6,BLOCK,-1,,<empty>,1,,1,1,,ANY
15,BLOCK,-1,,<empty>,1,,1,1,,ANY
26,BLOCK,-1,,<empty>,1,,1,1,,ANY
37,BLOCK,-1,,<empty>,1,,1,1,,ANY
48,BLOCK,-1,,<empty>,1,,1,1,,ANY
57,BLOCK,-1,,<empty>,1,,1,1,,ANY
64,BLOCK,-1,,"{
  CHECK_NOT_NULL(env_);
  async_context_ = EmitAsyncInit(isolate, resource, name,
                                 trigger_async_id);
}",36,,19,5,,void
77,BLOCK,-1,,"{
  EmitAsyncDestroy(env_, async_context_);
}",33,,25,1,,void
87,BLOCK,-1,,"{
  return node::MakeCallback(env_->isolate(), get_resource(),
                            callback, argc, argv,
                            async_context_);
}",67,,31,4,,void
108,BLOCK,-1,,"{
  return node::MakeCallback(env_->isolate(), get_resource(),
                            method, argc, argv,
                            async_context_);
}",67,,39,4,,void
129,BLOCK,-1,,"{
  return node::MakeCallback(env_->isolate(), get_resource(),
                            symbol, argc, argv,
                            async_context_);
}",67,,47,4,,void
147,BLOCK,-1,,"{
  return resource_.Get(env_->isolate());
}",45,,53,1,,void
160,BLOCK,-1,,"{
  return async_context_.async_id;
}",46,,57,1,,void
168,BLOCK,-1,,"{
  return async_context_.trigger_async_id;
}",54,,61,1,,void
177,BLOCK,-1,,<empty>,48,,68,2,,void
182,BLOCK,-1,,"{
    if (env_->is_stopping()) {
      MarkAsFailed();
      env_->async_hooks()->clear_async_id_stack();
    }
  }",39,,103,1,,void
188,BLOCK,-1,,"{
      MarkAsFailed();
      env_->async_hooks()->clear_async_id_stack();
    }",30,,104,2,,void
202,BLOCK,-1,,{ isolate->SetIdle(true); },34,,114,1,,void
213,BLOCK,-1,,{ env_->RunWeakRefCleanup(); },45,,133,1,,void
231,BLOCK,-1,,<empty>,1,,1,1,,ANY
237,BLOCK,-1,,<empty>,76,,22,4,,void
244,BLOCK,-1,,"{
  try_catch_.SetVerbose(true);
}",32,,30,4,,void
253,BLOCK,-1,,"{
  if (try_catch_.HasCaught())
    private_->MarkAsFailed();
  delete private_;
}",33,,34,1,,void
259,BLOCK,-1,,<empty>,5,,36,2,,void
271,BLOCK,-1,,<empty>,36,,45,3,,void
279,BLOCK,-1,,"{
  CHECK_NOT_NULL(env);
  env->PushAsyncCallbackScope();

  if (!env->can_call_into_js()) {
    failed_ = true;
    return;
  }

  Isolate* isolate = env->isolate();

  HandleScope handle_scope(isolate);
  Local<Context> current_context = isolate->GetCurrentContext();
  // If you hit this assertion, the caller forgot to enter the right Node.js
  // Environment's v8::Context first.
  // We first check `env->context() != current_context` because the contexts
  // likely *are* the same, in which case we can skip the slightly more
  // expensive Environment::GetCurrent() call.
  if (UNLIKELY(env->context() != current_context)) {
    CHECK_EQ(Environment::GetCurrent(isolate), env);
  }

  isolate->SetIdle(false);

  env->async_hooks()->push_async_context(
    async_context_.async_id, async_context_.trigger_async_id, object);

  pushed_ids_ = true;

  if (asyncContext.async_id != 0 && !skip_hooks_) {
    // No need to check a return value because the application will exit if
    // an ex...",48,,55,5,,void
292,BLOCK,-1,,"{
    failed_ = true;
    return;
  }",33,,59,2,,void
325,BLOCK,-1,,"{
    CHECK_EQ(Environment::GetCurrent(isolate), env);
  }",52,,73,2,,void
364,BLOCK,-1,,"{
    // No need to check a return value because the application will exit if
    // an exception occurs.
    AsyncWrap::EmitBefore(env, asyncContext.async_id);
  }",51,,84,2,,void
376,BLOCK,-1,,"{
  Close();
  env_->PopAsyncCallbackScope();
}",49,,91,1,,void
385,BLOCK,-1,,"{
  if (closed_) return;
  closed_ = true;

  // This function must ends up with either cleanup the
  // async id stack or pop the topmost one from it

  auto perform_stopping_check = [&]() {
    if (env_->is_stopping()) {
      MarkAsFailed();
      env_->async_hooks()->clear_async_id_stack();
    }
  };
  perform_stopping_check();

  if (env_->is_stopping()) return;

  Isolate* isolate = env_->isolate();
  auto idle = OnScopeLeave([&]() { isolate->SetIdle(true); });

  if (!failed_ && async_context_.async_id != 0 && !skip_hooks_) {
    AsyncWrap::EmitAfter(env_, async_context_.async_id);
  }

  if (pushed_ids_)
    env_->async_hooks()->pop_async_context(async_context_.async_id);

  if (failed_) return;

  if (env_->async_callback_scope_depth() > 1 || skip_task_queues_) {
    return;
  }

  TickInfo* tick_info = env_->tick_info();

  if (!env_->can_call_into_js()) return;

  auto weakref_cleanup = OnScopeLeave([&]() { env_->RunWeakRefCleanup(); });

  Local<Context> context = env_-...",37,,96,1,,void
388,BLOCK,-1,,<empty>,16,,97,2,,void
403,BLOCK,-1,,<empty>,28,,111,2,,void
428,BLOCK,-1,,"{
    AsyncWrap::EmitAfter(env_, async_context_.async_id);
  }",65,,116,2,,void
439,BLOCK,-1,,<empty>,5,,121,2,,void
452,BLOCK,-1,,<empty>,16,,123,2,,void
463,BLOCK,-1,,"{
    return;
  }",68,,125,2,,void
478,BLOCK,-1,,<empty>,34,,131,2,,void
501,BLOCK,-1,,"{
    context->GetMicrotaskQueue()->PerformCheckpoint(isolate);

    perform_stopping_check();
  }",41,,136,2,,void
523,BLOCK,-1,,"{
    CHECK_EQ(env_->execution_async_id(), 0);
    CHECK_EQ(env_->trigger_async_id(), 0);
  }",59,,144,2,,void
548,BLOCK,-1,,"{
    return;
  }",80,,149,2,,void
569,BLOCK,-1,,<empty>,34,,156,2,,void
599,BLOCK,-1,,"{
    failed_ = true;
  }",68,,164,2,,void
614,BLOCK,-1,,"{
  CHECK(!recv.IsEmpty());
#ifdef DEBUG
  for (int i = 0; i < argc; i++)
    CHECK(!argv[i].IsEmpty());
#endif

  Local<Function> hook_cb = env->async_hooks_callback_trampoline();
  int flags = InternalCallbackScope::kNoFlags;
  bool use_async_hooks_trampoline = false;
  AsyncHooks* async_hooks = env->async_hooks();
  if (!hook_cb.IsEmpty()) {
    // Use the callback trampoline if there are any before or after hooks, or
    // we can expect some kind of usage of async_hooks.executionAsyncResource().
    flags = InternalCallbackScope::kSkipAsyncHooks;
    use_async_hooks_trampoline =
        async_hooks->fields()[AsyncHooks::kBefore] +
        async_hooks->fields()[AsyncHooks::kAfter] +
        async_hooks->fields()[AsyncHooks::kUsesExecutionAsyncResource] > 0;
  }

  InternalCallbackScope scope(env, resource, asyncContext, flags);
  if (scope.Failed()) {
    return MaybeLocal<Value>();
  }

  MaybeLocal<Value> ret;

  Local<Context> context = env->context();
  if (use_async_hooks_t...",68,,176,8,,void
654,BLOCK,-1,,"{
    // Use the callback trampoline if there are any before or after hooks, or
    // we can expect some kind of usage of async_hooks.executionAsyncResource().
    flags = InternalCallbackScope::kSkipAsyncHooks;
    use_async_hooks_trampoline =
        async_hooks->fields()[AsyncHooks::kBefore] +
        async_hooks->fields()[AsyncHooks::kAfter] +
        async_hooks->fields()[AsyncHooks::kUsesExecutionAsyncResource] > 0;
  }",27,,187,2,,void
701,BLOCK,-1,,"{
    return MaybeLocal<Value>();
  }",23,,198,2,,void
721,BLOCK,-1,,"{
    MaybeStackBuffer<Local<Value>, 16> args(3 + argc);
    args[0] = v8::Number::New(env->isolate(), asyncContext.async_id);
    args[1] = resource;
    args[2] = callback;
    for (int i = 0; i < argc; i++) {
      args[i + 3] = argv[i];
    }
    ret = hook_cb->Call(context, recv, args.length(), &args[0]);
  }",35,,205,2,,void
755,BLOCK,-1,,<empty>,5,,210,1,,void
765,BLOCK,4,,"{
      args[i + 3] = argv[i];
    }",36,,210,4,,void
792,BLOCK,-1,,"{
    ret = callback->Call(context, recv, argc, argv);
  }",10,,214,1,,void
808,BLOCK,-1,,"{
    scope.MarkAsFailed();
    return MaybeLocal<Value>();
  }",22,,218,2,,void
824,BLOCK,-1,,"{
    return MaybeLocal<Value>();
  }",23,,224,2,,void
838,BLOCK,-1,,"{
  Local<String> method_string =
      String::NewFromUtf8(isolate, method).ToLocalChecked();
  return MakeCallback(isolate, recv, method_string, argc, argv, asyncContext);
}",60,,238,7,,void
871,BLOCK,-1,,"{
  // Check can_call_into_js() first because calling Get() might do so.
  Environment* env =
      Environment::GetCurrent(recv->GetCreationContext().ToLocalChecked());
  CHECK_NOT_NULL(env);
  if (!env->can_call_into_js()) return Local<Value>();

  Local<Value> callback_v;
  if (!recv->Get(isolate->GetCurrentContext(), symbol).ToLocal(&callback_v))
    return Local<Value>();
  if (!callback_v->IsFunction()) {
    // This used to return an empty value, but Undefined() makes more sense
    // since no exception is pending here.
    return Undefined(isolate);
  }
  Local<Function> callback = callback_v.As<Function>();
  return MakeCallback(isolate, recv, callback, argc, argv, asyncContext);
}",60,,249,7,,void
894,BLOCK,-1,,<empty>,33,,254,2,,void
918,BLOCK,-1,,<empty>,5,,258,2,,void
927,BLOCK,-1,,"{
    // This used to return an empty value, but Undefined() makes more sense
    // since no exception is pending here.
    return Undefined(isolate);
  }",34,,259,2,,void
958,BLOCK,-1,,"{
  // Observe the following two subtleties:
  //
  // 1. The environment is retrieved from the callback function's context.
  // 2. The context to enter is retrieved from the environment.
  //
  // Because of the AssignToContext() call in src/node_contextify.cc,
  // the two contexts need not be the same.
  Environment* env =
      Environment::GetCurrent(callback->GetCreationContext().ToLocalChecked());
  CHECK_NOT_NULL(env);
  Context::Scope context_scope(env->context());
  MaybeLocal<Value> ret =
      InternalMakeCallback(env, recv, recv, callback, argc, argv, asyncContext);
  if (ret.IsEmpty() && env->async_callback_scope_depth() == 0) {
    // This is only for legacy compatibility and we may want to look into
    // removing/adjusting it.
    return Undefined(isolate);
  }
  return ret;
}",60,,273,7,,void
1007,BLOCK,-1,,"{
    // This is only for legacy compatibility and we may want to look into
    // removing/adjusting it.
    return Undefined(isolate);
  }",64,,287,2,,void
1021,BLOCK,-1,,"{
  Environment* env =
      Environment::GetCurrent(callback->GetCreationContext().ToLocalChecked());
  CHECK_NOT_NULL(env);
  if (!env->can_call_into_js()) return Local<Value>();

  Local<Context> context = env->context();
  Context::Scope context_scope(context);
  if (env->async_callback_scope_depth()) {
    // There's another MakeCallback() on the stack, piggy back on it.
    // In particular, retain the current async_context.
    return callback->Call(context, recv, argc, argv);
  }

  // This is a toplevel invocation and the caller (intentionally)
  // didn't provide any async_context to run in. Install a default context.
  MaybeLocal<Value> ret =
    InternalMakeCallback(env, env->process_object(), recv, callback, argc, argv,
                         async_context{0, 0});
  return ret;
}",57,,303,6,,void
1044,BLOCK,-1,,<empty>,33,,307,2,,void
1065,BLOCK,-1,,"{
    // There's another MakeCallback() on the stack, piggy back on it.
    // In particular, retain the current async_context.
    return callback->Call(context, recv, argc, argv);
  }",42,,311,2,,void
1105,BLOCK,-1,,"{
  EscapableHandleScope handle_scope(isolate);
  return handle_scope.Escape(
      MakeCallback(isolate, recv, method, argc, argv, {0, 0})
          .FromMaybe(Local<Value>()));
}",47,,331,6,,void
1135,BLOCK,-1,,"{
  EscapableHandleScope handle_scope(isolate);
  return handle_scope.Escape(
      MakeCallback(isolate, recv, symbol, argc, argv, {0, 0})
          .FromMaybe(Local<Value>()));
}",47,,342,6,,void
1165,BLOCK,-1,,"{
  EscapableHandleScope handle_scope(isolate);
  return handle_scope.Escape(
      MakeCallback(isolate, recv, callback, argc, argv, {0, 0})
          .FromMaybe(Local<Value>()));
}",47,,353,6,,void
1192,BLOCK,-1,,{ realm->VerifyNoStrongBaseObjects(); },38,,75,2,,void
1202,BLOCK,-1,,"{
      if (bootstrapCatch.HasCaught()) {
        errors->push_back(FormatCaughtException(
            isolate, isolate->GetCurrentContext(), bootstrapCatch));
      }
    }",47,,136,1,,void
1208,BLOCK,-1,,"{
        errors->push_back(FormatCaughtException(
            isolate, isolate->GetCurrentContext(), bootstrapCatch));
      }",39,,137,2,,void
1227,BLOCK,-1,,"{
        return CreateEnvironment(
            setup->isolate_data(),
            setup->context(),
            args,
            exec_args,
            static_cast<EnvironmentFlags::Flags>(env_flags));
      }",64,,192,2,,void
1251,BLOCK,-1,,"{
      *static_cast<bool*>(data) = true;
    }",73,,217,2,,void
1271,BLOCK,-1,,<empty>,1,,1,1,,ANY
1275,BLOCK,-1,,"{
  CHECK_NOT_NULL(env);
  MultiIsolatePlatform* platform = GetMultiIsolatePlatform(env);
  CHECK_NOT_NULL(platform);

  Isolate* isolate = env->isolate();
  HandleScope handle_scope(isolate);
  Context::Scope context_scope(env->context());
  SealHandleScope seal(isolate);

  if (env->is_stopping()) return Nothing<ExitCode>();

  env->set_trace_sync_io(env->options()->trace_sync_io);
  {
    bool more;
    env->performance_state()->Mark(
        node::performance::NODE_PERFORMANCE_MILESTONE_LOOP_START);
    do {
      if (env->is_stopping()) break;
      uv_run(env->event_loop(), UV_RUN_DEFAULT);
      if (env->is_stopping()) break;

      platform->DrainTasks(isolate);

      more = uv_loop_alive(env->event_loop());
      if (more && !env->is_stopping()) continue;

      if (EmitProcessBeforeExit(env).IsNothing())
        break;

      {
        HandleScope handle_scope(isolate);
        if (env->RunSnapshotSerializeCallback().IsEmpty()) {
          break;
        }
      }

      ...",57,,22,2,,void
1309,BLOCK,-1,,<empty>,27,,32,2,,void
1322,BLOCK,15,,"{
    bool more;
    env->performance_state()->Mark(
        node::performance::NODE_PERFORMANCE_MILESTONE_LOOP_START);
    do {
      if (env->is_stopping()) break;
      uv_run(env->event_loop(), UV_RUN_DEFAULT);
      if (env->is_stopping()) break;

      platform->DrainTasks(isolate);

      more = uv_loop_alive(env->event_loop());
      if (more && !env->is_stopping()) continue;

      if (EmitProcessBeforeExit(env).IsNothing())
        break;

      {
        HandleScope handle_scope(isolate);
        if (env->RunSnapshotSerializeCallback().IsEmpty()) {
          break;
        }
      }

      // Emit `beforeExit` if the loop became alive either after emitting
      // event, or after running some callbacks.
      more = uv_loop_alive(env->event_loop());
    } while (more == true && !env->is_stopping());
    env->performance_state()->Mark(
        node::performance::NODE_PERFORMANCE_MILESTONE_LOOP_EXIT);
  }",3,,35,15,,void
1337,BLOCK,-1,,"{
      if (env->is_stopping()) break;
      uv_run(env->event_loop(), UV_RUN_DEFAULT);
      if (env->is_stopping()) break;

      platform->DrainTasks(isolate);

      more = uv_loop_alive(env->event_loop());
      if (more && !env->is_stopping()) continue;

      if (EmitProcessBeforeExit(env).IsNothing())
        break;

      {
        HandleScope handle_scope(isolate);
        if (env->RunSnapshotSerializeCallback().IsEmpty()) {
          break;
        }
      }

      // Emit `beforeExit` if the loop became alive either after emitting
      // event, or after running some callbacks.
      more = uv_loop_alive(env->event_loop());
    }",8,,39,1,,void
1343,BLOCK,-1,,<empty>,31,,40,2,,void
1356,BLOCK,-1,,<empty>,31,,42,2,,void
1378,BLOCK,-1,,<empty>,40,,47,2,,void
1386,BLOCK,-1,,<empty>,9,,50,2,,void
1388,BLOCK,8,,"{
        HandleScope handle_scope(isolate);
        if (env->RunSnapshotSerializeCallback().IsEmpty()) {
          break;
        }
      }",7,,52,8,,void
1400,BLOCK,-1,,"{
          break;
        }",60,,54,2,,void
1435,BLOCK,-1,,<empty>,27,,66,2,,void
1472,BLOCK,-1,,<empty>,,,,1,,<empty>
1486,BLOCK,-1,,"{
  CHECK_NOT_NULL(platform);
  CHECK_NOT_NULL(errors);

  impl_->platform = platform;
  uv_loop_t* loop = &impl_->loop;
  // Use `data` to tell the destructor whether the loop was initialized or not.
  loop->data = nullptr;
  int ret = uv_loop_init(loop);
  if (ret != 0) {
    errors->push_back(
        SPrintF(""Failed to initialize loop: %s"", uv_err_name(ret)));
    return;
  }
  loop->data = this;

  Isolate* isolate;
  if (flags & Flags::kIsForSnapshotting) {
    const std::vector<intptr_t>& external_references =
        SnapshotBuilder::CollectExternalReferences();
    isolate = impl_->isolate = Isolate::Allocate();
    // Must be done before the SnapshotCreator creation so  that the
    // memory reducer can be initialized.
    platform->RegisterIsolate(isolate, loop);
    impl_->snapshot_creator.emplace(isolate, external_references.data());
    isolate->SetCaptureStackTraceForUncaughtExceptions(
        true, 10, v8::StackTrace::StackTraceOptions::kDetailed);
    SetIsolateMi...",25,,96,6,,void
1517,BLOCK,-1,,"{
    errors->push_back(
        SPrintF(""Failed to initialize loop: %s"", uv_err_name(ret)));
    return;
  }",17,,105,2,,void
1541,BLOCK,-1,,"{
    const std::vector<intptr_t>& external_references =
        SnapshotBuilder::CollectExternalReferences();
    isolate = impl_->isolate = Isolate::Allocate();
    // Must be done before the SnapshotCreator creation so  that the
    // memory reducer can be initialized.
    platform->RegisterIsolate(isolate, loop);
    impl_->snapshot_creator.emplace(isolate, external_references.data());
    isolate->SetCaptureStackTraceForUncaughtExceptions(
        true, 10, v8::StackTrace::StackTraceOptions::kDetailed);
    SetIsolateMiscHandlers(isolate, {});
  }",42,,113,2,,void
1593,BLOCK,-1,,"{
    impl_->allocator = ArrayBufferAllocator::Create();
    isolate = impl_->isolate =
        NewIsolate(impl_->allocator, &impl_->loop, platform, snapshot_data);
  }",10,,124,1,,void
1618,BLOCK,13,,"{
    Locker locker(isolate);
    Isolate::Scope isolate_scope(isolate);
    HandleScope handle_scope(isolate);

    TryCatch bootstrapCatch(isolate);
    auto print_Exception = OnScopeLeave([&]() {
      if (bootstrapCatch.HasCaught()) {
        errors->push_back(FormatCaughtException(
            isolate, isolate->GetCurrentContext(), bootstrapCatch));
      }
    });

    impl_->isolate_data.reset(CreateIsolateData(
        isolate, loop, platform, impl_->allocator.get(), snapshot_data));
    impl_->isolate_data->set_is_building_snapshot(
        impl_->snapshot_creator.has_value());

    if (snapshot_data) {
      impl_->env.reset(make_env(this));
      if (impl_->env) {
        impl_->main_context.Reset(isolate, impl_->env->context());
      }
      return;
    }

    Local<Context> context = NewContext(isolate);
    impl_->main_context.Reset(isolate, context);
    if (context.IsEmpty()) {
      errors->push_back(""Failed to initialize V8 Context"");
      return;
    }

    Cont...",3,,130,13,,void
1666,BLOCK,-1,,"{
      impl_->env.reset(make_env(this));
      if (impl_->env) {
        impl_->main_context.Reset(isolate, impl_->env->context());
      }
      return;
    }",24,,148,2,,void
1679,BLOCK,-1,,"{
        impl_->main_context.Reset(isolate, impl_->env->context());
      }",23,,150,2,,void
1715,BLOCK,-1,,"{
      errors->push_back(""Failed to initialize V8 Context"");
      return;
    }",28,,158,2,,void
1739,BLOCK,-1,,<empty>,74,,172,4,,void
1745,BLOCK,-1,,"{
  // It's not guaranteed that a context that goes through
  // v8_inspector::V8Inspector::contextCreated() is runtime-independent,
  // so do not start the inspector on the main context when building
  // the default snapshot.
  uint64_t env_flags =
      EnvironmentFlags::kDefaultFlags | EnvironmentFlags::kNoCreateInspector;

  auto ret = std::unique_ptr<CommonEnvironmentSetup>(new CommonEnvironmentSetup(
      platform,
      errors,
      nullptr,
      true,
      [&](const CommonEnvironmentSetup* setup) -> Environment* {
        return CreateEnvironment(
            setup->isolate_data(),
            setup->context(),
            args,
            exec_args,
            static_cast<EnvironmentFlags::Flags>(env_flags));
      }));
  if (!errors->empty()) ret.reset();
  return ret;
}",48,,179,5,,void
1777,BLOCK,-1,,<empty>,25,,200,2,,void
1787,BLOCK,-1,,"{
  if (impl_->isolate != nullptr) {
    Isolate* isolate = impl_->isolate;
    {
      Locker locker(isolate);
      Isolate::Scope isolate_scope(isolate);

      impl_->main_context.Reset();
      impl_->env.reset();
      impl_->isolate_data.reset();
    }

    bool platform_finished = false;
    impl_->platform->AddIsolateFinishedCallback(isolate, [](void* data) {
      *static_cast<bool*>(data) = true;
    }, &platform_finished);
    impl_->platform->UnregisterIsolate(isolate);
    if (impl_->snapshot_creator.has_value())
      impl_->snapshot_creator.reset();
    else
      isolate->Dispose();

    // Wait until the platform has cleaned up all relevant resources.
    while (!platform_finished)
      uv_run(&impl_->loop, UV_RUN_ONCE);
  }

  if (impl_->isolate || impl_->loop.data != nullptr)
    CheckedUvLoopClose(&impl_->loop);

  delete impl_;
}",51,,204,1,,void
1794,BLOCK,-1,,"{
    Isolate* isolate = impl_->isolate;
    {
      Locker locker(isolate);
      Isolate::Scope isolate_scope(isolate);

      impl_->main_context.Reset();
      impl_->env.reset();
      impl_->isolate_data.reset();
    }

    bool platform_finished = false;
    impl_->platform->AddIsolateFinishedCallback(isolate, [](void* data) {
      *static_cast<bool*>(data) = true;
    }, &platform_finished);
    impl_->platform->UnregisterIsolate(isolate);
    if (impl_->snapshot_creator.has_value())
      impl_->snapshot_creator.reset();
    else
      isolate->Dispose();

    // Wait until the platform has cleaned up all relevant resources.
    while (!platform_finished)
      uv_run(&impl_->loop, UV_RUN_ONCE);
  }",34,,205,2,,void
1801,BLOCK,3,,"{
      Locker locker(isolate);
      Isolate::Scope isolate_scope(isolate);

      impl_->main_context.Reset();
      impl_->env.reset();
      impl_->isolate_data.reset();
    }",5,,207,3,,void
1854,BLOCK,-1,,<empty>,7,,222,2,,void
1862,BLOCK,-1,,<empty>,7,,224,1,,void
1888,BLOCK,-1,,<empty>,5,,232,2,,void
1899,BLOCK,-1,,"{
  CHECK_NOT_NULL(snapshot_creator());
  SnapshotData* snapshot_data = new SnapshotData();
  EmbedderSnapshotData::Pointer result{
      new EmbedderSnapshotData(snapshot_data, true)};

  auto exit_code = SnapshotBuilder::CreateSnapshot(
      snapshot_data,
      this,
      static_cast<uint8_t>(SnapshotMetadata::Type::kFullyCustomized));
  if (exit_code != ExitCode::kNoFailure) return {};

  return result;
}",72,,237,1,,void
1937,BLOCK,-1,,<empty>,42,,247,2,,void
1945,BLOCK,-1,,"{
  Maybe<ExitCode> result = SpinEventLoopInternal(env);
  if (result.IsNothing()) {
    return Nothing<int>();
  }
  return Just(static_cast<int>(result.FromJust()));
}",44,,252,2,,void
1959,BLOCK,-1,,"{
    return Nothing<int>();
  }",27,,254,2,,void
1973,BLOCK,-1,,"{
  return &impl_->loop;
}",55,,260,1,,void
1982,BLOCK,-1,,"{
  return impl_->allocator;
}",56,,265,1,,void
1990,BLOCK,-1,,"{
  return impl_->isolate;
}",50,,269,1,,void
1998,BLOCK,-1,,"{
  return impl_->isolate_data.get();
}",59,,273,1,,void
2009,BLOCK,-1,,"{
  return impl_->env.get();
}",50,,277,1,,void
2020,BLOCK,-1,,"{
  return impl_->main_context.Get(impl_->isolate);
}",64,,281,1,,void
2034,BLOCK,-1,,"{
  return impl_->snapshot_creator ? &impl_->snapshot_creator.value() : nullptr;
}",65,,285,1,,void
2052,BLOCK,-1,,"{
  CHECK_IMPLIES(data->owns_impl_, data->impl_);
  if (data->owns_impl_ &&
      data->impl_->data_ownership == SnapshotData::DataOwnership::kOwned) {
    delete data->impl_;
  }
  delete data;
}",45,,290,2,,void
2076,BLOCK,-1,,"{
    delete data->impl_;
  }",75,,293,2,,void
2086,BLOCK,-1,,"{
  return EmbedderSnapshotData::Pointer{new EmbedderSnapshotData(
      SnapshotBuilder::GetEmbeddedSnapshotData(), false)};
}",75,,299,1,,void
2101,BLOCK,-1,,"{
  SnapshotData* snapshot_data = new SnapshotData();
  CHECK_EQ(snapshot_data->data_ownership, SnapshotData::DataOwnership::kOwned);
  EmbedderSnapshotData::Pointer result{
      new EmbedderSnapshotData(snapshot_data, true)};
  if (!SnapshotData::FromBlob(snapshot_data, in)) {
    return {};
  }
  return result;
}",34,,305,2,,void
2132,BLOCK,-1,,"{
    return {};
  }",51,,310,2,,void
2140,BLOCK,-1,,"{
  return FromBlob(ReadFileSync(in));
}",72,,316,2,,void
2148,BLOCK,-1,,"{
  return impl_->ToBlob();
}",56,,320,1,,void
2158,BLOCK,-1,,"{
  impl_->ToFile(out);
}",52,,324,2,,void
2169,BLOCK,-1,,<empty>,42,,330,3,,void
2173,BLOCK,-1,,"{
#ifdef NODE_V8_SHARED_RO_HEAP
  return false;
#else
  return true;
#endif
}",61,,332,1,,void
2190,BLOCK,-1,,<empty>,1,,1,1,,ANY
2195,BLOCK,-1,,"{
  switch (encoding[0]) {
    case 'u':
    case 'U':
      // Note: the two first conditions are needed for performance reasons
      // as ""utf8""/""utf-8"" is a common case.
      // (same for other cases below)

      // utf8, utf16le
      if (encoding[1] == 't' && encoding[2] == 'f') {
        // Skip `-`
        const size_t skip = encoding[3] == '-' ? 4 : 3;
        if (encoding[skip] == '8' && encoding[skip + 1] == '\0')
          return UTF8;
        if (strncmp(encoding + skip, ""16le"", 5) == 0)
          return UCS2;
      // ucs2
      } else if (encoding[1] == 'c' && encoding[2] == 's') {
        const size_t skip = encoding[3] == '-' ? 4 : 3;
        if (encoding[skip] == '2' && encoding[skip + 1] == '\0')
          return UCS2;
      }
      if (StringEqualNoCase(encoding, ""utf8""))
        return UTF8;
      if (StringEqualNoCase(encoding, ""utf-8""))
        return UTF8;
      if (StringEqualNoCase(encoding, ""ucs2""))
        return UCS2;
      if (StringEqualNoCase(encod...",61,,14,3,,void
2200,BLOCK,-1,,"{
    case 'u':
    case 'U':
      // Note: the two first conditions are needed for performance reasons
      // as ""utf8""/""utf-8"" is a common case.
      // (same for other cases below)

      // utf8, utf16le
      if (encoding[1] == 't' && encoding[2] == 'f') {
        // Skip `-`
        const size_t skip = encoding[3] == '-' ? 4 : 3;
        if (encoding[skip] == '8' && encoding[skip + 1] == '\0')
          return UTF8;
        if (strncmp(encoding + skip, ""16le"", 5) == 0)
          return UCS2;
      // ucs2
      } else if (encoding[1] == 'c' && encoding[2] == 's') {
        const size_t skip = encoding[3] == '-' ? 4 : 3;
        if (encoding[skip] == '2' && encoding[skip + 1] == '\0')
          return UCS2;
      }
      if (StringEqualNoCase(encoding, ""utf8""))
        return UTF8;
      if (StringEqualNoCase(encoding, ""utf-8""))
        return UTF8;
      if (StringEqualNoCase(encoding, ""ucs2""))
        return UCS2;
      if (StringEqualNoCase(encoding, ""ucs-2""))
        re...",24,,15,2,,void
2217,BLOCK,-1,,"{
        // Skip `-`
        const size_t skip = encoding[3] == '-' ? 4 : 3;
        if (encoding[skip] == '8' && encoding[skip + 1] == '\0')
          return UTF8;
        if (strncmp(encoding + skip, ""16le"", 5) == 0)
          return UCS2;
      // ucs2
      }",53,,23,2,,void
2243,BLOCK,-1,,<empty>,11,,27,2,,void
2255,BLOCK,-1,,<empty>,11,,29,2,,void
2259,BLOCK,-1,,<empty>,14,,31,1,,void
2272,BLOCK,-1,,"{
        const size_t skip = encoding[3] == '-' ? 4 : 3;
        if (encoding[skip] == '2' && encoding[skip + 1] == '\0')
          return UCS2;
      }",60,,31,2,,void
2298,BLOCK,-1,,<empty>,11,,34,2,,void
2305,BLOCK,-1,,<empty>,9,,37,2,,void
2312,BLOCK,-1,,<empty>,9,,39,2,,void
2319,BLOCK,-1,,<empty>,9,,41,2,,void
2326,BLOCK,-1,,<empty>,9,,43,2,,void
2333,BLOCK,-1,,<empty>,9,,45,2,,void
2340,BLOCK,-1,,<empty>,9,,47,2,,void
2354,BLOCK,-1,,"{
        if (strncmp(encoding + 2, ""tin1"", 5) == 0)
          return LATIN1;
      }",31,,53,2,,void
2364,BLOCK,-1,,<empty>,11,,55,2,,void
2371,BLOCK,-1,,<empty>,9,,58,2,,void
2385,BLOCK,-1,,"{
        if (strncmp(encoding + 2, ""nary"", 5) == 0)
          return LATIN1;
      // buffer
      }",31,,64,2,,void
2395,BLOCK,-1,,<empty>,11,,66,2,,void
2399,BLOCK,-1,,<empty>,14,,68,1,,void
2406,BLOCK,-1,,"{
        if (strncmp(encoding + 2, ""ffer"", 5) == 0)
          return BUFFER;
      // base64
      }",38,,68,2,,void
2416,BLOCK,-1,,<empty>,11,,70,2,,void
2420,BLOCK,-1,,<empty>,14,,72,1,,void
2427,BLOCK,-1,,"{
        if (strncmp(encoding + 2, ""se64"", 5) == 0)
          return BASE64;
        if (strncmp(encoding + 2, ""se64url"", 8) == 0)
          return BASE64URL;
      }",38,,72,2,,void
2437,BLOCK,-1,,<empty>,11,,74,2,,void
2449,BLOCK,-1,,<empty>,11,,76,2,,void
2456,BLOCK,-1,,<empty>,9,,79,2,,void
2463,BLOCK,-1,,<empty>,9,,81,2,,void
2470,BLOCK,-1,,<empty>,9,,83,2,,void
2477,BLOCK,-1,,<empty>,9,,85,2,,void
2491,BLOCK,-1,,"{
        if (strncmp(encoding + 2, ""cii"", 4) == 0)
          return ASCII;
      }",31,,91,2,,void
2501,BLOCK,-1,,<empty>,11,,93,2,,void
2508,BLOCK,-1,,<empty>,9,,96,2,,void
2522,BLOCK,-1,,<empty>,9,,103,2,,void
2535,BLOCK,-1,,<empty>,11,,104,2,,void
2542,BLOCK,-1,,<empty>,9,,106,2,,void
2554,BLOCK,-1,,"{
  CHECK(!encoding_v.IsEmpty());

  if (!encoding_v->IsString())
    return default_encoding;

  Utf8Value encoding(isolate, encoding_v);

  return ParseEncoding(*encoding, default_encoding);
}",61,,115,4,,void
2567,BLOCK,-1,,<empty>,5,,119,2,,void
2586,BLOCK,-1,,"{
  CHECK_NE(encoding, UCS2);
  Local<Value> error;
  return StringBytes::Encode(isolate, buf, len, encoding, &error)
      .ToLocalChecked();
}",45,,129,5,,void
2615,BLOCK,-1,,"{
  Local<Value> error;
  return StringBytes::Encode(isolate, buf, len, &error)
      .ToLocalChecked();
}",72,,136,4,,void
2640,BLOCK,-1,,"{
  HandleScope scope(isolate);

  return StringBytes::Size(isolate, val, encoding).FromMaybe(-1);
}",45,,145,4,,void
2665,BLOCK,-1,,"{
  return StringBytes::Write(isolate, buf, buflen, val, encoding);
}",45,,156,6,,void
2681,BLOCK,-1,,"{
        Local<Value> main_script =
            ToV8Value(env->context(), main_script_source_utf8).ToLocalChecked();
        return info.run_cjs->Call(
            env->context(), Null(env->isolate()), 1, &main_script);
      }",77,,556,2,,void
2725,BLOCK,-1,,"{
    movedHandler(env, static_cast<int>(exit_code));
  }",75,,932,3,,void
2771,BLOCK,-1,,<empty>,1,,1,1,,ANY
2776,BLOCK,-1,,"{
  Local<Value> wasm_code_gen =
      context->GetEmbedderData(ContextEmbedderIndex::kAllowWasmCodeGeneration);
  return wasm_code_gen->IsUndefined() || wasm_code_gen->IsTrue();
}",53,,48,3,,void
2804,BLOCK,-1,,"{
  DebugSealHandleScope scope(isolate);
  Environment* env = Environment::GetCurrent(isolate);
  return env != nullptr &&
         (env->is_main_thread() || !env->is_stopping()) &&
         env->abort_on_uncaught_exception() &&
         env->should_abort_on_uncaught_toggle()[0] &&
         !env->inside_should_not_abort_on_uncaught_scope();
}",55,,54,2,,void
2855,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  if (env == nullptr) {
    return exception->ToString(context).FromMaybe(Local<Value>());
  }
  Realm* realm = Realm::GetCurrent(context);
  Local<Function> prepare;
  if (realm != nullptr) {
    // If we are in a Realm, call the realm specific prepareStackTrace callback
    // to avoid passing the JS objects (the exception and trace) across the
    // realm boundary with the `Error.prepareStackTrace` override.
    prepare = realm->prepare_stack_trace_callback();
  } else {
    // The context is created with ContextifyContext, call the principal
    // realm's prepareStackTrace callback.
    prepare = env->principal_realm()->prepare_stack_trace_callback();
  }
  if (prepare.IsEmpty()) {
    return exception->ToString(context).FromMaybe(Local<Value>());
  }
  Local<Value> args[] = {
      context->Global(),
      exception,
      trace,
  };
  // This TryCatch + Rethrow is required by V8 due to details around exception
  // ha...",65,,66,4,,void
2868,BLOCK,-1,,"{
    return exception->ToString(context).FromMaybe(Local<Value>());
  }",23,,68,2,,void
2896,BLOCK,-1,,"{
    // If we are in a Realm, call the realm specific prepareStackTrace callback
    // to avoid passing the JS objects (the exception and trace) across the
    // realm boundary with the `Error.prepareStackTrace` override.
    prepare = realm->prepare_stack_trace_callback();
  }",25,,73,2,,void
2904,BLOCK,-1,,"{
    // The context is created with ContextifyContext, call the principal
    // realm's prepareStackTrace callback.
    prepare = env->principal_realm()->prepare_stack_trace_callback();
  }",10,,78,1,,void
2919,BLOCK,-1,,"{
    return exception->ToString(context).FromMaybe(Local<Value>());
  }",26,,83,2,,void
2973,BLOCK,-1,,"{
    try_catch.ReThrow();
  }",60,,98,2,,void
2984,BLOCK,-1,,"{
  void* ret;
  if (zero_fill_field_ || per_process::cli_options->zero_fill_all_buffers)
    ret = allocator_->Allocate(size);
  else
    ret = allocator_->AllocateUninitialized(size);
  if (LIKELY(ret != nullptr))
    total_mem_usage_.fetch_add(size, std::memory_order_relaxed);
  return ret;
}",55,,104,2,,void
2994,BLOCK,-1,,<empty>,5,,107,2,,void
3003,BLOCK,-1,,<empty>,5,,109,1,,void
3016,BLOCK,-1,,<empty>,5,,111,2,,void
3031,BLOCK,-1,,"{
  void* ret = allocator_->AllocateUninitialized(size);
  if (LIKELY(ret != nullptr))
    total_mem_usage_.fetch_add(size, std::memory_order_relaxed);
  return ret;
}",68,,115,2,,void
3045,BLOCK,-1,,<empty>,5,,118,2,,void
3062,BLOCK,-1,,"{
  void* ret = allocator_->Reallocate(data, old_size, size);
  if (LIKELY(ret != nullptr) || UNLIKELY(size == 0))
    total_mem_usage_.fetch_add(size - old_size, std::memory_order_relaxed);
  return ret;
}",47,,123,4,,void
3083,BLOCK,-1,,<empty>,5,,126,2,,void
3101,BLOCK,-1,,"{
  total_mem_usage_.fetch_sub(size, std::memory_order_relaxed);
  allocator_->Free(data, size);
}",62,,130,3,,void
3119,BLOCK,-1,,"{
  CHECK(allocations_.empty());
}",65,,135,1,,void
3129,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  void* data = NodeArrayBufferAllocator::Allocate(size);
  RegisterPointerInternal(data, size);
  return data;
}",60,,139,2,,void
3150,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  void* data = NodeArrayBufferAllocator::AllocateUninitialized(size);
  RegisterPointerInternal(data, size);
  return data;
}",73,,146,2,,void
3172,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  UnregisterPointerInternal(data, size);
  NodeArrayBufferAllocator::Free(data, size);
}",67,,153,3,,void
3191,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  void* ret = NodeArrayBufferAllocator::Reallocate(data, old_size, size);
  if (ret == nullptr) {
    if (size == 0) {  // i.e. equivalent to free().
      // suppress coverity warning as data is used as key versus as pointer
      // in UnregisterPointerInternal
      // coverity[pass_freed_arg]
      UnregisterPointerInternal(data, old_size);
    }
    return nullptr;
  }

  if (data != nullptr) {
    auto it = allocations_.find(data);
    CHECK_NE(it, allocations_.end());
    allocations_.erase(it);
  }

  RegisterPointerInternal(ret, size);
  return ret;
}",62,,161,4,,void
3209,BLOCK,-1,,"{
    if (size == 0) {  // i.e. equivalent to free().
      // suppress coverity warning as data is used as key versus as pointer
      // in UnregisterPointerInternal
      // coverity[pass_freed_arg]
      UnregisterPointerInternal(data, old_size);
    }
    return nullptr;
  }",23,,164,2,,void
3214,BLOCK,-1,,"{  // i.e. equivalent to free().
      // suppress coverity warning as data is used as key versus as pointer
      // in UnregisterPointerInternal
      // coverity[pass_freed_arg]
      UnregisterPointerInternal(data, old_size);
    }",20,,165,2,,void
3224,BLOCK,-1,,"{
    auto it = allocations_.find(data);
    CHECK_NE(it, allocations_.end());
    allocations_.erase(it);
  }",24,,174,2,,void
3254,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  NodeArrayBufferAllocator::RegisterPointer(data, size);
  RegisterPointerInternal(data, size);
}",78,,184,3,,void
3272,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  NodeArrayBufferAllocator::UnregisterPointer(data, size);
  UnregisterPointerInternal(data, size);
}",80,,190,3,,void
3290,BLOCK,-1,,"{
  if (data == nullptr) return;
  auto it = allocations_.find(data);
  CHECK_NE(it, allocations_.end());
  if (size > 0) {
    // We allow allocations with size 1 for 0-length buffers to avoid having
    // to deal with nullptr values.
    CHECK_EQ(it->second, size);
  }
  allocations_.erase(it);
}",76,,197,3,,void
3295,BLOCK,-1,,<empty>,24,,198,2,,void
3315,BLOCK,-1,,"{
    // We allow allocations with size 1 for 0-length buffers to avoid having
    // to deal with nullptr values.
    CHECK_EQ(it->second, size);
  }",17,,201,2,,void
3331,BLOCK,-1,,"{
  if (data == nullptr) return;
  CHECK_EQ(allocations_.count(data), 0);
  allocations_[data] = size;
}",74,,210,3,,void
3336,BLOCK,-1,,<empty>,24,,211,2,,void
3354,BLOCK,-1,,"{
  if (debug || per_process::cli_options->debug_arraybuffer_allocations)
    return std::make_unique<DebuggingArrayBufferAllocator>();
  else
    return std::make_unique<NodeArrayBufferAllocator>();
}",80,,216,2,,void
3363,BLOCK,-1,,<empty>,5,,218,2,,void
3370,BLOCK,-1,,<empty>,5,,220,1,,void
3379,BLOCK,-1,,"{
  return ArrayBufferAllocator::Create().release();
}",52,,223,1,,void
3392,BLOCK,-1,,"{
  delete allocator;
}",64,,227,2,,void
3399,BLOCK,-1,,"{
  const uint64_t constrained_memory = uv_get_constrained_memory();
  const uint64_t total_memory = constrained_memory > 0 ?
      std::min(uv_get_total_memory(), constrained_memory) :
      uv_get_total_memory();
  if (total_memory > 0 &&
      params->constraints.max_old_generation_size_in_bytes() == 0) {
    // V8 defaults to 700MB or 1.4GB on 32 and 64 bit platforms respectively.
    // This default is based on browser use-cases. Tell V8 to configure the
    // heap based on the actual physical memory.
    params->constraints.ConfigureDefaults(total_memory, 0);
  }
  params->embedder_wrapper_object_index = BaseObject::InternalFields::kSlot;
  params->embedder_wrapper_type_index = std::numeric_limits<int>::max();

#ifdef NODE_ENABLE_VTUNE_PROFILING
  params->code_event_handler = vTune::GetVtuneCodeEventHandler();
#endif
}",67,,231,2,,void
3431,BLOCK,-1,,"{
    // V8 defaults to 700MB or 1.4GB on 32 and 64 bit platforms respectively.
    // This default is based on browser use-cases. Tell V8 to configure the
    // heap based on the actual physical memory.
    params->constraints.ConfigureDefaults(total_memory, 0);
  }",68,,237,2,,void
3464,BLOCK,-1,,"{
  if (s.flags & MESSAGE_LISTENER_WITH_ERROR_LEVEL)
    isolate->AddMessageListenerWithErrorLevel(
            errors::PerIsolateMessageListener,
            Isolate::MessageErrorLevel::kMessageError |
                Isolate::MessageErrorLevel::kMessageWarning);

  auto* abort_callback = s.should_abort_on_uncaught_exception_callback ?
      s.should_abort_on_uncaught_exception_callback :
      ShouldAbortOnUncaughtException;
  isolate->SetAbortOnUncaughtExceptionCallback(abort_callback);

  auto* fatal_error_cb = s.fatal_error_callback ?
      s.fatal_error_callback : OnFatalError;
  isolate->SetFatalErrorHandler(fatal_error_cb);
  isolate->SetOOMErrorHandler(OOMErrorHandler);

  if ((s.flags & SHOULD_NOT_SET_PREPARE_STACK_TRACE_CALLBACK) == 0) {
    auto* prepare_stack_trace_cb = s.prepare_stack_trace_callback ?
        s.prepare_stack_trace_callback : PrepareStackTraceCallback;
    isolate->SetPrepareStackTraceCallback(prepare_stack_trace_cb);
  }
}",78,,251,3,,void
3471,BLOCK,-1,,<empty>,5,,253,2,,void
3535,BLOCK,-1,,"{
    auto* prepare_stack_trace_cb = s.prepare_stack_trace_callback ?
        s.prepare_stack_trace_callback : PrepareStackTraceCallback;
    isolate->SetPrepareStackTraceCallback(prepare_stack_trace_cb);
  }",69,,268,2,,void
3557,BLOCK,-1,,"{
  isolate->SetMicrotasksPolicy(s.policy);

  auto* allow_wasm_codegen_cb = s.allow_wasm_code_generation_callback ?
    s.allow_wasm_code_generation_callback : AllowWasmCodeGenerationCallback;
  isolate->SetAllowWasmCodeGenerationCallback(allow_wasm_codegen_cb);

  auto* modify_code_generation_from_strings_callback =
      ModifyCodeGenerationFromStrings;
  if (s.modify_code_generation_from_strings_callback != nullptr) {
    modify_code_generation_from_strings_callback =
        s.modify_code_generation_from_strings_callback;
  }
  isolate->SetModifyCodeGenerationFromStringsCallback(
      modify_code_generation_from_strings_callback);

  Mutex::ScopedLock lock(node::per_process::cli_options_mutex);
  if (per_process::cli_options->get_per_isolate_options()
          ->get_per_env_options()
          ->experimental_fetch) {
    isolate->SetWasmStreamingCallback(wasm_web_api::StartStreamingCompilation);
  }

  if (per_process::cli_options->get_per_isolate_options()
          ->experi...",77,,275,3,,void
3591,BLOCK,-1,,"{
    modify_code_generation_from_strings_callback =
        s.modify_code_generation_from_strings_callback;
  }",66,,284,2,,void
3621,BLOCK,-1,,"{
    isolate->SetWasmStreamingCallback(wasm_web_api::StartStreamingCompilation);
  }",33,,294,2,,void
3638,BLOCK,-1,,"{
    isolate->SetHostCreateShadowRealmContextCallback(
        shadow_realm::HostCreateShadowRealmContextCallback);
  }",40,,299,2,,void
3654,BLOCK,-1,,"{
    auto* promise_reject_cb = s.promise_reject_callback ?
      s.promise_reject_callback : PromiseRejectCallback;
    isolate->SetPromiseRejectCallback(promise_reject_cb);
  }",67,,304,2,,void
3677,BLOCK,-1,,<empty>,5,,311,2,,void
3690,BLOCK,-1,,"{
  SetIsolateErrorHandlers(isolate, settings);
  SetIsolateMiscHandlers(isolate, settings);
}",59,,315,3,,void
3701,BLOCK,-1,,"{
  IsolateSettings settings;
  SetIsolateUpForNode(isolate, settings);
}",48,,320,2,,void
3714,BLOCK,-1,,"{
  Isolate* isolate = Isolate::Allocate();
  if (isolate == nullptr) return nullptr;

  if (snapshot_data != nullptr) {
    SnapshotBuilder::InitializeIsolateParams(snapshot_data, params);
  }

#ifdef NODE_V8_SHARED_RO_HEAP
  {
    // In shared-readonly-heap mode, V8 requires all snapshots used for
    // creating Isolates to be identical. This isn't really memory-safe
    // but also otherwise just doesn't work, and the only real alternative
    // is disabling shared-readonly-heap mode altogether.
    static Isolate::CreateParams first_params = *params;
    params->snapshot_blob = first_params.snapshot_blob;
    params->external_references = first_params.external_references;
  }
#endif

  // Register the isolate on the platform before the isolate gets initialized,
  // so that the isolate can access the platform during initialization.
  platform->RegisterIsolate(isolate, event_loop);

  SetIsolateCreateParamsForNode(params);
  Isolate::Initialize(isolate, *params);
  if (snapshot...",54,,331,6,,void
3726,BLOCK,-1,,<empty>,27,,333,2,,void
3733,BLOCK,-1,,"{
    SnapshotBuilder::InitializeIsolateParams(snapshot_data, params);
  }",33,,335,2,,void
3759,BLOCK,-1,,"{
    // If in deserialize mode, delay until after the deserialization is
    // complete.
    SetIsolateUpForNode(isolate, settings);
  }",33,,357,2,,void
3764,BLOCK,-1,,"{
    SetIsolateMiscHandlers(isolate, settings);
  }",10,,361,1,,void
3778,BLOCK,-1,,"{
  Isolate::CreateParams params;
  if (allocator != nullptr) params.array_buffer_allocator = allocator;
  return NewIsolate(&params,
                    event_loop,
                    platform,
                    SnapshotData::FromEmbedderWrapper(snapshot_data),
                    settings);
}",54,,372,6,,void
3784,BLOCK,-1,,<empty>,29,,374,2,,void
3810,BLOCK,-1,,"{
  Isolate::CreateParams params;
  if (allocator) params.array_buffer_allocator_shared = allocator;
  return NewIsolate(&params,
                    event_loop,
                    platform,
                    SnapshotData::FromEmbedderWrapper(snapshot_data),
                    settings);
}",54,,386,6,,void
3814,BLOCK,-1,,<empty>,18,,388,2,,void
3840,BLOCK,-1,,"{
  const SnapshotData* snapshot_data =
      SnapshotData::FromEmbedderWrapper(embedder_snapshot_data);
  return new IsolateData(isolate, loop, platform, allocator, snapshot_data);
}",57,,401,6,,void
3861,BLOCK,-1,,"{
  delete isolate_data;
}",49,,407,2,,void
3867,BLOCK,-1,,<empty>,49,,411,1,,void
3878,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();
  HandleScope handle_scope(isolate);

  const bool use_snapshot = context.IsEmpty();
  const EnvSerializeInfo* env_snapshot_info = nullptr;
  if (use_snapshot) {
    CHECK_NOT_NULL(isolate_data->snapshot_data());
    env_snapshot_info = &isolate_data->snapshot_data()->env_info;
  }

  // TODO(addaleax): This is a much better place for parsing per-Environment
  // options than the global parse call.
  Environment* env = new Environment(isolate_data,
                                     isolate,
                                     args,
                                     exec_args,
                                     env_snapshot_info,
                                     flags,
                                     thread_id);
  CHECK_NOT_NULL(env);

  if (use_snapshot) {
    context = Context::FromSnapshot(isolate,
                                    SnapshotData::kNodeMainContextIndex,
                                    {Deseriali...",69,,431,8,,void
3902,BLOCK,-1,,"{
    CHECK_NOT_NULL(isolate_data->snapshot_data());
    env_snapshot_info = &isolate_data->snapshot_data()->env_info;
  }",21,,437,2,,void
3933,BLOCK,-1,,"{
    context = Context::FromSnapshot(isolate,
                                    SnapshotData::kNodeMainContextIndex,
                                    {DeserializeNodeInternalFields, env})
                  .ToLocalChecked();

    CHECK(!context.IsEmpty());
    Context::Scope context_scope(context);

    if (InitializeContextRuntime(context).IsNothing()) {
      FreeEnvironment(env);
      return nullptr;
    }
    SetIsolateErrorHandlers(isolate, {});
  }",21,,453,2,,void
3965,BLOCK,-1,,"{
      FreeEnvironment(env);
      return nullptr;
    }",56,,462,2,,void
3996,BLOCK,-1,,"{
    FreeEnvironment(env);
    return nullptr;
  }",78,,484,2,,void
4007,BLOCK,-1,,"{
  Isolate* isolate = env->isolate();
  Isolate::DisallowJavascriptExecutionScope disallow_js(isolate,
      Isolate::DisallowJavascriptExecutionScope::THROW_ON_FAILURE);
  {
    HandleScope handle_scope(isolate);  // For env->context().
    Context::Scope context_scope(env->context());
    SealHandleScope seal_handle_scope(isolate);

    // Set the flag in accordance with the DisallowJavascriptExecutionScope
    // above.
    env->set_can_call_into_js(false);
    env->set_stopping(true);
    env->stop_sub_worker_contexts();
    env->RunCleanup();
    RunAtExit(env);
  }

  // This call needs to be made while the `Environment` is still alive
  // because we assume that it is available for async tracking in the
  // NodePlatform implementation.
  MultiIsolatePlatform* platform = env->isolate_data()->platform();
  if (platform != nullptr)
    platform->DrainTasks(isolate);

  delete env;
}",40,,492,2,,void
4023,BLOCK,5,,"{
    HandleScope handle_scope(isolate);  // For env->context().
    Context::Scope context_scope(env->context());
    SealHandleScope seal_handle_scope(isolate);

    // Set the flag in accordance with the DisallowJavascriptExecutionScope
    // above.
    env->set_can_call_into_js(false);
    env->set_stopping(true);
    env->stop_sub_worker_contexts();
    env->RunCleanup();
    RunAtExit(env);
  }",3,,496,5,,void
4070,BLOCK,-1,,<empty>,5,,515,2,,void
4084,BLOCK,-1,,"{
  return GetInspectorParentHandle(env, thread_id, url, """");
}",22,,523,4,,void
4098,BLOCK,-1,,"{
  CHECK_NOT_NULL(env);
  if (name == nullptr) name = """";
  CHECK_NE(thread_id.id, static_cast<uint64_t>(-1));
  if (!env->should_create_inspector()) {
    return nullptr;
  }
#if HAVE_INSPECTOR
  return std::make_unique<InspectorParentHandleImpl>(
      env->inspector_agent()->GetParentHandle(thread_id.id, url, name));
#else
  return {};
#endif
}",78,,528,5,,void
4105,BLOCK,-1,,<empty>,24,,530,2,,void
4123,BLOCK,-1,,"{
    return nullptr;
  }",40,,532,2,,void
4132,BLOCK,-1,,"{
  env->InitializeLibuv();
  env->InitializeDiagnostics();

  return StartExecution(env, cb);
}",32,,545,3,,void
4148,BLOCK,-1,,"{
  CHECK_NOT_NULL(main_script_source_utf8.data());
  return LoadEnvironment(
      env, [&](const StartExecutionCallbackInfo& info) -> MaybeLocal<Value> {
        Local<Value> main_script =
            ToV8Value(env->context(), main_script_source_utf8).ToLocalChecked();
        return info.run_cjs->Call(
            env->context(), Null(env->isolate()), 1, &main_script);
      });
}",77,,553,3,,void
4162,BLOCK,-1,,"{
  return Environment::GetCurrent(context);
}",60,,564,2,,void
4173,BLOCK,-1,,"{
  return env->isolate_data();
}",58,,568,2,,void
4183,BLOCK,-1,,"{
  return isolate_data->node_allocator();
}",74,,572,2,,void
4193,BLOCK,-1,,"{
  return env->context();
}",49,,576,2,,void
4203,BLOCK,-1,,"{
  return GetMultiIsolatePlatform(env->isolate_data());
}",65,,580,2,,void
4214,BLOCK,-1,,"{
  return env->platform();
}",65,,584,2,,void
4225,BLOCK,-1,,"{
  return CreatePlatform(
      thread_pool_size,
      static_cast<v8::TracingController*>(tracing_controller));
}",59,,590,3,,void
4237,BLOCK,-1,,"{
  return MultiIsolatePlatform::Create(thread_pool_size,
                                      tracing_controller)
      .release();
}",48,,598,3,,void
4252,BLOCK,-1,,"{
  delete platform;
}",51,,604,2,,void
4261,BLOCK,-1,,"{
  return std::make_unique<NodePlatform>(thread_pool_size,
                                        tracing_controller,
                                        page_allocator);
}",40,,611,4,,void
4278,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  EscapableHandleScope handle_scope(isolate);

  Local<Object> global = context->Global();
  Local<Private> key = Private::ForApi(isolate,
      FIXED_ONE_BYTE_STRING(isolate, ""node:per_context_binding_exports""));

  Local<Value> existing_value;
  if (!global->GetPrivate(context, key).ToLocal(&existing_value))
    return MaybeLocal<Object>();
  if (existing_value->IsObject())
    return handle_scope.Escape(existing_value.As<Object>());

  Local<Object> exports = Object::New(isolate);
  if (context->Global()->SetPrivate(context, key, exports).IsNothing() ||
      InitializePrimordials(context).IsNothing())
    return MaybeLocal<Object>();
  return handle_scope.Escape(exports);
}",65,,617,2,,void
4331,BLOCK,-1,,<empty>,5,,627,2,,void
4339,BLOCK,-1,,<empty>,5,,629,2,,void
4380,BLOCK,-1,,<empty>,5,,634,2,,void
4394,BLOCK,-1,,"{
  auto context = Context::New(isolate, nullptr, object_template);
  if (context.IsEmpty()) return context;

  if (InitializeContext(context).IsNothing()) {
    return Local<Context>();
  }

  return context;
}",66,,642,3,,void
4410,BLOCK,-1,,<empty>,26,,644,2,,void
4419,BLOCK,-1,,"{
    return Local<Context>();
  }",47,,646,2,,void
4428,BLOCK,-1,,"{
  THROW_ERR_PROTO_ACCESS(info.GetIsolate());
}",60,,653,2,,void
4438,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  HandleScope handle_scope(isolate);

  // When `IsCodeGenerationFromStringsAllowed` is true, V8 takes the fast path
  // and ignores the ModifyCodeGenerationFromStrings callback. Set it to false
  // to delegate the code generation validation to
  // node::ModifyCodeGenerationFromStrings.
  // The `IsCodeGenerationFromStringsAllowed` can be refreshed by V8 according
  // to the runtime flags, propagate the value to the embedder data.
  bool is_code_generation_from_strings_allowed =
      context->IsCodeGenerationFromStringsAllowed();
  context->AllowCodeGenerationFromStrings(false);
  context->SetEmbedderData(
      ContextEmbedderIndex::kAllowCodeGenerationFromStrings,
      Boolean::New(isolate, is_code_generation_from_strings_allowed));

  if (per_process::cli_options->disable_proto == """") {
    return Just(true);
  }

  // Remove __proto__
  // https://github.com/nodejs/node/issues/31951
  Local<Object> prototype;
  {
    Local<Stri...",62,,659,2,,void
4482,BLOCK,-1,,"{
    return Just(true);
  }",54,,676,2,,void
4491,BLOCK,11,,"{
    Local<String> object_string =
      FIXED_ONE_BYTE_STRING(isolate, ""Object"");
    Local<String> prototype_string =
      FIXED_ONE_BYTE_STRING(isolate, ""prototype"");

    Local<Value> object_v;
    if (!context->Global()
        ->Get(context, object_string)
        .ToLocal(&object_v)) {
      return Nothing<bool>();
    }

    Local<Value> prototype_v;
    if (!object_v.As<Object>()
        ->Get(context, prototype_string)
        .ToLocal(&prototype_v)) {
      return Nothing<bool>();
    }

    prototype = prototype_v.As<Object>();
  }",3,,683,11,,void
4531,BLOCK,-1,,"{
      return Nothing<bool>();
    }",30,,692,2,,void
4555,BLOCK,-1,,"{
      return Nothing<bool>();
    }",33,,699,2,,void
4581,BLOCK,-1,,"{
    if (prototype
        ->Delete(context, proto_string)
        .IsNothing()) {
      return Nothing<bool>();
    }
  }",60,,709,2,,void
4592,BLOCK,-1,,"{
      return Nothing<bool>();
    }",23,,712,2,,void
4596,BLOCK,-1,,<empty>,10,,715,1,,void
4605,BLOCK,-1,,"{
    Local<Value> thrower;
    if (!Function::New(context, ProtoThrower)
        .ToLocal(&thrower)) {
      return Nothing<bool>();
    }

    PropertyDescriptor descriptor(thrower, thrower);
    descriptor.set_enumerable(false);
    descriptor.set_configurable(true);
    if (prototype
        ->DefineProperty(context, proto_string, descriptor)
        .IsNothing()) {
      return Nothing<bool>();
    }
  }",66,,715,2,,void
4624,BLOCK,-1,,"{
      return Nothing<bool>();
    }",29,,718,2,,void
4652,BLOCK,-1,,"{
      return Nothing<bool>();
    }",23,,727,2,,void
4656,BLOCK,-1,,<empty>,10,,730,1,,void
4665,BLOCK,-1,,"{
    // Validated in ProcessGlobalArgs
    OnFatalError(""InitializeContextRuntime()"", ""invalid --disable-proto mode"");
  }",61,,730,2,,void
4676,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  HandleScope handle_scope(isolate);

  // Delete `Intl.v8BreakIterator`
  // https://github.com/nodejs/node/issues/14909
  {
    Context::Scope context_scope(context);
    Local<String> intl_string = FIXED_ONE_BYTE_STRING(isolate, ""Intl"");
    Local<String> break_iter_string =
        FIXED_ONE_BYTE_STRING(isolate, ""v8BreakIterator"");

    Local<Value> intl_v;
    if (!context->Global()->Get(context, intl_string).ToLocal(&intl_v)) {
      return Nothing<bool>();
    }

    if (intl_v->IsObject() &&
        intl_v.As<Object>()->Delete(context, break_iter_string).IsNothing()) {
      return Nothing<bool>();
    }
  }
  return Just(true);
}",70,,738,2,,void
4687,BLOCK,5,,"{
    Context::Scope context_scope(context);
    Local<String> intl_string = FIXED_ONE_BYTE_STRING(isolate, ""Intl"");
    Local<String> break_iter_string =
        FIXED_ONE_BYTE_STRING(isolate, ""v8BreakIterator"");

    Local<Value> intl_v;
    if (!context->Global()->Get(context, intl_string).ToLocal(&intl_v)) {
      return Nothing<bool>();
    }

    if (intl_v->IsObject() &&
        intl_v.As<Object>()->Delete(context, break_iter_string).IsNothing()) {
      return Nothing<bool>();
    }
  }",3,,744,5,,void
4730,BLOCK,-1,,"{
      return Nothing<bool>();
    }",73,,751,2,,void
4751,BLOCK,-1,,"{
      return Nothing<bool>();
    }",78,,756,2,,void
4761,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  HandleScope handle_scope(isolate);

  // Initialize the default values.
  context->SetEmbedderData(ContextEmbedderIndex::kAllowWasmCodeGeneration,
                           True(isolate));
  context->SetEmbedderData(
      ContextEmbedderIndex::kAllowCodeGenerationFromStrings, True(isolate));

  if (InitializeBaseContextForSnapshot(context).IsNothing()) {
    return Nothing<bool>();
  }
  return InitializePrimordials(context);
}",70,,763,2,,void
4796,BLOCK,-1,,"{
    return Nothing<bool>();
  }",62,,773,2,,void
4806,BLOCK,-1,,"{
  // Run per-context JS files.
  Isolate* isolate = context->GetIsolate();
  Context::Scope context_scope(context);
  Local<Object> exports;

  Local<String> primordials_string =
      FIXED_ONE_BYTE_STRING(isolate, ""primordials"");

  // Create primordials first and make it available to per-context scripts.
  Local<Object> primordials = Object::New(isolate);
  if (primordials->SetPrototype(context, Null(isolate)).IsNothing() ||
      !GetPerContextExports(context).ToLocal(&exports) ||
      exports->Set(context, primordials_string, primordials).IsNothing()) {
    return Nothing<bool>();
  }

  static const char* context_files[] = {""internal/per_context/primordials"",
                                        ""internal/per_context/domexception"",
                                        ""internal/per_context/messageport"",
                                        nullptr};

  // We do not have access to a per-Environment BuiltinLoader instance
  // at this point, because this code runs be...",59,,779,2,,void
4873,BLOCK,-1,,"{
    return Nothing<bool>();
  }",75,,792,2,,void
4886,BLOCK,-1,,<empty>,3,,807,1,,void
4897,BLOCK,4,,"{
    Local<Value> arguments[] = {exports, primordials};
    if (builtin_loader
            .CompileAndCall(
                context, *module, arraysize(arguments), arguments, nullptr)
            .IsEmpty()) {
      // Execution failed during context creation.
      return Nothing<bool>();
    }
  }",75,,807,4,,void
4919,BLOCK,-1,,"{
      // Execution failed during context creation.
      return Nothing<bool>();
    }",25,,812,2,,void
4929,BLOCK,-1,,"{
  if (InitializeMainContextForSnapshot(context).IsNothing()) {
    return Nothing<bool>();
  }

  return InitializeContextRuntime(context);
}",55,,822,2,,void
4936,BLOCK,-1,,"{
    return Nothing<bool>();
  }",62,,823,2,,void
4946,BLOCK,-1,,"{
  HandleScope handle_scope(isolate);
  Local<Context> context = isolate->GetCurrentContext();
  if (context.IsEmpty()) return nullptr;
  Environment* env = Environment::GetCurrent(context);
  if (env == nullptr) return nullptr;
  return env->event_loop();
}",50,,830,2,,void
4965,BLOCK,-1,,<empty>,26,,833,2,,void
4980,BLOCK,-1,,<empty>,23,,835,2,,void
4993,BLOCK,-1,,"{
  CHECK_NOT_NULL(env);
  Mutex::ScopedLock lock(env->extra_linked_bindings_mutex());

  node_module* prev_tail = env->extra_linked_bindings_tail();
  env->extra_linked_bindings()->push_back(mod);
  if (prev_tail != nullptr)
    prev_tail->nm_link = &env->extra_linked_bindings()->back();
}",65,,839,3,,void
5021,BLOCK,-1,,<empty>,5,,846,2,,void
5039,BLOCK,-1,,"{
  node_module node_mod = napi_module_to_node_module(&mod);
  node_mod.nm_flags = NM_F_LINKED;
  AddLinkedBinding(env, node_mod);
}",65,,849,3,,void
5061,BLOCK,-1,,"{
  node_module mod = {
    NODE_MODULE_VERSION,
    NM_F_LINKED,
    nullptr,  // nm_dso_handle
    nullptr,  // nm_filename
    nullptr,  // nm_register_func
    fn,
    name,
    priv,
    nullptr   // nm_link
  };
  AddLinkedBinding(env, mod);
}",35,,858,5,,void
5067,BLOCK,1,,<empty>,,,,1,,void
5087,BLOCK,-1,,"{
  node_module mod = {
      -1,           // nm_version for Node-API
      NM_F_LINKED,  // nm_flags
      nullptr,      // nm_dso_handle
      nullptr,      // nm_filename
      nullptr,      // nm_register_func
      get_node_api_context_register_func(env, name, module_api_version),
      name,                         // nm_modname
      reinterpret_cast<void*>(fn),  // nm_priv
      nullptr                       // nm_link
  };
  AddLinkedBinding(env, mod);
}",51,,876,5,,void
5118,BLOCK,-1,,"{
  return ThreadId { next_thread_id++ };
}",40,,893,1,,void
5128,BLOCK,-1,,"{
  exit(static_cast<int>(exit_code));
}",44,,897,2,,void
5138,BLOCK,-1,,"{
  env->set_stopping(true);
  env->set_can_call_into_js(false);
  env->stop_sub_worker_contexts();
  env->isolate()->DumpAndResetStats();
  // The tracing agent could be in the process of writing data using the
  // threadpool. Stop it before shutting down libuv. The rest of the tracing
  // agent disposal will be performed in DisposePlatform().
  per_process::v8_platform.StopTracingAgent();
  // When the process exits, the tasks in the thread pool may also need to
  // access the data of V8Platform, such as trace agent, or a field
  // added in the future. So make sure the thread pool exits first.
  // And make sure V8Platform don not call into Libuv threadpool, see Dispose
  // in node_v8_platform-inl.h
  uv_library_shutdown();
  DisposePlatform();
  Exit(exit_code);
}",78,,901,3,,void
5175,BLOCK,-1,,"{
  DefaultProcessExitHandlerInternal(env, static_cast<ExitCode>(exit_code));
}",65,,920,3,,void
5186,BLOCK,-1,,"{
  env->set_process_exit_handler(std::move(handler));
}",78,,925,3,,void
5200,BLOCK,-1,,"{
  auto movedHandler = std::move(handler);
  env->set_process_exit_handler([=](Environment* env, ExitCode exit_code) {
    movedHandler(env, static_cast<int>(exit_code));
  });
}",78,,930,3,,void
5234,BLOCK,-1,,<empty>,1,,1,1,,ANY
5242,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(isolate);
  CHECK_NOT_NULL(env);

  Local<Value> e;
  Local<String> estring = OneByteString(isolate, errors::errno_string(errorno));
  if (msg == nullptr || msg[0] == '\0') {
    msg = strerror(errorno);
  }
  Local<String> message = OneByteString(isolate, msg);

  Local<String> cons =
      String::Concat(isolate, estring, FIXED_ONE_BYTE_STRING(isolate, "", ""));
  cons = String::Concat(isolate, cons, message);

  Local<String> path_string;
  if (path != nullptr) {
    // FIXME(bnoordhuis) It's questionable to interpret the file path as UTF-8.
    path_string = String::NewFromUtf8(isolate, path).ToLocalChecked();
  }

  if (path_string.IsEmpty() == false) {
    cons = String::Concat(isolate, cons, FIXED_ONE_BYTE_STRING(isolate, "" '""));
    cons = String::Concat(isolate, cons, path_string);
    cons = String::Concat(isolate, cons, FIXED_ONE_BYTE_STRING(isolate, ""'""));
  }
  e = Exception::Error(cons);

  Local<Context> context = env->cont...",47,,27,6,,void
5281,BLOCK,-1,,"{
    msg = strerror(errorno);
  }",41,,33,2,,void
5328,BLOCK,-1,,"{
    // FIXME(bnoordhuis) It's questionable to interpret the file path as UTF-8.
    path_string = String::NewFromUtf8(isolate, path).ToLocalChecked();
  }",24,,43,2,,void
5347,BLOCK,-1,,"{
    cons = String::Concat(isolate, cons, FIXED_ONE_BYTE_STRING(isolate, "" '""));
    cons = String::Concat(isolate, cons, path_string);
    cons = String::Concat(isolate, cons, FIXED_ONE_BYTE_STRING(isolate, ""'""));
  }",39,,48,2,,void
5444,BLOCK,-1,,"{
    obj->Set(context, env->path_string(), path_string).Check();
  }",39,,62,2,,void
5462,BLOCK,-1,,"{
    obj->Set(context,
             env->syscall_string(),
             OneByteString(isolate, syscall)).Check();
  }",27,,66,2,,void
5485,BLOCK,-1,,"{
#ifdef _WIN32
  if (strncmp(path, ""\\\\?\\UNC\\"", 8) == 0) {
    return String::Concat(
        isolate,
        FIXED_ONE_BYTE_STRING(isolate, ""\\\\""),
        String::NewFromUtf8(isolate, path + 8).ToLocalChecked());
  } else if (strncmp(path, ""\\\\?\\"", 4) == 0) {
    return String::NewFromUtf8(isolate, path + 4).ToLocalChecked();
  }
#endif

  return String::NewFromUtf8(isolate, path).ToLocalChecked();
}",73,,75,3,,void
5505,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(isolate);
  CHECK_NOT_NULL(env);

  if (!msg || !msg[0])
    msg = uv_strerror(errorno);

  Local<String> js_code = OneByteString(isolate, uv_err_name(errorno));
  Local<String> js_syscall = OneByteString(isolate, syscall);
  Local<String> js_path;
  Local<String> js_dest;

  Local<String> js_msg = js_code;
  js_msg =
      String::Concat(isolate, js_msg, FIXED_ONE_BYTE_STRING(isolate, "": ""));
  js_msg = String::Concat(isolate, js_msg, OneByteString(isolate, msg));
  js_msg =
      String::Concat(isolate, js_msg, FIXED_ONE_BYTE_STRING(isolate, "", ""));
  js_msg = String::Concat(isolate, js_msg, js_syscall);

  if (path != nullptr) {
    js_path = StringFromPath(isolate, path);

    js_msg =
        String::Concat(isolate, js_msg, FIXED_ONE_BYTE_STRING(isolate, "" '""));
    js_msg = String::Concat(isolate, js_msg, js_path);
    js_msg =
        String::Concat(isolate, js_msg, FIXED_ONE_BYTE_STRING(isolate, ""'""));
  }

  if (dest != nullptr...",44,,96,7,,void
5524,BLOCK,-1,,<empty>,5,,101,2,,void
5611,BLOCK,-1,,"{
    js_path = StringFromPath(isolate, path);

    js_msg =
        String::Concat(isolate, js_msg, FIXED_ONE_BYTE_STRING(isolate, "" '""));
    js_msg = String::Concat(isolate, js_msg, js_path);
    js_msg =
        String::Concat(isolate, js_msg, FIXED_ONE_BYTE_STRING(isolate, ""'""));
  }",24,,116,2,,void
5652,BLOCK,-1,,"{
    js_dest = StringFromPath(isolate, dest);

    js_msg = String::Concat(
        isolate, js_msg, FIXED_ONE_BYTE_STRING(isolate, "" -> '""));
    js_msg = String::Concat(isolate, js_msg, js_dest);
    js_msg =
        String::Concat(isolate, js_msg, FIXED_ONE_BYTE_STRING(isolate, ""'""));
  }",24,,126,2,,void
5770,BLOCK,-1,,<empty>,5,,147,2,,void
5790,BLOCK,-1,,<empty>,5,,149,2,,void
5811,BLOCK,-1,,"{
  errors::TriggerUncaughtException(isolate, try_catch);
}",70,,246,3,,void
5823,BLOCK,-1,,"{
    // Disallow JavaScript execution during interrupt.
    Isolate::DisallowJavascriptExecutionScope scope(
        env->isolate(),
        Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
    fun(arg);
  }",54,,172,2,,void
5853,BLOCK,-1,,<empty>,1,,1,1,,ANY
5857,BLOCK,-1,,"{
  env->RunAtExitCallbacks();
}",34,,20,2,,void
5868,BLOCK,-1,,"{
  CHECK_NOT_NULL(env);
  env->AtExit(cb, arg);
}",65,,24,4,,void
5881,BLOCK,-1,,"{
  USE(EmitProcessBeforeExit(env));
}",39,,29,2,,void
5889,BLOCK,-1,,"{
  TRACE_EVENT0(TRACING_CATEGORY_NODE1(environment), ""BeforeExit"");
  if (!env->destroy_async_id_list()->empty())
    AsyncWrap::DestroyAsyncIdsCallback(env);

  Isolate* isolate = env->isolate();
  HandleScope handle_scope(isolate);
  Context::Scope context_scope(env->context());

  if (!env->can_call_into_js()) {
    return Nothing<bool>();
  }

  Local<Integer> exit_code = Integer::New(
      isolate, static_cast<int32_t>(env->exit_code(ExitCode::kNoFailure)));

  return ProcessEmit(env, ""beforeExit"", exit_code).IsEmpty() ?
      Nothing<bool>() : Just(true);
}",53,,33,2,,void
5903,BLOCK,-1,,<empty>,5,,36,2,,void
5931,BLOCK,-1,,"{
    return Nothing<bool>();
  }",33,,42,2,,void
5970,BLOCK,-1,,"{
  return EmitProcessExitInternal(env).FromMaybe(ExitCode::kGenericUserError);
}",52,,53,2,,void
5984,BLOCK,-1,,"{
  return static_cast<int>(EmitExitInternal(env));
}",32,,57,2,,void
5994,BLOCK,-1,,"{
  // process.emit('exit')
  Isolate* isolate = env->isolate();
  HandleScope handle_scope(isolate);
  Context::Scope context_scope(env->context());

  env->set_exiting(true);

  if (!env->can_call_into_js()) {
    return Nothing<ExitCode>();
  }

  Local<Integer> exit_code = Integer::New(
      isolate, static_cast<int32_t>(env->exit_code(ExitCode::kNoFailure)));

  if (ProcessEmit(env, ""exit"", exit_code).IsEmpty()) {
    return Nothing<ExitCode>();
  }
  // Reload exit code, it may be changed by `emit('exit')`
  return Just(env->exit_code(ExitCode::kNoFailure));
}",59,,61,2,,void
6022,BLOCK,-1,,"{
    return Nothing<ExitCode>();
  }",33,,69,2,,void
6053,BLOCK,-1,,"{
    return Nothing<ExitCode>();
  }",54,,76,2,,void
6069,BLOCK,-1,,"{
  Maybe<ExitCode> result = EmitProcessExitInternal(env);
  if (result.IsNothing()) {
    return Nothing<int>();
  }
  return Just(static_cast<int>(result.FromJust()));
}",46,,83,2,,void
6083,BLOCK,-1,,"{
    return Nothing<int>();
  }",27,,85,2,,void
6098,BLOCK,-1,,<empty>,,,,2,,<empty>
6105,BLOCK,-1,,<empty>,,,,4,,<empty>
6115,BLOCK,-1,,<empty>,,,,1,,<empty>
6125,BLOCK,-1,,{ delete handle; },60,,116,2,,void
6134,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(isolate);
  CHECK_NOT_NULL(env);
  env->AddCleanupHook(fun, arg);
}",43,,120,4,,void
6157,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(isolate);
  CHECK_NOT_NULL(env);
  env->RemoveCleanupHook(fun, arg);
}",46,,128,4,,void
6178,BLOCK,-1,,"{
  AsyncCleanupHookInfo* info = static_cast<AsyncCleanupHookInfo*>(arg);
  std::shared_ptr<AsyncCleanupHookInfo> keep_alive = info->self;

  info->env->DecreaseWaitingRequestCounter();
  info->self.reset();
}",47,,134,2,,void
6207,BLOCK,-1,,"{
  AsyncCleanupHookInfo* info = static_cast<AsyncCleanupHookInfo*>(arg);
  info->env->IncreaseWaitingRequestCounter();
  info->started = true;
  info->fun(info->arg, FinishAsyncCleanupHook, info);
}",44,,142,2,,void
6240,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(isolate);
  CHECK_NOT_NULL(env);
  auto info = std::make_shared<AsyncCleanupHookInfo>();
  info->env = env;
  info->fun = fun;
  info->arg = arg;
  info->self = info;
  env->AddCleanupHook(RunAsyncCleanupHook, info.get());
  return new ACHHandle { info };
}",16,,152,4,,void
6294,BLOCK,-1,,"{
  if (handle->info->started) return;
  handle->info->self.reset();
  handle->info->env->RemoveCleanupHook(RunAsyncCleanupHook, handle->info.get());
}",24,,165,2,,void
6301,BLOCK,-1,,<empty>,30,,166,2,,void
6330,BLOCK,-1,,"{
  env->RequestInterrupt([fun, arg](Environment* env) {
    // Disallow JavaScript execution during interrupt.
    Isolate::DisallowJavascriptExecutionScope scope(
        env->isolate(),
        Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
    fun(arg);
  });
}",76,,171,4,,void
6340,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(isolate);
  if (env == nullptr) return -1;
  return env->execution_async_id();
}",58,,181,2,,void
6353,BLOCK,-1,,<empty>,23,,183,2,,void
6366,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(isolate);
  if (env == nullptr) return -1;
  return env->trigger_async_id();
}",56,,187,2,,void
6379,BLOCK,-1,,<empty>,23,,189,2,,void
6395,BLOCK,-1,,"{
  HandleScope handle_scope(isolate);
  Local<String> type =
      String::NewFromUtf8(isolate, name, NewStringType::kInternalized)
          .ToLocalChecked();
  return EmitAsyncInit(isolate, resource, type, trigger_async_id);
}",56,,197,5,,void
6430,BLOCK,-1,,"{
  DebugSealHandleScope handle_scope(isolate);
  Environment* env = Environment::GetCurrent(isolate);
  CHECK_NOT_NULL(env);

  // Initialize async context struct
  if (trigger_async_id == -1)
    trigger_async_id = env->get_default_trigger_async_id();

  async_context context = {
    env->new_async_id(),  // async_id_
    trigger_async_id  // trigger_async_id_
  };

  // Run init hooks
  AsyncWrap::EmitAsyncInit(env, resource, name, context.async_id,
                           context.trigger_async_id);

  return context;
}",56,,208,5,,void
6449,BLOCK,-1,,<empty>,5,,215,2,,void
6485,BLOCK,-1,,"{
  EmitAsyncDestroy(Environment::GetCurrent(isolate), asyncContext);
}",69,,229,3,,void
6498,BLOCK,-1,,"{
  AsyncWrap::EmitDestroy(env, asyncContext.async_id);
}",69,,233,3,,void
6517,BLOCK,-1,,<empty>,1,,1,1,,ANY
6521,BLOCK,-1,,"{
#define SIGNO_CASE(e)                                                          \
  case e:                                                                      \
    return #e;
  switch (signo) {
#ifdef SIGHUP
    SIGNO_CASE(SIGHUP);
#endif

#ifdef SIGINT
    SIGNO_CASE(SIGINT);
#endif

#ifdef SIGQUIT
    SIGNO_CASE(SIGQUIT);
#endif

#ifdef SIGILL
    SIGNO_CASE(SIGILL);
#endif

#ifdef SIGTRAP
    SIGNO_CASE(SIGTRAP);
#endif

#ifdef SIGABRT
    SIGNO_CASE(SIGABRT);
#endif

#ifdef SIGIOT
#if SIGABRT != SIGIOT
    SIGNO_CASE(SIGIOT);
#endif
#endif

#ifdef SIGBUS
    SIGNO_CASE(SIGBUS);
#endif

#ifdef SIGFPE
    SIGNO_CASE(SIGFPE);
#endif

#ifdef SIGKILL
    SIGNO_CASE(SIGKILL);
#endif

#ifdef SIGUSR1
    SIGNO_CASE(SIGUSR1);
#endif

#ifdef SIGSEGV
    SIGNO_CASE(SIGSEGV);
#endif

#ifdef SIGUSR2
    SIGNO_CASE(SIGUSR2);
#endif

#ifdef SIGPIPE
    SIGNO_CASE(SIGPIPE);
#endif

#ifdef SIGALRM
    SIGNO_CASE(SIGALRM);
#endif

    SIGNO_CASE(SIGTERM);

#ifdef SIGCHLD
    SIGNO_CASE(SIGCHL...",37,,7,2,,void
6524,BLOCK,-1,,"{
#ifdef SIGHUP
    SIGNO_CASE(SIGHUP);
#endif

#ifdef SIGINT
    SIGNO_CASE(SIGINT);
#endif

#ifdef SIGQUIT
    SIGNO_CASE(SIGQUIT);
#endif

#ifdef SIGILL
    SIGNO_CASE(SIGILL);
#endif

#ifdef SIGTRAP
    SIGNO_CASE(SIGTRAP);
#endif

#ifdef SIGABRT
    SIGNO_CASE(SIGABRT);
#endif

#ifdef SIGIOT
#if SIGABRT != SIGIOT
    SIGNO_CASE(SIGIOT);
#endif
#endif

#ifdef SIGBUS
    SIGNO_CASE(SIGBUS);
#endif

#ifdef SIGFPE
    SIGNO_CASE(SIGFPE);
#endif

#ifdef SIGKILL
    SIGNO_CASE(SIGKILL);
#endif

#ifdef SIGUSR1
    SIGNO_CASE(SIGUSR1);
#endif

#ifdef SIGSEGV
    SIGNO_CASE(SIGSEGV);
#endif

#ifdef SIGUSR2
    SIGNO_CASE(SIGUSR2);
#endif

#ifdef SIGPIPE
    SIGNO_CASE(SIGPIPE);
#endif

#ifdef SIGALRM
    SIGNO_CASE(SIGALRM);
#endif

    SIGNO_CASE(SIGTERM);

#ifdef SIGCHLD
    SIGNO_CASE(SIGCHLD);
#endif

#ifdef SIGSTKFLT
    SIGNO_CASE(SIGSTKFLT);
#endif

#ifdef SIGCONT
    SIGNO_CASE(SIGCONT);
#endif

#ifdef SIGSTOP
    SIGNO_CASE(SIGSTOP);
#endif

#ifdef SIGTSTP
    SIGNO_CASE(SIGTST...",18,,11,2,,void
6526,BLOCK,1,,<empty>,,,,1,,void
6546,BLOCK,-1,,<empty>,1,,1,1,,ANY
6550,BLOCK,-1,,"{
          DestroyAsyncIdsCallback(static_cast<Environment*>(arg));
        }",23,,569,2,,void
6561,BLOCK,-1,,"{
      env->context()->GetMicrotaskQueue()->EnqueueMicrotask(
        env->isolate(),
        [](void* arg) {
          DestroyAsyncIdsCallback(static_cast<Environment*>(arg));
        }, env);
      }",48,,566,2,,void
6600,BLOCK,-1,,<empty>,1,,1,1,,ANY
6611,BLOCK,-1,,"{
  Local<Function> fn = env->async_hooks_destroy_function();

  TryCatchScope try_catch(env, TryCatchScope::CatchMode::kFatal);

  do {
    std::vector<double> destroy_async_id_list;
    destroy_async_id_list.swap(*env->destroy_async_id_list());
    if (!env->can_call_into_js()) return;
    for (auto async_id : destroy_async_id_list) {
      // Want each callback to be cleaned up after itself, instead of cleaning
      // them all up after the while() loop completes.
      HandleScope scope(env->isolate());
      Local<Value> async_id_value = Number::New(env->isolate(), async_id);
      MaybeLocal<Value> ret = fn->Call(
          env->context(), Undefined(env->isolate()), 1, &async_id_value);

      if (ret.IsEmpty())
        return;
    }
  } while (!env->destroy_async_id_list()->empty());
}",59,,67,2,,void
6631,BLOCK,-1,,"{
    std::vector<double> destroy_async_id_list;
    destroy_async_id_list.swap(*env->destroy_async_id_list());
    if (!env->can_call_into_js()) return;
    for (auto async_id : destroy_async_id_list) {
      // Want each callback to be cleaned up after itself, instead of cleaning
      // them all up after the while() loop completes.
      HandleScope scope(env->isolate());
      Local<Value> async_id_value = Number::New(env->isolate(), async_id);
      MaybeLocal<Value> ret = fn->Call(
          env->context(), Undefined(env->isolate()), 1, &async_id_value);

      if (ret.IsEmpty())
        return;
    }
  }",6,,72,1,,void
6648,BLOCK,-1,,<empty>,35,,75,2,,void
6653,BLOCK,-1,,"{
      // Want each callback to be cleaned up after itself, instead of cleaning
      // them all up after the while() loop completes.
      HandleScope scope(env->isolate());
      Local<Value> async_id_value = Number::New(env->isolate(), async_id);
      MaybeLocal<Value> ret = fn->Call(
          env->context(), Undefined(env->isolate()), 1, &async_id_value);

      if (ret.IsEmpty())
        return;
    }",49,,76,3,,void
6702,BLOCK,-1,,<empty>,9,,85,2,,void
6719,BLOCK,-1,,"{
  AsyncHooks* async_hooks = env->async_hooks();

  if (async_hooks->fields()[type] == 0 || !env->can_call_into_js())
    return;

  HandleScope handle_scope(env->isolate());
  Local<Value> async_id_value = Number::New(env->isolate(), async_id);
  TryCatchScope try_catch(env, TryCatchScope::CatchMode::kFatal);
  USE(fn->Call(env->context(), Undefined(env->isolate()), 1, &async_id_value));
}",31,,91,5,,void
6742,BLOCK,-1,,<empty>,5,,95,2,,void
6795,BLOCK,-1,,"{
  Emit(env, async_id, AsyncHooks::kPromiseResolve,
       env->async_hooks_promise_resolve_function());
}",71,,104,3,,void
6809,BLOCK,-1,,"{
  switch (provider_type()) {
#define V(PROVIDER)                                                           \
    case PROVIDER_ ## PROVIDER:                                               \
      TRACE_EVENT_NESTABLE_ASYNC_BEGIN0(                                      \
        TRACING_CATEGORY_NODE1(async_hooks),                                  \
        #PROVIDER ""_CALLBACK"", static_cast<int64_t>(get_async_id()));         \
      break;
    NODE_ASYNC_PROVIDER_TYPES(V)
#undef V
    default:
      UNREACHABLE();
  }
}",40,,110,1,,void
6812,BLOCK,-1,,"{
#define V(PROVIDER)                                                           \
    case PROVIDER_ ## PROVIDER:                                               \
      TRACE_EVENT_NESTABLE_ASYNC_BEGIN0(                                      \
        TRACING_CATEGORY_NODE1(async_hooks),                                  \
        #PROVIDER ""_CALLBACK"", static_cast<int64_t>(get_async_id()));         \
      break;
    NODE_ASYNC_PROVIDER_TYPES(V)
#undef V
    default:
      UNREACHABLE();
  }",28,,111,2,,void
6822,BLOCK,-1,,"{
  Emit(env, async_id, AsyncHooks::kBefore,
       env->async_hooks_before_function());
}",63,,126,3,,void
6838,BLOCK,-1,,"{
  switch (type) {
#define V(PROVIDER)                                                           \
    case PROVIDER_ ## PROVIDER:                                               \
      TRACE_EVENT_NESTABLE_ASYNC_END0(                                        \
        TRACING_CATEGORY_NODE1(async_hooks),                                  \
        #PROVIDER ""_CALLBACK"", static_cast<int64_t>(async_id));               \
      break;
    NODE_ASYNC_PROVIDER_TYPES(V)
#undef V
    default:
      UNREACHABLE();
  }
}",73,,132,3,,void
6841,BLOCK,-1,,"{
#define V(PROVIDER)                                                           \
    case PROVIDER_ ## PROVIDER:                                               \
      TRACE_EVENT_NESTABLE_ASYNC_END0(                                        \
        TRACING_CATEGORY_NODE1(async_hooks),                                  \
        #PROVIDER ""_CALLBACK"", static_cast<int64_t>(async_id));               \
      break;
    NODE_ASYNC_PROVIDER_TYPES(V)
#undef V
    default:
      UNREACHABLE();
  }",17,,133,2,,void
6851,BLOCK,-1,,"{
  // If the user's callback failed then the after() hooks will be called at the
  // end of _fatalException().
  Emit(env, async_id, AsyncHooks::kAfter,
       env->async_hooks_after_function());
}",62,,148,3,,void
6866,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsObject());

  // All of init, before, after, destroy, and promise_resolve are supplied by
  // async_hooks internally, so this should only ever be called once. At which
  // time all the functions should be set. Detect this by checking if
  // init !IsEmpty().
  CHECK(env->async_hooks_init_function().IsEmpty());

  Local<Object> fn_obj = args[0].As<Object>();

#define SET_HOOK_FN(name)                                                      \
  do {                                                                         \
    Local<Value> v =                                                           \
        fn_obj->Get(env->context(),                                            \
                    FIXED_ONE_BYTE_STRING(env->isolate(), #name))              \
            .ToLocalChecked();                                                 \
    CHECK(v->IsFunction());                                               ...",65,,155,2,,void
6903,BLOCK,1,,<empty>,,,,4,,void
6905,BLOCK,-1,,SET_HOOK_FN(init),3,,178,1,,void
6944,BLOCK,1,,<empty>,,,,4,,void
6946,BLOCK,-1,,SET_HOOK_FN(before),3,,179,1,,void
6985,BLOCK,1,,<empty>,,,,4,,void
6987,BLOCK,-1,,SET_HOOK_FN(after),3,,180,1,,void
7026,BLOCK,1,,<empty>,,,,4,,void
7028,BLOCK,-1,,SET_HOOK_FN(destroy),3,,181,1,,void
7067,BLOCK,1,,<empty>,,,,4,,void
7069,BLOCK,-1,,SET_HOOK_FN(promise_resolve),3,,182,1,,void
7111,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  env->ResetPromiseHooks(
      args[0]->IsFunction() ? args[0].As<Function>() : Local<Function>(),
      args[1]->IsFunction() ? args[1].As<Function>() : Local<Function>(),
      args[2]->IsFunction() ? args[2].As<Function>() : Local<Function>(),
      args[3]->IsFunction() ? args[3].As<Function>() : Local<Function>());
}",70,,186,2,,void
7189,BLOCK,-1,,"{
  delete static_cast<DestroyParam*>(ptr);
}",48,,204,2,,void
7198,BLOCK,-1,,"{
  HandleScope scope(info.GetIsolate());

  std::unique_ptr<DestroyParam> p{info.GetParameter()};
  Local<Object> prop_bag = PersistentToLocal::Default(info.GetIsolate(),
                                                      p->propBag);
  Local<Value> val;

  p->env->RemoveCleanupHook(DestroyParamCleanupHook, p.get());

  if (!prop_bag.IsEmpty() &&
      !prop_bag->Get(p->env->context(), p->env->destroyed_string())
        .ToLocal(&val)) {
    return;
  }

  if (val.IsEmpty() || val->IsFalse()) {
    AsyncWrap::EmitDestroy(p->env, p->asyncId);
  }
  // unique_ptr goes out of scope here and pointer is deleted.
}",74,,208,2,,void
7279,BLOCK,-1,,"{
    return;
  }",25,,220,2,,void
7291,BLOCK,-1,,"{
    AsyncWrap::EmitDestroy(p->env, p->asyncId);
  }",40,,224,2,,void
7306,BLOCK,-1,,"{
  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsNumber());
  CHECK(args.Length() == 2 || args[2]->IsObject());

  Isolate* isolate = args.GetIsolate();
  DestroyParam* p = new DestroyParam();
  p->asyncId = args[1].As<Number>()->Value();
  p->env = Environment::GetCurrent(args);
  p->target.Reset(isolate, args[0].As<Object>());
  if (args.Length() > 2) {
    p->propBag.Reset(isolate, args[2].As<Object>());
  }
  p->target.SetWeak(p, AsyncWrap::WeakCallback, WeakCallbackType::kParameter);
  p->env->AddCleanupHook(DestroyParamCleanupHook, p);
}",74,,231,2,,void
7389,BLOCK,-1,,"{
    p->propBag.Reset(isolate, args[2].As<Object>());
  }",26,,241,2,,void
7428,BLOCK,-1,,"{
  AsyncWrap* wrap;
  args.GetReturnValue().Set(kInvalidAsyncId);
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  args.GetReturnValue().Set(wrap->get_async_id());
}",69,,248,2,,void
7460,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  // No need for CHECK(IsNumber()) on args because if FromJust() doesn't fail
  // then the checks in push_async_ids() and pop_async_id() will.
  double async_id = args[0]->NumberValue(env->context()).FromJust();
  double trigger_async_id = args[1]->NumberValue(env->context()).FromJust();
  env->async_hooks()->push_async_context(async_id, trigger_async_id, {});
}",75,,256,2,,void
7515,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  double async_id = args[0]->NumberValue(env->context()).FromJust();
  args.GetReturnValue().Set(env->async_hooks()->pop_async_context(async_id));
}",74,,266,2,,void
7559,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  uint32_t index;
  if (!args[0]->Uint32Value(env->context()).To(&index)) return;
  args.GetReturnValue().Set(
      env->async_hooks()->native_execution_async_resource(index));
}",46,,274,2,,void
7586,BLOCK,-1,,<empty>,57,,277,2,,void
7607,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  env->async_hooks()->clear_async_id_stack();
}",76,,283,2,,void
7627,BLOCK,-1,,"{
  CHECK(args[0]->IsObject());

  AsyncWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  Local<Object> resource = args[0].As<Object>();
  double execution_async_id =
      args[1]->IsNumber() ? args[1].As<Number>()->Value() : kInvalidAsyncId;
  wrap->AsyncReset(resource, execution_async_id);
}",69,,289,2,,void
7685,BLOCK,-1,,"{
  AsyncWrap* wrap;
  args.GetReturnValue().Set(AsyncWrap::PROVIDER_NONE);
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  args.GetReturnValue().Set(wrap->provider_type());
}",74,,302,2,,void
7719,BLOCK,-1,,"{
  AsyncWrap::EmitDestroy(env(), async_id_);
  // Ensure no double destroy is emitted via AsyncReset().
  async_id_ = kInvalidAsyncId;

  if (!persistent().IsEmpty() && !from_gc) {
    HandleScope handle_scope(env()->isolate());
    USE(object()->Set(env()->context(), env()->resource_symbol(), object()));
  }
}",43,,310,2,,void
7738,BLOCK,-1,,"{
    HandleScope handle_scope(env()->isolate());
    USE(object()->Set(env()->context(), env()->resource_symbol(), object()));
  }",44,,315,2,,void
7750,BLOCK,-1,,"{
  CHECK(args[0]->IsNumber());
  AsyncWrap::EmitDestroy(
      Environment::GetCurrent(args),
      args[0].As<Number>()->Value());
}",78,,321,2,,void
7780,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  if (args[0]->IsFunction()) {
    env->set_async_hooks_callback_trampoline(args[0].As<Function>());
  } else {
    env->set_async_hooks_callback_trampoline(Local<Function>());
  }
}",80,,328,2,,void
7796,BLOCK,-1,,"{
    env->set_async_hooks_callback_trampoline(args[0].As<Function>());
  }",30,,331,2,,void
7808,BLOCK,-1,,"{
    env->set_async_hooks_callback_trampoline(Local<Function>());
  }",10,,333,1,,void
7818,BLOCK,-1,,"{
  Local<FunctionTemplate> tmpl = isolate_data->async_wrap_ctor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = isolate_data->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->SetClassName(
        FIXED_ONE_BYTE_STRING(isolate_data->isolate(), ""AsyncWrap""));
    SetProtoMethod(isolate, tmpl, ""getAsyncId"", AsyncWrap::GetAsyncId);
    SetProtoMethod(isolate, tmpl, ""asyncReset"", AsyncWrap::AsyncReset);
    SetProtoMethod(
        isolate, tmpl, ""getProviderType"", AsyncWrap::GetProviderType);
    isolate_data->set_async_wrap_ctor_template(tmpl);
  }
  return tmpl;
}",32,,339,2,,void
7834,BLOCK,-1,,"{
    Isolate* isolate = isolate_data->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->SetClassName(
        FIXED_ONE_BYTE_STRING(isolate_data->isolate(), ""AsyncWrap""));
    SetProtoMethod(isolate, tmpl, ""getAsyncId"", AsyncWrap::GetAsyncId);
    SetProtoMethod(isolate, tmpl, ""asyncReset"", AsyncWrap::AsyncReset);
    SetProtoMethod(
        isolate, tmpl, ""getProviderType"", AsyncWrap::GetProviderType);
    isolate_data->set_async_wrap_ctor_template(tmpl);
  }",23,,341,2,,void
7890,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();

  SetMethod(isolate, target, ""setupHooks"", SetupHooks);
  SetMethod(isolate, target, ""setCallbackTrampoline"", SetCallbackTrampoline);
  SetMethod(isolate, target, ""pushAsyncContext"", PushAsyncContext);
  SetMethod(isolate, target, ""popAsyncContext"", PopAsyncContext);
  SetMethod(isolate, target, ""executionAsyncResource"", ExecutionAsyncResource);
  SetMethod(isolate, target, ""clearAsyncIdStack"", ClearAsyncIdStack);
  SetMethod(isolate, target, ""queueDestroyAsyncId"", QueueDestroyAsyncId);
  SetMethod(isolate, target, ""setPromiseHooks"", SetPromiseHooks);
  SetMethod(isolate, target, ""registerDestroyHook"", RegisterDestroyHook);
  AsyncWrap::GetConstructorTemplate(isolate_data);
}",74,,356,3,,void
7955,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();
  HandleScope scope(isolate);

  PropertyAttribute ReadOnlyDontDelete =
      static_cast<PropertyAttribute>(ReadOnly | DontDelete);

#define FORCE_SET_TARGET_FIELD(obj, str, field)                               \
  (obj)->DefineOwnProperty(context,                                           \
                           FIXED_ONE_BYTE_STRING(isolate, str),               \
                           field,                                             \
                           ReadOnlyDontDelete).FromJust()

  // Attach the uint32_t[] where each slot contains the count of the number of
  // callbacks waiting to be called on a particular event. It can then be
  // incremented/decremented from JS quickly to communicate to C++ if there are
  // any callbacks waiting to be called.
  FORCE_SET_TARGET_FIELD(target,
                         ""async_hook_fields"",
                         env->async_h...",56,,374,5,,void
7995,BLOCK,1,,<empty>,,,,7,,void
8031,BLOCK,1,,<empty>,,,,7,,void
8064,BLOCK,1,,<empty>,,,,7,,void
8118,BLOCK,1,,<empty>,,,,4,,void
8140,BLOCK,1,,<empty>,,,,4,,void
8162,BLOCK,1,,<empty>,,,,4,,void
8184,BLOCK,1,,<empty>,,,,4,,void
8206,BLOCK,1,,<empty>,,,,4,,void
8228,BLOCK,1,,<empty>,,,,4,,void
8250,BLOCK,1,,<empty>,,,,4,,void
8272,BLOCK,1,,<empty>,,,,4,,void
8294,BLOCK,1,,<empty>,,,,4,,void
8316,BLOCK,1,,<empty>,,,,4,,void
8338,BLOCK,1,,<empty>,,,,4,,void
8360,BLOCK,1,,<empty>,,,,4,,void
8382,BLOCK,1,,<empty>,,,,4,,void
8407,BLOCK,1,,<empty>,,,,6,,void
8441,BLOCK,1,,<empty>,,,,2,,void
8490,BLOCK,-1,,"{
  registry->Register(SetupHooks);
  registry->Register(SetCallbackTrampoline);
  registry->Register(PushAsyncContext);
  registry->Register(PopAsyncContext);
  registry->Register(ExecutionAsyncResource);
  registry->Register(ClearAsyncIdStack);
  registry->Register(QueueDestroyAsyncId);
  registry->Register(SetPromiseHooks);
  registry->Register(RegisterDestroyHook);
  registry->Register(AsyncWrap::GetAsyncId);
  registry->Register(AsyncWrap::AsyncReset);
  registry->Register(AsyncWrap::GetProviderType);
}",42,,459,2,,void
8564,BLOCK,-1,,<empty>,67,,478,5,,void
8573,BLOCK,-1,,"{
  CHECK_NE(provider, PROVIDER_NONE);
  provider_type_ = provider;

  // Use AsyncReset() call to execute the init() callbacks.
  AsyncReset(object, execution_async_id, silent);
  init_hook_ran_ = true;
}",30,,485,6,,void
8595,BLOCK,-1,,"{
  trigger_async_id_ = trigger_async_id;
}",66,,499,6,,void
8604,BLOCK,-1,,"{
}",29,,504,3,,void
8608,BLOCK,-1,,"{
  return init_hook_ran_;
}",44,,528,1,,void
8614,BLOCK,-1,,"{
  EmitTraceEventDestroy();
  EmitDestroy(true /* from gc */);
}",25,,532,1,,void
8621,BLOCK,-1,,"{
  switch (provider_type()) {
  #define V(PROVIDER)                                                         \
    case PROVIDER_ ## PROVIDER:                                               \
      TRACE_EVENT_NESTABLE_ASYNC_END0(                                        \
        TRACING_CATEGORY_NODE1(async_hooks),                                  \
        #PROVIDER, static_cast<int64_t>(get_async_id()));                     \
      break;
    NODE_ASYNC_PROVIDER_TYPES(V)
  #undef V
    default:
      UNREACHABLE();
  }
}",41,,537,1,,void
8624,BLOCK,-1,,"{
  #define V(PROVIDER)                                                         \
    case PROVIDER_ ## PROVIDER:                                               \
      TRACE_EVENT_NESTABLE_ASYNC_END0(                                        \
        TRACING_CATEGORY_NODE1(async_hooks),                                  \
        #PROVIDER, static_cast<int64_t>(get_async_id()));                     \
      break;
    NODE_ASYNC_PROVIDER_TYPES(V)
  #undef V
    default:
      UNREACHABLE();
  }",28,,538,2,,void
8633,BLOCK,-1,,"{
  if (env->async_hooks()->fields()[AsyncHooks::kDestroy] == 0 ||
      !env->can_call_into_js()) {
    return;
  }

  if (env->destroy_async_id_list()->empty()) {
    env->SetImmediate(&DestroyAsyncIdsCallback, CallbackFlags::kUnrefed);
  }

  // If the list gets very large empty it faster using a Microtask.
  // Microtasks can't be added in GC context therefore we use an
  // interrupt to get this Microtask scheduled as fast as possible.
  if (env->destroy_async_id_list()->size() == 16384) {
    env->RequestInterrupt([](Environment* env) {
      env->context()->GetMicrotaskQueue()->EnqueueMicrotask(
        env->isolate(),
        [](void* arg) {
          DestroyAsyncIdsCallback(static_cast<Environment*>(arg));
        }, env);
      });
  }

  env->destroy_async_id_list()->push_back(async_id);
}",64,,552,3,,void
8654,BLOCK,-1,,"{
    return;
  }",33,,554,2,,void
8664,BLOCK,-1,,"{
    env->SetImmediate(&DestroyAsyncIdsCallback, CallbackFlags::kUnrefed);
  }",46,,558,2,,void
8684,BLOCK,-1,,"{
    env->RequestInterrupt([](Environment* env) {
      env->context()->GetMicrotaskQueue()->EnqueueMicrotask(
        env->isolate(),
        [](void* arg) {
          DestroyAsyncIdsCallback(static_cast<Environment*>(arg));
        }, env);
      });
  }",54,,565,2,,void
8704,BLOCK,-1,,"{
  CHECK_NE(provider_type(), PROVIDER_NONE);

  if (async_id_ != kInvalidAsyncId) {
    // This instance was in use before, we have already emitted an init with
    // its previous async_id and need to emit a matching destroy for that
    // before generating a new async_id.
    EmitDestroy();
  }

  // Now we can assign a new async_id_ to this instance.
  async_id_ = execution_async_id == kInvalidAsyncId ? env()->new_async_id()
                                                     : execution_async_id;
  trigger_async_id_ = env()->get_default_trigger_async_id();

  {
    HandleScope handle_scope(env()->isolate());
    Local<Object> obj = object();
    CHECK(!obj.IsEmpty());
    if (resource != obj) {
      USE(obj->Set(env()->context(), env()->resource_symbol(), resource));
    }
  }

  switch (provider_type()) {
#define V(PROVIDER)                                                           \
    case PROVIDER_ ## PROVIDER:                                               \
      if (*...",41,,582,4,,void
8712,BLOCK,-1,,"{
    // This instance was in use before, we have already emitted an init with
    // its previous async_id and need to emit a matching destroy for that
    // before generating a new async_id.
    EmitDestroy();
  }",37,,585,2,,void
8731,BLOCK,5,,"{
    HandleScope handle_scope(env()->isolate());
    Local<Object> obj = object();
    CHECK(!obj.IsEmpty());
    if (resource != obj) {
      USE(obj->Set(env()->context(), env()->resource_symbol(), resource));
    }
  }",3,,597,5,,void
8755,BLOCK,-1,,"{
      USE(obj->Set(env()->context(), env()->resource_symbol(), resource));
    }",26,,601,2,,void
8772,BLOCK,-1,,"{
#define V(PROVIDER)                                                           \
    case PROVIDER_ ## PROVIDER:                                               \
      if (*TRACE_EVENT_API_GET_CATEGORY_GROUP_ENABLED(                        \
          TRACING_CATEGORY_NODE1(async_hooks))) {                             \
        auto data = tracing::TracedValue::Create();                           \
        data->SetInteger(""executionAsyncId"",                                  \
                         static_cast<int64_t>(env()->execution_async_id()));  \
        data->SetInteger(""triggerAsyncId"",                                    \
                         static_cast<int64_t>(get_trigger_async_id()));       \
        TRACE_EVENT_NESTABLE_ASYNC_BEGIN1(                                    \
          TRACING_CATEGORY_NODE1(async_hooks),                                \
          #PROVIDER, static_cast<int64_t>(get_async_id()),                    \
          ""data"", std::move(data));...",28,,606,2,,void
8779,BLOCK,-1,,<empty>,15,,628,2,,void
8802,BLOCK,-1,,"{
  CHECK(!object.IsEmpty());
  CHECK(!type.IsEmpty());
  AsyncHooks* async_hooks = env->async_hooks();

  // Nothing to execute, so can continue normally.
  if (async_hooks->fields()[AsyncHooks::kInit] == 0) {
    return;
  }

  HandleScope scope(env->isolate());
  Local<Function> init_fn = env->async_hooks_init_function();

  Local<Value> argv[] = {
    Number::New(env->isolate(), async_id),
    type,
    Number::New(env->isolate(), trigger_async_id),
    object,
  };

  TryCatchScope try_catch(env, TryCatchScope::CatchMode::kFatal);
  USE(init_fn->Call(env->context(), object, arraysize(argv), argv));
}",56,,639,6,,void
8833,BLOCK,-1,,"{
    return;
  }",54,,645,2,,void
8902,BLOCK,-1,,"{
  EmitTraceEventBefore();

  ProviderType provider = provider_type();
  async_context context { get_async_id(), get_trigger_async_id() };
  MaybeLocal<Value> ret = InternalMakeCallback(
      env(), object(), object(), cb, argc, argv, context);

  // This is a static call with cached values because the `this` object may
  // no longer be alive at this point.
  EmitTraceEventAfter(provider, context.async_id);

  return ret;
}",63,,666,4,,void
8938,BLOCK,-1,,"{
  return provider_names[provider_type()];
}",47,,681,1,,void
8946,BLOCK,-1,,"{
  char buf[64];
  snprintf(buf,
           sizeof(buf),
           ""%s(%"" PRIu64 "":%.0f)"",
           MemoryInfoName(),
           env()->thread_id(),
           async_id_);
  return buf;
}",48,,685,1,,void
8954,BLOCK,-1,,"{
  return GetOwner(env(), object());
}",37,,696,1,,void
8964,BLOCK,-1,,"{
  EscapableHandleScope handle_scope(env->isolate());
  CHECK(!obj.IsEmpty());

  TryCatchScope ignore_exceptions(env);
  while (true) {
    Local<Value> owner;
    if (!obj->Get(env->context(),
                  env->owner_symbol()).ToLocal(&owner) ||
        !owner->IsObject()) {
      return handle_scope.Escape(obj);
    }

    obj = owner.As<Object>();
  }
}",72,,700,3,,void
8982,BLOCK,-1,,"{
    Local<Value> owner;
    if (!obj->Get(env->context(),
                  env->owner_symbol()).ToLocal(&owner) ||
        !owner->IsObject()) {
      return handle_scope.Escape(obj);
    }

    obj = owner.As<Object>();
  }",16,,705,2,,void
9013,BLOCK,-1,,"{
      return handle_scope.Escape(obj);
    }",29,,709,2,,void
9039,BLOCK,-1,,<empty>,1,,1,1,,ANY
9050,BLOCK,-1,,<empty>,1,,1,1,,ANY
9063,BLOCK,-1,,<empty>,1,,1,1,,ANY
9068,BLOCK,-1,,<empty>,1,,1,1,,ANY
9081,BLOCK,-1,,<empty>,1,,1,1,,ANY
9085,BLOCK,-1,,"{
        BaseObject* obj = data.GetParameter();
        // Clear the persistent handle so that ~BaseObject() doesn't attempt
        // to mess with internal fields, since the JS object may have
        // transitioned into an invalid state.
        // Refs: https://github.com/nodejs/node/issues/18897
        obj->persistent_handle_.Reset();
        CHECK_IMPLIES(obj->has_pointer_data(),
                      obj->pointer_data()->strong_ptr_count == 0);
        obj->OnGCCollect();
      }",52,,55,2,,void
9128,BLOCK,-1,,<empty>,1,,1,1,,ANY
9133,BLOCK,-1,,"{
  CHECK_EQ(false, object.IsEmpty());
  CHECK_GE(object->InternalFieldCount(), BaseObject::kInternalFieldCount);
  SetInternalFields(object, static_cast<void*>(this));
  realm->AddCleanupHook(DeleteMe, static_cast<void*>(this));
  realm->modify_base_object_count(1);
}",67,,17,3,,void
9169,BLOCK,-1,,"{
  realm()->modify_base_object_count(-1);
  realm()->RemoveCleanupHook(DeleteMe, static_cast<void*>(this));

  if (UNLIKELY(has_pointer_data())) {
    PointerData* metadata = pointer_data();
    CHECK_EQ(metadata->strong_ptr_count, 0);
    metadata->self = nullptr;
    if (metadata->weak_ptr_count == 0) delete metadata;
  }

  if (persistent_handle_.IsEmpty()) {
    // This most likely happened because the weak callback below cleared it.
    return;
  }

  {
    HandleScope handle_scope(realm()->isolate());
    object()->SetAlignedPointerInInternalField(BaseObject::kSlot, nullptr);
  }
}",27,,25,1,,void
9185,BLOCK,-1,,<empty>,7,,29,1,,void
9187,BLOCK,-1,,"{
    PointerData* metadata = pointer_data();
    CHECK_EQ(metadata->strong_ptr_count, 0);
    metadata->self = nullptr;
    if (metadata->weak_ptr_count == 0) delete metadata;
  }",37,,29,2,,void
9208,BLOCK,-1,,<empty>,40,,33,2,,void
9216,BLOCK,-1,,"{
    // This most likely happened because the weak callback below cleared it.
    return;
  }",37,,36,2,,void
9218,BLOCK,5,,"{
    HandleScope handle_scope(realm()->isolate());
    object()->SetAlignedPointerInInternalField(BaseObject::kSlot, nullptr);
  }",3,,41,5,,void
9236,BLOCK,-1,,"{
  if (has_pointer_data()) {
    pointer_data()->wants_weak_jsobj = true;
    if (pointer_data()->strong_ptr_count > 0) return;
  }

  persistent_handle_.SetWeak(
      this,
      [](const WeakCallbackInfo<BaseObject>& data) {
        BaseObject* obj = data.GetParameter();
        // Clear the persistent handle so that ~BaseObject() doesn't attempt
        // to mess with internal fields, since the JS object may have
        // transitioned into an invalid state.
        // Refs: https://github.com/nodejs/node/issues/18897
        obj->persistent_handle_.Reset();
        CHECK_IMPLIES(obj->has_pointer_data(),
                      obj->pointer_data()->strong_ptr_count == 0);
        obj->OnGCCollect();
      },
      WeakCallbackType::kParameter);
}",29,,47,1,,void
9239,BLOCK,-1,,"{
    pointer_data()->wants_weak_jsobj = true;
    if (pointer_data()->strong_ptr_count > 0) return;
  }",27,,48,2,,void
9251,BLOCK,-1,,<empty>,47,,50,2,,void
9270,BLOCK,-1,,"{
  DCHECK(args.IsConstructCall());
  CHECK_GE(args.This()->InternalFieldCount(), BaseObject::kInternalFieldCount);
  SetInternalFields(args.This(), nullptr);
}",46,,77,2,,void
9297,BLOCK,-1,,"{
  return MakeLazilyInitializedJSTemplate(env->isolate_data());
}",23,,84,2,,void
9308,BLOCK,-1,,"{
  Local<FunctionTemplate> t = NewFunctionTemplate(
      isolate_data->isolate(), LazilyInitializedJSTemplateConstructor);
  t->InstanceTemplate()->SetInternalFieldCount(BaseObject::kInternalFieldCount);
  return t;
}",32,,89,2,,void
9336,BLOCK,-1,,"{
  if (!has_pointer_data()) {
    PointerData* metadata = new PointerData();
    metadata->wants_weak_jsobj = persistent_handle_.IsWeak();
    metadata->self = this;
    pointer_data_ = metadata;
  }
  CHECK(has_pointer_data());
  return pointer_data_;
}",53,,96,1,,void
9340,BLOCK,-1,,"{
    PointerData* metadata = new PointerData();
    metadata->wants_weak_jsobj = persistent_handle_.IsWeak();
    metadata->self = this;
    pointer_data_ = metadata;
  }",28,,97,2,,void
9368,BLOCK,-1,,"{
  CHECK(has_pointer_data());
  PointerData* metadata = pointer_data();
  CHECK_GT(metadata->strong_ptr_count, 0);
  unsigned int new_refcount = --metadata->strong_ptr_count;
  if (new_refcount == 0) {
    if (metadata->is_detached) {
      OnGCCollect();
    } else if (metadata->wants_weak_jsobj && !persistent_handle_.IsEmpty()) {
      MakeWeak();
    }
  }
}",38,,107,1,,void
9390,BLOCK,-1,,"{
    if (metadata->is_detached) {
      OnGCCollect();
    } else if (metadata->wants_weak_jsobj && !persistent_handle_.IsEmpty()) {
      MakeWeak();
    }
  }",26,,112,2,,void
9395,BLOCK,-1,,"{
      OnGCCollect();
    }",32,,113,2,,void
9398,BLOCK,-1,,<empty>,12,,115,1,,void
9409,BLOCK,-1,,"{
      MakeWeak();
    }",77,,115,2,,void
9414,BLOCK,-1,,"{
  unsigned int prev_refcount = pointer_data()->strong_ptr_count++;
  if (prev_refcount == 0 && !persistent_handle_.IsEmpty())
    persistent_handle_.ClearWeak();
}",38,,121,1,,void
9432,BLOCK,-1,,<empty>,5,,124,2,,void
9441,BLOCK,-1,,"{
  BaseObject* self = static_cast<BaseObject*>(data);
  if (self->has_pointer_data() && self->pointer_data()->strong_ptr_count > 0) {
    return self->Detach();
  }
  delete self;
}",39,,127,2,,void
9462,BLOCK,-1,,"{
    return self->Detach();
  }",79,,129,2,,void
9473,BLOCK,-1,,"{
  return true;
}",45,,135,1,,void
9479,BLOCK,-1,,"{
  return object();
}",49,,139,1,,void
9485,BLOCK,-1,,"{
  return !persistent_handle_.IsWeak();
}",37,,143,1,,void
9495,BLOCK,-1,,"{
  return IsWeakOrDetached();
}",60,,147,1,,void
9512,BLOCK,-1,,<empty>,1,,1,1,,ANY
9519,BLOCK,-1,,<empty>,1,,1,1,,ANY
9538,BLOCK,-1,,<empty>,1,,1,1,,ANY
9547,BLOCK,-1,,<empty>,1,,1,1,,ANY
9554,BLOCK,-1,,<empty>,1,,1,1,,ANY
9561,BLOCK,-1,,<empty>,1,,1,1,,ANY
9565,BLOCK,-1,,{ delete handle; },60,,763,2,,void
9573,BLOCK,-1,,{ uv_freeaddrinfo(res); },37,,1434,1,,void
9583,BLOCK,-1,,"{
      for (auto p = res; p != nullptr; p = p->ai_next) {
        CHECK_EQ(p->ai_socktype, SOCK_STREAM);

        const char* addr;
        if (want_ipv4 && p->ai_family == AF_INET) {
          addr = reinterpret_cast<char*>(
              &(reinterpret_cast<struct sockaddr_in*>(p->ai_addr)->sin_addr));
        } else if (want_ipv6 && p->ai_family == AF_INET6) {
          addr = reinterpret_cast<char*>(
              &(reinterpret_cast<struct sockaddr_in6*>(p->ai_addr)->sin6_addr));
        } else {
          continue;
        }

        char ip[INET6_ADDRSTRLEN];
        if (uv_inet_ntop(p->ai_family, addr, ip, sizeof(ip)))
          continue;

        Local<String> s = OneByteString(env->isolate(), ip);
        if (results->Set(env->context(), n, s).IsNothing())
          return Nothing<bool>();
        n++;
      }
      return Just(true);
    }",68,,1453,3,,void
9585,BLOCK,-1,,<empty>,7,,1454,1,,void
9598,BLOCK,4,,"{
        CHECK_EQ(p->ai_socktype, SOCK_STREAM);

        const char* addr;
        if (want_ipv4 && p->ai_family == AF_INET) {
          addr = reinterpret_cast<char*>(
              &(reinterpret_cast<struct sockaddr_in*>(p->ai_addr)->sin_addr));
        } else if (want_ipv6 && p->ai_family == AF_INET6) {
          addr = reinterpret_cast<char*>(
              &(reinterpret_cast<struct sockaddr_in6*>(p->ai_addr)->sin6_addr));
        } else {
          continue;
        }

        char ip[INET6_ADDRSTRLEN];
        if (uv_inet_ntop(p->ai_family, addr, ip, sizeof(ip)))
          continue;

        Local<String> s = OneByteString(env->isolate(), ip);
        if (results->Set(env->context(), n, s).IsNothing())
          return Nothing<bool>();
        n++;
      }",56,,1454,4,,void
9613,BLOCK,-1,,"{
          addr = reinterpret_cast<char*>(
              &(reinterpret_cast<struct sockaddr_in*>(p->ai_addr)->sin_addr));
        }",51,,1458,2,,void
9627,BLOCK,-1,,<empty>,16,,1461,1,,void
9636,BLOCK,-1,,"{
          addr = reinterpret_cast<char*>(
              &(reinterpret_cast<struct sockaddr_in6*>(p->ai_addr)->sin6_addr));
        }",59,,1461,2,,void
9650,BLOCK,-1,,"{
          continue;
        }",16,,1464,1,,void
9662,BLOCK,-1,,<empty>,11,,1470,2,,void
9690,BLOCK,-1,,<empty>,11,,1474,2,,void
9704,BLOCK,-1,,{ ares_free_data(servers); },37,,1660,1,,void
9751,BLOCK,-1,,<empty>,1,,1,1,,ANY
9758,BLOCK,-1,,"{
  return static_cast<uint32_t>(p[0] << 8U) | (static_cast<uint32_t>(p[1]));
}",57,,81,2,,void
9779,BLOCK,-1,,"{
  NodeAresTask* task = ContainerOf(&NodeAresTask::poll_watcher, watcher);
  ChannelWrap* channel = task->channel;

  /* Reset the idle timer */
  uv_timer_again(channel->timer_handle());

  if (status < 0) {
    /* An error happened. Just pretend that the socket is both readable and */
    /* writable. */
    ares_process_fd(channel->cares_channel(), task->sock, task->sock);
    return;
  }

  /* Process DNS responses */
  ares_process_fd(channel->cares_channel(),
                  events & UV_READABLE ? task->sock : ARES_SOCKET_BAD,
                  events & UV_WRITABLE ? task->sock : ARES_SOCKET_BAD);
}",63,,85,4,,void
9804,BLOCK,-1,,"{
    /* An error happened. Just pretend that the socket is both readable and */
    /* writable. */
    ares_process_fd(channel->cares_channel(), task->sock, task->sock);
    return;
  }",19,,92,2,,void
9842,BLOCK,-1,,"{
  std::unique_ptr<NodeAresTask> free_me(
        ContainerOf(&NodeAresTask::poll_watcher, watcher));
}",45,,106,2,,void
9863,BLOCK,-1,,"{
  ChannelWrap* channel = static_cast<ChannelWrap*>(data);
  NodeAresTask* task;

  NodeAresTask lookup_task;
  lookup_task.sock = sock;
  auto it = channel->task_list()->find(&lookup_task);

  task = (it == channel->task_list()->end()) ? nullptr : *it;

  if (read || write) {
    if (!task) {
      /* New socket */
      channel->StartTimer();

      task = NodeAresTask::Create(channel, sock);
      if (task == nullptr) {
        /* This should never happen unless we're out of memory or something */
        /* is seriously wrong. The socket won't be polled, but the query will */
        /* eventually time out. */
        return;
      }

      channel->task_list()->insert(task);
    }

    /* This should never fail. If it fails anyway, the query will eventually */
    /* time out. */
    uv_poll_start(&task->poll_watcher,
                  (read ? UV_READABLE : 0) | (write ? UV_WRITABLE : 0),
                  ares_poll_cb);

  } else {
    /* read == 0 and write == 0 this is c-ar...",77,,113,5,,void
9908,BLOCK,-1,,"{
    if (!task) {
      /* New socket */
      channel->StartTimer();

      task = NodeAresTask::Create(channel, sock);
      if (task == nullptr) {
        /* This should never happen unless we're out of memory or something */
        /* is seriously wrong. The socket won't be polled, but the query will */
        /* eventually time out. */
        return;
      }

      channel->task_list()->insert(task);
    }

    /* This should never fail. If it fails anyway, the query will eventually */
    /* time out. */
    uv_poll_start(&task->poll_watcher,
                  (read ? UV_READABLE : 0) | (write ? UV_WRITABLE : 0),
                  ares_poll_cb);

  }",22,,123,2,,void
9912,BLOCK,-1,,"{
      /* New socket */
      channel->StartTimer();

      task = NodeAresTask::Create(channel, sock);
      if (task == nullptr) {
        /* This should never happen unless we're out of memory or something */
        /* is seriously wrong. The socket won't be polled, but the query will */
        /* eventually time out. */
        return;
      }

      channel->task_list()->insert(task);
    }",16,,124,2,,void
9929,BLOCK,-1,,"{
        /* This should never happen unless we're out of memory or something */
        /* is seriously wrong. The socket won't be polled, but the query will */
        /* eventually time out. */
        return;
      }",28,,129,2,,void
9955,BLOCK,-1,,"{
    /* read == 0 and write == 0 this is c-ares's way of notifying us that */
    /* the socket is now closed. We must free the data associated with */
    /* socket. */
    CHECK(task &&
          ""When an ares socket is closed we should have a handle for it"");

    channel->task_list()->erase(it);
    channel->env()->CloseHandle(&task->poll_watcher, ares_poll_close_cb);

    if (channel->task_list()->empty()) {
      channel->CloseTimer();
    }
  }",10,,145,1,,void
9988,BLOCK,-1,,"{
      channel->CloseTimer();
    }",40,,155,2,,void
9998,BLOCK,-1,,"{
  EscapableHandleScope scope(env->isolate());

  std::vector<Local<Value>> names;

  for (uint32_t i = 0; host->h_aliases[i] != nullptr; ++i)
    names.emplace_back(OneByteString(env->isolate(), host->h_aliases[i]));

  Local<Array> ret = Array::New(env->isolate(), names.data(), names.size());

  return scope.Escape(ret);
}",69,,161,3,,void
10015,BLOCK,-1,,<empty>,3,,166,1,,void
10077,BLOCK,-1,,"{
  size_t offset = names->Length();

  for (uint32_t i = 0; host->h_aliases[i] != nullptr; ++i) {
    names->Set(
        env->context(),
        i + offset,
        OneByteString(env->isolate(), host->h_aliases[i])).Check();
  }

  return names;
}",49,,176,4,,void
10086,BLOCK,-1,,<empty>,3,,179,1,,void
10100,BLOCK,4,,"{
    names->Set(
        env->context(),
        i + offset,
        OneByteString(env->isolate(), host->h_aliases[i])).Check();
  }",60,,179,4,,void
10133,BLOCK,-1,,"{
  MaybeStackBuffer<Local<Value>, 8> ttls(naddrttls);
  for (size_t i = 0; i < naddrttls; i++)
    ttls[i] = Integer::NewFromUnsigned(env->isolate(), addrttls[i].ttl);

  return Array::New(env->isolate(), ttls.out(), naddrttls);
}",23,,193,4,,void
10138,BLOCK,-1,,<empty>,3,,195,1,,void
10189,BLOCK,-1,,"{
  HandleScope handle_scope(env->isolate());
  hostent* host;

  int status;
  switch (*type) {
    case ns_t_a:
    case ns_t_cname:
    case ns_t_cname_or_a:
      status = ares_parse_a_reply(buf,
                                  len,
                                  &host,
                                  static_cast<ares_addrttl*>(addrttls),
                                  naddrttls);
      break;
    case ns_t_aaaa:
      status = ares_parse_aaaa_reply(buf,
                                     len,
                                     &host,
                                     static_cast<ares_addr6ttl*>(addrttls),
                                     naddrttls);
      break;
    case ns_t_ns:
      status = ares_parse_ns_reply(buf, len, &host);
      break;
    case ns_t_ptr:
      status = ares_parse_ptr_reply(buf, len, nullptr, 0, AF_INET, &host);
      break;
    default:
      UNREACHABLE(""Bad NS type"");
  }

  if (status != ARES_SUCCESS)
    return status;

  CHECK...",31,,208,8,,void
10201,BLOCK,-1,,"{
    case ns_t_a:
    case ns_t_cname:
    case ns_t_cname_or_a:
      status = ares_parse_a_reply(buf,
                                  len,
                                  &host,
                                  static_cast<ares_addrttl*>(addrttls),
                                  naddrttls);
      break;
    case ns_t_aaaa:
      status = ares_parse_aaaa_reply(buf,
                                     len,
                                     &host,
                                     static_cast<ares_addr6ttl*>(addrttls),
                                     naddrttls);
      break;
    case ns_t_ns:
      status = ares_parse_ns_reply(buf, len, &host);
      break;
    case ns_t_ptr:
      status = ares_parse_ptr_reply(buf, len, nullptr, 0, AF_INET, &host);
      break;
    default:
      UNREACHABLE(""Bad NS type"");
  }",18,,213,2,,void
10264,BLOCK,-1,,<empty>,5,,241,2,,void
10292,BLOCK,-1,,"{
    // A cname lookup always returns a single record but we follow the
    // common API here.
    *type = ns_t_cname;
    ret->Set(env->context(),
             ret->Length(),
             OneByteString(env->isolate(), ptr->h_name)).Check();
    return ARES_SUCCESS;
  }",28,,250,2,,void
10327,BLOCK,-1,,<empty>,5,,261,2,,void
10337,BLOCK,-1,,"{
    HostentToNames(env, ptr.get(), ret);
  }",25,,263,2,,void
10346,BLOCK,-1,,<empty>,10,,265,1,,void
10352,BLOCK,-1,,"{
    uint32_t offset = ret->Length();
    for (uint32_t i = 0; ptr->h_aliases[i] != nullptr; i++) {
      auto alias = OneByteString(env->isolate(), ptr->h_aliases[i]);
      ret->Set(env->context(), i + offset, alias).Check();
    }
  }",33,,265,2,,void
10361,BLOCK,-1,,<empty>,5,,267,1,,void
10375,BLOCK,4,,"{
      auto alias = OneByteString(env->isolate(), ptr->h_aliases[i]);
      ret->Set(env->context(), i + offset, alias).Check();
    }",61,,267,4,,void
10405,BLOCK,-1,,"{
    uint32_t offset = ret->Length();
    char ip[INET6_ADDRSTRLEN];
    for (uint32_t i = 0; ptr->h_addr_list[i] != nullptr; ++i) {
      uv_inet_ntop(ptr->h_addrtype, ptr->h_addr_list[i], ip, sizeof(ip));
      auto address = OneByteString(env->isolate(), ip);
      ret->Set(env->context(), i + offset, address).Check();
    }
  }",10,,271,1,,void
10415,BLOCK,-1,,<empty>,5,,274,1,,void
10429,BLOCK,4,,"{
      uv_inet_ntop(ptr->h_addrtype, ptr->h_addr_list[i], ip, sizeof(ip));
      auto address = OneByteString(env->isolate(), ip);
      ret->Set(env->context(), i + offset, address).Check();
    }",63,,274,4,,void
10476,BLOCK,-1,,"{
  HandleScope handle_scope(env->isolate());

  struct ares_mx_reply* mx_start;
  int status = ares_parse_mx_reply(buf, len, &mx_start);
  if (status != ARES_SUCCESS)
    return status;

  uint32_t offset = ret->Length();
  ares_mx_reply* current = mx_start;
  for (uint32_t i = 0; current != nullptr; ++i, current = current->next) {
    Local<Object> mx_record = Object::New(env->isolate());
    mx_record->Set(env->context(),
                   env->exchange_string(),
                   OneByteString(env->isolate(), current->host)).Check();
    mx_record->Set(env->context(),
                   env->priority_string(),
                   Integer::New(env->isolate(), current->priority)).Check();
    if (need_type)
      mx_record->Set(env->context(),
                     env->type_string(),
                     env->dns_mx_string()).Check();

    ret->Set(env->context(), i + offset, mx_record).Check();
  }

  ares_free_data(mx_start);
  return ARES_SUCCESS;
}",29,,289,6,,void
10496,BLOCK,-1,,<empty>,5,,295,2,,void
10511,BLOCK,-1,,<empty>,3,,299,1,,void
10527,BLOCK,4,,"{
    Local<Object> mx_record = Object::New(env->isolate());
    mx_record->Set(env->context(),
                   env->exchange_string(),
                   OneByteString(env->isolate(), current->host)).Check();
    mx_record->Set(env->context(),
                   env->priority_string(),
                   Integer::New(env->isolate(), current->priority)).Check();
    if (need_type)
      mx_record->Set(env->context(),
                     env->type_string(),
                     env->dns_mx_string()).Check();

    ret->Set(env->context(), i + offset, mx_record).Check();
  }",74,,299,4,,void
10593,BLOCK,-1,,<empty>,7,,308,2,,void
10640,BLOCK,-1,,"{
  HandleScope handle_scope(env->isolate());

  struct ares_caa_reply* caa_start;
  int status = ares_parse_caa_reply(buf, len, &caa_start);
  if (status != ARES_SUCCESS)
    return status;

  uint32_t offset = ret->Length();
  ares_caa_reply* current = caa_start;
  for (uint32_t i = 0; current != nullptr; ++i, current = current->next) {
    Local<Object> caa_record = Object::New(env->isolate());

    caa_record->Set(env->context(),
                    env->dns_critical_string(),
                    Integer::New(env->isolate(), current->critical)).Check();
    caa_record->Set(env->context(),
                    OneByteString(env->isolate(), current->property),
                    OneByteString(env->isolate(), current->value)).Check();
    if (need_type)
      caa_record->Set(env->context(),
                      env->type_string(),
                      env->dns_caa_string()).Check();

    ret->Set(env->context(), i + offset, caa_record).Check();
  }

  ares_free_data(caa_start);
 ...",29,,324,6,,void
10660,BLOCK,-1,,<empty>,5,,330,2,,void
10675,BLOCK,-1,,<empty>,3,,334,1,,void
10691,BLOCK,4,,"{
    Local<Object> caa_record = Object::New(env->isolate());

    caa_record->Set(env->context(),
                    env->dns_critical_string(),
                    Integer::New(env->isolate(), current->critical)).Check();
    caa_record->Set(env->context(),
                    OneByteString(env->isolate(), current->property),
                    OneByteString(env->isolate(), current->value)).Check();
    if (need_type)
      caa_record->Set(env->context(),
                      env->type_string(),
                      env->dns_caa_string()).Check();

    ret->Set(env->context(), i + offset, caa_record).Check();
  }",74,,334,4,,void
10761,BLOCK,-1,,<empty>,7,,344,2,,void
10808,BLOCK,-1,,"{
  HandleScope handle_scope(env->isolate());

  struct ares_txt_ext* txt_out;

  int status = ares_parse_txt_reply_ext(buf, len, &txt_out);
  if (status != ARES_SUCCESS)
    return status;

  Local<Array> txt_chunk;

  struct ares_txt_ext* current = txt_out;
  uint32_t i = 0, j;
  uint32_t offset = ret->Length();
  for (j = 0; current != nullptr; current = current->next) {
    Local<String> txt =
        OneByteString(env->isolate(), current->txt, current->length);

    // New record found - write out the current chunk
    if (current->record_start) {
      if (!txt_chunk.IsEmpty()) {
        if (need_type) {
          Local<Object> elem = Object::New(env->isolate());
          elem->Set(env->context(), env->entries_string(), txt_chunk).Check();
          elem->Set(env->context(),
                    env->type_string(),
                    env->dns_txt_string()).Check();
          ret->Set(env->context(), offset + i++, elem).Check();
        } else {
          ret->Set(env->context...",29,,360,6,,void
10828,BLOCK,-1,,<empty>,5,,367,2,,void
10853,BLOCK,-1,,<empty>,3,,374,1,,void
10865,BLOCK,4,,"{
    Local<String> txt =
        OneByteString(env->isolate(), current->txt, current->length);

    // New record found - write out the current chunk
    if (current->record_start) {
      if (!txt_chunk.IsEmpty()) {
        if (need_type) {
          Local<Object> elem = Object::New(env->isolate());
          elem->Set(env->context(), env->entries_string(), txt_chunk).Check();
          elem->Set(env->context(),
                    env->type_string(),
                    env->dns_txt_string()).Check();
          ret->Set(env->context(), offset + i++, elem).Check();
        } else {
          ret->Set(env->context(), offset + i++, txt_chunk).Check();
        }
      }

      txt_chunk = Array::New(env->isolate());
      j = 0;
    }

    txt_chunk->Set(env->context(), j++, txt).Check();
  }",60,,374,4,,void
10887,BLOCK,-1,,"{
      if (!txt_chunk.IsEmpty()) {
        if (need_type) {
          Local<Object> elem = Object::New(env->isolate());
          elem->Set(env->context(), env->entries_string(), txt_chunk).Check();
          elem->Set(env->context(),
                    env->type_string(),
                    env->dns_txt_string()).Check();
          ret->Set(env->context(), offset + i++, elem).Check();
        } else {
          ret->Set(env->context(), offset + i++, txt_chunk).Check();
        }
      }

      txt_chunk = Array::New(env->isolate());
      j = 0;
    }",32,,379,2,,void
10894,BLOCK,-1,,"{
        if (need_type) {
          Local<Object> elem = Object::New(env->isolate());
          elem->Set(env->context(), env->entries_string(), txt_chunk).Check();
          elem->Set(env->context(),
                    env->type_string(),
                    env->dns_txt_string()).Check();
          ret->Set(env->context(), offset + i++, elem).Check();
        } else {
          ret->Set(env->context(), offset + i++, txt_chunk).Check();
        }
      }",33,,380,2,,void
10897,BLOCK,-1,,"{
          Local<Object> elem = Object::New(env->isolate());
          elem->Set(env->context(), env->entries_string(), txt_chunk).Check();
          elem->Set(env->context(),
                    env->type_string(),
                    env->dns_txt_string()).Check();
          ret->Set(env->context(), offset + i++, elem).Check();
        }",24,,381,2,,void
10964,BLOCK,-1,,"{
          ret->Set(env->context(), offset + i++, txt_chunk).Check();
        }",16,,388,1,,void
11014,BLOCK,-1,,"{
    if (need_type) {
      Local<Object> elem = Object::New(env->isolate());
      elem->Set(env->context(), env->entries_string(), txt_chunk).Check();
      elem->Set(env->context(),
                env->type_string(),
                env->dns_txt_string()).Check();
      ret->Set(env->context(), offset + i, elem).Check();
    } else {
      ret->Set(env->context(), offset + i, txt_chunk).Check();
    }
  }",29,,401,2,,void
11017,BLOCK,-1,,"{
      Local<Object> elem = Object::New(env->isolate());
      elem->Set(env->context(), env->entries_string(), txt_chunk).Check();
      elem->Set(env->context(),
                env->type_string(),
                env->dns_txt_string()).Check();
      ret->Set(env->context(), offset + i, elem).Check();
    }",20,,402,2,,void
11083,BLOCK,-1,,"{
      ret->Set(env->context(), offset + i, txt_chunk).Check();
    }",12,,409,1,,void
11111,BLOCK,-1,,"{
  HandleScope handle_scope(env->isolate());

  struct ares_srv_reply* srv_start;
  int status = ares_parse_srv_reply(buf, len, &srv_start);
  if (status != ARES_SUCCESS)
    return status;

  ares_srv_reply* current = srv_start;
  int offset = ret->Length();
  for (uint32_t i = 0; current != nullptr; ++i, current = current->next) {
    Local<Object> srv_record = Object::New(env->isolate());
    srv_record->Set(env->context(),
                    env->name_string(),
                    OneByteString(env->isolate(), current->host)).Check();
    srv_record->Set(env->context(),
                    env->port_string(),
                    Integer::New(env->isolate(), current->port)).Check();
    srv_record->Set(env->context(),
                    env->priority_string(),
                    Integer::New(env->isolate(), current->priority)).Check();
    srv_record->Set(env->context(),
                    env->weight_string(),
                    Integer::New(env->isolate(), current->weight...",29,,424,6,,void
11131,BLOCK,-1,,<empty>,5,,430,2,,void
11146,BLOCK,-1,,<empty>,3,,434,1,,void
11162,BLOCK,4,,"{
    Local<Object> srv_record = Object::New(env->isolate());
    srv_record->Set(env->context(),
                    env->name_string(),
                    OneByteString(env->isolate(), current->host)).Check();
    srv_record->Set(env->context(),
                    env->port_string(),
                    Integer::New(env->isolate(), current->port)).Check();
    srv_record->Set(env->context(),
                    env->priority_string(),
                    Integer::New(env->isolate(), current->priority)).Check();
    srv_record->Set(env->context(),
                    env->weight_string(),
                    Integer::New(env->isolate(), current->weight)).Check();
    if (need_type)
      srv_record->Set(env->context(),
                      env->type_string(),
                      env->dns_srv_string()).Check();

    ret->Set(env->context(), i + offset, srv_record).Check();
  }",74,,434,4,,void
11280,BLOCK,-1,,<empty>,7,,449,2,,void
11327,BLOCK,-1,,"{
  HandleScope handle_scope(env->isolate());

  ares_naptr_reply* naptr_start;
  int status = ares_parse_naptr_reply(buf, len, &naptr_start);

  if (status != ARES_SUCCESS)
    return status;

  ares_naptr_reply* current = naptr_start;
  int offset = ret->Length();
  for (uint32_t i = 0; current != nullptr; ++i, current = current->next) {
    Local<Object> naptr_record = Object::New(env->isolate());
    naptr_record->Set(env->context(),
                      env->flags_string(),
                      OneByteString(env->isolate(), current->flags)).Check();
    naptr_record->Set(env->context(),
                      env->service_string(),
                      OneByteString(env->isolate(),
                                    current->service)).Check();
    naptr_record->Set(env->context(),
                      env->regexp_string(),
                      OneByteString(env->isolate(),
                                    current->regexp)).Check();
    naptr_record->Set(env->context(),
...",29,,466,6,,void
11347,BLOCK,-1,,<empty>,5,,473,2,,void
11362,BLOCK,-1,,<empty>,3,,477,1,,void
11378,BLOCK,4,,"{
    Local<Object> naptr_record = Object::New(env->isolate());
    naptr_record->Set(env->context(),
                      env->flags_string(),
                      OneByteString(env->isolate(), current->flags)).Check();
    naptr_record->Set(env->context(),
                      env->service_string(),
                      OneByteString(env->isolate(),
                                    current->service)).Check();
    naptr_record->Set(env->context(),
                      env->regexp_string(),
                      OneByteString(env->isolate(),
                                    current->regexp)).Check();
    naptr_record->Set(env->context(),
                      env->replacement_string(),
                      OneByteString(env->isolate(),
                                    current->replacement)).Check();
    naptr_record->Set(env->context(),
                      env->order_string(),
                      Integer::New(env->isolate(), current->order)).Check();
    naptr_rec...",74,,477,4,,void
11539,BLOCK,-1,,<empty>,7,,502,2,,void
11585,BLOCK,-1,,"{
  EscapableHandleScope handle_scope(env->isolate());

  // Manage memory using standardard smart pointer std::unique_tr
  struct AresDeleter {
    void operator()(char* ptr) const noexcept { ares_free_string(ptr); }
  };
  using ares_unique_ptr = std::unique_ptr<char[], AresDeleter>;

  // Can't use ares_parse_soa_reply() here which can only parse single record
  const unsigned int ancount = cares_get_16bit(buf + 6);
  unsigned char* ptr = buf + NS_HFIXEDSZ;
  char* name_temp = nullptr;
  long temp_len;  // NOLINT(runtime/int)
  int status = ares_expand_name(ptr, buf, len, &name_temp, &temp_len);
  if (status != ARES_SUCCESS) {
    // returns EBADRESP in case of invalid input
    return status == ARES_EBADNAME ? ARES_EBADRESP : status;
  }

  const ares_unique_ptr name(name_temp);

  if (ptr + temp_len + NS_QFIXEDSZ > buf + len) {
    return ARES_EBADRESP;
  }
  ptr += temp_len + NS_QFIXEDSZ;

  for (unsigned int i = 0; i < ancount; i++) {
    char* rr_name_temp = nullptr;
    lon...",25,,518,5,,void
11626,BLOCK,-1,,"{
    // returns EBADRESP in case of invalid input
    return status == ARES_EBADNAME ? ARES_EBADRESP : status;
  }",31,,533,2,,void
11647,BLOCK,-1,,"{
    return ARES_EBADRESP;
  }",49,,540,2,,void
11656,BLOCK,-1,,<empty>,3,,545,1,,void
11666,BLOCK,4,,"{
    char* rr_name_temp = nullptr;
    long rr_temp_len;  // NOLINT(runtime/int)
    int status2 = ares_expand_name(ptr, buf, len, &rr_name_temp, &rr_temp_len);

    if (status2 != ARES_SUCCESS)
      return status2 == ARES_EBADNAME ? ARES_EBADRESP : status2;

    const ares_unique_ptr rr_name(rr_name_temp);

    ptr += rr_temp_len;
    if (ptr + NS_RRFIXEDSZ > buf + len) {
      return ARES_EBADRESP;
    }

    const int rr_type = cares_get_16bit(ptr);
    const int rr_len = cares_get_16bit(ptr + 8);
    ptr += NS_RRFIXEDSZ;

    // only need SOA
    if (rr_type == ns_t_soa) {
      char* nsname_temp = nullptr;
      long nsname_temp_len;  // NOLINT(runtime/int)

      int status3 = ares_expand_name(ptr, buf, len,
                                     &nsname_temp,
                                     &nsname_temp_len);
      if (status3 != ARES_SUCCESS) {
        return status3 == ARES_EBADNAME ? ARES_EBADRESP : status3;
      }
      const ares_unique_ptr nsname(nsname_temp);
   ...",46,,545,4,,void
11687,BLOCK,-1,,<empty>,7,,551,2,,void
11709,BLOCK,-1,,"{
      return ARES_EBADRESP;
    }",41,,556,2,,void
11731,BLOCK,-1,,"{
      char* nsname_temp = nullptr;
      long nsname_temp_len;  // NOLINT(runtime/int)

      int status3 = ares_expand_name(ptr, buf, len,
                                     &nsname_temp,
                                     &nsname_temp_len);
      if (status3 != ARES_SUCCESS) {
        return status3 == ARES_EBADNAME ? ARES_EBADRESP : status3;
      }
      const ares_unique_ptr nsname(nsname_temp);
      ptr += nsname_temp_len;

      char* hostmaster_temp = nullptr;
      long hostmaster_temp_len;  // NOLINT(runtime/int)
      int status4 = ares_expand_name(ptr, buf, len,
                                     &hostmaster_temp,
                                     &hostmaster_temp_len);
      if (status4 != ARES_SUCCESS) {
        return status4 == ARES_EBADNAME ? ARES_EBADRESP : status4;
      }
      const ares_unique_ptr hostmaster(hostmaster_temp);
      ptr += hostmaster_temp_len;

      if (ptr + 5 * 4 > buf + len) {
        return ARES_EBADRESP;
      }

      const un...",30,,565,2,,void
11752,BLOCK,-1,,"{
        return status3 == ARES_EBADNAME ? ARES_EBADRESP : status3;
      }",36,,572,2,,void
11786,BLOCK,-1,,"{
        return status4 == ARES_EBADNAME ? ARES_EBADRESP : status4;
      }",36,,583,2,,void
11810,BLOCK,-1,,"{
        return ARES_EBADRESP;
      }",36,,589,2,,void
12080,BLOCK,-1,,"{
  MakeWeak();

  Setup();
}",21,,645,5,,void
12087,BLOCK,-1,,"{
  if (timer_handle_ != nullptr)
    tracker->TrackField(""timer_handle"", *timer_handle_);
  tracker->TrackField(""task_list"", task_list_, ""NodeAresTask::List"");
}",60,,651,2,,void
12092,BLOCK,-1,,<empty>,5,,653,2,,void
12111,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  CHECK_EQ(args.Length(), 2);
  CHECK(args[0]->IsInt32());
  CHECK(args[1]->IsInt32());
  const int timeout = args[0].As<Int32>()->Value();
  const int tries = args[1].As<Int32>()->Value();
  Environment* env = Environment::GetCurrent(args);
  new ChannelWrap(env, args.This(), timeout, tries);
}",64,,657,2,,void
12184,BLOCK,-1,,<empty>,27,,673,4,,void
12190,BLOCK,-1,,<empty>,74,,678,3,,void
12195,BLOCK,-1,,"{
  ChannelWrap* channel = static_cast<ChannelWrap*>(handle->data);
  CHECK_EQ(channel->timer_handle(), handle);
  CHECK_EQ(false, channel->task_list()->empty());
  ares_process_fd(channel->cares_channel(), ARES_SOCKET_BAD, ARES_SOCKET_BAD);
}",51,,682,2,,void
12230,BLOCK,-1,,"{
  tracker->TrackField(""channel"", channel);
}",61,,690,2,,void
12242,BLOCK,-1,,"{
  auto task = new NodeAresTask();

  task->channel = channel;
  task->sock = sock;

  if (uv_poll_init_socket(channel->env()->event_loop(),
                          &task->poll_watcher, sock) < 0) {
    /* This should never happen. */
    delete task;
    return nullptr;
  }

  return task;
}",78,,695,3,,void
12274,BLOCK,-1,,"{
    /* This should never happen. */
    delete task;
    return nullptr;
  }",59,,702,2,,void
12284,BLOCK,-1,,"{
  struct ares_options options;
  memset(&options, 0, sizeof(options));
  options.flags = ARES_FLAG_NOCHECKRESP;
  options.sock_state_cb = ares_sockstate_cb;
  options.sock_state_cb_data = this;
  options.timeout = timeout_;
  options.tries = tries_;

  int r;
  if (!library_inited_) {
    Mutex::ScopedLock lock(ares_library_mutex);
    // Multiple calls to ares_library_init() increase a reference counter,
    // so this is a no-op except for the first call to it.
    r = ares_library_init(ARES_LIB_INIT_ALL);
    if (r != ARES_SUCCESS)
      return env()->ThrowError(ToErrorCodeString(r));
  }

  /* We do the call to ares_init_option for caller. */
  const int optmask =
      ARES_OPT_FLAGS | ARES_OPT_TIMEOUTMS |
      ARES_OPT_SOCK_STATE_CB | ARES_OPT_TRIES;
  r = ares_init_options(&channel_, &options, optmask);

  if (r != ARES_SUCCESS) {
    Mutex::ScopedLock lock(ares_library_mutex);
    ares_library_cleanup();
    return env()->ThrowError(ToErrorCodeString(r));
  }

  library_i...",27,,711,1,,void
12321,BLOCK,-1,,"{
    Mutex::ScopedLock lock(ares_library_mutex);
    // Multiple calls to ares_library_init() increase a reference counter,
    // so this is a no-op except for the first call to it.
    r = ares_library_init(ARES_LIB_INIT_ALL);
    if (r != ARES_SUCCESS)
      return env()->ThrowError(ToErrorCodeString(r));
  }",25,,721,2,,void
12333,BLOCK,-1,,<empty>,7,,727,2,,void
12363,BLOCK,-1,,"{
    Mutex::ScopedLock lock(ares_library_mutex);
    ares_library_cleanup();
    return env()->ThrowError(ToErrorCodeString(r));
  }",26,,736,2,,void
12381,BLOCK,-1,,"{
  if (timer_handle_ == nullptr) {
    timer_handle_ = new uv_timer_t();
    timer_handle_->data = static_cast<void*>(this);
    uv_timer_init(env()->event_loop(), timer_handle_);
  } else if (uv_is_active(reinterpret_cast<uv_handle_t*>(timer_handle_))) {
    return;
  }
  int timeout = timeout_;
  if (timeout == 0) timeout = 1;
  if (timeout < 0 || timeout > 1000) timeout = 1000;
  uv_timer_start(timer_handle_, AresTimeout, timeout, timeout);
}",32,,745,1,,void
12386,BLOCK,-1,,"{
    timer_handle_ = new uv_timer_t();
    timer_handle_->data = static_cast<void*>(this);
    uv_timer_init(env()->event_loop(), timer_handle_);
  }",33,,746,2,,void
12405,BLOCK,-1,,<empty>,10,,750,1,,void
12411,BLOCK,-1,,"{
    return;
  }",75,,750,2,,void
12421,BLOCK,-1,,<empty>,21,,754,2,,void
12433,BLOCK,-1,,<empty>,38,,755,2,,void
12445,BLOCK,-1,,"{
  if (timer_handle_ == nullptr)
    return;

  env()->CloseHandle(timer_handle_, [](uv_timer_t* handle) { delete handle; });
  timer_handle_ = nullptr;
}",32,,759,1,,void
12450,BLOCK,-1,,<empty>,5,,761,2,,void
12464,BLOCK,-1,,"{
  ares_destroy(channel_);

  if (library_inited_) {
    Mutex::ScopedLock lock(ares_library_mutex);
    // This decreases the reference counter increased by ares_library_init().
    ares_library_cleanup();
  }

  CloseTimer();
}",29,,767,1,,void
12468,BLOCK,-1,,"{
    Mutex::ScopedLock lock(ares_library_mutex);
    // This decreases the reference counter increased by ares_library_init().
    ares_library_cleanup();
  }",24,,770,2,,void
12478,BLOCK,-1,,"{
  active_query_count_ += count;
  CHECK_GE(active_query_count_, 0);
}",55,,780,2,,void
12488,BLOCK,-1,,"{
  /* if last query is OK or servers are set by user self, do not check */
  if (query_last_ok_ || !is_servers_default_) {
    return;
  }

  ares_addr_port_node* servers = nullptr;

  ares_get_servers_ports(channel_, &servers);

  /* if no server or multi-servers, ignore */
  if (servers == nullptr) return;
  if (servers->next != nullptr) {
    ares_free_data(servers);
    is_servers_default_ = false;
    return;
  }

  /* if the only server is not 127.0.0.1, ignore */
  if (servers[0].family != AF_INET ||
      servers[0].addr.addr4.s_addr != htonl(INADDR_LOOPBACK) ||
      servers[0].tcp_port != 0 ||
      servers[0].udp_port != 0) {
    ares_free_data(servers);
    is_servers_default_ = false;
    return;
  }

  ares_free_data(servers);
  servers = nullptr;

  /* destroy channel and reset channel */
  ares_destroy(channel_);

  CloseTimer();
  Setup();
}",35,,793,1,,void
12494,BLOCK,-1,,"{
    return;
  }",47,,795,2,,void
12508,BLOCK,-1,,<empty>,27,,804,2,,void
12516,BLOCK,-1,,"{
    ares_free_data(servers);
    is_servers_default_ = false;
    return;
  }",33,,805,2,,void
12560,BLOCK,-1,,"{
    ares_free_data(servers);
    is_servers_default_ = false;
    return;
  }",33,,815,2,,void
12580,BLOCK,-1,,"{
  wrap->AresQuery(name, ns_c_in, ns_t_any);
  return 0;
}",67,,831,3,,void
12595,BLOCK,-1,,"{
  wrap->AresQuery(name, ns_c_in, ns_t_a);
  return 0;
}",63,,836,3,,void
12610,BLOCK,-1,,"{
  wrap->AresQuery(name, ns_c_in, ns_t_aaaa);
  return 0;
}",69,,841,3,,void
12625,BLOCK,-1,,"{
  wrap->AresQuery(name, ns_c_in, T_CAA);
  return 0;
}",67,,846,3,,void
12633,BLOCK,1,,<empty>,,,,1,,void
12642,BLOCK,-1,,"{
  wrap->AresQuery(name, ns_c_in, ns_t_cname);
  return 0;
}",71,,851,3,,void
12657,BLOCK,-1,,"{
  wrap->AresQuery(name, ns_c_in, ns_t_mx);
  return 0;
}",65,,856,3,,void
12672,BLOCK,-1,,"{
  wrap->AresQuery(name, ns_c_in, ns_t_ns);
  return 0;
}",65,,861,3,,void
12687,BLOCK,-1,,"{
  wrap->AresQuery(name, ns_c_in, ns_t_txt);
  return 0;
}",67,,866,3,,void
12702,BLOCK,-1,,"{
  wrap->AresQuery(name, ns_c_in, ns_t_srv);
  return 0;
}",67,,871,3,,void
12717,BLOCK,-1,,"{
  wrap->AresQuery(name, ns_c_in, ns_t_ptr);
  return 0;
}",67,,876,3,,void
12732,BLOCK,-1,,"{
  wrap->AresQuery(name, ns_c_in, ns_t_naptr);
  return 0;
}",71,,881,3,,void
12747,BLOCK,-1,,"{
  wrap->AresQuery(name, ns_c_in, ns_t_soa);
  return 0;
}",67,,886,3,,void
12762,BLOCK,-1,,"{
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Array> ret = Array::New(env->isolate());
  int type, status, old_count;

  /* Parse A records or CNAME records */
  ares_addrttl addrttls[256];
  int naddrttls = arraysize(addrttls);

  type = ns_t_cname_or_a;
  status = ParseGeneralReply(env,
                             buf,
                             len,
                             &type,
                             ret,
                             addrttls,
                             &naddrttls);
  uint32_t a_count = ret->Length();
  if (status != ARES_SUCCESS && status != ARES_ENODATA)
    return status;

  if (type == ns_t_a) {
    CHECK_EQ(static_cast<uint32_t>(naddrttls), a_count);
    for (uint32_t i = 0; i < a_count; i++) {
      Local<Object> o...",52,,893,3,,void
12768,BLOCK,-1,,<empty>,5,,895,2,,void
12859,BLOCK,-1,,<empty>,5,,921,2,,void
12866,BLOCK,-1,,"{
    CHECK_EQ(static_cast<uint32_t>(naddrttls), a_count);
    for (uint32_t i = 0; i < a_count; i++) {
      Local<Object> obj = Object::New(env->isolate());
      obj->Set(env->context(),
                env->address_string(),
                ret->Get(env->context(), i).ToLocalChecked()).Check();
      obj->Set(env->context(),
                env->ttl_string(),
                Integer::NewFromUnsigned(
                  env->isolate(), addrttls[i].ttl)).Check();
      obj->Set(env->context(),
                env->type_string(),
                env->dns_a_string()).Check();
      ret->Set(env->context(), i, obj).Check();
    }
  }",23,,923,2,,void
12873,BLOCK,-1,,<empty>,5,,925,1,,void
12883,BLOCK,4,,"{
      Local<Object> obj = Object::New(env->isolate());
      obj->Set(env->context(),
                env->address_string(),
                ret->Get(env->context(), i).ToLocalChecked()).Check();
      obj->Set(env->context(),
                env->ttl_string(),
                Integer::NewFromUnsigned(
                  env->isolate(), addrttls[i].ttl)).Check();
      obj->Set(env->context(),
                env->type_string(),
                env->dns_a_string()).Check();
      ret->Set(env->context(), i, obj).Check();
    }",44,,925,4,,void
12986,BLOCK,-1,,"{
    for (uint32_t i = 0; i < a_count; i++) {
      Local<Object> obj = Object::New(env->isolate());
      obj->Set(env->context(),
                env->value_string(),
                ret->Get(env->context(), i).ToLocalChecked()).Check();
      obj->Set(env->context(),
                env->type_string(),
                env->dns_cname_string()).Check();
      ret->Set(env->context(), i, obj).Check();
    }
  }",10,,939,1,,void
12988,BLOCK,-1,,<empty>,5,,940,1,,void
12998,BLOCK,4,,"{
      Local<Object> obj = Object::New(env->isolate());
      obj->Set(env->context(),
                env->value_string(),
                ret->Get(env->context(), i).ToLocalChecked()).Check();
      obj->Set(env->context(),
                env->type_string(),
                env->dns_cname_string()).Check();
      ret->Set(env->context(), i, obj).Check();
    }",44,,940,4,,void
13110,BLOCK,-1,,<empty>,5,,966,2,,void
13127,BLOCK,-1,,<empty>,3,,970,1,,void
13140,BLOCK,4,,"{
    Local<Object> obj = Object::New(env->isolate());
    obj->Set(env->context(),
              env->address_string(),
              ret->Get(env->context(), i).ToLocalChecked()).Check();
    obj->Set(env->context(),
              env->ttl_string(),
              Integer::NewFromUnsigned(
                env->isolate(), addr6ttls[i - a_count].ttl)).Check();
    obj->Set(env->context(),
              env->type_string(),
              env->dns_aaaa_string()).Check();
    ret->Set(env->context(), i, obj).Check();
  }",54,,970,4,,void
13260,BLOCK,-1,,<empty>,5,,988,2,,void
13289,BLOCK,-1,,<empty>,5,,995,2,,void
13293,BLOCK,-1,,<empty>,3,,997,1,,void
13306,BLOCK,4,,"{
    Local<Object> obj = Object::New(env->isolate());
    obj->Set(env->context(),
             env->value_string(),
             ret->Get(env->context(), i).ToLocalChecked()).Check();
    obj->Set(env->context(),
              env->type_string(),
              env->dns_ns_string()).Check();
    ret->Set(env->context(), i, obj).Check();
  }",56,,997,4,,void
13396,BLOCK,-1,,<empty>,5,,1011,2,,void
13415,BLOCK,-1,,<empty>,5,,1016,2,,void
13444,BLOCK,-1,,<empty>,5,,1023,2,,void
13448,BLOCK,-1,,<empty>,3,,1024,1,,void
13461,BLOCK,4,,"{
    Local<Object> obj = Object::New(env->isolate());
    obj->Set(env->context(),
              env->value_string(),
              ret->Get(env->context(), i).ToLocalChecked()).Check();
    obj->Set(env->context(),
              env->type_string(),
              env->dns_ptr_string()).Check();
    ret->Set(env->context(), i, obj).Check();
  }",56,,1024,4,,void
13551,BLOCK,-1,,<empty>,5,,1038,2,,void
13577,BLOCK,-1,,<empty>,5,,1044,2,,void
13586,BLOCK,-1,,<empty>,5,,1047,2,,void
13619,BLOCK,-1,,<empty>,5,,1052,2,,void
13634,BLOCK,-1,,"{
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  ares_addrttl addrttls[256];
  int naddrttls = arraysize(addrttls), status;
  Local<Array> ret = Array::New(env->isolate());

  int type = ns_t_a;
  status = ParseGeneralReply(env,
                             buf,
                             len,
                             &type,
                             ret,
                             addrttls,
                             &naddrttls);
  if (status != ARES_SUCCESS)
    return status;

  Local<Array> ttls = AddrTTLToArray<ares_addrttl>(env, addrttls, naddrttls);

  wrap->CallOnComplete(ret, ttls);
  return 0;
}",52,,1060,3,,void
13640,BLOCK,-1,,<empty>,5,,1062,2,,void
13719,BLOCK,-1,,<empty>,5,,1084,2,,void
13750,BLOCK,-1,,"{
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  ares_addr6ttl addrttls[256];
  int naddrttls = arraysize(addrttls), status;
  Local<Array> ret = Array::New(env->isolate());

  int type = ns_t_aaaa;
  status = ParseGeneralReply(env,
                             buf,
                             len,
                             &type,
                             ret,
                             addrttls,
                             &naddrttls);
  if (status != ARES_SUCCESS)
    return status;

  Local<Array> ttls = AddrTTLToArray<ares_addr6ttl>(env, addrttls, naddrttls);

  wrap->CallOnComplete(ret, ttls);
  return 0;
}",52,,1094,3,,void
13756,BLOCK,-1,,<empty>,5,,1096,2,,void
13835,BLOCK,-1,,<empty>,5,,1118,2,,void
13866,BLOCK,-1,,"{
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Array> ret = Array::New(env->isolate());
  int status = ParseCaaReply(env, buf, len, ret);
  if (status != ARES_SUCCESS)
    return status;

  wrap->CallOnComplete(ret);
  return 0;
}",52,,1128,3,,void
13872,BLOCK,-1,,<empty>,5,,1130,2,,void
13936,BLOCK,-1,,<empty>,5,,1142,2,,void
13951,BLOCK,-1,,"{
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Array> ret = Array::New(env->isolate());
  int type = ns_t_cname;
  int status = ParseGeneralReply(env, buf, len, &type, ret);
  if (status != ARES_SUCCESS)
    return status;

  wrap->CallOnComplete(ret);
  return 0;
}",52,,1150,3,,void
13957,BLOCK,-1,,<empty>,5,,1152,2,,void
14027,BLOCK,-1,,<empty>,5,,1165,2,,void
14042,BLOCK,-1,,"{
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Array> mx_records = Array::New(env->isolate());
  int status = ParseMxReply(env, buf, len, mx_records);

  if (status != ARES_SUCCESS)
    return status;

  wrap->CallOnComplete(mx_records);
  return 0;
}",52,,1173,3,,void
14048,BLOCK,-1,,<empty>,5,,1175,2,,void
14112,BLOCK,-1,,<empty>,5,,1188,2,,void
14127,BLOCK,-1,,"{
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  int type = ns_t_ns;
  Local<Array> names = Array::New(env->isolate());
  int status = ParseGeneralReply(env, buf, len, &type, names);
  if (status != ARES_SUCCESS)
    return status;

  wrap->CallOnComplete(names);
  return 0;
}",52,,1196,3,,void
14133,BLOCK,-1,,<empty>,5,,1198,2,,void
14203,BLOCK,-1,,<empty>,5,,1211,2,,void
14218,BLOCK,-1,,"{
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Array> txt_records = Array::New(env->isolate());
  int status = ParseTxtReply(env, buf, len, txt_records);
  if (status != ARES_SUCCESS)
    return status;

  wrap->CallOnComplete(txt_records);
  return 0;
}",52,,1219,3,,void
14224,BLOCK,-1,,<empty>,5,,1221,2,,void
14288,BLOCK,-1,,<empty>,5,,1233,2,,void
14303,BLOCK,-1,,"{
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Array> srv_records = Array::New(env->isolate());
  int status = ParseSrvReply(env, buf, len, srv_records);
  if (status != ARES_SUCCESS)
    return status;

  wrap->CallOnComplete(srv_records);
  return 0;
}",52,,1241,3,,void
14309,BLOCK,-1,,<empty>,5,,1243,2,,void
14373,BLOCK,-1,,<empty>,5,,1255,2,,void
14388,BLOCK,-1,,"{
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  int type = ns_t_ptr;
  Local<Array> aliases = Array::New(env->isolate());

  int status = ParseGeneralReply(env, buf, len, &type, aliases);
  if (status != ARES_SUCCESS)
    return status;

  wrap->CallOnComplete(aliases);
  return 0;
}",52,,1263,3,,void
14394,BLOCK,-1,,<empty>,5,,1265,2,,void
14464,BLOCK,-1,,<empty>,5,,1279,2,,void
14479,BLOCK,-1,,"{
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Array> naptr_records = Array::New(env->isolate());
  int status = ParseNaptrReply(env, buf, len, naptr_records);
  if (status != ARES_SUCCESS)
    return status;

  wrap->CallOnComplete(naptr_records);
  return 0;
}",52,,1287,3,,void
14485,BLOCK,-1,,<empty>,5,,1289,2,,void
14549,BLOCK,-1,,<empty>,5,,1301,2,,void
14564,BLOCK,-1,,"{
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  ares_soa_reply* soa_out;
  int status = ares_parse_soa_reply(buf, len, &soa_out);

  if (status != ARES_SUCCESS)
    return status;

  Local<Object> soa_record = Object::New(env->isolate());

  soa_record->Set(env->context(),
                  env->nsname_string(),
                  OneByteString(env->isolate(), soa_out->nsname)).Check();
  soa_record->Set(env->context(),
                  env->hostmaster_string(),
                  OneByteString(env->isolate(), soa_out->hostmaster)).Check();
  soa_record->Set(env->context(),
                  env->serial_string(),
                  Integer::NewFromUnsigned(
                      env->isolate(), soa_out->serial)).Check();
  soa_record->Set(env->context(),
             ...",52,,1309,3,,void
14570,BLOCK,-1,,<empty>,5,,1311,2,,void
14621,BLOCK,-1,,<empty>,5,,1324,2,,void
14828,BLOCK,-1,,"{
  int length, family;
  char address_buffer[sizeof(struct in6_addr)];

  if (uv_inet_pton(AF_INET, name, &address_buffer) == 0) {
    length = sizeof(struct in_addr);
    family = AF_INET;
  } else if (uv_inet_pton(AF_INET6, name, &address_buffer) == 0) {
    length = sizeof(struct in6_addr);
    family = AF_INET6;
  } else {
    return UV_EINVAL;  // So errnoException() reports a proper error.
  }

  TRACE_EVENT_NESTABLE_ASYNC_BEGIN2(
      TRACING_CATEGORY_NODE2(dns, native), ""reverse"", wrap,
      ""name"", TRACE_STR_COPY(name),
      ""family"", family == AF_INET ? ""ipv4"" : ""ipv6"");

  ares_gethostbyaddr(
      wrap->channel()->cares_channel(),
      address_buffer,
      length,
      family,
      GetHostByAddrWrap::Callback,
      wrap->MakeCallbackPointer());
  return 0;
}",68,,1358,3,,void
14840,BLOCK,-1,,"{
    length = sizeof(struct in_addr);
    family = AF_INET;
  }",58,,1362,2,,void
14849,BLOCK,-1,,<empty>,10,,1365,1,,void
14858,BLOCK,-1,,"{
    length = sizeof(struct in6_addr);
    family = AF_INET6;
  }",66,,1365,2,,void
14867,BLOCK,-1,,"{
    return UV_EINVAL;  // So errnoException() reports a proper error.
  }",10,,1368,1,,void
14911,BLOCK,-1,,"{
  if (UNLIKELY(!response->is_host))
    return ARES_EBADRESP;

  struct hostent* host = response->host.get();

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());
  wrap->CallOnComplete(HostentToNames(env, host));
  return 0;
}",52,,1389,3,,void
14918,BLOCK,-1,,<empty>,5,,1391,2,,void
14963,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  ChannelWrap* channel;
  ASSIGN_OR_RETURN_UNWRAP(&channel, args.Holder());

  CHECK_EQ(false, args.IsConstructCall());
  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsString());

  Local<Object> req_wrap_obj = args[0].As<Object>();
  Local<String> string = args[1].As<String>();
  auto wrap = std::make_unique<Wrap>(channel, req_wrap_obj);

  node::Utf8Value utf8name(env->isolate(), string);
  auto plain_name = utf8name.ToStringView();
  std::string name = ada::idna::to_ascii(plain_name);
  channel->ModifyActivityQueryCount(1);
  int err = wrap->Send(name.c_str());
  if (err) {
    channel->ModifyActivityQueryCount(-1);
  } else {
    // Release ownership of the pointer allowing the ownership to be transferred
    USE(wrap.release());
  }

  args.GetReturnValue().Set(err);
}",60,,1404,2,,void
15079,BLOCK,-1,,"{
    channel->ModifyActivityQueryCount(-1);
  }",12,,1422,2,,void
15087,BLOCK,-1,,"{
    // Release ownership of the pointer allowing the ownership to be transferred
    USE(wrap.release());
  }",10,,1424,1,,void
15106,BLOCK,-1,,"{
  auto cleanup = OnScopeLeave([&]() { uv_freeaddrinfo(res); });
  BaseObjectPtr<GetAddrInfoReqWrap> req_wrap{
      static_cast<GetAddrInfoReqWrap*>(req->data)};
  Environment* env = req_wrap->env();

  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Value> argv[] = {
    Integer::New(env->isolate(), status),
    Null(env->isolate())
  };

  uint32_t n = 0;
  const bool verbatim = req_wrap->verbatim();

  if (status == 0) {
    Local<Array> results = Array::New(env->isolate());

    auto add = [&] (bool want_ipv4, bool want_ipv6) -> Maybe<bool> {
      for (auto p = res; p != nullptr; p = p->ai_next) {
        CHECK_EQ(p->ai_socktype, SOCK_STREAM);

        const char* addr;
        if (want_ipv4 && p->ai_family == AF_INET) {
          addr = reinterpret_cast<char*>(
              &(reinterpret_cast<struct sockaddr_in*>(p->ai_addr)->sin_addr));
        } else if (want_ipv6 && p->ai_family == AF_INET6) {
          addr = reinterpre...",80,,1433,4,,void
15173,BLOCK,-1,,"{
    Local<Array> results = Array::New(env->isolate());

    auto add = [&] (bool want_ipv4, bool want_ipv6) -> Maybe<bool> {
      for (auto p = res; p != nullptr; p = p->ai_next) {
        CHECK_EQ(p->ai_socktype, SOCK_STREAM);

        const char* addr;
        if (want_ipv4 && p->ai_family == AF_INET) {
          addr = reinterpret_cast<char*>(
              &(reinterpret_cast<struct sockaddr_in*>(p->ai_addr)->sin_addr));
        } else if (want_ipv6 && p->ai_family == AF_INET6) {
          addr = reinterpret_cast<char*>(
              &(reinterpret_cast<struct sockaddr_in6*>(p->ai_addr)->sin6_addr));
        } else {
          continue;
        }

        char ip[INET6_ADDRSTRLEN];
        if (uv_inet_ntop(p->ai_family, addr, ip, sizeof(ip)))
          continue;

        Local<String> s = OneByteString(env->isolate(), ip);
        if (results->Set(env->context(), n, s).IsNothing())
          return Nothing<bool>();
        n++;
      }
      return Just(true);
    };

    if (...",20,,1450,2,,void
15199,BLOCK,-1,,<empty>,7,,1481,2,,void
15205,BLOCK,-1,,"{
      if (add(false, true).IsNothing())
        return;
    }",28,,1482,2,,void
15213,BLOCK,-1,,<empty>,9,,1484,2,,void
15219,BLOCK,-1,,"{
      argv[0] = Integer::New(env->isolate(), UV_EAI_NODATA);
    }",17,,1488,2,,void
15269,BLOCK,-1,,"{
  BaseObjectPtr<GetNameInfoReqWrap> req_wrap{
      static_cast<GetNameInfoReqWrap*>(req->data)};
  Environment* env = req_wrap->env();

  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Value> argv[] = {
    Integer::New(env->isolate(), status),
    Null(env->isolate()),
    Null(env->isolate())
  };

  if (status == 0) {
    // Success
    Local<String> js_hostname = OneByteString(env->isolate(), hostname);
    Local<String> js_service = OneByteString(env->isolate(), service);
    argv[1] = js_hostname;
    argv[2] = js_service;
  }

  TRACE_EVENT_NESTABLE_ASYNC_END2(
      TRACING_CATEGORY_NODE2(dns, native), ""lookupService"", req_wrap.get(),
      ""hostname"", TRACE_STR_COPY(hostname),
      ""service"", TRACE_STR_COPY(service));

  // Make the callback into JavaScript
  req_wrap->MakeCallback(env->oncomplete_string(), arraysize(argv), argv);
}",44,,1507,5,,void
15327,BLOCK,-1,,"{
    // Success
    Local<String> js_hostname = OneByteString(env->isolate(), hostname);
    Local<String> js_service = OneByteString(env->isolate(), service);
    argv[1] = js_hostname;
    argv[2] = js_service;
  }",20,,1521,2,,void
15392,BLOCK,-1,,"{
  Isolate* isolate = args.GetIsolate();
  node::Utf8Value ip(isolate, args[0]);

  int af;
  unsigned char result[sizeof(ares_addr_port_node::addr)];
  if (uv_inet_pton(af = AF_INET, *ip, result) != 0 &&
      uv_inet_pton(af = AF_INET6, *ip, result) != 0)
    return;

  char canonical_ip[INET6_ADDRSTRLEN];
  CHECK_EQ(0, uv_inet_ntop(af, result, canonical_ip, sizeof(canonical_ip)));
  Local<String> val = String::NewFromUtf8(isolate, canonical_ip)
      .ToLocalChecked();
  args.GetReturnValue().Set(val);
}",62,,1538,2,,void
15428,BLOCK,-1,,<empty>,5,,1546,2,,void
15466,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsString());
  CHECK(args[2]->IsInt32());
  CHECK(args[4]->IsBoolean());
  Local<Object> req_wrap_obj = args[0].As<Object>();
  node::Utf8Value hostname(env->isolate(), args[1]);
  std::string ascii_hostname = ada::idna::to_ascii(hostname.ToStringView());

  int32_t flags = 0;
  if (args[3]->IsInt32()) {
    flags = args[3].As<Int32>()->Value();
  }

  int family;

  switch (args[2].As<Int32>()->Value()) {
    case 0:
      family = AF_UNSPEC;
      break;
    case 4:
      family = AF_INET;
      break;
    case 6:
      family = AF_INET6;
      break;
    default:
      UNREACHABLE(""bad address family"");
  }

  auto req_wrap = std::make_unique<GetAddrInfoReqWrap>(env,
                                                       req_wrap_obj,
                                                       args[4]->IsTrue());

  struct addrinfo hints;
  memset(&hints, 0, sizeof(hints));
  hints.ai...",59,,1555,2,,void
15548,BLOCK,-1,,"{
    flags = args[3].As<Int32>()->Value();
  }",27,,1567,2,,void
15571,BLOCK,-1,,"{
    case 0:
      family = AF_UNSPEC;
      break;
    case 4:
      family = AF_INET;
      break;
    case 6:
      family = AF_INET6;
      break;
    default:
      UNREACHABLE(""bad address family"");
  }",41,,1573,2,,void
15681,BLOCK,-1,,<empty>,5,,1611,2,,void
15699,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsString());
  CHECK(args[2]->IsUint32());
  Local<Object> req_wrap_obj = args[0].As<Object>();
  node::Utf8Value ip(env->isolate(), args[1]);
  const unsigned port = args[2]->Uint32Value(env->context()).FromJust();
  struct sockaddr_storage addr;

  CHECK(uv_ip4_addr(*ip, port, reinterpret_cast<sockaddr_in*>(&addr)) == 0 ||
        uv_ip6_addr(*ip, port, reinterpret_cast<sockaddr_in6*>(&addr)) == 0);

  auto req_wrap = std::make_unique<GetNameInfoReqWrap>(env, req_wrap_obj);

  TRACE_EVENT_NESTABLE_ASYNC_BEGIN2(
      TRACING_CATEGORY_NODE2(dns, native), ""lookupService"", req_wrap.get(),
      ""ip"", TRACE_STR_COPY(*ip), ""port"", port);

  int err = req_wrap->Dispatch(uv_getnameinfo,
                               AfterGetNameInfo,
                               reinterpret_cast<struct sockaddr*>(&addr),
                               NI_NAMEREQD);
  if (err == 0)
    // Release owner...",59,,1617,2,,void
15835,BLOCK,-1,,<empty>,5,,1643,2,,void
15853,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  ChannelWrap* channel;
  ASSIGN_OR_RETURN_UNWRAP(&channel, args.Holder());

  Local<Array> server_array = Array::New(env->isolate());

  ares_addr_port_node* servers;

  int r = ares_get_servers_ports(channel->cares_channel(), &servers);
  CHECK_EQ(r, ARES_SUCCESS);
  auto cleanup = OnScopeLeave([&]() { ares_free_data(servers); });

  ares_addr_port_node* cur = servers;

  for (uint32_t i = 0; cur != nullptr; ++i, cur = cur->next) {
    char ip[INET6_ADDRSTRLEN];

    const void* caddr = static_cast<const void*>(&cur->addr);
    int err = uv_inet_ntop(cur->family, caddr, ip, sizeof(ip));
    CHECK_EQ(err, 0);

    Local<Value> ret[] = {
      OneByteString(env->isolate(), ip),
      Integer::New(env->isolate(), cur->udp_port)
    };

    if (server_array->Set(env->context(), i,
                          Array::New(env->isolate(), ret, arraysize(ret)))
          .IsNothing()) {
      return;
    }
  }

  args.GetReturnValue().Set...",58,,1649,2,,void
15907,BLOCK,-1,,<empty>,3,,1664,1,,void
15923,BLOCK,4,,"{
    char ip[INET6_ADDRSTRLEN];

    const void* caddr = static_cast<const void*>(&cur->addr);
    int err = uv_inet_ntop(cur->family, caddr, ip, sizeof(ip));
    CHECK_EQ(err, 0);

    Local<Value> ret[] = {
      OneByteString(env->isolate(), ip),
      Integer::New(env->isolate(), cur->udp_port)
    };

    if (server_array->Set(env->context(), i,
                          Array::New(env->isolate(), ret, arraysize(ret)))
          .IsNothing()) {
      return;
    }
  }",62,,1664,4,,void
15993,BLOCK,-1,,"{
      return;
    }",25,,1678,2,,void
16007,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  ChannelWrap* channel;
  ASSIGN_OR_RETURN_UNWRAP(&channel, args.Holder());

  if (channel->active_query_count()) {
    return args.GetReturnValue().Set(DNS_ESETSRVPENDING);
  }

  CHECK(args[0]->IsArray());

  Local<Array> arr = args[0].As<Array>();

  uint32_t len = arr->Length();

  if (len == 0) {
    int rv = ares_set_servers(channel->cares_channel(), nullptr);
    return args.GetReturnValue().Set(rv);
  }

  std::vector<ares_addr_port_node> servers(len);
  ares_addr_port_node* last = nullptr;

  int err;

  for (uint32_t i = 0; i < len; i++) {
    CHECK(arr->Get(env->context(), i).ToLocalChecked()->IsArray());

    Local<Array> elm = arr->Get(env->context(), i).ToLocalChecked().As<Array>();

    CHECK(elm->Get(env->context(),
                   0).ToLocalChecked()->Int32Value(env->context()).FromJust());
    CHECK(elm->Get(env->context(), 1).ToLocalChecked()->IsString());
    CHECK(elm->Get(env->context(),
                 ...",58,,1687,2,,void
16029,BLOCK,-1,,"{
    return args.GetReturnValue().Set(DNS_ESETSRVPENDING);
  }",38,,1692,2,,void
16069,BLOCK,-1,,"{
    int rv = ares_set_servers(channel->cares_channel(), nullptr);
    return args.GetReturnValue().Set(rv);
  }",17,,1702,2,,void
16102,BLOCK,-1,,<empty>,3,,1712,1,,void
16112,BLOCK,4,,"{
    CHECK(arr->Get(env->context(), i).ToLocalChecked()->IsArray());

    Local<Array> elm = arr->Get(env->context(), i).ToLocalChecked().As<Array>();

    CHECK(elm->Get(env->context(),
                   0).ToLocalChecked()->Int32Value(env->context()).FromJust());
    CHECK(elm->Get(env->context(), 1).ToLocalChecked()->IsString());
    CHECK(elm->Get(env->context(),
                   2).ToLocalChecked()->Int32Value(env->context()).FromJust());

    int fam = elm->Get(env->context(), 0)
        .ToLocalChecked()->Int32Value(env->context()).FromJust();
    node::Utf8Value ip(env->isolate(),
                       elm->Get(env->context(), 1).ToLocalChecked());
    int port = elm->Get(env->context(), 2)
        .ToLocalChecked()->Int32Value(env->context()).FromJust();

    ares_addr_port_node* cur = &servers[i];

    cur->tcp_port = cur->udp_port = port;
    switch (fam) {
      case 4:
        cur->family = AF_INET;
        err = uv_inet_pton(AF_INET, *ip, &cur->addr);
        brea...",38,,1712,4,,void
16298,BLOCK,-1,,"{
      case 4:
        cur->family = AF_INET;
        err = uv_inet_pton(AF_INET, *ip, &cur->addr);
        break;
      case 6:
        cur->family = AF_INET6;
        err = uv_inet_pton(AF_INET6, *ip, &cur->addr);
        break;
      default:
        UNREACHABLE(""Bad address family"");
    }",18,,1733,2,,void
16340,BLOCK,-1,,<empty>,7,,1747,2,,void
16351,BLOCK,-1,,<empty>,7,,1752,2,,void
16364,BLOCK,-1,,<empty>,5,,1758,2,,void
16377,BLOCK,-1,,<empty>,5,,1760,1,,void
16385,BLOCK,-1,,<empty>,5,,1763,2,,void
16403,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  ChannelWrap* channel;
  ASSIGN_OR_RETURN_UNWRAP(&channel, args.Holder());

  CHECK_EQ(args.Length(), 2);
  CHECK(args[0]->IsString());

  Isolate* isolate = args.GetIsolate();
  node::Utf8Value ip0(isolate, args[0]);

  unsigned char addr0[sizeof(struct in6_addr)];
  unsigned char addr1[sizeof(struct in6_addr)];
  int type0 = 0;

  // This function accepts 2 arguments.  The first may be either an IPv4
  // address or an IPv6 address.  If present, the second argument must be the
  // other type of address.  Otherwise, the unspecified type of IP is set
  // to 0 (any).

  if (uv_inet_pton(AF_INET, *ip0, &addr0) == 0) {
    ares_set_local_ip4(channel->cares_channel(), ReadUint32BE(addr0));
    type0 = 4;
  } else if (uv_inet_pton(AF_INET6, *ip0, &addr0) == 0) {
    ares_set_local_ip6(channel->cares_channel(), addr0);
    type0 = 6;
  } else {
    THROW_ERR_INVALID_ARG_VALUE(env, ""Invalid IP address."");
    return;
  }

  if (!args...",63,,1768,2,,void
16461,BLOCK,-1,,"{
    ares_set_local_ip4(channel->cares_channel(), ReadUint32BE(addr0));
    type0 = 4;
  }",49,,1788,2,,void
16473,BLOCK,-1,,<empty>,10,,1791,1,,void
16483,BLOCK,-1,,"{
    ares_set_local_ip6(channel->cares_channel(), addr0);
    type0 = 6;
  }",57,,1791,2,,void
16494,BLOCK,-1,,"{
    THROW_ERR_INVALID_ARG_VALUE(env, ""Invalid IP address."");
    return;
  }",10,,1794,1,,void
16507,BLOCK,-1,,"{
    CHECK(args[1]->IsString());
    node::Utf8Value ip1(isolate, args[1]);

    if (uv_inet_pton(AF_INET, *ip1, &addr1) == 0) {
      if (type0 == 4) {
        THROW_ERR_INVALID_ARG_VALUE(env, ""Cannot specify two IPv4 addresses."");
        return;
      } else {
        ares_set_local_ip4(channel->cares_channel(), ReadUint32BE(addr1));
      }
    } else if (uv_inet_pton(AF_INET6, *ip1, &addr1) == 0) {
      if (type0 == 6) {
        THROW_ERR_INVALID_ARG_VALUE(env, ""Cannot specify two IPv6 addresses."");
        return;
      } else {
        ares_set_local_ip6(channel->cares_channel(), addr1);
      }
    } else {
      THROW_ERR_INVALID_ARG_VALUE(env, ""Invalid IP address."");
      return;
    }
  }",32,,1799,2,,void
16530,BLOCK,-1,,"{
      if (type0 == 4) {
        THROW_ERR_INVALID_ARG_VALUE(env, ""Cannot specify two IPv4 addresses."");
        return;
      } else {
        ares_set_local_ip4(channel->cares_channel(), ReadUint32BE(addr1));
      }
    }",51,,1803,2,,void
16535,BLOCK,-1,,"{
        THROW_ERR_INVALID_ARG_VALUE(env, ""Cannot specify two IPv4 addresses."");
        return;
      }",23,,1804,2,,void
16541,BLOCK,-1,,"{
        ares_set_local_ip4(channel->cares_channel(), ReadUint32BE(addr1));
      }",14,,1807,1,,void
16550,BLOCK,-1,,<empty>,12,,1810,1,,void
16560,BLOCK,-1,,"{
      if (type0 == 6) {
        THROW_ERR_INVALID_ARG_VALUE(env, ""Cannot specify two IPv6 addresses."");
        return;
      } else {
        ares_set_local_ip6(channel->cares_channel(), addr1);
      }
    }",59,,1810,2,,void
16565,BLOCK,-1,,"{
        THROW_ERR_INVALID_ARG_VALUE(env, ""Cannot specify two IPv6 addresses."");
        return;
      }",23,,1811,2,,void
16571,BLOCK,-1,,"{
        ares_set_local_ip6(channel->cares_channel(), addr1);
      }",14,,1814,1,,void
16579,BLOCK,-1,,"{
      THROW_ERR_INVALID_ARG_VALUE(env, ""Invalid IP address."");
      return;
    }",12,,1817,1,,void
16585,BLOCK,-1,,"{
    // No second arg specified
    if (type0 == 4) {
      memset(&addr1, 0, sizeof(addr1));
      ares_set_local_ip6(channel->cares_channel(), addr1);
    } else {
      ares_set_local_ip4(channel->cares_channel(), 0);
    }
  }",10,,1821,1,,void
16590,BLOCK,-1,,"{
      memset(&addr1, 0, sizeof(addr1));
      ares_set_local_ip6(channel->cares_channel(), addr1);
    }",21,,1823,2,,void
16604,BLOCK,-1,,"{
      ares_set_local_ip4(channel->cares_channel(), 0);
    }",12,,1826,1,,void
16615,BLOCK,-1,,"{
  ChannelWrap* channel;
  ASSIGN_OR_RETURN_UNWRAP(&channel, args.Holder());

  TRACE_EVENT_INSTANT0(TRACING_CATEGORY_NODE2(dns, native),
      ""cancel"", TRACE_EVENT_SCOPE_THREAD);

  ares_cancel(channel->cares_channel());
}",54,,1832,2,,void
16643,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  int code = args[0]->Int32Value(env->context()).FromJust();
  const char* errmsg = (code == DNS_ESETSRVPENDING) ?
    EMSG_ESETSRVPENDING :
    ares_strerror(code);
  args.GetReturnValue().Set(OneByteString(env->isolate(), errmsg));
}",56,,1843,2,,void
16695,BLOCK,-1,,"{
  int idx;

  if (host->h_addr_list != nullptr) {
    idx = 0;
    while (host->h_addr_list[idx]) {
      free(host->h_addr_list[idx++]);
    }
    free(host->h_addr_list);
    host->h_addr_list = nullptr;
  }

  if (host->h_aliases != nullptr) {
    idx = 0;
    while (host->h_aliases[idx]) {
      free(host->h_aliases[idx++]);
    }
    free(host->h_aliases);
    host->h_aliases = nullptr;
  }

  free(host->h_name);
  free(host);
}",53,,1854,2,,void
16703,BLOCK,-1,,"{
    idx = 0;
    while (host->h_addr_list[idx]) {
      free(host->h_addr_list[idx++]);
    }
    free(host->h_addr_list);
    host->h_addr_list = nullptr;
  }",37,,1857,2,,void
16713,BLOCK,-1,,"{
      free(host->h_addr_list[idx++]);
    }",36,,1859,2,,void
16736,BLOCK,-1,,"{
    idx = 0;
    while (host->h_aliases[idx]) {
      free(host->h_aliases[idx++]);
    }
    free(host->h_aliases);
    host->h_aliases = nullptr;
  }",35,,1866,2,,void
16746,BLOCK,-1,,"{
      free(host->h_aliases[idx++]);
    }",34,,1868,2,,void
16776,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  SetMethod(context, target, ""getaddrinfo"", GetAddrInfo);
  SetMethod(context, target, ""getnameinfo"", GetNameInfo);
  SetMethodNoSideEffect(context, target, ""canonicalizeIP"", CanonicalizeIP);

  SetMethod(context, target, ""strerror"", StrError);

  target->Set(env->context(), FIXED_ONE_BYTE_STRING(env->isolate(), ""AF_INET""),
              Integer::New(env->isolate(), AF_INET)).Check();
  target->Set(env->context(), FIXED_ONE_BYTE_STRING(env->isolate(), ""AF_INET6""),
              Integer::New(env->isolate(), AF_INET6)).Check();
  target->Set(env->context(), FIXED_ONE_BYTE_STRING(env->isolate(),
                                                    ""AF_UNSPEC""),
              Integer::New(env->isolate(), AF_UNSPEC)).Check();
  target->Set(env->context(), FIXED_ONE_BYTE_STRING(env->isolate(),
                                                    ""AI_ADDRCONFIG""),
              Integer::New(env->is...",29,,1882,5,,void
16941,BLOCK,1,,<empty>,,,,1,,void
16969,BLOCK,1,,<empty>,,,,1,,void
17171,BLOCK,-1,,"{
  registry->Register(GetAddrInfo);
  registry->Register(GetNameInfo);
  registry->Register(CanonicalizeIP);
  registry->Register(StrError);
  registry->Register(ChannelWrap::New);

  registry->Register(Query<QueryAnyWrap>);
  registry->Register(Query<QueryAWrap>);
  registry->Register(Query<QueryAaaaWrap>);
  registry->Register(Query<QueryCaaWrap>);
  registry->Register(Query<QueryCnameWrap>);
  registry->Register(Query<QueryMxWrap>);
  registry->Register(Query<QueryNsWrap>);
  registry->Register(Query<QueryTxtWrap>);
  registry->Register(Query<QuerySrvWrap>);
  registry->Register(Query<QueryPtrWrap>);
  registry->Register(Query<QueryNaptrWrap>);
  registry->Register(Query<QuerySoaWrap>);
  registry->Register(Query<GetHostByAddrWrap>);

  registry->Register(GetServers);
  registry->Register(SetServers);
  registry->Register(SetLocalAddress);
  registry->Register(Cancel);
}",70,,1953,2,,void
17317,BLOCK,-1,,<empty>,1,,1,1,,ANY
17322,BLOCK,-1,,<empty>,1,,1,1,,ANY
17335,BLOCK,-1,,<empty>,1,,1,1,,ANY
17340,BLOCK,-1,,"{
              // Sort in descending order so that the most recently inserted
              // callbacks are run first.
              return a.insertion_order_counter_ > b.insertion_order_counter_;
            }",76,,18,3,,void
17363,BLOCK,-1,,<empty>,1,,1,1,,ANY
17366,BLOCK,-1,,"{
  // Copy into a vector, since we can't sort an unordered_set in-place.
  std::vector<CleanupHookCallback> callbacks(cleanup_hooks_.begin(),
                                             cleanup_hooks_.end());
  // We can't erase the copied elements from `cleanup_hooks_` yet, because we
  // need to be able to check whether they were un-scheduled by another hook.

  std::sort(callbacks.begin(),
            callbacks.end(),
            [](const CleanupHookCallback& a, const CleanupHookCallback& b) {
              // Sort in descending order so that the most recently inserted
              // callbacks are run first.
              return a.insertion_order_counter_ > b.insertion_order_counter_;
            });

  return callbacks;
}",11,,9,1,,void
17400,BLOCK,-1,,"{
  std::vector<CleanupHookCallback> callbacks = GetOrdered();

  for (const CleanupHookCallback& cb : callbacks) {
    if (cleanup_hooks_.count(cb) == 0) {
      // This hook was removed from the `cleanup_hooks_` set during another
      // hook that was run earlier. Nothing to do here.
      continue;
    }

    cb.fn_(cb.arg_);
    cleanup_hooks_.erase(cb);
  }
}",28,,27,1,,void
17413,BLOCK,-1,,"{
    if (cleanup_hooks_.count(cb) == 0) {
      // This hook was removed from the `cleanup_hooks_` set during another
      // hook that was run earlier. Nothing to do here.
      continue;
    }

    cb.fn_(cb.arg_);
    cleanup_hooks_.erase(cb);
  }",51,,30,3,,void
17422,BLOCK,-1,,"{
      // This hook was removed from the `cleanup_hooks_` set during another
      // hook that was run earlier. Nothing to do here.
      continue;
    }",40,,31,2,,void
17440,BLOCK,-1,,"{
  return std::hash<void*>()(cb.arg_);
}",42,,43,2,,void
17455,BLOCK,-1,,"{
  return a.fn_ == b.fn_ && a.arg_ == b.arg_;
}",71,,48,3,,void
17488,BLOCK,-1,,<empty>,1,,1,1,,ANY
17497,BLOCK,-1,,<empty>,1,,1,1,,ANY
17504,BLOCK,-1,,"{
}",78,,13,4,,void
17515,BLOCK,-1,,<empty>,1,,1,1,,ANY
17536,BLOCK,-1,,<empty>,1,,1,1,,ANY
17542,BLOCK,-1,,<empty>,33,,29,4,,void
17548,BLOCK,-1,,"{
  WrapType* wrap_data = static_cast<WrapType*>(handle->data);
  CHECK_NOT_NULL(wrap_data);
  CHECK_EQ(&wrap_data->handle_, reinterpret_cast<UVType*>(handle));

  Environment* env = wrap_data->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  // We should not be getting this callback if someone has already called
  // uv_close() on the handle.
  CHECK_EQ(wrap_data->persistent().IsEmpty(), false);

  Local<Value> client_handle;

  if (status == 0) {
    // Instantiate the client javascript object and handle.
    Local<Object> client_obj;
    if (!WrapType::Instantiate(env, wrap_data, WrapType::SOCKET)
             .ToLocal(&client_obj))
      return;

    // Unwrap the client javascript object.
    WrapType* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, client_obj);
    uv_stream_t* client = reinterpret_cast<uv_stream_t*>(&wrap->handle_);
    // uv_accept can fail if the new connection has already been closed, in
    // which case an EA...",65,,34,3,,void
17604,BLOCK,-1,,"{
    // Instantiate the client javascript object and handle.
    Local<Object> client_obj;
    if (!WrapType::Instantiate(env, wrap_data, WrapType::SOCKET)
             .ToLocal(&client_obj))
      return;

    // Unwrap the client javascript object.
    WrapType* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, client_obj);
    uv_stream_t* client = reinterpret_cast<uv_stream_t*>(&wrap->handle_);
    // uv_accept can fail if the new connection has already been closed, in
    // which case an EAGAIN (resource temporarily unavailable) will be
    // returned.
    if (uv_accept(handle, client))
      return;

    // Successful accept. Call the onconnection callback in JavaScript land.
    client_handle = client_obj;
  }",20,,49,2,,void
17626,BLOCK,-1,,<empty>,7,,54,2,,void
17646,BLOCK,-1,,<empty>,7,,64,2,,void
17652,BLOCK,-1,,"{
    client_handle = Undefined(env->isolate());
  }",10,,68,1,,void
17690,BLOCK,-1,,"{
  BaseObjectPtr<ConnectWrap> req_wrap{static_cast<ConnectWrap*>(req->data)};
  CHECK(req_wrap);
  WrapType* wrap = static_cast<WrapType*>(req->handle->data);
  CHECK_EQ(req_wrap->env(), wrap->env());
  Environment* env = wrap->env();

  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  // The wrap and request objects should still be there.
  CHECK_EQ(req_wrap->persistent().IsEmpty(), false);
  CHECK_EQ(wrap->persistent().IsEmpty(), false);

  bool readable, writable;

  if (status) {
    readable = writable = false;
  } else {
    readable = uv_is_readable(req->handle) != 0;
    writable = uv_is_writable(req->handle) != 0;
  }

  Local<Value> argv[5] = {
    Integer::New(env->isolate(), status),
    wrap->object(),
    req_wrap->object(),
    Boolean::New(env->isolate(), readable),
    Boolean::New(env->isolate(), writable)
  };

  TRACE_EVENT_NESTABLE_ASYNC_END1(TRACING_CATEGORY_NODE2(net, native),
                                  ""conn...",65,,79,3,,void
17763,BLOCK,-1,,"{
    readable = writable = false;
  }",15,,95,2,,void
17770,BLOCK,-1,,"{
    readable = uv_is_readable(req->handle) != 0;
    writable = uv_is_writable(req->handle) != 0;
  }",10,,97,1,,void
17825,BLOCK,-1,,<empty>,1,,1,1,,ANY
17856,BLOCK,-1,,<empty>,1,,1,1,,ANY
17867,BLOCK,-1,,"{
  CHECK_NOT_NULL(key_data);
  CHECK_EQ(key_data->GetKeyType(), kKeyTypeSecret);

  const int mode = EVP_CIPHER_mode(params.cipher);

  CipherCtxPointer ctx(EVP_CIPHER_CTX_new());
  EVP_CIPHER_CTX_init(ctx.get());
  if (mode == EVP_CIPH_WRAP_MODE)
    EVP_CIPHER_CTX_set_flags(ctx.get(), EVP_CIPHER_CTX_FLAG_WRAP_ALLOW);

  const bool encrypt = cipher_mode == kWebCryptoCipherEncrypt;

  if (!EVP_CipherInit_ex(
          ctx.get(),
          params.cipher,
          nullptr,
          nullptr,
          nullptr,
          encrypt)) {
    // Cipher init failed
    return WebCryptoCipherStatus::FAILED;
  }

  if (mode == EVP_CIPH_GCM_MODE && !EVP_CIPHER_CTX_ctrl(
        ctx.get(),
        EVP_CTRL_AEAD_SET_IVLEN,
        params.iv.size(),
        nullptr)) {
    return WebCryptoCipherStatus::FAILED;
  }

  if (!EVP_CIPHER_CTX_set_key_length(
          ctx.get(),
          key_data->GetSymmetricKeySize()) ||
      !EVP_CipherInit_ex(
          ctx.get(),
          nullptr,
          nul...",22,,40,7,,void
17895,BLOCK,-1,,<empty>,5,,49,2,,void
17922,BLOCK,-1,,"{
    // Cipher init failed
    return WebCryptoCipherStatus::FAILED;
  }",21,,59,2,,void
17946,BLOCK,-1,,"{
    return WebCryptoCipherStatus::FAILED;
  }",19,,68,2,,void
17984,BLOCK,-1,,"{
    return WebCryptoCipherStatus::FAILED;
  }",21,,81,2,,void
17997,BLOCK,-1,,"{
    switch (cipher_mode) {
      case kWebCryptoCipherDecrypt:
        // If in decrypt mode, the auth tag must be set in the params.tag.
        CHECK(params.tag);
        if (!EVP_CIPHER_CTX_ctrl(ctx.get(),
                                 EVP_CTRL_AEAD_SET_TAG,
                                 params.tag.size(),
                                 const_cast<char*>(params.tag.data<char>()))) {
          return WebCryptoCipherStatus::FAILED;
        }
        break;
      case kWebCryptoCipherEncrypt:
        // In decrypt mode, we grab the tag length here. We'll use it to
        // ensure that that allocated buffer has enough room for both the
        // final block and the auth tag. Unlike our other AES-GCM implementation
        // in CipherBase, in WebCrypto, the auth tag is concatenated to the end
        // of the generated ciphertext and returned in the same ArrayBuffer.
        tag_len = params.length;
        break;
      default:
        UNREACHABLE();
    }
  }",34,,87,2,,void
18000,BLOCK,-1,,"{
      case kWebCryptoCipherDecrypt:
        // If in decrypt mode, the auth tag must be set in the params.tag.
        CHECK(params.tag);
        if (!EVP_CIPHER_CTX_ctrl(ctx.get(),
                                 EVP_CTRL_AEAD_SET_TAG,
                                 params.tag.size(),
                                 const_cast<char*>(params.tag.data<char>()))) {
          return WebCryptoCipherStatus::FAILED;
        }
        break;
      case kWebCryptoCipherEncrypt:
        // In decrypt mode, we grab the tag length here. We'll use it to
        // ensure that that allocated buffer has enough room for both the
        // final block and the auth tag. Unlike our other AES-GCM implementation
        // in CipherBase, in WebCrypto, the auth tag is concatenated to the end
        // of the generated ciphertext and returned in the same ArrayBuffer.
        tag_len = params.length;
        break;
      default:
        UNREACHABLE();
    }",26,,88,2,,void
18029,BLOCK,-1,,"{
          return WebCryptoCipherStatus::FAILED;
        }",79,,95,2,,void
18098,BLOCK,-1,,"{
    return WebCryptoCipherStatus::FAILED;
  }",45,,123,2,,void
18113,BLOCK,-1,,"{
    out_len = 0;
  }",23,,137,2,,void
18118,BLOCK,-1,,<empty>,10,,139,1,,void
18140,BLOCK,-1,,"{
    return WebCryptoCipherStatus::FAILED;
  }",44,,143,2,,void
18173,BLOCK,-1,,"{
    return WebCryptoCipherStatus::FAILED;
  }",68,,151,2,,void
18189,BLOCK,-1,,"{
    if (!EVP_CIPHER_CTX_ctrl(ctx.get(),
                             EVP_CTRL_AEAD_GET_TAG,
                             tag_len,
                             buf.data<unsigned char>() + total))
      return WebCryptoCipherStatus::FAILED;
    total += tag_len;
  }",76,,158,2,,void
18205,BLOCK,-1,,<empty>,7,,163,2,,void
18234,BLOCK,-1,,"{
  return a == 0 ? 0 : 1 + (a - 1) / b;
}",21,,178,3,,void
18252,BLOCK,-1,,"{
  unsigned int remainder = (params.length % CHAR_BIT);
  const unsigned char* data = params.iv.data<unsigned char>();

  if (remainder == 0) {
    unsigned int byte_length = params.length / CHAR_BIT;
    return BignumPointer(BN_bin2bn(
        data + params.iv.size() - byte_length,
        byte_length,
        nullptr));
  }

  unsigned int byte_length =
      CeilDiv(params.length, static_cast<size_t>(CHAR_BIT));

  std::vector<unsigned char> counter(
      data + params.iv.size() - byte_length,
      data + params.iv.size());
  counter[0] &= ~(0xFF << remainder);

  return BignumPointer(BN_bin2bn(counter.data(), counter.size(), nullptr));
}",57,,182,2,,void
18274,BLOCK,-1,,"{
    unsigned int byte_length = params.length / CHAR_BIT;
    return BignumPointer(BN_bin2bn(
        data + params.iv.size() - byte_length,
        byte_length,
        nullptr));
  }",23,,186,2,,void
18352,BLOCK,-1,,"{
  unsigned int length_bytes = params.length / CHAR_BIT;
  unsigned int remainder = params.length % CHAR_BIT;

  const unsigned char* data = params.iv.data<unsigned char>();

  std::vector<unsigned char> new_counter_block(data, data + params.iv.size());

  size_t index = new_counter_block.size() - length_bytes;
  memset(&new_counter_block.front() + index, 0, length_bytes);

  if (remainder)
    new_counter_block[index - 1] &= 0xFF << remainder;

  return new_counter_block;
}",36,,206,2,,void
18410,BLOCK,-1,,<empty>,5,,218,2,,void
18431,BLOCK,-1,,"{
  CipherCtxPointer ctx(EVP_CIPHER_CTX_new());
  const bool encrypt = cipher_mode == kWebCryptoCipherEncrypt;

  if (!EVP_CipherInit_ex(
          ctx.get(),
          params.cipher,
          nullptr,
          reinterpret_cast<const unsigned char*>(key_data->GetSymmetricKey()),
          counter,
          encrypt)) {
    // Cipher init failed
    return WebCryptoCipherStatus::FAILED;
  }

  int out_len = 0;
  int final_len = 0;
  if (!EVP_CipherUpdate(
          ctx.get(),
          out,
          &out_len,
          in.data<unsigned char>(),
          in.size())) {
    return WebCryptoCipherStatus::FAILED;
  }

  if (!EVP_CipherFinal_ex(ctx.get(), out + out_len, &final_len))
    return WebCryptoCipherStatus::FAILED;

  out_len += final_len;
  if (static_cast<unsigned>(out_len) != in.size())
    return WebCryptoCipherStatus::FAILED;

  return WebCryptoCipherStatus::OK;
}",25,,229,7,,void
18460,BLOCK,-1,,"{
    // Cipher init failed
    return WebCryptoCipherStatus::FAILED;
  }",21,,239,2,,void
18491,BLOCK,-1,,"{
    return WebCryptoCipherStatus::FAILED;
  }",23,,251,2,,void
18508,BLOCK,-1,,<empty>,5,,256,2,,void
18525,BLOCK,-1,,<empty>,5,,260,2,,void
18543,BLOCK,-1,,"{
  BignumPointer num_counters(BN_new());
  if (!BN_lshift(num_counters.get(), BN_value_one(), params.length))
    return WebCryptoCipherStatus::FAILED;

  BignumPointer current_counter = GetCounter(params);

  BignumPointer num_output(BN_new());

  if (!BN_set_word(num_output.get(), CeilDiv(in.size(), kAesBlockSize)))
    return WebCryptoCipherStatus::FAILED;

  // Just like in chromium's implementation, if the counter will
  // be incremented more than there are counter values, we fail.
  if (BN_cmp(num_output.get(), num_counters.get()) > 0)
    return WebCryptoCipherStatus::FAILED;

  BignumPointer remaining_until_reset(BN_new());
  if (!BN_sub(remaining_until_reset.get(),
              num_counters.get(),
              current_counter.get())) {
    return WebCryptoCipherStatus::FAILED;
  }

  // Output size is identical to the input size.
  ByteSource::Builder buf(in.size());

  // Also just like in chromium's implementation, if we can process
  // the input without wrapping the...",22,,271,7,,void
18558,BLOCK,-1,,<empty>,5,,274,2,,void
18584,BLOCK,-1,,<empty>,5,,281,2,,void
18601,BLOCK,-1,,<empty>,5,,286,2,,void
18624,BLOCK,-1,,"{
    return WebCryptoCipherStatus::FAILED;
  }",39,,291,2,,void
18647,BLOCK,-1,,"{
    auto status = AES_CTR_Cipher2(key_data,
                                  cipher_mode,
                                  params,
                                  in,
                                  params.iv.data<unsigned char>(),
                                  buf.data<unsigned char>());
    if (status == WebCryptoCipherStatus::OK) *out = std::move(buf).release();
    return status;
  }",67,,301,2,,void
18672,BLOCK,-1,,<empty>,46,,308,2,,void
18732,BLOCK,-1,,<empty>,5,,325,2,,void
18778,BLOCK,-1,,<empty>,44,,340,2,,void
18799,BLOCK,-1,,"{
  ArrayBufferOrViewContents<char> iv(value);
  if (UNLIKELY(!iv.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(env, ""iv is too big"");
    return false;
  }
  params->iv = (mode == kCryptoJobAsync)
      ? iv.ToCopy()
      : iv.ToByteSource();
  return true;
}",30,,349,5,,void
18810,BLOCK,-1,,"{
    THROW_ERR_OUT_OF_RANGE(env, ""iv is too big"");
    return false;
  }",39,,351,2,,void
18840,BLOCK,-1,,"{
  CHECK(value->IsUint32());  // Length
  params->length = value.As<Uint32>()->Value();
  if (params->iv.size() != 16 ||
      params->length == 0 ||
      params->length > 128) {
    THROW_ERR_CRYPTO_INVALID_COUNTER(env);
    return false;
  }
  return true;
}",28,,364,4,,void
18878,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_COUNTER(env);
    return false;
  }",29,,369,2,,void
18893,BLOCK,-1,,"{
  switch (cipher_mode) {
    case kWebCryptoCipherDecrypt: {
      if (!IsAnyByteSource(value)) {
        THROW_ERR_CRYPTO_INVALID_TAG_LENGTH(env);
        return false;
      }
      ArrayBufferOrViewContents<char> tag_contents(value);
      if (UNLIKELY(!tag_contents.CheckSizeInt32())) {
        THROW_ERR_OUT_OF_RANGE(env, ""tagLength is too big"");
        return false;
      }
      params->tag = mode == kCryptoJobAsync
          ? tag_contents.ToCopy()
          : tag_contents.ToByteSource();
      break;
    }
    case kWebCryptoCipherEncrypt: {
      if (!value->IsUint32()) {
        THROW_ERR_CRYPTO_INVALID_TAG_LENGTH(env);
        return false;
      }
      params->length = value.As<Uint32>()->Value();
      if (params->length > 128) {
        THROW_ERR_CRYPTO_INVALID_TAG_LENGTH(env);
        return false;
      }
      break;
    }
    default:
      UNREACHABLE();
  }
  return true;
}",30,,381,6,,void
18896,BLOCK,-1,,"{
    case kWebCryptoCipherDecrypt: {
      if (!IsAnyByteSource(value)) {
        THROW_ERR_CRYPTO_INVALID_TAG_LENGTH(env);
        return false;
      }
      ArrayBufferOrViewContents<char> tag_contents(value);
      if (UNLIKELY(!tag_contents.CheckSizeInt32())) {
        THROW_ERR_OUT_OF_RANGE(env, ""tagLength is too big"");
        return false;
      }
      params->tag = mode == kCryptoJobAsync
          ? tag_contents.ToCopy()
          : tag_contents.ToByteSource();
      break;
    }
    case kWebCryptoCipherEncrypt: {
      if (!value->IsUint32()) {
        THROW_ERR_CRYPTO_INVALID_TAG_LENGTH(env);
        return false;
      }
      params->length = value.As<Uint32>()->Value();
      if (params->length > 128) {
        THROW_ERR_CRYPTO_INVALID_TAG_LENGTH(env);
        return false;
      }
      break;
    }
    default:
      UNREACHABLE();
  }",24,,382,2,,void
18899,BLOCK,3,,"{
      if (!IsAnyByteSource(value)) {
        THROW_ERR_CRYPTO_INVALID_TAG_LENGTH(env);
        return false;
      }
      ArrayBufferOrViewContents<char> tag_contents(value);
      if (UNLIKELY(!tag_contents.CheckSizeInt32())) {
        THROW_ERR_OUT_OF_RANGE(env, ""tagLength is too big"");
        return false;
      }
      params->tag = mode == kCryptoJobAsync
          ? tag_contents.ToCopy()
          : tag_contents.ToByteSource();
      break;
    }",35,,383,3,,void
18904,BLOCK,-1,,"{
        THROW_ERR_CRYPTO_INVALID_TAG_LENGTH(env);
        return false;
      }",36,,384,2,,void
18919,BLOCK,-1,,"{
        THROW_ERR_OUT_OF_RANGE(env, ""tagLength is too big"");
        return false;
      }",53,,389,2,,void
18944,BLOCK,6,,"{
      if (!value->IsUint32()) {
        THROW_ERR_CRYPTO_INVALID_TAG_LENGTH(env);
        return false;
      }
      params->length = value.As<Uint32>()->Value();
      if (params->length > 128) {
        THROW_ERR_CRYPTO_INVALID_TAG_LENGTH(env);
        return false;
      }
      break;
    }",35,,398,6,,void
18951,BLOCK,-1,,"{
        THROW_ERR_CRYPTO_INVALID_TAG_LENGTH(env);
        return false;
      }",31,,399,2,,void
18973,BLOCK,-1,,"{
        THROW_ERR_CRYPTO_INVALID_TAG_LENGTH(env);
        return false;
      }",33,,404,2,,void
18990,BLOCK,-1,,"{
  // Additional Data
  if (IsAnyByteSource(value)) {
    ArrayBufferOrViewContents<char> additional(value);
    if (UNLIKELY(!additional.CheckSizeInt32())) {
      THROW_ERR_OUT_OF_RANGE(env, ""additionalData is too big"");
      return false;
    }
    params->additional_data = mode == kCryptoJobAsync
        ? additional.ToCopy()
        : additional.ToByteSource();
  }
  return true;
}",30,,420,5,,void
18994,BLOCK,-1,,"{
    ArrayBufferOrViewContents<char> additional(value);
    if (UNLIKELY(!additional.CheckSizeInt32())) {
      THROW_ERR_OUT_OF_RANGE(env, ""additionalData is too big"");
      return false;
    }
    params->additional_data = mode == kCryptoJobAsync
        ? additional.ToCopy()
        : additional.ToByteSource();
  }",31,,422,2,,void
19005,BLOCK,-1,,"{
      THROW_ERR_OUT_OF_RANGE(env, ""additionalData is too big"");
      return false;
    }",49,,424,2,,void
19033,BLOCK,-1,,"{
  params->iv = ByteSource::Foreign(kDefaultWrapIV, strlen(kDefaultWrapIV));
}",44,,435,2,,void
19049,BLOCK,-1,,<empty>,33,,447,2,,void
19054,BLOCK,-1,,"{
  if (&other == this) return *this;
  this->~AESCipherConfig();
  return *new (this) AESCipherConfig(std::move(other));
}",79,,449,2,,void
19060,BLOCK,-1,,<empty>,23,,450,2,,void
19082,BLOCK,-1,,"{
  // If mode is sync, then the data in each of these properties
  // is not owned by the AESCipherConfig, so we ignore it.
  if (mode == kCryptoJobAsync) {
    tracker->TrackFieldWithSize(""iv"", iv.size());
    tracker->TrackFieldWithSize(""additional_data"", additional_data.size());
    tracker->TrackFieldWithSize(""tag"", tag.size());
  }
}",64,,455,2,,void
19087,BLOCK,-1,,"{
    tracker->TrackFieldWithSize(""iv"", iv.size());
    tracker->TrackFieldWithSize(""additional_data"", additional_data.size());
    tracker->TrackFieldWithSize(""tag"", tag.size());
  }",32,,458,2,,void
19123,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  params->mode = mode;

  CHECK(args[offset]->IsUint32());  // Key Variant
  params->variant =
      static_cast<AESKeyVariant>(args[offset].As<Uint32>()->Value());

  int cipher_nid;

  switch (params->variant) {
    case kKeyVariantAES_CTR_128:
      if (!ValidateIV(env, mode, args[offset + 1], params) ||
          !ValidateCounter(env, args[offset + 2], params)) {
        return Nothing<bool>();
      }
      cipher_nid = NID_aes_128_ctr;
      break;
    case kKeyVariantAES_CTR_192:
      if (!ValidateIV(env, mode, args[offset + 1], params) ||
          !ValidateCounter(env, args[offset + 2], params)) {
        return Nothing<bool>();
      }
      cipher_nid = NID_aes_192_ctr;
      break;
    case kKeyVariantAES_CTR_256:
      if (!ValidateIV(env, mode, args[offset + 1], params) ||
          !ValidateCounter(env, args[offset + 2], params)) {
        return Nothing<bool>();
      }
      cipher_nid = NID_aes_256_ctr;
      ...",30,,470,6,,void
19164,BLOCK,-1,,"{
    case kKeyVariantAES_CTR_128:
      if (!ValidateIV(env, mode, args[offset + 1], params) ||
          !ValidateCounter(env, args[offset + 2], params)) {
        return Nothing<bool>();
      }
      cipher_nid = NID_aes_128_ctr;
      break;
    case kKeyVariantAES_CTR_192:
      if (!ValidateIV(env, mode, args[offset + 1], params) ||
          !ValidateCounter(env, args[offset + 2], params)) {
        return Nothing<bool>();
      }
      cipher_nid = NID_aes_192_ctr;
      break;
    case kKeyVariantAES_CTR_256:
      if (!ValidateIV(env, mode, args[offset + 1], params) ||
          !ValidateCounter(env, args[offset + 2], params)) {
        return Nothing<bool>();
      }
      cipher_nid = NID_aes_256_ctr;
      break;
    case kKeyVariantAES_CBC_128:
      if (!ValidateIV(env, mode, args[offset + 1], params))
        return Nothing<bool>();
      cipher_nid = NID_aes_128_cbc;
      break;
    case kKeyVariantAES_CBC_192:
      if (!ValidateIV(env, mode, args[offset + 1], pa...",28,,481,2,,void
19188,BLOCK,-1,,"{
        return Nothing<bool>();
      }",60,,484,2,,void
19218,BLOCK,-1,,"{
        return Nothing<bool>();
      }",60,,491,2,,void
19248,BLOCK,-1,,"{
        return Nothing<bool>();
      }",60,,498,2,,void
19268,BLOCK,-1,,<empty>,9,,505,2,,void
19288,BLOCK,-1,,<empty>,9,,510,2,,void
19308,BLOCK,-1,,<empty>,9,,515,2,,void
19375,BLOCK,-1,,"{
        return Nothing<bool>();
      }",73,,533,2,,void
19418,BLOCK,-1,,"{
        return Nothing<bool>();
      }",73,,541,2,,void
19461,BLOCK,-1,,"{
        return Nothing<bool>();
      }",73,,549,2,,void
19482,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_UNKNOWN_CIPHER(env);
    return Nothing<bool>();
  }",34,,559,2,,void
19501,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_IV(env);
    return Nothing<bool>();
  }",66,,565,2,,void
19518,BLOCK,-1,,"{
#define V(name, fn)                                                           \
  case kKeyVariantAES_ ## name:                                               \
    return fn(env, key_data.get(), cipher_mode, params, in, out);
  switch (params.variant) {
    VARIANTS(V)
    default:
      UNREACHABLE();
  }
#undef V
}",22,,579,7,,void
19523,BLOCK,-1,,"{
    VARIANTS(V)
    default:
      UNREACHABLE();
  }",27,,583,2,,void
19533,BLOCK,-1,,"{
  AESCryptoJob::Initialize(env, target);

#define V(name, _) NODE_DEFINE_CONSTANT(target, kKeyVariantAES_ ## name);
  VARIANTS(V)
#undef V
}",62,,591,3,,void
19546,BLOCK,-1,,"{
  AESCryptoJob::RegisterExternalReferences(registry);
}",75,,599,2,,void
19568,BLOCK,-1,,<empty>,1,,1,1,,ANY
19571,BLOCK,-1,,"{
    BIO_METHOD* method = BIO_meth_new(BIO_TYPE_MEM, ""node.js SSL buffer"");
    BIO_meth_set_write(method, Write);
    BIO_meth_set_read(method, Read);
    BIO_meth_set_puts(method, Puts);
    BIO_meth_set_gets(method, Gets);
    BIO_meth_set_ctrl(method, Ctrl);
    BIO_meth_set_create(method, New);
    BIO_meth_set_destroy(method, Free);
    return method;
  }",43,,224,1,,void
19621,BLOCK,-1,,<empty>,1,,1,1,,ANY
19626,BLOCK,-1,,"{
  BIOPointer bio(BIO_new(GetMethod()));
  if (bio && env != nullptr)
    NodeBIO::FromBIO(bio.get())->env_ = env;
  return bio;
}",43,,35,2,,void
19629,BLOCK,-1,,<empty>,,,,2,,<empty>
19638,BLOCK,-1,,<empty>,5,,38,2,,void
19659,BLOCK,-1,,"{
  BIOPointer bio = New(env);

  if (!bio ||
      len > INT_MAX ||
      BIO_write(bio.get(), data, len) != static_cast<int>(len) ||
      BIO_set_mem_eof_return(bio.get(), 0) != 1) {
    return BIOPointer();
  }

  return bio;
}",78,,43,4,,void
19693,BLOCK,-1,,"{
    return BIOPointer();
  }",50,,49,2,,void
19702,BLOCK,-1,,"{
  BIO_set_data(bio, new NodeBIO());
  BIO_set_init(bio, 1);

  return 1;
}",28,,57,2,,void
19716,BLOCK,-1,,"{
  if (bio == nullptr)
    return 0;

  if (BIO_get_shutdown(bio)) {
    if (BIO_get_init(bio) && BIO_get_data(bio) != nullptr) {
      delete FromBIO(bio);
      BIO_set_data(bio, nullptr);
    }
  }

  return 1;
}",29,,65,2,,void
19721,BLOCK,-1,,<empty>,5,,67,2,,void
19727,BLOCK,-1,,"{
    if (BIO_get_init(bio) && BIO_get_data(bio) != nullptr) {
      delete FromBIO(bio);
      BIO_set_data(bio, nullptr);
    }
  }",30,,69,2,,void
19736,BLOCK,-1,,"{
      delete FromBIO(bio);
      BIO_set_data(bio, nullptr);
    }",60,,70,2,,void
19751,BLOCK,-1,,"{
  BIO_clear_retry_flags(bio);

  NodeBIO* nbio = FromBIO(bio);
  int bytes = nbio->Read(out, len);

  if (bytes == 0) {
    bytes = nbio->eof_return();
    if (bytes != 0) {
      BIO_set_retry_read(bio);
    }
  }

  return bytes;
}",49,,80,4,,void
19772,BLOCK,-1,,"{
    bytes = nbio->eof_return();
    if (bytes != 0) {
      BIO_set_retry_read(bio);
    }
  }",19,,86,2,,void
19783,BLOCK,-1,,"{
      BIO_set_retry_read(bio);
    }",21,,88,2,,void
19792,BLOCK,-1,,"{
  *size = read_head_->write_pos_ - read_head_->read_pos_;
  return read_head_->data_ + read_head_->read_pos_;
}",35,,97,2,,void
19817,BLOCK,-1,,"{
  Buffer* pos = read_head_;
  size_t max = *count;
  size_t total = 0;

  size_t i;
  for (i = 0; i < max; i++) {
    size[i] = pos->write_pos_ - pos->read_pos_;
    total += size[i];
    out[i] = pos->data_ + pos->read_pos_;

    /* Don't get past write head */
    if (pos == write_head_)
      break;
    else
      pos = pos->next_;
  }

  if (i == max)
    *count = i;
  else
    *count = i + 1;

  return total;
}",71,,103,4,,void
19833,BLOCK,-1,,<empty>,3,,109,1,,void
19842,BLOCK,4,,"{
    size[i] = pos->write_pos_ - pos->read_pos_;
    total += size[i];
    out[i] = pos->data_ + pos->read_pos_;

    /* Don't get past write head */
    if (pos == write_head_)
      break;
    else
      pos = pos->next_;
  }",29,,109,4,,void
19874,BLOCK,-1,,<empty>,7,,116,2,,void
19877,BLOCK,-1,,<empty>,7,,118,1,,void
19887,BLOCK,-1,,<empty>,5,,122,2,,void
19893,BLOCK,-1,,<empty>,5,,124,1,,void
19908,BLOCK,-1,,"{
  BIO_clear_retry_flags(bio);

  FromBIO(bio)->Write(data, len);

  return len;
}",57,,130,4,,void
19925,BLOCK,-1,,"{
  return Write(bio, str, strlen(str));
}",46,,139,3,,void
19938,BLOCK,-1,,"{
  NodeBIO* nbio = FromBIO(bio);

  if (nbio->Length() == 0)
    return 0;

  int i = nbio->IndexOf('\n', size);

  // Include '\n', if it's there.  If not, don't read off the end.
  if (i < size && i >= 0 && static_cast<size_t>(i) < nbio->Length())
    i++;

  // Shift `i` a bit to nullptr-terminate string later
  if (size == i)
    i--;

  // Flush read data
  nbio->Read(out, i);

  out[i] = 0;

  return i;
}",50,,144,4,,void
19951,BLOCK,-1,,<empty>,5,,148,2,,void
19980,BLOCK,-1,,<empty>,5,,154,2,,void
19987,BLOCK,-1,,<empty>,5,,158,2,,void
20010,BLOCK,-1,,"{
  NodeBIO* nbio;
  long ret;  // NOLINT(runtime/int)

  nbio = FromBIO(bio);
  ret = 1;

  switch (cmd) {
    case BIO_CTRL_RESET:
      nbio->Reset();
      break;
    case BIO_CTRL_EOF:
      ret = nbio->Length() == 0;
      break;
    case BIO_C_SET_BUF_MEM_EOF_RETURN:
      nbio->set_eof_return(num);
      break;
    case BIO_CTRL_INFO:
      ret = nbio->Length();
      if (ptr != nullptr)
        *reinterpret_cast<void**>(ptr) = nullptr;
      break;
    case BIO_C_SET_BUF_MEM:
      UNREACHABLE(""Can't use SET_BUF_MEM_PTR with NodeBIO"");
    case BIO_C_GET_BUF_MEM_PTR:
      UNREACHABLE(""Can't use GET_BUF_MEM_PTR with NodeBIO"");
    case BIO_CTRL_GET_CLOSE:
      ret = BIO_get_shutdown(bio);
      break;
    case BIO_CTRL_SET_CLOSE:
      BIO_set_shutdown(bio, num);
      break;
    case BIO_CTRL_WPENDING:
      ret = 0;
      break;
    case BIO_CTRL_PENDING:
      ret = nbio->Length();
      break;
    case BIO_CTRL_DUP:
    case BIO_CTRL_FLUSH:
      ret = 1;
      break;
...",31,,170,5,,void
20022,BLOCK,-1,,"{
    case BIO_CTRL_RESET:
      nbio->Reset();
      break;
    case BIO_CTRL_EOF:
      ret = nbio->Length() == 0;
      break;
    case BIO_C_SET_BUF_MEM_EOF_RETURN:
      nbio->set_eof_return(num);
      break;
    case BIO_CTRL_INFO:
      ret = nbio->Length();
      if (ptr != nullptr)
        *reinterpret_cast<void**>(ptr) = nullptr;
      break;
    case BIO_C_SET_BUF_MEM:
      UNREACHABLE(""Can't use SET_BUF_MEM_PTR with NodeBIO"");
    case BIO_C_GET_BUF_MEM_PTR:
      UNREACHABLE(""Can't use GET_BUF_MEM_PTR with NodeBIO"");
    case BIO_CTRL_GET_CLOSE:
      ret = BIO_get_shutdown(bio);
      break;
    case BIO_CTRL_SET_CLOSE:
      BIO_set_shutdown(bio, num);
      break;
    case BIO_CTRL_WPENDING:
      ret = 0;
      break;
    case BIO_CTRL_PENDING:
      ret = nbio->Length();
      break;
    case BIO_CTRL_DUP:
    case BIO_CTRL_FLUSH:
      ret = 1;
      break;
    case BIO_CTRL_PUSH:
    case BIO_CTRL_POP:
    default:
      ret = 0;
      break;
  }",16,,177,2,,void
20061,BLOCK,-1,,<empty>,9,,190,2,,void
20127,BLOCK,-1,,"{
  // Static initialization ensures that this is safe to use concurrently.
  static const BIO_METHOD* method = [&]() {
    BIO_METHOD* method = BIO_meth_new(BIO_TYPE_MEM, ""node.js SSL buffer"");
    BIO_meth_set_write(method, Write);
    BIO_meth_set_read(method, Read);
    BIO_meth_set_puts(method, Puts);
    BIO_meth_set_gets(method, Gets);
    BIO_meth_set_ctrl(method, Ctrl);
    BIO_meth_set_create(method, New);
    BIO_meth_set_destroy(method, Free);
    return method;
  }();

  return method;
}",40,,222,1,,void
20138,BLOCK,-1,,"{
  // `read_pos_` and `write_pos_` means the position of the reader and writer
  // inside the buffer, respectively. When they're equal - its safe to reset
  // them, because both reader and writer will continue doing their stuff
  // from new (zero) positions.
  while (read_head_->read_pos_ != 0 &&
         read_head_->read_pos_ == read_head_->write_pos_) {
    // Reset positions
    read_head_->read_pos_ = 0;
    read_head_->write_pos_ = 0;

    // Move read_head_ forward, just in case if there're still some data to
    // read in the next buffer.
    if (read_head_ != write_head_)
      read_head_ = read_head_->next_;
  }
}",33,,240,1,,void
20153,BLOCK,-1,,"{
    // Reset positions
    read_head_->read_pos_ = 0;
    read_head_->write_pos_ = 0;

    // Move read_head_ forward, just in case if there're still some data to
    // read in the next buffer.
    if (read_head_ != write_head_)
      read_head_ = read_head_->next_;
  }",59,,246,2,,void
20168,BLOCK,-1,,<empty>,7,,254,2,,void
20179,BLOCK,-1,,"{
  size_t bytes_read = 0;
  size_t expected = Length() > size ? size : Length();
  size_t offset = 0;
  size_t left = size;

  while (bytes_read < expected) {
    CHECK_LE(read_head_->read_pos_, read_head_->write_pos_);
    size_t avail = read_head_->write_pos_ - read_head_->read_pos_;
    if (avail > left)
      avail = left;

    // Copy data
    if (out != nullptr)
      memcpy(out + offset, read_head_->data_ + read_head_->read_pos_, avail);
    read_head_->read_pos_ += avail;

    // Move pointers
    bytes_read += avail;
    offset += avail;
    left -= avail;

    TryMoveReadHead();
  }
  CHECK_EQ(expected, bytes_read);
  length_ -= bytes_read;

  // Free all empty buffers, but write_head's child
  FreeEmpty();

  return bytes_read;
}",46,,259,3,,void
20205,BLOCK,-1,,"{
    CHECK_LE(read_head_->read_pos_, read_head_->write_pos_);
    size_t avail = read_head_->write_pos_ - read_head_->read_pos_;
    if (avail > left)
      avail = left;

    // Copy data
    if (out != nullptr)
      memcpy(out + offset, read_head_->data_ + read_head_->read_pos_, avail);
    read_head_->read_pos_ += avail;

    // Move pointers
    bytes_read += avail;
    offset += avail;
    left -= avail;

    TryMoveReadHead();
  }",33,,265,2,,void
20227,BLOCK,-1,,<empty>,7,,269,2,,void
20235,BLOCK,-1,,<empty>,7,,273,2,,void
20275,BLOCK,-1,,"{
  if (write_head_ == nullptr)
    return;
  Buffer* child = write_head_->next_;
  if (child == write_head_ || child == read_head_)
    return;
  Buffer* cur = child->next_;
  if (cur == write_head_ || cur == read_head_)
    return;

  Buffer* prev = child;
  while (cur != read_head_) {
    CHECK_NE(cur, write_head_);
    CHECK_EQ(cur->write_pos_, cur->read_pos_);

    Buffer* next = cur->next_;
    delete cur;
    cur = next;
  }
  prev->next_ = cur;
}",27,,293,1,,void
20280,BLOCK,-1,,<empty>,5,,295,2,,void
20296,BLOCK,-1,,<empty>,5,,298,2,,void
20312,BLOCK,-1,,<empty>,5,,301,2,,void
20322,BLOCK,-1,,"{
    CHECK_NE(cur, write_head_);
    CHECK_EQ(cur->write_pos_, cur->read_pos_);

    Buffer* next = cur->next_;
    delete cur;
    cur = next;
  }",29,,304,2,,void
20354,BLOCK,-1,,"{
  size_t bytes_read = 0;
  size_t max = Length() > limit ? limit : Length();
  size_t left = limit;
  Buffer* current = read_head_;

  while (bytes_read < max) {
    CHECK_LE(current->read_pos_, current->write_pos_);
    size_t avail = current->write_pos_ - current->read_pos_;
    if (avail > left)
      avail = left;

    // Walk through data
    char* tmp = current->data_ + current->read_pos_;
    size_t off = 0;
    while (off < avail && *tmp != delim) {
      off++;
      tmp++;
    }

    // Move pointers
    bytes_read += off;
    left -= off;

    // Found `delim`
    if (off != avail) {
      return bytes_read;
    }

    // Move to next buffer
    if (current->read_pos_ + avail == current->len_) {
      current = current->next_;
    }
  }
  CHECK_EQ(max, bytes_read);

  return max;
}",51,,316,3,,void
20380,BLOCK,-1,,"{
    CHECK_LE(current->read_pos_, current->write_pos_);
    size_t avail = current->write_pos_ - current->read_pos_;
    if (avail > left)
      avail = left;

    // Walk through data
    char* tmp = current->data_ + current->read_pos_;
    size_t off = 0;
    while (off < avail && *tmp != delim) {
      off++;
      tmp++;
    }

    // Move pointers
    bytes_read += off;
    left -= off;

    // Found `delim`
    if (off != avail) {
      return bytes_read;
    }

    // Move to next buffer
    if (current->read_pos_ + avail == current->len_) {
      current = current->next_;
    }
  }",28,,322,2,,void
20402,BLOCK,-1,,<empty>,7,,326,2,,void
20429,BLOCK,-1,,"{
      off++;
      tmp++;
    }",42,,331,2,,void
20444,BLOCK,-1,,"{
      return bytes_read;
    }",23,,341,2,,void
20457,BLOCK,-1,,"{
      current = current->next_;
    }",54,,346,2,,void
20473,BLOCK,-1,,"{
  size_t offset = 0;
  size_t left = size;

  // Allocate initial buffer if the ring is empty
  TryAllocateForWrite(left);

  while (left > 0) {
    size_t to_write = left;
    CHECK_LE(write_head_->write_pos_, write_head_->len_);
    size_t avail = write_head_->len_ - write_head_->write_pos_;

    if (to_write > avail)
      to_write = avail;

    // Copy data
    memcpy(write_head_->data_ + write_head_->write_pos_,
           data + offset,
           to_write);

    // Move pointers
    left -= to_write;
    offset += to_write;
    length_ += to_write;
    write_head_->write_pos_ += to_write;
    CHECK_LE(write_head_->write_pos_, write_head_->len_);

    // Go to next buffer if there still are some bytes to write
    if (left != 0) {
      CHECK_EQ(write_head_->write_pos_, write_head_->len_);
      TryAllocateForWrite(left);
      write_head_ = write_head_->next_;

      // Additionally, since we're moved to the next buffer, read head
      // may be moved as well.
      TryMov...",52,,356,3,,void
20488,BLOCK,-1,,"{
    size_t to_write = left;
    CHECK_LE(write_head_->write_pos_, write_head_->len_);
    size_t avail = write_head_->len_ - write_head_->write_pos_;

    if (to_write > avail)
      to_write = avail;

    // Copy data
    memcpy(write_head_->data_ + write_head_->write_pos_,
           data + offset,
           to_write);

    // Move pointers
    left -= to_write;
    offset += to_write;
    length_ += to_write;
    write_head_->write_pos_ += to_write;
    CHECK_LE(write_head_->write_pos_, write_head_->len_);

    // Go to next buffer if there still are some bytes to write
    if (left != 0) {
      CHECK_EQ(write_head_->write_pos_, write_head_->len_);
      TryAllocateForWrite(left);
      write_head_ = write_head_->next_;

      // Additionally, since we're moved to the next buffer, read head
      // may be moved as well.
      TryMoveReadHead();
    }
  }",20,,363,2,,void
20514,BLOCK,-1,,<empty>,7,,369,2,,void
20555,BLOCK,-1,,"{
      CHECK_EQ(write_head_->write_pos_, write_head_->len_);
      TryAllocateForWrite(left);
      write_head_ = write_head_->next_;

      // Additionally, since we're moved to the next buffer, read head
      // may be moved as well.
      TryMoveReadHead();
    }",20,,384,2,,void
20578,BLOCK,-1,,"{
  TryAllocateForWrite(*size);

  size_t available = write_head_->len_ - write_head_->write_pos_;
  if (*size == 0 || available <= *size)
    *size = available;

  return write_head_->data_ + write_head_->write_pos_;
}",43,,398,2,,void
20602,BLOCK,-1,,<empty>,5,,403,2,,void
20619,BLOCK,-1,,"{
  write_head_->write_pos_ += size;
  length_ += size;
  CHECK_LE(write_head_->write_pos_, write_head_->len_);

  // Allocate new buffer if write head is full,
  // and there're no other place to go
  TryAllocateForWrite(0);
  if (write_head_->write_pos_ == write_head_->len_) {
    write_head_ = write_head_->next_;

    // Additionally, since we're moved to the next buffer, read head
    // may be moved as well.
    TryMoveReadHead();
  }
}",35,,409,2,,void
20645,BLOCK,-1,,"{
    write_head_ = write_head_->next_;

    // Additionally, since we're moved to the next buffer, read head
    // may be moved as well.
    TryMoveReadHead();
  }",53,,417,2,,void
20656,BLOCK,-1,,"{
  Buffer* w = write_head_;
  Buffer* r = read_head_;
  // If write head is full, next buffer is either read head or not empty.
  if (w == nullptr ||
      (w->write_pos_ == w->len_ &&
       (w->next_ == r || w->next_->write_pos_ != 0))) {
    size_t len = w == nullptr ? initial_ :
                             kThroughputBufferLength;
    if (len < hint)
      len = hint;

    // If there is a one time allocation size hint, use it.
    if (allocate_hint_ > len) {
      len = allocate_hint_;
      allocate_hint_ = 0;
    }

    Buffer* next = new Buffer(env_, len);

    if (w == nullptr) {
      next->next_ = next;
      write_head_ = next;
      read_head_ = next;
    } else {
      next->next_ = w->next_;
      w->next_ = next;
    }
  }
}",48,,427,2,,void
20691,BLOCK,-1,,"{
    size_t len = w == nullptr ? initial_ :
                             kThroughputBufferLength;
    if (len < hint)
      len = hint;

    // If there is a one time allocation size hint, use it.
    if (allocate_hint_ > len) {
      len = allocate_hint_;
      allocate_hint_ = 0;
    }

    Buffer* next = new Buffer(env_, len);

    if (w == nullptr) {
      next->next_ = next;
      write_head_ = next;
      read_head_ = next;
    } else {
      next->next_ = w->next_;
      w->next_ = next;
    }
  }",55,,433,2,,void
20705,BLOCK,-1,,<empty>,7,,437,2,,void
20713,BLOCK,-1,,"{
      len = allocate_hint_;
      allocate_hint_ = 0;
    }",31,,440,2,,void
20731,BLOCK,-1,,"{
      next->next_ = next;
      write_head_ = next;
      read_head_ = next;
    }",23,,447,2,,void
20744,BLOCK,-1,,"{
      next->next_ = w->next_;
      w->next_ = next;
    }",12,,451,1,,void
20760,BLOCK,-1,,"{
  if (read_head_ == nullptr)
    return;

  while (read_head_->read_pos_ != read_head_->write_pos_) {
    CHECK(read_head_->write_pos_ > read_head_->read_pos_);

    length_ -= read_head_->write_pos_ - read_head_->read_pos_;
    read_head_->write_pos_ = 0;
    read_head_->read_pos_ = 0;

    read_head_ = read_head_->next_;
  }
  write_head_ = read_head_;
  CHECK_EQ(length_, 0);
}",23,,459,1,,void
20765,BLOCK,-1,,<empty>,5,,461,2,,void
20775,BLOCK,-1,,"{
    CHECK(read_head_->write_pos_ > read_head_->read_pos_);

    length_ -= read_head_->write_pos_ - read_head_->read_pos_;
    read_head_->write_pos_ = 0;
    read_head_->read_pos_ = 0;

    read_head_ = read_head_->next_;
  }",59,,463,2,,void
20817,BLOCK,-1,,"{
  if (read_head_ == nullptr)
    return;

  Buffer* current = read_head_;
  do {
    Buffer* next = current->next_;
    delete current;
    current = next;
  } while (current != read_head_);

  read_head_ = nullptr;
  write_head_ = nullptr;
}",21,,477,1,,void
20822,BLOCK,-1,,<empty>,5,,479,2,,void
20829,BLOCK,-1,,"{
    Buffer* next = current->next_;
    delete current;
    current = next;
  }",6,,482,1,,void
20854,BLOCK,-1,,"{
  CHECK_NOT_NULL(BIO_get_data(bio));
  return static_cast<NodeBIO*>(BIO_get_data(bio));
}",37,,493,2,,void
20877,BLOCK,-1,,<empty>,1,,1,1,,ANY
20884,BLOCK,-1,,"{
    std::unique_ptr<BackingStore> out;
    Environment* env = Environment::GetCurrent(args);

    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");

    UpdateResult r = cipher->Update(data, size, &out);

    if (r != kSuccess) {
      if (r == kErrorState) {
        ThrowCryptoError(env, ERR_get_error(),
                         ""Trying to add data in unsupported state"");
      }
      return;
    }

    Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(out));
    args.GetReturnValue().Set(
        Buffer::New(env, ab, 0, ab->ByteLength()).FromMaybe(Local<Value>()));
  }",62,,849,5,,void
20905,BLOCK,-1,,<empty>,7,,854,2,,void
20925,BLOCK,-1,,"{
      if (r == kErrorState) {
        ThrowCryptoError(env, ERR_get_error(),
                         ""Trying to add data in unsupported state"");
      }
      return;
    }",24,,858,2,,void
20930,BLOCK,-1,,"{
        ThrowCryptoError(env, ERR_get_error(),
                         ""Trying to add data in unsupported state"");
      }",29,,859,2,,void
21002,BLOCK,-1,,<empty>,1,,1,1,,ANY
21008,BLOCK,-1,,"{
  switch (EVP_CIPHER_mode(cipher)) {
  case EVP_CIPH_CCM_MODE:
  case EVP_CIPH_GCM_MODE:
#ifndef OPENSSL_NO_OCB
  case EVP_CIPH_OCB_MODE:
#endif
    return true;
  case EVP_CIPH_STREAM_CIPHER:
    return EVP_CIPHER_nid(cipher) == NID_chacha20_poly1305;
  default:
    return false;
  }
}",61,,29,2,,void
21012,BLOCK,-1,,"{
  case EVP_CIPH_CCM_MODE:
  case EVP_CIPH_GCM_MODE:
#ifndef OPENSSL_NO_OCB
  case EVP_CIPH_OCB_MODE:
#endif
    return true;
  case EVP_CIPH_STREAM_CIPHER:
    return EVP_CIPHER_nid(cipher) == NID_chacha20_poly1305;
  default:
    return false;
  }",36,,30,2,,void
21035,BLOCK,-1,,"{
  const EVP_CIPHER* cipher = EVP_CIPHER_CTX_cipher(ctx);
  return IsSupportedAuthenticatedMode(cipher);
}",62,,44,2,,void
21048,BLOCK,-1,,"{
  return tag_len == 4 || tag_len == 8 || (tag_len >= 12 && tag_len <= 16);
}",48,,49,2,,void
21069,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsObject());
  Local<Object> info = args[0].As<Object>();

  CHECK(args[1]->IsString() || args[1]->IsInt32());

  const EVP_CIPHER* cipher;
  if (args[1]->IsString()) {
    Utf8Value name(env->isolate(), args[1]);
    cipher = EVP_get_cipherbyname(*name);
  } else {
    int nid = args[1].As<Int32>()->Value();
    cipher = EVP_get_cipherbynid(nid);
  }

  if (cipher == nullptr)
    return;

  int mode = EVP_CIPHER_mode(cipher);
  int iv_length = EVP_CIPHER_iv_length(cipher);
  int key_length = EVP_CIPHER_key_length(cipher);
  int block_length = EVP_CIPHER_block_size(cipher);
  const char* mode_label = nullptr;
  switch (mode) {
    case EVP_CIPH_CBC_MODE: mode_label = ""cbc""; break;
    case EVP_CIPH_CCM_MODE: mode_label = ""ccm""; break;
    case EVP_CIPH_CFB_MODE: mode_label = ""cfb""; break;
    case EVP_CIPH_CTR_MODE: mode_label = ""ctr""; break;
    case EVP_CIPH_ECB_MODE: mode_label = ""ecb""; break;
    case EVP_CIP...",61,,54,2,,void
21119,BLOCK,-1,,"{
    Utf8Value name(env->isolate(), args[1]);
    cipher = EVP_get_cipherbyname(*name);
  }",28,,62,2,,void
21135,BLOCK,-1,,"{
    int nid = args[1].As<Int32>()->Value();
    cipher = EVP_get_cipherbynid(nid);
  }",10,,65,1,,void
21156,BLOCK,-1,,<empty>,5,,71,2,,void
21184,BLOCK,-1,,"{
    case EVP_CIPH_CBC_MODE: mode_label = ""cbc""; break;
    case EVP_CIPH_CCM_MODE: mode_label = ""ccm""; break;
    case EVP_CIPH_CFB_MODE: mode_label = ""cfb""; break;
    case EVP_CIPH_CTR_MODE: mode_label = ""ctr""; break;
    case EVP_CIPH_ECB_MODE: mode_label = ""ecb""; break;
    case EVP_CIPH_GCM_MODE: mode_label = ""gcm""; break;
    case EVP_CIPH_OCB_MODE: mode_label = ""ocb""; break;
    case EVP_CIPH_OFB_MODE: mode_label = ""ofb""; break;
    case EVP_CIPH_WRAP_MODE: mode_label = ""wrap""; break;
    case EVP_CIPH_XTS_MODE: mode_label = ""xts""; break;
    case EVP_CIPH_STREAM_CIPHER: mode_label = ""stream""; break;
  }",17,,78,2,,void
21265,BLOCK,-1,,"{
    // Test and input IV or key length to determine if it's acceptable.
    // If it is, then the getCipherInfo will succeed with the given
    // values.
    CipherCtxPointer ctx(EVP_CIPHER_CTX_new());
    if (!EVP_CipherInit_ex(ctx.get(), cipher, nullptr, nullptr, nullptr, 1))
      return;

    if (args[2]->IsInt32()) {
      int check_len = args[2].As<Int32>()->Value();
      if (!EVP_CIPHER_CTX_set_key_length(ctx.get(), check_len))
        return;
      key_length = check_len;
    }

    if (args[3]->IsInt32()) {
      int check_len = args[3].As<Int32>()->Value();
      // For CCM modes, the IV may be between 7 and 13 bytes.
      // For GCM and OCB modes, we'll check by attempting to
      // set the value. For everything else, just check that
      // check_len == iv_length.
      switch (mode) {
        case EVP_CIPH_CCM_MODE:
          if (check_len < 7 || check_len > 13)
            return;
          break;
        case EVP_CIPH_GCM_MODE:
          // Fall through
      ...",49,,97,2,,void
21281,BLOCK,-1,,<empty>,7,,103,2,,void
21290,BLOCK,-1,,"{
      int check_len = args[2].As<Int32>()->Value();
      if (!EVP_CIPHER_CTX_set_key_length(ctx.get(), check_len))
        return;
      key_length = check_len;
    }",29,,105,2,,void
21311,BLOCK,-1,,<empty>,9,,108,2,,void
21323,BLOCK,-1,,"{
      int check_len = args[3].As<Int32>()->Value();
      // For CCM modes, the IV may be between 7 and 13 bytes.
      // For GCM and OCB modes, we'll check by attempting to
      // set the value. For everything else, just check that
      // check_len == iv_length.
      switch (mode) {
        case EVP_CIPH_CCM_MODE:
          if (check_len < 7 || check_len > 13)
            return;
          break;
        case EVP_CIPH_GCM_MODE:
          // Fall through
        case EVP_CIPH_OCB_MODE:
          if (!EVP_CIPHER_CTX_ctrl(
                  ctx.get(),
                  EVP_CTRL_AEAD_SET_IVLEN,
                  check_len,
                  nullptr)) {
            return;
          }
          break;
        default:
          if (check_len != iv_length)
            return;
      }
      iv_length = check_len;
    }",29,,112,2,,void
21338,BLOCK,-1,,"{
        case EVP_CIPH_CCM_MODE:
          if (check_len < 7 || check_len > 13)
            return;
          break;
        case EVP_CIPH_GCM_MODE:
          // Fall through
        case EVP_CIPH_OCB_MODE:
          if (!EVP_CIPHER_CTX_ctrl(
                  ctx.get(),
                  EVP_CTRL_AEAD_SET_IVLEN,
                  check_len,
                  nullptr)) {
            return;
          }
          break;
        default:
          if (check_len != iv_length)
            return;
      }",21,,118,2,,void
21349,BLOCK,-1,,<empty>,13,,121,2,,void
21366,BLOCK,-1,,"{
            return;
          }",29,,130,2,,void
21374,BLOCK,-1,,<empty>,13,,136,2,,void
21407,BLOCK,-1,,"{
    return;
  }",67,,146,2,,void
21433,BLOCK,-1,,"{
    return;
  }",63,,157,2,,void
21463,BLOCK,-1,,"{
    return;
  }",76,,164,2,,void
21496,BLOCK,-1,,"{
    return;
  }",66,,173,2,,void
21529,BLOCK,-1,,"{
    return;
  }",63,,182,2,,void
21558,BLOCK,-1,,"{
    return;
  }",64,,189,2,,void
21572,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  SSLCtxPointer ctx(SSL_CTX_new(TLS_method()));
  if (!ctx) {
    return ThrowCryptoError(env, ERR_get_error(), ""SSL_CTX_new"");
  }

  SSLPointer ssl(SSL_new(ctx.get()));
  if (!ssl) {
    return ThrowCryptoError(env, ERR_get_error(), ""SSL_new"");
  }

  STACK_OF(SSL_CIPHER)* ciphers = SSL_get_ciphers(ssl.get());

  // TLSv1.3 ciphers aren't listed by EVP. There are only 5, we could just
  // document them, but since there are only 5, easier to just add them manually
  // and not have to explain their absence in the API docs. They are lower-cased
  // because the docs say they will be.
  static const char* TLS13_CIPHERS[] = {
    ""tls_aes_256_gcm_sha384"",
    ""tls_chacha20_poly1305_sha256"",
    ""tls_aes_128_gcm_sha256"",
    ""tls_aes_128_ccm_8_sha256"",
    ""tls_aes_128_ccm_sha256""
  };

  const int n = sk_SSL_CIPHER_num(ciphers);
  std::vector<Local<Value>> arr(n + arraysize(TLS13_CIPHERS));

  for (int i = 0; i < n; ++i) {
    co...",73,,197,2,,void
21583,BLOCK,-1,,<empty>,,,,2,,<empty>
21589,BLOCK,-1,,"{
    return ThrowCryptoError(env, ERR_get_error(), ""SSL_CTX_new"");
  }",13,,201,2,,void
21605,BLOCK,-1,,"{
    return ThrowCryptoError(env, ERR_get_error(), ""SSL_new"");
  }",13,,206,2,,void
21649,BLOCK,-1,,<empty>,3,,227,1,,void
21659,BLOCK,4,,"{
    const SSL_CIPHER* cipher = sk_SSL_CIPHER_value(ciphers, i);
    arr[i] = OneByteString(env->isolate(), SSL_CIPHER_get_name(cipher));
  }",31,,227,4,,void
21678,BLOCK,-1,,<empty>,3,,232,1,,void
21689,BLOCK,4,,"{
    const char* name = TLS13_CIPHERS[i];
    arr[n + i] = OneByteString(env->isolate(), name);
  }",59,,232,4,,void
21735,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  MarkPopErrorOnReturn mark_pop_error_on_return;
  CipherPushContext ctx(env);
  EVP_CIPHER_do_all_sorted(
#if OPENSSL_VERSION_MAJOR >= 3
    array_push_back<EVP_CIPHER,
                    EVP_CIPHER_fetch,
                    EVP_CIPHER_free,
                    EVP_get_cipherbyname,
                    EVP_CIPHER_get0_name>,
#else
    array_push_back<EVP_CIPHER>,
#endif
    &ctx);
  args.GetReturnValue().Set(ctx.ToJSArray());
}",70,,240,2,,void
21769,BLOCK,-1,,"{
  MakeWeak();
}",35,,266,4,,void
21775,BLOCK,-1,,"{
  tracker->TrackFieldWithSize(""context"", ctx_ ? kSizeOf_EVP_CIPHER_CTX : 0);
}",59,,270,2,,void
21790,BLOCK,-1,,"{
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);

  t->InstanceTemplate()->SetInternalFieldCount(CipherBase::kInternalFieldCount);

  SetProtoMethod(isolate, t, ""init"", Init);
  SetProtoMethod(isolate, t, ""initiv"", InitIv);
  SetProtoMethod(isolate, t, ""update"", Update);
  SetProtoMethod(isolate, t, ""final"", Final);
  SetProtoMethod(isolate, t, ""setAutoPadding"", SetAutoPadding);
  SetProtoMethodNoSideEffect(isolate, t, ""getAuthTag"", GetAuthTag);
  SetProtoMethod(isolate, t, ""setAuthTag"", SetAuthTag);
  SetProtoMethod(isolate, t, ""setAAD"", SetAAD);
  SetConstructorFunction(context, target, ""CipherBase"", t);

  SetMethodNoSideEffect(context, target, ""getSSLCiphers"", GetSSLCiphers);
  SetMethodNoSideEffect(context, target, ""getCiphers"", GetCiphers);

  SetMethod(context,
            target,
            ""publicEncrypt"",
            PublicKeyCipher::Cipher<PublicKeyCipher::kPublic,
        ...",69,,274,3,,void
21920,BLOCK,1,,<empty>,,,,7,,void
21922,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kWebCryptoCipherEncrypt)",3,,322,1,,void
22019,BLOCK,1,,<empty>,,,,7,,void
22021,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kWebCryptoCipherDecrypt)",3,,323,1,,void
22117,BLOCK,-1,,"{
  registry->Register(New);

  registry->Register(Init);
  registry->Register(InitIv);
  registry->Register(Update);
  registry->Register(Final);
  registry->Register(SetAutoPadding);
  registry->Register(GetAuthTag);
  registry->Register(SetAuthTag);
  registry->Register(SetAAD);

  registry->Register(GetSSLCiphers);
  registry->Register(GetCiphers);

  registry->Register(PublicKeyCipher::Cipher<PublicKeyCipher::kPublic,
                                             EVP_PKEY_encrypt_init,
                                             EVP_PKEY_encrypt>);
  registry->Register(PublicKeyCipher::Cipher<PublicKeyCipher::kPrivate,
                                             EVP_PKEY_decrypt_init,
                                             EVP_PKEY_decrypt>);
  registry->Register(PublicKeyCipher::Cipher<PublicKeyCipher::kPrivate,
                                             EVP_PKEY_sign_init,
                                             EVP_PKEY_sign>);
  registry->Register(PublicKeyCip...",42,,327,2,,void
22210,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);
  new CipherBase(env, args.This(), args[0]->IsTrue() ? kCipher : kDecipher);
}",63,,358,2,,void
22250,BLOCK,-1,,"{
  CHECK(!ctx_);
  ctx_.reset(EVP_CIPHER_CTX_new());

  const int mode = EVP_CIPHER_mode(cipher);
  if (mode == EVP_CIPH_WRAP_MODE)
    EVP_CIPHER_CTX_set_flags(ctx_.get(), EVP_CIPHER_CTX_FLAG_WRAP_ALLOW);

  const bool encrypt = (kind_ == kCipher);
  if (1 != EVP_CipherInit_ex(ctx_.get(), cipher, nullptr,
                             nullptr, nullptr, encrypt)) {
    return ThrowCryptoError(env(), ERR_get_error(),
                            ""Failed to initialize cipher"");
  }

  if (IsSupportedAuthenticatedMode(cipher)) {
    CHECK_GE(iv_len, 0);
    if (!InitAuthenticated(cipher_type, iv_len, auth_tag_len))
      return;
  }

  if (!EVP_CIPHER_CTX_set_key_length(ctx_.get(), key_len)) {
    ctx_.reset();
    return THROW_ERR_CRYPTO_INVALID_KEYLEN(env());
  }

  if (1 != EVP_CipherInit_ex(ctx_.get(), nullptr, nullptr, key, iv, encrypt)) {
    return ThrowCryptoError(env(), ERR_get_error(),
                            ""Failed to initialize cipher"");
  }
}",56,,370,8,,void
22268,BLOCK,-1,,<empty>,5,,376,2,,void
22294,BLOCK,-1,,"{
    return ThrowCryptoError(env(), ERR_get_error(),
                            ""Failed to initialize cipher"");
  }",58,,380,2,,void
22303,BLOCK,-1,,"{
    CHECK_GE(iv_len, 0);
    if (!InitAuthenticated(cipher_type, iv_len, auth_tag_len))
      return;
  }",45,,385,2,,void
22313,BLOCK,-1,,<empty>,7,,388,2,,void
22323,BLOCK,-1,,"{
    ctx_.reset();
    return THROW_ERR_CRYPTO_INVALID_KEYLEN(env());
  }",60,,391,2,,void
22344,BLOCK,-1,,"{
    return ThrowCryptoError(env(), ERR_get_error(),
                            ""Failed to initialize cipher"");
  }",79,,396,2,,void
22356,BLOCK,-1,,"{
  HandleScope scope(env()->isolate());
  MarkPopErrorOnReturn mark_pop_error_on_return;
#if OPENSSL_VERSION_MAJOR >= 3
  if (EVP_default_properties_is_fips_enabled(nullptr)) {
#else
  if (FIPS_mode()) {
#endif
    return THROW_ERR_CRYPTO_UNSUPPORTED_OPERATION(env(),
        ""crypto.createCipher() is not supported in FIPS mode."");
  }

  const EVP_CIPHER* const cipher = EVP_get_cipherbyname(cipher_type);
  if (cipher == nullptr)
    return THROW_ERR_CRYPTO_UNKNOWN_CIPHER(env());

  unsigned char key[EVP_MAX_KEY_LENGTH];
  unsigned char iv[EVP_MAX_IV_LENGTH];

  int key_len = EVP_BytesToKey(cipher,
                               EVP_md5(),
                               nullptr,
                               key_buf.data(),
                               key_buf.size(),
                               1,
                               key,
                               iv);
  CHECK_NE(key_len, 0);

  const int mode = EVP_CIPHER_mode(cipher);
  if (kind_ == kCipher && (mode == EVP_C...",50,,404,4,,void
22366,BLOCK,-1,,"{
#endif
    return THROW_ERR_CRYPTO_UNSUPPORTED_OPERATION(env(),
        ""crypto.createCipher() is not supported in FIPS mode."");
  }",20,,410,2,,void
22380,BLOCK,-1,,<empty>,5,,418,2,,void
22428,BLOCK,-1,,"{
    // Ignore the return value (i.e. possible exception) because we are
    // not calling back into JS anyway.
    ProcessEmitWarning(env(),
                       ""Use Cipheriv for counter mode of %s"",
                       cipher_type);
  }",56,,436,2,,void
22446,BLOCK,-1,,"{
  CipherBase* cipher;
  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());
  Environment* env = Environment::GetCurrent(args);

  CHECK_GE(args.Length(), 3);

  const Utf8Value cipher_type(args.GetIsolate(), args[0]);
  ArrayBufferOrViewContents<unsigned char> key_buf(args[1]);
  if (!key_buf.CheckSizeInt32())
    return THROW_ERR_OUT_OF_RANGE(env, ""password is too large"");

  // Don't assign to cipher->auth_tag_len_ directly; the value might not
  // represent a valid length at this point.
  unsigned int auth_tag_len;
  if (args[2]->IsUint32()) {
    auth_tag_len = args[2].As<Uint32>()->Value();
  } else {
    CHECK(args[2]->IsInt32() && args[2].As<Int32>()->Value() == -1);
    auth_tag_len = kNoAuthTagLength;
  }

  cipher->Init(*cipher_type, key_buf, auth_tag_len);
}",64,,448,2,,void
22489,BLOCK,-1,,<empty>,5,,458,2,,void
22502,BLOCK,-1,,"{
    auth_tag_len = args[2].As<Uint32>()->Value();
  }",28,,463,2,,void
22515,BLOCK,-1,,"{
    CHECK(args[2]->IsInt32() && args[2].As<Int32>()->Value() == -1);
    auth_tag_len = kNoAuthTagLength;
  }",10,,465,1,,void
22554,BLOCK,-1,,"{
  HandleScope scope(env()->isolate());
  MarkPopErrorOnReturn mark_pop_error_on_return;

  const EVP_CIPHER* const cipher = EVP_get_cipherbyname(cipher_type);
  if (cipher == nullptr)
    return THROW_ERR_CRYPTO_UNKNOWN_CIPHER(env());

  const int expected_iv_len = EVP_CIPHER_iv_length(cipher);
  const bool is_authenticated_mode = IsSupportedAuthenticatedMode(cipher);
  const bool has_iv = iv_buf.size() > 0;

  // Throw if no IV was passed and the cipher requires an IV
  if (!has_iv && expected_iv_len != 0)
    return THROW_ERR_CRYPTO_INVALID_IV(env());

  // Throw if an IV was passed which does not match the cipher's fixed IV length
  // static_cast<int> for the iv_buf.size() is safe because we've verified
  // prior that the value is not larger than INT_MAX.
  if (!is_authenticated_mode &&
      has_iv &&
      static_cast<int>(iv_buf.size()) != expected_iv_len) {
    return THROW_ERR_CRYPTO_INVALID_IV(env());
  }

  if (EVP_CIPHER_nid(cipher) == NID_chacha20_poly1305) {
    CHE...",52,,476,5,,void
22571,BLOCK,-1,,<empty>,5,,482,2,,void
22601,BLOCK,-1,,<empty>,5,,490,2,,void
22619,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_INVALID_IV(env());
  }",59,,497,2,,void
22628,BLOCK,-1,,"{
    CHECK(has_iv);
    // Check for invalid IV lengths, since OpenSSL does not under some
    // conditions:
    //   https://www.openssl.org/news/secadv/20190306.txt.
    if (iv_buf.size() > 12)
      return THROW_ERR_CRYPTO_INVALID_IV(env());
  }",56,,501,2,,void
22638,BLOCK,-1,,<empty>,7,,507,2,,void
22666,BLOCK,-1,,"{
  CipherBase* cipher;
  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());
  Environment* env = cipher->env();

  CHECK_GE(args.Length(), 4);

  const Utf8Value cipher_type(env->isolate(), args[0]);

  // The argument can either be a KeyObjectHandle or a byte source
  // (e.g. ArrayBuffer, TypedArray, etc). Whichever it is, grab the
  // raw bytes and proceed...
  const ByteSource key_buf = ByteSource::FromSecretKeyBytes(env, args[1]);

  if (UNLIKELY(key_buf.size() > INT_MAX))
    return THROW_ERR_OUT_OF_RANGE(env, ""key is too big"");

  ArrayBufferOrViewContents<unsigned char> iv_buf(
      !args[2]->IsNull() ? args[2] : Local<Value>());

  if (UNLIKELY(!iv_buf.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""iv is too big"");

  // Don't assign to cipher->auth_tag_len_ directly; the value might not
  // represent a valid length at this point.
  unsigned int auth_tag_len;
  if (args[3]->IsUint32()) {
    auth_tag_len = args[3].As<Uint32>()->Value();
  } else {
    CHECK(ar...",66,,520,2,,void
22716,BLOCK,-1,,<empty>,5,,535,2,,void
22742,BLOCK,-1,,<empty>,5,,541,2,,void
22755,BLOCK,-1,,"{
    auth_tag_len = args[3].As<Uint32>()->Value();
  }",28,,546,2,,void
22768,BLOCK,-1,,"{
    CHECK(args[3]->IsInt32() && args[3].As<Int32>()->Value() == -1);
    auth_tag_len = kNoAuthTagLength;
  }",10,,548,1,,void
22807,BLOCK,-1,,"{
  CHECK(IsAuthenticatedMode());
  MarkPopErrorOnReturn mark_pop_error_on_return;

  if (!EVP_CIPHER_CTX_ctrl(ctx_.get(),
                           EVP_CTRL_AEAD_SET_IVLEN,
                           iv_len,
                           nullptr)) {
    THROW_ERR_CRYPTO_INVALID_IV(env());
    return false;
  }

  const int mode = EVP_CIPHER_CTX_mode(ctx_.get());
  if (mode == EVP_CIPH_GCM_MODE) {
    if (auth_tag_len != kNoAuthTagLength) {
      if (!IsValidGCMTagLength(auth_tag_len)) {
        THROW_ERR_CRYPTO_INVALID_AUTH_TAG(
          env(),
          ""Invalid authentication tag length: %u"",
          auth_tag_len);
        return false;
      }

      // Remember the given authentication tag length for later.
      auth_tag_len_ = auth_tag_len;
    }
  } else {
    if (auth_tag_len == kNoAuthTagLength) {
      // We treat ChaCha20-Poly1305 specially. Like GCM, the authentication tag
      // length defaults to 16 bytes when encrypting. Unlike GCM, the
      // authentication tag...",32,,559,4,,void
22820,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_IV(env());
    return false;
  }",38,,566,2,,void
22836,BLOCK,-1,,"{
    if (auth_tag_len != kNoAuthTagLength) {
      if (!IsValidGCMTagLength(auth_tag_len)) {
        THROW_ERR_CRYPTO_INVALID_AUTH_TAG(
          env(),
          ""Invalid authentication tag length: %u"",
          auth_tag_len);
        return false;
      }

      // Remember the given authentication tag length for later.
      auth_tag_len_ = auth_tag_len;
    }
  }",34,,572,2,,void
22841,BLOCK,-1,,"{
      if (!IsValidGCMTagLength(auth_tag_len)) {
        THROW_ERR_CRYPTO_INVALID_AUTH_TAG(
          env(),
          ""Invalid authentication tag length: %u"",
          auth_tag_len);
        return false;
      }

      // Remember the given authentication tag length for later.
      auth_tag_len_ = auth_tag_len;
    }",43,,573,2,,void
22846,BLOCK,-1,,"{
        THROW_ERR_CRYPTO_INVALID_AUTH_TAG(
          env(),
          ""Invalid authentication tag length: %u"",
          auth_tag_len);
        return false;
      }",47,,574,2,,void
22857,BLOCK,-1,,"{
    if (auth_tag_len == kNoAuthTagLength) {
      // We treat ChaCha20-Poly1305 specially. Like GCM, the authentication tag
      // length defaults to 16 bytes when encrypting. Unlike GCM, the
      // authentication tag length also defaults to 16 bytes when decrypting,
      // whereas GCM would accept any valid authentication tag length.
      if (EVP_CIPHER_CTX_nid(ctx_.get()) == NID_chacha20_poly1305) {
        auth_tag_len = 16;
      } else {
        THROW_ERR_CRYPTO_INVALID_AUTH_TAG(
          env(), ""authTagLength required for %s"", cipher_type);
        return false;
      }
    }

    // TODO(tniessen) Support CCM decryption in FIPS mode

#if OPENSSL_VERSION_MAJOR >= 3
    if (mode == EVP_CIPH_CCM_MODE && kind_ == kDecipher &&
        EVP_default_properties_is_fips_enabled(nullptr)) {
#else
    if (mode == EVP_CIPH_CCM_MODE && kind_ == kDecipher && FIPS_mode()) {
#endif
      THROW_ERR_CRYPTO_UNSUPPORTED_OPERATION(env(),
          ""CCM encryption not supported in FIPS mo...",10,,585,1,,void
22862,BLOCK,-1,,"{
      // We treat ChaCha20-Poly1305 specially. Like GCM, the authentication tag
      // length defaults to 16 bytes when encrypting. Unlike GCM, the
      // authentication tag length also defaults to 16 bytes when decrypting,
      // whereas GCM would accept any valid authentication tag length.
      if (EVP_CIPHER_CTX_nid(ctx_.get()) == NID_chacha20_poly1305) {
        auth_tag_len = 16;
      } else {
        THROW_ERR_CRYPTO_INVALID_AUTH_TAG(
          env(), ""authTagLength required for %s"", cipher_type);
        return false;
      }
    }",43,,586,2,,void
22871,BLOCK,-1,,"{
        auth_tag_len = 16;
      }",68,,591,2,,void
22876,BLOCK,-1,,"{
        THROW_ERR_CRYPTO_INVALID_AUTH_TAG(
          env(), ""authTagLength required for %s"", cipher_type);
        return false;
      }",14,,593,1,,void
22893,BLOCK,-1,,"{
#endif
      THROW_ERR_CRYPTO_UNSUPPORTED_OPERATION(env(),
          ""CCM encryption not supported in FIPS mode"");
      return false;
    }",73,,606,2,,void
22909,BLOCK,-1,,"{
      THROW_ERR_CRYPTO_INVALID_AUTH_TAG(
          env(), ""Invalid authentication tag length: %u"", auth_tag_len);
      return false;
    }",40,,615,2,,void
22923,BLOCK,-1,,"{
      // Restrict the message length to min(INT_MAX, 2^(8*(15-iv_len))-1) bytes.
      CHECK(iv_len >= 7 && iv_len <= 13);
      max_message_size_ = INT_MAX;
      if (iv_len == 12) max_message_size_ = 16777215;
      if (iv_len == 13) max_message_size_ = 65535;
    }",36,,624,2,,void
22939,BLOCK,-1,,<empty>,25,,628,2,,void
22947,BLOCK,-1,,<empty>,25,,629,2,,void
22957,BLOCK,-1,,"{
  CHECK(ctx_);
  CHECK(EVP_CIPHER_CTX_mode(ctx_.get()) == EVP_CIPH_CCM_MODE);

  if (message_len > max_message_size_) {
    THROW_ERR_CRYPTO_INVALID_MESSAGELEN(env());
    return false;
  }

  return true;
}",57,,636,2,,void
22971,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_MESSAGELEN(env());
    return false;
  }",40,,640,2,,void
22980,BLOCK,-1,,"{
  // Check if this cipher operates in an AEAD mode that we support.
  CHECK(ctx_);
  return IsSupportedAuthenticatedMode(ctx_.get());
}",46,,648,1,,void
22992,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CipherBase* cipher;
  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());

  // Only callable after Final and if encrypting.
  if (cipher->ctx_ ||
      cipher->kind_ != kCipher ||
      cipher->auth_tag_len_ == kNoAuthTagLength) {
    return;
  }

  args.GetReturnValue().Set(
      Buffer::Copy(env, cipher->auth_tag_, cipher->auth_tag_len_)
          .FromMaybe(Local<Value>()));
}",70,,654,2,,void
23025,BLOCK,-1,,"{
    return;
  }",50,,662,2,,void
23053,BLOCK,-1,,"{
  CipherBase* cipher;
  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());
  Environment* env = Environment::GetCurrent(args);

  if (!cipher->ctx_ ||
      !cipher->IsAuthenticatedMode() ||
      cipher->kind_ != kDecipher ||
      cipher->auth_tag_state_ != kAuthTagUnknown) {
    return args.GetReturnValue().Set(false);
  }

  ArrayBufferOrViewContents<char> auth_tag(args[0]);
  if (UNLIKELY(!auth_tag.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""buffer is too big"");

  unsigned int tag_len = auth_tag.size();

  const int mode = EVP_CIPHER_CTX_mode(cipher->ctx_.get());
  bool is_valid;
  if (mode == EVP_CIPH_GCM_MODE) {
    // Restrict GCM tag lengths according to NIST 800-38d, page 9.
    is_valid = (cipher->auth_tag_len_ == kNoAuthTagLength ||
                cipher->auth_tag_len_ == tag_len) &&
               IsValidGCMTagLength(tag_len);
  } else {
    // At this point, the tag length is already known and must match the
    // length of the given authentication ta...",70,,671,2,,void
23093,BLOCK,-1,,"{
    return args.GetReturnValue().Set(false);
  }",51,,679,2,,void
23115,BLOCK,-1,,<empty>,5,,685,2,,void
23142,BLOCK,-1,,"{
    // Restrict GCM tag lengths according to NIST 800-38d, page 9.
    is_valid = (cipher->auth_tag_len_ == kNoAuthTagLength ||
                cipher->auth_tag_len_ == tag_len) &&
               IsValidGCMTagLength(tag_len);
  }",34,,691,2,,void
23160,BLOCK,-1,,"{
    // At this point, the tag length is already known and must match the
    // length of the given authentication tag.
    CHECK(IsSupportedAuthenticatedMode(cipher->ctx_.get()));
    CHECK_NE(cipher->auth_tag_len_, kNoAuthTagLength);
    is_valid = cipher->auth_tag_len_ == tag_len;
  }",10,,696,1,,void
23184,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_INVALID_AUTH_TAG(
      env, ""Invalid authentication tag length: %u"", tag_len);
  }",18,,704,2,,void
23238,BLOCK,-1,,"{
  if (auth_tag_state_ == kAuthTagKnown) {
    if (!EVP_CIPHER_CTX_ctrl(ctx_.get(),
                             EVP_CTRL_AEAD_SET_TAG,
                             auth_tag_len_,
                             reinterpret_cast<unsigned char*>(auth_tag_))) {
      return false;
    }
    auth_tag_state_ = kAuthTagPassedToOpenSSL;
  }
  return true;
}",46,,719,1,,void
23243,BLOCK,-1,,"{
    if (!EVP_CIPHER_CTX_ctrl(ctx_.get(),
                             EVP_CTRL_AEAD_SET_TAG,
                             auth_tag_len_,
                             reinterpret_cast<unsigned char*>(auth_tag_))) {
      return false;
    }
    auth_tag_state_ = kAuthTagPassedToOpenSSL;
  }",41,,720,2,,void
23256,BLOCK,-1,,"{
      return false;
    }",76,,724,2,,void
23269,BLOCK,-1,,"{
  if (!ctx_ || !IsAuthenticatedMode())
    return false;
  MarkPopErrorOnReturn mark_pop_error_on_return;

  int outlen;
  const int mode = EVP_CIPHER_CTX_mode(ctx_.get());

  // When in CCM mode, we need to set the authentication tag and the plaintext
  // length in advance.
  if (mode == EVP_CIPH_CCM_MODE) {
    if (plaintext_len < 0) {
      THROW_ERR_MISSING_ARGS(env(),
          ""options.plaintextLength required for CCM mode with AAD"");
      return false;
    }

    if (!CheckCCMMessageLength(plaintext_len))
      return false;

    if (kind_ == kDecipher) {
      if (!MaybePassAuthTagToOpenSSL())
        return false;
    }

    // Specify the plaintext length.
    if (!EVP_CipherUpdate(ctx_.get(), nullptr, &outlen, nullptr, plaintext_len))
      return false;
  }

  return 1 == EVP_CipherUpdate(ctx_.get(),
                               nullptr,
                               &outlen,
                               data.data(),
                               data.size());
}",24,,734,3,,void
23276,BLOCK,-1,,<empty>,5,,736,2,,void
23293,BLOCK,-1,,"{
    if (plaintext_len < 0) {
      THROW_ERR_MISSING_ARGS(env(),
          ""options.plaintextLength required for CCM mode with AAD"");
      return false;
    }

    if (!CheckCCMMessageLength(plaintext_len))
      return false;

    if (kind_ == kDecipher) {
      if (!MaybePassAuthTagToOpenSSL())
        return false;
    }

    // Specify the plaintext length.
    if (!EVP_CipherUpdate(ctx_.get(), nullptr, &outlen, nullptr, plaintext_len))
      return false;
  }",34,,744,2,,void
23298,BLOCK,-1,,"{
      THROW_ERR_MISSING_ARGS(env(),
          ""options.plaintextLength required for CCM mode with AAD"");
      return false;
    }",28,,745,2,,void
23308,BLOCK,-1,,<empty>,7,,752,2,,void
23315,BLOCK,-1,,"{
      if (!MaybePassAuthTagToOpenSSL())
        return false;
    }",29,,754,2,,void
23319,BLOCK,-1,,<empty>,9,,756,2,,void
23334,BLOCK,-1,,<empty>,7,,761,2,,void
23360,BLOCK,-1,,"{
  CipherBase* cipher;
  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());
  Environment* env = Environment::GetCurrent(args);

  CHECK_EQ(args.Length(), 2);
  CHECK(args[1]->IsInt32());
  int plaintext_len = args[1].As<Int32>()->Value();
  ArrayBufferOrViewContents<unsigned char> buf(args[0]);

  if (UNLIKELY(!buf.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""buffer is too big"");
  args.GetReturnValue().Set(cipher->SetAAD(buf, plaintext_len));
}",66,,771,2,,void
23414,BLOCK,-1,,<empty>,5,,782,2,,void
23438,BLOCK,-1,,"{
  if (!ctx_ || len > INT_MAX)
    return kErrorState;
  MarkPopErrorOnReturn mark_pop_error_on_return;

  const int mode = EVP_CIPHER_CTX_mode(ctx_.get());

  if (mode == EVP_CIPH_CCM_MODE && !CheckCCMMessageLength(len))
    return kErrorMessageSize;

  // Pass the authentication tag to OpenSSL if possible. This will only happen
  // once, usually on the first update.
  if (kind_ == kDecipher && IsAuthenticatedMode())
    CHECK(MaybePassAuthTagToOpenSSL());

  const int block_size = EVP_CIPHER_CTX_block_size(ctx_.get());
  CHECK_GT(block_size, 0);
  if (len + block_size > INT_MAX) return kErrorState;
  int buf_len = len + block_size;

  // For key wrapping algorithms, get output size by calling
  // EVP_CipherUpdate() with null output.
  if (kind_ == kCipher && mode == EVP_CIPH_WRAP_MODE &&
      EVP_CipherUpdate(ctx_.get(),
                       nullptr,
                       &buf_len,
                       reinterpret_cast<const unsigned char*>(data),
                       l...",41,,789,4,,void
23446,BLOCK,-1,,<empty>,5,,791,2,,void
23466,BLOCK,-1,,<empty>,5,,797,2,,void
23475,BLOCK,-1,,<empty>,5,,802,2,,void
23494,BLOCK,-1,,<empty>,35,,806,2,,void
23526,BLOCK,-1,,"{
    return kErrorState;
  }",35,,816,2,,void
23529,BLOCK,14,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env()->isolate_data());
    *out = ArrayBuffer::NewBackingStore(env()->isolate(), buf_len);
  }",3,,820,14,,void
23582,BLOCK,-1,,<empty>,5,,833,2,,void
23596,BLOCK,-1,,<empty>,5,,835,1,,void
23626,BLOCK,-1,,"{
    pending_auth_failed_ = true;
    return kSuccess;
  }",62,,839,2,,void
23642,BLOCK,-1,,"{
  Decode<CipherBase>(args, [](CipherBase* cipher,
                              const FunctionCallbackInfo<Value>& args,
                              const char* data, size_t size) {
    std::unique_ptr<BackingStore> out;
    Environment* env = Environment::GetCurrent(args);

    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");

    UpdateResult r = cipher->Update(data, size, &out);

    if (r != kSuccess) {
      if (r == kErrorState) {
        ThrowCryptoError(env, ERR_get_error(),
                         ""Trying to add data in unsupported state"");
      }
      return;
    }

    Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(out));
    args.GetReturnValue().Set(
        Buffer::New(env, ab, 0, ab->ByteLength()).FromMaybe(Local<Value>()));
  });
}",66,,846,2,,void
23655,BLOCK,-1,,"{
  if (!ctx_)
    return false;
  MarkPopErrorOnReturn mark_pop_error_on_return;
  return EVP_CIPHER_CTX_set_padding(ctx_.get(), auto_padding);
}",52,,872,2,,void
23659,BLOCK,-1,,<empty>,5,,874,2,,void
23674,BLOCK,-1,,"{
  CipherBase* cipher;
  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());

  bool b = cipher->SetAutoPadding(args.Length() < 1 || args[0]->IsTrue());
  args.GetReturnValue().Set(b);  // Possibly report invalid state failure
}",74,,879,2,,void
23715,BLOCK,-1,,"{
  if (!ctx_)
    return false;

  const int mode = EVP_CIPHER_CTX_mode(ctx_.get());

  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env()->isolate_data());
    *out = ArrayBuffer::NewBackingStore(env()->isolate(),
        static_cast<size_t>(EVP_CIPHER_CTX_block_size(ctx_.get())));
  }

  if (kind_ == kDecipher && IsSupportedAuthenticatedMode(ctx_.get()))
    MaybePassAuthTagToOpenSSL();

  // OpenSSL v1.x doesn't verify the presence of the auth tag so do
  // it ourselves, see https://github.com/nodejs/node/issues/45874.
  if (OPENSSL_VERSION_NUMBER < 0x30000000L && kind_ == kDecipher &&
      NID_chacha20_poly1305 == EVP_CIPHER_CTX_nid(ctx_.get()) &&
      auth_tag_state_ != kAuthTagPassedToOpenSSL) {
    return false;
  }

  // In CCM mode, final() only checks whether authentication failed in update().
  // EVP_CipherFinal_ex must not be called and will fail.
  bool ok;
  if (kind_ == kDecipher && mode == EVP_CIPH_CCM_MODE) {
    ok = !pending_auth_failed_;
    *out = Ar...",60,,887,2,,void
23719,BLOCK,-1,,<empty>,5,,889,2,,void
23730,BLOCK,4,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env()->isolate_data());
    *out = ArrayBuffer::NewBackingStore(env()->isolate(),
        static_cast<size_t>(EVP_CIPHER_CTX_block_size(ctx_.get())));
  }",3,,893,4,,void
23765,BLOCK,-1,,<empty>,5,,900,2,,void
23787,BLOCK,-1,,"{
    return false;
  }",51,,906,2,,void
23799,BLOCK,-1,,"{
    ok = !pending_auth_failed_;
    *out = ArrayBuffer::NewBackingStore(env()->isolate(), 0);
  }",56,,913,2,,void
23817,BLOCK,-1,,"{
    int out_len = (*out)->ByteLength();
    ok = EVP_CipherFinal_ex(ctx_.get(),
                            static_cast<unsigned char*>((*out)->Data()),
                            &out_len) == 1;

    CHECK_LE(static_cast<size_t>(out_len), (*out)->ByteLength());
    if (out_len > 0) {
      *out =
        BackingStore::Reallocate(env()->isolate(), std::move(*out), out_len);
    } else {
      *out = ArrayBuffer::NewBackingStore(env()->isolate(), 0);
    }

    if (ok && kind_ == kCipher && IsAuthenticatedMode()) {
      // In GCM mode, the authentication tag length can be specified in advance,
      // but defaults to 16 bytes when encrypting. In CCM and OCB mode, it must
      // always be given by the user.
      if (auth_tag_len_ == kNoAuthTagLength) {
        CHECK(mode == EVP_CIPH_GCM_MODE);
        auth_tag_len_ = sizeof(auth_tag_);
      }
      ok = (1 == EVP_CIPHER_CTX_ctrl(ctx_.get(), EVP_CTRL_AEAD_GET_TAG,
                     auth_tag_len_,
                     reinte...",10,,916,1,,void
23857,BLOCK,-1,,"{
      *out =
        BackingStore::Reallocate(env()->isolate(), std::move(*out), out_len);
    }",22,,923,2,,void
23877,BLOCK,-1,,"{
      *out = ArrayBuffer::NewBackingStore(env()->isolate(), 0);
    }",12,,926,1,,void
23898,BLOCK,-1,,"{
      // In GCM mode, the authentication tag length can be specified in advance,
      // but defaults to 16 bytes when encrypting. In CCM and OCB mode, it must
      // always be given by the user.
      if (auth_tag_len_ == kNoAuthTagLength) {
        CHECK(mode == EVP_CIPH_GCM_MODE);
        auth_tag_len_ = sizeof(auth_tag_);
      }
      ok = (1 == EVP_CIPHER_CTX_ctrl(ctx_.get(), EVP_CTRL_AEAD_GET_TAG,
                     auth_tag_len_,
                     reinterpret_cast<unsigned char*>(auth_tag_)));
    }",58,,930,2,,void
23903,BLOCK,-1,,"{
        CHECK(mode == EVP_CIPH_GCM_MODE);
        auth_tag_len_ = sizeof(auth_tag_);
      }",46,,934,2,,void
23936,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CipherBase* cipher;
  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());
  if (cipher->ctx_ == nullptr)
    return THROW_ERR_CRYPTO_INVALID_STATE(env);

  std::unique_ptr<BackingStore> out;

  // Check IsAuthenticatedMode() first, Final() destroys the EVP_CIPHER_CTX.
  const bool is_auth_mode = cipher->IsAuthenticatedMode();
  bool r = cipher->Final(&out);

  if (!r) {
    const char* msg = is_auth_mode
                          ? ""Unsupported state or unable to authenticate data""
                          : ""Unsupported state"";

    return ThrowCryptoError(env, ERR_get_error(), msg);
  }

  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(out));
  args.GetReturnValue().Set(
      Buffer::New(env, ab, 0, ab->ByteLength()).FromMaybe(Local<Value>()));
}",65,,949,2,,void
23959,BLOCK,-1,,<empty>,5,,955,2,,void
23989,BLOCK,-1,,"{
    const char* msg = is_auth_mode
                          ? ""Unsupported state or unable to authenticate data""
                          : ""Unsupported state"";

    return ThrowCryptoError(env, ERR_get_error(), msg);
  }",11,,963,2,,void
24053,BLOCK,-1,,"{
  EVPKeyCtxPointer ctx(EVP_PKEY_CTX_new(pkey.get(), nullptr));
  if (!ctx)
    return false;
  if (EVP_PKEY_cipher_init(ctx.get()) <= 0)
    return false;
  if (EVP_PKEY_CTX_set_rsa_padding(ctx.get(), padding) <= 0)
    return false;

  if (digest != nullptr) {
    if (EVP_PKEY_CTX_set_rsa_oaep_md(ctx.get(), digest) <= 0)
      return false;
  }

  if (!SetRsaOaepLabel(ctx, oaep_label.ToByteSource())) return false;

  size_t out_len = 0;
  if (EVP_PKEY_cipher(
          ctx.get(),
          nullptr,
          &out_len,
          data.data(),
          data.size()) <= 0) {
    return false;
  }

  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    *out = ArrayBuffer::NewBackingStore(env->isolate(), out_len);
  }

  if (EVP_PKEY_cipher(
          ctx.get(),
          static_cast<unsigned char*>((*out)->Data()),
          &out_len,
          data.data(),
          data.size()) <= 0) {
    return false;
  }

  CHECK_LE(out_len, (*out)->ByteLength());
  if (o...",41,,986,8,,void
24065,BLOCK,-1,,<empty>,5,,989,2,,void
24076,BLOCK,-1,,<empty>,5,,991,2,,void
24088,BLOCK,-1,,<empty>,5,,993,2,,void
24095,BLOCK,-1,,"{
    if (EVP_PKEY_CTX_set_rsa_oaep_md(ctx.get(), digest) <= 0)
      return false;
  }",26,,995,2,,void
24105,BLOCK,-1,,<empty>,7,,997,2,,void
24116,BLOCK,-1,,<empty>,57,,1000,2,,void
24142,BLOCK,-1,,"{
    return false;
  }",30,,1008,2,,void
24145,BLOCK,11,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    *out = ArrayBuffer::NewBackingStore(env->isolate(), out_len);
  }",3,,1012,11,,void
24189,BLOCK,-1,,"{
    return false;
  }",30,,1022,2,,void
24203,BLOCK,-1,,<empty>,5,,1028,2,,void
24223,BLOCK,-1,,<empty>,5,,1030,1,,void
24242,BLOCK,-1,,"{
  MarkPopErrorOnReturn mark_pop_error_on_return;
  Environment* env = Environment::GetCurrent(args);

  unsigned int offset = 0;
  ManagedEVPPKey pkey =
      ManagedEVPPKey::GetPublicOrPrivateKeyFromJs(args, &offset);
  if (!pkey)
    return;

  ArrayBufferOrViewContents<unsigned char> buf(args[offset]);
  if (UNLIKELY(!buf.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""buffer is too long"");

  uint32_t padding;
  if (!args[offset + 1]->Uint32Value(env->context()).To(&padding)) return;

  const EVP_MD* digest = nullptr;
  if (args[offset + 2]->IsString()) {
    const Utf8Value oaep_str(env->isolate(), args[offset + 2]);
    digest = EVP_get_digestbyname(*oaep_str);
    if (digest == nullptr)
      return THROW_ERR_OSSL_EVP_INVALID_DIGEST(env);
  }

  ArrayBufferOrViewContents<unsigned char> oaep_label(
      !args[offset + 3]->IsUndefined() ? args[offset + 3] : Local<Value>());
  if (UNLIKELY(!oaep_label.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""oaepL...",71,,1038,2,,void
24269,BLOCK,-1,,<empty>,5,,1046,2,,void
24283,BLOCK,-1,,<empty>,5,,1050,2,,void
24308,BLOCK,-1,,<empty>,68,,1053,2,,void
24323,BLOCK,-1,,"{
    const Utf8Value oaep_str(env->isolate(), args[offset + 2]);
    digest = EVP_get_digestbyname(*oaep_str);
    if (digest == nullptr)
      return THROW_ERR_OSSL_EVP_INVALID_DIGEST(env);
  }",37,,1056,2,,void
24344,BLOCK,-1,,<empty>,7,,1060,2,,void
24373,BLOCK,-1,,<empty>,5,,1066,2,,void
24396,BLOCK,-1,,"{
    return ThrowCryptoError(env, ERR_get_error());
  }",63,,1070,2,,void
24462,BLOCK,-1,,<empty>,1,,1,1,,ANY
24471,BLOCK,-1,,<empty>,1,,1,1,,ANY
24480,BLOCK,-1,,<empty>,1,,1,1,,ANY
24486,BLOCK,-1,,"{
  switch (state_) {
    case kWaiting:
      if (!ParseRecordHeader(data, avail))
        break;
      [[fallthrough]];
    case kTLSHeader:
      ParseHeader(data, avail);
      break;
    case kPaused:
      // Just nop
    case kEnded:
      // Already ended, just ignore it
      break;
    default:
      break;
  }
}",66,,27,3,,void
24489,BLOCK,-1,,"{
    case kWaiting:
      if (!ParseRecordHeader(data, avail))
        break;
      [[fallthrough]];
    case kTLSHeader:
      ParseHeader(data, avail);
      break;
    case kPaused:
      // Just nop
    case kEnded:
      // Already ended, just ignore it
      break;
    default:
      break;
  }",19,,28,2,,void
24497,BLOCK,-1,,<empty>,9,,31,2,,void
24517,BLOCK,-1,,"{
  // >= 5 bytes for header parsing
  if (avail < 5)
    return false;

  if (data[0] == kChangeCipherSpec ||
      data[0] == kAlert ||
      data[0] == kHandshake ||
      data[0] == kApplicationData) {
    frame_len_ = (data[3] << 8) + data[4];
    state_ = kTLSHeader;
    body_offset_ = 5;
  } else {
    End();
    return false;
  }

  // Sanity check (too big frame, or too small)
  // Let OpenSSL handle it
  if (frame_len_ >= kMaxTLSFrameLen) {
    End();
    return false;
  }

  return true;
}",78,,47,3,,void
24522,BLOCK,-1,,<empty>,5,,50,2,,void
24549,BLOCK,-1,,"{
    frame_len_ = (data[3] << 8) + data[4];
    state_ = kTLSHeader;
    body_offset_ = 5;
  }",36,,55,2,,void
24568,BLOCK,-1,,"{
    End();
    return false;
  }",10,,59,1,,void
24576,BLOCK,-1,,"{
    End();
    return false;
  }",38,,66,2,,void
24587,BLOCK,-1,,"{
  ClientHello hello;

  // We need at least six bytes (one byte for kClientHello, three bytes for the
  // length of the handshake message, and two bytes for the protocol version).
  // If the client sent a frame that suggests a smaller ClientHello, give up.
  if (frame_len_ < 6) return End();

  // >= 5 + frame size bytes for frame parsing
  if (body_offset_ + frame_len_ > avail)
    return;

  // Check hello protocol version.  Protocol tuples that we know about:
  //
  // (3,1) TLS v1.0
  // (3,2) TLS v1.1
  // (3,3) TLS v1.2
  //
  // Note that TLS v1.3 uses a TLS v1.2 handshake so requires no specific
  // support here.
  if (data[body_offset_ + 4] != 0x03 ||
      data[body_offset_ + 5] < 0x01 ||
      data[body_offset_ + 5] > 0x03) {
    return End();
  }

  if (data[body_offset_] == kClientHello) {
    if (state_ == kTLSHeader) {
      if (!ParseTLSClientHello(data, avail))
        return End();
    } else {
      // We couldn't get here, but whatever
      return End();
  ...",72,,75,3,,void
24593,BLOCK,-1,,<empty>,23,,81,2,,void
24602,BLOCK,-1,,<empty>,5,,85,2,,void
24628,BLOCK,-1,,"{
    return End();
  }",38,,97,2,,void
24637,BLOCK,-1,,"{
    if (state_ == kTLSHeader) {
      if (!ParseTLSClientHello(data, avail))
        return End();
    } else {
      // We couldn't get here, but whatever
      return End();
    }

    // Check if we overflowed (do not reply with any private data)
    if (session_id_ == nullptr ||
        session_size_ > 32 ||
        session_id_ + session_size_ > data + avail) {
      return End();
    }
  }",43,,101,2,,void
24642,BLOCK,-1,,"{
      if (!ParseTLSClientHello(data, avail))
        return End();
    }",31,,102,2,,void
24648,BLOCK,-1,,<empty>,9,,104,2,,void
24652,BLOCK,-1,,"{
      // We couldn't get here, but whatever
      return End();
    }",12,,105,1,,void
24671,BLOCK,-1,,"{
      return End();
    }",53,,113,2,,void
24719,BLOCK,-1,,"{
  // NOTE: In case of anything we're just returning back, ignoring the problem.
  // That's because we're heavily relying on OpenSSL to solve any problem with
  // incoming data.
  switch (type) {
    case kServerName:
      {
        if (len < 2)
          return;
        uint32_t server_names_len = (data[0] << 8) + data[1];
        if (server_names_len + 2 > len)
          return;
        for (size_t offset = 2; offset < 2 + server_names_len; ) {
          if (offset + 3 > len)
            return;
          uint8_t name_type = data[offset];
          if (name_type != kServernameHostname)
            return;
          uint16_t name_len = (data[offset + 1] << 8) + data[offset + 2];
          offset += 3;
          if (offset + name_len > len)
            return;
          servername_ = data + offset;
          servername_size_ = name_len;
          offset += name_len;
        }
      }
      break;
    case kTLSSessionTicket:
      tls_ticket_size_ = len;
      tls_ticket_ = data ...",52,,130,4,,void
24722,BLOCK,-1,,"{
    case kServerName:
      {
        if (len < 2)
          return;
        uint32_t server_names_len = (data[0] << 8) + data[1];
        if (server_names_len + 2 > len)
          return;
        for (size_t offset = 2; offset < 2 + server_names_len; ) {
          if (offset + 3 > len)
            return;
          uint8_t name_type = data[offset];
          if (name_type != kServernameHostname)
            return;
          uint16_t name_len = (data[offset + 1] << 8) + data[offset + 2];
          offset += 3;
          if (offset + name_len > len)
            return;
          servername_ = data + offset;
          servername_size_ = name_len;
          offset += name_len;
        }
      }
      break;
    case kTLSSessionTicket:
      tls_ticket_size_ = len;
      tls_ticket_ = data + len;
      break;
    default:
      // Ignore
      break;
  }",17,,134,2,,void
24725,BLOCK,3,,"{
        if (len < 2)
          return;
        uint32_t server_names_len = (data[0] << 8) + data[1];
        if (server_names_len + 2 > len)
          return;
        for (size_t offset = 2; offset < 2 + server_names_len; ) {
          if (offset + 3 > len)
            return;
          uint8_t name_type = data[offset];
          if (name_type != kServernameHostname)
            return;
          uint16_t name_len = (data[offset + 1] << 8) + data[offset + 2];
          offset += 3;
          if (offset + name_len > len)
            return;
          servername_ = data + offset;
          servername_size_ = name_len;
          offset += name_len;
        }
      }",7,,136,3,,void
24730,BLOCK,-1,,<empty>,11,,138,2,,void
24750,BLOCK,-1,,<empty>,11,,141,2,,void
24753,BLOCK,-1,,<empty>,9,,142,1,,void
24763,BLOCK,4,,"{
          if (offset + 3 > len)
            return;
          uint8_t name_type = data[offset];
          if (name_type != kServernameHostname)
            return;
          uint16_t name_len = (data[offset + 1] << 8) + data[offset + 2];
          offset += 3;
          if (offset + name_len > len)
            return;
          servername_ = data + offset;
          servername_size_ = name_len;
          offset += name_len;
        }",66,,142,4,,void
24770,BLOCK,-1,,<empty>,13,,144,2,,void
24782,BLOCK,-1,,<empty>,13,,147,2,,void
24809,BLOCK,-1,,<empty>,13,,151,2,,void
24841,BLOCK,-1,,"{
  const uint8_t* body;

  // Skip frame header, hello header, protocol version and random data
  size_t session_offset = body_offset_ + 4 + 2 + 32;

  if (session_offset + 1 >= avail)
    return false;

  body = data + session_offset;
  session_size_ = *body;
  session_id_ = body + 1;

  size_t cipher_offset = session_offset + 1 + session_size_;

  // Session OOB failure
  if (cipher_offset + 1 >= avail)
    return false;

  uint16_t cipher_len =
      (data[cipher_offset] << 8) + data[cipher_offset + 1];
  size_t comp_offset = cipher_offset + 2 + cipher_len;

  // Cipher OOB failure
  if (comp_offset >= avail)
    return false;

  uint8_t comp_len = data[comp_offset];
  size_t extension_offset = comp_offset + 1 + comp_len;

  // Compression OOB failure
  if (extension_offset > avail)
    return false;

  // No extensions present
  if (extension_offset == avail)
    return true;

  size_t ext_off = extension_offset + 2;

  // Parse known extensions
  while (ext_off < avail) {
    ...",80,,169,3,,void
24859,BLOCK,-1,,<empty>,5,,176,2,,void
24890,BLOCK,-1,,<empty>,5,,186,2,,void
24919,BLOCK,-1,,<empty>,5,,194,2,,void
24940,BLOCK,-1,,<empty>,5,,201,2,,void
24947,BLOCK,-1,,<empty>,5,,205,2,,void
24960,BLOCK,-1,,"{
    // Extension OOB
    if (ext_off + 4 > avail)
      return false;

    uint16_t ext_type = (data[ext_off] << 8) + data[ext_off + 1];
    uint16_t ext_len = (data[ext_off + 2] << 8) + data[ext_off + 3];
    ext_off += 4;

    // Extension OOB
    if (ext_off + ext_len > avail)
      return false;

    ParseExtension(ext_type,
                   data + ext_off,
                   ext_len);

    ext_off += ext_len;
  }",27,,210,2,,void
24967,BLOCK,-1,,<empty>,7,,213,2,,void
25009,BLOCK,-1,,<empty>,7,,221,2,,void
25025,BLOCK,-1,,<empty>,5,,232,2,,void
25040,BLOCK,-1,,<empty>,1,,1,1,,ANY
25043,BLOCK,-1,,{ OPENSSL_free(value_str); },46,,995,1,,void
25093,BLOCK,-1,,<empty>,1,,1,1,,ANY
25121,BLOCK,-1,,"{
  X509_STORE* store = SSL_CTX_get_cert_store(ctx);
  DeleteFnPtr<X509_STORE_CTX, X509_STORE_CTX_free> store_ctx(
      X509_STORE_CTX_new());
  X509Pointer result;
  X509* issuer;
  if (store_ctx.get() != nullptr &&
      X509_STORE_CTX_init(store_ctx.get(), store, nullptr, nullptr) == 1 &&
      X509_STORE_CTX_get1_issuer(&issuer, store_ctx.get(), cert) == 1) {
    result.reset(issuer);
  }
  return result;
}",58,,54,3,,void
25166,BLOCK,-1,,"{
    result.reset(issuer);
  }",72,,62,2,,void
25181,BLOCK,-1,,"{
  auto keylog_cb = SSL_CTX_get_keylog_callback(SSL_get_SSL_CTX(ssl.get()));
  // All supported versions of TLS/SSL fix the client random to the same size.
  constexpr size_t kTlsClientRandomSize = SSL3_RANDOM_SIZE;
  unsigned char crandom[kTlsClientRandomSize];

  if (keylog_cb == nullptr ||
      SSL_get_client_random(ssl.get(), crandom, kTlsClientRandomSize) !=
          kTlsClientRandomSize) {
    return;
  }

  std::string line = name;
  line += "" "" + StringBytes::hex_encode(reinterpret_cast<const char*>(crandom),
                                        kTlsClientRandomSize);
  line += "" "" + StringBytes::hex_encode(
      reinterpret_cast<const char*>(secret), secretlen);
  keylog_cb(ssl.get(), line.c_str());
}",23,,72,5,,void
25210,BLOCK,-1,,"{
    return;
  }",33,,80,2,,void
25255,BLOCK,-1,,"{
  const unsigned char* resp;
  int len = SSL_get_tlsext_status_ocsp_resp(ssl, &resp);
  if (resp == nullptr)
    return default_value;

  Local<Value> ret;
  MaybeLocal<Object> maybe_buffer =
      Buffer::Copy(env, reinterpret_cast<const char*>(resp), len);

  if (!maybe_buffer.ToLocal(&ret))
    return MaybeLocal<Value>();

  return ret;
}",33,,95,4,,void
25268,BLOCK,-1,,<empty>,5,,99,2,,void
25299,BLOCK,-1,,<empty>,5,,106,2,,void
25309,BLOCK,-1,,"{
  return session != nullptr && SSL_set_session(ssl.get(), session.get()) == 1;
}",39,,113,3,,void
25331,BLOCK,-1,,"{
  return SSLSessionPointer(d2i_SSL_SESSION(nullptr, &buf, length));
}",74,,117,3,,void
25344,BLOCK,-1,,"{  // NOLINT(runtime/int)
  long err = def;  // NOLINT(runtime/int)
  if (X509* peer_cert = SSL_get_peer_certificate(ssl.get())) {
    X509_free(peer_cert);
    err = SSL_get_verify_result(ssl.get());
  } else {
    const SSL_CIPHER* curr_cipher = SSL_get_current_cipher(ssl.get());
    const SSL_SESSION* sess = SSL_get_session(ssl.get());
    // Allow no-cert for PSK authentication in TLS1.2 and lower.
    // In TLS1.3 check that session was reused because TLS1.3 PSK
    // looks like session resumption.
    if (SSL_CIPHER_get_auth_nid(curr_cipher) == NID_auth_psk ||
        (SSL_SESSION_get_protocol_version(sess) == TLS1_3_VERSION &&
         SSL_session_reused(ssl.get()))) {
      return X509_V_OK;
    }
  }
  return err;
}",15,,123,3,,void
25350,BLOCK,-1,,<empty>,7,,125,1,,void
25359,BLOCK,-1,,"{
    X509_free(peer_cert);
    err = SSL_get_verify_result(ssl.get());
  }",62,,125,2,,void
25370,BLOCK,-1,,"{
    const SSL_CIPHER* curr_cipher = SSL_get_current_cipher(ssl.get());
    const SSL_SESSION* sess = SSL_get_session(ssl.get());
    // Allow no-cert for PSK authentication in TLS1.2 and lower.
    // In TLS1.3 check that session was reused because TLS1.3 PSK
    // looks like session resumption.
    if (SSL_CIPHER_get_auth_nid(curr_cipher) == NID_auth_psk ||
        (SSL_SESSION_get_protocol_version(sess) == TLS1_3_VERSION &&
         SSL_session_reused(ssl.get()))) {
      return X509_V_OK;
    }
  }",10,,128,1,,void
25403,BLOCK,-1,,"{
      return X509_V_OK;
    }",42,,136,2,,void
25413,BLOCK,-1,,"{
  SSL_CTX* ctx = context->ctx().get();
  X509* x509 = SSL_CTX_get0_certificate(ctx);
  EVP_PKEY* pkey = SSL_CTX_get0_privatekey(ctx);
  STACK_OF(X509)* chain;

  int err = SSL_CTX_get0_chain_certs(ctx, &chain);
  if (err == 1) err = SSL_use_certificate(ssl.get(), x509);
  if (err == 1) err = SSL_use_PrivateKey(ssl.get(), pkey);
  if (err == 1 && chain != nullptr) err = SSL_set1_chain(ssl.get(), chain);
  return err == 1;
}",66,,144,3,,void
25449,BLOCK,-1,,<empty>,17,,151,2,,void
25462,BLOCK,-1,,<empty>,17,,152,2,,void
25479,BLOCK,-1,,<empty>,37,,153,2,,void
25496,BLOCK,-1,,"{
  const unsigned char* buf;
  size_t len;
  size_t rem;

  if (!SSL_client_hello_get0_ext(
          ssl.get(),
          TLSEXT_TYPE_application_layer_protocol_negotiation,
          &buf,
          &rem) ||
      rem < 2) {
    return nullptr;
  }

  len = (buf[0] << 8) | buf[1];
  if (len + 2 != rem) return nullptr;
  return reinterpret_cast<const char*>(buf + 3);
}",55,,157,2,,void
25516,BLOCK,-1,,"{
    return nullptr;
  }",16,,167,2,,void
25536,BLOCK,-1,,<empty>,23,,172,2,,void
25549,BLOCK,-1,,"{
  const unsigned char* buf;
  size_t len;
  size_t rem;

  if (!SSL_client_hello_get0_ext(
          ssl.get(),
          TLSEXT_TYPE_server_name,
          &buf,
          &rem) || rem <= 2) {
    return nullptr;
  }

  len = (*buf << 8) | *(buf + 1);
  if (len + 2 != rem)
    return nullptr;
  rem = len;

  if (rem == 0 || *(buf + 2) != TLSEXT_NAMETYPE_host_name) return nullptr;
  rem--;
  if (rem <= 2)
    return nullptr;
  len = (*(buf + 3) << 8) | *(buf + 4);
  if (len + 2 > rem)
    return nullptr;
  return reinterpret_cast<const char*>(buf + 5);
}",61,,176,2,,void
25569,BLOCK,-1,,"{
    return nullptr;
  }",30,,185,2,,void
25589,BLOCK,-1,,<empty>,5,,191,2,,void
25606,BLOCK,-1,,<empty>,60,,194,2,,void
25615,BLOCK,-1,,<empty>,5,,197,2,,void
25637,BLOCK,-1,,<empty>,5,,200,2,,void
25650,BLOCK,-1,,"{
  return SSL_get_servername(ssl, TLSEXT_NAMETYPE_host_name);
}",37,,204,2,,void
25660,BLOCK,-1,,"{
  return SSL_CTX_set1_groups_list(sc->ctx().get(), groups) == 1;
}",55,,208,3,,void
25677,BLOCK,-1,,"{  // NOLINT(runtime/int)
  const char* code = ""UNSPECIFIED"";
#define CASE_X509_ERR(CODE) case X509_V_ERR_##CODE: code = #CODE; break;
  switch (err) {
    // if you modify anything in here, *please* update the respective section in
    // doc/api/tls.md as well
    CASE_X509_ERR(UNABLE_TO_GET_ISSUER_CERT)
    CASE_X509_ERR(UNABLE_TO_GET_CRL)
    CASE_X509_ERR(UNABLE_TO_DECRYPT_CERT_SIGNATURE)
    CASE_X509_ERR(UNABLE_TO_DECRYPT_CRL_SIGNATURE)
    CASE_X509_ERR(UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY)
    CASE_X509_ERR(CERT_SIGNATURE_FAILURE)
    CASE_X509_ERR(CRL_SIGNATURE_FAILURE)
    CASE_X509_ERR(CERT_NOT_YET_VALID)
    CASE_X509_ERR(CERT_HAS_EXPIRED)
    CASE_X509_ERR(CRL_NOT_YET_VALID)
    CASE_X509_ERR(CRL_HAS_EXPIRED)
    CASE_X509_ERR(ERROR_IN_CERT_NOT_BEFORE_FIELD)
    CASE_X509_ERR(ERROR_IN_CERT_NOT_AFTER_FIELD)
    CASE_X509_ERR(ERROR_IN_CRL_LAST_UPDATE_FIELD)
    CASE_X509_ERR(ERROR_IN_CRL_NEXT_UPDATE_FIELD)
    CASE_X509_ERR(OUT_OF_MEM)
    CASE_X509_ERR(DEPTH_ZERO_SELF_SIG...",37,,212,2,,void
25684,BLOCK,-1,,"{
    // if you modify anything in here, *please* update the respective section in
    // doc/api/tls.md as well
    CASE_X509_ERR(UNABLE_TO_GET_ISSUER_CERT)
    CASE_X509_ERR(UNABLE_TO_GET_CRL)
    CASE_X509_ERR(UNABLE_TO_DECRYPT_CERT_SIGNATURE)
    CASE_X509_ERR(UNABLE_TO_DECRYPT_CRL_SIGNATURE)
    CASE_X509_ERR(UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY)
    CASE_X509_ERR(CERT_SIGNATURE_FAILURE)
    CASE_X509_ERR(CRL_SIGNATURE_FAILURE)
    CASE_X509_ERR(CERT_NOT_YET_VALID)
    CASE_X509_ERR(CERT_HAS_EXPIRED)
    CASE_X509_ERR(CRL_NOT_YET_VALID)
    CASE_X509_ERR(CRL_HAS_EXPIRED)
    CASE_X509_ERR(ERROR_IN_CERT_NOT_BEFORE_FIELD)
    CASE_X509_ERR(ERROR_IN_CERT_NOT_AFTER_FIELD)
    CASE_X509_ERR(ERROR_IN_CRL_LAST_UPDATE_FIELD)
    CASE_X509_ERR(ERROR_IN_CRL_NEXT_UPDATE_FIELD)
    CASE_X509_ERR(OUT_OF_MEM)
    CASE_X509_ERR(DEPTH_ZERO_SELF_SIGNED_CERT)
    CASE_X509_ERR(SELF_SIGNED_CERT_IN_CHAIN)
    CASE_X509_ERR(UNABLE_TO_GET_ISSUER_CERT_LOCALLY)
    CASE_X509_ERR(UNABLE_TO_VERIFY_LEAF_SI...",16,,215,2,,void
25686,BLOCK,1,,<empty>,,,,1,,void
25694,BLOCK,1,,<empty>,,,,1,,void
25702,BLOCK,1,,<empty>,,,,1,,void
25710,BLOCK,1,,<empty>,,,,1,,void
25718,BLOCK,1,,<empty>,,,,1,,void
25726,BLOCK,1,,<empty>,,,,1,,void
25734,BLOCK,1,,<empty>,,,,1,,void
25742,BLOCK,1,,<empty>,,,,1,,void
25750,BLOCK,1,,<empty>,,,,1,,void
25758,BLOCK,1,,<empty>,,,,1,,void
25766,BLOCK,1,,<empty>,,,,1,,void
25774,BLOCK,1,,<empty>,,,,1,,void
25782,BLOCK,1,,<empty>,,,,1,,void
25790,BLOCK,1,,<empty>,,,,1,,void
25798,BLOCK,1,,<empty>,,,,1,,void
25806,BLOCK,1,,<empty>,,,,1,,void
25814,BLOCK,1,,<empty>,,,,1,,void
25822,BLOCK,1,,<empty>,,,,1,,void
25830,BLOCK,1,,<empty>,,,,1,,void
25838,BLOCK,1,,<empty>,,,,1,,void
25846,BLOCK,1,,<empty>,,,,1,,void
25854,BLOCK,1,,<empty>,,,,1,,void
25862,BLOCK,1,,<empty>,,,,1,,void
25870,BLOCK,1,,<empty>,,,,1,,void
25878,BLOCK,1,,<empty>,,,,1,,void
25886,BLOCK,1,,<empty>,,,,1,,void
25894,BLOCK,1,,<empty>,,,,1,,void
25902,BLOCK,1,,<empty>,,,,1,,void
25916,BLOCK,-1,,"{
  if (err == 0)
    return Undefined(env->isolate());
  const char* reason = X509_verify_cert_error_string(err);
  return OneByteString(env->isolate(), reason);
}",71,,251,3,,void
25921,BLOCK,-1,,<empty>,5,,253,2,,void
25945,BLOCK,-1,,"{
  if (err == 0)
    return Undefined(env->isolate());
  return OneByteString(env->isolate(), X509ErrorCode(err));
}",69,,258,3,,void
25950,BLOCK,-1,,<empty>,5,,260,2,,void
25970,BLOCK,-1,,"{
  ClearErrorOnReturn clear_error_on_return;
  X509* cert = SSL_get_certificate(ssl.get());
  if (cert == nullptr)
    return Undefined(env->isolate());

  MaybeLocal<Object> maybe_cert = X509ToObject(env, cert);
  return maybe_cert.FromMaybe<Value>(Local<Value>());
}",68,,264,3,,void
25984,BLOCK,-1,,<empty>,5,,268,2,,void
26013,BLOCK,-1,,"{
  BUF_MEM* mem;
  BIO_get_mem_ptr(bio.get(), &mem);
  MaybeLocal<String> ret =
      String::NewFromUtf8(
          env->isolate(),
          mem->data,
          NewStringType::kNormal,
          mem->length);
  CHECK_EQ(BIO_reset(bio.get()), 1);
  return ret.FromMaybe(Local<Value>());
}",65,,274,3,,void
26066,BLOCK,-1,,"{
  Local<Value> value;
  if (!maybe_value.ToLocal(&value))
    return false;

  // Undefined is ignored, but still considered successful
  if (value->IsUndefined())
    return true;

  return !target->Set(context, name, value).IsNothing();
}",32,,293,5,,void
26080,BLOCK,-1,,<empty>,5,,296,2,,void
26088,BLOCK,-1,,<empty>,5,,300,2,,void
26108,BLOCK,-1,,"{
  if (cipher == nullptr)
    return Undefined(env->isolate());

  return OneByteString(env->isolate(), getstr(cipher));
}",78,,306,3,,void
26113,BLOCK,-1,,<empty>,5,,308,2,,void
26148,BLOCK,-1,,"{
  Local<Context> context = env->isolate()->GetCurrentContext();
  cert->reset(sk_X509_delete(peer_certs.get(), 0));
  for (;;) {
    int i;
    for (i = 0; i < sk_X509_num(peer_certs.get()); i++) {
      X509* ca = sk_X509_value(peer_certs.get(), i);
      if (X509_check_issued(ca, cert->get()) != X509_V_OK)
        continue;

      Local<Object> ca_info;
      MaybeLocal<Object> maybe_ca_info = X509ToObject(env, ca);
      if (!maybe_ca_info.ToLocal(&ca_info))
        return MaybeLocal<Object>();

      if (!Set<Object>(context, object, env->issuercert_string(), ca_info))
        return MaybeLocal<Object>();
      object = ca_info;

      // NOTE: Intentionally freeing cert that is not used anymore.
      // Delete cert and continue aggregating issuers.
      cert->reset(sk_X509_delete(peer_certs.get(), i));
      break;
    }

    // Issuer not found, break out of the loop.
    if (i == sk_X509_num(peer_certs.get()))
      break;
  }
  return MaybeLocal<Object>(object);
}",29,,337,5,,void
26173,BLOCK,-1,,<empty>,3,,340,1,,void
26174,BLOCK,4,,"{
    int i;
    for (i = 0; i < sk_X509_num(peer_certs.get()); i++) {
      X509* ca = sk_X509_value(peer_certs.get(), i);
      if (X509_check_issued(ca, cert->get()) != X509_V_OK)
        continue;

      Local<Object> ca_info;
      MaybeLocal<Object> maybe_ca_info = X509ToObject(env, ca);
      if (!maybe_ca_info.ToLocal(&ca_info))
        return MaybeLocal<Object>();

      if (!Set<Object>(context, object, env->issuercert_string(), ca_info))
        return MaybeLocal<Object>();
      object = ca_info;

      // NOTE: Intentionally freeing cert that is not used anymore.
      // Delete cert and continue aggregating issuers.
      cert->reset(sk_X509_delete(peer_certs.get(), i));
      break;
    }

    // Issuer not found, break out of the loop.
    if (i == sk_X509_num(peer_certs.get()))
      break;
  }",12,,340,4,,void
26177,BLOCK,-1,,<empty>,5,,342,1,,void
26190,BLOCK,4,,"{
      X509* ca = sk_X509_value(peer_certs.get(), i);
      if (X509_check_issued(ca, cert->get()) != X509_V_OK)
        continue;

      Local<Object> ca_info;
      MaybeLocal<Object> maybe_ca_info = X509ToObject(env, ca);
      if (!maybe_ca_info.ToLocal(&ca_info))
        return MaybeLocal<Object>();

      if (!Set<Object>(context, object, env->issuercert_string(), ca_info))
        return MaybeLocal<Object>();
      object = ca_info;

      // NOTE: Intentionally freeing cert that is not used anymore.
      // Delete cert and continue aggregating issuers.
      cert->reset(sk_X509_delete(peer_certs.get(), i));
      break;
    }",57,,342,4,,void
26209,BLOCK,-1,,<empty>,9,,345,2,,void
26233,BLOCK,-1,,<empty>,9,,350,2,,void
26246,BLOCK,-1,,<empty>,9,,353,2,,void
26271,BLOCK,-1,,<empty>,7,,364,2,,void
26286,BLOCK,-1,,"{
  Local<Context> context = env->isolate()->GetCurrentContext();
  while (X509_check_issued(cert->get(), cert->get()) != X509_V_OK) {
    X509Pointer ca;
    if (!(ca = SSL_CTX_get_issuer(SSL_get_SSL_CTX(ssl.get()), cert->get())))
      break;

    Local<Object> ca_info;
    MaybeLocal<Object> maybe_ca_info = X509ToObject(env, ca.get());
    if (!maybe_ca_info.ToLocal(&ca_info))
      return MaybeLocal<Object>();

    if (!Set<Object>(context, issuer_chain, env->issuercert_string(), ca_info))
      return MaybeLocal<Object>();
    issuer_chain = ca_info;

    // For self-signed certificates whose keyUsage field does not include
    // keyCertSign, X509_check_issued() will return false. Avoid going into an
    // infinite loop by checking if SSL_CTX_get_issuer() returned the same
    // certificate.
    if (cert->get() == ca.get()) break;

    // Delete previous cert and continue aggregating issuers.
    *cert = std::move(ca);
  }
  return MaybeLocal<Object>(issuer_chain);
}",29,,373,5,,void
26312,BLOCK,-1,,"{
    X509Pointer ca;
    if (!(ca = SSL_CTX_get_issuer(SSL_get_SSL_CTX(ssl.get()), cert->get())))
      break;

    Local<Object> ca_info;
    MaybeLocal<Object> maybe_ca_info = X509ToObject(env, ca.get());
    if (!maybe_ca_info.ToLocal(&ca_info))
      return MaybeLocal<Object>();

    if (!Set<Object>(context, issuer_chain, env->issuercert_string(), ca_info))
      return MaybeLocal<Object>();
    issuer_chain = ca_info;

    // For self-signed certificates whose keyUsage field does not include
    // keyCertSign, X509_check_issued() will return false. Avoid going into an
    // infinite loop by checking if SSL_CTX_get_issuer() returned the same
    // certificate.
    if (cert->get() == ca.get()) break;

    // Delete previous cert and continue aggregating issuers.
    *cert = std::move(ca);
  }",68,,375,2,,void
26328,BLOCK,-1,,<empty>,7,,378,2,,void
26355,BLOCK,-1,,<empty>,7,,383,2,,void
26368,BLOCK,-1,,<empty>,7,,386,2,,void
26384,BLOCK,-1,,<empty>,34,,393,2,,void
26406,BLOCK,-1,,"{
  unsigned int i;
  const char hex[] = ""0123456789ABCDEF"";

  for (i = 0; i < md_size; i++) {
    fingerprint[3*i] = hex[(md[i] & 0xf0) >> 4];
    fingerprint[(3*i)+1] = hex[(md[i] & 0x0f)];
    fingerprint[(3*i)+2] = ':';
  }

  DCHECK_GT(md_size, 0);
  fingerprint[(3 * (md_size - 1)) + 2] = '\0';
}",44,,404,4,,void
26413,BLOCK,-1,,<empty>,3,,408,1,,void
26422,BLOCK,4,,"{
    fingerprint[3*i] = hex[(md[i] & 0xf0) >> 4];
    fingerprint[(3*i)+1] = hex[(md[i] & 0x0f)];
    fingerprint[(3*i)+2] = ':';
  }",33,,408,4,,void
26481,BLOCK,-1,,"{
  const char* name = nid2string(nid);
  return name != nullptr ?
      MaybeLocal<Value>(OneByteString(env->isolate(), name)) :
      MaybeLocal<Value>(Undefined(env->isolate()));
}",65,,419,3,,void
26517,BLOCK,-1,,"{
  const EC_POINT* pubkey = EC_KEY_get0_public_key(ec.get());
  if (pubkey == nullptr)
    return Undefined(env->isolate());

  return ECPointToBuffer(
      env,
      group,
      pubkey,
      EC_KEY_get_conv_form(ec.get()),
      nullptr).FromMaybe(Local<Object>());
}",26,,429,4,,void
26530,BLOCK,-1,,<empty>,5,,432,2,,void
26558,BLOCK,-1,,"{
  if (group == nullptr)
    return Undefined(env->isolate());

  int bits = EC_GROUP_order_bits(group);
  if (bits <= 0)
    return Undefined(env->isolate());

  return Integer::New(env->isolate(), bits);
}",26,,445,4,,void
26563,BLOCK,-1,,<empty>,5,,447,2,,void
26579,BLOCK,-1,,<empty>,5,,451,2,,void
26601,BLOCK,-1,,"{
  int size = i2d_RSA_PUBKEY(rsa.get(), nullptr);
  CHECK_GE(size, 0);

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), size);
  }

  unsigned char* serialized = reinterpret_cast<unsigned char*>(bs->Data());
  CHECK_GE(i2d_RSA_PUBKEY(rsa.get(), &serialized), 0);

  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
  return Buffer::New(env, ab, 0, ab->ByteLength()).FromMaybe(Local<Object>());
}",71,,456,3,,void
26621,BLOCK,5,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), size);
  }",3,,461,5,,void
26698,BLOCK,-1,,"{
  uint64_t exponent_word = static_cast<uint64_t>(BN_get_word(e));
  BIO_printf(bio.get(), ""0x%"" PRIx64, exponent_word);
  return ToV8Value(env, bio);
}",22,,476,4,,void
26716,BLOCK,-1,,"{
  return Integer::New(env->isolate(), BN_num_bits(n));
}",57,,482,3,,void
26734,BLOCK,-1,,"{
  BN_print(bio.get(), n);
  return ToV8Value(env, bio);
}",22,,489,4,,void
26750,BLOCK,-1,,"{
  int size = i2d_X509(cert, nullptr);

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), size);
  }

  unsigned char* serialized = reinterpret_cast<unsigned char*>(bs->Data());
  CHECK_GE(i2d_X509(cert, &serialized), 0);

  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
  return Buffer::New(env, ab, 0, ab->ByteLength()).FromMaybe(Local<Object>());
}",70,,495,3,,void
26764,BLOCK,4,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), size);
  }",3,,499,4,,void
26837,BLOCK,-1,,"{
  if (ASN1_INTEGER* serial_number = X509_get_serialNumber(cert)) {
    BignumPointer bn(ASN1_INTEGER_to_BN(serial_number, nullptr));
    if (bn) {
      char* data = BN_bn2hex(bn.get());
      ByteSource buf = ByteSource::Allocated(data, strlen(data));
      if (buf) return OneByteString(env->isolate(), buf.data<unsigned char>());
    }
  }

  return Undefined(env->isolate());
}",65,,511,3,,void
26839,BLOCK,-1,,<empty>,7,,512,1,,void
26845,BLOCK,-1,,"{
    BignumPointer bn(ASN1_INTEGER_to_BN(serial_number, nullptr));
    if (bn) {
      char* data = BN_bn2hex(bn.get());
      ByteSource buf = ByteSource::Allocated(data, strlen(data));
      if (buf) return OneByteString(env->isolate(), buf.data<unsigned char>());
    }
  }",66,,512,2,,void
26853,BLOCK,-1,,"{
      char* data = BN_bn2hex(bn.get());
      ByteSource buf = ByteSource::Allocated(data, strlen(data));
      if (buf) return OneByteString(env->isolate(), buf.data<unsigned char>());
    }",13,,514,2,,void
26874,BLOCK,-1,,<empty>,16,,517,2,,void
26896,BLOCK,-1,,"{
  StackOfASN1 eku(static_cast<STACK_OF(ASN1_OBJECT)*>(
      X509_get_ext_d2i(cert, NID_ext_key_usage, nullptr, nullptr)));
  if (eku) {
    const int count = sk_ASN1_OBJECT_num(eku.get());
    MaybeStackBuffer<Local<Value>, 16> ext_key_usage(count);
    char buf[256];

    int j = 0;
    for (int i = 0; i < count; i++) {
      if (OBJ_obj2txt(buf,
                      sizeof(buf),
                      sk_ASN1_OBJECT_value(eku.get(), i), 1) >= 0) {
        ext_key_usage[j++] = OneByteString(env->isolate(), buf);
      }
    }

    return Array::New(env->isolate(), ext_key_usage.out(), count);
  }

  return Undefined(env->isolate());
}",61,,524,3,,void
26902,BLOCK,-1,,"{
    const int count = sk_ASN1_OBJECT_num(eku.get());
    MaybeStackBuffer<Local<Value>, 16> ext_key_usage(count);
    char buf[256];

    int j = 0;
    for (int i = 0; i < count; i++) {
      if (OBJ_obj2txt(buf,
                      sizeof(buf),
                      sk_ASN1_OBJECT_value(eku.get(), i), 1) >= 0) {
        ext_key_usage[j++] = OneByteString(env->isolate(), buf);
      }
    }

    return Array::New(env->isolate(), ext_key_usage.out(), count);
  }",12,,527,2,,void
26920,BLOCK,-1,,<empty>,5,,533,1,,void
26930,BLOCK,4,,"{
      if (OBJ_obj2txt(buf,
                      sizeof(buf),
                      sk_ASN1_OBJECT_value(eku.get(), i), 1) >= 0) {
        ext_key_usage[j++] = OneByteString(env->isolate(), buf);
      }
    }",37,,533,4,,void
26945,BLOCK,-1,,"{
        ext_key_usage[j++] = OneByteString(env->isolate(), buf);
      }",68,,536,2,,void
26982,BLOCK,-1,,"{
  return GetCipherName(env, SSL_get_current_cipher(ssl.get()));
}",63,,548,3,,void
26996,BLOCK,-1,,"{
  return GetCipherVersion(env, SSL_get_current_cipher(ssl.get()));
}",66,,553,3,,void
27011,BLOCK,-1,,"{
  unsigned char md[EVP_MAX_MD_SIZE];
  unsigned int md_size;
  char fingerprint[EVP_MAX_MD_SIZE * 3];

  if (X509_digest(cert, method, md, &md_size)) {
    AddFingerprintDigest(md, md_size, fingerprint);
    return OneByteString(env->isolate(), fingerprint);
  }
  return Undefined(env->isolate());
}",17,,560,4,,void
27022,BLOCK,-1,,"{
    AddFingerprintDigest(md, md_size, fingerprint);
    return OneByteString(env->isolate(), fingerprint);
  }",48,,565,2,,void
27046,BLOCK,-1,,"{
  ASN1_TIME_print(bio.get(), X509_get0_notAfter(cert));
  return ToV8Value(env, bio);
}",28,,575,4,,void
27064,BLOCK,-1,,"{
  ASN1_TIME_print(bio.get(), X509_get0_notBefore(cert));
  return ToV8Value(env, bio);
}",28,,583,4,,void
27082,BLOCK,-1,,"{
  for (size_t i = 0; i < length; i++) {
    char c = name[i];
    switch (c) {
    case '""':
    case '\\':
      // These mess with encoding rules.
      // Fall through.
    case ',':
      // Commas make it impossible to split the list of subject alternative
      // names unambiguously, which is why we have to escape.
      // Fall through.
    case '\'':
      // Single quotes are unlikely to appear in any legitimate values, but they
      // could be used to make a value look like it was escaped (i.e., enclosed
      // in single/double quotes).
      return false;
    default:
      if (utf8) {
        // In UTF8 strings, we require escaping for any ASCII control character,
        // but NOT for non-ASCII characters. Note that all bytes of any code
        // point that consists of more than a single byte have their MSB set.
        if (static_cast<unsigned char>(c) < ' ' || c == '\x7f') {
          return false;
        }
      } else {
        // Check if the char is a c...",78,,588,4,,void
27084,BLOCK,-1,,<empty>,3,,589,1,,void
27094,BLOCK,4,,"{
    char c = name[i];
    switch (c) {
    case '""':
    case '\\':
      // These mess with encoding rules.
      // Fall through.
    case ',':
      // Commas make it impossible to split the list of subject alternative
      // names unambiguously, which is why we have to escape.
      // Fall through.
    case '\'':
      // Single quotes are unlikely to appear in any legitimate values, but they
      // could be used to make a value look like it was escaped (i.e., enclosed
      // in single/double quotes).
      return false;
    default:
      if (utf8) {
        // In UTF8 strings, we require escaping for any ASCII control character,
        // but NOT for non-ASCII characters. Note that all bytes of any code
        // point that consists of more than a single byte have their MSB set.
        if (static_cast<unsigned char>(c) < ' ' || c == '\x7f') {
          return false;
        }
      } else {
        // Check if the char is a control character or non-ASCII character....",39,,589,4,,void
27103,BLOCK,-1,,"{
    case '""':
    case '\\':
      // These mess with encoding rules.
      // Fall through.
    case ',':
      // Commas make it impossible to split the list of subject alternative
      // names unambiguously, which is why we have to escape.
      // Fall through.
    case '\'':
      // Single quotes are unlikely to appear in any legitimate values, but they
      // could be used to make a value look like it was escaped (i.e., enclosed
      // in single/double quotes).
      return false;
    default:
      if (utf8) {
        // In UTF8 strings, we require escaping for any ASCII control character,
        // but NOT for non-ASCII characters. Note that all bytes of any code
        // point that consists of more than a single byte have their MSB set.
        if (static_cast<unsigned char>(c) < ' ' || c == '\x7f') {
          return false;
        }
      } else {
        // Check if the char is a control character or non-ASCII character. Note
        // that char may or may n...",16,,591,2,,void
27117,BLOCK,-1,,"{
        // In UTF8 strings, we require escaping for any ASCII control character,
        // but NOT for non-ASCII characters. Note that all bytes of any code
        // point that consists of more than a single byte have their MSB set.
        if (static_cast<unsigned char>(c) < ' ' || c == '\x7f') {
          return false;
        }
      }",17,,606,2,,void
27128,BLOCK,-1,,"{
          return false;
        }",65,,610,2,,void
27132,BLOCK,-1,,"{
        // Check if the char is a control character or non-ASCII character. Note
        // that char may or may not be a signed type. Regardless, non-ASCII
        // values will always be outside of this range.
        if (c < ' ' || c > '~') {
          return false;
        }
      }",14,,613,1,,void
27141,BLOCK,-1,,"{
          return false;
        }",33,,617,2,,void
27154,BLOCK,-1,,"{
  if (IsSafeAltName(name, length, utf8)) {
    // For backward-compatibility, append ""safe"" names without any
    // modifications.
    if (safe_prefix != nullptr) {
      BIO_printf(out.get(), ""%s:"", safe_prefix);
    }
    BIO_write(out.get(), name, length);
  } else {
    // If a name is not ""safe"", we cannot embed it without special
    // encoding. This does not usually happen, but we don't want to hide
    // it from the user either. We use JSON compatible escaping here.
    BIO_write(out.get(), ""\"""", 1);
    if (safe_prefix != nullptr) {
      BIO_printf(out.get(), ""%s:"", safe_prefix);
    }
    for (size_t j = 0; j < length; j++) {
      char c = static_cast<char>(name[j]);
      if (c == '\\') {
        BIO_write(out.get(), ""\\\\"", 2);
      } else if (c == '""') {
        BIO_write(out.get(), ""\\\"""", 2);
      } else if ((c >= ' ' && c != ',' && c <= '~') || (utf8 && (c & 0x80))) {
        // Note that the above condition explicitly excludes commas, which means
        //...",58,,628,6,,void
27160,BLOCK,-1,,"{
    // For backward-compatibility, append ""safe"" names without any
    // modifications.
    if (safe_prefix != nullptr) {
      BIO_printf(out.get(), ""%s:"", safe_prefix);
    }
    BIO_write(out.get(), name, length);
  }",42,,629,2,,void
27165,BLOCK,-1,,"{
      BIO_printf(out.get(), ""%s:"", safe_prefix);
    }",33,,632,2,,void
27181,BLOCK,-1,,"{
    // If a name is not ""safe"", we cannot embed it without special
    // encoding. This does not usually happen, but we don't want to hide
    // it from the user either. We use JSON compatible escaping here.
    BIO_write(out.get(), ""\"""", 1);
    if (safe_prefix != nullptr) {
      BIO_printf(out.get(), ""%s:"", safe_prefix);
    }
    for (size_t j = 0; j < length; j++) {
      char c = static_cast<char>(name[j]);
      if (c == '\\') {
        BIO_write(out.get(), ""\\\\"", 2);
      } else if (c == '""') {
        BIO_write(out.get(), ""\\\"""", 2);
      } else if ((c >= ' ' && c != ',' && c <= '~') || (utf8 && (c & 0x80))) {
        // Note that the above condition explicitly excludes commas, which means
        // that those are encoded as Unicode escape sequences in the ""else""
        // block. That is not strictly necessary, and Node.js itself would parse
        // it correctly either way. We only do this to account for third-party
        // code that might be splitting the st...",10,,636,1,,void
27193,BLOCK,-1,,"{
      BIO_printf(out.get(), ""%s:"", safe_prefix);
    }",33,,641,2,,void
27202,BLOCK,-1,,<empty>,5,,644,1,,void
27212,BLOCK,4,,"{
      char c = static_cast<char>(name[j]);
      if (c == '\\') {
        BIO_write(out.get(), ""\\\\"", 2);
      } else if (c == '""') {
        BIO_write(out.get(), ""\\\"""", 2);
      } else if ((c >= ' ' && c != ',' && c <= '~') || (utf8 && (c & 0x80))) {
        // Note that the above condition explicitly excludes commas, which means
        // that those are encoded as Unicode escape sequences in the ""else""
        // block. That is not strictly necessary, and Node.js itself would parse
        // it correctly either way. We only do this to account for third-party
        // code that might be splitting the string at commas (as Node.js itself
        // used to do).
        BIO_write(out.get(), &c, 1);
      } else {
        // Control character or non-ASCII character. We treat everything as
        // Latin-1, which corresponds to the first 255 Unicode code points.
        const char hex[] = ""0123456789abcdef"";
        char u[] = { '\\', 'u', '0', '0', hex[(c & 0xf0) >> 4], hex...",41,,644,4,,void
27225,BLOCK,-1,,"{
        BIO_write(out.get(), ""\\\\"", 2);
      }",22,,646,2,,void
27234,BLOCK,-1,,<empty>,14,,648,1,,void
27239,BLOCK,-1,,"{
        BIO_write(out.get(), ""\\\"""", 2);
      }",28,,648,2,,void
27248,BLOCK,-1,,<empty>,14,,650,1,,void
27267,BLOCK,-1,,"{
        // Note that the above condition explicitly excludes commas, which means
        // that those are encoded as Unicode escape sequences in the ""else""
        // block. That is not strictly necessary, and Node.js itself would parse
        // it correctly either way. We only do this to account for third-party
        // code that might be splitting the string at commas (as Node.js itself
        // used to do).
        BIO_write(out.get(), &c, 1);
      }",78,,650,2,,void
27277,BLOCK,-1,,"{
        // Control character or non-ASCII character. We treat everything as
        // Latin-1, which corresponds to the first 255 Unicode code points.
        const char hex[] = ""0123456789abcdef"";
        char u[] = { '\\', 'u', '0', '0', hex[(c & 0xf0) >> 4], hex[c & 0x0f] };
        BIO_write(out.get(), u, sizeof(u));
      }",14,,658,1,,void
27323,BLOCK,-1,,"{
  PrintAltName(out, reinterpret_cast<const char*>(name->data), name->length,
               false, safe_prefix);
}",74,,672,4,,void
27342,BLOCK,-1,,"{
  PrintAltName(out, reinterpret_cast<const char*>(name->data), name->length,
               true, safe_prefix);
}",72,,679,4,,void
27360,BLOCK,-1,,"{
  if (gen->type == GEN_DNS) {
    ASN1_IA5STRING* name = gen->d.dNSName;
    BIO_write(out.get(), ""DNS:"", 4);
    // Note that the preferred name syntax (see RFCs 5280 and 1034) with
    // wildcards is a subset of what we consider ""safe"", so spec-compliant DNS
    // names will never need to be escaped.
    PrintLatin1AltName(out, name);
  } else if (gen->type == GEN_EMAIL) {
    ASN1_IA5STRING* name = gen->d.rfc822Name;
    BIO_write(out.get(), ""email:"", 6);
    PrintLatin1AltName(out, name);
  } else if (gen->type == GEN_URI) {
    ASN1_IA5STRING* name = gen->d.uniformResourceIdentifier;
    BIO_write(out.get(), ""URI:"", 4);
    // The set of ""safe"" names was designed to include just about any URI,
    // with a few exceptions, most notably URIs that contains commas (see
    // RFC 2396). In other words, most legitimate URIs will not require
    // escaping.
    PrintLatin1AltName(out, name);
  } else if (gen->type == GEN_DIRNAME) {
    // Earlier versions of Node.js used X509_N...",78,,686,3,,void
27367,BLOCK,-1,,"{
    ASN1_IA5STRING* name = gen->d.dNSName;
    BIO_write(out.get(), ""DNS:"", 4);
    // Note that the preferred name syntax (see RFCs 5280 and 1034) with
    // wildcards is a subset of what we consider ""safe"", so spec-compliant DNS
    // names will never need to be escaped.
    PrintLatin1AltName(out, name);
  }",29,,687,2,,void
27387,BLOCK,-1,,<empty>,10,,694,1,,void
27394,BLOCK,-1,,"{
    ASN1_IA5STRING* name = gen->d.rfc822Name;
    BIO_write(out.get(), ""email:"", 6);
    PrintLatin1AltName(out, name);
  }",38,,694,2,,void
27414,BLOCK,-1,,<empty>,10,,698,1,,void
27421,BLOCK,-1,,"{
    ASN1_IA5STRING* name = gen->d.uniformResourceIdentifier;
    BIO_write(out.get(), ""URI:"", 4);
    // The set of ""safe"" names was designed to include just about any URI,
    // with a few exceptions, most notably URIs that contains commas (see
    // RFC 2396). In other words, most legitimate URIs will not require
    // escaping.
    PrintLatin1AltName(out, name);
  }",36,,698,2,,void
27441,BLOCK,-1,,<empty>,10,,706,1,,void
27448,BLOCK,-1,,"{
    // Earlier versions of Node.js used X509_NAME_oneline to print the X509_NAME
    // object. The format was non standard and should be avoided. The use of
    // X509_NAME_oneline is discouraged by OpenSSL but was required for backward
    // compatibility. Conveniently, X509_NAME_oneline produced ASCII and the
    // output was unlikely to contains commas or other characters that would
    // require escaping. However, it SHOULD NOT produce ASCII output since an
    // RFC5280 AttributeValue may be a UTF8String.
    // Newer versions of Node.js have since switched to X509_NAME_print_ex to
    // produce a better format at the cost of backward compatibility. The new
    // format may contain Unicode characters and it is likely to contain commas,
    // which require escaping. Fortunately, the recently safeguarded function
    // PrintAltName handles all of that safely.
    BIO_printf(out.get(), ""DirName:"");
    BIOPointer tmp(BIO_new(BIO_s_mem()));
    CHECK(tmp);
    if (X509_...",40,,706,2,,void
27457,BLOCK,-1,,<empty>,,,,2,,<empty>
27477,BLOCK,-1,,"{
      return false;
    }",70,,725,2,,void
27513,BLOCK,-1,,<empty>,10,,733,1,,void
27520,BLOCK,-1,,"{
    BIO_printf(out.get(), ""IP Address:"");
    const ASN1_OCTET_STRING* ip = gen->d.ip;
    const unsigned char* b = ip->data;
    if (ip->length == 4) {
      BIO_printf(out.get(), ""%d.%d.%d.%d"", b[0], b[1], b[2], b[3]);
    } else if (ip->length == 16) {
      for (unsigned int j = 0; j < 8; j++) {
        uint16_t pair = (b[2 * j] << 8) | b[2 * j + 1];
        BIO_printf(out.get(), (j == 0) ? ""%X"" : "":%X"", pair);
      }
    } else {
#if OPENSSL_VERSION_MAJOR >= 3
      BIO_printf(out.get(), ""<invalid length=%d>"", ip->length);
#else
      BIO_printf(out.get(), ""<invalid>"");
#endif
    }
  }",38,,733,2,,void
27547,BLOCK,-1,,"{
      BIO_printf(out.get(), ""%d.%d.%d.%d"", b[0], b[1], b[2], b[3]);
    }",26,,737,2,,void
27567,BLOCK,-1,,<empty>,12,,739,1,,void
27574,BLOCK,-1,,"{
      for (unsigned int j = 0; j < 8; j++) {
        uint16_t pair = (b[2 * j] << 8) | b[2 * j + 1];
        BIO_printf(out.get(), (j == 0) ? ""%X"" : "":%X"", pair);
      }
    }",34,,739,2,,void
27576,BLOCK,-1,,<empty>,7,,740,1,,void
27586,BLOCK,4,,"{
        uint16_t pair = (b[2 * j] << 8) | b[2 * j + 1];
        BIO_printf(out.get(), (j == 0) ? ""%X"" : "":%X"", pair);
      }",44,,740,4,,void
27618,BLOCK,-1,,"{
#if OPENSSL_VERSION_MAJOR >= 3
      BIO_printf(out.get(), ""<invalid length=%d>"", ip->length);
#else
      BIO_printf(out.get(), ""<invalid>"");
#endif
    }",12,,744,1,,void
27626,BLOCK,-1,,<empty>,10,,751,1,,void
27633,BLOCK,-1,,"{
    // Unlike OpenSSL's default implementation, never print the OID as text and
    // instead always print its numeric representation.
    char oline[256];
    OBJ_obj2txt(oline, sizeof(oline), gen->d.rid, true);
    BIO_printf(out.get(), ""Registered ID:%s"", oline);
  }",36,,751,2,,void
27653,BLOCK,-1,,<empty>,10,,757,1,,void
27660,BLOCK,-1,,"{
    // The format that is used here is based on OpenSSL's implementation of
    // GENERAL_NAME_print (as of OpenSSL 3.0.1). Earlier versions of Node.js
    // instead produced the same format as i2v_GENERAL_NAME, which was somewhat
    // awkward, especially when passed to translatePeerCertificate.
    bool unicode = true;
    const char* prefix = nullptr;
    // OpenSSL 1.1.1 does not support othername in GENERAL_NAME_print and may
    // not define these NIDs.
#if OPENSSL_VERSION_MAJOR >= 3
    int nid = OBJ_obj2nid(gen->d.otherName->type_id);
    switch (nid) {
      case NID_id_on_SmtpUTF8Mailbox:
        prefix = ""SmtpUTF8Mailbox"";
        break;
      case NID_XmppAddr:
        prefix = ""XmppAddr"";
        break;
      case NID_SRVName:
        prefix = ""SRVName"";
        unicode = false;
        break;
      case NID_ms_upn:
        prefix = ""UPN"";
        break;
      case NID_NAIRealm:
        prefix = ""NAIRealm"";
        break;
    }
#endif  // OPENSSL_VERSION_MAJOR >= ...",42,,757,2,,void
27698,BLOCK,-1,,"{
      BIO_printf(out.get(), ""othername:<unsupported>"");
    }",53,,790,2,,void
27706,BLOCK,-1,,"{
      BIO_printf(out.get(), ""othername:"");
      if (unicode) {
        PrintUtf8AltName(out, gen->d.otherName->value->value.utf8string,
                         prefix);
      } else {
        PrintLatin1AltName(out, gen->d.otherName->value->value.ia5string,
                           prefix);
      }
    }",12,,792,1,,void
27715,BLOCK,-1,,"{
        PrintUtf8AltName(out, gen->d.otherName->value->value.utf8string,
                         prefix);
      }",20,,794,2,,void
27731,BLOCK,-1,,"{
        PrintLatin1AltName(out, gen->d.otherName->value->value.ia5string,
                           prefix);
      }",14,,797,1,,void
27747,BLOCK,-1,,<empty>,10,,802,1,,void
27754,BLOCK,-1,,"{
    // TODO(tniessen): this is what OpenSSL does, implement properly instead
    BIO_printf(out.get(), ""X400Name:<unsupported>"");
  }",37,,802,2,,void
27762,BLOCK,-1,,<empty>,10,,805,1,,void
27769,BLOCK,-1,,"{
    // TODO(tniessen): this is what OpenSSL does, implement properly instead
    BIO_printf(out.get(), ""EdiPartyName:<unsupported>"");
  }",41,,805,2,,void
27777,BLOCK,-1,,"{
    // This is safe because X509V3_EXT_d2i would have returned nullptr in this
    // case already.
    UNREACHABLE();
  }",10,,808,1,,void
27786,BLOCK,-1,,"{
  const X509V3_EXT_METHOD* method = X509V3_EXT_get(ext);
  CHECK(method == X509V3_EXT_get_nid(NID_subject_alt_name));

  GENERAL_NAMES* names = static_cast<GENERAL_NAMES*>(X509V3_EXT_d2i(ext));
  if (names == nullptr)
    return false;

  bool ok = true;

  for (int i = 0; i < sk_GENERAL_NAME_num(names); i++) {
    GENERAL_NAME* gen = sk_GENERAL_NAME_value(names, i);

    if (i != 0)
      BIO_write(out.get(), "", "", 2);

    if (!(ok = PrintGeneralName(out, gen))) {
      break;
    }
  }
  sk_GENERAL_NAME_pop_free(names, GENERAL_NAME_free);

  return ok;
}",78,,817,3,,void
27808,BLOCK,-1,,<empty>,5,,823,2,,void
27816,BLOCK,-1,,<empty>,3,,827,1,,void
27827,BLOCK,4,,"{
    GENERAL_NAME* gen = sk_GENERAL_NAME_value(names, i);

    if (i != 0)
      BIO_write(out.get(), "", "", 2);

    if (!(ok = PrintGeneralName(out, gen))) {
      break;
    }
  }",56,,827,4,,void
27838,BLOCK,-1,,<empty>,7,,831,2,,void
27853,BLOCK,-1,,"{
      break;
    }",45,,833,2,,void
27865,BLOCK,-1,,"{
  const X509V3_EXT_METHOD* method = X509V3_EXT_get(ext);
  CHECK(method == X509V3_EXT_get_nid(NID_info_access));

  AUTHORITY_INFO_ACCESS* descs =
      static_cast<AUTHORITY_INFO_ACCESS*>(X509V3_EXT_d2i(ext));
  if (descs == nullptr)
    return false;

  bool ok = true;

  for (int i = 0; i < sk_ACCESS_DESCRIPTION_num(descs); i++) {
    ACCESS_DESCRIPTION* desc = sk_ACCESS_DESCRIPTION_value(descs, i);

    if (i != 0)
      BIO_write(out.get(), ""\n"", 1);

    char objtmp[80];
    i2t_ASN1_OBJECT(objtmp, sizeof(objtmp), desc->method);
    BIO_printf(out.get(), ""%s - "", objtmp);
    if (!(ok = PrintGeneralName(out, desc->location))) {
      break;
    }
  }
  sk_ACCESS_DESCRIPTION_pop_free(descs, ACCESS_DESCRIPTION_free);

#if OPENSSL_VERSION_MAJOR < 3
  BIO_write(out.get(), ""\n"", 1);
#endif

  return ok;
}",74,,842,3,,void
27887,BLOCK,-1,,<empty>,5,,849,2,,void
27895,BLOCK,-1,,<empty>,3,,853,1,,void
27906,BLOCK,4,,"{
    ACCESS_DESCRIPTION* desc = sk_ACCESS_DESCRIPTION_value(descs, i);

    if (i != 0)
      BIO_write(out.get(), ""\n"", 1);

    char objtmp[80];
    i2t_ASN1_OBJECT(objtmp, sizeof(objtmp), desc->method);
    BIO_printf(out.get(), ""%s - "", objtmp);
    if (!(ok = PrintGeneralName(out, desc->location))) {
      break;
    }
  }",62,,853,4,,void
27917,BLOCK,-1,,<empty>,7,,857,2,,void
27949,BLOCK,-1,,"{
      break;
    }",56,,862,2,,void
27969,BLOCK,-1,,"{
  int index = X509_get_ext_by_NID(cert, NID_subject_alt_name, -1);
  if (index < 0)
    return Undefined(env->isolate());

  X509_EXTENSION* ext = X509_get_ext(cert, index);
  CHECK_NOT_NULL(ext);

  if (!SafeX509SubjectAltNamePrint(bio, ext)) {
    CHECK_EQ(BIO_reset(bio.get()), 1);
    return v8::Null(env->isolate());
  }

  return ToV8Value(env, bio);
}",74,,877,4,,void
27982,BLOCK,-1,,<empty>,5,,880,2,,void
28002,BLOCK,-1,,"{
    CHECK_EQ(BIO_reset(bio.get()), 1);
    return v8::Null(env->isolate());
  }",47,,885,2,,void
28029,BLOCK,-1,,"{
  int index = X509_get_ext_by_NID(cert, NID_info_access, -1);
  if (index < 0)
    return Undefined(env->isolate());

  X509_EXTENSION* ext = X509_get_ext(cert, index);
  CHECK_NOT_NULL(ext);

  if (!SafeX509InfoAccessPrint(bio, ext)) {
    CHECK_EQ(BIO_reset(bio.get()), 1);
    return v8::Null(env->isolate());
  }

  return ToV8Value(env, bio);
}",70,,895,4,,void
28042,BLOCK,-1,,<empty>,5,,898,2,,void
28062,BLOCK,-1,,"{
    CHECK_EQ(BIO_reset(bio.get()), 1);
    return v8::Null(env->isolate());
  }",43,,903,2,,void
28089,BLOCK,-1,,"{
  X509_NAME* issuer_name = X509_get_issuer_name(cert);
  if (X509_NAME_print_ex(
          bio.get(),
          issuer_name,
          0,
          kX509NameFlagsMultiline) <= 0) {
    CHECK_EQ(BIO_reset(bio.get()), 1);
    return Undefined(env->isolate());
  }

  return ToV8Value(env, bio);
}",58,,913,4,,void
28106,BLOCK,-1,,"{
    CHECK_EQ(BIO_reset(bio.get()), 1);
    return Undefined(env->isolate());
  }",42,,919,2,,void
28130,BLOCK,-1,,"{
  if (X509_NAME_print_ex(
          bio.get(),
          X509_get_subject_name(cert),
          0,
          kX509NameFlagsMultiline) <= 0) {
    CHECK_EQ(BIO_reset(bio.get()), 1);
    return Undefined(env->isolate());
  }

  return ToV8Value(env, bio);
}",53,,929,4,,void
28143,BLOCK,-1,,"{
    CHECK_EQ(BIO_reset(bio.get()), 1);
    return Undefined(env->isolate());
  }",42,,934,2,,void
28166,BLOCK,-1,,"{
  X509_NAME* name = get_name(cert);
  CHECK_NOT_NULL(name);

  int cnt = X509_NAME_entry_count(name);
  CHECK_GE(cnt, 0);

  Local<Object> result =
      Object::New(env->isolate(), Null(env->isolate()), nullptr, nullptr, 0);
  if (result.IsEmpty()) {
    return MaybeLocal<Value>();
  }

  for (int i = 0; i < cnt; i++) {
    X509_NAME_ENTRY* entry = X509_NAME_get_entry(name, i);
    CHECK_NOT_NULL(entry);

    // We intentionally ignore the value of X509_NAME_ENTRY_set because the
    // representation as an object does not allow grouping entries into sets
    // anyway, and multi-value RDNs are rare, i.e., the vast majority of
    // Relative Distinguished Names contains a single type-value pair only.
    const ASN1_OBJECT* type = X509_NAME_ENTRY_get_object(entry);
    const ASN1_STRING* value = X509_NAME_ENTRY_get_data(entry);

    // If OpenSSL knows the type, use the short name of the type as the key, and
    // the numeric representation of the type's OID otherwise.
    int t...",74,,943,3,,void
28209,BLOCK,-1,,"{
    return MaybeLocal<Value>();
  }",25,,952,2,,void
28213,BLOCK,-1,,<empty>,3,,956,1,,void
28223,BLOCK,4,,"{
    X509_NAME_ENTRY* entry = X509_NAME_get_entry(name, i);
    CHECK_NOT_NULL(entry);

    // We intentionally ignore the value of X509_NAME_ENTRY_set because the
    // representation as an object does not allow grouping entries into sets
    // anyway, and multi-value RDNs are rare, i.e., the vast majority of
    // Relative Distinguished Names contains a single type-value pair only.
    const ASN1_OBJECT* type = X509_NAME_ENTRY_get_object(entry);
    const ASN1_STRING* value = X509_NAME_ENTRY_get_data(entry);

    // If OpenSSL knows the type, use the short name of the type as the key, and
    // the numeric representation of the type's OID otherwise.
    int type_nid = OBJ_obj2nid(type);
    char type_buf[80];
    const char* type_str;
    if (type_nid != NID_undef) {
      type_str = OBJ_nid2sn(type_nid);
      CHECK_NOT_NULL(type_str);
    } else {
      OBJ_obj2txt(type_buf, sizeof(type_buf), type, true);
      type_str = type_buf;
    }

    Local<String> v8_name;
    if (...",33,,956,4,,void
28253,BLOCK,-1,,"{
      type_str = OBJ_nid2sn(type_nid);
      CHECK_NOT_NULL(type_str);
    }",32,,972,2,,void
28261,BLOCK,-1,,"{
      OBJ_obj2txt(type_buf, sizeof(type_buf), type, true);
      type_str = type_buf;
    }",12,,975,1,,void
28292,BLOCK,-1,,"{
      return MaybeLocal<Value>();
    }",75,,981,2,,void
28306,BLOCK,-1,,"{
      return Undefined(env->isolate());
    }",29,,992,2,,void
28345,BLOCK,-1,,"{
      return MaybeLocal<Value>();
    }",35,,1002,2,,void
28365,BLOCK,-1,,"{
      return MaybeLocal<Value>();
    }",73,,1012,2,,void
28369,BLOCK,-1,,<empty>,12,,1014,1,,void
28372,BLOCK,-1,,"{
      Local<Value> accum;
      if (!result->Get(env->context(), v8_name).ToLocal(&accum)) {
        return MaybeLocal<Value>();
      }
      if (!accum->IsArray()) {
        accum = Array::New(env->isolate(), &accum, 1);
        if (result->Set(env->context(), v8_name, accum).IsNothing()) {
          return MaybeLocal<Value>();
        }
      }
      Local<Array> array = accum.As<Array>();
      if (array->Set(env->context(), array->Length(), v8_value).IsNothing()) {
        return MaybeLocal<Value>();
      }
    }",26,,1014,2,,void
28394,BLOCK,-1,,"{
        return MaybeLocal<Value>();
      }",66,,1016,2,,void
28403,BLOCK,-1,,"{
        accum = Array::New(env->isolate(), &accum, 1);
        if (result->Set(env->context(), v8_name, accum).IsNothing()) {
          return MaybeLocal<Value>();
        }
      }",30,,1019,2,,void
28431,BLOCK,-1,,"{
          return MaybeLocal<Value>();
        }",70,,1021,2,,void
28461,BLOCK,-1,,"{
        return MaybeLocal<Value>();
      }",78,,1026,2,,void
28465,BLOCK,-1,,<empty>,12,,1029,1,,void
28480,BLOCK,-1,,"{
      return MaybeLocal<Value>();
    }",76,,1029,2,,void
28490,BLOCK,-1,,"{
  return Get(env, SSL_get_current_cipher(ssl.get()));
}",64,,1039,3,,void
28504,BLOCK,-1,,"{
  EscapableHandleScope scope(env->isolate());
  const unsigned char* buf;
  size_t len = SSL_client_hello_get0_ciphers(ssl.get(), &buf);
  size_t count = len / 2;
  MaybeStackBuffer<Local<Value>, 16> ciphers(count);
  int j = 0;
  for (size_t n = 0; n < len; n += 2) {
    const SSL_CIPHER* cipher = SSL_CIPHER_find(ssl.get(), buf);
    buf += 2;
    Local<Object> obj = Object::New(env->isolate());
    if (!Set(env->context(),
             obj,
             env->name_string(),
             GetCipherName(env, cipher)) ||
        !Set(env->context(),
             obj,
             env->standard_name_string(),
             GetCipherStandardName(env, cipher)) ||
        !Set(env->context(),
             obj,
             env->version_string(),
             GetCipherVersion(env, cipher))) {
      return MaybeLocal<Array>();
    }
    ciphers[j++] = obj;
  }
  Local<Array> ret = Array::New(env->isolate(), ciphers.out(), count);
  return scope.Escape(ret);
}",28,,1045,3,,void
28536,BLOCK,-1,,<empty>,3,,1052,1,,void
28547,BLOCK,4,,"{
    const SSL_CIPHER* cipher = SSL_CIPHER_find(ssl.get(), buf);
    buf += 2;
    Local<Object> obj = Object::New(env->isolate());
    if (!Set(env->context(),
             obj,
             env->name_string(),
             GetCipherName(env, cipher)) ||
        !Set(env->context(),
             obj,
             env->standard_name_string(),
             GetCipherStandardName(env, cipher)) ||
        !Set(env->context(),
             obj,
             env->version_string(),
             GetCipherVersion(env, cipher))) {
      return MaybeLocal<Array>();
    }
    ciphers[j++] = obj;
  }",39,,1052,4,,void
28619,BLOCK,-1,,"{
      return MaybeLocal<Array>();
    }",46,,1067,2,,void
28658,BLOCK,-1,,"{
  if (SSL_get_current_cipher(ssl.get()) == nullptr)
    return MaybeLocal<Object>();
  EscapableHandleScope scope(env->isolate());
  Local<Object> info = Object::New(env->isolate());

  if (!Set<Value>(env->context(),
                  info,
                  env->name_string(),
                  GetCurrentCipherValue<GetCipherName>(env, ssl)) ||
      !Set<Value>(env->context(),
                  info,
                  env->standard_name_string(),
                  GetCurrentCipherValue<GetCipherStandardName>(env, ssl)) ||
      !Set<Value>(env->context(),
                  info,
                  env->version_string(),
                  GetCurrentCipherValue<GetCipherVersion>(env, ssl))) {
    return MaybeLocal<Object>();
  }

  return scope.Escape(info);
}",75,,1077,3,,void
28667,BLOCK,-1,,<empty>,5,,1079,2,,void
28735,BLOCK,-1,,"{
    return MaybeLocal<Object>();
  }",71,,1094,2,,void
28749,BLOCK,-1,,"{
  CHECK_EQ(SSL_is_server(ssl.get()), 0);
  EVP_PKEY* raw_key;

  EscapableHandleScope scope(env->isolate());
  Local<Object> info = Object::New(env->isolate());
  if (!SSL_get_server_tmp_key(ssl.get(), &raw_key))
    return scope.Escape(info);

  Local<Context> context = env->context();
  crypto::EVPKeyPointer key(raw_key);

  int kid = EVP_PKEY_id(key.get());
  int bits = EVP_PKEY_bits(key.get());
  switch (kid) {
    case EVP_PKEY_DH:
      if (!Set<String>(context, info, env->type_string(), env->dh_string()) ||
          !Set<Integer>(context,
               info,
               env->size_string(),
               Integer::New(env->isolate(), bits))) {
        return MaybeLocal<Object>();
      }
      break;
    case EVP_PKEY_EC:
    case EVP_PKEY_X25519:
    case EVP_PKEY_X448:
      {
        const char* curve_name;
        if (kid == EVP_PKEY_EC) {
          ECKeyPointer ec(EVP_PKEY_get1_EC_KEY(key.get()));
          int nid = EC_GROUP_get_curve_name(EC_KEY_get0_group(ec.get...",77,,1101,3,,void
28787,BLOCK,-1,,<empty>,5,,1108,2,,void
28825,BLOCK,-1,,"{
    case EVP_PKEY_DH:
      if (!Set<String>(context, info, env->type_string(), env->dh_string()) ||
          !Set<Integer>(context,
               info,
               env->size_string(),
               Integer::New(env->isolate(), bits))) {
        return MaybeLocal<Object>();
      }
      break;
    case EVP_PKEY_EC:
    case EVP_PKEY_X25519:
    case EVP_PKEY_X448:
      {
        const char* curve_name;
        if (kid == EVP_PKEY_EC) {
          ECKeyPointer ec(EVP_PKEY_get1_EC_KEY(key.get()));
          int nid = EC_GROUP_get_curve_name(EC_KEY_get0_group(ec.get()));
          curve_name = OBJ_nid2sn(nid);
        } else {
          curve_name = OBJ_nid2sn(kid);
        }
        if (!Set<String>(context,
                         info,
                         env->type_string(),
                         env->ecdh_string()) ||
            !Set<String>(context,
                info,
                env->name_string(),
                OneByteString(env->isolate(), curve_name...",16,,1115,2,,void
28859,BLOCK,-1,,"{
        return MaybeLocal<Object>();
      }",53,,1121,2,,void
28869,BLOCK,11,,"{
        const char* curve_name;
        if (kid == EVP_PKEY_EC) {
          ECKeyPointer ec(EVP_PKEY_get1_EC_KEY(key.get()));
          int nid = EC_GROUP_get_curve_name(EC_KEY_get0_group(ec.get()));
          curve_name = OBJ_nid2sn(nid);
        } else {
          curve_name = OBJ_nid2sn(kid);
        }
        if (!Set<String>(context,
                         info,
                         env->type_string(),
                         env->ecdh_string()) ||
            !Set<String>(context,
                info,
                env->name_string(),
                OneByteString(env->isolate(), curve_name)) ||
            !Set<Integer>(context,
                 info,
                 env->size_string(),
                 Integer::New(env->isolate(), bits))) {
          return MaybeLocal<Object>();
        }
      }",7,,1128,11,,void
28875,BLOCK,-1,,"{
          ECKeyPointer ec(EVP_PKEY_get1_EC_KEY(key.get()));
          int nid = EC_GROUP_get_curve_name(EC_KEY_get0_group(ec.get()));
          curve_name = OBJ_nid2sn(nid);
        }",33,,1130,2,,void
28897,BLOCK,-1,,"{
          curve_name = OBJ_nid2sn(kid);
        }",16,,1134,1,,void
28948,BLOCK,-1,,"{
          return MaybeLocal<Object>();
        }",55,,1148,2,,void
28966,BLOCK,-1,,"{
  size_t len = EC_POINT_point2oct(group, point, form, nullptr, 0, nullptr);
  if (len == 0) {
    if (error != nullptr) *error = ""Failed to get public key length"";
    return MaybeLocal<Object>();
  }

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), len);
  }

  len = EC_POINT_point2oct(group,
                           point,
                           form,
                           reinterpret_cast<unsigned char*>(bs->Data()),
                           bs->ByteLength(),
                           nullptr);
  if (len == 0) {
    if (error != nullptr) *error = ""Failed to get public key"";
    return MaybeLocal<Object>();
  }

  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
  return Buffer::New(env, ab, 0, ab->ByteLength()).FromMaybe(Local<Object>());
}",56,,1162,6,,void
28981,BLOCK,-1,,"{
    if (error != nullptr) *error = ""Failed to get public key length"";
    return MaybeLocal<Object>();
  }",17,,1164,2,,void
28986,BLOCK,-1,,<empty>,27,,1165,2,,void
29000,BLOCK,5,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), len);
  }",3,,1170,5,,void
29039,BLOCK,-1,,"{
    if (error != nullptr) *error = ""Failed to get public key"";
    return MaybeLocal<Object>();
  }",17,,1181,2,,void
29044,BLOCK,-1,,<empty>,27,,1182,2,,void
29093,BLOCK,-1,,"{
  ClearErrorOnReturn clear_error_on_return;
  Local<Object> result;
  MaybeLocal<Object> maybe_cert;

  // NOTE: This is because of the odd OpenSSL behavior. On client `cert_chain`
  // contains the `peer_certificate`, but on server it doesn't.
  X509Pointer cert(is_server ? SSL_get_peer_certificate(ssl.get()) : nullptr);
  STACK_OF(X509)* ssl_certs = SSL_get_peer_cert_chain(ssl.get());
  if (!cert && (ssl_certs == nullptr || sk_X509_num(ssl_certs) == 0))
    return Undefined(env->isolate());

  // Short result requested.
  if (abbreviated) {
    maybe_cert =
        X509ToObject(env, cert ? cert.get() : sk_X509_value(ssl_certs, 0));
    return maybe_cert.ToLocal(&result) ? result : MaybeLocal<Value>();
  }

  StackOfX509 peer_certs = CloneSSLCerts(std::move(cert), ssl_certs);
  if (peer_certs == nullptr)
    return Undefined(env->isolate());

  // First and main certificate.
  X509Pointer first_cert(sk_X509_value(peer_certs.get(), 0));
  CHECK(first_cert);
  maybe_cert = X509ToOb...",21,,1194,5,,void
29137,BLOCK,-1,,<empty>,5,,1204,2,,void
29146,BLOCK,-1,,"{
    maybe_cert =
        X509ToObject(env, cert ? cert.get() : sk_X509_value(ssl_certs, 0));
    return maybe_cert.ToLocal(&result) ? result : MaybeLocal<Value>();
  }",20,,1207,2,,void
29184,BLOCK,-1,,<empty>,5,,1215,2,,void
29217,BLOCK,-1,,<empty>,5,,1222,2,,void
29250,BLOCK,-1,,<empty>,5,,1234,2,,void
29273,BLOCK,-1,,<empty>,5,,1245,2,,void
29301,BLOCK,-1,,"{
    return MaybeLocal<Value>();
  }",27,,1252,2,,void
29311,BLOCK,-1,,"{
  EscapableHandleScope scope(env->isolate());
  Local<Context> context = env->context();
  Local<Object> info = Object::New(env->isolate());

  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);

  // X509_check_ca() returns a range of values. Only 1 means ""is a CA""
  auto is_ca = Boolean::New(env->isolate(), 1 == X509_check_ca(cert));
  if (!Set<Value>(context,
                  info,
                  env->subject_string(),
                  GetX509NameObject<X509_get_subject_name>(env, cert)) ||
      !Set<Value>(context,
                  info,
                  env->issuer_string(),
                  GetX509NameObject<X509_get_issuer_name>(env, cert)) ||
      !Set<Value>(context,
                  info,
                  env->subjectaltname_string(),
                  GetSubjectAltNameString(env, cert, bio)) ||
      !Set<Value>(context,
                  info,
                  env->infoaccess_string(),
                  GetInfoAccessString(env, cert, bio)) ||
      !Set<B...",17,,1261,3,,void
29344,BLOCK,-1,,<empty>,,,,2,,<empty>
29424,BLOCK,-1,,"{
    return MaybeLocal<Object>();
  }",62,,1287,2,,void
29435,BLOCK,-1,,"{
    switch (EVP_PKEY_id(pkey.get())) {
      case EVP_PKEY_RSA:
        rsa.reset(EVP_PKEY_get1_RSA(pkey.get()));
        break;
      case EVP_PKEY_EC:
        ec.reset(EVP_PKEY_get1_EC_KEY(pkey.get()));
        break;
    }
  }",13,,1294,2,,void
29442,BLOCK,-1,,"{
      case EVP_PKEY_RSA:
        rsa.reset(EVP_PKEY_get1_RSA(pkey.get()));
        break;
      case EVP_PKEY_EC:
        ec.reset(EVP_PKEY_get1_EC_KEY(pkey.get()));
        break;
    }",38,,1295,2,,void
29469,BLOCK,-1,,"{
    const BIGNUM* n;
    const BIGNUM* e;
    RSA_get0_key(rsa.get(), &n, &e, nullptr);
    if (!Set<Value>(context,
                    info,
                    env->modulus_string(),
                    GetModulusString(env, bio, n)) ||
        !Set<Value>(context, info, env->bits_string(), GetBits(env, n)) ||
        !Set<Value>(context,
                    info,
                    env->exponent_string(),
                    GetExponentString(env, bio, e)) ||
        !Set<Object>(context,
                     info,
                     env->pubkey_string(),
                     GetPubKey(env, rsa))) {
      return MaybeLocal<Object>();
    }
  }",12,,1305,2,,void
29532,BLOCK,-1,,"{
      return MaybeLocal<Object>();
    }",44,,1321,2,,void
29536,BLOCK,-1,,<empty>,10,,1324,1,,void
29539,BLOCK,-1,,"{
    const EC_GROUP* group = EC_KEY_get0_group(ec.get());

    if (!Set<Value>(context,
                    info,
                    env->bits_string(),
                    GetECGroup(env, group, ec)) ||
        !Set<Value>(context,
                    info,
                    env->pubkey_string(),
                    GetECPubKey(env, group, ec))) {
      return MaybeLocal<Object>();
    }

    const int nid = EC_GROUP_get_curve_name(group);
    if (nid != 0) {
      // Curve is well-known, get its OID and NIST nick-name (if it has one).

      if (!Set<Value>(context,
                      info,
                      env->asn1curve_string(),
                      GetCurveName<OBJ_nid2sn>(env, nid)) ||
          !Set<Value>(context,
                      info,
                      env->nistcurve_string(),
                      GetCurveName<EC_curve_nid2nist>(env, nid))) {
        return MaybeLocal<Object>();
      }
    } else {
      // Unnamed curves can be described by their ...",18,,1324,2,,void
29574,BLOCK,-1,,"{
      return MaybeLocal<Object>();
    }",51,,1334,2,,void
29586,BLOCK,-1,,"{
      // Curve is well-known, get its OID and NIST nick-name (if it has one).

      if (!Set<Value>(context,
                      info,
                      env->asn1curve_string(),
                      GetCurveName<OBJ_nid2sn>(env, nid)) ||
          !Set<Value>(context,
                      info,
                      env->nistcurve_string(),
                      GetCurveName<EC_curve_nid2nist>(env, nid))) {
        return MaybeLocal<Object>();
      }
    }",19,,1339,2,,void
29611,BLOCK,-1,,"{
        return MaybeLocal<Object>();
      }",67,,1349,2,,void
29615,BLOCK,-1,,"{
      // Unnamed curves can be described by their mathematical properties,
      // but aren't used much (at all?) with X.509/TLS. Support later if needed.
    }",12,,1352,1,,void
29654,BLOCK,-1,,"{
    return MaybeLocal<Object>();
  }",48,,1370,2,,void
29736,BLOCK,-1,,"{
    return MaybeLocal<Object>();
  }",79,,1396,2,,void
29761,BLOCK,-1,,<empty>,1,,1,1,,ANY
29800,BLOCK,-1,,<empty>,1,,1,1,,ANY
29816,BLOCK,-1,,"{
  // Guaranteed thread-safe by standard, just don't use -fno-threadsafe-statics.
  static X509_STORE* store = NewRootCertStore();
  return store;
}",47,,56,1,,void
29828,BLOCK,-1,,"{
  if (v->IsString() || v->IsArrayBufferView()) {
    BIOPointer bio(BIO_new(BIO_s_secmem()));
    if (!bio) return nullptr;
    ByteSource bsrc = ByteSource::FromStringOrBuffer(env, v);
    if (bsrc.size() > INT_MAX) return nullptr;
    int written = BIO_write(bio.get(), bsrc.data<char>(), bsrc.size());
    if (written < 0) return nullptr;
    if (static_cast<size_t>(written) != bsrc.size()) return nullptr;
    return bio;
  }
  return nullptr;
}",54,,64,3,,void
29839,BLOCK,-1,,"{
    BIOPointer bio(BIO_new(BIO_s_secmem()));
    if (!bio) return nullptr;
    ByteSource bsrc = ByteSource::FromStringOrBuffer(env, v);
    if (bsrc.size() > INT_MAX) return nullptr;
    int written = BIO_write(bio.get(), bsrc.data<char>(), bsrc.size());
    if (written < 0) return nullptr;
    if (static_cast<size_t>(written) != bsrc.size()) return nullptr;
    return bio;
  }",48,,65,2,,void
29842,BLOCK,-1,,<empty>,,,,2,,<empty>
29848,BLOCK,-1,,<empty>,15,,67,2,,void
29867,BLOCK,-1,,<empty>,32,,69,2,,void
29890,BLOCK,-1,,<empty>,22,,71,2,,void
29902,BLOCK,-1,,<empty>,54,,72,2,,void
29918,BLOCK,-1,,"{
  // Just to ensure that `ERR_peek_last_error` below will return only errors
  // that we are interested in
  ERR_clear_error();

  X509Pointer x(
      PEM_read_bio_X509_AUX(in.get(), nullptr, NoPasswordCallback, nullptr));

  if (!x)
    return 0;

  unsigned long err = 0;  // NOLINT(runtime/int)

  StackOfX509 extra_certs(sk_X509_new_null());
  if (!extra_certs)
    return 0;

  while (X509Pointer extra {PEM_read_bio_X509(in.get(),
                                    nullptr,
                                    NoPasswordCallback,
                                    nullptr)}) {
    if (sk_X509_push(extra_certs.get(), extra.get())) {
      extra.release();
      continue;
    }

    return 0;
  }

  // When the while loop ends, it's usually just EOF.
  err = ERR_peek_last_error();
  if (ERR_GET_LIB(err) == ERR_LIB_PEM &&
      ERR_GET_REASON(err) == PEM_R_NO_START_LINE) {
    ERR_clear_error();
  } else {
    // some real error
    return 0;
  }

  return SSL_CTX_use_certificat...",56,,151,5,,void
29933,BLOCK,-1,,<empty>,5,,160,2,,void
29946,BLOCK,-1,,<empty>,5,,166,2,,void
29950,BLOCK,-1,,"{
    if (sk_X509_push(extra_certs.get(), extra.get())) {
      extra.release();
      continue;
    }

    return 0;
  }",48,,171,1,,void
29961,BLOCK,-1,,"{
      extra.release();
      continue;
    }",55,,172,2,,void
29982,BLOCK,-1,,"{
    ERR_clear_error();
  }",51,,183,2,,void
29985,BLOCK,-1,,"{
    // some real error
    return 0;
  }",10,,185,1,,void
30005,BLOCK,-1,,"{
  static std::vector<X509*> root_certs_vector;
  static Mutex root_certs_vector_mutex;
  Mutex::ScopedLock lock(root_certs_vector_mutex);

  if (root_certs_vector.empty() &&
      per_process::cli_options->ssl_openssl_cert_store == false) {
    for (size_t i = 0; i < arraysize(root_certs); i++) {
      X509* x509 =
          PEM_read_bio_X509(NodeBIO::NewFixed(root_certs[i],
                                              strlen(root_certs[i])).get(),
                            nullptr,   // no re-use of X509 structure
                            NoPasswordCallback,
                            nullptr);  // no callback data

      // Parse errors from the built-in roots are fatal.
      CHECK_NOT_NULL(x509);

      root_certs_vector.push_back(x509);
    }
  }

  X509_STORE* store = X509_STORE_new();
  if (*system_cert_path != '\0') {
    ERR_set_mark();
    X509_STORE_load_locations(store, system_cert_path, nullptr);
    ERR_pop_to_mark();
  }

  Mutex::ScopedLock cli_lock(node::pe...",32,,199,1,,void
30024,BLOCK,-1,,"{
    for (size_t i = 0; i < arraysize(root_certs); i++) {
      X509* x509 =
          PEM_read_bio_X509(NodeBIO::NewFixed(root_certs[i],
                                              strlen(root_certs[i])).get(),
                            nullptr,   // no re-use of X509 structure
                            NoPasswordCallback,
                            nullptr);  // no callback data

      // Parse errors from the built-in roots are fatal.
      CHECK_NOT_NULL(x509);

      root_certs_vector.push_back(x509);
    }
  }",66,,205,2,,void
30026,BLOCK,-1,,<empty>,5,,206,1,,void
30037,BLOCK,4,,"{
      X509* x509 =
          PEM_read_bio_X509(NodeBIO::NewFixed(root_certs[i],
                                              strlen(root_certs[i])).get(),
                            nullptr,   // no re-use of X509 structure
                            NoPasswordCallback,
                            nullptr);  // no callback data

      // Parse errors from the built-in roots are fatal.
      CHECK_NOT_NULL(x509);

      root_certs_vector.push_back(x509);
    }",56,,206,4,,void
30075,BLOCK,-1,,"{
    ERR_set_mark();
    X509_STORE_load_locations(store, system_cert_path, nullptr);
    ERR_pop_to_mark();
  }",34,,222,2,,void
30095,BLOCK,-1,,"{
    X509_STORE_set_default_paths(store);
  }",57,,229,2,,void
30099,BLOCK,-1,,"{
    for (X509* cert : root_certs_vector) {
      X509_up_ref(cert);
      X509_STORE_add_cert(store, cert);
    }
  }",10,,231,1,,void
30103,BLOCK,-1,,"{
      X509_up_ref(cert);
      X509_STORE_add_cert(store, cert);
    }",42,,232,3,,void
30115,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Local<Value> result[arraysize(root_certs)];

  for (size_t i = 0; i < arraysize(root_certs); i++) {
    if (!String::NewFromOneByte(
            env->isolate(),
            reinterpret_cast<const uint8_t*>(root_certs[i]))
            .ToLocal(&result[i])) {
      return;
    }
  }

  args.GetReturnValue().Set(
      Array::New(env->isolate(), result, arraysize(root_certs)));
}",67,,241,2,,void
30133,BLOCK,-1,,<empty>,3,,245,1,,void
30144,BLOCK,4,,"{
    if (!String::NewFromOneByte(
            env->isolate(),
            reinterpret_cast<const uint8_t*>(root_certs[i]))
            .ToLocal(&result[i])) {
      return;
    }
  }",54,,245,4,,void
30167,BLOCK,-1,,"{
      return;
    }",35,,249,2,,void
30192,BLOCK,-1,,"{
  return GetConstructorTemplate(env)->HasInstance(value);
}",78,,258,3,,void
30204,BLOCK,-1,,"{
  Local<FunctionTemplate> tmpl = env->secure_context_constructor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, New);
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        SecureContext::kInternalFieldCount);
    tmpl->SetClassName(FIXED_ONE_BYTE_STRING(env->isolate(), ""SecureContext""));

    SetProtoMethod(isolate, tmpl, ""init"", Init);
    SetProtoMethod(isolate, tmpl, ""setKey"", SetKey);
    SetProtoMethod(isolate, tmpl, ""setCert"", SetCert);
    SetProtoMethod(isolate, tmpl, ""addCACert"", AddCACert);
    SetProtoMethod(isolate, tmpl, ""addCRL"", AddCRL);
    SetProtoMethod(isolate, tmpl, ""addRootCerts"", AddRootCerts);
    SetProtoMethod(isolate, tmpl, ""setCipherSuites"", SetCipherSuites);
    SetProtoMethod(isolate, tmpl, ""setCiphers"", SetCiphers);
    SetProtoMethod(isolate, tmpl, ""setSigalgs"", SetSigalgs);
    SetProtoMethod(isolate, tmpl, ""setECDHCurve"", SetECDHCurve);
    SetProtoMethod(isolate, tmpl, ""set...",23,,263,2,,void
30220,BLOCK,-1,,"{
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, New);
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        SecureContext::kInternalFieldCount);
    tmpl->SetClassName(FIXED_ONE_BYTE_STRING(env->isolate(), ""SecureContext""));

    SetProtoMethod(isolate, tmpl, ""init"", Init);
    SetProtoMethod(isolate, tmpl, ""setKey"", SetKey);
    SetProtoMethod(isolate, tmpl, ""setCert"", SetCert);
    SetProtoMethod(isolate, tmpl, ""addCACert"", AddCACert);
    SetProtoMethod(isolate, tmpl, ""addCRL"", AddCRL);
    SetProtoMethod(isolate, tmpl, ""addRootCerts"", AddRootCerts);
    SetProtoMethod(isolate, tmpl, ""setCipherSuites"", SetCipherSuites);
    SetProtoMethod(isolate, tmpl, ""setCiphers"", SetCiphers);
    SetProtoMethod(isolate, tmpl, ""setSigalgs"", SetSigalgs);
    SetProtoMethod(isolate, tmpl, ""setECDHCurve"", SetECDHCurve);
    SetProtoMethod(isolate, tmpl, ""setDHParam"", SetDHParam);
    SetProtoMethod(isolate, tmpl, ""setMaxProto"", SetMaxProto);
    SetProtoMet...",23,,265,2,,void
30391,BLOCK,1,,<empty>,,,,5,,void
30408,BLOCK,1,,<empty>,,,,5,,void
30425,BLOCK,1,,<empty>,,,,5,,void
30442,BLOCK,1,,<empty>,,,,5,,void
30459,BLOCK,1,,<empty>,,,,5,,void
30521,BLOCK,-1,,"{
  Local<Context> context = env->context();
  SetConstructorFunction(context,
                         target,
                         ""SecureContext"",
                         GetConstructorTemplate(env),
                         SetConstructorFunctionFlag::NONE);

  SetMethodNoSideEffect(
      context, target, ""getRootCertificates"", GetRootCertificates);
  // Exposed for testing purposes only.
  SetMethodNoSideEffect(context,
                        target,
                        ""isExtraRootCertsFileLoaded"",
                        IsExtraRootCertsFileLoaded);
}",72,,331,3,,void
30555,BLOCK,-1,,"{
  registry->Register(New);
  registry->Register(Init);
  registry->Register(SetKey);
  registry->Register(SetCert);
  registry->Register(AddCACert);
  registry->Register(AddCRL);
  registry->Register(AddRootCerts);
  registry->Register(SetCipherSuites);
  registry->Register(SetCiphers);
  registry->Register(SetSigalgs);
  registry->Register(SetECDHCurve);
  registry->Register(SetDHParam);
  registry->Register(SetMaxProto);
  registry->Register(SetMinProto);
  registry->Register(GetMaxProto);
  registry->Register(GetMinProto);
  registry->Register(SetOptions);
  registry->Register(SetSessionIdContext);
  registry->Register(SetSessionTimeout);
  registry->Register(Close);
  registry->Register(LoadPKCS12);
  registry->Register(SetTicketKeys);
  registry->Register(EnableTicketKeyCallback);
  registry->Register(GetTicketKeys);
  registry->Register(GetCertificate<true>);
  registry->Register(GetCertificate<false>);

#ifndef OPENSSL_NO_ENGINE
  registry->Register(SetEngineKey);
  registr...",42,,349,2,,void
30715,BLOCK,-1,,"{
  Local<Object> obj;
  if (!GetConstructorTemplate(env)
          ->InstanceTemplate()
          ->NewInstance(env->context()).ToLocal(&obj)) {
    return nullptr;
  }

  return new SecureContext(env, obj);
}",56,,388,2,,void
30740,BLOCK,-1,,"{
    return nullptr;
  }",56,,392,2,,void
30753,BLOCK,-1,,"{
  MakeWeak();
  env->isolate()->AdjustAmountOfExternalAllocatedMemory(kExternalSize);
}",29,,400,3,,void
30766,BLOCK,-1,,"{
  if (ctx_ != nullptr) {
    env()->isolate()->AdjustAmountOfExternalAllocatedMemory(-kExternalSize);
  }
  ctx_.reset();
  cert_.reset();
  issuer_.reset();
}",36,,405,1,,void
30771,BLOCK,-1,,"{
    env()->isolate()->AdjustAmountOfExternalAllocatedMemory(-kExternalSize);
  }",24,,406,2,,void
30796,BLOCK,-1,,"{
  Reset();
}",33,,414,1,,void
30802,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  new SecureContext(env, args.This());
}",66,,418,2,,void
30822,BLOCK,-1,,"{
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
  Environment* env = sc->env();

  CHECK_EQ(args.Length(), 3);
  CHECK(args[1]->IsInt32());
  CHECK(args[2]->IsInt32());

  int min_version = args[1].As<Int32>()->Value();
  int max_version = args[2].As<Int32>()->Value();
  const SSL_METHOD* method = TLS_method();

  if (max_version == 0)
    max_version = kMaxSupportedVersion;

  if (args[0]->IsString()) {
    Utf8Value sslmethod(env->isolate(), args[0]);

    // Note that SSLv2 and SSLv3 are disallowed but SSLv23_method and friends
    // are still accepted.  They are OpenSSL's way of saying that all known
    // protocols below TLS 1.3 are supported unless explicitly disabled (which
    // we do below for SSLv2 and SSLv3.)
    if (sslmethod == ""SSLv2_method"" ||
        sslmethod == ""SSLv2_server_method"" ||
        sslmethod == ""SSLv2_client_method"") {
      THROW_ERR_TLS_INVALID_PROTOCOL_METHOD(env, ""SSLv2 methods disabled"");
      return;
    } else if (sslmet...",67,,423,2,,void
30890,BLOCK,-1,,<empty>,5,,437,2,,void
30901,BLOCK,-1,,"{
    Utf8Value sslmethod(env->isolate(), args[0]);

    // Note that SSLv2 and SSLv3 are disallowed but SSLv23_method and friends
    // are still accepted.  They are OpenSSL's way of saying that all known
    // protocols below TLS 1.3 are supported unless explicitly disabled (which
    // we do below for SSLv2 and SSLv3.)
    if (sslmethod == ""SSLv2_method"" ||
        sslmethod == ""SSLv2_server_method"" ||
        sslmethod == ""SSLv2_client_method"") {
      THROW_ERR_TLS_INVALID_PROTOCOL_METHOD(env, ""SSLv2 methods disabled"");
      return;
    } else if (sslmethod == ""SSLv3_method"" ||
               sslmethod == ""SSLv3_server_method"" ||
               sslmethod == ""SSLv3_client_method"") {
      THROW_ERR_TLS_INVALID_PROTOCOL_METHOD(env, ""SSLv3 methods disabled"");
      return;
    } else if (sslmethod == ""SSLv23_method"") {
      max_version = TLS1_2_VERSION;
    } else if (sslmethod == ""SSLv23_server_method"") {
      max_version = TLS1_2_VERSION;
      method = TLS_server_method()...",28,,439,2,,void
30923,BLOCK,-1,,"{
      THROW_ERR_TLS_INVALID_PROTOCOL_METHOD(env, ""SSLv2 methods disabled"");
      return;
    }",45,,448,2,,void
30929,BLOCK,-1,,<empty>,12,,451,1,,void
30942,BLOCK,-1,,"{
      THROW_ERR_TLS_INVALID_PROTOCOL_METHOD(env, ""SSLv3 methods disabled"");
      return;
    }",52,,453,2,,void
30948,BLOCK,-1,,<empty>,12,,456,1,,void
30953,BLOCK,-1,,"{
      max_version = TLS1_2_VERSION;
    }",46,,456,2,,void
30958,BLOCK,-1,,<empty>,12,,458,1,,void
30963,BLOCK,-1,,"{
      max_version = TLS1_2_VERSION;
      method = TLS_server_method();
    }",53,,458,2,,void
30971,BLOCK,-1,,<empty>,12,,461,1,,void
30976,BLOCK,-1,,"{
      max_version = TLS1_2_VERSION;
      method = TLS_client_method();
    }",53,,461,2,,void
30984,BLOCK,-1,,<empty>,12,,464,1,,void
30989,BLOCK,-1,,"{
      min_version = 0;
      max_version = kMaxSupportedVersion;
    }",43,,464,2,,void
30997,BLOCK,-1,,<empty>,12,,467,1,,void
31002,BLOCK,-1,,"{
      min_version = 0;
      max_version = kMaxSupportedVersion;
      method = TLS_server_method();
    }",50,,467,2,,void
31013,BLOCK,-1,,<empty>,12,,471,1,,void
31018,BLOCK,-1,,"{
      min_version = 0;
      max_version = kMaxSupportedVersion;
      method = TLS_client_method();
    }",50,,471,2,,void
31029,BLOCK,-1,,<empty>,12,,475,1,,void
31034,BLOCK,-1,,"{
      min_version = TLS1_VERSION;
      max_version = TLS1_VERSION;
    }",45,,475,2,,void
31042,BLOCK,-1,,<empty>,12,,478,1,,void
31047,BLOCK,-1,,"{
      min_version = TLS1_VERSION;
      max_version = TLS1_VERSION;
      method = TLS_server_method();
    }",52,,478,2,,void
31058,BLOCK,-1,,<empty>,12,,482,1,,void
31063,BLOCK,-1,,"{
      min_version = TLS1_VERSION;
      max_version = TLS1_VERSION;
      method = TLS_client_method();
    }",52,,482,2,,void
31074,BLOCK,-1,,<empty>,12,,486,1,,void
31079,BLOCK,-1,,"{
      min_version = TLS1_1_VERSION;
      max_version = TLS1_1_VERSION;
    }",47,,486,2,,void
31087,BLOCK,-1,,<empty>,12,,489,1,,void
31092,BLOCK,-1,,"{
      min_version = TLS1_1_VERSION;
      max_version = TLS1_1_VERSION;
      method = TLS_server_method();
    }",54,,489,2,,void
31103,BLOCK,-1,,<empty>,12,,493,1,,void
31108,BLOCK,-1,,"{
      min_version = TLS1_1_VERSION;
      max_version = TLS1_1_VERSION;
      method = TLS_client_method();
    }",54,,493,2,,void
31119,BLOCK,-1,,<empty>,12,,497,1,,void
31124,BLOCK,-1,,"{
      min_version = TLS1_2_VERSION;
      max_version = TLS1_2_VERSION;
    }",47,,497,2,,void
31132,BLOCK,-1,,<empty>,12,,500,1,,void
31137,BLOCK,-1,,"{
      min_version = TLS1_2_VERSION;
      max_version = TLS1_2_VERSION;
      method = TLS_server_method();
    }",54,,500,2,,void
31148,BLOCK,-1,,<empty>,12,,504,1,,void
31153,BLOCK,-1,,"{
      min_version = TLS1_2_VERSION;
      max_version = TLS1_2_VERSION;
      method = TLS_client_method();
    }",54,,504,2,,void
31164,BLOCK,-1,,"{
      THROW_ERR_TLS_INVALID_PROTOCOL_METHOD(
          env, ""Unknown method: %s"", *sslmethod);
      return;
    }",12,,508,1,,void
31184,BLOCK,-1,,"{
    return ThrowCryptoError(env, ERR_get_error(), ""SSL_CTX_new"");
  }",18,,516,2,,void
31288,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_OPERATION_FAILED(
        env, ""Error generating ticket keys"");
  }",74,,551,2,,void
31304,BLOCK,-1,,"{
  return SSLPointer(SSL_new(ctx_.get()));
}",39,,558,1,,void
31316,BLOCK,-1,,"{
  SSL_CTX_sess_set_new_cb(ctx_.get(), cb);
}",60,,562,2,,void
31327,BLOCK,-1,,"{
  SSL_CTX_sess_set_get_cb(ctx_.get(), cb);
}",60,,566,2,,void
31338,BLOCK,-1,,"{
  SSL_CTX_set_tlsext_servername_callback(ctx_.get(), cb);
}",72,,570,2,,void
31349,BLOCK,-1,,"{
  SSL_CTX_set_keylog_callback(ctx_.get(), cb);
}",52,,574,2,,void
31361,BLOCK,-1,,"{
  if (key->GetKeyType() != KeyType::kKeyTypePrivate) {
    THROW_ERR_CRYPTO_INVALID_KEYTYPE(env);
    return Nothing<bool>();
  }

  ClearErrorOnReturn clear_error_on_return;
  if (!SSL_CTX_use_PrivateKey(ctx_.get(), key->GetAsymmetricKey().get())) {
    ThrowCryptoError(env, ERR_get_error(), ""SSL_CTX_use_PrivateKey"");
    return Nothing<bool>();
  }

  return Just(true);
}",71,,579,3,,void
31371,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_KEYTYPE(env);
    return Nothing<bool>();
  }",54,,580,2,,void
31391,BLOCK,-1,,"{
    ThrowCryptoError(env, ERR_get_error(), ""SSL_CTX_use_PrivateKey"");
    return Nothing<bool>();
  }",75,,586,2,,void
31405,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_GE(args.Length(), 1);  // Private key argument is mandatory

  BIOPointer bio(LoadBIO(env, args[0]));
  if (!bio)
    return;

  ByteSource passphrase;
  if (args[1]->IsString())
    passphrase = ByteSource::FromString(env, args[1].As<String>());
  // This redirection is necessary because the PasswordCallback expects a
  // pointer to a pointer to the passphrase ByteSource to allow passing in
  // const ByteSources.
  const ByteSource* pass_ptr = &passphrase;

  EVPKeyPointer key(
      PEM_read_bio_PrivateKey(bio.get(),
                              nullptr,
                              PasswordCallback,
                              &pass_ptr));

  if (!key)
    return ThrowCryptoError(env, ERR_get_error(), ""PEM_read_bio_PrivateKey"");

  if (!SSL_CTX_use_PrivateKey(sc->ctx_.get(), key.get()))
    return ThrowCryptoError(env, ERR_get_error(), ""SSL_CTX...",69,,594,2,,void
31438,BLOCK,-1,,<empty>,5,,604,2,,void
31448,BLOCK,-1,,<empty>,5,,608,2,,void
31481,BLOCK,-1,,<empty>,5,,621,2,,void
31500,BLOCK,-1,,<empty>,5,,624,2,,void
31510,BLOCK,-1,,"{
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
  Environment* env = sc->env();
  ClearErrorOnReturn clear_error_on_return;

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsString());

  const Utf8Value sigalgs(env->isolate(), args[0]);

  if (!SSL_CTX_set1_sigalgs_list(sc->ctx_.get(), *sigalgs))
    return ThrowCryptoError(env, ERR_get_error());
}",73,,627,2,,void
31560,BLOCK,-1,,<empty>,5,,639,2,,void
31569,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_EQ(args.Length(), 2);

  if (UNLIKELY(env->permission()->enabled())) {
    return THROW_ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED(
        env,
        ""Programmatic selection of OpenSSL engines is unsupported while the ""
        ""experimental permission model is enabled"");
  }

  CryptoErrorStore errors;
  Utf8Value engine_id(env->isolate(), args[1]);
  EnginePointer engine = LoadEngineById(*engine_id, &errors);
  if (!engine) {
    Local<Value> exception;
    if (errors.ToException(env).ToLocal(&exception))
      env->isolate()->ThrowException(exception);
    return;
  }

  if (!ENGINE_init(engine.get())) {
    return THROW_ERR_CRYPTO_OPERATION_FAILED(
        env, ""Failure to initialize engine"");
  }

  engine.finish_on_exit = true;

  Utf8Value key_name(env->isolate(), args[0]);
  EVPKeyPointer key(ENGINE_load_private_key(engine.get(), *key_name,
     ...",75,,643,2,,void
31601,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED(
        env,
        ""Programmatic selection of OpenSSL engines is unsupported while the ""
        ""experimental permission model is enabled"");
  }",47,,651,2,,void
31627,BLOCK,-1,,"{
    Local<Value> exception;
    if (errors.ToException(env).ToLocal(&exception))
      env->isolate()->ThrowException(exception);
    return;
  }",16,,661,2,,void
31644,BLOCK,-1,,<empty>,7,,664,2,,void
31661,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_OPERATION_FAILED(
        env, ""Failure to initialize engine"");
  }",35,,668,2,,void
31694,BLOCK,-1,,<empty>,5,,680,2,,void
31713,BLOCK,-1,,<empty>,5,,683,2,,void
31733,BLOCK,-1,,"{
  ClearErrorOnReturn clear_error_on_return;
  if (!bio) return Just(false);
  cert_.reset();
  issuer_.reset();

  // The SSL_CTX_use_certificate_chain call here is not from openssl, this is
  // the method implemented elsewhere in this file. The naming is a bit
  // confusing, unfortunately.
  if (SSL_CTX_use_certificate_chain(
          ctx_.get(), std::move(bio), &cert_, &issuer_) == 0) {
    ThrowCryptoError(env, ERR_get_error(), ""SSL_CTX_use_certificate_chain"");
    return Nothing<bool>();
  }
  return Just(true);
}",72,,689,3,,void
31738,BLOCK,-1,,<empty>,13,,691,2,,void
31767,BLOCK,-1,,"{
    ThrowCryptoError(env, ERR_get_error(), ""SSL_CTX_use_certificate_chain"");
    return Nothing<bool>();
  }",63,,699,2,,void
31781,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_GE(args.Length(), 1);  // Certificate argument is mandatory

  BIOPointer bio(LoadBIO(env, args[0]));
  USE(sc->AddCert(env, std::move(bio)));
}",70,,706,2,,void
31826,BLOCK,-1,,"{
  ClearErrorOnReturn clear_error_on_return;
  if (!bio) return;
  X509_STORE* cert_store = SSL_CTX_get_cert_store(ctx_.get());
  while (X509Pointer x509 = X509Pointer(PEM_read_bio_X509_AUX(
             bio.get(), nullptr, NoPasswordCallback, nullptr))) {
    if (cert_store == GetOrCreateRootCertStore()) {
      cert_store = NewRootCertStore();
      SSL_CTX_set_cert_store(ctx_.get(), cert_store);
    }
    CHECK_EQ(1, X509_STORE_add_cert(cert_store, x509.get()));
    CHECK_EQ(1, SSL_CTX_add_client_CA(ctx_.get(), x509.get()));
  }
}",54,,718,2,,void
31831,BLOCK,-1,,<empty>,13,,720,2,,void
31842,BLOCK,-1,,"{
    if (cert_store == GetOrCreateRootCertStore()) {
      cert_store = NewRootCertStore();
      SSL_CTX_set_cert_store(ctx_.get(), cert_store);
    }
    CHECK_EQ(1, X509_STORE_add_cert(cert_store, x509.get()));
    CHECK_EQ(1, SSL_CTX_add_client_CA(ctx_.get(), x509.get()));
  }",65,,723,1,,void
31847,BLOCK,-1,,"{
      cert_store = NewRootCertStore();
      SSL_CTX_set_cert_store(ctx_.get(), cert_store);
    }",51,,724,2,,void
31880,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_GE(args.Length(), 1);  // CA certificate argument is mandatory

  BIOPointer bio(LoadBIO(env, args[0]));
  sc->SetCACert(bio);
}",72,,733,2,,void
31920,BLOCK,-1,,"{
  ClearErrorOnReturn clear_error_on_return;
  if (!bio) return Just(false);

  DeleteFnPtr<X509_CRL, X509_CRL_free> crl(
      PEM_read_bio_X509_CRL(bio.get(), nullptr, NoPasswordCallback, nullptr));

  if (!crl) {
    THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""Failed to parse CRL"");
    return Nothing<bool>();
  }

  X509_STORE* cert_store = SSL_CTX_get_cert_store(ctx_.get());
  if (cert_store == GetOrCreateRootCertStore()) {
    cert_store = NewRootCertStore();
    SSL_CTX_set_cert_store(ctx_.get(), cert_store);
  }

  CHECK_EQ(1, X509_STORE_add_crl(cert_store, crl.get()));
  CHECK_EQ(1,
           X509_STORE_set_flags(
               cert_store, X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL));
  return Just(true);
}",76,,745,3,,void
31925,BLOCK,-1,,<empty>,13,,747,2,,void
31947,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""Failed to parse CRL"");
    return Nothing<bool>();
  }",13,,752,2,,void
31965,BLOCK,-1,,"{
    cert_store = NewRootCertStore();
    SSL_CTX_set_cert_store(ctx_.get(), cert_store);
  }",49,,758,2,,void
31997,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_GE(args.Length(), 1);  // CRL argument is mandatory

  BIOPointer bio(LoadBIO(env, args[0]));
  USE(sc->SetCRL(env, bio));
}",69,,770,2,,void
32037,BLOCK,-1,,"{
  ClearErrorOnReturn clear_error_on_return;
  auto store = GetOrCreateRootCertStore();

  // Increment reference count so global store is not deleted along with CTX.
  X509_STORE_up_ref(store);
  SSL_CTX_set_cert_store(ctx_.get(), store);
}",36,,782,1,,void
32055,BLOCK,-1,,"{
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
  sc->SetRootCerts();
}",75,,791,2,,void
32072,BLOCK,-1,,"{
  // BoringSSL doesn't allow API config of TLS1.3 cipher suites.
#ifndef OPENSSL_IS_BORINGSSL
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
  Environment* env = sc->env();
  ClearErrorOnReturn clear_error_on_return;

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsString());

  const Utf8Value ciphers(env->isolate(), args[0]);
  if (!SSL_CTX_set_ciphersuites(sc->ctx_.get(), *ciphers))
    return ThrowCryptoError(env, ERR_get_error(), ""Failed to set ciphers"");
#endif
}",78,,797,2,,void
32122,BLOCK,-1,,<empty>,5,,810,2,,void
32132,BLOCK,-1,,"{
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
  Environment* env = sc->env();
  ClearErrorOnReturn clear_error_on_return;

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsString());

  Utf8Value ciphers(env->isolate(), args[0]);
  if (!SSL_CTX_set_cipher_list(sc->ctx_.get(), *ciphers)) {
    unsigned long err = ERR_get_error();  // NOLINT(runtime/int)

    if (strlen(*ciphers) == 0 && ERR_GET_REASON(err) == SSL_R_NO_CIPHER_MATCH) {
      // TLS1.2 ciphers were deliberately cleared, so don't consider
      // SSL_R_NO_CIPHER_MATCH to be an error (this is how _set_cipher_suites()
      // works). If the user actually sets a value (like ""no-such-cipher""), then
      // that's actually an error.
      return;
    }
    return ThrowCryptoError(env, err, ""Failed to set ciphers"");
  }
}",73,,814,2,,void
32182,BLOCK,-1,,"{
    unsigned long err = ERR_get_error();  // NOLINT(runtime/int)

    if (strlen(*ciphers) == 0 && ERR_GET_REASON(err) == SSL_R_NO_CIPHER_MATCH) {
      // TLS1.2 ciphers were deliberately cleared, so don't consider
      // SSL_R_NO_CIPHER_MATCH to be an error (this is how _set_cipher_suites()
      // works). If the user actually sets a value (like ""no-such-cipher""), then
      // that's actually an error.
      return;
    }
    return ThrowCryptoError(env, err, ""Failed to set ciphers"");
  }",59,,824,2,,void
32198,BLOCK,-1,,"{
      // TLS1.2 ciphers were deliberately cleared, so don't consider
      // SSL_R_NO_CIPHER_MATCH to be an error (this is how _set_cipher_suites()
      // works). If the user actually sets a value (like ""no-such-cipher""), then
      // that's actually an error.
      return;
    }",80,,827,2,,void
32209,BLOCK,-1,,"{
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
  Environment* env = sc->env();

  CHECK_GE(args.Length(), 1);  // ECDH curve name argument is mandatory
  CHECK(args[0]->IsString());

  Utf8Value curve(env->isolate(), args[0]);

  if (curve != ""auto"" && !SSL_CTX_set1_curves_list(sc->ctx_.get(), *curve)) {
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""Failed to set ECDH curve"");
  }
}",75,,838,2,,void
32262,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""Failed to set ECDH curve"");
  }",77,,848,2,,void
32271,BLOCK,-1,,"{
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.This());
  Environment* env = sc->env();
  ClearErrorOnReturn clear_error_on_return;

  CHECK_GE(args.Length(), 1);  // DH argument is mandatory

  // If the user specified ""auto"" for dhparams, the JavaScript layer will pass
  // true to this function instead of the original string. Any other string
  // value will be interpreted as custom DH parameters below.
  if (args[0]->IsTrue()) {
    CHECK(SSL_CTX_set_dh_auto(sc->ctx_.get(), true));
    return;
  }

  DHPointer dh;
  {
    BIOPointer bio(LoadBIO(env, args[0]));
    if (!bio)
      return;

    dh.reset(PEM_read_bio_DHparams(bio.get(), nullptr, nullptr, nullptr));
  }

  // Invalid dhparam is silently discarded and DHE is no longer used.
  // TODO(tniessen): don't silently discard invalid dhparam.
  if (!dh)
    return;

  const BIGNUM* p;
  DH_get0_pqg(dh.get(), &p, nullptr, nullptr);
  const int size = BN_num_bits(p);
  if (size < 1024) {
    return THROW_ERR_INVALID...",73,,853,2,,void
32301,BLOCK,-1,,"{
    CHECK(SSL_CTX_set_dh_auto(sc->ctx_.get(), true));
    return;
  }",26,,864,2,,void
32313,BLOCK,9,,"{
    BIOPointer bio(LoadBIO(env, args[0]));
    if (!bio)
      return;

    dh.reset(PEM_read_bio_DHparams(bio.get(), nullptr, nullptr, nullptr));
  }",3,,870,9,,void
32324,BLOCK,-1,,<empty>,7,,873,2,,void
32341,BLOCK,-1,,<empty>,5,,881,2,,void
32362,BLOCK,-1,,"{
    return THROW_ERR_INVALID_ARG_VALUE(
        env, ""DH parameter is less than 1024 bits"");
  }",20,,886,2,,void
32368,BLOCK,-1,,<empty>,10,,889,1,,void
32373,BLOCK,-1,,"{
    args.GetReturnValue().Set(FIXED_ONE_BYTE_STRING(
        env->isolate(), ""DH parameter is less than 2048 bits""));
  }",27,,889,2,,void
32400,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_OPERATION_FAILED(
        env, ""Error setting temp DH parameter"");
  }",54,,894,2,,void
32409,BLOCK,-1,,"{
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsInt32());

  int version = args[0].As<Int32>()->Value();

  CHECK(SSL_CTX_set_min_proto_version(sc->ctx_.get(), version));
}",74,,900,2,,void
32456,BLOCK,-1,,"{
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsInt32());

  int version = args[0].As<Int32>()->Value();

  CHECK(SSL_CTX_set_max_proto_version(sc->ctx_.get(), version));
}",74,,912,2,,void
32503,BLOCK,-1,,"{
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_EQ(args.Length(), 0);

  long version =  // NOLINT(runtime/int)
    SSL_CTX_get_min_proto_version(sc->ctx_.get());
  args.GetReturnValue().Set(static_cast<uint32_t>(version));
}",74,,924,2,,void
32542,BLOCK,-1,,"{
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_EQ(args.Length(), 0);

  long version =  // NOLINT(runtime/int)
    SSL_CTX_get_max_proto_version(sc->ctx_.get());
  args.GetReturnValue().Set(static_cast<uint32_t>(version));
}",74,,935,2,,void
32581,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsNumber());

  int64_t val = args[0]->IntegerValue(env->context()).FromMaybe(0);

  SSL_CTX_set_options(sc->ctx_.get(),
                      static_cast<long>(val));  // NOLINT(runtime/int)
}",73,,946,2,,void
32642,BLOCK,-1,,"{
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
  Environment* env = sc->env();

  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());

  const Utf8Value sessionIdContext(env->isolate(), args[0]);
  const unsigned char* sid_ctx =
      reinterpret_cast<const unsigned char*>(*sessionIdContext);
  unsigned int sid_ctx_len = sessionIdContext.length();

  if (SSL_CTX_set_session_id_context(sc->ctx_.get(), sid_ctx, sid_ctx_len) == 1)
    return;

  BUF_MEM* mem;
  Local<String> message;

  BIOPointer bio(BIO_new(BIO_s_mem()));
  if (!bio) {
    message = FIXED_ONE_BYTE_STRING(env->isolate(),
                                    ""SSL_CTX_set_session_id_context error"");
  } else {
    ERR_print_errors(bio.get());
    BIO_get_mem_ptr(bio.get(), &mem);
    message = OneByteString(env->isolate(), mem->data, mem->length);
  }

  env->isolate()->ThrowException(Exception::TypeError(message));
}",46,,961,2,,void
32706,BLOCK,-1,,<empty>,5,,975,2,,void
32716,BLOCK,-1,,<empty>,,,,2,,<empty>
32722,BLOCK,-1,,"{
    message = FIXED_ONE_BYTE_STRING(env->isolate(),
                                    ""SSL_CTX_set_session_id_context error"");
  }",13,,981,2,,void
32732,BLOCK,-1,,"{
    ERR_print_errors(bio.get());
    BIO_get_mem_ptr(bio.get(), &mem);
    message = OneByteString(env->isolate(), mem->data, mem->length);
  }",10,,984,1,,void
32774,BLOCK,-1,,"{
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsInt32());

  int32_t sessionTimeout = args[0].As<Int32>()->Value();
  SSL_CTX_set_timeout(sc->ctx_.get(), sessionTimeout);
}",80,,993,2,,void
32820,BLOCK,-1,,"{
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
  sc->Reset();
}",68,,1004,2,,void
32837,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  std::vector<char> pass;
  bool ret = false;

  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
  ClearErrorOnReturn clear_error_on_return;

  if (args.Length() < 1) {
    return THROW_ERR_MISSING_ARGS(env, ""PFX certificate argument is mandatory"");
  }

  BIOPointer in(LoadBIO(env, args[0]));
  if (!in) {
    return THROW_ERR_CRYPTO_OPERATION_FAILED(
        env, ""Unable to load PFX certificate"");
  }

  if (args.Length() >= 2) {
    THROW_AND_RETURN_IF_NOT_BUFFER(env, args[1], ""Pass phrase"");
    Local<ArrayBufferView> abv = args[1].As<ArrayBufferView>();
    size_t passlen = abv->ByteLength();
    pass.resize(passlen + 1);
    abv->CopyContents(pass.data(), passlen);
    pass[passlen] = '\0';
  }

  // Free previous certs
  sc->issuer_.reset();
  sc->cert_.reset();

  X509_STORE* cert_store = SSL_CTX_get_cert_store(sc->ctx_.get());

  DeleteFnPtr<PKCS12, PKCS12_free> p12;
  EVPKeyPointer pkey;
  X509Pointer ...",73,,1011,2,,void
32867,BLOCK,-1,,"{
    return THROW_ERR_MISSING_ARGS(env, ""PFX certificate argument is mandatory"");
  }",26,,1021,2,,void
32882,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_OPERATION_FAILED(
        env, ""Unable to load PFX certificate"");
  }",12,,1026,2,,void
32894,BLOCK,-1,,"{
    THROW_AND_RETURN_IF_NOT_BUFFER(env, args[1], ""Pass phrase"");
    Local<ArrayBufferView> abv = args[1].As<ArrayBufferView>();
    size_t passlen = abv->ByteLength();
    pass.resize(passlen + 1);
    abv->CopyContents(pass.data(), passlen);
    pass[passlen] = '\0';
  }",27,,1031,2,,void
33080,BLOCK,-1,,"{
    // Add CA certs too
    for (int i = 0; i < sk_X509_num(extra_certs.get()); i++) {
      X509* ca = sk_X509_value(extra_certs.get(), i);

      if (cert_store == GetOrCreateRootCertStore()) {
        cert_store = NewRootCertStore();
        SSL_CTX_set_cert_store(sc->ctx_.get(), cert_store);
      }
      X509_STORE_add_cert(cert_store, ca);
      SSL_CTX_add_client_CA(sc->ctx_.get(), ca);
    }
    ret = true;
  }",59,,1068,2,,void
33082,BLOCK,-1,,<empty>,5,,1070,1,,void
33096,BLOCK,4,,"{
      X509* ca = sk_X509_value(extra_certs.get(), i);

      if (cert_store == GetOrCreateRootCertStore()) {
        cert_store = NewRootCertStore();
        SSL_CTX_set_cert_store(sc->ctx_.get(), cert_store);
      }
      X509_STORE_add_cert(cert_store, ca);
      SSL_CTX_add_client_CA(sc->ctx_.get(), ca);
    }",62,,1070,4,,void
33110,BLOCK,-1,,"{
        cert_store = NewRootCertStore();
        SSL_CTX_set_cert_store(sc->ctx_.get(), cert_store);
      }",53,,1073,2,,void
33139,BLOCK,-1,,"{
    // TODO(@jasnell): Should this use ThrowCryptoError?
    unsigned long err = ERR_get_error();  // NOLINT(runtime/int)
    const char* str = ERR_reason_error_string(err);
    str = str != nullptr ? str : ""Unknown error"";

    return env->ThrowError(str);
  }",13,,1083,2,,void
33167,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsString());

  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  MarkPopErrorOnReturn mark_pop_error_on_return;

  // SSL_CTX_set_client_cert_engine does not itself support multiple
  // calls by cleaning up before overwriting the client_cert_engine
  // internal context variable.
  // Instead of trying to fix up this problem we in turn also do not
  // support multiple calls to SetClientCertEngine.
  CHECK(!sc->client_cert_engine_provided_);

  if (UNLIKELY(env->permission()->enabled())) {
    return THROW_ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED(
        env,
        ""Programmatic selection of OpenSSL engines is unsupported while the ""
        ""experimental permission model is enabled"");
  }

  CryptoErrorStore errors;
  const Utf8Value engine_id(env->isolate(), args[0]);
  EnginePointer engine = LoadEngineById(*engine_id, &errors);
  if (!engine) {
    Local<Valu...",46,,1095,2,,void
33212,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED(
        env,
        ""Programmatic selection of OpenSSL engines is unsupported while the ""
        ""experimental permission model is enabled"");
  }",47,,1112,2,,void
33238,BLOCK,-1,,"{
    Local<Value> exception;
    if (errors.ToException(env).ToLocal(&exception))
      env->isolate()->ThrowException(exception);
    return;
  }",16,,1122,2,,void
33255,BLOCK,-1,,<empty>,7,,1125,2,,void
33278,BLOCK,-1,,<empty>,5,,1131,2,,void
33292,BLOCK,-1,,"{
  SecureContext* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  Local<Object> buff;
  if (!Buffer::New(wrap->env(), 48).ToLocal(&buff))
    return;

  memcpy(Buffer::Data(buff), wrap->ticket_key_name_, 16);
  memcpy(Buffer::Data(buff) + 16, wrap->ticket_key_hmac_, 16);
  memcpy(Buffer::Data(buff) + 32, wrap->ticket_key_aes_, 16);

  args.GetReturnValue().Set(buff);
}",76,,1136,2,,void
33322,BLOCK,-1,,<empty>,5,,1142,2,,void
33370,BLOCK,-1,,"{
  SecureContext* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK_GE(args.Length(), 1);  // Ticket keys argument is mandatory
  CHECK(args[0]->IsArrayBufferView());
  ArrayBufferViewContents<char> buf(args[0].As<ArrayBufferView>());

  CHECK_EQ(buf.length(), 48);

  memcpy(wrap->ticket_key_name_, buf.data(), 16);
  memcpy(wrap->ticket_key_hmac_, buf.data() + 16, 16);
  memcpy(wrap->ticket_key_aes_, buf.data() + 32, 16);

  args.GetReturnValue().Set(true);
}",76,,1151,2,,void
33449,BLOCK,-1,,"{
  SecureContext* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  SSL_CTX_set_tlsext_ticket_key_cb(wrap->ctx_.get(), TicketKeyCallback);
}",46,,1171,2,,void
33475,BLOCK,-1,,"{
  static const int kTicketPartSize = 16;

  SecureContext* sc = static_cast<SecureContext*>(
      SSL_CTX_get_app_data(SSL_get_SSL_CTX(ssl)));

  Environment* env = sc->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Value> argv[3];

  if (!Buffer::Copy(
          env,
          reinterpret_cast<char*>(name),
          kTicketPartSize).ToLocal(&argv[0]) ||
      !Buffer::Copy(
          env,
          reinterpret_cast<char*>(iv),
          kTicketPartSize).ToLocal(&argv[1])) {
    return -1;
  }

  argv[2] = Boolean::New(env->isolate(), enc != 0);

  Local<Value> ret;
  if (!node::MakeCallback(
          env->isolate(),
          sc->object(),
          env->ticketkeycallback_string(),
          arraysize(argv),
          argv,
          {0, 0}).ToLocal(&ret) ||
      !ret->IsArray()) {
    return -1;
  }
  Local<Array> arr = ret.As<Array>();

  Local<Value> val;
  if (!arr->Get(env->context(), kTicketKeyReturnIndex).ToL...",47,,1183,7,,void
33550,BLOCK,-1,,"{
    return -1;
  }",47,,1202,2,,void
33609,BLOCK,-1,,"{
    return -1;
  }",24,,1216,2,,void
33650,BLOCK,-1,,"{
    return -1;
  }",24,,1223,2,,void
33668,BLOCK,-1,,<empty>,5,,1229,2,,void
33721,BLOCK,-1,,"{
    return -1;
  }",47,,1236,2,,void
33727,BLOCK,-1,,"{
    Local<Value> name_val;
    Local<Value> iv_val;
    if (!arr->Get(env->context(), kTicketKeyNameIndex).ToLocal(&name_val) ||
        !arr->Get(env->context(), kTicketKeyIVIndex).ToLocal(&iv_val) ||
        Buffer::Length(name_val) != kTicketPartSize ||
        Buffer::Length(iv_val) != kTicketPartSize) {
      return -1;
    }

    name_val.As<ArrayBufferView>()->CopyContents(name, kTicketPartSize);
    iv_val.As<ArrayBufferView>()->CopyContents(iv, kTicketPartSize);
  }",12,,1240,2,,void
33786,BLOCK,-1,,"{
      return -1;
    }",52,,1246,2,,void
33831,BLOCK,-1,,"{
    EVP_EncryptInit_ex(ectx,
                       EVP_aes_128_cbc(),
                       nullptr,
                       aes_key.data(),
                       iv);
  }",12,,1262,2,,void
33842,BLOCK,-1,,"{
    EVP_DecryptInit_ex(ectx,
                       EVP_aes_128_cbc(),
                       nullptr,
                       aes_key.data(),
                       iv);
  }",10,,1268,1,,void
33863,BLOCK,-1,,"{
  SecureContext* sc = static_cast<SecureContext*>(
      SSL_CTX_get_app_data(SSL_get_SSL_CTX(ssl)));

  if (enc) {
    memcpy(name, sc->ticket_key_name_, sizeof(sc->ticket_key_name_));
    if (CSPRNG(iv, 16).is_err() ||
        EVP_EncryptInit_ex(
            ectx, EVP_aes_128_cbc(), nullptr, sc->ticket_key_aes_, iv) <= 0 ||
        HMAC_Init_ex(hctx,
                     sc->ticket_key_hmac_,
                     sizeof(sc->ticket_key_hmac_),
                     EVP_sha256(),
                     nullptr) <= 0) {
      return -1;
    }
    return 1;
  }

  if (memcmp(name, sc->ticket_key_name_, sizeof(sc->ticket_key_name_)) != 0) {
    // The ticket key name does not match. Discard the ticket.
    return 0;
  }

  if (EVP_DecryptInit_ex(ectx, EVP_aes_128_cbc(), nullptr, sc->ticket_key_aes_,
                         iv) <= 0 ||
      HMAC_Init_ex(hctx, sc->ticket_key_hmac_, sizeof(sc->ticket_key_hmac_),
                   EVP_sha256(), nullptr) <= 0) {
    return -1;
  }
  retur...",57,,1284,7,,void
33874,BLOCK,-1,,"{
    memcpy(name, sc->ticket_key_name_, sizeof(sc->ticket_key_name_));
    if (CSPRNG(iv, 16).is_err() ||
        EVP_EncryptInit_ex(
            ectx, EVP_aes_128_cbc(), nullptr, sc->ticket_key_aes_, iv) <= 0 ||
        HMAC_Init_ex(hctx,
                     sc->ticket_key_hmac_,
                     sizeof(sc->ticket_key_hmac_),
                     EVP_sha256(),
                     nullptr) <= 0) {
      return -1;
    }
    return 1;
  }",12,,1288,2,,void
33916,BLOCK,-1,,"{
      return -1;
    }",37,,1297,2,,void
33934,BLOCK,-1,,"{
    // The ticket key name does not match. Discard the ticket.
    return 0;
  }",78,,1303,2,,void
33962,BLOCK,-1,,"{
    return -1;
  }",49,,1311,2,,void
33972,BLOCK,-1,,"{
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, info.This());
  Local<External> ext = External::New(info.GetIsolate(), sc->ctx_.get());
  info.GetReturnValue().Set(ext);
}",72,,1317,2,,void
34013,BLOCK,-1,,"{
  SecureContext* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  Environment* env = wrap->env();
  X509* cert;

  if (primary)
    cert = wrap->cert_.get();
  else
    cert = wrap->issuer_.get();
  if (cert == nullptr)
    return args.GetReturnValue().SetNull();

  int size = i2d_X509(cert, nullptr);
  Local<Object> buff;
  if (!Buffer::New(env, size).ToLocal(&buff))
    return;
  unsigned char* serialized = reinterpret_cast<unsigned char*>(
      Buffer::Data(buff));
  i2d_X509(cert, &serialized);

  args.GetReturnValue().Set(buff);
}",77,,1325,2,,void
34032,BLOCK,-1,,<empty>,5,,1332,2,,void
34042,BLOCK,-1,,<empty>,5,,1334,1,,void
34055,BLOCK,-1,,<empty>,5,,1336,2,,void
34088,BLOCK,-1,,<empty>,5,,1341,2,,void
34118,BLOCK,-1,,"{
  ERR_clear_error();
  MarkPopErrorOnReturn mark_pop_error_on_return;

  BIOPointer bio(BIO_new_file(file, ""r""));
  if (!bio)
    return ERR_get_error();

  while (X509Pointer x509 = X509Pointer(PEM_read_bio_X509(
             bio.get(), nullptr, NoPasswordCallback, nullptr))) {
    X509_STORE_add_cert(store, x509.get());
  }

  unsigned long err = ERR_peek_error();  // NOLINT(runtime/int)
  // Ignore error if its EOF/no start line found.
  if (ERR_GET_LIB(err) == ERR_LIB_PEM &&
      ERR_GET_REASON(err) == PEM_R_NO_START_LINE) {
    return 0;
  }

  return err;
}",23,,1352,3,,void
34129,BLOCK,-1,,<empty>,5,,1358,2,,void
34133,BLOCK,-1,,"{
    X509_STORE_add_cert(store, x509.get());
  }",65,,1361,1,,void
34154,BLOCK,-1,,"{
    return 0;
  }",51,,1368,2,,void
34163,BLOCK,-1,,"{
  if (file.empty()) return;
  ClearErrorOnReturn clear_error_on_return;
  X509_STORE* store = GetOrCreateRootCertStore();
  if (auto err = AddCertsFromFile(store, file.c_str())) {
    char buf[256];
    ERR_error_string_n(err, buf, sizeof(buf));
    fprintf(stderr,
            ""Warning: Ignoring extra certs from `%s`, load failed: %s\n"",
            file.c_str(),
            buf);
  } else {
    extra_root_certs_loaded = true;
  }
}",47,,1377,2,,void
34169,BLOCK,-1,,<empty>,21,,1378,2,,void
34177,BLOCK,-1,,<empty>,7,,1381,1,,void
34187,BLOCK,-1,,"{
    char buf[256];
    ERR_error_string_n(err, buf, sizeof(buf));
    fprintf(stderr,
            ""Warning: Ignoring extra certs from `%s`, load failed: %s\n"",
            file.c_str(),
            buf);
  }",57,,1381,2,,void
34203,BLOCK,-1,,"{
    extra_root_certs_loaded = true;
  }",10,,1388,1,,void
34211,BLOCK,-1,,"{
  return args.GetReturnValue().Set(extra_root_certs_loaded);
}",46,,1395,2,,void
34239,BLOCK,-1,,<empty>,1,,1,1,,ANY
34244,BLOCK,-1,,"{
    Local<FunctionTemplate> t = NewFunctionTemplate(isolate, callback);

    const PropertyAttribute attributes =
        static_cast<PropertyAttribute>(ReadOnly | DontDelete);

    t->InstanceTemplate()->SetInternalFieldCount(
        DiffieHellman::kInternalFieldCount);

    SetProtoMethod(isolate, t, ""generateKeys"", GenerateKeys);
    SetProtoMethod(isolate, t, ""computeSecret"", ComputeSecret);
    SetProtoMethodNoSideEffect(isolate, t, ""getPrime"", GetPrime);
    SetProtoMethodNoSideEffect(isolate, t, ""getGenerator"", GetGenerator);
    SetProtoMethodNoSideEffect(isolate, t, ""getPublicKey"", GetPublicKey);
    SetProtoMethodNoSideEffect(isolate, t, ""getPrivateKey"", GetPrivateKey);
    SetProtoMethod(isolate, t, ""setPublicKey"", SetPublicKey);
    SetProtoMethod(isolate, t, ""setPrivateKey"", SetPrivateKey);

    Local<FunctionTemplate> verify_error_getter_templ =
        FunctionTemplate::New(isolate,
                              DiffieHellman::VerifyErrorGetter,
                   ...",66,,64,3,,void
34371,BLOCK,-1,,"{
    const BIGNUM* p;
    DH_get0_pqg(dh, &p, nullptr, nullptr);
    return p;
  }",52,,355,2,,void
34386,BLOCK,-1,,"{
    const BIGNUM* g;
    DH_get0_pqg(dh, nullptr, nullptr, &g);
    return g;
  }",52,,363,2,,void
34401,BLOCK,-1,,"{
    const BIGNUM* pub_key;
    DH_get0_key(dh, &pub_key, nullptr);
    return pub_key;
  }",52,,371,2,,void
34415,BLOCK,-1,,"{
    const BIGNUM* priv_key;
    DH_get0_key(dh, nullptr, &priv_key);
    return priv_key;
  }",52,,379,2,,void
34430,BLOCK,-1,,"{ return DH_set0_key(dh, num, nullptr); }",34,,461,3,,void
34442,BLOCK,-1,,"{ return DH_set0_key(dh, nullptr, num); }",34,,467,3,,void
34471,BLOCK,-1,,<empty>,1,,1,1,,ANY
34479,BLOCK,-1,,"{
  // DH_size returns number of bytes in a prime number.
  // DH_compute_key returns number of bytes in a remainder of exponent, which
  // may have less bytes than a prime number. Therefore add 0-padding to the
  // allocated buffer.
  const size_t prime_size = length;
  if (remainder_size != prime_size) {
    CHECK_LT(remainder_size, prime_size);
    const size_t padding = prime_size - remainder_size;
    memmove(data + padding, data, remainder_size);
    memset(data, 0, padding);
  }
}",48,,41,4,,void
34488,BLOCK,-1,,"{
    CHECK_LT(remainder_size, prime_size);
    const size_t padding = prime_size - remainder_size;
    memmove(data + padding, data, remainder_size);
    memset(data, 0, padding);
  }",37,,47,2,,void
34513,BLOCK,-1,,"{
  MakeWeak();
}",46,,57,3,,void
34518,BLOCK,-1,,"{
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();
  auto make = [&](Local<String> name, FunctionCallback callback) {
    Local<FunctionTemplate> t = NewFunctionTemplate(isolate, callback);

    const PropertyAttribute attributes =
        static_cast<PropertyAttribute>(ReadOnly | DontDelete);

    t->InstanceTemplate()->SetInternalFieldCount(
        DiffieHellman::kInternalFieldCount);

    SetProtoMethod(isolate, t, ""generateKeys"", GenerateKeys);
    SetProtoMethod(isolate, t, ""computeSecret"", ComputeSecret);
    SetProtoMethodNoSideEffect(isolate, t, ""getPrime"", GetPrime);
    SetProtoMethodNoSideEffect(isolate, t, ""getGenerator"", GetGenerator);
    SetProtoMethodNoSideEffect(isolate, t, ""getPublicKey"", GetPublicKey);
    SetProtoMethodNoSideEffect(isolate, t, ""getPrivateKey"", GetPrivateKey);
    SetProtoMethod(isolate, t, ""setPublicKey"", SetPublicKey);
    SetProtoMethod(isolate, t, ""setPrivateKey"", SetPrivateKey);

    Local<FunctionTemplate> ver...",72,,61,3,,void
34584,BLOCK,-1,,"{
  registry->Register(New);
  registry->Register(DiffieHellmanGroup);

  registry->Register(GenerateKeys);
  registry->Register(ComputeSecret);
  registry->Register(GetPrime);
  registry->Register(GetGenerator);
  registry->Register(GetPublicKey);
  registry->Register(GetPrivateKey);
  registry->Register(SetPublicKey);
  registry->Register(SetPrivateKey);

  registry->Register(DiffieHellman::VerifyErrorGetter);
  registry->Register(DiffieHellman::Stateless);

  DHKeyPairGenJob::RegisterExternalReferences(registry);
  DHKeyExportJob::RegisterExternalReferences(registry);
  DHBitsJob::RegisterExternalReferences(registry);
}",42,,112,2,,void
34669,BLOCK,-1,,"{
  dh_.reset(DH_new());
  if (!DH_generate_parameters_ex(dh_.get(), primeLength, g, nullptr))
    return false;
  return VerifyContext();
}",50,,133,3,,void
34685,BLOCK,-1,,<empty>,5,,136,2,,void
34694,BLOCK,-1,,"{
  tracker->TrackFieldWithSize(""dh"", dh_ ? kSizeOf_DH : 0);
}",62,,140,2,,void
34709,BLOCK,-1,,"{
  dh_.reset(DH_new());
  CHECK_GE(g, 2);
  BignumPointer bn_g(BN_new());
  return bn_g && BN_set_word(bn_g.get(), g) &&
         DH_set0_pqg(dh_.get(), bn_p.release(), nullptr, bn_g.release()) &&
         VerifyContext();
}",55,,144,3,,void
34753,BLOCK,-1,,"{
  dh_.reset(DH_new());
  if (p_len <= 0) {
    ERR_put_error(ERR_LIB_BN, BN_F_BN_GENERATE_PRIME_EX,
      BN_R_BITS_TOO_SMALL, __FILE__, __LINE__);
    return false;
  }
  if (g <= 1) {
    ERR_put_error(ERR_LIB_DH, DH_F_DH_BUILTIN_GENPARAMS,
      DH_R_BAD_GENERATOR, __FILE__, __LINE__);
    return false;
  }
  BIGNUM* bn_p =
      BN_bin2bn(reinterpret_cast<const unsigned char*>(p), p_len, nullptr);
  BIGNUM* bn_g = BN_new();
  if (!BN_set_word(bn_g, g) ||
      !DH_set0_pqg(dh_.get(), bn_p, nullptr, bn_g)) {
    BN_free(bn_p);
    BN_free(bn_g);
    return false;
  }
  return VerifyContext();
}",59,,153,4,,void
34763,BLOCK,-1,,"{
    ERR_put_error(ERR_LIB_BN, BN_F_BN_GENERATE_PRIME_EX,
      BN_R_BITS_TOO_SMALL, __FILE__, __LINE__);
    return false;
  }",19,,155,2,,void
34769,BLOCK,1,,<empty>,,,,1,,void
34772,BLOCK,1,,<empty>,,,,1,,void
34780,BLOCK,-1,,"{
    ERR_put_error(ERR_LIB_DH, DH_F_DH_BUILTIN_GENPARAMS,
      DH_R_BAD_GENERATOR, __FILE__, __LINE__);
    return false;
  }",15,,160,2,,void
34786,BLOCK,1,,<empty>,,,,1,,void
34789,BLOCK,1,,<empty>,,,,1,,void
34821,BLOCK,-1,,"{
    BN_free(bn_p);
    BN_free(bn_g);
    return false;
  }",53,,169,2,,void
34837,BLOCK,-1,,"{
  dh_.reset(DH_new());
  if (p_len <= 0) {
    ERR_put_error(ERR_LIB_BN, BN_F_BN_GENERATE_PRIME_EX,
      BN_R_BITS_TOO_SMALL, __FILE__, __LINE__);
    return false;
  }
  if (g_len <= 0) {
    ERR_put_error(ERR_LIB_DH, DH_F_DH_BUILTIN_GENPARAMS,
      DH_R_BAD_GENERATOR, __FILE__, __LINE__);
    return false;
  }
  BIGNUM* bn_g =
      BN_bin2bn(reinterpret_cast<const unsigned char*>(g), g_len, nullptr);
  if (BN_is_zero(bn_g) || BN_is_one(bn_g)) {
    BN_free(bn_g);
    ERR_put_error(ERR_LIB_DH, DH_F_DH_BUILTIN_GENPARAMS,
      DH_R_BAD_GENERATOR, __FILE__, __LINE__);
    return false;
  }
  BIGNUM* bn_p =
      BN_bin2bn(reinterpret_cast<const unsigned char*>(p), p_len, nullptr);
  if (!DH_set0_pqg(dh_.get(), bn_p, nullptr, bn_g)) {
    BN_free(bn_p);
    BN_free(bn_g);
    return false;
  }
  return VerifyContext();
}",78,,177,5,,void
34847,BLOCK,-1,,"{
    ERR_put_error(ERR_LIB_BN, BN_F_BN_GENERATE_PRIME_EX,
      BN_R_BITS_TOO_SMALL, __FILE__, __LINE__);
    return false;
  }",19,,179,2,,void
34853,BLOCK,1,,<empty>,,,,1,,void
34856,BLOCK,1,,<empty>,,,,1,,void
34864,BLOCK,-1,,"{
    ERR_put_error(ERR_LIB_DH, DH_F_DH_BUILTIN_GENPARAMS,
      DH_R_BAD_GENERATOR, __FILE__, __LINE__);
    return false;
  }",19,,184,2,,void
34870,BLOCK,1,,<empty>,,,,1,,void
34873,BLOCK,1,,<empty>,,,,1,,void
34892,BLOCK,-1,,"{
    BN_free(bn_g);
    ERR_put_error(ERR_LIB_DH, DH_F_DH_BUILTIN_GENPARAMS,
      DH_R_BAD_GENERATOR, __FILE__, __LINE__);
    return false;
  }",44,,191,2,,void
34900,BLOCK,1,,<empty>,,,,1,,void
34903,BLOCK,1,,<empty>,,,,1,,void
34926,BLOCK,-1,,"{
    BN_free(bn_p);
    BN_free(bn_g);
    return false;
  }",53,,199,2,,void
34942,BLOCK,-1,,"{
  return BignumPointer(p(nullptr));
}",46,,210,1,,void
34950,BLOCK,-1,,<empty>,,,,1,,<empty>
34955,BLOCK,-1,,"{
#define V(n, p)                                                                \
  if (StringEqualNoCase(name, n)) return InstantiateStandardizedGroup<p>
  V(""modp1"", BN_get_rfc2409_prime_768);
  V(""modp2"", BN_get_rfc2409_prime_1024);
  V(""modp5"", BN_get_rfc3526_prime_1536);
  V(""modp14"", BN_get_rfc3526_prime_2048);
  V(""modp15"", BN_get_rfc3526_prime_3072);
  V(""modp16"", BN_get_rfc3526_prime_4096);
  V(""modp17"", BN_get_rfc3526_prime_6144);
  V(""modp18"", BN_get_rfc3526_prime_8192);
#undef V
  return nullptr;
}",79,,218,2,,void
34958,BLOCK,1,,<empty>,,,,2,,void
34963,BLOCK,-1,,<empty>,3,,221,2,,void
34968,BLOCK,1,,<empty>,,,,2,,void
34973,BLOCK,-1,,<empty>,3,,222,2,,void
34978,BLOCK,1,,<empty>,,,,2,,void
34983,BLOCK,-1,,<empty>,3,,223,2,,void
34988,BLOCK,1,,<empty>,,,,2,,void
34993,BLOCK,-1,,<empty>,3,,224,2,,void
34998,BLOCK,1,,<empty>,,,,2,,void
35003,BLOCK,-1,,<empty>,3,,225,2,,void
35008,BLOCK,1,,<empty>,,,,2,,void
35013,BLOCK,-1,,<empty>,3,,226,2,,void
35018,BLOCK,1,,<empty>,,,,2,,void
35023,BLOCK,-1,,<empty>,3,,227,2,,void
35028,BLOCK,1,,<empty>,,,,2,,void
35033,BLOCK,-1,,<empty>,3,,228,2,,void
35042,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  DiffieHellman* diffieHellman = new DiffieHellman(env, args.This());

  CHECK_EQ(args.Length(), 1);
  THROW_AND_RETURN_IF_NOT_STRING(env, args[0], ""Group name"");

  bool initialized = false;

  const node::Utf8Value group_name(env->isolate(), args[0]);
  auto group = FindDiffieHellmanGroup(*group_name);
  if (group == nullptr)
    return THROW_ERR_CRYPTO_UNKNOWN_DH_GROUP(env);

  initialized = diffieHellman->Init(group(), kStandardizedGenerator);
  if (!initialized)
    THROW_ERR_CRYPTO_INITIALIZATION_FAILED(env);
}",46,,234,2,,void
35096,BLOCK,-1,,<empty>,5,,246,2,,void
35111,BLOCK,-1,,<empty>,5,,250,2,,void
35118,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  DiffieHellman* diffieHellman =
      new DiffieHellman(env, args.This());
  bool initialized = false;

  if (args.Length() == 2) {
    if (args[0]->IsInt32()) {
      if (args[1]->IsInt32()) {
        initialized = diffieHellman->Init(args[0].As<Int32>()->Value(),
                                          args[1].As<Int32>()->Value());
      }
    } else {
      ArrayBufferOrViewContents<char> arg0(args[0]);
      if (UNLIKELY(!arg0.CheckSizeInt32()))
        return THROW_ERR_OUT_OF_RANGE(env, ""prime is too big"");
      if (args[1]->IsInt32()) {
        initialized = diffieHellman->Init(arg0.data(),
                                          arg0.size(),
                                          args[1].As<Int32>()->Value());
      } else {
        ArrayBufferOrViewContents<char> arg1(args[1]);
        if (UNLIKELY(!arg1.CheckSizeInt32()))
          return THROW_ERR_OUT_OF_RANGE(env, ""generator is too big"");
        initialized ...",66,,254,2,,void
35148,BLOCK,-1,,"{
    if (args[0]->IsInt32()) {
      if (args[1]->IsInt32()) {
        initialized = diffieHellman->Init(args[0].As<Int32>()->Value(),
                                          args[1].As<Int32>()->Value());
      }
    } else {
      ArrayBufferOrViewContents<char> arg0(args[0]);
      if (UNLIKELY(!arg0.CheckSizeInt32()))
        return THROW_ERR_OUT_OF_RANGE(env, ""prime is too big"");
      if (args[1]->IsInt32()) {
        initialized = diffieHellman->Init(arg0.data(),
                                          arg0.size(),
                                          args[1].As<Int32>()->Value());
      } else {
        ArrayBufferOrViewContents<char> arg1(args[1]);
        if (UNLIKELY(!arg1.CheckSizeInt32()))
          return THROW_ERR_OUT_OF_RANGE(env, ""generator is too big"");
        initialized = diffieHellman->Init(arg0.data(), arg0.size(),
                                          arg1.data(), arg1.size());
      }
    }
  }",27,,260,2,,void
35156,BLOCK,-1,,"{
      if (args[1]->IsInt32()) {
        initialized = diffieHellman->Init(args[0].As<Int32>()->Value(),
                                          args[1].As<Int32>()->Value());
      }
    }",29,,261,2,,void
35164,BLOCK,-1,,"{
        initialized = diffieHellman->Init(args[0].As<Int32>()->Value(),
                                          args[1].As<Int32>()->Value());
      }",31,,262,2,,void
35190,BLOCK,-1,,"{
      ArrayBufferOrViewContents<char> arg0(args[0]);
      if (UNLIKELY(!arg0.CheckSizeInt32()))
        return THROW_ERR_OUT_OF_RANGE(env, ""prime is too big"");
      if (args[1]->IsInt32()) {
        initialized = diffieHellman->Init(arg0.data(),
                                          arg0.size(),
                                          args[1].As<Int32>()->Value());
      } else {
        ArrayBufferOrViewContents<char> arg1(args[1]);
        if (UNLIKELY(!arg1.CheckSizeInt32()))
          return THROW_ERR_OUT_OF_RANGE(env, ""generator is too big"");
        initialized = diffieHellman->Init(arg0.data(), arg0.size(),
                                          arg1.data(), arg1.size());
      }
    }",12,,266,1,,void
35203,BLOCK,-1,,<empty>,9,,269,2,,void
35215,BLOCK,-1,,"{
        initialized = diffieHellman->Init(arg0.data(),
                                          arg0.size(),
                                          args[1].As<Int32>()->Value());
      }",31,,270,2,,void
35240,BLOCK,-1,,"{
        ArrayBufferOrViewContents<char> arg1(args[1]);
        if (UNLIKELY(!arg1.CheckSizeInt32()))
          return THROW_ERR_OUT_OF_RANGE(env, ""generator is too big"");
        initialized = diffieHellman->Init(arg0.data(), arg0.size(),
                                          arg1.data(), arg1.size());
      }",14,,274,1,,void
35253,BLOCK,-1,,<empty>,11,,277,2,,void
35283,BLOCK,-1,,"{
    return ThrowCryptoError(env, ERR_get_error(), ""Initialization failed"");
  }",21,,284,2,,void
35293,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  DiffieHellman* diffieHellman;
  ASSIGN_OR_RETURN_UNWRAP(&diffieHellman, args.Holder());

  if (!DH_generate_key(diffieHellman->dh_.get())) {
    return ThrowCryptoError(env, ERR_get_error(), ""Key generation failed"");
  }

  const BIGNUM* pub_key;
  DH_get0_key(diffieHellman->dh_.get(), &pub_key, nullptr);

  std::unique_ptr<BackingStore> bs;
  {
    const int size = BN_num_bytes(pub_key);
    CHECK_GE(size, 0);
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), size);
  }

  CHECK_EQ(static_cast<int>(bs->ByteLength()),
           BN_bn2binpad(pub_key,
                        static_cast<unsigned char*>(bs->Data()),
                        bs->ByteLength()));

  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
  Local<Value> buffer;
  if (!Buffer::New(env, ab, 0, ab->ByteLength()).ToLocal(&buffer)) return;
  args.GetReturnValue()....",75,,290,2,,void
35319,BLOCK,-1,,"{
    return ThrowCryptoError(env, ERR_get_error(), ""Key generation failed"");
  }",51,,296,2,,void
35343,BLOCK,9,,"{
    const int size = BN_num_bytes(pub_key);
    CHECK_GE(size, 0);
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), size);
  }",3,,304,9,,void
35430,BLOCK,-1,,<empty>,68,,318,2,,void
35446,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  DiffieHellman* dh;
  ASSIGN_OR_RETURN_UNWRAP(&dh, args.Holder());

  const BIGNUM* num = get_field(dh->dh_.get());
  if (num == nullptr)
    return THROW_ERR_CRYPTO_INVALID_STATE(env, err_if_null);

  std::unique_ptr<BackingStore> bs;
  {
    const int size = BN_num_bytes(num);
    CHECK_GE(size, 0);
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), size);
  }

  CHECK_EQ(static_cast<int>(bs->ByteLength()),
           BN_bn2binpad(num,
                        static_cast<unsigned char*>(bs->Data()),
                        bs->ByteLength()));

  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
  Local<Value> buffer;
  if (!Buffer::New(env, ab, 0, ab->ByteLength()).ToLocal(&buffer)) return;
  args.GetReturnValue().Set(buffer);
}",55,,325,4,,void
35477,BLOCK,-1,,<empty>,5,,333,2,,void
35489,BLOCK,9,,"{
    const int size = BN_num_bytes(num);
    CHECK_GE(size, 0);
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), size);
  }",3,,336,9,,void
35576,BLOCK,-1,,<empty>,68,,350,2,,void
35590,BLOCK,-1,,"{
  GetField(args, [](const DH* dh) -> const BIGNUM* {
    const BIGNUM* p;
    DH_get0_pqg(dh, &p, nullptr, nullptr);
    return p;
  }, ""p is null"");
}",71,,354,2,,void
35599,BLOCK,-1,,"{
  GetField(args, [](const DH* dh) -> const BIGNUM* {
    const BIGNUM* g;
    DH_get0_pqg(dh, nullptr, nullptr, &g);
    return g;
  }, ""g is null"");
}",75,,362,2,,void
35608,BLOCK,-1,,"{
  GetField(args, [](const DH* dh) -> const BIGNUM* {
    const BIGNUM* pub_key;
    DH_get0_key(dh, &pub_key, nullptr);
    return pub_key;
  }, ""No public key - did you forget to generate one?"");
}",75,,370,2,,void
35617,BLOCK,-1,,"{
  GetField(args, [](const DH* dh) -> const BIGNUM* {
    const BIGNUM* priv_key;
    DH_get0_key(dh, nullptr, &priv_key);
    return priv_key;
  }, ""No private key - did you forget to generate one?"");
}",76,,378,2,,void
35626,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  DiffieHellman* diffieHellman;
  ASSIGN_OR_RETURN_UNWRAP(&diffieHellman, args.Holder());

  ClearErrorOnReturn clear_error_on_return;

  CHECK_EQ(args.Length(), 1);
  ArrayBufferOrViewContents<unsigned char> key_buf(args[0]);
  if (UNLIKELY(!key_buf.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""secret is too big"");
  BignumPointer key(BN_bin2bn(key_buf.data(), key_buf.size(), nullptr));

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(),
                                      DH_size(diffieHellman->dh_.get()));
  }

  int size = DH_compute_key(static_cast<unsigned char*>(bs->Data()),
                            key.get(),
                            diffieHellman->dh_.get());

  if (size == -1) {
    int checkResult;
    int checked;

    checked = DH_check_pub_key(diffieHellman->dh_.get(),
            ...",76,,386,2,,void
35662,BLOCK,-1,,<empty>,5,,397,2,,void
35686,BLOCK,13,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(),
                                      DH_size(diffieHellman->dh_.get()));
  }",3,,401,13,,void
35735,BLOCK,-1,,"{
    int checkResult;
    int checked;

    checked = DH_check_pub_key(diffieHellman->dh_.get(),
                               key.get(),
                               &checkResult);

    if (!checked) {
      return ThrowCryptoError(env, ERR_get_error(), ""Invalid Key"");
    } else if (checkResult) {
      if (checkResult & DH_CHECK_PUBKEY_TOO_SMALL) {
        return THROW_ERR_CRYPTO_INVALID_KEYLEN(env,
            ""Supplied key is too small"");
      } else if (checkResult & DH_CHECK_PUBKEY_TOO_LARGE) {
        return THROW_ERR_CRYPTO_INVALID_KEYLEN(env,
            ""Supplied key is too large"");
      }
    }

    return THROW_ERR_CRYPTO_INVALID_KEYTYPE(env);
  }",19,,411,2,,void
35756,BLOCK,-1,,"{
      return ThrowCryptoError(env, ERR_get_error(), ""Invalid Key"");
    }",19,,419,2,,void
35763,BLOCK,-1,,<empty>,12,,421,1,,void
35766,BLOCK,-1,,"{
      if (checkResult & DH_CHECK_PUBKEY_TOO_SMALL) {
        return THROW_ERR_CRYPTO_INVALID_KEYLEN(env,
            ""Supplied key is too small"");
      } else if (checkResult & DH_CHECK_PUBKEY_TOO_LARGE) {
        return THROW_ERR_CRYPTO_INVALID_KEYLEN(env,
            ""Supplied key is too large"");
      }
    }",29,,421,2,,void
35771,BLOCK,-1,,"{
        return THROW_ERR_CRYPTO_INVALID_KEYLEN(env,
            ""Supplied key is too small"");
      }",52,,422,2,,void
35777,BLOCK,-1,,<empty>,14,,425,1,,void
35782,BLOCK,-1,,"{
        return THROW_ERR_CRYPTO_INVALID_KEYLEN(env,
            ""Supplied key is too large"");
      }",59,,425,2,,void
35847,BLOCK,-1,,<empty>,68,,441,2,,void
35863,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  DiffieHellman* dh;
  ASSIGN_OR_RETURN_UNWRAP(&dh, args.Holder());
  CHECK_EQ(args.Length(), 1);
  ArrayBufferOrViewContents<unsigned char> buf(args[0]);
  if (UNLIKELY(!buf.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""buf is too big"");
  BIGNUM* num = BN_bin2bn(buf.data(), buf.size(), nullptr);
  CHECK_NOT_NULL(num);
  CHECK_EQ(1, set_field(dh->dh_.get(), num));
}",78,,446,4,,void
35898,BLOCK,-1,,<empty>,5,,453,2,,void
35932,BLOCK,-1,,"{
  SetKey(args,
         [](DH* dh, BIGNUM* num) { return DH_set0_key(dh, num, nullptr); },
         ""Public key"");
}",75,,459,2,,void
35941,BLOCK,-1,,"{
  SetKey(args,
         [](DH* dh, BIGNUM* num) { return DH_set0_key(dh, nullptr, num); },
         ""Private key"");
}",76,,465,2,,void
35950,BLOCK,-1,,"{
  HandleScope scope(args.GetIsolate());

  DiffieHellman* diffieHellman;
  ASSIGN_OR_RETURN_UNWRAP(&diffieHellman, args.Holder());

  args.GetReturnValue().Set(diffieHellman->verifyError_);
}",80,,471,2,,void
35978,BLOCK,-1,,"{
  int codes;
  if (!DH_check(dh_.get(), &codes))
    return false;
  verifyError_ = codes;
  return true;
}",37,,480,1,,void
35989,BLOCK,-1,,<empty>,5,,483,2,,void
36004,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  if (args[*offset]->IsString()) {
    Utf8Value group_name(env->isolate(), args[*offset]);
    auto group = FindDiffieHellmanGroup(*group_name);
    if (group == nullptr) {
      THROW_ERR_CRYPTO_UNKNOWN_DH_GROUP(env);
      return Nothing<bool>();
    }

    params->params.prime = group();
    params->params.generator = kStandardizedGenerator;
    *offset += 1;
  } else {
    if (args[*offset]->IsInt32()) {
      int size = args[*offset].As<Int32>()->Value();
      if (size < 0) {
        THROW_ERR_OUT_OF_RANGE(env, ""Invalid prime size"");
        return Nothing<bool>();
      }
      params->params.prime = size;
    } else {
      ArrayBufferOrViewContents<unsigned char> input(args[*offset]);
      if (UNLIKELY(!input.CheckSizeInt32())) {
        THROW_ERR_OUT_OF_RANGE(env, ""prime is too big"");
        return Nothing<bool>();
      }
      params->params.prime = BignumPointer(
          BN_bin2bn(input.data(), input.size(), nu...",33,,506,5,,void
36021,BLOCK,-1,,"{
    Utf8Value group_name(env->isolate(), args[*offset]);
    auto group = FindDiffieHellmanGroup(*group_name);
    if (group == nullptr) {
      THROW_ERR_CRYPTO_UNKNOWN_DH_GROUP(env);
      return Nothing<bool>();
    }

    params->params.prime = group();
    params->params.generator = kStandardizedGenerator;
    *offset += 1;
  }",34,,509,2,,void
36042,BLOCK,-1,,"{
      THROW_ERR_CRYPTO_UNKNOWN_DH_GROUP(env);
      return Nothing<bool>();
    }",27,,512,2,,void
36066,BLOCK,-1,,"{
    if (args[*offset]->IsInt32()) {
      int size = args[*offset].As<Int32>()->Value();
      if (size < 0) {
        THROW_ERR_OUT_OF_RANGE(env, ""Invalid prime size"");
        return Nothing<bool>();
      }
      params->params.prime = size;
    } else {
      ArrayBufferOrViewContents<unsigned char> input(args[*offset]);
      if (UNLIKELY(!input.CheckSizeInt32())) {
        THROW_ERR_OUT_OF_RANGE(env, ""prime is too big"");
        return Nothing<bool>();
      }
      params->params.prime = BignumPointer(
          BN_bin2bn(input.data(), input.size(), nullptr));
    }

    CHECK(args[*offset + 1]->IsInt32());
    params->params.generator = args[*offset + 1].As<Int32>()->Value();
    *offset += 2;
  }",10,,520,1,,void
36075,BLOCK,-1,,"{
      int size = args[*offset].As<Int32>()->Value();
      if (size < 0) {
        THROW_ERR_OUT_OF_RANGE(env, ""Invalid prime size"");
        return Nothing<bool>();
      }
      params->params.prime = size;
    }",35,,521,2,,void
36093,BLOCK,-1,,"{
        THROW_ERR_OUT_OF_RANGE(env, ""Invalid prime size"");
        return Nothing<bool>();
      }",21,,523,2,,void
36107,BLOCK,-1,,"{
      ArrayBufferOrViewContents<unsigned char> input(args[*offset]);
      if (UNLIKELY(!input.CheckSizeInt32())) {
        THROW_ERR_OUT_OF_RANGE(env, ""prime is too big"");
        return Nothing<bool>();
      }
      params->params.prime = BignumPointer(
          BN_bin2bn(input.data(), input.size(), nullptr));
    }",12,,528,1,,void
36121,BLOCK,-1,,"{
        THROW_ERR_OUT_OF_RANGE(env, ""prime is too big"");
        return Nothing<bool>();
      }",46,,530,2,,void
36183,BLOCK,-1,,"{
  EVPKeyPointer key_params;
  if (BignumPointer* prime_fixed_value =
          std::get_if<BignumPointer>(&params->params.prime)) {
    DHPointer dh(DH_new());
    if (!dh)
      return EVPKeyCtxPointer();

    BIGNUM* prime = prime_fixed_value->get();
    BignumPointer bn_g(BN_new());
    if (!BN_set_word(bn_g.get(), params->params.generator) ||
        !DH_set0_pqg(dh.get(), prime, nullptr, bn_g.get())) {
      return EVPKeyCtxPointer();
    }

    prime_fixed_value->release();
    bn_g.release();

    key_params = EVPKeyPointer(EVP_PKEY_new());
    CHECK(key_params);
    CHECK_EQ(EVP_PKEY_assign_DH(key_params.get(), dh.release()), 1);
  } else if (int* prime_size = std::get_if<int>(&params->params.prime)) {
    EVPKeyCtxPointer param_ctx(EVP_PKEY_CTX_new_id(EVP_PKEY_DH, nullptr));
    EVP_PKEY* raw_params = nullptr;
    if (!param_ctx ||
        EVP_PKEY_paramgen_init(param_ctx.get()) <= 0 ||
        EVP_PKEY_CTX_set_dh_paramgen_prime_len(
            param_ctx.get(),
         ...",68,,546,2,,void
36186,BLOCK,-1,,<empty>,7,,548,1,,void
36202,BLOCK,-1,,"{
    DHPointer dh(DH_new());
    if (!dh)
      return EVPKeyCtxPointer();

    BIGNUM* prime = prime_fixed_value->get();
    BignumPointer bn_g(BN_new());
    if (!BN_set_word(bn_g.get(), params->params.generator) ||
        !DH_set0_pqg(dh.get(), prime, nullptr, bn_g.get())) {
      return EVPKeyCtxPointer();
    }

    prime_fixed_value->release();
    bn_g.release();

    key_params = EVPKeyPointer(EVP_PKEY_new());
    CHECK(key_params);
    CHECK_EQ(EVP_PKEY_assign_DH(key_params.get(), dh.release()), 1);
  }",62,,549,2,,void
36209,BLOCK,-1,,<empty>,7,,552,2,,void
36247,BLOCK,-1,,"{
      return EVPKeyCtxPointer();
    }",61,,557,2,,void
36276,BLOCK,-1,,<empty>,10,,567,1,,void
36278,BLOCK,-1,,<empty>,14,,567,1,,void
36292,BLOCK,-1,,"{
    EVPKeyCtxPointer param_ctx(EVP_PKEY_CTX_new_id(EVP_PKEY_DH, nullptr));
    EVP_PKEY* raw_params = nullptr;
    if (!param_ctx ||
        EVP_PKEY_paramgen_init(param_ctx.get()) <= 0 ||
        EVP_PKEY_CTX_set_dh_paramgen_prime_len(
            param_ctx.get(),
            *prime_size) <= 0 ||
        EVP_PKEY_CTX_set_dh_paramgen_generator(
            param_ctx.get(),
            params->params.generator) <= 0 ||
        EVP_PKEY_paramgen(param_ctx.get(), &raw_params) <= 0) {
      return EVPKeyCtxPointer();
    }

    key_params = EVPKeyPointer(raw_params);
  }",73,,567,2,,void
36346,BLOCK,-1,,"{
      return EVPKeyCtxPointer();
    }",63,,578,2,,void
36354,BLOCK,-1,,"{
    UNREACHABLE();
  }",10,,583,1,,void
36375,BLOCK,-1,,<empty>,5,,589,2,,void
36386,BLOCK,-1,,"{
  return Just(true);
}",32,,597,4,,void
36397,BLOCK,-1,,"{
  CHECK_NE(key_data->GetKeyType(), kKeyTypeSecret);

  switch (format) {
    case kWebCryptoKeyFormatPKCS8:
      if (key_data->GetKeyType() != kKeyTypePrivate)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_PKCS8_Export(key_data.get(), out);
    case kWebCryptoKeyFormatSPKI:
      if (key_data->GetKeyType() != kKeyTypePublic)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_SPKI_Export(key_data.get(), out);
    default:
      UNREACHABLE();
  }
}",22,,605,5,,void
36406,BLOCK,-1,,"{
    case kWebCryptoKeyFormatPKCS8:
      if (key_data->GetKeyType() != kKeyTypePrivate)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_PKCS8_Export(key_data.get(), out);
    case kWebCryptoKeyFormatSPKI:
      if (key_data->GetKeyType() != kKeyTypePublic)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_SPKI_Export(key_data.get(), out);
    default:
      UNREACHABLE();
  }",19,,608,2,,void
36416,BLOCK,-1,,<empty>,9,,611,2,,void
36437,BLOCK,-1,,<empty>,9,,615,2,,void
36457,BLOCK,-1,,"{
  size_t out_size;

  EVPKeyCtxPointer ctx(EVP_PKEY_CTX_new(our_key.get(), nullptr));
  if (!ctx ||
      EVP_PKEY_derive_init(ctx.get()) <= 0 ||
      EVP_PKEY_derive_set_peer(ctx.get(), their_key.get()) <= 0 ||
      EVP_PKEY_derive(ctx.get(), nullptr, &out_size) <= 0)
    return ByteSource();

  ByteSource::Builder out(out_size);
  if (EVP_PKEY_derive(ctx.get(), out.data<unsigned char>(), &out_size) <= 0) {
    return ByteSource();
  }

  ZeroPadDiffieHellmanSecret(out_size, out.data<char>(), out.size());
  return std::move(out).release();
}",38,,625,3,,void
36501,BLOCK,-1,,<empty>,5,,633,2,,void
36521,BLOCK,-1,,"{
    return ByteSource();
  }",78,,636,2,,void
36547,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsObject() && args[1]->IsObject());
  KeyObjectHandle* our_key_object;
  ASSIGN_OR_RETURN_UNWRAP(&our_key_object, args[0].As<Object>());
  CHECK_EQ(our_key_object->Data()->GetKeyType(), kKeyTypePrivate);
  KeyObjectHandle* their_key_object;
  ASSIGN_OR_RETURN_UNWRAP(&their_key_object, args[1].As<Object>());
  CHECK_NE(their_key_object->Data()->GetKeyType(), kKeyTypeSecret);

  ManagedEVPPKey our_key = our_key_object->Data()->GetAsymmetricKey();
  ManagedEVPPKey their_key = their_key_object->Data()->GetAsymmetricKey();

  Local<Value> out;
  if (!StatelessDiffieHellmanThreadsafe(our_key, their_key)
          .ToBuffer(env)
              .ToLocal(&out)) return;

  if (Buffer::Length(out) == 0)
    return ThrowCryptoError(env, ERR_get_error(), ""diffieHellman failed"");

  args.GetReturnValue().Set(out);
}",72,,645,2,,void
36647,BLOCK,-1,,<empty>,31,,662,2,,void
36657,BLOCK,-1,,<empty>,5,,665,2,,void
36678,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[offset]->IsObject());  // public key
  CHECK(args[offset + 1]->IsObject());  // private key

  KeyObjectHandle* private_key;
  KeyObjectHandle* public_key;

  ASSIGN_OR_RETURN_UNWRAP(&public_key, args[offset], Nothing<bool>());
  ASSIGN_OR_RETURN_UNWRAP(&private_key, args[offset + 1], Nothing<bool>());

  if (private_key->Data()->GetKeyType() != kKeyTypePrivate ||
      public_key->Data()->GetKeyType() != kKeyTypePublic) {
    THROW_ERR_CRYPTO_INVALID_KEYTYPE(env);
    return Nothing<bool>();
  }

  params->public_key = public_key->Data();
  params->private_key = private_key->Data();

  return Just(true);
}",27,,674,5,,void
36741,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_KEYTYPE(env);
    return Nothing<bool>();
  }",59,,687,2,,void
36772,BLOCK,-1,,"{
  *result = out->ToArrayBuffer(env);
  return Just(!result->IsEmpty());
}",35,,702,5,,void
36794,BLOCK,-1,,"{
  *out = StatelessDiffieHellmanThreadsafe(
      params.private_key->GetAsymmetricKey(),
      params.public_key->GetAsymmetricKey());
  return true;
}",22,,710,4,,void
36819,BLOCK,-1,,"{
  ManagedEVPPKey pkey = key->GetAsymmetricKey();
  CHECK_EQ(EVP_PKEY_id(pkey.get()), EVP_PKEY_DH);
  return Just(true);
}",27,,720,4,,void
36857,BLOCK,-1,,<empty>,1,,1,1,,ANY
36884,BLOCK,-1,,<empty>,1,,1,1,,ANY
36889,BLOCK,-1,,"{
  EVPKeyCtxPointer param_ctx(EVP_PKEY_CTX_new_id(EVP_PKEY_DSA, nullptr));
  EVP_PKEY* raw_params = nullptr;

  if (!param_ctx ||
      EVP_PKEY_paramgen_init(param_ctx.get()) <= 0 ||
      EVP_PKEY_CTX_set_dsa_paramgen_bits(
          param_ctx.get(),
          params->params.modulus_bits) <= 0) {
    return EVPKeyCtxPointer();
  }

  if (params->params.divisor_bits != -1) {
    if (EVP_PKEY_CTX_set_dsa_paramgen_q_bits(
            param_ctx.get(), params->params.divisor_bits) <= 0) {
      return EVPKeyCtxPointer();
    }
  }

  if (EVP_PKEY_paramgen(param_ctx.get(), &raw_params) <= 0)
    return EVPKeyCtxPointer();

  EVPKeyPointer key_params(raw_params);
  EVPKeyCtxPointer key_ctx(EVP_PKEY_CTX_new(key_params.get(), nullptr));

  if (!key_ctx || EVP_PKEY_keygen_init(key_ctx.get()) <= 0)
    return EVPKeyCtxPointer();

  return key_ctx;
}",70,,40,2,,void
36923,BLOCK,-1,,"{
    return EVPKeyCtxPointer();
  }",46,,48,2,,void
36935,BLOCK,-1,,"{
    if (EVP_PKEY_CTX_set_dsa_paramgen_q_bits(
            param_ctx.get(), params->params.divisor_bits) <= 0) {
      return EVPKeyCtxPointer();
    }
  }",42,,52,2,,void
36948,BLOCK,1,,<empty>,,,,4,,void
36964,BLOCK,-1,,"{
      return EVPKeyCtxPointer();
    }",65,,54,2,,void
36977,BLOCK,-1,,<empty>,5,,60,2,,void
37002,BLOCK,-1,,<empty>,5,,66,2,,void
37014,BLOCK,-1,,"{
  CHECK(args[*offset]->IsUint32());  // modulus bits
  CHECK(args[*offset + 1]->IsInt32());  // divisor bits

  params->params.modulus_bits = args[*offset].As<Uint32>()->Value();
  params->params.divisor_bits = args[*offset + 1].As<Int32>()->Value();
  CHECK_GE(params->params.divisor_bits, -1);

  *offset += 2;

  return Just(true);
}",34,,85,5,,void
37088,BLOCK,-1,,"{
  return Just(true);
}",33,,101,4,,void
37099,BLOCK,-1,,"{
  CHECK_NE(key_data->GetKeyType(), kKeyTypeSecret);

  switch (format) {
    case kWebCryptoKeyFormatRaw:
      // Not supported for RSA keys of either type
      return WebCryptoKeyExportStatus::FAILED;
    case kWebCryptoKeyFormatPKCS8:
      if (key_data->GetKeyType() != kKeyTypePrivate)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_PKCS8_Export(key_data.get(), out);
    case kWebCryptoKeyFormatSPKI:
      if (key_data->GetKeyType() != kKeyTypePublic)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_SPKI_Export(key_data.get(), out);
    default:
      UNREACHABLE();
  }
}",22,,109,5,,void
37108,BLOCK,-1,,"{
    case kWebCryptoKeyFormatRaw:
      // Not supported for RSA keys of either type
      return WebCryptoKeyExportStatus::FAILED;
    case kWebCryptoKeyFormatPKCS8:
      if (key_data->GetKeyType() != kKeyTypePrivate)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_PKCS8_Export(key_data.get(), out);
    case kWebCryptoKeyFormatSPKI:
      if (key_data->GetKeyType() != kKeyTypePublic)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_SPKI_Export(key_data.get(), out);
    default:
      UNREACHABLE();
  }",19,,112,2,,void
37124,BLOCK,-1,,<empty>,9,,118,2,,void
37145,BLOCK,-1,,<empty>,9,,122,2,,void
37165,BLOCK,-1,,"{
  const BIGNUM* p;  // Modulus length
  const BIGNUM* q;  // Divisor length

  ManagedEVPPKey m_pkey = key->GetAsymmetricKey();
  Mutex::ScopedLock lock(*m_pkey.mutex());
  int type = EVP_PKEY_id(m_pkey.get());
  CHECK(type == EVP_PKEY_DSA);

  const DSA* dsa = EVP_PKEY_get0_DSA(m_pkey.get());
  CHECK_NOT_NULL(dsa);

  DSA_get0_pqg(dsa, &p, &q, nullptr);

  size_t modulus_length = BN_num_bits(p);
  size_t divisor_length = BN_num_bits(q);

  if (target
          ->Set(
              env->context(),
              env->modulus_length_string(),
              Number::New(env->isolate(), static_cast<double>(modulus_length)))
          .IsNothing() ||
      target
          ->Set(
              env->context(),
              env->divisor_length_string(),
              Number::New(env->isolate(), static_cast<double>(divisor_length)))
          .IsNothing()) {
    return Nothing<bool>();
  }

  return Just(true);
}",27,,132,4,,void
37275,BLOCK,-1,,"{
    return Nothing<bool>();
  }",25,,160,2,,void
37287,BLOCK,-1,,"{
  DsaKeyPairGenJob::Initialize(env, target);
  DSAKeyExportJob::Initialize(env, target);
}",57,,168,3,,void
37304,BLOCK,-1,,"{
  DsaKeyPairGenJob::RegisterExternalReferences(registry);
  DSAKeyExportJob::RegisterExternalReferences(registry);
}",70,,173,2,,void
37333,BLOCK,-1,,<empty>,1,,1,1,,ANY
37337,BLOCK,-1,,"{
    return OneByteString(env->isolate(), OBJ_nid2sn(curve.nid));
  }",80,,115,2,,void
37385,BLOCK,-1,,<empty>,1,,1,1,,ANY
37390,BLOCK,-1,,"{
  int nid = EC_curve_nist2nid(name);
  if (nid == NID_undef)
    nid = OBJ_sn2nid(name);
  return nid;
}",40,,41,2,,void
37400,BLOCK,-1,,<empty>,5,,44,2,,void
37411,BLOCK,-1,,"{
  int nid;
  if (strcmp(name, ""Ed25519"") == 0) {
    nid = EVP_PKEY_ED25519;
  } else if (strcmp(name, ""Ed448"") == 0) {
    nid = EVP_PKEY_ED448;
  } else if (strcmp(name, ""X25519"") == 0) {
    nid = EVP_PKEY_X25519;
  } else if (strcmp(name, ""X448"") == 0) {
    nid = EVP_PKEY_X448;
  } else {
    nid = NID_undef;
  }
  return nid;
}",43,,48,2,,void
37419,BLOCK,-1,,"{
    nid = EVP_PKEY_ED25519;
  }",37,,50,2,,void
37424,BLOCK,-1,,<empty>,10,,52,1,,void
37431,BLOCK,-1,,"{
    nid = EVP_PKEY_ED448;
  }",42,,52,2,,void
37436,BLOCK,-1,,<empty>,10,,54,1,,void
37443,BLOCK,-1,,"{
    nid = EVP_PKEY_X25519;
  }",43,,54,2,,void
37448,BLOCK,-1,,<empty>,10,,56,1,,void
37455,BLOCK,-1,,"{
    nid = EVP_PKEY_X448;
  }",41,,56,2,,void
37460,BLOCK,-1,,"{
    nid = NID_undef;
  }",10,,58,1,,void
37471,BLOCK,-1,,"{
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);

  t->InstanceTemplate()->SetInternalFieldCount(ECDH::kInternalFieldCount);

  SetProtoMethod(isolate, t, ""generateKeys"", GenerateKeys);
  SetProtoMethod(isolate, t, ""computeSecret"", ComputeSecret);
  SetProtoMethodNoSideEffect(isolate, t, ""getPublicKey"", GetPublicKey);
  SetProtoMethodNoSideEffect(isolate, t, ""getPrivateKey"", GetPrivateKey);
  SetProtoMethod(isolate, t, ""setPublicKey"", SetPublicKey);
  SetProtoMethod(isolate, t, ""setPrivateKey"", SetPrivateKey);

  SetConstructorFunction(context, target, ""ECDH"", t);

  SetMethodNoSideEffect(context, target, ""ECDHConvertKey"", ECDH::ConvertKey);
  SetMethodNoSideEffect(context, target, ""getCurves"", ECDH::GetCurves);

  ECDHBitsJob::Initialize(env, target);
  ECKeyPairGenJob::Initialize(env, target);
  ECKeyExportJob::Initialize(env, target);

  NODE_DEFINE_CONSTANT(target, OPENSSL_EC_NAMED...",63,,64,3,,void
37580,BLOCK,1,,<empty>,,,,7,,void
37582,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, OPENSSL_EC_NAMED_CURVE)",3,,88,1,,void
37679,BLOCK,1,,<empty>,,,,7,,void
37681,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, OPENSSL_EC_EXPLICIT_CURVE)",3,,89,1,,void
37777,BLOCK,-1,,"{
  registry->Register(New);
  registry->Register(GenerateKeys);
  registry->Register(ComputeSecret);
  registry->Register(GetPublicKey);
  registry->Register(GetPrivateKey);
  registry->Register(SetPublicKey);
  registry->Register(SetPrivateKey);
  registry->Register(ECDH::ConvertKey);
  registry->Register(ECDH::GetCurves);

  ECDHBitsJob::RegisterExternalReferences(registry);
  ECKeyPairGenJob::RegisterExternalReferences(registry);
  ECKeyExportJob::RegisterExternalReferences(registry);
}",76,,92,2,,void
37846,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  const size_t num_curves = EC_get_builtin_curves(nullptr, 0);
  std::vector<EC_builtin_curve> curves(num_curves);
  CHECK_EQ(EC_get_builtin_curves(curves.data(), num_curves), num_curves);

  std::vector<Local<Value>> arr(num_curves);
  std::transform(curves.begin(), curves.end(), arr.begin(), [env](auto& curve) {
    return OneByteString(env->isolate(), OBJ_nid2sn(curve.nid));
  });
  args.GetReturnValue().Set(Array::New(env->isolate(), arr.data(), arr.size()));
}",63,,108,2,,void
37932,BLOCK,-1,,"{
  MakeWeak();
  CHECK_NOT_NULL(group_);
}",43,,124,4,,void
37939,BLOCK,-1,,"{
  tracker->TrackFieldWithSize(""key"", key_ ? kSizeOf_EC_KEY : 0);
}",53,,129,2,,void
37952,BLOCK,-1,,<empty>,15,,133,1,,void
37957,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  MarkPopErrorOnReturn mark_pop_error_on_return;

  // TODO(indutny): Support raw curves?
  CHECK(args[0]->IsString());
  node::Utf8Value curve(env->isolate(), args[0]);

  int nid = OBJ_sn2nid(*curve);
  if (nid == NID_undef)
    return THROW_ERR_CRYPTO_INVALID_CURVE(env);

  ECKeyPointer key(EC_KEY_new_by_curve_name(nid));
  if (!key)
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
      ""Failed to create key using named curve"");

  new ECDH(env, args.This(), std::move(key));
}",57,,135,2,,void
37993,BLOCK,-1,,<empty>,5,,146,2,,void
38004,BLOCK,-1,,<empty>,5,,150,2,,void
38025,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  ECDH* ecdh;
  ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.Holder());

  if (!EC_KEY_generate_key(ecdh->key_.get()))
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""Failed to generate key"");
}",66,,156,2,,void
38051,BLOCK,-1,,<empty>,5,,163,2,,void
38062,BLOCK,-1,,"{
  int r;

  ECPointPointer pub(EC_POINT_new(group));
  if (!pub) {
    THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to allocate EC_POINT for a public key"");
    return pub;
  }

  ArrayBufferOrViewContents<unsigned char> input(buf);
  if (UNLIKELY(!input.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(env, ""buffer is too big"");
    return ECPointPointer();
  }
  r = EC_POINT_oct2point(
      group,
      pub.get(),
      input.data(),
      input.size(),
      nullptr);
  if (!r)
    return ECPointPointer();

  return pub;
}",54,,168,4,,void
38071,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to allocate EC_POINT for a public key"");
    return pub;
  }",13,,172,2,,void
38087,BLOCK,-1,,"{
    THROW_ERR_OUT_OF_RANGE(env, ""buffer is too big"");
    return ECPointPointer();
  }",42,,179,2,,void
38113,BLOCK,-1,,<empty>,5,,190,2,,void
38122,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK(IsAnyByteSource(args[0]));

  ECDH* ecdh;
  ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.Holder());

  MarkPopErrorOnReturn mark_pop_error_on_return;

  if (!ecdh->IsKeyPairValid())
    return THROW_ERR_CRYPTO_INVALID_KEYPAIR(env);

  ECPointPointer pub(
      ECDH::BufferToPoint(env,
                          ecdh->group_,
                          args[0]));
  if (!pub) {
    args.GetReturnValue().Set(
        FIXED_ONE_BYTE_STRING(env->isolate(),
        ""ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY""));
    return;
  }

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    // NOTE: field_size is in bits
    int field_size = EC_GROUP_get_degree(ecdh->group_);
    size_t out_len = (field_size + 7) / 8;
    bs = ArrayBuffer::NewBackingStore(env->isolate(), out_len);
  }

  if (!ECDH_compute_key(
          bs->Data(), bs->ByteLength(), pub.get(), ecdh->key_.get(), nullptr))
    r...",67,,195,2,,void
38151,BLOCK,-1,,<empty>,5,,206,2,,void
38171,BLOCK,-1,,"{
    args.GetReturnValue().Set(
        FIXED_ONE_BYTE_STRING(env->isolate(),
        ""ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY""));
    return;
  }",13,,212,2,,void
38193,BLOCK,12,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    // NOTE: field_size is in bits
    int field_size = EC_GROUP_get_degree(ecdh->group_);
    size_t out_len = (field_size + 7) / 8;
    bs = ArrayBuffer::NewBackingStore(env->isolate(), out_len);
  }",3,,220,12,,void
38248,BLOCK,-1,,<empty>,5,,230,2,,void
38295,BLOCK,-1,,<empty>,68,,234,2,,void
38309,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  // Conversion form
  CHECK_EQ(args.Length(), 1);

  ECDH* ecdh;
  ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.Holder());

  const EC_GROUP* group = EC_KEY_get0_group(ecdh->key_.get());
  const EC_POINT* pub = EC_KEY_get0_public_key(ecdh->key_.get());
  if (pub == nullptr)
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to get ECDH public key"");

  CHECK(args[0]->IsUint32());
  uint32_t val = args[0].As<Uint32>()->Value();
  point_conversion_form_t form = static_cast<point_conversion_form_t>(val);

  const char* error;
  Local<Object> buf;
  if (!ECPointToBuffer(env, group, pub, form, &error).ToLocal(&buf))
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env, error);
  args.GetReturnValue().Set(buf);
}",66,,238,2,,void
38356,BLOCK,-1,,<empty>,5,,250,2,,void
38406,BLOCK,-1,,<empty>,5,,260,2,,void
38423,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  ECDH* ecdh;
  ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.Holder());

  const BIGNUM* b = EC_KEY_get0_private_key(ecdh->key_.get());
  if (b == nullptr)
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to get ECDH private key"");

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), BN_num_bytes(b));
  }
  CHECK_EQ(static_cast<int>(bs->ByteLength()),
           BN_bn2binpad(
               b, static_cast<unsigned char*>(bs->Data()), bs->ByteLength()));

  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
  Local<Value> buffer;
  if (!Buffer::New(env, ab, 0, ab->ByteLength()).ToLocal(&buffer)) return;
  args.GetReturnValue().Set(buffer);
}",67,,264,2,,void
38454,BLOCK,-1,,<empty>,5,,272,2,,void
38466,BLOCK,9,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), BN_num_bytes(b));
  }",3,,276,9,,void
38546,BLOCK,-1,,<empty>,68,,286,2,,void
38560,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  ECDH* ecdh;
  ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.Holder());

  ArrayBufferOrViewContents<unsigned char> priv_buffer(args[0]);
  if (UNLIKELY(!priv_buffer.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""key is too big"");

  BignumPointer priv(BN_bin2bn(
      priv_buffer.data(), priv_buffer.size(), nullptr));
  if (!priv) {
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to convert Buffer to BN"");
  }

  if (!ecdh->IsKeyValidForCurve(priv)) {
    return THROW_ERR_CRYPTO_INVALID_KEYTYPE(env,
        ""Private key is not valid for specified curve."");
  }

  ECKeyPointer new_key(EC_KEY_dup(ecdh->key_.get()));
  CHECK(new_key);

  int result = EC_KEY_set_private_key(new_key.get(), priv.get());
  priv.reset();

  if (!result) {
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to convert BN to a private key"");
  }

  MarkPopErrorOnReturn mark_pop_error_on_return;
  USE(&mark_pop_error_on_...",67,,290,2,,void
38589,BLOCK,-1,,<empty>,5,,298,2,,void
38609,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to convert Buffer to BN"");
  }",14,,302,2,,void
38621,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_INVALID_KEYTYPE(env,
        ""Private key is not valid for specified curve."");
  }",40,,307,2,,void
38656,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to convert BN to a private key"");
  }",16,,318,2,,void
38697,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to generate ECDH public key"");
  }",49,,333,2,,void
38713,BLOCK,-1,,<empty>,5,,339,2,,void
38742,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  ECDH* ecdh;
  ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.Holder());

  CHECK(IsAnyByteSource(args[0]));

  MarkPopErrorOnReturn mark_pop_error_on_return;

  ECPointPointer pub(
      ECDH::BufferToPoint(env,
                          ecdh->group_,
                          args[0]));
  if (!pub) {
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to convert Buffer to EC_POINT"");
  }

  int r = EC_KEY_set_public_key(ecdh->key_.get(), pub.get());
  if (!r) {
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to set EC_POINT as the public key"");
  }
}",66,,346,2,,void
38781,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to convert Buffer to EC_POINT"");
  }",13,,360,2,,void
38803,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to set EC_POINT as the public key"");
  }",11,,366,2,,void
38812,BLOCK,-1,,"{
  CHECK(group_);
  CHECK(private_key);
  // Private keys must be in the range [1, n-1].
  // Ref: Section 3.2.1 - http://www.secg.org/sec1-v2.pdf
  if (BN_cmp(private_key.get(), BN_value_one()) < 0) {
    return false;
  }
  BignumPointer order(BN_new());
  CHECK(order);
  return EC_GROUP_get_order(group_, order.get(), nullptr) &&
         BN_cmp(private_key.get(), order.get()) < 0;
}",65,,372,2,,void
38825,BLOCK,-1,,"{
    return false;
  }",54,,377,2,,void
38856,BLOCK,-1,,"{
  MarkPopErrorOnReturn mark_pop_error_on_return;
  USE(&mark_pop_error_on_return);
  return 1 == EC_KEY_check_key(key_.get());
}",29,,386,1,,void
38873,BLOCK,-1,,"{
  MarkPopErrorOnReturn mark_pop_error_on_return;
  Environment* env = Environment::GetCurrent(args);

  CHECK_EQ(args.Length(), 3);
  CHECK(IsAnyByteSource(args[0]));

  ArrayBufferOrViewContents<char> args0(args[0]);
  if (UNLIKELY(!args0.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""key is too big"");
  if (args0.size() == 0)
    return args.GetReturnValue().SetEmptyString();

  node::Utf8Value curve(env->isolate(), args[1]);

  int nid = OBJ_sn2nid(*curve);
  if (nid == NID_undef)
    return THROW_ERR_CRYPTO_INVALID_CURVE(env);

  ECGroupPointer group(
      EC_GROUP_new_by_curve_name(nid));
  if (group == nullptr)
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""Failed to get EC_GROUP"");

  ECPointPointer pub(
      ECDH::BufferToPoint(env,
                          group.get(),
                          args[0]));

  if (pub == nullptr) {
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to convert Buffer to EC_POINT"");
  }

  CHECK(args[2]->IsUi...",64,,393,2,,void
38906,BLOCK,-1,,<empty>,5,,402,2,,void
38918,BLOCK,-1,,<empty>,5,,404,2,,void
38946,BLOCK,-1,,<empty>,5,,410,2,,void
38958,BLOCK,-1,,<empty>,5,,415,2,,void
38981,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to convert Buffer to EC_POINT"");
  }",23,,422,2,,void
39037,BLOCK,-1,,<empty>,5,,434,2,,void
39054,BLOCK,-1,,"{
  tracker->TrackField(""public"", public_);
  tracker->TrackField(""private"", private_);
}",63,,438,2,,void
39074,BLOCK,-1,,"{
  *result = out->ToArrayBuffer(env);
  return Just(!result->IsEmpty());
}",35,,447,5,,void
39097,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[offset]->IsString());  // curve name
  CHECK(args[offset + 1]->IsObject());  // public key
  CHECK(args[offset + 2]->IsObject());  // private key

  KeyObjectHandle* private_key;
  KeyObjectHandle* public_key;

  Utf8Value name(env->isolate(), args[offset]);

  ASSIGN_OR_RETURN_UNWRAP(&public_key, args[offset + 1], Nothing<bool>());
  ASSIGN_OR_RETURN_UNWRAP(&private_key, args[offset + 2], Nothing<bool>());

  if (private_key->Data()->GetKeyType() != kKeyTypePrivate ||
      public_key->Data()->GetKeyType() != kKeyTypePublic) {
    THROW_ERR_CRYPTO_INVALID_KEYTYPE(env);
    return Nothing<bool>();
  }

  params->id_ = GetOKPCurveFromName(*name);
  params->private_ = private_key->Data();
  params->public_ = public_key->Data();

  return Just(true);
}",29,,456,5,,void
39180,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_KEYTYPE(env);
    return Nothing<bool>();
  }",59,,472,2,,void
39217,BLOCK,-1,,"{
  size_t len = 0;
  ManagedEVPPKey m_privkey = params.private_->GetAsymmetricKey();
  ManagedEVPPKey m_pubkey = params.public_->GetAsymmetricKey();

  switch (params.id_) {
    case EVP_PKEY_X25519:
      // Fall through
    case EVP_PKEY_X448: {
      EVPKeyCtxPointer ctx = nullptr;
      {
        ctx.reset(EVP_PKEY_CTX_new(m_privkey.get(), nullptr));
      }
      Mutex::ScopedLock pub_lock(*m_pubkey.mutex());
      if (EVP_PKEY_derive_init(ctx.get()) <= 0 ||
          EVP_PKEY_derive_set_peer(
              ctx.get(),
              m_pubkey.get()) <= 0 ||
          EVP_PKEY_derive(ctx.get(), nullptr, &len) <= 0) {
        return false;
      }

      ByteSource::Builder buf(len);

      if (EVP_PKEY_derive(ctx.get(), buf.data<unsigned char>(), &len) <= 0) {
        return false;
      }

      *out = std::move(buf).release(len);

      break;
    }
    default: {
      const EC_KEY* private_key;
      {
        Mutex::ScopedLock priv_lock(*m_privkey.mutex());
        private_k...",50,,486,4,,void
39244,BLOCK,-1,,"{
    case EVP_PKEY_X25519:
      // Fall through
    case EVP_PKEY_X448: {
      EVPKeyCtxPointer ctx = nullptr;
      {
        ctx.reset(EVP_PKEY_CTX_new(m_privkey.get(), nullptr));
      }
      Mutex::ScopedLock pub_lock(*m_pubkey.mutex());
      if (EVP_PKEY_derive_init(ctx.get()) <= 0 ||
          EVP_PKEY_derive_set_peer(
              ctx.get(),
              m_pubkey.get()) <= 0 ||
          EVP_PKEY_derive(ctx.get(), nullptr, &len) <= 0) {
        return false;
      }

      ByteSource::Builder buf(len);

      if (EVP_PKEY_derive(ctx.get(), buf.data<unsigned char>(), &len) <= 0) {
        return false;
      }

      *out = std::move(buf).release(len);

      break;
    }
    default: {
      const EC_KEY* private_key;
      {
        Mutex::ScopedLock priv_lock(*m_privkey.mutex());
        private_key = EVP_PKEY_get0_EC_KEY(m_privkey.get());
      }

      Mutex::ScopedLock pub_lock(*m_pubkey.mutex());
      const EC_KEY* public_key = EVP_PKEY_get0_EC_KEY(m_pubkey.get(...",23,,491,2,,void
39249,BLOCK,5,,"{
      EVPKeyCtxPointer ctx = nullptr;
      {
        ctx.reset(EVP_PKEY_CTX_new(m_privkey.get(), nullptr));
      }
      Mutex::ScopedLock pub_lock(*m_pubkey.mutex());
      if (EVP_PKEY_derive_init(ctx.get()) <= 0 ||
          EVP_PKEY_derive_set_peer(
              ctx.get(),
              m_pubkey.get()) <= 0 ||
          EVP_PKEY_derive(ctx.get(), nullptr, &len) <= 0) {
        return false;
      }

      ByteSource::Builder buf(len);

      if (EVP_PKEY_derive(ctx.get(), buf.data<unsigned char>(), &len) <= 0) {
        return false;
      }

      *out = std::move(buf).release(len);

      break;
    }",25,,494,5,,void
39254,BLOCK,3,,"{
        ctx.reset(EVP_PKEY_CTX_new(m_privkey.get(), nullptr));
      }",7,,496,3,,void
39303,BLOCK,-1,,"{
        return false;
      }",59,,504,2,,void
39323,BLOCK,-1,,"{
        return false;
      }",77,,510,2,,void
39340,BLOCK,7,,"{
      const EC_KEY* private_key;
      {
        Mutex::ScopedLock priv_lock(*m_privkey.mutex());
        private_key = EVP_PKEY_get0_EC_KEY(m_privkey.get());
      }

      Mutex::ScopedLock pub_lock(*m_pubkey.mutex());
      const EC_KEY* public_key = EVP_PKEY_get0_EC_KEY(m_pubkey.get());

      const EC_GROUP* group = EC_KEY_get0_group(private_key);
      if (group == nullptr)
        return false;

      CHECK_EQ(EC_KEY_check_key(private_key), 1);
      CHECK_EQ(EC_KEY_check_key(public_key), 1);
      const EC_POINT* pub = EC_KEY_get0_public_key(public_key);
      int field_size = EC_GROUP_get_degree(group);
      len = (field_size + 7) / 8;
      ByteSource::Builder buf(len);
      CHECK_NOT_NULL(pub);
      CHECK_NOT_NULL(private_key);
      if (ECDH_compute_key(buf.data<char>(), len, pub, private_key, nullptr) <=
          0) {
        return false;
      }

      *out = std::move(buf).release();
    }",14,,518,7,,void
39342,BLOCK,2,,"{
        Mutex::ScopedLock priv_lock(*m_privkey.mutex());
        private_key = EVP_PKEY_get0_EC_KEY(m_privkey.get());
      }",7,,520,2,,void
39381,BLOCK,-1,,<empty>,9,,530,2,,void
39428,BLOCK,-1,,"{
        return false;
      }",14,,541,2,,void
39448,BLOCK,-1,,"{
  EVPKeyCtxPointer key_ctx;
  switch (params->params.curve_nid) {
    case EVP_PKEY_ED25519:
      // Fall through
    case EVP_PKEY_ED448:
      // Fall through
    case EVP_PKEY_X25519:
      // Fall through
    case EVP_PKEY_X448:
      key_ctx.reset(EVP_PKEY_CTX_new_id(params->params.curve_nid, nullptr));
      break;
    default: {
      EVPKeyCtxPointer param_ctx(EVP_PKEY_CTX_new_id(EVP_PKEY_EC, nullptr));
      EVP_PKEY* raw_params = nullptr;
      if (!param_ctx ||
          EVP_PKEY_paramgen_init(param_ctx.get()) <= 0 ||
          EVP_PKEY_CTX_set_ec_paramgen_curve_nid(
              param_ctx.get(), params->params.curve_nid) <= 0 ||
          EVP_PKEY_CTX_set_ec_param_enc(
              param_ctx.get(), params->params.param_encoding) <= 0 ||
          EVP_PKEY_paramgen(param_ctx.get(), &raw_params) <= 0) {
        return EVPKeyCtxPointer();
      }
      EVPKeyPointer key_params(raw_params);
      key_ctx.reset(EVP_PKEY_CTX_new(key_params.get(), nullptr));
    }
  }

  i...",68,,552,2,,void
39456,BLOCK,-1,,"{
    case EVP_PKEY_ED25519:
      // Fall through
    case EVP_PKEY_ED448:
      // Fall through
    case EVP_PKEY_X25519:
      // Fall through
    case EVP_PKEY_X448:
      key_ctx.reset(EVP_PKEY_CTX_new_id(params->params.curve_nid, nullptr));
      break;
    default: {
      EVPKeyCtxPointer param_ctx(EVP_PKEY_CTX_new_id(EVP_PKEY_EC, nullptr));
      EVP_PKEY* raw_params = nullptr;
      if (!param_ctx ||
          EVP_PKEY_paramgen_init(param_ctx.get()) <= 0 ||
          EVP_PKEY_CTX_set_ec_paramgen_curve_nid(
              param_ctx.get(), params->params.curve_nid) <= 0 ||
          EVP_PKEY_CTX_set_ec_param_enc(
              param_ctx.get(), params->params.param_encoding) <= 0 ||
          EVP_PKEY_paramgen(param_ctx.get(), &raw_params) <= 0) {
        return EVPKeyCtxPointer();
      }
      EVPKeyPointer key_params(raw_params);
      key_ctx.reset(EVP_PKEY_CTX_new(key_params.get(), nullptr));
    }
  }",37,,554,2,,void
39478,BLOCK,12,,"{
      EVPKeyCtxPointer param_ctx(EVP_PKEY_CTX_new_id(EVP_PKEY_EC, nullptr));
      EVP_PKEY* raw_params = nullptr;
      if (!param_ctx ||
          EVP_PKEY_paramgen_init(param_ctx.get()) <= 0 ||
          EVP_PKEY_CTX_set_ec_paramgen_curve_nid(
              param_ctx.get(), params->params.curve_nid) <= 0 ||
          EVP_PKEY_CTX_set_ec_param_enc(
              param_ctx.get(), params->params.param_encoding) <= 0 ||
          EVP_PKEY_paramgen(param_ctx.get(), &raw_params) <= 0) {
        return EVPKeyCtxPointer();
      }
      EVPKeyPointer key_params(raw_params);
      key_ctx.reset(EVP_PKEY_CTX_new(key_params.get(), nullptr));
    }",14,,564,12,,void
39535,BLOCK,-1,,"{
        return EVPKeyCtxPointer();
      }",65,,573,2,,void
39561,BLOCK,-1,,<empty>,5,,582,2,,void
39575,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[*offset]->IsString());  // curve name
  CHECK(args[*offset + 1]->IsInt32());  // param encoding

  Utf8Value curve_name(env->isolate(), args[*offset]);
  params->params.curve_nid = GetCurveFromName(*curve_name);
  if (params->params.curve_nid == NID_undef) {
    THROW_ERR_CRYPTO_INVALID_CURVE(env);
    return Nothing<bool>();
  }

  params->params.param_encoding = args[*offset + 1].As<Int32>()->Value();
  if (params->params.param_encoding != OPENSSL_EC_NAMED_CURVE &&
      params->params.param_encoding != OPENSSL_EC_EXPLICIT_CURVE) {
    THROW_ERR_OUT_OF_RANGE(env, ""Invalid param_encoding specified"");
    return Nothing<bool>();
  }

  *offset += 2;

  return Just(true);
}",33,,601,5,,void
39629,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_CURVE(env);
    return Nothing<bool>();
  }",46,,608,2,,void
39668,BLOCK,-1,,"{
    THROW_ERR_OUT_OF_RANGE(env, ""Invalid param_encoding specified"");
    return Nothing<bool>();
  }",67,,615,2,,void
39688,BLOCK,-1,,"{
  ManagedEVPPKey m_pkey = key_data->GetAsymmetricKey();
  CHECK(m_pkey);
  Mutex::ScopedLock lock(*m_pkey.mutex());

  const EC_KEY* ec_key = EVP_PKEY_get0_EC_KEY(m_pkey.get());

  size_t len = 0;

  if (ec_key == nullptr) {
    typedef int (*export_fn)(const EVP_PKEY*, unsigned char*, size_t* len);
    export_fn fn = nullptr;
    switch (key_data->GetKeyType()) {
      case kKeyTypePrivate:
        fn = EVP_PKEY_get_raw_private_key;
        break;
      case kKeyTypePublic:
        fn = EVP_PKEY_get_raw_public_key;
        break;
      case kKeyTypeSecret:
        UNREACHABLE();
    }
    CHECK_NOT_NULL(fn);
    // Get the size of the raw key data
    if (fn(m_pkey.get(), nullptr, &len) == 0)
      return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
    ByteSource::Builder data(len);
    if (fn(m_pkey.get(), data.data<unsigned char>(), &len) == 0)
      return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
    *out = std::move(data).release(len);
  } else {
    if (key_data->GetKeyTy...",22,,629,4,,void
39721,BLOCK,-1,,"{
    typedef int (*export_fn)(const EVP_PKEY*, unsigned char*, size_t* len);
    export_fn fn = nullptr;
    switch (key_data->GetKeyType()) {
      case kKeyTypePrivate:
        fn = EVP_PKEY_get_raw_private_key;
        break;
      case kKeyTypePublic:
        fn = EVP_PKEY_get_raw_public_key;
        break;
      case kKeyTypeSecret:
        UNREACHABLE();
    }
    CHECK_NOT_NULL(fn);
    // Get the size of the raw key data
    if (fn(m_pkey.get(), nullptr, &len) == 0)
      return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
    ByteSource::Builder data(len);
    if (fn(m_pkey.get(), data.data<unsigned char>(), &len) == 0)
      return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
    *out = std::move(data).release(len);
  }",26,,638,2,,void
39726,BLOCK,-1,,<empty>,,,,4,,<empty>
39738,BLOCK,-1,,"{
      case kKeyTypePrivate:
        fn = EVP_PKEY_get_raw_private_key;
        break;
      case kKeyTypePublic:
        fn = EVP_PKEY_get_raw_public_key;
        break;
      case kKeyTypeSecret:
        UNREACHABLE();
    }",37,,641,2,,void
39767,BLOCK,-1,,<empty>,7,,654,2,,void
39789,BLOCK,-1,,<empty>,7,,657,2,,void
39807,BLOCK,-1,,"{
    if (key_data->GetKeyType() != kKeyTypePublic)
      return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
    const EC_GROUP* group = EC_KEY_get0_group(ec_key);
    const EC_POINT* point = EC_KEY_get0_public_key(ec_key);
    point_conversion_form_t form = POINT_CONVERSION_UNCOMPRESSED;

    // Get the allocated data size...
    len = EC_POINT_point2oct(group, point, form, nullptr, 0, nullptr);
    if (len == 0)
      return WebCryptoKeyExportStatus::FAILED;
    ByteSource::Builder data(len);
    size_t check_len = EC_POINT_point2oct(
        group, point, form, data.data<unsigned char>(), len, nullptr);
    if (check_len == 0)
      return WebCryptoKeyExportStatus::FAILED;

    CHECK_EQ(len, check_len);
    *out = std::move(data).release();
  }",10,,659,1,,void
39815,BLOCK,-1,,<empty>,7,,661,2,,void
39847,BLOCK,-1,,<empty>,7,,669,2,,void
39872,BLOCK,-1,,<empty>,7,,674,2,,void
39901,BLOCK,-1,,"{
  return Just(true);
}",32,,687,4,,void
39912,BLOCK,-1,,"{
  CHECK_NE(key_data->GetKeyType(), kKeyTypeSecret);

  switch (format) {
    case kWebCryptoKeyFormatRaw:
      return EC_Raw_Export(key_data.get(), params, out);
    case kWebCryptoKeyFormatPKCS8:
      if (key_data->GetKeyType() != kKeyTypePrivate)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_PKCS8_Export(key_data.get(), out);
    case kWebCryptoKeyFormatSPKI: {
      if (key_data->GetKeyType() != kKeyTypePublic)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;

      ManagedEVPPKey m_pkey = key_data->GetAsymmetricKey();
      if (EVP_PKEY_id(m_pkey.get()) != EVP_PKEY_EC) {
        return PKEY_SPKI_Export(key_data.get(), out);
      } else {
        // Ensure exported key is in uncompressed point format.
        // The temporary EC key is so we can have i2d_PUBKEY_bio() write out
        // the header but it is a somewhat silly hoop to jump through because
        // the header is for all practical purposes a static 26 byte sequence
    ...",22,,695,5,,void
39921,BLOCK,-1,,"{
    case kWebCryptoKeyFormatRaw:
      return EC_Raw_Export(key_data.get(), params, out);
    case kWebCryptoKeyFormatPKCS8:
      if (key_data->GetKeyType() != kKeyTypePrivate)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_PKCS8_Export(key_data.get(), out);
    case kWebCryptoKeyFormatSPKI: {
      if (key_data->GetKeyType() != kKeyTypePublic)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;

      ManagedEVPPKey m_pkey = key_data->GetAsymmetricKey();
      if (EVP_PKEY_id(m_pkey.get()) != EVP_PKEY_EC) {
        return PKEY_SPKI_Export(key_data.get(), out);
      } else {
        // Ensure exported key is in uncompressed point format.
        // The temporary EC key is so we can have i2d_PUBKEY_bio() write out
        // the header but it is a somewhat silly hoop to jump through because
        // the header is for all practical purposes a static 26 byte sequence
        // where only the second byte changes.
        Mutex::ScopedLock lock...",19,,698,2,,void
39941,BLOCK,-1,,<empty>,9,,703,2,,void
39955,BLOCK,10,,"{
      if (key_data->GetKeyType() != kKeyTypePublic)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;

      ManagedEVPPKey m_pkey = key_data->GetAsymmetricKey();
      if (EVP_PKEY_id(m_pkey.get()) != EVP_PKEY_EC) {
        return PKEY_SPKI_Export(key_data.get(), out);
      } else {
        // Ensure exported key is in uncompressed point format.
        // The temporary EC key is so we can have i2d_PUBKEY_bio() write out
        // the header but it is a somewhat silly hoop to jump through because
        // the header is for all practical purposes a static 26 byte sequence
        // where only the second byte changes.
        Mutex::ScopedLock lock(*m_pkey.mutex());
        const EC_KEY* ec_key = EVP_PKEY_get0_EC_KEY(m_pkey.get());
        const EC_GROUP* group = EC_KEY_get0_group(ec_key);
        const EC_POINT* point = EC_KEY_get0_public_key(ec_key);
        const point_conversion_form_t form = POINT_CONVERSION_UNCOMPRESSED;
        const size_t need =
            E...",35,,705,10,,void
39963,BLOCK,-1,,<empty>,9,,707,2,,void
39983,BLOCK,-1,,"{
        return PKEY_SPKI_Export(key_data.get(), out);
      }",53,,710,2,,void
39992,BLOCK,-1,,"{
        // Ensure exported key is in uncompressed point format.
        // The temporary EC key is so we can have i2d_PUBKEY_bio() write out
        // the header but it is a somewhat silly hoop to jump through because
        // the header is for all practical purposes a static 26 byte sequence
        // where only the second byte changes.
        Mutex::ScopedLock lock(*m_pkey.mutex());
        const EC_KEY* ec_key = EVP_PKEY_get0_EC_KEY(m_pkey.get());
        const EC_GROUP* group = EC_KEY_get0_group(ec_key);
        const EC_POINT* point = EC_KEY_get0_public_key(ec_key);
        const point_conversion_form_t form = POINT_CONVERSION_UNCOMPRESSED;
        const size_t need =
            EC_POINT_point2oct(group, point, form, nullptr, 0, nullptr);
        if (need == 0) return WebCryptoKeyExportStatus::FAILED;
        ByteSource::Builder data(need);
        const size_t have = EC_POINT_point2oct(
            group, point, form, data.data<unsigned char>(), need, nullptr);
       ...",14,,712,1,,void
40036,BLOCK,-1,,<empty>,24,,725,2,,void
40061,BLOCK,-1,,<empty>,24,,729,2,,void
40125,BLOCK,-1,,<empty>,,,,2,,<empty>
40141,BLOCK,-1,,<empty>,11,,745,2,,void
40166,BLOCK,-1,,"{
  ManagedEVPPKey m_pkey = key->GetAsymmetricKey();
  Mutex::ScopedLock lock(*m_pkey.mutex());
  CHECK_EQ(EVP_PKEY_id(m_pkey.get()), EVP_PKEY_EC);

  const EC_KEY* ec = EVP_PKEY_get0_EC_KEY(m_pkey.get());
  CHECK_NOT_NULL(ec);

  const EC_POINT* pub = EC_KEY_get0_public_key(ec);
  const EC_GROUP* group = EC_KEY_get0_group(ec);

  int degree_bits = EC_GROUP_get_degree(group);
  int degree_bytes =
    (degree_bits / CHAR_BIT) + (7 + (degree_bits % CHAR_BIT)) / 8;

  BignumPointer x(BN_new());
  BignumPointer y(BN_new());

  if (!EC_POINT_get_affine_coordinates(group, pub, x.get(), y.get(), nullptr)) {
    ThrowCryptoError(env, ERR_get_error(),
                     ""Failed to get elliptic-curve point coordinates"");
    return Nothing<void>();
  }

  if (target->Set(
          env->context(),
          env->jwk_kty_string(),
          env->jwk_ec_string()).IsNothing()) {
    return Nothing<void>();
  }

  if (SetEncodedValue(
          env,
          target,
          env->jwk_x_string...",27,,758,4,,void
40247,BLOCK,-1,,"{
    ThrowCryptoError(env, ERR_get_error(),
                     ""Failed to get elliptic-curve point coordinates"");
    return Nothing<void>();
  }",80,,776,2,,void
40274,BLOCK,-1,,"{
    return Nothing<void>();
  }",46,,785,2,,void
40309,BLOCK,-1,,"{
    return Nothing<void>();
  }",38,,800,2,,void
40324,BLOCK,-1,,"{
    case NID_X9_62_prime256v1:
      crv_name = OneByteString(env->isolate(), ""P-256"");
      break;
    case NID_secp256k1:
      crv_name = OneByteString(env->isolate(), ""secp256k1"");
      break;
    case NID_secp384r1:
      crv_name = OneByteString(env->isolate(), ""P-384"");
      break;
    case NID_secp521r1:
      crv_name = OneByteString(env->isolate(), ""P-521"");
      break;
    default: {
      THROW_ERR_CRYPTO_JWK_UNSUPPORTED_CURVE(
          env, ""Unsupported JWK EC curve: %s."", OBJ_nid2sn(nid));
      return Nothing<void>();
    }
  }",16,,806,2,,void
40370,BLOCK,18,,"{
      THROW_ERR_CRYPTO_JWK_UNSUPPORTED_CURVE(
          env, ""Unsupported JWK EC curve: %s."", OBJ_nid2sn(nid));
      return Nothing<void>();
    }",14,,819,18,,void
40395,BLOCK,-1,,"{
    return Nothing<void>();
  }",30,,828,2,,void
40405,BLOCK,-1,,"{
    const BIGNUM* pvt = EC_KEY_get0_private_key(ec);
    return SetEncodedValue(
      env,
      target,
      env->jwk_d_string(),
      pvt,
      degree_bytes).IsJust() ? JustVoid() : Nothing<void>();
  }",45,,832,2,,void
40435,BLOCK,-1,,"{
  ManagedEVPPKey pkey = key->GetAsymmetricKey();
  Mutex::ScopedLock lock(*pkey.mutex());

  const char* curve = nullptr;
  switch (EVP_PKEY_id(pkey.get())) {
    case EVP_PKEY_ED25519:
      curve = ""Ed25519"";
      break;
    case EVP_PKEY_ED448:
      curve = ""Ed448"";
      break;
    case EVP_PKEY_X25519:
      curve = ""X25519"";
      break;
    case EVP_PKEY_X448:
      curve = ""X448"";
      break;
    default:
      UNREACHABLE();
  }
  if (target->Set(
          env->context(),
          env->jwk_crv_string(),
          OneByteString(env->isolate(), curve)).IsNothing()) {
    return Nothing<bool>();
  }

  size_t len = 0;
  Local<Value> encoded;
  Local<Value> error;

  if (!EVP_PKEY_get_raw_public_key(pkey.get(), nullptr, &len))
    return Nothing<bool>();

  ByteSource::Builder out(len);

  if (key->GetKeyType() == kKeyTypePrivate) {
    if (!EVP_PKEY_get_raw_private_key(
            pkey.get(), out.data<unsigned char>(), &len) ||
        !StringBytes::Encode(
           ...",27,,848,4,,void
40460,BLOCK,-1,,"{
    case EVP_PKEY_ED25519:
      curve = ""Ed25519"";
      break;
    case EVP_PKEY_ED448:
      curve = ""Ed448"";
      break;
    case EVP_PKEY_X25519:
      curve = ""X25519"";
      break;
    case EVP_PKEY_X448:
      curve = ""X448"";
      break;
    default:
      UNREACHABLE();
  }",36,,853,2,,void
40509,BLOCK,-1,,"{
    return Nothing<bool>();
  }",62,,872,2,,void
40536,BLOCK,-1,,<empty>,5,,881,2,,void
40549,BLOCK,-1,,"{
    if (!EVP_PKEY_get_raw_private_key(
            pkey.get(), out.data<unsigned char>(), &len) ||
        !StringBytes::Encode(
             env->isolate(), out.data<const char>(), len, BASE64URL, &error)
             .ToLocal(&encoded) ||
        !target->Set(env->context(), env->jwk_d_string(), encoded).IsJust()) {
      if (!error.IsEmpty())
        env->isolate()->ThrowException(error);
      return Nothing<bool>();
    }
  }",45,,885,2,,void
40604,BLOCK,-1,,"{
      if (!error.IsEmpty())
        env->isolate()->ThrowException(error);
      return Nothing<bool>();
    }",78,,891,2,,void
40611,BLOCK,-1,,<empty>,9,,893,2,,void
40676,BLOCK,-1,,"{
    if (!error.IsEmpty())
      env->isolate()->ThrowException(error);
    return Nothing<bool>();
  }",76,,903,2,,void
40683,BLOCK,-1,,<empty>,7,,905,2,,void
40714,BLOCK,-1,,"{
    return Nothing<bool>();
  }",47,,912,2,,void
40727,BLOCK,-1,,"{
  CHECK(args[offset]->IsString());  // curve name
  Utf8Value curve(env->isolate(), args[offset].As<String>());

  int nid = GetCurveFromName(*curve);
  if (nid == NID_undef) {  // Unknown curve
    THROW_ERR_CRYPTO_INVALID_CURVE(env);
    return std::shared_ptr<KeyObjectData>();
  }

  Local<Value> x_value;
  Local<Value> y_value;
  Local<Value> d_value;

  if (!jwk->Get(env->context(), env->jwk_x_string()).ToLocal(&x_value) ||
      !jwk->Get(env->context(), env->jwk_y_string()).ToLocal(&y_value) ||
      !jwk->Get(env->context(), env->jwk_d_string()).ToLocal(&d_value)) {
    return std::shared_ptr<KeyObjectData>();
  }

  if (!x_value->IsString() ||
      !y_value->IsString() ||
      (!d_value->IsUndefined() && !d_value->IsString())) {
    THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK EC key"");
    return std::shared_ptr<KeyObjectData>();
  }

  KeyType type = d_value->IsString() ? kKeyTypePrivate : kKeyTypePublic;

  ECKeyPointer ec(EC_KEY_new_by_curve_name(nid));
  if (!ec)...",26,,923,5,,void
40757,BLOCK,-1,,"{  // Unknown curve
    THROW_ERR_CRYPTO_INVALID_CURVE(env);
    return std::shared_ptr<KeyObjectData>();
  }",25,,928,2,,void
40837,BLOCK,-1,,"{
    return std::shared_ptr<KeyObjectData>();
  }",73,,939,2,,void
40867,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK EC key"");
    return std::shared_ptr<KeyObjectData>();
  }",58,,945,2,,void
40893,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK EC key"");
    return std::shared_ptr<KeyObjectData>();
  }",12,,953,2,,void
40947,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK EC key"");
    return std::shared_ptr<KeyObjectData>();
  }",28,,964,2,,void
40960,BLOCK,-1,,"{
    ByteSource d = ByteSource::FromEncodedString(env, d_value.As<String>());
    if (!EC_KEY_set_private_key(ec.get(), d.ToBN().get())) {
      THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK EC key"");
      return std::shared_ptr<KeyObjectData>();
    }
  }",32,,969,2,,void
40987,BLOCK,-1,,"{
      THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK EC key"");
      return std::shared_ptr<KeyObjectData>();
    }",60,,971,2,,void
41028,BLOCK,-1,,"{
  ManagedEVPPKey m_pkey = key->GetAsymmetricKey();
  Mutex::ScopedLock lock(*m_pkey.mutex());
  CHECK_EQ(EVP_PKEY_id(m_pkey.get()), EVP_PKEY_EC);

  const EC_KEY* ec = EVP_PKEY_get0_EC_KEY(m_pkey.get());
  CHECK_NOT_NULL(ec);

  const EC_GROUP* group = EC_KEY_get0_group(ec);
  int nid = EC_GROUP_get_curve_name(group);

  return target->Set(
      env->context(),
      env->named_curve_string(),
      OneByteString(env->isolate(), OBJ_nid2sn(nid)));
}",27,,986,4,,void
41094,BLOCK,-1,,"{
  const EC_KEY* ec = EVP_PKEY_get0_EC_KEY(key.get());
  CHECK_NOT_NULL(ec);
  const EC_GROUP* group = EC_KEY_get0_group(ec);
  BignumPointer order(BN_new());
  CHECK(EC_GROUP_get_order(group, order.get(), nullptr));
  return BN_num_bytes(order.get());
}",50,,1008,2,,void
41151,BLOCK,-1,,<empty>,1,,1,1,,ANY
41158,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(args);
    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");
    bool r = hash->HashUpdate(data, size);
    args.GetReturnValue().Set(r);
  }",56,,142,5,,void
41172,BLOCK,-1,,<empty>,7,,145,2,,void
41219,BLOCK,-1,,<empty>,1,,1,1,,ANY
41225,BLOCK,-1,,"{
  MakeWeak();
}",74,,28,3,,void
41231,BLOCK,-1,,"{
  tracker->TrackFieldWithSize(""mdctx"", mdctx_ ? kSizeOf_EVP_MD_CTX : 0);
  tracker->TrackFieldWithSize(""md"", digest_ ? md_len_ : 0);
}",53,,32,2,,void
41254,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  MarkPopErrorOnReturn mark_pop_error_on_return;
  CipherPushContext ctx(env);
  EVP_MD_do_all_sorted(
#if OPENSSL_VERSION_MAJOR >= 3
    array_push_back<EVP_MD,
                    EVP_MD_fetch,
                    EVP_MD_free,
                    EVP_get_digestbyname,
                    EVP_MD_get0_name>,
#else
    array_push_back<EVP_MD>,
#endif
    &ctx);
  args.GetReturnValue().Set(ctx.ToJSArray());
}",63,,37,2,,void
41287,BLOCK,-1,,"{
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();
  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);

  t->InstanceTemplate()->SetInternalFieldCount(Hash::kInternalFieldCount);

  SetProtoMethod(isolate, t, ""update"", HashUpdate);
  SetProtoMethod(isolate, t, ""digest"", HashDigest);

  SetConstructorFunction(context, target, ""Hash"", t);

  SetMethodNoSideEffect(context, target, ""getHashes"", GetHashes);

  HashJob::Initialize(env, target);
}",63,,55,3,,void
41354,BLOCK,-1,,"{
  registry->Register(New);
  registry->Register(HashUpdate);
  registry->Register(HashDigest);
  registry->Register(GetHashes);

  HashJob::RegisterExternalReferences(registry);
}",76,,72,2,,void
41384,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const Hash* orig = nullptr;
  const EVP_MD* md = nullptr;

  if (args[0]->IsObject()) {
    ASSIGN_OR_RETURN_UNWRAP(&orig, args[0].As<Object>());
    md = EVP_MD_CTX_md(orig->mdctx_.get());
  } else {
    const Utf8Value hash_type(env->isolate(), args[0]);
    md = EVP_get_digestbyname(*hash_type);
  }

  Maybe<unsigned int> xof_md_len = Nothing<unsigned int>();
  if (!args[1]->IsUndefined()) {
    CHECK(args[1]->IsUint32());
    xof_md_len = Just<unsigned int>(args[1].As<Uint32>()->Value());
  }

  Hash* hash = new Hash(env, args.This());
  if (md == nullptr || !hash->HashInit(md, xof_md_len)) {
    return ThrowCryptoError(env, ERR_get_error(),
                            ""Digest method not supported"");
  }

  if (orig != nullptr &&
      0 >= EVP_MD_CTX_copy(hash->mdctx_.get(), orig->mdctx_.get())) {
    return ThrowCryptoError(env, ERR_get_error(), ""Digest copy error"");
  }
}",57,,81,2,,void
41408,BLOCK,-1,,"{
    ASSIGN_OR_RETURN_UNWRAP(&orig, args[0].As<Object>());
    md = EVP_MD_CTX_md(orig->mdctx_.get());
  }",28,,87,2,,void
41428,BLOCK,-1,,"{
    const Utf8Value hash_type(env->isolate(), args[0]);
    md = EVP_get_digestbyname(*hash_type);
  }",10,,90,1,,void
41455,BLOCK,-1,,"{
    CHECK(args[1]->IsUint32());
    xof_md_len = Just<unsigned int>(args[1].As<Uint32>()->Value());
  }",32,,96,2,,void
41497,BLOCK,-1,,"{
    return ThrowCryptoError(env, ERR_get_error(),
                            ""Digest method not supported"");
  }",57,,102,2,,void
41523,BLOCK,-1,,"{
    return ThrowCryptoError(env, ERR_get_error(), ""Digest copy error"");
  }",69,,108,2,,void
41534,BLOCK,-1,,"{
  mdctx_.reset(EVP_MD_CTX_new());
  if (!mdctx_ || EVP_DigestInit_ex(mdctx_.get(), md, nullptr) <= 0) {
    mdctx_.reset();
    return false;
  }

  md_len_ = EVP_MD_size(md);
  if (xof_md_len.IsJust() && xof_md_len.FromJust() != md_len_) {
    // This is a little hack to cause createHash to fail when an incorrect
    // hashSize option was passed for a non-XOF hash function.
    if ((EVP_MD_flags(md) & EVP_MD_FLAG_XOF) == 0) {
      EVPerr(EVP_F_EVP_DIGESTFINALXOF, EVP_R_NOT_XOF_OR_INVALID_LENGTH);
      return false;
    }
    md_len_ = xof_md_len.FromJust();
  }

  return true;
}",71,,113,3,,void
41553,BLOCK,-1,,"{
    mdctx_.reset();
    return false;
  }",69,,115,2,,void
41576,BLOCK,-1,,"{
    // This is a little hack to cause createHash to fail when an incorrect
    // hashSize option was passed for a non-XOF hash function.
    if ((EVP_MD_flags(md) & EVP_MD_FLAG_XOF) == 0) {
      EVPerr(EVP_F_EVP_DIGESTFINALXOF, EVP_R_NOT_XOF_OR_INVALID_LENGTH);
      return false;
    }
    md_len_ = xof_md_len.FromJust();
  }",64,,121,2,,void
41584,BLOCK,-1,,"{
      EVPerr(EVP_F_EVP_DIGESTFINALXOF, EVP_R_NOT_XOF_OR_INVALID_LENGTH);
      return false;
    }",52,,124,2,,void
41603,BLOCK,-1,,"{
  if (!mdctx_)
    return false;
  return EVP_DigestUpdate(mdctx_.get(), data, len) == 1;
}",53,,134,3,,void
41607,BLOCK,-1,,<empty>,5,,136,2,,void
41623,BLOCK,-1,,"{
  Decode<Hash>(args, [](Hash* hash, const FunctionCallbackInfo<Value>& args,
                        const char* data, size_t size) {
    Environment* env = Environment::GetCurrent(args);
    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");
    bool r = hash->HashUpdate(data, size);
    args.GetReturnValue().Set(r);
  });
}",64,,140,2,,void
41636,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  Hash* hash;
  ASSIGN_OR_RETURN_UNWRAP(&hash, args.Holder());

  enum encoding encoding = BUFFER;
  if (args.Length() >= 1) {
    encoding = ParseEncoding(env->isolate(), args[0], BUFFER);
  }

  unsigned int len = hash->md_len_;

  // TODO(tniessen): SHA3_squeeze does not work for zero-length outputs on all
  // platforms and will cause a segmentation fault if called. This workaround
  // causes hash.digest() to correctly return an empty buffer / string.
  // See https://github.com/openssl/openssl/issues/9431.

  if (!hash->digest_ && len > 0) {
    // Some hash algorithms such as SHA3 do not support calling
    // EVP_DigestFinal_ex more than once, however, Hash._flush
    // and Hash.digest can both be used to retrieve the digest,
    // so we need to cache it.
    // See https://github.com/nodejs/node/issues/28245.

    ByteSource::Builder digest(len);

    size_t default_len = EVP_MD_CTX_size(hash->mdctx_.get());
    int r...",64,,151,2,,void
41664,BLOCK,-1,,"{
    encoding = ParseEncoding(env->isolate(), args[0], BUFFER);
  }",27,,158,2,,void
41691,BLOCK,-1,,"{
    // Some hash algorithms such as SHA3 do not support calling
    // EVP_DigestFinal_ex more than once, however, Hash._flush
    // and Hash.digest can both be used to retrieve the digest,
    // so we need to cache it.
    // See https://github.com/nodejs/node/issues/28245.

    ByteSource::Builder digest(len);

    size_t default_len = EVP_MD_CTX_size(hash->mdctx_.get());
    int ret;
    if (len == default_len) {
      ret = EVP_DigestFinal_ex(
          hash->mdctx_.get(), digest.data<unsigned char>(), &len);
      // The output length should always equal hash->md_len_
      CHECK_EQ(len, hash->md_len_);
    } else {
      ret = EVP_DigestFinalXOF(
          hash->mdctx_.get(), digest.data<unsigned char>(), len);
    }

    if (ret != 1)
      return ThrowCryptoError(env, ERR_get_error());

    hash->digest_ = std::move(digest).release();
  }",34,,169,2,,void
41710,BLOCK,-1,,"{
      ret = EVP_DigestFinal_ex(
          hash->mdctx_.get(), digest.data<unsigned char>(), &len);
      // The output length should always equal hash->md_len_
      CHECK_EQ(len, hash->md_len_);
    }",29,,180,2,,void
41732,BLOCK,-1,,"{
      ret = EVP_DigestFinalXOF(
          hash->mdctx_.get(), digest.data<unsigned char>(), len);
    }",12,,185,1,,void
41751,BLOCK,-1,,<empty>,7,,191,2,,void
41802,BLOCK,-1,,"{
    CHECK(!error.IsEmpty());
    env->isolate()->ThrowException(error);
    return;
  }",21,,199,2,,void
41834,BLOCK,-1,,<empty>,28,,211,2,,void
41839,BLOCK,-1,,"{
  if (&other == this) return *this;
  this->~HashConfig();
  return *new (this) HashConfig(std::move(other));
}",64,,213,2,,void
41845,BLOCK,-1,,<empty>,23,,214,2,,void
41867,BLOCK,-1,,"{
  // If the Job is sync, then the HashConfig does not own the data.
  if (mode == kCryptoJobAsync)
    tracker->TrackFieldWithSize(""in"", in.size());
}",59,,219,2,,void
41872,BLOCK,-1,,<empty>,5,,222,2,,void
41889,BLOCK,-1,,"{
  *result = out->ToArrayBuffer(env);
  return Just(!result->IsEmpty());
}",35,,229,5,,void
41912,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  params->mode = mode;

  CHECK(args[offset]->IsString());  // Hash algorithm
  Utf8Value digest(env->isolate(), args[offset]);
  params->digest = EVP_get_digestbyname(*digest);
  if (UNLIKELY(params->digest == nullptr)) {
    THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *digest);
    return Nothing<bool>();
  }

  ArrayBufferOrViewContents<char> data(args[offset + 1]);
  if (UNLIKELY(!data.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(env, ""data is too big"");
    return Nothing<bool>();
  }
  params->in = mode == kCryptoJobAsync
      ? data.ToCopy()
      : data.ToByteSource();

  unsigned int expected = EVP_MD_size(params->digest);
  params->length = expected;
  if (UNLIKELY(args[offset + 2]->IsUint32())) {
    // length is expressed in terms of bits
    params->length =
        static_cast<uint32_t>(args[offset + 2]
            .As<Uint32>()->Value()) / CHAR_BIT;
    if (params->length != expected) {
      if...",25,,238,5,,void
41956,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *digest);
    return Nothing<bool>();
  }",44,,246,2,,void
41978,BLOCK,-1,,"{
    THROW_ERR_OUT_OF_RANGE(env, ""data is too big"");
    return Nothing<bool>();
  }",41,,252,2,,void
42022,BLOCK,-1,,"{
    // length is expressed in terms of bits
    params->length =
        static_cast<uint32_t>(args[offset + 2]
            .As<Uint32>()->Value()) / CHAR_BIT;
    if (params->length != expected) {
      if ((EVP_MD_flags(params->digest) & EVP_MD_FLAG_XOF) == 0) {
        THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Digest method not supported"");
        return Nothing<bool>();
      }
    }
  }",47,,262,2,,void
42048,BLOCK,-1,,"{
      if ((EVP_MD_flags(params->digest) & EVP_MD_FLAG_XOF) == 0) {
        THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Digest method not supported"");
        return Nothing<bool>();
      }
    }",37,,267,2,,void
42058,BLOCK,-1,,"{
        THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Digest method not supported"");
        return Nothing<bool>();
      }",66,,268,2,,void
42073,BLOCK,-1,,"{
  EVPMDPointer ctx(EVP_MD_CTX_new());

  if (UNLIKELY(!ctx ||
               EVP_DigestInit_ex(ctx.get(), params.digest, nullptr) <= 0 ||
               EVP_DigestUpdate(
                   ctx.get(), params.in.data<char>(), params.in.size()) <= 0)) {
    return false;
  }

  if (LIKELY(params.length > 0)) {
    unsigned int length = params.length;
    ByteSource::Builder buf(length);

    size_t expected = EVP_MD_CTX_size(ctx.get());

    int ret =
        (length == expected)
            ? EVP_DigestFinal_ex(ctx.get(), buf.data<unsigned char>(), &length)
            : EVP_DigestFinalXOF(ctx.get(), buf.data<unsigned char>(), length);

    if (UNLIKELY(ret != 1))
      return false;

    *out = std::move(buf).release();
  }

  return true;
}",22,,281,4,,void
42113,BLOCK,-1,,"{
    return false;
  }",80,,287,2,,void
42123,BLOCK,-1,,"{
    unsigned int length = params.length;
    ByteSource::Builder buf(length);

    size_t expected = EVP_MD_CTX_size(ctx.get());

    int ret =
        (length == expected)
            ? EVP_DigestFinal_ex(ctx.get(), buf.data<unsigned char>(), &length)
            : EVP_DigestFinalXOF(ctx.get(), buf.data<unsigned char>(), length);

    if (UNLIKELY(ret != 1))
      return false;

    *out = std::move(buf).release();
  }",34,,291,2,,void
42174,BLOCK,-1,,<empty>,7,,303,2,,void
42208,BLOCK,-1,,<empty>,1,,1,1,,ANY
42229,BLOCK,-1,,<empty>,1,,1,1,,ANY
42234,BLOCK,-1,,<empty>,35,,26,2,,void
42239,BLOCK,-1,,"{
  if (&other == this) return *this;
  this->~HKDFConfig();
  return *new (this) HKDFConfig(std::move(other));
}",64,,28,2,,void
42245,BLOCK,-1,,<empty>,23,,29,2,,void
42270,BLOCK,-1,,"{
  *result = out->ToArrayBuffer(env);
  return Just(!result->IsEmpty());
}",35,,38,5,,void
42293,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  params->mode = mode;

  CHECK(args[offset]->IsString());  // Hash
  CHECK(args[offset + 1]->IsObject());  // Key
  CHECK(IsAnyByteSource(args[offset + 2]));  // Salt
  CHECK(IsAnyByteSource(args[offset + 3]));  // Info
  CHECK(args[offset + 4]->IsUint32());  // Length

  Utf8Value hash(env->isolate(), args[offset]);
  params->digest = EVP_get_digestbyname(*hash);
  if (params->digest == nullptr) {
    THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *hash);
    return Nothing<bool>();
  }

  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args[offset + 1], Nothing<bool>());
  params->key = key->Data();

  ArrayBufferOrViewContents<char> salt(args[offset + 2]);
  ArrayBufferOrViewContents<char> info(args[offset + 3]);

  if (UNLIKELY(!salt.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(env, ""salt is too big"");
    return Nothing<bool>();
  }
  if (UNLIKELY(!info.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(e...",25,,47,5,,void
42368,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *hash);
    return Nothing<bool>();
  }",34,,60,2,,void
42415,BLOCK,-1,,"{
    THROW_ERR_OUT_OF_RANGE(env, ""salt is too big"");
    return Nothing<bool>();
  }",41,,72,2,,void
42428,BLOCK,-1,,"{
    THROW_ERR_OUT_OF_RANGE(env, ""info is too big"");
    return Nothing<bool>();
  }",41,,76,2,,void
42500,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_KEYLEN(env);
    return Nothing<bool>();
  }",36,,95,2,,void
42514,BLOCK,-1,,"{
  EVPKeyCtxPointer ctx =
      EVPKeyCtxPointer(EVP_PKEY_CTX_new_id(EVP_PKEY_HKDF, nullptr));
  if (!ctx || !EVP_PKEY_derive_init(ctx.get()) ||
      !EVP_PKEY_CTX_set_hkdf_md(ctx.get(), params.digest) ||
      !EVP_PKEY_CTX_add1_hkdf_info(
          ctx.get(), params.info.data<unsigned char>(), params.info.size())) {
    return false;
  }

  // TODO(panva): Once support for OpenSSL 1.1.1 is dropped the whole
  // of HKDFTraits::DeriveBits can be refactored to use
  // EVP_KDF which does handle zero length key.

  std::string_view salt;
  if (params.salt.size() != 0) {
    salt = {params.salt.data<char>(), params.salt.size()};
  } else {
    static const char default_salt[EVP_MAX_MD_SIZE] = {0};
    salt = {default_salt, static_cast<unsigned>(EVP_MD_size(params.digest))};
  }

  // We do not use EVP_PKEY_HKDEF_MODE_EXTRACT_AND_EXPAND and instead implement
  // the extraction step ourselves because EVP_PKEY_derive does not handle
  // zero-length keys, which are required for Web Cr...",22,,106,4,,void
42561,BLOCK,-1,,"{
    return false;
  }",78,,112,2,,void
42574,BLOCK,-1,,"{
    salt = {params.salt.data<char>(), params.salt.size()};
  }",32,,121,2,,void
42578,BLOCK,-1,,"{
    static const char default_salt[EVP_MAX_MD_SIZE] = {0};
    salt = {default_salt, static_cast<unsigned>(EVP_MD_size(params.digest))};
  }",10,,123,1,,void
42624,BLOCK,-1,,"{
    return false;
  }",33,,140,2,,void
42644,BLOCK,-1,,"{
    return false;
  }",74,,144,2,,void
42670,BLOCK,-1,,<empty>,5,,151,2,,void
42690,BLOCK,-1,,"{
  tracker->TrackField(""key"", key);
  // If the job is sync, then the HKDFConfig does not own the data
  if (mode == kCryptoJobAsync) {
    tracker->TrackFieldWithSize(""salt"", salt.size());
    tracker->TrackFieldWithSize(""info"", info.size());
  }
}",59,,157,2,,void
42701,BLOCK,-1,,"{
    tracker->TrackFieldWithSize(""salt"", salt.size());
    tracker->TrackFieldWithSize(""info"", info.size());
  }",32,,160,2,,void
42736,BLOCK,-1,,<empty>,1,,1,1,,ANY
42743,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(args);
    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");
    bool r = hmac->HmacUpdate(data, size);
    args.GetReturnValue().Set(r);
  }",56,,104,5,,void
42757,BLOCK,-1,,<empty>,7,,107,2,,void
42810,BLOCK,-1,,<empty>,1,,1,1,,ANY
42816,BLOCK,-1,,"{
  MakeWeak();
}",21,,33,3,,void
42822,BLOCK,-1,,"{
  tracker->TrackFieldWithSize(""context"", ctx_ ? kSizeOf_HMAC_CTX : 0);
}",53,,37,2,,void
42837,BLOCK,-1,,"{
  Isolate* isolate = env->isolate();
  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);

  t->InstanceTemplate()->SetInternalFieldCount(Hmac::kInternalFieldCount);

  SetProtoMethod(isolate, t, ""init"", HmacInit);
  SetProtoMethod(isolate, t, ""update"", HmacUpdate);
  SetProtoMethod(isolate, t, ""digest"", HmacDigest);

  SetConstructorFunction(env->context(), target, ""Hmac"", t);

  HmacJob::Initialize(env, target);
}",63,,41,3,,void
42897,BLOCK,-1,,"{
  registry->Register(New);
  registry->Register(HmacInit);
  registry->Register(HmacUpdate);
  registry->Register(HmacDigest);
  HmacJob::RegisterExternalReferences(registry);
}",76,,56,2,,void
42927,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  new Hmac(env, args.This());
}",57,,64,2,,void
42949,BLOCK,-1,,"{
  HandleScope scope(env()->isolate());

  const EVP_MD* md = EVP_get_digestbyname(hash_type);
  if (md == nullptr)
    return THROW_ERR_CRYPTO_INVALID_DIGEST(
        env(), ""Invalid digest: %s"", hash_type);
  if (key_len == 0) {
    key = """";
  }
  ctx_.reset(HMAC_CTX_new());
  if (!ctx_ || !HMAC_Init_ex(ctx_.get(), key, key_len, md, nullptr)) {
    ctx_.reset();
    return ThrowCryptoError(env(), ERR_get_error());
  }
}",74,,69,4,,void
42965,BLOCK,-1,,<empty>,5,,74,2,,void
42975,BLOCK,-1,,"{
    key = """";
  }",21,,76,2,,void
42998,BLOCK,-1,,"{
    ctx_.reset();
    return ThrowCryptoError(env(), ERR_get_error());
  }",70,,80,2,,void
43011,BLOCK,-1,,"{
  Hmac* hmac;
  ASSIGN_OR_RETURN_UNWRAP(&hmac, args.Holder());
  Environment* env = hmac->env();

  const node::Utf8Value hash_type(env->isolate(), args[0]);
  ByteSource key = ByteSource::FromSecretKeyBytes(env, args[1]);
  hmac->HmacInit(*hash_type, key.data<char>(), key.size());
}",62,,86,2,,void
43066,BLOCK,-1,,"{
  return ctx_ && HMAC_Update(ctx_.get(),
                             reinterpret_cast<const unsigned char*>(data),
                             len) == 1;
}",53,,96,3,,void
43084,BLOCK,-1,,"{
  Decode<Hmac>(args, [](Hmac* hmac, const FunctionCallbackInfo<Value>& args,
                        const char* data, size_t size) {
    Environment* env = Environment::GetCurrent(args);
    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");
    bool r = hmac->HmacUpdate(data, size);
    args.GetReturnValue().Set(r);
  });
}",64,,102,2,,void
43097,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  Hmac* hmac;
  ASSIGN_OR_RETURN_UNWRAP(&hmac, args.Holder());

  enum encoding encoding = BUFFER;
  if (args.Length() >= 1) {
    encoding = ParseEncoding(env->isolate(), args[0], BUFFER);
  }

  unsigned char md_value[EVP_MAX_MD_SIZE];
  unsigned int md_len = 0;

  if (hmac->ctx_) {
    bool ok = HMAC_Final(hmac->ctx_.get(), md_value, &md_len);
    hmac->ctx_.reset();
    if (!ok) {
      return ThrowCryptoError(env, ERR_get_error(), ""Failed to finalize HMAC"");
    }
  }

  Local<Value> error;
  MaybeLocal<Value> rc =
      StringBytes::Encode(env->isolate(),
                          reinterpret_cast<const char*>(md_value),
                          md_len,
                          encoding,
                          &error);
  if (rc.IsEmpty()) {
    CHECK(!error.IsEmpty());
    env->isolate()->ThrowException(error);
    return;
  }
  args.GetReturnValue().Set(rc.FromMaybe(Local<Value>()));
}",64,,113,2,,void
43125,BLOCK,-1,,"{
    encoding = ParseEncoding(env->isolate(), args[0], BUFFER);
  }",27,,120,2,,void
43146,BLOCK,-1,,"{
    bool ok = HMAC_Final(hmac->ctx_.get(), md_value, &md_len);
    hmac->ctx_.reset();
    if (!ok) {
      return ThrowCryptoError(env, ERR_get_error(), ""Failed to finalize HMAC"");
    }
  }",19,,127,2,,void
43169,BLOCK,-1,,"{
      return ThrowCryptoError(env, ERR_get_error(), ""Failed to finalize HMAC"");
    }",14,,130,2,,void
43206,BLOCK,-1,,"{
    CHECK(!error.IsEmpty());
    env->isolate()->ThrowException(error);
    return;
  }",21,,142,2,,void
43238,BLOCK,-1,,<empty>,28,,156,2,,void
43243,BLOCK,-1,,"{
  if (&other == this) return *this;
  this->~HmacConfig();
  return *new (this) HmacConfig(std::move(other));
}",64,,158,2,,void
43249,BLOCK,-1,,<empty>,23,,159,2,,void
43271,BLOCK,-1,,"{
  tracker->TrackField(""key"", key.get());
  // If the job is sync, then the HmacConfig does not own the data
  if (job_mode == kCryptoJobAsync) {
    tracker->TrackFieldWithSize(""data"", data.size());
    tracker->TrackFieldWithSize(""signature"", signature.size());
  }
}",59,,164,2,,void
43285,BLOCK,-1,,"{
    tracker->TrackFieldWithSize(""data"", data.size());
    tracker->TrackFieldWithSize(""signature"", signature.size());
  }",36,,167,2,,void
43311,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  params->job_mode = mode;

  CHECK(args[offset]->IsUint32());  // SignConfiguration::Mode
  params->mode =
    static_cast<SignConfiguration::Mode>(args[offset].As<Uint32>()->Value());

  CHECK(args[offset + 1]->IsString());  // Hash
  CHECK(args[offset + 2]->IsObject());  // Key

  Utf8Value digest(env->isolate(), args[offset + 1]);
  params->digest = EVP_get_digestbyname(*digest);
  if (params->digest == nullptr) {
    THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *digest);
    return Nothing<bool>();
  }

  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args[offset + 2], Nothing<bool>());
  params->key = key->Data();

  ArrayBufferOrViewContents<char> data(args[offset + 3]);
  if (UNLIKELY(!data.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(env, ""data is too big"");
    return Nothing<bool>();
  }
  params->data = mode == kCryptoJobAsync
      ? data.ToCopy()
      : data.ToByteSource();

  if (!args[off...",25,,177,5,,void
43389,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *digest);
    return Nothing<bool>();
  }",34,,191,2,,void
43429,BLOCK,-1,,"{
    THROW_ERR_OUT_OF_RANGE(env, ""data is too big"");
    return Nothing<bool>();
  }",41,,201,2,,void
43461,BLOCK,-1,,"{
    ArrayBufferOrViewContents<char> signature(args[offset + 4]);
    if (UNLIKELY(!signature.CheckSizeInt32())) {
      THROW_ERR_OUT_OF_RANGE(env, ""signature is too big"");
      return Nothing<bool>();
    }
    params->signature = mode == kCryptoJobAsync
        ? signature.ToCopy()
        : signature.ToByteSource();
  }",41,,209,2,,void
43476,BLOCK,-1,,"{
      THROW_ERR_OUT_OF_RANGE(env, ""signature is too big"");
      return Nothing<bool>();
    }",48,,211,2,,void
43507,BLOCK,-1,,"{
  HMACCtxPointer ctx(HMAC_CTX_new());

  if (!ctx ||
      !HMAC_Init_ex(
          ctx.get(),
          params.key->GetSymmetricKey(),
          params.key->GetSymmetricKeySize(),
          params.digest,
          nullptr)) {
    return false;
  }

  if (!HMAC_Update(
          ctx.get(),
          params.data.data<unsigned char>(),
          params.data.size())) {
    return false;
  }

  ByteSource::Builder buf(EVP_MAX_MD_SIZE);
  unsigned int len;

  if (!HMAC_Final(ctx.get(), buf.data<unsigned char>(), &len)) {
    return false;
  }

  *out = std::move(buf).release(len);

  return true;
}",22,,226,4,,void
43537,BLOCK,-1,,"{
    return false;
  }",21,,235,2,,void
43559,BLOCK,-1,,"{
    return false;
  }",32,,242,2,,void
43579,BLOCK,-1,,"{
    return false;
  }",64,,249,2,,void
43603,BLOCK,-1,,"{
  switch (params.mode) {
    case SignConfiguration::kSign:
      *result = out->ToArrayBuffer(env);
      break;
    case SignConfiguration::kVerify:
      *result = Boolean::New(
          env->isolate(),
          out->size() > 0 && out->size() == params.signature.size() &&
              memcmp(out->data(), params.signature.data(), out->size()) == 0);
      break;
    default:
      UNREACHABLE();
  }
  return Just(!result->IsEmpty());
}",27,,262,5,,void
43608,BLOCK,-1,,"{
    case SignConfiguration::kSign:
      *result = out->ToArrayBuffer(env);
      break;
    case SignConfiguration::kVerify:
      *result = Boolean::New(
          env->isolate(),
          out->size() > 0 && out->size() == params.signature.size() &&
              memcmp(out->data(), params.signature.data(), out->size()) == 0);
      break;
    default:
      UNREACHABLE();
  }",24,,263,2,,void
43703,BLOCK,-1,,<empty>,1,,1,1,,ANY
43726,BLOCK,-1,,<empty>,1,,1,1,,ANY
43734,BLOCK,-1,,"{
  CHECK(args[*offset]->IsInt32());
  params->params.id = args[*offset].As<Int32>()->Value();

  *offset += 1;

  return Just(true);
}",34,,37,5,,void
43770,BLOCK,-1,,"{
  EVPKeyCtxPointer ctx =
      EVPKeyCtxPointer(EVP_PKEY_CTX_new_id(params->params.id, nullptr));
  if (!ctx || EVP_PKEY_keygen_init(ctx.get()) <= 0)
    return EVPKeyCtxPointer();

  return ctx;
}",74,,46,2,,void
43793,BLOCK,-1,,<empty>,5,,50,2,,void
43802,BLOCK,-1,,"{
  if (out) tracker->TrackFieldWithSize(""out"", length);
}",67,,55,2,,void
43805,BLOCK,-1,,<empty>,12,,56,2,,void
43819,BLOCK,-1,,"{
  CHECK(args[*offset]->IsUint32());
  uint32_t bits = args[*offset].As<Uint32>()->Value();
  params->length = bits / CHAR_BIT;
  *offset += 1;
  return Just(true);
}",33,,63,5,,void
43860,BLOCK,-1,,"{
  ByteSource::Builder bytes(params->length);
  if (CSPRNG(bytes.data<unsigned char>(), params->length).is_err())
    return KeyGenJobStatus::FAILED;
  params->out = std::move(bytes).release();
  return KeyGenJobStatus::OK;
}",74,,72,3,,void
43878,BLOCK,-1,,<empty>,5,,75,2,,void
43905,BLOCK,-1,,"{
  std::shared_ptr<KeyObjectData> data =
      KeyObjectData::CreateSecret(std::move(params->out));
  return Just(KeyObjectHandle::Create(env, data).ToLocal(result));
}",65,,82,4,,void
43943,BLOCK,-1,,"{
  NidKeyPairGenJob::Initialize(env, target);
  SecretKeyGenJob::Initialize(env, target);
}",57,,89,3,,void
43960,BLOCK,-1,,"{
  NidKeyPairGenJob::RegisterExternalReferences(registry);
  SecretKeyGenJob::RegisterExternalReferences(registry);
}",70,,94,2,,void
43991,BLOCK,-1,,<empty>,1,,1,1,,ANY
43996,BLOCK,-1,,"{  // NOLINT(runtime/int)
        return d2i_PUBKEY(nullptr, p, l);
      }",43,,115,3,,void
44009,BLOCK,-1,,"{  // NOLINT(runtime/int)
        return d2i_PublicKey(EVP_PKEY_RSA, nullptr, p, l);
      }",43,,124,3,,void
44022,BLOCK,-1,,"{  // NOLINT(runtime/int)
        X509Pointer x509(d2i_X509(nullptr, p, l));
        return x509 ? X509_get_pubkey(x509.get()) : nullptr;
      }",43,,133,3,,void
44077,BLOCK,-1,,<empty>,1,,1,1,,ANY
44086,BLOCK,-1,,"{
  // During key pair generation, it is possible not to specify a key encoding,
  // which will lead to a key object being returned.
  if (args[*offset]->IsUndefined()) {
    CHECK_EQ(context, kKeyContextGenerate);
    CHECK(args[*offset + 1]->IsUndefined());
    config->output_key_object_ = true;
  } else {
    config->output_key_object_ = false;

    CHECK(args[*offset]->IsInt32());
    config->format_ = static_cast<PKFormatType>(
        args[*offset].As<Int32>()->Value());

    if (args[*offset + 1]->IsInt32()) {
      config->type_ = Just<PKEncodingType>(static_cast<PKEncodingType>(
          args[*offset + 1].As<Int32>()->Value()));
    } else {
      CHECK(
          (context == kKeyContextInput &&
           config->format_ == kKeyFormatPEM) ||
          (context == kKeyContextGenerate &&
           config->format_ == kKeyFormatJWK));
      CHECK(args[*offset + 1]->IsNullOrUndefined());
      config->type_ = Nothing<PKEncodingType>();
    }
  }

  *offset += 2;
}",33,,47,5,,void
44095,BLOCK,-1,,"{
    CHECK_EQ(context, kKeyContextGenerate);
    CHECK(args[*offset + 1]->IsUndefined());
    config->output_key_object_ = true;
  }",37,,50,2,,void
44115,BLOCK,-1,,"{
    config->output_key_object_ = false;

    CHECK(args[*offset]->IsInt32());
    config->format_ = static_cast<PKFormatType>(
        args[*offset].As<Int32>()->Value());

    if (args[*offset + 1]->IsInt32()) {
      config->type_ = Just<PKEncodingType>(static_cast<PKEncodingType>(
          args[*offset + 1].As<Int32>()->Value()));
    } else {
      CHECK(
          (context == kKeyContextInput &&
           config->format_ == kKeyFormatPEM) ||
          (context == kKeyContextGenerate &&
           config->format_ == kKeyFormatJWK));
      CHECK(args[*offset + 1]->IsNullOrUndefined());
      config->type_ = Nothing<PKEncodingType>();
    }
  }",10,,54,1,,void
44155,BLOCK,-1,,"{
      config->type_ = Just<PKEncodingType>(static_cast<PKEncodingType>(
          args[*offset + 1].As<Int32>()->Value()));
    }",39,,61,2,,void
44179,BLOCK,-1,,"{
      CHECK(
          (context == kKeyContextInput &&
           config->format_ == kKeyFormatPEM) ||
          (context == kKeyContextGenerate &&
           config->format_ == kKeyFormatJWK));
      CHECK(args[*offset + 1]->IsNullOrUndefined());
      config->type_ = Nothing<PKEncodingType>();
    }",12,,64,1,,void
44226,BLOCK,-1,,"{
  unsigned char* der_data;
  long der_len;  // NOLINT(runtime/int)

  // This skips surrounding data and decodes PEM to DER.
  {
    MarkPopErrorOnReturn mark_pop_error_on_return;
    if (PEM_bytes_read_bio(&der_data, &der_len, nullptr, name,
                           bp.get(), nullptr, nullptr) != 1)
      return ParseKeyResult::kParseKeyNotRecognized;
  }

  // OpenSSL might modify the pointer, so we need to make a copy before parsing.
  const unsigned char* p = der_data;
  pkey->reset(parse(&p, der_len));
  OPENSSL_clear_free(der_data, der_len);

  return *pkey ? ParseKeyResult::kParseKeyOk :
                 ParseKeyResult::kParseKeyFailed;
}",77,,83,5,,void
44229,BLOCK,3,,"{
    MarkPopErrorOnReturn mark_pop_error_on_return;
    if (PEM_bytes_read_bio(&der_data, &der_len, nullptr, name,
                           bp.get(), nullptr, nullptr) != 1)
      return ParseKeyResult::kParseKeyNotRecognized;
  }",3,,88,3,,void
44247,BLOCK,-1,,<empty>,7,,92,2,,void
44283,BLOCK,-1,,"{
  BIOPointer bp(BIO_new_mem_buf(const_cast<char*>(key_pem), key_pem_len));
  if (!bp)
    return ParseKeyResult::kParseKeyFailed;

  ParseKeyResult ret;

  // Try parsing as a SubjectPublicKeyInfo first.
  ret = TryParsePublicKey(pkey, bp, ""PUBLIC KEY"",
      [](const unsigned char** p, long l) {  // NOLINT(runtime/int)
        return d2i_PUBKEY(nullptr, p, l);
      });
  if (ret != ParseKeyResult::kParseKeyNotRecognized)
    return ret;

  // Maybe it is PKCS#1.
  CHECK(BIO_reset(bp.get()));
  ret = TryParsePublicKey(pkey, bp, ""RSA PUBLIC KEY"",
      [](const unsigned char** p, long l) {  // NOLINT(runtime/int)
        return d2i_PublicKey(EVP_PKEY_RSA, nullptr, p, l);
      });
  if (ret != ParseKeyResult::kParseKeyNotRecognized)
    return ret;

  // X.509 fallback.
  CHECK(BIO_reset(bp.get()));
  return TryParsePublicKey(pkey, bp, ""CERTIFICATE"",
      [](const unsigned char** p, long l) {  // NOLINT(runtime/int)
        X509Pointer x509(d2i_X509(nullptr, p, l));
        retur...",51,,106,4,,void
44294,BLOCK,-1,,<empty>,5,,109,2,,void
44313,BLOCK,-1,,<empty>,5,,119,2,,void
44335,BLOCK,-1,,<empty>,5,,128,2,,void
44357,BLOCK,-1,,"{
  if (config.format_ == kKeyFormatPEM) {
    return ParsePublicKeyPEM(pkey, key, key_len);
  } else {
    CHECK_EQ(config.format_, kKeyFormatDER);

    const unsigned char* p = reinterpret_cast<const unsigned char*>(key);
    if (config.type_.ToChecked() == kKeyEncodingPKCS1) {
      pkey->reset(d2i_PublicKey(EVP_PKEY_RSA, nullptr, &p, key_len));
    } else {
      CHECK_EQ(config.type_.ToChecked(), kKeyEncodingSPKI);
      pkey->reset(d2i_PUBKEY(nullptr, &p, key_len));
    }

    return *pkey ? ParseKeyResult::kParseKeyOk :
                   ParseKeyResult::kParseKeyFailed;
  }
}",47,,142,5,,void
44364,BLOCK,-1,,"{
    return ParsePublicKeyPEM(pkey, key, key_len);
  }",40,,143,2,,void
44371,BLOCK,-1,,"{
    CHECK_EQ(config.format_, kKeyFormatDER);

    const unsigned char* p = reinterpret_cast<const unsigned char*>(key);
    if (config.type_.ToChecked() == kKeyEncodingPKCS1) {
      pkey->reset(d2i_PublicKey(EVP_PKEY_RSA, nullptr, &p, key_len));
    } else {
      CHECK_EQ(config.type_.ToChecked(), kKeyEncodingSPKI);
      pkey->reset(d2i_PUBKEY(nullptr, &p, key_len));
    }

    return *pkey ? ParseKeyResult::kParseKeyOk :
                   ParseKeyResult::kParseKeyFailed;
  }",10,,145,1,,void
44392,BLOCK,-1,,"{
      pkey->reset(d2i_PublicKey(EVP_PKEY_RSA, nullptr, &p, key_len));
    }",56,,149,2,,void
44404,BLOCK,-1,,"{
      CHECK_EQ(config.type_.ToChecked(), kKeyEncodingSPKI);
      pkey->reset(d2i_PUBKEY(nullptr, &p, key_len));
    }",12,,151,1,,void
44439,BLOCK,-1,,"{
  if (size < 2 || data[0] != 0x30)
    return false;

  if (data[1] & 0x80) {
    // Long form.
    size_t n_bytes = data[1] & ~0x80;
    if (n_bytes + 2 > size || n_bytes > sizeof(size_t))
      return false;
    size_t length = 0;
    for (size_t i = 0; i < n_bytes; i++)
      length = (length << 8) | data[i + 2];
    *data_offset = 2 + n_bytes;
    *data_size = std::min(size - 2 - n_bytes, length);
  } else {
    // Short form.
    *data_offset = 2;
    *data_size = std::min<size_t>(size - 2, data[1]);
  }

  return true;
}",61,,162,5,,void
44450,BLOCK,-1,,<empty>,5,,164,2,,void
44459,BLOCK,-1,,"{
    // Long form.
    size_t n_bytes = data[1] & ~0x80;
    if (n_bytes + 2 > size || n_bytes > sizeof(size_t))
      return false;
    size_t length = 0;
    for (size_t i = 0; i < n_bytes; i++)
      length = (length << 8) | data[i + 2];
    *data_offset = 2 + n_bytes;
    *data_size = std::min(size - 2 - n_bytes, length);
  }",23,,166,2,,void
44480,BLOCK,-1,,<empty>,7,,170,2,,void
44488,BLOCK,-1,,<empty>,5,,172,1,,void
44529,BLOCK,-1,,"{
    // Short form.
    *data_offset = 2;
    *data_size = std::min<size_t>(size - 2, data[1]);
  }",10,,176,1,,void
44558,BLOCK,-1,,"{
  // Both RSAPrivateKey and RSAPublicKey structures start with a SEQUENCE.
  size_t offset, len;
  if (!IsASN1Sequence(data, size, &offset, &len))
    return false;

  // An RSAPrivateKey sequence always starts with a single-byte integer whose
  // value is either 0 or 1, whereas an RSAPublicKey starts with the modulus
  // (which is the product of two primes and therefore at least 4), so we can
  // decide the type of the structure based on the first three bytes of the
  // sequence.
  return len >= 3 &&
         data[offset] == 2 &&
         data[offset + 1] == 1 &&
         !(data[offset + 2] & 0xfe);
}",62,,185,3,,void
44570,BLOCK,-1,,<empty>,5,,189,2,,void
44605,BLOCK,-1,,"{
  // Both PrivateKeyInfo and EncryptedPrivateKeyInfo start with a SEQUENCE.
  size_t offset, len;
  if (!IsASN1Sequence(data, size, &offset, &len))
    return false;

  // A PrivateKeyInfo sequence always starts with an integer whereas an
  // EncryptedPrivateKeyInfo starts with an AlgorithmIdentifier.
  return len >= 1 &&
         data[offset] != 2;
}",72,,202,3,,void
44617,BLOCK,-1,,<empty>,5,,206,2,,void
44637,BLOCK,-1,,"{
  const ByteSource* passphrase = config.passphrase_.get();

  if (config.format_ == kKeyFormatPEM) {
    BIOPointer bio(BIO_new_mem_buf(key, key_len));
    if (!bio)
      return ParseKeyResult::kParseKeyFailed;

    pkey->reset(PEM_read_bio_PrivateKey(bio.get(),
                                        nullptr,
                                        PasswordCallback,
                                        &passphrase));
  } else {
    CHECK_EQ(config.format_, kKeyFormatDER);

    if (config.type_.ToChecked() == kKeyEncodingPKCS1) {
      const unsigned char* p = reinterpret_cast<const unsigned char*>(key);
      pkey->reset(d2i_PrivateKey(EVP_PKEY_RSA, nullptr, &p, key_len));
    } else if (config.type_.ToChecked() == kKeyEncodingPKCS8) {
      BIOPointer bio(BIO_new_mem_buf(key, key_len));
      if (!bio)
        return ParseKeyResult::kParseKeyFailed;

      if (IsEncryptedPrivateKeyInfo(
              reinterpret_cast<const unsigned char*>(key), key_len)) {
        pkey->rese...",48,,217,5,,void
44653,BLOCK,-1,,"{
    BIOPointer bio(BIO_new_mem_buf(key, key_len));
    if (!bio)
      return ParseKeyResult::kParseKeyFailed;

    pkey->reset(PEM_read_bio_PrivateKey(bio.get(),
                                        nullptr,
                                        PasswordCallback,
                                        &passphrase));
  }",40,,220,2,,void
44662,BLOCK,-1,,<empty>,7,,223,2,,void
44681,BLOCK,-1,,"{
    CHECK_EQ(config.format_, kKeyFormatDER);

    if (config.type_.ToChecked() == kKeyEncodingPKCS1) {
      const unsigned char* p = reinterpret_cast<const unsigned char*>(key);
      pkey->reset(d2i_PrivateKey(EVP_PKEY_RSA, nullptr, &p, key_len));
    } else if (config.type_.ToChecked() == kKeyEncodingPKCS8) {
      BIOPointer bio(BIO_new_mem_buf(key, key_len));
      if (!bio)
        return ParseKeyResult::kParseKeyFailed;

      if (IsEncryptedPrivateKeyInfo(
              reinterpret_cast<const unsigned char*>(key), key_len)) {
        pkey->reset(d2i_PKCS8PrivateKey_bio(bio.get(),
                                            nullptr,
                                            PasswordCallback,
                                            &passphrase));
      } else {
        PKCS8Pointer p8inf(d2i_PKCS8_PRIV_KEY_INFO_bio(bio.get(), nullptr));
        if (p8inf)
          pkey->reset(EVP_PKCS82PKEY(p8inf.get()));
      }
    } else {
      CHECK_EQ(config.type_.ToChecked(), k...",10,,229,1,,void
44696,BLOCK,-1,,"{
      const unsigned char* p = reinterpret_cast<const unsigned char*>(key);
      pkey->reset(d2i_PrivateKey(EVP_PKEY_RSA, nullptr, &p, key_len));
    }",56,,232,2,,void
44714,BLOCK,-1,,<empty>,12,,235,1,,void
44724,BLOCK,-1,,"{
      BIOPointer bio(BIO_new_mem_buf(key, key_len));
      if (!bio)
        return ParseKeyResult::kParseKeyFailed;

      if (IsEncryptedPrivateKeyInfo(
              reinterpret_cast<const unsigned char*>(key), key_len)) {
        pkey->reset(d2i_PKCS8PrivateKey_bio(bio.get(),
                                            nullptr,
                                            PasswordCallback,
                                            &passphrase));
      } else {
        PKCS8Pointer p8inf(d2i_PKCS8_PRIV_KEY_INFO_bio(bio.get(), nullptr));
        if (p8inf)
          pkey->reset(EVP_PKCS82PKEY(p8inf.get()));
      }
    }",63,,235,2,,void
44733,BLOCK,-1,,<empty>,9,,238,2,,void
44744,BLOCK,-1,,"{
        pkey->reset(d2i_PKCS8PrivateKey_bio(bio.get(),
                                            nullptr,
                                            PasswordCallback,
                                            &passphrase));
      }",70,,241,2,,void
44759,BLOCK,-1,,"{
        PKCS8Pointer p8inf(d2i_PKCS8_PRIV_KEY_INFO_bio(bio.get(), nullptr));
        if (p8inf)
          pkey->reset(EVP_PKCS82PKEY(p8inf.get()));
      }",14,,246,1,,void
44770,BLOCK,-1,,<empty>,11,,249,2,,void
44781,BLOCK,-1,,"{
      CHECK_EQ(config.type_.ToChecked(), kKeyEncodingSEC1);
      const unsigned char* p = reinterpret_cast<const unsigned char*>(key);
      pkey->reset(d2i_PrivateKey(EVP_PKEY_EC, nullptr, &p, key_len));
    }",12,,251,1,,void
44814,BLOCK,-1,,<empty>,5,,261,2,,void
44822,BLOCK,-1,,<empty>,5,,264,2,,void
44837,BLOCK,-1,,"{
    if (config.passphrase_.IsEmpty())
      return ParseKeyResult::kParseKeyNeedPassphrase;
  }",55,,266,2,,void
44845,BLOCK,-1,,<empty>,7,,268,2,,void
44860,BLOCK,-1,,"{
  BUF_MEM* bptr;
  BIO_get_mem_ptr(bio, &bptr);
  if (format == kKeyFormatPEM) {
    // PEM is an ASCII format, so we will return it as a string.
    return String::NewFromUtf8(env->isolate(), bptr->data,
                               NewStringType::kNormal,
                               bptr->length).FromMaybe(Local<Value>());
  } else {
    CHECK_EQ(format, kKeyFormatDER);
    // DER is binary, return it as a buffer.
    return Buffer::Copy(env, bptr->data, bptr->length)
        .FromMaybe(Local<Value>());
  }
}",26,,276,4,,void
44870,BLOCK,-1,,"{
    // PEM is an ASCII format, so we will return it as a string.
    return String::NewFromUtf8(env->isolate(), bptr->data,
                               NewStringType::kNormal,
                               bptr->length).FromMaybe(Local<Value>());
  }",32,,279,2,,void
44894,BLOCK,-1,,"{
    CHECK_EQ(format, kKeyFormatDER);
    // DER is binary, return it as a buffer.
    return Buffer::Copy(env, bptr->data, bptr->length)
        .FromMaybe(Local<Value>());
  }",10,,284,1,,void
44920,BLOCK,-1,,"{
  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);

  // If an empty string was passed as the passphrase, the ByteSource might
  // contain a null pointer, which OpenSSL will ignore, causing it to invoke its
  // default passphrase callback, which would block the thread until the user
  // manually enters a passphrase. We could supply our own passphrase callback
  // to handle this special case, but it is easier to avoid passing a null
  // pointer to OpenSSL.
  char* pass = nullptr;
  size_t pass_len = 0;
  if (!config.passphrase_.IsEmpty()) {
    pass = const_cast<char*>(config.passphrase_->data<char>());
    pass_len = config.passphrase_->size();
    if (pass == nullptr) {
      // OpenSSL will not actually dereference this pointer, so it can be any
      // non-null pointer. We cannot assert that directly, which is why we
      // intentionally use a pointer that will likely cause a segmentation fault
      // when dereferenced.
      CHECK_EQ(pass_len, 0);
      pass = rei...",45,,296,4,,void
44923,BLOCK,-1,,<empty>,,,,2,,<empty>
44944,BLOCK,-1,,"{
    pass = const_cast<char*>(config.passphrase_->data<char>());
    pass_len = config.passphrase_->size();
    if (pass == nullptr) {
      // OpenSSL will not actually dereference this pointer, so it can be any
      // non-null pointer. We cannot assert that directly, which is why we
      // intentionally use a pointer that will likely cause a segmentation fault
      // when dereferenced.
      CHECK_EQ(pass_len, 0);
      pass = reinterpret_cast<char*>(-1);
      CHECK_NE(pass, nullptr);
    }
  }",38,,308,2,,void
44967,BLOCK,-1,,"{
      // OpenSSL will not actually dereference this pointer, so it can be any
      // non-null pointer. We cannot assert that directly, which is why we
      // intentionally use a pointer that will likely cause a segmentation fault
      // when dereferenced.
      CHECK_EQ(pass_len, 0);
      pass = reinterpret_cast<char*>(-1);
      CHECK_NE(pass, nullptr);
    }",26,,311,2,,void
44995,BLOCK,-1,,"{
    // PKCS#1 is only permitted for RSA keys.
    CHECK_EQ(EVP_PKEY_id(pkey), EVP_PKEY_RSA);

    RSAPointer rsa(EVP_PKEY_get1_RSA(pkey));
    if (config.format_ == kKeyFormatPEM) {
      // Encode PKCS#1 as PEM.
      err = PEM_write_bio_RSAPrivateKey(
                bio.get(), rsa.get(),
                config.cipher_,
                reinterpret_cast<unsigned char*>(pass),
                pass_len,
                nullptr, nullptr) != 1;
    } else {
      // Encode PKCS#1 as DER. This does not permit encryption.
      CHECK_EQ(config.format_, kKeyFormatDER);
      CHECK_NULL(config.cipher_);
      err = i2d_RSAPrivateKey_bio(bio.get(), rsa.get()) != 1;
    }
  }",43,,326,2,,void
45010,BLOCK,-1,,"{
      // Encode PKCS#1 as PEM.
      err = PEM_write_bio_RSAPrivateKey(
                bio.get(), rsa.get(),
                config.cipher_,
                reinterpret_cast<unsigned char*>(pass),
                pass_len,
                nullptr, nullptr) != 1;
    }",42,,331,2,,void
45034,BLOCK,-1,,"{
      // Encode PKCS#1 as DER. This does not permit encryption.
      CHECK_EQ(config.format_, kKeyFormatDER);
      CHECK_NULL(config.cipher_);
      err = i2d_RSAPrivateKey_bio(bio.get(), rsa.get()) != 1;
    }",12,,339,1,,void
45058,BLOCK,-1,,<empty>,10,,345,1,,void
45063,BLOCK,-1,,"{
    if (config.format_ == kKeyFormatPEM) {
      // Encode PKCS#8 as PEM.
      err = PEM_write_bio_PKCS8PrivateKey(
                bio.get(), pkey,
                config.cipher_,
                pass,
                pass_len,
                nullptr, nullptr) != 1;
    } else {
      // Encode PKCS#8 as DER.
      CHECK_EQ(config.format_, kKeyFormatDER);
      err = i2d_PKCS8PrivateKey_bio(
                bio.get(), pkey,
                config.cipher_,
                pass,
                pass_len,
                nullptr, nullptr) != 1;
    }
  }",50,,345,2,,void
45070,BLOCK,-1,,"{
      // Encode PKCS#8 as PEM.
      err = PEM_write_bio_PKCS8PrivateKey(
                bio.get(), pkey,
                config.cipher_,
                pass,
                pass_len,
                nullptr, nullptr) != 1;
    }",42,,346,2,,void
45089,BLOCK,-1,,"{
      // Encode PKCS#8 as DER.
      CHECK_EQ(config.format_, kKeyFormatDER);
      err = i2d_PKCS8PrivateKey_bio(
                bio.get(), pkey,
                config.cipher_,
                pass,
                pass_len,
                nullptr, nullptr) != 1;
    }",12,,354,1,,void
45113,BLOCK,-1,,"{
    CHECK_EQ(encoding_type, kKeyEncodingSEC1);

    // SEC1 is only permitted for EC keys.
    CHECK_EQ(EVP_PKEY_id(pkey), EVP_PKEY_EC);

    ECKeyPointer ec_key(EVP_PKEY_get1_EC_KEY(pkey));
    if (config.format_ == kKeyFormatPEM) {
      // Encode SEC1 as PEM.
      err = PEM_write_bio_ECPrivateKey(
                bio.get(), ec_key.get(),
                config.cipher_,
                reinterpret_cast<unsigned char*>(pass),
                pass_len,
                nullptr, nullptr) != 1;
    } else {
      // Encode SEC1 as DER. This does not permit encryption.
      CHECK_EQ(config.format_, kKeyFormatDER);
      CHECK_NULL(config.cipher_);
      err = i2d_ECPrivateKey_bio(bio.get(), ec_key.get()) != 1;
    }
  }",10,,364,1,,void
45131,BLOCK,-1,,"{
      // Encode SEC1 as PEM.
      err = PEM_write_bio_ECPrivateKey(
                bio.get(), ec_key.get(),
                config.cipher_,
                reinterpret_cast<unsigned char*>(pass),
                pass_len,
                nullptr, nullptr) != 1;
    }",42,,371,2,,void
45155,BLOCK,-1,,"{
      // Encode SEC1 as DER. This does not permit encryption.
      CHECK_EQ(config.format_, kKeyFormatDER);
      CHECK_NULL(config.cipher_);
      err = i2d_ECPrivateKey_bio(bio.get(), ec_key.get()) != 1;
    }",12,,379,1,,void
45180,BLOCK,-1,,"{
    ThrowCryptoError(env, ERR_get_error(), ""Failed to encode private key"");
    return MaybeLocal<Value>();
  }",12,,387,2,,void
45203,BLOCK,-1,,"{
  if (config.type_.ToChecked() == kKeyEncodingPKCS1) {
    // PKCS#1 is only valid for RSA keys.
    CHECK_EQ(EVP_PKEY_id(pkey), EVP_PKEY_RSA);
    RSAPointer rsa(EVP_PKEY_get1_RSA(pkey));
    if (config.format_ == kKeyFormatPEM) {
      // Encode PKCS#1 as PEM.
      return PEM_write_bio_RSAPublicKey(bio.get(), rsa.get()) == 1;
    } else {
      // Encode PKCS#1 as DER.
      CHECK_EQ(config.format_, kKeyFormatDER);
      return i2d_RSAPublicKey_bio(bio.get(), rsa.get()) == 1;
    }
  } else {
    CHECK_EQ(config.type_.ToChecked(), kKeyEncodingSPKI);
    if (config.format_ == kKeyFormatPEM) {
      // Encode SPKI as PEM.
      return PEM_write_bio_PUBKEY(bio.get(), pkey) == 1;
    } else {
      // Encode SPKI as DER.
      CHECK_EQ(config.format_, kKeyFormatDER);
      return i2d_PUBKEY_bio(bio.get(), pkey) == 1;
    }
  }
}",65,,396,4,,void
45213,BLOCK,-1,,"{
    // PKCS#1 is only valid for RSA keys.
    CHECK_EQ(EVP_PKEY_id(pkey), EVP_PKEY_RSA);
    RSAPointer rsa(EVP_PKEY_get1_RSA(pkey));
    if (config.format_ == kKeyFormatPEM) {
      // Encode PKCS#1 as PEM.
      return PEM_write_bio_RSAPublicKey(bio.get(), rsa.get()) == 1;
    } else {
      // Encode PKCS#1 as DER.
      CHECK_EQ(config.format_, kKeyFormatDER);
      return i2d_RSAPublicKey_bio(bio.get(), rsa.get()) == 1;
    }
  }",54,,397,2,,void
45228,BLOCK,-1,,"{
      // Encode PKCS#1 as PEM.
      return PEM_write_bio_RSAPublicKey(bio.get(), rsa.get()) == 1;
    }",42,,401,2,,void
45242,BLOCK,-1,,"{
      // Encode PKCS#1 as DER.
      CHECK_EQ(config.format_, kKeyFormatDER);
      return i2d_RSAPublicKey_bio(bio.get(), rsa.get()) == 1;
    }",12,,404,1,,void
45261,BLOCK,-1,,"{
    CHECK_EQ(config.type_.ToChecked(), kKeyEncodingSPKI);
    if (config.format_ == kKeyFormatPEM) {
      // Encode SPKI as PEM.
      return PEM_write_bio_PUBKEY(bio.get(), pkey) == 1;
    } else {
      // Encode SPKI as DER.
      CHECK_EQ(config.format_, kKeyFormatDER);
      return i2d_PUBKEY_bio(bio.get(), pkey) == 1;
    }
  }",10,,409,1,,void
45276,BLOCK,-1,,"{
      // Encode SPKI as PEM.
      return PEM_write_bio_PUBKEY(bio.get(), pkey) == 1;
    }",42,,411,2,,void
45287,BLOCK,-1,,"{
      // Encode SPKI as DER.
      CHECK_EQ(config.format_, kKeyFormatDER);
      return i2d_PUBKEY_bio(bio.get(), pkey) == 1;
    }",12,,414,1,,void
45308,BLOCK,-1,,"{
  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);

  if (!WritePublicKeyInner(pkey, bio, config)) {
    ThrowCryptoError(env, ERR_get_error(), ""Failed to encode public key"");
    return MaybeLocal<Value>();
  }
  return BIOToStringOrBuffer(env, bio.get(), config.format_);
}",73,,424,4,,void
45311,BLOCK,-1,,<empty>,,,,2,,<empty>
45322,BLOCK,-1,,"{
    ThrowCryptoError(env, ERR_get_error(), ""Failed to encode public key"");
    return MaybeLocal<Value>();
  }",48,,428,2,,void
45345,BLOCK,-1,,"{
  CHECK_EQ(key->GetKeyType(), kKeyTypeSecret);

  Local<Value> error;
  Local<Value> raw;
  MaybeLocal<Value> key_data =
      StringBytes::Encode(
          env->isolate(),
          key->GetSymmetricKey(),
          key->GetSymmetricKeySize(),
          BASE64URL,
          &error);
  if (key_data.IsEmpty()) {
    CHECK(!error.IsEmpty());
    env->isolate()->ThrowException(error);
    return Nothing<bool>();
  }
  if (!key_data.ToLocal(&raw))
    return Nothing<bool>();

  if (target->Set(
          env->context(),
          env->jwk_kty_string(),
          env->jwk_oct_string()).IsNothing() ||
      target->Set(
          env->context(),
          env->jwk_k_string(),
          raw).IsNothing()) {
    return Nothing<bool>();
  }

  return Just(true);
}",27,,438,4,,void
45392,BLOCK,-1,,"{
    CHECK(!error.IsEmpty());
    env->isolate()->ThrowException(error);
    return Nothing<bool>();
  }",27,,450,2,,void
45417,BLOCK,-1,,<empty>,5,,456,2,,void
45457,BLOCK,-1,,"{
    return Nothing<bool>();
  }",29,,465,2,,void
45468,BLOCK,-1,,"{
  Local<Value> key;
  if (!jwk->Get(env->context(), env->jwk_k_string()).ToLocal(&key) ||
      !key->IsString()) {
    THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK secret key format"");
    return std::shared_ptr<KeyObjectData>();
  }

  static_assert(String::kMaxLength <= INT_MAX);
  ByteSource key_data = ByteSource::FromEncodedString(env, key.As<String>());
  return KeyObjectData::CreateSecret(std::move(key_data));
}",24,,474,3,,void
45499,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK secret key format"");
    return std::shared_ptr<KeyObjectData>();
  }",25,,477,2,,void
45543,BLOCK,-1,,"{
  switch (EVP_PKEY_id(key->GetAsymmetricKey().get())) {
    case EVP_PKEY_RSA_PSS: {
      if (handleRsaPss) return ExportJWKRsaKey(env, key, target);
      break;
    }
    case EVP_PKEY_RSA: return ExportJWKRsaKey(env, key, target);
    case EVP_PKEY_EC: return ExportJWKEcKey(env, key, target).IsJust() ?
                               Just(true) : Nothing<bool>();
    case EVP_PKEY_ED25519:
      // Fall through
    case EVP_PKEY_ED448:
      // Fall through
    case EVP_PKEY_X25519:
      // Fall through
    case EVP_PKEY_X448: return ExportJWKEdKey(env, key, target);
  }
  THROW_ERR_CRYPTO_JWK_UNSUPPORTED_KEY_TYPE(env);
  return Just(false);
}",24,,491,5,,void
45553,BLOCK,-1,,"{
    case EVP_PKEY_RSA_PSS: {
      if (handleRsaPss) return ExportJWKRsaKey(env, key, target);
      break;
    }
    case EVP_PKEY_RSA: return ExportJWKRsaKey(env, key, target);
    case EVP_PKEY_EC: return ExportJWKEcKey(env, key, target).IsJust() ?
                               Just(true) : Nothing<bool>();
    case EVP_PKEY_ED25519:
      // Fall through
    case EVP_PKEY_ED448:
      // Fall through
    case EVP_PKEY_X25519:
      // Fall through
    case EVP_PKEY_X448: return ExportJWKEdKey(env, key, target);
  }",55,,492,2,,void
45556,BLOCK,3,,"{
      if (handleRsaPss) return ExportJWKRsaKey(env, key, target);
      break;
    }",28,,493,3,,void
45559,BLOCK,-1,,<empty>,25,,494,2,,void
45613,BLOCK,-1,,"{
  if (strcmp(kty, ""RSA"") == 0) {
    return ImportJWKRsaKey(env, jwk, args, offset);
  } else if (strcmp(kty, ""EC"") == 0) {
    return ImportJWKEcKey(env, jwk, args, offset);
  }

  THROW_ERR_CRYPTO_INVALID_JWK(env, ""%s is not a supported JWK key type"", kty);
  return std::shared_ptr<KeyObjectData>();
}",26,,517,6,,void
45620,BLOCK,-1,,"{
    return ImportJWKRsaKey(env, jwk, args, offset);
  }",32,,518,2,,void
45628,BLOCK,-1,,<empty>,10,,520,1,,void
45635,BLOCK,-1,,"{
    return ImportJWKEcKey(env, jwk, args, offset);
  }",38,,520,2,,void
45657,BLOCK,-1,,"{
  // For the secret key detail, all we care about is the length,
  // converted to bits.

  size_t length = key->GetSymmetricKeySize() * CHAR_BIT;
  return target->Set(env->context(),
                     env->length_string(),
                     Number::New(env->isolate(), static_cast<double>(length)));
}",27,,531,4,,void
45697,BLOCK,-1,,"{
  switch (EVP_PKEY_id(key->GetAsymmetricKey().get())) {
    case EVP_PKEY_RSA:
      // Fall through
    case EVP_PKEY_RSA_PSS: return GetRsaKeyDetail(env, key, target);
    case EVP_PKEY_DSA: return GetDsaKeyDetail(env, key, target);
    case EVP_PKEY_EC: return GetEcKeyDetail(env, key, target);
    case EVP_PKEY_DH: return GetDhKeyDetail(env, key, target);
  }
  THROW_ERR_CRYPTO_INVALID_KEYTYPE(env);
  return Nothing<bool>();
}",25,,544,4,,void
45707,BLOCK,-1,,"{
    case EVP_PKEY_RSA:
      // Fall through
    case EVP_PKEY_RSA_PSS: return GetRsaKeyDetail(env, key, target);
    case EVP_PKEY_DSA: return GetDsaKeyDetail(env, key, target);
    case EVP_PKEY_EC: return GetEcKeyDetail(env, key, target);
    case EVP_PKEY_DH: return GetDhKeyDetail(env, key, target);
  }",55,,545,2,,void
45746,BLOCK,-1,,<empty>,39,,559,2,,void
45751,BLOCK,-1,,"{
  *this = that;
}",60,,561,2,,void
45760,BLOCK,-1,,"{
  Mutex::ScopedLock lock(*that.mutex_);

  pkey_.reset(that.get());

  if (pkey_)
    EVP_PKEY_up_ref(pkey_.get());

  mutex_ = that.mutex_;

  return *this;
}",71,,565,2,,void
45777,BLOCK,-1,,<empty>,5,,571,2,,void
45794,BLOCK,-1,,"{
  return !!pkey_;
}",39,,578,1,,void
45802,BLOCK,-1,,"{
  return pkey_.get();
}",39,,582,1,,void
45811,BLOCK,-1,,"{
  return mutex_.get();
}",38,,586,1,,void
45821,BLOCK,-1,,"{
  tracker->TrackFieldWithSize(""pkey"",
                              !pkey_ ? 0 : kSizeOf_EVP_PKEY +
                              size_of_private_key() +
                              size_of_public_key());
}",63,,590,2,,void
45839,BLOCK,-1,,"{
  size_t len = 0;
  return (pkey_ && EVP_PKEY_get_raw_private_key(
      pkey_.get(), nullptr, &len) == 1) ? len : 0;
}",52,,597,1,,void
45863,BLOCK,-1,,"{
  size_t len = 0;
  return (pkey_ && EVP_PKEY_get_raw_public_key(
      pkey_.get(), nullptr, &len) == 1) ? len : 0;
}",51,,603,1,,void
45888,BLOCK,-1,,"{
  return b ? Just(true) : Nothing<bool>();
}",44,,610,2,,void
45902,BLOCK,-1,,"{
  switch (key->GetKeyType()) {
    case kKeyTypeSecret:
      return ExportJWKSecretKey(env, key, result.As<Object>());
    case kKeyTypePublic:
      // Fall through
    case kKeyTypePrivate:
      return ExportJWKAsymmetricKey(
        env, key, result.As<Object>(), handleRsaPss);
    default:
      UNREACHABLE();
  }
}",47,,617,5,,void
45908,BLOCK,-1,,"{
    case kKeyTypeSecret:
      return ExportJWKSecretKey(env, key, result.As<Object>());
    case kKeyTypePublic:
      // Fall through
    case kKeyTypePrivate:
      return ExportJWKAsymmetricKey(
        env, key, result.As<Object>(), handleRsaPss);
    default:
      UNREACHABLE();
  }",30,,618,2,,void
45940,BLOCK,-1,,"{
  if (!*this) return Nothing<bool>();
  if (config.output_key_object_) {
    // Note that this has the downside of containing sensitive data of the
    // private key.
    std::shared_ptr<KeyObjectData> data =
        KeyObjectData::CreateAsymmetric(kKeyTypePublic, *this);
    return Tristate(KeyObjectHandle::Create(env, data).ToLocal(out));
  } else if (config.format_ == kKeyFormatJWK) {
    std::shared_ptr<KeyObjectData> data =
        KeyObjectData::CreateAsymmetric(kKeyTypePublic, *this);
    *out = Object::New(env->isolate());
    return ExportJWKInner(env, data, *out, false);
  }

  return Tristate(WritePublicKey(env, get(), config).ToLocal(out));
}",24,,634,4,,void
45945,BLOCK,-1,,<empty>,15,,635,2,,void
45952,BLOCK,-1,,"{
    // Note that this has the downside of containing sensitive data of the
    // private key.
    std::shared_ptr<KeyObjectData> data =
        KeyObjectData::CreateAsymmetric(kKeyTypePublic, *this);
    return Tristate(KeyObjectHandle::Create(env, data).ToLocal(out));
  }",34,,636,2,,void
45981,BLOCK,-1,,<empty>,10,,642,1,,void
45988,BLOCK,-1,,"{
    std::shared_ptr<KeyObjectData> data =
        KeyObjectData::CreateAsymmetric(kKeyTypePublic, *this);
    *out = Object::New(env->isolate());
    return ExportJWKInner(env, data, *out, false);
  }",47,,642,2,,void
46038,BLOCK,-1,,"{
  if (!*this) return Nothing<bool>();
  if (config.output_key_object_) {
    std::shared_ptr<KeyObjectData> data =
        KeyObjectData::CreateAsymmetric(kKeyTypePrivate, *this);
    return Tristate(KeyObjectHandle::Create(env, data).ToLocal(out));
  } else if (config.format_ == kKeyFormatJWK) {
    std::shared_ptr<KeyObjectData> data =
        KeyObjectData::CreateAsymmetric(kKeyTypePrivate, *this);
    *out = Object::New(env->isolate());
    return ExportJWKInner(env, data, *out, false);
  }

  return Tristate(WritePrivateKey(env, get(), config).ToLocal(out));
}",24,,655,4,,void
46043,BLOCK,-1,,<empty>,15,,656,2,,void
46050,BLOCK,-1,,"{
    std::shared_ptr<KeyObjectData> data =
        KeyObjectData::CreateAsymmetric(kKeyTypePrivate, *this);
    return Tristate(KeyObjectHandle::Create(env, data).ToLocal(out));
  }",34,,657,2,,void
46079,BLOCK,-1,,<empty>,10,,661,1,,void
46086,BLOCK,-1,,"{
    std::shared_ptr<KeyObjectData> data =
        KeyObjectData::CreateAsymmetric(kKeyTypePrivate, *this);
    *out = Object::New(env->isolate());
    return ExportJWKInner(env, data, *out, false);
  }",47,,661,2,,void
46136,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  PrivateKeyEncodingConfig result;
  GetKeyFormatAndTypeFromJs(&result, args, offset, context);

  if (result.output_key_object_) {
    if (context != kKeyContextInput)
      (*offset)++;
  } else {
    bool needs_passphrase = false;
    if (context != kKeyContextInput) {
      if (args[*offset]->IsString()) {
        Utf8Value cipher_name(env->isolate(), args[*offset]);
        result.cipher_ = EVP_get_cipherbyname(*cipher_name);
        if (result.cipher_ == nullptr) {
          THROW_ERR_CRYPTO_UNKNOWN_CIPHER(env);
          return NonCopyableMaybe<PrivateKeyEncodingConfig>();
        }
        needs_passphrase = true;
      } else {
        CHECK(args[*offset]->IsNullOrUndefined());
        result.cipher_ = nullptr;
      }
      (*offset)++;
    }

    if (IsAnyByteSource(args[*offset])) {
      CHECK_IMPLIES(context != kKeyContextInput, result.cipher_ != nullptr);
      ArrayBufferOrViewContents<char> passphrase(args[*offs...",33,,675,4,,void
46156,BLOCK,-1,,"{
    if (context != kKeyContextInput)
      (*offset)++;
  }",34,,681,2,,void
46161,BLOCK,-1,,<empty>,7,,683,2,,void
46166,BLOCK,-1,,"{
    bool needs_passphrase = false;
    if (context != kKeyContextInput) {
      if (args[*offset]->IsString()) {
        Utf8Value cipher_name(env->isolate(), args[*offset]);
        result.cipher_ = EVP_get_cipherbyname(*cipher_name);
        if (result.cipher_ == nullptr) {
          THROW_ERR_CRYPTO_UNKNOWN_CIPHER(env);
          return NonCopyableMaybe<PrivateKeyEncodingConfig>();
        }
        needs_passphrase = true;
      } else {
        CHECK(args[*offset]->IsNullOrUndefined());
        result.cipher_ = nullptr;
      }
      (*offset)++;
    }

    if (IsAnyByteSource(args[*offset])) {
      CHECK_IMPLIES(context != kKeyContextInput, result.cipher_ != nullptr);
      ArrayBufferOrViewContents<char> passphrase(args[*offset]);
      if (UNLIKELY(!passphrase.CheckSizeInt32())) {
        THROW_ERR_OUT_OF_RANGE(env, ""passphrase is too big"");
        return NonCopyableMaybe<PrivateKeyEncodingConfig>();
      }
      result.passphrase_ = NonCopyableMaybe<ByteSource>(
      ...",10,,684,1,,void
46175,BLOCK,-1,,"{
      if (args[*offset]->IsString()) {
        Utf8Value cipher_name(env->isolate(), args[*offset]);
        result.cipher_ = EVP_get_cipherbyname(*cipher_name);
        if (result.cipher_ == nullptr) {
          THROW_ERR_CRYPTO_UNKNOWN_CIPHER(env);
          return NonCopyableMaybe<PrivateKeyEncodingConfig>();
        }
        needs_passphrase = true;
      } else {
        CHECK(args[*offset]->IsNullOrUndefined());
        result.cipher_ = nullptr;
      }
      (*offset)++;
    }",38,,686,2,,void
46184,BLOCK,-1,,"{
        Utf8Value cipher_name(env->isolate(), args[*offset]);
        result.cipher_ = EVP_get_cipherbyname(*cipher_name);
        if (result.cipher_ == nullptr) {
          THROW_ERR_CRYPTO_UNKNOWN_CIPHER(env);
          return NonCopyableMaybe<PrivateKeyEncodingConfig>();
        }
        needs_passphrase = true;
      }",38,,687,2,,void
46208,BLOCK,-1,,"{
          THROW_ERR_CRYPTO_UNKNOWN_CIPHER(env);
          return NonCopyableMaybe<PrivateKeyEncodingConfig>();
        }",40,,690,2,,void
46217,BLOCK,-1,,"{
        CHECK(args[*offset]->IsNullOrUndefined());
        result.cipher_ = nullptr;
      }",14,,695,1,,void
46240,BLOCK,-1,,"{
      CHECK_IMPLIES(context != kKeyContextInput, result.cipher_ != nullptr);
      ArrayBufferOrViewContents<char> passphrase(args[*offset]);
      if (UNLIKELY(!passphrase.CheckSizeInt32())) {
        THROW_ERR_OUT_OF_RANGE(env, ""passphrase is too big"");
        return NonCopyableMaybe<PrivateKeyEncodingConfig>();
      }
      result.passphrase_ = NonCopyableMaybe<ByteSource>(
          passphrase.ToNullTerminatedCopy());
    }",41,,702,2,,void
46263,BLOCK,-1,,"{
        THROW_ERR_OUT_OF_RANGE(env, ""passphrase is too big"");
        return NonCopyableMaybe<PrivateKeyEncodingConfig>();
      }",51,,705,2,,void
46282,BLOCK,-1,,"{
      CHECK(args[*offset]->IsNullOrUndefined() && !needs_passphrase);
    }",12,,711,1,,void
46313,BLOCK,-1,,"{
  PublicKeyEncodingConfig result;
  GetKeyFormatAndTypeFromJs(&result, args, offset, context);
  return result;
}",33,,723,4,,void
46329,BLOCK,-1,,"{
  if (args[*offset]->IsString() || IsAnyByteSource(args[*offset])) {
    Environment* env = Environment::GetCurrent(args);
    ByteSource key = ByteSource::FromStringOrBuffer(env, args[(*offset)++]);
    NonCopyableMaybe<PrivateKeyEncodingConfig> config =
        GetPrivateKeyEncodingFromJs(args, offset, kKeyContextInput);
    if (config.IsEmpty())
      return ManagedEVPPKey();

    EVPKeyPointer pkey;
    ParseKeyResult ret =
        ParsePrivateKey(&pkey, config.Release(), key.data<char>(), key.size());
    return GetParsedKey(env, std::move(pkey), ret,
                        ""Failed to read private key"");
  } else {
    CHECK(args[*offset]->IsObject() && allow_key_object);
    KeyObjectHandle* key;
    ASSIGN_OR_RETURN_UNWRAP(&key, args[*offset].As<Object>(), ManagedEVPPKey());
    CHECK_EQ(key->Data()->GetKeyType(), kKeyTypePrivate);
    (*offset) += 4;
    return key->Data()->GetAsymmetricKey();
  }
}",28,,732,4,,void
46344,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(args);
    ByteSource key = ByteSource::FromStringOrBuffer(env, args[(*offset)++]);
    NonCopyableMaybe<PrivateKeyEncodingConfig> config =
        GetPrivateKeyEncodingFromJs(args, offset, kKeyContextInput);
    if (config.IsEmpty())
      return ManagedEVPPKey();

    EVPKeyPointer pkey;
    ParseKeyResult ret =
        ParsePrivateKey(&pkey, config.Release(), key.data<char>(), key.size());
    return GetParsedKey(env, std::move(pkey), ret,
                        ""Failed to read private key"");
  }",68,,733,2,,void
46381,BLOCK,-1,,<empty>,7,,739,2,,void
46414,BLOCK,-1,,"{
    CHECK(args[*offset]->IsObject() && allow_key_object);
    KeyObjectHandle* key;
    ASSIGN_OR_RETURN_UNWRAP(&key, args[*offset].As<Object>(), ManagedEVPPKey());
    CHECK_EQ(key->Data()->GetKeyType(), kKeyTypePrivate);
    (*offset) += 4;
    return key->Data()->GetAsymmetricKey();
  }",10,,746,1,,void
46463,BLOCK,-1,,"{
  if (IsAnyByteSource(args[*offset])) {
    Environment* env = Environment::GetCurrent(args);
    ArrayBufferOrViewContents<char> data(args[(*offset)++]);
    if (UNLIKELY(!data.CheckSizeInt32())) {
      THROW_ERR_OUT_OF_RANGE(env, ""keyData is too big"");
      return ManagedEVPPKey();
    }
    NonCopyableMaybe<PrivateKeyEncodingConfig> config_ =
        GetPrivateKeyEncodingFromJs(args, offset, kKeyContextInput);
    if (config_.IsEmpty())
      return ManagedEVPPKey();

    ParseKeyResult ret;
    PrivateKeyEncodingConfig config = config_.Release();
    EVPKeyPointer pkey;
    if (config.format_ == kKeyFormatPEM) {
      // For PEM, we can easily determine whether it is a public or private key
      // by looking for the respective PEM tags.
      ret = ParsePublicKeyPEM(&pkey, data.data(), data.size());
      if (ret == ParseKeyResult::kParseKeyNotRecognized) {
        ret = ParsePrivateKey(&pkey, config, data.data(), data.size());
      }
    } else {
      // For DER, the ty...",27,,758,3,,void
46470,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(args);
    ArrayBufferOrViewContents<char> data(args[(*offset)++]);
    if (UNLIKELY(!data.CheckSizeInt32())) {
      THROW_ERR_OUT_OF_RANGE(env, ""keyData is too big"");
      return ManagedEVPPKey();
    }
    NonCopyableMaybe<PrivateKeyEncodingConfig> config_ =
        GetPrivateKeyEncodingFromJs(args, offset, kKeyContextInput);
    if (config_.IsEmpty())
      return ManagedEVPPKey();

    ParseKeyResult ret;
    PrivateKeyEncodingConfig config = config_.Release();
    EVPKeyPointer pkey;
    if (config.format_ == kKeyFormatPEM) {
      // For PEM, we can easily determine whether it is a public or private key
      // by looking for the respective PEM tags.
      ret = ParsePublicKeyPEM(&pkey, data.data(), data.size());
      if (ret == ParseKeyResult::kParseKeyNotRecognized) {
        ret = ParsePrivateKey(&pkey, config, data.data(), data.size());
      }
    } else {
      // For DER, the type determines how to parse it. SPKI, PKC...",39,,759,2,,void
46493,BLOCK,-1,,"{
      THROW_ERR_OUT_OF_RANGE(env, ""keyData is too big"");
      return ManagedEVPPKey();
    }",43,,762,2,,void
46514,BLOCK,-1,,<empty>,7,,769,2,,void
46532,BLOCK,-1,,"{
      // For PEM, we can easily determine whether it is a public or private key
      // by looking for the respective PEM tags.
      ret = ParsePublicKeyPEM(&pkey, data.data(), data.size());
      if (ret == ParseKeyResult::kParseKeyNotRecognized) {
        ret = ParsePrivateKey(&pkey, config, data.data(), data.size());
      }
    }",42,,774,2,,void
46552,BLOCK,-1,,"{
        ret = ParsePrivateKey(&pkey, config, data.data(), data.size());
      }",58,,778,2,,void
46568,BLOCK,-1,,"{
      // For DER, the type determines how to parse it. SPKI, PKCS#8 and SEC1 are
      // easy, but PKCS#1 can be a public key or a private key.
      bool is_public;
      switch (config.type_.ToChecked()) {
        case kKeyEncodingPKCS1:
          is_public = !IsRSAPrivateKey(
              reinterpret_cast<const unsigned char*>(data.data()), data.size());
          break;
        case kKeyEncodingSPKI:
          is_public = true;
          break;
        case kKeyEncodingPKCS8:
        case kKeyEncodingSEC1:
          is_public = false;
          break;
        default:
          UNREACHABLE(""Invalid key encoding type"");
      }

      if (is_public) {
        ret = ParsePublicKey(&pkey, config, data.data(), data.size());
      } else {
        ret = ParsePrivateKey(&pkey, config, data.data(), data.size());
      }
    }",12,,781,1,,void
46577,BLOCK,-1,,"{
        case kKeyEncodingPKCS1:
          is_public = !IsRSAPrivateKey(
              reinterpret_cast<const unsigned char*>(data.data()), data.size());
          break;
        case kKeyEncodingSPKI:
          is_public = true;
          break;
        case kKeyEncodingPKCS8:
        case kKeyEncodingSEC1:
          is_public = false;
          break;
        default:
          UNREACHABLE(""Invalid key encoding type"");
      }",41,,785,2,,void
46614,BLOCK,-1,,"{
        ret = ParsePublicKey(&pkey, config, data.data(), data.size());
      }",22,,801,2,,void
46630,BLOCK,-1,,"{
        ret = ParsePrivateKey(&pkey, config, data.data(), data.size());
      }",14,,803,1,,void
46659,BLOCK,-1,,"{
    CHECK(args[*offset]->IsObject());
    KeyObjectHandle* key = Unwrap<KeyObjectHandle>(args[*offset].As<Object>());
    CHECK_NOT_NULL(key);
    CHECK_NE(key->Data()->GetKeyType(), kKeyTypeSecret);
    (*offset) += 4;
    return key->Data()->GetAsymmetricKey();
  }",10,,810,1,,void
46712,BLOCK,-1,,"{
  switch (ret) {
    case ParseKeyResult::kParseKeyOk:
      CHECK(pkey);
      break;
    case ParseKeyResult::kParseKeyNeedPassphrase:
      THROW_ERR_MISSING_PASSPHRASE(env,
                                   ""Passphrase required for encrypted key"");
      break;
    default:
      ThrowCryptoError(env, ERR_get_error(), default_msg);
  }

  return ManagedEVPPKey(std::move(pkey));
}",70,,823,5,,void
46715,BLOCK,-1,,"{
    case ParseKeyResult::kParseKeyOk:
      CHECK(pkey);
      break;
    case ParseKeyResult::kParseKeyNeedPassphrase:
      THROW_ERR_MISSING_PASSPHRASE(env,
                                   ""Passphrase required for encrypted key"");
      break;
    default:
      ThrowCryptoError(env, ERR_get_error(), default_msg);
  }",16,,824,2,,void
46747,BLOCK,-1,,<empty>,25,,842,2,,void
46753,BLOCK,-1,,<empty>,64,,845,3,,void
46758,BLOCK,-1,,"{
  switch (GetKeyType()) {
    case kKeyTypeSecret:
      tracker->TrackFieldWithSize(""symmetric_key"", symmetric_key_.size());
      break;
    case kKeyTypePrivate:
      // Fall through
    case kKeyTypePublic:
      tracker->TrackFieldWithSize(""key"", asymmetric_key_);
      break;
    default:
      UNREACHABLE();
  }
}",62,,847,2,,void
46761,BLOCK,-1,,"{
    case kKeyTypeSecret:
      tracker->TrackFieldWithSize(""symmetric_key"", symmetric_key_.size());
      break;
    case kKeyTypePrivate:
      // Fall through
    case kKeyTypePublic:
      tracker->TrackFieldWithSize(""key"", asymmetric_key_);
      break;
    default:
      UNREACHABLE();
  }",25,,848,2,,void
46791,BLOCK,-1,,"{
  return std::shared_ptr<KeyObjectData>(new KeyObjectData(std::move(key)));
}",76,,862,2,,void
46811,BLOCK,-1,,"{
  CHECK(pkey);
  return std::shared_ptr<KeyObjectData>(new KeyObjectData(key_type, pkey));
}",33,,868,3,,void
46828,BLOCK,-1,,"{
  return key_type_;
}",43,,873,1,,void
46834,BLOCK,-1,,"{
  CHECK_NE(key_type_, kKeyTypeSecret);
  return asymmetric_key_;
}",56,,877,1,,void
46843,BLOCK,-1,,"{
  CHECK_EQ(key_type_, kKeyTypeSecret);
  return symmetric_key_.data<char>();
}",52,,882,1,,void
46855,BLOCK,-1,,"{
  CHECK_EQ(key_type_, kKeyTypeSecret);
  return symmetric_key_.size();
}",51,,887,1,,void
46869,BLOCK,-1,,"{
  Local<FunctionTemplate> t = env->crypto_key_object_handle_constructor();
  return !t.IsEmpty() && t->HasInstance(value);
}",73,,892,3,,void
46896,BLOCK,-1,,"{
  Local<FunctionTemplate> templ = env->crypto_key_object_handle_constructor();
  if (templ.IsEmpty()) {
    Isolate* isolate = env->isolate();
    templ = NewFunctionTemplate(isolate, New);
    templ->InstanceTemplate()->SetInternalFieldCount(
        KeyObjectHandle::kInternalFieldCount);

    SetProtoMethod(isolate, templ, ""init"", Init);
    SetProtoMethodNoSideEffect(
        isolate, templ, ""getSymmetricKeySize"", GetSymmetricKeySize);
    SetProtoMethodNoSideEffect(
        isolate, templ, ""getAsymmetricKeyType"", GetAsymmetricKeyType);
    SetProtoMethod(isolate, templ, ""export"", Export);
    SetProtoMethod(isolate, templ, ""exportJwk"", ExportJWK);
    SetProtoMethod(isolate, templ, ""initECRaw"", InitECRaw);
    SetProtoMethod(isolate, templ, ""initEDRaw"", InitEDRaw);
    SetProtoMethod(isolate, templ, ""initJwk"", InitJWK);
    SetProtoMethod(isolate, templ, ""keyDetail"", GetKeyDetail);
    SetProtoMethod(isolate, templ, ""equals"", Equals);

    env->set_crypto_key_object_handle_con...",71,,897,2,,void
46912,BLOCK,-1,,"{
    Isolate* isolate = env->isolate();
    templ = NewFunctionTemplate(isolate, New);
    templ->InstanceTemplate()->SetInternalFieldCount(
        KeyObjectHandle::kInternalFieldCount);

    SetProtoMethod(isolate, templ, ""init"", Init);
    SetProtoMethodNoSideEffect(
        isolate, templ, ""getSymmetricKeySize"", GetSymmetricKeySize);
    SetProtoMethodNoSideEffect(
        isolate, templ, ""getAsymmetricKeyType"", GetAsymmetricKeyType);
    SetProtoMethod(isolate, templ, ""export"", Export);
    SetProtoMethod(isolate, templ, ""exportJwk"", ExportJWK);
    SetProtoMethod(isolate, templ, ""initECRaw"", InitECRaw);
    SetProtoMethod(isolate, templ, ""initEDRaw"", InitEDRaw);
    SetProtoMethod(isolate, templ, ""initJwk"", InitJWK);
    SetProtoMethod(isolate, templ, ""keyDetail"", GetKeyDetail);
    SetProtoMethod(isolate, templ, ""equals"", Equals);

    env->set_crypto_key_object_handle_constructor(templ);
  }",24,,899,2,,void
47006,BLOCK,-1,,"{
  registry->Register(New);
  registry->Register(Init);
  registry->Register(GetSymmetricKeySize);
  registry->Register(GetAsymmetricKeyType);
  registry->Register(Export);
  registry->Register(ExportJWK);
  registry->Register(InitECRaw);
  registry->Register(InitEDRaw);
  registry->Register(InitJWK);
  registry->Register(GetKeyDetail);
  registry->Register(Equals);
}",42,,924,2,,void
47067,BLOCK,-1,,"{
  Local<Object> obj;
  Local<Function> ctor = KeyObjectHandle::Initialize(env);
  CHECK(!env->crypto_key_object_handle_constructor().IsEmpty());
  if (!ctor->NewInstance(env->context(), 0, nullptr).ToLocal(&obj))
    return MaybeLocal<Object>();

  KeyObjectHandle* key = Unwrap<KeyObjectHandle>(obj);
  CHECK_NOT_NULL(key);
  key->data_ = data;
  return obj;
}",42,,940,3,,void
47110,BLOCK,-1,,<empty>,5,,945,2,,void
47133,BLOCK,-1,,"{
  return data_;
}",63,,953,1,,void
47140,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);
  new KeyObjectHandle(env, args.This());
}",68,,957,2,,void
47166,BLOCK,-1,,"{
  MakeWeak();
}",29,,965,3,,void
47172,BLOCK,-1,,"{
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());
  MarkPopErrorOnReturn mark_pop_error_on_return;

  CHECK(args[0]->IsInt32());
  KeyType type = static_cast<KeyType>(args[0].As<Uint32>()->Value());

  unsigned int offset;
  ManagedEVPPKey pkey;

  switch (type) {
  case kKeyTypeSecret: {
    CHECK_EQ(args.Length(), 2);
    ArrayBufferOrViewContents<char> buf(args[1]);
    key->data_ = KeyObjectData::CreateSecret(buf.ToCopy());
    break;
  }
  case kKeyTypePublic: {
    CHECK_EQ(args.Length(), 5);

    offset = 1;
    pkey = ManagedEVPPKey::GetPublicOrPrivateKeyFromJs(args, &offset);
    if (!pkey)
      return;
    key->data_ = KeyObjectData::CreateAsymmetric(type, pkey);
    break;
  }
  case kKeyTypePrivate: {
    CHECK_EQ(args.Length(), 5);

    offset = 1;
    pkey = ManagedEVPPKey::GetPrivateKeyFromJs(args, &offset, false);
    if (!pkey)
      return;
    key->data_ = KeyObjectData::CreateAsymmetric(type, pkey);
    break;
  }
  default:
    UNREACHAB...",69,,969,2,,void
47207,BLOCK,-1,,"{
  case kKeyTypeSecret: {
    CHECK_EQ(args.Length(), 2);
    ArrayBufferOrViewContents<char> buf(args[1]);
    key->data_ = KeyObjectData::CreateSecret(buf.ToCopy());
    break;
  }
  case kKeyTypePublic: {
    CHECK_EQ(args.Length(), 5);

    offset = 1;
    pkey = ManagedEVPPKey::GetPublicOrPrivateKeyFromJs(args, &offset);
    if (!pkey)
      return;
    key->data_ = KeyObjectData::CreateAsymmetric(type, pkey);
    break;
  }
  case kKeyTypePrivate: {
    CHECK_EQ(args.Length(), 5);

    offset = 1;
    pkey = ManagedEVPPKey::GetPrivateKeyFromJs(args, &offset, false);
    if (!pkey)
      return;
    key->data_ = KeyObjectData::CreateAsymmetric(type, pkey);
    break;
  }
  default:
    UNREACHABLE();
  }",17,,980,2,,void
47210,BLOCK,3,,"{
    CHECK_EQ(args.Length(), 2);
    ArrayBufferOrViewContents<char> buf(args[1]);
    key->data_ = KeyObjectData::CreateSecret(buf.ToCopy());
    break;
  }",24,,981,3,,void
47237,BLOCK,6,,"{
    CHECK_EQ(args.Length(), 5);

    offset = 1;
    pkey = ManagedEVPPKey::GetPublicOrPrivateKeyFromJs(args, &offset);
    if (!pkey)
      return;
    key->data_ = KeyObjectData::CreateAsymmetric(type, pkey);
    break;
  }",24,,987,6,,void
47259,BLOCK,-1,,<empty>,7,,993,2,,void
47274,BLOCK,9,,"{
    CHECK_EQ(args.Length(), 5);

    offset = 1;
    pkey = ManagedEVPPKey::GetPrivateKeyFromJs(args, &offset, false);
    if (!pkey)
      return;
    key->data_ = KeyObjectData::CreateAsymmetric(type, pkey);
    break;
  }",25,,997,9,,void
47297,BLOCK,-1,,<empty>,7,,1003,2,,void
47316,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());
  MarkPopErrorOnReturn mark_pop_error_on_return;

  // The argument must be a JavaScript object that we will inspect
  // to get the JWK properties from.
  CHECK(args[0]->IsObject());

  // Step one, Secret key or not?
  Local<Object> input = args[0].As<Object>();

  Local<Value> kty;
  if (!input->Get(env->context(), env->jwk_kty_string()).ToLocal(&kty) ||
      !kty->IsString()) {
    return THROW_ERR_CRYPTO_INVALID_JWK(env);
  }

  Utf8Value kty_string(env->isolate(), kty);

  if (strcmp(*kty_string, ""oct"") == 0) {
    // Secret key
    key->data_ = ImportJWKSecretKey(env, input);
    if (!key->data_) {
      // ImportJWKSecretKey is responsible for throwing an appropriate error
      return;
    }
  } else {
    key->data_ = ImportJWKAsymmetricKey(env, input, *kty_string, args, 1);
    if (!key->data_) {
      // ImportJWKAsymmetricKey is responsible for ...",72,,1012,2,,void
47383,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_INVALID_JWK(env);
  }",25,,1027,2,,void
47401,BLOCK,-1,,"{
    // Secret key
    key->data_ = ImportJWKSecretKey(env, input);
    if (!key->data_) {
      // ImportJWKSecretKey is responsible for throwing an appropriate error
      return;
    }
  }",40,,1033,2,,void
47414,BLOCK,-1,,"{
      // ImportJWKSecretKey is responsible for throwing an appropriate error
      return;
    }",22,,1036,2,,void
47417,BLOCK,-1,,"{
    key->data_ = ImportJWKAsymmetricKey(env, input, *kty_string, args, 1);
    if (!key->data_) {
      // ImportJWKAsymmetricKey is responsible for throwing an appropriate error
      return;
    }
  }",10,,1040,1,,void
47434,BLOCK,-1,,"{
      // ImportJWKAsymmetricKey is responsible for throwing an appropriate error
      return;
    }",22,,1042,2,,void
47453,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());

  CHECK(args[0]->IsString());
  Utf8Value name(env->isolate(), args[0]);

  MarkPopErrorOnReturn mark_pop_error_on_return;

  int id = OBJ_txt2nid(*name);
  ECKeyPointer eckey(EC_KEY_new_by_curve_name(id));
  if (!eckey)
    return args.GetReturnValue().Set(false);

  const EC_GROUP* group = EC_KEY_get0_group(eckey.get());
  ECPointPointer pub(ECDH::BufferToPoint(env, group, args[1]));

  if (!pub ||
      !eckey ||
      !EC_KEY_set_public_key(eckey.get(), pub.get())) {
    return args.GetReturnValue().Set(false);
  }

  EVPKeyPointer pkey(EVP_PKEY_new());
  if (!EVP_PKEY_assign_EC_KEY(pkey.get(), eckey.get()))
    args.GetReturnValue().Set(false);

  eckey.release();  // Release ownership of the key

  key->data_ =
      KeyObjectData::CreateAsymmetric(
          kKeyTypePublic,
          ManagedEVPPKey(std::move(pkey)));

  args.GetReturnValue().Set(true);
}",74,,1051,2,,void
47500,BLOCK,-1,,<empty>,5,,1064,2,,void
47546,BLOCK,-1,,"{
    return args.GetReturnValue().Set(false);
  }",55,,1071,2,,void
47570,BLOCK,-1,,<empty>,5,,1077,2,,void
47610,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());

  CHECK(args[0]->IsString());
  Utf8Value name(env->isolate(), args[0]);

  ArrayBufferOrViewContents<unsigned char> key_data(args[1]);
  KeyType type = static_cast<KeyType>(args[2].As<Int32>()->Value());

  MarkPopErrorOnReturn mark_pop_error_on_return;

  typedef EVP_PKEY* (*new_key_fn)(int, ENGINE*, const unsigned char*, size_t);
  new_key_fn fn = type == kKeyTypePrivate
      ? EVP_PKEY_new_raw_private_key
      : EVP_PKEY_new_raw_public_key;

  int id = GetOKPCurveFromName(*name);

  switch (id) {
    case EVP_PKEY_X25519:
    case EVP_PKEY_X448:
    case EVP_PKEY_ED25519:
    case EVP_PKEY_ED448: {
      EVPKeyPointer pkey(fn(id, nullptr, key_data.data(), key_data.size()));
      if (!pkey)
        return args.GetReturnValue().Set(false);
      key->data_ =
          KeyObjectData::CreateAsymmetric(
              type,
              ManagedEVPPKey(std:...",74,,1089,2,,void
47668,BLOCK,-1,,<empty>,,,,5,,<empty>
47688,BLOCK,-1,,"{
    case EVP_PKEY_X25519:
    case EVP_PKEY_X448:
    case EVP_PKEY_ED25519:
    case EVP_PKEY_ED448: {
      EVPKeyPointer pkey(fn(id, nullptr, key_data.data(), key_data.size()));
      if (!pkey)
        return args.GetReturnValue().Set(false);
      key->data_ =
          KeyObjectData::CreateAsymmetric(
              type,
              ManagedEVPPKey(std::move(pkey)));
      CHECK(key->data_);
      break;
    }
    default:
      UNREACHABLE();
  }",15,,1109,2,,void
47697,BLOCK,9,,"{
      EVPKeyPointer pkey(fn(id, nullptr, key_data.data(), key_data.size()));
      if (!pkey)
        return args.GetReturnValue().Set(false);
      key->data_ =
          KeyObjectData::CreateAsymmetric(
              type,
              ManagedEVPPKey(std::move(pkey)));
      CHECK(key->data_);
      break;
    }",26,,1113,9,,void
47714,BLOCK,-1,,<empty>,9,,1116,2,,void
47758,BLOCK,-1,,"{
  KeyObjectHandle* self_handle;
  KeyObjectHandle* arg_handle;
  ASSIGN_OR_RETURN_UNWRAP(&self_handle, args.Holder());
  ASSIGN_OR_RETURN_UNWRAP(&arg_handle, args[0].As<Object>());
  std::shared_ptr<KeyObjectData> key = self_handle->Data();
  std::shared_ptr<KeyObjectData> key2 = arg_handle->Data();

  KeyType key_type = key->GetKeyType();
  CHECK_EQ(key_type, key2->GetKeyType());

  bool ret;
  switch (key_type) {
    case kKeyTypeSecret: {
      size_t size = key->GetSymmetricKeySize();
      if (size == key2->GetSymmetricKeySize()) {
        ret = CRYPTO_memcmp(
          key->GetSymmetricKey(),
          key2->GetSymmetricKey(),
          size) == 0;
      } else {
        ret = false;
      }
      break;
    }
    case kKeyTypePublic:
    case kKeyTypePrivate: {
      EVP_PKEY* pkey = key->GetAsymmetricKey().get();
      EVP_PKEY* pkey2 = key2->GetAsymmetricKey().get();
#if OPENSSL_VERSION_MAJOR >= 3
      int ok = EVP_PKEY_eq(pkey, pkey2);
#else
      int ok = EVP_PKEY_cmp(...",71,,1131,2,,void
47817,BLOCK,-1,,"{
    case kKeyTypeSecret: {
      size_t size = key->GetSymmetricKeySize();
      if (size == key2->GetSymmetricKeySize()) {
        ret = CRYPTO_memcmp(
          key->GetSymmetricKey(),
          key2->GetSymmetricKey(),
          size) == 0;
      } else {
        ret = false;
      }
      break;
    }
    case kKeyTypePublic:
    case kKeyTypePrivate: {
      EVP_PKEY* pkey = key->GetAsymmetricKey().get();
      EVP_PKEY* pkey2 = key2->GetAsymmetricKey().get();
#if OPENSSL_VERSION_MAJOR >= 3
      int ok = EVP_PKEY_eq(pkey, pkey2);
#else
      int ok = EVP_PKEY_cmp(pkey, pkey2);
#endif
      if (ok == -2) {
        Environment* env = Environment::GetCurrent(args);
        return THROW_ERR_CRYPTO_UNSUPPORTED_OPERATION(env);
      }
      ret = ok == 1;
      break;
    }
    default:
      UNREACHABLE(""unsupported key type"");
  }",21,,1143,2,,void
47820,BLOCK,3,,"{
      size_t size = key->GetSymmetricKeySize();
      if (size == key2->GetSymmetricKeySize()) {
        ret = CRYPTO_memcmp(
          key->GetSymmetricKey(),
          key2->GetSymmetricKey(),
          size) == 0;
      } else {
        ret = false;
      }
      break;
    }",26,,1144,3,,void
47835,BLOCK,-1,,"{
        ret = CRYPTO_memcmp(
          key->GetSymmetricKey(),
          key2->GetSymmetricKey(),
          size) == 0;
      }",48,,1146,2,,void
47851,BLOCK,-1,,"{
        ret = false;
      }",14,,1151,1,,void
47860,BLOCK,8,,"{
      EVP_PKEY* pkey = key->GetAsymmetricKey().get();
      EVP_PKEY* pkey2 = key2->GetAsymmetricKey().get();
#if OPENSSL_VERSION_MAJOR >= 3
      int ok = EVP_PKEY_eq(pkey, pkey2);
#else
      int ok = EVP_PKEY_cmp(pkey, pkey2);
#endif
      if (ok == -2) {
        Environment* env = Environment::GetCurrent(args);
        return THROW_ERR_CRYPTO_UNSUPPORTED_OPERATION(env);
      }
      ret = ok == 1;
      break;
    }",27,,1157,8,,void
47892,BLOCK,-1,,"{
        Environment* env = Environment::GetCurrent(args);
        return THROW_ERR_CRYPTO_UNSUPPORTED_OPERATION(env);
      }",21,,1165,2,,void
47925,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());

  CHECK(args[0]->IsObject());

  std::shared_ptr<KeyObjectData> data = key->Data();

  switch (data->GetKeyType()) {
    case kKeyTypeSecret:
      if (GetSecretKeyDetail(env, data, args[0].As<Object>()).IsNothing())
        return;
      break;
    case kKeyTypePublic:
      // Fall through
    case kKeyTypePrivate:
      if (GetAsymmetricKeyDetail(env, data, args[0].As<Object>()).IsNothing())
        return;
      break;
    default:
      UNREACHABLE();
  }

  args.GetReturnValue().Set(args[0]);
}",77,,1179,2,,void
47966,BLOCK,-1,,"{
    case kKeyTypeSecret:
      if (GetSecretKeyDetail(env, data, args[0].As<Object>()).IsNothing())
        return;
      break;
    case kKeyTypePublic:
      // Fall through
    case kKeyTypePrivate:
      if (GetAsymmetricKeyDetail(env, data, args[0].As<Object>()).IsNothing())
        return;
      break;
    default:
      UNREACHABLE();
  }",31,,1188,2,,void
47982,BLOCK,-1,,<empty>,9,,1191,2,,void
48002,BLOCK,-1,,<empty>,9,,1197,2,,void
48020,BLOCK,-1,,"{
  const ManagedEVPPKey& key = data_->GetAsymmetricKey();
  switch (EVP_PKEY_id(key.get())) {
  case EVP_PKEY_RSA:
    return env()->crypto_rsa_string();
  case EVP_PKEY_RSA_PSS:
    return env()->crypto_rsa_pss_string();
  case EVP_PKEY_DSA:
    return env()->crypto_dsa_string();
  case EVP_PKEY_DH:
    return env()->crypto_dh_string();
  case EVP_PKEY_EC:
    return env()->crypto_ec_string();
  case EVP_PKEY_ED25519:
    return env()->crypto_ed25519_string();
  case EVP_PKEY_ED448:
    return env()->crypto_ed448_string();
  case EVP_PKEY_X25519:
    return env()->crypto_x25519_string();
  case EVP_PKEY_X448:
    return env()->crypto_x448_string();
  default:
    return Undefined(env()->isolate());
  }
}",60,,1206,1,,void
48034,BLOCK,-1,,"{
  case EVP_PKEY_RSA:
    return env()->crypto_rsa_string();
  case EVP_PKEY_RSA_PSS:
    return env()->crypto_rsa_pss_string();
  case EVP_PKEY_DSA:
    return env()->crypto_dsa_string();
  case EVP_PKEY_DH:
    return env()->crypto_dh_string();
  case EVP_PKEY_EC:
    return env()->crypto_ec_string();
  case EVP_PKEY_ED25519:
    return env()->crypto_ed25519_string();
  case EVP_PKEY_ED448:
    return env()->crypto_ed448_string();
  case EVP_PKEY_X25519:
    return env()->crypto_x25519_string();
  case EVP_PKEY_X448:
    return env()->crypto_x448_string();
  default:
    return Undefined(env()->isolate());
  }",35,,1208,2,,void
48109,BLOCK,-1,,"{
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());

  args.GetReturnValue().Set(key->GetAsymmetricKeyType());
}",46,,1233,2,,void
48133,BLOCK,-1,,"{
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());
  args.GetReturnValue().Set(
      static_cast<uint32_t>(key->Data()->GetSymmetricKeySize()));
}",46,,1241,2,,void
48162,BLOCK,-1,,"{
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());

  KeyType type = key->Data()->GetKeyType();

  MaybeLocal<Value> result;
  if (type == kKeyTypeSecret) {
    result = key->ExportSecretKey();
  } else if (type == kKeyTypePublic) {
    unsigned int offset = 0;
    PublicKeyEncodingConfig config =
        ManagedEVPPKey::GetPublicKeyEncodingFromJs(
            args, &offset, kKeyContextExport);
    CHECK_EQ(offset, static_cast<unsigned int>(args.Length()));
    result = key->ExportPublicKey(config);
  } else {
    CHECK_EQ(type, kKeyTypePrivate);
    unsigned int offset = 0;
    NonCopyableMaybe<PrivateKeyEncodingConfig> config =
        ManagedEVPPKey::GetPrivateKeyEncodingFromJs(
            args, &offset, kKeyContextExport);
    if (config.IsEmpty())
      return;
    CHECK_EQ(offset, static_cast<unsigned int>(args.Length()));
    result = key->ExportPrivateKey(config.Release());
  }

  if (!result.IsEmpty())
    args.GetReturnValue().Set(result.FromMaybe(L...",71,,1248,2,,void
48190,BLOCK,-1,,"{
    result = key->ExportSecretKey();
  }",31,,1255,2,,void
48198,BLOCK,-1,,<empty>,10,,1257,1,,void
48203,BLOCK,-1,,"{
    unsigned int offset = 0;
    PublicKeyEncodingConfig config =
        ManagedEVPPKey::GetPublicKeyEncodingFromJs(
            args, &offset, kKeyContextExport);
    CHECK_EQ(offset, static_cast<unsigned int>(args.Length()));
    result = key->ExportPublicKey(config);
  }",38,,1257,2,,void
48235,BLOCK,-1,,"{
    CHECK_EQ(type, kKeyTypePrivate);
    unsigned int offset = 0;
    NonCopyableMaybe<PrivateKeyEncodingConfig> config =
        ManagedEVPPKey::GetPrivateKeyEncodingFromJs(
            args, &offset, kKeyContextExport);
    if (config.IsEmpty())
      return;
    CHECK_EQ(offset, static_cast<unsigned int>(args.Length()));
    result = key->ExportPrivateKey(config.Release());
  }",10,,1264,1,,void
48262,BLOCK,-1,,<empty>,7,,1271,2,,void
48288,BLOCK,-1,,<empty>,5,,1277,2,,void
48304,BLOCK,-1,,"{
  const char* buf = data_->GetSymmetricKey();
  unsigned int len = data_->GetSymmetricKeySize();
  return Buffer::Copy(env(), buf, len).FromMaybe(Local<Value>());
}",60,,1280,1,,void
48335,BLOCK,-1,,"{
  return WritePublicKey(env(), data_->GetAsymmetricKey().get(), config);
}",50,,1287,2,,void
48351,BLOCK,-1,,"{
  return WritePrivateKey(env(), data_->GetAsymmetricKey().get(), config);
}",51,,1292,2,,void
48367,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());

  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsBoolean());

  ExportJWKInner(env, key->Data(), args[0], args[1]->IsTrue());

  args.GetReturnValue().Set(args[0]);
}",54,,1297,2,,void
48428,BLOCK,-1,,"{
  SetMethod(env->context(),
            target,
            ""createNativeKeyObjectClass"",
            NativeKeyObject::CreateNativeKeyObjectClass);
}",74,,1310,3,,void
48443,BLOCK,-1,,"{
  registry->Register(NativeKeyObject::CreateNativeKeyObjectClass);
  registry->Register(NativeKeyObject::New);
}",42,,1318,2,,void
48462,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsObject());
  KeyObjectHandle* handle = Unwrap<KeyObjectHandle>(args[0].As<Object>());
  new NativeKeyObject(env, args.This(), handle->Data());
}",68,,1323,2,,void
48512,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  CHECK_EQ(args.Length(), 1);
  Local<Value> callback = args[0];
  CHECK(callback->IsFunction());

  Local<FunctionTemplate> t =
      NewFunctionTemplate(isolate, NativeKeyObject::New);
  t->InstanceTemplate()->SetInternalFieldCount(
      KeyObjectHandle::kInternalFieldCount);

  Local<Value> ctor;
  if (!t->GetFunction(env->context()).ToLocal(&ctor))
    return;

  Local<Value> recv = Undefined(env->isolate());
  Local<Value> ret_v;
  if (!callback.As<Function>()->Call(
          env->context(), recv, 1, &ctor).ToLocal(&ret_v)) {
    return;
  }
  Local<Array> ret = ret_v.As<Array>();
  if (!ret->Get(env->context(), 1).ToLocal(&ctor)) return;
  env->set_crypto_key_object_secret_constructor(ctor.As<Function>());
  if (!ret->Get(env->context(), 2).ToLocal(&ctor)) return;
  env->set_crypto_key_object_public_constructor(ctor.As<Function>());
  if (!ret->Get(env->context(), 3).ToLocal(&ctor)) r...",46,,1332,2,,void
48589,BLOCK,-1,,<empty>,5,,1347,2,,void
48629,BLOCK,-1,,"{
    return;
  }",60,,1352,2,,void
48657,BLOCK,-1,,<empty>,52,,1356,2,,void
48683,BLOCK,-1,,<empty>,52,,1358,2,,void
48709,BLOCK,-1,,<empty>,52,,1360,2,,void
48733,BLOCK,-1,,"{
  if (context != env->context()) {
    THROW_ERR_MESSAGE_TARGET_CONTEXT_UNAVAILABLE(env);
    return {};
  }

  Local<Value> handle;
  if (!KeyObjectHandle::Create(env, data_).ToLocal(&handle))
    return {};

  Local<Function> key_ctor;
  Local<Value> arg = FIXED_ONE_BYTE_STRING(env->isolate(),
                                           ""internal/crypto/keys"");
  if (env->builtin_module_require()
          ->Call(context, Null(env->isolate()), 1, &arg)
          .IsEmpty()) {
    return {};
  }
  switch (data_->GetKeyType()) {
    case kKeyTypeSecret:
      key_ctor = env->crypto_key_object_secret_constructor();
      break;
    case kKeyTypePublic:
      key_ctor = env->crypto_key_object_public_constructor();
      break;
    case kKeyTypePrivate:
      key_ctor = env->crypto_key_object_private_constructor();
      break;
    default:
      UNREACHABLE();
  }

  Local<Value> key;
  if (!key_ctor->NewInstance(context, 1, &handle).ToLocal(&key))
    return {};

  return BaseObject...",53,,1368,4,,void
48741,BLOCK,-1,,"{
    THROW_ERR_MESSAGE_TARGET_CONTEXT_UNAVAILABLE(env);
    return {};
  }",34,,1369,2,,void
48763,BLOCK,-1,,<empty>,5,,1376,2,,void
48802,BLOCK,-1,,"{
    return {};
  }",23,,1383,2,,void
48809,BLOCK,-1,,"{
    case kKeyTypeSecret:
      key_ctor = env->crypto_key_object_secret_constructor();
      break;
    case kKeyTypePublic:
      key_ctor = env->crypto_key_object_public_constructor();
      break;
    case kKeyTypePrivate:
      key_ctor = env->crypto_key_object_private_constructor();
      break;
    default:
      UNREACHABLE();
  }",32,,1386,2,,void
48859,BLOCK,-1,,<empty>,5,,1402,2,,void
48877,BLOCK,-1,,"{
  return BaseObject::TransferMode::kCloneable;
}",67,,1407,1,,void
48887,BLOCK,-1,,"{
  return std::make_unique<KeyObjectTransferData>(handle_data_);
}",11,,1412,1,,void
48901,BLOCK,-1,,"{
  CHECK_EQ(key_data->GetKeyType(), kKeyTypePublic);
  ManagedEVPPKey m_pkey = key_data->GetAsymmetricKey();
  Mutex::ScopedLock lock(*m_pkey.mutex());
  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);
  if (!i2d_PUBKEY_bio(bio.get(), m_pkey.get()))
    return WebCryptoKeyExportStatus::FAILED;

  *out = ByteSource::FromBIO(bio);
  return WebCryptoKeyExportStatus::OK;
}",22,,1418,3,,void
48924,BLOCK,-1,,<empty>,,,,2,,<empty>
48940,BLOCK,-1,,<empty>,5,,1425,2,,void
48962,BLOCK,-1,,"{
  CHECK_EQ(key_data->GetKeyType(), kKeyTypePrivate);
  ManagedEVPPKey m_pkey = key_data->GetAsymmetricKey();
  Mutex::ScopedLock lock(*m_pkey.mutex());

  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);
  PKCS8Pointer p8inf(EVP_PKEY2PKCS8(m_pkey.get()));
  if (!i2d_PKCS8_PRIV_KEY_INFO_bio(bio.get(), p8inf.get()))
    return WebCryptoKeyExportStatus::FAILED;

  *out = ByteSource::FromBIO(bio);
  return WebCryptoKeyExportStatus::OK;
}",22,,1433,3,,void
48985,BLOCK,-1,,<empty>,,,,2,,<empty>
49008,BLOCK,-1,,<empty>,5,,1442,2,,void
49031,BLOCK,-1,,"{
  target->Set(env->context(),
              FIXED_ONE_BYTE_STRING(env->isolate(), ""KeyObjectHandle""),
              KeyObjectHandle::Initialize(env)).Check();

  NODE_DEFINE_CONSTANT(target, kWebCryptoKeyFormatRaw);
  NODE_DEFINE_CONSTANT(target, kWebCryptoKeyFormatPKCS8);
  NODE_DEFINE_CONSTANT(target, kWebCryptoKeyFormatSPKI);
  NODE_DEFINE_CONSTANT(target, kWebCryptoKeyFormatJWK);

  NODE_DEFINE_CONSTANT(target, EVP_PKEY_ED25519);
  NODE_DEFINE_CONSTANT(target, EVP_PKEY_ED448);
  NODE_DEFINE_CONSTANT(target, EVP_PKEY_X25519);
  NODE_DEFINE_CONSTANT(target, EVP_PKEY_X448);
  NODE_DEFINE_CONSTANT(target, kKeyEncodingPKCS1);
  NODE_DEFINE_CONSTANT(target, kKeyEncodingPKCS8);
  NODE_DEFINE_CONSTANT(target, kKeyEncodingSPKI);
  NODE_DEFINE_CONSTANT(target, kKeyEncodingSEC1);
  NODE_DEFINE_CONSTANT(target, kKeyFormatDER);
  NODE_DEFINE_CONSTANT(target, kKeyFormatPEM);
  NODE_DEFINE_CONSTANT(target, kKeyFormatJWK);
  NODE_DEFINE_CONSTANT(target, kKeyTypeSecret);
  NODE_DEFINE_CONSTANT...",57,,1449,3,,void
49059,BLOCK,1,,<empty>,,,,7,,void
49061,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kWebCryptoKeyFormatRaw)",3,,1454,1,,void
49158,BLOCK,1,,<empty>,,,,7,,void
49160,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kWebCryptoKeyFormatPKCS8)",3,,1455,1,,void
49257,BLOCK,1,,<empty>,,,,7,,void
49259,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kWebCryptoKeyFormatSPKI)",3,,1456,1,,void
49356,BLOCK,1,,<empty>,,,,7,,void
49358,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kWebCryptoKeyFormatJWK)",3,,1457,1,,void
49455,BLOCK,1,,<empty>,,,,7,,void
49457,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, EVP_PKEY_ED25519)",3,,1459,1,,void
49554,BLOCK,1,,<empty>,,,,7,,void
49556,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, EVP_PKEY_ED448)",3,,1460,1,,void
49653,BLOCK,1,,<empty>,,,,7,,void
49655,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, EVP_PKEY_X25519)",3,,1461,1,,void
49752,BLOCK,1,,<empty>,,,,7,,void
49754,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, EVP_PKEY_X448)",3,,1462,1,,void
49851,BLOCK,1,,<empty>,,,,7,,void
49853,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kKeyEncodingPKCS1)",3,,1463,1,,void
49950,BLOCK,1,,<empty>,,,,7,,void
49952,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kKeyEncodingPKCS8)",3,,1464,1,,void
50049,BLOCK,1,,<empty>,,,,7,,void
50051,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kKeyEncodingSPKI)",3,,1465,1,,void
50148,BLOCK,1,,<empty>,,,,7,,void
50150,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kKeyEncodingSEC1)",3,,1466,1,,void
50247,BLOCK,1,,<empty>,,,,7,,void
50249,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kKeyFormatDER)",3,,1467,1,,void
50346,BLOCK,1,,<empty>,,,,7,,void
50348,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kKeyFormatPEM)",3,,1468,1,,void
50445,BLOCK,1,,<empty>,,,,7,,void
50447,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kKeyFormatJWK)",3,,1469,1,,void
50544,BLOCK,1,,<empty>,,,,7,,void
50546,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kKeyTypeSecret)",3,,1470,1,,void
50643,BLOCK,1,,<empty>,,,,7,,void
50645,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kKeyTypePublic)",3,,1471,1,,void
50742,BLOCK,1,,<empty>,,,,7,,void
50744,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kKeyTypePrivate)",3,,1472,1,,void
50841,BLOCK,1,,<empty>,,,,7,,void
50843,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kSigEncDER)",3,,1473,1,,void
50940,BLOCK,1,,<empty>,,,,7,,void
50942,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kSigEncP1363)",3,,1474,1,,void
51038,BLOCK,-1,,"{
  KeyObjectHandle::RegisterExternalReferences(registry);
}",70,,1477,2,,void
51070,BLOCK,-1,,<empty>,1,,1,1,,ANY
51091,BLOCK,-1,,<empty>,1,,1,1,,ANY
51096,BLOCK,-1,,<empty>,28,,26,2,,void
51101,BLOCK,-1,,"{
  if (&other == this) return *this;
  this->~PBKDF2Config();
  return *new (this) PBKDF2Config(std::move(other));
}",70,,28,2,,void
51107,BLOCK,-1,,<empty>,23,,29,2,,void
51129,BLOCK,-1,,"{
  // The job is sync, the PBKDF2Config does not own the data.
  if (mode == kCryptoJobAsync) {
    tracker->TrackFieldWithSize(""pass"", pass.size());
    tracker->TrackFieldWithSize(""salt"", salt.size());
  }
}",61,,34,2,,void
51134,BLOCK,-1,,"{
    tracker->TrackFieldWithSize(""pass"", pass.size());
    tracker->TrackFieldWithSize(""salt"", salt.size());
  }",32,,36,2,,void
51160,BLOCK,-1,,"{
  *result = out->ToArrayBuffer(env);
  return Just(!result->IsEmpty());
}",35,,46,5,,void
51183,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  params->mode = mode;

  ArrayBufferOrViewContents<char> pass(args[offset]);
  ArrayBufferOrViewContents<char> salt(args[offset + 1]);

  if (UNLIKELY(!pass.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(env, ""pass is too large"");
    return Nothing<bool>();
  }

  if (UNLIKELY(!salt.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(env, ""salt is too large"");
    return Nothing<bool>();
  }

  params->pass = mode == kCryptoJobAsync
      ? pass.ToCopy()
      : pass.ToByteSource();

  params->salt = mode == kCryptoJobAsync
      ? salt.ToCopy()
      : salt.ToByteSource();

  CHECK(args[offset + 2]->IsInt32());  // iteration_count
  CHECK(args[offset + 3]->IsInt32());  // length
  CHECK(args[offset + 4]->IsString());  // digest_name

  params->iterations = args[offset + 2].As<Int32>()->Value();
  if (params->iterations < 0) {
    THROW_ERR_OUT_OF_RANGE(env, ""iterations must be <= %d"", INT_MAX);
    return Nothing<bool>();
  }

 ...",27,,62,5,,void
51216,BLOCK,-1,,"{
    THROW_ERR_OUT_OF_RANGE(env, ""pass is too large"");
    return Nothing<bool>();
  }",41,,70,2,,void
51229,BLOCK,-1,,"{
    THROW_ERR_OUT_OF_RANGE(env, ""salt is too large"");
    return Nothing<bool>();
  }",41,,75,2,,void
51315,BLOCK,-1,,"{
    THROW_ERR_OUT_OF_RANGE(env, ""iterations must be <= %d"", INT_MAX);
    return Nothing<bool>();
  }",31,,93,2,,void
51343,BLOCK,-1,,"{
    THROW_ERR_OUT_OF_RANGE(env, ""length must be <= %d"", INT_MAX);
    return Nothing<bool>();
  }",27,,99,2,,void
51374,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *name);
    return Nothing<bool>();
  }",34,,106,2,,void
51391,BLOCK,-1,,"{
  ByteSource::Builder buf(params.length);

  // Both pass and salt may be zero length here.
  // The generated bytes are stored in buf, which is
  // assigned to out on success.

  if (PKCS5_PBKDF2_HMAC(params.pass.data<char>(),
                        params.pass.size(),
                        params.salt.data<unsigned char>(),
                        params.salt.size(),
                        params.iterations,
                        params.digest,
                        params.length,
                        buf.data<unsigned char>()) <= 0) {
    return false;
  }
  *out = std::move(buf).release();
  return true;
}",22,,117,4,,void
51438,BLOCK,-1,,"{
    return false;
  }",58,,131,2,,void
51470,BLOCK,-1,,<empty>,1,,1,1,,ANY
51493,BLOCK,-1,,<empty>,1,,1,1,,ANY
51501,BLOCK,-1,,"{
  *result = v8::Undefined(env->isolate());
  return Just(!result->IsEmpty());
}",35,,32,5,,void
51527,BLOCK,-1,,"{
  CHECK(IsAnyByteSource(args[offset]));  // Buffer to fill
  CHECK(args[offset + 1]->IsUint32());  // Offset
  CHECK(args[offset + 2]->IsUint32());  // Size

  ArrayBufferOrViewContents<unsigned char> in(args[offset]);

  const uint32_t byte_offset = args[offset + 1].As<Uint32>()->Value();
  const uint32_t size = args[offset + 2].As<Uint32>()->Value();
  CHECK_GE(byte_offset + size, byte_offset);  // Overflow check.
  CHECK_LE(byte_offset + size, in.size());  // Bounds check.

  params->buffer = in.data() + byte_offset;
  params->size = size;

  return Just(true);
}",32,,41,5,,void
51621,BLOCK,-1,,"{
  return CSPRNG(params.buffer, params.size).is_ok();
}",25,,62,4,,void
51637,BLOCK,-1,,"{
  tracker->TrackFieldWithSize(""prime"", prime ? bits * 8 : 0);
}",66,,66,2,,void
51656,BLOCK,-1,,"{
  size_t size = BN_num_bytes(params.prime.get());
  std::shared_ptr<BackingStore> store =
      ArrayBuffer::NewBackingStore(env->isolate(), size);
  BN_bn2binpad(
      params.prime.get(),
      reinterpret_cast<unsigned char*>(store->Data()),
      size);
  *result = ArrayBuffer::New(env->isolate(), store);
  return Just(true);
}",35,,74,5,,void
51720,BLOCK,-1,,"{
  ClearErrorOnReturn clear_error;
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[offset]->IsUint32());  // Size
  CHECK(args[offset + 1]->IsBoolean());  // Safe

  const uint32_t size = args[offset].As<Uint32>()->Value();
  bool safe = args[offset + 1]->IsTrue();

  if (!args[offset + 2]->IsUndefined()) {
    ArrayBufferOrViewContents<unsigned char> add(args[offset + 2]);
    params->add.reset(BN_bin2bn(add.data(), add.size(), nullptr));
    if (!params->add) {
      THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""could not generate prime"");
      return Nothing<bool>();
    }
  }

  if (!args[offset + 3]->IsUndefined()) {
    ArrayBufferOrViewContents<unsigned char> rem(args[offset + 3]);
    params->rem.reset(BN_bin2bn(rem.data(), rem.size(), nullptr));
    if (!params->rem) {
      THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""could not generate prime"");
      return Nothing<bool>();
    }
  }

  // The JS interface already ensures that the (positive) size fits into an int....",32,,90,5,,void
51779,BLOCK,-1,,"{
    ArrayBufferOrViewContents<unsigned char> add(args[offset + 2]);
    params->add.reset(BN_bin2bn(add.data(), add.size(), nullptr));
    if (!params->add) {
      THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""could not generate prime"");
      return Nothing<bool>();
    }
  }",41,,99,2,,void
51808,BLOCK,-1,,"{
      THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""could not generate prime"");
      return Nothing<bool>();
    }",23,,102,2,,void
51824,BLOCK,-1,,"{
    ArrayBufferOrViewContents<unsigned char> rem(args[offset + 3]);
    params->rem.reset(BN_bin2bn(rem.data(), rem.size(), nullptr));
    if (!params->rem) {
      THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""could not generate prime"");
      return Nothing<bool>();
    }
  }",41,,108,2,,void
51853,BLOCK,-1,,"{
      THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""could not generate prime"");
      return Nothing<bool>();
    }",23,,111,2,,void
51872,BLOCK,-1,,"{
    if (BN_num_bits(params->add.get()) > bits) {
      // If we allowed this, the best case would be returning a static prime
      // that wasn't generated randomly. The worst case would be an infinite
      // loop within OpenSSL, blocking the main thread or one of the threads
      // in the thread pool.
      THROW_ERR_OUT_OF_RANGE(env, ""invalid options.add"");
      return Nothing<bool>();
    }

    if (params->rem) {
      if (BN_cmp(params->add.get(), params->rem.get()) != 1) {
        // This would definitely lead to an infinite loop if allowed since
        // OpenSSL does not check this condition.
        THROW_ERR_OUT_OF_RANGE(env, ""invalid options.rem"");
        return Nothing<bool>();
      }
    }
  }",20,,121,2,,void
51883,BLOCK,-1,,"{
      // If we allowed this, the best case would be returning a static prime
      // that wasn't generated randomly. The worst case would be an infinite
      // loop within OpenSSL, blocking the main thread or one of the threads
      // in the thread pool.
      THROW_ERR_OUT_OF_RANGE(env, ""invalid options.add"");
      return Nothing<bool>();
    }",48,,122,2,,void
51893,BLOCK,-1,,"{
      if (BN_cmp(params->add.get(), params->rem.get()) != 1) {
        // This would definitely lead to an infinite loop if allowed since
        // OpenSSL does not check this condition.
        THROW_ERR_OUT_OF_RANGE(env, ""invalid options.rem"");
        return Nothing<bool>();
      }
    }",22,,131,2,,void
51910,BLOCK,-1,,"{
        // This would definitely lead to an infinite loop if allowed since
        // OpenSSL does not check this condition.
        THROW_ERR_OUT_OF_RANGE(env, ""invalid options.rem"");
        return Nothing<bool>();
      }",62,,132,2,,void
51938,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""could not generate prime"");
    return Nothing<bool>();
  }",23,,144,2,,void
51953,BLOCK,-1,,"{
  // BN_generate_prime_ex() calls RAND_bytes_ex() internally.
  // Make sure the CSPRNG is properly seeded.
  CHECK(CSPRNG(nullptr, 0).is_ok());

  if (BN_generate_prime_ex(
          params.prime.get(),
          params.bits,
          params.safe ? 1 : 0,
          params.add.get(),
          params.rem.get(),
          nullptr) == 0) {
    return false;
  }

  return true;
}",56,,154,4,,void
51993,BLOCK,-1,,"{
    return false;
  }",26,,165,2,,void
52002,BLOCK,-1,,"{
  tracker->TrackFieldWithSize(
      ""prime"", candidate ? BN_num_bytes(candidate.get()) : 0);
}",65,,172,2,,void
52023,BLOCK,-1,,"{
  ArrayBufferOrViewContents<unsigned char> candidate(args[offset]);

  params->candidate =
      BignumPointer(BN_bin2bn(
          candidate.data(),
          candidate.size(),
          nullptr));

  CHECK(args[offset + 1]->IsInt32());  // Checks
  params->checks = args[offset + 1].As<Int32>()->Value();
  CHECK_GE(params->checks, 0);

  return Just(true);
}",31,,181,5,,void
52082,BLOCK,-1,,"{

  BignumCtxPointer ctx(BN_CTX_new());

  int ret = BN_is_prime_ex(
            params.candidate.get(),
            params.checks,
            ctx.get(),
            nullptr);
  if (ret < 0) return false;
  ByteSource::Builder buf(1);
  buf.data<char>()[0] = ret;
  *out = std::move(buf).release();
  return true;
}",22,,200,4,,void
52108,BLOCK,-1,,<empty>,16,,209,2,,void
52142,BLOCK,-1,,"{
  *result = Boolean::New(env->isolate(), out->data<char>()[0] != 0);
  return Just(true);
}",35,,220,5,,void
52171,BLOCK,-1,,"{
  RandomBytesJob::Initialize(env, target);
  RandomPrimeJob::Initialize(env, target);
  CheckPrimeJob::Initialize(env, target);
}",57,,226,3,,void
52194,BLOCK,-1,,"{
  RandomBytesJob::RegisterExternalReferences(registry);
  RandomPrimeJob::RegisterExternalReferences(registry);
  CheckPrimeJob::RegisterExternalReferences(registry);
}",70,,232,2,,void
52228,BLOCK,-1,,<empty>,1,,1,1,,ANY
52257,BLOCK,-1,,<empty>,1,,1,1,,ANY
52262,BLOCK,-1,,"{
  EVPKeyCtxPointer ctx(
      EVP_PKEY_CTX_new_id(
          params->params.variant == kKeyVariantRSA_PSS
              ? EVP_PKEY_RSA_PSS
              : EVP_PKEY_RSA,
          nullptr));

  if (EVP_PKEY_keygen_init(ctx.get()) <= 0)
    return EVPKeyCtxPointer();

  if (EVP_PKEY_CTX_set_rsa_keygen_bits(
          ctx.get(),
          params->params.modulus_bits) <= 0) {
    return EVPKeyCtxPointer();
  }

  // 0x10001 is the default RSA exponent.
  if (params->params.exponent != 0x10001) {
    BignumPointer bn(BN_new());
    CHECK_NOT_NULL(bn.get());
    CHECK(BN_set_word(bn.get(), params->params.exponent));
    // EVP_CTX accepts ownership of bn on success.
    if (EVP_PKEY_CTX_set_rsa_keygen_pubexp(ctx.get(), bn.get()) <= 0)
      return EVPKeyCtxPointer();

    bn.release();
  }

  if (params->params.variant == kKeyVariantRSA_PSS) {
    if (params->params.md != nullptr &&
        EVP_PKEY_CTX_set_rsa_pss_keygen_md(ctx.get(), params->params.md) <= 0) {
      return EVPKeyCtxPo...",70,,32,2,,void
52285,BLOCK,-1,,<empty>,5,,41,2,,void
52301,BLOCK,-1,,"{
    return EVPKeyCtxPointer();
  }",46,,45,2,,void
52312,BLOCK,-1,,"{
    BignumPointer bn(BN_new());
    CHECK_NOT_NULL(bn.get());
    CHECK(BN_set_word(bn.get(), params->params.exponent));
    // EVP_CTX accepts ownership of bn on success.
    if (EVP_PKEY_CTX_set_rsa_keygen_pubexp(ctx.get(), bn.get()) <= 0)
      return EVPKeyCtxPointer();

    bn.release();
  }",43,,50,2,,void
52344,BLOCK,-1,,<empty>,7,,56,2,,void
52359,BLOCK,-1,,"{
    if (params->params.md != nullptr &&
        EVP_PKEY_CTX_set_rsa_pss_keygen_md(ctx.get(), params->params.md) <= 0) {
      return EVPKeyCtxPointer();
    }

    // TODO(tniessen): This appears to only be necessary in OpenSSL 3, while
    // OpenSSL 1.1.1 behaves as recommended by RFC 8017 and defaults the MGF1
    // hash algorithm to the RSA-PSS hashAlgorithm. Remove this code if the
    // behavior of OpenSSL 3 changes.
    const EVP_MD* mgf1_md = params->params.mgf1_md;
    if (mgf1_md == nullptr && params->params.md != nullptr) {
      mgf1_md = params->params.md;
    }

    if (mgf1_md != nullptr &&
        EVP_PKEY_CTX_set_rsa_pss_keygen_mgf1_md(
            ctx.get(),
            mgf1_md) <= 0) {
      return EVPKeyCtxPointer();
    }

    int saltlen = params->params.saltlen;
    if (saltlen < 0 && params->params.md != nullptr) {
      saltlen = EVP_MD_size(params->params.md);
    }

    if (saltlen >= 0 &&
        EVP_PKEY_CTX_set_rsa_pss_keygen_saltlen(
            c...",53,,61,2,,void
52381,BLOCK,-1,,"{
      return EVPKeyCtxPointer();
    }",80,,63,2,,void
52404,BLOCK,-1,,"{
      mgf1_md = params->params.md;
    }",61,,72,2,,void
52425,BLOCK,-1,,"{
      return EVPKeyCtxPointer();
    }",28,,79,2,,void
52448,BLOCK,-1,,"{
      saltlen = EVP_MD_size(params->params.md);
    }",54,,84,2,,void
52470,BLOCK,-1,,"{
      return EVPKeyCtxPointer();
    }",28,,91,2,,void
52482,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[*offset]->IsUint32());  // Variant
  CHECK(args[*offset + 1]->IsUint32());  // Modulus bits
  CHECK(args[*offset + 2]->IsUint32());  // Exponent

  params->params.variant =
      static_cast<RSAKeyVariant>(args[*offset].As<Uint32>()->Value());

  CHECK_IMPLIES(params->params.variant != kKeyVariantRSA_PSS,
                args.Length() == 10);
  CHECK_IMPLIES(params->params.variant == kKeyVariantRSA_PSS,
                args.Length() == 13);

  params->params.modulus_bits = args[*offset + 1].As<Uint32>()->Value();
  params->params.exponent = args[*offset + 2].As<Uint32>()->Value();

  *offset += 3;

  if (params->params.variant == kKeyVariantRSA_PSS) {
    if (!args[*offset]->IsUndefined()) {
      CHECK(args[*offset]->IsString());
      Utf8Value digest(env->isolate(), args[*offset]);
      params->params.md = EVP_get_digestbyname(*digest);
      if (params->params.md == nullptr) {
        THROW_ERR_CRYPTO_INVALID_D...",34,,130,5,,void
52613,BLOCK,-1,,"{
    if (!args[*offset]->IsUndefined()) {
      CHECK(args[*offset]->IsString());
      Utf8Value digest(env->isolate(), args[*offset]);
      params->params.md = EVP_get_digestbyname(*digest);
      if (params->params.md == nullptr) {
        THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *digest);
        return Nothing<bool>();
      }
    }

    if (!args[*offset + 1]->IsUndefined()) {
      CHECK(args[*offset + 1]->IsString());
      Utf8Value digest(env->isolate(), args[*offset + 1]);
      params->params.mgf1_md = EVP_get_digestbyname(*digest);
      if (params->params.mgf1_md == nullptr) {
        THROW_ERR_CRYPTO_INVALID_DIGEST(
            env, ""Invalid MGF1 digest: %s"", *digest);
        return Nothing<bool>();
      }
    }

    if (!args[*offset + 2]->IsUndefined()) {
      CHECK(args[*offset + 2]->IsInt32());
      params->params.saltlen = args[*offset + 2].As<Int32>()->Value();
      if (params->params.saltlen < 0) {
        THROW_ERR_OUT_OF_RANGE(
      ...",53,,150,2,,void
52623,BLOCK,-1,,"{
      CHECK(args[*offset]->IsString());
      Utf8Value digest(env->isolate(), args[*offset]);
      params->params.md = EVP_get_digestbyname(*digest);
      if (params->params.md == nullptr) {
        THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *digest);
        return Nothing<bool>();
      }
    }",40,,151,2,,void
52659,BLOCK,-1,,"{
        THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *digest);
        return Nothing<bool>();
      }",41,,155,2,,void
52678,BLOCK,-1,,"{
      CHECK(args[*offset + 1]->IsString());
      Utf8Value digest(env->isolate(), args[*offset + 1]);
      params->params.mgf1_md = EVP_get_digestbyname(*digest);
      if (params->params.mgf1_md == nullptr) {
        THROW_ERR_CRYPTO_INVALID_DIGEST(
            env, ""Invalid MGF1 digest: %s"", *digest);
        return Nothing<bool>();
      }
    }",44,,161,2,,void
52718,BLOCK,-1,,"{
        THROW_ERR_CRYPTO_INVALID_DIGEST(
            env, ""Invalid MGF1 digest: %s"", *digest);
        return Nothing<bool>();
      }",46,,165,2,,void
52737,BLOCK,-1,,"{
      CHECK(args[*offset + 2]->IsInt32());
      params->params.saltlen = args[*offset + 2].As<Int32>()->Value();
      if (params->params.saltlen < 0) {
        THROW_ERR_OUT_OF_RANGE(
          env,
          ""salt length is out of range"");
        return Nothing<bool>();
      }
    }",44,,172,2,,void
52774,BLOCK,-1,,"{
        THROW_ERR_OUT_OF_RANGE(
          env,
          ""salt length is out of range"");
        return Nothing<bool>();
      }",39,,175,2,,void
52794,BLOCK,-1,,"{
  return WebCryptoKeyExportStatus::FAILED;
}",22,,193,4,,void
52807,BLOCK,-1,,"{
  CHECK_NE(key_data->GetKeyType(), kKeyTypeSecret);
  ManagedEVPPKey m_pkey = key_data->GetAsymmetricKey();
  Mutex::ScopedLock lock(*m_pkey.mutex());

  EVPKeyCtxPointer ctx(EVP_PKEY_CTX_new(m_pkey.get(), nullptr));

  if (!ctx || init(ctx.get()) <= 0)
    return WebCryptoCipherStatus::FAILED;

  if (EVP_PKEY_CTX_set_rsa_padding(ctx.get(), params.padding) <= 0) {
    return WebCryptoCipherStatus::FAILED;
  }

  if (params.digest != nullptr &&
      (EVP_PKEY_CTX_set_rsa_oaep_md(ctx.get(), params.digest) <= 0 ||
       EVP_PKEY_CTX_set_rsa_mgf1_md(ctx.get(), params.digest) <= 0)) {
    return WebCryptoCipherStatus::FAILED;
  }

  if (!SetRsaOaepLabel(ctx, params.label)) return WebCryptoCipherStatus::FAILED;

  size_t out_len = 0;
  if (cipher(
          ctx.get(),
          nullptr,
          &out_len,
          in.data<unsigned char>(),
          in.size()) <= 0) {
    return WebCryptoCipherStatus::FAILED;
  }

  ByteSource::Builder buf(out_len);

  if (cipher(ctx.get(),
        ...",22,,204,6,,void
52847,BLOCK,-1,,<empty>,5,,212,2,,void
52863,BLOCK,-1,,"{
    return WebCryptoCipherStatus::FAILED;
  }",69,,214,2,,void
52896,BLOCK,-1,,"{
    return WebCryptoCipherStatus::FAILED;
  }",70,,220,2,,void
52908,BLOCK,-1,,<empty>,44,,224,2,,void
52936,BLOCK,-1,,"{
    return WebCryptoCipherStatus::FAILED;
  }",28,,232,2,,void
52966,BLOCK,-1,,"{
    return WebCryptoCipherStatus::FAILED;
  }",31,,242,2,,void
52993,BLOCK,-1,,"{
  CHECK(args[offset]->IsUint32());  // RSAKeyVariant
  params->variant =
      static_cast<RSAKeyVariant>(args[offset].As<Uint32>()->Value());
  return Just(true);
}",33,,254,4,,void
53026,BLOCK,-1,,"{
  CHECK_NE(key_data->GetKeyType(), kKeyTypeSecret);

  switch (format) {
    case kWebCryptoKeyFormatRaw:
      // Not supported for RSA keys of either type
      return WebCryptoKeyExportStatus::FAILED;
    case kWebCryptoKeyFormatJWK:
      return RSA_JWK_Export(key_data.get(), params, out);
    case kWebCryptoKeyFormatPKCS8:
      if (key_data->GetKeyType() != kKeyTypePrivate)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_PKCS8_Export(key_data.get(), out);
    case kWebCryptoKeyFormatSPKI:
      if (key_data->GetKeyType() != kKeyTypePublic)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_SPKI_Export(key_data.get(), out);
    default:
      UNREACHABLE();
  }
}",22,,265,5,,void
53035,BLOCK,-1,,"{
    case kWebCryptoKeyFormatRaw:
      // Not supported for RSA keys of either type
      return WebCryptoKeyExportStatus::FAILED;
    case kWebCryptoKeyFormatJWK:
      return RSA_JWK_Export(key_data.get(), params, out);
    case kWebCryptoKeyFormatPKCS8:
      if (key_data->GetKeyType() != kKeyTypePrivate)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_PKCS8_Export(key_data.get(), out);
    case kWebCryptoKeyFormatSPKI:
      if (key_data->GetKeyType() != kKeyTypePublic)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_SPKI_Export(key_data.get(), out);
    default:
      UNREACHABLE();
  }",19,,268,2,,void
53061,BLOCK,-1,,<empty>,9,,276,2,,void
53082,BLOCK,-1,,<empty>,9,,280,2,,void
53100,BLOCK,-1,,<empty>,28,,291,2,,void
53105,BLOCK,-1,,"{
  if (mode == kCryptoJobAsync)
    tracker->TrackFieldWithSize(""label"", label.size());
}",64,,293,2,,void
53110,BLOCK,-1,,<empty>,5,,295,2,,void
53128,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  params->mode = mode;
  params->padding = RSA_PKCS1_OAEP_PADDING;

  CHECK(args[offset]->IsUint32());
  RSAKeyVariant variant =
      static_cast<RSAKeyVariant>(args[offset].As<Uint32>()->Value());

  switch (variant) {
    case kKeyVariantRSA_OAEP: {
      CHECK(args[offset + 1]->IsString());  // digest
      Utf8Value digest(env->isolate(), args[offset + 1]);

      params->digest = EVP_get_digestbyname(*digest);
      if (params->digest == nullptr) {
        THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *digest);
        return Nothing<bool>();
      }

      if (IsAnyByteSource(args[offset + 2])) {
        ArrayBufferOrViewContents<char> label(args[offset + 2]);
        if (UNLIKELY(!label.CheckSizeInt32())) {
          THROW_ERR_OUT_OF_RANGE(env, ""label is too big"");
          return Nothing<bool>();
        }
        params->label = label.ToCopy();
      }
      break;
    }
    default:
      THROW_ERR_CRYPT...",30,,303,6,,void
53170,BLOCK,-1,,"{
    case kKeyVariantRSA_OAEP: {
      CHECK(args[offset + 1]->IsString());  // digest
      Utf8Value digest(env->isolate(), args[offset + 1]);

      params->digest = EVP_get_digestbyname(*digest);
      if (params->digest == nullptr) {
        THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *digest);
        return Nothing<bool>();
      }

      if (IsAnyByteSource(args[offset + 2])) {
        ArrayBufferOrViewContents<char> label(args[offset + 2]);
        if (UNLIKELY(!label.CheckSizeInt32())) {
          THROW_ERR_OUT_OF_RANGE(env, ""label is too big"");
          return Nothing<bool>();
        }
        params->label = label.ToCopy();
      }
      break;
    }
    default:
      THROW_ERR_CRYPTO_INVALID_KEYTYPE(env);
      return Nothing<bool>();
  }",20,,313,2,,void
53173,BLOCK,3,,"{
      CHECK(args[offset + 1]->IsString());  // digest
      Utf8Value digest(env->isolate(), args[offset + 1]);

      params->digest = EVP_get_digestbyname(*digest);
      if (params->digest == nullptr) {
        THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *digest);
        return Nothing<bool>();
      }

      if (IsAnyByteSource(args[offset + 2])) {
        ArrayBufferOrViewContents<char> label(args[offset + 2]);
        if (UNLIKELY(!label.CheckSizeInt32())) {
          THROW_ERR_OUT_OF_RANGE(env, ""label is too big"");
          return Nothing<bool>();
        }
        params->label = label.ToCopy();
      }
      break;
    }",31,,314,3,,void
53207,BLOCK,-1,,"{
        THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *digest);
        return Nothing<bool>();
      }",38,,319,2,,void
53222,BLOCK,-1,,"{
        ArrayBufferOrViewContents<char> label(args[offset + 2]);
        if (UNLIKELY(!label.CheckSizeInt32())) {
          THROW_ERR_OUT_OF_RANGE(env, ""label is too big"");
          return Nothing<bool>();
        }
        params->label = label.ToCopy();
      }",46,,324,2,,void
53237,BLOCK,-1,,"{
          THROW_ERR_OUT_OF_RANGE(env, ""label is too big"");
          return Nothing<bool>();
        }",48,,326,2,,void
53269,BLOCK,-1,,"{
  switch (cipher_mode) {
    case kWebCryptoCipherEncrypt:
      CHECK_EQ(key_data->GetKeyType(), kKeyTypePublic);
      return RSA_Cipher<EVP_PKEY_encrypt_init, EVP_PKEY_encrypt>(
          env, key_data.get(), params, in, out);
    case kWebCryptoCipherDecrypt:
      CHECK_EQ(key_data->GetKeyType(), kKeyTypePrivate);
      return RSA_Cipher<EVP_PKEY_decrypt_init, EVP_PKEY_decrypt>(
          env, key_data.get(), params, in, out);
  }
  return WebCryptoCipherStatus::FAILED;
}",22,,348,7,,void
53272,BLOCK,-1,,"{
    case kWebCryptoCipherEncrypt:
      CHECK_EQ(key_data->GetKeyType(), kKeyTypePublic);
      return RSA_Cipher<EVP_PKEY_encrypt_init, EVP_PKEY_encrypt>(
          env, key_data.get(), params, in, out);
    case kWebCryptoCipherDecrypt:
      CHECK_EQ(key_data->GetKeyType(), kKeyTypePrivate);
      return RSA_Cipher<EVP_PKEY_decrypt_init, EVP_PKEY_decrypt>(
          env, key_data.get(), params, in, out);
  }",24,,349,2,,void
53319,BLOCK,-1,,"{
  ManagedEVPPKey m_pkey = key->GetAsymmetricKey();
  Mutex::ScopedLock lock(*m_pkey.mutex());
  int type = EVP_PKEY_id(m_pkey.get());
  CHECK(type == EVP_PKEY_RSA || type == EVP_PKEY_RSA_PSS);

  // TODO(tniessen): Remove the ""else"" branch once we drop support for OpenSSL
  // versions older than 1.1.1e via FIPS / dynamic linking.
  const RSA* rsa;
  if (OpenSSL_version_num() >= 0x1010105fL) {
    rsa = EVP_PKEY_get0_RSA(m_pkey.get());
  } else {
    rsa = static_cast<const RSA*>(EVP_PKEY_get0(m_pkey.get()));
  }
  CHECK_NOT_NULL(rsa);

  const BIGNUM* n;
  const BIGNUM* e;
  const BIGNUM* d;
  const BIGNUM* p;
  const BIGNUM* q;
  const BIGNUM* dp;
  const BIGNUM* dq;
  const BIGNUM* qi;
  RSA_get0_key(rsa, &n, &e, &d);

  if (target->Set(
          env->context(),
          env->jwk_kty_string(),
          env->jwk_rsa_string()).IsNothing()) {
    return Nothing<bool>();
  }

  if (SetEncodedValue(env, target, env->jwk_n_string(), n).IsNothing() ||
      SetEncodedValue(env, tar...",27,,365,4,,void
53355,BLOCK,-1,,"{
    rsa = EVP_PKEY_get0_RSA(m_pkey.get());
  }",45,,374,2,,void
53364,BLOCK,-1,,"{
    rsa = static_cast<const RSA*>(EVP_PKEY_get0(m_pkey.get()));
  }",10,,376,1,,void
53412,BLOCK,-1,,"{
    return Nothing<bool>();
  }",47,,394,2,,void
53439,BLOCK,-1,,"{
    return Nothing<bool>();
  }",73,,399,2,,void
53449,BLOCK,-1,,"{
    RSA_get0_factors(rsa, &p, &q);
    RSA_get0_crt_params(rsa, &dp, &dq, &qi);
    if (SetEncodedValue(env, target, env->jwk_d_string(), d).IsNothing() ||
        SetEncodedValue(env, target, env->jwk_p_string(), p).IsNothing() ||
        SetEncodedValue(env, target, env->jwk_q_string(), q).IsNothing() ||
        SetEncodedValue(env, target, env->jwk_dp_string(), dp).IsNothing() ||
        SetEncodedValue(env, target, env->jwk_dq_string(), dq).IsNothing() ||
        SetEncodedValue(env, target, env->jwk_qi_string(), qi).IsNothing()) {
      return Nothing<bool>();
    }
  }",45,,403,2,,void
53536,BLOCK,-1,,"{
      return Nothing<bool>();
    }",77,,411,2,,void
53549,BLOCK,-1,,"{
  Local<Value> n_value;
  Local<Value> e_value;
  Local<Value> d_value;

  if (!jwk->Get(env->context(), env->jwk_n_string()).ToLocal(&n_value) ||
      !jwk->Get(env->context(), env->jwk_e_string()).ToLocal(&e_value) ||
      !jwk->Get(env->context(), env->jwk_d_string()).ToLocal(&d_value) ||
      !n_value->IsString() ||
      !e_value->IsString()) {
    THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK RSA key"");
    return std::shared_ptr<KeyObjectData>();
  }

  if (!d_value->IsUndefined() && !d_value->IsString()) {
    THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK RSA key"");
    return std::shared_ptr<KeyObjectData>();
  }

  KeyType type = d_value->IsString() ? kKeyTypePrivate : kKeyTypePublic;

  RsaPointer rsa(RSA_new());

  ByteSource n = ByteSource::FromEncodedString(env, n_value.As<String>());
  ByteSource e = ByteSource::FromEncodedString(env, e_value.As<String>());

  if (!RSA_set0_key(
          rsa.get(),
          n.ToBN().release(),
          e.ToBN().release(),
  ...",26,,423,5,,void
53634,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK RSA key"");
    return std::shared_ptr<KeyObjectData>();
  }",29,,432,2,,void
53655,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK RSA key"");
    return std::shared_ptr<KeyObjectData>();
  }",56,,437,2,,void
53723,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK RSA key"");
    return std::shared_ptr<KeyObjectData>();
  }",21,,453,2,,void
53736,BLOCK,-1,,"{
    Local<Value> p_value;
    Local<Value> q_value;
    Local<Value> dp_value;
    Local<Value> dq_value;
    Local<Value> qi_value;

    if (!jwk->Get(env->context(), env->jwk_p_string()).ToLocal(&p_value) ||
        !jwk->Get(env->context(), env->jwk_q_string()).ToLocal(&q_value) ||
        !jwk->Get(env->context(), env->jwk_dp_string()).ToLocal(&dp_value) ||
        !jwk->Get(env->context(), env->jwk_dq_string()).ToLocal(&dq_value) ||
        !jwk->Get(env->context(), env->jwk_qi_string()).ToLocal(&qi_value)) {
      THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK RSA key"");
      return std::shared_ptr<KeyObjectData>();
    }

    if (!p_value->IsString() ||
        !q_value->IsString() ||
        !dp_value->IsString() ||
        !dq_value->IsString() ||
        !qi_value->IsString()) {
      THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK RSA key"");
      return std::shared_ptr<KeyObjectData>();
    }

    ByteSource d = ByteSource::FromEncodedString(env, d_value.As<String>());...",32,,458,2,,void
53857,BLOCK,-1,,"{
      THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK RSA key"");
      return std::shared_ptr<KeyObjectData>();
    }",77,,469,2,,void
53896,BLOCK,-1,,"{
      THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK RSA key"");
      return std::shared_ptr<KeyObjectData>();
    }",32,,478,2,,void
54042,BLOCK,-1,,"{
      THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK RSA key"");
      return std::shared_ptr<KeyObjectData>();
    }",35,,496,2,,void
54083,BLOCK,-1,,"{
  const BIGNUM* e;  // Public Exponent
  const BIGNUM* n;  // Modulus

  ManagedEVPPKey m_pkey = key->GetAsymmetricKey();
  Mutex::ScopedLock lock(*m_pkey.mutex());
  int type = EVP_PKEY_id(m_pkey.get());
  CHECK(type == EVP_PKEY_RSA || type == EVP_PKEY_RSA_PSS);

  // TODO(tniessen): Remove the ""else"" branch once we drop support for OpenSSL
  // versions older than 1.1.1e via FIPS / dynamic linking.
  const RSA* rsa;
  if (OpenSSL_version_num() >= 0x1010105fL) {
    rsa = EVP_PKEY_get0_RSA(m_pkey.get());
  } else {
    rsa = static_cast<const RSA*>(EVP_PKEY_get0(m_pkey.get()));
  }
  CHECK_NOT_NULL(rsa);

  RSA_get0_key(rsa, &n, &e, nullptr);

  size_t modulus_length = BN_num_bits(n);

  if (target
          ->Set(
              env->context(),
              env->modulus_length_string(),
              Number::New(env->isolate(), static_cast<double>(modulus_length)))
          .IsNothing()) {
    return Nothing<bool>();
  }

  std::unique_ptr<BackingStore> public_exponent;
  {
   ...",27,,511,4,,void
54121,BLOCK,-1,,"{
    rsa = EVP_PKEY_get0_RSA(m_pkey.get());
  }",45,,523,2,,void
54130,BLOCK,-1,,"{
    rsa = static_cast<const RSA*>(EVP_PKEY_get0(m_pkey.get()));
  }",10,,525,1,,void
54181,BLOCK,-1,,"{
    return Nothing<bool>();
  }",25,,539,2,,void
54191,BLOCK,18,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    public_exponent =
        ArrayBuffer::NewBackingStore(env->isolate(), BN_num_bytes(e));
  }",3,,544,18,,void
54258,BLOCK,-1,,"{
    return Nothing<bool>();
  }",25,,558,2,,void
54265,BLOCK,-1,,"{
    // Due to the way ASN.1 encoding works, default values are omitted when
    // encoding the data structure. However, there are also RSA-PSS keys for
    // which no parameters are set. In that case, the ASN.1 RSASSA-PSS-params
    // sequence will be missing entirely and RSA_get0_pss_params will return
    // nullptr. If parameters are present but all parameters are set to their
    // default values, an empty sequence will be stored in the ASN.1 structure.
    // In that case, RSA_get0_pss_params does not return nullptr but all fields
    // of the returned RSA_PSS_PARAMS will be set to nullptr.

    const RSA_PSS_PARAMS* params = RSA_get0_pss_params(rsa);
    if (params != nullptr) {
      int hash_nid = NID_sha1;
      int mgf_nid = NID_mgf1;
      int mgf1_hash_nid = NID_sha1;
      int64_t salt_length = 20;

      if (params->hashAlgorithm != nullptr) {
        hash_nid = OBJ_obj2nid(params->hashAlgorithm->algorithm);
      }

      if (target
              ->Set(
       ...",33,,562,2,,void
54275,BLOCK,-1,,"{
      int hash_nid = NID_sha1;
      int mgf_nid = NID_mgf1;
      int mgf1_hash_nid = NID_sha1;
      int64_t salt_length = 20;

      if (params->hashAlgorithm != nullptr) {
        hash_nid = OBJ_obj2nid(params->hashAlgorithm->algorithm);
      }

      if (target
              ->Set(
                  env->context(),
                  env->hash_algorithm_string(),
                  OneByteString(env->isolate(), OBJ_nid2ln(hash_nid)))
              .IsNothing()) {
        return Nothing<bool>();
      }

      if (params->maskGenAlgorithm != nullptr) {
        mgf_nid = OBJ_obj2nid(params->maskGenAlgorithm->algorithm);
        if (mgf_nid == NID_mgf1) {
          mgf1_hash_nid = OBJ_obj2nid(params->maskHash->algorithm);
        }
      }

      // If, for some reason, the MGF is not MGF1, then the MGF1 hash function
      // is intentionally not added to the object.
      if (mgf_nid == NID_mgf1) {
        if (target
                ->Set(
                    env->context(),
  ...",28,,573,2,,void
54298,BLOCK,-1,,"{
        hash_nid = OBJ_obj2nid(params->hashAlgorithm->algorithm);
      }",45,,579,2,,void
54330,BLOCK,-1,,"{
        return Nothing<bool>();
      }",29,,588,2,,void
54339,BLOCK,-1,,"{
        mgf_nid = OBJ_obj2nid(params->maskGenAlgorithm->algorithm);
        if (mgf_nid == NID_mgf1) {
          mgf1_hash_nid = OBJ_obj2nid(params->maskHash->algorithm);
        }
      }",48,,592,2,,void
54352,BLOCK,-1,,"{
          mgf1_hash_nid = OBJ_obj2nid(params->maskHash->algorithm);
        }",34,,594,2,,void
54365,BLOCK,-1,,"{
        if (target
                ->Set(
                    env->context(),
                    env->mgf1_hash_algorithm_string(),
                    OneByteString(env->isolate(), OBJ_nid2ln(mgf1_hash_nid)))
                .IsNothing()) {
          return Nothing<bool>();
        }
      }",32,,601,2,,void
54389,BLOCK,-1,,"{
          return Nothing<bool>();
        }",31,,607,2,,void
54398,BLOCK,-1,,"{
        if (ASN1_INTEGER_get_int64(&salt_length, params->saltLength) != 1) {
          ThrowCryptoError(env, ERR_get_error(), ""ASN1_INTEGER_get_in64 error"");
          return Nothing<bool>();
        }
      }",42,,612,2,,void
54408,BLOCK,-1,,"{
          ThrowCryptoError(env, ERR_get_error(), ""ASN1_INTEGER_get_in64 error"");
          return Nothing<bool>();
        }",76,,613,2,,void
54442,BLOCK,-1,,"{
        return Nothing<bool>();
      }",29,,624,2,,void
54454,BLOCK,-1,,"{
  RSAKeyPairGenJob::Initialize(env, target);
  RSAKeyExportJob::Initialize(env, target);
  RSACipherJob::Initialize(env, target);

  NODE_DEFINE_CONSTANT(target, kKeyVariantRSA_SSA_PKCS1_v1_5);
  NODE_DEFINE_CONSTANT(target, kKeyVariantRSA_PSS);
  NODE_DEFINE_CONSTANT(target, kKeyVariantRSA_OAEP);
}",57,,634,3,,void
54486,BLOCK,-1,,"{
  RSAKeyPairGenJob::RegisterExternalReferences(registry);
  RSAKeyExportJob::RegisterExternalReferences(registry);
  RSACipherJob::RegisterExternalReferences(registry);
}",70,,644,2,,void
54522,BLOCK,-1,,<empty>,1,,1,1,,ANY
54543,BLOCK,-1,,<empty>,1,,1,1,,ANY
54548,BLOCK,-1,,<empty>,26,,31,2,,void
54553,BLOCK,-1,,"{
  if (&other == this) return *this;
  this->~ScryptConfig();
  return *new (this) ScryptConfig(std::move(other));
}",70,,33,2,,void
54559,BLOCK,-1,,<empty>,23,,34,2,,void
54581,BLOCK,-1,,"{
  if (mode == kCryptoJobAsync) {
    tracker->TrackFieldWithSize(""pass"", pass.size());
    tracker->TrackFieldWithSize(""salt"", salt.size());
  }
}",61,,39,2,,void
54586,BLOCK,-1,,"{
    tracker->TrackFieldWithSize(""pass"", pass.size());
    tracker->TrackFieldWithSize(""salt"", salt.size());
  }",32,,40,2,,void
54612,BLOCK,-1,,"{
  *result = out->ToArrayBuffer(env);
  return Just(!result->IsEmpty());
}",35,,50,5,,void
54635,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  params->mode = mode;

  ArrayBufferOrViewContents<char> pass(args[offset]);
  ArrayBufferOrViewContents<char> salt(args[offset + 1]);

  if (UNLIKELY(!pass.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(env, ""pass is too large"");
    return Nothing<bool>();
  }

  if (UNLIKELY(!salt.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(env, ""salt is too large"");
    return Nothing<bool>();
  }

  params->pass = mode == kCryptoJobAsync
      ? pass.ToCopy()
      : pass.ToByteSource();

  params->salt = mode == kCryptoJobAsync
      ? salt.ToCopy()
      : salt.ToByteSource();

  CHECK(args[offset + 2]->IsUint32());  // N
  CHECK(args[offset + 3]->IsUint32());  // r
  CHECK(args[offset + 4]->IsUint32());  // p
  CHECK(args[offset + 5]->IsNumber());  // maxmem
  CHECK(args[offset + 6]->IsInt32());  // length

  params->N = args[offset + 2].As<Uint32>()->Value();
  params->r = args[offset + 3].As<Uint32>()->Value();
  params->p = args...",27,,59,5,,void
54668,BLOCK,-1,,"{
    THROW_ERR_OUT_OF_RANGE(env, ""pass is too large"");
    return Nothing<bool>();
  }",41,,67,2,,void
54681,BLOCK,-1,,"{
    THROW_ERR_OUT_OF_RANGE(env, ""salt is too large"");
    return Nothing<bool>();
  }",41,,72,2,,void
54850,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_INVALID_SCRYPT_PARAMS(env);
    return Nothing<bool>();
  }",20,,106,2,,void
54884,BLOCK,-1,,"{
  ByteSource::Builder buf(params.length);

  // Both the pass and salt may be zero-length at this point

  if (!EVP_PBE_scrypt(params.pass.data<char>(),
                      params.pass.size(),
                      params.salt.data<unsigned char>(),
                      params.salt.size(),
                      params.N,
                      params.r,
                      params.p,
                      params.maxmem,
                      buf.data<unsigned char>(),
                      params.length)) {
    return false;
  }
  *out = std::move(buf).release();
  return true;
}",22,,120,4,,void
54936,BLOCK,-1,,"{
    return false;
  }",39,,134,2,,void
54966,BLOCK,-1,,<empty>,1,,1,1,,ANY
54973,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(args);
    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");
    Error err = sign->Update(data, size);
    crypto::CheckThrow(sign->env(), err);
  }",56,,377,5,,void
54987,BLOCK,-1,,<empty>,7,,380,2,,void
55020,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(args);
    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");
    Error err = verify->Update(data, size);
    crypto::CheckThrow(verify->env(), err);
  }",58,,494,5,,void
55034,BLOCK,-1,,<empty>,7,,497,2,,void
55083,BLOCK,-1,,<empty>,1,,1,1,,ANY
55089,BLOCK,-1,,"{
  /* Validate DSA2 parameters from FIPS 186-4 */
#if OPENSSL_VERSION_MAJOR >= 3
  if (EVP_default_properties_is_fips_enabled(nullptr) &&
      EVP_PKEY_DSA == EVP_PKEY_base_id(key)) {
#else
  if (FIPS_mode() && EVP_PKEY_DSA == EVP_PKEY_base_id(key)) {
#endif
    const DSA* dsa = EVP_PKEY_get0_DSA(key);
    const BIGNUM* p;
    DSA_get0_pqg(dsa, &p, nullptr, nullptr);
    size_t L = BN_num_bits(p);
    const BIGNUM* q;
    DSA_get0_pqg(dsa, nullptr, &q, nullptr);
    size_t N = BN_num_bits(q);

    return (L == 1024 && N == 160) ||
           (L == 2048 && N == 224) ||
           (L == 2048 && N == 256) ||
           (L == 3072 && N == 256);
  }

  return true;
}",43,,32,2,,void
55097,BLOCK,-1,,"{
#endif
    const DSA* dsa = EVP_PKEY_get0_DSA(key);
    const BIGNUM* p;
    DSA_get0_pqg(dsa, &p, nullptr, nullptr);
    size_t L = BN_num_bits(p);
    const BIGNUM* q;
    DSA_get0_pqg(dsa, nullptr, &q, nullptr);
    size_t N = BN_num_bits(q);

    return (L == 1024 && N == 160) ||
           (L == 2048 && N == 224) ||
           (L == 2048 && N == 256) ||
           (L == 3072 && N == 256);
  }",61,,38,2,,void
55168,BLOCK,-1,,"{
  if (EVP_PKEY_id(pkey.get()) == EVP_PKEY_RSA ||
      EVP_PKEY_id(pkey.get()) == EVP_PKEY_RSA2 ||
      EVP_PKEY_id(pkey.get()) == EVP_PKEY_RSA_PSS) {
    if (EVP_PKEY_CTX_set_rsa_padding(pkctx, padding) <= 0)
      return false;
    if (padding == RSA_PKCS1_PSS_PADDING && salt_len.IsJust()) {
      if (EVP_PKEY_CTX_set_rsa_pss_saltlen(pkctx, salt_len.FromJust()) <= 0)
        return false;
    }
  }

  return true;
}",50,,60,5,,void
55193,BLOCK,-1,,"{
    if (EVP_PKEY_CTX_set_rsa_padding(pkctx, padding) <= 0)
      return false;
    if (padding == RSA_PKCS1_PSS_PADDING && salt_len.IsJust()) {
      if (EVP_PKEY_CTX_set_rsa_pss_saltlen(pkctx, salt_len.FromJust()) <= 0)
        return false;
    }
  }",52,,63,2,,void
55200,BLOCK,-1,,<empty>,7,,65,2,,void
55212,BLOCK,-1,,"{
      if (EVP_PKEY_CTX_set_rsa_pss_saltlen(pkctx, salt_len.FromJust()) <= 0)
        return false;
    }",64,,66,2,,void
55222,BLOCK,-1,,<empty>,9,,68,2,,void
55235,BLOCK,-1,,"{
  unsigned char m[EVP_MAX_MD_SIZE];
  unsigned int m_len;

  if (!EVP_DigestFinal_ex(mdctx.get(), m, &m_len))
    return nullptr;

  int signed_sig_len = EVP_PKEY_size(pkey.get());
  CHECK_GE(signed_sig_len, 0);
  size_t sig_len = static_cast<size_t>(signed_sig_len);
  std::unique_ptr<BackingStore> sig;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    sig = ArrayBuffer::NewBackingStore(env->isolate(), sig_len);
  }
  EVPKeyCtxPointer pkctx(EVP_PKEY_CTX_new(pkey.get(), nullptr));
  if (pkctx &&
      EVP_PKEY_sign_init(pkctx.get()) &&
      ApplyRSAOptions(pkey, pkctx.get(), padding, pss_salt_len) &&
      EVP_PKEY_CTX_set_signature_md(pkctx.get(), EVP_MD_CTX_md(mdctx.get())) &&
      EVP_PKEY_sign(pkctx.get(), static_cast<unsigned char*>(sig->Data()),
                    &sig_len, m, m_len)) {
    CHECK_LE(sig_len, sig->ByteLength());
    if (sig_len == 0)
      sig = ArrayBuffer::NewBackingStore(env->isolate(), 0);
    else
      sig = BackingStore:...",71,,79,6,,void
55248,BLOCK,-1,,<empty>,5,,84,2,,void
55275,BLOCK,10,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    sig = ArrayBuffer::NewBackingStore(env->isolate(), sig_len);
  }",3,,90,10,,void
55345,BLOCK,-1,,"{
    CHECK_LE(sig_len, sig->ByteLength());
    if (sig_len == 0)
      sig = ArrayBuffer::NewBackingStore(env->isolate(), 0);
    else
      sig = BackingStore::Reallocate(env->isolate(), std::move(sig), sig_len);
    return sig;
  }",42,,100,2,,void
55356,BLOCK,-1,,<empty>,7,,103,2,,void
55369,BLOCK,-1,,<empty>,7,,105,1,,void
55394,BLOCK,-1,,"{
  return EVP_PKEY_id(m_pkey.get()) == EVP_PKEY_RSA_PSS ? RSA_PKCS1_PSS_PADDING :
                                                         RSA_PKCS1_PADDING;
}",57,,112,2,,void
55410,BLOCK,-1,,"{
  int bits, base_id = EVP_PKEY_base_id(pkey.get());

  if (base_id == EVP_PKEY_DSA) {
    const DSA* dsa_key = EVP_PKEY_get0_DSA(pkey.get());
    // Both r and s are computed mod q, so their width is limited by that of q.
    bits = BN_num_bits(DSA_get0_q(dsa_key));
  } else if (base_id == EVP_PKEY_EC) {
    const EC_KEY* ec_key = EVP_PKEY_get0_EC_KEY(pkey.get());
    const EC_GROUP* ec_group = EC_KEY_get0_group(ec_key);
    bits = EC_GROUP_order_bits(ec_group);
  } else {
    return kNoDsaSignature;
  }

  return (bits + 7) / 8;
}",55,,117,2,,void
55424,BLOCK,-1,,"{
    const DSA* dsa_key = EVP_PKEY_get0_DSA(pkey.get());
    // Both r and s are computed mod q, so their width is limited by that of q.
    bits = BN_num_bits(DSA_get0_q(dsa_key));
  }",32,,120,2,,void
55439,BLOCK,-1,,<empty>,10,,124,1,,void
55444,BLOCK,-1,,"{
    const EC_KEY* ec_key = EVP_PKEY_get0_EC_KEY(pkey.get());
    const EC_GROUP* ec_group = EC_KEY_get0_group(ec_key);
    bits = EC_GROUP_order_bits(ec_group);
  }",38,,124,2,,void
55463,BLOCK,-1,,"{
    return kNoDsaSignature;
  }",10,,128,1,,void
55479,BLOCK,-1,,"{
  ECDSASigPointer asn1_sig(d2i_ECDSA_SIG(nullptr, &sig_data, len));
  if (!asn1_sig)
    return false;

  const BIGNUM* pr = ECDSA_SIG_get0_r(asn1_sig.get());
  const BIGNUM* ps = ECDSA_SIG_get0_s(asn1_sig.get());

  return BN_bn2binpad(pr, out, n) > 0 && BN_bn2binpad(ps, out + n, n) > 0;
}",15,,139,5,,void
55490,BLOCK,-1,,<empty>,5,,142,2,,void
55531,BLOCK,-1,,"{
  unsigned int n = GetBytesOfRS(pkey);
  if (n == kNoDsaSignature)
    return std::move(signature);

  std::unique_ptr<BackingStore> buf;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    buf = ArrayBuffer::NewBackingStore(env->isolate(), 2 * n);
  }
  if (!ExtractP1363(static_cast<unsigned char*>(signature->Data()),
                    static_cast<unsigned char*>(buf->Data()),
                    signature->ByteLength(), n))
    return std::move(signature);

  return buf;
}",76,,152,4,,void
55541,BLOCK,-1,,<empty>,5,,155,2,,void
55555,BLOCK,5,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    buf = ArrayBuffer::NewBackingStore(env->isolate(), 2 * n);
  }",3,,158,5,,void
55595,BLOCK,-1,,<empty>,5,,165,2,,void
55610,BLOCK,-1,,"{
  unsigned int n = GetBytesOfRS(pkey);
  if (n == kNoDsaSignature)
    return ByteSource();

  const unsigned char* sig_data = signature.data<unsigned char>();

  ByteSource::Builder out(n * 2);
  memset(out.data<void>(), 0, n * 2);

  if (!ExtractP1363(sig_data, out.data<unsigned char>(), signature.size(), n))
    return ByteSource();

  return std::move(out).release();
}",34,,174,4,,void
55620,BLOCK,-1,,<empty>,5,,177,2,,void
55657,BLOCK,-1,,<empty>,5,,185,2,,void
55674,BLOCK,-1,,"{
  unsigned int n = GetBytesOfRS(pkey);
  if (n == kNoDsaSignature)
    return std::move(out);

  const unsigned char* sig_data = out.data<unsigned char>();

  if (out.size() != 2 * n)
    return ByteSource();

  ECDSASigPointer asn1_sig(ECDSA_SIG_new());
  CHECK(asn1_sig);
  BIGNUM* r = BN_new();
  CHECK_NOT_NULL(r);
  BIGNUM* s = BN_new();
  CHECK_NOT_NULL(s);
  CHECK_EQ(r, BN_bin2bn(sig_data, n, r));
  CHECK_EQ(s, BN_bin2bn(sig_data + n, n, s));
  CHECK_EQ(1, ECDSA_SIG_set0(asn1_sig.get(), r, s));

  unsigned char* data = nullptr;
  int len = i2d_ECDSA_SIG(asn1_sig.get(), &data);

  if (len <= 0)
    return ByteSource();

  CHECK_NOT_NULL(data);

  return ByteSource::Allocated(data, len);
}",25,,192,3,,void
55684,BLOCK,-1,,<empty>,5,,195,2,,void
55707,BLOCK,-1,,<empty>,5,,200,2,,void
55768,BLOCK,-1,,<empty>,5,,216,2,,void
55785,BLOCK,-1,,"{
  HandleScope scope(env->isolate());

  switch (error) {
    case SignBase::Error::kSignUnknownDigest:
      return THROW_ERR_CRYPTO_INVALID_DIGEST(env);

    case SignBase::Error::kSignNotInitialised:
      return THROW_ERR_CRYPTO_INVALID_STATE(env, ""Not initialised"");

    case SignBase::Error::kSignMalformedSignature:
      return THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""Malformed signature"");

    case SignBase::Error::kSignInit:
    case SignBase::Error::kSignUpdate:
    case SignBase::Error::kSignPrivateKey:
    case SignBase::Error::kSignPublicKey:
      {
        unsigned long err = ERR_get_error();  // NOLINT(runtime/int)
        if (err)
          return ThrowCryptoError(env, err);
        switch (error) {
          case SignBase::Error::kSignInit:
            return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
                ""EVP_SignInit_ex failed"");
          case SignBase::Error::kSignUpdate:
            return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
                ""EVP_Si...",58,,223,3,,void
55794,BLOCK,-1,,"{
    case SignBase::Error::kSignUnknownDigest:
      return THROW_ERR_CRYPTO_INVALID_DIGEST(env);

    case SignBase::Error::kSignNotInitialised:
      return THROW_ERR_CRYPTO_INVALID_STATE(env, ""Not initialised"");

    case SignBase::Error::kSignMalformedSignature:
      return THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""Malformed signature"");

    case SignBase::Error::kSignInit:
    case SignBase::Error::kSignUpdate:
    case SignBase::Error::kSignPrivateKey:
    case SignBase::Error::kSignPublicKey:
      {
        unsigned long err = ERR_get_error();  // NOLINT(runtime/int)
        if (err)
          return ThrowCryptoError(env, err);
        switch (error) {
          case SignBase::Error::kSignInit:
            return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
                ""EVP_SignInit_ex failed"");
          case SignBase::Error::kSignUpdate:
            return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
                ""EVP_SignUpdate failed"");
          case SignBase::Error::kSignP...",18,,226,2,,void
55848,BLOCK,18,,"{
        unsigned long err = ERR_get_error();  // NOLINT(runtime/int)
        if (err)
          return ThrowCryptoError(env, err);
        switch (error) {
          case SignBase::Error::kSignInit:
            return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
                ""EVP_SignInit_ex failed"");
          case SignBase::Error::kSignUpdate:
            return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
                ""EVP_SignUpdate failed"");
          case SignBase::Error::kSignPrivateKey:
            return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
                ""PEM_read_bio_PrivateKey failed"");
          case SignBase::Error::kSignPublicKey:
            return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
                ""PEM_read_bio_PUBKEY failed"");
          default:
            ABORT();
        }
      }",7,,240,18,,void
55855,BLOCK,-1,,<empty>,11,,243,2,,void
55862,BLOCK,-1,,"{
          case SignBase::Error::kSignInit:
            return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
                ""EVP_SignInit_ex failed"");
          case SignBase::Error::kSignUpdate:
            return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
                ""EVP_SignUpdate failed"");
          case SignBase::Error::kSignPrivateKey:
            return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
                ""PEM_read_bio_PrivateKey failed"");
          case SignBase::Error::kSignPublicKey:
            return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
                ""PEM_read_bio_PUBKEY failed"");
          default:
            ABORT();
        }",24,,244,2,,void
55916,BLOCK,-1,,"{
  switch (EVP_PKEY_id(key.get())) {
    case EVP_PKEY_ED25519:
    case EVP_PKEY_ED448:
      return true;
    default:
      return false;
  }
}",43,,267,2,,void
55923,BLOCK,-1,,"{
    case EVP_PKEY_ED25519:
    case EVP_PKEY_ED448:
      return true;
    default:
      return false;
  }",35,,268,2,,void
55938,BLOCK,-1,,"{
  switch (EVP_PKEY_id(key.get())) {
    case EVP_PKEY_EC:
    case EVP_PKEY_DSA:
      return dsa_encoding == kSigEncP1363;
    default:
      return false;
  }
}",54,,278,3,,void
55945,BLOCK,-1,,"{
    case EVP_PKEY_EC:
    case EVP_PKEY_DSA:
      return dsa_encoding == kSigEncP1363;
    default:
      return false;
  }",35,,279,2,,void
55961,BLOCK,-1,,"{
  CHECK_NULL(mdctx_);
  // Historically, ""dss1"" and ""DSS1"" were DSA aliases for SHA-1
  // exposed through the public API.
  if (strcmp(sign_type, ""dss1"") == 0 ||
      strcmp(sign_type, ""DSS1"") == 0) {
    sign_type = ""SHA1"";
  }
  const EVP_MD* md = EVP_get_digestbyname(sign_type);
  if (md == nullptr)
    return kSignUnknownDigest;

  mdctx_.reset(EVP_MD_CTX_new());
  if (!mdctx_ || !EVP_DigestInit_ex(mdctx_.get(), md, nullptr)) {
    mdctx_.reset();
    return kSignInit;
  }

  return kSignOk;
}",55,,289,2,,void
55975,BLOCK,-1,,"{
    sign_type = ""SHA1"";
  }",39,,294,2,,void
55988,BLOCK,-1,,<empty>,5,,299,2,,void
56008,BLOCK,-1,,"{
    mdctx_.reset();
    return kSignInit;
  }",65,,302,2,,void
56022,BLOCK,-1,,"{
  if (mdctx_ == nullptr)
    return kSignNotInitialised;
  if (!EVP_DigestUpdate(mdctx_.get(), data, len))
    return kSignUpdate;
  return kSignOk;
}",64,,310,3,,void
56027,BLOCK,-1,,<empty>,5,,312,2,,void
56039,BLOCK,-1,,<empty>,5,,314,2,,void
56049,BLOCK,-1,,<empty>,29,,319,3,,void
56054,BLOCK,-1,,"{
  tracker->TrackFieldWithSize(""mdctx"", mdctx_ ? kSizeOf_EVP_MD_CTX : 0);
}",57,,321,2,,void
56069,BLOCK,-1,,"{
  MakeWeak();
}",72,,325,3,,void
56076,BLOCK,-1,,"{
  Isolate* isolate = env->isolate();
  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);

  t->InstanceTemplate()->SetInternalFieldCount(SignBase::kInternalFieldCount);

  SetProtoMethod(isolate, t, ""init"", SignInit);
  SetProtoMethod(isolate, t, ""update"", SignUpdate);
  SetProtoMethod(isolate, t, ""sign"", SignFinal);

  SetConstructorFunction(env->context(), target, ""Sign"", t);

  SignJob::Initialize(env, target);

  constexpr int kSignJobModeSign = SignConfiguration::kSign;
  constexpr int kSignJobModeVerify = SignConfiguration::kVerify;

  NODE_DEFINE_CONSTANT(target, kSignJobModeSign);
  NODE_DEFINE_CONSTANT(target, kSignJobModeVerify);
  NODE_DEFINE_CONSTANT(target, kSigEncDER);
  NODE_DEFINE_CONSTANT(target, kSigEncP1363);
  NODE_DEFINE_CONSTANT(target, RSA_PKCS1_PSS_PADDING);
}",63,,329,3,,void
56163,BLOCK,-1,,"{
  registry->Register(New);
  registry->Register(SignInit);
  registry->Register(SignUpdate);
  registry->Register(SignFinal);
  SignJob::RegisterExternalReferences(registry);
}",76,,353,2,,void
56193,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  new Sign(env, args.This());
}",57,,361,2,,void
56213,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Sign* sign;
  ASSIGN_OR_RETURN_UNWRAP(&sign, args.Holder());

  const node::Utf8Value sign_type(args.GetIsolate(), args[0]);
  crypto::CheckThrow(env, sign->Init(*sign_type));
}",62,,366,2,,void
56253,BLOCK,-1,,"{
  Decode<Sign>(args, [](Sign* sign, const FunctionCallbackInfo<Value>& args,
                        const char* data, size_t size) {
    Environment* env = Environment::GetCurrent(args);
    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");
    Error err = sign->Update(data, size);
    crypto::CheckThrow(sign->env(), err);
  });
}",64,,375,2,,void
56269,BLOCK,-1,,"{
  if (!mdctx_)
    return SignResult(kSignNotInitialised);

  EVPMDPointer mdctx = std::move(mdctx_);

  if (!ValidateDSAParameters(pkey.get()))
    return SignResult(kSignPrivateKey);

  std::unique_ptr<BackingStore> buffer =
      Node_SignFinal(env(), std::move(mdctx), pkey, padding, salt_len);
  Error error = buffer ? kSignOk : kSignPrivateKey;
  if (error == kSignOk && dsa_sig_enc == kSigEncP1363) {
    buffer = ConvertSignatureToP1363(env(), pkey, std::move(buffer));
    CHECK_NOT_NULL(buffer->Data());
  }
  return SignResult(error, std::move(buffer));
}",28,,390,5,,void
56273,BLOCK,-1,,<empty>,5,,392,2,,void
56292,BLOCK,-1,,<empty>,5,,397,2,,void
56329,BLOCK,-1,,"{
    buffer = ConvertSignatureToP1363(env(), pkey, std::move(buffer));
    CHECK_NOT_NULL(buffer->Data());
  }",56,,402,2,,void
56357,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Sign* sign;
  ASSIGN_OR_RETURN_UNWRAP(&sign, args.Holder());

  ClearErrorOnReturn clear_error_on_return;

  unsigned int offset = 0;
  ManagedEVPPKey key = ManagedEVPPKey::GetPrivateKeyFromJs(args, &offset, true);
  if (!key)
    return;

  int padding = GetDefaultSignPadding(key);
  if (!args[offset]->IsUndefined()) {
    CHECK(args[offset]->IsInt32());
    padding = args[offset].As<Int32>()->Value();
  }

  Maybe<int> salt_len = Nothing<int>();
  if (!args[offset + 1]->IsUndefined()) {
    CHECK(args[offset + 1]->IsInt32());
    salt_len = Just<int>(args[offset + 1].As<Int32>()->Value());
  }

  CHECK(args[offset + 2]->IsInt32());
  DSASigEnc dsa_sig_enc =
      static_cast<DSASigEnc>(args[offset + 2].As<Int32>()->Value());

  SignResult ret = sign->SignFinal(
      key,
      padding,
      salt_len,
      dsa_sig_enc);

  if (ret.error != kSignOk)
    return crypto::CheckThrow(env, ret.error);

  Local<ArrayBuffer> ab =
  ...",63,,409,2,,void
56393,BLOCK,-1,,<empty>,5,,419,2,,void
56408,BLOCK,-1,,"{
    CHECK(args[offset]->IsInt32());
    padding = args[offset].As<Int32>()->Value();
  }",37,,422,2,,void
56441,BLOCK,-1,,"{
    CHECK(args[offset + 1]->IsInt32());
    salt_len = Just<int>(args[offset + 1].As<Int32>()->Value());
  }",41,,428,2,,void
56507,BLOCK,-1,,<empty>,5,,444,2,,void
56565,BLOCK,-1,,"{
  MakeWeak();
}",25,,453,3,,void
56572,BLOCK,-1,,"{
  Isolate* isolate = env->isolate();
  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);

  t->InstanceTemplate()->SetInternalFieldCount(SignBase::kInternalFieldCount);

  SetProtoMethod(isolate, t, ""init"", VerifyInit);
  SetProtoMethod(isolate, t, ""update"", VerifyUpdate);
  SetProtoMethod(isolate, t, ""verify"", VerifyFinal);

  SetConstructorFunction(env->context(), target, ""Verify"", t);
}",65,,457,3,,void
56626,BLOCK,-1,,"{
  registry->Register(New);
  registry->Register(VerifyInit);
  registry->Register(VerifyUpdate);
  registry->Register(VerifyFinal);
}",78,,470,2,,void
56651,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  new Verify(env, args.This());
}",59,,477,2,,void
56671,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Verify* verify;
  ASSIGN_OR_RETURN_UNWRAP(&verify, args.Holder());

  const node::Utf8Value verify_type(args.GetIsolate(), args[0]);
  crypto::CheckThrow(env, verify->Init(*verify_type));
}",66,,482,2,,void
56711,BLOCK,-1,,"{
  Decode<Verify>(args, [](Verify* verify,
                          const FunctionCallbackInfo<Value>& args,
                          const char* data, size_t size) {
    Environment* env = Environment::GetCurrent(args);
    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");
    Error err = verify->Update(data, size);
    crypto::CheckThrow(verify->env(), err);
  });
}",68,,491,2,,void
56728,BLOCK,-1,,"{
  if (!mdctx_)
    return kSignNotInitialised;

  unsigned char m[EVP_MAX_MD_SIZE];
  unsigned int m_len;
  *verify_result = false;
  EVPMDPointer mdctx = std::move(mdctx_);

  if (!EVP_DigestFinal_ex(mdctx.get(), m, &m_len))
    return kSignPublicKey;

  EVPKeyCtxPointer pkctx(EVP_PKEY_CTX_new(pkey.get(), nullptr));
  if (pkctx &&
      EVP_PKEY_verify_init(pkctx.get()) > 0 &&
      ApplyRSAOptions(pkey, pkctx.get(), padding, saltlen) &&
      EVP_PKEY_CTX_set_signature_md(pkctx.get(),
                                    EVP_MD_CTX_md(mdctx.get())) > 0) {
    const unsigned char* s = sig.data<unsigned char>();
    const int r = EVP_PKEY_verify(pkctx.get(), s, sig.size(), m, m_len);
    *verify_result = r == 1;
  }

  return kSignOk;
}",58,,507,6,,void
56732,BLOCK,-1,,<empty>,5,,509,2,,void
56759,BLOCK,-1,,<empty>,5,,517,2,,void
56802,BLOCK,-1,,"{
    const unsigned char* s = sig.data<unsigned char>();
    const int r = EVP_PKEY_verify(pkctx.get(), s, sig.size(), m, m_len);
    *verify_result = r == 1;
  }",70,,524,2,,void
56837,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  ClearErrorOnReturn clear_error_on_return;

  Verify* verify;
  ASSIGN_OR_RETURN_UNWRAP(&verify, args.Holder());

  unsigned int offset = 0;
  ManagedEVPPKey pkey =
      ManagedEVPPKey::GetPublicOrPrivateKeyFromJs(args, &offset);
  if (!pkey)
    return;

  ArrayBufferOrViewContents<char> hbuf(args[offset]);
  if (UNLIKELY(!hbuf.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""buffer is too big"");

  int padding = GetDefaultSignPadding(pkey);
  if (!args[offset + 1]->IsUndefined()) {
    CHECK(args[offset + 1]->IsInt32());
    padding = args[offset + 1].As<Int32>()->Value();
  }

  Maybe<int> salt_len = Nothing<int>();
  if (!args[offset + 2]->IsUndefined()) {
    CHECK(args[offset + 2]->IsInt32());
    salt_len = Just<int>(args[offset + 2].As<Int32>()->Value());
  }

  CHECK(args[offset + 3]->IsInt32());
  DSASigEnc dsa_sig_enc =
      static_cast<DSASigEnc>(args[offset + 3].As<Int32>()->Value());

  ByteSource signa...",67,,533,2,,void
56872,BLOCK,-1,,<empty>,5,,544,2,,void
56886,BLOCK,-1,,<empty>,5,,548,2,,void
56906,BLOCK,-1,,"{
    CHECK(args[offset + 1]->IsInt32());
    padding = args[offset + 1].As<Int32>()->Value();
  }",41,,551,2,,void
56943,BLOCK,-1,,"{
    CHECK(args[offset + 2]->IsInt32());
    salt_len = Just<int>(args[offset + 2].As<Int32>()->Value());
  }",41,,557,2,,void
57003,BLOCK,-1,,"{
    signature = ConvertSignatureToDER(pkey, hbuf.ToByteSource());
    if (signature.data() == nullptr)
      return crypto::CheckThrow(env, Error::kSignMalformedSignature);
  }",36,,567,2,,void
57019,BLOCK,-1,,<empty>,7,,570,2,,void
57047,BLOCK,-1,,<empty>,5,,577,2,,void
57067,BLOCK,-1,,<empty>,40,,591,2,,void
57072,BLOCK,-1,,"{
  if (&other == this) return *this;
  this->~SignConfiguration();
  return *new (this) SignConfiguration(std::move(other));
}",41,,594,2,,void
57078,BLOCK,-1,,<empty>,23,,595,2,,void
57100,BLOCK,-1,,"{
  tracker->TrackField(""key"", key);
  if (job_mode == kCryptoJobAsync) {
    tracker->TrackFieldWithSize(""data"", data.size());
    tracker->TrackFieldWithSize(""signature"", signature.size());
  }
}",66,,600,2,,void
57111,BLOCK,-1,,"{
    tracker->TrackFieldWithSize(""data"", data.size());
    tracker->TrackFieldWithSize(""signature"", signature.size());
  }",36,,602,2,,void
57137,BLOCK,-1,,"{
  ClearErrorOnReturn clear_error_on_return;
  Environment* env = Environment::GetCurrent(args);

  params->job_mode = mode;

  CHECK(args[offset]->IsUint32());  // Sign Mode

  params->mode =
      static_cast<SignConfiguration::Mode>(args[offset].As<Uint32>()->Value());

  ManagedEVPPKey key;
  unsigned int keyParamOffset = offset + 1;
  if (params->mode == SignConfiguration::kVerify) {
    key = ManagedEVPPKey::GetPublicOrPrivateKeyFromJs(args, &keyParamOffset);
  } else {
    key = ManagedEVPPKey::GetPrivateKeyFromJs(args, &keyParamOffset, true);
  }
  if (!key)
    return Nothing<bool>();
  params->key = key;

  ArrayBufferOrViewContents<char> data(args[offset + 5]);
  if (UNLIKELY(!data.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(env, ""data is too big"");
    return Nothing<bool>();
  }
  params->data = mode == kCryptoJobAsync
      ? data.ToCopy()
      : data.ToByteSource();

  if (args[offset + 6]->IsString()) {
    Utf8Value digest(env->isolate(), args[offset + 6]);
  ...",32,,612,5,,void
57189,BLOCK,-1,,"{
    key = ManagedEVPPKey::GetPublicOrPrivateKeyFromJs(args, &keyParamOffset);
  }",51,,625,2,,void
57200,BLOCK,-1,,"{
    key = ManagedEVPPKey::GetPrivateKeyFromJs(args, &keyParamOffset, true);
  }",10,,627,1,,void
57214,BLOCK,-1,,<empty>,5,,631,2,,void
57236,BLOCK,-1,,"{
    THROW_ERR_OUT_OF_RANGE(env, ""data is too big"");
    return Nothing<bool>();
  }",41,,635,2,,void
57267,BLOCK,-1,,"{
    Utf8Value digest(env->isolate(), args[offset + 6]);
    params->digest = EVP_get_digestbyname(*digest);
    if (params->digest == nullptr) {
      THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *digest);
      return Nothing<bool>();
    }
  }",37,,643,2,,void
57292,BLOCK,-1,,"{
      THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *digest);
      return Nothing<bool>();
    }",36,,646,2,,void
57309,BLOCK,-1,,"{  // Salt length
    params->flags |= SignConfiguration::kHasSaltLength;
    params->salt_length = args[offset + 7].As<Int32>()->Value();
  }",36,,652,2,,void
57341,BLOCK,-1,,"{  // Padding
    params->flags |= SignConfiguration::kHasPadding;
    params->padding = args[offset + 8].As<Uint32>()->Value();
  }",37,,656,2,,void
57373,BLOCK,-1,,"{  // DSA Encoding
    params->dsa_encoding =
        static_cast<DSASigEnc>(args[offset + 9].As<Uint32>()->Value());
    if (params->dsa_encoding != kSigEncDER &&
        params->dsa_encoding != kSigEncP1363) {
      THROW_ERR_OUT_OF_RANGE(env, ""invalid signature encoding"");
      return Nothing<bool>();
    }
  }",37,,661,2,,void
57403,BLOCK,-1,,"{
      THROW_ERR_OUT_OF_RANGE(env, ""invalid signature encoding"");
      return Nothing<bool>();
    }",47,,665,2,,void
57417,BLOCK,-1,,"{
    ArrayBufferOrViewContents<char> signature(args[offset + 10]);
    if (UNLIKELY(!signature.CheckSizeInt32())) {
      THROW_ERR_OUT_OF_RANGE(env, ""signature is too big"");
      return Nothing<bool>();
    }
    // If this is an EC key (assuming ECDSA) we need to convert the
    // the signature from WebCrypto format into DER format...
    ManagedEVPPKey m_pkey = params->key;
    Mutex::ScopedLock lock(*m_pkey.mutex());
    if (UseP1363Encoding(m_pkey, params->dsa_encoding)) {
      params->signature =
          ConvertSignatureToDER(m_pkey, signature.ToByteSource());
    } else {
      params->signature = mode == kCryptoJobAsync
          ? signature.ToCopy()
          : signature.ToByteSource();
    }
  }",51,,671,2,,void
57432,BLOCK,-1,,"{
      THROW_ERR_OUT_OF_RANGE(env, ""signature is too big"");
      return Nothing<bool>();
    }",48,,673,2,,void
57457,BLOCK,-1,,"{
      params->signature =
          ConvertSignatureToDER(m_pkey, signature.ToByteSource());
    }",57,,681,2,,void
57469,BLOCK,-1,,"{
      params->signature = mode == kCryptoJobAsync
          ? signature.ToCopy()
          : signature.ToByteSource();
    }",12,,684,1,,void
57495,BLOCK,-1,,"{
  ClearErrorOnReturn clear_error_on_return;
  EVPMDPointer context(EVP_MD_CTX_new());
  EVP_PKEY_CTX* ctx = nullptr;

  switch (params.mode) {
    case SignConfiguration::kSign:
      if (!EVP_DigestSignInit(
              context.get(),
              &ctx,
              params.digest,
              nullptr,
              params.key.get())) {
        crypto::CheckThrow(env, SignBase::Error::kSignInit);
        return false;
      }
      break;
    case SignConfiguration::kVerify:
      if (!EVP_DigestVerifyInit(
              context.get(),
              &ctx,
              params.digest,
              nullptr,
              params.key.get())) {
        crypto::CheckThrow(env, SignBase::Error::kSignInit);
        return false;
      }
      break;
  }

  int padding = params.flags & SignConfiguration::kHasPadding
      ? params.padding
      : GetDefaultSignPadding(params.key);

  Maybe<int> salt_length = params.flags & SignConfiguration::kHasSaltLength
      ? Just<int>(params.s...",22,,697,4,,void
57508,BLOCK,-1,,"{
    case SignConfiguration::kSign:
      if (!EVP_DigestSignInit(
              context.get(),
              &ctx,
              params.digest,
              nullptr,
              params.key.get())) {
        crypto::CheckThrow(env, SignBase::Error::kSignInit);
        return false;
      }
      break;
    case SignConfiguration::kVerify:
      if (!EVP_DigestVerifyInit(
              context.get(),
              &ctx,
              params.digest,
              nullptr,
              params.key.get())) {
        crypto::CheckThrow(env, SignBase::Error::kSignInit);
        return false;
      }
      break;
  }",24,,702,2,,void
57532,BLOCK,-1,,"{
        crypto::CheckThrow(env, SignBase::Error::kSignInit);
        return false;
      }",34,,709,2,,void
57569,BLOCK,-1,,"{
        crypto::CheckThrow(env, SignBase::Error::kSignInit);
        return false;
      }",34,,720,2,,void
57626,BLOCK,-1,,"{
    crypto::CheckThrow(env, SignBase::Error::kSignPrivateKey);
    return false;
  }",25,,738,2,,void
57643,BLOCK,-1,,"{
    case SignConfiguration::kSign: {
      if (IsOneShot(params.key)) {
        size_t len;
        if (!EVP_DigestSign(
            context.get(),
            nullptr,
            &len,
            params.data.data<unsigned char>(),
            params.data.size())) {
          crypto::CheckThrow(env, SignBase::Error::kSignPrivateKey);
          return false;
        }
        ByteSource::Builder buf(len);
        if (!EVP_DigestSign(context.get(),
                            buf.data<unsigned char>(),
                            &len,
                            params.data.data<unsigned char>(),
                            params.data.size())) {
          crypto::CheckThrow(env, SignBase::Error::kSignPrivateKey);
          return false;
        }
        *out = std::move(buf).release(len);
      } else {
        size_t len;
        if (!EVP_DigestSignUpdate(
                context.get(),
                params.data.data<unsigned char>(),
                params.data.size()) ||
 ...",24,,743,2,,void
57648,BLOCK,3,,"{
      if (IsOneShot(params.key)) {
        size_t len;
        if (!EVP_DigestSign(
            context.get(),
            nullptr,
            &len,
            params.data.data<unsigned char>(),
            params.data.size())) {
          crypto::CheckThrow(env, SignBase::Error::kSignPrivateKey);
          return false;
        }
        ByteSource::Builder buf(len);
        if (!EVP_DigestSign(context.get(),
                            buf.data<unsigned char>(),
                            &len,
                            params.data.data<unsigned char>(),
                            params.data.size())) {
          crypto::CheckThrow(env, SignBase::Error::kSignPrivateKey);
          return false;
        }
        *out = std::move(buf).release(len);
      } else {
        size_t len;
        if (!EVP_DigestSignUpdate(
                context.get(),
                params.data.data<unsigned char>(),
                params.data.size()) ||
            !EVP_DigestSignFinal(conte...",36,,744,3,,void
57654,BLOCK,-1,,"{
        size_t len;
        if (!EVP_DigestSign(
            context.get(),
            nullptr,
            &len,
            params.data.data<unsigned char>(),
            params.data.size())) {
          crypto::CheckThrow(env, SignBase::Error::kSignPrivateKey);
          return false;
        }
        ByteSource::Builder buf(len);
        if (!EVP_DigestSign(context.get(),
                            buf.data<unsigned char>(),
                            &len,
                            params.data.data<unsigned char>(),
                            params.data.size())) {
          crypto::CheckThrow(env, SignBase::Error::kSignPrivateKey);
          return false;
        }
        *out = std::move(buf).release(len);
      }",34,,745,2,,void
57678,BLOCK,-1,,"{
          crypto::CheckThrow(env, SignBase::Error::kSignPrivateKey);
          return false;
        }",34,,752,2,,void
57719,BLOCK,-1,,"{
          crypto::CheckThrow(env, SignBase::Error::kSignPrivateKey);
          return false;
        }",50,,761,2,,void
57745,BLOCK,-1,,"{
        size_t len;
        if (!EVP_DigestSignUpdate(
                context.get(),
                params.data.data<unsigned char>(),
                params.data.size()) ||
            !EVP_DigestSignFinal(context.get(), nullptr, &len)) {
          crypto::CheckThrow(env, SignBase::Error::kSignPrivateKey);
          return false;
        }
        ByteSource::Builder buf(len);
        if (!EVP_DigestSignFinal(
                context.get(), buf.data<unsigned char>(), &len)) {
          crypto::CheckThrow(env, SignBase::Error::kSignPrivateKey);
          return false;
        }

        if (UseP1363Encoding(params.key, params.dsa_encoding)) {
          *out = ConvertSignatureToP1363(
              env, params.key, std::move(buf).release());
        } else {
          *out = std::move(buf).release(len);
        }
      }",14,,766,1,,void
57776,BLOCK,-1,,"{
          crypto::CheckThrow(env, SignBase::Error::kSignPrivateKey);
          return false;
        }",65,,772,2,,void
57805,BLOCK,-1,,"{
          crypto::CheckThrow(env, SignBase::Error::kSignPrivateKey);
          return false;
        }",66,,778,2,,void
57826,BLOCK,-1,,"{
          *out = ConvertSignatureToP1363(
              env, params.key, std::move(buf).release());
        }",64,,783,2,,void
57844,BLOCK,-1,,"{
          *out = std::move(buf).release(len);
        }",16,,786,1,,void
57862,BLOCK,6,,"{
      ByteSource::Builder buf(1);
      buf.data<char>()[0] = 0;
      if (EVP_DigestVerify(
              context.get(),
              params.signature.data<unsigned char>(),
              params.signature.size(),
              params.data.data<unsigned char>(),
              params.data.size()) == 1) {
        buf.data<char>()[0] = 1;
      }
      *out = std::move(buf).release();
    }",38,,792,6,,void
57906,BLOCK,-1,,"{
        buf.data<char>()[0] = 1;
      }",41,,800,2,,void
57935,BLOCK,-1,,"{
  switch (params.mode) {
    case SignConfiguration::kSign:
      *result = out->ToArrayBuffer(env);
      break;
    case SignConfiguration::kVerify:
      *result = Boolean::New(env->isolate(), out->data<char>()[0] == 1);
      break;
    default:
      UNREACHABLE();
  }
  return Just(!result->IsEmpty());
}",27,,814,5,,void
57940,BLOCK,-1,,"{
    case SignConfiguration::kSign:
      *result = out->ToArrayBuffer(env);
      break;
    case SignConfiguration::kVerify:
      *result = Boolean::New(env->isolate(), out->data<char>()[0] == 1);
      break;
    default:
      UNREACHABLE();
  }",24,,815,2,,void
58003,BLOCK,-1,,<empty>,1,,1,1,,ANY
58022,BLOCK,-1,,<empty>,1,,1,1,,ANY
58028,BLOCK,-1,,"{
  size_t length = input.size();
#ifdef OPENSSL_IS_BORINGSSL
  // OpenSSL uses EVP_DecodeBlock, which explicitly removes trailing characters,
  // while BoringSSL uses EVP_DecodedLength and EVP_DecodeBase64, which do not.
  // As such, we trim those characters here for compatibility.
  length = std::string(input.data()).find_last_not_of("" \n\r\t"") + 1;
#endif
  NetscapeSPKIPointer spki(
      NETSCAPE_SPKI_b64_decode(input.data(), length));
  if (!spki)
    return false;

  EVPKeyPointer pkey(X509_PUBKEY_get(spki->spkac->pubkey));
  if (!pkey)
    return false;

  return NETSCAPE_SPKI_verify(spki.get(), pkey.get()) > 0;
}",64,,19,2,,void
58047,BLOCK,-1,,<empty>,5,,30,2,,void
58061,BLOCK,-1,,<empty>,5,,34,2,,void
58080,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  ArrayBufferOrViewContents<char> input(args[0]);
  if (input.size() == 0)
    return args.GetReturnValue().SetEmptyString();

  if (UNLIKELY(!input.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""spkac is too large"");

  args.GetReturnValue().Set(VerifySpkac(input));
}",59,,39,2,,void
58101,BLOCK,-1,,<empty>,5,,43,2,,void
58117,BLOCK,-1,,<empty>,5,,46,2,,void
58136,BLOCK,-1,,"{
  BIOPointer bio(BIO_new(BIO_s_mem()));
  if (!bio) return ByteSource();

  size_t length = input.size();
#ifdef OPENSSL_IS_BORINGSSL
  // OpenSSL uses EVP_DecodeBlock, which explicitly removes trailing characters,
  // while BoringSSL uses EVP_DecodedLength and EVP_DecodeBase64, which do not.
  // As such, we trim those characters here for compatibility.
  length = std::string(input.data()).find_last_not_of("" \n\r\t"") + 1;
#endif
  NetscapeSPKIPointer spki(
      NETSCAPE_SPKI_b64_decode(input.data(), length));
  if (!spki) return ByteSource();

  EVPKeyPointer pkey(NETSCAPE_SPKI_get_pubkey(spki.get()));
  if (!pkey) return ByteSource();

  if (PEM_write_bio_PUBKEY(bio.get(), pkey.get()) <= 0) return ByteSource();

  return ByteSource::FromBIO(bio);
}",74,,52,3,,void
58139,BLOCK,-1,,<empty>,,,,2,,<empty>
58145,BLOCK,-1,,<empty>,13,,54,2,,void
58166,BLOCK,-1,,<empty>,14,,65,2,,void
58179,BLOCK,-1,,<empty>,14,,68,2,,void
58194,BLOCK,-1,,<empty>,57,,70,2,,void
58207,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  ArrayBufferOrViewContents<char> input(args[0]);
  if (input.size() == 0) return args.GetReturnValue().SetEmptyString();

  if (UNLIKELY(!input.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""spkac is too large"");

  ByteSource pkey = ExportPublicKey(env, input);
  if (!pkey) return args.GetReturnValue().SetEmptyString();

  args.GetReturnValue().Set(pkey.ToBuffer(env).FromMaybe(Local<Value>()));
}",63,,75,2,,void
58228,BLOCK,-1,,<empty>,26,,79,2,,void
58244,BLOCK,-1,,<empty>,5,,82,2,,void
58258,BLOCK,-1,,<empty>,14,,85,2,,void
58287,BLOCK,-1,,"{
  size_t length = input.size();
#ifdef OPENSSL_IS_BORINGSSL
  // OpenSSL uses EVP_DecodeBlock, which explicitly removes trailing characters,
  // while BoringSSL uses EVP_DecodedLength and EVP_DecodeBase64, which do not.
  // As such, we trim those characters here for compatibility.
  length = std::string(input.data()).find_last_not_of("" \n\r\t"") + 1;
#endif
  NetscapeSPKIPointer sp(
      NETSCAPE_SPKI_b64_decode(input.data(), length));
  if (!sp)
    return ByteSource();

  unsigned char* buf = nullptr;
  int buf_size = ASN1_STRING_to_UTF8(&buf, sp->spkac->challenge);
  return (buf_size >= 0) ? ByteSource::Allocated(buf, buf_size) : ByteSource();
}",74,,90,2,,void
58306,BLOCK,-1,,<empty>,5,,101,2,,void
58340,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  ArrayBufferOrViewContents<char> input(args[0]);
  if (input.size() == 0)
    return args.GetReturnValue().SetEmptyString();

  if (UNLIKELY(!input.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""spkac is too large"");

  ByteSource cert = ExportChallenge(input);
  if (!cert)
    return args.GetReturnValue().SetEmptyString();

  Local<Value> outString =
      Encode(env->isolate(), cert.data<char>(), cert.size(), BUFFER);

  args.GetReturnValue().Set(outString);
}",63,,108,2,,void
58361,BLOCK,-1,,<empty>,5,,113,2,,void
58377,BLOCK,-1,,<empty>,5,,116,2,,void
58390,BLOCK,-1,,<empty>,5,,120,2,,void
58432,BLOCK,-1,,"{
  Local<Context> context = env->context();
  SetMethodNoSideEffect(context, target, ""certVerifySpkac"", VerifySpkac);
  SetMethodNoSideEffect(
      context, target, ""certExportPublicKey"", ExportPublicKey);
  SetMethodNoSideEffect(
      context, target, ""certExportChallenge"", ExportChallenge);
}",57,,128,3,,void
58462,BLOCK,-1,,"{
  registry->Register(VerifySpkac);
  registry->Register(ExportPublicKey);
  registry->Register(ExportChallenge);
}",70,,137,2,,void
58490,BLOCK,-1,,<empty>,1,,1,1,,ANY
58509,BLOCK,-1,,<empty>,1,,1,1,,ANY
58515,BLOCK,-1,,"{
  // Moving the type checking into JS leads to test failures, most likely due
  // to V8 inlining certain parts of the wrapper. Therefore, keep them in C++.
  // Refs: https://github.com/nodejs/node/issues/34073.
  Environment* env = Environment::GetCurrent(args);
  if (!IsAnyByteSource(args[0])) {
    THROW_ERR_INVALID_ARG_TYPE(
      env, ""The \""buf1\"" argument must be an instance of ""
      ""ArrayBuffer, Buffer, TypedArray, or DataView."");
    return;
  }
  if (!IsAnyByteSource(args[1])) {
    THROW_ERR_INVALID_ARG_TYPE(
      env, ""The \""buf2\"" argument must be an instance of ""
      ""ArrayBuffer, Buffer, TypedArray, or DataView."");
    return;
  }

  ArrayBufferOrViewContents<char> buf1(args[0]);
  ArrayBufferOrViewContents<char> buf2(args[1]);

  if (buf1.size() != buf2.size()) {
    THROW_ERR_CRYPTO_TIMING_SAFE_EQUAL_LENGTH(env);
    return;
  }

  return args.GetReturnValue().Set(
      CRYPTO_memcmp(buf1.data(), buf2.data(), buf1.size()) == 0);
}",63,,19,2,,void
58530,BLOCK,-1,,"{
    THROW_ERR_INVALID_ARG_TYPE(
      env, ""The \""buf1\"" argument must be an instance of ""
      ""ArrayBuffer, Buffer, TypedArray, or DataView."");
    return;
  }",34,,24,2,,void
58541,BLOCK,-1,,"{
    THROW_ERR_INVALID_ARG_TYPE(
      env, ""The \""buf2\"" argument must be an instance of ""
      ""ArrayBuffer, Buffer, TypedArray, or DataView."");
    return;
  }",34,,30,2,,void
58566,BLOCK,-1,,"{
    THROW_ERR_CRYPTO_TIMING_SAFE_EQUAL_LENGTH(env);
    return;
  }",35,,40,2,,void
58598,BLOCK,-1,,"{
  SetMethodNoSideEffect(
      env->context(), target, ""timingSafeEqual"", TimingSafeEqual);
}",57,,49,3,,void
58611,BLOCK,-1,,"{
  registry->Register(TimingSafeEqual);
}",70,,53,2,,void
58627,BLOCK,-1,,<empty>,1,,1,1,,ANY
58633,BLOCK,-1,,"{
        static_cast<std::string*>(opaque)->assign(str, len);
        return 0;
      }",53,,347,4,,void
58650,BLOCK,-1,,"{
          InvokeQueued(0);
        }",66,,629,2,,void
58658,BLOCK,-1,,"{
      OnStreamAfterWrite(nullptr, 0);
    }",62,,661,2,,void
58667,BLOCK,-1,,{ return c == ' ' ? '_' : ToUpper(c); },37,,807,2,,void
58681,BLOCK,-1,,"{
          OnStreamAfterWrite(WriteWrap::FromObject(current_empty_write_), 0);
        }",66,,974,2,,void
58700,BLOCK,-1,,"{
        // BIO_write(), etc., called by SSL_trace, may error. The error should
        // be ignored, trace is a ""best effort"", and its usually because stderr
        // is a non-blocking pipe, and its buffer has overflowed. Leaving errors
        // on the stack that can get picked up by later SSL_ calls causes
        // unwanted failures in SSL_ calls, so keep the error stack unchanged.
        MarkPopErrorOnReturn mark_pop_error_on_return;
        SSL_trace(write_p,  version, content_type, buf, len, ssl, arg);
    }",17,,1205,8,,void
58741,BLOCK,-1,,<empty>,1,,1,1,,ANY
58750,BLOCK,-1,,"{
  TLSWrap* w = static_cast<TLSWrap*>(SSL_get_app_data(s));
  *copy = 0;
  return w->ReleaseSession();
}",16,,71,5,,void
58772,BLOCK,-1,,"{
  TLSWrap* w = static_cast<TLSWrap*>(arg);
  Environment* env = w->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Object> hello_obj = Object::New(env->isolate());
  Local<String> servername = (hello.servername() == nullptr)
      ? String::Empty(env->isolate())
      : OneByteString(env->isolate(),
                      hello.servername(),
                      hello.servername_size());
  Local<Object> buf =
      Buffer::Copy(
          env,
          reinterpret_cast<const char*>(hello.session_id()),
          hello.session_size()).FromMaybe(Local<Object>());

  if ((buf.IsEmpty() ||
       hello_obj->Set(env->context(), env->session_id_string(), buf)
           .IsNothing()) ||
      hello_obj->Set(env->context(), env->servername_string(), servername)
          .IsNothing() ||
      hello_obj
          ->Set(env->context(),
                env->tls_ticket_string(),
                Boolean::New(env->isolate(), hello.ha...",50,,79,3,,void
58938,BLOCK,-1,,"{
    return;
  }",25,,106,2,,void
58961,BLOCK,-1,,"{
  TLSWrap* w = static_cast<TLSWrap*>(SSL_get_app_data(s));
  Environment* env = w->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  const size_t size = strlen(line);
  Local<Value> line_bf = Buffer::Copy(env, line, 1 + size)
      .FromMaybe(Local<Value>());
  if (UNLIKELY(line_bf.IsEmpty()))
    return;

  char* data = Buffer::Data(line_bf);
  data[size] = '\n';
  w->MakeCallback(env->onkeylog_string(), 1, &line_bf);
}",53,,114,3,,void
59018,BLOCK,-1,,<empty>,5,,124,2,,void
59049,BLOCK,-1,,"{
  TLSWrap* w = static_cast<TLSWrap*>(SSL_get_app_data(s));
  Environment* env = w->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  if (!w->has_session_callbacks())
    return 0;

  // Check if session is small enough to be stored
  int size = i2d_SSL_SESSION(sess, nullptr);
  if (UNLIKELY(size > SecureContext::kMaxSessionSize))
    return 0;

  // Serialize session
  Local<Object> session = Buffer::New(env, size).FromMaybe(Local<Object>());
  if (UNLIKELY(session.IsEmpty()))
    return 0;

  unsigned char* session_data =
      reinterpret_cast<unsigned char*>(Buffer::Data(session));

  CHECK_EQ(i2d_SSL_SESSION(sess, &session_data), size);

  unsigned int session_id_length;
  const unsigned char* session_id_data =
      SSL_SESSION_get_id(sess, &session_id_length);

  Local<Object> session_id = Buffer::Copy(
      env,
      reinterpret_cast<const char*>(session_id_data),
      session_id_length).FromMaybe(Local<Object>());
  if...",51,,131,3,,void
59082,BLOCK,-1,,<empty>,5,,138,2,,void
59098,BLOCK,-1,,<empty>,5,,143,2,,void
59123,BLOCK,-1,,<empty>,5,,148,2,,void
59175,BLOCK,-1,,<empty>,5,,164,2,,void
59189,BLOCK,-1,,<empty>,5,,174,2,,void
59213,BLOCK,-1,,"{
  TLSWrap* w = static_cast<TLSWrap*>(SSL_get_app_data(s));

  if (!w->is_server() || !w->is_waiting_cert_cb())
    return 1;

  if (w->is_cert_cb_running())
    // Not an error. Suspend handshake with SSL_ERROR_WANT_X509_LOOKUP, and
    // handshake will continue after certcb is done.
    return -1;

  Environment* env = w->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());
  w->set_cert_cb_running();

  Local<Object> info = Object::New(env->isolate());

  const char* servername = GetServerName(s);
  Local<String> servername_str = (servername == nullptr)
      ? String::Empty(env->isolate())
      : OneByteString(env->isolate(), servername, strlen(servername));

  Local<Value> ocsp = Boolean::New(
      env->isolate(), SSL_get_tlsext_status_type(s) == TLSEXT_STATUSTYPE_ocsp);

  if (info->Set(env->context(), env->servername_string(), servername_str)
          .IsNothing() ||
      info->Set(env->context(), env->ocsp_request_string(),...",40,,181,3,,void
59233,BLOCK,-1,,<empty>,5,,185,2,,void
59241,BLOCK,-1,,<empty>,5,,190,2,,void
59365,BLOCK,-1,,"{
    return 1;
  }",80,,209,2,,void
59402,BLOCK,-1,,"{
  TLSWrap* w = static_cast<TLSWrap*>(arg);
  if (w->alpn_callback_enabled_) {
    Environment* env = w->env();
    HandleScope handle_scope(env->isolate());

    Local<Value> callback_arg =
        Buffer::Copy(env, reinterpret_cast<const char*>(in), inlen)
            .ToLocalChecked();

    MaybeLocal<Value> maybe_callback_result =
        w->MakeCallback(env->alpn_callback_string(), 1, &callback_arg);

    if (UNLIKELY(maybe_callback_result.IsEmpty())) {
      // Implies the callback didn't return, because some exception was thrown
      // during processing, e.g. if callback returned an invalid ALPN value.
      return SSL_TLSEXT_ERR_ALERT_FATAL;
    }

    Local<Value> callback_result = maybe_callback_result.ToLocalChecked();

    if (callback_result->IsUndefined()) {
      // If you set an ALPN callback, but you return undefined for an ALPN
      // request, you're rejecting all proposed ALPN protocols, and so we send
      // a fatal alert:
      return SSL_TLSEXT_ERR_ALERT...",16,,225,7,,void
59413,BLOCK,-1,,"{
    Environment* env = w->env();
    HandleScope handle_scope(env->isolate());

    Local<Value> callback_arg =
        Buffer::Copy(env, reinterpret_cast<const char*>(in), inlen)
            .ToLocalChecked();

    MaybeLocal<Value> maybe_callback_result =
        w->MakeCallback(env->alpn_callback_string(), 1, &callback_arg);

    if (UNLIKELY(maybe_callback_result.IsEmpty())) {
      // Implies the callback didn't return, because some exception was thrown
      // during processing, e.g. if callback returned an invalid ALPN value.
      return SSL_TLSEXT_ERR_ALERT_FATAL;
    }

    Local<Value> callback_result = maybe_callback_result.ToLocalChecked();

    if (callback_result->IsUndefined()) {
      // If you set an ALPN callback, but you return undefined for an ALPN
      // request, you're rejecting all proposed ALPN protocols, and so we send
      // a fatal alert:
      return SSL_TLSEXT_ERR_ALERT_FATAL;
    }

    CHECK(callback_result->IsNumber());
    unsigned int result...",34,,227,2,,void
59468,BLOCK,-1,,"{
      // Implies the callback didn't return, because some exception was thrown
      // during processing, e.g. if callback returned an invalid ALPN value.
      return SSL_TLSEXT_ERR_ALERT_FATAL;
    }",52,,238,2,,void
59486,BLOCK,-1,,"{
      // If you set an ALPN callback, but you return undefined for an ALPN
      // request, you're rejecting all proposed ALPN protocols, and so we send
      // a fatal alert:
      return SSL_TLSEXT_ERR_ALERT_FATAL;
    }",41,,246,2,,void
59532,BLOCK,-1,,<empty>,28,,267,2,,void
59565,BLOCK,-1,,"{
  TLSWrap* w = static_cast<TLSWrap*>(SSL_get_app_data(s));
  Environment* env = w->env();
  HandleScope handle_scope(env->isolate());

  if (w->is_client()) {
    // Incoming response
    Local<Value> arg;
    if (GetSSLOCSPResponse(env, s, Null(env->isolate())).ToLocal(&arg))
      w->MakeCallback(env->onocspresponse_string(), 1, &arg);

    // No async acceptance is possible, so always return 1 to accept the
    // response.  The listener for 'OCSPResponse' event has no control over
    // return value, but it can .destroy() the connection if the response is not
    // acceptable.
    return 1;
  }

  // Outgoing response
  Local<ArrayBufferView> obj =
      w->ocsp_response().FromMaybe(Local<ArrayBufferView>());
  if (UNLIKELY(obj.IsEmpty()))
    return SSL_TLSEXT_ERR_NOACK;

  size_t len = obj->ByteLength();

  // OpenSSL takes control of the pointer after accepting it
  unsigned char* data = MallocOpenSSL<unsigned char>(len);
  obj->CopyContents(data, len);

  if (!SSL_set_tl...",45,,285,3,,void
59591,BLOCK,-1,,"{
    // Incoming response
    Local<Value> arg;
    if (GetSSLOCSPResponse(env, s, Null(env->isolate())).ToLocal(&arg))
      w->MakeCallback(env->onocspresponse_string(), 1, &arg);

    // No async acceptance is possible, so always return 1 to accept the
    // response.  The listener for 'OCSPResponse' event has no control over
    // return value, but it can .destroy() the connection if the response is not
    // acceptable.
    return 1;
  }",23,,290,2,,void
59611,BLOCK,-1,,<empty>,7,,294,2,,void
59645,BLOCK,-1,,<empty>,5,,307,2,,void
59672,BLOCK,-1,,<empty>,5,,316,2,,void
59685,BLOCK,-1,,"{
  // OCSP stapling
  SSL_CTX_set_tlsext_status_cb(sc->ctx().get(), TLSExtStatusCallback);
  SSL_CTX_set_tlsext_status_arg(sc->ctx().get(), nullptr);
}",48,,323,2,,void
59712,BLOCK,-1,,"{
  if (value == nullptr)
    return ignore_null;
  return !target->Set(
      env->context(),
      name,
      OneByteString(env->isolate(), value))
          .IsNothing();
}",30,,334,6,,void
59717,BLOCK,-1,,<empty>,5,,336,2,,void
59743,BLOCK,-1,,"{
  std::string ret;
  ERR_print_errors_cb(
      [](const char* str, size_t len, void* opaque) {
        static_cast<std::string*>(opaque)->assign(str, len);
        return 0;
      },
      static_cast<void*>(&ret));
  return ret;
}",27,,344,1,,void
59761,BLOCK,-1,,"{
  MakeWeak();
  CHECK(sc_);
  ssl_ = sc_->CreateSSL();
  CHECK(ssl_);

  sc_->SetGetSessionCallback(GetSessionCallback);
  sc_->SetNewSessionCallback(NewSessionCallback);

  StreamBase::AttachToObject(GetObject());
  stream->PushStreamListener(this);

  env_->isolate()->AdjustAmountOfExternalAllocatedMemory(kExternalSize);

  InitSSL();
  Debug(this, ""Created new TLSWrap"");
}",15,,365,6,,void
59802,BLOCK,-1,,"{
  Destroy();
}",21,,383,1,,void
59807,BLOCK,-1,,"{
  if (ocsp_response_.IsEmpty())
    return MaybeLocal<ArrayBufferView>();
  return PersistentToLocal::Default(env()->isolate(), ocsp_response_);
}",60,,387,1,,void
59813,BLOCK,-1,,<empty>,5,,389,2,,void
59829,BLOCK,-1,,"{
  ocsp_response_.Reset();
}",35,,393,1,,void
59837,BLOCK,-1,,"{
  return next_sess_.release();
}",40,,397,1,,void
59848,BLOCK,-1,,"{
  Debug(this, ""Invoking queued write callbacks (%d, %s)"", status, error_str);
  if (!write_callback_scheduled_)
    return;

  if (current_write_) {
    BaseObjectPtr<AsyncWrap> current_write = std::move(current_write_);
    current_write_.reset();
    WriteWrap* w = WriteWrap::FromObject(current_write);
    w->Done(status, error_str);
  }
}",63,,401,3,,void
59857,BLOCK,-1,,<empty>,5,,404,2,,void
59861,BLOCK,-1,,"{
    BaseObjectPtr<AsyncWrap> current_write = std::move(current_write_);
    current_write_.reset();
    WriteWrap* w = WriteWrap::FromObject(current_write);
    w->Done(status, error_str);
  }",23,,406,2,,void
59894,BLOCK,-1,,"{
  Debug(this, ""New session callback done"");
  Cycle();
}",34,,414,1,,void
59902,BLOCK,-1,,"{
  // Initialize SSL  OpenSSL takes ownership of these.
  enc_in_ = NodeBIO::New(env()).release();
  enc_out_ = NodeBIO::New(env()).release();

  SSL_set_bio(ssl_.get(), enc_in_, enc_out_);

  // NOTE: This could be overridden in SetVerifyMode
  SSL_set_verify(ssl_.get(), SSL_VERIFY_NONE, VerifyCallback);

#ifdef SSL_MODE_RELEASE_BUFFERS
  SSL_set_mode(ssl_.get(), SSL_MODE_RELEASE_BUFFERS);
#endif  // SSL_MODE_RELEASE_BUFFERS

  // This is default in 1.1.1, but set it anyway, Cycle() doesn't currently
  // re-call ClearIn() if SSL_read() returns SSL_ERROR_WANT_READ, so data can be
  // left sitting in the incoming enc_in_ and never get processed.
  // - https://wiki.openssl.org/index.php/TLS1.3#Non-application_data_records
  SSL_set_mode(ssl_.get(), SSL_MODE_AUTO_RETRY);

#ifdef OPENSSL_IS_BORINGSSL
  // OpenSSL allows renegotiation by default, but BoringSSL disables it.
  // Configure BoringSSL to match OpenSSL's behavior.
  SSL_set_renegotiate_mode(ssl_.get(), ssl_renegotiate_fr...",25,,419,1,,void
59957,BLOCK,-1,,<empty>,5,,454,2,,void
59977,BLOCK,-1,,"{
    SSL_set_accept_state(ssl_.get());
  }",20,,460,2,,void
59984,BLOCK,-1,,<empty>,10,,462,1,,void
59987,BLOCK,-1,,"{
    // Enough space for server response (hello, cert)
    NodeBIO::FromBIO(enc_in_)->set_initial(kInitialClientBufferLength);
    SSL_set_connect_state(ssl_.get());
  }",27,,462,2,,void
60003,BLOCK,-1,,"{
    // Unexpected
    ABORT();
  }",10,,466,1,,void
60009,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK_EQ(args.Length(), 3);
  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsObject());
  CHECK(args[2]->IsBoolean());

  Local<Object> sc = args[1].As<Object>();
  Kind kind = args[2]->IsTrue() ? Kind::kServer : Kind::kClient;

  StreamBase* stream = StreamBase::FromObject(args[0].As<Object>());
  CHECK_NOT_NULL(stream);

  Local<Object> obj;
  if (!env->tls_wrap_constructor_function()
           ->NewInstance(env->context())
           .ToLocal(&obj)) {
    return;
  }

  TLSWrap* res = new TLSWrap(env, obj, kind, stream, Unwrap<SecureContext>(sc));

  args.GetReturnValue().Set(res->object());
}",61,,472,2,,void
60111,BLOCK,-1,,"{
    return;
  }",28,,489,2,,void
60142,BLOCK,-1,,"{
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  ArrayBufferViewContents<char> buffer(args[0]);
  const char* data = buffer.data();
  size_t len = buffer.length();
  Debug(wrap, ""Receiving %zu bytes injected from JS"", len);

  // Copy given buffer entirely or partiall if handle becomes closed
  while (len > 0 && wrap->IsAlive() && !wrap->IsClosing()) {
    uv_buf_t buf = wrap->OnStreamAlloc(len);
    size_t copy = buf.len > len ? len : buf.len;
    memcpy(buf.base, data, copy);
    buf.len = copy;
    wrap->OnStreamRead(copy, buf);

    data += copy;
    len -= copy;
  }
}",64,,498,2,,void
60189,BLOCK,-1,,"{
    uv_buf_t buf = wrap->OnStreamAlloc(len);
    size_t copy = buf.len > len ? len : buf.len;
    memcpy(buf.base, data, copy);
    buf.len = copy;
    wrap->OnStreamRead(copy, buf);

    data += copy;
    len -= copy;
  }",60,,508,2,,void
60238,BLOCK,-1,,"{
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK(!wrap->started_);
  wrap->started_ = true;

  // Send ClientHello handshake
  CHECK(wrap->is_client());
  // Seems odd to read when when we want to send, but SSL_read() triggers a
  // handshake if a session isn't established, and handshake will cause
  // encrypted data to become available for output.
  wrap->ClearOut();
  wrap->EncOut();
}",62,,520,2,,void
60276,BLOCK,-1,,"{
  if (!(where & (SSL_CB_HANDSHAKE_START | SSL_CB_HANDSHAKE_DONE)))
    return;

  // SSL_renegotiate_pending() should take `const SSL*`, but it does not.
  SSL* ssl = const_cast<SSL*>(ssl_);
  TLSWrap* c = static_cast<TLSWrap*>(SSL_get_app_data(ssl_));
  Environment* env = c->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());
  Local<Object> object = c->object();

  if (where & SSL_CB_HANDSHAKE_START) {
    Debug(c, ""SSLInfoCallback(SSL_CB_HANDSHAKE_START);"");
    // Start is tracked to limit number and frequency of renegotiation attempts,
    // since excessive renegotiation may be an attack.
    Local<Value> callback;

    if (object->Get(env->context(), env->onhandshakestart_string())
            .ToLocal(&callback) && callback->IsFunction()) {
      Local<Value> argv[] = { env->GetNow() };
      c->MakeCallback(callback.As<Function>(), arraysize(argv), argv);
    }
  }

  // SSL_CB_HANDSHAKE_START and SSL_CB_HANDSHAKE_DONE are ca...",68,,536,4,,void
60284,BLOCK,-1,,<empty>,5,,538,2,,void
60332,BLOCK,-1,,"{
    Debug(c, ""SSLInfoCallback(SSL_CB_HANDSHAKE_START);"");
    // Start is tracked to limit number and frequency of renegotiation attempts,
    // since excessive renegotiation may be an attack.
    Local<Value> callback;

    if (object->Get(env->context(), env->onhandshakestart_string())
            .ToLocal(&callback) && callback->IsFunction()) {
      Local<Value> argv[] = { env->GetNow() };
      c->MakeCallback(callback.As<Function>(), arraysize(argv), argv);
    }
  }",39,,548,2,,void
60364,BLOCK,-1,,"{
      Local<Value> argv[] = { env->GetNow() };
      c->MakeCallback(callback.As<Function>(), arraysize(argv), argv);
    }",60,,555,2,,void
60392,BLOCK,-1,,"{
    Debug(c, ""SSLInfoCallback(SSL_CB_HANDSHAKE_DONE);"");
    CHECK(!SSL_renegotiate_pending(ssl));
    Local<Value> callback;

    c->established_ = true;

    if (object->Get(env->context(), env->onhandshakedone_string())
          .ToLocal(&callback) && callback->IsFunction()) {
      c->MakeCallback(callback.As<Function>(), 0, nullptr);
    }
  }",71,,564,2,,void
60433,BLOCK,-1,,"{
      c->MakeCallback(callback.As<Function>(), 0, nullptr);
    }",58,,572,2,,void
60447,BLOCK,-1,,"{
  Debug(this, ""Trying to write encrypted output"");

  // Ignore cycling data if ClientHello wasn't yet parsed
  if (!hello_parser_.IsEnded()) {
    Debug(this, ""Returning from EncOut(), hello_parser_ active"");
    return;
  }

  // Write in progress
  if (write_size_ != 0) {
    Debug(this, ""Returning from EncOut(), write currently in progress"");
    return;
  }

  // Wait for `newSession` callback to be invoked
  if (is_awaiting_new_session()) {
    Debug(this, ""Returning from EncOut(), awaiting new session"");
    return;
  }

  // Split-off queue
  if (established_ && current_write_) {
    Debug(this, ""EncOut() write is scheduled"");
    write_callback_scheduled_ = true;
  }

  if (ssl_ == nullptr) {
    Debug(this, ""Returning from EncOut(), ssl_ == nullptr"");
    return;
  }

  // No encrypted output ready to write to the underlying stream.
  if (BIO_pending(enc_out_) == 0) {
    Debug(this, ""No pending encrypted output"");
    if (!pending_cleartext_input_ ||
        pending_cle...",24,,578,1,,void
60457,BLOCK,-1,,"{
    Debug(this, ""Returning from EncOut(), hello_parser_ active"");
    return;
  }",33,,582,2,,void
60466,BLOCK,-1,,"{
    Debug(this, ""Returning from EncOut(), write currently in progress"");
    return;
  }",25,,588,2,,void
60473,BLOCK,-1,,"{
    Debug(this, ""Returning from EncOut(), awaiting new session"");
    return;
  }",34,,594,2,,void
60479,BLOCK,-1,,<empty>,7,,600,1,,void
60481,BLOCK,-1,,"{
    Debug(this, ""EncOut() write is scheduled"");
    write_callback_scheduled_ = true;
  }",39,,600,2,,void
60492,BLOCK,-1,,"{
    Debug(this, ""Returning from EncOut(), ssl_ == nullptr"");
    return;
  }",24,,605,2,,void
60502,BLOCK,-1,,"{
    Debug(this, ""No pending encrypted output"");
    if (!pending_cleartext_input_ ||
        pending_cleartext_input_->ByteLength() == 0) {
      if (!in_dowrite_) {
        Debug(this, ""No pending cleartext input, not inside DoWrite()"");
        InvokeQueued(0);
      } else {
        Debug(this, ""No pending cleartext input, inside DoWrite()"");
        // TODO(@sam-github, @addaleax) If in_dowrite_ is true, appdata was
        // passed to SSL_write().  If we are here, the data was not encrypted to
        // enc_out_ yet.  Calling Done() ""works"", but since the write is not
        // flushed, its too soon.  Just returning and letting the next EncOut()
        // call Done() passes the test suite, but without more careful analysis,
        // its not clear if it is always correct. Not calling Done() could block
        // data flow, so for now continue to call Done(), just do it in the next
        // tick.
        BaseObjectPtr<TLSWrap> strong_ref{this};
        env()->SetImmedi...",35,,611,2,,void
60516,BLOCK,-1,,"{
      if (!in_dowrite_) {
        Debug(this, ""No pending cleartext input, not inside DoWrite()"");
        InvokeQueued(0);
      } else {
        Debug(this, ""No pending cleartext input, inside DoWrite()"");
        // TODO(@sam-github, @addaleax) If in_dowrite_ is true, appdata was
        // passed to SSL_write().  If we are here, the data was not encrypted to
        // enc_out_ yet.  Calling Done() ""works"", but since the write is not
        // flushed, its too soon.  Just returning and letting the next EncOut()
        // call Done() passes the test suite, but without more careful analysis,
        // its not clear if it is always correct. Not calling Done() could block
        // data flow, so for now continue to call Done(), just do it in the next
        // tick.
        BaseObjectPtr<TLSWrap> strong_ref{this};
        env()->SetImmediate([this, strong_ref](Environment* env) {
          InvokeQueued(0);
        });
      }
    }",54,,614,2,,void
60520,BLOCK,-1,,"{
        Debug(this, ""No pending cleartext input, not inside DoWrite()"");
        InvokeQueued(0);
      }",25,,615,2,,void
60527,BLOCK,-1,,"{
        Debug(this, ""No pending cleartext input, inside DoWrite()"");
        // TODO(@sam-github, @addaleax) If in_dowrite_ is true, appdata was
        // passed to SSL_write().  If we are here, the data was not encrypted to
        // enc_out_ yet.  Calling Done() ""works"", but since the write is not
        // flushed, its too soon.  Just returning and letting the next EncOut()
        // call Done() passes the test suite, but without more careful analysis,
        // its not clear if it is always correct. Not calling Done() could block
        // data flow, so for now continue to call Done(), just do it in the next
        // tick.
        BaseObjectPtr<TLSWrap> strong_ref{this};
        env()->SetImmediate([this, strong_ref](Environment* env) {
          InvokeQueued(0);
        });
      }",14,,618,1,,void
60579,BLOCK,-1,,<empty>,3,,645,1,,void
60619,BLOCK,-1,,"{
    InvokeQueued(res.err);
    return;
  }",21,,650,2,,void
60630,BLOCK,-1,,"{
    Debug(this, ""Write finished synchronously"");
    HandleScope handle_scope(env()->isolate());

    // Simulate asynchronous finishing, TLS cannot handle this at the moment.
    BaseObjectPtr<TLSWrap> strong_ref{this};
    env()->SetImmediate([this, strong_ref](Environment* env) {
      OnStreamAfterWrite(nullptr, 0);
    });
  }",19,,655,2,,void
60657,BLOCK,-1,,"{
  Debug(this, ""OnStreamAfterWrite(status = %d)"", status);
  if (current_empty_write_) {
    Debug(this, ""Had empty write"");
    BaseObjectPtr<AsyncWrap> current_empty_write =
        std::move(current_empty_write_);
    current_empty_write_.reset();
    WriteWrap* finishing = WriteWrap::FromObject(current_empty_write);
    finishing->Done(status);
    return;
  }

  if (ssl_ == nullptr) {
    Debug(this, ""ssl_ == nullptr, marking as cancelled"");
    status = UV_ECANCELED;
  }

  // Handle error
  if (status) {
    if (shutdown_) {
      Debug(this, ""Ignoring error after shutdown"");
      return;
    }

    // Notify about error
    InvokeQueued(status);
    return;
  }

  // Commit
  NodeBIO::FromBIO(enc_out_)->Read(nullptr, write_size_);

  // Ensure that the progress will be made and `InvokeQueued` will be called.
  ClearIn();

  // Try writing more data
  write_size_ = 0;
  EncOut();
}",67,,667,3,,void
60664,BLOCK,-1,,"{
    Debug(this, ""Had empty write"");
    BaseObjectPtr<AsyncWrap> current_empty_write =
        std::move(current_empty_write_);
    current_empty_write_.reset();
    WriteWrap* finishing = WriteWrap::FromObject(current_empty_write);
    finishing->Done(status);
    return;
  }",29,,669,2,,void
60701,BLOCK,-1,,"{
    Debug(this, ""ssl_ == nullptr, marking as cancelled"");
    status = UV_ECANCELED;
  }",24,,679,2,,void
60710,BLOCK,-1,,"{
    if (shutdown_) {
      Debug(this, ""Ignoring error after shutdown"");
      return;
    }

    // Notify about error
    InvokeQueued(status);
    return;
  }",15,,685,2,,void
60713,BLOCK,-1,,"{
      Debug(this, ""Ignoring error after shutdown"");
      return;
    }",20,,686,2,,void
60739,BLOCK,-1,,"{
  Debug(this, ""Trying to read cleartext output"");
  // Ignore cycling data if ClientHello wasn't yet parsed
  if (!hello_parser_.IsEnded()) {
    Debug(this, ""Returning from ClearOut(), hello_parser_ active"");
    return;
  }

  // No reads after EOF
  if (eof_) {
    Debug(this, ""Returning from ClearOut(), EOF reached"");
    return;
  }

  if (ssl_ == nullptr) {
    Debug(this, ""Returning from ClearOut(), ssl_ == nullptr"");
    return;
  }

  MarkPopErrorOnReturn mark_pop_error_on_return;

  char out[kClearOutChunkSize];
  int read;
  for (;;) {
    read = SSL_read(ssl_.get(), out, sizeof(out));
    Debug(this, ""Read %d bytes of cleartext output"", read);

    if (read <= 0)
      break;

    char* current = out;
    while (read > 0) {
      int avail = read;

      uv_buf_t buf = EmitAlloc(avail);
      if (static_cast<int>(buf.len) < avail)
        avail = buf.len;
      memcpy(buf.base, current, avail);
      EmitRead(avail, buf);

      // Caveat emptor: OnRead() calls into JS...",26,,707,1,,void
60749,BLOCK,-1,,"{
    Debug(this, ""Returning from ClearOut(), hello_parser_ active"");
    return;
  }",33,,710,2,,void
60756,BLOCK,-1,,"{
    Debug(this, ""Returning from ClearOut(), EOF reached"");
    return;
  }",13,,716,2,,void
60765,BLOCK,-1,,"{
    Debug(this, ""Returning from ClearOut(), ssl_ == nullptr"");
    return;
  }",24,,721,2,,void
60774,BLOCK,-1,,<empty>,3,,730,1,,void
60775,BLOCK,4,,"{
    read = SSL_read(ssl_.get(), out, sizeof(out));
    Debug(this, ""Read %d bytes of cleartext output"", read);

    if (read <= 0)
      break;

    char* current = out;
    while (read > 0) {
      int avail = read;

      uv_buf_t buf = EmitAlloc(avail);
      if (static_cast<int>(buf.len) < avail)
        avail = buf.len;
      memcpy(buf.base, current, avail);
      EmitRead(avail, buf);

      // Caveat emptor: OnRead() calls into JS land which can result in
      // the SSL context object being destroyed.  We have to carefully
      // check that ssl_ != nullptr afterwards.
      if (ssl_ == nullptr) {
        Debug(this, ""Returning from read loop, ssl_ == nullptr"");
        return;
      }

      read -= avail;
      current += avail;
    }
  }",12,,730,4,,void
60794,BLOCK,-1,,<empty>,7,,735,2,,void
60804,BLOCK,-1,,"{
      int avail = read;

      uv_buf_t buf = EmitAlloc(avail);
      if (static_cast<int>(buf.len) < avail)
        avail = buf.len;
      memcpy(buf.base, current, avail);
      EmitRead(avail, buf);

      // Caveat emptor: OnRead() calls into JS land which can result in
      // the SSL context object being destroyed.  We have to carefully
      // check that ssl_ != nullptr afterwards.
      if (ssl_ == nullptr) {
        Debug(this, ""Returning from read loop, ssl_ == nullptr"");
        return;
      }

      read -= avail;
      current += avail;
    }",22,,738,2,,void
60822,BLOCK,-1,,<empty>,9,,743,2,,void
60841,BLOCK,-1,,"{
        Debug(this, ""Returning from read loop, ssl_ == nullptr"");
        return;
      }",28,,750,2,,void
60856,BLOCK,-1,,"{
    HandleScope handle_scope(env()->isolate());
    Local<Value> error;
    int err = SSL_get_error(ssl_.get(), read);
    switch (err) {
      case SSL_ERROR_ZERO_RETURN:
        if (!eof_) {
          eof_ = true;
          EmitRead(UV_EOF);
        }
        return;

      case SSL_ERROR_SSL:
      case SSL_ERROR_SYSCALL:
        {
          unsigned long ssl_err = ERR_peek_error();  // NOLINT(runtime/int)

          Local<Context> context = env()->isolate()->GetCurrentContext();
          if (UNLIKELY(context.IsEmpty())) return;
          const std::string error_str = GetBIOError();
          Local<String> message = OneByteString(
              env()->isolate(), error_str.c_str(), error_str.size());
          if (UNLIKELY(message.IsEmpty())) return;
          error = Exception::Error(message);
          if (UNLIKELY(error.IsEmpty())) return;
          Local<Object> obj;
          if (UNLIKELY(!error->ToObject(context).ToLocal(&obj))) return;

          const char* ls = ERR_lib...",18,,766,2,,void
60879,BLOCK,-1,,"{
      case SSL_ERROR_ZERO_RETURN:
        if (!eof_) {
          eof_ = true;
          EmitRead(UV_EOF);
        }
        return;

      case SSL_ERROR_SSL:
      case SSL_ERROR_SYSCALL:
        {
          unsigned long ssl_err = ERR_peek_error();  // NOLINT(runtime/int)

          Local<Context> context = env()->isolate()->GetCurrentContext();
          if (UNLIKELY(context.IsEmpty())) return;
          const std::string error_str = GetBIOError();
          Local<String> message = OneByteString(
              env()->isolate(), error_str.c_str(), error_str.size());
          if (UNLIKELY(message.IsEmpty())) return;
          error = Exception::Error(message);
          if (UNLIKELY(error.IsEmpty())) return;
          Local<Object> obj;
          if (UNLIKELY(!error->ToObject(context).ToLocal(&obj))) return;

          const char* ls = ERR_lib_error_string(ssl_err);
          const char* fs = ERR_func_error_string(ssl_err);
          const char* rs = ERR_reason_error_string(ssl_...",18,,770,2,,void
60885,BLOCK,-1,,"{
          eof_ = true;
          EmitRead(UV_EOF);
        }",20,,772,2,,void
60895,BLOCK,9,,"{
          unsigned long ssl_err = ERR_peek_error();  // NOLINT(runtime/int)

          Local<Context> context = env()->isolate()->GetCurrentContext();
          if (UNLIKELY(context.IsEmpty())) return;
          const std::string error_str = GetBIOError();
          Local<String> message = OneByteString(
              env()->isolate(), error_str.c_str(), error_str.size());
          if (UNLIKELY(message.IsEmpty())) return;
          error = Exception::Error(message);
          if (UNLIKELY(error.IsEmpty())) return;
          Local<Object> obj;
          if (UNLIKELY(!error->ToObject(context).ToLocal(&obj))) return;

          const char* ls = ERR_lib_error_string(ssl_err);
          const char* fs = ERR_func_error_string(ssl_err);
          const char* rs = ERR_reason_error_string(ssl_err);
          if (!Set(env(), obj, env()->library_string(), ls) ||
              !Set(env(), obj, env()->function_string(), fs) ||
              !Set(env(), obj, env()->reason_string(), rs, false))...",9,,780,9,,void
60919,BLOCK,-1,,<empty>,44,,784,2,,void
60950,BLOCK,-1,,<empty>,44,,788,2,,void
60965,BLOCK,-1,,<empty>,42,,790,2,,void
60985,BLOCK,-1,,<empty>,66,,792,2,,void
61033,BLOCK,-1,,<empty>,68,,799,2,,void
61070,BLOCK,-1,,<empty>,72,,809,2,,void
61084,BLOCK,-1,,<empty>,7,,821,2,,void
61097,BLOCK,-1,,"{
  Debug(this, ""Trying to write cleartext input"");
  // Ignore cycling data if ClientHello wasn't yet parsed
  if (!hello_parser_.IsEnded()) {
    Debug(this, ""Returning from ClearIn(), hello_parser_ active"");
    return;
  }

  if (ssl_ == nullptr) {
    Debug(this, ""Returning from ClearIn(), ssl_ == nullptr"");
    return;
  }

  if (!pending_cleartext_input_ ||
      pending_cleartext_input_->ByteLength() == 0) {
    Debug(this, ""Returning from ClearIn(), no pending data"");
    return;
  }

  std::unique_ptr<BackingStore> bs = std::move(pending_cleartext_input_);
  MarkPopErrorOnReturn mark_pop_error_on_return;

  NodeBIO::FromBIO(enc_out_)->set_allocate_tls_hint(bs->ByteLength());
  int written = SSL_write(ssl_.get(), bs->Data(), bs->ByteLength());
  Debug(this, ""Writing %zu bytes, written = %d"", bs->ByteLength(), written);
  CHECK(written == -1 || written == static_cast<int>(bs->ByteLength()));

  // All written
  if (written != -1) {
    Debug(this, ""Successfully wrote all dat...",25,,827,1,,void
61107,BLOCK,-1,,"{
    Debug(this, ""Returning from ClearIn(), hello_parser_ active"");
    return;
  }",33,,830,2,,void
61116,BLOCK,-1,,"{
    Debug(this, ""Returning from ClearIn(), ssl_ == nullptr"");
    return;
  }",24,,835,2,,void
61131,BLOCK,-1,,"{
    Debug(this, ""Returning from ClearIn(), no pending data"");
    return;
  }",52,,841,2,,void
61205,BLOCK,-1,,"{
    Debug(this, ""Successfully wrote all data to SSL"");
    return;
  }",22,,855,2,,void
61227,BLOCK,-1,,"{
    Debug(this, ""Got SSL error (%d)"", err);
    write_callback_scheduled_ = true;
    // TODO(@sam-github) Should forward an error object with
    // .code/.function/.etc, if possible.
    InvokeQueued(UV_EPROTO, GetBIOError().c_str());
    return;
  }",57,,862,2,,void
61255,BLOCK,-1,,"{
  std::string name = ""TLSWrap "";
  name += is_server() ? ""server ("" : ""client ("";
  name += std::to_string(static_cast<int64_t>(get_async_id())) + "")"";
  return name;
}",46,,877,1,,void
61282,BLOCK,-1,,"{
  return static_cast<AsyncWrap*>(this);
}",36,,884,1,,void
61290,BLOCK,-1,,"{
  return underlying_stream()->IsIPCPipe();
}",27,,888,1,,void
61299,BLOCK,-1,,"{
  return underlying_stream()->GetFD();
}",22,,892,1,,void
61308,BLOCK,-1,,"{
  return ssl_ &&
      underlying_stream() != nullptr &&
      underlying_stream()->IsAlive();
}",25,,896,1,,void
61323,BLOCK,-1,,"{
  return underlying_stream()->IsClosing();
}",27,,902,1,,void
61332,BLOCK,-1,,"{
  Debug(this, ""ReadStart()"");
  if (underlying_stream() != nullptr && !eof_)
    return underlying_stream()->ReadStart();
  return 0;
}",26,,906,1,,void
61343,BLOCK,-1,,<empty>,5,,909,2,,void
61354,BLOCK,-1,,"{
  Debug(this, ""ReadStop()"");
  return underlying_stream() != nullptr ? underlying_stream()->ReadStop() : 0;
}",25,,913,1,,void
61371,BLOCK,-1,,"{
  return error_.empty() ? nullptr : error_.c_str();
}",36,,918,1,,void
61386,BLOCK,-1,,"{
  error_.clear();
}",28,,922,1,,void
61398,BLOCK,-1,,"{
  CHECK_NULL(send_handle);
  Debug(this, ""DoWrite()"");

  if (ssl_ == nullptr) {
    ClearError();
    error_ = ""Write after DestroySSL"";
    return UV_EPROTO;
  }

  size_t length = 0;
  size_t i;
  size_t nonempty_i = 0;
  size_t nonempty_count = 0;
  for (i = 0; i < count; i++) {
    length += bufs[i].len;
    if (bufs[i].len > 0) {
      nonempty_i = i;
      nonempty_count += 1;
    }
  }

  // We want to trigger a Write() on the underlying stream to drive the stream
  // system, but don't want to encrypt empty buffers into a TLS frame, so see
  // if we can find something to Write().
  // First, call ClearOut(). It does an SSL_read(), which might cause handshake
  // or other internal messages to be encrypted. If it does, write them later
  // with EncOut().
  // If there is still no encrypted output, call Write(bufs) on the underlying
  // stream. Since the bufs are empty, it won't actually write non-TLS data
  // onto the socket, we just want the side-effects. After, make ...",48,,931,5,,void
61408,BLOCK,-1,,"{
    ClearError();
    error_ = ""Write after DestroySSL"";
    return UV_EPROTO;
  }",24,,935,2,,void
61429,BLOCK,-1,,<empty>,3,,945,1,,void
61438,BLOCK,4,,"{
    length += bufs[i].len;
    if (bufs[i].len > 0) {
      nonempty_i = i;
      nonempty_count += 1;
    }
  }",31,,945,4,,void
61454,BLOCK,-1,,"{
      nonempty_i = i;
      nonempty_count += 1;
    }",26,,947,2,,void
61465,BLOCK,-1,,"{
    Debug(this, ""Empty write"");
    ClearOut();
    if (BIO_pending(enc_out_) == 0) {
      Debug(this, ""No pending encrypted output, writing to underlying stream"");
      CHECK(!current_empty_write_);
      current_empty_write_.reset(w->GetAsyncWrap());
      StreamWriteResult res =
          underlying_stream()->Write(bufs, count, send_handle);
      if (!res.async) {
        BaseObjectPtr<TLSWrap> strong_ref{this};
        env()->SetImmediate([this, strong_ref](Environment* env) {
          OnStreamAfterWrite(WriteWrap::FromObject(current_empty_write_), 0);
        });
      }
      return 0;
    }
  }",20,,963,2,,void
61475,BLOCK,-1,,"{
      Debug(this, ""No pending encrypted output, writing to underlying stream"");
      CHECK(!current_empty_write_);
      current_empty_write_.reset(w->GetAsyncWrap());
      StreamWriteResult res =
          underlying_stream()->Write(bufs, count, send_handle);
      if (!res.async) {
        BaseObjectPtr<TLSWrap> strong_ref{this};
        env()->SetImmediate([this, strong_ref](Environment* env) {
          OnStreamAfterWrite(WriteWrap::FromObject(current_empty_write_), 0);
        });
      }
      return 0;
    }",37,,966,2,,void
61505,BLOCK,-1,,"{
        BaseObjectPtr<TLSWrap> strong_ref{this};
        env()->SetImmediate([this, strong_ref](Environment* env) {
          OnStreamAfterWrite(WriteWrap::FromObject(current_empty_write_), 0);
        });
      }",23,,972,2,,void
61535,BLOCK,-1,,"{
    EncOut();
    return 0;
  }",20,,987,2,,void
61555,BLOCK,-1,,"{
    {
      NoArrayBufferZeroFillScope no_zero_fill_scope(env()->isolate_data());
      bs = ArrayBuffer::NewBackingStore(env()->isolate(), length);
    }
    size_t offset = 0;
    for (i = 0; i < count; i++) {
      memcpy(static_cast<char*>(bs->Data()) + offset,
             bufs[i].base, bufs[i].len);
      offset += bufs[i].len;
    }

    NodeBIO::FromBIO(enc_out_)->set_allocate_tls_hint(length);
    written = SSL_write(ssl_.get(), bs->Data(), length);
  }",28,,1005,2,,void
61556,BLOCK,1,,"{
      NoArrayBufferZeroFillScope no_zero_fill_scope(env()->isolate_data());
      bs = ArrayBuffer::NewBackingStore(env()->isolate(), length);
    }",5,,1006,1,,void
61579,BLOCK,-1,,<empty>,5,,1011,1,,void
61588,BLOCK,4,,"{
      memcpy(static_cast<char*>(bs->Data()) + offset,
             bufs[i].base, bufs[i].len);
      offset += bufs[i].len;
    }",33,,1011,4,,void
61637,BLOCK,-1,,"{
    // Only one buffer: try to write directly, only store if it fails
    uv_buf_t* buf = &bufs[nonempty_i];
    NodeBIO::FromBIO(enc_out_)->set_allocate_tls_hint(buf->len);
    written = SSL_write(ssl_.get(), buf->base, buf->len);

    if (written == -1) {
      NoArrayBufferZeroFillScope no_zero_fill_scope(env()->isolate_data());
      bs = ArrayBuffer::NewBackingStore(env()->isolate(), length);
      memcpy(bs->Data(), buf->base, buf->len);
    }
  }",10,,1019,1,,void
61674,BLOCK,-1,,"{
      NoArrayBufferZeroFillScope no_zero_fill_scope(env()->isolate_data());
      bs = ArrayBuffer::NewBackingStore(env()->isolate(), length);
      memcpy(bs->Data(), buf->base, buf->len);
    }",24,,1025,2,,void
61724,BLOCK,-1,,"{
    // If we stopped writing because of an error, it's fatal, discard the data.
    int err = SSL_get_error(ssl_.get(), written);
    if (err == SSL_ERROR_SSL || err == SSL_ERROR_SYSCALL) {
      // TODO(@jasnell): What are we doing with the error?
      Debug(this, ""Got SSL error (%d), returning UV_EPROTO"", err);
      current_write_.reset();
      return UV_EPROTO;
    }

    Debug(this, ""Saving data for later write"");
    // Otherwise, save unwritten data so it can be written later by ClearIn().
    CHECK(!pending_cleartext_input_ ||
          pending_cleartext_input_->ByteLength() == 0);
    pending_cleartext_input_ = std::move(bs);
  }",22,,1035,2,,void
61742,BLOCK,-1,,"{
      // TODO(@jasnell): What are we doing with the error?
      Debug(this, ""Got SSL error (%d), returning UV_EPROTO"", err);
      current_write_.reset();
      return UV_EPROTO;
    }",59,,1038,2,,void
61786,BLOCK,-1,,"{
  CHECK_NOT_NULL(ssl_);

  size_t size = suggested_size;
  char* base = NodeBIO::FromBIO(enc_in_)->PeekWritable(&size);
  return uv_buf_init(base, size);
}",56,,1061,2,,void
61814,BLOCK,-1,,"{
  Debug(this, ""Read %zd bytes from underlying stream"", nread);

  // Ignore everything after close_notify (rfc5246#section-7.2.1)
  if (eof_)
    return;

  if (nread < 0)  {
    // Error should be emitted only after all data was read
    ClearOut();

    if (nread == UV_EOF) {
      // underlying stream already should have also called ReadStop on itself
      eof_ = true;
    }

    EmitRead(nread);
    return;
  }

  // DestroySSL() is the only thing that un-sets ssl_, but that also removes
  // this TLSWrap as a stream listener, so we should not receive OnStreamRead()
  // calls anymore.
  CHECK(ssl_);

  // Commit the amount of data actually read into the peeked/allocated buffer
  // from the underlying stream.
  NodeBIO* enc_in = NodeBIO::FromBIO(enc_in_);
  enc_in->Commit(nread);

  // Parse ClientHello first, if we need to. It's only parsed if session event
  // listeners are used on the server side.  ""ended"" is the initial state, so
  // can mean parsing was never started,...",64,,1069,3,,void
61821,BLOCK,-1,,<empty>,5,,1074,2,,void
61827,BLOCK,-1,,"{
    // Error should be emitted only after all data was read
    ClearOut();

    if (nread == UV_EOF) {
      // underlying stream already should have also called ReadStop on itself
      eof_ = true;
    }

    EmitRead(nread);
    return;
  }",19,,1076,2,,void
61833,BLOCK,-1,,"{
      // underlying stream already should have also called ReadStop on itself
      eof_ = true;
    }",26,,1080,2,,void
61860,BLOCK,-1,,"{
    size_t avail = 0;
    uint8_t* data = reinterpret_cast<uint8_t*>(enc_in->Peek(&avail));
    CHECK_IMPLIES(data == nullptr, avail == 0);
    Debug(this, ""Passing %zu bytes to the hello parser"", avail);
    return hello_parser_.Parse(data, avail);
  }",33,,1103,2,,void
61899,BLOCK,-1,,"{
  return underlying_stream()->CreateShutdownWrap(req_wrap_object);
}",74,,1115,2,,void
61910,BLOCK,-1,,"{
  Debug(this, ""DoShutdown()"");
  MarkPopErrorOnReturn mark_pop_error_on_return;

  if (ssl_ && SSL_shutdown(ssl_.get()) == 0)
    SSL_shutdown(ssl_.get());

  shutdown_ = true;
  EncOut();
  return underlying_stream()->DoShutdown(req_wrap);
}",49,,1119,2,,void
61925,BLOCK,-1,,<empty>,5,,1124,2,,void
61945,BLOCK,-1,,"{
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK_EQ(args.Length(), 2);
  CHECK(args[0]->IsBoolean());
  CHECK(args[1]->IsBoolean());
  CHECK_NOT_NULL(wrap->ssl_);

  int verify_mode;
  if (wrap->is_server()) {
    bool request_cert = args[0]->IsTrue();
    if (!request_cert) {
      // If no cert is requested, there will be none to reject as unauthorized.
      verify_mode = SSL_VERIFY_NONE;
    } else {
      bool reject_unauthorized = args[1]->IsTrue();
      verify_mode = SSL_VERIFY_PEER;
      if (reject_unauthorized)
        verify_mode |= SSL_VERIFY_FAIL_IF_NO_PEER_CERT;
    }
  } else {
    // Servers always send a cert if the cipher is not anonymous (anon is
    // disabled by default), so use VERIFY_NONE and check the cert after the
    // handshake has completed.
    verify_mode = SSL_VERIFY_NONE;
  }

  // Always allow a connection. We'll reject in javascript.
  SSL_set_verify(wrap->ssl_.get(), verify_mode, VerifyCallback);
}",70,,1131,2,,void
61984,BLOCK,-1,,"{
    bool request_cert = args[0]->IsTrue();
    if (!request_cert) {
      // If no cert is requested, there will be none to reject as unauthorized.
      verify_mode = SSL_VERIFY_NONE;
    } else {
      bool reject_unauthorized = args[1]->IsTrue();
      verify_mode = SSL_VERIFY_PEER;
      if (reject_unauthorized)
        verify_mode |= SSL_VERIFY_FAIL_IF_NO_PEER_CERT;
    }
  }",26,,1141,2,,void
61997,BLOCK,-1,,"{
      // If no cert is requested, there will be none to reject as unauthorized.
      verify_mode = SSL_VERIFY_NONE;
    }",24,,1143,2,,void
62002,BLOCK,-1,,"{
      bool reject_unauthorized = args[1]->IsTrue();
      verify_mode = SSL_VERIFY_PEER;
      if (reject_unauthorized)
        verify_mode |= SSL_VERIFY_FAIL_IF_NO_PEER_CERT;
    }",12,,1146,1,,void
62017,BLOCK,-1,,<empty>,9,,1150,2,,void
62022,BLOCK,-1,,"{
    // Servers always send a cert if the cipher is not anonymous (anon is
    // disabled by default), so use VERIFY_NONE and check the cert after the
    // handshake has completed.
    verify_mode = SSL_VERIFY_NONE;
  }",10,,1152,1,,void
62039,BLOCK,-1,,"{
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  CHECK_NOT_NULL(wrap->ssl_);
  wrap->enable_session_callbacks();

  // Clients don't use the HelloParser.
  if (wrap->is_client())
    return;

  NodeBIO::FromBIO(wrap->enc_in_)->set_initial(kMaxHelloLength);
  wrap->hello_parser_.Start(OnClientHello,
                            OnClientHelloParseEnd,
                            wrap);
}",79,,1163,2,,void
62061,BLOCK,-1,,<empty>,5,,1171,2,,void
62087,BLOCK,-1,,"{
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  CHECK(wrap->sc_);
  wrap->sc_->SetKeylogCallback(KeylogCallback);
}",77,,1179,2,,void
62111,BLOCK,-1,,"{
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

#if HAVE_SSL_TRACE
  if (wrap->ssl_) {
    wrap->bio_trace_.reset(BIO_new_fp(stderr,  BIO_NOCLOSE | BIO_FP_TEXT));
    SSL_set_msg_callback(wrap->ssl_.get(), [](int write_p, int version, int
          content_type, const void* buf, size_t len, SSL* ssl, void* arg)
        -> void {
        // BIO_write(), etc., called by SSL_trace, may error. The error should
        // be ignored, trace is a ""best effort"", and its usually because stderr
        // is a non-blocking pipe, and its buffer has overflowed. Leaving errors
        // on the stack that can get picked up by later SSL_ calls causes
        // unwanted failures in SSL_ calls, so keep the error stack unchanged.
        MarkPopErrorOnReturn mark_pop_error_on_return;
        SSL_trace(write_p,  version, content_type, buf, len, ssl, arg);
    });
    SSL_set_msg_callback_arg(wrap->ssl_.get(), wrap->bio_trace_.get());
  }
#endif
}",68,,1196,2,,void
62124,BLOCK,-1,,"{
    wrap->bio_trace_.reset(BIO_new_fp(stderr,  BIO_NOCLOSE | BIO_FP_TEXT));
    SSL_set_msg_callback(wrap->ssl_.get(), [](int write_p, int version, int
          content_type, const void* buf, size_t len, SSL* ssl, void* arg)
        -> void {
        // BIO_write(), etc., called by SSL_trace, may error. The error should
        // be ignored, trace is a ""best effort"", and its usually because stderr
        // is a non-blocking pipe, and its buffer has overflowed. Leaving errors
        // on the stack that can get picked up by later SSL_ calls causes
        // unwanted failures in SSL_ calls, so keep the error stack unchanged.
        MarkPopErrorOnReturn mark_pop_error_on_return;
        SSL_trace(write_p,  version, content_type, buf, len, ssl, arg);
    });
    SSL_set_msg_callback_arg(wrap->ssl_.get(), wrap->bio_trace_.get());
  }",19,,1201,2,,void
62161,BLOCK,-1,,"{
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  wrap->Destroy();
  Debug(wrap, ""DestroySSL() finished"");
}",67,,1219,2,,void
62180,BLOCK,-1,,"{
  if (!ssl_)
    return;

  // If there is a write happening, mark it as finished.
  write_callback_scheduled_ = true;

  // And destroy
  InvokeQueued(UV_ECANCELED, ""Canceled because of SSL destruction"");

  env()->isolate()->AdjustAmountOfExternalAllocatedMemory(-kExternalSize);
  ssl_.reset();

  enc_in_ = nullptr;
  enc_out_ = nullptr;

  if (underlying_stream() != nullptr)
    underlying_stream()->RemoveStreamListener(this);

  sc_.reset();
}",25,,1226,1,,void
62184,BLOCK,-1,,<empty>,5,,1228,2,,void
62215,BLOCK,-1,,<empty>,5,,1243,2,,void
62229,BLOCK,-1,,"{
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  wrap->WaitForCertCb(OnClientHelloParseEnd, wrap);
}",69,,1248,2,,void
62249,BLOCK,-1,,"{
  cert_cb_ = cb;
  cert_cb_arg_ = arg;
}",51,,1254,3,,void
62260,BLOCK,-1,,"{
  TLSWrap* c = static_cast<TLSWrap*>(arg);
  Debug(c, ""OnClientHelloParseEnd()"");
  c->Cycle();
}",48,,1259,2,,void
62278,BLOCK,-1,,"{
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  wrap->alpn_callback_enabled_ = true;

  SSL* ssl = wrap->ssl_.get();
  SSL_CTX_set_alpn_select_cb(SSL_get_SSL_CTX(ssl), SelectALPNCallback, wrap);
}",69,,1265,2,,void
62310,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK_NOT_NULL(wrap->ssl_);

  const char* servername = GetServerName(wrap->ssl_.get());
  if (servername != nullptr) {
    args.GetReturnValue().Set(OneByteString(env->isolate(), servername));
  } else {
    args.GetReturnValue().Set(false);
  }
}",70,,1274,2,,void
62345,BLOCK,-1,,"{
    args.GetReturnValue().Set(OneByteString(env->isolate(), servername));
  }",30,,1283,2,,void
62360,BLOCK,-1,,"{
    args.GetReturnValue().Set(false);
  }",10,,1285,1,,void
62373,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsString());
  CHECK(!wrap->started_);
  CHECK(wrap->is_client());

  CHECK(wrap->ssl_);

  Utf8Value servername(env->isolate(), args[0].As<String>());
  SSL_set_tlsext_host_name(wrap->ssl_.get(), *servername);
}",70,,1290,2,,void
62444,BLOCK,-1,,"{
  TLSWrap* p = static_cast<TLSWrap*>(SSL_get_app_data(s));
  Environment* env = p->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  const char* servername = GetServerName(s);
  if (!Set(env, p->GetOwner(), env->servername_string(), servername))
    return SSL_TLSEXT_ERR_NOACK;

  Local<Value> ctx = p->object()->Get(env->context(), env->sni_context_string())
      .FromMaybe(Local<Value>());

  if (UNLIKELY(ctx.IsEmpty()) || !ctx->IsObject())
    return SSL_TLSEXT_ERR_NOACK;

  if (!env->secure_context_constructor_template()->HasInstance(ctx)) {
    // Failure: incorrect SNI context object
    Local<Value> err = Exception::TypeError(env->sni_context_err_string());
    p->MakeCallback(env->onerror_string(), 1, &err);
    return SSL_TLSEXT_ERR_NOACK;
  }

  SecureContext* sc = Unwrap<SecureContext>(ctx.As<Object>());
  CHECK_NOT_NULL(sc);
  p->sni_context_ = BaseObjectPtr<SecureContext>(sc);

  ConfigureSecureContext(sc);
  CHECK_E...",67,,1307,4,,void
62489,BLOCK,-1,,<empty>,5,,1315,2,,void
62529,BLOCK,-1,,<empty>,5,,1321,2,,void
62542,BLOCK,-1,,"{
    // Failure: incorrect SNI context object
    Local<Value> err = Exception::TypeError(env->sni_context_err_string());
    p->MakeCallback(env->onerror_string(), 1, &err);
    return SSL_TLSEXT_ERR_NOACK;
  }",70,,1323,2,,void
62627,BLOCK,-1,,"{
  int err = SSL_set1_verify_cert_store(ssl_.get(),
                                       SSL_CTX_get_cert_store(sc->ctx().get()));
  if (err != 1)
    return err;

  STACK_OF(X509_NAME)* list =
      SSL_dup_CA_list(SSL_CTX_get_client_CA_list(sc->ctx().get()));

  // NOTE: `SSL_set_client_CA_list` takes the ownership of `list`
  SSL_set_client_CA_list(ssl_.get(), list);
  return 1;
}",44,,1341,2,,void
62648,BLOCK,-1,,<empty>,5,,1345,2,,void
62677,BLOCK,-1,,"{
  TLSWrap* p;
  ASSIGN_OR_RETURN_UNWRAP(&p, args.Holder());
  CHECK_NOT_NULL(p->ssl_);

  Environment* env = p->env();
  Isolate* isolate = env->isolate();

  CHECK(args[0]->IsString());
  Utf8Value hint(isolate, args[0].As<String>());

  if (!SSL_use_psk_identity_hint(p->ssl_.get(), *hint)) {
    Local<Value> err = node::ERR_TLS_PSK_SET_IDENTIY_HINT_FAILED(isolate);
    p->MakeCallback(env->onerror_string(), 1, &err);
  }
}",75,,1357,2,,void
62731,BLOCK,-1,,"{
    Local<Value> err = node::ERR_TLS_PSK_SET_IDENTIY_HINT_FAILED(isolate);
    p->MakeCallback(env->onerror_string(), 1, &err);
  }",57,,1368,2,,void
62758,BLOCK,-1,,"{
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  CHECK_NOT_NULL(wrap->ssl_);

  SSL_set_psk_server_callback(wrap->ssl_.get(), PskServerCallback);
  SSL_set_psk_client_callback(wrap->ssl_.get(), PskClientCallback);
}",74,,1374,2,,void
62794,BLOCK,-1,,"{
  TLSWrap* p = static_cast<TLSWrap*>(SSL_get_app_data(s));

  Environment* env = p->env();
  HandleScope scope(env->isolate());

  Local<String> identity_str =
      String::NewFromUtf8(env->isolate(), identity).FromMaybe(Local<String>());
  if (UNLIKELY(identity_str.IsEmpty()))
    return 0;

  // Make sure there are no utf8 replacement symbols.
  Utf8Value identity_utf8(env->isolate(), identity_str);
  if (identity_utf8 != identity) return 0;

  Local<Value> argv[] = {
    identity_str,
    Integer::NewFromUnsigned(env->isolate(), max_psk_len)
  };

  Local<Value> psk_val =
      p->MakeCallback(env->onpskexchange_symbol(), arraysize(argv), argv)
          .FromMaybe(Local<Value>());
  if (UNLIKELY(psk_val.IsEmpty()) || !psk_val->IsArrayBufferView())
    return 0;

  ArrayBufferViewContents<char> psk_buf(psk_val);

  if (psk_buf.length() > max_psk_len)
    return 0;

  memcpy(psk, psk_buf.data(), psk_buf.length());
  return psk_buf.length();
}",31,,1387,5,,void
62840,BLOCK,-1,,<empty>,5,,1396,2,,void
62854,BLOCK,-1,,<empty>,34,,1400,2,,void
62904,BLOCK,-1,,<empty>,5,,1411,2,,void
62917,BLOCK,-1,,<empty>,5,,1416,2,,void
62944,BLOCK,-1,,"{
  TLSWrap* p = static_cast<TLSWrap*>(SSL_get_app_data(s));

  Environment* env = p->env();
  HandleScope scope(env->isolate());

  Local<Value> argv[] = {
    Null(env->isolate()),
    Integer::NewFromUnsigned(env->isolate(), max_psk_len),
    Integer::NewFromUnsigned(env->isolate(), max_identity_len)
  };

  if (hint != nullptr) {
    Local<String> local_hint =
        String::NewFromUtf8(env->isolate(), hint).FromMaybe(Local<String>());
    if (UNLIKELY(local_hint.IsEmpty()))
      return 0;

    argv[0] = local_hint;
  }

  Local<Value> ret =
      p->MakeCallback(env->onpskexchange_symbol(), arraysize(argv), argv)
          .FromMaybe(Local<Value>());
  if (UNLIKELY(ret.IsEmpty()) || !ret->IsObject())
    return 0;

  Local<Object> obj = ret.As<Object>();

  Local<Value> psk_val = obj->Get(env->context(), env->psk_string())
      .FromMaybe(Local<Value>());
  if (UNLIKELY(psk_val.IsEmpty()) || !psk_val->IsArrayBufferView())
    return 0;

  ArrayBufferViewContents<char> psk_bu...",31,,1428,7,,void
62996,BLOCK,-1,,"{
    Local<String> local_hint =
        String::NewFromUtf8(env->isolate(), hint).FromMaybe(Local<String>());
    if (UNLIKELY(local_hint.IsEmpty()))
      return 0;

    argv[0] = local_hint;
  }",24,,1440,2,,void
63022,BLOCK,-1,,<empty>,7,,1444,2,,void
63063,BLOCK,-1,,<empty>,5,,1453,2,,void
63110,BLOCK,-1,,<empty>,5,,1460,2,,void
63123,BLOCK,-1,,<empty>,5,,1464,2,,void
63160,BLOCK,-1,,<empty>,5,,1469,2,,void
63177,BLOCK,-1,,<empty>,5,,1474,2,,void
63207,BLOCK,-1,,"{
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, info.This());

  if (!wrap->ssl_)
    return info.GetReturnValue().Set(0);

  uint32_t write_queue_size = BIO_pending(wrap->enc_out_);
  info.GetReturnValue().Set(write_queue_size);
}",74,,1484,2,,void
63221,BLOCK,-1,,<empty>,5,,1489,2,,void
63250,BLOCK,-1,,"{
  tracker->TrackField(""ocsp_response"", ocsp_response_);
  tracker->TrackField(""sni_context"", sni_context_);
  tracker->TrackField(""error"", error_);
  if (pending_cleartext_input_)
    tracker->TrackField(""pending_cleartext_input"", pending_cleartext_input_);
  if (enc_in_ != nullptr)
    tracker->TrackField(""enc_in"", NodeBIO::FromBIO(enc_in_));
  if (enc_out_ != nullptr)
    tracker->TrackField(""enc_out"", NodeBIO::FromBIO(enc_out_));
}",56,,1495,2,,void
63271,BLOCK,-1,,<empty>,5,,1500,2,,void
63282,BLOCK,-1,,<empty>,5,,1502,2,,void
63297,BLOCK,-1,,<empty>,5,,1504,2,,void
63312,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  CHECK(w->is_waiting_cert_cb() && w->cert_cb_running_);

  Local<Object> object = w->object();
  Local<Value> ctx = object->Get(env->context(), env->sni_context_string())
      .FromMaybe(Local<Value>());
  if (UNLIKELY(ctx.IsEmpty()))
    return;

  Local<FunctionTemplate> cons = env->secure_context_constructor_template();
  if (cons->HasInstance(ctx)) {
    SecureContext* sc = Unwrap<SecureContext>(ctx.As<Object>());
    CHECK_NOT_NULL(sc);
    // Store the SNI context for later use.
    w->sni_context_ = BaseObjectPtr<SecureContext>(sc);

    if (UseSNIContext(w->ssl_, w->sni_context_) && !w->SetCACerts(sc)) {
      // Not clear why sometimes we throw error, and sometimes we call
      // onerror(). Both cause .destroy(), but onerror does a bit more.
      unsigned long err = ERR_get_error();  // NOLINT(runtime/int)
      return ThrowCryptoError(env, err, ""CertCbDon...",67,,1507,2,,void
63376,BLOCK,-1,,<empty>,5,,1518,2,,void
63394,BLOCK,-1,,"{
    SecureContext* sc = Unwrap<SecureContext>(ctx.As<Object>());
    CHECK_NOT_NULL(sc);
    // Store the SNI context for later use.
    w->sni_context_ = BaseObjectPtr<SecureContext>(sc);

    if (UseSNIContext(w->ssl_, w->sni_context_) && !w->SetCACerts(sc)) {
      // Not clear why sometimes we throw error, and sometimes we call
      // onerror(). Both cause .destroy(), but onerror does a bit more.
      unsigned long err = ERR_get_error();  // NOLINT(runtime/int)
      return ThrowCryptoError(env, err, ""CertCbDone"");
    }
  }",31,,1521,2,,void
63432,BLOCK,-1,,"{
      // Not clear why sometimes we throw error, and sometimes we call
      // onerror(). Both cause .destroy(), but onerror does a bit more.
      unsigned long err = ERR_get_error();  // NOLINT(runtime/int)
      return ThrowCryptoError(env, err, ""CertCbDone"");
    }",72,,1527,2,,void
63443,BLOCK,-1,,<empty>,10,,1533,1,,void
63449,BLOCK,-1,,"{
    // Failure: incorrect SNI context object
    Local<Value> err = Exception::TypeError(env->sni_context_err_string());
    w->MakeCallback(env->onerror_string(), 1, &err);
    return;
  }",31,,1533,2,,void
63509,BLOCK,-1,,"{
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  Environment* env = w->env();
  if (args.Length() < 1 || !Buffer::HasInstance(args[0]))
    return env->ThrowTypeError(""Must give a Buffer as first argument"");

  ArrayBufferViewContents<uint8_t> protos(args[0].As<ArrayBufferView>());
  SSL* ssl = w->ssl_.get();
  if (w->is_client()) {
    CHECK_EQ(0, SSL_set_alpn_protos(ssl, protos.data(), protos.length()));
  } else {
    w->alpn_protos_ = std::vector<unsigned char>(
        protos.data(), protos.data() + protos.length());
    SSL_CTX_set_alpn_select_cb(SSL_get_SSL_CTX(ssl), SelectALPNCallback, w);
  }
}",73,,1553,2,,void
63541,BLOCK,-1,,<empty>,5,,1558,2,,void
63573,BLOCK,-1,,"{
    CHECK_EQ(0, SSL_set_alpn_protos(ssl, protos.data(), protos.length()));
  }",23,,1562,2,,void
63587,BLOCK,-1,,"{
    w->alpn_protos_ = std::vector<unsigned char>(
        protos.data(), protos.data() + protos.length());
    SSL_CTX_set_alpn_select_cb(SSL_get_SSL_CTX(ssl), SelectALPNCallback, w);
  }",10,,1564,1,,void
63618,BLOCK,-1,,"{
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  Environment* env = w->env();

  bool abbreviated = args.Length() < 1 || !args[0]->IsTrue();

  Local<Value> ret;
  if (GetPeerCert(
          env,
          w->ssl_,
          abbreviated,
          w->is_server()).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",75,,1571,2,,void
63672,BLOCK,-1,,<empty>,5,,1584,2,,void
63685,BLOCK,-1,,"{
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  Environment* env = w->env();

  X509Certificate::GetPeerCertificateFlag flag = w->is_server()
      ? X509Certificate::GetPeerCertificateFlag::SERVER
      : X509Certificate::GetPeerCertificateFlag::NONE;

  Local<Value> ret;
  if (X509Certificate::GetPeerCert(env, w->ssl_, flag).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",79,,1587,2,,void
63739,BLOCK,-1,,<empty>,5,,1598,2,,void
63752,BLOCK,-1,,"{
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  Environment* env = w->env();

  Local<Value> ret;
  if (GetCert(env, w->ssl_).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",71,,1601,2,,void
63784,BLOCK,-1,,<empty>,5,,1608,2,,void
63797,BLOCK,-1,,"{
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  Environment* env = w->env();
  Local<Value> ret;
  if (X509Certificate::GetCert(env, w->ssl_).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",75,,1611,2,,void
63832,BLOCK,-1,,<empty>,5,,1617,2,,void
63845,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  // We cannot just pass nullptr to SSL_get_finished()
  // because it would further be propagated to memcpy(),
  // where the standard requirements as described in ISO/IEC 9899:2011
  // sections 7.21.2.1, 7.21.1.2, and 7.1.4, would be violated.
  // Thus, we use a dummy byte.
  char dummy[1];
  size_t len = SSL_get_finished(w->ssl_.get(), dummy, sizeof dummy);
  if (len == 0)
    return;

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), len);
  }

  CHECK_EQ(bs->ByteLength(),
           SSL_get_finished(w->ssl_.get(), bs->Data(), bs->ByteLength()));

  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
  Local<Value> buffer;
  if (!Buffer::New(env, ab, 0, ab->ByteLength()).ToLocal(&buffer)) return;
  args.GetReturnValue().Set(buff...",68,,1620,2,,void
63880,BLOCK,-1,,<empty>,5,,1634,2,,void
63889,BLOCK,10,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), len);
  }",3,,1637,10,,void
63969,BLOCK,-1,,<empty>,68,,1647,2,,void
63983,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  // We cannot just pass nullptr to SSL_get_peer_finished()
  // because it would further be propagated to memcpy(),
  // where the standard requirements as described in ISO/IEC 9899:2011
  // sections 7.21.2.1, 7.21.1.2, and 7.1.4, would be violated.
  // Thus, we use a dummy byte.
  char dummy[1];
  size_t len = SSL_get_peer_finished(w->ssl_.get(), dummy, sizeof dummy);
  if (len == 0)
    return;

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), len);
  }

  CHECK_EQ(bs->ByteLength(),
           SSL_get_peer_finished(w->ssl_.get(), bs->Data(), bs->ByteLength()));

  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
  Local<Value> buffer;
  if (!Buffer::New(env, ab, 0, ab->ByteLength()).ToLocal(&buffer)) return;
  args.GetReturnV...",72,,1651,2,,void
64018,BLOCK,-1,,<empty>,5,,1665,2,,void
64027,BLOCK,10,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), len);
  }",3,,1668,10,,void
64107,BLOCK,-1,,<empty>,68,,1678,2,,void
64121,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  SSL_SESSION* sess = SSL_get_session(w->ssl_.get());
  if (sess == nullptr)
    return;

  int slen = i2d_SSL_SESSION(sess, nullptr);
  if (slen <= 0)
    return;  // Invalid or malformed session.

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), slen);
  }

  unsigned char* p = static_cast<unsigned char*>(bs->Data());
  CHECK_LT(0, i2d_SSL_SESSION(sess, &p));

  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
  Local<Value> buffer;
  if (!Buffer::New(env, ab, 0, ab->ByteLength()).ToLocal(&buffer)) return;
  args.GetReturnValue().Set(buffer);
}",67,,1682,2,,void
64152,BLOCK,-1,,<empty>,5,,1690,2,,void
64164,BLOCK,-1,,<empty>,5,,1694,2,,void
64173,BLOCK,12,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), slen);
  }",3,,1697,12,,void
64248,BLOCK,-1,,<empty>,68,,1707,2,,void
64262,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  if (args.Length() < 1)
    return THROW_ERR_MISSING_ARGS(env, ""Session argument is mandatory"");

  THROW_AND_RETURN_IF_NOT_BUFFER(env, args[0], ""Session"");
  ArrayBufferViewContents<unsigned char> sbuf(args[0]);
  SSLSessionPointer sess = GetTLSSession(sbuf.data(), sbuf.length());
  if (sess == nullptr)
    return;  // TODO(tniessen): figure out error handling

  if (!SetTLSSession(w->ssl_, sess))
    return env->ThrowError(""SSL_set_session error"");
}",67,,1711,2,,void
64286,BLOCK,-1,,<empty>,5,,1718,2,,void
64318,BLOCK,-1,,<empty>,5,,1724,2,,void
64327,BLOCK,-1,,<empty>,5,,1727,2,,void
64338,BLOCK,-1,,"{
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  bool yes = SSL_session_reused(w->ssl_.get());
  args.GetReturnValue().Set(yes);
}",72,,1730,2,,void
64369,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  // XXX(bnoordhuis) The UNABLE_TO_GET_ISSUER_CERT error when there is no
  // peer certificate is questionable but it's compatible with what was
  // here before.
  long x509_verify_error =  // NOLINT(runtime/int)
      VerifyPeerCertificate(
          w->ssl_,
          X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT);

  if (x509_verify_error == X509_V_OK)
    return args.GetReturnValue().SetNull();

  const char* reason = X509_verify_cert_error_string(x509_verify_error);
  const char* code = X509ErrorCode(x509_verify_error);

  Local<Object> error =
      Exception::Error(OneByteString(env->isolate(), reason))
          ->ToObject(env->isolate()->GetCurrentContext())
              .FromMaybe(Local<Object>());

  if (Set(env, error, env->code_string(), code))
    args.GetReturnValue().Set(error);
}",68,,1737,2,,void
64398,BLOCK,-1,,<empty>,5,,1751,2,,void
64456,BLOCK,-1,,<empty>,5,,1762,2,,void
64469,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  args.GetReturnValue().Set(
      GetCipherInfo(env, w->ssl_).FromMaybe(Local<Object>()));
}",66,,1765,2,,void
64506,BLOCK,-1,,"{
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  // TODO(@sam-github) check arg length and types in js, and CHECK in c++
  if (args.Length() >= 1 && Buffer::HasInstance(args[0])) {
    ArrayBufferViewContents<unsigned char> sbuf(args[0]);

    const unsigned char* p = sbuf.data();
    SSL_SESSION* sess = d2i_SSL_SESSION(nullptr, &p, sbuf.length());

    // Setup next session and move hello to the BIO buffer
    w->next_sess_.reset(sess);
  }
}",68,,1773,2,,void
64530,BLOCK,-1,,"{
    ArrayBufferViewContents<unsigned char> sbuf(args[0]);

    const unsigned char* p = sbuf.data();
    SSL_SESSION* sess = d2i_SSL_SESSION(nullptr, &p, sbuf.length());

    // Setup next session and move hello to the BIO buffer
    w->next_sess_.reset(sess);
  }",59,,1778,2,,void
64565,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  SSL* ssl = w->ssl_.get();
  int nsig = SSL_get_shared_sigalgs(ssl, 0, nullptr, nullptr, nullptr, nullptr,
                                    nullptr);
  MaybeStackBuffer<Local<Value>, 16> ret_arr(nsig);

  for (int i = 0; i < nsig; i++) {
    int hash_nid;
    int sign_nid;
    std::string sig_with_md;

    SSL_get_shared_sigalgs(ssl, i, &sign_nid, &hash_nid, nullptr, nullptr,
                           nullptr);

    switch (sign_nid) {
      case EVP_PKEY_RSA:
        sig_with_md = ""RSA+"";
        break;

      case EVP_PKEY_RSA_PSS:
        sig_with_md = ""RSA-PSS+"";
        break;

      case EVP_PKEY_DSA:
        sig_with_md = ""DSA+"";
        break;

      case EVP_PKEY_EC:
        sig_with_md = ""ECDSA+"";
        break;

      case NID_ED25519:
        sig_with_md = ""Ed25519+"";
        break;

      case NID_ED448:
        sig_with_md = ""Ed448+"";
        break;
#...",73,,1789,2,,void
64606,BLOCK,-1,,<empty>,3,,1799,1,,void
64616,BLOCK,4,,"{
    int hash_nid;
    int sign_nid;
    std::string sig_with_md;

    SSL_get_shared_sigalgs(ssl, i, &sign_nid, &hash_nid, nullptr, nullptr,
                           nullptr);

    switch (sign_nid) {
      case EVP_PKEY_RSA:
        sig_with_md = ""RSA+"";
        break;

      case EVP_PKEY_RSA_PSS:
        sig_with_md = ""RSA-PSS+"";
        break;

      case EVP_PKEY_DSA:
        sig_with_md = ""DSA+"";
        break;

      case EVP_PKEY_EC:
        sig_with_md = ""ECDSA+"";
        break;

      case NID_ED25519:
        sig_with_md = ""Ed25519+"";
        break;

      case NID_ED448:
        sig_with_md = ""Ed448+"";
        break;
#ifndef OPENSSL_NO_GOST
      case NID_id_GostR3410_2001:
        sig_with_md = ""gost2001+"";
        break;

      case NID_id_GostR3410_2012_256:
        sig_with_md = ""gost2012_256+"";
        break;

      case NID_id_GostR3410_2012_512:
        sig_with_md = ""gost2012_512+"";
        break;
#endif  // !OPENSSL_NO_GOST
      default:
        const char*...",34,,1799,4,,void
64632,BLOCK,-1,,"{
      case EVP_PKEY_RSA:
        sig_with_md = ""RSA+"";
        break;

      case EVP_PKEY_RSA_PSS:
        sig_with_md = ""RSA-PSS+"";
        break;

      case EVP_PKEY_DSA:
        sig_with_md = ""DSA+"";
        break;

      case EVP_PKEY_EC:
        sig_with_md = ""ECDSA+"";
        break;

      case NID_ED25519:
        sig_with_md = ""Ed25519+"";
        break;

      case NID_ED448:
        sig_with_md = ""Ed448+"";
        break;
#ifndef OPENSSL_NO_GOST
      case NID_id_GostR3410_2001:
        sig_with_md = ""gost2001+"";
        break;

      case NID_id_GostR3410_2012_256:
        sig_with_md = ""gost2012_256+"";
        break;

      case NID_id_GostR3410_2012_512:
        sig_with_md = ""gost2012_512+"";
        break;
#endif  // !OPENSSL_NO_GOST
      default:
        const char* sn = OBJ_nid2sn(sign_nid);

        if (sn != nullptr) {
          sig_with_md = std::string(sn) + ""+"";
        } else {
          sig_with_md = ""UNDEF+"";
        }
        break;
    }",23,,1807,2,,void
64697,BLOCK,-1,,"{
          sig_with_md = std::string(sn) + ""+"";
        }",28,,1847,2,,void
64708,BLOCK,-1,,"{
          sig_with_md = ""UNDEF+"";
        }",16,,1849,1,,void
64722,BLOCK,-1,,"{
      sig_with_md += std::string(sn_hash);
    }",29,,1856,2,,void
64731,BLOCK,-1,,"{
      sig_with_md += ""UNDEF"";
    }",12,,1858,1,,void
64775,BLOCK,-1,,"{
  CHECK(args[0]->IsInt32());
  CHECK(args[1]->IsString());

  Environment* env = Environment::GetCurrent(args);
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  uint32_t olen = args[0].As<Uint32>()->Value();
  Utf8Value label(env->isolate(), args[1]);

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), olen);
  }

  ByteSource context;
  bool use_context = !args[2]->IsUndefined();
  if (use_context)
    context = ByteSource::FromBuffer(args[2]);

  if (SSL_export_keying_material(
          w->ssl_.get(),
          static_cast<unsigned char*>(bs->Data()),
          olen,
          *label,
          label.length(),
          context.data<unsigned char>(),
          context.size(),
          use_context) != 1) {
    return ThrowCryptoError(
         env,
         ERR_get_error(),
         ""SSL_export_keying_material"");
  }

  Local<ArrayBuffer> ab = ArrayBu...",77,,1868,2,,void
64834,BLOCK,12,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), olen);
  }",3,,1880,12,,void
64865,BLOCK,-1,,<empty>,5,,1888,2,,void
64907,BLOCK,-1,,"{
    return ThrowCryptoError(
         env,
         ERR_get_error(),
         ""SSL_export_keying_material"");
  }",30,,1898,2,,void
64955,BLOCK,-1,,<empty>,68,,1907,2,,void
64969,BLOCK,-1,,"{
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  w->hello_parser_.End();
}",66,,1911,2,,void
64988,BLOCK,-1,,"{
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  ClearErrorOnReturn clear_error_on_return;
  if (SSL_renegotiate(w->ssl_.get()) != 1)
    return ThrowCryptoError(w->env(), ERR_get_error());
}",68,,1917,2,,void
65008,BLOCK,-1,,<empty>,5,,1922,2,,void
65020,BLOCK,-1,,"{
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  Environment* env = w->env();

  SSL_SESSION* sess = SSL_get_session(w->ssl_.get());
  if (sess == nullptr)
    return;

  const unsigned char* ticket;
  size_t length;
  SSL_SESSION_get0_ticket(sess, &ticket, &length);

  if (ticket != nullptr) {
    args.GetReturnValue().Set(
        Buffer::Copy(env, reinterpret_cast<const char*>(ticket), length)
            .FromMaybe(Local<Object>()));
  }
}",69,,1925,2,,void
65050,BLOCK,-1,,<empty>,5,,1932,2,,void
65064,BLOCK,-1,,"{
    args.GetReturnValue().Set(
        Buffer::Copy(env, reinterpret_cast<const char*>(ticket), length)
            .FromMaybe(Local<Object>()));
  }",26,,1938,2,,void
65089,BLOCK,-1,,"{
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  w->awaiting_new_session_ = false;
  w->NewSessionDoneCb();
}",71,,1945,2,,void
65111,BLOCK,-1,,"{
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  Environment* env = w->env();

  if (args.Length() < 1)
    return THROW_ERR_MISSING_ARGS(env, ""OCSP response argument is mandatory"");

  THROW_AND_RETURN_IF_NOT_BUFFER(env, args[0], ""OCSP response"");

  w->ocsp_response_.Reset(args.GetIsolate(), args[0].As<ArrayBufferView>());
}",72,,1952,2,,void
65134,BLOCK,-1,,<empty>,5,,1958,2,,void
65165,BLOCK,-1,,"{
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  SSL_set_tlsext_status_type(w->ssl_.get(), TLSEXT_STATUSTYPE_ocsp);
}",68,,1965,2,,void
65186,BLOCK,-1,,"{
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  Environment* env = Environment::GetCurrent(args);

  CHECK(w->ssl_);

  // tmp key is available on only client
  if (w->is_server())
    return args.GetReturnValue().SetNull();

  args.GetReturnValue().Set(GetEphemeralKey(env, w->ssl_)
      .FromMaybe(Local<Value>()));

  // TODO(@sam-github) semver-major: else return ThrowCryptoError(env,
  // ERR_get_error())
}",76,,1972,2,,void
65212,BLOCK,-1,,<empty>,5,,1981,2,,void
65241,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  args.GetReturnValue().Set(
      OneByteString(env->isolate(), SSL_get_version(w->ssl_.get())));
}",68,,1990,2,,void
65281,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  const unsigned char* alpn_proto;
  unsigned int alpn_proto_len;

  SSL_get0_alpn_selected(w->ssl_.get(), &alpn_proto, &alpn_proto_len);

  Local<Value> result;
  if (alpn_proto_len == 0) {
    result = False(env->isolate());
  } else if (alpn_proto_len == sizeof(""h2"") - 1 &&
             0 == memcmp(alpn_proto, ""h2"", sizeof(""h2"") - 1)) {
    result = env->h2_string();
  } else if (alpn_proto_len == sizeof(""http/1.1"") - 1 &&
             0 == memcmp(alpn_proto, ""http/1.1"", sizeof(""http/1.1"") - 1)) {
    result = env->http_1_1_string();
  } else {
    result = OneByteString(env->isolate(), alpn_proto, alpn_proto_len);
  }

  args.GetReturnValue().Set(result);
}",79,,1998,2,,void
65320,BLOCK,-1,,"{
    result = False(env->isolate());
  }",28,,2009,2,,void
65329,BLOCK,-1,,<empty>,10,,2011,1,,void
65347,BLOCK,-1,,"{
    result = env->h2_string();
  }",63,,2012,2,,void
65355,BLOCK,-1,,<empty>,10,,2014,1,,void
65373,BLOCK,-1,,"{
    result = env->http_1_1_string();
  }",75,,2015,2,,void
65381,BLOCK,-1,,"{
    result = OneByteString(env->isolate(), alpn_proto, alpn_proto_len);
  }",10,,2017,1,,void
65402,BLOCK,-1,,"{
  // Prevent recursion
  if (++cycle_depth_ > 1)
    return;

  for (; cycle_depth_ > 0; cycle_depth_--) {
    ClearIn();
    ClearOut();
    // EncIn() doesn't exist, it happens via stream listener callbacks.
    EncOut();
  }
}",23,,2024,1,,void
65408,BLOCK,-1,,<empty>,5,,2027,2,,void
65411,BLOCK,-1,,<empty>,3,,2029,1,,void
65417,BLOCK,4,,"{
    ClearIn();
    ClearOut();
    // EncIn() doesn't exist, it happens via stream listener callbacks.
    EncOut();
  }",44,,2029,4,,void
65428,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  SetMethod(context, target, ""wrap"", TLSWrap::Wrap);

  NODE_DEFINE_CONSTANT(target, HAVE_SSL_TRACE);

  Local<FunctionTemplate> t = BaseObject::MakeLazilyInitializedJSTemplate(env);
  Local<String> tlsWrapString =
      FIXED_ONE_BYTE_STRING(env->isolate(), ""TLSWrap"");
  t->SetClassName(tlsWrapString);
  t->InstanceTemplate()->SetInternalFieldCount(StreamBase::kInternalFieldCount);

  Local<FunctionTemplate> get_write_queue_size =
      FunctionTemplate::New(env->isolate(),
                            GetWriteQueueSize,
                            Local<Value>(),
                            Signature::New(env->isolate(), t));
  t->PrototypeTemplate()->SetAccessorProperty(
      env->write_queue_size_string(),
      get_write_queue_size,
      Local<FunctionTemplate>(),
      static_cast<PropertyAttribute>(ReadOnly | DontDelete));

  t->Inherit(AsyncWrap::GetConstructorTemplate(env));

  S...",17,,2054,5,,void
65455,BLOCK,1,,<empty>,,,,6,,void
65457,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, HAVE_SSL_TRACE)",3,,2060,1,,void
65874,BLOCK,-1,,"{
  registry->Register(TLSWrap::Wrap);
  registry->Register(GetWriteQueueSize);

  registry->Register(CertCbDone);
  registry->Register(DestroySSL);
  registry->Register(EnableCertCb);
  registry->Register(EnableALPNCb);
  registry->Register(EndParser);
  registry->Register(EnableKeylogCallback);
  registry->Register(EnableSessionCallbacks);
  registry->Register(EnableTrace);
  registry->Register(GetServername);
  registry->Register(LoadSession);
  registry->Register(NewSessionDone);
  registry->Register(Receive);
  registry->Register(Renegotiate);
  registry->Register(RequestOCSP);
  registry->Register(SetALPNProtocols);
  registry->Register(SetOCSPResponse);
  registry->Register(SetServername);
  registry->Register(SetSession);
  registry->Register(SetVerifyMode);
  registry->Register(Start);
  registry->Register(ExportKeyingMaterial);
  registry->Register(IsSessionReused);
  registry->Register(GetALPNNegotiatedProto);
  registry->Register(GetCertificate);
  registry->Register(Get...",79,,2143,2,,void
66100,BLOCK,-1,,<empty>,1,,1,1,,ANY
66106,BLOCK,-1,,"{
        OPENSSL_clear_free(deleter_data, length);
      }",57,,358,4,,void
66118,BLOCK,-1,,"{
            OPENSSL_secure_clear_free(data, len);
          }",58,,728,4,,void
66159,BLOCK,-1,,<empty>,1,,1,1,,ANY
66165,BLOCK,-1,,"{
  // From https://www.openssl.org/docs/man1.1.1/man3/SSL_verify_cb:
  //
  //   If VerifyCallback returns 1, the verification process is continued. If
  //   VerifyCallback always returns 1, the TLS/SSL handshake will not be
  //   terminated with respect to verification failures and the connection will
  //   be established. The calling process can however retrieve the error code
  //   of the last verification error using SSL_get_verify_result(3) or by
  //   maintaining its own error storage managed by VerifyCallback.
  //
  // Since we cannot perform I/O quickly enough with X509_STORE_CTX_ APIs in
  // this callback, we ignore all preverify_ok errors and let the handshake
  // continue. It is imperative that the user use Connection::VerifyError after
  // the 'secure' callback has been made.
  return 1;
}",59,,46,3,,void
66174,BLOCK,-1,,"{
  unsigned char* buf = static_cast<unsigned char*>(buffer);
  do {
    if (1 == RAND_status()) {
#if OPENSSL_VERSION_MAJOR >= 3
      if (1 == RAND_bytes_ex(nullptr, buf, length, 0)) return {true};
#else
      while (length > INT_MAX && 1 == RAND_bytes(buf, INT_MAX)) {
        buf += INT_MAX;
        length -= INT_MAX;
      }
      if (length <= INT_MAX && 1 == RAND_bytes(buf, static_cast<int>(length)))
        return {true};
#endif
    }
#if OPENSSL_VERSION_MAJOR >= 3
    const auto code = ERR_peek_last_error();
    // A misconfigured OpenSSL 3 installation may report 1 from RAND_poll()
    // and RAND_status() but fail in RAND_bytes() if it cannot look up
    // a matching algorithm for the CSPRNG.
    if (ERR_GET_LIB(code) == ERR_LIB_RAND) {
      const auto reason = ERR_GET_REASON(code);
      if (reason == RAND_R_ERROR_INSTANTIATING_DRBG ||
          reason == RAND_R_UNABLE_TO_FETCH_DRBG ||
          reason == RAND_R_UNABLE_TO_CREATE_DRBG) {
        return {false};
      }
 ...",66,,63,3,,void
66182,BLOCK,-1,,"{
    if (1 == RAND_status()) {
#if OPENSSL_VERSION_MAJOR >= 3
      if (1 == RAND_bytes_ex(nullptr, buf, length, 0)) return {true};
#else
      while (length > INT_MAX && 1 == RAND_bytes(buf, INT_MAX)) {
        buf += INT_MAX;
        length -= INT_MAX;
      }
      if (length <= INT_MAX && 1 == RAND_bytes(buf, static_cast<int>(length)))
        return {true};
#endif
    }
#if OPENSSL_VERSION_MAJOR >= 3
    const auto code = ERR_peek_last_error();
    // A misconfigured OpenSSL 3 installation may report 1 from RAND_poll()
    // and RAND_status() but fail in RAND_bytes() if it cannot look up
    // a matching algorithm for the CSPRNG.
    if (ERR_GET_LIB(code) == ERR_LIB_RAND) {
      const auto reason = ERR_GET_REASON(code);
      if (reason == RAND_R_ERROR_INSTANTIATING_DRBG ||
          reason == RAND_R_UNABLE_TO_FETCH_DRBG ||
          reason == RAND_R_UNABLE_TO_CREATE_DRBG) {
        return {false};
      }
    }
#endif
  }",6,,65,1,,void
66187,BLOCK,-1,,"{
#if OPENSSL_VERSION_MAJOR >= 3
      if (1 == RAND_bytes_ex(nullptr, buf, length, 0)) return {true};
#else
      while (length > INT_MAX && 1 == RAND_bytes(buf, INT_MAX)) {
        buf += INT_MAX;
        length -= INT_MAX;
      }
      if (length <= INT_MAX && 1 == RAND_bytes(buf, static_cast<int>(length)))
        return {true};
#endif
    }",29,,66,2,,void
66198,BLOCK,-1,,"{
        buf += INT_MAX;
        length -= INT_MAX;
      }",65,,70,2,,void
66217,BLOCK,-1,,<empty>,9,,75,2,,void
66230,BLOCK,-1,,"{
  const ByteSource* passphrase = *static_cast<const ByteSource**>(u);
  if (passphrase != nullptr) {
    size_t buflen = static_cast<size_t>(size);
    size_t len = passphrase->size();
    if (buflen < len)
      return -1;
    memcpy(buf, passphrase->data(), len);
    return len;
  }

  return -1;
}",64,,97,5,,void
66242,BLOCK,-1,,"{
    size_t buflen = static_cast<size_t>(size);
    size_t len = passphrase->size();
    if (buflen < len)
      return -1;
    memcpy(buf, passphrase->data(), len);
    return len;
  }",30,,99,2,,void
66260,BLOCK,-1,,<empty>,7,,103,2,,void
66283,BLOCK,-1,,"{
  return 0;
}",66,,116,5,,void
66289,BLOCK,-1,,"{
  /* Override FIPS settings in configuration file, if needed. */
  if (per_process::cli_options->enable_fips_crypto ||
      per_process::cli_options->force_fips_crypto) {
#if OPENSSL_VERSION_MAJOR >= 3
    OSSL_PROVIDER* fips_provider = OSSL_PROVIDER_load(nullptr, ""fips"");
    if (fips_provider == nullptr)
      return false;
    OSSL_PROVIDER_unload(fips_provider);

    return EVP_default_properties_enable_fips(nullptr, 1) &&
           EVP_default_properties_is_fips_enabled(nullptr);
#else
    if (FIPS_mode() == 0) return FIPS_mode_set(1);

#endif
  }
  return true;
}",27,,120,1,,void
66302,BLOCK,-1,,"{
#if OPENSSL_VERSION_MAJOR >= 3
    OSSL_PROVIDER* fips_provider = OSSL_PROVIDER_load(nullptr, ""fips"");
    if (fips_provider == nullptr)
      return false;
    OSSL_PROVIDER_unload(fips_provider);

    return EVP_default_properties_enable_fips(nullptr, 1) &&
           EVP_default_properties_is_fips_enabled(nullptr);
#else
    if (FIPS_mode() == 0) return FIPS_mode_set(1);

#endif
  }",52,,123,2,,void
66307,BLOCK,-1,,<empty>,27,,133,2,,void
66317,BLOCK,-1,,"{
  static uv_once_t init_once = UV_ONCE_INIT;
  TryCatch try_catch{isolate};
  uv_once(&init_once, InitCryptoOnce);
  if (try_catch.HasCaught() && !try_catch.HasTerminated()) {
    try_catch.ReThrow();
    return false;
  }
  return true;
}",39,,140,2,,void
66342,BLOCK,-1,,"{
    try_catch.ReThrow();
    return false;
  }",60,,144,2,,void
66355,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Mutex::ScopedLock fips_lock(fips_mutex);
#ifndef OPENSSL_IS_BORINGSSL
  OPENSSL_INIT_SETTINGS* settings = OPENSSL_INIT_new();

#if OPENSSL_VERSION_MAJOR < 3
  // --openssl-config=...
  if (!per_process::cli_options->openssl_config.empty()) {
    const char* conf = per_process::cli_options->openssl_config.c_str();
    OPENSSL_INIT_set_config_filename(settings, conf);
  }
#endif

#if OPENSSL_VERSION_MAJOR >= 3
  // --openssl-legacy-provider
  if (per_process::cli_options->openssl_legacy_provider) {
    OSSL_PROVIDER* legacy_provider = OSSL_PROVIDER_load(nullptr, ""legacy"");
    if (legacy_provider == nullptr) {
      fprintf(stderr, ""Unable to load legacy provider.\n"");
    }
  }
#endif

  OPENSSL_init_ssl(0, settings);
  OPENSSL_INIT_free(settings);
  settings = nullptr;

#ifndef _WIN32
  if (per_process::cli_options->secure_heap != 0) {
    switch (CRYPTO_secure_malloc_init(
                per_process::cli_options->secure...",23,,155,1,,void
66378,BLOCK,-1,,"{
    const char* conf = per_process::cli_options->openssl_config.c_str();
    OPENSSL_INIT_set_config_filename(settings, conf);
  }",58,,163,2,,void
66409,BLOCK,-1,,"{
    switch (CRYPTO_secure_malloc_init(
                per_process::cli_options->secure_heap,
                static_cast<int>(per_process::cli_options->secure_heap_min))) {
      case 0:
        fprintf(stderr, ""Unable to initialize openssl secure heap.\n"");
        break;
      case 2:
        // Not a fatal error but worthy of a warning.
        fprintf(stderr, ""Unable to memory map openssl secure heap.\n"");
        break;
      case 1:
        // OK!
        break;
    }
  }",51,,184,2,,void
66424,BLOCK,-1,,"{
      case 0:
        fprintf(stderr, ""Unable to initialize openssl secure heap.\n"");
        break;
      case 2:
        // Not a fatal error but worthy of a warning.
        fprintf(stderr, ""Unable to memory map openssl secure heap.\n"");
        break;
      case 1:
        // OK!
        break;
    }",79,,187,2,,void
66447,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Mutex::ScopedLock fips_lock(fips_mutex);

#if OPENSSL_VERSION_MAJOR >= 3
  args.GetReturnValue().Set(EVP_default_properties_is_fips_enabled(nullptr) ?
      1 : 0);
#else
  args.GetReturnValue().Set(FIPS_mode() ? 1 : 0);
#endif
}",61,,214,2,,void
66471,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Mutex::ScopedLock fips_lock(fips_mutex);

  CHECK(!per_process::cli_options->force_fips_crypto);
  Environment* env = Environment::GetCurrent(args);
  CHECK(env->owns_process_state());
  bool enable = args[0]->BooleanValue(env->isolate());

#if OPENSSL_VERSION_MAJOR >= 3
  if (enable == EVP_default_properties_is_fips_enabled(nullptr))
#else
  if (static_cast<int>(enable) == FIPS_mode())
#endif
    return;  // No action needed.

#if OPENSSL_VERSION_MAJOR >= 3
  if (!EVP_default_properties_enable_fips(nullptr, enable)) {
#else
  if (!FIPS_mode_set(enable)) {
#endif
    unsigned long err = ERR_get_error();  // NOLINT(runtime/int)
    return ThrowCryptoError(env, err);
  }
}",61,,226,2,,void
66519,BLOCK,-1,,<empty>,5,,240,2,,void
66525,BLOCK,-1,,"{
#endif
    unsigned long err = ERR_get_error();  // NOLINT(runtime/int)
    return ThrowCryptoError(env, err);
  }",31,,245,2,,void
66538,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Mutex::ScopedLock fips_lock(fips_mutex);

#if OPENSSL_VERSION_MAJOR >= 3
  OSSL_PROVIDER* fips_provider = nullptr;
  if (OSSL_PROVIDER_available(nullptr, ""fips"")) {
    fips_provider = OSSL_PROVIDER_load(nullptr, ""fips"");
  }
  const auto enabled = fips_provider == nullptr ? 0 :
      OSSL_PROVIDER_self_test(fips_provider) ? 1 : 0;
#else
#ifdef OPENSSL_FIPS
  const auto enabled = FIPS_selftest() ? 1 : 0;
#else  // OPENSSL_FIPS
  const auto enabled = 0;
#endif  // OPENSSL_FIPS
#endif

  args.GetReturnValue().Set(enabled);
}",70,,252,2,,void
66562,BLOCK,-1,,"{
  errors_.clear();
  while (const uint32_t err = ERR_get_error()) {
    char buf[256];
    ERR_error_string_n(err, buf, sizeof(buf));
    errors_.emplace_back(buf);
  }
  std::reverse(std::begin(errors_), std::end(errors_));
}",34,,274,1,,void
66568,BLOCK,-1,,"{
    char buf[256];
    ERR_error_string_n(err, buf, sizeof(buf));
    errors_.emplace_back(buf);
  }",48,,276,1,,void
66597,BLOCK,-1,,"{
  return errors_.empty();
}",38,,284,1,,void
66608,BLOCK,-1,,"{
  if (exception_string.IsEmpty()) {
    CryptoErrorStore copy(*this);
    if (copy.Empty()) {
      // But possibly a bug...
      copy.Insert(NodeCryptoError::OK);
    }
    // Use last element as the error message, everything else goes
    // into the .opensslErrorStack property on the exception object.
    const std::string& last_error_string = copy.errors_.back();
    Local<String> exception_string;
    if (!String::NewFromUtf8(
            env->isolate(),
            last_error_string.data(),
            NewStringType::kNormal,
            last_error_string.size()).ToLocal(&exception_string)) {
      return MaybeLocal<Value>();
    }
    copy.errors_.pop_back();
    return copy.ToException(env, exception_string);
  }

  Local<Value> exception_v = Exception::Error(exception_string);
  CHECK(!exception_v.IsEmpty());

  if (!Empty()) {
    CHECK(exception_v->IsObject());
    Local<Object> exception = exception_v.As<Object>();
    Local<Value> stack;
    if (!ToV8Value(env->conte...",43,,290,3,,void
66614,BLOCK,-1,,"{
    CryptoErrorStore copy(*this);
    if (copy.Empty()) {
      // But possibly a bug...
      copy.Insert(NodeCryptoError::OK);
    }
    // Use last element as the error message, everything else goes
    // into the .opensslErrorStack property on the exception object.
    const std::string& last_error_string = copy.errors_.back();
    Local<String> exception_string;
    if (!String::NewFromUtf8(
            env->isolate(),
            last_error_string.data(),
            NewStringType::kNormal,
            last_error_string.size()).ToLocal(&exception_string)) {
      return MaybeLocal<Value>();
    }
    copy.errors_.pop_back();
    return copy.ToException(env, exception_string);
  }",35,,291,2,,void
66624,BLOCK,-1,,"{
      // But possibly a bug...
      copy.Insert(NodeCryptoError::OK);
    }",23,,293,2,,void
66672,BLOCK,-1,,"{
      return MaybeLocal<Value>();
    }",67,,305,2,,void
66708,BLOCK,-1,,"{
    CHECK(exception_v->IsObject());
    Local<Object> exception = exception_v.As<Object>();
    Local<Value> stack;
    if (!ToV8Value(env->context(), errors_).ToLocal(&stack) ||
        exception->Set(env->context(), env->openssl_error_stack(), stack)
            .IsNothing()) {
      return MaybeLocal<Value>();
    }
  }",17,,315,2,,void
66759,BLOCK,-1,,"{
      return MaybeLocal<Value>();
    }",27,,321,2,,void
66768,BLOCK,-1,,"{
  other.allocated_data_ = nullptr;
}",26,,332,2,,void
66777,BLOCK,-1,,"{
  OPENSSL_clear_free(allocated_data_, size_);
}",27,,336,1,,void
66785,BLOCK,-1,,"{
  if (&other != this) {
    OPENSSL_clear_free(allocated_data_, size_);
    data_ = other.data_;
    allocated_data_ = other.allocated_data_;
    other.allocated_data_ = nullptr;
    size_ = other.size_;
  }
  return *this;
}",64,,340,2,,void
66791,BLOCK,-1,,"{
    OPENSSL_clear_free(allocated_data_, size_);
    data_ = other.data_;
    allocated_data_ = other.allocated_data_;
    other.allocated_data_ = nullptr;
    size_ = other.size_;
  }",23,,341,2,,void
66821,BLOCK,-1,,"{
  // It's ok for allocated_data_ to be nullptr but
  // only if size_ is zero.
  CHECK_IMPLIES(size_ > 0, allocated_data_ != nullptr);
  std::unique_ptr<BackingStore> ptr = ArrayBuffer::NewBackingStore(
      allocated_data_,
      size(),
      [](void* data, size_t length, void* deleter_data) {
        OPENSSL_clear_free(deleter_data, length);
      }, allocated_data_);
  CHECK(ptr);
  allocated_data_ = nullptr;
  data_ = nullptr;
  size_ = 0;
  return ptr;
}",67,,351,1,,void
66861,BLOCK,-1,,"{
  std::unique_ptr<BackingStore> store = ReleaseToBackingStore();
  return ArrayBuffer::New(env->isolate(), std::move(store));
}",64,,368,2,,void
66889,BLOCK,-1,,"{
  Local<ArrayBuffer> ab = ToArrayBuffer(env);
  return Buffer::New(env, ab, 0, ab->ByteLength());
}",63,,373,2,,void
66914,BLOCK,-1,,"{
  CHECK(bio);
  BUF_MEM* bptr;
  BIO_get_mem_ptr(bio.get(), &bptr);
  ByteSource::Builder out(bptr->length);
  memcpy(out.data<void>(), bptr->data, bptr->length);
  return std::move(out).release();
}",55,,378,2,,void
66956,BLOCK,-1,,"{
  size_t length = 0;
  ByteSource out;

  if (StringBytes::Size(env->isolate(), key, enc).To(&length) && length > 0) {
    ByteSource::Builder buf(length);
    size_t actual =
        StringBytes::Write(env->isolate(), buf.data<char>(), length, key, enc);
    out = std::move(buf).release(actual);
  }

  return out;
}",61,,389,4,,void
66982,BLOCK,-1,,"{
    ByteSource::Builder buf(length);
    size_t actual =
        StringBytes::Write(env->isolate(), buf.data<char>(), length, key, enc);
    out = std::move(buf).release(actual);
  }",78,,393,2,,void
67022,BLOCK,-1,,"{
  return IsAnyByteSource(value) ? FromBuffer(value)
                                : FromString(env, value.As<String>());
}",63,,404,3,,void
67041,BLOCK,-1,,"{
  CHECK(str->IsString());
  size_t size = str->Utf8Length(env->isolate());
  size_t alloc_size = ntc ? size + 1 : size;
  ByteSource::Builder out(alloc_size);
  int opts = String::NO_OPTIONS;
  if (!ntc) opts |= String::NO_NULL_TERMINATION;
  str->WriteUtf8(env->isolate(), out.data<char>(), alloc_size, nullptr, opts);
  return std::move(out).release();
}",45,,410,4,,void
67079,BLOCK,-1,,<empty>,13,,416,2,,void
67114,BLOCK,-1,,"{
  ArrayBufferOrViewContents<char> buf(buffer);
  return ntc ? buf.ToNullTerminatedCopy() : buf.ToByteSource();
}",66,,421,3,,void
67134,BLOCK,-1,,"{
  // A key can be passed as a string, buffer or KeyObject with type 'secret'.
  // If it is a string, we need to convert it to a buffer. We are not doing that
  // in JS to avoid creating an unprotected copy on the heap.
  return value->IsString() || IsAnyByteSource(value) ?
           ByteSource::FromStringOrBuffer(env, value) :
           ByteSource::FromSymmetricKeyObjectHandle(value);
}",25,,428,3,,void
67160,BLOCK,-1,,"{
  return Buffer::HasInstance(value) ? FromBuffer(value, true)
                                    : FromString(env, value.As<String>(), true);
}",63,,438,3,,void
67182,BLOCK,-1,,"{
  CHECK(handle->IsObject());
  KeyObjectHandle* key = Unwrap<KeyObjectHandle>(handle.As<Object>());
  CHECK_NOT_NULL(key);
  return Foreign(key->Data()->GetSymmetricKey(),
                 key->Data()->GetSymmetricKeySize());
}",74,,443,2,,void
67222,BLOCK,-1,,"{
  return ByteSource(data, data, size);
}",59,,451,3,,void
67233,BLOCK,-1,,"{
  return ByteSource(data, nullptr, size);
}",63,,455,3,,void
67246,BLOCK,-1,,"{  // NOLINT(runtime/int)
  if (err == 0) return Just(true);  // No decoration necessary.

  const char* ls = ERR_lib_error_string(err);
  const char* fs = ERR_func_error_string(err);
  const char* rs = ERR_reason_error_string(err);

  Isolate* isolate = env->isolate();
  Local<Context> context = isolate->GetCurrentContext();

  if (ls != nullptr) {
    if (obj->Set(context, env->library_string(),
                 OneByteString(isolate, ls)).IsNothing()) {
      return Nothing<bool>();
    }
  }
  if (fs != nullptr) {
    if (obj->Set(context, env->function_string(),
                 OneByteString(isolate, fs)).IsNothing()) {
      return Nothing<bool>();
    }
  }
  if (rs != nullptr) {
    if (obj->Set(context, env->reason_string(),
                 OneByteString(isolate, rs)).IsNothing()) {
      return Nothing<bool>();
    }

    // SSL has no API to recover the error name from the number, so we
    // transform reason strings like ""this error"" to ""ERR_SSL_THIS_ERROR"",
    // wh...",34,,461,4,,void
67251,BLOCK,-1,,<empty>,17,,462,2,,void
67291,BLOCK,-1,,"{
    if (obj->Set(context, env->library_string(),
                 OneByteString(isolate, ls)).IsNothing()) {
      return Nothing<bool>();
    }
  }",22,,471,2,,void
67308,BLOCK,-1,,"{
      return Nothing<bool>();
    }",59,,473,2,,void
67315,BLOCK,-1,,"{
    if (obj->Set(context, env->function_string(),
                 OneByteString(isolate, fs)).IsNothing()) {
      return Nothing<bool>();
    }
  }",22,,477,2,,void
67332,BLOCK,-1,,"{
      return Nothing<bool>();
    }",59,,479,2,,void
67339,BLOCK,-1,,"{
    if (obj->Set(context, env->reason_string(),
                 OneByteString(isolate, rs)).IsNothing()) {
      return Nothing<bool>();
    }

    // SSL has no API to recover the error name from the number, so we
    // transform reason strings like ""this error"" to ""ERR_SSL_THIS_ERROR"",
    // which ends up being close to the original error macro name.
    std::string reason(rs);

    for (auto& c : reason) {
      if (c == ' ')
        c = '_';
      else
        c = ToUpper(c);
    }

#define OSSL_ERROR_CODES_MAP(V)                                               \
    V(SYS)                                                                    \
    V(BN)                                                                     \
    V(RSA)                                                                    \
    V(DH)                                                                     \
    V(EVP)                                                                    \
    V(BUF)          ...",22,,483,2,,void
67356,BLOCK,-1,,"{
      return Nothing<bool>();
    }",59,,485,2,,void
67365,BLOCK,-1,,"{
      if (c == ' ')
        c = '_';
      else
        c = ToUpper(c);
    }",28,,494,3,,void
67370,BLOCK,-1,,<empty>,9,,496,2,,void
67375,BLOCK,-1,,<empty>,9,,498,1,,void
67391,BLOCK,-1,,{ OSSL_ERROR_CODES_MAP(V) },31,,543,2,,void
67393,BLOCK,1,,<empty>,,,,1,,void
67624,BLOCK,-1,,<empty>,7,,548,2,,void
67665,BLOCK,-1,,<empty>,7,,559,2,,void
67677,BLOCK,-1,,"{
  char message_buffer[128] = {0};
  if (err != 0 || message == nullptr) {
    ERR_error_string_n(err, message_buffer, sizeof(message_buffer));
    message = message_buffer;
  }
  HandleScope scope(env->isolate());
  Local<String> exception_string;
  Local<Value> exception;
  Local<Object> obj;
  if (!String::NewFromUtf8(env->isolate(), message).ToLocal(&exception_string))
    return;
  CryptoErrorStore errors;
  errors.Capture();
  if (!errors.ToException(env, exception_string).ToLocal(&exception) ||
      !exception->ToObject(env->context()).ToLocal(&obj) ||
      error::Decorate(env, obj, err).IsNothing()) {
    return;
  }
  env->isolate()->ThrowException(exception);
}",44,,570,4,,void
67691,BLOCK,-1,,"{
    ERR_error_string_n(err, message_buffer, sizeof(message_buffer));
    message = message_buffer;
  }",39,,572,2,,void
67737,BLOCK,-1,,<empty>,5,,581,2,,void
67783,BLOCK,-1,,"{
    return;
  }",51,,586,2,,void
67798,BLOCK,-1,,"{
  MarkPopErrorOnReturn mark_pop_error_on_return;

  EnginePointer engine(ENGINE_by_id(id));
  if (!engine) {
    // Engine not found, try loading dynamically.
    engine = EnginePointer(ENGINE_by_id(""dynamic""));
    if (engine) {
      if (!ENGINE_ctrl_cmd_string(engine.get(), ""SO_PATH"", id, 0) ||
          !ENGINE_ctrl_cmd_string(engine.get(), ""LOAD"", nullptr, 0)) {
        engine.reset();
      }
    }
  }

  if (!engine && errors != nullptr) {
    errors->Capture();
    if (errors->Empty()) {
      errors->Insert(NodeCryptoError::ENGINE_NOT_FOUND, id);
    }
  }

  return engine;
}",72,,593,3,,void
67807,BLOCK,-1,,"{
    // Engine not found, try loading dynamically.
    engine = EnginePointer(ENGINE_by_id(""dynamic""));
    if (engine) {
      if (!ENGINE_ctrl_cmd_string(engine.get(), ""SO_PATH"", id, 0) ||
          !ENGINE_ctrl_cmd_string(engine.get(), ""LOAD"", nullptr, 0)) {
        engine.reset();
      }
    }
  }",16,,597,2,,void
67815,BLOCK,-1,,"{
      if (!ENGINE_ctrl_cmd_string(engine.get(), ""SO_PATH"", id, 0) ||
          !ENGINE_ctrl_cmd_string(engine.get(), ""LOAD"", nullptr, 0)) {
        engine.reset();
      }
    }",17,,600,2,,void
67836,BLOCK,-1,,"{
        engine.reset();
      }",70,,602,2,,void
67848,BLOCK,-1,,"{
    errors->Capture();
    if (errors->Empty()) {
      errors->Insert(NodeCryptoError::ENGINE_NOT_FOUND, id);
    }
  }",37,,608,2,,void
67858,BLOCK,-1,,"{
      errors->Insert(NodeCryptoError::ENGINE_NOT_FOUND, id);
    }",26,,610,2,,void
67875,BLOCK,-1,,"{
  ClearErrorOnReturn clear_error_on_return;
  EnginePointer engine = LoadEngineById(id, errors);
  if (!engine)
    return false;

  if (!ENGINE_set_default(engine.get(), flags)) {
    if (errors != nullptr)
      errors->Capture();
    return false;
  }

  return true;
}",74,,618,4,,void
67886,BLOCK,-1,,<empty>,5,,622,2,,void
67897,BLOCK,-1,,"{
    if (errors != nullptr)
      errors->Capture();
    return false;
  }",49,,624,2,,void
67902,BLOCK,-1,,<empty>,7,,626,2,,void
67915,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args.Length() >= 2 && args[0]->IsString());
  uint32_t flags;
  if (!args[1]->Uint32Value(env->context()).To(&flags)) return;

  const node::Utf8Value engine_id(env->isolate(), args[0]);

  if (UNLIKELY(env->permission()->enabled())) {
    return THROW_ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED(
        env,
        ""Programmatic selection of OpenSSL engines is unsupported while the ""
        ""experimental permission model is enabled"");
  }

  args.GetReturnValue().Set(SetEngine(*engine_id, flags));
}",57,,633,2,,void
67956,BLOCK,-1,,<empty>,57,,637,2,,void
67976,BLOCK,-1,,"{
    return THROW_ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED(
        env,
        ""Programmatic selection of OpenSSL engines is unsupported while the ""
        ""experimental permission model is enabled"");
  }",47,,641,2,,void
67999,BLOCK,-1,,"{
  std::vector<uint8_t> buf(size);
  CHECK_EQ(BN_bn2binpad(bn, buf.data(), size), size);
  return StringBytes::Encode(
      env->isolate(),
      reinterpret_cast<const char*>(buf.data()),
      buf.size(),
      BASE64URL,
      error);
}",26,,656,5,,void
68046,BLOCK,-1,,"{
  Local<Value> value;
  Local<Value> error;
  CHECK_NOT_NULL(bn);
  if (size == 0)
    size = BN_num_bytes(bn);
  if (!EncodeBignum(env, bn, size, &error).ToLocal(&value)) {
    if (!error.IsEmpty())
      env->isolate()->ThrowException(error);
    return Nothing<bool>();
  }
  return target->Set(env->context(), name, value);
}",15,,672,6,,void
68063,BLOCK,-1,,<empty>,5,,677,2,,void
68081,BLOCK,-1,,"{
    if (!error.IsEmpty())
      env->isolate()->ThrowException(error);
    return Nothing<bool>();
  }",61,,678,2,,void
68088,BLOCK,-1,,<empty>,7,,680,2,,void
68115,BLOCK,-1,,"{
  if (label.size() != 0) {
    // OpenSSL takes ownership of the label, so we need to create a copy.
    void* label_copy = OPENSSL_memdup(label.data(), label.size());
    CHECK_NOT_NULL(label_copy);
    int ret = EVP_PKEY_CTX_set0_rsa_oaep_label(
        ctx.get(), static_cast<unsigned char*>(label_copy), label.size());
    if (ret <= 0) {
      OPENSSL_free(label_copy);
      return false;
    }
  }
  return true;
}",76,,686,3,,void
68123,BLOCK,-1,,"{
    // OpenSSL takes ownership of the label, so we need to create a copy.
    void* label_copy = OPENSSL_memdup(label.data(), label.size());
    CHECK_NOT_NULL(label_copy);
    int ret = EVP_PKEY_CTX_set0_rsa_oaep_label(
        ctx.get(), static_cast<unsigned char*>(label_copy), label.size());
    if (ret <= 0) {
      OPENSSL_free(label_copy);
      return false;
    }
  }",26,,687,2,,void
68157,BLOCK,-1,,"{
      OPENSSL_free(label_copy);
      return false;
    }",19,,693,2,,void
68168,BLOCK,-1,,"{
  CHECK(args->IsUint32());
  uint32_t mode = args.As<v8::Uint32>()->Value();
  CHECK_LE(mode, kCryptoJobSync);
  return static_cast<CryptoJobMode>(mode);
}",59,,701,2,,void
68196,BLOCK,-1,,"{
  CHECK(args[0]->IsUint32());
  Environment* env = Environment::GetCurrent(args);
  uint32_t len = args[0].As<Uint32>()->Value();
  void* data = OPENSSL_secure_zalloc(len);
  if (data == nullptr) {
    // There's no memory available for the allocation.
    // Return nothing.
    return;
  }
  std::shared_ptr<BackingStore> store =
      ArrayBuffer::NewBackingStore(
          data,
          len,
          [](void* data, size_t len, void* deleter_data) {
            OPENSSL_secure_clear_free(data, len);
          },
          data);
  Local<ArrayBuffer> buffer = ArrayBuffer::New(env->isolate(), store);
  args.GetReturnValue().Set(Uint8Array::New(buffer, 0, len));
}",60,,714,2,,void
68231,BLOCK,-1,,"{
    // There's no memory available for the allocation.
    // Return nothing.
    return;
  }",24,,719,2,,void
68282,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  if (CRYPTO_secure_malloc_initialized())
    args.GetReturnValue().Set(
        BigInt::New(env->isolate(), CRYPTO_secure_used()));
}",62,,736,2,,void
68293,BLOCK,-1,,<empty>,5,,739,2,,void
68316,BLOCK,-1,,"{
  Local<Context> context = env->context();
#ifndef OPENSSL_NO_ENGINE
  SetMethod(context, target, ""setEngine"", SetEngine);
#endif  // !OPENSSL_NO_ENGINE

  SetMethodNoSideEffect(context, target, ""getFipsCrypto"", GetFipsCrypto);
  SetMethod(context, target, ""setFipsCrypto"", SetFipsCrypto);
  SetMethodNoSideEffect(context, target, ""testFipsCrypto"", TestFipsCrypto);

  NODE_DEFINE_CONSTANT(target, kCryptoJobAsync);
  NODE_DEFINE_CONSTANT(target, kCryptoJobSync);

  SetMethod(context, target, ""secureBuffer"", SecureBuffer);
  SetMethod(context, target, ""secureHeapUsed"", SecureHeapUsed);
}",57,,745,3,,void
68352,BLOCK,1,,<empty>,,,,7,,void
68354,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kCryptoJobAsync)",3,,755,1,,void
68451,BLOCK,1,,<empty>,,,,7,,void
68453,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kCryptoJobSync)",3,,756,1,,void
68559,BLOCK,-1,,"{
#ifndef OPENSSL_NO_ENGINE
  registry->Register(SetEngine);
#endif  // !OPENSSL_NO_ENGINE

  registry->Register(GetFipsCrypto);
  registry->Register(SetFipsCrypto);
  registry->Register(TestFipsCrypto);
  registry->Register(SecureBuffer);
  registry->Register(SecureHeapUsed);
}",70,,761,2,,void
68646,BLOCK,-1,,<empty>,1,,1,1,,ANY
68677,BLOCK,-1,,<empty>,1,,1,1,,ANY
68682,BLOCK,-1,,<empty>,71,,33,2,,void
68687,BLOCK,-1,,"{
  *this = that;
}",51,,35,2,,void
68696,BLOCK,-1,,"{
  cert_.reset(that.get());

  if (cert_)
    X509_up_ref(cert_.get());

  return *this;
}",62,,39,2,,void
68707,BLOCK,-1,,<empty>,5,,43,2,,void
68720,BLOCK,-1,,"{
  // This is an approximation based on the der encoding size.
  int size = i2d_X509(cert_.get(), nullptr);
  tracker->TrackFieldWithSize(""cert"", size);
}",60,,48,2,,void
68741,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  Local<Value> ret;
  if (GetFingerprintDigest(env, algo(), cert->get()).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",59,,56,2,,void
68776,BLOCK,-1,,<empty>,5,,62,2,,void
68789,BLOCK,-1,,"{
  Local<FunctionTemplate> tmpl = env->x509_constructor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        BaseObject::kInternalFieldCount);
    tmpl->SetClassName(
        FIXED_ONE_BYTE_STRING(env->isolate(), ""X509Certificate""));
    SetProtoMethod(isolate, tmpl, ""subject"", Subject);
    SetProtoMethod(isolate, tmpl, ""subjectAltName"", SubjectAltName);
    SetProtoMethod(isolate, tmpl, ""infoAccess"", InfoAccess);
    SetProtoMethod(isolate, tmpl, ""issuer"", Issuer);
    SetProtoMethod(isolate, tmpl, ""validTo"", ValidTo);
    SetProtoMethod(isolate, tmpl, ""validFrom"", ValidFrom);
    SetProtoMethod(isolate, tmpl, ""fingerprint"", Fingerprint<EVP_sha1>);
    SetProtoMethod(isolate, tmpl, ""fingerprint256"", Fingerprint<EVP_sha256>);
    SetProtoMethod(isolate, tmpl, ""fingerprint512"", Fingerprint<EVP_sha512>);
    SetProtoMethod(isolate, tmpl, ""keyUsage"", Ke...",23,,67,2,,void
68805,BLOCK,-1,,"{
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        BaseObject::kInternalFieldCount);
    tmpl->SetClassName(
        FIXED_ONE_BYTE_STRING(env->isolate(), ""X509Certificate""));
    SetProtoMethod(isolate, tmpl, ""subject"", Subject);
    SetProtoMethod(isolate, tmpl, ""subjectAltName"", SubjectAltName);
    SetProtoMethod(isolate, tmpl, ""infoAccess"", InfoAccess);
    SetProtoMethod(isolate, tmpl, ""issuer"", Issuer);
    SetProtoMethod(isolate, tmpl, ""validTo"", ValidTo);
    SetProtoMethod(isolate, tmpl, ""validFrom"", ValidFrom);
    SetProtoMethod(isolate, tmpl, ""fingerprint"", Fingerprint<EVP_sha1>);
    SetProtoMethod(isolate, tmpl, ""fingerprint256"", Fingerprint<EVP_sha256>);
    SetProtoMethod(isolate, tmpl, ""fingerprint512"", Fingerprint<EVP_sha512>);
    SetProtoMethod(isolate, tmpl, ""keyUsage"", KeyUsage);
    SetProtoMethod(isolate, tmpl, ""serialNumber"", SerialNumber);
    SetProtoMetho...",23,,69,2,,void
68965,BLOCK,-1,,"{
  return GetConstructorTemplate(env)->HasInstance(object);
}",75,,104,3,,void
68980,BLOCK,-1,,"{
  ClearErrorOnReturn clear_error_on_return;
  X509* cert = SSL_get_certificate(ssl.get());
  if (cert == nullptr)
    return MaybeLocal<Object>();

  X509Pointer ptr(X509_dup(cert));
  return New(env, std::move(ptr));
}",28,,135,3,,void
68994,BLOCK,-1,,<empty>,5,,139,2,,void
69015,BLOCK,-1,,"{
  ClearErrorOnReturn clear_error_on_return;
  MaybeLocal<Object> maybe_cert;

  bool is_server =
      static_cast<int>(flag) & static_cast<int>(GetPeerCertificateFlag::SERVER);

  X509Pointer cert(is_server ? SSL_get_peer_certificate(ssl.get()) : nullptr);
  STACK_OF(X509)* ssl_certs = SSL_get_peer_cert_chain(ssl.get());
  if (!cert && (ssl_certs == nullptr || sk_X509_num(ssl_certs) == 0))
    return MaybeLocal<Object>();

  std::vector<Local<Value>> certs;

  if (!cert) {
    cert.reset(sk_X509_value(ssl_certs, 0));
    sk_X509_delete(ssl_certs, 0);
  }

  return sk_X509_num(ssl_certs)
      ? New(env, std::move(cert), ssl_certs)
      : New(env, std::move(cert));
}",34,,148,4,,void
69066,BLOCK,-1,,<empty>,5,,158,2,,void
69081,BLOCK,-1,,"{
    cert.reset(sk_X509_value(ssl_certs, 0));
    sk_X509_delete(ssl_certs, 0);
  }",14,,162,2,,void
69115,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsArrayBufferView());
  ArrayBufferViewContents<unsigned char> buf(args[0].As<ArrayBufferView>());
  const unsigned char* data = buf.data();
  unsigned data_len = buf.length();

  ClearErrorOnReturn clear_error_on_return;
  BIOPointer bio(LoadBIO(env, args[0]));
  if (!bio)
    return ThrowCryptoError(env, ERR_get_error());

  Local<Object> cert;

  X509Pointer pem(PEM_read_bio_X509_AUX(
      bio.get(), nullptr, NoPasswordCallback, nullptr));
  if (!pem) {
    // Try as DER, but return the original PEM failure if it isn't DER.
    MarkPopErrorOnReturn mark_here;

    X509Pointer der(d2i_X509(nullptr, &data, data_len));
    if (!der)
      return ThrowCryptoError(env, ERR_get_error());

    if (!X509Certificate::New(env, std::move(der)).ToLocal(&cert))
      return;
  } else if (!X509Certificate::New(env, std::move(pem)).ToLocal(&cert)) {
    return;
  }

  args.GetReturnValue().Set(cert);
}",70,,172,2,,void
69164,BLOCK,-1,,<empty>,5,,183,2,,void
69187,BLOCK,-1,,"{
    // Try as DER, but return the original PEM failure if it isn't DER.
    MarkPopErrorOnReturn mark_here;

    X509Pointer der(d2i_X509(nullptr, &data, data_len));
    if (!der)
      return ThrowCryptoError(env, ERR_get_error());

    if (!X509Certificate::New(env, std::move(der)).ToLocal(&cert))
      return;
  }",13,,189,2,,void
69199,BLOCK,-1,,<empty>,7,,195,2,,void
69221,BLOCK,-1,,<empty>,7,,198,2,,void
69224,BLOCK,-1,,<empty>,10,,199,1,,void
69242,BLOCK,-1,,"{
    return;
  }",73,,199,2,,void
69256,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);
  Local<Value> ret;
  if (Property(env, cert->get(), bio).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",79,,208,2,,void
69297,BLOCK,-1,,<empty>,5,,216,2,,void
69310,BLOCK,-1,,"{
  ReturnPropertyThroughBIO<GetSubject>(args);
}",72,,219,2,,void
69320,BLOCK,-1,,"{
  ReturnPropertyThroughBIO<GetIssuerString>(args);
}",71,,223,2,,void
69330,BLOCK,-1,,"{
  ReturnPropertyThroughBIO<GetSubjectAltNameString>(args);
}",79,,227,2,,void
69340,BLOCK,-1,,"{
  ReturnPropertyThroughBIO<GetInfoAccessString>(args);
}",75,,231,2,,void
69350,BLOCK,-1,,"{
  ReturnPropertyThroughBIO<GetValidFrom>(args);
}",74,,235,2,,void
69360,BLOCK,-1,,"{
  ReturnPropertyThroughBIO<GetValidTo>(args);
}",72,,239,2,,void
69370,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  Local<Value> ret;
  if (Property(env, cert->get()).ToLocal(&ret)) args.GetReturnValue().Set(ret);
}",69,,244,2,,void
69404,BLOCK,-1,,<empty>,49,,249,2,,void
69417,BLOCK,-1,,"{
  ReturnProperty<GetKeyUsage>(args);
}",73,,252,2,,void
69427,BLOCK,-1,,"{
  ReturnProperty<GetSerialNumber>(args);
}",77,,256,2,,void
69437,BLOCK,-1,,"{
  ReturnProperty<GetRawDERCertificate>(args);
}",68,,260,2,,void
69447,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());

  // TODO(tniessen): consider checking X509_get_pubkey() when the
  // X509Certificate object is being created.
  ClearErrorOnReturn clear_error_on_return;
  EVPKeyPointer pkey(X509_get_pubkey(cert->get()));
  if (!pkey) return ThrowCryptoError(env, ERR_get_error());
  ManagedEVPPKey epkey(std::move(pkey));
  std::shared_ptr<KeyObjectData> key_data =
      KeyObjectData::CreateAsymmetric(kKeyTypePublic, epkey);

  Local<Value> ret;
  if (KeyObjectHandle::Create(env, key_data).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",74,,264,2,,void
69475,BLOCK,-1,,<empty>,14,,273,2,,void
69518,BLOCK,-1,,<empty>,5,,280,2,,void
69531,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);
  if (PEM_write_bio_X509(bio.get(), cert->get()))
    args.GetReturnValue().Set(ToV8Value(env, bio));
}",68,,283,2,,void
69550,BLOCK,-1,,<empty>,,,,2,,<empty>
69565,BLOCK,-1,,<empty>,5,,290,2,,void
69580,BLOCK,-1,,"{
  X509Certificate* cert;
  ClearErrorOnReturn clear_error_on_return;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  args.GetReturnValue().Set(X509_check_ca(cert->get()) == 1);
}",72,,293,2,,void
69608,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());

  CHECK(args[0]->IsString());  // name
  CHECK(args[1]->IsUint32());  // flags

  Utf8Value name(env->isolate(), args[0]);
  uint32_t flags = args[1].As<Uint32>()->Value();
  char* peername;

  switch (X509_check_host(
              cert->get(),
              *name,
              name.length(),
              flags,
              &peername)) {
    case 1:  {  // Match!
      Local<Value> ret = args[0];
      if (peername != nullptr) {
        ret = OneByteString(env->isolate(), peername);
        OPENSSL_free(peername);
      }
      return args.GetReturnValue().Set(ret);
    }
    case 0:  // No Match!
      return;  // No return value is set
    case -2:  // Error!
      return THROW_ERR_INVALID_ARG_VALUE(env, ""Invalid name"");
    default:  // Error!
      return THROW_ERR_CRYPTO_OPERATION_FAILED(env);
  }
}",74,,300,2,,void
69676,BLOCK,-1,,"{
    case 1:  {  // Match!
      Local<Value> ret = args[0];
      if (peername != nullptr) {
        ret = OneByteString(env->isolate(), peername);
        OPENSSL_free(peername);
      }
      return args.GetReturnValue().Set(ret);
    }
    case 0:  // No Match!
      return;  // No return value is set
    case -2:  // Error!
      return THROW_ERR_INVALID_ARG_VALUE(env, ""Invalid name"");
    default:  // Error!
      return THROW_ERR_CRYPTO_OPERATION_FAILED(env);
  }",27,,317,2,,void
69679,BLOCK,3,,"{  // Match!
      Local<Value> ret = args[0];
      if (peername != nullptr) {
        ret = OneByteString(env->isolate(), peername);
        OPENSSL_free(peername);
      }
      return args.GetReturnValue().Set(ret);
    }",14,,318,3,,void
69693,BLOCK,-1,,"{
        ret = OneByteString(env->isolate(), peername);
        OPENSSL_free(peername);
      }",32,,320,2,,void
69731,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());

  CHECK(args[0]->IsString());  // name
  CHECK(args[1]->IsUint32());  // flags

  Utf8Value name(env->isolate(), args[0]);
  uint32_t flags = args[1].As<Uint32>()->Value();

  switch (X509_check_email(
              cert->get(),
              *name,
              name.length(),
              flags)) {
    case 1:  // Match!
      return args.GetReturnValue().Set(args[0]);
    case 0:  // No Match!
      return;  // No return value is set
    case -2:  // Error!
      return THROW_ERR_INVALID_ARG_VALUE(env, ""Invalid name"");
    default:  // Error!
      return THROW_ERR_CRYPTO_OPERATION_FAILED(env);
  }
}",75,,335,2,,void
69796,BLOCK,-1,,"{
    case 1:  // Match!
      return args.GetReturnValue().Set(args[0]);
    case 0:  // No Match!
      return;  // No return value is set
    case -2:  // Error!
      return THROW_ERR_INVALID_ARG_VALUE(env, ""Invalid name"");
    default:  // Error!
      return THROW_ERR_CRYPTO_OPERATION_FAILED(env);
  }",23,,350,2,,void
69828,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());

  CHECK(args[0]->IsString());  // IP
  CHECK(args[1]->IsUint32());  // flags

  Utf8Value name(env->isolate(), args[0]);
  uint32_t flags = args[1].As<Uint32>()->Value();

  switch (X509_check_ip_asc(cert->get(), *name, flags)) {
    case 1:  // Match!
      return args.GetReturnValue().Set(args[0]);
    case 0:  // No Match!
      return;  // No return value is set
    case -2:  // Error!
      return THROW_ERR_INVALID_ARG_VALUE(env, ""Invalid IP"");
    default:  // Error!
      return THROW_ERR_CRYPTO_OPERATION_FAILED(env);
  }
}",72,,362,2,,void
69889,BLOCK,-1,,"{
    case 1:  // Match!
      return args.GetReturnValue().Set(args[0]);
    case 0:  // No Match!
      return;  // No return value is set
    case -2:  // Error!
      return THROW_ERR_INVALID_ARG_VALUE(env, ""Invalid IP"");
    default:  // Error!
      return THROW_ERR_CRYPTO_OPERATION_FAILED(env);
  }",57,,373,2,,void
69921,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());

  CHECK(args[0]->IsObject());
  CHECK(X509Certificate::HasInstance(env, args[0].As<Object>()));

  X509Certificate* issuer;
  ASSIGN_OR_RETURN_UNWRAP(&issuer, args[0]);

  ClearErrorOnReturn clear_error_on_return;

  args.GetReturnValue().Set(
    X509_check_issued(issuer->get(), cert->get()) == X509_V_OK);
}",76,,385,2,,void
69987,BLOCK,-1,,"{
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());

  CHECK(args[0]->IsObject());
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args[0]);
  CHECK_EQ(key->Data()->GetKeyType(), kKeyTypePrivate);

  ClearErrorOnReturn clear_error_on_return;

  args.GetReturnValue().Set(
      X509_check_private_key(
          cert->get(),
          key->Data()->GetAsymmetricKey().get()) == 1);
}",80,,402,2,,void
70048,BLOCK,-1,,"{
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());

  CHECK(args[0]->IsObject());
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args[0]);
  CHECK_EQ(key->Data()->GetKeyType(), kKeyTypePublic);

  ClearErrorOnReturn clear_error_on_return;

  args.GetReturnValue().Set(
      X509_verify(
          cert->get(),
          key->Data()->GetAsymmetricKey().get()) > 0);
}",71,,419,2,,void
70109,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  ClearErrorOnReturn clear_error_on_return;
  Local<Value> ret;
  if (X509ToObject(env, cert->get()).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",73,,436,2,,void
70144,BLOCK,-1,,<empty>,5,,443,2,,void
70157,BLOCK,-1,,"{
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  if (cert->issuer_cert_)
    args.GetReturnValue().Set(cert->issuer_cert_->object());
}",78,,446,2,,void
70170,BLOCK,-1,,<empty>,5,,450,2,,void
70189,BLOCK,-1,,"{
  tracker->TrackField(""cert"", cert_);
}",64,,474,2,,void
70202,BLOCK,-1,,"{
  if (context != env->context()) {
    THROW_ERR_MESSAGE_TARGET_CONTEXT_UNAVAILABLE(env);
    return {};
  }

  Local<Value> handle;
  if (!X509Certificate::New(env, data_).ToLocal(&handle))
    return {};

  return BaseObjectPtr<BaseObject>(
      Unwrap<X509Certificate>(handle.As<Object>()));
}",49,,482,4,,void
70210,BLOCK,-1,,"{
    THROW_ERR_MESSAGE_TARGET_CONTEXT_UNAVAILABLE(env);
    return {};
  }",34,,483,2,,void
70232,BLOCK,-1,,<empty>,5,,490,2,,void
70250,BLOCK,-1,,"{
  return BaseObject::TransferMode::kCloneable;
}",67,,497,1,,void
70260,BLOCK,-1,,"{
  return std::make_unique<X509CertificateTransferData>(cert_);
}",11,,502,1,,void
70274,BLOCK,-1,,"{
  SetMethod(env->context(), target, ""parseX509"", X509Certificate::Parse);

  NODE_DEFINE_CONSTANT(target, X509_CHECK_FLAG_ALWAYS_CHECK_SUBJECT);
  NODE_DEFINE_CONSTANT(target, X509_CHECK_FLAG_NEVER_CHECK_SUBJECT);
  NODE_DEFINE_CONSTANT(target, X509_CHECK_FLAG_NO_WILDCARDS);
  NODE_DEFINE_CONSTANT(target, X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS);
  NODE_DEFINE_CONSTANT(target, X509_CHECK_FLAG_MULTI_LABEL_WILDCARDS);
  NODE_DEFINE_CONSTANT(target, X509_CHECK_FLAG_SINGLE_LABEL_SUBDOMAINS);
}",74,,507,3,,void
70307,BLOCK,-1,,"{
  registry->Register(X509Certificate::Parse);
  registry->Register(Subject);
  registry->Register(SubjectAltName);
  registry->Register(InfoAccess);
  registry->Register(Issuer);
  registry->Register(ValidTo);
  registry->Register(ValidFrom);
  registry->Register(Fingerprint<EVP_sha1>);
  registry->Register(Fingerprint<EVP_sha256>);
  registry->Register(Fingerprint<EVP_sha512>);
  registry->Register(KeyUsage);
  registry->Register(SerialNumber);
  registry->Register(Pem);
  registry->Register(Raw);
  registry->Register(PublicKey);
  registry->Register(CheckCA);
  registry->Register(CheckHost);
  registry->Register(CheckEmail);
  registry->Register(CheckIP);
  registry->Register(CheckIssued);
  registry->Register(CheckPrivateKey);
  registry->Register(Verify);
  registry->Register(ToLegacy);
  registry->Register(GetIssuerCert);
}",42,,519,2,,void
70448,BLOCK,-1,,<empty>,1,,1,1,,ANY
70452,BLOCK,-1,,<empty>,73,,211,2,,void
70459,BLOCK,-1,,<empty>,75,,224,2,,void
70465,BLOCK,-1,,<empty>,59,,240,2,,void
70471,BLOCK,-1,,<empty>,62,,272,2,,void
70480,BLOCK,-1,,"{
          pull_pending_ = false;
          // In each of these cases, we do not expect that the source will
          // actually have provided any actual data.
          CHECK_IMPLIES(status == bob::Status::STATUS_BLOCK ||
                            status == bob::Status::STATUS_WAIT ||
                            status == bob::Status::STATUS_EOS,
                        vecs == nullptr && count == 0);
          if (status == bob::Status::STATUS_EOS) {
            uint32_t current = current_index_.value() + 1;
            current_reader_ = nullptr;
            // We have reached the end of this entry. If this is the last entry,
            // then we are done. Otherwise, we advance the current_index_, clear
            // the current_reader_ and wait for the next read.

            if (current == data_queue_->entries_.size()) {
              // Yes, this was the final entry. We're all done.
              ended_ = true;
            } else {
              // This was not the fina...",80,,248,5,,void
70523,BLOCK,-1,,"{
            uint32_t current = current_index_.value() + 1;
            current_reader_ = nullptr;
            // We have reached the end of this entry. If this is the last entry,
            // then we are done. Otherwise, we advance the current_index_, clear
            // the current_reader_ and wait for the next read.

            if (current == data_queue_->entries_.size()) {
              // Yes, this was the final entry. We're all done.
              ended_ = true;
            } else {
              // This was not the final entry, so we update the index and
              // continue on by performing another read.
              current_index_ = current;
              status = bob::STATUS_CONTINUE;
            }
            std::move(next)(status, nullptr, 0, [](uint64_t) {});
            return;
          }",50,,256,2,,void
70545,BLOCK,-1,,"{
              // Yes, this was the final entry. We're all done.
              ended_ = true;
            }",58,,263,2,,void
70550,BLOCK,-1,,"{
              // This was not the final entry, so we update the index and
              // continue on by performing another read.
              current_index_ = current;
              status = bob::STATUS_CONTINUE;
            }",20,,266,1,,void
70592,BLOCK,-1,,<empty>,73,,364,2,,void
70599,BLOCK,-1,,<empty>,77,,377,2,,void
70605,BLOCK,-1,,<empty>,67,,390,2,,void
70611,BLOCK,-1,,<empty>,73,,403,2,,void
70617,BLOCK,-1,,<empty>,59,,409,2,,void
70623,BLOCK,-1,,<empty>,62,,432,2,,void
70632,BLOCK,-1,,"{
          pull_pending_ = false;

          // In each of these cases, we do not expect that the source will
          // actually have provided any actual data.
          CHECK_IMPLIES(status == bob::Status::STATUS_BLOCK ||
                            status == bob::Status::STATUS_WAIT ||
                            status == bob::Status::STATUS_EOS,
                        vecs == nullptr && count == 0);
          if (status == bob::Status::STATUS_EOS) {
            data_queue_->entries_.erase(data_queue_->entries_.begin());
            ended_ = data_queue_->entries_.empty();
            current_reader_ = nullptr;
            if (!ended_) status = bob::Status::STATUS_CONTINUE;
            std::move(next)(status, nullptr, 0, [](uint64_t) {});
            return;
          }

          // Now that we have updated this readers state, we can forward
          // everything on to the outer next.
          std::move(next)(status, vecs, count, std::move(done));
        }",80,,418,5,,void
70675,BLOCK,-1,,"{
            data_queue_->entries_.erase(data_queue_->entries_.begin());
            ended_ = data_queue_->entries_.empty();
            current_reader_ = nullptr;
            if (!ended_) status = bob::Status::STATUS_CONTINUE;
            std::move(next)(status, nullptr, 0, [](uint64_t) {});
            return;
          }",50,,427,2,,void
70702,BLOCK,-1,,<empty>,26,,431,2,,void
70743,BLOCK,-1,,<empty>,75,,516,2,,void
70750,BLOCK,-1,,<empty>,66,,522,2,,void
70756,BLOCK,-1,,<empty>,75,,586,2,,void
70764,BLOCK,-1,,"{
      if (len == 0) {
        return std::make_unique<EmptyEntry>();
      }

      return std::make_unique<InMemoryEntry>(backing_store_, start, len);
    }",72,,638,3,,void
70769,BLOCK,-1,,"{
        return std::make_unique<EmptyEntry>();
      }",21,,639,2,,void
70793,BLOCK,-1,,{ uv_fs_req_cleanup(&req); },37,,791,1,,void
70803,BLOCK,-1,,{ uv_fs_req_cleanup(&req); },37,,853,1,,void
70812,BLOCK,-1,,{ uv_fs_req_cleanup(&req); },39,,870,1,,void
70823,BLOCK,-1,,<empty>,69,,921,2,,void
70829,BLOCK,-1,,<empty>,77,,927,2,,void
70835,BLOCK,-1,,<empty>,67,,929,2,,void
70841,BLOCK,-1,,<empty>,60,,939,2,,void
70847,BLOCK,-1,,<empty>,67,,953,2,,void
70853,BLOCK,-1,,<empty>,61,,959,2,,void
70859,BLOCK,-1,,<empty>,75,,1000,2,,void
70864,BLOCK,-1,,{ pending_pulls_.pop_front(); },38,,1018,1,,void
70874,BLOCK,-1,,"{
    if (item == nullptr || !item->is_idempotent()) {
      return true;  // true means the entry is not valid here.
    }

    // To keep from having to iterate over the entries
    // again, we'll try calculating the size. If any
    // of the entries are unable to provide a size, then
    // we assume we cannot safely treat this entry as
    // idempotent even if it claims to be.
    if (item->size().has_value()) {
      size += item->size().value();
    } else {
      return true;  // true means the entry is not valid here.
    }

    return false;
  }",46,,1037,2,,void
70885,BLOCK,-1,,"{
      return true;  // true means the entry is not valid here.
    }",52,,1038,2,,void
70896,BLOCK,-1,,"{
      size += item->size().value();
    }",35,,1047,2,,void
70907,BLOCK,-1,,"{
      return true;  // true means the entry is not valid here.
    }",12,,1049,1,,void
70957,BLOCK,-1,,<empty>,1,,1,1,,ANY
70964,BLOCK,-1,,<empty>,,,,1,,<empty>
70971,BLOCK,-1,,<empty>,25,,47,3,,void
70976,BLOCK,-1,,<empty>,57,,55,2,,void
70981,BLOCK,-1,,<empty>,,,,2,,<empty>
70986,BLOCK,-1,,<empty>,,,,2,,<empty>
70991,BLOCK,-1,,<empty>,,,,2,,<empty>
70996,BLOCK,-1,,<empty>,,,,2,,<empty>
71002,BLOCK,-1,,"{
    // If the data queue is not idempotent, or the size cannot be determined,
    // we cannot reasonably create a slice. Therefore, return nothing.
    if (!idempotent_ || !size_.has_value()) return nullptr;

    uint64_t size = size_.value();

    // start cannot be greater than the size.
    start = std::min(start, size);

    uint64_t end = std::max(start, std::min(maybeEnd.value_or(size), size));

    DCHECK_LE(start, end);

    uint64_t len = end - start;
    uint64_t remaining = end - start;
    std::vector<std::unique_ptr<Entry>> slices;

    if (remaining > 0) {
      for (const auto& entry : entries_) {
        // The size of every entry should be known since this is an
        // idempotent queue.
        uint64_t entrySize = entry->size().value();
        if (start > entrySize) {
          start -= entrySize;
          continue;
        }

        uint64_t chunkStart = start;
        uint64_t len = std::min(remaining, entrySize - chunkStart);
        slices.emplace_bac...",65,,65,3,,void
71012,BLOCK,-1,,<empty>,45,,68,2,,void
71078,BLOCK,-1,,"{
      for (const auto& entry : entries_) {
        // The size of every entry should be known since this is an
        // idempotent queue.
        uint64_t entrySize = entry->size().value();
        if (start > entrySize) {
          start -= entrySize;
          continue;
        }

        uint64_t chunkStart = start;
        uint64_t len = std::min(remaining, entrySize - chunkStart);
        slices.emplace_back(entry->slice(chunkStart, chunkStart + len));
        remaining -= len;
        start = 0;

        if (remaining == 0) break;
      }
    }",24,,83,2,,void
71082,BLOCK,-1,,"{
        // The size of every entry should be known since this is an
        // idempotent queue.
        uint64_t entrySize = entry->size().value();
        if (start > entrySize) {
          start -= entrySize;
          continue;
        }

        uint64_t chunkStart = start;
        uint64_t len = std::min(remaining, entrySize - chunkStart);
        slices.emplace_back(entry->slice(chunkStart, chunkStart + len));
        remaining -= len;
        start = 0;

        if (remaining == 0) break;
      }",42,,84,3,,void
71097,BLOCK,-1,,"{
          start -= entrySize;
          continue;
        }",32,,88,2,,void
71139,BLOCK,-1,,<empty>,29,,99,2,,void
71159,BLOCK,-1,,{ return size_; },49,,106,1,,void
71165,BLOCK,-1,,{ return idempotent_; },39,,108,1,,void
71171,BLOCK,-1,,{ return capped_size_.has_value(); },35,,110,1,,void
71181,BLOCK,-1,,"{
    if (idempotent_) return std::nullopt;
    if (!entry) return false;

    // If this entry successfully provides a size, we can add it to our size_
    // if that has a value, otherwise, we keep uint64_t empty.
    if (entry->size().has_value() && size_.has_value()) {
      uint64_t entrySize = entry->size().value();
      uint64_t size = size_.value();
      // If capped_size_ is set, size + entrySize cannot exceed capped_size_
      // or the entry cannot be added.
      if (capped_size_.has_value() &&
          (capped_size_.value() < entrySize + size)) {
        return false;
      }
      size_ = size + entrySize;
    } else {
      // This entry cannot provide a size. We can still add it but we have to
      // clear the known size.
      size_ = std::nullopt;
    }

    entries_.push_back(std::move(entry));
    return true;
  }",69,,112,2,,void
71184,BLOCK,-1,,<empty>,22,,113,2,,void
71192,BLOCK,-1,,<empty>,17,,114,2,,void
71208,BLOCK,-1,,"{
      uint64_t entrySize = entry->size().value();
      uint64_t size = size_.value();
      // If capped_size_ is set, size + entrySize cannot exceed capped_size_
      // or the entry cannot be added.
      if (capped_size_.has_value() &&
          (capped_size_.value() < entrySize + size)) {
        return false;
      }
      size_ = size + entrySize;
    }",57,,118,2,,void
71240,BLOCK,-1,,"{
        return false;
      }",54,,124,2,,void
71249,BLOCK,-1,,"{
      // This entry cannot provide a size. We can still add it but we have to
      // clear the known size.
      size_ = std::nullopt;
    }",12,,128,1,,void
71270,BLOCK,-1,,"{
    if (is_idempotent()) return;
    // If the data queue is already capped, it is possible to call
    // cap again with a smaller size.
    if (capped_size_.has_value()) {
      capped_size_ = std::min(limit, capped_size_.value());
      return;
    }

    // Otherwise just set the limit.
    capped_size_ = limit;
  }",41,,138,2,,void
71273,BLOCK,-1,,<empty>,26,,139,2,,void
71280,BLOCK,-1,,"{
      capped_size_ = std::min(limit, capped_size_.value());
      return;
    }",35,,142,2,,void
71299,BLOCK,-1,,"{
    if (capped_size_.has_value() && size_.has_value()) {
      uint64_t capped_size = capped_size_.value();
      uint64_t size = size_.value();
      return capped_size > size ? capped_size - size : 0UL;
    }
    return std::nullopt;
  }",62,,151,1,,void
71310,BLOCK,-1,,"{
      uint64_t capped_size = capped_size_.value();
      uint64_t size = size_.value();
      return capped_size > size ? capped_size - size : 0UL;
    }",56,,152,2,,void
71342,BLOCK,-1,,"{
    tracker->TrackField(
        ""entries"", entries_, ""std::vector<std::unique_ptr<Entry>>"");
  }",64,,160,2,,void
71353,BLOCK,-1,,<empty>,,,,1,,<empty>
71369,BLOCK,-1,,<empty>,,,,1,,<empty>
71387,BLOCK,-1,,"{
    CHECK(data_queue_->is_idempotent());
  }",44,,190,2,,void
71397,BLOCK,-1,,<empty>,,,,2,,<empty>
71402,BLOCK,-1,,<empty>,,,,2,,<empty>
71407,BLOCK,-1,,<empty>,,,,2,,<empty>
71412,BLOCK,-1,,<empty>,,,,2,,<empty>
71419,BLOCK,-1,,"{
    std::shared_ptr<DataQueue::Reader> self = shared_from_this();

    // If ended is true, this reader has already reached the end and cannot
    // provide any more data.
    if (ended_) {
      std::move(next)(bob::Status::STATUS_EOS, nullptr, 0, [](uint64_t) {});
      return bob::Status::STATUS_EOS;
    }

    // If this is the first pull from this reader, we are first going to
    // check to see if there is anything at all to actually do.
    if (!current_index_.has_value()) {
      // First, let's check the number of entries. If there are no entries,
      // we've reached the end and have nothing to do.
      // Because this is an idempotent dataqueue, we should always know the
      // size...
      if (data_queue_->entries_.empty()) {
        ended_ = true;
        std::move(next)(bob::Status::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        return bob::Status::STATUS_EOS;
      }

      current_index_ = 0;
    }

    // We have current_index_, awesome, we are going to...",65,,205,6,,void
71433,BLOCK,-1,,"{
      std::move(next)(bob::Status::STATUS_EOS, nullptr, 0, [](uint64_t) {});
      return bob::Status::STATUS_EOS;
    }",17,,210,2,,void
71460,BLOCK,-1,,"{
      // First, let's check the number of entries. If there are no entries,
      // we've reached the end and have nothing to do.
      // Because this is an idempotent dataqueue, we should always know the
      // size...
      if (data_queue_->entries_.empty()) {
        ended_ = true;
        std::move(next)(bob::Status::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        return bob::Status::STATUS_EOS;
      }

      current_index_ = 0;
    }",38,,217,2,,void
71468,BLOCK,-1,,"{
        ended_ = true;
        std::move(next)(bob::Status::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        return bob::Status::STATUS_EOS;
      }",42,,222,2,,void
71503,BLOCK,-1,,"{
      // Getting the current reader for an entry could fail for several
      // reasons. For an FdEntry, for instance, getting the reader may
      // fail if the file has been modified since the FdEntry was created.
      // We handle the case simply by erroring.
      std::move(next)(UV_EINVAL, nullptr, 0, [](uint64_t) {});
      return UV_EINVAL;
    }",36,,235,2,,void
71536,BLOCK,-1,,"{
      if (!ended_) return bob::Status::STATUS_CONTINUE;
      // For all other status, we just fall through and return it straightaway.
    }",25,,285,2,,void
71540,BLOCK,-1,,<empty>,20,,286,2,,void
71552,BLOCK,-1,,"{
    CHECK(!ended_);
    CHECK(current_index_.has_value());
    if (current_reader_ == nullptr) {
      auto& entry = data_queue_->entries_[current_index_.value()];
      // Because this is an idempotent reader, let's just be sure to
      // doublecheck that the entry itself is actually idempotent
      DCHECK(entry->is_idempotent());
      current_reader_ = static_cast<EntryImpl&>(*entry).get_reader();
    }
    return current_reader_.get();
  }",41,,308,1,,void
71565,BLOCK,-1,,"{
      auto& entry = data_queue_->entries_[current_index_.value()];
      // Because this is an idempotent reader, let's just be sure to
      // doublecheck that the entry itself is actually idempotent
      DCHECK(entry->is_idempotent());
      current_reader_ = static_cast<EntryImpl&>(*entry).get_reader();
    }",37,,311,2,,void
71604,BLOCK,-1,,<empty>,,,,1,,<empty>
71623,BLOCK,-1,,"{
    CHECK(!data_queue_->is_idempotent());
  }",44,,342,2,,void
71634,BLOCK,-1,,<empty>,,,,2,,<empty>
71639,BLOCK,-1,,<empty>,,,,2,,<empty>
71644,BLOCK,-1,,<empty>,,,,2,,<empty>
71649,BLOCK,-1,,<empty>,,,,2,,<empty>
71656,BLOCK,-1,,"{
    std::shared_ptr<DataQueue::Reader> self = shared_from_this();

    // If ended is true, this reader has already reached the end and cannot
    // provide any more data.
    if (ended_) {
      std::move(next)(bob::Status::STATUS_EOS, nullptr, 0, [](uint64_t) {});
      return bob::Status::STATUS_EOS;
    }

    // If the collection of entries is empty, there's nothing currently left to
    // read. How we respond depends on whether the data queue has been capped
    // or not.
    if (data_queue_->entries_.empty()) {
      // If the data_queue_ is empty, and not capped, then we can reasonably
      // expect more data to be provided later, but we don't know exactly when
      // that'll happe, so the proper response here is to return a blocked
      // status.
      if (!data_queue_->is_capped()) {
        std::move(next)(bob::Status::STATUS_BLOCK, nullptr, 0, [](uint64_t) {});
        return bob::STATUS_BLOCK;
      }

      // However, if we are capped, the status will depen...",65,,358,6,,void
71670,BLOCK,-1,,"{
      std::move(next)(bob::Status::STATUS_EOS, nullptr, 0, [](uint64_t) {});
      return bob::Status::STATUS_EOS;
    }",17,,363,2,,void
71698,BLOCK,-1,,"{
      // If the data_queue_ is empty, and not capped, then we can reasonably
      // expect more data to be provided later, but we don't know exactly when
      // that'll happe, so the proper response here is to return a blocked
      // status.
      if (!data_queue_->is_capped()) {
        std::move(next)(bob::Status::STATUS_BLOCK, nullptr, 0, [](uint64_t) {});
        return bob::STATUS_BLOCK;
      }

      // However, if we are capped, the status will depend on whether the size
      // of the data_queue_ is known or not.

      if (data_queue_->size().has_value()) {
        // If the size is known, and it is still less than the cap, then we
        // still might get more data. We just don't know exactly when that'll
        // come, so let's return a blocked status.
        if (data_queue_->size().value() < data_queue_->capped_size_.value()) {
          std::move(next)(
              bob::Status::STATUS_BLOCK, nullptr, 0, [](uint64_t) {});
          return bob::STATUS_BLO...",40,,371,2,,void
71705,BLOCK,-1,,"{
        std::move(next)(bob::Status::STATUS_BLOCK, nullptr, 0, [](uint64_t) {});
        return bob::STATUS_BLOCK;
      }",38,,376,2,,void
71732,BLOCK,-1,,"{
        // If the size is known, and it is still less than the cap, then we
        // still might get more data. We just don't know exactly when that'll
        // come, so let's return a blocked status.
        if (data_queue_->size().value() < data_queue_->capped_size_.value()) {
          std::move(next)(
              bob::Status::STATUS_BLOCK, nullptr, 0, [](uint64_t) {});
          return bob::STATUS_BLOCK;
        }

        // Otherwise, if size is equal to or greater than capped, we are done.
        // Fall through to allow the end handling to run.
      }",44,,384,2,,void
71748,BLOCK,-1,,"{
          std::move(next)(
              bob::Status::STATUS_BLOCK, nullptr, 0, [](uint64_t) {});
          return bob::STATUS_BLOCK;
        }",78,,388,2,,void
71799,BLOCK,-1,,"{
      std::move(next)(UV_EINVAL, nullptr, 0, [](uint64_t) {});
      return UV_EINVAL;
    }",36,,408,2,,void
71832,BLOCK,-1,,"{
      // The callback was resolved synchronously. Let's check our status.
      if (!ended_) return bob::Status::STATUS_CONTINUE;
      // For all other status, we just fall through and return it straightaway.
    }",25,,445,2,,void
71836,BLOCK,-1,,<empty>,20,,447,2,,void
71848,BLOCK,-1,,"{
    CHECK(!ended_);
    CHECK(!data_queue_->entries_.empty());
    if (current_reader_ == nullptr) {
      auto& entry = data_queue_->entries_.front();
      current_reader_ = static_cast<EntryImpl&>(*entry).get_reader();
    }
    return current_reader_.get();
  }",41,,469,1,,void
71864,BLOCK,-1,,"{
      auto& entry = data_queue_->entries_.front();
      current_reader_ = static_cast<EntryImpl&>(*entry).get_reader();
    }",37,,472,2,,void
71895,BLOCK,-1,,<empty>,,,,1,,<empty>
71908,BLOCK,-1,,"{
  if (is_idempotent()) {
    return std::make_shared<IdempotentDataQueueReader>(shared_from_this());
  }

  if (locked_to_reader_) return nullptr;
  locked_to_reader_ = true;

  return std::make_shared<NonIdempotentDataQueueReader>(shared_from_this());
}",64,,490,1,,void
71911,BLOCK,-1,,"{
    return std::make_shared<IdempotentDataQueueReader>(shared_from_this());
  }",24,,491,2,,void
71922,BLOCK,-1,,<empty>,26,,495,2,,void
71945,BLOCK,-1,,"{
      auto self = shared_from_this();
      if (ended_) {
        std::move(next)(bob::Status::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        return bob::Status::STATUS_EOS;
      }

      ended_ = true;
      std::move(next)(
          bob::Status::STATUS_CONTINUE, nullptr, 0, [](uint64_t) {});
      return bob::Status::STATUS_CONTINUE;
    }",67,,513,6,,void
71952,BLOCK,-1,,"{
        std::move(next)(bob::Status::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        return bob::Status::STATUS_EOS;
      }",19,,515,2,,void
72000,BLOCK,-1,,<empty>,,,,1,,<empty>
72005,BLOCK,-1,,<empty>,,,,2,,<empty>
72010,BLOCK,-1,,<empty>,,,,2,,<empty>
72015,BLOCK,-1,,<empty>,,,,2,,<empty>
72020,BLOCK,-1,,<empty>,,,,2,,<empty>
72024,BLOCK,-1,,"{
    return std::make_shared<EmptyReader>();
  }",60,,542,1,,void
72035,BLOCK,-1,,"{
    if (start != 0) return nullptr;
    return std::make_unique<EmptyEntry>();
  }",65,,548,3,,void
72040,BLOCK,-1,,<empty>,21,,549,2,,void
72051,BLOCK,-1,,{ return 0; },49,,553,1,,void
72057,BLOCK,-1,,{ return true; },39,,555,1,,void
72067,BLOCK,-1,,{ backing_store = nullptr; },31,,570,2,,void
72075,BLOCK,-1,,<empty>,58,,577,2,,void
72084,BLOCK,-1,,"{
      auto self = shared_from_this();
      if (ended_) {
        std::move(next)(bob::Status::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        return bob::Status::STATUS_EOS;
      }

      ended_ = true;
      DataQueue::Vec vec{
          reinterpret_cast<uint8_t*>(entry_.backing_store_->Data()) +
              entry_.offset_,
          entry_.byte_length_,
      };

      std::move(next)(bob::Status::STATUS_CONTINUE,
                      &vec,
                      1,
                      InMemoryFunctor({entry_.backing_store_}));
      return bob::Status::STATUS_CONTINUE;
    }",67,,583,6,,void
72091,BLOCK,-1,,"{
        std::move(next)(bob::Status::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        return bob::Status::STATUS_EOS;
      }",19,,585,2,,void
72164,BLOCK,-1,,<empty>,,,,1,,<empty>
72174,BLOCK,-1,,"{
    // The offset_ + byte_length_ cannot extend beyond the size of the
    // backing store, because that would just be silly.
    CHECK_LE(offset_ + byte_length_, backing_store_->ByteLength());
  }",35,,618,4,,void
72187,BLOCK,-1,,<empty>,,,,2,,<empty>
72192,BLOCK,-1,,<empty>,,,,2,,<empty>
72197,BLOCK,-1,,<empty>,,,,2,,<empty>
72202,BLOCK,-1,,<empty>,,,,2,,<empty>
72206,BLOCK,-1,,"{
    return std::make_shared<InMemoryReader>(*this);
  }",60,,630,1,,void
72220,BLOCK,-1,,"{
    const auto makeEntry = [&](uint64_t start,
                               uint64_t len) -> std::unique_ptr<Entry> {
      if (len == 0) {
        return std::make_unique<EmptyEntry>();
      }

      return std::make_unique<InMemoryEntry>(backing_store_, start, len);
    };

    start += offset_;

    // The start cannot extend beyond the maximum end point of this entry.
    start = std::min(start, offset_ + byte_length_);

    if (maybeEnd.has_value()) {
      uint64_t end = maybeEnd.value();
      // The end cannot extend beyond the maximum end point of this entry,
      // and the end must be equal to or greater than the start.
      end = std::max(start, std::min(offset_ + end, offset_ + byte_length_));

      return makeEntry(start, end - start);
    }

    // If no end is given, then the new length is the current length
    // minus the adjusted start.
    return makeEntry(start, byte_length_ - start);
  }",65,,636,3,,void
72243,BLOCK,-1,,"{
      uint64_t end = maybeEnd.value();
      // The end cannot extend beyond the maximum end point of this entry,
      // and the end must be equal to or greater than the start.
      end = std::max(start, std::min(offset_ + end, offset_ + byte_length_));

      return makeEntry(start, end - start);
    }",31,,651,2,,void
72283,BLOCK,-1,,{ return byte_length_; },49,,665,1,,void
72289,BLOCK,-1,,{ return true; },39,,667,1,,void
72296,BLOCK,-1,,"{
    tracker->TrackField(
        ""store"", backing_store_, ""std::shared_ptr<v8::BackingStore>"");
  }",64,,669,2,,void
72317,BLOCK,-1,,"{
    CHECK(data_queue_);
  }",44,,691,2,,void
72324,BLOCK,-1,,<empty>,,,,2,,<empty>
72329,BLOCK,-1,,<empty>,,,,2,,<empty>
72334,BLOCK,-1,,<empty>,,,,2,,<empty>
72339,BLOCK,-1,,<empty>,,,,2,,<empty>
72343,BLOCK,-1,,"{
    return std::make_shared<ReaderImpl>(data_queue_->get_reader());
  }",60,,701,1,,void
72360,BLOCK,-1,,"{
    std::shared_ptr<DataQueue> sliced = data_queue_->slice(start, end);
    if (!sliced) return nullptr;

    return std::make_unique<DataQueueEntry>(std::move(sliced));
  }",76,,706,3,,void
72378,BLOCK,-1,,<empty>,18,,708,2,,void
72396,BLOCK,-1,,{ return data_queue_->size(); },49,,719,1,,void
72405,BLOCK,-1,,{ return data_queue_->is_idempotent(); },39,,727,1,,void
72415,BLOCK,-1,,"{
    tracker->TrackField(
        ""data_queue"", data_queue_, ""std::shared_ptr<DataQueue>"");
  }",64,,729,2,,void
72426,BLOCK,-1,,{ return *data_queue_; },29,,734,1,,void
72440,BLOCK,-1,,<empty>,36,,746,2,,void
72449,BLOCK,-1,,"{
      auto self = shared_from_this();
      return inner_->Pull(
          std::move(next), options, data, count, max_count_hint);
    }",46,,752,6,,void
72474,BLOCK,-1,,"{
    // We're only going to create the FdEntry if the file exists.
    uv_fs_t req = uv_fs_t();
    auto cleanup = OnScopeLeave([&] { uv_fs_req_cleanup(&req); });

    auto buf = std::make_shared<BufferValue>(env->isolate(), path);
    if (uv_fs_stat(nullptr, &req, buf->out(), nullptr) < 0) return nullptr;

    return std::make_unique<FdEntry>(
        env, std::move(buf), req.statbuf, 0, req.statbuf.st_size);
  }",79,,788,3,,void
72511,BLOCK,-1,,<empty>,61,,794,2,,void
72546,BLOCK,-1,,<empty>,19,,809,6,,void
72550,BLOCK,-1,,"{
    return ReaderImpl::Create(this);
  }",60,,811,1,,void
72562,BLOCK,-1,,"{
    uint64_t new_start = start_ + start;
    uint64_t new_end = end_;
    if (end.has_value()) {
      new_end = std::min(end.value(), end_);
    }

    CHECK(new_start >= start_);
    CHECK(new_end <= end_);

    return std::make_unique<FdEntry>(env_, path_, stat_, new_start, new_end);
  }",76,,816,3,,void
72578,BLOCK,-1,,"{
      new_end = std::min(end.value(), end_);
    }",26,,819,2,,void
72615,BLOCK,-1,,{ return end_ - start_; },49,,829,1,,void
72623,BLOCK,-1,,{ return true; },39,,831,1,,void
72629,BLOCK,-1,,{ return env_; },28,,833,1,,void
72641,BLOCK,-1,,"{
    return other.st_size != stat_.st_size ||
           other.st_mtim.tv_nsec != stat_.st_mtim.tv_nsec;
  }",44,,846,2,,void
72667,BLOCK,-1,,"{
    uv_fs_t req = uv_fs_t();
    auto cleanup = OnScopeLeave([&] { uv_fs_req_cleanup(&req); });
    // TODO(jasnell): Note the use of a sync fs call here is a bit unfortunate.
    // Doing this asynchronously creates a bit of a race condition tho, a file
    // could be unmodified when we call the operation but then by the time the
    // async callback is triggered to give us that answer the file is modified.
    // While such silliness is still possible here, the sync call at least makes
    // it less likely to hit the race.
    if (uv_fs_fstat(nullptr, &req, fd, nullptr) < 0) return true;
    return entry->is_modified(req.statbuf);
  }",53,,851,3,,void
72685,BLOCK,-1,,<empty>,54,,860,2,,void
72700,BLOCK,-1,,"{
      uv_fs_t req;
      auto cleanup = OnScopeLeave([&] { uv_fs_req_cleanup(&req); });
      int file =
          uv_fs_open(nullptr, &req, entry->path_->out(), O_RDONLY, 0, nullptr);
      if (file < 0 || FdEntry::CheckModified(entry, file)) {
        uv_fs_close(nullptr, &req, file, nullptr);
        return nullptr;
      }
      Realm* realm = entry->env()->principal_realm();
      return std::make_shared<ReaderImpl>(
          BaseObjectPtr<fs::FileHandle>(fs::FileHandle::New(
              realm->GetBindingData<fs::BindingData>(realm->context()),
              file,
              Local<Object>(),
              entry->start_,
              entry->end_ - entry->start_)),
          entry);
    }",63,,868,2,,void
72733,BLOCK,-1,,"{
        uv_fs_close(nullptr, &req, file, nullptr);
        return nullptr;
      }",60,,873,2,,void
72803,BLOCK,-1,,"{
      handle_->PushStreamListener(this);
      handle_->env()->AddCleanupHook(cleanup, this);
    }",74,,889,3,,void
72821,BLOCK,-1,,"{
      handle_->env()->RemoveCleanupHook(cleanup, this);
      DrainAndClose();
      handle_->RemoveStreamListener(this);
    }",28,,894,1,,void
72841,BLOCK,-1,,"{
      return env_->allocate_managed_buffer(suggested_size);
    }",60,,900,2,,void
72853,BLOCK,-1,,"{
      std::shared_ptr<v8::BackingStore> store =
          env_->release_managed_buffer(buf);

      if (ended_) {
        // If we got here and ended_ is true, it means we ended and drained
        // while the read was pending. We're just going to do nothing.
        CHECK(pending_pulls_.empty());
        return;
      }

      CHECK(reading_);
      auto pending = DequeuePendingPull();

      if (CheckModified(entry_, handle_->GetFD())) {
        DrainAndClose();
        // The file was modified while the read was pending. We need to error.
        std::move(pending.next)(UV_EINVAL, nullptr, 0, [](uint64_t) {});
        return;
      }

      if (nread < 0) {
        if (nread == UV_EOF) {
          std::move(pending.next)(bob::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        } else {
          std::move(pending.next)(nread, nullptr, 0, [](uint64_t) {});
        }

        return DrainAndClose();
      }

      DataQueue::Vec vec;
      vec.base = static_cast<uint8_t*>(store->D...",68,,904,3,,void
72871,BLOCK,-1,,"{
        // If we got here and ended_ is true, it means we ended and drained
        // while the read was pending. We're just going to do nothing.
        CHECK(pending_pulls_.empty());
        return;
      }",19,,908,2,,void
72891,BLOCK,-1,,"{
        DrainAndClose();
        // The file was modified while the read was pending. We need to error.
        std::move(pending.next)(UV_EINVAL, nullptr, 0, [](uint64_t) {});
        return;
      }",52,,918,2,,void
72910,BLOCK,-1,,"{
        if (nread == UV_EOF) {
          std::move(pending.next)(bob::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        } else {
          std::move(pending.next)(nread, nullptr, 0, [](uint64_t) {});
        }

        return DrainAndClose();
      }",22,,925,2,,void
72915,BLOCK,-1,,"{
          std::move(pending.next)(bob::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        }",30,,926,2,,void
72931,BLOCK,-1,,"{
          std::move(pending.next)(nread, nullptr, 0, [](uint64_t) {});
        }",16,,928,1,,void
72984,BLOCK,-1,,"{
        reading_ = false;
        if (handle_->IsAlive()) handle_->ReadStop();
      }",35,,941,2,,void
72993,BLOCK,-1,,<empty>,33,,943,2,,void
73006,BLOCK,-1,,"{
      if (ended_ || !handle_->IsAlive()) {
        std::move(next)(bob::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        return bob::STATUS_EOS;
      }

      if (FdEntry::CheckModified(entry_, handle_->GetFD())) {
        DrainAndClose();
        std::move(next)(UV_EINVAL, nullptr, 0, [](uint64_t) {});
        return UV_EINVAL;
      }

      pending_pulls_.emplace_back(std::move(next), shared_from_this());
      if (!reading_) {
        reading_ = true;
        handle_->ReadStart();
      }
      return bob::STATUS_WAIT;
    }",67,,951,6,,void
73015,BLOCK,-1,,"{
        std::move(next)(bob::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        return bob::STATUS_EOS;
      }",42,,952,2,,void
73042,BLOCK,-1,,"{
        DrainAndClose();
        std::move(next)(UV_EINVAL, nullptr, 0, [](uint64_t) {});
        return UV_EINVAL;
      }",61,,957,2,,void
73069,BLOCK,-1,,"{
        reading_ = true;
        handle_->ReadStart();
      }",22,,964,2,,void
73092,BLOCK,-1,,"{
      auto ptr = static_cast<ReaderImpl*>(self);
      ptr->DrainAndClose();
    }",37,,990,2,,void
73106,BLOCK,-1,,"{
      if (ended_) return;
      ended_ = true;
      while (!pending_pulls_.empty()) {
        auto pending = DequeuePendingPull();
        std::move(pending.next)(bob::STATUS_EOS, nullptr, 0, [](uint64_t) {});
      }
      handle_->ReadStop();

      // We fallback to a sync close on the raw fd here because it is the
      // easiest, simplest thing to do. All of FileHandle's close mechanisms
      // assume async close and cleanup, while DrainAndClose might be running
      // in the destructor during GC, for instance. As a todo, FileHandle could
      // provide a sync mechanism for closing the FD but, for now, this
      // approach works.
      int fd = handle_->Release();
      uv_fs_t req;
      uv_fs_close(nullptr, &req, fd, nullptr);
      uv_fs_req_cleanup(&req);
    }",26,,995,1,,void
73109,BLOCK,-1,,<empty>,19,,996,2,,void
73120,BLOCK,-1,,"{
        auto pending = DequeuePendingPull();
        std::move(pending.next)(bob::STATUS_EOS, nullptr, 0, [](uint64_t) {});
      }",39,,998,2,,void
73163,BLOCK,-1,,"{
      CHECK(!pending_pulls_.empty());
      auto pop = OnScopeLeave([this] { pending_pulls_.pop_front(); });
      return std::move(pending_pulls_.front());
    }",38,,1016,1,,void
73188,BLOCK,-1,,<empty>,,,,1,,<empty>
73199,BLOCK,-1,,<empty>,,,,1,,<empty>
73210,BLOCK,-1,,"{
  // Any entry is invalid for an idempotent DataQueue if any of the entries
  // are nullptr or is not idempotent.
  uint64_t size = 0;
  const auto isInvalid = [&size](auto& item) {
    if (item == nullptr || !item->is_idempotent()) {
      return true;  // true means the entry is not valid here.
    }

    // To keep from having to iterate over the entries
    // again, we'll try calculating the size. If any
    // of the entries are unable to provide a size, then
    // we assume we cannot safely treat this entry as
    // idempotent even if it claims to be.
    if (item->size().has_value()) {
      size += item->size().value();
    } else {
      return true;  // true means the entry is not valid here.
    }

    return false;
  };

  if (std::any_of(list.begin(), list.end(), isInvalid)) {
    return nullptr;
  }

  return std::make_shared<DataQueueImpl>(std::move(list), size);
}",47,,1033,2,,void
73232,BLOCK,-1,,"{
    return nullptr;
  }",57,,1056,2,,void
73254,BLOCK,-1,,"{
  return std::make_shared<DataQueueImpl>(capped);
}",78,,1063,2,,void
73267,BLOCK,-1,,"{
  // If the view is not detachable, we do not want to create an InMemoryEntry
  // from it. Why? Because if we're not able to detach the backing store from
  // the underlying buffer, something else could modify the buffer while we're
  // holding the reference, which means we cannot guarantee that reads will be
  // idempotent.
  if (!view->Buffer()->IsDetachable()) {
    return nullptr;
  }
  auto store = view->Buffer()->GetBackingStore();
  auto offset = view->ByteOffset();
  auto length = view->ByteLength();
  USE(view->Buffer()->Detach(Local<Value>()));
  return CreateInMemoryEntryFromBackingStore(std::move(store), offset, length);
}",34,,1068,2,,void
73277,BLOCK,-1,,"{
    return nullptr;
  }",40,,1074,2,,void
73328,BLOCK,-1,,"{
  CHECK(store);
  if (offset + length > store->ByteLength()) {
    return nullptr;
  }
  return std::make_unique<InMemoryEntry>(std::move(store), offset, length);
}",76,,1086,4,,void
73340,BLOCK,-1,,"{
    return nullptr;
  }",46,,1088,2,,void
73363,BLOCK,-1,,"{
  return std::make_unique<DataQueueEntry>(std::move(data_queue));
}",44,,1095,2,,void
73381,BLOCK,-1,,"{
  return FdEntry::Create(env, path);
}",79,,1100,3,,void
73394,BLOCK,-1,,"{
  // Nothing to do here currently.
}",76,,1104,3,,void
73399,BLOCK,-1,,"{
  // Nothing to do here currently.
}",42,,1109,2,,void
73428,BLOCK,-1,,<empty>,1,,1,1,,ANY
73439,BLOCK,-1,,<empty>,1,,1,1,,ANY
73444,BLOCK,-1,,"{
    Info* info = static_cast<Info*>(arg);
    NativeSymbolDebuggingContext* sym_ctx = info->ctx.get();
    FILE* stream = info->stream;
    info->num_handles++;

    fprintf(stream, ""[%p] %s%s\n"", handle, uv_handle_type_name(handle->type),
            uv_is_active(handle) ? "" (active)"" : """");

    void* close_cb = reinterpret_cast<void*>(handle->close_cb);
    fprintf(stream, ""\tClose callback: %p %s\n"",
        close_cb, sym_ctx->LookupSymbol(close_cb).Display().c_str());

    fprintf(stream, ""\tData: %p %s\n"",
        handle->data, sym_ctx->LookupSymbol(handle->data).Display().c_str());

    // We are also interested in the first field of what `handle->data`
    // points to, because for C++ code that is usually the virtual table pointer
    // and gives us information about the exact kind of object we're looking at.
    void* first_field = nullptr;
    // `handle->data` might be any value, including `nullptr`, or something
    // cast from a completely different type; therefore...",52,,338,3,,void
73537,BLOCK,-1,,<empty>,7,,362,2,,void
73550,BLOCK,-1,,"{
      fprintf(stream, ""\t(First field): %p %s\n"",
          first_field, sym_ctx->LookupSymbol(first_field).Display().c_str());
    }",33,,364,2,,void
73571,BLOCK,-1,,"{
    // The return value is ignored because there's no good way to handle it.
    fwrite(str.data(), str.size(), 1, file);
  }",30,,477,1,,void
73632,BLOCK,-1,,<empty>,1,,1,1,,ANY
73639,BLOCK,-1,,"{
  std::string cats;
  credentials::SafeGetenv(""NODE_DEBUG_NATIVE"", &cats, env_vars, isolate);
  Parse(cats);
}",52,,63,3,,void
73656,BLOCK,-1,,"{
  std::string debug_categories = cats;
  while (!debug_categories.empty()) {
    std::string::size_type comma_pos = debug_categories.find(',');
    std::string wanted = ToLower(debug_categories.substr(0, comma_pos));

#define V(name)                                                                \
  {                                                                            \
    static const std::string available_category = ToLower(#name);              \
    if (available_category.find(wanted) != std::string::npos)                  \
      set_enabled(DebugCategory::name);                                        \
  }

    DEBUG_CATEGORY_NAMES(V)
#undef V

    if (comma_pos == std::string::npos) break;
    // Use everything after the `,` as the list for the next iteration.
    debug_categories = debug_categories.substr(comma_pos + 1);
  }
}",55,,69,2,,void
73667,BLOCK,-1,,"{
    std::string::size_type comma_pos = debug_categories.find(',');
    std::string wanted = ToLower(debug_categories.substr(0, comma_pos));

#define V(name)                                                                \
  {                                                                            \
    static const std::string available_category = ToLower(#name);              \
    if (available_category.find(wanted) != std::string::npos)                  \
      set_enabled(DebugCategory::name);                                        \
  }

    DEBUG_CATEGORY_NAMES(V)
#undef V

    if (comma_pos == std::string::npos) break;
    // Use everything after the `,` as the list for the next iteration.
    debug_categories = debug_categories.substr(comma_pos + 1);
  }",37,,71,2,,void
73696,BLOCK,-1,,<empty>,41,,85,2,,void
73711,BLOCK,-1,,"{
    current_process_ = GetCurrentProcess();
    USE(SymInitialize(current_process_, nullptr, true));
  }",33,,153,1,,void
73723,BLOCK,-1,,"{
    USE(SymCleanup(current_process_));
  }",43,,158,1,,void
73732,BLOCK,-1,,"{
    // Refs: https://docs.microsoft.com/en-us/windows/desktop/Debug/retrieving-symbol-information-by-address
    // Patches:
    // Use `fprintf(stderr, ` instead of `printf`
    // `sym.filename = pSymbol->Name` on success
    // `current_process_` instead of `hProcess.
    DWORD64 dwDisplacement = 0;
    // Patch: made into arg - DWORD64  dwAddress = SOME_ADDRESS;

    char buffer[sizeof(SYMBOL_INFO) + MAX_SYM_NAME * sizeof(TCHAR)];
    const auto pSymbol = reinterpret_cast<PSYMBOL_INFO>(buffer);

    pSymbol->SizeOfStruct = sizeof(SYMBOL_INFO);
    pSymbol->MaxNameLen = MAX_SYM_NAME;

    if (SymFromAddr(current_process_, dwAddress, &dwDisplacement, pSymbol)) {
      // SymFromAddr returned success
      return NameAndDisplacement(pSymbol->Name, dwDisplacement);
    } else {
      // SymFromAddr failed
      const DWORD error = GetLastError();  // ""eat"" the error anyway
#ifdef DEBUG
      fprintf(stderr, ""SymFromAddr returned error : %lu\n"", error);
#endif
    }
    // End MSDN...",67,,163,2,,void
73762,BLOCK,-1,,"{
      // SymFromAddr returned success
      return NameAndDisplacement(pSymbol->Name, dwDisplacement);
    }",77,,178,2,,void
73770,BLOCK,-1,,"{
      // SymFromAddr failed
      const DWORD error = GetLastError();  // ""eat"" the error anyway
#ifdef DEBUG
      fprintf(stderr, ""SymFromAddr returned error : %lu\n"", error);
#endif
    }",12,,181,1,,void
73781,BLOCK,-1,,"{
    SymbolInfo sym{};

    // Refs: https://docs.microsoft.com/en-us/windows/desktop/Debug/retrieving-symbol-information-by-address
    // Patches:
    // Use `fprintf(stderr, ` instead of `printf`.
    // Assign values to `sym` on success.
    // `current_process_` instead of `hProcess.

    // Patch: made into arg - DWORD64  dwAddress;
    DWORD dwDisplacement;
    IMAGEHLP_LINE64 line;

    SymSetOptions(SYMOPT_LOAD_LINES);

    line.SizeOfStruct = sizeof(IMAGEHLP_LINE64);
    // Patch: made into arg - dwAddress = 0x1000000;

    if (SymGetLineFromAddr64(current_process_, dwAddress,
                             &dwDisplacement, &line)) {
      // SymGetLineFromAddr64 returned success
      sym.filename = line.FileName;
      sym.line = line.LineNumber;
    } else {
      // SymGetLineFromAddr64 failed
      const DWORD error = GetLastError();  // ""eat"" the error anyway
#ifdef DEBUG
      fprintf(stderr, ""SymGetLineFromAddr64 returned error : %lu\n"", error);
#endif
    }
    // ...",54,,193,2,,void
73803,BLOCK,-1,,"{
      // SymGetLineFromAddr64 returned success
      sym.filename = line.FileName;
      sym.line = line.LineNumber;
    }",55,,212,2,,void
73819,BLOCK,-1,,"{
      // SymGetLineFromAddr64 failed
      const DWORD error = GetLastError();  // ""eat"" the error anyway
#ifdef DEBUG
      fprintf(stderr, ""SymGetLineFromAddr64 returned error : %lu\n"", error);
#endif
    }",12,,216,1,,void
73830,BLOCK,-1,,"{
    // Refs: https://docs.microsoft.com/en-us/windows/desktop/Debug/retrieving-undecorated-symbol-names
    // Patches:
    // Use `fprintf(stderr, ` instead of `printf`.
    // return `szUndName` instead of `printf` on success
    char szUndName[MAX_SYM_NAME];
    if (UnDecorateSymbolName(name, szUndName, sizeof(szUndName),
                             UNDNAME_COMPLETE)) {
      // UnDecorateSymbolName returned success
      return szUndName;
    } else {
      // UnDecorateSymbolName failed
      const DWORD error = GetLastError();  // ""eat"" the error anyway
#ifdef DEBUG
      fprintf(stderr, ""UnDecorateSymbolName returned error %lu\n"", error);
#endif
    }
    return nullptr;
  }",67,,229,2,,void
73839,BLOCK,-1,,"{
      // UnDecorateSymbolName returned success
      return szUndName;
    }",49,,236,2,,void
73843,BLOCK,-1,,"{
      // UnDecorateSymbolName failed
      const DWORD error = GetLastError();  // ""eat"" the error anyway
#ifdef DEBUG
      fprintf(stderr, ""UnDecorateSymbolName returned error %lu\n"", error);
#endif
    }",12,,239,1,,void
73854,BLOCK,-1,,"{
    const DWORD64 dw_address = reinterpret_cast<DWORD64>(address);
    SymbolInfo ret = WrappedGetLine(dw_address);
    std::tie(ret.name, ret.dis) = WrappedSymFromAddr(dw_address);
    if (!ret.name.empty()) {
      ret.name = WrappedUnDecorateSymbolName(ret.name.c_str());
    }
    return ret;
  }",51,,249,2,,void
73887,BLOCK,-1,,"{
      ret.name = WrappedUnDecorateSymbolName(ret.name.c_str());
    }",28,,253,2,,void
73905,BLOCK,-1,,"{
    MEMORY_BASIC_INFORMATION info;

    if (VirtualQuery(address, &info, sizeof(info)) != sizeof(info))
      return false;

    return info.State == MEM_COMMIT && info.Protect != 0;
  }",41,,259,2,,void
73917,BLOCK,-1,,<empty>,7,,263,2,,void
73937,BLOCK,-1,,"{
    return CaptureStackBackTrace(0, count, frames, nullptr);
  }",56,,268,3,,void
73948,BLOCK,-1,,<empty>,,,,2,,<empty>
73953,BLOCK,-1,,<empty>,,,,2,,<empty>
73958,BLOCK,-1,,<empty>,,,,2,,<empty>
73963,BLOCK,-1,,<empty>,,,,2,,<empty>
73968,BLOCK,-1,,"{
  return std::unique_ptr<NativeSymbolDebuggingContext>(
      new Win32SymbolDebuggingContext());
}",37,,284,1,,void
73981,BLOCK,-1,,"{
  std::ostringstream oss;
  oss << name;
  if (dis != 0) {
    oss << ""+"" << dis;
  }
  if (!filename.empty()) {
    oss << "" ["" << filename << ']';
  }
  if (line != 0) {
    oss << "":L"" << line;
  }
  return oss.str();
}",71,,291,1,,void
73990,BLOCK,-1,,"{
    oss << ""+"" << dis;
  }",17,,294,2,,void
74002,BLOCK,-1,,"{
    oss << "" ["" << filename << ']';
  }",26,,297,2,,void
74014,BLOCK,-1,,"{
    oss << "":L"" << line;
  }",18,,300,2,,void
74029,BLOCK,-1,,"{
  auto sym_ctx = NativeSymbolDebuggingContext::New();
  void* frames[256];
  const int size = sym_ctx->GetStackTrace(frames, arraysize(frames));
  for (int i = 1; i < size; i += 1) {
    void* frame = frames[i];
    NativeSymbolDebuggingContext::SymbolInfo s = sym_ctx->LookupSymbol(frame);
    fprintf(fp, ""%2d: %p %s\n"", i, frame, s.Display().c_str());
  }
}",30,,306,2,,void
74049,BLOCK,-1,,<empty>,3,,310,1,,void
74060,BLOCK,4,,"{
    void* frame = frames[i];
    NativeSymbolDebuggingContext::SymbolInfo s = sym_ctx->LookupSymbol(frame);
    fprintf(fp, ""%2d: %p %s\n"", i, frame, s.Display().c_str());
  }",37,,310,4,,void
74091,BLOCK,-1,,"{
  if (uv_loop_close(loop) == 0) return;

  PrintLibuvHandleInformation(loop, stderr);

  fflush(stderr);
  // Finally, abort.
  UNREACHABLE(""uv_loop_close() while having open handles"");
}",42,,317,2,,void
74097,BLOCK,-1,,<empty>,33,,318,2,,void
74110,BLOCK,-1,,"{
  struct Info {
    std::unique_ptr<NativeSymbolDebuggingContext> ctx;
    FILE* stream;
    size_t num_handles;
  };

  Info info { NativeSymbolDebuggingContext::New(), stream, 0 };

  fprintf(stream, ""uv loop at [%p] has open handles:\n"", loop);

  uv_walk(loop, [](uv_handle_t* handle, void* arg) {
    Info* info = static_cast<Info*>(arg);
    NativeSymbolDebuggingContext* sym_ctx = info->ctx.get();
    FILE* stream = info->stream;
    info->num_handles++;

    fprintf(stream, ""[%p] %s%s\n"", handle, uv_handle_type_name(handle->type),
            uv_is_active(handle) ? "" (active)"" : """");

    void* close_cb = reinterpret_cast<void*>(handle->close_cb);
    fprintf(stream, ""\tClose callback: %p %s\n"",
        close_cb, sym_ctx->LookupSymbol(close_cb).Display().c_str());

    fprintf(stream, ""\tData: %p %s\n"",
        handle->data, sym_ctx->LookupSymbol(handle->data).Display().c_str());

    // We are also interested in the first field of what `handle->data`
    // points to, becaus...",65,,327,3,,void
74140,BLOCK,-1,,"{
  std::vector<std::string> list;
#if defined(__linux__) || defined(__FreeBSD__) || \
    defined(__OpenBSD__) || defined(__DragonFly__)
  dl_iterate_phdr(
      [](struct dl_phdr_info* info, size_t size, void* data) {
        auto list = static_cast<std::vector<std::string>*>(data);
        if (*info->dlpi_name != '\0') {
          list->emplace_back(info->dlpi_name);
        }
        return 0;
      },
      &list);
#elif __APPLE__
  uint32_t i = 0;
  for (const char* name = _dyld_get_image_name(i); name != nullptr;
       name = _dyld_get_image_name(++i)) {
    list.emplace_back(name);
  }

#elif _AIX
  // We can't tell in advance how large the buffer needs to be.
  // Retry until we reach too large a size (1Mb).
  const unsigned int kBufferGrowStep = 4096;
  MallocedBuffer<char> buffer(kBufferGrowStep);
  int rc = -1;
  do {
    rc = loadquery(L_GETINFO, buffer.data, buffer.size);
    if (rc == 0) break;
    buffer = MallocedBuffer<char>(buffer.size + kBufferGrowStep);
  } whi...",77,,374,1,,void
74155,BLOCK,-1,,"{
  auto simple_fwrite = [&]() {
    // The return value is ignored because there's no good way to handle it.
    fwrite(str.data(), str.size(), 1, file);
  };

  if (file != stderr && file != stdout) {
    simple_fwrite();
    return;
  }
#ifdef _WIN32
  HANDLE handle =
      GetStdHandle(file == stdout ? STD_OUTPUT_HANDLE : STD_ERROR_HANDLE);

  // Check if stderr is something other than a tty/console
  if (handle == INVALID_HANDLE_VALUE || handle == nullptr ||
      uv_guess_handle(_fileno(file)) != UV_TTY) {
    simple_fwrite();
    return;
  }

  // Get required wide buffer size
  int n = MultiByteToWideChar(CP_UTF8, 0, str.data(), str.size(), nullptr, 0);

  std::vector<wchar_t> wbuf(n);
  MultiByteToWideChar(CP_UTF8, 0, str.data(), str.size(), wbuf.data(), n);

  WriteConsoleW(handle, wbuf.data(), n, nullptr, nullptr);
  return;
#elif defined(__ANDROID__)
  if (file == stderr) {
    __android_log_print(ANDROID_LOG_ERROR, ""nodejs"", ""%s"", str.data());
    return;
  }
#endif
  s...",49,,476,3,,void
74168,BLOCK,-1,,"{
    simple_fwrite();
    return;
  }",41,,482,2,,void
74176,BLOCK,-1,,"{
  node::DumpBacktrace(fp);
}",43,,516,2,,void
74198,BLOCK,-1,,<empty>,1,,1,1,,ANY
74205,BLOCK,-1,,<empty>,1,,1,1,,ANY
74228,BLOCK,-1,,<empty>,1,,1,1,,ANY
74233,BLOCK,-1,,"{
  tracker->TrackField(""encode_into_results_buffer"",
                      encode_into_results_buffer_);
}",60,,28,2,,void
74246,BLOCK,-1,,"{
  if (info == nullptr) {
    object
        ->Set(realm->context(),
              FIXED_ONE_BYTE_STRING(realm->isolate(), ""encodeIntoResults""),
              encode_into_results_buffer_.GetJSArray())
        .Check();
  } else {
    encode_into_results_buffer_.Deserialize(realm->context());
  }
  encode_into_results_buffer_.MakeWeak();
}",62,,40,4,,void
74251,BLOCK,-1,,"{
    object
        ->Set(realm->context(),
              FIXED_ONE_BYTE_STRING(realm->isolate(), ""encodeIntoResults""),
              encode_into_results_buffer_.GetJSArray())
        .Check();
  }",24,,41,2,,void
74274,BLOCK,-1,,"{
    encode_into_results_buffer_.Deserialize(realm->context());
  }",10,,47,1,,void
74292,BLOCK,-1,,"{
  DCHECK_NULL(internal_field_info_);
  internal_field_info_ = InternalFieldInfoBase::New<InternalFieldInfo>(type());
  internal_field_info_->encode_into_results_buffer =
      encode_into_results_buffer_.Serialize(context, creator);
  // Return true because we need to maintain the reference to the binding from
  // JS land.
  return true;
}",73,,54,3,,void
74319,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  InternalFieldInfo* info = internal_field_info_;
  internal_field_info_ = nullptr;
  return info;
}",58,,64,2,,void
74341,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  v8::HandleScope scope(context->GetIsolate());
  Realm* realm = Realm::GetCurrent(context);
  // Recreate the buffer in the constructor.
  InternalFieldInfo* casted_info = static_cast<InternalFieldInfo*>(info);
  BindingData* binding =
      realm->AddBindingData<BindingData>(context, holder, casted_info);
  CHECK_NOT_NULL(binding);
}",60,,74,5,,void
74387,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  CHECK_GE(args.Length(), 2);
  CHECK(args[0]->IsString());
  CHECK(args[1]->IsUint8Array());
  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);

  Local<String> source = args[0].As<String>();

  Local<Uint8Array> dest = args[1].As<Uint8Array>();
  Local<ArrayBuffer> buf = dest->Buffer();
  char* write_result = static_cast<char*>(buf->Data()) + dest->ByteOffset();
  size_t dest_length = dest->ByteLength();

  int nchars;
  int written = source->WriteUtf8(
      isolate,
      write_result,
      dest_length,
      &nchars,
      String::NO_NULL_TERMINATION | String::REPLACE_INVALID_UTF8);

  binding_data->encode_into_results_buffer_[0] = nchars;
  binding_data->encode_into_results_buffer_[1] = written;
}",71,,85,2,,void
74526,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());

  Local<String> str = args[0].As<String>();
  size_t length = str->Utf8Length(isolate);

  Local<ArrayBuffer> ab;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    std::unique_ptr<BackingStore> bs =
        ArrayBuffer::NewBackingStore(isolate, length);

    CHECK(bs);

    str->WriteUtf8(isolate,
                   static_cast<char*>(bs->Data()),
                   -1,  // We are certain that `data` is sufficiently large
                   nullptr,
                   String::NO_NULL_TERMINATION | String::REPLACE_INVALID_UTF8);

    ab = ArrayBuffer::New(isolate, std::move(bs));
  }

  auto array = Uint8Array::New(ab, 0, length);
  args.GetReturnValue().Set(array);
}",77,,114,2,,void
74580,BLOCK,11,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    std::unique_ptr<BackingStore> bs =
        ArrayBuffer::NewBackingStore(isolate, length);

    CHECK(bs);

    str->WriteUtf8(isolate,
                   static_cast<char*>(bs->Data()),
                   -1,  // We are certain that `data` is sufficiently large
                   nullptr,
                   String::NO_NULL_TERMINATION | String::REPLACE_INVALID_UTF8);

    ab = ArrayBuffer::New(isolate, std::move(bs));
  }",3,,124,11,,void
74657,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);  // list, flags

  CHECK_GE(args.Length(), 1);

  if (!(args[0]->IsArrayBuffer() || args[0]->IsSharedArrayBuffer() ||
        args[0]->IsArrayBufferView())) {
    return node::THROW_ERR_INVALID_ARG_TYPE(
        env->isolate(),
        ""The \""list\"" argument must be an instance of SharedArrayBuffer, ""
        ""ArrayBuffer or ArrayBufferView."");
  }

  ArrayBufferViewContents<char> buffer(args[0]);

  bool ignore_bom = args[1]->IsTrue();
  bool has_fatal = args[2]->IsTrue();

  const char* data = buffer.data();
  size_t length = buffer.length();

  if (has_fatal) {
    auto result = simdutf::validate_utf8_with_errors(data, length);

    if (result.error) {
      return node::THROW_ERR_ENCODING_INVALID_ENCODED_DATA(
          env->isolate(), ""The encoded data was not valid for encoding utf-8"");
    }
  }

  if (!ignore_bom && length >= 3) {
    if (memcmp(data, ""\xEF\xBB\xBF"", 3) == 0) {
      data += 3;
      length -= 3;
    }
  ...",71,,145,2,,void
74694,BLOCK,-1,,"{
    return node::THROW_ERR_INVALID_ARG_TYPE(
        env->isolate(),
        ""The \""list\"" argument must be an instance of SharedArrayBuffer, ""
        ""ArrayBuffer or ArrayBufferView."");
  }",40,,151,2,,void
74744,BLOCK,-1,,"{
    auto result = simdutf::validate_utf8_with_errors(data, length);

    if (result.error) {
      return node::THROW_ERR_ENCODING_INVALID_ENCODED_DATA(
          env->isolate(), ""The encoded data was not valid for encoding utf-8"");
    }
  }",18,,166,2,,void
74758,BLOCK,-1,,"{
      return node::THROW_ERR_ENCODING_INVALID_ENCODED_DATA(
          env->isolate(), ""The encoded data was not valid for encoding utf-8"");
    }",23,,169,2,,void
74776,BLOCK,-1,,"{
    if (memcmp(data, ""\xEF\xBB\xBF"", 3) == 0) {
      data += 3;
      length -= 3;
    }
  }",35,,175,2,,void
74784,BLOCK,-1,,"{
      data += 3;
      length -= 3;
    }",47,,176,2,,void
74795,BLOCK,-1,,<empty>,20,,182,2,,void
74841,BLOCK,-1,,"{
    CHECK(!error.IsEmpty());
    env->isolate()->ThrowException(error);
    return;
  }",33,,189,2,,void
74869,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());

  Utf8Value input(env->isolate(), args[0]);
  auto out = ada::idna::to_ascii(input.ToStringView());
  args.GetReturnValue().Set(
      String::NewFromUtf8(env->isolate(), out.c_str()).ToLocalChecked());
}",76,,198,2,,void
74939,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());

  Utf8Value input(env->isolate(), args[0]);
  auto out = ada::idna::to_unicode(input.ToStringView());
  args.GetReturnValue().Set(
      String::NewFromUtf8(env->isolate(), out.c_str()).ToLocalChecked());
}",78,,209,2,,void
75010,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();
  SetMethod(isolate, target, ""encodeInto"", EncodeInto);
  SetMethodNoSideEffect(isolate, target, ""encodeUtf8String"", EncodeUtf8String);
  SetMethodNoSideEffect(isolate, target, ""decodeUTF8"", DecodeUTF8);
  SetMethodNoSideEffect(isolate, target, ""toASCII"", ToASCII);
  SetMethodNoSideEffect(isolate, target, ""toUnicode"", ToUnicode);
}",76,,221,3,,void
75050,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(context);
  realm->AddBindingData<BindingData>(context, target);
}",58,,233,5,,void
75073,BLOCK,-1,,"{
  registry->Register(EncodeInto);
  registry->Register(EncodeUtf8String);
  registry->Register(DecodeUTF8);
  registry->Register(ToASCII);
  registry->Register(ToUnicode);
}",42,,239,2,,void
75114,BLOCK,-1,,<empty>,1,,1,1,,ANY
75149,BLOCK,-1,,<empty>,1,,1,1,,ANY
75153,BLOCK,-1,,{ return el.IsEmpty(); },49,,216,2,,void
75165,BLOCK,-1,,"{
        Environment* env = ContainerOf(
            &Environment::task_queues_async_, async);
        HandleScope handle_scope(env->isolate());
        Context::Scope context_scope(env->context());
        env->RunAndClearNativeImmediates();
      }",29,,957,2,,void
75196,BLOCK,-1,,"{
    env->set_can_call_into_js(false);
    uv_stop(env->event_loop());
  }",47,,991,2,,void
75212,BLOCK,-1,,"{
#ifdef DEBUG
      memset(handle, 0xab, uv_handle_size(handle->type));
#endif
    }",54,,1002,2,,void
75220,BLOCK,-1,,"{
    handle->data = env;

    env->CloseHandle(handle, [](uv_handle_t* handle) {
#ifdef DEBUG
      memset(handle, 0xab, uv_handle_size(handle->type));
#endif
    });
  }",52,,999,4,,void
75237,BLOCK,-1,,"{
    RegisterHandleCleanup(handle, close_and_finish, nullptr);
  }",51,,1009,2,,void
75248,BLOCK,-1,,"{
    Environment* env = ContainerOf(&Environment::idle_prepare_handle_, handle);
    env->isolate()->SetIdle(true);
  }",68,,1049,2,,void
75271,BLOCK,-1,,"{
    Environment* env = ContainerOf(&Environment::idle_check_handle_, handle);
    env->isolate()->SetIdle(false);
  }",62,,1053,2,,void
75294,BLOCK,-1,,"{
    TryCatchScope try_catch(this);
    DebugSealHandleScope seal_handle_scope(isolate());
    while (auto head = queue->Shift()) {
      bool is_refed = head->flags() & CallbackFlags::kRefed;
      if (is_refed)
        ref_count++;

      if (is_refed || !only_refed)
        head->Call(this);

      head.reset();  // Destroy now so that this is also observed by try_catch.

      if (UNLIKELY(try_catch.HasCaught())) {
        if (!try_catch.HasTerminated() && can_call_into_js())
          errors::TriggerUncaughtException(isolate(), try_catch);

        return true;
      }
    }
    return false;
  }",54,,1159,2,,void
75302,BLOCK,-1,,"{
      bool is_refed = head->flags() & CallbackFlags::kRefed;
      if (is_refed)
        ref_count++;

      if (is_refed || !only_refed)
        head->Call(this);

      head.reset();  // Destroy now so that this is also observed by try_catch.

      if (UNLIKELY(try_catch.HasCaught())) {
        if (!try_catch.HasTerminated() && can_call_into_js())
          errors::TriggerUncaughtException(isolate(), try_catch);

        return true;
      }
    }",40,,1162,1,,void
75316,BLOCK,-1,,<empty>,9,,1165,2,,void
75324,BLOCK,-1,,<empty>,9,,1168,2,,void
75340,BLOCK,-1,,"{
        if (!try_catch.HasTerminated() && can_call_into_js())
          errors::TriggerUncaughtException(isolate(), try_catch);

        return true;
      }",44,,1172,2,,void
75349,BLOCK,-1,,<empty>,11,,1174,2,,void
75368,BLOCK,-1,,"{
    std::unique_ptr<Environment*> env_ptr { static_cast<Environment**>(data) };
    Environment* env = *env_ptr;
    if (env == nullptr) {
      // The Environment has already been destroyed. That should be okay; any
      // callback added before the Environment shuts down would have been
      // handled during cleanup.
      return;
    }
    env->interrupt_data_.store(nullptr);
    env->RunAndClearInterrupts();
  }",64,,1222,3,,void
75385,BLOCK,-1,,"{
      // The Environment has already been destroyed. That should be okay; any
      // callback added before the Environment shuts down would have been
      // handled during cleanup.
      return;
    }",25,,1225,2,,void
75403,BLOCK,-1,,{ },58,,1342,2,,void
75467,BLOCK,-1,,<empty>,1,,1,1,,ANY
75489,BLOCK,-1,,"{
  js_promise_hooks_[0].Reset(env()->isolate(), init);
  js_promise_hooks_[1].Reset(env()->isolate(), before);
  js_promise_hooks_[2].Reset(env()->isolate(), after);
  js_promise_hooks_[3].Reset(env()->isolate(), resolve);
}",61,,71,5,,void
75541,BLOCK,-1,,"{
  async_hooks()->ResetPromiseHooks(init, before, after, resolve);

  for (auto it = contexts_.begin(); it != contexts_.end(); it++) {
    if (it->IsEmpty()) {
      contexts_.erase(it--);
      continue;
    }
    PersistentToLocal::Weak(isolate_, *it)
        ->SetPromiseHooks(init, before, after, resolve);
  }
}",62,,81,5,,void
75551,BLOCK,-1,,<empty>,3,,84,1,,void
75567,BLOCK,4,,"{
    if (it->IsEmpty()) {
      contexts_.erase(it--);
      continue;
    }
    PersistentToLocal::Weak(isolate_, *it)
        ->SetPromiseHooks(init, before, after, resolve);
  }",66,,84,4,,void
75573,BLOCK,-1,,"{
      contexts_.erase(it--);
      continue;
    }",24,,85,2,,void
75601,BLOCK,-1,,"{
  // Since async_hooks is experimental, do only perform the check
  // when async_hooks is enabled.
  if (fields_[kCheck] > 0) {
    CHECK_GE(async_id, -1);
    CHECK_GE(trigger_async_id, -1);
  }

  uint32_t offset = fields_[kStackLength];
  if (offset * 2 >= async_ids_stack_.Length()) grow_async_ids_stack();
  async_ids_stack_[2 * offset] = async_id_fields_[kExecutionAsyncId];
  async_ids_stack_[2 * offset + 1] = async_id_fields_[kTriggerAsyncId];
  fields_[kStackLength] += 1;
  async_id_fields_[kExecutionAsyncId] = async_id;
  async_id_fields_[kTriggerAsyncId] = trigger_async_id;

#ifdef DEBUG
  for (uint32_t i = offset; i < native_execution_async_resources_.size(); i++)
    CHECK(native_execution_async_resources_[i].IsEmpty());
#endif

  // When this call comes from JS (as a way of increasing the stack size),
  // `resource` will be empty, because JS caches these values anyway.
  if (!resource.IsEmpty()) {
    native_execution_async_resources_.resize(offset + 1);
    // Caveat...",61,,97,4,,void
75608,BLOCK,-1,,"{
    CHECK_GE(async_id, -1);
    CHECK_GE(trigger_async_id, -1);
  }",28,,100,2,,void
75632,BLOCK,-1,,<empty>,48,,106,2,,void
75675,BLOCK,-1,,"{
    native_execution_async_resources_.resize(offset + 1);
    // Caveat: This is a v8::Local<> assignment, we do not keep a v8::Global<>!
    native_execution_async_resources_[offset] = resource;
  }",28,,120,2,,void
75692,BLOCK,-1,,"{
  // In case of an exception then this may have already been reset, if the
  // stack was multiple MakeCallback()'s deep.
  if (UNLIKELY(fields_[kStackLength] == 0)) return false;

  // Ask for the async_id to be restored as a check that the stack
  // hasn't been corrupted.
  if (UNLIKELY(fields_[kCheck] > 0 &&
               async_id_fields_[kExecutionAsyncId] != async_id)) {
    FailWithCorruptedAsyncStack(async_id);
  }

  uint32_t offset = fields_[kStackLength] - 1;
  async_id_fields_[kExecutionAsyncId] = async_ids_stack_[2 * offset];
  async_id_fields_[kTriggerAsyncId] = async_ids_stack_[2 * offset + 1];
  fields_[kStackLength] = offset;

  if (LIKELY(offset < native_execution_async_resources_.size() &&
             !native_execution_async_resources_[offset].IsEmpty())) {
#ifdef DEBUG
    for (uint32_t i = offset + 1; i < native_execution_async_resources_.size();
         i++) {
      CHECK(native_execution_async_resources_[i].IsEmpty());
    }
#endif
    native_execution_as...",53,,128,2,,void
75700,BLOCK,-1,,<empty>,45,,131,2,,void
75716,BLOCK,-1,,"{
    FailWithCorruptedAsyncStack(async_id);
  }",66,,136,2,,void
75768,BLOCK,-1,,"{
#ifdef DEBUG
    for (uint32_t i = offset + 1; i < native_execution_async_resources_.size();
         i++) {
      CHECK(native_execution_async_resources_[i].IsEmpty());
    }
#endif
    native_execution_async_resources_.resize(offset);
    if (native_execution_async_resources_.size() <
            native_execution_async_resources_.capacity() / 2 &&
        native_execution_async_resources_.size() > 16) {
      native_execution_async_resources_.shrink_to_fit();
    }
  }",69,,146,2,,void
75793,BLOCK,-1,,"{
      native_execution_async_resources_.shrink_to_fit();
    }",56,,156,2,,void
75806,BLOCK,-1,,"{
    HandleScope handle_scope(env()->isolate());
    USE(js_execution_async_resources()->Set(
        env()->context(),
        env()->length_string(),
        Integer::NewFromUnsigned(env()->isolate(), offset)));
  }",68,,161,2,,void
75844,BLOCK,-1,,"{
  if (!js_execution_async_resources_.IsEmpty() && env()->can_call_into_js()) {
    Isolate* isolate = env()->isolate();
    HandleScope handle_scope(isolate);
    USE(PersistentToLocal::Strong(js_execution_async_resources_)
            ->Set(env()->context(),
                  env()->length_string(),
                  Integer::NewFromUnsigned(isolate, 0)));
  }

  native_execution_async_resources_.clear();
  native_execution_async_resources_.shrink_to_fit();

  async_id_fields_[kExecutionAsyncId] = 0;
  async_id_fields_[kTriggerAsyncId] = 0;
  fields_[kStackLength] = 0;
}",41,,172,1,,void
75856,BLOCK,-1,,"{
    Isolate* isolate = env()->isolate();
    HandleScope handle_scope(isolate);
    USE(PersistentToLocal::Strong(js_execution_async_resources_)
            ->Set(env()->context(),
                  env()->length_string(),
                  Integer::NewFromUnsigned(isolate, 0)));
  }",78,,173,2,,void
75917,BLOCK,-1,,"{
  ctx->SetPromiseHooks(js_promise_hooks_[0].IsEmpty()
                           ? Local<Function>()
                           : PersistentToLocal::Strong(js_promise_hooks_[0]),
                       js_promise_hooks_[1].IsEmpty()
                           ? Local<Function>()
                           : PersistentToLocal::Strong(js_promise_hooks_[1]),
                       js_promise_hooks_[2].IsEmpty()
                           ? Local<Function>()
                           : PersistentToLocal::Strong(js_promise_hooks_[2]),
                       js_promise_hooks_[3].IsEmpty()
                           ? Local<Function>()
                           : PersistentToLocal::Strong(js_promise_hooks_[3]));
}",58,,190,2,,void
75986,BLOCK,-1,,"{
  size_t id = contexts_.size();
  contexts_.resize(id + 1);
  contexts_[id].Reset(isolate_, context);
  contexts_[id].SetWeak();
}",56,,205,2,,void
76019,BLOCK,-1,,"{
  HandleScope handle_scope(isolate_);
  contexts_.erase(std::remove_if(contexts_.begin(),
                                 contexts_.end(),
                                 [&](auto&& el) { return el.IsEmpty(); }),
                  contexts_.end());
  for (auto it = contexts_.begin(); it != contexts_.end(); it++) {
    Local<Context> saved_context = PersistentToLocal::Weak(isolate_, *it);
    if (saved_context == context) {
      it->Reset();
      contexts_.erase(it);
      break;
    }
  }
}",58,,212,2,,void
76045,BLOCK,-1,,<empty>,3,,218,1,,void
76061,BLOCK,4,,"{
    Local<Context> saved_context = PersistentToLocal::Weak(isolate_, *it);
    if (saved_context == context) {
      it->Reset();
      contexts_.erase(it);
      break;
    }
  }",66,,218,4,,void
76079,BLOCK,-1,,"{
      it->Reset();
      contexts_.erase(it);
      break;
    }",35,,220,2,,void
76094,BLOCK,-1,,"{
  shadow_realms_.insert(realm);
}",70,,228,2,,void
76104,BLOCK,-1,,"{
  shadow_realms_.erase(realm);
}",72,,232,2,,void
76115,BLOCK,-1,,"{
  if (env->async_hooks()->fields()[AsyncHooks::kCheck] > 0) {
    CHECK_GE(default_trigger_async_id, 0);
  }

  old_default_trigger_async_id_ =
      async_hooks_->async_id_fields()[AsyncHooks::kDefaultTriggerAsyncId];
  async_hooks_->async_id_fields()[AsyncHooks::kDefaultTriggerAsyncId] =
      default_trigger_async_id;
}",40,,238,3,,void
76130,BLOCK,-1,,"{
    CHECK_GE(default_trigger_async_id, 0);
  }",61,,239,2,,void
76157,BLOCK,-1,,"{
  async_hooks_->async_id_fields()[AsyncHooks::kDefaultTriggerAsyncId] =
      old_default_trigger_async_id_;
}",71,,249,1,,void
76172,BLOCK,-1,,<empty>,62,,257,2,,void
76178,BLOCK,-1,,"{
  output << ""{ "";
  for (const SnapshotIndex i : v) {
    output << i << "", "";
  }
  output << "" }"";
  return output;
}",63,,260,3,,void
76185,BLOCK,-1,,"{
    output << i << "", "";
  }",35,,262,3,,void
76201,BLOCK,-1,,"{
  output << ""{\n""
         << ""// -- primitive begins --\n""
         << i.primitive_values << "",\n""
         << ""// -- primitive ends --\n""
         << ""// -- template_values begins --\n""
         << i.template_values << "",\n""
         << ""// -- template_values ends --\n""
         << ""}"";
  return output;
}",61,,270,3,,void
76234,BLOCK,-1,,"{
  output << ""{\n""
         << ""  ""
         << (i.type == SnapshotMetadata::Type::kDefault
                 ? ""SnapshotMetadata::Type::kDefault""
                 : ""SnapshotMetadata::Type::kFullyCustomized"")
         << "", // type\n""
         << ""  \"""" << i.node_version << ""\"", // node_version\n""
         << ""  \"""" << i.node_arch << ""\"", // node_arch\n""
         << ""  \"""" << i.node_platform << ""\"", // node_platform\n""
         << ""  "" << i.v8_cache_version_tag << "", // v8_cache_version_tag\n""
         << ""}"";
  return output;
}",75,,282,3,,void
76295,BLOCK,-1,,"{
  Isolate* isolate = creator->GetIsolate();
  IsolateDataSerializeInfo info;
  HandleScope handle_scope(isolate);
  // XXX(joyeecheung): technically speaking, the indexes here should be
  // consecutive and we could just return a range instead of an array,
  // but that's not part of the V8 API contract so we use an array
  // just to be safe.

#define VP(PropertyName, StringValue) V(Private, PropertyName)
#define VY(PropertyName, StringValue) V(Symbol, PropertyName)
#define VS(PropertyName, StringValue) V(String, PropertyName)
#define VR(PropertyName, TypeName) V(Private, per_realm_##PropertyName)
#define V(TypeName, PropertyName)                                              \
  info.primitive_values.push_back(                                             \
      creator->AddData(PropertyName##_.Get(isolate)));
  PER_ISOLATE_PRIVATE_SYMBOL_PROPERTIES(VP)
  PER_ISOLATE_SYMBOL_PROPERTIES(VY)
  PER_ISOLATE_STRING_PROPERTIES(VS)
  PER_REALM_STRONG_PERSISTENT_VALUES(VR)
#undef V
#undef...",75,,297,2,,void
76316,BLOCK,-1,,<empty>,3,,323,1,,void
76354,BLOCK,-1,,"{
  size_t i = 0;
  HandleScope handle_scope(isolate_);

  if (per_process::enabled_debug_list.enabled(DebugCategory::MKSNAPSHOT)) {
    fprintf(stderr, ""deserializing IsolateDataSerializeInfo...\n"");
    std::cerr << *info << ""\n"";
  }

#define VP(PropertyName, StringValue) V(Private, PropertyName)
#define VY(PropertyName, StringValue) V(Symbol, PropertyName)
#define VS(PropertyName, StringValue) V(String, PropertyName)
#define VR(PropertyName, TypeName) V(Private, per_realm_##PropertyName)
#define V(TypeName, PropertyName)                                              \
  do {                                                                         \
    MaybeLocal<TypeName> maybe_field =                                         \
        isolate_->GetDataFromSnapshotOnce<TypeName>(                           \
            info->primitive_values[i++]);                                      \
    Local<TypeName> field;                                                     \
    if (!maybe...",79,,344,2,,void
76372,BLOCK,-1,,"{
    fprintf(stderr, ""deserializing IsolateDataSerializeInfo...\n"");
    std::cerr << *info << ""\n"";
  }",75,,348,2,,void
76393,BLOCK,-1,,<empty>,3,,378,1,,void
76405,BLOCK,4,,"{
    MaybeLocal<String> maybe_field =
        isolate_->GetDataFromSnapshotOnce<String>(info->primitive_values[i++]);
    Local<String> field;
    if (!maybe_field.ToLocal(&field)) {
      fprintf(stderr, ""Failed to deserialize AsyncWrap provider %zu\n"", j);
    }
    async_wrap_providers_[j].Set(isolate_, field);
  }",60,,378,4,,void
76437,BLOCK,-1,,"{
      fprintf(stderr, ""Failed to deserialize AsyncWrap provider %zu\n"", j);
    }",39,,382,2,,void
76468,BLOCK,-1,,"{
  // Create string and private symbol properties as internalized one byte
  // strings after the platform is properly initialized.
  //
  // Internalized because it makes property lookups a little faster and
  // because the string is created in the old space straight away.  It's going
  // to end up in the old space sooner or later anyway but now it doesn't go
  // through v8::Eternal's new space handling first.
  //
  // One byte because our strings are ASCII and we can safely skip V8's UTF-8
  // decoding step.

  HandleScope handle_scope(isolate_);

#define V(PropertyName, StringValue)                                           \
  PropertyName##_.Set(                                                         \
      isolate_,                                                                \
      Private::New(isolate_,                                                   \
                   String::NewFromOneByte(                                     \
                       isolate...",38,,416,1,,void
76521,BLOCK,-1,,"{
  options_.reset(
      new PerIsolateOptions(*(per_process::cli_options->per_isolate)));

  if (snapshot_data == nullptr) {
    CreateProperties();
  } else {
    DeserializeProperties(&snapshot_data->isolate_data_info);
  }
}",37,,510,6,,void
76538,BLOCK,-1,,"{
    CreateProperties();
  }",33,,514,2,,void
76541,BLOCK,-1,,"{
    DeserializeProperties(&snapshot_data->isolate_data_info);
  }",10,,516,1,,void
76551,BLOCK,-1,,"{
#define V(PropertyName, StringValue)                                           \
  tracker->TrackField(#PropertyName, PropertyName());
  PER_ISOLATE_SYMBOL_PROPERTIES(V)

  PER_ISOLATE_STRING_PROPERTIES(V)
#undef V

  tracker->TrackField(""async_wrap_providers"", async_wrap_providers_);

  if (node_allocator_ != nullptr) {
    tracker->TrackFieldWithSize(
        ""node_allocator"", sizeof(*node_allocator_), ""NodeArrayBufferAllocator"");
  }
  tracker->TrackFieldWithSize(
      ""platform"", sizeof(*platform_), ""MultiIsolatePlatform"");
  // TODO(joyeecheung): implement MemoryRetainer in the option classes.
}",60,,521,2,,void
76566,BLOCK,-1,,"{
    tracker->TrackFieldWithSize(
        ""node_allocator"", sizeof(*node_allocator_), ""NodeArrayBufferAllocator"");
  }",35,,531,2,,void
76588,BLOCK,-1,,"{
  if (!env_->owns_process_state() || !env_->can_call_into_js()) {
    // Ideally, wed have a consistent story that treats all threads/Environment
    // instances equally here. However, tracing is essentially global, and this
    // callback is called from whichever thread calls `StartTracing()` or
    // `StopTracing()`. The only way to do this in a threadsafe fashion
    // seems to be only tracking this from the main thread, and only allowing
    // these state modifications from the main thread.
    return;
  }

  if (env_->principal_realm() == nullptr) {
    return;
  }

  bool async_hooks_enabled = (*(TRACE_EVENT_API_GET_CATEGORY_GROUP_ENABLED(
                                 TRACING_CATEGORY_NODE1(async_hooks)))) != 0;

  Isolate* isolate = env_->isolate();
  HandleScope handle_scope(isolate);
  Local<Function> cb = env_->trace_category_state_function();
  if (cb.IsEmpty())
    return;
  TryCatchScope try_catch(env_);
  try_catch.SetVerbose(true);
  Local<Value> args[] = ...",61,,540,1,,void
76601,BLOCK,-1,,"{
    // Ideally, wed have a consistent story that treats all threads/Environment
    // instances equally here. However, tracing is essentially global, and this
    // callback is called from whichever thread calls `StartTracing()` or
    // `StopTracing()`. The only way to do this in a threadsafe fashion
    // seems to be only tracking this from the main thread, and only allowing
    // these state modifications from the main thread.
    return;
  }",65,,541,2,,void
76610,BLOCK,-1,,"{
    return;
  }",43,,551,2,,void
76646,BLOCK,-1,,<empty>,5,,562,2,,void
76686,BLOCK,-1,,"{
  context->SetAlignedPointerInEmbedderData(ContextEmbedderIndex::kEnvironment,
                                           this);
  context->SetAlignedPointerInEmbedderData(ContextEmbedderIndex::kRealm, realm);
  // Used to retrieve bindings
  context->SetAlignedPointerInEmbedderData(
      ContextEmbedderIndex::kBindingDataStoreIndex,
      realm->binding_data_store());

  // ContextifyContexts will update this to a pointer to the native object.
  context->SetAlignedPointerInEmbedderData(
      ContextEmbedderIndex::kContextifyContext, nullptr);

  // This must not be done before other context fields are initialized.
  ContextEmbedderTag::TagNodeContext(context);

#if HAVE_INSPECTOR
  inspector_agent()->ContextCreated(context, info);
#endif  // HAVE_INSPECTOR

  this->async_hooks()->InstallPromiseHooks(context);
  TrackContext(context);
}",60,,571,4,,void
76741,BLOCK,-1,,"{
  if (!context.IsEmpty()) {
    context->SetAlignedPointerInEmbedderData(ContextEmbedderIndex::kEnvironment,
                                             nullptr);
    context->SetAlignedPointerInEmbedderData(ContextEmbedderIndex::kRealm,
                                             nullptr);
    context->SetAlignedPointerInEmbedderData(
        ContextEmbedderIndex::kBindingDataStoreIndex, nullptr);
    context->SetAlignedPointerInEmbedderData(
        ContextEmbedderIndex::kContextifyContext, nullptr);
  }
  UntrackContext(context);
}",67,,595,2,,void
76748,BLOCK,-1,,"{
    context->SetAlignedPointerInEmbedderData(ContextEmbedderIndex::kEnvironment,
                                             nullptr);
    context->SetAlignedPointerInEmbedderData(ContextEmbedderIndex::kRealm,
                                             nullptr);
    context->SetAlignedPointerInEmbedderData(
        ContextEmbedderIndex::kBindingDataStoreIndex, nullptr);
    context->SetAlignedPointerInEmbedderData(
        ContextEmbedderIndex::kContextifyContext, nullptr);
  }",27,,596,2,,void
76789,BLOCK,-1,,"{
  loaded_addons_.emplace_back(filename, flags);
  if (!was_loaded(&loaded_addons_.back())) {
    loaded_addons_.pop_back();
  }
}",60,,612,4,,void
76804,BLOCK,-1,,"{
    loaded_addons_.pop_back();
  }",44,,614,2,,void
76812,BLOCK,-1,,"{
  char cwd[PATH_MAX_BYTES];
  size_t size = PATH_MAX_BYTES;
  const int err = uv_cwd(cwd, &size);

  if (err == 0) {
    CHECK_GT(size, 0);
    return cwd;
  }

  // This can fail if the cwd is deleted. In that case, fall back to
  // exec_path.
  const std::string& exec_path = exec_path_;
  return exec_path.substr(0, exec_path.find_last_of(kPathSeparator));
}",35,,619,1,,void
76829,BLOCK,-1,,"{
    CHECK_GT(size, 0);
    return cwd;
  }",17,,624,2,,void
76854,BLOCK,-1,,"{
  task_queues_async_refs_ += diff;
  CHECK_GE(task_queues_async_refs_, 0);
  if (task_queues_async_refs_ == 0)
    uv_unref(reinterpret_cast<uv_handle_t*>(&task_queues_async_));
  else
    uv_ref(reinterpret_cast<uv_handle_t*>(&task_queues_async_));
}",42,,635,2,,void
76865,BLOCK,-1,,<empty>,5,,639,2,,void
76872,BLOCK,-1,,<empty>,5,,641,1,,void
76882,BLOCK,-1,,"{
  NoArrayBufferZeroFillScope no_zero_fill_scope(isolate_data());
  std::unique_ptr<v8::BackingStore> bs =
      v8::ArrayBuffer::NewBackingStore(isolate(), suggested_size);
  uv_buf_t buf = uv_buf_init(static_cast<char*>(bs->Data()), bs->ByteLength());
  released_allocated_buffers_.emplace(buf.base, std::move(bs));
  return buf;
}",76,,644,2,,void
76936,BLOCK,-1,,"{
  std::unique_ptr<v8::BackingStore> bs;
  if (buf.base != nullptr) {
    auto it = released_allocated_buffers_.find(buf.base);
    CHECK_NE(it, released_allocated_buffers_.end());
    bs = std::move(it->second);
    released_allocated_buffers_.erase(it);
  }
  return bs;
}",26,,654,2,,void
76952,BLOCK,-1,,"{
    auto it = released_allocated_buffers_.find(buf.base);
    CHECK_NE(it, released_allocated_buffers_.end());
    bs = std::move(it->second);
    released_allocated_buffers_.erase(it);
  }",28,,656,2,,void
76989,BLOCK,-1,,"{
  char exec_path_buf[2 * PATH_MAX];
  size_t exec_path_len = sizeof(exec_path_buf);
  std::string exec_path;
  if (uv_exepath(exec_path_buf, &exec_path_len) == 0) {
    exec_path = std::string(exec_path_buf, exec_path_len);
  } else if (argv.size() > 0) {
    exec_path = argv[0];
  }

  // On OpenBSD process.execPath will be relative unless we
  // get the full path before process.execPath is used.
#if defined(__OpenBSD__)
  uv_fs_t req;
  req.ptr = nullptr;
  if (0 ==
      uv_fs_realpath(nullptr, &req, exec_path.c_str(), nullptr)) {
    CHECK_NOT_NULL(req.ptr);
    exec_path = std::string(static_cast<char*>(req.ptr));
  }
  uv_fs_req_cleanup(&req);
#endif

  return exec_path;
}",63,,665,2,,void
77004,BLOCK,-1,,"{
    exec_path = std::string(exec_path_buf, exec_path_len);
  }",55,,669,2,,void
77014,BLOCK,-1,,<empty>,10,,671,1,,void
77022,BLOCK,-1,,"{
    exec_path = argv[0];
  }",31,,671,2,,void
77040,BLOCK,-1,,"{
  constexpr bool is_shared_ro_heap =
#ifdef NODE_V8_SHARED_RO_HEAP
      true;
#else
      false;
#endif
  if (is_shared_ro_heap && !is_main_thread()) {
    // If this is a Worker thread and we are in shared-readonly-heap mode,
    // we can always safely use the parent's Isolate's code cache.
    CHECK_NOT_NULL(isolate_data->worker_context());
    builtin_loader()->CopySourceAndCodeCacheReferenceFrom(
        isolate_data->worker_context()->env()->builtin_loader());
  } else if (isolate_data->snapshot_data() != nullptr) {
    // ... otherwise, if a snapshot was provided, use its code cache.
    builtin_loader()->RefreshCodeCache(
        isolate_data->snapshot_data()->code_cache);
  }

  // We'll be creating new objects so make sure we've entered the context.
  HandleScope handle_scope(isolate);

  // Set some flags if only kDefaultFlags was passed. This can make API version
  // transitions easier for embedders.
  if (flags_ & EnvironmentFlags::kDefaultFlags) {
    flags_ = flag...",38,,723,8,,void
77050,BLOCK,-1,,"{
    // If this is a Worker thread and we are in shared-readonly-heap mode,
    // we can always safely use the parent's Isolate's code cache.
    CHECK_NOT_NULL(isolate_data->worker_context());
    builtin_loader()->CopySourceAndCodeCacheReferenceFrom(
        isolate_data->worker_context()->env()->builtin_loader());
  }",47,,730,2,,void
77071,BLOCK,-1,,<empty>,10,,736,1,,void
77079,BLOCK,-1,,"{
    // ... otherwise, if a snapshot was provided, use its code cache.
    builtin_loader()->RefreshCodeCache(
        isolate_data->snapshot_data()->code_cache);
  }",56,,736,2,,void
77099,BLOCK,-1,,"{
    flags_ = flags_ |
        EnvironmentFlags::kOwnsProcessState |
        EnvironmentFlags::kOwnsInspector;
  }",49,,747,2,,void
77166,BLOCK,-1,,"{
    set_abort_on_uncaught_exception(false);
  }",56,,768,2,,void
77170,BLOCK,-1,,<empty>,7,,777,1,,void
77175,BLOCK,-1,,"{
    trace_state_observer_ = std::make_unique<TrackingTraceStateObserver>(this);
    if (TracingController* tracing_controller = writer->GetTracingController())
      tracing_controller->AddTraceStateObserver(trace_state_observer_.get());
  }",69,,777,2,,void
77186,BLOCK,-1,,<empty>,9,,779,1,,void
77194,BLOCK,-1,,<empty>,7,,780,2,,void
77231,BLOCK,-1,,"{
    auto traced_value = tracing::TracedValue::Create();
    traced_value->BeginArray(""args"");
    for (const std::string& arg : args) traced_value->AppendString(arg);
    traced_value->EndArray();
    traced_value->BeginArray(""exec_args"");
    for (const std::string& arg : exec_args) traced_value->AppendString(arg);
    traced_value->EndArray();
    TRACE_EVENT_NESTABLE_ASYNC_BEGIN1(TRACING_CATEGORY_NODE1(environment),
                                      ""Environment"",
                                      this,
                                      ""args"",
                                      std::move(traced_value));
  }",54,,789,2,,void
77290,BLOCK,-1,,"{
    permission()->EnablePermissions();
    // If any permission is set the process shouldn't be able to neither
    // spawn/worker nor use addons or enable inspector
    // unless explicitly allowed by the user
    if (!options_->allow_fs_read.empty() || !options_->allow_fs_write.empty()) {
      options_->allow_native_addons = false;
      flags_ = flags_ | EnvironmentFlags::kNoCreateInspector;
      permission()->Apply(""*"", permission::PermissionScope::kInspector);
      if (!options_->allow_child_process) {
        permission()->Apply(""*"", permission::PermissionScope::kChildProcess);
      }
      if (!options_->allow_worker_threads) {
        permission()->Apply(""*"", permission::PermissionScope::kWorkerThreads);
      }
    }

    if (!options_->allow_fs_read.empty()) {
      permission()->Apply(options_->allow_fs_read,
                          permission::PermissionScope::kFileSystemRead);
    }

    if (!options_->allow_fs_write.empty()) {
      permission()->Apply(options...",42,,804,2,,void
77311,BLOCK,-1,,"{
      options_->allow_native_addons = false;
      flags_ = flags_ | EnvironmentFlags::kNoCreateInspector;
      permission()->Apply(""*"", permission::PermissionScope::kInspector);
      if (!options_->allow_child_process) {
        permission()->Apply(""*"", permission::PermissionScope::kChildProcess);
      }
      if (!options_->allow_worker_threads) {
        permission()->Apply(""*"", permission::PermissionScope::kWorkerThreads);
      }
    }",80,,809,2,,void
77339,BLOCK,-1,,"{
        permission()->Apply(""*"", permission::PermissionScope::kChildProcess);
      }",43,,813,2,,void
77355,BLOCK,-1,,"{
        permission()->Apply(""*"", permission::PermissionScope::kWorkerThreads);
      }",44,,816,2,,void
77374,BLOCK,-1,,"{
      permission()->Apply(options_->allow_fs_read,
                          permission::PermissionScope::kFileSystemRead);
    }",43,,821,2,,void
77395,BLOCK,-1,,"{
      permission()->Apply(options_->allow_fs_write,
                          permission::PermissionScope::kFileSystemWrite);
    }",44,,826,2,,void
77413,BLOCK,-1,,"{
  principal_realm_ = std::make_unique<PrincipalRealm>(
      this, context, MAYBE_FIELD_PTR(env_info, principal_realm));
  if (env_info != nullptr) {
    DeserializeProperties(env_info);
  }

  if (!options_->force_async_hooks_checks) {
    async_hooks_.no_force_checks();
  }

  // By default, always abort when --abort-on-uncaught-exception was passed.
  should_abort_on_uncaught_toggle_[0] = 1;

  // The process is not exiting by default.
  set_exiting(false);

  performance_state_->Mark(performance::NODE_PERFORMANCE_MILESTONE_ENVIRONMENT,
                           environment_start_);
  performance_state_->Mark(performance::NODE_PERFORMANCE_MILESTONE_NODE_START,
                           per_process::node_start_time);

  if (per_process::v8_initialized) {
    performance_state_->Mark(performance::NODE_PERFORMANCE_MILESTONE_V8_START,
                            performance::performance_v8_start);
  }
}",75,,834,3,,void
77433,BLOCK,-1,,"{
    DeserializeProperties(env_info);
  }",28,,837,2,,void
77441,BLOCK,-1,,"{
    async_hooks_.no_force_checks();
  }",44,,841,2,,void
77475,BLOCK,-1,,"{
    performance_state_->Mark(performance::NODE_PERFORMANCE_MILESTONE_V8_START,
                            performance::performance_v8_start);
  }",36,,856,2,,void
77489,BLOCK,-1,,"{
  HandleScope handle_scope(isolate());
  Local<Context> ctx = context();

  if (Environment** interrupt_data = interrupt_data_.load()) {
    // There are pending RequestInterrupt() callbacks. Tell them not to run,
    // then force V8 to run interrupts by compiling and running an empty script
    // so as not to leak memory.
    *interrupt_data = nullptr;

    Isolate::AllowJavascriptExecutionScope allow_js_here(isolate());
    TryCatch try_catch(isolate());
    Context::Scope context_scope(ctx);

#ifdef DEBUG
    bool consistency_check = false;
    isolate()->RequestInterrupt([](Isolate*, void* data) {
      *static_cast<bool*>(data) = true;
    }, &consistency_check);
#endif

    Local<Script> script;
    if (Script::Compile(ctx, String::Empty(isolate())).ToLocal(&script))
      USE(script->Run(ctx));

    DCHECK(consistency_check);
  }

  // FreeEnvironment() should have set this.
  CHECK(is_stopping());

  if (heapsnapshot_near_heap_limit_callback_added_) {
    RemoveHeapSnaps...",29,,862,1,,void
77501,BLOCK,-1,,<empty>,7,,866,1,,void
77509,BLOCK,-1,,"{
    // There are pending RequestInterrupt() callbacks. Tell them not to run,
    // then force V8 to run interrupts by compiling and running an empty script
    // so as not to leak memory.
    *interrupt_data = nullptr;

    Isolate::AllowJavascriptExecutionScope allow_js_here(isolate());
    TryCatch try_catch(isolate());
    Context::Scope context_scope(ctx);

#ifdef DEBUG
    bool consistency_check = false;
    isolate()->RequestInterrupt([](Isolate*, void* data) {
      *static_cast<bool*>(data) = true;
    }, &consistency_check);
#endif

    Local<Script> script;
    if (Script::Compile(ctx, String::Empty(isolate())).ToLocal(&script))
      USE(script->Run(ctx));

    DCHECK(consistency_check);
  }",62,,866,2,,void
77544,BLOCK,-1,,<empty>,7,,885,2,,void
77555,BLOCK,-1,,"{
    RemoveHeapSnapshotNearHeapLimitCallback(0);
  }",53,,893,2,,void
77579,BLOCK,-1,,"{
    tracing::AgentWriterHandle* writer = GetTracingAgentWriter();
    CHECK_NOT_NULL(writer);
    if (TracingController* tracing_controller = writer->GetTracingController())
      tracing_controller->RemoveTraceStateObserver(trace_state_observer_.get());
  }",30,,910,2,,void
77587,BLOCK,-1,,<empty>,9,,913,1,,void
77595,BLOCK,-1,,<empty>,7,,914,2,,void
77612,BLOCK,-1,,"{
    // Dereference all addons that were loaded into this environment.
    for (binding::DLib& addon : loaded_addons_) {
      addon.Close();
    }
  }",26,,925,2,,void
77616,BLOCK,-1,,"{
      addon.Close();
    }",49,,927,3,,void
77624,BLOCK,-1,,"{
  HandleScope handle_scope(isolate());
  Context::Scope context_scope(context());

  CHECK_EQ(0, uv_timer_init(event_loop(), timer_handle()));
  uv_unref(reinterpret_cast<uv_handle_t*>(timer_handle()));

  CHECK_EQ(0, uv_check_init(event_loop(), immediate_check_handle()));
  uv_unref(reinterpret_cast<uv_handle_t*>(immediate_check_handle()));

  CHECK_EQ(0, uv_idle_init(event_loop(), immediate_idle_handle()));

  CHECK_EQ(0, uv_check_start(immediate_check_handle(), CheckImmediate));

  // Inform V8's CPU profiler when we're idle.  The profiler is sampling-based
  // but not all samples are created equal; mark the wall clock time spent in
  // epoll_wait() and friends so profiling tools can filter it out.  The samples
  // still end up in v8.log but with state=IDLE rather than state=EXTERNAL.
  CHECK_EQ(0, uv_prepare_init(event_loop(), &idle_prepare_handle_));
  CHECK_EQ(0, uv_check_init(event_loop(), &idle_check_handle_));

  CHECK_EQ(0, uv_async_init(
      event_loop(),
      &ta...",37,,933,1,,void
77693,BLOCK,17,,"{
    Mutex::ScopedLock lock(native_immediates_threadsafe_mutex_);
    task_queues_async_initialized_ = true;
    if (native_immediates_threadsafe_.size() > 0 ||
        native_immediates_interrupts_.size() > 0) {
      uv_async_send(&task_queues_async_);
    }
  }",3,,968,17,,void
77714,BLOCK,-1,,"{
      uv_async_send(&task_queues_async_);
    }",51,,972,2,,void
77722,BLOCK,-1,,"{
  // Should not access non-thread-safe methods here.
  set_stopping(true);
  if ((flags & StopFlags::kDoNotTerminateIsolate) == 0)
    isolate_->TerminateExecution();
  SetImmediateThreadsafe([](Environment* env) {
    env->set_can_call_into_js(false);
    uv_stop(env->event_loop());
  });
}",51,,986,2,,void
77733,BLOCK,-1,,<empty>,5,,990,2,,void
77743,BLOCK,-1,,"{
  HandleCleanupCb close_and_finish = [](Environment* env, uv_handle_t* handle,
                                        void* arg) {
    handle->data = env;

    env->CloseHandle(handle, [](uv_handle_t* handle) {
#ifdef DEBUG
      memset(handle, 0xab, uv_handle_size(handle->type));
#endif
    });
  };

  auto register_handle = [&](uv_handle_t* handle) {
    RegisterHandleCleanup(handle, close_and_finish, nullptr);
  };
  register_handle(reinterpret_cast<uv_handle_t*>(timer_handle()));
  register_handle(reinterpret_cast<uv_handle_t*>(immediate_check_handle()));
  register_handle(reinterpret_cast<uv_handle_t*>(immediate_idle_handle()));
  register_handle(reinterpret_cast<uv_handle_t*>(&idle_prepare_handle_));
  register_handle(reinterpret_cast<uv_handle_t*>(&idle_check_handle_));
  register_handle(reinterpret_cast<uv_handle_t*>(&task_queues_async_));
}",44,,997,1,,void
77781,BLOCK,-1,,"{
  {
    Mutex::ScopedLock lock(native_immediates_threadsafe_mutex_);
    task_queues_async_initialized_ = false;
  }

  Isolate::DisallowJavascriptExecutionScope disallow_js(isolate(),
      Isolate::DisallowJavascriptExecutionScope::THROW_ON_FAILURE);

  RunAndClearNativeImmediates(true /* skip unrefed SetImmediate()s */);

  for (ReqWrapBase* request : req_wrap_queue_)
    request->Cancel();

  for (HandleWrap* handle : handle_wrap_queue_)
    handle->Close();

  for (HandleCleanup& hc : handle_cleanup_queue_)
    hc.cb_(this, hc.handle_, hc.arg_);
  handle_cleanup_queue_.clear();

  while (handle_cleanup_waiting_ != 0 ||
         request_waiting_ != 0 ||
         !handle_wrap_queue_.IsEmpty()) {
    uv_run(event_loop(), UV_RUN_ONCE);
  }
}",36,,1020,1,,void
77782,BLOCK,1,,"{
    Mutex::ScopedLock lock(native_immediates_threadsafe_mutex_);
    task_queues_async_initialized_ = false;
  }",3,,1021,1,,void
77845,BLOCK,-1,,"{
    uv_run(event_loop(), UV_RUN_ONCE);
  }",41,,1043,2,,void
77852,BLOCK,-1,,"{
  uv_prepare_start(&idle_prepare_handle_, [](uv_prepare_t* handle) {
    Environment* env = ContainerOf(&Environment::idle_prepare_handle_, handle);
    env->isolate()->SetIdle(true);
  });
  uv_check_start(&idle_check_handle_, [](uv_check_t* handle) {
    Environment* env = ContainerOf(&Environment::idle_check_handle_, handle);
    env->isolate()->SetIdle(false);
  });
}",47,,1048,1,,void
77864,BLOCK,-1,,"{
  if (!trace_sync_io_) return;

  HandleScope handle_scope(isolate());

  fprintf(
      stderr, ""(node:%d) WARNING: Detected use of sync API\n"", uv_os_getpid());
  PrintStackTrace(isolate(),
                  StackTrace::CurrentStackTrace(
                      isolate(), stack_trace_limit(), StackTrace::kDetailed));
}",42,,1059,1,,void
77868,BLOCK,-1,,<empty>,24,,1060,2,,void
77891,BLOCK,-1,,"{
  EscapableHandleScope handle_scope(isolate());
  if (!snapshot_serialize_callback().IsEmpty()) {
    Context::Scope context_scope(context());
    return handle_scope.EscapeMaybe(snapshot_serialize_callback()->Call(
        context(), v8::Undefined(isolate()), 0, nullptr));
  }
  return handle_scope.Escape(Undefined(isolate()));
}",69,,1071,1,,void
77901,BLOCK,-1,,"{
    Context::Scope context_scope(context());
    return handle_scope.EscapeMaybe(snapshot_serialize_callback()->Call(
        context(), v8::Undefined(isolate()), 0, nullptr));
  }",49,,1073,2,,void
77932,BLOCK,-1,,"{
  EscapableHandleScope handle_scope(isolate());
  if (!snapshot_deserialize_main().IsEmpty()) {
    Context::Scope context_scope(context());
    return handle_scope.EscapeMaybe(snapshot_deserialize_main()->Call(
        context(), v8::Undefined(isolate()), 0, nullptr));
  }
  return handle_scope.Escape(Undefined(isolate()));
}",67,,1081,1,,void
77942,BLOCK,-1,,"{
    Context::Scope context_scope(context());
    return handle_scope.EscapeMaybe(snapshot_deserialize_main()->Call(
        context(), v8::Undefined(isolate()), 0, nullptr));
  }",47,,1083,2,,void
77973,BLOCK,-1,,"{
  started_cleanup_ = true;
  TRACE_EVENT0(TRACING_CATEGORY_NODE1(environment), ""RunCleanup"");
  // Only BaseObject's cleanups are registered as per-realm cleanup hooks now.
  // Defer the BaseObject cleanup after handles are cleaned up.
  CleanupHandles();

  while (!cleanup_queue_.empty() || principal_realm_->HasCleanupHooks() ||
         native_immediates_.size() > 0 ||
         native_immediates_threadsafe_.size() > 0 ||
         native_immediates_interrupts_.size() > 0) {
    // TODO(legendecas): cleanup handles in per-realm cleanup hooks as well.
    principal_realm_->RunCleanup();
    cleanup_queue_.Drain();
    CleanupHandles();
  }

  for (const int fd : unmanaged_fds_) {
    uv_fs_t close_req;
    uv_fs_close(nullptr, &close_req, fd, nullptr);
    uv_fs_req_cleanup(&close_req);
  }
}",32,,1091,1,,void
78014,BLOCK,-1,,"{
    // TODO(legendecas): cleanup handles in per-realm cleanup hooks as well.
    principal_realm_->RunCleanup();
    cleanup_queue_.Drain();
    CleanupHandles();
  }",52,,1101,2,,void
78027,BLOCK,-1,,"{
    uv_fs_t close_req;
    uv_fs_close(nullptr, &close_req, fd, nullptr);
    uv_fs_req_cleanup(&close_req);
  }",39,,1108,3,,void
78041,BLOCK,-1,,"{
  TRACE_EVENT0(TRACING_CATEGORY_NODE1(environment), ""AtExit"");
  for (ExitCallback at_exit : at_exit_functions_) {
    at_exit.cb_(at_exit.arg_);
  }
  at_exit_functions_.clear();
}",40,,1115,1,,void
78049,BLOCK,-1,,"{
    at_exit.cb_(at_exit.arg_);
  }",51,,1117,3,,void
78066,BLOCK,-1,,"{
  at_exit_functions_.push_front(ExitCallback{cb, arg});
}",60,,1123,3,,void
78078,BLOCK,-1,,"{
  while (native_immediates_interrupts_.size() > 0) {
    NativeImmediateQueue queue;
    {
      Mutex::ScopedLock lock(native_immediates_threadsafe_mutex_);
      queue.ConcatMove(std::move(native_immediates_interrupts_));
    }
    DebugSealHandleScope seal_handle_scope(isolate());

    while (auto head = queue.Shift())
      head->Call(this);
  }
}",43,,1127,1,,void
78086,BLOCK,-1,,"{
    NativeImmediateQueue queue;
    {
      Mutex::ScopedLock lock(native_immediates_threadsafe_mutex_);
      queue.ConcatMove(std::move(native_immediates_interrupts_));
    }
    DebugSealHandleScope seal_handle_scope(isolate());

    while (auto head = queue.Shift())
      head->Call(this);
  }",52,,1128,2,,void
78088,BLOCK,2,,"{
      Mutex::ScopedLock lock(native_immediates_threadsafe_mutex_);
      queue.ConcatMove(std::move(native_immediates_interrupts_));
    }",5,,1130,2,,void
78113,BLOCK,-1,,"{
  TRACE_EVENT0(TRACING_CATEGORY_NODE1(environment),
               ""RunAndClearNativeImmediates"");
  HandleScope handle_scope(isolate_);
  // In case the Isolate is no longer accessible just use an empty Local. This
  // is not an issue for InternalCallbackScope as this case is already handled
  // in its constructor but we avoid calls into v8 which can crash the process
  // in debug builds.
  Local<Object> obj =
      can_call_into_js() ? Object::New(isolate_) : Local<Object>();
  InternalCallbackScope cb_scope(this, obj, {0, 0});

  size_t ref_count = 0;

  // Handle interrupts first. These functions are not allowed to throw
  // exceptions, so we do not need to handle that.
  RunAndClearInterrupts();

  auto drain_list = [&](NativeImmediateQueue* queue) {
    TryCatchScope try_catch(this);
    DebugSealHandleScope seal_handle_scope(isolate());
    while (auto head = queue->Shift()) {
      bool is_refed = head->flags() & CallbackFlags::kRefed;
      if (is_refed)
        ref_c...",64,,1141,2,,void
78154,BLOCK,-1,,<empty>,43,,1181,2,,void
78167,BLOCK,-1,,<empty>,5,,1186,2,,void
78178,BLOCK,-1,,"{
    Mutex::ScopedLock lock(native_immediates_threadsafe_mutex_);
    threadsafe_immediates.ConcatMove(std::move(native_immediates_threadsafe_));
  }",49,,1196,2,,void
78195,BLOCK,-1,,<empty>,46,,1200,2,,void
78199,BLOCK,-1,,"{
  // The Isolate may outlive the Environment, so some logic to handle the
  // situation in which the Environment is destroyed before the handler runs
  // is required.

  // We allocate a new pointer to a pointer to this Environment instance, and
  // try to set it as interrupt_data_. If interrupt_data_ was already set, then
  // callbacks are already scheduled to run and we can delete our own pointer
  // and just return. If it was nullptr previously, the Environment** is stored;
  // ~Environment sets the Environment* contained in it to nullptr, so that
  // the callback can check whether ~Environment has already run and it is thus
  // not safe to access the Environment instance itself.
  Environment** interrupt_data = new Environment*(this);
  Environment** dummy = nullptr;
  if (!interrupt_data_.compare_exchange_strong(dummy, interrupt_data)) {
    delete interrupt_data;
    return;  // Already scheduled.
  }

  isolate()->RequestInterrupt([](Isolate* isolate, void* data) {
...",44,,1203,1,,void
78218,BLOCK,-1,,"{
    delete interrupt_data;
    return;  // Already scheduled.
  }",72,,1217,2,,void
78232,BLOCK,-1,,"{
  if (started_cleanup_) return;
  uv_timer_start(timer_handle(), RunTimers, duration_ms, 0);
}",54,,1236,2,,void
78235,BLOCK,-1,,<empty>,25,,1237,2,,void
78246,BLOCK,-1,,"{
  if (started_cleanup_) return;

  if (ref) {
    uv_ref(reinterpret_cast<uv_handle_t*>(timer_handle()));
  } else {
    uv_unref(reinterpret_cast<uv_handle_t*>(timer_handle()));
  }
}",44,,1241,2,,void
78249,BLOCK,-1,,<empty>,25,,1242,2,,void
78253,BLOCK,-1,,"{
    uv_ref(reinterpret_cast<uv_handle_t*>(timer_handle()));
  }",12,,1244,2,,void
78259,BLOCK,-1,,"{
    uv_unref(reinterpret_cast<uv_handle_t*>(timer_handle()));
  }",10,,1246,1,,void
78268,BLOCK,-1,,"{
  Environment* env = Environment::from_timer_handle(handle);
  TRACE_EVENT0(TRACING_CATEGORY_NODE1(environment), ""RunTimers"");

  if (!env->can_call_into_js())
    return;

  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Object> process = env->process_object();
  InternalCallbackScope scope(env, process, {0, 0});

  Local<Function> cb = env->timers_callback_function();
  MaybeLocal<Value> ret;
  Local<Value> arg = env->GetNow();
  // This code will loop until all currently due timers will process. It is
  // impossible for us to end up in an infinite loop due to how the JS-side
  // is structured.
  do {
    TryCatchScope try_catch(env);
    try_catch.SetVerbose(true);
    ret = cb->Call(env->context(), process, 1, &arg);
  } while (ret.IsEmpty() && env->can_call_into_js());

  // NOTE(apapirovski): If it ever becomes possible that `call_into_js` above
  // is reset back to `true` after being previously set to `false` then this
...",49,,1251,2,,void
78287,BLOCK,-1,,<empty>,5,,1256,2,,void
78344,BLOCK,-1,,"{
    TryCatchScope try_catch(env);
    try_catch.SetVerbose(true);
    ret = cb->Call(env->context(), process, 1, &arg);
  }",6,,1270,1,,void
78381,BLOCK,-1,,<empty>,5,,1282,2,,void
78410,BLOCK,-1,,"{
    int64_t duration_ms =
        llabs(expiry_ms) - (uv_now(env->event_loop()) - env->timer_base());

    env->ScheduleTimer(duration_ms > 0 ? duration_ms : 1);

    if (expiry_ms > 0)
      uv_ref(h);
    else
      uv_unref(h);
  }",23,,1296,2,,void
78441,BLOCK,-1,,<empty>,7,,1303,2,,void
78445,BLOCK,-1,,<empty>,7,,1305,1,,void
78449,BLOCK,-1,,"{
    uv_unref(h);
  }",10,,1306,1,,void
78456,BLOCK,-1,,"{
  Environment* env = Environment::from_immediate_check_handle(handle);
  TRACE_EVENT0(TRACING_CATEGORY_NODE1(environment), ""CheckImmediate"");

  HandleScope scope(env->isolate());
  Context::Scope context_scope(env->context());

  env->RunAndClearNativeImmediates();

  if (env->immediate_info()->count() == 0 || !env->can_call_into_js())
    return;

  do {
    MakeCallback(env->isolate(),
                 env->process_object(),
                 env->immediate_callback_function(),
                 0,
                 nullptr,
                 {0, 0}).ToLocalChecked();
  } while (env->immediate_info()->has_outstanding() && env->can_call_into_js());

  if (env->immediate_info()->ref_count() == 0)
    env->ToggleImmediateRef(false);
}",54,,1312,2,,void
78501,BLOCK,-1,,<empty>,5,,1322,2,,void
78504,BLOCK,-1,,"{
    MakeCallback(env->isolate(),
                 env->process_object(),
                 env->immediate_callback_function(),
                 0,
                 nullptr,
                 {0, 0}).ToLocalChecked();
  }",6,,1324,1,,void
78548,BLOCK,-1,,<empty>,5,,1334,2,,void
78558,BLOCK,-1,,"{
  if (started_cleanup_) return;

  if (ref) {
    // Idle handle is needed only to stop the event loop from blocking in poll.
    uv_idle_start(immediate_idle_handle(), [](uv_idle_t*){ });
  } else {
    uv_idle_stop(immediate_idle_handle());
  }
}",48,,1337,2,,void
78561,BLOCK,-1,,<empty>,25,,1338,2,,void
78565,BLOCK,-1,,"{
    // Idle handle is needed only to stop the event loop from blocking in poll.
    uv_idle_start(immediate_idle_handle(), [](uv_idle_t*){ });
  }",12,,1340,2,,void
78570,BLOCK,-1,,"{
    uv_idle_stop(immediate_idle_handle());
  }",10,,1343,1,,void
78575,BLOCK,-1,,"{
  uv_update_time(event_loop());
  uint64_t now = uv_now(event_loop());
  CHECK_GE(now, timer_base());
  now -= timer_base();
  return now;
}",38,,1348,1,,void
78593,BLOCK,-1,,"{
  uint64_t now = GetNowUint64();
  if (now <= 0xffffffff)
    return Integer::NewFromUnsigned(isolate(), static_cast<uint32_t>(now));
  else
    return Number::New(isolate(), static_cast<double>(now));
}",36,,1356,1,,void
78602,BLOCK,-1,,<empty>,5,,1359,2,,void
78613,BLOCK,-1,,<empty>,5,,1361,1,,void
78634,BLOCK,-1,,"{
  obj->Set(env->context(),
           env->errno_string(),
           Integer::New(env->isolate(), errorno)).Check();

  obj->Set(env->context(), env->code_string(),
           OneByteString(env->isolate(), err_string)).Check();

  if (message != nullptr) {
    obj->Set(env->context(), env->message_string(),
             OneByteString(env->isolate(), message)).Check();
  }

  Local<Value> path_buffer;
  if (path != nullptr) {
    path_buffer =
      Buffer::Copy(env->isolate(), path, strlen(path)).ToLocalChecked();
    obj->Set(env->context(), env->path_string(), path_buffer).Check();
  }

  Local<Value> dest_buffer;
  if (dest != nullptr) {
    dest_buffer =
      Buffer::Copy(env->isolate(), dest, strlen(dest)).ToLocalChecked();
    obj->Set(env->context(), env->dest_string(), dest_buffer).Check();
  }

  if (syscall != nullptr) {
    obj->Set(env->context(), env->syscall_string(),
             OneByteString(env->isolate(), syscall)).Check();
  }
}",45,,1371,9,,void
78684,BLOCK,-1,,"{
    obj->Set(env->context(), env->message_string(),
             OneByteString(env->isolate(), message)).Check();
  }",27,,1379,2,,void
78715,BLOCK,-1,,"{
    path_buffer =
      Buffer::Copy(env->isolate(), path, strlen(path)).ToLocalChecked();
    obj->Set(env->context(), env->path_string(), path_buffer).Check();
  }",24,,1385,2,,void
78757,BLOCK,-1,,"{
    dest_buffer =
      Buffer::Copy(env->isolate(), dest, strlen(dest)).ToLocalChecked();
    obj->Set(env->context(), env->dest_string(), dest_buffer).Check();
  }",24,,1392,2,,void
78794,BLOCK,-1,,"{
    obj->Set(env->context(), env->syscall_string(),
             OneByteString(env->isolate(), syscall)).Check();
  }",27,,1398,2,,void
78825,BLOCK,-1,,"{
  if (!object->IsObject() || errorno == 0)
    return;

  Local<Object> obj = object.As<Object>();
  const char* err_string = uv_err_name(errorno);

  if (message == nullptr || message[0] == '\0') {
    message = uv_strerror(errorno);
  }

  node::CollectExceptionInfo(this, obj, errorno, err_string,
                             syscall, message, path, dest);
}",60,,1409,7,,void
78836,BLOCK,-1,,<empty>,5,,1411,2,,void
78863,BLOCK,-1,,"{
    message = uv_strerror(errorno);
  }",49,,1416,2,,void
78885,BLOCK,-1,,<empty>,69,,1425,3,,void
78891,BLOCK,-1,,"{
  return {fields_.Serialize(context, creator)};
}",55,,1428,3,,void
78897,BLOCK,-1,,"{
  fields_.Deserialize(context);
}",57,,1432,2,,void
78908,BLOCK,-1,,"{
  output << ""{ "" << i.fields << "" }"";
  return output;
}",65,,1437,3,,void
78924,BLOCK,-1,,"{
  tracker->TrackField(""fields"", fields_);
}",62,,1442,2,,void
78936,BLOCK,-1,,"{
  return {fields_.Serialize(context, creator)};
}",71,,1447,3,,void
78942,BLOCK,-1,,"{
  fields_.Deserialize(context);
}",52,,1451,2,,void
78953,BLOCK,-1,,"{
  output << ""{ "" << i.fields << "" }"";
  return output;
}",60,,1456,3,,void
78969,BLOCK,-1,,"{
  tracker->TrackField(""fields"", fields_);
}",57,,1461,2,,void
78981,BLOCK,-1,,<empty>,79,,1467,3,,void
78987,BLOCK,-1,,"{
  HandleScope handle_scope(isolate);
  if (info == nullptr) {
    clear_async_id_stack();

    // Always perform async_hooks checks, not just when async_hooks is enabled.
    // TODO(AndreasMadsen): Consider removing this for LTS releases.
    // See discussion in https://github.com/nodejs/node/pull/15454
    // When removing this, do it by reverting the commit. Otherwise the test
    // and flag changes won't be included.
    fields_[kCheck] = 1;

    // kDefaultTriggerAsyncId should be -1, this indicates that there is no
    // specified default value and it should fallback to the executionAsyncId.
    // 0 is not used as the magic value, because that indicates a missing
    // context which is different from a default context.
    async_id_fields_[AsyncHooks::kDefaultTriggerAsyncId] = -1;

    // kAsyncIdCounter should start at 1 because that'll be the id the execution
    // context during bootstrap (code that runs before entering uv_run()).
    async_id_fields_[AsyncHooks::kA...",19,,1474,3,,void
78995,BLOCK,-1,,"{
    clear_async_id_stack();

    // Always perform async_hooks checks, not just when async_hooks is enabled.
    // TODO(AndreasMadsen): Consider removing this for LTS releases.
    // See discussion in https://github.com/nodejs/node/pull/15454
    // When removing this, do it by reverting the commit. Otherwise the test
    // and flag changes won't be included.
    fields_[kCheck] = 1;

    // kDefaultTriggerAsyncId should be -1, this indicates that there is no
    // specified default value and it should fallback to the executionAsyncId.
    // 0 is not used as the magic value, because that indicates a missing
    // context which is different from a default context.
    async_id_fields_[AsyncHooks::kDefaultTriggerAsyncId] = -1;

    // kAsyncIdCounter should start at 1 because that'll be the id the execution
    // context during bootstrap (code that runs before entering uv_run()).
    async_id_fields_[AsyncHooks::kAsyncIdCounter] = 1;
  }",24,,1476,2,,void
79021,BLOCK,-1,,"{
  async_ids_stack_.Deserialize(context);
  fields_.Deserialize(context);
  async_id_fields_.Deserialize(context);

  Local<Array> js_execution_async_resources;
  if (info_->js_execution_async_resources != 0) {
    js_execution_async_resources =
        context->GetDataFromSnapshotOnce<Array>(
            info_->js_execution_async_resources).ToLocalChecked();
  } else {
    js_execution_async_resources = Array::New(context->GetIsolate());
  }
  js_execution_async_resources_.Reset(
      context->GetIsolate(), js_execution_async_resources);

  // The native_execution_async_resources_ field requires v8::Local<> instances
  // for async calls whose resources were on the stack as JS objects when they
  // were entered. We cannot recreate this here; however, storing these values
  // on the JS equivalent gives the same result, so we do that instead.
  for (size_t i = 0; i < info_->native_execution_async_resources.size(); ++i) {
    if (info_->native_execution_async_resources[i] == SIZE_...",54,,1498,2,,void
79048,BLOCK,-1,,"{
    js_execution_async_resources =
        context->GetDataFromSnapshotOnce<Array>(
            info_->js_execution_async_resources).ToLocalChecked();
  }",49,,1504,2,,void
79064,BLOCK,-1,,"{
    js_execution_async_resources = Array::New(context->GetIsolate());
  }",10,,1508,1,,void
79085,BLOCK,-1,,<empty>,3,,1518,1,,void
79100,BLOCK,4,,"{
    if (info_->native_execution_async_resources[i] == SIZE_MAX)
      continue;
    Local<Object> obj = context->GetDataFromSnapshotOnce<Object>(
                                   info_->native_execution_async_resources[i])
                               .ToLocalChecked();
    js_execution_async_resources->Set(context, i, obj).Check();
  }",79,,1518,4,,void
79109,BLOCK,-1,,<empty>,7,,1520,2,,void
79149,BLOCK,-1,,"{
  output << ""{\n""
         << ""  "" << i.async_ids_stack << "",  // async_ids_stack\n""
         << ""  "" << i.fields << "",  // fields\n""
         << ""  "" << i.async_id_fields << "",  // async_id_fields\n""
         << ""  "" << i.js_execution_async_resources
         << "",  // js_execution_async_resources\n""
         << ""  "" << i.native_execution_async_resources
         << "",  // native_execution_async_resources\n""
         << ""}"";
  return output;
}",62,,1530,3,,void
79202,BLOCK,-1,,"{
  SerializeInfo info;
  // TODO(joyeecheung): some of these probably don't need to be serialized.
  info.async_ids_stack = async_ids_stack_.Serialize(context, creator);
  info.fields = fields_.Serialize(context, creator);
  info.async_id_fields = async_id_fields_.Serialize(context, creator);
  if (!js_execution_async_resources_.IsEmpty()) {
    info.js_execution_async_resources = creator->AddData(
        context, js_execution_async_resources_.Get(context->GetIsolate()));
    CHECK_NE(info.js_execution_async_resources, 0);
  } else {
    info.js_execution_async_resources = 0;
  }

  info.native_execution_async_resources.resize(
      native_execution_async_resources_.size());
  for (size_t i = 0; i < native_execution_async_resources_.size(); i++) {
    info.native_execution_async_resources[i] =
        native_execution_async_resources_[i].IsEmpty() ? SIZE_MAX :
            creator->AddData(
                context,
                native_execution_async_resources_[i]);
  }

  // A...",75,,1544,3,,void
79240,BLOCK,-1,,"{
    info.js_execution_async_resources = creator->AddData(
        context, js_execution_async_resources_.Get(context->GetIsolate()));
    CHECK_NE(info.js_execution_async_resources, 0);
  }",49,,1550,2,,void
79264,BLOCK,-1,,"{
    info.js_execution_async_resources = 0;
  }",10,,1554,1,,void
79281,BLOCK,-1,,<empty>,3,,1560,1,,void
79294,BLOCK,4,,"{
    info.native_execution_async_resources[i] =
        native_execution_async_resources_[i].IsEmpty() ? SIZE_MAX :
            creator->AddData(
                context,
                native_execution_async_resources_[i]);
  }",73,,1560,4,,void
79351,BLOCK,-1,,"{
  tracker->TrackField(""async_ids_stack"", async_ids_stack_);
  tracker->TrackField(""fields"", fields_);
  tracker->TrackField(""async_id_fields"", async_id_fields_);
  tracker->TrackField(""js_promise_hooks"", js_promise_hooks_);
}",59,,1578,2,,void
79379,BLOCK,-1,,"{
  async_ids_stack_.reserve(async_ids_stack_.Length() * 3);

  env()->async_hooks_binding()->Set(
      env()->context(),
      env()->async_ids_stack_string(),
      async_ids_stack_.GetJSArray()).Check();
}",41,,1585,1,,void
79416,BLOCK,-1,,"{
  fprintf(stderr,
          ""Error: async hook stack has become corrupted (""
          ""actual: %.f, expected: %.f)\n"",
          async_id_fields_.GetValue(kExecutionAsyncId),
          expected_async_id);
  DumpBacktrace(stderr);
  fflush(stderr);
  // TODO(joyeecheung): should this exit code be more specific?
  if (!env()->abort_on_uncaught_exception()) Exit(ExitCode::kGenericUserError);
  fprintf(stderr, ""\n"");
  fflush(stderr);
  ABORT_NO_BACKTRACE();
}",72,,1594,2,,void
79435,BLOCK,-1,,<empty>,46,,1603,2,,void
79450,BLOCK,-1,,"{
  if (options()->trace_exit) {
    HandleScope handle_scope(isolate());
    Isolate::DisallowJavascriptExecutionScope disallow_js(
        isolate(), Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);

    if (is_main_thread()) {
      fprintf(stderr, ""(node:%d) "", uv_os_getpid());
    } else {
      fprintf(stderr, ""(node:%d, thread:%"" PRIu64 "") "",
              uv_os_getpid(), thread_id());
    }

    fprintf(stderr,
            ""WARNING: Exited the environment with code %d\n"",
            static_cast<int>(exit_code));
    PrintStackTrace(isolate(),
                    StackTrace::CurrentStackTrace(
                        isolate(), stack_trace_limit(), StackTrace::kDetailed));
  }
  process_exit_handler_(this, exit_code);
}",44,,1609,2,,void
79455,BLOCK,-1,,"{
    HandleScope handle_scope(isolate());
    Isolate::DisallowJavascriptExecutionScope disallow_js(
        isolate(), Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);

    if (is_main_thread()) {
      fprintf(stderr, ""(node:%d) "", uv_os_getpid());
    } else {
      fprintf(stderr, ""(node:%d, thread:%"" PRIu64 "") "",
              uv_os_getpid(), thread_id());
    }

    fprintf(stderr,
            ""WARNING: Exited the environment with code %d\n"",
            static_cast<int>(exit_code));
    PrintStackTrace(isolate(),
                    StackTrace::CurrentStackTrace(
                        isolate(), stack_trace_limit(), StackTrace::kDetailed));
  }",30,,1610,2,,void
79469,BLOCK,-1,,"{
      fprintf(stderr, ""(node:%d) "", uv_os_getpid());
    }",27,,1615,2,,void
79475,BLOCK,-1,,"{
      fprintf(stderr, ""(node:%d, thread:%"" PRIu64 "") "",
              uv_os_getpid(), thread_id());
    }",12,,1617,1,,void
79500,BLOCK,-1,,"{
  DCHECK_EQ(Isolate::GetCurrent(), isolate());

  while (!sub_worker_contexts_.empty()) {
    Worker* w = *sub_worker_contexts_.begin();
    remove_sub_worker_context(w);
    w->Exit(ExitCode::kGenericUserError);
    w->JoinThread();
  }
}",46,,1632,1,,void
79513,BLOCK,-1,,"{
    Worker* w = *sub_worker_contexts_.begin();
    remove_sub_worker_context(w);
    w->Exit(ExitCode::kGenericUserError);
    w->JoinThread();
  }",41,,1635,2,,void
79538,BLOCK,-1,,"{
  if (worker_context() == nullptr) return nullptr;
  return worker_context()->env();
}",53,,1643,1,,void
79543,BLOCK,-1,,<empty>,36,,1644,2,,void
79555,BLOCK,-1,,"{
  if (!tracks_unmanaged_fds()) return;
  auto result = unmanaged_fds_.insert(fd);
  if (!result.second) {
    ProcessEmitWarning(
        this, ""File descriptor %d opened in unmanaged mode twice"", fd);
  }
}",42,,1648,2,,void
79559,BLOCK,-1,,<empty>,32,,1649,2,,void
79574,BLOCK,-1,,"{
    ProcessEmitWarning(
        this, ""File descriptor %d opened in unmanaged mode twice"", fd);
  }",23,,1651,2,,void
79583,BLOCK,-1,,"{
  if (!tracks_unmanaged_fds()) return;
  size_t removed_count = unmanaged_fds_.erase(fd);
  if (removed_count == 0) {
    ProcessEmitWarning(
        this, ""File descriptor %d closed but not opened in unmanaged mode"", fd);
  }
}",45,,1657,2,,void
79587,BLOCK,-1,,<empty>,32,,1658,2,,void
79601,BLOCK,-1,,"{
    ProcessEmitWarning(
        this, ""File descriptor %d closed but not opened in unmanaged mode"", fd);
  }",27,,1660,2,,void
79609,BLOCK,-1,,"{
  if (enabled_debug_list()->enabled(DebugCategory::MKSNAPSHOT)) {
    fprintf(stderr, ""At the exit of the Environment:\n"");
    principal_realm()->PrintInfoForSnapshot();
  }
}",49,,1666,1,,void
79618,BLOCK,-1,,"{
    fprintf(stderr, ""At the exit of the Environment:\n"");
    principal_realm()->PrintInfoForSnapshot();
  }",65,,1667,2,,void
79630,BLOCK,-1,,"{
  EnvSerializeInfo info;
  Local<Context> ctx = context();

  info.async_hooks = async_hooks_.Serialize(ctx, creator);
  info.immediate_info = immediate_info_.Serialize(ctx, creator);
  info.timeout_info = timeout_info_.Serialize(ctx, creator);
  info.tick_info = tick_info_.Serialize(ctx, creator);
  info.performance_state = performance_state_->Serialize(ctx, creator);
  info.exit_info = exit_info_.Serialize(ctx, creator);
  info.stream_base_state = stream_base_state_.Serialize(ctx, creator);
  info.should_abort_on_uncaught_toggle =
      should_abort_on_uncaught_toggle_.Serialize(ctx, creator);

  info.principal_realm = principal_realm_->Serialize(creator);
  // For now we only support serialization of the main context.
  // TODO(joyeecheung): support de/serialization of vm contexts.
  CHECK_EQ(contexts_.size(), 1);
  CHECK_EQ(contexts_[0], context());
  return info;
}",67,,1673,2,,void
79748,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  DeserializeRequest request{cb, {isolate(), holder}, index, info};
  deserialize_requests_.push_back(std::move(request));
}",74,,1698,5,,void
79776,BLOCK,-1,,"{
  HandleScope scope(isolate());
  Local<Context> ctx = context();
  Isolate* is = isolate();
  while (!deserialize_requests_.empty()) {
    DeserializeRequest request(std::move(deserialize_requests_.front()));
    deserialize_requests_.pop_front();
    Local<Object> holder = request.holder.Get(is);
    request.cb(ctx, holder, request.index, request.info);
    request.holder.Reset();
    request.info->Delete();
  }
}",44,,1704,1,,void
79797,BLOCK,-1,,"{
    DeserializeRequest request(std::move(deserialize_requests_.front()));
    deserialize_requests_.pop_front();
    Local<Object> holder = request.holder.Get(is);
    request.cb(ctx, holder, request.index, request.info);
    request.holder.Reset();
    request.info->Delete();
  }",42,,1708,2,,void
79853,BLOCK,-1,,"{
  Local<Context> ctx = context();

  if (enabled_debug_list_.enabled(DebugCategory::MKSNAPSHOT)) {
    fprintf(stderr, ""deserializing EnvSerializeInfo...\n"");
    std::cerr << *info << ""\n"";
  }

  // Deserialize the realm's properties before running the deserialize
  // requests as the requests may need to access the realm's properties.
  principal_realm_->DeserializeProperties(&info->principal_realm);
  RunDeserializeRequests();

  async_hooks_.Deserialize(ctx);
  immediate_info_.Deserialize(ctx);
  timeout_info_.Deserialize(ctx);
  tick_info_.Deserialize(ctx);
  performance_state_->Deserialize(ctx);
  exit_info_.Deserialize(ctx);
  stream_base_state_.Deserialize(ctx);
  should_abort_on_uncaught_toggle_.Deserialize(ctx);
}",71,,1718,2,,void
79869,BLOCK,-1,,"{
    fprintf(stderr, ""deserializing EnvSerializeInfo...\n"");
    std::cerr << *info << ""\n"";
  }",63,,1721,2,,void
79933,BLOCK,-1,,"{
  uint64_t free_in_system = uv_get_free_memory();
  size_t allowed = uv_get_constrained_memory();
  if (allowed == 0) {
    return free_in_system;
  }
  size_t rss;
  int err = uv_resident_set_memory(&rss);
  if (err) {
    return free_in_system;
  }
  if (allowed < rss) {
    // Something is probably wrong. Fallback to the free memory.
    return free_in_system;
  }
  // There may still be room for swap, but we will just leave it here.
  return allowed - rss;
}",45,,1741,1,,void
79946,BLOCK,-1,,"{
    return free_in_system;
  }",21,,1744,2,,void
79958,BLOCK,-1,,"{
    return free_in_system;
  }",12,,1749,2,,void
79965,BLOCK,-1,,"{
    // Something is probably wrong. Fallback to the free memory.
    return free_in_system;
  }",22,,1752,2,,void
79978,BLOCK,-1,,"{
  MemoryTracker tracker(isolate, graph);
  Environment* env = static_cast<Environment*>(data);
  // Start traversing embedder objects from the root Environment object.
  tracker.Track(env);
}",50,,1762,4,,void
80000,BLOCK,-1,,"{
  Environment* env = static_cast<Environment*>(data);

  Debug(env,
        DebugCategory::DIAGNOSTICS,
        ""Invoked NearHeapLimitCallback, processing=%d, ""
        ""current_limit=%"" PRIu64 "", ""
        ""initial_limit=%"" PRIu64 ""\n"",
        env->is_in_heapsnapshot_heap_limit_callback_,
        static_cast<uint64_t>(current_heap_limit),
        static_cast<uint64_t>(initial_heap_limit));

  size_t max_young_gen_size = env->isolate_data()->max_young_gen_size;
  size_t young_gen_size = 0;
  size_t old_gen_size = 0;

  HeapSpaceStatistics stats;
  size_t num_heap_spaces = env->isolate()->NumberOfHeapSpaces();
  for (size_t i = 0; i < num_heap_spaces; ++i) {
    env->isolate()->GetHeapSpaceStatistics(&stats, i);
    if (strcmp(stats.space_name(), ""new_space"") == 0 ||
        strcmp(stats.space_name(), ""new_large_object_space"") == 0) {
      young_gen_size += stats.space_used_size();
    } else {
      old_gen_size += stats.space_used_size();
    }
  }

  Debug(env,
        DebugCa...",70,,1771,4,,void
80037,BLOCK,-1,,<empty>,3,,1789,1,,void
80047,BLOCK,4,,"{
    env->isolate()->GetHeapSpaceStatistics(&stats, i);
    if (strcmp(stats.space_name(), ""new_space"") == 0 ||
        strcmp(stats.space_name(), ""new_large_object_space"") == 0) {
      young_gen_size += stats.space_used_size();
    } else {
      old_gen_size += stats.space_used_size();
    }
  }",48,,1789,4,,void
80076,BLOCK,-1,,"{
      young_gen_size += stats.space_used_size();
    }",68,,1792,2,,void
80084,BLOCK,-1,,"{
      old_gen_size += stats.space_used_size();
    }",12,,1794,1,,void
80111,BLOCK,-1,,"{
    Debug(env,
          DebugCategory::DIAGNOSTICS,
          ""Not generating snapshots in nested callback. ""
          ""new_limit=%"" PRIu64 ""\n"",
          static_cast<uint64_t>(new_limit));
    return new_limit;
  }",53,,1832,2,,void
80119,BLOCK,-1,,"{
    Debug(env,
          DebugCategory::DIAGNOSTICS,
          ""Not generating snapshots because it's too risky.\n"");
    env->RemoveHeapSnapshotNearHeapLimitCallback(0);
    // The new limit must be higher than current_heap_limit or V8 might
    // crash.
    return new_limit;
  }",39,,1844,2,,void
80152,BLOCK,-1,,"{
    dir = env->GetCwd();
  }",20,,1858,2,,void
80224,BLOCK,-1,,"{
    Debug(env,
          DebugCategory::DIAGNOSTICS,
          ""Removing the near heap limit callback"");
    env->RemoveHeapSnapshotNearHeapLimitCallback(0);
  }",79,,1879,2,,void
80261,BLOCK,-1,,"{
  size_t size = sizeof(*this);
  // Remove non pointer fields that will be tracked in MemoryInfo()
  // TODO(joyeecheung): refactor the MemoryTracker interface so
  // this can be done for common types within the Track* calls automatically
  // if a certain scope is entered.
  size -= sizeof(async_hooks_);
  size -= sizeof(cleanup_queue_);
  size -= sizeof(tick_info_);
  size -= sizeof(immediate_info_);
  return size;
}",45,,1898,1,,void
80290,BLOCK,-1,,"{
  // Iteratable STLs have their own sizes subtracted from the parent
  // by default.
  tracker->TrackField(""isolate_data"", isolate_data_);
  tracker->TrackField(""destroy_async_id_list"", destroy_async_id_list_);
  tracker->TrackField(""exec_argv"", exec_argv_);
  tracker->TrackField(""exit_info"", exit_info_);
  tracker->TrackField(""should_abort_on_uncaught_toggle"",
                      should_abort_on_uncaught_toggle_);
  tracker->TrackField(""stream_base_state"", stream_base_state_);
  tracker->TrackField(""cleanup_queue"", cleanup_queue_);
  tracker->TrackField(""async_hooks"", async_hooks_);
  tracker->TrackField(""immediate_info"", immediate_info_);
  tracker->TrackField(""timeout_info"", timeout_info_);
  tracker->TrackField(""tick_info"", tick_info_);
  tracker->TrackField(""principal_realm"", principal_realm_);
  tracker->TrackField(""shadow_realms"", shadow_realms_);

  // FIXME(joyeecheung): track other fields in Environment.
  // Currently MemoryTracker is unable to track these
  // corre...",60,,1911,2,,void
80372,BLOCK,-1,,"{
  isolate()->ClearKeptObjects();
}",39,,1940,1,,void
80451,BLOCK,-1,,<empty>,1,,1,1,,ANY
80456,BLOCK,-1,,<empty>,1,,1,1,,ANY
80475,BLOCK,-1,,<empty>,1,,1,1,,ANY
80484,BLOCK,-1,,<empty>,,,,5,,<empty>
80489,BLOCK,-1,,<empty>,,,,2,,<empty>
80494,BLOCK,-1,,<empty>,,,,2,,<empty>
80499,BLOCK,-1,,<empty>,,,,2,,<empty>
80504,BLOCK,-1,,<empty>,,,,2,,<empty>
80511,BLOCK,-1,,<empty>,,,,3,,<empty>
80515,BLOCK,-1,,<empty>,,,,1,,<empty>
80523,BLOCK,-1,,<empty>,,,,5,,<empty>
80530,BLOCK,-1,,<empty>,,,,1,,<empty>
80539,BLOCK,-1,,"{
  MarkAsUninitialized();
}",51,,84,3,,void
80545,BLOCK,-1,,"{
  FSEventWrap* wrap = Unwrap<FSEventWrap>(args.This());
  CHECK_NOT_NULL(wrap);
  args.GetReturnValue().Set(!wrap->IsHandleClosing());
}",75,,89,2,,void
80578,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);
  t->InstanceTemplate()->SetInternalFieldCount(
      FSEventWrap::kInternalFieldCount);

  t->Inherit(HandleWrap::GetConstructorTemplate(env));
  SetProtoMethod(isolate, t, ""start"", Start);

  Local<FunctionTemplate> get_initialized_templ =
      FunctionTemplate::New(env->isolate(),
                            GetInitialized,
                            Local<Value>(),
                            Signature::New(env->isolate(), t));

  t->PrototypeTemplate()->SetAccessorProperty(
      FIXED_ONE_BYTE_STRING(env->isolate(), ""initialized""),
      get_initialized_templ,
      Local<FunctionTemplate>(),
      static_cast<PropertyAttribute>(ReadOnly | DontDelete | DontEnum));

  SetConstructorFunction(context, target, ""FSEvent"", t);
}",42,,98,5,,void
80683,BLOCK,-1,,"{
  registry->Register(New);
  registry->Register(Start);
  registry->Register(GetInitialized);
}",42,,125,2,,void
80703,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);
  new FSEventWrap(env, args.This());
}",64,,131,2,,void
80728,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  FSEventWrap* wrap = Unwrap<FSEventWrap>(args.This());
  CHECK_NOT_NULL(wrap);
  CHECK(wrap->IsHandleClosing());  // Check that Start() has not been called.

  const int argc = args.Length();
  CHECK_GE(argc, 4);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, *path);

  unsigned int flags = 0;
  if (args[2]->IsTrue())
    flags |= UV_FS_EVENT_RECURSIVE;

  wrap->encoding_ = ParseEncoding(env->isolate(), args[3], kDefaultEncoding);

  int err = uv_fs_event_init(wrap->env()->event_loop(), &wrap->handle_);
  if (err != 0) {
    return args.GetReturnValue().Set(err);
  }

  err = uv_fs_event_start(&wrap->handle_, OnEvent, *path, flags);
  wrap->MarkAsInitialized();

  if (err != 0) {
    FSEventWrap::Close(args);
    return args.GetReturnValue().Set(err);
  }

  // Check for persistent argument
  if (!args[1]->IsTru...",66,,138,2,,void
80797,BLOCK,-1,,<empty>,5,,155,2,,void
80833,BLOCK,-1,,"{
    return args.GetReturnValue().Set(err);
  }",17,,160,2,,void
80862,BLOCK,-1,,"{
    FSEventWrap::Close(args);
    return args.GetReturnValue().Set(err);
  }",17,,167,2,,void
80885,BLOCK,-1,,"{
    uv_unref(reinterpret_cast<uv_handle_t*>(&wrap->handle_));
  }",27,,173,2,,void
80908,BLOCK,-1,,"{
  FSEventWrap* wrap = static_cast<FSEventWrap*>(handle->data);
  Environment* env = wrap->env();

  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  CHECK_EQ(wrap->persistent().IsEmpty(), false);

  // We're in a bind here. libuv can set both UV_RENAME and UV_CHANGE but
  // the Node API only lets us pass a single event to JS land.
  //
  // The obvious solution is to run the callback twice, once for each event.
  // However, since the second event is not allowed to fire if the handle is
  // closed after the first event, and since there is no good way to detect
  // closed handles, that option is out.
  //
  // For now, ignore the UV_CHANGE event if UV_RENAME is also set. Make the
  // assumption that a rename implicitly means an attribute change. Not too
  // unreasonable, right? Still, we should revisit this before v1.0.
  Local<String> event_string;
  if (status) {
    event_string = String::Empty(env->isolate());
  } else if (events...",29,,182,5,,void
80952,BLOCK,-1,,"{
    event_string = String::Empty(env->isolate());
  }",15,,203,2,,void
80964,BLOCK,-1,,<empty>,10,,205,1,,void
80969,BLOCK,-1,,"{
    event_string = env->rename_string();
  }",34,,205,2,,void
80977,BLOCK,-1,,<empty>,10,,207,1,,void
80982,BLOCK,-1,,"{
    event_string = env->change_string();
  }",34,,207,2,,void
80990,BLOCK,-1,,"{
    UNREACHABLE(""bad fs events flag"");
  }",10,,209,1,,void
81016,BLOCK,-1,,"{
    Local<Value> error;
    MaybeLocal<Value> fn = StringBytes::Encode(env->isolate(),
                                               filename,
                                               wrap->encoding_,
                                               &error);
    if (fn.IsEmpty()) {
      argv[0] = Integer::New(env->isolate(), UV_EINVAL);
      argv[2] = StringBytes::Encode(env->isolate(),
                                    filename,
                                    strlen(filename),
                                    BUFFER,
                                    &error).ToLocalChecked();
    } else {
      argv[2] = fn.ToLocalChecked();
    }
  }",28,,219,2,,void
81047,BLOCK,-1,,"{
      argv[0] = Integer::New(env->isolate(), UV_EINVAL);
      argv[2] = StringBytes::Encode(env->isolate(),
                                    filename,
                                    strlen(filename),
                                    BUFFER,
                                    &error).ToLocalChecked();
    }",23,,225,2,,void
81083,BLOCK,-1,,"{
      argv[2] = fn.ToLocalChecked();
    }",12,,232,1,,void
81120,BLOCK,-1,,<empty>,1,,1,1,,ANY
81124,BLOCK,-1,,"{
  HandleWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  if (IsAlive(wrap))
    uv_ref(wrap->GetHandle());
}",63,,40,2,,void
81136,BLOCK,-1,,<empty>,5,,45,2,,void
81146,BLOCK,-1,,"{
  HandleWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  if (IsAlive(wrap))
    uv_unref(wrap->GetHandle());
}",65,,49,2,,void
81158,BLOCK,-1,,<empty>,5,,54,2,,void
81168,BLOCK,-1,,"{
  HandleWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  args.GetReturnValue().Set(HasRef(wrap));
}",66,,58,2,,void
81190,BLOCK,-1,,"{
  HandleWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  wrap->Close(args[0]);
}",65,,65,2,,void
81210,BLOCK,-1,,"{
  if (state_ != kInitialized)
    return;

  uv_close(handle_, OnClose);
  state_ = kClosing;

  if (!close_callback.IsEmpty() && close_callback->IsFunction() &&
      !persistent().IsEmpty()) {
    object()->Set(env()->context(),
                  env()->handle_onclose_symbol(),
                  close_callback).Check();
  }
}",53,,72,2,,void
81215,BLOCK,-1,,<empty>,5,,74,2,,void
81240,BLOCK,-1,,"{
    object()->Set(env()->context(),
                  env()->handle_onclose_symbol(),
                  close_callback).Check();
  }",32,,80,2,,void
81260,BLOCK,-1,,"{
  // When all references to a HandleWrap are lost and the object is supposed to
  // be destroyed, we first call Close() to clean up the underlying libuv
  // handle. The OnClose callback then acquires and destroys another reference
  // to that object, and when that reference is lost, we perform the default
  // action (i.e. destroying `this`).
  if (state_ != kClosed) {
    Close();
  } else {
    BaseObject::OnGCCollect();
  }
}",32,,88,1,,void
81265,BLOCK,-1,,"{
    Close();
  }",26,,94,2,,void
81268,BLOCK,-1,,"{
    BaseObject::OnGCCollect();
  }",10,,96,1,,void
81276,BLOCK,-1,,"{
  return IsWeakOrDetached() ||
         !HandleWrap::HasRef(this) ||
         !uv_is_active(GetHandle());
}",60,,102,1,,void
81293,BLOCK,-1,,"{
  env()->handle_wrap_queue()->PushBack(this);
  state_ = kInitialized;
}",38,,109,1,,void
81308,BLOCK,-1,,"{
  handle_wrap_queue_.Remove();
  state_ = kClosed;
}",40,,115,1,,void
81323,BLOCK,-1,,"{
  handle_->data = this;
  HandleScope scope(env->isolate());
  CHECK(env->has_run_bootstrapping_code());
  env->handle_wrap_queue()->PushBack(this);
}",23,,127,5,,void
81352,BLOCK,-1,,"{
  CHECK_NOT_NULL(handle->data);
  BaseObjectPtr<HandleWrap> wrap { static_cast<HandleWrap*>(handle->data) };
  wrap->Detach();

  Environment* env = wrap->env();
  HandleScope scope(env->isolate());
  Context::Scope context_scope(env->context());

  CHECK_EQ(wrap->state_, kClosing);

  wrap->state_ = kClosed;

  wrap->OnClose();
  wrap->handle_wrap_queue_.Remove();

  if (!wrap->persistent().IsEmpty() &&
      wrap->object()->Has(env->context(), env->handle_onclose_symbol())
      .FromMaybe(false)) {
    wrap->MakeCallback(env->handle_onclose_symbol(), 0, nullptr);
  }
}",47,,135,2,,void
81440,BLOCK,-1,,"{
    wrap->MakeCallback(env->handle_onclose_symbol(), 0, nullptr);
  }",26,,153,2,,void
81455,BLOCK,-1,,"{
  return GetConstructorTemplate(env->isolate_data());
}",78,,157,2,,void
81466,BLOCK,-1,,"{
  Local<FunctionTemplate> tmpl = isolate_data->handle_wrap_ctor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = isolate_data->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->SetClassName(
        FIXED_ONE_BYTE_STRING(isolate_data->isolate(), ""HandleWrap""));
    tmpl->Inherit(AsyncWrap::GetConstructorTemplate(isolate_data));
    SetProtoMethod(isolate, tmpl, ""close"", HandleWrap::Close);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""hasRef"", HandleWrap::HasRef);
    SetProtoMethod(isolate, tmpl, ""ref"", HandleWrap::Ref);
    SetProtoMethod(isolate, tmpl, ""unref"", HandleWrap::Unref);
    isolate_data->set_handle_wrap_ctor_template(tmpl);
  }
  return tmpl;
}",32,,162,2,,void
81482,BLOCK,-1,,"{
    Isolate* isolate = isolate_data->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->SetClassName(
        FIXED_ONE_BYTE_STRING(isolate_data->isolate(), ""HandleWrap""));
    tmpl->Inherit(AsyncWrap::GetConstructorTemplate(isolate_data));
    SetProtoMethod(isolate, tmpl, ""close"", HandleWrap::Close);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""hasRef"", HandleWrap::HasRef);
    SetProtoMethod(isolate, tmpl, ""ref"", HandleWrap::Ref);
    SetProtoMethod(isolate, tmpl, ""unref"", HandleWrap::Unref);
    isolate_data->set_handle_wrap_ctor_template(tmpl);
  }",23,,164,2,,void
81553,BLOCK,-1,,"{
  registry->Register(HandleWrap::Close);
  registry->Register(HandleWrap::HasRef);
  registry->Register(HandleWrap::Ref);
  registry->Register(HandleWrap::Unref);
}",42,,180,2,,void
81597,BLOCK,-1,,<empty>,1,,1,1,,ANY
81618,BLOCK,-1,,<empty>,1,,1,1,,ANY
81623,BLOCK,-1,,"{ return ""<JS Node>""; }",31,,49,1,,void
81629,BLOCK,-1,,{ return 0; },33,,50,1,,void
81635,BLOCK,-1,,{ return false; },34,,51,1,,void
81641,BLOCK,-1,,{ return PersistentToLocal::Strong(persistent_); },26,,52,1,,void
81651,BLOCK,-1,,"{
    Local<Value> v = JSValue();
    if (v->IsObject()) return v.As<Object>()->GetIdentityHash();
    if (v->IsName()) return v.As<v8::Name>()->GetIdentityHash();
    if (v->IsInt32()) return v.As<v8::Int32>()->Value();
    return 0;
  }",22,,54,1,,void
81664,BLOCK,-1,,<empty>,24,,56,2,,void
81678,BLOCK,-1,,<empty>,22,,57,2,,void
81692,BLOCK,-1,,<empty>,23,,58,2,,void
81708,BLOCK,-1,,"{
    CHECK(!val.IsEmpty());
  }",35,,63,3,,void
81720,BLOCK,-1,,"{
      return static_cast<size_t>(n->IdentityHash());
    }",54,,68,2,,void
81734,BLOCK,-1,,"{
      return a->JSValue()->SameValue(b->JSValue());
    }",70,,74,3,,void
81753,BLOCK,-1,,<empty>,58,,85,2,,void
81758,BLOCK,-1,,"{
    std::unique_ptr<JSGraphJSNode> n { new JSGraphJSNode(isolate_, value) };
    auto it = engine_nodes_.find(n.get());
    if (it != engine_nodes_.end())
      return *it;
    engine_nodes_.insert(n.get());
    return AddNode(std::unique_ptr<Node>(n.release()));
  }",52,,87,2,,void
81785,BLOCK,-1,,<empty>,7,,91,2,,void
81813,BLOCK,-1,,"{
    Node* n = node.get();
    nodes_.emplace(std::move(node));
    return n;
  }",54,,96,2,,void
81838,BLOCK,-1,,"{
    edges_[from].insert(std::make_pair(name, to));
  }",75,,102,4,,void
81854,BLOCK,-1,,"{
    EscapableHandleScope handle_scope(isolate_);
    Local<Context> context = isolate_->GetCurrentContext();
    Environment* env = Environment::GetCurrent(context);

    std::unordered_map<Node*, Local<Object>> info_objects;
    Local<Array> nodes = Array::New(isolate_, nodes_.size());
    Local<String> edges_string = FIXED_ONE_BYTE_STRING(isolate_, ""edges"");
    Local<String> is_root_string = FIXED_ONE_BYTE_STRING(isolate_, ""isRoot"");
    Local<String> name_string = env->name_string();
    Local<String> size_string = env->size_string();
    Local<String> value_string = env->value_string();
    Local<String> wraps_string = FIXED_ONE_BYTE_STRING(isolate_, ""wraps"");
    Local<String> to_string = FIXED_ONE_BYTE_STRING(isolate_, ""to"");

    for (const std::unique_ptr<Node>& n : nodes_)
      info_objects[n.get()] = Object::New(isolate_);

    {
      HandleScope handle_scope(isolate_);
      size_t i = 0;
      for (const std::unique_ptr<Node>& n : nodes_) {
        Local<Object> obj...",42,,106,1,,void
81973,BLOCK,16,,"{
      HandleScope handle_scope(isolate_);
      size_t i = 0;
      for (const std::unique_ptr<Node>& n : nodes_) {
        Local<Object> obj = info_objects[n.get()];
        Local<Value> value;
        std::string name_str;
        const char* prefix = n->NamePrefix();
        if (prefix == nullptr) {
          name_str = n->Name();
        } else {
          name_str = n->NamePrefix();
          name_str += "" "";
          name_str += n->Name();
        }
        if (!String::NewFromUtf8(isolate_, name_str.c_str()).ToLocal(&value) ||
            obj->Set(context, name_string, value).IsNothing() ||
            obj->Set(context,
                     is_root_string,
                     Boolean::New(isolate_, n->IsRootNode()))
                .IsNothing() ||
            obj->Set(
                   context,
                   size_string,
                   Number::New(isolate_, static_cast<double>(n->SizeInBytes())))
                .IsNothing() ||
            obj->Set(context, edg...",5,,124,16,,void
81984,BLOCK,-1,,"{
        Local<Object> obj = info_objects[n.get()];
        Local<Value> value;
        std::string name_str;
        const char* prefix = n->NamePrefix();
        if (prefix == nullptr) {
          name_str = n->Name();
        } else {
          name_str = n->NamePrefix();
          name_str += "" "";
          name_str += n->Name();
        }
        if (!String::NewFromUtf8(isolate_, name_str.c_str()).ToLocal(&value) ||
            obj->Set(context, name_string, value).IsNothing() ||
            obj->Set(context,
                     is_root_string,
                     Boolean::New(isolate_, n->IsRootNode()))
                .IsNothing() ||
            obj->Set(
                   context,
                   size_string,
                   Number::New(isolate_, static_cast<double>(n->SizeInBytes())))
                .IsNothing() ||
            obj->Set(context, edges_string, Array::New(isolate_)).IsNothing()) {
          return MaybeLocal<Array>();
        }
        if (nodes->S...",53,,127,3,,void
82014,BLOCK,-1,,"{
          name_str = n->Name();
        }",32,,132,2,,void
82022,BLOCK,-1,,"{
          name_str = n->NamePrefix();
          name_str += "" "";
          name_str += n->Name();
        }",16,,134,1,,void
82120,BLOCK,-1,,"{
          return MaybeLocal<Array>();
        }",80,,150,2,,void
82135,BLOCK,-1,,<empty>,11,,154,2,,void
82144,BLOCK,-1,,"{
          value = static_cast<JSGraphJSNode*>(n.get())->JSValue();
          if (obj->Set(context, value_string, value).IsNothing())
            return MaybeLocal<Array>();
        }",35,,155,2,,void
82167,BLOCK,-1,,<empty>,13,,158,2,,void
82173,BLOCK,-1,,"{
      Node* wraps = n->WrapperNode();
      if (wraps == nullptr) continue;
      Local<Object> from = info_objects[n.get()];
      Local<Object> to = info_objects[wraps];
      if (from->Set(context, wraps_string, to).IsNothing())
        return MaybeLocal<Array>();
    }",51,,163,3,,void
82185,BLOCK,-1,,<empty>,29,,165,2,,void
82219,BLOCK,-1,,<empty>,9,,169,2,,void
82225,BLOCK,-1,,"{
      Node* source = edge_info.first;
      Local<Value> edges;
      if (!info_objects[source]->Get(context, edges_string).ToLocal(&edges) ||
          !edges->IsArray()) {
        return MaybeLocal<Array>();
      }

      size_t i = 0;
      size_t j = 0;
      for (const auto& edge : edge_info.second) {
        Local<Object> to_object = info_objects[edge.second];
        Local<Object> edge_obj = Object::New(isolate_);
        Local<Value> edge_name_value;
        const char* edge_name = edge.first;
        if (edge_name != nullptr) {
          if (!String::NewFromUtf8(isolate_, edge_name)
              .ToLocal(&edge_name_value)) {
            return MaybeLocal<Array>();
          }
        } else {
          edge_name_value = Number::New(isolate_, static_cast<double>(j++));
        }
        if (edge_obj->Set(context, name_string, edge_name_value).IsNothing() ||
            edge_obj->Set(context, to_string, to_object).IsNothing() ||
            edges.As<Array>()->Set(context,...",42,,172,3,,void
82258,BLOCK,-1,,"{
        return MaybeLocal<Array>();
      }",30,,176,2,,void
82274,BLOCK,-1,,"{
        Local<Object> to_object = info_objects[edge.second];
        Local<Object> edge_obj = Object::New(isolate_);
        Local<Value> edge_name_value;
        const char* edge_name = edge.first;
        if (edge_name != nullptr) {
          if (!String::NewFromUtf8(isolate_, edge_name)
              .ToLocal(&edge_name_value)) {
            return MaybeLocal<Array>();
          }
        } else {
          edge_name_value = Number::New(isolate_, static_cast<double>(j++));
        }
        if (edge_obj->Set(context, name_string, edge_name_value).IsNothing() ||
            edge_obj->Set(context, to_string, to_object).IsNothing() ||
            edges.As<Array>()->Set(context, i++, edge_obj).IsNothing()) {
          return MaybeLocal<Array>();
        }
      }",49,,182,3,,void
82312,BLOCK,-1,,"{
          if (!String::NewFromUtf8(isolate_, edge_name)
              .ToLocal(&edge_name_value)) {
            return MaybeLocal<Array>();
          }
        }",35,,187,2,,void
82326,BLOCK,-1,,"{
            return MaybeLocal<Array>();
          }",43,,189,2,,void
82330,BLOCK,-1,,"{
          edge_name_value = Number::New(isolate_, static_cast<double>(j++));
        }",16,,192,1,,void
82379,BLOCK,-1,,"{
          return MaybeLocal<Array>();
        }",73,,197,2,,void
82396,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  JSGraph graph(env->isolate());
  Environment::BuildEmbedderGraph(env->isolate(), &graph, env);
  Local<Array> ret;
  if (graph.CreateObject().ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",66,,214,2,,void
82437,BLOCK,-1,,<empty>,5,,220,2,,void
82453,BLOCK,-1,,<empty>,69,,226,3,,void
82457,BLOCK,-1,,"{
    return 65536;  // big chunks == faster
  }",31,,228,1,,void
82463,BLOCK,-1,,<empty>,31,,232,1,,void
82469,BLOCK,-1,,"{
    DCHECK_EQ(status_, 0);
    int offset = 0;
    while (offset < size) {
      const uv_buf_t buf = uv_buf_init(data + offset, size - offset);
      const int num_bytes_written = uv_fs_write(nullptr,
                                                req_,
                                                fd_,
                                                &buf,
                                                1,
                                                -1,
                                                nullptr);
      uv_fs_req_cleanup(req_);
      if (num_bytes_written < 0) {
        status_ = num_bytes_written;
        return kAbort;
      }
      DCHECK_LE(static_cast<size_t>(num_bytes_written), buf.len);
      offset += num_bytes_written;
    }
    DCHECK_EQ(offset, size);
    return kContinue;
  }",68,,234,3,,void
82481,BLOCK,-1,,"{
      const uv_buf_t buf = uv_buf_init(data + offset, size - offset);
      const int num_bytes_written = uv_fs_write(nullptr,
                                                req_,
                                                fd_,
                                                &buf,
                                                1,
                                                -1,
                                                nullptr);
      uv_fs_req_cleanup(req_);
      if (num_bytes_written < 0) {
        status_ = num_bytes_written;
        return kAbort;
      }
      DCHECK_LE(static_cast<size_t>(num_bytes_written), buf.len);
      offset += num_bytes_written;
    }",27,,237,2,,void
82511,BLOCK,-1,,"{
        status_ = num_bytes_written;
        return kAbort;
      }",34,,247,2,,void
82535,BLOCK,-1,,{ return status_; },22,,258,1,,void
82544,BLOCK,-1,,<empty>,,,,1,,<empty>
82555,BLOCK,-1,,"{
    MakeWeak();
    StreamBase::AttachToObject(GetObject());
  }",38,,276,4,,void
82561,BLOCK,-1,,<empty>,34,,281,1,,void
82565,BLOCK,-1,,"{
    return 65536;  // big chunks == faster
  }",31,,283,1,,void
82571,BLOCK,-1,,"{
    EmitRead(UV_EOF);
    snapshot_.reset();
  }",31,,287,1,,void
82582,BLOCK,-1,,"{
    int len = size;
    while (len != 0) {
      uv_buf_t buf = EmitAlloc(size);
      ssize_t avail = len;
      if (static_cast<ssize_t>(buf.len) < avail)
        avail = buf.len;
      memcpy(buf.base, data, avail);
      data += avail;
      len -= static_cast<int>(avail);
      EmitRead(size, buf);
    }
    return kContinue;
  }",62,,292,3,,void
82591,BLOCK,-1,,"{
      uv_buf_t buf = EmitAlloc(size);
      ssize_t avail = len;
      if (static_cast<ssize_t>(buf.len) < avail)
        avail = buf.len;
      memcpy(buf.base, data, avail);
      data += avail;
      len -= static_cast<int>(avail);
      EmitRead(size, buf);
    }",22,,294,2,,void
82609,BLOCK,-1,,<empty>,9,,298,2,,void
82637,BLOCK,-1,,"{
    CHECK_NE(snapshot_, nullptr);
    snapshot_->Serialize(this, HeapSnapshot::kJSON);
    return 0;
  }",28,,307,1,,void
82654,BLOCK,-1,,"{
    return 0;
  }",27,,313,1,,void
82661,BLOCK,-1,,"{
    UNREACHABLE();
  }",51,,317,2,,void
82670,BLOCK,-1,,"{
    UNREACHABLE();
  }",50,,324,5,,void
82675,BLOCK,-1,,{ return snapshot_ != nullptr; },27,,328,1,,void
82683,BLOCK,-1,,{ return snapshot_ == nullptr; },29,,329,1,,void
82691,BLOCK,-1,,{ return this; },38,,330,1,,void
82698,BLOCK,-1,,"{
    if (snapshot_ != nullptr) {
      tracker->TrackFieldWithSize(
          ""snapshot"", sizeof(*snapshot_), ""HeapSnapshot"");
    }
  }",58,,332,2,,void
82703,BLOCK,-1,,"{
      tracker->TrackFieldWithSize(
          ""snapshot"", sizeof(*snapshot_), ""HeapSnapshot"");
    }",31,,333,2,,void
82724,BLOCK,-1,,"{
  HeapSnapshotPointer snapshot{
      env->isolate()->GetHeapProfiler()->TakeHeapSnapshot(options)};
  snapshot->Serialize(out, HeapSnapshot::kJSON);
}",69,,348,4,,void
82754,BLOCK,-1,,"{
  uv_fs_t req;
  int err;

  const int fd = uv_fs_open(nullptr,
                            &req,
                            filename,
                            O_WRONLY | O_CREAT | O_TRUNC,
                            S_IWUSR | S_IRUSR,
                            nullptr);
  uv_fs_req_cleanup(&req);
  if ((err = fd) < 0) {
    env->ThrowUVException(err, ""open"", nullptr, filename);
    return Nothing<void>();
  }

  FileOutputStream stream(fd, &req);
  TakeSnapshot(env, &stream, options);
  if ((err = stream.status()) < 0) {
    env->ThrowUVException(err, ""write"", nullptr, filename);
    return Nothing<void>();
  }

  err = uv_fs_close(nullptr, &req, fd, nullptr);
  uv_fs_req_cleanup(&req);
  if (err < 0) {
    env->ThrowUVException(err, ""close"", nullptr, filename);
    return Nothing<void>();
  }

  return JustVoid();
}",70,,358,4,,void
82783,BLOCK,-1,,"{
    env->ThrowUVException(err, ""open"", nullptr, filename);
    return Nothing<void>();
  }",23,,369,2,,void
82813,BLOCK,-1,,"{
    env->ThrowUVException(err, ""write"", nullptr, filename);
    return Nothing<void>();
  }",36,,376,2,,void
82839,BLOCK,-1,,"{
    env->ThrowUVException(err, ""close"", nullptr, filename);
    return Nothing<void>();
  }",16,,383,2,,void
82856,BLOCK,-1,,"{
  const_cast<HeapSnapshot*>(snapshot)->Delete();
}",55,,391,2,,void
82868,BLOCK,-1,,"{
  HandleScope scope(env->isolate());

  if (env->streambaseoutputstream_constructor_template().IsEmpty()) {
    // Create FunctionTemplate for HeapSnapshotStream
    Local<FunctionTemplate> os = FunctionTemplate::New(env->isolate());
    os->Inherit(AsyncWrap::GetConstructorTemplate(env));
    Local<ObjectTemplate> ost = os->InstanceTemplate();
    ost->SetInternalFieldCount(StreamBase::kInternalFieldCount);
    os->SetClassName(
        FIXED_ONE_BYTE_STRING(env->isolate(), ""HeapSnapshotStream""));
    StreamBase::AddMethods(env, os);
    env->set_streambaseoutputstream_constructor_template(ost);
  }

  Local<Object> obj;
  if (!env->streambaseoutputstream_constructor_template()
           ->NewInstance(env->context())
           .ToLocal(&obj)) {
    return {};
  }
  return MakeBaseObject<HeapSnapshotStream>(env, std::move(snapshot), obj);
}",55,,396,3,,void
82883,BLOCK,-1,,"{
    // Create FunctionTemplate for HeapSnapshotStream
    Local<FunctionTemplate> os = FunctionTemplate::New(env->isolate());
    os->Inherit(AsyncWrap::GetConstructorTemplate(env));
    Local<ObjectTemplate> ost = os->InstanceTemplate();
    ost->SetInternalFieldCount(StreamBase::kInternalFieldCount);
    os->SetClassName(
        FIXED_ONE_BYTE_STRING(env->isolate(), ""HeapSnapshotStream""));
    StreamBase::AddMethods(env, os);
    env->set_streambaseoutputstream_constructor_template(ost);
  }",69,,399,2,,void
82968,BLOCK,-1,,"{
    return {};
  }",28,,414,2,,void
82988,BLOCK,-1,,"{
  CHECK(options_value->IsUint8Array());
  Local<Uint8Array> arr = options_value.As<Uint8Array>();
  uint8_t* options =
      static_cast<uint8_t*>(arr->Buffer()->Data()) + arr->ByteOffset();
  HeapProfiler::HeapSnapshotOptions result;
  result.snapshot_mode = options[0]
                             ? HeapProfiler::HeapSnapshotMode::kExposeInternals
                             : HeapProfiler::HeapSnapshotMode::kRegular;
  result.numerics_mode = options[1]
                             ? HeapProfiler::NumericsMode::kExposeNumericValues
                             : HeapProfiler::NumericsMode::kHideNumericValues;
  return result;
}",33,,421,2,,void
83064,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK_EQ(args.Length(), 1);
  auto options = GetHeapSnapshotOptions(args[0]);
  HeapSnapshotPointer snapshot{
      env->isolate()->GetHeapProfiler()->TakeHeapSnapshot(options)};
  CHECK(snapshot);
  BaseObjectPtr<AsyncWrap> stream =
      CreateHeapSnapshotStream(env, std::move(snapshot));
  if (stream)
    args.GetReturnValue().Set(stream->object());
}",72,,436,2,,void
83118,BLOCK,-1,,<empty>,5,,446,2,,void
83134,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = args.GetIsolate();
  CHECK_EQ(args.Length(), 2);
  Local<Value> filename_v = args[0];
  auto options = GetHeapSnapshotOptions(args[1]);

  if (filename_v->IsUndefined()) {
    DiagnosticFilename name(env, ""Heap"", ""heapsnapshot"");
    THROW_IF_INSUFFICIENT_PERMISSIONS(
        env, permission::PermissionScope::kFileSystemWrite, env->GetCwd());
    if (WriteSnapshot(env, *name, options).IsNothing()) return;
    if (String::NewFromUtf8(isolate, *name).ToLocal(&filename_v)) {
      args.GetReturnValue().Set(filename_v);
    }
    return;
  }

  BufferValue path(isolate, filename_v);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, path.ToStringView());
  if (WriteSnapshot(env, *path, options).IsNothing()) return;
  return args.GetReturnValue().Set(filename_v);
}",67,,449,2,,void
83177,BLOCK,-1,,"{
    DiagnosticFilename name(env, ""Heap"", ""heapsnapshot"");
    THROW_IF_INSUFFICIENT_PERMISSIONS(
        env, permission::PermissionScope::kFileSystemWrite, env->GetCwd());
    if (WriteSnapshot(env, *name, options).IsNothing()) return;
    if (String::NewFromUtf8(isolate, *name).ToLocal(&filename_v)) {
      args.GetReturnValue().Set(filename_v);
    }
    return;
  }",34,,456,2,,void
83203,BLOCK,-1,,<empty>,57,,460,2,,void
83218,BLOCK,-1,,"{
      args.GetReturnValue().Set(filename_v);
    }",67,,461,2,,void
83255,BLOCK,-1,,<empty>,55,,471,2,,void
83273,BLOCK,-1,,"{
  SetMethod(context, target, ""buildEmbedderGraph"", BuildEmbedderGraph);
  SetMethod(context, target, ""triggerHeapSnapshot"", TriggerHeapSnapshot);
  SetMethod(
      context, target, ""createHeapSnapshotStream"", CreateHeapSnapshotStream);
}",29,,478,5,,void
83293,BLOCK,-1,,"{
  registry->Register(BuildEmbedderGraph);
  registry->Register(TriggerHeapSnapshot);
  registry->Register(CreateHeapSnapshotStream);
}",70,,485,2,,void
83322,BLOCK,-1,,<empty>,1,,1,1,,ANY
83327,BLOCK,-1,,"{
    USE(map->Set(
          env->context(),
          Number::New(env->isolate(), key),
          Number::New(env->isolate(), static_cast<double>(value))));
  }",67,,163,3,,void
83365,BLOCK,-1,,"{
    USE(map->Set(
          env->context(),
          Number::New(env->isolate(), key),
          BigInt::New(env->isolate(), value)));
  }",67,,178,3,,void
83400,BLOCK,-1,,"{
    USE(map->Set(
          env->context(),
          Number::New(env->isolate(), key),
          Number::New(env->isolate(), static_cast<double>(value))));
  }",67,,603,3,,void
83437,BLOCK,-1,,"{
    USE(map->Set(
          env->context(),
          Number::New(env->isolate(), key),
          BigInt::New(env->isolate(), value)));
  }",67,,618,3,,void
83483,BLOCK,-1,,<empty>,1,,1,1,,ANY
83487,BLOCK,-1,,"{
  hdr_histogram* histogram;
  CHECK_EQ(0, hdr_init(options.lowest,
                       options.highest,
                       options.figures,
                       &histogram));
  histogram_.reset(histogram);
}",46,,24,2,,void
83512,BLOCK,-1,,"{
  tracker->TrackFieldWithSize(""histogram"", GetMemorySize());
}",58,,33,2,,void
83523,BLOCK,-1,,<empty>,42,,38,2,,void
83528,BLOCK,-1,,<empty>,40,,41,2,,void
83535,BLOCK,-1,,"{
  MakeWeak();
}",30,,48,4,,void
83543,BLOCK,-1,,"{
  MakeWeak();
}",43,,57,4,,void
83549,BLOCK,-1,,"{
  tracker->TrackField(""histogram"", histogram());
}",62,,61,2,,void
83560,BLOCK,-1,,"{
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  double value = static_cast<double>((*histogram)->Count());
  args.GetReturnValue().Set(value);
}",79,,65,2,,void
83591,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set(
      BigInt::NewFromUnsigned(env->isolate(), (*histogram)->Count()));
}",54,,73,2,,void
83632,BLOCK,-1,,"{
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  double value = static_cast<double>((*histogram)->Min());
  args.GetReturnValue().Set(value);
}",69,,81,2,,void
83663,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set(BigInt::New(env->isolate(), (*histogram)->Min()));
}",75,,88,2,,void
83704,BLOCK,-1,,"{
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  double value = static_cast<double>((*histogram)->Max());
  args.GetReturnValue().Set(value);
}",69,,95,2,,void
83735,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set(
      BigInt::New(env->isolate(), (*histogram)->Max()));
}",75,,102,2,,void
83776,BLOCK,-1,,"{
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set((*histogram)->Mean());
}",70,,110,2,,void
83801,BLOCK,-1,,"{
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  double value = static_cast<double>((*histogram)->Exceeds());
  args.GetReturnValue().Set(value);
}",73,,116,2,,void
83832,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set(
      BigInt::NewFromUnsigned(env->isolate(), (*histogram)->Exceeds()));
}",79,,123,2,,void
83873,BLOCK,-1,,"{
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set((*histogram)->Stddev());
}",72,,131,2,,void
83898,BLOCK,-1,,"{
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  CHECK(args[0]->IsNumber());
  double percentile = args[0].As<Number>()->Value();
  double value = static_cast<double>((*histogram)->Percentile(percentile));
  args.GetReturnValue().Set(value);
}",76,,137,2,,void
83949,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  CHECK(args[0]->IsNumber());
  double percentile = args[0].As<Number>()->Value();
  int64_t value = (*histogram)->Percentile(percentile);
  args.GetReturnValue().Set(BigInt::New(env->isolate(), value));
}",46,,147,2,,void
84014,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  CHECK(args[0]->IsMap());
  Local<Map> map = args[0].As<Map>();
  (*histogram)->Percentiles([map, env](double key, int64_t value) {
    USE(map->Set(
          env->context(),
          Number::New(env->isolate(), key),
          Number::New(env->isolate(), static_cast<double>(value))));
  });
}",77,,157,2,,void
84059,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  CHECK(args[0]->IsMap());
  Local<Map> map = args[0].As<Map>();
  (*histogram)->Percentiles([map, env](double key, int64_t value) {
    USE(map->Set(
          env->context(),
          Number::New(env->isolate(), key),
          BigInt::New(env->isolate(), value)));
  });
}",46,,172,2,,void
84104,BLOCK,-1,,"{
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  (*histogram)->Reset();
}",70,,186,2,,void
84122,BLOCK,-1,,"{
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  (*histogram)->RecordDelta();
}",74,,192,2,,void
84140,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK_IMPLIES(!args[0]->IsNumber(), args[0]->IsBigInt());
  bool lossless = true;
  int64_t value = args[0]->IsBigInt()
      ? args[0].As<BigInt>()->Int64Value(&lossless)
      : static_cast<int64_t>(args[0].As<Number>()->Value());
  if (!lossless || value < 1)
    return THROW_ERR_OUT_OF_RANGE(env, ""value is out of range"");
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  (*histogram)->Record(value);
}",69,,198,2,,void
84206,BLOCK,-1,,<empty>,5,,206,2,,void
84229,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());

  CHECK(GetConstructorTemplate(env->isolate_data())->HasInstance(args[0]));
  HistogramBase* other;
  ASSIGN_OR_RETURN_UNWRAP(&other, args[0]);

  double count = (*histogram)->Add(*(other->histogram()));
  args.GetReturnValue().Set(count);
}",66,,212,2,,void
84291,BLOCK,-1,,"{
  Local<Object> obj;
  if (!GetConstructorTemplate(env->isolate_data())
           ->InstanceTemplate()
           ->NewInstance(env->context())
           .ToLocal(&obj)) {
    return BaseObjectPtr<HistogramBase>();
  }

  return MakeBaseObject<HistogramBase>(env, obj, options);
}",40,,227,3,,void
84319,BLOCK,-1,,"{
    return BaseObjectPtr<HistogramBase>();
  }",28,,232,2,,void
84337,BLOCK,-1,,"{
  Local<Object> obj;
  if (!GetConstructorTemplate(env->isolate_data())
           ->InstanceTemplate()
           ->NewInstance(env->context())
           .ToLocal(&obj)) {
    return BaseObjectPtr<HistogramBase>();
  }
  return MakeBaseObject<HistogramBase>(env, obj, std::move(histogram));
}",43,,241,3,,void
84365,BLOCK,-1,,"{
    return BaseObjectPtr<HistogramBase>();
  }",28,,246,2,,void
84386,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);

  CHECK_IMPLIES(!args[0]->IsNumber(), args[0]->IsBigInt());
  CHECK_IMPLIES(!args[1]->IsNumber(), args[1]->IsBigInt());
  CHECK(args[2]->IsUint32());

  int64_t lowest = 1;
  int64_t highest = std::numeric_limits<int64_t>::max();

  bool lossless_ignored;

  if (args[0]->IsNumber()) {
    lowest = args[0].As<Integer>()->Value();
  } else if (args[0]->IsBigInt()) {
    lowest = args[0].As<BigInt>()->Int64Value(&lossless_ignored);
  }

  if (args[1]->IsNumber()) {
    highest = args[1].As<Integer>()->Value();
  } else if (args[1]->IsBigInt()) {
    highest = args[1].As<BigInt>()->Int64Value(&lossless_ignored);
  }

  int32_t figures = args[2].As<Uint32>()->Value();
  new HistogramBase(env, args.This(), Histogram::Options {
    lowest, highest, figures
  });
}",66,,252,2,,void
84460,BLOCK,-1,,"{
    lowest = args[0].As<Integer>()->Value();
  }",28,,265,2,,void
84473,BLOCK,-1,,<empty>,10,,267,1,,void
84481,BLOCK,-1,,"{
    lowest = args[0].As<BigInt>()->Int64Value(&lossless_ignored);
  }",35,,267,2,,void
84502,BLOCK,-1,,"{
    highest = args[1].As<Integer>()->Value();
  }",28,,271,2,,void
84515,BLOCK,-1,,<empty>,10,,273,1,,void
84523,BLOCK,-1,,"{
    highest = args[1].As<BigInt>()->Int64Value(&lossless_ignored);
  }",35,,273,2,,void
84565,BLOCK,-1,,"{
  Local<FunctionTemplate> tmpl = isolate_data->histogram_ctor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = isolate_data->isolate();
    tmpl = NewFunctionTemplate(isolate, New);
    Local<String> classname = FIXED_ONE_BYTE_STRING(isolate, ""Histogram"");
    tmpl->SetClassName(classname);

    tmpl->InstanceTemplate()->SetInternalFieldCount(
        HistogramBase::kInternalFieldCount);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""count"", GetCount);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""countBigInt"", GetCountBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""exceeds"", GetExceeds);
    SetProtoMethodNoSideEffect(
        isolate, tmpl, ""exceedsBigInt"", GetExceedsBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""min"", GetMin);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""minBigInt"", GetMinBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""max"", GetMax);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""maxBigInt"", GetMaxBigInt);
    SetProtoMetho...",32,,284,2,,void
84581,BLOCK,-1,,"{
    Isolate* isolate = isolate_data->isolate();
    tmpl = NewFunctionTemplate(isolate, New);
    Local<String> classname = FIXED_ONE_BYTE_STRING(isolate, ""Histogram"");
    tmpl->SetClassName(classname);

    tmpl->InstanceTemplate()->SetInternalFieldCount(
        HistogramBase::kInternalFieldCount);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""count"", GetCount);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""countBigInt"", GetCountBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""exceeds"", GetExceeds);
    SetProtoMethodNoSideEffect(
        isolate, tmpl, ""exceedsBigInt"", GetExceedsBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""min"", GetMin);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""minBigInt"", GetMinBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""max"", GetMax);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""maxBigInt"", GetMaxBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""mean"", GetMean);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""stdd...",23,,286,2,,void
84719,BLOCK,-1,,"{
  registry->Register(New);
  registry->Register(GetCount);
  registry->Register(GetCountBigInt);
  registry->Register(GetExceeds);
  registry->Register(GetExceedsBigInt);
  registry->Register(GetMin);
  registry->Register(GetMinBigInt);
  registry->Register(GetMax);
  registry->Register(GetMaxBigInt);
  registry->Register(GetMean);
  registry->Register(GetStddev);
  registry->Register(GetPercentile);
  registry->Register(GetPercentileBigInt);
  registry->Register(GetPercentiles);
  registry->Register(GetPercentilesBigInt);
  registry->Register(DoReset);
  registry->Register(Record);
  registry->Register(RecordDelta);
  registry->Register(Add);
}",42,,321,2,,void
84820,BLOCK,-1,,"{
  SetConstructorFunction(isolate_data->isolate(),
                         target,
                         ""Histogram"",
                         GetConstructorTemplate(isolate_data),
                         SetConstructorFunctionFlag::NONE);
}",62,,344,3,,void
84839,BLOCK,-1,,"{
  return Create(env, std::move(histogram_));
}",49,,355,4,,void
84851,BLOCK,-1,,"{
  return std::make_unique<HistogramTransferData>(this);
}",80,,359,1,,void
84864,BLOCK,-1,,"{
  tracker->TrackField(""histogram"", histogram_);
}",35,,364,2,,void
84875,BLOCK,-1,,"{
  Local<FunctionTemplate> tmpl = env->intervalhistogram_constructor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->Inherit(HandleWrap::GetConstructorTemplate(env));
    tmpl->SetClassName(OneByteString(isolate, ""Histogram""));
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        HistogramBase::kInternalFieldCount);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""count"", GetCount);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""countBigInt"", GetCountBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""exceeds"", GetExceeds);
    SetProtoMethodNoSideEffect(
        isolate, tmpl, ""exceedsBigInt"", GetExceedsBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""min"", GetMin);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""minBigInt"", GetMinBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""max"", GetMax);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""maxBigInt"", GetMaxBigInt);
    Se...",23,,369,2,,void
84891,BLOCK,-1,,"{
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->Inherit(HandleWrap::GetConstructorTemplate(env));
    tmpl->SetClassName(OneByteString(isolate, ""Histogram""));
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        HistogramBase::kInternalFieldCount);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""count"", GetCount);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""countBigInt"", GetCountBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""exceeds"", GetExceeds);
    SetProtoMethodNoSideEffect(
        isolate, tmpl, ""exceedsBigInt"", GetExceedsBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""min"", GetMin);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""minBigInt"", GetMinBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""max"", GetMax);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""maxBigInt"", GetMaxBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""mean"", GetMean);
    SetProtoMethodNoSideEffect(isolate, tmpl, ...",23,,371,2,,void
85026,BLOCK,-1,,"{
  registry->Register(GetCount);
  registry->Register(GetCountBigInt);
  registry->Register(GetExceeds);
  registry->Register(GetExceedsBigInt);
  registry->Register(GetMin);
  registry->Register(GetMinBigInt);
  registry->Register(GetMax);
  registry->Register(GetMaxBigInt);
  registry->Register(GetMean);
  registry->Register(GetStddev);
  registry->Register(GetPercentile);
  registry->Register(GetPercentileBigInt);
  registry->Register(GetPercentiles);
  registry->Register(GetPercentilesBigInt);
  registry->Register(DoReset);
  registry->Register(Start);
  registry->Register(Stop);
}",42,,404,2,,void
85121,BLOCK,-1,,"{
  MakeWeak();
  uv_timer_init(env->event_loop(), &timer_);
}",44,,438,7,,void
85137,BLOCK,-1,,"{
  Local<Object> obj;
  if (!GetConstructorTemplate(env)
          ->InstanceTemplate()
          ->NewInstance(env->context()).ToLocal(&obj)) {
    return BaseObjectPtr<IntervalHistogram>();
  }

  return MakeBaseObject<IntervalHistogram>(
      env,
      obj,
      AsyncWrap::PROVIDER_ELDHISTOGRAM,
      interval,
      std::move(on_interval),
      options);
}",40,,447,5,,void
85162,BLOCK,-1,,"{
    return BaseObjectPtr<IntervalHistogram>();
  }",56,,451,2,,void
85188,BLOCK,-1,,"{
  IntervalHistogram* histogram =
      ContainerOf(&IntervalHistogram::timer_, handle);

  Histogram* h = histogram->histogram().get();

  histogram->on_interval_(*h);
}",53,,464,2,,void
85218,BLOCK,-1,,"{
  tracker->TrackField(""histogram"", histogram());
}",66,,473,2,,void
85229,BLOCK,-1,,"{
  if (enabled_ || IsHandleClosing()) return;
  enabled_ = true;
  if (flags == StartFlags::RESET)
    histogram()->Reset();
  uv_timer_start(&timer_, TimerCB, interval_, interval_);
  uv_unref(reinterpret_cast<uv_handle_t*>(&timer_));
}",51,,477,2,,void
85234,BLOCK,-1,,<empty>,38,,478,2,,void
85245,BLOCK,-1,,<empty>,5,,481,2,,void
85264,BLOCK,-1,,"{
  if (!enabled_ || IsHandleClosing()) return;
  enabled_ = false;
  uv_timer_stop(&timer_);
}",34,,486,1,,void
85270,BLOCK,-1,,<empty>,39,,487,2,,void
85280,BLOCK,-1,,"{
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  histogram->OnStart(args[0]->IsTrue() ? StartFlags::RESET : StartFlags::NONE);
}",72,,492,2,,void
85310,BLOCK,-1,,"{
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  histogram->OnStop();
}",71,,498,2,,void
85327,BLOCK,-1,,"{
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  double value = static_cast<double>((*histogram)->Count());
  args.GetReturnValue().Set(value);
}",75,,504,2,,void
85358,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set(
      BigInt::NewFromUnsigned(env->isolate(), (*histogram)->Count()));
}",54,,512,2,,void
85399,BLOCK,-1,,"{
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  double value = static_cast<double>((*histogram)->Min());
  args.GetReturnValue().Set(value);
}",73,,520,2,,void
85430,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set(BigInt::New(env->isolate(), (*histogram)->Min()));
}",79,,527,2,,void
85471,BLOCK,-1,,"{
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  double value = static_cast<double>((*histogram)->Max());
  args.GetReturnValue().Set(value);
}",73,,534,2,,void
85502,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set(BigInt::New(env->isolate(), (*histogram)->Min()));
}",79,,541,2,,void
85543,BLOCK,-1,,"{
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set((*histogram)->Mean());
}",74,,548,2,,void
85568,BLOCK,-1,,"{
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  double value = static_cast<double>((*histogram)->Exceeds());
  args.GetReturnValue().Set(value);
}",77,,554,2,,void
85599,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set(
      BigInt::New(env->isolate(), (*histogram)->Exceeds()));
}",46,,562,2,,void
85640,BLOCK,-1,,"{
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set((*histogram)->Stddev());
}",76,,570,2,,void
85665,BLOCK,-1,,"{
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  CHECK(args[0]->IsNumber());
  double percentile = args[0].As<Number>()->Value();
  double value = static_cast<double>((*histogram)->Percentile(percentile));
  args.GetReturnValue().Set(value);
}",80,,576,2,,void
85716,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  CHECK(args[0]->IsNumber());
  double percentile = args[0].As<Number>()->Value();
  int64_t value = (*histogram)->Percentile(percentile);
  args.GetReturnValue().Set(BigInt::New(env->isolate(), value));
}",46,,586,2,,void
85781,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  CHECK(args[0]->IsMap());
  Local<Map> map = args[0].As<Map>();
  (*histogram)->Percentiles([map, env](double key, int64_t value) {
    USE(map->Set(
          env->context(),
          Number::New(env->isolate(), key),
          Number::New(env->isolate(), static_cast<double>(value))));
  });
}",46,,597,2,,void
85826,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  CHECK(args[0]->IsMap());
  Local<Map> map = args[0].As<Map>();
  (*histogram)->Percentiles([map, env](double key, int64_t value) {
    USE(map->Set(
          env->context(),
          Number::New(env->isolate(), key),
          BigInt::New(env->isolate(), value)));
  });
}",46,,612,2,,void
85871,BLOCK,-1,,"{
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  (*histogram)->Reset();
}",74,,626,2,,void
85888,BLOCK,-1,,"{
  return std::make_unique<HistogramBase::HistogramTransferData>(histogram());
}",46,,633,1,,void
85927,BLOCK,-1,,<empty>,1,,1,1,,ANY
85931,BLOCK,-1,,"{
      delegate->SendMessageToFrontend(m->string());
    }",46,,188,2,,void
85946,BLOCK,-1,,"{
      if (auto iface = weak_self.lock()) iface->DispatchMessages();
    }",63,,214,2,,void
85948,BLOCK,-1,,<empty>,11,,215,1,,void
85956,BLOCK,-1,,<empty>,42,,215,2,,void
85980,BLOCK,-1,,<empty>,1,,1,1,,ANY
85987,BLOCK,-1,,<empty>,54,,21,2,,void
85991,BLOCK,-1,,<empty>,,,,1,,<empty>
85997,BLOCK,-1,,"{
    return
        static_cast<DeletableWrapper<T>*>(thread->GetObject(id))->object_.get();
  }",54,,24,3,,void
86016,BLOCK,-1,,"{
  return std::unique_ptr<DeletableWrapper<T>>(
      new DeletableWrapper<T>(std::move(object)));
}",71,,34,2,,void
86039,BLOCK,-1,,<empty>,77,,43,3,,void
86044,BLOCK,-1,,"{
    thread->AddObject(object_id_, WrapInDeletable(factory_(thread)));
  }",51,,45,2,,void
86060,BLOCK,-1,,"{
  return std::unique_ptr<Request>(
      new CreateObjectRequest<Factory>(object_id, std::move(factory)));
}",75,,55,3,,void
86081,BLOCK,-1,,<empty>,65,,62,2,,void
86086,BLOCK,-1,,"{
    thread->RemoveObject(object_id_);
  }",51,,64,2,,void
86099,BLOCK,-1,,<empty>,60,,75,3,,void
86104,BLOCK,-1,,"{
    fn_(DeletableWrapper<Target>::get(thread, id_));
  }",51,,77,2,,void
86120,BLOCK,-1,,<empty>,48,,91,3,,void
86126,BLOCK,-1,,"{
    thread_->Post(NewCreateRequest(object_id_, std::move(factory)));
  }",69,,96,3,,void
86142,BLOCK,-1,,<empty>,,,,2,,<empty>
86146,BLOCK,-1,,"{
    // Disappearing thread may cause a memory leak
    thread_->Post(std::make_unique<DeleteRequest>(object_id_));
  }",35,,101,1,,void
86162,BLOCK,-1,,"{
    using Request = CallRequest<T, Fn>;
    thread_->Post(std::unique_ptr<Request>(
        new Request(object_id_, std::move(fn))));
  }",26,,107,2,,void
86187,BLOCK,-1,,"{
    Call(std::bind(Apply<Arg>, std::placeholders::_1, fn, std::move(argument)));
  }",53,,114,3,,void
86211,BLOCK,-1,,"{
    (target->*fn)(std::move(argument));
  }",59,,123,4,,void
86229,BLOCK,-1,,<empty>,64,,135,3,,void
86235,BLOCK,-1,,"{
    return std::make_unique<MainThreadSessionState>(thread, prevent_shutdown);
  }",59,,138,3,,void
86251,BLOCK,-1,,"{
    Agent* agent = thread_->inspector_agent();
    if (agent != nullptr)
      session_ = agent->Connect(std::move(delegate), prevent_shutdown_);
  }",68,,142,2,,void
86263,BLOCK,-1,,<empty>,7,,145,2,,void
86280,BLOCK,-1,,"{
    session_->Dispatch(message->string());
  }",56,,148,2,,void
86300,BLOCK,-1,,"{
    state_.Call(&MainThreadSessionState::Connect, std::move(delegate));
  }",53,,167,5,,void
86318,BLOCK,-1,,"{
    state_.Call(&MainThreadSessionState::Dispatch,
                StringBuffer::create(message));
  }",53,,171,2,,void
86338,BLOCK,-1,,<empty>,70,,183,3,,void
86343,BLOCK,-1,,"{
    delegate_.Call(
        [m = StringBuffer::create(message)]
        (InspectorSessionDelegate* delegate) {
      delegate->SendMessageToFrontend(m->string());
    });
  }",80,,185,2,,void
86355,BLOCK,-1,,<empty>,72,,200,2,,void
86359,BLOCK,-1,,"{
  if (handle_)
    handle_->Reset();
}",45,,202,1,,void
86362,BLOCK,-1,,<empty>,5,,204,2,,void
86371,BLOCK,-1,,"{
  CHECK_NOT_NULL(agent_);
  Mutex::ScopedLock scoped_lock(requests_lock_);
  bool needs_notify = requests_.empty();
  requests_.push_back(std::move(request));
  if (needs_notify) {
    std::weak_ptr<MainThreadInterface> weak_self {shared_from_this()};
    agent_->env()->RequestInterrupt([weak_self](Environment*) {
      if (auto iface = weak_self.lock()) iface->DispatchMessages();
    });
  }
  incoming_message_cond_.Broadcast(scoped_lock);
}",66,,207,2,,void
86395,BLOCK,-1,,"{
    std::weak_ptr<MainThreadInterface> weak_self {shared_from_this()};
    agent_->env()->RequestInterrupt([weak_self](Environment*) {
      if (auto iface = weak_self.lock()) iface->DispatchMessages();
    });
  }",21,,212,2,,void
86416,BLOCK,-1,,"{
  // We allow DispatchMessages reentry as we enter the pause. This is important
  // to support debugging the code invoked by an inspector call, such
  // as Runtime.evaluate
  dispatching_messages_ = false;
  if (dispatching_message_queue_.empty()) {
    Mutex::ScopedLock scoped_lock(requests_lock_);
    while (requests_.empty()) incoming_message_cond_.Wait(scoped_lock);
  }
  return true;
}",50,,221,1,,void
86425,BLOCK,-1,,"{
    Mutex::ScopedLock scoped_lock(requests_lock_);
    while (requests_.empty()) incoming_message_cond_.Wait(scoped_lock);
  }",43,,226,2,,void
86444,BLOCK,-1,,"{
  if (dispatching_messages_)
    return;
  dispatching_messages_ = true;
  bool had_messages = false;
  do {
    if (dispatching_message_queue_.empty()) {
      Mutex::ScopedLock scoped_lock(requests_lock_);
      requests_.swap(dispatching_message_queue_);
    }
    had_messages = !dispatching_message_queue_.empty();
    while (!dispatching_message_queue_.empty()) {
      MessageQueue::value_type task;
      std::swap(dispatching_message_queue_.front(), task);
      dispatching_message_queue_.pop_front();

      v8::SealHandleScope seal_handle_scope(agent_->env()->isolate());
      task->Call(this);
    }
  } while (had_messages);
  dispatching_messages_ = false;
}",46,,233,1,,void
86447,BLOCK,-1,,<empty>,5,,235,2,,void
86457,BLOCK,-1,,"{
    if (dispatching_message_queue_.empty()) {
      Mutex::ScopedLock scoped_lock(requests_lock_);
      requests_.swap(dispatching_message_queue_);
    }
    had_messages = !dispatching_message_queue_.empty();
    while (!dispatching_message_queue_.empty()) {
      MessageQueue::value_type task;
      std::swap(dispatching_message_queue_.front(), task);
      dispatching_message_queue_.pop_front();

      v8::SealHandleScope seal_handle_scope(agent_->env()->isolate());
      task->Call(this);
    }
  }",6,,238,1,,void
86463,BLOCK,-1,,"{
      Mutex::ScopedLock scoped_lock(requests_lock_);
      requests_.swap(dispatching_message_queue_);
    }",45,,239,2,,void
86485,BLOCK,-1,,"{
      MessageQueue::value_type task;
      std::swap(dispatching_message_queue_.front(), task);
      dispatching_message_queue_.pop_front();

      v8::SealHandleScope seal_handle_scope(agent_->env()->isolate());
      task->Call(this);
    }",49,,244,2,,void
86521,BLOCK,-1,,"{
  if (handle_ == nullptr)
    handle_ = std::make_shared<MainThreadHandle>(this);
  return handle_;
}",68,,256,1,,void
86526,BLOCK,-1,,<empty>,5,,258,2,,void
86543,BLOCK,-1,,"{
  CHECK_NOT_NULL(object);
  managed_objects_[id] = std::move(object);
}",72,,263,3,,void
86559,BLOCK,-1,,"{
  CHECK_EQ(1, managed_objects_.erase(id));
}",48,,268,2,,void
86571,BLOCK,-1,,"{
  Deletable* pointer = GetObjectIfExists(id);
  // This would mean the object is requested after it was disposed, which is
  // a coding error.
  CHECK_NOT_NULL(pointer);
  return pointer;
}",51,,272,2,,void
86585,BLOCK,-1,,"{
  auto iterator = managed_objects_.find(id);
  if (iterator == managed_objects_.end()) {
    return nullptr;
  }
  return iterator->second.get();
}",59,,280,2,,void
86601,BLOCK,-1,,"{
    return nullptr;
  }",43,,282,2,,void
86615,BLOCK,-1,,"{
  size_t expected_u16_length =
      simdutf::utf16_length_from_utf8(message.data(), message.length());
  MaybeStackBuffer<char16_t> buffer(expected_u16_length);
  size_t utf16_length = simdutf::convert_utf8_to_utf16(
      message.data(), message.length(), buffer.out());
  StringView view(reinterpret_cast<uint16_t*>(buffer.out()), utf16_length);
  return StringBuffer::create(view);
}",80,,288,2,,void
86673,BLOCK,-1,,"{
  return std::unique_ptr<InspectorSession>(
      new CrossThreadInspectorSession(++next_session_id_,
                                      shared_from_this(),
                                      std::move(delegate),
                                      prevent_shutdown));
}",28,,300,3,,void
86696,BLOCK,-1,,"{
  Mutex::ScopedLock scoped_lock(block_lock_);
  if (!main_thread_)
    return false;
  main_thread_->Post(std::move(request));
  return true;
}",63,,308,2,,void
86703,BLOCK,-1,,<empty>,5,,311,2,,void
86720,BLOCK,-1,,"{
  Mutex::ScopedLock scoped_lock(block_lock_);
  main_thread_ = nullptr;
}",32,,316,1,,void
86731,BLOCK,-1,,"{
  int id = newObjectId();
  main_thread_->AddObject(id, WrapInDeletable(std::move(delegate)));
  return std::unique_ptr<InspectorSessionDelegate>(
      new ThreadSafeDelegate(shared_from_this(), id));
}",57,,323,2,,void
86761,BLOCK,-1,,"{
  Mutex::ScopedLock scoped_lock(block_lock_);
  return main_thread_ == nullptr;
}",34,,330,1,,void
86787,BLOCK,-1,,<empty>,1,,1,1,,ANY
86797,BLOCK,-1,,<empty>,,,,2,,<empty>
86801,BLOCK,-1,,<empty>,,,,1,,<empty>
86806,BLOCK,-1,,<empty>,,,,1,,<empty>
86811,BLOCK,-1,,<empty>,,,,2,,<empty>
86818,BLOCK,-1,,"{
  }",57,,44,2,,void
86822,BLOCK,-1,,"{
    Mutex::ScopedLock scoped_lock(block_lock_);
    CHECK_NULL(main_thread_);  // main_thread_ should have called Reset
  }",23,,46,1,,void
86833,BLOCK,-1,,<empty>,,,,3,,<empty>
86837,BLOCK,-1,,"{
    return ++next_object_id_;
  }",21,,53,1,,void
86845,BLOCK,-1,,<empty>,,,,2,,<empty>
86850,BLOCK,-1,,<empty>,,,,2,,<empty>
86854,BLOCK,-1,,<empty>,,,,1,,<empty>
86858,BLOCK,-1,,<empty>,,,,1,,<empty>
86867,BLOCK,-1,,<empty>,,,,1,,<empty>
86880,BLOCK,-1,,<empty>,,,,2,,<empty>
86884,BLOCK,-1,,<empty>,,,,1,,<empty>
86888,BLOCK,-1,,<empty>,,,,1,,<empty>
86893,BLOCK,-1,,<empty>,,,,2,,<empty>
86897,BLOCK,-1,,<empty>,,,,1,,<empty>
86901,BLOCK,-1,,<empty>,,,,1,,<empty>
86905,BLOCK,-1,,"{
    return agent_;
  }",28,,82,1,,void
86913,BLOCK,-1,,<empty>,,,,3,,<empty>
86918,BLOCK,-1,,<empty>,,,,2,,<empty>
86923,BLOCK,-1,,<empty>,,,,2,,<empty>
86928,BLOCK,-1,,<empty>,,,,2,,<empty>
86940,BLOCK,-1,,<empty>,,,,1,,<empty>
86960,BLOCK,-1,,<empty>,1,,1,1,,ANY
86976,BLOCK,-1,,"{
  builder.put('""');
  if (!string.empty()) {
    size_t expected_utf16_length =
        simdutf::utf16_length_from_utf8(string.data(), string.length());
    MaybeStackBuffer<char16_t> buffer(expected_utf16_length);
    // simdutf::convert_utf8_to_utf16 returns zero in case of error.
    size_t utf16_length = simdutf::convert_utf8_to_utf16(
        string.data(), string.length(), buffer.out());
    // We have that utf16_length == expected_utf16_length if and only
    // if the input was a valid UTF-8 string.
    if (utf16_length != 0) {
      CHECK_EQ(expected_utf16_length, utf16_length);
      escapeWideStringForJSON(reinterpret_cast<const uint16_t*>(buffer.out()),
                              utf16_length,
                              &builder);
    }  // Otherwise, we had an invalid UTF-8 input.
  }
  builder.put('""');
}",63,,16,3,,void
86988,BLOCK,-1,,"{
    size_t expected_utf16_length =
        simdutf::utf16_length_from_utf8(string.data(), string.length());
    MaybeStackBuffer<char16_t> buffer(expected_utf16_length);
    // simdutf::convert_utf8_to_utf16 returns zero in case of error.
    size_t utf16_length = simdutf::convert_utf8_to_utf16(
        string.data(), string.length(), buffer.out());
    // We have that utf16_length == expected_utf16_length if and only
    // if the input was a valid UTF-8 string.
    if (utf16_length != 0) {
      CHECK_EQ(expected_utf16_length, utf16_length);
      escapeWideStringForJSON(reinterpret_cast<const uint16_t*>(buffer.out()),
                              utf16_length,
                              &builder);
    }  // Otherwise, we had an invalid UTF-8 input.
  }",24,,18,2,,void
87030,BLOCK,-1,,"{
      CHECK_EQ(expected_utf16_length, utf16_length);
      escapeWideStringForJSON(reinterpret_cast<const uint16_t*>(buffer.out()),
                              utf16_length,
                              &builder);
    }",28,,27,2,,void
87053,BLOCK,-1,,"{
  if (string.empty())
    return nullptr;
  size_t expected_utf16_length =
      simdutf::utf16_length_from_utf8(string.data(), string.length());
  MaybeStackBuffer<char16_t> buffer(expected_utf16_length);
  // simdutf::convert_utf8_to_utf16 returns zero in case of error.
  size_t utf16_length = simdutf::convert_utf8_to_utf16(
      string.data(), string.length(), buffer.out());
  // We have that utf16_length == expected_utf16_length if and only
  // if the input was a valid UTF-8 string.
  if (utf16_length == 0) return nullptr;  // We had an invalid UTF-8 input.
  CHECK_EQ(expected_utf16_length, utf16_length);
  return parseJSONCharacters(reinterpret_cast<const uint16_t*>(buffer.out()),
                             utf16_length);
}",65,,37,2,,void
87059,BLOCK,-1,,<empty>,5,,39,2,,void
87103,BLOCK,-1,,<empty>,26,,48,2,,void
87122,BLOCK,-1,,"{
  if (string.length() == 0)
    return nullptr;
  if (string.is8Bit())
    return parseJSONCharacters(string.characters8(), string.length());
  return parseJSONCharacters(string.characters16(), string.length());
}",67,,54,2,,void
87130,BLOCK,-1,,<empty>,5,,56,2,,void
87138,BLOCK,-1,,<empty>,5,,58,2,,void
87163,BLOCK,-1,,"{
  if (view.length() == 0)
    return """";
  if (view.is8Bit()) {
    return std::string(reinterpret_cast<const char*>(view.characters8()),
                       view.length());
  }
  const char16_t* source =
      reinterpret_cast<const char16_t*>(view.characters16());
  size_t expected_utf8_length =
      simdutf::utf8_length_from_utf16(source, view.length());
  MaybeStackBuffer<char> buffer(expected_utf8_length);
  // convert_utf16_to_utf8 returns zero in case of error.
  size_t utf8_length =
      simdutf::convert_utf16_to_utf8(source, view.length(), buffer.out());
  // We have that utf8_length == expected_utf8_length if and only
  // if the input was a valid UTF-16 string. Otherwise, utf8_length
  // must be zero.
  CHECK(utf8_length == 0 || utf8_length == expected_utf8_length);
  // An invalid UTF-16 input will generate the empty string:
  return String(buffer.out(), utf8_length);
}",56,,62,2,,void
87171,BLOCK,-1,,<empty>,5,,64,2,,void
87179,BLOCK,-1,,"{
    return std::string(reinterpret_cast<const char*>(view.characters8()),
                       view.length());
  }",22,,65,2,,void
87254,BLOCK,-1,,"{
  std::ostringstream stream;
  stream.imbue(std::locale::classic());  // Ignore current locale
  stream << d;
  return stream.str();
}",29,,85,2,,void
87280,BLOCK,-1,,"{
  std::istringstream stream(std::string(buffer, length));
  stream.imbue(std::locale::classic());  // Ignore current locale
  double d;
  stream >> d;
  *ok = !stream.fail();
  return d;
}",62,,92,4,,void
87318,BLOCK,-1,,"{
  if (binary) {
    return Value::parseBinary(
        reinterpret_cast<const uint8_t*>(message.data()),
        message.length());
  }
  return parseJSON(message);
}",50,,102,3,,void
87321,BLOCK,-1,,"{
    return Value::parseBinary(
        reinterpret_cast<const uint8_t*>(message.data()),
        message.length());
  }",15,,103,2,,void
87344,BLOCK,-1,,"{
  return message;
}",47,,111,2,,void
87351,BLOCK,-1,,"{
  return std::string(reinterpret_cast<const char*>(message.data()),
                     message.size());
}",63,,115,2,,void
87372,BLOCK,-1,,"{
  return std::string(reinterpret_cast<const char*>(data), length);
}",53,,120,3,,void
87387,BLOCK,-1,,"{
  auto casted_data = reinterpret_cast<const char16_t*>(data);
  size_t expected_utf8_length =
      simdutf::utf8_length_from_utf16(casted_data, length);
  MaybeStackBuffer<char> buffer(expected_utf8_length);
  // simdutf::convert_utf16_to_utf8 returns zero in case of error.
  size_t utf8_length =
      simdutf::convert_utf16_to_utf8(casted_data, length, buffer.out());
  // We have that utf8_length == expected_utf8_length if and only
  // if the input was a valid UTF-16 string. Otherwise, utf8_length
  // must be zero.
  CHECK(utf8_length == 0 || utf8_length == expected_utf8_length);
  // An invalid UTF-16 input will generate the empty string:
  return String(buffer.out(), utf8_length);
}",55,,124,3,,void
87438,BLOCK,-1,,"{
  return reinterpret_cast<const uint8_t*>(s.data());
}",57,,140,2,,void
87450,BLOCK,-1,,"{
  // The utf32_length_from_utf8 function calls count_utf8.
  // The count_utf8 function counts the number of code points
  // (characters) in the string, assuming that the string is valid Unicode.
  // TODO(@anonrig): Test to make sure CharacterCount returns correctly.
  return simdutf::utf32_length_from_utf8(s.data(), s.length());
}",49,,144,2,,void
87480,BLOCK,-1,,<empty>,1,,1,1,,ANY
87492,BLOCK,-1,,"{
  builder.put(c);
}",59,,25,3,,void
87504,BLOCK,-1,,"{
  builder.write(value, length);
}",42,,31,4,,void
87516,BLOCK,-1,,"{
  builderAppend(builder, value, std::strlen(value));
}",70,,36,3,,void
87530,BLOCK,-1,,"{
  builder << string;
}",73,,41,3,,void
87539,BLOCK,-1,,"{
  // ostringstream does not have a counterpart
}",60,,46,3,,void
87546,BLOCK,-1,,"{
  return string.substr(start, count);
}",75,,49,4,,void
87558,BLOCK,-1,,"{
  return std::to_string(n);
}",34,,52,2,,void
87569,BLOCK,-1,,"{
  return builder.str();
}",61,,55,2,,void
87580,BLOCK,-1,,"{
  return string.find(substring);
}",65,,58,3,,void
87591,BLOCK,-1,,<empty>,,,,2,,<empty>
87598,BLOCK,-1,,<empty>,,,,4,,<empty>
87603,BLOCK,-1,,<empty>,,,,2,,<empty>
87609,BLOCK,-1,,<empty>,,,,3,,<empty>
87614,BLOCK,-1,,<empty>,,,,2,,<empty>
87620,BLOCK,-1,,<empty>,,,,3,,<empty>
87625,BLOCK,-1,,<empty>,,,,2,,<empty>
87630,BLOCK,-1,,<empty>,,,,2,,<empty>
87636,BLOCK,-1,,<empty>,,,,3,,<empty>
87642,BLOCK,-1,,<empty>,,,,3,,<empty>
87647,BLOCK,-1,,<empty>,,,,2,,<empty>
87652,BLOCK,-1,,<empty>,,,,2,,<empty>
87657,BLOCK,-1,,"{
  return nullptr;
}",60,,81,2,,void
87664,BLOCK,-1,,"{
  return nullptr;
}",66,,84,2,,void
87672,BLOCK,-1,,{ UNREACHABLE(); },31,,97,1,,void
87677,BLOCK,-1,,{ UNREACHABLE(); },23,,98,1,,void
87682,BLOCK,-1,,{ UNREACHABLE(); },27,,99,1,,void
87689,BLOCK,-1,,"{
    UNREACHABLE();
  }",74,,100,3,,void
87696,BLOCK,-1,,{ UNREACHABLE(); },60,,103,3,,void
87710,BLOCK,-1,,<empty>,1,,1,1,,ANY
87715,BLOCK,-1,,<empty>,48,,11,1,,void
87720,BLOCK,-1,,"{
  frontend_ = std::make_unique<NodeRuntime::Frontend>(dispatcher->channel());
  NodeRuntime::Dispatcher::wire(dispatcher, this);
}",53,,13,2,,void
87747,BLOCK,-1,,"{
  notify_when_waiting_for_disconnect_ = enabled;
  return DispatchResponse::OK();
}",77,,18,2,,void
87759,BLOCK,-1,,"{
  if (notify_when_waiting_for_disconnect_) {
    frontend_->waitingForDisconnect();
    return true;
  }
  return false;
}",49,,23,1,,void
87762,BLOCK,-1,,"{
    frontend_->waitingForDisconnect();
    return true;
  }",44,,24,2,,void
87781,BLOCK,-1,,<empty>,1,,1,1,,ANY
87788,BLOCK,-1,,<empty>,,,,1,,<empty>
87793,BLOCK,-1,,<empty>,,,,2,,<empty>
87798,BLOCK,-1,,<empty>,,,,2,,<empty>
87802,BLOCK,-1,,<empty>,,,,1,,<empty>
87825,BLOCK,-1,,<empty>,1,,1,1,,ANY
87833,BLOCK,-1,,<empty>,29,,21,2,,void
87837,BLOCK,-1,,{ return frontend_.lock().get(); },32,,25,1,,void
87853,BLOCK,-1,,"{
    frontend_wrapper_ = std::make_unique<DeletableFrontendWrapper>(frontend);
  }",31,,35,3,,void
87867,BLOCK,-1,,"{
    thread->AddObject(object_id_, std::move(frontend_wrapper_));
  }",51,,39,2,,void
87885,BLOCK,-1,,<empty>,31,,51,2,,void
87890,BLOCK,-1,,"{
    thread->RemoveObject(object_id_);
  }",51,,53,2,,void
87903,BLOCK,-1,,<empty>,50,,64,3,,void
87908,BLOCK,-1,,"{
    DeletableFrontendWrapper* frontend_wrapper =
        static_cast<DeletableFrontendWrapper*>(
            thread->GetObjectIfExists(object_id_));
    if (frontend_wrapper == nullptr) return;
    auto frontend = frontend_wrapper->get();
    if (frontend != nullptr) {
      frontend->sendRawJSONNotification(message_);
    }
  }",51,,66,2,,void
87923,BLOCK,-1,,<empty>,38,,70,2,,void
87936,BLOCK,-1,,"{
      frontend->sendRawJSONNotification(message_);
    }",30,,72,2,,void
87950,BLOCK,-1,,<empty>,76,,86,3,,void
87955,BLOCK,-1,,"{
    if (!json_writer_)
      json_writer_.reset(TraceWriter::CreateJSONTraceWriter(stream_, ""value""));
    json_writer_->AppendTraceEvent(trace_event);
  }",65,,89,2,,void
87959,BLOCK,-1,,<empty>,7,,91,2,,void
87979,BLOCK,-1,,"{
    if (!json_writer_)
      return;
    json_writer_.reset();
    std::ostringstream result(
        ""{\""method\"":\""NodeTracing.dataCollected\"",\""params\"":"",
        std::ostringstream::ate);
    result << stream_.str();
    result << ""}"";
    main_thread_->Post(std::make_unique<SendMessageRequest>(frontend_object_id_,
                                                            result.str()));
    stream_.str("""");
  }",29,,95,2,,void
87983,BLOCK,-1,,<empty>,7,,97,2,,void
88037,BLOCK,-1,,<empty>,44,,119,3,,void
88041,BLOCK,-1,,"{
  trace_writer_.reset();
  main_thread_->Post(
      std::make_unique<DestroyFrontendWrapperRequest>(frontend_object_id_));
}",31,,121,1,,void
88061,BLOCK,-1,,"{
  // Note that frontend is still owned by TracingAgent
  frontend_ = std::make_shared<NodeTracing::Frontend>(dispatcher->channel());
  frontend_object_id_ = main_thread_->newObjectId();
  main_thread_->Post(std::make_unique<CreateFrontendWrapperRequest>(
      frontend_object_id_, frontend_));
  NodeTracing::Dispatcher::wire(dispatcher, this);
}",53,,127,2,,void
88108,BLOCK,-1,,"{
  if (!trace_writer_.empty()) {
    return DispatchResponse::Error(
        ""Call NodeTracing::end to stop tracing before updating the config"");
  }
  if (!env_->owns_process_state()) {
    return DispatchResponse::Error(
        ""Tracing properties can only be changed through main thread sessions"");
  }

  std::set<std::string> categories_set;
  protocol::Array<std::string>* categories =
      traceConfig->getIncludedCategories();
  for (size_t i = 0; i < categories->length(); i++)
    categories_set.insert(categories->get(i));

  if (categories_set.empty())
    return DispatchResponse::Error(""At least one category should be enabled"");

  tracing::AgentWriterHandle* writer = GetTracingAgentWriter();
  if (writer != nullptr) {
    trace_writer_ =
        writer->agent()->AddClient(categories_set,
                                   std::make_unique<InspectorTraceWriter>(
                                       frontend_object_id_, main_thread_),
                                   tr...",70,,137,2,,void
88115,BLOCK,-1,,"{
    return DispatchResponse::Error(
        ""Call NodeTracing::end to stop tracing before updating the config"");
  }",31,,138,2,,void
88128,BLOCK,-1,,"{
    return DispatchResponse::Error(
        ""Tracing properties can only be changed through main thread sessions"");
  }",36,,142,2,,void
88160,BLOCK,-1,,<empty>,3,,150,1,,void
88187,BLOCK,-1,,<empty>,5,,154,2,,void
88202,BLOCK,-1,,"{
    trace_writer_ =
        writer->agent()->AddClient(categories_set,
                                   std::make_unique<InspectorTraceWriter>(
                                       frontend_object_id_, main_thread_),
                                   tracing::Agent::kIgnoreDefaultCategories);
  }",26,,157,2,,void
88236,BLOCK,-1,,"{
  trace_writer_.reset();
  frontend_->tracingComplete();
  return DispatchResponse::OK();
}",39,,167,1,,void
88254,BLOCK,-1,,"{
  *categories = Array<String>::create();
  protocol::Array<String>* categories_list = categories->get();
  // In alphabetical order
  categories_list->addItem(""node"");
  categories_list->addItem(""node.async_hooks"");
  categories_list->addItem(""node.bootstrap"");
  categories_list->addItem(""node.console"");
  categories_list->addItem(""node.dns.native"");
  categories_list->addItem(""node.environment"");
  categories_list->addItem(""node.fs.async"");
  categories_list->addItem(""node.fs.sync"");
  categories_list->addItem(""node.fs_dir.async"");
  categories_list->addItem(""node.fs_dir.sync"");
  categories_list->addItem(""node.http"");
  categories_list->addItem(""node.net.native"");
  categories_list->addItem(""node.perf"");
  categories_list->addItem(""node.perf.timerify"");
  categories_list->addItem(""node.perf.usertiming"");
  categories_list->addItem(""node.promises.rejections"");
  categories_list->addItem(""node.threadpoolwork.async"");
  categories_list->addItem(""node.threadpoolwork.sync"");
  catego...",59,,174,2,,void
88396,BLOCK,-1,,<empty>,1,,1,1,,ANY
88406,BLOCK,-1,,<empty>,,,,3,,<empty>
88410,BLOCK,-1,,<empty>,,,,1,,<empty>
88415,BLOCK,-1,,<empty>,,,,2,,<empty>
88420,BLOCK,-1,,<empty>,,,,2,,<empty>
88424,BLOCK,-1,,<empty>,,,,1,,<empty>
88429,BLOCK,-1,,<empty>,,,,2,,<empty>
88438,BLOCK,-1,,<empty>,,,,1,,<empty>
88456,BLOCK,-1,,<empty>,1,,1,1,,ANY
88464,BLOCK,-1,,<empty>,62,,16,3,,void
88472,BLOCK,-1,,<empty>,,,,5,,<empty>
88478,BLOCK,-1,,<empty>,,,,3,,<empty>
88484,BLOCK,-1,,<empty>,,,,3,,<empty>
88489,BLOCK,-1,,<empty>,,,,2,,<empty>
88497,BLOCK,-1,,<empty>,,,,1,,<empty>
88507,BLOCK,-1,,<empty>,61,,36,2,,void
88515,BLOCK,-1,,"{
    workers_->WorkerCreated(title, url, waiting, target);
  }",73,,41,5,,void
88531,BLOCK,-1,,<empty>,63,,53,3,,void
88535,BLOCK,-1,,"{
    workers_->Detached(id_);
  }",46,,55,1,,void
88545,BLOCK,-1,,"{
    std::string message = protocol::StringUtil::StringViewToUtf8(msg);
    workers_->Send(id_, message);
  }",76,,59,2,,void
88570,BLOCK,-1,,"{
  return NodeWorker::WorkerInfo::create()
      .setWorkerId(id)
      .setTitle(title)
      .setUrl(url)
      .setType(""worker"").build();
}",76,,71,4,,void
88601,BLOCK,-1,,<empty>,46,,81,2,,void
88606,BLOCK,-1,,"{
  frontend_.reset(new NodeWorker::Frontend(dispatcher->channel()));
  NodeWorker::Dispatcher::wire(dispatcher, this);
  auto manager = manager_.lock();
  CHECK_NOT_NULL(manager);
  workers_ =
      std::make_shared<NodeWorkers>(frontend_, manager->MainThread());
}",52,,84,2,,void
88654,BLOCK,-1,,"{
  workers_->Receive(sessionId, message);
  return DispatchResponse::OK();
}",76,,94,3,,void
88670,BLOCK,-1,,"{
  auto manager = manager_.lock();
  if (!manager) {
    return DispatchResponse::OK();
  }
  if (!event_handle_) {
    std::unique_ptr<AgentWorkerInspectorDelegate> delegate(
            new AgentWorkerInspectorDelegate(workers_));
    event_handle_ = manager->SetAutoAttach(std::move(delegate));
  }
  event_handle_->SetWaitOnStart(waitForDebuggerOnStart);
  return DispatchResponse::OK();
}",67,,99,2,,void
88681,BLOCK,-1,,"{
    return DispatchResponse::OK();
  }",17,,101,2,,void
88690,BLOCK,-1,,"{
    std::unique_ptr<AgentWorkerInspectorDelegate> delegate(
            new AgentWorkerInspectorDelegate(workers_));
    event_handle_ = manager->SetAutoAttach(std::move(delegate));
  }",23,,104,2,,void
88720,BLOCK,-1,,"{
  event_handle_.reset();
  return DispatchResponse::OK();
}",41,,113,1,,void
88734,BLOCK,-1,,"{
  workers_->Detached(sessionId);
  return DispatchResponse::OK();
}",63,,118,2,,void
88752,BLOCK,-1,,"{
  auto frontend = frontend_.lock();
  if (!frontend)
    return;
  std::string id = std::to_string(++next_target_id_);
  auto delegate = thread_->MakeDelegateThreadSafe(
      std::unique_ptr<InspectorSessionDelegate>(
          new ParentInspectorSessionDelegate(id, shared_from_this())));
  sessions_[id] = target->Connect(std::move(delegate), true);
  frontend->attachedToWorker(id, WorkerInfo(id, title, url), waiting);
}",75,,126,5,,void
88763,BLOCK,-1,,<empty>,5,,129,2,,void
88820,BLOCK,-1,,"{
  auto frontend = frontend_.lock();
  if (frontend)
    frontend->receivedMessageFromWorker(id, message);
}",75,,138,3,,void
88830,BLOCK,-1,,<empty>,5,,141,2,,void
88842,BLOCK,-1,,"{
  auto it = sessions_.find(id);
  if (it != sessions_.end())
    it->second->Dispatch(Utf8ToStringView(message)->string());
}",78,,144,3,,void
88858,BLOCK,-1,,<empty>,5,,147,2,,void
88874,BLOCK,-1,,"{
  if (sessions_.erase(id) == 0)
    return;
  auto frontend = frontend_.lock();
  if (frontend) {
    frontend->detachedFromWorker(id);
  }
}",51,,150,2,,void
88883,BLOCK,-1,,<empty>,5,,152,2,,void
88894,BLOCK,-1,,"{
    frontend->detachedFromWorker(id);
  }",17,,154,2,,void
88910,BLOCK,-1,,<empty>,1,,1,1,,ANY
88920,BLOCK,-1,,<empty>,,,,2,,<empty>
88924,BLOCK,-1,,<empty>,,,,1,,<empty>
88929,BLOCK,-1,,<empty>,,,,2,,<empty>
88935,BLOCK,-1,,<empty>,,,,3,,<empty>
88940,BLOCK,-1,,<empty>,,,,2,,<empty>
88944,BLOCK,-1,,<empty>,,,,1,,<empty>
88949,BLOCK,-1,,<empty>,,,,2,,<empty>
88968,BLOCK,-1,,<empty>,1,,1,1,,ANY
88979,BLOCK,-1,,<empty>,27,,21,6,,void
88984,BLOCK,-1,,"{
    auto manager = thread->inspector_agent()->GetWorkerManager();
    manager->WorkerStarted(id_, info_, waiting_);
  }",51,,22,2,,void
89007,BLOCK,-1,,"{
    return ""[worker "" + std::to_string(id) + ""]"" +
           (name == """" ? """" : "" "" + name);
  }",72,,28,3,,void
89036,BLOCK,-1,,"{
  if (info.worker_thread)
    delegate->WorkerCreated(info.title, info.url, waiting, info.worker_thread);
}",51,,40,4,,void
89041,BLOCK,-1,,<empty>,5,,42,2,,void
89061,BLOCK,-1,,<empty>,78,,47,2,,void
89066,BLOCK,-1,,"{
    thread->inspector_agent()->GetWorkerManager()->WorkerFinished(worker_id_);
  }",51,,49,2,,void
89087,BLOCK,-1,,<empty>,19,,68,6,,void
89091,BLOCK,-1,,"{
  parent_thread_->Post(
      std::unique_ptr<Request>(new WorkerFinishedRequest(id_)));
}",49,,70,1,,void
89110,BLOCK,-1,,"{
  std::unique_ptr<Request> request(
      new WorkerStartedRequest(id_, url_, worker_thread, waiting, name_));
  parent_thread_->Post(std::move(request));
}",68,,76,3,,void
89134,BLOCK,-1,,"{
  return parent_thread_->Connect(std::move(delegate), prevent_shutdown);
}",28,,84,3,,void
89150,BLOCK,-1,,"{
  children_.erase(session_id);
}",57,,88,2,,void
89162,BLOCK,-1,,"{
  if (info.worker_thread->Expired())
    return;
  children_.emplace(session_id, info);
  for (const auto& delegate : delegates_) {
    Report(delegate.second, info, waiting);
  }
}",49,,94,4,,void
89170,BLOCK,-1,,<empty>,5,,96,2,,void
89181,BLOCK,-1,,"{
    Report(delegate.second, info, waiting);
  }",43,,98,3,,void
89194,BLOCK,-1,,"{
  bool wait = !delegates_waiting_on_start_.empty();
  return std::make_unique<ParentInspectorHandle>(
      thread_id, url, thread_, wait, name);
}",74,,104,4,,void
89221,BLOCK,-1,,"{
  delegates_.erase(id);
  delegates_waiting_on_start_.erase(id);
}",50,,110,2,,void
89236,BLOCK,-1,,"{
  int id = ++next_delegate_id_;
  delegates_[id] = std::move(attach_delegate);
  const auto& delegate = delegates_[id];
  for (const auto& worker : children_) {
    // Waiting is only reported when a worker is started, same as browser
    Report(delegate, worker.second, false);
  }
  return std::make_unique<WorkerManagerEventHandle>(shared_from_this(), id);
}",54,,116,2,,void
89260,BLOCK,-1,,"{
    // Waiting is only reported when a worker is started, same as browser
    Report(delegate, worker.second, false);
  }",40,,120,3,,void
89283,BLOCK,-1,,"{
  if (wait)
    delegates_waiting_on_start_.insert(id);
  else
    delegates_waiting_on_start_.erase(id);
}",66,,127,3,,void
89286,BLOCK,-1,,<empty>,5,,129,2,,void
89293,BLOCK,-1,,<empty>,5,,131,1,,void
89303,BLOCK,-1,,"{
    manager_->SetWaitOnStartForDelegate(id_, wait_on_start);
}",67,,134,2,,void
89313,BLOCK,-1,,"{
  manager_->RemoveAttachDelegate(id_);
}",55,,138,1,,void
89333,BLOCK,-1,,<empty>,1,,1,1,,ANY
89346,BLOCK,-1,,<empty>,,,,5,,<empty>
89350,BLOCK,-1,,<empty>,,,,1,,<empty>
89357,BLOCK,-1,,<empty>,66,,33,3,,void
89362,BLOCK,-1,,<empty>,,,,2,,<empty>
89366,BLOCK,-1,,<empty>,,,,1,,<empty>
89376,BLOCK,-1,,<empty>,45,,48,4,,void
89389,BLOCK,-1,,<empty>,,,,6,,<empty>
89393,BLOCK,-1,,<empty>,,,,1,,<empty>
89400,BLOCK,-1,,"{
    return std::make_unique<ParentInspectorHandle>(
        thread_id, url, parent_thread_, wait_, name);
  }",76,,63,4,,void
89420,BLOCK,-1,,<empty>,,,,3,,<empty>
89424,BLOCK,-1,,"{
    return wait_;
  }",25,,69,1,,void
89430,BLOCK,-1,,{ return url_; },34,,72,1,,void
89438,BLOCK,-1,,<empty>,,,,3,,<empty>
89449,BLOCK,-1,,<empty>,44,,88,2,,void
89456,BLOCK,-1,,<empty>,,,,4,,<empty>
89463,BLOCK,-1,,<empty>,,,,4,,<empty>
89468,BLOCK,-1,,<empty>,,,,2,,<empty>
89473,BLOCK,-1,,<empty>,,,,2,,<empty>
89479,BLOCK,-1,,<empty>,,,,3,,<empty>
89484,BLOCK,-1,,<empty>,,,,2,,<empty>
89488,BLOCK,-1,,"{
    return thread_;
  }",50,,98,1,,void
89499,BLOCK,-1,,<empty>,,,,1,,<empty>
89507,BLOCK,-1,,{ callback(data); },53,,552,1,,void
89517,BLOCK,-1,,"{
        CHECK(start_io_thread_async_initialized.exchange(false));
      }",64,,722,2,,void
89530,BLOCK,-1,,"{
      Environment* env = static_cast<Environment*>(data);

      {
        Mutex::ScopedLock lock(start_io_thread_async_mutex);
        start_io_thread_async.data = nullptr;
      }

      // This is global, will never get freed
      env->CloseHandle(&start_io_thread_async, [](uv_async_t*) {
        CHECK(start_io_thread_async_initialized.exchange(false));
      });
    }",48,,713,2,,void
89537,BLOCK,3,,"{
        Mutex::ScopedLock lock(start_io_thread_async_mutex);
        start_io_thread_async.data = nullptr;
      }",7,,716,3,,void
89558,BLOCK,-1,,"{
    Agent* agent = static_cast<Environment*>(env)->inspector_agent();
    if (agent->IsActive()) {
      agent->WaitForDisconnect();
    }
  }",37,,728,2,,void
89573,BLOCK,-1,,"{
      agent->WaitForDisconnect();
    }",28,,730,2,,void
89583,BLOCK,-1,,"{
    StartIoThread();
  }",54,,955,2,,void
89646,BLOCK,-1,,<empty>,1,,1,1,,ANY
89660,BLOCK,-1,,"{
  TwoByteValue buffer(isolate, value);
  return StringBuffer::create(StringView(*buffer, buffer.length()));
}",68,,67,3,,void
89681,BLOCK,-1,,"{
  static_cast<Agent*>(handle->data)->StartIoThread();
}",53,,73,2,,void
89698,BLOCK,-1,,"{
  std::ostringstream result;
  result << ""Worker["" << env->thread_id() << ""]"";
  return result.str();
}",52,,206,2,,void
89725,BLOCK,-1,,"{
    session_ = inspector->connect(CONTEXT_GROUP_ID,
                                  this,
                                  StringView(),
                                  V8Inspector::ClientTrustLevel::kFullyTrusted);
    node_dispatcher_ = std::make_unique<protocol::UberDispatcher>(this);
    tracing_agent_ =
        std::make_unique<protocol::TracingAgent>(env, main_thread_);
    tracing_agent_->Wire(node_dispatcher_.get());
    if (worker_manager) {
      worker_agent_ = std::make_unique<protocol::WorkerAgent>(worker_manager);
      worker_agent_->Wire(node_dispatcher_.get());
    }
    runtime_agent_ = std::make_unique<protocol::RuntimeAgent>();
    runtime_agent_->Wire(node_dispatcher_.get());
  }",35,,222,7,,void
89775,BLOCK,-1,,"{
      worker_agent_ = std::make_unique<protocol::WorkerAgent>(worker_manager);
      worker_agent_->Wire(node_dispatcher_.get());
    }",25,,231,2,,void
89812,BLOCK,-1,,"{
    tracing_agent_->disable();
    tracing_agent_.reset();  // Dispose before the dispatchers
    if (worker_agent_) {
      worker_agent_->disable();
      worker_agent_.reset();  // Dispose before the dispatchers
    }
    runtime_agent_->disable();
    runtime_agent_.reset();  // Dispose before the dispatchers
  }",27,,239,1,,void
89823,BLOCK,-1,,"{
      worker_agent_->disable();
      worker_agent_.reset();  // Dispose before the dispatchers
    }",24,,242,2,,void
89844,BLOCK,-1,,"{
    std::string raw_message = protocol::StringUtil::StringViewToUtf8(message);
    per_process::Debug(DebugCategory::INSPECTOR_SERVER,
                       ""[inspector received] %s\n"",
                       raw_message);
    std::unique_ptr<protocol::DictionaryValue> value =
        protocol::DictionaryValue::cast(protocol::StringUtil::parseMessage(
            raw_message, false));
    int call_id;
    std::string method;
    node_dispatcher_->parseCommand(value.get(), &call_id, &method);
    if (v8_inspector::V8InspectorSession::canDispatchMethod(
            Utf8ToStringView(method)->string())) {
      session_->dispatchProtocolMessage(message);
    } else {
      node_dispatcher_->dispatch(call_id, method, std::move(value),
                                 raw_message);
    }
  }",59,,250,2,,void
89914,BLOCK,-1,,"{
      session_->dispatchProtocolMessage(message);
    }",50,,262,2,,void
89921,BLOCK,-1,,"{
      node_dispatcher_->dispatch(call_id, method, std::move(value),
                                 raw_message);
    }",12,,264,1,,void
89938,BLOCK,-1,,"{
    std::unique_ptr<StringBuffer> buffer = Utf8ToStringView(reason);
    session_->schedulePauseOnNextStatement(buffer->string(), buffer->string());
  }",64,,270,2,,void
89959,BLOCK,-1,,"{
    return prevent_shutdown_;
  }",26,,275,1,,void
89965,BLOCK,-1,,"{
    retaining_context_ = runtime_agent_->notifyWaitingForDisconnect();
    return retaining_context_;
  }",37,,279,1,,void
89977,BLOCK,-1,,"{
    return retaining_context_;
  }",27,,284,1,,void
89985,BLOCK,-1,,"{
    sendMessageToFrontend(message->string());
  }",69,,291,3,,void
89995,BLOCK,-1,,"{
    sendMessageToFrontend(message->string());
  }",69,,296,2,,void
90004,BLOCK,-1,,{ },46,,300,1,,void
90009,BLOCK,-1,,"{
    if (per_process::enabled_debug_list.enabled(
            DebugCategory::INSPECTOR_SERVER)) {
      std::string raw_message = protocol::StringUtil::StringViewToUtf8(message);
      per_process::Debug(DebugCategory::INSPECTOR_SERVER,
                         ""[inspector send] %s\n"",
                         raw_message);
    }
    delegate_->SendMessageToFrontend(message);
  }",57,,302,2,,void
90020,BLOCK,-1,,"{
      std::string raw_message = protocol::StringUtil::StringViewToUtf8(message);
      per_process::Debug(DebugCategory::INSPECTOR_SERVER,
                         ""[inspector send] %s\n"",
                         raw_message);
    }",47,,304,2,,void
90049,BLOCK,-1,,"{
    sendMessageToFrontend(Utf8ToStringView(message)->string());
  }",58,,313,2,,void
90062,BLOCK,-1,,"{
    sendMessageToFrontend(message->serializeToJSON());
  }",77,,320,3,,void
90072,BLOCK,-1,,"{
    sendMessageToFrontend(message->serializeToJSON());
  }",55,,324,2,,void
90084,BLOCK,-1,,"{
    DCHECK(false);
  }",57,,330,4,,void
90101,BLOCK,-1,,<empty>,50,,348,3,,void
90105,BLOCK,-1,,<empty>,,,,1,,<empty>
90110,BLOCK,-1,,<empty>,,,,2,,<empty>
90117,BLOCK,-1,,"{
  Isolate* isolate = env->isolate();
  HandleScope handle_scope(isolate);
  Local<Context> context = env->context();

  // Send message to enable debug in cluster workers
  Local<Object> message = Object::New(isolate);
  message->Set(context, FIXED_ONE_BYTE_STRING(isolate, ""cmd""),
               FIXED_ONE_BYTE_STRING(isolate, ""NODE_DEBUG_ENABLED"")).Check();
  ProcessEmit(env, ""internalMessage"", message);
}",57,,357,2,,void
90171,BLOCK,-1,,"{
  return !path.empty() && path[0] == '/';
}",42,,382,2,,void
90188,BLOCK,-1,,"{
  HandleScope scope(env->isolate());

  const char* msg = ""This Environment was initialized without a V8::Inspector"";
  Local<Value> exception =
    v8::String::NewFromUtf8(env->isolate(), msg).ToLocalChecked();

  env->isolate()->ThrowException(exception);
}",57,,387,2,,void
90232,BLOCK,-1,,"{
    client_ = V8Inspector::create(env->isolate(), this);
    // TODO(bnoordhuis) Make name configurable from src/node.cc.
    std::string name =
        is_main_ ? GetHumanReadableProcessName() : GetWorkerLabel(env);
    ContextInfo info(name);
    info.is_default = true;
    contextCreated(env->context(), info);
  }",38,,402,3,,void
90270,BLOCK,-1,,"{
    waiting_for_resume_ = true;
    runMessageLoop();
  }",61,,412,2,,void
90278,BLOCK,-1,,"{
    waiting_for_sessions_disconnect_ = true;
    runMessageLoop();
  }",36,,417,1,,void
90286,BLOCK,-1,,"{
    waiting_for_frontend_ = true;
    runMessageLoop();
  }",26,,422,1,,void
90295,BLOCK,-1,,"{
    if (waiting_for_sessions_disconnect_) {
      // V8 isolate is mostly done and is only letting Inspector protocol
      // clients gather data.
      return;
    }
    if (auto agent = env_->inspector_agent()) {
      if (depth == 0) {
        agent->DisableAsyncHook();
      } else {
        agent->EnableAsyncHook();
      }
    }
  }",58,,427,2,,void
90298,BLOCK,-1,,"{
      // V8 isolate is mostly done and is only letting Inspector protocol
      // clients gather data.
      return;
    }",43,,428,2,,void
90301,BLOCK,-1,,<empty>,9,,433,1,,void
90309,BLOCK,-1,,"{
      if (depth == 0) {
        agent->DisableAsyncHook();
      } else {
        agent->EnableAsyncHook();
      }
    }",47,,433,2,,void
90314,BLOCK,-1,,"{
        agent->DisableAsyncHook();
      }",23,,434,2,,void
90320,BLOCK,-1,,"{
        agent->EnableAsyncHook();
      }",14,,436,1,,void
90330,BLOCK,-1,,"{
    auto name_buffer = Utf8ToStringView(info.name);
    auto origin_buffer = Utf8ToStringView(info.origin);
    std::unique_ptr<StringBuffer> aux_data_buffer;

    v8_inspector::V8ContextInfo v8info(
        context, CONTEXT_GROUP_ID, name_buffer->string());
    v8info.origin = origin_buffer->string();

    if (info.is_default) {
      aux_data_buffer = Utf8ToStringView(""{\""isDefault\"":true}"");
    } else {
      aux_data_buffer = Utf8ToStringView(""{\""isDefault\"":false}"");
    }
    v8info.auxData = aux_data_buffer->string();

    client_->contextCreated(v8info);
  }",72,,442,3,,void
90366,BLOCK,-1,,"{
      aux_data_buffer = Utf8ToStringView(""{\""isDefault\"":true}"");
    }",26,,451,2,,void
90372,BLOCK,-1,,"{
      aux_data_buffer = Utf8ToStringView(""{\""isDefault\"":false}"");
    }",12,,453,1,,void
90394,BLOCK,-1,,"{
    client_->contextDestroyed(context);
  }",49,,461,2,,void
90403,BLOCK,-1,,"{
    waiting_for_resume_ = false;
  }",42,,465,1,,void
90411,BLOCK,-1,,"{
    waiting_for_frontend_ = false;
  }",63,,469,2,,void
90420,BLOCK,-1,,"{
    int session_id = next_session_id_++;
    channels_[session_id] = std::make_unique<ChannelImpl>(env_,
                                                          client_,
                                                          getWorkerManager(),
                                                          std::move(delegate),
                                                          getThreadHandle(),
                                                          prevent_shutdown);
    return session_id;
  }",46,,474,3,,void
90454,BLOCK,-1,,"{
    auto it = channels_.find(session_id);
    if (it == channels_.end())
      return;
    bool retaining_context = it->second->retainingContext();
    channels_.erase(it);
    if (retaining_context) {
      for (const auto& id_channel : channels_) {
        if (id_channel.second->retainingContext())
          return;
      }
      contextDestroyed(env_->context());
    }
    if (waiting_for_sessions_disconnect_ && !is_main_)
      waiting_for_sessions_disconnect_ = false;
  }",43,,485,2,,void
90470,BLOCK,-1,,<empty>,7,,488,2,,void
90488,BLOCK,-1,,"{
      for (const auto& id_channel : channels_) {
        if (id_channel.second->retainingContext())
          return;
      }
      contextDestroyed(env_->context());
    }",28,,491,2,,void
90492,BLOCK,-1,,"{
        if (id_channel.second->retainingContext())
          return;
      }",48,,492,3,,void
90500,BLOCK,-1,,<empty>,11,,494,2,,void
90512,BLOCK,-1,,<empty>,7,,499,2,,void
90521,BLOCK,-1,,"{
    channels_[session_id]->dispatchProtocolMessage(message);
  }",79,,502,3,,void
90533,BLOCK,-1,,"{
    return env_->context();
  }",75,,506,2,,void
90544,BLOCK,-1,,"{
    Local<Function> installer = env_->inspector_console_extension_installer();
    if (!installer.IsEmpty()) {
      Local<Value> argv[] = {target};
      // If there is an exception, proceed in JS land
      USE(installer->Call(context, target, arraysize(argv), argv));
    }
  }",71,,511,3,,void
90561,BLOCK,-1,,"{
      Local<Value> argv[] = {target};
      // If there is an exception, proceed in JS land
      USE(installer->Call(context, target, arraysize(argv), argv));
    }",31,,513,2,,void
90582,BLOCK,-1,,"{
    Isolate* isolate = env_->isolate();
    Local<Context> context = env_->context();

    int script_id = message->GetScriptOrigin().ScriptId();

    Local<v8::StackTrace> stack_trace = message->GetStackTrace();

    if (!stack_trace.IsEmpty() && stack_trace->GetFrameCount() > 0 &&
        script_id == stack_trace->GetFrame(isolate, 0)->GetScriptId()) {
      script_id = 0;
    }

    const uint8_t DETAILS[] = ""Uncaught"";

    client_->exceptionThrown(
        context,
        StringView(DETAILS, sizeof(DETAILS) - 1),
        error,
        ToProtocolString(isolate, message->Get())->string(),
        ToProtocolString(isolate, message->GetScriptResourceName())->string(),
        message->GetLineNumber(context).FromMaybe(0),
        message->GetStartColumn(context).FromMaybe(0),
        client_->createStackTrace(stack_trace),
        script_id);
  }",76,,520,3,,void
90647,BLOCK,-1,,"{
      script_id = 0;
    }",72,,529,2,,void
90714,BLOCK,-1,,"{
    auto result =
        timers_.emplace(std::piecewise_construct, std::make_tuple(data),
                        std::make_tuple(env_, [=]() { callback(data); }));
    CHECK(result.second);
    uint64_t interval = static_cast<uint64_t>(1000 * interval_s);
    result.first->second.Update(interval, interval);
  }",49,,549,4,,void
90762,BLOCK,-1,,"{
    timers_.erase(data);
  }",41,,558,2,,void
90774,BLOCK,-1,,"{
    client_->asyncTaskScheduled(task_name, task, recurring);
  }",43,,564,4,,void
90786,BLOCK,-1,,"{
    client_->asyncTaskCanceled(task);
  }",38,,568,2,,void
90796,BLOCK,-1,,"{
    client_->asyncTaskStarted(task);
  }",37,,572,2,,void
90806,BLOCK,-1,,"{
    client_->asyncTaskFinished(task);
  }",38,,576,2,,void
90815,BLOCK,-1,,"{
    client_->allAsyncTasksCanceled();
  }",32,,580,1,,void
90824,BLOCK,-1,,"{
    for (const auto& id_channel : channels_) {
      id_channel.second->schedulePauseOnNextStatement(reason);
    }
  }",64,,584,2,,void
90828,BLOCK,-1,,"{
      id_channel.second->schedulePauseOnNextStatement(reason);
    }",46,,585,3,,void
90839,BLOCK,-1,,"{
    for (const auto& id_channel : channels_) {
      // Other sessions are ""invisible"" more most purposes
      if (id_channel.second->preventShutdown())
        return true;
    }
    return false;
  }",31,,590,1,,void
90843,BLOCK,-1,,"{
      // Other sessions are ""invisible"" more most purposes
      if (id_channel.second->preventShutdown())
        return true;
    }",46,,591,3,,void
90851,BLOCK,-1,,<empty>,9,,594,2,,void
90859,BLOCK,-1,,"{
    bool retaining_context = false;
    for (const auto& id_channel : channels_) {
      if (id_channel.second->notifyWaitingForDisconnect())
        retaining_context = true;
    }
    return retaining_context;
  }",37,,599,1,,void
90867,BLOCK,-1,,"{
      if (id_channel.second->notifyWaitingForDisconnect())
        retaining_context = true;
    }",46,,601,3,,void
90875,BLOCK,-1,,<empty>,9,,603,2,,void
90884,BLOCK,-1,,"{
    if (!interface_) {
      interface_ = std::make_shared<MainThreadInterface>(
          env_->inspector_agent());
    }
    return interface_->GetHandle();
  }",55,,608,1,,void
90888,BLOCK,-1,,"{
      interface_ = std::make_shared<MainThreadInterface>(
          env_->inspector_agent());
    }",22,,609,2,,void
90909,BLOCK,-1,,"{
    if (!is_main_) {
      return nullptr;
    }
    if (worker_manager_ == nullptr) {
      worker_manager_ =
          std::make_shared<WorkerManager>(getThreadHandle());
    }
    return worker_manager_;
  }",53,,616,1,,void
90913,BLOCK,-1,,"{
      return nullptr;
    }",20,,617,2,,void
90920,BLOCK,-1,,"{
      worker_manager_ =
          std::make_shared<WorkerManager>(getThreadHandle());
    }",37,,620,2,,void
90935,BLOCK,-1,,"{
    return !channels_.empty();
  }",19,,627,1,,void
90945,BLOCK,-1,,"{
    if (waiting_for_frontend_)
      return true;
    if (waiting_for_sessions_disconnect_ || waiting_for_resume_) {
      return hasConnectedSessions();
    }
    return false;
  }",31,,632,1,,void
90948,BLOCK,-1,,<empty>,7,,634,2,,void
90955,BLOCK,-1,,"{
      return hasConnectedSessions();
    }",66,,635,2,,void
90963,BLOCK,-1,,"{
    if (running_nested_loop_)
      return;

    running_nested_loop_ = true;

    while (shouldRunMessageLoop()) {
      if (interface_) interface_->WaitForFrontendEvent();
      env_->RunAndClearInterrupts();
    }
    running_nested_loop_ = false;
  }",25,,641,1,,void
90966,BLOCK,-1,,<empty>,7,,643,2,,void
90973,BLOCK,-1,,"{
      if (interface_) interface_->WaitForFrontendEvent();
      env_->RunAndClearInterrupts();
    }",36,,647,2,,void
90976,BLOCK,-1,,<empty>,23,,648,2,,void
90991,BLOCK,-1,,"{
    return env_->isolate_data()->platform()->CurrentClockTimeMillis();
  }",35,,654,1,,void
91007,BLOCK,-1,,"{
    std::string resource_name =
        protocol::StringUtil::StringViewToUtf8(resource_name_view);
    if (!IsFilePath(resource_name))
      return nullptr;

    std::string url = node::url::FromFilePath(resource_name);
    return Utf8ToStringView(url);
  }",54,,659,2,,void
91022,BLOCK,-1,,<empty>,7,,663,2,,void
91053,BLOCK,-1,,<empty>,,,,1,,<empty>
91073,BLOCK,-1,,<empty>,46,,688,2,,void
91077,BLOCK,-1,,<empty>,17,,690,1,,void
91085,BLOCK,-1,,"{
  path_ = path;
  debug_options_ = options;
  CHECK_NOT_NULL(host_port);
  host_port_ = host_port;

  client_ = std::make_shared<NodeInspectorClient>(parent_env_, is_main);
  if (parent_env_->owns_inspector()) {
    Mutex::ScopedLock lock(start_io_thread_async_mutex);
    CHECK_EQ(start_io_thread_async_initialized.exchange(true), false);
    CHECK_EQ(0, uv_async_init(parent_env_->event_loop(),
                              &start_io_thread_async,
                              StartIoThreadAsyncCallback));
    uv_unref(reinterpret_cast<uv_handle_t*>(&start_io_thread_async));
    start_io_thread_async.data = this;
    // Ignore failure, SIGUSR1 won't work, but that should not block node start.
    StartDebugSignalHandler();

    parent_env_->AddCleanupHook([](void* data) {
      Environment* env = static_cast<Environment*>(data);

      {
        Mutex::ScopedLock lock(start_io_thread_async_mutex);
        start_io_thread_async.data = nullptr;
      }

      // This is global, will ...",33,,695,5,,void
91114,BLOCK,-1,,"{
    Mutex::ScopedLock lock(start_io_thread_async_mutex);
    CHECK_EQ(start_io_thread_async_initialized.exchange(true), false);
    CHECK_EQ(0, uv_async_init(parent_env_->event_loop(),
                              &start_io_thread_async,
                              StartIoThreadAsyncCallback));
    uv_unref(reinterpret_cast<uv_handle_t*>(&start_io_thread_async));
    start_io_thread_async.data = this;
    // Ignore failure, SIGUSR1 won't work, but that should not block node start.
    StartDebugSignalHandler();

    parent_env_->AddCleanupHook([](void* data) {
      Environment* env = static_cast<Environment*>(data);

      {
        Mutex::ScopedLock lock(start_io_thread_async_mutex);
        start_io_thread_async.data = nullptr;
      }

      // This is global, will never get freed
      env->CloseHandle(&start_io_thread_async, [](uv_async_t*) {
        CHECK(start_io_thread_async_initialized.exchange(false));
      });
    }, parent_env_);
  }",38,,702,2,,void
91165,BLOCK,-1,,"{
    wait_for_connect = parent_handle_->WaitForConnect();
    parent_handle_->WorkerStarted(client_->getThreadHandle(), wait_for_connect);
  }",23,,736,2,,void
91182,BLOCK,-1,,<empty>,10,,739,1,,void
91196,BLOCK,-1,,"{
    return false;
  }",32,,740,2,,void
91201,BLOCK,-1,,"{
    CHECK(!parent_env_->has_serialized_options());
    debug_options_.EnableBreakFirstLine();
    parent_env_->options()->get_debug_options()->EnableBreakFirstLine();
    client_->waitForFrontend();
  }",25,,746,2,,void
91231,BLOCK,-1,,"{
  if (io_ != nullptr)
    return true;

  THROW_IF_INSUFFICIENT_PERMISSIONS(parent_env_,
                                    permission::PermissionScope::kInspector,
                                    ""StartIoThread"",
                                    false);
  if (!parent_env_->should_create_inspector() && !client_) {
    ThrowUninitializedInspectorError(parent_env_);
    return false;
  }

  CHECK_NOT_NULL(client_);

  io_ = InspectorIo::Start(client_->getThreadHandle(),
                           path_,
                           host_port_,
                           debug_options_.inspect_publish_uid);
  if (io_ == nullptr) {
    return false;
  }
  NotifyClusterWorkersDebugEnabled(parent_env_);
  return true;
}",29,,755,1,,void
91236,BLOCK,-1,,<empty>,5,,757,2,,void
91257,BLOCK,-1,,"{
    ThrowUninitializedInspectorError(parent_env_);
    return false;
  }",60,,763,2,,void
91281,BLOCK,-1,,"{
    return false;
  }",23,,774,2,,void
91290,BLOCK,-1,,"{
  io_.reset();
}",20,,781,1,,void
91300,BLOCK,-1,,"{
  THROW_IF_INSUFFICIENT_PERMISSIONS(parent_env_,
                                    permission::PermissionScope::kInspector,
                                    ""Connect"",
                                    std::unique_ptr<InspectorSession>{});
  if (!parent_env_->should_create_inspector() && !client_) {
    ThrowUninitializedInspectorError(parent_env_);
    return std::unique_ptr<InspectorSession>{};
  }

  CHECK_NOT_NULL(client_);

  int session_id = client_->connectFrontend(std::move(delegate),
                                            prevent_shutdown);
  return std::unique_ptr<InspectorSession>(
      new SameThreadInspectorSession(session_id, client_));
}",28,,787,3,,void
91320,BLOCK,-1,,"{
    ThrowUninitializedInspectorError(parent_env_);
    return std::unique_ptr<InspectorSession>{};
  }",60,,792,2,,void
91355,BLOCK,-1,,"{
  THROW_IF_INSUFFICIENT_PERMISSIONS(parent_env_,
                                    permission::PermissionScope::kInspector,
                                    ""ConnectToMainThread"",
                                    std::unique_ptr<InspectorSession>{});
  if (!parent_env_->should_create_inspector() && !client_) {
    ThrowUninitializedInspectorError(parent_env_);
    return std::unique_ptr<InspectorSession>{};
  }

  CHECK_NOT_NULL(parent_handle_);
  CHECK_NOT_NULL(client_);
  auto thread_safe_delegate =
      client_->getThreadHandle()->MakeDelegateThreadSafe(std::move(delegate));
  return parent_handle_->Connect(std::move(thread_safe_delegate),
                                 prevent_shutdown);
}",28,,807,3,,void
91375,BLOCK,-1,,"{
    ThrowUninitializedInspectorError(parent_env_);
    return std::unique_ptr<InspectorSession>{};
  }",60,,812,2,,void
91411,BLOCK,-1,,"{
  THROW_IF_INSUFFICIENT_PERMISSIONS(parent_env_,
                                    permission::PermissionScope::kInspector,
                                    ""WaitForDisconnect"");
  if (!parent_env_->should_create_inspector() && !client_) {
    ThrowUninitializedInspectorError(parent_env_);
    return;
  }

  CHECK_NOT_NULL(client_);
  bool is_worker = parent_handle_ != nullptr;
  parent_handle_.reset();
  if (client_->hasConnectedSessions() && !is_worker) {
    fprintf(stderr, ""Waiting for the debugger to disconnect...\n"");
    fflush(stderr);
  }
  if (!client_->notifyWaitingForDisconnect()) {
    client_->contextDestroyed(parent_env_->context());
  } else if (is_worker) {
    client_->waitForSessionsDisconnect();
  }
  if (io_ != nullptr) {
    io_->StopAcceptingNewConnections();
    client_->waitForSessionsDisconnect();
  }
}",33,,825,1,,void
91429,BLOCK,-1,,"{
    ThrowUninitializedInspectorError(parent_env_);
    return;
  }",60,,829,2,,void
91451,BLOCK,-1,,"{
    fprintf(stderr, ""Waiting for the debugger to disconnect...\n"");
    fflush(stderr);
  }",54,,837,2,,void
91462,BLOCK,-1,,"{
    client_->contextDestroyed(parent_env_->context());
  }",47,,841,2,,void
91472,BLOCK,-1,,<empty>,10,,843,1,,void
91475,BLOCK,-1,,"{
    client_->waitForSessionsDisconnect();
  }",25,,843,2,,void
91484,BLOCK,-1,,"{
    io_->StopAcceptingNewConnections();
    client_->waitForSessionsDisconnect();
  }",23,,846,2,,void
91498,BLOCK,-1,,"{
  if (!IsListening())
    return;
  client_->ReportUncaughtException(error, message);
  WaitForDisconnect();
}",61,,853,3,,void
91502,BLOCK,-1,,<empty>,5,,855,2,,void
91515,BLOCK,-1,,"{
  client_->schedulePauseOnNextStatement(reason);
}",71,,860,2,,void
91527,BLOCK,-1,,"{
  parent_env_->set_inspector_enable_async_hooks(enable_function);
  parent_env_->set_inspector_disable_async_hooks(disable_function);
  if (pending_enable_async_hook_) {
    CHECK(!pending_disable_async_hook_);
    pending_enable_async_hook_ = false;
    EnableAsyncHook();
  } else if (pending_disable_async_hook_) {
    CHECK(!pending_enable_async_hook_);
    pending_disable_async_hook_ = false;
    DisableAsyncHook();
  }
}",65,,866,4,,void
91540,BLOCK,-1,,"{
    CHECK(!pending_disable_async_hook_);
    pending_enable_async_hook_ = false;
    EnableAsyncHook();
  }",35,,869,2,,void
91549,BLOCK,-1,,<empty>,10,,873,1,,void
91552,BLOCK,-1,,"{
    CHECK(!pending_enable_async_hook_);
    pending_disable_async_hook_ = false;
    DisableAsyncHook();
  }",43,,873,2,,void
91563,BLOCK,-1,,"{
  HandleScope scope(parent_env_->isolate());
  Local<Function> enable = parent_env_->inspector_enable_async_hooks();
  if (!enable.IsEmpty()) {
    ToggleAsyncHook(parent_env_->isolate(), enable);
  } else if (pending_disable_async_hook_) {
    CHECK(!pending_enable_async_hook_);
    pending_disable_async_hook_ = false;
  } else {
    pending_enable_async_hook_ = true;
  }
}",31,,880,1,,void
91586,BLOCK,-1,,"{
    ToggleAsyncHook(parent_env_->isolate(), enable);
  }",26,,883,2,,void
91594,BLOCK,-1,,<empty>,10,,885,1,,void
91597,BLOCK,-1,,"{
    CHECK(!pending_enable_async_hook_);
    pending_disable_async_hook_ = false;
  }",43,,885,2,,void
91605,BLOCK,-1,,"{
    pending_enable_async_hook_ = true;
  }",10,,888,1,,void
91612,BLOCK,-1,,"{
  HandleScope scope(parent_env_->isolate());
  Local<Function> disable = parent_env_->inspector_enable_async_hooks();
  if (!disable.IsEmpty()) {
    ToggleAsyncHook(parent_env_->isolate(), disable);
  } else if (pending_enable_async_hook_) {
    CHECK(!pending_disable_async_hook_);
    pending_enable_async_hook_ = false;
  } else {
    pending_disable_async_hook_ = true;
  }
}",32,,893,1,,void
91635,BLOCK,-1,,"{
    ToggleAsyncHook(parent_env_->isolate(), disable);
  }",27,,896,2,,void
91643,BLOCK,-1,,<empty>,10,,898,1,,void
91646,BLOCK,-1,,"{
    CHECK(!pending_disable_async_hook_);
    pending_enable_async_hook_ = false;
  }",42,,898,2,,void
91654,BLOCK,-1,,"{
    pending_disable_async_hook_ = true;
  }",10,,901,1,,void
91663,BLOCK,-1,,"{
  // Guard against running this during cleanup -- no async events will be
  // emitted anyway at that point anymore, and calling into JS is not possible.
  // This should probably not be something we're attempting in the first place,
  // Refs: https://github.com/nodejs/node/pull/34362#discussion_r456006039
  if (!parent_env_->can_call_into_js()) return;
  CHECK(parent_env_->has_run_bootstrapping_code());
  HandleScope handle_scope(isolate);
  CHECK(!fn.IsEmpty());
  auto context = parent_env_->context();
  v8::TryCatch try_catch(isolate);
  USE(fn->Call(context, Undefined(isolate), 0, nullptr));
  if (try_catch.HasCaught() && !try_catch.HasTerminated()) {
    PrintCaughtException(isolate, context, try_catch);
    OnFatalError(""\nnode::inspector::Agent::ToggleAsyncHook"",
                 ""Cannot toggle Inspector's AsyncHook, please report this."");
  }
}",67,,906,3,,void
91670,BLOCK,-1,,<empty>,41,,911,2,,void
91717,BLOCK,-1,,"{
    PrintCaughtException(isolate, context, try_catch);
    OnFatalError(""\nnode::inspector::Agent::ToggleAsyncHook"",
                 ""Cannot toggle Inspector's AsyncHook, please report this."");
  }",60,,918,2,,void
91731,BLOCK,-1,,"{
  client_->AsyncTaskScheduled(task_name, task, recurring);
}",48,,926,4,,void
91743,BLOCK,-1,,"{
  client_->AsyncTaskCanceled(task);
}",43,,930,2,,void
91753,BLOCK,-1,,"{
  client_->AsyncTaskStarted(task);
}",42,,934,2,,void
91763,BLOCK,-1,,"{
  client_->AsyncTaskFinished(task);
}",43,,938,2,,void
91772,BLOCK,-1,,"{
  client_->AllAsyncTasksCanceled();
}",37,,942,1,,void
91780,BLOCK,-1,,"{
  // We need to attempt to interrupt V8 flow (in case Node is running
  // continuous JS code) and to wake up libuv thread (in case Node is waiting
  // for IO events)
  if (!options().allow_attaching_debugger) {
    return;
  }
  CHECK(start_io_thread_async_initialized);
  uv_async_send(&start_io_thread_async);
  parent_env_->RequestInterrupt([this](Environment*) {
    StartIoThread();
  });

  CHECK(start_io_thread_async_initialized);
  uv_async_send(&start_io_thread_async);
}",36,,946,1,,void
91786,BLOCK,-1,,"{
    return;
  }",44,,950,2,,void
91805,BLOCK,-1,,"{
  if (client_ == nullptr)  // This happens for a main context
    return;
  client_->contextCreated(context, info);
}",77,,963,3,,void
91810,BLOCK,-1,,<empty>,5,,965,2,,void
91821,BLOCK,-1,,"{
  if (client_ == nullptr)
    return false;
  return io_ != nullptr || client_->IsActive();
}",24,,969,1,,void
91826,BLOCK,-1,,<empty>,5,,971,2,,void
91842,BLOCK,-1,,"{
  parent_handle_ = std::move(parent_handle);
}",59,,976,2,,void
91856,BLOCK,-1,,"{
  THROW_IF_INSUFFICIENT_PERMISSIONS(parent_env_,
                                    permission::PermissionScope::kInspector,
                                    ""GetParentHandle"",
                                    std::unique_ptr<ParentInspectorHandle>{});
  if (!parent_env_->should_create_inspector() && !client_) {
    ThrowUninitializedInspectorError(parent_env_);
    return std::unique_ptr<ParentInspectorHandle>{};
  }

  CHECK_NOT_NULL(client_);
  if (!parent_handle_) {
    return client_->getWorkerManager()->NewParentHandle(thread_id, url, name);
  } else {
    return parent_handle_->NewParentInspectorHandle(thread_id, url, name);
  }
}",74,,981,4,,void
91876,BLOCK,-1,,"{
    ThrowUninitializedInspectorError(parent_env_);
    return std::unique_ptr<ParentInspectorHandle>{};
  }",60,,986,2,,void
91885,BLOCK,-1,,"{
    return client_->getWorkerManager()->NewParentHandle(thread_id, url, name);
  }",24,,992,2,,void
91898,BLOCK,-1,,"{
    return parent_handle_->NewParentInspectorHandle(thread_id, url, name);
  }",10,,994,1,,void
91910,BLOCK,-1,,"{
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      parent_env_, permission::PermissionScope::kInspector, ""WaitForConnect"");
  if (!parent_env_->should_create_inspector() && !client_) {
    ThrowUninitializedInspectorError(parent_env_);
    return;
  }

  CHECK_NOT_NULL(client_);
  client_->waitForFrontend();
}",30,,999,1,,void
91928,BLOCK,-1,,"{
    ThrowUninitializedInspectorError(parent_env_);
    return;
  }",60,,1002,2,,void
91939,BLOCK,-1,,"{
  THROW_IF_INSUFFICIENT_PERMISSIONS(parent_env_,
                                    permission::PermissionScope::kInspector,
                                    ""GetWorkerManager"",
                                    std::unique_ptr<WorkerManager>{});
  if (!parent_env_->should_create_inspector() && !client_) {
    ThrowUninitializedInspectorError(parent_env_);
    return std::unique_ptr<WorkerManager>{};
  }

  CHECK_NOT_NULL(client_);
  return client_->getWorkerManager();
}",58,,1011,1,,void
91959,BLOCK,-1,,"{
    ThrowUninitializedInspectorError(parent_env_);
    return std::unique_ptr<WorkerManager>{};
  }",60,,1016,2,,void
91973,BLOCK,-1,,"{
  if (io_ == nullptr)
    return """";
  return io_->GetWsUrl();
}",37,,1025,1,,void
91978,BLOCK,-1,,<empty>,5,,1027,2,,void
91989,BLOCK,-1,,"{
  auto client = client_.lock();
  if (client)
    client->disconnectFrontend(session_id_);
}",59,,1031,1,,void
91999,BLOCK,-1,,<empty>,5,,1034,2,,void
92009,BLOCK,-1,,"{
  auto client = client_.lock();
  if (client)
    client->dispatchMessageFromFrontend(session_id_, message);
}",46,,1038,2,,void
92019,BLOCK,-1,,<empty>,5,,1041,2,,void
92040,BLOCK,-1,,<empty>,1,,1,1,,ANY
92044,BLOCK,-1,,"{
      RequestQueueData* wrapper =
          node::ContainerOf(&RequestQueueData::async_, async);
      wrapper->DoDispatch();
    }",66,,101,2,,void
92067,BLOCK,-1,,"{
    uv_async_t* async = reinterpret_cast<uv_async_t*>(handle);
    RequestQueueData* wrapper =
        node::ContainerOf(&RequestQueueData::async_, async);
    delete wrapper;
  }",36,,376,2,,void
92126,BLOCK,-1,,<empty>,1,,1,1,,ANY
92137,BLOCK,-1,,"{
  std::string script_path;

  if (!script_name.empty()) {
    uv_fs_t req;
    req.ptr = nullptr;
    if (0 == uv_fs_realpath(loop, &req, script_name.c_str(), nullptr)) {
      CHECK_NOT_NULL(req.ptr);
      script_path = std::string(static_cast<char*>(req.ptr));
    }
    uv_fs_req_cleanup(&req);
  }

  return script_path;
}",73,,29,3,,void
92145,BLOCK,-1,,"{
    uv_fs_t req;
    req.ptr = nullptr;
    if (0 == uv_fs_realpath(loop, &req, script_name.c_str(), nullptr)) {
      CHECK_NOT_NULL(req.ptr);
      script_path = std::string(static_cast<char*>(req.ptr));
    }
    uv_fs_req_cleanup(&req);
  }",29,,32,2,,void
92164,BLOCK,-1,,"{
      CHECK_NOT_NULL(req.ptr);
      script_path = std::string(static_cast<char*>(req.ptr));
    }",72,,35,2,,void
92188,BLOCK,-1,,"{
  uint16_t buffer[8];
  CHECK(crypto::CSPRNG(buffer, sizeof(buffer)).is_ok());

  char uuid[256];
  snprintf(uuid, sizeof(uuid), ""%04x%04x-%04x-%04x-%04x-%04x%04x%04x"",
           buffer[0],  // time_low
           buffer[1],  // time_mid
           buffer[2],  // time_low
           (buffer[3] & 0x0fff) | 0x4000,  // time_hi_and_version
           (buffer[4] & 0x3fff) | 0x8000,  // clk_seq_hi clk_seq_low
           buffer[5],  // node
           buffer[6],
           buffer[7]);
  return uuid;
}",26,,47,1,,void
92248,BLOCK,-1,,<empty>,50,,71,4,,void
92253,BLOCK,-1,,"{
    switch (action_) {
      case TransportAction::kKill:
        server->TerminateConnections();
        [[fallthrough]];
      case TransportAction::kStop:
        server->Stop();
        break;
      case TransportAction::kSendMessage:
        server->Send(
            session_id_,
            protocol::StringUtil::StringViewToUtf8(message_->string()));
        break;
    }
  }",54,,73,2,,void
92256,BLOCK,-1,,"{
      case TransportAction::kKill:
        server->TerminateConnections();
        [[fallthrough]];
      case TransportAction::kStop:
        server->Stop();
        break;
      case TransportAction::kSendMessage:
        server->Send(
            session_id_,
            protocol::StringUtil::StringViewToUtf8(message_->string()));
        break;
    }",22,,74,2,,void
92302,BLOCK,-1,,"{
    int err = uv_async_init(loop, &async_, [](uv_async_t* async) {
      RequestQueueData* wrapper =
          node::ContainerOf(&RequestQueueData::async_, async);
      wrapper->DoDispatch();
    });
    CHECK_EQ(0, err);
  }",77,,100,2,,void
92318,BLOCK,-1,,<empty>,,,,2,,<empty>
92325,BLOCK,-1,,"{
    Mutex::ScopedLock scoped_lock(state_lock_);
    bool notify = messages_.empty();
    messages_.emplace_back(action, session_id, std::move(message));
    if (notify) {
      CHECK_EQ(0, uv_async_send(&async_));
      incoming_message_cond_.Broadcast(scoped_lock);
    }
  }",52,,113,4,,void
92349,BLOCK,-1,,"{
      CHECK_EQ(0, uv_async_send(&async_));
      incoming_message_cond_.Broadcast(scoped_lock);
    }",17,,117,2,,void
92363,BLOCK,-1,,"{
    Mutex::ScopedLock scoped_lock(state_lock_);
    if (messages_.empty()) {
      incoming_message_cond_.Wait(scoped_lock);
    }
  }",15,,123,1,,void
92372,BLOCK,-1,,"{
      incoming_message_cond_.Wait(scoped_lock);
    }",28,,125,2,,void
92382,BLOCK,-1,,"{
    server_ = server;
  }",49,,130,2,,void
92389,BLOCK,-1,,"{
    return handle_;
  }",42,,134,1,,void
92395,BLOCK,-1,,<empty>,,,,1,,<empty>
92399,BLOCK,-1,,"{
    Mutex::ScopedLock scoped_lock(state_lock_);
    MessageQueue messages;
    messages_.swap(messages);
    return messages;
  }",30,,141,1,,void
92414,BLOCK,-1,,"{
    if (server_ == nullptr)
      return;
    for (const auto& request : GetMessages()) {
      request.Dispatch(server_);
    }
  }",21,,148,1,,void
92419,BLOCK,-1,,<empty>,7,,150,2,,void
92424,BLOCK,-1,,"{
      request.Dispatch(server_);
    }",47,,151,3,,void
92439,BLOCK,-1,,<empty>,,,,1,,<empty>
92448,BLOCK,-1,,<empty>,63,,167,2,,void
92452,BLOCK,-1,,"{
    Mutex::ScopedLock scoped_lock(lock_);
    data_ = nullptr;
  }",16,,169,1,,void
92465,BLOCK,-1,,"{
    Mutex::ScopedLock scoped_lock(lock_);
    if (data_ != nullptr)
      data_->Post(session_id, action, std::move(message));
  }",52,,176,4,,void
92473,BLOCK,-1,,<empty>,7,,179,2,,void
92488,BLOCK,-1,,"{
    Mutex::ScopedLock scoped_lock(lock_);
    return data_ == nullptr;
  }",18,,182,1,,void
92504,BLOCK,-1,,{ },63,,195,3,,void
92509,BLOCK,-1,,"{
    request_queue_->Post(id_, TransportAction::kSendMessage,
                         StringBuffer::create(message));
  }",80,,196,2,,void
92534,BLOCK,-1,,<empty>,,,,6,,<empty>
92538,BLOCK,-1,,<empty>,,,,1,,<empty>
92544,BLOCK,-1,,<empty>,,,,3,,<empty>
92550,BLOCK,-1,,<empty>,,,,3,,<empty>
92555,BLOCK,-1,,<empty>,,,,2,,<empty>
92559,BLOCK,-1,,<empty>,,,,1,,<empty>
92564,BLOCK,-1,,<empty>,,,,2,,<empty>
92569,BLOCK,-1,,<empty>,,,,2,,<empty>
92574,BLOCK,-1,,"{
    request_queue_->SetServer(server);
  }",61,,224,2,,void
92593,BLOCK,-1,,"{
  auto io = std::unique_ptr<InspectorIo>(
      new InspectorIo(main_thread,
                      path,
                      host_port,
                      inspect_publish_uid));
  if (io->request_queue_->Expired()) {  // Thread is not running
    return nullptr;
  }
  return io;
}",51,,242,5,,void
92616,BLOCK,-1,,"{  // Thread is not running
    return nullptr;
  }",38,,248,2,,void
92628,BLOCK,-1,,"{
  Mutex::ScopedLock scoped_lock(thread_start_lock_);
  CHECK_EQ(uv_thread_create(&thread_, InspectorIo::ThreadMain, this), 0);
  thread_start_condition_.Wait(scoped_lock);
}",25,,263,5,,void
92649,BLOCK,-1,,"{
  request_queue_->Post(0, TransportAction::kKill, nullptr);
  int err = uv_thread_join(&thread_);
  CHECK_EQ(err, 0);
}",29,,269,1,,void
92671,BLOCK,-1,,"{
  request_queue_->Post(0, TransportAction::kStop, nullptr);
}",49,,275,1,,void
92685,BLOCK,-1,,"{
  static_cast<InspectorIo*>(io)->ThreadMain();
}",40,,280,2,,void
92695,BLOCK,-1,,"{
  uv_loop_t loop;
  loop.data = nullptr;
  int err = uv_loop_init(&loop);
  CHECK_EQ(err, 0);
  std::shared_ptr<RequestQueueData> queue(new RequestQueueData(&loop),
                                          RequestQueueData::CloseAndFree);
  std::string script_path = ScriptPath(&loop, script_name_);
  std::unique_ptr<InspectorIoDelegate> delegate(
      new InspectorIoDelegate(queue, main_thread_, id_,
                              script_path, script_name_));
  std::string host;
  int port;
  {
    ExclusiveAccess<HostPort>::Scoped host_port(host_port_);
    host = host_port->host();
    port = host_port->port();
  }
  InspectorSocketServer server(std::move(delegate),
                               &loop,
                               std::move(host),
                               port,
                               inspect_publish_uid_);
  request_queue_ = queue->handle();
  // Its lifetime is now that of the server delegate
  queue.reset();
  {
    Mutex::ScopedLock scoped_l...",32,,284,1,,void
92748,BLOCK,12,,"{
    ExclusiveAccess<HostPort>::Scoped host_port(host_port_);
    host = host_port->host();
    port = host_port->port();
  }",3,,297,12,,void
92790,BLOCK,17,,"{
    Mutex::ScopedLock scoped_lock(thread_start_lock_);
    if (server.Start()) {
      ExclusiveAccess<HostPort>::Scoped host_port(host_port_);
      host_port->set_port(server.Port());
    }
    thread_start_condition_.Broadcast(scoped_lock);
  }",3,,310,17,,void
92799,BLOCK,-1,,"{
      ExclusiveAccess<HostPort>::Scoped host_port(host_port_);
      host_port->set_port(server.Port());
    }",25,,312,2,,void
92826,BLOCK,-1,,"{
  ExclusiveAccess<HostPort>::Scoped host_port(host_port_);
  return FormatWsAddress(host_port->host(), host_port->port(), id_, true);
}",43,,322,1,,void
92850,BLOCK,-1,,<empty>,29,,335,6,,void
92856,BLOCK,-1,,"{
  auto session = main_thread_->Connect(
      std::unique_ptr<InspectorSessionDelegate>(
          new IoSessionDelegate(request_queue_->handle(), session_id)), true);
  if (session) {
    sessions_[session_id] = std::move(session);
    fprintf(stderr, ""Debugger attached.\n"");
  }
}",70,,338,3,,void
92880,BLOCK,-1,,"{
    sessions_[session_id] = std::move(session);
    fprintf(stderr, ""Debugger attached.\n"");
  }",16,,342,2,,void
92898,BLOCK,-1,,"{
  auto session = sessions_.find(session_id);
  if (session != sessions_.end())
    session->second->Dispatch(Utf8ToStringView(message)->string());
}",71,,349,3,,void
92914,BLOCK,-1,,<empty>,5,,352,2,,void
92930,BLOCK,-1,,"{
  sessions_.erase(session_id);
}",54,,355,2,,void
92939,BLOCK,-1,,"{
  return { target_id_ };
}",62,,359,1,,void
92945,BLOCK,-1,,"{
  return script_name_.empty() ? GetHumanReadableProcessName() : script_name_;
}",72,,363,2,,void
92958,BLOCK,-1,,"{
  return ""file://"" + script_path_;
}",70,,367,2,,void
92967,BLOCK,-1,,"{
  queue->handle_->Reset();
  queue->handle_.reset();
  uv_close(reinterpret_cast<uv_handle_t*>(&queue->async_),
           [](uv_handle_t* handle) {
    uv_async_t* async = reinterpret_cast<uv_async_t*>(handle);
    RequestQueueData* wrapper =
        node::ContainerOf(&RequestQueueData::async_, async);
    delete wrapper;
  });
}",62,,372,2,,void
93004,BLOCK,-1,,<empty>,1,,1,1,,ANY
93029,BLOCK,-1,,<empty>,1,,1,1,,ANY
93036,BLOCK,-1,,"{
  TwoByteValue buffer(isolate, value);
  return StringBuffer::create(StringView(*buffer, buffer.length()));
}",68,,36,3,,void
93059,BLOCK,-1,,"{
    return inspector->Connect(std::move(delegate), false);
  }",77,,43,3,,void
93075,BLOCK,-1,,"{
    return FIXED_ONE_BYTE_STRING(env->isolate(), ""Connection"");
  }",55,,47,2,,void
93089,BLOCK,-1,,"{
    return inspector->ConnectToMainThread(std::move(delegate), true);
  }",77,,54,3,,void
93105,BLOCK,-1,,"{
    return FIXED_ONE_BYTE_STRING(env->isolate(), ""MainThreadConnection"");
  }",55,,58,2,,void
93120,BLOCK,-1,,"{
    }",57,,71,3,,void
93125,BLOCK,-1,,"{
      Isolate* isolate = env_->isolate();
      HandleScope handle_scope(isolate);
      Context::Scope context_scope(env_->context());
      Local<Value> argument;
      if (!String::NewFromTwoByte(isolate, message.characters16(),
                                  NewStringType::kNormal,
                                  message.length()).ToLocal(&argument)) return;
      connection_->OnMessage(argument);
    }",18,,75,2,,void
93170,BLOCK,-1,,<empty>,73,,82,2,,void
93185,BLOCK,-1,,"{
    Agent* inspector = env->inspector_agent();
    session_ = ConnectionType::Connect(
        inspector, std::make_unique<JSBindingsSessionDelegate>(env, this));
  }",62,,95,4,,void
93214,BLOCK,-1,,"{
    MakeCallback(callback_.Get(env()->isolate()), 1, &value);
  }",38,,101,2,,void
93232,BLOCK,-1,,"{
    Isolate* isolate = env->isolate();
    Local<FunctionTemplate> tmpl =
        NewFunctionTemplate(isolate, JSBindingsConnection::New);
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        JSBindingsConnection::kInternalFieldCount);
    tmpl->Inherit(AsyncWrap::GetConstructorTemplate(env));
    SetProtoMethod(isolate, tmpl, ""dispatch"", JSBindingsConnection::Dispatch);
    SetProtoMethod(
        isolate, tmpl, ""disconnect"", JSBindingsConnection::Disconnect);
    SetConstructorFunction(
        env->context(), target, ConnectionType::GetClassName(env), tmpl);
  }",60,,105,3,,void
93300,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(info);
    CHECK(info[0]->IsFunction());
    Local<Function> callback = info[0].As<Function>();
    new JSBindingsConnection(env, info.This(), callback);
  }",60,,119,2,,void
93339,BLOCK,-1,,"{
    BaseObjectPtr<JSBindingsConnection> strong_ref{this};
    session_.reset();
    Detach();
  }",21,,127,1,,void
93356,BLOCK,-1,,"{
    JSBindingsConnection* session;
    ASSIGN_OR_RETURN_UNWRAP(&session, info.Holder());
    session->Disconnect();
  }",67,,133,2,,void
93373,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(info);
    JSBindingsConnection* session;
    ASSIGN_OR_RETURN_UNWRAP(&session, info.Holder());
    CHECK(info[0]->IsString());

    if (session->session_) {
      session->session_->Dispatch(
          ToProtocolString(env->isolate(), info[0])->string());
    }
  }",65,,139,2,,void
93401,BLOCK,-1,,"{
      session->session_->Dispatch(
          ToProtocolString(env->isolate(), info[0])->string());
    }",28,,145,2,,void
93423,BLOCK,-1,,"{
    tracker->TrackField(""callback"", callback_);
    tracker->TrackFieldWithSize(
        ""session"", sizeof(*session_), ""InspectorSession"");
  }",58,,151,2,,void
93446,BLOCK,-1,,"{
    return true;  // Binding connections emit events on their own.
  }",59,,160,1,,void
93455,BLOCK,-1,,"{
  Agent* agent = env->inspector_agent();
  return agent->IsActive();
}",48,,169,2,,void
93472,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(info);

  CHECK_EQ(info.Length(), 1);
  CHECK(info[0]->IsFunction());

  realm->set_inspector_console_extension_installer(info[0].As<Function>());
}",76,,174,2,,void
93508,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK_GT(args.Length(), 1);
  CHECK(args[0]->IsFunction());
  SlicedArguments call_args(args, /* start */ 2);
  env->inspector_agent()->PauseOnNextJavascriptStatement(""Break on start"");
  v8::MaybeLocal<v8::Value> retval =
      args[0].As<v8::Function>()->Call(env->context(), args[1],
                                       call_args.length(), call_args.out());
  if (!retval.IsEmpty()) {
    args.GetReturnValue().Set(retval.ToLocalChecked());
  }
}",71,,183,2,,void
93582,BLOCK,-1,,"{
    args.GetReturnValue().Set(retval.ToLocalChecked());
  }",26,,192,2,,void
93598,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  Isolate* isolate = env->isolate();
  Local<Context> context = isolate->GetCurrentContext();
  CHECK_GE(info.Length(), 2);
  SlicedArguments call_args(info, /* start */ 2);
  if (InspectorEnabled(env)) {
    Local<Value> inspector_method = info[0];
    CHECK(inspector_method->IsFunction());
    if (!env->is_in_inspector_console_call()) {
      env->set_is_in_inspector_console_call(true);
      MaybeLocal<Value> ret =
          inspector_method.As<Function>()->Call(context,
                                                info.Holder(),
                                                call_args.length(),
                                                call_args.out());
      env->set_is_in_inspector_console_call(false);
      if (ret.IsEmpty())
        return;
    }
  }

  Local<Value> node_method = info[1];
  CHECK(node_method->IsFunction());
  USE(node_method.As<Function>()->Call(context,
                                   info.H...",68,,197,2,,void
93637,BLOCK,-1,,"{
    Local<Value> inspector_method = info[0];
    CHECK(inspector_method->IsFunction());
    if (!env->is_in_inspector_console_call()) {
      env->set_is_in_inspector_console_call(true);
      MaybeLocal<Value> ret =
          inspector_method.As<Function>()->Call(context,
                                                info.Holder(),
                                                call_args.length(),
                                                call_args.out());
      env->set_is_in_inspector_console_call(false);
      if (ret.IsEmpty())
        return;
    }
  }",30,,203,2,,void
93658,BLOCK,-1,,"{
      env->set_is_in_inspector_console_call(true);
      MaybeLocal<Value> ret =
          inspector_method.As<Function>()->Call(context,
                                                info.Holder(),
                                                call_args.length(),
                                                call_args.out());
      env->set_is_in_inspector_console_call(false);
      if (ret.IsEmpty())
        return;
    }",47,,206,2,,void
93700,BLOCK,-1,,<empty>,9,,215,2,,void
93741,BLOCK,-1,,"{
  // The inspector assumes that when other clients use its asyncTask* API,
  // they use real pointers, or at least something aligned like real pointer.
  // In general it means that our task_id should always be even.
  //
  // On 32bit platforms, the 64bit asyncId would get truncated when converted
  // to a 32bit pointer. However, the javascript part will never enable
  // the async_hook on 32bit platforms, therefore the truncation will never
  // happen in practice.
  return reinterpret_cast<void*>(asyncId << 1);
}",44,,227,2,,void
93752,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsNumber());
  int64_t task_id = args[0]->IntegerValue(env->context()).FromJust();
  (env->inspector_agent()->*asyncTaskFn)(GetAsyncTask(task_id));
}",78,,240,2,,void
93797,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsString());
  Local<String> task_name = args[0].As<String>();
  String::Value task_name_value(args.GetIsolate(), task_name);
  StringView task_name_view(*task_name_value, task_name_value.length());

  CHECK(args[1]->IsNumber());
  int64_t task_id = args[1]->IntegerValue(env->context()).FromJust();
  void* task = GetAsyncTask(task_id);

  CHECK(args[2]->IsBoolean());
  bool recurring = args[2]->BooleanValue(args.GetIsolate());

  env->inspector_agent()->AsyncTaskScheduled(task_name_view, task, recurring);
}",80,,247,2,,void
93902,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsFunction());
  Local<Function> enable_function = args[0].As<Function>();
  CHECK(args[1]->IsFunction());
  Local<Function> disable_function = args[1].As<Function>();
  env->inspector_agent()->RegisterAsyncHook(env->isolate(),
    enable_function, disable_function);
}",79,,265,2,,void
93966,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  args.GetReturnValue().Set(env->inspector_agent()->IsListening());
}",57,,276,2,,void
93993,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Agent* agent = env->inspector_agent();

  if (args.Length() > 0 && args[0]->IsUint32()) {
    uint32_t port = args[0].As<Uint32>()->Value();
    CHECK_LE(port, std::numeric_limits<uint16_t>::max());
    ExclusiveAccess<HostPort>::Scoped host_port(agent->host_port());
    host_port->set_port(static_cast<int>(port));
  }

  if (args.Length() > 1 && args[1]->IsString()) {
    Utf8Value host(env->isolate(), args[1].As<String>());
    ExclusiveAccess<HostPort>::Scoped host_port(agent->host_port());
    host_port->set_host(*host);
  }

  agent->StartIoThread();
}",52,,281,2,,void
94023,BLOCK,-1,,"{
    uint32_t port = args[0].As<Uint32>()->Value();
    CHECK_LE(port, std::numeric_limits<uint16_t>::max());
    ExclusiveAccess<HostPort>::Scoped host_port(agent->host_port());
    host_port->set_port(static_cast<int>(port));
  }",49,,285,2,,void
94075,BLOCK,-1,,"{
    Utf8Value host(env->isolate(), args[1].As<String>());
    ExclusiveAccess<HostPort>::Scoped host_port(agent->host_port());
    host_port->set_host(*host);
  }",49,,292,2,,void
94108,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Agent* agent = env->inspector_agent();
  if (agent->IsActive())
    agent->WaitForConnect();
  args.GetReturnValue().Set(agent->IsActive());
}",63,,301,2,,void
94129,BLOCK,-1,,<empty>,5,,305,2,,void
94149,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  std::string url = env->inspector_agent()->GetWsUrl();
  if (url.empty()) {
    return;
  }
  args.GetReturnValue().Set(OneByteString(env->isolate(), url.c_str()));
}",51,,309,2,,void
94173,BLOCK,-1,,"{
    return;
  }",20,,312,2,,void
94198,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  v8::Local<v8::Function> consoleCallFunc =
      NewFunctionTemplate(isolate,
                          InspectorConsoleCall,
                          v8::Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasSideEffect)
          ->GetFunction(context)
          .ToLocalChecked();
  auto name_string = FIXED_ONE_BYTE_STRING(isolate, ""consoleCall"");
  target->Set(context, name_string, consoleCallFunc).Check();
  consoleCallFunc->SetName(name_string);

  SetMethod(context,
            target,
            ""setConsoleExtensionInstaller"",
            SetConsoleExtensionInstaller);
  SetMethod(context, target, ""callAndPauseOnStart"", CallAndPauseOnStart);
  SetMethod(context, target, ""open"", Open);
  SetMethodNoSideEffect(context, target, ""url"", Url);
  SetMethod(context, target, ""waitForDebugger"", WaitForDebugger);
...",53,,319,5,,void
94377,BLOCK,-1,,"{
  registry->Register(InspectorConsoleCall);
  registry->Register(SetConsoleExtensionInstaller);
  registry->Register(CallAndPauseOnStart);
  registry->Register(Open);
  registry->Register(Url);
  registry->Register(WaitForDebugger);

  registry->Register(AsyncTaskScheduledWrapper);
  registry->Register(InvokeAsyncTaskFnWithId<&Agent::AsyncTaskCanceled>);
  registry->Register(InvokeAsyncTaskFnWithId<&Agent::AsyncTaskStarted>);
  registry->Register(InvokeAsyncTaskFnWithId<&Agent::AsyncTaskFinished>);

  registry->Register(RegisterAsyncHookWrapper);
  registry->Register(IsEnabled);

  registry->Register(JSBindingsConnection<LocalConnection>::New);
  registry->Register(JSBindingsConnection<LocalConnection>::Dispatch);
  registry->Register(JSBindingsConnection<LocalConnection>::Disconnect);
  registry->Register(JSBindingsConnection<MainThreadConnection>::New);
  registry->Register(JSBindingsConnection<MainThreadConnection>::Dispatch);
  registry->Register(JSBindingsConnection<MainThrea...",70,,378,2,,void
94486,BLOCK,-1,,"{
    EndStartedProfilers(static_cast<Environment*>(env));
  }",29,,417,2,,void
94524,BLOCK,-1,,<empty>,1,,1,1,,ANY
94529,BLOCK,-1,,<empty>,17,,39,2,,void
94536,BLOCK,-1,,"{
  std::stringstream ss;
  uint32_t id = next_id();
  ss << R""({ ""id"": )"" << id;
  DCHECK(method != nullptr);
  ss << R""(, ""method"": "")"" << method << '""';
  if (params != nullptr) {
    ss << R""(, ""params"": )"" << params;
  }
  ss << "" }"";
  std::string message = ss.str();
  const uint8_t* message_data =
      reinterpret_cast<const uint8_t*>(message.c_str());
  // Save the id of the profile request to identify its response.
  if (is_profile_request) {
    profile_ids_.insert(id);
  }
  Debug(env(),
        DebugCategory::INSPECTOR_PROFILER,
        ""Dispatching message %s\n"",
        message.c_str());
  session_->Dispatch(StringView(message_data, message.length()));
  return id;
}",73,,43,4,,void
94562,BLOCK,-1,,"{
    ss << R""(, ""params"": )"" << params;
  }",26,,49,2,,void
94589,BLOCK,-1,,"{
    profile_ids_.insert(id);
  }",27,,57,2,,void
94623,BLOCK,-1,,"{
  int ret = WriteFileSync(env->isolate(), path, result);
  if (ret != 0) {
    char err_buf[128];
    uv_err_name_r(ret, err_buf, sizeof(err_buf));
    fprintf(stderr, ""%s: Failed to write file %s\n"", err_buf, path);
    return;
  }
  Debug(env, DebugCategory::INSPECTOR_PROFILER, ""Written result to %s\n"", path);
}",47,,70,4,,void
94638,BLOCK,-1,,"{
    char err_buf[128];
    uv_err_name_r(ret, err_buf, sizeof(err_buf));
    fprintf(stderr, ""%s: Failed to write file %s\n"", err_buf, path);
    return;
  }",17,,72,2,,void
94662,BLOCK,-1,,"{
  Environment* env = connection_->env();
  Isolate* isolate = env->isolate();
  HandleScope handle_scope(isolate);
  Local<Context> context = env->context();
  Context::Scope context_scope(context);

  const char* type = connection_->type();
  // Convert StringView to a Local<String>.
  Local<String> message_str;
  if (!String::NewFromTwoByte(isolate,
                              message.characters16(),
                              NewStringType::kNormal,
                              message.length())
           .ToLocal(&message_str)) {
    fprintf(
        stderr, ""Failed to convert %s profile message to V8 string\n"", type);
    return;
  }

  Debug(env,
        DebugCategory::INSPECTOR_PROFILER,
        ""Receive %s profile message\n"",
        type);

  Local<Value> parsed;
  if (!v8::JSON::Parse(context, message_str).ToLocal(&parsed) ||
      !parsed->IsObject()) {
    fprintf(stderr, ""Failed to parse %s profile result as JSON object\n"", type);
    return;
  }

  Local<Objec...",46,,82,2,,void
94728,BLOCK,-1,,"{
    fprintf(
        stderr, ""Failed to convert %s profile message to V8 string\n"", type);
    return;
  }",36,,96,2,,void
94767,BLOCK,-1,,"{
    fprintf(stderr, ""Failed to parse %s profile result as JSON object\n"", type);
    return;
  }",28,,109,2,,void
94809,BLOCK,-1,,"{
    Utf8Value str(isolate, message_str);
    fprintf(
        stderr, ""Cannot retrieve id from the response message:\n%s\n"", *str);
    return;
  }",26,,118,2,,void
94837,BLOCK,-1,,"{
    Utf8Value str(isolate, message_str);
    Debug(env, DebugCategory::INSPECTOR_PROFILER, ""%s\n"", *str);
    return;
  }",39,,126,2,,void
94852,BLOCK,-1,,"{
    Debug(env,
          DebugCategory::INSPECTOR_PROFILER,
          ""Writing profile response (id = %"" PRIu64 "")\n"",
          static_cast<uint64_t>(id));
  }",10,,130,1,,void
94874,BLOCK,-1,,"{
    fprintf(stderr, ""Failed to get 'result' from %s profile response\n"", type);
    return;
  }",33,,140,2,,void
94886,BLOCK,-1,,"{
    fprintf(
        stderr, ""'result' from %s profile response is not an object\n"", type);
    return;
  }",30,,145,2,,void
94910,BLOCK,-1,,"{
  fs::FSReqWrapSync req_wrap_sync;
  int ret = fs::MKDirpSync(nullptr, &req_wrap_sync.req, directory, 0777,
                           nullptr);
  if (ret < 0 && ret != UV_EEXIST) {
    char err_buf[128];
    uv_err_name_r(ret, err_buf, sizeof(err_buf));
    fprintf(stderr,
            ""%s: Failed to create %s profile directory %s\n"",
            err_buf,
            type,
            directory.c_str());
    return false;
  }
  return true;
}",77,,155,3,,void
94935,BLOCK,-1,,"{
    char err_buf[128];
    uv_err_name_r(ret, err_buf, sizeof(err_buf));
    fprintf(stderr,
            ""%s: Failed to create %s profile directory %s\n"",
            err_buf,
            type,
            directory.c_str());
    return false;
  }",36,,159,2,,void
94958,BLOCK,-1,,"{
  uint64_t timestamp =
      static_cast<uint64_t>(GetCurrentTimeInMicroseconds() / 1000);
  return SPrintF(""coverage-%s-%s-%s.json"",
      uv_os_getpid(),
      timestamp,
      env()->thread_id());
}",55,,172,1,,void
94980,BLOCK,-1,,"{
  Local<Context> context = env_->context();

  // Generate the profile output from the subclass.
  Local<Object> profile;
  if (!GetProfile(result).ToLocal(&profile)) {
    return;
  }

  Local<String> result_s;
  if (!v8::JSON::Stringify(context, profile).ToLocal(&result_s)) {
    fprintf(stderr, ""Failed to stringify %s profile result\n"", type());
    return;
  }

  // Create the directory if necessary.
  std::string directory = GetDirectory();
  DCHECK(!directory.empty());
  if (!EnsureDirectory(directory, type())) {
    return;
  }

  std::string filename = GetFilename();
  DCHECK(!filename.empty());
  std::string path = directory + kPathSeparator + filename;

  WriteResult(env_, path.c_str(), result_s);
}",63,,181,2,,void
95005,BLOCK,-1,,"{
    return;
  }",46,,186,2,,void
95027,BLOCK,-1,,"{
    fprintf(stderr, ""Failed to stringify %s profile result\n"", type());
    return;
  }",66,,191,2,,void
95048,BLOCK,-1,,"{
    return;
  }",44,,199,2,,void
95079,BLOCK,-1,,"{
  Isolate* isolate = env_->isolate();
  Local<Context> context = env_->context();
  HandleScope handle_scope(isolate);
  Context::Scope context_scope(context);

  // This is only set up during pre-execution (when the environment variables
  // becomes available in the JS land). If it's empty, we don't have coverage
  // directory path (which is resolved in JS land at the moment) either, so
  // the best we could to is to just discard the profile and do nothing.
  // This should only happen in half-baked Environments created using the
  // embedder API.
  if (env_->source_map_cache_getter().IsEmpty()) {
    return;
  }

  // Generate the profile output from the subclass.
  Local<Object> profile;
  if (!GetProfile(result).ToLocal(&profile)) {
    return;
  }

  // append source-map cache information to coverage object:
  Local<Value> source_map_cache_v;
  {
    TryCatchScope try_catch(env());
    {
      Isolate::AllowJavascriptExecutionScope allow_js_here(isolate);
      Local<Func...",63,,210,2,,void
95111,BLOCK,-1,,"{
    return;
  }",50,,222,2,,void
95127,BLOCK,-1,,"{
    return;
  }",46,,228,2,,void
95134,BLOCK,12,,"{
    TryCatchScope try_catch(env());
    {
      Isolate::AllowJavascriptExecutionScope allow_js_here(isolate);
      Local<Function> source_map_cache_getter = env_->source_map_cache_getter();
      if (!source_map_cache_getter->Call(
              context, Undefined(isolate), 0, nullptr)
              .ToLocal(&source_map_cache_v)) {
        return;
      }
    }
    if (try_catch.HasCaught() && !try_catch.HasTerminated()) {
      PrintCaughtException(isolate, context, try_catch);
    }
  }",3,,234,12,,void
95138,BLOCK,3,,"{
      Isolate::AllowJavascriptExecutionScope allow_js_here(isolate);
      Local<Function> source_map_cache_getter = env_->source_map_cache_getter();
      if (!source_map_cache_getter->Call(
              context, Undefined(isolate), 0, nullptr)
              .ToLocal(&source_map_cache_v)) {
        return;
      }
    }",5,,236,3,,void
95168,BLOCK,-1,,"{
        return;
      }",46,,241,2,,void
95181,BLOCK,-1,,"{
      PrintCaughtException(isolate, context, try_catch);
    }",62,,245,2,,void
95192,BLOCK,-1,,"{
    profile->Set(context, FIXED_ONE_BYTE_STRING(isolate, ""source-map-cache""),
                source_map_cache_v).ToChecked();
  }",43,,250,2,,void
95225,BLOCK,-1,,"{
    fprintf(stderr, ""Failed to stringify %s profile result\n"", type());
    return;
  }",66,,256,2,,void
95246,BLOCK,-1,,"{
    return;
  }",44,,264,2,,void
95277,BLOCK,-1,,"{
  return result;
}",75,,275,2,,void
95283,BLOCK,-1,,"{
  return env()->coverage_directory();
}",56,,279,1,,void
95292,BLOCK,-1,,"{
  DispatchMessage(""Profiler.enable"");
  DispatchMessage(""Profiler.startPreciseCoverage"",
                  R""({ ""callCount"": true, ""detailed"": true })"");
}",36,,283,1,,void
95301,BLOCK,-1,,"{
  DispatchMessage(""Profiler.takePreciseCoverage"", nullptr, true);
}",43,,289,1,,void
95309,BLOCK,-1,,"{
  DispatchMessage(""Profiler.stopPreciseCoverage"");
}",43,,293,1,,void
95315,BLOCK,-1,,"{
  Debug(env_,
      DebugCategory::INSPECTOR_PROFILER,
      ""V8CoverageConnection::End(), ending = %d\n"", ending_);
  if (ending_) {
    return;
  }
  ending_ = true;
  TakeCoverage();
}",34,,297,1,,void
95325,BLOCK,-1,,"{
    return;
  }",16,,301,2,,void
95334,BLOCK,-1,,"{
  return env()->cpu_prof_dir();
}",59,,308,1,,void
95343,BLOCK,-1,,"{
  return env()->cpu_prof_name();
}",58,,312,1,,void
95353,BLOCK,-1,,"{
  Local<Value> profile_v;
  if (!result
           ->Get(env()->context(),
                 FIXED_ONE_BYTE_STRING(env()->isolate(), ""profile""))
           .ToLocal(&profile_v)) {
    fprintf(stderr, ""'profile' from CPU profile result is undefined\n"");
    return MaybeLocal<Object>();
  }
  if (!profile_v->IsObject()) {
    fprintf(stderr, ""'profile' from CPU profile result is not an Object\n"");
    return MaybeLocal<Object>();
  }
  return profile_v.As<Object>();
}",78,,316,2,,void
95380,BLOCK,-1,,"{
    fprintf(stderr, ""'profile' from CPU profile result is undefined\n"");
    return MaybeLocal<Object>();
  }",34,,321,2,,void
95392,BLOCK,-1,,"{
    fprintf(stderr, ""'profile' from CPU profile result is not an Object\n"");
    return MaybeLocal<Object>();
  }",31,,325,2,,void
95406,BLOCK,-1,,"{
  DispatchMessage(""Profiler.enable"");
  std::string params = R""({ ""interval"": )"";
  params += std::to_string(env()->cpu_prof_interval());
  params += "" }"";
  DispatchMessage(""Profiler.setSamplingInterval"", params.c_str());
  DispatchMessage(""Profiler.start"");
}",39,,332,1,,void
95437,BLOCK,-1,,"{
  Debug(env_,
      DebugCategory::INSPECTOR_PROFILER,
      ""V8CpuProfilerConnection::End(), ending = %d\n"", ending_);
  if (ending_) {
    return;
  }
  ending_ = true;
  DispatchMessage(""Profiler.stop"", nullptr, true);
}",37,,341,1,,void
95447,BLOCK,-1,,"{
    return;
  }",16,,345,2,,void
95459,BLOCK,-1,,"{
  return env()->heap_prof_dir();
}",60,,352,1,,void
95468,BLOCK,-1,,"{
  return env()->heap_prof_name();
}",59,,356,1,,void
95478,BLOCK,-1,,"{
  Local<Value> profile_v;
  if (!result
           ->Get(env()->context(),
                 FIXED_ONE_BYTE_STRING(env()->isolate(), ""profile""))
           .ToLocal(&profile_v)) {
    fprintf(stderr, ""'profile' from heap profile result is undefined\n"");
    return MaybeLocal<Object>();
  }
  if (!profile_v->IsObject()) {
    fprintf(stderr, ""'profile' from heap profile result is not an Object\n"");
    return MaybeLocal<Object>();
  }
  return profile_v.As<Object>();
}",79,,360,2,,void
95505,BLOCK,-1,,"{
    fprintf(stderr, ""'profile' from heap profile result is undefined\n"");
    return MaybeLocal<Object>();
  }",34,,365,2,,void
95517,BLOCK,-1,,"{
    fprintf(stderr, ""'profile' from heap profile result is not an Object\n"");
    return MaybeLocal<Object>();
  }",31,,369,2,,void
95531,BLOCK,-1,,"{
  DispatchMessage(""HeapProfiler.enable"");
  std::string params = R""({ ""samplingInterval"": )"";
  params += std::to_string(env()->heap_prof_interval());
  params += "" }"";
  DispatchMessage(""HeapProfiler.startSampling"", params.c_str());
}",40,,376,1,,void
95560,BLOCK,-1,,"{
  Debug(env_,
      DebugCategory::INSPECTOR_PROFILER,
      ""V8HeapProfilerConnection::End(), ending = %d\n"", ending_);
  if (ending_) {
    return;
  }
  ending_ = true;
  DispatchMessage(""HeapProfiler.stopSampling"", nullptr, true);
}",38,,384,1,,void
95570,BLOCK,-1,,"{
    return;
  }",16,,388,2,,void
95583,BLOCK,-1,,"{
  // TODO(joyeechueng): merge these connections and use one session per env.
  Debug(env, DebugCategory::INSPECTOR_PROFILER, ""EndStartedProfilers\n"");
  V8ProfilerConnection* connection = env->cpu_profiler_connection();
  if (connection != nullptr) {
    connection->End();
  }

  connection = env->heap_profiler_connection();
  if (connection != nullptr) {
    connection->End();
  }

  connection = env->coverage_connection();
  if (connection != nullptr) {
    connection->End();
  }
}",51,,397,2,,void
95601,BLOCK,-1,,"{
    connection->End();
  }",30,,401,2,,void
95616,BLOCK,-1,,"{
    connection->End();
  }",30,,406,2,,void
95631,BLOCK,-1,,"{
    connection->End();
  }",30,,411,2,,void
95639,BLOCK,-1,,"{
  AtExit(env, [](void* env) {
    EndStartedProfilers(static_cast<Environment*>(env));
  }, env);

  Isolate* isolate = env->isolate();
  Local<String> coverage_str = env->env_vars()->Get(
      isolate, FIXED_ONE_BYTE_STRING(isolate, ""NODE_V8_COVERAGE""))
      .FromMaybe(Local<String>());
  if ((!coverage_str.IsEmpty() && coverage_str->Length() > 0) ||
      env->options()->test_runner_coverage) {
    CHECK_NULL(env->coverage_connection());
    env->set_coverage_connection(std::make_unique<V8CoverageConnection>(env));
    env->coverage_connection()->Start();
  }
  if (env->options()->cpu_prof) {
    const std::string& dir = env->options()->cpu_prof_dir;
    env->set_cpu_prof_interval(env->options()->cpu_prof_interval);
    env->set_cpu_prof_dir(dir.empty() ? env->GetCwd() : dir);
    if (env->options()->cpu_prof_name.empty()) {
      DiagnosticFilename filename(env, ""CPU"", ""cpuprofile"");
      env->set_cpu_prof_name(*filename);
    } else {
      env->set_cpu_prof_name(env->optio...",39,,416,2,,void
95692,BLOCK,-1,,"{
    CHECK_NULL(env->coverage_connection());
    env->set_coverage_connection(std::make_unique<V8CoverageConnection>(env));
    env->coverage_connection()->Start();
  }",45,,426,2,,void
95723,BLOCK,-1,,"{
    const std::string& dir = env->options()->cpu_prof_dir;
    env->set_cpu_prof_interval(env->options()->cpu_prof_interval);
    env->set_cpu_prof_dir(dir.empty() ? env->GetCwd() : dir);
    if (env->options()->cpu_prof_name.empty()) {
      DiagnosticFilename filename(env, ""CPU"", ""cpuprofile"");
      env->set_cpu_prof_name(*filename);
    } else {
      env->set_cpu_prof_name(env->options()->cpu_prof_name);
    }
    CHECK_NULL(env->cpu_profiler_connection());
    env->set_cpu_profiler_connection(
        std::make_unique<V8CpuProfilerConnection>(env));
    env->cpu_profiler_connection()->Start();
  }",33,,431,2,,void
95767,BLOCK,-1,,"{
      DiagnosticFilename filename(env, ""CPU"", ""cpuprofile"");
      env->set_cpu_prof_name(*filename);
    }",48,,435,2,,void
95780,BLOCK,-1,,"{
      env->set_cpu_prof_name(env->options()->cpu_prof_name);
    }",12,,438,1,,void
95821,BLOCK,-1,,"{
    const std::string& dir = env->options()->heap_prof_dir;
    env->set_heap_prof_interval(env->options()->heap_prof_interval);
    env->set_heap_prof_dir(dir.empty() ? env->GetCwd() : dir);
    if (env->options()->heap_prof_name.empty()) {
      DiagnosticFilename filename(env, ""Heap"", ""heapprofile"");
      env->set_heap_prof_name(*filename);
    } else {
      env->set_heap_prof_name(env->options()->heap_prof_name);
    }
    env->set_heap_profiler_connection(
        std::make_unique<profiler::V8HeapProfilerConnection>(env));
    env->heap_profiler_connection()->Start();
  }",34,,446,2,,void
95865,BLOCK,-1,,"{
      DiagnosticFilename filename(env, ""Heap"", ""heapprofile"");
      env->set_heap_prof_name(*filename);
    }",49,,450,2,,void
95878,BLOCK,-1,,"{
      env->set_heap_prof_name(env->options()->heap_prof_name);
    }",12,,453,1,,void
95913,BLOCK,-1,,"{
  CHECK(args[0]->IsString());
  Environment* env = Environment::GetCurrent(args);
  node::Utf8Value directory(env->isolate(), args[0].As<String>());
  env->set_coverage_directory(*directory);
}",75,,462,2,,void
95951,BLOCK,-1,,"{
  CHECK(args[0]->IsFunction());
  Environment* env = Environment::GetCurrent(args);
  env->set_source_map_cache_getter(args[0].As<Function>());
}",78,,470,2,,void
95981,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  V8CoverageConnection* connection = env->coverage_connection();

  Debug(
    env,
    DebugCategory::INSPECTOR_PROFILER,
    ""TakeCoverage, connection %s nullptr\n"",
    connection == nullptr ? ""=="" : ""!="");

  if (connection != nullptr) {
    Debug(env, DebugCategory::INSPECTOR_PROFILER, ""taking coverage\n"");
    connection->TakeCoverage();
  }
}",67,,476,2,,void
96013,BLOCK,-1,,"{
    Debug(env, DebugCategory::INSPECTOR_PROFILER, ""taking coverage\n"");
    connection->TakeCoverage();
  }",30,,486,2,,void
96028,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  V8CoverageConnection* connection = env->coverage_connection();

  Debug(env,
        DebugCategory::INSPECTOR_PROFILER,
        ""StopCoverage, connection %s nullptr\n"",
        connection == nullptr ? ""=="" : ""!="");

  if (connection != nullptr) {
    Debug(env, DebugCategory::INSPECTOR_PROFILER, ""Stopping coverage\n"");
    connection->StopCoverage();
  }
}",67,,492,2,,void
96060,BLOCK,-1,,"{
    Debug(env, DebugCategory::INSPECTOR_PROFILER, ""Stopping coverage\n"");
    connection->StopCoverage();
  }",30,,501,2,,void
96078,BLOCK,-1,,"{
  SetMethod(context, target, ""setCoverageDirectory"", SetCoverageDirectory);
  SetMethod(
      context, target, ""setSourceMapCacheGetter"", SetSourceMapCacheGetter);
  SetMethod(context, target, ""takeCoverage"", TakeCoverage);
  SetMethod(context, target, ""stopCoverage"", StopCoverage);
}",36,,510,5,,void
96103,BLOCK,-1,,"{
  registry->Register(SetCoverageDirectory);
  registry->Register(SetSourceMapCacheGetter);
  registry->Register(TakeCoverage);
  registry->Register(StopCoverage);
}",70,,518,2,,void
96135,BLOCK,-1,,<empty>,1,,1,1,,ANY
96139,BLOCK,-1,,{ return b == 0; },59,,204,2,,void
96166,BLOCK,-1,,<empty>,1,,1,1,,ANY
96172,BLOCK,-1,,<empty>,,,,2,,<empty>
96179,BLOCK,-1,,<empty>,,,,3,,<empty>
96184,BLOCK,-1,,<empty>,,,,2,,<empty>
96190,BLOCK,-1,,<empty>,,,,3,,<empty>
96194,BLOCK,-1,,"{
    return &tcp_;
  }",19,,30,1,,void
96201,BLOCK,-1,,<empty>,,,,1,,<empty>
96206,BLOCK,-1,,"{
    return node::ContainerOf(&TcpHolder::tcp_,
                             reinterpret_cast<uv_tcp_t*>(handle));
  }",40,,36,2,,void
96223,BLOCK,-1,,<empty>,,,,2,,<empty>
96230,BLOCK,-1,,<empty>,,,,4,,<empty>
96235,BLOCK,-1,,<empty>,,,,2,,<empty>
96239,BLOCK,-1,,<empty>,,,,1,,<empty>
96245,BLOCK,-1,,<empty>,,,,3,,<empty>
96256,BLOCK,-1,,<empty>,,,,3,,<empty>
96261,BLOCK,-1,,<empty>,,,,2,,<empty>
96266,BLOCK,-1,,<empty>,,,,2,,<empty>
96270,BLOCK,-1,,<empty>,,,,1,,<empty>
96275,BLOCK,-1,,<empty>,,,,2,,<empty>
96279,BLOCK,-1,,<empty>,,,,1,,<empty>
96283,BLOCK,-1,,<empty>,,,,1,,<empty>
96287,BLOCK,-1,,"{
    return inspector_;
  }",32,,66,1,,void
96293,BLOCK,-1,,<empty>,,,,1,,<empty>
96297,BLOCK,-1,,<empty>,,,,1,,<empty>
96303,BLOCK,-1,,<empty>,,,,3,,<empty>
96307,BLOCK,-1,,<empty>,,,,1,,<empty>
96317,BLOCK,-1,,<empty>,58,,114,3,,void
96322,BLOCK,-1,,"{
    return node::ContainerOf(&WriteRequest::req, req);
  }",56,,116,2,,void
96338,BLOCK,-1,,"{
    delete WriteRequest::from_write_req(req);
  }",52,,120,3,,void
96355,BLOCK,-1,,"{
  *buf = uv_buf_init(new char[len], len);
}",70,,130,4,,void
96368,BLOCK,-1,,"{
  buffer->erase(buffer->begin(), buffer->begin() + count);
}",76,,134,3,,void
96399,BLOCK,-1,,"{
  // Magic string from websockets spec.
  static const char ws_magic[] = ""258EAFA5-E914-47DA-95CA-C5AB0DC85B11"";
  std::string input(client_key + ws_magic);
  char hash[SHA_DIGEST_LENGTH];
  USE(SHA1(reinterpret_cast<const unsigned char*>(input.data()),
           input.size(),
           reinterpret_cast<unsigned char*>(hash)));
  node::base64_encode(hash, sizeof(hash), *buffer, sizeof(*buffer));
}",71,,145,3,,void
96441,BLOCK,-1,,"{
  size_t last_colon_pos = host.rfind(':');
  if (last_colon_pos == std::string::npos)
    return host;
  size_t bracket = host.rfind(']');
  if (bracket == std::string::npos || last_colon_pos > bracket)
    return host.substr(0, last_colon_pos);
  return host;
}",54,,156,2,,void
96458,BLOCK,-1,,<empty>,5,,159,2,,void
96481,BLOCK,-1,,<empty>,5,,162,2,,void
96495,BLOCK,-1,,"{
  // To avoid DNS rebinding attacks, we are aware of the following requirements:
  // * the host name must be an IP address (CVE-2018-7160, CVE-2022-32212),
  // * the IP address must be routable (hackerone.com/reports/1632921), and
  // * the IP address must be formatted unambiguously (CVE-2022-43548).

  // The logic below assumes that the string is null-terminated, so ensure that
  // we did not somehow end up with null characters within the string.
  if (host.find('\0') != std::string::npos) return false;

  // All IPv6 addresses must be enclosed in square brackets, and anything
  // enclosed in square brackets must be an IPv6 address.
  if (host.length() >= 4 && host.front() == '[' && host.back() == ']') {
    // INET6_ADDRSTRLEN is the maximum length of the dual format (including the
    // terminating null character), which is the longest possible representation
    // of an IPv6 address: xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:ddd.ddd.ddd.ddd
    if (host.length() - 2 >= INET6_ADDRS...",50,,166,2,,void
96508,BLOCK,-1,,<empty>,45,,174,2,,void
96532,BLOCK,-1,,"{
    // INET6_ADDRSTRLEN is the maximum length of the dual format (including the
    // terminating null character), which is the longest possible representation
    // of an IPv6 address: xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:ddd.ddd.ddd.ddd
    if (host.length() - 2 >= INET6_ADDRSTRLEN) return false;

    // Annoyingly, libuv's implementation of inet_pton() deviates from other
    // implementations of the function in that it allows '%' in IPv6 addresses.
    if (host.find('%') != std::string::npos) return false;

    // Parse the IPv6 address to ensure it is syntactically valid.
    char ipv6_str[INET6_ADDRSTRLEN];
    std::copy(host.begin() + 1, host.end() - 1, ipv6_str);
    ipv6_str[host.length()] = '\0';
    unsigned char ipv6[sizeof(struct in6_addr)];
    if (uv_inet_pton(AF_INET6, ipv6_str, ipv6) != 0) return false;

    // The only non-routable IPv6 address is ::/128. It should not be necessary
    // to explicitly reject it because it will still be enclosed in square
    // brac...",72,,178,2,,void
96542,BLOCK,-1,,<empty>,48,,182,2,,void
96557,BLOCK,-1,,<empty>,46,,186,2,,void
96594,BLOCK,-1,,<empty>,54,,193,2,,void
96608,BLOCK,-1,,"{
      return false;
    }",80,,204,2,,void
96624,BLOCK,-1,,<empty>,55,,219,2,,void
96633,BLOCK,-1,,<empty>,21,,226,2,,void
96711,BLOCK,-1,,"{
  std::vector<char> frame;
  OpCode op_code = kOpCodeText;
  frame.push_back(kFinalBit | op_code);
  const size_t data_length = message.size();
  if (data_length <= kMaxSingleBytePayloadLength) {
    frame.push_back(static_cast<char>(data_length));
  } else if (data_length <= 0xFFFF) {
    frame.push_back(kTwoBytePayloadLengthField);
    frame.push_back((data_length & 0xFF00) >> 8);
    frame.push_back(data_length & 0xFF);
  } else {
    frame.push_back(kEightBytePayloadLengthField);
    char extended_payload_length[8];
    size_t remaining = data_length;
    // Fill the length into extended_payload_length in the network byte order.
    for (int i = 0; i < 8; ++i) {
      extended_payload_length[7 - i] = remaining & 0xFF;
      remaining >>= 8;
    }
    frame.insert(frame.end(), extended_payload_length,
                 extended_payload_length + 8);
    CHECK_EQ(0, remaining);
  }
  frame.insert(frame.end(), message.begin(), message.end());
  return frame;
}",80,,256,2,,void
96735,BLOCK,-1,,"{
    frame.push_back(static_cast<char>(data_length));
  }",51,,261,2,,void
96744,BLOCK,-1,,<empty>,10,,263,1,,void
96749,BLOCK,-1,,"{
    frame.push_back(kTwoBytePayloadLengthField);
    frame.push_back((data_length & 0xFF00) >> 8);
    frame.push_back(data_length & 0xFF);
  }",37,,263,2,,void
96772,BLOCK,-1,,"{
    frame.push_back(kEightBytePayloadLengthField);
    char extended_payload_length[8];
    size_t remaining = data_length;
    // Fill the length into extended_payload_length in the network byte order.
    for (int i = 0; i < 8; ++i) {
      extended_payload_length[7 - i] = remaining & 0xFF;
      remaining >>= 8;
    }
    frame.insert(frame.end(), extended_payload_length,
                 extended_payload_length + 8);
    CHECK_EQ(0, remaining);
  }",10,,267,1,,void
96784,BLOCK,-1,,<empty>,5,,272,1,,void
96794,BLOCK,4,,"{
      extended_payload_length[7 - i] = remaining & 0xFF;
      remaining >>= 8;
    }",33,,272,4,,void
96848,BLOCK,-1,,"{
  *bytes_consumed = 0;
  if (buffer.size() < 2)
    return FRAME_INCOMPLETE;

  auto it = buffer.begin();

  unsigned char first_byte = *it++;
  unsigned char second_byte = *it++;

  bool final = (first_byte & kFinalBit) != 0;
  bool reserved1 = (first_byte & kReserved1Bit) != 0;
  bool reserved2 = (first_byte & kReserved2Bit) != 0;
  bool reserved3 = (first_byte & kReserved3Bit) != 0;
  int op_code = first_byte & kOpCodeMask;
  bool masked = (second_byte & kMaskBit) != 0;
  *compressed = reserved1;
  if (!final || reserved2 || reserved3)
    return FRAME_ERROR;  // Only compression extension is supported.

  bool closed = false;
  switch (op_code) {
    case kOpCodeClose:
      closed = true;
      break;
    case kOpCodeText:
      break;
    case kOpCodeBinary:        // We don't support binary frames yet.
    case kOpCodeContinuation:  // We don't support binary frames yet.
    case kOpCodePing:          // We don't support binary frames yet.
    case kOpCodePong:          // ...",63,,288,6,,void
96860,BLOCK,-1,,<empty>,5,,291,2,,void
96939,BLOCK,-1,,<empty>,5,,306,2,,void
96948,BLOCK,-1,,"{
    case kOpCodeClose:
      closed = true;
      break;
    case kOpCodeText:
      break;
    case kOpCodeBinary:        // We don't support binary frames yet.
    case kOpCodeContinuation:  // We don't support binary frames yet.
    case kOpCodePing:          // We don't support binary frames yet.
    case kOpCodePong:          // We don't support binary frames yet.
    default:
      return FRAME_ERROR;
  }",20,,309,2,,void
96974,BLOCK,-1,,"{
    return FRAME_ERROR;
  }",32,,324,2,,void
96987,BLOCK,-1,,"{
    int extended_payload_length_size;
    if (payload_length64 == kTwoBytePayloadLengthField) {
      extended_payload_length_size = 2;
    } else if (payload_length64 == kEightBytePayloadLengthField) {
      extended_payload_length_size = 8;
    } else {
      return FRAME_ERROR;
    }
    if ((buffer.end() - it) < extended_payload_length_size)
      return FRAME_INCOMPLETE;
    payload_length64 = 0;
    for (int i = 0; i < extended_payload_length_size; ++i) {
      payload_length64 <<= 8;
      payload_length64 |= static_cast<unsigned char>(*it++);
    }
  }",55,,329,2,,void
96993,BLOCK,-1,,"{
      extended_payload_length_size = 2;
    }",57,,331,2,,void
96998,BLOCK,-1,,<empty>,12,,333,1,,void
97003,BLOCK,-1,,"{
      extended_payload_length_size = 8;
    }",66,,333,2,,void
97008,BLOCK,-1,,"{
      return FRAME_ERROR;
    }",12,,335,1,,void
97020,BLOCK,-1,,<empty>,7,,339,2,,void
97027,BLOCK,-1,,<empty>,5,,341,1,,void
97037,BLOCK,4,,"{
      payload_length64 <<= 8;
      payload_length64 |= static_cast<unsigned char>(*it++);
    }",60,,341,4,,void
97066,BLOCK,-1,,"{
    // WebSocket frame length too large.
    return FRAME_ERROR;
  }",64,,350,2,,void
97084,BLOCK,-1,,<empty>,5,,357,2,,void
97098,BLOCK,-1,,<empty>,3,,361,1,,void
97153,BLOCK,-1,,{ },31,,377,3,,void
97158,BLOCK,-1,,{ },62,,379,2,,void
97162,BLOCK,-1,,<empty>,35,,380,1,,void
97166,BLOCK,-1,,"{
    tcp_.reset();
    if (dispose_)
      delete this;
  }",25,,382,1,,void
97173,BLOCK,-1,,<empty>,7,,385,2,,void
97180,BLOCK,-1,,"{
    // 1. Parse.
    int processed = 0;
    do {
      processed = ParseWsFrames(*data);
      // 2. Fix the data size & length
      if (processed > 0) {
        remove_from_beginning(data, processed);
      }
    } while (processed > 0 && !data->empty());
  }",49,,388,2,,void
97186,BLOCK,-1,,"{
      processed = ParseWsFrames(*data);
      // 2. Fix the data size & length
      if (processed > 0) {
        remove_from_beginning(data, processed);
      }
    }",8,,391,1,,void
97196,BLOCK,-1,,"{
        remove_from_beginning(data, processed);
      }",26,,394,2,,void
97213,BLOCK,-1,,"{
    std::vector<char> output = encode_frame_hybi17(data);
    WriteRaw(output, WriteRequest::Cleanup);
  }",53,,400,2,,void
97227,BLOCK,-1,,"{
    if (tcp_) {
      dispose_ = true;
      SendClose();
    } else {
      delete this;
    }
  }",28,,406,1,,void
97230,BLOCK,-1,,"{
      dispose_ = true;
      SendClose();
    }",15,,407,2,,void
97236,BLOCK,-1,,"{
      delete this;
    }",12,,410,1,,void
97245,BLOCK,-1,,"{
    WriteRequest* wr = WriteRequest::from_write_req(req);
    WsHandler* handler = static_cast<WsHandler*>(wr->handler);
    delete wr;
    Callback cb = handler->OnCloseSent;
    (handler->*cb)();
  }",64,,418,3,,void
97277,BLOCK,-1,,"{
    OnCloseReceived = &WsHandler::OnEof;
  }",28,,426,1,,void
97287,BLOCK,-1,,"{
    WriteRaw(std::vector<char>(CLOSE_FRAME, CLOSE_FRAME + sizeof(CLOSE_FRAME)),
             OnCloseFrameWritten);
  }",20,,430,1,,void
97302,BLOCK,-1,,"{
    OnCloseSent = &WsHandler::OnEof;
    SendClose();
  }",29,,435,1,,void
97314,BLOCK,-1,,"{
    int bytes_consumed = 0;
    std::vector<char> output;
    bool compressed = false;

    ws_decode_result r =  decode_frame_hybi17(buffer,
                                              true /* client_frame */,
                                              &bytes_consumed, &output,
                                              &compressed);
    // Compressed frame means client is ignoring the headers and misbehaves
    if (compressed || r == FRAME_ERROR) {
      OnEof();
      bytes_consumed = 0;
    } else if (r == FRAME_CLOSE) {
      (this->*OnCloseReceived)();
      bytes_consumed = 0;
    } else if (r == FRAME_OK) {
      delegate()->OnWsFrame(output);
    }
    return bytes_consumed;
  }",54,,440,2,,void
97342,BLOCK,-1,,"{
      OnEof();
      bytes_consumed = 0;
    }",41,,450,2,,void
97348,BLOCK,-1,,<empty>,12,,453,1,,void
97353,BLOCK,-1,,"{
      (this->*OnCloseReceived)();
      bytes_consumed = 0;
    }",34,,453,2,,void
97362,BLOCK,-1,,<empty>,12,,456,1,,void
97367,BLOCK,-1,,"{
      delegate()->OnWsFrame(output);
    }",31,,456,2,,void
97387,BLOCK,-1,,{ },26,,474,6,,void
97399,BLOCK,-1,,"{
    llhttp_init(&parser_, HTTP_REQUEST, &parser_settings);
    llhttp_settings_init(&parser_settings);
    parser_settings.on_header_field = OnHeaderField;
    parser_settings.on_header_value = OnHeaderValue;
    parser_settings.on_message_complete = OnMessageComplete;
    parser_settings.on_url = OnPath;
  }",48,,487,3,,void
97433,BLOCK,-1,,"{
    char accept_string[ACCEPT_KEY_LENGTH];
    generate_accept_string(accept_key, &accept_string);
    const char accept_ws_prefix[] = ""HTTP/1.1 101 Switching Protocols\r\n""
                                    ""Upgrade: websocket\r\n""
                                    ""Connection: Upgrade\r\n""
                                    ""Sec-WebSocket-Accept: "";
    const char accept_ws_suffix[] = ""\r\n\r\n"";
    std::vector<char> reply(accept_ws_prefix,
                            accept_ws_prefix + sizeof(accept_ws_prefix) - 1);
    reply.insert(reply.end(), accept_string,
                 accept_string + sizeof(accept_string));
    reply.insert(reply.end(), accept_ws_suffix,
                 accept_ws_suffix + sizeof(accept_ws_suffix) - 1);
    if (WriteRaw(reply, WriteRequest::Cleanup) >= 0) {
      inspector_->SwitchProtocol(new WsHandler(inspector_, std::move(tcp_)));
    } else {
      tcp_.reset();
    }
  }",62,,496,2,,void
97492,BLOCK,-1,,"{
      inspector_->SwitchProtocol(new WsHandler(inspector_, std::move(tcp_)));
    }",54,,510,2,,void
97506,BLOCK,-1,,"{
      tcp_.reset();
    }",12,,512,1,,void
97514,BLOCK,-1,,"{
    const char HANDSHAKE_FAILED_RESPONSE[] =
        ""HTTP/1.0 400 Bad Request\r\n""
        ""Content-Type: text/html; charset=UTF-8\r\n\r\n""
        ""WebSockets request was expected\r\n"";
    WriteRaw(std::vector<char>(HANDSHAKE_FAILED_RESPONSE,
             HANDSHAKE_FAILED_RESPONSE + sizeof(HANDSHAKE_FAILED_RESPONSE) - 1),
             ThenCloseAndReportFailure);
  }",35,,517,1,,void
97535,BLOCK,-1,,"{
    tcp_.reset();
  }",25,,528,1,,void
97544,BLOCK,-1,,"{
    llhttp_errno_t err;
    err = llhttp_execute(&parser_, data->data(), data->size());

    if (err == HPE_PAUSED_UPGRADE) {
      err = HPE_OK;
      llhttp_resume_after_upgrade(&parser_);
    }
    data->clear();
    if (err != HPE_OK) {
      CancelHandshake();
    }
    // Event handling may delete *this
    std::vector<HttpEvent> events;
    std::swap(events, events_);
    for (const HttpEvent& event : events) {
      if (!IsAllowedHost(event.host) || !event.isGET) {
        CancelHandshake();
        return;
      } else if (!event.upgrade) {
        delegate()->OnHttpGet(event.host, event.path);
      } else if (event.ws_key.empty()) {
        CancelHandshake();
        return;
      } else {
        delegate()->OnSocketUpgrade(event.host, event.path, event.ws_key);
      }
    }
  }",49,,532,2,,void
97563,BLOCK,-1,,"{
      err = HPE_OK;
      llhttp_resume_after_upgrade(&parser_);
    }",36,,536,2,,void
97578,BLOCK,-1,,"{
      CancelHandshake();
    }",24,,541,2,,void
97590,BLOCK,-1,,"{
      if (!IsAllowedHost(event.host) || !event.isGET) {
        CancelHandshake();
        return;
      } else if (!event.upgrade) {
        delegate()->OnHttpGet(event.host, event.path);
      } else if (event.ws_key.empty()) {
        CancelHandshake();
        return;
      } else {
        delegate()->OnSocketUpgrade(event.host, event.path, event.ws_key);
      }
    }",43,,547,3,,void
97602,BLOCK,-1,,"{
        CancelHandshake();
        return;
      }",55,,548,2,,void
97606,BLOCK,-1,,<empty>,14,,551,1,,void
97612,BLOCK,-1,,"{
        delegate()->OnHttpGet(event.host, event.path);
      }",34,,551,2,,void
97624,BLOCK,-1,,<empty>,14,,553,1,,void
97632,BLOCK,-1,,"{
        CancelHandshake();
        return;
      }",40,,553,2,,void
97636,BLOCK,-1,,"{
        delegate()->OnSocketUpgrade(event.host, event.path, event.ws_key);
      }",14,,556,1,,void
97654,BLOCK,-1,,"{
    WriteRaw(data, WriteRequest::Cleanup);
  }",53,,562,2,,void
97663,BLOCK,-1,,"{
    delete this;
  }",28,,567,1,,void
97671,BLOCK,-1,,"{
    ProtocolHandler* handler = WriteRequest::from_write_req(req)->handler;
    WriteRequest::Cleanup(req, status);
    handler->inspector()->SwitchProtocol(nullptr);
  }",70,,572,3,,void
97702,BLOCK,-1,,"{
    HttpHandler* handler = From(parser);
    handler->parsing_value_ = true;
    handler->headers_[handler->current_header_].append(at, length);
    return 0;
  }",77,,578,4,,void
97733,BLOCK,-1,,"{
    HttpHandler* handler = From(parser);
    if (handler->parsing_value_) {
      handler->parsing_value_ = false;
      handler->current_header_.clear();
    }
    handler->current_header_.append(at, length);
    return 0;
  }",77,,585,4,,void
97743,BLOCK,-1,,"{
      handler->parsing_value_ = false;
      handler->current_header_.clear();
    }",34,,587,2,,void
97771,BLOCK,-1,,"{
    HttpHandler* handler = From(parser);
    handler->path_.append(at, length);
    return 0;
  }",70,,595,4,,void
97791,BLOCK,-1,,"{
    return node::ContainerOf(&HttpHandler::parser_, parser);
  }",46,,601,2,,void
97806,BLOCK,-1,,"{
    // Event needs to be fired after the parser is done.
    HttpHandler* handler = From(parser);
    handler->events_.emplace_back(handler->path_,
                                  parser->upgrade,
                                  parser->method == HTTP_GET,
                                  handler->HeaderValue(""Sec-WebSocket-Key""),
                                  handler->HeaderValue(""Host""));
    handler->path_ = """";
    handler->parsing_value_ = false;
    handler->headers_.clear();
    handler->current_header_ = """";
    return 0;
  }",50,,605,2,,void
97866,BLOCK,-1,,"{
    bool header_found = false;
    std::string value;
    for (const auto& header_value : headers_) {
      if (node::StringEqualNoCaseN(header_value.first.data(), header.data(),
                                   header.length())) {
        if (header_found)
          return """";
        value = header_value.second;
        header_found = true;
      }
    }
    return value;
  }",60,,620,2,,void
97875,BLOCK,-1,,"{
      if (node::StringEqualNoCaseN(header_value.first.data(), header.data(),
                                   header.length())) {
        if (header_found)
          return """";
        value = header_value.second;
        header_found = true;
      }
    }",47,,623,3,,void
97895,BLOCK,-1,,"{
        if (header_found)
          return """";
        value = header_value.second;
        header_found = true;
      }",54,,625,2,,void
97898,BLOCK,-1,,<empty>,11,,627,2,,void
97915,BLOCK,-1,,"{
    std::string host = TrimPort(host_with_port);
    return host.empty() || IsIPAddress(host)
           || node::StringEqualNoCase(host.data(), ""localhost"");
  }",63,,635,2,,void
97951,BLOCK,-1,,"{
  CHECK_NOT_NULL(tcp_);
  tcp_->SetHandler(this);
}",80,,655,3,,void
97964,BLOCK,-1,,"{
  return tcp_->WriteRaw(buffer, write_cb);
}",53,,661,3,,void
97975,BLOCK,-1,,"{
  return tcp_->delegate();
}",56,,665,1,,void
97984,BLOCK,-1,,"{
  char ip[INET6_ADDRSTRLEN];
  sockaddr_storage addr;
  int len = sizeof(addr);
  int err = uv_tcp_getsockname(tcp_->tcp(),
                               reinterpret_cast<struct sockaddr*>(&addr),
                               &len);
  if (err != 0)
    return """";
  if (addr.ss_family == AF_INET6) {
    const sockaddr_in6* v6 = reinterpret_cast<const sockaddr_in6*>(&addr);
    err = uv_ip6_name(v6, ip, sizeof(ip));
  } else {
    const sockaddr_in* v4 = reinterpret_cast<const sockaddr_in*>(&addr);
    err = uv_ip4_name(v4, ip, sizeof(ip));
  }
  if (err != 0)
    return """";
  return ip;
}",46,,669,1,,void
98010,BLOCK,-1,,<empty>,5,,677,2,,void
98019,BLOCK,-1,,"{
    const sockaddr_in6* v6 = reinterpret_cast<const sockaddr_in6*>(&addr);
    err = uv_ip6_name(v6, ip, sizeof(ip));
  }",35,,678,2,,void
98035,BLOCK,-1,,"{
    const sockaddr_in* v4 = reinterpret_cast<const sockaddr_in*>(&addr);
    err = uv_ip4_name(v4, ip, sizeof(ip));
  }",10,,681,1,,void
98054,BLOCK,-1,,<empty>,5,,686,2,,void
98063,BLOCK,-1,,{ },42,,694,2,,void
98069,BLOCK,-1,,"{
  TcpHolder* result = new TcpHolder(std::move(delegate));
  uv_stream_t* tcp = reinterpret_cast<uv_stream_t*>(&result->tcp_);
  int err = uv_tcp_init(server->loop, &result->tcp_);
  if (err == 0) {
    err = uv_accept(server, tcp);
  }
  if (err == 0) {
    err = uv_read_start(tcp, allocate_buffer, OnDataReceivedCb);
  }
  if (err == 0) {
    return TcpHolder::Pointer(result);
  } else {
    delete result;
    return nullptr;
  }
}",48,,699,3,,void
98104,BLOCK,-1,,"{
    err = uv_accept(server, tcp);
  }",17,,703,2,,void
98114,BLOCK,-1,,"{
    err = uv_read_start(tcp, allocate_buffer, OnDataReceivedCb);
  }",17,,706,2,,void
98125,BLOCK,-1,,"{
    return TcpHolder::Pointer(result);
  }",17,,709,2,,void
98133,BLOCK,-1,,"{
    delete result;
    return nullptr;
  }",10,,711,1,,void
98142,BLOCK,-1,,"{
  handler_ = handler;
}",54,,717,2,,void
98151,BLOCK,-1,,"{
#if DUMP_WRITES
  printf(""%s (%ld bytes):\n"", __FUNCTION__, buffer.size());
  dump_hex(buffer.data(), buffer.size());
  printf(""\n"");
#endif

  // Freed in write_request_cleanup
  WriteRequest* wr = new WriteRequest(handler_, buffer);
  uv_stream_t* stream = reinterpret_cast<uv_stream_t*>(&tcp_);
  int err = uv_write(&wr->req, stream, &wr->buf, 1, write_cb);
  if (err < 0)
    delete wr;
  return err < 0;
}",80,,721,3,,void
98185,BLOCK,-1,,<empty>,5,,733,2,,void
98195,BLOCK,-1,,"{
  return delegate_.get();
}",50,,737,1,,void
98205,BLOCK,-1,,"{
  delete From(handle);
}",47,,742,2,,void
98215,BLOCK,-1,,"{
#if DUMP_READS
  if (nread >= 0) {
    printf(""%s (%ld bytes)\n"", __FUNCTION__, nread);
    dump_hex(buf->base, nread);
  } else {
    printf(""[%s:%d] %s\n"", __FUNCTION__, __LINE__, uv_err_name(nread));
  }
#endif
  TcpHolder* holder = From(tcp);
  holder->ReclaimUvBuf(buf, nread);
  if (nread < 0 || nread == UV_EOF) {
    holder->handler_->OnEof();
  } else {
    holder->handler_->OnData(&holder->buffer);
  }
}",55,,747,4,,void
98235,BLOCK,-1,,"{
    holder->handler_->OnEof();
  }",37,,758,2,,void
98243,BLOCK,-1,,"{
    holder->handler_->OnData(&holder->buffer);
  }",10,,760,1,,void
98258,BLOCK,-1,,"{
  uv_handle_t* handle = reinterpret_cast<uv_handle_t*>(&holder->tcp_);
  uv_close(handle, OnClosed);
}",57,,766,2,,void
98276,BLOCK,-1,,"{
  if (read > 0) {
    buffer.insert(buffer.end(), buf->base, buf->base + read);
  }
  delete[] buf->base;
}",65,,771,3,,void
98281,BLOCK,-1,,"{
    buffer.insert(buffer.end(), buf->base, buf->base + read);
  }",17,,772,2,,void
98305,BLOCK,-1,,<empty>,,,,1,,<empty>
98310,BLOCK,-1,,"{
  handler->Shutdown();
}",58,,781,2,,void
98320,BLOCK,-1,,"{
  auto tcp = TcpHolder::Accept(server, std::move(delegate));
  if (tcp) {
    InspectorSocket* inspector = new InspectorSocket();
    inspector->SwitchProtocol(new HttpHandler(inspector, std::move(tcp)));
    return InspectorSocket::Pointer(inspector);
  } else {
    return InspectorSocket::Pointer(nullptr);
  }
}",76,,787,3,,void
98336,BLOCK,-1,,"{
    InspectorSocket* inspector = new InspectorSocket();
    inspector->SwitchProtocol(new HttpHandler(inspector, std::move(tcp)));
    return InspectorSocket::Pointer(inspector);
  }",12,,789,2,,void
98361,BLOCK,-1,,"{
    return InspectorSocket::Pointer(nullptr);
  }",10,,793,1,,void
98372,BLOCK,-1,,"{
  protocol_handler_->AcceptUpgrade(ws_key);
}",64,,798,2,,void
98381,BLOCK,-1,,"{
  protocol_handler_->CancelHandshake();
}",41,,802,1,,void
98389,BLOCK,-1,,"{
  return protocol_handler_->GetHost();
}",40,,806,1,,void
98399,BLOCK,-1,,"{
  protocol_handler_.reset(std::move(handler));
}",64,,810,2,,void
98414,BLOCK,-1,,"{
  protocol_handler_->Write(std::vector<char>(data, data + len));
}",59,,814,3,,void
98441,BLOCK,-1,,<empty>,1,,1,1,,ANY
98466,BLOCK,-1,,<empty>,1,,1,1,,ANY
98474,BLOCK,-1,,<empty>,,,,5,,<empty>
98484,BLOCK,-1,,"{
  for (char& c : *string) {
    c = (c == '\""' || c == '\\') ? '_' : c;
  }
}",34,,27,2,,void
98489,BLOCK,-1,,"{
    c = (c == '\""' || c == '\\') ? '_' : c;
  }",27,,28,3,,void
98507,BLOCK,-1,,"{
  // Host is valid (socket was bound) so colon means it's a v6 IP address
  bool v6 = host.find(':') != std::string::npos;
  std::ostringstream url;
  if (v6) {
    url << '[';
  }
  url << host;
  if (v6) {
    url << ']';
  }
  url << ':' << port;
  return url.str();
}",63,,33,3,,void
98525,BLOCK,-1,,"{
    url << '[';
  }",11,,37,2,,void
98534,BLOCK,-1,,"{
    url << ']';
  }",11,,41,2,,void
98554,BLOCK,-1,,"{
  std::ostringstream url;
  if (include_protocol)
    url << ""ws://"";
  url << host << '/' << target_id;
  return url.str();
}",50,,50,4,,void
98558,BLOCK,-1,,<empty>,5,,53,2,,void
98578,BLOCK,-1,,"{
  bool first = true;
  std::ostringstream json;
  json << ""{\n"";
  for (const auto& name_value : object) {
    if (!first)
      json << "",\n"";
    first = false;
    json << ""  \"""" << name_value.first << ""\"": \"""";
    json << name_value.second << ""\"""";
  }
  json << ""\n} "";
  return json.str();
}",75,,58,2,,void
98590,BLOCK,-1,,"{
    if (!first)
      json << "",\n"";
    first = false;
    json << ""  \"""" << name_value.first << ""\"": \"""";
    json << name_value.second << ""\"""";
  }",41,,62,3,,void
98594,BLOCK,-1,,<empty>,7,,64,2,,void
98629,BLOCK,-1,,"{
  bool first = true;
  std::ostringstream json;
  json << ""[ "";
  for (const auto& object : array) {
    if (!first)
      json << "", "";
    first = false;
    json << MapToString(object);
  }
  json << ""]\n\n"";
  return json.str();
}",67,,74,2,,void
98641,BLOCK,-1,,"{
    if (!first)
      json << "", "";
    first = false;
    json << MapToString(object);
  }",36,,78,3,,void
98645,BLOCK,-1,,<empty>,7,,80,2,,void
98669,BLOCK,-1,,"{
  size_t len = strlen(expected);
  if (StringEqualNoCaseN(path, expected, len)) {
    if (path[len] == '/') return path + len + 1;
    if (path[len] == '\0') return path + len;
  }
  return nullptr;
}",70,,88,3,,void
98680,BLOCK,-1,,"{
    if (path[len] == '/') return path + len + 1;
    if (path[len] == '\0') return path + len;
  }",48,,90,2,,void
98687,BLOCK,-1,,<empty>,27,,91,2,,void
98700,BLOCK,-1,,<empty>,28,,92,2,,void
98713,BLOCK,-1,,"{
  const char HEADERS[] = ""HTTP/1.0 %d OK\r\n""
                         ""Content-Type: application/json; charset=UTF-8\r\n""
                         ""Cache-Control: no-cache\r\n""
                         ""Content-Length: %zu\r\n""
                         ""\r\n"";
  char header[sizeof(HEADERS) + 20];
  int header_len = snprintf(header,
                            sizeof(header),
                            HEADERS,
                            code,
                            response.size());
  socket->Write(header, header_len);
  socket->Write(response.data(), response.size());
}",33,,99,4,,void
98754,BLOCK,-1,,"{
  std::map<std::string, std::string> response;
  response[""Browser""] = ""node.js/"" NODE_VERSION;
  response[""Protocol-Version""] = ""1.1"";
  SendHttpResponse(socket, MapToString(response), 200);
}",51,,115,2,,void
98787,BLOCK,-1,,"{
  SendHttpResponse(socket, """", 404);
}",48,,122,2,,void
98796,BLOCK,-1,,"{
  z_stream strm;
  strm.zalloc = Z_NULL;
  strm.zfree = Z_NULL;
  strm.opaque = Z_NULL;
  CHECK_EQ(Z_OK, inflateInit(&strm));
  static const size_t kDecompressedSize =
      PROTOCOL_JSON[0] * 0x10000u +
      PROTOCOL_JSON[1] * 0x100u +
      PROTOCOL_JSON[2];
  strm.next_in = const_cast<uint8_t*>(PROTOCOL_JSON + 3);
  strm.avail_in = sizeof(PROTOCOL_JSON) - 3;
  std::string data(kDecompressedSize, '\0');
  strm.next_out = reinterpret_cast<Byte*>(data.data());
  strm.avail_out = data.size();
  CHECK_EQ(Z_STREAM_END, inflate(&strm, Z_FINISH));
  CHECK_EQ(0, strm.avail_out);
  CHECK_EQ(Z_OK, inflateEnd(&strm));
  SendHttpResponse(socket, data, 200);
}",48,,126,2,,void
98902,BLOCK,-1,,"{
  return FormatAddress(FormatHostPort(host, port), target_id, include_protocol);
}",52,,150,5,,void
98917,BLOCK,-1,,<empty>,,,,4,,<empty>
98921,BLOCK,-1,,"{
    ws_socket_.reset();
  }",16,,157,1,,void
98930,BLOCK,-1,,<empty>,,,,2,,<empty>
98935,BLOCK,-1,,"{
    ws_socket_ = std::move(ws_socket);
  }",48,,161,2,,void
98946,BLOCK,-1,,{ return id_; },18,,164,1,,void
98952,BLOCK,-1,,"{
    return server_port_;
  }",21,,165,1,,void
98958,BLOCK,-1,,"{
    return ws_socket_.get();
  }",32,,168,1,,void
98968,BLOCK,-1,,"{
    ws_socket_->AcceptUpgrade(ws_key);
  }",42,,171,2,,void
98977,BLOCK,-1,,"{
    ws_socket_->CancelHandshake();
  }",18,,174,1,,void
98988,BLOCK,-1,,{ },57,,181,3,,void
98992,BLOCK,-1,,"{
      server_->SessionTerminated(session_id_);
    }",26,,182,1,,void
99003,BLOCK,-1,,<empty>,,,,3,,<empty>
99010,BLOCK,-1,,<empty>,,,,4,,<empty>
99015,BLOCK,-1,,<empty>,,,,2,,<empty>
99019,BLOCK,-1,,"{
      return server_->Session(session_id_);
    }",30,,191,1,,void
99036,BLOCK,-1,,<empty>,68,,208,2,,void
99042,BLOCK,-1,,<empty>,,,,3,,<empty>
99046,BLOCK,-1,,"{
    uv_close(reinterpret_cast<uv_handle_t*>(&tcp_socket_), FreeOnCloseCallback);
  }",16,,210,1,,void
99056,BLOCK,-1,,{ return port_; },20,,213,1,,void
99063,BLOCK,-1,,"{
    return node::ContainerOf(&ServerSocket::tcp_socket_,
                             reinterpret_cast<uv_tcp_t*>(socket));
  }",56,,217,2,,void
99081,BLOCK,-1,,<empty>,,,,3,,<empty>
99086,BLOCK,-1,,"{
    delete FromTcpSocket(tcp_socket_);
  }",61,,222,2,,void
99093,BLOCK,-1,,<empty>,,,,1,,<empty>
99097,BLOCK,-1,,<empty>,,,,1,,<empty>
99104,BLOCK,-1,,<empty>,,,,1,,<empty>
99118,BLOCK,-1,,"{
  if (!publish_uid_stderr || out == nullptr) {
    return;
  }
  for (const auto& server_socket : server_sockets) {
    for (const std::string& id : ids) {
      fprintf(out, ""Debugger %s on %s\n"",
              verb,
              FormatWsAddress(host, server_socket->port(), id, true).c_str());
    }
  }
  fprintf(out, ""For help, see: %s\n"",
          ""https://nodejs.org/en/docs/inspector"");
  fflush(out);
}",16,,239,7,,void
99126,BLOCK,-1,,"{
    return;
  }",46,,240,2,,void
99131,BLOCK,-1,,"{
    for (const std::string& id : ids) {
      fprintf(out, ""Debugger %s on %s\n"",
              verb,
              FormatWsAddress(host, server_socket->port(), id, true).c_str());
    }
  }",52,,243,3,,void
99135,BLOCK,-1,,"{
      fprintf(out, ""Debugger %s on %s\n"",
              verb,
              FormatWsAddress(host, server_socket->port(), id, true).c_str());
    }",39,,244,3,,void
99166,BLOCK,-1,,"{
  delegate_->AssignServer(this);
  state_ = ServerState::kNew;
}",17,,265,7,,void
99180,BLOCK,-1,,<empty>,,,,1,,<empty>
99185,BLOCK,-1,,"{
  auto it = connected_sessions_.find(session_id);
  return it == connected_sessions_.end() ? nullptr : it->second.second.get();
}",63,,272,2,,void
99217,BLOCK,-1,,"{
  SocketSession* session = Session(session_id);
  if (!TargetExists(id)) {
    session->Decline();
    return;
  }
  connected_sessions_[session_id].first = id;
  session->Accept(ws_key);
  delegate_->StartSession(session_id, id);
}",71,,279,4,,void
99227,BLOCK,-1,,"{
    session->Decline();
    return;
  }",26,,281,2,,void
99255,BLOCK,-1,,"{
  if (Session(session_id) == nullptr) {
    return;
  }
  bool was_attached = connected_sessions_[session_id].first != """";
  if (was_attached) {
    delegate_->EndSession(session_id);
  }
  connected_sessions_.erase(session_id);
  if (connected_sessions_.empty()) {
    if (was_attached && state_ == ServerState::kRunning
        && !server_sockets_.empty()) {
      PrintDebuggerReadyMessage(host_,
                                server_sockets_,
                                delegate_->GetTargetIds(),
                                ""ending"",
                                inspect_publish_uid_.console,
                                out_);
    }
    if (state_ == ServerState::kStopped) {
      delegate_.reset();
    }
  }
}",63,,290,2,,void
99261,BLOCK,-1,,"{
    return;
  }",39,,291,2,,void
99275,BLOCK,-1,,"{
    delegate_->EndSession(session_id);
  }",21,,295,2,,void
99291,BLOCK,-1,,"{
    if (was_attached && state_ == ServerState::kRunning
        && !server_sockets_.empty()) {
      PrintDebuggerReadyMessage(host_,
                                server_sockets_,
                                delegate_->GetTargetIds(),
                                ""ending"",
                                inspect_publish_uid_.console,
                                out_);
    }
    if (state_ == ServerState::kStopped) {
      delegate_.reset();
    }
  }",36,,299,2,,void
99306,BLOCK,-1,,"{
      PrintDebuggerReadyMessage(host_,
                                server_sockets_,
                                delegate_->GetTargetIds(),
                                ""ending"",
                                inspect_publish_uid_.console,
                                out_);
    }",38,,301,2,,void
99325,BLOCK,-1,,"{
      delegate_.reset();
    }",42,,309,2,,void
99336,BLOCK,-1,,"{
  SocketSession* session = Session(session_id);
  InspectorSocket* socket = session->ws_socket();
  if (!inspect_publish_uid_.http) {
    SendHttpNotFound(socket);
    return true;
  }
  const char* command = MatchPathSegment(path.c_str(), ""/json"");
  if (command == nullptr)
    return false;

  if (MatchPathSegment(command, ""list"") || command[0] == '\0') {
    SendListResponse(socket, host, session);
    return true;
  } else if (MatchPathSegment(command, ""protocol"")) {
    SendProtocolJson(socket);
    return true;
  } else if (MatchPathSegment(command, ""version"")) {
    SendVersionResponse(socket);
    return true;
  }
  return false;
}",71,,317,4,,void
99354,BLOCK,-1,,"{
    SendHttpNotFound(socket);
    return true;
  }",35,,320,2,,void
99372,BLOCK,-1,,<empty>,5,,326,2,,void
99385,BLOCK,-1,,"{
    SendListResponse(socket, host, session);
    return true;
  }",64,,328,2,,void
99393,BLOCK,-1,,<empty>,10,,331,1,,void
99398,BLOCK,-1,,"{
    SendProtocolJson(socket);
    return true;
  }",53,,331,2,,void
99404,BLOCK,-1,,<empty>,10,,334,1,,void
99409,BLOCK,-1,,"{
    SendVersionResponse(socket);
    return true;
  }",52,,334,2,,void
99422,BLOCK,-1,,"{
  std::vector<std::map<std::string, std::string>> response;
  for (const std::string& id : delegate_->GetTargetIds()) {
    response.push_back(std::map<std::string, std::string>());
    std::map<std::string, std::string>& target_map = response.back();
    target_map[""description""] = ""node.js instance"";
    target_map[""faviconUrl""] =
                        ""https://nodejs.org/static/images/favicons/favicon.ico"";
    target_map[""id""] = id;
    target_map[""title""] = delegate_->GetTargetTitle(id);
    Escape(&target_map[""title""]);
    target_map[""type""] = ""node"";
    // This attribute value is a ""best effort"" URL that is passed as a JSON
    // string. It is not guaranteed to resolve to a valid resource.
    target_map[""url""] = delegate_->GetTargetUrl(id);
    Escape(&target_map[""url""]);

    std::string detected_host = host;
    if (detected_host.empty()) {
      detected_host = FormatHostPort(socket->GetHost(),
                                     session->server_port());
    }
   ...",70,,343,4,,void
99430,BLOCK,-1,,"{
    response.push_back(std::map<std::string, std::string>());
    std::map<std::string, std::string>& target_map = response.back();
    target_map[""description""] = ""node.js instance"";
    target_map[""faviconUrl""] =
                        ""https://nodejs.org/static/images/favicons/favicon.ico"";
    target_map[""id""] = id;
    target_map[""title""] = delegate_->GetTargetTitle(id);
    Escape(&target_map[""title""]);
    target_map[""type""] = ""node"";
    // This attribute value is a ""best effort"" URL that is passed as a JSON
    // string. It is not guaranteed to resolve to a valid resource.
    target_map[""url""] = delegate_->GetTargetUrl(id);
    Escape(&target_map[""url""]);

    std::string detected_host = host;
    if (detected_host.empty()) {
      detected_host = FormatHostPort(socket->GetHost(),
                                     session->server_port());
    }
    std::string formatted_address = FormatAddress(detected_host, id, false);
    target_map[""devtoolsFrontendUrl""] = GetFro...",59,,345,3,,void
99511,BLOCK,-1,,"{
      detected_host = FormatHostPort(socket->GetHost(),
                                     session->server_port());
    }",32,,361,2,,void
99562,BLOCK,-1,,"{
  std::ostringstream frontend_url;
  frontend_url << ""devtools://devtools/bundled/"";
  frontend_url << (is_compat ? ""inspector"" : ""js_app"");
  frontend_url << "".html?experiments=true&v8only=true&ws="";
  frontend_url << formatted_address;
  return frontend_url.str();
}",43,,377,3,,void
99587,BLOCK,-1,,"{
  CHECK_NOT_NULL(delegate_);
  CHECK_EQ(state_, ServerState::kNew);
  std::unique_ptr<SocketServerDelegate> delegate_holder;
  // We will return it if startup is successful
  delegate_.swap(delegate_holder);
  struct addrinfo hints;
  memset(&hints, 0, sizeof(hints));
  hints.ai_flags = AI_NUMERICSERV;
  hints.ai_socktype = SOCK_STREAM;
  uv_getaddrinfo_t req;
  const std::string port_string = std::to_string(port_);
  int err = uv_getaddrinfo(loop_, &req, nullptr, host_.c_str(),
                           port_string.c_str(), &hints);
  if (err < 0) {
    if (out_ != nullptr) {
      fprintf(out_, ""Unable to resolve \""%s\"": %s\n"", host_.c_str(),
              uv_strerror(err));
    }
    return false;
  }
  for (addrinfo* address = req.addrinfo; address != nullptr;
       address = address->ai_next) {
    auto server_socket = ServerSocketPtr(new ServerSocket(this));
    err = server_socket->Listen(address->ai_addr, loop_);
    if (err == 0)
      server_sockets_.push_back(std::mov...",37,,386,1,,void
99654,BLOCK,-1,,"{
    if (out_ != nullptr) {
      fprintf(out_, ""Unable to resolve \""%s\"": %s\n"", host_.c_str(),
              uv_strerror(err));
    }
    return false;
  }",16,,400,2,,void
99659,BLOCK,-1,,"{
      fprintf(out_, ""Unable to resolve \""%s\"": %s\n"", host_.c_str(),
              uv_strerror(err));
    }",26,,401,2,,void
99672,BLOCK,-1,,<empty>,3,,407,1,,void
99687,BLOCK,4,,"{
    auto server_socket = ServerSocketPtr(new ServerSocket(this));
    err = server_socket->Listen(address->ai_addr, loop_);
    if (err == 0)
      server_sockets_.push_back(std::move(server_socket));
  }",36,,408,4,,void
99709,BLOCK,-1,,<empty>,7,,412,2,,void
99728,BLOCK,-1,,"{
    if (out_ != nullptr) {
      fprintf(out_, ""Starting inspector on %s:%d failed: %s\n"",
              host_.c_str(), port_, uv_strerror(err));
      fflush(out_);
    }
    return false;
  }",32,,418,2,,void
99733,BLOCK,-1,,"{
      fprintf(out_, ""Starting inspector on %s:%d failed: %s\n"",
              host_.c_str(), port_, uv_strerror(err));
      fflush(out_);
    }",26,,419,2,,void
99774,BLOCK,-1,,"{
  if (state_ == ServerState::kStopped)
    return;
  CHECK_EQ(state_, ServerState::kRunning);
  state_ = ServerState::kStopped;
  server_sockets_.clear();
  if (done())
    delegate_.reset();
}",36,,437,1,,void
99781,BLOCK,-1,,<empty>,5,,439,2,,void
99799,BLOCK,-1,,<empty>,5,,444,2,,void
99807,BLOCK,-1,,"{
  for (const auto& key_value : connected_sessions_)
    key_value.second.second->Close();
}",52,,447,1,,void
99823,BLOCK,-1,,"{
  const std::vector<std::string>& target_ids = delegate_->GetTargetIds();
  const auto& found = std::find(target_ids.begin(), target_ids.end(), id);
  return found != target_ids.end();
}",65,,452,2,,void
99857,BLOCK,-1,,"{
  if (!server_sockets_.empty()) {
    return server_sockets_[0]->port();
  }
  return port_;
}",41,,458,1,,void
99864,BLOCK,-1,,"{
    return server_sockets_[0]->port();
  }",33,,459,2,,void
99879,BLOCK,-1,,"{
  std::unique_ptr<SocketSession> session(
      new SocketSession(this, next_session_id_++, server_port));

  InspectorSocket::DelegatePointer delegate =
      InspectorSocket::DelegatePointer(
          new SocketSession::Delegate(this, session->id()));

  InspectorSocket::Pointer inspector =
      InspectorSocket::Accept(server_socket, std::move(delegate));
  if (inspector) {
    session->Own(std::move(inspector));
    connected_sessions_[session->id()].second = std::move(session);
  }
}",64,,466,3,,void
99922,BLOCK,-1,,"{
    session->Own(std::move(inspector));
    connected_sessions_[session->id()].second = std::move(session);
  }",18,,476,2,,void
99951,BLOCK,-1,,"{
  SocketSession* session = Session(session_id);
  if (session != nullptr) {
    session->Send(message);
  }
}",78,,482,3,,void
99961,BLOCK,-1,,"{
    session->Send(message);
  }",27,,484,2,,void
99971,BLOCK,-1,,"{
  server->Close();
}",69,,489,2,,void
99982,BLOCK,-1,,<empty>,42,,496,4,,void
99987,BLOCK,-1,,"{
  ws_socket_->Write(message.data(), message.length());
}",54,,498,2,,void
100005,BLOCK,-1,,"{
  if (!server_->HandleGetRequest(session_id_, host, path))
    Session()->ws_socket()->CancelHandshake();
}",66,,503,3,,void
100015,BLOCK,-1,,<empty>,5,,505,2,,void
100029,BLOCK,-1,,"{
  std::string id = path.empty() ? path : path.substr(1);
  server_->SessionStarted(session_id_, id, ws_key);
}",74,,510,4,,void
100055,BLOCK,-1,,"{
  server_->MessageReceived(session_id_,
                           std::string(data.data(), data.size()));
}",72,,515,2,,void
100076,BLOCK,-1,,"{
  sockaddr_storage addr;
  int len = sizeof(addr);
  int err = uv_tcp_getsockname(&tcp_socket_,
                               reinterpret_cast<struct sockaddr*>(&addr), &len);
  if (err != 0)
    return err;
  int port;
  if (addr.ss_family == AF_INET6)
    port = reinterpret_cast<const sockaddr_in6*>(&addr)->sin6_port;
  else
    port = reinterpret_cast<const sockaddr_in*>(&addr)->sin_port;
  port_ = ntohs(port);
  return err;
}",32,,521,1,,void
100099,BLOCK,-1,,<empty>,5,,527,2,,void
100109,BLOCK,-1,,<empty>,5,,530,2,,void
100119,BLOCK,-1,,<empty>,5,,532,1,,void
100139,BLOCK,-1,,"{
  uv_tcp_t* server = &tcp_socket_;
  CHECK_EQ(0, uv_tcp_init(loop, server));
  int err = uv_tcp_bind(server, addr, 0);
  if (err == 0) {
    // 511 is the value used by a 'net' module by default
    err = uv_listen(reinterpret_cast<uv_stream_t*>(server), 511,
                    ServerSocket::SocketConnectedCallback);
  }
  if (err == 0) {
    err = DetectPort();
  }
  return err;
}",59,,537,3,,void
100161,BLOCK,-1,,"{
    // 511 is the value used by a 'net' module by default
    err = uv_listen(reinterpret_cast<uv_stream_t*>(server), 511,
                    ServerSocket::SocketConnectedCallback);
  }",17,,541,2,,void
100176,BLOCK,-1,,"{
    err = DetectPort();
  }",17,,546,2,,void
100187,BLOCK,-1,,"{
  if (status == 0) {
    ServerSocket* server_socket = ServerSocket::FromTcpSocket(tcp_socket);
    // Memory is freed when the socket closes.
    server_socket->server_->Accept(server_socket->port_, tcp_socket);
  }
}",56,,554,3,,void
100192,BLOCK,-1,,"{
    ServerSocket* server_socket = ServerSocket::FromTcpSocket(tcp_socket);
    // Memory is freed when the socket closes.
    server_socket->server_->Accept(server_socket->port_, tcp_socket);
  }",20,,555,2,,void
100229,BLOCK,-1,,<empty>,1,,1,1,,ANY
100240,BLOCK,-1,,<empty>,1,,1,1,,ANY
100244,BLOCK,-1,,<empty>,,,,3,,<empty>
100250,BLOCK,-1,,<empty>,,,,3,,<empty>
100256,BLOCK,-1,,<empty>,,,,3,,<empty>
100262,BLOCK,-1,,<empty>,,,,3,,<empty>
100269,BLOCK,-1,,<empty>,,,,4,,<empty>
100275,BLOCK,-1,,<empty>,,,,3,,<empty>
100281,BLOCK,-1,,<empty>,,,,3,,<empty>
100288,BLOCK,-1,,<empty>,,,,4,,<empty>
100295,BLOCK,-1,,<empty>,,,,4,,<empty>
100302,BLOCK,-1,,<empty>,,,,4,,<empty>
100309,BLOCK,-1,,<empty>,,,,4,,<empty>
100316,BLOCK,-1,,<empty>,,,,4,,<empty>
100324,BLOCK,-1,,<empty>,,,,5,,<empty>
100332,BLOCK,-1,,<empty>,,,,5,,<empty>
100340,BLOCK,-1,,<empty>,,,,5,,<empty>
100347,BLOCK,-1,,<empty>,,,,4,,<empty>
100357,BLOCK,-1,,<empty>,,,,7,,<empty>
100365,BLOCK,-1,,<empty>,,,,5,,<empty>
100373,BLOCK,-1,,<empty>,,,,5,,<empty>
100381,BLOCK,-1,,<empty>,,,,5,,<empty>
100388,BLOCK,-1,,<empty>,,,,4,,<empty>
100395,BLOCK,-1,,<empty>,,,,4,,<empty>
100402,BLOCK,-1,,<empty>,,,,4,,<empty>
100409,BLOCK,-1,,<empty>,,,,4,,<empty>
100416,BLOCK,-1,,<empty>,,,,4,,<empty>
100423,BLOCK,-1,,<empty>,,,,4,,<empty>
100432,BLOCK,-1,,<empty>,,,,6,,<empty>
100441,BLOCK,-1,,<empty>,,,,6,,<empty>
100450,BLOCK,-1,,<empty>,,,,6,,<empty>
100457,BLOCK,-1,,<empty>,,,,4,,<empty>
100464,BLOCK,-1,,<empty>,,,,4,,<empty>
100471,BLOCK,-1,,<empty>,,,,4,,<empty>
100478,BLOCK,-1,,<empty>,,,,4,,<empty>
100485,BLOCK,-1,,<empty>,,,,4,,<empty>
100492,BLOCK,-1,,<empty>,,,,4,,<empty>
100500,BLOCK,-1,,<empty>,,,,5,,<empty>
100508,BLOCK,-1,,<empty>,,,,5,,<empty>
100516,BLOCK,-1,,<empty>,,,,5,,<empty>
100524,BLOCK,-1,,<empty>,,,,5,,<empty>
100532,BLOCK,-1,,<empty>,,,,5,,<empty>
100540,BLOCK,-1,,<empty>,,,,5,,<empty>
100548,BLOCK,-1,,<empty>,,,,5,,<empty>
100556,BLOCK,-1,,<empty>,,,,5,,<empty>
100564,BLOCK,-1,,<empty>,,,,5,,<empty>
100572,BLOCK,-1,,<empty>,,,,5,,<empty>
100580,BLOCK,-1,,<empty>,,,,5,,<empty>
100588,BLOCK,-1,,<empty>,,,,5,,<empty>
100596,BLOCK,-1,,<empty>,,,,5,,<empty>
100603,BLOCK,-1,,<empty>,,,,4,,<empty>
100610,BLOCK,-1,,<empty>,,,,4,,<empty>
100618,BLOCK,-1,,<empty>,,,,5,,<empty>
100628,BLOCK,-1,,<empty>,,,,7,,<empty>
100637,BLOCK,-1,,<empty>,,,,6,,<empty>
100645,BLOCK,-1,,<empty>,,,,5,,<empty>
100655,BLOCK,-1,,<empty>,,,,7,,<empty>
100662,BLOCK,-1,,<empty>,,,,4,,<empty>
100674,BLOCK,-1,,<empty>,,,,9,,<empty>
100684,BLOCK,-1,,<empty>,,,,7,,<empty>
100691,BLOCK,-1,,<empty>,,,,4,,<empty>
100698,BLOCK,-1,,<empty>,,,,4,,<empty>
100707,BLOCK,-1,,<empty>,,,,6,,<empty>
100714,BLOCK,-1,,<empty>,,,,4,,<empty>
100722,BLOCK,-1,,<empty>,,,,5,,<empty>
100728,BLOCK,-1,,<empty>,,,,3,,<empty>
100735,BLOCK,-1,,<empty>,,,,4,,<empty>
100742,BLOCK,-1,,<empty>,,,,4,,<empty>
100749,BLOCK,-1,,<empty>,,,,4,,<empty>
100755,BLOCK,-1,,<empty>,,,,3,,<empty>
100761,BLOCK,-1,,<empty>,,,,3,,<empty>
100767,BLOCK,-1,,<empty>,,,,3,,<empty>
100773,BLOCK,-1,,<empty>,,,,3,,<empty>
100781,BLOCK,-1,,<empty>,,,,5,,<empty>
100787,BLOCK,-1,,<empty>,,,,3,,<empty>
100794,BLOCK,-1,,<empty>,,,,4,,<empty>
100801,BLOCK,-1,,<empty>,,,,4,,<empty>
100808,BLOCK,-1,,<empty>,,,,4,,<empty>
100815,BLOCK,-1,,<empty>,,,,4,,<empty>
100821,BLOCK,-1,,<empty>,,,,3,,<empty>
100827,BLOCK,-1,,<empty>,,,,3,,<empty>
100834,BLOCK,-1,,<empty>,,,,4,,<empty>
100842,BLOCK,-1,,<empty>,,,,5,,<empty>
100852,BLOCK,-1,,<empty>,,,,7,,<empty>
100860,BLOCK,-1,,<empty>,,,,5,,<empty>
100867,BLOCK,-1,,<empty>,,,,4,,<empty>
100877,BLOCK,-1,,<empty>,,,,7,,<empty>
100888,BLOCK,-1,,<empty>,,,,8,,<empty>
100897,BLOCK,-1,,<empty>,,,,6,,<empty>
100904,BLOCK,-1,,<empty>,,,,4,,<empty>
100914,BLOCK,-1,,<empty>,,,,7,,<empty>
100920,BLOCK,-1,,<empty>,,,,3,,<empty>
100927,BLOCK,-1,,<empty>,,,,4,,<empty>
100934,BLOCK,-1,,<empty>,,,,4,,<empty>
100941,BLOCK,-1,,<empty>,,,,4,,<empty>
100948,BLOCK,-1,,<empty>,,,,4,,<empty>
100955,BLOCK,-1,,<empty>,,,,4,,<empty>
100962,BLOCK,-1,,<empty>,,,,4,,<empty>
100969,BLOCK,-1,,<empty>,,,,4,,<empty>
100976,BLOCK,-1,,<empty>,,,,4,,<empty>
100983,BLOCK,-1,,<empty>,,,,4,,<empty>
100993,BLOCK,-1,,<empty>,,,,7,,<empty>
101000,BLOCK,-1,,<empty>,,,,4,,<empty>
101007,BLOCK,-1,,<empty>,,,,4,,<empty>
101016,BLOCK,-1,,<empty>,,,,6,,<empty>
101024,BLOCK,-1,,<empty>,,,,5,,<empty>
101032,BLOCK,-1,,<empty>,,,,5,,<empty>
101041,BLOCK,-1,,<empty>,,,,6,,<empty>
101051,BLOCK,-1,,<empty>,,,,7,,<empty>
101059,BLOCK,-1,,<empty>,,,,5,,<empty>
101065,BLOCK,-1,,<empty>,,,,3,,<empty>
101071,BLOCK,-1,,<empty>,,,,3,,<empty>
101078,BLOCK,-1,,<empty>,,,,4,,<empty>
101085,BLOCK,-1,,<empty>,,,,4,,<empty>
101093,BLOCK,-1,,<empty>,,,,5,,<empty>
101099,BLOCK,-1,,<empty>,,,,3,,<empty>
101105,BLOCK,-1,,<empty>,,,,3,,<empty>
101116,BLOCK,-1,,<empty>,1,,1,1,,ANY
101138,BLOCK,-1,,<empty>,,,,1,,<empty>
101219,BLOCK,-1,,<empty>,,,,3,,<empty>
101226,BLOCK,-1,,<empty>,,,,4,,<empty>
101248,BLOCK,-1,,"{ result = cb(env, cbinfo_wrapper); }",43,,441,2,,void
101264,BLOCK,-1,,"{
                          exceptionOccurred = true;
                          if (env->terminatedOrTerminating()) {
                            return;
                          }
                          env->isolate->ThrowException(value);
                        }",71,,442,3,,void
101273,BLOCK,-1,,"{
                            return;
                          }",63,,444,2,,void
101288,BLOCK,-1,,"{
    return v8::String::NewFromOneByte(isolate,
                                      reinterpret_cast<const uint8_t*>(str),
                                      v8::NewStringType::kNormal,
                                      length);
  }",80,,1530,2,,void
101314,BLOCK,-1,,"{
    return v8::String::NewFromUtf8(
        isolate, str, v8::NewStringType::kNormal, static_cast<int>(length));
  }",80,,1542,2,,void
101339,BLOCK,-1,,"{
    return v8::String::NewFromTwoByte(isolate,
                                      reinterpret_cast<const uint16_t*>(str),
                                      v8::NewStringType::kNormal,
                                      length);
  }",80,,1552,2,,void
101364,BLOCK,-1,,"{
        if (length == NAPI_AUTO_LENGTH) {
          length = (std::string_view(str)).length();
        }
        auto resource = new v8impl::ExternalOneByteStringResource(
            env, str, length, finalize_callback, finalize_hint);
        return v8::String::NewExternalOneByte(isolate, resource);
      }",33,,1577,2,,void
101369,BLOCK,1,,<empty>,,,,1,,void
101371,BLOCK,-1,,"{
          length = (std::string_view(str)).length();
        }",41,,1578,2,,void
101411,BLOCK,-1,,"{
        if (length == NAPI_AUTO_LENGTH) {
          length = (std::u16string_view(str)).length();
        }
        auto resource = new v8impl::ExternalStringResource(
            env, str, length, finalize_callback, finalize_hint);
        return v8::String::NewExternalTwoByte(isolate, resource);
      }",33,,1604,2,,void
101416,BLOCK,1,,<empty>,,,,1,,void
101418,BLOCK,-1,,"{
          length = (std::u16string_view(str)).length();
        }",41,,1605,2,,void
101472,BLOCK,-1,,<empty>,1,,1,1,,ANY
101481,BLOCK,-1,,"{
  CHECK_ENV(env);
  if (length > 0) CHECK_ARG(env, str);
  CHECK_ARG(env, result);
  RETURN_STATUS_IF_FALSE(
      env, (length == NAPI_AUTO_LENGTH) || length <= INT_MAX, napi_invalid_arg);

  auto isolate = env->isolate;
  auto str_maybe = string_maker(isolate);
  CHECK_MAYBE_EMPTY(env, str_maybe, napi_generic_failure);
  *result = v8impl::JsValueFromV8LocalValue(str_maybe.ToLocalChecked());
  return napi_clear_last_error(env);
}",49,,69,6,,void
101484,BLOCK,1,,<empty>,,,,2,,void
101486,BLOCK,-1,,CHECK_ENV(env),3,,70,1,,void
101491,BLOCK,-1,,CHECK_ENV(env),3,,70,2,,void
101499,BLOCK,-1,,<empty>,19,,71,2,,void
101503,BLOCK,1,,<empty>,,,,3,,void
101505,BLOCK,-1,,"CHECK_ARG(env, str)",19,,71,1,,void
101511,BLOCK,-1,,"CHECK_ARG(env, str)",19,,71,2,,void
101520,BLOCK,1,,<empty>,,,,3,,void
101522,BLOCK,-1,,"CHECK_ARG(env, result)",3,,72,1,,void
101528,BLOCK,-1,,"CHECK_ARG(env, result)",3,,72,2,,void
101537,BLOCK,1,,<empty>,,,,3,,void
101539,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(
      env, (length == NAPI_AUTO_LENGTH) || length <= INT_MAX, napi_invalid_arg)",3,,73,1,,void
101549,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(
      env, (length == NAPI_AUTO_LENGTH) || length <= INT_MAX, napi_invalid_arg)",3,,73,2,,void
101570,BLOCK,1,,<empty>,,,,5,,void
101572,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, str_maybe, napi_generic_failure)",3,,78,1,,void
101580,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, str_maybe, napi_generic_failure)",3,,78,2,,void
101612,BLOCK,-1,,"{
  napi_status status;
#if defined(V8_ENABLE_SANDBOX)
  status = create_api(env, str, length, result);
  if (status == napi_ok) {
    if (copied != nullptr) {
      *copied = true;
    }
    if (finalize_callback) {
      env->CallFinalizer(
          finalize_callback, static_cast<CharType*>(str), finalize_hint);
    }
  }
#else
  status = NewString(env, str, length, result, string_maker);
  if (status == napi_ok && copied != nullptr) {
    *copied = false;
  }
#endif  // V8_ENABLE_SANDBOX
  return status;
}",57,,92,10,,void
101630,BLOCK,-1,,"{
    *copied = false;
  }",47,,107,2,,void
101645,BLOCK,-1,,"{
    Link(finalize_callback == nullptr ? &env->reflist
                                      : &env->finalizing_reflist);
  }",64,,120,5,,void
101662,BLOCK,-1,,"{
    Unlink();
    env_ = nullptr;
  }",28,,131,1,,void
101670,BLOCK,-1,,"{
    if (finalize_callback_ == nullptr) return;
    if (env_ == nullptr) {
      // The environment is dead. Call the finalizer directly.
      finalize_callback_(nullptr, finalize_data_, finalize_hint_);
    } else {
      // The environment is still alive. Let's remove ourselves from its list
      // of references and call the user's finalizer.
      Unlink();
      env_->CallFinalizer(finalize_callback_, finalize_data_, finalize_hint_);
    }
  }",28,,136,1,,void
101675,BLOCK,-1,,<empty>,40,,137,2,,void
101681,BLOCK,-1,,"{
      // The environment is dead. Call the finalizer directly.
      finalize_callback_(nullptr, finalize_data_, finalize_hint_);
    }",26,,138,2,,void
101687,BLOCK,-1,,"{
      // The environment is still alive. Let's remove ourselves from its list
      // of references and call the user's finalizer.
      Unlink();
      env_->CallFinalizer(finalize_callback_, finalize_data_, finalize_hint_);
    }",12,,141,1,,void
101705,BLOCK,-1,,<empty>,25,,161,6,,void
101709,BLOCK,-1,,{ return string_; },37,,163,1,,void
101715,BLOCK,-1,,{ return length_; },34,,164,1,,void
101729,BLOCK,-1,,<empty>,25,,181,6,,void
101733,BLOCK,-1,,{ return string_; },41,,183,1,,void
101739,BLOCK,-1,,{ return length_; },34,,184,1,,void
101750,BLOCK,-1,,"{
  if (p->utf8name != nullptr) {
    CHECK_NEW_FROM_UTF8(env, *result, p->utf8name);
  } else {
    v8::Local<v8::Value> property_value =
        v8impl::V8LocalValueFromJsValue(p->name);

    RETURN_STATUS_IF_FALSE(env, property_value->IsName(), napi_name_expected);
    *result = property_value.As<v8::Name>();
  }

  return napi_ok;
}",34,,194,4,,void
101757,BLOCK,-1,,"{
    CHECK_NEW_FROM_UTF8(env, *result, p->utf8name);
  }",31,,195,2,,void
101766,BLOCK,1,,<empty>,,,,6,,void
101768,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, *result, p->utf8name)",5,,196,1,,void
101778,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, *result, p->utf8name)",5,,196,1,,void
101788,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, *result, p->utf8name)",5,,196,2,,void
101795,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, *result, p->utf8name)",5,,196,1,,void
101803,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, *result, p->utf8name)",5,,196,2,,void
101833,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, *result, p->utf8name)",5,,196,1,,void
101841,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, *result, p->utf8name)",5,,196,2,,void
101856,BLOCK,-1,,"{
    v8::Local<v8::Value> property_value =
        v8impl::V8LocalValueFromJsValue(p->name);

    RETURN_STATUS_IF_FALSE(env, property_value->IsName(), napi_name_expected);
    *result = property_value.As<v8::Name>();
  }",10,,197,1,,void
101881,BLOCK,1,,<empty>,,,,4,,void
101883,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, property_value->IsName(), napi_name_expected)",5,,201,1,,void
101890,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, property_value->IsName(), napi_name_expected)",5,,201,2,,void
101909,BLOCK,-1,,"{
  unsigned int attribute_flags = v8::PropertyAttribute::None;

  // The napi_writable attribute is ignored for accessor descriptors, but
  // V8 would throw `TypeError`s on assignment with nonexistence of a setter.
  if ((descriptor->getter == nullptr && descriptor->setter == nullptr) &&
      (descriptor->attributes & napi_writable) == 0) {
    attribute_flags |= v8::PropertyAttribute::ReadOnly;
  }

  if ((descriptor->attributes & napi_enumerable) == 0) {
    attribute_flags |= v8::PropertyAttribute::DontEnum;
  }
  if ((descriptor->attributes & napi_configurable) == 0) {
    attribute_flags |= v8::PropertyAttribute::DontDelete;
  }

  return static_cast<v8::PropertyAttribute>(attribute_flags);
}",49,,210,2,,void
101938,BLOCK,-1,,"{
    attribute_flags |= v8::PropertyAttribute::ReadOnly;
  }",54,,216,2,,void
101954,BLOCK,-1,,"{
    attribute_flags |= v8::PropertyAttribute::DontEnum;
  }",56,,220,2,,void
101970,BLOCK,-1,,"{
    attribute_flags |= v8::PropertyAttribute::DontDelete;
  }",58,,223,2,,void
101986,BLOCK,-1,,"{
  return reinterpret_cast<napi_deferred>(local);
}",43,,231,2,,void
101995,BLOCK,-1,,"{
  return reinterpret_cast<v8impl::Persistent<v8::Value>*>(local);
}",26,,236,2,,void
102005,BLOCK,-1,,<empty>,70,,242,2,,void
102012,BLOCK,-1,,<empty>,47,,256,2,,void
102016,BLOCK,-1,,{ return escape_called_; },30,,257,1,,void
102023,BLOCK,-1,,"{
    escape_called_ = true;
    return scope.Escape(handle);
  }",44,,259,2,,void
102039,BLOCK,-1,,"{
  return reinterpret_cast<napi_handle_scope>(s);
}",80,,269,2,,void
102048,BLOCK,-1,,"{
  return reinterpret_cast<HandleScopeWrapper*>(s);
}",80,,273,2,,void
102057,BLOCK,-1,,"{
  return reinterpret_cast<napi_escapable_handle_scope>(s);
}",37,,279,2,,void
102066,BLOCK,-1,,"{
  return reinterpret_cast<EscapableHandleScopeWrapper*>(s);
}",36,,285,2,,void
102078,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();
  v8impl::Persistent<v8::Value>* deferred_ref =
      NodePersistentFromJsDeferred(deferred);
  v8::Local<v8::Value> v8_deferred =
      v8::Local<v8::Value>::New(env->isolate, *deferred_ref);

  auto v8_resolver = v8_deferred.As<v8::Promise::Resolver>();

  v8::Maybe<bool> success =
      is_resolved ? v8_resolver->Resolve(
                        context, v8impl::V8LocalValueFromJsValue(result))
                  : v8_resolver->Reject(
                        context, v8impl::V8LocalValueFromJsValue(result));

  delete deferred_ref;

  RETURN_STATUS_IF_FALSE(env, success.FromMaybe(false), napi_generic_failure);

  return GET_RETURN_STATUS(env);
}",55,,292,5,,void
102081,BLOCK,1,,<empty>,,,,2,,void
102083,BLOCK,-1,,NAPI_PREAMBLE(env),3,,293,1,,void
102088,BLOCK,-1,,NAPI_PREAMBLE(env),3,,293,2,,void
102093,BLOCK,-1,,NAPI_PREAMBLE(env),3,,293,1,,void
102102,BLOCK,-1,,NAPI_PREAMBLE(env),3,,293,2,,void
102109,BLOCK,-1,,NAPI_PREAMBLE(env),3,,293,1,,void
102116,BLOCK,-1,,NAPI_PREAMBLE(env),3,,293,2,,void
102137,BLOCK,1,,<empty>,,,,3,,void
102139,BLOCK,-1,,"CHECK_ARG(env, result)",3,,294,1,,void
102145,BLOCK,-1,,"CHECK_ARG(env, result)",3,,294,2,,void
102239,BLOCK,1,,<empty>,,,,5,,void
102241,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, success.FromMaybe(false), napi_generic_failure)",3,,312,1,,void
102249,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, success.FromMaybe(false), napi_generic_failure)",3,,312,2,,void
102258,BLOCK,1,,<empty>,,,,3,,void
102279,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, js_object);
  if (action == KeepWrap) {
    CHECK_ARG(env, result);
  }

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(js_object);
  RETURN_STATUS_IF_FALSE(env, value->IsObject(), napi_invalid_arg);
  v8::Local<v8::Object> obj = value.As<v8::Object>();

  auto val = obj->GetPrivate(context, NAPI_PRIVATE_KEY(context, wrapper))
                 .ToLocalChecked();
  RETURN_STATUS_IF_FALSE(env, val->IsExternal(), napi_invalid_arg);
  Reference* reference =
      static_cast<v8impl::Reference*>(val.As<v8::External>()->Value());

  if (result) {
    *result = reference->Data();
  }

  if (action == RemoveWrap) {
    CHECK(obj->DeletePrivate(context, NAPI_PRIVATE_KEY(context, wrapper))
              .FromJust());
    if (reference->ownership() == Ownership::kUserland) {
      // When the wrap is been removed, the finalizer should be reset.
      reference->ResetFinalizer();
    } e...",48,,322,5,,void
102282,BLOCK,1,,<empty>,,,,2,,void
102284,BLOCK,-1,,NAPI_PREAMBLE(env),3,,323,1,,void
102289,BLOCK,-1,,NAPI_PREAMBLE(env),3,,323,2,,void
102294,BLOCK,-1,,NAPI_PREAMBLE(env),3,,323,1,,void
102303,BLOCK,-1,,NAPI_PREAMBLE(env),3,,323,2,,void
102310,BLOCK,-1,,NAPI_PREAMBLE(env),3,,323,1,,void
102317,BLOCK,-1,,NAPI_PREAMBLE(env),3,,323,2,,void
102338,BLOCK,1,,<empty>,,,,3,,void
102340,BLOCK,-1,,"CHECK_ARG(env, js_object)",3,,324,1,,void
102346,BLOCK,-1,,"CHECK_ARG(env, js_object)",3,,324,2,,void
102356,BLOCK,-1,,"{
    CHECK_ARG(env, result);
  }",27,,325,2,,void
102360,BLOCK,1,,<empty>,,,,3,,void
102362,BLOCK,-1,,"CHECK_ARG(env, result)",5,,326,1,,void
102368,BLOCK,-1,,"CHECK_ARG(env, result)",5,,326,2,,void
102410,BLOCK,1,,<empty>,,,,4,,void
102412,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, value->IsObject(), napi_invalid_arg)",3,,332,1,,void
102419,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, value->IsObject(), napi_invalid_arg)",3,,332,2,,void
102451,BLOCK,1,,<empty>,,,,2,,void
102470,BLOCK,1,,<empty>,,,,5,,void
102472,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsExternal(), napi_invalid_arg)",3,,337,1,,void
102479,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsExternal(), napi_invalid_arg)",3,,337,2,,void
102499,BLOCK,-1,,"{
    *result = reference->Data();
  }",15,,341,2,,void
102511,BLOCK,-1,,"{
    CHECK(obj->DeletePrivate(context, NAPI_PRIVATE_KEY(context, wrapper))
              .FromJust());
    if (reference->ownership() == Ownership::kUserland) {
      // When the wrap is been removed, the finalizer should be reset.
      reference->ResetFinalizer();
    } else {
      delete reference;
    }
  }",29,,345,2,,void
102522,BLOCK,1,,<empty>,,,,2,,void
102543,BLOCK,-1,,"{
      // When the wrap is been removed, the finalizer should be reset.
      reference->ResetFinalizer();
    }",57,,348,2,,void
102549,BLOCK,-1,,"{
      delete reference;
    }",12,,351,1,,void
102555,BLOCK,1,,<empty>,,,,3,,void
102573,BLOCK,-1,,"{
    CallbackBundle* bundle = new CallbackBundle();
    bundle->cb = cb;
    bundle->cb_data = data;
    bundle->env = env;

    v8::Local<v8::Value> cbdata = v8::External::New(env->isolate, bundle);
    Reference::New(
        env, cbdata, 0, Ownership::kRuntime, Delete, bundle, nullptr);
    return cbdata;
  }",54,,373,4,,void
102638,BLOCK,-1,,"{
    CallbackBundle* bundle = static_cast<CallbackBundle*>(data);
    delete bundle;
  }",60,,389,4,,void
102654,BLOCK,-1,,<empty>,65,,400,4,,void
102658,BLOCK,-1,,<empty>,,,,1,,<empty>
102664,BLOCK,-1,,<empty>,,,,3,,<empty>
102669,BLOCK,-1,,<empty>,,,,2,,<empty>
102673,BLOCK,-1,,{ return _this; },21,,406,1,,void
102679,BLOCK,-1,,{ return _args_length; },23,,408,1,,void
102685,BLOCK,-1,,{ return _data; },16,,410,1,,void
102696,BLOCK,-1,,"{
    _bundle = reinterpret_cast<CallbackBundle*>(
        cbinfo.Data().As<v8::External>()->Value());
    _data = _bundle->cb_data;
  }",25,,424,3,,void
102719,BLOCK,-1,,"{
    napi_callback_info cbinfo_wrapper = reinterpret_cast<napi_callback_info>(
        static_cast<CallbackWrapper*>(this));

    // All other pointers we need are stored in `_bundle`
    napi_env env = _bundle->env;
    napi_callback cb = _bundle->cb;

    napi_value result = nullptr;
    bool exceptionOccurred = false;
    env->CallIntoModule([&](napi_env env) { result = cb(env, cbinfo_wrapper); },
                        [&](napi_env env, v8::Local<v8::Value> value) {
                          exceptionOccurred = true;
                          if (env->terminatedOrTerminating()) {
                            return;
                          }
                          env->isolate->ThrowException(value);
                        });

    if (!exceptionOccurred && (result != nullptr)) {
      this->SetReturnValue(result);
    }
  }",32,,431,1,,void
102757,BLOCK,-1,,"{
      this->SetReturnValue(result);
    }",52,,450,2,,void
102770,BLOCK,-1,,"{
    FunctionCallbackWrapper cbwrapper(info);
    cbwrapper.InvokeCallback();
  }",71,,461,2,,void
102785,BLOCK,-1,,"{
    v8::Local<v8::Value> cbdata = v8impl::CallbackBundle::New(env, cb, cb_data);
    RETURN_STATUS_IF_FALSE(env, !cbdata.IsEmpty(), napi_generic_failure);

    v8::MaybeLocal<v8::Function> maybe_function =
        v8::Function::New(env->context(), Invoke, cbdata);
    CHECK_MAYBE_EMPTY(env, maybe_function, napi_generic_failure);

    *result = maybe_function.ToLocalChecked();
    return napi_clear_last_error(env);
  }",74,,469,5,,void
102813,BLOCK,1,,<empty>,,,,4,,void
102815,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, !cbdata.IsEmpty(), napi_generic_failure)",5,,471,1,,void
102823,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, !cbdata.IsEmpty(), napi_generic_failure)",5,,471,2,,void
102855,BLOCK,1,,<empty>,,,,4,,void
102857,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe_function, napi_generic_failure)",5,,475,1,,void
102865,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe_function, napi_generic_failure)",5,,475,2,,void
102889,BLOCK,-1,,"{
    v8::Local<v8::Value> cbdata = v8impl::CallbackBundle::New(env, cb, cb_data);
    RETURN_STATUS_IF_FALSE(env, !cbdata.IsEmpty(), napi_generic_failure);

    *result = v8::FunctionTemplate::New(env->isolate, Invoke, cbdata, sig);
    return napi_clear_last_error(env);
  }",66,,486,6,,void
102917,BLOCK,1,,<empty>,,,,4,,void
102919,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, !cbdata.IsEmpty(), napi_generic_failure)",5,,488,1,,void
102927,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, !cbdata.IsEmpty(), napi_generic_failure)",5,,488,2,,void
102955,BLOCK,-1,,<empty>,54,,496,2,,void
102959,BLOCK,-1,,"{
    if (_cbinfo.IsConstructCall()) {
      return v8impl::JsValueFromV8LocalValue(_cbinfo.NewTarget());
    } else {
      return nullptr;
    }
  }",38,,498,1,,void
102965,BLOCK,-1,,"{
      return v8impl::JsValueFromV8LocalValue(_cbinfo.NewTarget());
    }",36,,499,2,,void
102976,BLOCK,-1,,"{
      return nullptr;
    }",12,,501,1,,void
102984,BLOCK,-1,,"{
    size_t i = 0;
    size_t min = std::min(buffer_length, _args_length);

    for (; i < min; i += 1) {
      buffer[i] = v8impl::JsValueFromV8LocalValue(_cbinfo[i]);
    }

    if (i < buffer_length) {
      napi_value undefined =
          v8impl::JsValueFromV8LocalValue(v8::Undefined(_cbinfo.GetIsolate()));
      for (; i < buffer_length; i += 1) {
        buffer[i] = undefined;
      }
    }
  }",64,,507,3,,void
102999,BLOCK,-1,,<empty>,5,,511,1,,void
103006,BLOCK,4,,"{
      buffer[i] = v8impl::JsValueFromV8LocalValue(_cbinfo[i]);
    }",29,,511,4,,void
103022,BLOCK,-1,,"{
      napi_value undefined =
          v8impl::JsValueFromV8LocalValue(v8::Undefined(_cbinfo.GetIsolate()));
      for (; i < buffer_length; i += 1) {
        buffer[i] = undefined;
      }
    }",28,,515,2,,void
103039,BLOCK,-1,,<empty>,7,,518,1,,void
103046,BLOCK,4,,"{
        buffer[i] = undefined;
      }",41,,518,4,,void
103056,BLOCK,-1,,"{
    v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
    _cbinfo.GetReturnValue().Set(val);
  }",50,,525,2,,void
103089,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, js_object);

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(js_object);
  RETURN_STATUS_IF_FALSE(env, value->IsObject(), napi_invalid_arg);
  v8::Local<v8::Object> obj = value.As<v8::Object>();

  // If we've already wrapped this object, we error out.
  RETURN_STATUS_IF_FALSE(
      env,
      !obj->HasPrivate(context, NAPI_PRIVATE_KEY(context, wrapper)).FromJust(),
      napi_invalid_arg);

  v8impl::Reference* reference = nullptr;
  if (result != nullptr) {
    // The returned reference should be deleted via napi_delete_reference()
    // ONLY in response to the finalize callback invocation. (If it is deleted
    // before then, then the finalize callback will never be invoked.)
    // Therefore a finalize callback is required when returning a reference.
    CHECK_ARG(env, finalize_cb);
    reference = v8impl::Reference::New(env,
                                       obj,
...",43,,536,7,,void
103092,BLOCK,1,,<empty>,,,,2,,void
103094,BLOCK,-1,,NAPI_PREAMBLE(env),3,,537,1,,void
103099,BLOCK,-1,,NAPI_PREAMBLE(env),3,,537,2,,void
103104,BLOCK,-1,,NAPI_PREAMBLE(env),3,,537,1,,void
103113,BLOCK,-1,,NAPI_PREAMBLE(env),3,,537,2,,void
103120,BLOCK,-1,,NAPI_PREAMBLE(env),3,,537,1,,void
103127,BLOCK,-1,,NAPI_PREAMBLE(env),3,,537,2,,void
103148,BLOCK,1,,<empty>,,,,3,,void
103150,BLOCK,-1,,"CHECK_ARG(env, js_object)",3,,538,1,,void
103156,BLOCK,-1,,"CHECK_ARG(env, js_object)",3,,538,2,,void
103198,BLOCK,1,,<empty>,,,,4,,void
103200,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, value->IsObject(), napi_invalid_arg)",3,,543,1,,void
103207,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, value->IsObject(), napi_invalid_arg)",3,,543,2,,void
103230,BLOCK,1,,<empty>,,,,3,,void
103232,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(
      env,
      !obj->HasPrivate(context, NAPI_PRIVATE_KEY(context, wrapper)).FromJust(),
      napi_invalid_arg)",3,,547,1,,void
103254,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(
      env,
      !obj->HasPrivate(context, NAPI_PRIVATE_KEY(context, wrapper)).FromJust(),
      napi_invalid_arg)",3,,547,2,,void
103268,BLOCK,-1,,"{
    // The returned reference should be deleted via napi_delete_reference()
    // ONLY in response to the finalize callback invocation. (If it is deleted
    // before then, then the finalize callback will never be invoked.)
    // Therefore a finalize callback is required when returning a reference.
    CHECK_ARG(env, finalize_cb);
    reference = v8impl::Reference::New(env,
                                       obj,
                                       0,
                                       v8impl::Ownership::kUserland,
                                       finalize_cb,
                                       native_object,
                                       finalize_hint);
    *result = reinterpret_cast<napi_ref>(reference);
  }",26,,553,2,,void
103272,BLOCK,1,,<empty>,,,,3,,void
103274,BLOCK,-1,,"CHECK_ARG(env, finalize_cb)",5,,558,1,,void
103280,BLOCK,-1,,"CHECK_ARG(env, finalize_cb)",5,,558,2,,void
103312,BLOCK,-1,,"{
    // Create a self-deleting reference.
    reference = v8impl::Reference::New(
        env,
        obj,
        0,
        v8impl::Ownership::kRuntime,
        finalize_cb,
        native_object,
        finalize_cb == nullptr ? nullptr : finalize_hint);
  }",10,,567,1,,void
103347,BLOCK,1,,<empty>,,,,2,,void
103372,BLOCK,1,,<empty>,,,,3,,void
103387,BLOCK,-1,,"{
  return value->IsObject() || value->IsSymbol();
}",57,,595,2,,void
103401,BLOCK,-1,,"{
  finalize_callback_ = nullptr;
  finalize_data_ = nullptr;
  finalize_hint_ = nullptr;
}",34,,601,1,,void
103420,BLOCK,-1,,"{
  Link(finalize_callback == nullptr ? &env->reflist : &env->finalizing_reflist);
}",29,,616,7,,void
103437,BLOCK,-1,,"{
  // Remove from the env's tracked list.
  Unlink();
  // Try to remove the finalizer from the scheduled second pass callback.
  env_->DequeueFinalizer(this);
}",21,,622,1,,void
103453,BLOCK,-1,,"{
  return new RefBase(env,
                     initial_refcount,
                     ownership,
                     finalize_callback,
                     finalize_data,
                     finalize_hint);
}",44,,634,7,,void
103466,BLOCK,-1,,"{
  return finalize_data_;
}",23,,643,1,,void
103472,BLOCK,-1,,"{
  return ++refcount_;
}",25,,647,1,,void
103479,BLOCK,-1,,"{
  if (refcount_ == 0) {
    return 0;
  }
  return --refcount_;
}",27,,651,1,,void
103484,BLOCK,-1,,"{
    return 0;
  }",23,,652,2,,void
103493,BLOCK,-1,,"{
  return refcount_;
}",30,,658,1,,void
103499,BLOCK,-1,,"{
  Ownership ownership = ownership_;
  // Swap out the field finalize_callback so that it can not be accidentally
  // called more than once.
  napi_finalize finalize_callback = finalize_callback_;
  void* finalize_data = finalize_data_;
  void* finalize_hint = finalize_hint_;
  ResetFinalizer();

  // Either the RefBase is going to be deleted in the finalize_callback or not,
  // it should be removed from the tracked list.
  Unlink();
  // 1. If the finalize_callback is present, it should either delete the
  //    RefBase, or set ownership with Ownership::kRuntime.
  // 2. If the finalizer is not present, the RefBase can be deleted after the
  //    call.
  if (finalize_callback != nullptr) {
    env_->CallFinalizer(finalize_callback, finalize_data, finalize_hint);
    // No access to `this` after finalize_callback is called.
  }

  // If the RefBase is not Ownership::kRuntime, userland code should delete it.
  // Now delete it if it is Ownership::kRuntime.
  if (ownership == Owne...",26,,662,1,,void
103522,BLOCK,-1,,"{
    env_->CallFinalizer(finalize_callback, finalize_data, finalize_hint);
    // No access to `this` after finalize_callback is called.
  }",37,,678,2,,void
103536,BLOCK,-1,,"{
    delete this;
  }",41,,685,2,,void
103545,BLOCK,-1,,"{
  if (RefCount() == 0) {
    SetWeak();
  }
}",44,,694,4,,void
103550,BLOCK,-1,,"{
    SetWeak();
  }",24,,695,2,,void
103555,BLOCK,-1,,"{
  // Reset the handle. And no weak callback will be invoked.
  persistent_.Reset();
}",25,,700,1,,void
103570,BLOCK,-1,,"{
  return new Reference(env,
                       value,
                       initial_refcount,
                       ownership,
                       finalize_callback,
                       finalize_data,
                       finalize_hint);
}",48,,711,8,,void
103584,BLOCK,-1,,"{
  // When the persistent_ is cleared in the WeakCallback, and a second pass
  // callback is pending, return 0 unconditionally.
  if (persistent_.IsEmpty()) {
    return 0;
  }
  uint32_t refcount = RefBase::Ref();
  if (refcount == 1 && can_be_weak_) {
    persistent_.ClearWeak();
  }
  return refcount;
}",27,,721,1,,void
103590,BLOCK,-1,,"{
    return 0;
  }",30,,724,2,,void
103606,BLOCK,-1,,"{
    persistent_.ClearWeak();
  }",38,,728,2,,void
103616,BLOCK,-1,,"{
  // When the persistent_ is cleared in the WeakCallback, and a second pass
  // callback is pending, return 0 unconditionally.
  if (persistent_.IsEmpty()) {
    return 0;
  }
  uint32_t old_refcount = RefCount();
  uint32_t refcount = RefBase::Unref();
  if (old_refcount == 1 && refcount == 0) {
    SetWeak();
  }
  return refcount;
}",29,,734,1,,void
103622,BLOCK,-1,,"{
    return 0;
  }",30,,737,2,,void
103644,BLOCK,-1,,"{
    SetWeak();
  }",43,,742,2,,void
103651,BLOCK,-1,,"{
  if (persistent_.IsEmpty()) {
    return v8::Local<v8::Value>();
  } else {
    return v8::Local<v8::Value>::New(env_->isolate, persistent_);
  }
}",39,,748,1,,void
103657,BLOCK,-1,,"{
    return v8::Local<v8::Value>();
  }",30,,749,2,,void
103664,BLOCK,-1,,"{
    return v8::Local<v8::Value>::New(env_->isolate, persistent_);
  }",10,,751,1,,void
103685,BLOCK,-1,,"{
  // Unconditionally reset the persistent handle so that no weak callback will
  // be invoked again.
  persistent_.Reset();

  // Chain up to perform the rest of the finalization.
  RefBase::Finalize();
}",28,,756,1,,void
103697,BLOCK,-1,,"{
  if (can_be_weak_) {
    persistent_.SetWeak(this, WeakCallback, v8::WeakCallbackType::kParameter);
  } else {
    persistent_.Reset();
  }
}",27,,767,1,,void
103700,BLOCK,-1,,"{
    persistent_.SetWeak(this, WeakCallback, v8::WeakCallbackType::kParameter);
  }",21,,768,2,,void
103713,BLOCK,-1,,"{
    persistent_.Reset();
  }",10,,770,1,,void
103722,BLOCK,-1,,"{
  Reference* reference = data.GetParameter();
  // The reference must be reset during the weak callback as the API protocol.
  reference->persistent_.Reset();
  reference->env_->EnqueueFinalizer(reference);
}",75,,778,2,,void
103776,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  // The value of the constant below must be updated to reference the last
  // message in the `napi_status` enum each time a new error message is added.
  // We don't have a napi_status_last as this would result in an ABI
  // change each time a message was added.
  const int last_status = napi_cannot_run_js;

  static_assert(NAPI_ARRAYSIZE(error_messages) == last_status + 1,
                ""Count of error messages must match count of error values"");
  CHECK_LE(env->last_error.error_code, last_status);
  // Wait until someone requests the last error information to fetch the error
  // message string
  env->last_error.error_message = error_messages[env->last_error.error_code];

  if (env->last_error.error_code == napi_ok) {
    napi_clear_last_error(env);
  }
  *result = &(env->last_error);
  return napi_ok;
}",60,,816,3,,void
103779,BLOCK,1,,<empty>,,,,2,,void
103781,BLOCK,-1,,CHECK_ENV(env),3,,817,1,,void
103786,BLOCK,-1,,CHECK_ENV(env),3,,817,2,,void
103793,BLOCK,1,,<empty>,,,,3,,void
103795,BLOCK,-1,,"CHECK_ARG(env, result)",3,,818,1,,void
103801,BLOCK,-1,,"CHECK_ARG(env, result)",3,,818,2,,void
103815,BLOCK,1,,<empty>,,,,3,,void
103853,BLOCK,-1,,"{
    napi_clear_last_error(env);
  }",46,,833,2,,void
103874,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);
  CHECK_ARG(env, cb);

  v8::Local<v8::Function> return_value;
  v8::EscapableHandleScope scope(env->isolate);
  v8::Local<v8::Function> fn;
  STATUS_CALL(v8impl::FunctionCallbackWrapper::NewFunction(
      env, cb, callback_data, &fn));
  return_value = scope.Escape(fn);

  if (utf8name != nullptr) {
    v8::Local<v8::String> name_string;
    CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length);
    return_value->SetName(name_string);
  }

  *result = v8impl::JsValueFromV8LocalValue(return_value);

  return GET_RETURN_STATUS(env);
}",65,,845,7,,void
103877,BLOCK,1,,<empty>,,,,2,,void
103879,BLOCK,-1,,NAPI_PREAMBLE(env),3,,846,1,,void
103884,BLOCK,-1,,NAPI_PREAMBLE(env),3,,846,2,,void
103889,BLOCK,-1,,NAPI_PREAMBLE(env),3,,846,1,,void
103898,BLOCK,-1,,NAPI_PREAMBLE(env),3,,846,2,,void
103905,BLOCK,-1,,NAPI_PREAMBLE(env),3,,846,1,,void
103912,BLOCK,-1,,NAPI_PREAMBLE(env),3,,846,2,,void
103933,BLOCK,1,,<empty>,,,,3,,void
103935,BLOCK,-1,,"CHECK_ARG(env, result)",3,,847,1,,void
103941,BLOCK,-1,,"CHECK_ARG(env, result)",3,,847,2,,void
103950,BLOCK,1,,<empty>,,,,3,,void
103952,BLOCK,-1,,"CHECK_ARG(env, cb)",3,,848,1,,void
103958,BLOCK,-1,,"CHECK_ARG(env, cb)",3,,848,2,,void
103989,BLOCK,1,,<empty>,,,,3,,void
103991,BLOCK,-1,,"STATUS_CALL(v8impl::FunctionCallbackWrapper::NewFunction(
      env, cb, callback_data, &fn))",3,,853,1,,void
104010,BLOCK,-1,,<empty>,3,,853,2,,void
104025,BLOCK,-1,,"{
    v8::Local<v8::String> name_string;
    CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length);
    return_value->SetName(name_string);
  }",28,,857,2,,void
104041,BLOCK,1,,<empty>,,,,7,,void
104043,BLOCK,-1,,"CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length)",5,,859,1,,void
104053,BLOCK,-1,,"CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length)",5,,859,1,,void
104063,BLOCK,-1,,"CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length)",5,,859,2,,void
104070,BLOCK,-1,,"CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length)",5,,859,1,,void
104076,BLOCK,-1,,"CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length)",5,,859,2,,void
104104,BLOCK,-1,,"CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length)",5,,859,1,,void
104112,BLOCK,-1,,"CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length)",5,,859,2,,void
104141,BLOCK,1,,<empty>,,,,3,,void
104163,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);
  CHECK_ARG(env, constructor);

  if (property_count > 0) {
    CHECK_ARG(env, properties);
  }

  v8::Isolate* isolate = env->isolate;

  v8::EscapableHandleScope scope(isolate);
  v8::Local<v8::FunctionTemplate> tpl;
  STATUS_CALL(v8impl::FunctionCallbackWrapper::NewTemplate(
      env, constructor, callback_data, &tpl));

  v8::Local<v8::String> name_string;
  CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length);
  tpl->SetClassName(name_string);

  size_t static_property_count = 0;
  for (size_t i = 0; i < property_count; i++) {
    const napi_property_descriptor* p = properties + i;

    if ((p->attributes & napi_static) != 0) {
      // Static properties are handled separately below.
      static_property_count++;
      continue;
    }

    v8::Local<v8::Name> property_name;
    STATUS_CALL(v8impl::V8NameFromPropertyDescriptor(env, p, &property_name));

    v8::PropertyAttribute attributes =
        v8impl::V8PropertyAtt...",39,,876,9,,void
104166,BLOCK,1,,<empty>,,,,2,,void
104168,BLOCK,-1,,NAPI_PREAMBLE(env),3,,877,1,,void
104173,BLOCK,-1,,NAPI_PREAMBLE(env),3,,877,2,,void
104178,BLOCK,-1,,NAPI_PREAMBLE(env),3,,877,1,,void
104187,BLOCK,-1,,NAPI_PREAMBLE(env),3,,877,2,,void
104194,BLOCK,-1,,NAPI_PREAMBLE(env),3,,877,1,,void
104201,BLOCK,-1,,NAPI_PREAMBLE(env),3,,877,2,,void
104222,BLOCK,1,,<empty>,,,,3,,void
104224,BLOCK,-1,,"CHECK_ARG(env, result)",3,,878,1,,void
104230,BLOCK,-1,,"CHECK_ARG(env, result)",3,,878,2,,void
104239,BLOCK,1,,<empty>,,,,3,,void
104241,BLOCK,-1,,"CHECK_ARG(env, constructor)",3,,879,1,,void
104247,BLOCK,-1,,"CHECK_ARG(env, constructor)",3,,879,2,,void
104257,BLOCK,-1,,"{
    CHECK_ARG(env, properties);
  }",27,,881,2,,void
104261,BLOCK,1,,<empty>,,,,3,,void
104263,BLOCK,-1,,"CHECK_ARG(env, properties)",5,,882,1,,void
104269,BLOCK,-1,,"CHECK_ARG(env, properties)",5,,882,2,,void
104295,BLOCK,1,,<empty>,,,,3,,void
104297,BLOCK,-1,,"STATUS_CALL(v8impl::FunctionCallbackWrapper::NewTemplate(
      env, constructor, callback_data, &tpl))",3,,889,1,,void
104316,BLOCK,-1,,<empty>,3,,889,2,,void
104335,BLOCK,1,,<empty>,,,,7,,void
104337,BLOCK,-1,,"CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length)",3,,893,1,,void
104347,BLOCK,-1,,"CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length)",3,,893,1,,void
104357,BLOCK,-1,,"CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length)",3,,893,2,,void
104364,BLOCK,-1,,"CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length)",3,,893,1,,void
104370,BLOCK,-1,,"CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length)",3,,893,2,,void
104398,BLOCK,-1,,"CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length)",3,,893,1,,void
104406,BLOCK,-1,,"CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length)",3,,893,2,,void
104429,BLOCK,-1,,<empty>,3,,897,1,,void
104439,BLOCK,4,,"{
    const napi_property_descriptor* p = properties + i;

    if ((p->attributes & napi_static) != 0) {
      // Static properties are handled separately below.
      static_property_count++;
      continue;
    }

    v8::Local<v8::Name> property_name;
    STATUS_CALL(v8impl::V8NameFromPropertyDescriptor(env, p, &property_name));

    v8::PropertyAttribute attributes =
        v8impl::V8PropertyAttributesFromDescriptor(p);

    // This code is similar to that in napi_define_properties(); the
    // difference is it applies to a template instead of an object,
    // and preferred PropertyAttribute for lack of PropertyDescriptor
    // support on ObjectTemplate.
    if (p->getter != nullptr || p->setter != nullptr) {
      v8::Local<v8::FunctionTemplate> getter_tpl;
      v8::Local<v8::FunctionTemplate> setter_tpl;
      if (p->getter != nullptr) {
        STATUS_CALL(v8impl::FunctionCallbackWrapper::NewTemplate(
            env, p->getter, p->data, &getter_tpl));
      }
      if (...",47,,897,4,,void
104454,BLOCK,-1,,"{
      // Static properties are handled separately below.
      static_property_count++;
      continue;
    }",45,,900,2,,void
104469,BLOCK,1,,<empty>,,,,4,,void
104471,BLOCK,-1,,"STATUS_CALL(v8impl::V8NameFromPropertyDescriptor(env, p, &property_name))",5,,907,1,,void
104487,BLOCK,-1,,<empty>,5,,907,2,,void
104511,BLOCK,-1,,"{
      v8::Local<v8::FunctionTemplate> getter_tpl;
      v8::Local<v8::FunctionTemplate> setter_tpl;
      if (p->getter != nullptr) {
        STATUS_CALL(v8impl::FunctionCallbackWrapper::NewTemplate(
            env, p->getter, p->data, &getter_tpl));
      }
      if (p->setter != nullptr) {
        STATUS_CALL(v8impl::FunctionCallbackWrapper::NewTemplate(
            env, p->setter, p->data, &setter_tpl));
      }

      tpl->PrototypeTemplate()->SetAccessorProperty(property_name,
                                                    getter_tpl,
                                                    setter_tpl,
                                                    attributes,
                                                    v8::AccessControl::DEFAULT);
    }",55,,916,2,,void
104536,BLOCK,-1,,"{
        STATUS_CALL(v8impl::FunctionCallbackWrapper::NewTemplate(
            env, p->getter, p->data, &getter_tpl));
      }",33,,919,2,,void
104539,BLOCK,1,,<empty>,,,,5,,void
104541,BLOCK,-1,,"STATUS_CALL(v8impl::FunctionCallbackWrapper::NewTemplate(
            env, p->getter, p->data, &getter_tpl))",9,,920,1,,void
104564,BLOCK,-1,,<empty>,9,,920,2,,void
104574,BLOCK,-1,,"{
        STATUS_CALL(v8impl::FunctionCallbackWrapper::NewTemplate(
            env, p->setter, p->data, &setter_tpl));
      }",33,,923,2,,void
104577,BLOCK,1,,<empty>,,,,5,,void
104579,BLOCK,-1,,"STATUS_CALL(v8impl::FunctionCallbackWrapper::NewTemplate(
            env, p->setter, p->data, &setter_tpl))",9,,924,1,,void
104602,BLOCK,-1,,<empty>,9,,924,2,,void
104623,BLOCK,-1,,<empty>,12,,933,1,,void
104630,BLOCK,-1,,"{
      v8::Local<v8::FunctionTemplate> t;
      STATUS_CALL(v8impl::FunctionCallbackWrapper::NewTemplate(
          env, p->method, p->data, &t, v8::Signature::New(isolate, tpl)));

      tpl->PrototypeTemplate()->Set(property_name, t, attributes);
    }",38,,933,2,,void
104642,BLOCK,1,,<empty>,,,,6,,void
104644,BLOCK,-1,,"STATUS_CALL(v8impl::FunctionCallbackWrapper::NewTemplate(
          env, p->method, p->data, &t, v8::Signature::New(isolate, tpl)))",7,,935,1,,void
104675,BLOCK,-1,,<empty>,7,,935,2,,void
104690,BLOCK,-1,,"{
      v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(p->value);
      tpl->PrototypeTemplate()->Set(property_name, value, attributes);
    }",12,,939,1,,void
104755,BLOCK,-1,,"{
    std::vector<napi_property_descriptor> static_descriptors;
    static_descriptors.reserve(static_property_count);

    for (size_t i = 0; i < property_count; i++) {
      const napi_property_descriptor* p = properties + i;
      if ((p->attributes & napi_static) != 0) {
        static_descriptors.push_back(*p);
      }
    }

    STATUS_CALL(napi_define_properties(
        env, *result, static_descriptors.size(), static_descriptors.data()));
  }",34,,949,2,,void
104763,BLOCK,-1,,<empty>,5,,953,1,,void
104773,BLOCK,4,,"{
      const napi_property_descriptor* p = properties + i;
      if ((p->attributes & napi_static) != 0) {
        static_descriptors.push_back(*p);
      }
    }",49,,953,4,,void
104788,BLOCK,-1,,"{
        static_descriptors.push_back(*p);
      }",47,,955,2,,void
104797,BLOCK,1,,<empty>,,,,5,,void
104799,BLOCK,-1,,"STATUS_CALL(napi_define_properties(
        env, *result, static_descriptors.size(), static_descriptors.data()))",5,,960,1,,void
104819,BLOCK,-1,,<empty>,5,,960,2,,void
104826,BLOCK,1,,<empty>,,,,3,,void
104843,BLOCK,-1,,"{
  return napi_get_all_property_names(
      env,
      object,
      napi_key_include_prototypes,
      static_cast<napi_key_filter>(napi_key_enumerable | napi_key_skip_symbols),
      napi_key_numbers_to_strings,
      result);
}",68,,969,4,,void
104865,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;
  CHECK_TO_OBJECT(env, context, obj, object);

  v8::PropertyFilter filter = v8::PropertyFilter::ALL_PROPERTIES;
  if (key_filter & napi_key_writable) {
    filter = static_cast<v8::PropertyFilter>(filter |
                                             v8::PropertyFilter::ONLY_WRITABLE);
  }
  if (key_filter & napi_key_enumerable) {
    filter = static_cast<v8::PropertyFilter>(
        filter | v8::PropertyFilter::ONLY_ENUMERABLE);
  }
  if (key_filter & napi_key_configurable) {
    filter = static_cast<v8::PropertyFilter>(
        filter | v8::PropertyFilter::ONLY_CONFIGURABLE);
  }
  if (key_filter & napi_key_skip_strings) {
    filter = static_cast<v8::PropertyFilter>(filter |
                                             v8::PropertyFilter::SKIP_STRINGS);
  }
  if (key_filter & napi_key_skip_symbols) {
    filter = static_cast<v8::PropertyFilter>(filte...",49,,985,7,,void
104868,BLOCK,1,,<empty>,,,,2,,void
104870,BLOCK,-1,,NAPI_PREAMBLE(env),3,,986,1,,void
104875,BLOCK,-1,,NAPI_PREAMBLE(env),3,,986,2,,void
104880,BLOCK,-1,,NAPI_PREAMBLE(env),3,,986,1,,void
104889,BLOCK,-1,,NAPI_PREAMBLE(env),3,,986,2,,void
104896,BLOCK,-1,,NAPI_PREAMBLE(env),3,,986,1,,void
104903,BLOCK,-1,,NAPI_PREAMBLE(env),3,,986,2,,void
104924,BLOCK,1,,<empty>,,,,3,,void
104926,BLOCK,-1,,"CHECK_ARG(env, result)",3,,987,1,,void
104932,BLOCK,-1,,"CHECK_ARG(env, result)",3,,987,2,,void
104967,BLOCK,1,,<empty>,,,,7,,void
104969,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,991,1,,void
104971,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,991,1,,void
104977,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,991,2,,void
104996,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,991,1,,void
105004,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,991,2,,void
105029,BLOCK,-1,,"{
    filter = static_cast<v8::PropertyFilter>(filter |
                                             v8::PropertyFilter::ONLY_WRITABLE);
  }",39,,994,2,,void
105045,BLOCK,-1,,"{
    filter = static_cast<v8::PropertyFilter>(
        filter | v8::PropertyFilter::ONLY_ENUMERABLE);
  }",41,,998,2,,void
105061,BLOCK,-1,,"{
    filter = static_cast<v8::PropertyFilter>(
        filter | v8::PropertyFilter::ONLY_CONFIGURABLE);
  }",43,,1002,2,,void
105077,BLOCK,-1,,"{
    filter = static_cast<v8::PropertyFilter>(filter |
                                             v8::PropertyFilter::SKIP_STRINGS);
  }",43,,1006,2,,void
105093,BLOCK,-1,,"{
    filter = static_cast<v8::PropertyFilter>(filter |
                                             v8::PropertyFilter::SKIP_SYMBOLS);
  }",43,,1010,2,,void
105109,BLOCK,-1,,"{
    case napi_key_include_prototypes:
      collection_mode = v8::KeyCollectionMode::kIncludePrototypes;
      break;
    case napi_key_own_only:
      collection_mode = v8::KeyCollectionMode::kOwnOnly;
      break;
    default:
      return napi_set_last_error(env, napi_invalid_arg);
  }",21,,1017,2,,void
105137,BLOCK,-1,,"{
    case napi_key_keep_numbers:
      conversion_mode = v8::KeyConversionMode::kKeepNumbers;
      break;
    case napi_key_numbers_to_strings:
      conversion_mode = v8::KeyConversionMode::kConvertToString;
      break;
    default:
      return napi_set_last_error(env, napi_invalid_arg);
  }",27,,1028,2,,void
105190,BLOCK,1,,<empty>,,,,5,,void
105192,BLOCK,-1,,"CHECK_MAYBE_EMPTY_WITH_PREAMBLE(
      env, maybe_all_propertynames, napi_generic_failure)",3,,1046,1,,void
105200,BLOCK,-1,,"CHECK_MAYBE_EMPTY_WITH_PREAMBLE(
      env, maybe_all_propertynames, napi_generic_failure)",3,,1046,2,,void
105226,BLOCK,1,,<empty>,,,,3,,void
105244,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, key);
  CHECK_ARG(env, value);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  v8::Local<v8::Value> k = v8impl::V8LocalValueFromJsValue(key);
  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);

  v8::Maybe<bool> set_maybe = obj->Set(context, k, val);

  RETURN_STATUS_IF_FALSE(env, set_maybe.FromMaybe(false), napi_generic_failure);
  return GET_RETURN_STATUS(env);
}",60,,1057,5,,void
105247,BLOCK,1,,<empty>,,,,2,,void
105249,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1058,1,,void
105254,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1058,2,,void
105259,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1058,1,,void
105268,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1058,2,,void
105275,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1058,1,,void
105282,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1058,2,,void
105303,BLOCK,1,,<empty>,,,,3,,void
105305,BLOCK,-1,,"CHECK_ARG(env, key)",3,,1059,1,,void
105311,BLOCK,-1,,"CHECK_ARG(env, key)",3,,1059,2,,void
105320,BLOCK,1,,<empty>,,,,3,,void
105322,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1060,1,,void
105328,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1060,2,,void
105363,BLOCK,1,,<empty>,,,,7,,void
105365,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1065,1,,void
105367,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1065,1,,void
105373,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1065,2,,void
105392,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1065,1,,void
105400,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1065,2,,void
105461,BLOCK,1,,<empty>,,,,5,,void
105463,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, set_maybe.FromMaybe(false), napi_generic_failure)",3,,1072,1,,void
105471,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, set_maybe.FromMaybe(false), napi_generic_failure)",3,,1072,2,,void
105480,BLOCK,1,,<empty>,,,,3,,void
105498,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);
  CHECK_ARG(env, key);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  v8::Local<v8::Value> k = v8impl::V8LocalValueFromJsValue(key);
  v8::Maybe<bool> has_maybe = obj->Has(context, k);

  CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure);

  *result = has_maybe.FromMaybe(false);
  return GET_RETURN_STATUS(env);
}",56,,1079,5,,void
105501,BLOCK,1,,<empty>,,,,2,,void
105503,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1080,1,,void
105508,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1080,2,,void
105513,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1080,1,,void
105522,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1080,2,,void
105529,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1080,1,,void
105536,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1080,2,,void
105557,BLOCK,1,,<empty>,,,,3,,void
105559,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1081,1,,void
105565,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1081,2,,void
105574,BLOCK,1,,<empty>,,,,3,,void
105576,BLOCK,-1,,"CHECK_ARG(env, key)",3,,1082,1,,void
105582,BLOCK,-1,,"CHECK_ARG(env, key)",3,,1082,2,,void
105617,BLOCK,1,,<empty>,,,,7,,void
105619,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1087,1,,void
105621,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1087,1,,void
105627,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1087,2,,void
105646,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1087,1,,void
105654,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1087,2,,void
105695,BLOCK,1,,<empty>,,,,5,,void
105697,BLOCK,-1,,"CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure)",3,,1092,1,,void
105705,BLOCK,-1,,"CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure)",3,,1092,2,,void
105722,BLOCK,1,,<empty>,,,,3,,void
105740,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, key);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Value> k = v8impl::V8LocalValueFromJsValue(key);
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  auto get_maybe = obj->Get(context, k);

  CHECK_MAYBE_EMPTY(env, get_maybe, napi_generic_failure);

  v8::Local<v8::Value> val = get_maybe.ToLocalChecked();
  *result = v8impl::JsValueFromV8LocalValue(val);
  return GET_RETURN_STATUS(env);
}",62,,1101,5,,void
105743,BLOCK,1,,<empty>,,,,2,,void
105745,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1102,1,,void
105750,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1102,2,,void
105755,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1102,1,,void
105764,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1102,2,,void
105771,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1102,1,,void
105778,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1102,2,,void
105799,BLOCK,1,,<empty>,,,,3,,void
105801,BLOCK,-1,,"CHECK_ARG(env, key)",3,,1103,1,,void
105807,BLOCK,-1,,"CHECK_ARG(env, key)",3,,1103,2,,void
105816,BLOCK,1,,<empty>,,,,3,,void
105818,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1104,1,,void
105824,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1104,2,,void
105874,BLOCK,1,,<empty>,,,,7,,void
105876,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1110,1,,void
105878,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1110,1,,void
105884,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1110,2,,void
105903,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1110,1,,void
105911,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1110,2,,void
105937,BLOCK,1,,<empty>,,,,5,,void
105939,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, get_maybe, napi_generic_failure)",3,,1114,1,,void
105947,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, get_maybe, napi_generic_failure)",3,,1114,2,,void
105978,BLOCK,1,,<empty>,,,,3,,void
105996,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, key);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Value> k = v8impl::V8LocalValueFromJsValue(key);
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);
  v8::Maybe<bool> delete_maybe = obj->Delete(context, k);
  CHECK_MAYBE_NOTHING(env, delete_maybe, napi_generic_failure);

  if (result != nullptr) *result = delete_maybe.FromMaybe(false);

  return GET_RETURN_STATUS(env);
}",59,,1124,5,,void
105999,BLOCK,1,,<empty>,,,,2,,void
106001,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1125,1,,void
106006,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1125,2,,void
106011,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1125,1,,void
106020,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1125,2,,void
106027,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1125,1,,void
106034,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1125,2,,void
106055,BLOCK,1,,<empty>,,,,3,,void
106057,BLOCK,-1,,"CHECK_ARG(env, key)",3,,1126,1,,void
106063,BLOCK,-1,,"CHECK_ARG(env, key)",3,,1126,2,,void
106113,BLOCK,1,,<empty>,,,,7,,void
106115,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1132,1,,void
106117,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1132,1,,void
106123,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1132,2,,void
106142,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1132,1,,void
106150,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1132,2,,void
106176,BLOCK,1,,<empty>,,,,5,,void
106178,BLOCK,-1,,"CHECK_MAYBE_NOTHING(env, delete_maybe, napi_generic_failure)",3,,1134,1,,void
106186,BLOCK,-1,,"CHECK_MAYBE_NOTHING(env, delete_maybe, napi_generic_failure)",3,,1134,2,,void
106196,BLOCK,-1,,<empty>,26,,1136,2,,void
106208,BLOCK,1,,<empty>,,,,3,,void
106226,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, key);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);
  v8::Local<v8::Value> k = v8impl::V8LocalValueFromJsValue(key);
  RETURN_STATUS_IF_FALSE(env, k->IsName(), napi_name_expected);
  v8::Maybe<bool> has_maybe = obj->HasOwnProperty(context, k.As<v8::Name>());
  CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure);
  *result = has_maybe.FromMaybe(false);

  return GET_RETURN_STATUS(env);
}",60,,1144,5,,void
106229,BLOCK,1,,<empty>,,,,2,,void
106231,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1145,1,,void
106236,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1145,2,,void
106241,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1145,1,,void
106250,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1145,2,,void
106257,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1145,1,,void
106264,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1145,2,,void
106285,BLOCK,1,,<empty>,,,,3,,void
106287,BLOCK,-1,,"CHECK_ARG(env, key)",3,,1146,1,,void
106293,BLOCK,-1,,"CHECK_ARG(env, key)",3,,1146,2,,void
106302,BLOCK,1,,<empty>,,,,3,,void
106304,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1147,1,,void
106310,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1147,2,,void
106345,BLOCK,1,,<empty>,,,,7,,void
106347,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1152,1,,void
106349,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1152,1,,void
106355,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1152,2,,void
106374,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1152,1,,void
106382,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1152,2,,void
106417,BLOCK,1,,<empty>,,,,4,,void
106419,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, k->IsName(), napi_name_expected)",3,,1154,1,,void
106426,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, k->IsName(), napi_name_expected)",3,,1154,2,,void
106448,BLOCK,1,,<empty>,,,,5,,void
106450,BLOCK,-1,,"CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure)",3,,1156,1,,void
106458,BLOCK,-1,,"CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure)",3,,1156,2,,void
106475,BLOCK,1,,<empty>,,,,3,,void
106493,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, value);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  v8::Local<v8::Name> key;
  CHECK_NEW_FROM_UTF8(env, key, utf8name);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);

  v8::Maybe<bool> set_maybe = obj->Set(context, key, val);

  RETURN_STATUS_IF_FALSE(env, set_maybe.FromMaybe(false), napi_generic_failure);
  return GET_RETURN_STATUS(env);
}",66,,1165,5,,void
106496,BLOCK,1,,<empty>,,,,2,,void
106498,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1166,1,,void
106503,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1166,2,,void
106508,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1166,1,,void
106517,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1166,2,,void
106524,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1166,1,,void
106531,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1166,2,,void
106552,BLOCK,1,,<empty>,,,,3,,void
106554,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1167,1,,void
106560,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1167,2,,void
106595,BLOCK,1,,<empty>,,,,7,,void
106597,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1172,1,,void
106599,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1172,1,,void
106605,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1172,2,,void
106624,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1172,1,,void
106632,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1172,2,,void
106659,BLOCK,1,,<empty>,,,,6,,void
106661,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1175,1,,void
106671,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1175,1,,void
106681,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1175,2,,void
106688,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1175,1,,void
106694,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1175,2,,void
106722,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1175,1,,void
106730,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1175,2,,void
106776,BLOCK,1,,<empty>,,,,5,,void
106778,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, set_maybe.FromMaybe(false), napi_generic_failure)",3,,1181,1,,void
106786,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, set_maybe.FromMaybe(false), napi_generic_failure)",3,,1181,2,,void
106795,BLOCK,1,,<empty>,,,,3,,void
106813,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  v8::Local<v8::Name> key;
  CHECK_NEW_FROM_UTF8(env, key, utf8name);

  v8::Maybe<bool> has_maybe = obj->Has(context, key);

  CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure);

  *result = has_maybe.FromMaybe(false);
  return GET_RETURN_STATUS(env);
}",62,,1188,5,,void
106816,BLOCK,1,,<empty>,,,,2,,void
106818,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1189,1,,void
106823,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1189,2,,void
106828,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1189,1,,void
106837,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1189,2,,void
106844,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1189,1,,void
106851,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1189,2,,void
106872,BLOCK,1,,<empty>,,,,3,,void
106874,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1190,1,,void
106880,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1190,2,,void
106915,BLOCK,1,,<empty>,,,,7,,void
106917,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1195,1,,void
106919,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1195,1,,void
106925,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1195,2,,void
106944,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1195,1,,void
106952,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1195,2,,void
106979,BLOCK,1,,<empty>,,,,6,,void
106981,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1198,1,,void
106991,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1198,1,,void
107001,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1198,2,,void
107008,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1198,1,,void
107014,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1198,2,,void
107042,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1198,1,,void
107050,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1198,2,,void
107076,BLOCK,1,,<empty>,,,,5,,void
107078,BLOCK,-1,,"CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure)",3,,1202,1,,void
107086,BLOCK,-1,,"CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure)",3,,1202,2,,void
107103,BLOCK,1,,<empty>,,,,3,,void
107121,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Name> key;
  CHECK_NEW_FROM_UTF8(env, key, utf8name);

  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  auto get_maybe = obj->Get(context, key);

  CHECK_MAYBE_EMPTY(env, get_maybe, napi_generic_failure);

  v8::Local<v8::Value> val = get_maybe.ToLocalChecked();
  *result = v8impl::JsValueFromV8LocalValue(val);
  return GET_RETURN_STATUS(env);
}",68,,1211,5,,void
107124,BLOCK,1,,<empty>,,,,2,,void
107126,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1212,1,,void
107131,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1212,2,,void
107136,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1212,1,,void
107145,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1212,2,,void
107152,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1212,1,,void
107159,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1212,2,,void
107180,BLOCK,1,,<empty>,,,,3,,void
107182,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1213,1,,void
107188,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1213,2,,void
107222,BLOCK,1,,<empty>,,,,6,,void
107224,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1218,1,,void
107234,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1218,1,,void
107244,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1218,2,,void
107251,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1218,1,,void
107257,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1218,2,,void
107285,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1218,1,,void
107293,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, key, utf8name)",3,,1218,2,,void
107321,BLOCK,1,,<empty>,,,,7,,void
107323,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1222,1,,void
107325,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1222,1,,void
107331,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1222,2,,void
107350,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1222,1,,void
107358,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1222,2,,void
107384,BLOCK,1,,<empty>,,,,5,,void
107386,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, get_maybe, napi_generic_failure)",3,,1226,1,,void
107394,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, get_maybe, napi_generic_failure)",3,,1226,2,,void
107425,BLOCK,1,,<empty>,,,,3,,void
107443,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, value);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  auto set_maybe = obj->Set(context, index, val);

  RETURN_STATUS_IF_FALSE(env, set_maybe.FromMaybe(false), napi_generic_failure);

  return GET_RETURN_STATUS(env);
}",59,,1236,5,,void
107446,BLOCK,1,,<empty>,,,,2,,void
107448,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1237,1,,void
107453,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1237,2,,void
107458,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1237,1,,void
107467,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1237,2,,void
107474,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1237,1,,void
107481,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1237,2,,void
107502,BLOCK,1,,<empty>,,,,3,,void
107504,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1238,1,,void
107510,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1238,2,,void
107545,BLOCK,1,,<empty>,,,,7,,void
107547,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1243,1,,void
107549,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1243,1,,void
107555,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1243,2,,void
107574,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1243,1,,void
107582,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1243,2,,void
107628,BLOCK,1,,<empty>,,,,5,,void
107630,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, set_maybe.FromMaybe(false), napi_generic_failure)",3,,1248,1,,void
107638,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, set_maybe.FromMaybe(false), napi_generic_failure)",3,,1248,2,,void
107647,BLOCK,1,,<empty>,,,,3,,void
107665,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  v8::Maybe<bool> has_maybe = obj->Has(context, index);

  CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure);

  *result = has_maybe.FromMaybe(false);
  return GET_RETURN_STATUS(env);
}",55,,1256,5,,void
107668,BLOCK,1,,<empty>,,,,2,,void
107670,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1257,1,,void
107675,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1257,2,,void
107680,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1257,1,,void
107689,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1257,2,,void
107696,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1257,1,,void
107703,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1257,2,,void
107724,BLOCK,1,,<empty>,,,,3,,void
107726,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1258,1,,void
107732,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1258,2,,void
107767,BLOCK,1,,<empty>,,,,7,,void
107769,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1263,1,,void
107771,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1263,1,,void
107777,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1263,2,,void
107796,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1263,1,,void
107804,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1263,2,,void
107830,BLOCK,1,,<empty>,,,,5,,void
107832,BLOCK,-1,,"CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure)",3,,1267,1,,void
107840,BLOCK,-1,,"CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure)",3,,1267,2,,void
107857,BLOCK,1,,<empty>,,,,3,,void
107875,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  auto get_maybe = obj->Get(context, index);

  CHECK_MAYBE_EMPTY(env, get_maybe, napi_generic_failure);

  *result = v8impl::JsValueFromV8LocalValue(get_maybe.ToLocalChecked());
  return GET_RETURN_STATUS(env);
}",61,,1276,5,,void
107878,BLOCK,1,,<empty>,,,,2,,void
107880,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1277,1,,void
107885,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1277,2,,void
107890,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1277,1,,void
107899,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1277,2,,void
107906,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1277,1,,void
107913,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1277,2,,void
107934,BLOCK,1,,<empty>,,,,3,,void
107936,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1278,1,,void
107942,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1278,2,,void
107977,BLOCK,1,,<empty>,,,,7,,void
107979,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1283,1,,void
107981,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1283,1,,void
107987,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1283,2,,void
108006,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1283,1,,void
108014,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1283,2,,void
108040,BLOCK,1,,<empty>,,,,5,,void
108042,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, get_maybe, napi_generic_failure)",3,,1287,1,,void
108050,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, get_maybe, napi_generic_failure)",3,,1287,2,,void
108070,BLOCK,1,,<empty>,,,,3,,void
108088,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);
  v8::Maybe<bool> delete_maybe = obj->Delete(context, index);
  CHECK_MAYBE_NOTHING(env, delete_maybe, napi_generic_failure);

  if (result != nullptr) *result = delete_maybe.FromMaybe(false);

  return GET_RETURN_STATUS(env);
}",58,,1296,5,,void
108091,BLOCK,1,,<empty>,,,,2,,void
108093,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1297,1,,void
108098,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1297,2,,void
108103,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1297,1,,void
108112,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1297,2,,void
108119,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1297,1,,void
108126,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1297,2,,void
108173,BLOCK,1,,<empty>,,,,7,,void
108175,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1302,1,,void
108177,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1302,1,,void
108183,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1302,2,,void
108202,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1302,1,,void
108210,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1302,2,,void
108236,BLOCK,1,,<empty>,,,,5,,void
108238,BLOCK,-1,,"CHECK_MAYBE_NOTHING(env, delete_maybe, napi_generic_failure)",3,,1304,1,,void
108246,BLOCK,-1,,"CHECK_MAYBE_NOTHING(env, delete_maybe, napi_generic_failure)",3,,1304,2,,void
108256,BLOCK,-1,,<empty>,26,,1306,2,,void
108268,BLOCK,1,,<empty>,,,,3,,void
108286,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  if (property_count > 0) {
    CHECK_ARG(env, properties);
  }

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Object> obj;
  CHECK_TO_OBJECT(env, context, obj, object);

  for (size_t i = 0; i < property_count; i++) {
    const napi_property_descriptor* p = &properties[i];

    v8::Local<v8::Name> property_name;
    STATUS_CALL(v8impl::V8NameFromPropertyDescriptor(env, p, &property_name));

    if (p->getter != nullptr || p->setter != nullptr) {
      v8::Local<v8::Function> local_getter;
      v8::Local<v8::Function> local_setter;

      if (p->getter != nullptr) {
        STATUS_CALL(v8impl::FunctionCallbackWrapper::NewFunction(
            env, p->getter, p->data, &local_getter));
      }
      if (p->setter != nullptr) {
        STATUS_CALL(v8impl::FunctionCallbackWrapper::NewFunction(
            env, p->setter, p->data, &local_setter));
      }

      v8::PropertyDescriptor descriptor(local_getter, local_setter);
      descriptor....",68,,1315,5,,void
108289,BLOCK,1,,<empty>,,,,2,,void
108291,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1316,1,,void
108296,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1316,2,,void
108301,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1316,1,,void
108310,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1316,2,,void
108317,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1316,1,,void
108324,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1316,2,,void
108346,BLOCK,-1,,"{
    CHECK_ARG(env, properties);
  }",27,,1317,2,,void
108350,BLOCK,1,,<empty>,,,,3,,void
108352,BLOCK,-1,,"CHECK_ARG(env, properties)",5,,1318,1,,void
108358,BLOCK,-1,,"CHECK_ARG(env, properties)",5,,1318,2,,void
108393,BLOCK,1,,<empty>,,,,7,,void
108395,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1324,1,,void
108397,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1324,1,,void
108403,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1324,2,,void
108422,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1324,1,,void
108430,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1324,2,,void
108444,BLOCK,-1,,<empty>,3,,1326,1,,void
108454,BLOCK,4,,"{
    const napi_property_descriptor* p = &properties[i];

    v8::Local<v8::Name> property_name;
    STATUS_CALL(v8impl::V8NameFromPropertyDescriptor(env, p, &property_name));

    if (p->getter != nullptr || p->setter != nullptr) {
      v8::Local<v8::Function> local_getter;
      v8::Local<v8::Function> local_setter;

      if (p->getter != nullptr) {
        STATUS_CALL(v8impl::FunctionCallbackWrapper::NewFunction(
            env, p->getter, p->data, &local_getter));
      }
      if (p->setter != nullptr) {
        STATUS_CALL(v8impl::FunctionCallbackWrapper::NewFunction(
            env, p->setter, p->data, &local_setter));
      }

      v8::PropertyDescriptor descriptor(local_getter, local_setter);
      descriptor.set_enumerable((p->attributes & napi_enumerable) != 0);
      descriptor.set_configurable((p->attributes & napi_configurable) != 0);

      auto define_maybe =
          obj->DefineProperty(context, property_name, descriptor);

      if (!define_maybe.FromMaybe(f...",47,,1326,4,,void
108473,BLOCK,1,,<empty>,,,,4,,void
108475,BLOCK,-1,,"STATUS_CALL(v8impl::V8NameFromPropertyDescriptor(env, p, &property_name))",5,,1330,1,,void
108491,BLOCK,-1,,<empty>,5,,1330,2,,void
108507,BLOCK,-1,,"{
      v8::Local<v8::Function> local_getter;
      v8::Local<v8::Function> local_setter;

      if (p->getter != nullptr) {
        STATUS_CALL(v8impl::FunctionCallbackWrapper::NewFunction(
            env, p->getter, p->data, &local_getter));
      }
      if (p->setter != nullptr) {
        STATUS_CALL(v8impl::FunctionCallbackWrapper::NewFunction(
            env, p->setter, p->data, &local_setter));
      }

      v8::PropertyDescriptor descriptor(local_getter, local_setter);
      descriptor.set_enumerable((p->attributes & napi_enumerable) != 0);
      descriptor.set_configurable((p->attributes & napi_configurable) != 0);

      auto define_maybe =
          obj->DefineProperty(context, property_name, descriptor);

      if (!define_maybe.FromMaybe(false)) {
        return napi_set_last_error(env, napi_invalid_arg);
      }
    }",55,,1332,2,,void
108532,BLOCK,-1,,"{
        STATUS_CALL(v8impl::FunctionCallbackWrapper::NewFunction(
            env, p->getter, p->data, &local_getter));
      }",33,,1336,2,,void
108535,BLOCK,1,,<empty>,,,,5,,void
108537,BLOCK,-1,,"STATUS_CALL(v8impl::FunctionCallbackWrapper::NewFunction(
            env, p->getter, p->data, &local_getter))",9,,1337,1,,void
108560,BLOCK,-1,,<empty>,9,,1337,2,,void
108570,BLOCK,-1,,"{
        STATUS_CALL(v8impl::FunctionCallbackWrapper::NewFunction(
            env, p->setter, p->data, &local_setter));
      }",33,,1340,2,,void
108573,BLOCK,1,,<empty>,,,,5,,void
108575,BLOCK,-1,,"STATUS_CALL(v8impl::FunctionCallbackWrapper::NewFunction(
            env, p->setter, p->data, &local_setter))",9,,1341,1,,void
108598,BLOCK,-1,,<empty>,9,,1341,2,,void
108645,BLOCK,-1,,"{
        return napi_set_last_error(env, napi_invalid_arg);
      }",43,,1352,2,,void
108651,BLOCK,-1,,<empty>,12,,1355,1,,void
108658,BLOCK,-1,,"{
      v8::Local<v8::Function> method;
      STATUS_CALL(v8impl::FunctionCallbackWrapper::NewFunction(
          env, p->method, p->data, &method));
      v8::PropertyDescriptor descriptor(method,
                                        (p->attributes & napi_writable) != 0);
      descriptor.set_enumerable((p->attributes & napi_enumerable) != 0);
      descriptor.set_configurable((p->attributes & napi_configurable) != 0);

      auto define_maybe =
          obj->DefineProperty(context, property_name, descriptor);

      if (!define_maybe.FromMaybe(false)) {
        return napi_set_last_error(env, napi_generic_failure);
      }
    }",38,,1355,2,,void
108670,BLOCK,1,,<empty>,,,,5,,void
108672,BLOCK,-1,,"STATUS_CALL(v8impl::FunctionCallbackWrapper::NewFunction(
          env, p->method, p->data, &method))",7,,1357,1,,void
108695,BLOCK,-1,,<empty>,7,,1357,2,,void
108748,BLOCK,-1,,"{
        return napi_set_last_error(env, napi_generic_failure);
      }",43,,1367,2,,void
108754,BLOCK,-1,,"{
      v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(p->value);
      bool defined_successfully = false;

      if ((p->attributes & napi_enumerable) &&
          (p->attributes & napi_writable) &&
          (p->attributes & napi_configurable)) {
        // Use a fast path for this type of data property.
        auto define_maybe =
            obj->CreateDataProperty(context, property_name, value);
        defined_successfully = define_maybe.FromMaybe(false);
      } else {
        v8::PropertyDescriptor descriptor(value,
                                          (p->attributes & napi_writable) != 0);
        descriptor.set_enumerable((p->attributes & napi_enumerable) != 0);
        descriptor.set_configurable((p->attributes & napi_configurable) != 0);

        auto define_maybe =
            obj->DefineProperty(context, property_name, descriptor);
        defined_successfully = define_maybe.FromMaybe(false);
      }

      if (!defined_successfully) {
        return...",12,,1370,1,,void
108794,BLOCK,-1,,"{
        // Use a fast path for this type of data property.
        auto define_maybe =
            obj->CreateDataProperty(context, property_name, value);
        defined_successfully = define_maybe.FromMaybe(false);
      }",48,,1376,2,,void
108813,BLOCK,-1,,"{
        v8::PropertyDescriptor descriptor(value,
                                          (p->attributes & napi_writable) != 0);
        descriptor.set_enumerable((p->attributes & napi_enumerable) != 0);
        descriptor.set_configurable((p->attributes & napi_configurable) != 0);

        auto define_maybe =
            obj->DefineProperty(context, property_name, descriptor);
        defined_successfully = define_maybe.FromMaybe(false);
      }",14,,1381,1,,void
108866,BLOCK,-1,,"{
        return napi_set_last_error(env, napi_invalid_arg);
      }",34,,1392,2,,void
108874,BLOCK,1,,<empty>,,,,3,,void
108890,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  v8::Maybe<bool> set_frozen =
      obj->SetIntegrityLevel(context, v8::IntegrityLevel::kFrozen);

  RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, set_frozen.FromMaybe(false), napi_generic_failure);

  return GET_RETURN_STATUS(env);
}",76,,1401,3,,void
108893,BLOCK,1,,<empty>,,,,2,,void
108895,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1402,1,,void
108900,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1402,2,,void
108905,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1402,1,,void
108914,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1402,2,,void
108921,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1402,1,,void
108928,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1402,2,,void
108975,BLOCK,1,,<empty>,,,,7,,void
108977,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1407,1,,void
108979,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1407,1,,void
108985,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1407,2,,void
109004,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1407,1,,void
109012,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1407,2,,void
109046,BLOCK,1,,<empty>,,,,6,,void
109048,BLOCK,-1,,"RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, set_frozen.FromMaybe(false), napi_generic_failure)",3,,1412,1,,void
109056,BLOCK,-1,,"RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, set_frozen.FromMaybe(false), napi_generic_failure)",3,,1412,2,,void
109071,BLOCK,1,,<empty>,,,,3,,void
109087,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  v8::Maybe<bool> set_sealed =
      obj->SetIntegrityLevel(context, v8::IntegrityLevel::kSealed);

  RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, set_sealed.FromMaybe(false), napi_generic_failure);

  return GET_RETURN_STATUS(env);
}",74,,1418,3,,void
109090,BLOCK,1,,<empty>,,,,2,,void
109092,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1419,1,,void
109097,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1419,2,,void
109102,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1419,1,,void
109111,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1419,2,,void
109118,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1419,1,,void
109125,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1419,2,,void
109172,BLOCK,1,,<empty>,,,,7,,void
109174,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1424,1,,void
109176,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1424,1,,void
109182,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1424,2,,void
109201,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1424,1,,void
109209,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1424,2,,void
109243,BLOCK,1,,<empty>,,,,6,,void
109245,BLOCK,-1,,"RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, set_sealed.FromMaybe(false), napi_generic_failure)",3,,1429,1,,void
109253,BLOCK,-1,,"RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, set_sealed.FromMaybe(false), napi_generic_failure)",3,,1429,2,,void
109268,BLOCK,1,,<empty>,,,,3,,void
109285,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);

  *result = val->IsArray();
  return napi_clear_last_error(env);
}",52,,1437,4,,void
109288,BLOCK,1,,<empty>,,,,2,,void
109290,BLOCK,-1,,CHECK_ENV(env),3,,1438,1,,void
109295,BLOCK,-1,,CHECK_ENV(env),3,,1438,2,,void
109302,BLOCK,1,,<empty>,,,,3,,void
109304,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1439,1,,void
109310,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1439,2,,void
109319,BLOCK,1,,<empty>,,,,3,,void
109321,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1440,1,,void
109327,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1440,2,,void
109364,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  RETURN_STATUS_IF_FALSE(env, val->IsArray(), napi_array_expected);

  v8::Local<v8::Array> arr = val.As<v8::Array>();
  *result = arr->Length();

  return GET_RETURN_STATUS(env);
}",64,,1450,4,,void
109367,BLOCK,1,,<empty>,,,,2,,void
109369,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1451,1,,void
109374,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1451,2,,void
109379,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1451,1,,void
109388,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1451,2,,void
109395,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1451,1,,void
109402,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1451,2,,void
109423,BLOCK,1,,<empty>,,,,3,,void
109425,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1452,1,,void
109431,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1452,2,,void
109440,BLOCK,1,,<empty>,,,,3,,void
109442,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1453,1,,void
109448,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1453,2,,void
109476,BLOCK,1,,<empty>,,,,4,,void
109478,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsArray(), napi_array_expected)",3,,1456,1,,void
109485,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsArray(), napi_array_expected)",3,,1456,2,,void
109515,BLOCK,1,,<empty>,,,,3,,void
109533,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, lhs);
  CHECK_ARG(env, rhs);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> a = v8impl::V8LocalValueFromJsValue(lhs);
  v8::Local<v8::Value> b = v8impl::V8LocalValueFromJsValue(rhs);

  *result = a->StrictEquals(b);
  return GET_RETURN_STATUS(env);
}",57,,1467,5,,void
109536,BLOCK,1,,<empty>,,,,2,,void
109538,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1468,1,,void
109543,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1468,2,,void
109548,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1468,1,,void
109557,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1468,2,,void
109564,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1468,1,,void
109571,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1468,2,,void
109592,BLOCK,1,,<empty>,,,,3,,void
109594,BLOCK,-1,,"CHECK_ARG(env, lhs)",3,,1469,1,,void
109600,BLOCK,-1,,"CHECK_ARG(env, lhs)",3,,1469,2,,void
109609,BLOCK,1,,<empty>,,,,3,,void
109611,BLOCK,-1,,"CHECK_ARG(env, rhs)",3,,1470,1,,void
109617,BLOCK,-1,,"CHECK_ARG(env, rhs)",3,,1470,2,,void
109626,BLOCK,1,,<empty>,,,,3,,void
109628,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1471,1,,void
109634,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1471,2,,void
109681,BLOCK,1,,<empty>,,,,3,,void
109698,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Object> obj;
  CHECK_TO_OBJECT(env, context, obj, object);

  v8::Local<v8::Value> val = obj->GetPrototype();
  *result = v8impl::JsValueFromV8LocalValue(val);
  return GET_RETURN_STATUS(env);
}",63,,1482,4,,void
109701,BLOCK,1,,<empty>,,,,2,,void
109703,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1483,1,,void
109708,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1483,2,,void
109713,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1483,1,,void
109722,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1483,2,,void
109729,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1483,1,,void
109736,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1483,2,,void
109757,BLOCK,1,,<empty>,,,,3,,void
109759,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1484,1,,void
109765,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1484,2,,void
109800,BLOCK,1,,<empty>,,,,7,,void
109802,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1489,1,,void
109804,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1489,1,,void
109810,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1489,2,,void
109829,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1489,1,,void
109837,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, obj, object)",3,,1489,2,,void
109875,BLOCK,1,,<empty>,,,,3,,void
109891,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsValueFromV8LocalValue(v8::Object::New(env->isolate));

  return napi_clear_last_error(env);
}",77,,1496,3,,void
109894,BLOCK,1,,<empty>,,,,2,,void
109896,BLOCK,-1,,CHECK_ENV(env),3,,1497,1,,void
109901,BLOCK,-1,,CHECK_ENV(env),3,,1497,2,,void
109908,BLOCK,1,,<empty>,,,,3,,void
109910,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1498,1,,void
109916,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1498,2,,void
109946,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsValueFromV8LocalValue(v8::Array::New(env->isolate));

  return napi_clear_last_error(env);
}",76,,1505,3,,void
109949,BLOCK,1,,<empty>,,,,2,,void
109951,BLOCK,-1,,CHECK_ENV(env),3,,1506,1,,void
109956,BLOCK,-1,,CHECK_ENV(env),3,,1506,2,,void
109963,BLOCK,1,,<empty>,,,,3,,void
109965,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1507,1,,void
109971,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1507,2,,void
110002,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result =
      v8impl::JsValueFromV8LocalValue(v8::Array::New(env->isolate, length));

  return napi_clear_last_error(env);
}",74,,1516,4,,void
110005,BLOCK,1,,<empty>,,,,2,,void
110007,BLOCK,-1,,CHECK_ENV(env),3,,1517,1,,void
110012,BLOCK,-1,,CHECK_ENV(env),3,,1517,2,,void
110019,BLOCK,1,,<empty>,,,,3,,void
110021,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1518,1,,void
110027,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1518,2,,void
110058,BLOCK,-1,,"{
  return v8impl::NewString(env, str, length, result, [&](v8::Isolate* isolate) {
    return v8::String::NewFromOneByte(isolate,
                                      reinterpret_cast<const uint8_t*>(str),
                                      v8::NewStringType::kNormal,
                                      length);
  });
}",70,,1529,5,,void
110074,BLOCK,-1,,"{
  return v8impl::NewString(env, str, length, result, [&](v8::Isolate* isolate) {
    return v8::String::NewFromUtf8(
        isolate, str, v8::NewStringType::kNormal, static_cast<int>(length));
  });
}",68,,1541,5,,void
110090,BLOCK,-1,,"{
  return v8impl::NewString(env, str, length, result, [&](v8::Isolate* isolate) {
    return v8::String::NewFromTwoByte(isolate,
                                      reinterpret_cast<const uint16_t*>(str),
                                      v8::NewStringType::kNormal,
                                      length);
  });
}",69,,1551,5,,void
110106,BLOCK,-1,,"{
  return v8impl::NewExternalString(
      env,
      str,
      length,
      finalize_callback,
      finalize_hint,
      result,
      copied,
      napi_create_string_latin1,
      [&](v8::Isolate* isolate) {
        if (length == NAPI_AUTO_LENGTH) {
          length = (std::string_view(str)).length();
        }
        auto resource = new v8impl::ExternalOneByteStringResource(
            env, str, length, finalize_callback, finalize_hint);
        return v8::String::NewExternalOneByte(isolate, resource);
      });
}",54,,1567,8,,void
110126,BLOCK,-1,,"{
  return v8impl::NewExternalString(
      env,
      str,
      length,
      finalize_callback,
      finalize_hint,
      result,
      copied,
      napi_create_string_utf16,
      [&](v8::Isolate* isolate) {
        if (length == NAPI_AUTO_LENGTH) {
          length = (std::u16string_view(str)).length();
        }
        auto resource = new v8impl::ExternalStringResource(
            env, str, length, finalize_callback, finalize_hint);
        return v8::String::NewExternalTwoByte(isolate, resource);
      });
}",53,,1594,8,,void
110147,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result =
      v8impl::JsValueFromV8LocalValue(v8::Number::New(env->isolate, value));

  return napi_clear_last_error(env);
}",63,,1616,4,,void
110150,BLOCK,1,,<empty>,,,,2,,void
110152,BLOCK,-1,,CHECK_ENV(env),3,,1617,1,,void
110157,BLOCK,-1,,CHECK_ENV(env),3,,1617,2,,void
110164,BLOCK,1,,<empty>,,,,3,,void
110166,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1618,1,,void
110172,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1618,2,,void
110204,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result =
      v8impl::JsValueFromV8LocalValue(v8::Integer::New(env->isolate, value));

  return napi_clear_last_error(env);
}",62,,1628,4,,void
110207,BLOCK,1,,<empty>,,,,2,,void
110209,BLOCK,-1,,CHECK_ENV(env),3,,1629,1,,void
110214,BLOCK,-1,,CHECK_ENV(env),3,,1629,2,,void
110221,BLOCK,1,,<empty>,,,,3,,void
110223,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1630,1,,void
110229,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1630,2,,void
110261,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsValueFromV8LocalValue(
      v8::Integer::NewFromUnsigned(env->isolate, value));

  return napi_clear_last_error(env);
}",63,,1640,4,,void
110264,BLOCK,1,,<empty>,,,,2,,void
110266,BLOCK,-1,,CHECK_ENV(env),3,,1641,1,,void
110271,BLOCK,-1,,CHECK_ENV(env),3,,1641,2,,void
110278,BLOCK,1,,<empty>,,,,3,,void
110280,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1642,1,,void
110286,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1642,2,,void
110318,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsValueFromV8LocalValue(
      v8::Number::New(env->isolate, static_cast<double>(value)));

  return napi_clear_last_error(env);
}",62,,1652,4,,void
110321,BLOCK,1,,<empty>,,,,2,,void
110323,BLOCK,-1,,CHECK_ENV(env),3,,1653,1,,void
110328,BLOCK,-1,,CHECK_ENV(env),3,,1653,2,,void
110335,BLOCK,1,,<empty>,,,,3,,void
110337,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1654,1,,void
110343,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1654,2,,void
110377,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result =
      v8impl::JsValueFromV8LocalValue(v8::BigInt::New(env->isolate, value));

  return napi_clear_last_error(env);
}",69,,1664,4,,void
110380,BLOCK,1,,<empty>,,,,2,,void
110382,BLOCK,-1,,CHECK_ENV(env),3,,1665,1,,void
110387,BLOCK,-1,,CHECK_ENV(env),3,,1665,2,,void
110394,BLOCK,1,,<empty>,,,,3,,void
110396,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1666,1,,void
110402,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1666,2,,void
110434,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsValueFromV8LocalValue(
      v8::BigInt::NewFromUnsigned(env->isolate, value));

  return napi_clear_last_error(env);
}",70,,1676,4,,void
110437,BLOCK,1,,<empty>,,,,2,,void
110439,BLOCK,-1,,CHECK_ENV(env),3,,1677,1,,void
110444,BLOCK,-1,,CHECK_ENV(env),3,,1677,2,,void
110451,BLOCK,1,,<empty>,,,,3,,void
110453,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1678,1,,void
110459,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1678,2,,void
110493,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, words);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();

  RETURN_STATUS_IF_FALSE(env, word_count <= INT_MAX, napi_invalid_arg);

  v8::MaybeLocal<v8::BigInt> b =
      v8::BigInt::NewFromWords(context, sign_bit, word_count, words);

  CHECK_MAYBE_EMPTY_WITH_PREAMBLE(env, b, napi_generic_failure);

  *result = v8impl::JsValueFromV8LocalValue(b.ToLocalChecked());
  return GET_RETURN_STATUS(env);
}",69,,1690,6,,void
110496,BLOCK,1,,<empty>,,,,2,,void
110498,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1691,1,,void
110503,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1691,2,,void
110508,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1691,1,,void
110517,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1691,2,,void
110524,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1691,1,,void
110531,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1691,2,,void
110552,BLOCK,1,,<empty>,,,,3,,void
110554,BLOCK,-1,,"CHECK_ARG(env, words)",3,,1692,1,,void
110560,BLOCK,-1,,"CHECK_ARG(env, words)",3,,1692,2,,void
110569,BLOCK,1,,<empty>,,,,3,,void
110571,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1693,1,,void
110577,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1693,2,,void
110600,BLOCK,1,,<empty>,,,,3,,void
110602,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, word_count <= INT_MAX, napi_invalid_arg)",3,,1697,1,,void
110608,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, word_count <= INT_MAX, napi_invalid_arg)",3,,1697,2,,void
110638,BLOCK,1,,<empty>,,,,5,,void
110640,BLOCK,-1,,"CHECK_MAYBE_EMPTY_WITH_PREAMBLE(env, b, napi_generic_failure)",3,,1702,1,,void
110648,BLOCK,-1,,"CHECK_MAYBE_EMPTY_WITH_PREAMBLE(env, b, napi_generic_failure)",3,,1702,2,,void
110674,BLOCK,1,,<empty>,,,,3,,void
110691,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  v8::Isolate* isolate = env->isolate;

  if (value) {
    *result = v8impl::JsValueFromV8LocalValue(v8::True(isolate));
  } else {
    *result = v8impl::JsValueFromV8LocalValue(v8::False(isolate));
  }

  return napi_clear_last_error(env);
}",61,,1710,4,,void
110694,BLOCK,1,,<empty>,,,,2,,void
110696,BLOCK,-1,,CHECK_ENV(env),3,,1711,1,,void
110701,BLOCK,-1,,CHECK_ENV(env),3,,1711,2,,void
110708,BLOCK,1,,<empty>,,,,3,,void
110710,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1712,1,,void
110716,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1712,2,,void
110730,BLOCK,-1,,"{
    *result = v8impl::JsValueFromV8LocalValue(v8::True(isolate));
  }",14,,1716,2,,void
110744,BLOCK,-1,,"{
    *result = v8impl::JsValueFromV8LocalValue(v8::False(isolate));
  }",10,,1718,1,,void
110766,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  v8::Isolate* isolate = env->isolate;

  if (description == nullptr) {
    *result = v8impl::JsValueFromV8LocalValue(v8::Symbol::New(isolate));
  } else {
    v8::Local<v8::Value> desc = v8impl::V8LocalValueFromJsValue(description);
    RETURN_STATUS_IF_FALSE(env, desc->IsString(), napi_string_expected);

    *result = v8impl::JsValueFromV8LocalValue(
        v8::Symbol::New(isolate, desc.As<v8::String>()));
  }

  return napi_clear_last_error(env);
}",63,,1727,4,,void
110769,BLOCK,1,,<empty>,,,,2,,void
110771,BLOCK,-1,,CHECK_ENV(env),3,,1728,1,,void
110776,BLOCK,-1,,CHECK_ENV(env),3,,1728,2,,void
110783,BLOCK,1,,<empty>,,,,3,,void
110785,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1729,1,,void
110791,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1729,2,,void
110807,BLOCK,-1,,"{
    *result = v8impl::JsValueFromV8LocalValue(v8::Symbol::New(isolate));
  }",31,,1733,2,,void
110823,BLOCK,-1,,"{
    v8::Local<v8::Value> desc = v8impl::V8LocalValueFromJsValue(description);
    RETURN_STATUS_IF_FALSE(env, desc->IsString(), napi_string_expected);

    *result = v8impl::JsValueFromV8LocalValue(
        v8::Symbol::New(isolate, desc.As<v8::String>()));
  }",10,,1735,1,,void
110846,BLOCK,1,,<empty>,,,,4,,void
110848,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, desc->IsString(), napi_string_expected)",5,,1737,1,,void
110855,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, desc->IsString(), napi_string_expected)",5,,1737,2,,void
110889,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  napi_value js_description_string;
  STATUS_CALL(napi_create_string_utf8(
      env, utf8description, length, &js_description_string));
  v8::Local<v8::String> description_string =
      v8impl::V8LocalValueFromJsValue(js_description_string).As<v8::String>();

  *result = v8impl::JsValueFromV8LocalValue(
      v8::Symbol::For(env->isolate, description_string));

  return napi_clear_last_error(env);
}",64,,1749,5,,void
110892,BLOCK,1,,<empty>,,,,2,,void
110894,BLOCK,-1,,CHECK_ENV(env),3,,1750,1,,void
110899,BLOCK,-1,,CHECK_ENV(env),3,,1750,2,,void
110906,BLOCK,1,,<empty>,,,,3,,void
110908,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1751,1,,void
110914,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1751,2,,void
110923,BLOCK,1,,<empty>,,,,4,,void
110925,BLOCK,-1,,"STATUS_CALL(napi_create_string_utf8(
      env, utf8description, length, &js_description_string))",3,,1754,1,,void
110939,BLOCK,-1,,<empty>,3,,1754,2,,void
110988,BLOCK,-1,,"{
  if ((code != nullptr) || (code_cstring != nullptr)) {
    v8::Local<v8::Context> context = env->context();
    v8::Local<v8::Object> err_object = error.As<v8::Object>();

    v8::Local<v8::Value> code_value = v8impl::V8LocalValueFromJsValue(code);
    if (code != nullptr) {
      code_value = v8impl::V8LocalValueFromJsValue(code);
      RETURN_STATUS_IF_FALSE(env, code_value->IsString(), napi_string_expected);
    } else {
      CHECK_NEW_FROM_UTF8(env, code_value, code_cstring);
    }

    v8::Local<v8::Name> code_key;
    CHECK_NEW_FROM_UTF8(env, code_key, ""code"");

    v8::Maybe<bool> set_maybe = err_object->Set(context, code_key, code_value);
    RETURN_STATUS_IF_FALSE(
        env, set_maybe.FromMaybe(false), napi_generic_failure);
  }
  return napi_ok;
}",68,,1768,5,,void
110997,BLOCK,-1,,"{
    v8::Local<v8::Context> context = env->context();
    v8::Local<v8::Object> err_object = error.As<v8::Object>();

    v8::Local<v8::Value> code_value = v8impl::V8LocalValueFromJsValue(code);
    if (code != nullptr) {
      code_value = v8impl::V8LocalValueFromJsValue(code);
      RETURN_STATUS_IF_FALSE(env, code_value->IsString(), napi_string_expected);
    } else {
      CHECK_NEW_FROM_UTF8(env, code_value, code_cstring);
    }

    v8::Local<v8::Name> code_key;
    CHECK_NEW_FROM_UTF8(env, code_key, ""code"");

    v8::Maybe<bool> set_maybe = err_object->Set(context, code_key, code_value);
    RETURN_STATUS_IF_FALSE(
        env, set_maybe.FromMaybe(false), napi_generic_failure);
  }",55,,1769,2,,void
111045,BLOCK,-1,,"{
      code_value = v8impl::V8LocalValueFromJsValue(code);
      RETURN_STATUS_IF_FALSE(env, code_value->IsString(), napi_string_expected);
    }",26,,1774,2,,void
111060,BLOCK,1,,<empty>,,,,4,,void
111062,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, code_value->IsString(), napi_string_expected)",7,,1776,1,,void
111069,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, code_value->IsString(), napi_string_expected)",7,,1776,2,,void
111076,BLOCK,-1,,"{
      CHECK_NEW_FROM_UTF8(env, code_value, code_cstring);
    }",12,,1777,1,,void
111082,BLOCK,1,,<empty>,,,,6,,void
111084,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, code_value, code_cstring)",7,,1778,1,,void
111094,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, code_value, code_cstring)",7,,1778,1,,void
111104,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, code_value, code_cstring)",7,,1778,2,,void
111111,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, code_value, code_cstring)",7,,1778,1,,void
111117,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, code_value, code_cstring)",7,,1778,2,,void
111145,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, code_value, code_cstring)",7,,1778,1,,void
111153,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, code_value, code_cstring)",7,,1778,2,,void
111180,BLOCK,1,,<empty>,,,,6,,void
111182,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, code_key, ""code"")",5,,1782,1,,void
111192,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, code_key, ""code"")",5,,1782,1,,void
111202,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, code_key, ""code"")",5,,1782,2,,void
111209,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, code_key, ""code"")",5,,1782,1,,void
111215,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, code_key, ""code"")",5,,1782,2,,void
111243,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, code_key, ""code"")",5,,1782,1,,void
111251,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, code_key, ""code"")",5,,1782,2,,void
111282,BLOCK,1,,<empty>,,,,5,,void
111284,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(
        env, set_maybe.FromMaybe(false), napi_generic_failure)",5,,1785,1,,void
111292,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(
        env, set_maybe.FromMaybe(false), napi_generic_failure)",5,,1785,2,,void
111307,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, msg);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> message_value = v8impl::V8LocalValueFromJsValue(msg);
  RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected);

  v8::Local<v8::Value> error_obj =
      v8::Exception::Error(message_value.As<v8::String>());
  STATUS_CALL(set_error_code(env, error_obj, code, nullptr));

  *result = v8impl::JsValueFromV8LocalValue(error_obj);

  return napi_clear_last_error(env);
}",62,,1794,5,,void
111310,BLOCK,1,,<empty>,,,,2,,void
111312,BLOCK,-1,,CHECK_ENV(env),3,,1795,1,,void
111317,BLOCK,-1,,CHECK_ENV(env),3,,1795,2,,void
111324,BLOCK,1,,<empty>,,,,3,,void
111326,BLOCK,-1,,"CHECK_ARG(env, msg)",3,,1796,1,,void
111332,BLOCK,-1,,"CHECK_ARG(env, msg)",3,,1796,2,,void
111341,BLOCK,1,,<empty>,,,,3,,void
111343,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1797,1,,void
111349,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1797,2,,void
111377,BLOCK,1,,<empty>,,,,4,,void
111379,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected)",3,,1800,1,,void
111386,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected)",3,,1800,2,,void
111414,BLOCK,1,,<empty>,,,,3,,void
111416,BLOCK,-1,,"STATUS_CALL(set_error_code(env, error_obj, code, nullptr))",3,,1804,1,,void
111429,BLOCK,-1,,<empty>,3,,1804,2,,void
111451,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, msg);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> message_value = v8impl::V8LocalValueFromJsValue(msg);
  RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected);

  v8::Local<v8::Value> error_obj =
      v8::Exception::TypeError(message_value.As<v8::String>());
  STATUS_CALL(set_error_code(env, error_obj, code, nullptr));

  *result = v8impl::JsValueFromV8LocalValue(error_obj);

  return napi_clear_last_error(env);
}",67,,1814,5,,void
111454,BLOCK,1,,<empty>,,,,2,,void
111456,BLOCK,-1,,CHECK_ENV(env),3,,1815,1,,void
111461,BLOCK,-1,,CHECK_ENV(env),3,,1815,2,,void
111468,BLOCK,1,,<empty>,,,,3,,void
111470,BLOCK,-1,,"CHECK_ARG(env, msg)",3,,1816,1,,void
111476,BLOCK,-1,,"CHECK_ARG(env, msg)",3,,1816,2,,void
111485,BLOCK,1,,<empty>,,,,3,,void
111487,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1817,1,,void
111493,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1817,2,,void
111521,BLOCK,1,,<empty>,,,,4,,void
111523,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected)",3,,1820,1,,void
111530,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected)",3,,1820,2,,void
111558,BLOCK,1,,<empty>,,,,3,,void
111560,BLOCK,-1,,"STATUS_CALL(set_error_code(env, error_obj, code, nullptr))",3,,1824,1,,void
111573,BLOCK,-1,,<empty>,3,,1824,2,,void
111595,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, msg);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> message_value = v8impl::V8LocalValueFromJsValue(msg);
  RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected);

  v8::Local<v8::Value> error_obj =
      v8::Exception::RangeError(message_value.As<v8::String>());
  STATUS_CALL(set_error_code(env, error_obj, code, nullptr));

  *result = v8impl::JsValueFromV8LocalValue(error_obj);

  return napi_clear_last_error(env);
}",68,,1834,5,,void
111598,BLOCK,1,,<empty>,,,,2,,void
111600,BLOCK,-1,,CHECK_ENV(env),3,,1835,1,,void
111605,BLOCK,-1,,CHECK_ENV(env),3,,1835,2,,void
111612,BLOCK,1,,<empty>,,,,3,,void
111614,BLOCK,-1,,"CHECK_ARG(env, msg)",3,,1836,1,,void
111620,BLOCK,-1,,"CHECK_ARG(env, msg)",3,,1836,2,,void
111629,BLOCK,1,,<empty>,,,,3,,void
111631,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1837,1,,void
111637,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1837,2,,void
111665,BLOCK,1,,<empty>,,,,4,,void
111667,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected)",3,,1840,1,,void
111674,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected)",3,,1840,2,,void
111702,BLOCK,1,,<empty>,,,,3,,void
111704,BLOCK,-1,,"STATUS_CALL(set_error_code(env, error_obj, code, nullptr))",3,,1844,1,,void
111717,BLOCK,-1,,<empty>,3,,1844,2,,void
111739,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, msg);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> message_value = v8impl::V8LocalValueFromJsValue(msg);
  RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected);

  v8::Local<v8::Value> error_obj =
      v8::Exception::SyntaxError(message_value.As<v8::String>());
  STATUS_CALL(set_error_code(env, error_obj, code, nullptr));

  *result = v8impl::JsValueFromV8LocalValue(error_obj);

  return napi_clear_last_error(env);
}",73,,1854,5,,void
111742,BLOCK,1,,<empty>,,,,2,,void
111744,BLOCK,-1,,CHECK_ENV(env),3,,1855,1,,void
111749,BLOCK,-1,,CHECK_ENV(env),3,,1855,2,,void
111756,BLOCK,1,,<empty>,,,,3,,void
111758,BLOCK,-1,,"CHECK_ARG(env, msg)",3,,1856,1,,void
111764,BLOCK,-1,,"CHECK_ARG(env, msg)",3,,1856,2,,void
111773,BLOCK,1,,<empty>,,,,3,,void
111775,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1857,1,,void
111781,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1857,2,,void
111809,BLOCK,1,,<empty>,,,,4,,void
111811,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected)",3,,1860,1,,void
111818,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected)",3,,1860,2,,void
111846,BLOCK,1,,<empty>,,,,3,,void
111848,BLOCK,-1,,"STATUS_CALL(set_error_code(env, error_obj, code, nullptr))",3,,1864,1,,void
111861,BLOCK,-1,,<empty>,3,,1864,2,,void
111882,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> v = v8impl::V8LocalValueFromJsValue(value);

  if (v->IsNumber()) {
    *result = napi_number;
  } else if (v->IsBigInt()) {
    *result = napi_bigint;
  } else if (v->IsString()) {
    *result = napi_string;
  } else if (v->IsFunction()) {
    // This test has to come before IsObject because IsFunction
    // implies IsObject
    *result = napi_function;
  } else if (v->IsExternal()) {
    // This test has to come before IsObject because IsExternal
    // implies IsObject
    *result = napi_external;
  } else if (v->IsObject()) {
    *result = napi_object;
  } else if (v->IsBoolean()) {
    *result = napi_boolean;
  } else if (v->IsUndefined()) {
    *result = napi_undefined;
  } else if (v->IsSymbol()) {
    *result = napi_symbol;
  } else if (v->IsNull()) {
    *result = napi_null;
  } e...",60,,1873,4,,void
111885,BLOCK,1,,<empty>,,,,2,,void
111887,BLOCK,-1,,CHECK_ENV(env),3,,1876,1,,void
111892,BLOCK,-1,,CHECK_ENV(env),3,,1876,2,,void
111899,BLOCK,1,,<empty>,,,,3,,void
111901,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1877,1,,void
111907,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1877,2,,void
111916,BLOCK,1,,<empty>,,,,3,,void
111918,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1878,1,,void
111924,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1878,2,,void
111950,BLOCK,-1,,"{
    *result = napi_number;
  }",22,,1882,2,,void
111956,BLOCK,-1,,<empty>,10,,1884,1,,void
111962,BLOCK,-1,,"{
    *result = napi_bigint;
  }",29,,1884,2,,void
111968,BLOCK,-1,,<empty>,10,,1886,1,,void
111974,BLOCK,-1,,"{
    *result = napi_string;
  }",29,,1886,2,,void
111980,BLOCK,-1,,<empty>,10,,1888,1,,void
111986,BLOCK,-1,,"{
    // This test has to come before IsObject because IsFunction
    // implies IsObject
    *result = napi_function;
  }",31,,1888,2,,void
111992,BLOCK,-1,,<empty>,10,,1892,1,,void
111998,BLOCK,-1,,"{
    // This test has to come before IsObject because IsExternal
    // implies IsObject
    *result = napi_external;
  }",31,,1892,2,,void
112004,BLOCK,-1,,<empty>,10,,1896,1,,void
112010,BLOCK,-1,,"{
    *result = napi_object;
  }",29,,1896,2,,void
112016,BLOCK,-1,,<empty>,10,,1898,1,,void
112022,BLOCK,-1,,"{
    *result = napi_boolean;
  }",30,,1898,2,,void
112028,BLOCK,-1,,<empty>,10,,1900,1,,void
112034,BLOCK,-1,,"{
    *result = napi_undefined;
  }",32,,1900,2,,void
112040,BLOCK,-1,,<empty>,10,,1902,1,,void
112046,BLOCK,-1,,"{
    *result = napi_symbol;
  }",29,,1902,2,,void
112052,BLOCK,-1,,<empty>,10,,1904,1,,void
112058,BLOCK,-1,,"{
    *result = napi_null;
  }",27,,1904,2,,void
112064,BLOCK,-1,,"{
    // Should not get here unless V8 has added some new kind of value.
    return napi_set_last_error(env, napi_invalid_arg);
  }",10,,1906,1,,void
112077,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsValueFromV8LocalValue(v8::Undefined(env->isolate));

  return napi_clear_last_error(env);
}",77,,1914,3,,void
112080,BLOCK,1,,<empty>,,,,2,,void
112082,BLOCK,-1,,CHECK_ENV(env),3,,1915,1,,void
112087,BLOCK,-1,,CHECK_ENV(env),3,,1915,2,,void
112094,BLOCK,1,,<empty>,,,,3,,void
112096,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1916,1,,void
112102,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1916,2,,void
112130,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsValueFromV8LocalValue(v8::Null(env->isolate));

  return napi_clear_last_error(env);
}",72,,1923,3,,void
112133,BLOCK,1,,<empty>,,,,2,,void
112135,BLOCK,-1,,CHECK_ENV(env),3,,1924,1,,void
112140,BLOCK,-1,,CHECK_ENV(env),3,,1924,2,,void
112147,BLOCK,1,,<empty>,,,,3,,void
112149,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1925,1,,void
112155,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1925,2,,void
112187,BLOCK,-1,,"{         // [out] Receives the data pointer for the callback.
  CHECK_ENV(env);
  CHECK_ARG(env, cbinfo);

  v8impl::CallbackWrapper* info =
      reinterpret_cast<v8impl::CallbackWrapper*>(cbinfo);

  if (argv != nullptr) {
    CHECK_ARG(env, argc);
    info->Args(argv, *argc);
  }
  if (argc != nullptr) {
    *argc = info->ArgsLength();
  }
  if (this_arg != nullptr) {
    *this_arg = info->This();
  }
  if (data != nullptr) {
    *data = info->Data();
  }

  return napi_clear_last_error(env);
}",18,,1940,7,,void
112190,BLOCK,1,,<empty>,,,,2,,void
112192,BLOCK,-1,,CHECK_ENV(env),3,,1941,1,,void
112197,BLOCK,-1,,CHECK_ENV(env),3,,1941,2,,void
112204,BLOCK,1,,<empty>,,,,3,,void
112206,BLOCK,-1,,"CHECK_ARG(env, cbinfo)",3,,1942,1,,void
112212,BLOCK,-1,,"CHECK_ARG(env, cbinfo)",3,,1942,2,,void
112228,BLOCK,-1,,"{
    CHECK_ARG(env, argc);
    info->Args(argv, *argc);
  }",24,,1947,2,,void
112232,BLOCK,1,,<empty>,,,,3,,void
112234,BLOCK,-1,,"CHECK_ARG(env, argc)",5,,1948,1,,void
112240,BLOCK,-1,,"CHECK_ARG(env, argc)",5,,1948,2,,void
112257,BLOCK,-1,,"{
    *argc = info->ArgsLength();
  }",24,,1951,2,,void
112269,BLOCK,-1,,"{
    *this_arg = info->This();
  }",28,,1954,2,,void
112281,BLOCK,-1,,"{
    *data = info->Data();
  }",24,,1957,2,,void
112298,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, cbinfo);
  CHECK_ARG(env, result);

  v8impl::CallbackWrapper* info =
      reinterpret_cast<v8impl::CallbackWrapper*>(cbinfo);

  *result = info->GetNewTarget();
  return napi_clear_last_error(env);
}",64,,1966,4,,void
112301,BLOCK,1,,<empty>,,,,2,,void
112303,BLOCK,-1,,CHECK_ENV(env),3,,1967,1,,void
112308,BLOCK,-1,,CHECK_ENV(env),3,,1967,2,,void
112315,BLOCK,1,,<empty>,,,,3,,void
112317,BLOCK,-1,,"CHECK_ARG(env, cbinfo)",3,,1968,1,,void
112323,BLOCK,-1,,"CHECK_ARG(env, cbinfo)",3,,1968,2,,void
112332,BLOCK,1,,<empty>,,,,3,,void
112334,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1969,1,,void
112340,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1969,2,,void
112371,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, recv);
  if (argc > 0) {
    CHECK_ARG(env, argv);
  }

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Value> v8recv = v8impl::V8LocalValueFromJsValue(recv);

  v8::Local<v8::Function> v8func;
  CHECK_TO_FUNCTION(env, v8func, func);

  auto maybe = v8func->Call(
      context,
      v8recv,
      argc,
      reinterpret_cast<v8::Local<v8::Value>*>(const_cast<napi_value*>(argv)));

  if (try_catch.HasCaught()) {
    return napi_set_last_error(env, napi_pending_exception);
  } else {
    if (result != nullptr) {
      CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure);
      *result = v8impl::JsValueFromV8LocalValue(maybe.ToLocalChecked());
    }
    return napi_clear_last_error(env);
  }
}",63,,1983,7,,void
112374,BLOCK,1,,<empty>,,,,2,,void
112376,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1984,1,,void
112381,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1984,2,,void
112386,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1984,1,,void
112395,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1984,2,,void
112402,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1984,1,,void
112409,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1984,2,,void
112430,BLOCK,1,,<empty>,,,,3,,void
112432,BLOCK,-1,,"CHECK_ARG(env, recv)",3,,1985,1,,void
112438,BLOCK,-1,,"CHECK_ARG(env, recv)",3,,1985,2,,void
112448,BLOCK,-1,,"{
    CHECK_ARG(env, argv);
  }",17,,1986,2,,void
112452,BLOCK,1,,<empty>,,,,3,,void
112454,BLOCK,-1,,"CHECK_ARG(env, argv)",5,,1987,1,,void
112460,BLOCK,-1,,"CHECK_ARG(env, argv)",5,,1987,2,,void
112508,BLOCK,1,,<empty>,,,,4,,void
112510,BLOCK,-1,,"CHECK_TO_FUNCTION(env, v8func, func)",3,,1995,1,,void
112512,BLOCK,-1,,"CHECK_TO_FUNCTION(env, v8func, func)",3,,1995,1,,void
112518,BLOCK,-1,,"CHECK_TO_FUNCTION(env, v8func, func)",3,,1995,2,,void
112540,BLOCK,-1,,"CHECK_TO_FUNCTION(env, v8func, func)",3,,1995,1,,void
112547,BLOCK,-1,,"CHECK_TO_FUNCTION(env, v8func, func)",3,,1995,2,,void
112580,BLOCK,-1,,"{
    return napi_set_last_error(env, napi_pending_exception);
  }",30,,2003,2,,void
112586,BLOCK,-1,,"{
    if (result != nullptr) {
      CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure);
      *result = v8impl::JsValueFromV8LocalValue(maybe.ToLocalChecked());
    }
    return napi_clear_last_error(env);
  }",10,,2005,1,,void
112591,BLOCK,-1,,"{
      CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure);
      *result = v8impl::JsValueFromV8LocalValue(maybe.ToLocalChecked());
    }",28,,2006,2,,void
112596,BLOCK,1,,<empty>,,,,5,,void
112598,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure)",7,,2007,1,,void
112606,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure)",7,,2007,2,,void
112631,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsValueFromV8LocalValue(env->context()->Global());

  return napi_clear_last_error(env);
}",74,,2014,3,,void
112634,BLOCK,1,,<empty>,,,,2,,void
112636,BLOCK,-1,,CHECK_ENV(env),3,,2015,1,,void
112641,BLOCK,-1,,CHECK_ENV(env),3,,2015,2,,void
112648,BLOCK,1,,<empty>,,,,3,,void
112650,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2016,1,,void
112656,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2016,2,,void
112684,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, error);

  v8::Isolate* isolate = env->isolate;

  isolate->ThrowException(v8impl::V8LocalValueFromJsValue(error));
  // any VM calls after this point and before returning
  // to the javascript invoker will fail
  return napi_clear_last_error(env);
}",67,,2023,3,,void
112687,BLOCK,1,,<empty>,,,,2,,void
112689,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2024,1,,void
112694,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2024,2,,void
112699,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2024,1,,void
112708,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2024,2,,void
112715,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2024,1,,void
112722,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2024,2,,void
112743,BLOCK,1,,<empty>,,,,3,,void
112745,BLOCK,-1,,"CHECK_ARG(env, error)",3,,2025,1,,void
112751,BLOCK,-1,,"CHECK_ARG(env, error)",3,,2025,2,,void
112781,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);

  v8::Isolate* isolate = env->isolate;
  v8::Local<v8::String> str;
  CHECK_NEW_FROM_UTF8(env, str, msg);

  v8::Local<v8::Value> error_obj = v8::Exception::Error(str);
  STATUS_CALL(set_error_code(env, error_obj, nullptr, code));

  isolate->ThrowException(error_obj);
  // any VM calls after this point and before returning
  // to the javascript invoker will fail
  return napi_clear_last_error(env);
}",58,,2037,4,,void
112784,BLOCK,1,,<empty>,,,,2,,void
112786,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2038,1,,void
112791,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2038,2,,void
112796,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2038,1,,void
112805,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2038,2,,void
112812,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2038,1,,void
112819,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2038,2,,void
112857,BLOCK,1,,<empty>,,,,6,,void
112859,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2042,1,,void
112869,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2042,1,,void
112879,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2042,2,,void
112886,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2042,1,,void
112892,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2042,2,,void
112920,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2042,1,,void
112928,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2042,2,,void
112960,BLOCK,1,,<empty>,,,,3,,void
112962,BLOCK,-1,,"STATUS_CALL(set_error_code(env, error_obj, nullptr, code))",3,,2045,1,,void
112975,BLOCK,-1,,<empty>,3,,2045,2,,void
112993,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);

  v8::Isolate* isolate = env->isolate;
  v8::Local<v8::String> str;
  CHECK_NEW_FROM_UTF8(env, str, msg);

  v8::Local<v8::Value> error_obj = v8::Exception::TypeError(str);
  STATUS_CALL(set_error_code(env, error_obj, nullptr, code));

  isolate->ThrowException(error_obj);
  // any VM calls after this point and before returning
  // to the javascript invoker will fail
  return napi_clear_last_error(env);
}",63,,2055,4,,void
112996,BLOCK,1,,<empty>,,,,2,,void
112998,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2056,1,,void
113003,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2056,2,,void
113008,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2056,1,,void
113017,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2056,2,,void
113024,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2056,1,,void
113031,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2056,2,,void
113069,BLOCK,1,,<empty>,,,,6,,void
113071,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2060,1,,void
113081,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2060,1,,void
113091,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2060,2,,void
113098,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2060,1,,void
113104,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2060,2,,void
113132,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2060,1,,void
113140,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2060,2,,void
113172,BLOCK,1,,<empty>,,,,3,,void
113174,BLOCK,-1,,"STATUS_CALL(set_error_code(env, error_obj, nullptr, code))",3,,2063,1,,void
113187,BLOCK,-1,,<empty>,3,,2063,2,,void
113205,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);

  v8::Isolate* isolate = env->isolate;
  v8::Local<v8::String> str;
  CHECK_NEW_FROM_UTF8(env, str, msg);

  v8::Local<v8::Value> error_obj = v8::Exception::RangeError(str);
  STATUS_CALL(set_error_code(env, error_obj, nullptr, code));

  isolate->ThrowException(error_obj);
  // any VM calls after this point and before returning
  // to the javascript invoker will fail
  return napi_clear_last_error(env);
}",64,,2073,4,,void
113208,BLOCK,1,,<empty>,,,,2,,void
113210,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2074,1,,void
113215,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2074,2,,void
113220,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2074,1,,void
113229,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2074,2,,void
113236,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2074,1,,void
113243,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2074,2,,void
113281,BLOCK,1,,<empty>,,,,6,,void
113283,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2078,1,,void
113293,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2078,1,,void
113303,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2078,2,,void
113310,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2078,1,,void
113316,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2078,2,,void
113344,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2078,1,,void
113352,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2078,2,,void
113384,BLOCK,1,,<empty>,,,,3,,void
113386,BLOCK,-1,,"STATUS_CALL(set_error_code(env, error_obj, nullptr, code))",3,,2081,1,,void
113399,BLOCK,-1,,<empty>,3,,2081,2,,void
113417,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);

  v8::Isolate* isolate = env->isolate;
  v8::Local<v8::String> str;
  CHECK_NEW_FROM_UTF8(env, str, msg);

  v8::Local<v8::Value> error_obj = v8::Exception::SyntaxError(str);
  STATUS_CALL(set_error_code(env, error_obj, nullptr, code));

  isolate->ThrowException(error_obj);
  // any VM calls after this point and before returning
  // to the javascript invoker will fail
  return napi_clear_last_error(env);
}",69,,2091,4,,void
113420,BLOCK,1,,<empty>,,,,2,,void
113422,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2092,1,,void
113427,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2092,2,,void
113432,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2092,1,,void
113441,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2092,2,,void
113448,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2092,1,,void
113455,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2092,2,,void
113493,BLOCK,1,,<empty>,,,,6,,void
113495,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2096,1,,void
113505,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2096,1,,void
113515,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2096,2,,void
113522,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2096,1,,void
113528,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2096,2,,void
113556,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2096,1,,void
113564,BLOCK,-1,,"CHECK_NEW_FROM_UTF8(env, str, msg)",3,,2096,2,,void
113596,BLOCK,1,,<empty>,,,,3,,void
113598,BLOCK,-1,,"STATUS_CALL(set_error_code(env, error_obj, nullptr, code))",3,,2099,1,,void
113611,BLOCK,-1,,<empty>,3,,2099,2,,void
113629,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot
  // throw JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  *result = val->IsNativeError();

  return napi_clear_last_error(env);
}",52,,2109,4,,void
113632,BLOCK,1,,<empty>,,,,2,,void
113634,BLOCK,-1,,CHECK_ENV(env),3,,2112,1,,void
113639,BLOCK,-1,,CHECK_ENV(env),3,,2112,2,,void
113646,BLOCK,1,,<empty>,,,,3,,void
113648,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2113,1,,void
113654,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2113,2,,void
113663,BLOCK,1,,<empty>,,,,3,,void
113665,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2114,1,,void
113671,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2114,2,,void
113708,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected);

  *result = val.As<v8::Number>()->Value();

  return napi_clear_last_error(env);
}",62,,2124,4,,void
113711,BLOCK,1,,<empty>,,,,2,,void
113713,BLOCK,-1,,CHECK_ENV(env),3,,2127,1,,void
113718,BLOCK,-1,,CHECK_ENV(env),3,,2127,2,,void
113725,BLOCK,1,,<empty>,,,,3,,void
113727,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2128,1,,void
113733,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2128,2,,void
113742,BLOCK,1,,<empty>,,,,3,,void
113744,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2129,1,,void
113750,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2129,2,,void
113778,BLOCK,1,,<empty>,,,,4,,void
113780,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected)",3,,2132,1,,void
113787,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected)",3,,2132,2,,void
113812,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);

  if (val->IsInt32()) {
    *result = val.As<v8::Int32>()->Value();
  } else {
    RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected);

    // Empty context: https://github.com/nodejs/node/issues/14379
    v8::Local<v8::Context> context;
    *result = val->Int32Value(context).FromJust();
  }

  return napi_clear_last_error(env);
}",62,,2141,4,,void
113815,BLOCK,1,,<empty>,,,,2,,void
113817,BLOCK,-1,,CHECK_ENV(env),3,,2144,1,,void
113822,BLOCK,-1,,CHECK_ENV(env),3,,2144,2,,void
113829,BLOCK,1,,<empty>,,,,3,,void
113831,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2145,1,,void
113837,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2145,2,,void
113846,BLOCK,1,,<empty>,,,,3,,void
113848,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2146,1,,void
113854,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2146,2,,void
113880,BLOCK,-1,,"{
    *result = val.As<v8::Int32>()->Value();
  }",23,,2150,2,,void
113892,BLOCK,-1,,"{
    RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected);

    // Empty context: https://github.com/nodejs/node/issues/14379
    v8::Local<v8::Context> context;
    *result = val->Int32Value(context).FromJust();
  }",10,,2152,1,,void
113900,BLOCK,1,,<empty>,,,,4,,void
113902,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected)",5,,2153,1,,void
113909,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected)",5,,2153,2,,void
113944,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);

  if (val->IsUint32()) {
    *result = val.As<v8::Uint32>()->Value();
  } else {
    RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected);

    // Empty context: https://github.com/nodejs/node/issues/14379
    v8::Local<v8::Context> context;
    *result = val->Uint32Value(context).FromJust();
  }

  return napi_clear_last_error(env);
}",64,,2165,4,,void
113947,BLOCK,1,,<empty>,,,,2,,void
113949,BLOCK,-1,,CHECK_ENV(env),3,,2168,1,,void
113954,BLOCK,-1,,CHECK_ENV(env),3,,2168,2,,void
113961,BLOCK,1,,<empty>,,,,3,,void
113963,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2169,1,,void
113969,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2169,2,,void
113978,BLOCK,1,,<empty>,,,,3,,void
113980,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2170,1,,void
113986,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2170,2,,void
114012,BLOCK,-1,,"{
    *result = val.As<v8::Uint32>()->Value();
  }",24,,2174,2,,void
114024,BLOCK,-1,,"{
    RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected);

    // Empty context: https://github.com/nodejs/node/issues/14379
    v8::Local<v8::Context> context;
    *result = val->Uint32Value(context).FromJust();
  }",10,,2176,1,,void
114032,BLOCK,1,,<empty>,,,,4,,void
114034,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected)",5,,2177,1,,void
114041,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected)",5,,2177,2,,void
114076,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);

  // This is still a fast path very likely to be taken.
  if (val->IsInt32()) {
    *result = val.As<v8::Int32>()->Value();
    return napi_clear_last_error(env);
  }

  RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected);

  // v8::Value::IntegerValue() converts NaN, +Inf, and -Inf to INT64_MIN,
  // inconsistent with v8::Value::Int32Value() which converts those values to 0.
  // Special-case all non-finite values to match that behavior.
  double doubleValue = val.As<v8::Number>()->Value();
  if (std::isfinite(doubleValue)) {
    // Empty context: https://github.com/nodejs/node/issues/14379
    v8::Local<v8::Context> context;
    *result = val->IntegerValue(context).FromJust();
  } else {
    *result = 0;
  }

  return napi_clea...",62,,2189,4,,void
114079,BLOCK,1,,<empty>,,,,2,,void
114081,BLOCK,-1,,CHECK_ENV(env),3,,2192,1,,void
114086,BLOCK,-1,,CHECK_ENV(env),3,,2192,2,,void
114093,BLOCK,1,,<empty>,,,,3,,void
114095,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2193,1,,void
114101,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2193,2,,void
114110,BLOCK,1,,<empty>,,,,3,,void
114112,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2194,1,,void
114118,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2194,2,,void
114144,BLOCK,-1,,"{
    *result = val.As<v8::Int32>()->Value();
    return napi_clear_last_error(env);
  }",23,,2199,2,,void
114165,BLOCK,1,,<empty>,,,,4,,void
114167,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected)",3,,2204,1,,void
114174,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected)",3,,2204,2,,void
114196,BLOCK,-1,,"{
    // Empty context: https://github.com/nodejs/node/issues/14379
    v8::Local<v8::Context> context;
    *result = val->IntegerValue(context).FromJust();
  }",35,,2210,2,,void
114218,BLOCK,-1,,"{
    *result = 0;
  }",10,,2214,1,,void
114233,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);
  CHECK_ARG(env, lossless);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);

  RETURN_STATUS_IF_FALSE(env, val->IsBigInt(), napi_bigint_expected);

  *result = val.As<v8::BigInt>()->Int64Value(lossless);

  return napi_clear_last_error(env);
}",68,,2224,5,,void
114236,BLOCK,1,,<empty>,,,,2,,void
114238,BLOCK,-1,,CHECK_ENV(env),3,,2225,1,,void
114243,BLOCK,-1,,CHECK_ENV(env),3,,2225,2,,void
114250,BLOCK,1,,<empty>,,,,3,,void
114252,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2226,1,,void
114258,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2226,2,,void
114267,BLOCK,1,,<empty>,,,,3,,void
114269,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2227,1,,void
114275,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2227,2,,void
114284,BLOCK,1,,<empty>,,,,3,,void
114286,BLOCK,-1,,"CHECK_ARG(env, lossless)",3,,2228,1,,void
114292,BLOCK,-1,,"CHECK_ARG(env, lossless)",3,,2228,2,,void
114320,BLOCK,1,,<empty>,,,,4,,void
114322,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsBigInt(), napi_bigint_expected)",3,,2232,1,,void
114329,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsBigInt(), napi_bigint_expected)",3,,2232,2,,void
114356,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);
  CHECK_ARG(env, lossless);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);

  RETURN_STATUS_IF_FALSE(env, val->IsBigInt(), napi_bigint_expected);

  *result = val.As<v8::BigInt>()->Uint64Value(lossless);

  return napi_clear_last_error(env);
}",69,,2242,5,,void
114359,BLOCK,1,,<empty>,,,,2,,void
114361,BLOCK,-1,,CHECK_ENV(env),3,,2243,1,,void
114366,BLOCK,-1,,CHECK_ENV(env),3,,2243,2,,void
114373,BLOCK,1,,<empty>,,,,3,,void
114375,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2244,1,,void
114381,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2244,2,,void
114390,BLOCK,1,,<empty>,,,,3,,void
114392,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2245,1,,void
114398,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2245,2,,void
114407,BLOCK,1,,<empty>,,,,3,,void
114409,BLOCK,-1,,"CHECK_ARG(env, lossless)",3,,2246,1,,void
114415,BLOCK,-1,,"CHECK_ARG(env, lossless)",3,,2246,2,,void
114443,BLOCK,1,,<empty>,,,,4,,void
114445,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsBigInt(), napi_bigint_expected)",3,,2250,1,,void
114452,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsBigInt(), napi_bigint_expected)",3,,2250,2,,void
114480,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, word_count);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);

  RETURN_STATUS_IF_FALSE(env, val->IsBigInt(), napi_bigint_expected);

  v8::Local<v8::BigInt> big = val.As<v8::BigInt>();

  int word_count_int = *word_count;

  if (sign_bit == nullptr && words == nullptr) {
    word_count_int = big->WordCount();
  } else {
    CHECK_ARG(env, sign_bit);
    CHECK_ARG(env, words);
    big->ToWordsArray(sign_bit, &word_count_int, words);
  }

  *word_count = word_count_int;

  return napi_clear_last_error(env);
}",69,,2261,6,,void
114483,BLOCK,1,,<empty>,,,,2,,void
114485,BLOCK,-1,,CHECK_ENV(env),3,,2262,1,,void
114490,BLOCK,-1,,CHECK_ENV(env),3,,2262,2,,void
114497,BLOCK,1,,<empty>,,,,3,,void
114499,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2263,1,,void
114505,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2263,2,,void
114514,BLOCK,1,,<empty>,,,,3,,void
114516,BLOCK,-1,,"CHECK_ARG(env, word_count)",3,,2264,1,,void
114522,BLOCK,-1,,"CHECK_ARG(env, word_count)",3,,2264,2,,void
114550,BLOCK,1,,<empty>,,,,4,,void
114552,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsBigInt(), napi_bigint_expected)",3,,2268,1,,void
114559,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsBigInt(), napi_bigint_expected)",3,,2268,2,,void
114592,BLOCK,-1,,"{
    word_count_int = big->WordCount();
  }",48,,2274,2,,void
114600,BLOCK,-1,,"{
    CHECK_ARG(env, sign_bit);
    CHECK_ARG(env, words);
    big->ToWordsArray(sign_bit, &word_count_int, words);
  }",10,,2276,1,,void
114604,BLOCK,1,,<empty>,,,,3,,void
114606,BLOCK,-1,,"CHECK_ARG(env, sign_bit)",5,,2277,1,,void
114612,BLOCK,-1,,"CHECK_ARG(env, sign_bit)",5,,2277,2,,void
114621,BLOCK,1,,<empty>,,,,3,,void
114623,BLOCK,-1,,"CHECK_ARG(env, words)",5,,2278,1,,void
114629,BLOCK,-1,,"CHECK_ARG(env, words)",5,,2278,2,,void
114656,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  RETURN_STATUS_IF_FALSE(env, val->IsBoolean(), napi_boolean_expected);

  *result = val.As<v8::Boolean>()->Value();

  return napi_clear_last_error(env);
}",58,,2289,4,,void
114659,BLOCK,1,,<empty>,,,,2,,void
114661,BLOCK,-1,,CHECK_ENV(env),3,,2292,1,,void
114666,BLOCK,-1,,CHECK_ENV(env),3,,2292,2,,void
114673,BLOCK,1,,<empty>,,,,3,,void
114675,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2293,1,,void
114681,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2293,2,,void
114690,BLOCK,1,,<empty>,,,,3,,void
114692,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2294,1,,void
114698,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2294,2,,void
114726,BLOCK,1,,<empty>,,,,4,,void
114728,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsBoolean(), napi_boolean_expected)",3,,2297,1,,void
114735,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsBoolean(), napi_boolean_expected)",3,,2297,2,,void
114762,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, value);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected);

  if (!buf) {
    CHECK_ARG(env, result);
    *result = val.As<v8::String>()->Length();
  } else if (bufsize != 0) {
    int copied =
        val.As<v8::String>()->WriteOneByte(env->isolate,
                                           reinterpret_cast<uint8_t*>(buf),
                                           0,
                                           bufsize - 1,
                                           v8::String::NO_NULL_TERMINATION);

    buf[copied] = '\0';
    if (result != nullptr) {
      *result = copied;
    }
  } else if (result != nullptr) {
    *result = 0;
  }

  return napi_clear_last_error(env);
}",80,,2313,6,,void
114765,BLOCK,1,,<empty>,,,,2,,void
114767,BLOCK,-1,,CHECK_ENV(env),3,,2314,1,,void
114772,BLOCK,-1,,CHECK_ENV(env),3,,2314,2,,void
114779,BLOCK,1,,<empty>,,,,3,,void
114781,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2315,1,,void
114787,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2315,2,,void
114815,BLOCK,1,,<empty>,,,,4,,void
114817,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected)",3,,2318,1,,void
114824,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected)",3,,2318,2,,void
114833,BLOCK,-1,,"{
    CHECK_ARG(env, result);
    *result = val.As<v8::String>()->Length();
  }",13,,2320,2,,void
114837,BLOCK,1,,<empty>,,,,3,,void
114839,BLOCK,-1,,"CHECK_ARG(env, result)",5,,2321,1,,void
114845,BLOCK,-1,,"CHECK_ARG(env, result)",5,,2321,2,,void
114862,BLOCK,-1,,<empty>,10,,2323,1,,void
114867,BLOCK,-1,,"{
    int copied =
        val.As<v8::String>()->WriteOneByte(env->isolate,
                                           reinterpret_cast<uint8_t*>(buf),
                                           0,
                                           bufsize - 1,
                                           v8::String::NO_NULL_TERMINATION);

    buf[copied] = '\0';
    if (result != nullptr) {
      *result = copied;
    }
  }",28,,2323,2,,void
114902,BLOCK,-1,,"{
      *result = copied;
    }",28,,2332,2,,void
114908,BLOCK,-1,,<empty>,10,,2335,1,,void
114913,BLOCK,-1,,"{
    *result = 0;
  }",33,,2335,2,,void
114929,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, value);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected);

  if (!buf) {
    CHECK_ARG(env, result);
    *result = val.As<v8::String>()->Utf8Length(env->isolate);
  } else if (bufsize != 0) {
    int copied = val.As<v8::String>()->WriteUtf8(
        env->isolate,
        buf,
        bufsize - 1,
        nullptr,
        v8::String::REPLACE_INVALID_UTF8 | v8::String::NO_NULL_TERMINATION);

    buf[copied] = '\0';
    if (result != nullptr) {
      *result = copied;
    }
  } else if (result != nullptr) {
    *result = 0;
  }

  return napi_clear_last_error(env);
}",80,,2351,6,,void
114932,BLOCK,1,,<empty>,,,,2,,void
114934,BLOCK,-1,,CHECK_ENV(env),3,,2352,1,,void
114939,BLOCK,-1,,CHECK_ENV(env),3,,2352,2,,void
114946,BLOCK,1,,<empty>,,,,3,,void
114948,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2353,1,,void
114954,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2353,2,,void
114982,BLOCK,1,,<empty>,,,,4,,void
114984,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected)",3,,2356,1,,void
114991,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected)",3,,2356,2,,void
115000,BLOCK,-1,,"{
    CHECK_ARG(env, result);
    *result = val.As<v8::String>()->Utf8Length(env->isolate);
  }",13,,2358,2,,void
115004,BLOCK,1,,<empty>,,,,3,,void
115006,BLOCK,-1,,"CHECK_ARG(env, result)",5,,2359,1,,void
115012,BLOCK,-1,,"CHECK_ARG(env, result)",5,,2359,2,,void
115032,BLOCK,-1,,<empty>,10,,2361,1,,void
115037,BLOCK,-1,,"{
    int copied = val.As<v8::String>()->WriteUtf8(
        env->isolate,
        buf,
        bufsize - 1,
        nullptr,
        v8::String::REPLACE_INVALID_UTF8 | v8::String::NO_NULL_TERMINATION);

    buf[copied] = '\0';
    if (result != nullptr) {
      *result = copied;
    }
  }",28,,2361,2,,void
115076,BLOCK,-1,,"{
      *result = copied;
    }",28,,2370,2,,void
115082,BLOCK,-1,,<empty>,10,,2373,1,,void
115087,BLOCK,-1,,"{
    *result = 0;
  }",33,,2373,2,,void
115103,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, value);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected);

  if (!buf) {
    CHECK_ARG(env, result);
    // V8 assumes UTF-16 length is the same as the number of characters.
    *result = val.As<v8::String>()->Length();
  } else if (bufsize != 0) {
    int copied = val.As<v8::String>()->Write(env->isolate,
                                             reinterpret_cast<uint16_t*>(buf),
                                             0,
                                             bufsize - 1,
                                             v8::String::NO_NULL_TERMINATION);

    buf[copied] = '\0';
    if (result != nullptr) {
      *result = copied;
    }
  } else if (result != nullptr) {
    *result = 0;
  }

  return napi_clear_last_error(env);
}",68,,2392,6,,void
115106,BLOCK,1,,<empty>,,,,2,,void
115108,BLOCK,-1,,CHECK_ENV(env),3,,2393,1,,void
115113,BLOCK,-1,,CHECK_ENV(env),3,,2393,2,,void
115120,BLOCK,1,,<empty>,,,,3,,void
115122,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2394,1,,void
115128,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2394,2,,void
115156,BLOCK,1,,<empty>,,,,4,,void
115158,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected)",3,,2397,1,,void
115165,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected)",3,,2397,2,,void
115174,BLOCK,-1,,"{
    CHECK_ARG(env, result);
    // V8 assumes UTF-16 length is the same as the number of characters.
    *result = val.As<v8::String>()->Length();
  }",13,,2399,2,,void
115178,BLOCK,1,,<empty>,,,,3,,void
115180,BLOCK,-1,,"CHECK_ARG(env, result)",5,,2400,1,,void
115186,BLOCK,-1,,"CHECK_ARG(env, result)",5,,2400,2,,void
115203,BLOCK,-1,,<empty>,10,,2403,1,,void
115208,BLOCK,-1,,"{
    int copied = val.As<v8::String>()->Write(env->isolate,
                                             reinterpret_cast<uint16_t*>(buf),
                                             0,
                                             bufsize - 1,
                                             v8::String::NO_NULL_TERMINATION);

    buf[copied] = '\0';
    if (result != nullptr) {
      *result = copied;
    }
  }",28,,2403,2,,void
115243,BLOCK,-1,,"{
      *result = copied;
    }",28,,2411,2,,void
115249,BLOCK,-1,,<empty>,10,,2414,1,,void
115254,BLOCK,-1,,"{
    *result = 0;
  }",33,,2414,2,,void
115268,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Isolate* isolate = env->isolate;
  v8::Local<v8::Boolean> b =
      v8impl::V8LocalValueFromJsValue(value)->ToBoolean(isolate);
  *result = v8impl::JsValueFromV8LocalValue(b);
  return GET_RETURN_STATUS(env);
}",64,,2423,4,,void
115271,BLOCK,1,,<empty>,,,,2,,void
115273,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2424,1,,void
115278,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2424,2,,void
115283,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2424,1,,void
115292,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2424,2,,void
115299,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2424,1,,void
115306,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2424,2,,void
115327,BLOCK,1,,<empty>,,,,3,,void
115329,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2425,1,,void
115335,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2425,2,,void
115344,BLOCK,1,,<empty>,,,,3,,void
115346,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2426,1,,void
115352,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2426,2,,void
115394,BLOCK,1,,<empty>,,,,3,,void
115411,BLOCK,-1,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",1,,2451,4,,void
115413,BLOCK,-1,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",1,,2451,1,,void
115418,BLOCK,-1,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",1,,2451,2,,void
115423,BLOCK,-1,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",1,,2451,1,,void
115432,BLOCK,-1,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",1,,2451,2,,void
115439,BLOCK,-1,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",1,,2451,1,,void
115446,BLOCK,-1,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",1,,2451,2,,void
115465,BLOCK,-1,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",1,,2451,1,,void
115471,BLOCK,-1,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",1,,2451,2,,void
115478,BLOCK,-1,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",1,,2451,1,,void
115484,BLOCK,-1,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",1,,2451,2,,void
115514,BLOCK,-1,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",1,,2451,1,,void
115516,BLOCK,-1,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",1,,2451,1,,void
115522,BLOCK,-1,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",1,,2451,2,,void
115541,BLOCK,-1,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",1,,2451,1,,void
115549,BLOCK,-1,,"GEN_COERCE_FUNCTION(NUMBER, Number, number)",1,,2451,2,,void
115587,BLOCK,-1,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",1,,2452,4,,void
115589,BLOCK,-1,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",1,,2452,1,,void
115594,BLOCK,-1,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",1,,2452,2,,void
115599,BLOCK,-1,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",1,,2452,1,,void
115608,BLOCK,-1,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",1,,2452,2,,void
115615,BLOCK,-1,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",1,,2452,1,,void
115622,BLOCK,-1,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",1,,2452,2,,void
115641,BLOCK,-1,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",1,,2452,1,,void
115647,BLOCK,-1,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",1,,2452,2,,void
115654,BLOCK,-1,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",1,,2452,1,,void
115660,BLOCK,-1,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",1,,2452,2,,void
115690,BLOCK,-1,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",1,,2452,1,,void
115692,BLOCK,-1,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",1,,2452,1,,void
115698,BLOCK,-1,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",1,,2452,2,,void
115717,BLOCK,-1,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",1,,2452,1,,void
115725,BLOCK,-1,,"GEN_COERCE_FUNCTION(OBJECT, Object, object)",1,,2452,2,,void
115763,BLOCK,-1,,"GEN_COERCE_FUNCTION(STRING, String, string)",1,,2453,4,,void
115765,BLOCK,-1,,"GEN_COERCE_FUNCTION(STRING, String, string)",1,,2453,1,,void
115770,BLOCK,-1,,"GEN_COERCE_FUNCTION(STRING, String, string)",1,,2453,2,,void
115775,BLOCK,-1,,"GEN_COERCE_FUNCTION(STRING, String, string)",1,,2453,1,,void
115784,BLOCK,-1,,"GEN_COERCE_FUNCTION(STRING, String, string)",1,,2453,2,,void
115791,BLOCK,-1,,"GEN_COERCE_FUNCTION(STRING, String, string)",1,,2453,1,,void
115798,BLOCK,-1,,"GEN_COERCE_FUNCTION(STRING, String, string)",1,,2453,2,,void
115817,BLOCK,-1,,"GEN_COERCE_FUNCTION(STRING, String, string)",1,,2453,1,,void
115823,BLOCK,-1,,"GEN_COERCE_FUNCTION(STRING, String, string)",1,,2453,2,,void
115830,BLOCK,-1,,"GEN_COERCE_FUNCTION(STRING, String, string)",1,,2453,1,,void
115836,BLOCK,-1,,"GEN_COERCE_FUNCTION(STRING, String, string)",1,,2453,2,,void
115866,BLOCK,-1,,"GEN_COERCE_FUNCTION(STRING, String, string)",1,,2453,1,,void
115868,BLOCK,-1,,"GEN_COERCE_FUNCTION(STRING, String, string)",1,,2453,1,,void
115874,BLOCK,-1,,"GEN_COERCE_FUNCTION(STRING, String, string)",1,,2453,2,,void
115893,BLOCK,-1,,"GEN_COERCE_FUNCTION(STRING, String, string)",1,,2453,1,,void
115901,BLOCK,-1,,"GEN_COERCE_FUNCTION(STRING, String, string)",1,,2453,2,,void
115942,BLOCK,-1,,"{
  return v8impl::Wrap(
      env, js_object, native_object, finalize_cb, finalize_hint, result);
}",52,,2462,7,,void
115960,BLOCK,-1,,"{
  return v8impl::Unwrap(env, obj, result, v8impl::KeepWrap);
}",51,,2469,4,,void
115978,BLOCK,-1,,"{
  return v8impl::Unwrap(env, obj, result, v8impl::RemoveWrap);
}",56,,2475,4,,void
115998,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::Isolate* isolate = env->isolate;

  v8::Local<v8::Value> external_value = v8::External::New(isolate, data);

  if (finalize_cb) {
    // The Reference object will delete itself after invoking the finalizer
    // callback.
    v8impl::Reference::New(env,
                           external_value,
                           0,
                           v8impl::Ownership::kRuntime,
                           finalize_cb,
                           data,
                           finalize_hint);
  }

  *result = v8impl::JsValueFromV8LocalValue(external_value);

  return napi_clear_last_error(env);
}",65,,2483,6,,void
116001,BLOCK,1,,<empty>,,,,2,,void
116003,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2484,1,,void
116008,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2484,2,,void
116013,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2484,1,,void
116022,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2484,2,,void
116029,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2484,1,,void
116036,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2484,2,,void
116057,BLOCK,1,,<empty>,,,,3,,void
116059,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2485,1,,void
116065,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2485,2,,void
116097,BLOCK,-1,,"{
    // The Reference object will delete itself after invoking the finalizer
    // callback.
    v8impl::Reference::New(env,
                           external_value,
                           0,
                           v8impl::Ownership::kRuntime,
                           finalize_cb,
                           data,
                           finalize_hint);
  }",20,,2491,2,,void
116132,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;
  CHECK_TO_OBJECT_WITH_PREAMBLE(env, context, obj, object);
  CHECK_ARG_WITH_PREAMBLE(env, type_tag);

  auto key = NAPI_PRIVATE_KEY(context, type_tag);
  auto maybe_has = obj->HasPrivate(context, key);
  CHECK_MAYBE_NOTHING_WITH_PREAMBLE(env, maybe_has, napi_generic_failure);
  RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, !maybe_has.FromJust(), napi_invalid_arg);

  auto tag = v8::BigInt::NewFromWords(
      context, 0, 2, reinterpret_cast<const uint64_t*>(type_tag));
  CHECK_MAYBE_EMPTY_WITH_PREAMBLE(env, tag, napi_generic_failure);

  auto maybe_set = obj->SetPrivate(context, key, tag.ToLocalChecked());
  CHECK_MAYBE_NOTHING_WITH_PREAMBLE(env, maybe_set, napi_generic_failure);
  RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, maybe_set.FromJust(), napi_generic_failure);

  return GET_RETURN_STATUS(env);
}",76,,2510,4,,void
116135,BLOCK,1,,<empty>,,,,2,,void
116137,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2511,1,,void
116142,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2511,2,,void
116147,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2511,1,,void
116156,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2511,2,,void
116163,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2511,1,,void
116170,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2511,2,,void
116217,BLOCK,1,,<empty>,,,,9,,void
116219,BLOCK,-1,,"CHECK_TO_OBJECT_WITH_PREAMBLE(env, context, obj, object)",3,,2514,1,,void
116221,BLOCK,-1,,"CHECK_TO_OBJECT_WITH_PREAMBLE(env, context, obj, object)",3,,2514,1,,void
116227,BLOCK,-1,,"CHECK_TO_OBJECT_WITH_PREAMBLE(env, context, obj, object)",3,,2514,2,,void
116252,BLOCK,-1,,"CHECK_TO_OBJECT_WITH_PREAMBLE(env, context, obj, object)",3,,2514,1,,void
116260,BLOCK,-1,,"CHECK_TO_OBJECT_WITH_PREAMBLE(env, context, obj, object)",3,,2514,2,,void
116282,BLOCK,1,,<empty>,,,,4,,void
116284,BLOCK,-1,,"CHECK_ARG_WITH_PREAMBLE(env, type_tag)",3,,2515,1,,void
116290,BLOCK,-1,,"CHECK_ARG_WITH_PREAMBLE(env, type_tag)",3,,2515,2,,void
116307,BLOCK,1,,<empty>,,,,2,,void
116331,BLOCK,1,,<empty>,,,,6,,void
116333,BLOCK,-1,,"CHECK_MAYBE_NOTHING_WITH_PREAMBLE(env, maybe_has, napi_generic_failure)",3,,2519,1,,void
116341,BLOCK,-1,,"CHECK_MAYBE_NOTHING_WITH_PREAMBLE(env, maybe_has, napi_generic_failure)",3,,2519,2,,void
116361,BLOCK,1,,<empty>,,,,6,,void
116363,BLOCK,-1,,"RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, !maybe_has.FromJust(), napi_invalid_arg)",3,,2520,1,,void
116371,BLOCK,-1,,"RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, !maybe_has.FromJust(), napi_invalid_arg)",3,,2520,2,,void
116402,BLOCK,1,,<empty>,,,,6,,void
116404,BLOCK,-1,,"CHECK_MAYBE_EMPTY_WITH_PREAMBLE(env, tag, napi_generic_failure)",3,,2525,1,,void
116412,BLOCK,-1,,"CHECK_MAYBE_EMPTY_WITH_PREAMBLE(env, tag, napi_generic_failure)",3,,2525,2,,void
116441,BLOCK,1,,<empty>,,,,6,,void
116443,BLOCK,-1,,"CHECK_MAYBE_NOTHING_WITH_PREAMBLE(env, maybe_set, napi_generic_failure)",3,,2528,1,,void
116451,BLOCK,-1,,"CHECK_MAYBE_NOTHING_WITH_PREAMBLE(env, maybe_set, napi_generic_failure)",3,,2528,2,,void
116470,BLOCK,1,,<empty>,,,,6,,void
116472,BLOCK,-1,,"RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, maybe_set.FromJust(), napi_generic_failure)",3,,2529,1,,void
116479,BLOCK,-1,,"RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, maybe_set.FromJust(), napi_generic_failure)",3,,2529,2,,void
116494,BLOCK,1,,<empty>,,,,3,,void
116512,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;
  CHECK_TO_OBJECT_WITH_PREAMBLE(env, context, obj, object);
  CHECK_ARG_WITH_PREAMBLE(env, type_tag);
  CHECK_ARG_WITH_PREAMBLE(env, result);

  auto maybe_value =
      obj->GetPrivate(context, NAPI_PRIVATE_KEY(context, type_tag));
  CHECK_MAYBE_EMPTY_WITH_PREAMBLE(env, maybe_value, napi_generic_failure);
  v8::Local<v8::Value> val = maybe_value.ToLocalChecked();

  // We consider the type check to have failed unless we reach the line below
  // where we set whether the type check succeeded or not based on the
  // comparison of the two type tags.
  *result = false;
  if (val->IsBigInt()) {
    int sign;
    int size = 2;
    napi_type_tag tag;
    val.As<v8::BigInt>()->ToWordsArray(
        &sign, &size, reinterpret_cast<uint64_t*>(&tag));
    if (sign == 0) {
      if (size == 2) {
        *result =
            (tag.lower == type_tag->lower && tag.upper == type_tag->upper);
   ...",65,,2538,5,,void
116515,BLOCK,1,,<empty>,,,,2,,void
116517,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2539,1,,void
116522,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2539,2,,void
116527,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2539,1,,void
116536,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2539,2,,void
116543,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2539,1,,void
116550,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2539,2,,void
116597,BLOCK,1,,<empty>,,,,9,,void
116599,BLOCK,-1,,"CHECK_TO_OBJECT_WITH_PREAMBLE(env, context, obj, object)",3,,2542,1,,void
116601,BLOCK,-1,,"CHECK_TO_OBJECT_WITH_PREAMBLE(env, context, obj, object)",3,,2542,1,,void
116607,BLOCK,-1,,"CHECK_TO_OBJECT_WITH_PREAMBLE(env, context, obj, object)",3,,2542,2,,void
116632,BLOCK,-1,,"CHECK_TO_OBJECT_WITH_PREAMBLE(env, context, obj, object)",3,,2542,1,,void
116640,BLOCK,-1,,"CHECK_TO_OBJECT_WITH_PREAMBLE(env, context, obj, object)",3,,2542,2,,void
116662,BLOCK,1,,<empty>,,,,4,,void
116664,BLOCK,-1,,"CHECK_ARG_WITH_PREAMBLE(env, type_tag)",3,,2543,1,,void
116670,BLOCK,-1,,"CHECK_ARG_WITH_PREAMBLE(env, type_tag)",3,,2543,2,,void
116685,BLOCK,1,,<empty>,,,,4,,void
116687,BLOCK,-1,,"CHECK_ARG_WITH_PREAMBLE(env, result)",3,,2544,1,,void
116693,BLOCK,-1,,"CHECK_ARG_WITH_PREAMBLE(env, result)",3,,2544,2,,void
116715,BLOCK,1,,<empty>,,,,2,,void
116730,BLOCK,1,,<empty>,,,,6,,void
116732,BLOCK,-1,,"CHECK_MAYBE_EMPTY_WITH_PREAMBLE(env, maybe_value, napi_generic_failure)",3,,2548,1,,void
116740,BLOCK,-1,,"CHECK_MAYBE_EMPTY_WITH_PREAMBLE(env, maybe_value, napi_generic_failure)",3,,2548,2,,void
116775,BLOCK,-1,,"{
    int sign;
    int size = 2;
    napi_type_tag tag;
    val.As<v8::BigInt>()->ToWordsArray(
        &sign, &size, reinterpret_cast<uint64_t*>(&tag));
    if (sign == 0) {
      if (size == 2) {
        *result =
            (tag.lower == type_tag->lower && tag.upper == type_tag->upper);
      } else if (size == 1) {
        *result = (tag.lower == type_tag->lower && 0 == type_tag->upper);
      } else if (size == 0) {
        *result = (0 == type_tag->lower && 0 == type_tag->upper);
      }
    }
  }",24,,2555,2,,void
116801,BLOCK,-1,,"{
      if (size == 2) {
        *result =
            (tag.lower == type_tag->lower && tag.upper == type_tag->upper);
      } else if (size == 1) {
        *result = (tag.lower == type_tag->lower && 0 == type_tag->upper);
      } else if (size == 0) {
        *result = (0 == type_tag->lower && 0 == type_tag->upper);
      }
    }",20,,2561,2,,void
116806,BLOCK,-1,,"{
        *result =
            (tag.lower == type_tag->lower && tag.upper == type_tag->upper);
      }",22,,2562,2,,void
116826,BLOCK,-1,,<empty>,14,,2565,1,,void
116831,BLOCK,-1,,"{
        *result = (tag.lower == type_tag->lower && 0 == type_tag->upper);
      }",29,,2565,2,,void
116849,BLOCK,-1,,<empty>,14,,2567,1,,void
116854,BLOCK,-1,,"{
        *result = (0 == type_tag->lower && 0 == type_tag->upper);
      }",29,,2567,2,,void
116872,BLOCK,1,,<empty>,,,,3,,void
116889,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  RETURN_STATUS_IF_FALSE(env, val->IsExternal(), napi_invalid_arg);

  v8::Local<v8::External> external_value = val.As<v8::External>();
  *result = external_value->Value();

  return napi_clear_last_error(env);
}",63,,2578,4,,void
116892,BLOCK,1,,<empty>,,,,2,,void
116894,BLOCK,-1,,CHECK_ENV(env),3,,2579,1,,void
116899,BLOCK,-1,,CHECK_ENV(env),3,,2579,2,,void
116906,BLOCK,1,,<empty>,,,,3,,void
116908,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2580,1,,void
116914,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2580,2,,void
116923,BLOCK,1,,<empty>,,,,3,,void
116925,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2581,1,,void
116931,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2581,2,,void
116959,BLOCK,1,,<empty>,,,,4,,void
116961,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsExternal(), napi_invalid_arg)",3,,2584,1,,void
116968,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsExternal(), napi_invalid_arg)",3,,2584,2,,void
117005,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> v8_value = v8impl::V8LocalValueFromJsValue(value);
  if (env->module_api_version != NAPI_VERSION_EXPERIMENTAL) {
    if (!(v8_value->IsObject() || v8_value->IsFunction() ||
          v8_value->IsSymbol())) {
      return napi_set_last_error(env, napi_invalid_arg);
    }
  }

  v8impl::Reference* reference = v8impl::Reference::New(
      env, v8_value, initial_refcount, v8impl::Ownership::kUserland);

  *result = reinterpret_cast<napi_ref>(reference);
  return napi_clear_last_error(env);
}",64,,2596,5,,void
117008,BLOCK,1,,<empty>,,,,2,,void
117010,BLOCK,-1,,CHECK_ENV(env),3,,2599,1,,void
117015,BLOCK,-1,,CHECK_ENV(env),3,,2599,2,,void
117022,BLOCK,1,,<empty>,,,,3,,void
117024,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2600,1,,void
117030,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2600,2,,void
117039,BLOCK,1,,<empty>,,,,3,,void
117041,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2601,1,,void
117047,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2601,2,,void
117074,BLOCK,1,,<empty>,,,,1,,void
117076,BLOCK,-1,,"{
    if (!(v8_value->IsObject() || v8_value->IsFunction() ||
          v8_value->IsSymbol())) {
      return napi_set_last_error(env, napi_invalid_arg);
    }
  }",61,,2604,2,,void
117093,BLOCK,-1,,"{
      return napi_set_last_error(env, napi_invalid_arg);
    }",34,,2606,2,,void
117129,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, ref);

  delete reinterpret_cast<v8impl::Reference*>(ref);

  return napi_clear_last_error(env);
}",74,,2620,3,,void
117132,BLOCK,1,,<empty>,,,,2,,void
117134,BLOCK,-1,,CHECK_ENV(env),3,,2623,1,,void
117139,BLOCK,-1,,CHECK_ENV(env),3,,2623,2,,void
117146,BLOCK,1,,<empty>,,,,3,,void
117148,BLOCK,-1,,"CHECK_ARG(env, ref)",3,,2624,1,,void
117154,BLOCK,-1,,"CHECK_ARG(env, ref)",3,,2624,2,,void
117173,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, ref);

  v8impl::Reference* reference = reinterpret_cast<v8impl::Reference*>(ref);
  uint32_t count = reference->Ref();

  if (result != nullptr) {
    *result = count;
  }

  return napi_clear_last_error(env);
}",61,,2638,4,,void
117176,BLOCK,1,,<empty>,,,,2,,void
117178,BLOCK,-1,,CHECK_ENV(env),3,,2641,1,,void
117183,BLOCK,-1,,CHECK_ENV(env),3,,2641,2,,void
117190,BLOCK,1,,<empty>,,,,3,,void
117192,BLOCK,-1,,"CHECK_ARG(env, ref)",3,,2642,1,,void
117198,BLOCK,-1,,"CHECK_ARG(env, ref)",3,,2642,2,,void
117221,BLOCK,-1,,"{
    *result = count;
  }",26,,2647,2,,void
117235,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, ref);

  v8impl::Reference* reference = reinterpret_cast<v8impl::Reference*>(ref);

  if (reference->RefCount() == 0) {
    return napi_set_last_error(env, napi_generic_failure);
  }

  uint32_t count = reference->Unref();

  if (result != nullptr) {
    *result = count;
  }

  return napi_clear_last_error(env);
}",63,,2660,4,,void
117238,BLOCK,1,,<empty>,,,,2,,void
117240,BLOCK,-1,,CHECK_ENV(env),3,,2663,1,,void
117245,BLOCK,-1,,CHECK_ENV(env),3,,2663,2,,void
117252,BLOCK,1,,<empty>,,,,3,,void
117254,BLOCK,-1,,"CHECK_ARG(env, ref)",3,,2664,1,,void
117260,BLOCK,-1,,"CHECK_ARG(env, ref)",3,,2664,2,,void
117279,BLOCK,-1,,"{
    return napi_set_last_error(env, napi_generic_failure);
  }",35,,2668,2,,void
117295,BLOCK,-1,,"{
    *result = count;
  }",26,,2674,2,,void
117309,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, ref);
  CHECK_ARG(env, result);

  v8impl::Reference* reference = reinterpret_cast<v8impl::Reference*>(ref);
  *result = v8impl::JsValueFromV8LocalValue(reference->Get());

  return napi_clear_last_error(env);
}",69,,2686,4,,void
117312,BLOCK,1,,<empty>,,,,2,,void
117314,BLOCK,-1,,CHECK_ENV(env),3,,2689,1,,void
117319,BLOCK,-1,,CHECK_ENV(env),3,,2689,2,,void
117326,BLOCK,1,,<empty>,,,,3,,void
117328,BLOCK,-1,,"CHECK_ARG(env, ref)",3,,2690,1,,void
117334,BLOCK,-1,,"CHECK_ARG(env, ref)",3,,2690,2,,void
117343,BLOCK,1,,<empty>,,,,3,,void
117345,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2691,1,,void
117351,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2691,2,,void
117382,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsHandleScopeFromV8HandleScope(
      new v8impl::HandleScopeWrapper(env->isolate));
  env->open_handle_scopes++;
  return napi_clear_last_error(env);
}",74,,2700,3,,void
117385,BLOCK,1,,<empty>,,,,2,,void
117387,BLOCK,-1,,CHECK_ENV(env),3,,2703,1,,void
117392,BLOCK,-1,,CHECK_ENV(env),3,,2703,2,,void
117399,BLOCK,1,,<empty>,,,,3,,void
117401,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2704,1,,void
117407,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2704,2,,void
117437,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, scope);
  if (env->open_handle_scopes == 0) {
    return napi_handle_scope_mismatch;
  }

  env->open_handle_scopes--;
  delete v8impl::V8HandleScopeFromJsHandleScope(scope);
  return napi_clear_last_error(env);
}",73,,2713,3,,void
117440,BLOCK,1,,<empty>,,,,2,,void
117442,BLOCK,-1,,CHECK_ENV(env),3,,2716,1,,void
117447,BLOCK,-1,,CHECK_ENV(env),3,,2716,2,,void
117454,BLOCK,1,,<empty>,,,,3,,void
117456,BLOCK,-1,,"CHECK_ARG(env, scope)",3,,2717,1,,void
117462,BLOCK,-1,,"CHECK_ARG(env, scope)",3,,2717,2,,void
117474,BLOCK,-1,,"{
    return napi_handle_scope_mismatch;
  }",37,,2718,2,,void
117495,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsEscapableHandleScopeFromV8EscapableHandleScope(
      new v8impl::EscapableHandleScopeWrapper(env->isolate));
  env->open_handle_scopes++;
  return napi_clear_last_error(env);
}",56,,2728,3,,void
117498,BLOCK,1,,<empty>,,,,2,,void
117500,BLOCK,-1,,CHECK_ENV(env),3,,2731,1,,void
117505,BLOCK,-1,,CHECK_ENV(env),3,,2731,2,,void
117512,BLOCK,1,,<empty>,,,,3,,void
117514,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2732,1,,void
117520,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2732,2,,void
117550,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, scope);
  if (env->open_handle_scopes == 0) {
    return napi_handle_scope_mismatch;
  }

  delete v8impl::V8EscapableHandleScopeFromJsEscapableHandleScope(scope);
  env->open_handle_scopes--;
  return napi_clear_last_error(env);
}",54,,2741,3,,void
117553,BLOCK,1,,<empty>,,,,2,,void
117555,BLOCK,-1,,CHECK_ENV(env),3,,2744,1,,void
117560,BLOCK,-1,,CHECK_ENV(env),3,,2744,2,,void
117567,BLOCK,1,,<empty>,,,,3,,void
117569,BLOCK,-1,,"CHECK_ARG(env, scope)",3,,2745,1,,void
117575,BLOCK,-1,,"CHECK_ARG(env, scope)",3,,2745,2,,void
117587,BLOCK,-1,,"{
    return napi_handle_scope_mismatch;
  }",37,,2746,2,,void
117610,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, scope);
  CHECK_ARG(env, escapee);
  CHECK_ARG(env, result);

  v8impl::EscapableHandleScopeWrapper* s =
      v8impl::V8EscapableHandleScopeFromJsEscapableHandleScope(scope);
  if (!s->escape_called()) {
    *result = v8impl::JsValueFromV8LocalValue(
        s->Escape(v8impl::V8LocalValueFromJsValue(escapee)));
    return napi_clear_last_error(env);
  }
  return napi_set_last_error(env, napi_escape_called_twice);
}",63,,2758,5,,void
117613,BLOCK,1,,<empty>,,,,2,,void
117615,BLOCK,-1,,CHECK_ENV(env),3,,2761,1,,void
117620,BLOCK,-1,,CHECK_ENV(env),3,,2761,2,,void
117627,BLOCK,1,,<empty>,,,,3,,void
117629,BLOCK,-1,,"CHECK_ARG(env, scope)",3,,2762,1,,void
117635,BLOCK,-1,,"CHECK_ARG(env, scope)",3,,2762,2,,void
117644,BLOCK,1,,<empty>,,,,3,,void
117646,BLOCK,-1,,"CHECK_ARG(env, escapee)",3,,2763,1,,void
117652,BLOCK,-1,,"CHECK_ARG(env, escapee)",3,,2763,2,,void
117661,BLOCK,1,,<empty>,,,,3,,void
117663,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2764,1,,void
117669,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2764,2,,void
117689,BLOCK,-1,,"{
    *result = v8impl::JsValueFromV8LocalValue(
        s->Escape(v8impl::V8LocalValueFromJsValue(escapee)));
    return napi_clear_last_error(env);
  }",28,,2768,2,,void
117721,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, constructor);
  if (argc > 0) {
    CHECK_ARG(env, argv);
  }
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Function> ctor;
  CHECK_TO_FUNCTION(env, ctor, constructor);

  auto maybe = ctor->NewInstance(
      context,
      argc,
      reinterpret_cast<v8::Local<v8::Value>*>(const_cast<napi_value*>(argv)));

  CHECK_MAYBE_EMPTY(env, maybe, napi_pending_exception);

  *result = v8impl::JsValueFromV8LocalValue(maybe.ToLocalChecked());
  return GET_RETURN_STATUS(env);
}",62,,2780,6,,void
117724,BLOCK,1,,<empty>,,,,2,,void
117726,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2781,1,,void
117731,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2781,2,,void
117736,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2781,1,,void
117745,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2781,2,,void
117752,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2781,1,,void
117759,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2781,2,,void
117780,BLOCK,1,,<empty>,,,,3,,void
117782,BLOCK,-1,,"CHECK_ARG(env, constructor)",3,,2782,1,,void
117788,BLOCK,-1,,"CHECK_ARG(env, constructor)",3,,2782,2,,void
117798,BLOCK,-1,,"{
    CHECK_ARG(env, argv);
  }",17,,2783,2,,void
117802,BLOCK,1,,<empty>,,,,3,,void
117804,BLOCK,-1,,"CHECK_ARG(env, argv)",5,,2784,1,,void
117810,BLOCK,-1,,"CHECK_ARG(env, argv)",5,,2784,2,,void
117819,BLOCK,1,,<empty>,,,,3,,void
117821,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2786,1,,void
117827,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2786,2,,void
117860,BLOCK,1,,<empty>,,,,4,,void
117862,BLOCK,-1,,"CHECK_TO_FUNCTION(env, ctor, constructor)",3,,2791,1,,void
117864,BLOCK,-1,,"CHECK_TO_FUNCTION(env, ctor, constructor)",3,,2791,1,,void
117870,BLOCK,-1,,"CHECK_TO_FUNCTION(env, ctor, constructor)",3,,2791,2,,void
117892,BLOCK,-1,,"CHECK_TO_FUNCTION(env, ctor, constructor)",3,,2791,1,,void
117899,BLOCK,-1,,"CHECK_TO_FUNCTION(env, ctor, constructor)",3,,2791,2,,void
117930,BLOCK,1,,<empty>,,,,5,,void
117932,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe, napi_pending_exception)",3,,2798,1,,void
117940,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe, napi_pending_exception)",3,,2798,2,,void
117960,BLOCK,1,,<empty>,,,,3,,void
117978,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, object);
  CHECK_ARG(env, result);

  *result = false;

  v8::Local<v8::Object> ctor;
  v8::Local<v8::Context> context = env->context();

  CHECK_TO_OBJECT(env, context, ctor, constructor);

  if (!ctor->IsFunction()) {
    napi_throw_type_error(
        env, ""ERR_NAPI_CONS_FUNCTION"", ""Constructor must be a function"");

    return napi_set_last_error(env, napi_function_expected);
  }

  napi_status status = napi_generic_failure;

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(object);
  auto maybe_result = val->InstanceOf(context, ctor);
  CHECK_MAYBE_NOTHING(env, maybe_result, status);
  *result = maybe_result.FromJust();
  return GET_RETURN_STATUS(env);
}",54,,2807,5,,void
117981,BLOCK,1,,<empty>,,,,2,,void
117983,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2808,1,,void
117988,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2808,2,,void
117993,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2808,1,,void
118002,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2808,2,,void
118009,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2808,1,,void
118016,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2808,2,,void
118037,BLOCK,1,,<empty>,,,,3,,void
118039,BLOCK,-1,,"CHECK_ARG(env, object)",3,,2809,1,,void
118045,BLOCK,-1,,"CHECK_ARG(env, object)",3,,2809,2,,void
118054,BLOCK,1,,<empty>,,,,3,,void
118056,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2810,1,,void
118062,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2810,2,,void
118101,BLOCK,1,,<empty>,,,,7,,void
118103,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, ctor, constructor)",3,,2817,1,,void
118105,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, ctor, constructor)",3,,2817,1,,void
118111,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, ctor, constructor)",3,,2817,2,,void
118130,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, ctor, constructor)",3,,2817,1,,void
118138,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, ctor, constructor)",3,,2817,2,,void
118157,BLOCK,-1,,"{
    napi_throw_type_error(
        env, ""ERR_NAPI_CONS_FUNCTION"", ""Constructor must be a function"");

    return napi_set_last_error(env, napi_function_expected);
  }",28,,2819,2,,void
118198,BLOCK,1,,<empty>,,,,6,,void
118200,BLOCK,-1,,"CHECK_MAYBE_NOTHING(env, maybe_result, status)",3,,2830,1,,void
118208,BLOCK,-1,,"CHECK_MAYBE_NOTHING(env, maybe_result, status)",3,,2830,2,,void
118224,BLOCK,1,,<empty>,,,,3,,void
118240,BLOCK,-1,,"{
  // NAPI_PREAMBLE is not used here: this function must execute when there is a
  // pending exception.
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = !env->last_exception.IsEmpty();
  return napi_clear_last_error(env);
}",78,,2836,3,,void
118243,BLOCK,1,,<empty>,,,,2,,void
118245,BLOCK,-1,,CHECK_ENV(env),3,,2839,1,,void
118250,BLOCK,-1,,CHECK_ENV(env),3,,2839,2,,void
118257,BLOCK,1,,<empty>,,,,3,,void
118259,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2840,1,,void
118265,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2840,2,,void
118289,BLOCK,-1,,"{
  // NAPI_PREAMBLE is not used here: this function must execute when there is a
  // pending exception.
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  if (env->last_exception.IsEmpty()) {
    return napi_get_undefined(env, result);
  } else {
    *result = v8impl::JsValueFromV8LocalValue(
        v8::Local<v8::Value>::New(env->isolate, env->last_exception));
    env->last_exception.Reset();
  }

  return napi_clear_last_error(env);
}",78,,2847,3,,void
118292,BLOCK,1,,<empty>,,,,2,,void
118294,BLOCK,-1,,CHECK_ENV(env),3,,2850,1,,void
118299,BLOCK,-1,,CHECK_ENV(env),3,,2850,2,,void
118306,BLOCK,1,,<empty>,,,,3,,void
118308,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2851,1,,void
118314,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2851,2,,void
118327,BLOCK,-1,,"{
    return napi_get_undefined(env, result);
  }",38,,2853,2,,void
118333,BLOCK,-1,,"{
    *result = v8impl::JsValueFromV8LocalValue(
        v8::Local<v8::Value>::New(env->isolate, env->last_exception));
    env->last_exception.Reset();
  }",10,,2855,1,,void
118374,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  *result = val->IsArrayBuffer();

  return napi_clear_last_error(env);
}",58,,2866,4,,void
118377,BLOCK,1,,<empty>,,,,2,,void
118379,BLOCK,-1,,CHECK_ENV(env),3,,2867,1,,void
118384,BLOCK,-1,,CHECK_ENV(env),3,,2867,2,,void
118391,BLOCK,1,,<empty>,,,,3,,void
118393,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2868,1,,void
118399,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2868,2,,void
118408,BLOCK,1,,<empty>,,,,3,,void
118410,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2869,1,,void
118416,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2869,2,,void
118454,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::Isolate* isolate = env->isolate;
  v8::Local<v8::ArrayBuffer> buffer =
      v8::ArrayBuffer::New(isolate, byte_length);

  // Optionally return a pointer to the buffer's data, to avoid another call to
  // retrieve it.
  if (data != nullptr) {
    *data = buffer->Data();
  }

  *result = v8impl::JsValueFromV8LocalValue(buffer);
  return GET_RETURN_STATUS(env);
}",68,,2880,5,,void
118457,BLOCK,1,,<empty>,,,,2,,void
118459,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2881,1,,void
118464,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2881,2,,void
118469,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2881,1,,void
118478,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2881,2,,void
118485,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2881,1,,void
118492,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2881,2,,void
118513,BLOCK,1,,<empty>,,,,3,,void
118515,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2882,1,,void
118521,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2882,2,,void
118555,BLOCK,-1,,"{
    *data = buffer->Data();
  }",24,,2890,2,,void
118574,BLOCK,1,,<empty>,,,,3,,void
118594,BLOCK,-1,,"{
  // The API contract here is that the cleanup function runs on the JS thread,
  // and is able to use napi_env. Implementing that properly is hard, so use the
  // `Buffer` variant for easier implementation.
  napi_value buffer;
  STATUS_CALL(napi_create_external_buffer(
      env, byte_length, external_data, finalize_cb, finalize_hint, &buffer));
  return napi_get_typedarray_info(
      env, buffer, nullptr, nullptr, nullptr, result, nullptr);
}",54,,2904,7,,void
118598,BLOCK,1,,<empty>,,,,4,,void
118600,BLOCK,-1,,"STATUS_CALL(napi_create_external_buffer(
      env, byte_length, external_data, finalize_cb, finalize_hint, &buffer))",3,,2909,1,,void
118616,BLOCK,-1,,<empty>,3,,2909,2,,void
118636,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, arraybuffer);

  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(arraybuffer);
  RETURN_STATUS_IF_FALSE(env, value->IsArrayBuffer(), napi_invalid_arg);

  v8::Local<v8::ArrayBuffer> ab = value.As<v8::ArrayBuffer>();

  if (data != nullptr) {
    *data = ab->Data();
  }

  if (byte_length != nullptr) {
    *byte_length = ab->ByteLength();
  }

  return napi_clear_last_error(env);
}",71,,2918,5,,void
118639,BLOCK,1,,<empty>,,,,2,,void
118641,BLOCK,-1,,CHECK_ENV(env),3,,2919,1,,void
118646,BLOCK,-1,,CHECK_ENV(env),3,,2919,2,,void
118653,BLOCK,1,,<empty>,,,,3,,void
118655,BLOCK,-1,,"CHECK_ARG(env, arraybuffer)",3,,2920,1,,void
118661,BLOCK,-1,,"CHECK_ARG(env, arraybuffer)",3,,2920,2,,void
118689,BLOCK,1,,<empty>,,,,4,,void
118691,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, value->IsArrayBuffer(), napi_invalid_arg)",3,,2923,1,,void
118698,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, value->IsArrayBuffer(), napi_invalid_arg)",3,,2923,2,,void
118722,BLOCK,-1,,"{
    *data = ab->Data();
  }",24,,2927,2,,void
118734,BLOCK,-1,,"{
    *byte_length = ab->ByteLength();
  }",31,,2931,2,,void
118751,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  *result = val->IsTypedArray();

  return napi_clear_last_error(env);
}",57,,2940,4,,void
118754,BLOCK,1,,<empty>,,,,2,,void
118756,BLOCK,-1,,CHECK_ENV(env),3,,2941,1,,void
118761,BLOCK,-1,,CHECK_ENV(env),3,,2941,2,,void
118768,BLOCK,1,,<empty>,,,,3,,void
118770,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2942,1,,void
118776,BLOCK,-1,,"CHECK_ARG(env, value)",3,,2942,2,,void
118785,BLOCK,1,,<empty>,,,,3,,void
118787,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2943,1,,void
118793,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2943,2,,void
118833,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, arraybuffer);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(arraybuffer);
  RETURN_STATUS_IF_FALSE(env, value->IsArrayBuffer(), napi_invalid_arg);

  v8::Local<v8::ArrayBuffer> buffer = value.As<v8::ArrayBuffer>();
  v8::Local<v8::TypedArray> typedArray;

  switch (type) {
    case napi_int8_array:
      CREATE_TYPED_ARRAY(
          env, Int8Array, 1, buffer, byte_offset, length, typedArray);
      break;
    case napi_uint8_array:
      CREATE_TYPED_ARRAY(
          env, Uint8Array, 1, buffer, byte_offset, length, typedArray);
      break;
    case napi_uint8_clamped_array:
      CREATE_TYPED_ARRAY(
          env, Uint8ClampedArray, 1, buffer, byte_offset, length, typedArray);
      break;
    case napi_int16_array:
      CREATE_TYPED_ARRAY(
          env, Int16Array, 2, buffer, byte_offset, length, typedArray);
      break;
    case napi_uint16_array:
      CREATE_TYPED_ARRAY(
          env, Uint...",67,,2956,7,,void
118836,BLOCK,1,,<empty>,,,,2,,void
118838,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2957,1,,void
118843,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2957,2,,void
118848,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2957,1,,void
118857,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2957,2,,void
118864,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2957,1,,void
118871,BLOCK,-1,,NAPI_PREAMBLE(env),3,,2957,2,,void
118892,BLOCK,1,,<empty>,,,,3,,void
118894,BLOCK,-1,,"CHECK_ARG(env, arraybuffer)",3,,2958,1,,void
118900,BLOCK,-1,,"CHECK_ARG(env, arraybuffer)",3,,2958,2,,void
118909,BLOCK,1,,<empty>,,,,3,,void
118911,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2959,1,,void
118917,BLOCK,-1,,"CHECK_ARG(env, result)",3,,2959,2,,void
118945,BLOCK,1,,<empty>,,,,4,,void
118947,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, value->IsArrayBuffer(), napi_invalid_arg)",3,,2962,1,,void
118954,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, value->IsArrayBuffer(), napi_invalid_arg)",3,,2962,2,,void
118985,BLOCK,-1,,"{
    case napi_int8_array:
      CREATE_TYPED_ARRAY(
          env, Int8Array, 1, buffer, byte_offset, length, typedArray);
      break;
    case napi_uint8_array:
      CREATE_TYPED_ARRAY(
          env, Uint8Array, 1, buffer, byte_offset, length, typedArray);
      break;
    case napi_uint8_clamped_array:
      CREATE_TYPED_ARRAY(
          env, Uint8ClampedArray, 1, buffer, byte_offset, length, typedArray);
      break;
    case napi_int16_array:
      CREATE_TYPED_ARRAY(
          env, Int16Array, 2, buffer, byte_offset, length, typedArray);
      break;
    case napi_uint16_array:
      CREATE_TYPED_ARRAY(
          env, Uint16Array, 2, buffer, byte_offset, length, typedArray);
      break;
    case napi_int32_array:
      CREATE_TYPED_ARRAY(
          env, Int32Array, 4, buffer, byte_offset, length, typedArray);
      break;
    case napi_uint32_array:
      CREATE_TYPED_ARRAY(
          env, Uint32Array, 4, buffer, byte_offset, length, typedArray);
      break;
    case nap...",17,,2967,2,,void
118995,BLOCK,1,,<empty>,,,,7,,void
118997,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int8Array, 1, buffer, byte_offset, length, typedArray)",7,,2969,1,,void
119002,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int8Array, 1, buffer, byte_offset, length, typedArray)",7,,2969,2,,void
119004,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int8Array, 1, buffer, byte_offset, length, typedArray)",7,,2969,1,,void
119012,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int8Array, 1, buffer, byte_offset, length, typedArray)",7,,2969,2,,void
119023,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int8Array, 1, buffer, byte_offset, length, typedArray)",7,,2969,1,,void
119036,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int8Array, 1, buffer, byte_offset, length, typedArray)",7,,2969,2,,void
119068,BLOCK,1,,<empty>,,,,7,,void
119070,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint8Array, 1, buffer, byte_offset, length, typedArray)",7,,2973,1,,void
119075,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint8Array, 1, buffer, byte_offset, length, typedArray)",7,,2973,2,,void
119077,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint8Array, 1, buffer, byte_offset, length, typedArray)",7,,2973,1,,void
119085,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint8Array, 1, buffer, byte_offset, length, typedArray)",7,,2973,2,,void
119096,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint8Array, 1, buffer, byte_offset, length, typedArray)",7,,2973,1,,void
119109,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint8Array, 1, buffer, byte_offset, length, typedArray)",7,,2973,2,,void
119141,BLOCK,1,,<empty>,,,,7,,void
119143,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint8ClampedArray, 1, buffer, byte_offset, length, typedArray)",7,,2977,1,,void
119148,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint8ClampedArray, 1, buffer, byte_offset, length, typedArray)",7,,2977,2,,void
119150,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint8ClampedArray, 1, buffer, byte_offset, length, typedArray)",7,,2977,1,,void
119158,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint8ClampedArray, 1, buffer, byte_offset, length, typedArray)",7,,2977,2,,void
119169,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint8ClampedArray, 1, buffer, byte_offset, length, typedArray)",7,,2977,1,,void
119182,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint8ClampedArray, 1, buffer, byte_offset, length, typedArray)",7,,2977,2,,void
119214,BLOCK,1,,<empty>,,,,7,,void
119216,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int16Array, 2, buffer, byte_offset, length, typedArray)",7,,2981,1,,void
119221,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int16Array, 2, buffer, byte_offset, length, typedArray)",7,,2981,2,,void
119223,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int16Array, 2, buffer, byte_offset, length, typedArray)",7,,2981,1,,void
119231,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int16Array, 2, buffer, byte_offset, length, typedArray)",7,,2981,2,,void
119242,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int16Array, 2, buffer, byte_offset, length, typedArray)",7,,2981,1,,void
119255,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int16Array, 2, buffer, byte_offset, length, typedArray)",7,,2981,2,,void
119287,BLOCK,1,,<empty>,,,,7,,void
119289,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint16Array, 2, buffer, byte_offset, length, typedArray)",7,,2985,1,,void
119294,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint16Array, 2, buffer, byte_offset, length, typedArray)",7,,2985,2,,void
119296,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint16Array, 2, buffer, byte_offset, length, typedArray)",7,,2985,1,,void
119304,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint16Array, 2, buffer, byte_offset, length, typedArray)",7,,2985,2,,void
119315,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint16Array, 2, buffer, byte_offset, length, typedArray)",7,,2985,1,,void
119328,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint16Array, 2, buffer, byte_offset, length, typedArray)",7,,2985,2,,void
119360,BLOCK,1,,<empty>,,,,7,,void
119362,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int32Array, 4, buffer, byte_offset, length, typedArray)",7,,2989,1,,void
119367,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int32Array, 4, buffer, byte_offset, length, typedArray)",7,,2989,2,,void
119369,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int32Array, 4, buffer, byte_offset, length, typedArray)",7,,2989,1,,void
119377,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int32Array, 4, buffer, byte_offset, length, typedArray)",7,,2989,2,,void
119388,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int32Array, 4, buffer, byte_offset, length, typedArray)",7,,2989,1,,void
119401,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Int32Array, 4, buffer, byte_offset, length, typedArray)",7,,2989,2,,void
119433,BLOCK,1,,<empty>,,,,7,,void
119435,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint32Array, 4, buffer, byte_offset, length, typedArray)",7,,2993,1,,void
119440,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint32Array, 4, buffer, byte_offset, length, typedArray)",7,,2993,2,,void
119442,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint32Array, 4, buffer, byte_offset, length, typedArray)",7,,2993,1,,void
119450,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint32Array, 4, buffer, byte_offset, length, typedArray)",7,,2993,2,,void
119461,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint32Array, 4, buffer, byte_offset, length, typedArray)",7,,2993,1,,void
119474,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Uint32Array, 4, buffer, byte_offset, length, typedArray)",7,,2993,2,,void
119506,BLOCK,1,,<empty>,,,,7,,void
119508,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Float32Array, 4, buffer, byte_offset, length, typedArray)",7,,2997,1,,void
119513,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Float32Array, 4, buffer, byte_offset, length, typedArray)",7,,2997,2,,void
119515,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Float32Array, 4, buffer, byte_offset, length, typedArray)",7,,2997,1,,void
119523,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Float32Array, 4, buffer, byte_offset, length, typedArray)",7,,2997,2,,void
119534,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Float32Array, 4, buffer, byte_offset, length, typedArray)",7,,2997,1,,void
119547,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Float32Array, 4, buffer, byte_offset, length, typedArray)",7,,2997,2,,void
119579,BLOCK,1,,<empty>,,,,7,,void
119581,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Float64Array, 8, buffer, byte_offset, length, typedArray)",7,,3001,1,,void
119586,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Float64Array, 8, buffer, byte_offset, length, typedArray)",7,,3001,2,,void
119588,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Float64Array, 8, buffer, byte_offset, length, typedArray)",7,,3001,1,,void
119596,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Float64Array, 8, buffer, byte_offset, length, typedArray)",7,,3001,2,,void
119607,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Float64Array, 8, buffer, byte_offset, length, typedArray)",7,,3001,1,,void
119620,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, Float64Array, 8, buffer, byte_offset, length, typedArray)",7,,3001,2,,void
119652,BLOCK,1,,<empty>,,,,7,,void
119654,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, BigInt64Array, 8, buffer, byte_offset, length, typedArray)",7,,3005,1,,void
119659,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, BigInt64Array, 8, buffer, byte_offset, length, typedArray)",7,,3005,2,,void
119661,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, BigInt64Array, 8, buffer, byte_offset, length, typedArray)",7,,3005,1,,void
119669,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, BigInt64Array, 8, buffer, byte_offset, length, typedArray)",7,,3005,2,,void
119680,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, BigInt64Array, 8, buffer, byte_offset, length, typedArray)",7,,3005,1,,void
119693,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, BigInt64Array, 8, buffer, byte_offset, length, typedArray)",7,,3005,2,,void
119725,BLOCK,1,,<empty>,,,,7,,void
119727,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, BigUint64Array, 8, buffer, byte_offset, length, typedArray)",7,,3009,1,,void
119732,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, BigUint64Array, 8, buffer, byte_offset, length, typedArray)",7,,3009,2,,void
119734,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, BigUint64Array, 8, buffer, byte_offset, length, typedArray)",7,,3009,1,,void
119742,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, BigUint64Array, 8, buffer, byte_offset, length, typedArray)",7,,3009,2,,void
119753,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, BigUint64Array, 8, buffer, byte_offset, length, typedArray)",7,,3009,1,,void
119766,BLOCK,-1,,"CREATE_TYPED_ARRAY(
          env, BigUint64Array, 8, buffer, byte_offset, length, typedArray)",7,,3009,2,,void
119805,BLOCK,1,,<empty>,,,,3,,void
119826,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, typedarray);

  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(typedarray);
  RETURN_STATUS_IF_FALSE(env, value->IsTypedArray(), napi_invalid_arg);

  v8::Local<v8::TypedArray> array = value.As<v8::TypedArray>();

  if (type != nullptr) {
    if (value->IsInt8Array()) {
      *type = napi_int8_array;
    } else if (value->IsUint8Array()) {
      *type = napi_uint8_array;
    } else if (value->IsUint8ClampedArray()) {
      *type = napi_uint8_clamped_array;
    } else if (value->IsInt16Array()) {
      *type = napi_int16_array;
    } else if (value->IsUint16Array()) {
      *type = napi_uint16_array;
    } else if (value->IsInt32Array()) {
      *type = napi_int32_array;
    } else if (value->IsUint32Array()) {
      *type = napi_uint32_array;
    } else if (value->IsFloat32Array()) {
      *type = napi_float32_array;
    } else if (value->IsFloat64Array()) {
      *type = napi_float64_array;
    } else if (value->IsBigInt64Array()) ...",70,,3026,8,,void
119829,BLOCK,1,,<empty>,,,,2,,void
119831,BLOCK,-1,,CHECK_ENV(env),3,,3027,1,,void
119836,BLOCK,-1,,CHECK_ENV(env),3,,3027,2,,void
119843,BLOCK,1,,<empty>,,,,3,,void
119845,BLOCK,-1,,"CHECK_ARG(env, typedarray)",3,,3028,1,,void
119851,BLOCK,-1,,"CHECK_ARG(env, typedarray)",3,,3028,2,,void
119879,BLOCK,1,,<empty>,,,,4,,void
119881,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, value->IsTypedArray(), napi_invalid_arg)",3,,3031,1,,void
119888,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, value->IsTypedArray(), napi_invalid_arg)",3,,3031,2,,void
119912,BLOCK,-1,,"{
    if (value->IsInt8Array()) {
      *type = napi_int8_array;
    } else if (value->IsUint8Array()) {
      *type = napi_uint8_array;
    } else if (value->IsUint8ClampedArray()) {
      *type = napi_uint8_clamped_array;
    } else if (value->IsInt16Array()) {
      *type = napi_int16_array;
    } else if (value->IsUint16Array()) {
      *type = napi_uint16_array;
    } else if (value->IsInt32Array()) {
      *type = napi_int32_array;
    } else if (value->IsUint32Array()) {
      *type = napi_uint32_array;
    } else if (value->IsFloat32Array()) {
      *type = napi_float32_array;
    } else if (value->IsFloat64Array()) {
      *type = napi_float64_array;
    } else if (value->IsBigInt64Array()) {
      *type = napi_bigint64_array;
    } else if (value->IsBigUint64Array()) {
      *type = napi_biguint64_array;
    }
  }",24,,3035,2,,void
119918,BLOCK,-1,,"{
      *type = napi_int8_array;
    }",31,,3036,2,,void
119924,BLOCK,-1,,<empty>,12,,3038,1,,void
119930,BLOCK,-1,,"{
      *type = napi_uint8_array;
    }",39,,3038,2,,void
119936,BLOCK,-1,,<empty>,12,,3040,1,,void
119942,BLOCK,-1,,"{
      *type = napi_uint8_clamped_array;
    }",46,,3040,2,,void
119948,BLOCK,-1,,<empty>,12,,3042,1,,void
119954,BLOCK,-1,,"{
      *type = napi_int16_array;
    }",39,,3042,2,,void
119960,BLOCK,-1,,<empty>,12,,3044,1,,void
119966,BLOCK,-1,,"{
      *type = napi_uint16_array;
    }",40,,3044,2,,void
119972,BLOCK,-1,,<empty>,12,,3046,1,,void
119978,BLOCK,-1,,"{
      *type = napi_int32_array;
    }",39,,3046,2,,void
119984,BLOCK,-1,,<empty>,12,,3048,1,,void
119990,BLOCK,-1,,"{
      *type = napi_uint32_array;
    }",40,,3048,2,,void
119996,BLOCK,-1,,<empty>,12,,3050,1,,void
120002,BLOCK,-1,,"{
      *type = napi_float32_array;
    }",41,,3050,2,,void
120008,BLOCK,-1,,<empty>,12,,3052,1,,void
120014,BLOCK,-1,,"{
      *type = napi_float64_array;
    }",41,,3052,2,,void
120020,BLOCK,-1,,<empty>,12,,3054,1,,void
120026,BLOCK,-1,,"{
      *type = napi_bigint64_array;
    }",42,,3054,2,,void
120032,BLOCK,-1,,<empty>,12,,3056,1,,void
120038,BLOCK,-1,,"{
      *type = napi_biguint64_array;
    }",43,,3056,2,,void
120047,BLOCK,-1,,"{
    *length = array->Length();
  }",26,,3061,2,,void
120072,BLOCK,-1,,"{
    // Calling Buffer() may have the side effect of allocating the buffer,
    // so only do this when its needed.
    buffer = array->Buffer();
  }",50,,3066,2,,void
120083,BLOCK,-1,,"{
    *data = static_cast<uint8_t*>(buffer->Data()) + array->ByteOffset();
  }",24,,3072,2,,void
120102,BLOCK,-1,,"{
    *arraybuffer = v8impl::JsValueFromV8LocalValue(buffer);
  }",31,,3076,2,,void
120115,BLOCK,-1,,"{
    *byte_offset = array->ByteOffset();
  }",31,,3080,2,,void
120134,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, arraybuffer);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(arraybuffer);
  RETURN_STATUS_IF_FALSE(env, value->IsArrayBuffer(), napi_invalid_arg);

  v8::Local<v8::ArrayBuffer> buffer = value.As<v8::ArrayBuffer>();
  if (byte_length + byte_offset > buffer->ByteLength()) {
    napi_throw_range_error(env,
                           ""ERR_NAPI_INVALID_DATAVIEW_ARGS"",
                           ""byte_offset + byte_length should be less than or ""
                           ""equal to the size in bytes of the array passed in"");
    return napi_set_last_error(env, napi_pending_exception);
  }
  v8::Local<v8::DataView> DataView =
      v8::DataView::New(buffer, byte_offset, byte_length);

  *result = v8impl::JsValueFromV8LocalValue(DataView);
  return GET_RETURN_STATUS(env);
}",65,,3091,6,,void
120137,BLOCK,1,,<empty>,,,,2,,void
120139,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3092,1,,void
120144,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3092,2,,void
120149,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3092,1,,void
120158,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3092,2,,void
120165,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3092,1,,void
120172,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3092,2,,void
120193,BLOCK,1,,<empty>,,,,3,,void
120195,BLOCK,-1,,"CHECK_ARG(env, arraybuffer)",3,,3093,1,,void
120201,BLOCK,-1,,"CHECK_ARG(env, arraybuffer)",3,,3093,2,,void
120210,BLOCK,1,,<empty>,,,,3,,void
120212,BLOCK,-1,,"CHECK_ARG(env, result)",3,,3094,1,,void
120218,BLOCK,-1,,"CHECK_ARG(env, result)",3,,3094,2,,void
120246,BLOCK,1,,<empty>,,,,4,,void
120248,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, value->IsArrayBuffer(), napi_invalid_arg)",3,,3097,1,,void
120255,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, value->IsArrayBuffer(), napi_invalid_arg)",3,,3097,2,,void
120284,BLOCK,-1,,"{
    napi_throw_range_error(env,
                           ""ERR_NAPI_INVALID_DATAVIEW_ARGS"",
                           ""byte_offset + byte_length should be less than or ""
                           ""equal to the size in bytes of the array passed in"");
    return napi_set_last_error(env, napi_pending_exception);
  }",57,,3100,2,,void
120323,BLOCK,1,,<empty>,,,,3,,void
120340,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  *result = val->IsDataView();

  return napi_clear_last_error(env);
}",55,,3116,4,,void
120343,BLOCK,1,,<empty>,,,,2,,void
120345,BLOCK,-1,,CHECK_ENV(env),3,,3117,1,,void
120350,BLOCK,-1,,CHECK_ENV(env),3,,3117,2,,void
120357,BLOCK,1,,<empty>,,,,3,,void
120359,BLOCK,-1,,"CHECK_ARG(env, value)",3,,3118,1,,void
120365,BLOCK,-1,,"CHECK_ARG(env, value)",3,,3118,2,,void
120374,BLOCK,1,,<empty>,,,,3,,void
120376,BLOCK,-1,,"CHECK_ARG(env, result)",3,,3119,1,,void
120382,BLOCK,-1,,"CHECK_ARG(env, result)",3,,3119,2,,void
120422,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, dataview);

  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(dataview);
  RETURN_STATUS_IF_FALSE(env, value->IsDataView(), napi_invalid_arg);

  v8::Local<v8::DataView> array = value.As<v8::DataView>();

  if (byte_length != nullptr) {
    *byte_length = array->ByteLength();
  }

  v8::Local<v8::ArrayBuffer> buffer;
  if (data != nullptr || arraybuffer != nullptr) {
    // Calling Buffer() may have the side effect of allocating the buffer,
    // so only do this when its needed.
    buffer = array->Buffer();
  }

  if (data != nullptr) {
    *data = static_cast<uint8_t*>(buffer->Data()) + array->ByteOffset();
  }

  if (arraybuffer != nullptr) {
    *arraybuffer = v8impl::JsValueFromV8LocalValue(buffer);
  }

  if (byte_offset != nullptr) {
    *byte_offset = array->ByteOffset();
  }

  return napi_clear_last_error(env);
}",68,,3132,7,,void
120425,BLOCK,1,,<empty>,,,,2,,void
120427,BLOCK,-1,,CHECK_ENV(env),3,,3133,1,,void
120432,BLOCK,-1,,CHECK_ENV(env),3,,3133,2,,void
120439,BLOCK,1,,<empty>,,,,3,,void
120441,BLOCK,-1,,"CHECK_ARG(env, dataview)",3,,3134,1,,void
120447,BLOCK,-1,,"CHECK_ARG(env, dataview)",3,,3134,2,,void
120475,BLOCK,1,,<empty>,,,,4,,void
120477,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, value->IsDataView(), napi_invalid_arg)",3,,3137,1,,void
120484,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, value->IsDataView(), napi_invalid_arg)",3,,3137,2,,void
120508,BLOCK,-1,,"{
    *byte_length = array->ByteLength();
  }",31,,3141,2,,void
120533,BLOCK,-1,,"{
    // Calling Buffer() may have the side effect of allocating the buffer,
    // so only do this when its needed.
    buffer = array->Buffer();
  }",50,,3146,2,,void
120544,BLOCK,-1,,"{
    *data = static_cast<uint8_t*>(buffer->Data()) + array->ByteOffset();
  }",24,,3152,2,,void
120563,BLOCK,-1,,"{
    *arraybuffer = v8impl::JsValueFromV8LocalValue(buffer);
  }",31,,3156,2,,void
120576,BLOCK,-1,,"{
    *byte_offset = array->ByteOffset();
  }",31,,3160,2,,void
120592,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);
  *result = NAPI_VERSION;
  return napi_clear_last_error(env);
}",73,,3167,3,,void
120595,BLOCK,1,,<empty>,,,,2,,void
120597,BLOCK,-1,,CHECK_ENV(env),3,,3168,1,,void
120602,BLOCK,-1,,CHECK_ENV(env),3,,3168,2,,void
120609,BLOCK,1,,<empty>,,,,3,,void
120611,BLOCK,-1,,"CHECK_ARG(env, result)",3,,3169,1,,void
120617,BLOCK,-1,,"CHECK_ARG(env, result)",3,,3169,2,,void
120627,BLOCK,1,,<empty>,,,,1,,void
120638,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, deferred);
  CHECK_ARG(env, promise);

  auto maybe = v8::Promise::Resolver::New(env->context());
  CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure);

  auto v8_resolver = maybe.ToLocalChecked();
  auto v8_deferred = new v8impl::Persistent<v8::Value>();
  v8_deferred->Reset(env->isolate, v8_resolver);

  *deferred = v8impl::JsDeferredFromNodePersistent(v8_deferred);
  *promise = v8impl::JsValueFromV8LocalValue(v8_resolver->GetPromise());
  return GET_RETURN_STATUS(env);
}",65,,3176,4,,void
120641,BLOCK,1,,<empty>,,,,2,,void
120643,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3177,1,,void
120648,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3177,2,,void
120653,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3177,1,,void
120662,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3177,2,,void
120669,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3177,1,,void
120676,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3177,2,,void
120697,BLOCK,1,,<empty>,,,,3,,void
120699,BLOCK,-1,,"CHECK_ARG(env, deferred)",3,,3178,1,,void
120705,BLOCK,-1,,"CHECK_ARG(env, deferred)",3,,3178,2,,void
120714,BLOCK,1,,<empty>,,,,3,,void
120716,BLOCK,-1,,"CHECK_ARG(env, promise)",3,,3179,1,,void
120722,BLOCK,-1,,"CHECK_ARG(env, promise)",3,,3179,2,,void
120747,BLOCK,1,,<empty>,,,,5,,void
120749,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure)",3,,3182,1,,void
120757,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure)",3,,3182,2,,void
120805,BLOCK,1,,<empty>,,,,3,,void
120822,BLOCK,-1,,"{
  return v8impl::ConcludeDeferred(env, deferred, resolution, true);
}",69,,3195,4,,void
120838,BLOCK,-1,,"{
  return v8impl::ConcludeDeferred(env, deferred, resolution, false);
}",68,,3201,4,,void
120854,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, is_promise);

  *is_promise = v8impl::V8LocalValueFromJsValue(value)->IsPromise();

  return napi_clear_last_error(env);
}",58,,3207,4,,void
120857,BLOCK,1,,<empty>,,,,2,,void
120859,BLOCK,-1,,CHECK_ENV(env),3,,3208,1,,void
120864,BLOCK,-1,,CHECK_ENV(env),3,,3208,2,,void
120871,BLOCK,1,,<empty>,,,,3,,void
120873,BLOCK,-1,,"CHECK_ARG(env, value)",3,,3209,1,,void
120879,BLOCK,-1,,"CHECK_ARG(env, value)",3,,3209,2,,void
120888,BLOCK,1,,<empty>,,,,3,,void
120890,BLOCK,-1,,"CHECK_ARG(env, is_promise)",3,,3210,1,,void
120896,BLOCK,-1,,"CHECK_ARG(env, is_promise)",3,,3210,2,,void
120922,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::MaybeLocal<v8::Value> maybe_date = v8::Date::New(env->context(), time);
  CHECK_MAYBE_EMPTY(env, maybe_date, napi_generic_failure);

  *result = v8impl::JsValueFromV8LocalValue(maybe_date.ToLocalChecked());

  return GET_RETURN_STATUS(env);
}",61,,3219,4,,void
120925,BLOCK,1,,<empty>,,,,2,,void
120927,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3220,1,,void
120932,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3220,2,,void
120937,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3220,1,,void
120946,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3220,2,,void
120953,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3220,1,,void
120960,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3220,2,,void
120981,BLOCK,1,,<empty>,,,,3,,void
120983,BLOCK,-1,,"CHECK_ARG(env, result)",3,,3221,1,,void
120989,BLOCK,-1,,"CHECK_ARG(env, result)",3,,3221,2,,void
121020,BLOCK,1,,<empty>,,,,4,,void
121022,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe_date, napi_generic_failure)",3,,3224,1,,void
121030,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe_date, napi_generic_failure)",3,,3224,2,,void
121050,BLOCK,1,,<empty>,,,,3,,void
121067,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, is_date);

  *is_date = v8impl::V8LocalValueFromJsValue(value)->IsDate();

  return napi_clear_last_error(env);
}",52,,3233,4,,void
121070,BLOCK,1,,<empty>,,,,2,,void
121072,BLOCK,-1,,CHECK_ENV(env),3,,3234,1,,void
121077,BLOCK,-1,,CHECK_ENV(env),3,,3234,2,,void
121084,BLOCK,1,,<empty>,,,,3,,void
121086,BLOCK,-1,,"CHECK_ARG(env, value)",3,,3235,1,,void
121092,BLOCK,-1,,"CHECK_ARG(env, value)",3,,3235,2,,void
121101,BLOCK,1,,<empty>,,,,3,,void
121103,BLOCK,-1,,"CHECK_ARG(env, is_date)",3,,3236,1,,void
121109,BLOCK,-1,,"CHECK_ARG(env, is_date)",3,,3236,2,,void
121135,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  RETURN_STATUS_IF_FALSE(env, val->IsDate(), napi_date_expected);

  v8::Local<v8::Date> date = val.As<v8::Date>();
  *result = date->ValueOf();

  return GET_RETURN_STATUS(env);
}",60,,3245,4,,void
121138,BLOCK,1,,<empty>,,,,2,,void
121140,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3246,1,,void
121145,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3246,2,,void
121150,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3246,1,,void
121159,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3246,2,,void
121166,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3246,1,,void
121173,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3246,2,,void
121194,BLOCK,1,,<empty>,,,,3,,void
121196,BLOCK,-1,,"CHECK_ARG(env, value)",3,,3247,1,,void
121202,BLOCK,-1,,"CHECK_ARG(env, value)",3,,3247,2,,void
121211,BLOCK,1,,<empty>,,,,3,,void
121213,BLOCK,-1,,"CHECK_ARG(env, result)",3,,3248,1,,void
121219,BLOCK,-1,,"CHECK_ARG(env, result)",3,,3248,2,,void
121247,BLOCK,1,,<empty>,,,,4,,void
121249,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsDate(), napi_date_expected)",3,,3251,1,,void
121256,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, val->IsDate(), napi_date_expected)",3,,3251,2,,void
121286,BLOCK,1,,<empty>,,,,3,,void
121303,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, script);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> v8_script = v8impl::V8LocalValueFromJsValue(script);

  if (!v8_script->IsString()) {
    return napi_set_last_error(env, napi_string_expected);
  }

  v8::Local<v8::Context> context = env->context();

  auto maybe_script = v8::Script::Compile(context, v8_script.As<v8::String>());
  CHECK_MAYBE_EMPTY(env, maybe_script, napi_generic_failure);

  auto script_result = maybe_script.ToLocalChecked()->Run(context);
  CHECK_MAYBE_EMPTY(env, script_result, napi_generic_failure);

  *result = v8impl::JsValueFromV8LocalValue(script_result.ToLocalChecked());
  return GET_RETURN_STATUS(env);
}",60,,3261,4,,void
121306,BLOCK,1,,<empty>,,,,2,,void
121308,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3262,1,,void
121313,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3262,2,,void
121318,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3262,1,,void
121327,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3262,2,,void
121334,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3262,1,,void
121341,BLOCK,-1,,NAPI_PREAMBLE(env),3,,3262,2,,void
121362,BLOCK,1,,<empty>,,,,3,,void
121364,BLOCK,-1,,"CHECK_ARG(env, script)",3,,3263,1,,void
121370,BLOCK,-1,,"CHECK_ARG(env, script)",3,,3263,2,,void
121379,BLOCK,1,,<empty>,,,,3,,void
121381,BLOCK,-1,,"CHECK_ARG(env, result)",3,,3264,1,,void
121387,BLOCK,-1,,"CHECK_ARG(env, result)",3,,3264,2,,void
121414,BLOCK,-1,,"{
    return napi_set_last_error(env, napi_string_expected);
  }",31,,3268,2,,void
121451,BLOCK,1,,<empty>,,,,5,,void
121453,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe_script, napi_generic_failure)",3,,3275,1,,void
121461,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe_script, napi_generic_failure)",3,,3275,2,,void
121482,BLOCK,1,,<empty>,,,,5,,void
121484,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, script_result, napi_generic_failure)",3,,3278,1,,void
121492,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, script_result, napi_generic_failure)",3,,3278,2,,void
121512,BLOCK,1,,<empty>,,,,3,,void
121532,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, js_object);
  CHECK_ARG(env, finalize_cb);

  v8::Local<v8::Value> v8_value = v8impl::V8LocalValueFromJsValue(js_object);
  RETURN_STATUS_IF_FALSE(env, v8_value->IsObject(), napi_invalid_arg);

  // Create a self-deleting reference if the optional out-param result is not
  // set.
  v8impl::Ownership ownership = result == nullptr
                                    ? v8impl::Ownership::kRuntime
                                    : v8impl::Ownership::kUserland;
  v8impl::Reference* reference = v8impl::Reference::New(
      env, v8_value, 0, ownership, finalize_cb, finalize_data, finalize_hint);

  if (result != nullptr) {
    *result = reinterpret_cast<napi_ref>(reference);
  }
  return napi_clear_last_error(env);
}",61,,3289,7,,void
121535,BLOCK,1,,<empty>,,,,2,,void
121537,BLOCK,-1,,CHECK_ENV(env),3,,3292,1,,void
121542,BLOCK,-1,,CHECK_ENV(env),3,,3292,2,,void
121549,BLOCK,1,,<empty>,,,,3,,void
121551,BLOCK,-1,,"CHECK_ARG(env, js_object)",3,,3293,1,,void
121557,BLOCK,-1,,"CHECK_ARG(env, js_object)",3,,3293,2,,void
121566,BLOCK,1,,<empty>,,,,3,,void
121568,BLOCK,-1,,"CHECK_ARG(env, finalize_cb)",3,,3294,1,,void
121574,BLOCK,-1,,"CHECK_ARG(env, finalize_cb)",3,,3294,2,,void
121602,BLOCK,1,,<empty>,,,,4,,void
121604,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, v8_value->IsObject(), napi_invalid_arg)",3,,3297,1,,void
121611,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, v8_value->IsObject(), napi_invalid_arg)",3,,3297,2,,void
121654,BLOCK,-1,,"{
    *result = reinterpret_cast<napi_ref>(reference);
  }",26,,3307,2,,void
121670,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, adjusted_value);

  *adjusted_value =
      env->isolate->AdjustAmountOfExternalAllocatedMemory(change_in_bytes);

  return napi_clear_last_error(env);
}",77,,3315,4,,void
121673,BLOCK,1,,<empty>,,,,2,,void
121675,BLOCK,-1,,CHECK_ENV(env),3,,3316,1,,void
121680,BLOCK,-1,,CHECK_ENV(env),3,,3316,2,,void
121687,BLOCK,1,,<empty>,,,,3,,void
121689,BLOCK,-1,,"CHECK_ARG(env, adjusted_value)",3,,3317,1,,void
121695,BLOCK,-1,,"CHECK_ARG(env, adjusted_value)",3,,3317,2,,void
121721,BLOCK,-1,,"{
  CHECK_ENV(env);

  v8impl::RefBase* old_data = static_cast<v8impl::RefBase*>(env->instance_data);
  if (old_data != nullptr) {
    // Our contract so far has been to not finalize any old data there may be.
    // So we simply delete it.
    delete old_data;
  }

  env->instance_data = v8impl::RefBase::New(
      env, 0, v8impl::Ownership::kRuntime, finalize_cb, data, finalize_hint);

  return napi_clear_last_error(env);
}",68,,3328,5,,void
121724,BLOCK,1,,<empty>,,,,2,,void
121726,BLOCK,-1,,CHECK_ENV(env),3,,3329,1,,void
121731,BLOCK,-1,,CHECK_ENV(env),3,,3329,2,,void
121747,BLOCK,-1,,"{
    // Our contract so far has been to not finalize any old data there may be.
    // So we simply delete it.
    delete old_data;
  }",28,,3332,2,,void
121778,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, data);

  v8impl::RefBase* idata = static_cast<v8impl::RefBase*>(env->instance_data);

  *data = (idata == nullptr ? nullptr : idata->Data());

  return napi_clear_last_error(env);
}",74,,3344,3,,void
121781,BLOCK,1,,<empty>,,,,2,,void
121783,BLOCK,-1,,CHECK_ENV(env),3,,3345,1,,void
121788,BLOCK,-1,,CHECK_ENV(env),3,,3345,2,,void
121795,BLOCK,1,,<empty>,,,,3,,void
121797,BLOCK,-1,,"CHECK_ARG(env, data)",3,,3346,1,,void
121803,BLOCK,-1,,"CHECK_ARG(env, data)",3,,3346,2,,void
121837,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, arraybuffer);

  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(arraybuffer);
  RETURN_STATUS_IF_FALSE(
      env, value->IsArrayBuffer(), napi_arraybuffer_expected);

  v8::Local<v8::ArrayBuffer> it = value.As<v8::ArrayBuffer>();
  RETURN_STATUS_IF_FALSE(
      env, it->IsDetachable(), napi_detachable_arraybuffer_expected);

  it->Detach(v8::Local<v8::Value>()).Check();

  return napi_clear_last_error(env);
}",72,,3356,3,,void
121840,BLOCK,1,,<empty>,,,,2,,void
121842,BLOCK,-1,,CHECK_ENV(env),3,,3357,1,,void
121847,BLOCK,-1,,CHECK_ENV(env),3,,3357,2,,void
121854,BLOCK,1,,<empty>,,,,3,,void
121856,BLOCK,-1,,"CHECK_ARG(env, arraybuffer)",3,,3358,1,,void
121862,BLOCK,-1,,"CHECK_ARG(env, arraybuffer)",3,,3358,2,,void
121890,BLOCK,1,,<empty>,,,,4,,void
121892,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(
      env, value->IsArrayBuffer(), napi_arraybuffer_expected)",3,,3361,1,,void
121899,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(
      env, value->IsArrayBuffer(), napi_arraybuffer_expected)",3,,3361,2,,void
121926,BLOCK,1,,<empty>,,,,4,,void
121928,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(
      env, it->IsDetachable(), napi_detachable_arraybuffer_expected)",3,,3365,1,,void
121935,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(
      env, it->IsDetachable(), napi_detachable_arraybuffer_expected)",3,,3365,2,,void
121961,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, arraybuffer);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(arraybuffer);

  *result =
      value->IsArrayBuffer() && value.As<v8::ArrayBuffer>()->WasDetached();

  return napi_clear_last_error(env);
}",67,,3375,4,,void
121964,BLOCK,1,,<empty>,,,,2,,void
121966,BLOCK,-1,,CHECK_ENV(env),3,,3376,1,,void
121971,BLOCK,-1,,CHECK_ENV(env),3,,3376,2,,void
121978,BLOCK,1,,<empty>,,,,3,,void
121980,BLOCK,-1,,"CHECK_ARG(env, arraybuffer)",3,,3377,1,,void
121986,BLOCK,-1,,"CHECK_ARG(env, arraybuffer)",3,,3377,2,,void
121995,BLOCK,1,,<empty>,,,,3,,void
121997,BLOCK,-1,,"CHECK_ARG(env, result)",3,,3378,1,,void
122003,BLOCK,-1,,"CHECK_ARG(env, result)",3,,3378,2,,void
122047,BLOCK,-1,,"{ cb(env, data, hint); }",38,,105,2,,void
122065,BLOCK,-1,,<empty>,1,,1,1,,ANY
122068,BLOCK,-1,,<empty>,,,,2,,<empty>
122074,BLOCK,-1,,<empty>,16,,13,1,,void
122078,BLOCK,-1,,<empty>,25,,14,1,,void
122082,BLOCK,-1,,<empty>,27,,15,1,,void
122088,BLOCK,-1,,"{
    prev_ = list;
    next_ = list->next_;
    if (next_ != nullptr) {
      next_->prev_ = this;
    }
    list->next_ = this;
  }",35,,19,2,,void
122101,BLOCK,-1,,"{
      next_->prev_ = this;
    }",27,,22,2,,void
122115,BLOCK,-1,,"{
    if (prev_ != nullptr) {
      prev_->next_ = next_;
    }
    if (next_ != nullptr) {
      next_->prev_ = prev_;
    }
    prev_ = nullptr;
    next_ = nullptr;
  }",24,,28,1,,void
122120,BLOCK,-1,,"{
      prev_->next_ = next_;
    }",27,,29,2,,void
122130,BLOCK,-1,,"{
      next_->prev_ = prev_;
    }",27,,32,2,,void
122146,BLOCK,-1,,"{
    while (list->next_ != nullptr) {
      list->next_->Finalize();
    }
  }",42,,39,2,,void
122153,BLOCK,-1,,"{
      list->next_->Finalize();
    }",36,,40,2,,void
122165,BLOCK,-1,,<empty>,,,,1,,<empty>
122178,BLOCK,-1,,"{
    napi_clear_last_error(this);
  }",48,,58,3,,void
122184,BLOCK,-1,,"{
    return v8impl::PersistentToLocal::Strong(context_persistent);
  }",49,,62,1,,void
122196,BLOCK,-1,,{ refs++; },21,,66,1,,void
122202,BLOCK,-1,,"{
    if (--refs == 0) DeleteMe();
  }",23,,67,1,,void
122208,BLOCK,-1,,<empty>,22,,68,2,,void
122213,BLOCK,-1,,{ return true; },41,,71,1,,void
122221,BLOCK,-1,,"{
    if (env->terminatedOrTerminating()) {
      return;
    }
    env->isolate->ThrowException(value);
  }",76,,73,3,,void
122227,BLOCK,-1,,"{
      return;
    }",41,,74,2,,void
122239,BLOCK,-1,,"{
    return this->isolate->IsExecutionTerminating() || !can_call_into_js();
  }",41,,81,1,,void
122255,BLOCK,-1,,"{
    int open_handle_scopes_before = open_handle_scopes;
    int open_callback_scopes_before = open_callback_scopes;
    napi_clear_last_error(this);
    call(this);
    CHECK_EQ(open_handle_scopes, open_handle_scopes_before);
    CHECK_EQ(open_callback_scopes, open_callback_scopes_before);
    if (!last_exception.IsEmpty()) {
      handle_exception(this, last_exception.Get(this->isolate));
      last_exception.Reset();
    }
  }",76,,89,3,,void
122280,BLOCK,-1,,"{
      handle_exception(this, last_exception.Get(this->isolate));
      last_exception.Reset();
    }",36,,96,2,,void
122298,BLOCK,-1,,"{
    v8::HandleScope handle_scope(isolate);
    CallIntoModule([&](napi_env env) { cb(env, data, hint); });
  }",72,,103,4,,void
122308,BLOCK,-1,,"{
    pending_finalizers.emplace(finalizer);
  }",64,,112,2,,void
122318,BLOCK,-1,,"{
    pending_finalizers.erase(finalizer);
  }",64,,118,2,,void
122327,BLOCK,-1,,"{
    // First we must finalize those references that have `napi_finalizer`
    // callbacks. The reason is that addons might store other references which
    // they delete during their `napi_finalizer` callbacks. If we deleted such
    // references here first, they would be doubly deleted when the
    // `napi_finalizer` deleted them subsequently.
    v8impl::RefTracker::FinalizeAll(&finalizing_reflist);
    v8impl::RefTracker::FinalizeAll(&reflist);
    delete this;
  }",27,,122,1,,void
122361,BLOCK,-1,,<empty>,,,,1,,<empty>
122365,BLOCK,-1,,<empty>,,,,1,,<empty>
122381,BLOCK,1,,<empty>,,,,1,,void
122387,BLOCK,-1,,"{
  env->last_error.error_code = napi_ok;
  env->last_error.engine_error_code = 0;
  env->last_error.engine_reserved = nullptr;
  env->last_error.error_message = nullptr;
  return napi_ok;
}",56,,158,2,,void
122425,BLOCK,-1,,"{
  env->last_error.error_code = error_code;
  env->last_error.engine_error_code = engine_error_code;
  env->last_error.engine_reserved = engine_reserved;
  return error_code;
}",73,,169,5,,void
122461,BLOCK,-1,,"{
  return reinterpret_cast<napi_value>(*local);
}",71,,297,2,,void
122471,BLOCK,-1,,"{
  v8::Local<v8::Value> local;
  memcpy(static_cast<void*>(&local), &v, sizeof(v));
  return local;
}",67,,301,2,,void
122500,BLOCK,-1,,<empty>,39,,317,5,,void
122504,BLOCK,-1,,<empty>,,,,1,,<empty>
122512,BLOCK,-1,,"{
    return new Finalizer(env, finalize_callback, finalize_data, finalize_hint);
  }",56,,325,5,,void
122523,BLOCK,-1,,{ return finalize_callback_; },28,,329,1,,void
122529,BLOCK,-1,,{ return finalize_data_; },16,,330,1,,void
122535,BLOCK,-1,,{ return finalize_hint_; },16,,331,1,,void
122541,BLOCK,-1,,<empty>,,,,1,,<empty>
122551,BLOCK,-1,,<empty>,75,,344,2,,void
122555,BLOCK,-1,,"{
    if (HasCaught()) {
      _env->last_exception.Reset(_env->isolate, Exception());
    }
  }",15,,346,1,,void
122558,BLOCK,-1,,"{
      _env->last_exception.Reset(_env->isolate, Exception());
    }",22,,347,2,,void
122583,BLOCK,-1,,<empty>,,,,7,,<empty>
122593,BLOCK,-1,,<empty>,,,,7,,<empty>
122597,BLOCK,-1,,<empty>,,,,1,,<empty>
122601,BLOCK,-1,,<empty>,,,,1,,<empty>
122605,BLOCK,-1,,<empty>,,,,1,,<empty>
122609,BLOCK,-1,,<empty>,,,,1,,<empty>
122613,BLOCK,-1,,<empty>,,,,1,,<empty>
122617,BLOCK,-1,,{ return ownership_; },25,,390,1,,void
122623,BLOCK,-1,,<empty>,,,,1,,<empty>
122633,BLOCK,-1,,<empty>,,,,4,,<empty>
122644,BLOCK,-1,,<empty>,,,,8,,<empty>
122648,BLOCK,-1,,<empty>,,,,1,,<empty>
122652,BLOCK,-1,,<empty>,,,,1,,<empty>
122656,BLOCK,-1,,<empty>,,,,1,,<empty>
122660,BLOCK,-1,,<empty>,,,,1,,<empty>
122664,BLOCK,-1,,<empty>,,,,1,,<empty>
122669,BLOCK,-1,,<empty>,,,,2,,<empty>
122673,BLOCK,-1,,<empty>,,,,1,,<empty>
122690,BLOCK,-1,,<empty>,1,,1,1,,ANY
122712,BLOCK,-1,,<empty>,1,,1,1,,ANY
122717,BLOCK,-1,,"{
  MakeWeak();
  StreamBase::AttachToObject(obj);
}",23,,28,3,,void
122727,BLOCK,-1,,"{
  return static_cast<AsyncWrap*>(this);
}",37,,34,1,,void
122735,BLOCK,-1,,"{
  return true;
}",26,,39,1,,void
122741,BLOCK,-1,,"{
  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());
  TryCatchScope try_catch(env());
  Local<Value> value;
  if (!MakeCallback(env()->isclosing_string(), 0, nullptr).ToLocal(&value)) {
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
    return true;
  }
  return value->IsTrue();
}",28,,44,1,,void
122776,BLOCK,-1,,"{
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
    return true;
  }",77,,49,2,,void
122788,BLOCK,-1,,<empty>,7,,51,2,,void
122808,BLOCK,-1,,"{
  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());
  TryCatchScope try_catch(env());
  Local<Value> value;
  int value_int = UV_EPROTO;
  if (!MakeCallback(env()->onreadstart_string(), 0, nullptr).ToLocal(&value) ||
      !value->Int32Value(env()->context()).To(&value_int)) {
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }
  return value_int;
}",27,,58,1,,void
122862,BLOCK,-1,,"{
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }",60,,65,2,,void
122874,BLOCK,-1,,<empty>,7,,67,2,,void
122889,BLOCK,-1,,"{
  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());
  TryCatchScope try_catch(env());
  Local<Value> value;
  int value_int = UV_EPROTO;
  if (!MakeCallback(env()->onreadstop_string(), 0, nullptr).ToLocal(&value) ||
      !value->Int32Value(env()->context()).To(&value_int)) {
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }
  return value_int;
}",26,,73,1,,void
122943,BLOCK,-1,,"{
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }",60,,80,2,,void
122955,BLOCK,-1,,<empty>,7,,82,2,,void
122971,BLOCK,-1,,"{
  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());

  Local<Value> argv[] = {
    req_wrap->object()
  };

  TryCatchScope try_catch(env());
  Local<Value> value;
  int value_int = UV_EPROTO;
  if (!MakeCallback(env()->onshutdown_string(),
                    arraysize(argv),
                    argv).ToLocal(&value) ||
      !value->Int32Value(env()->context()).To(&value_int)) {
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }
  return value_int;
}",50,,88,2,,void
123034,BLOCK,-1,,"{
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }",60,,102,2,,void
123046,BLOCK,-1,,<empty>,7,,104,2,,void
123065,BLOCK,-1,,"{
  CHECK_NULL(send_handle);

  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());

  MaybeStackBuffer<Local<Value>, 16> bufs_arr(count);
  for (size_t i = 0; i < count; i++) {
    bufs_arr[i] =
        Buffer::Copy(env(), bufs[i].base, bufs[i].len).ToLocalChecked();
  }

  Local<Value> argv[] = {
    w->object(),
    Array::New(env()->isolate(), bufs_arr.out(), count)
  };

  TryCatchScope try_catch(env());
  Local<Value> value;
  int value_int = UV_EPROTO;
  if (!MakeCallback(env()->onwrite_string(),
                    arraysize(argv),
                    argv).ToLocal(&value) ||
      !value->Int32Value(env()->context()).To(&value_int)) {
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }
  return value_int;
}",49,,113,5,,void
123084,BLOCK,-1,,<empty>,3,,120,1,,void
123094,BLOCK,4,,"{
    bufs_arr[i] =
        Buffer::Copy(env(), bufs[i].base, bufs[i].len).ToLocalChecked();
  }",38,,120,4,,void
123180,BLOCK,-1,,"{
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }",60,,136,2,,void
123192,BLOCK,-1,,<empty>,7,,138,2,,void
123208,BLOCK,-1,,"{
  // This constructor should not be exposed to public javascript.
  // Therefore we assert that we are not trying to call this as a
  // normal function.
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);
  new JSStream(env, args.This());
}",61,,144,2,,void
123233,BLOCK,-1,,"{
  CHECK(args[0]->IsObject());
  Wrap* w = static_cast<Wrap*>(StreamReq::FromObject(args[0].As<Object>()));

  CHECK(args[1]->IsInt32());
  w->Done(args[1].As<Int32>()->Value());
}",64,,155,2,,void
123280,BLOCK,-1,,"{
  JSStream* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  ArrayBufferViewContents<char> buffer(args[0]);
  const char* data = buffer.data();
  int len = buffer.length();

  // Repeatedly ask the stream's owner for memory, copy the data that we
  // just read from JS into those buffers and emit them as reads.
  while (len != 0) {
    uv_buf_t buf = wrap->EmitAlloc(len);
    ssize_t avail = len;
    if (static_cast<ssize_t>(buf.len) < avail)
      avail = buf.len;

    memcpy(buf.base, data, avail);
    data += avail;
    len -= static_cast<int>(avail);
    wrap->EmitRead(avail, buf);
  }
}",68,,164,2,,void
123312,BLOCK,-1,,"{
    uv_buf_t buf = wrap->EmitAlloc(len);
    ssize_t avail = len;
    if (static_cast<ssize_t>(buf.len) < avail)
      avail = buf.len;

    memcpy(buf.base, data, avail);
    data += avail;
    len -= static_cast<int>(avail);
    wrap->EmitRead(avail, buf);
  }",20,,174,2,,void
123333,BLOCK,-1,,<empty>,7,,178,2,,void
123363,BLOCK,-1,,"{
  JSStream* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  wrap->EmitRead(UV_EOF);
}",65,,188,2,,void
123384,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);
  t->InstanceTemplate()
    ->SetInternalFieldCount(StreamBase::kInternalFieldCount);
  t->Inherit(AsyncWrap::GetConstructorTemplate(env));

  SetProtoMethod(isolate, t, ""finishWrite"", Finish<WriteWrap>);
  SetProtoMethod(isolate, t, ""finishShutdown"", Finish<ShutdownWrap>);
  SetProtoMethod(isolate, t, ""readBuffer"", ReadBuffer);
  SetProtoMethod(isolate, t, ""emitEOF"", EmitEOF);

  StreamBase::AddMethods(env, t);
  SetConstructorFunction(context, target, ""JSStream"", t);
}",39,,199,5,,void
123470,BLOCK,-1,,<empty>,1,,1,1,,ANY
123485,BLOCK,-1,,<empty>,1,,1,1,,ANY
123491,BLOCK,-1,,<empty>,,,,3,,<empty>
123495,BLOCK,-1,,<empty>,,,,1,,<empty>
123499,BLOCK,-1,,<empty>,,,,1,,<empty>
123506,BLOCK,-1,,<empty>,,,,4,,<empty>
123510,BLOCK,-1,,<empty>,,,,1,,<empty>
123514,BLOCK,-1,,<empty>,,,,1,,<empty>
123518,BLOCK,-1,,{ return this; },38,,38,1,,void
123525,BLOCK,-1,,<empty>,,,,2,,<empty>
123530,BLOCK,-1,,<empty>,,,,2,,<empty>
123535,BLOCK,-1,,<empty>,,,,2,,<empty>
123540,BLOCK,-1,,<empty>,,,,2,,<empty>
123548,BLOCK,-1,,<empty>,,,,5,,<empty>
123555,BLOCK,-1,,"{
  MakeWeak();

  obj->SetAlignedPointerInInternalField(
      kUDPWrapBaseField, static_cast<UDPWrapBase*>(this));
}",45,,55,3,,void
123568,BLOCK,-1,,"{
  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());
  TryCatchScope try_catch(env());
  Local<Value> value;
  int32_t value_int = JS_EXCEPTION_PENDING;
  if (!MakeCallback(env()->onreadstart_string(), 0, nullptr).ToLocal(&value) ||
      !value->Int32Value(env()->context()).To(&value_int)) {
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }
  return value_int;
}",28,,62,1,,void
123593,BLOCK,1,,<empty>,,,,1,,void
123624,BLOCK,-1,,"{
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }",60,,69,2,,void
123636,BLOCK,-1,,<empty>,7,,71,2,,void
123651,BLOCK,-1,,"{
  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());
  TryCatchScope try_catch(env());
  Local<Value> value;
  int32_t value_int = JS_EXCEPTION_PENDING;
  if (!MakeCallback(env()->onreadstop_string(), 0, nullptr).ToLocal(&value) ||
      !value->Int32Value(env()->context()).To(&value_int)) {
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }
  return value_int;
}",27,,76,1,,void
123676,BLOCK,1,,<empty>,,,,1,,void
123707,BLOCK,-1,,"{
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }",60,,83,2,,void
123719,BLOCK,-1,,<empty>,7,,85,2,,void
123737,BLOCK,-1,,"{
  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());
  TryCatchScope try_catch(env());
  Local<Value> value;
  int64_t value_int = JS_EXCEPTION_PENDING;
  size_t total_len = 0;

  MaybeStackBuffer<Local<Value>, 16> buffers(nbufs);
  for (size_t i = 0; i < nbufs; i++) {
    buffers[i] = Buffer::Copy(env(), bufs[i].base, bufs[i].len)
        .ToLocalChecked();
    total_len += bufs[i].len;
  }

  Local<Object> address;
  if (!AddressToJS(env(), addr).ToLocal(&address)) return value_int;

  Local<Value> args[] = {
    listener()->CreateSendWrap(total_len)->object(),
    Array::New(env()->isolate(), buffers.out(), nbufs),
    address,
  };

  if (!MakeCallback(env()->onwrite_string(), arraysize(args), args)
          .ToLocal(&value) ||
      !value->IntegerValue(env()->context()).To(&value_int)) {
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }
  return value_int;
}",47,,92,4,,void
123762,BLOCK,1,,<empty>,,,,1,,void
123772,BLOCK,-1,,<empty>,3,,101,1,,void
123782,BLOCK,4,,"{
    buffers[i] = Buffer::Copy(env(), bufs[i].base, bufs[i].len)
        .ToLocalChecked();
    total_len += bufs[i].len;
  }",38,,101,4,,void
123827,BLOCK,-1,,<empty>,52,,108,2,,void
123886,BLOCK,-1,,"{
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }",62,,118,2,,void
123898,BLOCK,-1,,<empty>,7,,120,2,,void
123913,BLOCK,-1,,"{
  SocketAddress ret;
  CHECK(SocketAddress::New(AF_INET, ""127.0.0.1"", 1337, &ret));
  return ret;
}",40,,125,1,,void
123930,BLOCK,-1,,"{
  SocketAddress ret;
  CHECK(SocketAddress::New(AF_INET, ""127.0.0.1"", 1337, &ret));
  return ret;
}",40,,131,1,,void
123948,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args.IsConstructCall());
  new JSUDPWrap(env, args.Holder());
}",62,,137,2,,void
123973,BLOCK,-1,,"{
  JSUDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  Environment* env = wrap->env();

  ArrayBufferViewContents<char> buffer(args[0]);
  const char* data = buffer.data();
  int len = buffer.length();

  CHECK(args[1]->IsInt32());   // family
  CHECK(args[2]->IsString());  // address
  CHECK(args[3]->IsInt32());   // port
  CHECK(args[4]->IsInt32());   // flags
  int family = args[1].As<Int32>()->Value() == 4 ? AF_INET : AF_INET6;
  Utf8Value address(env->isolate(), args[2]);
  int port = args[3].As<Int32>()->Value();
  int flags = args[3].As<Int32>()->Value();

  sockaddr_storage addr;
  CHECK_EQ(sockaddr_for_family(family, *address, port, &addr), 0);

  // Repeatedly ask the stream's owner for memory, copy the data that we
  // just read from JS into those buffers and emit them as reads.
  while (len != 0) {
    uv_buf_t buf = wrap->listener()->OnAlloc(len);
    ssize_t avail = std::min<size_t>(buf.len, len);
    memcpy(buf.base, data, avail);
    data += avail;
...",71,,143,2,,void
124100,BLOCK,-1,,"{
    uv_buf_t buf = wrap->listener()->OnAlloc(len);
    ssize_t avail = std::min<size_t>(buf.len, len);
    memcpy(buf.base, data, avail);
    data += avail;
    len -= static_cast<int>(avail);
    wrap->listener()->OnRecv(
        avail, buf, reinterpret_cast<sockaddr*>(&addr), flags);
  }",20,,166,2,,void
124159,BLOCK,-1,,"{
  JSUDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsInt32());
  ReqWrap<uv_udp_send_t>* req_wrap;
  ASSIGN_OR_RETURN_UNWRAP(&req_wrap, args[0].As<Object>());
  int status = args[1].As<Int32>()->Value();

  wrap->listener()->OnSendDone(req_wrap, status);
}",69,,177,2,,void
124222,BLOCK,-1,,"{
  JSUDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  wrap->listener()->OnAfterBind();
}",70,,190,2,,void
124245,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);
  t->InstanceTemplate()
    ->SetInternalFieldCount(UDPWrapBase::kUDPWrapBaseField + 1);
  t->Inherit(AsyncWrap::GetConstructorTemplate(env));

  UDPWrapBase::AddMethods(env, t);
  SetProtoMethod(isolate, t, ""emitReceived"", EmitReceived);
  SetProtoMethod(isolate, t, ""onSendDone"", OnSendDone);
  SetProtoMethod(isolate, t, ""onAfterBind"", OnAfterBind);

  SetConstructorFunction(context, target, ""JSUDPWrap"", t);
}",40,,200,5,,void
124332,BLOCK,-1,,<empty>,1,,1,1,,ANY
124336,BLOCK,-1,,"{
  Isolate* isolate = Isolate::Allocate();
  CHECK_NOT_NULL(isolate);
  per_process::v8_platform.Platform()->RegisterIsolate(isolate,
                                                       uv_default_loop());
  Isolate::CreateParams params;
  params.array_buffer_allocator = allocator;
  Isolate::Initialize(isolate, params);
  return isolate;
}",67,,15,2,,void
124375,BLOCK,-1,,"{
  per_process::v8_platform.Platform()->UnregisterIsolate(isolate);
  isolate->Dispose();
}",48,,26,2,,void
124393,BLOCK,-1,,<empty>,52,,36,1,,void
124398,BLOCK,-1,,"{
  DCHECK(!parsed_);

  Isolate* isolate = isolate_.get();
  Local<Context> context = context_.Get(isolate);

  // It's not a real script, so don't print the source line.
  errors::PrinterTryCatch bootstrapCatch(
      isolate, errors::PrinterTryCatch::kDontPrintSourceLine);
  Local<Value> json_string_value;
  Local<Value> result_value;
  if (!ToV8Value(context, content).ToLocal(&json_string_value) ||
      !json_string_value->IsString() ||
      !v8::JSON::Parse(context, json_string_value.As<String>())
           .ToLocal(&result_value) ||
      !result_value->IsObject()) {
    return false;
  }
  content_.Reset(isolate, result_value.As<Object>());
  parsed_ = true;
  return true;
}",52,,38,2,,void
124478,BLOCK,-1,,"{
    return false;
  }",34,,53,2,,void
124499,BLOCK,-1,,"{
  Isolate* isolate = isolate_.get();
  Local<Context> context = context_.Get(isolate);
  Local<Object> content_object = content_.Get(isolate);
  Local<Value> value;
  // It's not a real script, so don't print the source line.
  errors::PrinterTryCatch bootstrapCatch(
      isolate, errors::PrinterTryCatch::kDontPrintSourceLine);
  Local<Value> field_local;
  if (!ToV8Value(context, field, isolate).ToLocal(&field_local)) {
    return {};
  }
  if (!content_object->Get(context, field_local).ToLocal(&value) ||
      !value->IsString()) {
    return {};
  }
  Utf8Value utf8_value(isolate, value);
  return utf8_value.ToString();
}",29,,62,2,,void
124558,BLOCK,-1,,"{
    return {};
  }",66,,71,2,,void
124579,BLOCK,-1,,"{
    return {};
  }",27,,75,2,,void
124594,BLOCK,-1,,"{
  Isolate* isolate = isolate_.get();
  Local<Context> context = context_.Get(isolate);
  Local<Object> content_object = content_.Get(isolate);
  Local<Value> value;
  bool has_field;
  // It's not a real script, so don't print the source line.
  errors::PrinterTryCatch bootstrapCatch(
      isolate, errors::PrinterTryCatch::kDontPrintSourceLine);
  Local<Value> field_local;
  if (!ToV8Value(context, field, isolate).ToLocal(&field_local)) {
    return {};
  }
  if (!content_object->Has(context, field_local).To(&has_field)) {
    return {};
  }
  if (!has_field) {
    return false;
  }
  if (!content_object->Get(context, field_local).ToLocal(&value) ||
      !value->IsBoolean()) {
    return {};
  }
  return value->BooleanValue(isolate);
}",78,,82,2,,void
124654,BLOCK,-1,,"{
    return {};
  }",66,,92,2,,void
124669,BLOCK,-1,,"{
    return {};
  }",66,,95,2,,void
124674,BLOCK,-1,,"{
    return false;
  }",19,,98,2,,void
124696,BLOCK,-1,,"{
    return {};
  }",28,,102,2,,void
124720,BLOCK,-1,,<empty>,1,,1,1,,ANY
124727,BLOCK,-1,,<empty>,1,,1,1,,ANY
124731,BLOCK,-1,,"{
  // 'static constexpr' is slightly better than static const
  // since the initialization occurs at compile time.
  // See https://lemire.me/blog/I3Cah
  static constexpr std::string_view control_symbols[0x20] = {
      ""\\u0000"", ""\\u0001"", ""\\u0002"", ""\\u0003"", ""\\u0004"", ""\\u0005"",
      ""\\u0006"", ""\\u0007"", ""\\b"",     ""\\t"",     ""\\n"",     ""\\u000b"",
      ""\\f"",     ""\\r"",     ""\\u000e"", ""\\u000f"", ""\\u0010"", ""\\u0011"",
      ""\\u0012"", ""\\u0013"", ""\\u0014"", ""\\u0015"", ""\\u0016"", ""\\u0017"",
      ""\\u0018"", ""\\u0019"", ""\\u001a"", ""\\u001b"", ""\\u001c"", ""\\u001d"",
      ""\\u001e"", ""\\u001f""};

  std::string ret;
  size_t last_pos = 0;
  size_t pos = 0;
  for (; pos < str.size(); ++pos) {
    std::string replace;
    char ch = str[pos];
    if (ch == '\\') {
      replace = ""\\\\"";
    } else if (ch == '\""') {
      replace = ""\\\"""";
    } else {
      size_t num = static_cast<size_t>(ch);
      if (num < 0x20) replace = control_symbols[num];
    }
    if (!replace.empty()) {
 ...",51,,5,2,,void
124778,BLOCK,-1,,<empty>,3,,20,1,,void
124787,BLOCK,4,,"{
    std::string replace;
    char ch = str[pos];
    if (ch == '\\') {
      replace = ""\\\\"";
    } else if (ch == '\""') {
      replace = ""\\\"""";
    } else {
      size_t num = static_cast<size_t>(ch);
      if (num < 0x20) replace = control_symbols[num];
    }
    if (!replace.empty()) {
      if (pos > last_pos) {
        ret += str.substr(last_pos, pos - last_pos);
      }
      last_pos = pos + 1;
      ret += replace;
    }
  }",35,,20,4,,void
124799,BLOCK,-1,,"{
      replace = ""\\\\"";
    }",21,,23,2,,void
124804,BLOCK,-1,,<empty>,12,,25,1,,void
124809,BLOCK,-1,,"{
      replace = ""\\\"""";
    }",28,,25,2,,void
124814,BLOCK,-1,,"{
      size_t num = static_cast<size_t>(ch);
      if (num < 0x20) replace = control_symbols[num];
    }",12,,27,1,,void
124825,BLOCK,-1,,<empty>,23,,29,2,,void
124837,BLOCK,-1,,"{
      if (pos > last_pos) {
        ret += str.substr(last_pos, pos - last_pos);
      }
      last_pos = pos + 1;
      ret += replace;
    }",27,,31,2,,void
124842,BLOCK,-1,,"{
        ret += str.substr(last_pos, pos - last_pos);
      }",27,,32,2,,void
124868,BLOCK,-1,,"{
    ret += str.substr(last_pos, pos - last_pos);
  }",30,,40,2,,void
124886,BLOCK,-1,,"{
  if (indent_depth <= 0) return str;
  const std::string indent(indent_depth, ' ');
  std::string out;
  std::string::size_type pos = 0;
  for (;;) {
    std::string::size_type prev_pos = pos;
    pos = str.find('\n', pos);

    out.append(indent);

    if (pos == std::string::npos) {
      out.append(str, prev_pos, std::string::npos);
      break;
    } else {
      pos++;
      out.append(str, prev_pos, pos - prev_pos);
    }
  }

  return out;
}",64,,46,3,,void
124891,BLOCK,-1,,<empty>,26,,47,2,,void
124904,BLOCK,-1,,<empty>,3,,51,1,,void
124905,BLOCK,4,,"{
    std::string::size_type prev_pos = pos;
    pos = str.find('\n', pos);

    out.append(indent);

    if (pos == std::string::npos) {
      out.append(str, prev_pos, std::string::npos);
      break;
    } else {
      pos++;
      out.append(str, prev_pos, pos - prev_pos);
    }
  }",12,,51,4,,void
124931,BLOCK,-1,,"{
      out.append(str, prev_pos, std::string::npos);
      break;
    }",35,,57,2,,void
124945,BLOCK,-1,,"{
      pos++;
      out.append(str, prev_pos, pos - prev_pos);
    }",12,,60,1,,void
124975,BLOCK,-1,,<empty>,1,,1,1,,ANY
125012,BLOCK,-1,,<empty>,1,,1,1,,ANY
125015,BLOCK,-1,,"{
#if defined(NODE_ENABLE_LARGE_CODE_PAGES) && NODE_ENABLE_LARGE_CODE_PAGES
  bool have_thp = false;
#if defined(__linux__)
  have_thp = IsTransparentHugePagesEnabled();
#elif defined(__FreeBSD__)
  have_thp = IsSuperPagesEnabled();
#elif defined(__APPLE__)
  // pse-36 flag is present in recent mac x64 products.
  have_thp = true;
#endif
  if (!have_thp)
    return EACCES;

  struct text_region r = FindNodeTextRegion();
  if (r.found_text_region == false)
    return ENOENT;

  return MoveTextRegionToLargePages(r);
#else
  return ENOTSUP;
#endif
}",33,,417,1,,void
125022,BLOCK,-1,,"{
  switch (status) {
    case ENOTSUP:
      return ""Mapping to large pages is not supported."";

    case EACCES:
      return ""Large pages are not enabled."";

    case ENOENT:
      return ""failed to find text region"";

    case -1:
      return ""Mapping code to large pages failed. Reverting to default page ""
          ""size."";

    case 0:
      return ""OK"";

    default:
      return ""Unknown error"";
  }
}",41,,441,2,,void
125025,BLOCK,-1,,"{
    case ENOTSUP:
      return ""Mapping to large pages is not supported."";

    case EACCES:
      return ""Large pages are not enabled."";

    case ENOENT:
      return ""failed to find text region"";

    case -1:
      return ""Mapping code to large pages failed. Reverting to default page ""
          ""size."";

    case 0:
      return ""OK"";

    default:
      return ""Unknown error"";
  }",19,,442,2,,void
125056,BLOCK,-1,,<empty>,1,,1,1,,ANY
125065,BLOCK,-1,,<empty>,1,,1,1,,ANY
125084,BLOCK,-1,,<empty>,1,,1,1,,ANY
125087,BLOCK,-1,,"{
    MaybeLocal<Value> result = module->Evaluate(context);
    if (!result.IsEmpty() && microtask_queue)
      microtask_queue->PerformCheckpoint(isolate);
    return result;
  }",20,,384,1,,void
125107,BLOCK,-1,,<empty>,7,,387,2,,void
125146,BLOCK,-1,,<empty>,1,,1,1,,ANY
125154,BLOCK,-1,,"{
  env->id_to_module_map.emplace(id_, this);

  Local<Value> undefined = Undefined(env->isolate());
  object->SetInternalField(kURLSlot, url);
  object->SetInternalField(kSyntheticEvaluationStepsSlot, undefined);
  object->SetInternalField(kContextObjectSlot, undefined);
}",36,,58,5,,void
125195,BLOCK,-1,,"{
  HandleScope scope(env()->isolate());
  Local<Module> module = module_.Get(env()->isolate());
  env()->id_to_module_map.erase(id_);
  auto range = env()->hash_to_module_map.equal_range(module->GetIdentityHash());
  for (auto it = range.first; it != range.second; ++it) {
    if (it->second == this) {
      env()->hash_to_module_map.erase(it);
      break;
    }
  }
}",27,,67,1,,void
125237,BLOCK,-1,,<empty>,3,,72,1,,void
125251,BLOCK,4,,"{
    if (it->second == this) {
      env()->hash_to_module_map.erase(it);
      break;
    }
  }",57,,72,4,,void
125258,BLOCK,-1,,"{
      env()->hash_to_module_map.erase(it);
      break;
    }",29,,73,2,,void
125270,BLOCK,-1,,"{
  Local<Value> obj = object()->GetInternalField(kContextObjectSlot);
  if (obj.IsEmpty()) return {};
  return obj.As<Object>()->GetCreationContext().ToLocalChecked();
}",44,,80,1,,void
125287,BLOCK,-1,,<empty>,22,,82,2,,void
125305,BLOCK,-1,,"{
  auto range = env->hash_to_module_map.equal_range(module->GetIdentityHash());
  for (auto it = range.first; it != range.second; ++it) {
    if (it->second->module_ == module) {
      return it->second;
    }
  }
  return nullptr;
}",61,,87,3,,void
125320,BLOCK,-1,,<empty>,3,,89,1,,void
125334,BLOCK,4,,"{
    if (it->second->module_ == module) {
      return it->second;
    }
  }",57,,89,4,,void
125343,BLOCK,-1,,"{
      return it->second;
    }",40,,90,2,,void
125355,BLOCK,-1,,"{
  auto module_wrap_it = env->id_to_module_map.find(id);
  if (module_wrap_it == env->id_to_module_map.end()) {
    return nullptr;
  }
  return module_wrap_it->second;
}",66,,97,3,,void
125375,BLOCK,-1,,"{
    return nullptr;
  }",54,,99,2,,void
125386,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  CHECK_GE(args.Length(), 3);

  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  Local<Object> that = args.This();

  CHECK(args[0]->IsString());
  Local<String> url = args[0].As<String>();

  Local<Context> context;
  ContextifyContext* contextify_context = nullptr;
  if (args[1]->IsUndefined()) {
    context = that->GetCreationContext().ToLocalChecked();
  } else {
    CHECK(args[1]->IsObject());
    contextify_context = ContextifyContext::ContextFromContextifiedSandbox(
        env, args[1].As<Object>());
    CHECK_NOT_NULL(contextify_context);
    context = contextify_context->context();
  }

  int line_offset = 0;
  int column_offset = 0;

  bool synthetic = args[2]->IsArray();
  if (synthetic) {
    // new ModuleWrap(url, context, exportNames, syntheticExecutionFunction)
    CHECK(args[3]->IsFunction());
  } else {
    // new ModuleWrap(url, context, source, lineOffset, columOffset, cachedData)
    CH...",63,,107,2,,void
125458,BLOCK,-1,,"{
    context = that->GetCreationContext().ToLocalChecked();
  }",31,,121,2,,void
125469,BLOCK,-1,,"{
    CHECK(args[1]->IsObject());
    contextify_context = ContextifyContext::ContextFromContextifiedSandbox(
        env, args[1].As<Object>());
    CHECK_NOT_NULL(contextify_context);
    context = contextify_context->context();
  }",10,,123,1,,void
125517,BLOCK,-1,,"{
    // new ModuleWrap(url, context, exportNames, syntheticExecutionFunction)
    CHECK(args[3]->IsFunction());
  }",18,,135,2,,void
125526,BLOCK,-1,,"{
    // new ModuleWrap(url, context, source, lineOffset, columOffset, cachedData)
    CHECK(args[2]->IsString());
    CHECK(args[3]->IsNumber());
    line_offset = args[3].As<Int32>()->Value();
    CHECK(args[4]->IsNumber());
    column_offset = args[4].As<Int32>()->Value();
  }",10,,138,1,,void
125611,BLOCK,28,,"{
    Context::Scope context_scope(context);
    if (synthetic) {
      CHECK(args[2]->IsArray());
      Local<Array> export_names_arr = args[2].As<Array>();

      uint32_t len = export_names_arr->Length();
      std::vector<Local<String>> export_names(len);
      for (uint32_t i = 0; i < len; i++) {
        Local<Value> export_name_val =
            export_names_arr->Get(context, i).ToLocalChecked();
        CHECK(export_name_val->IsString());
        export_names[i] = export_name_val.As<String>();
      }

      module = Module::CreateSyntheticModule(isolate, url, export_names,
        SyntheticModuleEvaluationStepsCallback);
    } else {
      ScriptCompiler::CachedData* cached_data = nullptr;
      if (!args[5]->IsUndefined()) {
        CHECK(args[5]->IsArrayBufferView());
        Local<ArrayBufferView> cached_data_buf = args[5].As<ArrayBufferView>();
        uint8_t* data =
            static_cast<uint8_t*>(cached_data_buf->Buffer()->Data());
        cached_data =
            ...",3,,157,28,,void
125617,BLOCK,-1,,"{
      CHECK(args[2]->IsArray());
      Local<Array> export_names_arr = args[2].As<Array>();

      uint32_t len = export_names_arr->Length();
      std::vector<Local<String>> export_names(len);
      for (uint32_t i = 0; i < len; i++) {
        Local<Value> export_name_val =
            export_names_arr->Get(context, i).ToLocalChecked();
        CHECK(export_name_val->IsString());
        export_names[i] = export_name_val.As<String>();
      }

      module = Module::CreateSyntheticModule(isolate, url, export_names,
        SyntheticModuleEvaluationStepsCallback);
    }",20,,159,2,,void
125655,BLOCK,-1,,<empty>,7,,165,1,,void
125665,BLOCK,4,,"{
        Local<Value> export_name_val =
            export_names_arr->Get(context, i).ToLocalChecked();
        CHECK(export_name_val->IsString());
        export_names[i] = export_name_val.As<String>();
      }",42,,165,4,,void
125705,BLOCK,-1,,"{
      ScriptCompiler::CachedData* cached_data = nullptr;
      if (!args[5]->IsUndefined()) {
        CHECK(args[5]->IsArrayBufferView());
        Local<ArrayBufferView> cached_data_buf = args[5].As<ArrayBufferView>();
        uint8_t* data =
            static_cast<uint8_t*>(cached_data_buf->Buffer()->Data());
        cached_data =
            new ScriptCompiler::CachedData(data + cached_data_buf->ByteOffset(),
                                           cached_data_buf->ByteLength());
      }

      Local<String> source_text = args[2].As<String>();
      ScriptOrigin origin(isolate,
                          url,
                          line_offset,
                          column_offset,
                          true,                             // is cross origin
                          -1,                               // script id
                          Local<Value>(),                   // source map URL
                          false,                            // ...",12,,174,1,,void
125718,BLOCK,-1,,"{
        CHECK(args[5]->IsArrayBufferView());
        Local<ArrayBufferView> cached_data_buf = args[5].As<ArrayBufferView>();
        uint8_t* data =
            static_cast<uint8_t*>(cached_data_buf->Buffer()->Data());
        cached_data =
            new ScriptCompiler::CachedData(data + cached_data_buf->ByteOffset(),
                                           cached_data_buf->ByteLength());
      }",36,,176,2,,void
125803,BLOCK,-1,,"{
        options = ScriptCompiler::kNoCompileOptions;
      }",46,,200,2,,void
125810,BLOCK,-1,,"{
        options = ScriptCompiler::kConsumeCodeCache;
      }",14,,202,1,,void
125831,BLOCK,-1,,"{
        if (try_catch.HasCaught() && !try_catch.HasTerminated()) {
          CHECK(!try_catch.Message().IsEmpty());
          CHECK(!try_catch.Exception().IsEmpty());
          AppendExceptionLine(env, try_catch.Exception(), try_catch.Message(),
                              ErrorHandlingMode::MODULE_ERROR);
          try_catch.ReThrow();
        }
        return;
      }",35,,206,2,,void
125843,BLOCK,-1,,"{
          CHECK(!try_catch.Message().IsEmpty());
          CHECK(!try_catch.Exception().IsEmpty());
          AppendExceptionLine(env, try_catch.Exception(), try_catch.Message(),
                              ErrorHandlingMode::MODULE_ERROR);
          try_catch.ReThrow();
        }",66,,207,2,,void
125893,BLOCK,-1,,"{
        THROW_ERR_VM_MODULE_CACHED_DATA_REJECTED(
            env, ""cachedData buffer was rejected"");
        try_catch.ReThrow();
        return;
      }",45,,217,2,,void
125918,BLOCK,-1,,"{
    return;
  }",69,,226,2,,void
125931,BLOCK,-1,,"{
    obj->synthetic_ = true;
    obj->object()->SetInternalField(kSyntheticEvaluationStepsSlot, args[3]);
  }",18,,232,2,,void
126015,BLOCK,-1,,"{
  Local<Object> assertions =
        Object::New(isolate, v8::Null(env->isolate()), nullptr, nullptr, 0);
  for (int i = 0; i < raw_assertions->Length(); i += 3) {
      assertions
          ->Set(env->context(),
                raw_assertions->Get(env->context(), i).As<String>(),
                raw_assertions->Get(env->context(), i + 1).As<Value>())
          .ToChecked();
  }

  return assertions;
}",55,,254,4,,void
126039,BLOCK,-1,,<empty>,3,,257,1,,void
126053,BLOCK,4,,"{
      assertions
          ->Set(env->context(),
                raw_assertions->Get(env->context(), i).As<String>(),
                raw_assertions->Get(env->context(), i + 1).As<Value>())
          .ToChecked();
  }",57,,257,4,,void
126097,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = args.GetIsolate();

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsFunction());

  Local<Object> that = args.This();

  ModuleWrap* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, that);

  if (obj->linked_)
    return;
  obj->linked_ = true;

  Local<Function> resolver_arg = args[0].As<Function>();

  Local<Context> mod_context = obj->context();
  Local<Module> module = obj->module_.Get(isolate);

  Local<FixedArray> module_requests = module->GetModuleRequests();
  const int module_requests_length = module_requests->Length();
  MaybeStackBuffer<Local<Value>, 16> promises(module_requests_length);

  // call the dependency resolve callbacks
  for (int i = 0; i < module_requests_length; i++) {
    Local<ModuleRequest> module_request =
      module_requests->Get(env->context(), i).As<ModuleRequest>();
    Local<String> specifier = module_request->GetSpecifier();
    Utf8Value specifier_utf8(env->isolate(), specifier);
  ...",64,,268,2,,void
126145,BLOCK,-1,,<empty>,5,,281,2,,void
126208,BLOCK,-1,,<empty>,3,,294,1,,void
126218,BLOCK,4,,"{
    Local<ModuleRequest> module_request =
      module_requests->Get(env->context(), i).As<ModuleRequest>();
    Local<String> specifier = module_request->GetSpecifier();
    Utf8Value specifier_utf8(env->isolate(), specifier);
    std::string specifier_std(*specifier_utf8, specifier_utf8.length());

    Local<FixedArray> raw_assertions = module_request->GetImportAssertions();
    Local<Object> assertions =
      createImportAssertionContainer(env, isolate, raw_assertions);

    Local<Value> argv[] = {
        specifier,
        assertions,
    };

    MaybeLocal<Value> maybe_resolve_return_value =
        resolver_arg->Call(mod_context, that, arraysize(argv), argv);
    if (maybe_resolve_return_value.IsEmpty()) {
      return;
    }
    Local<Value> resolve_return_value =
        maybe_resolve_return_value.ToLocalChecked();
    if (!resolve_return_value->IsPromise()) {
      THROW_ERR_VM_MODULE_LINK_FAILURE(
          env, ""request for '%s' did not return promise"", specifier_std)...",52,,294,4,,void
126308,BLOCK,-1,,"{
      return;
    }",47,,312,2,,void
126326,BLOCK,-1,,"{
      THROW_ERR_VM_MODULE_LINK_FAILURE(
          env, ""request for '%s' did not return promise"", specifier_std);
      return;
    }",45,,317,2,,void
126384,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = args.GetIsolate();
  ModuleWrap* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.This());
  Local<Context> context = obj->context();
  Local<Module> module = obj->module_.Get(isolate);
  TryCatchScope try_catch(env);
  USE(module->InstantiateModule(context, ResolveModuleCallback));

  // clear resolve cache on instantiate
  obj->resolve_cache_.clear();

  if (try_catch.HasCaught() && !try_catch.HasTerminated()) {
    CHECK(!try_catch.Message().IsEmpty());
    CHECK(!try_catch.Exception().IsEmpty());
    AppendExceptionLine(env, try_catch.Exception(), try_catch.Message(),
                        ErrorHandlingMode::MODULE_ERROR);
    try_catch.ReThrow();
    return;
  }
}",71,,332,2,,void
126458,BLOCK,-1,,"{
    CHECK(!try_catch.Message().IsEmpty());
    CHECK(!try_catch.Exception().IsEmpty());
    AppendExceptionLine(env, try_catch.Exception(), try_catch.Message(),
                        ErrorHandlingMode::MODULE_ERROR);
    try_catch.ReThrow();
    return;
  }",60,,345,2,,void
126499,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  ModuleWrap* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.This());
  Local<Context> context = obj->context();
  Local<Module> module = obj->module_.Get(isolate);

  ContextifyContext* contextify_context = obj->contextify_context_;
  std::shared_ptr<MicrotaskQueue> microtask_queue;
  if (contextify_context != nullptr)
      microtask_queue = contextify_context->microtask_queue();

  // module.evaluate(timeout, breakOnSigint)
  CHECK_EQ(args.Length(), 2);

  CHECK(args[0]->IsNumber());
  int64_t timeout = args[0]->IntegerValue(env->context()).FromJust();

  CHECK(args[1]->IsBoolean());
  bool break_on_sigint = args[1]->IsTrue();

  ShouldNotAbortOnUncaughtScope no_abort_scope(env);
  TryCatchScope try_catch(env);
  Isolate::SafeForTerminationScope safe_for_termination(env->isolate());

  bool timed_out = false;
  bool received_signal = false;
  MaybeLocal<Value> result;
  auto run = [&]() {
    Ma...",68,,355,2,,void
126562,BLOCK,-1,,<empty>,7,,366,2,,void
126650,BLOCK,-1,,"{
    Watchdog wd(isolate, timeout, &timed_out);
    SigintWatchdog swd(isolate, &received_signal);
    result = run();
  }",41,,390,2,,void
126666,BLOCK,-1,,<empty>,10,,394,1,,void
126669,BLOCK,-1,,"{
    SigintWatchdog swd(isolate, &received_signal);
    result = run();
  }",31,,394,2,,void
126679,BLOCK,-1,,<empty>,10,,397,1,,void
126685,BLOCK,-1,,"{
    Watchdog wd(isolate, timeout, &timed_out);
    result = run();
  }",29,,397,2,,void
126696,BLOCK,-1,,"{
    result = run();
  }",10,,400,1,,void
126705,BLOCK,-1,,"{
    CHECK(try_catch.HasCaught());
  }",25,,404,2,,void
126715,BLOCK,-1,,"{
    if (!env->is_main_thread() && env->is_stopping())
      return;
    env->isolate()->CancelTerminateExecution();
    // It is possible that execution was terminated by another timeout in
    // which this timeout is nested, so check whether one of the watchdogs
    // from this invocation is responsible for termination.
    if (timed_out) {
      THROW_ERR_SCRIPT_EXECUTION_TIMEOUT(env, timeout);
    } else if (received_signal) {
      THROW_ERR_SCRIPT_EXECUTION_INTERRUPTED(env);
    }
  }",37,,409,2,,void
126727,BLOCK,-1,,<empty>,7,,411,2,,void
126738,BLOCK,-1,,"{
      THROW_ERR_SCRIPT_EXECUTION_TIMEOUT(env, timeout);
    }",20,,416,2,,void
126743,BLOCK,-1,,<empty>,12,,418,1,,void
126746,BLOCK,-1,,"{
      THROW_ERR_SCRIPT_EXECUTION_INTERRUPTED(env);
    }",33,,418,2,,void
126754,BLOCK,-1,,"{
    if (!try_catch.HasTerminated())
      try_catch.ReThrow();
    return;
  }",30,,423,2,,void
126761,BLOCK,-1,,<empty>,7,,425,2,,void
126782,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = args.GetIsolate();
  ModuleWrap* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.This());

  Local<Module> module = obj->module_.Get(isolate);

  switch (module->GetStatus()) {
    case v8::Module::Status::kUninstantiated:
    case v8::Module::Status::kInstantiating:
      return env->ThrowError(
          ""cannot get namespace, module has not been instantiated"");
    case v8::Module::Status::kInstantiated:
    case v8::Module::Status::kEvaluating:
    case v8::Module::Status::kEvaluated:
    case v8::Module::Status::kErrored:
      break;
    default:
      UNREACHABLE();
  }

  Local<Value> result = module->GetModuleNamespace();
  args.GetReturnValue().Set(result);
}",72,,432,2,,void
126824,BLOCK,-1,,"{
    case v8::Module::Status::kUninstantiated:
    case v8::Module::Status::kInstantiating:
      return env->ThrowError(
          ""cannot get namespace, module has not been instantiated"");
    case v8::Module::Status::kInstantiated:
    case v8::Module::Status::kEvaluating:
    case v8::Module::Status::kEvaluated:
    case v8::Module::Status::kErrored:
      break;
    default:
      UNREACHABLE();
  }",32,,440,2,,void
126904,BLOCK,-1,,"{
  Isolate* isolate = args.GetIsolate();
  ModuleWrap* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.This());

  Local<Module> module = obj->module_.Get(isolate);

  args.GetReturnValue().Set(module->GetStatus());
}",69,,458,2,,void
126948,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  ModuleWrap* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.This());

  Local<Module> module = obj->module_.Get(env->isolate());

  Local<FixedArray> module_requests = module->GetModuleRequests();
  int count = module_requests->Length();

  MaybeStackBuffer<Local<Value>, 16> specifiers(count);

  for (int i = 0; i < count; i++) {
    Local<ModuleRequest> module_request =
      module_requests->Get(env->context(), i).As<ModuleRequest>();
    specifiers[i] = module_request->GetSpecifier();
  }

  args.GetReturnValue().Set(
      Array::New(env->isolate(), specifiers.out(), count));
}",46,,469,2,,void
127002,BLOCK,-1,,<empty>,3,,481,1,,void
127012,BLOCK,4,,"{
    Local<ModuleRequest> module_request =
      module_requests->Get(env->context(), i).As<ModuleRequest>();
    specifiers[i] = module_request->GetSpecifier();
  }",35,,481,4,,void
127063,BLOCK,-1,,"{
  Isolate* isolate = args.GetIsolate();
  ModuleWrap* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.This());

  Local<Module> module = obj->module_.Get(isolate);
  args.GetReturnValue().Set(module->GetException());
}",68,,491,2,,void
127110,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  if (env == nullptr) {
    Isolate* isolate = context->GetIsolate();
    THROW_ERR_EXECUTION_ENVIRONMENT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Module>();
  }

  Isolate* isolate = env->isolate();

  Utf8Value specifier_utf8(isolate, specifier);
  std::string specifier_std(*specifier_utf8, specifier_utf8.length());

  ModuleWrap* dependent = GetFromModule(env, referrer);
  if (dependent == nullptr) {
    THROW_ERR_VM_MODULE_LINK_FAILURE(
        env, ""request for '%s' is from invalid module"", specifier_std);
    return MaybeLocal<Module>();
  }

  if (dependent->resolve_cache_.count(specifier_std) != 1) {
    THROW_ERR_VM_MODULE_LINK_FAILURE(
        env, ""request for '%s' is not in cache"", specifier_std);
    return MaybeLocal<Module>();
  }

  Local<Promise> resolve_promise =
      dependent->resolve_cache_[specifier_std].Get(isolate);

  if (resolve_promise->State() != Promise::kFulfilled) {
    THROW_ERR_VM_MODULE_...",29,,504,5,,void
127123,BLOCK,-1,,"{
    Isolate* isolate = context->GetIsolate();
    THROW_ERR_EXECUTION_ENVIRONMENT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Module>();
  }",23,,506,2,,void
127164,BLOCK,-1,,"{
    THROW_ERR_VM_MODULE_LINK_FAILURE(
        env, ""request for '%s' is from invalid module"", specifier_std);
    return MaybeLocal<Module>();
  }",29,,518,2,,void
127181,BLOCK,-1,,"{
    THROW_ERR_VM_MODULE_LINK_FAILURE(
        env, ""request for '%s' is not in cache"", specifier_std);
    return MaybeLocal<Module>();
  }",60,,524,2,,void
127212,BLOCK,-1,,"{
    THROW_ERR_VM_MODULE_LINK_FAILURE(
        env, ""request for '%s' is not yet fulfilled"", specifier_std);
    return MaybeLocal<Module>();
  }",56,,533,2,,void
127243,BLOCK,-1,,"{
    THROW_ERR_VM_MODULE_LINK_FAILURE(
        env, ""request for '%s' did not return an object"", specifier_std);
    return MaybeLocal<Module>();
  }",62,,540,2,,void
127272,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  Environment* env = Environment::GetCurrent(context);
  if (env == nullptr) {
    THROW_ERR_EXECUTION_ENVIRONMENT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Promise>();
  }

  EscapableHandleScope handle_scope(isolate);

  Local<Function> import_callback =
    env->host_import_module_dynamically_callback();

  Local<FixedArray> options = host_defined_options.As<FixedArray>();
  if (options->Length() != HostDefinedOptions::kLength) {
    Local<Promise::Resolver> resolver;
    if (!Promise::Resolver::New(context).ToLocal(&resolver)) return {};
    resolver
        ->Reject(context,
                 v8::Exception::TypeError(FIXED_ONE_BYTE_STRING(
                     context->GetIsolate(), ""Invalid host defined options"")))
        .ToChecked();
    return handle_scope.Escape(resolver->GetPromise());
  }

  Local<Value> object;

  int type = options->Get(context, HostDefinedOptions::kType)
                 .As<Number>()
                 ...",42,,556,6,,void
127292,BLOCK,-1,,"{
    THROW_ERR_EXECUTION_ENVIRONMENT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Promise>();
  }",23,,559,2,,void
127329,BLOCK,-1,,"{
    Local<Promise::Resolver> resolver;
    if (!Promise::Resolver::New(context).ToLocal(&resolver)) return {};
    resolver
        ->Reject(context,
                 v8::Exception::TypeError(FIXED_ONE_BYTE_STRING(
                     context->GetIsolate(), ""Invalid host defined options"")))
        .ToChecked();
    return handle_scope.Escape(resolver->GetPromise());
  }",57,,570,2,,void
127351,BLOCK,-1,,<empty>,62,,572,2,,void
127435,BLOCK,-1,,"{
    contextify::ContextifyScript* wrap = env->id_to_script_map.find(id)->second;
    object = wrap->object();
  }",36,,591,2,,void
127455,BLOCK,-1,,<empty>,10,,594,1,,void
127462,BLOCK,-1,,"{
    ModuleWrap* wrap = ModuleWrap::GetFromID(env, id);
    object = wrap->object();
  }",43,,594,2,,void
127479,BLOCK,-1,,<empty>,10,,597,1,,void
127486,BLOCK,-1,,"{
    auto it = env->id_to_function_map.find(id);
    CHECK_NE(it, env->id_to_function_map.end());
    object = it->second->object();
  }",45,,597,2,,void
127514,BLOCK,-1,,"{
    UNREACHABLE();
  }",10,,601,1,,void
127558,BLOCK,-1,,"{
    CHECK(result->IsPromise());
    return handle_scope.Escape(result.As<Promise>());
  }",40,,619,2,,void
127579,BLOCK,-1,,"{
  Isolate* isolate = args.GetIsolate();
  Environment* env = Environment::GetCurrent(args);
  HandleScope handle_scope(isolate);

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsFunction());
  Local<Function> import_callback = args[0].As<Function>();
  env->set_host_import_module_dynamically_callback(import_callback);

  isolate->SetHostImportModuleDynamicallyCallback(ImportModuleDynamically);
}",46,,628,2,,void
127639,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  if (env == nullptr)
    return;
  ModuleWrap* module_wrap = GetFromModule(env, module);

  if (module_wrap == nullptr) {
    return;
  }

  Local<Object> wrap = module_wrap->object();
  Local<Function> callback =
      env->host_initialize_import_meta_object_callback();
  Local<Value> args[] = { wrap, meta };
  TryCatchScope try_catch(env);
  USE(callback->Call(
        context, Undefined(env->isolate()), arraysize(args), args));
  if (try_catch.HasCaught() && !try_catch.HasTerminated()) {
    try_catch.ReThrow();
  }
}",71,,642,4,,void
127652,BLOCK,-1,,<empty>,5,,645,2,,void
127664,BLOCK,-1,,"{
    return;
  }",31,,648,2,,void
127720,BLOCK,-1,,"{
    try_catch.ReThrow();
  }",60,,659,2,,void
127729,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsFunction());
  Local<Function> import_meta_callback = args[0].As<Function>();
  env->set_host_initialize_import_meta_object_callback(import_meta_callback);

  isolate->SetHostInitializeImportMetaObjectCallback(
      HostInitializeImportMetaObjectCallback);
}",46,,665,2,,void
127785,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  ModuleWrap* obj = GetFromModule(env, module);

  TryCatchScope try_catch(env);
  Local<Function> synthetic_evaluation_steps =
      obj->object()->GetInternalField(kSyntheticEvaluationStepsSlot)
          .As<Function>();
  obj->object()->SetInternalField(
      kSyntheticEvaluationStepsSlot, Undefined(isolate));
  MaybeLocal<Value> ret = synthetic_evaluation_steps->Call(context,
      obj->object(), 0, nullptr);
  if (ret.IsEmpty()) {
    CHECK(try_catch.HasCaught());
  }
  if (try_catch.HasCaught() && !try_catch.HasTerminated()) {
    CHECK(!try_catch.Message().IsEmpty());
    CHECK(!try_catch.Exception().IsEmpty());
    try_catch.ReThrow();
    return MaybeLocal<Value>();
  }

  Local<Promise::Resolver> resolver;
  if (!Promise::Resolver::New(context).ToLocal(&resolver)) {
    return MaybeLocal<Value>();
  }

  resolver->Resolve(context, Undefined(isolate)).ToChecked();
  return resol...",51,,679,3,,void
127859,BLOCK,-1,,"{
    CHECK(try_catch.HasCaught());
  }",22,,693,2,,void
127876,BLOCK,-1,,"{
    CHECK(!try_catch.Message().IsEmpty());
    CHECK(!try_catch.Exception().IsEmpty());
    try_catch.ReThrow();
    return MaybeLocal<Value>();
  }",60,,696,2,,void
127922,BLOCK,-1,,"{
    return MaybeLocal<Value>();
  }",60,,704,2,,void
127944,BLOCK,-1,,"{
  Isolate* isolate = args.GetIsolate();
  Local<Object> that = args.This();

  ModuleWrap* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, that);

  CHECK(obj->synthetic_);

  CHECK_EQ(args.Length(), 2);

  CHECK(args[0]->IsString());
  Local<String> export_name = args[0].As<String>();

  Local<Value> export_value = args[1];

  Local<Module> module = obj->module_.Get(isolate);
  USE(module->SetSyntheticModuleExport(isolate, export_name, export_value));
}",78,,712,2,,void
128030,BLOCK,-1,,"{
  Isolate* isolate = args.GetIsolate();
  Local<Object> that = args.This();

  ModuleWrap* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, that);

  CHECK(!obj->synthetic_);

  Local<Module> module = obj->module_.Get(isolate);

  CHECK_LT(module->GetStatus(), v8::Module::Status::kEvaluating);

  Local<UnboundModuleScript> unbound_module_script =
      module->GetUnboundModuleScript();
  std::unique_ptr<ScriptCompiler::CachedData> cached_data(
      ScriptCompiler::CreateCodeCache(unbound_module_script));
  Environment* env = Environment::GetCurrent(args);
  if (!cached_data) {
    args.GetReturnValue().Set(Buffer::New(env, 0).ToLocalChecked());
  } else {
    MaybeLocal<Object> buf =
        Buffer::Copy(env,
                     reinterpret_cast<const char*>(cached_data->data),
                     cached_data->length);
    args.GetReturnValue().Set(buf.ToLocalChecked());
  }
}",76,,732,2,,void
128095,BLOCK,-1,,<empty>,,,,2,,<empty>
128109,BLOCK,-1,,"{
    args.GetReturnValue().Set(Buffer::New(env, 0).ToLocalChecked());
  }",21,,750,2,,void
128127,BLOCK,-1,,"{
    MaybeLocal<Object> buf =
        Buffer::Copy(env,
                     reinterpret_cast<const char*>(cached_data->data),
                     cached_data->length);
    args.GetReturnValue().Set(buf.ToLocalChecked());
  }",10,,752,1,,void
128165,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> tpl = NewFunctionTemplate(isolate, New);
  tpl->InstanceTemplate()->SetInternalFieldCount(
      ModuleWrap::kInternalFieldCount);

  SetProtoMethod(isolate, tpl, ""link"", Link);
  SetProtoMethod(isolate, tpl, ""instantiate"", Instantiate);
  SetProtoMethod(isolate, tpl, ""evaluate"", Evaluate);
  SetProtoMethod(isolate, tpl, ""setExport"", SetSyntheticExport);
  SetProtoMethodNoSideEffect(
      isolate, tpl, ""createCachedData"", CreateCachedData);
  SetProtoMethodNoSideEffect(isolate, tpl, ""getNamespace"", GetNamespace);
  SetProtoMethodNoSideEffect(isolate, tpl, ""getStatus"", GetStatus);
  SetProtoMethodNoSideEffect(isolate, tpl, ""getError"", GetError);
  SetProtoMethodNoSideEffect(isolate,
                             tpl,
                             ""getStaticDependencySpecifiers"",
                             GetStaticDependencySpecifiers);

  SetConstructorFunction(c...",41,,764,5,,void
128261,BLOCK,1,,<empty>,,,,3,,void
128290,BLOCK,1,,<empty>,,,,3,,void
128319,BLOCK,1,,<empty>,,,,3,,void
128348,BLOCK,1,,<empty>,,,,3,,void
128377,BLOCK,1,,<empty>,,,,3,,void
128406,BLOCK,1,,<empty>,,,,3,,void
128438,BLOCK,-1,,"{
  registry->Register(New);

  registry->Register(Link);
  registry->Register(Instantiate);
  registry->Register(Evaluate);
  registry->Register(SetSyntheticExport);
  registry->Register(CreateCachedData);
  registry->Register(GetNamespace);
  registry->Register(GetStatus);
  registry->Register(GetError);
  registry->Register(GetStaticDependencySpecifiers);

  registry->Register(SetImportModuleDynamicallyCallback);
  registry->Register(SetInitializeImportMetaObjectCallback);
}",42,,812,2,,void
128514,BLOCK,-1,,<empty>,1,,1,1,,ANY
128518,BLOCK,-1,,"{
      Environment* env = static_cast<Environment*>(data);
      env->isolate()->SetAtomicsWaitCallback(nullptr, nullptr);
    }",35,,255,2,,void
128539,BLOCK,-1,,{ env->set_embedder_entry_point({}); },28,,284,1,,void
128550,BLOCK,-1,,"{
    TearDownOncePerProcess();

    if (snapshot_data != nullptr &&
        snapshot_data->data_ownership == SnapshotData::DataOwnership::kOwned) {
      delete snapshot_data;
    }
  }",45,,1265,1,,void
128566,BLOCK,-1,,"{
      delete snapshot_data;
    }",79,,1269,2,,void
128681,BLOCK,-1,,<empty>,1,,1,1,,ANY
128708,BLOCK,-1,,"{
  Environment* env = static_cast<Environment*>(data);

  const char* message = ""(unknown event)"";
  switch (event) {
#define V(key, msg)                         \
    case Isolate::AtomicsWaitEvent::key:    \
      message = msg;                        \
      break;
    ATOMIC_WAIT_EVENTS(V)
#undef V
  }

  fprintf(stderr,
          ""(node:%d) [Thread %"" PRIu64 ""] Atomics.wait(%p + %zx, %"" PRId64
          "", %.f) %s\n"",
          static_cast<int>(uv_os_getpid()),
          env->thread_id(),
          array_buffer->Data(),
          offset_in_bytes,
          value,
          timeout_in_ms,
          message);
}",45,,220,8,,void
128721,BLOCK,-1,,"{
#define V(key, msg)                         \
    case Isolate::AtomicsWaitEvent::key:    \
      message = msg;                        \
      break;
    ATOMIC_WAIT_EVENTS(V)
#undef V
  }",18,,224,2,,void
128723,BLOCK,1,,<empty>,,,,1,,void
128788,BLOCK,-1,,"{
  isolate_->GetHeapProfiler()->AddBuildEmbedderGraphCallback(
      Environment::BuildEmbedderGraph, this);
  if (heap_snapshot_near_heap_limit_ > 0) {
    AddHeapSnapshotNearHeapLimitCallback();
  }
  if (options_->trace_uncaught)
    isolate_->SetCaptureStackTraceForUncaughtExceptions(true);
  if (options_->trace_atomics_wait) {
    isolate_->SetAtomicsWaitCallback(AtomicsWaitCallback, this);
    AddCleanupHook([](void* data) {
      Environment* env = static_cast<Environment*>(data);
      env->isolate()->SetAtomicsWaitCallback(nullptr, nullptr);
    }, this);
  }
}",43,,245,1,,void
128804,BLOCK,-1,,"{
    AddHeapSnapshotNearHeapLimitCallback();
  }",43,,248,2,,void
128810,BLOCK,-1,,<empty>,5,,252,2,,void
128820,BLOCK,-1,,"{
    isolate_->SetAtomicsWaitCallback(AtomicsWaitCallback, this);
    AddCleanupHook([](void* data) {
      Environment* env = static_cast<Environment*>(data);
      env->isolate()->SetAtomicsWaitCallback(nullptr, nullptr);
    }, this);
  }",37,,253,2,,void
128835,BLOCK,-1,,"{
  EscapableHandleScope scope(env->isolate());
  CHECK_NOT_NULL(main_script_id);
  Realm* realm = env->principal_realm();

  return scope.EscapeMaybe(realm->ExecuteBootstrapper(main_script_id));
}",80,,263,3,,void
128865,BLOCK,-1,,"{
  InternalCallbackScope callback_scope(
      env,
      Object::New(env->isolate()),
      { 1, 0 },
      InternalCallbackScope::kSkipAsyncHooks);

  if (cb != nullptr) {
    EscapableHandleScope scope(env->isolate());
    // TODO(addaleax): pass the callback to the main script more directly,
    // e.g. by making StartExecution(env, builtin) parametrizable
    env->set_embedder_entry_point(std::move(cb));
    auto reset_entry_point =
        OnScopeLeave([&]() { env->set_embedder_entry_point({}); });

    const char* entry = env->isolate_data()->is_building_snapshot()
                            ? ""internal/main/mksnapshot""
                            : ""internal/main/embedding"";

    return scope.EscapeMaybe(StartExecution(env, entry));
  }

  CHECK(!env->isolate_data()->is_building_snapshot());

  // TODO(joyeecheung): move these conditions into JS land and let the
  // deserialize main function take precedence. For workers, we need to
  // move the pre-execution part into a ...",79,,271,3,,void
128887,BLOCK,-1,,"{
    EscapableHandleScope scope(env->isolate());
    // TODO(addaleax): pass the callback to the main script more directly,
    // e.g. by making StartExecution(env, builtin) parametrizable
    env->set_embedder_entry_point(std::move(cb));
    auto reset_entry_point =
        OnScopeLeave([&]() { env->set_embedder_entry_point({}); });

    const char* entry = env->isolate_data()->is_building_snapshot()
                            ? ""internal/main/mksnapshot""
                            : ""internal/main/embedding"";

    return scope.EscapeMaybe(StartExecution(env, entry));
  }",22,,278,2,,void
128947,BLOCK,-1,,"{
    return env->RunSnapshotDeserializeMain();
  }",52,,299,2,,void
128960,BLOCK,-1,,"{
    return StartExecution(env, ""internal/main/worker_thread"");
  }",41,,303,2,,void
128976,BLOCK,-1,,"{
    first_argv = env->argv()[1];
  }",31,,308,2,,void
128989,BLOCK,-1,,"{
    return StartExecution(env, ""internal/main/inspect"");
  }",32,,312,2,,void
129000,BLOCK,-1,,"{
    return StartExecution(env, ""internal/main/print_help"");
  }",45,,316,2,,void
129012,BLOCK,-1,,"{
    return StartExecution(env, ""internal/main/prof_process"");
  }",37,,320,2,,void
129032,BLOCK,-1,,"{
    return StartExecution(env, ""internal/main/eval_string"");
  }",71,,325,2,,void
129044,BLOCK,-1,,"{
    return StartExecution(env, ""internal/main/check_syntax"");
  }",42,,329,2,,void
129056,BLOCK,-1,,"{
    return StartExecution(env, ""internal/main/test_runner"");
  }",36,,333,2,,void
129068,BLOCK,-1,,"{
    return StartExecution(env, ""internal/main/watch_mode"");
  }",35,,337,2,,void
129083,BLOCK,-1,,"{
    return StartExecution(env, ""internal/main/run_main_module"");
  }",49,,341,2,,void
129100,BLOCK,-1,,"{
    return StartExecution(env, ""internal/main/repl"");
  }",78,,345,2,,void
129112,BLOCK,-1,,"{
#ifdef __POSIX__
  // Restore signal dispositions, the parent process may have changed them.
  struct sigaction act;
  memset(&act, 0, sizeof(act));

  // The hard-coded upper limit is because NSIG is not very reliable; on Linux,
  // it evaluates to 32, 34 or 64, depending on whether RT signals are enabled.
  // Counting up to SIGRTMIN doesn't work for the same reason.
  for (unsigned nr = 1; nr < kMaxSignal; nr += 1) {
    if (nr == SIGKILL || nr == SIGSTOP)
      continue;
    act.sa_handler = (nr == SIGPIPE || nr == SIGXFSZ) ? SIG_IGN : SIG_DFL;
    if (act.sa_handler == SIG_DFL) {
      // The only bad handler value we can inhert from before exec is SIG_IGN
      // (any actual function pointer is reset to SIG_DFL during exec).
      // If that's the case, we want to reset it back to SIG_DFL.
      // However, it's also possible that an embeder (or an LD_PRELOAD-ed
      // library) has set up own signal handler for own purposes
      // (e.g. profiling). If that's the case, ...",28,,435,1,,void
129125,BLOCK,-1,,"{
  // init_process_flags is accessed in ResetStdio(),
  // which can be called from signal handlers.
  CHECK(init_process_flags.is_lock_free());
  init_process_flags.store(flags);

  if (!(flags & ProcessInitializationFlags::kNoStdioInitialization)) {
    atexit(ResetStdio);
  }

#ifdef __POSIX__
  if (!(flags & ProcessInitializationFlags::kNoStdioInitialization)) {
    // Disable stdio buffering, it interacts poorly with printf()
    // calls elsewhere in the program (e.g., any logging from V8.)
    setvbuf(stdout, nullptr, _IONBF, 0);
    setvbuf(stderr, nullptr, _IONBF, 0);

    // Make sure file descriptors 0-2 are valid before we start logging
    // anything.
    for (auto& s : stdio) {
      const int fd = &s - stdio;
      if (fstat(fd, &s.stat) == 0) continue;

      // Anything but EBADF means something is seriously wrong.  We don't
      // have to special-case EINTR, fstat() is not interruptible.
      if (errno != EBADF) ABORT();

      // If EBADF (file descriptor doe...",67,,472,2,,void
129143,BLOCK,-1,,"{
    atexit(ResetStdio);
  }",70,,478,2,,void
129148,BLOCK,-1,,"{
  if (init_process_flags.load() &
      ProcessInitializationFlags::kNoStdioInitialization) {
    return;
  }

  uv_tty_reset_mode();
#ifdef __POSIX__
  for (auto& s : stdio) {
    const int fd = &s - stdio;

    struct stat tmp;
    if (-1 == fstat(fd, &tmp)) {
      CHECK_EQ(errno, EBADF);  // Program closed file descriptor.
      continue;
    }

    bool is_same_file =
        (s.stat.st_dev == tmp.st_dev && s.stat.st_ino == tmp.st_ino);
    if (!is_same_file) continue;  // Program reopened file descriptor.

    int flags;
    do
      flags = fcntl(fd, F_GETFL);
    while (flags == -1 && errno == EINTR);  // NOLINT
    CHECK_NE(flags, -1);

    // Restore the O_NONBLOCK flag if it changed.
    if (O_NONBLOCK & (flags ^ s.flags)) {
      flags &= ~O_NONBLOCK;
      flags |= s.flags & O_NONBLOCK;

      int err;
      do
        err = fcntl(fd, F_SETFL, flags);
      while (err == -1 && errno == EINTR);  // NOLINT
      CHECK_NE(err, -1);
    }

    if (s.isatty) {
      sigset...",19,,630,1,,void
129158,BLOCK,-1,,"{
    return;
  }",59,,632,2,,void
129168,BLOCK,-1,,"{
  // Parse a few arguments which are specific to Node.
  std::vector<std::string> v8_args;

  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  options_parser::Parse(
      args,
      exec_args,
      &v8_args,
      per_process::cli_options.get(),
      settings,
      errors);

  if (!errors->empty()) return ExitCode::kInvalidCommandLineArgument;

  std::string revert_error;
  for (const std::string& cve : per_process::cli_options->security_reverts) {
    Revert(cve.c_str(), &revert_error);
    if (!revert_error.empty()) {
      errors->emplace_back(std::move(revert_error));
      // TODO(joyeecheung): merge into kInvalidCommandLineArgument.
      return ExitCode::kInvalidCommandLineArgument2;
    }
  }

  if (per_process::cli_options->disable_proto != ""delete"" &&
      per_process::cli_options->disable_proto != ""throw"" &&
      per_process::cli_options->disable_proto != """") {
    errors->emplace_back(""invalid mode passed to --disable-proto"");
    // TODO(joyeecheung): ...",74,,695,5,,void
129205,BLOCK,-1,,<empty>,25,,708,2,,void
129218,BLOCK,-1,,"{
    Revert(cve.c_str(), &revert_error);
    if (!revert_error.empty()) {
      errors->emplace_back(std::move(revert_error));
      // TODO(joyeecheung): merge into kInvalidCommandLineArgument.
      return ExitCode::kInvalidCommandLineArgument2;
    }
  }",77,,711,3,,void
129232,BLOCK,-1,,"{
      errors->emplace_back(std::move(revert_error));
      // TODO(joyeecheung): merge into kInvalidCommandLineArgument.
      return ExitCode::kInvalidCommandLineArgument2;
    }",32,,713,2,,void
129270,BLOCK,-1,,"{
    errors->emplace_back(""invalid mode passed to --disable-proto"");
    // TODO(joyeecheung): merge into kInvalidCommandLineArgument.
    return ExitCode::kInvalidCommandLineArgument2;
  }",54,,722,2,,void
129299,BLOCK,-1,,"{
    v8_args.emplace_back(""--harmony-import-assertions"");
  }",69,,731,2,,void
129353,BLOCK,-1,,"{
    env_opts->abort_on_uncaught_exception = true;
  }",68,,739,2,,void
129372,BLOCK,-1,,"{
    for (size_t i = 0; i < v8_args.size(); ++i)
      v8_args_as_char_ptr[i] = v8_args[i].data();
    int argc = v8_args.size();
    V8::SetFlagsFromCommandLine(&argc, v8_args_as_char_ptr.data(), true);
    v8_args_as_char_ptr.resize(argc);
  }",27,,753,2,,void
129374,BLOCK,-1,,<empty>,5,,754,1,,void
129421,BLOCK,-1,,<empty>,3,,762,1,,void
129454,BLOCK,-1,,<empty>,5,,766,2,,void
129470,BLOCK,-1,,"{
  return static_cast<int>(
      ProcessGlobalArgsInternal(args, exec_args, errors, settings));
}",54,,774,5,,void
129491,BLOCK,-1,,"{
  // Make sure InitializeNodeWithArgs() is called only once.
  CHECK(!init_called.exchange(true));

  // Initialize node_start_time to get relative uptime.
  per_process::node_start_time = uv_hrtime();

  // Register built-in bindings
  binding::RegisterBuiltinBindings();

  // Make inherited handles noninheritable.
  if (!(flags & ProcessInitializationFlags::kEnableStdioInheritance) &&
      !(flags & ProcessInitializationFlags::kNoStdioInitialization)) {
    uv_disable_stdio_inheritance();
  }

  // Cache the original command line to be
  // used in diagnostic reports.
  per_process::cli_options->cmdline = *argv;

  // Node provides a ""v8.setFlagsFromString"" method to dynamically change flags.
  // Hence do not freeze flags when initializing V8. In a browser setting, this
  // is security relevant, for Node it's less important.
  V8::SetFlagsFromString(""--no-freeze-flags-after-init"");

#if defined(NODE_V8_OPTIONS)
  // Should come before the call to V8::SetFlagsFromCommandLine()...",46,,787,5,,void
129522,BLOCK,-1,,"{
    uv_disable_stdio_inheritance();
  }",70,,799,2,,void
129552,BLOCK,-1,,"{
    std::string node_options;

    if (credentials::SafeGetenv(""NODE_OPTIONS"", &node_options)) {
      std::vector<std::string> env_argv =
          ParseNodeOptionsEnvVar(node_options, errors);

      if (!errors->empty()) return ExitCode::kInvalidCommandLineArgument;

      // [0] is expected to be the program name, fill it in from the real argv.
      env_argv.insert(env_argv.begin(), argv->at(0));

      const ExitCode exit_code = ProcessGlobalArgsInternal(
          &env_argv, nullptr, errors, kAllowedInEnvvar);
      if (exit_code != ExitCode::kNoFailure) return exit_code;
    }
  }",70,,822,2,,void
129562,BLOCK,-1,,"{
      std::vector<std::string> env_argv =
          ParseNodeOptionsEnvVar(node_options, errors);

      if (!errors->empty()) return ExitCode::kInvalidCommandLineArgument;

      // [0] is expected to be the program name, fill it in from the real argv.
      env_argv.insert(env_argv.begin(), argv->at(0));

      const ExitCode exit_code = ProcessGlobalArgsInternal(
          &env_argv, nullptr, errors, kAllowedInEnvvar);
      if (exit_code != ExitCode::kNoFailure) return exit_code;
    }",65,,825,2,,void
129582,BLOCK,-1,,<empty>,29,,829,2,,void
129615,BLOCK,-1,,<empty>,46,,836,2,,void
129625,BLOCK,-1,,"{
    const ExitCode exit_code =
        ProcessGlobalArgsInternal(argv, exec_argv, errors, kDisallowedInEnvvar);
    if (exit_code != ExitCode::kNoFailure) return exit_code;
  }",66,,841,2,,void
129640,BLOCK,-1,,<empty>,44,,844,2,,void
129653,BLOCK,-1,,<empty>,5,,849,2,,void
129677,BLOCK,-1,,"{
  return static_cast<int>(
      InitializeNodeWithArgsInternal(argv, exec_argv, errors, flags));
}",69,,905,5,,void
129691,BLOCK,-1,,"{
  auto result = std::make_unique<InitializationResultImpl>();
  result->args_ = args;

  if (!(flags & ProcessInitializationFlags::kNoParseGlobalDebugVariables)) {
    // Initialized the enabled list for Debug() calls with system
    // environment variables.
    per_process::enabled_debug_list.Parse();
  }

  PlatformInit(flags);

  // This needs to run *before* V8::Initialize().
  {
    result->exit_code_ = InitializeNodeWithArgsInternal(
        &result->args_, &result->exec_args_, &result->errors_, flags);
    if (result->exit_code_enum() != ExitCode::kNoFailure) {
      result->early_return_ = true;
      return result;
    }
  }

  if (!(flags & ProcessInitializationFlags::kNoUseLargePages) &&
      (per_process::cli_options->use_largepages == ""on"" ||
       per_process::cli_options->use_largepages == ""silent"")) {
    int lp_result = node::MapStaticCodeToLargePages();
    if (per_process::cli_options->use_largepages == ""on"" && lp_result != 0) {
      result->errors_.emplace_...",76,,913,3,,void
129711,BLOCK,-1,,"{
    // Initialized the enabled list for Debug() calls with system
    // environment variables.
    per_process::enabled_debug_list.Parse();
  }",76,,917,2,,void
129720,BLOCK,6,,"{
    result->exit_code_ = InitializeNodeWithArgsInternal(
        &result->args_, &result->exec_args_, &result->errors_, flags);
    if (result->exit_code_enum() != ExitCode::kNoFailure) {
      result->early_return_ = true;
      return result;
    }
  }",3,,926,6,,void
129748,BLOCK,-1,,"{
      result->early_return_ = true;
      return result;
    }",59,,929,2,,void
129779,BLOCK,-1,,"{
    int lp_result = node::MapStaticCodeToLargePages();
    if (per_process::cli_options->use_largepages == ""on"" && lp_result != 0) {
      result->errors_.emplace_back(node::LargePagesError(lp_result));
    }
  }",63,,937,2,,void
129799,BLOCK,-1,,"{
      result->errors_.emplace_back(node::LargePagesError(lp_result));
    }",77,,939,2,,void
129818,BLOCK,-1,,"{
    if (per_process::cli_options->print_version) {
      printf(""%s\n"", NODE_VERSION);
      result->exit_code_ = ExitCode::kNoFailure;
      result->early_return_ = true;
      return result;
    }

    if (per_process::cli_options->print_bash_completion) {
      std::string completion = options_parser::GetBashCompletion();
      printf(""%s\n"", completion.c_str());
      result->exit_code_ = ExitCode::kNoFailure;
      result->early_return_ = true;
      return result;
    }

    if (per_process::cli_options->print_v8_help) {
      V8::SetFlagsFromString(""--help"", static_cast<size_t>(6));
      result->exit_code_ = ExitCode::kNoFailure;
      result->early_return_ = true;
      return result;
    }
  }",75,,944,2,,void
129825,BLOCK,-1,,"{
      printf(""%s\n"", NODE_VERSION);
      result->exit_code_ = ExitCode::kNoFailure;
      result->early_return_ = true;
      return result;
    }",50,,945,2,,void
129829,BLOCK,1,,<empty>,,,,1,,void
129851,BLOCK,-1,,"{
      std::string completion = options_parser::GetBashCompletion();
      printf(""%s\n"", completion.c_str());
      result->exit_code_ = ExitCode::kNoFailure;
      result->early_return_ = true;
      return result;
    }",58,,952,2,,void
129885,BLOCK,-1,,"{
      V8::SetFlagsFromString(""--help"", static_cast<size_t>(6));
      result->exit_code_ = ExitCode::kNoFailure;
      result->early_return_ = true;
      return result;
    }",50,,960,2,,void
129915,BLOCK,-1,,"{
#if HAVE_OPENSSL && !defined(OPENSSL_IS_BORINGSSL)
    auto GetOpenSSLErrorString = []() -> std::string {
      std::string ret;
      ERR_print_errors_cb(
          [](const char* str, size_t len, void* opaque) {
            std::string* ret = static_cast<std::string*>(opaque);
            ret->append(str, len);
            ret->append(""\n"");
            return 0;
          },
          static_cast<void*>(&ret));
      return ret;
    };

    // In the case of FIPS builds we should make sure
    // the random source is properly initialized first.
#if OPENSSL_VERSION_MAJOR >= 3
    // Call OPENSSL_init_crypto to initialize OPENSSL_INIT_LOAD_CONFIG to
    // avoid the default behavior where errors raised during the parsing of the
    // OpenSSL configuration file are not propagated and cannot be detected.
    //
    // If FIPS is configured the OpenSSL configuration file will have an
    // .include pointing to the fipsmodule.cnf file generated by the openssl
    // fipsinstall com...",62,,968,2,,void
129923,BLOCK,-1,,"{
    per_process::v8_platform.Initialize(
        static_cast<int>(per_process::cli_options->v8_thread_pool_size));
    result->platform_ = per_process::v8_platform.Platform();
  }",75,,1078,2,,void
129954,BLOCK,-1,,"{
    V8::Initialize();
  }",63,,1084,2,,void
129976,BLOCK,-1,,"{
  return InitializeOncePerProcessInternal(args, flags);
}",46,,1096,3,,void
129984,BLOCK,-1,,"{
  const uint32_t flags = init_process_flags.load();
  ResetStdio();
  if (!(flags & ProcessInitializationFlags::kNoDefaultSignalHandling)) {
    ResetSignalHandlers();
  }

  per_process::v8_initialized = false;
  if (!(flags & ProcessInitializationFlags::kNoInitializeV8)) {
    V8::Dispose();
  }

#if NODE_USE_V8_WASM_TRAP_HANDLER && defined(_WIN32)
  if (!(flags & ProcessInitializationFlags::kNoDefaultSignalHandling)) {
    RemoveVectoredExceptionHandler(per_process::old_vectored_exception_handler);
  }
#endif

  if (!(flags & ProcessInitializationFlags::kNoInitializeNodeV8Platform)) {
    V8::DisposePlatform();
    // uv_run cannot be called from the time before the beforeExit callback
    // runs until the program exits unless the event loop has any referenced
    // handles after beforeExit terminates. This prevents unrefed timers
    // that happen to terminate during shutdown from being run unsafely.
    // Since uv_run cannot be called, uv_async handles held by the platfor...",31,,1100,1,,void
130000,BLOCK,-1,,"{
    ResetSignalHandlers();
  }",72,,1103,2,,void
130014,BLOCK,-1,,"{
    V8::Dispose();
  }",63,,1108,2,,void
130026,BLOCK,-1,,"{
    V8::DisposePlatform();
    // uv_run cannot be called from the time before the beforeExit callback
    // runs until the program exits unless the event loop has any referenced
    // handles after beforeExit terminates. This prevents unrefed timers
    // that happen to terminate during shutdown from being run unsafely.
    // Since uv_run cannot be called, uv_async handles held by the platform
    // will never be fully cleaned up.
    per_process::v8_platform.Dispose();
  }",75,,1118,2,,void
130040,BLOCK,-1,,<empty>,47,,1130,1,,void
130044,BLOCK,-1,,<empty>,55,,1131,1,,void
130050,BLOCK,-1,,"{
  ExitCode exit_code = result->exit_code_enum();
  // nullptr indicates there's no snapshot data.
  DCHECK_NULL(*snapshot_data_ptr);

  // node:embedded_snapshot_main indicates that we are using the
  // embedded snapshot and we are not supposed to clean it up.
  const std::string& main_script = result->args()[1];
  if (main_script == ""node:embedded_snapshot_main"") {
    *snapshot_data_ptr = SnapshotBuilder::GetEmbeddedSnapshotData();
    if (*snapshot_data_ptr == nullptr) {
      // The Node.js binary is built without embedded snapshot
      fprintf(stderr,
              ""node:embedded_snapshot_main was specified as snapshot ""
              ""entry point but Node.js was built without embedded ""
              ""snapshot.\n"");
      exit_code = ExitCode::kInvalidCommandLineArgument;
      return exit_code;
    }
  } else {
    // Otherwise, load and run the specified main script.
    std::unique_ptr<SnapshotData> generated_data =
        std::make_unique<SnapshotData>();
    std::str...",79,,1134,3,,void
130074,BLOCK,-1,,"{
    *snapshot_data_ptr = SnapshotBuilder::GetEmbeddedSnapshotData();
    if (*snapshot_data_ptr == nullptr) {
      // The Node.js binary is built without embedded snapshot
      fprintf(stderr,
              ""node:embedded_snapshot_main was specified as snapshot ""
              ""entry point but Node.js was built without embedded ""
              ""snapshot.\n"");
      exit_code = ExitCode::kInvalidCommandLineArgument;
      return exit_code;
    }
  }",53,,1142,2,,void
130087,BLOCK,-1,,"{
      // The Node.js binary is built without embedded snapshot
      fprintf(stderr,
              ""node:embedded_snapshot_main was specified as snapshot ""
              ""entry point but Node.js was built without embedded ""
              ""snapshot.\n"");
      exit_code = ExitCode::kInvalidCommandLineArgument;
      return exit_code;
    }",40,,1144,2,,void
130099,BLOCK,-1,,"{
    // Otherwise, load and run the specified main script.
    std::unique_ptr<SnapshotData> generated_data =
        std::make_unique<SnapshotData>();
    std::string main_script_content;
    int r = ReadFileSync(&main_script_content, main_script.c_str());
    if (r != 0) {
      FPrintF(stderr,
              ""Cannot read main script %s for building snapshot. %s: %s"",
              main_script,
              uv_err_name(r),
              uv_strerror(r));
      return ExitCode::kGenericUserError;
    }

    exit_code = node::SnapshotBuilder::Generate(generated_data.get(),
                                                result->args(),
                                                result->exec_args(),
                                                main_script_content);
    if (exit_code == ExitCode::kNoFailure) {
      *snapshot_data_ptr = generated_data.release();
    } else {
      return exit_code;
    }
  }",10,,1153,1,,void
130122,BLOCK,-1,,"{
      FPrintF(stderr,
              ""Cannot read main script %s for building snapshot. %s: %s"",
              main_script,
              uv_err_name(r),
              uv_strerror(r));
      return ExitCode::kGenericUserError;
    }",17,,1159,2,,void
130162,BLOCK,-1,,"{
      *snapshot_data_ptr = generated_data.release();
    }",44,,1172,2,,void
130171,BLOCK,-1,,"{
      return exit_code;
    }",12,,1174,1,,void
130185,BLOCK,-1,,"{
    snapshot_blob_path = per_process::cli_options->snapshot_blob;
  }",57,,1181,2,,void
130194,BLOCK,-1,,"{
    // Defaults to snapshot.blob in the current working directory.
    snapshot_blob_path = std::string(""snapshot.blob"");
  }",10,,1183,1,,void
130215,BLOCK,-1,,"{
    (*snapshot_data_ptr)->ToFile(fp);
    fclose(fp);
  }",22,,1189,2,,void
130225,BLOCK,-1,,"{
    fprintf(stderr,
            ""Cannot open %s for writing a snapshot.\n"",
            snapshot_blob_path.c_str());
    exit_code = ExitCode::kStartupSnapshotFailure;
  }",10,,1192,1,,void
130245,BLOCK,-1,,"{
  ExitCode exit_code = result->exit_code_enum();
  // nullptr indicates there's no snapshot data.
  DCHECK_NULL(*snapshot_data_ptr);
  // --snapshot-blob indicates that we are reading a customized snapshot.
  if (!per_process::cli_options->snapshot_blob.empty()) {
    std::string filename = per_process::cli_options->snapshot_blob;
    FILE* fp = fopen(filename.c_str(), ""rb"");
    if (fp == nullptr) {
      fprintf(stderr, ""Cannot open %s"", filename.c_str());
      exit_code = ExitCode::kStartupSnapshotFailure;
      return exit_code;
    }
    std::unique_ptr<SnapshotData> read_data = std::make_unique<SnapshotData>();
    bool ok = SnapshotData::FromFile(read_data.get(), fp);
    fclose(fp);
    if (!ok) {
      // If we fail to read the customized snapshot,
      // simply exit with kStartupSnapshotFailure.
      exit_code = ExitCode::kStartupSnapshotFailure;
      return exit_code;
    }
    *snapshot_data_ptr = read_data.release();
  } else if (per_process::cli_options->node_sn...",73,,1202,3,,void
130266,BLOCK,-1,,"{
    std::string filename = per_process::cli_options->snapshot_blob;
    FILE* fp = fopen(filename.c_str(), ""rb"");
    if (fp == nullptr) {
      fprintf(stderr, ""Cannot open %s"", filename.c_str());
      exit_code = ExitCode::kStartupSnapshotFailure;
      return exit_code;
    }
    std::unique_ptr<SnapshotData> read_data = std::make_unique<SnapshotData>();
    bool ok = SnapshotData::FromFile(read_data.get(), fp);
    fclose(fp);
    if (!ok) {
      // If we fail to read the customized snapshot,
      // simply exit with kStartupSnapshotFailure.
      exit_code = ExitCode::kStartupSnapshotFailure;
      return exit_code;
    }
    *snapshot_data_ptr = read_data.release();
  }",57,,1207,2,,void
130288,BLOCK,-1,,"{
      fprintf(stderr, ""Cannot open %s"", filename.c_str());
      exit_code = ExitCode::kStartupSnapshotFailure;
      return exit_code;
    }",24,,1210,2,,void
130327,BLOCK,-1,,"{
      // If we fail to read the customized snapshot,
      // simply exit with kStartupSnapshotFailure.
      exit_code = ExitCode::kStartupSnapshotFailure;
      return exit_code;
    }",14,,1218,2,,void
130343,BLOCK,-1,,<empty>,10,,1225,1,,void
130350,BLOCK,-1,,"{
    // If --snapshot-blob is not specified, we are reading the embedded
    // snapshot, but we will skip it if --no-node-snapshot is specified.
    const node::SnapshotData* read_data =
        SnapshotBuilder::GetEmbeddedSnapshotData();
    if (read_data != nullptr && read_data->Check()) {
      // If we fail to read the embedded snapshot, treat it as if Node.js
      // was built without one.
      *snapshot_data_ptr = read_data;
    }
  }",55,,1225,2,,void
130367,BLOCK,-1,,"{
      // If we fail to read the embedded snapshot, treat it as if Node.js
      // was built without one.
      *snapshot_data_ptr = read_data;
    }",53,,1230,2,,void
130404,BLOCK,-1,,"{
  CHECK_GT(argc, 0);

  // Hack around with the argv pointer. Used for process.title = ""blah"".
  argv = uv_setup_args(argc, argv);

  std::unique_ptr<InitializationResultImpl> result =
      InitializeOncePerProcessInternal(
          std::vector<std::string>(argv, argv + argc));
  for (const std::string& error : result->errors()) {
    FPrintF(stderr, ""%s: %s\n"", result->args().at(0), error);
  }
  if (result->early_return()) {
    return result->exit_code_enum();
  }

  DCHECK_EQ(result->exit_code_enum(), ExitCode::kNoFailure);
  const SnapshotData* snapshot_data = nullptr;

  auto cleanup_process = OnScopeLeave([&]() {
    TearDownOncePerProcess();

    if (snapshot_data != nullptr &&
        snapshot_data->data_ownership == SnapshotData::DataOwnership::kOwned) {
      delete snapshot_data;
    }
  });

  uv_loop_configure(uv_default_loop(), UV_METRICS_IDLE_TIME);

  std::string sea_config = per_process::cli_options->experimental_sea_config;
  if (!sea_config.empty()) {
    ret...",54,,1246,3,,void
130437,BLOCK,-1,,"{
    FPrintF(stderr, ""%s: %s\n"", result->args().at(0), error);
  }",53,,1255,3,,void
130455,BLOCK,-1,,"{
    return result->exit_code_enum();
  }",31,,1258,2,,void
130494,BLOCK,-1,,"{
    return sea::BuildSingleExecutableBlob(sea_config);
  }",28,,1277,2,,void
130509,BLOCK,-1,,"{
    if (result->args().size() < 2) {
      fprintf(stderr,
              ""--build-snapshot must be used with an entry point script.\n""
              ""Usage: node --build-snapshot /path/to/entry.js\n"");
      return ExitCode::kInvalidCommandLineArgument;
    }
    return GenerateAndWriteSnapshotData(&snapshot_data, result.get());
  }",62,,1282,2,,void
130520,BLOCK,-1,,"{
      fprintf(stderr,
              ""--build-snapshot must be used with an entry point script.\n""
              ""Usage: node --build-snapshot /path/to/entry.js\n"");
      return ExitCode::kInvalidCommandLineArgument;
    }",36,,1283,2,,void
130549,BLOCK,-1,,"{
#ifndef DISABLE_SINGLE_EXECUTABLE_APPLICATION
  std::tie(argc, argv) = sea::FixupArgsForSEA(argc, argv);
#endif
  return static_cast<int>(StartInternal(argc, argv));
}",34,,1296,3,,void
130574,BLOCK,-1,,"{
  env->ExitEnv(flags);
  return 0;
}",52,,1303,3,,void
130585,BLOCK,-1,,<empty>,19,,1311,1,,void
130592,BLOCK,-1,,"{
        return CreateEnvironment(
            setup->isolate_data(), setup->context(),
            std::forward<EnvironmentArgs>(env_args)...);
      }",64,,913,2,,void
130617,BLOCK,-1,,"{
        return CreateEnvironment(setup->isolate_data(),
                                 setup->context(),
                                 std::forward<EnvironmentArgs>(env_args)...);
      }",64,,936,2,,void
130663,BLOCK,-1,,<empty>,1,,1,1,,ANY
130675,BLOCK,-1,,<empty>,,,,6,,<empty>
130685,BLOCK,-1,,<empty>,,,,7,,<empty>
130693,BLOCK,-1,,"NODE_DEPRECATED(""Use ErrnoException(isolate, ...)"",
                inline v8::Local<v8::Value> ErrnoException(
      int errorno,
      const char* syscall = nullptr,
      const char* message = nullptr,
      const char* path = nullptr) {
  return ErrnoException(v8::Isolate::GetCurrent(),
                        errorno,
                        syscall,
                        message,
                        path);
})",1,,151,5,,void
130713,BLOCK,-1,,"NODE_DEPRECATED(""Use UVException(isolate, ...)"",
                inline v8::Local<v8::Value> UVException(int errorno,
                                        const char* syscall = nullptr,
                                        const char* message = nullptr,
                                        const char* path = nullptr) {
  return UVException(v8::Isolate::GetCurrent(),
                     errorno,
                     syscall,
                     message,
                     path);
})",1,,164,5,,void
130734,BLOCK,-1,,<empty>,,,,6,,<empty>
130743,BLOCK,-1,,<empty>,,,,6,,<empty>
130769,BLOCK,-1,,<empty>,,,,1,,<empty>
130865,BLOCK,-1,,<empty>,,,,1,,<empty>
130878,BLOCK,-1,,<empty>,,,,1,,<empty>
130882,BLOCK,-1,,<empty>,,,,1,,<empty>
130886,BLOCK,-1,,<empty>,,,,1,,<empty>
130890,BLOCK,-1,,<empty>,,,,1,,<empty>
130894,BLOCK,-1,,<empty>,,,,1,,<empty>
130898,BLOCK,-1,,<empty>,,,,1,,<empty>
130902,BLOCK,-1,,<empty>,,,,1,,<empty>
130906,BLOCK,-1,,<empty>,,,,1,,<empty>
130913,BLOCK,-1,,<empty>,,,,3,,<empty>
130919,BLOCK,-1,,<empty>,,,,3,,<empty>
130927,BLOCK,-1,,<empty>,,,,5,,<empty>
130933,BLOCK,-1,,<empty>,,,,3,,<empty>
130937,BLOCK,-1,,<empty>,,,,1,,<empty>
130943,BLOCK,-1,,"{
  uint64_t flags_accum = ProcessInitializationFlags::kNoFlags;
  for (const auto flag : list) flags_accum |= static_cast<uint64_t>(flag);
  return InitializeOncePerProcess(
      args, static_cast<ProcessInitializationFlags::Flags>(flags_accum));
}",68,,356,3,,void
130972,BLOCK,-1,,<empty>,,,,1,,<empty>
130992,BLOCK,-1,,<empty>,,,,5,,<empty>
130999,BLOCK,-1,,<empty>,,,,2,,<empty>
131003,BLOCK,-1,,<empty>,,,,1,,<empty>
131008,BLOCK,-1,,<empty>,,,,1,,<empty>
131013,BLOCK,-1,,<empty>,,,,2,,<empty>
131018,BLOCK,-1,,<empty>,,,,1,,<empty>
131022,BLOCK,-1,,<empty>,,,,1,,<empty>
131027,BLOCK,-1,,<empty>,,,,1,,<empty>
131032,BLOCK,-1,,<empty>,,,,2,,<empty>
131037,BLOCK,-1,,<empty>,,,,2,,<empty>
131043,BLOCK,-1,,<empty>,,,,3,,<empty>
131049,BLOCK,-1,,<empty>,,,,3,,<empty>
131054,BLOCK,-1,,<empty>,,,,2,,<empty>
131061,BLOCK,-1,,<empty>,,,,4,,<empty>
131068,BLOCK,-1,,<empty>,,,,4,,<empty>
131078,BLOCK,-1,,<empty>,,,,1,,<empty>
131114,BLOCK,-1,,<empty>,,,,1,,<empty>
131151,BLOCK,-1,,<empty>,,,,2,,<empty>
131156,BLOCK,-1,,<empty>,,,,1,,<empty>
131161,BLOCK,-1,,<empty>,,,,2,,<empty>
131166,BLOCK,-1,,<empty>,,,,2,,<empty>
131171,BLOCK,-1,,<empty>,,,,2,,<empty>
131175,BLOCK,-1,,<empty>,,,,1,,<empty>
131179,BLOCK,-1,,<empty>,,,,1,,<empty>
131184,BLOCK,-1,,<empty>,,,,2,,<empty>
131189,BLOCK,-1,,<empty>,,,,2,,<empty>
131194,BLOCK,-1,,<empty>,,,,2,,<empty>
131199,BLOCK,-1,,<empty>,,,,2,,<empty>
131205,BLOCK,-1,,<empty>,,,,3,,<empty>
131215,BLOCK,-1,,<empty>,,,,3,,<empty>
131220,BLOCK,-1,,<empty>,,,,2,,<empty>
131229,BLOCK,-1,,<empty>,,,,6,,<empty>
131238,BLOCK,-1,,<empty>,,,,6,,<empty>
131244,BLOCK,-1,,<empty>,,,,3,,<empty>
131249,BLOCK,-1,,<empty>,,,,2,,<empty>
131258,BLOCK,-1,,<empty>,,,,6,,<empty>
131263,BLOCK,-1,,<empty>,,,,2,,<empty>
131269,BLOCK,-1,,<empty>,,,,1,,<empty>
131279,BLOCK,-1,,<empty>,,,,1,,<empty>
131296,BLOCK,-1,,<empty>,,,,1,,<empty>
131354,BLOCK,-1,,<empty>,,,,1,,<empty>
131365,BLOCK,-1,,<empty>,,,,8,,<empty>
131372,BLOCK,-1,,<empty>,,,,4,,<empty>
131380,BLOCK,-1,,<empty>,,,,5,,<empty>
131391,BLOCK,-1,,<empty>,,,,3,,<empty>
131397,BLOCK,-1,,<empty>,,,,3,,<empty>
131402,BLOCK,-1,,<empty>,,,,2,,<empty>
131408,BLOCK,-1,,<empty>,,,,3,,<empty>
131414,BLOCK,-1,,<empty>,,,,3,,<empty>
131419,BLOCK,-1,,<empty>,,,,2,,<empty>
131424,BLOCK,-1,,<empty>,,,,2,,<empty>
131429,BLOCK,-1,,<empty>,,,,2,,<empty>
131434,BLOCK,-1,,<empty>,,,,2,,<empty>
131440,BLOCK,-1,,<empty>,,,,3,,<empty>
131445,BLOCK,-1,,<empty>,,,,2,,<empty>
131451,BLOCK,-1,,<empty>,,,,3,,<empty>
131456,BLOCK,-1,,<empty>,,,,2,,<empty>
131463,BLOCK,-1,,<empty>,,,,4,,<empty>
131472,BLOCK,-1,,<empty>,,,,6,,<empty>
131481,BLOCK,-1,,<empty>,,,,6,,<empty>
131490,BLOCK,-1,,<empty>,,,,6,,<empty>
131499,BLOCK,-1,,<empty>,,,,6,,<empty>
131504,BLOCK,-1,,<empty>,,,,2,,<empty>
131509,BLOCK,-1,,<empty>,,,,2,,<empty>
131515,BLOCK,-1,,<empty>,,,,3,,<empty>
131520,BLOCK,-1,,<empty>,,,,2,,<empty>
131524,BLOCK,-1,,<empty>,,,,1,,<empty>
131529,BLOCK,-1,,<empty>,,,,2,,<empty>
131534,BLOCK,-1,,<empty>,,,,2,,<empty>
131539,BLOCK,-1,,<empty>,,,,2,,<empty>
131544,BLOCK,-1,,<empty>,,,,2,,<empty>
131549,BLOCK,-1,,<empty>,,,,2,,<empty>
131554,BLOCK,-1,,<empty>,,,,2,,<empty>
131561,BLOCK,-1,,<empty>,,,,2,,<empty>
131565,BLOCK,-1,,<empty>,,,,1,,<empty>
131570,BLOCK,-1,,<empty>,,,,1,,<empty>
131577,BLOCK,-1,,<empty>,,,,4,,<empty>
131585,BLOCK,-1,,<empty>,,,,5,,<empty>
131593,BLOCK,-1,,<empty>,,,,5,,<empty>
131597,BLOCK,-1,,<empty>,,,,1,,<empty>
131603,BLOCK,-1,,<empty>,,,,1,,<empty>
131607,BLOCK,-1,,<empty>,,,,1,,<empty>
131611,BLOCK,-1,,<empty>,,,,1,,<empty>
131615,BLOCK,-1,,<empty>,,,,1,,<empty>
131619,BLOCK,-1,,<empty>,,,,1,,<empty>
131623,BLOCK,-1,,<empty>,,,,1,,<empty>
131628,BLOCK,-1,,<empty>,,,,2,,<empty>
131633,BLOCK,-1,,<empty>,,,,2,,<empty>
131638,BLOCK,-1,,<empty>,,,,2,,<empty>
131643,BLOCK,-1,,<empty>,,,,2,,<empty>
131650,BLOCK,-1,,<empty>,,,,1,,<empty>
131665,BLOCK,-1,,<empty>,,,,4,,<empty>
131674,BLOCK,-1,,<empty>,,,,6,,<empty>
131680,BLOCK,-1,,"{
  auto ret = std::unique_ptr<CommonEnvironmentSetup>(new CommonEnvironmentSetup(
      platform, errors,
      [&](const CommonEnvironmentSetup* setup) -> Environment* {
        return CreateEnvironment(
            setup->isolate_data(), setup->context(),
            std::forward<EnvironmentArgs>(env_args)...);
      }));
  if (!errors->empty()) ret.reset();
  return ret;
}",36,,910,4,,void
131701,BLOCK,-1,,<empty>,25,,918,2,,void
131714,BLOCK,-1,,"{
  auto ret = std::unique_ptr<CommonEnvironmentSetup>(new CommonEnvironmentSetup(
      platform,
      errors,
      snapshot_data,
      Flags::kNoFlags,
      [&](const CommonEnvironmentSetup* setup) -> Environment* {
        return CreateEnvironment(setup->isolate_data(),
                                 setup->context(),
                                 std::forward<EnvironmentArgs>(env_args)...);
      }));
  if (!errors->empty()) ret.reset();
  return ret;
}",36,,930,5,,void
131739,BLOCK,-1,,<empty>,25,,941,2,,void
131750,BLOCK,-1,,"NODE_DEPRECATED(""Use v8::Date::New() directly"",
                inline v8::Local<v8::Value> NODE_UNIXTIME_V8(double time) {
                  return v8::Date::New(
                             v8::Isolate::GetCurrent()->GetCurrentContext(),
                             1000 * time)
                      .ToLocalChecked();
                })",1,,946,2,,void
131777,BLOCK,-1,,"NODE_DEPRECATED(""Use v8::Date::ValueOf() directly"",
                inline double NODE_V8_UNIXTIME(v8::Local<v8::Date> date) {
  return date->ValueOf() / 1000;
})",1,,954,2,,void
131791,BLOCK,-1,,"{
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(isolate,
                                                                callback);
  v8::Local<v8::String> fn_name = v8::String::NewFromUtf8(isolate, name,
      v8::NewStringType::kInternalized).ToLocalChecked();
  t->SetClassName(fn_name);
  recv->Set(fn_name, t);
}",60,,1002,4,,void
131865,BLOCK,-1,,"{
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> context = isolate->GetCurrentContext();
  v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(isolate,
                                                                callback);
  v8::Local<v8::Function> fn = t->GetFunction(context).ToLocalChecked();
  v8::Local<v8::String> fn_name = v8::String::NewFromUtf8(isolate, name,
      v8::NewStringType::kInternalized).ToLocalChecked();
  fn->SetName(fn_name);
  recv->Set(context, fn_name, fn).Check();
}",60,,1016,4,,void
131975,BLOCK,-1,,"{
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Signature> s = v8::Signature::New(isolate, recv);
  v8::Local<v8::FunctionTemplate> t =
      v8::FunctionTemplate::New(isolate, callback, v8::Local<v8::Value>(), s);
  v8::Local<v8::String> fn_name = v8::String::NewFromUtf8(isolate, name,
      v8::NewStringType::kInternalized).ToLocalChecked();
  t->SetClassName(fn_name);
  recv->PrototypeTemplate()->Set(fn_name, t);
}",70,,1034,4,,void
132082,BLOCK,-1,,<empty>,,,,1,,<empty>
132093,BLOCK,-1,,<empty>,,,,3,,<empty>
132101,BLOCK,-1,,<empty>,,,,5,,<empty>
132108,BLOCK,-1,,<empty>,,,,4,,<empty>
132115,BLOCK,-1,,<empty>,,,,4,,<empty>
132124,BLOCK,-1,,<empty>,,,,6,,<empty>
132129,BLOCK,-1,,<empty>,,,,2,,<empty>
132136,BLOCK,-1,,<empty>,,,,4,,<empty>
132144,BLOCK,-1,,<empty>,,,,5,,<empty>
132150,BLOCK,-1,,<empty>,,,,1,,<empty>
132169,BLOCK,-1,,<empty>,,,,2,,<empty>
132175,BLOCK,-1,,<empty>,,,,3,,<empty>
132181,BLOCK,-1,,<empty>,,,,3,,<empty>
132189,BLOCK,-1,,<empty>,,,,5,,<empty>
132197,BLOCK,-1,,<empty>,,,,5,,<empty>
132204,BLOCK,-1,,<empty>,,,,4,,<empty>
132215,BLOCK,-1,,<empty>,,,,4,,<empty>
132222,BLOCK,-1,,<empty>,,,,4,,<empty>
132229,BLOCK,-1,,<empty>,,,,2,,<empty>
132237,BLOCK,-1,,<empty>,,,,4,,<empty>
132244,BLOCK,-1,,"{
  return AsyncCleanupHookHandle(AddEnvironmentCleanupHookInternal(isolate, fun,
      arg));
}",16,,1302,4,,void
132255,BLOCK,-1,,<empty>,,,,2,,<empty>
132260,BLOCK,-1,,"{
  RemoveEnvironmentCleanupHookInternal(holder.get());
}",73,,1310,2,,void
132272,BLOCK,-1,,<empty>,,,,4,,<empty>
132277,BLOCK,-1,,<empty>,,,,2,,<empty>
132282,BLOCK,-1,,<empty>,,,,2,,<empty>
132290,BLOCK,-1,,<empty>,,,,5,,<empty>
132298,BLOCK,-1,,<empty>,,,,5,,<empty>
132304,BLOCK,-1,,<empty>,,,,3,,<empty>
132310,BLOCK,-1,,<empty>,,,,3,,<empty>
132319,BLOCK,-1,,<empty>,,,,4,,<empty>
132326,BLOCK,-1,,<empty>,,,,4,,<empty>
132330,BLOCK,-1,,<empty>,,,,1,,<empty>
132335,BLOCK,-1,,<empty>,,,,2,,<empty>
132340,BLOCK,-1,,<empty>,,,,2,,<empty>
132345,BLOCK,-1,,<empty>,,,,2,,<empty>
132350,BLOCK,-1,,<empty>,,,,2,,<empty>
132362,BLOCK,-1,,<empty>,,,,7,,<empty>
132372,BLOCK,-1,,<empty>,,,,7,,<empty>
132381,BLOCK,-1,,<empty>,,,,5,,<empty>
132385,BLOCK,-1,,<empty>,,,,1,,<empty>
132390,BLOCK,-1,,<empty>,,,,2,,<empty>
132395,BLOCK,-1,,<empty>,,,,2,,<empty>
132402,BLOCK,-1,,<empty>,,,,4,,<empty>
132409,BLOCK,-1,,<empty>,,,,4,,<empty>
132413,BLOCK,-1,,<empty>,,,,1,,<empty>
132417,BLOCK,-1,,<empty>,,,,1,,<empty>
132421,BLOCK,-1,,<empty>,,,,1,,<empty>
132427,BLOCK,-1,,<empty>,,,,2,,<empty>
132437,BLOCK,-1,,<empty>,,,,4,,<empty>
132443,BLOCK,-1,,"{ cb(env, data, hint); }",25,,48,2,,void
132456,BLOCK,-1,,"{
      finalization_scheduled = false;
      Unref();
      DrainFinalizerQueue();
    }",66,,60,2,,void
132468,BLOCK,-1,,"{
    node_napi_env__* env = static_cast<node_napi_env__*>(env_);
    if (env->terminatedOrTerminating()) {
      return;
    }
    node::Environment* node_env = env->node_env();
    if (!node_env->options()->force_node_api_uncaught_exceptions_policy &&
        !enforceUncaughtExceptionPolicy) {
      ProcessEmitDeprecationWarning(
          node_env,
          ""Uncaught N-API callback exception detected, please run node ""
          ""with option --force-node-api-uncaught-exceptions-policy=true""
          ""to handle those exceptions properly."",
          ""DEP0168"");
      return;
    }
    // If there was an unhandled exception in the complete callback,
    // report it as a fatal exception. (There is no JavaScript on the
    // callstack that can possibly handle it.)
    env->trigger_fatal_exception(local_err);
  }",74,,90,3,,void
132480,BLOCK,-1,,"{
      return;
    }",41,,92,2,,void
132500,BLOCK,-1,,"{
      ProcessEmitDeprecationWarning(
          node_env,
          ""Uncaught N-API callback exception detected, please run node ""
          ""with option --force-node-api-uncaught-exceptions-policy=true""
          ""to handle those exceptions properly."",
          ""DEP0168"");
      return;
    }",42,,97,2,,void
132516,BLOCK,-1,,{ static_cast<napi_env>(arg)->Unref(); },21,,193,2,,void
132528,BLOCK,-1,,"{
            ThreadSafeFunction* ts_fn =
                node::ContainerOf(&ThreadSafeFunction::async,
                                  reinterpret_cast<uv_async_t*>(handle));
            delete ts_fn;
          }",43,,318,2,,void
132551,BLOCK,-1,,"{ call_js_cb(env, js_callback, context, data); }",29,,416,2,,void
132564,BLOCK,-1,,"{
          ThreadSafeFunction* ts_fn =
              node::ContainerOf(&ThreadSafeFunction::async,
                                reinterpret_cast<uv_async_t*>(handle));
          ts_fn->Finalize();
        }",41,,446,2,,void
132588,BLOCK,-1,,"{
    _exports = init(env, v8impl::JsValueFromV8LocalValue(exports));
  }",41,,726,2,,void
132606,BLOCK,-1,,{ env->Unref(); },42,,801,2,,void
132617,BLOCK,-1,,"{
      _complete(env, ConvertUVErrorCode(status), _data);
    }",54,,1195,2,,void
132666,BLOCK,-1,,<empty>,1,,1,1,,ANY
132671,BLOCK,-1,,"{
  CHECK_NOT_NULL(node_env());
}",74,,25,4,,void
132677,BLOCK,-1,,"{
  destructing = true;
  DrainFinalizerQueue();
  napi_env__::DeleteMe();
}",34,,29,1,,void
132689,BLOCK,-1,,"{
  return node_env()->can_call_into_js();
}",48,,35,1,,void
132701,BLOCK,-1,,"{
  CallFinalizer<true>(cb, data, hint);
}",79,,39,4,,void
132710,BLOCK,-1,,"{
  v8::HandleScope handle_scope(isolate);
  v8::Context::Scope context_scope(context());
  CallbackIntoModule<enforceUncaughtExceptionPolicy>(
      [&](napi_env env) { cb(env, data, hint); });
}",79,,44,4,,void
132723,BLOCK,-1,,"{
  napi_env__::EnqueueFinalizer(finalizer);
  // Schedule a second pass only when it has not been scheduled, and not
  // destructing the env.
  // When the env is being destructed, queued finalizers are drained in the
  // loop of `node_napi_env__::DrainFinalizerQueue`.
  if (!finalization_scheduled && !destructing) {
    finalization_scheduled = true;
    Ref();
    node_env()->SetImmediate([this](node::Environment* node_env) {
      finalization_scheduled = false;
      Unref();
      DrainFinalizerQueue();
    });
  }
}",71,,51,2,,void
132735,BLOCK,-1,,"{
    finalization_scheduled = true;
    Ref();
    node_env()->SetImmediate([this](node::Environment* node_env) {
      finalization_scheduled = false;
      Unref();
      DrainFinalizerQueue();
    });
  }",48,,57,2,,void
132748,BLOCK,-1,,"{
  // As userland code can delete additional references in one finalizer,
  // the list of pending finalizers may be mutated as we execute them, so
  // we keep iterating it until it is empty.
  while (!pending_finalizers.empty()) {
    v8impl::RefTracker* ref_tracker = *pending_finalizers.begin();
    pending_finalizers.erase(ref_tracker);
    ref_tracker->Finalize();
  }
}",45,,68,1,,void
132755,BLOCK,-1,,"{
    v8impl::RefTracker* ref_tracker = *pending_finalizers.begin();
    pending_finalizers.erase(ref_tracker);
    ref_tracker->Finalize();
  }",39,,72,2,,void
132777,BLOCK,-1,,"{
  v8::Local<v8::Message> local_msg =
      v8::Exception::CreateMessage(isolate, local_err);
  node::errors::TriggerUncaughtException(isolate, local_err, local_msg);
}",79,,79,2,,void
132809,BLOCK,-1,,"{
  CallIntoModule(call, [](napi_env env_, v8::Local<v8::Value> local_err) {
    node_napi_env__* env = static_cast<node_napi_env__*>(env_);
    if (env->terminatedOrTerminating()) {
      return;
    }
    node::Environment* node_env = env->node_env();
    if (!node_env->options()->force_node_api_uncaught_exceptions_policy &&
        !enforceUncaughtExceptionPolicy) {
      ProcessEmitDeprecationWarning(
          node_env,
          ""Uncaught N-API callback exception detected, please run node ""
          ""with option --force-node-api-uncaught-exceptions-policy=true""
          ""to handle those exceptions properly."",
          ""DEP0168"");
      return;
    }
    // If there was an unhandled exception in the complete callback,
    // report it as a fatal exception. (There is no JavaScript on the
    // callstack that can possibly handle it.)
    env->trigger_fatal_exception(local_err);
  });
}",52,,89,2,,void
132823,BLOCK,-1,,"{
    return new BufferFinalizer(
        env, finalize_callback, finalize_data, finalize_hint);
  }",62,,122,5,,void
132836,BLOCK,-1,,"{
    std::unique_ptr<BufferFinalizer, Deleter> finalizer{
        static_cast<BufferFinalizer*>(hint)};
    finalizer->finalize_data_ = data;

    // It is safe to call into JavaScript at this point.
    if (finalizer->finalize_callback_ == nullptr) return;
    finalizer->env_->CallFinalizer(finalizer->finalize_callback_,
                                   finalizer->finalize_data_,
                                   finalizer->finalize_hint_);
  }",62,,127,3,,void
132855,BLOCK,-1,,<empty>,51,,133,2,,void
132877,BLOCK,-1,,{ delete finalizer; },49,,140,2,,void
132887,BLOCK,-1,,"{
    env_->Ref();
  }",73,,148,5,,void
132895,BLOCK,-1,,{ env_->Unref(); },22,,152,1,,void
132906,BLOCK,-1,,"{
  std::string error_message;
  error_message += module_name;
  error_message += "" requires Node-API version "";
  error_message += std::to_string(module_api_version);
  error_message += "", but this version of Node.js only supports version "";
  error_message += NODE_STRINGIFY(NAPI_VERSION) "" add-ons."";
  node_env->ThrowError(error_message.c_str());
}",59,,157,4,,void
132927,BLOCK,1,,<empty>,,,,1,,void
132943,BLOCK,-1,,"{
  node_napi_env result;

  // Validate module_api_version.
  if (module_api_version < NODE_API_DEFAULT_MODULE_API_VERSION) {
    module_api_version = NODE_API_DEFAULT_MODULE_API_VERSION;
  } else if (module_api_version > NAPI_VERSION &&
             module_api_version != NAPI_VERSION_EXPERIMENTAL) {
    node::Environment* node_env = node::Environment::GetCurrent(context);
    CHECK_NOT_NULL(node_env);
    ThrowNodeApiVersionError(
        node_env, module_filename.c_str(), module_api_version);
    return nullptr;
  }

  result = new node_napi_env__(context, module_filename, module_api_version);
  // TODO(addaleax): There was previously code that tried to delete the
  // napi_env when its v8::Context was garbage collected;
  // However, as long as N-API addons using this napi_env are in place,
  // the Context needs to be accessible and alive.
  // Ideally, we'd want an on-addon-unload hook that takes care of this
  // once all N-API addons using this napi_env are unloaded.
  // Fo...",52,,169,4,,void
132949,BLOCK,1,,<empty>,,,,1,,void
132951,BLOCK,-1,,"{
    module_api_version = NODE_API_DEFAULT_MODULE_API_VERSION;
  }",65,,173,2,,void
132955,BLOCK,1,,<empty>,,,,1,,void
132958,BLOCK,-1,,<empty>,10,,175,1,,void
132964,BLOCK,1,,<empty>,,,,1,,void
132969,BLOCK,1,,<empty>,,,,1,,void
132971,BLOCK,-1,,"{
    node::Environment* node_env = node::Environment::GetCurrent(context);
    CHECK_NOT_NULL(node_env);
    ThrowNodeApiVersionError(
        node_env, module_filename.c_str(), module_api_version);
    return nullptr;
  }",63,,176,2,,void
133026,BLOCK,-1,,"{
    ref.Reset(env->isolate, func);
    node::AddEnvironmentCleanupHook(env->isolate, Cleanup, this);
    env->Ref();
  }",32,,223,11,,void
133051,BLOCK,-1,,"{
    node::RemoveEnvironmentCleanupHook(env->isolate, Cleanup, this);
    env->Unref();
  }",34,,229,1,,void
133070,BLOCK,-1,,"{
    node::Mutex::ScopedLock lock(this->mutex);

    while (queue.size() >= max_queue_size && max_queue_size > 0 &&
           !is_closing) {
      if (mode == napi_tsfn_nonblocking) {
        return napi_queue_full;
      }
      cond->Wait(lock);
    }

    if (is_closing) {
      if (thread_count == 0) {
        return napi_invalid_arg;
      } else {
        thread_count--;
        return napi_closing;
      }
    } else {
      queue.push(data);
      Send();
      return napi_ok;
    }
  }",73,,236,3,,void
133090,BLOCK,-1,,"{
      if (mode == napi_tsfn_nonblocking) {
        return napi_queue_full;
      }
      cond->Wait(lock);
    }",25,,240,2,,void
133095,BLOCK,-1,,"{
        return napi_queue_full;
      }",42,,241,2,,void
133105,BLOCK,-1,,"{
      if (thread_count == 0) {
        return napi_invalid_arg;
      } else {
        thread_count--;
        return napi_closing;
      }
    }",21,,247,2,,void
133110,BLOCK,-1,,"{
        return napi_invalid_arg;
      }",30,,248,2,,void
133114,BLOCK,-1,,"{
        thread_count--;
        return napi_closing;
      }",14,,250,1,,void
133120,BLOCK,-1,,"{
      queue.push(data);
      Send();
      return napi_ok;
    }",12,,254,1,,void
133132,BLOCK,-1,,"{
    node::Mutex::ScopedLock lock(this->mutex);

    if (is_closing) {
      return napi_closing;
    }

    thread_count++;

    return napi_ok;
  }",25,,261,1,,void
133140,BLOCK,-1,,"{
      return napi_closing;
    }",21,,264,2,,void
133151,BLOCK,-1,,"{
    node::Mutex::ScopedLock lock(this->mutex);

    if (thread_count == 0) {
      return napi_invalid_arg;
    }

    thread_count--;

    if (thread_count == 0 || mode == napi_tsfn_abort) {
      if (!is_closing) {
        is_closing = (mode == napi_tsfn_abort);
        if (is_closing && max_queue_size > 0) {
          cond->Signal(lock);
        }
        Send();
      }
    }

    return napi_ok;
  }",67,,273,2,,void
133161,BLOCK,-1,,"{
      return napi_invalid_arg;
    }",28,,276,2,,void
133174,BLOCK,-1,,"{
      if (!is_closing) {
        is_closing = (mode == napi_tsfn_abort);
        if (is_closing && max_queue_size > 0) {
          cond->Signal(lock);
        }
        Send();
      }
    }",55,,282,2,,void
133178,BLOCK,-1,,"{
        is_closing = (mode == napi_tsfn_abort);
        if (is_closing && max_queue_size > 0) {
          cond->Signal(lock);
        }
        Send();
      }",24,,283,2,,void
133190,BLOCK,-1,,"{
          cond->Signal(lock);
        }",47,,285,2,,void
133202,BLOCK,-1,,"{
    for (; !queue.empty(); queue.pop()) {
      call_js_cb(nullptr, nullptr, context, queue.front());
    }
    delete this;
  }",30,,295,1,,void
133204,BLOCK,-1,,<empty>,5,,296,1,,void
133214,BLOCK,4,,"{
      call_js_cb(nullptr, nullptr, context, queue.front());
    }",41,,296,4,,void
133228,BLOCK,-1,,"{
    ThreadSafeFunction* ts_fn = this;
    uv_loop_t* loop = env->node_env()->event_loop();

    if (uv_async_init(loop, &async, AsyncCb) == 0) {
      if (max_queue_size > 0) {
        cond = std::make_unique<node::ConditionVariable>();
      }
      if (max_queue_size == 0 || cond) {
        return napi_ok;
      }

      env->node_env()->CloseHandle(
          reinterpret_cast<uv_handle_t*>(&async),
          [](uv_handle_t* handle) -> void {
            ThreadSafeFunction* ts_fn =
                node::ContainerOf(&ThreadSafeFunction::async,
                                  reinterpret_cast<uv_async_t*>(handle));
            delete ts_fn;
          });

      // Prevent the thread-safe function from being deleted here, because
      // the callback above will delete it.
      ts_fn = nullptr;
    }

    delete ts_fn;

    return napi_generic_failure;
  }",22,,304,1,,void
133251,BLOCK,-1,,"{
      if (max_queue_size > 0) {
        cond = std::make_unique<node::ConditionVariable>();
      }
      if (max_queue_size == 0 || cond) {
        return napi_ok;
      }

      env->node_env()->CloseHandle(
          reinterpret_cast<uv_handle_t*>(&async),
          [](uv_handle_t* handle) -> void {
            ThreadSafeFunction* ts_fn =
                node::ContainerOf(&ThreadSafeFunction::async,
                                  reinterpret_cast<uv_async_t*>(handle));
            delete ts_fn;
          });

      // Prevent the thread-safe function from being deleted here, because
      // the callback above will delete it.
      ts_fn = nullptr;
    }",52,,308,2,,void
133256,BLOCK,-1,,"{
        cond = std::make_unique<node::ConditionVariable>();
      }",31,,309,2,,void
133269,BLOCK,-1,,"{
        return napi_ok;
      }",40,,312,2,,void
133294,BLOCK,-1,,"{
    uv_unref(reinterpret_cast<uv_handle_t*>(&async));

    return napi_ok;
  }",23,,335,1,,void
133305,BLOCK,-1,,"{
    uv_ref(reinterpret_cast<uv_handle_t*>(&async));

    return napi_ok;
  }",21,,341,1,,void
133316,BLOCK,-1,,{ return context; },26,,347,1,,void
133322,BLOCK,-1,,"{
    bool has_more = true;

    // Limit maximum synchronous iteration count to prevent event loop
    // starvation. See `src/node_messaging.cc` for an inspiration.
    unsigned int iterations_left = kMaxIterationCount;
    while (has_more && --iterations_left != 0) {
      dispatch_state = kDispatchRunning;
      has_more = DispatchOne();

      // Send() was called while we were executing the JS function
      if (dispatch_state.exchange(kDispatchIdle) != kDispatchRunning) {
        has_more = true;
      }
    }

    if (has_more) {
      Send();
    }
  }",19,,350,1,,void
133338,BLOCK,-1,,"{
      dispatch_state = kDispatchRunning;
      has_more = DispatchOne();

      // Send() was called while we were executing the JS function
      if (dispatch_state.exchange(kDispatchIdle) != kDispatchRunning) {
        has_more = true;
      }
    }",48,,356,2,,void
133353,BLOCK,-1,,"{
        has_more = true;
      }",71,,361,2,,void
133359,BLOCK,-1,,"{
      Send();
    }",19,,366,2,,void
133364,BLOCK,-1,,"{
    void* data = nullptr;
    bool popped_value = false;
    bool has_more = false;

    {
      node::Mutex::ScopedLock lock(this->mutex);
      if (is_closing) {
        CloseHandlesAndMaybeDelete();
      } else {
        size_t size = queue.size();
        if (size > 0) {
          data = queue.front();
          queue.pop();
          popped_value = true;
          if (size == max_queue_size && max_queue_size > 0) {
            cond->Signal(lock);
          }
          size--;
        }

        if (size == 0) {
          if (thread_count == 0) {
            is_closing = true;
            if (max_queue_size > 0) {
              cond->Signal(lock);
            }
            CloseHandlesAndMaybeDelete();
          }
        } else {
          has_more = true;
        }
      }
    }

    if (popped_value) {
      v8::HandleScope scope(env->isolate);
      CallbackScope cb_scope(this);
      napi_value js_callback = nullptr;
      if (!ref.IsEmpty()) {
        v8::Local<v8::Func...",22,,371,1,,void
133376,BLOCK,7,,"{
      node::Mutex::ScopedLock lock(this->mutex);
      if (is_closing) {
        CloseHandlesAndMaybeDelete();
      } else {
        size_t size = queue.size();
        if (size > 0) {
          data = queue.front();
          queue.pop();
          popped_value = true;
          if (size == max_queue_size && max_queue_size > 0) {
            cond->Signal(lock);
          }
          size--;
        }

        if (size == 0) {
          if (thread_count == 0) {
            is_closing = true;
            if (max_queue_size > 0) {
              cond->Signal(lock);
            }
            CloseHandlesAndMaybeDelete();
          }
        } else {
          has_more = true;
        }
      }
    }",5,,376,7,,void
133384,BLOCK,-1,,"{
        CloseHandlesAndMaybeDelete();
      }",23,,378,2,,void
133387,BLOCK,-1,,"{
        size_t size = queue.size();
        if (size > 0) {
          data = queue.front();
          queue.pop();
          popped_value = true;
          if (size == max_queue_size && max_queue_size > 0) {
            cond->Signal(lock);
          }
          size--;
        }

        if (size == 0) {
          if (thread_count == 0) {
            is_closing = true;
            if (max_queue_size > 0) {
              cond->Signal(lock);
            }
            CloseHandlesAndMaybeDelete();
          }
        } else {
          has_more = true;
        }
      }",14,,380,1,,void
133399,BLOCK,-1,,"{
          data = queue.front();
          queue.pop();
          popped_value = true;
          if (size == max_queue_size && max_queue_size > 0) {
            cond->Signal(lock);
          }
          size--;
        }",23,,382,2,,void
133421,BLOCK,-1,,"{
            cond->Signal(lock);
          }",61,,386,2,,void
133433,BLOCK,-1,,"{
          if (thread_count == 0) {
            is_closing = true;
            if (max_queue_size > 0) {
              cond->Signal(lock);
            }
            CloseHandlesAndMaybeDelete();
          }
        }",24,,392,2,,void
133438,BLOCK,-1,,"{
            is_closing = true;
            if (max_queue_size > 0) {
              cond->Signal(lock);
            }
            CloseHandlesAndMaybeDelete();
          }",34,,393,2,,void
133446,BLOCK,-1,,"{
              cond->Signal(lock);
            }",37,,395,2,,void
133454,BLOCK,-1,,"{
          has_more = true;
        }",16,,400,1,,void
133460,BLOCK,-1,,"{
      v8::HandleScope scope(env->isolate);
      CallbackScope cb_scope(this);
      napi_value js_callback = nullptr;
      if (!ref.IsEmpty()) {
        v8::Local<v8::Function> js_cb =
            v8::Local<v8::Function>::New(env->isolate, ref);
        js_callback = v8impl::JsValueFromV8LocalValue(js_cb);
      }
      env->CallbackIntoModule<false>(
          [&](napi_env env) { call_js_cb(env, js_callback, context, data); });
    }",23,,406,2,,void
133478,BLOCK,-1,,"{
        v8::Local<v8::Function> js_cb =
            v8::Local<v8::Function>::New(env->isolate, ref);
        js_callback = v8impl::JsValueFromV8LocalValue(js_cb);
      }",27,,410,2,,void
133522,BLOCK,-1,,"{
    v8::HandleScope scope(env->isolate);
    if (finalize_cb) {
      CallbackScope cb_scope(this);
      env->CallFinalizer<false>(finalize_cb, finalize_data, context);
    }
    EmptyQueueAndDelete();
  }",19,,422,1,,void
133530,BLOCK,-1,,"{
      CallbackScope cb_scope(this);
      env->CallFinalizer<false>(finalize_cb, finalize_data, context);
    }",22,,424,2,,void
133546,BLOCK,-1,,"{
    v8::HandleScope scope(env->isolate);
    if (set_closing) {
      node::Mutex::ScopedLock lock(this->mutex);
      is_closing = true;
      if (max_queue_size > 0) {
        cond->Signal(lock);
      }
    }
    if (handles_closing) {
      return;
    }
    handles_closing = true;
    env->node_env()->CloseHandle(
        reinterpret_cast<uv_handle_t*>(&async),
        [](uv_handle_t* handle) -> void {
          ThreadSafeFunction* ts_fn =
              node::ContainerOf(&ThreadSafeFunction::async,
                                reinterpret_cast<uv_async_t*>(handle));
          ts_fn->Finalize();
        });
  }",61,,431,2,,void
133554,BLOCK,-1,,"{
      node::Mutex::ScopedLock lock(this->mutex);
      is_closing = true;
      if (max_queue_size > 0) {
        cond->Signal(lock);
      }
    }",22,,433,2,,void
133567,BLOCK,-1,,"{
        cond->Signal(lock);
      }",31,,436,2,,void
133575,BLOCK,-1,,"{
      return;
    }",26,,440,2,,void
133595,BLOCK,-1,,"{
    // Ask currently running Dispatch() to make one more iteration
    unsigned char current_state = dispatch_state.fetch_or(kDispatchPending);
    if ((current_state & kDispatchRunning) == kDispatchRunning) {
      return;
    }

    CHECK_EQ(0, uv_async_send(&async));
  }",15,,454,1,,void
133610,BLOCK,-1,,"{
      return;
    }",65,,457,2,,void
133624,BLOCK,-1,,"{
    if (!(env == nullptr || cb == nullptr)) {
      napi_value recv;
      napi_status status;

      status = napi_get_undefined(env, &recv);
      if (status != napi_ok) {
        napi_throw_error(env,
                         ""ERR_NAPI_TSFN_GET_UNDEFINED"",
                         ""Failed to retrieve undefined value"");
        return;
      }

      status = napi_call_function(env, recv, cb, 0, nullptr, nullptr);
      if (status != napi_ok && status != napi_pending_exception) {
        napi_throw_error(
            env, ""ERR_NAPI_TSFN_CALL_JS"", ""Failed to call JS callback"");
        return;
      }
    }
  }",78,,466,5,,void
133634,BLOCK,-1,,"{
      napi_value recv;
      napi_status status;

      status = napi_get_undefined(env, &recv);
      if (status != napi_ok) {
        napi_throw_error(env,
                         ""ERR_NAPI_TSFN_GET_UNDEFINED"",
                         ""Failed to retrieve undefined value"");
        return;
      }

      status = napi_call_function(env, recv, cb, 0, nullptr, nullptr);
      if (status != napi_ok && status != napi_pending_exception) {
        napi_throw_error(
            env, ""ERR_NAPI_TSFN_CALL_JS"", ""Failed to call JS callback"");
        return;
      }
    }",45,,467,2,,void
133647,BLOCK,-1,,"{
        napi_throw_error(env,
                         ""ERR_NAPI_TSFN_GET_UNDEFINED"",
                         ""Failed to retrieve undefined value"");
        return;
      }",30,,472,2,,void
133670,BLOCK,-1,,"{
        napi_throw_error(
            env, ""ERR_NAPI_TSFN_CALL_JS"", ""Failed to call JS callback"");
        return;
      }",66,,480,2,,void
133680,BLOCK,-1,,"{
    ThreadSafeFunction* ts_fn =
        node::ContainerOf(&ThreadSafeFunction::async, async);
    ts_fn->Dispatch();
  }",42,,488,2,,void
133701,BLOCK,-1,,"{
    reinterpret_cast<ThreadSafeFunction*>(data)->CloseHandlesAndMaybeDelete(
        true);
  }",35,,494,2,,void
133731,BLOCK,-1,,<empty>,,,,1,,<empty>
133756,BLOCK,-1,,"{
    async_id_ = node_env()->new_async_id();
    trigger_async_id_ = node_env()->get_default_trigger_async_id();
    resource_.Reset(node_env()->isolate(), resource_object);
    lost_reference_ = false;
    if (externally_managed_resource) {
      resource_.SetWeak(
          this, AsyncContext::WeakCallback, v8::WeakCallbackType::kParameter);
    }

    node::AsyncWrap::EmitAsyncInit(node_env(),
                                   resource_object,
                                   resource_name,
                                   async_id_,
                                   trigger_async_id_);
  }",19,,541,5,,void
133783,BLOCK,-1,,"{
      resource_.SetWeak(
          this, AsyncContext::WeakCallback, v8::WeakCallbackType::kParameter);
    }",38,,546,2,,void
133811,BLOCK,-1,,"{
    resource_.Reset();
    lost_reference_ = true;
    node::AsyncWrap::EmitDestroy(node_env(), async_id_);
  }",19,,558,1,,void
133834,BLOCK,-1,,"{
    EnsureReference();
    return node::InternalMakeCallback(node_env(),
                                      resource(),
                                      recv,
                                      callback,
                                      argc,
                                      argv,
                                      {async_id_, trigger_async_id_});
  }",36,,568,5,,void
133853,BLOCK,-1,,"{
    EnsureReference();
    napi_callback_scope it =
        reinterpret_cast<napi_callback_scope>(new CallbackScope(this));
    env_->open_callback_scopes++;
    return it;
  }",50,,579,1,,void
133872,BLOCK,-1,,"{
    if (lost_reference_) {
      const v8::HandleScope handle_scope(node_env()->isolate());
      resource_.Reset(node_env()->isolate(),
                      v8::Object::New(node_env()->isolate()));
      lost_reference_ = false;
    }
  }",33,,587,1,,void
133875,BLOCK,-1,,"{
      const v8::HandleScope handle_scope(node_env()->isolate());
      resource_.Reset(node_env()->isolate(),
                      v8::Object::New(node_env()->isolate()));
      lost_reference_ = false;
    }",26,,588,2,,void
133906,BLOCK,-1,,{ return env_->node_env(); },40,,596,1,,void
133915,BLOCK,-1,,"{
    return resource_.Get(node_env()->isolate());
  }",43,,597,1,,void
133928,BLOCK,-1,,"{
    return {async_id_, trigger_async_id_};
  }",46,,600,1,,void
133935,BLOCK,-1,,"{
    CallbackScope* callback_scope = reinterpret_cast<CallbackScope*>(s);
    delete callback_scope;
    env->open_callback_scopes--;
  }",64,,605,3,,void
133952,BLOCK,-1,,"{
    AsyncContext* async_context = data.GetParameter();
    async_context->resource_.Reset();
    async_context->lost_reference_ = true;
  }",76,,611,2,,void
133976,BLOCK,-1,,<empty>,63,,624,2,,void
133989,BLOCK,-1,,"{
  napi_module_register_by_symbol(
      exports,
      module,
      context,
      static_cast<const napi_module*>(priv)->nm_register_func);
}",49,,644,5,,void
134006,BLOCK,-1,,"{
  napi_module_register_by_symbol(
      exports,
      module,
      context,
      reinterpret_cast<napi_addon_register_func>(priv),
      module_api_version);
}",56,,656,5,,void
134021,BLOCK,-1,,"{
  static_assert(
      NAPI_VERSION == 9,
      ""New version of Node-API requires adding another else-if statement below ""
      ""for the new version and updating this assert condition."");
  if (module_api_version <= NODE_API_DEFAULT_MODULE_API_VERSION) {
    return node_api_context_register_func<NODE_API_DEFAULT_MODULE_API_VERSION>;
  } else if (module_api_version == 9) {
    return node_api_context_register_func<9>;
  } else if (module_api_version == NAPI_VERSION_EXPERIMENTAL) {
    return node_api_context_register_func<NAPI_VERSION_EXPERIMENTAL>;
  } else {
    v8impl::ThrowNodeApiVersionError(node_env, module_name, module_api_version);
    return nullptr;
  }
}",33,,674,4,,void
134025,BLOCK,1,,<empty>,,,,1,,void
134033,BLOCK,1,,<empty>,,,,1,,void
134035,BLOCK,-1,,"{
    return node_api_context_register_func<NODE_API_DEFAULT_MODULE_API_VERSION>;
  }",66,,679,2,,void
134039,BLOCK,-1,,<empty>,10,,681,1,,void
134044,BLOCK,-1,,"{
    return node_api_context_register_func<9>;
  }",39,,681,2,,void
134048,BLOCK,-1,,<empty>,10,,683,1,,void
134053,BLOCK,1,,<empty>,,,,1,,void
134055,BLOCK,-1,,"{
    return node_api_context_register_func<NAPI_VERSION_EXPERIMENTAL>;
  }",63,,683,2,,void
134059,BLOCK,-1,,"{
    v8impl::ThrowNodeApiVersionError(node_env, module_name, module_api_version);
    return nullptr;
  }",10,,685,1,,void
134076,BLOCK,-1,,"{
  node::Environment* node_env = node::Environment::GetCurrent(context);
  std::string module_filename = """";
  if (init == nullptr) {
    CHECK_NOT_NULL(node_env);
    node_env->ThrowError(""Module has no declared entry point."");
    return;
  }

  // We set `env->filename` from `module.filename` here, but we could just as
  // easily add a private property to `exports` in `process.dlopen`, which
  // receives the file name from JS, and retrieve *that* here. Thus, we are not
  // endorsing commonjs here by making use of `module.filename`.
  v8::Local<v8::Value> filename_js;
  v8::Local<v8::Object> modobj;
  if (module->ToObject(context).ToLocal(&modobj) &&
      modobj->Get(context, node_env->filename_string()).ToLocal(&filename_js) &&
      filename_js->IsString()) {
    node::Utf8Value filename(node_env->isolate(), filename_js);

    // Turn the absolute path into a URL. Currently the absolute path is always
    // a file system path.
    // TODO(gabrielschulhof): Pass the `filena...",65,,695,6,,void
134095,BLOCK,-1,,"{
    CHECK_NOT_NULL(node_env);
    node_env->ThrowError(""Module has no declared entry point."");
    return;
  }",24,,698,2,,void
134153,BLOCK,-1,,"{
    node::Utf8Value filename(node_env->isolate(), filename_js);

    // Turn the absolute path into a URL. Currently the absolute path is always
    // a file system path.
    // TODO(gabrielschulhof): Pass the `filename` through unchanged if/when we
    // receive it as a URL already.
    module_filename = node::url::FromFilePath(filename.ToStringView());
  }",32,,712,2,,void
134202,BLOCK,-1,,"{
    napi_value _module = v8impl::JsValueFromV8LocalValue(module);
    napi_set_named_property(env, _module, ""exports"", _exports);
  }",61,,734,2,,void
134221,BLOCK,-1,,"{
  return {
      -1,
      mod->nm_flags | NM_F_DELETEME,
      nullptr,
      mod->nm_filename,
      nullptr,
      napi_module_register_cb,
      mod->nm_modname,
      const_cast<napi_module*>(mod),  // priv
      nullptr,
  };
}",64,,741,2,,void
134227,BLOCK,-1,,"{
  node::node_module* nm =
      new node::node_module(node::napi_module_to_node_module(mod));
  node::node_module_register(nm);
}",56,,757,2,,void
134249,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, fun);

  node::AddEnvironmentCleanupHook(env->isolate, fun, arg);

  return napi_ok;
}",61,,765,4,,void
134252,BLOCK,1,,<empty>,,,,2,,void
134254,BLOCK,-1,,CHECK_ENV(env),3,,766,1,,void
134259,BLOCK,-1,,CHECK_ENV(env),3,,766,2,,void
134266,BLOCK,1,,<empty>,,,,3,,void
134268,BLOCK,-1,,"CHECK_ARG(env, fun)",3,,767,1,,void
134274,BLOCK,-1,,"CHECK_ARG(env, fun)",3,,767,2,,void
134297,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, fun);

  node::RemoveEnvironmentCleanupHook(env->isolate, fun, arg);

  return napi_ok;
}",64,,776,4,,void
134300,BLOCK,1,,<empty>,,,,2,,void
134302,BLOCK,-1,,CHECK_ENV(env),3,,777,1,,void
134307,BLOCK,-1,,CHECK_ENV(env),3,,777,2,,void
134314,BLOCK,1,,<empty>,,,,3,,void
134316,BLOCK,-1,,"CHECK_ARG(env, fun)",3,,778,1,,void
134322,BLOCK,-1,,"CHECK_ARG(env, fun)",3,,778,2,,void
134345,BLOCK,-1,,"{
    handle_ = node::AddEnvironmentCleanupHook(env->isolate, Hook, this);
    env->Ref();
  }",65,,789,4,,void
134364,BLOCK,-1,,"{
    node::RemoveEnvironmentCleanupHook(std::move(handle_));
    if (done_cb_ != nullptr) done_cb_(done_data_);

    // Release the `env` handle asynchronously since it would be surprising if
    // a call to a N-API function would destroy `env` synchronously.
    static_cast<node_napi_env>(env_)->node_env()->SetImmediate(
        [env = env_](node::Environment*) { env->Unref(); });
  }",39,,794,1,,void
134378,BLOCK,-1,,<empty>,30,,796,2,,void
134397,BLOCK,-1,,"{
    napi_async_cleanup_hook_handle__* handle =
        static_cast<napi_async_cleanup_hook_handle__*>(data);
    handle->done_cb_ = done_cb;
    handle->done_data_ = done_data;
    handle->user_hook_(handle, handle->user_data_);
  }",73,,804,4,,void
134430,BLOCK,-1,,<empty>,,,,2,,<empty>
134435,BLOCK,-1,,<empty>,,,,1,,<empty>
134458,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, hook);

  napi_async_cleanup_hook_handle__* handle =
      new napi_async_cleanup_hook_handle__(env, hook, arg);

  if (remove_handle != nullptr) *remove_handle = handle;

  return napi_clear_last_error(env);
}",76,,824,5,,void
134461,BLOCK,1,,<empty>,,,,2,,void
134463,BLOCK,-1,,CHECK_ENV(env),3,,825,1,,void
134468,BLOCK,-1,,CHECK_ENV(env),3,,825,2,,void
134475,BLOCK,1,,<empty>,,,,3,,void
134477,BLOCK,-1,,"CHECK_ARG(env, hook)",3,,826,1,,void
134483,BLOCK,-1,,"CHECK_ARG(env, hook)",3,,826,2,,void
134501,BLOCK,-1,,<empty>,33,,831,2,,void
134513,BLOCK,-1,,"{
  if (remove_handle == nullptr) return napi_invalid_arg;

  delete remove_handle;

  return napi_ok;
}",78,,837,2,,void
134518,BLOCK,-1,,<empty>,33,,838,2,,void
134530,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, err);

  v8::Local<v8::Value> local_err = v8impl::V8LocalValueFromJsValue(err);
  static_cast<node_napi_env>(env)->trigger_fatal_exception(local_err);

  return napi_clear_last_error(env);
}",75,,845,3,,void
134533,BLOCK,1,,<empty>,,,,2,,void
134535,BLOCK,-1,,NAPI_PREAMBLE(env),3,,846,1,,void
134540,BLOCK,-1,,NAPI_PREAMBLE(env),3,,846,2,,void
134545,BLOCK,-1,,NAPI_PREAMBLE(env),3,,846,1,,void
134554,BLOCK,-1,,NAPI_PREAMBLE(env),3,,846,2,,void
134561,BLOCK,-1,,NAPI_PREAMBLE(env),3,,846,1,,void
134568,BLOCK,-1,,NAPI_PREAMBLE(env),3,,846,2,,void
134589,BLOCK,1,,<empty>,,,,3,,void
134591,BLOCK,-1,,"CHECK_ARG(env, err)",3,,847,1,,void
134597,BLOCK,-1,,"CHECK_ARG(env, err)",3,,847,2,,void
134635,BLOCK,-1,,"{
  std::string location_string;
  std::string message_string;

  if (location_len != NAPI_AUTO_LENGTH) {
    location_string.assign(const_cast<char*>(location), location_len);
  } else {
    location_string.assign(const_cast<char*>(location), strlen(location));
  }

  if (message_len != NAPI_AUTO_LENGTH) {
    message_string.assign(const_cast<char*>(message), message_len);
  } else {
    message_string.assign(const_cast<char*>(message), strlen(message));
  }

  node::OnFatalError(location_string.c_str(), message_string.c_str());
}",69,,858,5,,void
134642,BLOCK,1,,<empty>,,,,1,,void
134644,BLOCK,-1,,"{
    location_string.assign(const_cast<char*>(location), location_len);
  }",41,,862,2,,void
134654,BLOCK,-1,,"{
    location_string.assign(const_cast<char*>(location), strlen(location));
  }",10,,864,1,,void
134668,BLOCK,1,,<empty>,,,,1,,void
134670,BLOCK,-1,,"{
    message_string.assign(const_cast<char*>(message), message_len);
  }",40,,868,2,,void
134680,BLOCK,-1,,"{
    message_string.assign(const_cast<char*>(message), strlen(message));
  }",10,,870,1,,void
134709,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  v8impl::AsyncContext* node_async_context =
      reinterpret_cast<v8impl::AsyncContext*>(async_context_handle);

  *result = node_async_context->OpenCallbackScope();

  return napi_clear_last_error(env);
}",55,,881,5,,void
134712,BLOCK,1,,<empty>,,,,2,,void
134714,BLOCK,-1,,CHECK_ENV(env),3,,884,1,,void
134719,BLOCK,-1,,CHECK_ENV(env),3,,884,2,,void
134726,BLOCK,1,,<empty>,,,,3,,void
134728,BLOCK,-1,,"CHECK_ARG(env, result)",3,,885,1,,void
134734,BLOCK,-1,,"CHECK_ARG(env, result)",3,,885,2,,void
134761,BLOCK,-1,,"{
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, scope);
  if (env->open_callback_scopes == 0) {
    return napi_callback_scope_mismatch;
  }

  v8impl::AsyncContext::CloseCallbackScope(reinterpret_cast<node_napi_env>(env),
                                           scope);

  return napi_clear_last_error(env);
}",77,,896,3,,void
134764,BLOCK,1,,<empty>,,,,2,,void
134766,BLOCK,-1,,CHECK_ENV(env),3,,899,1,,void
134771,BLOCK,-1,,CHECK_ENV(env),3,,899,2,,void
134778,BLOCK,1,,<empty>,,,,3,,void
134780,BLOCK,-1,,"CHECK_ARG(env, scope)",3,,900,1,,void
134786,BLOCK,-1,,"CHECK_ARG(env, scope)",3,,900,2,,void
134798,BLOCK,-1,,"{
    return napi_callback_scope_mismatch;
  }",39,,901,2,,void
134821,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, async_resource_name);
  CHECK_ARG(env, result);

  v8::Isolate* isolate = env->isolate;
  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Object> v8_resource;
  bool externally_managed_resource;
  if (async_resource != nullptr) {
    CHECK_TO_OBJECT(env, context, v8_resource, async_resource);
    externally_managed_resource = true;
  } else {
    v8_resource = v8::Object::New(isolate);
    externally_managed_resource = false;
  }

  v8::Local<v8::String> v8_resource_name;
  CHECK_TO_STRING(env, context, v8_resource_name, async_resource_name);

  v8impl::AsyncContext* async_context =
      new v8impl::AsyncContext(reinterpret_cast<node_napi_env>(env),
                               v8_resource,
                               v8_resource_name,
                               externally_managed_resource);

  *result = reinterpret_cast<napi_async_context>(async_context);

  return napi_clear_last_error(env);
}",68,,914,5,,void
134824,BLOCK,1,,<empty>,,,,2,,void
134826,BLOCK,-1,,CHECK_ENV(env),3,,915,1,,void
134831,BLOCK,-1,,CHECK_ENV(env),3,,915,2,,void
134838,BLOCK,1,,<empty>,,,,3,,void
134840,BLOCK,-1,,"CHECK_ARG(env, async_resource_name)",3,,916,1,,void
134846,BLOCK,-1,,"CHECK_ARG(env, async_resource_name)",3,,916,2,,void
134855,BLOCK,1,,<empty>,,,,3,,void
134857,BLOCK,-1,,"CHECK_ARG(env, result)",3,,917,1,,void
134863,BLOCK,-1,,"CHECK_ARG(env, result)",3,,917,2,,void
134903,BLOCK,-1,,"{
    CHECK_TO_OBJECT(env, context, v8_resource, async_resource);
    externally_managed_resource = true;
  }",34,,924,2,,void
134910,BLOCK,1,,<empty>,,,,7,,void
134912,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, v8_resource, async_resource)",5,,925,1,,void
134914,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, v8_resource, async_resource)",5,,925,1,,void
134920,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, v8_resource, async_resource)",5,,925,2,,void
134939,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, v8_resource, async_resource)",5,,925,1,,void
134947,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, v8_resource, async_resource)",5,,925,2,,void
134964,BLOCK,-1,,"{
    v8_resource = v8::Object::New(isolate);
    externally_managed_resource = false;
  }",10,,927,1,,void
134992,BLOCK,1,,<empty>,,,,7,,void
134994,BLOCK,-1,,"CHECK_TO_STRING(env, context, v8_resource_name, async_resource_name)",3,,933,1,,void
134996,BLOCK,-1,,"CHECK_TO_STRING(env, context, v8_resource_name, async_resource_name)",3,,933,1,,void
135002,BLOCK,-1,,"CHECK_TO_STRING(env, context, v8_resource_name, async_resource_name)",3,,933,2,,void
135021,BLOCK,-1,,"CHECK_TO_STRING(env, context, v8_resource_name, async_resource_name)",3,,933,1,,void
135029,BLOCK,-1,,"CHECK_TO_STRING(env, context, v8_resource_name, async_resource_name)",3,,933,2,,void
135067,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, async_context);

  v8impl::AsyncContext* node_async_context =
      reinterpret_cast<v8impl::AsyncContext*>(async_context);

  delete node_async_context;

  return napi_clear_last_error(env);
}",77,,947,3,,void
135070,BLOCK,1,,<empty>,,,,2,,void
135072,BLOCK,-1,,CHECK_ENV(env),3,,948,1,,void
135077,BLOCK,-1,,CHECK_ENV(env),3,,948,2,,void
135084,BLOCK,1,,<empty>,,,,3,,void
135086,BLOCK,-1,,"CHECK_ARG(env, async_context)",3,,949,1,,void
135092,BLOCK,-1,,"CHECK_ARG(env, async_context)",3,,949,2,,void
135119,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, recv);
  if (argc > 0) {
    CHECK_ARG(env, argv);
  }

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Object> v8recv;
  CHECK_TO_OBJECT(env, context, v8recv, recv);

  v8::Local<v8::Function> v8func;
  CHECK_TO_FUNCTION(env, v8func, func);

  v8::MaybeLocal<v8::Value> callback_result;

  if (async_context == nullptr) {
    callback_result = node::MakeCallback(
        env->isolate,
        v8recv,
        v8func,
        argc,
        reinterpret_cast<v8::Local<v8::Value>*>(const_cast<napi_value*>(argv)),
        {0, 0});
  } else {
    v8impl::AsyncContext* node_async_context =
        reinterpret_cast<v8impl::AsyncContext*>(async_context);
    callback_result = node_async_context->MakeCallback(
        v8recv,
        v8func,
        argc,
        reinterpret_cast<v8::Local<v8::Value>*>(const_cast<napi_value*>(argv)));
  }

  if (try_catch.HasCaught()) {
    return napi_set_last_error(env, napi_pending_exception);
  } ...",63,,965,8,,void
135122,BLOCK,1,,<empty>,,,,2,,void
135124,BLOCK,-1,,NAPI_PREAMBLE(env),3,,966,1,,void
135129,BLOCK,-1,,NAPI_PREAMBLE(env),3,,966,2,,void
135134,BLOCK,-1,,NAPI_PREAMBLE(env),3,,966,1,,void
135143,BLOCK,-1,,NAPI_PREAMBLE(env),3,,966,2,,void
135150,BLOCK,-1,,NAPI_PREAMBLE(env),3,,966,1,,void
135157,BLOCK,-1,,NAPI_PREAMBLE(env),3,,966,2,,void
135178,BLOCK,1,,<empty>,,,,3,,void
135180,BLOCK,-1,,"CHECK_ARG(env, recv)",3,,967,1,,void
135186,BLOCK,-1,,"CHECK_ARG(env, recv)",3,,967,2,,void
135196,BLOCK,-1,,"{
    CHECK_ARG(env, argv);
  }",17,,968,2,,void
135200,BLOCK,1,,<empty>,,,,3,,void
135202,BLOCK,-1,,"CHECK_ARG(env, argv)",5,,969,1,,void
135208,BLOCK,-1,,"CHECK_ARG(env, argv)",5,,969,2,,void
135243,BLOCK,1,,<empty>,,,,7,,void
135245,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, v8recv, recv)",3,,975,1,,void
135247,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, v8recv, recv)",3,,975,1,,void
135253,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, v8recv, recv)",3,,975,2,,void
135272,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, v8recv, recv)",3,,975,1,,void
135280,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, v8recv, recv)",3,,975,2,,void
135306,BLOCK,1,,<empty>,,,,4,,void
135308,BLOCK,-1,,"CHECK_TO_FUNCTION(env, v8func, func)",3,,978,1,,void
135310,BLOCK,-1,,"CHECK_TO_FUNCTION(env, v8func, func)",3,,978,1,,void
135316,BLOCK,-1,,"CHECK_TO_FUNCTION(env, v8func, func)",3,,978,2,,void
135338,BLOCK,-1,,"CHECK_TO_FUNCTION(env, v8func, func)",3,,978,1,,void
135345,BLOCK,-1,,"CHECK_TO_FUNCTION(env, v8func, func)",3,,978,2,,void
135371,BLOCK,-1,,"{
    callback_result = node::MakeCallback(
        env->isolate,
        v8recv,
        v8func,
        argc,
        reinterpret_cast<v8::Local<v8::Value>*>(const_cast<napi_value*>(argv)),
        {0, 0});
  }",33,,982,2,,void
135393,BLOCK,-1,,"{
    v8impl::AsyncContext* node_async_context =
        reinterpret_cast<v8impl::AsyncContext*>(async_context);
    callback_result = node_async_context->MakeCallback(
        v8recv,
        v8func,
        argc,
        reinterpret_cast<v8::Local<v8::Value>*>(const_cast<napi_value*>(argv)));
  }",10,,990,1,,void
135419,BLOCK,-1,,"{
    return napi_set_last_error(env, napi_pending_exception);
  }",30,,1000,2,,void
135425,BLOCK,-1,,"{
    CHECK_MAYBE_EMPTY(env, callback_result, napi_generic_failure);
    if (result != nullptr) {
      *result =
          v8impl::JsValueFromV8LocalValue(callback_result.ToLocalChecked());
    }
  }",10,,1002,1,,void
135430,BLOCK,1,,<empty>,,,,4,,void
135432,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, callback_result, napi_generic_failure)",5,,1003,1,,void
135440,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, callback_result, napi_generic_failure)",5,,1003,2,,void
135450,BLOCK,-1,,"{
      *result =
          v8impl::JsValueFromV8LocalValue(callback_result.ToLocalChecked());
    }",28,,1004,2,,void
135465,BLOCK,1,,<empty>,,,,3,,void
135483,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::MaybeLocal<v8::Object> maybe = node::Buffer::New(env->isolate, length);

  CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure);

  v8::Local<v8::Object> buffer = maybe.ToLocalChecked();

  *result = v8impl::JsValueFromV8LocalValue(buffer);

  if (data != nullptr) {
    *data = node::Buffer::Data(buffer);
  }

  return GET_RETURN_STATUS(env);
}",63,,1016,5,,void
135486,BLOCK,1,,<empty>,,,,2,,void
135488,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1017,1,,void
135493,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1017,2,,void
135498,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1017,1,,void
135507,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1017,2,,void
135514,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1017,1,,void
135521,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1017,2,,void
135542,BLOCK,1,,<empty>,,,,3,,void
135544,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1018,1,,void
135550,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1018,2,,void
135580,BLOCK,1,,<empty>,,,,4,,void
135582,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure)",3,,1022,1,,void
135590,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure)",3,,1022,2,,void
135622,BLOCK,-1,,"{
    *data = node::Buffer::Data(buffer);
  }",24,,1028,2,,void
135636,BLOCK,1,,<empty>,,,,3,,void
135656,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

#if defined(V8_ENABLE_SANDBOX)
  return napi_set_last_error(env, napi_no_external_buffers_allowed);
#endif

  v8::Isolate* isolate = env->isolate;

  // The finalizer object will delete itself after invoking the callback.
  v8impl::BufferFinalizer* finalizer =
      v8impl::BufferFinalizer::New(env, finalize_cb, nullptr, finalize_hint);

  v8::MaybeLocal<v8::Object> maybe =
      node::Buffer::New(isolate,
                        static_cast<char*>(data),
                        length,
                        v8impl::BufferFinalizer::FinalizeBufferCallback,
                        finalizer);

  CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure);

  *result = v8impl::JsValueFromV8LocalValue(maybe.ToLocalChecked());
  return GET_RETURN_STATUS(env);
  // Tell coverity that 'finalizer' should not be freed when we return
  // as it will be deleted when the buffer to which it is associated
  // is finalized.
  // coverity[leaked_storag...",72,,1040,7,,void
135659,BLOCK,1,,<empty>,,,,2,,void
135661,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1041,1,,void
135666,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1041,2,,void
135671,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1041,1,,void
135680,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1041,2,,void
135687,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1041,1,,void
135694,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1041,2,,void
135715,BLOCK,1,,<empty>,,,,3,,void
135717,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1042,1,,void
135723,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1042,2,,void
135779,BLOCK,1,,<empty>,,,,4,,void
135781,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure)",3,,1061,1,,void
135789,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure)",3,,1061,2,,void
135809,BLOCK,1,,<empty>,,,,3,,void
135828,BLOCK,-1,,"{
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::MaybeLocal<v8::Object> maybe =
      node::Buffer::Copy(env->isolate, static_cast<const char*>(data), length);

  CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure);

  v8::Local<v8::Object> buffer = maybe.ToLocalChecked();
  *result = v8impl::JsValueFromV8LocalValue(buffer);

  if (result_data != nullptr) {
    *result_data = node::Buffer::Data(buffer);
  }

  return GET_RETURN_STATUS(env);
}",68,,1075,6,,void
135831,BLOCK,1,,<empty>,,,,2,,void
135833,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1076,1,,void
135838,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1076,2,,void
135843,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1076,1,,void
135852,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1076,2,,void
135859,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1076,1,,void
135866,BLOCK,-1,,NAPI_PREAMBLE(env),3,,1076,2,,void
135887,BLOCK,1,,<empty>,,,,3,,void
135889,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1077,1,,void
135895,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1077,2,,void
135928,BLOCK,1,,<empty>,,,,4,,void
135930,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure)",3,,1082,1,,void
135938,BLOCK,-1,,"CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure)",3,,1082,2,,void
135970,BLOCK,-1,,"{
    *result_data = node::Buffer::Data(buffer);
  }",31,,1087,2,,void
135984,BLOCK,1,,<empty>,,,,3,,void
136001,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  *result = node::Buffer::HasInstance(v8impl::V8LocalValueFromJsValue(value));
  return napi_clear_last_error(env);
}",53,,1096,4,,void
136004,BLOCK,1,,<empty>,,,,2,,void
136006,BLOCK,-1,,CHECK_ENV(env),3,,1097,1,,void
136011,BLOCK,-1,,CHECK_ENV(env),3,,1097,2,,void
136018,BLOCK,1,,<empty>,,,,3,,void
136020,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1098,1,,void
136026,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1098,2,,void
136035,BLOCK,1,,<empty>,,,,3,,void
136037,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1099,1,,void
136043,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1099,2,,void
136073,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, value);

  v8::Local<v8::Value> buffer = v8impl::V8LocalValueFromJsValue(value);

  if (data != nullptr) {
    *data = node::Buffer::Data(buffer);
  }
  if (length != nullptr) {
    *length = node::Buffer::Length(buffer);
  }

  return napi_clear_last_error(env);
}",61,,1108,5,,void
136076,BLOCK,1,,<empty>,,,,2,,void
136078,BLOCK,-1,,CHECK_ENV(env),3,,1109,1,,void
136083,BLOCK,-1,,CHECK_ENV(env),3,,1109,2,,void
136090,BLOCK,1,,<empty>,,,,3,,void
136092,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1110,1,,void
136098,BLOCK,-1,,"CHECK_ARG(env, value)",3,,1110,2,,void
136123,BLOCK,-1,,"{
    *data = node::Buffer::Data(buffer);
  }",24,,1114,2,,void
136138,BLOCK,-1,,"{
    *length = node::Buffer::Length(buffer);
  }",26,,1117,2,,void
136157,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);
  static const napi_node_version version = {
      NODE_MAJOR_VERSION, NODE_MINOR_VERSION, NODE_PATCH_VERSION, NODE_RELEASE};
  *result = &version;
  return napi_clear_last_error(env);
}",80,,1125,3,,void
136160,BLOCK,1,,<empty>,,,,2,,void
136162,BLOCK,-1,,CHECK_ENV(env),3,,1126,1,,void
136167,BLOCK,-1,,CHECK_ENV(env),3,,1126,2,,void
136174,BLOCK,1,,<empty>,,,,3,,void
136176,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1127,1,,void
136182,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1127,2,,void
136193,BLOCK,1,,<empty>,,,,1,,void
136196,BLOCK,1,,<empty>,,,,1,,void
136199,BLOCK,1,,<empty>,,,,1,,void
136202,BLOCK,1,,<empty>,,,,1,,void
136218,BLOCK,-1,,"{
  switch (code) {
    case 0:
      return napi_ok;
    case UV_EINVAL:
      return napi_invalid_arg;
    case UV_ECANCELED:
      return napi_cancelled;
    default:
      return napi_generic_failure;
  }
}",49,,1137,2,,void
136221,BLOCK,-1,,"{
    case 0:
      return napi_ok;
    case UV_EINVAL:
      return napi_invalid_arg;
    case UV_ECANCELED:
      return napi_cancelled;
    default:
      return napi_generic_failure;
  }",17,,1138,2,,void
136246,BLOCK,-1,,<empty>,29,,1167,7,,void
136250,BLOCK,-1,,<empty>,,,,1,,<empty>
136260,BLOCK,-1,,"{
    return new Work(
        env, async_resource, async_resource_name, execute, complete, data);
  }",32,,1177,7,,void
136274,BLOCK,-1,,{ delete work; },34,,1182,2,,void
136280,BLOCK,-1,,"{ _execute(_env, _data); }",36,,1184,1,,void
136287,BLOCK,-1,,"{
    if (_complete == nullptr) return;

    // Establish a handle scope here so that every callback doesn't have to.
    // Also it is needed for the exception-handling below.
    v8::HandleScope scope(_env->isolate);

    CallbackScope callback_scope(this);

    _env->CallbackIntoModule<true>([&](napi_env env) {
      _complete(env, ConvertUVErrorCode(status), _data);
    });

    // Note: Don't access `work` after this point because it was
    // likely deleted by the complete callback.
  }",49,,1186,2,,void
136292,BLOCK,-1,,<empty>,31,,1187,2,,void
136321,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, execute);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Object> resource;
  if (async_resource != nullptr) {
    CHECK_TO_OBJECT(env, context, resource, async_resource);
  } else {
    resource = v8::Object::New(env->isolate);
  }

  v8::Local<v8::String> resource_name;
  CHECK_TO_STRING(env, context, resource_name, async_resource_name);

  uvimpl::Work* work = uvimpl::Work::New(reinterpret_cast<node_napi_env>(env),
                                         resource,
                                         resource_name,
                                         execute,
                                         complete,
                                         data);

  *result = reinterpret_cast<napi_async_work>(work);

  return napi_clear_last_error(env);
}",49,,1229,8,,void
136324,BLOCK,1,,<empty>,,,,2,,void
136326,BLOCK,-1,,CHECK_ENV(env),3,,1230,1,,void
136331,BLOCK,-1,,CHECK_ENV(env),3,,1230,2,,void
136338,BLOCK,1,,<empty>,,,,3,,void
136340,BLOCK,-1,,"CHECK_ARG(env, execute)",3,,1231,1,,void
136346,BLOCK,-1,,"CHECK_ARG(env, execute)",3,,1231,2,,void
136355,BLOCK,1,,<empty>,,,,3,,void
136357,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1232,1,,void
136363,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1232,2,,void
136396,BLOCK,-1,,"{
    CHECK_TO_OBJECT(env, context, resource, async_resource);
  }",34,,1237,2,,void
136403,BLOCK,1,,<empty>,,,,7,,void
136405,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, resource, async_resource)",5,,1238,1,,void
136407,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, resource, async_resource)",5,,1238,1,,void
136413,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, resource, async_resource)",5,,1238,2,,void
136432,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, resource, async_resource)",5,,1238,1,,void
136440,BLOCK,-1,,"CHECK_TO_OBJECT(env, context, resource, async_resource)",5,,1238,2,,void
136454,BLOCK,-1,,"{
    resource = v8::Object::New(env->isolate);
  }",10,,1239,1,,void
136481,BLOCK,1,,<empty>,,,,7,,void
136483,BLOCK,-1,,"CHECK_TO_STRING(env, context, resource_name, async_resource_name)",3,,1244,1,,void
136485,BLOCK,-1,,"CHECK_TO_STRING(env, context, resource_name, async_resource_name)",3,,1244,1,,void
136491,BLOCK,-1,,"CHECK_TO_STRING(env, context, resource_name, async_resource_name)",3,,1244,2,,void
136510,BLOCK,-1,,"CHECK_TO_STRING(env, context, resource_name, async_resource_name)",3,,1244,1,,void
136518,BLOCK,-1,,"CHECK_TO_STRING(env, context, resource_name, async_resource_name)",3,,1244,2,,void
136562,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, work);

  uvimpl::Work::Delete(reinterpret_cast<uvimpl::Work*>(work));

  return napi_clear_last_error(env);
}",69,,1259,3,,void
136565,BLOCK,1,,<empty>,,,,2,,void
136567,BLOCK,-1,,CHECK_ENV(env),3,,1260,1,,void
136572,BLOCK,-1,,CHECK_ENV(env),3,,1260,2,,void
136579,BLOCK,1,,<empty>,,,,3,,void
136581,BLOCK,-1,,"CHECK_ARG(env, work)",3,,1261,1,,void
136587,BLOCK,-1,,"CHECK_ARG(env, work)",3,,1261,2,,void
136610,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, loop);
  *loop = reinterpret_cast<node_napi_env>(env)->node_env()->event_loop();
  return napi_clear_last_error(env);
}",79,,1268,3,,void
136613,BLOCK,1,,<empty>,,,,2,,void
136615,BLOCK,-1,,CHECK_ENV(env),3,,1269,1,,void
136620,BLOCK,-1,,CHECK_ENV(env),3,,1269,2,,void
136627,BLOCK,1,,<empty>,,,,3,,void
136629,BLOCK,-1,,"CHECK_ARG(env, loop)",3,,1270,1,,void
136635,BLOCK,-1,,"CHECK_ARG(env, loop)",3,,1270,2,,void
136661,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, work);

  uv_loop_t* event_loop = nullptr;
  STATUS_CALL(napi_get_uv_event_loop(env, &event_loop));

  uvimpl::Work* w = reinterpret_cast<uvimpl::Work*>(work);

  w->ScheduleWork();

  return napi_clear_last_error(env);
}",68,,1276,3,,void
136664,BLOCK,1,,<empty>,,,,2,,void
136666,BLOCK,-1,,CHECK_ENV(env),3,,1277,1,,void
136671,BLOCK,-1,,CHECK_ENV(env),3,,1277,2,,void
136678,BLOCK,1,,<empty>,,,,3,,void
136680,BLOCK,-1,,"CHECK_ARG(env, work)",3,,1278,1,,void
136686,BLOCK,-1,,"CHECK_ARG(env, work)",3,,1278,2,,void
136698,BLOCK,1,,<empty>,,,,4,,void
136700,BLOCK,-1,,"STATUS_CALL(napi_get_uv_event_loop(env, &event_loop))",3,,1281,1,,void
136712,BLOCK,-1,,<empty>,3,,1281,2,,void
136734,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, work);

  uvimpl::Work* w = reinterpret_cast<uvimpl::Work*>(work);

  CALL_UV(env, w->CancelWork());

  return napi_clear_last_error(env);
}",69,,1291,3,,void
136737,BLOCK,1,,<empty>,,,,2,,void
136739,BLOCK,-1,,CHECK_ENV(env),3,,1292,1,,void
136744,BLOCK,-1,,CHECK_ENV(env),3,,1292,2,,void
136751,BLOCK,1,,<empty>,,,,3,,void
136753,BLOCK,-1,,"CHECK_ARG(env, work)",3,,1293,1,,void
136759,BLOCK,-1,,"CHECK_ARG(env, work)",3,,1293,2,,void
136779,BLOCK,1,,<empty>,,,,8,,void
136781,BLOCK,-1,,"CALL_UV(env, w->CancelWork())",3,,1297,1,,void
136801,BLOCK,-1,,"CALL_UV(env, w->CancelWork())",3,,1297,2,,void
136825,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, async_resource_name);
  RETURN_STATUS_IF_FALSE(env, initial_thread_count > 0, napi_invalid_arg);
  CHECK_ARG(env, result);

  napi_status status = napi_ok;

  v8::Local<v8::Function> v8_func;
  if (func == nullptr) {
    CHECK_ARG(env, call_js_cb);
  } else {
    CHECK_TO_FUNCTION(env, v8_func, func);
  }

  v8::Local<v8::Context> v8_context = env->context();

  v8::Local<v8::Object> v8_resource;
  if (async_resource == nullptr) {
    v8_resource = v8::Object::New(env->isolate);
  } else {
    CHECK_TO_OBJECT(env, v8_context, v8_resource, async_resource);
  }

  v8::Local<v8::String> v8_name;
  CHECK_TO_STRING(env, v8_context, v8_name, async_resource_name);

  v8impl::ThreadSafeFunction* ts_fn =
      new v8impl::ThreadSafeFunction(v8_func,
                                     v8_resource,
                                     v8_name,
                                     initial_thread_count,
                                     context,
        ...",67,,1313,12,,void
136828,BLOCK,1,,<empty>,,,,2,,void
136830,BLOCK,-1,,CHECK_ENV(env),3,,1314,1,,void
136835,BLOCK,-1,,CHECK_ENV(env),3,,1314,2,,void
136842,BLOCK,1,,<empty>,,,,3,,void
136844,BLOCK,-1,,"CHECK_ARG(env, async_resource_name)",3,,1315,1,,void
136850,BLOCK,-1,,"CHECK_ARG(env, async_resource_name)",3,,1315,2,,void
136859,BLOCK,1,,<empty>,,,,3,,void
136861,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, initial_thread_count > 0, napi_invalid_arg)",3,,1316,1,,void
136867,BLOCK,-1,,"RETURN_STATUS_IF_FALSE(env, initial_thread_count > 0, napi_invalid_arg)",3,,1316,2,,void
136876,BLOCK,1,,<empty>,,,,3,,void
136878,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1317,1,,void
136884,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1317,2,,void
136907,BLOCK,-1,,"{
    CHECK_ARG(env, call_js_cb);
  }",24,,1322,2,,void
136911,BLOCK,1,,<empty>,,,,3,,void
136913,BLOCK,-1,,"CHECK_ARG(env, call_js_cb)",5,,1323,1,,void
136919,BLOCK,-1,,"CHECK_ARG(env, call_js_cb)",5,,1323,2,,void
136926,BLOCK,-1,,"{
    CHECK_TO_FUNCTION(env, v8_func, func);
  }",10,,1324,1,,void
136931,BLOCK,1,,<empty>,,,,4,,void
136933,BLOCK,-1,,"CHECK_TO_FUNCTION(env, v8_func, func)",5,,1325,1,,void
136935,BLOCK,-1,,"CHECK_TO_FUNCTION(env, v8_func, func)",5,,1325,1,,void
136941,BLOCK,-1,,"CHECK_TO_FUNCTION(env, v8_func, func)",5,,1325,2,,void
136963,BLOCK,-1,,"CHECK_TO_FUNCTION(env, v8_func, func)",5,,1325,1,,void
136970,BLOCK,-1,,"CHECK_TO_FUNCTION(env, v8_func, func)",5,,1325,2,,void
137010,BLOCK,-1,,"{
    v8_resource = v8::Object::New(env->isolate);
  }",34,,1331,2,,void
137023,BLOCK,-1,,"{
    CHECK_TO_OBJECT(env, v8_context, v8_resource, async_resource);
  }",10,,1333,1,,void
137030,BLOCK,1,,<empty>,,,,7,,void
137032,BLOCK,-1,,"CHECK_TO_OBJECT(env, v8_context, v8_resource, async_resource)",5,,1334,1,,void
137034,BLOCK,-1,,"CHECK_TO_OBJECT(env, v8_context, v8_resource, async_resource)",5,,1334,1,,void
137040,BLOCK,-1,,"CHECK_TO_OBJECT(env, v8_context, v8_resource, async_resource)",5,,1334,2,,void
137059,BLOCK,-1,,"CHECK_TO_OBJECT(env, v8_context, v8_resource, async_resource)",5,,1334,1,,void
137067,BLOCK,-1,,"CHECK_TO_OBJECT(env, v8_context, v8_resource, async_resource)",5,,1334,2,,void
137095,BLOCK,1,,<empty>,,,,7,,void
137097,BLOCK,-1,,"CHECK_TO_STRING(env, v8_context, v8_name, async_resource_name)",3,,1338,1,,void
137099,BLOCK,-1,,"CHECK_TO_STRING(env, v8_context, v8_name, async_resource_name)",3,,1338,1,,void
137105,BLOCK,-1,,"CHECK_TO_STRING(env, v8_context, v8_name, async_resource_name)",3,,1338,2,,void
137124,BLOCK,-1,,"CHECK_TO_STRING(env, v8_context, v8_name, async_resource_name)",3,,1338,1,,void
137132,BLOCK,-1,,"CHECK_TO_STRING(env, v8_context, v8_name, async_resource_name)",3,,1338,2,,void
137166,BLOCK,-1,,"{
    status = napi_generic_failure;
  }",25,,1352,2,,void
137171,BLOCK,-1,,"{
    // Init deletes ts_fn upon failure.
    status = ts_fn->Init();
    if (status == napi_ok) {
      *result = reinterpret_cast<napi_threadsafe_function>(ts_fn);
    }
  }",10,,1354,1,,void
137182,BLOCK,-1,,"{
      *result = reinterpret_cast<napi_threadsafe_function>(ts_fn);
    }",28,,1357,2,,void
137198,BLOCK,-1,,"{
  CHECK_NOT_NULL(func);
  CHECK_NOT_NULL(result);

  *result = reinterpret_cast<v8impl::ThreadSafeFunction*>(func)->Context();
  return napi_ok;
}",51,,1366,3,,void
137220,BLOCK,-1,,"{
  CHECK_NOT_NULL(func);
  return reinterpret_cast<v8impl::ThreadSafeFunction*>(func)->Push(data,
                                                                   is_blocking);
}",79,,1377,4,,void
137236,BLOCK,-1,,"{
  CHECK_NOT_NULL(func);
  return reinterpret_cast<v8impl::ThreadSafeFunction*>(func)->Acquire();
}",65,,1384,2,,void
137251,BLOCK,-1,,"{
  CHECK_NOT_NULL(func);
  return reinterpret_cast<v8impl::ThreadSafeFunction*>(func)->Release(mode);
}",80,,1390,3,,void
137267,BLOCK,-1,,"{
  CHECK_NOT_NULL(func);
  return reinterpret_cast<v8impl::ThreadSafeFunction*>(func)->Unref();
}",77,,1396,3,,void
137282,BLOCK,-1,,"{
  CHECK_NOT_NULL(func);
  return reinterpret_cast<v8impl::ThreadSafeFunction*>(func)->Ref();
}",75,,1402,3,,void
137297,BLOCK,-1,,"{
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = static_cast<node_napi_env>(env)->GetFilename();
  return napi_clear_last_error(env);
}",75,,1408,3,,void
137300,BLOCK,1,,<empty>,,,,2,,void
137302,BLOCK,-1,,CHECK_ENV(env),3,,1409,1,,void
137307,BLOCK,-1,,CHECK_ENV(env),3,,1409,2,,void
137314,BLOCK,1,,<empty>,,,,3,,void
137316,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1410,1,,void
137322,BLOCK,-1,,"CHECK_ARG(env, result)",3,,1410,2,,void
137350,BLOCK,-1,,<empty>,1,,1,1,,ANY
137355,BLOCK,-1,,<empty>,,,,3,,<empty>
137359,BLOCK,-1,,<empty>,,,,1,,<empty>
137371,BLOCK,-1,,<empty>,,,,1,,<empty>
137379,BLOCK,-1,,<empty>,,,,2,,<empty>
137387,BLOCK,-1,,<empty>,,,,5,,<empty>
137395,BLOCK,-1,,<empty>,,,,5,,<empty>
137401,BLOCK,-1,,<empty>,,,,3,,<empty>
137412,BLOCK,-1,,<empty>,,,,8,,<empty>
137420,BLOCK,-1,,<empty>,,,,5,,<empty>
137430,BLOCK,-1,,<empty>,,,,7,,<empty>
137439,BLOCK,-1,,<empty>,,,,6,,<empty>
137446,BLOCK,-1,,<empty>,,,,4,,<empty>
137454,BLOCK,-1,,<empty>,,,,5,,<empty>
137465,BLOCK,-1,,<empty>,,,,8,,<empty>
137471,BLOCK,-1,,<empty>,,,,3,,<empty>
137477,BLOCK,-1,,<empty>,,,,3,,<empty>
137483,BLOCK,-1,,<empty>,,,,3,,<empty>
137489,BLOCK,-1,,<empty>,,,,3,,<empty>
137495,BLOCK,-1,,<empty>,,,,3,,<empty>
137501,BLOCK,-1,,<empty>,,,,3,,<empty>
137508,BLOCK,-1,,<empty>,,,,4,,<empty>
137515,BLOCK,-1,,<empty>,,,,4,,<empty>
137523,BLOCK,-1,,<empty>,,,,5,,<empty>
137529,BLOCK,-1,,<empty>,,,,3,,<empty>
137544,BLOCK,-1,,<empty>,,,,12,,<empty>
137550,BLOCK,-1,,<empty>,,,,3,,<empty>
137557,BLOCK,-1,,<empty>,,,,4,,<empty>
137562,BLOCK,-1,,<empty>,,,,2,,<empty>
137568,BLOCK,-1,,<empty>,,,,3,,<empty>
137574,BLOCK,-1,,<empty>,,,,3,,<empty>
137580,BLOCK,-1,,<empty>,,,,3,,<empty>
137588,BLOCK,-1,,<empty>,,,,5,,<empty>
137593,BLOCK,-1,,<empty>,,,,2,,<empty>
137610,BLOCK,-1,,<empty>,1,,1,1,,ANY
137616,BLOCK,-1,,<empty>,,,,4,,<empty>
137620,BLOCK,-1,,<empty>,,,,1,,<empty>
137627,BLOCK,-1,,<empty>,,,,4,,<empty>
137634,BLOCK,-1,,<empty>,,,,4,,<empty>
137639,BLOCK,-1,,<empty>,,,,2,,<empty>
137643,BLOCK,-1,,<empty>,,,,1,,<empty>
137648,BLOCK,-1,,<empty>,,,,2,,<empty>
137653,BLOCK,-1,,<empty>,,,,2,,<empty>
137657,BLOCK,-1,,<empty>,,,,1,,<empty>
137661,BLOCK,-1,,"{
    return node::Environment::GetCurrent(context());
  }",46,,30,1,,void
137673,BLOCK,-1,,{ return filename.c_str(); },42,,33,1,,void
137685,BLOCK,-1,,<empty>,,,,1,,<empty>
137701,BLOCK,-1,,<empty>,1,,1,1,,ANY
137711,BLOCK,-1,,<empty>,,,,3,,<empty>
137718,BLOCK,-1,,<empty>,,,,4,,<empty>
137730,BLOCK,-1,,"{
    static Mutex dlib_load_mutex;
    Mutex::ScopedLock lock(dlib_load_mutex);

    const bool is_opened = dlib->Open();

    // Objects containing v14 or later modules will have registered themselves
    // on the pending list.  Activate all of them now.  At present, only one
    // module per object is supported.
    node_module* mp = thread_local_modpending;
    thread_local_modpending = nullptr;

    if (!is_opened) {
      std::string errmsg = dlib->errmsg_.c_str();
      dlib->Close();
#ifdef _WIN32
      // Windows needs to add the filename into the error message
      errmsg += *filename;
#endif  // _WIN32
      THROW_ERR_DLOPEN_FAILED(env, ""%s"", errmsg.c_str());
      return false;
    }

    if (mp != nullptr) {
      if (mp->nm_context_register_func == nullptr) {
        if (env->force_context_aware()) {
          dlib->Close();
          THROW_ERR_NON_CONTEXT_AWARE_DISABLED(env);
          return false;
        }
      }
      mp->nm_dso_handle = dlib->handle_;
      d...",55,,456,2,,void
137752,BLOCK,-1,,"{
      std::string errmsg = dlib->errmsg_.c_str();
      dlib->Close();
#ifdef _WIN32
      // Windows needs to add the filename into the error message
      errmsg += *filename;
#endif  // _WIN32
      THROW_ERR_DLOPEN_FAILED(env, ""%s"", errmsg.c_str());
      return false;
    }",21,,468,2,,void
137779,BLOCK,-1,,"{
      if (mp->nm_context_register_func == nullptr) {
        if (env->force_context_aware()) {
          dlib->Close();
          THROW_ERR_NON_CONTEXT_AWARE_DISABLED(env);
          return false;
        }
      }
      mp->nm_dso_handle = dlib->handle_;
      dlib->SaveInGlobalHandleMap(mp);
    }",24,,479,2,,void
137786,BLOCK,-1,,"{
        if (env->force_context_aware()) {
          dlib->Close();
          THROW_ERR_NON_CONTEXT_AWARE_DISABLED(env);
          return false;
        }
      }",52,,480,2,,void
137792,BLOCK,-1,,"{
          dlib->Close();
          THROW_ERR_NON_CONTEXT_AWARE_DISABLED(env);
          return false;
        }",41,,481,2,,void
137814,BLOCK,-1,,"{
      if (auto callback = GetInitializerCallback(dlib)) {
        callback(exports, module, context);
        return true;
      } else if (auto napi_callback = GetNapiInitializerCallback(dlib)) {
        int32_t module_api_version = NODE_API_DEFAULT_MODULE_API_VERSION;
        if (auto get_version = GetNapiAddonGetApiVersionCallback(dlib)) {
          module_api_version = get_version();
        }
        napi_module_register_by_symbol(
            exports, module, context, napi_callback, module_api_version);
        return true;
      } else {
        mp = dlib->GetSavedModuleFromGlobalHandleMap();
        if (mp == nullptr || mp->nm_context_register_func == nullptr) {
          dlib->Close();
          THROW_ERR_DLOPEN_FAILED(
              env, ""Module did not self-register: '%s'."", *filename);
          return false;
        }
      }
    }",12,,489,1,,void
137816,BLOCK,-1,,<empty>,11,,490,1,,void
137822,BLOCK,-1,,"{
        callback(exports, module, context);
        return true;
      }",57,,490,2,,void
137830,BLOCK,-1,,<empty>,14,,493,1,,void
137832,BLOCK,-1,,<empty>,18,,493,1,,void
137838,BLOCK,-1,,"{
        int32_t module_api_version = NODE_API_DEFAULT_MODULE_API_VERSION;
        if (auto get_version = GetNapiAddonGetApiVersionCallback(dlib)) {
          module_api_version = get_version();
        }
        napi_module_register_by_symbol(
            exports, module, context, napi_callback, module_api_version);
        return true;
      }",73,,493,2,,void
137844,BLOCK,-1,,<empty>,13,,495,1,,void
137850,BLOCK,-1,,"{
          module_api_version = get_version();
        }",73,,495,2,,void
137863,BLOCK,-1,,"{
        mp = dlib->GetSavedModuleFromGlobalHandleMap();
        if (mp == nullptr || mp->nm_context_register_func == nullptr) {
          dlib->Close();
          THROW_ERR_DLOPEN_FAILED(
              env, ""Module did not self-register: '%s'."", *filename);
          return false;
        }
      }",14,,501,1,,void
137880,BLOCK,-1,,"{
          dlib->Close();
          THROW_ERR_DLOPEN_FAILED(
              env, ""Module did not self-register: '%s'."", *filename);
          return false;
        }",71,,503,2,,void
137905,BLOCK,-1,,"{
      // Even if the module did self-register, it may have done so with the
      // wrong version. We must only give up after having checked to see if it
      // has an appropriate initializer callback.
      if (auto callback = GetInitializerCallback(dlib)) {
        callback(exports, module, context);
        return true;
      }

      const int actual_nm_version = mp->nm_version;
      // NOTE: `mp` is allocated inside of the shared library's memory, calling
      // `dlclose` will deallocate it
      dlib->Close();
      THROW_ERR_DLOPEN_FAILED(
          env,
          ""The module '%s'""
          ""\nwas compiled against a different Node.js version using""
          ""\nNODE_MODULE_VERSION %d. This version of Node.js requires""
          ""\nNODE_MODULE_VERSION %d. Please try re-compiling or ""
          ""re-installing\nthe module (for instance, using `npm rebuild` ""
          ""or `npm install`)."",
          *filename,
          actual_nm_version,
          NODE_MODULE_VERSION);...",76,,513,2,,void
137907,BLOCK,-1,,<empty>,11,,517,1,,void
137913,BLOCK,-1,,"{
        callback(exports, module, context);
        return true;
      }",57,,517,2,,void
137955,BLOCK,-1,,"{
      mp->nm_context_register_func(exports, module, context, mp->nm_priv);
    }",50,,543,2,,void
137967,BLOCK,-1,,<empty>,12,,545,1,,void
137974,BLOCK,-1,,"{
      mp->nm_register_func(exports, module, mp->nm_priv);
    }",49,,545,2,,void
137985,BLOCK,-1,,"{
      dlib->Close();
      THROW_ERR_DLOPEN_FAILED(env, ""Module has no declared entry point."");
      return false;
    }",12,,547,1,,void
138023,BLOCK,-1,,<empty>,1,,1,1,,ANY
138025,BLOCK,-1,,<empty>,,,,1,,<empty>
138029,BLOCK,-1,,<empty>,,,,1,,<empty>
138033,BLOCK,-1,,<empty>,,,,1,,<empty>
138037,BLOCK,-1,,<empty>,,,,1,,<empty>
138041,BLOCK,-1,,<empty>,,,,1,,<empty>
138045,BLOCK,-1,,<empty>,,,,1,,<empty>
138049,BLOCK,-1,,<empty>,,,,1,,<empty>
138053,BLOCK,-1,,<empty>,,,,1,,<empty>
138057,BLOCK,-1,,<empty>,,,,1,,<empty>
138061,BLOCK,-1,,<empty>,,,,1,,<empty>
138065,BLOCK,-1,,<empty>,,,,1,,<empty>
138069,BLOCK,-1,,<empty>,,,,1,,<empty>
138073,BLOCK,-1,,<empty>,,,,1,,<empty>
138077,BLOCK,-1,,<empty>,,,,1,,<empty>
138081,BLOCK,-1,,<empty>,,,,1,,<empty>
138085,BLOCK,-1,,<empty>,,,,1,,<empty>
138089,BLOCK,-1,,<empty>,,,,1,,<empty>
138093,BLOCK,-1,,<empty>,,,,1,,<empty>
138097,BLOCK,-1,,<empty>,,,,1,,<empty>
138101,BLOCK,-1,,<empty>,,,,1,,<empty>
138105,BLOCK,-1,,<empty>,,,,1,,<empty>
138109,BLOCK,-1,,<empty>,,,,1,,<empty>
138113,BLOCK,-1,,<empty>,,,,1,,<empty>
138117,BLOCK,-1,,<empty>,,,,1,,<empty>
138121,BLOCK,-1,,<empty>,,,,1,,<empty>
138125,BLOCK,-1,,<empty>,,,,1,,<empty>
138129,BLOCK,-1,,<empty>,,,,1,,<empty>
138133,BLOCK,-1,,<empty>,,,,1,,<empty>
138137,BLOCK,-1,,<empty>,,,,1,,<empty>
138141,BLOCK,-1,,<empty>,,,,1,,<empty>
138145,BLOCK,-1,,<empty>,,,,1,,<empty>
138149,BLOCK,-1,,<empty>,,,,1,,<empty>
138153,BLOCK,-1,,<empty>,,,,1,,<empty>
138157,BLOCK,-1,,<empty>,,,,1,,<empty>
138161,BLOCK,-1,,<empty>,,,,1,,<empty>
138165,BLOCK,-1,,<empty>,,,,1,,<empty>
138169,BLOCK,-1,,<empty>,,,,1,,<empty>
138173,BLOCK,-1,,<empty>,,,,1,,<empty>
138177,BLOCK,-1,,<empty>,,,,1,,<empty>
138181,BLOCK,-1,,<empty>,,,,1,,<empty>
138185,BLOCK,-1,,<empty>,,,,1,,<empty>
138189,BLOCK,-1,,<empty>,,,,1,,<empty>
138193,BLOCK,-1,,<empty>,,,,1,,<empty>
138197,BLOCK,-1,,<empty>,,,,1,,<empty>
138201,BLOCK,-1,,<empty>,,,,1,,<empty>
138205,BLOCK,-1,,<empty>,,,,1,,<empty>
138209,BLOCK,-1,,<empty>,,,,1,,<empty>
138213,BLOCK,-1,,<empty>,,,,1,,<empty>
138217,BLOCK,-1,,<empty>,,,,1,,<empty>
138221,BLOCK,-1,,<empty>,,,,1,,<empty>
138225,BLOCK,-1,,<empty>,,,,1,,<empty>
138229,BLOCK,-1,,<empty>,,,,1,,<empty>
138233,BLOCK,-1,,<empty>,,,,1,,<empty>
138237,BLOCK,-1,,<empty>,,,,1,,<empty>
138241,BLOCK,-1,,<empty>,,,,1,,<empty>
138245,BLOCK,-1,,<empty>,,,,1,,<empty>
138261,BLOCK,-1,,"{
  struct node_module* mp = reinterpret_cast<struct node_module*>(m);

  if (mp->nm_flags & NM_F_INTERNAL) {
    mp->nm_link = modlist_internal;
    modlist_internal = mp;
  } else if (!node_is_initialized) {
    // ""Linked"" modules are included as part of the node project.
    // Like builtins they are registered *before* node::Init runs.
    mp->nm_flags = NM_F_LINKED;
    mp->nm_link = modlist_linked;
    modlist_linked = mp;
  } else {
    thread_local_modpending = mp;
  }
}",47,,255,2,,void
138274,BLOCK,-1,,"{
    mp->nm_link = modlist_internal;
    modlist_internal = mp;
  }",37,,258,2,,void
138284,BLOCK,-1,,<empty>,10,,261,1,,void
138288,BLOCK,-1,,"{
    // ""Linked"" modules are included as part of the node project.
    // Like builtins they are registered *before* node::Init runs.
    mp->nm_flags = NM_F_LINKED;
    mp->nm_link = modlist_linked;
    modlist_linked = mp;
  }",36,,261,2,,void
138303,BLOCK,-1,,"{
    thread_local_modpending = mp;
  }",10,,267,1,,void
138314,BLOCK,-1,,"{
    CHECK_NE(handle, nullptr);
    Mutex::ScopedLock lock(mutex_);

    map_[handle].module = mod;
    // We need to store this flag internally to avoid a chicken-and-egg problem
    // during cleanup. By the time we actually use the flag's value,
    // the shared object has been unloaded, and its memory would be gone,
    // making it impossible to access fields of `mod` --
    // unless `mod` *is* dynamically allocated, but we cannot know that
    // without checking the flag.
    map_[handle].wants_delete_module = mod->nm_flags & NM_F_DELETEME;
    map_[handle].refcount++;
  }",44,,276,3,,void
138349,BLOCK,-1,,"{
    CHECK_NE(handle, nullptr);
    Mutex::ScopedLock lock(mutex_);

    auto it = map_.find(handle);
    if (it == map_.end()) return nullptr;
    it->second.refcount++;
    return it->second.module;
  }",56,,291,2,,void
138371,BLOCK,-1,,<empty>,27,,296,2,,void
138390,BLOCK,-1,,"{
    CHECK_NE(handle, nullptr);
    Mutex::ScopedLock lock(mutex_);

    auto it = map_.find(handle);
    if (it == map_.end()) return;
    CHECK_GE(it->second.refcount, 1);
    if (--it->second.refcount == 0) {
      if (it->second.wants_delete_module)
        delete it->second.module;
      map_.erase(handle);
    }
  }",28,,301,2,,void
138412,BLOCK,-1,,<empty>,27,,306,2,,void
138430,BLOCK,-1,,"{
      if (it->second.wants_delete_module)
        delete it->second.module;
      map_.erase(handle);
    }",37,,308,2,,void
138437,BLOCK,-1,,<empty>,9,,310,2,,void
138461,BLOCK,-1,,<empty>,60,,326,3,,void
138465,BLOCK,-1,,"{
  int ret = uv_dlopen(filename_.c_str(), &lib_);
  if (ret == 0) {
    handle_ = static_cast<void*>(lib_.handle);
    return true;
  }
  errmsg_ = uv_dlerror(&lib_);
  uv_dlclose(&lib_);
  return false;
}",19,,360,1,,void
138480,BLOCK,-1,,"{
    handle_ = static_cast<void*>(lib_.handle);
    return true;
  }",17,,362,2,,void
138501,BLOCK,-1,,"{
  if (handle_ == nullptr) return;
  if (has_entry_in_global_handle_map_)
    global_handle_map.erase(handle_);
  uv_dlclose(&lib_);
  handle_ = nullptr;
}",20,,371,1,,void
138506,BLOCK,-1,,<empty>,27,,372,2,,void
138510,BLOCK,-1,,<empty>,5,,374,2,,void
138524,BLOCK,-1,,"{
  void* address;
  if (0 == uv_dlsym(&lib_, name, &address)) return address;
  return nullptr;
}",48,,379,2,,void
138535,BLOCK,-1,,<empty>,45,,381,2,,void
138544,BLOCK,-1,,"{
  has_entry_in_global_handle_map_ = true;
  global_handle_map.set(handle_, mp);
}",51,,386,2,,void
138557,BLOCK,-1,,"{
  has_entry_in_global_handle_map_ = true;
  return global_handle_map.get_and_increase_refcount(handle_);
}",56,,391,1,,void
138572,BLOCK,-1,,"{
  const char* name = ""node_register_module_v"" STRINGIFY(NODE_MODULE_VERSION);
  return reinterpret_cast<InitializerCallback>(dlib->GetSymbolAddress(name));
}",63,,400,2,,void
138591,BLOCK,-1,,"{
  const char* name =
      STRINGIFY(NAPI_MODULE_INITIALIZER_BASE) STRINGIFY(NAPI_MODULE_VERSION);
  return reinterpret_cast<napi_addon_register_func>(
      dlib->GetSymbolAddress(name));
}",72,,405,2,,void
138611,BLOCK,-1,,"{
  return reinterpret_cast<node_api_addon_get_api_version_func>(
      dlib->GetSymbolAddress(STRINGIFY(NODE_API_MODULE_GET_API_VERSION)));
}",17,,413,2,,void
138625,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  if (env->no_native_addons()) {
    return THROW_ERR_DLOPEN_DISABLED(
      env, ""Cannot load native addon because loading addons is disabled."");
  }

  auto context = env->context();

  CHECK_NULL(thread_local_modpending);

  if (args.Length() < 2) {
    return THROW_ERR_MISSING_ARGS(
        env, ""process.dlopen needs at least 2 arguments"");
  }

  int32_t flags = DLib::kDefaultFlags;
  if (args.Length() > 2 && !args[2]->Int32Value(context).To(&flags)) {
    return THROW_ERR_INVALID_ARG_TYPE(env, ""flag argument must be an integer."");
  }

  Local<Object> module;
  Local<Object> exports;
  Local<Value> exports_v;
  if (!args[0]->ToObject(context).ToLocal(&module) ||
      !module->Get(context, env->exports_string()).ToLocal(&exports_v) ||
      !exports_v->ToObject(context).ToLocal(&exports)) {
    return;  // Exception pending.
  }

  node::Utf8Value filename(env->isolate(), args[1]);  // Cast
  env->TryLoadAddon(*filename, f...",54,,424,2,,void
138638,BLOCK,-1,,"{
    return THROW_ERR_DLOPEN_DISABLED(
      env, ""Cannot load native addon because loading addons is disabled."");
  }",32,,427,2,,void
138658,BLOCK,-1,,"{
    return THROW_ERR_MISSING_ARGS(
        env, ""process.dlopen needs at least 2 arguments"");
  }",26,,436,2,,void
138690,BLOCK,-1,,"{
    return THROW_ERR_INVALID_ARG_TYPE(env, ""flag argument must be an integer."");
  }",70,,442,2,,void
138752,BLOCK,-1,,"{
    return;  // Exception pending.
  }",56,,451,2,,void
138776,BLOCK,-1,,"{
  struct node_module* mp;

  for (mp = list; mp != nullptr; mp = mp->nm_link) {
    if (strcmp(mp->nm_modname, name) == 0) break;
  }

  CHECK(mp == nullptr || (mp->nm_flags & flag) != 0);
  return mp;
}",49,,562,4,,void
138779,BLOCK,-1,,<empty>,3,,565,1,,void
138791,BLOCK,4,,"{
    if (strcmp(mp->nm_modname, name) == 0) break;
  }",52,,565,4,,void
138800,BLOCK,-1,,<empty>,44,,566,2,,void
138820,BLOCK,-1,,"{
#define V(modname)                                                             \
  do {                                                                         \
    Local<ObjectTemplate> templ =                                              \
        ObjectTemplate::New(isolate_data->isolate());                          \
    templ->SetInternalFieldCount(BaseObject::kInternalFieldCount);             \
    _register_isolate_##modname(isolate_data, templ);                          \
    isolate_data->set_##modname##_binding_template(templ);                     \
  } while (0);
  NODE_BINDINGS_WITH_PER_ISOLATE_INIT(V)
#undef V
}",64,,573,2,,void
138829,BLOCK,-1,,"{
  Local<ObjectTemplate> templ;

#define V(name)                                                                \
  if (strcmp(mod_name, #name) == 0) {                                          \
    templ = isolate_data->name##_binding_template();                           \
  } else  // NOLINT(readability/braces)
  NODE_BINDINGS_WITH_PER_ISOLATE_INIT(V)
#undef V
  {
    // Default template.
    templ = isolate_data->binding_data_default_template();
  }

  Local<Object> obj = templ->NewInstance(context).ToLocalChecked();
  return obj;
}",77,,588,4,,void
138838,BLOCK,4,,"{
    // Default template.
    templ = isolate_data->binding_data_default_template();
  }",3,,597,4,,void
138866,BLOCK,-1,,"{
  EscapableHandleScope scope(realm->isolate());
  Local<Context> context = realm->context();
  Local<Object> exports = GetInternalBindingExportObject(
      realm->isolate_data(), mod->nm_modname, context);
  CHECK_NULL(mod->nm_register_func);
  CHECK_NOT_NULL(mod->nm_context_register_func);
  Local<Value> unused = Undefined(realm->isolate());
  // Internal bindings don't have a ""module"" object, only exports.
  mod->nm_context_register_func(exports, unused, context, mod->nm_priv);
  return scope.Escape(exports);
}",74,,606,3,,void
138937,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(args);
  Isolate* isolate = realm->isolate();
  HandleScope scope(isolate);

  CHECK(args[0]->IsString());

  Local<String> module = args[0].As<String>();
  node::Utf8Value module_v(isolate, module);
  Local<Object> exports;

  node_module* mod = FindModule(modlist_internal, *module_v, NM_F_INTERNAL);
  if (mod != nullptr) {
    exports = InitInternalBinding(realm, mod);
    realm->internal_bindings.insert(mod);
  } else {
    return THROW_ERR_INVALID_MODULE(isolate, ""No such binding: %s"", *module_v);
  }

  args.GetReturnValue().Set(exports);
}",66,,619,2,,void
138996,BLOCK,-1,,"{
    exports = InitInternalBinding(realm, mod);
    realm->internal_bindings.insert(mod);
  }",23,,631,2,,void
139010,BLOCK,-1,,"{
    return THROW_ERR_INVALID_MODULE(isolate, ""No such binding: %s"", *module_v);
  }",10,,634,1,,void
139029,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsString());

  Local<String> module_name = args[0].As<String>();

  node::Utf8Value module_name_v(env->isolate(), module_name);
  const char* name = *module_name_v;
  node_module* mod = nullptr;

  // Iterate from here to the nearest non-Worker Environment to see if there's
  // a linked binding defined locally rather than through the global list.
  Environment* cur_env = env;
  while (mod == nullptr && cur_env != nullptr) {
    Mutex::ScopedLock lock(cur_env->extra_linked_bindings_mutex());
    mod = FindModule(cur_env->extra_linked_bindings_head(), name, NM_F_LINKED);
    cur_env = cur_env->worker_parent_env();
  }

  if (mod == nullptr)
    mod = FindModule(modlist_linked, name, NM_F_LINKED);

  if (mod == nullptr) {
    return THROW_ERR_INVALID_MODULE(
        env, ""No such binding was linked: %s"", *module_name_v);
  }

  Local<Object> module = Object::New(env->isolate());
  Local<Object> exports = Object::...",64,,641,2,,void
139085,BLOCK,-1,,"{
    Mutex::ScopedLock lock(cur_env->extra_linked_bindings_mutex());
    mod = FindModule(cur_env->extra_linked_bindings_head(), name, NM_F_LINKED);
    cur_env = cur_env->worker_parent_env();
  }",48,,655,2,,void
139111,BLOCK,-1,,<empty>,5,,662,2,,void
139122,BLOCK,-1,,"{
    return THROW_ERR_INVALID_MODULE(
        env, ""No such binding was linked: %s"", *module_name_v);
  }",23,,664,2,,void
139191,BLOCK,-1,,"{
    mod->nm_context_register_func(
        exports, module, env->context(), mod->nm_priv);
  }",49,,675,2,,void
139206,BLOCK,-1,,<empty>,10,,678,1,,void
139213,BLOCK,-1,,"{
    mod->nm_register_func(exports, module, mod->nm_priv);
  }",48,,678,2,,void
139224,BLOCK,-1,,"{
    return THROW_ERR_INVALID_MODULE(
        env, ""Linked binding has no declared entry point."");
  }",10,,680,1,,void
139255,BLOCK,-1,,"{
#define V(modname) _register_##modname();
  NODE_BUILTIN_BINDINGS(V)
#undef V
}",32,,693,1,,void
139257,BLOCK,1,,<empty>,,,,1,,void
139260,BLOCK,1,,<empty>,,,,1,,void
139322,BLOCK,-1,,"{
  registry->Register(GetLinkedBinding);
  registry->Register(GetInternalBinding);
}",70,,699,2,,void
139348,BLOCK,-1,,<empty>,1,,1,1,,ANY
139354,BLOCK,-1,,"{
      if (buf->IsDetachable()) {
        std::shared_ptr<BackingStore> store = buf->GetBackingStore();
        USE(buf->Detach(Local<Value>()));
        return DataQueue::CreateInMemoryEntryFromBackingStore(
            store, byte_offset, byte_length);
      }

      // If the ArrayBuffer is not detachable, we will copy from it instead.
      std::shared_ptr<BackingStore> store =
          ArrayBuffer::NewBackingStore(env->isolate(), byte_length);
      uint8_t* ptr = static_cast<uint8_t*>(buf->Data()) + byte_offset;
      std::copy(ptr, ptr + byte_length, static_cast<uint8_t*>(store->Data()));
      return DataQueue::CreateInMemoryEntryFromBackingStore(
          store, 0, byte_length);
    }",69,,186,4,,void
139360,BLOCK,-1,,"{
        std::shared_ptr<BackingStore> store = buf->GetBackingStore();
        USE(buf->Detach(Local<Value>()));
        return DataQueue::CreateInMemoryEntryFromBackingStore(
            store, byte_offset, byte_length);
      }",32,,187,2,,void
139447,BLOCK,-1,,"{
    auto dropMe = std::unique_ptr<Impl>(impl);
    Environment* env = impl->env;
    HandleScope handleScope(env->isolate());
    Local<Function> fn = impl->callback.Get(env->isolate());

    if (status == bob::STATUS_EOS) impl->reader->eos_ = true;

    if (count > 0) {
      // Copy the returns vectors into a single ArrayBuffer.
      size_t total = 0;
      for (size_t n = 0; n < count; n++) total += vecs[n].len;

      std::shared_ptr<BackingStore> store =
          v8::ArrayBuffer::NewBackingStore(env->isolate(), total);
      auto ptr = static_cast<uint8_t*>(store->Data());
      for (size_t n = 0; n < count; n++) {
        std::copy(vecs[n].base, vecs[n].base + vecs[n].len, ptr);
        ptr += vecs[n].len;
      }
      // Since we copied the data buffers, signal that we're done with them.
      std::move(doneCb)(0);
      Local<Value> argv[2] = {Uint32::New(env->isolate(), status),
                              ArrayBuffer::New(env->isolate(), store)};
      impl->reader-...",48,,343,5,,void
139492,BLOCK,-1,,<empty>,36,,349,2,,void
139504,BLOCK,-1,,"{
      // Copy the returns vectors into a single ArrayBuffer.
      size_t total = 0;
      for (size_t n = 0; n < count; n++) total += vecs[n].len;

      std::shared_ptr<BackingStore> store =
          v8::ArrayBuffer::NewBackingStore(env->isolate(), total);
      auto ptr = static_cast<uint8_t*>(store->Data());
      for (size_t n = 0; n < count; n++) {
        std::copy(vecs[n].base, vecs[n].base + vecs[n].len, ptr);
        ptr += vecs[n].len;
      }
      // Since we copied the data buffers, signal that we're done with them.
      std::move(doneCb)(0);
      Local<Value> argv[2] = {Uint32::New(env->isolate(), status),
                              ArrayBuffer::New(env->isolate(), store)};
      impl->reader->MakeCallback(fn, arraysize(argv), argv);
      return;
    }",20,,351,2,,void
139510,BLOCK,-1,,<empty>,7,,354,1,,void
139556,BLOCK,-1,,<empty>,7,,359,1,,void
139566,BLOCK,4,,"{
        std::copy(vecs[n].base, vecs[n].base + vecs[n].len, ptr);
        ptr += vecs[n].len;
      }",42,,359,4,,void
139673,BLOCK,-1,,<empty>,1,,1,1,,ANY
139678,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsArray());
  Local<Array> array = args[0].As<Array>();

  struct View {
    std::shared_ptr<BackingStore> store;
    size_t length;
    size_t offset = 0;
  };

  std::vector<View> views;
  size_t total = 0;

  for (uint32_t n = 0; n < array->Length(); n++) {
    Local<Value> val;
    if (!array->Get(env->context(), n).ToLocal(&val)) return;
    if (val->IsArrayBuffer()) {
      auto ab = val.As<ArrayBuffer>();
      views.push_back(View{ab->GetBackingStore(), ab->ByteLength(), 0});
      total += ab->ByteLength();
    } else {
      CHECK(val->IsArrayBufferView());
      auto view = val.As<ArrayBufferView>();
      views.push_back(View{view->Buffer()->GetBackingStore(),
                           view->ByteLength(),
                           view->ByteOffset()});
      total += view->ByteLength();
    }
  }

  std::shared_ptr<BackingStore> store =
      ArrayBuffer::NewBackingStore(env->isolate(), total);
  ui...",54,,43,2,,void
139712,BLOCK,-1,,<empty>,3,,57,1,,void
139725,BLOCK,4,,"{
    Local<Value> val;
    if (!array->Get(env->context(), n).ToLocal(&val)) return;
    if (val->IsArrayBuffer()) {
      auto ab = val.As<ArrayBuffer>();
      views.push_back(View{ab->GetBackingStore(), ab->ByteLength(), 0});
      total += ab->ByteLength();
    } else {
      CHECK(val->IsArrayBufferView());
      auto view = val.As<ArrayBufferView>();
      views.push_back(View{view->Buffer()->GetBackingStore(),
                           view->ByteLength(),
                           view->ByteOffset()});
      total += view->ByteLength();
    }
  }",50,,57,4,,void
139747,BLOCK,-1,,<empty>,55,,59,2,,void
139754,BLOCK,-1,,"{
      auto ab = val.As<ArrayBuffer>();
      views.push_back(View{ab->GetBackingStore(), ab->ByteLength(), 0});
      total += ab->ByteLength();
    }",31,,60,2,,void
139784,BLOCK,-1,,"{
      CHECK(val->IsArrayBufferView());
      auto view = val.As<ArrayBufferView>();
      views.push_back(View{view->Buffer()->GetBackingStore(),
                           view->ByteLength(),
                           view->ByteOffset()});
      total += view->ByteLength();
    }",12,,64,1,,void
139851,BLOCK,-1,,<empty>,3,,77,1,,void
139864,BLOCK,4,,"{
    uint8_t* from =
        static_cast<uint8_t*>(views[n].store->Data()) + views[n].offset;
    std::copy(from, from + views[n].length, ptr);
    ptr += views[n].length;
  }",45,,77,4,,void
139928,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, path.ToStringView());
  auto entry = DataQueue::CreateFdEntry(env, args[0]);
  if (entry == nullptr) {
    return THROW_ERR_INVALID_ARG_VALUE(env, ""Unabled to open file as blob"");
  }

  std::vector<std::unique_ptr<DataQueue::Entry>> entries;
  entries.push_back(std::move(entry));

  auto blob =
      Blob::Create(env, DataQueue::CreateIdempotent(std::move(entries)));

  if (blob) {
    auto array = Array::New(env->isolate(), 2);
    USE(array->Set(env->context(), 0, blob->object()));
    USE(array->Set(env->context(),
                   1,
                   Uint32::NewFromUnsigned(env->isolate(), blob->length())));

    args.GetReturnValue().Set(array);
  }
}",64,,87,2,,void
139975,BLOCK,-1,,"{
    return THROW_ERR_INVALID_ARG_VALUE(env, ""Unabled to open file as blob"");
  }",25,,94,2,,void
140021,BLOCK,-1,,"{
    auto array = Array::New(env->isolate(), 2);
    USE(array->Set(env->context(), 0, blob->object()));
    USE(array->Set(env->context(),
                   1,
                   Uint32::NewFromUnsigned(env->isolate(), blob->length())));

    args.GetReturnValue().Set(array);
  }",13,,104,2,,void
140083,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();

  SetMethod(isolate, target, ""createBlob"", New);
  SetMethod(isolate, target, ""storeDataObject"", StoreDataObject);
  SetMethod(isolate, target, ""getDataObject"", GetDataObject);
  SetMethod(isolate, target, ""revokeObjectURL"", RevokeObjectURL);
  SetMethod(isolate, target, ""concat"", Concat);
  SetMethod(isolate, target, ""createBlobFromFilePath"", BlobFromFilePath);
}",69,,117,3,,void
140128,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(context);
  realm->AddBindingData<BlobBindingData>(context, target);
}",51,,131,5,,void
140151,BLOCK,-1,,"{
  Local<FunctionTemplate> tmpl = env->blob_constructor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        BaseObject::kInternalFieldCount);
    tmpl->SetClassName(
        FIXED_ONE_BYTE_STRING(env->isolate(), ""Blob""));
    SetProtoMethod(isolate, tmpl, ""getReader"", GetReader);
    SetProtoMethod(isolate, tmpl, ""slice"", ToSlice);
    env->set_blob_constructor_template(tmpl);
  }
  return tmpl;
}",72,,136,2,,void
140167,BLOCK,-1,,"{
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        BaseObject::kInternalFieldCount);
    tmpl->SetClassName(
        FIXED_ONE_BYTE_STRING(env->isolate(), ""Blob""));
    SetProtoMethod(isolate, tmpl, ""getReader"", GetReader);
    SetProtoMethod(isolate, tmpl, ""slice"", ToSlice);
    env->set_blob_constructor_template(tmpl);
  }",23,,138,2,,void
140222,BLOCK,-1,,"{
  return GetConstructorTemplate(env)->HasInstance(object);
}",71,,152,3,,void
140235,BLOCK,-1,,"{
  HandleScope scope(env->isolate());

  Local<Function> ctor;
  if (!GetConstructorTemplate(env)->GetFunction(env->context()).ToLocal(&ctor))
    return BaseObjectPtr<Blob>();

  Local<Object> obj;
  if (!ctor->NewInstance(env->context()).ToLocal(&obj))
    return BaseObjectPtr<Blob>();

  return MakeBaseObject<Blob>(env, obj, data_queue);
}",73,,157,3,,void
140263,BLOCK,-1,,<empty>,5,,162,2,,void
140286,BLOCK,-1,,<empty>,5,,166,2,,void
140303,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsArray());  // sources

  Local<Array> array = args[0].As<Array>();
  std::vector<std::unique_ptr<DataQueue::Entry>> entries(array->Length());

  for (size_t i = 0; i < array->Length(); i++) {
    Local<Value> entry;
    if (!array->Get(env->context(), i).ToLocal(&entry)) {
      return;
    }

    const auto entryFromArrayBuffer = [env](v8::Local<v8::ArrayBuffer> buf,
                                            size_t byte_length,
                                            size_t byte_offset = 0) {
      if (buf->IsDetachable()) {
        std::shared_ptr<BackingStore> store = buf->GetBackingStore();
        USE(buf->Detach(Local<Value>()));
        return DataQueue::CreateInMemoryEntryFromBackingStore(
            store, byte_offset, byte_length);
      }

      // If the ArrayBuffer is not detachable, we will copy from it instead.
      std::shared_ptr<BackingStore> store =
          ArrayBuffer::NewBackingSt...",57,,171,2,,void
140348,BLOCK,-1,,<empty>,3,,178,1,,void
140361,BLOCK,4,,"{
    Local<Value> entry;
    if (!array->Get(env->context(), i).ToLocal(&entry)) {
      return;
    }

    const auto entryFromArrayBuffer = [env](v8::Local<v8::ArrayBuffer> buf,
                                            size_t byte_length,
                                            size_t byte_offset = 0) {
      if (buf->IsDetachable()) {
        std::shared_ptr<BackingStore> store = buf->GetBackingStore();
        USE(buf->Detach(Local<Value>()));
        return DataQueue::CreateInMemoryEntryFromBackingStore(
            store, byte_offset, byte_length);
      }

      // If the ArrayBuffer is not detachable, we will copy from it instead.
      std::shared_ptr<BackingStore> store =
          ArrayBuffer::NewBackingStore(env->isolate(), byte_length);
      uint8_t* ptr = static_cast<uint8_t*>(buf->Data()) + byte_offset;
      std::copy(ptr, ptr + byte_length, static_cast<uint8_t*>(store->Data()));
      return DataQueue::CreateInMemoryEntryFromBackingStore(
          store, 0...",48,,178,4,,void
140383,BLOCK,-1,,"{
      return;
    }",57,,180,2,,void
140394,BLOCK,-1,,"{
      Local<ArrayBuffer> buf = entry.As<ArrayBuffer>();
      entries[i] = entryFromArrayBuffer(buf, buf->ByteLength());
    }",33,,212,2,,void
140416,BLOCK,-1,,<empty>,12,,215,1,,void
140422,BLOCK,-1,,"{
      Local<ArrayBufferView> view = entry.As<ArrayBufferView>();
      entries[i] = entryFromArrayBuffer(
          view->Buffer(), view->ByteLength(), view->ByteOffset());
    }",44,,215,2,,void
140451,BLOCK,-1,,<empty>,12,,219,1,,void
140459,BLOCK,-1,,"{
      Blob* blob;
      ASSIGN_OR_RETURN_UNWRAP(&blob, entry);
      entries[i] = DataQueue::CreateDataQueueEntry(blob->data_queue_);
    }",47,,219,2,,void
140477,BLOCK,-1,,"{
      UNREACHABLE(""Incorrect Blob initialization type"");
    }",12,,223,1,,void
140496,BLOCK,-1,,<empty>,5,,230,2,,void
140512,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Blob* blob;
  ASSIGN_OR_RETURN_UNWRAP(&blob, args.Holder());

  BaseObjectPtr<Blob::Reader> reader =
      Blob::Reader::Create(env, BaseObjectPtr<Blob>(blob));
  if (reader) args.GetReturnValue().Set(reader->object());
}",63,,233,2,,void
140551,BLOCK,-1,,<empty>,15,,240,2,,void
140567,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Blob* blob;
  ASSIGN_OR_RETURN_UNWRAP(&blob, args.Holder());
  CHECK(args[0]->IsUint32());
  CHECK(args[1]->IsUint32());
  size_t start = args[0].As<Uint32>()->Value();
  size_t end = args[1].As<Uint32>()->Value();
  BaseObjectPtr<Blob> slice = blob->Slice(env, start, end);
  if (slice)
    args.GetReturnValue().Set(slice->object());
}",61,,243,2,,void
140637,BLOCK,-1,,<empty>,5,,253,2,,void
140653,BLOCK,-1,,"{
  tracker->TrackField(""data_queue_"", data_queue_, ""std::shared_ptr<DataQueue>"");
}",53,,256,2,,void
140667,BLOCK,-1,,"{
  return Create(env,
                this->data_queue_->slice(start, static_cast<uint64_t>(end)));
}",77,,260,4,,void
140687,BLOCK,-1,,"{
  MakeWeak();
}",53,,268,4,,void
140695,BLOCK,-1,,"{
  MakeWeak();
}",42,,277,4,,void
140702,BLOCK,-1,,"{
  return GetConstructorTemplate(env)->HasInstance(value);
}",78,,281,3,,void
140714,BLOCK,-1,,"{
  Local<FunctionTemplate> tmpl = env->blob_reader_constructor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        BaseObject::kInternalFieldCount);
    tmpl->SetClassName(FIXED_ONE_BYTE_STRING(env->isolate(), ""BlobReader""));
    SetProtoMethod(env->isolate(), tmpl, ""pull"", Pull);
    env->set_blob_reader_constructor_template(tmpl);
  }
  return tmpl;
}",80,,285,2,,void
140730,BLOCK,-1,,"{
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        BaseObject::kInternalFieldCount);
    tmpl->SetClassName(FIXED_ONE_BYTE_STRING(env->isolate(), ""BlobReader""));
    SetProtoMethod(env->isolate(), tmpl, ""pull"", Pull);
    env->set_blob_reader_constructor_template(tmpl);
  }",23,,287,2,,void
140783,BLOCK,-1,,"{
  Local<Object> obj;
  if (!GetConstructorTemplate(env)
           ->InstanceTemplate()
           ->NewInstance(env->context())
           .ToLocal(&obj)) {
    return BaseObjectPtr<Blob::Reader>();
  }

  return MakeBaseObject<Blob::Reader>(env, obj, std::move(blob));
}",76,,300,3,,void
140808,BLOCK,-1,,"{
    return BaseObjectPtr<Blob::Reader>();
  }",28,,305,2,,void
140832,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Blob::Reader* reader;
  ASSIGN_OR_RETURN_UNWRAP(&reader, args.Holder());

  CHECK(args[0]->IsFunction());
  Local<Function> fn = args[0].As<Function>();
  CHECK(!fn->IsConstructor());

  if (reader->eos_) {
    Local<Value> arg = Int32::New(env->isolate(), bob::STATUS_EOS);
    reader->MakeCallback(fn, 1, &arg);
    return args.GetReturnValue().Set(bob::STATUS_EOS);
  }

  struct Impl {
    BaseObjectPtr<Blob::Reader> reader;
    Global<Function> callback;
    Environment* env;
  };
  // TODO(@jasnell): A unique_ptr is likely better here but making this a unique
  // pointer that is passed into the lambda causes the std::move(next) below to
  // complain about std::function needing to be copy-constructible.
  Impl* impl = new Impl();
  impl->reader = BaseObjectPtr<Blob::Reader>(reader);
  impl->callback.Reset(env->isolate(), fn);
  impl->env = env;

  auto next = [impl](int status,
                     const DataQueue::Vec* vec...",66,,312,2,,void
140878,BLOCK,-1,,"{
    Local<Value> arg = Int32::New(env->isolate(), bob::STATUS_EOS);
    reader->MakeCallback(fn, 1, &arg);
    return args.GetReturnValue().Set(bob::STATUS_EOS);
  }",21,,321,2,,void
140981,BLOCK,-1,,"{
  if (context != env->context()) {
    THROW_ERR_MESSAGE_TARGET_CONTEXT_UNAVAILABLE(env);
    return {};
  }
  return Blob::Create(env, data_queue);
}",49,,386,4,,void
140989,BLOCK,-1,,"{
    THROW_ERR_MESSAGE_TARGET_CONTEXT_UNAVAILABLE(env);
    return {};
  }",34,,387,2,,void
141003,BLOCK,-1,,"{
  return BaseObject::TransferMode::kCloneable;
}",56,,394,1,,void
141013,BLOCK,-1,,"{
  return std::make_unique<BlobTransferData>(data_queue_);
}",71,,398,1,,void
141026,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  BlobBindingData* binding_data = Realm::GetBindingData<BlobBindingData>(args);

  CHECK(args[0]->IsString());  // ID key
  CHECK(Blob::HasInstance(env, args[1]));  // Blob
  CHECK(args[2]->IsUint32());  // Length
  CHECK(args[3]->IsString());  // Type

  Utf8Value key(env->isolate(), args[0]);
  Blob* blob;
  ASSIGN_OR_RETURN_UNWRAP(&blob, args[1]);

  size_t length = args[2].As<Uint32>()->Value();
  Utf8Value type(env->isolate(), args[3]);

  binding_data->store_data_object(
      std::string(*key, key.length()),
      BlobBindingData::StoredDataObject(
        BaseObjectPtr<Blob>(blob),
        length,
        std::string(*type, type.length())));
}",77,,402,2,,void
141150,BLOCK,-1,,"{
  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());
  BlobBindingData* binding_data = Realm::GetBindingData<BlobBindingData>(args);
  Environment* env = Environment::GetCurrent(args);
  Utf8Value input(env->isolate(), args[0].As<String>());
  auto out = ada::parse<ada::url_aggregator>(input.ToStringView());

  if (!out) {
    return;
  }

  auto pathname = out->get_pathname();
  auto start_index = pathname.find(':');

  if (start_index != std::string_view::npos && start_index != pathname.size()) {
    auto end_index = pathname.find(':', start_index + 1);
    if (end_index == std::string_view::npos) {
      auto id = std::string(pathname.substr(start_index + 1));
      binding_data->revoke_data_object(id);
    }
  }
}",69,,427,2,,void
141212,BLOCK,-1,,"{
    return;
  }",13,,435,2,,void
141244,BLOCK,-1,,"{
    auto end_index = pathname.find(':', start_index + 1);
    if (end_index == std::string_view::npos) {
      auto id = std::string(pathname.substr(start_index + 1));
      binding_data->revoke_data_object(id);
    }
  }",80,,442,2,,void
141264,BLOCK,-1,,"{
      auto id = std::string(pathname.substr(start_index + 1));
      binding_data->revoke_data_object(id);
    }",46,,444,2,,void
141288,BLOCK,-1,,"{
  BlobBindingData* binding_data = Realm::GetBindingData<BlobBindingData>(args);

  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsString());

  Utf8Value key(env->isolate(), args[0]);

  BlobBindingData::StoredDataObject stored =
      binding_data->get_data_object(std::string(*key, key.length()));
  if (stored.blob) {
    Local<Value> type;
    if (!String::NewFromUtf8(
            env->isolate(),
            stored.type.c_str(),
            v8::NewStringType::kNormal,
            static_cast<int>(stored.type.length())).ToLocal(&type)) {
      return;
    }

    Local<Value> values[] = {
      stored.blob->object(),
      Uint32::NewFromUnsigned(env->isolate(), stored.length),
      type
    };

    args.GetReturnValue().Set(
        Array::New(
            env->isolate(),
            values,
            arraysize(values)));
  }
}",75,,451,2,,void
141344,BLOCK,-1,,"{
    Local<Value> type;
    if (!String::NewFromUtf8(
            env->isolate(),
            stored.type.c_str(),
            v8::NewStringType::kNormal,
            static_cast<int>(stored.type.length())).ToLocal(&type)) {
      return;
    }

    Local<Value> values[] = {
      stored.blob->object(),
      Uint32::NewFromUnsigned(env->isolate(), stored.length),
      type
    };

    args.GetReturnValue().Set(
        Array::New(
            env->isolate(),
            values,
            arraysize(values)));
  }",20,,461,2,,void
141384,BLOCK,-1,,"{
      return;
    }",69,,467,2,,void
141430,BLOCK,-1,,"{
  tracker->TrackField(""blob"", blob, ""BaseObjectPtr<Blob>"");
}",35,,486,2,,void
141444,BLOCK,-1,,<empty>,19,,496,4,,void
141450,BLOCK,-1,,"{
  MakeWeak();
}",49,,499,3,,void
141456,BLOCK,-1,,"{
  tracker->TrackField(""data_objects_"",
                      data_objects_,
                      ""std::unordered_map<std::string, StoredDataObject>"");
}",64,,503,2,,void
141469,BLOCK,-1,,"{
  data_objects_[uuid] = object;
}",54,,511,3,,void
141479,BLOCK,-1,,"{
  if (data_objects_.find(uuid) == data_objects_.end()) {
    return;
  }
  data_objects_.erase(uuid);
  CHECK_EQ(data_objects_.find(uuid), data_objects_.end());
}",67,,515,2,,void
141491,BLOCK,-1,,"{
    return;
  }",56,,516,2,,void
141512,BLOCK,-1,,"{
  auto entry = data_objects_.find(uuid);
  if (entry == data_objects_.end())
    return BlobBindingData::StoredDataObject {};
  return entry->second;
}",30,,524,2,,void
141528,BLOCK,-1,,<empty>,5,,527,2,,void
141543,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  HandleScope scope(context->GetIsolate());
  Realm* realm = Realm::GetCurrent(context);
  BlobBindingData* binding =
      realm->AddBindingData<BlobBindingData>(context, holder);
  CHECK_NOT_NULL(binding);
}",64,,534,5,,void
141583,BLOCK,-1,,"{
  // Stored blob objects are not actually persisted.
  // Return true because we need to maintain the reference to the binding from
  // JS land.
  return true;
}",77,,544,3,,void
141590,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  InternalFieldInfo* info =
      InternalFieldInfoBase::New<InternalFieldInfo>(type());
  return info;
}",62,,551,2,,void
141612,BLOCK,-1,,"{
  registry->Register(Blob::New);
  registry->Register(Blob::GetReader);
  registry->Register(Blob::ToSlice);
  registry->Register(Blob::StoreDataObject);
  registry->Register(Blob::GetDataObject);
  registry->Register(Blob::RevokeObjectURL);
  registry->Register(Blob::Reader::Pull);
  registry->Register(Concat);
  registry->Register(BlobFromFilePath);
}",76,,558,2,,void
141709,BLOCK,-1,,<empty>,1,,1,1,,ANY
141713,BLOCK,-1,,<empty>,56,,22,2,,void
141724,BLOCK,-1,,<empty>,1,,1,1,,ANY
141733,BLOCK,-1,,"{

  int status;
  if (eos_) {
    status = bob::Status::STATUS_EOS;
    std::move(next)(status, nullptr, 0, [](size_t len) {});
    return status;
  }

  status = DoPull(std::move(next), options, data, count, max_count_hint);

  if (status == bob::Status::STATUS_EOS) eos_ = true;

  return status;
}",28,,17,6,,void
141737,BLOCK,-1,,"{
    status = bob::Status::STATUS_EOS;
    std::move(next)(status, nullptr, 0, [](size_t len) {});
    return status;
  }",13,,20,2,,void
141777,BLOCK,-1,,<empty>,42,,28,2,,void
141791,BLOCK,-1,,<empty>,1,,1,1,,ANY
141804,BLOCK,-1,,<empty>,,,,1,,<empty>
141824,BLOCK,-1,,<empty>,,,,1,,<empty>
141840,BLOCK,-1,,<empty>,,,,1,,<empty>
141849,BLOCK,-1,,<empty>,,,,6,,<empty>
141859,BLOCK,-1,,<empty>,,,,6,,<empty>
141863,BLOCK,-1,,{ return eos_; },23,,90,1,,void
141874,BLOCK,-1,,<empty>,,,,6,,<empty>
141879,BLOCK,-1,,<empty>,,,,1,,<empty>
141890,BLOCK,-1,,"{
        static_cast<CallbackInfo*>(arg)->OnBackingStoreFree();
      }",79,,122,4,,void
141903,BLOCK,-1,,"{
    CHECK_EQ(self->env_, env);  // Consistency check.

    self->CallAndResetCallback();
  }",75,,198,2,,void
141921,BLOCK,-1,,"{
    free(data);
  }",74,,509,4,,void
141932,BLOCK,-1,,<empty>,63,,1179,4,,void
141970,BLOCK,-1,,<empty>,1,,1,1,,ANY
141981,BLOCK,-1,,<empty>,,,,6,,<empty>
141986,BLOCK,-1,,<empty>,,,,2,,<empty>
141991,BLOCK,-1,,<empty>,,,,2,,<empty>
141996,BLOCK,-1,,<empty>,,,,2,,<empty>
142000,BLOCK,-1,,<empty>,,,,1,,<empty>
142004,BLOCK,-1,,<empty>,,,,1,,<empty>
142012,BLOCK,-1,,<empty>,,,,5,,<empty>
142027,BLOCK,-1,,"{
  CHECK_NOT_NULL(callback);
  CHECK_IMPLIES(data == nullptr, length == 0);

  CallbackInfo* self = new CallbackInfo(env, callback, data, hint);
  std::unique_ptr<BackingStore> bs =
      ArrayBuffer::NewBackingStore(data, length, [](void*, size_t, void* arg) {
        static_cast<CallbackInfo*>(arg)->OnBackingStoreFree();
      }, self);
  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));

  // V8 simply ignores the BackingStore deleter callback if data == nullptr,
  // but our API contract requires it being called.
  if (data == nullptr) {
    ab->Detach(Local<Value>()).Check();
    self->OnBackingStoreFree();  // This calls `callback` asynchronously.
  } else {
    // Store the ArrayBuffer so that we can detach it later.
    self->persistent_.Reset(env->isolate(), ab);
    self->persistent_.SetWeak();
  }

  return ab;
}",17,,116,6,,void
142085,BLOCK,-1,,"{
    ab->Detach(Local<Value>()).Check();
    self->OnBackingStoreFree();  // This calls `callback` asynchronously.
  }",24,,129,2,,void
142099,BLOCK,-1,,"{
    // Store the ArrayBuffer so that we can detach it later.
    self->persistent_.Reset(env->isolate(), ab);
    self->persistent_.SetWeak();
  }",10,,132,1,,void
142126,BLOCK,-1,,"{
  env->AddCleanupHook(CleanupHook, this);
  env->isolate()->AdjustAmountOfExternalAllocatedMemory(sizeof(*this));
}",17,,149,5,,void
142147,BLOCK,-1,,"{
  CallbackInfo* self = static_cast<CallbackInfo*>(data);

  {
    HandleScope handle_scope(self->env_->isolate());
    Local<ArrayBuffer> ab = self->persistent_.Get(self->env_->isolate());
    if (!ab.IsEmpty() && ab->IsDetachable()) {
      ab->Detach(Local<Value>()).Check();
      self->persistent_.Reset();
    }
  }

  // Call the callback in this case, but don't delete `this` yet because the
  // BackingStore deleter callback will do so later.
  self->CallAndResetCallback();
}",44,,154,2,,void
142154,BLOCK,3,,"{
    HandleScope handle_scope(self->env_->isolate());
    Local<ArrayBuffer> ab = self->persistent_.Get(self->env_->isolate());
    if (!ab.IsEmpty() && ab->IsDetachable()) {
      ab->Detach(Local<Value>()).Check();
      self->persistent_.Reset();
    }
  }",3,,157,3,,void
142192,BLOCK,-1,,"{
      ab->Detach(Local<Value>()).Check();
      self->persistent_.Reset();
    }",46,,160,2,,void
142214,BLOCK,-1,,"{
  FreeCallback callback;
  {
    Mutex::ScopedLock lock(mutex_);
    callback = callback_;
    callback_ = nullptr;
  }
  if (callback != nullptr) {
    // Clean up all Environment-related state and run the callback.
    env_->RemoveCleanupHook(CleanupHook, this);
    int64_t change_in_bytes = -static_cast<int64_t>(sizeof(*this));
    env_->isolate()->AdjustAmountOfExternalAllocatedMemory(change_in_bytes);

    callback(data_, hint_);
  }
}",43,,171,1,,void
142216,BLOCK,2,,"{
    Mutex::ScopedLock lock(mutex_);
    callback = callback_;
    callback_ = nullptr;
  }",3,,173,2,,void
142230,BLOCK,-1,,"{
    // Clean up all Environment-related state and run the callback.
    env_->RemoveCleanupHook(CleanupHook, this);
    int64_t change_in_bytes = -static_cast<int64_t>(sizeof(*this));
    env_->isolate()->AdjustAmountOfExternalAllocatedMemory(change_in_bytes);

    callback(data_, hint_);
  }",28,,178,2,,void
142260,BLOCK,-1,,"{
  // This method should always release the memory for `this`.
  std::unique_ptr<CallbackInfo> self { this };
  Mutex::ScopedLock lock(mutex_);
  // If callback_ == nullptr, that means that the callback has already run from
  // the cleanup hook, and there is nothing left to do here besides to clean
  // up the memory involved. In particular, the underlying `Environment` may
  // be gone at this point, so dont attempt to call SetImmediateThreadsafe().
  if (callback_ == nullptr) return;

  env_->SetImmediateThreadsafe([self = std::move(self)](Environment* env) {
    CHECK_EQ(self->env_, env);  // Consistency check.

    self->CallAndResetCallback();
  });
}",41,,188,1,,void
142272,BLOCK,-1,,<empty>,29,,196,2,,void
142284,BLOCK,-1,,"{
  return val->IsArrayBufferView();
}",36,,237,2,,void
142294,BLOCK,-1,,"{
  return obj->IsArrayBufferView();
}",37,,242,2,,void
142304,BLOCK,-1,,"{
  CHECK(val->IsArrayBufferView());
  Local<ArrayBufferView> ui = val.As<ArrayBufferView>();
  return static_cast<char*>(ui->Buffer()->Data()) + ui->ByteOffset();
}",30,,247,2,,void
142339,BLOCK,-1,,"{
  return Data(obj.As<Value>());
}",31,,254,2,,void
142350,BLOCK,-1,,"{
  CHECK(val->IsArrayBufferView());
  Local<ArrayBufferView> ui = val.As<ArrayBufferView>();
  return ui->ByteLength();
}",33,,259,2,,void
142375,BLOCK,-1,,"{
  CHECK(obj->IsArrayBufferView());
  Local<ArrayBufferView> ui = obj.As<ArrayBufferView>();
  return ui->ByteLength();
}",34,,266,2,,void
142403,BLOCK,-1,,"{
  CHECK(!env->buffer_prototype_object().IsEmpty());
  Local<Uint8Array> ui = Uint8Array::New(ab, byte_offset, length);
  Maybe<bool> mb =
      ui->SetPrototype(env->context(), env->buffer_prototype_object());
  if (mb.IsNothing())
    return MaybeLocal<Uint8Array>();
  return ui;
}",43,,276,5,,void
142446,BLOCK,-1,,<empty>,5,,282,2,,void
142458,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(isolate);
  if (env == nullptr) {
    THROW_ERR_BUFFER_CONTEXT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Uint8Array>();
  }
  return New(env, ab, byte_offset, length);
}",43,,289,5,,void
142471,BLOCK,-1,,"{
    THROW_ERR_BUFFER_CONTEXT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Uint8Array>();
  }",23,,291,2,,void
142488,BLOCK,-1,,"{
  EscapableHandleScope scope(isolate);

  size_t length;
  if (!StringBytes::Size(isolate, string, enc).To(&length))
    return Local<Object>();
  size_t actual = 0;
  std::unique_ptr<BackingStore> store;

  if (length > 0) {
    store = ArrayBuffer::NewBackingStore(isolate, length);

    if (UNLIKELY(!store)) {
      THROW_ERR_MEMORY_ALLOCATION_FAILED(isolate);
      return Local<Object>();
    }

    actual = StringBytes::Write(
        isolate,
        static_cast<char*>(store->Data()),
        length,
        string,
        enc);
    CHECK(actual <= length);

    if (LIKELY(actual > 0)) {
      if (actual < length)
        store = BackingStore::Reallocate(isolate, std::move(store), actual);
      Local<ArrayBuffer> buf = ArrayBuffer::New(isolate, std::move(store));
      Local<Object> obj;
      if (UNLIKELY(!New(isolate, buf, 0, actual).ToLocal(&obj)))
        return MaybeLocal<Object>();
      return scope.Escape(obj);
    }
  }

  return scope.EscapeMaybe(New(isolate, 0));
}",43,,301,4,,void
142507,BLOCK,-1,,<empty>,5,,306,2,,void
142525,BLOCK,-1,,"{
    store = ArrayBuffer::NewBackingStore(isolate, length);

    if (UNLIKELY(!store)) {
      THROW_ERR_MEMORY_ALLOCATION_FAILED(isolate);
      return Local<Object>();
    }

    actual = StringBytes::Write(
        isolate,
        static_cast<char*>(store->Data()),
        length,
        string,
        enc);
    CHECK(actual <= length);

    if (LIKELY(actual > 0)) {
      if (actual < length)
        store = BackingStore::Reallocate(isolate, std::move(store), actual);
      Local<ArrayBuffer> buf = ArrayBuffer::New(isolate, std::move(store));
      Local<Object> obj;
      if (UNLIKELY(!New(isolate, buf, 0, actual).ToLocal(&obj)))
        return MaybeLocal<Object>();
      return scope.Escape(obj);
    }
  }",19,,310,2,,void
142538,BLOCK,-1,,"{
      THROW_ERR_MEMORY_ALLOCATION_FAILED(isolate);
      return Local<Object>();
    }",27,,313,2,,void
142568,BLOCK,-1,,"{
      if (actual < length)
        store = BackingStore::Reallocate(isolate, std::move(store), actual);
      Local<ArrayBuffer> buf = ArrayBuffer::New(isolate, std::move(store));
      Local<Object> obj;
      if (UNLIKELY(!New(isolate, buf, 0, actual).ToLocal(&obj)))
        return MaybeLocal<Object>();
      return scope.Escape(obj);
    }",29,,326,2,,void
142573,BLOCK,-1,,<empty>,9,,328,2,,void
142621,BLOCK,-1,,<empty>,9,,332,2,,void
142643,BLOCK,-1,,"{
  EscapableHandleScope handle_scope(isolate);
  Local<Object> obj;
  Environment* env = Environment::GetCurrent(isolate);
  if (env == nullptr) {
    THROW_ERR_BUFFER_CONTEXT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Object>();
  }
  if (Buffer::New(env, length).ToLocal(&obj))
    return handle_scope.Escape(obj);
  return Local<Object>();
}",57,,341,3,,void
142664,BLOCK,-1,,"{
    THROW_ERR_BUFFER_CONTEXT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Object>();
  }",23,,345,2,,void
142681,BLOCK,-1,,<empty>,5,,350,2,,void
142695,BLOCK,-1,,"{
  Isolate* isolate(env->isolate());
  EscapableHandleScope scope(isolate);

  // V8 currently only allows a maximum Typed Array index of max Smi.
  if (length > kMaxLength) {
    isolate->ThrowException(ERR_BUFFER_TOO_LARGE(isolate));
    return Local<Object>();
  }

  Local<ArrayBuffer> ab;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    std::unique_ptr<BackingStore> bs =
        ArrayBuffer::NewBackingStore(isolate, length);

    CHECK(bs);

    ab = ArrayBuffer::New(isolate, std::move(bs));
  }

  MaybeLocal<Object> obj =
      New(env, ab, 0, ab->ByteLength())
          .FromMaybe(Local<Uint8Array>());

  return scope.EscapeMaybe(obj);
}",57,,355,3,,void
142709,BLOCK,-1,,"{
    isolate->ThrowException(ERR_BUFFER_TOO_LARGE(isolate));
    return Local<Object>();
  }",28,,360,2,,void
142723,BLOCK,7,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    std::unique_ptr<BackingStore> bs =
        ArrayBuffer::NewBackingStore(isolate, length);

    CHECK(bs);

    ab = ArrayBuffer::New(isolate, std::move(bs));
  }",3,,366,7,,void
142787,BLOCK,-1,,"{
  EscapableHandleScope handle_scope(isolate);
  Environment* env = Environment::GetCurrent(isolate);
  if (env == nullptr) {
    THROW_ERR_BUFFER_CONTEXT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Object>();
  }
  Local<Object> obj;
  if (Buffer::Copy(env, data, length).ToLocal(&obj))
    return handle_scope.Escape(obj);
  return Local<Object>();
}",76,,384,4,,void
142803,BLOCK,-1,,"{
    THROW_ERR_BUFFER_CONTEXT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Object>();
  }",23,,387,2,,void
142826,BLOCK,-1,,<empty>,5,,393,2,,void
142841,BLOCK,-1,,"{
  Isolate* isolate(env->isolate());
  EscapableHandleScope scope(isolate);

  // V8 currently only allows a maximum Typed Array index of max Smi.
  if (length > kMaxLength) {
    isolate->ThrowException(ERR_BUFFER_TOO_LARGE(isolate));
    return Local<Object>();
  }

  Local<ArrayBuffer> ab;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    std::unique_ptr<BackingStore> bs =
        ArrayBuffer::NewBackingStore(isolate, length);

    CHECK(bs);

    memcpy(bs->Data(), data, length);

    ab = ArrayBuffer::New(isolate, std::move(bs));
  }

  MaybeLocal<Object> obj =
      New(env, ab, 0, ab->ByteLength())
          .FromMaybe(Local<Uint8Array>());

  return scope.EscapeMaybe(obj);
}",76,,398,4,,void
142855,BLOCK,-1,,"{
    isolate->ThrowException(ERR_BUFFER_TOO_LARGE(isolate));
    return Local<Object>();
  }",28,,403,2,,void
142869,BLOCK,7,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    std::unique_ptr<BackingStore> bs =
        ArrayBuffer::NewBackingStore(isolate, length);

    CHECK(bs);

    memcpy(bs->Data(), data, length);

    ab = ArrayBuffer::New(isolate, std::move(bs));
  }",3,,409,7,,void
142942,BLOCK,-1,,"{
  EscapableHandleScope handle_scope(isolate);
  Environment* env = Environment::GetCurrent(isolate);
  if (env == nullptr) {
    callback(data, hint);
    THROW_ERR_BUFFER_CONTEXT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Object>();
  }
  return handle_scope.EscapeMaybe(
      Buffer::New(env, data, length, callback, hint));
}",36,,433,6,,void
142958,BLOCK,-1,,"{
    callback(data, hint);
    THROW_ERR_BUFFER_CONTEXT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Object>();
  }",23,,436,2,,void
142988,BLOCK,-1,,"{
  EscapableHandleScope scope(env->isolate());

  if (length > kMaxLength) {
    env->isolate()->ThrowException(ERR_BUFFER_TOO_LARGE(env->isolate()));
    callback(data, hint);
    return Local<Object>();
  }

  Local<ArrayBuffer> ab =
      CallbackInfo::CreateTrackedArrayBuffer(env, data, length, callback, hint);
  if (ab->SetPrivate(env->context(),
                     env->untransferable_object_private_symbol(),
                     True(env->isolate())).IsNothing()) {
    return Local<Object>();
  }
  MaybeLocal<Uint8Array> maybe_ui = Buffer::New(env, ab, 0, length);

  Local<Uint8Array> ui;
  if (!maybe_ui.ToLocal(&ui))
    return MaybeLocal<Object>();

  return scope.Escape(ui);
}",36,,450,6,,void
142999,BLOCK,-1,,"{
    env->isolate()->ThrowException(ERR_BUFFER_TOO_LARGE(env->isolate()));
    callback(data, hint);
    return Local<Object>();
  }",28,,453,2,,void
143053,BLOCK,-1,,"{
    return Local<Object>();
  }",57,,463,2,,void
143083,BLOCK,-1,,<empty>,5,,470,2,,void
143098,BLOCK,-1,,"{
  EscapableHandleScope handle_scope(isolate);
  Environment* env = Environment::GetCurrent(isolate);
  if (env == nullptr) {
    free(data);
    THROW_ERR_BUFFER_CONTEXT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Object>();
  }
  Local<Object> obj;
  if (Buffer::New(env, data, length).ToLocal(&obj))
    return handle_scope.Escape(obj);
  return Local<Object>();
}",69,,477,4,,void
143114,BLOCK,-1,,"{
    free(data);
    THROW_ERR_BUFFER_CONTEXT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Object>();
  }",23,,480,2,,void
143139,BLOCK,-1,,<empty>,5,,487,2,,void
143153,BLOCK,-1,,"{
  if (length > 0) {
    CHECK_NOT_NULL(data);
    // V8 currently only allows a maximum Typed Array index of max Smi.
    if (length > kMaxLength) {
      Isolate* isolate(env->isolate());
      isolate->ThrowException(ERR_BUFFER_TOO_LARGE(isolate));
      free(data);
      return Local<Object>();
    }
  }

  EscapableHandleScope handle_scope(env->isolate());

  auto free_callback = [](void* data, size_t length, void* deleter_data) {
    free(data);
  };
  std::unique_ptr<BackingStore> bs =
      v8::ArrayBuffer::NewBackingStore(data, length, free_callback, nullptr);

  Local<ArrayBuffer> ab = v8::ArrayBuffer::New(env->isolate(), std::move(bs));

  Local<Object> obj;
  if (Buffer::New(env, ab, 0, length).ToLocal(&obj))
    return handle_scope.Escape(obj);
  return Local<Object>();
}",39,,495,4,,void
143158,BLOCK,-1,,"{
    CHECK_NOT_NULL(data);
    // V8 currently only allows a maximum Typed Array index of max Smi.
    if (length > kMaxLength) {
      Isolate* isolate(env->isolate());
      isolate->ThrowException(ERR_BUFFER_TOO_LARGE(isolate));
      free(data);
      return Local<Object>();
    }
  }",19,,496,2,,void
143165,BLOCK,-1,,"{
      Isolate* isolate(env->isolate());
      isolate->ThrowException(ERR_BUFFER_TOO_LARGE(isolate));
      free(data);
      return Local<Object>();
    }",30,,499,2,,void
143250,BLOCK,-1,,<empty>,5,,519,2,,void
143264,BLOCK,-1,,"{
  CHECK(args[0]->IsString());
  CHECK(args[1]->IsInt32());

  enum encoding enc = static_cast<enum encoding>(args[1].As<Int32>()->Value());
  Local<Object> buf;
  if (New(args.GetIsolate(), args[0].As<String>(), enc).ToLocal(&buf))
    args.GetReturnValue().Set(buf);
}",64,,525,2,,void
143316,BLOCK,-1,,<empty>,5,,532,2,,void
143329,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  THROW_AND_RETURN_UNLESS_BUFFER(env, args.This());
  ArrayBufferViewContents<char> buffer(args.This());

  if (buffer.length() == 0)
    return args.GetReturnValue().SetEmptyString();

  size_t start = 0;
  size_t end = 0;
  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[0], 0, &start));
  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[1], buffer.length(), &end));
  if (end < start) end = start;
  THROW_AND_RETURN_IF_OOB(Just(end <= buffer.length()));
  size_t length = end - start;

  Local<Value> error;
  MaybeLocal<Value> maybe_ret =
      StringBytes::Encode(isolate,
                          buffer.data() + start,
                          length,
                          encoding,
                          &error);
  Local<Value> ret;
  if (!maybe_ret.ToLocal(&ret)) {
    CHECK(!error.IsEmpty());
    isolate->ThrowException(error);
    return;
  }
  args.GetReturnValue().Set(ret);
}",59,,537,2,,void
143351,BLOCK,1,,<empty>,,,,4,,void
143372,BLOCK,-1,,<empty>,5,,545,2,,void
143391,BLOCK,1,,<empty>,,,,6,,void
143393,BLOCK,-1,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[0], 0, &start))",3,,549,1,,void
143410,BLOCK,-1,,<empty>,3,,549,2,,void
143418,BLOCK,-1,,<empty>,3,,549,2,,void
143429,BLOCK,1,,<empty>,,,,7,,void
143431,BLOCK,-1,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[1], buffer.length(), &end))",3,,550,1,,void
143451,BLOCK,-1,,<empty>,3,,550,2,,void
143459,BLOCK,-1,,<empty>,3,,550,2,,void
143472,BLOCK,-1,,<empty>,20,,551,2,,void
143478,BLOCK,1,,<empty>,,,,6,,void
143480,BLOCK,-1,,THROW_AND_RETURN_IF_OOB(Just(end <= buffer.length())),3,,552,1,,void
143496,BLOCK,-1,,<empty>,3,,552,2,,void
143504,BLOCK,-1,,<empty>,3,,552,2,,void
143558,BLOCK,-1,,"{
    CHECK(!error.IsEmpty());
    isolate->ThrowException(error);
    return;
  }",33,,563,2,,void
143583,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  THROW_AND_RETURN_UNLESS_BUFFER(env, args[0]);
  THROW_AND_RETURN_UNLESS_BUFFER(env, args[1]);
  ArrayBufferViewContents<char> source(args[0]);
  Local<Object> target_obj = args[1].As<Object>();
  SPREAD_BUFFER_ARG(target_obj, target);

  size_t target_start = 0;
  size_t source_start = 0;
  size_t source_end = 0;

  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[2], 0, &target_start));
  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[3], 0, &source_start));
  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[4], source.length(),
                                          &source_end));

  // Copy 0 bytes; we're done
  if (target_start >= target_length || source_start >= source_end)
    return args.GetReturnValue().Set(0);

  if (source_start > source.length())
    return THROW_ERR_OUT_OF_RANGE(
        env, ""The value of \""sourceStart\"" is out of range."");

  if (source_end - source_start > target_length - target_start)
 ...",52,,572,2,,void
143597,BLOCK,1,,<empty>,,,,4,,void
143609,BLOCK,1,,<empty>,,,,4,,void
143650,BLOCK,1,,<empty>,,,,6,,void
143652,BLOCK,-1,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[2], 0, &target_start))",3,,585,1,,void
143669,BLOCK,-1,,<empty>,3,,585,2,,void
143677,BLOCK,-1,,<empty>,3,,585,2,,void
143688,BLOCK,1,,<empty>,,,,6,,void
143690,BLOCK,-1,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[3], 0, &source_start))",3,,586,1,,void
143707,BLOCK,-1,,<empty>,3,,586,2,,void
143715,BLOCK,-1,,<empty>,3,,586,2,,void
143726,BLOCK,1,,<empty>,,,,7,,void
143728,BLOCK,-1,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[4], source.length(),
                                          &source_end))",3,,587,1,,void
143748,BLOCK,-1,,<empty>,3,,587,2,,void
143756,BLOCK,-1,,<empty>,3,,587,2,,void
143773,BLOCK,-1,,<empty>,5,,592,2,,void
143790,BLOCK,-1,,<empty>,5,,595,2,,void
143803,BLOCK,-1,,<empty>,5,,599,2,,void
143857,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Local<Context> ctx = env->context();

  THROW_AND_RETURN_UNLESS_BUFFER(env, args[0]);
  SPREAD_BUFFER_ARG(args[0], ts_obj);

  size_t start = 0;
  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[2], 0, &start));
  size_t end;
  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[3], 0, &end));

  size_t fill_length = end - start;
  Local<String> str_obj;
  size_t str_length;
  enum encoding enc;

  // OOB Check. Throw the error in JS.
  if (start > end || fill_length + start > ts_obj_length)
    return args.GetReturnValue().Set(-2);

  // First check if Buffer has been passed.
  if (Buffer::HasInstance(args[1])) {
    SPREAD_BUFFER_ARG(args[1], fill_obj);
    str_length = fill_obj_length;
    memcpy(
        ts_obj_data + start, fill_obj_data, std::min(str_length, fill_length));
    goto start_fill;
  }

  // Then coerce everything that's not a string.
  if (!args[1]->IsString()) {
    uint32_t val;
    if (!args[1]->Uint32Valu...",52,,610,2,,void
143881,BLOCK,1,,<empty>,,,,4,,void
143899,BLOCK,1,,<empty>,,,,6,,void
143901,BLOCK,-1,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[2], 0, &start))",3,,618,1,,void
143918,BLOCK,-1,,<empty>,3,,618,2,,void
143926,BLOCK,-1,,<empty>,3,,618,2,,void
143938,BLOCK,1,,<empty>,,,,6,,void
143940,BLOCK,-1,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[3], 0, &end))",3,,620,1,,void
143957,BLOCK,-1,,<empty>,3,,620,2,,void
143965,BLOCK,-1,,<empty>,3,,620,2,,void
143997,BLOCK,-1,,<empty>,5,,629,2,,void
144016,BLOCK,-1,,"{
    SPREAD_BUFFER_ARG(args[1], fill_obj);
    str_length = fill_obj_length;
    memcpy(
        ts_obj_data + start, fill_obj_data, std::min(str_length, fill_length));
    goto start_fill;
  }",37,,632,2,,void
144045,BLOCK,-1,,"{
    uint32_t val;
    if (!args[1]->Uint32Value(ctx).To(&val)) return;
    int value = val & 255;
    memset(ts_obj_data + start, value, fill_length);
    return;
  }",29,,641,2,,void
144061,BLOCK,-1,,<empty>,46,,643,2,,void
144106,BLOCK,-1,,"{
    str_length = str_obj->Utf8Length(env->isolate());
    node::Utf8Value str(env->isolate(), args[1]);
    memcpy(ts_obj_data + start, *str, std::min(str_length, fill_length));

  }",20,,654,2,,void
144139,BLOCK,-1,,<empty>,10,,659,1,,void
144144,BLOCK,-1,,"{
    str_length = str_obj->Length() * sizeof(uint16_t);
    node::TwoByteValue str(env->isolate(), args[1]);
    if (IsBigEndian())
      SwapBytes16(reinterpret_cast<char*>(&str[0]), str_length);

    memcpy(ts_obj_data + start, *str, std::min(str_length, fill_length));

  }",27,,659,2,,void
144165,BLOCK,-1,,<empty>,7,,663,2,,void
144187,BLOCK,-1,,"{
    // Write initial String to Buffer, then use that memory to copy remainder
    // of string. Correct the string length for cases like HEX where less than
    // the total string length is written.
    str_length = StringBytes::Write(
        env->isolate(), ts_obj_data + start, fill_length, str_obj, enc);
  }",10,,667,1,,void
144209,BLOCK,-1,,<empty>,5,,678,2,,void
144215,BLOCK,-1,,<empty>,5,,686,2,,void
144244,BLOCK,-1,,"{
    memcpy(ptr, ts_obj_data + start, in_there);
    ptr += in_there;
    in_there *= 2;
  }",45,,691,2,,void
144261,BLOCK,-1,,"{
    memcpy(ptr, ts_obj_data + start, fill_length - in_there);
  }",31,,697,2,,void
144274,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  THROW_AND_RETURN_UNLESS_BUFFER(env, args.This());
  SPREAD_BUFFER_ARG(args.This(), ts_obj);

  THROW_AND_RETURN_IF_NOT_STRING(env, args[0], ""argument"");

  Local<String> str = args[0]->ToString(env->context()).ToLocalChecked();

  size_t offset = 0;
  size_t max_length = 0;

  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[1], 0, &offset));
  if (offset > ts_obj_length) {
    return node::THROW_ERR_BUFFER_OUT_OF_BOUNDS(
        env, ""\""offset\"" is outside of buffer bounds"");
  }

  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[2], ts_obj_length - offset,
                                          &max_length));

  max_length = std::min(ts_obj_length - offset, max_length);

  if (max_length == 0)
    return args.GetReturnValue().Set(0);

  uint32_t written = StringBytes::Write(
      env->isolate(), ts_obj_data + offset, max_length, str, encoding);
  args.GetReturnValue().Set(written);
}",59,,704,2,,void
144289,BLOCK,1,,<empty>,,,,4,,void
144338,BLOCK,1,,<empty>,,,,6,,void
144340,BLOCK,-1,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[1], 0, &offset))",3,,717,1,,void
144357,BLOCK,-1,,<empty>,3,,717,2,,void
144365,BLOCK,-1,,<empty>,3,,717,2,,void
144378,BLOCK,-1,,"{
    return node::THROW_ERR_BUFFER_OUT_OF_BOUNDS(
        env, ""\""offset\"" is outside of buffer bounds"");
  }",31,,718,2,,void
144388,BLOCK,1,,<empty>,,,,7,,void
144390,BLOCK,-1,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[2], ts_obj_length - offset,
                                          &max_length))",3,,723,1,,void
144409,BLOCK,-1,,<empty>,3,,723,2,,void
144417,BLOCK,-1,,<empty>,3,,723,2,,void
144440,BLOCK,-1,,<empty>,5,,729,2,,void
144479,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsString());

  // Fast case: avoid StringBytes on UTF8 string. Jump to v8.
  args.GetReturnValue().Set(args[0].As<String>()->Utf8Length(env->isolate()));
}",66,,736,2,,void
144520,BLOCK,-1,,"{
  uint32_t result = 0;
  uint32_t length = source.length;
  const uint8_t* data = reinterpret_cast<const uint8_t*>(source.data);
  for (uint32_t i = 0; i < length; ++i) {
    result += (data[i] >> 7);
  }
  result += length;
  return result;
}",66,,745,3,,void
144540,BLOCK,-1,,<empty>,3,,749,1,,void
144550,BLOCK,4,,"{
    result += (data[i] >> 7);
  }",41,,749,4,,void
144567,BLOCK,-1,,<empty>,,,,2,,<empty>
144574,BLOCK,-1,,"{
  if (val == 0) {
    if (a_length > b_length)
      return 1;
    else if (a_length < b_length)
      return -1;
  } else {
    if (val > 0)
      return 1;
    else
      return -1;
  }
  return val;
}",75,,761,4,,void
144579,BLOCK,-1,,"{
    if (a_length > b_length)
      return 1;
    else if (a_length < b_length)
      return -1;
  }",17,,762,2,,void
144584,BLOCK,-1,,<empty>,7,,764,2,,void
144588,BLOCK,-1,,<empty>,10,,765,1,,void
144593,BLOCK,-1,,<empty>,7,,766,2,,void
144598,BLOCK,-1,,"{
    if (val > 0)
      return 1;
    else
      return -1;
  }",10,,767,1,,void
144603,BLOCK,-1,,<empty>,7,,769,2,,void
144607,BLOCK,-1,,<empty>,7,,771,1,,void
144617,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  THROW_AND_RETURN_UNLESS_BUFFER(env, args[0]);
  THROW_AND_RETURN_UNLESS_BUFFER(env, args[1]);
  ArrayBufferViewContents<char> source(args[0]);
  ArrayBufferViewContents<char> target(args[1]);

  size_t target_start = 0;
  size_t source_start = 0;
  size_t source_end = 0;
  size_t target_end = 0;

  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[2], 0, &target_start));
  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[3], 0, &source_start));
  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[4], target.length(),
                                          &target_end));
  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[5], source.length(),
                                          &source_end));

  if (source_start > source.length())
    return THROW_ERR_OUT_OF_RANGE(
        env, ""The value of \""sourceStart\"" is out of range."");
  if (target_start > target.length())
    return THROW_ERR_OUT_OF_RANGE(
        env, ""The va...",61,,776,2,,void
144631,BLOCK,1,,<empty>,,,,4,,void
144643,BLOCK,1,,<empty>,,,,4,,void
144678,BLOCK,1,,<empty>,,,,6,,void
144680,BLOCK,-1,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[2], 0, &target_start))",3,,789,1,,void
144697,BLOCK,-1,,<empty>,3,,789,2,,void
144705,BLOCK,-1,,<empty>,3,,789,2,,void
144716,BLOCK,1,,<empty>,,,,6,,void
144718,BLOCK,-1,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[3], 0, &source_start))",3,,790,1,,void
144735,BLOCK,-1,,<empty>,3,,790,2,,void
144743,BLOCK,-1,,<empty>,3,,790,2,,void
144754,BLOCK,1,,<empty>,,,,7,,void
144756,BLOCK,-1,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[4], target.length(),
                                          &target_end))",3,,791,1,,void
144776,BLOCK,-1,,<empty>,3,,791,2,,void
144784,BLOCK,-1,,<empty>,3,,791,2,,void
144795,BLOCK,1,,<empty>,,,,7,,void
144797,BLOCK,-1,,"THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[5], source.length(),
                                          &source_end))",3,,793,1,,void
144817,BLOCK,-1,,<empty>,3,,793,2,,void
144825,BLOCK,-1,,<empty>,3,,793,2,,void
144841,BLOCK,-1,,<empty>,5,,797,2,,void
144853,BLOCK,-1,,<empty>,5,,800,2,,void
144928,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  THROW_AND_RETURN_UNLESS_BUFFER(env, args[0]);
  THROW_AND_RETURN_UNLESS_BUFFER(env, args[1]);
  ArrayBufferViewContents<char> a(args[0]);
  ArrayBufferViewContents<char> b(args[1]);

  size_t cmp_length = std::min(a.length(), b.length());

  int val = normalizeCompareVal(cmp_length > 0 ?
                                memcmp(a.data(), b.data(), cmp_length) : 0,
                                a.length(), b.length());
  args.GetReturnValue().Set(val);
}",55,,820,2,,void
144942,BLOCK,1,,<empty>,,,,4,,void
144954,BLOCK,1,,<empty>,,,,4,,void
145028,BLOCK,-1,,"{
  int64_t length_i64 = static_cast<int64_t>(length);
  if (offset_i64 < 0) {
    if (offset_i64 + length_i64 >= 0) {
      // Negative offsets count backwards from the end of the buffer.
      return length_i64 + offset_i64;
    } else if (is_forward || needle_length == 0) {
      // indexOf from before the start of the buffer: search the whole buffer.
      return 0;
    } else {
      // lastIndexOf from before the start of the buffer: no match.
      return -1;
    }
  } else {
    if (offset_i64 + needle_length <= length_i64) {
      // Valid positive offset.
      return offset_i64;
    } else if (needle_length == 0) {
      // Out of buffer bounds, but empty needle: point to end of buffer.
      return length_i64;
    } else if (is_forward) {
      // indexOf from past the end of the buffer: no match.
      return -1;
    } else {
      // lastIndexOf from past the end of the buffer: search the whole buffer.
      return length_i64 - 1;
    }
  }
}",40,,843,5,,void
145039,BLOCK,-1,,"{
    if (offset_i64 + length_i64 >= 0) {
      // Negative offsets count backwards from the end of the buffer.
      return length_i64 + offset_i64;
    } else if (is_forward || needle_length == 0) {
      // indexOf from before the start of the buffer: search the whole buffer.
      return 0;
    } else {
      // lastIndexOf from before the start of the buffer: no match.
      return -1;
    }
  }",23,,845,2,,void
145046,BLOCK,-1,,"{
      // Negative offsets count backwards from the end of the buffer.
      return length_i64 + offset_i64;
    }",39,,846,2,,void
145052,BLOCK,-1,,<empty>,12,,849,1,,void
145059,BLOCK,-1,,"{
      // indexOf from before the start of the buffer: search the whole buffer.
      return 0;
    }",50,,849,2,,void
145063,BLOCK,-1,,"{
      // lastIndexOf from before the start of the buffer: no match.
      return -1;
    }",12,,852,1,,void
145068,BLOCK,-1,,"{
    if (offset_i64 + needle_length <= length_i64) {
      // Valid positive offset.
      return offset_i64;
    } else if (needle_length == 0) {
      // Out of buffer bounds, but empty needle: point to end of buffer.
      return length_i64;
    } else if (is_forward) {
      // indexOf from past the end of the buffer: no match.
      return -1;
    } else {
      // lastIndexOf from past the end of the buffer: search the whole buffer.
      return length_i64 - 1;
    }
  }",10,,856,1,,void
145075,BLOCK,-1,,"{
      // Valid positive offset.
      return offset_i64;
    }",51,,857,2,,void
145079,BLOCK,-1,,<empty>,12,,860,1,,void
145084,BLOCK,-1,,"{
      // Out of buffer bounds, but empty needle: point to end of buffer.
      return length_i64;
    }",36,,860,2,,void
145088,BLOCK,-1,,<empty>,12,,863,1,,void
145091,BLOCK,-1,,"{
      // indexOf from past the end of the buffer: no match.
      return -1;
    }",28,,863,2,,void
145096,BLOCK,-1,,"{
      // lastIndexOf from past the end of the buffer: search the whole buffer.
      return length_i64 - 1;
    }",12,,866,1,,void
145105,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  CHECK(args[1]->IsString());
  CHECK(args[2]->IsNumber());
  CHECK(args[3]->IsInt32());
  CHECK(args[4]->IsBoolean());

  enum encoding enc = static_cast<enum encoding>(args[3].As<Int32>()->Value());

  THROW_AND_RETURN_UNLESS_BUFFER(env, args[0]);
  ArrayBufferViewContents<char> buffer(args[0]);

  Local<String> needle = args[1].As<String>();
  int64_t offset_i64 = args[2].As<Integer>()->Value();
  bool is_forward = args[4]->IsTrue();

  const char* haystack = buffer.data();
  // Round down to the nearest multiple of 2 in case of UCS2.
  const size_t haystack_length = (enc == UCS2) ?
      buffer.length() &~ 1 : buffer.length();  // NOLINT(whitespace/operators)

  size_t needle_length;
  if (!StringBytes::Size(isolate, needle, enc).To(&needle_length)) return;

  int64_t opt_offset = IndexOfOffset(haystack_length,
                                     offset_i64,
                             ...",61,,873,2,,void
145168,BLOCK,1,,<empty>,,,,4,,void
145253,BLOCK,-1,,<empty>,68,,897,2,,void
145267,BLOCK,-1,,"{
    // Match String#indexOf() and String#lastIndexOf() behavior.
    args.GetReturnValue().Set(static_cast<double>(opt_offset));
    return;
  }",27,,904,2,,void
145283,BLOCK,-1,,"{
    return args.GetReturnValue().Set(-1);
  }",29,,910,2,,void
145299,BLOCK,-1,,"{
    return args.GetReturnValue().Set(-1);
  }",25,,914,2,,void
145331,BLOCK,-1,,"{
    return args.GetReturnValue().Set(-1);
  }",40,,920,2,,void
145350,BLOCK,-1,,"{
    String::Value needle_value(isolate, needle);
    if (*needle_value == nullptr)
      return args.GetReturnValue().Set(-1);

    if (haystack_length < 2 || needle_value.length() < 1) {
      return args.GetReturnValue().Set(-1);
    }

    if (IsBigEndian()) {
      StringBytes::InlineDecoder decoder;
      if (decoder.Decode(env, needle, enc).IsNothing()) return;
      const uint16_t* decoded_string =
          reinterpret_cast<const uint16_t*>(decoder.out());

      if (decoded_string == nullptr)
        return args.GetReturnValue().Set(-1);

      result = SearchString(reinterpret_cast<const uint16_t*>(haystack),
                            haystack_length / 2,
                            decoded_string,
                            decoder.size() / 2,
                            offset / 2,
                            is_forward);
    } else {
      result = SearchString(reinterpret_cast<const uint16_t*>(haystack),
                            haystack_length / 2,
           ...",20,,926,2,,void
145360,BLOCK,-1,,<empty>,7,,929,2,,void
145382,BLOCK,-1,,"{
      return args.GetReturnValue().Set(-1);
    }",59,,931,2,,void
145395,BLOCK,-1,,"{
      StringBytes::InlineDecoder decoder;
      if (decoder.Decode(env, needle, enc).IsNothing()) return;
      const uint16_t* decoded_string =
          reinterpret_cast<const uint16_t*>(decoder.out());

      if (decoded_string == nullptr)
        return args.GetReturnValue().Set(-1);

      result = SearchString(reinterpret_cast<const uint16_t*>(haystack),
                            haystack_length / 2,
                            decoded_string,
                            decoder.size() / 2,
                            offset / 2,
                            is_forward);
    }",24,,935,2,,void
145408,BLOCK,-1,,<empty>,57,,937,2,,void
145423,BLOCK,-1,,<empty>,9,,942,2,,void
145455,BLOCK,-1,,"{
      result = SearchString(reinterpret_cast<const uint16_t*>(haystack),
                            haystack_length / 2,
                            reinterpret_cast<const uint16_t*>(*needle_value),
                            needle_value.length(),
                            offset / 2,
                            is_forward);
    }",12,,950,1,,void
145481,BLOCK,-1,,<empty>,10,,959,1,,void
145486,BLOCK,-1,,"{
    String::Utf8Value needle_value(isolate, needle);
    if (*needle_value == nullptr)
      return args.GetReturnValue().Set(-1);

    result = SearchString(reinterpret_cast<const uint8_t*>(haystack),
                          haystack_length,
                          reinterpret_cast<const uint8_t*>(*needle_value),
                          needle_length,
                          offset,
                          is_forward);
  }",27,,959,2,,void
145496,BLOCK,-1,,<empty>,7,,962,2,,void
145522,BLOCK,-1,,<empty>,10,,970,1,,void
145527,BLOCK,-1,,"{
    uint8_t* needle_data = node::UncheckedMalloc<uint8_t>(needle_length);
    if (needle_data == nullptr) {
      return args.GetReturnValue().Set(-1);
    }
    needle->WriteOneByte(
        isolate, needle_data, 0, needle_length, String::NO_NULL_TERMINATION);

    result = SearchString(reinterpret_cast<const uint8_t*>(haystack),
                          haystack_length,
                          needle_data,
                          needle_length,
                          offset,
                          is_forward);
    free(needle_data);
  }",29,,970,2,,void
145542,BLOCK,-1,,"{
      return args.GetReturnValue().Set(-1);
    }",33,,972,2,,void
145597,BLOCK,-1,,"{
  CHECK(args[1]->IsObject());
  CHECK(args[2]->IsNumber());
  CHECK(args[3]->IsInt32());
  CHECK(args[4]->IsBoolean());

  enum encoding enc = static_cast<enum encoding>(args[3].As<Int32>()->Value());

  THROW_AND_RETURN_UNLESS_BUFFER(Environment::GetCurrent(args), args[0]);
  THROW_AND_RETURN_UNLESS_BUFFER(Environment::GetCurrent(args), args[1]);
  ArrayBufferViewContents<char> haystack_contents(args[0]);
  ArrayBufferViewContents<char> needle_contents(args[1]);
  int64_t offset_i64 = args[2].As<Integer>()->Value();
  bool is_forward = args[4]->IsTrue();

  const char* haystack = haystack_contents.data();
  const size_t haystack_length = haystack_contents.length();
  const char* needle = needle_contents.data();
  const size_t needle_length = needle_contents.length();

  int64_t opt_offset = IndexOfOffset(haystack_length,
                                     offset_i64,
                                     needle_length,
                                     is_forward);

  if (nee...",61,,991,2,,void
145649,BLOCK,1,,<empty>,,,,3,,void
145669,BLOCK,1,,<empty>,,,,3,,void
145751,BLOCK,-1,,"{
    // Match String#indexOf() and String#lastIndexOf() behavior.
    args.GetReturnValue().Set(static_cast<double>(opt_offset));
    return;
  }",27,,1016,2,,void
145767,BLOCK,-1,,"{
    return args.GetReturnValue().Set(-1);
  }",29,,1022,2,,void
145783,BLOCK,-1,,"{
    return args.GetReturnValue().Set(-1);
  }",25,,1026,2,,void
145815,BLOCK,-1,,"{
    return args.GetReturnValue().Set(-1);
  }",40,,1032,2,,void
145834,BLOCK,-1,,"{
    if (haystack_length < 2 || needle_length < 2) {
      return args.GetReturnValue().Set(-1);
    }
    result = SearchString(
        reinterpret_cast<const uint16_t*>(haystack),
        haystack_length / 2,
        reinterpret_cast<const uint16_t*>(needle),
        needle_length / 2,
        offset / 2,
        is_forward);
    result *= 2;
  }",20,,1038,2,,void
145843,BLOCK,-1,,"{
      return args.GetReturnValue().Set(-1);
    }",51,,1039,2,,void
145877,BLOCK,-1,,"{
    result = SearchString(
        reinterpret_cast<const uint8_t*>(haystack),
        haystack_length,
        reinterpret_cast<const uint8_t*>(needle),
        needle_length,
        offset,
        is_forward);
  }",10,,1050,1,,void
145911,BLOCK,-1,,"{
  CHECK(args[1]->IsUint32());
  CHECK(args[2]->IsNumber());
  CHECK(args[3]->IsBoolean());

  THROW_AND_RETURN_UNLESS_BUFFER(Environment::GetCurrent(args), args[0]);
  ArrayBufferViewContents<char> buffer(args[0]);

  uint32_t needle = args[1].As<Uint32>()->Value();
  int64_t offset_i64 = args[2].As<Integer>()->Value();
  bool is_forward = args[3]->IsTrue();

  int64_t opt_offset =
      IndexOfOffset(buffer.length(), offset_i64, 1, is_forward);
  if (opt_offset <= -1 || buffer.length() == 0) {
    return args.GetReturnValue().Set(-1);
  }
  size_t offset = static_cast<size_t>(opt_offset);
  CHECK_LT(offset, buffer.length());

  const void* ptr;
  if (is_forward) {
    ptr = memchr(buffer.data() + offset, needle, buffer.length() - offset);
  } else {
    ptr = node::stringsearch::MemrchrFill(buffer.data(), needle, offset + 1);
  }
  const char* ptr_char = static_cast<const char*>(ptr);
  args.GetReturnValue().Set(ptr ? static_cast<int>(ptr_char - buffer.data())
                   ...",61,,1064,2,,void
145942,BLOCK,1,,<empty>,,,,3,,void
146014,BLOCK,-1,,"{
    return args.GetReturnValue().Set(-1);
  }",49,,1078,2,,void
146040,BLOCK,-1,,"{
    ptr = memchr(buffer.data() + offset, needle, buffer.length() - offset);
  }",19,,1085,2,,void
146058,BLOCK,-1,,"{
    ptr = node::stringsearch::MemrchrFill(buffer.data(), needle, offset + 1);
  }",10,,1087,1,,void
146104,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  THROW_AND_RETURN_UNLESS_BUFFER(env, args[0]);
  SPREAD_BUFFER_ARG(args[0], ts_obj);
  SwapBytes16(ts_obj_data, ts_obj_length);
  args.GetReturnValue().Set(args[0]);
}",54,,1096,2,,void
146118,BLOCK,1,,<empty>,,,,4,,void
146147,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  THROW_AND_RETURN_UNLESS_BUFFER(env, args[0]);
  SPREAD_BUFFER_ARG(args[0], ts_obj);
  SwapBytes32(ts_obj_data, ts_obj_length);
  args.GetReturnValue().Set(args[0]);
}",54,,1105,2,,void
146161,BLOCK,1,,<empty>,,,,4,,void
146190,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  THROW_AND_RETURN_UNLESS_BUFFER(env, args[0]);
  SPREAD_BUFFER_ARG(args[0], ts_obj);
  SwapBytes64(ts_obj_data, ts_obj_length);
  args.GetReturnValue().Set(args[0]);
}",54,,1114,2,,void
146204,BLOCK,1,,<empty>,,,,4,,void
146233,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsTypedArray() || args[0]->IsArrayBuffer() ||
        args[0]->IsSharedArrayBuffer());
  ArrayBufferViewContents<char> abv(args[0]);

  if (abv.WasDetached()) {
    return node::THROW_ERR_INVALID_STATE(
        env, ""Cannot validate on a detached buffer"");
  }

  args.GetReturnValue().Set(simdutf::validate_utf8(abv.data(), abv.length()));
}",61,,1122,2,,void
146279,BLOCK,-1,,"{
    return node::THROW_ERR_INVALID_STATE(
        env, ""Cannot validate on a detached buffer"");
  }",26,,1129,2,,void
146310,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsTypedArray() || args[0]->IsArrayBuffer() ||
        args[0]->IsSharedArrayBuffer());
  ArrayBufferViewContents<char> abv(args[0]);

  if (abv.WasDetached()) {
    return node::THROW_ERR_INVALID_STATE(
        env, ""Cannot validate on a detached buffer"");
  }

  args.GetReturnValue().Set(simdutf::validate_ascii(abv.data(), abv.length()));
}",62,,1137,2,,void
146356,BLOCK,-1,,"{
    return node::THROW_ERR_INVALID_STATE(
        env, ""Cannot validate on a detached buffer"");
  }",26,,1144,2,,void
146387,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(args);

  // TODO(legendecas): Remove this check once the binding supports sub-realms.
  CHECK_EQ(realm->kind(), Realm::Kind::kPrincipal);

  CHECK(args[0]->IsObject());
  Local<Object> proto = args[0].As<Object>();
  realm->set_buffer_prototype_object(proto);
}",66,,1152,2,,void
146434,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  NodeArrayBufferAllocator* allocator = env->isolate_data()->node_allocator();
  Local<ArrayBuffer> ab;
  // It can be a nullptr when running inside an isolate where we
  // do not own the ArrayBuffer allocator.
  if (allocator == nullptr) {
    // Create a dummy Uint32Array - the JS land can only toggle the C++ land
    // setting when the allocator uses our toggle. With this the toggle in JS
    // land results in no-ops.
    ab = ArrayBuffer::New(env->isolate(), sizeof(uint32_t));
  } else {
    uint32_t* zero_fill_field = allocator->zero_fill_field();
    std::unique_ptr<BackingStore> backing =
        ArrayBuffer::NewBackingStore(zero_fill_field,
                                     sizeof(*zero_fill_field),
                                     [](void*, size_t, void*) {},
                                     nullptr);
    ab = ArrayBuffer::New(env->isolate(), std::move(backing));
  }

  ab->SetPrivate(
      env->context(),...",65,,1163,2,,void
146462,BLOCK,-1,,"{
    // Create a dummy Uint32Array - the JS land can only toggle the C++ land
    // setting when the allocator uses our toggle. With this the toggle in JS
    // land results in no-ops.
    ab = ArrayBuffer::New(env->isolate(), sizeof(uint32_t));
  }",29,,1169,2,,void
146476,BLOCK,-1,,"{
    uint32_t* zero_fill_field = allocator->zero_fill_field();
    std::unique_ptr<BackingStore> backing =
        ArrayBuffer::NewBackingStore(zero_fill_field,
                                     sizeof(*zero_fill_field),
                                     [](void*, size_t, void*) {},
                                     nullptr);
    ab = ArrayBuffer::New(env->isolate(), std::move(backing));
  }",10,,1174,1,,void
146555,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  if (args[0]->IsArrayBuffer()) {
    Local<ArrayBuffer> buf = args[0].As<ArrayBuffer>();
    if (buf->IsDetachable()) {
      std::shared_ptr<BackingStore> store = buf->GetBackingStore();
      buf->Detach(Local<Value>()).Check();
      args.GetReturnValue().Set(ArrayBuffer::New(env->isolate(), store));
    }
  }
}",65,,1192,2,,void
146571,BLOCK,-1,,"{
    Local<ArrayBuffer> buf = args[0].As<ArrayBuffer>();
    if (buf->IsDetachable()) {
      std::shared_ptr<BackingStore> store = buf->GetBackingStore();
      buf->Detach(Local<Value>()).Check();
      args.GetReturnValue().Set(ArrayBuffer::New(env->isolate(), store));
    }
  }",33,,1194,2,,void
146589,BLOCK,-1,,"{
      std::shared_ptr<BackingStore> store = buf->GetBackingStore();
      buf->Detach(Local<Value>()).Check();
      args.GetReturnValue().Set(ArrayBuffer::New(env->isolate(), store));
    }",30,,1196,2,,void
146631,BLOCK,-1,,"{
  void* pointer;
  size_t byte_length;
  if (buffer->IsArrayBuffer()) {
    Local<ArrayBuffer> ab = buffer.As<ArrayBuffer>();
    pointer = ab->Data();
    byte_length = ab->ByteLength();
  } else if (buffer->IsSharedArrayBuffer()) {
    Local<SharedArrayBuffer> ab = buffer.As<SharedArrayBuffer>();
    pointer = ab->Data();
    byte_length = ab->ByteLength();
  } else {
    UNREACHABLE();  // Caller must validate.
  }
  return {pointer, byte_length};
}",70,,1206,2,,void
146639,BLOCK,-1,,"{
    Local<ArrayBuffer> ab = buffer.As<ArrayBuffer>();
    pointer = ab->Data();
    byte_length = ab->ByteLength();
  }",32,,1209,2,,void
146663,BLOCK,-1,,<empty>,10,,1213,1,,void
146669,BLOCK,-1,,"{
    Local<SharedArrayBuffer> ab = buffer.As<SharedArrayBuffer>();
    pointer = ab->Data();
    byte_length = ab->ByteLength();
  }",45,,1213,2,,void
146693,BLOCK,-1,,"{
    UNREACHABLE();  // Caller must validate.
  }",10,,1217,1,,void
146700,BLOCK,-1,,"{
  // args[0] == Destination ArrayBuffer
  // args[1] == Destination ArrayBuffer Offset
  // args[2] == Source ArrayBuffer
  // args[3] == Source ArrayBuffer Offset
  // args[4] == bytesToCopy

  CHECK(args[0]->IsArrayBuffer() || args[0]->IsSharedArrayBuffer());
  CHECK(args[1]->IsUint32());
  CHECK(args[2]->IsArrayBuffer() || args[2]->IsSharedArrayBuffer());
  CHECK(args[3]->IsUint32());
  CHECK(args[4]->IsUint32());

  void* destination;
  size_t destination_byte_length;
  std::tie(destination, destination_byte_length) =
      DecomposeBufferToParts(args[0]);

  void* source;
  size_t source_byte_length;
  std::tie(source, source_byte_length) = DecomposeBufferToParts(args[2]);

  uint32_t destination_offset = args[1].As<Uint32>()->Value();
  uint32_t source_offset = args[3].As<Uint32>()->Value();
  size_t bytes_to_copy = args[4].As<Uint32>()->Value();

  CHECK_GE(destination_byte_length - destination_offset, bytes_to_copy);
  CHECK_GE(source_byte_length - source_offset, bytes_to_...",63,,1225,2,,void
146849,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  SetMethod(context, target, ""setBufferPrototype"", SetBufferPrototype);
  SetMethodNoSideEffect(context, target, ""createFromString"", CreateFromString);

  SetFastMethodNoSideEffect(context,
                            target,
                            ""byteLengthUtf8"",
                            SlowByteLengthUtf8,
                            &fast_byte_length_utf8);
  SetMethod(context, target, ""copy"", Copy);
  SetMethodNoSideEffect(context, target, ""compare"", Compare);
  SetMethodNoSideEffect(context, target, ""compareOffset"", CompareOffset);
  SetMethod(context, target, ""fill"", Fill);
  SetMethodNoSideEffect(context, target, ""indexOfBuffer"", IndexOfBuffer);
  SetMethodNoSideEffect(context, target, ""indexOfNumber"", IndexOfNumber);
  SetMethodNoSideEffect(context, target, ""indexOfString"", IndexOfString);

  SetMethod(context, target, ""detachArrayBuffer"", DetachArrayBuffer);
  SetMethod(...",29,,1262,5,,void
147067,BLOCK,-1,,"{
  registry->Register(SetBufferPrototype);
  registry->Register(CreateFromString);

  registry->Register(SlowByteLengthUtf8);
  registry->Register(fast_byte_length_utf8.GetTypeInfo());
  registry->Register(FastByteLengthUtf8);
  registry->Register(Copy);
  registry->Register(Compare);
  registry->Register(CompareOffset);
  registry->Register(Fill);
  registry->Register(IndexOfBuffer);
  registry->Register(IndexOfNumber);
  registry->Register(IndexOfString);

  registry->Register(Swap16);
  registry->Register(Swap32);
  registry->Register(Swap64);

  registry->Register(IsUtf8);
  registry->Register(IsAscii);

  registry->Register(StringSlice<ASCII>);
  registry->Register(StringSlice<BASE64>);
  registry->Register(StringSlice<BASE64URL>);
  registry->Register(StringSlice<LATIN1>);
  registry->Register(StringSlice<HEX>);
  registry->Register(StringSlice<UCS2>);
  registry->Register(StringSlice<UTF8>);

  registry->Register(StringWrite<ASCII>);
  registry->Register(StringWrite<BASE64>)...",70,,1326,2,,void
147252,BLOCK,-1,,<empty>,1,,1,1,,ANY
147266,BLOCK,-1,,<empty>,,,,3,,<empty>
147271,BLOCK,-1,,<empty>,,,,2,,<empty>
147276,BLOCK,-1,,<empty>,,,,2,,<empty>
147281,BLOCK,-1,,<empty>,,,,2,,<empty>
147288,BLOCK,-1,,<empty>,,,,4,,<empty>
147294,BLOCK,-1,,<empty>,,,,3,,<empty>
147301,BLOCK,-1,,<empty>,,,,4,,<empty>
147310,BLOCK,-1,,<empty>,,,,6,,<empty>
147317,BLOCK,-1,,<empty>,,,,4,,<empty>
147325,BLOCK,-1,,<empty>,,,,5,,<empty>
147332,BLOCK,-1,,"{
  // Asking to seek too far into the buffer
  // check to avoid wrapping in subsequent subtraction
  if (off > max)
    return false;

  // Asking for more than is left over in the buffer
  if (max - off < len)
    return false;

  // Otherwise we're in bounds
  return true;
}",71,,75,4,,void
147337,BLOCK,-1,,<empty>,5,,79,2,,void
147346,BLOCK,-1,,<empty>,5,,83,2,,void
147373,BLOCK,-1,,<empty>,1,,1,1,,ANY
147377,BLOCK,-1,,"{
  LoadJavaScriptSource();
#ifdef NODE_SHARED_BUILTIN_CJS_MODULE_LEXER_LEXER_PATH
  AddExternalizedBuiltin(
      ""internal/deps/cjs-module-lexer/lexer"",
      STRINGIFY(NODE_SHARED_BUILTIN_CJS_MODULE_LEXER_LEXER_PATH));
#endif  // NODE_SHARED_BUILTIN_CJS_MODULE_LEXER_LEXER_PATH

#ifdef NODE_SHARED_BUILTIN_CJS_MODULE_LEXER_DIST_LEXER_PATH
  AddExternalizedBuiltin(
      ""internal/deps/cjs-module-lexer/dist/lexer"",
      STRINGIFY(NODE_SHARED_BUILTIN_CJS_MODULE_LEXER_DIST_LEXER_PATH));
#endif  // NODE_SHARED_BUILTIN_CJS_MODULE_LEXER_DIST_LEXER_PATH

#ifdef NODE_SHARED_BUILTIN_UNDICI_UNDICI_PATH
  AddExternalizedBuiltin(""internal/deps/undici/undici"",
                         STRINGIFY(NODE_SHARED_BUILTIN_UNDICI_UNDICI_PATH));
#endif  // NODE_SHARED_BUILTIN_UNDICI_UNDICI_PATH
}",79,,36,1,,void
147383,BLOCK,-1,,"{
  auto source = source_.read();
  return source->find(id) != source->end();
}",44,,56,2,,void
147407,BLOCK,-1,,"{
  auto result = source_.write()->emplace(id, source);
  return result.second;
}",67,,61,3,,void
147429,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();

  Local<Object> out = Object::New(isolate);
  auto source = env->builtin_loader()->source_.read();
  for (auto const& x : *source) {
    Local<String> key = OneByteString(isolate, x.first.c_str(), x.first.size());
    out->Set(context, key, x.second.ToStringChecked(isolate)).FromJust();
  }
  info.GetReturnValue().Set(out);
}",73,,67,3,,void
147482,BLOCK,-1,,"{
    Local<String> key = OneByteString(isolate, x.first.c_str(), x.first.size());
    out->Set(context, key, x.second.ToStringChecked(isolate)).FromJust();
  }",33,,74,3,,void
147531,BLOCK,-1,,"{
  return config_.ToStringChecked(isolate);
}",64,,81,2,,void
147541,BLOCK,-1,,"{
  std::vector<std::string> ids;
  auto source = source_.read();
  ids.reserve(source->size());
  for (auto const& x : *source) {
    ids.emplace_back(x.first);
  }
  return ids;
}",63,,85,1,,void
147570,BLOCK,-1,,"{
    ids.emplace_back(x.first);
  }",33,,89,3,,void
147583,BLOCK,-1,,"{
  BuiltinCategories builtin_categories;

  std::vector<std::string> prefixes = {
#if !HAVE_OPENSSL
    ""internal/crypto/"",
    ""internal/debugger/"",
#endif  // !HAVE_OPENSSL

    ""internal/bootstrap/"",
    ""internal/per_context/"",
    ""internal/deps/"",
    ""internal/main/""
  };

  builtin_categories.can_be_required.emplace(
      ""internal/deps/cjs-module-lexer/lexer"");

  builtin_categories.cannot_be_required = std::set<std::string> {
#if !HAVE_INSPECTOR
    ""inspector"", ""inspector/promises"", ""internal/util/inspector"",
#endif  // !HAVE_INSPECTOR

#if !NODE_USE_V8_PLATFORM || !defined(NODE_HAVE_I18N_SUPPORT)
        ""trace_events"",
#endif  // !NODE_USE_V8_PLATFORM || !defined(NODE_HAVE_I18N_SUPPORT)

#if !HAVE_OPENSSL
        ""crypto"", ""crypto/promises"", ""https"", ""http2"", ""tls"", ""_tls_common"",
        ""_tls_wrap"", ""internal/tls/secure-pair"",
        ""internal/tls/parse-cert-string"", ""internal/tls/secure-context"",
        ""internal/http2/core"", ""internal/http2/compat"",
        ""int...",78,,95,1,,void
147643,BLOCK,-1,,"{
    const std::string& id = x.first;
    for (auto const& prefix : prefixes) {
      if (prefix.length() > id.length()) {
        continue;
      }
      if (id.find(prefix) == 0 &&
          builtin_categories.can_be_required.count(id) == 0) {
        builtin_categories.cannot_be_required.emplace(id);
      }
    }
  }",33,,137,3,,void
147653,BLOCK,-1,,"{
      if (prefix.length() > id.length()) {
        continue;
      }
      if (id.find(prefix) == 0 &&
          builtin_categories.can_be_required.count(id) == 0) {
        builtin_categories.cannot_be_required.emplace(id);
      }
    }",41,,139,3,,void
147664,BLOCK,-1,,"{
        continue;
      }",42,,140,2,,void
147684,BLOCK,-1,,"{
        builtin_categories.cannot_be_required.emplace(id);
      }",62,,144,2,,void
147696,BLOCK,-1,,"{
    const std::string& id = x.first;
    if (0 == builtin_categories.cannot_be_required.count(id)) {
      builtin_categories.can_be_required.emplace(id);
    }
  }",33,,150,3,,void
147713,BLOCK,-1,,"{
      builtin_categories.can_be_required.emplace(id);
    }",63,,152,2,,void
147728,BLOCK,-1,,"{
  auto source = source_.read();
#ifndef NODE_BUILTIN_MODULES_PATH
  const auto source_it = source->find(id);
  if (UNLIKELY(source_it == source->end())) {
    fprintf(stderr, ""Cannot find native builtin: \""%s\"".\n"", id);
    ABORT();
  }
  return source_it->second.ToStringChecked(isolate);
#else   // !NODE_BUILTIN_MODULES_PATH
  std::string filename = OnDiskFileName(id);

  std::string contents;
  int r = ReadFileSync(&contents, filename.c_str());
  if (r != 0) {
    const std::string buf = SPrintF(""Cannot read local builtin. %s: %s \""%s\"""",
                                    uv_err_name(r),
                                    uv_strerror(r),
                                    filename);
    Local<String> message = OneByteString(isolate, buf.c_str());
    isolate->ThrowException(v8::Exception::Error(message));
    return MaybeLocal<String>();
  }
  return String::NewFromUtf8(
      isolate, contents.c_str(), v8::NewStringType::kNormal, contents.length());
#endif  // NODE_BUILTIN...",75,,178,3,,void
147752,BLOCK,-1,,"{
    fprintf(stderr, ""Cannot find native builtin: \""%s\"".\n"", id);
    ABORT();
  }",45,,182,2,,void
147774,BLOCK,-1,,"{
  StaticExternalTwoByteResource* resource;
  {
    Mutex::ScopedLock lock(externalized_builtins_mutex);
    auto it = externalized_builtin_sources.find(id);
    if (it == externalized_builtin_sources.end()) {
      std::string source;
      int r = ReadFileSync(&source, filename);
      if (r != 0) {
        fprintf(stderr,
                ""Cannot load externalized builtin: \""%s:%s\"".\n"",
                id,
                filename);
        ABORT();
      }
      size_t expected_u16_length =
          simdutf::utf16_length_from_utf8(source.data(), source.length());
      auto out = std::make_shared<std::vector<uint16_t>>(expected_u16_length);
      size_t u16_length = simdutf::convert_utf8_to_utf16(
          source.data(),
          source.length(),
          reinterpret_cast<char16_t*>(out->data()));
      out->resize(u16_length);

      auto result = externalized_builtin_sources.emplace(
          id,
          std::make_unique<StaticExternalTwoByteResource>(
              ou...",66,,213,3,,void
147776,BLOCK,2,,"{
    Mutex::ScopedLock lock(externalized_builtins_mutex);
    auto it = externalized_builtin_sources.find(id);
    if (it == externalized_builtin_sources.end()) {
      std::string source;
      int r = ReadFileSync(&source, filename);
      if (r != 0) {
        fprintf(stderr,
                ""Cannot load externalized builtin: \""%s:%s\"".\n"",
                id,
                filename);
        ABORT();
      }
      size_t expected_u16_length =
          simdutf::utf16_length_from_utf8(source.data(), source.length());
      auto out = std::make_shared<std::vector<uint16_t>>(expected_u16_length);
      size_t u16_length = simdutf::convert_utf8_to_utf16(
          source.data(),
          source.length(),
          reinterpret_cast<char16_t*>(out->data()));
      out->resize(u16_length);

      auto result = externalized_builtin_sources.emplace(
          id,
          std::make_unique<StaticExternalTwoByteResource>(
              out->data(), out->size(), out));
      CHECK(resu...",3,,215,2,,void
147795,BLOCK,-1,,"{
      std::string source;
      int r = ReadFileSync(&source, filename);
      if (r != 0) {
        fprintf(stderr,
                ""Cannot load externalized builtin: \""%s:%s\"".\n"",
                id,
                filename);
        ABORT();
      }
      size_t expected_u16_length =
          simdutf::utf16_length_from_utf8(source.data(), source.length());
      auto out = std::make_shared<std::vector<uint16_t>>(expected_u16_length);
      size_t u16_length = simdutf::convert_utf8_to_utf16(
          source.data(),
          source.length(),
          reinterpret_cast<char16_t*>(out->data()));
      out->resize(u16_length);

      auto result = externalized_builtin_sources.emplace(
          id,
          std::make_unique<StaticExternalTwoByteResource>(
              out->data(), out->size(), out));
      CHECK(result.second);
      it = result.first;
    }",51,,218,2,,void
147808,BLOCK,-1,,"{
        fprintf(stderr,
                ""Cannot load externalized builtin: \""%s:%s\"".\n"",
                id,
                filename);
        ABORT();
      }",19,,221,2,,void
147923,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  EscapableHandleScope scope(isolate);

  Local<String> source;
  if (!LoadBuiltinSource(isolate, id).ToLocal(&source)) {
    return {};
  }

  std::string filename_s = std::string(""node:"") + id;
  Local<String> filename =
      OneByteString(isolate, filename_s.c_str(), filename_s.size());
  ScriptOrigin origin(isolate, filename, 0, 0, true);

  BuiltinCodeCacheData cached_data{};
  {
    // Note: The lock here should not extend into the
    // `CompileFunction()` call below, because this function may recurse if
    // there is a syntax error during bootstrap (because the fatal exception
    // handler is invoked, which may load built-in modules).
    RwLock::ScopedLock lock(code_cache_->mutex);
    auto cache_it = code_cache_->map.find(id);
    if (cache_it != code_cache_->map.end()) {
      // Transfer ownership to ScriptCompiler::Source later.
      cached_data = cache_it->second;
    }
  }

  const bool has_cache = cached_data.data ...",36,,257,5,,void
147949,BLOCK,-1,,"{
    return {};
  }",57,,262,2,,void
147988,BLOCK,14,,"{
    // Note: The lock here should not extend into the
    // `CompileFunction()` call below, because this function may recurse if
    // there is a syntax error during bootstrap (because the fatal exception
    // handler is invoked, which may load built-in modules).
    RwLock::ScopedLock lock(code_cache_->mutex);
    auto cache_it = code_cache_->map.find(id);
    if (cache_it != code_cache_->map.end()) {
      // Transfer ownership to ScriptCompiler::Source later.
      cached_data = cache_it->second;
    }
  }",3,,272,14,,void
148013,BLOCK,-1,,"{
      // Transfer ownership to ScriptCompiler::Source later.
      cached_data = cache_it->second;
    }",45,,279,2,,void
148102,BLOCK,-1,,"{
    // In the case of early errors, v8 is already capable of
    // decorating the stack for us - note that we use CompileFunction
    // so there is no need to worry about wrappers.
    return MaybeLocal<Function>();
  }",33,,311,2,,void
148126,BLOCK,-1,,"{
    per_process::Debug(DebugCategory::CODE_CACHE,
                       ""Code cache of %s (%s) %s\n"",
                       id,
                       script_source.GetCachedData()->buffer_policy ==
                               ScriptCompiler::CachedData::BufferNotOwned
                           ? ""BufferNotOwned""
                           : ""BufferOwned"",
                       script_source.GetCachedData()->rejected ? ""is rejected""
                                                               : ""is accepted"");
  }",18,,327,2,,void
148167,BLOCK,-1,,"{
    // We failed to accept this cache, maybe because it was rejected, maybe
    // because it wasn't present. Either way, we'll attempt to replace this
    // code cache info with a new one.
    std::shared_ptr<ScriptCompiler::CachedData> new_cached_data(
        ScriptCompiler::CreateCodeCacheForFunction(fun));
    CHECK_NOT_NULL(new_cached_data);

    {
      RwLock::ScopedLock lock(code_cache_->mutex);
      code_cache_->map.insert_or_assign(
          id, BuiltinCodeCacheData(std::move(new_cached_data)));
    }
  }",41,,339,2,,void
148170,BLOCK,-1,,<empty>,,,,2,,<empty>
148175,BLOCK,3,,"{
      RwLock::ScopedLock lock(code_cache_->mutex);
      code_cache_->map.insert_or_assign(
          id, BuiltinCodeCacheData(std::move(new_cached_data)));
    }",5,,347,3,,void
148206,BLOCK,-1,,"{
  Result result;
  std::vector<Local<String>> parameters;
  Isolate* isolate = context->GetIsolate();
  // Detects parameters of the scripts based on module ids.
  // internal/bootstrap/realm: process, getLinkedBinding,
  //                           getInternalBinding, primordials
  if (strcmp(id, ""internal/bootstrap/realm"") == 0) {
    parameters = {
        FIXED_ONE_BYTE_STRING(isolate, ""process""),
        FIXED_ONE_BYTE_STRING(isolate, ""getLinkedBinding""),
        FIXED_ONE_BYTE_STRING(isolate, ""getInternalBinding""),
        FIXED_ONE_BYTE_STRING(isolate, ""primordials""),
    };
  } else if (strncmp(id,
                     ""internal/per_context/"",
                     strlen(""internal/per_context/"")) == 0) {
    // internal/per_context/*: global, exports, primordials
    parameters = {
        FIXED_ONE_BYTE_STRING(isolate, ""exports""),
        FIXED_ONE_BYTE_STRING(isolate, ""primordials""),
    };
  } else if (strncmp(id, ""internal/main/"", strlen(""internal/main/"")) == 0 ||
   ...",77,,359,4,,void
148230,BLOCK,-1,,"{
    parameters = {
        FIXED_ONE_BYTE_STRING(isolate, ""process""),
        FIXED_ONE_BYTE_STRING(isolate, ""getLinkedBinding""),
        FIXED_ONE_BYTE_STRING(isolate, ""getInternalBinding""),
        FIXED_ONE_BYTE_STRING(isolate, ""primordials""),
    };
  }",52,,366,2,,void
148234,BLOCK,-1,,<empty>,10,,373,1,,void
148243,BLOCK,-1,,"{
    // internal/per_context/*: global, exports, primordials
    parameters = {
        FIXED_ONE_BYTE_STRING(isolate, ""exports""),
        FIXED_ONE_BYTE_STRING(isolate, ""primordials""),
    };
  }",61,,375,2,,void
148247,BLOCK,-1,,<empty>,10,,381,1,,void
148264,BLOCK,-1,,"{
    // internal/main/*, internal/bootstrap/*: process, require,
    //                                        internalBinding, primordials
    parameters = {
        FIXED_ONE_BYTE_STRING(isolate, ""process""),
        FIXED_ONE_BYTE_STRING(isolate, ""require""),
        FIXED_ONE_BYTE_STRING(isolate, ""internalBinding""),
        FIXED_ONE_BYTE_STRING(isolate, ""primordials""),
    };
  }",59,,384,2,,void
148268,BLOCK,-1,,"{
    // others: exports, require, module, process, internalBinding, primordials
    parameters = {
        FIXED_ONE_BYTE_STRING(isolate, ""exports""),
        FIXED_ONE_BYTE_STRING(isolate, ""require""),
        FIXED_ONE_BYTE_STRING(isolate, ""module""),
        FIXED_ONE_BYTE_STRING(isolate, ""process""),
        FIXED_ONE_BYTE_STRING(isolate, ""internalBinding""),
        FIXED_ONE_BYTE_STRING(isolate, ""primordials""),
    };
  }",10,,393,1,,void
148288,BLOCK,-1,,"{
    DCHECK_EQ(this, optional_realm->env()->builtin_loader());
    RecordResult(id, result, optional_realm);
  }",34,,407,2,,void
148310,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  // Arguments must match the parameters specified in
  // BuiltinLoader::LookupAndCompile().
  std::vector<Local<Value>> arguments;
  // Detects parameters of the scripts based on module ids.
  // internal/bootstrap/realm: process, getLinkedBinding,
  //                           getInternalBinding, primordials
  if (strcmp(id, ""internal/bootstrap/realm"") == 0) {
    Local<Value> get_linked_binding;
    Local<Value> get_internal_binding;
    if (!NewFunctionTemplate(isolate, binding::GetLinkedBinding)
             ->GetFunction(context)
             .ToLocal(&get_linked_binding) ||
        !NewFunctionTemplate(isolate, binding::GetInternalBinding)
             ->GetFunction(context)
             .ToLocal(&get_internal_binding)) {
      return MaybeLocal<Value>();
    }
    arguments = {realm->process_object(),
                 get_linked_binding,
                 get_internal_binding,
                 realm->primordials()};
  } else if ...",63,,416,4,,void
148333,BLOCK,-1,,"{
    Local<Value> get_linked_binding;
    Local<Value> get_internal_binding;
    if (!NewFunctionTemplate(isolate, binding::GetLinkedBinding)
             ->GetFunction(context)
             .ToLocal(&get_linked_binding) ||
        !NewFunctionTemplate(isolate, binding::GetInternalBinding)
             ->GetFunction(context)
             .ToLocal(&get_internal_binding)) {
      return MaybeLocal<Value>();
    }
    arguments = {realm->process_object(),
                 get_linked_binding,
                 get_internal_binding,
                 realm->primordials()};
  }",52,,424,2,,void
148376,BLOCK,-1,,"{
      return MaybeLocal<Value>();
    }",47,,432,2,,void
148382,BLOCK,-1,,<empty>,10,,439,1,,void
148399,BLOCK,-1,,"{
    // internal/main/*, internal/bootstrap/*: process, require,
    //                                        internalBinding, primordials
    arguments = {realm->process_object(),
                 realm->builtin_module_require(),
                 realm->internal_binding_loader(),
                 realm->primordials()};
  }",59,,442,2,,void
148403,BLOCK,-1,,"{
    // This should be invoked with the other CompileAndCall() methods, as
    // we are unable to generate the arguments.
    // Currently there are two cases:
    // internal/per_context/*: the arguments are generated in
    //                         InitializePrimordials()
    // all the other cases: the arguments are generated in the JS-land loader.
    UNREACHABLE();
  }",10,,449,1,,void
148426,BLOCK,-1,,"{
  // Arguments must match the parameters specified in
  // BuiltinLoader::LookupAndCompile().
  MaybeLocal<Function> maybe_fn = LookupAndCompile(context, id, optional_realm);
  Local<Function> fn;
  if (!maybe_fn.ToLocal(&fn)) {
    return MaybeLocal<Value>();
  }
  Local<Value> undefined = Undefined(context->GetIsolate());
  return fn->Call(context, undefined, argc, argv);
}",72,,465,6,,void
148450,BLOCK,-1,,"{
    return MaybeLocal<Value>();
  }",31,,470,2,,void
148477,BLOCK,-1,,"{
  std::vector<std::string> ids = GetBuiltinIds();
  bool all_succeeded = true;
  std::string v8_tools_prefix = ""internal/deps/v8/tools/"";
  for (const auto& id : ids) {
    if (id.compare(0, v8_tools_prefix.size(), v8_tools_prefix) == 0) {
      continue;
    }
    v8::TryCatch bootstrapCatch(context->GetIsolate());
    USE(LookupAndCompile(context, id.c_str(), nullptr));
    if (bootstrapCatch.HasCaught()) {
      per_process::Debug(DebugCategory::CODE_CACHE,
                         ""Failed to compile code cache for %s\n"",
                         id.c_str());
      all_succeeded = false;
      PrintCaughtException(context->GetIsolate(), context, bootstrapCatch);
    }
  }
  return all_succeeded;
}",64,,477,2,,void
148500,BLOCK,-1,,"{
    if (id.compare(0, v8_tools_prefix.size(), v8_tools_prefix) == 0) {
      continue;
    }
    v8::TryCatch bootstrapCatch(context->GetIsolate());
    USE(LookupAndCompile(context, id.c_str(), nullptr));
    if (bootstrapCatch.HasCaught()) {
      per_process::Debug(DebugCategory::CODE_CACHE,
                         ""Failed to compile code cache for %s\n"",
                         id.c_str());
      all_succeeded = false;
      PrintCaughtException(context->GetIsolate(), context, bootstrapCatch);
    }
  }",30,,481,3,,void
148514,BLOCK,-1,,"{
      continue;
    }",70,,482,2,,void
148535,BLOCK,-1,,"{
      per_process::Debug(DebugCategory::CODE_CACHE,
                         ""Failed to compile code cache for %s\n"",
                         id.c_str());
      all_succeeded = false;
      PrintCaughtException(context->GetIsolate(), context, bootstrapCatch);
    }",37,,487,2,,void
148564,BLOCK,-1,,"{
  RwLock::ScopedReadLock lock(code_cache_->mutex);
  for (auto const& item : code_cache_->map) {
    out->push_back({item.first, item.second});
  }
}",74,,498,2,,void
148575,BLOCK,-1,,"{
    out->push_back({item.first, item.second});
  }",45,,500,3,,void
148591,BLOCK,-1,,"{
  RwLock::ScopedLock lock(code_cache_->mutex);
  code_cache_->map.reserve(in.size());
  DCHECK(code_cache_->map.empty());
  for (auto const& item : in) {
    auto result = code_cache_->map.emplace(item.id, item.data);
    USE(result.second);
    DCHECK(result.second);
  }
  code_cache_->has_code_cache = true;
}",76,,505,2,,void
148617,BLOCK,-1,,"{
    auto result = code_cache_->map.emplace(item.id, item.data);
    USE(result.second);
    DCHECK(result.second);
  }",31,,509,3,,void
148651,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();
  Local<Object> result = Object::New(isolate);

  BuiltinCategories builtin_categories =
      env->builtin_loader()->GetBuiltinCategories();

  if (!env->owns_process_state()) {
    builtin_categories.can_be_required.erase(""trace_events"");
    builtin_categories.cannot_be_required.insert(""trace_events"");
  }

  Local<Value> cannot_be_required_js;
  Local<Value> can_be_required_js;

  if (!ToV8Value(context, builtin_categories.cannot_be_required)
           .ToLocal(&cannot_be_required_js))
    return;
  if (result
          ->Set(context,
                OneByteString(isolate, ""cannotBeRequired""),
                cannot_be_required_js)
          .IsNothing())
    return;
  if (!ToV8Value(context, builtin_categories.can_be_required)
           .ToLocal(&can_be_required_js))
    return;
  if (result
          ->Set(context,
                OneByteStrin...",68,,518,3,,void
148704,BLOCK,-1,,"{
    builtin_categories.can_be_required.erase(""trace_events"");
    builtin_categories.cannot_be_required.insert(""trace_events"");
  }",35,,527,2,,void
148741,BLOCK,-1,,<empty>,5,,537,2,,void
148756,BLOCK,-1,,<empty>,5,,543,2,,void
148770,BLOCK,-1,,<empty>,5,,546,2,,void
148785,BLOCK,-1,,"{
    return;
  }",25,,551,2,,void
148799,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(args);
  Isolate* isolate = realm->isolate();
  Local<Context> context = realm->context();
  Local<Object> result = Object::New(isolate);

  Local<Value> builtins_with_cache_js;
  Local<Value> builtins_without_cache_js;
  Local<Value> builtins_in_snapshot_js;
  if (!ToV8Value(context, realm->builtins_with_cache)
           .ToLocal(&builtins_with_cache_js)) {
    return;
  }
  if (result
          ->Set(context,
                OneByteString(isolate, ""compiledWithCache""),
                builtins_with_cache_js)
          .IsNothing()) {
    return;
  }

  if (!ToV8Value(context, realm->builtins_without_cache)
           .ToLocal(&builtins_without_cache_js)) {
    return;
  }
  if (result
          ->Set(context,
                OneByteString(isolate, ""compiledWithoutCache""),
                builtins_without_cache_js)
          .IsNothing()) {
    return;
  }

  if (!ToV8Value(context, realm->builtins_in_snapshot)
           .ToLocal(&builtins_in_...",76,,557,2,,void
148863,BLOCK,-1,,"{
    return;
  }",47,,567,2,,void
148878,BLOCK,-1,,"{
    return;
  }",25,,574,2,,void
148892,BLOCK,-1,,"{
    return;
  }",50,,579,2,,void
148907,BLOCK,-1,,"{
    return;
  }",25,,586,2,,void
148921,BLOCK,-1,,"{
    return;
  }",48,,591,2,,void
148936,BLOCK,-1,,"{
    return;
  }",25,,598,2,,void
148951,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  Isolate* isolate = env->isolate();

  std::vector<std::string> ids = env->builtin_loader()->GetBuiltinIds();
  info.GetReturnValue().Set(
      ToV8Value(isolate->GetCurrentContext(), ids).ToLocalChecked());
}",79,,606,3,,void
149005,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  info.GetReturnValue().Set(
      env->builtin_loader()->GetConfigString(info.GetIsolate()));
}",68,,616,3,,void
149038,BLOCK,-1,,"{
  if (result == BuiltinLoader::Result::kWithCache) {
    realm->builtins_with_cache.insert(id);
  } else {
    realm->builtins_without_cache.insert(id);
  }
}",48,,624,4,,void
149047,BLOCK,-1,,"{
    realm->builtins_with_cache.insert(id);
  }",52,,625,2,,void
149056,BLOCK,-1,,"{
    realm->builtins_without_cache.insert(id);
  }",10,,627,1,,void
149068,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(args);
  CHECK(args[0]->IsString());
  node::Utf8Value id_v(realm->isolate(), args[0].As<String>());
  const char* id = *id_v;
  MaybeLocal<Function> maybe = realm->env()->builtin_loader()->LookupAndCompile(
      realm->context(), id, realm);
  Local<Function> fn;
  if (maybe.ToLocal(&fn)) {
    args.GetReturnValue().Set(fn);
  }
}",78,,632,2,,void
149135,BLOCK,-1,,"{
    args.GetReturnValue().Set(fn);
  }",27,,640,2,,void
149148,BLOCK,-1,,"{
  auto instance = Environment::GetCurrent(args)->builtin_loader();
  RwLock::ScopedReadLock lock(instance->code_cache_->mutex);
  args.GetReturnValue().Set(v8::Boolean::New(
      args.GetIsolate(), instance->code_cache_->has_code_cache));
}",80,,645,2,,void
149193,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(args);
  CHECK(args[0]->IsFunction());
  CHECK(args[1]->IsFunction());
  DCHECK(realm->internal_binding_loader().IsEmpty());
  DCHECK(realm->builtin_module_require().IsEmpty());
  realm->set_internal_binding_loader(args[0].As<Function>());
  realm->set_builtin_module_require(args[1].As<Function>());
}",66,,652,2,,void
149256,BLOCK,-1,,"{
  code_cache_ = other->code_cache_;
  source_ = other->source_;
}",33,,663,2,,void
149272,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();

  target->SetAccessor(isolate_data->config_string(),
                      ConfigStringGetter,
                      nullptr,
                      Local<Value>(),
                      DEFAULT,
                      None,
                      SideEffectType::kHasNoSideEffect);

  target->SetAccessor(FIXED_ONE_BYTE_STRING(isolate, ""builtinIds""),
                      BuiltinIdsGetter,
                      nullptr,
                      Local<Value>(),
                      DEFAULT,
                      None,
                      SideEffectType::kHasNoSideEffect);

  target->SetAccessor(FIXED_ONE_BYTE_STRING(isolate, ""builtinCategories""),
                      GetBuiltinCategories,
                      nullptr,
                      Local<Value>(),
                      DEFAULT,
                      None,
                      SideEffectType::kHasNoSideEffect);

  target->SetAccessor(FIXED_ONE_BYTE_STRING(isolate, ""natives""),
   ...",78,,669,3,,void
149372,BLOCK,-1,,"{
  // internalBinding('builtins') should be frozen
  target->SetIntegrityLevel(context, IntegrityLevel::kFrozen).FromJust();
}",60,,713,5,,void
149388,BLOCK,-1,,"{
  registry->Register(ConfigStringGetter);
  registry->Register(BuiltinIdsGetter);
  registry->Register(GetBuiltinCategories);
  registry->Register(GetCacheUsage);
  registry->Register(CompileFunction);
  registry->Register(HasCachedBuiltins);
  registry->Register(SetInternalLoaders);
  registry->Register(GetNatives);

  RegisterExternalReferencesForInternalizedBuiltinCode(registry);
}",42,,719,2,,void
149462,BLOCK,-1,,<empty>,1,,1,1,,ANY
149481,BLOCK,-1,,<empty>,1,,1,1,,ANY
149488,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

#if defined(DEBUG) && DEBUG
  READONLY_TRUE_PROPERTY(target, ""isDebugBuild"");
#else
  READONLY_FALSE_PROPERTY(target, ""isDebugBuild"");
#endif  // defined(DEBUG) && DEBUG

#if HAVE_OPENSSL
  READONLY_TRUE_PROPERTY(target, ""hasOpenSSL"");
#else
  READONLY_FALSE_PROPERTY(target, ""hasOpenSSL"");
#endif  // HAVE_OPENSSL

  READONLY_TRUE_PROPERTY(target, ""fipsMode"");

#ifdef NODE_HAVE_I18N_SUPPORT

  READONLY_TRUE_PROPERTY(target, ""hasIntl"");

#ifdef NODE_HAVE_SMALL_ICU
  READONLY_TRUE_PROPERTY(target, ""hasSmallICU"");
#endif  // NODE_HAVE_SMALL_ICU

#if NODE_USE_V8_PLATFORM
  READONLY_TRUE_PROPERTY(target, ""hasTracing"");
#endif

#if !defined(NODE_WITHOUT_NODE_OPTIONS)
  READONLY_TRUE_PROPERTY(target, ""hasNodeOptions"");
#endif

#endif  // NODE_HAVE_I18N_SUPPORT

#if HAVE_INSPECTOR
  READONLY_TRUE_PROPERTY(target, ""hasInspector"");
#else
  READONLY_FALSE_PROPERTY(target, ""hasInspector"");
#endif

// c...",36,,29,5,,void
149572,BLOCK,-1,,<empty>,1,,1,1,,ANY
149577,BLOCK,-1,,"{
#ifdef E2BIG
  NODE_DEFINE_CONSTANT(target, E2BIG);
#endif

#ifdef EACCES
  NODE_DEFINE_CONSTANT(target, EACCES);
#endif

#ifdef EADDRINUSE
  NODE_DEFINE_CONSTANT(target, EADDRINUSE);
#endif

#ifdef EADDRNOTAVAIL
  NODE_DEFINE_CONSTANT(target, EADDRNOTAVAIL);
#endif

#ifdef EAFNOSUPPORT
  NODE_DEFINE_CONSTANT(target, EAFNOSUPPORT);
#endif

#ifdef EAGAIN
  NODE_DEFINE_CONSTANT(target, EAGAIN);
#endif

#ifdef EALREADY
  NODE_DEFINE_CONSTANT(target, EALREADY);
#endif

#ifdef EBADF
  NODE_DEFINE_CONSTANT(target, EBADF);
#endif

#ifdef EBADMSG
  NODE_DEFINE_CONSTANT(target, EBADMSG);
#endif

#ifdef EBUSY
  NODE_DEFINE_CONSTANT(target, EBUSY);
#endif

#ifdef ECANCELED
  NODE_DEFINE_CONSTANT(target, ECANCELED);
#endif

#ifdef ECHILD
  NODE_DEFINE_CONSTANT(target, ECHILD);
#endif

#ifdef ECONNABORTED
  NODE_DEFINE_CONSTANT(target, ECONNABORTED);
#endif

#ifdef ECONNREFUSED
  NODE_DEFINE_CONSTANT(target, ECONNREFUSED);
#endif

#ifdef ECONNRESET
  NODE_DEFINE_CONSTANT(target, ECONNRESET);
#...",49,,75,2,,void
149582,BLOCK,-1,,"{
#ifdef WSAEINTR
  NODE_DEFINE_CONSTANT(target, WSAEINTR);
#endif

#ifdef WSAEBADF
  NODE_DEFINE_CONSTANT(target, WSAEBADF);
#endif

#ifdef WSAEACCES
  NODE_DEFINE_CONSTANT(target, WSAEACCES);
#endif

#ifdef WSAEFAULT
  NODE_DEFINE_CONSTANT(target, WSAEFAULT);
#endif

#ifdef WSAEINVAL
  NODE_DEFINE_CONSTANT(target, WSAEINVAL);
#endif

#ifdef WSAEMFILE
  NODE_DEFINE_CONSTANT(target, WSAEMFILE);
#endif

#ifdef WSAEWOULDBLOCK
  NODE_DEFINE_CONSTANT(target, WSAEWOULDBLOCK);
#endif

#ifdef WSAEINPROGRESS
  NODE_DEFINE_CONSTANT(target, WSAEINPROGRESS);
#endif

#ifdef WSAEALREADY
  NODE_DEFINE_CONSTANT(target, WSAEALREADY);
#endif

#ifdef WSAENOTSOCK
  NODE_DEFINE_CONSTANT(target, WSAENOTSOCK);
#endif

#ifdef WSAEDESTADDRREQ
  NODE_DEFINE_CONSTANT(target, WSAEDESTADDRREQ);
#endif

#ifdef WSAEMSGSIZE
  NODE_DEFINE_CONSTANT(target, WSAEMSGSIZE);
#endif

#ifdef WSAEPROTOTYPE
  NODE_DEFINE_CONSTANT(target, WSAEPROTOTYPE);
#endif

#ifdef WSAENOPROTOOPT
  NODE_DEFINE_CONSTANT(target, WSAENOPROT...",56,,393,2,,void
149587,BLOCK,-1,,"{
#ifdef SIGHUP
  NODE_DEFINE_CONSTANT(target, SIGHUP);
#endif

#ifdef SIGINT
  NODE_DEFINE_CONSTANT(target, SIGINT);
#endif

#ifdef SIGQUIT
  NODE_DEFINE_CONSTANT(target, SIGQUIT);
#endif

#ifdef SIGILL
  NODE_DEFINE_CONSTANT(target, SIGILL);
#endif

#ifdef SIGTRAP
  NODE_DEFINE_CONSTANT(target, SIGTRAP);
#endif

#ifdef SIGABRT
  NODE_DEFINE_CONSTANT(target, SIGABRT);
#endif

#ifdef SIGIOT
  NODE_DEFINE_CONSTANT(target, SIGIOT);
#endif

#ifdef SIGBUS
  NODE_DEFINE_CONSTANT(target, SIGBUS);
#endif

#ifdef SIGFPE
  NODE_DEFINE_CONSTANT(target, SIGFPE);
#endif

#ifdef SIGKILL
  NODE_DEFINE_CONSTANT(target, SIGKILL);
#endif

#ifdef SIGUSR1
  NODE_DEFINE_CONSTANT(target, SIGUSR1);
#endif

#ifdef SIGSEGV
  NODE_DEFINE_CONSTANT(target, SIGSEGV);
#endif

#ifdef SIGUSR2
  NODE_DEFINE_CONSTANT(target, SIGUSR2);
#endif

#ifdef SIGPIPE
  NODE_DEFINE_CONSTANT(target, SIGPIPE);
#endif

#ifdef SIGALRM
  NODE_DEFINE_CONSTANT(target, SIGALRM);
#endif

  NODE_DEFINE_CONSTANT(target, SIGTERM);

#ifde...",50,,627,2,,void
149595,BLOCK,-1,,"{
#ifdef UV_PRIORITY_LOW
# define PRIORITY_LOW UV_PRIORITY_LOW
  NODE_DEFINE_CONSTANT(target, PRIORITY_LOW);
# undef PRIORITY_LOW
#endif

#ifdef UV_PRIORITY_BELOW_NORMAL
# define PRIORITY_BELOW_NORMAL UV_PRIORITY_BELOW_NORMAL
  NODE_DEFINE_CONSTANT(target, PRIORITY_BELOW_NORMAL);
# undef PRIORITY_BELOW_NORMAL
#endif

#ifdef UV_PRIORITY_NORMAL
# define PRIORITY_NORMAL UV_PRIORITY_NORMAL
  NODE_DEFINE_CONSTANT(target, PRIORITY_NORMAL);
# undef PRIORITY_NORMAL
#endif

#ifdef UV_PRIORITY_ABOVE_NORMAL
# define PRIORITY_ABOVE_NORMAL UV_PRIORITY_ABOVE_NORMAL
  NODE_DEFINE_CONSTANT(target, PRIORITY_ABOVE_NORMAL);
# undef PRIORITY_ABOVE_NORMAL
#endif

#ifdef UV_PRIORITY_HIGH
# define PRIORITY_HIGH UV_PRIORITY_HIGH
  NODE_DEFINE_CONSTANT(target, PRIORITY_HIGH);
# undef PRIORITY_HIGH
#endif

#ifdef UV_PRIORITY_HIGHEST
# define PRIORITY_HIGHEST UV_PRIORITY_HIGHEST
  NODE_DEFINE_CONSTANT(target, PRIORITY_HIGHEST);
# undef PRIORITY_HIGHEST
#endif
}",52,,776,2,,void
149600,BLOCK,-1,,"{
#ifdef OPENSSL_VERSION_NUMBER
    NODE_DEFINE_CONSTANT(target, OPENSSL_VERSION_NUMBER);
#endif

#ifdef SSL_OP_ALL
    NODE_DEFINE_CONSTANT(target, SSL_OP_ALL);
#endif

#ifdef SSL_OP_ALLOW_NO_DHE_KEX
    NODE_DEFINE_CONSTANT(target, SSL_OP_ALLOW_NO_DHE_KEX);
#endif

#ifdef SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION
    NODE_DEFINE_CONSTANT(target, SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION);
#endif

#ifdef SSL_OP_CIPHER_SERVER_PREFERENCE
    NODE_DEFINE_CONSTANT(target, SSL_OP_CIPHER_SERVER_PREFERENCE);
#endif

#ifdef SSL_OP_CISCO_ANYCONNECT
    NODE_DEFINE_CONSTANT(target, SSL_OP_CISCO_ANYCONNECT);
#endif

#ifdef SSL_OP_COOKIE_EXCHANGE
    NODE_DEFINE_CONSTANT(target, SSL_OP_COOKIE_EXCHANGE);
#endif

#ifdef SSL_OP_CRYPTOPRO_TLSEXT_BUG
    NODE_DEFINE_CONSTANT(target, SSL_OP_CRYPTOPRO_TLSEXT_BUG);
#endif

#ifdef SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS
    NODE_DEFINE_CONSTANT(target, SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS);
#endif

#ifdef SSL_OP_LEGACY_SERVER_CONNECT
    NODE_DEFINE_CONSTANT(ta...",50,,814,2,,void
149605,BLOCK,-1,,"{
  NODE_DEFINE_CONSTANT(target, UV_FS_SYMLINK_DIR);
  NODE_DEFINE_CONSTANT(target, UV_FS_SYMLINK_JUNCTION);
  // file access modes
  NODE_DEFINE_CONSTANT(target, O_RDONLY);
  NODE_DEFINE_CONSTANT(target, O_WRONLY);
  NODE_DEFINE_CONSTANT(target, O_RDWR);

  // file types from readdir
  NODE_DEFINE_CONSTANT(target, UV_DIRENT_UNKNOWN);
  NODE_DEFINE_CONSTANT(target, UV_DIRENT_FILE);
  NODE_DEFINE_CONSTANT(target, UV_DIRENT_DIR);
  NODE_DEFINE_CONSTANT(target, UV_DIRENT_LINK);
  NODE_DEFINE_CONSTANT(target, UV_DIRENT_FIFO);
  NODE_DEFINE_CONSTANT(target, UV_DIRENT_SOCKET);
  NODE_DEFINE_CONSTANT(target, UV_DIRENT_CHAR);
  NODE_DEFINE_CONSTANT(target, UV_DIRENT_BLOCK);

  NODE_DEFINE_CONSTANT(target, S_IFMT);
  NODE_DEFINE_CONSTANT(target, S_IFREG);
  NODE_DEFINE_CONSTANT(target, S_IFDIR);
  NODE_DEFINE_CONSTANT(target, S_IFCHR);
#ifdef S_IFBLK
  NODE_DEFINE_CONSTANT(target, S_IFBLK);
#endif

#ifdef S_IFIFO
  NODE_DEFINE_CONSTANT(target, S_IFIFO);
#endif

#ifdef S_IFLNK
  NODE_DEFINE_C...",50,,1043,2,,void
149664,BLOCK,-1,,"{
#ifdef RTLD_LAZY
  NODE_DEFINE_CONSTANT(target, RTLD_LAZY);
#endif

#ifdef RTLD_NOW
  NODE_DEFINE_CONSTANT(target, RTLD_NOW);
#endif

#ifdef RTLD_GLOBAL
  NODE_DEFINE_CONSTANT(target, RTLD_GLOBAL);
#endif

#ifdef RTLD_LOCAL
  NODE_DEFINE_CONSTANT(target, RTLD_LOCAL);
#endif

#ifdef RTLD_DEEPBIND
  NODE_DEFINE_CONSTANT(target, RTLD_DEEPBIND);
#endif
}",50,,1226,2,,void
149669,BLOCK,-1,,"{
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_BEGIN);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_END);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_COMPLETE);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_INSTANT);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_ASYNC_BEGIN);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_ASYNC_STEP_INTO);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_ASYNC_STEP_PAST);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_ASYNC_END);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_NESTABLE_ASYNC_BEGIN);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_NESTABLE_ASYNC_END);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_NESTABLE_ASYNC_INSTANT);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_FLOW_BEGIN);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_FLOW_STEP);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_FLOW_END);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_METADATA);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHAS...",49,,1248,2,,void
149755,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  Environment* env = Environment::GetCurrent(context);

  CHECK(target->SetPrototype(env->context(), Null(env->isolate())).FromJust());

  Local<Object> os_constants = Object::New(isolate);
  CHECK(os_constants->SetPrototype(env->context(),
                                   Null(env->isolate())).FromJust());

  Local<Object> err_constants = Object::New(isolate);
  CHECK(err_constants->SetPrototype(env->context(),
                                    Null(env->isolate())).FromJust());

  Local<Object> sig_constants = Object::New(isolate);
  CHECK(sig_constants->SetPrototype(env->context(),
                                    Null(env->isolate())).FromJust());

  Local<Object> priority_constants = Object::New(isolate);
  CHECK(priority_constants->SetPrototype(env->context(),
                                         Null(env->isolate())).FromJust());

  Local<Object> fs_constants = Object::New(isolate);
  CHECK(fs_constants->SetPrototype(en...",45,,1280,5,,void
150199,BLOCK,-1,,<empty>,1,,1,1,,ANY
150208,BLOCK,-1,,<empty>,1,,1,1,,ANY
150212,BLOCK,-1,,"{
        if (desc.has_enumerable()) {
          desc_for_sandbox->set_enumerable(desc.enumerable());
        }
        if (desc.has_configurable()) {
          desc_for_sandbox->set_configurable(desc.configurable());
        }
        // Set the property on the sandbox.
        USE(sandbox->DefineProperty(context, property, *desc_for_sandbox));
      }",50,,598,2,,void
150218,BLOCK,-1,,"{
          desc_for_sandbox->set_enumerable(desc.enumerable());
        }",36,,599,2,,void
150232,BLOCK,-1,,"{
          desc_for_sandbox->set_configurable(desc.configurable());
        }",38,,602,2,,void
150257,BLOCK,-1,,"{
    MaybeLocal<Value> result = script->Run(context);
    if (!result.IsEmpty() && mtask_queue)
      mtask_queue->PerformCheckpoint(env->isolate());
    return result;
  }",20,,1053,1,,void
150277,BLOCK,-1,,<empty>,7,,1056,2,,void
150318,BLOCK,-1,,<empty>,1,,1,1,,ANY
150325,BLOCK,-1,,"{
  return Uint32::New(context->GetIsolate(), index)->ToString(context)
      .ToLocalChecked();
}",66,,105,3,,void
150349,BLOCK,-1,,"{
  HandleScope scope(env->isolate());
  Local<ObjectTemplate> object_template = env->contextify_global_template();
  DCHECK(!object_template.IsEmpty());
  const SnapshotData* snapshot_data = env->isolate_data()->snapshot_data();

  MicrotaskQueue* queue =
      options.microtask_queue_wrap
          ? options.microtask_queue_wrap->microtask_queue().get()
          : env->isolate()->GetCurrentContext()->GetMicrotaskQueue();

  Local<Context> v8_context;
  if (!(CreateV8Context(env->isolate(), object_template, snapshot_data, queue)
            .ToLocal(&v8_context))) {
    // Allocation failure, maximum call stack size reached, termination, etc.
    return BaseObjectPtr<ContextifyContext>();
  }
  return New(v8_context, env, sandbox_obj, options);
}",36,,115,4,,void
150428,BLOCK,-1,,"{
    // Allocation failure, maximum call stack size reached, termination, etc.
    return BaseObjectPtr<ContextifyContext>();
  }",37,,128,2,,void
150441,BLOCK,-1,,"{
  if (microtask_queue_wrap_) {
    tracker->TrackField(""microtask_queue_wrap"",
                        microtask_queue_wrap_->object());
  }
}",66,,135,2,,void
150444,BLOCK,-1,,"{
    tracker->TrackField(""microtask_queue_wrap"",
                        microtask_queue_wrap_->object());
  }",30,,136,2,,void
150461,BLOCK,-1,,"{
  context_.Reset(env->isolate(), v8_context);
  // This should only be done after the initial initializations of the context
  // global object is finished.
  DCHECK_NULL(v8_context->GetAlignedPointerFromEmbedderData(
      ContextEmbedderIndex::kContextifyContext));
  v8_context->SetAlignedPointerInEmbedderData(
      ContextEmbedderIndex::kContextifyContext, this);
  // It's okay to make this reference weak - V8 would create an internal
  // reference to this context via the constructor of the wrapper.
  // As long as the wrapper is alive, it's constructor is alive, and so
  // is the context.
  context_.SetWeak();
}",59,,147,5,,void
150494,BLOCK,-1,,"{
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);

  env()->UnassignFromContext(PersistentToLocal::Weak(isolate, context_));
  context_.Reset();
}",41,,162,1,,void
150523,BLOCK,-1,,"{
  DCHECK(isolate_data->contextify_wrapper_template().IsEmpty());
  Local<FunctionTemplate> global_func_template =
      FunctionTemplate::New(isolate_data->isolate());
  Local<ObjectTemplate> global_object_template =
      global_func_template->InstanceTemplate();

  NamedPropertyHandlerConfiguration config(
      PropertyGetterCallback,
      PropertySetterCallback,
      PropertyDescriptorCallback,
      PropertyDeleterCallback,
      PropertyEnumeratorCallback,
      PropertyDefinerCallback,
      {},
      PropertyHandlerFlags::kHasNoSideEffect);

  IndexedPropertyHandlerConfiguration indexed_config(
      IndexedPropertyGetterCallback,
      IndexedPropertySetterCallback,
      IndexedPropertyDescriptorCallback,
      IndexedPropertyDeleterCallback,
      PropertyEnumeratorCallback,
      IndexedPropertyDefinerCallback,
      {},
      PropertyHandlerFlags::kHasNoSideEffect);

  global_object_template->SetHandler(config);
  global_object_template->SetHandler(indexed_config);
...",78,,170,2,,void
150628,BLOCK,-1,,"{
  EscapableHandleScope scope(isolate);

  Local<Context> ctx;
  if (snapshot_data == nullptr) {
    ctx = Context::New(isolate,
                       nullptr,  // extensions
                       object_template,
                       {},  // global object
                       {},  // deserialization callback
                       queue);
    if (ctx.IsEmpty() || InitializeBaseContextForSnapshot(ctx).IsNothing()) {
      return MaybeLocal<Context>();
    }
  } else if (!Context::FromSnapshot(isolate,
                                    SnapshotData::kNodeVMContextIndex,
                                    {},       // deserialization callback
                                    nullptr,  // extensions
                                    {},       // global object
                                    queue)
                  .ToLocal(&ctx)) {
    return MaybeLocal<Context>();
  }

  return scope.Escape(ctx);
}",28,,212,5,,void
150641,BLOCK,-1,,"{
    ctx = Context::New(isolate,
                       nullptr,  // extensions
                       object_template,
                       {},  // global object
                       {},  // deserialization callback
                       queue);
    if (ctx.IsEmpty() || InitializeBaseContextForSnapshot(ctx).IsNothing()) {
      return MaybeLocal<Context>();
    }
  }",33,,216,2,,void
150665,BLOCK,-1,,"{
      return MaybeLocal<Context>();
    }",77,,223,2,,void
150669,BLOCK,-1,,<empty>,10,,226,1,,void
150689,BLOCK,-1,,"{
    return MaybeLocal<Context>();
  }",35,,232,2,,void
150705,BLOCK,-1,,"{
  HandleScope scope(env->isolate());
  // This only initializes part of the context. The primordials are
  // only initialized when needed because even deserializing them slows
  // things down significantly and they are only needed in rare occasions
  // in the vm contexts.
  if (InitializeContextRuntime(v8_context).IsNothing()) {
    return BaseObjectPtr<ContextifyContext>();
  }

  Local<Context> main_context = env->context();
  Local<Object> new_context_global = v8_context->Global();
  v8_context->SetSecurityToken(main_context->GetSecurityToken());

  // We need to tie the lifetime of the sandbox object with the lifetime of
  // newly created context. We do this by making them hold references to each
  // other. The context can directly hold a reference to the sandbox as an
  // embedder data field. The sandbox uses a private symbol to hold a reference
  // to the ContextifyContext wrapper which in turn internally references
  // the context from its constructor.
  v8_context-...",36,,243,5,,void
150718,BLOCK,-1,,"{
    return BaseObjectPtr<ContextifyContext>();
  }",57,,249,2,,void
150803,BLOCK,-1,,"{
    Utf8Value origin_val(env->isolate(), options.origin);
    info.origin = *origin_val;
  }",34,,277,2,,void
150829,BLOCK,18,,"{
    Context::Scope context_scope(v8_context);
    Local<String> ctor_name = sandbox_obj->GetConstructorName();
    if (!ctor_name->Equals(v8_context, env->object_string()).FromMaybe(false) &&
        new_context_global
            ->DefineOwnProperty(
                v8_context,
                v8::Symbol::GetToStringTag(env->isolate()),
                ctor_name,
                static_cast<v8::PropertyAttribute>(v8::DontEnum))
            .IsNothing()) {
      return BaseObjectPtr<ContextifyContext>();
    }
    env->AssignToContext(v8_context, nullptr, info);

    if (!env->contextify_wrapper_template()
             ->NewInstance(v8_context)
             .ToLocal(&wrapper)) {
      return BaseObjectPtr<ContextifyContext>();
    }

    result =
        MakeBaseObject<ContextifyContext>(env, wrapper, v8_context, options);
    // The only strong reference to the wrapper will come from the sandbox.
    result->MakeWeak();
  }",3,,284,18,,void
150883,BLOCK,-1,,"{
      return BaseObjectPtr<ContextifyContext>();
    }",27,,294,2,,void
150908,BLOCK,-1,,"{
      return BaseObjectPtr<ContextifyContext>();
    }",34,,301,2,,void
150941,BLOCK,-1,,"{
    return BaseObjectPtr<ContextifyContext>();
  }",25,,314,2,,void
150951,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();
  SetMethod(isolate, target, ""makeContext"", MakeContext);
  SetMethod(isolate, target, ""isContext"", IsContext);
  SetMethod(isolate, target, ""compileFunction"", CompileFunction);
}",62,,322,3,,void
150978,BLOCK,-1,,"{
  registry->Register(MakeContext);
  registry->Register(IsContext);
  registry->Register(CompileFunction);
  registry->Register(PropertyGetterCallback);
  registry->Register(PropertySetterCallback);
  registry->Register(PropertyDescriptorCallback);
  registry->Register(PropertyDeleterCallback);
  registry->Register(PropertyEnumeratorCallback);
  registry->Register(PropertyDefinerCallback);
  registry->Register(IndexedPropertyGetterCallback);
  registry->Register(IndexedPropertySetterCallback);
  registry->Register(IndexedPropertyDescriptorCallback);
  registry->Register(IndexedPropertyDeleterCallback);
  registry->Register(IndexedPropertyDefinerCallback);
}",42,,330,2,,void
151053,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK_EQ(args.Length(), 6);
  CHECK(args[0]->IsObject());
  Local<Object> sandbox = args[0].As<Object>();

  // Don't allow contextifying a sandbox multiple times.
  CHECK(
      !sandbox->HasPrivate(
          env->context(),
          env->contextify_context_private_symbol()).FromJust());

  ContextOptions options;

  CHECK(args[1]->IsString());
  options.name = args[1].As<String>();

  CHECK(args[2]->IsString() || args[2]->IsUndefined());
  if (args[2]->IsString()) {
    options.origin = args[2].As<String>();
  }

  CHECK(args[3]->IsBoolean());
  options.allow_code_gen_strings = args[3].As<Boolean>();

  CHECK(args[4]->IsBoolean());
  options.allow_code_gen_wasm = args[4].As<Boolean>();

  if (args[5]->IsObject() &&
      !env->microtask_queue_ctor_template().IsEmpty() &&
      env->microtask_queue_ctor_template()->HasInstance(args[5])) {
    options.microtask_queue_wrap.reset(
        Unwrap<MicrotaskQueueWrap>(args[5].As<...",78,,348,2,,void
151143,BLOCK,-1,,"{
    options.origin = args[2].As<String>();
  }",28,,367,2,,void
151215,BLOCK,-1,,"{
    options.microtask_queue_wrap.reset(
        Unwrap<MicrotaskQueueWrap>(args[5].As<Object>()));
  }",67,,379,2,,void
151253,BLOCK,-1,,"{
    if (!try_catch.HasTerminated())
      try_catch.ReThrow();
    return;
  }",30,,388,2,,void
151260,BLOCK,-1,,<empty>,7,,390,2,,void
151270,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsObject());
  Local<Object> sandbox = args[0].As<Object>();

  Maybe<bool> result =
      sandbox->HasPrivate(env->context(),
                          env->contextify_context_private_symbol());
  args.GetReturnValue().Set(result.FromJust());
}",76,,396,2,,void
151328,BLOCK,-1,,"{
  ContextifyContext* context = data.GetParameter();
  delete context;
}",54,,410,2,,void
151343,BLOCK,-1,,"{
  Local<Value> context_global;
  if (sandbox
          ->GetPrivate(env->context(), env->contextify_context_private_symbol())
          .ToLocal(&context_global) &&
      context_global->IsObject()) {
    return Unwrap<ContextifyContext>(context_global.As<Object>());
  }
  return nullptr;
}",35,,418,3,,void
151372,BLOCK,-1,,"{
    return Unwrap<ContextifyContext>(context_global.As<Object>());
  }",35,,423,2,,void
151388,BLOCK,-1,,"{
  return Get(args.This());
}",80,,430,2,,void
151399,BLOCK,-1,,"{
  Local<Context> context;
  if (!object->GetCreationContext().ToLocal(&context)) {
    return nullptr;
  }
  if (!ContextEmbedderTag::IsNodeContext(context)) {
    return nullptr;
  }
  return static_cast<ContextifyContext*>(
      context->GetAlignedPointerFromEmbedderData(
          ContextEmbedderIndex::kContextifyContext));
}",65,,434,2,,void
151416,BLOCK,-1,,"{
    return nullptr;
  }",56,,436,2,,void
151426,BLOCK,-1,,"{
    return nullptr;
  }",52,,439,2,,void
151443,BLOCK,-1,,"{
  return ctx == nullptr || ctx->context_.IsEmpty();
}",75,,447,2,,void
151460,BLOCK,-1,,"{
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  Local<Context> context = ctx->context();
  Local<Object> sandbox = ctx->sandbox();
  MaybeLocal<Value> maybe_rv =
      sandbox->GetRealNamedProperty(context, property);
  if (maybe_rv.IsEmpty()) {
    maybe_rv =
        ctx->global_proxy()->GetRealNamedProperty(context, property);
  }

  Local<Value> rv;
  if (maybe_rv.ToLocal(&rv)) {
    if (rv == sandbox)
      rv = ctx->global_proxy();

    args.GetReturnValue().Set(rv);
  }
}",46,,454,3,,void
151472,BLOCK,-1,,<empty>,33,,458,2,,void
151511,BLOCK,-1,,"{
    maybe_rv =
        ctx->global_proxy()->GetRealNamedProperty(context, property);
  }",27,,464,2,,void
151535,BLOCK,-1,,"{
    if (rv == sandbox)
      rv = ctx->global_proxy();

    args.GetReturnValue().Set(rv);
  }",30,,470,2,,void
151540,BLOCK,-1,,<empty>,7,,472,2,,void
151561,BLOCK,-1,,"{
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  Local<Context> context = ctx->context();
  PropertyAttribute attributes = PropertyAttribute::None;
  bool is_declared_on_global_proxy = ctx->global_proxy()
      ->GetRealNamedPropertyAttributes(context, property)
      .To(&attributes);
  bool read_only =
      static_cast<int>(attributes) &
      static_cast<int>(PropertyAttribute::ReadOnly);

  bool is_declared_on_sandbox = ctx->sandbox()
      ->GetRealNamedPropertyAttributes(context, property)
      .To(&attributes);
  read_only = read_only ||
      (static_cast<int>(attributes) &
      static_cast<int>(PropertyAttribute::ReadOnly));

  if (read_only)
    return;

  // true for x = 5
  // false for this.x = 5
  // false for Object.defineProperty(this, 'foo', ...)
  // false for vmResult.x = 5 where vmResult = vm.runInContext();
  bool is_contextual_store = ctx->global_proxy() != args.This();

  // Indic...",46,,482,4,,void
151573,BLOCK,-1,,<empty>,33,,486,2,,void
151652,BLOCK,-1,,<empty>,5,,505,2,,void
151692,BLOCK,-1,,<empty>,5,,525,2,,void
151702,BLOCK,-1,,<empty>,45,,527,2,,void
151718,BLOCK,-1,,<empty>,66,,528,2,,void
151748,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(context);
    Local<Object> desc_obj = desc.As<Object>();

    // We have to specify the return value for any contextual or get/set
    // property
    if (desc_obj->HasOwnProperty(context, env->get_string()).FromMaybe(false) ||
        desc_obj->HasOwnProperty(context, env->set_string()).FromMaybe(false))
      args.GetReturnValue().Set(value);
  }",29,,535,2,,void
151795,BLOCK,-1,,<empty>,7,,543,2,,void
151809,BLOCK,-1,,"{
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  Local<Context> context = ctx->context();

  Local<Object> sandbox = ctx->sandbox();

  if (sandbox->HasOwnProperty(context, property).FromMaybe(false)) {
    Local<Value> desc;
    if (sandbox->GetOwnPropertyDescriptor(context, property).ToLocal(&desc)) {
      args.GetReturnValue().Set(desc);
    }
  }
}",46,,550,3,,void
151821,BLOCK,-1,,<empty>,33,,554,2,,void
151854,BLOCK,-1,,"{
    Local<Value> desc;
    if (sandbox->GetOwnPropertyDescriptor(context, property).ToLocal(&desc)) {
      args.GetReturnValue().Set(desc);
    }
  }",68,,560,2,,void
151872,BLOCK,-1,,"{
      args.GetReturnValue().Set(desc);
    }",78,,562,2,,void
151885,BLOCK,-1,,"{
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  Local<Context> context = ctx->context();
  Isolate* isolate = context->GetIsolate();

  PropertyAttribute attributes = PropertyAttribute::None;
  bool is_declared =
      ctx->global_proxy()->GetRealNamedPropertyAttributes(context,
                                                          property)
          .To(&attributes);
  bool read_only =
      static_cast<int>(attributes) &
          static_cast<int>(PropertyAttribute::ReadOnly);

  // If the property is set on the global as read_only, don't change it on
  // the global or sandbox.
  if (is_declared && read_only)
    return;

  Local<Object> sandbox = ctx->sandbox();

  auto define_prop_on_sandbox =
      [&] (PropertyDescriptor* desc_for_sandbox) {
        if (desc.has_enumerable()) {
          desc_for_sandbox->set_enumerable(desc.enumerable());
        }
        if (desc.has_configurable()) {
     ...",46,,572,4,,void
151897,BLOCK,-1,,<empty>,33,,576,2,,void
151955,BLOCK,-1,,<empty>,5,,593,2,,void
151981,BLOCK,-1,,"{
    PropertyDescriptor desc_for_sandbox(
        desc.has_get() ? desc.get() : Undefined(isolate).As<Value>(),
        desc.has_set() ? desc.set() : Undefined(isolate).As<Value>());

    define_prop_on_sandbox(&desc_for_sandbox);
  }",41,,609,2,,void
152016,BLOCK,-1,,"{
    Local<Value> value =
        desc.has_value() ? desc.value() : Undefined(isolate).As<Value>();

    if (desc.has_writable()) {
      PropertyDescriptor desc_for_sandbox(value, desc.writable());
      define_prop_on_sandbox(&desc_for_sandbox);
    } else {
      PropertyDescriptor desc_for_sandbox(value);
      define_prop_on_sandbox(&desc_for_sandbox);
    }
  }",10,,615,1,,void
152042,BLOCK,-1,,"{
      PropertyDescriptor desc_for_sandbox(value, desc.writable());
      define_prop_on_sandbox(&desc_for_sandbox);
    }",30,,619,2,,void
152054,BLOCK,-1,,"{
      PropertyDescriptor desc_for_sandbox(value);
      define_prop_on_sandbox(&desc_for_sandbox);
    }",12,,622,1,,void
152066,BLOCK,-1,,"{
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  Maybe<bool> success = ctx->sandbox()->Delete(ctx->context(), property);

  if (success.FromMaybe(false))
    return;

  // Delete failed on the sandbox, intercept and do not delete on
  // the global object.
  args.GetReturnValue().Set(false);
}",48,,632,3,,void
152078,BLOCK,-1,,<empty>,33,,636,2,,void
152101,BLOCK,-1,,<empty>,5,,641,2,,void
152115,BLOCK,-1,,"{
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  Local<Array> properties;

  if (!ctx->sandbox()->GetPropertyNames(ctx->context()).ToLocal(&properties))
    return;

  args.GetReturnValue().Set(properties);
}",46,,650,2,,void
152127,BLOCK,-1,,<empty>,33,,654,2,,void
152152,BLOCK,-1,,<empty>,5,,659,2,,void
152167,BLOCK,-1,,"{
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  ContextifyContext::PropertyGetterCallback(
      Uint32ToName(ctx->context(), index), args);
}",46,,667,3,,void
152179,BLOCK,-1,,<empty>,33,,671,2,,void
152198,BLOCK,-1,,"{
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  ContextifyContext::PropertySetterCallback(
      Uint32ToName(ctx->context(), index), value, args);
}",46,,681,4,,void
152210,BLOCK,-1,,<empty>,33,,685,2,,void
152229,BLOCK,-1,,"{
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  ContextifyContext::PropertyDescriptorCallback(
      Uint32ToName(ctx->context(), index), args);
}",46,,694,3,,void
152241,BLOCK,-1,,<empty>,33,,698,2,,void
152260,BLOCK,-1,,"{
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  ContextifyContext::PropertyDefinerCallback(
      Uint32ToName(ctx->context(), index), desc, args);
}",46,,708,4,,void
152272,BLOCK,-1,,<empty>,33,,712,2,,void
152291,BLOCK,-1,,"{
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  Maybe<bool> success = ctx->sandbox()->Delete(ctx->context(), index);

  if (success.FromMaybe(false))
    return;

  // Delete failed on the sandbox, intercept and do not delete on
  // the global object.
  args.GetReturnValue().Set(false);
}",48,,721,3,,void
152303,BLOCK,-1,,<empty>,33,,725,2,,void
152326,BLOCK,-1,,<empty>,5,,730,2,,void
152341,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();
  Local<String> class_name = FIXED_ONE_BYTE_STRING(isolate, ""ContextifyScript"");

  Local<FunctionTemplate> script_tmpl = NewFunctionTemplate(isolate, New);
  script_tmpl->InstanceTemplate()->SetInternalFieldCount(
      ContextifyScript::kInternalFieldCount);
  script_tmpl->SetClassName(class_name);
  SetProtoMethod(isolate, script_tmpl, ""createCachedData"", CreateCachedData);
  SetProtoMethod(isolate, script_tmpl, ""runInContext"", RunInContext);

  target->Set(isolate, ""ContextifyScript"", script_tmpl);
  isolate_data->set_script_context_constructor_template(script_tmpl);
}",62,,738,3,,void
152408,BLOCK,-1,,"{
  registry->Register(New);
  registry->Register(CreateCachedData);
  registry->Register(RunInContext);
}",42,,754,2,,void
152428,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();

  CHECK(args.IsConstructCall());

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  CHECK(args[0]->IsString());
  Local<String> code = args[0].As<String>();

  CHECK(args[1]->IsString());
  Local<String> filename = args[1].As<String>();

  int line_offset = 0;
  int column_offset = 0;
  Local<ArrayBufferView> cached_data_buf;
  bool produce_cached_data = false;
  Local<Context> parsing_context = context;

  if (argc > 2) {
    // new ContextifyScript(code, filename, lineOffset, columnOffset,
    //                      cachedData, produceCachedData, parsingContext)
    CHECK_EQ(argc, 7);
    CHECK(args[2]->IsNumber());
    line_offset = args[2].As<Int32>()->Value();
    CHECK(args[3]->IsNumber());
    column_offset = args[3].As<Int32>()->Value();
    if (!args[4]->IsUndefined()) {
      CHECK(args[4]->IsArrayBufferView());
      cached_data_b...",69,,760,2,,void
152535,BLOCK,-1,,"{
    // new ContextifyScript(code, filename, lineOffset, columnOffset,
    //                      cachedData, produceCachedData, parsingContext)
    CHECK_EQ(argc, 7);
    CHECK(args[2]->IsNumber());
    line_offset = args[2].As<Int32>()->Value();
    CHECK(args[3]->IsNumber());
    column_offset = args[3].As<Int32>()->Value();
    if (!args[4]->IsUndefined()) {
      CHECK(args[4]->IsArrayBufferView());
      cached_data_buf = args[4].As<ArrayBufferView>();
    }
    CHECK(args[5]->IsBoolean());
    produce_cached_data = args[5]->IsTrue();
    if (!args[6]->IsUndefined()) {
      CHECK(args[6]->IsObject());
      ContextifyContext* sandbox =
          ContextifyContext::ContextFromContextifiedSandbox(
              env, args[6].As<Object>());
      CHECK_NOT_NULL(sandbox);
      parsing_context = sandbox->context();
    }
  }",17,,782,2,,void
152583,BLOCK,-1,,"{
      CHECK(args[4]->IsArrayBufferView());
      cached_data_buf = args[4].As<ArrayBufferView>();
    }",34,,790,2,,void
152622,BLOCK,-1,,"{
      CHECK(args[6]->IsObject());
      ContextifyContext* sandbox =
          ContextifyContext::ContextFromContextifiedSandbox(
              env, args[6].As<Object>());
      CHECK_NOT_NULL(sandbox);
      parsing_context = sandbox->context();
    }",34,,796,2,,void
152670,BLOCK,-1,,"{
    Utf8Value fn(isolate, filename);
    TRACE_EVENT_BEGIN1(TRACING_CATEGORY_NODE2(vm, script),
                       ""ContextifyScript::New"",
                       ""filename"",
                       TRACE_STR_COPY(*fn));
  }",53,,810,2,,void
152694,BLOCK,-1,,"{
    uint8_t* data = static_cast<uint8_t*>(cached_data_buf->Buffer()->Data());
    cached_data = new ScriptCompiler::CachedData(
        data + cached_data_buf->ByteOffset(), cached_data_buf->ByteLength());
  }",35,,819,2,,void
152808,BLOCK,-1,,<empty>,5,,848,2,,void
152850,BLOCK,-1,,"{
    errors::DecorateErrorStack(env, try_catch);
    no_abort_scope.Close();
    if (!try_catch.HasTerminated())
      try_catch.ReThrow();
    TRACE_EVENT_END0(TRACING_CATEGORY_NODE2(vm, script),
                     ""ContextifyScript::New"");
    return;
  }",45,,858,2,,void
152867,BLOCK,-1,,<empty>,7,,862,2,,void
152897,BLOCK,-1,,"{
    new_cached_data.reset(ScriptCompiler::CreateCodeCache(v8_script));
  }",28,,870,2,,void
152925,BLOCK,-1,,"{
    return;
  }",25,,880,2,,void
152950,BLOCK,-1,,<empty>,5,,889,2,,void
152966,BLOCK,-1,,"{
  Local<Context> context;
  if (!target->GetCreationContext().ToLocal(&context)) {
    return Nothing<bool>();
  }
  if (compile_options == ScriptCompiler::kConsumeCodeCache) {
    if (target
            ->Set(
                context,
                env->cached_data_rejected_string(),
                Boolean::New(env->isolate(), source.GetCachedData()->rejected))
            .IsNothing()) {
      return Nothing<bool>();
    }
  }
  if (produce_cached_data) {
    bool cached_data_produced = new_cached_data != nullptr;
    if (cached_data_produced) {
      MaybeLocal<Object> buf =
          Buffer::Copy(env,
                       reinterpret_cast<const char*>(new_cached_data->data),
                       new_cached_data->length);
      if (target->Set(context, env->cached_data_string(), buf.ToLocalChecked())
              .IsNothing()) {
        return Nothing<bool>();
      }
    }
    if (target
            ->Set(context,
                  env->cached_data_produced_string(),
 ...",66,,900,7,,void
152983,BLOCK,-1,,"{
    return Nothing<bool>();
  }",56,,902,2,,void
152992,BLOCK,-1,,"{
    if (target
            ->Set(
                context,
                env->cached_data_rejected_string(),
                Boolean::New(env->isolate(), source.GetCachedData()->rejected))
            .IsNothing()) {
      return Nothing<bool>();
    }
  }",61,,905,2,,void
153020,BLOCK,-1,,"{
      return Nothing<bool>();
    }",27,,911,2,,void
153025,BLOCK,-1,,"{
    bool cached_data_produced = new_cached_data != nullptr;
    if (cached_data_produced) {
      MaybeLocal<Object> buf =
          Buffer::Copy(env,
                       reinterpret_cast<const char*>(new_cached_data->data),
                       new_cached_data->length);
      if (target->Set(context, env->cached_data_string(), buf.ToLocalChecked())
              .IsNothing()) {
        return Nothing<bool>();
      }
    }
    if (target
            ->Set(context,
                  env->cached_data_produced_string(),
                  Boolean::New(env->isolate(), cached_data_produced))
            .IsNothing()) {
      return Nothing<bool>();
    }
  }",28,,915,2,,void
153034,BLOCK,-1,,"{
      MaybeLocal<Object> buf =
          Buffer::Copy(env,
                       reinterpret_cast<const char*>(new_cached_data->data),
                       new_cached_data->length);
      if (target->Set(context, env->cached_data_string(), buf.ToLocalChecked())
              .IsNothing()) {
        return Nothing<bool>();
      }
    }",31,,917,2,,void
153071,BLOCK,-1,,"{
        return Nothing<bool>();
      }",29,,923,2,,void
153096,BLOCK,-1,,"{
      return Nothing<bool>();
    }",27,,931,2,,void
153107,BLOCK,-1,,"{
  return !value.IsEmpty() &&
         env->script_context_constructor_template()->HasInstance(value);
}",62,,939,3,,void
153127,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  ContextifyScript* wrapped_script;
  ASSIGN_OR_RETURN_UNWRAP(&wrapped_script, args.Holder());
  Local<UnboundScript> unbound_script =
      PersistentToLocal::Default(env->isolate(), wrapped_script->script_);
  std::unique_ptr<ScriptCompiler::CachedData> cached_data(
      ScriptCompiler::CreateCodeCache(unbound_script));
  if (!cached_data) {
    args.GetReturnValue().Set(Buffer::New(env, 0).ToLocalChecked());
  } else {
    MaybeLocal<Object> buf = Buffer::Copy(
        env,
        reinterpret_cast<const char*>(cached_data->data),
        cached_data->length);
    args.GetReturnValue().Set(buf.ToLocalChecked());
  }
}",46,,945,2,,void
153163,BLOCK,-1,,<empty>,,,,2,,<empty>
153169,BLOCK,-1,,"{
    args.GetReturnValue().Set(Buffer::New(env, 0).ToLocalChecked());
  }",21,,953,2,,void
153187,BLOCK,-1,,"{
    MaybeLocal<Object> buf = Buffer::Copy(
        env,
        reinterpret_cast<const char*>(cached_data->data),
        cached_data->length);
    args.GetReturnValue().Set(buf.ToLocalChecked());
  }",10,,955,1,,void
153222,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  ContextifyScript* wrapped_script;
  ASSIGN_OR_RETURN_UNWRAP(&wrapped_script, args.Holder());

  CHECK_EQ(args.Length(), 5);
  CHECK(args[0]->IsObject() || args[0]->IsNull());

  Local<Context> context;
  std::shared_ptr<MicrotaskQueue> microtask_queue;

  if (args[0]->IsObject()) {
    Local<Object> sandbox = args[0].As<Object>();
    // Get the context from the sandbox
    ContextifyContext* contextify_context =
        ContextifyContext::ContextFromContextifiedSandbox(env, sandbox);
    CHECK_NOT_NULL(contextify_context);
    CHECK_EQ(contextify_context->env(), env);

    context = contextify_context->context();
    if (context.IsEmpty()) return;

    microtask_queue = contextify_context->microtask_queue();
  } else {
    context = env->context();
  }

  TRACE_EVENT0(TRACING_CATEGORY_NODE2(vm, script), ""RunInContext"");

  CHECK(args[1]->IsNumber());
  int64_t timeout = args[1]->IntegerValue(env->context()).FromJust();

  CHE...",78,,964,2,,void
153278,BLOCK,-1,,"{
    Local<Object> sandbox = args[0].As<Object>();
    // Get the context from the sandbox
    ContextifyContext* contextify_context =
        ContextifyContext::ContextFromContextifiedSandbox(env, sandbox);
    CHECK_NOT_NULL(contextify_context);
    CHECK_EQ(contextify_context->env(), env);

    context = contextify_context->context();
    if (context.IsEmpty()) return;

    microtask_queue = contextify_context->microtask_queue();
  }",28,,976,2,,void
153319,BLOCK,-1,,<empty>,28,,985,2,,void
153328,BLOCK,-1,,"{
    context = env->context();
  }",10,,988,1,,void
153428,BLOCK,-1,,"{
  Context::Scope context_scope(context);

  if (!env->can_call_into_js())
    return false;
  if (!ContextifyScript::InstanceOf(env, args.Holder())) {
    THROW_ERR_INVALID_THIS(
        env,
        ""Script methods can only be called on script instances."");
    return false;
  }

  TryCatchScope try_catch(env);
  Isolate::SafeForTerminationScope safe_for_termination(env->isolate());
  ContextifyScript* wrapped_script;
  ASSIGN_OR_RETURN_UNWRAP(&wrapped_script, args.Holder(), false);
  Local<UnboundScript> unbound_script =
      PersistentToLocal::Default(env->isolate(), wrapped_script->script_);
  Local<Script> script = unbound_script->BindToCurrentContext();

#if HAVE_INSPECTOR
  if (break_on_first_line) {
    env->inspector_agent()->PauseOnNextJavascriptStatement(""Break on start"");
  }
#endif

  MaybeLocal<Value> result;
  bool timed_out = false;
  bool received_signal = false;
  auto run = [&]() {
    MaybeLocal<Value> result = script->Run(context);
    if (!result.IsEmpty() &...",77,,1024,9,,void
153438,BLOCK,-1,,<empty>,5,,1028,2,,void
153452,BLOCK,-1,,"{
    THROW_ERR_INVALID_THIS(
        env,
        ""Script methods can only be called on script instances."");
    return false;
  }",58,,1029,2,,void
153527,BLOCK,-1,,"{
    Watchdog wd(env->isolate(), timeout, &timed_out);
    SigintWatchdog swd(env->isolate(), &received_signal);
    result = run();
  }",41,,1059,2,,void
153549,BLOCK,-1,,<empty>,10,,1063,1,,void
153552,BLOCK,-1,,"{
    SigintWatchdog swd(env->isolate(), &received_signal);
    result = run();
  }",31,,1063,2,,void
153565,BLOCK,-1,,<empty>,10,,1066,1,,void
153571,BLOCK,-1,,"{
    Watchdog wd(env->isolate(), timeout, &timed_out);
    result = run();
  }",29,,1066,2,,void
153585,BLOCK,-1,,"{
    result = run();
  }",10,,1069,1,,void
153593,BLOCK,-1,,"{
    if (!env->is_main_thread() && env->is_stopping())
      return false;
    env->isolate()->CancelTerminateExecution();
    // It is possible that execution was terminated by another timeout in
    // which this timeout is nested, so check whether one of the watchdogs
    // from this invocation is responsible for termination.
    if (timed_out) {
      node::THROW_ERR_SCRIPT_EXECUTION_TIMEOUT(env, timeout);
    } else if (received_signal) {
      node::THROW_ERR_SCRIPT_EXECUTION_INTERRUPTED(env);
    }
  }",37,,1074,2,,void
153605,BLOCK,-1,,<empty>,7,,1076,2,,void
153617,BLOCK,-1,,"{
      node::THROW_ERR_SCRIPT_EXECUTION_TIMEOUT(env, timeout);
    }",20,,1081,2,,void
153625,BLOCK,-1,,<empty>,12,,1083,1,,void
153628,BLOCK,-1,,"{
      node::THROW_ERR_SCRIPT_EXECUTION_INTERRUPTED(env);
    }",33,,1083,2,,void
153639,BLOCK,-1,,"{
    if (!timed_out && !received_signal && display_errors) {
      // We should decorate non-termination exceptions
      errors::DecorateErrorStack(env, try_catch);
    }

    // If there was an exception thrown during script execution, re-throw it.
    // If one of the above checks threw, re-throw the exception instead of
    // letting try_catch catch it.
    // If execution has been terminated, but not by one of the watchdogs from
    // this invocation, this will re-throw a `null` value.
    if (!try_catch.HasTerminated())
      try_catch.ReThrow();

    return false;
  }",30,,1088,2,,void
153648,BLOCK,-1,,"{
      // We should decorate non-termination exceptions
      errors::DecorateErrorStack(env, try_catch);
    }",59,,1089,2,,void
153661,BLOCK,-1,,<empty>,7,,1100,2,,void
153686,BLOCK,-1,,"{
  MakeWeak();
  env->id_to_script_map.emplace(id_, this);
}",38,,1112,3,,void
153699,BLOCK,-1,,"{
  env()->id_to_script_map.erase(id_);
}",39,,1118,1,,void
153711,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();

  // Argument 1: source code
  CHECK(args[0]->IsString());
  Local<String> code = args[0].As<String>();

  // Argument 2: filename
  CHECK(args[1]->IsString());
  Local<String> filename = args[1].As<String>();

  // Argument 3: line offset
  CHECK(args[2]->IsNumber());
  int line_offset = args[2].As<Int32>()->Value();

  // Argument 4: column offset
  CHECK(args[3]->IsNumber());
  int column_offset = args[3].As<Int32>()->Value();

  // Argument 5: cached data (optional)
  Local<ArrayBufferView> cached_data_buf;
  if (!args[4]->IsUndefined()) {
    CHECK(args[4]->IsArrayBufferView());
    cached_data_buf = args[4].As<ArrayBufferView>();
  }

  // Argument 6: produce cache data
  CHECK(args[5]->IsBoolean());
  bool produce_cached_data = args[5]->IsTrue();

  // Argument 7: parsing context (optional)
  Local<Context> parsing_context;
  if (!args[6]->IsU...",46,,1124,2,,void
153826,BLOCK,-1,,"{
    CHECK(args[4]->IsArrayBufferView());
    cached_data_buf = args[4].As<ArrayBufferView>();
  }",32,,1147,2,,void
153871,BLOCK,-1,,"{
    CHECK(args[6]->IsObject());
    ContextifyContext* sandbox =
        ContextifyContext::ContextFromContextifiedSandbox(
            env, args[6].As<Object>());
    CHECK_NOT_NULL(sandbox);
    parsing_context = sandbox->context();
  }",32,,1158,2,,void
153902,BLOCK,-1,,"{
    parsing_context = context;
  }",10,,1165,1,,void
153919,BLOCK,-1,,"{
    CHECK(args[7]->IsArray());
    context_extensions_buf = args[7].As<Array>();
  }",32,,1171,2,,void
153948,BLOCK,-1,,"{
    CHECK(args[8]->IsArray());
    params_buf = args[8].As<Array>();
  }",32,,1178,2,,void
153974,BLOCK,-1,,"{
    uint8_t* data = static_cast<uint8_t*>(cached_data_buf->Buffer()->Data());
    cached_data = new ScriptCompiler::CachedData(
      data + cached_data_buf->ByteOffset(), cached_data_buf->ByteLength());
  }",35,,1185,2,,void
154087,BLOCK,-1,,"{
    options = ScriptCompiler::kNoCompileOptions;
  }",42,,1218,2,,void
154094,BLOCK,-1,,"{
    options = ScriptCompiler::kConsumeCodeCache;
  }",10,,1220,1,,void
154121,BLOCK,-1,,"{
    for (uint32_t n = 0; n < context_extensions_buf->Length(); n++) {
      Local<Value> val;
      if (!context_extensions_buf->Get(context, n).ToLocal(&val)) return;
      CHECK(val->IsObject());
      context_extensions.push_back(val.As<Object>());
    }
  }",42,,1229,2,,void
154123,BLOCK,-1,,<empty>,5,,1230,1,,void
154136,BLOCK,4,,"{
      Local<Value> val;
      if (!context_extensions_buf->Get(context, n).ToLocal(&val)) return;
      CHECK(val->IsObject());
      context_extensions.push_back(val.As<Object>());
    }",69,,1230,4,,void
154155,BLOCK,-1,,<empty>,67,,1232,2,,void
154185,BLOCK,-1,,"{
    for (uint32_t n = 0; n < params_buf->Length(); n++) {
      Local<Value> val;
      if (!params_buf->Get(context, n).ToLocal(&val)) return;
      CHECK(val->IsString());
      params.push_back(val.As<String>());
    }
  }",30,,1240,2,,void
154187,BLOCK,-1,,<empty>,5,,1241,1,,void
154200,BLOCK,4,,"{
      Local<Value> val;
      if (!params_buf->Get(context, n).ToLocal(&val)) return;
      CHECK(val->IsString());
      params.push_back(val.As<String>());
    }",57,,1241,4,,void
154219,BLOCK,-1,,<empty>,55,,1243,2,,void
154284,BLOCK,-1,,"{
    if (try_catch.HasCaught() && !try_catch.HasTerminated()) {
      errors::DecorateErrorStack(env, try_catch);
      try_catch.ReThrow();
    }
    return;
  }",31,,1260,2,,void
154296,BLOCK,-1,,"{
      errors::DecorateErrorStack(env, try_catch);
      try_catch.ReThrow();
    }",62,,1261,2,,void
154328,BLOCK,-1,,"{
    return;
  }",42,,1270,2,,void
154372,BLOCK,-1,,<empty>,5,,1278,2,,void
154388,BLOCK,-1,,<empty>,5,,1281,2,,void
154410,BLOCK,-1,,<empty>,5,,1287,2,,void
154423,BLOCK,-1,,"{
    new_cached_data.reset(ScriptCompiler::CreateCodeCacheForFunction(fn));
  }",28,,1290,2,,void
154448,BLOCK,-1,,"{
    return;
  }",25,,1299,2,,void
154462,BLOCK,-1,,"{
  CompiledFnEntry* entry = data.GetParameter();
  delete entry;
}",52,,1307,2,,void
154479,BLOCK,-1,,"{
  fn_.SetWeak(this, WeakCallback, v8::WeakCallbackType::kParameter);
}",65,,1316,5,,void
154494,BLOCK,-1,,"{
  env()->id_to_function_map.erase(id_);
  fn_.ClearWeak();
}",37,,1320,1,,void
154510,BLOCK,-1,,"{
  int ret = SigintWatchdogHelper::GetInstance()->Start();
  args.GetReturnValue().Set(ret == 0);
}",74,,1325,2,,void
154535,BLOCK,-1,,"{
  bool had_pending_signals = SigintWatchdogHelper::GetInstance()->Stop();
  args.GetReturnValue().Set(had_pending_signals);
}",73,,1330,2,,void
154558,BLOCK,-1,,"{
  bool ret = SigintWatchdogHelper::GetInstance()->HasPendingSignal();
  args.GetReturnValue().Set(ret);
}",79,,1335,2,,void
154581,BLOCK,-1,,"{
  CHECK(args[0]->IsInt32());
  CHECK(args[1]->IsInt32());
  int32_t mode = args[0].As<v8::Int32>()->Value();
  int32_t execution = args[1].As<v8::Int32>()->Value();
  Isolate* isolate = args.GetIsolate();

  Local<Context> current_context = isolate->GetCurrentContext();
  Local<Promise::Resolver> resolver;
  if (!Promise::Resolver::New(current_context).ToLocal(&resolver)) return;
  std::unique_ptr<v8::MeasureMemoryDelegate> delegate =
      v8::MeasureMemoryDelegate::Default(
          isolate,
          current_context,
          resolver,
          static_cast<v8::MeasureMemoryMode>(mode));
  isolate->MeasureMemory(std::move(delegate),
                         static_cast<v8::MeasureMemoryExecution>(execution));
  Local<Promise> promise = resolver->GetPromise();

  args.GetReturnValue().Set(promise);
}",68,,1340,2,,void
154658,BLOCK,-1,,<empty>,68,,1349,2,,void
154717,BLOCK,-1,,"{
  MakeWeak();
}",75,,1366,3,,void
154722,BLOCK,-1,,"{
  return microtask_queue_;
}",45,,1371,1,,void
154729,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  new MicrotaskQueueWrap(Environment::GetCurrent(args), args.This());
}",71,,1375,2,,void
154751,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();
  HandleScope scope(isolate);
  Local<FunctionTemplate> tmpl = NewFunctionTemplate(isolate, New);
  tmpl->InstanceTemplate()->SetInternalFieldCount(
      ContextifyScript::kInternalFieldCount);
  isolate_data->set_microtask_queue_ctor_template(tmpl);
  SetConstructorFunction(isolate, target, ""MicrotaskQueue"", tmpl);
}",62,,1381,3,,void
154795,BLOCK,-1,,"{
  registry->Register(New);
}",42,,1392,2,,void
154806,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();

  ContextifyContext::CreatePerIsolateProperties(isolate_data, target);
  ContextifyScript::CreatePerIsolateProperties(isolate_data, target);
  MicrotaskQueueWrap::CreatePerIsolateProperties(isolate_data, target);

  SetMethod(isolate, target, ""startSigintWatchdog"", StartSigintWatchdog);
  SetMethod(isolate, target, ""stopSigintWatchdog"", StopSigintWatchdog);
  // Used in tests.
  SetMethodNoSideEffect(
      isolate, target, ""watchdogHasPendingSigint"", WatchdogHasPendingSigint);

  {
    Local<FunctionTemplate> tpl = FunctionTemplate::New(isolate);
    tpl->SetClassName(FIXED_ONE_BYTE_STRING(isolate, ""CompiledFnEntry""));
    tpl->InstanceTemplate()->SetInternalFieldCount(
        CompiledFnEntry::kInternalFieldCount);

    isolate_data->set_compiled_fn_entry_template(tpl->InstanceTemplate());
  }
  SetMethod(isolate, target, ""measureMemory"", MeasureMemory);
}",63,,1397,3,,void
154847,BLOCK,9,,"{
    Local<FunctionTemplate> tpl = FunctionTemplate::New(isolate);
    tpl->SetClassName(FIXED_ONE_BYTE_STRING(isolate, ""CompiledFnEntry""));
    tpl->InstanceTemplate()->SetInternalFieldCount(
        CompiledFnEntry::kInternalFieldCount);

    isolate_data->set_compiled_fn_entry_template(tpl->InstanceTemplate());
  }",3,,1410,9,,void
154896,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<Object> constants = Object::New(env->isolate());
  Local<Object> measure_memory = Object::New(env->isolate());
  Local<Object> memory_execution = Object::New(env->isolate());

  {
    Local<Object> memory_mode = Object::New(env->isolate());
    MeasureMemoryMode SUMMARY = MeasureMemoryMode::kSummary;
    MeasureMemoryMode DETAILED = MeasureMemoryMode::kDetailed;
    NODE_DEFINE_CONSTANT(memory_mode, SUMMARY);
    NODE_DEFINE_CONSTANT(memory_mode, DETAILED);
    READONLY_PROPERTY(measure_memory, ""mode"", memory_mode);
  }

  {
    MeasureMemoryExecution DEFAULT = MeasureMemoryExecution::kDefault;
    MeasureMemoryExecution EAGER = MeasureMemoryExecution::kEager;
    NODE_DEFINE_CONSTANT(memory_execution, DEFAULT);
    NODE_DEFINE_CONSTANT(memory_execution, EAGER);
    READONLY_PROPERTY(measure_memory, ""execution"", memory_execution);
  }

  READONLY_PROPERTY(constants, ""measureMemory""...",52,,1424,5,,void
154954,BLOCK,8,,"{
    Local<Object> memory_mode = Object::New(env->isolate());
    MeasureMemoryMode SUMMARY = MeasureMemoryMode::kSummary;
    MeasureMemoryMode DETAILED = MeasureMemoryMode::kDetailed;
    NODE_DEFINE_CONSTANT(memory_mode, SUMMARY);
    NODE_DEFINE_CONSTANT(memory_mode, DETAILED);
    READONLY_PROPERTY(measure_memory, ""mode"", memory_mode);
  }",3,,1432,8,,void
154991,BLOCK,9,,"{
    MeasureMemoryExecution DEFAULT = MeasureMemoryExecution::kDefault;
    MeasureMemoryExecution EAGER = MeasureMemoryExecution::kEager;
    NODE_DEFINE_CONSTANT(memory_execution, DEFAULT);
    NODE_DEFINE_CONSTANT(memory_execution, EAGER);
    READONLY_PROPERTY(measure_memory, ""execution"", memory_execution);
  }",3,,1441,9,,void
155035,BLOCK,-1,,"{
  ContextifyContext::RegisterExternalReferences(registry);
  ContextifyScript::RegisterExternalReferences(registry);
  MicrotaskQueueWrap::RegisterExternalReferences(registry);

  registry->Register(StartSigintWatchdog);
  registry->Register(StopSigintWatchdog);
  registry->Register(WatchdogHasPendingSigint);
  registry->Register(MeasureMemory);
}",70,,1454,2,,void
155084,BLOCK,-1,,<empty>,1,,1,1,,ANY
155109,BLOCK,-1,,<empty>,1,,1,1,,ANY
155112,BLOCK,-1,,"{
  // This could reasonably be a static variable, but this way
  // we can guarantee that this function is always usable
  // and returns the correct value,  e.g. even in static
  // initialization code in other files.
#ifdef __linux__
  static const bool value = getauxval(AT_SECURE);
  return value;
#else
  return false;
#endif
}",24,,35,1,,void
155123,BLOCK,-1,,"{
#if !defined(__CloudABI__) && !defined(_WIN32)
#if defined(__linux__)
  if ((!HasOnly(CAP_NET_BIND_SERVICE) && linux_at_secure()) ||
      getuid() != geteuid() || getgid() != getegid())
#else
  if (linux_at_secure() || getuid() != geteuid() || getgid() != getegid())
#endif
    goto fail;
#endif

  if (env_vars != nullptr) {
    DCHECK_NOT_NULL(isolate);
    HandleScope handle_scope(isolate);
    TryCatch ignore_errors(isolate);
    MaybeLocal<String> maybe_value = env_vars->Get(
        isolate, String::NewFromUtf8(isolate, key).ToLocalChecked());
    Local<String> value;
    if (!maybe_value.ToLocal(&value)) goto fail;
    String::Utf8Value utf8_value(isolate, value);
    if (*utf8_value == nullptr) goto fail;
    *text = std::string(*utf8_value, utf8_value.length());
    return true;
  }

  {
    Mutex::ScopedLock lock(per_process::env_var_mutex);

    size_t init_sz = 256;
    MaybeStackBuffer<char, 256> val;
    int ret = uv_os_getenv(key, *val, &init_sz);

    if (ret == UV_...",39,,80,5,,void
155134,BLOCK,-1,,<empty>,5,,88,2,,void
155140,BLOCK,-1,,"{
    DCHECK_NOT_NULL(isolate);
    HandleScope handle_scope(isolate);
    TryCatch ignore_errors(isolate);
    MaybeLocal<String> maybe_value = env_vars->Get(
        isolate, String::NewFromUtf8(isolate, key).ToLocalChecked());
    Local<String> value;
    if (!maybe_value.ToLocal(&value)) goto fail;
    String::Utf8Value utf8_value(isolate, value);
    if (*utf8_value == nullptr) goto fail;
    *text = std::string(*utf8_value, utf8_value.length());
    return true;
  }",28,,91,2,,void
155182,BLOCK,-1,,<empty>,39,,98,2,,void
155193,BLOCK,-1,,<empty>,33,,100,2,,void
155210,BLOCK,3,,"{
    Mutex::ScopedLock lock(per_process::env_var_mutex);

    size_t init_sz = 256;
    MaybeStackBuffer<char, 256> val;
    int ret = uv_os_getenv(key, *val, &init_sz);

    if (ret == UV_ENOBUFS) {
      // Buffer is not large enough, reallocate to the updated init_sz
      // and fetch env value again.
      val.AllocateSufficientStorage(init_sz);
      ret = uv_os_getenv(key, *val, &init_sz);
    }

    if (ret >= 0) {  // Env key value fetch success.
      *text = *val;
      return true;
    }
  }",3,,105,3,,void
155234,BLOCK,-1,,"{
      // Buffer is not large enough, reallocate to the updated init_sz
      // and fetch env value again.
      val.AllocateSufficientStorage(init_sz);
      ret = uv_os_getenv(key, *val, &init_sz);
    }",28,,112,2,,void
155252,BLOCK,-1,,"{  // Env key value fetch success.
      *text = *val;
      return true;
    }",19,,119,2,,void
155271,BLOCK,-1,,"{
  CHECK(args[0]->IsString());
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  Utf8Value strenvtag(isolate, args[0]);
  std::string text;
  if (!SafeGetenv(*strenvtag, &text, env->env_vars(), isolate)) return;
  Local<Value> result =
      ToV8Value(isolate->GetCurrentContext(), text).ToLocalChecked();
  args.GetReturnValue().Set(result);
}",65,,130,2,,void
155313,BLOCK,-1,,<empty>,65,,136,2,,void
155342,BLOCK,-1,,"{
  registry->Register(SafeGetenv);

#ifdef NODE_IMPLEMENTS_POSIX_CREDENTIALS
  registry->Register(GetUid);
  registry->Register(GetEUid);
  registry->Register(GetGid);
  registry->Register(GetEGid);
  registry->Register(GetGroups);

  registry->Register(InitGroups);
  registry->Register(SetEGid);
  registry->Register(SetEUid);
  registry->Register(SetGid);
  registry->Register(SetUid);
  registry->Register(SetGroups);
#endif  // NODE_IMPLEMENTS_POSIX_CREDENTIALS
}",70,,436,2,,void
155355,BLOCK,-1,,"{
  SetMethod(context, target, ""safeGetenv"", SafeGetenv);

#ifdef NODE_IMPLEMENTS_POSIX_CREDENTIALS
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  READONLY_TRUE_PROPERTY(target, ""implementsPosixCredentials"");
  SetMethodNoSideEffect(context, target, ""getuid"", GetUid);
  SetMethodNoSideEffect(context, target, ""geteuid"", GetEUid);
  SetMethodNoSideEffect(context, target, ""getgid"", GetGid);
  SetMethodNoSideEffect(context, target, ""getegid"", GetEGid);
  SetMethodNoSideEffect(context, target, ""getgroups"", GetGroups);

  if (env->owns_process_state()) {
    SetMethod(context, target, ""initgroups"", InitGroups);
    SetMethod(context, target, ""setegid"", SetEGid);
    SetMethod(context, target, ""seteuid"", SetEUid);
    SetMethod(context, target, ""setgid"", SetGid);
    SetMethod(context, target, ""setuid"", SetUid);
    SetMethod(context, target, ""setgroups"", SetGroups);
  }
#endif  // NODE_IMPLEMENTS_POSIX_CREDENTIALS
}",36,,458,5,,void
155382,BLOCK,-1,,<empty>,1,,1,1,,ANY
155390,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);

  if (!InitCryptoOnce(env->isolate())) {
    return;
  }

#define V(Namespace) Namespace::Initialize(env, target);
  CRYPTO_NAMESPACE_LIST(V)
#undef V
}",29,,75,5,,void
155406,BLOCK,-1,,"{
    return;
  }",40,,78,2,,void
155409,BLOCK,1,,<empty>,,,,2,,void
155546,BLOCK,-1,,"{
#define V(Namespace) Namespace::RegisterExternalReferences(registry);
  CRYPTO_NAMESPACE_LIST(V)
#undef V
}",70,,87,2,,void
155548,BLOCK,1,,<empty>,,,,1,,void
155710,BLOCK,-1,,<empty>,1,,1,1,,ANY
155714,BLOCK,-1,,"{
      const char* msg = ""Closing directory handle on garbage collection failed"";
      // This exception will end up being fatal for the process because
      // it is being thrown from within the SetImmediate handler and
      // there is no JS stack to bubble it to. In other words, tearing
      // down the process is the only reasonable thing we can do here.
      HandleScope handle_scope(env->isolate());
      env->ThrowUVException(detail.ret, ""close"", msg);
    }",52,,152,2,,void
155741,BLOCK,-1,,"{
    ProcessEmitWarning(env,
                       ""Closing directory handle on garbage collection"");
  }",44,,168,2,,void
155782,BLOCK,-1,,<empty>,1,,1,1,,ANY
155787,BLOCK,-1,,"{
  switch (req_type) {
#define FS_TYPE_TO_NAME(type, name)                                            \
  case UV_FS_##type:                                                           \
    return name;
    FS_TYPE_TO_NAME(OPENDIR, ""opendir"")
    FS_TYPE_TO_NAME(READDIR, ""readdir"")
    FS_TYPE_TO_NAME(CLOSEDIR, ""closedir"")
#undef FS_TYPE_TO_NAME
    default:
      return ""unknow"";
  }
}",67,,46,2,,void
155790,BLOCK,-1,,"{
#define FS_TYPE_TO_NAME(type, name)                                            \
  case UV_FS_##type:                                                           \
    return name;
    FS_TYPE_TO_NAME(OPENDIR, ""opendir"")
    FS_TYPE_TO_NAME(READDIR, ""readdir"")
    FS_TYPE_TO_NAME(CLOSEDIR, ""closedir"")
#undef FS_TYPE_TO_NAME
    default:
      return ""unknow"";
  }",21,,47,2,,void
155792,BLOCK,1,,<empty>,,,,1,,void
155798,BLOCK,1,,<empty>,,,,1,,void
155804,BLOCK,1,,<empty>,,,,1,,void
155818,BLOCK,-1,,"{
  MakeWeak();

  dir_->nentries = 0;
  dir_->dirents = nullptr;
}",17,,100,4,,void
155835,BLOCK,-1,,"{
  Local<Object> obj;
  if (!env->dir_instance_template()
          ->NewInstance(env->context())
          .ToLocal(&obj)) {
    return nullptr;
  }

  return new DirHandle(env, obj, dir);
}",60,,107,3,,void
155859,BLOCK,-1,,"{
    return nullptr;
  }",27,,111,2,,void
155872,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
}",62,,118,2,,void
155881,BLOCK,-1,,"{
  CHECK(!closing_);  // We should not be deleting while explicitly closing!
  GCClose();         // Close synchronously and emit warning
  CHECK(closed_);    // We have to be closed at the point
}",25,,122,1,,void
155891,BLOCK,-1,,"{
  tracker->TrackFieldWithSize(""dir"", sizeof(*dir_));
}",58,,128,2,,void
155903,BLOCK,-1,,"{
  if (closed_) return;
  uv_fs_t req;
  FS_DIR_SYNC_TRACE_BEGIN(closedir);
  int ret = uv_fs_closedir(nullptr, &req, dir_, nullptr);
  FS_DIR_SYNC_TRACE_END(closedir);
  uv_fs_req_cleanup(&req);
  closing_ = false;
  closed_ = true;

  struct err_detail { int ret; };

  err_detail detail { ret };

  if (ret < 0) {
    // Do not unref this
    env()->SetImmediate([detail](Environment* env) {
      const char* msg = ""Closing directory handle on garbage collection failed"";
      // This exception will end up being fatal for the process because
      // it is being thrown from within the SetImmediate handler and
      // there is no JS stack to bubble it to. In other words, tearing
      // down the process is the only reasonable thing we can do here.
      HandleScope handle_scope(env->isolate());
      env->ThrowUVException(detail.ret, ""close"", msg);
    });
    return;
  }

  // If the close was successful, we still want to emit a process warning
  // to notify that the file descri...",34,,136,1,,void
155906,BLOCK,-1,,<empty>,16,,137,2,,void
155912,BLOCK,1,,<empty>,,,,9,,void
155928,BLOCK,-1,,<empty>,3,,139,2,,void
155930,BLOCK,-1,,FS_DIR_SYNC_TRACE_BEGIN(closedir),3,,139,1,,void
155948,BLOCK,-1,,FS_DIR_SYNC_TRACE_BEGIN(closedir),3,,139,2,,void
155976,BLOCK,-1,,FS_DIR_SYNC_TRACE_BEGIN(closedir),3,,139,2,,void
156017,BLOCK,1,,<empty>,,,,9,,void
156033,BLOCK,-1,,<empty>,3,,141,2,,void
156035,BLOCK,-1,,FS_DIR_SYNC_TRACE_END(closedir),3,,141,1,,void
156053,BLOCK,-1,,FS_DIR_SYNC_TRACE_END(closedir),3,,141,2,,void
156081,BLOCK,-1,,FS_DIR_SYNC_TRACE_END(closedir),3,,141,2,,void
156127,BLOCK,-1,,"{
    // Do not unref this
    env()->SetImmediate([detail](Environment* env) {
      const char* msg = ""Closing directory handle on garbage collection failed"";
      // This exception will end up being fatal for the process because
      // it is being thrown from within the SetImmediate handler and
      // there is no JS stack to bubble it to. In other words, tearing
      // down the process is the only reasonable thing we can do here.
      HandleScope handle_scope(env->isolate());
      env->ThrowUVException(detail.ret, ""close"", msg);
    });
    return;
  }",16,,150,2,,void
156146,BLOCK,-1,,"{
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_DIR_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  if (after.Proceed())
    req_wrap->Resolve(Undefined(req_wrap->env()->isolate()));
}",31,,174,2,,void
156174,BLOCK,1,,<empty>,,,,18,,void
156176,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,177,1,,void
156194,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,177,2,,void
156222,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,177,2,,void
156278,BLOCK,-1,,<empty>,5,,180,2,,void
156295,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 1);

  DirHandle* dir;
  ASSIGN_OR_RETURN_UNWRAP(&dir, args.Holder());

  dir->closing_ = false;
  dir->closed_ = true;

  FSReqBase* req_wrap_async = GetReqWrap(args, 0);
  if (req_wrap_async != nullptr) {  // close(req)
    FS_DIR_ASYNC_TRACE_BEGIN0(UV_FS_CLOSEDIR, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""closedir"", UTF8, AfterClose,
              uv_fs_closedir, dir->dir());
  } else {  // close(undefined, ctx)
    CHECK_EQ(argc, 2);
    FSReqWrapSync req_wrap_sync;
    FS_DIR_SYNC_TRACE_BEGIN(closedir);
    SyncCall(env, args[1], &req_wrap_sync, ""closedir"", uv_fs_closedir,
             dir->dir());
    FS_DIR_SYNC_TRACE_END(closedir);
  }
}",64,,183,2,,void
156342,BLOCK,-1,,"{  // close(req)
    FS_DIR_ASYNC_TRACE_BEGIN0(UV_FS_CLOSEDIR, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""closedir"", UTF8, AfterClose,
              uv_fs_closedir, dir->dir());
  }",34,,196,2,,void
156350,BLOCK,1,,<empty>,,,,16,,void
156352,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_BEGIN0(UV_FS_CLOSEDIR, req_wrap_async)",5,,197,1,,void
156370,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_BEGIN0(UV_FS_CLOSEDIR, req_wrap_async)",5,,197,2,,void
156398,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_BEGIN0(UV_FS_CLOSEDIR, req_wrap_async)",5,,197,2,,void
156454,BLOCK,-1,,"{  // close(undefined, ctx)
    CHECK_EQ(argc, 2);
    FSReqWrapSync req_wrap_sync;
    FS_DIR_SYNC_TRACE_BEGIN(closedir);
    SyncCall(env, args[1], &req_wrap_sync, ""closedir"", uv_fs_closedir,
             dir->dir());
    FS_DIR_SYNC_TRACE_END(closedir);
  }",10,,200,1,,void
156462,BLOCK,1,,<empty>,,,,9,,void
156478,BLOCK,-1,,<empty>,5,,203,2,,void
156480,BLOCK,-1,,FS_DIR_SYNC_TRACE_BEGIN(closedir),5,,203,1,,void
156498,BLOCK,-1,,FS_DIR_SYNC_TRACE_BEGIN(closedir),5,,203,2,,void
156526,BLOCK,-1,,FS_DIR_SYNC_TRACE_BEGIN(closedir),5,,203,2,,void
156571,BLOCK,1,,<empty>,,,,9,,void
156587,BLOCK,-1,,<empty>,5,,206,2,,void
156589,BLOCK,-1,,FS_DIR_SYNC_TRACE_END(closedir),5,,206,1,,void
156607,BLOCK,-1,,FS_DIR_SYNC_TRACE_END(closedir),5,,206,2,,void
156635,BLOCK,-1,,FS_DIR_SYNC_TRACE_END(closedir),5,,206,2,,void
156672,BLOCK,-1,,"{
  MaybeStackBuffer<Local<Value>, 64> entries(num * 2);

  // Return an array of all read filenames.
  int j = 0;
  for (int i = 0; i < num; i++) {
    Local<Value> filename;
    Local<Value> error;
    const size_t namelen = strlen(ents[i].name);
    if (!StringBytes::Encode(env->isolate(),
                             ents[i].name,
                             namelen,
                             encoding,
                             &error).ToLocal(&filename)) {
      *err_out = error;
      return MaybeLocal<Array>();
    }

    entries[j++] = filename;
    entries[j++] = Integer::New(env->isolate(), ents[i].type);
  }

  return Array::New(env->isolate(), entries.out(), j);
}",28,,215,6,,void
156683,BLOCK,-1,,<empty>,3,,220,1,,void
156693,BLOCK,4,,"{
    Local<Value> filename;
    Local<Value> error;
    const size_t namelen = strlen(ents[i].name);
    if (!StringBytes::Encode(env->isolate(),
                             ents[i].name,
                             namelen,
                             encoding,
                             &error).ToLocal(&filename)) {
      *err_out = error;
      return MaybeLocal<Array>();
    }

    entries[j++] = filename;
    entries[j++] = Integer::New(env->isolate(), ents[i].type);
  }",33,,220,4,,void
156737,BLOCK,-1,,"{
      *err_out = error;
      return MaybeLocal<Array>();
    }",58,,228,2,,void
156786,BLOCK,-1,,"{
  BaseObjectPtr<FSReqBase> req_wrap { FSReqBase::from_req(req) };
  FSReqAfterScope after(req_wrap.get(), req);
  FS_DIR_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  if (!after.Proceed()) {
    return;
  }

  Environment* env = req_wrap->env();
  Isolate* isolate = env->isolate();

  if (req->result == 0) {
    // Done
    Local<Value> done = Null(isolate);
    after.Clear();
    req_wrap->Resolve(done);
    return;
  }

  uv_dir_t* dir = static_cast<uv_dir_t*>(req->ptr);

  Local<Value> error;
  Local<Array> js_array;
  if (!DirentListToArray(env,
                         dir->dirents,
                         static_cast<int>(req->result),
                         req_wrap->encoding(),
                         &error)
           .ToLocal(&js_array)) {
    // Clear libuv resources *before* delivering results to JS land because
    // that can schedule another operation on the same uv_dir_t. Ditto below.
    after.Clear();
    return r...",40,,240,2,,void
156820,BLOCK,1,,<empty>,,,,17,,void
156822,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,243,1,,void
156840,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,243,2,,void
156868,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,243,2,,void
156925,BLOCK,-1,,"{
    return;
  }",25,,245,2,,void
156947,BLOCK,-1,,"{
    // Done
    Local<Value> done = Null(isolate);
    after.Clear();
    req_wrap->Resolve(done);
    return;
  }",25,,252,2,,void
157007,BLOCK,-1,,"{
    // Clear libuv resources *before* delivering results to JS land because
    // that can schedule another operation on the same uv_dir_t. Ditto below.
    after.Clear();
    return req_wrap->Reject(error);
  }",33,,269,2,,void
157031,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  const enum encoding encoding = ParseEncoding(isolate, args[0], UTF8);

  DirHandle* dir;
  ASSIGN_OR_RETURN_UNWRAP(&dir, args.Holder());

  CHECK(args[1]->IsNumber());
  uint64_t buffer_size = static_cast<uint64_t>(args[1].As<Number>()->Value());

  if (buffer_size != dir->dirents_.size()) {
    dir->dirents_.resize(buffer_size);
    dir->dir_->nentries = buffer_size;
    dir->dir_->dirents = dir->dirents_.data();
  }

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {  // dir.read(encoding, bufferSize, req)
    FS_DIR_ASYNC_TRACE_BEGIN0(UV_FS_READDIR, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""readdir"", encoding,
              AfterDirRead, uv_fs_readdir, dir->dir());
  } else {  // dir.read(encoding, bufferSize, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
 ...",63,,281,2,,void
157104,BLOCK,-1,,"{
    dir->dirents_.resize(buffer_size);
    dir->dir_->nentries = buffer_size;
    dir->dir_->dirents = dir->dirents_.data();
  }",44,,296,2,,void
157141,BLOCK,-1,,"{  // dir.read(encoding, bufferSize, req)
    FS_DIR_ASYNC_TRACE_BEGIN0(UV_FS_READDIR, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""readdir"", encoding,
              AfterDirRead, uv_fs_readdir, dir->dir());
  }",34,,303,2,,void
157149,BLOCK,1,,<empty>,,,,16,,void
157151,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_BEGIN0(UV_FS_READDIR, req_wrap_async)",5,,304,1,,void
157169,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_BEGIN0(UV_FS_READDIR, req_wrap_async)",5,,304,2,,void
157197,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_BEGIN0(UV_FS_READDIR, req_wrap_async)",5,,304,2,,void
157253,BLOCK,-1,,"{  // dir.read(encoding, bufferSize, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_DIR_SYNC_TRACE_BEGIN(readdir);
    int err = SyncCall(env, args[3], &req_wrap_sync, ""readdir"", uv_fs_readdir,
                       dir->dir());
    FS_DIR_SYNC_TRACE_END(readdir);
    if (err < 0) {
      return;  // syscall failed, no need to continue, error info is in ctx
    }

    if (req_wrap_sync.req.result == 0) {
      // Done
      Local<Value> done = Null(isolate);
      args.GetReturnValue().Set(done);
      return;
    }

    CHECK_GE(req_wrap_sync.req.result, 0);

    Local<Value> error;
    Local<Array> js_array;
    if (!DirentListToArray(env,
                           dir->dir()->dirents,
                           static_cast<int>(req_wrap_sync.req.result),
                           encoding,
                           &error)
             .ToLocal(&js_array)) {
      Local<Object> ctx = args[2].As<Object>();
      USE(ctx->Set(env->context(), env-...",10,,307,1,,void
157261,BLOCK,1,,<empty>,,,,9,,void
157277,BLOCK,-1,,<empty>,5,,310,2,,void
157279,BLOCK,-1,,FS_DIR_SYNC_TRACE_BEGIN(readdir),5,,310,1,,void
157297,BLOCK,-1,,FS_DIR_SYNC_TRACE_BEGIN(readdir),5,,310,2,,void
157325,BLOCK,-1,,FS_DIR_SYNC_TRACE_BEGIN(readdir),5,,310,2,,void
157373,BLOCK,1,,<empty>,,,,9,,void
157389,BLOCK,-1,,<empty>,5,,313,2,,void
157391,BLOCK,-1,,FS_DIR_SYNC_TRACE_END(readdir),5,,313,1,,void
157409,BLOCK,-1,,FS_DIR_SYNC_TRACE_END(readdir),5,,313,2,,void
157437,BLOCK,-1,,FS_DIR_SYNC_TRACE_END(readdir),5,,313,2,,void
157470,BLOCK,-1,,"{
      return;  // syscall failed, no need to continue, error info is in ctx
    }",18,,314,2,,void
157480,BLOCK,-1,,"{
      // Done
      Local<Value> done = Null(isolate);
      args.GetReturnValue().Set(done);
      return;
    }",40,,318,2,,void
157540,BLOCK,-1,,"{
      Local<Object> ctx = args[2].As<Object>();
      USE(ctx->Set(env->context(), env->error_string(), error));
      return;
    }",35,,334,2,,void
157580,BLOCK,-1,,"{
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_DIR_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  if (!after.Proceed()) {
    return;
  }

  Environment* env = req_wrap->env();

  uv_dir_t* dir = static_cast<uv_dir_t*>(req->ptr);
  DirHandle* handle = DirHandle::New(env, dir);

  req_wrap->Resolve(handle->object().As<Value>());
}",33,,344,2,,void
157608,BLOCK,1,,<empty>,,,,18,,void
157610,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,347,1,,void
157628,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,347,2,,void
157656,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,347,2,,void
157713,BLOCK,-1,,"{
    return;
  }",25,,349,2,,void
157754,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(isolate, args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, path.ToStringView());

  const enum encoding encoding = ParseEncoding(isolate, args[1], UTF8);

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {  // openDir(path, encoding, req)
    FS_DIR_ASYNC_TRACE_BEGIN1(
        UV_FS_OPENDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""opendir"", encoding, AfterOpenDir,
              uv_fs_opendir, *path);
  } else {  // openDir(path, encoding, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_DIR_SYNC_TRACE_BEGIN(opendir);
    int result = SyncCall(env, args[3], &req_wrap_sync, ""opendir"",
                          uv_fs_opendir, *path)...",62,,361,2,,void
157819,BLOCK,-1,,"{  // openDir(path, encoding, req)
    FS_DIR_ASYNC_TRACE_BEGIN1(
        UV_FS_OPENDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""opendir"", encoding, AfterOpenDir,
              uv_fs_opendir, *path);
  }",34,,376,2,,void
157828,BLOCK,1,,<empty>,,,,18,,void
157830,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_BEGIN1(
        UV_FS_OPENDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,377,1,,void
157848,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_BEGIN1(
        UV_FS_OPENDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,377,2,,void
157876,BLOCK,-1,,"FS_DIR_ASYNC_TRACE_BEGIN1(
        UV_FS_OPENDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,377,2,,void
157939,BLOCK,-1,,"{  // openDir(path, encoding, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_DIR_SYNC_TRACE_BEGIN(opendir);
    int result = SyncCall(env, args[3], &req_wrap_sync, ""opendir"",
                          uv_fs_opendir, *path);
    FS_DIR_SYNC_TRACE_END(opendir);
    if (result < 0) {
      return;  // syscall failed, no need to continue, error info is in ctx
    }

    uv_fs_t* req = &req_wrap_sync.req;
    uv_dir_t* dir = static_cast<uv_dir_t*>(req->ptr);
    DirHandle* handle = DirHandle::New(env, dir);

    args.GetReturnValue().Set(handle->object().As<Value>());
  }",10,,381,1,,void
157947,BLOCK,1,,<empty>,,,,9,,void
157963,BLOCK,-1,,<empty>,5,,384,2,,void
157965,BLOCK,-1,,FS_DIR_SYNC_TRACE_BEGIN(opendir),5,,384,1,,void
157983,BLOCK,-1,,FS_DIR_SYNC_TRACE_BEGIN(opendir),5,,384,2,,void
158011,BLOCK,-1,,FS_DIR_SYNC_TRACE_BEGIN(opendir),5,,384,2,,void
158057,BLOCK,1,,<empty>,,,,9,,void
158073,BLOCK,-1,,<empty>,5,,387,2,,void
158075,BLOCK,-1,,FS_DIR_SYNC_TRACE_END(opendir),5,,387,1,,void
158093,BLOCK,-1,,FS_DIR_SYNC_TRACE_END(opendir),5,,387,2,,void
158121,BLOCK,-1,,FS_DIR_SYNC_TRACE_END(opendir),5,,387,2,,void
158154,BLOCK,-1,,"{
      return;  // syscall failed, no need to continue, error info is in ctx
    }",21,,388,2,,void
158201,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  SetMethod(context, target, ""opendir"", OpenDir);

  // Create FunctionTemplate for DirHandle
  Local<FunctionTemplate> dir = NewFunctionTemplate(isolate, DirHandle::New);
  dir->Inherit(AsyncWrap::GetConstructorTemplate(env));
  SetProtoMethod(isolate, dir, ""read"", DirHandle::Read);
  SetProtoMethod(isolate, dir, ""close"", DirHandle::Close);
  Local<ObjectTemplate> dirt = dir->InstanceTemplate();
  dirt->SetInternalFieldCount(DirHandle::kInternalFieldCount);
  SetConstructorFunction(context, target, ""DirHandle"", dir);
  env->set_dir_instance_template(dirt);
}",29,,403,5,,void
158287,BLOCK,-1,,"{
  registry->Register(OpenDir);
  registry->Register(DirHandle::New);
  registry->Register(DirHandle::Read);
  registry->Register(DirHandle::Close);
}",70,,420,2,,void
158323,BLOCK,-1,,<empty>,1,,1,1,,ANY
158326,BLOCK,-1,,"{ uv_os_free_environ(items, count); }",37,,193,1,,void
158352,BLOCK,-1,,<empty>,1,,1,1,,ANY
158358,BLOCK,-1,,<empty>,,,,3,,<empty>
158363,BLOCK,-1,,<empty>,,,,2,,<empty>
158370,BLOCK,-1,,<empty>,,,,4,,<empty>
158376,BLOCK,-1,,<empty>,,,,3,,<empty>
158381,BLOCK,-1,,<empty>,,,,2,,<empty>
158387,BLOCK,-1,,<empty>,,,,3,,<empty>
158392,BLOCK,-1,,<empty>,,,,2,,<empty>
158399,BLOCK,-1,,<empty>,,,,3,,<empty>
158404,BLOCK,-1,,<empty>,,,,2,,<empty>
158411,BLOCK,-1,,<empty>,,,,4,,<empty>
158417,BLOCK,-1,,<empty>,,,,3,,<empty>
158422,BLOCK,-1,,<empty>,,,,2,,<empty>
158428,BLOCK,-1,,<empty>,,,,3,,<empty>
158433,BLOCK,-1,,<empty>,,,,2,,<empty>
158438,BLOCK,-1,,<empty>,,,,2,,<empty>
158442,BLOCK,-1,,<empty>,,,,1,,<empty>
158447,BLOCK,-1,,<empty>,69,,61,2,,void
158465,BLOCK,-1,,"{
  if (key.length() == 2 && key[0] == 'T' && key[1] == 'Z') {
#ifdef __POSIX__
    tzset();
    isolate->DateTimeConfigurationChangeNotification(
        Isolate::TimeZoneDetection::kRedetect);
#else
    _tzset();

# if defined(NODE_HAVE_I18N_SUPPORT)
    isolate->DateTimeConfigurationChangeNotification(
        Isolate::TimeZoneDetection::kSkip);

    // On windows, the TZ environment is not supported out of the box.
    // By default, v8 will only be able to detect the system configured
    // timezone. This supports using the TZ environment variable to set
    // the default timezone instead.
    if (val != nullptr) i18n::SetDefaultTimeZone(val);
# else
    isolate->DateTimeConfigurationChangeNotification(
        Isolate::TimeZoneDetection::kRedetect);
# endif
#endif
  }
}",32,,77,4,,void
158485,BLOCK,-1,,"{
#ifdef __POSIX__
    tzset();
    isolate->DateTimeConfigurationChangeNotification(
        Isolate::TimeZoneDetection::kRedetect);
#else
    _tzset();

# if defined(NODE_HAVE_I18N_SUPPORT)
    isolate->DateTimeConfigurationChangeNotification(
        Isolate::TimeZoneDetection::kSkip);

    // On windows, the TZ environment is not supported out of the box.
    // By default, v8 will only be able to detect the system configured
    // timezone. This supports using the TZ environment variable to set
    // the default timezone instead.
    if (val != nullptr) i18n::SetDefaultTimeZone(val);
# else
    isolate->DateTimeConfigurationChangeNotification(
        Isolate::TimeZoneDetection::kRedetect);
# endif
#endif
  }",60,,78,2,,void
158500,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::env_var_mutex);

  size_t init_sz = 256;
  MaybeStackBuffer<char, 256> val;
  int ret = uv_os_getenv(key, *val, &init_sz);

  if (ret == UV_ENOBUFS) {
    // Buffer is not large enough, reallocate to the updated init_sz
    // and fetch env value again.
    val.AllocateSufficientStorage(init_sz);
    ret = uv_os_getenv(key, *val, &init_sz);
  }

  if (ret >= 0) {  // Env key value fetch success.
    return Just(std::string(*val, init_sz));
  }

  return Nothing<std::string>();
}",61,,103,2,,void
158524,BLOCK,-1,,"{
    // Buffer is not large enough, reallocate to the updated init_sz
    // and fetch env value again.
    val.AllocateSufficientStorage(init_sz);
    ret = uv_os_getenv(key, *val, &init_sz);
  }",26,,110,2,,void
158542,BLOCK,-1,,"{  // Env key value fetch success.
    return Just(std::string(*val, init_sz));
  }",17,,117,2,,void
158560,BLOCK,-1,,"{
  node::Utf8Value key(isolate, property);
  Maybe<std::string> value = Get(*key);

  if (value.IsJust()) {
    std::string val = value.FromJust();
    return String::NewFromUtf8(
        isolate, val.data(), NewStringType::kNormal, val.size());
  }

  return MaybeLocal<String>();
}",68,,125,3,,void
158581,BLOCK,-1,,"{
    std::string val = value.FromJust();
    return String::NewFromUtf8(
        isolate, val.data(), NewStringType::kNormal, val.size());
  }",23,,129,2,,void
158614,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::env_var_mutex);

  node::Utf8Value key(isolate, property);
  node::Utf8Value val(isolate, value);

#ifdef _WIN32
  if (key.length() > 0 && key[0] == '=') return;
#endif
  uv_os_setenv(*key, *val);
  DateTimeConfigurationChangeNotification(isolate, key, *val);
}",45,,140,4,,void
158642,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::env_var_mutex);

  char val[2];
  size_t init_sz = sizeof(val);
  int ret = uv_os_getenv(key, val, &init_sz);

  if (ret == UV_ENOENT) {
    return -1;
  }

#ifdef _WIN32
  if (key[0] == '=') {
    return static_cast<int32_t>(ReadOnly) |
           static_cast<int32_t>(DontDelete) |
           static_cast<int32_t>(DontEnum);
  }
#endif

  return 0;
}",52,,153,2,,void
158666,BLOCK,-1,,"{
    return -1;
  }",25,,160,2,,void
158677,BLOCK,-1,,"{
  node::Utf8Value key(isolate, property);
  return Query(*key);
}",77,,175,3,,void
158691,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::env_var_mutex);

  node::Utf8Value key(isolate, property);
  uv_os_unsetenv(*key);
  DateTimeConfigurationChangeNotification(isolate, key);
}",69,,180,3,,void
158711,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::env_var_mutex);
  uv_env_item_t* items;
  int count;

  auto cleanup = OnScopeLeave([&]() { uv_os_free_environ(items, count); });
  CHECK_EQ(uv_os_environ(&items, &count), 0);

  MaybeStackBuffer<Local<Value>, 256> env_v(count);
  int env_v_index = 0;
  for (int i = 0; i < count; i++) {
#ifdef _WIN32
    // If the key starts with '=' it is a hidden environment variable.
    if (items[i].name[0] == '=') continue;
#endif
    MaybeLocal<String> str = String::NewFromUtf8(isolate, items[i].name);
    if (str.IsEmpty()) {
      isolate->ThrowException(ERR_STRING_TOO_LONG(isolate));
      return Local<Array>();
    }
    env_v[env_v_index++] = str.ToLocalChecked();
  }

  return Array::New(isolate, env_v.out(), env_v_index);
}",62,,188,2,,void
158737,BLOCK,-1,,<empty>,3,,198,1,,void
158747,BLOCK,4,,"{
#ifdef _WIN32
    // If the key starts with '=' it is a hidden environment variable.
    if (items[i].name[0] == '=') continue;
#endif
    MaybeLocal<String> str = String::NewFromUtf8(isolate, items[i].name);
    if (str.IsEmpty()) {
      isolate->ThrowException(ERR_STRING_TOO_LONG(isolate));
      return Local<Array>();
    }
    env_v[env_v_index++] = str.ToLocalChecked();
  }",35,,198,4,,void
158769,BLOCK,-1,,"{
      isolate->ThrowException(ERR_STRING_TOO_LONG(isolate));
      return Local<Array>();
    }",24,,204,2,,void
158802,BLOCK,-1,,"{
  HandleScope handle_scope(isolate);
  Local<Context> context = isolate->GetCurrentContext();

  std::shared_ptr<KVStore> copy = KVStore::CreateMapKVStore();
  Local<Array> keys = Enumerate(isolate);
  uint32_t keys_length = keys->Length();
  for (uint32_t i = 0; i < keys_length; i++) {
    Local<Value> key = keys->Get(context, i).ToLocalChecked();
    CHECK(key->IsString());
    copy->Set(isolate,
              key.As<String>(),
              Get(isolate, key.As<String>()).ToLocalChecked());
  }
  return copy;
}",65,,214,2,,void
158844,BLOCK,-1,,<empty>,3,,221,1,,void
158854,BLOCK,4,,"{
    Local<Value> key = keys->Get(context, i).ToLocalChecked();
    CHECK(key->IsString());
    copy->Set(isolate,
              key.As<String>(),
              Get(isolate, key.As<String>()).ToLocalChecked());
  }",46,,221,4,,void
158899,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  auto it = map_.find(key);
  return it == map_.end() ? Nothing<std::string>() : Just(it->second);
}",59,,231,2,,void
158930,BLOCK,-1,,"{
  Utf8Value str(isolate, key);
  Maybe<std::string> value = Get(*str);
  if (value.IsNothing()) return Local<String>();
  std::string val = value.FromJust();
  return String::NewFromUtf8(
      isolate, val.data(), NewStringType::kNormal, val.size());
}",79,,237,3,,void
158951,BLOCK,-1,,<empty>,26,,240,2,,void
158984,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  Utf8Value key_str(isolate, key);
  Utf8Value value_str(isolate, value);
  if (*key_str != nullptr && key_str.length() > 0 && *value_str != nullptr) {
    map_[std::string(*key_str, key_str.length())] =
        std::string(*value_str, value_str.length());
  }
}",80,,246,4,,void
159013,BLOCK,-1,,"{
    map_[std::string(*key_str, key_str.length())] =
        std::string(*value_str, value_str.length());
  }",77,,250,2,,void
159041,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  return map_.find(key) == map_.end() ? -1 : 0;
}",50,,256,2,,void
159065,BLOCK,-1,,"{
  Utf8Value str(isolate, key);
  return Query(*str);
}",70,,261,3,,void
159079,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  Utf8Value str(isolate, key);
  map_.erase(std::string(*str, str.length()));
}",62,,266,3,,void
159105,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  std::vector<Local<Value>> values;
  values.reserve(map_.size());
  for (const auto& pair : map_) {
    values.emplace_back(
        String::NewFromUtf8(isolate, pair.first.data(),
                            NewStringType::kNormal, pair.first.size())
            .ToLocalChecked());
  }
  return Array::New(isolate, values.data(), values.size());
}",60,,272,2,,void
159129,BLOCK,-1,,"{
    values.emplace_back(
        String::NewFromUtf8(isolate, pair.first.data(),
                            NewStringType::kNormal, pair.first.size())
            .ToLocalChecked());
  }",33,,276,3,,void
159175,BLOCK,-1,,"{
  return std::make_shared<MapKVStore>(*this);
}",68,,285,2,,void
159188,BLOCK,-1,,"{
  return std::make_shared<MapKVStore>();
}",54,,289,1,,void
159199,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  HandleScope handle_scope(isolate);
  Local<Array> keys;
  if (!entries->GetOwnPropertyNames(context).ToLocal(&keys))
    return Nothing<bool>();
  uint32_t keys_length = keys->Length();
  for (uint32_t i = 0; i < keys_length; i++) {
    Local<Value> key;
    if (!keys->Get(context, i).ToLocal(&key))
      return Nothing<bool>();
    if (!key->IsString()) continue;

    Local<Value> value;
    Local<String> value_string;
    if (!entries->Get(context, key).ToLocal(&value) ||
        !value->ToString(context).ToLocal(&value_string)) {
      return Nothing<bool>();
    }

    Set(isolate, key.As<String>(), value_string);
  }
  return Just(true);
}",62,,294,3,,void
159227,BLOCK,-1,,<empty>,5,,299,2,,void
159238,BLOCK,-1,,<empty>,3,,301,1,,void
159248,BLOCK,4,,"{
    Local<Value> key;
    if (!keys->Get(context, i).ToLocal(&key))
      return Nothing<bool>();
    if (!key->IsString()) continue;

    Local<Value> value;
    Local<String> value_string;
    if (!entries->Get(context, key).ToLocal(&value) ||
        !value->ToString(context).ToLocal(&value_string)) {
      return Nothing<bool>();
    }

    Set(isolate, key.As<String>(), value_string);
  }",46,,301,4,,void
159267,BLOCK,-1,,<empty>,7,,304,2,,void
159276,BLOCK,-1,,<empty>,27,,305,2,,void
159313,BLOCK,-1,,"{
      return Nothing<bool>();
    }",59,,310,2,,void
159332,BLOCK,-1,,"{
  HandleScope scope(isolate);
  Local<Array> keys = Enumerate(isolate);
  uint32_t keys_length = keys->Length();
  for (uint32_t i = 0; i < keys_length; i++) {
    Local<Value> key;
    Local<String> value;
    bool ok = keys->Get(context, i).ToLocal(&key);
    ok = ok && key->IsString();
    ok = ok && Get(isolate, key.As<String>()).ToLocal(&value);
    ok = ok && object->Set(context, key, value).To(&ok);
    if (!ok) return Nothing<bool>();
  }
  return Just(true);
}",67,,323,4,,void
159352,BLOCK,-1,,<empty>,3,,327,1,,void
159362,BLOCK,4,,"{
    Local<Value> key;
    Local<String> value;
    bool ok = keys->Get(context, i).ToLocal(&key);
    ok = ok && key->IsString();
    ok = ok && Get(isolate, key.As<String>()).ToLocal(&value);
    ok = ok && object->Set(context, key, value).To(&ok);
    if (!ok) return Nothing<bool>();
  }",46,,327,4,,void
159429,BLOCK,-1,,<empty>,14,,334,2,,void
159440,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  CHECK(env->has_run_bootstrapping_code());
  if (property->IsSymbol()) {
    return info.GetReturnValue().SetUndefined();
  }
  CHECK(property->IsString());
  MaybeLocal<String> value_string =
      env->env_vars()->Get(env->isolate(), property.As<String>());
  if (!value_string.IsEmpty()) {
    info.GetReturnValue().Set(value_string.ToLocalChecked());
  }
}",64,,340,3,,void
159459,BLOCK,-1,,"{
    return info.GetReturnValue().SetUndefined();
  }",29,,343,2,,void
159500,BLOCK,-1,,"{
    info.GetReturnValue().Set(value_string.ToLocalChecked());
  }",32,,349,2,,void
159518,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  CHECK(env->has_run_bootstrapping_code());
  // calling env->EmitProcessEnvWarning() sets a variable indicating that
  // warnings have been emitted. It should be called last after other
  // conditions leading to a warning have been met.
  if (env->options()->pending_deprecation && !value->IsString() &&
      !value->IsNumber() && !value->IsBoolean() &&
      env->EmitProcessEnvWarning()) {
    if (ProcessEmitDeprecationWarning(
            env,
            ""Assigning any value other than a string, number, or boolean to a ""
            ""process.env property is deprecated. Please make sure to convert ""
            ""the ""
            ""value to a string before setting process.env with it."",
            ""DEP0104"")
            .IsNothing())
      return;
  }

  Local<String> key;
  Local<String> value_string;
  if (!property->ToString(env->context()).ToLocal(&key) ||
      !value->ToString(env->context()).ToLocal(&value_string)) {
 ...",64,,356,4,,void
159562,BLOCK,-1,,"{
    if (ProcessEmitDeprecationWarning(
            env,
            ""Assigning any value other than a string, number, or boolean to a ""
            ""process.env property is deprecated. Please make sure to convert ""
            ""the ""
            ""value to a string before setting process.env with it."",
            ""DEP0104"")
            .IsNothing())
      return;
  }",37,,364,2,,void
159571,BLOCK,-1,,<empty>,7,,373,2,,void
159613,BLOCK,-1,,"{
    return;
  }",64,,379,2,,void
159641,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  CHECK(env->has_run_bootstrapping_code());
  if (property->IsString()) {
    int32_t rc = env->env_vars()->Query(env->isolate(), property.As<String>());
    if (rc != -1) info.GetReturnValue().Set(rc);
  }
}",65,,390,3,,void
159660,BLOCK,-1,,"{
    int32_t rc = env->env_vars()->Query(env->isolate(), property.As<String>());
    if (rc != -1) info.GetReturnValue().Set(rc);
  }",29,,393,2,,void
159684,BLOCK,-1,,<empty>,19,,395,2,,void
159698,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  CHECK(env->has_run_bootstrapping_code());
  if (property->IsString()) {
    env->env_vars()->Delete(env->isolate(), property.As<String>());
  }

  // process.env never has non-configurable properties, so always
  // return true like the tc39 delete operator.
  info.GetReturnValue().Set(true);
}",67,,400,3,,void
159717,BLOCK,-1,,"{
    env->env_vars()->Delete(env->isolate(), property.As<String>());
  }",29,,403,2,,void
159745,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  CHECK(env->has_run_bootstrapping_code());

  info.GetReturnValue().Set(
      env->env_vars()->Enumerate(env->isolate()));
}",68,,412,2,,void
159783,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  if (desc.has_value()) {
    if (!desc.has_writable() ||
        !desc.has_enumerable() ||
        !desc.has_configurable()) {
      THROW_ERR_INVALID_OBJECT_DEFINE_PROPERTY(env,
                                               ""'process.env' only accepts a ""
                                               ""configurable, writable,""
                                               "" and enumerable ""
                                               ""data descriptor"");
    } else if (!desc.configurable() ||
               !desc.enumerable() ||
               !desc.writable()) {
      THROW_ERR_INVALID_OBJECT_DEFINE_PROPERTY(env,
                                               ""'process.env' only accepts a ""
                                               ""configurable, writable,""
                                               "" and enumerable ""
                                               ""data descriptor"");
    } else {
      return EnvS...",65,,422,4,,void
159797,BLOCK,-1,,"{
    if (!desc.has_writable() ||
        !desc.has_enumerable() ||
        !desc.has_configurable()) {
      THROW_ERR_INVALID_OBJECT_DEFINE_PROPERTY(env,
                                               ""'process.env' only accepts a ""
                                               ""configurable, writable,""
                                               "" and enumerable ""
                                               ""data descriptor"");
    } else if (!desc.configurable() ||
               !desc.enumerable() ||
               !desc.writable()) {
      THROW_ERR_INVALID_OBJECT_DEFINE_PROPERTY(env,
                                               ""'process.env' only accepts a ""
                                               ""configurable, writable,""
                                               "" and enumerable ""
                                               ""data descriptor"");
    } else {
      return EnvSetter(property, desc.value(), info);
    }
  }",25,,424,2,,void
159816,BLOCK,-1,,"{
      THROW_ERR_INVALID_OBJECT_DEFINE_PROPERTY(env,
                                               ""'process.env' only accepts a ""
                                               ""configurable, writable,""
                                               "" and enumerable ""
                                               ""data descriptor"");
    }",35,,427,2,,void
159821,BLOCK,-1,,<empty>,12,,433,1,,void
159840,BLOCK,-1,,"{
      THROW_ERR_INVALID_OBJECT_DEFINE_PROPERTY(env,
                                               ""'process.env' only accepts a ""
                                               ""configurable, writable,""
                                               "" and enumerable ""
                                               ""data descriptor"");
    }",34,,435,2,,void
159845,BLOCK,-1,,"{
      return EnvSetter(property, desc.value(), info);
    }",12,,441,1,,void
159855,BLOCK,-1,,<empty>,10,,444,1,,void
159866,BLOCK,-1,,"{
    // we don't accept a getter/setter in 'process.env'
    THROW_ERR_INVALID_OBJECT_DEFINE_PROPERTY(env,
                                             ""'process.env' does not accept an""
                                             "" accessor(getter/setter)""
                                             "" descriptor"");
  }",48,,444,2,,void
159871,BLOCK,-1,,"{
    THROW_ERR_INVALID_OBJECT_DEFINE_PROPERTY(env,
                                             ""'process.env' only accepts a ""
                                             ""configurable, writable,""
                                             "" and enumerable ""
                                             ""data descriptor"");
  }",10,,450,1,,void
159880,BLOCK,-1,,"{
  HandleScope scope(isolate);
  if (!isolate_data->env_proxy_template().IsEmpty()) return;
  Local<FunctionTemplate> env_proxy_ctor_template =
      FunctionTemplate::New(isolate);
  Local<ObjectTemplate> env_proxy_template =
      ObjectTemplate::New(isolate, env_proxy_ctor_template);
  env_proxy_template->SetHandler(NamedPropertyHandlerConfiguration(
      EnvGetter,
      EnvSetter,
      EnvQuery,
      EnvDeleter,
      EnvEnumerator,
      EnvDefiner,
      nullptr,
      Local<Value>(),
      PropertyHandlerFlags::kHasNoSideEffect));
  isolate_data->set_env_proxy_template(env_proxy_template);
  isolate_data->set_env_proxy_ctor_template(env_proxy_ctor_template);
}",74,,459,3,,void
159893,BLOCK,-1,,<empty>,54,,461,2,,void
159948,BLOCK,-1,,"{
  registry->Register(EnvGetter);
  registry->Register(EnvSetter);
  registry->Register(EnvQuery);
  registry->Register(EnvDeleter);
  registry->Register(EnvEnumerator);
  registry->Register(EnvDefiner);
}",76,,480,2,,void
159984,BLOCK,-1,,"{
#if HAVE_INSPECTOR
    env->inspector_agent()->ReportUncaughtException(error, message);
#endif
  }",36,,376,1,,void
159991,BLOCK,-1,,"{
      Local<Value> enhanced;
      Local<Value> argv[] = {err_obj};
      if (!enhancer.IsEmpty() &&
          enhancer
              ->Call(env->context(), Undefined(isolate), arraysize(argv), argv)
              .ToLocal(&enhanced)) {
        stack_trace = enhanced;
      }
    }",55,,396,2,,void
160027,BLOCK,-1,,"{
        stack_trace = enhanced;
      }",36,,402,2,,void
160058,BLOCK,-1,,<empty>,1,,1,1,,ANY
160063,BLOCK,-1,,"{
  if (!er.IsEmpty() && er->IsObject()) {
    Local<Object> err_obj = er.As<Object>();
    auto maybe_value =
        err_obj->GetPrivate(env->context(), env->decorated_private_symbol());
    Local<Value> decorated;
    return maybe_value.ToLocal(&decorated) && decorated->IsTrue();
  }
  return false;
}",62,,37,3,,void
160075,BLOCK,-1,,"{
    Local<Object> err_obj = er.As<Object>();
    auto maybe_value =
        err_obj->GetPrivate(env->context(), env->decorated_private_symbol());
    Local<Value> decorated;
    return maybe_value.ToLocal(&decorated) && decorated->IsTrue();
  }",40,,38,2,,void
160129,BLOCK,-1,,"{
  v8::TryCatch try_catch(isolate);
  HandleScope handle_scope(isolate);
  Environment* env = Environment::GetCurrent(context);

  // The ScriptResourceName of the message may be different from the one we use
  // to compile the script. V8 replaces it when it detects magic comments in
  // the source texts.
  Local<Value> script_resource_name = message->GetScriptResourceName();
  int linenum = message->GetLineNumber(context).FromJust();
  int columnum = message->GetStartColumn(context).FromJust();

  Local<Value> argv[] = {script_resource_name,
                         v8::Int32::New(isolate, linenum),
                         v8::Int32::New(isolate, columnum)};
  MaybeLocal<Value> maybe_ret = env->get_source_map_error_source()->Call(
      context, Undefined(isolate), arraysize(argv), argv);
  Local<Value> ret;
  if (!maybe_ret.ToLocal(&ret)) {
    // Ignore the caught exceptions.
    DCHECK(try_catch.HasCaught());
    return std::string();
  }
  if (!ret->IsString()) {
    return...",72,,55,5,,void
160229,BLOCK,-1,,"{
    // Ignore the caught exceptions.
    DCHECK(try_catch.HasCaught());
    return std::string();
  }",33,,73,2,,void
160246,BLOCK,-1,,"{
    return std::string();
  }",25,,78,2,,void
160273,BLOCK,-1,,"{
  MaybeLocal<String> source_line_maybe = message->GetSourceLine(context);
  node::Utf8Value encoded_source(isolate, source_line_maybe.ToLocalChecked());
  std::string sourceline(*encoded_source, encoded_source.length());
  *added_exception_line = false;

  if (sourceline.find(""node-do-not-add-exception-line"") != std::string::npos) {
    return sourceline;
  }

  // If source maps have been enabled, the exception line will instead be
  // added in the JavaScript context:
  Environment* env = Environment::GetCurrent(isolate);
  const bool has_source_map_url =
      !message->GetScriptOrigin().SourceMapUrl().IsEmpty() &&
      !message->GetScriptOrigin().SourceMapUrl()->IsUndefined();
  if (has_source_map_url && env != nullptr && env->source_maps_enabled()) {
    std::string source = GetSourceMapErrorSource(
        isolate, context, message, added_exception_line);
    if (*added_exception_line) {
      return source;
    }
  }

  // Because of how node modules work, all scripts are ...",63,,89,5,,void
160316,BLOCK,-1,,"{
    return sourceline;
  }",79,,95,2,,void
160364,BLOCK,-1,,"{
    std::string source = GetSourceMapErrorSource(
        isolate, context, message, added_exception_line);
    if (*added_exception_line) {
      return source;
    }
  }",75,,105,2,,void
160376,BLOCK,-1,,"{
      return source;
    }",32,,108,2,,void
160454,BLOCK,-1,,"{
    CHECK_GE(end, start);
    start -= script_start;
    end -= script_start;
  }",30,,145,2,,void
160502,BLOCK,-1,,"{
    return buf;
  }",53,,160,2,,void
160515,BLOCK,-1,,<empty>,3,,168,1,,void
160525,BLOCK,4,,"{
    if (sourceline[i] == '\0' || off >= kUnderlineBufsize) {
      break;
    }
    CHECK_LT(off, kUnderlineBufsize);
    underline_buf[off++] = (sourceline[i] == '\t') ? '\t' : ' ';
  }",35,,168,4,,void
160536,BLOCK,-1,,"{
      break;
    }",60,,169,2,,void
160555,BLOCK,-1,,<empty>,3,,175,1,,void
160565,BLOCK,4,,"{
    if (sourceline[i] == '\0' || off >= kUnderlineBufsize) {
      break;
    }
    CHECK_LT(off, kUnderlineBufsize);
    underline_buf[off++] = '^';
  }",37,,175,4,,void
160576,BLOCK,-1,,"{
      break;
    }",60,,176,2,,void
160610,BLOCK,-1,,"{
  std::string result;
  for (int i = 0; i < stack->GetFrameCount(); i++) {
    Local<StackFrame> stack_frame = stack->GetFrame(isolate, i);
    node::Utf8Value fn_name_s(isolate, stack_frame->GetFunctionName());
    node::Utf8Value script_name(isolate, stack_frame->GetScriptName());
    const int line_number = stack_frame->GetLineNumber();
    const int column = stack_frame->GetColumn();

    if (stack_frame->IsEval()) {
      if (stack_frame->GetScriptId() == Message::kNoScriptIdInfo) {
        result += SPrintF(""    at [eval]:%i:%i\n"", line_number, column);
      } else {
        std::vector<char> buf(script_name.length() + 64);
        snprintf(buf.data(),
                 buf.size(),
                 ""    at [eval] (%s:%i:%i)\n"",
                 *script_name,
                 line_number,
                 column);
        result += std::string(buf.data());
      }
      break;
    }

    if (fn_name_s.length() == 0) {
      std::vector<char> buf(script_name.length() + 64);
  ...",80,,188,3,,void
160613,BLOCK,-1,,<empty>,3,,190,1,,void
160626,BLOCK,4,,"{
    Local<StackFrame> stack_frame = stack->GetFrame(isolate, i);
    node::Utf8Value fn_name_s(isolate, stack_frame->GetFunctionName());
    node::Utf8Value script_name(isolate, stack_frame->GetScriptName());
    const int line_number = stack_frame->GetLineNumber();
    const int column = stack_frame->GetColumn();

    if (stack_frame->IsEval()) {
      if (stack_frame->GetScriptId() == Message::kNoScriptIdInfo) {
        result += SPrintF(""    at [eval]:%i:%i\n"", line_number, column);
      } else {
        std::vector<char> buf(script_name.length() + 64);
        snprintf(buf.data(),
                 buf.size(),
                 ""    at [eval] (%s:%i:%i)\n"",
                 *script_name,
                 line_number,
                 column);
        result += std::string(buf.data());
      }
      break;
    }

    if (fn_name_s.length() == 0) {
      std::vector<char> buf(script_name.length() + 64);
      snprintf(buf.data(),
               buf.size(),
               ""    at ...",52,,190,4,,void
160672,BLOCK,-1,,"{
      if (stack_frame->GetScriptId() == Message::kNoScriptIdInfo) {
        result += SPrintF(""    at [eval]:%i:%i\n"", line_number, column);
      } else {
        std::vector<char> buf(script_name.length() + 64);
        snprintf(buf.data(),
                 buf.size(),
                 ""    at [eval] (%s:%i:%i)\n"",
                 *script_name,
                 line_number,
                 column);
        result += std::string(buf.data());
      }
      break;
    }",32,,197,2,,void
160682,BLOCK,-1,,"{
        result += SPrintF(""    at [eval]:%i:%i\n"", line_number, column);
      }",67,,198,2,,void
160690,BLOCK,-1,,"{
        std::vector<char> buf(script_name.length() + 64);
        snprintf(buf.data(),
                 buf.size(),
                 ""    at [eval] (%s:%i:%i)\n"",
                 *script_name,
                 line_number,
                 column);
        result += std::string(buf.data());
      }",14,,200,1,,void
160731,BLOCK,-1,,"{
      std::vector<char> buf(script_name.length() + 64);
      snprintf(buf.data(),
               buf.size(),
               ""    at %s:%i:%i\n"",
               *script_name,
               line_number,
               column);
      result += std::string(buf.data());
    }",34,,213,2,,void
160765,BLOCK,-1,,"{
      std::vector<char> buf(fn_name_s.length() + script_name.length() + 64);
      snprintf(buf.data(),
               buf.size(),
               ""    at %s (%s:%i:%i)\n"",
               *fn_name_s,
               *script_name,
               line_number,
               column);
      result += std::string(buf.data());
    }",12,,222,1,,void
160811,BLOCK,-1,,"{
  FPrintF(stderr, ""%s\n"", str);
  fflush(stderr);
}",59,,237,2,,void
160822,BLOCK,-1,,"{
  PrintToStderrAndFlush(FormatStackTrace(isolate, stack));
}",65,,242,3,,void
160835,BLOCK,-1,,"{
  std::string result;
  node::Utf8Value reason(isolate,
                         err->ToDetailString(context)
                             .FromMaybe(Local<String>()));
  if (add_source_line) {
    bool added_exception_line = false;
    std::string source =
        GetErrorSource(isolate, context, message, &added_exception_line);
    result = source + '\n';
  }
  result += reason.ToString() + '\n';

  Local<v8::StackTrace> stack = message->GetStackTrace();
  if (!stack.IsEmpty()) result += FormatStackTrace(isolate, stack);
  return result;
}",64,,250,6,,void
160851,BLOCK,-1,,"{
    bool added_exception_line = false;
    std::string source =
        GetErrorSource(isolate, context, message, &added_exception_line);
    result = source + '\n';
  }",24,,255,2,,void
160896,BLOCK,-1,,<empty>,25,,264,2,,void
160910,BLOCK,-1,,"{
  CHECK(try_catch.HasCaught());
  return FormatCaughtException(
      isolate, context, try_catch.Exception(), try_catch.Message());
}",66,,270,4,,void
160934,BLOCK,-1,,"{
  PrintToStderrAndFlush(FormatCaughtException(isolate, context, try_catch));
}",58,,278,4,,void
160947,BLOCK,-1,,"{
  if (message.IsEmpty()) return;

  HandleScope scope(env->isolate());
  Local<Object> err_obj;
  if (!er.IsEmpty() && er->IsObject()) {
    err_obj = er.As<Object>();
    // If arrow_message is already set, skip.
    auto maybe_value = err_obj->GetPrivate(env->context(),
                                          env->arrow_message_private_symbol());
    Local<Value> lvalue;
    if (!maybe_value.ToLocal(&lvalue) || lvalue->IsString())
      return;
  }

  bool added_exception_line = false;
  std::string source = GetErrorSource(
      env->isolate(), env->context(), message, &added_exception_line);
  if (!added_exception_line) {
    return;
  }
  MaybeLocal<Value> arrow_str = ToV8Value(env->context(), source);

  const bool can_set_arrow = !arrow_str.IsEmpty() && !err_obj.IsEmpty();
  // If allocating arrow_str failed, print it out. There's not much else to do.
  // If it's not an error, but something needs to be printed out because
  // it's a fatal exception, also print it out fr...",55,,285,5,,void
160953,BLOCK,-1,,<empty>,26,,286,2,,void
160977,BLOCK,-1,,"{
    err_obj = er.As<Object>();
    // If arrow_message is already set, skip.
    auto maybe_value = err_obj->GetPrivate(env->context(),
                                          env->arrow_message_private_symbol());
    Local<Value> lvalue;
    if (!maybe_value.ToLocal(&lvalue) || lvalue->IsString())
      return;
  }",40,,290,2,,void
161017,BLOCK,-1,,<empty>,7,,297,2,,void
161041,BLOCK,-1,,"{
    return;
  }",30,,303,2,,void
161082,BLOCK,-1,,"{
    if (env->printed_error()) return;
    Mutex::ScopedLock lock(per_process::tty_mutex);
    env->set_printed_error(true);

    ResetStdio();
    FPrintF(stderr, ""\n%s"", source);
    return;
  }",77,,314,2,,void
161088,BLOCK,-1,,<empty>,31,,315,2,,void
161130,BLOCK,-1,,"{
  DumpBacktrace(stderr);
  fflush(stderr);
  ABORT_NO_BACKTRACE();
}",27,,331,1,,void
161139,BLOCK,-1,,"{
  std::string name = GetHumanReadableProcessName();

  fprintf(stderr,
          ""%s: %s:%s%s Assertion `%s' failed.\n"",
          name.c_str(),
          info.file_line,
          info.function,
          *info.function ? "":"" : """",
          info.message);
  fflush(stderr);

  Abort();
}",53,,337,2,,void
161178,BLOCK,-1,,"{
  if (!env->can_call_into_js())
    enhance_stack = EnhanceFatalException::kDontEnhance;

  Isolate* isolate = env->isolate();
  CHECK(!error.IsEmpty());
  CHECK(!message.IsEmpty());
  HandleScope scope(isolate);

  AppendExceptionLine(env, error, message, FATAL_ERROR);

  auto report_to_inspector = [&]() {
#if HAVE_INSPECTOR
    env->inspector_agent()->ReportUncaughtException(error, message);
#endif
  };

  Local<Value> arrow;
  Local<Value> stack_trace;
  bool decorated = IsExceptionDecorated(env, error);

  if (!error->IsObject()) {  // We can only enhance actual errors.
    report_to_inspector();
    stack_trace = Undefined(isolate);
    // If error is not an object, AppendExceptionLine() has already print the
    // source line and the arrow to stderr.
    // TODO(joyeecheung): move that side effect out of AppendExceptionLine().
    // It is done just to preserve the source line as soon as possible.
  } else {
    Local<Object> err_obj = error.As<Object>();

    auto enhance_...",71,,365,5,,void
161185,BLOCK,-1,,<empty>,5,,367,2,,void
161243,BLOCK,-1,,"{  // We can only enhance actual errors.
    report_to_inspector();
    stack_trace = Undefined(isolate);
    // If error is not an object, AppendExceptionLine() has already print the
    // source line and the arrow to stderr.
    // TODO(joyeecheung): move that side effect out of AppendExceptionLine().
    // It is done just to preserve the source line as soon as possible.
  }",27,,386,2,,void
161250,BLOCK,-1,,"{
    Local<Object> err_obj = error.As<Object>();

    auto enhance_with = [&](Local<Function> enhancer) {
      Local<Value> enhanced;
      Local<Value> argv[] = {err_obj};
      if (!enhancer.IsEmpty() &&
          enhancer
              ->Call(env->context(), Undefined(isolate), arraysize(argv), argv)
              .ToLocal(&enhanced)) {
        stack_trace = enhanced;
      }
    };

    switch (enhance_stack) {
      case EnhanceFatalException::kEnhance: {
        enhance_with(env->enhance_fatal_stack_before_inspector());
        report_to_inspector();
        enhance_with(env->enhance_fatal_stack_after_inspector());
        break;
      }
      case EnhanceFatalException::kDontEnhance: {
        USE(err_obj->Get(env->context(), env->stack_string())
                .ToLocal(&stack_trace));
        report_to_inspector();
        break;
      }
      default:
        UNREACHABLE();
    }

    arrow =
        err_obj->GetPrivate(env->context(), env->arrow_message_private_symbol()...",10,,393,1,,void
161267,BLOCK,-1,,"{
      case EnhanceFatalException::kEnhance: {
        enhance_with(env->enhance_fatal_stack_before_inspector());
        report_to_inspector();
        enhance_with(env->enhance_fatal_stack_after_inspector());
        break;
      }
      case EnhanceFatalException::kDontEnhance: {
        USE(err_obj->Get(env->context(), env->stack_string())
                .ToLocal(&stack_trace));
        report_to_inspector();
        break;
      }
      default:
        UNREACHABLE();
    }",28,,407,2,,void
161272,BLOCK,3,,"{
        enhance_with(env->enhance_fatal_stack_before_inspector());
        report_to_inspector();
        enhance_with(env->enhance_fatal_stack_after_inspector());
        break;
      }",45,,408,3,,void
161289,BLOCK,6,,"{
        USE(err_obj->Get(env->context(), env->stack_string())
                .ToLocal(&stack_trace));
        report_to_inspector();
        break;
      }",49,,414,6,,void
161353,BLOCK,-1,,"{
    if (arrow.IsEmpty() || !arrow->IsString() || decorated) {
      FPrintF(stderr, ""%s\n"", trace);
    } else {
      node::Utf8Value arrow_string(env->isolate(), arrow);
      FPrintF(stderr, ""%s\n%s\n"", arrow_string, trace);
    }
  }",58,,433,2,,void
161367,BLOCK,-1,,"{
      FPrintF(stderr, ""%s\n"", trace);
    }",61,,434,2,,void
161373,BLOCK,-1,,"{
      node::Utf8Value arrow_string(env->isolate(), arrow);
      FPrintF(stderr, ""%s\n%s\n"", arrow_string, trace);
    }",12,,436,1,,void
161387,BLOCK,-1,,"{
    // this really only happens for RangeErrors, since they're the only
    // kind that won't have all this info in the trace, or when non-Error
    // objects are thrown manually.
    MaybeLocal<Value> message;
    MaybeLocal<Value> name;

    if (error->IsObject()) {
      Local<Object> err_obj = error.As<Object>();
      message = err_obj->Get(env->context(), env->message_string());
      name = err_obj->Get(env->context(), env->name_string());
    }

    if (message.IsEmpty() || message.ToLocalChecked()->IsUndefined() ||
        name.IsEmpty() || name.ToLocalChecked()->IsUndefined()) {
      // Not an error object. Just print as-is.
      node::Utf8Value message(env->isolate(), error);

      FPrintF(
          stderr,
          ""%s\n"",
          *message ? message.ToStringView() : ""<toString() threw exception>"");
    } else {
      node::Utf8Value name_string(env->isolate(), name.ToLocalChecked());
      node::Utf8Value message_string(env->isolate(), message.ToLocalChecked()...",10,,440,1,,void
161403,BLOCK,-1,,"{
      Local<Object> err_obj = error.As<Object>();
      message = err_obj->Get(env->context(), env->message_string());
      name = err_obj->Get(env->context(), env->name_string());
    }",28,,447,2,,void
161468,BLOCK,-1,,"{
      // Not an error object. Just print as-is.
      node::Utf8Value message(env->isolate(), error);

      FPrintF(
          stderr,
          ""%s\n"",
          *message ? message.ToStringView() : ""<toString() threw exception>"");
    }",65,,454,2,,void
161488,BLOCK,-1,,"{
      node::Utf8Value name_string(env->isolate(), name.ToLocalChecked());
      node::Utf8Value message_string(env->isolate(), message.ToLocalChecked());
      // Update the report message if it is an object has message property.
      report_message = message_string.ToString();

      if (arrow.IsEmpty() || !arrow->IsString() || decorated) {
        FPrintF(stderr, ""%s: %s\n"", name_string, message_string);
      } else {
        node::Utf8Value arrow_string(env->isolate(), arrow);
        FPrintF(stderr,
            ""%s\n%s: %s\n"", arrow_string, name_string, message_string);
      }
    }",12,,462,1,,void
161528,BLOCK,-1,,"{
        FPrintF(stderr, ""%s: %s\n"", name_string, message_string);
      }",63,,468,2,,void
161535,BLOCK,-1,,"{
        node::Utf8Value arrow_string(env->isolate(), arrow);
        FPrintF(stderr,
            ""%s\n%s: %s\n"", arrow_string, name_string, message_string);
      }",14,,470,1,,void
161557,BLOCK,-1,,"{
      std::string argv0;
      if (!env->argv().empty()) argv0 = env->argv()[0];
      if (argv0.empty()) argv0 = ""node"";
      FPrintF(stderr,
              ""(Use `%s --trace-uncaught ...` to show where the exception ""
              ""was thrown)\n"",
              fs::Basename(argv0, "".exe""));
    }",42,,477,2,,void
161568,BLOCK,-1,,<empty>,33,,479,2,,void
161582,BLOCK,-1,,<empty>,26,,480,2,,void
161605,BLOCK,-1,,"{
    TriggerNodeReport(env, report_message.c_str(), ""Exception"", """", error);
  }",66,,488,2,,void
161622,BLOCK,-1,,"{
    Local<StackTrace> trace = message->GetStackTrace();
    if (!trace.IsEmpty()) {
      FPrintF(stderr, ""Thrown at:\n"");
      PrintStackTrace(env->isolate(), trace);
    }
  }",39,,492,2,,void
161639,BLOCK,-1,,"{
      FPrintF(stderr, ""Thrown at:\n"");
      PrintStackTrace(env->isolate(), trace);
    }",27,,494,2,,void
161656,BLOCK,-1,,"{
    FPrintF(stderr, ""\nNode.js %s\n"", NODE_VERSION);
  }",54,,500,2,,void
161667,BLOCK,-1,,"{
  if (location) {
    FPrintF(stderr, ""FATAL ERROR: %s %s\n"", location, message);
  } else {
    FPrintF(stderr, ""FATAL ERROR: %s\n"", message);
  }

  Isolate* isolate = Isolate::TryGetCurrent();
  bool report_on_fatalerror;
  {
    Mutex::ScopedLock lock(node::per_process::cli_options_mutex);
    report_on_fatalerror = per_process::cli_options->report_on_fatalerror;
  }

  if (report_on_fatalerror) {
    TriggerNodeReport(isolate, message, ""FatalError"", """", Local<Object>());
  }

  fflush(stderr);
  ABORT();
}",75,,507,3,,void
161670,BLOCK,-1,,"{
    FPrintF(stderr, ""FATAL ERROR: %s %s\n"", location, message);
  }",17,,508,2,,void
161677,BLOCK,-1,,"{
    FPrintF(stderr, ""FATAL ERROR: %s\n"", message);
  }",10,,510,1,,void
161690,BLOCK,5,,"{
    Mutex::ScopedLock lock(node::per_process::cli_options_mutex);
    report_on_fatalerror = per_process::cli_options->report_on_fatalerror;
  }",3,,516,5,,void
161707,BLOCK,-1,,"{
    TriggerNodeReport(isolate, message, ""FatalError"", """", Local<Object>());
  }",29,,521,2,,void
161721,BLOCK,-1,,"{
  const char* message =
      details.is_heap_oom ? ""Allocation failed - JavaScript heap out of memory""
                          : ""Allocation failed - process out of memory"";
  if (location) {
    FPrintF(stderr, ""FATAL ERROR: %s %s\n"", location, message);
  } else {
    FPrintF(stderr, ""FATAL ERROR: %s\n"", message);
  }

  Isolate* isolate = Isolate::TryGetCurrent();
  bool report_on_fatalerror;
  {
    Mutex::ScopedLock lock(node::per_process::cli_options_mutex);
    report_on_fatalerror = per_process::cli_options->report_on_fatalerror;
  }

  if (report_on_fatalerror) {
    // Trigger report with the isolate. Environment::GetCurrent may return
    // nullptr here:
    // - If the OOM is reported by a young generation space allocation,
    //   Isolate::GetCurrentContext returns an empty handle.
    // - Otherwise, Isolate::GetCurrentContext returns a non-empty handle.
    TriggerNodeReport(isolate, message, ""OOMError"", """", Local<Object>());
  }

  fflush(stderr);
  ABORT();
}",66,,530,3,,void
161733,BLOCK,-1,,"{
    FPrintF(stderr, ""FATAL ERROR: %s %s\n"", location, message);
  }",17,,534,2,,void
161740,BLOCK,-1,,"{
    FPrintF(stderr, ""FATAL ERROR: %s\n"", message);
  }",10,,536,1,,void
161753,BLOCK,7,,"{
    Mutex::ScopedLock lock(node::per_process::cli_options_mutex);
    report_on_fatalerror = per_process::cli_options->report_on_fatalerror;
  }",3,,542,7,,void
161770,BLOCK,-1,,"{
    // Trigger report with the isolate. Environment::GetCurrent may return
    // nullptr here:
    // - If the OOM is reported by a young generation space allocation,
    //   Isolate::GetCurrentContext returns an empty handle.
    // - Otherwise, Isolate::GetCurrentContext returns a non-empty handle.
    TriggerNodeReport(isolate, message, ""OOMError"", """", Local<Object>());
  }",29,,547,2,,void
161785,BLOCK,-1,,"{
  HandleScope scope(context->GetIsolate());

  Environment* env = Environment::GetCurrent(context);
  if (env->source_maps_enabled()) {
    // We do not expect the maybe_cache_generated_source_map to throw any more
    // exceptions. If it does, just ignore it.
    errors::TryCatchScope try_catch(env);
    Local<Function> maybe_cache_source_map =
        env->maybe_cache_generated_source_map();
    Local<Value> argv[1] = {source};

    MaybeLocal<Value> maybe_cached = maybe_cache_source_map->Call(
        context, context->Global(), arraysize(argv), argv);
    if (maybe_cached.IsEmpty()) {
      DCHECK(try_catch.HasCaught());
    }
  }

  Local<Value> allow_code_gen = context->GetEmbedderData(
      ContextEmbedderIndex::kAllowCodeGenerationFromStrings);
  bool codegen_allowed =
      allow_code_gen->IsUndefined() || allow_code_gen->IsTrue();
  return {
      codegen_allowed,
      {},
  };
}",24,,563,4,,void
161805,BLOCK,-1,,"{
    // We do not expect the maybe_cache_generated_source_map to throw any more
    // exceptions. If it does, just ignore it.
    errors::TryCatchScope try_catch(env);
    Local<Function> maybe_cache_source_map =
        env->maybe_cache_generated_source_map();
    Local<Value> argv[1] = {source};

    MaybeLocal<Value> maybe_cached = maybe_cache_source_map->Call(
        context, context->Global(), arraysize(argv), argv);
    if (maybe_cached.IsEmpty()) {
      DCHECK(try_catch.HasCaught());
    }
  }",35,,567,2,,void
161850,BLOCK,-1,,"{
      DCHECK(try_catch.HasCaught());
    }",33,,577,2,,void
161886,BLOCK,-1,,"{
  if (HasCaught() && !HasTerminated() && mode_ == CatchMode::kFatal) {
    HandleScope scope(env_->isolate());
    Local<v8::Value> exception = Exception();
    Local<v8::Message> message = Message();
    EnhanceFatalException enhance = CanContinue() ?
        EnhanceFatalException::kEnhance : EnhanceFatalException::kDontEnhance;
    if (message.IsEmpty())
      message = Exception::CreateMessage(env_->isolate(), exception);
    ReportFatalException(env_, exception, message, enhance);
    env_->Exit(ExitCode::kExceptionInFatalExceptionHandler);
  }
}",33,,594,1,,void
161898,BLOCK,-1,,"{
    HandleScope scope(env_->isolate());
    Local<v8::Value> exception = Exception();
    Local<v8::Message> message = Message();
    EnhanceFatalException enhance = CanContinue() ?
        EnhanceFatalException::kEnhance : EnhanceFatalException::kDontEnhance;
    if (message.IsEmpty())
      message = Exception::CreateMessage(env_->isolate(), exception);
    ReportFatalException(env_, exception, message, enhance);
    env_->Exit(ExitCode::kExceptionInFatalExceptionHandler);
  }",70,,595,2,,void
161939,BLOCK,-1,,<empty>,7,,602,2,,void
161967,BLOCK,-1,,"{
#define ERRNO_CASE(e)                                                          \
  case e:                                                                      \
    return #e;
  switch (errorno) {
#ifdef EACCES
    ERRNO_CASE(EACCES);
#endif

#ifdef EADDRINUSE
    ERRNO_CASE(EADDRINUSE);
#endif

#ifdef EADDRNOTAVAIL
    ERRNO_CASE(EADDRNOTAVAIL);
#endif

#ifdef EAFNOSUPPORT
    ERRNO_CASE(EAFNOSUPPORT);
#endif

#ifdef EAGAIN
    ERRNO_CASE(EAGAIN);
#endif

#ifdef EWOULDBLOCK
#if EAGAIN != EWOULDBLOCK
    ERRNO_CASE(EWOULDBLOCK);
#endif
#endif

#ifdef EALREADY
    ERRNO_CASE(EALREADY);
#endif

#ifdef EBADF
    ERRNO_CASE(EBADF);
#endif

#ifdef EBADMSG
    ERRNO_CASE(EBADMSG);
#endif

#ifdef EBUSY
    ERRNO_CASE(EBUSY);
#endif

#ifdef ECANCELED
    ERRNO_CASE(ECANCELED);
#endif

#ifdef ECHILD
    ERRNO_CASE(ECHILD);
#endif

#ifdef ECONNABORTED
    ERRNO_CASE(ECONNABORTED);
#endif

#ifdef ECONNREFUSED
    ERRNO_CASE(ECONNREFUSED);
#endif

#ifdef ECONNRESET
    ERRNO_CASE(ECONNRESET)...",39,,608,2,,void
161970,BLOCK,-1,,"{
#ifdef EACCES
    ERRNO_CASE(EACCES);
#endif

#ifdef EADDRINUSE
    ERRNO_CASE(EADDRINUSE);
#endif

#ifdef EADDRNOTAVAIL
    ERRNO_CASE(EADDRNOTAVAIL);
#endif

#ifdef EAFNOSUPPORT
    ERRNO_CASE(EAFNOSUPPORT);
#endif

#ifdef EAGAIN
    ERRNO_CASE(EAGAIN);
#endif

#ifdef EWOULDBLOCK
#if EAGAIN != EWOULDBLOCK
    ERRNO_CASE(EWOULDBLOCK);
#endif
#endif

#ifdef EALREADY
    ERRNO_CASE(EALREADY);
#endif

#ifdef EBADF
    ERRNO_CASE(EBADF);
#endif

#ifdef EBADMSG
    ERRNO_CASE(EBADMSG);
#endif

#ifdef EBUSY
    ERRNO_CASE(EBUSY);
#endif

#ifdef ECANCELED
    ERRNO_CASE(ECANCELED);
#endif

#ifdef ECHILD
    ERRNO_CASE(ECHILD);
#endif

#ifdef ECONNABORTED
    ERRNO_CASE(ECONNABORTED);
#endif

#ifdef ECONNREFUSED
    ERRNO_CASE(ECONNREFUSED);
#endif

#ifdef ECONNRESET
    ERRNO_CASE(ECONNRESET);
#endif

#ifdef EDEADLK
    ERRNO_CASE(EDEADLK);
#endif

#ifdef EDESTADDRREQ
    ERRNO_CASE(EDESTADDRREQ);
#endif

#ifdef EDOM
    ERRNO_CASE(EDOM);
#endif

#ifdef EDQUOT
    ERRNO_CASE(EDQUOT);
#e...",20,,612,2,,void
161979,BLOCK,-1,,"{
  Isolate* isolate = message->GetIsolate();
  switch (message->ErrorLevel()) {
    case Isolate::MessageErrorLevel::kMessageWarning: {
      Environment* env = Environment::GetCurrent(isolate);
      if (!env) {
        break;
      }
      Utf8Value filename(isolate, message->GetScriptOrigin().ResourceName());
      // (filename):(line) (message)
      std::stringstream warning;
      warning << *filename;
      warning << "":"";
      warning << message->GetLineNumber(env->context()).FromMaybe(-1);
      warning << "" "";
      v8::String::Utf8Value msg(isolate, message->Get());
      warning << *msg;
      USE(ProcessEmitWarningGeneric(env, warning.str().c_str(), ""V8""));
      break;
    }
    case Isolate::MessageErrorLevel::kMessageError:
      TriggerUncaughtException(isolate, error, message);
      break;
  }
}",76,,936,3,,void
161992,BLOCK,-1,,"{
    case Isolate::MessageErrorLevel::kMessageWarning: {
      Environment* env = Environment::GetCurrent(isolate);
      if (!env) {
        break;
      }
      Utf8Value filename(isolate, message->GetScriptOrigin().ResourceName());
      // (filename):(line) (message)
      std::stringstream warning;
      warning << *filename;
      warning << "":"";
      warning << message->GetLineNumber(env->context()).FromMaybe(-1);
      warning << "" "";
      v8::String::Utf8Value msg(isolate, message->Get());
      warning << *msg;
      USE(ProcessEmitWarningGeneric(env, warning.str().c_str(), ""V8""));
      break;
    }
    case Isolate::MessageErrorLevel::kMessageError:
      TriggerUncaughtException(isolate, error, message);
      break;
  }",34,,938,2,,void
161999,BLOCK,3,,"{
      Environment* env = Environment::GetCurrent(isolate);
      if (!env) {
        break;
      }
      Utf8Value filename(isolate, message->GetScriptOrigin().ResourceName());
      // (filename):(line) (message)
      std::stringstream warning;
      warning << *filename;
      warning << "":"";
      warning << message->GetLineNumber(env->context()).FromMaybe(-1);
      warning << "" "";
      v8::String::Utf8Value msg(isolate, message->Get());
      warning << *msg;
      USE(ProcessEmitWarningGeneric(env, warning.str().c_str(), ""V8""));
      break;
    }",55,,939,3,,void
162011,BLOCK,-1,,"{
        break;
      }",17,,941,2,,void
162087,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(args);
  CHECK(args[0]->IsFunction());
  realm->set_prepare_stack_trace_callback(args[0].As<Function>());
}",76,,962,2,,void
162117,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsBoolean());
  env->set_source_maps_enabled(args[0].As<Boolean>()->Value());
}",75,,968,2,,void
162150,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsFunction());
  env->set_get_source_map_error_source(args[0].As<Function>());
}",46,,975,2,,void
162180,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsFunction());
  env->set_maybe_cache_generated_source_map(args[0].As<Function>());
}",46,,982,2,,void
162210,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(args);
  CHECK(args[0]->IsFunction());
  CHECK(args[1]->IsFunction());
  realm->set_enhance_fatal_stack_before_inspector(args[0].As<Function>());
  realm->set_enhance_fatal_stack_after_inspector(args[1].As<Function>());
}",46,,989,2,,void
162257,BLOCK,-1,,"{
  Local<Context> context = args.GetIsolate()->GetCurrentContext();
  Local<String> detail_string;
  if (args[0]->ToDetailString(context).ToLocal(&detail_string))
    args.GetReturnValue().Set(detail_string);
}",76,,998,2,,void
162289,BLOCK,-1,,<empty>,5,,1002,2,,void
162302,BLOCK,-1,,"{
  Isolate* isolate = args.GetIsolate();
  Environment* env = Environment::GetCurrent(isolate);
  Local<Value> exception = args[0];
  Local<Message> message = Exception::CreateMessage(isolate, exception);
  if (env != nullptr && env->abort_on_uncaught_exception()) {
    ReportFatalException(
        env, exception, message, EnhanceFatalException::kEnhance);
    Abort();
  }
  bool from_promise = args[1]->IsTrue();
  errors::TriggerUncaughtException(isolate, exception, message, from_promise);
}",79,,1005,2,,void
162348,BLOCK,-1,,"{
    ReportFatalException(
        env, exception, message, EnhanceFatalException::kEnhance);
    Abort();
  }",61,,1010,2,,void
162378,BLOCK,-1,,"{
  registry->Register(SetPrepareStackTraceCallback);
  registry->Register(SetGetSourceMapErrorSource);
  registry->Register(SetSourceMapsEnabled);
  registry->Register(SetMaybeCacheGeneratedSourceMap);
  registry->Register(SetEnhanceStackForFatalException);
  registry->Register(NoSideEffectsToString);
  registry->Register(TriggerUncaughtException);
}",70,,1019,2,,void
162421,BLOCK,-1,,"{
  SetMethod(context,
            target,
            ""setPrepareStackTraceCallback"",
            SetPrepareStackTraceCallback);
  SetMethod(context,
            target,
            ""setGetSourceMapErrorSource"",
            SetGetSourceMapErrorSource);
  SetMethod(context, target, ""setSourceMapsEnabled"", SetSourceMapsEnabled);
  SetMethod(context,
            target,
            ""setMaybeCacheGeneratedSourceMap"",
            SetMaybeCacheGeneratedSourceMap);
  SetMethod(context,
            target,
            ""setEnhanceStackForFatalException"",
            SetEnhanceStackForFatalException);
  SetMethodNoSideEffect(
      context, target, ""noSideEffectsToString"", NoSideEffectsToString);
  SetMethod(
      context, target, ""triggerUncaughtException"", TriggerUncaughtException);

  Isolate* isolate = context->GetIsolate();
  Local<Object> exit_codes = Object::New(isolate);
  READONLY_PROPERTY(target, ""exitCodes"", exit_codes);

#define V(Name, Code)                                     ...",29,,1032,5,,void
162486,BLOCK,-1,,"{
  Local<Value> exception = try_catch.Exception();

  if (!exception->IsObject()) return;

  Local<Object> err_obj = exception.As<Object>();

  if (IsExceptionDecorated(env, err_obj)) return;

  AppendExceptionLine(env, exception, try_catch.Message(), CONTEXTIFY_ERROR);
  TryCatchScope try_catch_scope(env);  // Ignore exceptions below.
  MaybeLocal<Value> stack = err_obj->Get(env->context(), env->stack_string());
  MaybeLocal<Value> maybe_value =
      err_obj->GetPrivate(env->context(), env->arrow_message_private_symbol());

  Local<Value> arrow;
  if (!(maybe_value.ToLocal(&arrow) && arrow->IsString())) {
    return;
  }

  if (stack.IsEmpty() || !stack.ToLocalChecked()->IsString()) {
    return;
  }

  Local<String> decorated_stack = String::Concat(
      env->isolate(),
      String::Concat(env->isolate(),
                     arrow.As<String>(),
                     FIXED_ONE_BYTE_STRING(env->isolate(), ""\n"")),
      stack.ToLocalChecked().As<String>());
  USE(err_obj->Set(env...",65,,1068,3,,void
162503,BLOCK,-1,,<empty>,31,,1071,2,,void
162519,BLOCK,-1,,<empty>,43,,1075,2,,void
162586,BLOCK,-1,,"{
    return;
  }",60,,1084,2,,void
162602,BLOCK,-1,,"{
    return;
  }",63,,1088,2,,void
162681,BLOCK,-1,,"{
  CHECK(!error.IsEmpty());
  HandleScope scope(isolate);

  if (message.IsEmpty()) message = Exception::CreateMessage(isolate, error);

  CHECK(isolate->InContext());
  Local<Context> context = isolate->GetCurrentContext();
  Environment* env = Environment::GetCurrent(context);
  if (env == nullptr) {
    // This means that the exception happens before Environment is assigned
    // to the context e.g. when there is a SyntaxError in a per-context
    // script - which usually indicates that there is a bug because no JS
    // error is supposed to be thrown at this point.
    // Since we don't have access to Environment here, there is not
    // much we can do, so we just print whatever is useful and crash.
    PrintToStderrAndFlush(
        FormatCaughtException(isolate, context, error, message));
    Abort();
  }

  // Invoke process._fatalException() to give user a chance to handle it.
  // We have to grab it from the process object since this has been
  // monkey-patchable.
  L...",50,,1106,5,,void
162696,BLOCK,-1,,<empty>,26,,1110,2,,void
162732,BLOCK,-1,,"{
    // This means that the exception happens before Environment is assigned
    // to the context e.g. when there is a SyntaxError in a per-context
    // script - which usually indicates that there is a bug because no JS
    // error is supposed to be thrown at this point.
    // Since we don't have access to Environment here, there is not
    // much we can do, so we just print whatever is useful and crash.
    PrintToStderrAndFlush(
        FormatCaughtException(isolate, context, error, message));
    Abort();
  }",23,,1115,2,,void
162784,BLOCK,-1,,"{
    ReportFatalException(
        env, error, message, EnhanceFatalException::kDontEnhance);
    env->Exit(ExitCode::kInvalidFatalExceptionMonkeyPatching);
    return;
  }",48,,1138,2,,void
162810,BLOCK,-1,,"{
    // We do not expect the global uncaught exception itself to throw any more
    // exceptions. If it does, exit the current Node.js instance.
    errors::TryCatchScope try_catch(env,
                                    errors::TryCatchScope::CatchMode::kFatal);
    // Explicitly disable verbose exception reporting -
    // if process._fatalException() throws an error, we don't want it to
    // trigger the per-isolate message listener which will call this
    // function and recurse.
    try_catch.SetVerbose(false);
    Local<Value> argv[2] = { error,
                             Boolean::New(env->isolate(), from_promise) };

    maybe_handled = fatal_exception_function.As<Function>()->Call(
        env->context(), process_object, arraysize(argv), argv);
  }",32,,1146,2,,void
162864,BLOCK,-1,,"{
    return;
  }",41,,1168,2,,void
162872,BLOCK,-1,,"{
    return;
  }",28,,1178,2,,void
162899,BLOCK,-1,,"{
  // If the try_catch is verbose, the per-isolate message listener is going to
  // handle it (which is going to call into another overload of
  // TriggerUncaughtException()).
  if (try_catch.IsVerbose()) {
    return;
  }

  // If the user calls TryCatch::TerminateExecution() on this TryCatch
  // they must call CancelTerminateExecution() again before invoking
  // TriggerUncaughtException() because it will invoke
  // process._fatalException() in the JS land.
  CHECK(!try_catch.HasTerminated());
  CHECK(try_catch.HasCaught());
  HandleScope scope(isolate);
  TriggerUncaughtException(isolate,
                           try_catch.Exception(),
                           try_catch.Message(),
                           false /* from_promise */);
}",80,,1191,3,,void
162905,BLOCK,-1,,"{
    return;
  }",30,,1195,2,,void
162935,BLOCK,-1,,"{
  if (!HasCaught()) {
    return;
  }
  std::string str =
      FormatCaughtException(isolate_,
                            isolate_->GetCurrentContext(),
                            Exception(),
                            Message(),
                            print_source_line_ == kPrintSourceLine);
  PrintToStderrAndFlush(str);
}",37,,1212,1,,void
162939,BLOCK,-1,,"{
    return;
  }",21,,1213,2,,void
162972,BLOCK,-1,,<empty>,1,,1,1,,ANY
162977,BLOCK,-1,,<empty>,1,,1,1,,ANY
162992,BLOCK,-1,,<empty>,1,,1,1,,ANY
162995,BLOCK,-1,,"{
  if (!is_finalized_) {
    external_references_.push_back(reinterpret_cast<intptr_t>(nullptr));
    is_finalized_ = true;
  }

  return external_references_;
}",79,,9,1,,void
162999,BLOCK,-1,,"{
    external_references_.push_back(reinterpret_cast<intptr_t>(nullptr));
    is_finalized_ = true;
  }",23,,10,2,,void
163015,BLOCK,-1,,"{
  this->Register(BaseObject::LazilyInitializedJSTemplateConstructor);

#define V(modname) _register_external_reference_##modname(this);
  EXTERNAL_REFERENCE_BINDING_LIST(V)
#undef V
  // TODO(joyeecheung): collect more external references here.
}",56,,18,1,,void
163039,BLOCK,-1,,<empty>,1,,1,1,,ANY
163048,BLOCK,-1,,<empty>,1,,1,1,,ANY
163052,BLOCK,-1,,"{
      char msg[70];
      snprintf(msg, arraysize(msg),
              ""Closing file descriptor %d on garbage collection failed"",
              detail.fd);
      // This exception will end up being fatal for the process because
      // it is being thrown from within the SetImmediate handler and
      // there is no JS stack to bubble it to. In other words, tearing
      // down the process is the only reasonable thing we can do here.
      HandleScope handle_scope(env->isolate());
      env->ThrowUVException(detail.ret, ""close"", msg);
    }",52,,362,2,,void
163084,BLOCK,-1,,"{
    ProcessEmitWarning(env,
                       ""Closing file descriptor %d on garbage collection"",
                       detail.fd);
    if (env->filehandle_close_warning()) {
      env->set_filehandle_close_warning(false);
      USE(ProcessEmitDeprecationWarning(
          env,
          ""Closing a FileHandle object on garbage collection is deprecated. ""
          ""Please close FileHandle objects explicitly using ""
          ""FileHandle.prototype.close(). In the future, an error will be ""
          ""thrown if a file descriptor is closed during garbage collection."",
          ""DEP0137""));
    }
  }",50,,381,2,,void
163096,BLOCK,-1,,"{
      env->set_filehandle_close_warning(false);
      USE(ProcessEmitDeprecationWarning(
          env,
          ""Closing a FileHandle object on garbage collection is deprecated. ""
          ""Please close FileHandle objects explicitly using ""
          ""FileHandle.prototype.close(). In the future, an error will be ""
          ""thrown if a file descriptor is closed during garbage collection."",
          ""DEP0137""));
    }",42,,385,2,,void
163112,BLOCK,-1,,"{
    CloseReq* req_wrap = CloseReq::from_req(req);
    FS_ASYNC_TRACE_END1(
        req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
    BaseObjectPtr<CloseReq> close(req_wrap);
    CHECK(close);
    close->file_handle()->AfterClose();
    if (!close->env()->can_call_into_js()) return;
    Isolate* isolate = close->env()->isolate();
    if (req->result < 0) {
      HandleScope handle_scope(isolate);
      close->Reject(
          UVException(isolate, static_cast<int>(req->result), ""close""));
    } else {
      close->Resolve();
    }
  }",55,,483,2,,void
163137,BLOCK,1,,<empty>,,,,20,,void
163139,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
        req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",5,,485,1,,void
163157,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
        req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",5,,485,2,,void
163185,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
        req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",5,,485,2,,void
163259,BLOCK,-1,,<empty>,44,,490,2,,void
163277,BLOCK,-1,,"{
      HandleScope handle_scope(isolate);
      close->Reject(
          UVException(isolate, static_cast<int>(req->result), ""close""));
    }",26,,492,2,,void
163294,BLOCK,-1,,"{
      close->Resolve();
    }",12,,496,1,,void
163304,BLOCK,-1,,"{
    FileHandle* handle;
    {
      FileHandleReadWrap* req_wrap = FileHandleReadWrap::from_req(req);
      FS_ASYNC_TRACE_END1(
          req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
      handle = req_wrap->file_handle_;
      CHECK_EQ(handle->current_read_.get(), req_wrap);
    }

    // ReadStart() checks whether current_read_ is set to determine whether
    // a read is in progress. Moving it into a local variable makes sure that
    // the ReadStart() call below doesn't think we're still actively reading.
    BaseObjectPtr<FileHandleReadWrap> read_wrap =
        std::move(handle->current_read_);

    ssize_t result = req->result;
    uv_buf_t buffer = read_wrap->buffer_;

    uv_fs_req_cleanup(req);

    // Push the read wrap back to the freelist, or let it be destroyed
    // once were exiting the current scope.
    constexpr size_t kWantedFreelistFill = 100;
    auto& freelist = handle->binding_data_->file_handle_read_wrap_freelist;
    if (freelist.si...",61,,608,2,,void
163306,BLOCK,2,,"{
      FileHandleReadWrap* req_wrap = FileHandleReadWrap::from_req(req);
      FS_ASYNC_TRACE_END1(
          req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
      handle = req_wrap->file_handle_;
      CHECK_EQ(handle->current_read_.get(), req_wrap);
    }",5,,610,2,,void
163330,BLOCK,1,,<empty>,,,,18,,void
163332,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
          req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",7,,612,1,,void
163350,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
          req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",7,,612,2,,void
163378,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
          req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",7,,612,2,,void
163488,BLOCK,-1,,"{
      read_wrap->Reset();
      freelist.emplace_back(std::move(read_wrap));
    }",48,,633,2,,void
163506,BLOCK,-1,,"{
      // Read at most as many bytes as we originally planned to.
      if (handle->read_length_ >= 0 && handle->read_length_ < result)
        result = handle->read_length_;

      // If we read data and we have an expected length, decrease it by
      // how much we have read.
      if (handle->read_length_ >= 0)
        handle->read_length_ -= result;

      // If we have an offset, increase it by how much we have read.
      if (handle->read_offset_ >= 0)
        handle->read_offset_ += result;
    }",22,,638,2,,void
163519,BLOCK,-1,,<empty>,9,,641,2,,void
163531,BLOCK,-1,,<empty>,9,,646,2,,void
163543,BLOCK,-1,,<empty>,9,,650,2,,void
163553,BLOCK,-1,,<empty>,7,,656,2,,void
163567,BLOCK,-1,,<empty>,7,,662,2,,void
163577,BLOCK,-1,,"{
    FileHandleCloseWrap* wrap = static_cast<FileHandleCloseWrap*>(
        FileHandleCloseWrap::from_req(req));
    FS_ASYNC_TRACE_END1(
        req->fs_type, wrap, ""result"", static_cast<int>(req->result))
    FileHandle* handle = static_cast<FileHandle*>(wrap->stream());
    handle->AfterClose();

    int result = static_cast<int>(req->result);
    uv_fs_req_cleanup(req);
    wrap->Done(result);
  }",70,,688,2,,void
163603,BLOCK,1,,<empty>,,,,18,,void
163605,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
        req->fs_type, wrap, ""result"", static_cast<int>(req->result))",5,,691,1,,void
163623,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
        req->fs_type, wrap, ""result"", static_cast<int>(req->result))",5,,691,2,,void
163651,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
        req->fs_type, wrap, ""result"", static_cast<int>(req->result))",5,,691,2,,void
163734,BLOCK,-1,,"{
    uv_fs_t close_req;
    CHECK_EQ(0, uv_fs_close(loop, &close_req, fd, nullptr));
    uv_fs_req_cleanup(&close_req);
  }",48,,1050,1,,void
163754,BLOCK,-1,,"{
            FSReqBase* req_wrap = FSReqBase::from_req(req);
            int err = static_cast<int>(req->result);
            if (reinterpret_cast<intptr_t>(req->data) == UV_EEXIST &&
                  req_wrap->continuation_data()->paths().size() > 0) {
              if (err == 0 && S_ISDIR(req->statbuf.st_mode)) {
                Environment* env = req_wrap->env();
                uv_loop_t* loop = env->event_loop();
                std::string path = req->path;
                uv_fs_req_cleanup(req);
                MKDirpAsync(loop, req, path.c_str(),
                            req_wrap->continuation_data()->mode(), nullptr);
                return;
              }
              err = UV_ENOTDIR;
            }
            // verify that the path pointed to is actually a directory.
            if (err == 0 && !S_ISDIR(req->statbuf.st_mode)) err = UV_EEXIST;
            req_wrap->continuation_data()->Done(err);
          }",66,,1724,2,,void
163792,BLOCK,-1,,"{
              if (err == 0 && S_ISDIR(req->statbuf.st_mode)) {
                Environment* env = req_wrap->env();
                uv_loop_t* loop = env->event_loop();
                std::string path = req->path;
                uv_fs_req_cleanup(req);
                MKDirpAsync(loop, req, path.c_str(),
                            req_wrap->continuation_data()->mode(), nullptr);
                return;
              }
              err = UV_ENOTDIR;
            }",70,,1728,2,,void
163804,BLOCK,1,,<empty>,,,,2,,void
163814,BLOCK,-1,,"{
                Environment* env = req_wrap->env();
                uv_loop_t* loop = env->event_loop();
                std::string path = req->path;
                uv_fs_req_cleanup(req);
                MKDirpAsync(loop, req, path.c_str(),
                            req_wrap->continuation_data()->mode(), nullptr);
                return;
              }",62,,1729,2,,void
163868,BLOCK,1,,<empty>,,,,2,,void
163878,BLOCK,-1,,<empty>,61,,1741,2,,void
163896,BLOCK,-1,,"{
    FSReqBase* req_wrap = FSReqBase::from_req(req);
    Environment* env = req_wrap->env();
    uv_loop_t* loop = env->event_loop();
    std::string path = req->path;
    int err = static_cast<int>(req->result);

    while (true) {
      switch (err) {
        // Note: uv_fs_req_cleanup in terminal paths will be called by
        // FSReqAfterScope::~FSReqAfterScope()
        case 0: {
          if (req_wrap->continuation_data()->paths().size() == 0) {
            req_wrap->continuation_data()->MaybeSetFirstPath(path);
            req_wrap->continuation_data()->Done(0);
          } else {
            req_wrap->continuation_data()->MaybeSetFirstPath(path);
            uv_fs_req_cleanup(req);
            MKDirpAsync(loop, req, path.c_str(),
                        req_wrap->continuation_data()->mode(), nullptr);
          }
          break;
        }
        case UV_EACCES:
        case UV_ENOTDIR:
        case UV_EPERM: {
          req_wrap->continuation_data()->Done(err);
        ...",59,,1675,2,,void
163935,BLOCK,-1,,"{
      switch (err) {
        // Note: uv_fs_req_cleanup in terminal paths will be called by
        // FSReqAfterScope::~FSReqAfterScope()
        case 0: {
          if (req_wrap->continuation_data()->paths().size() == 0) {
            req_wrap->continuation_data()->MaybeSetFirstPath(path);
            req_wrap->continuation_data()->Done(0);
          } else {
            req_wrap->continuation_data()->MaybeSetFirstPath(path);
            uv_fs_req_cleanup(req);
            MKDirpAsync(loop, req, path.c_str(),
                        req_wrap->continuation_data()->mode(), nullptr);
          }
          break;
        }
        case UV_EACCES:
        case UV_ENOTDIR:
        case UV_EPERM: {
          req_wrap->continuation_data()->Done(err);
          break;
        }
        case UV_ENOENT: {
          std::string dirname = path.substr(0,
                                            path.find_last_of(kPathSeparator));
          if (dirname != path) {
            req_wrap->conti...",18,,1682,2,,void
163938,BLOCK,-1,,"{
        // Note: uv_fs_req_cleanup in terminal paths will be called by
        // FSReqAfterScope::~FSReqAfterScope()
        case 0: {
          if (req_wrap->continuation_data()->paths().size() == 0) {
            req_wrap->continuation_data()->MaybeSetFirstPath(path);
            req_wrap->continuation_data()->Done(0);
          } else {
            req_wrap->continuation_data()->MaybeSetFirstPath(path);
            uv_fs_req_cleanup(req);
            MKDirpAsync(loop, req, path.c_str(),
                        req_wrap->continuation_data()->mode(), nullptr);
          }
          break;
        }
        case UV_EACCES:
        case UV_ENOTDIR:
        case UV_EPERM: {
          req_wrap->continuation_data()->Done(err);
          break;
        }
        case UV_ENOENT: {
          std::string dirname = path.substr(0,
                                            path.find_last_of(kPathSeparator));
          if (dirname != path) {
            req_wrap->continuation_data()->PushP...",20,,1683,2,,void
163941,BLOCK,3,,"{
          if (req_wrap->continuation_data()->paths().size() == 0) {
            req_wrap->continuation_data()->MaybeSetFirstPath(path);
            req_wrap->continuation_data()->Done(0);
          } else {
            req_wrap->continuation_data()->MaybeSetFirstPath(path);
            uv_fs_req_cleanup(req);
            MKDirpAsync(loop, req, path.c_str(),
                        req_wrap->continuation_data()->mode(), nullptr);
          }
          break;
        }",17,,1686,3,,void
163955,BLOCK,-1,,"{
            req_wrap->continuation_data()->MaybeSetFirstPath(path);
            req_wrap->continuation_data()->Done(0);
          }",67,,1687,2,,void
163973,BLOCK,-1,,"{
            req_wrap->continuation_data()->MaybeSetFirstPath(path);
            uv_fs_req_cleanup(req);
            MKDirpAsync(loop, req, path.c_str(),
                        req_wrap->continuation_data()->mode(), nullptr);
          }",18,,1690,1,,void
164006,BLOCK,10,,"{
          req_wrap->continuation_data()->Done(err);
          break;
        }",24,,1700,10,,void
164018,BLOCK,13,,"{
          std::string dirname = path.substr(0,
                                            path.find_last_of(kPathSeparator));
          if (dirname != path) {
            req_wrap->continuation_data()->PushPath(path);
            req_wrap->continuation_data()->PushPath(std::move(dirname));
          } else if (req_wrap->continuation_data()->paths().size() == 0) {
            err = UV_EEXIST;
            continue;
          }
          uv_fs_req_cleanup(req);
          MKDirpAsync(loop, req, path.c_str(),
                      req_wrap->continuation_data()->mode(), nullptr);
          break;
        }",25,,1704,13,,void
164036,BLOCK,-1,,"{
            req_wrap->continuation_data()->PushPath(path);
            req_wrap->continuation_data()->PushPath(std::move(dirname));
          }",32,,1707,2,,void
164058,BLOCK,-1,,<empty>,18,,1710,1,,void
164072,BLOCK,-1,,"{
            err = UV_EEXIST;
            continue;
          }",74,,1710,2,,void
164124,BLOCK,-1,,<empty>,24,,1744,2,,void
164140,BLOCK,-1,,{ uv_fs_req_cleanup(&req); },50,,2012,1,,void
164149,BLOCK,-1,,"{
    uv_fs_t close_req;
    CHECK_EQ(0, uv_fs_close(nullptr, &close_req, file, nullptr));
    uv_fs_req_cleanup(&close_req);
  }",44,,2027,1,,void
164218,BLOCK,-1,,<empty>,1,,1,1,,ANY
164227,BLOCK,-1,,"{
  // Remove everything leading up to and including the final path separator.
  std::string::size_type pos = str.find_last_of(kPathSeparator);

  // Starting index for the resulting string
  std::size_t start_pos = 0;
  // String size to return
  std::size_t str_size = str.size();
  if (pos != std::string::npos) {
    start_pos = pos + 1;
    str_size -= start_pos;
  }

  // Strip away the extension, if any.
  if (str_size >= extension.size() &&
      str.compare(str.size() - extension.size(),
        extension.size(), extension) == 0) {
    str_size -= extension.size();
  }

  return str.substr(start_pos, str_size);
}",76,,93,3,,void
164255,BLOCK,-1,,"{
    start_pos = pos + 1;
    str_size -= start_pos;
  }",33,,101,2,,void
164292,BLOCK,-1,,"{
    str_size -= extension.size();
  }",44,,109,2,,void
164310,BLOCK,-1,,"{
  return IsSafeJsInt(value) ? value.As<Integer>()->Value() : -1;
}",46,,116,2,,void
164328,BLOCK,-1,,"{
  switch (req_type) {
#define FS_TYPE_TO_NAME(type, name)                                            \
  case UV_FS_##type:                                                           \
    return name;
    FS_TYPE_TO_NAME(OPEN, ""open"")
    FS_TYPE_TO_NAME(CLOSE, ""close"")
    FS_TYPE_TO_NAME(READ, ""read"")
    FS_TYPE_TO_NAME(WRITE, ""write"")
    FS_TYPE_TO_NAME(SENDFILE, ""sendfile"")
    FS_TYPE_TO_NAME(STAT, ""stat"")
    FS_TYPE_TO_NAME(LSTAT, ""lstat"")
    FS_TYPE_TO_NAME(FSTAT, ""fstat"")
    FS_TYPE_TO_NAME(FTRUNCATE, ""ftruncate"")
    FS_TYPE_TO_NAME(UTIME, ""utime"")
    FS_TYPE_TO_NAME(FUTIME, ""futime"")
    FS_TYPE_TO_NAME(ACCESS, ""access"")
    FS_TYPE_TO_NAME(CHMOD, ""chmod"")
    FS_TYPE_TO_NAME(FCHMOD, ""fchmod"")
    FS_TYPE_TO_NAME(FSYNC, ""fsync"")
    FS_TYPE_TO_NAME(FDATASYNC, ""fdatasync"")
    FS_TYPE_TO_NAME(UNLINK, ""unlink"")
    FS_TYPE_TO_NAME(RMDIR, ""rmdir"")
    FS_TYPE_TO_NAME(MKDIR, ""mkdir"")
    FS_TYPE_TO_NAME(MKDTEMP, ""mkdtemp"")
    FS_TYPE_TO_NAME(RENAME, ""rename"")
    FS_T...",66,,120,2,,void
164331,BLOCK,-1,,"{
#define FS_TYPE_TO_NAME(type, name)                                            \
  case UV_FS_##type:                                                           \
    return name;
    FS_TYPE_TO_NAME(OPEN, ""open"")
    FS_TYPE_TO_NAME(CLOSE, ""close"")
    FS_TYPE_TO_NAME(READ, ""read"")
    FS_TYPE_TO_NAME(WRITE, ""write"")
    FS_TYPE_TO_NAME(SENDFILE, ""sendfile"")
    FS_TYPE_TO_NAME(STAT, ""stat"")
    FS_TYPE_TO_NAME(LSTAT, ""lstat"")
    FS_TYPE_TO_NAME(FSTAT, ""fstat"")
    FS_TYPE_TO_NAME(FTRUNCATE, ""ftruncate"")
    FS_TYPE_TO_NAME(UTIME, ""utime"")
    FS_TYPE_TO_NAME(FUTIME, ""futime"")
    FS_TYPE_TO_NAME(ACCESS, ""access"")
    FS_TYPE_TO_NAME(CHMOD, ""chmod"")
    FS_TYPE_TO_NAME(FCHMOD, ""fchmod"")
    FS_TYPE_TO_NAME(FSYNC, ""fsync"")
    FS_TYPE_TO_NAME(FDATASYNC, ""fdatasync"")
    FS_TYPE_TO_NAME(UNLINK, ""unlink"")
    FS_TYPE_TO_NAME(RMDIR, ""rmdir"")
    FS_TYPE_TO_NAME(MKDIR, ""mkdir"")
    FS_TYPE_TO_NAME(MKDTEMP, ""mkdtemp"")
    FS_TYPE_TO_NAME(RENAME, ""rename"")
    FS_TYPE_TO_NAME(SCANDIR, ""...",21,,121,2,,void
164333,BLOCK,1,,<empty>,,,,1,,void
164339,BLOCK,1,,<empty>,,,,1,,void
164345,BLOCK,1,,<empty>,,,,1,,void
164351,BLOCK,1,,<empty>,,,,1,,void
164357,BLOCK,1,,<empty>,,,,1,,void
164363,BLOCK,1,,<empty>,,,,1,,void
164369,BLOCK,1,,<empty>,,,,1,,void
164375,BLOCK,1,,<empty>,,,,1,,void
164381,BLOCK,1,,<empty>,,,,1,,void
164387,BLOCK,1,,<empty>,,,,1,,void
164393,BLOCK,1,,<empty>,,,,1,,void
164399,BLOCK,1,,<empty>,,,,1,,void
164405,BLOCK,1,,<empty>,,,,1,,void
164411,BLOCK,1,,<empty>,,,,1,,void
164417,BLOCK,1,,<empty>,,,,1,,void
164423,BLOCK,1,,<empty>,,,,1,,void
164429,BLOCK,1,,<empty>,,,,1,,void
164435,BLOCK,1,,<empty>,,,,1,,void
164441,BLOCK,1,,<empty>,,,,1,,void
164447,BLOCK,1,,<empty>,,,,1,,void
164453,BLOCK,1,,<empty>,,,,1,,void
164459,BLOCK,1,,<empty>,,,,1,,void
164465,BLOCK,1,,<empty>,,,,1,,void
164471,BLOCK,1,,<empty>,,,,1,,void
164477,BLOCK,1,,<empty>,,,,1,,void
164483,BLOCK,1,,<empty>,,,,1,,void
164489,BLOCK,1,,<empty>,,,,1,,void
164495,BLOCK,1,,<empty>,,,,1,,void
164501,BLOCK,1,,<empty>,,,,1,,void
164507,BLOCK,1,,<empty>,,,,1,,void
164513,BLOCK,1,,<empty>,,,,1,,void
164519,BLOCK,1,,<empty>,,,,1,,void
164525,BLOCK,1,,<empty>,,,,1,,void
164537,BLOCK,-1,,<empty>,,,,2,,<empty>
164542,BLOCK,-1,,"{
  tracker->TrackField(""paths"", paths_);
}",67,,225,2,,void
164552,BLOCK,-1,,<empty>,,,,1,,<empty>
164556,BLOCK,-1,,<empty>,,,,1,,<empty>
164561,BLOCK,-1,,"{
  tracker->TrackField(""continuation_data"", continuation_data_);
}",58,,233,2,,void
164574,BLOCK,-1,,"{
  MakeWeak();
  StreamBase::AttachToObject(GetObject());
}",35,,245,4,,void
164585,BLOCK,-1,,"{
  Environment* env = binding_data->env();
  if (obj.IsEmpty() && !env->fd_constructor_template()
                            ->NewInstance(env->context())
                            .ToLocal(&obj)) {
    return nullptr;
  }
  auto handle = new FileHandle(binding_data, obj, fd);
  if (maybeOffset.has_value()) handle->read_offset_ = maybeOffset.value();
  if (maybeLength.has_value()) handle->read_length_ = maybeLength.value();
  return handle;
}",65,,254,6,,void
164616,BLOCK,-1,,"{
    return nullptr;
  }",45,,258,2,,void
164632,BLOCK,-1,,<empty>,32,,262,2,,void
164646,BLOCK,-1,,<empty>,32,,263,2,,void
164661,BLOCK,-1,,"{
  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
  Environment* env = binding_data->env();
  CHECK(args.IsConstructCall());
  CHECK(args[0]->IsInt32());

  std::optional<int64_t> maybeOffset = std::nullopt;
  std::optional<int64_t> maybeLength = std::nullopt;
  if (args[1]->IsNumber())
    maybeOffset = args[1]->IntegerValue(env->context()).FromJust();
  if (args[2]->IsNumber())
    maybeLength = args[2]->IntegerValue(env->context()).FromJust();

  FileHandle::New(binding_data,
                  args[0].As<Int32>()->Value(),
                  args.This(),
                  maybeOffset,
                  maybeLength);
}",63,,267,2,,void
164720,BLOCK,-1,,<empty>,5,,276,2,,void
164743,BLOCK,-1,,<empty>,5,,278,2,,void
164782,BLOCK,-1,,"{
  CHECK(!closing_);  // We should not be deleting while explicitly closing!
  Close();           // Close synchronously and emit warning
  CHECK(closed_);    // We have to be closed at the point
}",27,,287,1,,void
164795,BLOCK,-1,,"{
  return UV_ENOSYS;  // Not implemented (yet).
}",51,,296,5,,void
164802,BLOCK,-1,,"{
  tracker->TrackField(""current_read"", current_read_);
}",59,,300,2,,void
164812,BLOCK,-1,,"{
  return reading_ || closing_ || closed_ ?
      TransferMode::kUntransferable : TransferMode::kTransferable;
}",62,,304,1,,void
164829,BLOCK,-1,,"{
  CHECK_NE(GetTransferMode(), TransferMode::kUntransferable);
  auto ret = std::make_unique<TransferData>(fd_);
  closed_ = true;
  return ret;
}",74,,309,1,,void
164854,BLOCK,-1,,<empty>,58,,316,2,,void
164858,BLOCK,-1,,"{
  if (fd_ > 0) {
    uv_fs_t close_req;
    CHECK_NE(fd_, -1);
    FS_SYNC_TRACE_BEGIN(close);
    CHECK_EQ(0, uv_fs_close(nullptr, &close_req, fd_, nullptr));
    FS_SYNC_TRACE_END(close);
    uv_fs_req_cleanup(&close_req);
  }
}",43,,318,1,,void
164863,BLOCK,-1,,"{
    uv_fs_t close_req;
    CHECK_NE(fd_, -1);
    FS_SYNC_TRACE_BEGIN(close);
    CHECK_EQ(0, uv_fs_close(nullptr, &close_req, fd_, nullptr));
    FS_SYNC_TRACE_END(close);
    uv_fs_req_cleanup(&close_req);
  }",16,,319,2,,void
164872,BLOCK,1,,<empty>,,,,9,,void
164888,BLOCK,-1,,<empty>,5,,322,2,,void
164890,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(close),5,,322,1,,void
164908,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(close),5,,322,2,,void
164936,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(close),5,,322,2,,void
164976,BLOCK,1,,<empty>,,,,9,,void
164992,BLOCK,-1,,<empty>,5,,324,2,,void
164994,BLOCK,-1,,FS_SYNC_TRACE_END(close),5,,324,1,,void
165012,BLOCK,-1,,FS_SYNC_TRACE_END(close),5,,324,2,,void
165040,BLOCK,-1,,FS_SYNC_TRACE_END(close),5,,324,2,,void
165078,BLOCK,-1,,"{
  BindingData* bd = Realm::GetBindingData<BindingData>(context);
  if (bd == nullptr) return {};

  int fd = fd_;
  fd_ = -1;
  return BaseObjectPtr<BaseObject> { FileHandle::New(bd, fd) };
}",49,,332,4,,void
165093,BLOCK,-1,,<empty>,22,,334,2,,void
165115,BLOCK,-1,,"{
  if (closed_ || closing_) return;
  uv_fs_t req;
  CHECK_NE(fd_, -1);
  FS_SYNC_TRACE_BEGIN(close);
  int ret = uv_fs_close(env()->event_loop(), &req, fd_, nullptr);
  FS_SYNC_TRACE_END(close);
  uv_fs_req_cleanup(&req);

  struct err_detail { int ret; int fd; };

  err_detail detail { ret, fd_ };

  AfterClose();

  if (ret < 0) {
    // Do not unref this
    env()->SetImmediate([detail](Environment* env) {
      char msg[70];
      snprintf(msg, arraysize(msg),
              ""Closing file descriptor %d on garbage collection failed"",
              detail.fd);
      // This exception will end up being fatal for the process because
      // it is being thrown from within the SetImmediate handler and
      // there is no JS stack to bubble it to. In other words, tearing
      // down the process is the only reasonable thing we can do here.
      HandleScope handle_scope(env->isolate());
      env->ThrowUVException(detail.ret, ""close"", msg);
    });
    return;
  }

  // If the clos...",33,,345,1,,void
165120,BLOCK,-1,,<empty>,28,,346,2,,void
165130,BLOCK,1,,<empty>,,,,9,,void
165146,BLOCK,-1,,<empty>,3,,349,2,,void
165148,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(close),3,,349,1,,void
165166,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(close),3,,349,2,,void
165194,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(close),3,,349,2,,void
165238,BLOCK,1,,<empty>,,,,9,,void
165254,BLOCK,-1,,<empty>,3,,351,2,,void
165256,BLOCK,-1,,FS_SYNC_TRACE_END(close),3,,351,1,,void
165274,BLOCK,-1,,FS_SYNC_TRACE_END(close),3,,351,2,,void
165302,BLOCK,-1,,FS_SYNC_TRACE_END(close),3,,351,2,,void
165344,BLOCK,-1,,"{
    // Do not unref this
    env()->SetImmediate([detail](Environment* env) {
      char msg[70];
      snprintf(msg, arraysize(msg),
              ""Closing file descriptor %d on garbage collection failed"",
              detail.fd);
      // This exception will end up being fatal for the process because
      // it is being thrown from within the SetImmediate handler and
      // there is no JS stack to bubble it to. In other words, tearing
      // down the process is the only reasonable thing we can do here.
      HandleScope handle_scope(env->isolate());
      env->ThrowUVException(detail.ret, ""close"", msg);
    });
    return;
  }",16,,360,2,,void
165362,BLOCK,-1,,"{
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Context::Scope context_scope(env()->context());
  InternalCallbackScope callback_scope(this);
  Local<Promise> promise = promise_.Get(isolate);
  Local<Promise::Resolver> resolver = promise.As<Promise::Resolver>();
  resolver->Resolve(env()->context(), Undefined(isolate)).Check();
}",38,,398,1,,void
165422,BLOCK,-1,,"{
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Context::Scope context_scope(env()->context());
  InternalCallbackScope callback_scope(this);
  Local<Promise> promise = promise_.Get(isolate);
  Local<Promise::Resolver> resolver = promise.As<Promise::Resolver>();
  resolver->Reject(env()->context(), reason).Check();
}",56,,408,2,,void
165480,BLOCK,-1,,"{
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Value> val = ref_.Get(isolate);
  Local<Object> obj = val.As<Object>();
  return Unwrap<FileHandle>(obj);
}",49,,418,1,,void
165525,BLOCK,-1,,"{
  promise_.Reset(env->isolate(), promise);
  ref_.Reset(env->isolate(), ref);
}",63,,430,5,,void
165547,BLOCK,-1,,"{
  uv_fs_req_cleanup(req());
  promise_.Reset();
  ref_.Reset();
}",35,,435,1,,void
165561,BLOCK,-1,,"{
  tracker->TrackField(""promise"", promise_);
  tracker->TrackField(""ref"", ref_);
}",69,,441,2,,void
165577,BLOCK,-1,,"{
  Isolate* isolate = env()->isolate();
  EscapableHandleScope scope(isolate);
  Local<Context> context = env()->context();

  Local<Value> close_resolver =
      object()->GetInternalField(FileHandle::kClosingPromiseSlot);
  if (!close_resolver.IsEmpty() && !close_resolver->IsUndefined()) {
    CHECK(close_resolver->IsPromise());
    return close_resolver.As<Promise>();
  }

  CHECK(!closed_);
  CHECK(!closing_);
  CHECK(!reading_);

  auto maybe_resolver = Promise::Resolver::New(context);
  CHECK(!maybe_resolver.IsEmpty());
  Local<Promise::Resolver> resolver = maybe_resolver.ToLocalChecked();
  Local<Promise> promise = resolver.As<Promise>();

  Local<Object> close_req_obj;
  if (!env()->fdclose_constructor_template()
          ->NewInstance(env()->context()).ToLocal(&close_req_obj)) {
    return MaybeLocal<Promise>();
  }
  closing_ = true;
  object()->SetInternalField(FileHandle::kClosingPromiseSlot, promise);

  CloseReq* req = new CloseReq(env(), close_req_obj, promise, obje...",48,,453,1,,void
165623,BLOCK,-1,,"{
    CHECK(close_resolver->IsPromise());
    return close_resolver.As<Promise>();
  }",68,,460,2,,void
165704,BLOCK,-1,,"{
    return MaybeLocal<Promise>();
  }",68,,476,2,,void
165743,BLOCK,1,,<empty>,,,,16,,void
165745,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_CLOSE, req)",3,,501,1,,void
165763,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_CLOSE, req)",3,,501,2,,void
165791,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_CLOSE, req)",3,,501,2,,void
165848,BLOCK,-1,,"{
    req->Reject(UVException(isolate, ret, ""close""));
    delete req;
  }",16,,503,2,,void
165869,BLOCK,-1,,"{
  FileHandle* fd;
  ASSIGN_OR_RETURN_UNWRAP(&fd, args.Holder());
  Local<Promise> ret;
  if (!fd->ClosePromise().ToLocal(&ret)) return;
  args.GetReturnValue().Set(ret);
}",65,,511,2,,void
165894,BLOCK,-1,,<empty>,42,,515,2,,void
165908,BLOCK,-1,,"{
  FileHandle* fd;
  ASSIGN_OR_RETURN_UNWRAP(&fd, args.Holder());
  fd->Release();
}",69,,520,2,,void
165924,BLOCK,-1,,"{
  int fd = GetFD();
  // Just pretend that Close was called and we're all done.
  AfterClose();
  return fd;
}",27,,526,1,,void
165935,BLOCK,-1,,"{
  closing_ = false;
  closed_ = true;
  fd_ = -1;
  if (reading_ && !persistent().IsEmpty())
    EmitRead(UV_EOF);
}",31,,533,1,,void
165954,BLOCK,-1,,<empty>,5,,538,2,,void
165960,BLOCK,-1,,"{
  tracker->TrackField(""buffer"", buffer_);
  tracker->TrackField(""file_handle"", this->file_handle_);
}",67,,541,2,,void
165980,BLOCK,-1,,<empty>,26,,548,3,,void
165984,BLOCK,-1,,"{
  if (!IsAlive() || IsClosing())
    return UV_EOF;

  reading_ = true;

  if (current_read_)
    return 0;

  BaseObjectPtr<FileHandleReadWrap> read_wrap;

  if (read_length_ == 0) {
    EmitRead(UV_EOF);
    return 0;
  }

  {
    // Create a new FileHandleReadWrap or re-use one.
    // Either way, we need these two scopes for AsyncReset() or otherwise
    // for creating the new instance.
    HandleScope handle_scope(env()->isolate());
    AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(this);

    auto& freelist = binding_data_->file_handle_read_wrap_freelist;
    if (freelist.size() > 0) {
      read_wrap = std::move(freelist.back());
      freelist.pop_back();
      // Use a fresh async resource.
      // Lifetime is ensured via AsyncWrap::resource_.
      Local<Object> resource = Object::New(env()->isolate());
      USE(resource->Set(
          env()->context(), env()->handle_string(), read_wrap->object()));
      read_wrap->AsyncReset(resource);
      read_wrap->file_...",29,,550,1,,void
165990,BLOCK,-1,,<empty>,5,,552,2,,void
165998,BLOCK,-1,,<empty>,5,,557,2,,void
166010,BLOCK,-1,,"{
    EmitRead(UV_EOF);
    return 0;
  }",26,,561,2,,void
166014,BLOCK,6,,"{
    // Create a new FileHandleReadWrap or re-use one.
    // Either way, we need these two scopes for AsyncReset() or otherwise
    // for creating the new instance.
    HandleScope handle_scope(env()->isolate());
    AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(this);

    auto& freelist = binding_data_->file_handle_read_wrap_freelist;
    if (freelist.size() > 0) {
      read_wrap = std::move(freelist.back());
      freelist.pop_back();
      // Use a fresh async resource.
      // Lifetime is ensured via AsyncWrap::resource_.
      Local<Object> resource = Object::New(env()->isolate());
      USE(resource->Set(
          env()->context(), env()->handle_string(), read_wrap->object()));
      read_wrap->AsyncReset(resource);
      read_wrap->file_handle_ = this;
    } else {
      Local<Object> wrap_obj;
      if (!env()
               ->filehandlereadwrap_template()
               ->NewInstance(env()->context())
               .ToLocal(&wrap_obj)) {
        return UV_EBU...",3,,566,6,,void
166037,BLOCK,-1,,"{
      read_wrap = std::move(freelist.back());
      freelist.pop_back();
      // Use a fresh async resource.
      // Lifetime is ensured via AsyncWrap::resource_.
      Local<Object> resource = Object::New(env()->isolate());
      USE(resource->Set(
          env()->context(), env()->handle_string(), read_wrap->object()));
      read_wrap->AsyncReset(resource);
      read_wrap->file_handle_ = this;
    }",30,,574,2,,void
166094,BLOCK,-1,,"{
      Local<Object> wrap_obj;
      if (!env()
               ->filehandlereadwrap_template()
               ->NewInstance(env()->context())
               .ToLocal(&wrap_obj)) {
        return UV_EBUSY;
      }
      read_wrap = MakeDetachedBaseObject<FileHandleReadWrap>(this, wrap_obj);
    }",12,,584,1,,void
166118,BLOCK,-1,,"{
        return UV_EBUSY;
      }",37,,589,2,,void
166143,BLOCK,-1,,<empty>,5,,597,2,,void
166170,BLOCK,1,,<empty>,,,,15,,void
166172,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_READ, current_read_.get())",3,,602,1,,void
166190,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_READ, current_read_.get())",3,,602,2,,void
166218,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_READ, current_read_.get())",3,,602,2,,void
166284,BLOCK,-1,,"{
  reading_ = false;
  return 0;
}",28,,668,1,,void
166295,BLOCK,-1,,"{
  return new FileHandleCloseWrap(this, object);
}",68,,675,2,,void
166305,BLOCK,-1,,"{
  if (closing_ || closed_) {
    req_wrap->Done(0);
    return 1;
  }
  FileHandleCloseWrap* wrap = static_cast<FileHandleCloseWrap*>(req_wrap);
  closing_ = true;
  CHECK_NE(fd_, -1);
  FS_ASYNC_TRACE_BEGIN0(UV_FS_CLOSE, wrap)
  wrap->Dispatch(uv_fs_close, fd_, uv_fs_callback_t{[](uv_fs_t* req) {
    FileHandleCloseWrap* wrap = static_cast<FileHandleCloseWrap*>(
        FileHandleCloseWrap::from_req(req));
    FS_ASYNC_TRACE_END1(
        req->fs_type, wrap, ""result"", static_cast<int>(req->result))
    FileHandle* handle = static_cast<FileHandle*>(wrap->stream());
    handle->AfterClose();

    int result = static_cast<int>(req->result);
    uv_fs_req_cleanup(req);
    wrap->Done(result);
  }});

  return 0;
}",52,,679,2,,void
166310,BLOCK,-1,,"{
    req_wrap->Done(0);
    return 1;
  }",28,,680,2,,void
166338,BLOCK,1,,<empty>,,,,16,,void
166340,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_CLOSE, wrap)",3,,687,1,,void
166358,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_CLOSE, wrap)",3,,687,2,,void
166386,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_CLOSE, wrap)",3,,687,2,,void
166444,BLOCK,-1,,"{
  MakeCallback(env()->oncomplete_string(), 1, &reject);
}",49,,705,2,,void
166457,BLOCK,-1,,"{
  Resolve(FillGlobalStatsArray(binding_data(), use_bigint(), stat));
}",56,,709,2,,void
166467,BLOCK,-1,,"{
  Resolve(FillGlobalStatFsArray(binding_data(), use_bigint(), stat));
}",60,,713,2,,void
166477,BLOCK,-1,,"{
  Local<Value> argv[2] {
    Null(env()->isolate()),
    value
  };
  MakeCallback(env()->oncomplete_string(),
               value->IsUndefined() ? 1 : arraysize(argv),
               argv);
}",49,,717,2,,void
166506,BLOCK,-1,,"{
  args.GetReturnValue().SetUndefined();
}",77,,727,2,,void
166518,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
  new FSReqCallback(binding_data, args.This(), args[0]->IsTrue());
}",64,,731,2,,void
166552,BLOCK,-1,,"{
  CHECK_EQ(wrap_->req(), req);
}",46,,741,3,,void
166562,BLOCK,-1,,"{
  Clear();
}",37,,745,1,,void
166567,BLOCK,-1,,"{
  if (!wrap_) return;

  uv_fs_req_cleanup(wrap_->req());
  wrap_->Detach();
  wrap_.reset();
}",31,,749,1,,void
166571,BLOCK,-1,,<empty>,15,,750,2,,void
166590,BLOCK,-1,,"{
  BaseObjectPtr<FSReqBase> wrap { wrap_ };
  Local<Value> exception = UVException(wrap_->env()->isolate(),
                                       static_cast<int>(req->result),
                                       wrap_->syscall(),
                                       nullptr,
                                       req->path,
                                       wrap_->data());
  Clear();
  wrap->Reject(exception);
}",44,,766,2,,void
166638,BLOCK,-1,,"{
  if (!wrap_->env()->can_call_into_js()) {
    return false;
  }

  if (req_->result < 0) {
    Reject(req_);
    return false;
  }
  return true;
}",33,,778,1,,void
166648,BLOCK,-1,,"{
    return false;
  }",42,,779,2,,void
166657,BLOCK,-1,,"{
    Reject(req_);
    return false;
  }",25,,783,2,,void
166667,BLOCK,-1,,"{
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  if (after.Proceed())
    req_wrap->Resolve(Undefined(req_wrap->env()->isolate()));
}",32,,790,2,,void
166695,BLOCK,1,,<empty>,,,,18,,void
166697,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,793,1,,void
166715,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,793,2,,void
166743,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,793,2,,void
166799,BLOCK,-1,,<empty>,5,,796,2,,void
166816,BLOCK,-1,,"{
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  if (after.Proceed()) {
    req_wrap->ResolveStat(&req->statbuf);
  }
}",30,,799,2,,void
166844,BLOCK,1,,<empty>,,,,18,,void
166846,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,802,1,,void
166864,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,802,2,,void
166892,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,802,2,,void
166948,BLOCK,-1,,"{
    req_wrap->ResolveStat(&req->statbuf);
  }",24,,804,2,,void
166961,BLOCK,-1,,"{
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  if (after.Proceed()) {
    req_wrap->ResolveStatFs(static_cast<uv_statfs_t*>(req->ptr));
  }
}",32,,809,2,,void
166989,BLOCK,1,,<empty>,,,,18,,void
166991,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,812,1,,void
167009,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,812,2,,void
167037,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,812,2,,void
167093,BLOCK,-1,,"{
    req_wrap->ResolveStatFs(static_cast<uv_statfs_t*>(req->ptr));
  }",24,,814,2,,void
167107,BLOCK,-1,,"{
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  int result = static_cast<int>(req->result);
  if (result >= 0 && req_wrap->is_plain_open())
    req_wrap->env()->AddUnmanagedFd(result);

  if (after.Proceed())
    req_wrap->Resolve(Integer::New(req_wrap->env()->isolate(), result));
}",33,,819,2,,void
167135,BLOCK,1,,<empty>,,,,18,,void
167137,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,822,1,,void
167155,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,822,2,,void
167183,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,822,2,,void
167251,BLOCK,-1,,<empty>,5,,826,2,,void
167265,BLOCK,-1,,<empty>,5,,829,2,,void
167286,BLOCK,-1,,"{
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  if (after.Proceed()) {
    FileHandle* fd = FileHandle::New(req_wrap->binding_data(),
                                     static_cast<int>(req->result));
    if (fd == nullptr) return;
    req_wrap->Resolve(fd->object());
  }
}",40,,832,2,,void
167314,BLOCK,1,,<empty>,,,,18,,void
167316,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,835,1,,void
167334,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,835,2,,void
167362,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,835,2,,void
167418,BLOCK,-1,,"{
    FileHandle* fd = FileHandle::New(req_wrap->binding_data(),
                                     static_cast<int>(req->result));
    if (fd == nullptr) return;
    req_wrap->Resolve(fd->object());
  }",24,,837,2,,void
167439,BLOCK,-1,,<empty>,24,,840,2,,void
167453,BLOCK,-1,,"{
#ifdef _WIN32
  if (path->compare(0, 8, ""\\\\?\\UNC\\"", 8) == 0) {
    *path = path->substr(8);
    path->insert(0, ""\\\\"");
  } else if (path->compare(0, 4, ""\\\\?\\"", 4) == 0) {
    *path = path->substr(4);
  }
#endif
}",44,,847,2,,void
167458,BLOCK,-1,,"{
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  if (after.Proceed()) {
    std::string first_path(req_wrap->continuation_data()->first_path());
    if (first_path.empty())
      return req_wrap->Resolve(Undefined(req_wrap->env()->isolate()));
    FromNamespacedPath(&first_path);
    Local<Value> path;
    Local<Value> error;
    if (!StringBytes::Encode(req_wrap->env()->isolate(), first_path.c_str(),
                             req_wrap->encoding(),
                             &error).ToLocal(&path)) {
      return req_wrap->Reject(error);
    }
    return req_wrap->Resolve(path);
  }
}",32,,858,2,,void
167486,BLOCK,1,,<empty>,,,,18,,void
167488,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,861,1,,void
167506,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,861,2,,void
167534,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,861,2,,void
167590,BLOCK,-1,,"{
    std::string first_path(req_wrap->continuation_data()->first_path());
    if (first_path.empty())
      return req_wrap->Resolve(Undefined(req_wrap->env()->isolate()));
    FromNamespacedPath(&first_path);
    Local<Value> path;
    Local<Value> error;
    if (!StringBytes::Encode(req_wrap->env()->isolate(), first_path.c_str(),
                             req_wrap->encoding(),
                             &error).ToLocal(&path)) {
      return req_wrap->Reject(error);
    }
    return req_wrap->Resolve(path);
  }",24,,863,2,,void
167605,BLOCK,-1,,<empty>,7,,866,2,,void
167660,BLOCK,-1,,"{
      return req_wrap->Reject(error);
    }",54,,872,2,,void
167677,BLOCK,-1,,"{
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  MaybeLocal<Value> link;
  Local<Value> error;

  if (after.Proceed()) {
    link = StringBytes::Encode(req_wrap->env()->isolate(),
                               req->path,
                               req_wrap->encoding(),
                               &error);
    if (link.IsEmpty())
      req_wrap->Reject(error);
    else
      req_wrap->Resolve(link.ToLocalChecked());
  }
}",36,,879,2,,void
167705,BLOCK,1,,<empty>,,,,18,,void
167707,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,882,1,,void
167725,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,882,2,,void
167753,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,882,2,,void
167819,BLOCK,-1,,"{
    link = StringBytes::Encode(req_wrap->env()->isolate(),
                               req->path,
                               req_wrap->encoding(),
                               &error);
    if (link.IsEmpty())
      req_wrap->Reject(error);
    else
      req_wrap->Resolve(link.ToLocalChecked());
  }",24,,887,2,,void
167847,BLOCK,-1,,<empty>,7,,893,2,,void
167854,BLOCK,-1,,<empty>,7,,895,1,,void
167867,BLOCK,-1,,"{
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  MaybeLocal<Value> link;
  Local<Value> error;

  if (after.Proceed()) {
    link = StringBytes::Encode(req_wrap->env()->isolate(),
                               static_cast<const char*>(req->ptr),
                               req_wrap->encoding(),
                               &error);
    if (link.IsEmpty())
      req_wrap->Reject(error);
    else
      req_wrap->Resolve(link.ToLocalChecked());
  }
}",35,,899,2,,void
167895,BLOCK,1,,<empty>,,,,18,,void
167897,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,902,1,,void
167915,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,902,2,,void
167943,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,902,2,,void
168009,BLOCK,-1,,"{
    link = StringBytes::Encode(req_wrap->env()->isolate(),
                               static_cast<const char*>(req->ptr),
                               req_wrap->encoding(),
                               &error);
    if (link.IsEmpty())
      req_wrap->Reject(error);
    else
      req_wrap->Resolve(link.ToLocalChecked());
  }",24,,907,2,,void
168039,BLOCK,-1,,<empty>,7,,913,2,,void
168046,BLOCK,-1,,<empty>,7,,915,1,,void
168059,BLOCK,-1,,"{
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  if (!after.Proceed()) {
    return;
  }

  Environment* env = req_wrap->env();
  Isolate* isolate = env->isolate();
  Local<Value> error;
  int r;

  std::vector<Local<Value>> name_v;
  std::vector<Local<Value>> type_v;

  const bool with_file_types = req_wrap->with_file_types();

  for (;;) {
    uv_dirent_t ent;

    r = uv_fs_scandir_next(req, &ent);
    if (r == UV_EOF)
      break;
    if (r != 0) {
      return req_wrap->Reject(
          UVException(isolate, r, nullptr, req_wrap->syscall(), req->path));
    }

    Local<Value> filename;
    if (!StringBytes::Encode(isolate, ent.name, req_wrap->encoding(), &error)
             .ToLocal(&filename)) {
      return req_wrap->Reject(error);
    }
    name_v.push_back(filename);

    if (with_file_types) type_v.emplace_back(Integer::New(isolate, e...",33,,919,2,,void
168087,BLOCK,1,,<empty>,,,,18,,void
168089,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,922,1,,void
168107,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,922,2,,void
168135,BLOCK,-1,,"FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))",3,,922,2,,void
168192,BLOCK,-1,,"{
    return;
  }",25,,924,2,,void
168240,BLOCK,-1,,<empty>,3,,938,1,,void
168241,BLOCK,4,,"{
    uv_dirent_t ent;

    r = uv_fs_scandir_next(req, &ent);
    if (r == UV_EOF)
      break;
    if (r != 0) {
      return req_wrap->Reject(
          UVException(isolate, r, nullptr, req_wrap->syscall(), req->path));
    }

    Local<Value> filename;
    if (!StringBytes::Encode(isolate, ent.name, req_wrap->encoding(), &error)
             .ToLocal(&filename)) {
      return req_wrap->Reject(error);
    }
    name_v.push_back(filename);

    if (with_file_types) type_v.emplace_back(Integer::New(isolate, ent.type));
  }",12,,938,4,,void
168253,BLOCK,-1,,<empty>,7,,943,2,,void
168259,BLOCK,-1,,"{
      return req_wrap->Reject(
          UVException(isolate, r, nullptr, req_wrap->syscall(), req->path));
    }",17,,944,2,,void
168302,BLOCK,-1,,"{
      return req_wrap->Reject(error);
    }",35,,951,2,,void
168316,BLOCK,-1,,<empty>,26,,956,2,,void
168331,BLOCK,-1,,"{
    Local<Value> result[] = {Array::New(isolate, name_v.data(), name_v.size()),
                             Array::New(isolate, type_v.data(), type_v.size())};
    req_wrap->Resolve(Array::New(isolate, result, arraysize(result)));
  }",24,,959,2,,void
168375,BLOCK,-1,,"{
    req_wrap->Resolve(Array::New(isolate, name_v.data(), name_v.size()));
  }",10,,963,1,,void
168397,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  Isolate* isolate = env->isolate();
  HandleScope scope(isolate);

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  CHECK(args[1]->IsInt32());
  int mode = args[1].As<Int32>()->Value();

  BufferValue path(isolate, args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, path.ToStringView());

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {  // access(path, mode, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_ACCESS, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""access"", UTF8, AfterNoArgs,
              uv_fs_access, *path, mode);
  } else {  // access(path, mode, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(access);
    SyncCall(env, args[3], &req_wrap_sync, ""access"", uv_fs_access, *path, mode);
    FS_SYNC_TRACE_END(a...",54,,968,2,,void
168475,BLOCK,-1,,"{  // access(path, mode, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_ACCESS, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""access"", UTF8, AfterNoArgs,
              uv_fs_access, *path, mode);
  }",34,,986,2,,void
168484,BLOCK,1,,<empty>,,,,18,,void
168486,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_ACCESS, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,987,1,,void
168504,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_ACCESS, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,987,2,,void
168532,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_ACCESS, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,987,2,,void
168596,BLOCK,-1,,"{  // access(path, mode, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(access);
    SyncCall(env, args[3], &req_wrap_sync, ""access"", uv_fs_access, *path, mode);
    FS_SYNC_TRACE_END(access);
  }",10,,991,1,,void
168604,BLOCK,1,,<empty>,,,,9,,void
168620,BLOCK,-1,,<empty>,5,,994,2,,void
168622,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(access),5,,994,1,,void
168640,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(access),5,,994,2,,void
168668,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(access),5,,994,2,,void
168712,BLOCK,1,,<empty>,,,,9,,void
168728,BLOCK,-1,,<empty>,5,,996,2,,void
168730,BLOCK,-1,,FS_SYNC_TRACE_END(access),5,,996,1,,void
168748,BLOCK,-1,,FS_SYNC_TRACE_END(access),5,,996,2,,void
168776,BLOCK,-1,,FS_SYNC_TRACE_END(access),5,,996,2,,void
168809,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  CHECK(args[0]->IsInt32());
  int fd = args[0].As<Int32>()->Value();
  env->RemoveUnmanagedFd(fd);

  FSReqBase* req_wrap_async = GetReqWrap(args, 1);
  if (req_wrap_async != nullptr) {  // close(fd, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_CLOSE, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""close"", UTF8, AfterNoArgs,
              uv_fs_close, fd);
  } else {  // close(fd, undefined, ctx)
    CHECK_EQ(argc, 3);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(close);
    SyncCall(env, args[2], &req_wrap_sync, ""close"", uv_fs_close, fd);
    FS_SYNC_TRACE_END(close);
  }
}",53,,1001,2,,void
168862,BLOCK,-1,,"{  // close(fd, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_CLOSE, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""close"", UTF8, AfterNoArgs,
              uv_fs_close, fd);
  }",34,,1012,2,,void
168870,BLOCK,1,,<empty>,,,,16,,void
168872,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_CLOSE, req_wrap_async)",5,,1013,1,,void
168890,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_CLOSE, req_wrap_async)",5,,1013,2,,void
168918,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_CLOSE, req_wrap_async)",5,,1013,2,,void
168971,BLOCK,-1,,"{  // close(fd, undefined, ctx)
    CHECK_EQ(argc, 3);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(close);
    SyncCall(env, args[2], &req_wrap_sync, ""close"", uv_fs_close, fd);
    FS_SYNC_TRACE_END(close);
  }",10,,1016,1,,void
168979,BLOCK,1,,<empty>,,,,9,,void
168995,BLOCK,-1,,<empty>,5,,1019,2,,void
168997,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(close),5,,1019,1,,void
169015,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(close),5,,1019,2,,void
169043,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(close),5,,1019,2,,void
169085,BLOCK,1,,<empty>,,,,9,,void
169101,BLOCK,-1,,<empty>,5,,1021,2,,void
169103,BLOCK,-1,,FS_SYNC_TRACE_END(close),5,,1021,1,,void
169121,BLOCK,-1,,FS_SYNC_TRACE_END(close),5,,1021,2,,void
169149,BLOCK,-1,,FS_SYNC_TRACE_END(close),5,,1021,2,,void
169182,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  uv_loop_t* loop = env->event_loop();

  CHECK(args[0]->IsString());
  node::Utf8Value path(isolate, args[0]);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, path.ToStringView());

  if (strlen(*path) != path.length()) {
    args.GetReturnValue().Set(Array::New(isolate));
    return;  // Contains a nul byte.
  }
  uv_fs_t open_req;
  const int fd = uv_fs_open(loop, &open_req, *path, O_RDONLY, 0, nullptr);
  uv_fs_req_cleanup(&open_req);

  if (fd < 0) {
    args.GetReturnValue().Set(Array::New(isolate));
    return;
  }

  auto defer_close = OnScopeLeave([fd, loop]() {
    uv_fs_t close_req;
    CHECK_EQ(0, uv_fs_close(loop, &close_req, fd, nullptr));
    uv_fs_req_cleanup(&close_req);
  });

  const size_t kBlockSize = 32 << 10;
  std::vector<char> chars;
  int64_t offset = 0;
  ssize_t numchars;
  do {
    const size_t start = chars.size();
   ...",77,,1027,2,,void
169237,BLOCK,-1,,"{
    args.GetReturnValue().Set(Array::New(isolate));
    return;  // Contains a nul byte.
  }",39,,1037,2,,void
169270,BLOCK,-1,,"{
    args.GetReturnValue().Set(Array::New(isolate));
    return;
  }",15,,1045,2,,void
169302,BLOCK,-1,,"{
    const size_t start = chars.size();
    chars.resize(start + kBlockSize);

    uv_buf_t buf;
    buf.base = &chars[start];
    buf.len = kBlockSize;

    uv_fs_t read_req;
    numchars = uv_fs_read(loop, &read_req, fd, &buf, 1, offset, nullptr);
    uv_fs_req_cleanup(&read_req);

    if (numchars < 0) {
      args.GetReturnValue().Set(Array::New(isolate));
      return;
    }
    offset += numchars;
  }",6,,1060,1,,void
169351,BLOCK,-1,,"{
      args.GetReturnValue().Set(Array::New(isolate));
      return;
    }",23,,1072,2,,void
169391,BLOCK,-1,,"{
    start = 3;  // Skip UTF-8 BOM.
  }",68,,1080,2,,void
169427,BLOCK,-1,,"{
    char c = *p++;
    if (c == '\\' && p < pe && *p == '""') p++;
    if (c != '""') continue;
    *ppos++ = p;
    if (ppos < &pos[2]) continue;
    ppos = &pos[0];

    char* s = &pos[0][0];
    char* se = &pos[1][-1];  // Exclude quote.
    size_t n = se - s;

    if (n == 4) {
      if (0 == memcmp(s, ""main"", 4)) break;
      if (0 == memcmp(s, ""name"", 4)) break;
      if (0 == memcmp(s, ""type"", 4)) break;
    } else if (n == 7) {
      if (0 == memcmp(s, ""exports"", 7)) break;
      if (0 == memcmp(s, ""imports"", 7)) break;
    }
  }",18,,1091,2,,void
169447,BLOCK,-1,,<empty>,43,,1093,2,,void
169454,BLOCK,-1,,<empty>,19,,1094,2,,void
169468,BLOCK,-1,,<empty>,25,,1096,2,,void
169505,BLOCK,-1,,"{
      if (0 == memcmp(s, ""main"", 4)) break;
      if (0 == memcmp(s, ""name"", 4)) break;
      if (0 == memcmp(s, ""type"", 4)) break;
    }",17,,1103,2,,void
169513,BLOCK,-1,,<empty>,38,,1104,2,,void
169522,BLOCK,-1,,<empty>,38,,1105,2,,void
169531,BLOCK,-1,,<empty>,38,,1106,2,,void
169534,BLOCK,-1,,<empty>,12,,1107,1,,void
169539,BLOCK,-1,,"{
      if (0 == memcmp(s, ""exports"", 7)) break;
      if (0 == memcmp(s, ""imports"", 7)) break;
    }",24,,1107,2,,void
169547,BLOCK,-1,,<empty>,41,,1108,2,,void
169556,BLOCK,-1,,<empty>,41,,1109,2,,void
169610,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsString());
  node::Utf8Value path(env->isolate(), args[0]);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, path.ToStringView());

  uv_fs_t req;
  int rc = uv_fs_stat(env->event_loop(), &req, *path, nullptr);
  if (rc == 0) {
    const uv_stat_t* const s = static_cast<const uv_stat_t*>(req.ptr);
    rc = !!(s->st_mode & S_IFDIR);
  }
  uv_fs_req_cleanup(&req);

  args.GetReturnValue().Set(rc);
}",73,,1126,2,,void
169664,BLOCK,-1,,"{
    const uv_stat_t* const s = static_cast<const uv_stat_t*>(req.ptr);
    rc = !!(s->st_mode & S_IFDIR);
  }",16,,1136,2,,void
169697,BLOCK,-1,,"{
  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
  Environment* env = binding_data->env();

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, path.ToStringView());

  bool use_bigint = args[1]->IsTrue();
  FSReqBase* req_wrap_async = GetReqWrap(args, 2, use_bigint);
  if (req_wrap_async != nullptr) {  // stat(path, use_bigint, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_STAT, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""stat"", UTF8, AfterStat,
              uv_fs_stat, *path);
  } else {  // stat(path, use_bigint, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(stat);
    int err = SyncCall(env, args[3], &req_wrap_sync, ""stat"", uv_fs_stat, *path);
    FS_SYNC_TRACE_END(stat);
    if (err != 0) {
   ...",59,,1145,2,,void
169768,BLOCK,-1,,"{  // stat(path, use_bigint, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_STAT, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""stat"", UTF8, AfterStat,
              uv_fs_stat, *path);
  }",34,,1159,2,,void
169777,BLOCK,1,,<empty>,,,,18,,void
169779,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_STAT, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1160,1,,void
169797,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_STAT, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1160,2,,void
169825,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_STAT, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1160,2,,void
169888,BLOCK,-1,,"{  // stat(path, use_bigint, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(stat);
    int err = SyncCall(env, args[3], &req_wrap_sync, ""stat"", uv_fs_stat, *path);
    FS_SYNC_TRACE_END(stat);
    if (err != 0) {
      return;  // error info is in ctx
    }

    Local<Value> arr = FillGlobalStatsArray(binding_data, use_bigint,
        static_cast<const uv_stat_t*>(req_wrap_sync.req.ptr));
    args.GetReturnValue().Set(arr);
  }",10,,1164,1,,void
169896,BLOCK,1,,<empty>,,,,9,,void
169912,BLOCK,-1,,<empty>,5,,1167,2,,void
169914,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(stat),5,,1167,1,,void
169932,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(stat),5,,1167,2,,void
169960,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(stat),5,,1167,2,,void
170006,BLOCK,1,,<empty>,,,,9,,void
170022,BLOCK,-1,,<empty>,5,,1169,2,,void
170024,BLOCK,-1,,FS_SYNC_TRACE_END(stat),5,,1169,1,,void
170042,BLOCK,-1,,FS_SYNC_TRACE_END(stat),5,,1169,2,,void
170070,BLOCK,-1,,FS_SYNC_TRACE_END(stat),5,,1169,2,,void
170103,BLOCK,-1,,"{
      return;  // error info is in ctx
    }",19,,1170,2,,void
170133,BLOCK,-1,,"{
  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
  Environment* env = binding_data->env();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);

  bool use_bigint = args[1]->IsTrue();
  FSReqBase* req_wrap_async = GetReqWrap(args, 2, use_bigint);
  if (req_wrap_async != nullptr) {  // lstat(path, use_bigint, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LSTAT, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""lstat"", UTF8, AfterStat,
              uv_fs_lstat, *path);
  } else {  // lstat(path, use_bigint, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(lstat);
    int err = SyncCall(env, args[3], &req_wrap_sync, ""lstat"", uv_fs_lstat,
                       *path);
    FS_SYNC_TRACE_END(lstat);
    if (err != 0) {
      return;  // error info is in ctx
    }

    Local<Value> arr = FillGlobalStatsArr...",60,,1180,2,,void
170193,BLOCK,-1,,"{  // lstat(path, use_bigint, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LSTAT, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""lstat"", UTF8, AfterStat,
              uv_fs_lstat, *path);
  }",34,,1192,2,,void
170202,BLOCK,1,,<empty>,,,,18,,void
170204,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LSTAT, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1193,1,,void
170222,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LSTAT, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1193,2,,void
170250,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LSTAT, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1193,2,,void
170313,BLOCK,-1,,"{  // lstat(path, use_bigint, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(lstat);
    int err = SyncCall(env, args[3], &req_wrap_sync, ""lstat"", uv_fs_lstat,
                       *path);
    FS_SYNC_TRACE_END(lstat);
    if (err != 0) {
      return;  // error info is in ctx
    }

    Local<Value> arr = FillGlobalStatsArray(binding_data, use_bigint,
        static_cast<const uv_stat_t*>(req_wrap_sync.req.ptr));
    args.GetReturnValue().Set(arr);
  }",10,,1197,1,,void
170321,BLOCK,1,,<empty>,,,,9,,void
170337,BLOCK,-1,,<empty>,5,,1200,2,,void
170339,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(lstat),5,,1200,1,,void
170357,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(lstat),5,,1200,2,,void
170385,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(lstat),5,,1200,2,,void
170431,BLOCK,1,,<empty>,,,,9,,void
170447,BLOCK,-1,,<empty>,5,,1203,2,,void
170449,BLOCK,-1,,FS_SYNC_TRACE_END(lstat),5,,1203,1,,void
170467,BLOCK,-1,,FS_SYNC_TRACE_END(lstat),5,,1203,2,,void
170495,BLOCK,-1,,FS_SYNC_TRACE_END(lstat),5,,1203,2,,void
170528,BLOCK,-1,,"{
      return;  // error info is in ctx
    }",19,,1204,2,,void
170558,BLOCK,-1,,"{
  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
  Environment* env = binding_data->env();

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  CHECK(args[0]->IsInt32());
  int fd = args[0].As<Int32>()->Value();

  bool use_bigint = args[1]->IsTrue();
  FSReqBase* req_wrap_async = GetReqWrap(args, 2, use_bigint);
  if (req_wrap_async != nullptr) {  // fstat(fd, use_bigint, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FSTAT, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""fstat"", UTF8, AfterStat,
              uv_fs_fstat, fd);
  } else {  // fstat(fd, use_bigint, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(fstat);
    int err = SyncCall(env, args[3], &req_wrap_sync, ""fstat"", uv_fs_fstat, fd);
    FS_SYNC_TRACE_END(fstat);
    if (err != 0) {
      return;  // error info is in ctx
    }

    Local<Value> arr = FillGlobalStatsArray(binding_data, use_bigint,
        static_cast<const uv_stat_t*>(req_wr...",60,,1214,2,,void
170625,BLOCK,-1,,"{  // fstat(fd, use_bigint, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FSTAT, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""fstat"", UTF8, AfterStat,
              uv_fs_fstat, fd);
  }",34,,1226,2,,void
170633,BLOCK,1,,<empty>,,,,16,,void
170635,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FSTAT, req_wrap_async)",5,,1227,1,,void
170653,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FSTAT, req_wrap_async)",5,,1227,2,,void
170681,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FSTAT, req_wrap_async)",5,,1227,2,,void
170734,BLOCK,-1,,"{  // fstat(fd, use_bigint, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(fstat);
    int err = SyncCall(env, args[3], &req_wrap_sync, ""fstat"", uv_fs_fstat, fd);
    FS_SYNC_TRACE_END(fstat);
    if (err != 0) {
      return;  // error info is in ctx
    }

    Local<Value> arr = FillGlobalStatsArray(binding_data, use_bigint,
        static_cast<const uv_stat_t*>(req_wrap_sync.req.ptr));
    args.GetReturnValue().Set(arr);
  }",10,,1230,1,,void
170742,BLOCK,1,,<empty>,,,,9,,void
170758,BLOCK,-1,,<empty>,5,,1233,2,,void
170760,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(fstat),5,,1233,1,,void
170778,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(fstat),5,,1233,2,,void
170806,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(fstat),5,,1233,2,,void
170851,BLOCK,1,,<empty>,,,,9,,void
170867,BLOCK,-1,,<empty>,5,,1235,2,,void
170869,BLOCK,-1,,FS_SYNC_TRACE_END(fstat),5,,1235,1,,void
170887,BLOCK,-1,,FS_SYNC_TRACE_END(fstat),5,,1235,2,,void
170915,BLOCK,-1,,FS_SYNC_TRACE_END(fstat),5,,1235,2,,void
170948,BLOCK,-1,,"{
      return;  // error info is in ctx
    }",19,,1236,2,,void
170978,BLOCK,-1,,"{
  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
  Environment* env = binding_data->env();

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);

  bool use_bigint = args[1]->IsTrue();
  FSReqBase* req_wrap_async = GetReqWrap(args, 2, use_bigint);
  if (req_wrap_async != nullptr) {  // statfs(path, use_bigint, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_STATFS, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env,
              req_wrap_async,
              args,
              ""statfs"",
              UTF8,
              AfterStatFs,
              uv_fs_statfs,
              *path);
  } else {  // statfs(path, use_bigint, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(statfs);
    int err =
        SyncCall(env, args[3], &req_wrap_sync, ""statfs"", uv_fs_statfs, *path);
    FS_SYNC_TRACE_END(statfs);
    if (err != 0) {
      r...",61,,1246,2,,void
171038,BLOCK,-1,,"{  // statfs(path, use_bigint, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_STATFS, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env,
              req_wrap_async,
              args,
              ""statfs"",
              UTF8,
              AfterStatFs,
              uv_fs_statfs,
              *path);
  }",34,,1258,2,,void
171047,BLOCK,1,,<empty>,,,,18,,void
171049,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_STATFS, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1259,1,,void
171067,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_STATFS, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1259,2,,void
171095,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_STATFS, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1259,2,,void
171158,BLOCK,-1,,"{  // statfs(path, use_bigint, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(statfs);
    int err =
        SyncCall(env, args[3], &req_wrap_sync, ""statfs"", uv_fs_statfs, *path);
    FS_SYNC_TRACE_END(statfs);
    if (err != 0) {
      return;  // error info is in ctx
    }

    Local<Value> arr = FillGlobalStatFsArray(
        binding_data,
        use_bigint,
        static_cast<const uv_statfs_t*>(req_wrap_sync.req.ptr));
    args.GetReturnValue().Set(arr);
  }",10,,1269,1,,void
171166,BLOCK,1,,<empty>,,,,9,,void
171182,BLOCK,-1,,<empty>,5,,1272,2,,void
171184,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(statfs),5,,1272,1,,void
171202,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(statfs),5,,1272,2,,void
171230,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(statfs),5,,1272,2,,void
171276,BLOCK,1,,<empty>,,,,9,,void
171292,BLOCK,-1,,<empty>,5,,1275,2,,void
171294,BLOCK,-1,,FS_SYNC_TRACE_END(statfs),5,,1275,1,,void
171312,BLOCK,-1,,FS_SYNC_TRACE_END(statfs),5,,1275,2,,void
171340,BLOCK,-1,,FS_SYNC_TRACE_END(statfs),5,,1275,2,,void
171373,BLOCK,-1,,"{
      return;  // error info is in ctx
    }",19,,1276,2,,void
171403,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 4);

  BufferValue target(isolate, args[0]);
  CHECK_NOT_NULL(*target);
  auto target_view = target.ToStringView();
  // To avoid bypass the symlink target should be allowed to read and write
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, target_view);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, target_view);

  BufferValue path(isolate, args[1]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, path.ToStringView());

  CHECK(args[2]->IsInt32());
  int flags = args[2].As<Int32>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // symlink(target, path, flags, req)
    FS_ASYNC_TRACE_BEGIN2(UV_FS_SYMLINK,
                        ...",62,,1288,2,,void
171510,BLOCK,-1,,"{  // symlink(target, path, flags, req)
    FS_ASYNC_TRACE_BEGIN2(UV_FS_SYMLINK,
                          req_wrap_async,
                          ""target"",
                          TRACE_STR_COPY(*target),
                          ""path"",
                          TRACE_STR_COPY(*path))
    AsyncDestCall(env, req_wrap_async, args, ""symlink"", *path, path.length(),
                  UTF8, AfterNoArgs, uv_fs_symlink, *target, *path, flags);
  }",34,,1313,2,,void
171520,BLOCK,1,,<empty>,,,,20,,void
171522,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN2(UV_FS_SYMLINK,
                          req_wrap_async,
                          ""target"",
                          TRACE_STR_COPY(*target),
                          ""path"",
                          TRACE_STR_COPY(*path))",5,,1314,1,,void
171540,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN2(UV_FS_SYMLINK,
                          req_wrap_async,
                          ""target"",
                          TRACE_STR_COPY(*target),
                          ""path"",
                          TRACE_STR_COPY(*path))",5,,1314,2,,void
171568,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN2(UV_FS_SYMLINK,
                          req_wrap_async,
                          ""target"",
                          TRACE_STR_COPY(*target),
                          ""path"",
                          TRACE_STR_COPY(*path))",5,,1314,2,,void
171649,BLOCK,-1,,"{  // symlink(target, path, flags, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(symlink);
    SyncCall(env, args[4], &req_wrap_sync, ""symlink"",
             uv_fs_symlink, *target, *path, flags);
    FS_SYNC_TRACE_END(symlink);
  }",10,,1322,1,,void
171657,BLOCK,1,,<empty>,,,,9,,void
171673,BLOCK,-1,,<empty>,5,,1325,2,,void
171675,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(symlink),5,,1325,1,,void
171693,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(symlink),5,,1325,2,,void
171721,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(symlink),5,,1325,2,,void
171767,BLOCK,1,,<empty>,,,,9,,void
171783,BLOCK,-1,,<empty>,5,,1328,2,,void
171785,BLOCK,-1,,FS_SYNC_TRACE_END(symlink),5,,1328,1,,void
171803,BLOCK,-1,,FS_SYNC_TRACE_END(symlink),5,,1328,2,,void
171831,BLOCK,-1,,FS_SYNC_TRACE_END(symlink),5,,1328,2,,void
171864,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue src(isolate, args[0]);
  CHECK_NOT_NULL(*src);

  const auto src_view = src.ToStringView();
  // To avoid bypass the link target should be allowed to read and write
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, src_view);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, src_view);

  BufferValue dest(isolate, args[1]);
  CHECK_NOT_NULL(*dest);
  const auto dest_view = dest.ToStringView();
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, dest_view);

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {  // link(src, dest, req)
    FS_ASYNC_TRACE_BEGIN2(UV_FS_LINK,
                          req_wrap_async,
                          ""src"",
                 ...",59,,1332,2,,void
171956,BLOCK,-1,,"{  // link(src, dest, req)
    FS_ASYNC_TRACE_BEGIN2(UV_FS_LINK,
                          req_wrap_async,
                          ""src"",
                          TRACE_STR_COPY(*src),
                          ""dest"",
                          TRACE_STR_COPY(*dest))
    AsyncDestCall(env, req_wrap_async, args, ""link"", *dest, dest.length(), UTF8,
                  AfterNoArgs, uv_fs_link, *src, *dest);
  }",34,,1356,2,,void
171966,BLOCK,1,,<empty>,,,,20,,void
171968,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN2(UV_FS_LINK,
                          req_wrap_async,
                          ""src"",
                          TRACE_STR_COPY(*src),
                          ""dest"",
                          TRACE_STR_COPY(*dest))",5,,1357,1,,void
171986,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN2(UV_FS_LINK,
                          req_wrap_async,
                          ""src"",
                          TRACE_STR_COPY(*src),
                          ""dest"",
                          TRACE_STR_COPY(*dest))",5,,1357,2,,void
172014,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN2(UV_FS_LINK,
                          req_wrap_async,
                          ""src"",
                          TRACE_STR_COPY(*src),
                          ""dest"",
                          TRACE_STR_COPY(*dest))",5,,1357,2,,void
172094,BLOCK,-1,,"{  // link(src, dest)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(link);
    SyncCall(env, args[3], &req_wrap_sync, ""link"",
             uv_fs_link, *src, *dest);
    FS_SYNC_TRACE_END(link);
  }",10,,1365,1,,void
172102,BLOCK,1,,<empty>,,,,9,,void
172118,BLOCK,-1,,<empty>,5,,1368,2,,void
172120,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(link),5,,1368,1,,void
172138,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(link),5,,1368,2,,void
172166,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(link),5,,1368,2,,void
172211,BLOCK,1,,<empty>,,,,9,,void
172227,BLOCK,-1,,<empty>,5,,1371,2,,void
172229,BLOCK,-1,,FS_SYNC_TRACE_END(link),5,,1371,1,,void
172247,BLOCK,-1,,FS_SYNC_TRACE_END(link),5,,1371,2,,void
172275,BLOCK,-1,,FS_SYNC_TRACE_END(link),5,,1371,2,,void
172308,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(isolate, args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, path.ToStringView());

  const enum encoding encoding = ParseEncoding(isolate, args[1], UTF8);

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {  // readlink(path, encoding, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_READLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""readlink"", encoding, AfterStringPtr,
              uv_fs_readlink, *path);
  } else {
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(readlink);
    int err = SyncCall(env, args[3], &req_wrap_sync, ""readlink"",
                       uv_fs_readlink, *path);
    FS_SYNC_TRACE_END(readlink);
    if (err < ...",63,,1375,2,,void
172373,BLOCK,-1,,"{  // readlink(path, encoding, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_READLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""readlink"", encoding, AfterStringPtr,
              uv_fs_readlink, *path);
  }",34,,1390,2,,void
172382,BLOCK,1,,<empty>,,,,18,,void
172384,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_READLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1391,1,,void
172402,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_READLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1391,2,,void
172430,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_READLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1391,2,,void
172493,BLOCK,-1,,"{
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(readlink);
    int err = SyncCall(env, args[3], &req_wrap_sync, ""readlink"",
                       uv_fs_readlink, *path);
    FS_SYNC_TRACE_END(readlink);
    if (err < 0) {
      return;  // syscall failed, no need to continue, error info is in ctx
    }
    const char* link_path = static_cast<const char*>(req_wrap_sync.req.ptr);

    Local<Value> error;
    MaybeLocal<Value> rc = StringBytes::Encode(isolate,
                                               link_path,
                                               encoding,
                                               &error);
    if (rc.IsEmpty()) {
      Local<Object> ctx = args[3].As<Object>();
      ctx->Set(env->context(), env->error_string(), error).Check();
      return;
    }

    args.GetReturnValue().Set(rc.ToLocalChecked());
  }",10,,1395,1,,void
172501,BLOCK,1,,<empty>,,,,9,,void
172517,BLOCK,-1,,<empty>,5,,1398,2,,void
172519,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(readlink),5,,1398,1,,void
172537,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(readlink),5,,1398,2,,void
172565,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(readlink),5,,1398,2,,void
172611,BLOCK,1,,<empty>,,,,9,,void
172627,BLOCK,-1,,<empty>,5,,1401,2,,void
172629,BLOCK,-1,,FS_SYNC_TRACE_END(readlink),5,,1401,1,,void
172647,BLOCK,-1,,FS_SYNC_TRACE_END(readlink),5,,1401,2,,void
172675,BLOCK,-1,,FS_SYNC_TRACE_END(readlink),5,,1401,2,,void
172708,BLOCK,-1,,"{
      return;  // syscall failed, no need to continue, error info is in ctx
    }",18,,1402,2,,void
172745,BLOCK,-1,,"{
      Local<Object> ctx = args[3].As<Object>();
      ctx->Set(env->context(), env->error_string(), error).Check();
      return;
    }",23,,1412,2,,void
172790,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue old_path(isolate, args[0]);
  CHECK_NOT_NULL(*old_path);
  auto view_old_path = old_path.ToStringView();
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, view_old_path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, view_old_path);

  BufferValue new_path(isolate, args[1]);
  CHECK_NOT_NULL(*new_path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env,
      permission::PermissionScope::kFileSystemWrite,
      new_path.ToStringView());

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {
    FS_ASYNC_TRACE_BEGIN2(UV_FS_RENAME,
                          req_wrap_async,
                          ""old_path"",
                          TRACE_STR_COPY(*old_path),
                          ""new_path"",
      ...",61,,1422,2,,void
172878,BLOCK,-1,,"{
    FS_ASYNC_TRACE_BEGIN2(UV_FS_RENAME,
                          req_wrap_async,
                          ""old_path"",
                          TRACE_STR_COPY(*old_path),
                          ""new_path"",
                          TRACE_STR_COPY(*new_path))
    AsyncDestCall(env, req_wrap_async, args, ""rename"", *new_path,
                  new_path.length(), UTF8, AfterNoArgs, uv_fs_rename,
                  *old_path, *new_path);
  }",34,,1445,2,,void
172888,BLOCK,1,,<empty>,,,,20,,void
172890,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN2(UV_FS_RENAME,
                          req_wrap_async,
                          ""old_path"",
                          TRACE_STR_COPY(*old_path),
                          ""new_path"",
                          TRACE_STR_COPY(*new_path))",5,,1446,1,,void
172908,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN2(UV_FS_RENAME,
                          req_wrap_async,
                          ""old_path"",
                          TRACE_STR_COPY(*old_path),
                          ""new_path"",
                          TRACE_STR_COPY(*new_path))",5,,1446,2,,void
172936,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN2(UV_FS_RENAME,
                          req_wrap_async,
                          ""old_path"",
                          TRACE_STR_COPY(*old_path),
                          ""new_path"",
                          TRACE_STR_COPY(*new_path))",5,,1446,2,,void
173016,BLOCK,-1,,"{
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(rename);
    SyncCall(env, args[3], &req_wrap_sync, ""rename"", uv_fs_rename,
             *old_path, *new_path);
    FS_SYNC_TRACE_END(rename);
  }",10,,1455,1,,void
173024,BLOCK,1,,<empty>,,,,9,,void
173040,BLOCK,-1,,<empty>,5,,1458,2,,void
173042,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(rename),5,,1458,1,,void
173060,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(rename),5,,1458,2,,void
173088,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(rename),5,,1458,2,,void
173133,BLOCK,1,,<empty>,,,,9,,void
173149,BLOCK,-1,,<empty>,5,,1461,2,,void
173151,BLOCK,-1,,FS_SYNC_TRACE_END(rename),5,,1461,1,,void
173169,BLOCK,-1,,FS_SYNC_TRACE_END(rename),5,,1461,2,,void
173197,BLOCK,-1,,FS_SYNC_TRACE_END(rename),5,,1461,2,,void
173230,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  CHECK(IsSafeJsInt(args[1]));
  const int64_t len = args[1].As<Integer>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FTRUNCATE, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""ftruncate"", UTF8, AfterNoArgs,
              uv_fs_ftruncate, fd, len);
  } else {
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(ftruncate);
    SyncCall(env, args[3], &req_wrap_sync, ""ftruncate"", uv_fs_ftruncate, fd,
             len);
    FS_SYNC_TRACE_END(ftruncate);
  }
}",64,,1465,2,,void
173295,BLOCK,-1,,"{
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FTRUNCATE, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""ftruncate"", UTF8, AfterNoArgs,
              uv_fs_ftruncate, fd, len);
  }",34,,1478,2,,void
173303,BLOCK,1,,<empty>,,,,16,,void
173305,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FTRUNCATE, req_wrap_async)",5,,1479,1,,void
173323,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FTRUNCATE, req_wrap_async)",5,,1479,2,,void
173351,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FTRUNCATE, req_wrap_async)",5,,1479,2,,void
173405,BLOCK,-1,,"{
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(ftruncate);
    SyncCall(env, args[3], &req_wrap_sync, ""ftruncate"", uv_fs_ftruncate, fd,
             len);
    FS_SYNC_TRACE_END(ftruncate);
  }",10,,1482,1,,void
173413,BLOCK,1,,<empty>,,,,9,,void
173429,BLOCK,-1,,<empty>,5,,1485,2,,void
173431,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(ftruncate),5,,1485,1,,void
173449,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(ftruncate),5,,1485,2,,void
173477,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(ftruncate),5,,1485,2,,void
173520,BLOCK,1,,<empty>,,,,9,,void
173536,BLOCK,-1,,<empty>,5,,1488,2,,void
173538,BLOCK,-1,,FS_SYNC_TRACE_END(ftruncate),5,,1488,1,,void
173556,BLOCK,-1,,FS_SYNC_TRACE_END(ftruncate),5,,1488,2,,void
173584,BLOCK,-1,,FS_SYNC_TRACE_END(ftruncate),5,,1488,2,,void
173617,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 1);
  if (req_wrap_async != nullptr) {
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FDATASYNC, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""fdatasync"", UTF8, AfterNoArgs,
              uv_fs_fdatasync, fd);
  } else {
    CHECK_EQ(argc, 3);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(fdatasync);
    SyncCall(env, args[2], &req_wrap_sync, ""fdatasync"", uv_fs_fdatasync, fd);
    FS_SYNC_TRACE_END(fdatasync);
  }
}",64,,1492,2,,void
173665,BLOCK,-1,,"{
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FDATASYNC, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""fdatasync"", UTF8, AfterNoArgs,
              uv_fs_fdatasync, fd);
  }",34,,1502,2,,void
173673,BLOCK,1,,<empty>,,,,16,,void
173675,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FDATASYNC, req_wrap_async)",5,,1503,1,,void
173693,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FDATASYNC, req_wrap_async)",5,,1503,2,,void
173721,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FDATASYNC, req_wrap_async)",5,,1503,2,,void
173774,BLOCK,-1,,"{
    CHECK_EQ(argc, 3);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(fdatasync);
    SyncCall(env, args[2], &req_wrap_sync, ""fdatasync"", uv_fs_fdatasync, fd);
    FS_SYNC_TRACE_END(fdatasync);
  }",10,,1506,1,,void
173782,BLOCK,1,,<empty>,,,,9,,void
173798,BLOCK,-1,,<empty>,5,,1509,2,,void
173800,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(fdatasync),5,,1509,1,,void
173818,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(fdatasync),5,,1509,2,,void
173846,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(fdatasync),5,,1509,2,,void
173888,BLOCK,1,,<empty>,,,,9,,void
173904,BLOCK,-1,,<empty>,5,,1511,2,,void
173906,BLOCK,-1,,FS_SYNC_TRACE_END(fdatasync),5,,1511,1,,void
173924,BLOCK,-1,,FS_SYNC_TRACE_END(fdatasync),5,,1511,2,,void
173952,BLOCK,-1,,FS_SYNC_TRACE_END(fdatasync),5,,1511,2,,void
173985,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 1);
  if (req_wrap_async != nullptr) {
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FSYNC, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""fsync"", UTF8, AfterNoArgs,
              uv_fs_fsync, fd);
  } else {
    CHECK_EQ(argc, 3);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(fsync);
    SyncCall(env, args[2], &req_wrap_sync, ""fsync"", uv_fs_fsync, fd);
    FS_SYNC_TRACE_END(fsync);
  }
}",60,,1515,2,,void
174033,BLOCK,-1,,"{
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FSYNC, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""fsync"", UTF8, AfterNoArgs,
              uv_fs_fsync, fd);
  }",34,,1525,2,,void
174041,BLOCK,1,,<empty>,,,,16,,void
174043,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FSYNC, req_wrap_async)",5,,1526,1,,void
174061,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FSYNC, req_wrap_async)",5,,1526,2,,void
174089,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FSYNC, req_wrap_async)",5,,1526,2,,void
174142,BLOCK,-1,,"{
    CHECK_EQ(argc, 3);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(fsync);
    SyncCall(env, args[2], &req_wrap_sync, ""fsync"", uv_fs_fsync, fd);
    FS_SYNC_TRACE_END(fsync);
  }",10,,1529,1,,void
174150,BLOCK,1,,<empty>,,,,9,,void
174166,BLOCK,-1,,<empty>,5,,1532,2,,void
174168,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(fsync),5,,1532,1,,void
174186,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(fsync),5,,1532,2,,void
174214,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(fsync),5,,1532,2,,void
174256,BLOCK,1,,<empty>,,,,9,,void
174272,BLOCK,-1,,<empty>,5,,1534,2,,void
174274,BLOCK,-1,,FS_SYNC_TRACE_END(fsync),5,,1534,1,,void
174292,BLOCK,-1,,FS_SYNC_TRACE_END(fsync),5,,1534,2,,void
174320,BLOCK,-1,,FS_SYNC_TRACE_END(fsync),5,,1534,2,,void
174353,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, path.ToStringView());

  FSReqBase* req_wrap_async = GetReqWrap(args, 1);
  if (req_wrap_async != nullptr) {
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UNLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""unlink"", UTF8, AfterNoArgs,
              uv_fs_unlink, *path);
  } else {
    CHECK_EQ(argc, 3);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(unlink);
    SyncCall(env, args[2], &req_wrap_sync, ""unlink"", uv_fs_unlink, *path);
    FS_SYNC_TRACE_END(unlink);
  }
}",61,,1538,2,,void
174405,BLOCK,-1,,"{
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UNLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""unlink"", UTF8, AfterNoArgs,
              uv_fs_unlink, *path);
  }",34,,1550,2,,void
174414,BLOCK,1,,<empty>,,,,18,,void
174416,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UNLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1551,1,,void
174434,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UNLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1551,2,,void
174462,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UNLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1551,2,,void
174525,BLOCK,-1,,"{
    CHECK_EQ(argc, 3);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(unlink);
    SyncCall(env, args[2], &req_wrap_sync, ""unlink"", uv_fs_unlink, *path);
    FS_SYNC_TRACE_END(unlink);
  }",10,,1555,1,,void
174533,BLOCK,1,,<empty>,,,,9,,void
174549,BLOCK,-1,,<empty>,5,,1558,2,,void
174551,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(unlink),5,,1558,1,,void
174569,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(unlink),5,,1558,2,,void
174597,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(unlink),5,,1558,2,,void
174640,BLOCK,1,,<empty>,,,,9,,void
174656,BLOCK,-1,,<empty>,5,,1560,2,,void
174658,BLOCK,-1,,FS_SYNC_TRACE_END(unlink),5,,1560,1,,void
174676,BLOCK,-1,,FS_SYNC_TRACE_END(unlink),5,,1560,2,,void
174704,BLOCK,-1,,FS_SYNC_TRACE_END(unlink),5,,1560,2,,void
174737,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, path.ToStringView());

  FSReqBase* req_wrap_async = GetReqWrap(args, 1);  // rmdir(path, req)
  if (req_wrap_async != nullptr) {
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_RMDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""rmdir"", UTF8, AfterNoArgs,
              uv_fs_rmdir, *path);
  } else {  // rmdir(path, undefined, ctx)
    CHECK_EQ(argc, 3);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(rmdir);
    SyncCall(env, args[2], &req_wrap_sync, ""rmdir"",
             uv_fs_rmdir, *path);
    FS_SYNC_TRACE_END(rmdir);
  }
}",60,,1564,2,,void
174789,BLOCK,-1,,"{
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_RMDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""rmdir"", UTF8, AfterNoArgs,
              uv_fs_rmdir, *path);
  }",34,,1576,2,,void
174798,BLOCK,1,,<empty>,,,,18,,void
174800,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_RMDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1577,1,,void
174818,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_RMDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1577,2,,void
174846,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_RMDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1577,2,,void
174909,BLOCK,-1,,"{  // rmdir(path, undefined, ctx)
    CHECK_EQ(argc, 3);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(rmdir);
    SyncCall(env, args[2], &req_wrap_sync, ""rmdir"",
             uv_fs_rmdir, *path);
    FS_SYNC_TRACE_END(rmdir);
  }",10,,1581,1,,void
174917,BLOCK,1,,<empty>,,,,9,,void
174933,BLOCK,-1,,<empty>,5,,1584,2,,void
174935,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(rmdir),5,,1584,1,,void
174953,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(rmdir),5,,1584,2,,void
174981,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(rmdir),5,,1584,2,,void
175024,BLOCK,1,,<empty>,,,,9,,void
175040,BLOCK,-1,,<empty>,5,,1587,2,,void
175042,BLOCK,-1,,FS_SYNC_TRACE_END(rmdir),5,,1587,1,,void
175060,BLOCK,-1,,FS_SYNC_TRACE_END(rmdir),5,,1587,2,,void
175088,BLOCK,-1,,FS_SYNC_TRACE_END(rmdir),5,,1587,2,,void
175125,BLOCK,-1,,"{
  FSReqWrapSync* req_wrap = ContainerOf(&FSReqWrapSync::req, req);

  // on the first iteration of algorithm, stash state information.
  if (req_wrap->continuation_data() == nullptr) {
    req_wrap->set_continuation_data(
        std::make_unique<FSContinuationData>(req, mode, cb));
    req_wrap->continuation_data()->PushPath(std::move(path));
  }

  while (req_wrap->continuation_data()->paths().size() > 0) {
    std::string next_path = req_wrap->continuation_data()->PopPath();
    int err = uv_fs_mkdir(loop, req, next_path.c_str(), mode, nullptr);
    while (true) {
      switch (err) {
        // Note: uv_fs_req_cleanup in terminal paths will be called by
        // ~FSReqWrapSync():
        case 0:
          req_wrap->continuation_data()->MaybeSetFirstPath(next_path);
          if (req_wrap->continuation_data()->paths().size() == 0) {
            return 0;
          }
          break;
        case UV_EACCES:
        case UV_ENOSPC:
        case UV_ENOTDIR:
        case UV_EPERM...",29,,1595,6,,void
175142,BLOCK,-1,,"{
    req_wrap->set_continuation_data(
        std::make_unique<FSContinuationData>(req, mode, cb));
    req_wrap->continuation_data()->PushPath(std::move(path));
  }",49,,1599,2,,void
175183,BLOCK,-1,,"{
    std::string next_path = req_wrap->continuation_data()->PopPath();
    int err = uv_fs_mkdir(loop, req, next_path.c_str(), mode, nullptr);
    while (true) {
      switch (err) {
        // Note: uv_fs_req_cleanup in terminal paths will be called by
        // ~FSReqWrapSync():
        case 0:
          req_wrap->continuation_data()->MaybeSetFirstPath(next_path);
          if (req_wrap->continuation_data()->paths().size() == 0) {
            return 0;
          }
          break;
        case UV_EACCES:
        case UV_ENOSPC:
        case UV_ENOTDIR:
        case UV_EPERM: {
          return err;
        }
        case UV_ENOENT: {
          std::string dirname = next_path.substr(0,
                                        next_path.find_last_of(kPathSeparator));
          if (dirname != next_path) {
            req_wrap->continuation_data()->PushPath(std::move(next_path));
            req_wrap->continuation_data()->PushPath(std::move(dirname));
          } else if (req_wrap->c...",61,,1605,2,,void
175208,BLOCK,-1,,"{
      switch (err) {
        // Note: uv_fs_req_cleanup in terminal paths will be called by
        // ~FSReqWrapSync():
        case 0:
          req_wrap->continuation_data()->MaybeSetFirstPath(next_path);
          if (req_wrap->continuation_data()->paths().size() == 0) {
            return 0;
          }
          break;
        case UV_EACCES:
        case UV_ENOSPC:
        case UV_ENOTDIR:
        case UV_EPERM: {
          return err;
        }
        case UV_ENOENT: {
          std::string dirname = next_path.substr(0,
                                        next_path.find_last_of(kPathSeparator));
          if (dirname != next_path) {
            req_wrap->continuation_data()->PushPath(std::move(next_path));
            req_wrap->continuation_data()->PushPath(std::move(dirname));
          } else if (req_wrap->continuation_data()->paths().size() == 0) {
            err = UV_EEXIST;
            continue;
          }
          break;
        }
        default:
          u...",18,,1608,2,,void
175211,BLOCK,-1,,"{
        // Note: uv_fs_req_cleanup in terminal paths will be called by
        // ~FSReqWrapSync():
        case 0:
          req_wrap->continuation_data()->MaybeSetFirstPath(next_path);
          if (req_wrap->continuation_data()->paths().size() == 0) {
            return 0;
          }
          break;
        case UV_EACCES:
        case UV_ENOSPC:
        case UV_ENOTDIR:
        case UV_EPERM: {
          return err;
        }
        case UV_ENOENT: {
          std::string dirname = next_path.substr(0,
                                        next_path.find_last_of(kPathSeparator));
          if (dirname != next_path) {
            req_wrap->continuation_data()->PushPath(std::move(next_path));
            req_wrap->continuation_data()->PushPath(std::move(dirname));
          } else if (req_wrap->continuation_data()->paths().size() == 0) {
            err = UV_EEXIST;
            continue;
          }
          break;
        }
        default:
          uv_fs_req_cleanup(req)...",20,,1609,2,,void
175235,BLOCK,-1,,"{
            return 0;
          }",67,,1614,2,,void
175247,BLOCK,14,,"{
          return err;
        }",24,,1621,14,,void
175252,BLOCK,17,,"{
          std::string dirname = next_path.substr(0,
                                        next_path.find_last_of(kPathSeparator));
          if (dirname != next_path) {
            req_wrap->continuation_data()->PushPath(std::move(next_path));
            req_wrap->continuation_data()->PushPath(std::move(dirname));
          } else if (req_wrap->continuation_data()->paths().size() == 0) {
            err = UV_EEXIST;
            continue;
          }
          break;
        }",25,,1624,17,,void
175270,BLOCK,-1,,"{
            req_wrap->continuation_data()->PushPath(std::move(next_path));
            req_wrap->continuation_data()->PushPath(std::move(dirname));
          }",37,,1627,2,,void
175296,BLOCK,-1,,<empty>,18,,1630,1,,void
175310,BLOCK,-1,,"{
            err = UV_EEXIST;
            continue;
          }",74,,1630,2,,void
175345,BLOCK,1,,<empty>,,,,2,,void
175355,BLOCK,-1,,"{
            uv_fs_req_cleanup(req);
            if (orig_err == UV_EEXIST &&
              req_wrap->continuation_data()->paths().size() > 0) {
              return UV_ENOTDIR;
            }
            return UV_EEXIST;
          }",59,,1640,2,,void
175375,BLOCK,-1,,"{
              return UV_ENOTDIR;
            }",66,,1643,2,,void
175384,BLOCK,-1,,<empty>,24,,1648,2,,void
175400,BLOCK,-1,,"{
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  // on the first iteration of algorithm, stash state information.
  if (req_wrap->continuation_data() == nullptr) {
    req_wrap->set_continuation_data(
        std::make_unique<FSContinuationData>(req, mode, cb));
    req_wrap->continuation_data()->PushPath(std::move(path));
  }

  // on each iteration of algorithm, mkdir directory on top of stack.
  std::string next_path = req_wrap->continuation_data()->PopPath();
  int err = uv_fs_mkdir(loop, req, next_path.c_str(), mode,
                        uv_fs_callback_t{[](uv_fs_t* req) {
    FSReqBase* req_wrap = FSReqBase::from_req(req);
    Environment* env = req_wrap->env();
    uv_loop_t* loop = env->event_loop();
    std::string path = req->path;
    int err = static_cast<int>(req->result);

    while (true) {
      switch (err) {
        // Note: uv_fs_req_cleanup in terminal paths will be called by
        // FSReqAfterScope::~FSReqAfterScope()
        case 0: {
          if (r...",30,,1663,6,,void
175416,BLOCK,-1,,"{
    req_wrap->set_continuation_data(
        std::make_unique<FSContinuationData>(req, mode, cb));
    req_wrap->continuation_data()->PushPath(std::move(path));
  }",49,,1666,2,,void
175478,BLOCK,-1,,"{
  env->PrintSyncTrace();
  int err = MKDirpSync(env->event_loop(), &req_wrap->req, path, mode,
                       nullptr);
  if (err < 0) {
    v8::Local<v8::Context> context = env->context();
    v8::Local<v8::Object> ctx_obj = args[4].As<v8::Object>();
    v8::Isolate* isolate = env->isolate();
    ctx_obj->Set(context,
                 env->errno_string(),
                 v8::Integer::New(isolate, err)).Check();
    ctx_obj->Set(context,
                 env->syscall_string(),
                 OneByteString(isolate, ""mkdir"")).Check();
  }
  return err;
}",73,,1755,6,,void
175502,BLOCK,-1,,"{
    v8::Local<v8::Context> context = env->context();
    v8::Local<v8::Object> ctx_obj = args[4].As<v8::Object>();
    v8::Isolate* isolate = env->isolate();
    ctx_obj->Set(context,
                 env->errno_string(),
                 v8::Integer::New(isolate, err)).Check();
    ctx_obj->Set(context,
                 env->syscall_string(),
                 OneByteString(isolate, ""mkdir"")).Check();
  }",16,,1759,2,,void
175581,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 4);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, path.ToStringView());

  CHECK(args[1]->IsInt32());
  const int mode = args[1].As<Int32>()->Value();

  CHECK(args[2]->IsBoolean());
  bool mkdirp = args[2]->IsTrue();

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // mkdir(path, mode, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UNLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""mkdir"", UTF8,
              mkdirp ? AfterMkdirp : AfterNoArgs,
              mkdirp ? MKDirpAsync : uv_fs_mkdir, *path, mode);
  } else {  // mkdir(path, mode, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(mkdir);
    if (mkdirp) {
      int err = Ca...",60,,1773,2,,void
175668,BLOCK,-1,,"{  // mkdir(path, mode, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UNLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""mkdir"", UTF8,
              mkdirp ? AfterMkdirp : AfterNoArgs,
              mkdirp ? MKDirpAsync : uv_fs_mkdir, *path, mode);
  }",34,,1791,2,,void
175677,BLOCK,1,,<empty>,,,,18,,void
175679,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UNLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1792,1,,void
175697,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UNLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1792,2,,void
175725,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UNLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1792,2,,void
175795,BLOCK,-1,,"{  // mkdir(path, mode, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(mkdir);
    if (mkdirp) {
      int err = CallMKDirpSync(env, args, &req_wrap_sync, *path, mode);
      if (err == 0 &&
          !req_wrap_sync.continuation_data()->first_path().empty()) {
        Local<Value> error;
        std::string first_path(req_wrap_sync.continuation_data()->first_path());
        FromNamespacedPath(&first_path);
        MaybeLocal<Value> path = StringBytes::Encode(env->isolate(),
                                                     first_path.c_str(),
                                                     UTF8, &error);
        if (path.IsEmpty()) {
          Local<Object> ctx = args[4].As<Object>();
          ctx->Set(env->context(), env->error_string(), error).Check();
          return;
        }
        args.GetReturnValue().Set(path.ToLocalChecked());
      }
    } else {
      SyncCall(env, args[4], &req_wrap_sync, ""mkdir"",
            ...",10,,1797,1,,void
175803,BLOCK,1,,<empty>,,,,9,,void
175819,BLOCK,-1,,<empty>,5,,1800,2,,void
175821,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(mkdir),5,,1800,1,,void
175839,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(mkdir),5,,1800,2,,void
175867,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(mkdir),5,,1800,2,,void
175898,BLOCK,-1,,"{
      int err = CallMKDirpSync(env, args, &req_wrap_sync, *path, mode);
      if (err == 0 &&
          !req_wrap_sync.continuation_data()->first_path().empty()) {
        Local<Value> error;
        std::string first_path(req_wrap_sync.continuation_data()->first_path());
        FromNamespacedPath(&first_path);
        MaybeLocal<Value> path = StringBytes::Encode(env->isolate(),
                                                     first_path.c_str(),
                                                     UTF8, &error);
        if (path.IsEmpty()) {
          Local<Object> ctx = args[4].As<Object>();
          ctx->Set(env->context(), env->error_string(), error).Check();
          return;
        }
        args.GetReturnValue().Set(path.ToLocalChecked());
      }
    }",17,,1801,2,,void
175926,BLOCK,-1,,"{
        Local<Value> error;
        std::string first_path(req_wrap_sync.continuation_data()->first_path());
        FromNamespacedPath(&first_path);
        MaybeLocal<Value> path = StringBytes::Encode(env->isolate(),
                                                     first_path.c_str(),
                                                     UTF8, &error);
        if (path.IsEmpty()) {
          Local<Object> ctx = args[4].As<Object>();
          ctx->Set(env->context(), env->error_string(), error).Check();
          return;
        }
        args.GetReturnValue().Set(path.ToLocalChecked());
      }",69,,1804,2,,void
175970,BLOCK,-1,,"{
          Local<Object> ctx = args[4].As<Object>();
          ctx->Set(env->context(), env->error_string(), error).Check();
          return;
        }",29,,1811,2,,void
176012,BLOCK,-1,,"{
      SyncCall(env, args[4], &req_wrap_sync, ""mkdir"",
               uv_fs_mkdir, *path, mode);
    }",12,,1818,1,,void
176028,BLOCK,1,,<empty>,,,,9,,void
176044,BLOCK,-1,,<empty>,5,,1822,2,,void
176046,BLOCK,-1,,FS_SYNC_TRACE_END(mkdir),5,,1822,1,,void
176064,BLOCK,-1,,FS_SYNC_TRACE_END(mkdir),5,,1822,2,,void
176092,BLOCK,-1,,FS_SYNC_TRACE_END(mkdir),5,,1822,2,,void
176125,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(isolate, args[0]);
  CHECK_NOT_NULL(*path);

  const enum encoding encoding = ParseEncoding(isolate, args[1], UTF8);

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {  // realpath(path, encoding, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_REALPATH, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""realpath"", encoding, AfterStringPtr,
              uv_fs_realpath, *path);
  } else {  // realpath(path, encoding, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(realpath);
    int err = SyncCall(env, args[3], &req_wrap_sync, ""realpath"",
                       uv_fs_realpath, *path);
    FS_SYNC_TRACE_END(realpath);
    if (err < 0) {
      return;  // syscall failed, no need to continue, error info ...",63,,1826,2,,void
176179,BLOCK,-1,,"{  // realpath(path, encoding, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_REALPATH, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""realpath"", encoding, AfterStringPtr,
              uv_fs_realpath, *path);
  }",34,,1839,2,,void
176188,BLOCK,1,,<empty>,,,,18,,void
176190,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_REALPATH, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1840,1,,void
176208,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_REALPATH, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1840,2,,void
176236,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_REALPATH, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1840,2,,void
176299,BLOCK,-1,,"{  // realpath(path, encoding, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(realpath);
    int err = SyncCall(env, args[3], &req_wrap_sync, ""realpath"",
                       uv_fs_realpath, *path);
    FS_SYNC_TRACE_END(realpath);
    if (err < 0) {
      return;  // syscall failed, no need to continue, error info is in ctx
    }

    const char* link_path = static_cast<const char*>(req_wrap_sync.req.ptr);

    Local<Value> error;
    MaybeLocal<Value> rc = StringBytes::Encode(isolate,
                                               link_path,
                                               encoding,
                                               &error);
    if (rc.IsEmpty()) {
      Local<Object> ctx = args[3].As<Object>();
      ctx->Set(env->context(), env->error_string(), error).Check();
      return;
    }

    args.GetReturnValue().Set(rc.ToLocalChecked());
  }",10,,1844,1,,void
176307,BLOCK,1,,<empty>,,,,9,,void
176323,BLOCK,-1,,<empty>,5,,1847,2,,void
176325,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(realpath),5,,1847,1,,void
176343,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(realpath),5,,1847,2,,void
176371,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(realpath),5,,1847,2,,void
176417,BLOCK,1,,<empty>,,,,9,,void
176433,BLOCK,-1,,<empty>,5,,1850,2,,void
176435,BLOCK,-1,,FS_SYNC_TRACE_END(realpath),5,,1850,1,,void
176453,BLOCK,-1,,FS_SYNC_TRACE_END(realpath),5,,1850,2,,void
176481,BLOCK,-1,,FS_SYNC_TRACE_END(realpath),5,,1850,2,,void
176514,BLOCK,-1,,"{
      return;  // syscall failed, no need to continue, error info is in ctx
    }",18,,1851,2,,void
176551,BLOCK,-1,,"{
      Local<Object> ctx = args[3].As<Object>();
      ctx->Set(env->context(), env->error_string(), error).Check();
      return;
    }",23,,1862,2,,void
176596,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(isolate, args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, path.ToStringView());

  const enum encoding encoding = ParseEncoding(isolate, args[1], UTF8);

  bool with_types = args[2]->IsTrue();

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // readdir(path, encoding, withTypes, req)
    req_wrap_async->set_with_file_types(with_types);
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_SCANDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env,
              req_wrap_async,
              args,
              ""scandir"",
              encoding,
              AfterScanDir,
              uv_fs_scandir,
              *path,
              0 /*flags*/);
  } else {  // readdir(path, encoding, withTypes, un...",62,,1872,2,,void
176670,BLOCK,-1,,"{  // readdir(path, encoding, withTypes, req)
    req_wrap_async->set_with_file_types(with_types);
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_SCANDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env,
              req_wrap_async,
              args,
              ""scandir"",
              encoding,
              AfterScanDir,
              uv_fs_scandir,
              *path,
              0 /*flags*/);
  }",34,,1889,2,,void
176684,BLOCK,1,,<empty>,,,,18,,void
176686,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_SCANDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1891,1,,void
176704,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_SCANDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1891,2,,void
176732,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_SCANDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,1891,2,,void
176796,BLOCK,-1,,"{  // readdir(path, encoding, withTypes, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(readdir);
    int err = SyncCall(env, args[4], &req_wrap_sync, ""scandir"",
                       uv_fs_scandir, *path, 0 /*flags*/);
    FS_SYNC_TRACE_END(readdir);
    if (err < 0) {
      return;  // syscall failed, no need to continue, error info is in ctx
    }

    CHECK_GE(req_wrap_sync.req.result, 0);
    int r;
    std::vector<Local<Value>> name_v;
    std::vector<Local<Value>> type_v;

    for (;;) {
      uv_dirent_t ent;

      r = uv_fs_scandir_next(&(req_wrap_sync.req), &ent);
      if (r == UV_EOF)
        break;
      if (r != 0) {
        Local<Object> ctx = args[4].As<Object>();
        ctx->Set(env->context(), env->errno_string(),
                 Integer::New(isolate, r)).Check();
        ctx->Set(env->context(), env->syscall_string(),
                 OneByteString(isolate, ""readdir"")).Check();
        return;
      }

      Loc...",10,,1902,1,,void
176804,BLOCK,1,,<empty>,,,,9,,void
176820,BLOCK,-1,,<empty>,5,,1905,2,,void
176822,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(readdir),5,,1905,1,,void
176840,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(readdir),5,,1905,2,,void
176868,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(readdir),5,,1905,2,,void
176915,BLOCK,1,,<empty>,,,,9,,void
176931,BLOCK,-1,,<empty>,5,,1908,2,,void
176933,BLOCK,-1,,FS_SYNC_TRACE_END(readdir),5,,1908,1,,void
176951,BLOCK,-1,,FS_SYNC_TRACE_END(readdir),5,,1908,2,,void
176979,BLOCK,-1,,FS_SYNC_TRACE_END(readdir),5,,1908,2,,void
177012,BLOCK,-1,,"{
      return;  // syscall failed, no need to continue, error info is in ctx
    }",18,,1909,2,,void
177041,BLOCK,-1,,<empty>,5,,1918,1,,void
177042,BLOCK,4,,"{
      uv_dirent_t ent;

      r = uv_fs_scandir_next(&(req_wrap_sync.req), &ent);
      if (r == UV_EOF)
        break;
      if (r != 0) {
        Local<Object> ctx = args[4].As<Object>();
        ctx->Set(env->context(), env->errno_string(),
                 Integer::New(isolate, r)).Check();
        ctx->Set(env->context(), env->syscall_string(),
                 OneByteString(isolate, ""readdir"")).Check();
        return;
      }

      Local<Value> error;
      MaybeLocal<Value> filename = StringBytes::Encode(isolate,
                                                       ent.name,
                                                       encoding,
                                                       &error);

      if (filename.IsEmpty()) {
        Local<Object> ctx = args[4].As<Object>();
        ctx->Set(env->context(), env->error_string(), error).Check();
        return;
      }

      name_v.push_back(filename.ToLocalChecked());

      if (with_types) {
        type_v.empl...",14,,1918,4,,void
177057,BLOCK,-1,,<empty>,9,,1923,2,,void
177063,BLOCK,-1,,"{
        Local<Object> ctx = args[4].As<Object>();
        ctx->Set(env->context(), env->errno_string(),
                 Integer::New(isolate, r)).Check();
        ctx->Set(env->context(), env->syscall_string(),
                 OneByteString(isolate, ""readdir"")).Check();
        return;
      }",19,,1924,2,,void
177143,BLOCK,-1,,"{
        Local<Object> ctx = args[4].As<Object>();
        ctx->Set(env->context(), env->error_string(), error).Check();
        return;
      }",31,,1939,2,,void
177183,BLOCK,-1,,"{
        type_v.emplace_back(Integer::New(isolate, ent.type));
      }",23,,1947,2,,void
177217,BLOCK,-1,,"{
      Local<Value> result[] = {
        names,
        Array::New(isolate, type_v.data(), type_v.size())
      };
      args.GetReturnValue().Set(Array::New(isolate, result, arraysize(result)));
    }",21,,1954,2,,void
177252,BLOCK,-1,,"{
      args.GetReturnValue().Set(names);
    }",12,,1960,1,,void
177267,BLOCK,-1,,"{
  // These flags capture the intention of the open() call.
  const int rwflags = flags & (UV_FS_O_RDONLY | UV_FS_O_WRONLY | UV_FS_O_RDWR);

  // These flags have write-like side effects even with O_RDONLY, at least on
  // some operating systems. On Windows, for example, O_RDONLY | O_TEMPORARY
  // can be used to delete a file. Bizarre.
  const int write_as_side_effect = flags & (UV_FS_O_APPEND | UV_FS_O_CREAT |
                                            UV_FS_O_TRUNC | UV_FS_O_TEMPORARY);

  // TODO(rafaelgss): it can be optimized to avoid two permission checks
  auto pathView = path.ToStringView();
  if (rwflags != UV_FS_O_WRONLY) {
    THROW_IF_INSUFFICIENT_PERMISSIONS(
        env,
        permission::PermissionScope::kFileSystemRead,
        pathView,
        Nothing<void>());
  }
  if (rwflags != UV_FS_O_RDONLY || write_as_side_effect) {
    THROW_IF_INSUFFICIENT_PERMISSIONS(
        env,
        permission::PermissionScope::kFileSystemWrite,
        pathView,
        Nothi...",59,,1968,4,,void
177301,BLOCK,-1,,"{
    THROW_IF_INSUFFICIENT_PERMISSIONS(
        env,
        permission::PermissionScope::kFileSystemRead,
        pathView,
        Nothing<void>());
  }",34,,1980,2,,void
177317,BLOCK,-1,,"{
    THROW_IF_INSUFFICIENT_PERMISSIONS(
        env,
        permission::PermissionScope::kFileSystemWrite,
        pathView,
        Nothing<void>());
  }",58,,1987,2,,void
177333,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  auto isolate = env->isolate();

  CHECK_GE(args.Length(), 2);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);

  CHECK(args[1]->IsInt32());
  const int flags = args[1].As<Int32>()->Value();

  if (CheckOpenPermissions(env, path, flags).IsNothing()) return;

  uv_fs_t req;
  auto defer_req_cleanup = OnScopeLeave([&req]() { uv_fs_req_cleanup(&req); });

  FS_SYNC_TRACE_BEGIN(open);
  uv_file file = uv_fs_open(nullptr, &req, *path, flags, 438, nullptr);
  FS_SYNC_TRACE_END(open);
  if (req.result < 0) {
    // req will be cleaned up by scope leave.
    Local<Value> out[] = {
        Integer::New(isolate, req.result),       // errno
        FIXED_ONE_BYTE_STRING(isolate, ""open""),  // syscall
    };
    return args.GetReturnValue().Set(Array::New(isolate, out, arraysize(out)));
  }
  uv_fs_req_cleanup(&req);

  auto defer_close = OnScopeLeave([file]() {
    uv_fs_t close_req;
    CHECK_EQ(0, uv_fs_close(nullpt...",67,,1997,2,,void
177394,BLOCK,-1,,<empty>,59,,2009,2,,void
177404,BLOCK,1,,<empty>,,,,9,,void
177420,BLOCK,-1,,<empty>,3,,2014,2,,void
177422,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(open),3,,2014,1,,void
177440,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(open),3,,2014,2,,void
177468,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(open),3,,2014,2,,void
177511,BLOCK,1,,<empty>,,,,9,,void
177527,BLOCK,-1,,<empty>,3,,2016,2,,void
177529,BLOCK,-1,,FS_SYNC_TRACE_END(open),3,,2016,1,,void
177547,BLOCK,-1,,FS_SYNC_TRACE_END(open),3,,2016,2,,void
177575,BLOCK,-1,,FS_SYNC_TRACE_END(open),3,,2016,2,,void
177610,BLOCK,-1,,"{
    // req will be cleaned up by scope leave.
    Local<Value> out[] = {
        Integer::New(isolate, req.result),       // errno
        FIXED_ONE_BYTE_STRING(isolate, ""open""),  // syscall
    };
    return args.GetReturnValue().Set(Array::New(isolate, out, arraysize(out)));
  }",23,,2017,2,,void
177665,BLOCK,1,,<empty>,,,,9,,void
177681,BLOCK,-1,,<empty>,3,,2037,2,,void
177683,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(read),3,,2037,1,,void
177701,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(read),3,,2037,2,,void
177729,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(read),3,,2037,2,,void
177760,BLOCK,-1,,"{
    auto r = uv_fs_read(nullptr, &req, file, &buf, 1, -1, nullptr);
    if (req.result < 0) {
      FS_SYNC_TRACE_END(read);
      // req will be cleaned up by scope leave.
      Local<Value> out[] = {
          Integer::New(isolate, req.result),       // errno
          FIXED_ONE_BYTE_STRING(isolate, ""read""),  // syscall
      };
      return args.GetReturnValue().Set(
          Array::New(isolate, out, arraysize(out)));
    }
    uv_fs_req_cleanup(&req);
    if (r <= 0) {
      break;
    }
    result.append(buf.base, r);
  }",16,,2038,2,,void
177781,BLOCK,-1,,"{
      FS_SYNC_TRACE_END(read);
      // req will be cleaned up by scope leave.
      Local<Value> out[] = {
          Integer::New(isolate, req.result),       // errno
          FIXED_ONE_BYTE_STRING(isolate, ""read""),  // syscall
      };
      return args.GetReturnValue().Set(
          Array::New(isolate, out, arraysize(out)));
    }",25,,2040,2,,void
177785,BLOCK,1,,<empty>,,,,9,,void
177801,BLOCK,-1,,<empty>,7,,2041,2,,void
177803,BLOCK,-1,,FS_SYNC_TRACE_END(read),7,,2041,1,,void
177821,BLOCK,-1,,FS_SYNC_TRACE_END(read),7,,2041,2,,void
177849,BLOCK,-1,,FS_SYNC_TRACE_END(read),7,,2041,2,,void
177916,BLOCK,-1,,"{
      break;
    }",17,,2051,2,,void
177929,BLOCK,1,,<empty>,,,,9,,void
177945,BLOCK,-1,,<empty>,3,,2056,2,,void
177947,BLOCK,-1,,FS_SYNC_TRACE_END(read),3,,2056,1,,void
177965,BLOCK,-1,,FS_SYNC_TRACE_END(read),3,,2056,2,,void
177993,BLOCK,-1,,FS_SYNC_TRACE_END(read),3,,2056,2,,void
178057,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);

  CHECK(args[1]->IsInt32());
  const int flags = args[1].As<Int32>()->Value();

  CHECK(args[2]->IsInt32());
  const int mode = args[2].As<Int32>()->Value();

  if (CheckOpenPermissions(env, path, flags).IsNothing()) return;

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // open(path, flags, mode, req)
    req_wrap_async->set_is_plain_open(true);
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_OPEN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""open"", UTF8, AfterInteger,
              uv_fs_open, *path, flags, mode);
  } else {  // open(path, flags, mode, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(open);
    int result = SyncCall(env, args[4], &req_wrap_sync, ""open"",
         ...",59,,2065,2,,void
178134,BLOCK,-1,,<empty>,59,,2080,2,,void
178146,BLOCK,-1,,"{  // open(path, flags, mode, req)
    req_wrap_async->set_is_plain_open(true);
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_OPEN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""open"", UTF8, AfterInteger,
              uv_fs_open, *path, flags, mode);
  }",34,,2083,2,,void
178160,BLOCK,1,,<empty>,,,,18,,void
178162,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_OPEN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2085,1,,void
178180,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_OPEN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2085,2,,void
178208,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_OPEN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2085,2,,void
178273,BLOCK,-1,,"{  // open(path, flags, mode, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(open);
    int result = SyncCall(env, args[4], &req_wrap_sync, ""open"",
                          uv_fs_open, *path, flags, mode);
    FS_SYNC_TRACE_END(open);
    if (result >= 0) env->AddUnmanagedFd(result);
    args.GetReturnValue().Set(result);
  }",10,,2089,1,,void
178281,BLOCK,1,,<empty>,,,,9,,void
178297,BLOCK,-1,,<empty>,5,,2092,2,,void
178299,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(open),5,,2092,1,,void
178317,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(open),5,,2092,2,,void
178345,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(open),5,,2092,2,,void
178393,BLOCK,1,,<empty>,,,,9,,void
178409,BLOCK,-1,,<empty>,5,,2095,2,,void
178411,BLOCK,-1,,FS_SYNC_TRACE_END(open),5,,2095,1,,void
178429,BLOCK,-1,,FS_SYNC_TRACE_END(open),5,,2095,2,,void
178457,BLOCK,-1,,FS_SYNC_TRACE_END(open),5,,2095,2,,void
178490,BLOCK,-1,,<empty>,22,,2096,2,,void
178508,BLOCK,-1,,"{
  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
  Environment* env = binding_data->env();
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(isolate, args[0]);
  CHECK_NOT_NULL(*path);

  CHECK(args[1]->IsInt32());
  const int flags = args[1].As<Int32>()->Value();

  CHECK(args[2]->IsInt32());
  const int mode = args[2].As<Int32>()->Value();

  if (CheckOpenPermissions(env, path, flags).IsNothing()) return;

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // openFileHandle(path, flags, mode, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_OPEN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""open"", UTF8, AfterOpenFileHandle,
              uv_fs_open, *path, flags, mode);
  } else {  // openFileHandle(path, flags, mode, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(open);...",69,,2101,2,,void
178598,BLOCK,-1,,<empty>,59,,2118,2,,void
178610,BLOCK,-1,,"{  // openFileHandle(path, flags, mode, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_OPEN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""open"", UTF8, AfterOpenFileHandle,
              uv_fs_open, *path, flags, mode);
  }",34,,2121,2,,void
178619,BLOCK,1,,<empty>,,,,18,,void
178621,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_OPEN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2122,1,,void
178639,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_OPEN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2122,2,,void
178667,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_OPEN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2122,2,,void
178732,BLOCK,-1,,"{  // openFileHandle(path, flags, mode, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(open);
    int result = SyncCall(env, args[4], &req_wrap_sync, ""open"",
                          uv_fs_open, *path, flags, mode);
    FS_SYNC_TRACE_END(open);
    if (result < 0) {
      return;  // syscall failed, no need to continue, error info is in ctx
    }
    FileHandle* fd = FileHandle::New(binding_data, result);
    if (fd == nullptr) return;
    args.GetReturnValue().Set(fd->object());
  }",10,,2126,1,,void
178740,BLOCK,1,,<empty>,,,,9,,void
178756,BLOCK,-1,,<empty>,5,,2129,2,,void
178758,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(open),5,,2129,1,,void
178776,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(open),5,,2129,2,,void
178804,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(open),5,,2129,2,,void
178852,BLOCK,1,,<empty>,,,,9,,void
178868,BLOCK,-1,,<empty>,5,,2132,2,,void
178870,BLOCK,-1,,FS_SYNC_TRACE_END(open),5,,2132,1,,void
178888,BLOCK,-1,,FS_SYNC_TRACE_END(open),5,,2132,2,,void
178916,BLOCK,-1,,FS_SYNC_TRACE_END(open),5,,2132,2,,void
178949,BLOCK,-1,,"{
      return;  // syscall failed, no need to continue, error info is in ctx
    }",21,,2133,2,,void
178964,BLOCK,-1,,<empty>,24,,2137,2,,void
178981,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue src(isolate, args[0]);
  CHECK_NOT_NULL(*src);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, src.ToStringView());

  BufferValue dest(isolate, args[1]);
  CHECK_NOT_NULL(*dest);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, dest.ToStringView());

  CHECK(args[2]->IsInt32());
  const int flags = args[2].As<Int32>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // copyFile(src, dest, flags, req)
    FS_ASYNC_TRACE_BEGIN2(UV_FS_COPYFILE,
                          req_wrap_async,
                          ""src"",
                          TRACE_STR_COPY(*src),
                          ""dest"",
                          TRACE_STR_COPY(*dest))
    AsyncDestCall(env, req_wrap_async, ar...",63,,2142,2,,void
179076,BLOCK,-1,,"{  // copyFile(src, dest, flags, req)
    FS_ASYNC_TRACE_BEGIN2(UV_FS_COPYFILE,
                          req_wrap_async,
                          ""src"",
                          TRACE_STR_COPY(*src),
                          ""dest"",
                          TRACE_STR_COPY(*dest))
    AsyncDestCall(env, req_wrap_async, args, ""copyfile"",
                  *dest, dest.length(), UTF8, AfterNoArgs,
                  uv_fs_copyfile, *src, *dest, flags);
  }",34,,2163,2,,void
179086,BLOCK,1,,<empty>,,,,20,,void
179088,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN2(UV_FS_COPYFILE,
                          req_wrap_async,
                          ""src"",
                          TRACE_STR_COPY(*src),
                          ""dest"",
                          TRACE_STR_COPY(*dest))",5,,2164,1,,void
179106,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN2(UV_FS_COPYFILE,
                          req_wrap_async,
                          ""src"",
                          TRACE_STR_COPY(*src),
                          ""dest"",
                          TRACE_STR_COPY(*dest))",5,,2164,2,,void
179134,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN2(UV_FS_COPYFILE,
                          req_wrap_async,
                          ""src"",
                          TRACE_STR_COPY(*src),
                          ""dest"",
                          TRACE_STR_COPY(*dest))",5,,2164,2,,void
179215,BLOCK,-1,,"{  // copyFile(src, dest, flags, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(copyfile);
    SyncCall(env, args[4], &req_wrap_sync, ""copyfile"",
             uv_fs_copyfile, *src, *dest, flags);
    FS_SYNC_TRACE_END(copyfile);
  }",10,,2173,1,,void
179223,BLOCK,1,,<empty>,,,,9,,void
179239,BLOCK,-1,,<empty>,5,,2176,2,,void
179241,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(copyfile),5,,2176,1,,void
179259,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(copyfile),5,,2176,2,,void
179287,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(copyfile),5,,2176,2,,void
179333,BLOCK,1,,<empty>,,,,9,,void
179349,BLOCK,-1,,<empty>,5,,2179,2,,void
179351,BLOCK,-1,,FS_SYNC_TRACE_END(copyfile),5,,2179,1,,void
179369,BLOCK,-1,,FS_SYNC_TRACE_END(copyfile),5,,2179,2,,void
179397,BLOCK,-1,,FS_SYNC_TRACE_END(copyfile),5,,2179,2,,void
179430,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 4);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  CHECK(Buffer::HasInstance(args[1]));
  Local<Object> buffer_obj = args[1].As<Object>();
  char* buffer_data = Buffer::Data(buffer_obj);
  size_t buffer_length = Buffer::Length(buffer_obj);

  CHECK(IsSafeJsInt(args[2]));
  const int64_t off_64 = args[2].As<Integer>()->Value();
  CHECK_GE(off_64, 0);
  CHECK_LE(static_cast<uint64_t>(off_64), buffer_length);
  const size_t off = static_cast<size_t>(off_64);

  CHECK(args[3]->IsInt32());
  const size_t len = static_cast<size_t>(args[3].As<Int32>()->Value());
  CHECK(Buffer::IsWithinBounds(off, len, buffer_length));
  CHECK_LE(len, buffer_length);
  CHECK_GE(off + len, off);

  const int64_t pos = GetOffset(args[4]);

  char* buf = buffer_data + off;
  uv_buf_t uvbuf = uv_buf_init(buf, len);

  FSReqBase* req_wrap_async = GetReqWrap(args, 5);
  if (r...",66,,2193,2,,void
179601,BLOCK,-1,,"{  // write(fd, buffer, off, len, pos, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_WRITE, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""write"", UTF8, AfterInteger,
              uv_fs_write, fd, &uvbuf, 1, pos);
  }",34,,2225,2,,void
179609,BLOCK,1,,<empty>,,,,16,,void
179611,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_WRITE, req_wrap_async)",5,,2226,1,,void
179629,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_WRITE, req_wrap_async)",5,,2226,2,,void
179657,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_WRITE, req_wrap_async)",5,,2226,2,,void
179714,BLOCK,-1,,"{  // write(fd, buffer, off, len, pos, undefined, ctx)
    CHECK_EQ(argc, 7);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(write);
    int bytesWritten = SyncCall(env, args[6], &req_wrap_sync, ""write"",
                                uv_fs_write, fd, &uvbuf, 1, pos);
    FS_SYNC_TRACE_END(write, ""bytesWritten"", bytesWritten);
    args.GetReturnValue().Set(bytesWritten);
  }",10,,2229,1,,void
179722,BLOCK,1,,<empty>,,,,9,,void
179738,BLOCK,-1,,<empty>,5,,2232,2,,void
179740,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(write),5,,2232,1,,void
179758,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(write),5,,2232,2,,void
179786,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(write),5,,2232,2,,void
179835,BLOCK,1,,<empty>,,,,10,,void
179851,BLOCK,-1,,<empty>,5,,2235,2,,void
179853,BLOCK,-1,,"FS_SYNC_TRACE_END(write, ""bytesWritten"", bytesWritten)",5,,2235,1,,void
179871,BLOCK,-1,,"FS_SYNC_TRACE_END(write, ""bytesWritten"", bytesWritten)",5,,2235,2,,void
179899,BLOCK,-1,,"FS_SYNC_TRACE_END(write, ""bytesWritten"", bytesWritten)",5,,2235,2,,void
179942,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  CHECK(args[1]->IsArray());
  Local<Array> chunks = args[1].As<Array>();

  int64_t pos = GetOffset(args[2]);

  MaybeStackBuffer<uv_buf_t> iovs(chunks->Length());

  for (uint32_t i = 0; i < iovs.length(); i++) {
    Local<Value> chunk = chunks->Get(env->context(), i).ToLocalChecked();
    CHECK(Buffer::HasInstance(chunk));
    iovs[i] = uv_buf_init(Buffer::Data(chunk), Buffer::Length(chunk));
  }

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // writeBuffers(fd, chunks, pos, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_WRITE, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""write"", UTF8, AfterInteger,
              uv_fs_write, fd, *iovs, iovs.length(), pos);
  } else {  // writeBuffers(fd, chunks, pos, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWra...",67,,2248,2,,void
180016,BLOCK,-1,,<empty>,3,,2264,1,,void
180029,BLOCK,4,,"{
    Local<Value> chunk = chunks->Get(env->context(), i).ToLocalChecked();
    CHECK(Buffer::HasInstance(chunk));
    iovs[i] = uv_buf_init(Buffer::Data(chunk), Buffer::Length(chunk));
  }",48,,2264,4,,void
180079,BLOCK,-1,,"{  // writeBuffers(fd, chunks, pos, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_WRITE, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""write"", UTF8, AfterInteger,
              uv_fs_write, fd, *iovs, iovs.length(), pos);
  }",34,,2271,2,,void
180087,BLOCK,1,,<empty>,,,,16,,void
180089,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_WRITE, req_wrap_async)",5,,2272,1,,void
180107,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_WRITE, req_wrap_async)",5,,2272,2,,void
180135,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_WRITE, req_wrap_async)",5,,2272,2,,void
180195,BLOCK,-1,,"{  // writeBuffers(fd, chunks, pos, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(write);
    int bytesWritten = SyncCall(env, args[4], &req_wrap_sync, ""write"",
                                uv_fs_write, fd, *iovs, iovs.length(), pos);
    FS_SYNC_TRACE_END(write, ""bytesWritten"", bytesWritten);
    args.GetReturnValue().Set(bytesWritten);
  }",10,,2275,1,,void
180203,BLOCK,1,,<empty>,,,,9,,void
180219,BLOCK,-1,,<empty>,5,,2278,2,,void
180221,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(write),5,,2278,1,,void
180239,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(write),5,,2278,2,,void
180267,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(write),5,,2278,2,,void
180319,BLOCK,1,,<empty>,,,,10,,void
180335,BLOCK,-1,,<empty>,5,,2281,2,,void
180337,BLOCK,-1,,"FS_SYNC_TRACE_END(write, ""bytesWritten"", bytesWritten)",5,,2281,1,,void
180355,BLOCK,-1,,"FS_SYNC_TRACE_END(write, ""bytesWritten"", bytesWritten)",5,,2281,2,,void
180383,BLOCK,-1,,"FS_SYNC_TRACE_END(write, ""bytesWritten"", bytesWritten)",5,,2281,2,,void
180426,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 4);
  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  const int64_t pos = GetOffset(args[2]);

  const auto enc = ParseEncoding(isolate, args[3], UTF8);

  Local<Value> value = args[1];
  char* buf = nullptr;
  size_t len;

  FSReqBase* req_wrap_async = GetReqWrap(args, 4);
  const bool is_async = req_wrap_async != nullptr;

  // Avoid copying the string when it is externalized but only when:
  // 1. The target encoding is compatible with the string's encoding, and
  // 2. The write is synchronous, otherwise the string might get neutered
  //    while the request is in flight, and
  // 3. For UCS2, when the host system is little-endian.  Big-endian systems
  //    need to call StringBytes::Write() to ensure proper byte swapping.
  // The const_casts are conceptually sound: memory is read but not written.
  if (!is...",66,,2295,2,,void
180521,BLOCK,-1,,"{
    auto string = value.As<String>();
    if ((enc == ASCII || enc == LATIN1) && string->IsExternalOneByte()) {
      auto ext = string->GetExternalOneByteStringResource();
      buf = const_cast<char*>(ext->data());
      len = ext->length();
    } else if (enc == UCS2 && IsLittleEndian() && string->IsExternalTwoByte()) {
      auto ext = string->GetExternalStringResource();
      buf = reinterpret_cast<char*>(const_cast<uint16_t*>(ext->data()));
      len = ext->length() * sizeof(*ext->data());
    }
  }",39,,2322,2,,void
180542,BLOCK,-1,,"{
      auto ext = string->GetExternalOneByteStringResource();
      buf = const_cast<char*>(ext->data());
      len = ext->length();
    }",73,,2324,2,,void
180565,BLOCK,-1,,<empty>,12,,2328,1,,void
180577,BLOCK,-1,,"{
      auto ext = string->GetExternalStringResource();
      buf = reinterpret_cast<char*>(const_cast<uint16_t*>(ext->data()));
      len = ext->length() * sizeof(*ext->data());
    }",80,,2328,2,,void
180610,BLOCK,-1,,"{  // write(fd, string, pos, enc, req)
    CHECK_NOT_NULL(req_wrap_async);
    if (!StringBytes::StorageSize(isolate, value, enc).To(&len)) return;
    FSReqBase::FSReqBuffer& stack_buffer =
        req_wrap_async->Init(""write"", len, enc);
    // StorageSize may return too large a char, so correct the actual length
    // by the write size
    len = StringBytes::Write(isolate, *stack_buffer, len, args[1], enc);
    stack_buffer.SetLengthAndZeroTerminate(len);
    uv_buf_t uvbuf = uv_buf_init(*stack_buffer, len);
    FS_ASYNC_TRACE_BEGIN0(UV_FS_WRITE, req_wrap_async)
    int err = req_wrap_async->Dispatch(uv_fs_write,
                                       fd,
                                       &uvbuf,
                                       1,
                                       pos,
                                       AfterInteger);
    if (err < 0) {
      uv_fs_t* uv_req = req_wrap_async->req();
      uv_req->result = err;
      uv_req->path = nullptr;
      AfterInteger...",17,,2335,2,,void
180627,BLOCK,-1,,<empty>,66,,2337,2,,void
180672,BLOCK,1,,<empty>,,,,16,,void
180674,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_WRITE, req_wrap_async)",5,,2345,1,,void
180692,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_WRITE, req_wrap_async)",5,,2345,2,,void
180720,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_WRITE, req_wrap_async)",5,,2345,2,,void
180781,BLOCK,-1,,"{
      uv_fs_t* uv_req = req_wrap_async->req();
      uv_req->result = err;
      uv_req->path = nullptr;
      AfterInteger(uv_req);  // after may delete req_wrap_async if there is
                             // an error
    }",18,,2352,2,,void
180802,BLOCK,-1,,"{
      req_wrap_async->SetReturnValue(args);
    }",12,,2358,1,,void
180809,BLOCK,-1,,"{  // write(fd, string, pos, enc, undefined, ctx)
    CHECK_EQ(argc, 6);
    FSReqWrapSync req_wrap_sync;
    FSReqBase::FSReqBuffer stack_buffer;
    if (buf == nullptr) {
      if (!StringBytes::StorageSize(isolate, value, enc).To(&len))
        return;
      stack_buffer.AllocateSufficientStorage(len + 1);
      // StorageSize may return too large a char, so correct the actual length
      // by the write size
      len = StringBytes::Write(isolate, *stack_buffer,
                               len, args[1], enc);
      stack_buffer.SetLengthAndZeroTerminate(len);
      buf = *stack_buffer;
    }
    uv_buf_t uvbuf = uv_buf_init(buf, len);
    FS_SYNC_TRACE_BEGIN(write);
    int bytesWritten = SyncCall(env, args[5], &req_wrap_sync, ""write"",
                                uv_fs_write, fd, &uvbuf, 1, pos);
    FS_SYNC_TRACE_END(write, ""bytesWritten"", bytesWritten);
    args.GetReturnValue().Set(bytesWritten);
  }",10,,2361,1,,void
180819,BLOCK,-1,,"{
      if (!StringBytes::StorageSize(isolate, value, enc).To(&len))
        return;
      stack_buffer.AllocateSufficientStorage(len + 1);
      // StorageSize may return too large a char, so correct the actual length
      // by the write size
      len = StringBytes::Write(isolate, *stack_buffer,
                               len, args[1], enc);
      stack_buffer.SetLengthAndZeroTerminate(len);
      buf = *stack_buffer;
    }",25,,2365,2,,void
180834,BLOCK,-1,,<empty>,9,,2367,2,,void
180875,BLOCK,1,,<empty>,,,,9,,void
180891,BLOCK,-1,,<empty>,5,,2377,2,,void
180893,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(write),5,,2377,1,,void
180911,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(write),5,,2377,2,,void
180939,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(write),5,,2377,2,,void
180988,BLOCK,1,,<empty>,,,,10,,void
181004,BLOCK,-1,,<empty>,5,,2380,2,,void
181006,BLOCK,-1,,"FS_SYNC_TRACE_END(write, ""bytesWritten"", bytesWritten)",5,,2380,1,,void
181024,BLOCK,-1,,"FS_SYNC_TRACE_END(write, ""bytesWritten"", bytesWritten)",5,,2380,2,,void
181052,BLOCK,-1,,"FS_SYNC_TRACE_END(write, ""bytesWritten"", bytesWritten)",5,,2380,2,,void
181095,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 5);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  CHECK(Buffer::HasInstance(args[1]));
  Local<Object> buffer_obj = args[1].As<Object>();
  char* buffer_data = Buffer::Data(buffer_obj);
  size_t buffer_length = Buffer::Length(buffer_obj);

  CHECK(IsSafeJsInt(args[2]));
  const int64_t off_64 = args[2].As<Integer>()->Value();
  CHECK_GE(off_64, 0);
  CHECK_LT(static_cast<uint64_t>(off_64), buffer_length);
  const size_t off = static_cast<size_t>(off_64);

  CHECK(args[3]->IsInt32());
  const size_t len = static_cast<size_t>(args[3].As<Int32>()->Value());
  CHECK(Buffer::IsWithinBounds(off, len, buffer_length));

  CHECK(IsSafeJsInt(args[4]) || args[4]->IsBigInt());
  const int64_t pos = args[4]->IsNumber() ?
                      args[4].As<Integer>()->Value() :
                      args[4].As<BigInt>()->Int64Value();

  char* buf = buffer_data...",59,,2397,2,,void
181291,BLOCK,-1,,"{  // read(fd, buffer, offset, len, pos, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_READ, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""read"", UTF8, AfterInteger,
              uv_fs_read, fd, &uvbuf, 1, pos);
  }",34,,2430,2,,void
181299,BLOCK,1,,<empty>,,,,16,,void
181301,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_READ, req_wrap_async)",5,,2431,1,,void
181319,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_READ, req_wrap_async)",5,,2431,2,,void
181347,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_READ, req_wrap_async)",5,,2431,2,,void
181404,BLOCK,-1,,"{  // read(fd, buffer, offset, len, pos, undefined, ctx)
    CHECK_EQ(argc, 7);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(read);
    const int bytesRead = SyncCall(env, args[6], &req_wrap_sync, ""read"",
                                   uv_fs_read, fd, &uvbuf, 1, pos);
    FS_SYNC_TRACE_END(read, ""bytesRead"", bytesRead);
    args.GetReturnValue().Set(bytesRead);
  }",10,,2434,1,,void
181412,BLOCK,1,,<empty>,,,,9,,void
181428,BLOCK,-1,,<empty>,5,,2437,2,,void
181430,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(read),5,,2437,1,,void
181448,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(read),5,,2437,2,,void
181476,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(read),5,,2437,2,,void
181525,BLOCK,1,,<empty>,,,,10,,void
181541,BLOCK,-1,,<empty>,5,,2440,2,,void
181543,BLOCK,-1,,"FS_SYNC_TRACE_END(read, ""bytesRead"", bytesRead)",5,,2440,1,,void
181561,BLOCK,-1,,"FS_SYNC_TRACE_END(read, ""bytesRead"", bytesRead)",5,,2440,2,,void
181589,BLOCK,-1,,"FS_SYNC_TRACE_END(read, ""bytesRead"", bytesRead)",5,,2440,2,,void
181632,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  CHECK(args[1]->IsArray());
  Local<Array> buffers = args[1].As<Array>();

  int64_t pos = GetOffset(args[2]);  // -1 if not a valid JS int

  MaybeStackBuffer<uv_buf_t> iovs(buffers->Length());

  // Init uv buffers from ArrayBufferViews
  for (uint32_t i = 0; i < iovs.length(); i++) {
    Local<Value> buffer = buffers->Get(env->context(), i).ToLocalChecked();
    CHECK(Buffer::HasInstance(buffer));
    iovs[i] = uv_buf_init(Buffer::Data(buffer), Buffer::Length(buffer));
  }

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // readBuffers(fd, buffers, pos, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_READ, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""read"", UTF8, AfterInteger,
              uv_fs_read, fd, *iovs, iovs.length(), pos);
  } else {  // readB...",66,,2453,2,,void
181706,BLOCK,-1,,<empty>,3,,2470,1,,void
181719,BLOCK,4,,"{
    Local<Value> buffer = buffers->Get(env->context(), i).ToLocalChecked();
    CHECK(Buffer::HasInstance(buffer));
    iovs[i] = uv_buf_init(Buffer::Data(buffer), Buffer::Length(buffer));
  }",48,,2470,4,,void
181769,BLOCK,-1,,"{  // readBuffers(fd, buffers, pos, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_READ, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""read"", UTF8, AfterInteger,
              uv_fs_read, fd, *iovs, iovs.length(), pos);
  }",34,,2477,2,,void
181777,BLOCK,1,,<empty>,,,,16,,void
181779,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_READ, req_wrap_async)",5,,2478,1,,void
181797,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_READ, req_wrap_async)",5,,2478,2,,void
181825,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_READ, req_wrap_async)",5,,2478,2,,void
181885,BLOCK,-1,,"{  // readBuffers(fd, buffers, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(read);
    int bytesRead = SyncCall(env, /* ctx */ args[4], &req_wrap_sync, ""read"",
                             uv_fs_read, fd, *iovs, iovs.length(), pos);
    FS_SYNC_TRACE_END(read, ""bytesRead"", bytesRead);
    args.GetReturnValue().Set(bytesRead);
  }",10,,2481,1,,void
181893,BLOCK,1,,<empty>,,,,9,,void
181909,BLOCK,-1,,<empty>,5,,2484,2,,void
181911,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(read),5,,2484,1,,void
181929,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(read),5,,2484,2,,void
181957,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(read),5,,2484,2,,void
182009,BLOCK,1,,<empty>,,,,10,,void
182025,BLOCK,-1,,<empty>,5,,2487,2,,void
182027,BLOCK,-1,,"FS_SYNC_TRACE_END(read, ""bytesRead"", bytesRead)",5,,2487,1,,void
182045,BLOCK,-1,,"FS_SYNC_TRACE_END(read, ""bytesRead"", bytesRead)",5,,2487,2,,void
182073,BLOCK,-1,,"FS_SYNC_TRACE_END(read, ""bytesRead"", bytesRead)",5,,2487,2,,void
182116,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, path.ToStringView());

  CHECK(args[1]->IsInt32());
  int mode = args[1].As<Int32>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {  // chmod(path, mode, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_CHMOD, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""chmod"", UTF8, AfterNoArgs,
              uv_fs_chmod, *path, mode);
  } else {  // chmod(path, mode, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(chmod);
    SyncCall(env, args[3], &req_wrap_sync, ""chmod"",
             uv_fs_chmod, *path, mode);
    FS_SYNC_TRACE_END(chmod);
  }
}",60,,2496,2,,void
182187,BLOCK,-1,,"{  // chmod(path, mode, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_CHMOD, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""chmod"", UTF8, AfterNoArgs,
              uv_fs_chmod, *path, mode);
  }",34,,2511,2,,void
182196,BLOCK,1,,<empty>,,,,18,,void
182198,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_CHMOD, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2512,1,,void
182216,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_CHMOD, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2512,2,,void
182244,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_CHMOD, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2512,2,,void
182308,BLOCK,-1,,"{  // chmod(path, mode, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(chmod);
    SyncCall(env, args[3], &req_wrap_sync, ""chmod"",
             uv_fs_chmod, *path, mode);
    FS_SYNC_TRACE_END(chmod);
  }",10,,2516,1,,void
182316,BLOCK,1,,<empty>,,,,9,,void
182332,BLOCK,-1,,<empty>,5,,2519,2,,void
182334,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(chmod),5,,2519,1,,void
182352,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(chmod),5,,2519,2,,void
182380,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(chmod),5,,2519,2,,void
182424,BLOCK,1,,<empty>,,,,9,,void
182440,BLOCK,-1,,<empty>,5,,2522,2,,void
182442,BLOCK,-1,,FS_SYNC_TRACE_END(chmod),5,,2522,1,,void
182460,BLOCK,-1,,FS_SYNC_TRACE_END(chmod),5,,2522,2,,void
182488,BLOCK,-1,,FS_SYNC_TRACE_END(chmod),5,,2522,2,,void
182521,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  CHECK(args[1]->IsInt32());
  const int mode = args[1].As<Int32>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {  // fchmod(fd, mode, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FCHMOD, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""fchmod"", UTF8, AfterNoArgs,
              uv_fs_fchmod, fd, mode);
  } else {  // fchmod(fd, mode, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(fchmod);
    SyncCall(env, args[3], &req_wrap_sync, ""fchmod"",
             uv_fs_fchmod, fd, mode);
    FS_SYNC_TRACE_END(fchmod);
  }
}",61,,2530,2,,void
182588,BLOCK,-1,,"{  // fchmod(fd, mode, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FCHMOD, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""fchmod"", UTF8, AfterNoArgs,
              uv_fs_fchmod, fd, mode);
  }",34,,2543,2,,void
182596,BLOCK,1,,<empty>,,,,16,,void
182598,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FCHMOD, req_wrap_async)",5,,2544,1,,void
182616,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FCHMOD, req_wrap_async)",5,,2544,2,,void
182644,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FCHMOD, req_wrap_async)",5,,2544,2,,void
182698,BLOCK,-1,,"{  // fchmod(fd, mode, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(fchmod);
    SyncCall(env, args[3], &req_wrap_sync, ""fchmod"",
             uv_fs_fchmod, fd, mode);
    FS_SYNC_TRACE_END(fchmod);
  }",10,,2547,1,,void
182706,BLOCK,1,,<empty>,,,,9,,void
182722,BLOCK,-1,,<empty>,5,,2550,2,,void
182724,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(fchmod),5,,2550,1,,void
182742,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(fchmod),5,,2550,2,,void
182770,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(fchmod),5,,2550,2,,void
182813,BLOCK,1,,<empty>,,,,9,,void
182829,BLOCK,-1,,<empty>,5,,2553,2,,void
182831,BLOCK,-1,,FS_SYNC_TRACE_END(fchmod),5,,2553,1,,void
182849,BLOCK,-1,,FS_SYNC_TRACE_END(fchmod),5,,2553,2,,void
182877,BLOCK,-1,,FS_SYNC_TRACE_END(fchmod),5,,2553,2,,void
182910,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, path.ToStringView());

  CHECK(IsSafeJsInt(args[1]));
  const uv_uid_t uid = static_cast<uv_uid_t>(args[1].As<Integer>()->Value());

  CHECK(IsSafeJsInt(args[2]));
  const uv_gid_t gid = static_cast<uv_gid_t>(args[2].As<Integer>()->Value());

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // chown(path, uid, gid, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_CHOWN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""chown"", UTF8, AfterNoArgs,
              uv_fs_chown, *path, uid, gid);
  } else {  // chown(path, uid, gid, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(chown);
    SyncCal...",60,,2561,2,,void
183000,BLOCK,-1,,"{  // chown(path, uid, gid, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_CHOWN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""chown"", UTF8, AfterNoArgs,
              uv_fs_chown, *path, uid, gid);
  }",34,,2579,2,,void
183009,BLOCK,1,,<empty>,,,,18,,void
183011,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_CHOWN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2580,1,,void
183029,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_CHOWN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2580,2,,void
183057,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_CHOWN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2580,2,,void
183122,BLOCK,-1,,"{  // chown(path, uid, gid, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(chown);
    SyncCall(env, args[4], &req_wrap_sync, ""chown"",
             uv_fs_chown, *path, uid, gid);
    FS_SYNC_TRACE_END(chown);
  }",10,,2584,1,,void
183130,BLOCK,1,,<empty>,,,,9,,void
183146,BLOCK,-1,,<empty>,5,,2587,2,,void
183148,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(chown),5,,2587,1,,void
183166,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(chown),5,,2587,2,,void
183194,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(chown),5,,2587,2,,void
183239,BLOCK,1,,<empty>,,,,9,,void
183255,BLOCK,-1,,<empty>,5,,2590,2,,void
183257,BLOCK,-1,,FS_SYNC_TRACE_END(chown),5,,2590,1,,void
183275,BLOCK,-1,,FS_SYNC_TRACE_END(chown),5,,2590,2,,void
183303,BLOCK,-1,,FS_SYNC_TRACE_END(chown),5,,2590,2,,void
183336,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  CHECK(IsSafeJsInt(args[1]));
  const uv_uid_t uid = static_cast<uv_uid_t>(args[1].As<Integer>()->Value());

  CHECK(IsSafeJsInt(args[2]));
  const uv_gid_t gid = static_cast<uv_gid_t>(args[2].As<Integer>()->Value());

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // fchown(fd, uid, gid, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FCHOWN, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""fchown"", UTF8, AfterNoArgs,
              uv_fs_fchown, fd, uid, gid);
  } else {  // fchown(fd, uid, gid, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(fchown);
    SyncCall(env, args[4], &req_wrap_sync, ""fchown"",
             uv_fs_fchown, fd, uid, gid);
    FS_SYNC_TRACE_END(fchown);
  }
}",61,,2598,2,,void
183422,BLOCK,-1,,"{  // fchown(fd, uid, gid, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FCHOWN, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""fchown"", UTF8, AfterNoArgs,
              uv_fs_fchown, fd, uid, gid);
  }",34,,2614,2,,void
183430,BLOCK,1,,<empty>,,,,16,,void
183432,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FCHOWN, req_wrap_async)",5,,2615,1,,void
183450,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FCHOWN, req_wrap_async)",5,,2615,2,,void
183478,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FCHOWN, req_wrap_async)",5,,2615,2,,void
183533,BLOCK,-1,,"{  // fchown(fd, uid, gid, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(fchown);
    SyncCall(env, args[4], &req_wrap_sync, ""fchown"",
             uv_fs_fchown, fd, uid, gid);
    FS_SYNC_TRACE_END(fchown);
  }",10,,2618,1,,void
183541,BLOCK,1,,<empty>,,,,9,,void
183557,BLOCK,-1,,<empty>,5,,2621,2,,void
183559,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(fchown),5,,2621,1,,void
183577,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(fchown),5,,2621,2,,void
183605,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(fchown),5,,2621,2,,void
183649,BLOCK,1,,<empty>,,,,9,,void
183665,BLOCK,-1,,<empty>,5,,2624,2,,void
183667,BLOCK,-1,,FS_SYNC_TRACE_END(fchown),5,,2624,1,,void
183685,BLOCK,-1,,FS_SYNC_TRACE_END(fchown),5,,2624,2,,void
183713,BLOCK,-1,,FS_SYNC_TRACE_END(fchown),5,,2624,2,,void
183746,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, path.ToStringView());

  CHECK(IsSafeJsInt(args[1]));
  const uv_uid_t uid = static_cast<uv_uid_t>(args[1].As<Integer>()->Value());

  CHECK(IsSafeJsInt(args[2]));
  const uv_gid_t gid = static_cast<uv_gid_t>(args[2].As<Integer>()->Value());

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // lchown(path, uid, gid, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LCHOWN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""lchown"", UTF8, AfterNoArgs,
              uv_fs_lchown, *path, uid, gid);
  } else {  // lchown(path, uid, gid, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(lchown);
    S...",61,,2629,2,,void
183836,BLOCK,-1,,"{  // lchown(path, uid, gid, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LCHOWN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""lchown"", UTF8, AfterNoArgs,
              uv_fs_lchown, *path, uid, gid);
  }",34,,2647,2,,void
183845,BLOCK,1,,<empty>,,,,18,,void
183847,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LCHOWN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2648,1,,void
183865,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LCHOWN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2648,2,,void
183893,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LCHOWN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2648,2,,void
183958,BLOCK,-1,,"{  // lchown(path, uid, gid, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(lchown);
    SyncCall(env, args[4], &req_wrap_sync, ""lchown"",
             uv_fs_lchown, *path, uid, gid);
    FS_SYNC_TRACE_END(lchown);
  }",10,,2652,1,,void
183966,BLOCK,1,,<empty>,,,,9,,void
183982,BLOCK,-1,,<empty>,5,,2655,2,,void
183984,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(lchown),5,,2655,1,,void
184002,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(lchown),5,,2655,2,,void
184030,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(lchown),5,,2655,2,,void
184075,BLOCK,1,,<empty>,,,,9,,void
184091,BLOCK,-1,,<empty>,5,,2658,2,,void
184093,BLOCK,-1,,FS_SYNC_TRACE_END(lchown),5,,2658,1,,void
184111,BLOCK,-1,,FS_SYNC_TRACE_END(lchown),5,,2658,2,,void
184139,BLOCK,-1,,FS_SYNC_TRACE_END(lchown),5,,2658,2,,void
184172,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, path.ToStringView());

  CHECK(args[1]->IsNumber());
  const double atime = args[1].As<Number>()->Value();

  CHECK(args[2]->IsNumber());
  const double mtime = args[2].As<Number>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // utimes(path, atime, mtime, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UTIME, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""utime"", UTF8, AfterNoArgs,
              uv_fs_utime, *path, atime, mtime);
  } else {  // utimes(path, atime, mtime, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(utimes);
    SyncCall(env, args[4], &req_wrap_sync, ""ut...",61,,2663,2,,void
184262,BLOCK,-1,,"{  // utimes(path, atime, mtime, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UTIME, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""utime"", UTF8, AfterNoArgs,
              uv_fs_utime, *path, atime, mtime);
  }",34,,2681,2,,void
184271,BLOCK,1,,<empty>,,,,18,,void
184273,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UTIME, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2682,1,,void
184291,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UTIME, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2682,2,,void
184319,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UTIME, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2682,2,,void
184384,BLOCK,-1,,"{  // utimes(path, atime, mtime, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(utimes);
    SyncCall(env, args[4], &req_wrap_sync, ""utime"",
             uv_fs_utime, *path, atime, mtime);
    FS_SYNC_TRACE_END(utimes);
  }",10,,2686,1,,void
184392,BLOCK,1,,<empty>,,,,9,,void
184408,BLOCK,-1,,<empty>,5,,2689,2,,void
184410,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(utimes),5,,2689,1,,void
184428,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(utimes),5,,2689,2,,void
184456,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(utimes),5,,2689,2,,void
184501,BLOCK,1,,<empty>,,,,9,,void
184517,BLOCK,-1,,<empty>,5,,2692,2,,void
184519,BLOCK,-1,,FS_SYNC_TRACE_END(utimes),5,,2692,1,,void
184537,BLOCK,-1,,FS_SYNC_TRACE_END(utimes),5,,2692,2,,void
184565,BLOCK,-1,,FS_SYNC_TRACE_END(utimes),5,,2692,2,,void
184598,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  CHECK(args[1]->IsNumber());
  const double atime = args[1].As<Number>()->Value();

  CHECK(args[2]->IsNumber());
  const double mtime = args[2].As<Number>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // futimes(fd, atime, mtime, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FUTIME, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""futime"", UTF8, AfterNoArgs,
              uv_fs_futime, fd, atime, mtime);
  } else {  // futimes(fd, atime, mtime, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(futimes);
    SyncCall(env, args[4], &req_wrap_sync, ""futime"",
             uv_fs_futime, fd, atime, mtime);
    FS_SYNC_TRACE_END(futimes);
  }
}",62,,2696,2,,void
184684,BLOCK,-1,,"{  // futimes(fd, atime, mtime, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FUTIME, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""futime"", UTF8, AfterNoArgs,
              uv_fs_futime, fd, atime, mtime);
  }",34,,2712,2,,void
184692,BLOCK,1,,<empty>,,,,16,,void
184694,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FUTIME, req_wrap_async)",5,,2713,1,,void
184712,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FUTIME, req_wrap_async)",5,,2713,2,,void
184740,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN0(UV_FS_FUTIME, req_wrap_async)",5,,2713,2,,void
184795,BLOCK,-1,,"{  // futimes(fd, atime, mtime, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(futimes);
    SyncCall(env, args[4], &req_wrap_sync, ""futime"",
             uv_fs_futime, fd, atime, mtime);
    FS_SYNC_TRACE_END(futimes);
  }",10,,2716,1,,void
184803,BLOCK,1,,<empty>,,,,9,,void
184819,BLOCK,-1,,<empty>,5,,2719,2,,void
184821,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(futimes),5,,2719,1,,void
184839,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(futimes),5,,2719,2,,void
184867,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(futimes),5,,2719,2,,void
184911,BLOCK,1,,<empty>,,,,9,,void
184927,BLOCK,-1,,<empty>,5,,2722,2,,void
184929,BLOCK,-1,,FS_SYNC_TRACE_END(futimes),5,,2722,1,,void
184947,BLOCK,-1,,FS_SYNC_TRACE_END(futimes),5,,2722,2,,void
184975,BLOCK,-1,,FS_SYNC_TRACE_END(futimes),5,,2722,2,,void
185008,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, path.ToStringView());

  CHECK(args[1]->IsNumber());
  const double atime = args[1].As<Number>()->Value();

  CHECK(args[2]->IsNumber());
  const double mtime = args[2].As<Number>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // lutimes(path, atime, mtime, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LUTIME, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""lutime"", UTF8, AfterNoArgs,
              uv_fs_lutime, *path, atime, mtime);
  } else {  // lutimes(path, atime, mtime, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(lutimes);
    SyncCall(env, args[4], &req_wrap_syn...",62,,2726,2,,void
185098,BLOCK,-1,,"{  // lutimes(path, atime, mtime, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LUTIME, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""lutime"", UTF8, AfterNoArgs,
              uv_fs_lutime, *path, atime, mtime);
  }",34,,2744,2,,void
185107,BLOCK,1,,<empty>,,,,18,,void
185109,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LUTIME, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2745,1,,void
185127,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LUTIME, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2745,2,,void
185155,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LUTIME, req_wrap_async, ""path"", TRACE_STR_COPY(*path))",5,,2745,2,,void
185220,BLOCK,-1,,"{  // lutimes(path, atime, mtime, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(lutimes);
    SyncCall(env, args[4], &req_wrap_sync, ""lutime"",
             uv_fs_lutime, *path, atime, mtime);
    FS_SYNC_TRACE_END(lutimes);
  }",10,,2749,1,,void
185228,BLOCK,1,,<empty>,,,,9,,void
185244,BLOCK,-1,,<empty>,5,,2752,2,,void
185246,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(lutimes),5,,2752,1,,void
185264,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(lutimes),5,,2752,2,,void
185292,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(lutimes),5,,2752,2,,void
185337,BLOCK,1,,<empty>,,,,9,,void
185353,BLOCK,-1,,<empty>,5,,2755,2,,void
185355,BLOCK,-1,,FS_SYNC_TRACE_END(lutimes),5,,2755,1,,void
185373,BLOCK,-1,,FS_SYNC_TRACE_END(lutimes),5,,2755,2,,void
185401,BLOCK,-1,,FS_SYNC_TRACE_END(lutimes),5,,2755,2,,void
185434,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  BufferValue tmpl(isolate, args[0]);
  CHECK_NOT_NULL(*tmpl);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, tmpl.ToStringView());

  const enum encoding encoding = ParseEncoding(isolate, args[1], UTF8);

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {  // mkdtemp(tmpl, encoding, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_MKDTEMP, req_wrap_async, ""path"", TRACE_STR_COPY(*tmpl))
    AsyncCall(env, req_wrap_async, args, ""mkdtemp"", encoding, AfterStringPath,
              uv_fs_mkdtemp, *tmpl);
  } else {  // mkdtemp(tmpl, encoding, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(mkdtemp);
    SyncCall(env, args[3], &req_wrap_sync, ""mkdtemp"",
             uv_fs_mkdtemp, *tmpl);
    FS_SYNC_TRACE_END(mkdtem...",62,,2759,2,,void
185499,BLOCK,-1,,"{  // mkdtemp(tmpl, encoding, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_MKDTEMP, req_wrap_async, ""path"", TRACE_STR_COPY(*tmpl))
    AsyncCall(env, req_wrap_async, args, ""mkdtemp"", encoding, AfterStringPath,
              uv_fs_mkdtemp, *tmpl);
  }",34,,2774,2,,void
185508,BLOCK,1,,<empty>,,,,18,,void
185510,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_MKDTEMP, req_wrap_async, ""path"", TRACE_STR_COPY(*tmpl))",5,,2775,1,,void
185528,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_MKDTEMP, req_wrap_async, ""path"", TRACE_STR_COPY(*tmpl))",5,,2775,2,,void
185556,BLOCK,-1,,"FS_ASYNC_TRACE_BEGIN1(
        UV_FS_MKDTEMP, req_wrap_async, ""path"", TRACE_STR_COPY(*tmpl))",5,,2775,2,,void
185619,BLOCK,-1,,"{  // mkdtemp(tmpl, encoding, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(mkdtemp);
    SyncCall(env, args[3], &req_wrap_sync, ""mkdtemp"",
             uv_fs_mkdtemp, *tmpl);
    FS_SYNC_TRACE_END(mkdtemp);
    const char* path = req_wrap_sync.req.path;

    Local<Value> error;
    MaybeLocal<Value> rc =
        StringBytes::Encode(isolate, path, encoding, &error);
    if (rc.IsEmpty()) {
      Local<Object> ctx = args[3].As<Object>();
      ctx->Set(env->context(), env->error_string(), error).Check();
      return;
    }
    args.GetReturnValue().Set(rc.ToLocalChecked());
  }",10,,2779,1,,void
185627,BLOCK,1,,<empty>,,,,9,,void
185643,BLOCK,-1,,<empty>,5,,2782,2,,void
185645,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(mkdtemp),5,,2782,1,,void
185663,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(mkdtemp),5,,2782,2,,void
185691,BLOCK,-1,,FS_SYNC_TRACE_BEGIN(mkdtemp),5,,2782,2,,void
185734,BLOCK,1,,<empty>,,,,9,,void
185750,BLOCK,-1,,<empty>,5,,2785,2,,void
185752,BLOCK,-1,,FS_SYNC_TRACE_END(mkdtemp),5,,2785,1,,void
185770,BLOCK,-1,,FS_SYNC_TRACE_END(mkdtemp),5,,2785,2,,void
185798,BLOCK,-1,,FS_SYNC_TRACE_END(mkdtemp),5,,2785,2,,void
185860,BLOCK,-1,,"{
      Local<Object> ctx = args[3].As<Object>();
      ctx->Set(env->context(), env->error_string(), error).Check();
      return;
    }",23,,2791,2,,void
185907,BLOCK,-1,,"{
  if (file_url.type != ada::scheme::FILE) {
    env->isolate()->ThrowException(ERR_INVALID_URL_SCHEME(env->isolate()));

    return false;
  }

  std::string_view pathname = file_url.get_pathname();
#ifdef _WIN32
  size_t first_percent = std::string::npos;
  size_t pathname_size = pathname.size();
  std::string pathname_escaped_slash;

  for (size_t i = 0; i < pathname_size; i++) {
    if (pathname[i] == '/') {
      pathname_escaped_slash += '\\';
    } else {
      pathname_escaped_slash += pathname[i];
    }

    if (pathname[i] != '%') continue;

    if (first_percent == std::string::npos) {
      first_percent = i;
    }

    // just safe-guard against access the pathname
    // outside the bounds
    if ((i + 2) >= pathname_size) continue;

    char third = pathname[i + 2] | 0x20;

    bool is_slash = pathname[i + 1] == '2' && third == 102;
    bool is_forward_slash = pathname[i + 1] == '5' && third == 99;

    if (!is_slash && !is_forward_slash) continue;

    env->isolate(...",36,,2806,4,,void
185918,BLOCK,-1,,"{
    env->isolate()->ThrowException(ERR_INVALID_URL_SCHEME(env->isolate()));

    return false;
  }",43,,2807,2,,void
185954,BLOCK,-1,,"{
    std::string error_message =
        std::string(""File URL host must be \""localhost\"" or empty on "") +
        std::string(per_process::metadata.platform);
    env->isolate()->ThrowException(
        ERR_INVALID_FILE_URL_HOST(env->isolate(), error_message.c_str()));

    return false;
  }",28,,2884,2,,void
186000,BLOCK,-1,,<empty>,3,,2895,1,,void
186015,BLOCK,4,,"{
    if (pathname[i] != '%') continue;

    if (first_percent == std::string::npos) {
      first_percent = i;
    }

    if (pathname[i + 1] == '2' && (pathname[i + 2] | 0x20) == 102) {
      env->isolate()->ThrowException(ERR_INVALID_FILE_URL_PATH(
          env->isolate(),
          ""File URL path must not include encoded / characters""));

      return false;
    }
  }",54,,2895,4,,void
186022,BLOCK,-1,,<empty>,29,,2896,2,,void
186032,BLOCK,-1,,"{
      first_percent = i;
    }",45,,2898,2,,void
186054,BLOCK,-1,,"{
      env->isolate()->ThrowException(ERR_INVALID_FILE_URL_PATH(
          env->isolate(),
          ""File URL path must not include encoded / characters""));

      return false;
    }",68,,2902,2,,void
186087,BLOCK,-1,,"{
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env,
      permission::PermissionScope::kFileSystemRead,
      file_path,
      BindingData::FilePathIsFileReturnType::kThrowInsufficientPermissions);

  uv_fs_t req;

  int rc = uv_fs_stat(env->event_loop(), &req, file_path.c_str(), nullptr);

  if (rc == 0) {
    const uv_stat_t* const s = static_cast<const uv_stat_t*>(req.ptr);
    rc = !!(s->st_mode & S_IFDIR);
  }

  uv_fs_req_cleanup(&req);

  // rc is 0 if the path refers to a file
  if (rc == 0) return BindingData::FilePathIsFileReturnType::kIsFile;

  return BindingData::FilePathIsFileReturnType::kIsNotFile;
}",53,,2918,3,,void
186121,BLOCK,-1,,"{
    const uv_stat_t* const s = static_cast<const uv_stat_t*>(req.ptr);
    rc = !!(s->st_mode & S_IFDIR);
  }",16,,2929,2,,void
186146,BLOCK,-1,,<empty>,16,,2937,2,,void
186177,BLOCK,-1,,"{
  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());

  Environment* env = Environment::GetCurrent(args);

  Utf8Value utf8_package_json_url(env->isolate(), args[0].As<String>());
  auto package_json_url =
      ada::parse<ada::url_aggregator>(utf8_package_json_url.ToStringView());

  if (!package_json_url) {
    env->isolate()->ThrowException(
        ERR_INVALID_URL(env->isolate(), ""Invalid URL""));

    return;
  }

  ada::result<ada::url_aggregator> file_path_url;
  std::string initial_file_path;
  std::string file_path;

  if (args.Length() >= 2 && !args[1]->IsNullOrUndefined() &&
      args[1]->IsString()) {
    std::string package_config_main =
        Utf8Value(env->isolate(), args[1].As<String>()).ToString();

    file_path_url = ada::parse<ada::url_aggregator>(
        std::string(""./"") + package_config_main, &package_json_url.value());

    if (!file_path_url) {
      env->isolate()->ThrowException(
          ERR_INVALID_URL(env->isolate(), ""Invalid URL""));

     ...",78,,2958,2,,void
186229,BLOCK,-1,,"{
    env->isolate()->ThrowException(
        ERR_INVALID_URL(env->isolate(), ""Invalid URL""));

    return;
  }",26,,2968,2,,void
186277,BLOCK,-1,,"{
    std::string package_config_main =
        Utf8Value(env->isolate(), args[1].As<String>()).ToString();

    file_path_url = ada::parse<ada::url_aggregator>(
        std::string(""./"") + package_config_main, &package_json_url.value());

    if (!file_path_url) {
      env->isolate()->ThrowException(
          ERR_INVALID_URL(env->isolate(), ""Invalid URL""));

      return;
    }

    if (!FileURLToPath(env, file_path_url.value(), initial_file_path)) return;

    FromNamespacedPath(&initial_file_path);

    for (int i = 0; i < BindingData::legacy_main_extensions_with_main_end;
         i++) {
      file_path = initial_file_path + BindingData::legacy_main_extensions[i];

      switch (FilePathIsFile(env, file_path)) {
        case BindingData::FilePathIsFileReturnType::kIsFile:
          return args.GetReturnValue().Set(i);
        case BindingData::FilePathIsFileReturnType::kIsNotFile:
          continue;
        case BindingData::FilePathIsFileReturnType::
            kThrowInsuff...",28,,2980,2,,void
186322,BLOCK,-1,,"{
      env->isolate()->ThrowException(
          ERR_INVALID_URL(env->isolate(), ""Invalid URL""));

      return;
    }",25,,2987,2,,void
186346,BLOCK,-1,,<empty>,72,,2994,2,,void
186352,BLOCK,-1,,<empty>,5,,2998,1,,void
186364,BLOCK,4,,"{
      file_path = initial_file_path + BindingData::legacy_main_extensions[i];

      switch (FilePathIsFile(env, file_path)) {
        case BindingData::FilePathIsFileReturnType::kIsFile:
          return args.GetReturnValue().Set(i);
        case BindingData::FilePathIsFileReturnType::kIsNotFile:
          continue;
        case BindingData::FilePathIsFileReturnType::
            kThrowInsufficientPermissions:
          // the default behavior when do not have permission is to return
          // and exit the execution of the method as soon as possible
          // the internal function will throw the exception
          return;
        default:
          UNREACHABLE();
      }
    }",15,,2999,4,,void
186378,BLOCK,-1,,"{
        case BindingData::FilePathIsFileReturnType::kIsFile:
          return args.GetReturnValue().Set(i);
        case BindingData::FilePathIsFileReturnType::kIsNotFile:
          continue;
        case BindingData::FilePathIsFileReturnType::
            kThrowInsufficientPermissions:
          // the default behavior when do not have permission is to return
          // and exit the execution of the method as soon as possible
          // the internal function will throw the exception
          return;
        default:
          UNREACHABLE();
      }",47,,3002,2,,void
186431,BLOCK,-1,,"{
    env->isolate()->ThrowException(
        ERR_INVALID_URL(env->isolate(), ""Invalid URL""));

    return;
  }",23,,3022,2,,void
186455,BLOCK,-1,,<empty>,70,,3029,2,,void
186461,BLOCK,-1,,<empty>,3,,3033,1,,void
186475,BLOCK,4,,"{
    file_path = initial_file_path + BindingData::legacy_main_extensions[i];

    switch (FilePathIsFile(env, file_path)) {
      case BindingData::FilePathIsFileReturnType::kIsFile:
        return args.GetReturnValue().Set(i);
      case BindingData::FilePathIsFileReturnType::kIsNotFile:
        continue;
      case BindingData::FilePathIsFileReturnType::kThrowInsufficientPermissions:
        // the default behavior when do not have permission is to return
        // and exit the execution of the method as soon as possible
        // the internal function will throw the exception
        return;
      default:
        UNREACHABLE();
    }
  }",13,,3035,4,,void
186489,BLOCK,-1,,"{
      case BindingData::FilePathIsFileReturnType::kIsFile:
        return args.GetReturnValue().Set(i);
      case BindingData::FilePathIsFileReturnType::kIsNotFile:
        continue;
      case BindingData::FilePathIsFileReturnType::kThrowInsufficientPermissions:
        // the default behavior when do not have permission is to return
        // and exit the execution of the method as soon as possible
        // the internal function will throw the exception
        return;
      default:
        UNREACHABLE();
    }",45,,3038,2,,void
186532,BLOCK,-1,,<empty>,67,,3056,2,,void
186556,BLOCK,-1,,"{
    Utf8Value utf8_base_path(env->isolate(), args[2].As<String>());
    auto base_url =
        ada::parse<ada::url_aggregator>(utf8_base_path.ToStringView());

    if (!base_url) {
      env->isolate()->ThrowException(
          ERR_INVALID_URL(env->isolate(), ""Invalid URL""));

      return;
    }

    if (!FileURLToPath(env, base_url.value(), module_base)) return;
  }",28,,3059,2,,void
186587,BLOCK,-1,,"{
      env->isolate()->ThrowException(
          ERR_INVALID_URL(env->isolate(), ""Invalid URL""));

      return;
    }",20,,3064,2,,void
186611,BLOCK,-1,,<empty>,61,,3071,2,,void
186614,BLOCK,-1,,"{
    std::string err_arg_message =
        ""The \""base\"" argument must be of type string or an instance of URL."";
    env->isolate()->ThrowException(
        ERR_INVALID_ARG_TYPE(env->isolate(), err_arg_message.c_str()));
    return;
  }",10,,3072,1,,void
186666,BLOCK,-1,,"{
  tracker->TrackField(""stats_field_array"", stats_field_array);
  tracker->TrackField(""stats_field_bigint_array"", stats_field_bigint_array);
  tracker->TrackField(""statfs_field_array"", statfs_field_array);
  tracker->TrackField(""statfs_field_bigint_array"", statfs_field_bigint_array);
  tracker->TrackField(""file_handle_read_wrap_freelist"",
                      file_handle_read_wrap_freelist);
}",60,,3086,2,,void
186703,BLOCK,-1,,"{
  Isolate* isolate = realm->isolate();
  Local<Context> context = realm->context();

  if (info == nullptr) {
    wrap->Set(context,
              FIXED_ONE_BYTE_STRING(isolate, ""statValues""),
              stats_field_array.GetJSArray())
        .Check();

    wrap->Set(context,
              FIXED_ONE_BYTE_STRING(isolate, ""bigintStatValues""),
              stats_field_bigint_array.GetJSArray())
        .Check();

    wrap->Set(context,
              FIXED_ONE_BYTE_STRING(isolate, ""statFsValues""),
              statfs_field_array.GetJSArray())
        .Check();

    wrap->Set(context,
              FIXED_ONE_BYTE_STRING(isolate, ""bigintStatFsValues""),
              statfs_field_bigint_array.GetJSArray())
        .Check();
  } else {
    stats_field_array.Deserialize(realm->context());
    stats_field_bigint_array.Deserialize(realm->context());
    statfs_field_array.Deserialize(realm->context());
    statfs_field_bigint_array.Deserialize(realm->context());
  }
  stats_field_array...",61,,3111,4,,void
186725,BLOCK,-1,,"{
    wrap->Set(context,
              FIXED_ONE_BYTE_STRING(isolate, ""statValues""),
              stats_field_array.GetJSArray())
        .Check();

    wrap->Set(context,
              FIXED_ONE_BYTE_STRING(isolate, ""bigintStatValues""),
              stats_field_bigint_array.GetJSArray())
        .Check();

    wrap->Set(context,
              FIXED_ONE_BYTE_STRING(isolate, ""statFsValues""),
              statfs_field_array.GetJSArray())
        .Check();

    wrap->Set(context,
              FIXED_ONE_BYTE_STRING(isolate, ""bigintStatFsValues""),
              statfs_field_bigint_array.GetJSArray())
        .Check();
  }",24,,3115,2,,void
186787,BLOCK,-1,,"{
    stats_field_array.Deserialize(realm->context());
    stats_field_bigint_array.Deserialize(realm->context());
    statfs_field_array.Deserialize(realm->context());
    statfs_field_bigint_array.Deserialize(realm->context());
  }",10,,3135,1,,void
186843,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  HandleScope scope(context->GetIsolate());
  Realm* realm = Realm::GetCurrent(context);
  InternalFieldInfo* casted_info = static_cast<InternalFieldInfo*>(info);
  BindingData* binding =
      realm->AddBindingData<BindingData>(context, holder, casted_info);
  CHECK_NOT_NULL(binding);
}",60,,3150,5,,void
186890,BLOCK,-1,,"{
  CHECK(file_handle_read_wrap_freelist.empty());
  DCHECK_NULL(internal_field_info_);
  internal_field_info_ = InternalFieldInfoBase::New<InternalFieldInfo>(type());
  internal_field_info_->stats_field_array =
      stats_field_array.Serialize(context, creator);
  internal_field_info_->stats_field_bigint_array =
      stats_field_bigint_array.Serialize(context, creator);
  internal_field_info_->statfs_field_array =
      statfs_field_array.Serialize(context, creator);
  internal_field_info_->statfs_field_bigint_array =
      statfs_field_bigint_array.Serialize(context, creator);
  // Return true because we need to maintain the reference to the binding from
  // JS land.
  return true;
}",73,,3161,3,,void
186952,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  InternalFieldInfo* info = internal_field_info_;
  internal_field_info_ = nullptr;
  return info;
}",58,,3178,2,,void
186972,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();

  SetMethod(
      isolate, target, ""legacyMainResolve"", BindingData::LegacyMainResolve);
}",76,,3186,3,,void
186991,BLOCK,-1,,"{
  registry->Register(BindingData::LegacyMainResolve);
}",42,,3194,2,,void
187004,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();

  SetMethod(isolate, target, ""access"", Access);
  SetMethod(isolate, target, ""close"", Close);
  SetMethod(isolate, target, ""open"", Open);
  SetMethod(isolate, target, ""openFileHandle"", OpenFileHandle);
  SetMethod(isolate, target, ""read"", Read);
  SetMethod(isolate, target, ""readBuffers"", ReadBuffers);
  SetMethod(isolate, target, ""fdatasync"", Fdatasync);
  SetMethod(isolate, target, ""fsync"", Fsync);
  SetMethod(isolate, target, ""rename"", Rename);
  SetMethod(isolate, target, ""ftruncate"", FTruncate);
  SetMethod(isolate, target, ""rmdir"", RMDir);
  SetMethod(isolate, target, ""mkdir"", MKDir);
  SetMethod(isolate, target, ""readdir"", ReadDir);
  SetMethod(isolate, target, ""internalModuleReadJSON"", InternalModuleReadJSON);
  SetMethod(isolate, target, ""internalModuleStat"", InternalModuleStat);
  SetMethod(isolate, target, ""stat"", Stat);
  SetMethod(isolate, target, ""lstat"", LStat);
  SetMethod(isolate, target, ""fstat"", FStat);
  SetMethodN...",70,,3199,3,,void
187505,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(context);
  realm->AddBindingData<BindingData>(context, target);
}",52,,3307,5,,void
187527,BLOCK,-1,,"{
  return binding_data_.get();
}",40,,3312,1,,void
187537,BLOCK,-1,,"{
  registry->Register(Access);
  StatWatcher::RegisterExternalReferences(registry);
  BindingData::RegisterExternalReferences(registry);

  registry->Register(Close);
  registry->Register(Open);
  registry->Register(OpenFileHandle);
  registry->Register(Read);
  registry->Register(ReadBuffers);
  registry->Register(Fdatasync);
  registry->Register(Fsync);
  registry->Register(Rename);
  registry->Register(FTruncate);
  registry->Register(RMDir);
  registry->Register(MKDir);
  registry->Register(ReadDir);
  registry->Register(InternalModuleReadJSON);
  registry->Register(InternalModuleStat);
  registry->Register(Stat);
  registry->Register(LStat);
  registry->Register(FStat);
  registry->Register(ReadFileSync);
  registry->Register(StatFs);
  registry->Register(Link);
  registry->Register(Symlink);
  registry->Register(ReadLink);
  registry->Register(Unlink);
  registry->Register(WriteBuffer);
  registry->Register(WriteBuffers);
  registry->Register(WriteString);
  registry->Registe...",70,,3316,2,,void
187786,BLOCK,-1,,<empty>,1,,1,1,,ANY
187790,BLOCK,-1,,"{
    if (HasHttp2Observer(env))
      entry->Notify(env);
  }",68,,646,2,,void
187794,BLOCK,-1,,<empty>,7,,648,2,,void
187806,BLOCK,-1,,"{
    if (HasHttp2Observer(env))
      entry->Notify(env);
  }",68,,666,2,,void
187810,BLOCK,-1,,<empty>,7,,668,2,,void
187821,BLOCK,-1,,"{
          ping->Done(false);
        }",52,,718,2,,void
187833,BLOCK,-1,,"{
    headers_v[i * 2] = header.GetName(this).ToLocalChecked();
    headers_v[i * 2 + 1] = header.GetValue(this).ToLocalChecked();
    if (header.flags() & NGHTTP2_NV_FLAG_NO_INDEX)
      sensitive_v[sensitive_count++] = headers_v[i * 2];
  }",68,,1352,3,,void
187871,BLOCK,-1,,<empty>,7,,1356,2,,void
187890,BLOCK,-1,,"{
      if (!session_ || !is_write_scheduled()) {
        // This can happen e.g. when a stream was reset before this turn
        // of the event loop, in which case SendPendingData() is called early,
        // or the session was destroyed in the meantime.
        return;
      }

      // Sending data may call arbitrary JS code, so keep track of
      // async context.
      if (env->can_call_into_js()) {
        HandleScope handle_scope(env->isolate());
        InternalCallbackScope callback_scope(this);
        SendPendingData();
      }
    }",62,,1628,2,,void
187897,BLOCK,-1,,"{
        // This can happen e.g. when a stream was reset before this turn
        // of the event loop, in which case SendPendingData() is called early,
        // or the session was destroyed in the meantime.
        return;
      }",47,,1629,2,,void
187904,BLOCK,-1,,"{
        HandleScope handle_scope(env->isolate());
        InternalCallbackScope callback_scope(this);
        SendPendingData();
      }",36,,1638,2,,void
187920,BLOCK,-1,,"{
      // Free any remaining outgoing data chunks here. This should be done
      // here because it's possible for destroy to have been called while
      // we still have queued outbound writes.
      while (!queue_.empty()) {
        NgHttp2StreamWrite& head = queue_.front();
        if (head.req_wrap)
          WriteWrap::FromObject(head.req_wrap)->Done(UV_ECANCELED);
        queue_.pop();
      }

      // We can destroy the stream now if there are no writes for it
      // already on the socket. Otherwise, we'll wait for the garbage collector
      // to take care of cleaning up.
      if (session() == nullptr ||
          !session()->HasWritesOnSocketForStream(this)) {
        // Delete once strong_ref goes out of scope.
        Detach();
      }
    }",27,,2141,2,,void
187927,BLOCK,-1,,"{
        NgHttp2StreamWrite& head = queue_.front();
        if (head.req_wrap)
          WriteWrap::FromObject(head.req_wrap)->Done(UV_ECANCELED);
        queue_.pop();
      }",31,,2145,2,,void
187939,BLOCK,-1,,<empty>,11,,2148,2,,void
187966,BLOCK,-1,,"{
        // Delete once strong_ref goes out of scope.
        Detach();
      }",57,,2156,2,,void
187973,BLOCK,-1,,"{
    return code == NGHTTP2_CANCEL;
  }",51,,2275,2,,void
188022,BLOCK,-1,,<empty>,1,,1,1,,ANY
188032,BLOCK,-1,,"{
  AliasedUint32Array& observers = env->performance_state()->observers;
  return observers[performance::NODE_PERFORMANCE_ENTRY_TYPE_HTTP2] != 0;
}",41,,54,2,,void
188062,BLOCK,-1,,<empty>,77,,79,2,,void
188067,BLOCK,-1,,"{
  if (!session_) return;

  // If there is another scope further below on the stack, or
  // a write is already scheduled, there's nothing to do.
  if (session_->is_in_scope() || session_->is_write_scheduled()) {
    session_.reset();
    return;
  }
  session_->set_in_scope();
}",67,,81,2,,void
188071,BLOCK,-1,,<empty>,18,,82,2,,void
188083,BLOCK,-1,,"{
    session_.reset();
    return;
  }",66,,86,2,,void
188096,BLOCK,-1,,"{
  if (!session_) return;
  session_->set_in_scope(false);
  if (!session_->is_write_scheduled())
    session_->MaybeScheduleWrite();
}",27,,93,1,,void
188100,BLOCK,-1,,<empty>,18,,94,2,,void
188113,BLOCK,-1,,<empty>,5,,97,2,,void
188123,BLOCK,-1,,"{
  nghttp2_option* option;
  CHECK_EQ(nghttp2_option_new(&option), 0);
  CHECK_NOT_NULL(option);
  options_.reset(option);

  // Make sure closed connections aren't kept around, taking up memory.
  // Note that this breaks the priority tree, which we don't use.
  nghttp2_option_set_no_closed_streams(option, 1);

  // We manually handle flow control within a session in order to
  // implement backpressure -- that is, we only send WINDOW_UPDATE
  // frames to the remote peer as data is actually consumed by user
  // code. This ensures that the flow of data over the connection
  // does not move too quickly and limits the amount of data we
  // are required to buffer.
  nghttp2_option_set_no_auto_window_update(option, 1);

  // Enable built in support for receiving ALTSVC and ORIGIN frames (but
  // only on client side sessions
  if (type == NGHTTP2_SESSION_CLIENT) {
    nghttp2_option_set_builtin_recv_extension_type(option, NGHTTP2_ALTSVC);
    nghttp2_option_set_builtin_recv_extensi...",71,,104,3,,void
188147,BLOCK,-1,,"{
    nghttp2_option_set_builtin_recv_extension_type(option, NGHTTP2_ALTSVC);
    nghttp2_option_set_builtin_recv_extension_type(option, NGHTTP2_ORIGIN);
  }",39,,124,2,,void
188172,BLOCK,-1,,"{
    nghttp2_option_set_max_deflate_dynamic_table_size(
        option,
        buffer[IDX_OPTIONS_MAX_DEFLATE_DYNAMIC_TABLE_SIZE]);
  }",66,,132,2,,void
188184,BLOCK,-1,,"{
    nghttp2_option_set_max_reserved_remote_streams(
        option,
        buffer[IDX_OPTIONS_MAX_RESERVED_REMOTE_STREAMS]);
  }",63,,138,2,,void
188196,BLOCK,-1,,"{
    nghttp2_option_set_max_send_header_block_length(
        option,
        buffer[IDX_OPTIONS_MAX_SEND_HEADER_BLOCK_LENGTH]);
  }",64,,144,2,,void
188211,BLOCK,-1,,"{
    nghttp2_option_set_peer_max_concurrent_streams(
        option,
        buffer[IDX_OPTIONS_PEER_MAX_CONCURRENT_STREAMS]);
  }",63,,152,2,,void
188223,BLOCK,-1,,"{
    PaddingStrategy strategy =
        static_cast<PaddingStrategy>(
            buffer.GetValue(IDX_OPTIONS_PADDING_STRATEGY));
    set_padding_strategy(strategy);
  }",52,,162,2,,void
188242,BLOCK,-1,,<empty>,5,,174,2,,void
188253,BLOCK,-1,,<empty>,5,,182,2,,void
188264,BLOCK,-1,,<empty>,5,,190,2,,void
188275,BLOCK,-1,,<empty>,5,,201,2,,void
188290,BLOCK,-1,,"{
    nghttp2_option_set_max_settings(
        option,
        static_cast<size_t>(buffer[IDX_OPTIONS_MAX_SETTINGS]));
  }",48,,204,2,,void
188303,BLOCK,-1,,"{
  AliasedUint32Array& buffer = http2_state->settings_buffer;
  uint32_t flags = buffer[IDX_SETTINGS_COUNT];

  size_t count = 0;

#define V(name) GRABSETTING(entries, count, name);
  HTTP2_SETTINGS(V)
#undef V

  return count;
}",38,,221,3,,void
188331,BLOCK,-1,,"{
  callback_.Reset(env()->isolate(), callback);
  count_ = Init(session->http2_state(), entries_);
}",30,,244,5,,void
188352,BLOCK,-1,,"{
  return callback_.Get(env()->isolate());
}",49,,249,1,,void
188366,BLOCK,-1,,"{
  tracker->TrackField(""callback"", callback_);
}",62,,253,2,,void
188376,BLOCK,-1,,"{
  return Pack(session_->env(), count_, entries_);
}",36,,260,1,,void
188389,BLOCK,-1,,"{
  nghttp2_settings_entry entries[IDX_SETTINGS_COUNT];
  size_t count = Init(state, entries);
  return Pack(state->env(), count, entries);
}",53,,264,2,,void
188411,BLOCK,-1,,"{
  EscapableHandleScope scope(env->isolate());
  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), count * 6);
  }
  if (nghttp2_pack_settings_payload(static_cast<uint8_t*>(bs->Data()),
                                    bs->ByteLength(),
                                    entries,
                                    count) < 0) {
    return scope.Escape(Undefined(env->isolate()));
  }
  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
  return scope.Escape(Buffer::New(env, ab, 0, ab->ByteLength())
                          .FromMaybe(Local<Value>()));
}",44,,273,4,,void
188425,BLOCK,4,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), count * 6);
  }",3,,276,4,,void
188461,BLOCK,-1,,"{
    return scope.Escape(Undefined(env->isolate()));
  }",49,,283,2,,void
188516,BLOCK,-1,,"{
  AliasedUint32Array& buffer = session->http2_state()->settings_buffer;

#define V(name)                                                                \
  buffer[IDX_SETTINGS_ ## name] =                                              \
      fn(session->session(), NGHTTP2_SETTINGS_ ## name);
  HTTP2_SETTINGS(V)
#undef V
}",67,,293,3,,void
188532,BLOCK,-1,,"{
  AliasedUint32Array& buffer = http2_state->settings_buffer;
  uint32_t flags = 0;

#define V(name)                                                            \
  do {                                                                     \
    buffer[IDX_SETTINGS_ ## name] = DEFAULT_SETTINGS_ ## name;             \
    flags |= 1 << IDX_SETTINGS_ ## name;                                   \
  } while (0);
  HTTP2_SETTINGS(V)
#undef V

  buffer[IDX_SETTINGS_COUNT] = flags;
}",62,,304,2,,void
188553,BLOCK,-1,,"{
  Http2Scope h2scope(session_.get());
  CHECK_EQ(nghttp2_submit_settings(
      session_->session(),
      NGHTTP2_FLAG_NONE,
      &entries_[0],
      count_), 0);
}",28,,320,1,,void
188577,BLOCK,-1,,"{
  uint64_t end = uv_hrtime();
  double duration = (end - startTime_) / 1e6;

  Local<Value> argv[] = {Boolean::New(env()->isolate(), ack),
                         Number::New(env()->isolate(), duration)};
  MakeCallback(callback(), arraysize(argv), argv);
}",36,,329,2,,void
188624,BLOCK,-1,,"{
  Local<Context> context = env->context();
  int32_t parent_ = parent->Int32Value(context).ToChecked();
  int32_t weight_ = weight->Int32Value(context).ToChecked();
  bool exclusive_ = exclusive->IsTrue();
  Debug(env, DebugCategory::HTTP2STREAM,
        ""Http2Priority: parent: %d, weight: %d, exclusive: %s\n"",
        parent_, weight_, exclusive_ ? ""yes"" : ""no"");
  nghttp2_priority_spec_init(this, parent_, weight_, exclusive_ ? 1 : 0);
}",54,,344,5,,void
188687,BLOCK,-1,,"{
  switch (session_type_) {
    case NGHTTP2_SESSION_SERVER: return ""server"";
    case NGHTTP2_SESSION_CLIENT: return ""client"";
    default:
      // This should never happen
      ABORT();
  }
}",44,,356,1,,void
188690,BLOCK,-1,,"{
    case NGHTTP2_SESSION_SERVER: return ""server"";
    case NGHTTP2_SESSION_CLIENT: return ""client"";
    default:
      // This should never happen
      ABORT();
  }",26,,357,2,,void
188707,BLOCK,-1,,"{
  int origin_string_len = origin_string->Length();
  if (count_ == 0) {
    CHECK_EQ(origin_string_len, 0);
    return;
  }

  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs_ = ArrayBuffer::NewBackingStore(env->isolate(),
                                       alignof(nghttp2_origin_entry) - 1 +
                                       count_ * sizeof(nghttp2_origin_entry) +
                                       origin_string_len);
  }

  // Make sure the start address is aligned appropriately for an nghttp2_nv*.
  char* start = AlignUp(static_cast<char*>(bs_->Data()),
                        alignof(nghttp2_origin_entry));
  char* origin_contents = start + (count_ * sizeof(nghttp2_origin_entry));
  nghttp2_origin_entry* const nva =
      reinterpret_cast<nghttp2_origin_entry*>(start);

  CHECK_LE(origin_contents + origin_string_len,
           static_cast<char*>(bs_->Data()) + bs_->ByteLength());
  CHECK_EQ(origin_string->WriteOneByte(
           ...",28,,370,4,,void
188719,BLOCK,-1,,"{
    CHECK_EQ(origin_string_len, 0);
    return;
  }",20,,372,2,,void
188724,BLOCK,4,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs_ = ArrayBuffer::NewBackingStore(env->isolate(),
                                       alignof(nghttp2_origin_entry) - 1 +
                                       count_ * sizeof(nghttp2_origin_entry) +
                                       origin_string_len);
  }",3,,377,4,,void
188818,BLOCK,-1,,<empty>,3,,404,1,,void
188829,BLOCK,4,,"{
    if (n >= count_) {
      static uint8_t zero = '\0';
      nva[0].origin = &zero;
      nva[0].origin_len = 1;
      count_ = 1;
      return;
    }

    nva[n].origin = reinterpret_cast<uint8_t*>(p);
    nva[n].origin_len = strlen(p);
    p += nva[n].origin_len + 1;
  }",75,,404,4,,void
188834,BLOCK,-1,,"{
      static uint8_t zero = '\0';
      nva[0].origin = &zero;
      nva[0].origin_len = 1;
      count_ = 1;
      return;
    }",22,,405,2,,void
188888,BLOCK,-1,,"{
  nghttp2_session_callbacks* callbacks_;
  CHECK_EQ(nghttp2_session_callbacks_new(&callbacks_), 0);
  callbacks.reset(callbacks_);

  nghttp2_session_callbacks_set_on_begin_headers_callback(
    callbacks_, OnBeginHeadersCallback);
  nghttp2_session_callbacks_set_on_header_callback2(
    callbacks_, OnHeaderCallback);
  nghttp2_session_callbacks_set_on_frame_recv_callback(
    callbacks_, OnFrameReceive);
  nghttp2_session_callbacks_set_on_stream_close_callback(
    callbacks_, OnStreamClose);
  nghttp2_session_callbacks_set_on_data_chunk_recv_callback(
    callbacks_, OnDataChunkReceived);
  nghttp2_session_callbacks_set_on_frame_not_send_callback(
    callbacks_, OnFrameNotSent);
  nghttp2_session_callbacks_set_on_invalid_header_callback2(
    callbacks_, OnInvalidHeader);
  nghttp2_session_callbacks_set_error_callback2(callbacks_, OnNghttpError);
  nghttp2_session_callbacks_set_send_data_callback(
    callbacks_, OnSendData);
  nghttp2_session_callbacks_set_on_invalid_frame_rec...",65,,421,2,,void
188935,BLOCK,-1,,"{
    nghttp2_session_callbacks_set_select_padding_callback(
      callbacks_, OnSelectPadding);
  }",31,,448,2,,void
188943,BLOCK,-1,,"{
  StopTrackingMemory(buf);
}",58,,454,2,,void
188950,BLOCK,-1,,"{
  CHECK_GE(current_nghttp2_memory_, previous_size);
}",67,,458,2,,void
188958,BLOCK,-1,,"{
  current_nghttp2_memory_ += size;
}",55,,462,2,,void
188966,BLOCK,-1,,"{
  current_nghttp2_memory_ -= size;
}",55,,466,2,,void
188976,BLOCK,-1,,"{
  MakeWeak();
  statistics_.session_type = type;
  statistics_.start_time = uv_hrtime();

  // Capture the configuration options for this session
  Http2Options opts(http2_state, type);

  max_session_memory_ = opts.max_session_memory();

  uint32_t maxHeaderPairs = opts.max_header_pairs();
  max_header_pairs_ =
      type == NGHTTP2_SESSION_SERVER
          ? GetServerMaxHeaderPairs(maxHeaderPairs)
          : GetClientMaxHeaderPairs(maxHeaderPairs);

  max_outstanding_pings_ = opts.max_outstanding_pings();
  max_outstanding_settings_ = opts.max_outstanding_settings();

  padding_strategy_ = opts.padding_strategy();

  bool hasGetPaddingCallback =
      padding_strategy_ != PADDING_STRATEGY_NONE;

  auto fn = type == NGHTTP2_SESSION_SERVER ?
      nghttp2_session_server_new3 :
      nghttp2_session_client_new3;

  nghttp2_mem alloc_info = MakeAllocator();

  // This should fail only if the system is out of memory, which
  // is going to cause lots of other problems anyway, or if ...",33,,476,4,,void
189122,BLOCK,-1,,"{
  CHECK(!is_in_scope());
  Debug(this, ""freeing nghttp2 session"");
  // Explicitly reset session_ so the subsequent
  // current_nghttp2_memory_ check passes.
  session_.reset();
  CHECK_EQ(current_nghttp2_memory_, 0);
}",31,,528,1,,void
189140,BLOCK,-1,,"{
  tracker->TrackField(""streams"", streams_);
  tracker->TrackField(""outstanding_pings"", outstanding_pings_);
  tracker->TrackField(""outstanding_settings"", outstanding_settings_);
  tracker->TrackField(""outgoing_buffers"", outgoing_buffers_);
  tracker->TrackFieldWithSize(""stream_buf"", stream_buf_.len);
  tracker->TrackFieldWithSize(""outgoing_storage"", outgoing_storage_.size());
  tracker->TrackFieldWithSize(""pending_rst_streams"",
                              pending_rst_streams_.size() * sizeof(int32_t));
  tracker->TrackFieldWithSize(""nghttp2_memory"", current_nghttp2_memory_);
}",61,,537,2,,void
189203,BLOCK,-1,,"{
  return std::string(""Http2Session "") + TypeName() + "" ("" +
      std::to_string(static_cast<int64_t>(get_async_id())) + "")"";
}",51,,549,1,,void
189229,BLOCK,-1,,"{
  Local<Object> obj = Object::New(env->isolate());

#define SET(name, val)                                                         \
  if (!obj->Set(                                                               \
          env->context(),                                                      \
          env->name(),                                                         \
          Number::New(                                                         \
            env->isolate(),                                                    \
            static_cast<double>(entry.details.val))).IsJust()) {               \
    return MaybeLocal<Object>();                                               \
  }

  SET(bytes_read_string, received_bytes)
  SET(bytes_written_string, sent_bytes)
  SET(id_string, id)
#undef SET

#define SET(name, val)                                                         \
  if (!obj->Set(                                                               \
          env-...",47,,556,3,,void
189245,BLOCK,1,,<empty>,,,,1,,void
189278,BLOCK,-1,,"SET(bytes_read_string, received_bytes)",3,,569,2,,void
189282,BLOCK,1,,<empty>,,,,1,,void
189315,BLOCK,-1,,"SET(bytes_written_string, sent_bytes)",3,,570,2,,void
189319,BLOCK,1,,<empty>,,,,1,,void
189352,BLOCK,-1,,"SET(id_string, id)",3,,571,2,,void
189356,BLOCK,1,,<empty>,,,,1,,void
189395,BLOCK,-1,,"SET(time_to_first_byte_string, first_byte)",3,,585,2,,void
189399,BLOCK,1,,<empty>,,,,1,,void
189438,BLOCK,-1,,"SET(time_to_first_byte_sent_string, first_byte_sent)",3,,586,2,,void
189442,BLOCK,1,,<empty>,,,,1,,void
189481,BLOCK,-1,,"SET(time_to_first_header_string, first_header)",3,,587,2,,void
189491,BLOCK,-1,,"{
  Local<Object> obj = Object::New(env->isolate());

#define SET(name, val)                                                         \
  if (!obj->Set(                                                               \
          env->context(),                                                      \
          env->name(),                                                         \
          Number::New(                                                         \
            env->isolate(),                                                    \
            static_cast<double>(entry.details.val))).IsJust()) {               \
    return MaybeLocal<Object>();                                               \
  }

  SET(bytes_written_string, data_sent)
  SET(bytes_read_string, data_received)
  SET(frames_received_string, frame_count)
  SET(frames_sent_string, frame_sent)
  SET(max_concurrent_streams_string, max_concurrent_streams)
  SET(ping_rtt_string, ping_rtt)
  SET(stream_average_duration_string...",48,,595,3,,void
189507,BLOCK,1,,<empty>,,,,1,,void
189540,BLOCK,-1,,"SET(bytes_written_string, data_sent)",3,,608,2,,void
189544,BLOCK,1,,<empty>,,,,1,,void
189577,BLOCK,-1,,"SET(bytes_read_string, data_received)",3,,609,2,,void
189581,BLOCK,1,,<empty>,,,,1,,void
189614,BLOCK,-1,,"SET(frames_received_string, frame_count)",3,,610,2,,void
189618,BLOCK,1,,<empty>,,,,1,,void
189651,BLOCK,-1,,"SET(frames_sent_string, frame_sent)",3,,611,2,,void
189655,BLOCK,1,,<empty>,,,,1,,void
189688,BLOCK,-1,,"SET(max_concurrent_streams_string, max_concurrent_streams)",3,,612,2,,void
189692,BLOCK,1,,<empty>,,,,1,,void
189725,BLOCK,-1,,"SET(ping_rtt_string, ping_rtt)",3,,613,2,,void
189729,BLOCK,1,,<empty>,,,,1,,void
189762,BLOCK,-1,,"SET(stream_average_duration_string, stream_average_duration)",3,,614,2,,void
189766,BLOCK,1,,<empty>,,,,1,,void
189799,BLOCK,-1,,"SET(stream_count_string, stream_count)",3,,615,2,,void
189834,BLOCK,-1,,"{
    return MaybeLocal<Object>();
  }",53,,623,2,,void
189842,BLOCK,-1,,"{
  CHECK_NOT_NULL(session());
  if (LIKELY(!HasHttp2Observer(env())))
    return;

  double start = statistics_.start_time / 1e6;
  double duration = (PERFORMANCE_NOW() / 1e6) - start;

  std::unique_ptr<Http2StreamPerformanceEntry> entry =
      std::make_unique<Http2StreamPerformanceEntry>(
          ""Http2Stream"",
          start - (env()->time_origin() / 1e6),
          duration,
          statistics_);

  env()->SetImmediate([entry = std::move(entry)](Environment* env) {
    if (HasHttp2Observer(env))
      entry->Notify(env);
  });
}",36,,631,1,,void
189849,BLOCK,-1,,<empty>,5,,634,2,,void
189902,BLOCK,-1,,"{
  if (LIKELY(!HasHttp2Observer(env())))
    return;

  double start = statistics_.start_time / 1e6;
  double duration = (PERFORMANCE_NOW() / 1e6) - start;

  std::unique_ptr<Http2SessionPerformanceEntry> entry =
      std::make_unique<Http2SessionPerformanceEntry>(
          ""Http2Session"",
          start - (env()->time_origin() / 1e6),
          duration,
          statistics_);

  env()->SetImmediate([entry = std::move(entry)](Environment* env) {
    if (HasHttp2Observer(env))
      entry->Notify(env);
  });
}",37,,652,1,,void
189908,BLOCK,-1,,<empty>,5,,654,2,,void
189963,BLOCK,-1,,"{
  Debug(this, ""closing session"");

  if (is_closing())
    return;
  set_closing();

  // Stop reading on the i/o stream
  if (stream_ != nullptr) {
    set_reading_stopped();
    stream_->ReadStop();
  }

  // If the socket is not closed, then attempt to send a closing GOAWAY
  // frame. There is no guarantee that this GOAWAY will be received by
  // the peer but the HTTP/2 spec recommends sending it anyway. We'll
  // make a best effort.
  if (!socket_closed) {
    Debug(this, ""terminating session with code %d"", code);
    CHECK_EQ(nghttp2_session_terminate_session(session_.get(), code), 0);
    SendPendingData();
  } else if (stream_ != nullptr) {
    stream_->RemoveStreamListener(this);
  }

  set_destroyed();

  // If we are writing we will get to make the callback in OnStreamAfterWrite.
  if (!is_write_in_progress()) {
    Debug(this, ""make done session callback"");
    HandleScope scope(env()->isolate());
    MakeCallback(env()->ondone_string(), 0, nullptr);
    if (stream_ ...",61,,673,3,,void
189969,BLOCK,-1,,<empty>,5,,677,2,,void
189976,BLOCK,-1,,"{
    set_reading_stopped();
    stream_->ReadStop();
  }",27,,681,2,,void
189985,BLOCK,-1,,"{
    Debug(this, ""terminating session with code %d"", code);
    CHECK_EQ(nghttp2_session_terminate_session(session_.get(), code), 0);
    SendPendingData();
  }",23,,690,2,,void
190000,BLOCK,-1,,<empty>,10,,694,1,,void
190005,BLOCK,-1,,"{
    stream_->RemoveStreamListener(this);
  }",34,,694,2,,void
190015,BLOCK,-1,,"{
    Debug(this, ""make done session callback"");
    HandleScope scope(env()->isolate());
    MakeCallback(env()->ondone_string(), 0, nullptr);
    if (stream_ != nullptr) {
      // Start reading again to detect the other end finishing.
      set_reading_stopped(false);
      stream_->ReadStart();
    }
  }",32,,701,2,,void
190036,BLOCK,-1,,"{
      // Start reading again to detect the other end finishing.
      set_reading_stopped(false);
      stream_->ReadStart();
    }",29,,705,2,,void
190051,BLOCK,-1,,"{
    ping->DetachFromSession();
    env()->SetImmediate(
        [ping = std::move(ping)](Environment* env) {
          ping->Done(false);
        });
  }",53,,715,2,,void
190071,BLOCK,-1,,"{
  auto s = streams_.find(id);
  return s != streams_.end() ? s->second : BaseObjectPtr<Http2Stream>();
}",65,,729,2,,void
190095,BLOCK,-1,,"{
  uint32_t maxConcurrentStreams =
      nghttp2_session_get_local_settings(
          session_.get(), NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS);
  size_t maxSize =
      std::min(streams_.max_size(), static_cast<size_t>(maxConcurrentStreams));
  // We can add a new stream so long as we are less than the current
  // maximum on concurrent streams and there's enough available memory
  return streams_.size() < maxSize &&
         has_available_session_memory(sizeof(Http2Stream));
}",35,,734,1,,void
190134,BLOCK,-1,,"{
  CHECK_GE(++statistics_.stream_count, 0);
  streams_[stream->id()] = BaseObjectPtr<Http2Stream>(stream);
  size_t size = streams_.size();
  if (size > statistics_.max_concurrent_streams)
    statistics_.max_concurrent_streams = size;
  IncrementCurrentSessionMemory(sizeof(*stream));
}",51,,746,2,,void
190166,BLOCK,-1,,<empty>,5,,751,2,,void
190180,BLOCK,-1,,"{
  BaseObjectPtr<Http2Stream> stream;
  if (streams_.empty())
    return stream;
  stream = FindStream(id);
  if (stream) {
    streams_.erase(id);
    DecrementCurrentSessionMemory(sizeof(*stream));
  }
  return stream;
}",67,,756,2,,void
190191,BLOCK,-1,,<empty>,5,,759,2,,void
190200,BLOCK,-1,,"{
    streams_.erase(id);
    DecrementCurrentSessionMemory(sizeof(*stream));
  }",15,,761,2,,void
190217,BLOCK,-1,,"{
  size_t r = (frameLen + 9) % 8;
  if (r == 0) return frameLen;  // If already a multiple of 8, return.

  size_t pad = frameLen + (8 - r);

  // If maxPayloadLen happens to be less than the calculated pad length,
  // use the max instead, even tho this means the frame will not be
  // aligned.
  pad = std::min(maxPayloadLen, pad);
  Debug(this, ""using frame size padding: %d"", pad);
  return pad;
}",67,,773,3,,void
190230,BLOCK,-1,,<empty>,15,,775,2,,void
190260,BLOCK,-1,,"{
  Debug(this, ""using max frame size padding: %d"", maxPayloadLen);
  return maxPayloadLen;
}",67,,790,3,,void
190270,BLOCK,-1,,"{
  CHECK_NOT_NULL(stream_buf_.base);
  CHECK_LE(stream_buf_offset_, stream_buf_.len);
  size_t read_len = stream_buf_.len - stream_buf_offset_;

  // multiple side effects.
  Debug(this, ""receiving %d bytes [wants data? %d]"",
        read_len,
        nghttp2_session_want_read(session_.get()));
  set_receive_paused(false);
  custom_recv_error_code_ = nullptr;
  ssize_t ret =
    nghttp2_session_mem_recv(session_.get(),
                             reinterpret_cast<uint8_t*>(stream_buf_.base) +
                                 stream_buf_offset_,
                             read_len);
  CHECK_NE(ret, NGHTTP2_ERR_NOMEM);
  CHECK_IMPLIES(custom_recv_error_code_ != nullptr, ret < 0);

  if (is_receive_paused()) {
    CHECK(is_reading_stopped());

    CHECK_GT(ret, 0);
    CHECK_LE(static_cast<size_t>(ret), read_len);

    // Mark the remainder of the data as available for later consumption.
    // Even if all bytes were received, a paused stream may delay the
    // nghttp2_on_frame_r...",39,,800,1,,void
190330,BLOCK,-1,,"{
    CHECK(is_reading_stopped());

    CHECK_GT(ret, 0);
    CHECK_LE(static_cast<size_t>(ret), read_len);

    // Mark the remainder of the data as available for later consumption.
    // Even if all bytes were received, a paused stream may delay the
    // nghttp2_on_frame_recv_callback which may have an END_STREAM flag.
    stream_buf_offset_ += ret;
    goto done;
  }",28,,819,2,,void
190371,BLOCK,-1,,"{
    SendPendingData();
  }",36,,840,2,,void
190379,BLOCK,-1,,"{
    Isolate* isolate = env()->isolate();
    Debug(this,
        ""fatal error receiving data: %d (%s)"",
        ret,
        custom_recv_error_code_ != nullptr ?
            custom_recv_error_code_ : ""(no custom error code)"");
    Local<Value> args[] = {
      Integer::New(isolate, static_cast<int32_t>(ret)),
      Null(isolate)
    };
    if (custom_recv_error_code_ != nullptr) {
      args[1] = String::NewFromUtf8(
          isolate,
          custom_recv_error_code_,
          NewStringType::kInternalized).ToLocalChecked();
    }
    MakeCallback(
        env()->http2session_on_error_function(),
        arraysize(args),
        args);
  }",26,,845,2,,void
190415,BLOCK,-1,,"{
      args[1] = String::NewFromUtf8(
          isolate,
          custom_recv_error_code_,
          NewStringType::kInternalized).ToLocalChecked();
    }",45,,856,2,,void
190444,BLOCK,-1,,"{
  // If this is a push promise, we want to grab the id of the promised stream
  return (frame->hd.type == NGHTTP2_PUSH_PROMISE) ?
      frame->push_promise.promised_stream_id :
      frame->hd.stream_id;
}",48,,870,2,,void
190470,BLOCK,-1,,"{
  Http2Session* session = static_cast<Http2Session*>(user_data);
  int32_t id = GetFrameID(frame);
  Debug(session, ""beginning headers for stream %d"", id);

  BaseObjectPtr<Http2Stream> stream = session->FindStream(id);
  // The common case is that we're creating a new stream. The less likely
  // case is that we're receiving a set of trailers
  if (LIKELY(!stream)) {
    if (UNLIKELY(!session->CanAddStream() ||
                 Http2Stream::New(session, id, frame->headers.cat) ==
                     nullptr)) {
      if (session->rejected_stream_count_++ >
          session->js_fields_->max_rejected_streams)
        return NGHTTP2_ERR_CALLBACK_FAILURE;
      // Too many concurrent streams being opened
      nghttp2_submit_rst_stream(
          session->session(),
          NGHTTP2_FLAG_NONE,
          id,
          NGHTTP2_ENHANCE_YOUR_CALM);
      return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;
    }

    session->rejected_stream_count_ = 0;
  } else if (!stream->is_destroyed()) ...",59,,884,4,,void
190501,BLOCK,-1,,"{
    if (UNLIKELY(!session->CanAddStream() ||
                 Http2Stream::New(session, id, frame->headers.cat) ==
                     nullptr)) {
      if (session->rejected_stream_count_++ >
          session->js_fields_->max_rejected_streams)
        return NGHTTP2_ERR_CALLBACK_FAILURE;
      // Too many concurrent streams being opened
      nghttp2_submit_rst_stream(
          session->session(),
          NGHTTP2_FLAG_NONE,
          id,
          NGHTTP2_ENHANCE_YOUR_CALM);
      return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;
    }

    session->rejected_stream_count_ = 0;
  }",24,,892,2,,void
190523,BLOCK,-1,,"{
      if (session->rejected_stream_count_++ >
          session->js_fields_->max_rejected_streams)
        return NGHTTP2_ERR_CALLBACK_FAILURE;
      // Too many concurrent streams being opened
      nghttp2_submit_rst_stream(
          session->session(),
          NGHTTP2_FLAG_NONE,
          id,
          NGHTTP2_ENHANCE_YOUR_CALM);
      return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;
    }",32,,895,2,,void
190535,BLOCK,-1,,<empty>,9,,898,2,,void
190554,BLOCK,-1,,<empty>,10,,909,1,,void
190561,BLOCK,-1,,"{
    stream->StartHeaders(frame->headers.cat);
  }",39,,909,2,,void
190582,BLOCK,-1,,"{
  Http2Session* session = static_cast<Http2Session*>(user_data);
  int32_t id = GetFrameID(frame);
  BaseObjectPtr<Http2Stream> stream = session->FindStream(id);
  // If stream is null at this point, either something odd has happened
  // or the stream was closed locally while header processing was occurring.
  // either way, do not proceed and close the stream.
  if (UNLIKELY(!stream))
    return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;

  // If the stream has already been destroyed, ignore.
  if (!stream->is_destroyed() && !stream->AddHeader(name, value, flags)) {
    // This will only happen if the connected peer sends us more
    // than the allowed number of header items at any given time
    stream->SubmitRstStream(NGHTTP2_ENHANCE_YOUR_CALM);
    return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;
  }
  return 0;
}",53,,923,7,,void
190609,BLOCK,-1,,<empty>,5,,931,2,,void
190627,BLOCK,-1,,"{
    // This will only happen if the connected peer sends us more
    // than the allowed number of header items at any given time
    stream->SubmitRstStream(NGHTTP2_ENHANCE_YOUR_CALM);
    return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;
  }",74,,934,2,,void
190643,BLOCK,-1,,"{
  Http2Session* session = static_cast<Http2Session*>(user_data);
  session->statistics_.frame_count++;
  Debug(session, ""complete frame received: type: %d"",
        frame->hd.type);
  switch (frame->hd.type) {
    case NGHTTP2_DATA:
      return session->HandleDataFrame(frame);
    case NGHTTP2_PUSH_PROMISE:
      // Intentional fall-through, handled just like headers frames
    case NGHTTP2_HEADERS:
      session->HandleHeadersFrame(frame);
      break;
    case NGHTTP2_SETTINGS:
      session->HandleSettingsFrame(frame);
      break;
    case NGHTTP2_PRIORITY:
      session->HandlePriorityFrame(frame);
      break;
    case NGHTTP2_GOAWAY:
      session->HandleGoawayFrame(frame);
      break;
    case NGHTTP2_PING:
      session->HandlePingFrame(frame);
      break;
    case NGHTTP2_ALTSVC:
      session->HandleAltSvcFrame(frame);
      break;
    case NGHTTP2_ORIGIN:
      session->HandleOriginFrame(frame);
      break;
    default:
      break;
  }
  return 0;
}",51,,948,4,,void
190670,BLOCK,-1,,"{
    case NGHTTP2_DATA:
      return session->HandleDataFrame(frame);
    case NGHTTP2_PUSH_PROMISE:
      // Intentional fall-through, handled just like headers frames
    case NGHTTP2_HEADERS:
      session->HandleHeadersFrame(frame);
      break;
    case NGHTTP2_SETTINGS:
      session->HandleSettingsFrame(frame);
      break;
    case NGHTTP2_PRIORITY:
      session->HandlePriorityFrame(frame);
      break;
    case NGHTTP2_GOAWAY:
      session->HandleGoawayFrame(frame);
      break;
    case NGHTTP2_PING:
      session->HandlePingFrame(frame);
      break;
    case NGHTTP2_ALTSVC:
      session->HandleAltSvcFrame(frame);
      break;
    case NGHTTP2_ORIGIN:
      session->HandleOriginFrame(frame);
      break;
    default:
      break;
  }",27,,953,2,,void
190748,BLOCK,-1,,"{
  Http2Session* session = static_cast<Http2Session*>(user_data);
  const uint32_t max_invalid_frames = session->js_fields_->max_invalid_frames;

  Debug(session,
        ""invalid frame received (%u/%u), code: %d"",
        session->invalid_frame_count_,
        max_invalid_frames,
        lib_error_code);
  if (session->invalid_frame_count_++ > max_invalid_frames) {
    session->custom_recv_error_code_ = ""ERR_HTTP2_TOO_MANY_INVALID_FRAMES"";
    return 1;
  }

  // If the error is fatal or if error code is ERR_STREAM_CLOSED... emit error
  if (nghttp2_is_fatal(lib_error_code) ||
      lib_error_code == NGHTTP2_ERR_STREAM_CLOSED) {
    Environment* env = session->env();
    Isolate* isolate = env->isolate();
    HandleScope scope(isolate);
    Local<Context> context = env->context();
    Context::Scope context_scope(context);
    Local<Value> arg = Integer::New(isolate, lib_error_code);
    session->MakeCallback(env->http2session_on_error_function(), 1, &arg);
  }
  return 0;
}",51,,988,5,,void
190778,BLOCK,-1,,"{
    session->custom_recv_error_code_ = ""ERR_HTTP2_TOO_MANY_INVALID_FRAMES"";
    return 1;
  }",61,,997,2,,void
190793,BLOCK,-1,,"{
    Environment* env = session->env();
    Isolate* isolate = env->isolate();
    HandleScope scope(isolate);
    Local<Context> context = env->context();
    Context::Scope context_scope(context);
    Local<Value> arg = Integer::New(isolate, lib_error_code);
    session->MakeCallback(env->http2session_on_error_function(), 1, &arg);
  }",52,,1004,2,,void
190853,BLOCK,-1,,"{
  int32_t id = GetFrameID(frame);
  BaseObjectPtr<Http2Stream> stream = FindStream(id);

  if (stream && !stream->is_destroyed() && stream->headers_count() > 0) {
    Debug(this, ""freeing headers for stream %d"", id);
    stream->ClearHeaders();
    CHECK_EQ(stream->headers_count(), 0);
    DecrementCurrentSessionMemory(stream->current_headers_length_);
    stream->current_headers_length_ = 0;
  }
}",62,,1018,2,,void
190882,BLOCK,-1,,"{
    Debug(this, ""freeing headers for stream %d"", id);
    stream->ClearHeaders();
    CHECK_EQ(stream->headers_count(), 0);
    DecrementCurrentSessionMemory(stream->current_headers_length_);
    stream->current_headers_length_ = 0;
  }",73,,1022,2,,void
190910,BLOCK,-1,,"{
  switch (libErrorCode) {
  case NGHTTP2_ERR_STREAM_CLOSED:
    return NGHTTP2_STREAM_CLOSED;
  case NGHTTP2_ERR_HEADER_COMP:
    return NGHTTP2_COMPRESSION_ERROR;
  case NGHTTP2_ERR_FRAME_SIZE_ERROR:
    return NGHTTP2_FRAME_SIZE_ERROR;
  case NGHTTP2_ERR_FLOW_CONTROL:
    return NGHTTP2_FLOW_CONTROL_ERROR;
  case NGHTTP2_ERR_REFUSED_STREAM:
    return NGHTTP2_REFUSED_STREAM;
  case NGHTTP2_ERR_PROTO:
  case NGHTTP2_ERR_HTTP_HEADER:
  case NGHTTP2_ERR_HTTP_MESSAGING:
    return NGHTTP2_PROTOCOL_ERROR;
  default:
    return NGHTTP2_INTERNAL_ERROR;
  }
}",60,,1031,2,,void
190913,BLOCK,-1,,"{
  case NGHTTP2_ERR_STREAM_CLOSED:
    return NGHTTP2_STREAM_CLOSED;
  case NGHTTP2_ERR_HEADER_COMP:
    return NGHTTP2_COMPRESSION_ERROR;
  case NGHTTP2_ERR_FRAME_SIZE_ERROR:
    return NGHTTP2_FRAME_SIZE_ERROR;
  case NGHTTP2_ERR_FLOW_CONTROL:
    return NGHTTP2_FLOW_CONTROL_ERROR;
  case NGHTTP2_ERR_REFUSED_STREAM:
    return NGHTTP2_REFUSED_STREAM;
  case NGHTTP2_ERR_PROTO:
  case NGHTTP2_ERR_HTTP_HEADER:
  case NGHTTP2_ERR_HTTP_MESSAGING:
    return NGHTTP2_PROTOCOL_ERROR;
  default:
    return NGHTTP2_INTERNAL_ERROR;
  }",25,,1032,2,,void
190952,BLOCK,-1,,"{
  Http2Session* session = static_cast<Http2Session*>(user_data);
  Environment* env = session->env();
  Debug(session, ""frame type %d was not sent, code: %d"",
        frame->hd.type, error_code);

  // Do not report if the frame was not sent due to the session closing
  if (error_code == NGHTTP2_ERR_SESSION_CLOSING ||
      error_code == NGHTTP2_ERR_STREAM_CLOSED ||
      error_code == NGHTTP2_ERR_STREAM_CLOSING) {
    // Nghttp2 contains header limit of 65536. When this value is exceeded the
    // pipeline is stopped and we should remove the current headers reference
    // to destroy the session completely.
    // Further information see: https://github.com/nodejs/node/issues/35233
    session->DecrefHeaders(frame);
    return 0;
  }

  Isolate* isolate = env->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env->context();
  Context::Scope context_scope(context);

  Local<Value> argv[3] = {
    Integer::New(isolate, frame->hd.stream_id),
    Integer::New(iso...",51,,1061,5,,void
190987,BLOCK,-1,,"{
    // Nghttp2 contains header limit of 65536. When this value is exceeded the
    // pipeline is stopped and we should remove the current headers reference
    // to destroy the session completely.
    // Further information see: https://github.com/nodejs/node/issues/35233
    session->DecrefHeaders(frame);
    return 0;
  }",49,,1070,2,,void
191045,BLOCK,-1,,"{
  Http2Session* session = static_cast<Http2Session*>(user_data);
  session->statistics_.frame_sent += 1;
  return 0;
}",48,,1097,4,,void
191068,BLOCK,-1,,"{
  Http2Session* session = static_cast<Http2Session*>(user_data);
  Environment* env = session->env();
  Isolate* isolate = env->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env->context();
  Context::Scope context_scope(context);
  Debug(session, ""stream %d closed with code: %d"", id, code);
  BaseObjectPtr<Http2Stream> stream = session->FindStream(id);
  // Intentionally ignore the callback if the stream does not exist or has
  // already been destroyed
  if (!stream || stream->is_destroyed())
    return 0;

  stream->Close(code);

  // It is possible for the stream close to occur before the stream is
  // ever passed on to the javascript side. If that happens, the callback
  // will return false.
  if (env->can_call_into_js()) {
    Local<Value> arg = Integer::NewFromUnsigned(isolate, code);
    MaybeLocal<Value> answer = stream->MakeCallback(
        env->http2session_on_stream_close_function(), 1, &arg);
    if (answer.IsEmpty() || answer.ToLocalChecked()...",50,,1107,5,,void
191129,BLOCK,-1,,<empty>,5,,1119,2,,void
191142,BLOCK,-1,,"{
    Local<Value> arg = Integer::NewFromUnsigned(isolate, code);
    MaybeLocal<Value> answer = stream->MakeCallback(
        env->http2session_on_stream_close_function(), 1, &arg);
    if (answer.IsEmpty() || answer.ToLocalChecked()->IsFalse()) {
      // Skip to destroy
      stream->Destroy();
    }
  }",32,,1126,2,,void
191185,BLOCK,-1,,"{
      // Skip to destroy
      stream->Destroy();
    }",65,,1130,2,,void
191201,BLOCK,-1,,"{
  // Ignore invalid header fields by default.
  return 0;
}",52,,1147,7,,void
191213,BLOCK,-1,,"{
  Http2Session* session = static_cast<Http2Session*>(user_data);
  Debug(session, ""buffering data chunk for stream %d, size: ""
        ""%d, flags: %d"", id, len, flags);
  Environment* env = session->env();
  HandleScope scope(env->isolate());

  // We should never actually get a 0-length chunk so this check is
  // only a precaution at this point.
  if (len == 0)
    return 0;

  // Notify nghttp2 that we've consumed a chunk of data on the connection
  // so that it can send a WINDOW_UPDATE frame. This is a critical part of
  // the flow control process in http2
  CHECK_EQ(nghttp2_session_consume_connection(handle, len), 0);
  BaseObjectPtr<Http2Stream> stream = session->FindStream(id);

  // If the stream has been destroyed, ignore this chunk
  if (!stream || stream->is_destroyed())
    return 0;

  stream->statistics_.received_bytes += len;

  // Repeatedly ask the stream's owner for memory, and copy the read data
  // into those buffers.
  // The typical case is actually the ex...",56,,1161,7,,void
191243,BLOCK,-1,,<empty>,5,,1171,2,,void
191270,BLOCK,-1,,<empty>,5,,1181,2,,void
191281,BLOCK,-1,,"{
    uv_buf_t buf = stream->EmitAlloc(len);
    ssize_t avail = len;
    if (static_cast<ssize_t>(buf.len) < avail)
      avail = buf.len;

    // `buf.base == nullptr` is the default Http2StreamListener's way
    // of saying that it wants a pointer to the raw original.
    // Since it has access to the original socket buffer from which the data
    // was read in the first place, it can use that to minimize ArrayBuffer
    // allocations.
    if (LIKELY(buf.base == nullptr))
      buf.base = reinterpret_cast<char*>(const_cast<uint8_t*>(data));
    else
      memcpy(buf.base, data, avail);
    data += avail;
    len -= avail;
    stream->EmitRead(avail, buf);

    // If the stream owner (e.g. the JS Http2Stream) wants more data, just
    // tell nghttp2 that all data has been consumed. Otherwise, defer until
    // more data is being requested.
    if (stream->is_reading())
      nghttp2_session_consume_stream(handle, id, avail);
    else
      stream->inbound_consumed_data_while_...",6,,1190,1,,void
191302,BLOCK,-1,,<empty>,7,,1194,2,,void
191315,BLOCK,-1,,<empty>,7,,1202,2,,void
191326,BLOCK,-1,,<empty>,7,,1204,1,,void
191350,BLOCK,-1,,<empty>,7,,1213,2,,void
191356,BLOCK,-1,,<empty>,7,,1215,1,,void
191374,BLOCK,-1,,"{
      session->SendPendingData();
    }",52,,1219,2,,void
191387,BLOCK,-1,,"{
    CHECK(session->is_reading_stopped());
    session->set_receive_paused();
    Debug(session, ""receive paused"");
    return NGHTTP2_ERR_PAUSE;
  }",40,,1226,2,,void
191411,BLOCK,-1,,"{
  Http2Session* session = static_cast<Http2Session*>(user_data);
  ssize_t padding = frame->hd.length;

  switch (session->padding_strategy_) {
    case PADDING_STRATEGY_NONE:
      // Fall-through
      break;
    case PADDING_STRATEGY_MAX:
      padding = session->OnMaxFrameSizePadding(padding, maxPayloadLen);
      break;
    case PADDING_STRATEGY_ALIGNED:
      padding = session->OnDWordAlignedPadding(padding, maxPayloadLen);
      break;
  }
  return padding;
}",56,,1241,5,,void
191430,BLOCK,-1,,"{
    case PADDING_STRATEGY_NONE:
      // Fall-through
      break;
    case PADDING_STRATEGY_MAX:
      padding = session->OnMaxFrameSizePadding(padding, maxPayloadLen);
      break;
    case PADDING_STRATEGY_ALIGNED:
      padding = session->OnDWordAlignedPadding(padding, maxPayloadLen);
      break;
  }",39,,1245,2,,void
191466,BLOCK,-1,,"{
  // Unfortunately, this is currently the only way for us to know if
  // the session errored because the peer is not an http2 peer.
  Http2Session* session = static_cast<Http2Session*>(user_data);
  Debug(session, ""Error '%s'"", message);
  if (lib_error_code == NGHTTP2_ERR_SETTINGS_EXPECTED) {
    Environment* env = session->env();
    Isolate* isolate = env->isolate();
    HandleScope scope(isolate);
    Local<Context> context = env->context();
    Context::Scope context_scope(context);
    Local<Value> arg = Integer::New(isolate, NGHTTP2_ERR_PROTO);
    session->MakeCallback(env->http2session_on_error_function(), 1, &arg);
  }
  return 0;
}",50,,1265,6,,void
191481,BLOCK,-1,,"{
    Environment* env = session->env();
    Isolate* isolate = env->isolate();
    HandleScope scope(isolate);
    Local<Context> context = env->context();
    Context::Scope context_scope(context);
    Local<Value> arg = Integer::New(isolate, NGHTTP2_ERR_PROTO);
    session->MakeCallback(env->http2session_on_error_function(), 1, &arg);
  }",56,,1270,2,,void
191541,BLOCK,-1,,"{
  // See the comments in Http2Session::OnDataChunkReceived
  // (which is the only possible call site for this method).
  return uv_buf_init(nullptr, size);
}",58,,1282,2,,void
191551,BLOCK,-1,,"{
  Http2Stream* stream = static_cast<Http2Stream*>(stream_);
  Http2Session* session = stream->session();
  Environment* env = stream->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  if (nread < 0) {
    PassReadErrorToPreviousListener(nread);
    return;
  }

  Local<ArrayBuffer> ab;
  if (session->stream_buf_ab_.IsEmpty()) {
    ab = ArrayBuffer::New(env->isolate(),
                          std::move(session->stream_buf_allocation_));
    session->stream_buf_ab_.Reset(env->isolate(), ab);
  } else {
    ab = PersistentToLocal::Strong(session->stream_buf_ab_);
  }

  // There is a single large array buffer for the entire data read from the
  // network; create a slice of that array buffer and emit it as the
  // received data buffer.
  size_t offset = buf.base - session->stream_buf_.base;

  // Verify that the data offset is inside the current read buffer.
  CHECK_GE(offset, session->stream_buf_offset_);
  CHECK_LE(offset, ses...",76,,1288,3,,void
191588,BLOCK,-1,,"{
    PassReadErrorToPreviousListener(nread);
    return;
  }",18,,1295,2,,void
191604,BLOCK,-1,,"{
    ab = ArrayBuffer::New(env->isolate(),
                          std::move(session->stream_buf_allocation_));
    session->stream_buf_ab_.Reset(env->isolate(), ab);
  }",42,,1301,2,,void
191634,BLOCK,-1,,"{
    ab = PersistentToLocal::Strong(session->stream_buf_ab_);
  }",10,,1305,1,,void
191690,BLOCK,-1,,"{
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);

  int32_t id = GetFrameID(frame);
  Debug(this, ""handle headers frame for stream %d"", id);
  BaseObjectPtr<Http2Stream> stream = FindStream(id);

  // If the stream has already been destroyed, ignore.
  if (!stream || stream->is_destroyed())
    return;

  // The headers are stored as a vector of Http2Header instances.
  // The following converts that into a JS array with the structure:
  // [name1, value1, name2, value2, name3, value3, name3, value4] and so on.
  // That array is passed up to the JS layer and converted into an Object form
  // like {name1: value1, name2: value2, name3: [value3, value4]}. We do it
  // this way for performance reasons (it's faster to generate and pass an
  // array than it is to generate and pass the object).

  MaybeStackBuffer<Local<Value>, 64> headers_v(stream->headers_count() * 2);
  MaybeS...",67,,1326,2,,void
191739,BLOCK,-1,,<empty>,5,,1338,2,,void
191844,BLOCK,-1,,"{
  if (js_fields_->priority_listener_count == 0) return;
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);

  nghttp2_priority priority_frame = frame->priority;
  int32_t id = GetFrameID(frame);
  Debug(this, ""handle priority frame for stream %d"", id);
  // Priority frame stream ID should never be <= 0. nghttp2 handles this for us
  nghttp2_priority_spec spec = priority_frame.pri_spec;

  Local<Value> argv[4] = {
    Integer::New(isolate, id),
    Integer::New(isolate, spec.stream_id),
    Integer::New(isolate, spec.weight),
    Boolean::New(isolate, spec.exclusive)
  };
  MakeCallback(env()->http2session_on_priority_function(),
               arraysize(argv), argv);
}",68,,1380,2,,void
191851,BLOCK,-1,,<empty>,49,,1381,2,,void
191917,BLOCK,-1,,"{
  int32_t id = GetFrameID(frame);
  Debug(this, ""handling data frame for stream %d"", id);
  BaseObjectPtr<Http2Stream> stream = FindStream(id);

  if (stream &&
      !stream->is_destroyed() &&
      frame->hd.flags & NGHTTP2_FLAG_END_STREAM) {
    stream->EmitRead(UV_EOF);
  } else if (frame->hd.length == 0) {
    if (invalid_frame_count_++ > js_fields_->max_invalid_frames) {
      custom_recv_error_code_ = ""ERR_HTTP2_TOO_MANY_INVALID_FRAMES"";
      Debug(this, ""rejecting empty-frame-without-END_STREAM flood\n"");
      // Consider a flood of 0-length frames without END_STREAM an error.
      return 1;
    }
  }
  return 0;
}",63,,1407,2,,void
191951,BLOCK,-1,,"{
    stream->EmitRead(UV_EOF);
  }",50,,1414,2,,void
191958,BLOCK,-1,,<empty>,10,,1416,1,,void
191967,BLOCK,-1,,"{
    if (invalid_frame_count_++ > js_fields_->max_invalid_frames) {
      custom_recv_error_code_ = ""ERR_HTTP2_TOO_MANY_INVALID_FRAMES"";
      Debug(this, ""rejecting empty-frame-without-END_STREAM flood\n"");
      // Consider a flood of 0-length frames without END_STREAM an error.
      return 1;
    }
  }",37,,1416,2,,void
191975,BLOCK,-1,,"{
      custom_recv_error_code_ = ""ERR_HTTP2_TOO_MANY_INVALID_FRAMES"";
      Debug(this, ""rejecting empty-frame-without-END_STREAM flood\n"");
      // Consider a flood of 0-length frames without END_STREAM an error.
      return 1;
    }",66,,1417,2,,void
191990,BLOCK,-1,,"{
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);

  nghttp2_goaway goaway_frame = frame->goaway;
  Debug(this, ""handling goaway frame"");

  Local<Value> argv[3] = {
    Integer::NewFromUnsigned(isolate, goaway_frame.error_code),
    Integer::New(isolate, goaway_frame.last_stream_id),
    Undefined(isolate)
  };

  size_t length = goaway_frame.opaque_data_len;
  if (length > 0) {
    // If the copy fails for any reason here, we just ignore it.
    // The additional goaway data is completely optional and we
    // shouldn't fail if we're not able to process it.
    argv[2] = Buffer::Copy(isolate,
                           reinterpret_cast<char*>(goaway_frame.opaque_data),
                           length).ToLocalChecked();
  }

  MakeCallback(env()->http2session_on_goaway_data_function(),
               arraysize(argv), argv);
}",66,,1429,2,,void
192041,BLOCK,-1,,"{
    // If the copy fails for any reason here, we just ignore it.
    // The additional goaway data is completely optional and we
    // shouldn't fail if we're not able to process it.
    argv[2] = Buffer::Copy(isolate,
                           reinterpret_cast<char*>(goaway_frame.opaque_data),
                           length).ToLocalChecked();
  }",19,,1445,2,,void
192072,BLOCK,-1,,"{
  if (!(js_fields_->bitfield & (1 << kSessionHasAltsvcListeners))) return;
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);

  int32_t id = GetFrameID(frame);

  nghttp2_extension ext = frame->ext;
  nghttp2_ext_altsvc* altsvc = static_cast<nghttp2_ext_altsvc*>(ext.payload);
  Debug(this, ""handling altsvc frame"");

  Local<Value> argv[3] = {
    Integer::New(isolate, id),
    OneByteString(isolate, altsvc->origin, altsvc->origin_len),
    OneByteString(isolate, altsvc->field_value, altsvc->field_value_len)
  };

  MakeCallback(env()->http2session_on_altsvc_function(),
               arraysize(argv), argv);
}",66,,1459,2,,void
192082,BLOCK,-1,,<empty>,68,,1460,2,,void
192149,BLOCK,-1,,"{
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);

  Debug(this, ""handling origin frame"");

  nghttp2_extension ext = frame->ext;
  nghttp2_ext_origin* origin = static_cast<nghttp2_ext_origin*>(ext.payload);

  size_t nov = origin->nov;
  std::vector<Local<Value>> origin_v(nov);

  for (size_t i = 0; i < nov; ++i) {
    const nghttp2_origin_entry& entry = origin->ov[i];
    origin_v[i] = OneByteString(isolate, entry.origin, entry.origin_len);
  }
  Local<Value> holder = Array::New(isolate, origin_v.data(), origin_v.size());
  MakeCallback(env()->http2session_on_origin_function(), 1, &holder);
}",66,,1482,2,,void
192207,BLOCK,-1,,<empty>,3,,1496,1,,void
192217,BLOCK,4,,"{
    const nghttp2_origin_entry& entry = origin->ov[i];
    origin_v[i] = OneByteString(isolate, entry.origin, entry.origin_len);
  }",36,,1496,4,,void
192269,BLOCK,-1,,"{
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);
  Local<Value> arg;
  bool ack = frame->hd.flags & NGHTTP2_FLAG_ACK;
  if (ack) {
    BaseObjectPtr<Http2Ping> ping = PopPing();

    if (!ping) {
      // PING Ack is unsolicited. Treat as a connection error. The HTTP/2
      // spec does not require this, but there is no legitimate reason to
      // receive an unsolicited PING ack on a connection. Either the peer
      // is buggy or malicious, and we're not going to tolerate such
      // nonsense.
      arg = Integer::New(isolate, NGHTTP2_ERR_PROTO);
      MakeCallback(env()->http2session_on_error_function(), 1, &arg);
      return;
    }

    ping->Done(true, frame->ping.opaque_data);
    return;
  }

  if (!(js_fields_->bitfield & (1 << kSessionHasPingListeners))) return;
  // Notify the session that a ping occurred
  arg = Buffer::Copy(
      env(),
      reinterpret_cas...",64,,1505,2,,void
192310,BLOCK,-1,,"{
    BaseObjectPtr<Http2Ping> ping = PopPing();

    if (!ping) {
      // PING Ack is unsolicited. Treat as a connection error. The HTTP/2
      // spec does not require this, but there is no legitimate reason to
      // receive an unsolicited PING ack on a connection. Either the peer
      // is buggy or malicious, and we're not going to tolerate such
      // nonsense.
      arg = Integer::New(isolate, NGHTTP2_ERR_PROTO);
      MakeCallback(env()->http2session_on_error_function(), 1, &arg);
      return;
    }

    ping->Done(true, frame->ping.opaque_data);
    return;
  }",12,,1512,2,,void
192321,BLOCK,-1,,"{
      // PING Ack is unsolicited. Treat as a connection error. The HTTP/2
      // spec does not require this, but there is no legitimate reason to
      // receive an unsolicited PING ack on a connection. Either the peer
      // is buggy or malicious, and we're not going to tolerate such
      // nonsense.
      arg = Integer::New(isolate, NGHTTP2_ERR_PROTO);
      MakeCallback(env()->http2session_on_error_function(), 1, &arg);
      return;
    }",16,,1515,2,,void
192359,BLOCK,-1,,<empty>,66,,1530,2,,void
192391,BLOCK,-1,,"{
  bool ack = frame->hd.flags & NGHTTP2_FLAG_ACK;
  if (!ack) {
    js_fields_->bitfield &= ~(1 << kSessionRemoteSettingsIsUpToDate);
    if (!(js_fields_->bitfield & (1 << kSessionHasRemoteSettingsListeners)))
      return;
    // This is not a SETTINGS acknowledgement, notify and return
    MakeCallback(env()->http2session_on_settings_function(), 0, nullptr);
    return;
  }

  // If this is an acknowledgement, we should have an Http2Settings
  // object for it.
  BaseObjectPtr<Http2Settings> settings = PopSettings();
  if (settings) {
    settings->Done(true);
    return;
  }
  // SETTINGS Ack is unsolicited. Treat as a connection error. The HTTP/2
  // spec does not require this, but there is no legitimate reason to
  // receive an unsolicited SETTINGS ack on a connection. Either the peer
  // is buggy or malicious, and we're not going to tolerate such
  // nonsense.
  // Note that nghttp2 currently prevents this from happening for SETTINGS
  // frames, so this block is purely ...",68,,1540,2,,void
192405,BLOCK,-1,,"{
    js_fields_->bitfield &= ~(1 << kSessionRemoteSettingsIsUpToDate);
    if (!(js_fields_->bitfield & (1 << kSessionHasRemoteSettingsListeners)))
      return;
    // This is not a SETTINGS acknowledgement, notify and return
    MakeCallback(env()->http2session_on_settings_function(), 0, nullptr);
    return;
  }",13,,1542,2,,void
192423,BLOCK,-1,,<empty>,7,,1545,2,,void
192442,BLOCK,-1,,"{
    settings->Done(true);
    return;
  }",17,,1554,2,,void
192497,BLOCK,-1,,"{
  Debug(this, ""write finished with status %d"", status);

  CHECK(is_write_in_progress());
  set_write_in_progress(false);

  // Inform all pending writes about their completion.
  ClearOutgoing(status);

  if (is_reading_stopped() &&
      !is_write_in_progress() &&
      nghttp2_session_want_read(session_.get())) {
    set_reading_stopped(false);
    stream_->ReadStart();
  }

  if (is_destroyed()) {
    HandleScope scope(env()->isolate());
    MakeCallback(env()->ondone_string(), 0, nullptr);
    if (stream_ != nullptr) {
      // Start reading again to detect the other end finishing.
      set_reading_stopped(false);
      stream_->ReadStart();
    }
    return;
  }

  // If there is more incoming data queued up, consume it.
  if (stream_buf_offset_ > 0) {
    ConsumeHTTP2Data();
  }

  if (!is_write_scheduled() && !is_destroyed()) {
    // Schedule a new write if nghttp2 wants to send data.
    MaybeScheduleWrite();
  }
}",65,,1576,3,,void
192518,BLOCK,-1,,"{
    set_reading_stopped(false);
    stream_->ReadStart();
  }",50,,1587,2,,void
192527,BLOCK,-1,,"{
    HandleScope scope(env()->isolate());
    MakeCallback(env()->ondone_string(), 0, nullptr);
    if (stream_ != nullptr) {
      // Start reading again to detect the other end finishing.
      set_reading_stopped(false);
      stream_->ReadStart();
    }
    return;
  }",23,,1592,2,,void
192545,BLOCK,-1,,"{
      // Start reading again to detect the other end finishing.
      set_reading_stopped(false);
      stream_->ReadStart();
    }",29,,1595,2,,void
192557,BLOCK,-1,,"{
    ConsumeHTTP2Data();
  }",31,,1604,2,,void
192565,BLOCK,-1,,"{
    // Schedule a new write if nghttp2 wants to send data.
    MaybeScheduleWrite();
  }",49,,1608,2,,void
192570,BLOCK,-1,,"{
  CHECK(!is_write_scheduled());
  if (UNLIKELY(!session_))
    return;

  if (nghttp2_session_want_write(session_.get())) {
    HandleScope handle_scope(env()->isolate());
    Debug(this, ""scheduling write"");
    set_write_scheduled();
    BaseObjectPtr<Http2Session> strong_ref{this};
    env()->SetImmediate([this, strong_ref](Environment* env) {
      if (!session_ || !is_write_scheduled()) {
        // This can happen e.g. when a stream was reset before this turn
        // of the event loop, in which case SendPendingData() is called early,
        // or the session was destroyed in the meantime.
        return;
      }

      // Sending data may call arbitrary JS code, so keep track of
      // async context.
      if (env->can_call_into_js()) {
        HandleScope handle_scope(env->isolate());
        InternalCallbackScope callback_scope(this);
        SendPendingData();
      }
    });
  }
}",41,,1618,1,,void
192578,BLOCK,-1,,<empty>,5,,1621,2,,void
192586,BLOCK,-1,,"{
    HandleScope handle_scope(env()->isolate());
    Debug(this, ""scheduling write"");
    set_write_scheduled();
    BaseObjectPtr<Http2Session> strong_ref{this};
    env()->SetImmediate([this, strong_ref](Environment* env) {
      if (!session_ || !is_write_scheduled()) {
        // This can happen e.g. when a stream was reset before this turn
        // of the event loop, in which case SendPendingData() is called early,
        // or the session was destroyed in the meantime.
        return;
      }

      // Sending data may call arbitrary JS code, so keep track of
      // async context.
      if (env->can_call_into_js()) {
        HandleScope handle_scope(env->isolate());
        InternalCallbackScope callback_scope(this);
        SendPendingData();
      }
    });
  }",51,,1623,2,,void
192612,BLOCK,-1,,"{
  // If the session is already closing we don't want to stop reading as we want
  // to detect when the other peer is actually closed.
  if (is_reading_stopped() || is_closing()) return;
  int want_read = nghttp2_session_want_read(session_.get());
  Debug(this, ""wants read? %d"", want_read);
  if (want_read == 0 || is_write_in_progress()) {
    set_reading_stopped();
    stream_->ReadStop();
  }
}",39,,1647,1,,void
192617,BLOCK,-1,,<empty>,45,,1650,2,,void
192637,BLOCK,-1,,"{
    set_reading_stopped();
    stream_->ReadStop();
  }",49,,1653,2,,void
192647,BLOCK,-1,,"{
  CHECK(is_sending());

  set_sending(false);

  if (!outgoing_buffers_.empty()) {
    outgoing_storage_.clear();
    outgoing_length_ = 0;

    std::vector<NgHttp2StreamWrite> current_outgoing_buffers_;
    current_outgoing_buffers_.swap(outgoing_buffers_);
    for (const NgHttp2StreamWrite& wr : current_outgoing_buffers_) {
      BaseObjectPtr<AsyncWrap> wrap = std::move(wr.req_wrap);
      if (wrap) {
        // TODO(addaleax): Pass `status` instead of 0, so that we actually error
        // out with the error from the write to the underlying protocol,
        // if one occurred.
        WriteWrap::FromObject(wrap)->Done(0);
      }
    }
  }

  // Now that we've finished sending queued data, if there are any pending
  // RstStreams we should try sending again and then flush them one by one.
  if (!pending_rst_streams_.empty()) {
    std::vector<int32_t> current_pending_rst_streams;
    pending_rst_streams_.swap(current_pending_rst_streams);

    SendPendingData();

    for (in...",46,,1661,2,,void
192657,BLOCK,-1,,"{
    outgoing_storage_.clear();
    outgoing_length_ = 0;

    std::vector<NgHttp2StreamWrite> current_outgoing_buffers_;
    current_outgoing_buffers_.swap(outgoing_buffers_);
    for (const NgHttp2StreamWrite& wr : current_outgoing_buffers_) {
      BaseObjectPtr<AsyncWrap> wrap = std::move(wr.req_wrap);
      if (wrap) {
        // TODO(addaleax): Pass `status` instead of 0, so that we actually error
        // out with the error from the write to the underlying protocol,
        // if one occurred.
        WriteWrap::FromObject(wrap)->Done(0);
      }
    }
  }",35,,1666,2,,void
192680,BLOCK,-1,,"{
      BaseObjectPtr<AsyncWrap> wrap = std::move(wr.req_wrap);
      if (wrap) {
        // TODO(addaleax): Pass `status` instead of 0, so that we actually error
        // out with the error from the write to the underlying protocol,
        // if one occurred.
        WriteWrap::FromObject(wrap)->Done(0);
      }
    }",68,,1672,3,,void
192696,BLOCK,-1,,"{
        // TODO(addaleax): Pass `status` instead of 0, so that we actually error
        // out with the error from the write to the underlying protocol,
        // if one occurred.
        WriteWrap::FromObject(wrap)->Done(0);
      }",17,,1674,2,,void
192712,BLOCK,-1,,"{
    std::vector<int32_t> current_pending_rst_streams;
    pending_rst_streams_.swap(current_pending_rst_streams);

    SendPendingData();

    for (int32_t stream_id : current_pending_rst_streams) {
      BaseObjectPtr<Http2Stream> stream = FindStream(stream_id);
      if (LIKELY(stream))
        stream->FlushRstStream();
    }
  }",38,,1685,2,,void
192729,BLOCK,-1,,"{
      BaseObjectPtr<Http2Stream> stream = FindStream(stream_id);
      if (LIKELY(stream))
        stream->FlushRstStream();
    }",59,,1691,3,,void
192739,BLOCK,-1,,<empty>,11,,1693,1,,void
192741,BLOCK,-1,,<empty>,9,,1694,2,,void
192750,BLOCK,-1,,"{
  outgoing_length_ += write.buf.len;
  outgoing_buffers_.emplace_back(std::move(write));
}",67,,1699,2,,void
192772,BLOCK,-1,,"{
  size_t offset = outgoing_storage_.size();
  outgoing_storage_.resize(offset + src_length);
  memcpy(&outgoing_storage_[offset], src, src_length);

  // Store with a base of `nullptr` initially, since future resizes
  // of the outgoing_buffers_ vector may invalidate the pointer.
  // The correct base pointers will be set later, before writing to the
  // underlying socket.
  PushOutgoingBuffer(NgHttp2StreamWrite {
    uv_buf_init(nullptr, src_length)
  });
}",80,,1707,3,,void
192803,BLOCK,-1,,"{
  Debug(this, ""sending pending data"");
  // Do not attempt to send data on the socket if the destroying flag has
  // been set. That means everything is shutting down and the socket
  // will not be usable.
  if (is_destroyed())
    return 0;
  set_write_scheduled(false);

  // SendPendingData should not be called recursively.
  if (is_sending())
    return 1;
  // This is cleared by ClearOutgoing().
  set_sending();

  ssize_t src_length;
  const uint8_t* src;

  CHECK(outgoing_buffers_.empty());
  CHECK(outgoing_storage_.empty());

  // Part One: Gather data from nghttp2

  while ((src_length = nghttp2_session_mem_send(session_.get(), &src)) > 0) {
    Debug(this, ""nghttp2 has %d bytes to send"", src_length);
    CopyDataIntoOutgoing(src, src_length);
  }

  CHECK_NE(src_length, NGHTTP2_ERR_NOMEM);

  if (stream_ == nullptr) {
    // It would seem nice to bail out earlier, but `nghttp2_session_mem_send()`
    // does take care of things like closing the individual streams after
 ...",41,,1726,1,,void
192809,BLOCK,-1,,<empty>,5,,1732,2,,void
192816,BLOCK,-1,,<empty>,5,,1737,2,,void
192844,BLOCK,-1,,"{
    Debug(this, ""nghttp2 has %d bytes to send"", src_length);
    CopyDataIntoOutgoing(src, src_length);
  }",77,,1749,2,,void
192859,BLOCK,-1,,"{
    // It would seem nice to bail out earlier, but `nghttp2_session_mem_send()`
    // does take care of things like closing the individual streams after
    // a socket has been torn down, so we still need to call it.
    ClearOutgoing(UV_ECANCELED);
    return 0;
  }",27,,1756,2,,void
192874,BLOCK,-1,,"{
    ClearOutgoing(0);
    return 0;
  }",19,,1767,2,,void
192902,BLOCK,-1,,"{
    statistics_.data_sent += write.buf.len;
    if (write.buf.base == nullptr) {
      bufs[i++] = uv_buf_init(
          reinterpret_cast<char*>(outgoing_storage_.data() + offset),
          write.buf.len);
      offset += write.buf.len;
    } else {
      bufs[i++] = write.buf;
    }
  }",61,,1779,3,,void
192920,BLOCK,-1,,"{
      bufs[i++] = uv_buf_init(
          reinterpret_cast<char*>(outgoing_storage_.data() + offset),
          write.buf.len);
      offset += write.buf.len;
    }",36,,1781,2,,void
192948,BLOCK,-1,,"{
      bufs[i++] = write.buf;
    }",12,,1786,1,,void
192978,BLOCK,-1,,"{
    set_write_in_progress(false);
    ClearOutgoing(res.err);
  }",19,,1796,2,,void
192997,BLOCK,-1,,"{
  Http2Session* session = static_cast<Http2Session*>(user_data);
  BaseObjectPtr<Http2Stream> stream = session->FindStream(frame->hd.stream_id);
  if (!stream) return 0;

  // Send the frame header + a byte that indicates padding length.
  session->CopyDataIntoOutgoing(framehd, 9);
  if (frame->data.padlen > 0) {
    uint8_t padding_byte = frame->data.padlen - 1;
    CHECK_EQ(padding_byte, frame->data.padlen - 1);
    session->CopyDataIntoOutgoing(&padding_byte, 1);
  }

  Debug(session, ""nghttp2 has %d bytes to send directly"", length);
  while (length > 0) {
    // nghttp2 thinks that there is data available (length > 0), which means
    // we told it so, which means that we *should* have data available.
    CHECK(!stream->queue_.empty());

    NgHttp2StreamWrite& write = stream->queue_.front();
    if (write.buf.len <= length) {
      // This write does not suffice by itself, so we can consume it completely.
      length -= write.buf.len;
      session->PushOutgoingBuffer(std::m...",24,,1817,7,,void
193022,BLOCK,-1,,<empty>,16,,1820,2,,void
193039,BLOCK,-1,,"{
    uint8_t padding_byte = frame->data.padlen - 1;
    CHECK_EQ(padding_byte, frame->data.padlen - 1);
    session->CopyDataIntoOutgoing(&padding_byte, 1);
  }",31,,1824,2,,void
193074,BLOCK,-1,,"{
    // nghttp2 thinks that there is data available (length > 0), which means
    // we told it so, which means that we *should* have data available.
    CHECK(!stream->queue_.empty());

    NgHttp2StreamWrite& write = stream->queue_.front();
    if (write.buf.len <= length) {
      // This write does not suffice by itself, so we can consume it completely.
      length -= write.buf.len;
      session->PushOutgoingBuffer(std::move(write));
      stream->queue_.pop();
      continue;
    }

    // Slice off `length` bytes of the first write in the queue.
    session->PushOutgoingBuffer(NgHttp2StreamWrite {
      uv_buf_init(write.buf.base, length)
    });
    write.buf.base += length;
    write.buf.len -= length;
    break;
  }",22,,1831,2,,void
193100,BLOCK,-1,,"{
      // This write does not suffice by itself, so we can consume it completely.
      length -= write.buf.len;
      session->PushOutgoingBuffer(std::move(write));
      stream->queue_.pop();
      continue;
    }",34,,1837,2,,void
193160,BLOCK,-1,,"{
    // Send padding if that was requested.
    session->PushOutgoingBuffer(NgHttp2StreamWrite {
      uv_buf_init(const_cast<char*>(zero_bytes_256), frame->data.padlen - 1)
    });
  }",31,,1854,2,,void
193187,BLOCK,-1,,"{
  Debug(this, ""submitting request"");
  Http2Scope h2scope(this);
  Http2Stream* stream = nullptr;
  Http2Stream::Provider::Stream prov(options);
  *ret = nghttp2_submit_request(
      session_.get(),
      &priority,
      headers.data(),
      headers.length(),
      *prov,
      nullptr);
  CHECK_NE(*ret, NGHTTP2_ERR_NOMEM);
  if (LIKELY(*ret > 0))
    stream = Http2Stream::New(this, *ret, NGHTTP2_HCAT_HEADERS, options);
  return stream;
}",18,,1869,5,,void
193232,BLOCK,-1,,<empty>,5,,1883,2,,void
193250,BLOCK,-1,,"{
  return env()->allocate_managed_buffer(suggested_size);
}",61,,1887,2,,void
193262,BLOCK,-1,,"{
  HandleScope handle_scope(env()->isolate());
  Context::Scope context_scope(env()->context());
  Http2Scope h2scope(this);
  CHECK_NOT_NULL(stream_);
  Debug(this, ""receiving %d bytes, offset %d"", nread, stream_buf_offset_);
  std::unique_ptr<BackingStore> bs = env()->release_managed_buffer(buf_);

  // Only pass data on if nread > 0
  if (nread <= 0) {
    if (nread < 0) {
      PassReadErrorToPreviousListener(nread);
    }
    return;
  }

  CHECK_LE(static_cast<size_t>(nread), bs->ByteLength());

  statistics_.data_received += nread;

  if (LIKELY(stream_buf_offset_ == 0)) {
    // Shrink to the actual amount of used data.
    bs = BackingStore::Reallocate(env()->isolate(), std::move(bs), nread);
  } else {
    // This is a very unlikely case, and should only happen if the ReadStart()
    // call in OnStreamAfterWrite() immediately provides data. If that does
    // happen, we concatenate the data we received with the already-stored
    // pending input data, slicing off the a...",70,,1892,3,,void
193301,BLOCK,-1,,"{
    if (nread < 0) {
      PassReadErrorToPreviousListener(nread);
    }
    return;
  }",19,,1901,2,,void
193306,BLOCK,-1,,"{
      PassReadErrorToPreviousListener(nread);
    }",20,,1902,2,,void
193328,BLOCK,-1,,"{
    // Shrink to the actual amount of used data.
    bs = BackingStore::Reallocate(env()->isolate(), std::move(bs), nread);
  }",40,,1912,2,,void
193346,BLOCK,-1,,"{
    // This is a very unlikely case, and should only happen if the ReadStart()
    // call in OnStreamAfterWrite() immediately provides data. If that does
    // happen, we concatenate the data we received with the already-stored
    // pending input data, slicing off the already processed part.
    size_t pending_len = stream_buf_.len - stream_buf_offset_;
    std::unique_ptr<BackingStore> new_bs;
    {
      NoArrayBufferZeroFillScope no_zero_fill_scope(env()->isolate_data());
      new_bs = ArrayBuffer::NewBackingStore(env()->isolate(),
                                            pending_len + nread);
    }
    memcpy(static_cast<char*>(new_bs->Data()),
           stream_buf_.base + stream_buf_offset_,
           pending_len);
    memcpy(static_cast<char*>(new_bs->Data()) + pending_len,
           bs->Data(),
           nread);

    bs = std::move(new_bs);
    nread = bs->ByteLength();
    stream_buf_offset_ = 0;
    stream_buf_ab_.Reset();

    // We have now fully processed t...",10,,1915,1,,void
193362,BLOCK,4,,"{
      NoArrayBufferZeroFillScope no_zero_fill_scope(env()->isolate_data());
      new_bs = ArrayBuffer::NewBackingStore(env()->isolate(),
                                            pending_len + nread);
    }",5,,1922,4,,void
193460,BLOCK,-1,,"{
  for (const NgHttp2StreamWrite& wr : outgoing_buffers_) {
    if (wr.req_wrap && WriteWrap::FromObject(wr.req_wrap)->stream() == stream)
      return true;
  }
  return false;
}",68,,1961,2,,void
193464,BLOCK,-1,,"{
    if (wr.req_wrap && WriteWrap::FromObject(wr.req_wrap)->stream() == stream)
      return true;
  }",58,,1962,3,,void
193482,BLOCK,-1,,<empty>,7,,1964,2,,void
193491,BLOCK,-1,,"{
  StreamBase* stream = StreamBase::FromObject(stream_obj);
  stream->PushStreamListener(this);
  Debug(this, ""i/o stream consumed"");
}",54,,1973,2,,void
193512,BLOCK,-1,,"{
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
  CHECK(args[0]->IsObject());

  ArrayBufferViewContents<char> buffer(args[0]);
  const char* data = buffer.data();
  size_t len = buffer.length();
  Debug(session, ""Receiving %zu bytes injected from JS"", len);

  // Copy given buffer
  while (len > 0) {
    uv_buf_t buf = session->OnStreamAlloc(len);
    size_t copy = buf.len > len ? len : buf.len;
    memcpy(buf.base, data, copy);
    buf.len = copy;
    session->OnStreamRead(copy, buf);

    data += copy;
    len -= copy;
  }
}",69,,1983,2,,void
193555,BLOCK,-1,,"{
    uv_buf_t buf = session->OnStreamAlloc(len);
    size_t copy = buf.len > len ? len : buf.len;
    memcpy(buf.base, data, copy);
    buf.len = copy;
    session->OnStreamRead(copy, buf);

    data += copy;
    len -= copy;
  }",19,,1994,2,,void
193607,BLOCK,-1,,"{
  Local<Object> obj;
  if (!session->env()
           ->http2stream_constructor_template()
           ->NewInstance(session->env()->context())
           .ToLocal(&obj)) {
    return nullptr;
  }
  return new Http2Stream(session, obj, id, category, options);
}",44,,2009,5,,void
193637,BLOCK,-1,,"{
    return nullptr;
  }",28,,2014,2,,void
193656,BLOCK,-1,,"{
  MakeWeak();
  StreamBase::AttachToObject(GetObject());
  statistics_.id = id;
  statistics_.start_time = uv_hrtime();

  // Limit the number of header pairs
  max_header_pairs_ = session->max_header_pairs();
  if (max_header_pairs_ == 0) {
    max_header_pairs_ = DEFAULT_MAX_HEADER_LIST_PAIRS;
  }
  current_headers_.reserve(std::min(max_header_pairs_, 12u));

  // Limit the number of header octets
  max_header_length_ =
      std::min(
        nghttp2_session_get_local_settings(
          session->session(),
          NGHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE),
      MAX_MAX_HEADER_LIST_SIZE);

  if (options & STREAM_OPTION_GET_TRAILERS)
    set_has_trailers();

  PushStreamListener(&stream_listener_);

  if (options & STREAM_OPTION_EMPTY_PAYLOAD)
    Shutdown();
  session->AddStream(this);
}",43,,2029,6,,void
193679,BLOCK,-1,,"{
    max_header_pairs_ = DEFAULT_MAX_HEADER_LIST_PAIRS;
  }",31,,2037,2,,void
193710,BLOCK,-1,,<empty>,5,,2051,2,,void
193717,BLOCK,-1,,<empty>,5,,2056,2,,void
193727,BLOCK,-1,,"{
  Debug(this, ""tearing down stream"");
}",29,,2060,1,,void
193735,BLOCK,-1,,"{
  tracker->TrackField(""current_headers"", current_headers_);
  tracker->TrackField(""queue"", queue_);
}",60,,2064,2,,void
193751,BLOCK,-1,,"{
  const Http2Session* sess = session();
  const std::string sname =
      sess ? sess->diagnostic_name() : ""session already destroyed"";
  return ""HttpStream "" + std::to_string(id()) + "" ("" +
         std::to_string(static_cast<int64_t>(get_async_id())) + "") ["" + sname +
         ""]"";
}",50,,2069,1,,void
193794,BLOCK,-1,,"{
  Debug(this, ""starting headers, category: %d"", category);
  CHECK(!this->is_destroyed());
  session_->DecrementCurrentSessionMemory(current_headers_length_);
  current_headers_length_ = 0;
  current_headers_.clear();
  current_headers_category_ = category;
}",67,,2079,2,,void
193823,BLOCK,-1,,{ return stream(); },48,,2089,1,,void
193829,BLOCK,-1,,"{
  return nghttp2_session_find_stream(session_->session(), id_);
}",45,,2091,1,,void
193841,BLOCK,-1,,"{
  CHECK(!this->is_destroyed());
  set_closed();
  code_ = code;
  Debug(this, ""closed with code %d"", code);
}",39,,2095,2,,void
193860,BLOCK,-1,,"{
  // DoShutdown() always finishes synchronously, so there's no need to create
  // a structure to store asynchronous context.
  return nullptr;
}",69,,2102,2,,void
193867,BLOCK,-1,,"{
  if (is_destroyed())
    return UV_EPIPE;

  {
    Http2Scope h2scope(this);
    set_not_writable();
    CHECK_NE(nghttp2_session_resume_data(
        session_->session(), id_),
        NGHTTP2_ERR_NOMEM);
    Debug(this, ""writable side shutdown"");
  }
  return 1;
}",53,,2108,2,,void
193870,BLOCK,-1,,<empty>,5,,2110,2,,void
193873,BLOCK,2,,"{
    Http2Scope h2scope(this);
    set_not_writable();
    CHECK_NE(nghttp2_session_resume_data(
        session_->session(), id_),
        NGHTTP2_ERR_NOMEM);
    Debug(this, ""writable side shutdown"");
  }",3,,2112,2,,void
193894,BLOCK,-1,,"{
  // Do nothing if this stream instance is already destroyed
  if (is_destroyed())
    return;
  if (session_->has_pending_rststream(id_))
    FlushRstStream();
  set_destroyed();

  Debug(this, ""destroying stream"");

  // Wait until the start of the next loop to delete because there
  // may still be some pending operations queued for this stream.
  BaseObjectPtr<Http2Stream> strong_ref = session_->RemoveStream(id_);
  if (strong_ref) {
    env()->SetImmediate([this, strong_ref = std::move(strong_ref)](
        Environment* env) {
      // Free any remaining outgoing data chunks here. This should be done
      // here because it's possible for destroy to have been called while
      // we still have queued outbound writes.
      while (!queue_.empty()) {
        NgHttp2StreamWrite& head = queue_.front();
        if (head.req_wrap)
          WriteWrap::FromObject(head.req_wrap)->Done(UV_ECANCELED);
        queue_.pop();
      }

      // We can destroy the stream now if there are ...",29,,2126,1,,void
193897,BLOCK,-1,,<empty>,5,,2129,2,,void
193905,BLOCK,-1,,<empty>,5,,2131,2,,void
193924,BLOCK,-1,,"{
    env()->SetImmediate([this, strong_ref = std::move(strong_ref)](
        Environment* env) {
      // Free any remaining outgoing data chunks here. This should be done
      // here because it's possible for destroy to have been called while
      // we still have queued outbound writes.
      while (!queue_.empty()) {
        NgHttp2StreamWrite& head = queue_.front();
        if (head.req_wrap)
          WriteWrap::FromObject(head.req_wrap)->Done(UV_ECANCELED);
        queue_.pop();
      }

      // We can destroy the stream now if there are no writes for it
      // already on the socket. Otherwise, we'll wait for the garbage collector
      // to take care of cleaning up.
      if (session() == nullptr ||
          !session()->HasWritesOnSocketForStream(this)) {
        // Delete once strong_ref goes out of scope.
        Detach();
      }
    });
  }",19,,2139,2,,void
193962,BLOCK,-1,,"{
  CHECK(!this->is_destroyed());
  Http2Scope h2scope(this);
  Debug(this, ""submitting response"");
  if (options & STREAM_OPTION_GET_TRAILERS)
    set_has_trailers();

  if (!is_writable())
    options |= STREAM_OPTION_EMPTY_PAYLOAD;

  Http2Stream::Provider::Stream prov(this, options);
  int ret = nghttp2_submit_response(
      session_->session(),
      id_,
      headers.data(),
      headers.length(),
      *prov);
  CHECK_NE(ret, NGHTTP2_ERR_NOMEM);
  return ret;
}",75,,2173,3,,void
193979,BLOCK,-1,,<empty>,5,,2178,2,,void
193984,BLOCK,-1,,<empty>,5,,2181,2,,void
194020,BLOCK,-1,,"{
  CHECK(!this->is_destroyed());
  Http2Scope h2scope(this);
  Debug(this, ""sending %d informational headers"", headers.length());
  int ret = nghttp2_submit_headers(
      session_->session(),
      NGHTTP2_FLAG_NONE,
      id_,
      nullptr,
      headers.data(),
      headers.length(),
      nullptr);
  CHECK_NE(ret, NGHTTP2_ERR_NOMEM);
  return ret;
}",58,,2196,2,,void
194065,BLOCK,-1,,"{
  Debug(this, ""let javascript know we are ready for trailers"");
  CHECK(!this->is_destroyed());
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);
  set_has_trailers(false);
  MakeCallback(env()->http2session_on_stream_trailers_function(), 0, nullptr);
}",32,,2212,1,,void
194111,BLOCK,-1,,"{
  CHECK(!this->is_destroyed());
  Http2Scope h2scope(this);
  Debug(this, ""sending %d trailers"", headers.length());
  int ret;
  // Sending an empty trailers frame poses problems in Safari, Edge & IE.
  // Instead we can just send an empty data frame with NGHTTP2_FLAG_END_STREAM
  // to indicate that the stream is ready to be closed.
  if (headers.length() == 0) {
    Http2Stream::Provider::Stream prov(this, 0);
    ret = nghttp2_submit_data(
        session_->session(),
        NGHTTP2_FLAG_END_STREAM,
        id_,
        *prov);
  } else {
    ret = nghttp2_submit_trailer(
        session_->session(),
        id_,
        headers.data(),
        headers.length());
  }
  CHECK_NE(ret, NGHTTP2_ERR_NOMEM);
  return ret;
}",62,,2224,2,,void
194136,BLOCK,-1,,"{
    Http2Stream::Provider::Stream prov(this, 0);
    ret = nghttp2_submit_data(
        session_->session(),
        NGHTTP2_FLAG_END_STREAM,
        id_,
        *prov);
  }",30,,2232,2,,void
194153,BLOCK,-1,,"{
    ret = nghttp2_submit_trailer(
        session_->session(),
        id_,
        headers.data(),
        headers.length());
  }",10,,2239,1,,void
194180,BLOCK,-1,,"{
  CHECK(!this->is_destroyed());
  Http2Scope h2scope(this);
  Debug(this, ""sending priority spec"");
  int ret = silent ?
      nghttp2_session_change_stream_priority(
          session_->session(),
          id_,
          &priority) :
      nghttp2_submit_priority(
          session_->session(),
          NGHTTP2_FLAG_NONE,
          id_, &priority);
  CHECK_NE(ret, NGHTTP2_ERR_NOMEM);
  return ret;
}",46,,2252,3,,void
194223,BLOCK,-1,,"{
  CHECK(!this->is_destroyed());
  code_ = code;

  auto is_stream_cancel = [](const uint32_t code) {
    return code == NGHTTP2_CANCEL;
  };

  // If RST_STREAM frame is received with error code NGHTTP2_CANCEL,
  // add it to the pending list and don't force purge the data. It is
  // to avoids the double free error due to unwanted behavior of nghttp2.

  // Add stream to the pending list only if it is received with scope
  // below in the stack. The pending list may not get processed
  // if RST_STREAM received is not in scope and added to the list
  // causing endpoint to hang.
  if (session_->is_in_scope() && is_stream_cancel(code)) {
      session_->AddPendingRstStream(id_);
      return;
  }


  // If possible, force a purge of any currently pending data here to make sure
  // it is sent before closing the stream. If it returns non-zero then we need
  // to wait until the current write finishes and try again to avoid nghttp2
  // behaviour where it prioritizes RstStream over ...",56,,2271,2,,void
194245,BLOCK,-1,,"{
      session_->AddPendingRstStream(id_);
      return;
  }",58,,2287,2,,void
194259,BLOCK,-1,,"{
    session_->AddPendingRstStream(id_);
    return;
  }",41,,2297,2,,void
194270,BLOCK,-1,,"{
  if (is_destroyed())
    return;
  Http2Scope h2scope(this);
  CHECK_EQ(nghttp2_submit_rst_stream(
      session_->session(),
      NGHTTP2_FLAG_NONE,
      id_,
      code_), 0);
}",36,,2305,1,,void
194273,BLOCK,-1,,<empty>,5,,2307,2,,void
194294,BLOCK,-1,,"{
  CHECK(!this->is_destroyed());
  Http2Scope h2scope(this);
  Debug(this, ""sending push promise"");
  *ret = nghttp2_submit_push_promise(
      session_->session(),
      NGHTTP2_FLAG_NONE,
      id_,
      headers.data(),
      headers.length(),
      nullptr);
  CHECK_NE(*ret, NGHTTP2_ERR_NOMEM);
  Http2Stream* stream = nullptr;
  if (*ret > 0) {
    stream = Http2Stream::New(
        session_.get(), *ret, NGHTTP2_HCAT_HEADERS, options);
  }

  return stream;
}",58,,2320,4,,void
194339,BLOCK,-1,,"{
    stream = Http2Stream::New(
        session_.get(), *ret, NGHTTP2_HCAT_HEADERS, options);
  }",17,,2333,2,,void
194359,BLOCK,-1,,"{
  Http2Scope h2scope(this);
  CHECK(!this->is_destroyed());
  set_reading();

  Debug(this, ""reading starting"");

  // Tell nghttp2 about our consumption of the data that was handed
  // off to JS land.
  nghttp2_session_consume_stream(
      session_->session(),
      id_,
      inbound_consumed_data_while_paused_);
  inbound_consumed_data_while_paused_ = 0;

  return 0;
}",30,,2343,1,,void
194388,BLOCK,-1,,"{
  CHECK(!this->is_destroyed());
  if (!is_reading())
    return 0;
  set_paused();
  Debug(this, ""reading stopped"");
  return 0;
}",29,,2362,1,,void
194398,BLOCK,-1,,<empty>,5,,2365,2,,void
194414,BLOCK,-1,,"{
  CHECK_NULL(send_handle);
  Http2Scope h2scope(this);
  if (!is_writable() || is_destroyed()) {
    return UV_EOF;
  }
  Debug(this, ""queuing %d buffers to send"", nbufs);
  for (size_t i = 0; i < nbufs; ++i) {
    // Store the req_wrap on the last write info in the queue, so that it is
    // only marked as finished once all buffers associated with it are finished.
    queue_.emplace(NgHttp2StreamWrite {
      BaseObjectPtr<AsyncWrap>(
          i == nbufs - 1 ? req_wrap->GetAsyncWrap() : nullptr),
      bufs[i]
    });
    IncrementAvailableOutboundLength(bufs[i].len);
  }
  CHECK_NE(nghttp2_session_resume_data(
      session_->session(),
      id_), NGHTTP2_ERR_NOMEM);
  return 0;
}",52,,2384,5,,void
194425,BLOCK,-1,,"{
    return UV_EOF;
  }",41,,2387,2,,void
194433,BLOCK,-1,,<empty>,3,,2391,1,,void
194443,BLOCK,4,,"{
    // Store the req_wrap on the last write info in the queue, so that it is
    // only marked as finished once all buffers associated with it are finished.
    queue_.emplace(NgHttp2StreamWrite {
      BaseObjectPtr<AsyncWrap>(
          i == nbufs - 1 ? req_wrap->GetAsyncWrap() : nullptr),
      bufs[i]
    });
    IncrementAvailableOutboundLength(bufs[i].len);
  }",38,,2391,4,,void
194490,BLOCK,-1,,"{
  CHECK(!this->is_destroyed());

  if (Http2RcBufferPointer::IsZeroLength(name))
    return true;  // Ignore empty headers.

  Http2Header header(env(), name, value, flags);
  size_t length = header.length() + 32;
  // A header can only be added if we have not exceeded the maximum number
  // of headers and the session has memory available for it.
  if (!session_->has_available_session_memory(length) ||
      current_headers_.size() == max_header_pairs_ ||
      current_headers_length_ + length > max_header_length_) {
    return false;
  }

  if (statistics_.first_header == 0)
    statistics_.first_header = uv_hrtime();

  current_headers_.push_back(std::move(header));

  current_headers_length_ += length;
  session_->IncrementCurrentSessionMemory(length);
  return true;
}",44,,2414,4,,void
194503,BLOCK,-1,,<empty>,5,,2418,2,,void
194541,BLOCK,-1,,"{
    return false;
  }",62,,2426,2,,void
194550,BLOCK,-1,,<empty>,5,,2431,2,,void
194580,BLOCK,-1,,"{
  CHECK(!stream->is_destroyed());
  provider_.source.ptr = stream;
  empty_ = options & STREAM_OPTION_EMPTY_PAYLOAD;
}",67,,2441,3,,void
194603,BLOCK,-1,,"{
  provider_.source.ptr = nullptr;
  empty_ = options & STREAM_OPTION_EMPTY_PAYLOAD;
}",46,,2447,2,,void
194619,BLOCK,-1,,"{
  provider_.source.ptr = nullptr;
}",36,,2452,1,,void
194631,BLOCK,-1,,"{
  provider_.read_callback = Http2Stream::Provider::Stream::OnRead;
}",38,,2459,2,,void
194648,BLOCK,-1,,"{
  provider_.read_callback = Http2Stream::Provider::Stream::OnRead;
}",46,,2464,3,,void
194670,BLOCK,-1,,"{
  Http2Session* session = static_cast<Http2Session*>(user_data);
  Debug(session, ""reading outbound data for stream %d"", id);
  BaseObjectPtr<Http2Stream> stream = session->FindStream(id);
  if (!stream) return 0;
  if (stream->statistics_.first_byte_sent == 0)
    stream->statistics_.first_byte_sent = uv_hrtime();
  CHECK_EQ(id, stream->id());

  size_t amount = 0;          // amount of data being sent in this data frame.

  // Remove all empty chunks from the head of the queue.
  // This is done here so that .write('', cb) is still a meaningful way to
  // find out when the HTTP2 stream wants to consume data, and because the
  // StreamBase API allows empty input chunks.
  while (!stream->queue_.empty() && stream->queue_.front().buf.len == 0) {
    BaseObjectPtr<AsyncWrap> finished =
        std::move(stream->queue_.front().req_wrap);
    stream->queue_.pop();
    if (finished)
      WriteWrap::FromObject(finished)->Done(0);
  }

  if (!stream->queue_.empty()) {
    Debug(sessio...",64,,2474,8,,void
194695,BLOCK,-1,,<empty>,16,,2478,2,,void
194706,BLOCK,-1,,<empty>,5,,2480,2,,void
194745,BLOCK,-1,,"{
    BaseObjectPtr<AsyncWrap> finished =
        std::move(stream->queue_.front().req_wrap);
    stream->queue_.pop();
    if (finished)
      WriteWrap::FromObject(finished)->Done(0);
  }",74,,2489,2,,void
194772,BLOCK,-1,,<empty>,7,,2494,2,,void
194790,BLOCK,-1,,"{
    Debug(session, ""stream %d has pending outbound data"", id);
    amount = std::min(stream->available_outbound_length_, length);
    Debug(session, ""sending %d bytes for data frame on stream %d"", amount, id);
    if (amount > 0) {
      // Just return the length, let Http2Session::OnSendData take care of
      // actually taking the buffers out of the queue.
      *flags |= NGHTTP2_DATA_FLAG_NO_COPY;
      stream->DecrementAvailableOutboundLength(amount);
    }
  }",32,,2497,2,,void
194814,BLOCK,-1,,"{
      // Just return the length, let Http2Session::OnSendData take care of
      // actually taking the buffers out of the queue.
      *flags |= NGHTTP2_DATA_FLAG_NO_COPY;
      stream->DecrementAvailableOutboundLength(amount);
    }",21,,2501,2,,void
194833,BLOCK,-1,,"{
    CHECK(stream->queue_.empty());
    Debug(session, ""deferring stream %d"", id);
    stream->EmitWantsWrite(length);
    if (stream->available_outbound_length_ > 0 || !stream->is_writable()) {
      // EmitWantsWrite() did something interesting synchronously, restart:
      return OnRead(handle, id, buf, length, flags, source, user_data);
    }
    return NGHTTP2_ERR_DEFERRED;
  }",45,,2509,2,,void
194862,BLOCK,-1,,"{
      // EmitWantsWrite() did something interesting synchronously, restart:
      return OnRead(handle, id, buf, length, flags, source, user_data);
    }",75,,2513,2,,void
194886,BLOCK,-1,,"{
    Debug(session, ""no more data for stream %d"", id);
    *flags |= NGHTTP2_DATA_FLAG_EOF;
    if (stream->has_trailers()) {
      *flags |= NGHTTP2_DATA_FLAG_NO_END_STREAM;
      stream->OnTrailers();
    }
  }",74,,2520,2,,void
194900,BLOCK,-1,,"{
      *flags |= NGHTTP2_DATA_FLAG_NO_END_STREAM;
      stream->OnTrailers();
    }",33,,2523,2,,void
194922,BLOCK,-1,,"{
  available_outbound_length_ += amount;
  session_->IncrementCurrentSessionMemory(amount);
}",67,,2533,2,,void
194935,BLOCK,-1,,"{
  available_outbound_length_ -= amount;
  session_->DecrementCurrentSessionMemory(amount);
}",67,,2538,2,,void
194948,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  uint32_t val = args[0]->Uint32Value(env->context()).ToChecked();
  args.GetReturnValue().Set(
      OneByteString(
          env->isolate(),
          reinterpret_cast<const uint8_t*>(nghttp2_strerror(val))));
}",63,,2548,2,,void
194993,BLOCK,-1,,"{
  Http2State* state = Realm::GetBindingData<Http2State>(args);
  args.GetReturnValue().Set(Http2Settings::Pack(state));
}",60,,2561,2,,void
195020,BLOCK,-1,,"{
  Http2State* state = Realm::GetBindingData<Http2State>(args);
  Http2Settings::RefreshDefaults(state);
}",70,,2569,2,,void
195040,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
  int32_t id = args[0]->Int32Value(env->context()).ToChecked();
  if (nghttp2_session_set_next_stream_id(session->session(), id) < 0) {
    Debug(session, ""failed to set next stream id to %d"", id);
    return args.GetReturnValue().Set(false);
  }
  args.GetReturnValue().Set(true);
  Debug(session, ""set next stream id to %d"", id);
}",77,,2575,2,,void
195082,BLOCK,-1,,"{
    Debug(session, ""failed to set next stream id to %d"", id);
    return args.GetReturnValue().Set(false);
  }",71,,2580,2,,void
195112,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());

  int32_t window_size = args[0]->Int32Value(env->context()).ToChecked();

  int result = nghttp2_session_set_local_window_size(
      session->session(), NGHTTP2_FLAG_NONE, 0, window_size);

  args.GetReturnValue().Set(result);

  Debug(session, ""set local window size to %d"", window_size);
}",46,,2592,2,,void
195172,BLOCK,-1,,"{
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
  Http2Settings::Update(session, fn);
  Debug(session, ""settings refreshed for session"");
}",77,,2611,2,,void
195194,BLOCK,-1,,"{
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
  Debug(session, ""refreshing state"");

  AliasedFloat64Array& buffer = session->http2_state()->session_state_buffer;

  nghttp2_session* s = session->session();

  buffer[IDX_SESSION_STATE_EFFECTIVE_LOCAL_WINDOW_SIZE] =
      nghttp2_session_get_effective_local_window_size(s);
  buffer[IDX_SESSION_STATE_EFFECTIVE_RECV_DATA_LENGTH] =
      nghttp2_session_get_effective_recv_data_length(s);
  buffer[IDX_SESSION_STATE_NEXT_STREAM_ID] =
      nghttp2_session_get_next_stream_id(s);
  buffer[IDX_SESSION_STATE_LOCAL_WINDOW_SIZE] =
      nghttp2_session_get_local_window_size(s);
  buffer[IDX_SESSION_STATE_LAST_PROC_STREAM_ID] =
      nghttp2_session_get_last_proc_stream_id(s);
  buffer[IDX_SESSION_STATE_REMOTE_WINDOW_SIZE] =
      nghttp2_session_get_remote_window_size(s);
  buffer[IDX_SESSION_STATE_OUTBOUND_QUEUE_SIZE] =
      static_cast<double>(nghttp2_session_get_outbound_queue_size(s));
  buffer[IDX_SESSION_...",74,,2621,2,,void
195286,BLOCK,-1,,"{
  Http2State* state = Realm::GetBindingData<Http2State>(args);
  Environment* env = state->env();
  CHECK(args.IsConstructCall());
  SessionType type =
      static_cast<SessionType>(
          args[0]->Int32Value(env->context()).ToChecked());
  Http2Session* session = new Http2Session(state, args.This(), type);
  Debug(session, ""session created"");
}",65,,2652,2,,void
195345,BLOCK,-1,,"{
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
  CHECK(args[0]->IsObject());
  session->Consume(args[0].As<Object>());
}",69,,2665,2,,void
195375,BLOCK,-1,,"{
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
  Debug(session, ""destroying session"");
  Environment* env = Environment::GetCurrent(args);
  Local<Context> context = env->context();

  uint32_t code = args[0]->Uint32Value(context).ToChecked();
  session->Close(code, args[1]->IsTrue());
}",69,,2673,2,,void
195433,BLOCK,-1,,"{
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
  Environment* env = session->env();

  Local<Array> headers = args[0].As<Array>();
  int32_t options = args[1]->Int32Value(env->context()).ToChecked();

  Debug(session, ""request submitted"");

  int32_t ret = 0;
  Http2Stream* stream =
      session->Http2Session::SubmitRequest(
          Http2Priority(env, args[2], args[3], args[4]),
          Http2Headers(env, headers),
          &ret,
          static_cast<int>(options));

  if (ret <= 0 || stream == nullptr) {
    Debug(session, ""could not submit request: %s"", nghttp2_strerror(ret));
    return args.GetReturnValue().Set(ret);
  }

  Debug(session, ""request submitted, new stream id %d"", stream->id());
  args.GetReturnValue().Set(stream->object());
}",69,,2686,2,,void
195518,BLOCK,-1,,"{
    Debug(session, ""could not submit request: %s"", nghttp2_strerror(ret));
    return args.GetReturnValue().Set(ret);
  }",38,,2704,2,,void
195558,BLOCK,-1,,"{
  if (is_destroyed())
    return;

  Http2Scope h2scope(this);
  // the last proc stream id is the most recently created Http2Stream.
  if (lastStreamID <= 0)
    lastStreamID = nghttp2_session_get_last_proc_stream_id(session_.get());
  Debug(this, ""submitting goaway"");
  nghttp2_submit_goaway(session_.get(), NGHTTP2_FLAG_NONE,
                        lastStreamID, code, data, len);
}",39,,2719,5,,void
195561,BLOCK,-1,,<empty>,5,,2721,2,,void
195570,BLOCK,-1,,<empty>,5,,2726,2,,void
195595,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Local<Context> context = env->context();
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());

  uint32_t code = args[0]->Uint32Value(context).ToChecked();
  int32_t lastStreamID = args[1]->Int32Value(context).ToChecked();
  ArrayBufferViewContents<uint8_t> opaque_data;

  if (args[2]->IsArrayBufferView()) {
    opaque_data.Read(args[2].As<ArrayBufferView>());
  }

  session->Goaway(code, lastStreamID, opaque_data.data(), opaque_data.length());
}",68,,2735,2,,void
195660,BLOCK,-1,,"{
    opaque_data.Read(args[2].As<ArrayBufferView>());
  }",37,,2745,2,,void
195689,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  HandleScope scope(isolate);
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());

  uint32_t length = session->chunks_sent_since_last_write_;

  session->object()->Set(env->context(),
                         env->chunks_sent_since_last_write_string(),
                         Integer::NewFromUnsigned(isolate, length)).Check();

  args.GetReturnValue().Set(length);
}",78,,2754,2,,void
195758,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Local<Context> context = env->context();
  Http2Stream* stream;
  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());
  uint32_t code = args[0]->Uint32Value(context).ToChecked();
  Debug(stream, ""sending rst_stream with code %d"", code);
  stream->SubmitRstStream(code);
}",70,,2773,2,,void
195811,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Http2Stream* stream;
  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());

  Local<Array> headers = args[0].As<Array>();
  int32_t options = args[1]->Int32Value(env->context()).ToChecked();

  args.GetReturnValue().Set(
      stream->SubmitResponse(
          Http2Headers(env, headers),
          static_cast<int>(options)));
  Debug(stream, ""response submitted"");
}",68,,2785,2,,void
195880,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Http2Stream* stream;
  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());

  Local<Array> headers = args[0].As<Array>();

  args.GetReturnValue().Set(stream->SubmitInfo(Http2Headers(env, headers)));
}",65,,2802,2,,void
195927,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Http2Stream* stream;
  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());

  Local<Array> headers = args[0].As<Array>();

  args.GetReturnValue().Set(
      stream->SubmitTrailers(Http2Headers(env, headers)));
}",69,,2813,2,,void
195974,BLOCK,-1,,"{
  Http2Stream* stream;
  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());
  args.GetReturnValue().Set(stream->id());
}",66,,2825,2,,void
195998,BLOCK,-1,,"{
  Http2Stream* stream;
  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());
  Debug(stream, ""destroying stream"");
  stream->Destroy();
}",68,,2832,2,,void
196018,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Http2Stream* parent;
  ASSIGN_OR_RETURN_UNWRAP(&parent, args.Holder());

  Local<Array> headers = args[0].As<Array>();
  int32_t options = args[1]->Int32Value(env->context()).ToChecked();

  Debug(parent, ""creating push promise"");

  int32_t ret = 0;
  Http2Stream* stream =
      parent->SubmitPushPromise(
          Http2Headers(env, headers),
          &ret,
          static_cast<int>(options));

  if (ret <= 0 || stream == nullptr) {
    Debug(parent, ""failed to create push stream: %d"", ret);
    return args.GetReturnValue().Set(ret);
  }
  Debug(parent, ""push stream %d created"", stream->id());
  args.GetReturnValue().Set(stream->object());
}",72,,2840,2,,void
196093,BLOCK,-1,,"{
    Debug(parent, ""failed to create push stream: %d"", ret);
    return args.GetReturnValue().Set(ret);
  }",38,,2857,2,,void
196129,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Http2Stream* stream;
  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());

  CHECK_EQ(stream->SubmitPriority(
      Http2Priority(env, args[0], args[1], args[2]),
      args[3]->IsTrue()), 0);
  Debug(stream, ""priority submitted"");
}",69,,2866,2,,void
196176,BLOCK,-1,,"{
  Http2Stream* stream;
  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());

  Debug(stream, ""refreshing state"");

  CHECK_NOT_NULL(stream->session());
  AliasedFloat64Array& buffer =
      stream->session()->http2_state()->stream_state_buffer;

  nghttp2_stream* str = stream->stream();
  nghttp2_session* s = stream->session()->session();

  if (str == nullptr) {
    buffer[IDX_STREAM_STATE] = NGHTTP2_STREAM_STATE_IDLE;
    buffer[IDX_STREAM_STATE_WEIGHT] =
        buffer[IDX_STREAM_STATE_SUM_DEPENDENCY_WEIGHT] =
        buffer[IDX_STREAM_STATE_LOCAL_CLOSE] =
        buffer[IDX_STREAM_STATE_REMOTE_CLOSE] =
        buffer[IDX_STREAM_STATE_LOCAL_WINDOW_SIZE] = 0;
  } else {
    buffer[IDX_STREAM_STATE] =
        nghttp2_stream_get_state(str);
    buffer[IDX_STREAM_STATE_WEIGHT] =
        nghttp2_stream_get_weight(str);
    buffer[IDX_STREAM_STATE_SUM_DEPENDENCY_WEIGHT] =
        nghttp2_stream_get_sum_dependency_weight(str);
    buffer[IDX_STREAM_STATE_LOCAL_CLOSE] =
        nghttp2_s...",73,,2880,2,,void
196226,BLOCK,-1,,"{
    buffer[IDX_STREAM_STATE] = NGHTTP2_STREAM_STATE_IDLE;
    buffer[IDX_STREAM_STATE_WEIGHT] =
        buffer[IDX_STREAM_STATE_SUM_DEPENDENCY_WEIGHT] =
        buffer[IDX_STREAM_STATE_LOCAL_CLOSE] =
        buffer[IDX_STREAM_STATE_REMOTE_CLOSE] =
        buffer[IDX_STREAM_STATE_LOCAL_WINDOW_SIZE] = 0;
  }",23,,2893,2,,void
196254,BLOCK,-1,,"{
    buffer[IDX_STREAM_STATE] =
        nghttp2_stream_get_state(str);
    buffer[IDX_STREAM_STATE_WEIGHT] =
        nghttp2_stream_get_weight(str);
    buffer[IDX_STREAM_STATE_SUM_DEPENDENCY_WEIGHT] =
        nghttp2_stream_get_sum_dependency_weight(str);
    buffer[IDX_STREAM_STATE_LOCAL_CLOSE] =
        nghttp2_session_get_stream_local_close(s, stream->id());
    buffer[IDX_STREAM_STATE_REMOTE_CLOSE] =
        nghttp2_session_get_stream_remote_close(s, stream->id());
    buffer[IDX_STREAM_STATE_LOCAL_WINDOW_SIZE] =
        nghttp2_session_get_stream_local_window_size(s, stream->id());
  }",10,,2900,1,,void
196311,BLOCK,-1,,"{
  Http2Scope h2scope(this);
  CHECK_EQ(nghttp2_submit_altsvc(session_.get(), NGHTTP2_FLAG_NONE, id,
                                 origin, origin_len, value, value_len), 0);
}",45,,2920,6,,void
196332,BLOCK,-1,,"{
  Http2Scope h2scope(this);
  CHECK_EQ(nghttp2_submit_origin(
      session_.get(),
      NGHTTP2_FLAG_NONE,
      *origins,
      origins.length()), 0);
}",51,,2926,2,,void
196354,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());

  int32_t id = args[0]->Int32Value(env->context()).ToChecked();

  // origin and value are both required to be ASCII, handle them as such.
  Local<String> origin_str = args[1]->ToString(env->context()).ToLocalChecked();
  Local<String> value_str = args[2]->ToString(env->context()).ToLocalChecked();

  if (origin_str.IsEmpty() || value_str.IsEmpty())
    return;

  size_t origin_len = origin_str->Length();
  size_t value_len = value_str->Length();

  CHECK_LE(origin_len + value_len, 16382);  // Max permitted for ALTSVC
  // Verify that origin len != 0 if stream id == 0, or
  // that origin len == 0 if stream id != 0
  CHECK((origin_len != 0 && id == 0) || (origin_len == 0 && id != 0));

  MaybeStackBuffer<uint8_t> origin(origin_len);
  MaybeStackBuffer<uint8_t> value(value_len);
  origin_str->WriteOneByte(env->isolate(), *origin);
  value_str->WriteOneBy...",68,,2936,2,,void
196435,BLOCK,-1,,<empty>,5,,2948,2,,void
196519,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Local<Context> context = env->context();
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());

  Local<String> origin_string = args[0].As<String>();
  size_t count = args[1]->Int32Value(context).ToChecked();

  session->Origin(Origins(env, origin_string, count));
}",68,,2966,2,,void
196583,BLOCK,-1,,"{
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());

  // A PING frame may have exactly 8 bytes of payload data. If not provided,
  // then the current hrtime will be used as the payload.
  ArrayBufferViewContents<uint8_t, 8> payload;
  if (args[0]->IsArrayBufferView()) {
    payload.Read(args[0].As<ArrayBufferView>());
    CHECK_EQ(payload.length(), 8);
  }

  CHECK(args[1]->IsFunction());
  args.GetReturnValue().Set(
      session->AddPing(payload.data(), args[1].As<Function>()));
}",66,,2979,2,,void
196606,BLOCK,-1,,"{
    payload.Read(args[0].As<ArrayBufferView>());
    CHECK_EQ(payload.length(), 8);
  }",37,,2986,2,,void
196655,BLOCK,-1,,"{
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
  CHECK(args[0]->IsFunction());
  args.GetReturnValue().Set(session->AddSettings(args[0].As<Function>()));
}",70,,2997,2,,void
196691,BLOCK,-1,,"{
  BaseObjectPtr<Http2Ping> ping;
  if (!outstanding_pings_.empty()) {
    ping = std::move(outstanding_pings_.front());
    outstanding_pings_.pop();
    DecrementCurrentSessionMemory(sizeof(*ping));
  }
  return ping;
}",50,,3004,1,,void
196703,BLOCK,-1,,"{
    ping = std::move(outstanding_pings_.front());
    outstanding_pings_.pop();
    DecrementCurrentSessionMemory(sizeof(*ping));
  }",36,,3006,2,,void
196729,BLOCK,-1,,"{
  Local<Object> obj;
  if (!env()->http2ping_constructor_template()
          ->NewInstance(env()->context())
              .ToLocal(&obj)) {
    return false;
  }

  BaseObjectPtr<Http2Ping> ping =
      MakeDetachedBaseObject<Http2Ping>(this, obj, callback);
  if (!ping)
    return false;

  if (outstanding_pings_.size() == max_outstanding_pings_) {
    ping->Done(false);
    return false;
  }

  IncrementCurrentSessionMemory(sizeof(*ping));
  // The Ping itself is an Async resource. When the acknowledgement is received,
  // the callback will be invoked and a notification sent out to JS land. The
  // notification will include the duration of the ping, allowing the round
  // trip to be measured.
  ping->Send(payload);

  outstanding_pings_.emplace(std::move(ping));
  return true;
}",78,,3014,3,,void
196753,BLOCK,-1,,"{
    return false;
  }",31,,3018,2,,void
196774,BLOCK,-1,,<empty>,5,,3025,2,,void
196784,BLOCK,-1,,"{
    ping->Done(false);
    return false;
  }",60,,3027,2,,void
196815,BLOCK,-1,,"{
  BaseObjectPtr<Http2Settings> settings;
  if (!outstanding_settings_.empty()) {
    settings = std::move(outstanding_settings_.front());
    outstanding_settings_.pop();
    DecrementCurrentSessionMemory(sizeof(*settings));
  }
  return settings;
}",58,,3043,1,,void
196827,BLOCK,-1,,"{
    settings = std::move(outstanding_settings_.front());
    outstanding_settings_.pop();
    DecrementCurrentSessionMemory(sizeof(*settings));
  }",39,,3045,2,,void
196852,BLOCK,-1,,"{
  Local<Object> obj;
  if (!env()->http2settings_constructor_template()
          ->NewInstance(env()->context())
              .ToLocal(&obj)) {
    return false;
  }

  BaseObjectPtr<Http2Settings> settings =
      MakeDetachedBaseObject<Http2Settings>(this, obj, callback, 0);
  if (!settings)
    return false;

  if (outstanding_settings_.size() == max_outstanding_settings_) {
    settings->Done(false);
    return false;
  }

  IncrementCurrentSessionMemory(sizeof(*settings));
  settings->Send();
  outstanding_settings_.emplace(std::move(settings));
  return true;
}",58,,3053,2,,void
196876,BLOCK,-1,,"{
    return false;
  }",31,,3057,2,,void
196898,BLOCK,-1,,<empty>,5,,3064,2,,void
196908,BLOCK,-1,,"{
    settings->Done(false);
    return false;
  }",66,,3066,2,,void
196941,BLOCK,-1,,"{
  callback_.Reset(env()->isolate(), callback);
}",31,,3083,4,,void
196955,BLOCK,-1,,"{
  tracker->TrackField(""callback"", callback_);
}",58,,3087,2,,void
196965,BLOCK,-1,,"{
  return callback_.Get(env()->isolate());
}",45,,3091,1,,void
196979,BLOCK,-1,,"{
  CHECK(session_);
  uint8_t data[8];
  if (payload == nullptr) {
    memcpy(&data, &startTime_, arraysize(data));
    payload = data;
  }
  Http2Scope h2scope(session_.get());
  CHECK_EQ(nghttp2_submit_ping(
      session_->session(),
      NGHTTP2_FLAG_NONE,
      payload), 0);
}",46,,3095,2,,void
196986,BLOCK,-1,,"{
    memcpy(&data, &startTime_, arraysize(data));
    payload = data;
  }",27,,3098,2,,void
197017,BLOCK,-1,,"{
  uint64_t duration_ns = uv_hrtime() - startTime_;
  double duration_ms = duration_ns / 1e6;
  if (session_) session_->statistics_.ping_rtt = duration_ns;

  Isolate* isolate = env()->isolate();
  HandleScope handle_scope(isolate);
  Context::Scope context_scope(env()->context());

  Local<Value> buf = Undefined(isolate);
  if (payload != nullptr) {
    buf = Buffer::Copy(isolate,
                       reinterpret_cast<const char*>(payload),
                       8).ToLocalChecked();
  }

  Local<Value> argv[] = {
      Boolean::New(isolate, ack), Number::New(isolate, duration_ms), buf};
  MakeCallback(callback(), arraysize(argv), argv);
}",56,,3109,3,,void
197032,BLOCK,-1,,<empty>,17,,3112,2,,void
197068,BLOCK,-1,,"{
    buf = Buffer::Copy(isolate,
                       reinterpret_cast<const char*>(payload),
                       8).ToLocalChecked();
  }",27,,3119,2,,void
197108,BLOCK,-1,,"{
  session_.reset();
}",37,,3130,1,,void
197117,BLOCK,-1,,"{
  if (req_wrap)
    tracker->TrackField(""req_wrap"", req_wrap);
  tracker->TrackField(""buf"", buf);
}",67,,3134,2,,void
197120,BLOCK,-1,,<empty>,5,,3136,2,,void
197137,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK_EQ(args.Length(), 11);

#define SET_FUNCTION(arg, name)                                               \
  CHECK(args[arg]->IsFunction());                                             \
  env->set_http2session_on_ ## name ## _function(args[arg].As<Function>());

  SET_FUNCTION(0, error)
  SET_FUNCTION(1, priority)
  SET_FUNCTION(2, settings)
  SET_FUNCTION(3, ping)
  SET_FUNCTION(4, headers)
  SET_FUNCTION(5, frame_error)
  SET_FUNCTION(6, goaway_data)
  SET_FUNCTION(7, altsvc)
  SET_FUNCTION(8, origin)
  SET_FUNCTION(9, stream_trailers)
  SET_FUNCTION(10, stream_close)

#undef SET_FUNCTION
}",68,,3140,2,,void
197154,BLOCK,1,,<empty>,,,,2,,void
197174,BLOCK,1,,<empty>,,,,2,,void
197194,BLOCK,1,,<empty>,,,,2,,void
197214,BLOCK,1,,<empty>,,,,2,,void
197234,BLOCK,1,,<empty>,,,,2,,void
197254,BLOCK,1,,<empty>,,,,2,,void
197274,BLOCK,1,,<empty>,,,,2,,void
197294,BLOCK,1,,<empty>,,,,2,,void
197314,BLOCK,1,,<empty>,,,,2,,void
197334,BLOCK,1,,<empty>,,,,2,,void
197354,BLOCK,1,,<empty>,,,,2,,void
197376,BLOCK,-1,,"{
  tracker->TrackField(""root_buffer"", root_buffer);
}",59,,3169,2,,void
197390,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(context);
  Environment* env = realm->env();
  Isolate* isolate = env->isolate();
  HandleScope handle_scope(isolate);

  Http2State* const state = realm->AddBindingData<Http2State>(context, target);
  if (state == nullptr) return;

#define SET_STATE_TYPEDARRAY(name, field)             \
  target->Set(context,                                \
              FIXED_ONE_BYTE_STRING(isolate, (name)), \
              (field)).FromJust()

  // Initialize the buffer used to store the session state
  SET_STATE_TYPEDARRAY(
    ""sessionState"", state->session_state_buffer.GetJSArray());
  // Initialize the buffer used to store the stream state
  SET_STATE_TYPEDARRAY(
    ""streamState"", state->stream_state_buffer.GetJSArray());
  SET_STATE_TYPEDARRAY(
    ""settingsBuffer"", state->settings_buffer.GetJSArray());
  SET_STATE_TYPEDARRAY(
    ""optionsBuffer"", state->options_buffer.GetJSArray());
  SET_STATE_TYPEDARRAY(
    ""streamStats"", state->stream_stats_buffer...",29,,3177,5,,void
197433,BLOCK,-1,,<empty>,25,,3184,2,,void
197443,BLOCK,1,,<empty>,,,,5,,void
197469,BLOCK,1,,<empty>,,,,5,,void
197495,BLOCK,1,,<empty>,,,,5,,void
197521,BLOCK,1,,<empty>,,,,5,,void
197547,BLOCK,1,,<empty>,,,,5,,void
197573,BLOCK,1,,<empty>,,,,5,,void
197596,BLOCK,1,,<empty>,,,,7,,void
197598,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kBitfield)",3,,3207,1,,void
197695,BLOCK,1,,<empty>,,,,7,,void
197697,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kSessionPriorityListenerCount)",3,,3208,1,,void
197794,BLOCK,1,,<empty>,,,,7,,void
197796,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kSessionFrameErrorListenerCount)",3,,3209,1,,void
197893,BLOCK,1,,<empty>,,,,7,,void
197895,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kSessionMaxInvalidFrames)",3,,3210,1,,void
197992,BLOCK,1,,<empty>,,,,7,,void
197994,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kSessionMaxRejectedStreams)",3,,3211,1,,void
198091,BLOCK,1,,<empty>,,,,7,,void
198093,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kSessionUint8FieldCount)",3,,3212,1,,void
198190,BLOCK,1,,<empty>,,,,7,,void
198192,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kSessionHasRemoteSettingsListeners)",3,,3214,1,,void
198289,BLOCK,1,,<empty>,,,,7,,void
198291,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kSessionRemoteSettingsIsUpToDate)",3,,3215,1,,void
198388,BLOCK,1,,<empty>,,,,7,,void
198390,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kSessionHasPingListeners)",3,,3216,1,,void
198487,BLOCK,1,,<empty>,,,,7,,void
198489,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kSessionHasAltsvcListeners)",3,,3217,1,,void
199012,BLOCK,1,,<empty>,,,,7,,void
199014,BLOCK,-1,,"NODE_DEFINE_CONSTANT(constants, NGHTTP2_DEFAULT_WEIGHT)",3,,3318,1,,void
199156,BLOCK,-1,,<empty>,1,,1,1,,ANY
199163,BLOCK,-1,,<empty>,1,,1,1,,ANY
199180,BLOCK,-1,,<empty>,1,,1,1,,ANY
199185,BLOCK,-1,,"{
  v8::Local<v8::Value> header_string =
      headers->Get(env->context(), 0).ToLocalChecked();
  v8::Local<v8::Value> header_count =
      headers->Get(env->context(), 1).ToLocalChecked();
  CHECK(header_count->IsUint32());
  CHECK(header_string->IsString());
  count_ = header_count.As<v8::Uint32>()->Value();
  int header_string_len = header_string.As<v8::String>()->Length();

  if (count_ == 0) {
    CHECK_EQ(header_string_len, 0);
    return;
  }

  buf_.AllocateSufficientStorage((alignof(nv_t) - 1) +
                                 count_ * sizeof(nv_t) +
                                 header_string_len);

  char* start = AlignUp(buf_.out(), alignof(nv_t));
  char* header_contents = start + (count_ * sizeof(nv_t));
  nv_t* const nva = reinterpret_cast<nv_t*>(start);

  CHECK_LE(header_contents + header_string_len, *buf_ + buf_.length());
  CHECK_EQ(header_string.As<v8::String>()->WriteOneByte(
               env->isolate(),
               reinterpret_cast<uint8_t*>(header_co...",73,,15,3,,void
199263,BLOCK,-1,,"{
    CHECK_EQ(header_string_len, 0);
    return;
  }",20,,25,2,,void
199348,BLOCK,-1,,<empty>,3,,49,1,,void
199359,BLOCK,4,,"{
    if (n >= count_) {
      static uint8_t zero = '\0';
      nva[0].name = nva[0].value = &zero;
      nva[0].namelen = nva[0].valuelen = 1;
      count_ = 1;
      return;
    }

    nva[n].name = reinterpret_cast<uint8_t*>(p);
    nva[n].namelen = strlen(p);
    p += nva[n].namelen + 1;
    nva[n].value = reinterpret_cast<uint8_t*>(p);
    nva[n].valuelen = strlen(p);
    p += nva[n].valuelen + 1;
    nva[n].flags = *p;
    p++;
  }",75,,49,4,,void
199364,BLOCK,-1,,"{
      static uint8_t zero = '\0';
      nva[0].name = nva[0].value = &zero;
      nva[0].namelen = nva[0].valuelen = 1;
      count_ = 1;
      return;
    }",22,,50,2,,void
199466,BLOCK,-1,,"{
  static constexpr size_t min_header_pairs = 1;
  return std::max(max_header_pairs, min_header_pairs);
}",57,,69,2,,void
199482,BLOCK,-1,,"{
  static constexpr size_t min_header_pairs = 4;
  return std::max(max_header_pairs, min_header_pairs);
}",57,,74,2,,void
199497,BLOCK,-1,,"{
  std::string ret = name();
  ret += "" = "";
  ret += value();
  return ret;
}",57,,80,1,,void
199515,BLOCK,-1,,"{
  return IsZeroLength(-1, name, value);
}",34,,90,3,,void
199528,BLOCK,-1,,"{

  if (NgHeader<T>::rcbufferpointer_t::IsZeroLength(value))
    return true;

  const char* header_name = T::ToHttpHeaderName(token);
  return header_name != nullptr ||
      NgHeader<T>::rcbufferpointer_t::IsZeroLength(name);
}",34,,98,4,,void
199539,BLOCK,-1,,<empty>,5,,101,2,,void
199571,BLOCK,-1,,<empty>,48,,114,5,,void
199580,BLOCK,-1,,"{
  if (token == -1) {
    CHECK_NOT_NULL(name);
    name_.reset(name, true);  // Internalizable
  }
  CHECK_NOT_NULL(value);
  name_.reset(name, true);  // Internalizable
  value_.reset(value);
}",62,,122,6,,void
199586,BLOCK,-1,,"{
    CHECK_NOT_NULL(name);
    name_.reset(name, true);  // Internalizable
  }",20,,123,2,,void
199612,BLOCK,-1,,"{
  other.token_ = -1;
  other.flags_ = 0;
  other.env_ = nullptr;
}",28,,138,2,,void
199633,BLOCK,-1,,"{
  tracker->TrackField(""name"", name_);
  tracker->TrackField(""value"", value_);
}",60,,145,2,,void
199650,BLOCK,-1,,"{

  // Not all instances will support using token id's for header names.
  // HTTP/2 specifically does not support it.
  const char* header_name = T::ToHttpHeaderName(token_);

  // If header_name is not nullptr, then it is a known header with
  // a statically defined name. We can safely internalize it here.
  if (header_name != nullptr) {
    auto& static_str_map = env_->isolate_data()->static_str_map;
    v8::Eternal<v8::String> eternal = static_str_map[header_name];
    if (eternal.IsEmpty()) {
      v8::Local<v8::String> str = OneByteString(env_->isolate(), header_name);
      eternal.Set(env_->isolate(), str);
      return str;
    }
    return eternal.Get(env_->isolate());
  }
  return rcbufferpointer_t::External::New(allocator, name_);
}",48,,152,2,,void
199663,BLOCK,-1,,"{
    auto& static_str_map = env_->isolate_data()->static_str_map;
    v8::Eternal<v8::String> eternal = static_str_map[header_name];
    if (eternal.IsEmpty()) {
      v8::Local<v8::String> str = OneByteString(env_->isolate(), header_name);
      eternal.Set(env_->isolate(), str);
      return str;
    }
    return eternal.Get(env_->isolate());
  }",31,,160,2,,void
199691,BLOCK,-1,,"{
      v8::Local<v8::String> str = OneByteString(env_->isolate(), header_name);
      eternal.Set(env_->isolate(), str);
      return str;
    }",28,,163,2,,void
199741,BLOCK,-1,,"{
  return rcbufferpointer_t::External::New(allocator, value_);
}",48,,175,2,,void
199754,BLOCK,-1,,"{
  return name_.str();
}",39,,180,1,,void
199763,BLOCK,-1,,"{
  return value_.str();
}",40,,185,1,,void
199772,BLOCK,-1,,"{
  return name_.len() + value_.len();
}",36,,190,1,,void
199786,BLOCK,-1,,"{
  return flags_;
}",36,,195,1,,void
199801,BLOCK,-1,,<empty>,1,,1,1,,ANY
199804,BLOCK,-1,,"{
      if (buf.base == binding_data_->parser_buffer.data())
        binding_data_->parser_buffer_in_use = false;
      else
        free(buf.base);
    }",46,,761,1,,void
199816,BLOCK,-1,,<empty>,9,,763,2,,void
199823,BLOCK,-1,,<empty>,9,,765,1,,void
199858,BLOCK,-1,,<empty>,1,,1,1,,ANY
199925,BLOCK,-1,,"{
  return c == ' ' || c == '\t';
}",27,,90,2,,void
199940,BLOCK,-1,,<empty>,73,,96,3,,void
199949,BLOCK,-1,,"{
    tracker->TrackField(""parser_buffer"", parser_buffer);
  }",58,,103,2,,void
199963,BLOCK,-1,,<empty>,,,,1,,<empty>
199971,BLOCK,-1,,"{
    on_heap_ = false;
    Reset();
  }",15,,112,1,,void
199979,BLOCK,-1,,"{
    Reset();
  }",16,,118,1,,void
199984,BLOCK,-1,,"{
    if (!on_heap_ && size_ > 0) {
      char* s = new char[size_];
      memcpy(s, str_, size_);
      str_ = s;
      on_heap_ = true;
    }
  }",15,,126,1,,void
199992,BLOCK,-1,,"{
      char* s = new char[size_];
      memcpy(s, str_, size_);
      str_ = s;
      on_heap_ = true;
    }",33,,127,2,,void
200011,BLOCK,-1,,"{
    if (on_heap_) {
      delete[] str_;
      on_heap_ = false;
    }

    str_ = nullptr;
    size_ = 0;
  }",16,,136,1,,void
200014,BLOCK,-1,,"{
      delete[] str_;
      on_heap_ = false;
    }",19,,137,2,,void
200031,BLOCK,-1,,"{
    if (str_ == nullptr) {
      str_ = str;
    } else if (on_heap_ || str_ + size_ != str) {
      // Non-consecutive input, make a copy on the heap.
      // TODO(bnoordhuis) Use slab allocation, O(n) allocs is bad.
      char* s = new char[size_ + size];
      memcpy(s, str_, size_);
      memcpy(s + size_, str, size);

      if (on_heap_)
        delete[] str_;
      else
        on_heap_ = true;

      str_ = s;
    }
    size_ += size;
  }",45,,147,3,,void
200036,BLOCK,-1,,"{
      str_ = str;
    }",26,,148,2,,void
200041,BLOCK,-1,,<empty>,12,,150,1,,void
200050,BLOCK,-1,,"{
      // Non-consecutive input, make a copy on the heap.
      // TODO(bnoordhuis) Use slab allocation, O(n) allocs is bad.
      char* s = new char[size_ + size];
      memcpy(s, str_, size_);
      memcpy(s + size_, str, size);

      if (on_heap_)
        delete[] str_;
      else
        on_heap_ = true;

      str_ = s;
    }",49,,150,2,,void
200068,BLOCK,-1,,<empty>,9,,158,2,,void
200072,BLOCK,-1,,<empty>,9,,160,1,,void
200086,BLOCK,-1,,"{
    if (size_ != 0)
      return OneByteString(env->isolate(), str_, size_);
    else
      return String::Empty(env->isolate());
  }",50,,168,2,,void
200091,BLOCK,-1,,<empty>,7,,170,2,,void
200101,BLOCK,-1,,<empty>,7,,172,1,,void
200115,BLOCK,-1,,"{
    while (size_ > 0 && IsOWS(str_[size_ - 1])) {
      size_--;
    }
    return ToString(env);
  }",51,,177,2,,void
200127,BLOCK,-1,,"{
      size_--;
    }",49,,178,2,,void
200143,BLOCK,-1,,<empty>,,,,3,,<empty>
200149,BLOCK,-1,,<empty>,,,,2,,<empty>
200154,BLOCK,-1,,<empty>,,,,2,,<empty>
200159,BLOCK,-1,,<empty>,,,,2,,<empty>
200164,BLOCK,-1,,<empty>,,,,2,,<empty>
200169,BLOCK,-1,,<empty>,,,,2,,<empty>
200174,BLOCK,-1,,"{
      all_connections_.insert(parser);
    }",31,,208,2,,void
200184,BLOCK,-1,,"{
      all_connections_.erase(parser);
    }",30,,212,2,,void
200194,BLOCK,-1,,"{
      active_connections_.insert(parser);
    }",37,,216,2,,void
200204,BLOCK,-1,,"{
      active_connections_.erase(parser);
    }",36,,220,2,,void
200220,BLOCK,-1,,"{
  }",37,,247,3,,void
200227,BLOCK,-1,,"{
    int rv = TrackHeader(length);
    if (rv != 0) {
      return rv;
    }

    url_.Update(at, length);
    return 0;
  }",45,,289,3,,void
200237,BLOCK,-1,,"{
      return rv;
    }",18,,291,2,,void
200253,BLOCK,-1,,"{
    int rv = TrackHeader(length);
    if (rv != 0) {
      return rv;
    }

    status_message_.Update(at, length);
    return 0;
  }",48,,300,3,,void
200263,BLOCK,-1,,"{
      return rv;
    }",18,,302,2,,void
200279,BLOCK,-1,,"{
    int rv = TrackHeader(length);
    if (rv != 0) {
      return rv;
    }

    if (num_fields_ == num_values_) {
      // start of new field name
      num_fields_++;
      if (num_fields_ == kMaxHeaderFieldsCount) {
        // ran out of space - flush to javascript land
        Flush();
        num_fields_ = 1;
        num_values_ = 0;
      }
      fields_[num_fields_ - 1].Reset();
    }

    CHECK_LT(num_fields_, kMaxHeaderFieldsCount);
    CHECK_EQ(num_fields_, num_values_ + 1);

    fields_[num_fields_ - 1].Update(at, length);

    return 0;
  }",54,,311,3,,void
200289,BLOCK,-1,,"{
      return rv;
    }",18,,313,2,,void
200296,BLOCK,-1,,"{
      // start of new field name
      num_fields_++;
      if (num_fields_ == kMaxHeaderFieldsCount) {
        // ran out of space - flush to javascript land
        Flush();
        num_fields_ = 1;
        num_values_ = 0;
      }
      fields_[num_fields_ - 1].Reset();
    }",37,,317,2,,void
200303,BLOCK,-1,,"{
        // ran out of space - flush to javascript land
        Flush();
        num_fields_ = 1;
        num_values_ = 0;
      }",49,,320,2,,void
200344,BLOCK,-1,,"{
    int rv = TrackHeader(length);
    if (rv != 0) {
      return rv;
    }

    if (num_values_ != num_fields_) {
      // start of new header value
      num_values_++;
      values_[num_values_ - 1].Reset();
    }

    CHECK_LT(num_values_, arraysize(values_));
    CHECK_EQ(num_values_, num_fields_);

    values_[num_values_ - 1].Update(at, length);

    return 0;
  }",54,,338,3,,void
200354,BLOCK,-1,,"{
      return rv;
    }",18,,340,2,,void
200361,BLOCK,-1,,"{
      // start of new header value
      num_values_++;
      values_[num_values_ - 1].Reset();
    }",37,,344,2,,void
200394,BLOCK,-1,,"{
    headers_completed_ = true;
    header_nread_ = 0;

    // Arguments for the on-headers-complete javascript callback. This
    // list needs to be kept in sync with the actual argument list for
    // `parserOnHeadersComplete` in lib/_http_common.js.
    enum on_headers_complete_arg_index {
      A_VERSION_MAJOR = 0,
      A_VERSION_MINOR,
      A_HEADERS,
      A_METHOD,
      A_URL,
      A_STATUS_CODE,
      A_STATUS_MESSAGE,
      A_UPGRADE,
      A_SHOULD_KEEP_ALIVE,
      A_MAX
    };

    Local<Value> argv[A_MAX];
    Local<Object> obj = object();
    Local<Value> cb = obj->Get(env()->context(),
                               kOnHeadersComplete).ToLocalChecked();

    if (!cb->IsFunction())
      return 0;

    Local<Value> undefined = Undefined(env()->isolate());
    for (size_t i = 0; i < arraysize(argv); i++)
      argv[i] = undefined;

    if (have_flushed_) {
      // Slow case, flush remaining headers.
      Flush();
    } else {
      // Fast case, pass headers an...",29,,359,1,,void
200439,BLOCK,-1,,<empty>,7,,385,2,,void
200454,BLOCK,-1,,<empty>,5,,388,1,,void
200472,BLOCK,-1,,"{
      // Slow case, flush remaining headers.
      Flush();
    }",24,,391,2,,void
200475,BLOCK,-1,,"{
      // Fast case, pass headers and URL to JS land.
      argv[A_HEADERS] = CreateHeaders();
      if (parser_.type == HTTP_REQUEST)
        argv[A_URL] = url_.ToString(env());
    }",12,,394,1,,void
200487,BLOCK,-1,,<empty>,9,,398,2,,void
200509,BLOCK,-1,,"{
      argv[A_METHOD] =
          Uint32::NewFromUnsigned(env()->isolate(), parser_.method);
    }",39,,405,2,,void
200531,BLOCK,-1,,"{
      argv[A_STATUS_CODE] =
          Integer::New(env()->isolate(), parser_.status_code);
      argv[A_STATUS_MESSAGE] = status_message_.ToString(env());
    }",40,,411,2,,void
200625,BLOCK,21,,"{
      InternalCallbackScope callback_scope(
          this, InternalCallbackScope::kSkipTaskQueues);
      head_response = cb.As<Function>()->Call(
          env()->context(), object(), arraysize(argv), argv);
      if (head_response.IsEmpty()) callback_scope.MarkAsFailed();
    }",5,,430,21,,void
200654,BLOCK,-1,,<empty>,36,,435,2,,void
200683,BLOCK,-1,,"{
      got_exception_ = true;
      return -1;
    }",52,,442,2,,void
200699,BLOCK,-1,,"{
    if (length == 0)
      return 0;

    Environment* env = this->env();
    HandleScope handle_scope(env->isolate());

    Local<Value> cb = object()->Get(env->context(), kOnBody).ToLocalChecked();

    if (!cb->IsFunction())
      return 0;

    Local<Value> buffer = Buffer::Copy(env, at, length).ToLocalChecked();

    MaybeLocal<Value> r = MakeCallback(cb.As<Function>(), 1, &buffer);

    if (r.IsEmpty()) {
      got_exception_ = true;
      llhttp_set_error_reason(&parser_, ""HPE_JS_EXCEPTION:JS Exception"");
      return HPE_USER;
    }

    return 0;
  }",46,,451,3,,void
200704,BLOCK,-1,,<empty>,7,,453,2,,void
200744,BLOCK,-1,,<empty>,7,,461,2,,void
200782,BLOCK,-1,,"{
      got_exception_ = true;
      llhttp_set_error_reason(&parser_, ""HPE_JS_EXCEPTION:JS Exception"");
      return HPE_USER;
    }",22,,467,2,,void
200797,BLOCK,-1,,"{
    HandleScope scope(env()->isolate());

    // Important: Pop from the lists BEFORE resetting the last_message_start_
    // otherwise std::set.erase will fail.
    if (connectionsList_ != nullptr) {
      connectionsList_->Pop(this);
      connectionsList_->PopActive(this);
    }

    last_message_start_ = 0;

    if (connectionsList_ != nullptr) {
      connectionsList_->Push(this);
    }

    if (num_fields_)
      Flush();  // Flush trailing HTTP headers.

    Local<Object> obj = object();
    Local<Value> cb = obj->Get(env()->context(),
                               kOnMessageComplete).ToLocalChecked();

    if (!cb->IsFunction())
      return 0;

    MaybeLocal<Value> r;
    {
      InternalCallbackScope callback_scope(
          this, InternalCallbackScope::kSkipTaskQueues);
      r = cb.As<Function>()->Call(env()->context(), object(), 0, nullptr);
      if (r.IsEmpty()) callback_scope.MarkAsFailed();
    }

    if (r.IsEmpty()) {
      got_exception_ = true;
      retur...",29,,477,1,,void
200808,BLOCK,-1,,"{
      connectionsList_->Pop(this);
      connectionsList_->PopActive(this);
    }",38,,482,2,,void
200826,BLOCK,-1,,"{
      connectionsList_->Push(this);
    }",38,,489,2,,void
200834,BLOCK,-1,,<empty>,7,,494,2,,void
200867,BLOCK,-1,,<empty>,7,,501,2,,void
200875,BLOCK,11,,"{
      InternalCallbackScope callback_scope(
          this, InternalCallbackScope::kSkipTaskQueues);
      r = cb.As<Function>()->Call(env()->context(), object(), 0, nullptr);
      if (r.IsEmpty()) callback_scope.MarkAsFailed();
    }",5,,504,11,,void
200903,BLOCK,-1,,<empty>,24,,508,2,,void
200913,BLOCK,-1,,"{
      got_exception_ = true;
      return -1;
    }",22,,511,2,,void
200925,BLOCK,-1,,"{
    header_nread_ = 0;
    return 0;
  }",25,,520,1,,void
200934,BLOCK,-1,,"{
    header_nread_ = 0;
    return 0;
  }",27,,527,1,,void
200944,BLOCK,-1,,"{
    BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
    new Parser(binding_data, args.This());
  }",60,,532,2,,void
200966,BLOCK,-1,,"{
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    delete parser;
  }",62,,538,2,,void
200981,BLOCK,-1,,"{
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    // Since the Parser destructor isn't going to run the destroy() callbacks
    // it needs to be triggered manually.
    parser->EmitTraceEventDestroy();
    parser->EmitDestroy();
  }",61,,546,2,,void
201002,BLOCK,-1,,"{
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    if (parser->connectionsList_ != nullptr) {
      parser->connectionsList_->Pop(parser);
      parser->connectionsList_->PopActive(parser);
    }
  }",63,,556,2,,void
201017,BLOCK,-1,,"{
      parser->connectionsList_->Pop(parser);
      parser->connectionsList_->PopActive(parser);
    }",46,,560,2,,void
201035,BLOCK,-1,,"{
    url_.Save();
    status_message_.Save();

    for (size_t i = 0; i < num_fields_; i++) {
      fields_[i].Save();
    }

    for (size_t i = 0; i < num_values_; i++) {
      values_[i].Save();
    }
  }",15,,566,1,,void
201045,BLOCK,-1,,<empty>,5,,570,1,,void
201055,BLOCK,4,,"{
      fields_[i].Save();
    }",46,,570,4,,void
201063,BLOCK,-1,,<empty>,5,,574,1,,void
201073,BLOCK,4,,"{
      values_[i].Save();
    }",46,,574,4,,void
201084,BLOCK,-1,,"{
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    ArrayBufferViewContents<char> buffer(args[0]);

    Local<Value> ret = parser->Execute(buffer.data(), buffer.length());

    if (!ret.IsEmpty())
      args.GetReturnValue().Set(ret);
  }",64,,580,2,,void
201122,BLOCK,-1,,<empty>,7,,589,2,,void
201135,BLOCK,-1,,"{
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    Local<Value> ret = parser->Execute(nullptr, 0);

    if (!ret.IsEmpty())
      args.GetReturnValue().Set(ret);
  }",63,,593,2,,void
201162,BLOCK,-1,,<empty>,7,,600,2,,void
201175,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(args);

    uint64_t max_http_header_size = 0;
    uint32_t lenient_flags = kLenientNone;
    ConnectionsList* connectionsList = nullptr;

    CHECK(args[0]->IsInt32());
    CHECK(args[1]->IsObject());

    if (args.Length() > 2) {
      CHECK(args[2]->IsNumber());
      max_http_header_size =
          static_cast<uint64_t>(args[2].As<Number>()->Value());
    }
    if (max_http_header_size == 0) {
      max_http_header_size = env->options()->max_http_header_size;
    }

    if (args.Length() > 3) {
      CHECK(args[3]->IsInt32());
      lenient_flags = args[3].As<Int32>()->Value();
    }

    if (args.Length() > 4 && !args[4]->IsNullOrUndefined()) {
      CHECK(args[4]->IsObject());
      ASSIGN_OR_RETURN_UNWRAP(&connectionsList, args[4]);
    }

    llhttp_type_t type =
        static_cast<llhttp_type_t>(args[0].As<Int32>()->Value());

    CHECK(type == HTTP_REQUEST || type == HTTP_RESPONSE);
    Parser* parser;
    ASSIGN_OR_RETURN...",67,,604,2,,void
201217,BLOCK,-1,,"{
      CHECK(args[2]->IsNumber());
      max_http_header_size =
          static_cast<uint64_t>(args[2].As<Number>()->Value());
    }",28,,614,2,,void
201242,BLOCK,-1,,"{
      max_http_header_size = env->options()->max_http_header_size;
    }",36,,619,2,,void
201258,BLOCK,-1,,"{
      CHECK(args[3]->IsInt32());
      lenient_flags = args[3].As<Int32>()->Value();
    }",28,,623,2,,void
201292,BLOCK,-1,,"{
      CHECK(args[4]->IsObject());
      ASSIGN_OR_RETURN_UNWRAP(&connectionsList, args[4]);
    }",61,,628,2,,void
201381,BLOCK,-1,,"{
      parser->connectionsList_ = connectionsList;

      // This protects from a DoS attack where an attacker establishes
      // the connection without sending any data on applications where
      // server.timeout is left to the default value of zero.
      parser->last_message_start_ = uv_hrtime();

      // Important: Push into the lists AFTER setting the last_message_start_
      // otherwise std::set.erase will fail later.
      parser->connectionsList_->Push(parser);
      parser->connectionsList_->PushActive(parser);
    }",37,,651,2,,void
201407,BLOCK,-1,,"{
      parser->connectionsList_ = nullptr;
    }",12,,663,1,,void
201417,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(args);
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());
    // Should always be called from the same context.
    CHECK_EQ(env, parser->env());

    if constexpr (should_pause) {
      llhttp_pause(&parser->parser_);
    } else {
      llhttp_resume(&parser->parser_);
    }
  }",62,,669,2,,void
201442,BLOCK,-1,,"{
      llhttp_pause(&parser->parser_);
    }",33,,676,2,,void
201449,BLOCK,-1,,"{
      llhttp_resume(&parser->parser_);
    }",12,,678,1,,void
201459,BLOCK,-1,,"{
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());
    CHECK(args[0]->IsObject());
    StreamBase* stream = StreamBase::FromObject(args[0].As<Object>());
    CHECK_NOT_NULL(stream);
    stream->PushStreamListener(parser);
  }",64,,684,2,,void
201499,BLOCK,-1,,"{
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    // Already unconsumed
    if (parser->stream_ == nullptr)
      return;

    parser->stream_->RemoveStreamListener(parser);
  }",66,,694,2,,void
201514,BLOCK,-1,,<empty>,7,,700,2,,void
201527,BLOCK,-1,,"{
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    Local<Object> ret = Buffer::Copy(
        parser->env(),
        parser->current_buffer_data_,
        parser->current_buffer_len_).ToLocalChecked();

    args.GetReturnValue().Set(ret);
  }",73,,706,2,,void
201571,BLOCK,-1,,"{
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    if (parser->last_message_start_ == 0) {
      args.GetReturnValue().Set(0);
      return;
    }

    double duration = (uv_hrtime() - parser->last_message_start_) / 1e6;
    args.GetReturnValue().Set(duration);
  }",65,,718,2,,void
201586,BLOCK,-1,,"{
      args.GetReturnValue().Set(0);
      return;
    }",43,,722,2,,void
201618,BLOCK,-1,,"{
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    args.GetReturnValue().Set(parser->headers_completed_);
  }",73,,731,2,,void
201642,BLOCK,-1,,"{
    // For most types of streams, OnStreamRead will be immediately after
    // OnStreamAlloc, and will consume all data, so using a static buffer for
    // reading is more efficient. For other streams, just use Malloc() directly.
    if (binding_data_->parser_buffer_in_use)
      return uv_buf_init(Malloc(suggested_size), suggested_size);
    binding_data_->parser_buffer_in_use = true;

    if (binding_data_->parser_buffer.empty())
      binding_data_->parser_buffer.resize(kAllocBufferSize);

    return uv_buf_init(binding_data_->parser_buffer.data(), kAllocBufferSize);
  }",58,,741,2,,void
201647,BLOCK,-1,,<empty>,7,,746,2,,void
201665,BLOCK,-1,,<empty>,7,,750,2,,void
201686,BLOCK,-1,,"{
    HandleScope scope(env()->isolate());
    // Once were done here, either indicate that the HTTP parser buffer
    // is free for re-use, or free() the data if it didnt come from there
    // in the first place.
    auto on_scope_leave = OnScopeLeave([&]() {
      if (buf.base == binding_data_->parser_buffer.data())
        binding_data_->parser_buffer_in_use = false;
      else
        free(buf.base);
    });

    if (nread < 0) {
      PassReadErrorToPreviousListener(nread);
      return;
    }

    // Ignore, empty reads have special meaning in http parser
    if (nread == 0)
      return;

    Local<Value> ret = Execute(buf.base, nread);

    // Exception
    if (ret.IsEmpty())
      return;

    Local<Value> cb =
        object()->Get(env()->context(), kOnExecute).ToLocalChecked();

    if (!cb->IsFunction())
      return;

    // Hooks for GetCurrentBuffer
    current_buffer_len_ = nread;
    current_buffer_data_ = buf.base;

    MakeCallback(cb.As<Function>(), 1, &ret);...",66,,756,3,,void
201702,BLOCK,-1,,"{
      PassReadErrorToPreviousListener(nread);
      return;
    }",20,,768,2,,void
201710,BLOCK,-1,,<empty>,7,,775,2,,void
201728,BLOCK,-1,,<empty>,7,,781,2,,void
201754,BLOCK,-1,,<empty>,7,,787,2,,void
201783,BLOCK,-1,,"{
    EscapableHandleScope scope(env()->isolate());

    current_buffer_len_ = len;
    current_buffer_data_ = data;
    got_exception_ = false;

    llhttp_errno_t err;

    if (data == nullptr) {
      err = llhttp_finish(&parser_);
    } else {
      err = llhttp_execute(&parser_, data, len);
      Save();
    }

    // Calculate bytes read and resume after Upgrade/CONNECT pause
    size_t nread = len;
    if (err != HPE_OK) {
      nread = llhttp_get_error_pos(&parser_) - data;

      // This isn't a real pause, just a way to stop parsing early.
      if (err == HPE_PAUSED_UPGRADE) {
        err = HPE_OK;
        llhttp_resume_after_upgrade(&parser_);
      }
    }

    // Apply pending pause
    if (pending_pause_) {
      pending_pause_ = false;
      llhttp_pause(&parser_);
    }

    current_buffer_len_ = 0;
    current_buffer_data_ = nullptr;

    // If there was an exception in one of the callbacks
    if (got_exception_)
      return scope.Escape(Local<Value>());

    Loc...",54,,800,3,,void
201804,BLOCK,-1,,"{
      err = llhttp_finish(&parser_);
    }",26,,809,2,,void
201811,BLOCK,-1,,"{
      err = llhttp_execute(&parser_, data, len);
      Save();
    }",12,,811,1,,void
201828,BLOCK,-1,,"{
      nread = llhttp_get_error_pos(&parser_) - data;

      // This isn't a real pause, just a way to stop parsing early.
      if (err == HPE_PAUSED_UPGRADE) {
        err = HPE_OK;
        llhttp_resume_after_upgrade(&parser_);
      }
    }",24,,818,2,,void
201840,BLOCK,-1,,"{
        err = HPE_OK;
        llhttp_resume_after_upgrade(&parser_);
      }",38,,822,2,,void
201849,BLOCK,-1,,"{
      pending_pause_ = false;
      llhttp_pause(&parser_);
    }",25,,829,2,,void
201864,BLOCK,-1,,<empty>,7,,839,2,,void
201895,BLOCK,-1,,"{
      Local<Value> e = Exception::Error(env()->parse_error_string());
      Local<Object> obj = e->ToObject(env()->isolate()->GetCurrentContext())
        .ToLocalChecked();
      obj->Set(env()->context(),
               env()->bytes_parsed_string(),
               nread_obj).Check();
      const char* errno_reason = llhttp_get_error_reason(&parser_);

      Local<String> code;
      Local<String> reason;
      if (err == HPE_USER) {
        const char* colon = strchr(errno_reason, ':');
        CHECK_NOT_NULL(colon);
        code = OneByteString(env()->isolate(),
                             errno_reason,
                             static_cast<int>(colon - errno_reason));
        reason = OneByteString(env()->isolate(), colon + 1);
      } else {
        code = OneByteString(env()->isolate(), llhttp_errno_name(err));
        reason = OneByteString(env()->isolate(), errno_reason);
      }

      obj->Set(env()->context(), env()->code_string(), code).Check();
      obj->Set(env(...",44,,845,2,,void
201966,BLOCK,-1,,"{
        const char* colon = strchr(errno_reason, ':');
        CHECK_NOT_NULL(colon);
        code = OneByteString(env()->isolate(),
                             errno_reason,
                             static_cast<int>(colon - errno_reason));
        reason = OneByteString(env()->isolate(), colon + 1);
      }",28,,856,2,,void
201999,BLOCK,-1,,"{
        code = OneByteString(env()->isolate(), llhttp_errno_name(err));
        reason = OneByteString(env()->isolate(), errno_reason);
      }",14,,863,1,,void
202059,BLOCK,-1,,"{
      return scope.Escape(Local<Value>());
    }",26,,874,2,,void
202075,BLOCK,-1,,"{
    // There could be extra entries but the max size should be fixed
    Local<Value> headers_v[kMaxHeaderFieldsCount * 2];

    for (size_t i = 0; i < num_values_; ++i) {
      headers_v[i * 2] = fields_[i].ToString(env());
      headers_v[i * 2 + 1] = values_[i].ToTrimmedString(env());
    }

    return Array::New(env()->isolate(), headers_v, num_values_ * 2);
  }",32,,880,1,,void
202086,BLOCK,-1,,<empty>,5,,884,1,,void
202096,BLOCK,4,,"{
      headers_v[i * 2] = fields_[i].ToString(env());
      headers_v[i * 2 + 1] = values_[i].ToTrimmedString(env());
    }",46,,884,4,,void
202141,BLOCK,-1,,"{
    HandleScope scope(env()->isolate());

    Local<Object> obj = object();
    Local<Value> cb = obj->Get(env()->context(), kOnHeaders).ToLocalChecked();

    if (!cb->IsFunction())
      return;

    Local<Value> argv[2] = {
      CreateHeaders(),
      url_.ToString(env())
    };

    MaybeLocal<Value> r = MakeCallback(cb.As<Function>(),
                                       arraysize(argv),
                                       argv);

    if (r.IsEmpty())
      got_exception_ = true;

    url_.Reset();
    have_flushed_ = true;
  }",16,,894,1,,void
202179,BLOCK,-1,,<empty>,7,,901,2,,void
202208,BLOCK,-1,,<empty>,7,,913,2,,void
202225,BLOCK,-1,,"{
    llhttp_init(&parser_, type, &settings);

    if (lenient_flags & kLenientHeaders) {
      llhttp_set_lenient_headers(&parser_, 1);
    }
    if (lenient_flags & kLenientChunkedLength) {
      llhttp_set_lenient_chunked_length(&parser_, 1);
    }
    if (lenient_flags & kLenientKeepAlive) {
      llhttp_set_lenient_keep_alive(&parser_, 1);
    }

    header_nread_ = 0;
    url_.Reset();
    status_message_.Reset();
    num_fields_ = 0;
    num_values_ = 0;
    have_flushed_ = false;
    got_exception_ = false;
    headers_completed_ = false;
    max_http_header_size_ = max_http_header_size;
  }",37,,921,4,,void
202236,BLOCK,-1,,"{
      llhttp_set_lenient_headers(&parser_, 1);
    }",42,,924,2,,void
202245,BLOCK,-1,,"{
      llhttp_set_lenient_chunked_length(&parser_, 1);
    }",48,,927,2,,void
202254,BLOCK,-1,,"{
      llhttp_set_lenient_keep_alive(&parser_, 1);
    }",44,,930,2,,void
202292,BLOCK,-1,,"{
    header_nread_ += len;
    if (header_nread_ >= max_http_header_size_) {
      llhttp_set_error_reason(&parser_, ""HPE_HEADER_OVERFLOW:Header overflow"");
      return HPE_USER;
    }
    return 0;
  }",31,,946,2,,void
202300,BLOCK,-1,,"{
      llhttp_set_error_reason(&parser_, ""HPE_HEADER_OVERFLOW:Header overflow"");
      return HPE_USER;
    }",49,,948,2,,void
202312,BLOCK,-1,,"{
    if (!pending_pause_) {
      return 0;
    }

    pending_pause_ = false;
    llhttp_set_error_reason(&parser_, ""Paused in callback"");
    return HPE_PAUSED;
  }",20,,956,1,,void
202316,BLOCK,-1,,"{
      return 0;
    }",26,,957,2,,void
202331,BLOCK,-1,,"{
    // HTTP parsers are able to emit events without any GC root referring
    // to them, because they receive events directly from the underlying
    // libuv resource.
    return true;
  }",59,,967,1,,void
202359,BLOCK,-1,,"{
      Parser* parser = ContainerOf(&Parser::parser_, p);
      int rv = (parser->*Member)(std::forward<Args>(args)...);
      if (rv == 0) {
        rv = parser->MaybePause();
      }
      return rv;
    }",48,,1000,3,,void
202387,BLOCK,-1,,"{
        rv = parser->MaybePause();
      }",20,,1003,2,,void
202399,BLOCK,-1,,<empty>,,,,1,,<empty>
202405,BLOCK,-1,,<empty>,,,,3,,<empty>
202410,BLOCK,-1,,<empty>,,,,1,,<empty>
202434,BLOCK,-1,,"{
  if (lhs->last_message_start_ == 0 && rhs->last_message_start_ == 0) {
    // When both parsers are idle, guarantee strict order by
    // comparing pointers as ints.
    return lhs < rhs;
  } else if (lhs->last_message_start_ == 0) {
    return true;
  } else if (rhs->last_message_start_ == 0) {
    return false;
  }

  return lhs->last_message_start_ < rhs->last_message_start_;
}",79,,1016,3,,void
202447,BLOCK,-1,,"{
    // When both parsers are idle, guarantee strict order by
    // comparing pointers as ints.
    return lhs < rhs;
  }",71,,1017,2,,void
202453,BLOCK,-1,,<empty>,10,,1021,1,,void
202460,BLOCK,-1,,"{
    return true;
  }",45,,1021,2,,void
202464,BLOCK,-1,,<empty>,10,,1023,1,,void
202471,BLOCK,-1,,"{
    return false;
  }",45,,1023,2,,void
202486,BLOCK,-1,,"{
  Local<Context> context = args.GetIsolate()->GetCurrentContext();
  Environment* env = Environment::GetCurrent(context);

  new ConnectionsList(env, args.This());
}",68,,1030,2,,void
202519,BLOCK,-1,,"{
  Isolate* isolate = args.GetIsolate();

  ConnectionsList* list;

  ASSIGN_OR_RETURN_UNWRAP(&list, args.Holder());

  std::vector<Local<Value>> result;
  result.reserve(list->all_connections_.size());
  for (auto parser : list->all_connections_) {
    result.emplace_back(parser->object());
  }

  return args.GetReturnValue().Set(
      Array::New(isolate, result.data(), result.size()));
}",68,,1037,2,,void
202559,BLOCK,-1,,"{
    result.emplace_back(parser->object());
  }",46,,1046,3,,void
202593,BLOCK,-1,,"{
  Isolate* isolate = args.GetIsolate();

  ConnectionsList* list;

  ASSIGN_OR_RETURN_UNWRAP(&list, args.Holder());

  std::vector<Local<Value>> result;
  result.reserve(list->all_connections_.size());
  for (auto parser : list->all_connections_) {
    if (parser->last_message_start_ == 0) {
      result.emplace_back(parser->object());
    }
  }

  return args.GetReturnValue().Set(
      Array::New(isolate, result.data(), result.size()));
}",69,,1054,2,,void
202633,BLOCK,-1,,"{
    if (parser->last_message_start_ == 0) {
      result.emplace_back(parser->object());
    }
  }",46,,1063,3,,void
202640,BLOCK,-1,,"{
      result.emplace_back(parser->object());
    }",43,,1064,2,,void
202674,BLOCK,-1,,"{
  Isolate* isolate = args.GetIsolate();

  ConnectionsList* list;

  ASSIGN_OR_RETURN_UNWRAP(&list, args.Holder());

  std::vector<Local<Value>> result;
  result.reserve(list->active_connections_.size());
  for (auto parser : list->active_connections_) {
    result.emplace_back(parser->object());
  }

  return args.GetReturnValue().Set(
      Array::New(isolate, result.data(), result.size()));
}",71,,1073,2,,void
202714,BLOCK,-1,,"{
    result.emplace_back(parser->object());
  }",49,,1082,3,,void
202748,BLOCK,-1,,"{
  Isolate* isolate = args.GetIsolate();

  ConnectionsList* list;

  ASSIGN_OR_RETURN_UNWRAP(&list, args.Holder());
  CHECK(args[0]->IsNumber());
  CHECK(args[1]->IsNumber());
  uint64_t headers_timeout =
    static_cast<uint64_t>(args[0].As<Uint32>()->Value()) * 1000000;
  uint64_t request_timeout =
    static_cast<uint64_t>(args[1].As<Uint32>()->Value()) * 1000000;

  if (headers_timeout == 0 && request_timeout == 0) {
    return args.GetReturnValue().Set(Array::New(isolate, 0));
  } else if (request_timeout > 0 && headers_timeout > request_timeout) {
    std::swap(headers_timeout, request_timeout);
  }

  // On IoT or embedded devices the uv_hrtime() may return the timestamp
  // that is smaller than configured timeout for headers or request
  // to prevent subtracting two unsigned integers
  // that can yield incorrect results we should check
  // if the 'now' is bigger than the timeout for headers or request
  const uint64_t now = uv_hrtime();
  const uint64_t headers_deadlin...",72,,1090,2,,void
202818,BLOCK,-1,,"{
    return args.GetReturnValue().Set(Array::New(isolate, 0));
  }",53,,1103,2,,void
202834,BLOCK,-1,,<empty>,10,,1105,1,,void
202843,BLOCK,-1,,"{
    std::swap(headers_timeout, request_timeout);
  }",72,,1105,2,,void
202892,BLOCK,-1,,"{
    return args.GetReturnValue().Set(Array::New(isolate, 0));
  }",55,,1122,2,,void
202948,BLOCK,-1,,"{
    Parser* parser = *iter;
    iter++;

    // Check for expiration.
    if (
      (!parser->headers_completed_ && headers_deadline > 0 &&
        parser->last_message_start_ < headers_deadline) ||
      (
        request_deadline > 0 &&
        parser->last_message_start_ < request_deadline)
    ) {
      result.emplace_back(parser->object());

      list->active_connections_.erase(parser);
    }
  }",23,,1131,2,,void
202981,BLOCK,-1,,"{
      result.emplace_back(parser->object());

      list->active_connections_.erase(parser);
    }",7,,1142,2,,void
203072,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(context);
  Environment* env = realm->env();
  Isolate* isolate = env->isolate();
  BindingData* const binding_data =
      realm->AddBindingData<BindingData>(context, target);
  if (binding_data == nullptr) return;

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, Parser::New);
  t->InstanceTemplate()->SetInternalFieldCount(Parser::kInternalFieldCount);

  t->Set(FIXED_ONE_BYTE_STRING(env->isolate(), ""REQUEST""),
         Integer::New(env->isolate(), HTTP_REQUEST));
  t->Set(FIXED_ONE_BYTE_STRING(env->isolate(), ""RESPONSE""),
         Integer::New(env->isolate(), HTTP_RESPONSE));
  t->Set(FIXED_ONE_BYTE_STRING(env->isolate(), ""kOnMessageBegin""),
         Integer::NewFromUnsigned(env->isolate(), kOnMessageBegin));
  t->Set(FIXED_ONE_BYTE_STRING(env->isolate(), ""kOnHeaders""),
         Integer::NewFromUnsigned(env->isolate(), kOnHeaders));
  t->Set(FIXED_ONE_BYTE_STRING(env->isolate(), ""kOnHeadersComplete""),
         Integer::NewFromUnsigne...",39,,1202,5,,void
203112,BLOCK,-1,,<empty>,32,,1208,2,,void
203649,BLOCK,-1,,<empty>,1,,1,1,,ANY
203666,BLOCK,-1,,<empty>,1,,1,1,,ANY
203695,BLOCK,-1,,<empty>,1,,1,1,,ANY
203710,BLOCK,-1,,<empty>,1,,1,1,,ANY
203714,BLOCK,-1,,"{
  return node::Start(argc, argv);
}",34,,96,3,,void
203760,BLOCK,-1,,<empty>,1,,1,1,,ANY
203768,BLOCK,-1,,"{
  isolate_params_->array_buffer_allocator = array_buffer_allocator_.get();

  isolate_ =
      NewIsolate(isolate_params_.get(), event_loop, platform, snapshot_data);
  CHECK_NOT_NULL(isolate_);

  // If the indexes are not nullptr, we are not deserializing
  isolate_data_.reset(
      CreateIsolateData(isolate_,
                        event_loop,
                        platform,
                        array_buffer_allocator_.get(),
                        snapshot_data->AsEmbedderWrapper().get()));
  isolate_data_->set_is_building_snapshot(
      per_process::cli_options->per_isolate->build_snapshot);

  isolate_data_->max_young_gen_size =
      isolate_params_->constraints.max_young_generation_size_in_bytes();
}",37,,45,6,,void
203831,BLOCK,-1,,"{
  if (isolate_params_ == nullptr) {
    return;
  }
  // This should only be done on a main instance that owns its isolate.
  platform_->UnregisterIsolate(isolate_);
  isolate_->Dispose();
}",39,,66,1,,void
203836,BLOCK,-1,,"{
    return;
  }",35,,67,2,,void
203850,BLOCK,-1,,"{
  Locker locker(isolate_);
  Isolate::Scope isolate_scope(isolate_);
  HandleScope handle_scope(isolate_);

  ExitCode exit_code = ExitCode::kNoFailure;
  DeleteFnPtr<Environment, FreeEnvironment> env =
      CreateMainEnvironment(&exit_code);
  CHECK_NOT_NULL(env);

  Context::Scope context_scope(env->context());
  Run(&exit_code, env.get());
  return exit_code;
}",34,,75,1,,void
203898,BLOCK,-1,,"{
  if (*exit_code == ExitCode::kNoFailure) {
    bool runs_sea_code = false;
#ifndef DISABLE_SINGLE_EXECUTABLE_APPLICATION
    if (sea::IsSingleExecutable()) {
      runs_sea_code = true;
      sea::SeaResource sea = sea::FindSingleExecutableResource();
      std::string_view code = sea.code;
      LoadEnvironment(env, code);
    }
#endif
    if (!runs_sea_code) {
      LoadEnvironment(env, StartExecutionCallback{});
    }

    *exit_code =
        SpinEventLoopInternal(env).FromMaybe(ExitCode::kGenericUserError);
  }

#if defined(LEAK_SANITIZER)
  __lsan_do_leak_check();
#endif
}",67,,90,3,,void
203906,BLOCK,-1,,"{
    bool runs_sea_code = false;
#ifndef DISABLE_SINGLE_EXECUTABLE_APPLICATION
    if (sea::IsSingleExecutable()) {
      runs_sea_code = true;
      sea::SeaResource sea = sea::FindSingleExecutableResource();
      std::string_view code = sea.code;
      LoadEnvironment(env, code);
    }
#endif
    if (!runs_sea_code) {
      LoadEnvironment(env, StartExecutionCallback{});
    }

    *exit_code =
        SpinEventLoopInternal(env).FromMaybe(ExitCode::kGenericUserError);
  }",43,,91,2,,void
203916,BLOCK,-1,,"{
      runs_sea_code = true;
      sea::SeaResource sea = sea::FindSingleExecutableResource();
      std::string_view code = sea.code;
      LoadEnvironment(env, code);
    }",36,,94,2,,void
203939,BLOCK,-1,,"{
      LoadEnvironment(env, StartExecutionCallback{});
    }",25,,101,2,,void
203959,BLOCK,-1,,"{
  *exit_code = ExitCode::kNoFailure;  // Reset the exit code to 0

  HandleScope handle_scope(isolate_);

  // TODO(addaleax): This should load a real per-Isolate option, currently
  // this is still effectively per-process.
  if (isolate_data_->options()->track_heap_objects) {
    isolate_->GetHeapProfiler()->StartTrackingHeapObjects(true);
  }

  Local<Context> context;
  DeleteFnPtr<Environment, FreeEnvironment> env;

  if (snapshot_data_ != nullptr) {
    env.reset(CreateEnvironment(isolate_data_.get(),
                                Local<Context>(),  // read from snapshot
                                args_,
                                exec_args_));
#if HAVE_OPENSSL
    crypto::InitCryptoOnce(isolate_);
#endif  // HAVE_OPENSSL
  } else {
    context = NewContext(isolate_);
    CHECK(!context.IsEmpty());
    Context::Scope context_scope(context);
    env.reset(
        CreateEnvironment(isolate_data_.get(), context, args_, exec_args_));
  }

  return env;
}",62,,115,2,,void
203976,BLOCK,-1,,"{
    isolate_->GetHeapProfiler()->StartTrackingHeapObjects(true);
  }",53,,122,2,,void
204001,BLOCK,-1,,"{
    env.reset(CreateEnvironment(isolate_data_.get(),
                                Local<Context>(),  // read from snapshot
                                args_,
                                exec_args_));
#if HAVE_OPENSSL
    crypto::InitCryptoOnce(isolate_);
#endif  // HAVE_OPENSSL
  }",34,,129,2,,void
204015,BLOCK,-1,,"{
    context = NewContext(isolate_);
    CHECK(!context.IsEmpty());
    Context::Scope context_scope(context);
    env.reset(
        CreateEnvironment(isolate_data_.get(), context, args_, exec_args_));
  }",10,,137,1,,void
204063,BLOCK,-1,,<empty>,1,,1,1,,ANY
204072,BLOCK,-1,,<empty>,1,,1,1,,ANY
204079,BLOCK,-1,,<empty>,1,,1,1,,ANY
204082,BLOCK,-1,,"{
    for (BaseObjectPtr<BaseObject> object : host_objects) {
      if (!object) continue;

      // If the function did not finish successfully, host_objects will contain
      // a list of objects that will never be passed to JS. Therefore, we
      // destroy them here.
      object->Detach();
    }
  }",37,,166,1,,void
204086,BLOCK,-1,,"{
      if (!object) continue;

      // If the function did not finish successfully, host_objects will contain
      // a list of objects that will never be passed to JS. Therefore, we
      // destroy them here.
      object->Detach();
    }",59,,167,3,,void
204090,BLOCK,-1,,<empty>,20,,168,2,,void
204102,BLOCK,-1,,"{
    // Called when data has been put into the queue.
    MessagePort* channel = ContainerOf(&MessagePort::async_, handle);
    channel->OnMessage(MessageProcessingMode::kNormalOperation);
  }",43,,641,2,,void
204123,BLOCK,-1,,{ if (!succeeded) Close(); },37,,652,1,,void
204127,BLOCK,-1,,<empty>,55,,652,2,,void
204155,BLOCK,-1,,<empty>,1,,1,1,,ANY
204166,BLOCK,-1,,"{
  return BaseObject::TransferMode::kUntransferable;
}",62,,50,1,,void
204176,BLOCK,-1,,"{
  return CloneForMessaging();
}",74,,54,1,,void
204182,BLOCK,-1,,"{
  return {};
}",77,,58,1,,void
204187,BLOCK,-1,,"{
  return Just(BaseObjectList {});
}",63,,62,1,,void
204197,BLOCK,-1,,"{
  return Just(true);
}",62,,67,3,,void
204207,BLOCK,-1,,"{
  return Just(true);
}",58,,74,3,,void
204215,BLOCK,-1,,<empty>,44,,79,2,,void
204219,BLOCK,-1,,"{
  return main_message_buf_.data == nullptr;
}",38,,81,1,,void
204237,BLOCK,-1,,<empty>,55,,101,7,,void
204242,BLOCK,-1,,"{
    // Identifying the index in the message's BaseObject array is sufficient.
    uint32_t id;
    if (!deserializer->ReadUint32(&id))
      return MaybeLocal<Object>();
    if (id != kNormalObject) {
      CHECK_LT(id, host_objects_.size());
      return host_objects_[id]->object(isolate);
    }
    EscapableHandleScope scope(isolate);
    Local<Context> context = isolate->GetCurrentContext();
    Local<Value> object;
    if (!deserializer->ReadValue(context).ToLocal(&object))
      return MaybeLocal<Object>();
    CHECK(object->IsObject());
    return scope.Escape(object.As<Object>());
  }",64,,103,2,,void
204252,BLOCK,-1,,<empty>,7,,107,2,,void
204259,BLOCK,-1,,"{
      CHECK_LT(id, host_objects_.size());
      return host_objects_[id]->object(isolate);
    }",30,,108,2,,void
204304,BLOCK,-1,,<empty>,7,,116,2,,void
204326,BLOCK,-1,,"{
    CHECK_LT(clone_id, shared_array_buffers_.size());
    return shared_array_buffers_[clone_id];
  }",53,,122,3,,void
204342,BLOCK,-1,,"{
    CHECK_LT(transfer_id, wasm_modules_.size());
    return WasmModuleObject::FromCompiledModule(
        isolate, wasm_modules_[transfer_id]);
  }",56,,128,3,,void
204362,BLOCK,-1,,"{
    CHECK(shared_value_conveyor_.has_value());
    return &shared_value_conveyor_.value();
  }",80,,134,2,,void
204382,BLOCK,-1,,<empty>,,,,1,,<empty>
204392,BLOCK,-1,,"{
  Context::Scope context_scope(context);

  CHECK(!IsCloseMessage());
  if (port_list != nullptr && !transferables_.empty()) {
    // Need to create this outside of the EscapableHandleScope, but inside
    // the Context::Scope.
    *port_list = Array::New(env->isolate());
  }

  EscapableHandleScope handle_scope(env->isolate());

  // Create all necessary objects for transferables, e.g. MessagePort handles.
  std::vector<BaseObjectPtr<BaseObject>> host_objects(transferables_.size());
  auto cleanup = OnScopeLeave([&]() {
    for (BaseObjectPtr<BaseObject> object : host_objects) {
      if (!object) continue;

      // If the function did not finish successfully, host_objects will contain
      // a list of objects that will never be passed to JS. Therefore, we
      // destroy them here.
      object->Detach();
    }
  });

  for (uint32_t i = 0; i < transferables_.size(); ++i) {
    HandleScope handle_scope(env->isolate());
    TransferData* data = transferables_[i].get();
    h...",65,,152,4,,void
204409,BLOCK,-1,,"{
    // Need to create this outside of the EscapableHandleScope, but inside
    // the Context::Scope.
    *port_list = Array::New(env->isolate());
  }",56,,156,2,,void
204446,BLOCK,-1,,<empty>,3,,177,1,,void
204459,BLOCK,4,,"{
    HandleScope handle_scope(env->isolate());
    TransferData* data = transferables_[i].get();
    host_objects[i] = data->Deserialize(
        env, context, std::move(transferables_[i]));
    if (!host_objects[i]) return {};
    if (port_list != nullptr) {
      // If we gather a list of all message ports, and this transferred object
      // is a message port, add it to that list. This is a bit of an odd case
      // of special handling for MessagePorts (as opposed to applying to all
      // transferables), but it's required for spec compliance.
      DCHECK((*port_list)->IsArray());
      Local<Array> port_list_array = port_list->As<Array>();
      Local<Object> obj = host_objects[i]->object();
      if (env->message_port_constructor_template()->HasInstance(obj)) {
        if (port_list_array->Set(context,
                                 port_list_array->Length(),
                                 obj).IsNothing()) {
          return {};
        }
      }
    }
  }",56,,177,4,,void
204497,BLOCK,-1,,<empty>,27,,182,2,,void
204503,BLOCK,-1,,"{
      // If we gather a list of all message ports, and this transferred object
      // is a message port, add it to that list. This is a bit of an odd case
      // of special handling for MessagePorts (as opposed to applying to all
      // transferables), but it's required for spec compliance.
      DCHECK((*port_list)->IsArray());
      Local<Array> port_list_array = port_list->As<Array>();
      Local<Object> obj = host_objects[i]->object();
      if (env->message_port_constructor_template()->HasInstance(obj)) {
        if (port_list_array->Set(context,
                                 port_list_array->Length(),
                                 obj).IsNothing()) {
          return {};
        }
      }
    }",31,,183,2,,void
204541,BLOCK,-1,,"{
        if (port_list_array->Set(context,
                                 port_list_array->Length(),
                                 obj).IsNothing()) {
          return {};
        }
      }",71,,191,2,,void
204556,BLOCK,-1,,"{
          return {};
        }",52,,194,2,,void
204572,BLOCK,-1,,<empty>,3,,204,1,,void
204585,BLOCK,4,,"{
    Local<SharedArrayBuffer> sab =
        SharedArrayBuffer::New(env->isolate(), shared_array_buffers_[i]);
    shared_array_buffers.push_back(sab);
  }",63,,204,4,,void
204639,BLOCK,-1,,<empty>,3,,224,1,,void
204652,BLOCK,4,,"{
    Local<ArrayBuffer> ab =
        ArrayBuffer::New(env->isolate(), std::move(array_buffers_[i]));
    deserializer.TransferArrayBuffer(i, ab);
  }",56,,224,4,,void
204689,BLOCK,-1,,<empty>,5,,231,2,,void
204708,BLOCK,-1,,<empty>,5,,234,2,,void
204713,BLOCK,-1,,"{
    if (base_object->FinalizeTransferRead(context, &deserializer).IsNothing())
      return {};
  }",62,,236,3,,void
204725,BLOCK,-1,,<empty>,7,,238,2,,void
204741,BLOCK,-1,,"{
  shared_array_buffers_.emplace_back(std::move(backing_store));
}",50,,246,2,,void
204755,BLOCK,-1,,"{
  transferables_.emplace_back(std::move(data));
}",69,,250,2,,void
204769,BLOCK,-1,,"{
  wasm_modules_.emplace_back(std::move(mod));
  return wasm_modules_.size() - 1;
}",59,,254,2,,void
204790,BLOCK,-1,,"{
  shared_value_conveyor_.emplace(std::move(conveyor));
}",72,,259,2,,void
204805,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  Local<Object> per_context_bindings;
  Local<Value> emit_message_val;
  if (!GetPerContextExports(context).ToLocal(&per_context_bindings) ||
      !per_context_bindings->Get(context,
                                FIXED_ONE_BYTE_STRING(isolate, ""emitMessage""))
          .ToLocal(&emit_message_val)) {
    return MaybeLocal<Function>();
  }
  CHECK(emit_message_val->IsFunction());
  return emit_message_val.As<Function>();
}",69,,265,2,,void
204847,BLOCK,-1,,"{
    return MaybeLocal<Function>();
  }",40,,272,2,,void
204864,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  Local<Object> per_context_bindings;
  Local<Value> domexception_ctor_val;
  if (!GetPerContextExports(context).ToLocal(&per_context_bindings) ||
      !per_context_bindings->Get(context,
                                FIXED_ONE_BYTE_STRING(isolate, ""DOMException""))
          .ToLocal(&domexception_ctor_val)) {
    return MaybeLocal<Function>();
  }
  CHECK(domexception_ctor_val->IsFunction());
  Local<Function> domexception_ctor = domexception_ctor_val.As<Function>();
  return domexception_ctor;
}",62,,279,2,,void
204906,BLOCK,-1,,"{
    return MaybeLocal<Function>();
  }",45,,286,2,,void
204931,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  Local<Value> argv[] = {message,
                         FIXED_ONE_BYTE_STRING(isolate, ""DataCloneError"")};
  Local<Value> exception;
  Local<Function> domexception_ctor;
  if (!GetDOMException(context).ToLocal(&domexception_ctor) ||
      !domexception_ctor->NewInstance(context, arraysize(argv), argv)
           .ToLocal(&exception)) {
    return;
  }
  isolate->ThrowException(exception);
}",77,,294,3,,void
204981,BLOCK,-1,,"{
    return;
  }",34,,302,2,,void
204995,BLOCK,-1,,<empty>,47,,314,4,,void
205000,BLOCK,-1,,"{
    ThrowDataCloneException(context_, message);
  }",60,,316,2,,void
205009,BLOCK,-1,,"{
    if (BaseObject::IsBaseObject(object)) {
      return WriteHostObject(
          BaseObjectPtr<BaseObject> { Unwrap<BaseObject>(object) });
    }

    // Convert process.env to a regular object.
    auto env_proxy_ctor_template = env_->env_proxy_ctor_template();
    if (!env_proxy_ctor_template.IsEmpty() &&
        env_proxy_ctor_template->HasInstance(object)) {
      HandleScope scope(isolate);
      // TODO(bnoordhuis) Prototype-less object in case process.env contains
      // a ""__proto__"" key? process.env has a prototype with concomitant
      // methods like toString(). It's probably confusing if that gets lost
      // in transmission.
      Local<Object> normal_object = Object::New(isolate);
      env_->env_vars()->AssignToObject(isolate, env_->context(), normal_object);
      serializer->WriteUint32(kNormalObject);  // Instead of a BaseObject.
      return serializer->WriteValue(env_->context(), normal_object);
    }

    ThrowDataCloneError(env_->clone_unsupported_typ...",80,,320,3,,void
205016,BLOCK,-1,,"{
      return WriteHostObject(
          BaseObjectPtr<BaseObject> { Unwrap<BaseObject>(object) });
    }",43,,321,2,,void
205045,BLOCK,-1,,"{
      HandleScope scope(isolate);
      // TODO(bnoordhuis) Prototype-less object in case process.env contains
      // a ""__proto__"" key? process.env has a prototype with concomitant
      // methods like toString(). It's probably confusing if that gets lost
      // in transmission.
      Local<Object> normal_object = Object::New(isolate);
      env_->env_vars()->AssignToObject(isolate, env_->context(), normal_object);
      serializer->WriteUint32(kNormalObject);  // Instead of a BaseObject.
      return serializer->WriteValue(env_->context(), normal_object);
    }",55,,329,2,,void
205100,BLOCK,-1,,"{
    uint32_t i;
    for (i = 0; i < seen_shared_array_buffers_.size(); ++i) {
      if (PersistentToLocal::Strong(seen_shared_array_buffers_[i]) ==
          shared_array_buffer) {
        return Just(i);
      }
    }

    seen_shared_array_buffers_.emplace_back(
      Global<SharedArrayBuffer> { isolate, shared_array_buffer });
    msg_->AddSharedArrayBuffer(shared_array_buffer->GetBackingStore());
    return Just(i);
  }",62,,347,3,,void
205103,BLOCK,-1,,<empty>,5,,349,1,,void
205115,BLOCK,4,,"{
      if (PersistentToLocal::Strong(seen_shared_array_buffers_[i]) ==
          shared_array_buffer) {
        return Just(i);
      }
    }",61,,349,4,,void
205126,BLOCK,-1,,"{
        return Just(i);
      }",32,,351,2,,void
205154,BLOCK,-1,,"{
    return Just(msg_->AddWASMModule(module->GetCompiledModule()));
  }",66,,363,3,,void
205170,BLOCK,-1,,"{
    msg_->AdoptSharedValueConveyor(std::move(conveyor));
    return true;
  }",74,,368,3,,void
205186,BLOCK,-1,,"{
    for (uint32_t i = 0; i < host_objects_.size(); i++) {
      BaseObjectPtr<BaseObject> host_object = std::move(host_objects_[i]);
      std::unique_ptr<TransferData> data;
      if (i < first_cloned_object_index_)
        data = host_object->TransferForMessaging();
      if (!data)
        data = host_object->CloneForMessaging();
      if (!data) return Nothing<bool>();
      if (data->FinalizeTransferWrite(context, serializer).IsNothing())
        return Nothing<bool>();
      msg_->AddTransferable(std::move(data));
    }
    return Just(true);
  }",46,,373,2,,void
205188,BLOCK,-1,,<empty>,5,,374,1,,void
205201,BLOCK,4,,"{
      BaseObjectPtr<BaseObject> host_object = std::move(host_objects_[i]);
      std::unique_ptr<TransferData> data;
      if (i < first_cloned_object_index_)
        data = host_object->TransferForMessaging();
      if (!data)
        data = host_object->CloneForMessaging();
      if (!data) return Nothing<bool>();
      if (data->FinalizeTransferWrite(context, serializer).IsNothing())
        return Nothing<bool>();
      msg_->AddTransferable(std::move(data));
    }",57,,374,4,,void
205226,BLOCK,-1,,<empty>,9,,378,2,,void
205236,BLOCK,-1,,<empty>,9,,380,2,,void
205246,BLOCK,-1,,<empty>,18,,381,2,,void
205259,BLOCK,-1,,<empty>,9,,383,2,,void
205278,BLOCK,-1,,"{
    // Make sure we have not started serializing the value itself yet.
    CHECK_EQ(first_cloned_object_index_, SIZE_MAX);
    host_objects_.emplace_back(std::move(host_object));
  }",68,,389,2,,void
205294,BLOCK,-1,,"{
    for (size_t i = 0; i < host_objects_.size(); i++) {
      std::vector<BaseObjectPtr<BaseObject>> nested_transferables;
      if (!host_objects_[i]->NestedTransferables().To(&nested_transferables))
        return Nothing<bool>();
      for (auto& nested_transferable : nested_transferables) {
        if (std::find(host_objects_.begin(),
                      host_objects_.end(),
                      nested_transferable) == host_objects_.end()) {
          AddHostObject(nested_transferable);
        }
      }
    }
    return Just(true);
  }",45,,398,1,,void
205296,BLOCK,-1,,<empty>,5,,399,1,,void
205309,BLOCK,4,,"{
      std::vector<BaseObjectPtr<BaseObject>> nested_transferables;
      if (!host_objects_[i]->NestedTransferables().To(&nested_transferables))
        return Nothing<bool>();
      for (auto& nested_transferable : nested_transferables) {
        if (std::find(host_objects_.begin(),
                      host_objects_.end(),
                      nested_transferable) == host_objects_.end()) {
          AddHostObject(nested_transferable);
        }
      }
    }",55,,399,4,,void
205332,BLOCK,-1,,<empty>,9,,402,2,,void
205338,BLOCK,-1,,"{
        if (std::find(host_objects_.begin(),
                      host_objects_.end(),
                      nested_transferable) == host_objects_.end()) {
          AddHostObject(nested_transferable);
        }
      }",62,,403,3,,void
205358,BLOCK,-1,,"{
          AddHostObject(nested_transferable);
        }",68,,406,2,,void
205369,BLOCK,-1,,"{
    BaseObject::TransferMode mode = host_object->GetTransferMode();
    if (mode == BaseObject::TransferMode::kUntransferable) {
      ThrowDataCloneError(env_->clone_unsupported_type_str());
      return Nothing<bool>();
    }

    for (uint32_t i = 0; i < host_objects_.size(); i++) {
      if (host_objects_[i] == host_object) {
        serializer->WriteUint32(i);
        return Just(true);
      }
    }

    if (mode == BaseObject::TransferMode::kTransferable) {
      THROW_ERR_MISSING_TRANSFERABLE_IN_TRANSFER_LIST(env_);
      return Nothing<bool>();
    }

    CHECK_EQ(mode, BaseObject::TransferMode::kCloneable);
    uint32_t index = host_objects_.size();
    if (first_cloned_object_index_ == SIZE_MAX)
      first_cloned_object_index_ = index;
    serializer->WriteUint32(index);
    host_objects_.push_back(host_object);
    return Just(true);
  }",70,,417,2,,void
205385,BLOCK,-1,,"{
      ThrowDataCloneError(env_->clone_unsupported_type_str());
      return Nothing<bool>();
    }",60,,419,2,,void
205394,BLOCK,-1,,<empty>,5,,424,1,,void
205407,BLOCK,4,,"{
      if (host_objects_[i] == host_object) {
        serializer->WriteUint32(i);
        return Just(true);
      }
    }",57,,424,4,,void
205414,BLOCK,-1,,"{
        serializer->WriteUint32(i);
        return Just(true);
      }",44,,425,2,,void
205431,BLOCK,-1,,"{
      THROW_ERR_MISSING_TRANSFERABLE_IN_TRANSFER_LIST(env_);
      return Nothing<bool>();
    }",58,,431,2,,void
205454,BLOCK,-1,,<empty>,7,,439,2,,void
205481,BLOCK,-1,,<empty>,,,,1,,<empty>
205496,BLOCK,-1,,"{
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(context);

  // Verify that we're not silently overwriting an existing message.
  CHECK(main_message_buf_.is_empty());

  SerializerDelegate delegate(env, context, this);
  ValueSerializer serializer(env->isolate(), &delegate);
  delegate.serializer = &serializer;

  std::vector<Local<ArrayBuffer>> array_buffers;
  for (uint32_t i = 0; i < transfer_list_v.length(); ++i) {
    Local<Value> entry = transfer_list_v[i];
    if (entry->IsObject()) {
      // See https://github.com/nodejs/node/pull/30339#issuecomment-552225353
      // for details.
      bool untransferable;
      if (!entry.As<Object>()->HasPrivate(
              context,
              env->untransferable_object_private_symbol())
              .To(&untransferable)) {
        return Nothing<bool>();
      }
      if (untransferable) continue;
    }

    // Currently, we support ArrayBuffers and BaseObjects for which
    // GetTransferMode() does ...",59,,461,6,,void
205540,BLOCK,-1,,<empty>,3,,473,1,,void
205553,BLOCK,4,,"{
    Local<Value> entry = transfer_list_v[i];
    if (entry->IsObject()) {
      // See https://github.com/nodejs/node/pull/30339#issuecomment-552225353
      // for details.
      bool untransferable;
      if (!entry.As<Object>()->HasPrivate(
              context,
              env->untransferable_object_private_symbol())
              .To(&untransferable)) {
        return Nothing<bool>();
      }
      if (untransferable) continue;
    }

    // Currently, we support ArrayBuffers and BaseObjects for which
    // GetTransferMode() does not return kUntransferable.
    if (entry->IsArrayBuffer()) {
      Local<ArrayBuffer> ab = entry.As<ArrayBuffer>();
      // If we cannot render the ArrayBuffer unusable in this Isolate,
      // copying the buffer will have to do.
      // Note that we can currently transfer ArrayBuffers even if they were
      // not allocated by Nodes ArrayBufferAllocator in the first place,
      // because we pass the underlying v8::BackingStore around rat...",59,,473,4,,void
205568,BLOCK,-1,,"{
      // See https://github.com/nodejs/node/pull/30339#issuecomment-552225353
      // for details.
      bool untransferable;
      if (!entry.As<Object>()->HasPrivate(
              context,
              env->untransferable_object_private_symbol())
              .To(&untransferable)) {
        return Nothing<bool>();
      }
      if (untransferable) continue;
    }",28,,475,2,,void
205589,BLOCK,-1,,"{
        return Nothing<bool>();
      }",37,,482,2,,void
205594,BLOCK,-1,,<empty>,27,,485,2,,void
205601,BLOCK,-1,,"{
      Local<ArrayBuffer> ab = entry.As<ArrayBuffer>();
      // If we cannot render the ArrayBuffer unusable in this Isolate,
      // copying the buffer will have to do.
      // Note that we can currently transfer ArrayBuffers even if they were
      // not allocated by Nodes ArrayBufferAllocator in the first place,
      // because we pass the underlying v8::BackingStore around rather than
      // raw data *and* an Isolate with a non-default ArrayBuffer allocator
      // is always going to outlive any Workers it creates, and so will its
      // allocator along with it.
      if (!ab->IsDetachable()) continue;
      if (std::find(array_buffers.begin(), array_buffers.end(), ab) !=
          array_buffers.end()) {
        ThrowDataCloneException(
            context,
            FIXED_ONE_BYTE_STRING(
                env->isolate(),
                ""Transfer list contains duplicate ArrayBuffer""));
        return Nothing<bool>();
      }
      // We simply use the array index i...",33,,490,2,,void
205618,BLOCK,-1,,<empty>,32,,500,2,,void
205639,BLOCK,-1,,"{
        ThrowDataCloneException(
            context,
            FIXED_ONE_BYTE_STRING(
                env->isolate(),
                ""Transfer list contains duplicate ArrayBuffer""));
        return Nothing<bool>();
      }",32,,502,2,,void
205670,BLOCK,-1,,<empty>,12,,516,1,,void
205685,BLOCK,-1,,"{
      // Check if the source MessagePort is being transferred.
      if (!source_port.IsEmpty() && entry == source_port) {
        ThrowDataCloneException(
            context,
            FIXED_ONE_BYTE_STRING(env->isolate(),
                                  ""Transfer list contains source port""));
        return Nothing<bool>();
      }
      BaseObjectPtr<BaseObject> host_object {
          Unwrap<BaseObject>(entry.As<Object>()) };
      if (env->message_port_constructor_template()->HasInstance(entry) &&
          (!host_object ||
           static_cast<MessagePort*>(host_object.get())->IsDetached())) {
        ThrowDataCloneException(
            context,
            FIXED_ONE_BYTE_STRING(
                env->isolate(),
                ""MessagePort in transfer list is already detached""));
        return Nothing<bool>();
      }
      if (std::find(delegate.host_objects_.begin(),
                    delegate.host_objects_.end(),
                    host_object) != delegate.hos...",62,,517,2,,void
205696,BLOCK,-1,,"{
        ThrowDataCloneException(
            context,
            FIXED_ONE_BYTE_STRING(env->isolate(),
                                  ""Transfer list contains source port""));
        return Nothing<bool>();
      }",59,,519,2,,void
205743,BLOCK,-1,,"{
        ThrowDataCloneException(
            context,
            FIXED_ONE_BYTE_STRING(
                env->isolate(),
                ""MessagePort in transfer list is already detached""));
        return Nothing<bool>();
      }",73,,530,2,,void
205779,BLOCK,-1,,"{
        ThrowDataCloneException(
            context,
            String::Concat(env->isolate(),
                FIXED_ONE_BYTE_STRING(
                  env->isolate(),
                  ""Transfer list contains duplicate ""),
                entry.As<Object>()->GetConstructorName()));
        return Nothing<bool>();
      }",67,,540,2,,void
205818,BLOCK,-1,,"{
        delegate.AddHostObject(host_object);
        continue;
      }",58,,551,2,,void
205837,BLOCK,-1,,<empty>,5,,561,2,,void
205854,BLOCK,-1,,"{
    return Nothing<bool>();
  }",58,,564,2,,void
205860,BLOCK,-1,,"{
    // If serialization succeeded, we render it inaccessible in this Isolate.
    std::shared_ptr<BackingStore> backing_store = ab->GetBackingStore();
    ab->Detach(Local<Value>()).Check();

    array_buffers_.emplace_back(std::move(backing_store));
  }",47,,568,3,,void
205899,BLOCK,-1,,<empty>,5,,577,2,,void
205931,BLOCK,-1,,"{
  tracker->TrackField(""array_buffers_"", array_buffers_);
  tracker->TrackField(""shared_array_buffers"", shared_array_buffers_);
  tracker->TrackField(""transferables"", transferables_);
}",56,,587,2,,void
205954,BLOCK,-1,,"{
}",21,,594,2,,void
205958,BLOCK,-1,,"{
  CHECK_NULL(owner_);
  Disentangle();
}",37,,597,1,,void
205965,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  tracker->TrackField(""incoming_messages"", incoming_messages_);
}",64,,602,2,,void
205979,BLOCK,-1,,"{
  // This function will be called by other threads.
  Mutex::ScopedLock lock(mutex_);
  incoming_messages_.emplace_back(std::move(message));

  if (owner_ != nullptr) {
    Debug(owner_, ""Adding message to incoming queue"");
    owner_->TriggerAsync();
  }
}",76,,607,2,,void
205996,BLOCK,-1,,"{
    Debug(owner_, ""Adding message to incoming queue"");
    owner_->TriggerAsync();
  }",26,,612,2,,void
206009,BLOCK,-1,,"{
  auto group = std::make_shared<SiblingGroup>();
  group->Entangle({a, b});
}",72,,618,3,,void
206027,BLOCK,-1,,"{
  if (group_) {
    group_->Disentangle(this);
  }
}",37,,623,1,,void
206030,BLOCK,-1,,"{
    group_->Disentangle(this);
  }",15,,624,2,,void
206039,BLOCK,-1,,"{
  if (data_) Detach();
}",29,,629,1,,void
206042,BLOCK,-1,,<empty>,14,,630,2,,void
206050,BLOCK,-1,,"{
  auto onmessage = [](uv_async_t* handle) {
    // Called when data has been put into the queue.
    MessagePort* channel = ContainerOf(&MessagePort::async_, handle);
    channel->OnMessage(MessageProcessingMode::kNormalOperation);
  };

  CHECK_EQ(uv_async_init(env->event_loop(),
                         &async_,
                         onmessage), 0);
  // Reset later to indicate success of the constructor.
  bool succeeded = false;
  auto cleanup = OnScopeLeave([&]() { if (!succeeded) Close(); });

  Local<Value> fn;
  if (!wrap->Get(context, env->oninit_symbol()).ToLocal(&fn))
    return;

  if (fn->IsFunction()) {
    Local<Function> init = fn.As<Function>();
    if (init->Call(context, wrap, 0, nullptr).IsEmpty())
      return;
  }

  Local<Function> emit_message_fn;
  if (!GetEmitMessageFunction(context).ToLocal(&emit_message_fn))
    return;
  emit_message_fn_.Reset(env->isolate(), emit_message_fn);

  succeeded = true;
  Debug(this, ""Created message port"");
}",38,,640,4,,void
206094,BLOCK,-1,,<empty>,5,,656,2,,void
206101,BLOCK,-1,,"{
    Local<Function> init = fn.As<Function>();
    if (init->Call(context, wrap, 0, nullptr).IsEmpty())
      return;
  }",25,,658,2,,void
206124,BLOCK,-1,,<empty>,7,,661,2,,void
206140,BLOCK,-1,,<empty>,5,,666,2,,void
206160,BLOCK,-1,,"{
  return data_ == nullptr || IsHandleClosing();
}",38,,673,1,,void
206170,BLOCK,-1,,"{
  if (IsHandleClosing()) return;
  CHECK_EQ(uv_async_send(&async_), 0);
}",34,,677,1,,void
206173,BLOCK,-1,,<empty>,26,,678,2,,void
206184,BLOCK,-1,,"{
  Debug(this, ""Closing message port, data set = %d"", static_cast<int>(!!data_));

  if (data_) {
    // Wrap this call with accessing the mutex, so that TriggerAsync()
    // can check IsHandleClosing() without race conditions.
    Mutex::ScopedLock sibling_lock(data_->mutex_);
    HandleWrap::Close(close_callback);
  } else {
    HandleWrap::Close(close_callback);
  }
}",62,,682,2,,void
206195,BLOCK,-1,,"{
    // Wrap this call with accessing the mutex, so that TriggerAsync()
    // can check IsHandleClosing() without race conditions.
    Mutex::ScopedLock sibling_lock(data_->mutex_);
    HandleWrap::Close(close_callback);
  }",14,,685,2,,void
206207,BLOCK,-1,,"{
    HandleWrap::Close(close_callback);
  }",10,,690,1,,void
206217,BLOCK,-1,,"{
  // This constructor just throws an error. Unfortunately, we cant use V8s
  // ConstructorBehavior::kThrow, as that also removes the prototype from the
  // class (i.e. makes it behave like an arrow function).
  Environment* env = Environment::GetCurrent(args);
  THROW_ERR_CONSTRUCT_CALL_INVALID(env);
}",64,,695,2,,void
206235,BLOCK,-1,,"{
  Context::Scope context_scope(context);
  Local<FunctionTemplate> ctor_templ = GetMessagePortConstructorTemplate(env);

  // Construct a new instance, then assign the listener instance and possibly
  // the MessagePortData to it.
  Local<Object> instance;
  if (!ctor_templ->InstanceTemplate()->NewInstance(context).ToLocal(&instance))
    return nullptr;
  MessagePort* port = new MessagePort(env, context, instance);
  CHECK_NOT_NULL(port);
  if (port->IsHandleClosing()) {
    // Construction failed with an exception.
    return nullptr;
  }

  if (data) {
    CHECK(!sibling_group);
    port->Detach();
    port->data_ = std::move(data);

    // This lock is here to avoid race conditions with the `owner_` read
    // in AddToIncomingQueue(). (This would likely be unproblematic without it,
    // but it's better to be safe than sorry.)
    Mutex::ScopedLock lock(port->data_->mutex_);
    port->data_->owner_ = port;
    // If the existing MessagePortData object had pending messages, t...",50,,707,5,,void
206267,BLOCK,-1,,<empty>,5,,715,2,,void
206285,BLOCK,-1,,"{
    // Construction failed with an exception.
    return nullptr;
  }",32,,718,2,,void
206290,BLOCK,-1,,"{
    CHECK(!sibling_group);
    port->Detach();
    port->data_ = std::move(data);

    // This lock is here to avoid race conditions with the `owner_` read
    // in AddToIncomingQueue(). (This would likely be unproblematic without it,
    // but it's better to be safe than sorry.)
    Mutex::ScopedLock lock(port->data_->mutex_);
    port->data_->owner_ = port;
    // If the existing MessagePortData object had pending messages, this is
    // the easiest way to run that queue.
    port->TriggerAsync();
  }",13,,723,2,,void
206326,BLOCK,-1,,<empty>,10,,736,1,,void
206329,BLOCK,-1,,"{
    sibling_group->Entangle(port->data_.get());
  }",29,,736,2,,void
206348,BLOCK,-1,,"{
  std::shared_ptr<Message> received;
  {
    // Get the head of the message queue.
    Mutex::ScopedLock lock(data_->mutex_);

    Debug(this, ""MessagePort has message"");

    bool wants_message =
        receiving_messages_ ||
        mode == MessageProcessingMode::kForceReadMessages;
    // We have nothing to do if:
    // - There are no pending messages
    // - We are not intending to receive messages, and the message we would
    //   receive is not the final ""close"" message.
    if (data_->incoming_messages_.empty() ||
        (!wants_message &&
         !data_->incoming_messages_.front()->IsCloseMessage())) {
      return env()->no_message_symbol();
    }

    received = data_->incoming_messages_.front();
    data_->incoming_messages_.pop_front();
  }

  if (received->IsCloseMessage()) {
    Close();
    return env()->no_message_symbol();
  }

  if (!env()->can_call_into_js()) return MaybeLocal<Value>();

  return received->Deserialize(env(), context, port_list);
}",72,,744,4,,void
206356,BLOCK,2,,"{
    // Get the head of the message queue.
    Mutex::ScopedLock lock(data_->mutex_);

    Debug(this, ""MessagePort has message"");

    bool wants_message =
        receiving_messages_ ||
        mode == MessageProcessingMode::kForceReadMessages;
    // We have nothing to do if:
    // - There are no pending messages
    // - We are not intending to receive messages, and the message we would
    //   receive is not the final ""close"" message.
    if (data_->incoming_messages_.empty() ||
        (!wants_message &&
         !data_->incoming_messages_.front()->IsCloseMessage())) {
      return env()->no_message_symbol();
    }

    received = data_->incoming_messages_.front();
    data_->incoming_messages_.pop_front();
  }",3,,746,2,,void
206396,BLOCK,-1,,"{
      return env()->no_message_symbol();
    }",65,,761,2,,void
206421,BLOCK,-1,,"{
    Close();
    return env()->no_message_symbol();
  }",35,,769,2,,void
206434,BLOCK,-1,,<empty>,35,,774,2,,void
206449,BLOCK,-1,,"{
  Debug(this, ""Running MessagePort::OnMessage()"");
  HandleScope handle_scope(env()->isolate());
  Local<Context> context =
      object(env()->isolate())->GetCreationContext().ToLocalChecked();

  size_t processing_limit;
  if (mode == MessageProcessingMode::kNormalOperation) {
    Mutex::ScopedLock(data_->mutex_);
    processing_limit = std::max(data_->incoming_messages_.size(),
                                static_cast<size_t>(1000));
  } else {
    processing_limit = std::numeric_limits<size_t>::max();
  }

  // data_ can only ever be modified by the owner thread, so no need to lock.
  // However, the message port may be transferred while it is processing
  // messages, so we need to check that this handle still owns its `data_` field
  // on every iteration.
  while (data_) {
    if (processing_limit-- == 0) {
      // Prevent event loop starvation by only processing those messages without
      // interruption that were already present when the OnMessage() call was
      /...",57,,779,2,,void
206483,BLOCK,-1,,"{
    Mutex::ScopedLock(data_->mutex_);
    processing_limit = std::max(data_->incoming_messages_.size(),
                                static_cast<size_t>(1000));
  }",56,,786,2,,void
206507,BLOCK,-1,,"{
    processing_limit = std::numeric_limits<size_t>::max();
  }",10,,790,1,,void
206522,BLOCK,-1,,"{
    if (processing_limit-- == 0) {
      // Prevent event loop starvation by only processing those messages without
      // interruption that were already present when the OnMessage() call was
      // first triggered, but at least 1000 messages because otherwise the
      // overhead of repeatedly triggering the uv_async_t instance becomes
      // noticeable, at least on Windows.
      // (That might require more investigation by somebody more familiar with
      // Windows.)
      TriggerAsync();
      return;
    }

    HandleScope handle_scope(env()->isolate());
    Context::Scope context_scope(context);
    Local<Function> emit_message = PersistentToLocal::Strong(emit_message_fn_);

    Local<Value> payload;
    Local<Value> port_list = Undefined(env()->isolate());
    Local<Value> message_error;
    Local<Value> argv[3];

    {
      // Catch any exceptions from parsing the message itself (not from
      // emitting it) as 'messageeror' events.
      TryCatchScope try_catc...",17,,798,2,,void
206528,BLOCK,-1,,"{
      // Prevent event loop starvation by only processing those messages without
      // interruption that were already present when the OnMessage() call was
      // first triggered, but at least 1000 messages because otherwise the
      // overhead of repeatedly triggering the uv_async_t instance becomes
      // noticeable, at least on Windows.
      // (That might require more investigation by somebody more familiar with
      // Windows.)
      TriggerAsync();
      return;
    }",34,,799,2,,void
206579,BLOCK,11,,"{
      // Catch any exceptions from parsing the message itself (not from
      // emitting it) as 'messageeror' events.
      TryCatchScope try_catch(env());
      if (!ReceiveMessage(context, mode, &port_list).ToLocal(&payload)) {
        if (try_catch.HasCaught() && !try_catch.HasTerminated())
          message_error = try_catch.Exception();
        goto reschedule;
      }
    }",5,,820,11,,void
206595,BLOCK,-1,,"{
        if (try_catch.HasCaught() && !try_catch.HasTerminated())
          message_error = try_catch.Exception();
        goto reschedule;
      }",73,,824,2,,void
206607,BLOCK,-1,,<empty>,11,,826,2,,void
206622,BLOCK,-1,,<empty>,48,,830,2,,void
206630,BLOCK,-1,,"{
      Debug(this, ""MessagePort drains queue because !can_call_into_js()"");
      // In this case there is nothing to do but to drain the current queue.
      continue;
    }",37,,832,2,,void
206662,BLOCK,-1,,"{
    reschedule:
      if (!message_error.IsEmpty()) {
        argv[0] = message_error;
        argv[1] = Undefined(env()->isolate());
        argv[2] = env()->messageerror_string();
        USE(MakeCallback(emit_message, arraysize(argv), argv));
      }

      // Re-schedule OnMessage() execution in case of failure.
      if (data_)
        TriggerAsync();
      return;
    }",70,,842,2,,void
206670,BLOCK,-1,,"{
        argv[0] = message_error;
        argv[1] = Undefined(env()->isolate());
        argv[2] = env()->messageerror_string();
        USE(MakeCallback(emit_message, arraysize(argv), argv));
      }",37,,844,2,,void
206696,BLOCK,-1,,<empty>,9,,853,2,,void
206702,BLOCK,-1,,"{
  Debug(this, ""MessagePort::OnClose()"");
  if (data_) {
    // Detach() returns move(data_).
    Detach()->Disentangle();
  }
}",29,,859,1,,void
206708,BLOCK,-1,,"{
    // Detach() returns move(data_).
    Detach()->Disentangle();
  }",14,,861,2,,void
206716,BLOCK,-1,,"{
  CHECK(data_);
  Mutex::ScopedLock lock(data_->mutex_);
  data_->owner_ = nullptr;
  return std::move(data_);
}",56,,867,1,,void
206737,BLOCK,-1,,"{
  if (IsDetached())
    return BaseObject::TransferMode::kUntransferable;
  return BaseObject::TransferMode::kTransferable;
}",63,,874,1,,void
206740,BLOCK,-1,,<empty>,5,,876,2,,void
206756,BLOCK,-1,,"{
  Close();
  return Detach();
}",67,,880,1,,void
206766,BLOCK,-1,,"{
  return BaseObjectPtr<MessagePort> { MessagePort::New(
      env, context,
      static_unique_pointer_cast<MessagePortData>(std::move(self))) };
}",41,,888,4,,void
206792,BLOCK,-1,,"{
  Isolate* isolate = env->isolate();
  Local<Object> obj = object(isolate);

  std::shared_ptr<Message> msg = std::make_shared<Message>();

  // Per spec, we need to both check if transfer list has the source port, and
  // serialize the input message, even if the MessagePort is closed or detached.

  Maybe<bool> serialization_maybe =
      msg->Serialize(env, context, message_v, transfer_v, obj);
  if (data_ == nullptr) {
    return serialization_maybe;
  }
  if (serialization_maybe.IsNothing()) {
    return Nothing<bool>();
  }

  std::string error;
  Maybe<bool> res = data_->Dispatch(msg, &error);
  if (res.IsNothing())
    return res;

  if (!error.empty())
    ProcessEmitWarning(env, error.c_str());

  return res;
}",70,,897,5,,void
206836,BLOCK,-1,,"{
    return serialization_maybe;
  }",25,,908,2,,void
206844,BLOCK,-1,,"{
    return Nothing<bool>();
  }",40,,911,2,,void
206863,BLOCK,-1,,<empty>,5,,918,2,,void
206872,BLOCK,-1,,<empty>,5,,921,2,,void
206886,BLOCK,-1,,"{
  if (!group_) {
    if (error != nullptr)
      *error = ""MessagePortData is not entangled."";
    return Nothing<bool>();
  }
  return group_->Dispatch(this, message, error);
}",25,,928,3,,void
206890,BLOCK,-1,,"{
    if (error != nullptr)
      *error = ""MessagePortData is not entangled."";
    return Nothing<bool>();
  }",16,,929,2,,void
206895,BLOCK,-1,,<empty>,7,,931,2,,void
206917,BLOCK,-1,,"{
  if (!object->IsObject()) return Just(false);

  if (object->IsArray()) {
    Local<Array> arr = object.As<Array>();
    size_t length = arr->Length();
    transfer_list.AllocateSufficientStorage(length);
    for (size_t i = 0; i < length; i++) {
      if (!arr->Get(context, i).ToLocal(&transfer_list[i]))
        return Nothing<bool>();
    }
    return Just(true);
  }

  Isolate* isolate = env->isolate();
  Local<Value> iterator_method;
  if (!object.As<Object>()->Get(context, Symbol::GetIterator(isolate))
      .ToLocal(&iterator_method)) return Nothing<bool>();
  if (!iterator_method->IsFunction()) return Just(false);

  Local<Value> iterator;
  if (!iterator_method.As<Function>()->Call(context, object, 0, nullptr)
      .ToLocal(&iterator)) return Nothing<bool>();
  if (!iterator->IsObject()) return Just(false);

  Local<Value> next;
  if (!iterator.As<Object>()->Get(context, env->next_string()).ToLocal(&next))
    return Nothing<bool>();
  if (!next->IsFunction()) return Jus...",54,,941,5,,void
206924,BLOCK,-1,,<empty>,28,,942,2,,void
206933,BLOCK,-1,,"{
    Local<Array> arr = object.As<Array>();
    size_t length = arr->Length();
    transfer_list.AllocateSufficientStorage(length);
    for (size_t i = 0; i < length; i++) {
      if (!arr->Get(context, i).ToLocal(&transfer_list[i]))
        return Nothing<bool>();
    }
    return Just(true);
  }",26,,944,2,,void
206957,BLOCK,-1,,<empty>,5,,948,1,,void
206967,BLOCK,4,,"{
      if (!arr->Get(context, i).ToLocal(&transfer_list[i]))
        return Nothing<bool>();
    }",41,,948,4,,void
206983,BLOCK,-1,,<empty>,9,,950,2,,void
207021,BLOCK,-1,,<empty>,35,,958,2,,void
207030,BLOCK,-1,,<empty>,39,,959,2,,void
207057,BLOCK,-1,,<empty>,28,,963,2,,void
207066,BLOCK,-1,,<empty>,30,,964,2,,void
207094,BLOCK,-1,,<empty>,5,,968,2,,void
207103,BLOCK,-1,,<empty>,28,,969,2,,void
207121,BLOCK,-1,,"{
    Local<Value> result;
    if (!next.As<Function>()->Call(context, iterator, 0, nullptr)
        .ToLocal(&result)) return Nothing<bool>();
    if (!result->IsObject()) return Just(false);

    Local<Value> done;
    if (!result.As<Object>()->Get(context, env->done_string()).ToLocal(&done))
      return Nothing<bool>();
    if (done->BooleanValue(isolate)) break;

    Local<Value> val;
    if (!result.As<Object>()->Get(context, env->value_string()).ToLocal(&val))
      return Nothing<bool>();
    entries.push_back(val);
  }",35,,972,2,,void
207145,BLOCK,-1,,<empty>,28,,975,2,,void
207154,BLOCK,-1,,<empty>,30,,976,2,,void
207182,BLOCK,-1,,<empty>,7,,980,2,,void
207191,BLOCK,-1,,<empty>,38,,981,2,,void
207217,BLOCK,-1,,<empty>,7,,985,2,,void
207256,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Local<Object> obj = args.This();
  Local<Context> context = obj->GetCreationContext().ToLocalChecked();

  if (args.Length() == 0) {
    return THROW_ERR_MISSING_ARGS(env, ""Not enough arguments to ""
                                       ""MessagePort.postMessage"");
  }

  if (!args[1]->IsNullOrUndefined() && !args[1]->IsObject()) {
    // Browsers ignore null or undefined, and otherwise accept an array or an
    // options object.
    return THROW_ERR_INVALID_ARG_TYPE(env,
        ""Optional transferList argument must be an iterable"");
  }

  TransferList transfer_list;
  if (args[1]->IsObject()) {
    bool was_iterable;
    if (!ReadIterable(env, context, transfer_list, args[1]).To(&was_iterable))
      return;
    if (!was_iterable) {
      Local<Value> transfer_option;
      if (!args[1].As<Object>()->Get(context, env->transfer_string())
          .ToLocal(&transfer_option)) return;
      if (!transfer_option->IsUndefined()) ...",72,,994,2,,void
207295,BLOCK,-1,,"{
    return THROW_ERR_MISSING_ARGS(env, ""Not enough arguments to ""
                                       ""MessagePort.postMessage"");
  }",27,,999,2,,void
207316,BLOCK,-1,,"{
    // Browsers ignore null or undefined, and otherwise accept an array or an
    // options object.
    return THROW_ERR_INVALID_ARG_TYPE(env,
        ""Optional transferList argument must be an iterable"");
  }",62,,1004,2,,void
207329,BLOCK,-1,,"{
    bool was_iterable;
    if (!ReadIterable(env, context, transfer_list, args[1]).To(&was_iterable))
      return;
    if (!was_iterable) {
      Local<Value> transfer_option;
      if (!args[1].As<Object>()->Get(context, env->transfer_string())
          .ToLocal(&transfer_option)) return;
      if (!transfer_option->IsUndefined()) {
        if (!ReadIterable(env, context, transfer_list, transfer_option)
            .To(&was_iterable)) return;
        if (!was_iterable) {
          return THROW_ERR_INVALID_ARG_TYPE(env,
              ""Optional options.transfer argument must be an iterable"");
        }
      }
    }
  }",28,,1012,2,,void
207345,BLOCK,-1,,<empty>,7,,1015,2,,void
207350,BLOCK,-1,,"{
      Local<Value> transfer_option;
      if (!args[1].As<Object>()->Get(context, env->transfer_string())
          .ToLocal(&transfer_option)) return;
      if (!transfer_option->IsUndefined()) {
        if (!ReadIterable(env, context, transfer_list, transfer_option)
            .To(&was_iterable)) return;
        if (!was_iterable) {
          return THROW_ERR_INVALID_ARG_TYPE(env,
              ""Optional options.transfer argument must be an iterable"");
        }
      }
    }",24,,1016,2,,void
207377,BLOCK,-1,,<empty>,39,,1019,2,,void
207385,BLOCK,-1,,"{
        if (!ReadIterable(env, context, transfer_list, transfer_option)
            .To(&was_iterable)) return;
        if (!was_iterable) {
          return THROW_ERR_INVALID_ARG_TYPE(env,
              ""Optional options.transfer argument must be an iterable"");
        }
      }",44,,1020,2,,void
207398,BLOCK,-1,,<empty>,33,,1022,2,,void
207403,BLOCK,-1,,"{
          return THROW_ERR_INVALID_ARG_TYPE(env,
              ""Optional options.transfer argument must be an iterable"");
        }",28,,1023,2,,void
207428,BLOCK,-1,,"{
    Message msg;
    USE(msg.Serialize(env, context, args[0], transfer_list, obj));
    return;
  }",51,,1035,2,,void
207461,BLOCK,-1,,<empty>,5,,1043,2,,void
207476,BLOCK,-1,,"{
  Debug(this, ""Start receiving messages"");
  receiving_messages_ = true;
  Mutex::ScopedLock lock(data_->mutex_);
  if (!data_->incoming_messages_.empty())
    TriggerAsync();
}",27,,1046,1,,void
207496,BLOCK,-1,,<empty>,5,,1051,2,,void
207501,BLOCK,-1,,"{
  Debug(this, ""Stop receiving messages"");
  receiving_messages_ = false;
}",26,,1054,1,,void
207512,BLOCK,-1,,"{
  MessagePort* port;
  ASSIGN_OR_RETURN_UNWRAP(&port, args.This());
  if (!port->data_) {
    return;
  }
  port->Start();
}",66,,1059,2,,void
207526,BLOCK,-1,,"{
    return;
  }",21,,1062,2,,void
207536,BLOCK,-1,,"{
  MessagePort* port;
  CHECK(args[0]->IsObject());
  ASSIGN_OR_RETURN_UNWRAP(&port, args[0].As<Object>());
  if (!port->data_) {
    return;
  }
  port->Stop();
}",65,,1068,2,,void
207559,BLOCK,-1,,"{
    return;
  }",21,,1072,2,,void
207569,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  args.GetReturnValue().Set(
      GetMessagePortConstructorTemplate(env)->HasInstance(args[0]));
}",70,,1078,2,,void
207597,BLOCK,-1,,"{
  MessagePort* port;
  ASSIGN_OR_RETURN_UNWRAP(&port, args[0].As<Object>());
  port->OnMessage(MessageProcessingMode::kForceReadMessages);
}",66,,1084,2,,void
207619,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  if (!args[0]->IsObject() ||
      !env->message_port_constructor_template()->HasInstance(args[0])) {
    return THROW_ERR_INVALID_ARG_TYPE(env,
        ""The \""port\"" argument must be a MessagePort instance"");
  }
  MessagePort* port = Unwrap<MessagePort>(args[0].As<Object>());
  if (port == nullptr) {
    // Return 'no messages' for a closed port.
    args.GetReturnValue().Set(
        Environment::GetCurrent(args)->no_message_symbol());
    return;
  }

  MaybeLocal<Value> payload = port->ReceiveMessage(
      port->object()->GetCreationContext().ToLocalChecked(),
      MessageProcessingMode::kForceReadMessages);
  if (!payload.IsEmpty())
    args.GetReturnValue().Set(payload.ToLocalChecked());
}",75,,1090,2,,void
207648,BLOCK,-1,,"{
    return THROW_ERR_INVALID_ARG_TYPE(env,
        ""The \""port\"" argument must be a MessagePort instance"");
  }",72,,1093,2,,void
207670,BLOCK,-1,,"{
    // Return 'no messages' for a closed port.
    args.GetReturnValue().Set(
        Environment::GetCurrent(args)->no_message_symbol());
    return;
  }",24,,1098,2,,void
207716,BLOCK,-1,,<empty>,5,,1109,2,,void
207732,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  if (!args[0]->IsObject() ||
      !env->message_port_constructor_template()->HasInstance(args[0])) {
    return THROW_ERR_INVALID_ARG_TYPE(env,
        ""The \""port\"" argument must be a MessagePort instance"");
  }
  MessagePort* port = Unwrap<MessagePort>(args[0].As<Object>());
  if (port == nullptr || port->IsHandleClosing()) {
    Isolate* isolate = env->isolate();
    THROW_ERR_CLOSED_MESSAGE_PORT(isolate);
    return;
  }

  Local<Value> context_arg = args[1];
  ContextifyContext* context_wrapper;
  if (!context_arg->IsObject() ||
      (context_wrapper = ContextifyContext::ContextFromContextifiedSandbox(
          env, context_arg.As<Object>())) == nullptr) {
    return THROW_ERR_INVALID_ARG_TYPE(env, ""Invalid context argument"");
  }

  std::unique_ptr<MessagePortData> data;
  if (!port->IsDetached())
    data = port->Detach();

  Context::Scope context_scope(context_wrapper->context());
  MessagePort* target =
      Messag...",74,,1112,2,,void
207761,BLOCK,-1,,"{
    return THROW_ERR_INVALID_ARG_TYPE(env,
        ""The \""port\"" argument must be a MessagePort instance"");
  }",72,,1115,2,,void
207788,BLOCK,-1,,"{
    Isolate* isolate = env->isolate();
    THROW_ERR_CLOSED_MESSAGE_PORT(isolate);
    return;
  }",51,,1120,2,,void
207829,BLOCK,-1,,"{
    return THROW_ERR_INVALID_ARG_TYPE(env, ""Invalid context argument"");
  }",55,,1130,2,,void
207847,BLOCK,-1,,<empty>,5,,1136,2,,void
207881,BLOCK,-1,,<empty>,5,,1142,2,,void
207898,BLOCK,-1,,"{
  MessagePortData::Entangle(a->data_.get(), b->data_.get());
}",60,,1145,3,,void
207920,BLOCK,-1,,"{
  MessagePortData::Entangle(a->data_.get(), b);
}",64,,1149,3,,void
207936,BLOCK,-1,,"{
  tracker->TrackField(""data"", data_);
  tracker->TrackField(""emit_message_fn"", emit_message_fn_);
}",60,,1153,2,,void
207953,BLOCK,-1,,"{
  // Factor generating the MessagePort JS constructor into its own piece
  // of code, because it is needed early on in the child environment setup.
  Local<FunctionTemplate> templ = env->message_port_constructor_template();
  if (!templ.IsEmpty())
    return templ;

  {
    Isolate* isolate = env->isolate();
    Local<FunctionTemplate> m = NewFunctionTemplate(isolate, MessagePort::New);
    m->SetClassName(env->message_port_constructor_string());
    m->InstanceTemplate()->SetInternalFieldCount(
        MessagePort::kInternalFieldCount);
    m->Inherit(HandleWrap::GetConstructorTemplate(env));

    SetProtoMethod(isolate, m, ""postMessage"", MessagePort::PostMessage);
    SetProtoMethod(isolate, m, ""start"", MessagePort::Start);

    env->set_message_port_constructor_template(m);
  }

  return GetMessagePortConstructorTemplate(env);
}",77,,1158,2,,void
207970,BLOCK,-1,,<empty>,5,,1163,2,,void
207973,BLOCK,3,,"{
    Isolate* isolate = env->isolate();
    Local<FunctionTemplate> m = NewFunctionTemplate(isolate, MessagePort::New);
    m->SetClassName(env->message_port_constructor_string());
    m->InstanceTemplate()->SetInternalFieldCount(
        MessagePort::kInternalFieldCount);
    m->Inherit(HandleWrap::GetConstructorTemplate(env));

    SetProtoMethod(isolate, m, ""postMessage"", MessagePort::PostMessage);
    SetProtoMethod(isolate, m, ""start"", MessagePort::Start);

    env->set_message_port_constructor_template(m);
  }",3,,1165,3,,void
208046,BLOCK,-1,,"{
  MakeWeak();
}",28,,1183,3,,void
208052,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  new JSTransferable(Environment::GetCurrent(args), args.This());
}",67,,1187,2,,void
208072,BLOCK,-1,,"{
  // Implement `kClone in this ? kCloneable : kTransferable`.
  HandleScope handle_scope(env()->isolate());
  errors::TryCatchScope ignore_exceptions(env());

  bool has_clone;
  if (!object()->Has(env()->context(),
                     env()->messaging_clone_symbol()).To(&has_clone)) {
    return TransferMode::kUntransferable;
  }

  return has_clone ? TransferMode::kCloneable : TransferMode::kTransferable;
}",70,,1192,1,,void
208102,BLOCK,-1,,"{
    return TransferMode::kUntransferable;
  }",71,,1199,2,,void
208119,BLOCK,-1,,"{
  return TransferOrClone(TransferMode::kTransferable);
}",70,,1206,1,,void
208128,BLOCK,-1,,"{
  return TransferOrClone(TransferMode::kCloneable);
}",73,,1210,1,,void
208138,BLOCK,-1,,"{
  // Call `this[symbol]()` where `symbol` is `kClone` or `kTransfer`,
  // which should return an object with `data` and `deserializeInfo` properties;
  // `data` is written to the serializer later, and `deserializeInfo` is stored
  // on the `TransferData` instance as a string.
  HandleScope handle_scope(env()->isolate());
  Local<Context> context = env()->isolate()->GetCurrentContext();
  Local<Symbol> method_name = mode == TransferMode::kCloneable ?
      env()->messaging_clone_symbol() : env()->messaging_transfer_symbol();

  Local<Value> method;
  if (!object()->Get(context, method_name).ToLocal(&method)) {
    return {};
  }
  if (method->IsFunction()) {
    Local<Value> result_v;
    if (!method.As<Function>()->Call(
            context, object(), 0, nullptr).ToLocal(&result_v)) {
      return {};
    }

    if (result_v->IsObject()) {
      Local<Object> result = result_v.As<Object>();
      Local<Value> data;
      Local<Value> deserialize_info;
      if (!result->Get(con...",30,,1215,2,,void
208196,BLOCK,-1,,"{
    return {};
  }",62,,1226,2,,void
208203,BLOCK,-1,,"{
    Local<Value> result_v;
    if (!method.As<Function>()->Call(
            context, object(), 0, nullptr).ToLocal(&result_v)) {
      return {};
    }

    if (result_v->IsObject()) {
      Local<Object> result = result_v.As<Object>();
      Local<Value> data;
      Local<Value> deserialize_info;
      if (!result->Get(context, env()->data_string()).ToLocal(&data) ||
          !result->Get(context, env()->deserialize_info_string())
              .ToLocal(&deserialize_info)) {
        return {};
      }
      Utf8Value deserialize_info_str(env()->isolate(), deserialize_info);
      if (*deserialize_info_str == nullptr) return {};
      return std::make_unique<Data>(
          *deserialize_info_str, Global<Value>(env()->isolate(), data));
    }
  }",29,,1229,2,,void
208227,BLOCK,-1,,"{
      return {};
    }",64,,1232,2,,void
208234,BLOCK,-1,,"{
      Local<Object> result = result_v.As<Object>();
      Local<Value> data;
      Local<Value> deserialize_info;
      if (!result->Get(context, env()->data_string()).ToLocal(&data) ||
          !result->Get(context, env()->deserialize_info_string())
              .ToLocal(&deserialize_info)) {
        return {};
      }
      Utf8Value deserialize_info_str(env()->isolate(), deserialize_info);
      if (*deserialize_info_str == nullptr) return {};
      return std::make_unique<Data>(
          *deserialize_info_str, Global<Value>(env()->isolate(), data));
    }",31,,1236,2,,void
208287,BLOCK,-1,,"{
        return {};
      }",44,,1242,2,,void
208301,BLOCK,-1,,<empty>,45,,1246,2,,void
208331,BLOCK,-1,,<empty>,5,,1253,2,,void
208338,BLOCK,-1,,<empty>,5,,1255,1,,void
208343,BLOCK,-1,,"{
  // Call `this[kTransferList]()` and return the resulting list of BaseObjects.
  HandleScope handle_scope(env()->isolate());
  Local<Context> context = env()->isolate()->GetCurrentContext();
  Local<Symbol> method_name = env()->messaging_transfer_list_symbol();

  Local<Value> method;
  if (!object()->Get(context, method_name).ToLocal(&method)) {
    return Nothing<BaseObjectList>();
  }
  if (!method->IsFunction()) return Just(BaseObjectList {});

  Local<Value> list_v;
  if (!method.As<Function>()->Call(
          context, object(), 0, nullptr).ToLocal(&list_v)) {
    return Nothing<BaseObjectList>();
  }
  if (!list_v->IsArray()) return Just(BaseObjectList {});
  Local<Array> list = list_v.As<Array>();

  BaseObjectList ret;
  for (size_t i = 0; i < list->Length(); i++) {
    Local<Value> value;
    if (!list->Get(context, i).ToLocal(&value))
      return Nothing<BaseObjectList>();
    if (value->IsObject() && BaseObject::IsBaseObject(value.As<Object>()))
      ret.emplace_bac...",45,,1259,1,,void
208391,BLOCK,-1,,"{
    return Nothing<BaseObjectList>();
  }",62,,1266,2,,void
208400,BLOCK,-1,,<empty>,30,,1269,2,,void
208428,BLOCK,-1,,"{
    return Nothing<BaseObjectList>();
  }",60,,1273,2,,void
208437,BLOCK,-1,,<empty>,27,,1276,2,,void
208454,BLOCK,-1,,<empty>,3,,1280,1,,void
208467,BLOCK,4,,"{
    Local<Value> value;
    if (!list->Get(context, i).ToLocal(&value))
      return Nothing<BaseObjectList>();
    if (value->IsObject() && BaseObject::IsBaseObject(value.As<Object>()))
      ret.emplace_back(Unwrap<BaseObject>(value));
  }",47,,1280,4,,void
208486,BLOCK,-1,,<empty>,7,,1283,2,,void
208503,BLOCK,-1,,<empty>,7,,1285,2,,void
208521,BLOCK,-1,,"{
  // Call `this[kDeserialize](data)` where `data` comes from the return value
  // of `this[kTransfer]()` or `this[kClone]()`.
  HandleScope handle_scope(env()->isolate());
  Local<Value> data;
  if (!deserializer->ReadValue(context).ToLocal(&data)) return Nothing<bool>();

  Local<Symbol> method_name = env()->messaging_deserialize_symbol();
  Local<Value> method;
  if (!object()->Get(context, method_name).ToLocal(&method)) {
    return Nothing<bool>();
  }
  if (!method->IsFunction()) return Just(true);

  if (method.As<Function>()->Call(context, object(), 1, &data).IsEmpty()) {
    return Nothing<bool>();
  }
  return Just(true);
}",62,,1291,3,,void
208545,BLOCK,-1,,<empty>,57,,1296,2,,void
208576,BLOCK,-1,,"{
    return Nothing<bool>();
  }",62,,1300,2,,void
208585,BLOCK,-1,,<empty>,30,,1303,2,,void
208605,BLOCK,-1,,"{
    return Nothing<bool>();
  }",75,,1305,2,,void
208616,BLOCK,-1,,<empty>,30,,1314,3,,void
208623,BLOCK,-1,,"{
  // Create the JS wrapper object that will later be filled with data passed to
  // the `[kDeserialize]()` method on it. This split is necessary, because here
  // we need to create an object with the right prototype and internal fields,
  // but the actual JS data stored in the serialized data can only be read at
  // the end of the stream, after the main message has been read.

  if (context != env->context()) {
    THROW_ERR_MESSAGE_TARGET_CONTEXT_UNAVAILABLE(env);
    return {};
  }
  HandleScope handle_scope(env->isolate());
  Local<Value> info;
  if (!ToV8Value(context, deserialize_info_).ToLocal(&info)) return {};

  Local<Value> ret;
  CHECK(!env->messaging_deserialize_create_object().IsEmpty());
  if (!env->messaging_deserialize_create_object()
           ->Call(context, Null(env->isolate()), 1, &info)
           .ToLocal(&ret) ||
      !ret->IsObject() || !BaseObject::IsBaseObject(ret.As<Object>())) {
    return {};
  }

  return BaseObjectPtr<BaseObject> { Unwrap<BaseO...",41,,1319,4,,void
208631,BLOCK,-1,,"{
    THROW_ERR_MESSAGE_TARGET_CONTEXT_UNAVAILABLE(env);
    return {};
  }",34,,1326,2,,void
208656,BLOCK,-1,,<empty>,62,,1332,2,,void
208711,BLOCK,-1,,"{
    return {};
  }",72,,1339,2,,void
208726,BLOCK,-1,,"{
  HandleScope handle_scope(context->GetIsolate());
  auto ret = serializer->WriteValue(context, PersistentToLocal::Strong(data_));
  data_.Reset();
  return ret;
}",58,,1347,3,,void
208756,BLOCK,-1,,"{
  Mutex::ScopedLock lock(SiblingGroup::groups_mutex_);
  std::shared_ptr<SiblingGroup> group;
  auto i = groups_.find(name);
  if (i == groups_.end() || i->second.expired()) {
    group = std::make_shared<SiblingGroup>(name);
    groups_[name] = group;
  } else {
    group = i->second.lock();
  }
  return group;
}",74,,1354,2,,void
208791,BLOCK,-1,,"{
    group = std::make_shared<SiblingGroup>(name);
    groups_[name] = group;
  }",50,,1358,2,,void
208807,BLOCK,-1,,"{
    group = i->second.lock();
  }",10,,1361,1,,void
208822,BLOCK,-1,,"{
  Mutex::ScopedLock lock(SiblingGroup::groups_mutex_);
  auto i = groups_.find(name);
  if (i != groups_.end() && i->second.expired())
    groups_.erase(name);
}",63,,1367,2,,void
208850,BLOCK,-1,,<empty>,5,,1371,2,,void
208860,BLOCK,-1,,{ },19,,1375,2,,void
208864,BLOCK,-1,,"{
  // If this is a named group, check to see if we can remove the group
  if (!name_.empty())
    CheckSiblingGroup(name_);
}",31,,1377,1,,void
208871,BLOCK,-1,,<empty>,5,,1380,2,,void
208879,BLOCK,-1,,"{

  RwLock::ScopedReadLock lock(group_mutex_);

  // The source MessagePortData is not part of this group.
  if (ports_.find(source) == ports_.end()) {
    if (error != nullptr)
      *error = ""Source MessagePort is not entangled with this group."";
    return Nothing<bool>();
  }

  // There are no destination ports.
  if (size() <= 1)
    return Just(false);

  // Transferables cannot be used when there is more
  // than a single destination.
  if (size() > 2 && message->has_transferables()) {
    if (error != nullptr)
      *error = ""Transferables cannot be used with multiple destinations."";
    return Nothing<bool>();
  }

  for (MessagePortData* port : ports_) {
    if (port == source)
      continue;
    // This loop should only be entered if there's only a single destination
    for (const auto& transferable : message->transferables()) {
      if (port == transferable.get()) {
        if (error != nullptr) {
          *error = ""The target port was posted to itself, and the ""
...",25,,1386,4,,void
208894,BLOCK,-1,,"{
    if (error != nullptr)
      *error = ""Source MessagePort is not entangled with this group."";
    return Nothing<bool>();
  }",44,,1391,2,,void
208899,BLOCK,-1,,<empty>,7,,1393,2,,void
208910,BLOCK,-1,,<empty>,5,,1399,2,,void
208923,BLOCK,-1,,"{
    if (error != nullptr)
      *error = ""Transferables cannot be used with multiple destinations."";
    return Nothing<bool>();
  }",51,,1403,2,,void
208928,BLOCK,-1,,<empty>,7,,1405,2,,void
208938,BLOCK,-1,,"{
    if (port == source)
      continue;
    // This loop should only be entered if there's only a single destination
    for (const auto& transferable : message->transferables()) {
      if (port == transferable.get()) {
        if (error != nullptr) {
          *error = ""The target port was posted to itself, and the ""
                   ""communication channel was lost"";
        }
        return Just(true);
      }
    }
    port->AddToIncomingQueue(message);
  }",40,,1409,3,,void
208943,BLOCK,-1,,<empty>,7,,1411,2,,void
208951,BLOCK,-1,,"{
      if (port == transferable.get()) {
        if (error != nullptr) {
          *error = ""The target port was posted to itself, and the ""
                   ""communication channel was lost"";
        }
        return Just(true);
      }
    }",63,,1413,3,,void
208959,BLOCK,-1,,"{
        if (error != nullptr) {
          *error = ""The target port was posted to itself, and the ""
                   ""communication channel was lost"";
        }
        return Just(true);
      }",39,,1414,2,,void
208964,BLOCK,-1,,"{
          *error = ""The target port was posted to itself, and the ""
                   ""communication channel was lost"";
        }",31,,1415,2,,void
208984,BLOCK,-1,,"{
  Entangle({ port });
}",52,,1428,2,,void
208992,BLOCK,-1,,"{
  RwLock::ScopedWriteLock lock(group_mutex_);
  for (MessagePortData* data : ports) {
    ports_.insert(data);
    CHECK(!data->group_);
    data->group_ = shared_from_this();
  }
}",76,,1432,2,,void
208999,BLOCK,-1,,"{
    ports_.insert(data);
    CHECK(!data->group_);
    data->group_ = shared_from_this();
  }",39,,1434,3,,void
209019,BLOCK,-1,,"{
  auto self = shared_from_this();  // Keep alive until end of function.
  RwLock::ScopedWriteLock lock(group_mutex_);
  ports_.erase(data);
  data->group_.reset();

  data->AddToIncomingQueue(std::make_shared<Message>());
  // If this is an anonymous group and there's another port, close it.
  if (size() == 1 && name_.empty())
    (*(ports_.begin()))->AddToIncomingQueue(std::make_shared<Message>());
}",55,,1441,2,,void
209055,BLOCK,-1,,<empty>,5,,1450,2,,void
209075,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsFunction());
  env->set_messaging_deserialize_create_object(args[0].As<Function>());
}",46,,1459,2,,void
209105,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  if (!args.IsConstructCall()) {
    THROW_ERR_CONSTRUCT_CALL_REQUIRED(env);
    return;
  }

  Local<Context> context = args.This()->GetCreationContext().ToLocalChecked();
  Context::Scope context_scope(context);

  MessagePort* port1 = MessagePort::New(env, context);
  if (port1 == nullptr) return;
  MessagePort* port2 = MessagePort::New(env, context);
  if (port2 == nullptr) {
    port1->Close();
    return;
  }

  MessagePort::Entangle(port1, port2);

  args.This()->Set(context, env->port1_string(), port1->object())
      .Check();
  args.This()->Set(context, env->port2_string(), port2->object())
      .Check();
}",69,,1465,2,,void
209120,BLOCK,-1,,"{
    THROW_ERR_CONSTRUCT_CALL_REQUIRED(env);
    return;
  }",32,,1467,2,,void
209156,BLOCK,-1,,<empty>,25,,1476,2,,void
209171,BLOCK,-1,,"{
    port1->Close();
    return;
  }",25,,1478,2,,void
209225,BLOCK,-1,,"{
  CHECK(args[0]->IsString());
  Environment* env = Environment::GetCurrent(args);
  Context::Scope context_scope(env->context());
  Utf8Value name(env->isolate(), args[0]);
  MessagePort* port =
      MessagePort::New(env, env->context(), {}, SiblingGroup::Get(*name));
  if (port != nullptr) {
    args.GetReturnValue().Set(port->object());
  }
}",71,,1491,2,,void
209279,BLOCK,-1,,"{
    args.GetReturnValue().Set(port->object());
  }",24,,1498,2,,void
209298,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  {
    SetConstructorFunction(context,
                           target,
                           ""MessageChannel"",
                           NewFunctionTemplate(isolate, MessageChannel));
  }

  {
    Local<FunctionTemplate> t =
        NewFunctionTemplate(isolate, JSTransferable::New);
    t->InstanceTemplate()->SetInternalFieldCount(
        JSTransferable::kInternalFieldCount);
    t->SetClassName(OneByteString(isolate, ""JSTransferable""));
    SetConstructorFunction(
        context, target, ""JSTransferable"", t, SetConstructorFunctionFlag::NONE);
  }

  SetConstructorFunction(context,
                         target,
                         env->message_port_constructor_string(),
                         GetMessagePortConstructorTemplate(env),
                         SetConstructorFunctionFlag::NONE);

  // These are not methods on the MessagePort prototype, because
  // the bro...",39,,1506,5,,void
209314,BLOCK,5,,"{
    SetConstructorFunction(context,
                           target,
                           ""MessageChannel"",
                           NewFunctionTemplate(isolate, MessageChannel));
  }",3,,1510,5,,void
209322,BLOCK,6,,"{
    Local<FunctionTemplate> t =
        NewFunctionTemplate(isolate, JSTransferable::New);
    t->InstanceTemplate()->SetInternalFieldCount(
        JSTransferable::kInternalFieldCount);
    t->SetClassName(OneByteString(isolate, ""JSTransferable""));
    SetConstructorFunction(
        context, target, ""JSTransferable"", t, SetConstructorFunctionFlag::NONE);
  }",3,,1517,6,,void
209416,BLOCK,15,,"{
    Local<Function> domexception = GetDOMException(context).ToLocalChecked();
    target
        ->Set(context,
              FIXED_ONE_BYTE_STRING(env->isolate(), ""DOMException""),
              domexception)
        .Check();
  }",3,,1548,15,,void
209447,BLOCK,-1,,"{
  registry->Register(MessageChannel);
  registry->Register(BroadcastChannel);
  registry->Register(JSTransferable::New);
  registry->Register(MessagePort::New);
  registry->Register(MessagePort::PostMessage);
  registry->Register(MessagePort::Start);
  registry->Register(MessagePort::Stop);
  registry->Register(MessagePort::CheckType);
  registry->Register(MessagePort::Drain);
  registry->Register(MessagePort::ReceiveMessage);
  registry->Register(MessagePort::MoveToContext);
  registry->Register(SetDeserializerCreateObjectFunction);
}",77,,1558,2,,void
209547,BLOCK,-1,,<empty>,1,,1,1,,ANY
209602,BLOCK,-1,,<empty>,1,,1,1,,ANY
209607,BLOCK,-1,,"{
  node = NODE_VERSION_STRING;
  v8 = v8::V8::GetVersion();
  uv = uv_version_string();
  zlib = ZLIB_VERSION;
  ares = ARES_VERSION_STR;
  modules = NODE_STRINGIFY(NODE_MODULE_VERSION);
  nghttp2 = NGHTTP2_VERSION;
  napi = NODE_STRINGIFY(NAPI_VERSION);
  llhttp =
      NODE_STRINGIFY(LLHTTP_VERSION_MAJOR)
      "".""
      NODE_STRINGIFY(LLHTTP_VERSION_MINOR)
      "".""
      NODE_STRINGIFY(LLHTTP_VERSION_PATCH);

  brotli =
    std::to_string(BrotliEncoderVersion() >> 24) +
    ""."" +
    std::to_string((BrotliEncoderVersion() & 0xFFF000) >> 12) +
    ""."" +
    std::to_string(BrotliEncoderVersion() & 0xFFF);
#ifndef NODE_SHARED_BUILTIN_UNDICI_UNDICI_PATH
  undici = UNDICI_VERSION;
#endif

  acorn = ACORN_VERSION;
  cjs_module_lexer = CJS_MODULE_LEXER_VERSION;
  base64 = BASE64_VERSION;
  uvwasi = UVWASI_VERSION_STRING;

#if HAVE_OPENSSL
  openssl = GetOpenSSLVersion();
#endif

#ifdef NODE_HAVE_I18N_SUPPORT
  icu = U_ICU_VERSION;
  unicode = U_UNICODE_VERSION;
#endif  // NODE_HAVE_I1...",32,,77,1,,void
209611,BLOCK,1,,<empty>,,,,1,,void
209633,BLOCK,1,,<empty>,,,,1,,void
209641,BLOCK,1,,<empty>,,,,1,,void
209646,BLOCK,1,,<empty>,,,,1,,void
209682,BLOCK,1,,<empty>,,,,1,,void
209687,BLOCK,1,,<empty>,,,,1,,void
209692,BLOCK,1,,<empty>,,,,1,,void
209697,BLOCK,1,,<empty>,,,,1,,void
209711,BLOCK,-1,,"{
#if NODE_VERSION_IS_LTS
  lts = NODE_VERSION_LTS_CODENAME;
#endif  // NODE_VERSION_IS_LTS

#ifdef NODE_HAS_RELEASE_URLS
#define NODE_RELEASE_URLPFX NODE_RELEASE_URLBASE ""v"" NODE_VERSION_STRING ""/""
#define NODE_RELEASE_URLFPFX NODE_RELEASE_URLPFX ""node-v"" NODE_VERSION_STRING

  source_url = NODE_RELEASE_URLFPFX "".tar.gz"";
  headers_url = NODE_RELEASE_URLFPFX ""-headers.tar.gz"";
#ifdef _WIN32
  lib_url = strcmp(NODE_ARCH, ""ia32"") ? NODE_RELEASE_URLPFX ""win-"" NODE_ARCH
                                                           ""/node.lib""
                                     : NODE_RELEASE_URLPFX ""win-x86/node.lib"";
#endif  // _WIN32

#endif  // NODE_HAS_RELEASE_URLS
}",51,,126,1,,void
209715,BLOCK,-1,,<empty>,65,,146,1,,void
209730,BLOCK,-1,,<empty>,1,,1,1,,ANY
209743,BLOCK,-1,,<empty>,1,,1,1,,ANY
209752,BLOCK,-1,,<empty>,1,,1,1,,ANY
209756,BLOCK,-1,,"{
    refs_ = 0;
  }",16,,33,1,,void
209763,BLOCK,-1,,"{
    if (persistent().IsEmpty())
      return;
    persistent().ClearWeak();
    persistent().Reset();
  }",25,,38,1,,void
209769,BLOCK,-1,,<empty>,7,,40,2,,void
209783,BLOCK,-1,,"{
    assert(!handle.IsEmpty());
    assert(handle->InternalFieldCount() > 0);
    // Cast to ObjectWrap before casting to T.  A direct cast from void
    // to T won't work right when T has more than one base class.
    void* ptr = handle->GetAlignedPointerFromInternalField(0);
    ObjectWrap* wrap = static_cast<ObjectWrap*>(ptr);
    return static_cast<T*>(wrap);
  }",57,,47,2,,void
209818,BLOCK,-1,,"{
    return handle(v8::Isolate::GetCurrent());
  }",41,,58,1,,void
209831,BLOCK,-1,,"{
    return v8::Local<v8::Object>::New(isolate, persistent());
  }",61,,63,2,,void
209850,BLOCK,-1,,"{
    return handle_;
  }",51,,69,1,,void
209857,BLOCK,-1,,"{
    assert(persistent().IsEmpty());
    assert(handle->InternalFieldCount() > 0);
    handle->SetAlignedPointerInInternalField(0, this);
    persistent().Reset(v8::Isolate::GetCurrent(), handle);
    MakeWeak();
  }",50,,75,2,,void
209891,BLOCK,-1,,"{
    persistent().SetWeak(this, WeakCallback, v8::WeakCallbackType::kParameter);
  }",26,,84,1,,void
209906,BLOCK,-1,,"{
    assert(!persistent().IsEmpty());
    persistent().ClearWeak();
    refs_++;
  }",22,,92,1,,void
209922,BLOCK,-1,,"{
    assert(!persistent().IsEmpty());
    assert(!persistent().IsWeak());
    assert(refs_ > 0);
    if (--refs_ == 0)
      MakeWeak();
  }",24,,107,1,,void
209944,BLOCK,-1,,<empty>,7,,112,2,,void
209951,BLOCK,-1,,"{
    ObjectWrap* wrap = data.GetParameter();
    assert(wrap->refs_ == 0);
    wrap->handle_.Reset();
    delete wrap;
  }",53,,119,2,,void
209986,BLOCK,-1,,<empty>,1,,1,1,,ANY
209989,BLOCK,-1,,"{
    per_process::cli_options->per_isolate->per_env = original_per_env;
    per_process::cli_options->per_isolate = original_per_isolate;
  }",44,,1104,1,,void
210014,BLOCK,-1,,"{
    std::string text;
    return credentials::SafeGetenv(name, &text) ? text : """";
  }",54,,1293,2,,void
210060,BLOCK,-1,,<empty>,1,,1,1,,ANY
210073,BLOCK,-1,,"{
#if !NODE_USE_V8_PLATFORM && !HAVE_INSPECTOR
  if (inspector_enabled) {
    errors->push_back(""Inspector is not available when Node is compiled ""
                      ""--without-v8-platform and --without-inspector."");
  }
#endif

  if (deprecated_debug) {
    errors->push_back(""[DEP0062]: `node --debug` and `node --debug-brk` ""
                      ""are invalid. Please use `node --inspect` and ""
                      ""`node --inspect-brk` instead."");
  }

  using std::string_view_literals::operator""""sv;
  const std::vector<std::string_view> destinations =
      SplitString(inspect_publish_uid_string, "",""sv);
  inspect_publish_uid.console = false;
  inspect_publish_uid.http = false;
  for (const std::string_view destination : destinations) {
    if (destination == ""stderr""sv) {
      inspect_publish_uid.console = true;
    } else if (destination == ""http""sv) {
      inspect_publish_uid.http = true;
    } else {
      errors->push_back(""--inspect-publish-uid destination can be ""
 ...",65,,40,3,,void
210076,BLOCK,-1,,"{
    errors->push_back(""Inspector is not available when Node is compiled ""
                      ""--without-v8-platform and --without-inspector."");
  }",26,,42,2,,void
210084,BLOCK,-1,,"{
    errors->push_back(""[DEP0062]: `node --debug` and `node --debug-brk` ""
                      ""are invalid. Please use `node --inspect` and ""
                      ""`node --inspect-brk` instead."");
  }",25,,48,2,,void
210109,BLOCK,-1,,"{
    if (destination == ""stderr""sv) {
      inspect_publish_uid.console = true;
    } else if (destination == ""http""sv) {
      inspect_publish_uid.http = true;
    } else {
      errors->push_back(""--inspect-publish-uid destination can be ""
                        ""stderr or http"");
    }
  }",59,,59,3,,void
210114,BLOCK,-1,,"{
      inspect_publish_uid.console = true;
    }",36,,60,2,,void
210121,BLOCK,-1,,<empty>,12,,62,1,,void
210126,BLOCK,-1,,"{
      inspect_publish_uid.http = true;
    }",41,,62,2,,void
210133,BLOCK,-1,,"{
      errors->push_back(""--inspect-publish-uid destination can be ""
                        ""stderr or http"");
    }",12,,64,1,,void
210144,BLOCK,-1,,"{
#if HAVE_OPENSSL
  if (use_openssl_ca && use_bundled_ca) {
    errors->push_back(""either --use-openssl-ca or --use-bundled-ca can be ""
                      ""used, not both"");
  }

  // Any value less than 2 disables use of the secure heap.
  if (secure_heap >= 2) {
    if ((secure_heap & (secure_heap - 1)) != 0)
      errors->push_back(""--secure-heap must be a power of 2"");
    secure_heap_min =
        std::min({
            secure_heap,
            secure_heap_min,
            static_cast<int64_t>(std::numeric_limits<int>::max())});
    secure_heap_min = std::max(static_cast<int64_t>(2), secure_heap_min);
    if ((secure_heap_min & (secure_heap_min - 1)) != 0)
      errors->push_back(""--secure-heap-min must be a power of 2"");
  }
#endif  // HAVE_OPENSSL

  if (use_largepages != ""off"" &&
      use_largepages != ""on"" &&
      use_largepages != ""silent"") {
    errors->push_back(""invalid value for --use-largepages"");
  }
  per_isolate->CheckOptions(errors, argv);
}",70,,72,3,,void
210157,BLOCK,-1,,"{
    errors->push_back(""invalid value for --use-largepages"");
  }",35,,96,2,,void
210174,BLOCK,-1,,"{
  per_env->CheckOptions(errors, argv);
}",70,,103,3,,void
210186,BLOCK,-1,,"{
  if (has_policy_integrity_string && experimental_policy.empty()) {
    errors->push_back(""--policy-integrity requires ""
                      ""--experimental-policy be enabled"");
  }
  if (has_policy_integrity_string && experimental_policy_integrity.empty()) {
    errors->push_back(""--policy-integrity cannot be empty"");
  }

  if (!module_type.empty()) {
    if (module_type != ""commonjs"" && module_type != ""module"") {
      errors->push_back(""--input-type must be \""module\"" or \""commonjs\"""");
    }
  }

  if (syntax_check_only && has_eval_string) {
    errors->push_back(""either --check or --eval can be used, not both"");
  }

  if (!unhandled_rejections.empty() &&
      unhandled_rejections != ""warn-with-error-code"" &&
      unhandled_rejections != ""throw"" &&
      unhandled_rejections != ""strict"" &&
      unhandled_rejections != ""warn"" &&
      unhandled_rejections != ""none"") {
    errors->push_back(""invalid value for --unhandled-rejections"");
  }

  if (tls_min_v1_3 && tls_max_v1...",71,,108,3,,void
210194,BLOCK,-1,,"{
    errors->push_back(""--policy-integrity requires ""
                      ""--experimental-policy be enabled"");
  }",67,,109,2,,void
210207,BLOCK,-1,,"{
    errors->push_back(""--policy-integrity cannot be empty"");
  }",77,,113,2,,void
210219,BLOCK,-1,,"{
    if (module_type != ""commonjs"" && module_type != ""module"") {
      errors->push_back(""--input-type must be \""module\"" or \""commonjs\"""");
    }
  }",29,,117,2,,void
210228,BLOCK,-1,,"{
      errors->push_back(""--input-type must be \""module\"" or \""commonjs\"""");
    }",63,,118,2,,void
210235,BLOCK,-1,,<empty>,7,,123,1,,void
210237,BLOCK,-1,,"{
    errors->push_back(""either --check or --eval can be used, not both"");
  }",45,,123,2,,void
210269,BLOCK,-1,,"{
    errors->push_back(""invalid value for --unhandled-rejections"");
  }",39,,132,2,,void
210276,BLOCK,-1,,<empty>,7,,136,1,,void
210278,BLOCK,-1,,"{
    errors->push_back(""either --tls-min-v1.3 or --tls-max-v1.2 can be ""
                      ""used, not both"");
  }",37,,136,2,,void
210288,BLOCK,-1,,"{
    errors->push_back(""--heapsnapshot-near-heap-limit must not be negative"");
  }",42,,141,2,,void
210296,BLOCK,-1,,"{
    if (syntax_check_only) {
      errors->push_back(""either --test or --check can be used, not both"");
    }

    if (has_eval_string) {
      errors->push_back(""either --test or --eval can be used, not both"");
    }

    if (force_repl) {
      errors->push_back(""either --test or --interactive can be used, not both"");
    }

    if (watch_mode_paths.size() > 0) {
      errors->push_back(
          ""--watch-path cannot be used in combination with --test"");
    }

#ifndef ALLOW_ATTACHING_DEBUGGER_IN_TEST_RUNNER
    debug_options_.allow_attaching_debugger = false;
#endif
  }",20,,145,2,,void
210299,BLOCK,-1,,"{
      errors->push_back(""either --test or --check can be used, not both"");
    }",28,,146,2,,void
210307,BLOCK,-1,,"{
      errors->push_back(""either --test or --eval can be used, not both"");
    }",26,,150,2,,void
210315,BLOCK,-1,,"{
      errors->push_back(""either --test or --interactive can be used, not both"");
    }",21,,154,2,,void
210328,BLOCK,-1,,"{
      errors->push_back(
          ""--watch-path cannot be used in combination with --test"");
    }",38,,158,2,,void
210341,BLOCK,-1,,"{
    if (syntax_check_only) {
      errors->push_back(""either --watch or --check can be used, not both"");
    } else if (has_eval_string) {
      errors->push_back(""either --watch or --eval can be used, not both"");
    } else if (force_repl) {
      errors->push_back(""either --watch or --interactive ""
                        ""can be used, not both"");
    } else if (argv->size() < 1 || (*argv)[1].empty()) {
      errors->push_back(""--watch requires specifying a file"");
    }

#ifndef ALLOW_ATTACHING_DEBUGGER_IN_WATCH_MODE
    debug_options_.allow_attaching_debugger = false;
#endif
  }",19,,168,2,,void
210344,BLOCK,-1,,"{
      errors->push_back(""either --watch or --check can be used, not both"");
    }",28,,169,2,,void
210351,BLOCK,-1,,<empty>,12,,171,1,,void
210354,BLOCK,-1,,"{
      errors->push_back(""either --watch or --eval can be used, not both"");
    }",33,,171,2,,void
210361,BLOCK,-1,,<empty>,12,,173,1,,void
210364,BLOCK,-1,,"{
      errors->push_back(""either --watch or --interactive ""
                        ""can be used, not both"");
    }",28,,173,2,,void
210371,BLOCK,-1,,<empty>,12,,176,1,,void
210387,BLOCK,-1,,"{
      errors->push_back(""--watch requires specifying a file"");
    }",56,,176,2,,void
210403,BLOCK,-1,,<empty>,,,,1,,<empty>
210408,BLOCK,-1,,<empty>,,,,1,,<empty>
210413,BLOCK,-1,,"{
    Insert(dop, &EnvironmentOptions::get_debug_options);
  }",34,,237,2,,void
210424,BLOCK,-1,,<empty>,,,,1,,<empty>
210429,BLOCK,-1,,<empty>,,,,2,,<empty>
210434,BLOCK,-1,,<empty>,,,,1,,<empty>
210439,BLOCK,-1,,<empty>,,,,2,,<empty>
210463,BLOCK,-1,,"{
  _piop_instance.Parse(
    args, exec_args, v8_args, options, required_env_settings, errors);
}",75,,279,7,,void
210483,BLOCK,-1,,"{
  _ppop_instance.Parse(
    args, exec_args, v8_args, options, required_env_settings, errors);
}",75,,289,7,,void
210497,BLOCK,-1,,"{
#ifndef DISABLE_SINGLE_EXECUTABLE_APPLICATION
  if (sea::IsSingleExecutable()) return;
#endif

  AddOption(""--inspect-port"",
            ""set host:port for inspector"",
            &DebugOptions::host_port,
            kAllowedInEnvvar);
  AddAlias(""--debug-port"", ""--inspect-port"");

  AddOption(""--inspect"",
            ""activate inspector on host:port (default: 127.0.0.1:9229)"",
            &DebugOptions::inspector_enabled,
            kAllowedInEnvvar);
  AddAlias(""--inspect="", { ""--inspect-port"", ""--inspect"" });

  AddOption(""--debug"", """", &DebugOptions::deprecated_debug);
  AddAlias(""--debug="", ""--debug"");
  AddOption(""--debug-brk"", """", &DebugOptions::deprecated_debug);
  AddAlias(""--debug-brk="", ""--debug-brk"");

  AddOption(""--inspect-brk"",
            ""activate inspector on host:port and break at start of user script"",
            &DebugOptions::break_first_line,
            kAllowedInEnvvar);
  Implies(""--inspect-brk"", ""--inspect"");
  AddAlias(""--inspect-brk="", { ""--inspect-...",42,,298,1,,void
210503,BLOCK,-1,,<empty>,34,,300,2,,void
210591,BLOCK,-1,,"{
  AddOption(""--conditions"",
            ""additional user conditions for conditional exports and imports"",
            &EnvironmentOptions::conditions,
            kAllowedInEnvvar);
  AddAlias(""-C"", ""--conditions"");
  AddOption(""--diagnostic-dir"",
            ""set dir for all output files""
            "" (default: current working directory)"",
            &EnvironmentOptions::diagnostic_dir,
            kAllowedInEnvvar);
  AddOption(""--dns-result-order"",
            ""set default value of verbatim in dns.lookup. Options are ""
            ""'ipv4first' (IPv4 addresses are placed before IPv6 addresses) ""
            ""'verbatim' (addresses are in the order the DNS resolver ""
            ""returned)"",
            &EnvironmentOptions::dns_result_order,
            kAllowedInEnvvar);
  AddOption(""--network-family-autoselection"",
            ""Disable network address family autodetection algorithm"",
            &EnvironmentOptions::network_family_autoselection,
            kAllowedInEnvvar,
 ...",54,,338,1,,void
211321,BLOCK,-1,,"{
  AddOption(""--track-heap-objects"",
            ""track heap object allocations for heap snapshots"",
            &PerIsolateOptions::track_heap_objects,
            kAllowedInEnvvar);

  // Explicitly add some V8 flags to mark them as allowed in NODE_OPTIONS.
  AddOption(""--abort-on-uncaught-exception"",
            ""aborting instead of exiting causes a core file to be generated ""
            ""for analysis"",
            V8Option{},
            kAllowedInEnvvar);
  AddOption(""--interpreted-frames-native-stack"",
            ""help system profilers to translate JavaScript interpreted frames"",
            V8Option{},
            kAllowedInEnvvar);
  AddOption(""--max-old-space-size"", """", V8Option{}, kAllowedInEnvvar);
  AddOption(""--max-semi-space-size"", """", V8Option{}, kAllowedInEnvvar);
  AddOption(""--perf-basic-prof"", """", V8Option{}, kAllowedInEnvvar);
  AddOption(
      ""--perf-basic-prof-only-functions"", """", V8Option{}, kAllowedInEnvvar);
  AddOption(""--perf-prof"", """", V8Option{}, kA...",40,,742,2,,void
211481,BLOCK,-1,,"{
  AddOption(""--title"",
            ""the process title to use on startup"",
            &PerProcessOptions::title,
            kAllowedInEnvvar);
  AddOption(""--trace-event-categories"",
            ""comma separated list of trace event categories to record"",
            &PerProcessOptions::trace_event_categories,
            kAllowedInEnvvar);
  AddOption(""--trace-event-file-pattern"",
            ""Template string specifying the filepath for the trace-events ""
            ""data, it supports ${rotation} and ${pid}."",
            &PerProcessOptions::trace_event_file_pattern,
            kAllowedInEnvvar);
  AddAlias(""--trace-events-enabled"", {
    ""--trace-event-categories"", ""v8,node,node.async_hooks"" });
  AddOption(""--v8-pool-size"",
            ""set V8's thread pool size"",
            &PerProcessOptions::v8_thread_pool_size,
            kAllowedInEnvvar);
  AddOption(""--zero-fill-buffers"",
            ""automatically zero-fill all newly allocated Buffer and ""
            ""SlowBuffer in...",39,,817,2,,void
211683,BLOCK,-1,,"{
  if (!host.empty() && host.front() == '[' && host.back() == ']')
    return host.substr(1, host.size() - 2);
  else
    return host;
}",60,,1000,2,,void
211704,BLOCK,-1,,<empty>,5,,1002,2,,void
211718,BLOCK,-1,,<empty>,5,,1004,1,,void
211726,BLOCK,-1,,"{
  char* endptr;
  errno = 0;
  const unsigned long result =                 // NOLINT(runtime/int)
    strtoul(port.c_str(), &endptr, 10);
  if (errno != 0 || *endptr != '\0'||
      (result != 0 && result < 1024) || result > 65535) {
    errors->push_back("" must be 0 or in range 1024 to 65535."");
  }
  return static_cast<int>(result);
}",67,,1008,3,,void
211763,BLOCK,-1,,"{
    errors->push_back("" must be 0 or in range 1024 to 65535."");
  }",57,,1014,2,,void
211778,BLOCK,-1,,"{
  // remove_brackets only works if no port is specified
  // so if it has an effect only an IPv6 address was specified.
  std::string host = RemoveBrackets(arg);
  if (host.length() < arg.length())
    return HostPort{host, DebugOptions::kDefaultInspectorPort};

  size_t colon = arg.rfind(':');
  if (colon == std::string::npos) {
    // Either a port number or a host name.  Assume that
    // if it's not all decimal digits, it's a host name.
    for (char c : arg) {
      if (c < '0' || c > '9') {
        return HostPort{arg, DebugOptions::kDefaultInspectorPort};
      }
    }
    return HostPort { """", ParseAndValidatePort(arg, errors) };
  }
  // Host and port found:
  return HostPort { RemoveBrackets(arg.substr(0, colon)),
                    ParseAndValidatePort(arg.substr(colon + 1), errors) };
}",57,,1021,3,,void
211794,BLOCK,-1,,<empty>,5,,1026,2,,void
211818,BLOCK,-1,,"{
    // Either a port number or a host name.  Assume that
    // if it's not all decimal digits, it's a host name.
    for (char c : arg) {
      if (c < '0' || c > '9') {
        return HostPort{arg, DebugOptions::kDefaultInspectorPort};
      }
    }
    return HostPort { """", ParseAndValidatePort(arg, errors) };
  }",35,,1029,2,,void
211822,BLOCK,-1,,"{
      if (c < '0' || c > '9') {
        return HostPort{arg, DebugOptions::kDefaultInspectorPort};
      }
    }",24,,1032,3,,void
211831,BLOCK,-1,,"{
        return HostPort{arg, DebugOptions::kDefaultInspectorPort};
      }",31,,1033,2,,void
211868,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  const auto& parser = _ppop_instance;

  std::ostringstream out;

  out << ""_node_complete() {\n""
         ""  local cur_word options\n""
         ""  cur_word=\""${COMP_WORDS[COMP_CWORD]}\""\n""
         ""  if [[ \""${cur_word}\"" == -* ]] ; then\n""
         ""    COMPREPLY=( $(compgen -W '"";

  for (const auto& item : parser.options_) {
    if (item.first[0] != '[') {
      out << item.first << "" "";
    }
  }
  for (const auto& item : parser.aliases_) {
    if (item.first[0] != '[') {
      out << item.first << "" "";
    }
  }
  if (parser.aliases_.size() > 0) {
    out.seekp(-1, out.cur);  // Strip the trailing space
  }

  out << ""' -- \""${cur_word}\"") )\n""
         ""    return 0\n""
         ""  else\n""
         ""    COMPREPLY=( $(compgen -f \""${cur_word}\"") )\n""
         ""    return 0\n""
         ""  fi\n""
         ""}\n""
         ""complete -o filenames -o nospace -o bashdefault ""
         ""-F _node_complete node node_g"";
  return...",33,,1044,1,,void
211887,BLOCK,-1,,"{
    if (item.first[0] != '[') {
      out << item.first << "" "";
    }
  }",44,,1056,3,,void
211896,BLOCK,-1,,"{
      out << item.first << "" "";
    }",31,,1057,2,,void
211909,BLOCK,-1,,"{
    if (item.first[0] != '[') {
      out << item.first << "" "";
    }
  }",44,,1061,3,,void
211918,BLOCK,-1,,"{
      out << item.first << "" "";
    }",31,,1062,2,,void
211935,BLOCK,-1,,"{
    out.seekp(-1, out.cur);  // Strip the trailing space
  }",35,,1066,2,,void
211957,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Environment* env = Environment::GetCurrent(args);
  if (!env->has_run_bootstrapping_code()) {
    // No code because this is an assertion.
    return env->ThrowError(
        ""Should not query options before bootstrapping is done"");
  }
  env->set_has_serialized_options(true);

  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();

  // Temporarily act as if the current Environment's/IsolateData's options were
  // the default options, i.e. like they are the ones we'd access for global
  // options parsing, so that all options are available from the main parser.
  auto original_per_isolate = per_process::cli_options->per_isolate;
  per_process::cli_options->per_isolate = env->isolate_data()->options();
  auto original_per_env = per_process::cli_options->per_isolate->per_env;
  per_process::cli_options->per_isolate->per_env = env->options();
  auto on_scope_leave = OnScopeLeave([&]() {
    per_pro...",61,,1084,2,,void
211977,BLOCK,-1,,"{
    // No code because this is an assertion.
    return env->ThrowError(
        ""Should not query options before bootstrapping is done"");
  }",43,,1087,2,,void
212076,BLOCK,-1,,"{
    return;
  }",25,,1112,2,,void
212083,BLOCK,-1,,"{
    Local<Value> value;
    const auto& option_info = item.second;
    auto field = option_info.field;
    PerProcessOptions* opts = per_process::cli_options.get();
    switch (option_info.type) {
      case kNoOp:
      case kV8Option:
        // Special case for --abort-on-uncaught-exception which is also
        // respected by Node.js internals
        if (item.first == ""--abort-on-uncaught-exception"") {
          value = Boolean::New(
            isolate, original_per_env->abort_on_uncaught_exception);
        } else {
          value = Undefined(isolate);
        }
        break;
      case kBoolean:
        value = Boolean::New(isolate,
                             *_ppop_instance.Lookup<bool>(field, opts));
        break;
      case kInteger:
        value = Number::New(
            isolate,
            static_cast<double>(*_ppop_instance.Lookup<int64_t>(field, opts)));
        break;
      case kUInteger:
        value = Number::New(
            isolate,
            stati...",52,,1116,3,,void
212114,BLOCK,-1,,"{
      case kNoOp:
      case kV8Option:
        // Special case for --abort-on-uncaught-exception which is also
        // respected by Node.js internals
        if (item.first == ""--abort-on-uncaught-exception"") {
          value = Boolean::New(
            isolate, original_per_env->abort_on_uncaught_exception);
        } else {
          value = Undefined(isolate);
        }
        break;
      case kBoolean:
        value = Boolean::New(isolate,
                             *_ppop_instance.Lookup<bool>(field, opts));
        break;
      case kInteger:
        value = Number::New(
            isolate,
            static_cast<double>(*_ppop_instance.Lookup<int64_t>(field, opts)));
        break;
      case kUInteger:
        value = Number::New(
            isolate,
            static_cast<double>(*_ppop_instance.Lookup<uint64_t>(field, opts)));
        break;
      case kString:
        if (!ToV8Value(context,
                       *_ppop_instance.Lookup<std::string>(field, ...",31,,1121,2,,void
212125,BLOCK,-1,,"{
          value = Boolean::New(
            isolate, original_per_env->abort_on_uncaught_exception);
        }",60,,1126,2,,void
212137,BLOCK,-1,,"{
          value = Undefined(isolate);
        }",16,,1129,1,,void
212230,BLOCK,-1,,"{
          return;
        }",36,,1150,2,,void
212255,BLOCK,-1,,"{
          return;
        }",36,,1157,2,,void
212260,BLOCK,29,,"{
        const HostPort& host_port =
          *_ppop_instance.Lookup<HostPort>(field, opts);
        Local<Object> obj = Object::New(isolate);
        Local<Value> host;
        if (!ToV8Value(context, host_port.host()).ToLocal(&host) ||
            obj->Set(context, env->host_string(), host).IsNothing() ||
            obj->Set(context,
                     env->port_string(),
                     Integer::New(isolate, host_port.port()))
                .IsNothing()) {
          return;
        }
        value = obj;
        break;
      }",23,,1161,29,,void
212340,BLOCK,-1,,"{
          return;
        }",31,,1171,2,,void
212510,BLOCK,-1,,"{
      return;
    }",54,,1202,2,,void
212529,BLOCK,-1,,<empty>,71,,1208,2,,void
212547,BLOCK,-1,,"{
    return;
  }",25,,1212,2,,void
212588,BLOCK,-1,,"{
    return;
  }",70,,1218,2,,void
212602,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  if (!env->has_run_bootstrapping_code()) {
    // No code because this is an assertion.
    return env->ThrowError(
        ""Should not query options before bootstrapping is done"");
  }
  Isolate* isolate = args.GetIsolate();
  Local<Context> context = env->context();
  Local<Object> ret = Object::New(isolate);

  if (ret->Set(context,
           FIXED_ONE_BYTE_STRING(env->isolate(), ""shouldNotRegisterESMLoader""),
           Boolean::New(isolate, env->should_not_register_esm_loader()))
      .IsNothing()) return;

  if (ret->Set(context,
           FIXED_ONE_BYTE_STRING(env->isolate(), ""noGlobalSearchPaths""),
           Boolean::New(isolate, env->no_global_search_paths()))
      .IsNothing()) return;

  if (ret->Set(context,
               FIXED_ONE_BYTE_STRING(env->isolate(), ""noBrowserGlobals""),
               Boolean::New(isolate, env->no_browser_globals()))
          .IsNothing())
    return;

  args.GetReturnValue().Set(ret...",66,,1225,2,,void
212617,BLOCK,-1,,"{
    // No code because this is an assertion.
    return env->ThrowError(
        ""Should not query options before bootstrapping is done"");
  }",43,,1227,2,,void
212676,BLOCK,-1,,<empty>,21,,1239,2,,void
212702,BLOCK,-1,,<empty>,21,,1244,2,,void
212728,BLOCK,-1,,<empty>,5,,1250,2,,void
212745,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();
  SetMethodNoSideEffect(context, target, ""getCLIOptions"", GetCLIOptions);
  SetMethodNoSideEffect(
      context, target, ""getEmbedderOptions"", GetEmbedderOptions);

  Local<Object> env_settings = Object::New(isolate);
  NODE_DEFINE_CONSTANT(env_settings, kAllowedInEnvvar);
  NODE_DEFINE_CONSTANT(env_settings, kDisallowedInEnvvar);
  target
      ->Set(
          context, FIXED_ONE_BYTE_STRING(isolate, ""envSettings""), env_settings)
      .Check();

  Local<Object> types = Object::New(isolate);
  NODE_DEFINE_CONSTANT(types, kNoOp);
  NODE_DEFINE_CONSTANT(types, kV8Option);
  NODE_DEFINE_CONSTANT(types, kBoolean);
  NODE_DEFINE_CONSTANT(types, kInteger);
  NODE_DEFINE_CONSTANT(types, kUInteger);
  NODE_DEFINE_CONSTANT(types, kString);
  NODE_DEFINE_CONSTANT(types, kHostPort);
  NODE_DEFINE_CONSTANT(types, kStringList);
  target->Set(context, FIXED_ONE_BYTE_STRING(isolate, ""types""), types)
   ...",29,,1258,5,,void
212851,BLOCK,-1,,"{
  registry->Register(GetCLIOptions);
  registry->Register(GetEmbedderOptions);
}",70,,1286,2,,void
212866,BLOCK,-1,,"{
  HandleEnvOptions(env_options, [](const char* name) {
    std::string text;
    return credentials::SafeGetenv(name, &text) ? text : """";
  });
}",72,,1292,2,,void
212875,BLOCK,-1,,"{
  env_options->pending_deprecation =
      opt_getter(""NODE_PENDING_DEPRECATION"") == ""1"";

  env_options->preserve_symlinks = opt_getter(""NODE_PRESERVE_SYMLINKS"") == ""1"";

  env_options->preserve_symlinks_main =
      opt_getter(""NODE_PRESERVE_SYMLINKS_MAIN"") == ""1"";

  if (env_options->redirect_warnings.empty())
    env_options->redirect_warnings = opt_getter(""NODE_REDIRECT_WARNINGS"");
}",75,,1300,3,,void
212907,BLOCK,-1,,<empty>,5,,1310,2,,void
212919,BLOCK,-1,,"{
  std::vector<std::string> env_argv;

  bool is_in_string = false;
  bool will_start_new_arg = true;
  for (std::string::size_type index = 0; index < node_options.size(); ++index) {
    char c = node_options.at(index);

    // Backslashes escape the following character
    if (c == '\\' && is_in_string) {
      if (index + 1 == node_options.size()) {
        errors->push_back(""invalid value for NODE_OPTIONS ""
                          ""(invalid escape)\n"");
        return env_argv;
      } else {
        c = node_options.at(++index);
      }
    } else if (c == ' ' && !is_in_string) {
      will_start_new_arg = true;
      continue;
    } else if (c == '""') {
      is_in_string = !is_in_string;
      continue;
    }

    if (will_start_new_arg) {
      env_argv.emplace_back(std::string(1, c));
      will_start_new_arg = false;
    } else {
      env_argv.back() += c;
    }
  }

  if (is_in_string) {
    errors->push_back(""invalid value for NODE_OPTIONS ""
                      ""(un...",72,,1314,3,,void
212938,BLOCK,-1,,<empty>,3,,1319,1,,void
212951,BLOCK,4,,"{
    char c = node_options.at(index);

    // Backslashes escape the following character
    if (c == '\\' && is_in_string) {
      if (index + 1 == node_options.size()) {
        errors->push_back(""invalid value for NODE_OPTIONS ""
                          ""(invalid escape)\n"");
        return env_argv;
      } else {
        c = node_options.at(++index);
      }
    } else if (c == ' ' && !is_in_string) {
      will_start_new_arg = true;
      continue;
    } else if (c == '""') {
      is_in_string = !is_in_string;
      continue;
    }

    if (will_start_new_arg) {
      env_argv.emplace_back(std::string(1, c));
      will_start_new_arg = false;
    } else {
      env_argv.back() += c;
    }
  }",80,,1319,4,,void
212966,BLOCK,-1,,"{
      if (index + 1 == node_options.size()) {
        errors->push_back(""invalid value for NODE_OPTIONS ""
                          ""(invalid escape)\n"");
        return env_argv;
      } else {
        c = node_options.at(++index);
      }
    }",36,,1323,2,,void
212976,BLOCK,-1,,"{
        errors->push_back(""invalid value for NODE_OPTIONS ""
                          ""(invalid escape)\n"");
        return env_argv;
      }",45,,1324,2,,void
212985,BLOCK,-1,,"{
        c = node_options.at(++index);
      }",14,,1328,1,,void
212995,BLOCK,-1,,<empty>,12,,1331,1,,void
213003,BLOCK,-1,,"{
      will_start_new_arg = true;
      continue;
    }",43,,1331,2,,void
213009,BLOCK,-1,,<empty>,12,,1334,1,,void
213014,BLOCK,-1,,"{
      is_in_string = !is_in_string;
      continue;
    }",26,,1334,2,,void
213022,BLOCK,-1,,"{
      env_argv.emplace_back(std::string(1, c));
      will_start_new_arg = false;
    }",29,,1339,2,,void
213037,BLOCK,-1,,"{
      env_argv.back() += c;
    }",12,,1342,1,,void
213046,BLOCK,-1,,"{
    errors->push_back(""invalid value for NODE_OPTIONS ""
                      ""(unterminated string)\n"");
  }",21,,1347,2,,void
213077,BLOCK,-1,,<empty>,1,,1,1,,ANY
213080,BLOCK,-1,,{ uv_os_free_passwd(&pwd); },41,,299,1,,void
213107,BLOCK,-1,,<empty>,1,,1,1,,ANY
213112,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  char buf[UV_MAXHOSTNAMESIZE];
  size_t size = sizeof(buf);
  int r = uv_os_gethostname(buf, &size);

  if (r != 0) {
    CHECK_GE(args.Length(), 1);
    env->CollectUVExceptionInfo(args[args.Length() - 1], r,
                                ""uv_os_gethostname"");
    return args.GetReturnValue().SetUndefined();
  }

  args.GetReturnValue().Set(
      String::NewFromUtf8(env->isolate(), buf).ToLocalChecked());
}",66,,60,2,,void
213138,BLOCK,-1,,"{
    CHECK_GE(args.Length(), 1);
    env->CollectUVExceptionInfo(args[args.Length() - 1], r,
                                ""uv_os_gethostname"");
    return args.GetReturnValue().SetUndefined();
  }",15,,66,2,,void
213190,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  uv_utsname_t info;
  int err = uv_os_uname(&info);

  if (err != 0) {
    CHECK_GE(args.Length(), 1);
    env->CollectUVExceptionInfo(args[args.Length() - 1], err, ""uv_os_uname"");
    return args.GetReturnValue().SetUndefined();
  }

  // [sysname, version, release, machine]
  Local<Value> osInformation[] = {
      String::NewFromUtf8(env->isolate(), info.sysname).ToLocalChecked(),
      String::NewFromUtf8(env->isolate(), info.version).ToLocalChecked(),
      String::NewFromUtf8(env->isolate(), info.release).ToLocalChecked(),
      String::NewFromUtf8(env->isolate(), info.machine).ToLocalChecked()};

  args.GetReturnValue().Set(Array::New(env->isolate(),
                                       osInformation,
                                       arraysize(osInformation)));
}",71,,77,2,,void
213210,BLOCK,-1,,"{
    CHECK_GE(args.Length(), 1);
    env->CollectUVExceptionInfo(args[args.Length() - 1], err, ""uv_os_uname"");
    return args.GetReturnValue().SetUndefined();
  }",17,,82,2,,void
213321,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  uv_cpu_info_t* cpu_infos;
  int count;

  int err = uv_cpu_info(&cpu_infos, &count);
  if (err)
    return;

  // It's faster to create an array packed with all the data and
  // assemble them into objects in JS than to call Object::Set() repeatedly
  // The array is in the format
  // [model, speed, (5 entries of cpu_times), model2, speed2, ...]
  std::vector<Local<Value>> result;
  result.reserve(count * 7);
  for (int i = 0; i < count; i++) {
    uv_cpu_info_t* ci = cpu_infos + i;
    result.emplace_back(OneByteString(isolate, ci->model));
    result.emplace_back(Number::New(isolate, ci->speed));
    result.emplace_back(
        Number::New(isolate, static_cast<double>(ci->cpu_times.user)));
    result.emplace_back(
        Number::New(isolate, static_cast<double>(ci->cpu_times.nice)));
    result.emplace_back(
        Number::New(isolate, static_cast<double>(ci->cpu_times.sys)));
    re...",65,,100,2,,void
213349,BLOCK,-1,,<empty>,5,,109,2,,void
213368,BLOCK,-1,,<empty>,3,,117,1,,void
213378,BLOCK,4,,"{
    uv_cpu_info_t* ci = cpu_infos + i;
    result.emplace_back(OneByteString(isolate, ci->model));
    result.emplace_back(Number::New(isolate, ci->speed));
    result.emplace_back(
        Number::New(isolate, static_cast<double>(ci->cpu_times.user)));
    result.emplace_back(
        Number::New(isolate, static_cast<double>(ci->cpu_times.nice)));
    result.emplace_back(
        Number::New(isolate, static_cast<double>(ci->cpu_times.sys)));
    result.emplace_back(
        Number::New(isolate, static_cast<double>(ci->cpu_times.idle)));
    result.emplace_back(
        Number::New(isolate, static_cast<double>(ci->cpu_times.irq)));
  }",35,,117,4,,void
213513,BLOCK,-1,,"{
  double amount = static_cast<double>(uv_get_free_memory());
  args.GetReturnValue().Set(amount);
}",68,,138,2,,void
213532,BLOCK,-1,,"{
  double amount = static_cast<double>(uv_get_total_memory());
  args.GetReturnValue().Set(amount);
}",69,,144,2,,void
213551,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  double uptime;
  int err = uv_uptime(&uptime);
  if (err != 0) {
    env->CollectUVExceptionInfo(args[args.Length() - 1], err, ""uv_uptime"");
    return args.GetReturnValue().SetUndefined();
  }

  args.GetReturnValue().Set(uptime);
}",64,,150,2,,void
213571,BLOCK,-1,,"{
    env->CollectUVExceptionInfo(args[args.Length() - 1], err, ""uv_uptime"");
    return args.GetReturnValue().SetUndefined();
  }",17,,154,2,,void
213606,BLOCK,-1,,"{
  CHECK(args[0]->IsFloat64Array());
  Local<Float64Array> array = args[0].As<Float64Array>();
  CHECK_EQ(array->Length(), 3);
  Local<ArrayBuffer> ab = array->Buffer();
  double* loadavg = static_cast<double*>(ab->Data());
  uv_loadavg(loadavg);
}",65,,163,2,,void
213657,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  uv_interface_address_t* interfaces;
  int count, i;
  char ip[INET6_ADDRSTRLEN];
  char netmask[INET6_ADDRSTRLEN];
  std::array<char, 18> mac;
  Local<String> name, family;

  int err = uv_interface_addresses(&interfaces, &count);

  if (err == UV_ENOSYS)
    return args.GetReturnValue().SetUndefined();

  if (err) {
    CHECK_GE(args.Length(), 1);
    env->CollectUVExceptionInfo(args[args.Length() - 1], errno,
                                ""uv_interface_addresses"");
    return args.GetReturnValue().SetUndefined();
  }

  Local<Value> no_scope_id = Integer::New(isolate, -1);
  std::vector<Local<Value>> result;
  result.reserve(count * 7);
  for (i = 0; i < count; i++) {
    const char* const raw_name = interfaces[i].name;

    // Use UTF-8 on both Windows and Unixes (While it may be true that UNIX
    // systems are somewhat encoding-agnostic here, its more than reasonable
    // to assum...",76,,173,2,,void
213693,BLOCK,-1,,<empty>,5,,186,2,,void
213704,BLOCK,-1,,"{
    CHECK_GE(args.Length(), 1);
    env->CollectUVExceptionInfo(args[args.Length() - 1], errno,
                                ""uv_interface_addresses"");
    return args.GetReturnValue().SetUndefined();
  }",12,,188,2,,void
213763,BLOCK,-1,,<empty>,3,,198,1,,void
213772,BLOCK,4,,"{
    const char* const raw_name = interfaces[i].name;

    // Use UTF-8 on both Windows and Unixes (While it may be true that UNIX
    // systems are somewhat encoding-agnostic here, its more than reasonable
    // to assume UTF8 as the default as well. Its what people will expect if
    // they name the interface from any input that uses UTF-8, which should be
    // the most frequent case by far these days.)
    name = String::NewFromUtf8(isolate, raw_name).ToLocalChecked();

    snprintf(mac.data(),
             mac.size(),
             ""%02x:%02x:%02x:%02x:%02x:%02x"",
             static_cast<unsigned char>(interfaces[i].phys_addr[0]),
             static_cast<unsigned char>(interfaces[i].phys_addr[1]),
             static_cast<unsigned char>(interfaces[i].phys_addr[2]),
             static_cast<unsigned char>(interfaces[i].phys_addr[3]),
             static_cast<unsigned char>(interfaces[i].phys_addr[4]),
             static_cast<unsigned char>(interfaces[i].phys_addr[5]));
...",31,,198,4,,void
213868,BLOCK,-1,,"{
      uv_ip4_name(&interfaces[i].address.address4, ip, sizeof(ip));
      uv_ip4_name(&interfaces[i].netmask.netmask4, netmask, sizeof(netmask));
      family = env->ipv4_string();
    }",63,,218,2,,void
213900,BLOCK,-1,,<empty>,12,,222,1,,void
213913,BLOCK,-1,,"{
      uv_ip6_name(&interfaces[i].address.address6, ip, sizeof(ip));
      uv_ip6_name(&interfaces[i].netmask.netmask6, netmask, sizeof(netmask));
      family = env->ipv6_string();
    }",71,,222,2,,void
213945,BLOCK,-1,,"{
      strncpy(ip, ""<unknown sa family>"", INET6_ADDRSTRLEN);
      family = env->unknown_string();
    }",12,,226,1,,void
214016,BLOCK,-1,,"{
      uint32_t scopeid = interfaces[i].address.address6.sin6_scope_id;
      result.emplace_back(Integer::NewFromUnsigned(isolate, scopeid));
    }",64,,238,2,,void
214040,BLOCK,-1,,"{
      result.emplace_back(no_scope_id);
    }",12,,241,1,,void
214073,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  char buf[PATH_MAX];

  size_t len = sizeof(buf);
  const int err = uv_os_homedir(buf, &len);

  if (err) {
    CHECK_GE(args.Length(), 1);
    env->CollectUVExceptionInfo(args[args.Length() - 1], err, ""uv_os_homedir"");
    return args.GetReturnValue().SetUndefined();
  }

  Local<String> home = String::NewFromUtf8(env->isolate(),
                                           buf,
                                           NewStringType::kNormal,
                                           len).ToLocalChecked();
  args.GetReturnValue().Set(home);
}",71,,251,2,,void
214097,BLOCK,-1,,"{
    CHECK_GE(args.Length(), 1);
    env->CollectUVExceptionInfo(args[args.Length() - 1], err, ""uv_os_homedir"");
    return args.GetReturnValue().SetUndefined();
  }",12,,258,2,,void
214160,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  uv_passwd_t pwd;
  enum encoding encoding;

  if (args[0]->IsObject()) {
    Local<Object> options = args[0].As<Object>();
    MaybeLocal<Value> maybe_encoding = options->Get(env->context(),
                                                    env->encoding_string());
    Local<Value> encoding_opt;
    if (!maybe_encoding.ToLocal(&encoding_opt))
        return;

    encoding = ParseEncoding(env->isolate(), encoding_opt, UTF8);
  } else {
    encoding = UTF8;
  }

  const int err = uv_os_get_passwd(&pwd);

  if (err) {
    CHECK_GE(args.Length(), 2);
    env->CollectUVExceptionInfo(args[args.Length() - 1], err,
                                ""uv_os_get_passwd"");
    return args.GetReturnValue().SetUndefined();
  }

  auto free_passwd = OnScopeLeave([&]() { uv_os_free_passwd(&pwd); });

  Local<Value> error;

  Local<Value> uid = Number::New(env->isolate(), pwd.uid);
  Local<Value> gid = Number::New(env->isolate(), pwd.gid);
  Ma...",66,,272,2,,void
214177,BLOCK,-1,,"{
    Local<Object> options = args[0].As<Object>();
    MaybeLocal<Value> maybe_encoding = options->Get(env->context(),
                                                    env->encoding_string());
    Local<Value> encoding_opt;
    if (!maybe_encoding.ToLocal(&encoding_opt))
        return;

    encoding = ParseEncoding(env->isolate(), encoding_opt, UTF8);
  }",28,,277,2,,void
214221,BLOCK,-1,,<empty>,9,,283,2,,void
214233,BLOCK,-1,,"{
    encoding = UTF8;
  }",10,,286,1,,void
214245,BLOCK,-1,,"{
    CHECK_GE(args.Length(), 2);
    env->CollectUVExceptionInfo(args[args.Length() - 1], err,
                                ""uv_os_get_passwd"");
    return args.GetReturnValue().SetUndefined();
  }",12,,292,2,,void
214369,BLOCK,-1,,<empty>,5,,316,2,,void
214378,BLOCK,-1,,<empty>,5,,318,1,,void
214410,BLOCK,-1,,"{
    CHECK(!error.IsEmpty());
    env->isolate()->ThrowException(error);
    return;
  }",67,,320,2,,void
214541,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK_EQ(args.Length(), 3);
  CHECK(args[0]->IsInt32());
  CHECK(args[1]->IsInt32());

  const int pid = args[0].As<Int32>()->Value();
  const int priority = args[1].As<Int32>()->Value();
  const int err = uv_os_setpriority(pid, priority);

  if (err) {
    CHECK(args[2]->IsObject());
    env->CollectUVExceptionInfo(args[2], err, ""uv_os_setpriority"");
  }

  args.GetReturnValue().Set(err);
}",66,,344,2,,void
214602,BLOCK,-1,,"{
    CHECK(args[2]->IsObject());
    env->CollectUVExceptionInfo(args[2], err, ""uv_os_setpriority"");
  }",12,,355,2,,void
214631,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK_EQ(args.Length(), 2);
  CHECK(args[0]->IsInt32());

  const int pid = args[0].As<Int32>()->Value();
  int priority;
  const int err = uv_os_getpriority(pid, &priority);

  if (err) {
    CHECK(args[1]->IsObject());
    env->CollectUVExceptionInfo(args[1], err, ""uv_os_getpriority"");
    return;
  }

  args.GetReturnValue().Set(priority);
}",66,,364,2,,void
214675,BLOCK,-1,,"{
    CHECK(args[1]->IsObject());
    env->CollectUVExceptionInfo(args[1], err, ""uv_os_getpriority"");
    return;
  }",12,,374,2,,void
214705,BLOCK,-1,,"{
  unsigned int parallelism = uv_available_parallelism();
  args.GetReturnValue().Set(parallelism);
}",78,,383,2,,void
214725,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  SetMethod(context, target, ""getHostname"", GetHostname);
  SetMethod(context, target, ""getLoadAvg"", GetLoadAvg);
  SetMethod(context, target, ""getUptime"", GetUptime);
  SetMethod(context, target, ""getTotalMem"", GetTotalMemory);
  SetMethod(context, target, ""getFreeMem"", GetFreeMemory);
  SetMethod(context, target, ""getCPUs"", GetCPUInfo);
  SetMethod(context, target, ""getInterfaceAddresses"", GetInterfaceAddresses);
  SetMethod(context, target, ""getHomeDirectory"", GetHomeDirectory);
  SetMethod(context, target, ""getUserInfo"", GetUserInfo);
  SetMethod(context, target, ""setPriority"", SetPriority);
  SetMethod(context, target, ""getPriority"", GetPriority);
  SetMethod(
      context, target, ""getAvailableParallelism"", GetAvailableParallelism);
  SetMethod(context, target, ""getOSInformation"", GetOSInformation);
  target
      ->Set(context,
            FIXED_ONE_BYTE_STRING(env->isolate(), ""isBigEndian""),
            Boolean::New(e...",29,,391,5,,void
214826,BLOCK,-1,,"{
  registry->Register(GetHostname);
  registry->Register(GetLoadAvg);
  registry->Register(GetUptime);
  registry->Register(GetTotalMemory);
  registry->Register(GetFreeMemory);
  registry->Register(GetCPUInfo);
  registry->Register(GetInterfaceAddresses);
  registry->Register(GetHomeDirectory);
  registry->Register(GetUserInfo);
  registry->Register(SetPriority);
  registry->Register(GetPriority);
  registry->Register(GetAvailableParallelism);
  registry->Register(GetOSInformation);
}",70,,414,2,,void
214898,BLOCK,-1,,"{
    entry->Notify(env);
  }",66,,191,2,,void
214911,BLOCK,-1,,"{
        uint64_t delta = histogram.RecordDelta();
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                        ""delay"", delta);
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                      ""min"", histogram.Min());
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                      ""max"", histogram.Max());
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                      ""mean"", histogram.Mean());
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                      ""stddev"", histogram.Stddev());
      }",73,,262,2,,void
214988,BLOCK,-1,,<empty>,1,,1,1,,ANY
215003,BLOCK,-1,,"{
  if (info == nullptr) {
    for (size_t i = 0; i < milestones.Length(); i++) milestones[i] = -1.;
  }
}",51,,59,3,,void
215008,BLOCK,-1,,"{
    for (size_t i = 0; i < milestones.Length(); i++) milestones[i] = -1.;
  }",24,,60,2,,void
215010,BLOCK,-1,,<empty>,5,,61,1,,void
215034,BLOCK,-1,,"{
  SerializeInfo info{root.Serialize(context, creator),
                     milestones.Serialize(context, creator),
                     observers.Serialize(context, creator)};
  return info;
}",67,,66,3,,void
215063,BLOCK,-1,,"{
  root.Deserialize(context);
  // This is just done to set up the pointers, we will actually reset
  // all the milestones after deserialization.
  milestones.Deserialize(context);
  observers.Deserialize(context);
}",68,,73,2,,void
215084,BLOCK,-1,,"{
  o << ""{\n""
    << ""  "" << i.root << "",  // root\n""
    << ""  "" << i.milestones << "",  // milestones\n""
    << ""  "" << i.observers << "",  // observers\n""
    << ""}"";
  return o;
}",68,,82,3,,void
215121,BLOCK,-1,,"{
  this->milestones[milestone] = static_cast<double>(ts);
  TRACE_EVENT_INSTANT_WITH_TIMESTAMP0(
      TRACING_CATEGORY_NODE1(bootstrap),
      GetPerformanceMilestoneName(milestone),
      TRACE_EVENT_SCOPE_THREAD, ts / 1000);
}",74,,91,3,,void
215144,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(args);
  // TODO(legendecas): Remove this check once the sub-realms are supported.
  CHECK_EQ(realm->kind(), Realm::Kind::kPrincipal);
  Environment* env = realm->env();
  PerformanceMilestone milestone =
      static_cast<PerformanceMilestone>(args[0].As<Int32>()->Value());
  if (milestone != NODE_PERFORMANCE_MILESTONE_INVALID)
    env->performance_state()->Mark(milestone);
}",61,,100,2,,void
215188,BLOCK,-1,,<empty>,5,,108,2,,void
215201,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(args);
  // TODO(legendecas): Remove this check once the sub-realms are supported.
  CHECK_EQ(realm->kind(), Realm::Kind::kPrincipal);
  CHECK(args[0]->IsFunction());
  realm->set_performance_entry_callback(args[0].As<Function>());
}",73,,111,2,,void
215244,BLOCK,-1,,"{
  Environment* env = static_cast<Environment*>(data);
  // Prevent gc callback from reentering with different type
  // See https://github.com/nodejs/node/issues/44046
  if (env->performance_state()->current_gc_type != 0) {
    return;
  }
  env->performance_state()->performance_last_gc_start_mark = PERFORMANCE_NOW();
  env->performance_state()->current_gc_type = type;
}",17,,124,5,,void
215260,BLOCK,-1,,"{
    return;
  }",55,,128,2,,void
215283,BLOCK,-1,,"{
  Local<Object> obj = Object::New(env->isolate());

  if (!obj->Set(
          env->context(),
          env->kind_string(),
          Integer::NewFromUnsigned(
              env->isolate(),
              entry.details.kind)).IsJust()) {
    return MaybeLocal<Object>();
  }

  if (!obj->Set(
          env->context(),
          env->flags_string(),
          Integer::NewFromUnsigned(
              env->isolate(),
              entry.details.flags)).IsJust()) {
    return MaybeLocal<Object>();
  }

  return obj;
}",38,,137,3,,void
215328,BLOCK,-1,,"{
    return MaybeLocal<Object>();
  }",46,,145,2,,void
215361,BLOCK,-1,,"{
    return MaybeLocal<Object>();
  }",47,,154,2,,void
215373,BLOCK,-1,,"{
  Environment* env = static_cast<Environment*>(data);
  PerformanceState* state = env->performance_state();
  if (type != state->current_gc_type) {
    return;
  }
  env->performance_state()->current_gc_type = 0;
  // If no one is listening to gc performance entries, do not create them.
  if (LIKELY(!state->observers[NODE_PERFORMANCE_ENTRY_TYPE_GC]))
    return;

  double start_time =
      (state->performance_last_gc_start_mark - env->time_origin()) /
      NANOS_PER_MILLIS;
  double duration = (PERFORMANCE_NOW() / NANOS_PER_MILLIS) -
                    (state->performance_last_gc_start_mark / NANOS_PER_MILLIS);

  std::unique_ptr<GCPerformanceEntry> entry =
      std::make_unique<GCPerformanceEntry>(
          ""gc"",
          start_time,
          duration,
          GCPerformanceEntry::Details(static_cast<PerformanceGCKind>(type),
                                      static_cast<PerformanceGCFlags>(flags)));

  env->SetImmediate([entry = std::move(entry)](Environment* env) {
...",17,,166,5,,void
215392,BLOCK,-1,,"{
    return;
  }",39,,169,2,,void
215410,BLOCK,-1,,<empty>,5,,175,2,,void
215425,BLOCK,1,,<empty>,,,,1,,void
215434,BLOCK,1,,<empty>,,,,1,,void
215441,BLOCK,1,,<empty>,,,,1,,void
215484,BLOCK,-1,,"{
  Environment* env = static_cast<Environment*>(data);
  // Reset current_gc_type to 0
  env->performance_state()->current_gc_type = 0;
  env->isolate()->RemoveGCPrologueCallback(MarkGarbageCollectionStart, data);
  env->isolate()->RemoveGCEpilogueCallback(MarkGarbageCollectionEnd, data);
}",47,,196,2,,void
215521,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  // Reset current_gc_type to 0
  env->performance_state()->current_gc_type = 0;
  env->isolate()->AddGCPrologueCallback(MarkGarbageCollectionStart,
                                        static_cast<void*>(env));
  env->isolate()->AddGCEpilogueCallback(MarkGarbageCollectionEnd,
                                        static_cast<void*>(env));
  env->AddCleanupHook(GarbageCollectionCleanupHook, env);
}",46,,205,2,,void
215570,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  env->RemoveCleanupHook(GarbageCollectionCleanupHook, env);
  GarbageCollectionCleanupHook(env);
}",44,,217,2,,void
215591,BLOCK,-1,,"{
  Local<Value> val = fn->GetDebugName();
  if (val.IsEmpty() || val->IsUndefined()) {
    Local<Value> boundFunction = fn->GetBoundFunction();
    if (!boundFunction.IsEmpty() && !boundFunction->IsUndefined()) {
      val = GetName(boundFunction.As<Function>());
    }
  }
  return val;
}",49,,225,2,,void
215612,BLOCK,-1,,"{
    Local<Value> boundFunction = fn->GetBoundFunction();
    if (!boundFunction.IsEmpty() && !boundFunction->IsUndefined()) {
      val = GetName(boundFunction.As<Function>());
    }
  }",44,,227,2,,void
215635,BLOCK,-1,,"{
      val = GetName(boundFunction.As<Function>());
    }",68,,229,2,,void
215649,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Utf8Value type(env->isolate(), args[0]);
  Local<Value> entry = args[1];
  PerformanceEntryType entry_type = ToPerformanceEntryTypeEnum(*type);
  AliasedUint32Array& observers = env->performance_state()->observers;
  if (entry_type != NODE_PERFORMANCE_ENTRY_TYPE_INVALID &&
      observers[entry_type]) {
    USE(env->performance_entry_callback()->
      Call(env->context(), Undefined(env->isolate()), 1, &entry));
  }
}",54,,237,2,,void
215699,BLOCK,-1,,"{
    USE(env->performance_entry_callback()->
      Call(env->context(), Undefined(env->isolate()), 1, &entry));
  }",30,,244,2,,void
215724,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  uint64_t idle_time = uv_metrics_idle_time(env->event_loop());
  args.GetReturnValue().Set(1.0 * idle_time / 1e6);
}",60,,251,2,,void
215757,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  int64_t interval = args[0].As<Integer>()->Value();
  CHECK_GT(interval, 0);
  BaseObjectPtr<IntervalHistogram> histogram =
      IntervalHistogram::Create(env, interval, [](Histogram& histogram) {
        uint64_t delta = histogram.RecordDelta();
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                        ""delay"", delta);
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                      ""min"", histogram.Min());
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                      ""max"", histogram.Max());
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                      ""mean"", histogram.Mean());
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                      ""stddev"", histogram.Stddev());
      }, Histogram::Options { 1000 });
  args.GetReturnValue().Set(histogram->object());
}",66,,257,2,,void
215812,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  args.GetReturnValue().Set(
      Number::New(args.GetIsolate(), env->time_origin() / NANOS_PER_MILLIS));
}",61,,278,2,,void
215842,BLOCK,1,,<empty>,,,,1,,void
215848,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  args.GetReturnValue().Set(Number::New(
      args.GetIsolate(), env->time_origin_timestamp() / MICROS_PER_MILLIS));
}",70,,284,2,,void
215878,BLOCK,1,,<empty>,,,,1,,void
215884,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(args);
  CHECK_EQ(realm->kind(), Realm::Kind::kPrincipal);
  realm->env()->performance_state()->Mark(
      performance::NODE_PERFORMANCE_MILESTONE_BOOTSTRAP_COMPLETE);
}",69,,290,2,,void
215921,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();

  HistogramBase::Initialize(isolate_data, target);

  SetMethod(isolate, target, ""markMilestone"", MarkMilestone);
  SetMethod(isolate, target, ""setupObservers"", SetupPerformanceObservers);
  SetMethod(isolate,
            target,
            ""installGarbageCollectionTracking"",
            InstallGarbageCollectionTracking);
  SetMethod(isolate,
            target,
            ""removeGarbageCollectionTracking"",
            RemoveGarbageCollectionTracking);
  SetMethod(isolate, target, ""notify"", Notify);
  SetMethod(isolate, target, ""loopIdleTime"", LoopIdleTime);
  SetMethod(isolate, target, ""getTimeOrigin"", GetTimeOrigin);
  SetMethod(isolate, target, ""getTimeOriginTimestamp"", GetTimeOriginTimeStamp);
  SetMethod(isolate, target, ""createELDHistogram"", CreateELDHistogram);
  SetMethod(isolate, target, ""markBootstrapComplete"", MarkBootstrapComplete);
}",70,,298,3,,void
215992,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();
  PerformanceState* state = env->performance_state();

  target->Set(context,
              FIXED_ONE_BYTE_STRING(isolate, ""observerCounts""),
              state->observers.GetJSArray()).Check();
  target->Set(context,
              FIXED_ONE_BYTE_STRING(isolate, ""milestones""),
              state->milestones.GetJSArray()).Check();

  Local<Object> constants = Object::New(isolate);

  NODE_DEFINE_CONSTANT(constants, NODE_PERFORMANCE_GC_MAJOR);
  NODE_DEFINE_CONSTANT(constants, NODE_PERFORMANCE_GC_MINOR);
  NODE_DEFINE_CONSTANT(constants, NODE_PERFORMANCE_GC_INCREMENTAL);
  NODE_DEFINE_CONSTANT(constants, NODE_PERFORMANCE_GC_WEAKCB);

  NODE_DEFINE_CONSTANT(
    constants, NODE_PERFORMANCE_GC_FLAGS_NO);
  NODE_DEFINE_CONSTANT(
    constants, NODE_PERFORMANCE_GC_FLAGS_CONSTRUCT_RETAINED);
  NODE_DEFINE_CONSTANT(
    constants, NODE_PERFORMANCE_GC_FLAGS_FORCED);
  NODE_DEFINE_CONSTANT(
    con...",45,,324,5,,void
216065,BLOCK,1,,<empty>,,,,7,,void
216067,BLOCK,-1,,"NODE_DEFINE_CONSTANT(constants, NODE_PERFORMANCE_GC_MAJOR)",3,,338,1,,void
216164,BLOCK,1,,<empty>,,,,7,,void
216166,BLOCK,-1,,"NODE_DEFINE_CONSTANT(constants, NODE_PERFORMANCE_GC_MINOR)",3,,339,1,,void
216263,BLOCK,1,,<empty>,,,,7,,void
216265,BLOCK,-1,,"NODE_DEFINE_CONSTANT(constants, NODE_PERFORMANCE_GC_INCREMENTAL)",3,,340,1,,void
216362,BLOCK,1,,<empty>,,,,7,,void
216364,BLOCK,-1,,"NODE_DEFINE_CONSTANT(constants, NODE_PERFORMANCE_GC_WEAKCB)",3,,341,1,,void
216461,BLOCK,1,,<empty>,,,,7,,void
216463,BLOCK,-1,,"NODE_DEFINE_CONSTANT(
    constants, NODE_PERFORMANCE_GC_FLAGS_NO)",3,,343,1,,void
216560,BLOCK,1,,<empty>,,,,7,,void
216562,BLOCK,-1,,"NODE_DEFINE_CONSTANT(
    constants, NODE_PERFORMANCE_GC_FLAGS_CONSTRUCT_RETAINED)",3,,345,1,,void
216659,BLOCK,1,,<empty>,,,,7,,void
216661,BLOCK,-1,,"NODE_DEFINE_CONSTANT(
    constants, NODE_PERFORMANCE_GC_FLAGS_FORCED)",3,,347,1,,void
216758,BLOCK,1,,<empty>,,,,7,,void
216760,BLOCK,-1,,"NODE_DEFINE_CONSTANT(
    constants, NODE_PERFORMANCE_GC_FLAGS_SYNCHRONOUS_PHANTOM_PROCESSING)",3,,349,1,,void
216857,BLOCK,1,,<empty>,,,,7,,void
216859,BLOCK,-1,,"NODE_DEFINE_CONSTANT(
    constants, NODE_PERFORMANCE_GC_FLAGS_ALL_AVAILABLE_GARBAGE)",3,,351,1,,void
216956,BLOCK,1,,<empty>,,,,7,,void
216958,BLOCK,-1,,"NODE_DEFINE_CONSTANT(
    constants, NODE_PERFORMANCE_GC_FLAGS_ALL_EXTERNAL_MEMORY)",3,,353,1,,void
217055,BLOCK,1,,<empty>,,,,7,,void
217057,BLOCK,-1,,"NODE_DEFINE_CONSTANT(
    constants, NODE_PERFORMANCE_GC_FLAGS_SCHEDULE_IDLE)",3,,355,1,,void
217179,BLOCK,-1,,"{
  registry->Register(MarkMilestone);
  registry->Register(SetupPerformanceObservers);
  registry->Register(InstallGarbageCollectionTracking);
  registry->Register(RemoveGarbageCollectionTracking);
  registry->Register(Notify);
  registry->Register(LoopIdleTime);
  registry->Register(GetTimeOrigin);
  registry->Register(GetTimeOriginTimeStamp);
  registry->Register(CreateELDHistogram);
  registry->Register(MarkBootstrapComplete);
  HistogramBase::RegisterExternalReferences(registry);
  IntervalHistogram::RegisterExternalReferences(registry);
}",70,,375,2,,void
217263,BLOCK,-1,,<empty>,1,,1,1,,ANY
217284,BLOCK,-1,,<empty>,1,,1,1,,ANY
217288,BLOCK,-1,,"{
      static_cast<DelayedTaskScheduler*>(data)->Run();
    }",40,,63,2,,void
217301,BLOCK,-1,,<empty>,40,,117,2,,void
217308,BLOCK,-1,,"{
      delete reinterpret_cast<uv_timer_t*>(handle);
    }",77,,157,2,,void
217318,BLOCK,-1,,"{
    std::unique_ptr<uv_async_t> flush_tasks {
        reinterpret_cast<uv_async_t*>(handle) };
    PerIsolatePlatformData* platform_data =
        static_cast<PerIsolatePlatformData*>(flush_tasks->data);
    platform_data->DecreaseHandleCount();
    platform_data->self_reference_.reset();
  }",36,,314,2,,void
217354,BLOCK,-1,,"{
          return delayed.get() == task;
      }",76,,437,2,,void
217368,BLOCK,-1,,"{
        std::unique_ptr<DelayedTask> task {
            static_cast<DelayedTask*>(handle->data) };
        task->platform_data->DecreaseHandleCount();
      }",40,,479,2,,void
217393,BLOCK,-1,,"{
      uv_close(reinterpret_cast<uv_handle_t*>(&delayed->timer),
               [](uv_handle_t* handle) {
        std::unique_ptr<DelayedTask> task {
            static_cast<DelayedTask*>(handle->data) };
        task->platform_data->DecreaseHandleCount();
      });
    }",68,,477,2,,void
217406,BLOCK,-1,,"{
    fprintf(stderr, ""\n"");
    DumpBacktrace(stderr);
    fflush(stderr);
  }",15,,561,1,,void
217432,BLOCK,-1,,<empty>,1,,1,1,,ANY
217443,BLOCK,-1,,"{
  std::unique_ptr<PlatformWorkerData>
      worker_data(static_cast<PlatformWorkerData*>(data));

  TaskQueue<Task>* pending_worker_tasks = worker_data->task_queue;
  TRACE_EVENT_METADATA1(""__metadata"", ""thread_name"", ""name"",
                        ""PlatformWorkerThread"");

  // Notify the main thread that the platform worker is ready.
  {
    Mutex::ScopedLock lock(*worker_data->platform_workers_mutex);
    (*worker_data->pending_platform_workers)--;
    worker_data->platform_workers_ready->Signal(lock);
  }

  while (std::unique_ptr<Task> task = pending_worker_tasks->BlockingPop()) {
    task->Run();
    pending_worker_tasks->NotifyOfCompletion();
  }
}",46,,27,2,,void
217464,BLOCK,5,,"{
    Mutex::ScopedLock lock(*worker_data->platform_workers_mutex);
    (*worker_data->pending_platform_workers)--;
    worker_data->platform_workers_ready->Signal(lock);
  }",3,,36,5,,void
217496,BLOCK,-1,,"{
    task->Run();
    pending_worker_tasks->NotifyOfCompletion();
  }",76,,42,2,,void
217509,BLOCK,-1,,"{
  if (thread_pool_size < 1) {
    thread_pool_size = uv_available_parallelism() - 1;
  }
  return std::max(thread_pool_size, 1);
}",58,,48,2,,void
217514,BLOCK,-1,,"{
    thread_pool_size = uv_available_parallelism() - 1;
  }",29,,49,2,,void
217531,BLOCK,-1,,<empty>,36,,60,2,,void
217535,BLOCK,-1,,"{
    auto start_thread = [](void* data) {
      static_cast<DelayedTaskScheduler*>(data)->Run();
    };
    std::unique_ptr<uv_thread_t> t { new uv_thread_t() };
    uv_sem_init(&ready_, 0);
    CHECK_EQ(0, uv_thread_create(t.get(), start_thread, this));
    uv_sem_wait(&ready_);
    uv_sem_destroy(&ready_);
    return t;
  }",40,,62,1,,void
217576,BLOCK,-1,,"{
    tasks_.Push(std::make_unique<ScheduleTask>(this, std::move(task),
                                               delay_in_seconds));
    uv_async_send(&flush_tasks_);
  }",77,,74,3,,void
217602,BLOCK,-1,,"{
    tasks_.Push(std::make_unique<StopTask>(this));
    uv_async_send(&flush_tasks_);
  }",15,,80,1,,void
217620,BLOCK,-1,,"{
    TRACE_EVENT_METADATA1(""__metadata"", ""thread_name"", ""name"",
                          ""WorkerThreadsTaskRunner::DelayedTaskScheduler"");
    loop_.data = this;
    CHECK_EQ(0, uv_loop_init(&loop_));
    flush_tasks_.data = this;
    CHECK_EQ(0, uv_async_init(&loop_, &flush_tasks_, FlushTasks));
    uv_sem_post(&ready_);

    uv_run(&loop_, UV_RUN_DEFAULT);
    CheckedUvLoopClose(&loop_);
  }",14,,86,1,,void
217663,BLOCK,-1,,"{
    DelayedTaskScheduler* scheduler =
        ContainerOf(&DelayedTaskScheduler::loop_, flush_tasks->loop);
    while (std::unique_ptr<Task> task = scheduler->tasks_.Pop())
      task->Run();
  }",51,,99,2,,void
217698,BLOCK,-1,,<empty>,79,,108,2,,void
217702,BLOCK,-1,,"{
      std::vector<uv_timer_t*> timers;
      for (uv_timer_t* timer : scheduler_->timers_)
        timers.push_back(timer);
      for (uv_timer_t* timer : timers)
        scheduler_->TakeTimerTask(timer);
      uv_close(reinterpret_cast<uv_handle_t*>(&scheduler_->flush_tasks_),
               [](uv_handle_t* handle) {});
    }",25,,110,1,,void
217738,BLOCK,-1,,<empty>,45,,131,4,,void
217742,BLOCK,-1,,"{
      uint64_t delay_millis = llround(delay_in_seconds_ * 1000);
      std::unique_ptr<uv_timer_t> timer(new uv_timer_t());
      CHECK_EQ(0, uv_timer_init(&scheduler_->loop_, timer.get()));
      timer->data = task_.release();
      CHECK_EQ(0, uv_timer_start(timer.get(), RunTask, delay_millis, 0));
      scheduler_->timers_.insert(timer.release());
    }",25,,133,1,,void
217805,BLOCK,-1,,"{
    DelayedTaskScheduler* scheduler =
        ContainerOf(&DelayedTaskScheduler::loop_, timer->loop);
    scheduler->pending_worker_tasks_->Push(scheduler->TakeTimerTask(timer));
  }",42,,148,2,,void
217832,BLOCK,-1,,"{
    std::unique_ptr<Task> task(static_cast<Task*>(timer->data));
    uv_timer_stop(timer);
    uv_close(reinterpret_cast<uv_handle_t*>(timer), [](uv_handle_t* handle) {
      delete reinterpret_cast<uv_timer_t*>(handle);
    });
    timers_.erase(timer);
    return task;
  }",58,,154,2,,void
217869,BLOCK,-1,,"{
  Mutex platform_workers_mutex;
  ConditionVariable platform_workers_ready;

  Mutex::ScopedLock lock(platform_workers_mutex);
  int pending_platform_workers = thread_pool_size;

  delayed_task_scheduler_ = std::make_unique<DelayedTaskScheduler>(
      &pending_worker_tasks_);
  threads_.push_back(delayed_task_scheduler_->Start());

  for (int i = 0; i < thread_pool_size; i++) {
    PlatformWorkerData* worker_data = new PlatformWorkerData{
      &pending_worker_tasks_, &platform_workers_mutex,
      &platform_workers_ready, &pending_platform_workers, i
    };
    std::unique_ptr<uv_thread_t> t { new uv_thread_t() };
    if (uv_thread_create(t.get(), PlatformWorkerThread,
                         worker_data) != 0) {
      break;
    }
    threads_.push_back(std::move(t));
  }

  // Wait for platform workers to initialize before continuing with the
  // bootstrap.
  while (pending_platform_workers > 0) {
    platform_workers_ready.Wait(lock);
  }
}",72,,173,2,,void
217898,BLOCK,-1,,<empty>,3,,184,1,,void
217908,BLOCK,4,,"{
    PlatformWorkerData* worker_data = new PlatformWorkerData{
      &pending_worker_tasks_, &platform_workers_mutex,
      &platform_workers_ready, &pending_platform_workers, i
    };
    std::unique_ptr<uv_thread_t> t { new uv_thread_t() };
    if (uv_thread_create(t.get(), PlatformWorkerThread,
                         worker_data) != 0) {
      break;
    }
    threads_.push_back(std::move(t));
  }",46,,184,4,,void
217934,BLOCK,-1,,"{
      break;
    }",45,,191,2,,void
217949,BLOCK,-1,,"{
    platform_workers_ready.Wait(lock);
  }",40,,199,2,,void
217959,BLOCK,-1,,"{
  pending_worker_tasks_.Push(std::move(task));
}",68,,204,2,,void
217974,BLOCK,-1,,"{
  delayed_task_scheduler_->PostDelayedTask(std::move(task), delay_in_seconds);
}",72,,209,3,,void
217988,BLOCK,-1,,"{
  pending_worker_tasks_.BlockingDrain();
}",47,,213,1,,void
217996,BLOCK,-1,,"{
  pending_worker_tasks_.Stop();
  delayed_task_scheduler_->Stop();
  for (size_t i = 0; i < threads_.size(); i++) {
    CHECK_EQ(0, uv_thread_join(threads_[i].get()));
  }
}",42,,217,1,,void
218006,BLOCK,-1,,<empty>,3,,220,1,,void
218019,BLOCK,4,,"{
    CHECK_EQ(0, uv_thread_join(threads_[i].get()));
  }",48,,220,4,,void
218032,BLOCK,-1,,"{
  return threads_.size();
}",60,,225,1,,void
218043,BLOCK,-1,,"{
  flush_tasks_ = new uv_async_t();
  CHECK_EQ(0, uv_async_init(loop, flush_tasks_, FlushTasks));
  flush_tasks_->data = static_cast<void*>(this);
  uv_unref(reinterpret_cast<uv_handle_t*>(flush_tasks_));
}",36,,231,3,,void
218068,BLOCK,-1,,"{
  return shared_from_this();
}",51,,239,1,,void
218075,BLOCK,-1,,"{
  auto platform_data = static_cast<PerIsolatePlatformData*>(handle->data);
  platform_data->FlushForegroundTasksInternal();
}",61,,243,2,,void
218092,BLOCK,-1,,"{
  UNREACHABLE();
}",79,,248,2,,void
218098,BLOCK,-1,,"{
  if (flush_tasks_ == nullptr) {
    // V8 may post tasks during Isolate disposal. In that case, the only
    // sensible path forward is to discard the task.
    return;
  }
  foreground_tasks_.Push(std::move(task));
  uv_async_send(flush_tasks_);
}",67,,252,2,,void
218103,BLOCK,-1,,"{
    // V8 may post tasks during Isolate disposal. In that case, the only
    // sensible path forward is to discard the task.
    return;
  }",32,,253,2,,void
218120,BLOCK,-1,,"{
  if (flush_tasks_ == nullptr) {
    // V8 may post tasks during Isolate disposal. In that case, the only
    // sensible path forward is to discard the task.
    return;
  }
  std::unique_ptr<DelayedTask> delayed(new DelayedTask());
  delayed->task = std::move(task);
  delayed->platform_data = shared_from_this();
  delayed->timeout = delay_in_seconds;
  foreground_delayed_tasks_.Push(std::move(delayed));
  uv_async_send(flush_tasks_);
}",58,,263,3,,void
218125,BLOCK,-1,,"{
    // V8 may post tasks during Isolate disposal. In that case, the only
    // sensible path forward is to discard the task.
    return;
  }",32,,264,2,,void
218169,BLOCK,-1,,"{
  PostTask(std::move(task));
}",78,,277,2,,void
218181,BLOCK,-1,,"{
  PostDelayedTask(std::move(task), delay_in_seconds);
}",30,,283,3,,void
218192,BLOCK,-1,,"{
  CHECK(!flush_tasks_);
}",51,,287,1,,void
218201,BLOCK,-1,,"{
  shutdown_callbacks_.emplace_back(ShutdownCallback { callback, data });
}",62,,292,3,,void
218213,BLOCK,-1,,"{
  if (flush_tasks_ == nullptr)
    return;

  // While there should be no V8 tasks in the queues at this point, it is
  // possible that Node.js-internal tasks from e.g. the inspector are still
  // lying around. We clear these queues and ignore the return value,
  // effectively deleting the tasks instead of running them.
  foreground_delayed_tasks_.PopAll();
  foreground_tasks_.PopAll();
  scheduled_delayed_tasks_.clear();

  // Both destroying the scheduled_delayed_tasks_ lists and closing
  // flush_tasks_ handle add tasks to the event loop. We keep a count of all
  // non-closed handles, and when that reaches zero, we inform any shutdown
  // callbacks that the platform is done as far as this Isolate is concerned.
  self_reference_ = shared_from_this();
  uv_close(reinterpret_cast<uv_handle_t*>(flush_tasks_),
           [](uv_handle_t* handle) {
    std::unique_ptr<uv_async_t> flush_tasks {
        reinterpret_cast<uv_async_t*>(handle) };
    PerIsolatePlatformData* platform_...",41,,296,1,,void
218218,BLOCK,-1,,<empty>,5,,298,2,,void
218246,BLOCK,-1,,"{
  CHECK_GE(uv_handle_count_, 1);
  if (--uv_handle_count_ == 0) {
    for (const auto& callback : shutdown_callbacks_)
      callback.cb(callback.data);
  }
}",52,,325,1,,void
218255,BLOCK,-1,,"{
    for (const auto& callback : shutdown_callbacks_)
      callback.cb(callback.data);
  }",32,,327,2,,void
218272,BLOCK,-1,,"{
  if (tracing_controller != nullptr) {
    tracing_controller_ = tracing_controller;
  } else {
    tracing_controller_ = new v8::TracingController();
  }

  // V8 will default to its built in allocator if none is provided.
  page_allocator_ = page_allocator;

  // TODO(addaleax): It's a bit icky that we use global state here, but we can't
  // really do anything about it unless V8 starts exposing a way to access the
  // current v8::Platform instance.
  SetTracingController(tracing_controller_);
  DCHECK_EQ(GetTracingController(), tracing_controller_);

  thread_pool_size = GetActualThreadPoolSize(thread_pool_size);
  worker_thread_task_runner_ =
      std::make_shared<WorkerThreadsTaskRunner>(thread_pool_size);
}",63,,335,4,,void
218277,BLOCK,-1,,"{
    tracing_controller_ = tracing_controller;
  }",38,,336,2,,void
218282,BLOCK,-1,,"{
    tracing_controller_ = new v8::TracingController();
  }",10,,338,1,,void
218310,BLOCK,-1,,"{
  Shutdown();
}",31,,356,1,,void
218317,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_isolate_mutex_);
  auto delegate = std::make_shared<PerIsolatePlatformData>(isolate, loop);
  IsolatePlatformDelegate* ptr = delegate.get();
  auto insertion = per_isolate_.emplace(
    isolate,
    std::make_pair(ptr, std::move(delegate)));
  CHECK(insertion.second);
}",71,,360,3,,void
218368,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_isolate_mutex_);
  auto insertion = per_isolate_.emplace(
    isolate,
    std::make_pair(delegate, std::shared_ptr<PerIsolatePlatformData>{}));
  CHECK(insertion.second);
}",71,,371,3,,void
218395,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_isolate_mutex_);
  auto existing_it = per_isolate_.find(isolate);
  CHECK_NE(existing_it, per_isolate_.end());
  auto& existing = existing_it->second;
  if (existing.second) {
    existing.second->Shutdown();
  }
  per_isolate_.erase(existing_it);
}",56,,379,2,,void
218423,BLOCK,-1,,"{
    existing.second->Shutdown();
  }",24,,384,2,,void
218441,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_isolate_mutex_);
  auto it = per_isolate_.find(isolate);
  if (it == per_isolate_.end()) {
    cb(data);
    return;
  }
  CHECK(it->second.second);
  it->second.second->AddShutdownCallback(cb, data);
}",78,,391,4,,void
218460,BLOCK,-1,,"{
    cb(data);
    return;
  }",33,,394,2,,void
218483,BLOCK,-1,,"{
  if (has_shut_down_) return;
  has_shut_down_ = true;
  worker_thread_task_runner_->Shutdown();

  {
    Mutex::ScopedLock lock(per_isolate_mutex_);
    per_isolate_.clear();
  }
}",31,,402,1,,void
218486,BLOCK,-1,,<empty>,23,,403,2,,void
218495,BLOCK,4,,"{
    Mutex::ScopedLock lock(per_isolate_mutex_);
    per_isolate_.clear();
  }",3,,407,4,,void
218506,BLOCK,-1,,"{
  return worker_thread_task_runner_->NumberOfWorkerThreads();
}",43,,413,1,,void
218516,BLOCK,-1,,"{
  if (isolate_->IsExecutionTerminating()) return;
  DebugSealHandleScope scope(isolate_);
  Environment* env = Environment::GetCurrent(isolate_);
  if (env != nullptr) {
    v8::HandleScope scope(isolate_);
    InternalCallbackScope cb_scope(env, Object::New(isolate_), { 0, 0 },
                                   InternalCallbackScope::kNoFlags);
    task->Run();
  } else {
    // The task is moved out of InternalCallbackScope if env is not available.
    // This is a required else block, and should not be removed.
    // See comment: https://github.com/nodejs/node/pull/34688#pullrequestreview-463867489
    task->Run();
  }
}",76,,417,2,,void
218522,BLOCK,-1,,<empty>,43,,418,2,,void
218539,BLOCK,-1,,"{
    v8::HandleScope scope(isolate_);
    InternalCallbackScope cb_scope(env, Object::New(isolate_), { 0, 0 },
                                   InternalCallbackScope::kNoFlags);
    task->Run();
  }",23,,421,2,,void
218562,BLOCK,-1,,"{
    // The task is moved out of InternalCallbackScope if env is not available.
    // This is a required else block, and should not be removed.
    // See comment: https://github.com/nodejs/node/pull/34688#pullrequestreview-463867489
    task->Run();
  }",10,,426,1,,void
218570,BLOCK,-1,,"{
  auto it = std::find_if(scheduled_delayed_tasks_.begin(),
                         scheduled_delayed_tasks_.end(),
                         [task](const DelayedTaskPointer& delayed) -> bool {
          return delayed.get() == task;
      });
  CHECK_NE(it, scheduled_delayed_tasks_.end());
  scheduled_delayed_tasks_.erase(it);
}",74,,434,2,,void
218602,BLOCK,-1,,"{
  DelayedTask* delayed = ContainerOf(&DelayedTask::timer, handle);
  delayed->platform_data->RunForegroundTask(std::move(delayed->task));
  delayed->platform_data->DeleteFromScheduledTasks(delayed);
}",68,,444,2,,void
218636,BLOCK,-1,,"{
  std::shared_ptr<PerIsolatePlatformData> per_isolate = ForNodeIsolate(isolate);
  if (!per_isolate) return;

  do {
    // Worker tasks aren't associated with an Isolate.
    worker_thread_task_runner_->BlockingDrain();
  } while (per_isolate->FlushForegroundTasksInternal());
}",49,,450,2,,void
218650,BLOCK,-1,,<empty>,21,,452,2,,void
218653,BLOCK,-1,,"{
    // Worker tasks aren't associated with an Isolate.
    worker_thread_task_runner_->BlockingDrain();
  }",6,,454,1,,void
218665,BLOCK,-1,,"{
  bool did_work = false;

  while (std::unique_ptr<DelayedTask> delayed =
      foreground_delayed_tasks_.Pop()) {
    did_work = true;
    uint64_t delay_millis = llround(delayed->timeout * 1000);

    delayed->timer.data = static_cast<void*>(delayed.get());
    uv_timer_init(loop_, &delayed->timer);
    // Timers may not guarantee queue ordering of events with the same delay if
    // the delay is non-zero. This should not be a problem in practice.
    uv_timer_start(&delayed->timer, RunForegroundTask, delay_millis, 0);
    uv_unref(reinterpret_cast<uv_handle_t*>(&delayed->timer));
    uv_handle_count_++;

    scheduled_delayed_tasks_.emplace_back(delayed.release(),
                                          [](DelayedTask* delayed) {
      uv_close(reinterpret_cast<uv_handle_t*>(&delayed->timer),
               [](uv_handle_t* handle) {
        std::unique_ptr<DelayedTask> task {
            static_cast<DelayedTask*>(handle->data) };
        task->platform_data->DecreaseHandleCo...",61,,460,1,,void
218683,BLOCK,-1,,"{
    did_work = true;
    uint64_t delay_millis = llround(delayed->timeout * 1000);

    delayed->timer.data = static_cast<void*>(delayed.get());
    uv_timer_init(loop_, &delayed->timer);
    // Timers may not guarantee queue ordering of events with the same delay if
    // the delay is non-zero. This should not be a problem in practice.
    uv_timer_start(&delayed->timer, RunForegroundTask, delay_millis, 0);
    uv_unref(reinterpret_cast<uv_handle_t*>(&delayed->timer));
    uv_handle_count_++;

    scheduled_delayed_tasks_.emplace_back(delayed.release(),
                                          [](DelayedTask* delayed) {
      uv_close(reinterpret_cast<uv_handle_t*>(&delayed->timer),
               [](uv_handle_t* handle) {
        std::unique_ptr<DelayedTask> task {
            static_cast<DelayedTask*>(handle->data) };
        task->platform_data->DecreaseHandleCount();
      });
    });
  }",40,,464,2,,void
218762,BLOCK,-1,,"{
    std::unique_ptr<Task> task = std::move(tasks.front());
    tasks.pop();
    did_work = true;
    RunForegroundTask(std::move(task));
  }",26,,490,2,,void
218798,BLOCK,-1,,"{
  worker_thread_task_runner_->PostTask(std::move(task));
}",67,,499,2,,void
218813,BLOCK,-1,,"{
  worker_thread_task_runner_->PostDelayedTask(std::move(task),
                                              delay_in_seconds);
}",71,,504,3,,void
218828,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_isolate_mutex_);
  auto data = per_isolate_[isolate];
  CHECK_NOT_NULL(data.first);
  return data.first;
}",69,,510,2,,void
218850,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_isolate_mutex_);
  auto data = per_isolate_[isolate];
  CHECK_NOT_NULL(data.first);
  return data.second;
}",48,,518,2,,void
218872,BLOCK,-1,,"{
  std::shared_ptr<PerIsolatePlatformData> per_isolate = ForNodeIsolate(isolate);
  if (!per_isolate) return false;
  return per_isolate->FlushForegroundTasksInternal();
}",59,,525,2,,void
218886,BLOCK,-1,,<empty>,21,,527,2,,void
218899,BLOCK,-1,,"{
  return v8::platform::NewDefaultJobHandle(
      this, priority, std::move(job_task), NumberOfWorkerThreads());
}",71,,532,3,,void
218919,BLOCK,-1,,"{
  return ForIsolate(isolate)->IdleTasksEnabled();
}",55,,537,2,,void
218930,BLOCK,-1,,"{
  return ForIsolate(isolate)->GetForegroundTaskRunner();
}",57,,542,2,,void
218940,BLOCK,-1,,"{
  // Convert nanos to seconds.
  return uv_hrtime() / 1e9;
}",52,,546,1,,void
218948,BLOCK,-1,,"{
  return SystemClockTimeMillis();
}",47,,551,1,,void
218954,BLOCK,-1,,"{
  CHECK_NOT_NULL(tracing_controller_);
  return tracing_controller_;
}",61,,555,1,,void
218961,BLOCK,-1,,"{
  return []() {
    fprintf(stderr, ""\n"");
    DumpBacktrace(stderr);
    fflush(stderr);
  };
}",66,,560,1,,void
218967,BLOCK,-1,,"{
  return page_allocator_;
}",53,,568,1,,void
218973,BLOCK,-1,,{ },61,,575,1,,void
218978,BLOCK,-1,,"{
  Mutex::ScopedLock scoped_lock(lock_);
  outstanding_tasks_++;
  task_queue_.push(std::move(task));
  tasks_available_.Signal(scoped_lock);
}",50,,578,2,,void
219001,BLOCK,-1,,"{
  Mutex::ScopedLock scoped_lock(lock_);
  if (task_queue_.empty()) {
    return std::unique_ptr<T>(nullptr);
  }
  std::unique_ptr<T> result = std::move(task_queue_.front());
  task_queue_.pop();
  return result;
}",40,,586,1,,void
219010,BLOCK,-1,,"{
    return std::unique_ptr<T>(nullptr);
  }",28,,588,2,,void
219044,BLOCK,-1,,"{
  Mutex::ScopedLock scoped_lock(lock_);
  while (task_queue_.empty() && !stopped_) {
    tasks_available_.Wait(scoped_lock);
  }
  if (stopped_) {
    return std::unique_ptr<T>(nullptr);
  }
  std::unique_ptr<T> result = std::move(task_queue_.front());
  task_queue_.pop();
  return result;
}",48,,597,1,,void
219056,BLOCK,-1,,"{
    tasks_available_.Wait(scoped_lock);
  }",44,,599,2,,void
219064,BLOCK,-1,,"{
    return std::unique_ptr<T>(nullptr);
  }",17,,602,2,,void
219098,BLOCK,-1,,"{
  Mutex::ScopedLock scoped_lock(lock_);
  if (--outstanding_tasks_ == 0) {
    tasks_drained_.Broadcast(scoped_lock);
  }
}",41,,611,1,,void
219107,BLOCK,-1,,"{
    tasks_drained_.Broadcast(scoped_lock);
  }",34,,613,2,,void
219116,BLOCK,-1,,"{
  Mutex::ScopedLock scoped_lock(lock_);
  while (outstanding_tasks_ > 0) {
    tasks_drained_.Wait(scoped_lock);
  }
}",36,,619,1,,void
219124,BLOCK,-1,,"{
    tasks_drained_.Wait(scoped_lock);
  }",34,,621,2,,void
219133,BLOCK,-1,,"{
  Mutex::ScopedLock scoped_lock(lock_);
  stopped_ = true;
  tasks_available_.Broadcast(scoped_lock);
}",27,,627,1,,void
219148,BLOCK,-1,,"{
  Mutex::ScopedLock scoped_lock(lock_);
  std::queue<std::unique_ptr<T>> result;
  result.swap(task_queue_);
  return result;
}",55,,634,1,,void
219192,BLOCK,-1,,<empty>,1,,1,1,,ANY
219209,BLOCK,-1,,<empty>,1,,1,1,,ANY
219236,BLOCK,-1,,"{
  nodedbg_const_ContextEmbedderIndex__kEnvironment__int =
      ContextEmbedderIndex::kEnvironment;
  nodedbg_const_BaseObject__kInternalFieldCount__int =
      BaseObject::kInternalFieldCount;

  nodedbg_offset_ExternalString__data__uintptr_t = NODE_OFF_EXTSTR_DATA;
  nodedbg_offset_ReqWrap__req_wrap_queue___ListNode_ReqWrapQueue =
      OffsetOf<ListNode<ReqWrapBase>, ReqWrap<uv_req_t>>(
          &ReqWrap<uv_req_t>::req_wrap_queue_);

  #define V(Class, Member, Type, Accessor)                                    \
    NODEDBG_OFFSET(Class, Member, Type) = OffsetOf(&Accessor);
    NODE_OFFSET_POSTMORTEM_METADATA(V)
  #undef V

  return 1;
}",23,,52,1,,void
219250,BLOCK,1,,<empty>,,,,1,,void
219265,BLOCK,1,,<empty>,,,,2,,void
219374,BLOCK,-1,,<empty>,1,,1,1,,ANY
219385,BLOCK,-1,,<empty>,1,,1,1,,ANY
219398,BLOCK,-1,,<empty>,1,,1,1,,ANY
219404,BLOCK,-1,,"{
  Isolate* isolate = env->isolate();

  Local<String> event_string;
  if (!String::NewFromOneByte(isolate, reinterpret_cast<const uint8_t*>(event))
      .ToLocal(&event_string)) return MaybeLocal<Value>();

  Local<Object> process = env->process_object();
  Local<Value> argv[] = {event_string, message};
  return MakeCallback(isolate, process, ""emit"", arraysize(argv), argv, {0, 0});
}",53,,23,4,,void
219432,BLOCK,-1,,<empty>,32,,28,2,,void
219469,BLOCK,-1,,"{
  if (!env->can_call_into_js()) return Just(false);

  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Object> process = env->process_object();
  Local<Value> emit_warning;
  if (!process->Get(env->context(), env->emit_warning_string())
           .ToLocal(&emit_warning)) {
    return Nothing<bool>();
  }

  if (!emit_warning->IsFunction()) return Just(false);

  int argc = 0;
  Local<Value> args[3];  // warning, type, code

  // The caller has to be able to handle a failure anyway, so we might as well
  // do proper error checking for string creation.
  if (!String::NewFromUtf8(env->isolate(), warning).ToLocal(&args[argc++]))
    return Nothing<bool>();

  if (type != nullptr) {
    if (!String::NewFromOneByte(env->isolate(),
                                reinterpret_cast<const uint8_t*>(type))
             .ToLocal(&args[argc++])) {
      return Nothing<bool>();
    }
    if (code != nullptr &&
        !String::NewFromOneByte(...",57,,38,5,,void
219476,BLOCK,-1,,<empty>,33,,39,2,,void
219526,BLOCK,-1,,"{
    return Nothing<bool>();
  }",37,,47,2,,void
219535,BLOCK,-1,,<empty>,36,,51,2,,void
219569,BLOCK,-1,,<empty>,5,,59,2,,void
219576,BLOCK,-1,,"{
    if (!String::NewFromOneByte(env->isolate(),
                                reinterpret_cast<const uint8_t*>(type))
             .ToLocal(&args[argc++])) {
      return Nothing<bool>();
    }
    if (code != nullptr &&
        !String::NewFromOneByte(env->isolate(),
                                reinterpret_cast<const uint8_t*>(code))
             .ToLocal(&args[argc++])) {
      return Nothing<bool>();
    }
  }",24,,61,2,,void
219598,BLOCK,-1,,"{
      return Nothing<bool>();
    }",39,,64,2,,void
219626,BLOCK,-1,,"{
      return Nothing<bool>();
    }",39,,70,2,,void
219647,BLOCK,-1,,"{
    return Nothing<bool>();
  }",23,,79,2,,void
219659,BLOCK,-1,,"{
  if (experimental_warnings.find(warning) != experimental_warnings.end())
    return Nothing<bool>();

  experimental_warnings.insert(warning);
  std::string message(warning);
  message.append("" is an experimental feature and might change at any time"");
  return ProcessEmitWarningGeneric(env, message.c_str(), ""ExperimentalWarning"");
}",64,,89,3,,void
219671,BLOCK,-1,,<empty>,5,,91,2,,void
219701,BLOCK,-1,,"{
  return ProcessEmitWarningGeneric(
      env, warning, ""DeprecationWarning"", deprecation_code);
}",73,,101,4,,void
219760,BLOCK,-1,,<empty>,1,,1,1,,ANY
219766,BLOCK,-1,,"{
  Abort();
}",60,,66,2,,void
219772,BLOCK,-1,,"{
  // This should crash hard all platforms.
  volatile void** d = static_cast<volatile void**>(nullptr);
  *d = nullptr;
}",68,,71,2,,void
219787,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(env->owns_process_state());

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsString());
  Utf8Value path(env->isolate(), args[0]);
  int err = uv_chdir(*path);
  if (err) {
    // Also include the original working directory, since that will usually
    // be helpful information when debugging a `chdir()` failure.
    char buf[PATH_MAX_BYTES];
    size_t cwd_len = sizeof(buf);
    uv_cwd(buf, &cwd_len);
    return env->ThrowUVException(err, ""chdir"", nullptr, buf, *path);
  }
}",60,,77,2,,void
219831,BLOCK,-1,,"{
    // Also include the original working directory, since that will usually
    // be helpful information when debugging a `chdir()` failure.
    char buf[PATH_MAX_BYTES];
    size_t cwd_len = sizeof(buf);
    uv_cwd(buf, &cwd_len);
    return env->ThrowUVException(err, ""chdir"", nullptr, buf, *path);
  }",12,,85,2,,void
219859,BLOCK,-1,,"{
  CHECK(args[index]->IsFloat64Array());
  Local<Float64Array> arr = args[index].As<Float64Array>();
  CHECK_EQ(arr->Length(), array_length);
  return arr->Buffer();
}",26,,98,4,,void
219894,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  uv_rusage_t rusage;

  // Call libuv to get the values we'll return.
  int err = uv_getrusage(&rusage);
  if (err)
    return env->ThrowUVException(err, ""uv_getrusage"");

  // Get the double array pointer from the Float64Array argument.
  Local<ArrayBuffer> ab = get_fields_array_buffer(args, 0, 2);
  double* fields = static_cast<double*>(ab->Data());

  // Set the Float64Array elements to be user / system values in microseconds.
  fields[0] = MICROS_PER_SEC * rusage.ru_utime.tv_sec + rusage.ru_utime.tv_usec;
  fields[1] = MICROS_PER_SEC * rusage.ru_stime.tv_sec + rusage.ru_stime.tv_usec;
}",63,,110,2,,void
219912,BLOCK,-1,,<empty>,5,,117,2,,void
219946,BLOCK,1,,<empty>,,,,1,,void
219965,BLOCK,1,,<empty>,,,,1,,void
219981,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(env->has_run_bootstrapping_code());
  char buf[PATH_MAX_BYTES];
  size_t cwd_len = sizeof(buf);
  int err = uv_cwd(buf, &cwd_len);
  if (err)
    return env->ThrowUVException(err, ""uv_cwd"");

  Local<String> cwd = String::NewFromUtf8(env->isolate(),
                                          buf,
                                          NewStringType::kNormal,
                                          cwd_len).ToLocalChecked();
  args.GetReturnValue().Set(cwd);
}",58,,128,2,,void
220010,BLOCK,-1,,<empty>,5,,135,2,,void
220052,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Local<Context> context = env->context();

  if (args.Length() < 2) {
    THROW_ERR_MISSING_ARGS(env, ""Bad argument."");
  }

  int pid;
  if (!args[0]->Int32Value(context).To(&pid)) return;
  int sig;
  if (!args[1]->Int32Value(context).To(&sig)) return;

  uv_pid_t own_pid = uv_os_getpid();
  if (sig > 0 &&
      (pid == 0 || pid == -1 || pid == own_pid || pid == -own_pid) &&
      !HasSignalJSHandler(sig)) {
    // This is most likely going to terminate this process.
    // It's not an exact method but it might be close enough.
    RunAtExit(env);
  }

  int err = uv_kill(pid, sig);
  args.GetReturnValue().Set(err);
}",59,,144,2,,void
220078,BLOCK,-1,,"{
    THROW_ERR_MISSING_ARGS(env, ""Bad argument."");
  }",26,,148,2,,void
220097,BLOCK,-1,,<empty>,47,,153,2,,void
220114,BLOCK,-1,,<empty>,47,,155,2,,void
220146,BLOCK,-1,,"{
    // This is most likely going to terminate this process.
    // It's not an exact method but it might be close enough.
    RunAtExit(env);
  }",33,,160,2,,void
220167,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  size_t rss;
  int err = uv_resident_set_memory(&rss);
  if (err)
    return env->ThrowUVException(err, ""uv_resident_set_memory"");

  args.GetReturnValue().Set(static_cast<double>(rss));
}",58,,170,2,,void
220185,BLOCK,-1,,<empty>,5,,176,2,,void
220207,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  Isolate* isolate = env->isolate();
  // V8 memory usage
  HeapStatistics v8_heap_stats;
  isolate->GetHeapStatistics(&v8_heap_stats);

  NodeArrayBufferAllocator* array_buffer_allocator =
      env->isolate_data()->node_allocator();

  // Get the double array pointer from the Float64Array argument.
  Local<ArrayBuffer> ab = get_fields_array_buffer(args, 0, 5);
  double* fields = static_cast<double*>(ab->Data());

  size_t rss;
  int err = uv_resident_set_memory(&rss);
  if (err)
    return env->ThrowUVException(err, ""uv_resident_set_memory"");

  fields[0] = static_cast<double>(rss);
  fields[1] = static_cast<double>(v8_heap_stats.total_heap_size());
  fields[2] = static_cast<double>(v8_heap_stats.used_heap_size());
  fields[3] = static_cast<double>(v8_heap_stats.external_memory());
  fields[4] =
      array_buffer_allocator == nullptr
          ? 0
          : static_cast<double>(array_buffer_allocator->total_mem_usage());
}",66,,181,2,,void
220268,BLOCK,-1,,<empty>,5,,199,2,,void
220332,BLOCK,-1,,"{
  uint64_t value = uv_get_constrained_memory();
  if (value != 0) {
    args.GetReturnValue().Set(static_cast<double>(value));
  }
}",75,,211,2,,void
220341,BLOCK,-1,,"{
    args.GetReturnValue().Set(static_cast<double>(value));
  }",19,,213,2,,void
220356,BLOCK,-1,,"{
  CHECK(args.Length() == 1 && args[0]->IsString() &&
        ""must be called with a single string"");
  Utf8Value message(args.GetIsolate(), args[0]);
  FPrintF(stderr, ""%s\n"", message);
  fflush(stderr);
}",56,,218,2,,void
220391,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(env->has_run_bootstrapping_code());
  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsUndefined() || args[0]->IsUint32());
  Mutex::ScopedLock scoped_lock(per_process::umask_mutex);

  uint32_t old;
  if (args[0]->IsUndefined()) {
    old = umask(0);
    umask(static_cast<mode_t>(old));
  } else {
    int oct = args[0].As<Uint32>()->Value();
    old = umask(static_cast<mode_t>(oct));
  }

  args.GetReturnValue().Set(old);
}",60,,226,2,,void
220438,BLOCK,-1,,"{
    old = umask(0);
    umask(static_cast<mode_t>(old));
  }",31,,234,2,,void
220448,BLOCK,-1,,"{
    int oct = args[0].As<Uint32>()->Value();
    old = umask(static_cast<mode_t>(oct));
  }",10,,237,1,,void
220479,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  uv_update_time(env->event_loop());
  double uptime =
      static_cast<double>(uv_hrtime() - per_process::node_start_time);
  Local<Number> result = Number::New(env->isolate(), uptime / NANOS_PER_SEC);
  args.GetReturnValue().Set(result);
}",61,,245,2,,void
220520,BLOCK,1,,<empty>,,,,1,,void
220534,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  std::vector<Local<Value>> request_v;
  for (ReqWrapBase* req_wrap : *env->req_wrap_queue()) {
    AsyncWrap* w = req_wrap->GetAsyncWrap();
    if (w->persistent().IsEmpty())
      continue;
    request_v.emplace_back(w->GetOwner());
  }

  args.GetReturnValue().Set(
      Array::New(env->isolate(), request_v.data(), request_v.size()));
}",72,,255,2,,void
220559,BLOCK,-1,,"{
    AsyncWrap* w = req_wrap->GetAsyncWrap();
    if (w->persistent().IsEmpty())
      continue;
    request_v.emplace_back(w->GetOwner());
  }",56,,259,3,,void
220575,BLOCK,-1,,<empty>,7,,262,2,,void
220612,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  std::vector<Local<Value>> handle_v;
  for (auto w : *env->handle_wrap_queue()) {
    if (!HandleWrap::HasRef(w))
      continue;
    handle_v.emplace_back(w->GetOwner());
  }
  args.GetReturnValue().Set(
      Array::New(env->isolate(), handle_v.data(), handle_v.size()));
}",64,,272,2,,void
220637,BLOCK,-1,,"{
    if (!HandleWrap::HasRef(w))
      continue;
    handle_v.emplace_back(w->GetOwner());
  }",44,,276,3,,void
220645,BLOCK,-1,,<empty>,7,,278,2,,void
220682,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  std::vector<Local<Value>> resources_info;

  // Active requests
  for (ReqWrapBase* req_wrap : *env->req_wrap_queue()) {
    AsyncWrap* w = req_wrap->GetAsyncWrap();
    if (w->persistent().IsEmpty()) continue;
    resources_info.emplace_back(
        OneByteString(env->isolate(), w->MemoryInfoName()));
  }

  // Active handles
  for (HandleWrap* w : *env->handle_wrap_queue()) {
    if (w->persistent().IsEmpty() || !HandleWrap::HasRef(w)) continue;
    resources_info.emplace_back(
        OneByteString(env->isolate(), w->MemoryInfoName()));
  }

  // Active timeouts
  resources_info.insert(resources_info.end(),
                        env->timeout_info()[0],
                        OneByteString(env->isolate(), ""Timeout""));

  // Active immediates
  resources_info.insert(resources_info.end(),
                        env->immediate_info()->ref_count(),
                        OneByteString(env->isolate(), ""Immediate""));

  args....",77,,285,2,,void
220707,BLOCK,-1,,"{
    AsyncWrap* w = req_wrap->GetAsyncWrap();
    if (w->persistent().IsEmpty()) continue;
    resources_info.emplace_back(
        OneByteString(env->isolate(), w->MemoryInfoName()));
  }",56,,290,3,,void
220723,BLOCK,-1,,<empty>,36,,292,2,,void
220745,BLOCK,-1,,"{
    if (w->persistent().IsEmpty() || !HandleWrap::HasRef(w)) continue;
    resources_info.emplace_back(
        OneByteString(env->isolate(), w->MemoryInfoName()));
  }",51,,298,3,,void
220761,BLOCK,-1,,<empty>,62,,299,2,,void
220844,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  uv_rusage_t rusage;
  int err = uv_getrusage(&rusage);
  if (err)
    return env->ThrowUVException(err, ""uv_getrusage"");

  Local<ArrayBuffer> ab = get_fields_array_buffer(args, 0, 16);
  double* fields = static_cast<double*>(ab->Data());

  fields[0] = MICROS_PER_SEC * rusage.ru_utime.tv_sec + rusage.ru_utime.tv_usec;
  fields[1] = MICROS_PER_SEC * rusage.ru_stime.tv_sec + rusage.ru_stime.tv_usec;
  fields[2] = static_cast<double>(rusage.ru_maxrss);
  fields[3] = static_cast<double>(rusage.ru_ixrss);
  fields[4] = static_cast<double>(rusage.ru_idrss);
  fields[5] = static_cast<double>(rusage.ru_isrss);
  fields[6] = static_cast<double>(rusage.ru_minflt);
  fields[7] = static_cast<double>(rusage.ru_majflt);
  fields[8] = static_cast<double>(rusage.ru_nswap);
  fields[9] = static_cast<double>(rusage.ru_inblock);
  fields[10] = static_cast<double>(rusage.ru_oublock);
  fields[11] = static_cast<double>(rusage.ru_msgsnd);
  fields...",68,,318,2,,void
220862,BLOCK,-1,,<empty>,5,,324,2,,void
220896,BLOCK,1,,<empty>,,,,1,,void
220915,BLOCK,1,,<empty>,,,,1,,void
221057,BLOCK,-1,,"{
#if HAVE_INSPECTOR
  Environment* env = Environment::GetCurrent(args);
  if (env->inspector_agent()->IsListening()) {
    env->inspector_agent()->Stop();
  }
#endif
}",63,,446,2,,void
221062,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  RunAtExit(env);
  ExitCode code = ExitCode::kNoFailure;
  Maybe<int32_t> code_int = args[0]->Int32Value(env->context());
  if (!code_int.IsNothing()) {
    code = static_cast<ExitCode>(code_int.FromJust());
  }
  env->Exit(code);
}",65,,455,2,,void
221101,BLOCK,-1,,"{
    code = static_cast<ExitCode>(code_int.FromJust());
  }",30,,460,2,,void
221121,BLOCK,-1,,"{
  Isolate* isolate = realm->isolate();
  Local<Context> context = realm->context();
  Local<ArrayBuffer> ab = ArrayBuffer::New(isolate, kBufferSize);
  array_buffer_.Reset(isolate, ab);
  object->Set(context, FIXED_ONE_BYTE_STRING(isolate, ""hrtimeBuffer""), ab)
      .ToChecked();
  backing_store_ = ab->GetBackingStore();
}",51,,469,3,,void
221179,BLOCK,-1,,<empty>,,,,2,,<empty>
221184,BLOCK,-1,,<empty>,,,,2,,<empty>
221190,BLOCK,-1,,"{
  SetFastMethodNoSideEffect(
      isolate, target, ""hrtime"", SlowNumber, &fast_number_);
  SetFastMethodNoSideEffect(
      isolate, target, ""hrtimeBigInt"", SlowBigInt, &fast_bigint_);
}",78,,482,3,,void
221209,BLOCK,-1,,"{
  registry->Register(SlowNumber);
  registry->Register(SlowBigInt);
  registry->Register(FastNumber);
  registry->Register(FastBigInt);
  registry->Register(fast_number_.GetTypeInfo());
  registry->Register(fast_bigint_.GetTypeInfo());
}",42,,490,2,,void
221250,BLOCK,-1,,"{
  Local<Object> v8_object = value.As<Object>();
  return static_cast<BindingData*>(
      v8_object->GetAlignedPointerFromInternalField(BaseObject::kSlot));
}",59,,499,2,,void
221275,BLOCK,-1,,"{
  tracker->TrackField(""array_buffer"", array_buffer_);
}",60,,505,2,,void
221286,BLOCK,-1,,"{
  // Make sure we don't accidentally access buffers wiped for snapshot.
  CHECK(!receiver->array_buffer_.IsEmpty());
  uint64_t t = uv_hrtime();
  uint32_t* fields = static_cast<uint32_t*>(receiver->backing_store_->Data());
  fields[0] = (t / NANOS_PER_SEC) >> 32;
  fields[1] = (t / NANOS_PER_SEC) & 0xffffffff;
  fields[2] = t % NANOS_PER_SEC;
}",53,,518,2,,void
221318,BLOCK,1,,<empty>,,,,1,,void
221329,BLOCK,1,,<empty>,,,,1,,void
221339,BLOCK,1,,<empty>,,,,1,,void
221345,BLOCK,-1,,"{
  // Make sure we don't accidentally access buffers wiped for snapshot.
  CHECK(!receiver->array_buffer_.IsEmpty());
  uint64_t t = uv_hrtime();
  uint64_t* fields = static_cast<uint64_t*>(receiver->backing_store_->Data());
  fields[0] = t;
}",53,,528,2,,void
221378,BLOCK,-1,,"{
  BigIntImpl(FromJSObject<BindingData>(args.Holder()));
}",71,,536,2,,void
221392,BLOCK,-1,,"{
  NumberImpl(FromJSObject<BindingData>(args.Holder()));
}",79,,540,2,,void
221407,BLOCK,-1,,"{
  // It's not worth keeping.
  // Release it, we will recreate it when the instance is dehydrated.
  array_buffer_.Reset();
  // Return true because we need to maintain the reference to the binding from
  // JS land.
  return true;
}",73,,545,3,,void
221418,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  InternalFieldInfo* info =
      InternalFieldInfoBase::New<InternalFieldInfo>(type());
  return info;
}",58,,554,2,,void
221443,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  v8::HandleScope scope(context->GetIsolate());
  Realm* realm = Realm::GetCurrent(context);
  // Recreate the buffer in the constructor.
  BindingData* binding = realm->AddBindingData<BindingData>(context, holder);
  CHECK_NOT_NULL(binding);
}",60,,564,5,,void
221483,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();

  BindingData::AddMethods(isolate, target);
  // define various internal methods
  SetMethod(isolate, target, ""_debugProcess"", DebugProcess);
  SetMethod(isolate, target, ""abort"", Abort);
  SetMethod(isolate, target, ""causeSegfault"", CauseSegfault);
  SetMethod(isolate, target, ""chdir"", Chdir);

  SetMethod(isolate, target, ""umask"", Umask);
  SetMethod(isolate, target, ""memoryUsage"", MemoryUsage);
  SetMethod(isolate, target, ""constrainedMemory"", GetConstrainedMemory);
  SetMethod(isolate, target, ""rss"", Rss);
  SetMethod(isolate, target, ""cpuUsage"", CPUUsage);
  SetMethod(isolate, target, ""resourceUsage"", ResourceUsage);

  SetMethod(isolate, target, ""_debugEnd"", DebugEnd);
  SetMethod(isolate, target, ""_getActiveRequests"", GetActiveRequests);
  SetMethod(isolate, target, ""_getActiveHandles"", GetActiveHandles);
  SetMethod(isolate, target, ""getActiveResourcesInfo"", GetActiveResourcesInfo);
  SetMethod(isolate, target, ""_kill"", Kill);...",70,,574,3,,void
221611,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(context);
  realm->AddBindingData<BindingData>(context, target);
}",52,,608,5,,void
221634,BLOCK,-1,,"{
  BindingData::RegisterExternalReferences(registry);

  registry->Register(DebugProcess);
  registry->Register(DebugEnd);
  registry->Register(Abort);
  registry->Register(CauseSegfault);
  registry->Register(Chdir);

  registry->Register(Umask);
  registry->Register(RawDebug);
  registry->Register(MemoryUsage);
  registry->Register(GetConstrainedMemory);
  registry->Register(Rss);
  registry->Register(CPUUsage);
  registry->Register(ResourceUsage);

  registry->Register(GetActiveRequests);
  registry->Register(GetActiveHandles);
  registry->Register(GetActiveResourcesInfo);
  registry->Register(Kill);

  registry->Register(Cwd);
  registry->Register(binding::DLOpen);
  registry->Register(ReallyExit);
  registry->Register(Uptime);
  registry->Register(PatchProcessObject);
}",70,,613,2,,void
221754,BLOCK,-1,,{ return a.first < b.first; },34,,129,3,,void
221791,BLOCK,-1,,<empty>,1,,1,1,,ANY
221796,BLOCK,-1,,"{
  std::string title = GetProcessTitle(""node"");
  info.GetReturnValue().Set(
      String::NewFromUtf8(info.GetIsolate(), title.data(),
                          NewStringType::kNormal, title.size())
      .ToLocalChecked());
}",73,,35,3,,void
221837,BLOCK,-1,,"{
  node::Utf8Value title(info.GetIsolate(), value);
  TRACE_EVENT_METADATA1(
      ""__metadata"", ""process_name"", ""name"", TRACE_STR_COPY(*title));
  uv_set_process_title(*title);
}",72,,45,4,,void
221860,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  ExclusiveAccess<HostPort>::Scoped host_port(env->inspector_host_port());
  int port = host_port->port();
  info.GetReturnValue().Set(port);
}",70,,53,3,,void
221896,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  int32_t port = value->Int32Value(env->context()).FromMaybe(0);

  if ((port != 0 && port < 1024) || port > 65535) {
    return THROW_ERR_OUT_OF_RANGE(
      env,
      ""process.debugPort must be 0 or in range 1024 to 65535"");
  }

  ExclusiveAccess<HostPort>::Scoped host_port(env->inspector_host_port());
  host_port->set_port(static_cast<int>(port));
}",69,,62,4,,void
221932,BLOCK,-1,,"{
    return THROW_ERR_OUT_OF_RANGE(
      env,
      ""process.debugPort must be 0 or in range 1024 to 65535"");
  }",51,,66,2,,void
221955,BLOCK,-1,,"{
  info.GetReturnValue().Set(uv_os_getppid());
}",73,,77,3,,void
221968,BLOCK,-1,,"{
  Isolate* isolate = realm->isolate();
  EscapableHandleScope scope(isolate);
  Local<Context> context = realm->context();

  Local<FunctionTemplate> process_template = FunctionTemplate::New(isolate);
  process_template->SetClassName(realm->env()->process_string());
  Local<Function> process_ctor;
  Local<Object> process;
  if (!process_template->GetFunction(context).ToLocal(&process_ctor) ||
      !process_ctor->NewInstance(context).ToLocal(&process)) {
    return MaybeLocal<Object>();
  }

  // process[exit_info_private_symbol]
  if (process
          ->SetPrivate(context,
                       realm->env()->exit_info_private_symbol(),
                       realm->env()->exit_info().GetJSArray())
          .IsNothing()) {
    return {};
  }

  // process.version
  READONLY_PROPERTY(
      process, ""version"", FIXED_ONE_BYTE_STRING(isolate, NODE_VERSION));

  Local<Object> versions = Object::New(isolate);
  // Node.js version is always on the top
  READONLY_STRING_PROPERTY(
    ...",54,,81,2,,void
222045,BLOCK,-1,,"{
    return MaybeLocal<Object>();
  }",62,,91,2,,void
222074,BLOCK,-1,,"{
    return {};
  }",25,,100,2,,void
222145,BLOCK,-1,,"{
    versions
        ->DefineOwnProperty(
            context,
            OneByteString(isolate, version.first.data(), version.first.size()),
            OneByteString(
                isolate, version.second.data(), version.second.size()),
            v8::ReadOnly)
        .Check();
  }",46,,131,3,,void
222245,BLOCK,-1,,"{
  Isolate* isolate = args.GetIsolate();
  Local<Context> context = isolate->GetCurrentContext();
  Environment* env = Environment::GetCurrent(context);
  CHECK(args[0]->IsObject());
  Local<Object> process = args[0].As<Object>();

  // process.title
  CHECK(process
            ->SetAccessor(
                context,
                FIXED_ONE_BYTE_STRING(isolate, ""title""),
                ProcessTitleGetter,
                env->owns_process_state() ? ProcessTitleSetter : nullptr,
                Local<Value>(),
                DEFAULT,
                None,
                SideEffectType::kHasNoSideEffect)
            .FromJust());

  // process.argv
  process->Set(context,
               FIXED_ONE_BYTE_STRING(isolate, ""argv""),
               ToV8Value(context, env->argv()).ToLocalChecked()).Check();

  // process.execArgv
  process->Set(context,
               FIXED_ONE_BYTE_STRING(isolate, ""execArgv""),
               ToV8Value(context, env->exec_argv())
                   .ToLoc...",66,,177,2,,void
222441,BLOCK,-1,,"{
  registry->Register(RawDebug);
  registry->Register(GetParentProcessId);
  registry->Register(DebugPortSetter);
  registry->Register(DebugPortGetter);
  registry->Register(ProcessTitleSetter);
  registry->Register(ProcessTitleGetter);
}",77,,246,2,,void
222483,BLOCK,-1,,<empty>,1,,1,1,,ANY
222487,BLOCK,-1,,"{
    std::cout << ""#"" << i++ << "" "" << obj << "": "" << obj->MemoryInfoName()
              << ""\n"";
  }",42,,225,2,,void
222516,BLOCK,-1,,"{
    if (obj->IsNotIndicativeOfMemoryLeakAtExit()) return;
    fprintf(stderr,
            ""Found bad BaseObject during clean exit: %s\n"",
            obj->MemoryInfoName());
    fflush(stderr);
    ABORT();
  }",41,,268,2,,void
222522,BLOCK,-1,,<empty>,51,,269,2,,void
222550,BLOCK,-1,,<empty>,1,,1,1,,ANY
222556,BLOCK,-1,,"{
  context_.Reset(isolate_, context);
  env->AssignToContext(context, this, ContextInfo(""""));
}",63,,22,4,,void
222574,BLOCK,-1,,"{
  CHECK_EQ(base_object_count_, 0);
}",17,,27,1,,void
222582,BLOCK,-1,,"{
#define V(PropertyName, TypeName)                                              \
  tracker->TrackField(#PropertyName, PropertyName());
  PER_REALM_STRONG_PERSISTENT_VALUES(V)
#undef V

  tracker->TrackField(""cleanup_queue"", cleanup_queue_);
  tracker->TrackField(""builtins_with_cache"", builtins_with_cache);
  tracker->TrackField(""builtins_without_cache"", builtins_without_cache);
}",54,,31,2,,void
222606,BLOCK,-1,,"{
  HandleScope handle_scope(isolate_);
  Local<Context> ctx = context();

  // Store primordials setup by the per-context script in the environment.
  Local<Object> per_context_bindings =
      GetPerContextExports(ctx).ToLocalChecked();
  Local<Value> primordials =
      per_context_bindings->Get(ctx, env_->primordials_string())
          .ToLocalChecked();
  CHECK(primordials->IsObject());
  set_primordials(primordials.As<Object>());

  Local<String> prototype_string =
      FIXED_ONE_BYTE_STRING(isolate(), ""prototype"");

#define V(EnvPropertyName, PrimordialsPropertyName)                            \
  {                                                                            \
    Local<Value> ctor =                                                        \
        primordials.As<Object>()                                               \
            ->Get(ctx,                                                         \
                  FIXED_ONE_BYTE_STRING(isolate(), Primordial...",32,,42,1,,void
222667,BLOCK,1,,"V(primordials_safe_map_prototype_object, ""SafeMap"")",3,,72,9,,void
222723,BLOCK,1,,"V(primordials_safe_set_prototype_object, ""SafeSet"")",3,,73,10,,void
222779,BLOCK,1,,"V(primordials_safe_weak_map_prototype_object, ""SafeWeakMap"")",3,,74,11,,void
222835,BLOCK,1,,"V(primordials_safe_weak_set_prototype_object, ""SafeWeakSet"")",3,,75,12,,void
222909,BLOCK,-1,,"{
  RealmSerializeInfo info;
  Local<Context> ctx = context();

  // Currently all modules are compiled without cache in builtin snapshot
  // builder.
  info.builtins = std::vector<std::string>(builtins_without_cache.begin(),
                                           builtins_without_cache.end());

  uint32_t id = 0;
#define V(PropertyName, TypeName)                                              \
  do {                                                                         \
    Local<TypeName> field = PropertyName();                                    \
    if (!field.IsEmpty()) {                                                    \
      size_t index = creator->AddData(ctx, field);                             \
      info.persistent_values.push_back({#PropertyName, id, index});            \
    }                                                                          \
    id++;                                                                      \
  } while (0);
  PER_REALM_S...",63,,86,2,,void
222967,BLOCK,-1,,"{
  Local<Context> ctx = context();

  builtins_in_snapshot = info->builtins;

  const std::vector<PropInfo>& values = info->persistent_values;
  size_t i = 0;  // index to the array
  uint32_t id = 0;
#define V(PropertyName, TypeName)                                              \
  do {                                                                         \
    if (values.size() > i && id == values[i].id) {                             \
      const PropInfo& d = values[i];                                           \
      DCHECK_EQ(d.name, #PropertyName);                                        \
      MaybeLocal<TypeName> maybe_field =                                       \
          ctx->GetDataFromSnapshotOnce<TypeName>(d.index);                     \
      Local<TypeName> field;                                                   \
      if (!maybe_field.ToLocal(&field)) {                                      \
        fprintf(stderr,                                           ...",67,,116,2,,void
223023,BLOCK,-1,,"{
    fprintf(stderr,
            ""Failed to deserialize context back reference from the snapshot\n"");
  }",61,,148,2,,void
223035,BLOCK,-1,,"{
  EscapableHandleScope scope(isolate());
  Local<Context> ctx = context();
  MaybeLocal<Value> result =
      env()->builtin_loader()->CompileAndCall(ctx, id, this);

  // If there was an error during bootstrap, it must be unrecoverable
  // (e.g. max call stack exceeded). Clear the stack so that the
  // AsyncCallbackScope destructor doesn't fail on the id check.
  // There are only two ways to have a stack size > 1: 1) the user manually
  // called MakeCallback or 2) user awaited during bootstrap, which triggered
  // _tickCallback().
  if (result.IsEmpty()) {
    env()->async_hooks()->clear_async_id_stack();
  }

  return scope.EscapeMaybe(result);
}",62,,157,2,,void
223067,BLOCK,-1,,"{
    env()->async_hooks()->clear_async_id_stack();
  }",25,,169,2,,void
223084,BLOCK,-1,,"{
  EscapableHandleScope scope(isolate_);

  CHECK(!has_run_bootstrapping_code());

  Local<Value> result;
  if (!ExecuteBootstrapper(""internal/bootstrap/realm"").ToLocal(&result) ||
      !BootstrapRealm().ToLocal(&result)) {
    return MaybeLocal<Value>();
  }

  DoneBootstrapping();

  return scope.Escape(result);
}",45,,176,1,,void
223113,BLOCK,-1,,"{
    return MaybeLocal<Value>();
  }",43,,183,2,,void
223126,BLOCK,-1,,"{
  // Make sure that no request or handle is created during bootstrap -
  // if necessary those should be done in pre-execution.
  // Usually, doing so would trigger the checks present in the ReqWrap and
  // HandleWrap classes, so this is only a consistency check.

  // TODO(legendecas): track req_wrap and handle_wrap by realms instead of
  // environments.
  if (kind_ == kPrincipal) {
    CHECK(env_->req_wrap_queue()->IsEmpty());
    CHECK(env_->handle_wrap_queue()->IsEmpty());
  }

  has_run_bootstrapping_code_ = true;

  // This adjusts the return value of base_object_created_after_bootstrap() so
  // that tests that check the count do not have to account for internally
  // created BaseObjects.
  base_object_created_by_bootstrap_ = base_object_count_;
}",33,,192,1,,void
223131,BLOCK,-1,,"{
    CHECK(env_->req_wrap_queue()->IsEmpty());
    CHECK(env_->handle_wrap_queue()->IsEmpty());
  }",28,,200,2,,void
223157,BLOCK,-1,,"{
  TRACE_EVENT0(TRACING_CATEGORY_NODE1(realm), ""RunCleanup"");
  for (size_t i = 0; i < binding_data_store_.size(); ++i) {
    binding_data_store_[i].reset();
  }
  cleanup_queue_.Drain();
}",26,,213,1,,void
223163,BLOCK,-1,,<empty>,3,,215,1,,void
223176,BLOCK,4,,"{
    binding_data_store_[i].reset();
  }",59,,215,4,,void
223190,BLOCK,-1,,"{
  fprintf(stderr, ""Realm = %p\n"", this);
  fprintf(stderr, ""BaseObjects of the Realm:\n"");
  size_t i = 0;
  ForEachBaseObject([&](BaseObject* obj) {
    std::cout << ""#"" << i++ << "" "" << obj << "": "" << obj->MemoryInfoName()
              << ""\n"";
  });

  fprintf(stderr, ""\nBuiltins without cache:\n"");
  for (const auto& s : builtins_without_cache) {
    fprintf(stderr, ""%s\n"", s.c_str());
  }
  fprintf(stderr, ""\nBuiltins with cache:\n"");
  for (const auto& s : builtins_with_cache) {
    fprintf(stderr, ""%s\n"", s.c_str());
  }
  fprintf(stderr, ""\nStatic bindings (need to be registered):\n"");
  for (const auto mod : internal_bindings) {
    fprintf(stderr, ""%s:%s\n"", mod->nm_filename, mod->nm_modname);
  }

  fprintf(stderr, ""End of the Realm.\n"");
}",36,,221,1,,void
223209,BLOCK,-1,,"{
    fprintf(stderr, ""%s\n"", s.c_str());
  }",48,,231,3,,void
223223,BLOCK,-1,,"{
    fprintf(stderr, ""%s\n"", s.c_str());
  }",45,,235,3,,void
223237,BLOCK,-1,,"{
    fprintf(stderr, ""%s:%s\n"", mod->nm_filename, mod->nm_modname);
  }",44,,239,3,,void
223253,BLOCK,-1,,"{
  // When a process exits cleanly, i.e. because the event loop ends up without
  // things to wait for, the Node.js objects that are left on the heap should
  // be:
  //
  //   1. weak, i.e. ready for garbage collection once no longer referenced, or
  //   2. detached, i.e. scheduled for destruction once no longer referenced, or
  //   3. an unrefed libuv handle, i.e. does not keep the event loop alive, or
  //   4. an inactive libuv handle (essentially the same here)
  //
  // There are a few exceptions to this rule, but generally, if there are
  // C++-backed Node.js objects on the heap that do not fall into the above
  // categories, we may be looking at a potential memory leak. Most likely,
  // the cause is a missing MakeWeak() call on the corresponding object.
  //
  // In order to avoid this kind of problem, we check the list of BaseObjects
  // for these criteria. Currently, we only do so when explicitly instructed to
  // or when in debug mode (where --verify-base-object...",41,,246,1,,void
223262,BLOCK,-1,,<empty>,47,,266,2,,void
223269,BLOCK,-1,,"{
  return PersistentToLocal::Strong(context_);
}",47,,278,1,,void
223284,BLOCK,-1,,"{
  // Create properties if not deserializing from snapshot.
  // Or the properties are deserialized with DeserializeProperties() when the
  // env drained the deserialize requests.
  if (realm_info == nullptr) {
    CreateProperties();
  }
}",39,,299,4,,void
223289,BLOCK,-1,,"{
    CreateProperties();
  }",30,,303,2,,void
223294,BLOCK,-1,,"{
  DCHECK(!context_.IsEmpty());

  HandleScope handle_scope(isolate());
  env_->UnassignFromContext(context());
}",35,,308,1,,void
223312,BLOCK,-1,,"{
  HandleScope scope(isolate_);

  if (ExecuteBootstrapper(""internal/bootstrap/node"").IsEmpty()) {
    return MaybeLocal<Value>();
  }

  if (!env_->no_browser_globals()) {
    if (ExecuteBootstrapper(""internal/bootstrap/web/exposed-wildcard"")
            .IsEmpty() ||
        ExecuteBootstrapper(""internal/bootstrap/web/exposed-window-or-worker"")
            .IsEmpty()) {
      return MaybeLocal<Value>();
    }
  }

  // TODO(joyeecheung): skip these in the snapshot building for workers.
  auto thread_switch_id =
      env_->is_main_thread() ? ""internal/bootstrap/switches/is_main_thread""
                             : ""internal/bootstrap/switches/is_not_main_thread"";
  if (ExecuteBootstrapper(thread_switch_id).IsEmpty()) {
    return MaybeLocal<Value>();
  }

  auto process_state_switch_id =
      env_->owns_process_state()
          ? ""internal/bootstrap/switches/does_own_process_state""
          : ""internal/bootstrap/switches/does_not_own_process_state"";
  if (ExecuteBootstrapper...",52,,315,1,,void
223322,BLOCK,-1,,"{
    return MaybeLocal<Value>();
  }",65,,318,2,,void
223331,BLOCK,-1,,"{
    if (ExecuteBootstrapper(""internal/bootstrap/web/exposed-wildcard"")
            .IsEmpty() ||
        ExecuteBootstrapper(""internal/bootstrap/web/exposed-window-or-worker"")
            .IsEmpty()) {
      return MaybeLocal<Value>();
    }
  }",36,,322,2,,void
223344,BLOCK,-1,,"{
      return MaybeLocal<Value>();
    }",25,,326,2,,void
223363,BLOCK,-1,,"{
    return MaybeLocal<Value>();
  }",56,,335,2,,void
223382,BLOCK,-1,,"{
    return MaybeLocal<Value>();
  }",63,,343,2,,void
223431,BLOCK,-1,,"{
    return MaybeLocal<Value>();
  }",76,,351,2,,void
223458,BLOCK,-1,,<empty>,1,,1,1,,ANY
223462,BLOCK,-1,,"{
        std::ostringstream os;

        GetNodeReport(
            env, ""Worker thread subreport"", trigger, Local<Value>(), os);

        Mutex::ScopedLock lock(workers_mutex);
        worker_infos.emplace_back(os.str());
        notify.Signal(lock);
      }",69,,228,2,,void
223496,BLOCK,-1,,"{
      expected_results += w->RequestInterrupt([&](Environment* env) {
        std::ostringstream os;

        GetNodeReport(
            env, ""Worker thread subreport"", trigger, Local<Value>(), os);

        Mutex::ScopedLock lock(workers_mutex);
        worker_infos.emplace_back(os.str());
        notify.Signal(lock);
      });
    }",39,,227,2,,void
223510,BLOCK,-1,,"{
                return !std::iswspace(ch);
              }",70,,539,2,,void
223524,BLOCK,-1,,{ return a.first < b.first; },34,,818,3,,void
223578,BLOCK,-1,,<empty>,1,,1,1,,ANY
223610,BLOCK,-1,,<empty>,,,,9,,<empty>
223615,BLOCK,-1,,<empty>,,,,2,,<empty>
223623,BLOCK,-1,,<empty>,,,,5,,<empty>
223628,BLOCK,-1,,<empty>,,,,2,,<empty>
223635,BLOCK,-1,,<empty>,,,,4,,<empty>
223642,BLOCK,-1,,<empty>,,,,4,,<empty>
223647,BLOCK,-1,,<empty>,,,,2,,<empty>
223652,BLOCK,-1,,<empty>,,,,2,,<empty>
223658,BLOCK,-1,,<empty>,,,,3,,<empty>
223663,BLOCK,-1,,<empty>,,,,2,,<empty>
223668,BLOCK,-1,,<empty>,,,,2,,<empty>
223673,BLOCK,-1,,<empty>,,,,2,,<empty>
223678,BLOCK,-1,,<empty>,,,,2,,<empty>
223683,BLOCK,-1,,<empty>,,,,2,,<empty>
223688,BLOCK,-1,,<empty>,,,,2,,<empty>
223698,BLOCK,-1,,"{
  // Obtain the current time and the pid.
  TIME_TYPE tm_struct;
  DiagnosticFilename::LocalTime(&tm_struct);
  uv_pid_t pid = uv_os_getpid();

  // Save formatting for output stream.
  std::ios old_state(nullptr);
  old_state.copyfmt(out);

  // File stream opened OK, now start printing the report content:
  // the title and header information (event, filename, timestamp and pid)

  JSONWriter writer(out, compact);
  writer.json_start();
  writer.json_objectstart(""header"");
  writer.json_keyvalue(""reportVersion"", NODE_REPORT_VERSION);
  writer.json_keyvalue(""event"", message);
  writer.json_keyvalue(""trigger"", trigger);
  if (!filename.empty())
    writer.json_keyvalue(""filename"", filename);
  else
    writer.json_keyvalue(""filename"", JSONWriter::Null{});

  // Report dump event and module load date/time stamps
  char timebuf[64];
#ifdef _WIN32
  snprintf(timebuf,
           sizeof(timebuf),
           ""%4d-%02d-%02dT%02d:%02d:%02dZ"",
           tm_struct.wYear,
           tm_stru...",43,,96,9,,void
223755,BLOCK,-1,,<empty>,5,,116,2,,void
223763,BLOCK,-1,,<empty>,5,,118,1,,void
223812,BLOCK,-1,,"{
    writer.json_keyvalue(""dumpEventTimeStamp"",
                         std::to_string(ts.tv_sec * 1000 + ts.tv_usec / 1000));
  }",34,,147,2,,void
223843,BLOCK,-1,,<empty>,5,,155,2,,void
223854,BLOCK,-1,,<empty>,5,,157,1,,void
223862,BLOCK,23,,"{
    // Report the process cwd.
    char buf[PATH_MAX_BYTES];
    size_t cwd_size = sizeof(buf);
    if (uv_cwd(buf, &cwd_size) == 0)
      writer.json_keyvalue(""cwd"", buf);
  }",3,,159,23,,void
223876,BLOCK,-1,,<empty>,7,,164,2,,void
223893,BLOCK,-1,,"{
    writer.json_arraystart(""commandLine"");
    for (const std::string& arg : per_process::cli_options->cmdline) {
      writer.json_element(arg);
    }
    writer.json_arrayend();
  }",51,,168,2,,void
223906,BLOCK,-1,,"{
      writer.json_element(arg);
    }",70,,170,3,,void
223927,BLOCK,-1,,"{
    writer.json_objectstart(""javascriptStack"");
    // Report summary JavaScript error stack backtrace
    PrintJavaScriptErrorStack(&writer, isolate, error, trigger);

    writer.json_objectend();  // the end of 'javascriptStack'

    // Report V8 Heap and Garbage Collector information
    PrintGCStatistics(&writer, isolate);
  }",27,,180,2,,void
223948,BLOCK,-1,,"{
    writer.json_objectstart(""javascriptStack"");
    PrintEmptyJavaScriptStack(&writer);
    writer.json_objectend();  // the end of 'javascriptStack'
  }",10,,189,1,,void
223976,BLOCK,-1,,"{
    uv_walk(env->event_loop(), WalkHandle, static_cast<void*>(&writer));

    writer.json_start();
    writer.json_keyvalue(""type"", ""loop"");
    writer.json_keyvalue(""is_active"",
        static_cast<bool>(uv_loop_alive(env->event_loop())));
    writer.json_keyvalue(""address"",
        ValueToHexString(reinterpret_cast<int64_t>(env->event_loop())));

    // Report Event loop idle time
    uint64_t idle_time = uv_metrics_idle_time(env->event_loop());
    writer.json_keyvalue(""loopIdleTimeSeconds"", 1.0 * idle_time / 1e9);
    writer.json_end();
  }",23,,202,2,,void
224056,BLOCK,-1,,"{
    Mutex workers_mutex;
    ConditionVariable notify;
    std::vector<std::string> worker_infos;
    size_t expected_results = 0;

    env->ForEachWorker([&](Worker* w) {
      expected_results += w->RequestInterrupt([&](Environment* env) {
        std::ostringstream os;

        GetNodeReport(
            env, ""Worker thread subreport"", trigger, Local<Value>(), os);

        Mutex::ScopedLock lock(workers_mutex);
        worker_infos.emplace_back(os.str());
        notify.Signal(lock);
      });
    });

    Mutex::ScopedLock lock(workers_mutex);
    worker_infos.reserve(expected_results);
    while (worker_infos.size() < expected_results)
      notify.Wait(lock);
    for (const std::string& worker_info : worker_infos)
      writer.json_element(JSONWriter::ForeignJSON { worker_info });
  }",23,,221,2,,void
224124,BLOCK,-1,,"{
  std::ostringstream buf;
  // Report Node version
  buf << ""v"" << NODE_VERSION_STRING;
  writer->json_keyvalue(""nodejsVersion"", buf.str());
  buf.str("""");

#ifndef _WIN32
  // Report compiler and runtime glibc versions where possible.
  const char* (*libc_version)();
  *(reinterpret_cast<void**>(&libc_version)) =
      dlsym(RTLD_DEFAULT, ""gnu_get_libc_version"");
  if (libc_version != nullptr)
    writer->json_keyvalue(""glibcVersionRuntime"", (*libc_version)());
#endif /* _WIN32 */

#ifdef __GLIBC__
  buf << __GLIBC__ << ""."" << __GLIBC_MINOR__;
  writer->json_keyvalue(""glibcVersionCompiler"", buf.str());
  buf.str("""");
#endif

  // Report Process word size
  writer->json_keyvalue(""wordSize"", sizeof(void*) * 8);
  writer->json_keyvalue(""arch"", per_process::metadata.arch);
  writer->json_keyvalue(""platform"", per_process::metadata.platform);

  // Report deps component versions
  PrintComponentVersions(writer);

  // Report release metadata.
  PrintRelease(writer);

  // Report operat...",57,,259,2,,void
224146,BLOCK,-1,,<empty>,,,,1,,<empty>
224162,BLOCK,-1,,<empty>,5,,272,2,,void
224211,BLOCK,-1,,"{
    writer->json_keyvalue(""osName"", os_info.sysname);
    writer->json_keyvalue(""osRelease"", os_info.release);
    writer->json_keyvalue(""osVersion"", os_info.version);
    writer->json_keyvalue(""osMachine"", os_info.machine);
  }",35,,295,2,,void
224261,BLOCK,-1,,<empty>,5,,309,2,,void
224272,BLOCK,-1,,"{
  uv_cpu_info_t* cpu_info;
  int count;
  if (uv_cpu_info(&cpu_info, &count) == 0) {
    writer->json_arraystart(""cpus"");
    for (int i = 0; i < count; i++) {
      writer->json_start();
      writer->json_keyvalue(""model"", cpu_info[i].model);
      writer->json_keyvalue(""speed"", cpu_info[i].speed);
      writer->json_keyvalue(""user"", cpu_info[i].cpu_times.user);
      writer->json_keyvalue(""nice"", cpu_info[i].cpu_times.nice);
      writer->json_keyvalue(""sys"", cpu_info[i].cpu_times.sys);
      writer->json_keyvalue(""idle"", cpu_info[i].cpu_times.idle);
      writer->json_keyvalue(""irq"", cpu_info[i].cpu_times.irq);
      writer->json_end();
    }
    writer->json_arrayend();
    uv_free_cpu_info(cpu_info, count);
  }
}",46,,313,2,,void
224283,BLOCK,-1,,"{
    writer->json_arraystart(""cpus"");
    for (int i = 0; i < count; i++) {
      writer->json_start();
      writer->json_keyvalue(""model"", cpu_info[i].model);
      writer->json_keyvalue(""speed"", cpu_info[i].speed);
      writer->json_keyvalue(""user"", cpu_info[i].cpu_times.user);
      writer->json_keyvalue(""nice"", cpu_info[i].cpu_times.nice);
      writer->json_keyvalue(""sys"", cpu_info[i].cpu_times.sys);
      writer->json_keyvalue(""idle"", cpu_info[i].cpu_times.idle);
      writer->json_keyvalue(""irq"", cpu_info[i].cpu_times.irq);
      writer->json_end();
    }
    writer->json_arrayend();
    uv_free_cpu_info(cpu_info, count);
  }",44,,316,2,,void
224290,BLOCK,-1,,<empty>,5,,318,1,,void
224300,BLOCK,4,,"{
      writer->json_start();
      writer->json_keyvalue(""model"", cpu_info[i].model);
      writer->json_keyvalue(""speed"", cpu_info[i].speed);
      writer->json_keyvalue(""user"", cpu_info[i].cpu_times.user);
      writer->json_keyvalue(""nice"", cpu_info[i].cpu_times.nice);
      writer->json_keyvalue(""sys"", cpu_info[i].cpu_times.sys);
      writer->json_keyvalue(""idle"", cpu_info[i].cpu_times.idle);
      writer->json_keyvalue(""irq"", cpu_info[i].cpu_times.irq);
      writer->json_end();
    }",37,,318,4,,void
224400,BLOCK,-1,,"{
  uv_interface_address_t* interfaces;
  char ip[INET6_ADDRSTRLEN];
  char netmask[INET6_ADDRSTRLEN];
  char mac[18];
  int count;

  if (uv_interface_addresses(&interfaces, &count) == 0) {
    writer->json_arraystart(""networkInterfaces"");

    for (int i = 0; i < count; i++) {
      writer->json_start();
      writer->json_keyvalue(""name"", interfaces[i].name);
      writer->json_keyvalue(""internal"", !!interfaces[i].is_internal);
      snprintf(mac,
               sizeof(mac),
               ""%02x:%02x:%02x:%02x:%02x:%02x"",
               static_cast<unsigned char>(interfaces[i].phys_addr[0]),
               static_cast<unsigned char>(interfaces[i].phys_addr[1]),
               static_cast<unsigned char>(interfaces[i].phys_addr[2]),
               static_cast<unsigned char>(interfaces[i].phys_addr[3]),
               static_cast<unsigned char>(interfaces[i].phys_addr[4]),
               static_cast<unsigned char>(interfaces[i].phys_addr[5]));
      writer->json_keyvalue(""mac"", mac)...",59,,334,2,,void
224414,BLOCK,-1,,"{
    writer->json_arraystart(""networkInterfaces"");

    for (int i = 0; i < count; i++) {
      writer->json_start();
      writer->json_keyvalue(""name"", interfaces[i].name);
      writer->json_keyvalue(""internal"", !!interfaces[i].is_internal);
      snprintf(mac,
               sizeof(mac),
               ""%02x:%02x:%02x:%02x:%02x:%02x"",
               static_cast<unsigned char>(interfaces[i].phys_addr[0]),
               static_cast<unsigned char>(interfaces[i].phys_addr[1]),
               static_cast<unsigned char>(interfaces[i].phys_addr[2]),
               static_cast<unsigned char>(interfaces[i].phys_addr[3]),
               static_cast<unsigned char>(interfaces[i].phys_addr[4]),
               static_cast<unsigned char>(interfaces[i].phys_addr[5]));
      writer->json_keyvalue(""mac"", mac);

      if (interfaces[i].address.address4.sin_family == AF_INET) {
        uv_ip4_name(&interfaces[i].address.address4, ip, sizeof(ip));
        uv_ip4_name(&interfaces[i].netmask.netmask...",57,,341,2,,void
224421,BLOCK,-1,,<empty>,5,,344,1,,void
224431,BLOCK,4,,"{
      writer->json_start();
      writer->json_keyvalue(""name"", interfaces[i].name);
      writer->json_keyvalue(""internal"", !!interfaces[i].is_internal);
      snprintf(mac,
               sizeof(mac),
               ""%02x:%02x:%02x:%02x:%02x:%02x"",
               static_cast<unsigned char>(interfaces[i].phys_addr[0]),
               static_cast<unsigned char>(interfaces[i].phys_addr[1]),
               static_cast<unsigned char>(interfaces[i].phys_addr[2]),
               static_cast<unsigned char>(interfaces[i].phys_addr[3]),
               static_cast<unsigned char>(interfaces[i].phys_addr[4]),
               static_cast<unsigned char>(interfaces[i].phys_addr[5]));
      writer->json_keyvalue(""mac"", mac);

      if (interfaces[i].address.address4.sin_family == AF_INET) {
        uv_ip4_name(&interfaces[i].address.address4, ip, sizeof(ip));
        uv_ip4_name(&interfaces[i].netmask.netmask4, netmask, sizeof(netmask));
        writer->json_keyvalue(""address"", ip);
        write...",37,,344,4,,void
224535,BLOCK,-1,,"{
        uv_ip4_name(&interfaces[i].address.address4, ip, sizeof(ip));
        uv_ip4_name(&interfaces[i].netmask.netmask4, netmask, sizeof(netmask));
        writer->json_keyvalue(""address"", ip);
        writer->json_keyvalue(""netmask"", netmask);
        writer->json_keyvalue(""family"", ""IPv4"");
      }",65,,359,2,,void
224579,BLOCK,-1,,<empty>,14,,365,1,,void
224592,BLOCK,-1,,"{
        uv_ip6_name(&interfaces[i].address.address6, ip, sizeof(ip));
        uv_ip6_name(&interfaces[i].netmask.netmask6, netmask, sizeof(netmask));
        writer->json_keyvalue(""address"", ip);
        writer->json_keyvalue(""netmask"", netmask);
        writer->json_keyvalue(""family"", ""IPv6"");
        writer->json_keyvalue(""scopeid"",
                              interfaces[i].address.address6.sin6_scope_id);
      }",73,,365,2,,void
224650,BLOCK,-1,,"{
        writer->json_keyvalue(""family"", ""unknown"");
      }",14,,373,1,,void
224674,BLOCK,-1,,"{
  writer->json_objectstart(""errorProperties"");
  if (!error.IsEmpty() && error->IsObject()) {
    TryCatch try_catch(isolate);
    Local<Object> error_obj = error.As<Object>();
    Local<Context> context = error_obj->GetIsolate()->GetCurrentContext();
    Local<Array> keys;
    if (!error_obj->GetOwnPropertyNames(context).ToLocal(&keys)) {
      return writer->json_objectend();  // the end of 'errorProperties'
    }
    uint32_t keys_length = keys->Length();
    for (uint32_t i = 0; i < keys_length; i++) {
      Local<Value> key;
      if (!keys->Get(context, i).ToLocal(&key) || !key->IsString()) {
        continue;
      }
      Local<Value> value;
      Local<String> value_string;
      if (!error_obj->Get(context, key).ToLocal(&value) ||
          !value->ToString(context).ToLocal(&value_string)) {
        continue;
      }
      node::Utf8Value k(isolate, key);
      if (k == ""stack"" || k == ""message"") continue;
      node::Utf8Value v(isolate, value_string);
      writer->jso...",64,,387,4,,void
224691,BLOCK,-1,,"{
    TryCatch try_catch(isolate);
    Local<Object> error_obj = error.As<Object>();
    Local<Context> context = error_obj->GetIsolate()->GetCurrentContext();
    Local<Array> keys;
    if (!error_obj->GetOwnPropertyNames(context).ToLocal(&keys)) {
      return writer->json_objectend();  // the end of 'errorProperties'
    }
    uint32_t keys_length = keys->Length();
    for (uint32_t i = 0; i < keys_length; i++) {
      Local<Value> key;
      if (!keys->Get(context, i).ToLocal(&key) || !key->IsString()) {
        continue;
      }
      Local<Value> value;
      Local<String> value_string;
      if (!error_obj->Get(context, key).ToLocal(&value) ||
          !value->ToString(context).ToLocal(&value_string)) {
        continue;
      }
      node::Utf8Value k(isolate, key);
      if (k == ""stack"" || k == ""message"") continue;
      node::Utf8Value v(isolate, value_string);
      writer->json_keyvalue(k.ToStringView(), v.ToStringView());
    }
  }",46,,389,2,,void
224735,BLOCK,-1,,"{
      return writer->json_objectend();  // the end of 'errorProperties'
    }",66,,394,2,,void
224749,BLOCK,-1,,<empty>,5,,398,1,,void
224759,BLOCK,4,,"{
      Local<Value> key;
      if (!keys->Get(context, i).ToLocal(&key) || !key->IsString()) {
        continue;
      }
      Local<Value> value;
      Local<String> value_string;
      if (!error_obj->Get(context, key).ToLocal(&value) ||
          !value->ToString(context).ToLocal(&value_string)) {
        continue;
      }
      node::Utf8Value k(isolate, key);
      if (k == ""stack"" || k == ""message"") continue;
      node::Utf8Value v(isolate, value_string);
      writer->json_keyvalue(k.ToStringView(), v.ToStringView());
    }",48,,398,4,,void
224784,BLOCK,-1,,"{
        continue;
      }",69,,400,2,,void
224821,BLOCK,-1,,"{
        continue;
      }",61,,406,2,,void
224835,BLOCK,-1,,<empty>,43,,410,2,,void
224863,BLOCK,-1,,"{
  if (error.IsEmpty()) {
    return Nothing<std::string>();
  }

  MaybeLocal<String> maybe_str;
  // `ToString` is not available to Symbols.
  if (error->IsSymbol()) {
    maybe_str = error.As<v8::Symbol>()->ToDetailString(context);
  } else if (!error->IsObject()) {
    maybe_str = error->ToString(context);
  } else if (error->IsObject()) {
    MaybeLocal<Value> stack = error.As<Object>()->Get(
        context, FIXED_ONE_BYTE_STRING(isolate, ""stack""));
    if (!stack.IsEmpty() && stack.ToLocalChecked()->IsString()) {
      maybe_str = stack.ToLocalChecked().As<String>();
    }
  }

  Local<String> js_str;
  if (!maybe_str.ToLocal(&js_str)) {
    return Nothing<std::string>();
  }
  String::Utf8Value sv(isolate, js_str);
  return Just<>(std::string(*sv, sv.length()));
}",61,,420,4,,void
224869,BLOCK,-1,,"{
    return Nothing<std::string>();
  }",24,,421,2,,void
224883,BLOCK,-1,,"{
    maybe_str = error.As<v8::Symbol>()->ToDetailString(context);
  }",26,,427,2,,void
224895,BLOCK,-1,,<empty>,10,,429,1,,void
224902,BLOCK,-1,,"{
    maybe_str = error->ToString(context);
  }",34,,429,2,,void
224911,BLOCK,-1,,<empty>,10,,431,1,,void
224917,BLOCK,-1,,"{
    MaybeLocal<Value> stack = error.As<Object>()->Get(
        context, FIXED_ONE_BYTE_STRING(isolate, ""stack""));
    if (!stack.IsEmpty() && stack.ToLocalChecked()->IsString()) {
      maybe_str = stack.ToLocalChecked().As<String>();
    }
  }",33,,431,2,,void
224949,BLOCK,-1,,"{
      maybe_str = stack.ToLocalChecked().As<String>();
    }",65,,434,2,,void
224972,BLOCK,-1,,"{
    return Nothing<std::string>();
  }",36,,440,2,,void
224996,BLOCK,-1,,"{
  writer->json_keyvalue(""message"", ""No stack."");
  writer->json_arraystart(""stack"");
  writer->json_element(""Unavailable."");
  writer->json_arrayend();

  writer->json_objectstart(""errorProperties"");
  writer->json_objectend();
}",59,,447,2,,void
225032,BLOCK,-1,,"{
  // Can not capture the stacktrace when the isolate is in a OOM state or no
  // context is entered.
  if (!strcmp(trigger, ""OOMError"") || !isolate->InContext()) {
    PrintEmptyJavaScriptStack(writer);
    return;
  }

  HandleScope scope(isolate);
  RegisterState state;
  state.pc = nullptr;
  state.fp = &state;
  state.sp = &state;

  // in-out params
  SampleInfo info;
  void* samples[MAX_FRAME_COUNT];
  isolate->GetStackSample(state, samples, MAX_FRAME_COUNT, &info);

  constexpr StackTrace::StackTraceOptions stack_trace_options =
      static_cast<StackTrace::StackTraceOptions>(
          StackTrace::kDetailed |
          StackTrace::kExposeFramesAcrossSecurityOrigins);
  Local<StackTrace> stack = StackTrace::CurrentStackTrace(
      isolate, MAX_FRAME_COUNT, stack_trace_options);

  if (stack->GetFrameCount() == 0) {
    PrintEmptyJavaScriptStack(writer);
    return;
  }

  writer->json_keyvalue(""message"", trigger);
  writer->json_arraystart(""stack"");
  for (int i = 0; i <...",55,,460,4,,void
225044,BLOCK,-1,,"{
    PrintEmptyJavaScriptStack(writer);
    return;
  }",62,,463,2,,void
225112,BLOCK,-1,,"{
    PrintEmptyJavaScriptStack(writer);
    return;
  }",36,,486,2,,void
225128,BLOCK,-1,,<empty>,3,,493,1,,void
225141,BLOCK,4,,"{
    Local<StackFrame> frame = stack->GetFrame(isolate, i);

    Utf8Value function_name(isolate, frame->GetFunctionName());
    Utf8Value script_name(isolate, frame->GetScriptName());
    const int line_number = frame->GetLineNumber();
    const int column = frame->GetColumn();

    std::string stack_line = SPrintF(
        ""at %s (%s:%d:%d)"", *function_name, *script_name, line_number, column);
    writer->json_element(stack_line);
  }",52,,493,4,,void
225218,BLOCK,-1,,"{
  if (error.IsEmpty()) {
    return PrintJavaScriptStack(writer, isolate, trigger);
  }

  TryCatch try_catch(isolate);
  HandleScope scope(isolate);
  Local<Context> context = isolate->GetCurrentContext();
  std::string ss = """";
  if (!ErrorToString(isolate, context, error).To(&ss)) {
    PrintEmptyJavaScriptStack(writer);
    return;
  }

  int line = ss.find('\n');
  if (line == -1) {
    writer->json_keyvalue(""message"", ss);
  } else {
    std::string l = ss.substr(0, line);
    writer->json_keyvalue(""message"", l);
    writer->json_arraystart(""stack"");
    ss = ss.substr(line + 1);
    line = ss.find('\n');
    while (line != -1) {
      l = ss.substr(0, line);
      l.erase(l.begin(), std::find_if(l.begin(), l.end(), [](int ch) {
                return !std::iswspace(ch);
              }));
      writer->json_element(l);
      ss = ss.substr(line + 1);
      line = ss.find('\n');
    }
    writer->json_arrayend();
  }

  // Report summary JavaScript error properties backtrace...",60,,514,5,,void
225224,BLOCK,-1,,"{
    return PrintJavaScriptStack(writer, isolate, trigger);
  }",24,,515,2,,void
225261,BLOCK,-1,,"{
    PrintEmptyJavaScriptStack(writer);
    return;
  }",56,,523,2,,void
225278,BLOCK,-1,,"{
    writer->json_keyvalue(""message"", ss);
  }",19,,529,2,,void
225286,BLOCK,-1,,"{
    std::string l = ss.substr(0, line);
    writer->json_keyvalue(""message"", l);
    writer->json_arraystart(""stack"");
    ss = ss.substr(line + 1);
    line = ss.find('\n');
    while (line != -1) {
      l = ss.substr(0, line);
      l.erase(l.begin(), std::find_if(l.begin(), l.end(), [](int ch) {
                return !std::iswspace(ch);
              }));
      writer->json_element(l);
      ss = ss.substr(line + 1);
      line = ss.find('\n');
    }
    writer->json_arrayend();
  }",10,,531,1,,void
225328,BLOCK,-1,,"{
      l = ss.substr(0, line);
      l.erase(l.begin(), std::find_if(l.begin(), l.end(), [](int ch) {
                return !std::iswspace(ch);
              }));
      writer->json_element(l);
      ss = ss.substr(line + 1);
      line = ss.find('\n');
    }",24,,537,2,,void
225391,BLOCK,-1,,"{
  auto sym_ctx = NativeSymbolDebuggingContext::New();
  void* frames[256];
  const int size = sym_ctx->GetStackTrace(frames, arraysize(frames));
  writer->json_arraystart(""nativeStack"");
  int i;
  for (i = 1; i < size; i++) {
    void* frame = frames[i];
    writer->json_start();
    writer->json_keyvalue(""pc"",
                          ValueToHexString(reinterpret_cast<uintptr_t>(frame)));
    writer->json_keyvalue(""symbol"", sym_ctx->LookupSymbol(frame).Display());
    writer->json_end();
  }
  writer->json_arrayend();
}",50,,554,2,,void
225417,BLOCK,-1,,<empty>,3,,560,1,,void
225426,BLOCK,4,,"{
    void* frame = frames[i];
    writer->json_start();
    writer->json_keyvalue(""pc"",
                          ValueToHexString(reinterpret_cast<uintptr_t>(frame)));
    writer->json_keyvalue(""symbol"", sym_ctx->LookupSymbol(frame).Display());
    writer->json_end();
  }",30,,560,4,,void
225472,BLOCK,-1,,"{
  HeapStatistics v8_heap_stats;
  isolate->GetHeapStatistics(&v8_heap_stats);
  HeapSpaceStatistics v8_heap_space_stats;

  writer->json_objectstart(""javascriptHeap"");
  writer->json_keyvalue(""totalMemory"", v8_heap_stats.total_heap_size());
  writer->json_keyvalue(""executableMemory"",
                        v8_heap_stats.total_heap_size_executable());
  writer->json_keyvalue(""totalCommittedMemory"",
                        v8_heap_stats.total_physical_size());
  writer->json_keyvalue(""availableMemory"",
                        v8_heap_stats.total_available_size());
  writer->json_keyvalue(""totalGlobalHandlesMemory"",
                        v8_heap_stats.total_global_handles_size());
  writer->json_keyvalue(""usedGlobalHandlesMemory"",
                        v8_heap_stats.used_global_handles_size());
  writer->json_keyvalue(""usedMemory"", v8_heap_stats.used_heap_size());
  writer->json_keyvalue(""memoryLimit"", v8_heap_stats.heap_size_limit());
  writer->json_keyvalue(""mallocedMemory"", v...",69,,575,3,,void
225618,BLOCK,-1,,<empty>,3,,606,1,,void
225631,BLOCK,4,,"{
    isolate->GetHeapSpaceStatistics(&v8_heap_space_stats, i);
    writer->json_objectstart(v8_heap_space_stats.space_name());
    writer->json_keyvalue(""memorySize"", v8_heap_space_stats.space_size());
    writer->json_keyvalue(
        ""committedMemory"",
        v8_heap_space_stats.physical_space_size());
    writer->json_keyvalue(
        ""capacity"",
        v8_heap_space_stats.space_used_size() +
            v8_heap_space_stats.space_available_size());
    writer->json_keyvalue(""used"", v8_heap_space_stats.space_used_size());
    writer->json_keyvalue(
        ""available"", v8_heap_space_stats.space_available_size());
    writer->json_objectend();
  }",62,,606,4,,void
225713,BLOCK,-1,,"{
  // Get process uptime in seconds
  uint64_t uptime =
      (uv_hrtime() - per_process::node_start_time) / (NANOS_PER_SEC);
  if (uptime == 0) uptime = 1;  // avoid division by zero.

  // Process and current thread usage statistics
  uv_rusage_t rusage;
  writer->json_objectstart(""resourceUsage"");

  uint64_t free_memory = uv_get_free_memory();
  uint64_t total_memory = uv_get_total_memory();

  writer->json_keyvalue(""free_memory"", free_memory);
  writer->json_keyvalue(""total_memory"", total_memory);

  size_t rss;
  int err = uv_resident_set_memory(&rss);
  if (!err) {
    writer->json_keyvalue(""rss"", rss);
  }

  uint64_t constrained_memory = uv_get_constrained_memory();
  if (constrained_memory) {
    writer->json_keyvalue(""constrained_memory"", constrained_memory);
  }

  // See GuessMemoryAvailableToTheProcess
  if (!err && constrained_memory && constrained_memory >= rss) {
    uint64_t available_memory = constrained_memory - rss;
    writer->json_keyvalue(""available_memory"",...",52,,627,2,,void
225728,BLOCK,-1,,<empty>,20,,631,2,,void
225768,BLOCK,-1,,"{
    writer->json_keyvalue(""rss"", rss);
  }",13,,645,2,,void
225781,BLOCK,-1,,"{
    writer->json_keyvalue(""constrained_memory"", constrained_memory);
  }",27,,650,2,,void
225797,BLOCK,-1,,"{
    uint64_t available_memory = constrained_memory - rss;
    writer->json_keyvalue(""available_memory"", available_memory);
  }",64,,655,2,,void
225811,BLOCK,-1,,"{
    writer->json_keyvalue(""available_memory"", free_memory);
  }",10,,658,1,,void
225824,BLOCK,-1,,"{
    double user_cpu =
        rusage.ru_utime.tv_sec + SEC_PER_MICROS * rusage.ru_utime.tv_usec;
    double kernel_cpu =
        rusage.ru_stime.tv_sec + SEC_PER_MICROS * rusage.ru_stime.tv_usec;
    writer->json_keyvalue(""userCpuSeconds"", user_cpu);
    writer->json_keyvalue(""kernelCpuSeconds"", kernel_cpu);
    double cpu_abs = user_cpu + kernel_cpu;
    double cpu_percentage = (cpu_abs / uptime) * 100.0;
    double user_cpu_percentage = (user_cpu / uptime) * 100.0;
    double kernel_cpu_percentage = (kernel_cpu / uptime) * 100.0;
    writer->json_keyvalue(""cpuConsumptionPercent"", cpu_percentage);
    writer->json_keyvalue(""userCpuConsumptionPercent"", user_cpu_percentage);
    writer->json_keyvalue(""kernelCpuConsumptionPercent"", kernel_cpu_percentage);
    writer->json_keyvalue(""maxRss"", rusage.ru_maxrss * 1024);
    writer->json_objectstart(""pageFaults"");
    writer->json_keyvalue(""IORequired"", rusage.ru_majflt);
    writer->json_keyvalue(""IONotRequired"", rusage.ru_minflt);
    ...",35,,662,2,,void
225985,BLOCK,-1,,"{
  uv_env_item_t* envitems;
  int envcount;
  int r;

  writer->json_objectstart(""environmentVariables"");

  {
    Mutex::ScopedLock lock(per_process::env_var_mutex);
    r = uv_os_environ(&envitems, &envcount);
  }

  if (r == 0) {
    for (int i = 0; i < envcount; i++)
      writer->json_keyvalue(envitems[i].name, envitems[i].value);

    uv_os_free_environ(envitems, envcount);
  }

  writer->json_objectend();

#ifndef _WIN32
  static struct {
    const char* description;
    int id;
  } rlimit_strings[] = {
    {""core_file_size_blocks"", RLIMIT_CORE},
    {""data_seg_size_kbytes"", RLIMIT_DATA},
    {""file_size_blocks"", RLIMIT_FSIZE},
#if !(defined(_AIX) || defined(__sun))
    {""max_locked_memory_bytes"", RLIMIT_MEMLOCK},
#endif
#ifndef __sun
    {""max_memory_size_kbytes"", RLIMIT_RSS},
#endif
    {""open_files"", RLIMIT_NOFILE},
    {""stack_size_bytes"", RLIMIT_STACK},
    {""cpu_time_seconds"", RLIMIT_CPU},
#ifndef __sun
    {""max_user_processes"", RLIMIT_NPROC},
#endif
#ifndef __OpenBSD...",56,,714,2,,void
225994,BLOCK,5,,"{
    Mutex::ScopedLock lock(per_process::env_var_mutex);
    r = uv_os_environ(&envitems, &envcount);
  }",3,,721,5,,void
226011,BLOCK,-1,,"{
    for (int i = 0; i < envcount; i++)
      writer->json_keyvalue(envitems[i].name, envitems[i].value);

    uv_os_free_environ(envitems, envcount);
  }",15,,726,2,,void
226013,BLOCK,-1,,<empty>,5,,727,1,,void
226087,BLOCK,-1,,<empty>,3,,764,1,,void
226098,BLOCK,4,,"{
    if (getrlimit(rlimit_strings[i].id, &limit) == 0) {
      writer->json_objectstart(rlimit_strings[i].description);

      if (limit.rlim_cur == RLIM_INFINITY)
        writer->json_keyvalue(""soft"", ""unlimited"");
      else
        writer->json_keyvalue(""soft"", limit.rlim_cur);

      if (limit.rlim_max == RLIM_INFINITY)
        writer->json_keyvalue(""hard"", ""unlimited"");
      else
        writer->json_keyvalue(""hard"", limit.rlim_max);

      writer->json_objectend();
    }
  }",58,,764,4,,void
226110,BLOCK,-1,,"{
      writer->json_objectstart(rlimit_strings[i].description);

      if (limit.rlim_cur == RLIM_INFINITY)
        writer->json_keyvalue(""soft"", ""unlimited"");
      else
        writer->json_keyvalue(""soft"", limit.rlim_cur);

      if (limit.rlim_max == RLIM_INFINITY)
        writer->json_keyvalue(""hard"", ""unlimited"");
      else
        writer->json_keyvalue(""hard"", limit.rlim_max);

      writer->json_objectend();
    }",55,,765,2,,void
226126,BLOCK,-1,,<empty>,9,,769,2,,void
226134,BLOCK,-1,,<empty>,9,,771,1,,void
226149,BLOCK,-1,,<empty>,9,,774,2,,void
226157,BLOCK,-1,,<empty>,9,,776,1,,void
226180,BLOCK,-1,,"{
  writer->json_arraystart(""sharedObjects"");
  std::vector<std::string> modules =
      NativeSymbolDebuggingContext::GetLoadedLibraries();
  for (auto const& module_name : modules) writer->json_element(module_name);
  writer->json_arrayend();
}",54,,788,2,,void
226216,BLOCK,-1,,"{
  std::stringstream buf;

  writer->json_objectstart(""componentVersions"");

#define V(key) +1
  std::pair<std::string_view, std::string_view>
      versions_array[NODE_VERSIONS_KEYS(V)];
#undef V
  auto* slot = &versions_array[0];

#define V(key)                                                                 \
  do {                                                                         \
    *slot++ = std::pair<std::string_view, std::string_view>(                   \
        #key, per_process::metadata.versions.key);                             \
  } while (0);
  NODE_VERSIONS_KEYS(V)
#undef V

  std::sort(&versions_array[0],
            &versions_array[arraysize(versions_array)],
            [](auto& a, auto& b) { return a.first < b.first; });

  for (const auto& version : versions_array) {
    writer->json_keyvalue(version.first, version.second);
  }

  writer->json_objectend();
}",56,,797,2,,void
226265,BLOCK,-1,,"{
    writer->json_keyvalue(version.first, version.second);
  }",46,,820,3,,void
226284,BLOCK,-1,,"{
  writer->json_objectstart(""release"");
  writer->json_keyvalue(""name"", per_process::metadata.release.name);
#if NODE_VERSION_IS_LTS
  writer->json_keyvalue(""lts"", per_process::metadata.release.lts);
#endif

#ifdef NODE_HAS_RELEASE_URLS
  writer->json_keyvalue(""headersUrl"",
                        per_process::metadata.release.headers_url);
  writer->json_keyvalue(""sourceUrl"", per_process::metadata.release.source_url);
#ifdef _WIN32
  writer->json_keyvalue(""libUrl"", per_process::metadata.release.lib_url);
#endif  // _WIN32
#endif  // NODE_HAS_RELEASE_URLS

  writer->json_objectend();
}",46,,828,2,,void
226315,BLOCK,-1,,"{
  std::string filename;

  // Determine the required report filename. In order of priority:
  //   1) supplied on API 2) configured on startup 3) default generated
  if (!name.empty()) {
    THROW_IF_INSUFFICIENT_PERMISSIONS(
        env, permission::PermissionScope::kFileSystemWrite, name, name);
    // Filename was specified as API parameter.
    filename = name;
  } else {
    std::string report_filename;
    {
      Mutex::ScopedLock lock(per_process::cli_options_mutex);
      report_filename = per_process::cli_options->report_filename;
    }
    if (report_filename.length() > 0) {
      // File name was supplied via start-up option.
      filename = report_filename;
    } else {
      filename = *DiagnosticFilename(
          env != nullptr ? env->thread_id() : 0, ""report"", ""json"");
    }
    if (env != nullptr) {
      THROW_IF_INSUFFICIENT_PERMISSIONS(
          env,
          permission::PermissionScope::kFileSystemWrite,
          std::string_view(env->GetCwd()),
        ...",51,,854,7,,void
226323,BLOCK,-1,,"{
    THROW_IF_INSUFFICIENT_PERMISSIONS(
        env, permission::PermissionScope::kFileSystemWrite, name, name);
    // Filename was specified as API parameter.
    filename = name;
  }",22,,859,2,,void
226337,BLOCK,-1,,"{
    std::string report_filename;
    {
      Mutex::ScopedLock lock(per_process::cli_options_mutex);
      report_filename = per_process::cli_options->report_filename;
    }
    if (report_filename.length() > 0) {
      // File name was supplied via start-up option.
      filename = report_filename;
    } else {
      filename = *DiagnosticFilename(
          env != nullptr ? env->thread_id() : 0, ""report"", ""json"");
    }
    if (env != nullptr) {
      THROW_IF_INSUFFICIENT_PERMISSIONS(
          env,
          permission::PermissionScope::kFileSystemWrite,
          std::string_view(env->GetCwd()),
          filename);
    }
  }",10,,864,1,,void
226339,BLOCK,2,,"{
      Mutex::ScopedLock lock(per_process::cli_options_mutex);
      report_filename = per_process::cli_options->report_filename;
    }",5,,866,2,,void
226359,BLOCK,-1,,"{
      // File name was supplied via start-up option.
      filename = report_filename;
    }",39,,870,2,,void
226364,BLOCK,-1,,"{
      filename = *DiagnosticFilename(
          env != nullptr ? env->thread_id() : 0, ""report"", ""json"");
    }",12,,873,1,,void
226384,BLOCK,-1,,"{
      THROW_IF_INSUFFICIENT_PERMISSIONS(
          env,
          permission::PermissionScope::kFileSystemWrite,
          std::string_view(env->GetCwd()),
          filename);
    }",25,,877,2,,void
226407,BLOCK,-1,,"{
    outstream = &std::cout;
  }",29,,890,2,,void
226415,BLOCK,-1,,<empty>,10,,892,1,,void
226420,BLOCK,-1,,"{
    outstream = &std::cerr;
  }",36,,892,2,,void
226428,BLOCK,-1,,"{
    std::string report_directory;
    {
      Mutex::ScopedLock lock(per_process::cli_options_mutex);
      report_directory = per_process::cli_options->report_directory;
    }
    // Regular file. Append filename to directory path if one was specified
    if (report_directory.length() > 0) {
      std::string pathname = report_directory;
      pathname += kPathSeparator;
      pathname += filename;
      outfile.open(pathname, std::ios::out | std::ios::binary);
    } else {
      outfile.open(filename, std::ios::out | std::ios::binary);
    }
    // Check for errors on the file open
    if (!outfile.is_open()) {
      std::cerr << ""\nFailed to open Node.js report file: "" << filename;

      if (report_directory.length() > 0)
        std::cerr << "" directory: "" << report_directory;

      std::cerr << "" (errno: "" << errno << "")"" << std::endl;
      return """";
    }
    outstream = &outfile;
    std::cerr << ""\nWriting Node.js report to file: "" << filename;
  }",10,,894,1,,void
226430,BLOCK,2,,"{
      Mutex::ScopedLock lock(per_process::cli_options_mutex);
      report_directory = per_process::cli_options->report_directory;
    }",5,,896,2,,void
226450,BLOCK,-1,,"{
      std::string pathname = report_directory;
      pathname += kPathSeparator;
      pathname += filename;
      outfile.open(pathname, std::ios::out | std::ios::binary);
    }",40,,901,2,,void
226478,BLOCK,-1,,"{
      outfile.open(filename, std::ios::out | std::ios::binary);
    }",12,,906,1,,void
226501,BLOCK,-1,,"{
      std::cerr << ""\nFailed to open Node.js report file: "" << filename;

      if (report_directory.length() > 0)
        std::cerr << "" directory: "" << report_directory;

      std::cerr << "" (errno: "" << errno << "")"" << std::endl;
      return """";
    }",29,,910,2,,void
226516,BLOCK,-1,,<empty>,9,,914,2,,void
226551,BLOCK,7,,"{
    Mutex::ScopedLock lock(per_process::cli_options_mutex);
    compact = per_process::cli_options->report_compact;
  }",3,,924,7,,void
226582,BLOCK,-1,,"{
    outfile.close();
  }",26,,933,2,,void
226591,BLOCK,-1,,"{
    std::cerr << ""\nNode.js report completed"" << std::endl;
  }",29,,938,2,,void
226611,BLOCK,-1,,"{
  Environment* env = nullptr;
  if (isolate != nullptr) {
    env = Environment::GetCurrent(isolate);
  }
  return TriggerNodeReport(isolate, env, message, trigger, name, error);
}",51,,949,6,,void
226620,BLOCK,-1,,"{
    env = Environment::GetCurrent(isolate);
  }",27,,951,2,,void
226644,BLOCK,-1,,"{
  return TriggerNodeReport(env != nullptr ? env->isolate() : nullptr,
                           env,
                           message,
                           trigger,
                           name,
                           error);
}",51,,962,6,,void
226669,BLOCK,-1,,"{
  Environment* env = nullptr;
  if (isolate != nullptr) {
    env = Environment::GetCurrent(isolate);
  }
  report::WriteNodeReport(
      isolate, env, message, trigger, """", out, error, false);
}",39,,976,6,,void
226678,BLOCK,-1,,"{
    env = Environment::GetCurrent(isolate);
  }",27,,978,2,,void
226706,BLOCK,-1,,"{
  Isolate* isolate = nullptr;
  if (env != nullptr) {
    isolate = env->isolate();
  }
  report::WriteNodeReport(
      isolate, env, message, trigger, """", out, error, false);
}",39,,990,6,,void
226715,BLOCK,-1,,"{
    isolate = env->isolate();
  }",23,,992,2,,void
226756,BLOCK,-1,,<empty>,1,,1,1,,ANY
226789,BLOCK,-1,,<empty>,1,,1,1,,ANY
226794,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  Isolate* isolate = env->isolate();
  HandleScope scope(isolate);
  std::string filename;
  Local<Value> error;

  CHECK_EQ(info.Length(), 4);
  String::Utf8Value message(isolate, info[0].As<String>());
  String::Utf8Value trigger(isolate, info[1].As<String>());

  if (info[2]->IsString())
    filename = *String::Utf8Value(isolate, info[2]);
  if (!info[3].IsEmpty())
    error = info[3];
  else
    error = Local<Value>();

  filename = TriggerNodeReport(env, *message, *trigger, filename, error);
  // Return value is the report filename
  info.GetReturnValue().Set(
      String::NewFromUtf8(isolate, filename.c_str()).ToLocalChecked());
}",59,,29,2,,void
226850,BLOCK,-1,,<empty>,5,,41,2,,void
226870,BLOCK,-1,,<empty>,5,,43,2,,void
226877,BLOCK,-1,,<empty>,5,,45,1,,void
226914,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  Isolate* isolate = env->isolate();
  HandleScope scope(isolate);
  Local<Object> error;
  std::ostringstream out;

  CHECK_EQ(info.Length(), 1);
  if (!info[0].IsEmpty() && info[0]->IsObject())
    error = info[0].As<Object>();
  else
    error = Local<Object>();

  GetNodeReport(env, ""JavaScript API"", __func__, error, out);

  // Return value is the contents of a report as a string.
  info.GetReturnValue().Set(
      String::NewFromUtf8(isolate, out.str().c_str()).ToLocalChecked());
}",57,,54,2,,void
226960,BLOCK,-1,,<empty>,5,,63,2,,void
226970,BLOCK,-1,,<empty>,5,,65,1,,void
227006,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  info.GetReturnValue().Set(per_process::cli_options->report_compact);
}",65,,74,2,,void
227028,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Environment* env = Environment::GetCurrent(info);
  Isolate* isolate = env->isolate();
  bool compact = info[0]->ToBoolean(isolate)->Value();
  per_process::cli_options->report_compact = compact;
}",65,,79,2,,void
227073,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Environment* env = Environment::GetCurrent(info);
  std::string directory = per_process::cli_options->report_directory;
  auto result = String::NewFromUtf8(env->isolate(), directory.c_str());
  info.GetReturnValue().Set(result.ToLocalChecked());
}",67,,87,2,,void
227125,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Environment* env = Environment::GetCurrent(info);
  CHECK(info[0]->IsString());
  Utf8Value dir(env->isolate(), info[0].As<String>());
  per_process::cli_options->report_directory = *dir;
}",67,,95,2,,void
227170,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Environment* env = Environment::GetCurrent(info);
  std::string filename = per_process::cli_options->report_filename;
  auto result = String::NewFromUtf8(env->isolate(), filename.c_str());
  info.GetReturnValue().Set(result.ToLocalChecked());
}",66,,103,2,,void
227222,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Environment* env = Environment::GetCurrent(info);
  CHECK(info[0]->IsString());
  Utf8Value name(env->isolate(), info[0].As<String>());
  per_process::cli_options->report_filename = *name;
}",66,,111,2,,void
227267,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  std::string signal = env->isolate_data()->options()->report_signal;
  auto result = String::NewFromUtf8(env->isolate(), signal.c_str());
  info.GetReturnValue().Set(result.ToLocalChecked());
}",64,,119,2,,void
227318,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  CHECK(info[0]->IsString());
  Utf8Value signal(env->isolate(), info[0].As<String>());
  env->isolate_data()->options()->report_signal = *signal;
}",64,,126,2,,void
227362,BLOCK,-1,,"{
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  info.GetReturnValue().Set(per_process::cli_options->report_on_fatalerror);
}",79,,133,2,,void
227384,BLOCK,-1,,"{
  CHECK(info[0]->IsBoolean());
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  per_process::cli_options->report_on_fatalerror = info[0]->IsTrue();
}",76,,138,2,,void
227413,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  info.GetReturnValue().Set(env->isolate_data()->options()->report_on_signal);
}",75,,144,2,,void
227442,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  CHECK(info[0]->IsBoolean());
  env->isolate_data()->options()->report_on_signal = info[0]->IsTrue();
}",72,,149,2,,void
227478,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  info.GetReturnValue().Set(
      env->isolate_data()->options()->report_uncaught_exception);
}",46,,156,2,,void
227507,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  CHECK(info[0]->IsBoolean());
  env->isolate_data()->options()->report_uncaught_exception = info[0]->IsTrue();
}",46,,163,2,,void
227546,BLOCK,-1,,"{
  SetMethod(context, exports, ""writeReport"", WriteReport);
  SetMethod(context, exports, ""getReport"", GetReport);
  SetMethod(context, exports, ""getCompact"", GetCompact);
  SetMethod(context, exports, ""setCompact"", SetCompact);
  SetMethod(context, exports, ""getDirectory"", GetDirectory);
  SetMethod(context, exports, ""setDirectory"", SetDirectory);
  SetMethod(context, exports, ""getFilename"", GetFilename);
  SetMethod(context, exports, ""setFilename"", SetFilename);
  SetMethod(context, exports, ""getSignal"", GetSignal);
  SetMethod(context, exports, ""setSignal"", SetSignal);
  SetMethod(
      context, exports, ""shouldReportOnFatalError"", ShouldReportOnFatalError);
  SetMethod(context, exports, ""setReportOnFatalError"", SetReportOnFatalError);
  SetMethod(context, exports, ""shouldReportOnSignal"", ShouldReportOnSignal);
  SetMethod(context, exports, ""setReportOnSignal"", SetReportOnSignal);
  SetMethod(context,
            exports,
            ""shouldReportOnUncaughtException"",
         ...",36,,172,5,,void
227631,BLOCK,-1,,"{
  registry->Register(WriteReport);
  registry->Register(GetReport);
  registry->Register(GetCompact);
  registry->Register(SetCompact);
  registry->Register(GetDirectory);
  registry->Register(SetDirectory);
  registry->Register(GetFilename);
  registry->Register(SetFilename);
  registry->Register(GetSignal);
  registry->Register(SetSignal);
  registry->Register(ShouldReportOnFatalError);
  registry->Register(SetReportOnFatalError);
  registry->Register(ShouldReportOnSignal);
  registry->Register(SetReportOnSignal);
  registry->Register(ShouldReportOnUncaughtException);
  registry->Register(SetReportOnUncaughtException);
}",70,,198,2,,void
227727,BLOCK,-1,,<empty>,1,,1,1,,ANY
227740,BLOCK,-1,,"{
  if (addr == nullptr) {
    writer->json_keyvalue(name, null);
    return;
  }

  uv_getnameinfo_t endpoint;
  char* host = nullptr;
  char hostbuf[INET6_ADDRSTRLEN];
  const int family = addr->sa_family;
  const int port = ntohs(family == AF_INET ?
                         reinterpret_cast<sockaddr_in*>(addr)->sin_port :
                         reinterpret_cast<sockaddr_in6*>(addr)->sin6_port);

  if (uv_getnameinfo(h->loop, &endpoint, nullptr, addr, NI_NUMERICSERV) == 0) {
    host = endpoint.host;
    DCHECK_EQ(port, std::stoi(endpoint.service));
  } else {
    const void* src = family == AF_INET ?
                      static_cast<void*>(
                        &(reinterpret_cast<sockaddr_in*>(addr)->sin_addr)) :
                      static_cast<void*>(
                        &(reinterpret_cast<sockaddr_in6*>(addr)->sin6_addr));
    if (uv_inet_ntop(family, src, hostbuf, sizeof(hostbuf)) == 0) {
      host = hostbuf;
    }
  }
  writer->json_objectstart(name);
  if (host ...",48,,15,5,,void
227745,BLOCK,-1,,"{
    writer->json_keyvalue(name, null);
    return;
  }",24,,16,2,,void
227795,BLOCK,-1,,"{
    host = endpoint.host;
    DCHECK_EQ(port, std::stoi(endpoint.service));
  }",79,,29,2,,void
227811,BLOCK,-1,,"{
    const void* src = family == AF_INET ?
                      static_cast<void*>(
                        &(reinterpret_cast<sockaddr_in*>(addr)->sin_addr)) :
                      static_cast<void*>(
                        &(reinterpret_cast<sockaddr_in6*>(addr)->sin6_addr));
    if (uv_inet_ntop(family, src, hostbuf, sizeof(hostbuf)) == 0) {
      host = hostbuf;
    }
  }",10,,32,1,,void
227844,BLOCK,-1,,"{
      host = hostbuf;
    }",67,,38,2,,void
227857,BLOCK,-1,,"{
    writer->json_keyvalue(""host"", host);
  }",24,,43,2,,void
227879,BLOCK,-1,,"{
  struct sockaddr_storage addr_storage;
  struct sockaddr* addr = reinterpret_cast<sockaddr*>(&addr_storage);
  uv_any_handle* handle = reinterpret_cast<uv_any_handle*>(h);
  int addr_size = sizeof(addr_storage);
  int rc = -1;

  switch (h->type) {
    case UV_UDP:
      rc = uv_udp_getsockname(&handle->udp, addr, &addr_size);
      break;
    case UV_TCP:
      rc = uv_tcp_getsockname(&handle->tcp, addr, &addr_size);
      break;
    default:
      break;
  }
  ReportEndpoint(h, rc == 0 ? addr : nullptr,  ""localEndpoint"", writer);

  switch (h->type) {
    case UV_UDP:
      rc = uv_udp_getpeername(&handle->udp, addr, &addr_size);
      break;
    case UV_TCP:
      rc = uv_tcp_getpeername(&handle->tcp, addr, &addr_size);
      break;
    default:
      break;
  }
  ReportEndpoint(h, rc == 0 ? addr : nullptr, ""remoteEndpoint"", writer);
}",65,,51,3,,void
227908,BLOCK,-1,,"{
    case UV_UDP:
      rc = uv_udp_getsockname(&handle->udp, addr, &addr_size);
      break;
    case UV_TCP:
      rc = uv_tcp_getsockname(&handle->tcp, addr, &addr_size);
      break;
    default:
      break;
  }",20,,58,2,,void
227951,BLOCK,-1,,"{
    case UV_UDP:
      rc = uv_udp_getpeername(&handle->udp, addr, &addr_size);
      break;
    case UV_TCP:
      rc = uv_tcp_getpeername(&handle->tcp, addr, &addr_size);
      break;
    default:
      break;
  }",20,,70,2,,void
227995,BLOCK,-1,,"{
  uv_any_handle* handle = reinterpret_cast<uv_any_handle*>(h);
  MaybeStackBuffer<char> buffer;
  size_t buffer_size = buffer.capacity();
  int rc = -1;

  // First call to get required buffer size.
  rc = uv_pipe_getsockname(&handle->pipe, buffer.out(), &buffer_size);
  if (rc == UV_ENOBUFS) {
    buffer.AllocateSufficientStorage(buffer_size);
    rc = uv_pipe_getsockname(&handle->pipe, buffer.out(), &buffer_size);
  }
  if (rc == 0 && buffer_size != 0) {
    buffer.SetLength(buffer_size);
    writer->json_keyvalue(""localEndpoint"", buffer.ToStringView());
  } else {
    writer->json_keyvalue(""localEndpoint"", null);
  }

  // First call to get required buffer size.
  buffer_size = buffer.capacity();
  rc = uv_pipe_getpeername(&handle->pipe, buffer.out(), &buffer_size);
  if (rc == UV_ENOBUFS) {
    buffer.AllocateSufficientStorage(buffer_size);
    rc = uv_pipe_getpeername(&handle->pipe, buffer.out(), &buffer_size);
  }
  if (rc == 0 && buffer_size != 0) {
    buffer.SetLength(buf...",69,,84,3,,void
228032,BLOCK,-1,,"{
    buffer.AllocateSufficientStorage(buffer_size);
    rc = uv_pipe_getsockname(&handle->pipe, buffer.out(), &buffer_size);
  }",25,,92,2,,void
228059,BLOCK,-1,,"{
    buffer.SetLength(buffer_size);
    writer->json_keyvalue(""localEndpoint"", buffer.ToStringView());
  }",36,,96,2,,void
228075,BLOCK,-1,,"{
    writer->json_keyvalue(""localEndpoint"", null);
  }",10,,99,1,,void
228105,BLOCK,-1,,"{
    buffer.AllocateSufficientStorage(buffer_size);
    rc = uv_pipe_getpeername(&handle->pipe, buffer.out(), &buffer_size);
  }",25,,106,2,,void
228132,BLOCK,-1,,"{
    buffer.SetLength(buffer_size);
    writer->json_keyvalue(""remoteEndpoint"", buffer.ToStringView());
  }",36,,110,2,,void
228148,BLOCK,-1,,"{
    writer->json_keyvalue(""remoteEndpoint"", null);
  }",10,,113,1,,void
228160,BLOCK,-1,,"{
  MaybeStackBuffer<char> buffer;
  int rc = -1;
  size_t size = buffer.capacity();
  uv_any_handle* handle = reinterpret_cast<uv_any_handle*>(h);
  // First call to get required buffer size.
  switch (h->type) {
    case UV_FS_EVENT:
      rc = uv_fs_event_getpath(&(handle->fs_event), buffer.out(), &size);
      break;
    case UV_FS_POLL:
      rc = uv_fs_poll_getpath(&(handle->fs_poll), buffer.out(), &size);
      break;
    default:
      break;
  }
  if (rc == UV_ENOBUFS) {
    buffer.AllocateSufficientStorage(size);
    switch (h->type) {
      case UV_FS_EVENT:
        rc = uv_fs_event_getpath(&(handle->fs_event), buffer.out(), &size);
        break;
      case UV_FS_POLL:
        rc = uv_fs_poll_getpath(&(handle->fs_poll), buffer.out(), &size);
        break;
      default:
        break;
    }
  }

  if (rc == 0 && size > 0) {
    buffer.SetLength(size);
    writer->json_keyvalue(""filename"", buffer.ToStringView());
  } else {
    writer->json_keyvalue(""filename"", null);
  }
}",60,,119,3,,void
228184,BLOCK,-1,,"{
    case UV_FS_EVENT:
      rc = uv_fs_event_getpath(&(handle->fs_event), buffer.out(), &size);
      break;
    case UV_FS_POLL:
      rc = uv_fs_poll_getpath(&(handle->fs_poll), buffer.out(), &size);
      break;
    default:
      break;
  }",20,,125,2,,void
228223,BLOCK,-1,,"{
    buffer.AllocateSufficientStorage(size);
    switch (h->type) {
      case UV_FS_EVENT:
        rc = uv_fs_event_getpath(&(handle->fs_event), buffer.out(), &size);
        break;
      case UV_FS_POLL:
        rc = uv_fs_poll_getpath(&(handle->fs_poll), buffer.out(), &size);
        break;
      default:
        break;
    }
  }",25,,135,2,,void
228233,BLOCK,-1,,"{
      case UV_FS_EVENT:
        rc = uv_fs_event_getpath(&(handle->fs_event), buffer.out(), &size);
        break;
      case UV_FS_POLL:
        rc = uv_fs_poll_getpath(&(handle->fs_poll), buffer.out(), &size);
        break;
      default:
        break;
    }",22,,137,2,,void
228276,BLOCK,-1,,"{
    buffer.SetLength(size);
    writer->json_keyvalue(""filename"", buffer.ToStringView());
  }",28,,149,2,,void
228292,BLOCK,-1,,"{
    writer->json_keyvalue(""filename"", null);
  }",10,,152,1,,void
228304,BLOCK,-1,,"{
  const char* type = uv_handle_type_name(h->type);
  JSONWriter* writer = static_cast<JSONWriter*>(arg);
  uv_any_handle* handle = reinterpret_cast<uv_any_handle*>(h);

  writer->json_start();
  writer->json_keyvalue(""type"", type);
  writer->json_keyvalue(""is_active"", static_cast<bool>(uv_is_active(h)));
  writer->json_keyvalue(""is_referenced"", static_cast<bool>(uv_has_ref(h)));
  writer->json_keyvalue(""address"",
                        ValueToHexString(reinterpret_cast<uint64_t>(h)));

  switch (h->type) {
    case UV_FS_EVENT:
    case UV_FS_POLL:
      ReportPath(h, writer);
      break;
    case UV_PROCESS:
      writer->json_keyvalue(""pid"", handle->process.pid);
      break;
    case UV_TCP:
    case UV_UDP:
      ReportEndpoints(h, writer);
      break;
    case UV_NAMED_PIPE:
      ReportPipeEndpoints(h, writer);
      break;
    case UV_TIMER: {
      uint64_t due = handle->timer.timeout;
      uint64_t now = uv_now(handle->timer.loop);
      writer->json_keyvalue(""repeat""...",44,,158,3,,void
228365,BLOCK,-1,,"{
    case UV_FS_EVENT:
    case UV_FS_POLL:
      ReportPath(h, writer);
      break;
    case UV_PROCESS:
      writer->json_keyvalue(""pid"", handle->process.pid);
      break;
    case UV_TCP:
    case UV_UDP:
      ReportEndpoints(h, writer);
      break;
    case UV_NAMED_PIPE:
      ReportPipeEndpoints(h, writer);
      break;
    case UV_TIMER: {
      uint64_t due = handle->timer.timeout;
      uint64_t now = uv_now(handle->timer.loop);
      writer->json_keyvalue(""repeat"", uv_timer_get_repeat(&handle->timer));
      writer->json_keyvalue(""firesInMsFromNow"",
                            static_cast<int64_t>(due - now));
      writer->json_keyvalue(""expired"", now >= due);
      break;
    }
    case UV_TTY: {
      int height, width, rc;
      rc = uv_tty_get_winsize(&(handle->tty), &width, &height);
      if (rc == 0) {
        writer->json_keyvalue(""width"", width);
        writer->json_keyvalue(""height"", height);
      }
      break;
    }
    case UV_SIGNAL:
      // SIGWINC...",20,,170,2,,void
228403,BLOCK,23,,"{
      uint64_t due = handle->timer.timeout;
      uint64_t now = uv_now(handle->timer.loop);
      writer->json_keyvalue(""repeat"", uv_timer_get_repeat(&handle->timer));
      writer->json_keyvalue(""firesInMsFromNow"",
                            static_cast<int64_t>(due - now));
      writer->json_keyvalue(""expired"", now >= due);
      break;
    }",20,,185,23,,void
228452,BLOCK,26,,"{
      int height, width, rc;
      rc = uv_tty_get_winsize(&(handle->tty), &width, &height);
      if (rc == 0) {
        writer->json_keyvalue(""width"", width);
        writer->json_keyvalue(""height"", height);
      }
      break;
    }",18,,194,26,,void
228471,BLOCK,-1,,"{
        writer->json_keyvalue(""width"", width);
        writer->json_keyvalue(""height"", height);
      }",20,,197,2,,void
228529,BLOCK,-1,,"{
    // These *must* be 0 or libuv will set the buffer sizes to the non-zero
    // values they contain.
    int send_size = 0;
    int recv_size = 0;
    uv_send_buffer_size(h, &send_size);
    uv_recv_buffer_size(h, &recv_size);
    writer->json_keyvalue(""sendBufferSize"", send_size);
    writer->json_keyvalue(""recvBufferSize"", recv_size);
  }",5,,217,2,,void
228588,BLOCK,-1,,"{
    uv_os_fd_t fd_v;
    int rc = uv_fileno(h, &fd_v);

    if (rc == 0) {
      writer->json_keyvalue(""fd"", static_cast<int>(fd_v));
      switch (fd_v) {
        case STDIN_FILENO:
          writer->json_keyvalue(""stdio"", ""stdin"");
          break;
        case STDOUT_FILENO:
          writer->json_keyvalue(""stdio"", ""stdout"");
          break;
        case STDERR_FILENO:
          writer->json_keyvalue(""stdio"", ""stderr"");
          break;
        default:
          break;
      }
    }
  }",48,,230,2,,void
228601,BLOCK,-1,,"{
      writer->json_keyvalue(""fd"", static_cast<int>(fd_v));
      switch (fd_v) {
        case STDIN_FILENO:
          writer->json_keyvalue(""stdio"", ""stdin"");
          break;
        case STDOUT_FILENO:
          writer->json_keyvalue(""stdio"", ""stdout"");
          break;
        case STDERR_FILENO:
          writer->json_keyvalue(""stdio"", ""stderr"");
          break;
        default:
          break;
      }
    }",18,,234,2,,void
228612,BLOCK,-1,,"{
        case STDIN_FILENO:
          writer->json_keyvalue(""stdio"", ""stdin"");
          break;
        case STDOUT_FILENO:
          writer->json_keyvalue(""stdio"", ""stdout"");
          break;
        case STDERR_FILENO:
          writer->json_keyvalue(""stdio"", ""stderr"");
          break;
        default:
          break;
      }",21,,236,2,,void
228660,BLOCK,-1,,"{
    writer->json_keyvalue(""writeQueueSize"", handle->stream.write_queue_size);
    writer->json_keyvalue(""readable"",
                          static_cast<bool>(uv_is_readable(&handle->stream)));
    writer->json_keyvalue(""writable"",
                          static_cast<bool>(uv_is_writable(&handle->stream)));
  }",75,,253,2,,void
228701,BLOCK,-1,,"{
    writer->json_keyvalue(
        ""writeQueueSize"",
        uv_udp_get_send_queue_size(reinterpret_cast<uv_udp_t*>(h)));
    writer->json_keyvalue(
        ""writeQueueCount"",
        uv_udp_get_send_queue_count(reinterpret_cast<uv_udp_t*>(h)));
  }",26,,260,2,,void
228732,BLOCK,-1,,<empty>,1,,1,1,,ANY
228737,BLOCK,-1,,<empty>,1,,1,1,,ANY
228740,BLOCK,-1,,"{
    size_t size;
#ifdef __APPLE__
    postject_options options;
    postject_options_init(&options);
    options.macho_segment_name = ""NODE_SEA"";
    const char* blob = static_cast<const char*>(
        postject_find_resource(""NODE_SEA_BLOB"", &size, &options));
#else
    const char* blob = static_cast<const char*>(
        postject_find_resource(""NODE_SEA_BLOB"", &size, nullptr));
#endif
    return {blob, size};
  }",67,,113,1,,void
228758,BLOCK,-1,,"{
    std::string_view blob = FindSingleExecutableBlob();
    per_process::Debug(DebugCategory::SEA,
                       ""Found SEA resource %p, size=%zu\n"",
                       blob.data(),
                       blob.size());
    SeaDeserializer deserializer(blob);
    return deserializer.Read<SeaResource>();
  }",63,,137,1,,void
228818,BLOCK,-1,,<empty>,1,,1,1,,ANY
228825,BLOCK,-1,,"{
  return static_cast<SeaFlags>(static_cast<uint32_t>(x) |
                               static_cast<uint32_t>(y));
}",44,,39,3,,void
228841,BLOCK,-1,,"{
  return static_cast<SeaFlags>(static_cast<uint32_t>(x) &
                               static_cast<uint32_t>(y));
}",44,,44,3,,void
228857,BLOCK,-1,,"{
  return x = x | y;
}",80,,49,3,,void
228868,BLOCK,-1,,<empty>,74,,57,1,,void
228873,BLOCK,-1,,<empty>,,,,2,,<empty>
228878,BLOCK,-1,,"{
  sink.reserve(SeaResource::kHeaderSize + sea.code.size());

  Debug(""Write SEA magic %x\n"", kMagic);
  size_t written_total = WriteArithmetic<uint32_t>(kMagic);

  uint32_t flags = static_cast<uint32_t>(sea.flags);
  Debug(""Write SEA flags %x\n"", flags);
  written_total += WriteArithmetic<uint32_t>(flags);
  DCHECK_EQ(written_total, SeaResource::kHeaderSize);

  Debug(""Write SEA resource code %p, size=%zu\n"",
        sea.code.data(),
        sea.code.size());
  written_total += WriteStringView(sea.code, StringLogMode::kAddressAndContent);
  return written_total;
}",53,,66,2,,void
228957,BLOCK,-1,,<empty>,77,,88,2,,void
228961,BLOCK,-1,,<empty>,,,,1,,<empty>
228965,BLOCK,-1,,"{
  uint32_t magic = ReadArithmetic<uint32_t>();
  Debug(""Read SEA magic %x\n"", magic);

  CHECK_EQ(magic, kMagic);
  SeaFlags flags(static_cast<SeaFlags>(ReadArithmetic<uint32_t>()));
  Debug(""Read SEA flags %x\n"", static_cast<uint32_t>(flags));
  CHECK_EQ(read_total, SeaResource::kHeaderSize);

  std::string_view code = ReadStringView(StringLogMode::kAddressAndContent);
  Debug(""Read SEA resource code %p, size=%zu\n"", code.data(), code.size());
  return {flags, code};
}",37,,97,1,,void
229012,BLOCK,-1,,"{
  CHECK(IsSingleExecutable());
  static const std::string_view result = []() -> std::string_view {
    size_t size;
#ifdef __APPLE__
    postject_options options;
    postject_options_init(&options);
    options.macho_segment_name = ""NODE_SEA"";
    const char* blob = static_cast<const char*>(
        postject_find_resource(""NODE_SEA_BLOB"", &size, &options));
#else
    const char* blob = static_cast<const char*>(
        postject_find_resource(""NODE_SEA_BLOB"", &size, nullptr));
#endif
    return {blob, size};
  }();
  per_process::Debug(DebugCategory::SEA,
                     ""Found SEA blob %p, size=%zu\n"",
                     result.data(),
                     result.size());
  return result;
}",45,,111,1,,void
229040,BLOCK,-1,,"{
  static const SeaResource sea_resource = []() -> SeaResource {
    std::string_view blob = FindSingleExecutableBlob();
    per_process::Debug(DebugCategory::SEA,
                       ""Found SEA resource %p, size=%zu\n"",
                       blob.data(),
                       blob.size());
    SeaDeserializer deserializer(blob);
    return deserializer.Read<SeaResource>();
  }();
  return sea_resource;
}",44,,136,1,,void
229051,BLOCK,-1,,"{
  return postject_has_resource();
}",27,,149,1,,void
229058,BLOCK,-1,,"{
  if (!IsSingleExecutable()) {
    args.GetReturnValue().Set(false);
    return;
  }

  SeaResource sea_resource = FindSingleExecutableResource();
  args.GetReturnValue().Set(!static_cast<bool>(
      sea_resource.flags & SeaFlags::kDisableExperimentalSeaWarning));
}",78,,153,2,,void
229062,BLOCK,-1,,"{
    args.GetReturnValue().Set(false);
    return;
  }",30,,154,2,,void
229098,BLOCK,-1,,"{
  // Repeats argv[0] at position 1 on argv as a replacement for the missing
  // entry point file path.
  if (IsSingleExecutable()) {
    static std::vector<char*> new_argv;
    new_argv.reserve(argc + 2);
    new_argv.emplace_back(argv[0]);
    new_argv.insert(new_argv.end(), argv, argv + argc);
    new_argv.emplace_back(nullptr);
    argc = new_argv.size() - 1;
    argv = new_argv.data();
  }

  return {argc, argv};
}",64,,164,3,,void
229101,BLOCK,-1,,"{
    static std::vector<char*> new_argv;
    new_argv.reserve(argc + 2);
    new_argv.emplace_back(argv[0]);
    new_argv.insert(new_argv.end(), argv, argv + argc);
    new_argv.emplace_back(nullptr);
    argc = new_argv.size() - 1;
    argv = new_argv.data();
  }",29,,167,2,,void
229157,BLOCK,-1,,<empty>,,,,1,,<empty>
229167,BLOCK,-1,,"{
  std::string config;
  int r = ReadFileSync(&config, config_path.c_str());
  if (r != 0) {
    const char* err = uv_strerror(r);
    FPrintF(stderr,
            ""Cannot read single executable configuration from %s: %s\n"",
            config_path,
            err);
    return std::nullopt;
  }

  SeaConfig result;
  JSONParser parser;
  if (!parser.Parse(config)) {
    FPrintF(stderr, ""Cannot parse JSON from %s\n"", config_path);
    return std::nullopt;
  }

  result.main_path =
      parser.GetTopLevelStringField(""main"").value_or(std::string());
  if (result.main_path.empty()) {
    FPrintF(stderr,
            ""\""main\"" field of %s is not a non-empty string\n"",
            config_path);
    return std::nullopt;
  }

  result.output_path =
      parser.GetTopLevelStringField(""output"").value_or(std::string());
  if (result.output_path.empty()) {
    FPrintF(stderr,
            ""\""output\"" field of %s is not a non-empty string\n"",
            config_path);
    return std::nullopt;
 ...",37,,189,2,,void
229183,BLOCK,-1,,"{
    const char* err = uv_strerror(r);
    FPrintF(stderr,
            ""Cannot read single executable configuration from %s: %s\n"",
            config_path,
            err);
    return std::nullopt;
  }",15,,192,2,,void
229207,BLOCK,-1,,"{
    FPrintF(stderr, ""Cannot parse JSON from %s\n"", config_path);
    return std::nullopt;
  }",30,,203,2,,void
229239,BLOCK,-1,,"{
    FPrintF(stderr,
            ""\""main\"" field of %s is not a non-empty string\n"",
            config_path);
    return std::nullopt;
  }",33,,210,2,,void
229271,BLOCK,-1,,"{
    FPrintF(stderr,
            ""\""output\"" field of %s is not a non-empty string\n"",
            config_path);
    return std::nullopt;
  }",35,,219,2,,void
229294,BLOCK,-1,,"{
    FPrintF(stderr,
            ""\""disableExperimentalSEAWarning\"" field of %s is not a Boolean\n"",
            config_path);
    return std::nullopt;
  }",54,,228,2,,void
229308,BLOCK,-1,,"{
    result.flags |= SeaFlags::kDisableExperimentalSeaWarning;
  }",49,,234,2,,void
229322,BLOCK,-1,,"{
  std::string main_script;
  // TODO(joyeecheung): unify the file utils.
  int r = ReadFileSync(&main_script, config.main_path.c_str());
  if (r != 0) {
    const char* err = uv_strerror(r);
    FPrintF(stderr, ""Cannot read main script %s:%s\n"", config.main_path, err);
    return ExitCode::kGenericUserError;
  }

  SeaResource sea{config.flags, main_script};

  SeaSerializer serializer;
  serializer.Write(sea);

  uv_buf_t buf = uv_buf_init(serializer.sink.data(), serializer.sink.size());
  r = WriteFileSync(config.output_path.c_str(), buf);
  if (r != 0) {
    const char* err = uv_strerror(r);
    FPrintF(stderr, ""Cannot write output to %s:%s\n"", config.output_path, err);
    return ExitCode::kGenericUserError;
  }

  FPrintF(stderr,
          ""Wrote single executable preparation blob to %s\n"",
          config.output_path);
  return ExitCode::kNoFailure;
}",64,,241,2,,void
229340,BLOCK,-1,,"{
    const char* err = uv_strerror(r);
    FPrintF(stderr, ""Cannot read main script %s:%s\n"", config.main_path, err);
    return ExitCode::kGenericUserError;
  }",15,,245,2,,void
229401,BLOCK,-1,,"{
    const char* err = uv_strerror(r);
    FPrintF(stderr, ""Cannot write output to %s:%s\n"", config.output_path, err);
    return ExitCode::kGenericUserError;
  }",15,,258,2,,void
229432,BLOCK,-1,,"{
  std::optional<SeaConfig> config_opt =
      ParseSingleExecutableConfig(config_path);
  if (config_opt.has_value()) {
    ExitCode code = GenerateSingleExecutableBlob(config_opt.value());
    return code;
  }

  return ExitCode::kGenericUserError;
}",68,,272,2,,void
229443,BLOCK,-1,,"{
    ExitCode code = GenerateSingleExecutableBlob(config_opt.value());
    return code;
  }",31,,275,2,,void
229465,BLOCK,-1,,"{
  SetMethod(context,
            target,
            ""isExperimentalSeaWarningNeeded"",
            IsExperimentalSeaWarningNeeded);
}",29,,286,5,,void
229475,BLOCK,-1,,"{
  registry->Register(IsExperimentalSeaWarningNeeded);
}",70,,293,2,,void
229496,BLOCK,-1,,<empty>,1,,1,1,,ANY
229513,BLOCK,-1,,<empty>,1,,1,1,,ANY
229520,BLOCK,-1,,<empty>,,,,3,,<empty>
229524,BLOCK,-1,,<empty>,,,,1,,<empty>
229529,BLOCK,-1,,<empty>,,,,2,,<empty>
229535,BLOCK,-1,,<empty>,,,,3,,<empty>
229541,BLOCK,-1,,<empty>,,,,3,,<empty>
229546,BLOCK,-1,,<empty>,,,,2,,<empty>
229551,BLOCK,-1,,<empty>,,,,2,,<empty>
229556,BLOCK,-1,,<empty>,,,,2,,<empty>
229561,BLOCK,-1,,<empty>,,,,2,,<empty>
229566,BLOCK,-1,,<empty>,,,,2,,<empty>
229571,BLOCK,-1,,<empty>,,,,2,,<empty>
229576,BLOCK,-1,,<empty>,,,,2,,<empty>
229581,BLOCK,-1,,<empty>,,,,2,,<empty>
229586,BLOCK,-1,,<empty>,,,,2,,<empty>
229591,BLOCK,-1,,<empty>,,,,2,,<empty>
229600,BLOCK,-1,,<empty>,,,,4,,<empty>
229604,BLOCK,-1,,<empty>,,,,1,,<empty>
229609,BLOCK,-1,,<empty>,,,,2,,<empty>
229614,BLOCK,-1,,<empty>,,,,2,,<empty>
229619,BLOCK,-1,,<empty>,,,,2,,<empty>
229624,BLOCK,-1,,<empty>,,,,2,,<empty>
229629,BLOCK,-1,,<empty>,,,,2,,<empty>
229634,BLOCK,-1,,<empty>,,,,2,,<empty>
229639,BLOCK,-1,,<empty>,,,,2,,<empty>
229644,BLOCK,-1,,<empty>,,,,2,,<empty>
229649,BLOCK,-1,,<empty>,,,,2,,<empty>
229654,BLOCK,-1,,<empty>,,,,2,,<empty>
229663,BLOCK,-1,,"{
  MakeWeak();
}",39,,100,3,,void
229669,BLOCK,-1,,"{
  Local<Value> args[1] = { message };
  Local<Value> get_data_clone_error =
      object()->Get(env()->context(),
                    env()->get_data_clone_error_string())
                      .ToLocalChecked();

  CHECK(get_data_clone_error->IsFunction());
  MaybeLocal<Value> error =
      get_data_clone_error.As<Function>()->Call(env()->context(),
                                                object(),
                                                arraysize(args),
                                                args);

  if (error.IsEmpty()) return;

  env()->isolate()->ThrowException(error.ToLocalChecked());
}",68,,104,2,,void
229730,BLOCK,-1,,<empty>,24,,118,2,,void
229748,BLOCK,-1,,"{
  Local<Value> args[1] = { shared_array_buffer };
  Local<Value> get_shared_array_buffer_id =
      object()->Get(env()->context(),
                    env()->get_shared_array_buffer_id_string())
                      .ToLocalChecked();

  if (!get_shared_array_buffer_id->IsFunction()) {
    return ValueSerializer::Delegate::GetSharedArrayBufferId(
        isolate, shared_array_buffer);
  }

  MaybeLocal<Value> id =
      get_shared_array_buffer_id.As<Function>()->Call(env()->context(),
                                                      object(),
                                                      arraysize(args),
                                                      args);

  if (id.IsEmpty()) return Nothing<uint32_t>();

  return id.ToLocalChecked()->Uint32Value(env()->context());
}",69,,124,3,,void
229784,BLOCK,-1,,"{
    return ValueSerializer::Delegate::GetSharedArrayBufferId(
        isolate, shared_array_buffer);
  }",50,,131,2,,void
229820,BLOCK,-1,,<empty>,21,,142,2,,void
229840,BLOCK,-1,,"{
  MaybeLocal<Value> ret;
  Local<Value> args[1] = { input };

  Local<Value> write_host_object =
      object()->Get(env()->context(),
                    env()->write_host_object_string()).ToLocalChecked();

  if (!write_host_object->IsFunction()) {
    return ValueSerializer::Delegate::WriteHostObject(isolate, input);
  }

  ret = write_host_object.As<Function>()->Call(env()->context(),
                                               object(),
                                               arraysize(args),
                                               args);

  if (ret.IsEmpty())
    return Nothing<bool>();

  return Just(true);
}",69,,148,3,,void
229881,BLOCK,-1,,"{
    return ValueSerializer::Delegate::WriteHostObject(isolate, input);
  }",41,,156,2,,void
229913,BLOCK,-1,,<empty>,5,,166,2,,void
229923,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  if (!args.IsConstructCall()) {
    return THROW_ERR_CONSTRUCT_CALL_REQUIRED(
        env, ""Class constructor Serializer cannot be invoked without 'new'"");
  }

  new SerializerContext(env, args.This());
}",70,,171,2,,void
229938,BLOCK,-1,,"{
    return THROW_ERR_CONSTRUCT_CALL_REQUIRED(
        env, ""Class constructor Serializer cannot be invoked without 'new'"");
  }",32,,173,2,,void
229954,BLOCK,-1,,"{
  SerializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());
  ctx->serializer_.WriteHeader();
}",78,,181,2,,void
229973,BLOCK,-1,,"{
  SerializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());
  Maybe<bool> ret =
      ctx->serializer_.WriteValue(ctx->env()->context(), args[0]);

  if (ret.IsJust()) args.GetReturnValue().Set(ret.FromJust());
}",77,,187,2,,void
230006,BLOCK,-1,,<empty>,21,,193,2,,void
230022,BLOCK,-1,,"{
  SerializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  bool value = args[0]->BooleanValue(ctx->env()->isolate());
  ctx->serializer_.SetTreatArrayBufferViewsAsHostObjects(value);
}",46,,197,2,,void
230058,BLOCK,-1,,"{
  SerializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  // Note: Both ValueSerializer and this Buffer::New() variant use malloc()
  // as the underlying allocator.
  std::pair<uint8_t*, size_t> ret = ctx->serializer_.Release();
  auto buf = Buffer::New(ctx->env(),
                         reinterpret_cast<char*>(ret.first),
                         ret.second);

  if (!buf.IsEmpty()) {
    args.GetReturnValue().Set(buf.ToLocalChecked());
  }
}",80,,205,2,,void
230101,BLOCK,-1,,"{
    args.GetReturnValue().Set(buf.ToLocalChecked());
  }",23,,216,2,,void
230117,BLOCK,-1,,"{
  SerializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  Maybe<uint32_t> id = args[0]->Uint32Value(ctx->env()->context());
  if (id.IsNothing()) return;

  if (!args[1]->IsArrayBuffer())
    return node::THROW_ERR_INVALID_ARG_TYPE(
        ctx->env(), ""arrayBuffer must be an ArrayBuffer"");

  Local<ArrayBuffer> ab = args[1].As<ArrayBuffer>();
  ctx->serializer_.TransferArrayBuffer(id.FromJust(), ab);
  return;
}",46,,222,2,,void
230150,BLOCK,-1,,<empty>,23,,227,2,,void
230160,BLOCK,-1,,<empty>,5,,230,2,,void
230199,BLOCK,-1,,"{
  SerializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  Maybe<uint32_t> value = args[0]->Uint32Value(ctx->env()->context());
  if (value.IsNothing()) return;

  ctx->serializer_.WriteUint32(value.FromJust());
}",78,,238,2,,void
230232,BLOCK,-1,,<empty>,26,,243,2,,void
230248,BLOCK,-1,,"{
  SerializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  Maybe<uint32_t> arg0 = args[0]->Uint32Value(ctx->env()->context());
  Maybe<uint32_t> arg1 = args[1]->Uint32Value(ctx->env()->context());
  if (arg0.IsNothing() || arg1.IsNothing())
    return;

  uint64_t hi = arg0.FromJust();
  uint64_t lo = arg1.FromJust();
  ctx->serializer_.WriteUint64((hi << 32) | lo);
}",78,,248,2,,void
230305,BLOCK,-1,,<empty>,5,,255,2,,void
230336,BLOCK,-1,,"{
  SerializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  Maybe<double> value = args[0]->NumberValue(ctx->env()->context());
  if (value.IsNothing()) return;

  ctx->serializer_.WriteDouble(value.FromJust());
}",78,,262,2,,void
230366,BLOCK,-1,,<empty>,26,,267,2,,void
230382,BLOCK,-1,,"{
  SerializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  if (!args[0]->IsArrayBufferView()) {
    return node::THROW_ERR_INVALID_ARG_TYPE(
        ctx->env(), ""source must be a TypedArray or a DataView"");
  }

  ArrayBufferViewContents<char> bytes(args[0]);
  ctx->serializer_.WriteRawBytes(bytes.data(), bytes.length());
}",80,,272,2,,void
230399,BLOCK,-1,,"{
    return node::THROW_ERR_INVALID_ARG_TYPE(
        ctx->env(), ""source must be a TypedArray or a DataView"");
  }",38,,276,2,,void
230435,BLOCK,-1,,"{
  object()->Set(env->context(), env->buffer_string(), buffer).Check();

  MakeWeak();
}",57,,291,4,,void
230457,BLOCK,-1,,"{
  Local<Value> read_host_object =
      object()->Get(env()->context(),
                    env()->read_host_object_string()).ToLocalChecked();

  if (!read_host_object->IsFunction()) {
    return ValueDeserializer::Delegate::ReadHostObject(isolate);
  }

  Isolate::AllowJavascriptExecutionScope allow_js(isolate);
  MaybeLocal<Value> ret =
      read_host_object.As<Function>()->Call(env()->context(),
                                            object(),
                                            0,
                                            nullptr);

  if (ret.IsEmpty())
    return MaybeLocal<Object>();

  Local<Value> return_value = ret.ToLocalChecked();
  if (!return_value->IsObject()) {
    env()->ThrowTypeError(""readHostObject must return an object"");
    return MaybeLocal<Object>();
  }

  return return_value.As<Object>();
}",74,,297,2,,void
230485,BLOCK,-1,,"{
    return ValueDeserializer::Delegate::ReadHostObject(isolate);
  }",40,,302,2,,void
230522,BLOCK,-1,,<empty>,5,,314,2,,void
230541,BLOCK,-1,,"{
    env()->ThrowTypeError(""readHostObject must return an object"");
    return MaybeLocal<Object>();
  }",34,,317,2,,void
230558,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  if (!args.IsConstructCall()) {
    return THROW_ERR_CONSTRUCT_CALL_REQUIRED(
        env, ""Class constructor Deserializer cannot be invoked without 'new'"");
  }

  if (!args[0]->IsArrayBufferView()) {
    return node::THROW_ERR_INVALID_ARG_TYPE(
        env, ""buffer must be a TypedArray or a DataView"");
  }

  new DeserializerContext(env, args.This(), args[0]);
}",72,,325,2,,void
230573,BLOCK,-1,,"{
    return THROW_ERR_CONSTRUCT_CALL_REQUIRED(
        env, ""Class constructor Deserializer cannot be invoked without 'new'"");
  }",32,,327,2,,void
230586,BLOCK,-1,,"{
    return node::THROW_ERR_INVALID_ARG_TYPE(
        env, ""buffer must be a TypedArray or a DataView"");
  }",38,,332,2,,void
230608,BLOCK,-1,,"{
  DeserializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  Maybe<bool> ret = ctx->deserializer_.ReadHeader(ctx->env()->context());

  if (ret.IsJust()) args.GetReturnValue().Set(ret.FromJust());
}",79,,340,2,,void
230638,BLOCK,-1,,<empty>,21,,346,2,,void
230654,BLOCK,-1,,"{
  DeserializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  MaybeLocal<Value> ret = ctx->deserializer_.ReadValue(ctx->env()->context());

  if (!ret.IsEmpty()) args.GetReturnValue().Set(ret.ToLocalChecked());
}",78,,349,2,,void
230688,BLOCK,-1,,<empty>,23,,355,2,,void
230704,BLOCK,-1,,"{
  DeserializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  Maybe<uint32_t> id = args[0]->Uint32Value(ctx->env()->context());
  if (id.IsNothing()) return;

  if (args[1]->IsArrayBuffer()) {
    Local<ArrayBuffer> ab = args[1].As<ArrayBuffer>();
    ctx->deserializer_.TransferArrayBuffer(id.FromJust(), ab);
    return;
  }

  if (args[1]->IsSharedArrayBuffer()) {
    Local<SharedArrayBuffer> sab = args[1].As<SharedArrayBuffer>();
    ctx->deserializer_.TransferSharedArrayBuffer(id.FromJust(), sab);
    return;
  }

  return node::THROW_ERR_INVALID_ARG_TYPE(
      ctx->env(), ""arrayBuffer must be an ArrayBuffer or SharedArrayBuffer"");
}",46,,359,2,,void
230737,BLOCK,-1,,<empty>,23,,364,2,,void
230746,BLOCK,-1,,"{
    Local<ArrayBuffer> ab = args[1].As<ArrayBuffer>();
    ctx->deserializer_.TransferArrayBuffer(id.FromJust(), ab);
    return;
  }",33,,366,2,,void
230778,BLOCK,-1,,"{
    Local<SharedArrayBuffer> sab = args[1].As<SharedArrayBuffer>();
    ctx->deserializer_.TransferSharedArrayBuffer(id.FromJust(), sab);
    return;
  }",39,,372,2,,void
230817,BLOCK,-1,,"{
  DeserializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  args.GetReturnValue().Set(ctx->deserializer_.GetWireFormatVersion());
}",46,,383,2,,void
230843,BLOCK,-1,,"{
  DeserializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  uint32_t value;
  bool ok = ctx->deserializer_.ReadUint32(&value);
  if (!ok) return ctx->env()->ThrowError(""ReadUint32() failed"");
  return args.GetReturnValue().Set(value);
}",79,,390,2,,void
230867,BLOCK,-1,,<empty>,12,,396,2,,void
230890,BLOCK,-1,,"{
  DeserializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  uint64_t value;
  bool ok = ctx->deserializer_.ReadUint64(&value);
  if (!ok) return ctx->env()->ThrowError(""ReadUint64() failed"");

  uint32_t hi = static_cast<uint32_t>(value >> 32);
  uint32_t lo = static_cast<uint32_t>(value);

  Isolate* isolate = ctx->env()->isolate();

  Local<Value> ret[] = {
    Integer::NewFromUnsigned(isolate, hi),
    Integer::NewFromUnsigned(isolate, lo)
  };
  return args.GetReturnValue().Set(Array::New(isolate, ret, arraysize(ret)));
}",79,,400,2,,void
230914,BLOCK,-1,,<empty>,12,,406,2,,void
230984,BLOCK,-1,,"{
  DeserializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  double value;
  bool ok = ctx->deserializer_.ReadDouble(&value);
  if (!ok) return ctx->env()->ThrowError(""ReadDouble() failed"");
  return args.GetReturnValue().Set(value);
}",79,,420,2,,void
231008,BLOCK,-1,,<empty>,12,,426,2,,void
231031,BLOCK,-1,,"{
  DeserializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  Maybe<int64_t> length_arg = args[0]->IntegerValue(ctx->env()->context());
  if (length_arg.IsNothing()) return;
  size_t length = length_arg.FromJust();

  const void* data;
  bool ok = ctx->deserializer_.ReadRawBytes(length, &data);
  if (!ok) return ctx->env()->ThrowError(""ReadRawBytes() failed"");

  const uint8_t* position = reinterpret_cast<const uint8_t*>(data);
  CHECK_GE(position, ctx->data_);
  CHECK_LE(position + length, ctx->data_ + ctx->length_);

  const uint32_t offset = static_cast<uint32_t>(position - ctx->data_);
  CHECK_EQ(ctx->data_ + offset, position);

  args.GetReturnValue().Set(offset);
}",46,,431,2,,void
231064,BLOCK,-1,,<empty>,31,,436,2,,void
231089,BLOCK,-1,,<empty>,12,,441,2,,void
231153,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> ser =
      NewFunctionTemplate(isolate, SerializerContext::New);

  ser->InstanceTemplate()->SetInternalFieldCount(
      SerializerContext::kInternalFieldCount);

  SetProtoMethod(isolate, ser, ""writeHeader"", SerializerContext::WriteHeader);
  SetProtoMethod(isolate, ser, ""writeValue"", SerializerContext::WriteValue);
  SetProtoMethod(
      isolate, ser, ""releaseBuffer"", SerializerContext::ReleaseBuffer);
  SetProtoMethod(isolate,
                 ser,
                 ""transferArrayBuffer"",
                 SerializerContext::TransferArrayBuffer);
  SetProtoMethod(isolate, ser, ""writeUint32"", SerializerContext::WriteUint32);
  SetProtoMethod(isolate, ser, ""writeUint64"", SerializerContext::WriteUint64);
  SetProtoMethod(isolate, ser, ""writeDouble"", SerializerContext::WriteDouble);
  SetProtoMethod(
      isolate, ser, ""writeRawBytes"", SerializerContext::WriteRaw...",29,,456,5,,void
231357,BLOCK,-1,,"{
  registry->Register(SerializerContext::New);

  registry->Register(SerializerContext::WriteHeader);
  registry->Register(SerializerContext::WriteValue);
  registry->Register(SerializerContext::ReleaseBuffer);
  registry->Register(SerializerContext::TransferArrayBuffer);
  registry->Register(SerializerContext::WriteUint32);
  registry->Register(SerializerContext::WriteUint64);
  registry->Register(SerializerContext::WriteDouble);
  registry->Register(SerializerContext::WriteRawBytes);
  registry->Register(SerializerContext::SetTreatArrayBufferViewsAsHostObjects);

  registry->Register(DeserializerContext::New);
  registry->Register(DeserializerContext::ReadHeader);
  registry->Register(DeserializerContext::ReadValue);
  registry->Register(DeserializerContext::GetWireFormatVersion);
  registry->Register(DeserializerContext::TransferArrayBuffer);
  registry->Register(DeserializerContext::ReadUint32);
  registry->Register(DeserializerContext::ReadUint64);
  registry->Register(Deseria...",70,,514,2,,void
231497,BLOCK,-1,,{ delete realm; },56,,51,2,,void
231513,BLOCK,-1,,<empty>,1,,1,1,,ANY
231519,BLOCK,-1,,"{
  ShadowRealm* realm = new ShadowRealm(env);

  // We do not expect the realm bootstrapping to throw any
  // exceptions. If it does, exit the current Node.js instance.
  TryCatchScope try_catch(env, TryCatchScope::CatchMode::kFatal);
  if (realm->RunBootstrapping().IsEmpty()) {
    delete realm;
    return nullptr;
  }
  return realm;
}",49,,17,2,,void
231542,BLOCK,-1,,"{
    delete realm;
    return nullptr;
  }",44,,23,2,,void
231553,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(initiator_context);
  EscapableHandleScope scope(env->isolate());
  ShadowRealm* realm = ShadowRealm::New(env);
  if (realm != nullptr) {
    return scope.Escape(realm->context());
  }
  return MaybeLocal<Context>();
}",39,,32,2,,void
231580,BLOCK,-1,,"{
    return scope.Escape(realm->context());
  }",25,,36,2,,void
231596,BLOCK,-1,,"{
  ShadowRealm* realm = data.GetParameter();
  realm->context_.Reset();

  // Yield to pending weak callbacks before deleting the realm.
  // This is necessary to avoid cleaning up base objects before their scheduled
  // weak callbacks are invoked, which can lead to accessing to v8 apis during
  // the first pass of the weak callback.
  realm->env()->SetImmediate([realm](Environment* env) { delete realm; });
  // Remove the cleanup hook to avoid deleting the realm again.
  realm->env()->RemoveCleanupHook(DeleteMe, realm);
}",79,,43,2,,void
231630,BLOCK,-1,,"{
  ShadowRealm* realm = static_cast<ShadowRealm*>(data);
  // Clear the context handle to avoid invoking the weak callback again.
  // Also, the context internal slots are cleared and the context is no longer
  // reference to the realm.
  delete realm;
}",40,,57,2,,void
231643,BLOCK,-1,,"{
  context_.SetWeak(this, WeakCallback, v8::WeakCallbackType::kParameter);
  CreateProperties();

  env->TrackShadowRealm(this);
  env->AddCleanupHook(DeleteMe, this);
}",60,,66,2,,void
231670,BLOCK,-1,,"{
  while (HasCleanupHooks()) {
    RunCleanup();
  }

  env_->UntrackShadowRealm(this);

  if (context_.IsEmpty()) {
    // This most likely happened because the weak callback cleared it.
    return;
  }

  {
    HandleScope handle_scope(isolate());
    env_->UnassignFromContext(context());
  }
}",29,,74,1,,void
231673,BLOCK,-1,,"{
    RunCleanup();
  }",29,,75,2,,void
231685,BLOCK,-1,,"{
    // This most likely happened because the weak callback cleared it.
    return;
  }",27,,81,2,,void
231687,BLOCK,4,,"{
    HandleScope handle_scope(isolate());
    env_->UnassignFromContext(context());
  }",3,,86,4,,void
231699,BLOCK,-1,,"{
  Local<Context> ctx = PersistentToLocal::Default(isolate_, context_);
  DCHECK(!ctx.IsEmpty());
  return ctx;
}",53,,92,1,,void
231725,BLOCK,-1,,"{
  HandleScope scope(isolate_);

  // Skip ""internal/bootstrap/node"" as it installs node globals and per-isolate
  // callbacks.

  if (!env_->no_browser_globals()) {
    if (ExecuteBootstrapper(""internal/bootstrap/web/exposed-wildcard"")
            .IsEmpty()) {
      return MaybeLocal<Value>();
    }
  }

  return v8::True(isolate_);
}",57,,127,1,,void
231735,BLOCK,-1,,"{
    if (ExecuteBootstrapper(""internal/bootstrap/web/exposed-wildcard"")
            .IsEmpty()) {
      return MaybeLocal<Value>();
    }
  }",36,,133,2,,void
231742,BLOCK,-1,,"{
      return MaybeLocal<Value>();
    }",25,,135,2,,void
231761,BLOCK,-1,,<empty>,1,,1,1,,ANY
231778,BLOCK,-1,,<empty>,1,,1,1,,ANY
231785,BLOCK,-1,,<empty>,1,,1,1,,ANY
231788,BLOCK,-1,,"{
  return nullptr;
}",64,,9,1,,void
231795,BLOCK,-1,,"{
      if (bootstrapCatch.HasCaught()) {
        PrintCaughtException(
            isolate, isolate->GetCurrentContext(), bootstrapCatch);
      }
    }",47,,928,1,,void
231801,BLOCK,-1,,"{
        PrintCaughtException(
            isolate, isolate->GetCurrentContext(), bootstrapCatch);
      }",39,,929,2,,void
231817,BLOCK,-1,,{ realm->PrintInfoForSnapshot(); },44,,1002,2,,void
231827,BLOCK,-1,,"{
    // If there are any BaseObjects that are not snapshotable left
    // during context serialization, V8 would crash due to unregistered
    // global handles and print detailed information about them.
    if (!obj->is_snapshotable()) {
      return;
    }
    SnapshotableObject* ptr = static_cast<SnapshotableObject*>(obj);

    std::string type_name = ptr->GetTypeName();
    per_process::Debug(DebugCategory::MKSNAPSHOT,
                       ""Serialize snapshotable object %i (%p), ""
                       ""object=%p, type=%s\n"",
                       static_cast<int>(i),
                       ptr,
                       *(ptr->object()),
                       type_name);

    if (ptr->PrepareForSerialization(context, creator)) {
      SnapshotIndex index = creator->AddData(context, obj->object());
      per_process::Debug(DebugCategory::MKSNAPSHOT,
                         ""Serialized with index=%d\n"",
                         static_cast<int>(index));
      info->native_ob...",49,,1203,2,,void
231834,BLOCK,-1,,"{
      return;
    }",34,,1207,2,,void
231874,BLOCK,-1,,"{
      SnapshotIndex index = creator->AddData(context, obj->object());
      per_process::Debug(DebugCategory::MKSNAPSHOT,
                         ""Serialized with index=%d\n"",
                         static_cast<int>(index));
      info->native_objects.push_back({type_name, i, index});
    }",57,,1221,2,,void
231972,BLOCK,-1,,<empty>,1,,1,1,,ANY
231978,BLOCK,-1,,"{
  output << ""<builtins::CodeCacheInfo id="" << info.id
         << "", length="" << info.data.length << "">\n"";
  return output;
}",63,,55,3,,void
232003,BLOCK,-1,,"{
  output << ""{\n"";
  for (const auto& info : vec) {
    output << info;
  }
  output << ""}\n"";
  return output;
}",75,,62,3,,void
232010,BLOCK,-1,,"{
    output << info;
  }",32,,64,3,,void
232024,BLOCK,-1,,"{
  output << ""{\n"";
  for (const auto& i : vec) {
    output << i << "","";
  }
  output << ""}"";
  return output;
}",59,,72,3,,void
232031,BLOCK,-1,,"{
    output << i << "","";
  }",29,,74,3,,void
232047,BLOCK,-1,,"{
  output << ""{\n"";
  for (const auto& info : vec) {
    output << ""  "" << info << "",\n"";
  }
  output << ""}"";
  return output;
}",60,,82,3,,void
232054,BLOCK,-1,,"{
    output << ""  "" << info << "",\n"";
  }",32,,84,3,,void
232072,BLOCK,-1,,"{
  output << ""{ \"""" << info.name << ""\"", "" << std::to_string(info.id) << "", ""
         << std::to_string(info.index) << "" }"";
  return output;
}",70,,91,3,,void
232109,BLOCK,-1,,"{
  output << ""{\n"";
  for (const auto& info : vec) {
    output << ""  \"""" << info << ""\"",\n"";
  }
  output << ""}"";
  return output;
}",63,,98,3,,void
232116,BLOCK,-1,,"{
    output << ""  \"""" << info << ""\"",\n"";
  }",32,,100,3,,void
232134,BLOCK,-1,,"{
  output << ""{\n""
         << ""// -- builtins begins --\n""
         << i.builtins << "",\n""
         << ""// -- builtins ends --\n""
         << ""// -- persistent_values begins --\n""
         << i.persistent_values << "",\n""
         << ""// -- persistent_values ends --\n""
         << ""// -- native_objects begins --\n""
         << i.native_objects << "",\n""
         << ""// -- native_objects ends --\n""
         << i.context << "",  // context\n""
         << ""}"";
  return output;
}",77,,107,3,,void
232183,BLOCK,-1,,"{
  output << ""{\n""
         << ""// -- async_hooks begins --\n""
         << i.async_hooks << "",\n""
         << ""// -- async_hooks ends --\n""
         << i.tick_info << "",  // tick_info\n""
         << i.immediate_info << "",  // immediate_info\n""
         << i.timeout_info << "",  // timeout_info\n""
         << ""// -- performance_state begins --\n""
         << i.performance_state << "",\n""
         << ""// -- performance_state ends --\n""
         << i.exit_info << "",  // exit_info\n""
         << i.stream_base_state << "",  // stream_base_state\n""
         << i.should_abort_on_uncaught_toggle
         << "",  // should_abort_on_uncaught_toggle\n""
         << ""// -- principal_realm begins --\n""
         << i.principal_realm << "",\n""
         << ""// -- principal_realm ends --\n""
         << ""}"";
  return output;
}",75,,123,3,,void
232262,BLOCK,-1,,<empty>,16,,150,2,,void
232266,BLOCK,-1,,<empty>,,,,1,,<empty>
232271,BLOCK,-1,,"{
    // Currently the snapshot blob built with an empty script is around 4MB.
    // So use that as the default sink size.
    sink.reserve(4 * 1024 * 1024);
  }",45,,163,1,,void
232285,BLOCK,-1,,<empty>,,,,2,,<empty>
232289,BLOCK,-1,,"{
  Debug(""Read<v8::StartupData>()\n"");

  int raw_size = ReadArithmetic<int>();
  Debug(""size=%d\n"", raw_size);

  CHECK_GT(raw_size, 0);  // There should be no startup data of size 0.
  // The data pointer of v8::StartupData would be deleted so it must be new'ed.
  std::unique_ptr<char> buf = std::unique_ptr<char>(new char[raw_size]);
  ReadArithmetic<char>(buf.get(), raw_size);

  return v8::StartupData{buf.release(), raw_size};
}",46,,179,1,,void
232329,BLOCK,-1,,"{
  Debug(""\nWrite<v8::StartupData>() size=%d\n"", data.raw_size);

  CHECK_GT(data.raw_size, 0);  // There should be no startup data of size 0.
  size_t written_total = WriteArithmetic<int>(data.raw_size);
  written_total +=
      WriteArithmetic<char>(data.data, static_cast<size_t>(data.raw_size));

  Debug(""Write<v8::StartupData>() wrote %d bytes\n\n"", written_total);
  return written_total;
}",63,,194,2,,void
232366,BLOCK,-1,,"{
  Debug(""Read<builtins::CodeCacheInfo>()\n"");

  std::string id = ReadString();
  auto owning_ptr =
      std::make_shared<std::vector<uint8_t>>(ReadVector<uint8_t>());
  builtins::BuiltinCodeCacheData code_cache_data{std::move(owning_ptr)};
  builtins::CodeCacheInfo result{id, code_cache_data};

  if (is_debug) {
    std::string str = ToStr(result);
    Debug(""Read<builtins::CodeCacheInfo>() %s\n"", str.c_str());
  }
  return result;
}",54,,212,1,,void
232404,BLOCK,-1,,"{
    std::string str = ToStr(result);
    Debug(""Read<builtins::CodeCacheInfo>() %s\n"", str.c_str());
  }",17,,221,2,,void
232422,BLOCK,-1,,"{
  Debug(""\nWrite<builtins::CodeCacheInfo>() id = %s""
        "", length=%d\n"",
        info.id.c_str(),
        info.data.length);

  size_t written_total = WriteString(info.id);

  written_total += WriteArithmetic<size_t>(info.data.length);
  written_total += WriteArithmetic(info.data.data, info.data.length);

  Debug(""Write<builtins::CodeCacheInfo>() wrote %d bytes\n"", written_total);
  return written_total;
}",71,,229,2,,void
232475,BLOCK,-1,,"{
  Debug(""Read<PropInfo>()\n"");

  PropInfo result;
  result.name = ReadString();
  result.id = ReadArithmetic<uint32_t>();
  result.index = ReadArithmetic<SnapshotIndex>();

  if (is_debug) {
    std::string str = ToStr(result);
    Debug(""Read<PropInfo>() %s\n"", str.c_str());
  }

  return result;
}",39,,251,1,,void
232496,BLOCK,-1,,"{
    std::string str = ToStr(result);
    Debug(""Read<PropInfo>() %s\n"", str.c_str());
  }",17,,259,2,,void
232514,BLOCK,-1,,"{
  if (is_debug) {
    std::string str = ToStr(data);
    Debug(""Write<PropInfo>() %s\n"", str.c_str());
  }

  size_t written_total = WriteString(data.name);
  written_total += WriteArithmetic<uint32_t>(data.id);
  written_total += WriteArithmetic<SnapshotIndex>(data.index);

  Debug(""Write<PropInfo>() wrote %d bytes\n"", written_total);
  return written_total;
}",56,,268,2,,void
232517,BLOCK,-1,,"{
    std::string str = ToStr(data);
    Debug(""Write<PropInfo>() %s\n"", str.c_str());
  }",17,,269,2,,void
232562,BLOCK,-1,,"{
  Debug(""Read<AsyncHooks::SerializeInfo>()\n"");

  AsyncHooks::SerializeInfo result;
  result.async_ids_stack = ReadArithmetic<AliasedBufferIndex>();
  result.fields = ReadArithmetic<AliasedBufferIndex>();
  result.async_id_fields = ReadArithmetic<AliasedBufferIndex>();
  result.js_execution_async_resources = ReadArithmetic<SnapshotIndex>();
  result.native_execution_async_resources = ReadVector<SnapshotIndex>();

  if (is_debug) {
    std::string str = ToStr(result);
    Debug(""Read<AsyncHooks::SerializeInfo>() %s\n"", str.c_str());
  }

  return result;
}",56,,291,1,,void
232593,BLOCK,-1,,"{
    std::string str = ToStr(result);
    Debug(""Read<AsyncHooks::SerializeInfo>() %s\n"", str.c_str());
  }",17,,301,2,,void
232611,BLOCK,-1,,"{
  if (is_debug) {
    std::string str = ToStr(data);
    Debug(""Write<AsyncHooks::SerializeInfo>() %s\n"", str.c_str());
  }

  size_t written_total =
      WriteArithmetic<AliasedBufferIndex>(data.async_ids_stack);
  written_total += WriteArithmetic<AliasedBufferIndex>(data.fields);
  written_total += WriteArithmetic<AliasedBufferIndex>(data.async_id_fields);
  written_total +=
      WriteArithmetic<SnapshotIndex>(data.js_execution_async_resources);
  written_total +=
      WriteVector<SnapshotIndex>(data.native_execution_async_resources);

  Debug(""Write<AsyncHooks::SerializeInfo>() wrote %d bytes\n"", written_total);
  return written_total;
}",73,,309,2,,void
232614,BLOCK,-1,,"{
    std::string str = ToStr(data);
    Debug(""Write<AsyncHooks::SerializeInfo>() %s\n"", str.c_str());
  }",17,,310,2,,void
232680,BLOCK,-1,,"{
  Debug(""Read<TickInfo::SerializeInfo>()\n"");

  TickInfo::SerializeInfo result;
  result.fields = ReadArithmetic<AliasedBufferIndex>();

  if (is_debug) {
    std::string str = ToStr(result);
    Debug(""Read<TickInfo::SerializeInfo>() %s\n"", str.c_str());
  }

  return result;
}",54,,331,1,,void
232691,BLOCK,-1,,"{
    std::string str = ToStr(result);
    Debug(""Read<TickInfo::SerializeInfo>() %s\n"", str.c_str());
  }",17,,337,2,,void
232709,BLOCK,-1,,"{
  if (is_debug) {
    std::string str = ToStr(data);
    Debug(""Write<TickInfo::SerializeInfo>() %s\n"", str.c_str());
  }

  size_t written_total = WriteArithmetic<AliasedBufferIndex>(data.fields);

  Debug(""Write<TickInfo::SerializeInfo>() wrote %d bytes\n"", written_total);
  return written_total;
}",71,,346,2,,void
232712,BLOCK,-1,,"{
    std::string str = ToStr(data);
    Debug(""Write<TickInfo::SerializeInfo>() %s\n"", str.c_str());
  }",17,,347,2,,void
232742,BLOCK,-1,,"{
  Debug(""Read<ImmediateInfo::SerializeInfo>()\n"");

  ImmediateInfo::SerializeInfo result;
  result.fields = ReadArithmetic<AliasedBufferIndex>();
  if (is_debug) {
    std::string str = ToStr(result);
    Debug(""Read<ImmediateInfo::SerializeInfo>() %s\n"", str.c_str());
  }
  return result;
}",59,,361,1,,void
232753,BLOCK,-1,,"{
    std::string str = ToStr(result);
    Debug(""Read<ImmediateInfo::SerializeInfo>() %s\n"", str.c_str());
  }",17,,366,2,,void
232771,BLOCK,-1,,"{
  if (is_debug) {
    std::string str = ToStr(data);
    Debug(""Write<ImmediateInfo::SerializeInfo>() %s\n"", str.c_str());
  }

  size_t written_total = WriteArithmetic<AliasedBufferIndex>(data.fields);

  Debug(""Write<ImmediateInfo::SerializeInfo>() wrote %d bytes\n"",
        written_total);
  return written_total;
}",76,,374,2,,void
232774,BLOCK,-1,,"{
    std::string str = ToStr(data);
    Debug(""Write<ImmediateInfo::SerializeInfo>() %s\n"", str.c_str());
  }",17,,375,2,,void
232804,BLOCK,-1,,"{
  Debug(""Read<PerformanceState::SerializeInfo>()\n"");

  performance::PerformanceState::SerializeInfo result;
  result.root = ReadArithmetic<AliasedBufferIndex>();
  result.milestones = ReadArithmetic<AliasedBufferIndex>();
  result.observers = ReadArithmetic<AliasedBufferIndex>();
  if (is_debug) {
    std::string str = ToStr(result);
    Debug(""Read<PerformanceState::SerializeInfo>() %s\n"", str.c_str());
  }
  return result;
}",75,,392,1,,void
232825,BLOCK,-1,,"{
    std::string str = ToStr(result);
    Debug(""Read<PerformanceState::SerializeInfo>() %s\n"", str.c_str());
  }",17,,399,2,,void
232843,BLOCK,-1,,"{
  if (is_debug) {
    std::string str = ToStr(data);
    Debug(""Write<PerformanceState::SerializeInfo>() %s\n"", str.c_str());
  }

  size_t written_total = WriteArithmetic<AliasedBufferIndex>(data.root);
  written_total += WriteArithmetic<AliasedBufferIndex>(data.milestones);
  written_total += WriteArithmetic<AliasedBufferIndex>(data.observers);

  Debug(""Write<PerformanceState::SerializeInfo>() wrote %d bytes\n"",
        written_total);
  return written_total;
}",63,,408,2,,void
232846,BLOCK,-1,,"{
    std::string str = ToStr(data);
    Debug(""Write<PerformanceState::SerializeInfo>() %s\n"", str.c_str());
  }",17,,409,2,,void
232894,BLOCK,-1,,"{
  Debug(""Read<IsolateDataSerializeInfo>()\n"");

  IsolateDataSerializeInfo result;
  result.primitive_values = ReadVector<SnapshotIndex>();
  result.template_values = ReadVector<PropInfo>();
  if (is_debug) {
    std::string str = ToStr(result);
    Debug(""Read<IsolateDataSerializeInfo>() %s\n"", str.c_str());
  }
  return result;
}",55,,429,1,,void
232910,BLOCK,-1,,"{
    std::string str = ToStr(result);
    Debug(""Read<IsolateDataSerializeInfo>() %s\n"", str.c_str());
  }",17,,435,2,,void
232928,BLOCK,-1,,"{
  if (is_debug) {
    std::string str = ToStr(data);
    Debug(""Write<IsolateDataSerializeInfo>() %s\n"", str.c_str());
  }

  size_t written_total = WriteVector<SnapshotIndex>(data.primitive_values);
  written_total += WriteVector<PropInfo>(data.template_values);

  Debug(""Write<IsolateDataSerializeInfo>() wrote %d bytes\n"", written_total);
  return written_total;
}",72,,443,2,,void
232931,BLOCK,-1,,"{
    std::string str = ToStr(data);
    Debug(""Write<IsolateDataSerializeInfo>() %s\n"", str.c_str());
  }",17,,444,2,,void
232970,BLOCK,-1,,"{
  Debug(""Read<RealmSerializeInfo>()\n"");
  RealmSerializeInfo result;
  result.builtins = ReadVector<std::string>();
  result.persistent_values = ReadVector<PropInfo>();
  result.native_objects = ReadVector<PropInfo>();
  result.context = ReadArithmetic<SnapshotIndex>();
  return result;
}",49,,457,1,,void
233001,BLOCK,-1,,"{
  if (is_debug) {
    std::string str = ToStr(data);
    Debug(""\nWrite<RealmSerializeInfo>() %s\n"", str.c_str());
  }

  // Use += here to ensure order of evaluation.
  size_t written_total = WriteVector<std::string>(data.builtins);
  written_total += WriteVector<PropInfo>(data.persistent_values);
  written_total += WriteVector<PropInfo>(data.native_objects);
  written_total += WriteArithmetic<SnapshotIndex>(data.context);

  Debug(""Write<RealmSerializeInfo>() wrote %d bytes\n"", written_total);
  return written_total;
}",66,,468,2,,void
233004,BLOCK,-1,,"{
    std::string str = ToStr(data);
    Debug(""\nWrite<RealmSerializeInfo>() %s\n"", str.c_str());
  }",17,,469,2,,void
233063,BLOCK,-1,,"{
  Debug(""Read<EnvSerializeInfo>()\n"");
  EnvSerializeInfo result;
  result.async_hooks = Read<AsyncHooks::SerializeInfo>();
  result.tick_info = Read<TickInfo::SerializeInfo>();
  result.immediate_info = Read<ImmediateInfo::SerializeInfo>();
  result.timeout_info = ReadArithmetic<AliasedBufferIndex>();
  result.performance_state =
      Read<performance::PerformanceState::SerializeInfo>();
  result.exit_info = ReadArithmetic<AliasedBufferIndex>();
  result.stream_base_state = ReadArithmetic<AliasedBufferIndex>();
  result.should_abort_on_uncaught_toggle = ReadArithmetic<AliasedBufferIndex>();
  result.principal_realm = Read<RealmSerializeInfo>();
  return result;
}",47,,485,1,,void
233122,BLOCK,-1,,"{
  if (is_debug) {
    std::string str = ToStr(data);
    Debug(""\nWrite<EnvSerializeInfo>() %s\n"", str.c_str());
  }

  // Use += here to ensure order of evaluation.
  size_t written_total = Write<AsyncHooks::SerializeInfo>(data.async_hooks);
  written_total += Write<TickInfo::SerializeInfo>(data.tick_info);
  written_total += Write<ImmediateInfo::SerializeInfo>(data.immediate_info);
  written_total += WriteArithmetic<AliasedBufferIndex>(data.timeout_info);
  written_total += Write<performance::PerformanceState::SerializeInfo>(
      data.performance_state);
  written_total += WriteArithmetic<AliasedBufferIndex>(data.exit_info);
  written_total += WriteArithmetic<AliasedBufferIndex>(data.stream_base_state);
  written_total +=
      WriteArithmetic<AliasedBufferIndex>(data.should_abort_on_uncaught_toggle);
  written_total += Write<RealmSerializeInfo>(data.principal_realm);

  Debug(""Write<EnvSerializeInfo>() wrote %d bytes\n"", written_total);
  return written_total;
}",64,,502,2,,void
233125,BLOCK,-1,,"{
    std::string str = ToStr(data);
    Debug(""\nWrite<EnvSerializeInfo>() %s\n"", str.c_str());
  }",17,,503,2,,void
233216,BLOCK,-1,,"{
  Debug(""Read<SnapshotMetadata>()\n"");

  SnapshotMetadata result;
  result.type = static_cast<SnapshotMetadata::Type>(ReadArithmetic<uint8_t>());
  result.node_version = ReadString();
  result.node_arch = ReadString();
  result.node_platform = ReadString();
  result.v8_cache_version_tag = ReadArithmetic<uint32_t>();

  if (is_debug) {
    std::string str = ToStr(result);
    Debug(""Read<SnapshotMetadata>() %s\n"", str.c_str());
  }
  return result;
}",47,,535,1,,void
233249,BLOCK,-1,,"{
    std::string str = ToStr(result);
    Debug(""Read<SnapshotMetadata>() %s\n"", str.c_str());
  }",17,,545,2,,void
233267,BLOCK,-1,,"{
  if (is_debug) {
    std::string str = ToStr(data);
    Debug(""\nWrite<SnapshotMetadata>() %s\n"", str.c_str());
  }
  size_t written_total = 0;
  // We need the Node.js version, platform and arch to match because
  // Node.js may perform synchronizations that are platform-specific and they
  // can be changed in semver-patches.
  Debug(""Write snapshot type %d\n"", static_cast<uint8_t>(data.type));
  written_total += WriteArithmetic<uint8_t>(static_cast<uint8_t>(data.type));
  Debug(""Write Node.js version %s\n"", data.node_version.c_str());
  written_total += WriteString(data.node_version);
  Debug(""Write Node.js arch %s\n"", data.node_arch);
  written_total += WriteString(data.node_arch);
  Debug(""Write Node.js platform %s\n"", data.node_platform);
  written_total += WriteString(data.node_platform);
  Debug(""Write V8 cached data version tag %"" PRIx32 ""\n"",
        data.v8_cache_version_tag);
  written_total += WriteArithmetic<uint32_t>(data.v8_cache_version_tag);
  return written_tot...",64,,553,2,,void
233270,BLOCK,-1,,"{
    std::string str = ToStr(data);
    Debug(""\nWrite<SnapshotMetadata>() %s\n"", str.c_str());
  }",17,,554,2,,void
233355,BLOCK,-1,,"{
  SnapshotSerializer w;
  w.Debug(""SnapshotData::ToBlob()\n"");

  size_t written_total = 0;

  // Metadata
  w.Debug(""Write magic %"" PRIx32 ""\n"", kMagic);
  written_total += w.WriteArithmetic<uint32_t>(kMagic);
  w.Debug(""Write metadata\n"");
  written_total += w.Write<SnapshotMetadata>(metadata);

  written_total += w.Write<v8::StartupData>(v8_snapshot_blob_data);
  w.Debug(""Write isolate_data_indices\n"");
  written_total += w.Write<IsolateDataSerializeInfo>(isolate_data_info);
  written_total += w.Write<EnvSerializeInfo>(env_info);
  w.Debug(""Write code_cache\n"");
  written_total += w.WriteVector<builtins::CodeCacheInfo>(code_cache);
  w.Debug(""SnapshotData::ToBlob() Wrote %d bytes\n"", written_total);
  return w.sink;
}",48,,587,1,,void
233454,BLOCK,-1,,"{
  const std::vector<char> sink = ToBlob();
  size_t num_written = fwrite(sink.data(), sink.size(), 1, out);
  CHECK_EQ(num_written, 1);
  CHECK_EQ(fflush(out), 0);
}",44,,609,2,,void
233484,BLOCK,-1,,"{
  return data != nullptr ? data->impl_ : nullptr;
}",39,,617,2,,void
233497,BLOCK,-1,,"{
  return EmbedderSnapshotData::Pointer{new EmbedderSnapshotData(this, false)};
}",71,,621,1,,void
233510,BLOCK,-1,,"{
  return FromBlob(out, ReadFileSync(in));
}",58,,625,3,,void
233521,BLOCK,-1,,"{
  return FromBlob(out, std::string_view(in.data(), in.size()));
}",77,,629,3,,void
233542,BLOCK,-1,,"{
  SnapshotDeserializer r(in);
  r.Debug(""SnapshotData::FromBlob()\n"");

  DCHECK_EQ(out->data_ownership, SnapshotData::DataOwnership::kOwned);

  // Metadata
  uint32_t magic = r.ReadArithmetic<uint32_t>();
  r.Debug(""Read magic %"" PRIx32 ""\n"", magic);
  CHECK_EQ(magic, kMagic);
  out->metadata = r.Read<SnapshotMetadata>();
  r.Debug(""Read metadata\n"");
  if (!out->Check()) {
    return false;
  }

  out->v8_snapshot_blob_data = r.Read<v8::StartupData>();
  r.Debug(""Read isolate_data_info\n"");
  out->isolate_data_info = r.Read<IsolateDataSerializeInfo>();
  out->env_info = r.Read<EnvSerializeInfo>();
  r.Debug(""Read code_cache\n"");
  out->code_cache = r.ReadVector<builtins::CodeCacheInfo>();

  r.Debug(""SnapshotData::FromBlob() read %d bytes\n"", r.read_total);
  return true;
}",69,,633,3,,void
233590,BLOCK,-1,,"{
    return false;
  }",22,,645,2,,void
233648,BLOCK,-1,,"{
  if (metadata.node_version != per_process::metadata.versions.node) {
    fprintf(stderr,
            ""Failed to load the startup snapshot because it was built with""
            ""Node.js version %s and the current Node.js version is %s.\n"",
            metadata.node_version.c_str(),
            NODE_VERSION);
    return false;
  }

  if (metadata.node_arch != per_process::metadata.arch) {
    fprintf(stderr,
            ""Failed to load the startup snapshot because it was built with""
            ""architecture %s and the architecture is %s.\n"",
            metadata.node_arch.c_str(),
            NODE_ARCH);
    return false;
  }

  if (metadata.node_platform != per_process::metadata.platform) {
    fprintf(stderr,
            ""Failed to load the startup snapshot because it was built with""
            ""platform %s and the current platform is %s.\n"",
            metadata.node_platform.c_str(),
            NODE_PLATFORM);
    return false;
  }

  uint32_t current_cache_version = v8::Sc...",34,,660,1,,void
233661,BLOCK,-1,,"{
    fprintf(stderr,
            ""Failed to load the startup snapshot because it was built with""
            ""Node.js version %s and the current Node.js version is %s.\n"",
            metadata.node_version.c_str(),
            NODE_VERSION);
    return false;
  }",69,,661,2,,void
233684,BLOCK,-1,,"{
    fprintf(stderr,
            ""Failed to load the startup snapshot because it was built with""
            ""architecture %s and the architecture is %s.\n"",
            metadata.node_arch.c_str(),
            NODE_ARCH);
    return false;
  }",57,,670,2,,void
233707,BLOCK,-1,,"{
    fprintf(stderr,
            ""Failed to load the startup snapshot because it was built with""
            ""platform %s and the current platform is %s.\n"",
            metadata.node_platform.c_str(),
            NODE_PLATFORM);
    return false;
  }",65,,679,2,,void
233745,BLOCK,-1,,"{
    // For now we only do this check for the customized snapshots - we know
    // that the flags we use in the default snapshot are limited and safe
    // enough so we can relax the constraints for it.
    fprintf(stderr,
            ""Failed to load the startup snapshot because it was built with ""
            ""a different version of V8 or with different V8 configurations.\n""
            ""Expected tag %"" PRIx32 "", read %"" PRIx32 ""\n"",
            current_cache_version,
            metadata.v8_cache_version_tag);
    return false;
  }",66,,690,2,,void
233754,BLOCK,-1,,"{
  if (data_ownership == DataOwnership::kOwned &&
      v8_snapshot_blob_data.data != nullptr) {
    delete[] v8_snapshot_blob_data.data;
  }
}",31,,707,1,,void
233767,BLOCK,-1,,"{
    delete[] v8_snapshot_blob_data.data;
  }",46,,709,2,,void
233778,BLOCK,-1,,"{
  for (size_t i = 0; i < size; i++) {
    *ss << std::to_string(vec[i]) << (i == size - 1 ? '\n' : ',');
  }
}",63,,715,4,,void
233780,BLOCK,-1,,<empty>,3,,716,1,,void
233790,BLOCK,4,,"{
    *ss << std::to_string(vec[i]) << (i == size - 1 ? '\n' : ',');
  }",37,,716,4,,void
233814,BLOCK,-1,,"{
  char buf[64] = {0};
  size_t size = id.size();
  CHECK_LT(size, sizeof(buf));
  for (size_t i = 0; i < size; ++i) {
    char ch = id[i];
    buf[i] = (ch == '-' || ch == '/') ? '_' : ch;
  }
  return std::string(buf) + std::string(""_cache_data"");
}",63,,721,2,,void
233832,BLOCK,-1,,<empty>,3,,725,1,,void
233842,BLOCK,4,,"{
    char ch = id[i];
    buf[i] = (ch == '-' || ch == '/') ? '_' : ch;
  }",37,,725,4,,void
233879,BLOCK,-1,,"{
  char buf[64] = {0};
  if (size < 1024) {
    snprintf(buf, sizeof(buf), ""%.2fB"", static_cast<double>(size));
  } else if (size < 1024 * 1024) {
    snprintf(buf, sizeof(buf), ""%.2fKB"", static_cast<double>(size / 1024));
  } else {
    snprintf(
        buf, sizeof(buf), ""%.2fMB"", static_cast<double>(size / 1024 / 1024));
  }
  return buf;
}",44,,732,2,,void
233889,BLOCK,-1,,"{
    snprintf(buf, sizeof(buf), ""%.2fB"", static_cast<double>(size));
  }",20,,734,2,,void
233899,BLOCK,-1,,<empty>,10,,736,1,,void
233906,BLOCK,-1,,"{
    snprintf(buf, sizeof(buf), ""%.2fKB"", static_cast<double>(size / 1024));
  }",34,,736,2,,void
233918,BLOCK,-1,,"{
    snprintf(
        buf, sizeof(buf), ""%.2fMB"", static_cast<double>(size / 1024 / 1024));
  }",10,,738,1,,void
233938,BLOCK,-1,,"{
  *ss << ""static const uint8_t "" << GetCodeCacheDefName(info.id) << ""[] = {\n"";
  WriteVector(ss, info.data.data, info.data.length);
  *ss << ""};\n"";
}",60,,781,3,,void
233972,BLOCK,-1,,"{
  std::string def_name = GetCodeCacheDefName(id);
  *ss << ""    { \"""" << id << ""\"",\n"";
  *ss << ""      {"" << def_name << "",\n"";
  *ss << ""       "" << size << "",\n"";
  *ss << ""      }\n"";
  *ss << ""    },\n"";
}",52,,790,4,,void
234015,BLOCK,-1,,"{
  ss << R""(#include <cstddef>
#include ""env.hpp""
#include ""node_snapshot_builder.hpp""
#include ""v8.hpp""

// This file is generated by tools/snapshot. Do not edit.

namespace node {
)"";

#ifdef NODE_MKSNAPSHOT_USE_STRING_LITERALS
  ss << R""(static const char *v8_snapshot_blob_data = "")"";
  WriteDataAsCharString(
      &ss,
      reinterpret_cast<const uint8_t*>(data->v8_snapshot_blob_data.data),
      data->v8_snapshot_blob_data.raw_size);
  ss << R""("";)"";
#else
  ss << R""(static const char v8_snapshot_blob_data[] = {)"";
  WriteVector(&ss,
              data->v8_snapshot_blob_data.data,
              data->v8_snapshot_blob_data.raw_size);
  ss << R""(};)"";
#endif

  ss << R""(static const int v8_snapshot_blob_size = )""
     << data->v8_snapshot_blob_data.raw_size << "";"";

  for (const auto& item : data->code_cache) {
#ifdef NODE_MKSNAPSHOT_USE_STRING_LITERALS
    WriteStaticCodeCacheDataAsStringLiteral(&ss, item);
#else
    // Windows can't deal with too many large vector initializer...",61,,799,3,,void
234054,BLOCK,-1,,"{
#ifdef NODE_MKSNAPSHOT_USE_STRING_LITERALS
    WriteStaticCodeCacheDataAsStringLiteral(&ss, item);
#else
    // Windows can't deal with too many large vector initializers.
    // Store the data into static arrays first.
    WriteStaticCodeCacheDataAsArray(&ss, item);
#endif
  }",45,,828,3,,void
234085,BLOCK,-1,,"{
    WriteCodeCacheInitializer(&ss, item.id, item.data.length);
  }",45,,861,3,,void
234104,BLOCK,-1,,"{
  // Reset the AllowCodeGenerationFromStrings flag to true (default value) so
  // that it can be re-initialized with v8 flag
  // --disallow-code-generation-from-strings and recognized in
  // node::InitializeContextRuntime.
  context->AllowCodeGenerationFromStrings(true);
}",72,,878,2,,void
234113,BLOCK,-1,,"{
  static auto registry = std::make_unique<ExternalReferenceRegistry>();
  return registry->external_references();
}",75,,886,1,,void
234131,BLOCK,-1,,"{
  CHECK_NULL(params->external_references);
  CHECK_NULL(params->snapshot_blob);
  params->external_references = CollectExternalReferences().data();
  params->snapshot_blob =
      const_cast<v8::StartupData*>(&(data->v8_snapshot_blob_data));
}",78,,892,3,,void
234165,BLOCK,-1,,"{
  // The default snapshot is meant to be runtime-independent and has more
  // restrictions. We do not enable the inspector and do not run the event
  // loop when building the default snapshot to avoid inconsistencies, but
  // we do for the fully customized one, and they are expected to fixup the
  // inconsistencies using v8.startupSnapshot callbacks.
  SnapshotMetadata::Type snapshot_type =
      main_script.has_value() ? SnapshotMetadata::Type::kFullyCustomized
                              : SnapshotMetadata::Type::kDefault;

  std::vector<std::string> errors;
  auto setup = CommonEnvironmentSetup::CreateForSnapshotting(
      per_process::v8_platform.Platform(), &errors, args, exec_args);
  if (!setup) {
    for (const std::string& err : errors)
      fprintf(stderr, ""%s: %s\n"", args[0].c_str(), err.c_str());
    return ExitCode::kBootstrapFailure;
  }
  Isolate* isolate = setup->isolate();

  {
    HandleScope scope(isolate);
    TryCatch bootstrapCatch(isolate);

    auto...",50,,904,5,,void
234213,BLOCK,-1,,"{
    for (const std::string& err : errors)
      fprintf(stderr, ""%s: %s\n"", args[0].c_str(), err.c_str());
    return ExitCode::kBootstrapFailure;
  }",15,,917,2,,void
234240,BLOCK,9,,"{
    HandleScope scope(isolate);
    TryCatch bootstrapCatch(isolate);

    auto print_Exception = OnScopeLeave([&]() {
      if (bootstrapCatch.HasCaught()) {
        PrintCaughtException(
            isolate, isolate->GetCurrentContext(), bootstrapCatch);
      }
    });

    // Run the custom main script for fully customized snapshots.
    if (snapshot_type == SnapshotMetadata::Type::kFullyCustomized) {
      Context::Scope context_scope(setup->context());
      Environment* env = setup->env();
#if HAVE_INSPECTOR
        env->InitializeInspector({});
#endif
        if (LoadEnvironment(env, main_script.value()).IsEmpty()) {
          return ExitCode::kGenericUserError;
        }

        // FIXME(joyeecheung): right now running the loop in the snapshot
        // builder might introduce inconsistencies in JS land that need to
        // be synchronized again after snapshot restoration.
        ExitCode exit_code =
            SpinEventLoopInternal(env).FromMaybe(ExitCode::kGeneri...",3,,924,9,,void
234259,BLOCK,-1,,"{
      Context::Scope context_scope(setup->context());
      Environment* env = setup->env();
#if HAVE_INSPECTOR
        env->InitializeInspector({});
#endif
        if (LoadEnvironment(env, main_script.value()).IsEmpty()) {
          return ExitCode::kGenericUserError;
        }

        // FIXME(joyeecheung): right now running the loop in the snapshot
        // builder might introduce inconsistencies in JS land that need to
        // be synchronized again after snapshot restoration.
        ExitCode exit_code =
            SpinEventLoopInternal(env).FromMaybe(ExitCode::kGenericUserError);
        if (exit_code != ExitCode::kNoFailure) {
          return exit_code;
        }
    }",68,,936,2,,void
234283,BLOCK,-1,,"{
          return ExitCode::kGenericUserError;
        }",66,,942,2,,void
234305,BLOCK,-1,,"{
          return exit_code;
        }",48,,951,2,,void
234324,BLOCK,-1,,"{
  SnapshotMetadata::Type snapshot_type =
      static_cast<SnapshotMetadata::Type>(snapshot_type_u8);
  Isolate* isolate = setup->isolate();
  Environment* env = setup->env();
  SnapshotCreator* creator = setup->snapshot_creator();

  {
    HandleScope scope(isolate);
    Local<Context> main_context = setup->context();

    // The default context with only things created by V8.
    Local<Context> default_context = Context::New(isolate);

    // The context used by the vm module.
    Local<Context> vm_context;
    {
      Local<ObjectTemplate> global_template =
          setup->isolate_data()->contextify_global_template();
      CHECK(!global_template.IsEmpty());
      if (!contextify::ContextifyContext::CreateV8Context(
               isolate, global_template, nullptr, nullptr)
               .ToLocal(&vm_context)) {
        return ExitCode::kStartupSnapshotFailure;
      }
    }

    // The Node.js-specific context with primodials, can be used by workers
    // TODO(joyeecheung):...",68,,962,4,,void
234352,BLOCK,9,,"{
    HandleScope scope(isolate);
    Local<Context> main_context = setup->context();

    // The default context with only things created by V8.
    Local<Context> default_context = Context::New(isolate);

    // The context used by the vm module.
    Local<Context> vm_context;
    {
      Local<ObjectTemplate> global_template =
          setup->isolate_data()->contextify_global_template();
      CHECK(!global_template.IsEmpty());
      if (!contextify::ContextifyContext::CreateV8Context(
               isolate, global_template, nullptr, nullptr)
               .ToLocal(&vm_context)) {
        return ExitCode::kStartupSnapshotFailure;
      }
    }

    // The Node.js-specific context with primodials, can be used by workers
    // TODO(joyeecheung): investigate if this can be used by vm contexts
    // without breaking compatibility.
    Local<Context> base_context = NewContext(isolate);
    if (base_context.IsEmpty()) {
      return ExitCode::kBootstrapFailure;
    }
    ResetCont...",3,,969,9,,void
234382,BLOCK,6,,"{
      Local<ObjectTemplate> global_template =
          setup->isolate_data()->contextify_global_template();
      CHECK(!global_template.IsEmpty());
      if (!contextify::ContextifyContext::CreateV8Context(
               isolate, global_template, nullptr, nullptr)
               .ToLocal(&vm_context)) {
        return ExitCode::kStartupSnapshotFailure;
      }
    }",5,,978,6,,void
234419,BLOCK,-1,,"{
        return ExitCode::kStartupSnapshotFailure;
      }",39,,984,2,,void
234437,BLOCK,-1,,"{
      return ExitCode::kBootstrapFailure;
    }",33,,993,2,,void
234443,BLOCK,10,,"{
      Context::Scope context_scope(main_context);

      if (per_process::enabled_debug_list.enabled(DebugCategory::MKSNAPSHOT)) {
        env->ForEachRealm([](Realm* realm) { realm->PrintInfoForSnapshot(); });
        printf(""Environment = %p\n"", env);
      }

      // Serialize the native states
      out->isolate_data_info = setup->isolate_data()->Serialize(creator);
      out->env_info = env->Serialize(creator);

#ifdef NODE_USE_NODE_CODE_CACHE
      // Regenerate all the code cache.
      if (!env->builtin_loader()->CompileAllBuiltins(main_context)) {
        return ExitCode::kGenericUserError;
      }
      env->builtin_loader()->CopyCodeCache(&(out->code_cache));
      for (const auto& item : out->code_cache) {
        std::string size_str = FormatSize(item.data.length);
        per_process::Debug(DebugCategory::MKSNAPSHOT,
                           ""Generated code cache for %d: %s\n"",
                           item.id.c_str(),
                           size_str.c_str()...",5,,998,10,,void
234457,BLOCK,-1,,"{
        env->ForEachRealm([](Realm* realm) { realm->PrintInfoForSnapshot(); });
        printf(""Environment = %p\n"", env);
      }",79,,1001,2,,void
234554,BLOCK,-1,,"{
    return ExitCode::kStartupSnapshotFailure;
  }",52,,1047,2,,void
234620,BLOCK,-1,,"{
    PrintLibuvHandleInformation(env->event_loop(), stderr);
  }",75,,1063,2,,void
234630,BLOCK,-1,,"{
    return ExitCode::kStartupSnapshotFailure;
  }",26,,1066,2,,void
234646,BLOCK,-1,,"{
  SnapshotData data;
  ExitCode exit_code = Generate(&data, args, exec_args, main_script);
  if (exit_code != ExitCode::kNoFailure) {
    return exit_code;
  }
  FormatBlob(out, &data);
  return exit_code;
}",50,,1076,5,,void
234663,BLOCK,-1,,"{
    return exit_code;
  }",42,,1079,2,,void
234678,BLOCK,-1,,<empty>,44,,1089,4,,void
234682,BLOCK,-1,,"{
  switch (type_) {
#define V(PropertyName, NativeTypeName)                                        \
  case EmbedderObjectType::k_##PropertyName: {                                 \
    return #NativeTypeName;                                                    \
  }
    SERIALIZABLE_OBJECT_TYPES(V)
#undef V
    default: { UNREACHABLE(); }
  }
}",53,,1091,1,,void
234685,BLOCK,-1,,"{
#define V(PropertyName, NativeTypeName)                                        \
  case EmbedderObjectType::k_##PropertyName: {                                 \
    return #NativeTypeName;                                                    \
  }
    SERIALIZABLE_OBJECT_TYPES(V)
#undef V
    default: { UNREACHABLE(); }
  }",18,,1092,2,,void
234689,BLOCK,4,,{ UNREACHABLE(); },14,,1099,4,,void
234698,BLOCK,-1,,"{
  if (payload.raw_size == 0) {
    holder->SetAlignedPointerInInternalField(index, nullptr);
    return;
  }
  per_process::Debug(DebugCategory::MKSNAPSHOT,
                     ""Deserialize internal field %d of %p, size=%d\n"",
                     static_cast<int>(index),
                     (*holder),
                     static_cast<int>(payload.raw_size));

  if (payload.raw_size == 0) {
    holder->SetAlignedPointerInInternalField(index, nullptr);
    return;
  }

  DCHECK_EQ(index, BaseObject::kEmbedderType);

  Environment* env_ptr = static_cast<Environment*>(env);
  const InternalFieldInfoBase* info =
      reinterpret_cast<const InternalFieldInfoBase*>(payload.data);
  // TODO(joyeecheung): we can add a constant kNodeEmbedderId to the
  // beginning of every InternalFieldInfoBase to ensure that we don't
  // step on payloads that were not serialized by Node.js.
  switch (info->type) {
#define V(PropertyName, NativeTypeName)                                        \
  case...",47,,1106,5,,void
234705,BLOCK,-1,,"{
    holder->SetAlignedPointerInInternalField(index, nullptr);
    return;
  }",30,,1107,2,,void
234737,BLOCK,-1,,"{
    holder->SetAlignedPointerInInternalField(index, nullptr);
    return;
  }",30,,1117,2,,void
234768,BLOCK,-1,,"{
#define V(PropertyName, NativeTypeName)                                        \
  case EmbedderObjectType::k_##PropertyName: {                                 \
    per_process::Debug(DebugCategory::MKSNAPSHOT,                              \
                       ""Object %p is %s\n"",                                    \
                       (*holder),                                              \
                       #NativeTypeName);                                       \
    env_ptr->EnqueueDeserializeRequest(                                        \
        NativeTypeName::Deserialize,                                           \
        holder,                                                                \
        index,                                                                 \
        info->Copy<NativeTypeName::InternalFieldInfo>());                      \
    break;                                                                     \
  }
    SERIALIZABLE_OB...",23,,1130,2,,void
234772,BLOCK,4,,"{
      // This should only be reachable during development when trying to
      // deserialize a snapshot blob built by a version of Node.js that
      // has more recognizable EmbedderObjectTypes than the deserializing
      // Node.js binary.
      fprintf(stderr,
              ""Unknown embedder object type %"" PRIu8 "", possibly caused by ""
              ""mismatched Node.js versions\n"",
              static_cast<uint8_t>(info->type));
      ABORT();
    }",14,,1146,4,,void
234781,BLOCK,-1,,"{
  // We only do one serialization for the kEmbedderType slot, the result
  // contains everything necessary for deserializing the entire object,
  // including the fields whose index is bigger than kEmbedderType
  // (most importantly, BaseObject::kSlot).
  // For Node.js this design is enough for all the native binding that are
  // serializable.
  if (index != BaseObject::kEmbedderType || !BaseObject::IsBaseObject(holder)) {
    return StartupData{nullptr, 0};
  }

  per_process::Debug(DebugCategory::MKSNAPSHOT,
                     ""Serialize internal field, index=%d, holder=%p\n"",
                     static_cast<int>(index),
                     *holder);

  void* native_ptr =
      holder->GetAlignedPointerFromInternalField(BaseObject::kSlot);
  per_process::Debug(DebugCategory::MKSNAPSHOT, ""native = %p\n"", native_ptr);
  DCHECK(static_cast<BaseObject*>(native_ptr)->is_snapshotable());
  SnapshotableObject* obj = static_cast<SnapshotableObject*>(native_ptr);

  per_process::...",59,,1162,4,,void
234795,BLOCK,-1,,"{
    return StartupData{nullptr, 0};
  }",80,,1169,2,,void
234896,BLOCK,-1,,"{
  HandleScope scope(realm->isolate());
  Local<Context> context = realm->context();
  uint32_t i = 0;
  realm->ForEachBaseObject([&](BaseObject* obj) {
    // If there are any BaseObjects that are not snapshotable left
    // during context serialization, V8 would crash due to unregistered
    // global handles and print detailed information about them.
    if (!obj->is_snapshotable()) {
      return;
    }
    SnapshotableObject* ptr = static_cast<SnapshotableObject*>(obj);

    std::string type_name = ptr->GetTypeName();
    per_process::Debug(DebugCategory::MKSNAPSHOT,
                       ""Serialize snapshotable object %i (%p), ""
                       ""object=%p, type=%s\n"",
                       static_cast<int>(i),
                       ptr,
                       *(ptr->object()),
                       type_name);

    if (ptr->PrepareForSerialization(context, creator)) {
      SnapshotIndex index = creator->AddData(context, obj->object());
      per_process::Debug(De...",61,,1199,4,,void
234925,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Local<Value> process_obj = args[0];
  Local<Value> require_fn = args[1];
  Local<Value> runcjs_fn = args[2];
  CHECK(process_obj->IsObject());
  CHECK(require_fn->IsFunction());
  CHECK(runcjs_fn->IsFunction());

  const node::StartExecutionCallback& callback = env->embedder_entry_point();
  node::StartExecutionCallbackInfo info{process_obj.As<Object>(),
                                        require_fn.As<Function>(),
                                        runcjs_fn.As<Function>()};
  MaybeLocal<Value> retval = callback(info);
  if (!retval.IsEmpty()) {
    args.GetReturnValue().Set(retval.ToLocalChecked());
  }
}",76,,1232,2,,void
235013,BLOCK,-1,,"{
    args.GetReturnValue().Set(retval.ToLocalChecked());
  }",26,,1246,2,,void
235029,BLOCK,-1,,"{
  CHECK(args[0]->IsString());
  Local<String> filename = args[0].As<String>();
  Local<String> source = args[1].As<String>();
  Isolate* isolate = args.GetIsolate();
  Local<Context> context = isolate->GetCurrentContext();
  ScriptOrigin origin(isolate, filename, 0, 0, true);
  // TODO(joyeecheung): do we need all of these? Maybe we would want a less
  // internal version of them.
  std::vector<Local<String>> parameters = {
      FIXED_ONE_BYTE_STRING(isolate, ""require""),
      FIXED_ONE_BYTE_STRING(isolate, ""__filename""),
      FIXED_ONE_BYTE_STRING(isolate, ""__dirname""),
  };
  ScriptCompiler::Source script_source(source, origin);
  Local<Function> fn;
  if (ScriptCompiler::CompileFunction(context,
                                      &script_source,
                                      parameters.size(),
                                      parameters.data(),
                                      0,
                                      nullptr,
                             ...",68,,1251,2,,void
235130,BLOCK,-1,,"{
    args.GetReturnValue().Set(fn);
  }",26,,1274,2,,void
235143,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(env->snapshot_serialize_callback().IsEmpty());
  CHECK(args[0]->IsFunction());
  env->set_snapshot_serialize_callback(args[0].As<Function>());
}",68,,1279,2,,void
235181,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(env->snapshot_deserialize_callback().IsEmpty());
  CHECK(args[0]->IsFunction());
  env->set_snapshot_deserialize_callback(args[0].As<Function>());
}",70,,1286,2,,void
235219,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(env->snapshot_deserialize_main().IsEmpty());
  CHECK(args[0]->IsFunction());
  env->set_snapshot_deserialize_main(args[0].As<Function>());
}",74,,1293,2,,void
235260,BLOCK,-1,,"{
  return kAnonymousMainPath;
}",36,,1302,1,,void
235270,BLOCK,-1,,"{
  if (info == nullptr) {
    object
        ->Set(
            realm->context(),
            FIXED_ONE_BYTE_STRING(realm->isolate(), ""isBuildingSnapshotBuffer""),
            is_building_snapshot_buffer_.GetJSArray())
        .Check();
  } else {
    is_building_snapshot_buffer_.Deserialize(realm->context());
  }
  // Reset the status according to the current state of the realm.
  bool is_building_snapshot = realm->isolate_data()->is_building_snapshot();
  DCHECK_IMPLIES(is_building_snapshot,
                 realm->isolate_data()->snapshot_data() == nullptr);
  is_building_snapshot_buffer_[0] = is_building_snapshot ? 1 : 0;
  is_building_snapshot_buffer_.MakeWeak();
}",63,,1315,4,,void
235275,BLOCK,-1,,"{
    object
        ->Set(
            realm->context(),
            FIXED_ONE_BYTE_STRING(realm->isolate(), ""isBuildingSnapshotBuffer""),
            is_building_snapshot_buffer_.GetJSArray())
        .Check();
  }",24,,1316,2,,void
235298,BLOCK,-1,,"{
    is_building_snapshot_buffer_.Deserialize(realm->context());
  }",10,,1323,1,,void
235345,BLOCK,-1,,"{
  DCHECK_NULL(internal_field_info_);
  internal_field_info_ = InternalFieldInfoBase::New<InternalFieldInfo>(type());
  internal_field_info_->is_building_snapshot_buffer =
      is_building_snapshot_buffer_.Serialize(context, creator);
  // Return true because we need to maintain the reference to the binding from
  // JS land.
  return true;
}",73,,1335,3,,void
235372,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  InternalFieldInfo* info = internal_field_info_;
  internal_field_info_ = nullptr;
  return info;
}",58,,1345,2,,void
235394,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  v8::HandleScope scope(context->GetIsolate());
  Realm* realm = Realm::GetCurrent(context);
  // Recreate the buffer in the constructor.
  InternalFieldInfo* casted_info = static_cast<InternalFieldInfo*>(info);
  BindingData* binding =
      realm->AddBindingData<BindingData>(context, holder, casted_info);
  CHECK_NOT_NULL(binding);
}",60,,1355,5,,void
235440,BLOCK,-1,,"{
  tracker->TrackField(""is_building_snapshot_buffer"",
                      is_building_snapshot_buffer_);
}",60,,1366,2,,void
235454,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(context);
  realm->AddBindingData<BindingData>(context, target);
}",45,,1374,5,,void
235478,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();
  SetMethod(isolate, target, ""runEmbedderEntryPoint"", RunEmbedderEntryPoint);
  SetMethod(isolate, target, ""compileSerializeMain"", CompileSerializeMain);
  SetMethod(isolate, target, ""setSerializeCallback"", SetSerializeCallback);
  SetMethod(isolate, target, ""setDeserializeCallback"", SetDeserializeCallback);
  SetMethod(isolate,
            target,
            ""setDeserializeMainFunction"",
            SetDeserializeMainFunction);
  target->Set(FIXED_ONE_BYTE_STRING(isolate, ""anonymousMainPath""),
              OneByteString(isolate, kAnonymousMainPath));
}",63,,1380,3,,void
235525,BLOCK,-1,,"{
  registry->Register(RunEmbedderEntryPoint);
  registry->Register(CompileSerializeMain);
  registry->Register(SetSerializeCallback);
  registry->Register(SetDeserializeCallback);
  registry->Register(SetDeserializeMainFunction);
}",70,,1394,2,,void
235564,BLOCK,-1,,<empty>,1,,1,1,,ANY
235583,BLOCK,-1,,<empty>,1,,1,1,,ANY
235608,BLOCK,-1,,<empty>,1,,1,1,,ANY
235614,BLOCK,-1,,"{
  SocketAddress addr;
  int len = sizeof(sockaddr_storage);
  if (fn(&handle, addr.storage(), &len) == 0)
    CHECK_EQ(static_cast<size_t>(len), addr.length());
  else
    addr.storage()->sa_family = 0;
  return addr;
}",51,,29,3,,void
235633,BLOCK,-1,,<empty>,5,,33,2,,void
235643,BLOCK,-1,,<empty>,5,,35,1,,void
235661,BLOCK,-1,,"{
  switch (family) {
    case AF_INET:
      return uv_ip4_addr(
          host,
          port,
          reinterpret_cast<sockaddr_in*>(addr)) == 0;
    case AF_INET6:
      return uv_ip6_addr(
          host,
          port,
          reinterpret_cast<sockaddr_in6*>(addr)) == 0;
    default:
      UNREACHABLE();
  }
}",29,,44,5,,void
235664,BLOCK,-1,,"{
    case AF_INET:
      return uv_ip4_addr(
          host,
          port,
          reinterpret_cast<sockaddr_in*>(addr)) == 0;
    case AF_INET6:
      return uv_ip6_addr(
          host,
          port,
          reinterpret_cast<sockaddr_in6*>(addr)) == 0;
    default:
      UNREACHABLE();
  }",19,,45,2,,void
235695,BLOCK,-1,,"{
  return New(AF_INET, host, port, addr) || New(AF_INET6, host, port, addr);
}",26,,64,4,,void
235715,BLOCK,-1,,"{
  return ToSockAddr(family, host, port,
                    reinterpret_cast<sockaddr_storage*>(addr->storage()));
}",26,,72,5,,void
235731,BLOCK,-1,,"{
  size_t hash = 0;
  switch (addr.family()) {
    case AF_INET: {
      const sockaddr_in* ipv4 =
          reinterpret_cast<const sockaddr_in*>(addr.raw());
      hash_combine(&hash, ipv4->sin_port, ipv4->sin_addr.s_addr);
      break;
    }
    case AF_INET6: {
      const sockaddr_in6* ipv6 =
          reinterpret_cast<const sockaddr_in6*>(addr.raw());
      const uint64_t* a =
          reinterpret_cast<const uint64_t*>(&ipv6->sin6_addr);
      hash_combine(&hash, ipv6->sin6_port, a[0], a[1]);
      break;
    }
    default:
      UNREACHABLE();
  }
  return hash;
}",73,,77,2,,void
235741,BLOCK,-1,,"{
    case AF_INET: {
      const sockaddr_in* ipv4 =
          reinterpret_cast<const sockaddr_in*>(addr.raw());
      hash_combine(&hash, ipv4->sin_port, ipv4->sin_addr.s_addr);
      break;
    }
    case AF_INET6: {
      const sockaddr_in6* ipv6 =
          reinterpret_cast<const sockaddr_in6*>(addr.raw());
      const uint64_t* a =
          reinterpret_cast<const uint64_t*>(&ipv6->sin6_addr);
      hash_combine(&hash, ipv6->sin6_port, a[0], a[1]);
      break;
    }
    default:
      UNREACHABLE();
  }",26,,79,2,,void
235744,BLOCK,3,,"{
      const sockaddr_in* ipv4 =
          reinterpret_cast<const sockaddr_in*>(addr.raw());
      hash_combine(&hash, ipv4->sin_port, ipv4->sin_addr.s_addr);
      break;
    }",19,,80,3,,void
235768,BLOCK,6,,"{
      const sockaddr_in6* ipv6 =
          reinterpret_cast<const sockaddr_in6*>(addr.raw());
      const uint64_t* a =
          reinterpret_cast<const uint64_t*>(&ipv6->sin6_addr);
      hash_combine(&hash, ipv6->sin6_port, a[0], a[1]);
      break;
    }",20,,86,6,,void
235808,BLOCK,-1,,"{
  return FromUVHandle(uv_tcp_getsockname, handle);
}",67,,100,2,,void
235817,BLOCK,-1,,"{
  return FromUVHandle(uv_udp_getsockname, handle);
}",67,,104,2,,void
235826,BLOCK,-1,,"{
  return FromUVHandle(uv_tcp_getpeername, handle);
}",67,,108,2,,void
235835,BLOCK,-1,,"{
  return FromUVHandle(uv_udp_getpeername, handle);
}",67,,112,2,,void
235862,BLOCK,-1,,"{
  const sockaddr_in* one_in =
      reinterpret_cast<const sockaddr_in*>(one.data());
  const sockaddr_in* two_in =
      reinterpret_cast<const sockaddr_in*>(two.data());
  return memcmp(&one_in->sin_addr, &two_in->sin_addr, sizeof(uint32_t)) == 0;
}",31,,121,3,,void
235900,BLOCK,-1,,"{
  const sockaddr_in6* one_in =
      reinterpret_cast<const sockaddr_in6*>(one.data());
  const sockaddr_in6* two_in =
      reinterpret_cast<const sockaddr_in6*>(two.data());
  return memcmp(&one_in->sin6_addr, &two_in->sin6_addr, 16) == 0;
}",31,,131,3,,void
235937,BLOCK,-1,,"{
  const sockaddr_in* check_ipv4 =
      reinterpret_cast<const sockaddr_in*>(ipv4.data());
  const sockaddr_in6* check_ipv6 =
      reinterpret_cast<const sockaddr_in6*>(ipv6.data());

  const uint8_t* ptr =
      reinterpret_cast<const uint8_t*>(&check_ipv6->sin6_addr);

  return memcmp(ptr, mask, sizeof(mask)) == 0 &&
         memcmp(ptr + sizeof(mask),
                &check_ipv4->sin_addr,
                sizeof(uint32_t)) == 0;
}",32,,141,3,,void
235992,BLOCK,-1,,"{
  const sockaddr_in* one_in =
      reinterpret_cast<const sockaddr_in*>(one.data());
  const sockaddr_in* two_in =
      reinterpret_cast<const sockaddr_in*>(two.data());
  const uint32_t s_addr_one = ntohl(one_in->sin_addr.s_addr);
  const uint32_t s_addr_two = ntohl(two_in->sin_addr.s_addr);

  if (s_addr_one < s_addr_two)
    return SocketAddress::CompareResult::LESS_THAN;
  else if (s_addr_one == s_addr_two)
    return SocketAddress::CompareResult::SAME;
  else
    return SocketAddress::CompareResult::GREATER_THAN;
}",31,,158,3,,void
236033,BLOCK,-1,,<empty>,5,,167,2,,void
236041,BLOCK,-1,,<empty>,8,,168,1,,void
236046,BLOCK,-1,,<empty>,5,,169,2,,void
236054,BLOCK,-1,,<empty>,5,,171,1,,void
236066,BLOCK,-1,,"{
  const sockaddr_in6* one_in =
      reinterpret_cast<const sockaddr_in6*>(one.data());
  const sockaddr_in6* two_in =
      reinterpret_cast<const sockaddr_in6*>(two.data());
  int ret = memcmp(&one_in->sin6_addr, &two_in->sin6_addr, 16);
  if (ret < 0)
    return SocketAddress::CompareResult::LESS_THAN;
  else if (ret > 0)
    return SocketAddress::CompareResult::GREATER_THAN;
  return SocketAddress::CompareResult::SAME;
}",31,,176,3,,void
236102,BLOCK,-1,,<empty>,5,,183,2,,void
236110,BLOCK,-1,,<empty>,8,,184,1,,void
236115,BLOCK,-1,,<empty>,5,,185,2,,void
236133,BLOCK,-1,,"{
  const sockaddr_in* ipv4_in =
      reinterpret_cast<const sockaddr_in*>(ipv4.data());
  const sockaddr_in6 * ipv6_in =
      reinterpret_cast<const sockaddr_in6*>(ipv6.data());

  const uint8_t* ptr =
      reinterpret_cast<const uint8_t*>(&ipv6_in->sin6_addr);

  if (memcmp(ptr, mask, sizeof(mask)) != 0)
    return SocketAddress::CompareResult::NOT_COMPARABLE;

  int ret = memcmp(
      &ipv4_in->sin_addr,
      ptr + sizeof(mask),
      sizeof(uint32_t));

  if (ret < 0)
    return SocketAddress::CompareResult::LESS_THAN;
  else if (ret > 0)
    return SocketAddress::CompareResult::GREATER_THAN;
  return SocketAddress::CompareResult::SAME;
}",32,,191,3,,void
236169,BLOCK,-1,,<empty>,5,,201,2,,void
236194,BLOCK,-1,,<empty>,5,,209,2,,void
236202,BLOCK,-1,,<empty>,8,,210,1,,void
236207,BLOCK,-1,,<empty>,5,,211,2,,void
236226,BLOCK,-1,,"{
  uint32_t mask = ((1ull << prefix) - 1) << (32 - prefix);

  const sockaddr_in* ip_in =
      reinterpret_cast<const sockaddr_in*>(ip.data());
  const sockaddr_in* net_in =
      reinterpret_cast<const sockaddr_in*>(net.data());

  return (htonl(ip_in->sin_addr.s_addr) & mask) ==
         (htonl(net_in->sin_addr.s_addr) & mask);
}",17,,218,4,,void
236281,BLOCK,-1,,"{
  // Special case, if prefix == 128, then just do a
  // straight comparison.
  if (prefix == 128)
    return compare_ipv6(ip, net) == SocketAddress::CompareResult::SAME;

  uint8_t r = prefix % 8;
  int len = (prefix - r) / 8;
  uint8_t mask = ((1 << r) - 1) << (8 - r);

  const sockaddr_in6* ip_in =
      reinterpret_cast<const sockaddr_in6*>(ip.data());
  const sockaddr_in6* net_in =
      reinterpret_cast<const sockaddr_in6*>(net.data());

  if (memcmp(&ip_in->sin6_addr, &net_in->sin6_addr, len) != 0)
    return false;

  const uint8_t* p1 = reinterpret_cast<const uint8_t*>(
      ip_in->sin6_addr.s6_addr);
  const uint8_t* p2 = reinterpret_cast<const uint8_t*>(
      net_in->sin6_addr.s6_addr);

  return (p1[len] & mask) == (p2[len] & mask);
}",17,,233,4,,void
236286,BLOCK,-1,,<empty>,5,,237,2,,void
236354,BLOCK,-1,,<empty>,5,,249,2,,void
236395,BLOCK,-1,,"{

  if (prefix == 128)
    return compare_ipv4_ipv6(ip, net) == SocketAddress::CompareResult::SAME;

  uint8_t r = prefix % 8;
  int len = (prefix - r) / 8;
  uint8_t mask = ((1 << r) - 1) << (8 - r);

  const sockaddr_in* ip_in =
      reinterpret_cast<const sockaddr_in*>(ip.data());
  const sockaddr_in6* net_in =
      reinterpret_cast<const sockaddr_in6*>(net.data());

  uint8_t ip_mask[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff, 0, 0, 0, 0};
  uint8_t* ptr = ip_mask;
  memcpy(ptr + 12, &ip_in->sin_addr, 4);

  if (memcmp(ptr, &net_in->sin6_addr, len) != 0)
    return false;

  ptr += len;
  const uint8_t* p2 = reinterpret_cast<const uint8_t*>(
      net_in->sin6_addr.s6_addr);

  return (ptr[0] & mask) == (p2[len] & mask);
}",17,,262,4,,void
236400,BLOCK,-1,,<empty>,5,,265,2,,void
236498,BLOCK,-1,,<empty>,5,,281,2,,void
236532,BLOCK,-1,,"{
  if (prefix == 32)
    return compare_ipv4_ipv6(net, ip) == SocketAddress::CompareResult::SAME;

  uint32_t m = ((1ull << prefix) - 1) << (32 - prefix);

  const sockaddr_in6* ip_in =
      reinterpret_cast<const sockaddr_in6*>(ip.data());
  const sockaddr_in* net_in =
      reinterpret_cast<const sockaddr_in*>(net.data());

  const uint8_t* ptr =
      reinterpret_cast<const uint8_t*>(&ip_in->sin6_addr);

  if (memcmp(ptr, mask, sizeof(mask)) != 0)
    return false;

  ptr += sizeof(mask);
  uint32_t check = ReadUint32BE(ptr);

  return (check & m) == (htonl(net_in->sin_addr.s_addr) & m);
}",17,,293,4,,void
236537,BLOCK,-1,,<empty>,5,,295,2,,void
236595,BLOCK,-1,,<empty>,5,,308,2,,void
236624,BLOCK,-1,,"{
  switch (family()) {
    case AF_INET:
      switch (other.family()) {
        case AF_INET: return is_match_ipv4(*this, other);
        case AF_INET6: return is_match_ipv4_ipv6(*this, other);
      }
      break;
    case AF_INET6:
      switch (other.family()) {
        case AF_INET: return is_match_ipv4_ipv6(other, *this);
        case AF_INET6: return is_match_ipv6(*this, other);
      }
      break;
  }
  return false;
}",64,,321,2,,void
236627,BLOCK,-1,,"{
    case AF_INET:
      switch (other.family()) {
        case AF_INET: return is_match_ipv4(*this, other);
        case AF_INET6: return is_match_ipv4_ipv6(*this, other);
      }
      break;
    case AF_INET6:
      switch (other.family()) {
        case AF_INET: return is_match_ipv4_ipv6(other, *this);
        case AF_INET6: return is_match_ipv6(*this, other);
      }
      break;
  }",21,,322,2,,void
236635,BLOCK,-1,,"{
        case AF_INET: return is_match_ipv4(*this, other);
        case AF_INET6: return is_match_ipv4_ipv6(*this, other);
      }",31,,324,2,,void
236658,BLOCK,-1,,"{
        case AF_INET: return is_match_ipv4_ipv6(other, *this);
        case AF_INET6: return is_match_ipv6(*this, other);
      }",31,,330,2,,void
236680,BLOCK,-1,,"{
  switch (family()) {
    case AF_INET:
      switch (other.family()) {
        case AF_INET: return compare_ipv4(*this, other);
        case AF_INET6: return compare_ipv4_ipv6(*this, other);
      }
      break;
    case AF_INET6:
      switch (other.family()) {
        case AF_INET: {
          CompareResult c = compare_ipv4_ipv6(other, *this);
          switch (c) {
            case SocketAddress::CompareResult::NOT_COMPARABLE:
              // Fall through
            case SocketAddress::CompareResult::SAME:
              return c;
            case SocketAddress::CompareResult::GREATER_THAN:
              return SocketAddress::CompareResult::LESS_THAN;
            case SocketAddress::CompareResult::LESS_THAN:
              return SocketAddress::CompareResult::GREATER_THAN;
          }
          break;
        }
        case AF_INET6: return compare_ipv6(*this, other);
      }
      break;
  }
  return SocketAddress::CompareResult::NOT_COMPARABLE;
}",39,,340,2,,void
236683,BLOCK,-1,,"{
    case AF_INET:
      switch (other.family()) {
        case AF_INET: return compare_ipv4(*this, other);
        case AF_INET6: return compare_ipv4_ipv6(*this, other);
      }
      break;
    case AF_INET6:
      switch (other.family()) {
        case AF_INET: {
          CompareResult c = compare_ipv4_ipv6(other, *this);
          switch (c) {
            case SocketAddress::CompareResult::NOT_COMPARABLE:
              // Fall through
            case SocketAddress::CompareResult::SAME:
              return c;
            case SocketAddress::CompareResult::GREATER_THAN:
              return SocketAddress::CompareResult::LESS_THAN;
            case SocketAddress::CompareResult::LESS_THAN:
              return SocketAddress::CompareResult::GREATER_THAN;
          }
          break;
        }
        case AF_INET6: return compare_ipv6(*this, other);
      }
      break;
  }",21,,341,2,,void
236691,BLOCK,-1,,"{
        case AF_INET: return compare_ipv4(*this, other);
        case AF_INET6: return compare_ipv4_ipv6(*this, other);
      }",31,,343,2,,void
236714,BLOCK,-1,,"{
        case AF_INET: {
          CompareResult c = compare_ipv4_ipv6(other, *this);
          switch (c) {
            case SocketAddress::CompareResult::NOT_COMPARABLE:
              // Fall through
            case SocketAddress::CompareResult::SAME:
              return c;
            case SocketAddress::CompareResult::GREATER_THAN:
              return SocketAddress::CompareResult::LESS_THAN;
            case SocketAddress::CompareResult::LESS_THAN:
              return SocketAddress::CompareResult::GREATER_THAN;
          }
          break;
        }
        case AF_INET6: return compare_ipv6(*this, other);
      }",31,,349,2,,void
236717,BLOCK,3,,"{
          CompareResult c = compare_ipv4_ipv6(other, *this);
          switch (c) {
            case SocketAddress::CompareResult::NOT_COMPARABLE:
              // Fall through
            case SocketAddress::CompareResult::SAME:
              return c;
            case SocketAddress::CompareResult::GREATER_THAN:
              return SocketAddress::CompareResult::LESS_THAN;
            case SocketAddress::CompareResult::LESS_THAN:
              return SocketAddress::CompareResult::GREATER_THAN;
          }
          break;
        }",23,,350,3,,void
236727,BLOCK,-1,,"{
            case SocketAddress::CompareResult::NOT_COMPARABLE:
              // Fall through
            case SocketAddress::CompareResult::SAME:
              return c;
            case SocketAddress::CompareResult::GREATER_THAN:
              return SocketAddress::CompareResult::LESS_THAN;
            case SocketAddress::CompareResult::LESS_THAN:
              return SocketAddress::CompareResult::GREATER_THAN;
          }",22,,352,2,,void
236786,BLOCK,-1,,"{

  switch (family()) {
    case AF_INET:
      switch (other.family()) {
        case AF_INET: return in_network_ipv4(*this, other, prefix);
        case AF_INET6: return in_network_ipv4_ipv6(*this, other, prefix);
      }
      break;
    case AF_INET6:
      switch (other.family()) {
        case AF_INET: return in_network_ipv6_ipv4(*this, other, prefix);
        case AF_INET6: return in_network_ipv6(*this, other, prefix);
      }
      break;
  }

  return false;
}",23,,373,3,,void
236789,BLOCK,-1,,"{
    case AF_INET:
      switch (other.family()) {
        case AF_INET: return in_network_ipv4(*this, other, prefix);
        case AF_INET6: return in_network_ipv4_ipv6(*this, other, prefix);
      }
      break;
    case AF_INET6:
      switch (other.family()) {
        case AF_INET: return in_network_ipv6_ipv4(*this, other, prefix);
        case AF_INET6: return in_network_ipv6(*this, other, prefix);
      }
      break;
  }",21,,375,2,,void
236797,BLOCK,-1,,"{
        case AF_INET: return in_network_ipv4(*this, other, prefix);
        case AF_INET6: return in_network_ipv4_ipv6(*this, other, prefix);
      }",31,,377,2,,void
236822,BLOCK,-1,,"{
        case AF_INET: return in_network_ipv6_ipv4(*this, other, prefix);
        case AF_INET6: return in_network_ipv6(*this, other, prefix);
      }",31,,383,2,,void
236846,BLOCK,-1,,<empty>,23,,395,2,,void
236851,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  std::unique_ptr<Rule> rule =
      std::make_unique<SocketAddressRule>(address);
  rules_.emplace_front(std::move(rule));
  address_rules_[*address.get()] = rules_.begin();
}",52,,398,2,,void
236895,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  auto it = address_rules_.find(*address.get());
  if (it != std::end(address_rules_)) {
    rules_.erase(it->second);
    address_rules_.erase(it);
  }
}",52,,407,2,,void
236919,BLOCK,-1,,"{
    rules_.erase(it->second);
    address_rules_.erase(it);
  }",39,,410,2,,void
236937,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  std::unique_ptr<Rule> rule =
      std::make_unique<SocketAddressRangeRule>(start, end);
  rules_.emplace_front(std::move(rule));
}",48,,418,3,,void
236973,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  std::unique_ptr<Rule> rule =
      std::make_unique<SocketAddressMaskRule>(network, prefix);
  rules_.emplace_front(std::move(rule));
}",17,,427,3,,void
237008,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  for (const auto& rule : rules_) {
    if (rule->Apply(address))
      return true;
  }
  return parent_ ? parent_->Apply(address) : false;
}",52,,435,2,,void
237015,BLOCK,-1,,"{
    if (rule->Apply(address))
      return true;
  }",35,,437,3,,void
237022,BLOCK,-1,,<empty>,7,,439,2,,void
237038,BLOCK,-1,,<empty>,25,,446,2,,void
237044,BLOCK,-1,,<empty>,17,,452,3,,void
237050,BLOCK,-1,,<empty>,23,,458,3,,void
237055,BLOCK,-1,,"{
  return this->address->is_match(*address.get());
}",52,,461,2,,void
237071,BLOCK,-1,,"{
  std::string ret = ""Address: "";
  ret += address->family() == AF_INET ? ""IPv4"" : ""IPv6"";
  ret += "" "";
  ret += address->address();
  return ret;
}",67,,465,1,,void
237102,BLOCK,-1,,"{
  return *address.get() >= *start.get() &&
         *address.get() <= *end.get();
}",52,,474,2,,void
237130,BLOCK,-1,,"{
  std::string ret = ""Range: "";
  ret += start->family() == AF_INET ? ""IPv4"" : ""IPv6"";
  ret += "" "";
  ret += start->address();
  ret += ""-"";
  ret += end->address();
  return ret;
}",72,,479,1,,void
237170,BLOCK,-1,,"{
  return address->is_in_network(*network.get(), prefix);
}",52,,490,2,,void
237185,BLOCK,-1,,"{
  std::string ret = ""Subnet: "";
  ret += network->family() == AF_INET ? ""IPv4"" : ""IPv6"";
  ret += "" "";
  ret += network->address();
  ret += ""/"" + std::to_string(prefix);
  return ret;
}",71,,494,1,,void
237225,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  std::vector<Local<Value>> rules;
  if (!ListRules(env, &rules))
    return MaybeLocal<Array>();
  return Array::New(env->isolate(), rules.data(), rules.size());
}",71,,503,2,,void
237244,BLOCK,-1,,<empty>,5,,507,2,,void
237269,BLOCK,-1,,"{
  if (parent_ && !parent_->ListRules(env, rules))
    return false;
  for (const auto& rule : rules_) {
    Local<Value> str;
    if (!rule->ToV8String(env).ToLocal(&str))
      return false;
    rules->push_back(str);
  }
  return true;
}",47,,513,3,,void
237280,BLOCK,-1,,<empty>,5,,515,2,,void
237286,BLOCK,-1,,"{
    Local<Value> str;
    if (!rule->ToV8String(env).ToLocal(&str))
      return false;
    rules->push_back(str);
  }",35,,516,3,,void
237304,BLOCK,-1,,<empty>,7,,519,2,,void
237318,BLOCK,-1,,"{
  tracker->TrackField(""rules"", rules_);
}",77,,525,2,,void
237329,BLOCK,-1,,"{
  tracker->TrackField(""address"", address);
}",41,,530,2,,void
237340,BLOCK,-1,,"{
  tracker->TrackField(""start"", start);
  tracker->TrackField(""end"", end);
}",41,,535,2,,void
237357,BLOCK,-1,,"{
  tracker->TrackField(""network"", network);
}",41,,541,2,,void
237370,BLOCK,-1,,"{
  MakeWeak();
}",40,,550,4,,void
237376,BLOCK,-1,,"{
  Local<Object> obj;
  if (!env->blocklist_constructor_template()
          ->InstanceTemplate()
          ->NewInstance(env->context()).ToLocal(&obj)) {
    return BaseObjectPtr<SocketAddressBlockListWrap>();
  }
  BaseObjectPtr<SocketAddressBlockListWrap> wrap =
      MakeBaseObject<SocketAddressBlockListWrap>(env, obj);
  CHECK(wrap);
  return wrap;
}",23,,555,2,,void
237403,BLOCK,-1,,"{
    return BaseObjectPtr<SocketAddressBlockListWrap>();
  }",56,,559,2,,void
237428,BLOCK,-1,,"{
  Local<Object> obj;
  if (!env->blocklist_constructor_template()
          ->InstanceTemplate()
          ->NewInstance(env->context()).ToLocal(&obj)) {
    return BaseObjectPtr<SocketAddressBlockListWrap>();
  }
  BaseObjectPtr<SocketAddressBlockListWrap> wrap =
      MakeBaseObject<SocketAddressBlockListWrap>(
          env,
          obj,
          std::move(blocklist));
  CHECK(wrap);
  return wrap;
}",56,,570,3,,void
237455,BLOCK,-1,,"{
    return BaseObjectPtr<SocketAddressBlockListWrap>();
  }",56,,574,2,,void
237484,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);
  new SocketAddressBlockListWrap(env, args.This());
}",46,,587,2,,void
237509,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  SocketAddressBlockListWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK(SocketAddressBase::HasInstance(env, args[0]));
  SocketAddressBase* addr;
  ASSIGN_OR_RETURN_UNWRAP(&addr, args[0]);

  wrap->blocklist_->AddSocketAddress(addr->address());

  args.GetReturnValue().Set(true);
}",46,,594,2,,void
237564,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  SocketAddressBlockListWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK(SocketAddressBase::HasInstance(env, args[0]));
  CHECK(SocketAddressBase::HasInstance(env, args[1]));

  SocketAddressBase* start_addr;
  SocketAddressBase* end_addr;
  ASSIGN_OR_RETURN_UNWRAP(&start_addr, args[0]);
  ASSIGN_OR_RETURN_UNWRAP(&end_addr, args[1]);

  // Starting address must come before the end address
  if (*start_addr->address().get() > *end_addr->address().get())
    return args.GetReturnValue().Set(false);

  wrap->blocklist_->AddSocketAddressRange(
      start_addr->address(),
      end_addr->address());

  args.GetReturnValue().Set(true);
}",46,,609,2,,void
237631,BLOCK,-1,,<empty>,5,,624,2,,void
237667,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  SocketAddressBlockListWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK(SocketAddressBase::HasInstance(env, args[0]));
  CHECK(args[1]->IsInt32());

  SocketAddressBase* addr;
  ASSIGN_OR_RETURN_UNWRAP(&addr, args[0]);

  int32_t prefix;
  if (!args[1]->Int32Value(env->context()).To(&prefix)) {
    return;
  }

  CHECK_IMPLIES(addr->address()->family() == AF_INET, prefix <= 32);
  CHECK_IMPLIES(addr->address()->family() == AF_INET6, prefix <= 128);
  CHECK_GE(prefix, 0);

  wrap->blocklist_->AddSocketAddressMask(addr->address(), prefix);

  args.GetReturnValue().Set(true);
}",46,,634,2,,void
237725,BLOCK,-1,,"{
    return;
  }",57,,646,2,,void
237779,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  SocketAddressBlockListWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK(SocketAddressBase::HasInstance(env, args[0]));
  SocketAddressBase* addr;
  ASSIGN_OR_RETURN_UNWRAP(&addr, args[0]);

  args.GetReturnValue().Set(wrap->blocklist_->Apply(addr->address()));
}",46,,660,2,,void
237833,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  SocketAddressBlockListWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  Local<Array> rules;
  if (wrap->blocklist_->ListRules(env).ToLocal(&rules))
    args.GetReturnValue().Set(rules);
}",46,,673,2,,void
237868,BLOCK,-1,,<empty>,5,,679,2,,void
237881,BLOCK,-1,,"{
  blocklist_->MemoryInfo(tracker);
}",75,,682,2,,void
237890,BLOCK,-1,,"{
  return std::make_unique<TransferData>(this);
}",55,,687,1,,void
237904,BLOCK,-1,,"{
  return GetConstructorTemplate(env)->HasInstance(value);
}",25,,693,3,,void
237916,BLOCK,-1,,"{
  Local<FunctionTemplate> tmpl = env->blocklist_constructor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, SocketAddressBlockListWrap::New);
    tmpl->SetClassName(FIXED_ONE_BYTE_STRING(env->isolate(), ""BlockList""));
    tmpl->InstanceTemplate()->SetInternalFieldCount(kInternalFieldCount);
    SetProtoMethod(isolate, tmpl, ""addAddress"", AddAddress);
    SetProtoMethod(isolate, tmpl, ""addRange"", AddRange);
    SetProtoMethod(isolate, tmpl, ""addSubnet"", AddSubnet);
    SetProtoMethod(isolate, tmpl, ""check"", Check);
    SetProtoMethod(isolate, tmpl, ""getRules"", GetRules);
    env->set_blocklist_constructor_template(tmpl);
  }
  return tmpl;
}",23,,698,2,,void
237932,BLOCK,-1,,"{
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, SocketAddressBlockListWrap::New);
    tmpl->SetClassName(FIXED_ONE_BYTE_STRING(env->isolate(), ""BlockList""));
    tmpl->InstanceTemplate()->SetInternalFieldCount(kInternalFieldCount);
    SetProtoMethod(isolate, tmpl, ""addAddress"", AddAddress);
    SetProtoMethod(isolate, tmpl, ""addRange"", AddRange);
    SetProtoMethod(isolate, tmpl, ""addSubnet"", AddSubnet);
    SetProtoMethod(isolate, tmpl, ""check"", Check);
    SetProtoMethod(isolate, tmpl, ""getRules"", GetRules);
    env->set_blocklist_constructor_template(tmpl);
  }",23,,700,2,,void
238004,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);

  SetConstructorFunction(context,
                         target,
                         ""BlockList"",
                         GetConstructorTemplate(env),
                         SetConstructorFunctionFlag::NONE);

  SocketAddressBase::Initialize(env, target);

  NODE_DEFINE_CONSTANT(target, AF_INET);
  NODE_DEFINE_CONSTANT(target, AF_INET6);
}",17,,719,5,,void
238040,BLOCK,-1,,"{
  return New(env, std::move(blocklist_));
}",49,,737,4,,void
238053,BLOCK,-1,,"{
  blocklist_->MemoryInfo(tracker);
}",35,,742,2,,void
238064,BLOCK,-1,,"{
  return GetConstructorTemplate(env)->HasInstance(value);
}",75,,746,3,,void
238076,BLOCK,-1,,"{
  Local<FunctionTemplate> tmpl = env->socketaddress_constructor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, New);
    tmpl->SetClassName(FIXED_ONE_BYTE_STRING(env->isolate(), ""SocketAddress""));
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        SocketAddressBase::kInternalFieldCount);
    SetProtoMethod(isolate, tmpl, ""detail"", Detail);
    SetProtoMethod(isolate, tmpl, ""legacyDetail"", LegacyDetail);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""flowlabel"", GetFlowLabel);
    env->set_socketaddress_constructor_template(tmpl);
  }
  return tmpl;
}",23,,751,2,,void
238092,BLOCK,-1,,"{
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, New);
    tmpl->SetClassName(FIXED_ONE_BYTE_STRING(env->isolate(), ""SocketAddress""));
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        SocketAddressBase::kInternalFieldCount);
    SetProtoMethod(isolate, tmpl, ""detail"", Detail);
    SetProtoMethod(isolate, tmpl, ""legacyDetail"", LegacyDetail);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""flowlabel"", GetFlowLabel);
    env->set_socketaddress_constructor_template(tmpl);
  }",23,,753,2,,void
238152,BLOCK,-1,,"{
  SetConstructorFunction(env->context(),
                         target,
                         ""SocketAddress"",
                         GetConstructorTemplate(env),
                         SetConstructorFunctionFlag::NONE);
}",76,,767,3,,void
238170,BLOCK,-1,,"{
  Local<Object> obj;
  if (!GetConstructorTemplate(env)
          ->InstanceTemplate()
          ->NewInstance(env->context()).ToLocal(&obj)) {
    return BaseObjectPtr<SocketAddressBase>();
  }

  return MakeBaseObject<SocketAddressBase>(env, obj, std::move(address));
}",45,,777,3,,void
238195,BLOCK,-1,,"{
    return BaseObjectPtr<SocketAddressBase>();
  }",56,,781,2,,void
238216,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args.IsConstructCall());
  CHECK(args[0]->IsString());  // address
  CHECK(args[1]->IsInt32());  // port
  CHECK(args[2]->IsInt32());  // family
  CHECK(args[3]->IsUint32());  // flow label

  Utf8Value address(env->isolate(), args[0]);
  int32_t port = args[1].As<Int32>()->Value();
  int32_t family = args[2].As<Int32>()->Value();
  uint32_t flow_label = args[3].As<Uint32>()->Value();

  std::shared_ptr<SocketAddress> addr = std::make_shared<SocketAddress>();

  if (!SocketAddress::New(family, *address, port, addr.get()))
    return THROW_ERR_INVALID_ADDRESS(env);

  addr->set_flow_label(flow_label);

  new SocketAddressBase(env, args.This(), std::move(addr));
}",70,,788,2,,void
238329,BLOCK,-1,,<empty>,5,,804,2,,void
238354,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsObject());
  Local<Object> detail = args[0].As<Object>();

  SocketAddressBase* base;
  ASSIGN_OR_RETURN_UNWRAP(&base, args.Holder());

  Local<Value> address;
  if (!ToV8Value(env->context(), base->address_->address()).ToLocal(&address))
    return;

  if (detail->Set(env->context(), env->address_string(), address).IsJust() &&
      detail->Set(
          env->context(),
          env->port_string(),
          Int32::New(env->isolate(), base->address_->port())).IsJust() &&
      detail->Set(
          env->context(),
          env->family_string(),
          Int32::New(env->isolate(), base->address_->family())).IsJust() &&
      detail->Set(
          env->context(),
          env->flowlabel_string(),
          Uint32::New(env->isolate(), base->address_->flow_label()))
              .IsJust()) {
    args.GetReturnValue().Set(detail);
  }
}",73,,811,2,,void
238413,BLOCK,-1,,<empty>,5,,821,2,,void
238522,BLOCK,-1,,"{
    args.GetReturnValue().Set(detail);
  }",26,,836,2,,void
238535,BLOCK,-1,,"{
  SocketAddressBase* base;
  ASSIGN_OR_RETURN_UNWRAP(&base, args.Holder());
  args.GetReturnValue().Set(base->address_->flow_label());
}",79,,841,2,,void
238561,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  SocketAddressBase* base;
  ASSIGN_OR_RETURN_UNWRAP(&base, args.Holder());
  Local<Object> address;
  if (!base->address_->ToJS(env).ToLocal(&address)) return;
  args.GetReturnValue().Set(address);
}",79,,847,2,,void
238597,BLOCK,-1,,<empty>,53,,852,2,,void
238613,BLOCK,-1,,"{
  MakeWeak();
}",36,,861,4,,void
238619,BLOCK,-1,,"{
  tracker->TrackField(""address"", address_);
}",66,,865,2,,void
238629,BLOCK,-1,,"{
  return std::make_unique<TransferData>(this);
}",46,,870,1,,void
238642,BLOCK,-1,,"{
  tracker->TrackField(""address"", address_);
}",80,,874,2,,void
238655,BLOCK,-1,,"{
  return SocketAddressBase::Create(env, std::move(address_));
}",49,,881,4,,void
238696,BLOCK,-1,,<empty>,1,,1,1,,ANY
238721,BLOCK,-1,,<empty>,1,,1,1,,ANY
238726,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, StatWatcher::New);
  t->InstanceTemplate()->SetInternalFieldCount(
      StatWatcher::kInternalFieldCount);
  t->Inherit(HandleWrap::GetConstructorTemplate(isolate_data));
  SetProtoMethod(isolate, t, ""start"", StatWatcher::Start);

  SetConstructorFunction(isolate, target, ""StatWatcher"", t);
}",76,,49,3,,void
238780,BLOCK,-1,,"{
  registry->Register(StatWatcher::New);
  registry->Register(StatWatcher::Start);
}",42,,62,2,,void
238801,BLOCK,-1,,"{
  CHECK_EQ(0, uv_fs_poll_init(env()->event_loop(), &watcher_));
}",35,,75,4,,void
238818,BLOCK,-1,,"{
  StatWatcher* wrap = ContainerOf(&StatWatcher::watcher_, handle);
  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Value> arr = fs::FillGlobalStatsArray(
      wrap->binding_data_.get(), wrap->use_bigint_, curr);
  USE(fs::FillGlobalStatsArray(
      wrap->binding_data_.get(), wrap->use_bigint_, prev, true));

  Local<Value> argv[2] = { Integer::New(env->isolate(), status), arr };
  wrap->MakeCallback(env->onchange_string(), arraysize(argv), argv);
}",51,,83,5,,void
238906,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  fs::BindingData* binding_data = Realm::GetBindingData<fs::BindingData>(args);
  new StatWatcher(binding_data, args.This(), args[0]->IsTrue());
}",64,,99,2,,void
238941,BLOCK,-1,,"{
  CHECK_EQ(args.Length(), 2);

  StatWatcher* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  CHECK(!uv_is_active(wrap->GetHandle()));

  node::Utf8Value path(args.GetIsolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      wrap->env(),
      permission::PermissionScope::kFileSystemRead,
      path.ToStringView());

  CHECK(args[1]->IsUint32());
  const uint32_t interval = args[1].As<Uint32>()->Value();

  // Note that uv_fs_poll_start does not return ENOENT, we are handling
  // mostly memory errors here.
  const int err = uv_fs_poll_start(&wrap->watcher_, Callback, *path, interval);
  if (err != 0) {
    args.GetReturnValue().Set(err);
  }
}",66,,106,2,,void
239024,BLOCK,-1,,"{
    args.GetReturnValue().Set(err);
  }",17,,126,2,,void
239047,BLOCK,-1,,<empty>,1,,1,1,,ANY
239058,BLOCK,-1,,<empty>,1,,1,1,,ANY
239066,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
#define V(PropertyName, StringValue)                                           \
  target                                                                       \
      ->Set(env->context(),                                                    \
            env->PropertyName()->Description(env->isolate()),                  \
            env->PropertyName())                                               \
      .Check();
  PER_ISOLATE_SYMBOL_PROPERTIES(V)
#undef V
}",36,,17,5,,void
239104,BLOCK,-1,,<empty>,1,,1,1,,ANY
239110,BLOCK,-1,,"{
  Local<Value> maybe_async_id;
  if (!promise->Get(env->context(), id_symbol).ToLocal(&maybe_async_id)) {
    return v8::Just(AsyncWrap::kInvalidAsyncId);
  }
  return maybe_async_id->IsNumber()
      ? maybe_async_id->NumberValue(env->context())
      : v8::Just(AsyncWrap::kInvalidAsyncId);
}",72,,36,4,,void
239132,BLOCK,-1,,"{
    return v8::Just(AsyncWrap::kInvalidAsyncId);
  }",74,,38,2,,void
239168,BLOCK,-1,,"{
  // This check is imperfect. If the internal field is set, it should
  // be an object. If it's not, we just ignore it. Ideally v8 would
  // have had GetInternalField returning a MaybeLocal but this works
  // for now.
  Local<Value> promiseWrap = promise->GetInternalField(0);
  if (promiseWrap->IsObject()) {
        Local<Value> maybe_async_id;
    if (!promiseWrap.As<Object>()->Get(env->context(), id_symbol)
        .ToLocal(&maybe_async_id)) {
      return v8::Just(AsyncWrap::kInvalidAsyncId);
    }
    return maybe_async_id->IsNumber()
        ? maybe_async_id->NumberValue(env->context())
        : v8::Just(AsyncWrap::kInvalidAsyncId);
  } else {
      return v8::Just(AsyncWrap::kInvalidAsyncId);
  }
}",76,,48,4,,void
239185,BLOCK,-1,,"{
        Local<Value> maybe_async_id;
    if (!promiseWrap.As<Object>()->Get(env->context(), id_symbol)
        .ToLocal(&maybe_async_id)) {
      return v8::Just(AsyncWrap::kInvalidAsyncId);
    }
    return maybe_async_id->IsNumber()
        ? maybe_async_id->NumberValue(env->context())
        : v8::Just(AsyncWrap::kInvalidAsyncId);
  }",32,,54,2,,void
239210,BLOCK,-1,,"{
      return v8::Just(AsyncWrap::kInvalidAsyncId);
    }",36,,57,2,,void
239241,BLOCK,-1,,"{
      return v8::Just(AsyncWrap::kInvalidAsyncId);
  }",10,,63,1,,void
239254,BLOCK,-1,,"{
  static std::atomic<uint64_t> unhandledRejections{0};
  static std::atomic<uint64_t> rejectionsHandledAfter{0};

  Local<Promise> promise = message.GetPromise();
  Isolate* isolate = promise->GetIsolate();
  PromiseRejectEvent event = message.GetEvent();

  Environment* env = Environment::GetCurrent(isolate);

  if (env == nullptr || !env->can_call_into_js()) return;

  Local<Function> callback = env->promise_reject_callback();
  // The promise is rejected before JS land calls SetPromiseRejectCallback
  // to initializes the promise reject callback during bootstrap.
  CHECK(!callback.IsEmpty());

  Local<Value> value;
  Local<Value> type = Number::New(env->isolate(), event);

  if (event == kPromiseRejectWithNoHandler) {
    value = message.GetValue();
    unhandledRejections++;
    TRACE_COUNTER2(TRACING_CATEGORY_NODE2(promises, rejections),
                  ""rejections"",
                  ""unhandled"", unhandledRejections,
                  ""handledAfter"", rejectionsHandledAfte...",58,,68,2,,void
239307,BLOCK,-1,,<empty>,51,,78,2,,void
239349,BLOCK,-1,,"{
    value = message.GetValue();
    unhandledRejections++;
    TRACE_COUNTER2(TRACING_CATEGORY_NODE2(promises, rejections),
                  ""rejections"",
                  ""unhandled"", unhandledRejections,
                  ""handledAfter"", rejectionsHandledAfter);
  }",45,,88,2,,void
239368,BLOCK,-1,,<empty>,10,,95,1,,void
239373,BLOCK,-1,,"{
    value = Undefined(isolate);
    rejectionsHandledAfter++;
    TRACE_COUNTER2(TRACING_CATEGORY_NODE2(promises, rejections),
                  ""rejections"",
                  ""unhandled"", unhandledRejections,
                  ""handledAfter"", rejectionsHandledAfter);
  }",56,,95,2,,void
239390,BLOCK,-1,,<empty>,10,,102,1,,void
239395,BLOCK,-1,,"{
    value = message.GetValue();
  }",53,,102,2,,void
239403,BLOCK,-1,,<empty>,10,,104,1,,void
239408,BLOCK,-1,,"{
    value = message.GetValue();
  }",52,,104,2,,void
239416,BLOCK,-1,,"{
    return;
  }",10,,106,1,,void
239423,BLOCK,-1,,"{
    value = Undefined(isolate);
  }",24,,110,2,,void
239464,BLOCK,-1,,<empty>,27,,121,2,,void
239480,BLOCK,-1,,<empty>,35,,123,2,,void
239494,BLOCK,-1,,"{
    // That means that promise might be a PromiseWrap, so we'll
    // check there as well.
    if (!GetAssignedPromiseWrapAsyncId(env, promise, env->async_id_symbol())
              .To(&async_id)) return;
    if (!GetAssignedPromiseWrapAsyncId(
          env, promise, env->trigger_async_id_symbol())
              .To(&trigger_async_id)) return;
  }",55,,126,2,,void
239509,BLOCK,-1,,<empty>,31,,130,2,,void
239525,BLOCK,-1,,<empty>,39,,133,2,,void
239539,BLOCK,-1,,"{
    env->async_hooks()->push_async_context(
        async_id, trigger_async_id, promise);
  }",55,,137,2,,void
239583,BLOCK,-1,,"{
    // This condition might not be true if async_hooks was enabled during
    // the promise callback execution.
    env->async_hooks()->pop_async_context(async_id);
  }",46,,147,2,,void
239603,BLOCK,-1,,"{
    fprintf(stderr, ""Exception in PromiseRejectCallback:\n"");
    PrintCaughtException(isolate, env->context(), try_catch);
  }",60,,156,2,,void
239619,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  CHECK(args[0]->IsFunction());

  isolate->GetCurrentContext()->GetMicrotaskQueue()
      ->EnqueueMicrotask(isolate, args[0].As<Function>());
}",71,,163,2,,void
239663,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  env->context()->GetMicrotaskQueue()->PerformCheckpoint(env->isolate());
}",68,,173,2,,void
239690,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsFunction());
  env->set_tick_callback_function(args[0].As<Function>());
}",70,,178,2,,void
239720,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsFunction());
  env->set_promise_reject_callback(args[0].As<Function>());
}",46,,185,2,,void
239753,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  SetMethod(context, target, ""enqueueMicrotask"", EnqueueMicrotask);
  SetMethod(context, target, ""setTickCallback"", SetTickCallback);
  SetMethod(context, target, ""runMicrotasks"", RunMicrotasks);
  target->Set(env->context(),
              FIXED_ONE_BYTE_STRING(isolate, ""tickInfo""),
              env->tick_info()->fields().GetJSArray()).Check();

  Local<Object> events = Object::New(isolate);
  NODE_DEFINE_CONSTANT(events, kPromiseRejectWithNoHandler);
  NODE_DEFINE_CONSTANT(events, kPromiseHandlerAddedAfterReject);
  NODE_DEFINE_CONSTANT(events, kPromiseResolveAfterResolved);
  NODE_DEFINE_CONSTANT(events, kPromiseRejectAfterResolved);

  target->Set(env->context(),
              FIXED_ONE_BYTE_STRING(isolate, ""promiseRejectEvents""),
              events).Check();
  SetMethod(
      context, target, ""setPromiseRejectCallback"", SetPromiseRejectCallback);
}",36,,195,5,,void
239824,BLOCK,1,,<empty>,,,,7,,void
239826,BLOCK,-1,,"NODE_DEFINE_CONSTANT(events, kPromiseRejectWithNoHandler)",3,,207,1,,void
239923,BLOCK,1,,<empty>,,,,7,,void
239925,BLOCK,-1,,"NODE_DEFINE_CONSTANT(events, kPromiseHandlerAddedAfterReject)",3,,208,1,,void
240022,BLOCK,1,,<empty>,,,,7,,void
240024,BLOCK,-1,,"NODE_DEFINE_CONSTANT(events, kPromiseResolveAfterResolved)",3,,209,1,,void
240121,BLOCK,1,,<empty>,,,,7,,void
240123,BLOCK,-1,,"NODE_DEFINE_CONSTANT(events, kPromiseRejectAfterResolved)",3,,210,1,,void
240239,BLOCK,-1,,"{
  registry->Register(EnqueueMicrotask);
  registry->Register(SetTickCallback);
  registry->Register(RunMicrotasks);
  registry->Register(SetPromiseRejectCallback);
}",70,,219,2,,void
240267,BLOCK,-1,,<empty>,1,,1,1,,ANY
240280,BLOCK,-1,,<empty>,1,,1,1,,ANY
240307,BLOCK,-1,,<empty>,1,,1,1,,ANY
240316,BLOCK,-1,,<empty>,,,,5,,<empty>
240321,BLOCK,-1,,<empty>,,,,2,,<empty>
240326,BLOCK,-1,,<empty>,,,,2,,<empty>
240331,BLOCK,-1,,<empty>,,,,2,,<empty>
240336,BLOCK,-1,,<empty>,,,,2,,<empty>
240340,BLOCK,-1,,{ return categories_; },54,,41,1,,void
240347,BLOCK,-1,,"{
    tracker->TrackField(""categories"", categories_);
  }",58,,43,2,,void
240364,BLOCK,-1,,"{
    MakeWeak();
  }",67,,54,4,,void
240371,BLOCK,-1,,<empty>,,,,1,,<empty>
240379,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  std::set<std::string> categories;
  CHECK(args[0]->IsArray());
  Local<Array> cats = args[0].As<Array>();
  for (size_t n = 0; n < cats->Length(); n++) {
    Local<Value> category;
    if (!cats->Get(env->context(), n).ToLocal(&category)) return;
    Utf8Value val(env->isolate(), category);
    if (!*val) return;
    categories.emplace(*val);
  }
  CHECK_NOT_NULL(GetTracingAgentWriter());
  new NodeCategorySet(env, args.This(), std::move(categories));
}",68,,62,2,,void
240417,BLOCK,-1,,<empty>,3,,67,1,,void
240430,BLOCK,4,,"{
    Local<Value> category;
    if (!cats->Get(env->context(), n).ToLocal(&category)) return;
    Utf8Value val(env->isolate(), category);
    if (!*val) return;
    categories.emplace(*val);
  }",47,,67,4,,void
240452,BLOCK,-1,,<empty>,59,,69,2,,void
240465,BLOCK,-1,,<empty>,16,,71,2,,void
240490,BLOCK,-1,,"{
  NodeCategorySet* category_set;
  ASSIGN_OR_RETURN_UNWRAP(&category_set, args.Holder());
  CHECK_NOT_NULL(category_set);
  const auto& categories = category_set->GetCategories();
  if (!category_set->enabled_ && !categories.empty()) {
    // Starts the Tracing Agent if it wasn't started already (e.g. through
    // a command line flag.)
    StartTracingAgent();
    GetTracingAgentWriter()->Enable(categories);
    category_set->enabled_ = true;
  }
}",71,,78,2,,void
240519,BLOCK,-1,,"{
    // Starts the Tracing Agent if it wasn't started already (e.g. through
    // a command line flag.)
    StartTracingAgent();
    GetTracingAgentWriter()->Enable(categories);
    category_set->enabled_ = true;
  }",55,,83,2,,void
240535,BLOCK,-1,,"{
  NodeCategorySet* category_set;
  ASSIGN_OR_RETURN_UNWRAP(&category_set, args.Holder());
  CHECK_NOT_NULL(category_set);
  const auto& categories = category_set->GetCategories();
  if (category_set->enabled_ && !categories.empty()) {
    GetTracingAgentWriter()->Disable(categories);
    category_set->enabled_ = false;
  }
}",72,,92,2,,void
240563,BLOCK,-1,,"{
    GetTracingAgentWriter()->Disable(categories);
    category_set->enabled_ = false;
  }",54,,97,2,,void
240578,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  std::string categories =
      GetTracingAgentWriter()->agent()->GetEnabledCategories();
  if (!categories.empty()) {
    args.GetReturnValue().Set(
      String::NewFromUtf8(env->isolate(),
                          categories.c_str(),
                          NewStringType::kNormal,
                          categories.size()).ToLocalChecked());
  }
}",68,,103,2,,void
240603,BLOCK,-1,,"{
    args.GetReturnValue().Set(
      String::NewFromUtf8(env->isolate(),
                          categories.c_str(),
                          NewStringType::kNormal,
                          categories.size()).ToLocalChecked());
  }",28,,107,2,,void
240637,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsFunction());
  env->set_trace_category_state_function(args[0].As<Function>());
}",46,,117,2,,void
240670,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  SetMethod(context, target, ""getEnabledCategories"", GetEnabledCategories);
  SetMethod(context,
            target,
            ""setTraceCategoryStateUpdateHandler"",
            SetTraceCategoryStateUpdateHandler);

  Local<FunctionTemplate> category_set =
      NewFunctionTemplate(isolate, NodeCategorySet::New);
  category_set->InstanceTemplate()->SetInternalFieldCount(
      NodeCategorySet::kInternalFieldCount);
  SetProtoMethod(isolate, category_set, ""enable"", NodeCategorySet::Enable);
  SetProtoMethod(isolate, category_set, ""disable"", NodeCategorySet::Disable);

  SetConstructorFunction(context, target, ""CategorySet"", category_set);

  Local<String> isTraceCategoryEnabled =
      FIXED_ONE_BYTE_STRING(env->isolate(), ""isTraceCategoryEnabled"");
  Local<String> trace = FIXED_ONE_BYTE_STRING(env->isolate(), ""trace"");

  // Grab the trace and isTraceCategoryEnabled intrinsics from the bi...",29,,126,5,,void
240810,BLOCK,-1,,"{
  registry->Register(GetEnabledCategories);
  registry->Register(SetTraceCategoryStateUpdateHandler);
  registry->Register(NodeCategorySet::New);
  registry->Register(NodeCategorySet::Enable);
  registry->Register(NodeCategorySet::Disable);
}",42,,160,2,,void
240855,BLOCK,-1,,<empty>,1,,1,1,,ANY
240860,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
240878,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
240896,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
240914,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
240932,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
240950,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
240968,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
240986,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
241004,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
241022,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
241040,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
241058,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
241076,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
241094,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
241112,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
241130,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
241148,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
241166,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
241184,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
241202,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
241220,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
241238,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
241256,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
241274,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
241292,BLOCK,-1,,VALUE_METHOD_MAP(V),3,,47,2,,void
241310,BLOCK,-1,,"{
  args.GetReturnValue().Set(
    args[0]->IsArrayBuffer() || args[0]->IsSharedArrayBuffer());
}",71,,50,2,,void
241335,BLOCK,-1,,"{
  args.GetReturnValue().Set(
    args[0]->IsNumberObject() ||
    args[0]->IsStringObject() ||
    args[0]->IsBooleanObject() ||
    args[0]->IsBigIntObject() ||
    args[0]->IsSymbolObject());
}",71,,55,2,,void
241384,BLOCK,-1,,"{
#define V(type) SetMethodNoSideEffect(context, target, ""is"" #type, Is##type);
  VALUE_METHOD_MAP(V)
#undef V

  SetMethodNoSideEffect(context, target, ""isAnyArrayBuffer"", IsAnyArrayBuffer);
  SetMethodNoSideEffect(context, target, ""isBoxedPrimitive"", IsBoxedPrimitive);
}",34,,67,5,,void
241386,BLOCK,1,,<empty>,,,,1,,void
241393,BLOCK,1,,<empty>,,,,1,,void
241528,BLOCK,-1,,"{
#define V(type) registry->Register(Is##type);
  VALUE_METHOD_MAP(V)
#undef V

  registry->Register(IsAnyArrayBuffer);
  registry->Register(IsBoxedPrimitive);
}",75,,78,2,,void
241530,BLOCK,1,,<empty>,,,,1,,void
241675,BLOCK,-1,,<empty>,1,,1,1,,ANY
241704,BLOCK,-1,,<empty>,1,,1,1,,ANY
241709,BLOCK,-1,,"{
  tracker->TrackField(""url_components_buffer"", url_components_buffer_);
}",60,,31,2,,void
241721,BLOCK,-1,,"{
  object
      ->Set(realm->context(),
            FIXED_ONE_BYTE_STRING(realm->isolate(), ""urlComponents""),
            url_components_buffer_.GetJSArray())
      .Check();
  url_components_buffer_.MakeWeak();
}",70,,37,3,,void
241752,BLOCK,-1,,"{
  // We'll just re-initialize the buffers in the constructor since their
  // contents can be thrown away once consumed in the previous call.
  url_components_buffer_.Release();
  // Return true because we need to maintain the reference to the binding from
  // JS land.
  return true;
}",73,,47,3,,void
241763,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  InternalFieldInfo* info =
      InternalFieldInfoBase::New<InternalFieldInfo>(type());
  return info;
}",58,,56,2,,void
241788,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  v8::HandleScope scope(context->GetIsolate());
  Realm* realm = Realm::GetCurrent(context);
  BindingData* binding = realm->AddBindingData<BindingData>(context, holder);
  CHECK_NOT_NULL(binding);
}",60,,66,5,,void
241827,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());

  std::string input = Utf8Value(env->isolate(), args[0]).ToString();
  if (input.empty()) {
    return args.GetReturnValue().Set(FIXED_ONE_BYTE_STRING(env->isolate(), """"));
  }

  // It is important to have an initial value that contains a special scheme.
  // Since it will change the implementation of `set_hostname` according to URL
  // spec.
  auto out = ada::parse<ada::url>(""ws://x"");
  DCHECK(out);
  if (!out->set_hostname(input)) {
    return args.GetReturnValue().Set(FIXED_ONE_BYTE_STRING(env->isolate(), """"));
  }
  std::string host = out->get_hostname();
  args.GetReturnValue().Set(
      String::NewFromUtf8(env->isolate(), host.c_str()).ToLocalChecked());
}",74,,74,2,,void
241868,BLOCK,-1,,"{
    return args.GetReturnValue().Set(FIXED_ONE_BYTE_STRING(env->isolate(), """"));
  }",22,,80,2,,void
241904,BLOCK,-1,,"{
    return args.GetReturnValue().Set(FIXED_ONE_BYTE_STRING(env->isolate(), """"));
  }",34,,89,2,,void
241952,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());

  std::string input = Utf8Value(env->isolate(), args[0]).ToString();
  // It is important to have an initial value that contains a special scheme.
  // Since it will change the implementation of `set_hostname` according to URL
  // spec.
  auto out = ada::parse<ada::url>(""ws://x"");
  DCHECK(out);
  if (!out->set_hostname(input)) {
    return args.GetReturnValue().Set(
        String::NewFromUtf8(env->isolate(), """").ToLocalChecked());
  }
  std::string result = ada::unicode::to_unicode(out->get_hostname());

  args.GetReturnValue().Set(String::NewFromUtf8(env->isolate(),
                                                result.c_str(),
                                                NewStringType::kNormal,
                                                result.length())
                                .ToLocalChecked());
}",76,,97,2,,void
242009,BLOCK,-1,,"{
    return args.GetReturnValue().Set(
        String::NewFromUtf8(env->isolate(), """").ToLocalChecked());
  }",34,,108,2,,void
242076,BLOCK,-1,,"{
  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());  // input

  Environment* env = Environment::GetCurrent(args);
  HandleScope handle_scope(env->isolate());

  Utf8Value input(env->isolate(), args[0]);
  std::string_view input_view = input.ToStringView();
  auto out = ada::parse<ada::url_aggregator>(input_view);

  if (!out) {
    THROW_ERR_INVALID_URL(env, ""Invalid URL"");
    return;
  }

  std::string origin = out->get_origin();
  args.GetReturnValue().Set(String::NewFromUtf8(env->isolate(),
                                                origin.data(),
                                                NewStringType::kNormal,
                                                origin.length())
                                .ToLocalChecked());
}",74,,121,2,,void
242135,BLOCK,-1,,"{
    THROW_ERR_INVALID_URL(env, ""Invalid URL"");
    return;
  }",13,,132,2,,void
242180,BLOCK,-1,,"{
  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());  // input
  // args[1] // base url

  Environment* env = Environment::GetCurrent(args);
  HandleScope handle_scope(env->isolate());

  Utf8Value input(env->isolate(), args[0]);
  std::string_view input_view = input.ToStringView();

  bool can_parse{};
  if (args[1]->IsString()) {
    Utf8Value base(env->isolate(), args[1]);
    std::string_view base_view = base.ToStringView();
    can_parse = ada::can_parse(input_view, &base_view);
  } else {
    can_parse = ada::can_parse(input_view);
  }

  args.GetReturnValue().Set(can_parse);
}",69,,145,2,,void
242235,BLOCK,-1,,"{
    Utf8Value base(env->isolate(), args[1]);
    std::string_view base_view = base.ToStringView();
    can_parse = ada::can_parse(input_view, &base_view);
  }",28,,157,2,,void
242262,BLOCK,-1,,"{
    can_parse = ada::can_parse(input_view);
  }",10,,161,1,,void
242283,BLOCK,-1,,"{
  return ada::can_parse(std::string_view(input.data, input.length));
}",64,,169,3,,void
242303,BLOCK,-1,,<empty>,,,,2,,<empty>
242310,BLOCK,-1,,"{
  auto base_view = std::string_view(base.data, base.length);
  return ada::can_parse(std::string_view(input.data, input.length), &base_view);
}",71,,177,4,,void
242345,BLOCK,-1,,<empty>,,,,2,,<empty>
242350,BLOCK,-1,,"{
  CHECK_GT(args.Length(), 4);
  CHECK(args[0]->IsString());  // url href

  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  Utf8Value href(isolate, args[0].As<String>());
  const bool hash = args[1]->IsTrue();
  const bool unicode = args[2]->IsTrue();
  const bool search = args[3]->IsTrue();
  const bool auth = args[4]->IsTrue();

  // ada::url provides a faster alternative to ada::url_aggregator if we
  // directly want to manipulate the url components without using the respective
  // setters. therefore we are using ada::url here.
  auto out = ada::parse<ada::url>(href.ToStringView());
  CHECK(out);

  if (!hash) {
    out->hash = std::nullopt;
  }

  if (unicode) {
    out->host = ada::idna::to_unicode(out->get_hostname());
  }

  if (!search) {
    out->query = std::nullopt;
  }

  if (!auth) {
    out->username = """";
    out->password = """";
  }

  std::string result = out->get_href();
  args.GetReturnValue().Set(String::NewFromUtf8(en...",67,,185,2,,void
242444,BLOCK,-1,,"{
    out->hash = std::nullopt;
  }",14,,204,2,,void
242454,BLOCK,-1,,"{
    out->host = ada::idna::to_unicode(out->get_hostname());
  }",16,,208,2,,void
242472,BLOCK,-1,,"{
    out->query = std::nullopt;
  }",16,,212,2,,void
242483,BLOCK,-1,,"{
    out->username = """";
    out->password = """";
  }",14,,216,2,,void
242534,BLOCK,-1,,"{
  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());  // input
  // args[1] // base url

  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
  Environment* env = Environment::GetCurrent(args);
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Utf8Value input(env->isolate(), args[0]);
  ada::result<ada::url_aggregator> base;
  ada::url_aggregator* base_pointer = nullptr;
  if (args[1]->IsString()) {
    base = ada::parse<ada::url_aggregator>(
        Utf8Value(env->isolate(), args[1]).ToString());
    if (!base) {
      return args.GetReturnValue().Set(false);
    }
    base_pointer = &base.value();
  }
  auto out =
      ada::parse<ada::url_aggregator>(input.ToStringView(), base_pointer);

  if (!out) {
    return args.GetReturnValue().Set(false);
  }

  binding_data->UpdateComponents(out->get_components(), out->type);

  args.GetReturnValue().Set(
      ToV8Value(env->context(), out->get_href(), env->isolate(...",66,,229,2,,void
242607,BLOCK,-1,,"{
    base = ada::parse<ada::url_aggregator>(
        Utf8Value(env->isolate(), args[1]).ToString());
    if (!base) {
      return args.GetReturnValue().Set(false);
    }
    base_pointer = &base.value();
  }",28,,242,2,,void
242632,BLOCK,-1,,"{
      return args.GetReturnValue().Set(false);
    }",16,,245,2,,void
242670,BLOCK,-1,,"{
    return args.GetReturnValue().Set(false);
  }",13,,253,2,,void
242718,BLOCK,-1,,"{
  CHECK(args[0]->IsString());    // href
  CHECK(args[1]->IsNumber());    // action type
  CHECK(args[2]->IsString());    // new value

  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  enum url_update_action action = static_cast<enum url_update_action>(
      args[1]->Uint32Value(env->context()).FromJust());
  Utf8Value input(isolate, args[0].As<String>());
  Utf8Value new_value(isolate, args[2].As<String>());

  std::string_view new_value_view = new_value.ToStringView();
  auto out = ada::parse<ada::url_aggregator>(input.ToStringView());
  CHECK(out);

  bool result{true};

  switch (action) {
    case kPathname: {
      result = out->set_pathname(new_value_view);
      break;
    }
    case kHash: {
      out->set_hash(new_value_view);
      break;
    }
    case kHost: {
      result = out->set_host(new_value_view);
      break;
    }
    case kHostname: {
      re...",67,,264,2,,void
242832,BLOCK,-1,,"{
    case kPathname: {
      result = out->set_pathname(new_value_view);
      break;
    }
    case kHash: {
      out->set_hash(new_value_view);
      break;
    }
    case kHost: {
      result = out->set_host(new_value_view);
      break;
    }
    case kHostname: {
      result = out->set_hostname(new_value_view);
      break;
    }
    case kHref: {
      result = out->set_href(new_value_view);
      break;
    }
    case kPassword: {
      result = out->set_password(new_value_view);
      break;
    }
    case kPort: {
      result = out->set_port(new_value_view);
      break;
    }
    case kProtocol: {
      result = out->set_protocol(new_value_view);
      break;
    }
    case kSearch: {
      out->set_search(new_value_view);
      break;
    }
    case kUsername: {
      result = out->set_username(new_value_view);
      break;
    }
    default:
      UNREACHABLE(""Unsupported URL update action"");
  }",19,,284,2,,void
242835,BLOCK,3,,"{
      result = out->set_pathname(new_value_view);
      break;
    }",21,,285,3,,void
242846,BLOCK,6,,"{
      out->set_hash(new_value_view);
      break;
    }",17,,289,6,,void
242855,BLOCK,9,,"{
      result = out->set_host(new_value_view);
      break;
    }",17,,293,9,,void
242866,BLOCK,12,,"{
      result = out->set_hostname(new_value_view);
      break;
    }",21,,297,12,,void
242877,BLOCK,15,,"{
      result = out->set_href(new_value_view);
      break;
    }",17,,301,15,,void
242888,BLOCK,18,,"{
      result = out->set_password(new_value_view);
      break;
    }",21,,305,18,,void
242899,BLOCK,21,,"{
      result = out->set_port(new_value_view);
      break;
    }",17,,309,21,,void
242910,BLOCK,24,,"{
      result = out->set_protocol(new_value_view);
      break;
    }",21,,313,24,,void
242921,BLOCK,27,,"{
      out->set_search(new_value_view);
      break;
    }",19,,317,27,,void
242930,BLOCK,30,,"{
      result = out->set_username(new_value_view);
      break;
    }",21,,321,30,,void
242945,BLOCK,-1,,"{
    return args.GetReturnValue().Set(false);
  }",16,,329,2,,void
242994,BLOCK,-1,,"{
  url_components_buffer_[0] = components.protocol_end;
  url_components_buffer_[1] = components.username_end;
  url_components_buffer_[2] = components.host_start;
  url_components_buffer_[3] = components.host_end;
  url_components_buffer_[4] = components.port;
  url_components_buffer_[5] = components.pathname_start;
  url_components_buffer_[6] = components.search_start;
  url_components_buffer_[7] = components.hash_start;
  url_components_buffer_[8] = type;
  static_assert(kURLComponentsLength == 9,
                ""kURLComponentsLength should be up-to-date"");
}",66,,340,3,,void
243066,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();
  SetMethodNoSideEffect(isolate, target, ""domainToASCII"", DomainToASCII);
  SetMethodNoSideEffect(isolate, target, ""domainToUnicode"", DomainToUnicode);
  SetMethodNoSideEffect(isolate, target, ""format"", Format);
  SetMethodNoSideEffect(isolate, target, ""getOrigin"", GetOrigin);
  SetMethod(isolate, target, ""parse"", Parse);
  SetMethod(isolate, target, ""update"", Update);
  SetFastMethodNoSideEffect(
      isolate, target, ""canParse"", CanParse, &fast_can_parse_);
  SetFastMethodNoSideEffect(isolate,
                            target,
                            ""canParseWithBase"",
                            CanParse,
                            &fast_can_parse_with_base_);
}",76,,355,3,,void
243125,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(context);
  realm->AddBindingData<BindingData>(context, target);
}",58,,375,5,,void
243148,BLOCK,-1,,"{
  registry->Register(DomainToASCII);
  registry->Register(DomainToUnicode);
  registry->Register(Format);
  registry->Register(GetOrigin);
  registry->Register(Parse);
  registry->Register(Update);
  registry->Register(CanParse);
  registry->Register(FastCanParse);
  registry->Register(fast_can_parse_.GetTypeInfo());
  registry->Register(FastCanParseWithBase);
  registry->Register(fast_can_parse_with_base_.GetTypeInfo());
}",42,,381,2,,void
243214,BLOCK,-1,,"{
  std::string escaped_file_path;
  for (size_t i = 0; i < file_path.length(); ++i) {
    escaped_file_path += file_path[i];
    if (file_path[i] == '%') escaped_file_path += ""25"";
  }
  return ada::href_from_file(escaped_file_path);
}",60,,395,2,,void
243217,BLOCK,-1,,<empty>,3,,397,1,,void
243230,BLOCK,4,,"{
    escaped_file_path += file_path[i];
    if (file_path[i] == '%') escaped_file_path += ""25"";
  }",51,,397,4,,void
243242,BLOCK,-1,,<empty>,30,,399,2,,void
243277,BLOCK,-1,,<empty>,1,,1,1,,ANY
243294,BLOCK,-1,,<empty>,1,,1,1,,ANY
243304,BLOCK,-1,,"{
  CHECK(args[0]->IsObject());

  Local<Object> object = args[0].As<Object>();
  Local<String> name = object->GetConstructorName();

  args.GetReturnValue().Set(name);
}",46,,79,2,,void
243346,BLOCK,-1,,"{
  CHECK(args[0]->IsExternal());
  Isolate* isolate = args.GetIsolate();
  Local<External> external = args[0].As<External>();

  void* ptr = external->Value();
  uint64_t value = reinterpret_cast<uint64_t>(ptr);
  Local<BigInt> ret = BigInt::NewFromUnsigned(isolate, value);
  args.GetReturnValue().Set(ret);
}",46,,89,2,,void
243410,BLOCK,-1,,"{
  // Return undefined if it's not a Promise.
  if (!args[0]->IsPromise())
    return;

  auto isolate = args.GetIsolate();

  Local<Promise> promise = args[0].As<Promise>();

  int state = promise->State();
  Local<Value> values[2] = { Integer::New(isolate, state) };
  size_t number_of_values = 1;
  if (state != Promise::PromiseState::kPending)
    values[number_of_values++] = promise->Result();
  Local<Array> ret = Array::New(isolate, values, number_of_values);
  args.GetReturnValue().Set(ret);
}",72,,100,2,,void
243419,BLOCK,-1,,<empty>,5,,103,2,,void
243467,BLOCK,-1,,<empty>,5,,113,2,,void
243502,BLOCK,-1,,"{
  // Return undefined if it's not a proxy.
  if (!args[0]->IsProxy())
    return;

  Local<Proxy> proxy = args[0].As<Proxy>();

  // TODO(BridgeAR): Remove the length check as soon as we prohibit access to
  // the util binding layer. It's accessed in the wild and `esm` would break in
  // case the check is removed.
  if (args.Length() == 1 || args[1]->IsTrue()) {
    Local<Value> ret[] = {
      proxy->GetTarget(),
      proxy->GetHandler()
    };

    args.GetReturnValue().Set(
        Array::New(args.GetIsolate(), ret, arraysize(ret)));
  } else {
    Local<Value> ret = proxy->GetTarget();

    args.GetReturnValue().Set(ret);
  }
}",70,,118,2,,void
243511,BLOCK,-1,,<empty>,5,,121,2,,void
243539,BLOCK,-1,,"{
    Local<Value> ret[] = {
      proxy->GetTarget(),
      proxy->GetHandler()
    };

    args.GetReturnValue().Set(
        Array::New(args.GetIsolate(), ret, arraysize(ret)));
  }",48,,128,2,,void
243571,BLOCK,-1,,"{
    Local<Value> ret = proxy->GetTarget();

    args.GetReturnValue().Set(ret);
  }",10,,136,1,,void
243594,BLOCK,-1,,"{
  if (args[0]->IsArrayBuffer()) {
    auto buffer = args[0].As<v8::ArrayBuffer>();
    args.GetReturnValue().Set(buffer->WasDetached());
    return;
  }
  args.GetReturnValue().Set(false);
}",76,,143,2,,void
243602,BLOCK,-1,,"{
    auto buffer = args[0].As<v8::ArrayBuffer>();
    args.GetReturnValue().Set(buffer->WasDetached());
    return;
  }",33,,144,2,,void
243636,BLOCK,-1,,"{
  if (!args[0]->IsObject())
    return;

  Environment* env = Environment::GetCurrent(args);
  bool is_key_value;
  Local<Array> entries;
  if (!args[0].As<Object>()->PreviewEntries(&is_key_value).ToLocal(&entries))
    return;
  // Fast path for WeakMap and WeakSet.
  if (args.Length() == 1)
    return args.GetReturnValue().Set(entries);

  Local<Value> ret[] = {
    entries,
    Boolean::New(env->isolate(), is_key_value)
  };
  return args.GetReturnValue().Set(
      Array::New(env->isolate(), ret, arraysize(ret)));
}",69,,152,2,,void
243645,BLOCK,-1,,<empty>,5,,154,2,,void
243679,BLOCK,-1,,<empty>,5,,160,2,,void
243688,BLOCK,-1,,<empty>,5,,163,2,,void
243735,BLOCK,-1,,"{
  CHECK(args[0]->IsUint32());
  uint32_t msec = args[0].As<Uint32>()->Value();
  uv_sleep(msec);
}",60,,173,2,,void
243761,BLOCK,-1,,"{
  CHECK(args[0]->IsArrayBufferView());
  args.GetReturnValue().Set(args[0].As<ArrayBufferView>()->HasBuffer());
}",72,,179,2,,void
243791,BLOCK,-1,,<empty>,47,,187,4,,void
243799,BLOCK,-1,,"{
  MakeWeak();
  if (!target.IsEmpty()) {
    target_.Reset(realm->isolate(), target);
    if (reference_count_ == 0) {
      target_.SetWeak();
    }
  }
}",41,,194,5,,void
243807,BLOCK,-1,,"{
    target_.Reset(realm->isolate(), target);
    if (reference_count_ == 0) {
      target_.SetWeak();
    }
  }",26,,196,2,,void
243821,BLOCK,-1,,"{
      target_.SetWeak();
    }",32,,198,2,,void
243831,BLOCK,-1,,"{
  if (target_.IsEmpty()) {
    target_index_ = 0;
    return true;
  }

  // Users can still hold strong references to target in addition to the
  // reference that we manage here, and they could expect that the referenced
  // object remains the same as long as that external strong reference
  // is alive. Since we have no way to know if there is any other reference
  // keeping the target alive, the best we can do to maintain consistency is to
  // simply save a reference to the target in the snapshot (effectively making
  // it strong) during serialization, and restore it during deserialization.
  // If there's no known counted reference from our side, we'll make the
  // reference here weak upon deserialization so that it can be GC'ed if users
  // do not hold additional references to it.
  Local<Object> target = target_.Get(context->GetIsolate());
  target_index_ = creator->AddData(context, target);
  DCHECK_NE(target_index_, 0);
  target_.Reset();
  return true;
}",75,,205,3,,void
243837,BLOCK,-1,,"{
    target_index_ = 0;
    return true;
  }",26,,206,2,,void
243878,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  InternalFieldInfo* info =
      InternalFieldInfoBase::New<InternalFieldInfo>(type());
  info->target = target_index_;
  info->reference_count = reference_count_;
  return info;
}",60,,228,2,,void
243913,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  HandleScope scope(context->GetIsolate());

  InternalFieldInfo* weak_info = reinterpret_cast<InternalFieldInfo*>(info);
  Local<Object> target;
  if (weak_info->target != 0) {
    target = context->GetDataFromSnapshotOnce<Object>(weak_info->target)
                 .ToLocalChecked();
  }
  new WeakReference(
      Realm::GetCurrent(context), holder, target, weak_info->reference_count);
}",62,,240,5,,void
243942,BLOCK,-1,,"{
    target = context->GetDataFromSnapshotOnce<Object>(weak_info->target)
                 .ToLocalChecked();
  }",31,,246,2,,void
243973,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(args);
  CHECK(args.IsConstructCall());
  CHECK(args[0]->IsObject());
  new WeakReference(realm, args.This(), args[0].As<Object>());
}",66,,254,2,,void
244011,BLOCK,-1,,"{
  WeakReference* weak_ref = Unwrap<WeakReference>(args.Holder());
  Isolate* isolate = args.GetIsolate();
  if (!weak_ref->target_.IsEmpty())
    args.GetReturnValue().Set(weak_ref->target_.Get(isolate));
}",66,,261,2,,void
244038,BLOCK,-1,,<empty>,5,,265,2,,void
244057,BLOCK,-1,,"{
  WeakReference* weak_ref = Unwrap<WeakReference>(args.Holder());
  weak_ref->reference_count_++;
  if (weak_ref->target_.IsEmpty()) return;
  if (weak_ref->reference_count_ == 1) weak_ref->target_.ClearWeak();
  args.GetReturnValue().Set(
      v8::Number::New(args.GetIsolate(), weak_ref->reference_count_));
}",69,,268,2,,void
244080,BLOCK,-1,,<empty>,36,,271,2,,void
244088,BLOCK,-1,,<empty>,40,,272,2,,void
244119,BLOCK,-1,,"{
  WeakReference* weak_ref = Unwrap<WeakReference>(args.Holder());
  CHECK_GE(weak_ref->reference_count_, 1);
  weak_ref->reference_count_--;
  if (weak_ref->target_.IsEmpty()) return;
  if (weak_ref->reference_count_ == 0) weak_ref->target_.SetWeak();
  args.GetReturnValue().Set(
      v8::Number::New(args.GetIsolate(), weak_ref->reference_count_));
}",69,,277,2,,void
244147,BLOCK,-1,,<empty>,36,,281,2,,void
244155,BLOCK,-1,,<empty>,40,,282,2,,void
244186,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  int fd;
  if (!args[0]->Int32Value(env->context()).To(&fd)) return;
  CHECK_GE(fd, 0);

  uv_handle_type t = uv_guess_handle(fd);
  // TODO(anonrig): We can use an enum here and then create the array in the
  // binding, which will remove the hard-coding in C++ and JS land.
  uint32_t type{0};

  // Currently, the return type of this function corresponds to the index of the
  // array defined in the JS land. This is done as an optimization to reduce the
  // string serialization overhead.
  switch (t) {
    case UV_TCP:
      type = 0;
      break;
    case UV_TTY:
      type = 1;
      break;
    case UV_UDP:
      type = 2;
      break;
    case UV_FILE:
      type = 3;
      break;
    case UV_NAMED_PIPE:
      type = 4;
      break;
    case UV_UNKNOWN_HANDLE:
      type = 5;
      break;
    default:
      ABORT();
  }

  args.GetReturnValue().Set(type);
}",70,,287,2,,void
244213,BLOCK,-1,,<empty>,53,,290,2,,void
244230,BLOCK,-1,,"{
    case UV_TCP:
      type = 0;
      break;
    case UV_TTY:
      type = 1;
      break;
    case UV_UDP:
      type = 2;
      break;
    case UV_FILE:
      type = 3;
      break;
    case UV_NAMED_PIPE:
      type = 4;
      break;
    case UV_UNKNOWN_HANDLE:
      type = 5;
      break;
    default:
      ABORT();
  }",14,,301,2,,void
244282,BLOCK,-1,,"{
  uv_handle_type t = uv_guess_handle(fd);
  uint32_t type{0};

  switch (t) {
    case UV_TCP:
      type = 0;
      break;
    case UV_TTY:
      type = 1;
      break;
    case UV_UDP:
      type = 2;
      break;
    case UV_FILE:
      type = 3;
      break;
    case UV_NAMED_PIPE:
      type = 4;
      break;
    case UV_UNKNOWN_HANDLE:
      type = 5;
      break;
    default:
      ABORT();
  }

  return type;
}",79,,327,3,,void
244295,BLOCK,-1,,"{
    case UV_TCP:
      type = 0;
      break;
    case UV_TTY:
      type = 1;
      break;
    case UV_UDP:
      type = 2;
      break;
    case UV_FILE:
      type = 3;
      break;
    case UV_NAMED_PIPE:
      type = 4;
      break;
    case UV_UNKNOWN_HANDLE:
      type = 5;
      break;
    default:
      ABORT();
  }",14,,331,2,,void
244340,BLOCK,-1,,<empty>,,,,2,,<empty>
244345,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK_GE(args.Length(), 2);
  CHECK(args[0]->IsString());
  CHECK(args[1]->IsNumber());

  TwoByteValue value(env->isolate(), args[0]);

  int64_t start = args[1]->IntegerValue(env->context()).FromJust();
  CHECK_GE(start, 0);

  for (size_t i = start; i < value.length(); i++) {
    char16_t c = value[i];
    if (!IsUnicodeSurrogate(c)) {
      continue;
    } else if (IsUnicodeSurrogateTrail(c) || i == value.length() - 1) {
      value[i] = kUnicodeReplacementCharacter;
    } else {
      char16_t d = value[i + 1];
      if (IsUnicodeTrail(d)) {
        i++;
      } else {
        value[i] = kUnicodeReplacementCharacter;
      }
    }
  }

  args.GetReturnValue().Set(
      String::NewFromTwoByte(env->isolate(),
                             *value,
                             v8::NewStringType::kNormal,
                             value.length()).ToLocalChecked());
}",66,,359,2,,void
244403,BLOCK,-1,,<empty>,3,,370,1,,void
244416,BLOCK,4,,"{
    char16_t c = value[i];
    if (!IsUnicodeSurrogate(c)) {
      continue;
    } else if (IsUnicodeSurrogateTrail(c) || i == value.length() - 1) {
      value[i] = kUnicodeReplacementCharacter;
    } else {
      char16_t d = value[i + 1];
      if (IsUnicodeTrail(d)) {
        i++;
      } else {
        value[i] = kUnicodeReplacementCharacter;
      }
    }
  }",51,,370,4,,void
244427,BLOCK,-1,,"{
      continue;
    }",33,,372,2,,void
244430,BLOCK,-1,,<empty>,12,,374,1,,void
244443,BLOCK,-1,,"{
      value[i] = kUnicodeReplacementCharacter;
    }",71,,374,2,,void
244450,BLOCK,-1,,"{
      char16_t d = value[i + 1];
      if (IsUnicodeTrail(d)) {
        i++;
      } else {
        value[i] = kUnicodeReplacementCharacter;
      }
    }",12,,376,1,,void
244462,BLOCK,-1,,"{
        i++;
      }",30,,378,2,,void
244466,BLOCK,-1,,"{
        value[i] = kUnicodeReplacementCharacter;
      }",14,,380,1,,void
244505,BLOCK,-1,,"{
  registry->Register(GetPromiseDetails);
  registry->Register(GetProxyDetails);
  registry->Register(IsArrayBufferDetached);
  registry->Register(PreviewEntries);
  registry->Register(GetOwnNonIndexProperties);
  registry->Register(GetConstructorName);
  registry->Register(GetExternalValue);
  registry->Register(Sleep);
  registry->Register(ArrayBufferViewHasBuffer);
  registry->Register(WeakReference::New);
  registry->Register(WeakReference::Get);
  registry->Register(WeakReference::IncRef);
  registry->Register(WeakReference::DecRef);
  registry->Register(GuessHandleType);
  registry->Register(FastGuessHandleType);
  registry->Register(fast_guess_handle_type_.GetTypeInfo());
  registry->Register(ToUSVString);
}",70,,393,2,,void
244609,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  {
    Local<ObjectTemplate> tmpl = ObjectTemplate::New(isolate);
#define V(PropertyName, _)                                                     \
  tmpl->Set(FIXED_ONE_BYTE_STRING(env->isolate(), #PropertyName),              \
            env->PropertyName());

    PER_ISOLATE_PRIVATE_SYMBOL_PROPERTIES(V)
#undef V

    target
        ->Set(context,
              FIXED_ONE_BYTE_STRING(isolate, ""privateSymbols""),
              tmpl->NewInstance(context).ToLocalChecked())
        .Check();
  }

  {
    Local<Object> constants = Object::New(isolate);
#define V(name)                                                                \
  constants                                                                    \
      ->Set(context,                                                           \
            FIXED_ONE_BYTE_STRING(isolate, #name),                             \
            Integer::Ne...",29,,416,5,,void
244625,BLOCK,5,,"{
    Local<ObjectTemplate> tmpl = ObjectTemplate::New(isolate);
#define V(PropertyName, _)                                                     \
  tmpl->Set(FIXED_ONE_BYTE_STRING(env->isolate(), #PropertyName),              \
            env->PropertyName());

    PER_ISOLATE_PRIVATE_SYMBOL_PROPERTIES(V)
#undef V

    target
        ->Set(context,
              FIXED_ONE_BYTE_STRING(isolate, ""privateSymbols""),
              tmpl->NewInstance(context).ToLocalChecked())
        .Check();
  }",3,,420,5,,void
244658,BLOCK,6,,"{
    Local<Object> constants = Object::New(isolate);
#define V(name)                                                                \
  constants                                                                    \
      ->Set(context,                                                           \
            FIXED_ONE_BYTE_STRING(isolate, #name),                             \
            Integer::New(isolate, Promise::PromiseState::name))                \
      .Check();

    V(kPending);
    V(kFulfilled);
    V(kRejected);
#undef V

#define V(name)                                                                \
  constants                                                                    \
      ->Set(context,                                                           \
            FIXED_ONE_BYTE_STRING(isolate, #name),                             \
            Integer::New(isolate, Environment::ExitInfoField::name))           \
      .Check();

    V(kExiting);
    V(kExitCode);
...",3,,436,6,,void
244671,BLOCK,1,,<empty>,,,,3,,void
244694,BLOCK,1,,<empty>,,,,3,,void
244717,BLOCK,1,,<empty>,,,,3,,void
244740,BLOCK,1,,<empty>,,,,3,,void
244763,BLOCK,1,,<empty>,,,,3,,void
244786,BLOCK,1,,<empty>,,,,3,,void
244809,BLOCK,1,,<empty>,,,,3,,void
244830,BLOCK,1,,<empty>,,,,3,,void
244851,BLOCK,1,,<empty>,,,,3,,void
244872,BLOCK,1,,<empty>,,,,3,,void
244893,BLOCK,1,,<empty>,,,,3,,void
244914,BLOCK,1,,<empty>,,,,3,,void
245093,BLOCK,-1,,<empty>,1,,1,1,,ANY
245116,BLOCK,-1,,<empty>,1,,1,1,,ANY
245123,BLOCK,1,,<empty>,,,,1,,void
245156,BLOCK,1,,<empty>,,,,1,,void
245169,BLOCK,1,,<empty>,,,,1,,void
245182,BLOCK,-1,,"{
  Local<Context> context = realm->context();
  if (info == nullptr) {
    obj->Set(context,
             FIXED_ONE_BYTE_STRING(realm->isolate(), ""heapStatisticsBuffer""),
             heap_statistics_buffer.GetJSArray())
        .Check();
    obj->Set(
           context,
           FIXED_ONE_BYTE_STRING(realm->isolate(), ""heapCodeStatisticsBuffer""),
           heap_code_statistics_buffer.GetJSArray())
        .Check();
    obj->Set(
           context,
           FIXED_ONE_BYTE_STRING(realm->isolate(), ""heapSpaceStatisticsBuffer""),
           heap_space_statistics_buffer.GetJSArray())
        .Check();
  } else {
    heap_statistics_buffer.Deserialize(realm->context());
    heap_code_statistics_buffer.Deserialize(realm->context());
    heap_space_statistics_buffer.Deserialize(realm->context());
  }
  heap_statistics_buffer.MakeWeak();
  heap_space_statistics_buffer.MakeWeak();
  heap_code_statistics_buffer.MakeWeak();
}",63,,109,4,,void
245197,BLOCK,-1,,"{
    obj->Set(context,
             FIXED_ONE_BYTE_STRING(realm->isolate(), ""heapStatisticsBuffer""),
             heap_statistics_buffer.GetJSArray())
        .Check();
    obj->Set(
           context,
           FIXED_ONE_BYTE_STRING(realm->isolate(), ""heapCodeStatisticsBuffer""),
           heap_code_statistics_buffer.GetJSArray())
        .Check();
    obj->Set(
           context,
           FIXED_ONE_BYTE_STRING(realm->isolate(), ""heapSpaceStatisticsBuffer""),
           heap_space_statistics_buffer.GetJSArray())
        .Check();
  }",24,,111,2,,void
245253,BLOCK,-1,,"{
    heap_statistics_buffer.Deserialize(realm->context());
    heap_code_statistics_buffer.Deserialize(realm->context());
    heap_space_statistics_buffer.Deserialize(realm->context());
  }",10,,126,1,,void
245295,BLOCK,-1,,"{
  DCHECK_NULL(internal_field_info_);
  internal_field_info_ = InternalFieldInfoBase::New<InternalFieldInfo>(type());
  internal_field_info_->heap_statistics_buffer =
      heap_statistics_buffer.Serialize(context, creator);
  internal_field_info_->heap_space_statistics_buffer =
      heap_space_statistics_buffer.Serialize(context, creator);
  internal_field_info_->heap_code_statistics_buffer =
      heap_code_statistics_buffer.Serialize(context, creator);
  // Return true because we need to maintain the reference to the binding from
  // JS land.
  return true;
}",73,,137,3,,void
245345,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  HandleScope scope(context->GetIsolate());
  Realm* realm = Realm::GetCurrent(context);
  // Recreate the buffer in the constructor.
  InternalFieldInfo* casted_info = static_cast<InternalFieldInfo*>(info);
  BindingData* binding =
      realm->AddBindingData<BindingData>(context, holder, casted_info);
  CHECK_NOT_NULL(binding);
}",60,,154,5,,void
245391,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  InternalFieldInfo* info = internal_field_info_;
  internal_field_info_ = nullptr;
  return info;
}",58,,165,2,,void
245410,BLOCK,-1,,"{
  tracker->TrackField(""heap_statistics_buffer"", heap_statistics_buffer);
  tracker->TrackField(""heap_space_statistics_buffer"",
                      heap_space_statistics_buffer);
  tracker->TrackField(""heap_code_statistics_buffer"",
                      heap_code_statistics_buffer);
}",60,,172,2,,void
245433,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Local<Integer> result =
      Integer::NewFromUnsigned(env->isolate(),
                               ScriptCompiler::CachedDataVersionTag());
  args.GetReturnValue().Set(result);
}",68,,180,2,,void
245472,BLOCK,-1,,"{
  CHECK(args[0]->IsUint32());
  Environment* env = Environment::GetCurrent(args);
  uint32_t limit = args[0].As<v8::Uint32>()->Value();
  CHECK_GT(limit, 0);
  env->AddHeapSnapshotNearHeapLimitCallback();
  env->set_heap_snapshot_near_heap_limit(limit);
}",76,,188,2,,void
245516,BLOCK,-1,,"{
  BindingData* data = Realm::GetBindingData<BindingData>(args);
  HeapStatistics s;
  args.GetIsolate()->GetHeapStatistics(&s);
  AliasedFloat64Array& buffer = data->heap_statistics_buffer;
#define V(index, name, _) buffer[index] = static_cast<double>(s.name());
  HEAP_STATISTICS_PROPERTIES(V)
#undef V
}",74,,197,2,,void
245544,BLOCK,1,,<empty>,,,,3,,void
245689,BLOCK,-1,,"{
  BindingData* data = Realm::GetBindingData<BindingData>(args);
  HeapSpaceStatistics s;
  Isolate* const isolate = args.GetIsolate();
  CHECK(args[0]->IsUint32());
  size_t space_index = static_cast<size_t>(args[0].As<v8::Uint32>()->Value());
  isolate->GetHeapSpaceStatistics(&s, space_index);

  AliasedFloat64Array& buffer = data->heap_space_statistics_buffer;

#define V(index, name, _) buffer[index] = static_cast<double>(s.name());
  HEAP_SPACE_STATISTICS_PROPERTIES(V)
#undef V
}",79,,208,2,,void
245743,BLOCK,1,,<empty>,,,,3,,void
245788,BLOCK,-1,,"{
  BindingData* data = Realm::GetBindingData<BindingData>(args);
  HeapCodeStatistics s;
  args.GetIsolate()->GetHeapCodeAndMetadataStatistics(&s);
  AliasedFloat64Array& buffer = data->heap_code_statistics_buffer;

#define V(index, name, _) buffer[index] = static_cast<double>(s.name());
  HEAP_CODE_STATISTICS_PROPERTIES(V)
#undef V
}",78,,223,2,,void
245816,BLOCK,1,,<empty>,,,,3,,void
245861,BLOCK,-1,,"{
  CHECK(args[0]->IsString());
  String::Utf8Value flags(args.GetIsolate(), args[0]);
  V8::SetFlagsFromString(*flags, static_cast<size_t>(flags.length()));
}",66,,235,2,,void
245894,BLOCK,-1,,"{
  switch (gc_type) {
    case v8::GCType::kGCTypeScavenge:
      return ""Scavenge"";
    case v8::GCType::kGCTypeMarkSweepCompact:
      return ""MarkSweepCompact"";
    case v8::GCType::kGCTypeIncrementalMarking:
      return ""IncrementalMarking"";
    case v8::GCType::kGCTypeProcessWeakCallbacks:
      return ""ProcessWeakCallbacks"";
    default:
      return ""Unknown"";
  }
}",54,,241,2,,void
245897,BLOCK,-1,,"{
    case v8::GCType::kGCTypeScavenge:
      return ""Scavenge"";
    case v8::GCType::kGCTypeMarkSweepCompact:
      return ""MarkSweepCompact"";
    case v8::GCType::kGCTypeIncrementalMarking:
      return ""IncrementalMarking"";
    case v8::GCType::kGCTypeProcessWeakCallbacks:
      return ""ProcessWeakCallbacks"";
    default:
      return ""Unknown"";
  }",20,,242,2,,void
245938,BLOCK,-1,,"{
  HeapStatistics heap_statistics;
  isolate->GetHeapStatistics(&heap_statistics);
  writer->json_objectstart(""heapStatistics"");
  writer->json_keyvalue(""totalHeapSize"", heap_statistics.total_heap_size());
  writer->json_keyvalue(""totalHeapSizeExecutable"",
                        heap_statistics.total_heap_size_executable());
  writer->json_keyvalue(""totalPhysicalSize"",
                        heap_statistics.total_physical_size());
  writer->json_keyvalue(""totalAvailableSize"",
                        heap_statistics.total_available_size());
  writer->json_keyvalue(""totalGlobalHandlesSize"",
                        heap_statistics.total_global_handles_size());
  writer->json_keyvalue(""usedGlobalHandlesSize"",
                        heap_statistics.used_global_handles_size());
  writer->json_keyvalue(""usedHeapSize"", heap_statistics.used_heap_size());
  writer->json_keyvalue(""heapSizeLimit"", heap_statistics.heap_size_limit());
  writer->json_keyvalue(""mallocedMemory"", heap_statistics....",69,,256,3,,void
246067,BLOCK,-1,,<empty>,3,,281,1,,void
246077,BLOCK,4,,"{
    HeapSpaceStatistics heap_space_statistics;
    isolate->GetHeapSpaceStatistics(&heap_space_statistics, i);
    writer->json_start();
    writer->json_keyvalue(""spaceName"", heap_space_statistics.space_name());
    writer->json_keyvalue(""spaceSize"", heap_space_statistics.space_size());
    writer->json_keyvalue(""spaceUsedSize"",
                          heap_space_statistics.space_used_size());
    writer->json_keyvalue(""spaceAvailableSize"",
                          heap_space_statistics.space_available_size());
    writer->json_keyvalue(""physicalSpaceSize"",
                          heap_space_statistics.physical_space_size());
    writer->json_end();
  }",41,,281,4,,void
246150,BLOCK,-1,,"{
  GCProfiler* profiler = static_cast<GCProfiler*>(data);
  if (profiler->current_gc_type != 0) {
    return;
  }
  JSONWriter* writer = profiler->writer();
  writer->json_start();
  writer->json_keyvalue(""gcType"", GetGCTypeName(gc_type));
  writer->json_objectstart(""beforeGC"");
  SetHeapStatistics(writer, isolate);
  writer->json_objectend();
  profiler->current_gc_type = gc_type;
  profiler->start_time = uv_hrtime();
}",42,,301,5,,void
246163,BLOCK,-1,,"{
    return;
  }",39,,303,2,,void
246212,BLOCK,-1,,"{
  GCProfiler* profiler = static_cast<GCProfiler*>(data);
  if (profiler->current_gc_type != gc_type) {
    return;
  }
  JSONWriter* writer = profiler->writer();
  profiler->current_gc_type = 0;
  writer->json_keyvalue(""cost"", (uv_hrtime() - profiler->start_time) / 1e3);
  profiler->start_time = 0;
  writer->json_objectstart(""afterGC"");
  SetHeapStatistics(writer, isolate);
  writer->json_objectend();
  writer->json_end();
}",41,,319,5,,void
246225,BLOCK,-1,,"{
    return;
  }",45,,321,2,,void
246277,BLOCK,-1,,"{
  MakeWeak();
}",35,,339,3,,void
246282,BLOCK,-1,,"{
  if (state != GCProfiler::GCProfilerState::kInitialized) {
    env()->isolate()->RemoveGCPrologueCallback(BeforeGCCallback, this);
    env()->isolate()->RemoveGCEpilogueCallback(AfterGCCallback, this);
  }
}",27,,348,1,,void
246291,BLOCK,-1,,"{
    env()->isolate()->RemoveGCPrologueCallback(BeforeGCCallback, this);
    env()->isolate()->RemoveGCEpilogueCallback(AfterGCCallback, this);
  }",59,,349,2,,void
246313,BLOCK,-1,,"{
  return &writer_;
}",34,,355,1,,void
246320,BLOCK,-1,,"{
  return &out_stream_;
}",46,,359,1,,void
246328,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);
  new GCProfiler(env, args.This());
}",63,,363,2,,void
246353,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  GCProfiler* profiler;
  ASSIGN_OR_RETURN_UNWRAP(&profiler, args.Holder());
  if (profiler->state != GCProfiler::GCProfilerState::kInitialized) {
    return;
  }
  profiler->writer()->json_start();
  profiler->writer()->json_keyvalue(""version"", 1);

  uv_timeval64_t ts;
  if (uv_gettimeofday(&ts) == 0) {
    profiler->writer()->json_keyvalue(""startTime"",
                                      ts.tv_sec * 1000 + ts.tv_usec / 1000);
  } else {
    profiler->writer()->json_keyvalue(""startTime"", 0);
  }
  profiler->writer()->json_arraystart(""statistics"");
  env->isolate()->AddGCPrologueCallback(BeforeGCCallback,
                                        static_cast<void*>(profiler));
  env->isolate()->AddGCEpilogueCallback(AfterGCCallback,
                                        static_cast<void*>(profiler));
  profiler->state = GCProfiler::GCProfilerState::kStarted;
}",65,,369,2,,void
246380,BLOCK,-1,,"{
    return;
  }",69,,373,2,,void
246405,BLOCK,-1,,"{
    profiler->writer()->json_keyvalue(""startTime"",
                                      ts.tv_sec * 1000 + ts.tv_usec / 1000);
  }",34,,380,2,,void
246426,BLOCK,-1,,"{
    profiler->writer()->json_keyvalue(""startTime"", 0);
  }",10,,383,1,,void
246479,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  GCProfiler* profiler;
  ASSIGN_OR_RETURN_UNWRAP(&profiler, args.Holder());
  if (profiler->state != GCProfiler::GCProfilerState::kStarted) {
    return;
  }
  profiler->writer()->json_arrayend();
  uv_timeval64_t ts;
  if (uv_gettimeofday(&ts) == 0) {
    profiler->writer()->json_keyvalue(""endTime"",
                                      ts.tv_sec * 1000 + ts.tv_usec / 1000);
  } else {
    profiler->writer()->json_keyvalue(""endTime"", 0);
  }
  profiler->writer()->json_end();
  profiler->state = GCProfiler::GCProfilerState::kStopped;
  auto string = profiler->out_stream()->str();
  args.GetReturnValue().Set(String::NewFromUtf8(env->isolate(),
                                                string.data(),
                                                v8::NewStringType::kNormal,
                                                string.size())
                                .ToLocalChecked());
}",68,,394,2,,void
246506,BLOCK,-1,,"{
    return;
  }",65,,398,2,,void
246522,BLOCK,-1,,"{
    profiler->writer()->json_keyvalue(""endTime"",
                                      ts.tv_sec * 1000 + ts.tv_usec / 1000);
  }",34,,403,2,,void
246543,BLOCK,-1,,"{
    profiler->writer()->json_keyvalue(""endTime"", 0);
  }",10,,406,1,,void
246617,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(context);
  Environment* env = realm->env();
  BindingData* const binding_data =
      realm->AddBindingData<BindingData>(context, target);
  if (binding_data == nullptr) return;

  SetMethodNoSideEffect(
      context, target, ""cachedDataVersionTag"", CachedDataVersionTag);
  SetMethodNoSideEffect(context,
                        target,
                        ""setHeapSnapshotNearHeapLimit"",
                        SetHeapSnapshotNearHeapLimit);
  SetMethod(context,
            target,
            ""updateHeapStatisticsBuffer"",
            UpdateHeapStatisticsBuffer);

  SetMethod(context,
            target,
            ""updateHeapCodeStatisticsBuffer"",
            UpdateHeapCodeStatisticsBuffer);

  size_t number_of_heap_spaces = env->isolate()->NumberOfHeapSpaces();

  // Heap space names are extracted once and exposed to JavaScript to
  // avoid excessive creation of heap space name Strings.
  HeapSpaceStatistics s;
  MaybeStackBuffer<Local<V...",29,,422,5,,void
246650,BLOCK,-1,,<empty>,32,,427,2,,void
246687,BLOCK,-1,,<empty>,3,,451,1,,void
246697,BLOCK,4,,"{
    env->isolate()->GetHeapSpaceStatistics(&s, i);
    heap_spaces[i] = String::NewFromUtf8(env->isolate(), s.space_name())
                                             .ToLocalChecked();
  }",54,,451,4,,void
246760,BLOCK,1,,<empty>,,,,3,,void
247084,BLOCK,1,,<empty>,,,,3,,void
247178,BLOCK,1,,<empty>,,,,3,,void
247329,BLOCK,-1,,"{
  registry->Register(CachedDataVersionTag);
  registry->Register(UpdateHeapStatisticsBuffer);
  registry->Register(UpdateHeapCodeStatisticsBuffer);
  registry->Register(UpdateHeapSpaceStatisticsBuffer);
  registry->Register(SetFlagsFromString);
  registry->Register(SetHeapSnapshotNearHeapLimit);
  registry->Register(GCProfiler::New);
  registry->Register(GCProfiler::Start);
  registry->Register(GCProfiler::Stop);
}",70,,492,2,,void
247402,BLOCK,-1,,<empty>,1,,1,1,,ANY
247429,BLOCK,-1,,<empty>,1,,1,1,,ANY
247434,BLOCK,-1,,<empty>,1,,1,1,,ANY
247461,BLOCK,-1,,<empty>,1,,1,1,,ANY
247467,BLOCK,-1,,"{
  Debug(wasi.env(), DebugCategory::WASI, std::forward<Args>(args)...);
}",53,,17,3,,void
247489,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  Environment* env = Environment::GetCurrent(context);
  CHECK_NOT_NULL(env);
  const char* err_name = uvwasi_embedder_err_code_to_string(errorno);
  Local<String> js_code = OneByteString(isolate, err_name);
  Local<String> js_syscall = OneByteString(isolate, syscall);
  Local<String> js_msg = js_code;
  js_msg =
      String::Concat(isolate, js_msg, FIXED_ONE_BYTE_STRING(isolate, "", ""));
  js_msg = String::Concat(isolate, js_msg, js_syscall);
  Local<Object> e;
  if (!Exception::Error(js_msg)->ToObject(context).ToLocal(&e))
    return MaybeLocal<Value>();

  if (e->Set(context,
             env->errno_string(),
             Integer::New(isolate, errorno)).IsNothing() ||
      e->Set(context, env->code_string(), js_code).IsNothing() ||
      e->Set(context, env->syscall_string(), js_syscall).IsNothing()) {
    return MaybeLocal<Value>();
  }

  return e;
}",61,,50,4,,void
247578,BLOCK,-1,,<empty>,5,,63,2,,void
247628,BLOCK,-1,,"{
    return MaybeLocal<Value>();
  }",71,,69,2,,void
247639,BLOCK,-1,,"{
  MakeWeak();
  alloc_info_ = MakeAllocator();
  options->allocator = &alloc_info_;
  int err = uvwasi_init(&uvw_, options);
  if (err != UVWASI_ESUCCESS) {
    Local<Value> exception;
    if (!WASIException(env->context(), err, ""uvwasi_init"").ToLocal(&exception))
      return;

    env->isolate()->ThrowException(exception);
  }
}",65,,79,4,,void
247661,BLOCK,-1,,"{
    Local<Value> exception;
    if (!WASIException(env->context(), err, ""uvwasi_init"").ToLocal(&exception))
      return;

    env->isolate()->ThrowException(exception);
  }",31,,84,2,,void
247681,BLOCK,-1,,<empty>,7,,87,2,,void
247694,BLOCK,-1,,"{
  uvwasi_destroy(&uvw_);
  CHECK_EQ(current_uvwasi_memory_, 0);
}",15,,94,1,,void
247703,BLOCK,-1,,"{
  tracker->TrackField(""memory"", memory_);
  tracker->TrackFieldWithSize(""uvwasi_memory"", current_uvwasi_memory_);
}",53,,99,2,,void
247720,BLOCK,-1,,"{
  CHECK_GE(current_uvwasi_memory_, previous_size);
}",59,,104,2,,void
247728,BLOCK,-1,,"{
  current_uvwasi_memory_ += size;
}",47,,108,2,,void
247736,BLOCK,-1,,"{
  current_uvwasi_memory_ -= size;
}",47,,112,2,,void
247744,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  CHECK_EQ(args.Length(), 4);
  CHECK(args[0]->IsArray());
  CHECK(args[1]->IsArray());
  CHECK(args[2]->IsArray());
  CHECK(args[3]->IsArray());

  Environment* env = Environment::GetCurrent(args);
  Local<Context> context = env->context();
  Local<Array> argv = args[0].As<Array>();
  const uint32_t argc = argv->Length();
  uvwasi_options_t options;

  uvwasi_options_init(&options);

  Local<Array> stdio = args[3].As<Array>();
  CHECK_EQ(stdio->Length(), 3);
  options.in = stdio->Get(context, 0).ToLocalChecked()->
    Int32Value(context).FromJust();
  options.out = stdio->Get(context, 1).ToLocalChecked()->
    Int32Value(context).FromJust();
  options.err = stdio->Get(context, 2).ToLocalChecked()->
    Int32Value(context).FromJust();

  options.fd_table_size = 3;
  options.argc = argc;
  options.argv =
    const_cast<const char**>(argc == 0 ? nullptr : new char*[argc]);

  for (uint32_t i = 0; i < argc; i++) {
    auto arg = argv->Get(context, i)....",57,,116,2,,void
247927,BLOCK,-1,,<empty>,3,,146,1,,void
247937,BLOCK,4,,"{
    auto arg = argv->Get(context, i).ToLocalChecked();
    CHECK(arg->IsString());
    node::Utf8Value str(env->isolate(), arg);
    options.argv[i] = strdup(*str);
    CHECK_NOT_NULL(options.argv[i]);
  }",39,,146,4,,void
248005,BLOCK,-1,,<empty>,3,,157,1,,void
248015,BLOCK,4,,"{
    auto pair = env_pairs->Get(context, i).ToLocalChecked();
    CHECK(pair->IsString());
    node::Utf8Value str(env->isolate(), pair);
    options.envp[i] = strdup(*str);
    CHECK_NOT_NULL(options.envp[i]);
  }",39,,157,4,,void
248108,BLOCK,-1,,<empty>,3,,171,1,,void
248122,BLOCK,4,,"{
    auto mapped = preopens->Get(context, i).ToLocalChecked();
    auto real = preopens->Get(context, i + 1).ToLocalChecked();
    CHECK(mapped->IsString());
    CHECK(real->IsString());
    node::Utf8Value mapped_path(env->isolate(), mapped);
    node::Utf8Value real_path(env->isolate(), real);
    options.preopens[index].mapped_path = strdup(*mapped_path);
    CHECK_NOT_NULL(options.preopens[index].mapped_path);
    options.preopens[index].real_path = strdup(*real_path);
    CHECK_NOT_NULL(options.preopens[index].real_path);
    index++;
  }",56,,171,4,,void
248228,BLOCK,-1,,"{
    for (uint32_t i = 0; i < argc; i++)
      free(const_cast<char*>(options.argv[i]));
    delete[] options.argv;
  }",32,,187,2,,void
248230,BLOCK,-1,,<empty>,5,,188,1,,void
248253,BLOCK,-1,,<empty>,3,,193,1,,void
248283,BLOCK,-1,,"{
    for (uint32_t i = 0; i < options.preopenc; i++) {
      free(const_cast<char*>(options.preopens[i].mapped_path));
      free(const_cast<char*>(options.preopens[i].real_path));
    }

    free(options.preopens);
  }",36,,197,2,,void
248285,BLOCK,-1,,<empty>,5,,198,1,,void
248297,BLOCK,4,,"{
      free(const_cast<char*>(options.preopens[i].mapped_path));
      free(const_cast<char*>(options.preopens[i].real_path));
    }",53,,198,4,,void
248328,BLOCK,-1,,"{
  auto c_function = CFunction::Make(FastCallback);
  Local<FunctionTemplate> t =
      FunctionTemplate::New(env->isolate(),
                            SlowCallback,
                            Local<Value>(),
                            Local<Signature>(),
                            sizeof...(Args),
                            v8::ConstructorBehavior::kThrow,
                            v8::SideEffectType::kHasSideEffect,
                            &c_function);
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<String> name_string =
      String::NewFromUtf8(env->isolate(), name, type).ToLocalChecked();
  tmpl->PrototypeTemplate()->Set(name_string, t);
  t->SetClassName(name_string);
}",71,,209,4,,void
248413,BLOCK,-1,,<empty>,,,,1,,<empty>
248417,BLOCK,-1,,"{
  return UVWASI_EINVAL;
}",31,,232,1,,void
248423,BLOCK,-1,,<empty>,27,,237,1,,void
248430,BLOCK,-1,,"{
  WASI* wasi = reinterpret_cast<WASI*>(BaseObject::FromJSObject(receiver));
  if (UNLIKELY(wasi == nullptr)) return EinvalError<R>();

  if (UNLIKELY(options.wasm_memory == nullptr || wasi->memory_.IsEmpty())) {
    // fallback to slow path which to throw an error about missing memory.
    options.fallback = true;
    return EinvalError<R>();
  }
  uint8_t* memory = nullptr;
  CHECK(LIKELY(options.wasm_memory->getStorageIfAligned(&memory)));

  return F(*wasi,
           {reinterpret_cast<char*>(memory), options.wasm_memory->length()},
           args...);
}",38,,245,4,,void
248446,BLOCK,-1,,<empty>,34,,247,2,,void
248463,BLOCK,-1,,"{
    // fallback to slow path which to throw an error about missing memory.
    options.fallback = true;
    return EinvalError<R>();
  }",76,,249,2,,void
248505,BLOCK,-1,,<empty>,,,,2,,<empty>
248510,BLOCK,-1,,<empty>,,,,2,,<empty>
248515,BLOCK,-1,,"{
  return value->IsUint32();
}",46,,270,2,,void
248525,BLOCK,-1,,"{
  return value.As<Uint32>()->Value();
}",42,,275,2,,void
248538,BLOCK,-1,,"{
  return value->IsBigInt();
}",46,,280,2,,void
248548,BLOCK,-1,,"{
  Local<BigInt> js_value = value.As<BigInt>();
  bool lossless;
  return js_value->Uint64Value(&lossless);
}",42,,285,2,,void
248571,BLOCK,-1,,"{
  return value->IsBigInt();
}",45,,292,2,,void
248581,BLOCK,-1,,"{
  Local<BigInt> js_value = value.As<BigInt>();
  bool lossless;
  return js_value->Int64Value(&lossless);
}",41,,297,2,,void
248606,BLOCK,-1,,"{
  return CheckType<T>(info[i]);
}",68,,304,4,,void
248619,BLOCK,-1,,"{
  if (!CheckTypes<T>(info, i, arg)) return false;
  return CheckTypes<Ts...>(info, i + 1, args...);
}",29,,312,5,,void
248626,BLOCK,-1,,<empty>,37,,313,2,,void
248640,BLOCK,-1,,"{
  return CheckTypes<Args...>(info, 0, Args()...);
}",58,,318,2,,void
248650,BLOCK,-1,,"{
  return true;
}",58,,323,2,,void
248660,BLOCK,-1,,"{
  args.GetReturnValue().Set(
      F(*wasi, memory, ConvertType<Args>(args[Indices])...));
}",49,,336,5,,void
248683,BLOCK,-1,,"{
  F(*wasi, memory, ConvertType<Args>(args[Indices])...);
}",49,,350,5,,void
248696,BLOCK,-1,,"{
  if (args.Length() != sizeof...(Args)) {
    args.GetReturnValue().Set(UVWASI_EINVAL);
    return;
  }
  if (!CheckTypes<Args...>(args)) {
    args.GetReturnValue().Set(UVWASI_EINVAL);
    return;
  }

  WASI* wasi;
  ASSIGN_OR_RETURN_UNWRAP(&wasi, args.This());
  if (wasi->memory_.IsEmpty()) {
    THROW_ERR_WASI_NOT_STARTED(Environment::GetCurrent(args));
    return;
  }

  Local<WasmMemoryObject> memory = PersistentToLocal::Strong(wasi->memory_);
  Local<ArrayBuffer> ab = memory->Buffer();
  size_t mem_size = ab->ByteLength();
  char* mem_data = static_cast<char*>(ab->Data());
  CHECK_NOT_NULL(mem_data);

  CallAndSetReturn<FT, F, R, Args...>(
      std::make_index_sequence<sizeof...(Args)>{},
      args,
      wasi,
      {mem_data, mem_size});
}",46,,358,2,,void
248705,BLOCK,-1,,"{
    args.GetReturnValue().Set(UVWASI_EINVAL);
    return;
  }",41,,359,2,,void
248719,BLOCK,-1,,"{
    args.GetReturnValue().Set(UVWASI_EINVAL);
    return;
  }",35,,363,2,,void
248744,BLOCK,-1,,"{
    THROW_ERR_WASI_NOT_STARTED(Environment::GetCurrent(args));
    return;
  }",32,,370,2,,void
248808,BLOCK,-1,,"{
  WASI::WasiFunction<FT, F, R, Args...>::SetFunction(env, name, tmpl);
}",55,,392,5,,void
248825,BLOCK,-1,,"{
  Debug(wasi, ""args_get(%d, %d)\n"", argv_offset, argv_buf_offset);

  CHECK_BOUNDS_OR_RETURN(memory.size, argv_buf_offset, wasi.uvw_.argv_buf_size);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, argv_offset, wasi.uvw_.argc * UVWASI_SERDES_SIZE_uint32_t);
  std::vector<char*> argv(wasi.uvw_.argc);
  char* argv_buf = &memory.data[argv_buf_offset];
  uvwasi_errno_t err = uvwasi_args_get(&wasi.uvw_, argv.data(), argv_buf);

  if (err == UVWASI_ESUCCESS) {
    for (size_t i = 0; i < wasi.uvw_.argc; i++) {
      uint32_t offset =
          static_cast<uint32_t>(argv_buf_offset + (argv[i] - argv[0]));
      uvwasi_serdes_write_uint32_t(
          memory.data, argv_offset + (i * UVWASI_SERDES_SIZE_uint32_t), offset);
    }
  }

  return err;
}",50,,399,5,,void
248841,BLOCK,1,,<empty>,,,,4,,void
248843,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, argv_buf_offset, wasi.uvw_.argv_buf_size)",3,,402,1,,void
248856,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, argv_buf_offset, wasi.uvw_.argv_buf_size)",3,,402,2,,void
248865,BLOCK,1,,<empty>,,,,3,,void
248867,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, argv_offset, wasi.uvw_.argc * UVWASI_SERDES_SIZE_uint32_t)",3,,403,1,,void
248882,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, argv_offset, wasi.uvw_.argc * UVWASI_SERDES_SIZE_uint32_t)",3,,403,2,,void
248919,BLOCK,-1,,"{
    for (size_t i = 0; i < wasi.uvw_.argc; i++) {
      uint32_t offset =
          static_cast<uint32_t>(argv_buf_offset + (argv[i] - argv[0]));
      uvwasi_serdes_write_uint32_t(
          memory.data, argv_offset + (i * UVWASI_SERDES_SIZE_uint32_t), offset);
    }
  }",31,,409,2,,void
248921,BLOCK,-1,,<empty>,5,,410,1,,void
248935,BLOCK,4,,"{
      uint32_t offset =
          static_cast<uint32_t>(argv_buf_offset + (argv[i] - argv[0]));
      uvwasi_serdes_write_uint32_t(
          memory.data, argv_offset + (i * UVWASI_SERDES_SIZE_uint32_t), offset);
    }",49,,410,4,,void
248969,BLOCK,-1,,"{
  Debug(wasi, ""args_sizes_get(%d, %d)\n"", argc_offset, argv_buf_offset);
  CHECK_BOUNDS_OR_RETURN(memory.size, argc_offset, UVWASI_SERDES_SIZE_size_t);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, argv_buf_offset, UVWASI_SERDES_SIZE_size_t);
  uvwasi_size_t argc;
  uvwasi_size_t argv_buf_size;
  uvwasi_errno_t err = uvwasi_args_sizes_get(&wasi.uvw_, &argc, &argv_buf_size);
  if (err == UVWASI_ESUCCESS) {
    uvwasi_serdes_write_size_t(memory.data, argc_offset, argc);
    uvwasi_serdes_write_size_t(memory.data, argv_buf_offset, argv_buf_size);
  }

  return err;
}",55,,424,5,,void
248981,BLOCK,1,,<empty>,,,,4,,void
248983,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, argc_offset, UVWASI_SERDES_SIZE_size_t)",3,,426,1,,void
248992,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, argc_offset, UVWASI_SERDES_SIZE_size_t)",3,,426,2,,void
249002,BLOCK,1,,<empty>,,,,4,,void
249004,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, argv_buf_offset, UVWASI_SERDES_SIZE_size_t)",3,,427,1,,void
249013,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, argv_buf_offset, UVWASI_SERDES_SIZE_size_t)",3,,427,2,,void
249035,BLOCK,-1,,"{
    uvwasi_serdes_write_size_t(memory.data, argc_offset, argc);
    uvwasi_serdes_write_size_t(memory.data, argv_buf_offset, argv_buf_size);
  }",31,,432,2,,void
249057,BLOCK,-1,,"{
  Debug(wasi, ""clock_res_get(%d, %d)\n"", clock_id, resolution_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, resolution_ptr, UVWASI_SERDES_SIZE_timestamp_t);
  uvwasi_timestamp_t resolution;
  uvwasi_errno_t err = uvwasi_clock_res_get(&wasi.uvw_, clock_id, &resolution);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_timestamp_t(memory.data, resolution_ptr, resolution);

  return err;
}",53,,443,5,,void
249069,BLOCK,1,,<empty>,,,,4,,void
249071,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, resolution_ptr, UVWASI_SERDES_SIZE_timestamp_t)",3,,445,1,,void
249080,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, resolution_ptr, UVWASI_SERDES_SIZE_timestamp_t)",3,,445,2,,void
249100,BLOCK,-1,,<empty>,5,,450,2,,void
249117,BLOCK,-1,,"{
  Debug(wasi, ""clock_time_get(%d, %d, %d)\n"", clock_id, precision, time_ptr);
  CHECK_BOUNDS_OR_RETURN(memory.size, time_ptr, UVWASI_SERDES_SIZE_timestamp_t);
  uvwasi_timestamp_t time;
  uvwasi_errno_t err =
      uvwasi_clock_time_get(&wasi.uvw_, clock_id, precision, &time);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_timestamp_t(memory.data, time_ptr, time);

  return err;
}",48,,459,6,,void
249130,BLOCK,1,,<empty>,,,,4,,void
249132,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, time_ptr, UVWASI_SERDES_SIZE_timestamp_t)",3,,461,1,,void
249141,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, time_ptr, UVWASI_SERDES_SIZE_timestamp_t)",3,,461,2,,void
249162,BLOCK,-1,,<empty>,5,,466,2,,void
249178,BLOCK,-1,,"{
  Debug(wasi, ""environ_get(%d, %d)\n"", environ_offset, environ_buf_offset);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, environ_buf_offset, wasi.uvw_.env_buf_size);
  CHECK_BOUNDS_OR_RETURN(memory.size,
                         environ_offset,
                         wasi.uvw_.envc * UVWASI_SERDES_SIZE_uint32_t);
  std::vector<char*> environment(wasi.uvw_.envc);
  char* environ_buf = &memory.data[environ_buf_offset];
  uvwasi_errno_t err =
      uvwasi_environ_get(&wasi.uvw_, environment.data(), environ_buf);

  if (err == UVWASI_ESUCCESS) {
    for (size_t i = 0; i < wasi.uvw_.envc; i++) {
      uint32_t offset = static_cast<uint32_t>(
          environ_buf_offset + (environment[i] - environment[0]));

      uvwasi_serdes_write_uint32_t(
          memory.data,
          environ_offset + (i * UVWASI_SERDES_SIZE_uint32_t),
          offset);
    }
  }

  return err;
}",56,,474,5,,void
249194,BLOCK,1,,<empty>,,,,4,,void
249196,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, environ_buf_offset, wasi.uvw_.env_buf_size)",3,,476,1,,void
249209,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, environ_buf_offset, wasi.uvw_.env_buf_size)",3,,476,2,,void
249218,BLOCK,1,,<empty>,,,,3,,void
249220,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size,
                         environ_offset,
                         wasi.uvw_.envc * UVWASI_SERDES_SIZE_uint32_t)",3,,478,1,,void
249235,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size,
                         environ_offset,
                         wasi.uvw_.envc * UVWASI_SERDES_SIZE_uint32_t)",3,,478,2,,void
249272,BLOCK,-1,,"{
    for (size_t i = 0; i < wasi.uvw_.envc; i++) {
      uint32_t offset = static_cast<uint32_t>(
          environ_buf_offset + (environment[i] - environment[0]));

      uvwasi_serdes_write_uint32_t(
          memory.data,
          environ_offset + (i * UVWASI_SERDES_SIZE_uint32_t),
          offset);
    }
  }",31,,486,2,,void
249274,BLOCK,-1,,<empty>,5,,487,1,,void
249288,BLOCK,4,,"{
      uint32_t offset = static_cast<uint32_t>(
          environ_buf_offset + (environment[i] - environment[0]));

      uvwasi_serdes_write_uint32_t(
          memory.data,
          environ_offset + (i * UVWASI_SERDES_SIZE_uint32_t),
          offset);
    }",49,,487,4,,void
249322,BLOCK,-1,,"{
  Debug(wasi, ""environ_sizes_get(%d, %d)\n"", envc_offset, env_buf_offset);
  CHECK_BOUNDS_OR_RETURN(memory.size, envc_offset, UVWASI_SERDES_SIZE_size_t);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, env_buf_offset, UVWASI_SERDES_SIZE_size_t);
  uvwasi_size_t envc;
  uvwasi_size_t env_buf_size;
  uvwasi_errno_t err =
      uvwasi_environ_sizes_get(&wasi.uvw_, &envc, &env_buf_size);
  if (err == UVWASI_ESUCCESS) {
    uvwasi_serdes_write_size_t(memory.data, envc_offset, envc);
    uvwasi_serdes_write_size_t(memory.data, env_buf_offset, env_buf_size);
  }

  return err;
}",57,,504,5,,void
249334,BLOCK,1,,<empty>,,,,4,,void
249336,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, envc_offset, UVWASI_SERDES_SIZE_size_t)",3,,506,1,,void
249345,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, envc_offset, UVWASI_SERDES_SIZE_size_t)",3,,506,2,,void
249355,BLOCK,1,,<empty>,,,,4,,void
249357,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, env_buf_offset, UVWASI_SERDES_SIZE_size_t)",3,,507,1,,void
249366,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, env_buf_offset, UVWASI_SERDES_SIZE_size_t)",3,,507,2,,void
249388,BLOCK,-1,,"{
    uvwasi_serdes_write_size_t(memory.data, envc_offset, envc);
    uvwasi_serdes_write_size_t(memory.data, env_buf_offset, env_buf_size);
  }",31,,513,2,,void
249412,BLOCK,-1,,"{
  Debug(wasi, ""fd_advise(%d, %d, %d, %d)\n"", fd, offset, len, advice);
  return uvwasi_fd_advise(&wasi.uvw_, fd, offset, len, advice);
}",42,,526,7,,void
249438,BLOCK,-1,,"{
  Debug(wasi, ""fd_allocate(%d, %d, %d)\n"", fd, offset, len);
  return uvwasi_fd_allocate(&wasi.uvw_, fd, offset, len);
}",73,,532,6,,void
249460,BLOCK,-1,,"{
  Debug(wasi, ""fd_close(%d)\n"", fd);
  return uvwasi_fd_close(&wasi.uvw_, fd);
}",61,,537,4,,void
249478,BLOCK,-1,,"{
  Debug(wasi, ""fd_datasync(%d)\n"", fd);
  return uvwasi_fd_datasync(&wasi.uvw_, fd);
}",64,,542,4,,void
249497,BLOCK,-1,,"{
  Debug(wasi, ""fd_fdstat_get(%d, %d)\n"", fd, buf);
  CHECK_BOUNDS_OR_RETURN(memory.size, buf, UVWASI_SERDES_SIZE_fdstat_t);
  uvwasi_fdstat_t stats;
  uvwasi_errno_t err = uvwasi_fd_fdstat_get(&wasi.uvw_, fd, &stats);

  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_fdstat_t(memory.data, buf, &stats);

  return err;
}",42,,550,5,,void
249509,BLOCK,1,,<empty>,,,,4,,void
249511,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, buf, UVWASI_SERDES_SIZE_fdstat_t)",3,,552,1,,void
249520,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, buf, UVWASI_SERDES_SIZE_fdstat_t)",3,,552,2,,void
249540,BLOCK,-1,,<empty>,5,,557,2,,void
249557,BLOCK,-1,,"{
  Debug(wasi, ""fd_fdstat_set_flags(%d, %d)\n"", fd, flags);
  return uvwasi_fd_fdstat_set_flags(&wasi.uvw_, fd, flags);
}",49,,565,5,,void
249579,BLOCK,-1,,"{
  Debug(wasi,
        ""fd_fdstat_set_rights(%d, %d, %d)\n"",
        fd,
        fs_rights_base,
        fs_rights_inheriting);
  return uvwasi_fd_fdstat_set_rights(
      &wasi.uvw_, fd, fs_rights_base, fs_rights_inheriting);
}",65,,574,6,,void
249602,BLOCK,-1,,"{
  Debug(wasi, ""fd_filestat_get(%d, %d)\n"", fd, buf);
  CHECK_BOUNDS_OR_RETURN(memory.size, buf, UVWASI_SERDES_SIZE_filestat_t);
  uvwasi_filestat_t stats;
  uvwasi_errno_t err = uvwasi_fd_filestat_get(&wasi.uvw_, fd, &stats);

  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_filestat_t(memory.data, buf, &stats);

  return err;
}",44,,587,5,,void
249614,BLOCK,1,,<empty>,,,,4,,void
249616,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, buf, UVWASI_SERDES_SIZE_filestat_t)",3,,589,1,,void
249625,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, buf, UVWASI_SERDES_SIZE_filestat_t)",3,,589,2,,void
249645,BLOCK,-1,,<empty>,5,,594,2,,void
249662,BLOCK,-1,,"{
  Debug(wasi, ""fd_filestat_set_size(%d, %d)\n"", fd, st_size);
  return uvwasi_fd_filestat_set_size(&wasi.uvw_, fd, st_size);
}",52,,602,5,,void
249685,BLOCK,-1,,"{
  Debug(wasi,
        ""fd_filestat_set_times(%d, %d, %d, %d)\n"",
        fd,
        st_atim,
        st_mtim,
        fst_flags);
  return uvwasi_fd_filestat_set_times(
      &wasi.uvw_, fd, st_atim, st_mtim, fst_flags);
}",55,,612,7,,void
249713,BLOCK,-1,,"{
  Debug(wasi,
        ""uvwasi_fd_pread(%d, %d, %d, %d, %d)\n"",
        fd,
        iovs_ptr,
        iovs_len,
        offset,
        nread_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, iovs_ptr, iovs_len * UVWASI_SERDES_SIZE_iovec_t);
  CHECK_BOUNDS_OR_RETURN(memory.size, nread_ptr, UVWASI_SERDES_SIZE_size_t);
  std::vector<uvwasi_iovec_t> iovs(iovs_len);
  uvwasi_errno_t err;

  err = uvwasi_serdes_readv_iovec_t(
      memory.data, memory.size, iovs_ptr, iovs.data(), iovs_len);
  if (err != UVWASI_ESUCCESS) {
    return err;
  }

  uvwasi_size_t nread;
  err = uvwasi_fd_pread(&wasi.uvw_, fd, iovs.data(), iovs_len, offset, &nread);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_size_t(memory.data, nread_ptr, nread);

  return err;
}",44,,629,8,,void
249727,BLOCK,1,,<empty>,,,,3,,void
249729,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, iovs_ptr, iovs_len * UVWASI_SERDES_SIZE_iovec_t)",3,,637,1,,void
249740,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, iovs_ptr, iovs_len * UVWASI_SERDES_SIZE_iovec_t)",3,,637,2,,void
249750,BLOCK,1,,<empty>,,,,4,,void
249752,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, nread_ptr, UVWASI_SERDES_SIZE_size_t)",3,,639,1,,void
249761,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, nread_ptr, UVWASI_SERDES_SIZE_size_t)",3,,639,2,,void
249793,BLOCK,-1,,"{
    return err;
  }",31,,645,2,,void
249817,BLOCK,-1,,<empty>,5,,652,2,,void
249833,BLOCK,-1,,"{
  Debug(wasi, ""fd_prestat_get(%d, %d)\n"", fd, buf);
  CHECK_BOUNDS_OR_RETURN(memory.size, buf, UVWASI_SERDES_SIZE_prestat_t);
  uvwasi_prestat_t prestat;
  uvwasi_errno_t err = uvwasi_fd_prestat_get(&wasi.uvw_, fd, &prestat);

  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_prestat_t(memory.data, buf, &prestat);

  return err;
}",43,,660,5,,void
249845,BLOCK,1,,<empty>,,,,4,,void
249847,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, buf, UVWASI_SERDES_SIZE_prestat_t)",3,,662,1,,void
249856,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, buf, UVWASI_SERDES_SIZE_prestat_t)",3,,662,2,,void
249876,BLOCK,-1,,<empty>,5,,667,2,,void
249894,BLOCK,-1,,"{
  Debug(wasi, ""fd_prestat_dir_name(%d, %d, %d)\n"", fd, path_ptr, path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len);
  return uvwasi_fd_prestat_dir_name(
      &wasi.uvw_, fd, &memory.data[path_ptr], path_len);
}",52,,676,6,,void
249907,BLOCK,1,,<empty>,,,,4,,void
249909,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len)",3,,678,1,,void
249918,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len)",3,,678,2,,void
249946,BLOCK,-1,,"{
  Debug(wasi,
        ""uvwasi_fd_pwrite(%d, %d, %d, %d, %d)\n"",
        fd,
        iovs_ptr,
        iovs_len,
        offset,
        nwritten_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, iovs_ptr, iovs_len * UVWASI_SERDES_SIZE_ciovec_t);
  CHECK_BOUNDS_OR_RETURN(memory.size, nwritten_ptr, UVWASI_SERDES_SIZE_size_t);
  std::vector<uvwasi_ciovec_t> iovs(iovs_len);
  uvwasi_errno_t err;

  err = uvwasi_serdes_readv_ciovec_t(
      memory.data, memory.size, iovs_ptr, iovs.data(), iovs_len);
  if (err != UVWASI_ESUCCESS) {
    return err;
  }

  uvwasi_size_t nwritten;
  err = uvwasi_fd_pwrite(
      &wasi.uvw_, fd, iovs.data(), iovs_len, offset, &nwritten);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_size_t(memory.data, nwritten_ptr, nwritten);

  return err;
}",48,,689,8,,void
249960,BLOCK,1,,<empty>,,,,3,,void
249962,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, iovs_ptr, iovs_len * UVWASI_SERDES_SIZE_ciovec_t)",3,,697,1,,void
249973,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, iovs_ptr, iovs_len * UVWASI_SERDES_SIZE_ciovec_t)",3,,697,2,,void
249983,BLOCK,1,,<empty>,,,,4,,void
249985,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, nwritten_ptr, UVWASI_SERDES_SIZE_size_t)",3,,699,1,,void
249994,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, nwritten_ptr, UVWASI_SERDES_SIZE_size_t)",3,,699,2,,void
250026,BLOCK,-1,,"{
    return err;
  }",31,,705,2,,void
250050,BLOCK,-1,,<empty>,5,,713,2,,void
250068,BLOCK,-1,,"{
  Debug(wasi, ""fd_read(%d, %d, %d, %d)\n"", fd, iovs_ptr, iovs_len, nread_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, iovs_ptr, iovs_len * UVWASI_SERDES_SIZE_iovec_t);
  CHECK_BOUNDS_OR_RETURN(memory.size, nread_ptr, UVWASI_SERDES_SIZE_size_t);
  std::vector<uvwasi_iovec_t> iovs(iovs_len);
  uvwasi_errno_t err;

  err = uvwasi_serdes_readv_iovec_t(
      memory.data, memory.size, iovs_ptr, iovs.data(), iovs_len);
  if (err != UVWASI_ESUCCESS) {
    return err;
  }

  uvwasi_size_t nread;
  err = uvwasi_fd_read(&wasi.uvw_, fd, iovs.data(), iovs_len, &nread);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_size_t(memory.data, nread_ptr, nread);

  return err;
}",43,,723,7,,void
250081,BLOCK,1,,<empty>,,,,3,,void
250083,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, iovs_ptr, iovs_len * UVWASI_SERDES_SIZE_iovec_t)",3,,725,1,,void
250094,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, iovs_ptr, iovs_len * UVWASI_SERDES_SIZE_iovec_t)",3,,725,2,,void
250104,BLOCK,1,,<empty>,,,,4,,void
250106,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, nread_ptr, UVWASI_SERDES_SIZE_size_t)",3,,727,1,,void
250115,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, nread_ptr, UVWASI_SERDES_SIZE_size_t)",3,,727,2,,void
250147,BLOCK,-1,,"{
    return err;
  }",31,,733,2,,void
250170,BLOCK,-1,,<empty>,5,,740,2,,void
250189,BLOCK,-1,,"{
  Debug(wasi,
        ""uvwasi_fd_readdir(%d, %d, %d, %d, %d)\n"",
        fd,
        buf_ptr,
        buf_len,
        cookie,
        bufused_ptr);
  CHECK_BOUNDS_OR_RETURN(memory.size, buf_ptr, buf_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, bufused_ptr, UVWASI_SERDES_SIZE_size_t);
  uvwasi_size_t bufused;
  uvwasi_errno_t err = uvwasi_fd_readdir(
      &wasi.uvw_, fd, &memory.data[buf_ptr], buf_len, cookie, &bufused);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_size_t(memory.data, bufused_ptr, bufused);

  return err;
}",48,,751,8,,void
250204,BLOCK,1,,<empty>,,,,4,,void
250206,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, buf_ptr, buf_len)",3,,759,1,,void
250215,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, buf_ptr, buf_len)",3,,759,2,,void
250225,BLOCK,1,,<empty>,,,,4,,void
250227,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, bufused_ptr, UVWASI_SERDES_SIZE_size_t)",3,,760,1,,void
250236,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, bufused_ptr, UVWASI_SERDES_SIZE_size_t)",3,,760,2,,void
250264,BLOCK,-1,,<empty>,5,,765,2,,void
250280,BLOCK,-1,,"{
  Debug(wasi, ""fd_renumber(%d, %d)\n"", from, to);
  return uvwasi_fd_renumber(&wasi.uvw_, from, to);
}",79,,770,5,,void
250303,BLOCK,-1,,"{
  Debug(wasi, ""fd_seek(%d, %d, %d, %d)\n"", fd, offset, whence, newoffset_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, newoffset_ptr, UVWASI_SERDES_SIZE_filesize_t);
  uvwasi_filesize_t newoffset;
  uvwasi_errno_t err =
      uvwasi_fd_seek(&wasi.uvw_, fd, offset, whence, &newoffset);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_filesize_t(memory.data, newoffset_ptr, newoffset);

  return err;
}",47,,780,7,,void
250317,BLOCK,1,,<empty>,,,,4,,void
250319,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, newoffset_ptr, UVWASI_SERDES_SIZE_filesize_t)",3,,782,1,,void
250328,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, newoffset_ptr, UVWASI_SERDES_SIZE_filesize_t)",3,,782,2,,void
250350,BLOCK,-1,,<empty>,5,,788,2,,void
250365,BLOCK,-1,,"{
  Debug(wasi, ""fd_sync(%d)\n"", fd);
  return uvwasi_fd_sync(&wasi.uvw_, fd);
}",60,,793,4,,void
250384,BLOCK,-1,,"{
  Debug(wasi, ""fd_tell(%d, %d)\n"", fd, offset_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, offset_ptr, UVWASI_SERDES_SIZE_filesize_t);
  uvwasi_filesize_t offset;
  uvwasi_errno_t err = uvwasi_fd_tell(&wasi.uvw_, fd, &offset);

  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_filesize_t(memory.data, offset_ptr, offset);

  return err;
}",44,,801,5,,void
250396,BLOCK,1,,<empty>,,,,4,,void
250398,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, offset_ptr, UVWASI_SERDES_SIZE_filesize_t)",3,,803,1,,void
250407,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, offset_ptr, UVWASI_SERDES_SIZE_filesize_t)",3,,803,2,,void
250427,BLOCK,-1,,<empty>,5,,809,2,,void
250445,BLOCK,-1,,"{
  Debug(wasi,
        ""fd_write(%d, %d, %d, %d)\n"",
        fd,
        iovs_ptr,
        iovs_len,
        nwritten_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, iovs_ptr, iovs_len * UVWASI_SERDES_SIZE_ciovec_t);
  CHECK_BOUNDS_OR_RETURN(memory.size, nwritten_ptr, UVWASI_SERDES_SIZE_size_t);
  std::vector<uvwasi_ciovec_t> iovs(iovs_len);
  uvwasi_errno_t err;

  err = uvwasi_serdes_readv_ciovec_t(
      memory.data, memory.size, iovs_ptr, iovs.data(), iovs_len);
  if (err != UVWASI_ESUCCESS) {
    return err;
  }

  uvwasi_size_t nwritten;
  err = uvwasi_fd_write(&wasi.uvw_, fd, iovs.data(), iovs_len, &nwritten);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_size_t(memory.data, nwritten_ptr, nwritten);

  return err;
}",47,,819,7,,void
250458,BLOCK,1,,<empty>,,,,3,,void
250460,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, iovs_ptr, iovs_len * UVWASI_SERDES_SIZE_ciovec_t)",3,,826,1,,void
250471,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, iovs_ptr, iovs_len * UVWASI_SERDES_SIZE_ciovec_t)",3,,826,2,,void
250481,BLOCK,1,,<empty>,,,,4,,void
250483,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, nwritten_ptr, UVWASI_SERDES_SIZE_size_t)",3,,828,1,,void
250492,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, nwritten_ptr, UVWASI_SERDES_SIZE_size_t)",3,,828,2,,void
250524,BLOCK,-1,,"{
    return err;
  }",31,,834,2,,void
250547,BLOCK,-1,,<empty>,5,,841,2,,void
250564,BLOCK,-1,,"{
  Debug(wasi, ""path_create_directory(%d, %d, %d)\n"", fd, path_ptr, path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len);
  uvwasi_errno_t err = uvwasi_path_create_directory(
      &wasi.uvw_, fd, &memory.data[path_ptr], path_len);
  return err;
}",55,,850,6,,void
250577,BLOCK,1,,<empty>,,,,4,,void
250579,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len)",3,,852,1,,void
250588,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len)",3,,852,2,,void
250620,BLOCK,-1,,"{
  Debug(wasi,
        ""path_filestat_get(%d, %d, %d)\n"",
        fd,
        path_ptr,
        path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, buf_ptr, UVWASI_SERDES_SIZE_filestat_t);
  uvwasi_filestat_t stats;
  uvwasi_errno_t err = uvwasi_path_filestat_get(
      &wasi.uvw_, fd, flags, &memory.data[path_ptr], path_len, &stats);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_filestat_t(memory.data, buf_ptr, &stats);

  return err;
}",50,,864,8,,void
250633,BLOCK,1,,<empty>,,,,4,,void
250635,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len)",3,,870,1,,void
250644,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len)",3,,870,2,,void
250654,BLOCK,1,,<empty>,,,,4,,void
250656,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, buf_ptr, UVWASI_SERDES_SIZE_filestat_t)",3,,871,1,,void
250665,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, buf_ptr, UVWASI_SERDES_SIZE_filestat_t)",3,,871,2,,void
250693,BLOCK,-1,,<empty>,5,,876,2,,void
250715,BLOCK,-1,,"{
  Debug(wasi,
        ""path_filestat_set_times(%d, %d, %d, %d, %d, %d, %d)\n"",
        fd,
        flags,
        path_ptr,
        path_len,
        st_atim,
        st_mtim,
        fst_flags);
  CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len);
  return uvwasi_path_filestat_set_times(&wasi.uvw_,
                                        fd,
                                        flags,
                                        &memory.data[path_ptr],
                                        path_len,
                                        st_atim,
                                        st_mtim,
                                        fst_flags);
}",57,,889,10,,void
250732,BLOCK,1,,<empty>,,,,4,,void
250734,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len)",3,,899,1,,void
250743,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len)",3,,899,2,,void
250777,BLOCK,-1,,"{
  Debug(wasi,
        ""path_link(%d, %d, %d, %d, %d, %d, %d)\n"",
        old_fd,
        old_flags,
        old_path_ptr,
        old_path_len,
        new_fd,
        new_path_ptr,
        new_path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, old_path_ptr, old_path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, new_path_ptr, new_path_len);
  return uvwasi_path_link(&wasi.uvw_,
                          old_fd,
                          old_flags,
                          &memory.data[old_path_ptr],
                          old_path_len,
                          new_fd,
                          &memory.data[new_path_ptr],
                          new_path_len);
}",48,,918,10,,void
250794,BLOCK,1,,<empty>,,,,4,,void
250796,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, old_path_ptr, old_path_len)",3,,928,1,,void
250805,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, old_path_ptr, old_path_len)",3,,928,2,,void
250815,BLOCK,1,,<empty>,,,,4,,void
250817,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, new_path_ptr, new_path_len)",3,,929,1,,void
250826,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, new_path_ptr, new_path_len)",3,,929,2,,void
250867,BLOCK,-1,,"{
  Debug(wasi,
        ""path_open(%d, %d, %d, %d, %d, %d, %d, %d, %d)\n"",
        dirfd,
        dirflags,
        path_ptr,
        path_len,
        o_flags,
        fs_rights_base,
        fs_rights_inheriting,
        fs_flags,
        fd_ptr);
  CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, fd_ptr, UVWASI_SERDES_SIZE_fd_t);
  uvwasi_fd_t fd;
  uvwasi_errno_t err = uvwasi_path_open(&wasi.uvw_,
                                        dirfd,
                                        dirflags,
                                        &memory.data[path_ptr],
                                        path_len,
                                        static_cast<uvwasi_oflags_t>(o_flags),
                                        fs_rights_base,
                                        fs_rights_inheriting,
                                        static_cast<uvwasi_fdflags_t>(fs_flags),
                                        &fd);
  if (err =...",42,,950,12,,void
250886,BLOCK,1,,<empty>,,,,4,,void
250888,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len)",3,,962,1,,void
250897,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len)",3,,962,2,,void
250907,BLOCK,1,,<empty>,,,,4,,void
250909,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, fd_ptr, UVWASI_SERDES_SIZE_fd_t)",3,,963,1,,void
250918,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, fd_ptr, UVWASI_SERDES_SIZE_fd_t)",3,,963,2,,void
250954,BLOCK,-1,,<empty>,5,,976,2,,void
250974,BLOCK,-1,,"{
  Debug(wasi,
        ""path_readlink(%d, %d, %d, %d, %d, %d)\n"",
        fd,
        path_ptr,
        path_len,
        buf_ptr,
        buf_len,
        bufused_ptr);
  CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, buf_ptr, buf_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, bufused_ptr, UVWASI_SERDES_SIZE_size_t);
  uvwasi_size_t bufused;
  uvwasi_errno_t err = uvwasi_path_readlink(&wasi.uvw_,
                                            fd,
                                            &memory.data[path_ptr],
                                            path_len,
                                            &memory.data[buf_ptr],
                                            buf_len,
                                            &bufused);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_size_t(memory.data, bufused_ptr, bufused);

  return err;
}",51,,988,9,,void
250990,BLOCK,1,,<empty>,,,,4,,void
250992,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len)",3,,997,1,,void
251001,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len)",3,,997,2,,void
251011,BLOCK,1,,<empty>,,,,4,,void
251013,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, buf_ptr, buf_len)",3,,998,1,,void
251022,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, buf_ptr, buf_len)",3,,998,2,,void
251032,BLOCK,1,,<empty>,,,,4,,void
251034,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, bufused_ptr, UVWASI_SERDES_SIZE_size_t)",3,,999,1,,void
251043,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, bufused_ptr, UVWASI_SERDES_SIZE_size_t)",3,,999,2,,void
251077,BLOCK,-1,,<empty>,5,,1009,2,,void
251094,BLOCK,-1,,"{
  Debug(wasi, ""path_remove_directory(%d, %d, %d)\n"", fd, path_ptr, path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len);
  return uvwasi_path_remove_directory(
      &wasi.uvw_, fd, &memory.data[path_ptr], path_len);
}",55,,1018,6,,void
251107,BLOCK,1,,<empty>,,,,4,,void
251109,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len)",3,,1020,1,,void
251118,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len)",3,,1020,2,,void
251147,BLOCK,-1,,"{
  Debug(wasi,
        ""path_rename(%d, %d, %d, %d, %d, %d)\n"",
        old_fd,
        old_path_ptr,
        old_path_len,
        new_fd,
        new_path_ptr,
        new_path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, old_path_ptr, old_path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, new_path_ptr, new_path_len);
  return uvwasi_path_rename(&wasi.uvw_,
                            old_fd,
                            &memory.data[old_path_ptr],
                            old_path_len,
                            new_fd,
                            &memory.data[new_path_ptr],
                            new_path_len);
}",50,,1032,9,,void
251163,BLOCK,1,,<empty>,,,,4,,void
251165,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, old_path_ptr, old_path_len)",3,,1041,1,,void
251174,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, old_path_ptr, old_path_len)",3,,1041,2,,void
251184,BLOCK,1,,<empty>,,,,4,,void
251186,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, new_path_ptr, new_path_len)",3,,1042,1,,void
251195,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, new_path_ptr, new_path_len)",3,,1042,2,,void
251231,BLOCK,-1,,"{
  Debug(wasi,
        ""path_symlink(%d, %d, %d, %d, %d)\n"",
        old_path_ptr,
        old_path_len,
        fd,
        new_path_ptr,
        new_path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, old_path_ptr, old_path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, new_path_ptr, new_path_len);
  return uvwasi_path_symlink(&wasi.uvw_,
                             &memory.data[old_path_ptr],
                             old_path_len,
                             fd,
                             &memory.data[new_path_ptr],
                             new_path_len);
}",51,,1058,8,,void
251246,BLOCK,1,,<empty>,,,,4,,void
251248,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, old_path_ptr, old_path_len)",3,,1066,1,,void
251257,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, old_path_ptr, old_path_len)",3,,1066,2,,void
251267,BLOCK,1,,<empty>,,,,4,,void
251269,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, new_path_ptr, new_path_len)",3,,1067,1,,void
251278,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, new_path_ptr, new_path_len)",3,,1067,2,,void
251311,BLOCK,-1,,"{
  Debug(wasi, ""path_unlink_file(%d, %d, %d)\n"", fd, path_ptr, path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len);
  return uvwasi_path_unlink_file(
      &wasi.uvw_, fd, &memory.data[path_ptr], path_len);
}",50,,1080,6,,void
251324,BLOCK,1,,<empty>,,,,4,,void
251326,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len)",3,,1082,1,,void
251335,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len)",3,,1082,2,,void
251362,BLOCK,-1,,"{
  Debug(wasi,
        ""poll_oneoff(%d, %d, %d, %d)\n"",
        in_ptr,
        out_ptr,
        nsubscriptions,
        nevents_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, in_ptr, nsubscriptions * UVWASI_SERDES_SIZE_subscription_t);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, out_ptr, nsubscriptions * UVWASI_SERDES_SIZE_event_t);
  CHECK_BOUNDS_OR_RETURN(memory.size, nevents_ptr, UVWASI_SERDES_SIZE_size_t);
  std::vector<uvwasi_subscription_t> in(nsubscriptions);
  std::vector<uvwasi_event_t> out(nsubscriptions);

  for (uint32_t i = 0; i < nsubscriptions; ++i) {
    uvwasi_serdes_read_subscription_t(memory.data, in_ptr, &in[i]);
    in_ptr += UVWASI_SERDES_SIZE_subscription_t;
  }

  uvwasi_size_t nevents;
  uvwasi_errno_t err = uvwasi_poll_oneoff(
      &wasi.uvw_, in.data(), out.data(), nsubscriptions, &nevents);
  if (err == UVWASI_ESUCCESS) {
    uvwasi_serdes_write_size_t(memory.data, nevents_ptr, nevents);

    for (uint32_t i = 0; i < nsubscriptions; ++i) {
      u...",49,,1092,7,,void
251375,BLOCK,1,,<empty>,,,,3,,void
251377,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, in_ptr, nsubscriptions * UVWASI_SERDES_SIZE_subscription_t)",3,,1099,1,,void
251388,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, in_ptr, nsubscriptions * UVWASI_SERDES_SIZE_subscription_t)",3,,1099,2,,void
251397,BLOCK,1,,<empty>,,,,3,,void
251399,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, out_ptr, nsubscriptions * UVWASI_SERDES_SIZE_event_t)",3,,1101,1,,void
251410,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, out_ptr, nsubscriptions * UVWASI_SERDES_SIZE_event_t)",3,,1101,2,,void
251420,BLOCK,1,,<empty>,,,,4,,void
251422,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, nevents_ptr, UVWASI_SERDES_SIZE_size_t)",3,,1103,1,,void
251431,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, nevents_ptr, UVWASI_SERDES_SIZE_size_t)",3,,1103,2,,void
251452,BLOCK,-1,,<empty>,3,,1107,1,,void
251462,BLOCK,4,,"{
    uvwasi_serdes_read_subscription_t(memory.data, in_ptr, &in[i]);
    in_ptr += UVWASI_SERDES_SIZE_subscription_t;
  }",49,,1107,4,,void
251499,BLOCK,-1,,"{
    uvwasi_serdes_write_size_t(memory.data, nevents_ptr, nevents);

    for (uint32_t i = 0; i < nsubscriptions; ++i) {
      uvwasi_serdes_write_event_t(memory.data, out_ptr, &out[i]);
      out_ptr += UVWASI_SERDES_SIZE_event_t;
    }
  }",31,,1115,2,,void
251507,BLOCK,-1,,<empty>,5,,1118,1,,void
251517,BLOCK,4,,"{
      uvwasi_serdes_write_event_t(memory.data, out_ptr, &out[i]);
      out_ptr += UVWASI_SERDES_SIZE_event_t;
    }",51,,1118,4,,void
251538,BLOCK,-1,,"{
  Debug(wasi, ""proc_exit(%d)\n"", code);
  uvwasi_proc_exit(&wasi.uvw_, code);
}",60,,1127,4,,void
251555,BLOCK,-1,,"{
  Debug(wasi, ""proc_raise(%d)\n"", sig);
  return uvwasi_proc_raise(&wasi.uvw_, sig);
}",64,,1132,4,,void
251574,BLOCK,-1,,"{
  Debug(wasi, ""random_get(%d, %d)\n"", buf_ptr, buf_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, buf_ptr, buf_len);
  return uvwasi_random_get(&wasi.uvw_, &memory.data[buf_ptr], buf_len);
}",44,,1140,5,,void
251586,BLOCK,1,,<empty>,,,,4,,void
251588,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, buf_ptr, buf_len)",3,,1142,1,,void
251597,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, buf_ptr, buf_len)",3,,1142,2,,void
251619,BLOCK,-1,,"{
  Debug(wasi, ""sched_yield()\n"");
  return uvwasi_sched_yield(&wasi.uvw_);
}",51,,1146,3,,void
251637,BLOCK,-1,,"{
  Debug(wasi, ""sock_accept(%d, %d, %d)\n"", sock, flags, fd_ptr);
  uvwasi_fd_t fd;
  uvwasi_errno_t err = uvwasi_sock_accept(&wasi.uvw_, sock, flags, &fd);

  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_size_t(memory.data, fd_ptr, fd);

  return err;
}",44,,1155,6,,void
251661,BLOCK,-1,,<empty>,5,,1161,2,,void
251681,BLOCK,-1,,"{
  Debug(wasi,
        ""sock_recv(%d, %d, %d, %d, %d, %d)\n"",
        sock,
        ri_data_ptr,
        ri_data_len,
        ri_flags,
        ro_datalen_ptr,
        ro_flags_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, ri_data_ptr, ri_data_len * UVWASI_SERDES_SIZE_iovec_t);
  CHECK_BOUNDS_OR_RETURN(memory.size, ro_datalen_ptr, 4);
  CHECK_BOUNDS_OR_RETURN(memory.size, ro_flags_ptr, 4);
  std::vector<uvwasi_iovec_t> ri_data(ri_data_len);
  uvwasi_errno_t err = uvwasi_serdes_readv_iovec_t(
      memory.data, memory.size, ri_data_ptr, ri_data.data(), ri_data_len);
  if (err != UVWASI_ESUCCESS) {
    return err;
  }

  uvwasi_size_t ro_datalen;
  uvwasi_roflags_t ro_flags;
  err = uvwasi_sock_recv(&wasi.uvw_,
                         sock,
                         ri_data.data(),
                         ri_data_len,
                         ri_flags,
                         &ro_datalen,
                         &ro_flags);
  if (err == UVWASI_ESUCCESS) {
    uvwasi_serdes_wr...",48,,1173,9,,void
251696,BLOCK,1,,<empty>,,,,3,,void
251698,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, ri_data_ptr, ri_data_len * UVWASI_SERDES_SIZE_iovec_t)",3,,1182,1,,void
251709,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, ri_data_ptr, ri_data_len * UVWASI_SERDES_SIZE_iovec_t)",3,,1182,2,,void
251719,BLOCK,1,,<empty>,,,,4,,void
251721,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, ro_datalen_ptr, 4)",3,,1184,1,,void
251730,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, ro_datalen_ptr, 4)",3,,1184,2,,void
251740,BLOCK,1,,<empty>,,,,4,,void
251742,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, ro_flags_ptr, 4)",3,,1185,1,,void
251751,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(memory.size, ro_flags_ptr, 4)",3,,1185,2,,void
251783,BLOCK,-1,,"{
    return err;
  }",31,,1189,2,,void
251810,BLOCK,-1,,"{
    uvwasi_serdes_write_size_t(memory.data, ro_datalen_ptr, ro_datalen);
    uvwasi_serdes_write_roflags_t(memory.data, ro_flags_ptr, ro_flags);
  }",31,,1202,2,,void
251835,BLOCK,-1,,"{
  Debug(wasi,
        ""sock_send(%d, %d, %d, %d, %d)\n"",
        sock,
        si_data_ptr,
        si_data_len,
        si_flags,
        so_datalen_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, si_data_ptr, si_data_len * UVWASI_SERDES_SIZE_ciovec_t);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, so_datalen_ptr, UVWASI_SERDES_SIZE_size_t);
  std::vector<uvwasi_ciovec_t> si_data(si_data_len);
  uvwasi_errno_t err = uvwasi_serdes_readv_ciovec_t(
      memory.data, memory.size, si_data_ptr, si_data.data(), si_data_len);
  if (err != UVWASI_ESUCCESS) {
    return err;
  }

  uvwasi_size_t so_datalen;
  err = uvwasi_sock_send(
      &wasi.uvw_, sock, si_data.data(), si_data_len, si_flags, &so_datalen);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_size_t(memory.data, so_datalen_ptr, so_datalen);

  return err;
}",50,,1216,8,,void
251849,BLOCK,1,,<empty>,,,,3,,void
251851,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, si_data_ptr, si_data_len * UVWASI_SERDES_SIZE_ciovec_t)",3,,1224,1,,void
251862,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, si_data_ptr, si_data_len * UVWASI_SERDES_SIZE_ciovec_t)",3,,1224,2,,void
251872,BLOCK,1,,<empty>,,,,4,,void
251874,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, so_datalen_ptr, UVWASI_SERDES_SIZE_size_t)",3,,1226,1,,void
251883,BLOCK,-1,,"CHECK_BOUNDS_OR_RETURN(
      memory.size, so_datalen_ptr, UVWASI_SERDES_SIZE_size_t)",3,,1226,2,,void
251915,BLOCK,-1,,"{
    return err;
  }",31,,1231,2,,void
251939,BLOCK,-1,,<empty>,5,,1239,2,,void
251955,BLOCK,-1,,"{
  Debug(wasi, ""sock_shutdown(%d, %d)\n"", sock, how);
  return uvwasi_sock_shutdown(&wasi.uvw_, sock, how);
}",43,,1247,5,,void
251973,BLOCK,-1,,"{
  WASI* wasi;
  ASSIGN_OR_RETURN_UNWRAP(&wasi, args.This());
  CHECK_EQ(args.Length(), 1);
  if (!args[0]->IsWasmMemoryObject()) {
    return node::THROW_ERR_INVALID_ARG_TYPE(
        wasi->env(),
        ""\""instance.exports.memory\"" property must be a WebAssembly.Memory ""
        ""object"");
  }
  wasi->memory_.Reset(wasi->env()->isolate(), args[0].As<WasmMemoryObject>());
}",64,,1252,2,,void
251996,BLOCK,-1,,"{
    return node::THROW_ERR_INVALID_ARG_TYPE(
        wasi->env(),
        ""\""instance.exports.memory\"" property must be a WebAssembly.Memory ""
        ""object"");
  }",39,,1256,2,,void
252033,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> tmpl = NewFunctionTemplate(isolate, WASI::New);
  tmpl->InstanceTemplate()->SetInternalFieldCount(WASI::kInternalFieldCount);

#define V(F, name)                                                             \
  SetFunction<decltype(&WASI::F), WASI::F>(WASI::F, env, name, tmpl);

  V(ArgsGet, ""args_get"")
  V(ArgsSizesGet, ""args_sizes_get"")
  V(ClockResGet, ""clock_res_get"")
  V(ClockTimeGet, ""clock_time_get"")
  V(EnvironGet, ""environ_get"")
  V(EnvironSizesGet, ""environ_sizes_get"")
  V(FdAdvise, ""fd_advise"")
  V(FdAllocate, ""fd_allocate"")
  V(FdClose, ""fd_close"")
  V(FdDatasync, ""fd_datasync"")
  V(FdFdstatGet, ""fd_fdstat_get"")
  V(FdFdstatSetFlags, ""fd_fdstat_set_flags"")
  V(FdFdstatSetRights, ""fd_fdstat_set_rights"")
  V(FdFilestatGet, ""fd_filestat_get"")
  V(FdFilestatSetSize, ""fd_filestat_set_size"")
  V(FdFilestatSetTimes, ""fd_filestat_set_times"")
  V(FdPread, ""fd_pr...",44,,1268,5,,void
252072,BLOCK,1,,<empty>,,,,3,,void
252083,BLOCK,1,,<empty>,,,,3,,void
252094,BLOCK,1,,<empty>,,,,3,,void
252105,BLOCK,1,,<empty>,,,,3,,void
252116,BLOCK,1,,<empty>,,,,3,,void
252127,BLOCK,1,,<empty>,,,,3,,void
252138,BLOCK,1,,<empty>,,,,3,,void
252149,BLOCK,1,,<empty>,,,,3,,void
252160,BLOCK,1,,<empty>,,,,3,,void
252171,BLOCK,1,,<empty>,,,,3,,void
252182,BLOCK,1,,<empty>,,,,3,,void
252193,BLOCK,1,,<empty>,,,,3,,void
252204,BLOCK,1,,<empty>,,,,3,,void
252215,BLOCK,1,,<empty>,,,,3,,void
252226,BLOCK,1,,<empty>,,,,3,,void
252237,BLOCK,1,,<empty>,,,,3,,void
252248,BLOCK,1,,<empty>,,,,3,,void
252259,BLOCK,1,,<empty>,,,,3,,void
252270,BLOCK,1,,<empty>,,,,3,,void
252281,BLOCK,1,,<empty>,,,,3,,void
252292,BLOCK,1,,<empty>,,,,3,,void
252303,BLOCK,1,,<empty>,,,,3,,void
252314,BLOCK,1,,<empty>,,,,3,,void
252325,BLOCK,1,,<empty>,,,,3,,void
252336,BLOCK,1,,<empty>,,,,3,,void
252347,BLOCK,1,,<empty>,,,,3,,void
252358,BLOCK,1,,<empty>,,,,3,,void
252369,BLOCK,1,,<empty>,,,,3,,void
252380,BLOCK,1,,<empty>,,,,3,,void
252391,BLOCK,1,,<empty>,,,,3,,void
252402,BLOCK,1,,<empty>,,,,3,,void
252413,BLOCK,1,,<empty>,,,,3,,void
252424,BLOCK,1,,<empty>,,,,3,,void
252435,BLOCK,1,,<empty>,,,,3,,void
252446,BLOCK,1,,<empty>,,,,3,,void
252457,BLOCK,1,,<empty>,,,,3,,void
252468,BLOCK,1,,<empty>,,,,3,,void
252479,BLOCK,1,,<empty>,,,,3,,void
252490,BLOCK,1,,<empty>,,,,3,,void
252501,BLOCK,1,,<empty>,,,,3,,void
252512,BLOCK,1,,<empty>,,,,3,,void
252523,BLOCK,1,,<empty>,,,,3,,void
252534,BLOCK,1,,<empty>,,,,3,,void
252545,BLOCK,1,,<empty>,,,,3,,void
252556,BLOCK,1,,<empty>,,,,3,,void
252567,BLOCK,1,,<empty>,,,,3,,void
252603,BLOCK,-1,,<empty>,1,,1,1,,ANY
252616,BLOCK,-1,,<empty>,1,,1,1,,ANY
252621,BLOCK,-1,,"{
  Local<Function> templ = env->wasm_streaming_object_constructor();
  if (!templ.IsEmpty()) {
    return templ;
  }

  Isolate* isolate = env->isolate();
  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);
  t->InstanceTemplate()->SetInternalFieldCount(
      WasmStreamingObject::kInternalFieldCount);

  SetProtoMethod(isolate, t, ""setURL"", SetURL);
  SetProtoMethod(isolate, t, ""push"", Push);
  SetProtoMethod(isolate, t, ""finish"", Finish);
  SetProtoMethod(isolate, t, ""abort"", Abort);

  auto function = t->GetFunction(env->context()).ToLocalChecked();
  env->set_wasm_streaming_object_constructor(function);
  return function;
}",67,,23,2,,void
252638,BLOCK,-1,,"{
    return templ;
  }",25,,25,2,,void
252712,BLOCK,-1,,"{
  registry->Register(New);
  registry->Register(Push);
  registry->Register(Finish);
  registry->Register(Abort);
}",42,,45,2,,void
252737,BLOCK,-1,,"{
  // v8::WasmStreaming is opaque. We assume that the size of the WebAssembly
  // module that is being compiled is roughly what V8 allocates (as in, off by
  // only a small factor).
  tracker->TrackFieldWithSize(""streaming"", wasm_size_);
}",68,,52,2,,void
252749,BLOCK,-1,,"{
  Local<Function> ctor = Initialize(env);
  Local<Object> obj;
  if (!ctor->NewInstance(env->context(), 0, nullptr).ToLocal(&obj)) {
    return MaybeLocal<Object>();
  }

  CHECK(streaming);

  WasmStreamingObject* ptr = Unwrap<WasmStreamingObject>(obj);
  CHECK_NOT_NULL(ptr);
  ptr->streaming_ = streaming;
  ptr->wasm_size_ = 0;
  return obj;
}",65,,60,3,,void
252780,BLOCK,-1,,"{
    return MaybeLocal<Object>();
  }",69,,63,2,,void
252811,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);
  new WasmStreamingObject(env, args.This());
}",72,,76,2,,void
252836,BLOCK,-1,,"{
  WasmStreamingObject* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.Holder());
  CHECK(obj->streaming_);

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsString());
  Utf8Value url(Environment::GetCurrent(args)->isolate(), args[0]);
  obj->streaming_->SetUrl(url.out(), url.length());
}",75,,82,2,,void
252893,BLOCK,-1,,"{
  WasmStreamingObject* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.Holder());
  CHECK(obj->streaming_);

  CHECK_EQ(args.Length(), 1);
  Local<Value> chunk = args[0];

  // The start of the memory section backing the ArrayBuffer(View), the offset
  // of the ArrayBuffer(View) within the memory section, and its size in bytes.
  const void* bytes;
  size_t offset;
  size_t size;

  if (LIKELY(chunk->IsArrayBufferView())) {
    Local<ArrayBufferView> view = chunk.As<ArrayBufferView>();
    bytes = view->Buffer()->Data();
    offset = view->ByteOffset();
    size = view->ByteLength();
  } else if (LIKELY(chunk->IsArrayBuffer())) {
    Local<ArrayBuffer> buffer = chunk.As<ArrayBuffer>();
    bytes = buffer->Data();
    offset = 0;
    size = buffer->ByteLength();
  } else {
    return node::THROW_ERR_INVALID_ARG_TYPE(
        Environment::GetCurrent(args),
        ""chunk must be an ArrayBufferView or an ArrayBuffer"");
  }

  // Forward the data to V8. Internally, V8 will make a copy.
  o...",73,,93,2,,void
252930,BLOCK,-1,,"{
    Local<ArrayBufferView> view = chunk.As<ArrayBufferView>();
    bytes = view->Buffer()->Data();
    offset = view->ByteOffset();
    size = view->ByteLength();
  }",43,,107,2,,void
252963,BLOCK,-1,,<empty>,10,,112,1,,void
252970,BLOCK,-1,,"{
    Local<ArrayBuffer> buffer = chunk.As<ArrayBuffer>();
    bytes = buffer->Data();
    offset = 0;
    size = buffer->ByteLength();
  }",46,,112,2,,void
252997,BLOCK,-1,,"{
    return node::THROW_ERR_INVALID_ARG_TYPE(
        Environment::GetCurrent(args),
        ""chunk must be an ArrayBufferView or an ArrayBuffer"");
  }",10,,117,1,,void
253030,BLOCK,-1,,"{
  WasmStreamingObject* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.Holder());
  CHECK(obj->streaming_);

  CHECK_EQ(args.Length(), 0);
  obj->streaming_->Finish();
}",75,,129,2,,void
253059,BLOCK,-1,,"{
  WasmStreamingObject* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.Holder());
  CHECK(obj->streaming_);

  CHECK_EQ(args.Length(), 1);
  obj->streaming_->Abort(args[0]);
}",74,,138,2,,void
253091,BLOCK,-1,,"{
  // V8 passes an instance of v8::WasmStreaming to this callback, which we can
  // use to pass the WebAssembly module bytes to V8 as we receive them.
  // Unfortunately, our fetch() implementation is a JavaScript dependency, so it
  // is difficult to implement the required logic here. Instead, we create a
  // a WasmStreamingObject that encapsulates v8::WasmStreaming and that we can
  // pass to the JavaScript implementation. The JavaScript implementation can
  // then push() bytes from the Response and eventually either finish() or
  // abort() the operation.

  // Create the wrapper object.
  std::shared_ptr<WasmStreaming> streaming =
      WasmStreaming::Unpack(info.GetIsolate(), info.Data());
  Environment* env = Environment::GetCurrent(info);
  Local<Object> obj;
  if (!WasmStreamingObject::Create(env, streaming).ToLocal(&obj)) {
    // A JavaScript exception is pending. Let V8 deal with it.
    return;
  }

  // V8 always passes one argument to this callback.
  CHECK_EQ(in...",73,,147,2,,void
253138,BLOCK,-1,,"{
    // A JavaScript exception is pending. Let V8 deal with it.
    return;
  }",67,,162,2,,void
253210,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(info);
  env->set_wasm_streaming_compilation_impl(info[0].As<Function>());
}",65,,189,2,,void
253236,BLOCK,-1,,"{
  SetMethod(context, target, ""setImplementation"", SetImplementation);
}",24,,197,5,,void
253246,BLOCK,-1,,"{
  registry->Register(SetImplementation);
  registry->Register(StartStreamingCompilation);
  WasmStreamingObject::RegisterExternalReferences(registry);
}",70,,201,2,,void
253273,BLOCK,-1,,<empty>,1,,1,1,,ANY
253277,BLOCK,-1,,"{
    Watchdog* w = ContainerOf(&Watchdog::async_, signal);
    uv_stop(&w->loop_);
  }",62,,51,2,,void
253298,BLOCK,-1,,"{
    TraceSigintWatchdog* watchdog =
        ContainerOf(&TraceSigintWatchdog::handle_, handle);
    watchdog->signal_flag_ = SignalFlags::FromIdle;
    watchdog->HandleInterrupt();
  }",77,,172,2,,void
253325,BLOCK,-1,,"{
        TraceSigintWatchdog* self = static_cast<TraceSigintWatchdog*>(data);
        if (self->signal_flag_ == SignalFlags::None) {
          self->signal_flag_ = SignalFlags::FromInterrupt;
        }
        self->HandleInterrupt();
      }",44,,189,3,,void
253340,BLOCK,-1,,"{
          self->signal_flag_ = SignalFlags::FromInterrupt;
        }",54,,191,2,,void
253373,BLOCK,-1,,<empty>,1,,1,1,,ANY
253379,BLOCK,-1,,"{

  int rc;
  rc = uv_loop_init(&loop_);
  if (rc != 0) {
    OnFatalError(""node::Watchdog::Watchdog()"", ""Failed to initialize uv loop."");
  }

  rc = uv_async_init(&loop_, &async_, [](uv_async_t* signal) {
    Watchdog* w = ContainerOf(&Watchdog::async_, signal);
    uv_stop(&w->loop_);
  });

  CHECK_EQ(0, rc);

  rc = uv_timer_init(&loop_, &timer_);
  CHECK_EQ(0, rc);

  rc = uv_timer_start(&timer_, &Watchdog::Timer, ms, 0);
  CHECK_EQ(0, rc);

  rc = uv_thread_create(&thread_, &Watchdog::Run, this);
  CHECK_EQ(0, rc);
}",48,,43,4,,void
253390,BLOCK,-1,,"{
    OnFatalError(""node::Watchdog::Watchdog()"", ""Failed to initialize uv loop."");
  }",16,,47,2,,void
253445,BLOCK,-1,,"{
  uv_async_send(&async_);
  uv_thread_join(&thread_);

  uv_close(reinterpret_cast<uv_handle_t*>(&async_), nullptr);

  // UV_RUN_DEFAULT so that libuv has a chance to clean up.
  uv_run(&loop_, UV_RUN_DEFAULT);

  CheckedUvLoopClose(&loop_);
}",23,,69,1,,void
253463,BLOCK,-1,,"{
  Watchdog* wd = static_cast<Watchdog*>(arg);

  // UV_RUN_DEFAULT the loop will be stopped either by the async or the
  // timer handle.
  uv_run(&wd->loop_, UV_RUN_DEFAULT);

  // Loop ref count reaches zero when both handles are closed.
  // Close the timer handle on this side and let ~Watchdog() close async_
  uv_close(reinterpret_cast<uv_handle_t*>(&wd->timer_), nullptr);
}",31,,82,2,,void
253488,BLOCK,-1,,"{
  Watchdog* w = ContainerOf(&Watchdog::timer_, timer);
  *w->timed_out_ = true;
  w->isolate()->TerminateExecution();
  uv_stop(&w->loop_);
}",41,,94,2,,void
253521,BLOCK,-1,,"{
  Mutex::ScopedLock lock(SigintWatchdogHelper::GetInstanceActionMutex());
  // Register this watchdog with the global SIGINT/Ctrl+C listener.
  SigintWatchdogHelper::GetInstance()->Register(this);
  // Start the helper thread, if that has not already happened.
  SigintWatchdogHelper::GetInstance()->Start();
}",60,,104,3,,void
253546,BLOCK,-1,,"{
  Mutex::ScopedLock lock(SigintWatchdogHelper::GetInstanceActionMutex());
  SigintWatchdogHelper::GetInstance()->Unregister(this);
  SigintWatchdogHelper::GetInstance()->Stop();
}",35,,113,1,,void
253571,BLOCK,-1,,"{
  *received_signal_ = true;
  isolate_->TerminateExecution();
  return SignalPropagation::kStopPropagation;
}",50,,119,1,,void
253589,BLOCK,-1,,"{
  Isolate* isolate = env->isolate();
  Local<FunctionTemplate> constructor = NewFunctionTemplate(isolate, New);
  constructor->InstanceTemplate()->SetInternalFieldCount(
      TraceSigintWatchdog::kInternalFieldCount);
  constructor->Inherit(HandleWrap::GetConstructorTemplate(env));

  SetProtoMethod(isolate, constructor, ""start"", Start);
  SetProtoMethod(isolate, constructor, ""stop"", Stop);

  SetConstructorFunction(
      env->context(), target, ""TraceSigintWatchdog"", constructor);
}",72,,125,3,,void
253647,BLOCK,-1,,"{
  // This constructor should not be exposed to public javascript.
  // Therefore we assert that we are not trying to call this as a
  // normal function.
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);
  new TraceSigintWatchdog(env, args.This());
}",72,,139,2,,void
253672,BLOCK,-1,,"{
  TraceSigintWatchdog* watchdog;
  ASSIGN_OR_RETURN_UNWRAP(&watchdog, args.Holder());
  Mutex::ScopedLock lock(SigintWatchdogHelper::GetInstanceActionMutex());
  // Register this watchdog with the global SIGINT/Ctrl+C listener.
  SigintWatchdogHelper::GetInstance()->Register(watchdog);
  // Start the helper thread, if that has not already happened.
  int r = SigintWatchdogHelper::GetInstance()->Start();
  CHECK_EQ(r, 0);
}",74,,148,2,,void
253712,BLOCK,-1,,"{
  TraceSigintWatchdog* watchdog;
  ASSIGN_OR_RETURN_UNWRAP(&watchdog, args.Holder());
  Mutex::ScopedLock lock(SigintWatchdogHelper::GetInstanceActionMutex());
  SigintWatchdogHelper::GetInstance()->Unregister(watchdog);
  SigintWatchdogHelper::GetInstance()->Stop();
}",73,,159,2,,void
253747,BLOCK,-1,,"{
  int r = uv_async_init(env->event_loop(), &handle_, [](uv_async_t* handle) {
    TraceSigintWatchdog* watchdog =
        ContainerOf(&TraceSigintWatchdog::handle_, handle);
    watchdog->signal_flag_ = SignalFlags::FromIdle;
    watchdog->HandleInterrupt();
  });
  CHECK_EQ(r, 0);
  uv_unref(reinterpret_cast<uv_handle_t*>(&handle_));
}",54,,171,3,,void
253770,BLOCK,-1,,"{
  /**
   * In case of uv loop polling, i.e. no JS currently running, activate the
   * loop to run a piece of JS code to trigger interruption.
   */
  CHECK_EQ(uv_async_send(&handle_), 0);
  env()->isolate()->RequestInterrupt(
      [](v8::Isolate* isolate, void* data) {
        TraceSigintWatchdog* self = static_cast<TraceSigintWatchdog*>(data);
        if (self->signal_flag_ == SignalFlags::None) {
          self->signal_flag_ = SignalFlags::FromInterrupt;
        }
        self->HandleInterrupt();
      },
      this);
  return SignalPropagation::kContinuePropagation;
}",55,,182,1,,void
253792,BLOCK,-1,,"{
  // Do not nest interrupts.
  if (interrupting) {
    return;
  }
  interrupting = true;
  if (signal_flag_ == SignalFlags::None) {
    return;
  }
  Environment* env_ = env();
  // FIXME: Before
  // https://github.com/nodejs/node/pull/29207#issuecomment-527667993 get
  // fixed, additional JavaScript code evaluation shall be prevented from
  // running during interruption.
  FPrintF(stderr,
      ""KEYBOARD_INTERRUPT: Script execution was interrupted by `SIGINT`\n"");
  if (signal_flag_ == SignalFlags::FromInterrupt) {
    PrintStackTrace(env_->isolate(),
                    v8::StackTrace::CurrentStackTrace(
                        env_->isolate(), 10, v8::StackTrace::kDetailed));
  }
  signal_flag_ = SignalFlags::None;
  interrupting = false;

  Mutex::ScopedLock lock(SigintWatchdogHelper::GetInstanceActionMutex());
  SigintWatchdogHelper::GetInstance()->Unregister(this);
  SigintWatchdogHelper::GetInstance()->Stop();
  raise(SIGINT);
}",45,,200,1,,void
253795,BLOCK,-1,,"{
    return;
  }",21,,202,2,,void
253806,BLOCK,-1,,"{
    return;
  }",42,,206,2,,void
253821,BLOCK,-1,,"{
    PrintStackTrace(env_->isolate(),
                    v8::StackTrace::CurrentStackTrace(
                        env_->isolate(), 10, v8::StackTrace::kDetailed));
  }",51,,216,2,,void
253878,BLOCK,-1,,"{
  if (!instance.watchdog_disabled_ &&
      (dwCtrlType == CTRL_C_EVENT || dwCtrlType == CTRL_BREAK_EVENT)) {
    InformWatchdogsAboutSignal();

    // Return true because the signal has been handled.
    return TRUE;
  } else {
    return FALSE;
  }
}",76,,253,2,,void
253892,BLOCK,-1,,"{
    InformWatchdogsAboutSignal();

    // Return true because the signal has been handled.
    return TRUE;
  }",71,,255,2,,void
253897,BLOCK,-1,,"{
    return FALSE;
  }",10,,260,1,,void
253903,BLOCK,-1,,"{
  Mutex::ScopedLock list_lock(instance.list_mutex_);

  bool is_stopping = false;
#ifdef __POSIX__
  is_stopping = instance.stopping_;
#endif

  // If there are no listeners and the helper thread has been awoken by a signal
  // (= not when stopping it), indicate that by setting has_pending_signal_.
  if (instance.watchdogs_.empty() && !is_stopping) {
    instance.has_pending_signal_ = true;
  }

  for (auto it = instance.watchdogs_.rbegin(); it != instance.watchdogs_.rend();
       it++) {
    SignalPropagation wp = (*it)->HandleSigint();
    if (wp == SignalPropagation::kStopPropagation) {
      break;
    }
  }

  return is_stopping;
}",57,,267,1,,void
253923,BLOCK,-1,,"{
    instance.has_pending_signal_ = true;
  }",52,,277,2,,void
253930,BLOCK,-1,,<empty>,3,,281,1,,void
253950,BLOCK,4,,"{
    SignalPropagation wp = (*it)->HandleSigint();
    if (wp == SignalPropagation::kStopPropagation) {
      break;
    }
  }",14,,282,4,,void
253965,BLOCK,-1,,"{
      break;
    }",52,,284,2,,void
253972,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);

  if (start_stop_count_++ > 0) {
    return 0;
  }

#ifdef __POSIX__
  CHECK_EQ(has_running_thread_, false);
  has_pending_signal_ = false;
  stopping_ = false;

  sigset_t sigmask;
  sigfillset(&sigmask);
  sigset_t savemask;
  CHECK_EQ(0, pthread_sigmask(SIG_SETMASK, &sigmask, &savemask));
  sigmask = savemask;
  int ret = pthread_create(&thread_, nullptr, RunSigintWatchdog, nullptr);
  CHECK_EQ(0, pthread_sigmask(SIG_SETMASK, &sigmask, nullptr));
  if (ret != 0) {
    return ret;
  }
  has_running_thread_ = true;

  RegisterSignalHandler(SIGINT, HandleSignal);
#else
  if (watchdog_disabled_) {
    watchdog_disabled_ = false;
  } else {
    SetConsoleCtrlHandler(WinCtrlCHandlerRoutine, TRUE);
  }
#endif

  return 0;
}",35,,293,1,,void
253981,BLOCK,-1,,"{
    return 0;
  }",32,,296,2,,void
253986,BLOCK,-1,,"{
    watchdog_disabled_ = false;
  }",27,,319,2,,void
253991,BLOCK,-1,,"{
    SetConsoleCtrlHandler(WinCtrlCHandlerRoutine, TRUE);
  }",10,,321,1,,void
254000,BLOCK,-1,,"{
  bool had_pending_signal;
  Mutex::ScopedLock lock(mutex_);

  {
    Mutex::ScopedLock list_lock(list_mutex_);

    had_pending_signal = has_pending_signal_;

    if (--start_stop_count_ > 0) {
      has_pending_signal_ = false;
      return had_pending_signal;
    }

#ifdef __POSIX__
    // Set stopping now because it's only protected by list_mutex_.
    stopping_ = true;
#endif

    watchdogs_.clear();
  }

#ifdef __POSIX__
  if (!has_running_thread_) {
    has_pending_signal_ = false;
    return had_pending_signal;
  }

  // Wake up the helper thread.
  uv_sem_post(&sem_);

  // Wait for the helper thread to finish.
  CHECK_EQ(0, pthread_join(thread_, nullptr));
  has_running_thread_ = false;

  RegisterSignalHandler(SIGINT, SignalExit, true);
#else
  watchdog_disabled_ = true;
#endif

  had_pending_signal = has_pending_signal_;
  has_pending_signal_ = false;

  return had_pending_signal;
}",35,,330,1,,void
254005,BLOCK,4,,"{
    Mutex::ScopedLock list_lock(list_mutex_);

    had_pending_signal = has_pending_signal_;

    if (--start_stop_count_ > 0) {
      has_pending_signal_ = false;
      return had_pending_signal;
    }

#ifdef __POSIX__
    // Set stopping now because it's only protected by list_mutex_.
    stopping_ = true;
#endif

    watchdogs_.clear();
  }",3,,334,4,,void
254017,BLOCK,-1,,"{
      has_pending_signal_ = false;
      return had_pending_signal;
    }",34,,339,2,,void
254041,BLOCK,-1,,"{
  Mutex::ScopedLock lock(list_mutex_);

  return has_pending_signal_;
}",47,,377,1,,void
254051,BLOCK,-1,,"{
  Mutex::ScopedLock lock(list_mutex_);

  watchdogs_.push_back(wd);
}",61,,383,2,,void
254064,BLOCK,-1,,"{
  Mutex::ScopedLock lock(list_mutex_);

  auto it = std::find(watchdogs_.begin(), watchdogs_.end(), wd);

  CHECK_NE(it, watchdogs_.end());
  watchdogs_.erase(it);
}",63,,389,2,,void
254098,BLOCK,-1,,"{
#ifdef __POSIX__
  has_running_thread_ = false;
  stopping_ = false;
  CHECK_EQ(0, uv_sem_init(&sem_, 0));
#else
  watchdog_disabled_ = false;
#endif
}",34,,401,1,,void
254105,BLOCK,-1,,"{
  start_stop_count_ = 0;
  Stop();

#ifdef __POSIX__
  CHECK_EQ(has_running_thread_, false);
  uv_sem_destroy(&sem_);
#endif
}",47,,412,1,,void
254120,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  TraceSigintWatchdog::Init(env, target);
}",36,,429,5,,void
254156,BLOCK,-1,,<empty>,1,,1,1,,ANY
254160,BLOCK,-1,,"{
        *static_cast<bool*>(data) = true;
      }",73,,221,2,,void
254172,BLOCK,-1,,"{
      // TODO(addaleax): This call is harmless but should not be necessary.
      // Figure out why V8 is raising a DCHECK() here without it
      // (in test/parallel/test-async-hooks-worker-asyncfn-terminate-4.js).
      isolate_->CancelTerminateExecution();

      if (!env_) return;
      env_->set_can_call_into_js(false);

      {
        Mutex::ScopedLock lock(mutex_);
        stopped_ = true;
        this->env_ = nullptr;
      }

      env_.reset();
    }",43,,297,1,,void
254180,BLOCK,-1,,<empty>,18,,303,2,,void
254187,BLOCK,4,,"{
        Mutex::ScopedLock lock(mutex_);
        stopped_ = true;
        this->env_ = nullptr;
      }",7,,306,4,,void
254210,BLOCK,-1,,"{
          Exit(static_cast<ExitCode>(exit_code));
        }",79,,366,3,,void
254220,BLOCK,-1,,"{
      return env_vars->Get(name).FromMaybe("""");
    }",79,,528,2,,void
254237,BLOCK,-1,,"{
          if (w->has_ref_)
            env->add_refs(-1);
          w->JoinThread();
          // implicitly delete w
        }",60,,686,2,,void
254242,BLOCK,-1,,<empty>,13,,688,2,,void
254259,BLOCK,-1,,"{
    // XXX: This could become a std::unique_ptr, but that makes at least
    // gcc 6.3 detect undefined behaviour when there shouldn't be any.
    // gcc 7+ handles this well.
    Worker* w = static_cast<Worker*>(arg);
    const uintptr_t stack_top = reinterpret_cast<uintptr_t>(&arg);

    // Leave a few kilobytes just to make sure we're within limits and have
    // some space to do work in C++ land.
    w->stack_base_ = stack_top - (w->stack_size_ - kStackBufferSize);

    w->Run();

    Mutex::ScopedLock lock(w->mutex_);
    w->env()->SetImmediateThreadsafe(
        [w = std::unique_ptr<Worker>(w)](Environment* env) {
          if (w->has_ref_)
            env->add_refs(-1);
          w->JoinThread();
          // implicitly delete w
        });
  }",69,,671,2,,void
254305,BLOCK,-1,,"{
          HandleScope handle_scope(env->isolate());
          Context::Scope context_scope(env->context());

          AsyncHooks::DefaultTriggerAsyncIdScope trigger_id_scope(taker->get());
          BaseObjectPtr<AsyncWrap> stream =
              heap::CreateHeapSnapshotStream(env, std::move(snapshot));
          Local<Value> args[] = {stream->object()};
          taker->get()->MakeCallback(
              env->ondone_string(), arraysize(args), args);
          // implicitly delete `taker`
        }",68,,837,2,,void
254369,BLOCK,-1,,"{
    heap::HeapSnapshotPointer snapshot{
        worker_env->isolate()->GetHeapProfiler()->TakeHeapSnapshot(options)};
    CHECK(snapshot);

    // Here, the worker thread temporarily owns the WorkerHeapSnapshotTaker
    // object.

    env->SetImmediateThreadsafe(
        [taker = std::move(taker),
         snapshot = std::move(snapshot)](Environment* env) mutable {
          HandleScope handle_scope(env->isolate());
          Context::Scope context_scope(env->context());

          AsyncHooks::DefaultTriggerAsyncIdScope trigger_id_scope(taker->get());
          BaseObjectPtr<AsyncWrap> stream =
              heap::CreateHeapSnapshotStream(env, std::move(snapshot));
          Local<Value> args[] = {stream->object()};
          taker->get()->MakeCallback(
              env->ondone_string(), arraysize(args), args);
          // implicitly delete `taker`
        },
        CallbackFlags::kUnrefed);

    // Now, the lambda is delivered to the main thread, as a result, the
    // Worke...",77,,827,2,,void
254432,BLOCK,-1,,<empty>,1,,1,1,,ANY
254450,BLOCK,-1,,"{
  Debug(this, ""Creating new worker instance with thread id %llu"",
        thread_id_.id);

  // Set up everything that needs to be set up in the parent environment.
  MessagePort* parent_port = MessagePort::New(env, env->context());
  if (parent_port == nullptr) {
    // This can happen e.g. because execution is terminating.
    return;
  }

  child_port_data_ = std::make_unique<MessagePortData>(nullptr);
  MessagePort::Entangle(parent_port, child_port_data_.get());

  object()
      ->Set(env->context(), env->message_port_string(), parent_port->object())
      .Check();

  object()->Set(env->context(),
                env->thread_id_string(),
                Number::New(env->isolate(), static_cast<double>(thread_id_.id)))
      .Check();

  // Without this check, to use the permission model with
  // workers (--allow-worker) one would need to pass --allow-inspector as well
  if (env->permission()->is_granted(
          node::permission::PermissionScope::kInspector)) {
    inspect...",37,,65,9,,void
254473,BLOCK,-1,,"{
    // This can happen e.g. because execution is terminating.
    return;
  }",31,,71,2,,void
254555,BLOCK,-1,,"{
    inspector_parent_handle_ =
        GetInspectorParentHandle(env, thread_id_, url.c_str(), name.c_str());
  }",59,,91,2,,void
254589,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  if (env_ != nullptr)
    return env_->is_stopping();
  return stopped_;
}",33,,103,1,,void
254597,BLOCK,-1,,<empty>,5,,106,2,,void
254609,BLOCK,-1,,"{
  constraints->set_stack_limit(reinterpret_cast<uint32_t*>(stack_base_));

  if (resource_limits_[kMaxYoungGenerationSizeMb] > 0) {
    constraints->set_max_young_generation_size_in_bytes(
        static_cast<size_t>(resource_limits_[kMaxYoungGenerationSizeMb] * kMB));
  } else {
    resource_limits_[kMaxYoungGenerationSizeMb] =
        constraints->max_young_generation_size_in_bytes() / kMB;
  }

  if (resource_limits_[kMaxOldGenerationSizeMb] > 0) {
    constraints->set_max_old_generation_size_in_bytes(
        static_cast<size_t>(resource_limits_[kMaxOldGenerationSizeMb] * kMB));
  } else {
    resource_limits_[kMaxOldGenerationSizeMb] =
        constraints->max_old_generation_size_in_bytes() / kMB;
  }

  if (resource_limits_[kCodeRangeSizeMb] > 0) {
    constraints->set_code_range_size_in_bytes(
        static_cast<size_t>(resource_limits_[kCodeRangeSizeMb] * kMB));
  } else {
    resource_limits_[kCodeRangeSizeMb] =
        constraints->code_range_size_in_bytes() / kMB;
  }
}",74,,110,2,,void
254623,BLOCK,-1,,"{
    constraints->set_max_young_generation_size_in_bytes(
        static_cast<size_t>(resource_limits_[kMaxYoungGenerationSizeMb] * kMB));
  }",56,,113,2,,void
254636,BLOCK,-1,,"{
    resource_limits_[kMaxYoungGenerationSizeMb] =
        constraints->max_young_generation_size_in_bytes() / kMB;
  }",10,,116,1,,void
254653,BLOCK,-1,,"{
    constraints->set_max_old_generation_size_in_bytes(
        static_cast<size_t>(resource_limits_[kMaxOldGenerationSizeMb] * kMB));
  }",54,,121,2,,void
254666,BLOCK,-1,,"{
    resource_limits_[kMaxOldGenerationSizeMb] =
        constraints->max_old_generation_size_in_bytes() / kMB;
  }",10,,124,1,,void
254683,BLOCK,-1,,"{
    constraints->set_code_range_size_in_bytes(
        static_cast<size_t>(resource_limits_[kCodeRangeSizeMb] * kMB));
  }",47,,129,2,,void
254696,BLOCK,-1,,"{
    resource_limits_[kCodeRangeSizeMb] =
        constraints->code_range_size_in_bytes() / kMB;
  }",10,,132,1,,void
254711,BLOCK,-1,,"{
    int ret = uv_loop_init(&loop_);
    if (ret != 0) {
      char err_buf[128];
      uv_err_name_r(ret, err_buf, sizeof(err_buf));
      // TODO(joyeecheung): maybe this should be kBootstrapFailure instead?
      w->Exit(ExitCode::kGenericUserError, ""ERR_WORKER_INIT_FAILED"", err_buf);
      return;
    }
    loop_init_failed_ = false;
    uv_loop_configure(&loop_, UV_METRICS_IDLE_TIME);

    std::shared_ptr<ArrayBufferAllocator> allocator =
        ArrayBufferAllocator::Create();
    Isolate::CreateParams params;
    SetIsolateCreateParamsForNode(&params);
    w->UpdateResourceConstraints(&params.constraints);
    params.array_buffer_allocator_shared = allocator;
    Isolate* isolate =
        NewIsolate(&params, &loop_, w->platform_, w->snapshot_data());
    if (isolate == nullptr) {
      // TODO(joyeecheung): maybe this should be kBootstrapFailure instead?
      w->Exit(ExitCode::kGenericUserError,
              ""ERR_WORKER_INIT_FAILED"",
              ""Failed to create new Is...",13,,144,2,,void
254722,BLOCK,-1,,"{
      char err_buf[128];
      uv_err_name_r(ret, err_buf, sizeof(err_buf));
      // TODO(joyeecheung): maybe this should be kBootstrapFailure instead?
      w->Exit(ExitCode::kGenericUserError, ""ERR_WORKER_INIT_FAILED"", err_buf);
      return;
    }",19,,146,2,,void
254789,BLOCK,-1,,"{
      // TODO(joyeecheung): maybe this should be kBootstrapFailure instead?
      w->Exit(ExitCode::kGenericUserError,
              ""ERR_WORKER_INIT_FAILED"",
              ""Failed to create new Isolate"");
      return;
    }",29,,164,2,,void
254810,BLOCK,17,,"{
      Locker locker(isolate);
      Isolate::Scope isolate_scope(isolate);
      // V8 computes its stack limit the first time a `Locker` is used based on
      // --stack-size. Reset it to the correct value.
      isolate->SetStackLimit(w->stack_base_);

      HandleScope handle_scope(isolate);
      isolate_data_.reset(
          CreateIsolateData(isolate,
                            &loop_,
                            w_->platform_,
                            allocator.get(),
                            w->snapshot_data()->AsEmbedderWrapper().get()));
      CHECK(isolate_data_);
      CHECK(!isolate_data_->is_building_snapshot());
      if (w_->per_isolate_opts_)
        isolate_data_->set_options(std::move(w_->per_isolate_opts_));
      isolate_data_->set_worker_context(w_);
      isolate_data_->max_young_gen_size =
          params.constraints.max_young_generation_size_in_bytes();
    }",5,,179,17,,void
254864,BLOCK,-1,,<empty>,9,,196,2,,void
254904,BLOCK,-1,,"{
    Debug(w_, ""Worker %llu dispose isolate"", w_->thread_id_.id);
    Isolate* isolate;
    {
      Mutex::ScopedLock lock(w_->mutex_);
      isolate = w_->isolate_;
      w_->isolate_ = nullptr;
    }

    if (isolate != nullptr) {
      CHECK(!loop_init_failed_);
      bool platform_finished = false;

      isolate_data_.reset();

      w_->platform_->AddIsolateFinishedCallback(isolate, [](void* data) {
        *static_cast<bool*>(data) = true;
      }, &platform_finished);

      // The order of these calls is important; if the Isolate is first disposed
      // and then unregistered, there is a race condition window in which no
      // new Isolate at the same address can successfully be registered with
      // the platform.
      // (Refs: https://github.com/nodejs/node/issues/30846)
      w_->platform_->UnregisterIsolate(isolate);
      isolate->Dispose();

      // Wait until the platform has cleaned up all relevant resources.
      while (!platform_finished) {
        uv_r...",23,,206,1,,void
254914,BLOCK,3,,"{
      Mutex::ScopedLock lock(w_->mutex_);
      isolate = w_->isolate_;
      w_->isolate_ = nullptr;
    }",5,,209,3,,void
254934,BLOCK,-1,,"{
      CHECK(!loop_init_failed_);
      bool platform_finished = false;

      isolate_data_.reset();

      w_->platform_->AddIsolateFinishedCallback(isolate, [](void* data) {
        *static_cast<bool*>(data) = true;
      }, &platform_finished);

      // The order of these calls is important; if the Isolate is first disposed
      // and then unregistered, there is a race condition window in which no
      // new Isolate at the same address can successfully be registered with
      // the platform.
      // (Refs: https://github.com/nodejs/node/issues/30846)
      w_->platform_->UnregisterIsolate(isolate);
      isolate->Dispose();

      // Wait until the platform has cleaned up all relevant resources.
      while (!platform_finished) {
        uv_run(&loop_, UV_RUN_ONCE);
      }
    }",29,,215,2,,void
254970,BLOCK,-1,,"{
        uv_run(&loop_, UV_RUN_ONCE);
      }",34,,234,2,,void
254978,BLOCK,-1,,"{
      CheckedUvLoopClose(&loop_);
    }",29,,238,2,,void
254985,BLOCK,-1,,{ return !loop_init_failed_; },31,,243,1,,void
254998,BLOCK,-1,,<empty>,,,,1,,<empty>
255011,BLOCK,-1,,"{
  Worker* worker = static_cast<Worker*>(data);
  // Give the current GC some extra leeway to let it finish rather than
  // crash hard. We are not going to perform further allocations anyway.
  constexpr size_t kExtraHeapAllowance = 16 * 1024 * 1024;
  size_t new_limit = current_heap_limit + kExtraHeapAllowance;
  Environment* env = worker->env();
  if (env != nullptr) {
    DCHECK(!env->is_in_heapsnapshot_heap_limit_callback());
    Debug(env,
          DebugCategory::DIAGNOSTICS,
          ""Throwing ERR_WORKER_OUT_OF_MEMORY, ""
          ""new_limit=%"" PRIu64 ""\n"",
          static_cast<uint64_t>(new_limit));
  }
  // TODO(joyeecheung): maybe this should be kV8FatalError instead?
  worker->Exit(ExitCode::kGenericUserError,
               ""ERR_WORKER_OUT_OF_MEMORY"",
               ""JS heap out of memory"");
  return new_limit;
}",57,,255,4,,void
255043,BLOCK,-1,,"{
    DCHECK(!env->is_in_heapsnapshot_heap_limit_callback());
    Debug(env,
          DebugCategory::DIAGNOSTICS,
          ""Throwing ERR_WORKER_OUT_OF_MEMORY, ""
          ""new_limit=%"" PRIu64 ""\n"",
          static_cast<uint64_t>(new_limit));
  }",23,,262,2,,void
255065,BLOCK,-1,,"{
  std::string trace_name = ""[worker "" + std::to_string(thread_id_.id) + ""]"" +
                           (name_ == """" ? """" : "" "" + name_);
  TRACE_EVENT_METADATA1(
      ""__metadata"", ""thread_name"", ""name"", TRACE_STR_COPY(trace_name.c_str()));
  CHECK_NOT_NULL(platform_);

  Debug(this, ""Creating isolate for worker with id %llu"", thread_id_.id);

  WorkerThreadData data(this);
  if (isolate_ == nullptr) return;
  CHECK(data.loop_is_usable());

  Debug(this, ""Starting worker with id %llu"", thread_id_.id);
  {
    Locker locker(isolate_);
    Isolate::Scope isolate_scope(isolate_);
    SealHandleScope outer_seal(isolate_);

    DeleteFnPtr<Environment, FreeEnvironment> env_;
    auto cleanup_env = OnScopeLeave([&]() {
      // TODO(addaleax): This call is harmless but should not be necessary.
      // Figure out why V8 is raising a DCHECK() here without it
      // (in test/parallel/test-async-hooks-worker-asyncfn-terminate-4.js).
      isolate_->CancelTerminateExecution();

      i...",20,,277,1,,void
255112,BLOCK,-1,,<empty>,28,,287,2,,void
255125,BLOCK,11,,"{
    Locker locker(isolate_);
    Isolate::Scope isolate_scope(isolate_);
    SealHandleScope outer_seal(isolate_);

    DeleteFnPtr<Environment, FreeEnvironment> env_;
    auto cleanup_env = OnScopeLeave([&]() {
      // TODO(addaleax): This call is harmless but should not be necessary.
      // Figure out why V8 is raising a DCHECK() here without it
      // (in test/parallel/test-async-hooks-worker-asyncfn-terminate-4.js).
      isolate_->CancelTerminateExecution();

      if (!env_) return;
      env_->set_can_call_into_js(false);

      {
        Mutex::ScopedLock lock(mutex_);
        stopped_ = true;
        this->env_ = nullptr;
      }

      env_.reset();
    });

    if (is_stopped()) return;
    {
      HandleScope handle_scope(isolate_);
      Local<Context> context;
      {
        // We create the Context object before we have an Environment* in place
        // that we could use for error handling. If creation fails due to
        // resource constraints, we need so...",3,,291,11,,void
255149,BLOCK,-1,,<empty>,23,,315,2,,void
255151,BLOCK,11,,"{
      HandleScope handle_scope(isolate_);
      Local<Context> context;
      {
        // We create the Context object before we have an Environment* in place
        // that we could use for error handling. If creation fails due to
        // resource constraints, we need something in place to handle it,
        // though.
        TryCatch try_catch(isolate_);
        if (snapshot_data_ != nullptr) {
          Debug(this,
                ""Worker %llu uses context from snapshot %d\n"",
                thread_id_.id,
                static_cast<int>(SnapshotData::kNodeBaseContextIndex));
          context = Context::FromSnapshot(isolate_,
                                          SnapshotData::kNodeBaseContextIndex)
                        .ToLocalChecked();
          if (!context.IsEmpty() &&
              !InitializeContextRuntime(context).IsJust()) {
            context = Local<Context>();
          }
        } else {
          Debug(
              this, ""Worker %llu builds cont...",5,,316,11,,void
255160,BLOCK,4,,"{
        // We create the Context object before we have an Environment* in place
        // that we could use for error handling. If creation fails due to
        // resource constraints, we need something in place to handle it,
        // though.
        TryCatch try_catch(isolate_);
        if (snapshot_data_ != nullptr) {
          Debug(this,
                ""Worker %llu uses context from snapshot %d\n"",
                thread_id_.id,
                static_cast<int>(SnapshotData::kNodeBaseContextIndex));
          context = Context::FromSnapshot(isolate_,
                                          SnapshotData::kNodeBaseContextIndex)
                        .ToLocalChecked();
          if (!context.IsEmpty() &&
              !InitializeContextRuntime(context).IsJust()) {
            context = Local<Context>();
          }
        } else {
          Debug(
              this, ""Worker %llu builds context from scratch\n"", thread_id_.id);
          context = NewContext(isolate_);
 ...",7,,319,4,,void
255168,BLOCK,-1,,"{
          Debug(this,
                ""Worker %llu uses context from snapshot %d\n"",
                thread_id_.id,
                static_cast<int>(SnapshotData::kNodeBaseContextIndex));
          context = Context::FromSnapshot(isolate_,
                                          SnapshotData::kNodeBaseContextIndex)
                        .ToLocalChecked();
          if (!context.IsEmpty() &&
              !InitializeContextRuntime(context).IsJust()) {
            context = Local<Context>();
          }
        }",40,,325,2,,void
255206,BLOCK,-1,,"{
            context = Local<Context>();
          }",60,,334,2,,void
255211,BLOCK,-1,,"{
          Debug(
              this, ""Worker %llu builds context from scratch\n"", thread_id_.id);
          context = NewContext(isolate_);
        }",16,,337,1,,void
255227,BLOCK,-1,,"{
          // TODO(joyeecheung): maybe this should be kBootstrapFailure instead?
          Exit(ExitCode::kGenericUserError,
               ""ERR_WORKER_INIT_FAILED"",
               ""Failed to create new Context"");
          return;
        }",32,,342,2,,void
255237,BLOCK,-1,,<empty>,25,,351,2,,void
255248,BLOCK,9,,"{
        env_.reset(CreateEnvironment(
            data.isolate_data_.get(),
            context,
            std::move(argv_),
            std::move(exec_argv_),
            static_cast<EnvironmentFlags::Flags>(environment_flags_),
            thread_id_,
            std::move(inspector_parent_handle_)));
        if (is_stopped()) return;
        CHECK_NOT_NULL(env_);
        env_->set_env_vars(std::move(env_vars_));
        SetProcessExitHandler(env_.get(), [this](Environment*, int exit_code) {
          Exit(static_cast<ExitCode>(exit_code));
        });
      }",7,,354,9,,void
255282,BLOCK,-1,,<empty>,27,,363,2,,void
255300,BLOCK,10,,"{
        Mutex::ScopedLock lock(mutex_);
        if (stopped_) return;
        this->env_ = env_.get();
      }",7,,370,10,,void
255306,BLOCK,-1,,<empty>,23,,372,2,,void
255324,BLOCK,-1,,<empty>,25,,376,2,,void
255326,BLOCK,13,,"{
        if (!CreateEnvMessagePort(env_.get())) {
          return;
        }

        Debug(this, ""Created message port for worker %llu"", thread_id_.id);
        if (LoadEnvironment(env_.get(), StartExecutionCallback{}).IsEmpty())
          return;

        Debug(this, ""Loaded environment for worker %llu"", thread_id_.id);
      }",7,,377,13,,void
255334,BLOCK,-1,,"{
          return;
        }",48,,378,2,,void
255353,BLOCK,-1,,<empty>,11,,384,2,,void
255361,BLOCK,12,,"{
      Maybe<ExitCode> exit_code = SpinEventLoopInternal(env_.get());
      Mutex::ScopedLock lock(mutex_);
      if (exit_code_ == ExitCode::kNoFailure && exit_code.IsJust()) {
        exit_code_ = exit_code.FromJust();
      }

      Debug(this,
            ""Exiting thread for worker %llu with exit code %d"",
            thread_id_.id,
            static_cast<int>(exit_code_));
    }",5,,390,12,,void
255387,BLOCK,-1,,"{
        exit_code_ = exit_code.FromJust();
      }",69,,393,2,,void
255413,BLOCK,-1,,"{
  HandleScope handle_scope(isolate_);
  std::unique_ptr<MessagePortData> data;
  {
    Mutex::ScopedLock lock(mutex_);
    data = std::move(child_port_data_);
  }

  // Set up the message channel for receiving messages in the child.
  MessagePort* child_port = MessagePort::New(env,
                                             env->context(),
                                             std::move(data));
  // MessagePort::New() may return nullptr if execution is terminated
  // within it.
  if (child_port != nullptr)
    env->set_message_port(child_port->object(isolate_));

  return child_port;
}",53,,407,2,,void
255424,BLOCK,4,,"{
    Mutex::ScopedLock lock(mutex_);
    data = std::move(child_port_data_);
  }",3,,410,4,,void
255456,BLOCK,-1,,<empty>,5,,422,2,,void
255471,BLOCK,-1,,"{
  if (!tid_.has_value())
    return;
  CHECK_EQ(uv_thread_join(&tid_.value()), 0);
  tid_.reset();

  env()->remove_sub_worker_context(this);

  {
    HandleScope handle_scope(env()->isolate());
    Context::Scope context_scope(env()->context());

    // Reset the parent port as we're closing it now anyway.
    object()->Set(env()->context(),
                  env()->message_port_string(),
                  Undefined(env()->isolate())).Check();

    Local<Value> args[] = {
        Integer::New(env()->isolate(), static_cast<int>(exit_code_)),
        custom_error_ != nullptr
            ? OneByteString(env()->isolate(), custom_error_).As<Value>()
            : Null(env()->isolate()).As<Value>(),
        !custom_error_str_.empty()
            ? OneByteString(env()->isolate(), custom_error_str_.c_str())
                  .As<Value>()
            : Null(env()->isolate()).As<Value>(),
    };

    MakeCallback(env()->onexit_string(), arraysize(args), args);
  }

  // If we get here, the...",27,,427,1,,void
255478,BLOCK,-1,,<empty>,5,,429,2,,void
255497,BLOCK,5,,"{
    HandleScope handle_scope(env()->isolate());
    Context::Scope context_scope(env()->context());

    // Reset the parent port as we're closing it now anyway.
    object()->Set(env()->context(),
                  env()->message_port_string(),
                  Undefined(env()->isolate())).Check();

    Local<Value> args[] = {
        Integer::New(env()->isolate(), static_cast<int>(exit_code_)),
        custom_error_ != nullptr
            ? OneByteString(env()->isolate(), custom_error_).As<Value>()
            : Null(env()->isolate()).As<Value>(),
        !custom_error_str_.empty()
            ? OneByteString(env()->isolate(), custom_error_str_.c_str())
                  .As<Value>()
            : Null(env()->isolate()).As<Value>(),
    };

    MakeCallback(env()->onexit_string(), arraysize(args), args);
  }",3,,435,5,,void
255603,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);

  CHECK(stopped_);
  CHECK_NULL(env_);
  CHECK(!tid_.has_value());

  Debug(this, ""Worker %llu destroyed"", thread_id_.id);
}",19,,464,1,,void
255625,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  auto is_internal = args[5];
  CHECK(is_internal->IsBoolean());
  if (is_internal->IsFalse()) {
    THROW_IF_INSUFFICIENT_PERMISSIONS(
        env, permission::PermissionScope::kWorkerThreads, """");
  }
  Isolate* isolate = args.GetIsolate();

  CHECK(args.IsConstructCall());

  if (env->isolate_data()->platform() == nullptr) {
    THROW_ERR_MISSING_PLATFORM_FOR_WORKER(env);
    return;
  }
  CHECK(!env->isolate_data()->is_building_snapshot());

  std::string url;
  std::string name;
  std::shared_ptr<PerIsolateOptions> per_isolate_opts = nullptr;
  std::shared_ptr<KVStore> env_vars = nullptr;

  std::vector<std::string> exec_argv_out;

  // Argument might be a string or URL
  if (!args[0]->IsNullOrUndefined()) {
    Utf8Value value(
        isolate, args[0]->ToString(env->context()).FromMaybe(Local<String>()));
    url.append(value.out(), value.length());
  }

  if (!args[6]->IsNullOrUndefined()) {
    Utf8Value value(
        i...",59,,474,2,,void
255650,BLOCK,-1,,"{
    THROW_IF_INSUFFICIENT_PERMISSIONS(
        env, permission::PermissionScope::kWorkerThreads, """");
  }",31,,478,2,,void
255681,BLOCK,-1,,"{
    THROW_ERR_MISSING_PLATFORM_FOR_WORKER(env);
    return;
  }",51,,486,2,,void
255730,BLOCK,-1,,"{
    Utf8Value value(
        isolate, args[0]->ToString(env->context()).FromMaybe(Local<String>()));
    url.append(value.out(), value.length());
  }",38,,500,2,,void
255768,BLOCK,-1,,"{
    Utf8Value value(
        isolate, args[6]->ToString(env->context()).FromMaybe(Local<String>()));
    name.append(value.out(), value.length());
  }",38,,506,2,,void
255805,BLOCK,-1,,"{
    // Means worker.env = { ...process.env }.
    env_vars = env->env_vars()->Clone(isolate);
  }",26,,512,2,,void
255817,BLOCK,-1,,<empty>,10,,515,1,,void
255825,BLOCK,-1,,"{
    // User provided env.
    env_vars = KVStore::CreateMapKVStore();
    env_vars->AssignFromObject(isolate->GetCurrentContext(),
                               args[1].As<Object>());
  }",35,,515,2,,void
255847,BLOCK,-1,,"{
    // Env is shared.
    env_vars = env->env_vars();
  }",10,,520,1,,void
255868,BLOCK,-1,,"{
    per_isolate_opts.reset(new PerIsolateOptions());

    HandleEnvOptions(per_isolate_opts->per_env, [&env_vars](const char* name) {
      return env_vars->Get(name).FromMaybe("""");
    });

#ifndef NODE_WITHOUT_NODE_OPTIONS
    MaybeLocal<String> maybe_node_opts =
        env_vars->Get(isolate, OneByteString(isolate, ""NODE_OPTIONS""));
    Local<String> node_opts;
    if (maybe_node_opts.ToLocal(&node_opts)) {
      std::string node_options(*String::Utf8Value(isolate, node_opts));
      std::vector<std::string> errors{};
      std::vector<std::string> env_argv =
          ParseNodeOptionsEnvVar(node_options, &errors);
      // [0] is expected to be the program name, add dummy string.
      env_argv.insert(env_argv.begin(), """");
      std::vector<std::string> invalid_args{};
      options_parser::Parse(&env_argv,
                            nullptr,
                            &invalid_args,
                            per_isolate_opts.get(),
                            kAllowedInE...",50,,525,2,,void
255906,BLOCK,-1,,"{
      std::string node_options(*String::Utf8Value(isolate, node_opts));
      std::vector<std::string> errors{};
      std::vector<std::string> env_argv =
          ParseNodeOptionsEnvVar(node_options, &errors);
      // [0] is expected to be the program name, add dummy string.
      env_argv.insert(env_argv.begin(), """");
      std::vector<std::string> invalid_args{};
      options_parser::Parse(&env_argv,
                            nullptr,
                            &invalid_args,
                            per_isolate_opts.get(),
                            kAllowedInEnvvar,
                            &errors);
      if (!errors.empty() && args[1]->IsObject()) {
        // Only fail for explicitly provided env, this protects from failures
        // when NODE_OPTIONS from parent's env is used (which is the default).
        Local<Value> error;
        if (!ToV8Value(env->context(), errors).ToLocal(&error)) return;
        Local<String> key =
            FIXED_ONE_BYTE_STRIN...",46,,536,2,,void
255988,BLOCK,-1,,"{
        // Only fail for explicitly provided env, this protects from failures
        // when NODE_OPTIONS from parent's env is used (which is the default).
        Local<Value> error;
        if (!ToV8Value(env->context(), errors).ToLocal(&error)) return;
        Local<String> key =
            FIXED_ONE_BYTE_STRING(env->isolate(), ""invalidNodeOptions"");
        // Ignore the return value of Set() because exceptions bubble up to JS
        // when we return anyway.
        USE(args.This()->Set(env->context(), key, error));
        return;
      }",51,,550,2,,void
256007,BLOCK,-1,,<empty>,65,,554,2,,void
256043,BLOCK,-1,,"{
    Local<Array> array = args[2].As<Array>();
    // The first argument is reserved for program name, but we don't need it
    // in workers.
    std::vector<std::string> exec_argv = {""""};
    uint32_t length = array->Length();
    for (uint32_t i = 0; i < length; i++) {
      Local<Value> arg;
      if (!array->Get(env->context(), i).ToLocal(&arg)) {
        return;
      }
      Local<String> arg_v8;
      if (!arg->ToString(env->context()).ToLocal(&arg_v8)) {
        return;
      }
      Utf8Value arg_utf8_value(args.GetIsolate(), arg_v8);
      std::string arg_string(arg_utf8_value.out(), arg_utf8_value.length());
      exec_argv.push_back(arg_string);
    }

    std::vector<std::string> invalid_args{};
    std::vector<std::string> errors{};
    // Using invalid_args as the v8_args argument as it stores unknown
    // options for the per isolate parser.
    options_parser::Parse(&exec_argv,
                          &exec_argv_out,
                          &invalid_args,
   ...",27,,566,2,,void
256074,BLOCK,-1,,<empty>,5,,572,1,,void
256084,BLOCK,4,,"{
      Local<Value> arg;
      if (!array->Get(env->context(), i).ToLocal(&arg)) {
        return;
      }
      Local<String> arg_v8;
      if (!arg->ToString(env->context()).ToLocal(&arg_v8)) {
        return;
      }
      Utf8Value arg_utf8_value(args.GetIsolate(), arg_v8);
      std::string arg_string(arg_utf8_value.out(), arg_utf8_value.length());
      exec_argv.push_back(arg_string);
    }",43,,572,4,,void
256106,BLOCK,-1,,"{
        return;
      }",57,,574,2,,void
256128,BLOCK,-1,,"{
        return;
      }",60,,578,2,,void
256211,BLOCK,-1,,"{
      Local<Value> error;
      if (!ToV8Value(env->context(),
                     errors.size() > 0 ? errors : invalid_args)
                         .ToLocal(&error)) {
        return;
      }
      Local<String> key =
          FIXED_ONE_BYTE_STRING(env->isolate(), ""invalidExecArgv"");
      // Ignore the return value of Set() because exceptions bubble up to JS
      // when we return anyway.
      USE(args.This()->Set(env->context(), key, error));
      return;
    }",55,,599,2,,void
256238,BLOCK,-1,,"{
        return;
      }",44,,603,2,,void
256268,BLOCK,-1,,"{
    exec_argv_out = env->exec_argv();
  }",10,,613,1,,void
256360,BLOCK,-1,,<empty>,5,,636,2,,void
256373,BLOCK,-1,,<empty>,5,,638,2,,void
256386,BLOCK,-1,,<empty>,5,,640,2,,void
256399,BLOCK,-1,,<empty>,5,,642,2,,void
256412,BLOCK,-1,,<empty>,5,,644,2,,void
256424,BLOCK,-1,,"{
  Worker* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
  Mutex::ScopedLock lock(w->mutex_);

  w->stopped_ = false;

  if (w->resource_limits_[kStackSizeMb] > 0) {
    if (w->resource_limits_[kStackSizeMb] * kMB < kStackBufferSize) {
      w->resource_limits_[kStackSizeMb] = kStackBufferSize / kMB;
      w->stack_size_ = kStackBufferSize;
    } else {
      w->stack_size_ =
          static_cast<size_t>(w->resource_limits_[kStackSizeMb] * kMB);
    }
  } else {
    w->resource_limits_[kStackSizeMb] = w->stack_size_ / kMB;
  }

  uv_thread_options_t thread_options;
  thread_options.flags = UV_THREAD_HAS_STACK_SIZE;
  thread_options.stack_size = w->stack_size_;

  uv_thread_t* tid = &w->tid_.emplace();  // Create uv_thread_t instance
  int ret = uv_thread_create_ex(tid, &thread_options, [](void* arg) {
    // XXX: This could become a std::unique_ptr, but that makes at least
    // gcc 6.3 detect undefined behaviour when there shouldn't be any.
    // gcc 7+ handles this well.
    ...",67,,647,2,,void
256451,BLOCK,-1,,"{
    if (w->resource_limits_[kStackSizeMb] * kMB < kStackBufferSize) {
      w->resource_limits_[kStackSizeMb] = kStackBufferSize / kMB;
      w->stack_size_ = kStackBufferSize;
    } else {
      w->stack_size_ =
          static_cast<size_t>(w->resource_limits_[kStackSizeMb] * kMB);
    }
  }",46,,654,2,,void
256462,BLOCK,-1,,"{
      w->resource_limits_[kStackSizeMb] = kStackBufferSize / kMB;
      w->stack_size_ = kStackBufferSize;
    }",69,,655,2,,void
256478,BLOCK,-1,,"{
      w->stack_size_ =
          static_cast<size_t>(w->resource_limits_[kStackSizeMb] * kMB);
    }",12,,658,1,,void
256493,BLOCK,-1,,"{
    w->resource_limits_[kStackSizeMb] = w->stack_size_ / kMB;
  }",10,,662,1,,void
256543,BLOCK,-1,,"{
    // The object now owns the created thread and should not be garbage
    // collected until that finishes.
    w->ClearWeak();

    if (w->has_ref_)
      w->env()->add_refs(1);

    w->env()->add_sub_worker_context(w);
  }",17,,694,2,,void
256552,BLOCK,-1,,<empty>,7,,700,2,,void
256570,BLOCK,-1,,"{
    w->stopped_ = true;
    w->tid_.reset();

    char err_buf[128];
    uv_err_name_r(ret, err_buf, sizeof(err_buf));
    {
      Isolate* isolate = w->env()->isolate();
      HandleScope handle_scope(isolate);
      THROW_ERR_WORKER_INIT_FAILED(isolate, err_buf);
    }
  }",10,,703,1,,void
256588,BLOCK,5,,"{
      Isolate* isolate = w->env()->isolate();
      HandleScope handle_scope(isolate);
      THROW_ERR_WORKER_INIT_FAILED(isolate, err_buf);
    }",5,,709,5,,void
256609,BLOCK,-1,,"{
  Worker* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());

  Debug(w, ""Worker %llu is getting stopped by parent"", w->thread_id_.id);
  w->Exit(ExitCode::kGenericUserError);
}",66,,717,2,,void
256637,BLOCK,-1,,"{
  Worker* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
  if (!w->has_ref_ && w->tid_.has_value()) {
    w->has_ref_ = true;
    w->env()->add_refs(1);
  }
}",59,,725,2,,void
256658,BLOCK,-1,,"{
    w->has_ref_ = true;
    w->env()->add_refs(1);
  }",44,,728,2,,void
256676,BLOCK,-1,,"{
  Worker* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
  args.GetReturnValue().Set(w->has_ref_);
}",62,,734,2,,void
256699,BLOCK,-1,,"{
  Worker* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
  if (w->has_ref_ && w->tid_.has_value()) {
    w->has_ref_ = false;
    w->env()->add_refs(-1);
  }
}",61,,740,2,,void
256719,BLOCK,-1,,"{
    w->has_ref_ = false;
    w->env()->add_refs(-1);
  }",43,,743,2,,void
256738,BLOCK,-1,,"{
  Worker* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
  args.GetReturnValue().Set(w->GetResourceLimits(args.GetIsolate()));
}",73,,749,2,,void
256766,BLOCK,-1,,"{
  Local<ArrayBuffer> ab = ArrayBuffer::New(isolate, sizeof(resource_limits_));

  memcpy(ab->Data(), resource_limits_, sizeof(resource_limits_));
  return Float64Array::New(ab, 0, kTotalResourceLimitCount);
}",71,,755,2,,void
256802,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  Debug(this,
        ""Worker %llu called Exit(%d, %s, %s)"",
        thread_id_.id,
        static_cast<int>(code),
        error_code,
        error_message);

  if (error_code != nullptr) {
    custom_error_ = error_code;
    custom_error_str_ = error_message;
  }

  if (env_ != nullptr) {
    exit_code_ = code;
    Stop(env_);
  } else {
    stopped_ = true;
  }
}",46,,764,4,,void
256821,BLOCK,-1,,"{
    custom_error_ = error_code;
    custom_error_str_ = error_message;
  }",30,,773,2,,void
256832,BLOCK,-1,,"{
    exit_code_ = code;
    Stop(env_);
  }",24,,778,2,,void
256838,BLOCK,-1,,"{
    stopped_ = true;
  }",10,,781,1,,void
256845,BLOCK,-1,,"{
  // Worker objects always stay alive as long as the child thread, regardless
  // of whether they are being referenced in the parent thread.
  return true;
}",56,,786,1,,void
256854,BLOCK,-1,,<empty>,67,,795,3,,void
256860,BLOCK,-1,,"{
  Worker* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
  CHECK_EQ(args.Length(), 1);
  auto options = heap::GetHeapSnapshotOptions(args[0]);

  Debug(w, ""Worker %llu taking heap snapshot"", w->thread_id_.id);

  Environment* env = w->env();
  AsyncHooks::DefaultTriggerAsyncIdScope trigger_id_scope(w);
  Local<Object> wrap;
  if (!env->worker_heap_snapshot_taker_template()
      ->NewInstance(env->context()).ToLocal(&wrap)) {
    return;
  }

  // The created WorkerHeapSnapshotTaker is an object owned by main
  // thread's Isolate, it can not be accessed by worker thread
  std::unique_ptr<BaseObjectPtr<WorkerHeapSnapshotTaker>> taker =
      std::make_unique<BaseObjectPtr<WorkerHeapSnapshotTaker>>(
          MakeDetachedBaseObject<WorkerHeapSnapshotTaker>(env, wrap));

  // Interrupt the worker thread and take a snapshot, then schedule a call
  // on the parent thread that turns that snapshot into a readable stream.
  bool scheduled = w->RequestInterrupt([taker = std::move(taker),...",72,,802,2,,void
256924,BLOCK,-1,,"{
    return;
  }",53,,814,2,,void
256962,BLOCK,-1,,"{
    args.GetReturnValue().Set(wrap);
  }",18,,855,2,,void
256972,BLOCK,-1,,"{
    args.GetReturnValue().Set(Local<Object>());
  }",10,,857,1,,void
256985,BLOCK,-1,,"{
  Worker* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());

  Mutex::ScopedLock lock(w->mutex_);
  // Using w->is_stopped() here leads to a deadlock, and checking is_stopped()
  // before locking the mutex is a race condition. So manually do the same
  // check.
  if (w->stopped_ || w->env_ == nullptr)
    return args.GetReturnValue().Set(-1);

  uint64_t idle_time = uv_metrics_idle_time(w->env_->event_loop());
  args.GetReturnValue().Set(1.0 * idle_time / 1e6);
}",68,,862,2,,void
257009,BLOCK,-1,,<empty>,5,,871,2,,void
257046,BLOCK,-1,,"{
  Worker* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());

  Mutex::ScopedLock lock(w->mutex_);
  // Using w->is_stopped() here leads to a deadlock, and checking is_stopped()
  // before locking the mutex is a race condition. So manually do the same
  // check.
  if (w->stopped_ || w->env_ == nullptr)
    return args.GetReturnValue().Set(-1);

  double loop_start_time = w->env_->performance_state()->milestones[
      node::performance::NODE_PERFORMANCE_MILESTONE_LOOP_START];
  CHECK_GE(loop_start_time, 0);
  args.GetReturnValue().Set(loop_start_time / 1e6);
}",69,,877,2,,void
257070,BLOCK,-1,,<empty>,5,,886,2,,void
257116,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Local<Object> port = env->message_port();
  CHECK_IMPLIES(!env->is_main_thread(), !port.IsEmpty());
  if (!port.IsEmpty()) {
    CHECK_EQ(port->GetCreationContext().ToLocalChecked()->GetIsolate(),
             args.GetIsolate());
    args.GetReturnValue().Set(port);
  }
}",65,,898,2,,void
257152,BLOCK,-1,,"{
    CHECK_EQ(port->GetCreationContext().ToLocalChecked()->GetIsolate(),
             args.GetIsolate());
    args.GetReturnValue().Set(port);
  }",24,,902,2,,void
257181,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();

  {
    Local<FunctionTemplate> w = NewFunctionTemplate(isolate, Worker::New);

    w->InstanceTemplate()->SetInternalFieldCount(
        Worker::kInternalFieldCount);
    w->Inherit(AsyncWrap::GetConstructorTemplate(isolate_data));

    SetProtoMethod(isolate, w, ""startThread"", Worker::StartThread);
    SetProtoMethod(isolate, w, ""stopThread"", Worker::StopThread);
    SetProtoMethod(isolate, w, ""hasRef"", Worker::HasRef);
    SetProtoMethod(isolate, w, ""ref"", Worker::Ref);
    SetProtoMethod(isolate, w, ""unref"", Worker::Unref);
    SetProtoMethod(isolate, w, ""getResourceLimits"", Worker::GetResourceLimits);
    SetProtoMethod(isolate, w, ""takeHeapSnapshot"", Worker::TakeHeapSnapshot);
    SetProtoMethod(isolate, w, ""loopIdleTime"", Worker::LoopIdleTime);
    SetProtoMethod(isolate, w, ""loopStartTime"", Worker::LoopStartTime);

    SetConstructorFunction(isolate, target, ""Worker"", w);
  }

  {
    Local<FunctionTemplate> wst = NewFunctionT...",69,,910,3,,void
257189,BLOCK,3,,"{
    Local<FunctionTemplate> w = NewFunctionTemplate(isolate, Worker::New);

    w->InstanceTemplate()->SetInternalFieldCount(
        Worker::kInternalFieldCount);
    w->Inherit(AsyncWrap::GetConstructorTemplate(isolate_data));

    SetProtoMethod(isolate, w, ""startThread"", Worker::StartThread);
    SetProtoMethod(isolate, w, ""stopThread"", Worker::StopThread);
    SetProtoMethod(isolate, w, ""hasRef"", Worker::HasRef);
    SetProtoMethod(isolate, w, ""ref"", Worker::Ref);
    SetProtoMethod(isolate, w, ""unref"", Worker::Unref);
    SetProtoMethod(isolate, w, ""getResourceLimits"", Worker::GetResourceLimits);
    SetProtoMethod(isolate, w, ""takeHeapSnapshot"", Worker::TakeHeapSnapshot);
    SetProtoMethod(isolate, w, ""loopIdleTime"", Worker::LoopIdleTime);
    SetProtoMethod(isolate, w, ""loopStartTime"", Worker::LoopStartTime);

    SetConstructorFunction(isolate, target, ""Worker"", w);
  }",3,,913,3,,void
257288,BLOCK,4,,"{
    Local<FunctionTemplate> wst = NewFunctionTemplate(isolate, nullptr);

    wst->InstanceTemplate()->SetInternalFieldCount(
        WorkerHeapSnapshotTaker::kInternalFieldCount);
    wst->Inherit(AsyncWrap::GetConstructorTemplate(isolate_data));

    Local<String> wst_string =
        FIXED_ONE_BYTE_STRING(isolate, ""WorkerHeapSnapshotTaker"");
    wst->SetClassName(wst_string);
    isolate_data->set_worker_heap_snapshot_taker_template(
        wst->InstanceTemplate());
  }",3,,933,4,,void
257351,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  target
      ->Set(env->context(),
            env->thread_id_string(),
            Number::New(isolate, static_cast<double>(env->thread_id())))
      .Check();

  target
      ->Set(env->context(),
            FIXED_ONE_BYTE_STRING(isolate, ""isMainThread""),
            Boolean::New(isolate, env->is_main_thread()))
      .Check();

  target
      ->Set(env->context(),
            FIXED_ONE_BYTE_STRING(isolate, ""ownsProcessState""),
            Boolean::New(isolate, env->owns_process_state()))
      .Check();

  if (!env->is_main_thread()) {
    target
        ->Set(env->context(),
              FIXED_ONE_BYTE_STRING(isolate, ""resourceLimits""),
              env->worker_context()->GetResourceLimits(isolate))
        .Check();
  }

  NODE_DEFINE_CONSTANT(target, kMaxYoungGenerationSizeMb);
  NODE_DEFINE_CONSTANT(target, kMaxOldGenerationSizeMb);
  NODE_DEFINE_CONSTANT(target, kCodeRangeSize...",51,,953,5,,void
257445,BLOCK,-1,,"{
    target
        ->Set(env->context(),
              FIXED_ONE_BYTE_STRING(isolate, ""resourceLimits""),
              env->worker_context()->GetResourceLimits(isolate))
        .Check();
  }",31,,975,2,,void
257473,BLOCK,1,,<empty>,,,,7,,void
257475,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kMaxYoungGenerationSizeMb)",3,,983,1,,void
257572,BLOCK,1,,<empty>,,,,7,,void
257574,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kMaxOldGenerationSizeMb)",3,,984,1,,void
257671,BLOCK,1,,<empty>,,,,7,,void
257673,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kCodeRangeSizeMb)",3,,985,1,,void
257770,BLOCK,1,,<empty>,,,,7,,void
257772,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kStackSizeMb)",3,,986,1,,void
257869,BLOCK,1,,<empty>,,,,7,,void
257871,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kTotalResourceLimitCount)",3,,987,1,,void
257967,BLOCK,-1,,"{
  registry->Register(GetEnvMessagePort);
  registry->Register(Worker::New);
  registry->Register(Worker::StartThread);
  registry->Register(Worker::StopThread);
  registry->Register(Worker::HasRef);
  registry->Register(Worker::Ref);
  registry->Register(Worker::Unref);
  registry->Register(Worker::GetResourceLimits);
  registry->Register(Worker::TakeHeapSnapshot);
  registry->Register(Worker::LoopIdleTime);
  registry->Register(Worker::LoopStartTime);
}",70,,990,2,,void
258060,BLOCK,-1,,<empty>,1,,1,1,,ANY
258063,BLOCK,-1,,{ Unref(); },46,,405,1,,void
258106,BLOCK,-1,,<empty>,1,,1,1,,ANY
258111,BLOCK,-1,,"{
#define V(code) if (err == code) return #code;
  ZLIB_ERROR_CODES(V)
#undef V
  return ""Z_UNKNOWN_ERROR"";
}",42,,90,2,,void
258113,BLOCK,1,,<empty>,,,,1,,void
258118,BLOCK,-1,,<empty>,3,,92,2,,void
258125,BLOCK,-1,,<empty>,3,,92,2,,void
258132,BLOCK,-1,,<empty>,3,,92,2,,void
258139,BLOCK,-1,,<empty>,3,,92,2,,void
258146,BLOCK,-1,,<empty>,3,,92,2,,void
258153,BLOCK,-1,,<empty>,3,,92,2,,void
258160,BLOCK,-1,,<empty>,3,,92,2,,void
258167,BLOCK,-1,,<empty>,3,,92,2,,void
258174,BLOCK,-1,,<empty>,3,,92,2,,void
258205,BLOCK,-1,,"{
    CHECK_NOT_NULL(message);
  }",18,,117,4,,void
258211,BLOCK,-1,,<empty>,,,,1,,<empty>
258218,BLOCK,-1,,{ return code != nullptr; },31,,127,1,,void
258226,BLOCK,-1,,<empty>,,,,1,,<empty>
258240,BLOCK,-1,,<empty>,,,,1,,<empty>
258244,BLOCK,-1,,<empty>,,,,1,,<empty>
258248,BLOCK,-1,,<empty>,,,,1,,<empty>
258256,BLOCK,-1,,<empty>,,,,5,,<empty>
258261,BLOCK,-1,,<empty>,,,,2,,<empty>
258267,BLOCK,-1,,<empty>,,,,3,,<empty>
258271,BLOCK,-1,,<empty>,,,,1,,<empty>
258276,BLOCK,-1,,{ mode_ = mode; },44,,141,2,,void
258283,BLOCK,-1,,<empty>,,,,1,,<empty>
258292,BLOCK,-1,,<empty>,,,,6,,<empty>
258299,BLOCK,-1,,<empty>,,,,4,,<empty>
258305,BLOCK,-1,,<empty>,,,,3,,<empty>
258314,BLOCK,-1,,"{
    tracker->TrackField(""dictionary"", dictionary_);
  }",58,,153,2,,void
258325,BLOCK,-1,,<empty>,,,,2,,<empty>
258330,BLOCK,-1,,<empty>,,,,2,,<empty>
258335,BLOCK,-1,,<empty>,,,,2,,<empty>
258339,BLOCK,-1,,<empty>,,,,1,,<empty>
258343,BLOCK,-1,,<empty>,,,,1,,<empty>
258359,BLOCK,-1,,<empty>,,,,1,,<empty>
258391,BLOCK,-1,,<empty>,,,,1,,<empty>
258399,BLOCK,-1,,<empty>,,,,5,,<empty>
258404,BLOCK,-1,,<empty>,,,,2,,<empty>
258410,BLOCK,-1,,<empty>,,,,3,,<empty>
258415,BLOCK,-1,,{ mode_ = mode; },44,,189,2,,void
258423,BLOCK,-1,,<empty>,,,,2,,<empty>
258428,BLOCK,-1,,<empty>,,,,2,,<empty>
258441,BLOCK,-1,,<empty>,,,,1,,<empty>
258473,BLOCK,-1,,<empty>,,,,1,,<empty>
258477,BLOCK,-1,,<empty>,,,,1,,<empty>
258484,BLOCK,-1,,<empty>,,,,4,,<empty>
258488,BLOCK,-1,,<empty>,,,,1,,<empty>
258494,BLOCK,-1,,<empty>,,,,3,,<empty>
258498,BLOCK,-1,,<empty>,,,,1,,<empty>
258509,BLOCK,-1,,<empty>,,,,1,,<empty>
258513,BLOCK,-1,,<empty>,,,,1,,<empty>
258520,BLOCK,-1,,<empty>,,,,4,,<empty>
258524,BLOCK,-1,,<empty>,,,,1,,<empty>
258530,BLOCK,-1,,<empty>,,,,3,,<empty>
258534,BLOCK,-1,,<empty>,,,,1,,<empty>
258546,BLOCK,-1,,<empty>,,,,1,,<empty>
258557,BLOCK,-1,,<empty>,,,,1,,<empty>
258568,BLOCK,-1,,"{
    MakeWeak();
  }",32,,263,3,,void
258573,BLOCK,-1,,"{
    CHECK(!write_in_progress_);
    Close();
    CHECK_EQ(zlib_memory_, 0);
    CHECK_EQ(unreported_allocations_, 0);
  }",33,,267,1,,void
258587,BLOCK,-1,,"{
    if (write_in_progress_) {
      pending_close_ = true;
      return;
    }

    pending_close_ = false;
    closed_ = true;
    CHECK(init_done_ && ""close before init"");

    AllocScope alloc_scope(this);
    ctx_.Close();
  }",16,,274,1,,void
258590,BLOCK,-1,,"{
      pending_close_ = true;
      return;
    }",29,,275,2,,void
258616,BLOCK,-1,,"{
    CompressionStream* ctx;
    ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());
    ctx->Close();
  }",62,,289,2,,void
258633,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(args);
    Local<Context> context = env->context();
    CHECK_EQ(args.Length(), 7);

    uint32_t in_off, in_len, out_off, out_len, flush;
    const char* in;
    char* out;

    CHECK_EQ(false, args[0]->IsUndefined() && ""must provide flush value"");
    if (!args[0]->Uint32Value(context).To(&flush)) return;

    if (flush != Z_NO_FLUSH &&
        flush != Z_PARTIAL_FLUSH &&
        flush != Z_SYNC_FLUSH &&
        flush != Z_FULL_FLUSH &&
        flush != Z_FINISH &&
        flush != Z_BLOCK) {
      UNREACHABLE(""Invalid flush value"");
    }

    if (args[1]->IsNull()) {
      // just a flush
      in = nullptr;
      in_len = 0;
      in_off = 0;
    } else {
      CHECK(Buffer::HasInstance(args[1]));
      Local<Object> in_buf = args[1].As<Object>();
      if (!args[2]->Uint32Value(context).To(&in_off)) return;
      if (!args[3]->Uint32Value(context).To(&in_len)) return;

      CHECK(Buffer::IsWithinBounds(in_off, in_len, Buffer::L...",62,,298,2,,void
258689,BLOCK,-1,,<empty>,52,,308,2,,void
258715,BLOCK,-1,,"{
      UNREACHABLE(""Invalid flush value"");
    }",27,,315,2,,void
258725,BLOCK,-1,,"{
      // just a flush
      in = nullptr;
      in_len = 0;
      in_off = 0;
    }",28,,319,2,,void
258736,BLOCK,-1,,"{
      CHECK(Buffer::HasInstance(args[1]));
      Local<Object> in_buf = args[1].As<Object>();
      if (!args[2]->Uint32Value(context).To(&in_off)) return;
      if (!args[3]->Uint32Value(context).To(&in_len)) return;

      CHECK(Buffer::IsWithinBounds(in_off, in_len, Buffer::Length(in_buf)));
      in = Buffer::Data(in_buf) + in_off;
    }",12,,324,1,,void
258771,BLOCK,-1,,<empty>,55,,327,2,,void
258787,BLOCK,-1,,<empty>,55,,328,2,,void
258844,BLOCK,-1,,<empty>,54,,336,2,,void
258860,BLOCK,-1,,<empty>,54,,337,2,,void
258908,BLOCK,-1,,"{
    AllocScope alloc_scope(this);

    CHECK(init_done_ && ""write before init"");
    CHECK(!closed_ && ""already finalized"");

    CHECK_EQ(false, write_in_progress_);
    CHECK_EQ(false, pending_close_);
    write_in_progress_ = true;
    Ref();

    ctx_.SetBuffers(in, in_len, out, out_len);
    ctx_.SetFlush(flush);

    if constexpr (!async) {
      // sync version
      AsyncWrap::env()->PrintSyncTrace();
      DoThreadPoolWork();
      if (CheckError()) {
        UpdateWriteResult();
        write_in_progress_ = false;
      }
      Unref();
      return;
    }

    // async version
    ScheduleWork();
  }",43,,350,6,,void
258947,BLOCK,-1,,"{
      // sync version
      AsyncWrap::env()->PrintSyncTrace();
      DoThreadPoolWork();
      if (CheckError()) {
        UpdateWriteResult();
        write_in_progress_ = false;
      }
      Unref();
      return;
    }",27,,364,2,,void
258958,BLOCK,-1,,"{
        UpdateWriteResult();
        write_in_progress_ = false;
      }",25,,368,2,,void
258969,BLOCK,-1,,"{
    ctx_.GetAfterWriteOffsets(&write_result_[1], &write_result_[0]);
  }",28,,380,1,,void
258985,BLOCK,-1,,"{
    ctx_.DoThreadPoolWork();
  }",36,,388,1,,void
258993,BLOCK,-1,,"{
    const CompressionError err = ctx_.GetErrorInfo();
    if (!err.IsError()) return true;
    EmitError(err);
    return false;
  }",21,,393,1,,void
259007,BLOCK,-1,,<empty>,25,,395,2,,void
259018,BLOCK,-1,,"{
    DCHECK(init_done_);
    AllocScope alloc_scope(this);
    auto on_scope_leave = OnScopeLeave([&]() { Unref(); });

    write_in_progress_ = false;

    if (status == UV_ECANCELED) {
      Close();
      return;
    }

    CHECK_EQ(status, 0);

    Environment* env = AsyncWrap::env();
    HandleScope handle_scope(env->isolate());
    Context::Scope context_scope(env->context());

    if (!CheckError())
      return;

    UpdateWriteResult();

    // call the write() cb
    Local<Value> cb = object()->GetInternalField(kWriteJSCallback);
    MakeCallback(cb.As<Function>(), 0, nullptr);

    if (pending_close_)
      Close();
  }",49,,402,2,,void
259036,BLOCK,-1,,"{
      Close();
      return;
    }",33,,409,2,,void
259064,BLOCK,-1,,<empty>,7,,421,2,,void
259087,BLOCK,-1,,<empty>,7,,430,2,,void
259093,BLOCK,-1,,"{
    Environment* env = AsyncWrap::env();
    // If you hit this assertion, you forgot to enter the v8::Context first.
    CHECK_EQ(env->context(), env->isolate()->GetCurrentContext());

    HandleScope scope(env->isolate());
    Local<Value> args[] = {
      OneByteString(env->isolate(), err.message),
      Integer::New(env->isolate(), err.err),
      OneByteString(env->isolate(), err.code)
    };
    MakeCallback(env->onerror_string(), arraysize(args), args);

    // no hope of rescue.
    write_in_progress_ = false;
    if (pending_close_)
      Close();
  }",47,,434,2,,void
259163,BLOCK,-1,,<empty>,7,,450,2,,void
259169,BLOCK,-1,,"{
    CompressionStream* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

    AllocScope alloc_scope(wrap);
    const CompressionError err = wrap->context()->ResetStream();
    if (err.IsError())
      wrap->EmitError(err);
  }",62,,453,2,,void
259196,BLOCK,-1,,<empty>,7,,460,2,,void
259206,BLOCK,-1,,"{
    tracker->TrackField(""compression context"", ctx_);
    tracker->TrackFieldWithSize(""zlib_memory"",
                                zlib_memory_ + unreported_allocations_);
  }",58,,463,2,,void
259224,BLOCK,-1,,{ return &ctx_; },33,,470,1,,void
259233,BLOCK,-1,,"{
    write_result_ = write_result;
    object()->SetInternalField(kWriteJSCallback, write_js_callback);
    init_done_ = true;
  }",78,,472,3,,void
259252,BLOCK,-1,,"{
    size_t real_size =
        MultiplyWithOverflowCheck(static_cast<size_t>(items),
                                  static_cast<size_t>(size));
    return AllocForBrotli(data, real_size);
  }",64,,484,4,,void
259272,BLOCK,-1,,"{
    size += sizeof(size_t);
    CompressionStream* ctx = static_cast<CompressionStream*>(data);
    char* memory = UncheckedMalloc(size);
    if (UNLIKELY(memory == nullptr)) return nullptr;
    *reinterpret_cast<size_t*>(memory) = size;
    ctx->unreported_allocations_.fetch_add(size,
                                           std::memory_order_relaxed);
    return memory + sizeof(size_t);
  }",56,,491,3,,void
259293,BLOCK,-1,,<empty>,38,,495,2,,void
259322,BLOCK,-1,,"{
    if (UNLIKELY(pointer == nullptr)) return;
    CompressionStream* ctx = static_cast<CompressionStream*>(data);
    char* real_pointer = static_cast<char*>(pointer) - sizeof(size_t);
    size_t real_size = *reinterpret_cast<size_t*>(real_pointer);
    ctx->unreported_allocations_.fetch_sub(real_size,
                                           std::memory_order_relaxed);
    free(real_pointer);
  }",54,,502,3,,void
259328,BLOCK,-1,,<empty>,39,,503,2,,void
259367,BLOCK,-1,,"{
    ssize_t report =
        unreported_allocations_.exchange(0, std::memory_order_relaxed);
    if (report == 0) return;
    CHECK_IMPLIES(report < 0, zlib_memory_ >= static_cast<size_t>(-report));
    zlib_memory_ += report;
    AsyncWrap::env()->isolate()->AdjustAmountOfExternalAllocatedMemory(report);
  }",48,,514,1,,void
259383,BLOCK,-1,,<empty>,22,,517,2,,void
259414,BLOCK,-1,,<empty>,69,,524,2,,void
259418,BLOCK,-1,,{ stream->AdjustAmountOfExternalAllocatedMemory(); },19,,525,1,,void
259427,BLOCK,-1,,"{
    if (++refs_ == 1) {
      ClearWeak();
    }
  }",14,,530,1,,void
259433,BLOCK,-1,,"{
      ClearWeak();
    }",23,,531,2,,void
259438,BLOCK,-1,,"{
    CHECK_GT(refs_, 0);
    if (--refs_ == 0) {
      MakeWeak();
    }
  }",16,,536,1,,void
259447,BLOCK,-1,,"{
      MakeWeak();
    }",23,,538,2,,void
259461,BLOCK,-1,,<empty>,,,,1,,<empty>
259494,BLOCK,-1,,"{
    context()->SetMode(mode);
  }",36,,558,4,,void
259504,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(args);
    CHECK(args[0]->IsInt32());
    node_zlib_mode mode =
        static_cast<node_zlib_mode>(args[0].As<Int32>()->Value());
    new ZlibStream(env, args.This(), mode);
  }",60,,562,2,,void
259546,BLOCK,-1,,"{
    // Refs: https://github.com/nodejs/node/issues/16649
    // Refs: https://github.com/nodejs/node/issues/14161
    if (args.Length() == 5) {
      fprintf(stderr,
          ""WARNING: You are likely using a version of node-tar or npm that ""
          ""is incompatible with this version of Node.js.\nPlease use ""
          ""either the version of npm that is bundled with Node.js, or ""
          ""a version of npm (> 5.5.1 or < 5.4.0) or node-tar (> 4.0.1) ""
          ""that is compatible with Node.js 9 and above.\n"");
    }
    CHECK(args.Length() == 7 &&
      ""init(windowBits, level, memLevel, strategy, writeResult, writeCallback,""
      "" dictionary)"");

    ZlibStream* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

    Local<Context> context = args.GetIsolate()->GetCurrentContext();

    // windowBits is special. On the compression side, 0 is an invalid value.
    // But on the decompression side, a value of 0 for windowBits tells zlib
    // to use the window size in t...",61,,571,2,,void
259554,BLOCK,-1,,"{
      fprintf(stderr,
          ""WARNING: You are likely using a version of node-tar or npm that ""
          ""is incompatible with this version of Node.js.\nPlease use ""
          ""either the version of npm that is bundled with Node.js, or ""
          ""a version of npm (> 5.5.1 or < 5.4.0) or node-tar (> 4.0.1) ""
          ""that is compatible with Node.js 9 and above.\n"");
    }",29,,574,2,,void
259603,BLOCK,-1,,<empty>,58,,595,2,,void
259620,BLOCK,-1,,<empty>,51,,598,2,,void
259637,BLOCK,-1,,<empty>,56,,601,2,,void
259654,BLOCK,-1,,<empty>,55,,604,2,,void
259722,BLOCK,-1,,"{
      unsigned char* data =
          reinterpret_cast<unsigned char*>(Buffer::Data(args[6]));
      dictionary = std::vector<unsigned char>(
          data,
          data + Buffer::Length(args[6]));
    }",39,,615,2,,void
259792,BLOCK,-1,,"{
    CHECK(args.Length() == 2 && ""params(level, strategy)"");
    ZlibStream* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
    Local<Context> context = args.GetIsolate()->GetCurrentContext();
    int level;
    if (!args[0]->Int32Value(context).To(&level)) return;
    int strategy;
    if (!args[1]->Int32Value(context).To(&strategy)) return;

    AllocScope alloc_scope(wrap);
    const CompressionError err = wrap->context()->SetParams(level, strategy);
    if (err.IsError())
      wrap->EmitError(err);
  }",63,,632,2,,void
259838,BLOCK,-1,,<empty>,51,,638,2,,void
259855,BLOCK,-1,,<empty>,54,,640,2,,void
259877,BLOCK,-1,,<empty>,7,,645,2,,void
259894,BLOCK,-1,,"{
    context()->SetMode(mode);
  }",56,,659,4,,void
259903,BLOCK,-1,,"{
    return this->CompressionStream<CompressionContext>::context();
  }",40,,663,1,,void
259914,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(args);
    CHECK(args[0]->IsInt32());
    node_zlib_mode mode =
        static_cast<node_zlib_mode>(args[0].As<Int32>()->Value());
    new BrotliCompressionStream(env, args.This(), mode);
  }",60,,668,2,,void
259956,BLOCK,-1,,"{
    BrotliCompressionStream* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
    CHECK(args.Length() == 3 && ""init(params, writeResult, writeCallback)"");

    CHECK(args[1]->IsUint32Array());
    uint32_t* write_result = reinterpret_cast<uint32_t*>(Buffer::Data(args[1]));

    CHECK(args[2]->IsFunction());
    Local<Function> write_js_callback = args[2].As<Function>();
    wrap->InitStream(write_result, write_js_callback);

    AllocScope alloc_scope(wrap);
    CompressionError err =
        wrap->context()->Init(
          CompressionStream<CompressionContext>::AllocForBrotli,
          CompressionStream<CompressionContext>::FreeForZlib,
          static_cast<CompressionStream<CompressionContext>*>(wrap));
    if (err.IsError()) {
      wrap->EmitError(err);
      args.GetReturnValue().Set(false);
      return;
    }

    CHECK(args[0]->IsUint32Array());
    const uint32_t* data = reinterpret_cast<uint32_t*>(Buffer::Data(args[0]));
    size_t len = args[0].As<Uint32Array...",61,,676,2,,void
260047,BLOCK,-1,,"{
      wrap->EmitError(err);
      args.GetReturnValue().Set(false);
      return;
    }",24,,694,2,,void
260094,BLOCK,-1,,<empty>,5,,704,1,,void
260106,BLOCK,4,,"{
      if (data[i] == static_cast<uint32_t>(-1))
        continue;
      err = wrap->context()->SetParams(i, data[i]);
      if (err.IsError()) {
        wrap->EmitError(err);
        args.GetReturnValue().Set(false);
        return;
      }
    }",56,,704,4,,void
260116,BLOCK,-1,,<empty>,9,,706,2,,void
260136,BLOCK,-1,,"{
        wrap->EmitError(err);
        args.GetReturnValue().Set(false);
        return;
      }",26,,708,2,,void
260163,BLOCK,-1,,"{
    // Currently a no-op, and not accessed from JS land.
    // At some point Brotli may support changing parameters on the fly,
    // in which case we can implement this and a JS equivalent similar to
    // the zlib Params() function.
  }",63,,718,2,,void
260173,BLOCK,-1,,"{
  {
    Mutex::ScopedLock lock(mutex_);
    if (!zlib_init_done_) {
      dictionary_.clear();
      mode_ = NONE;
      return;
    }
  }

  CHECK_LE(mode_, UNZIP);

  int status = Z_OK;
  if (mode_ == DEFLATE || mode_ == GZIP || mode_ == DEFLATERAW) {
    status = deflateEnd(&strm_);
  } else if (mode_ == INFLATE || mode_ == GUNZIP || mode_ == INFLATERAW ||
             mode_ == UNZIP) {
    status = inflateEnd(&strm_);
  }

  CHECK(status == Z_OK || status == Z_DATA_ERROR);
  mode_ = NONE;

  dictionary_.clear();
}",27,,732,1,,void
260174,BLOCK,1,,"{
    Mutex::ScopedLock lock(mutex_);
    if (!zlib_init_done_) {
      dictionary_.clear();
      mode_ = NONE;
      return;
    }
  }",3,,733,1,,void
260181,BLOCK,-1,,"{
      dictionary_.clear();
      mode_ = NONE;
      return;
    }",27,,735,2,,void
260209,BLOCK,-1,,"{
    status = deflateEnd(&strm_);
  }",65,,745,2,,void
260216,BLOCK,-1,,<empty>,10,,747,1,,void
260233,BLOCK,-1,,"{
    status = inflateEnd(&strm_);
  }",30,,748,2,,void
260257,BLOCK,-1,,"{
  bool first_init_call = InitZlib();
  if (first_init_call && err_ != Z_OK) {
    return;
  }

  const Bytef* next_expected_header_byte = nullptr;

  // If the avail_out is left at 0, then it means that it ran out
  // of room.  If there was avail_out left over, then it means
  // that all of the input was consumed.
  switch (mode_) {
    case DEFLATE:
    case GZIP:
    case DEFLATERAW:
      err_ = deflate(&strm_, flush_);
      break;
    case UNZIP:
      if (strm_.avail_in > 0) {
        next_expected_header_byte = strm_.next_in;
      }

      switch (gzip_id_bytes_read_) {
        case 0:
          if (next_expected_header_byte == nullptr) {
            break;
          }

          if (*next_expected_header_byte == GZIP_HEADER_ID1) {
            gzip_id_bytes_read_ = 1;
            next_expected_header_byte++;

            if (strm_.avail_in == 1) {
              // The only available byte was already read.
              break;
            }
          } else {
            ...",38,,759,1,,void
260268,BLOCK,-1,,"{
    return;
  }",40,,761,2,,void
260276,BLOCK,-1,,"{
    case DEFLATE:
    case GZIP:
    case DEFLATERAW:
      err_ = deflate(&strm_, flush_);
      break;
    case UNZIP:
      if (strm_.avail_in > 0) {
        next_expected_header_byte = strm_.next_in;
      }

      switch (gzip_id_bytes_read_) {
        case 0:
          if (next_expected_header_byte == nullptr) {
            break;
          }

          if (*next_expected_header_byte == GZIP_HEADER_ID1) {
            gzip_id_bytes_read_ = 1;
            next_expected_header_byte++;

            if (strm_.avail_in == 1) {
              // The only available byte was already read.
              break;
            }
          } else {
            mode_ = INFLATE;
            break;
          }

          [[fallthrough]];
        case 1:
          if (next_expected_header_byte == nullptr) {
            break;
          }

          if (*next_expected_header_byte == GZIP_HEADER_ID2) {
            gzip_id_bytes_read_ = 2;
            mode_ = GUNZIP;
          } else {
            ...",18,,770,2,,void
260298,BLOCK,-1,,"{
        next_expected_header_byte = strm_.next_in;
      }",31,,777,2,,void
260306,BLOCK,-1,,"{
        case 0:
          if (next_expected_header_byte == nullptr) {
            break;
          }

          if (*next_expected_header_byte == GZIP_HEADER_ID1) {
            gzip_id_bytes_read_ = 1;
            next_expected_header_byte++;

            if (strm_.avail_in == 1) {
              // The only available byte was already read.
              break;
            }
          } else {
            mode_ = INFLATE;
            break;
          }

          [[fallthrough]];
        case 1:
          if (next_expected_header_byte == nullptr) {
            break;
          }

          if (*next_expected_header_byte == GZIP_HEADER_ID2) {
            gzip_id_bytes_read_ = 2;
            mode_ = GUNZIP;
          } else {
            // There is no actual difference between INFLATE and INFLATERAW
            // (after initialization).
            mode_ = INFLATE;
          }

          break;
        default:
          UNREACHABLE(""invalid number of gzip magic number bytes read"")...",36,,781,2,,void
260313,BLOCK,-1,,"{
            break;
          }",53,,783,2,,void
260320,BLOCK,-1,,"{
            gzip_id_bytes_read_ = 1;
            next_expected_header_byte++;

            if (strm_.avail_in == 1) {
              // The only available byte was already read.
              break;
            }
          }",62,,787,2,,void
260332,BLOCK,-1,,"{
              // The only available byte was already read.
              break;
            }",38,,791,2,,void
260335,BLOCK,-1,,"{
            mode_ = INFLATE;
            break;
          }",18,,795,1,,void
260346,BLOCK,-1,,"{
            break;
          }",53,,802,2,,void
260353,BLOCK,-1,,"{
            gzip_id_bytes_read_ = 2;
            mode_ = GUNZIP;
          }",62,,806,2,,void
260361,BLOCK,-1,,"{
            // There is no actual difference between INFLATE and INFLATERAW
            // (after initialization).
            mode_ = INFLATE;
          }",18,,809,1,,void
260395,BLOCK,-1,,"{
        // Load it
        err_ = inflateSetDictionary(&strm_,
                                    dictionary_.data(),
                                    dictionary_.size());
        if (err_ == Z_OK) {
          // And try to decode again
          err_ = inflate(&strm_, flush_);
        } else if (err_ == Z_DATA_ERROR) {
          // Both inflateSetDictionary() and inflate() return Z_DATA_ERROR.
          // Make it possible for After() to tell a bad dictionary from bad
          // input.
          err_ = Z_NEED_DICT;
        }
      }",33,,830,2,,void
260413,BLOCK,-1,,"{
          // And try to decode again
          err_ = inflate(&strm_, flush_);
        }",27,,835,2,,void
260421,BLOCK,-1,,<empty>,16,,838,1,,void
260426,BLOCK,-1,,"{
          // Both inflateSetDictionary() and inflate() return Z_DATA_ERROR.
          // Make it possible for After() to tell a bad dictionary from bad
          // input.
          err_ = Z_NEED_DICT;
        }",42,,838,2,,void
260452,BLOCK,-1,,"{
        // Bytes remain in input buffer. Perhaps this is another compressed
        // member in the same archive, or just trailing garbage.
        // Trailing zero bytes are okay, though, since they are frequently
        // used for padding.

        ResetStream();
        err_ = inflate(&strm_, flush_);
      }",40,,849,2,,void
260470,BLOCK,-1,,"{
  strm_.avail_in = in_len;
  strm_.next_in = const_cast<Bytef*>(reinterpret_cast<const Bytef*>(in));
  strm_.avail_out = out_len;
  strm_.next_out = reinterpret_cast<Bytef*>(out);
}",59,,866,5,,void
260501,BLOCK,-1,,"{
  flush_ = flush;
}",39,,874,2,,void
260510,BLOCK,-1,,"{
  *avail_in = strm_.avail_in;
  *avail_out = strm_.avail_out;
}",67,,880,3,,void
260527,BLOCK,-1,,"{
  if (strm_.msg != nullptr)
    message = strm_.msg;

  return CompressionError { message, ZlibStrerror(err_), err_ };
}",74,,886,2,,void
260534,BLOCK,-1,,<empty>,5,,888,2,,void
260550,BLOCK,-1,,"{
  // Acceptable error states depend on the type of zlib stream.
  switch (err_) {
  case Z_OK:
  case Z_BUF_ERROR:
    if (strm_.avail_out != 0 && flush_ == Z_FINISH) {
      return ErrorForMessage(""unexpected end of file"");
    }
  case Z_STREAM_END:
    // normal statuses, not fatal
    break;
  case Z_NEED_DICT:
    if (dictionary_.empty())
      return ErrorForMessage(""Missing dictionary"");
    else
      return ErrorForMessage(""Bad dictionary"");
  default:
    // something else.
    return ErrorForMessage(""Zlib error"");
  }

  return CompressionError {};
}",52,,894,1,,void
260553,BLOCK,-1,,"{
  case Z_OK:
  case Z_BUF_ERROR:
    if (strm_.avail_out != 0 && flush_ == Z_FINISH) {
      return ErrorForMessage(""unexpected end of file"");
    }
  case Z_STREAM_END:
    // normal statuses, not fatal
    break;
  case Z_NEED_DICT:
    if (dictionary_.empty())
      return ErrorForMessage(""Missing dictionary"");
    else
      return ErrorForMessage(""Bad dictionary"");
  default:
    // something else.
    return ErrorForMessage(""Zlib error"");
  }",17,,896,2,,void
260568,BLOCK,-1,,"{
      return ErrorForMessage(""unexpected end of file"");
    }",53,,899,2,,void
260582,BLOCK,-1,,<empty>,7,,907,2,,void
260587,BLOCK,-1,,<empty>,7,,909,1,,void
260601,BLOCK,-1,,"{
  bool first_init_call = InitZlib();
  if (first_init_call && err_ != Z_OK) {
    return ErrorForMessage(""Failed to init stream before reset"");
  }

  err_ = Z_OK;

  switch (mode_) {
    case DEFLATE:
    case DEFLATERAW:
    case GZIP:
      err_ = deflateReset(&strm_);
      break;
    case INFLATE:
    case INFLATERAW:
    case GUNZIP:
      err_ = inflateReset(&strm_);
      break;
    default:
      break;
  }

  if (err_ != Z_OK)
    return ErrorForMessage(""Failed to reset stream"");

  return SetDictionary();
}",45,,919,1,,void
260612,BLOCK,-1,,"{
    return ErrorForMessage(""Failed to init stream before reset"");
  }",40,,921,2,,void
260621,BLOCK,-1,,"{
    case DEFLATE:
    case DEFLATERAW:
    case GZIP:
      err_ = deflateReset(&strm_);
      break;
    case INFLATE:
    case INFLATERAW:
    case GUNZIP:
      err_ = inflateReset(&strm_);
      break;
    default:
      break;
  }",18,,927,2,,void
260652,BLOCK,-1,,<empty>,5,,943,2,,void
260664,BLOCK,-1,,"{
  strm_.zalloc = alloc;
  strm_.zfree = free;
  strm_.opaque = opaque;
}",56,,951,4,,void
260688,BLOCK,-1,,"{
  if (!((window_bits == 0) &&
        (mode_ == INFLATE ||
         mode_ == GUNZIP ||
         mode_ == UNZIP))) {
    CHECK(
        (window_bits >= Z_MIN_WINDOWBITS && window_bits <= Z_MAX_WINDOWBITS) &&
        ""invalid windowBits"");
  }

  CHECK((level >= Z_MIN_LEVEL && level <= Z_MAX_LEVEL) &&
    ""invalid compression level"");

  CHECK((mem_level >= Z_MIN_MEMLEVEL && mem_level <= Z_MAX_MEMLEVEL) &&
        ""invalid memlevel"");

  CHECK((strategy == Z_FILTERED || strategy == Z_HUFFMAN_ONLY ||
         strategy == Z_RLE || strategy == Z_FIXED ||
         strategy == Z_DEFAULT_STRATEGY) &&
        ""invalid strategy"");

  level_ = level;
  window_bits_ = window_bits;
  mem_level_ = mem_level;
  strategy_ = strategy;

  flush_ = Z_NO_FLUSH;

  err_ = Z_OK;

  if (mode_ == GZIP || mode_ == GUNZIP) {
    window_bits_ += 16;
  }

  if (mode_ == UNZIP) {
    window_bits_ += 32;
  }

  if (mode_ == DEFLATERAW || mode_ == INFLATERAW) {
    window_bits_ *= -1;
  }

  dictionary_ = std::...",46,,960,6,,void
260706,BLOCK,-1,,"{
    CHECK(
        (window_bits >= Z_MIN_WINDOWBITS && window_bits <= Z_MAX_WINDOWBITS) &&
        ""invalid windowBits"");
  }",28,,964,2,,void
260713,BLOCK,1,,<empty>,,,,1,,void
260718,BLOCK,1,,<empty>,,,,1,,void
260727,BLOCK,1,,<empty>,,,,1,,void
260733,BLOCK,1,,<empty>,,,,1,,void
260742,BLOCK,1,,<empty>,,,,1,,void
260747,BLOCK,1,,<empty>,,,,1,,void
260798,BLOCK,-1,,"{
    window_bits_ += 16;
  }",41,,990,2,,void
260806,BLOCK,-1,,"{
    window_bits_ += 32;
  }",23,,994,2,,void
260818,BLOCK,-1,,"{
    window_bits_ *= -1;
  }",51,,998,2,,void
260833,BLOCK,-1,,"{
  Mutex::ScopedLock lock(mutex_);
  if (zlib_init_done_) {
    return false;
  }

  switch (mode_) {
    case DEFLATE:
    case GZIP:
    case DEFLATERAW:
      err_ = deflateInit2(&strm_,
                          level_,
                          Z_DEFLATED,
                          window_bits_,
                          mem_level_,
                          strategy_);
      break;
    case INFLATE:
    case GUNZIP:
    case INFLATERAW:
    case UNZIP:
      err_ = inflateInit2(&strm_, window_bits_);
      break;
    default:
      UNREACHABLE();
  }

  if (err_ != Z_OK) {
    dictionary_.clear();
    mode_ = NONE;
    return true;
  }

  SetDictionary();
  zlib_init_done_ = true;
  return true;
}",30,,1005,1,,void
260839,BLOCK,-1,,"{
    return false;
  }",24,,1007,2,,void
260844,BLOCK,-1,,"{
    case DEFLATE:
    case GZIP:
    case DEFLATERAW:
      err_ = deflateInit2(&strm_,
                          level_,
                          Z_DEFLATED,
                          window_bits_,
                          mem_level_,
                          strategy_);
      break;
    case INFLATE:
    case GUNZIP:
    case INFLATERAW:
    case UNZIP:
      err_ = inflateInit2(&strm_, window_bits_);
      break;
    default:
      UNREACHABLE();
  }",18,,1011,2,,void
260883,BLOCK,-1,,"{
    dictionary_.clear();
    mode_ = NONE;
    return true;
  }",21,,1032,2,,void
260902,BLOCK,-1,,"{
  if (dictionary_.empty())
    return CompressionError {};

  err_ = Z_OK;

  switch (mode_) {
    case DEFLATE:
    case DEFLATERAW:
      err_ = deflateSetDictionary(&strm_,
                                  dictionary_.data(),
                                  dictionary_.size());
      break;
    case INFLATERAW:
      // The other inflate cases will have the dictionary set when inflate()
      // returns Z_NEED_DICT in Process()
      err_ = inflateSetDictionary(&strm_,
                                  dictionary_.data(),
                                  dictionary_.size());
      break;
    default:
      break;
  }

  if (err_ != Z_OK) {
    return ErrorForMessage(""Failed to set dictionary"");
  }

  return CompressionError {};
}",47,,1044,1,,void
260908,BLOCK,-1,,<empty>,5,,1046,2,,void
260917,BLOCK,-1,,"{
    case DEFLATE:
    case DEFLATERAW:
      err_ = deflateSetDictionary(&strm_,
                                  dictionary_.data(),
                                  dictionary_.size());
      break;
    case INFLATERAW:
      // The other inflate cases will have the dictionary set when inflate()
      // returns Z_NEED_DICT in Process()
      err_ = inflateSetDictionary(&strm_,
                                  dictionary_.data(),
                                  dictionary_.size());
      break;
    default:
      break;
  }",18,,1050,2,,void
260958,BLOCK,-1,,"{
    return ErrorForMessage(""Failed to set dictionary"");
  }",21,,1068,2,,void
260970,BLOCK,-1,,"{
  bool first_init_call = InitZlib();
  if (first_init_call && err_ != Z_OK) {
    return ErrorForMessage(""Failed to init stream before set parameters"");
  }

  err_ = Z_OK;

  switch (mode_) {
    case DEFLATE:
    case DEFLATERAW:
      err_ = deflateParams(&strm_, level, strategy);
      break;
    default:
      break;
  }

  if (err_ != Z_OK && err_ != Z_BUF_ERROR) {
    return ErrorForMessage(""Failed to set parameters"");
  }

  return CompressionError {};
}",66,,1076,3,,void
260981,BLOCK,-1,,"{
    return ErrorForMessage(""Failed to init stream before set parameters"");
  }",40,,1078,2,,void
260990,BLOCK,-1,,"{
    case DEFLATE:
    case DEFLATERAW:
      err_ = deflateParams(&strm_, level, strategy);
      break;
    default:
      break;
  }",18,,1084,2,,void
261013,BLOCK,-1,,"{
    return ErrorForMessage(""Failed to set parameters"");
  }",44,,1093,2,,void
261027,BLOCK,-1,,"{
  next_in_ = reinterpret_cast<const uint8_t*>(in);
  next_out_ = reinterpret_cast<uint8_t*>(out);
  avail_in_ = in_len;
  avail_out_ = out_len;
}",61,,1102,5,,void
261048,BLOCK,-1,,"{
  flush_ = static_cast<BrotliEncoderOperation>(flush);
}",41,,1110,2,,void
261059,BLOCK,-1,,"{
  *avail_in = avail_in_;
  *avail_out = avail_out_;
}",69,,1116,3,,void
261071,BLOCK,-1,,"{
  CHECK_EQ(mode_, BROTLI_ENCODE);
  CHECK(state_);
  const uint8_t* next_in = next_in_;
  last_result_ = BrotliEncoderCompressStream(state_.get(),
                                             flush_,
                                             &avail_in_,
                                             &next_in,
                                             &avail_out_,
                                             &next_out_,
                                             nullptr);
  next_in_ += next_in - next_in_;
}",47,,1122,1,,void
261106,BLOCK,-1,,"{
  state_.reset();
  mode_ = NONE;
}",36,,1137,1,,void
261120,BLOCK,-1,,"{
  alloc_ = alloc;
  free_ = free;
  alloc_opaque_ = opaque;
  state_.reset(BrotliEncoderCreateInstance(alloc, free, opaque));
  if (!state_) {
    return CompressionError(""Could not initialize Brotli instance"",
                            ""ERR_ZLIB_INITIALIZATION_FAILED"",
                            -1);
  } else {
    return CompressionError {};
  }
}",59,,1144,4,,void
261141,BLOCK,-1,,"{
    return CompressionError(""Could not initialize Brotli instance"",
                            ""ERR_ZLIB_INITIALIZATION_FAILED"",
                            -1);
  }",16,,1149,2,,void
261149,BLOCK,-1,,"{
    return CompressionError {};
  }",10,,1153,1,,void
261156,BLOCK,-1,,"{
  return Init(alloc_, free_, alloc_opaque_);
}",54,,1158,1,,void
261167,BLOCK,-1,,"{
  if (!BrotliEncoderSetParameter(state_.get(),
                                 static_cast<BrotliEncoderParameter>(key),
                                 value)) {
    return CompressionError(""Setting parameter failed"",
                            ""ERR_BROTLI_PARAM_SET_FAILED"",
                            -1);
  } else {
    return CompressionError {};
  }
}",75,,1162,3,,void
261179,BLOCK,-1,,"{
    return CompressionError(""Setting parameter failed"",
                            ""ERR_BROTLI_PARAM_SET_FAILED"",
                            -1);
  }",42,,1165,2,,void
261187,BLOCK,-1,,"{
    return CompressionError {};
  }",10,,1169,1,,void
261194,BLOCK,-1,,"{
  if (!last_result_) {
    return CompressionError(""Compression failed"",
                            ""ERR_BROTLI_COMPRESSION_FAILED"",
                            -1);
  } else {
    return CompressionError {};
  }
}",61,,1174,1,,void
261198,BLOCK,-1,,"{
    return CompressionError(""Compression failed"",
                            ""ERR_BROTLI_COMPRESSION_FAILED"",
                            -1);
  }",22,,1175,2,,void
261206,BLOCK,-1,,"{
    return CompressionError {};
  }",10,,1179,1,,void
261213,BLOCK,-1,,"{
  state_.reset();
  mode_ = NONE;
}",36,,1185,1,,void
261224,BLOCK,-1,,"{
  CHECK_EQ(mode_, BROTLI_DECODE);
  CHECK(state_);
  const uint8_t* next_in = next_in_;
  last_result_ = BrotliDecoderDecompressStream(state_.get(),
                                               &avail_in_,
                                               &next_in,
                                               &avail_out_,
                                               &next_out_,
                                               nullptr);
  next_in_ += next_in - next_in_;
  if (last_result_ == BROTLI_DECODER_RESULT_ERROR) {
    error_ = BrotliDecoderGetErrorCode(state_.get());
    error_string_ = std::string(""ERR_"") + BrotliDecoderErrorString(error_);
  }
}",47,,1190,1,,void
261259,BLOCK,-1,,"{
    error_ = BrotliDecoderGetErrorCode(state_.get());
    error_string_ = std::string(""ERR_"") + BrotliDecoderErrorString(error_);
  }",52,,1201,2,,void
261283,BLOCK,-1,,"{
  alloc_ = alloc;
  free_ = free;
  alloc_opaque_ = opaque;
  state_.reset(BrotliDecoderCreateInstance(alloc, free, opaque));
  if (!state_) {
    return CompressionError(""Could not initialize Brotli instance"",
                            ""ERR_ZLIB_INITIALIZATION_FAILED"",
                            -1);
  } else {
    return CompressionError {};
  }
}",59,,1209,4,,void
261304,BLOCK,-1,,"{
    return CompressionError(""Could not initialize Brotli instance"",
                            ""ERR_ZLIB_INITIALIZATION_FAILED"",
                            -1);
  }",16,,1214,2,,void
261312,BLOCK,-1,,"{
    return CompressionError {};
  }",10,,1218,1,,void
261319,BLOCK,-1,,"{
  return Init(alloc_, free_, alloc_opaque_);
}",54,,1223,1,,void
261330,BLOCK,-1,,"{
  if (!BrotliDecoderSetParameter(state_.get(),
                                 static_cast<BrotliDecoderParameter>(key),
                                 value)) {
    return CompressionError(""Setting parameter failed"",
                            ""ERR_BROTLI_PARAM_SET_FAILED"",
                            -1);
  } else {
    return CompressionError {};
  }
}",75,,1227,3,,void
261342,BLOCK,-1,,"{
    return CompressionError(""Setting parameter failed"",
                            ""ERR_BROTLI_PARAM_SET_FAILED"",
                            -1);
  }",42,,1230,2,,void
261350,BLOCK,-1,,"{
    return CompressionError {};
  }",10,,1234,1,,void
261357,BLOCK,-1,,"{
  if (error_ != BROTLI_DECODER_NO_ERROR) {
    return CompressionError(""Decompression failed"",
                            error_string_.c_str(),
                            static_cast<int>(error_));
  } else if (flush_ == BROTLI_OPERATION_FINISH &&
             last_result_ == BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT) {
    // Match zlib's behaviour, as brotli doesn't have its own code for this.
    return CompressionError(""unexpected end of file"",
                            ""Z_BUF_ERROR"",
                            Z_BUF_ERROR);
  } else {
    return CompressionError {};
  }
}",61,,1239,1,,void
261362,BLOCK,-1,,"{
    return CompressionError(""Decompression failed"",
                            error_string_.c_str(),
                            static_cast<int>(error_));
  }",42,,1240,2,,void
261374,BLOCK,-1,,<empty>,10,,1244,1,,void
261383,BLOCK,-1,,"{
    // Match zlib's behaviour, as brotli doesn't have its own code for this.
    return CompressionError(""unexpected end of file"",
                            ""Z_BUF_ERROR"",
                            Z_BUF_ERROR);
  }",70,,1245,2,,void
261390,BLOCK,-1,,"{
    return CompressionError {};
  }",10,,1250,1,,void
261401,BLOCK,-1,,"{
    Isolate* isolate = env->isolate();
    Local<FunctionTemplate> z = NewFunctionTemplate(isolate, Stream::New);

    z->InstanceTemplate()->SetInternalFieldCount(
        Stream::kInternalFieldCount);
    z->Inherit(AsyncWrap::GetConstructorTemplate(env));

    SetProtoMethod(isolate, z, ""write"", Stream::template Write<true>);
    SetProtoMethod(isolate, z, ""writeSync"", Stream::template Write<false>);
    SetProtoMethod(isolate, z, ""close"", Stream::Close);

    SetProtoMethod(isolate, z, ""init"", Stream::Init);
    SetProtoMethod(isolate, z, ""params"", Stream::Params);
    SetProtoMethod(isolate, z, ""reset"", Stream::Reset);

    SetConstructorFunction(env->context(), target, name, z);
  }",78,,1258,4,,void
261493,BLOCK,-1,,"{
    registry->Register(Stream::New);
    registry->Register(Stream::template Write<true>);
    registry->Register(Stream::template Write<false>);
    registry->Register(Stream::Close);
    registry->Register(Stream::Init);
    registry->Register(Stream::Params);
    registry->Register(Stream::Reset);
  }",57,,1277,2,,void
261550,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);

  MakeClass<ZlibStream>::Make(env, target, ""Zlib"");
  MakeClass<BrotliEncoderStream>::Make(env, target, ""BrotliEncoder"");
  MakeClass<BrotliDecoderStream>::Make(env, target, ""BrotliDecoder"");

  target->Set(env->context(),
              FIXED_ONE_BYTE_STRING(env->isolate(), ""ZLIB_VERSION""),
              FIXED_ONE_BYTE_STRING(env->isolate(), ZLIB_VERSION)).Check();
}",29,,1291,5,,void
261607,BLOCK,-1,,"{
  MakeClass<ZlibStream>::Make(registry);
  MakeClass<BrotliEncoderStream>::Make(registry);
  MakeClass<BrotliDecoderStream>::Make(registry);
}",70,,1303,2,,void
261627,BLOCK,-1,,"{
  NODE_DEFINE_CONSTANT(target, Z_NO_FLUSH);
  NODE_DEFINE_CONSTANT(target, Z_PARTIAL_FLUSH);
  NODE_DEFINE_CONSTANT(target, Z_SYNC_FLUSH);
  NODE_DEFINE_CONSTANT(target, Z_FULL_FLUSH);
  NODE_DEFINE_CONSTANT(target, Z_FINISH);
  NODE_DEFINE_CONSTANT(target, Z_BLOCK);

  // return/error codes
  NODE_DEFINE_CONSTANT(target, Z_OK);
  NODE_DEFINE_CONSTANT(target, Z_STREAM_END);
  NODE_DEFINE_CONSTANT(target, Z_NEED_DICT);
  NODE_DEFINE_CONSTANT(target, Z_ERRNO);
  NODE_DEFINE_CONSTANT(target, Z_STREAM_ERROR);
  NODE_DEFINE_CONSTANT(target, Z_DATA_ERROR);
  NODE_DEFINE_CONSTANT(target, Z_MEM_ERROR);
  NODE_DEFINE_CONSTANT(target, Z_BUF_ERROR);
  NODE_DEFINE_CONSTANT(target, Z_VERSION_ERROR);

  NODE_DEFINE_CONSTANT(target, Z_NO_COMPRESSION);
  NODE_DEFINE_CONSTANT(target, Z_BEST_SPEED);
  NODE_DEFINE_CONSTANT(target, Z_BEST_COMPRESSION);
  NODE_DEFINE_CONSTANT(target, Z_DEFAULT_COMPRESSION);
  NODE_DEFINE_CONSTANT(target, Z_FILTERED);
  NODE_DEFINE_CONSTANT(target, Z_HUFFMAN_ONLY);
  N...",48,,1311,2,,void
261633,BLOCK,1,,<empty>,,,,7,,void
261635,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_NO_FLUSH)",3,,1312,1,,void
261732,BLOCK,1,,<empty>,,,,7,,void
261734,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_PARTIAL_FLUSH)",3,,1313,1,,void
261831,BLOCK,1,,<empty>,,,,7,,void
261833,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_SYNC_FLUSH)",3,,1314,1,,void
261930,BLOCK,1,,<empty>,,,,7,,void
261932,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_FULL_FLUSH)",3,,1315,1,,void
262029,BLOCK,1,,<empty>,,,,7,,void
262031,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_FINISH)",3,,1316,1,,void
262128,BLOCK,1,,<empty>,,,,7,,void
262130,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_BLOCK)",3,,1317,1,,void
262227,BLOCK,1,,<empty>,,,,7,,void
262229,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_OK)",3,,1320,1,,void
262326,BLOCK,1,,<empty>,,,,7,,void
262328,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_STREAM_END)",3,,1321,1,,void
262425,BLOCK,1,,<empty>,,,,7,,void
262427,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_NEED_DICT)",3,,1322,1,,void
262524,BLOCK,1,,<empty>,,,,7,,void
262526,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_ERRNO)",3,,1323,1,,void
262623,BLOCK,1,,<empty>,,,,7,,void
262625,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_STREAM_ERROR)",3,,1324,1,,void
262722,BLOCK,1,,<empty>,,,,7,,void
262724,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_DATA_ERROR)",3,,1325,1,,void
262821,BLOCK,1,,<empty>,,,,7,,void
262823,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_MEM_ERROR)",3,,1326,1,,void
262920,BLOCK,1,,<empty>,,,,7,,void
262922,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_BUF_ERROR)",3,,1327,1,,void
263019,BLOCK,1,,<empty>,,,,7,,void
263021,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_VERSION_ERROR)",3,,1328,1,,void
263118,BLOCK,1,,<empty>,,,,7,,void
263120,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_NO_COMPRESSION)",3,,1330,1,,void
263217,BLOCK,1,,<empty>,,,,7,,void
263219,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_BEST_SPEED)",3,,1331,1,,void
263316,BLOCK,1,,<empty>,,,,7,,void
263318,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_BEST_COMPRESSION)",3,,1332,1,,void
263415,BLOCK,1,,<empty>,,,,7,,void
263417,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_DEFAULT_COMPRESSION)",3,,1333,1,,void
263514,BLOCK,1,,<empty>,,,,7,,void
263516,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_FILTERED)",3,,1334,1,,void
263613,BLOCK,1,,<empty>,,,,7,,void
263615,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_HUFFMAN_ONLY)",3,,1335,1,,void
263712,BLOCK,1,,<empty>,,,,7,,void
263714,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_RLE)",3,,1336,1,,void
263811,BLOCK,1,,<empty>,,,,7,,void
263813,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_FIXED)",3,,1337,1,,void
263910,BLOCK,1,,<empty>,,,,7,,void
263912,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_DEFAULT_STRATEGY)",3,,1338,1,,void
264009,BLOCK,1,,<empty>,,,,7,,void
264011,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, ZLIB_VERNUM)",3,,1339,1,,void
264108,BLOCK,1,,<empty>,,,,7,,void
264110,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, DEFLATE)",3,,1341,1,,void
264207,BLOCK,1,,<empty>,,,,7,,void
264209,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, INFLATE)",3,,1342,1,,void
264306,BLOCK,1,,<empty>,,,,7,,void
264308,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, GZIP)",3,,1343,1,,void
264405,BLOCK,1,,<empty>,,,,7,,void
264407,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, GUNZIP)",3,,1344,1,,void
264504,BLOCK,1,,<empty>,,,,7,,void
264506,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, DEFLATERAW)",3,,1345,1,,void
264603,BLOCK,1,,<empty>,,,,7,,void
264605,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, INFLATERAW)",3,,1346,1,,void
264702,BLOCK,1,,<empty>,,,,7,,void
264704,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, UNZIP)",3,,1347,1,,void
264801,BLOCK,1,,<empty>,,,,7,,void
264803,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODE)",3,,1348,1,,void
264900,BLOCK,1,,<empty>,,,,7,,void
264902,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_ENCODE)",3,,1349,1,,void
264998,BLOCK,1,,<empty>,,,,6,,void
265000,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_MIN_WINDOWBITS)",3,,1351,1,,void
265096,BLOCK,1,,<empty>,,,,6,,void
265098,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_MAX_WINDOWBITS)",3,,1352,1,,void
265194,BLOCK,1,,<empty>,,,,6,,void
265196,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_DEFAULT_WINDOWBITS)",3,,1353,1,,void
265292,BLOCK,1,,<empty>,,,,6,,void
265294,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_MIN_CHUNK)",3,,1354,1,,void
265390,BLOCK,1,,<empty>,,,,6,,void
265392,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_MAX_CHUNK)",3,,1355,1,,void
265493,BLOCK,1,,<empty>,,,,6,,void
265495,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_DEFAULT_CHUNK)",3,,1356,1,,void
265593,BLOCK,1,,<empty>,,,,6,,void
265595,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_MIN_MEMLEVEL)",3,,1357,1,,void
265691,BLOCK,1,,<empty>,,,,6,,void
265693,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_MAX_MEMLEVEL)",3,,1358,1,,void
265789,BLOCK,1,,<empty>,,,,6,,void
265791,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_DEFAULT_MEMLEVEL)",3,,1359,1,,void
265887,BLOCK,1,,<empty>,,,,6,,void
265889,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_MIN_LEVEL)",3,,1360,1,,void
265986,BLOCK,1,,<empty>,,,,6,,void
265988,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_MAX_LEVEL)",3,,1361,1,,void
266084,BLOCK,1,,<empty>,,,,6,,void
266086,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, Z_DEFAULT_LEVEL)",3,,1362,1,,void
266183,BLOCK,1,,<empty>,,,,7,,void
266185,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_OPERATION_PROCESS)",3,,1365,1,,void
266282,BLOCK,1,,<empty>,,,,7,,void
266284,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_OPERATION_FLUSH)",3,,1366,1,,void
266381,BLOCK,1,,<empty>,,,,7,,void
266383,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_OPERATION_FINISH)",3,,1367,1,,void
266480,BLOCK,1,,<empty>,,,,7,,void
266482,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_OPERATION_EMIT_METADATA)",3,,1368,1,,void
266579,BLOCK,1,,<empty>,,,,7,,void
266581,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_MODE)",3,,1369,1,,void
266678,BLOCK,1,,<empty>,,,,7,,void
266680,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_MODE_GENERIC)",3,,1370,1,,void
266777,BLOCK,1,,<empty>,,,,7,,void
266779,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_MODE_TEXT)",3,,1371,1,,void
266876,BLOCK,1,,<empty>,,,,7,,void
266878,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_MODE_FONT)",3,,1372,1,,void
266975,BLOCK,1,,<empty>,,,,7,,void
266977,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DEFAULT_MODE)",3,,1373,1,,void
267074,BLOCK,1,,<empty>,,,,7,,void
267076,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_QUALITY)",3,,1374,1,,void
267173,BLOCK,1,,<empty>,,,,7,,void
267175,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_MIN_QUALITY)",3,,1375,1,,void
267272,BLOCK,1,,<empty>,,,,7,,void
267274,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_MAX_QUALITY)",3,,1376,1,,void
267371,BLOCK,1,,<empty>,,,,7,,void
267373,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DEFAULT_QUALITY)",3,,1377,1,,void
267470,BLOCK,1,,<empty>,,,,7,,void
267472,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_LGWIN)",3,,1378,1,,void
267569,BLOCK,1,,<empty>,,,,7,,void
267571,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_MIN_WINDOW_BITS)",3,,1379,1,,void
267668,BLOCK,1,,<empty>,,,,7,,void
267670,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_MAX_WINDOW_BITS)",3,,1380,1,,void
267767,BLOCK,1,,<empty>,,,,7,,void
267769,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_LARGE_MAX_WINDOW_BITS)",3,,1381,1,,void
267866,BLOCK,1,,<empty>,,,,7,,void
267868,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DEFAULT_WINDOW)",3,,1382,1,,void
267965,BLOCK,1,,<empty>,,,,7,,void
267967,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_LGBLOCK)",3,,1383,1,,void
268064,BLOCK,1,,<empty>,,,,7,,void
268066,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_MIN_INPUT_BLOCK_BITS)",3,,1384,1,,void
268163,BLOCK,1,,<empty>,,,,7,,void
268165,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_MAX_INPUT_BLOCK_BITS)",3,,1385,1,,void
268262,BLOCK,1,,<empty>,,,,7,,void
268264,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING)",3,,1386,1,,void
268361,BLOCK,1,,<empty>,,,,7,,void
268363,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_SIZE_HINT)",3,,1387,1,,void
268460,BLOCK,1,,<empty>,,,,7,,void
268462,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_LARGE_WINDOW)",3,,1388,1,,void
268559,BLOCK,1,,<empty>,,,,7,,void
268561,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_NPOSTFIX)",3,,1389,1,,void
268658,BLOCK,1,,<empty>,,,,7,,void
268660,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_NDIRECT)",3,,1390,1,,void
268757,BLOCK,1,,<empty>,,,,7,,void
268759,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_RESULT_ERROR)",3,,1391,1,,void
268856,BLOCK,1,,<empty>,,,,7,,void
268858,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_RESULT_SUCCESS)",3,,1392,1,,void
268955,BLOCK,1,,<empty>,,,,7,,void
268957,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT)",3,,1393,1,,void
269054,BLOCK,1,,<empty>,,,,7,,void
269056,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT)",3,,1394,1,,void
269153,BLOCK,1,,<empty>,,,,7,,void
269155,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target,
      BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION)",3,,1395,1,,void
269252,BLOCK,1,,<empty>,,,,7,,void
269254,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_PARAM_LARGE_WINDOW)",3,,1397,1,,void
269351,BLOCK,1,,<empty>,,,,7,,void
269353,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_NO_ERROR)",3,,1398,1,,void
269450,BLOCK,1,,<empty>,,,,7,,void
269452,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_SUCCESS)",3,,1399,1,,void
269549,BLOCK,1,,<empty>,,,,7,,void
269551,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_NEEDS_MORE_INPUT)",3,,1400,1,,void
269648,BLOCK,1,,<empty>,,,,7,,void
269650,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_NEEDS_MORE_OUTPUT)",3,,1401,1,,void
269747,BLOCK,1,,<empty>,,,,7,,void
269749,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE)",3,,1402,1,,void
269846,BLOCK,1,,<empty>,,,,7,,void
269848,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_RESERVED)",3,,1403,1,,void
269945,BLOCK,1,,<empty>,,,,7,,void
269947,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target,
      BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE)",3,,1404,1,,void
270044,BLOCK,1,,<empty>,,,,7,,void
270046,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target,
      BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET)",3,,1406,1,,void
270143,BLOCK,1,,<empty>,,,,7,,void
270145,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME)",3,,1408,1,,void
270242,BLOCK,1,,<empty>,,,,7,,void
270244,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_CL_SPACE)",3,,1409,1,,void
270341,BLOCK,1,,<empty>,,,,7,,void
270343,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE)",3,,1410,1,,void
270440,BLOCK,1,,<empty>,,,,7,,void
270442,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT)",3,,1411,1,,void
270539,BLOCK,1,,<empty>,,,,7,,void
270541,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1)",3,,1412,1,,void
270638,BLOCK,1,,<empty>,,,,7,,void
270640,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2)",3,,1413,1,,void
270737,BLOCK,1,,<empty>,,,,7,,void
270739,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_TRANSFORM)",3,,1414,1,,void
270836,BLOCK,1,,<empty>,,,,7,,void
270838,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_DICTIONARY)",3,,1415,1,,void
270935,BLOCK,1,,<empty>,,,,7,,void
270937,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS)",3,,1416,1,,void
271034,BLOCK,1,,<empty>,,,,7,,void
271036,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_PADDING_1)",3,,1417,1,,void
271133,BLOCK,1,,<empty>,,,,7,,void
271135,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_PADDING_2)",3,,1418,1,,void
271232,BLOCK,1,,<empty>,,,,7,,void
271234,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_DISTANCE)",3,,1419,1,,void
271331,BLOCK,1,,<empty>,,,,7,,void
271333,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET)",3,,1420,1,,void
271430,BLOCK,1,,<empty>,,,,7,,void
271432,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_INVALID_ARGUMENTS)",3,,1421,1,,void
271529,BLOCK,1,,<empty>,,,,7,,void
271531,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES)",3,,1422,1,,void
271628,BLOCK,1,,<empty>,,,,7,,void
271630,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS)",3,,1423,1,,void
271727,BLOCK,1,,<empty>,,,,7,,void
271729,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP)",3,,1424,1,,void
271826,BLOCK,1,,<empty>,,,,7,,void
271828,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1)",3,,1425,1,,void
271925,BLOCK,1,,<empty>,,,,7,,void
271927,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2)",3,,1426,1,,void
272024,BLOCK,1,,<empty>,,,,7,,void
272026,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES)",3,,1427,1,,void
272123,BLOCK,1,,<empty>,,,,7,,void
272125,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_UNREACHABLE)",3,,1428,1,,void
272230,BLOCK,-1,,<empty>,1,,1,1,,ANY
272236,BLOCK,-1,,"{
  deny_all_ = true;
}",59,,13,3,,void
272245,BLOCK,-1,,"{
  return deny_all_ == false;
}",72,,18,3,,void
272260,BLOCK,-1,,<empty>,1,,1,1,,ANY
272291,BLOCK,-1,,<empty>,1,,1,1,,ANY
272295,BLOCK,-1,,"{
  uv_fs_t req;
  int rc = uv_fs_stat(nullptr, &req, res.c_str(), nullptr);
  if (rc == 0) {
    const uv_stat_t* const s = static_cast<const uv_stat_t*>(req.ptr);
    if (s->st_mode & S_IFDIR) {
      // add wildcard when directory
      if (res.back() == node::kPathSeparator) {
        return res + ""*"";
      }
      return res + node::kPathSeparator + ""*"";
    }
  }
  uv_fs_req_cleanup(&req);
  return res;
}",60,,18,2,,void
272313,BLOCK,-1,,"{
    const uv_stat_t* const s = static_cast<const uv_stat_t*>(req.ptr);
    if (s->st_mode & S_IFDIR) {
      // add wildcard when directory
      if (res.back() == node::kPathSeparator) {
        return res + ""*"";
      }
      return res + node::kPathSeparator + ""*"";
    }
  }",16,,21,2,,void
272328,BLOCK,-1,,"{
      // add wildcard when directory
      if (res.back() == node::kPathSeparator) {
        return res + ""*"";
      }
      return res + node::kPathSeparator + ""*"";
    }",31,,23,2,,void
272338,BLOCK,-1,,"{
        return res + ""*"";
      }",47,,25,2,,void
272360,BLOCK,-1,,"{
  if (node == nullptr) {
    return;
  }

  if (node->children.size()) {
    for (auto& c : node->children) {
      FreeRecursivelyNode(c.second);
    }
  }

  if (node->wildcard_child != nullptr) {
    delete node->wildcard_child;
  }
  delete node;
}",60,,36,2,,void
272365,BLOCK,-1,,"{
    return;
  }",24,,37,2,,void
272374,BLOCK,-1,,"{
    for (auto& c : node->children) {
      FreeRecursivelyNode(c.second);
    }
  }",30,,41,2,,void
272380,BLOCK,-1,,"{
      FreeRecursivelyNode(c.second);
    }",36,,42,3,,void
272391,BLOCK,-1,,"{
    delete node->wildcard_child;
  }",40,,47,2,,void
272403,BLOCK,-1,,"{
#ifdef _WIN32
  // is UNC file path
  if (param.rfind(""\\\\"", 0) == 0) {
    // return lookup with normalized param
    int starting_pos = 4;  // ""\\?\""
    if (param.rfind(""\\\\?\\UNC\\"") == 0) {
      starting_pos += 4;  // ""UNC\""
    }
    auto normalized = param.substr(starting_pos);
    return granted_tree->Lookup(normalized, true);
  }
#endif
  return granted_tree->Lookup(param, true);
}",53,,54,3,,void
272418,BLOCK,-1,,"{
  std::string whitespace(spaces, ' ');

  if (node == nullptr) {
    return;
  }
  if (node->wildcard_child != nullptr) {
    per_process::Debug(DebugCategory::PERMISSION_MODEL,
                       ""%s Wildcard: %s\n"",
                       whitespace,
                       node->prefix);
  } else {
    per_process::Debug(DebugCategory::PERMISSION_MODEL,
                       ""%s Prefix: %s\n"",
                       whitespace,
                       node->prefix);
    if (node->children.size()) {
      int child = 0;
      for (const auto pair : node->children) {
        ++child;
        per_process::Debug(DebugCategory::PERMISSION_MODEL,
                           ""%s Child(%s): %s\n"",
                           whitespace,
                           child,
                           std::string(1, pair.first));
        PrintTree(pair.second, spaces + 2);
      }
      per_process::Debug(DebugCategory::PERMISSION_MODEL,
                         ""%s End of tree - child(%s)...",69,,76,3,,void
272427,BLOCK,-1,,"{
    return;
  }",24,,79,2,,void
272435,BLOCK,-1,,"{
    per_process::Debug(DebugCategory::PERMISSION_MODEL,
                       ""%s Wildcard: %s\n"",
                       whitespace,
                       node->prefix);
  }",40,,82,2,,void
272449,BLOCK,-1,,"{
    per_process::Debug(DebugCategory::PERMISSION_MODEL,
                       ""%s Prefix: %s\n"",
                       whitespace,
                       node->prefix);
    if (node->children.size()) {
      int child = 0;
      for (const auto pair : node->children) {
        ++child;
        per_process::Debug(DebugCategory::PERMISSION_MODEL,
                           ""%s Child(%s): %s\n"",
                           whitespace,
                           child,
                           std::string(1, pair.first));
        PrintTree(pair.second, spaces + 2);
      }
      per_process::Debug(DebugCategory::PERMISSION_MODEL,
                         ""%s End of tree - child(%s)\n"",
                         whitespace,
                         child);
    } else {
      per_process::Debug(DebugCategory::PERMISSION_MODEL,
                         ""%s End of tree: %s\n"",
                         whitespace,
                         node->prefix);
    }
  }",10,,87,1,,void
272469,BLOCK,-1,,"{
      int child = 0;
      for (const auto pair : node->children) {
        ++child;
        per_process::Debug(DebugCategory::PERMISSION_MODEL,
                           ""%s Child(%s): %s\n"",
                           whitespace,
                           child,
                           std::string(1, pair.first));
        PrintTree(pair.second, spaces + 2);
      }
      per_process::Debug(DebugCategory::PERMISSION_MODEL,
                         ""%s End of tree - child(%s)\n"",
                         whitespace,
                         child);
    }",32,,92,2,,void
272479,BLOCK,-1,,"{
        ++child;
        per_process::Debug(DebugCategory::PERMISSION_MODEL,
                           ""%s Child(%s): %s\n"",
                           whitespace,
                           child,
                           std::string(1, pair.first));
        PrintTree(pair.second, spaces + 2);
      }",46,,94,3,,void
272518,BLOCK,-1,,"{
      per_process::Debug(DebugCategory::PERMISSION_MODEL,
                         ""%s End of tree: %s\n"",
                         whitespace,
                         node->prefix);
    }",12,,107,1,,void
272536,BLOCK,-1,,"{
  using std::string_view_literals::operator""""sv;
  for (const std::string_view res : SplitString(allow, "",""sv)) {
    if (res == ""*""sv) {
      if (scope == PermissionScope::kFileSystemRead) {
        deny_all_in_ = false;
        allow_all_in_ = true;
      } else {
        deny_all_out_ = false;
        allow_all_out_ = true;
      }
      return;
    }
    GrantAccess(scope, std::string(res.data(), res.size()));
  }
}",75,,118,3,,void
272542,BLOCK,-1,,"{
    if (res == ""*""sv) {
      if (scope == PermissionScope::kFileSystemRead) {
        deny_all_in_ = false;
        allow_all_in_ = true;
      } else {
        deny_all_out_ = false;
        allow_all_out_ = true;
      }
      return;
    }
    GrantAccess(scope, std::string(res.data(), res.size()));
  }",64,,120,3,,void
272547,BLOCK,-1,,"{
      if (scope == PermissionScope::kFileSystemRead) {
        deny_all_in_ = false;
        allow_all_in_ = true;
      } else {
        deny_all_out_ = false;
        allow_all_out_ = true;
      }
      return;
    }",23,,121,2,,void
272554,BLOCK,-1,,"{
        deny_all_in_ = false;
        allow_all_in_ = true;
      }",54,,122,2,,void
272562,BLOCK,-1,,"{
        deny_all_out_ = false;
        allow_all_out_ = true;
      }",14,,125,1,,void
272589,BLOCK,-1,,"{
  const std::string path = WildcardIfDir(res);
  if (perm == PermissionScope::kFileSystemRead) {
    granted_in_fs_.Insert(path);
    deny_all_in_ = false;
  } else if (perm == PermissionScope::kFileSystemWrite) {
    granted_out_fs_.Insert(path);
    deny_all_out_ = false;
  }
}",78,,135,3,,void
272601,BLOCK,-1,,"{
    granted_in_fs_.Insert(path);
    deny_all_in_ = false;
  }",49,,137,2,,void
272611,BLOCK,-1,,<empty>,10,,140,1,,void
272618,BLOCK,-1,,"{
    granted_out_fs_.Insert(path);
    deny_all_out_ = false;
  }",57,,140,2,,void
272632,BLOCK,-1,,"{
  switch (perm) {
    case PermissionScope::kFileSystem:
      return allow_all_in_ && allow_all_out_;
    case PermissionScope::kFileSystemRead:
      return !deny_all_in_ &&
             ((param.empty() && allow_all_in_) || allow_all_in_ ||
              is_tree_granted(&granted_in_fs_, param));
    case PermissionScope::kFileSystemWrite:
      return !deny_all_out_ &&
             ((param.empty() && allow_all_out_) || allow_all_out_ ||
              is_tree_granted(&granted_out_fs_, param));
    default:
      return false;
  }
}",67,,147,3,,void
272635,BLOCK,-1,,"{
    case PermissionScope::kFileSystem:
      return allow_all_in_ && allow_all_out_;
    case PermissionScope::kFileSystemRead:
      return !deny_all_in_ &&
             ((param.empty() && allow_all_in_) || allow_all_in_ ||
              is_tree_granted(&granted_in_fs_, param));
    case PermissionScope::kFileSystemWrite:
      return !deny_all_out_ &&
             ((param.empty() && allow_all_out_) || allow_all_out_ ||
              is_tree_granted(&granted_out_fs_, param));
    default:
      return false;
  }",17,,148,2,,void
272692,BLOCK,-1,,<empty>,65,,164,1,,void
272696,BLOCK,-1,,"{
  FreeRecursivelyNode(root_node_);
}",39,,166,1,,void
272703,BLOCK,-1,,"{
  FSPermission::RadixTree::Node* current_node = root_node_;
  if (current_node->children.size() == 0) {
    return when_empty_return;
  }
  unsigned int parent_node_prefix_len = current_node->prefix.length();
  const std::string path(s);
  auto path_len = path.length();

  while (true) {
    if (parent_node_prefix_len == path_len && current_node->IsEndNode()) {
      return true;
    }

    auto node = current_node->NextNode(path, parent_node_prefix_len);
    if (node == nullptr) {
      return false;
    }

    current_node = node;
    parent_node_prefix_len += current_node->prefix.length();
    if (current_node->wildcard_child != nullptr &&
        path_len >= (parent_node_prefix_len - 2 /* slash* */)) {
      return true;
    }
  }
}",70,,171,3,,void
272717,BLOCK,-1,,"{
    return when_empty_return;
  }",43,,173,2,,void
272741,BLOCK,-1,,"{
    if (parent_node_prefix_len == path_len && current_node->IsEndNode()) {
      return true;
    }

    auto node = current_node->NextNode(path, parent_node_prefix_len);
    if (node == nullptr) {
      return false;
    }

    current_node = node;
    parent_node_prefix_len += current_node->prefix.length();
    if (current_node->wildcard_child != nullptr &&
        path_len >= (parent_node_prefix_len - 2 /* slash* */)) {
      return true;
    }
  }",16,,180,2,,void
272751,BLOCK,-1,,"{
      return true;
    }",74,,181,2,,void
272767,BLOCK,-1,,"{
      return false;
    }",26,,186,2,,void
272793,BLOCK,-1,,"{
      return true;
    }",64,,193,2,,void
272800,BLOCK,-1,,"{
  FSPermission::RadixTree::Node* current_node = root_node_;

  unsigned int parent_node_prefix_len = current_node->prefix.length();
  int path_len = path.length();

  for (int i = 1; i <= path_len; ++i) {
    bool is_wildcard_node = path[i - 1] == '*';
    bool is_last_char = i == path_len;

    if (is_wildcard_node || is_last_char) {
      std::string node_path = path.substr(parent_node_prefix_len, i);
      current_node = current_node->CreateChild(node_path);
    }

    if (is_wildcard_node) {
      current_node = current_node->CreateWildcardChild();
      parent_node_prefix_len = i;
    }
  }

  if (UNLIKELY(per_process::enabled_debug_list.enabled(
          DebugCategory::PERMISSION_MODEL))) {
    per_process::Debug(DebugCategory::PERMISSION_MODEL, ""Inserting %s\n"", path);
    PrintTree(root_node_);
  }
}",63,,199,2,,void
272822,BLOCK,-1,,<empty>,3,,205,1,,void
272832,BLOCK,4,,"{
    bool is_wildcard_node = path[i - 1] == '*';
    bool is_last_char = i == path_len;

    if (is_wildcard_node || is_last_char) {
      std::string node_path = path.substr(parent_node_prefix_len, i);
      current_node = current_node->CreateChild(node_path);
    }

    if (is_wildcard_node) {
      current_node = current_node->CreateWildcardChild();
      parent_node_prefix_len = i;
    }
  }",39,,205,4,,void
272853,BLOCK,-1,,"{
      std::string node_path = path.substr(parent_node_prefix_len, i);
      current_node = current_node->CreateChild(node_path);
    }",43,,209,2,,void
272872,BLOCK,-1,,"{
      current_node = current_node->CreateWildcardChild();
      parent_node_prefix_len = i;
    }",27,,214,2,,void
272893,BLOCK,-1,,"{
    per_process::Debug(DebugCategory::PERMISSION_MODEL, ""Inserting %s\n"", path);
    PrintTree(root_node_);
  }",46,,221,2,,void
272918,BLOCK,-1,,<empty>,1,,1,1,,ANY
272927,BLOCK,-1,,<empty>,1,,1,1,,ANY
272933,BLOCK,-1,,"{
  deny_all_ = true;
}",56,,12,3,,void
272942,BLOCK,-1,,"{
  return deny_all_ == false;
}",69,,17,3,,void
272957,BLOCK,-1,,<empty>,1,,1,1,,ANY
272984,BLOCK,-1,,<empty>,1,,1,1,,ANY
272990,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  v8::Isolate* isolate = env->isolate();
  CHECK(args[0]->IsString());

  String::Utf8Value utf8_deny_scope(isolate, args[0]);
  if (*utf8_deny_scope == nullptr) {
    return;
  }

  const std::string deny_scope = *utf8_deny_scope;
  PermissionScope scope = Permission::StringToPermission(deny_scope);
  if (scope == PermissionScope::kPermissionsRoot) {
    return args.GetReturnValue().Set(false);
  }

  if (args.Length() > 1 && !args[1]->IsUndefined()) {
    String::Utf8Value utf8_arg(isolate, args[1]);
    if (*utf8_arg == nullptr) {
      return;
    }
    return args.GetReturnValue().Set(
        env->permission()->is_granted(scope, *utf8_arg));
  }

  return args.GetReturnValue().Set(env->permission()->is_granted(scope));
}",58,,30,2,,void
273024,BLOCK,-1,,"{
    return;
  }",36,,36,2,,void
273045,BLOCK,-1,,"{
    return args.GetReturnValue().Set(false);
  }",51,,42,2,,void
273070,BLOCK,-1,,"{
    String::Utf8Value utf8_arg(isolate, args[1]);
    if (*utf8_arg == nullptr) {
      return;
    }
    return args.GetReturnValue().Set(
        env->permission()->is_granted(scope, *utf8_arg));
  }",53,,46,2,,void
273082,BLOCK,-1,,"{
      return;
    }",31,,48,2,,void
273122,BLOCK,-1,,"{
  PERMISSIONS(V)
  return nullptr;
}",72,,62,2,,void
273131,BLOCK,-1,,"{
  PERMISSIONS(V)
  return PermissionScope::kPermissionsRoot;
}",73,,70,2,,void
273141,BLOCK,-1,,"{
  std::shared_ptr<PermissionBase> fs = std::make_shared<FSPermission>();
  std::shared_ptr<PermissionBase> child_p =
      std::make_shared<ChildProcessPermission>();
  std::shared_ptr<PermissionBase> worker_t =
      std::make_shared<WorkerPermission>();
  std::shared_ptr<PermissionBase> inspector =
      std::make_shared<InspectorPermission>();
#define V(Name, _, __)                                                         \
  nodes_.insert(std::make_pair(PermissionScope::k##Name, fs));
  FILESYSTEM_PERMISSIONS(V)
#undef V
#define V(Name, _, __)                                                         \
  nodes_.insert(std::make_pair(PermissionScope::k##Name, child_p));
  CHILD_PROCESS_PERMISSIONS(V)
#undef V
#define V(Name, _, __)                                                         \
  nodes_.insert(std::make_pair(PermissionScope::k##Name, worker_t));
  WORKER_THREADS_PERMISSIONS(V)
#undef V
#define V(Name, _, __)                                                         \
  no...",44,,76,1,,void
273204,BLOCK,-1,,"{
  Local<Value> err = ERR_ACCESS_DENIED(env->isolate());
  CHECK(err->IsObject());
  if (err.As<Object>()
          ->Set(env->context(),
                env->permission_string(),
                v8::String::NewFromUtf8(env->isolate(),
                                        PermissionToString(perm),
                                        v8::NewStringType::kNormal)
                    .ToLocalChecked())
          .IsNothing() ||
      err.As<Object>()
          ->Set(env->context(),
                env->resource_string(),
                v8::String::NewFromUtf8(env->isolate(),
                                        std::string(res).c_str(),
                                        v8::NewStringType::kNormal)
                    .ToLocalChecked())
          .IsNothing())
    return;
  env->isolate()->ThrowException(err);
}",65,,104,4,,void
273305,BLOCK,-1,,<empty>,5,,123,2,,void
273318,BLOCK,-1,,"{
  if (!enabled_) {
    enabled_ = true;
  }
}",38,,127,1,,void
273322,BLOCK,-1,,"{
    enabled_ = true;
  }",18,,128,2,,void
273331,BLOCK,-1,,"{
  auto permission = nodes_.find(scope);
  if (permission != nodes_.end()) {
    permission->second->Apply(allow, scope);
  }
}",73,,133,3,,void
273347,BLOCK,-1,,"{
    permission->second->Apply(allow, scope);
  }",35,,135,2,,void
273363,BLOCK,-1,,"{
  SetMethodNoSideEffect(context, target, ""has"", Has);

  target->SetIntegrityLevel(context, v8::IntegrityLevel::kFrozen).FromJust();
}",29,,143,5,,void
273386,BLOCK,-1,,"{
  registry->Register(Has);
}",70,,149,2,,void
273419,BLOCK,-1,,<empty>,1,,1,1,,ANY
273432,BLOCK,-1,,<empty>,1,,1,1,,ANY
273443,BLOCK,-1,,<empty>,1,,1,1,,ANY
273449,BLOCK,-1,,"{
  deny_all_ = true;
}",79,,12,3,,void
273458,BLOCK,-1,,"{
  return deny_all_ == false;
}",66,,17,3,,void
273473,BLOCK,-1,,<empty>,1,,1,1,,ANY
273502,BLOCK,-1,,<empty>,1,,1,1,,ANY
273508,BLOCK,-1,,"{
  EscapableHandleScope handle_scope(env->isolate());
  AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(parent);
  CHECK_EQ(false, env->pipe_constructor_template().IsEmpty());
  Local<Function> constructor = env->pipe_constructor_template()
                                    ->GetFunction(env->context())
                                    .ToLocalChecked();
  CHECK_EQ(false, constructor.IsEmpty());
  Local<Value> type_value = Int32::New(env->isolate(), type);
  return handle_scope.EscapeMaybe(
      constructor->NewInstance(env->context(), 1, &type_value));
}",69,,52,4,,void
273591,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);
  t->InstanceTemplate()
    ->SetInternalFieldCount(StreamBase::kInternalFieldCount);

  t->Inherit(LibuvStreamWrap::GetConstructorTemplate(env));

  SetProtoMethod(isolate, t, ""bind"", Bind);
  SetProtoMethod(isolate, t, ""listen"", Listen);
  SetProtoMethod(isolate, t, ""connect"", Connect);
  SetProtoMethod(isolate, t, ""open"", Open);

#ifdef _WIN32
  SetProtoMethod(isolate, t, ""setPendingInstances"", SetPendingInstances);
#endif

  SetProtoMethod(isolate, t, ""fchmod"", Fchmod);

  SetConstructorFunction(context, target, ""Pipe"", t);
  env->set_pipe_constructor_template(t);

  // Create FunctionTemplate for PipeConnectWrap.
  auto cwt = BaseObject::MakeLazilyInitializedJSTemplate(env);
  cwt->Inherit(AsyncWrap::GetConstructorTemplate(env));
  SetConstructorFunction(context, target, ""PipeConnectWrap"", cwt);

  // Define constants
  ...",39,,69,5,,void
273711,BLOCK,1,,<empty>,,,,7,,void
273713,BLOCK,-1,,"NODE_DEFINE_CONSTANT(constants, SOCKET)",3,,100,1,,void
273810,BLOCK,1,,<empty>,,,,7,,void
273812,BLOCK,-1,,"NODE_DEFINE_CONSTANT(constants, SERVER)",3,,101,1,,void
273909,BLOCK,1,,<empty>,,,,7,,void
273911,BLOCK,-1,,"NODE_DEFINE_CONSTANT(constants, IPC)",3,,102,1,,void
274008,BLOCK,1,,<empty>,,,,7,,void
274010,BLOCK,-1,,"NODE_DEFINE_CONSTANT(constants, UV_READABLE)",3,,103,1,,void
274107,BLOCK,1,,<empty>,,,,7,,void
274109,BLOCK,-1,,"NODE_DEFINE_CONSTANT(constants, UV_WRITABLE)",3,,104,1,,void
274218,BLOCK,-1,,"{
  registry->Register(New);
  registry->Register(Bind);
  registry->Register(Listen);
  registry->Register(Connect);
  registry->Register(Open);
#ifdef _WIN32
  registry->Register(SetPendingInstances);
#endif
  registry->Register(Fchmod);
}",80,,110,2,,void
274253,BLOCK,-1,,"{
  // This constructor should not be exposed to public javascript.
  // Therefore we assert that we are not trying to call this as a
  // normal function.
  CHECK(args.IsConstructCall());
  CHECK(args[0]->IsInt32());
  Environment* env = Environment::GetCurrent(args);

  int type_value = args[0].As<Int32>()->Value();
  PipeWrap::SocketType type = static_cast<PipeWrap::SocketType>(type_value);

  bool ipc;
  ProviderType provider;
  switch (type) {
    case SOCKET:
      provider = PROVIDER_PIPEWRAP;
      ipc = false;
      break;
    case SERVER:
      provider = PROVIDER_PIPESERVERWRAP;
      ipc = false;
      break;
    case IPC:
      provider = PROVIDER_PIPEWRAP;
      ipc = true;
      break;
    default:
      UNREACHABLE();
  }

  new PipeWrap(env, args.This(), provider, ipc);
}",61,,122,2,,void
274296,BLOCK,-1,,"{
    case SOCKET:
      provider = PROVIDER_PIPEWRAP;
      ipc = false;
      break;
    case SERVER:
      provider = PROVIDER_PIPESERVERWRAP;
      ipc = false;
      break;
    case IPC:
      provider = PROVIDER_PIPEWRAP;
      ipc = true;
      break;
    default:
      UNREACHABLE();
  }",17,,135,2,,void
274342,BLOCK,-1,,"{
  int r = uv_pipe_init(env->event_loop(), &handle_, ipc);
  CHECK_EQ(r, 0);  // How do we proxy this error up to javascript?
                   // Suggestion: uv_pipe_init() returns void.
}",45,,160,5,,void
274361,BLOCK,-1,,"{
  PipeWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  node::Utf8Value name(args.GetIsolate(), args[0]);
  int err = uv_pipe_bind(&wrap->handle_, *name);
  args.GetReturnValue().Set(err);
}",62,,167,2,,void
274401,BLOCK,-1,,"{
  PipeWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  CHECK(args[0]->IsInt32());
  int mode = args[0].As<Int32>()->Value();
  int err = uv_pipe_chmod(&wrap->handle_, mode);
  args.GetReturnValue().Set(err);
}",72,,187,2,,void
274450,BLOCK,-1,,"{
  PipeWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  Environment* env = wrap->env();
  int backlog;
  if (!args[0]->Int32Value(env->context()).To(&backlog)) return;
  int err = uv_listen(reinterpret_cast<uv_stream_t*>(&wrap->handle_),
                      backlog,
                      OnConnection);
  args.GetReturnValue().Set(err);
}",64,,197,2,,void
274484,BLOCK,-1,,<empty>,58,,202,2,,void
274510,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  PipeWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  int fd;
  if (!args[0]->Int32Value(env->context()).To(&fd)) return;

  int err = uv_pipe_open(&wrap->handle_, fd);
  if (err == 0) wrap->set_fd(fd);

  args.GetReturnValue().Set(err);
}",62,,210,2,,void
274545,BLOCK,-1,,<empty>,53,,217,2,,void
274560,BLOCK,-1,,<empty>,17,,220,2,,void
274578,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  PipeWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsString());

  Local<Object> req_wrap_obj = args[0].As<Object>();
  node::Utf8Value name(env->isolate(), args[1]);

  ConnectWrap* req_wrap =
      new ConnectWrap(env, req_wrap_obj, AsyncWrap::PROVIDER_PIPECONNECTWRAP);
  req_wrap->Dispatch(uv_pipe_connect,
                     &wrap->handle_,
                     *name,
                     AfterConnect);

  TRACE_EVENT_NESTABLE_ASYNC_BEGIN1(TRACING_CATEGORY_NODE2(net, native),
                                    ""connect"",
                                    req_wrap,
                                    ""pipe_path"",
                                    TRACE_STR_COPY(*name));

  args.GetReturnValue().Set(0);  // uv_pipe_connect() doesn't return errors.
}",65,,226,2,,void
274681,BLOCK,-1,,<empty>,1,,1,1,,ANY
274702,BLOCK,-1,,<empty>,1,,1,1,,ANY
274711,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(context);
    Isolate* isolate = env->isolate();
    Local<FunctionTemplate> constructor = NewFunctionTemplate(isolate, New);
    constructor->InstanceTemplate()->SetInternalFieldCount(
        ProcessWrap::kInternalFieldCount);

    constructor->Inherit(HandleWrap::GetConstructorTemplate(env));

    SetProtoMethod(isolate, constructor, ""spawn"", Spawn);
    SetProtoMethod(isolate, constructor, ""kill"", Kill);

    SetConstructorFunction(context, target, ""Process"", constructor);
  }",38,,55,5,,void
274776,BLOCK,-1,,"{
    MarkAsUninitialized();
  }",53,,88,3,,void
274783,BLOCK,-1,,"{
    Local<String> handle_key = env->handle_string();
    // This property has always been set by JS land if we are in this code path.
    Local<Object> handle =
        stdio->Get(env->context(), handle_key).ToLocalChecked().As<Object>();

    uv_stream_t* stream = LibuvStreamWrap::From(env, handle)->stream();
    CHECK_NOT_NULL(stream);
    return stream;
  }",76,,92,3,,void
274837,BLOCK,-1,,"{
    Local<Context> context = env->context();
    Local<String> stdio_key = env->stdio_string();
    Local<Array> stdios =
        js_options->Get(context, stdio_key).ToLocalChecked().As<Array>();

    uint32_t len = stdios->Length();
    options->stdio = new uv_stdio_container_t[len];
    options->stdio_count = len;

    for (uint32_t i = 0; i < len; i++) {
      Local<Object> stdio =
          stdios->Get(context, i).ToLocalChecked().As<Object>();
      Local<Value> type =
          stdio->Get(context, env->type_string()).ToLocalChecked();

      if (type->StrictEquals(env->ignore_string())) {
        options->stdio[i].flags = UV_IGNORE;
      } else if (type->StrictEquals(env->pipe_string())) {
        options->stdio[i].flags = static_cast<uv_stdio_flags>(
            UV_CREATE_PIPE | UV_READABLE_PIPE | UV_WRITABLE_PIPE);
        options->stdio[i].data.stream = StreamForWrap(env, stdio);
      } else if (type->StrictEquals(env->overlapped_string())) {
        options->stdio[i].f...",64,,105,4,,void
274895,BLOCK,-1,,<empty>,5,,115,1,,void
274905,BLOCK,4,,"{
      Local<Object> stdio =
          stdios->Get(context, i).ToLocalChecked().As<Object>();
      Local<Value> type =
          stdio->Get(context, env->type_string()).ToLocalChecked();

      if (type->StrictEquals(env->ignore_string())) {
        options->stdio[i].flags = UV_IGNORE;
      } else if (type->StrictEquals(env->pipe_string())) {
        options->stdio[i].flags = static_cast<uv_stdio_flags>(
            UV_CREATE_PIPE | UV_READABLE_PIPE | UV_WRITABLE_PIPE);
        options->stdio[i].data.stream = StreamForWrap(env, stdio);
      } else if (type->StrictEquals(env->overlapped_string())) {
        options->stdio[i].flags = static_cast<uv_stdio_flags>(
            UV_CREATE_PIPE | UV_READABLE_PIPE | UV_WRITABLE_PIPE |
            UV_OVERLAPPED_PIPE);
        options->stdio[i].data.stream = StreamForWrap(env, stdio);
      } else if (type->StrictEquals(env->wrap_string())) {
        options->stdio[i].flags = UV_INHERIT_STREAM;
        options->stdio[i].data.stream = Strea...",40,,115,4,,void
274951,BLOCK,-1,,"{
        options->stdio[i].flags = UV_IGNORE;
      }",53,,121,2,,void
274962,BLOCK,-1,,<empty>,14,,123,1,,void
274972,BLOCK,-1,,"{
        options->stdio[i].flags = static_cast<uv_stdio_flags>(
            UV_CREATE_PIPE | UV_READABLE_PIPE | UV_WRITABLE_PIPE);
        options->stdio[i].data.stream = StreamForWrap(env, stdio);
      }",58,,123,2,,void
275002,BLOCK,-1,,<empty>,14,,127,1,,void
275012,BLOCK,-1,,"{
        options->stdio[i].flags = static_cast<uv_stdio_flags>(
            UV_CREATE_PIPE | UV_READABLE_PIPE | UV_WRITABLE_PIPE |
            UV_OVERLAPPED_PIPE);
        options->stdio[i].data.stream = StreamForWrap(env, stdio);
      }",64,,127,2,,void
275044,BLOCK,-1,,<empty>,14,,132,1,,void
275054,BLOCK,-1,,"{
        options->stdio[i].flags = UV_INHERIT_STREAM;
        options->stdio[i].data.stream = StreamForWrap(env, stdio);
      }",58,,132,2,,void
275078,BLOCK,-1,,"{
        Local<String> fd_key = env->fd_string();
        Local<Value> fd_value = stdio->Get(context, fd_key).ToLocalChecked();
        CHECK(fd_value->IsNumber());
        int fd = static_cast<int>(fd_value.As<Integer>()->Value());
        options->stdio[i].flags = UV_INHERIT_FD;
        options->stdio[i].data.fd = fd;
      }",14,,135,1,,void
275145,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(args);
    Local<Context> context = env->context();
    ProcessWrap* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
    THROW_IF_INSUFFICIENT_PERMISSIONS(
        env, permission::PermissionScope::kChildProcess, """");

    Local<Object> js_options =
        args[0]->ToObject(env->context()).ToLocalChecked();

    uv_process_options_t options;
    memset(&options, 0, sizeof(uv_process_options_t));

    options.exit_cb = OnExit;

    // options.uid
    Local<Value> uid_v =
        js_options->Get(context, env->uid_string()).ToLocalChecked();
    if (!uid_v->IsUndefined() && !uid_v->IsNull()) {
      CHECK(uid_v->IsInt32());
      const int32_t uid = uid_v.As<Int32>()->Value();
      options.flags |= UV_PROCESS_SETUID;
      options.uid = static_cast<uv_uid_t>(uid);
    }

    // options.gid
    Local<Value> gid_v =
        js_options->Get(context, env->gid_string()).ToLocalChecked();
    if (!gid_v->IsUndefined() && !gid_v->IsN...",62,,146,2,,void
275241,BLOCK,-1,,"{
      CHECK(uid_v->IsInt32());
      const int32_t uid = uid_v.As<Int32>()->Value();
      options.flags |= UV_PROCESS_SETUID;
      options.uid = static_cast<uv_uid_t>(uid);
    }",52,,165,2,,void
275299,BLOCK,-1,,"{
      CHECK(gid_v->IsInt32());
      const int32_t gid = gid_v.As<Int32>()->Value();
      options.flags |= UV_PROCESS_SETGID;
      options.gid = static_cast<uv_gid_t>(gid);
    }",52,,175,2,,void
275392,BLOCK,-1,,"{
      Local<Array> js_argv = argv_v.As<Array>();
      int argc = js_argv->Length();
      CHECK_LT(argc, INT_MAX);  // Check for overflow.

      // Heap allocate to detect errors. +1 is for nullptr.
      options.args = new char*[argc + 1];
      for (int i = 0; i < argc; i++) {
        node::Utf8Value arg(env->isolate(),
                            js_argv->Get(context, i).ToLocalChecked());
        options.args[i] = strdup(*arg);
        CHECK_NOT_NULL(options.args[i]);
      }
      options.args[argc] = nullptr;
    }",49,,194,2,,void
275420,BLOCK,-1,,<empty>,7,,201,1,,void
275430,BLOCK,4,,"{
        node::Utf8Value arg(env->isolate(),
                            js_argv->Get(context, i).ToLocalChecked());
        options.args[i] = strdup(*arg);
        CHECK_NOT_NULL(options.args[i]);
      }",38,,201,4,,void
275506,BLOCK,-1,,"{
      options.cwd = *cwd;
    }",27,,215,2,,void
275542,BLOCK,-1,,"{
      Local<Array> env_opt = env_v.As<Array>();
      int envc = env_opt->Length();
      CHECK_LT(envc, INT_MAX);            // Check for overflow.
      options.env = new char*[envc + 1];  // Heap allocated to detect errors.
      for (int i = 0; i < envc; i++) {
        node::Utf8Value pair(env->isolate(),
                             env_opt->Get(context, i).ToLocalChecked());
        options.env[i] = strdup(*pair);
        CHECK_NOT_NULL(options.env[i]);
      }
      options.env[envc] = nullptr;
    }",47,,222,2,,void
275570,BLOCK,-1,,<empty>,7,,227,1,,void
275580,BLOCK,4,,"{
        node::Utf8Value pair(env->isolate(),
                             env_opt->Get(context, i).ToLocalChecked());
        options.env[i] = strdup(*pair);
        CHECK_NOT_NULL(options.env[i]);
      }",38,,227,4,,void
275646,BLOCK,-1,,"{
      options.flags |= UV_PROCESS_WINDOWS_HIDE;
    }",27,,243,2,,void
275657,BLOCK,-1,,"{
      options.flags |= UV_PROCESS_WINDOWS_HIDE_CONSOLE;
    }",38,,247,2,,void
275686,BLOCK,-1,,"{
      options.flags |= UV_PROCESS_WINDOWS_VERBATIM_ARGUMENTS;
    }",26,,256,2,,void
275715,BLOCK,-1,,"{
      options.flags |= UV_PROCESS_DETACHED;
    }",31,,264,2,,void
275743,BLOCK,-1,,"{
      CHECK_EQ(wrap->process_.data, wrap);
      wrap->object()->Set(context, env->pid_string(),
                          Integer::New(env->isolate(),
                                       wrap->process_.pid)).Check();
    }",19,,271,2,,void
275783,BLOCK,-1,,"{
      for (int i = 0; options.args[i]; i++) free(options.args[i]);
      delete [] options.args;
    }",23,,278,2,,void
275785,BLOCK,-1,,<empty>,7,,279,1,,void
275811,BLOCK,-1,,"{
      for (int i = 0; options.env[i]; i++) free(options.env[i]);
      delete [] options.env;
    }",22,,283,2,,void
275813,BLOCK,-1,,<empty>,7,,284,1,,void
275851,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(args);
    ProcessWrap* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
    int signal = args[0]->Int32Value(env->context()).FromJust();
    int err = uv_process_kill(&wrap->process_, signal);
    args.GetReturnValue().Set(err);
  }",61,,293,2,,void
275907,BLOCK,-1,,"{
    ProcessWrap* wrap = ContainerOf(&ProcessWrap::process_, handle);
    CHECK_EQ(&wrap->process_, handle);

    Environment* env = wrap->env();
    HandleScope handle_scope(env->isolate());
    Context::Scope context_scope(env->context());

    Local<Value> argv[] = {
      Number::New(env->isolate(), static_cast<double>(exit_status)),
      OneByteString(env->isolate(), signo_string(term_signal))
    };

    wrap->MakeCallback(env->onexit_string(), arraysize(argv), argv);
  }",39,,304,4,,void
276007,BLOCK,-1,,<empty>,1,,1,1,,ANY
276032,BLOCK,-1,,<empty>,1,,1,1,,ANY
276047,BLOCK,-1,,<empty>,1,,1,1,,ANY
276058,BLOCK,-1,,<empty>,1,,1,1,,ANY
276077,BLOCK,-1,,<empty>,1,,1,1,,ANY
276096,BLOCK,-1,,<empty>,1,,1,1,,ANY
276111,BLOCK,-1,,<empty>,1,,1,1,,ANY
276119,BLOCK,-1,,"{
  v8::Local<v8::Value> value;
  if (!object->Get(env->context(), name).ToLocal(&value)) return false;
  if (!value->IsUndefined()) {
    Utf8Value utf8(env->isolate(), value);
    options->*member = *utf8;
  }
  return true;
}",51,,16,5,,void
276145,BLOCK,-1,,<empty>,59,,18,2,,void
276154,BLOCK,-1,,"{
    Utf8Value utf8(env->isolate(), value);
    options->*member = *utf8;
  }",30,,19,2,,void
276177,BLOCK,-1,,"{
  v8::Local<v8::Value> value;
  if (!object->Get(env->context(), name).ToLocal(&value)) return false;
  if (!value->IsUndefined()) {
    CHECK(value->IsBoolean());
    options->*member = value->IsTrue();
  }
  return true;
}",51,,30,5,,void
276203,BLOCK,-1,,<empty>,59,,32,2,,void
276212,BLOCK,-1,,"{
    CHECK(value->IsBoolean());
    options->*member = value->IsTrue();
  }",30,,33,2,,void
276235,BLOCK,-1,,"{
  v8::Local<v8::Value> value;
  if (!object->Get(env->context(), name).ToLocal(&value)) return false;

  if (!value->IsUndefined()) {
    CHECK_IMPLIES(!value->IsBigInt(), value->IsNumber());

    uint64_t val = 0;
    if (value->IsBigInt()) {
      bool lossless = true;
      val = value.As<v8::BigInt>()->Uint64Value(&lossless);
      if (!lossless) {
        Utf8Value label(env->isolate(), name);
        THROW_ERR_OUT_OF_RANGE(
            env, (""options."" + label.ToString() + "" is out of range"").c_str());
        return false;
      }
    } else {
      val = static_cast<int64_t>(value.As<v8::Number>()->Value());
    }
    options->*member = val;
  }
  return true;
}",51,,44,5,,void
276261,BLOCK,-1,,<empty>,59,,46,2,,void
276270,BLOCK,-1,,"{
    CHECK_IMPLIES(!value->IsBigInt(), value->IsNumber());

    uint64_t val = 0;
    if (value->IsBigInt()) {
      bool lossless = true;
      val = value.As<v8::BigInt>()->Uint64Value(&lossless);
      if (!lossless) {
        Utf8Value label(env->isolate(), name);
        THROW_ERR_OUT_OF_RANGE(
            env, (""options."" + label.ToString() + "" is out of range"").c_str());
        return false;
      }
    } else {
      val = static_cast<int64_t>(value.As<v8::Number>()->Value());
    }
    options->*member = val;
  }",30,,48,2,,void
276290,BLOCK,-1,,"{
      bool lossless = true;
      val = value.As<v8::BigInt>()->Uint64Value(&lossless);
      if (!lossless) {
        Utf8Value label(env->isolate(), name);
        THROW_ERR_OUT_OF_RANGE(
            env, (""options."" + label.ToString() + "" is out of range"").c_str());
        return false;
      }
    }",28,,52,2,,void
276309,BLOCK,-1,,"{
        Utf8Value label(env->isolate(), name);
        THROW_ERR_OUT_OF_RANGE(
            env, (""options."" + label.ToString() + "" is out of range"").c_str());
        return false;
      }",22,,55,2,,void
276333,BLOCK,-1,,"{
      val = static_cast<int64_t>(value.As<v8::Number>()->Value());
    }",12,,61,1,,void
276357,BLOCK,-1,,"{
  stats->*member += amt;
}",52,,74,3,,void
276367,BLOCK,-1,,"{
  stats->*member = uv_hrtime();
}",40,,79,2,,void
276378,BLOCK,-1,,"{
  stats->*member = val;
}",42,,84,3,,void
276388,BLOCK,-1,,"{
  return stats->*member;
}",32,,89,2,,void
276419,BLOCK,-1,,<empty>,1,,1,1,,ANY
276434,BLOCK,-1,,<empty>,1,,1,1,,ANY
276467,BLOCK,-1,,<empty>,1,,1,1,,ANY
276498,BLOCK,-1,,<empty>,1,,1,1,,ANY
276519,BLOCK,-1,,<empty>,1,,1,1,,ANY
276534,BLOCK,-1,,<empty>,1,,1,1,,ANY
276551,BLOCK,-1,,<empty>,1,,1,1,,ANY
276568,BLOCK,-1,,<empty>,1,,1,1,,ANY
276597,BLOCK,-1,,<empty>,1,,1,1,,ANY
276618,BLOCK,-1,,<empty>,1,,1,1,,ANY
276637,BLOCK,-1,,<empty>,1,,1,1,,ANY
276652,BLOCK,-1,,<empty>,1,,1,1,,ANY
276675,BLOCK,-1,,<empty>,1,,1,1,,ANY
276696,BLOCK,-1,,<empty>,1,,1,1,,ANY
276707,BLOCK,-1,,<empty>,1,,1,1,,ANY
276718,BLOCK,-1,,<empty>,1,,1,1,,ANY
276723,BLOCK,-1,,"{
          SignalWrap* wrap = ContainerOf(&SignalWrap::handle_, handle);
          Environment* env = wrap->env();
          HandleScope handle_scope(env->isolate());
          Context::Scope context_scope(env->context());
          Local<Value> arg = Integer::New(env->isolate(), signum);
          wrap->MakeCallback(env->onsignal_string(), 1, &arg);
        }",45,,123,3,,void
276800,BLOCK,-1,,<empty>,1,,1,1,,ANY
276804,BLOCK,-1,,<empty>,,,,2,,<empty>
276815,BLOCK,-1,,"{
    Environment* env = Environment::GetCurrent(context);
    Isolate* isolate = env->isolate();
    Local<FunctionTemplate> constructor = NewFunctionTemplate(isolate, New);
    constructor->InstanceTemplate()->SetInternalFieldCount(
        SignalWrap::kInternalFieldCount);
    constructor->Inherit(HandleWrap::GetConstructorTemplate(env));

    SetProtoMethod(isolate, constructor, ""start"", Start);
    SetProtoMethod(isolate, constructor, ""stop"", Stop);

    SetConstructorFunction(context, target, ""Signal"", constructor);
  }",38,,54,5,,void
276878,BLOCK,-1,,"{
    registry->Register(New);
    registry->Register(Start);
    registry->Register(Stop);
  }",79,,68,2,,void
276900,BLOCK,-1,,"{
    int r = uv_signal_init(env->event_loop(), &handle_);
    CHECK_EQ(r, 0);
  }",52,,92,3,,void
276918,BLOCK,-1,,"{
    if (active_) {
      DecreaseSignalHandlerCount(handle_.signum);
      active_ = false;
    }
    HandleWrap::Close(close_callback);
  }",60,,97,2,,void
276921,BLOCK,-1,,"{
      DecreaseSignalHandlerCount(handle_.signum);
      active_ = false;
    }",18,,98,2,,void
276938,BLOCK,-1,,"{
    SignalWrap* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
    Environment* env = wrap->env();
    int signum;
    if (!args[0]->Int32Value(env->context()).To(&signum)) return;
#if defined(__POSIX__) && HAVE_INSPECTOR
    if (signum == SIGPROF) {
      Environment* env = Environment::GetCurrent(args);
      if (env->inspector_agent()->IsListening()) {
        ProcessEmitWarning(env,
                           ""process.on(SIGPROF) is reserved while debugging"");
        return;
      }
    }
#endif
    int err = uv_signal_start(
        &wrap->handle_,
        [](uv_signal_t* handle, int signum) {
          SignalWrap* wrap = ContainerOf(&SignalWrap::handle_, handle);
          Environment* env = wrap->env();
          HandleScope handle_scope(env->isolate());
          Context::Scope context_scope(env->context());
          Local<Value> arg = Integer::New(env->isolate(), signum);
          wrap->MakeCallback(env->onsignal_string(), 1, &arg);
        },
        signum)...",62,,105,2,,void
276971,BLOCK,-1,,<empty>,59,,110,2,,void
276987,BLOCK,-1,,"{
      CHECK(!wrap->active_);
      wrap->active_ = true;
      Mutex::ScopedLock lock(handled_signals_mutex);
      handled_signals[signum]++;
    }",19,,133,2,,void
277017,BLOCK,-1,,"{
    SignalWrap* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

    if (wrap->active_)  {
      wrap->active_ = false;
      DecreaseSignalHandlerCount(wrap->handle_.signum);
    }

    int err = uv_signal_stop(&wrap->handle_);
    args.GetReturnValue().Set(err);
  }",61,,143,2,,void
277030,BLOCK,-1,,"{
      wrap->active_ = false;
      DecreaseSignalHandlerCount(wrap->handle_.signum);
    }",25,,147,2,,void
277063,BLOCK,-1,,<empty>,,,,1,,<empty>
277071,BLOCK,-1,,"{
  Mutex::ScopedLock lock(handled_signals_mutex);
  int64_t new_handler_count = --handled_signals[signum];
  CHECK_GE(new_handler_count, 0);
  if (new_handler_count == 0)
    handled_signals.erase(signum);
}",45,,163,2,,void
277089,BLOCK,-1,,<empty>,5,,168,2,,void
277099,BLOCK,-1,,"{
  Mutex::ScopedLock lock(handled_signals_mutex);
  return handled_signals.find(signum) != handled_signals.end();
}",37,,171,2,,void
277135,BLOCK,-1,,<empty>,1,,1,1,,ANY
277140,BLOCK,-1,,"{
  if (used() == kBufferSize)
    *buf = uv_buf_init(nullptr, 0);
  else
    *buf = uv_buf_init(data_ + used(), available());
}",60,,54,3,,void
277145,BLOCK,-1,,<empty>,5,,56,2,,void
277153,BLOCK,-1,,<empty>,5,,58,1,,void
277167,BLOCK,-1,,"{
  // If we hand out the same chunk twice, this should catch it.
  CHECK_EQ(buf->base, data_ + used());
  used_ += static_cast<unsigned int>(nread);
}",73,,62,3,,void
277184,BLOCK,-1,,"{
  memcpy(dest, data_, used());
  return used();
}",56,,69,2,,void
277194,BLOCK,-1,,"{
  return sizeof data_ - used();
}",57,,75,1,,void
277203,BLOCK,-1,,"{
  return used_;
}",52,,80,1,,void
277209,BLOCK,-1,,"{
  return next_;
}",64,,85,1,,void
277216,BLOCK,-1,,"{
  next_ = next;
}",71,,90,2,,void
277227,BLOCK,-1,,"{
  CHECK(readable || writable);
}",34,,111,5,,void
277235,BLOCK,-1,,"{
  CHECK(lifecycle_ == kUninitialized || lifecycle_ == kClosed);

  SyncProcessOutputBuffer* buf;
  SyncProcessOutputBuffer* next;

  for (buf = first_output_buffer_; buf != nullptr; buf = next) {
    next = buf->next();
    delete buf;
  }
}",47,,116,1,,void
277247,BLOCK,-1,,<empty>,3,,122,1,,void
277257,BLOCK,4,,"{
    next = buf->next();
    delete buf;
  }",64,,122,4,,void
277270,BLOCK,-1,,"{
  CHECK_EQ(lifecycle_, kUninitialized);

  int r = uv_pipe_init(loop, uv_pipe(), 0);
  if (r < 0)
    return r;

  uv_pipe()->data = this;

  lifecycle_ = kInitialized;
  return 0;
}",55,,129,2,,void
277285,BLOCK,-1,,<empty>,5,,134,2,,void
277301,BLOCK,-1,,"{
  CHECK_EQ(lifecycle_, kInitialized);

  // Set the busy flag already. If this function fails no recovery is
  // possible.
  lifecycle_ = kStarted;

  if (readable()) {
    if (input_buffer_.len > 0) {
      CHECK_NOT_NULL(input_buffer_.base);

      int r = uv_write(&write_req_,
                       uv_stream(),
                       &input_buffer_,
                       1,
                       WriteCallback);
      if (r < 0)
        return r;
    }

    int r = uv_shutdown(&shutdown_req_, uv_stream(), ShutdownCallback);
    if (r < 0)
      return r;
  }

  if (writable()) {
    int r = uv_read_start(uv_stream(), AllocCallback, ReadCallback);
    if (r < 0)
      return r;
  }

  return 0;
}",35,,143,1,,void
277310,BLOCK,-1,,"{
    if (input_buffer_.len > 0) {
      CHECK_NOT_NULL(input_buffer_.base);

      int r = uv_write(&write_req_,
                       uv_stream(),
                       &input_buffer_,
                       1,
                       WriteCallback);
      if (r < 0)
        return r;
    }

    int r = uv_shutdown(&shutdown_req_, uv_stream(), ShutdownCallback);
    if (r < 0)
      return r;
  }",19,,150,2,,void
277317,BLOCK,-1,,"{
      CHECK_NOT_NULL(input_buffer_.base);

      int r = uv_write(&write_req_,
                       uv_stream(),
                       &input_buffer_,
                       1,
                       WriteCallback);
      if (r < 0)
        return r;
    }",32,,151,2,,void
277337,BLOCK,-1,,<empty>,9,,160,2,,void
277352,BLOCK,-1,,<empty>,7,,165,2,,void
277357,BLOCK,-1,,"{
    int r = uv_read_start(uv_stream(), AllocCallback, ReadCallback);
    if (r < 0)
      return r;
  }",19,,168,2,,void
277369,BLOCK,-1,,<empty>,7,,171,2,,void
277377,BLOCK,-1,,"{
  CHECK(lifecycle_ == kInitialized || lifecycle_ == kStarted);

  uv_close(uv_handle(), CloseCallback);

  lifecycle_ = kClosing;
}",36,,178,1,,void
277396,BLOCK,-1,,"{
  size_t length = OutputLength();
  Local<Object> js_buffer = Buffer::New(env, length).ToLocalChecked();
  CopyOutput(Buffer::Data(js_buffer));
  return js_buffer;
}",79,,187,2,,void
277427,BLOCK,-1,,"{
  return readable_;
}",45,,195,1,,void
277433,BLOCK,-1,,"{
  return writable_;
}",45,,200,1,,void
277439,BLOCK,-1,,"{
  unsigned int flags;

  flags = UV_CREATE_PIPE;
  if (readable())
    flags |= UV_READABLE_PIPE;
  if (writable())
    flags |= UV_WRITABLE_PIPE;

  return static_cast<uv_stdio_flags>(flags);
}",55,,205,1,,void
277446,BLOCK,-1,,<empty>,5,,210,2,,void
277452,BLOCK,-1,,<empty>,5,,212,2,,void
277463,BLOCK,-1,,"{
  CHECK_LT(lifecycle_, kClosing);
  return &uv_pipe_;
}",50,,218,1,,void
277473,BLOCK,-1,,"{
  return reinterpret_cast<uv_stream_t*>(uv_pipe());
}",54,,224,1,,void
277481,BLOCK,-1,,"{
  return reinterpret_cast<uv_handle_t*>(uv_pipe());
}",54,,229,1,,void
277489,BLOCK,-1,,"{
  SyncProcessOutputBuffer* buf;
  size_t size = 0;

  for (buf = first_output_buffer_; buf != nullptr; buf = buf->next())
    size += buf->used();

  return size;
}",51,,234,1,,void
277496,BLOCK,-1,,<empty>,3,,238,1,,void
277521,BLOCK,-1,,"{
  SyncProcessOutputBuffer* buf;
  size_t offset = 0;

  for (buf = first_output_buffer_; buf != nullptr; buf = buf->next())
    offset += buf->Copy(dest + offset);
}",57,,245,2,,void
277528,BLOCK,-1,,<empty>,3,,249,1,,void
277555,BLOCK,-1,,"{
  // This function assumes that libuv will never allocate two buffers for the
  // same stream at the same time. There's an assert in
  // SyncProcessOutputBuffer::OnRead that would fail if this assumption was
  // ever violated.

  if (last_output_buffer_ == nullptr) {
    // Allocate the first capture buffer.
    first_output_buffer_ = new SyncProcessOutputBuffer();
    last_output_buffer_ = first_output_buffer_;

  } else if (last_output_buffer_->available() == 0) {
    // The current capture buffer is full so get us a new one.
    SyncProcessOutputBuffer* buf = new SyncProcessOutputBuffer();
    last_output_buffer_->set_next(buf);
    last_output_buffer_ = buf;
  }

  last_output_buffer_->OnAlloc(suggested_size, buf);
}",74,,254,3,,void
277560,BLOCK,-1,,"{
    // Allocate the first capture buffer.
    first_output_buffer_ = new SyncProcessOutputBuffer();
    last_output_buffer_ = first_output_buffer_;

  }",39,,260,2,,void
277569,BLOCK,-1,,<empty>,10,,265,1,,void
277577,BLOCK,-1,,"{
    // The current capture buffer is full so get us a new one.
    SyncProcessOutputBuffer* buf = new SyncProcessOutputBuffer();
    last_output_buffer_->set_next(buf);
    last_output_buffer_ = buf;
  }",53,,265,2,,void
277602,BLOCK,-1,,"{
  if (nread == UV_EOF) {
    // Libuv implicitly stops reading on EOF.

  } else if (nread < 0) {
    SetError(static_cast<int>(nread));
    // At some point libuv should really implicitly stop reading on error.
    uv_read_stop(uv_stream());

  } else {
    last_output_buffer_->OnRead(buf, nread);
    process_handler_->IncrementBufferSizeAndCheckOverflow(nread);
  }
}",71,,276,3,,void
277607,BLOCK,-1,,"{
    // Libuv implicitly stops reading on EOF.

  }",24,,277,2,,void
277609,BLOCK,-1,,<empty>,10,,280,1,,void
277614,BLOCK,-1,,"{
    SetError(static_cast<int>(nread));
    // At some point libuv should really implicitly stop reading on error.
    uv_read_stop(uv_stream());

  }",25,,280,2,,void
277621,BLOCK,-1,,"{
    last_output_buffer_->OnRead(buf, nread);
    process_handler_->IncrementBufferSizeAndCheckOverflow(nread);
  }",10,,285,1,,void
277637,BLOCK,-1,,"{
  if (result < 0)
    SetError(result);
}",52,,292,2,,void
277642,BLOCK,-1,,<empty>,5,,294,2,,void
277649,BLOCK,-1,,"{
  if (result < 0)
    SetError(result);
}",55,,298,2,,void
277654,BLOCK,-1,,<empty>,5,,300,2,,void
277660,BLOCK,-1,,"{
  lifecycle_ = kClosed;
}",38,,304,1,,void
277668,BLOCK,-1,,"{
  CHECK_NE(error, 0);
  process_handler_->SetPipeError(error);
}",48,,309,2,,void
277683,BLOCK,-1,,"{
  SyncProcessStdioPipe* self =
      reinterpret_cast<SyncProcessStdioPipe*>(handle->data);
  self->OnAlloc(suggested_size, buf);
}",57,,317,4,,void
277704,BLOCK,-1,,"{
  SyncProcessStdioPipe* self =
        reinterpret_cast<SyncProcessStdioPipe*>(stream->data);
  self->OnRead(buf, nread);
}",62,,326,4,,void
277724,BLOCK,-1,,"{
  SyncProcessStdioPipe* self =
      reinterpret_cast<SyncProcessStdioPipe*>(req->handle->data);
  self->OnWriteDone(result);
}",71,,333,3,,void
277745,BLOCK,-1,,"{
  SyncProcessStdioPipe* self =
      reinterpret_cast<SyncProcessStdioPipe*>(req->handle->data);

  // On AIX, OS X and the BSDs, calling shutdown() on one end of a pipe
  // when the other end has closed the connection fails with ENOTCONN.
  // Libuv is not the right place to handle that because it can't tell
  // if the error is genuine but we here can.
  if (result == UV_ENOTCONN)
    result = 0;

  self->OnShutdownDone(result);
}",77,,340,3,,void
277760,BLOCK,-1,,<empty>,5,,349,2,,void
277773,BLOCK,-1,,"{
  SyncProcessStdioPipe* self =
      reinterpret_cast<SyncProcessStdioPipe*>(handle->data);
  self->OnClose();
}",63,,355,2,,void
277793,BLOCK,-1,,"{
  SetMethod(context, target, ""spawn"", Spawn);
}",48,,365,5,,void
277803,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kChildProcess, """");
  env->PrintSyncTrace();
  SyncProcessRunner p(env);
  Local<Value> result;
  if (!p.Run(args[0]).ToLocal(&result)) return;
  args.GetReturnValue().Set(result);
}",72,,370,2,,void
277846,BLOCK,-1,,<empty>,41,,377,2,,void
277860,BLOCK,-1,,"{
}",17,,414,2,,void
277864,BLOCK,-1,,"{
  CHECK_EQ(lifecycle_, kHandlesClosed);

  stdio_pipes_.clear();
  delete[] file_buffer_;
  delete[] args_buffer_;
  delete[] cwd_buffer_;
  delete[] env_buffer_;
  delete[] uv_stdio_containers_;
}",41,,418,1,,void
277885,BLOCK,-1,,"{
  return env_;
}",45,,430,1,,void
277892,BLOCK,-1,,"{
  EscapableHandleScope scope(env()->isolate());

  CHECK_EQ(lifecycle_, kUninitialized);

  Maybe<bool> r = TryInitializeAndRunLoop(options);
  CloseHandlesAndDeleteLoop();
  if (r.IsNothing()) return MaybeLocal<Object>();

  Local<Object> result = BuildResultObject();

  return scope.Escape(result);
}",65,,434,2,,void
277913,BLOCK,-1,,<empty>,22,,441,2,,void
277933,BLOCK,-1,,"{
  int r;

  // There is no recovery from failure inside TryInitializeAndRunLoop - the
  // only option we'd have is to close all handles and destroy the loop.
  CHECK_EQ(lifecycle_, kUninitialized);
  lifecycle_ = kInitialized;

  uv_loop_ = new uv_loop_t;
  if (uv_loop_ == nullptr) {
    SetError(UV_ENOMEM);
    return Just(false);
  }

  r = uv_loop_init(uv_loop_);
  if (r < 0) {
    delete uv_loop_;
    uv_loop_ = nullptr;
    SetError(r);
    return Just(false);
  }

  if (!ParseOptions(options).To(&r)) return Nothing<bool>();

  if (r < 0) {
    SetError(r);
    return Just(false);
  }

  if (timeout_ > 0) {
    r = uv_timer_init(uv_loop_, &uv_timer_);
    if (r < 0) {
      SetError(r);
      return Just(false);
    }

    uv_unref(reinterpret_cast<uv_handle_t*>(&uv_timer_));

    uv_timer_.data = this;
    kill_timer_initialized_ = true;

    // Start the timer immediately. If uv_spawn fails then
    // CloseHandlesAndDeleteLoop() will immediately close the timer handle
   ...",78,,448,2,,void
277949,BLOCK,-1,,"{
    SetError(UV_ENOMEM);
    return Just(false);
  }",28,,457,2,,void
277962,BLOCK,-1,,"{
    delete uv_loop_;
    uv_loop_ = nullptr;
    SetError(r);
    return Just(false);
  }",14,,463,2,,void
277982,BLOCK,-1,,<empty>,38,,470,2,,void
277989,BLOCK,-1,,"{
    SetError(r);
    return Just(false);
  }",14,,472,2,,void
277999,BLOCK,-1,,"{
    r = uv_timer_init(uv_loop_, &uv_timer_);
    if (r < 0) {
      SetError(r);
      return Just(false);
    }

    uv_unref(reinterpret_cast<uv_handle_t*>(&uv_timer_));

    uv_timer_.data = this;
    kill_timer_initialized_ = true;

    // Start the timer immediately. If uv_spawn fails then
    // CloseHandlesAndDeleteLoop() will immediately close the timer handle
    // which implicitly stops it, so there is no risk that the timeout callback
    // runs when the process didn't start.
    r = uv_timer_start(&uv_timer_, KillTimerCallback, timeout_, 0);
    if (r < 0) {
      SetError(r);
      return Just(false);
    }
  }",21,,477,2,,void
278010,BLOCK,-1,,"{
      SetError(r);
      return Just(false);
    }",16,,479,2,,void
278041,BLOCK,-1,,"{
      SetError(r);
      return Just(false);
    }",16,,494,2,,void
278064,BLOCK,-1,,"{
    SetError(r);
    return Just(false);
  }",14,,502,2,,void
278078,BLOCK,-1,,"{
    if (pipe != nullptr) {
      r = pipe->Start();
      if (r < 0) {
        SetPipeError(r);
        return Just(false);
      }
    }
  }",41,,508,3,,void
278083,BLOCK,-1,,"{
      r = pipe->Start();
      if (r < 0) {
        SetPipeError(r);
        return Just(false);
      }
    }",26,,509,2,,void
278094,BLOCK,-1,,"{
        SetPipeError(r);
        return Just(false);
      }",18,,511,2,,void
278109,BLOCK,-1,,<empty>,5,,521,2,,void
278120,BLOCK,-1,,"{
  CHECK_LT(lifecycle_, kHandlesClosed);

  if (uv_loop_ != nullptr) {
    CloseStdioPipes();
    CloseKillTimer();
    // Close the process handle when ExitCallback was not called.
    uv_handle_t* uv_process_handle =
        reinterpret_cast<uv_handle_t*>(&uv_process_);

    // Close the process handle if it is still open. The handle type also
    // needs to be checked because TryInitializeAndRunLoop() won't spawn a
    // process if input validation fails.
    if (uv_process_handle->type == UV_PROCESS &&
        !uv_is_closing(uv_process_handle))
      uv_close(uv_process_handle, nullptr);

    // Give closing watchers a chance to finish closing and get their close
    // callbacks called.
    int r = uv_run(uv_loop_, UV_RUN_DEFAULT);
    if (r < 0)
      ABORT();

    CheckedUvLoopClose(uv_loop_);
    delete uv_loop_;
    uv_loop_ = nullptr;

  } else {
    // If the loop doesn't exist, neither should any pipes or timers.
    CHECK_EQ(false, stdio_pipes_initialized_);
    CHEC...",53,,529,1,,void
278128,BLOCK,-1,,"{
    CloseStdioPipes();
    CloseKillTimer();
    // Close the process handle when ExitCallback was not called.
    uv_handle_t* uv_process_handle =
        reinterpret_cast<uv_handle_t*>(&uv_process_);

    // Close the process handle if it is still open. The handle type also
    // needs to be checked because TryInitializeAndRunLoop() won't spawn a
    // process if input validation fails.
    if (uv_process_handle->type == UV_PROCESS &&
        !uv_is_closing(uv_process_handle))
      uv_close(uv_process_handle, nullptr);

    // Give closing watchers a chance to finish closing and get their close
    // callbacks called.
    int r = uv_run(uv_loop_, UV_RUN_DEFAULT);
    if (r < 0)
      ABORT();

    CheckedUvLoopClose(uv_loop_);
    delete uv_loop_;
    uv_loop_ = nullptr;

  }",28,,532,2,,void
278148,BLOCK,-1,,<empty>,7,,544,2,,void
278162,BLOCK,-1,,<empty>,7,,550,2,,void
278171,BLOCK,-1,,"{
    // If the loop doesn't exist, neither should any pipes or timers.
    CHECK_EQ(false, stdio_pipes_initialized_);
    CHECK_EQ(false, kill_timer_initialized_);
  }",10,,556,1,,void
278184,BLOCK,-1,,"{
  CHECK_LT(lifecycle_, kHandlesClosed);

  if (stdio_pipes_initialized_) {
    CHECK(!stdio_pipes_.empty());
    CHECK_NOT_NULL(uv_loop_);

    for (const auto& pipe : stdio_pipes_) {
      if (pipe)
        pipe->Close();
    }

    stdio_pipes_initialized_ = false;
  }
}",43,,566,1,,void
278190,BLOCK,-1,,"{
    CHECK(!stdio_pipes_.empty());
    CHECK_NOT_NULL(uv_loop_);

    for (const auto& pipe : stdio_pipes_) {
      if (pipe)
        pipe->Close();
    }

    stdio_pipes_initialized_ = false;
  }",33,,569,2,,void
278201,BLOCK,-1,,"{
      if (pipe)
        pipe->Close();
    }",43,,573,3,,void
278204,BLOCK,-1,,<empty>,9,,575,2,,void
278215,BLOCK,-1,,"{
  CHECK_LT(lifecycle_, kHandlesClosed);

  if (kill_timer_initialized_) {
    CHECK_GT(timeout_, 0);
    CHECK_NOT_NULL(uv_loop_);

    uv_handle_t* uv_timer_handle = reinterpret_cast<uv_handle_t*>(&uv_timer_);
    uv_ref(uv_timer_handle);
    uv_close(uv_timer_handle, KillTimerCloseCallback);

    kill_timer_initialized_ = false;
  }
}",42,,583,1,,void
278221,BLOCK,-1,,"{
    CHECK_GT(timeout_, 0);
    CHECK_NOT_NULL(uv_loop_);

    uv_handle_t* uv_timer_handle = reinterpret_cast<uv_handle_t*>(&uv_timer_);
    uv_ref(uv_timer_handle);
    uv_close(uv_timer_handle, KillTimerCloseCallback);

    kill_timer_initialized_ = false;
  }",32,,586,2,,void
278244,BLOCK,-1,,"{
  // Only attempt to kill once.
  if (killed_)
    return;
  killed_ = true;

  // We might get here even if the process we spawned has already exited. This
  // could happen when our child process spawned another process which
  // inherited (one of) the stdio pipes. In this case we won't attempt to send
  // a signal to the process, however we will still close our end of the stdio
  // pipes so this situation won't make us hang.
  if (exit_status_ < 0) {
    int r = uv_process_kill(&uv_process_, kill_signal_);

    // If uv_kill failed with an error that isn't ESRCH, the user probably
    // specified an invalid or unsupported signal. Signal this to the user as
    // and error and kill the process with SIGKILL instead.
    if (r < 0 && r != UV_ESRCH) {
      SetError(r);

      // Deliberately ignore the return value, we might not have
      // sufficient privileges to signal the child process.
      USE(uv_process_kill(&uv_process_, SIGKILL));
    }
  }

  // Close all stdio p...",32,,599,1,,void
278247,BLOCK,-1,,<empty>,5,,602,2,,void
278256,BLOCK,-1,,"{
    int r = uv_process_kill(&uv_process_, kill_signal_);

    // If uv_kill failed with an error that isn't ESRCH, the user probably
    // specified an invalid or unsupported signal. Signal this to the user as
    // and error and kill the process with SIGKILL instead.
    if (r < 0 && r != UV_ESRCH) {
      SetError(r);

      // Deliberately ignore the return value, we might not have
      // sufficient privileges to signal the child process.
      USE(uv_process_kill(&uv_process_, SIGKILL));
    }
  }",25,,610,2,,void
278272,BLOCK,-1,,"{
      SetError(r);

      // Deliberately ignore the return value, we might not have
      // sufficient privileges to signal the child process.
      USE(uv_process_kill(&uv_process_, SIGKILL));
    }",33,,616,2,,void
278286,BLOCK,-1,,"{
  buffered_output_size_ += length;

  if (max_buffer_ > 0 && buffered_output_size_ > max_buffer_) {
    SetError(UV_ENOBUFS);
    Kill();
  }
}",77,,633,2,,void
278298,BLOCK,-1,,"{
    SetError(UV_ENOBUFS);
    Kill();
  }",63,,636,2,,void
278306,BLOCK,-1,,"{
  if (exit_status < 0)
    return SetError(static_cast<int>(exit_status));

  exit_status_ = exit_status;
  term_signal_ = term_signal;
}",70,,643,3,,void
278311,BLOCK,-1,,<empty>,5,,645,2,,void
278326,BLOCK,-1,,"{
  SetError(UV_ETIMEDOUT);
  Kill();
}",46,,652,1,,void
278332,BLOCK,-1,,"{
  if (error_ != 0)
    return error_;
  else
    return pipe_error_;
}",35,,658,1,,void
278337,BLOCK,-1,,<empty>,5,,660,2,,void
278341,BLOCK,-1,,<empty>,5,,662,1,,void
278348,BLOCK,-1,,"{
  if (error_ == 0)
    error_ = error;
}",45,,666,2,,void
278353,BLOCK,-1,,<empty>,5,,668,2,,void
278361,BLOCK,-1,,"{
  if (pipe_error_ == 0)
    pipe_error_ = pipe_error;
}",54,,672,2,,void
278366,BLOCK,-1,,<empty>,5,,674,2,,void
278373,BLOCK,-1,,"{
  EscapableHandleScope scope(env()->isolate());
  Local<Context> context = env()->context();

  Local<Object> js_result = Object::New(env()->isolate());

  if (GetError() != 0) {
    js_result->Set(context, env()->error_string(),
                   Integer::New(env()->isolate(), GetError())).Check();
  }

  if (exit_status_ >= 0) {
    if (term_signal_ > 0) {
      js_result->Set(context, env()->status_string(),
                     Null(env()->isolate())).Check();
    } else {
      js_result->Set(context, env()->status_string(),
                     Number::New(env()->isolate(),
                                 static_cast<double>(exit_status_))).Check();
    }
  } else {
    // If exit_status_ < 0 the process was never started because of some error.
    js_result->Set(context, env()->status_string(),
                   Null(env()->isolate())).Check();
  }

  if (term_signal_ > 0)
    js_result->Set(context, env()->signal_string(),
                   String::NewFromUtf8(env()->i...",54,,678,1,,void
278408,BLOCK,-1,,"{
    js_result->Set(context, env()->error_string(),
                   Integer::New(env()->isolate(), GetError())).Check();
  }",24,,684,2,,void
278434,BLOCK,-1,,"{
    if (term_signal_ > 0) {
      js_result->Set(context, env()->status_string(),
                     Null(env()->isolate())).Check();
    } else {
      js_result->Set(context, env()->status_string(),
                     Number::New(env()->isolate(),
                                 static_cast<double>(exit_status_))).Check();
    }
  }",26,,689,2,,void
278439,BLOCK,-1,,"{
      js_result->Set(context, env()->status_string(),
                     Null(env()->isolate())).Check();
    }",27,,690,2,,void
278458,BLOCK,-1,,"{
      js_result->Set(context, env()->status_string(),
                     Number::New(env()->isolate(),
                                 static_cast<double>(exit_status_))).Check();
    }",12,,693,1,,void
278483,BLOCK,-1,,"{
    // If exit_status_ < 0 the process was never started because of some error.
    js_result->Set(context, env()->status_string(),
                   Null(env()->isolate())).Check();
  }",10,,698,1,,void
278505,BLOCK,-1,,<empty>,5,,705,2,,void
278532,BLOCK,-1,,<empty>,5,,711,1,,void
278554,BLOCK,-1,,<empty>,5,,715,2,,void
278569,BLOCK,-1,,<empty>,5,,718,1,,void
278619,BLOCK,-1,,"{
  CHECK_GE(lifecycle_, kInitialized);
  CHECK(!stdio_pipes_.empty());

  EscapableHandleScope scope(env()->isolate());
  MaybeStackBuffer<Local<Value>, 8> js_output(stdio_pipes_.size());

  for (uint32_t i = 0; i < stdio_pipes_.size(); i++) {
    SyncProcessStdioPipe* h = stdio_pipes_[i].get();
    if (h != nullptr && h->writable())
      js_output[i] = h->GetOutputAsBuffer(env());
    else
      js_output[i] = Null(env()->isolate());
  }

  return scope.Escape(
      Array::New(env()->isolate(), js_output.out(), js_output.length()));
}",52,,728,1,,void
278642,BLOCK,-1,,<empty>,3,,735,1,,void
278655,BLOCK,4,,"{
    SyncProcessStdioPipe* h = stdio_pipes_[i].get();
    if (h != nullptr && h->writable())
      js_output[i] = h->GetOutputAsBuffer(env());
    else
      js_output[i] = Null(env()->isolate());
  }",54,,735,4,,void
278674,BLOCK,-1,,<empty>,7,,738,2,,void
278685,BLOCK,-1,,<empty>,7,,740,1,,void
278720,BLOCK,-1,,"{
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  int r;

  if (!js_value->IsObject()) return Just<int>(UV_EINVAL);

  Local<Context> context = env()->context();
  Local<Object> js_options = js_value.As<Object>();

  Local<Value> js_file =
      js_options->Get(context, env()->file_string()).ToLocalChecked();
  if (!CopyJsString(js_file, &file_buffer_).To(&r)) return Nothing<int>();
  if (r < 0) return Just(r);
  uv_process_options_.file = file_buffer_;

  Local<Value> js_args =
      js_options->Get(context, env()->args_string()).ToLocalChecked();
  if (!CopyJsStringArray(js_args, &args_buffer_).To(&r)) return Nothing<int>();
  if (r < 0) return Just(r);
  uv_process_options_.args = reinterpret_cast<char**>(args_buffer_);

  Local<Value> js_cwd =
      js_options->Get(context, env()->cwd_string()).ToLocalChecked();
  if (IsSet(js_cwd)) {
    if (!CopyJsString(js_cwd, &cwd_buffer_).To(&r)) return Nothing<int>();
    if (r < 0) return Just(r);
    uv_process_op...",67,,747,2,,void
278738,BLOCK,-1,,<empty>,30,,752,2,,void
278791,BLOCK,-1,,<empty>,53,,759,2,,void
278798,BLOCK,-1,,<empty>,14,,760,2,,void
278836,BLOCK,-1,,<empty>,58,,765,2,,void
278843,BLOCK,-1,,<empty>,14,,766,2,,void
278873,BLOCK,-1,,<empty>,7,,771,1,,void
278875,BLOCK,-1,,"{
    if (!CopyJsString(js_cwd, &cwd_buffer_).To(&r)) return Nothing<int>();
    if (r < 0) return Just(r);
    uv_process_options_.cwd = cwd_buffer_;
  }",22,,771,2,,void
278887,BLOCK,-1,,<empty>,53,,772,2,,void
278894,BLOCK,-1,,<empty>,16,,773,2,,void
278922,BLOCK,-1,,<empty>,7,,779,1,,void
278924,BLOCK,-1,,"{
    if (!CopyJsStringArray(js_env_pairs, &env_buffer_).To(&r))
      return Nothing<int>();
    if (r < 0) return Just(r);

    uv_process_options_.env = reinterpret_cast<char**>(env_buffer_);
  }",28,,779,2,,void
278936,BLOCK,-1,,<empty>,7,,781,2,,void
278943,BLOCK,-1,,<empty>,16,,782,2,,void
278973,BLOCK,-1,,<empty>,7,,788,1,,void
278975,BLOCK,-1,,"{
    CHECK(js_uid->IsInt32());
    const int32_t uid = js_uid.As<Int32>()->Value();
    uv_process_options_.uid = static_cast<uv_uid_t>(uid);
    uv_process_options_.flags |= UV_PROCESS_SETUID;
  }",22,,788,2,,void
279022,BLOCK,-1,,<empty>,7,,797,1,,void
279024,BLOCK,-1,,"{
    CHECK(js_gid->IsInt32());
    const int32_t gid = js_gid.As<Int32>()->Value();
    uv_process_options_.gid = static_cast<uv_gid_t>(gid);
    uv_process_options_.flags |= UV_PROCESS_SETGID;
  }",22,,797,2,,void
279076,BLOCK,-1,,<empty>,5,,807,2,,void
279106,BLOCK,-1,,<empty>,5,,812,2,,void
279117,BLOCK,-1,,<empty>,5,,815,2,,void
279147,BLOCK,-1,,<empty>,5,,822,2,,void
279172,BLOCK,-1,,<empty>,7,,826,1,,void
279174,BLOCK,-1,,"{
    CHECK(js_timeout->IsNumber());
    int64_t timeout = js_timeout->IntegerValue(context).FromJust();
    timeout_ = static_cast<uint64_t>(timeout);
  }",26,,826,2,,void
279215,BLOCK,-1,,<empty>,7,,834,1,,void
279217,BLOCK,-1,,"{
    CHECK(js_max_buffer->IsNumber());
    max_buffer_ = js_max_buffer->NumberValue(context).FromJust();
  }",29,,834,2,,void
279252,BLOCK,-1,,<empty>,7,,841,1,,void
279254,BLOCK,-1,,"{
    CHECK(js_kill_signal->IsInt32());
    kill_signal_ = js_kill_signal.As<Int32>()->Value();
  }",30,,841,2,,void
279295,BLOCK,-1,,<empty>,14,,849,2,,void
279306,BLOCK,-1,,"{
  HandleScope scope(env()->isolate());
  Local<Array> js_stdio_options;

  if (!js_value->IsArray())
    return UV_EINVAL;

  Local<Context> context = env()->context();
  js_stdio_options = js_value.As<Array>();

  stdio_count_ = js_stdio_options->Length();
  uv_stdio_containers_ = new uv_stdio_container_t[stdio_count_];

  stdio_pipes_.clear();
  stdio_pipes_.resize(stdio_count_);
  stdio_pipes_initialized_ = true;

  for (uint32_t i = 0; i < stdio_count_; i++) {
    Local<Value> js_stdio_option =
        js_stdio_options->Get(context, i).ToLocalChecked();

    if (!js_stdio_option->IsObject())
      return UV_EINVAL;

    int r = ParseStdioOption(i, js_stdio_option.As<Object>());
    if (r < 0)
      return r;
  }

  uv_process_options_.stdio = uv_stdio_containers_;
  uv_process_options_.stdio_count = stdio_count_;

  return 0;
}",65,,855,2,,void
279324,BLOCK,-1,,<empty>,5,,860,2,,void
279366,BLOCK,-1,,<empty>,3,,872,1,,void
279376,BLOCK,4,,"{
    Local<Value> js_stdio_option =
        js_stdio_options->Get(context, i).ToLocalChecked();

    if (!js_stdio_option->IsObject())
      return UV_EINVAL;

    int r = ParseStdioOption(i, js_stdio_option.As<Object>());
    if (r < 0)
      return r;
  }",47,,872,4,,void
279398,BLOCK,-1,,<empty>,7,,877,2,,void
279414,BLOCK,-1,,<empty>,7,,881,2,,void
279434,BLOCK,-1,,"{
  Local<Context> context = env()->context();
  Local<Value> js_type =
      js_stdio_option->Get(context, env()->type_string()).ToLocalChecked();

  if (js_type->StrictEquals(env()->ignore_string())) {
    return AddStdioIgnore(child_fd);

  } else if (js_type->StrictEquals(env()->pipe_string())) {
    Isolate* isolate = env()->isolate();
    Local<String> rs = env()->readable_string();
    Local<String> ws = env()->writable_string();

    bool readable = js_stdio_option->Get(context, rs)
        .ToLocalChecked()->BooleanValue(isolate);
    bool writable =
        js_stdio_option->Get(context, ws)
        .ToLocalChecked()->BooleanValue(isolate);

    uv_buf_t buf = uv_buf_init(nullptr, 0);

    if (readable) {
      Local<Value> input =
          js_stdio_option->Get(context, env()->input_string()).ToLocalChecked();
      if (Buffer::HasInstance(input)) {
        buf = uv_buf_init(Buffer::Data(input),
                          static_cast<unsigned int>(Buffer::Length(input)));
 ...",72,,892,3,,void
279472,BLOCK,-1,,"{
    return AddStdioIgnore(child_fd);

  }",54,,897,2,,void
279477,BLOCK,-1,,<empty>,10,,900,1,,void
279487,BLOCK,-1,,"{
    Isolate* isolate = env()->isolate();
    Local<String> rs = env()->readable_string();
    Local<String> ws = env()->writable_string();

    bool readable = js_stdio_option->Get(context, rs)
        .ToLocalChecked()->BooleanValue(isolate);
    bool writable =
        js_stdio_option->Get(context, ws)
        .ToLocalChecked()->BooleanValue(isolate);

    uv_buf_t buf = uv_buf_init(nullptr, 0);

    if (readable) {
      Local<Value> input =
          js_stdio_option->Get(context, env()->input_string()).ToLocalChecked();
      if (Buffer::HasInstance(input)) {
        buf = uv_buf_init(Buffer::Data(input),
                          static_cast<unsigned int>(Buffer::Length(input)));
      } else if (!input->IsUndefined() && !input->IsNull()) {
        // Strings, numbers etc. are currently unsupported. It's not possible
        // to create a buffer for them here because there is no way to free
        // them afterwards.
        return UV_EINVAL;
      }
    }

    return AddSt...",59,,900,2,,void
279555,BLOCK,-1,,"{
      Local<Value> input =
          js_stdio_option->Get(context, env()->input_string()).ToLocalChecked();
      if (Buffer::HasInstance(input)) {
        buf = uv_buf_init(Buffer::Data(input),
                          static_cast<unsigned int>(Buffer::Length(input)));
      } else if (!input->IsUndefined() && !input->IsNull()) {
        // Strings, numbers etc. are currently unsupported. It's not possible
        // to create a buffer for them here because there is no way to free
        // them afterwards.
        return UV_EINVAL;
      }
    }",19,,913,2,,void
279575,BLOCK,-1,,<empty>,11,,916,1,,void
279577,BLOCK,-1,,"{
        buf = uv_buf_init(Buffer::Data(input),
                          static_cast<unsigned int>(Buffer::Length(input)));
      }",39,,916,2,,void
279594,BLOCK,-1,,<empty>,14,,919,1,,void
279607,BLOCK,-1,,"{
        // Strings, numbers etc. are currently unsupported. It's not possible
        // to create a buffer for them here because there is no way to free
        // them afterwards.
        return UV_EINVAL;
      }",61,,919,2,,void
279617,BLOCK,-1,,<empty>,10,,929,1,,void
279636,BLOCK,-1,,"{
    int inherit_fd = js_stdio_option->Get(context, env()->fd_string())
        .ToLocalChecked()->Int32Value(context).FromJust();
    return AddStdioInheritFD(child_fd, inherit_fd);

  }",57,,930,2,,void
279664,BLOCK,-1,,"{
    UNREACHABLE(""invalid child stdio type"");
  }",10,,935,1,,void
279671,BLOCK,-1,,"{
  CHECK_LT(child_fd, stdio_count_);
  CHECK(!stdio_pipes_[child_fd]);

  uv_stdio_containers_[child_fd].flags = UV_IGNORE;

  return 0;
}",58,,941,2,,void
279696,BLOCK,-1,,"{
  CHECK_LT(child_fd, stdio_count_);
  CHECK(!stdio_pipes_[child_fd]);

  std::unique_ptr<SyncProcessStdioPipe> h(
      new SyncProcessStdioPipe(this, readable, writable, input_buffer));

  int r = h->Initialize(uv_loop_);
  if (r < 0) {
    h.reset();
    return r;
  }

  uv_stdio_containers_[child_fd].flags = h->uv_flags();
  uv_stdio_containers_[child_fd].data.stream = h->uv_stream();

  stdio_pipes_[child_fd] = std::move(h);

  return 0;
}",60,,954,5,,void
279730,BLOCK,-1,,"{
    h.reset();
    return r;
  }",14,,962,2,,void
279775,BLOCK,-1,,"{
  CHECK_LT(child_fd, stdio_count_);
  CHECK(!stdio_pipes_[child_fd]);

  uv_stdio_containers_[child_fd].flags = UV_INHERIT_FD;
  uv_stdio_containers_[child_fd].data.fd = inherit_fd;

  return 0;
}",77,,976,3,,void
279806,BLOCK,-1,,"{
  return !value->IsUndefined() && !value->IsNull();
}",51,,987,2,,void
279824,BLOCK,-1,,"{
  Isolate* isolate = env()->isolate();
  Local<String> js_string;
  size_t size, written;
  char* buffer;

  if (js_value->IsString())
    js_string = js_value.As<String>();
  else if (!js_value->ToString(env()->isolate()->GetCurrentContext())
                .ToLocal(&js_string))
    return Nothing<int>();

  // Include space for null terminator byte.
  if (!StringBytes::StorageSize(isolate, js_string, UTF8).To(&size))
    return Nothing<int>();
  size += 1;

  buffer = new char[size];

  written = StringBytes::Write(isolate, buffer, -1, js_string, UTF8);
  buffer[written] = '\0';

  *target = buffer;
  return Just(0);
}",65,,992,3,,void
279845,BLOCK,-1,,<empty>,5,,999,2,,void
279853,BLOCK,-1,,<empty>,8,,1000,1,,void
279872,BLOCK,-1,,<empty>,5,,1002,2,,void
279889,BLOCK,-1,,<empty>,5,,1006,2,,void
279928,BLOCK,-1,,"{
  Isolate* isolate = env()->isolate();
  Local<Array> js_array;
  uint32_t length;
  size_t list_size, data_size, data_offset;
  char** list;
  char* buffer;

  if (!js_value->IsArray()) return Just<int>(UV_EINVAL);

  Local<Context> context = env()->context();
  js_array = js_value.As<Array>()->Clone().As<Array>();
  length = js_array->Length();
  data_size = 0;

  // Index has a pointer to every string element, plus one more for a final
  // null pointer.
  list_size = (length + 1) * sizeof *list;

  // Convert all array elements to string. Modify the js object itself if
  // needed - it's okay since we cloned the original object. Also compute the
  // length of all strings, including room for a null terminator after every
  // string. Align strings to cache lines.
  for (uint32_t i = 0; i < length; i++) {
    auto value = js_array->Get(context, i).ToLocalChecked();

    if (!value->IsString()) {
      Local<String> string;
      if (!value->ToString(env()->isolate()->GetCurrent...",64,,1019,3,,void
279953,BLOCK,-1,,<empty>,29,,1027,2,,void
279998,BLOCK,-1,,<empty>,3,,1042,1,,void
280008,BLOCK,4,,"{
    auto value = js_array->Get(context, i).ToLocalChecked();

    if (!value->IsString()) {
      Local<String> string;
      if (!value->ToString(env()->isolate()->GetCurrentContext())
               .ToLocal(&string))
        return Nothing<int>();
      js_array
          ->Set(context,
                i,
                string)
          .Check();
    }

    Maybe<size_t> maybe_size = StringBytes::StorageSize(isolate, value, UTF8);
    if (maybe_size.IsNothing()) return Nothing<int>();
    data_size += maybe_size.FromJust() + 1;
    data_size = RoundUp(data_size, sizeof(void*));
  }",41,,1042,4,,void
280027,BLOCK,-1,,"{
      Local<String> string;
      if (!value->ToString(env()->isolate()->GetCurrentContext())
               .ToLocal(&string))
        return Nothing<int>();
      js_array
          ->Set(context,
                i,
                string)
          .Check();
    }",29,,1045,2,,void
280051,BLOCK,-1,,<empty>,9,,1049,2,,void
280082,BLOCK,-1,,<empty>,33,,1058,2,,void
280112,BLOCK,-1,,<empty>,3,,1068,1,,void
280122,BLOCK,4,,"{
    list[i] = buffer + data_offset;
    auto value = js_array->Get(context, i).ToLocalChecked();
    data_offset += StringBytes::Write(isolate,
                                      buffer + data_offset,
                                      -1,
                                      value,
                                      UTF8);
    buffer[data_offset++] = '\0';
    data_offset = RoundUp(data_offset, sizeof(void*));
  }",41,,1068,4,,void
280186,BLOCK,-1,,"{
  SyncProcessRunner* self = reinterpret_cast<SyncProcessRunner*>(handle->data);
  uv_close(reinterpret_cast<uv_handle_t*>(handle), nullptr);
  self->OnExit(exit_status, term_signal);
}",55,,1089,4,,void
280210,BLOCK,-1,,"{
  SyncProcessRunner* self = reinterpret_cast<SyncProcessRunner*>(handle->data);
  self->OnKillTimerTimeout();
}",63,,1096,2,,void
280227,BLOCK,-1,,"{
  // No-op.
}",69,,1102,2,,void
280241,BLOCK,-1,,<empty>,1,,1,1,,ANY
280256,BLOCK,-1,,<empty>,1,,1,1,,ANY
280287,BLOCK,-1,,<empty>,1,,1,1,,ANY
280291,BLOCK,-1,,"{
  Environment* env = stream_env();

  v8::HandleScope handle_scope(env->isolate());

  if (req_wrap_obj.IsEmpty()) {
    if (!env->shutdown_wrap_template()
             ->NewInstance(env->context())
             .ToLocal(&req_wrap_obj)) {
      return UV_EBUSY;
    }
    StreamReq::ResetObject(req_wrap_obj);
  }

  BaseObjectPtr<AsyncWrap> req_wrap_ptr;
  AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(GetAsyncWrap());
  ShutdownWrap* req_wrap = CreateShutdownWrap(req_wrap_obj);
  if (req_wrap != nullptr) req_wrap_ptr.reset(req_wrap->GetAsyncWrap());
  int err = DoShutdown(req_wrap);

  if (err != 0 && req_wrap != nullptr) {
    req_wrap->Dispose();
  }

  const char* msg = Error();
  if (msg != nullptr) {
    if (req_wrap_obj
            ->Set(env->context(),
                  env->error_string(),
                  OneByteString(env->isolate(), msg))
            .IsNothing()) {
      return UV_EBUSY;
    }
    ClearError();
  }

  return err;
}",62,,43,2,,void
280307,BLOCK,-1,,"{
    if (!env->shutdown_wrap_template()
             ->NewInstance(env->context())
             .ToLocal(&req_wrap_obj)) {
      return UV_EBUSY;
    }
    StreamReq::ResetObject(req_wrap_obj);
  }",31,,48,2,,void
280326,BLOCK,-1,,"{
      return UV_EBUSY;
    }",39,,51,2,,void
280351,BLOCK,-1,,<empty>,28,,60,2,,void
280373,BLOCK,-1,,"{
    req_wrap->Dispose();
  }",40,,63,2,,void
280386,BLOCK,-1,,"{
    if (req_wrap_obj
            ->Set(env->context(),
                  env->error_string(),
                  OneByteString(env->isolate(), msg))
            .IsNothing()) {
      return UV_EBUSY;
    }
    ClearError();
  }",23,,68,2,,void
280409,BLOCK,-1,,"{
      return UV_EBUSY;
    }",27,,73,2,,void
280423,BLOCK,-1,,"{
  Environment* env = stream_env();
  int err;

  size_t total_bytes = 0;
  for (size_t i = 0; i < count; ++i) total_bytes += bufs[i].len;
  bytes_written_ += total_bytes;

  if (send_handle == nullptr && !skip_try_write) {
    err = DoTryWrite(&bufs, &count);
    if (err != 0 || count == 0) {
      return StreamWriteResult{false, err, nullptr, total_bytes, {}};
    }
  }

  v8::HandleScope handle_scope(env->isolate());

  if (req_wrap_obj.IsEmpty()) {
    if (!env->write_wrap_template()
             ->NewInstance(env->context())
             .ToLocal(&req_wrap_obj)) {
      return StreamWriteResult{false, UV_EBUSY, nullptr, 0, {}};
    }
    StreamReq::ResetObject(req_wrap_obj);
  }

  AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(GetAsyncWrap());
  WriteWrap* req_wrap = CreateWriteWrap(req_wrap_obj);
  BaseObjectPtr<AsyncWrap> req_wrap_ptr(req_wrap->GetAsyncWrap());

  err = DoWrite(req_wrap, bufs, count, send_handle);
  bool async = err == 0;

  if (!async) {
    req_wrap...",58,,86,6,,void
280434,BLOCK,-1,,<empty>,3,,91,1,,void
280461,BLOCK,-1,,"{
    err = DoTryWrite(&bufs, &count);
    if (err != 0 || count == 0) {
      return StreamWriteResult{false, err, nullptr, total_bytes, {}};
    }
  }",50,,94,2,,void
280477,BLOCK,-1,,"{
      return StreamWriteResult{false, err, nullptr, total_bytes, {}};
    }",33,,96,2,,void
280497,BLOCK,-1,,"{
    if (!env->write_wrap_template()
             ->NewInstance(env->context())
             .ToLocal(&req_wrap_obj)) {
      return StreamWriteResult{false, UV_EBUSY, nullptr, 0, {}};
    }
    StreamReq::ResetObject(req_wrap_obj);
  }",31,,103,2,,void
280516,BLOCK,-1,,"{
      return StreamWriteResult{false, UV_EBUSY, nullptr, 0, {}};
    }",39,,106,2,,void
280563,BLOCK,-1,,"{
    req_wrap->Dispose();
    req_wrap = nullptr;
  }",15,,119,2,,void
280579,BLOCK,-1,,"{
    if (req_wrap_obj
            ->Set(env->context(),
                  env->error_string(),
                  OneByteString(env->isolate(), msg))
            .IsNothing()) {
      return StreamWriteResult{false, UV_EBUSY, nullptr, 0, {}};
    }
    ClearError();
  }",23,,125,2,,void
280602,BLOCK,-1,,"{
      return StreamWriteResult{false, UV_EBUSY, nullptr, 0, {}};
    }",27,,130,2,,void
280628,BLOCK,-1,,"{
  return ReadStart();
}",70,,150,2,,void
280635,BLOCK,-1,,"{
  return ReadStop();
}",69,,155,2,,void
280642,BLOCK,-1,,"{
  CHECK(Buffer::HasInstance(args[0]));

  uv_buf_t buf = uv_buf_init(Buffer::Data(args[0]), Buffer::Length(args[0]));
  PushStreamListener(new CustomBufferJSListener(buf));
  return 0;
}",72,,159,2,,void
280679,BLOCK,-1,,"{
  CHECK(args[0]->IsObject());
  Local<Object> req_wrap_obj = args[0].As<Object>();

  return Shutdown(req_wrap_obj);
}",67,,167,2,,void
280706,BLOCK,-1,,"{
  env_->stream_base_state()[kBytesWritten] = res.bytes;
  env_->stream_base_state()[kLastWriteWasAsync] = res.async;
}",63,,174,2,,void
280731,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();

  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsArray());

  Local<Object> req_wrap_obj = args[0].As<Object>();
  Local<Array> chunks = args[1].As<Array>();
  bool all_buffers = args[2]->IsTrue();

  size_t count;
  if (all_buffers)
    count = chunks->Length();
  else
    count = chunks->Length() >> 1;

  MaybeStackBuffer<uv_buf_t, 16> bufs(count);

  size_t storage_size = 0;
  size_t offset;

  if (!all_buffers) {
    // Determine storage size first
    for (size_t i = 0; i < count; i++) {
      Local<Value> chunk;
      if (!chunks->Get(context, i * 2).ToLocal(&chunk))
        return -1;

      if (Buffer::HasInstance(chunk))
        continue;
        // Buffer chunk, no additional storage required

      // String chunk
      Local<String> string;
      if (!chunk->ToString(context).ToLocal(&string))
        return -1;
      Local<Value> next_ch...",65,,179,2,,void
280807,BLOCK,-1,,<empty>,5,,193,2,,void
280815,BLOCK,-1,,<empty>,5,,195,1,,void
280840,BLOCK,-1,,"{
    // Determine storage size first
    for (size_t i = 0; i < count; i++) {
      Local<Value> chunk;
      if (!chunks->Get(context, i * 2).ToLocal(&chunk))
        return -1;

      if (Buffer::HasInstance(chunk))
        continue;
        // Buffer chunk, no additional storage required

      // String chunk
      Local<String> string;
      if (!chunk->ToString(context).ToLocal(&string))
        return -1;
      Local<Value> next_chunk;
      if (!chunks->Get(context, i * 2 + 1).ToLocal(&next_chunk))
        return -1;
      enum encoding encoding = ParseEncoding(isolate, next_chunk);
      size_t chunk_size;
      if ((encoding == UTF8 &&
             string->Length() > 65535 &&
             !StringBytes::Size(isolate, string, encoding).To(&chunk_size)) ||
              !StringBytes::StorageSize(isolate, string, encoding)
                  .To(&chunk_size)) {
        return -1;
      }
      storage_size += chunk_size;
    }

    if (storage_size > INT_MAX)
      return UV_E...",21,,202,2,,void
280842,BLOCK,-1,,<empty>,5,,204,1,,void
280852,BLOCK,4,,"{
      Local<Value> chunk;
      if (!chunks->Get(context, i * 2).ToLocal(&chunk))
        return -1;

      if (Buffer::HasInstance(chunk))
        continue;
        // Buffer chunk, no additional storage required

      // String chunk
      Local<String> string;
      if (!chunk->ToString(context).ToLocal(&string))
        return -1;
      Local<Value> next_chunk;
      if (!chunks->Get(context, i * 2 + 1).ToLocal(&next_chunk))
        return -1;
      enum encoding encoding = ParseEncoding(isolate, next_chunk);
      size_t chunk_size;
      if ((encoding == UTF8 &&
             string->Length() > 65535 &&
             !StringBytes::Size(isolate, string, encoding).To(&chunk_size)) ||
              !StringBytes::StorageSize(isolate, string, encoding)
                  .To(&chunk_size)) {
        return -1;
      }
      storage_size += chunk_size;
    }",40,,204,4,,void
280873,BLOCK,-1,,<empty>,9,,207,2,,void
280878,BLOCK,-1,,<empty>,11,,209,1,,void
280880,BLOCK,-1,,<empty>,9,,210,2,,void
280899,BLOCK,-1,,<empty>,9,,216,2,,void
280925,BLOCK,-1,,<empty>,9,,219,2,,void
280975,BLOCK,-1,,"{
        return -1;
      }",37,,226,2,,void
280986,BLOCK,-1,,<empty>,7,,233,2,,void
280990,BLOCK,-1,,"{
    for (size_t i = 0; i < count; i++) {
      Local<Value> chunk;
      if (!chunks->Get(context, i).ToLocal(&chunk))
        return -1;
      bufs[i].base = Buffer::Data(chunk);
      bufs[i].len = Buffer::Length(chunk);
    }
  }",10,,234,1,,void
280992,BLOCK,-1,,<empty>,5,,235,1,,void
281002,BLOCK,4,,"{
      Local<Value> chunk;
      if (!chunks->Get(context, i).ToLocal(&chunk))
        return -1;
      bufs[i].base = Buffer::Data(chunk);
      bufs[i].len = Buffer::Length(chunk);
    }",40,,235,4,,void
281021,BLOCK,-1,,<empty>,9,,238,2,,void
281058,BLOCK,-1,,"{
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(isolate, storage_size);
  }",25,,245,2,,void
281079,BLOCK,-1,,"{
    for (size_t i = 0; i < count; i++) {
      Local<Value> chunk;
      if (!chunks->Get(context, i * 2).ToLocal(&chunk))
        return -1;

      // Write buffer
      if (Buffer::HasInstance(chunk)) {
        bufs[i].base = Buffer::Data(chunk);
        bufs[i].len = Buffer::Length(chunk);
        continue;
      }

      // Write string
      CHECK_LE(offset, storage_size);
      char* str_storage =
          static_cast<char*>(bs ? bs->Data() : nullptr) + offset;
      size_t str_size = (bs ? bs->ByteLength() : 0) - offset;

      Local<String> string;
      if (!chunk->ToString(context).ToLocal(&string))
        return -1;
      Local<Value> next_chunk;
      if (!chunks->Get(context, i * 2 + 1).ToLocal(&next_chunk))
        return -1;
      enum encoding encoding = ParseEncoding(isolate, next_chunk);
      str_size = StringBytes::Write(isolate,
                                    str_storage,
                                    str_size,
                                    ...",21,,251,2,,void
281081,BLOCK,-1,,<empty>,5,,252,1,,void
281091,BLOCK,4,,"{
      Local<Value> chunk;
      if (!chunks->Get(context, i * 2).ToLocal(&chunk))
        return -1;

      // Write buffer
      if (Buffer::HasInstance(chunk)) {
        bufs[i].base = Buffer::Data(chunk);
        bufs[i].len = Buffer::Length(chunk);
        continue;
      }

      // Write string
      CHECK_LE(offset, storage_size);
      char* str_storage =
          static_cast<char*>(bs ? bs->Data() : nullptr) + offset;
      size_t str_size = (bs ? bs->ByteLength() : 0) - offset;

      Local<String> string;
      if (!chunk->ToString(context).ToLocal(&string))
        return -1;
      Local<Value> next_chunk;
      if (!chunks->Get(context, i * 2 + 1).ToLocal(&next_chunk))
        return -1;
      enum encoding encoding = ParseEncoding(isolate, next_chunk);
      str_size = StringBytes::Write(isolate,
                                    str_storage,
                                    str_size,
                                    string,
                                 ...",40,,252,4,,void
281112,BLOCK,-1,,<empty>,9,,255,2,,void
281117,BLOCK,-1,,<empty>,11,,258,1,,void
281119,BLOCK,-1,,"{
        bufs[i].base = Buffer::Data(chunk);
        bufs[i].len = Buffer::Length(chunk);
        continue;
      }",39,,258,2,,void
281189,BLOCK,-1,,<empty>,9,,272,2,,void
281215,BLOCK,-1,,<empty>,9,,275,2,,void
281274,BLOCK,-1,,<empty>,5,,291,2,,void
281294,BLOCK,-1,,"{
  CHECK(args[0]->IsObject());

  Environment* env = Environment::GetCurrent(args);

  if (!args[1]->IsUint8Array()) {
    node::THROW_ERR_INVALID_ARG_TYPE(env, ""Second argument must be a buffer"");
    return 0;
  }

  Local<Object> req_wrap_obj = args[0].As<Object>();
  uv_buf_t buf;
  buf.base = Buffer::Data(args[1]);
  buf.len = Buffer::Length(args[1]);

  uv_stream_t* send_handle = nullptr;

  if (args[2]->IsObject() && IsIPCPipe()) {
    Local<Object> send_handle_obj = args[2].As<Object>();

    HandleWrap* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, send_handle_obj, UV_EINVAL);
    send_handle = reinterpret_cast<uv_stream_t*>(wrap->GetHandle());
    // Reference LibuvStreamWrap instance to prevent it from being garbage
    // collected before `AfterWrite` is called.
    if (req_wrap_obj->Set(env->context(),
                          env->handle_string(),
                          send_handle_obj).IsNothing()) {
      return -1;
    }
  }

  StreamWriteResult res = Write(&buf, 1,...",70,,296,2,,void
281318,BLOCK,-1,,"{
    node::THROW_ERR_INVALID_ARG_TYPE(env, ""Second argument must be a buffer"");
    return 0;
  }",33,,301,2,,void
281375,BLOCK,-1,,"{
    Local<Object> send_handle_obj = args[2].As<Object>();

    HandleWrap* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, send_handle_obj, UV_EINVAL);
    send_handle = reinterpret_cast<uv_stream_t*>(wrap->GetHandle());
    // Reference LibuvStreamWrap instance to prevent it from being garbage
    // collected before `AfterWrite` is called.
    if (req_wrap_obj->Set(env->context(),
                          env->handle_string(),
                          send_handle_obj).IsNothing()) {
      return -1;
    }
  }",43,,313,2,,void
281419,BLOCK,-1,,"{
      return -1;
    }",57,,323,2,,void
281442,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsString());

  Local<Object> req_wrap_obj = args[0].As<Object>();
  Local<String> string = args[1].As<String>();
  Local<Object> send_handle_obj;
  if (args[2]->IsObject())
    send_handle_obj = args[2].As<Object>();

  // Compute the size of the storage that the string will be flattened into.
  // For UTF8 strings that are very long, go ahead and take the hit for
  // computing their actual size, rather than tripling the storage.
  size_t storage_size;
  if ((enc == UTF8 &&
         string->Length() > 65535 &&
         !StringBytes::Size(isolate, string, enc).To(&storage_size)) ||
          !StringBytes::StorageSize(isolate, string, enc).To(&storage_size)) {
    return -1;
  }

  if (storage_size > INT_MAX)
    return UV_ENOBUFS;

  // Try writing immediately if write size isn't too big
  char stack_storage[16384];  // 16kb
  size_t data_size;
 ...",70,,336,2,,void
281508,BLOCK,-1,,<empty>,5,,346,2,,void
281557,BLOCK,-1,,"{
    return -1;
  }",78,,355,2,,void
281565,BLOCK,-1,,<empty>,5,,360,2,,void
281592,BLOCK,-1,,"{
    data_size = StringBytes::Write(isolate,
                                   stack_storage,
                                   storage_size,
                                   string,
                                   enc);
    buf = uv_buf_init(stack_storage, data_size);

    uv_buf_t* bufs = &buf;
    size_t count = 1;
    const int err = DoTryWrite(&bufs, &count);
    // Keep track of the bytes written here, because we're taking a shortcut
    // by using `DoTryWrite()` directly instead of using the utilities
    // provided by `Write()`.
    synchronously_written = count == 0 ? data_size : data_size - buf.len;
    bytes_written_ += synchronously_written;

    // Immediate failure or success
    if (err != 0 || count == 0) {
      SetWriteResult(StreamWriteResult { false, err, nullptr, data_size, {} });
      return err;
    }

    // Partial write
    CHECK_EQ(count, 1);
  }",18,,370,2,,void
281649,BLOCK,-1,,"{
      SetWriteResult(StreamWriteResult { false, err, nullptr, data_size, {} });
      return err;
    }",33,,388,2,,void
281672,BLOCK,-1,,"{
    // Copy partial data
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(isolate, buf.len);
    memcpy(static_cast<char*>(bs->Data()), buf.base, buf.len);
    data_size = buf.len;
  }",18,,399,2,,void
281708,BLOCK,-1,,"{
    // Write it
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(isolate, storage_size);
    data_size = StringBytes::Write(isolate,
                                   static_cast<char*>(bs->Data()),
                                   storage_size,
                                   string,
                                   enc);
  }",10,,405,1,,void
281764,BLOCK,-1,,"{
    HandleWrap* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, send_handle_obj, UV_EINVAL);
    send_handle = reinterpret_cast<uv_stream_t*>(wrap->GetHandle());
    // Reference LibuvStreamWrap instance to prevent it from being garbage
    // collected before `AfterWrite` is called.
    if (req_wrap_obj->Set(env->context(),
                          env->handle_string(),
                          send_handle_obj).IsNothing()) {
      return -1;
    }
  }",50,,422,2,,void
281796,BLOCK,-1,,"{
      return -1;
    }",57,,430,2,,void
281823,BLOCK,-1,,<empty>,5,,440,2,,void
281846,BLOCK,-1,,"{
  Environment* env = env_;

  DCHECK_EQ(static_cast<int32_t>(nread), nread);
  DCHECK_LE(offset, INT32_MAX);

  if (checks == DONT_SKIP_NREAD_CHECKS) {
    if (ab.IsEmpty()) {
      DCHECK_EQ(offset, 0);
      DCHECK_LE(nread, 0);
    } else {
      DCHECK_GE(nread, 0);
    }
  }

  env->stream_base_state()[kReadBytesOrError] = static_cast<int32_t>(nread);
  env->stream_base_state()[kArrayBufferOffset] = offset;

  Local<Value> argv[] = {
    ab.IsEmpty() ? Undefined(env->isolate()).As<Value>() : ab.As<Value>()
  };

  AsyncWrap* wrap = GetAsyncWrap();
  CHECK_NOT_NULL(wrap);
  Local<Value> onread = wrap->object()->GetInternalField(
      StreamBase::kOnReadFunctionField);
  CHECK(onread->IsFunction());
  return wrap->MakeCallback(onread.As<Function>(), arraysize(argv), argv);
}",77,,449,5,,void
281863,BLOCK,-1,,"{
    if (ab.IsEmpty()) {
      DCHECK_EQ(offset, 0);
      DCHECK_LE(nread, 0);
    } else {
      DCHECK_GE(nread, 0);
    }
  }",41,,455,2,,void
281869,BLOCK,-1,,"{
      DCHECK_EQ(offset, 0);
      DCHECK_LE(nread, 0);
    }",23,,456,2,,void
281877,BLOCK,-1,,"{
      DCHECK_GE(nread, 0);
    }",12,,459,1,,void
281962,BLOCK,-1,,"{
  return false;
}",30,,480,1,,void
281968,BLOCK,-1,,"{
  return -1;
}",25,,485,1,,void
281975,BLOCK,-1,,"{
  return GetAsyncWrap()->object();
}",39,,490,1,,void
281990,BLOCK,-1,,"{
  Local<FunctionTemplate> templ =
      NewFunctionTemplate(isolate,
                          stream_method,
                          signature,
                          ConstructorBehavior::kThrow,
                          SideEffectType::kHasNoSideEffect);
  t->PrototypeTemplate()->SetAccessorProperty(
      string, templ, Local<FunctionTemplate>(), attributes);
}",50,,499,7,,void
282023,BLOCK,-1,,"{
  AddMethods(env->isolate_data(), t);
}",74,,510,3,,void
282035,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();
  HandleScope scope(isolate);

  enum PropertyAttribute attributes =
      static_cast<PropertyAttribute>(ReadOnly | DontDelete | DontEnum);
  Local<Signature> sig = Signature::New(isolate, t);

  AddMethod(isolate, sig, attributes, t, GetFD, isolate_data->fd_string());
  AddMethod(isolate,
            sig,
            attributes,
            t,
            GetExternal,
            isolate_data->external_stream_string());
  AddMethod(isolate,
            sig,
            attributes,
            t,
            GetBytesRead,
            isolate_data->bytes_read_string());
  AddMethod(isolate,
            sig,
            attributes,
            t,
            GetBytesWritten,
            isolate_data->bytes_written_string());
  SetProtoMethod(isolate, t, ""readStart"", JSMethod<&StreamBase::ReadStartJS>);
  SetProtoMethod(isolate, t, ""readStop"", JSMethod<&StreamBase::ReadStopJS>);
  SetProtoMethod(isolate, t, ""shutdown"", JSMethod<&StreamBa...",56,,515,3,,void
282190,BLOCK,-1,,"{
  // This function is called by a single thread during start up, so it is safe
  // to use a local static variable here.
  static bool is_registered = false;
  if (is_registered) return;
  registry->Register(GetFD);
  registry->Register(GetExternal);
  registry->Register(GetBytesRead);
  registry->Register(GetBytesWritten);
  registry->Register(JSMethod<&StreamBase::ReadStartJS>);
  registry->Register(JSMethod<&StreamBase::ReadStopJS>);
  registry->Register(JSMethod<&StreamBase::Shutdown>);
  registry->Register(JSMethod<&StreamBase::UseUserBuffer>);
  registry->Register(JSMethod<&StreamBase::Writev>);
  registry->Register(JSMethod<&StreamBase::WriteBuffer>);
  registry->Register(JSMethod<&StreamBase::WriteString<ASCII>>);
  registry->Register(JSMethod<&StreamBase::WriteString<UTF8>>);
  registry->Register(JSMethod<&StreamBase::WriteString<UCS2>>);
  registry->Register(JSMethod<&StreamBase::WriteString<LATIN1>>);
  registry->Register(
      BaseObject::InternalFieldGet<StreamBase::...",42,,571,2,,void
282197,BLOCK,-1,,<empty>,22,,575,2,,void
282290,BLOCK,-1,,"{
  // Mimic implementation of StreamBase::GetFD() and UDPWrap::GetFD().
  StreamBase* wrap = StreamBase::FromObject(args.This().As<Object>());
  if (wrap == nullptr) return args.GetReturnValue().Set(UV_EINVAL);

  if (!wrap->IsAlive()) return args.GetReturnValue().Set(UV_EINVAL);

  args.GetReturnValue().Set(wrap->GetFD());
}",65,,598,2,,void
282309,BLOCK,-1,,<empty>,24,,601,2,,void
282325,BLOCK,-1,,<empty>,25,,603,2,,void
282350,BLOCK,-1,,"{
  StreamBase* wrap = StreamBase::FromObject(args.This().As<Object>());
  if (wrap == nullptr) return args.GetReturnValue().Set(0);

  // uint64_t -> double. 53bits is enough for all real cases.
  args.GetReturnValue().Set(static_cast<double>(wrap->bytes_read_));
}",72,,608,2,,void
282369,BLOCK,-1,,<empty>,24,,610,2,,void
282395,BLOCK,-1,,"{
  StreamBase* wrap = StreamBase::FromObject(args.This().As<Object>());
  if (wrap == nullptr) return args.GetReturnValue().Set(0);

  // uint64_t -> double. 53bits is enough for all real cases.
  args.GetReturnValue().Set(static_cast<double>(wrap->bytes_written_));
}",75,,616,2,,void
282414,BLOCK,-1,,<empty>,24,,618,2,,void
282440,BLOCK,-1,,"{
  StreamBase* wrap = StreamBase::FromObject(args.This().As<Object>());
  if (wrap == nullptr) return;

  Local<External> ext = External::New(args.GetIsolate(), wrap);
  args.GetReturnValue().Set(ext);
}",71,,624,2,,void
282459,BLOCK,-1,,<empty>,24,,626,2,,void
282488,BLOCK,-1,,"{
  StreamBase* wrap = StreamBase::FromObject(args.Holder().As<Object>());
  if (wrap == nullptr) return;

  if (!wrap->IsAlive()) return args.GetReturnValue().Set(UV_EINVAL);

  AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(wrap->GetAsyncWrap());
  args.GetReturnValue().Set((wrap->*Method)(args));
}",68,,633,2,,void
282507,BLOCK,-1,,<empty>,24,,635,2,,void
282515,BLOCK,-1,,<empty>,25,,637,2,,void
282548,BLOCK,-1,,"{
  // No TryWrite by default
  return 0;
}",64,,643,3,,void
282554,BLOCK,-1,,"{
  return nullptr;
}",43,,649,1,,void
282560,BLOCK,-1,,"{
  // No-op
}",35,,654,1,,void
282565,BLOCK,-1,,"{
  CHECK_NOT_NULL(stream_);
  Environment* env = static_cast<StreamBase*>(stream_)->stream_env();
  return env->allocate_managed_buffer(suggested_size);
}",71,,659,2,,void
282587,BLOCK,-1,,"{
  CHECK_NOT_NULL(stream_);
  StreamBase* stream = static_cast<StreamBase*>(stream_);
  Environment* env = stream->stream_env();
  Isolate* isolate = env->isolate();
  HandleScope handle_scope(isolate);
  Context::Scope context_scope(env->context());
  std::unique_ptr<BackingStore> bs = env->release_managed_buffer(buf_);

  if (nread <= 0)  {
    if (nread < 0)
      stream->CallJSOnreadMethod(nread, Local<ArrayBuffer>());
    return;
  }

  CHECK_LE(static_cast<size_t>(nread), bs->ByteLength());
  bs = BackingStore::Reallocate(isolate, std::move(bs), nread);

  stream->CallJSOnreadMethod(nread, ArrayBuffer::New(isolate, std::move(bs)));
}",80,,665,3,,void
282635,BLOCK,-1,,"{
    if (nread < 0)
      stream->CallJSOnreadMethod(nread, Local<ArrayBuffer>());
    return;
  }",20,,674,2,,void
282640,BLOCK,-1,,<empty>,7,,676,2,,void
282688,BLOCK,-1,,"{
  return buffer_;
}",71,,687,2,,void
282696,BLOCK,-1,,"{
  CHECK_NOT_NULL(stream_);

  StreamBase* stream = static_cast<StreamBase*>(stream_);
  Environment* env = stream->stream_env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  // In the case that there's an error and buf is null, return immediately.
  // This can happen on unices when POLLHUP is received and UV_EOF is returned
  // or when getting an error while performing a UV_HANDLE_ZERO_READ on Windows.
  if (buf.base == nullptr && nread < 0) {
    stream->CallJSOnreadMethod(nread, Local<ArrayBuffer>());
    return;
  }

  CHECK_EQ(buf.base, buffer_.base);

  MaybeLocal<Value> ret = stream->CallJSOnreadMethod(nread,
                             Local<ArrayBuffer>(),
                             0,
                             StreamBase::SKIP_NREAD_CHECKS);
  Local<Value> next_buf_v;
  if (ret.ToLocal(&next_buf_v) && !next_buf_v->IsUndefined()) {
    buffer_.base = Buffer::Data(next_buf_v);
    buffer_.len = Buffer::Length(next_bu...",79,,692,3,,void
282733,BLOCK,-1,,"{
    stream->CallJSOnreadMethod(nread, Local<ArrayBuffer>());
    return;
  }",41,,703,2,,void
282782,BLOCK,-1,,"{
    buffer_.base = Buffer::Data(next_buf_v);
    buffer_.len = Buffer::Length(next_buf_v);
  }",63,,715,2,,void
282806,BLOCK,-1,,"{
  StreamBase* stream = static_cast<StreamBase*>(stream_);
  Environment* env = stream->stream_env();
  if (!env->can_call_into_js()) return;
  AsyncWrap* async_wrap = req_wrap->GetAsyncWrap();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());
  CHECK(!async_wrap->persistent().IsEmpty());
  Local<Object> req_wrap_obj = async_wrap->object();

  Local<Value> argv[] = {
    Integer::New(env->isolate(), status),
    stream->GetObject(),
    Undefined(env->isolate())
  };

  const char* msg = stream->Error();
  if (msg != nullptr) {
    argv[2] = OneByteString(env->isolate(), msg);
    stream->ClearError();
  }

  if (req_wrap_obj->Has(env->context(), env->oncomplete_string()).FromJust())
    async_wrap->MakeCallback(env->oncomplete_string(), arraysize(argv), argv);
}",38,,723,3,,void
282826,BLOCK,-1,,<empty>,33,,726,2,,void
282899,BLOCK,-1,,"{
    argv[2] = OneByteString(env->isolate(), msg);
    stream->ClearError();
  }",23,,740,2,,void
282930,BLOCK,-1,,<empty>,5,,746,2,,void
282947,BLOCK,-1,,"{
  OnStreamAfterReqFinished(req_wrap, status);
}",38,,750,3,,void
282956,BLOCK,-1,,"{
  OnStreamAfterReqFinished(req_wrap, status);
}",41,,755,3,,void
282964,BLOCK,-1,,"{
  stream()->EmitAfterShutdown(this, status);
  Dispose();
}",39,,759,2,,void
282976,BLOCK,-1,,"{
  stream()->EmitAfterWrite(this, status);
  Dispose();
}",36,,764,2,,void
282987,BLOCK,-1,,"{
  if (stream_ != nullptr)
    stream_->RemoveStreamListener(this);
}",35,,769,1,,void
282992,BLOCK,-1,,<empty>,5,,771,2,,void
283003,BLOCK,-1,,"{
  CHECK_NOT_NULL(previous_listener_);
  previous_listener_->OnStreamAfterShutdown(w, status);
}",73,,774,3,,void
283016,BLOCK,-1,,"{
  CHECK_NOT_NULL(previous_listener_);
  previous_listener_->OnStreamAfterWrite(w, status);
}",67,,779,3,,void
283027,BLOCK,-1,,"{
  while (listener_ != nullptr) {
    StreamListener* listener = listener_;
    listener->OnStreamDestroy();
    // Remove the listener if it didnt remove itself. This makes the logic
    // in `OnStreamDestroy()` implementations easier, because they
    // may call generic cleanup functions which can just remove the
    // listener unconditionally.
    if (listener == listener_)
      RemoveStreamListener(listener_);
  }
}",35,,784,1,,void
283032,BLOCK,-1,,"{
    StreamListener* listener = listener_;
    listener->OnStreamDestroy();
    // Remove the listener if it didnt remove itself. This makes the logic
    // in `OnStreamDestroy()` implementations easier, because they
    // may call generic cleanup functions which can just remove the
    // listener unconditionally.
    if (listener == listener_)
      RemoveStreamListener(listener_);
  }",32,,785,2,,void
283045,BLOCK,-1,,<empty>,7,,793,2,,void
283051,BLOCK,-1,,"{
  CHECK_NOT_NULL(listener);

  StreamListener* previous;
  StreamListener* current;

  // Remove from the linked list.
  // No loop condition because we want a crash if listener is not found.
  for (current = listener_, previous = nullptr;;
       previous = current, current = current->previous_listener_) {
    CHECK_NOT_NULL(current);
    if (current == listener) {
      if (previous != nullptr)
        previous->previous_listener_ = current->previous_listener_;
      else
        listener_ = listener->previous_listener_;
      break;
    }
  }

  listener->stream_ = nullptr;
  listener->previous_listener_ = nullptr;
}",69,,797,2,,void
283057,BLOCK,-1,,<empty>,3,,805,1,,void
283074,BLOCK,4,,"{
    CHECK_NOT_NULL(current);
    if (current == listener) {
      if (previous != nullptr)
        previous->previous_listener_ = current->previous_listener_;
      else
        listener_ = listener->previous_listener_;
      break;
    }
  }",67,,806,4,,void
283081,BLOCK,-1,,"{
      if (previous != nullptr)
        previous->previous_listener_ = current->previous_listener_;
      else
        listener_ = listener->previous_listener_;
      break;
    }",30,,808,2,,void
283086,BLOCK,-1,,<empty>,9,,810,2,,void
283095,BLOCK,-1,,<empty>,9,,812,1,,void
283116,BLOCK,-1,,"{
  auto* wrap = new SimpleShutdownWrap<AsyncWrap>(this, object);
  wrap->MakeWeak();
  return wrap;
}",27,,822,2,,void
283134,BLOCK,-1,,"{
  auto* wrap = new SimpleWriteWrap<AsyncWrap>(this, object);
  wrap->MakeWeak();
  return wrap;
}",27,,829,2,,void
283153,BLOCK,-1,,"{
  AsyncWrap* async_wrap = GetAsyncWrap();
  Environment* env = async_wrap->env();
  if (error_str != nullptr) {
    v8::HandleScope handle_scope(env->isolate());
    if (async_wrap->object()
            ->Set(env->context(),
                  env->error_string(),
                  OneByteString(env->isolate(), error_str))
            .IsNothing()) {
      return;
    }
  }

  OnDone(status);
}",57,,835,3,,void
283169,BLOCK,-1,,"{
    v8::HandleScope handle_scope(env->isolate());
    if (async_wrap->object()
            ->Set(env->context(),
                  env->error_string(),
                  OneByteString(env->isolate(), error_str))
            .IsNothing()) {
      return;
    }
  }",29,,838,2,,void
283201,BLOCK,-1,,"{
      return;
    }",27,,844,2,,void
283221,BLOCK,-1,,<empty>,1,,1,1,,ANY
283225,BLOCK,-1,,"{
    HandleScope handle_scope(env->isolate());
    Context::Scope context_scope(env->context());
    Local<Object> object = this->object();

    Local<Value> onunpipe;
    if (!object->Get(env->context(), env->onunpipe_string()).ToLocal(&onunpipe))
      return;
    if (onunpipe->IsFunction() &&
        MakeCallback(onunpipe.As<Function>(), 0, nullptr).IsEmpty()) {
      return;
    }

    // Set all the links established in the constructor to `null`.
    Local<Value> null = Null(env->isolate());

    Local<Value> source_v;
    Local<Value> sink_v;
    if (!object->Get(env->context(), env->source_string()).ToLocal(&source_v) ||
        !object->Get(env->context(), env->sink_string()).ToLocal(&sink_v) ||
        !source_v->IsObject() || !sink_v->IsObject()) {
      return;
    }

    if (object->Set(env->context(), env->source_string(), null).IsNothing() ||
        object->Set(env->context(), env->sink_string(), null).IsNothing() ||
        source_v.As<Object>()
            ->Set(en...",60,,71,2,,void
283272,BLOCK,-1,,<empty>,7,,78,2,,void
283290,BLOCK,-1,,"{
      return;
    }",70,,80,2,,void
283363,BLOCK,-1,,"{
      return;
    }",55,,91,2,,void
283439,BLOCK,-1,,"{
      return;
    }",27,,102,2,,void
283455,BLOCK,-1,,<empty>,1,,1,1,,ANY
283461,BLOCK,-1,,"{
  MakeWeak();

  CHECK_NOT_NULL(sink);
  CHECK_NOT_NULL(source);

  source->PushStreamListener(&readable_listener_);
  sink->PushStreamListener(&writable_listener_);

  uses_wants_write_ = sink->HasWantsWrite();
}",76,,25,4,,void
283488,BLOCK,-1,,"{
  Unpipe(true);
}",27,,37,1,,void
283494,BLOCK,-1,,"{
  return static_cast<StreamBase*>(readable_listener_.stream());
}",34,,41,1,,void
283505,BLOCK,-1,,"{
  return static_cast<StreamBase*>(writable_listener_.stream());
}",32,,45,1,,void
283517,BLOCK,-1,,"{
  if (is_closed_)
    return;

  // Note that we possibly cannot use virtual methods on `source` and `sink`
  // here, because this function can be called from their destructors via
  // `OnStreamDestroy()`.
  if (!source_destroyed_)
    source()->ReadStop();

  is_closed_ = true;
  is_reading_ = false;
  source()->RemoveStreamListener(&readable_listener_);
  if (pending_writes_ == 0)
    sink()->RemoveStreamListener(&writable_listener_);

  if (is_in_deletion) return;

  // Delay the JS-facing part with SetImmediate, because this might be from
  // inside the garbage collector, so we cant run JS here.
  HandleScope handle_scope(env()->isolate());
  BaseObjectPtr<StreamPipe> strong_ref{this};
  env()->SetImmediate([this, strong_ref](Environment* env) {
    HandleScope handle_scope(env->isolate());
    Context::Scope context_scope(env->context());
    Local<Object> object = this->object();

    Local<Value> onunpipe;
    if (!object->Get(env->context(), env->onunpipe_string()).ToL...",46,,49,2,,void
283520,BLOCK,-1,,<empty>,5,,51,2,,void
283525,BLOCK,-1,,<empty>,5,,57,2,,void
283546,BLOCK,-1,,<empty>,5,,63,2,,void
283555,BLOCK,-1,,<empty>,23,,65,2,,void
283579,BLOCK,-1,,"{
  StreamPipe* pipe = ContainerOf(&StreamPipe::readable_listener_, this);
  size_t size = std::min(suggested_size, pipe->wanted_data_);
  CHECK_GT(size, 0);
  return pipe->env()->allocate_managed_buffer(size);
}",77,,108,2,,void
283617,BLOCK,-1,,"{
  StreamPipe* pipe = ContainerOf(&StreamPipe::readable_listener_, this);
  std::unique_ptr<BackingStore> bs = pipe->env()->release_managed_buffer(buf_);
  if (nread < 0) {
    // EOF or error; stop reading and pass the error to the previous listener
    // (which might end up in JS).
    pipe->is_eof_ = true;
    // Cache `sink()` here because the previous listener might do things
    // that eventually lead to an `Unpipe()` call.
    StreamBase* sink = pipe->sink();
    stream()->ReadStop();
    CHECK_NOT_NULL(previous_listener_);
    previous_listener_->OnStreamRead(nread, uv_buf_init(nullptr, 0));
    // If were not writing, close now. Otherwise, well do that in
    // `OnStreamAfterWrite()`.
    if (pipe->pending_writes_ == 0) {
      sink->Shutdown();
      pipe->Unpipe();
    }
    return;
  }

  pipe->ProcessData(nread, std::move(bs));
}",71,,116,3,,void
283647,BLOCK,-1,,"{
    // EOF or error; stop reading and pass the error to the previous listener
    // (which might end up in JS).
    pipe->is_eof_ = true;
    // Cache `sink()` here because the previous listener might do things
    // that eventually lead to an `Unpipe()` call.
    StreamBase* sink = pipe->sink();
    stream()->ReadStop();
    CHECK_NOT_NULL(previous_listener_);
    previous_listener_->OnStreamRead(nread, uv_buf_init(nullptr, 0));
    // If were not writing, close now. Otherwise, well do that in
    // `OnStreamAfterWrite()`.
    if (pipe->pending_writes_ == 0) {
      sink->Shutdown();
      pipe->Unpipe();
    }
    return;
  }",18,,119,2,,void
283679,BLOCK,-1,,"{
      sink->Shutdown();
      pipe->Unpipe();
    }",37,,131,2,,void
283704,BLOCK,-1,,"{
  CHECK(uses_wants_write_ || pending_writes_ == 0);
  uv_buf_t buffer = uv_buf_init(static_cast<char*>(bs->Data()), nread);
  StreamWriteResult res = sink()->Write(&buffer, 1);
  pending_writes_++;
  if (!res.async) {
    writable_listener_.OnStreamAfterWrite(nullptr, res.err);
  } else {
    is_reading_ = false;
    res.wrap->SetBackingStore(std::move(bs));
    if (source() != nullptr)
      source()->ReadStop();
  }
}",64,,142,3,,void
283739,BLOCK,-1,,"{
    writable_listener_.OnStreamAfterWrite(nullptr, res.err);
  }",19,,147,2,,void
283749,BLOCK,-1,,"{
    is_reading_ = false;
    res.wrap->SetBackingStore(std::move(bs));
    if (source() != nullptr)
      source()->ReadStop();
  }",10,,149,1,,void
283768,BLOCK,-1,,<empty>,7,,153,2,,void
283778,BLOCK,-1,,"{
  StreamPipe* pipe = ContainerOf(&StreamPipe::writable_listener_, this);
  pipe->pending_writes_--;
  if (pipe->is_closed_) {
    if (pipe->pending_writes_ == 0) {
      Environment* env = pipe->env();
      HandleScope handle_scope(env->isolate());
      Context::Scope context_scope(env->context());
      if (pipe->MakeCallback(env->oncomplete_string(), 0, nullptr).IsEmpty())
        return;
      stream()->RemoveStreamListener(this);
    }
    return;
  }

  if (pipe->is_eof_) {
    HandleScope handle_scope(pipe->env()->isolate());
    InternalCallbackScope callback_scope(pipe,
        InternalCallbackScope::kSkipTaskQueues);
    pipe->sink()->Shutdown();
    pipe->Unpipe();
    return;
  }

  if (status != 0) {
    CHECK_NOT_NULL(previous_listener_);
    StreamListener* prev = previous_listener_;
    pipe->Unpipe();
    prev->OnStreamAfterWrite(w, status);
    return;
  }

  if (!pipe->uses_wants_write_) {
    OnStreamWantsWrite(65536);
  }
}",67,,158,3,,void
283796,BLOCK,-1,,"{
    if (pipe->pending_writes_ == 0) {
      Environment* env = pipe->env();
      HandleScope handle_scope(env->isolate());
      Context::Scope context_scope(env->context());
      if (pipe->MakeCallback(env->oncomplete_string(), 0, nullptr).IsEmpty())
        return;
      stream()->RemoveStreamListener(this);
    }
    return;
  }",25,,161,2,,void
283803,BLOCK,-1,,"{
      Environment* env = pipe->env();
      HandleScope handle_scope(env->isolate());
      Context::Scope context_scope(env->context());
      if (pipe->MakeCallback(env->oncomplete_string(), 0, nullptr).IsEmpty())
        return;
      stream()->RemoveStreamListener(this);
    }",37,,162,2,,void
283837,BLOCK,-1,,<empty>,9,,167,2,,void
283849,BLOCK,-1,,"{
    HandleScope handle_scope(pipe->env()->isolate());
    InternalCallbackScope callback_scope(pipe,
        InternalCallbackScope::kSkipTaskQueues);
    pipe->sink()->Shutdown();
    pipe->Unpipe();
    return;
  }",22,,173,2,,void
283881,BLOCK,-1,,"{
    CHECK_NOT_NULL(previous_listener_);
    StreamListener* prev = previous_listener_;
    pipe->Unpipe();
    prev->OnStreamAfterWrite(w, status);
    return;
  }",20,,182,2,,void
283903,BLOCK,-1,,"{
    OnStreamWantsWrite(65536);
  }",33,,190,2,,void
283911,BLOCK,-1,,"{
  StreamPipe* pipe = ContainerOf(&StreamPipe::writable_listener_, this);
  CHECK_NOT_NULL(previous_listener_);
  StreamListener* prev = previous_listener_;
  pipe->Unpipe();
  prev->OnStreamAfterShutdown(w, status);
}",70,,196,3,,void
283939,BLOCK,-1,,"{
  StreamPipe* pipe = ContainerOf(&StreamPipe::readable_listener_, this);
  pipe->source_destroyed_ = true;
  if (!pipe->is_eof_) {
    OnStreamRead(UV_EPIPE, uv_buf_init(nullptr, 0));
  }
}",54,,204,1,,void
283959,BLOCK,-1,,"{
    OnStreamRead(UV_EPIPE, uv_buf_init(nullptr, 0));
  }",23,,207,2,,void
283968,BLOCK,-1,,"{
  StreamPipe* pipe = ContainerOf(&StreamPipe::writable_listener_, this);
  pipe->sink_destroyed_ = true;
  pipe->is_eof_ = true;
  pipe->pending_writes_ = 0;
  pipe->Unpipe();
}",54,,212,1,,void
284001,BLOCK,-1,,"{
  StreamPipe* pipe = ContainerOf(&StreamPipe::writable_listener_, this);
  pipe->wanted_data_ = suggested_size;
  if (pipe->is_reading_ || pipe->is_closed_)
    return;
  HandleScope handle_scope(pipe->env()->isolate());
  InternalCallbackScope callback_scope(pipe,
      InternalCallbackScope::kSkipTaskQueues);
  pipe->is_reading_ = true;
  pipe->source()->ReadStart();
}",78,,220,2,,void
284024,BLOCK,-1,,<empty>,5,,224,2,,void
284057,BLOCK,-1,,"{
  CHECK_NOT_NULL(previous_listener_);
  return previous_listener_->OnStreamAlloc(suggested_size);
}",77,,232,2,,void
284070,BLOCK,-1,,"{
  CHECK_NOT_NULL(previous_listener_);
  return previous_listener_->OnStreamRead(nread, buf);
}",70,,238,3,,void
284085,BLOCK,-1,,"{
  std::unique_ptr<StreamPipe> stream_pipe(new StreamPipe(source, sink, obj));

  // Set up links between this object and the source/sink objects.
  // In particular, this makes sure that they are garbage collected as a group,
  // if that applies to the given streams (for example, Http2Streams use
  // weak references).
  Environment* env = source->stream_env();
  if (obj->Set(env->context(), env->source_string(), source->GetObject())
          .IsNothing()) {
    return Nothing<StreamPipe*>();
  }
  if (source->GetObject()
          ->Set(env->context(), env->pipe_target_string(), obj)
          .IsNothing()) {
    return Nothing<StreamPipe*>();
  }
  if (obj->Set(env->context(), env->sink_string(), sink->GetObject())
          .IsNothing()) {
    return Nothing<StreamPipe*>();
  }
  if (sink->GetObject()
          ->Set(env->context(), env->pipe_source_string(), obj)
          .IsNothing()) {
    return Nothing<StreamPipe*>();
  }

  return Just(stream_pipe.release());
}",55,,245,4,,void
284125,BLOCK,-1,,"{
    return Nothing<StreamPipe*>();
  }",25,,254,2,,void
284148,BLOCK,-1,,"{
    return Nothing<StreamPipe*>();
  }",25,,259,2,,void
284171,BLOCK,-1,,"{
    return Nothing<StreamPipe*>();
  }",25,,263,2,,void
284194,BLOCK,-1,,"{
    return Nothing<StreamPipe*>();
  }",25,,268,2,,void
284207,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsObject());
  StreamBase* source = StreamBase::FromObject(args[0].As<Object>());
  StreamBase* sink = StreamBase::FromObject(args[1].As<Object>());

  if (StreamPipe::New(source, sink, args.This()).IsNothing()) return;
}",63,,275,2,,void
284267,BLOCK,-1,,<empty>,63,,282,2,,void
284273,BLOCK,-1,,"{
  StreamPipe* pipe;
  ASSIGN_OR_RETURN_UNWRAP(&pipe, args.Holder());
  pipe->is_closed_ = false;
  pipe->writable_listener_.OnStreamWantsWrite(65536);
}",65,,285,2,,void
284298,BLOCK,-1,,"{
  StreamPipe* pipe;
  ASSIGN_OR_RETURN_UNWRAP(&pipe, args.Holder());
  pipe->Unpipe();
}",66,,292,2,,void
284315,BLOCK,-1,,"{
  StreamPipe* pipe;
  ASSIGN_OR_RETURN_UNWRAP(&pipe, args.Holder());
  args.GetReturnValue().Set(pipe->is_closed_);
}",68,,298,2,,void
284338,BLOCK,-1,,"{
  StreamPipe* pipe;
  ASSIGN_OR_RETURN_UNWRAP(&pipe, args.Holder());
  args.GetReturnValue().Set(pipe->pending_writes_);
}",73,,304,2,,void
284365,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  // Create FunctionTemplate for FileHandle::CloseReq
  Local<FunctionTemplate> pipe = NewFunctionTemplate(isolate, StreamPipe::New);
  SetProtoMethod(isolate, pipe, ""unpipe"", StreamPipe::Unpipe);
  SetProtoMethod(isolate, pipe, ""start"", StreamPipe::Start);
  SetProtoMethod(isolate, pipe, ""isClosed"", StreamPipe::IsClosed);
  SetProtoMethod(isolate, pipe, ""pendingWrites"", StreamPipe::PendingWrites);
  pipe->Inherit(AsyncWrap::GetConstructorTemplate(env));
  pipe->InstanceTemplate()->SetInternalFieldCount(
      StreamPipe::kInternalFieldCount);
  SetConstructorFunction(context, target, ""StreamPipe"", pipe);
}",39,,315,5,,void
284453,BLOCK,-1,,<empty>,1,,1,1,,ANY
284459,BLOCK,-1,,"{
        static_cast<LibuvStreamWrap*>(handle->data)
            ->OnUvAlloc(suggested_size, buf);
      }",69,,205,4,,void
284478,BLOCK,-1,,"{
        LibuvStreamWrap* wrap = static_cast<LibuvStreamWrap*>(stream->data);
        TryCatchScope try_catch(wrap->env());
        try_catch.SetVerbose(true);
        wrap->OnUvRead(nread, buf);
      }",67,,209,4,,void
284537,BLOCK,-1,,<empty>,1,,1,1,,ANY
284541,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  StreamReq::ResetObject(args.This());
}",71,,61,2,,void
284562,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> sw =
      NewFunctionTemplate(isolate, IsConstructCallCallback);
  sw->InstanceTemplate()->SetInternalFieldCount(StreamReq::kInternalFieldCount);

  // we need to set handle and callback to null,
  // so that those fields are created and functions
  // do not become megamorphic
  // Fields:
  // - oncomplete
  // - callback
  // - handle
  sw->InstanceTemplate()->Set(env->oncomplete_string(), v8::Null(isolate));
  sw->InstanceTemplate()->Set(FIXED_ONE_BYTE_STRING(isolate, ""callback""),
                              v8::Null(isolate));
  sw->InstanceTemplate()->Set(FIXED_ONE_BYTE_STRING(isolate, ""handle""),
                              v8::Null(isolate));

  sw->Inherit(AsyncWrap::GetConstructorTemplate(env));

  SetConstructorFunction(context, target, ""ShutdownWrap"", sw);
  env->set_shutdown_wrap_template(sw->InstanceTemplate());

  Local<FunctionTemplate> ww =
  ...",46,,69,5,,void
284714,BLOCK,1,,<empty>,,,,7,,void
284716,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kReadBytesOrError)",3,,103,1,,void
284813,BLOCK,1,,<empty>,,,,7,,void
284815,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kArrayBufferOffset)",3,,104,1,,void
284912,BLOCK,1,,<empty>,,,,7,,void
284914,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kBytesWritten)",3,,105,1,,void
285011,BLOCK,1,,<empty>,,,,7,,void
285013,BLOCK,-1,,"NODE_DEFINE_CONSTANT(target, kLastWriteWasAsync)",3,,106,1,,void
285127,BLOCK,-1,,"{
  registry->Register(IsConstructCallCallback);
  registry->Register(GetWriteQueueSize);
  registry->Register(SetBlocking);
  StreamBase::RegisterExternalReferences(registry);
}",42,,115,2,,void
285155,BLOCK,-1,,"{
  StreamBase::AttachToObject(object);
}",23,,131,5,,void
285165,BLOCK,-1,,"{
  Local<FunctionTemplate> tmpl = env->libuv_stream_wrap_ctor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->SetClassName(FIXED_ONE_BYTE_STRING(isolate, ""LibuvStreamWrap""));
    tmpl->Inherit(HandleWrap::GetConstructorTemplate(env));
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        StreamBase::kInternalFieldCount);
    Local<FunctionTemplate> get_write_queue_size =
        FunctionTemplate::New(isolate,
                              GetWriteQueueSize,
                              Local<Value>(),
                              Signature::New(isolate, tmpl));
    tmpl->PrototypeTemplate()->SetAccessorProperty(
        env->write_queue_size_string(),
        get_write_queue_size,
        Local<FunctionTemplate>(),
        static_cast<PropertyAttribute>(ReadOnly | DontDelete));
    SetProtoMethod(isolate, tmpl, ""setBlocking"", SetBlocking);
    StreamBase::AddMethods(env, tmpl);
    env->...",23,,137,2,,void
285181,BLOCK,-1,,"{
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->SetClassName(FIXED_ONE_BYTE_STRING(isolate, ""LibuvStreamWrap""));
    tmpl->Inherit(HandleWrap::GetConstructorTemplate(env));
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        StreamBase::kInternalFieldCount);
    Local<FunctionTemplate> get_write_queue_size =
        FunctionTemplate::New(isolate,
                              GetWriteQueueSize,
                              Local<Value>(),
                              Signature::New(isolate, tmpl));
    tmpl->PrototypeTemplate()->SetAccessorProperty(
        env->write_queue_size_string(),
        get_write_queue_size,
        Local<FunctionTemplate>(),
        static_cast<PropertyAttribute>(ReadOnly | DontDelete));
    SetProtoMethod(isolate, tmpl, ""setBlocking"", SetBlocking);
    StreamBase::AddMethods(env, tmpl);
    env->set_libuv_stream_wrap_ctor_template(tmpl);
  }",23,,139,2,,void
285280,BLOCK,-1,,"{
  Local<FunctionTemplate> sw = env->libuv_stream_wrap_ctor_template();
  CHECK(!sw.IsEmpty() && sw->HasInstance(object));
  return Unwrap<LibuvStreamWrap>(object);
}",80,,164,3,,void
285312,BLOCK,-1,,"{
#ifdef _WIN32
  return fd_;
#else
  int fd = -1;
  if (stream() != nullptr)
    uv_fileno(reinterpret_cast<uv_handle_t*>(stream()), &fd);
  return fd;
#endif
}",30,,171,1,,void
285322,BLOCK,-1,,<empty>,5,,177,2,,void
285334,BLOCK,-1,,"{
  return HandleWrap::IsAlive(this);
}",33,,183,1,,void
285344,BLOCK,-1,,"{
  return uv_is_closing(reinterpret_cast<uv_handle_t*>(stream()));
}",35,,188,1,,void
285353,BLOCK,-1,,"{
  return static_cast<AsyncWrap*>(this);
}",44,,193,1,,void
285361,BLOCK,-1,,"{
  return is_named_pipe_ipc();
}",35,,198,1,,void
285367,BLOCK,-1,,"{
  return uv_read_start(
      stream(),
      [](uv_handle_t* handle, size_t suggested_size, uv_buf_t* buf) {
        static_cast<LibuvStreamWrap*>(handle->data)
            ->OnUvAlloc(suggested_size, buf);
      },
      [](uv_stream_t* stream, ssize_t nread, const uv_buf_t* buf) {
        LibuvStreamWrap* wrap = static_cast<LibuvStreamWrap*>(stream->data);
        TryCatchScope try_catch(wrap->env());
        try_catch.SetVerbose(true);
        wrap->OnUvRead(nread, buf);
      });
}",34,,202,1,,void
285376,BLOCK,-1,,"{
  return uv_read_stop(stream());
}",33,,218,1,,void
285385,BLOCK,-1,,"{
  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());

  *buf = EmitAlloc(suggested_size);
}",71,,223,3,,void
285408,BLOCK,-1,,"{
  static_assert(std::is_base_of<LibuvStreamWrap, WrapType>::value ||
                std::is_base_of<UDPWrap, WrapType>::value,
                ""Can only accept stream handles"");

  EscapableHandleScope scope(env->isolate());
  Local<Object> wrap_obj;

  if (!WrapType::Instantiate(env, parent, WrapType::SOCKET).ToLocal(&wrap_obj))
    return Local<Object>();

  HandleWrap* wrap = Unwrap<HandleWrap>(wrap_obj);
  CHECK_NOT_NULL(wrap);
  uv_stream_t* stream = reinterpret_cast<uv_stream_t*>(wrap->GetHandle());
  CHECK_NOT_NULL(stream);

  if (uv_accept(parent->stream(), stream))
    ABORT();

  return scope.Escape(wrap_obj);
}",65,,232,3,,void
285449,BLOCK,-1,,<empty>,5,,241,2,,void
285480,BLOCK,-1,,<empty>,5,,249,2,,void
285493,BLOCK,-1,,"{
  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());
  uv_handle_type type = UV_UNKNOWN_HANDLE;

  if (is_named_pipe_ipc() &&
      uv_pipe_pending_count(reinterpret_cast<uv_pipe_t*>(stream())) > 0) {
    type = uv_pipe_pending_type(reinterpret_cast<uv_pipe_t*>(stream()));
  }

  // We should not be getting this callback if someone has already called
  // uv_close() on the handle.
  CHECK_EQ(persistent().IsEmpty(), false);

  if (nread > 0) {
    MaybeLocal<Object> pending_obj;

    if (type == UV_TCP) {
      pending_obj = AcceptHandle<TCPWrap>(env(), this);
    } else if (type == UV_NAMED_PIPE) {
      pending_obj = AcceptHandle<PipeWrap>(env(), this);
    } else if (type == UV_UDP) {
      pending_obj = AcceptHandle<UDPWrap>(env(), this);
    } else {
      CHECK_EQ(type, UV_UNKNOWN_HANDLE);
    }

    Local<Object> local_pending_obj;
    if (type != UV_UNKNOWN_HANDLE &&
        (!pending_obj.ToLocal(&local_pending_obj) ||
         object()
 ...",75,,254,3,,void
285519,BLOCK,-1,,"{
    type = uv_pipe_pending_type(reinterpret_cast<uv_pipe_t*>(stream()));
  }",74,,260,2,,void
285536,BLOCK,-1,,"{
    MaybeLocal<Object> pending_obj;

    if (type == UV_TCP) {
      pending_obj = AcceptHandle<TCPWrap>(env(), this);
    } else if (type == UV_NAMED_PIPE) {
      pending_obj = AcceptHandle<PipeWrap>(env(), this);
    } else if (type == UV_UDP) {
      pending_obj = AcceptHandle<UDPWrap>(env(), this);
    } else {
      CHECK_EQ(type, UV_UNKNOWN_HANDLE);
    }

    Local<Object> local_pending_obj;
    if (type != UV_UNKNOWN_HANDLE &&
        (!pending_obj.ToLocal(&local_pending_obj) ||
         object()
             ->Set(env()->context(),
                   env()->pending_handle_string(),
                   local_pending_obj)
             .IsNothing())) {
      return Nothing<void>();
    }
  }",18,,268,2,,void
285546,BLOCK,-1,,"{
      pending_obj = AcceptHandle<TCPWrap>(env(), this);
    }",25,,271,2,,void
285558,BLOCK,-1,,<empty>,12,,273,1,,void
285563,BLOCK,-1,,"{
      pending_obj = AcceptHandle<PipeWrap>(env(), this);
    }",39,,273,2,,void
285575,BLOCK,-1,,<empty>,12,,275,1,,void
285580,BLOCK,-1,,"{
      pending_obj = AcceptHandle<UDPWrap>(env(), this);
    }",32,,275,2,,void
285592,BLOCK,-1,,"{
      CHECK_EQ(type, UV_UNKNOWN_HANDLE);
    }",12,,277,1,,void
285630,BLOCK,-1,,"{
      return Nothing<void>();
    }",29,,288,2,,void
285643,BLOCK,-1,,"{
  LibuvStreamWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, info.This());

  if (wrap->stream() == nullptr) {
    info.GetReturnValue().Set(0);
    return;
  }

  uint32_t write_queue_size = wrap->stream()->write_queue_size;
  info.GetReturnValue().Set(write_queue_size);
}",46,,298,2,,void
285659,BLOCK,-1,,"{
    info.GetReturnValue().Set(0);
    return;
  }",34,,302,2,,void
285690,BLOCK,-1,,"{
  LibuvStreamWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK_GT(args.Length(), 0);
  if (!wrap->IsAlive())
    return args.GetReturnValue().Set(UV_EINVAL);

  bool enable = args[0]->IsTrue();
  args.GetReturnValue().Set(uv_stream_set_blocking(wrap->stream(), enable));
}",76,,312,2,,void
285711,BLOCK,-1,,<empty>,5,,318,2,,void
285749,BLOCK,-1,,"{
  return new LibuvShutdownWrap(this, object);
}",73,,327,2,,void
285759,BLOCK,-1,,"{
  return new LibuvWriteWrap(this, object);
}",67,,331,2,,void
285769,BLOCK,-1,,"{
  LibuvShutdownWrap* req_wrap = static_cast<LibuvShutdownWrap*>(req_wrap_);
  return req_wrap->Dispatch(uv_shutdown, stream(), AfterUvShutdown);
}",58,,336,2,,void
285789,BLOCK,-1,,"{
  LibuvShutdownWrap* req_wrap = static_cast<LibuvShutdownWrap*>(
      LibuvShutdownWrap::from_req(req));
  CHECK_NOT_NULL(req_wrap);
  HandleScope scope(req_wrap->env()->isolate());
  Context::Scope context_scope(req_wrap->env()->context());
  req_wrap->Done(status);
}",71,,342,3,,void
285830,BLOCK,-1,,"{
  int err;
  size_t written;
  uv_buf_t* vbufs = *bufs;
  size_t vcount = *count;

  err = uv_try_write(stream(), vbufs, vcount);
  if (err == UV_ENOSYS || err == UV_EAGAIN)
    return 0;
  if (err < 0)
    return err;

  // Slice off the buffers: skip all written buffers and slice the one that
  // was partially written.
  written = err;
  for (; vcount > 0; vbufs++, vcount--) {
    // Slice
    if (vbufs[0].len > written) {
      vbufs[0].base += written;
      vbufs[0].len -= written;
      written = 0;
      break;

    // Discard
    } else {
      written -= vbufs[0].len;
    }
  }

  *bufs = vbufs;
  *count = vcount;

  return 0;
}",65,,356,3,,void
285857,BLOCK,-1,,<empty>,5,,364,2,,void
285864,BLOCK,-1,,<empty>,5,,366,2,,void
285871,BLOCK,-1,,<empty>,3,,371,1,,void
285880,BLOCK,4,,"{
    // Slice
    if (vbufs[0].len > written) {
      vbufs[0].base += written;
      vbufs[0].len -= written;
      written = 0;
      break;

    // Discard
    } else {
      written -= vbufs[0].len;
    }
  }",41,,371,4,,void
285889,BLOCK,-1,,"{
      vbufs[0].base += written;
      vbufs[0].len -= written;
      written = 0;
      break;

    // Discard
    }",33,,373,2,,void
285909,BLOCK,-1,,"{
      written -= vbufs[0].len;
    }",12,,380,1,,void
285934,BLOCK,-1,,"{
  LibuvWriteWrap* w = static_cast<LibuvWriteWrap*>(req_wrap);
  return w->Dispatch(uv_write2,
                     stream(),
                     bufs,
                     count,
                     send_handle,
                     AfterUvWrite);
}",56,,395,5,,void
285957,BLOCK,-1,,"{
  LibuvWriteWrap* req_wrap = static_cast<LibuvWriteWrap*>(
      LibuvWriteWrap::from_req(req));
  CHECK_NOT_NULL(req_wrap);
  HandleScope scope(req_wrap->env()->isolate());
  Context::Scope context_scope(req_wrap->env()->context());
  req_wrap->Done(status);
}",65,,407,3,,void
286006,BLOCK,-1,,<empty>,1,,1,1,,ANY
286031,BLOCK,-1,,<empty>,1,,1,1,,ANY
286036,BLOCK,-1,,"{
    free(const_cast<TypeName*>(data_));
    isolate()->AdjustAmountOfExternalAllocatedMemory(-byte_length());
  }",28,,58,1,,void
286050,BLOCK,-1,,"{
    return data_;
  }",41,,63,1,,void
286056,BLOCK,-1,,"{
    return length_;
  }",34,,67,1,,void
286062,BLOCK,-1,,"{
    return length() * sizeof(*data());
  }",31,,71,1,,void
286076,BLOCK,-1,,"{
    if (length == 0)
      return String::Empty(isolate);

    if (length < EXTERN_APEX)
      return NewSimpleFromCopy(isolate, data, length, error);

    TypeName* new_data = node::UncheckedMalloc<TypeName>(length);
    if (new_data == nullptr) {
      *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
      return MaybeLocal<Value>();
    }
    memcpy(new_data, data, length * sizeof(*new_data));

    return ExternString<ResourceType, TypeName>::New(isolate,
                                                     new_data,
                                                     length,
                                                     error);
  }",61,,78,5,,void
286081,BLOCK,-1,,<empty>,7,,80,2,,void
286092,BLOCK,1,,<empty>,,,,1,,void
286094,BLOCK,-1,,<empty>,7,,83,2,,void
286115,BLOCK,-1,,"{
      *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
      return MaybeLocal<Value>();
    }",30,,86,2,,void
286150,BLOCK,-1,,"{
    if (length == 0)
      return String::Empty(isolate);

    if (length < EXTERN_APEX) {
      MaybeLocal<Value> str = NewSimpleFromCopy(isolate, data, length, error);
      free(data);
      return str;
    }

    ExternString* h_str = new ExternString<ResourceType, TypeName>(isolate,
                                                                   data,
                                                                   length);
    MaybeLocal<Value> str = NewExternal(isolate, h_str);
    isolate->AdjustAmountOfExternalAllocatedMemory(h_str->byte_length());

    if (str.IsEmpty()) {
      delete h_str;
      *error = node::ERR_STRING_TOO_LONG(isolate);
      return MaybeLocal<Value>();
    }

    return str.ToLocalChecked();
  }",53,,102,5,,void
286155,BLOCK,-1,,<empty>,7,,104,2,,void
286166,BLOCK,1,,<empty>,,,,1,,void
286168,BLOCK,-1,,"{
      MaybeLocal<Value> str = NewSimpleFromCopy(isolate, data, length, error);
      free(data);
      return str;
    }",31,,106,2,,void
286214,BLOCK,-1,,"{
      delete h_str;
      *error = node::ERR_STRING_TOO_LONG(isolate);
      return MaybeLocal<Value>();
    }",24,,118,2,,void
286235,BLOCK,-1,,{ return isolate_; },35,,127,1,,void
286244,BLOCK,-1,,{ },55,,131,4,,void
286250,BLOCK,-1,,<empty>,,,,3,,<empty>
286258,BLOCK,-1,,<empty>,,,,5,,<empty>
286269,BLOCK,-1,,"{
  return String::NewExternalOneByte(isolate, h_str).FromMaybe(Local<Value>());
}",51,,155,3,,void
286286,BLOCK,-1,,"{
  return String::NewExternalTwoByte(isolate, h_str).FromMaybe(Local<Value>());
}",51,,162,3,,void
286305,BLOCK,-1,,"{
  MaybeLocal<String> str =
      String::NewFromOneByte(isolate,
                             reinterpret_cast<const uint8_t*>(data),
                             v8::NewStringType::kNormal,
                             length);
  if (str.IsEmpty()) {
    *error = node::ERR_STRING_TOO_LONG(isolate);
    return MaybeLocal<Value>();
  }
  return str.ToLocalChecked();
}",79,,170,5,,void
286331,BLOCK,-1,,"{
    *error = node::ERR_STRING_TOO_LONG(isolate);
    return MaybeLocal<Value>();
  }",22,,176,2,,void
286354,BLOCK,-1,,"{
  MaybeLocal<String> str =
      String::NewFromTwoByte(isolate,
                             data,
                             v8::NewStringType::kNormal,
                             length);
  if (str.IsEmpty()) {
    *error = node::ERR_STRING_TOO_LONG(isolate);
    return MaybeLocal<Value>();
  }
  return str.ToLocalChecked();
}",79,,188,5,,void
286378,BLOCK,-1,,"{
    *error = node::ERR_STRING_TOO_LONG(isolate);
    return MaybeLocal<Value>();
  }",22,,194,2,,void
287342,BLOCK,-1,,"{
  return unhex_table[x];
}",41,,243,2,,void
287354,BLOCK,-1,,"{
  size_t i;
  for (i = 0; i < len && i * 2 + 1 < srcLen; ++i) {
    unsigned a = unhex(static_cast<uint8_t>(src[i * 2 + 0]));
    unsigned b = unhex(static_cast<uint8_t>(src[i * 2 + 1]));
    if (!~a || !~b)
      return i;
    buf[i] = (a << 4) | b;
  }

  return i;
}",47,,251,5,,void
287357,BLOCK,-1,,<empty>,3,,253,1,,void
287374,BLOCK,4,,"{
    unsigned a = unhex(static_cast<uint8_t>(src[i * 2 + 0]));
    unsigned b = unhex(static_cast<uint8_t>(src[i * 2 + 1]));
    if (!~a || !~b)
      return i;
    buf[i] = (a << 4) | b;
  }",51,,253,4,,void
287409,BLOCK,-1,,<empty>,7,,257,2,,void
287431,BLOCK,-1,,"{
  uint16_t* const dst = reinterpret_cast<uint16_t*>(buf);

  size_t max_chars = buflen / sizeof(*dst);
  if (max_chars == 0) {
    return 0;
  }

  uint16_t* const aligned_dst = AlignUp(dst, sizeof(*dst));
  size_t nchars;
  if (aligned_dst == dst) {
    nchars = str->Write(isolate, dst, 0, max_chars, flags);
    return nchars * sizeof(*dst);
  }

  CHECK_EQ(reinterpret_cast<uintptr_t>(aligned_dst) % sizeof(*dst), 0);

  // Write all but the last char
  max_chars = std::min(max_chars, static_cast<size_t>(str->Length()));
  if (max_chars == 0) {
    return 0;
  }
  nchars = str->Write(isolate, aligned_dst, 0, max_chars - 1, flags);
  CHECK_EQ(nchars, max_chars - 1);

  // Shift everything to unaligned-left
  memmove(dst, aligned_dst, nchars * sizeof(*dst));

  // One more char to be written
  uint16_t last;
  CHECK_EQ(str->Write(isolate, &last, nchars, 1, flags), 1);
  memcpy(buf + nchars * sizeof(*dst), &last, sizeof(last));
  nchars++;

  return nchars * sizeof(*dst);
}",79,,265,6,,void
287450,BLOCK,-1,,"{
    return 0;
  }",23,,269,2,,void
287466,BLOCK,-1,,"{
    nchars = str->Write(isolate, dst, 0, max_chars, flags);
    return nchars * sizeof(*dst);
  }",27,,275,2,,void
287510,BLOCK,-1,,"{
    return 0;
  }",23,,284,2,,void
287580,BLOCK,-1,,"{
  HandleScope scope(isolate);
  size_t nbytes;

  CHECK(val->IsString() == true);
  Local<String> str = val.As<String>();

  int flags = String::HINT_MANY_WRITES_EXPECTED |
              String::NO_NULL_TERMINATION |
              String::REPLACE_INVALID_UTF8;

  switch (encoding) {
    case ASCII:
    case LATIN1:
      if (str->IsExternalOneByte()) {
        auto ext = str->GetExternalOneByteStringResource();
        nbytes = std::min(buflen, ext->length());
        memcpy(buf, ext->data(), nbytes);
      } else {
        uint8_t* const dst = reinterpret_cast<uint8_t*>(buf);
        nbytes = str->WriteOneByte(isolate, dst, 0, buflen, flags);
      }
      break;

    case BUFFER:
    case UTF8:
      nbytes = str->WriteUtf8(isolate, buf, buflen, nullptr, flags);
      break;

    case UCS2: {
      nbytes = WriteUCS2(isolate, buf, buflen, str, flags);

      // Node's ""ucs2"" encoding wants LE character data stored in
      // the Buffer, so we need to reorder on BE platforms.  S...",51,,306,6,,void
287618,BLOCK,-1,,"{
    case ASCII:
    case LATIN1:
      if (str->IsExternalOneByte()) {
        auto ext = str->GetExternalOneByteStringResource();
        nbytes = std::min(buflen, ext->length());
        memcpy(buf, ext->data(), nbytes);
      } else {
        uint8_t* const dst = reinterpret_cast<uint8_t*>(buf);
        nbytes = str->WriteOneByte(isolate, dst, 0, buflen, flags);
      }
      break;

    case BUFFER:
    case UTF8:
      nbytes = str->WriteUtf8(isolate, buf, buflen, nullptr, flags);
      break;

    case UCS2: {
      nbytes = WriteUCS2(isolate, buf, buflen, str, flags);

      // Node's ""ucs2"" encoding wants LE character data stored in
      // the Buffer, so we need to reorder on BE platforms.  See
      // https://nodejs.org/api/buffer.html regarding Node's ""ucs2""
      // encoding specification
      if (IsBigEndian())
        SwapBytes16(buf, nbytes);

      break;
    }

    case BASE64URL:
      // Fall through
    case BASE64:
      if (str->IsExternalOneByte()) {
    ...",21,,317,2,,void
287628,BLOCK,-1,,"{
        auto ext = str->GetExternalOneByteStringResource();
        nbytes = std::min(buflen, ext->length());
        memcpy(buf, ext->data(), nbytes);
      }",37,,320,2,,void
287655,BLOCK,-1,,"{
        uint8_t* const dst = reinterpret_cast<uint8_t*>(buf);
        nbytes = str->WriteOneByte(isolate, dst, 0, buflen, flags);
      }",14,,324,1,,void
287692,BLOCK,15,,"{
      nbytes = WriteUCS2(isolate, buf, buflen, str, flags);

      // Node's ""ucs2"" encoding wants LE character data stored in
      // the Buffer, so we need to reorder on BE platforms.  See
      // https://nodejs.org/api/buffer.html regarding Node's ""ucs2""
      // encoding specification
      if (IsBigEndian())
        SwapBytes16(buf, nbytes);

      break;
    }",16,,335,15,,void
287703,BLOCK,-1,,<empty>,9,,343,2,,void
287717,BLOCK,-1,,"{
        auto ext = str->GetExternalOneByteStringResource();
        nbytes = base64_decode(buf, buflen, ext->data(), ext->length());
      }",37,,351,2,,void
287739,BLOCK,-1,,"{
        String::Value value(isolate, str);
        nbytes = base64_decode(buf, buflen, *value, value.length());
      }",14,,354,1,,void
287763,BLOCK,-1,,"{
        auto ext = str->GetExternalOneByteStringResource();
        nbytes = hex_decode(buf, buflen, ext->data(), ext->length());
      }",37,,361,2,,void
287785,BLOCK,-1,,"{
        String::Value value(isolate, str);
        nbytes = hex_decode(buf, buflen, *value, value.length());
      }",14,,364,1,,void
287813,BLOCK,-1,,"{
  HandleScope scope(isolate);
  size_t data_size = 0;
  bool is_buffer = Buffer::HasInstance(val);

  if (is_buffer && (encoding == BUFFER || encoding == LATIN1)) {
    return Just(Buffer::Length(val));
  }

  Local<String> str;
  if (!val->ToString(isolate->GetCurrentContext()).ToLocal(&str))
    return Nothing<size_t>();

  switch (encoding) {
    case ASCII:
    case LATIN1:
      data_size = str->Length();
      break;

    case BUFFER:
    case UTF8:
      // A single UCS2 codepoint never takes up more than 3 utf8 bytes.
      // It is an exercise for the caller to decide when a string is
      // long enough to justify calling Size() instead of StorageSize()
      data_size = 3 * str->Length();
      break;

    case UCS2:
      data_size = str->Length() * sizeof(uint16_t);
      break;

    case BASE64URL:
      // Fall through
    case BASE64:
      data_size = base64_decoded_size_fast(str->Length());
      break;

    case HEX:
      CHECK(str->Length() % 2 == 0 && ""inval...",64,,382,4,,void
287839,BLOCK,-1,,"{
    return Just(Buffer::Length(val));
  }",64,,387,2,,void
287867,BLOCK,-1,,<empty>,5,,393,2,,void
287872,BLOCK,-1,,"{
    case ASCII:
    case LATIN1:
      data_size = str->Length();
      break;

    case BUFFER:
    case UTF8:
      // A single UCS2 codepoint never takes up more than 3 utf8 bytes.
      // It is an exercise for the caller to decide when a string is
      // long enough to justify calling Size() instead of StorageSize()
      data_size = 3 * str->Length();
      break;

    case UCS2:
      data_size = str->Length() * sizeof(uint16_t);
      break;

    case BASE64URL:
      // Fall through
    case BASE64:
      data_size = base64_decoded_size_fast(str->Length());
      break;

    case HEX:
      CHECK(str->Length() % 2 == 0 && ""invalid hex string length"");
      data_size = str->Length() / 2;
      break;

    default:
      UNREACHABLE(""unknown encoding"");
  }",21,,395,2,,void
287955,BLOCK,-1,,"{
  HandleScope scope(isolate);

  if (Buffer::HasInstance(val) && (encoding == BUFFER || encoding == LATIN1))
    return Just(Buffer::Length(val));

  Local<String> str;
  if (!val->ToString(isolate->GetCurrentContext()).ToLocal(&str))
    return Nothing<size_t>();

  switch (encoding) {
    case ASCII:
    case LATIN1:
      return Just<size_t>(str->Length());

    case BUFFER:
    case UTF8:
      return Just<size_t>(str->Utf8Length(isolate));

    case UCS2:
      return Just(str->Length() * sizeof(uint16_t));

    case BASE64URL:
      // Fall through
    case BASE64: {
      String::Value value(isolate, str);
      return Just(base64_decoded_size(*value, value.length()));
    }

    case HEX:
      return Just<size_t>(str->Length() / 2);
  }

  UNREACHABLE();
}",57,,433,4,,void
287973,BLOCK,-1,,<empty>,5,,437,2,,void
288001,BLOCK,-1,,<empty>,5,,441,2,,void
288006,BLOCK,-1,,"{
    case ASCII:
    case LATIN1:
      return Just<size_t>(str->Length());

    case BUFFER:
    case UTF8:
      return Just<size_t>(str->Utf8Length(isolate));

    case UCS2:
      return Just(str->Length() * sizeof(uint16_t));

    case BASE64URL:
      // Fall through
    case BASE64: {
      String::Value value(isolate, str);
      return Just(base64_decoded_size(*value, value.length()));
    }

    case HEX:
      return Just<size_t>(str->Length() / 2);
  }",21,,443,2,,void
288049,BLOCK,18,,"{
      String::Value value(isolate, str);
      return Just(base64_decoded_size(*value, value.length()));
    }",18,,457,18,,void
288083,BLOCK,-1,,"{
  for (size_t i = 0; i < len; ++i) {
    dst[i] = src[i] & 0x7f;
  }
}",70,,469,4,,void
288085,BLOCK,-1,,<empty>,3,,470,1,,void
288095,BLOCK,4,,"{
    dst[i] = src[i] & 0x7f;
  }",36,,470,4,,void
288111,BLOCK,-1,,"{
  if (len < 16) {
    force_ascii_slow(src, dst, len);
    return;
  }

  const unsigned bytes_per_word = sizeof(uintptr_t);
  const unsigned align_mask = bytes_per_word - 1;
  const unsigned src_unalign = reinterpret_cast<uintptr_t>(src) & align_mask;
  const unsigned dst_unalign = reinterpret_cast<uintptr_t>(dst) & align_mask;

  if (src_unalign > 0) {
    if (src_unalign == dst_unalign) {
      const unsigned unalign = bytes_per_word - src_unalign;
      force_ascii_slow(src, dst, unalign);
      src += unalign;
      dst += unalign;
      len -= src_unalign;
    } else {
      force_ascii_slow(src, dst, len);
      return;
    }
  }

#if defined(_WIN64) || defined(_LP64)
  const uintptr_t mask = ~0x8080808080808080ll;
#else
  const uintptr_t mask = ~0x80808080l;
#endif

  const uintptr_t* srcw = reinterpret_cast<const uintptr_t*>(src);
  uintptr_t* dstw = reinterpret_cast<uintptr_t*>(dst);

  for (size_t i = 0, n = len / bytes_per_word; i < n; ++i) {
    dstw[i] = srcw[i] & ma...",65,,476,4,,void
288116,BLOCK,-1,,"{
    force_ascii_slow(src, dst, len);
    return;
  }",17,,477,2,,void
288153,BLOCK,-1,,"{
    if (src_unalign == dst_unalign) {
      const unsigned unalign = bytes_per_word - src_unalign;
      force_ascii_slow(src, dst, unalign);
      src += unalign;
      dst += unalign;
      len -= src_unalign;
    } else {
      force_ascii_slow(src, dst, len);
      return;
    }
  }",24,,487,2,,void
288158,BLOCK,-1,,"{
      const unsigned unalign = bytes_per_word - src_unalign;
      force_ascii_slow(src, dst, unalign);
      src += unalign;
      dst += unalign;
      len -= src_unalign;
    }",37,,488,2,,void
288179,BLOCK,-1,,"{
      force_ascii_slow(src, dst, len);
      return;
    }",12,,494,1,,void
288203,BLOCK,-1,,<empty>,3,,509,1,,void
288219,BLOCK,4,,"{
    dstw[i] = srcw[i] & mask;
  }",60,,509,4,,void
288239,BLOCK,-1,,"{
    const size_t offset = len - remainder;
    force_ascii_slow(src + offset, dst + offset, remainder);
  }",22,,514,2,,void
288261,BLOCK,-1,,"{
  // We know how much we'll write, just make sure that there's space.
  CHECK(dlen >= slen * 2 &&
      ""not enough space provided for hex encode"");

  dlen = slen * 2;
  for (uint32_t i = 0, k = 0; k < dlen; i += 1, k += 2) {
    static const char hex[] = ""0123456789abcdef"";
    uint8_t val = static_cast<uint8_t>(src[i]);
    dst[k + 0] = hex[val >> 4];
    dst[k + 1] = hex[val & 15];
  }

  return dlen;
}",18,,525,5,,void
288276,BLOCK,-1,,<empty>,3,,531,1,,void
288295,BLOCK,4,,"{
    static const char hex[] = ""0123456789abcdef"";
    uint8_t val = static_cast<uint8_t>(src[i]);
    dst[k + 0] = hex[val >> 4];
    dst[k + 1] = hex[val & 15];
  }",57,,531,4,,void
288337,BLOCK,-1,,"{
  size_t dlen = slen * 2;
  std::string dst(dlen, '\0');
  hex_encode(src, slen, dst.data(), dlen);
  return dst;
}",67,,541,3,,void
288366,BLOCK,-1,,"{
  CHECK_BUFLEN_IN_RANGE(buflen);

  if (!buflen && encoding != BUFFER) {
    return String::Empty(isolate);
  }

  MaybeLocal<String> val;

  switch (encoding) {
    case BUFFER:
      {
        auto maybe_buf = Buffer::Copy(isolate, buf, buflen);
        Local<v8::Object> buf;
        if (!maybe_buf.ToLocal(&buf)) {
          *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
        }
        return buf;
      }

    case ASCII:
      if (simdutf::validate_ascii_with_errors(buf, buflen).error) {
        // The input contains non-ASCII bytes.
        char* out = node::UncheckedMalloc(buflen);
        if (out == nullptr) {
          *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
          return MaybeLocal<Value>();
        }
        force_ascii(buf, out, buflen);
        return ExternOneByteString::New(isolate, out, buflen, error);
      } else {
        return ExternOneByteString::NewFromCopy(isolate, buf, buflen, error);
      }

    case UTF8:
      {
        val = S...",60,,561,6,,void
288369,BLOCK,1,,<empty>,,,,2,,void
288371,BLOCK,-1,,CHECK_BUFLEN_IN_RANGE(buflen),3,,562,1,,void
288378,BLOCK,-1,,CHECK_BUFLEN_IN_RANGE(buflen),3,,562,2,,void
288397,BLOCK,-1,,"{
    return String::Empty(isolate);
  }",38,,564,2,,void
288411,BLOCK,-1,,"{
    case BUFFER:
      {
        auto maybe_buf = Buffer::Copy(isolate, buf, buflen);
        Local<v8::Object> buf;
        if (!maybe_buf.ToLocal(&buf)) {
          *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
        }
        return buf;
      }

    case ASCII:
      if (simdutf::validate_ascii_with_errors(buf, buflen).error) {
        // The input contains non-ASCII bytes.
        char* out = node::UncheckedMalloc(buflen);
        if (out == nullptr) {
          *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
          return MaybeLocal<Value>();
        }
        force_ascii(buf, out, buflen);
        return ExternOneByteString::New(isolate, out, buflen, error);
      } else {
        return ExternOneByteString::NewFromCopy(isolate, buf, buflen, error);
      }

    case UTF8:
      {
        val = String::NewFromUtf8(isolate,
                                  buf,
                                  v8::NewStringType::kNormal,
                                 ...",21,,570,2,,void
288414,BLOCK,3,,"{
        auto maybe_buf = Buffer::Copy(isolate, buf, buflen);
        Local<v8::Object> buf;
        if (!maybe_buf.ToLocal(&buf)) {
          *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
        }
        return buf;
      }",7,,572,3,,void
288440,BLOCK,-1,,"{
          *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
        }",39,,575,2,,void
288462,BLOCK,-1,,"{
        // The input contains non-ASCII bytes.
        char* out = node::UncheckedMalloc(buflen);
        if (out == nullptr) {
          *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
          return MaybeLocal<Value>();
        }
        force_ascii(buf, out, buflen);
        return ExternOneByteString::New(isolate, out, buflen, error);
      }",67,,582,2,,void
288475,BLOCK,-1,,"{
          *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
          return MaybeLocal<Value>();
        }",29,,585,2,,void
288500,BLOCK,-1,,"{
        return ExternOneByteString::NewFromCopy(isolate, buf, buflen, error);
      }",14,,591,1,,void
288512,BLOCK,9,,"{
        val = String::NewFromUtf8(isolate,
                                  buf,
                                  v8::NewStringType::kNormal,
                                  buflen);
        Local<String> str;
        if (!val.ToLocal(&str)) {
          *error = node::ERR_STRING_TOO_LONG(isolate);
        }
        return str;
      }",7,,596,9,,void
288540,BLOCK,-1,,"{
          *error = node::ERR_STRING_TOO_LONG(isolate);
        }",33,,602,2,,void
288564,BLOCK,15,,"{
      size_t dlen = base64_encoded_size(buflen);
      char* dst = node::UncheckedMalloc(dlen);
      if (dst == nullptr) {
        *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
        return MaybeLocal<Value>();
      }

      size_t written = base64_encode(buf, buflen, dst, dlen);
      CHECK_EQ(written, dlen);

      return ExternOneByteString::New(isolate, dst, dlen, error);
    }",18,,611,15,,void
288582,BLOCK,-1,,"{
        *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
        return MaybeLocal<Value>();
      }",27,,614,2,,void
288615,BLOCK,18,,"{
      size_t dlen = base64_encoded_size(buflen, Base64Mode::URL);
      char* dst = node::UncheckedMalloc(dlen);
      if (dst == nullptr) {
        *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
        return MaybeLocal<Value>();
      }

      size_t written = base64_encode(buf, buflen, dst, dlen, Base64Mode::URL);
      CHECK_EQ(written, dlen);

      return ExternOneByteString::New(isolate, dst, dlen, error);
    }",21,,625,18,,void
288636,BLOCK,-1,,"{
        *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
        return MaybeLocal<Value>();
      }",27,,628,2,,void
288672,BLOCK,21,,"{
      size_t dlen = buflen * 2;
      char* dst = node::UncheckedMalloc(dlen);
      if (dst == nullptr) {
        *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
        return MaybeLocal<Value>();
      }
      size_t written = hex_encode(buf, buflen, dst, dlen);
      CHECK_EQ(written, dlen);

      return ExternOneByteString::New(isolate, dst, dlen, error);
    }",15,,639,21,,void
288691,BLOCK,-1,,"{
        *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
        return MaybeLocal<Value>();
      }",27,,642,2,,void
288724,BLOCK,24,,"{
      size_t str_len = buflen / 2;
      if (IsBigEndian()) {
        uint16_t* dst = node::UncheckedMalloc<uint16_t>(str_len);
        if (str_len != 0 && dst == nullptr) {
          *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
          return MaybeLocal<Value>();
        }
        for (size_t i = 0, k = 0; k < str_len; i += 2, k += 1) {
          // The input is in *little endian*, because that's what Node.js
          // expects, so the high byte comes after the low byte.
          const uint8_t hi = static_cast<uint8_t>(buf[i + 1]);
          const uint8_t lo = static_cast<uint8_t>(buf[i + 0]);
          dst[k] = static_cast<uint16_t>(hi) << 8 | lo;
        }
        return ExternTwoByteString::New(isolate, dst, str_len, error);
      }
      if (reinterpret_cast<uintptr_t>(buf) % 2 != 0) {
        // Unaligned data still means we can't directly pass it to V8.
        char* dst = node::UncheckedMalloc(buflen);
        if (dst == nullptr) {
          *error = node::ER...",16,,652,24,,void
288733,BLOCK,-1,,"{
        uint16_t* dst = node::UncheckedMalloc<uint16_t>(str_len);
        if (str_len != 0 && dst == nullptr) {
          *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
          return MaybeLocal<Value>();
        }
        for (size_t i = 0, k = 0; k < str_len; i += 2, k += 1) {
          // The input is in *little endian*, because that's what Node.js
          // expects, so the high byte comes after the low byte.
          const uint8_t hi = static_cast<uint8_t>(buf[i + 1]);
          const uint8_t lo = static_cast<uint8_t>(buf[i + 0]);
          dst[k] = static_cast<uint16_t>(hi) << 8 | lo;
        }
        return ExternTwoByteString::New(isolate, dst, str_len, error);
      }",26,,654,2,,void
288752,BLOCK,-1,,"{
          *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
          return MaybeLocal<Value>();
        }",45,,656,2,,void
288764,BLOCK,-1,,<empty>,9,,660,1,,void
288783,BLOCK,4,,"{
          // The input is in *little endian*, because that's what Node.js
          // expects, so the high byte comes after the low byte.
          const uint8_t hi = static_cast<uint8_t>(buf[i + 1]);
          const uint8_t lo = static_cast<uint8_t>(buf[i + 0]);
          dst[k] = static_cast<uint16_t>(hi) << 8 | lo;
        }",64,,660,4,,void
288832,BLOCK,-1,,"{
        // Unaligned data still means we can't directly pass it to V8.
        char* dst = node::UncheckedMalloc(buflen);
        if (dst == nullptr) {
          *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
          return MaybeLocal<Value>();
        }
        memcpy(dst, buf, buflen);
        return ExternTwoByteString::New(
            isolate, reinterpret_cast<uint16_t*>(dst), str_len, error);
      }",54,,669,2,,void
288845,BLOCK,-1,,"{
          *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
          return MaybeLocal<Value>();
        }",29,,672,2,,void
288892,BLOCK,-1,,"{
  if (buflen == 0) return String::Empty(isolate);
  CHECK_BUFLEN_IN_RANGE(buflen);

  // Node's ""ucs2"" encoding expects LE character data inside a
  // Buffer, so we need to reorder on BE platforms.  See
  // https://nodejs.org/api/buffer.html regarding Node's ""ucs2""
  // encoding specification
  if (IsBigEndian()) {
    uint16_t* dst = node::UncheckedMalloc<uint16_t>(buflen);
    if (dst == nullptr) {
      *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
      return MaybeLocal<Value>();
    }
    size_t nbytes = buflen * sizeof(uint16_t);
    memcpy(dst, buf, nbytes);
    SwapBytes16(reinterpret_cast<char*>(dst), nbytes);
    return ExternTwoByteString::New(isolate, dst, buflen, error);
  } else {
    return ExternTwoByteString::NewFromCopy(isolate, buf, buflen, error);
  }
}",60,,693,5,,void
288897,BLOCK,-1,,<empty>,20,,694,2,,void
288906,BLOCK,1,,<empty>,,,,2,,void
288908,BLOCK,-1,,CHECK_BUFLEN_IN_RANGE(buflen),3,,695,1,,void
288915,BLOCK,-1,,CHECK_BUFLEN_IN_RANGE(buflen),3,,695,2,,void
288929,BLOCK,-1,,"{
    uint16_t* dst = node::UncheckedMalloc<uint16_t>(buflen);
    if (dst == nullptr) {
      *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
      return MaybeLocal<Value>();
    }
    size_t nbytes = buflen * sizeof(uint16_t);
    memcpy(dst, buf, nbytes);
    SwapBytes16(reinterpret_cast<char*>(dst), nbytes);
    return ExternTwoByteString::New(isolate, dst, buflen, error);
  }",22,,701,2,,void
288944,BLOCK,-1,,"{
      *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
      return MaybeLocal<Value>();
    }",25,,703,2,,void
288981,BLOCK,-1,,"{
    return ExternTwoByteString::NewFromCopy(isolate, buf, buflen, error);
  }",10,,711,1,,void
288998,BLOCK,-1,,"{
  const size_t len = strlen(buf);
  return Encode(isolate, buf, len, encoding, error);
}",60,,719,5,,void
289023,BLOCK,-1,,<empty>,1,,1,1,,ANY
289030,BLOCK,-1,,<empty>,1,,1,1,,ANY
289051,BLOCK,-1,,<empty>,1,,1,1,,ANY
289059,BLOCK,-1,,"{
  Local<Value> error;
  MaybeLocal<Value> ret;
  if (encoding == UTF8) {
    MaybeLocal<String> utf8_string = String::NewFromUtf8(
        isolate,
        data,
        v8::NewStringType::kNormal,
        length);
    if (utf8_string.IsEmpty()) {
      isolate->ThrowException(node::ERR_STRING_TOO_LONG(isolate));
      return MaybeLocal<String>();
    } else {
      return utf8_string;
    }
  } else {
    ret = StringBytes::Encode(
        isolate,
        data,
        length,
        encoding,
        &error);
  }

  if (ret.IsEmpty()) {
    CHECK(!error.IsEmpty());
    isolate->ThrowException(error);
  }

  DCHECK(ret.IsEmpty() || ret.ToLocalChecked()->IsString());
  return ret.FromMaybe(Local<Value>()).As<String>();
}",55,,30,5,,void
289074,BLOCK,-1,,"{
    MaybeLocal<String> utf8_string = String::NewFromUtf8(
        isolate,
        data,
        v8::NewStringType::kNormal,
        length);
    if (utf8_string.IsEmpty()) {
      isolate->ThrowException(node::ERR_STRING_TOO_LONG(isolate));
      return MaybeLocal<String>();
    } else {
      return utf8_string;
    }
  }",25,,33,2,,void
289098,BLOCK,-1,,"{
      isolate->ThrowException(node::ERR_STRING_TOO_LONG(isolate));
      return MaybeLocal<String>();
    }",32,,39,2,,void
289111,BLOCK,-1,,"{
      return utf8_string;
    }",12,,42,1,,void
289115,BLOCK,-1,,"{
    ret = StringBytes::Encode(
        isolate,
        data,
        length,
        encoding,
        &error);
  }",10,,45,1,,void
289133,BLOCK,-1,,"{
    CHECK(!error.IsEmpty());
    isolate->ThrowException(error);
  }",22,,54,2,,void
289173,BLOCK,-1,,"{
  Local<String> prepend, body;

  size_t nread = *nread_ptr;

  if (Encoding() == UTF8 ||
      Encoding() == UCS2 ||
      Encoding() == BASE64 ||
      Encoding() == BASE64URL) {
    // See if we want bytes to finish a character from the previous
    // chunk; if so, copy the new bytes to the missing bytes buffer
    // and create a small string from it that is to be prepended to the
    // main body.
    if (MissingBytes() > 0) {
      // There are never more bytes missing than the pre-calculated maximum.
      CHECK_LE(MissingBytes() + BufferedBytes(),
               kIncompleteCharactersEnd);
      if (Encoding() == UTF8) {
        // For UTF-8, we need special treatment to align with the V8 decoder:
        // If an incomplete character is found at a chunk boundary, we use
        // its remainder and pass it to V8 as-is.
        for (size_t i = 0; i < nread && i < MissingBytes(); ++i) {
          if ((data[i] & 0xC0) != 0x80) {
            // This byte is not a continuation...",65,,68,4,,void
289197,BLOCK,-1,,"{
    // See if we want bytes to finish a character from the previous
    // chunk; if so, copy the new bytes to the missing bytes buffer
    // and create a small string from it that is to be prepended to the
    // main body.
    if (MissingBytes() > 0) {
      // There are never more bytes missing than the pre-calculated maximum.
      CHECK_LE(MissingBytes() + BufferedBytes(),
               kIncompleteCharactersEnd);
      if (Encoding() == UTF8) {
        // For UTF-8, we need special treatment to align with the V8 decoder:
        // If an incomplete character is found at a chunk boundary, we use
        // its remainder and pass it to V8 as-is.
        for (size_t i = 0; i < nread && i < MissingBytes(); ++i) {
          if ((data[i] & 0xC0) != 0x80) {
            // This byte is not a continuation byte even though it should have
            // been one. We stop decoding of the incomplete character at this
            // point (but still use the rest of the incomplete bytes f...",32,,76,2,,void
289202,BLOCK,-1,,"{
      // There are never more bytes missing than the pre-calculated maximum.
      CHECK_LE(MissingBytes() + BufferedBytes(),
               kIncompleteCharactersEnd);
      if (Encoding() == UTF8) {
        // For UTF-8, we need special treatment to align with the V8 decoder:
        // If an incomplete character is found at a chunk boundary, we use
        // its remainder and pass it to V8 as-is.
        for (size_t i = 0; i < nread && i < MissingBytes(); ++i) {
          if ((data[i] & 0xC0) != 0x80) {
            // This byte is not a continuation byte even though it should have
            // been one. We stop decoding of the incomplete character at this
            // point (but still use the rest of the incomplete bytes from this
            // chunk) and assume that the new, unexpected byte starts a new one.
            state_[kMissingBytes] = 0;
            memcpy(IncompleteCharacterBuffer() + BufferedBytes(), data, i);
            state_[kBufferedBytes] += i;
          ...",29,,81,2,,void
289212,BLOCK,-1,,"{
        // For UTF-8, we need special treatment to align with the V8 decoder:
        // If an incomplete character is found at a chunk boundary, we use
        // its remainder and pass it to V8 as-is.
        for (size_t i = 0; i < nread && i < MissingBytes(); ++i) {
          if ((data[i] & 0xC0) != 0x80) {
            // This byte is not a continuation byte even though it should have
            // been one. We stop decoding of the incomplete character at this
            // point (but still use the rest of the incomplete bytes from this
            // chunk) and assume that the new, unexpected byte starts a new one.
            state_[kMissingBytes] = 0;
            memcpy(IncompleteCharacterBuffer() + BufferedBytes(), data, i);
            state_[kBufferedBytes] += i;
            data += i;
            nread -= i;
            break;
          }
        }
      }",31,,85,2,,void
289214,BLOCK,-1,,<empty>,9,,89,1,,void
289228,BLOCK,4,,"{
          if ((data[i] & 0xC0) != 0x80) {
            // This byte is not a continuation byte even though it should have
            // been one. We stop decoding of the incomplete character at this
            // point (but still use the rest of the incomplete bytes from this
            // chunk) and assume that the new, unexpected byte starts a new one.
            state_[kMissingBytes] = 0;
            memcpy(IncompleteCharacterBuffer() + BufferedBytes(), data, i);
            state_[kBufferedBytes] += i;
            data += i;
            nread -= i;
            break;
          }
        }",66,,89,4,,void
289237,BLOCK,-1,,"{
            // This byte is not a continuation byte even though it should have
            // been one. We stop decoding of the incomplete character at this
            // point (but still use the rest of the incomplete bytes from this
            // chunk) and assume that the new, unexpected byte starts a new one.
            state_[kMissingBytes] = 0;
            memcpy(IncompleteCharacterBuffer() + BufferedBytes(), data, i);
            state_[kBufferedBytes] += i;
            data += i;
            nread -= i;
            break;
          }",41,,90,2,,void
289299,BLOCK,-1,,"{
        // If no more bytes are missing, create a small string that we
        // will later prepend.
        if (!MakeString(isolate,
                        IncompleteCharacterBuffer(),
                        BufferedBytes(),
                        Encoding()).ToLocal(&prepend)) {
          return MaybeLocal<String>();
        }

        *nread_ptr += BufferedBytes();
        // No more buffered bytes.
        state_[kBufferedBytes] = 0;
      }",40,,117,2,,void
289312,BLOCK,-1,,"{
          return MaybeLocal<String>();
        }",56,,123,2,,void
289329,BLOCK,-1,,"{
      body = !prepend.IsEmpty() ? prepend : String::Empty(isolate);
      prepend = Local<String>();
    }",31,,135,2,,void
289348,BLOCK,-1,,"{
      // If not, that means is no character left to finish at this point.
      DCHECK_EQ(MissingBytes(), 0);
      DCHECK_EQ(BufferedBytes(), 0);

      // See whether there is a character that we may have to cut off and
      // finish when receiving the next chunk.
      if (Encoding() == UTF8 && data[nread - 1] & 0x80) {
        // This is UTF-8 encoded data and we ended on a non-ASCII UTF-8 byte.
        // This means we'll need to figure out where the character to which
        // the byte belongs begins.
        for (size_t i = nread - 1; ; --i) {
          DCHECK_LT(i, nread);
          state_[kBufferedBytes]++;
          if ((data[i] & 0xC0) == 0x80) {
            // This byte does not start a character (a ""trailing"" byte).
            if (state_[kBufferedBytes] >= 4 || i == 0) {
              // We either have more then 4 trailing bytes (which means
              // the current character would not be inside the range for
              // valid Unicode, and in particular ...",12,,138,1,,void
289367,BLOCK,-1,,"{
        // This is UTF-8 encoded data and we ended on a non-ASCII UTF-8 byte.
        // This means we'll need to figure out where the character to which
        // the byte belongs begins.
        for (size_t i = nread - 1; ; --i) {
          DCHECK_LT(i, nread);
          state_[kBufferedBytes]++;
          if ((data[i] & 0xC0) == 0x80) {
            // This byte does not start a character (a ""trailing"" byte).
            if (state_[kBufferedBytes] >= 4 || i == 0) {
              // We either have more then 4 trailing bytes (which means
              // the current character would not be inside the range for
              // valid Unicode, and in particular cannot be represented
              // through JavaScript's UTF-16-based approach to strings), or the
              // current buffer does not contain the start of an UTF-8 character
              // at all. Either way, this is invalid UTF8 and we can just
              // let the engine's decoder handle it.
              sta...",57,,145,2,,void
289369,BLOCK,-1,,<empty>,9,,149,1,,void
289378,BLOCK,4,,"{
          DCHECK_LT(i, nread);
          state_[kBufferedBytes]++;
          if ((data[i] & 0xC0) == 0x80) {
            // This byte does not start a character (a ""trailing"" byte).
            if (state_[kBufferedBytes] >= 4 || i == 0) {
              // We either have more then 4 trailing bytes (which means
              // the current character would not be inside the range for
              // valid Unicode, and in particular cannot be represented
              // through JavaScript's UTF-16-based approach to strings), or the
              // current buffer does not contain the start of an UTF-8 character
              // at all. Either way, this is invalid UTF8 and we can just
              // let the engine's decoder handle it.
              state_[kBufferedBytes] = 0;
              break;
            }
          } else {
            // Found the first byte of a UTF-8 character. By looking at the
            // upper bits we can tell how long the character *should* be.
     ...",43,,149,4,,void
289394,BLOCK,-1,,"{
            // This byte does not start a character (a ""trailing"" byte).
            if (state_[kBufferedBytes] >= 4 || i == 0) {
              // We either have more then 4 trailing bytes (which means
              // the current character would not be inside the range for
              // valid Unicode, and in particular cannot be represented
              // through JavaScript's UTF-16-based approach to strings), or the
              // current buffer does not contain the start of an UTF-8 character
              // at all. Either way, this is invalid UTF8 and we can just
              // let the engine's decoder handle it.
              state_[kBufferedBytes] = 0;
              break;
            }
          }",41,,152,2,,void
289405,BLOCK,-1,,"{
              // We either have more then 4 trailing bytes (which means
              // the current character would not be inside the range for
              // valid Unicode, and in particular cannot be represented
              // through JavaScript's UTF-16-based approach to strings), or the
              // current buffer does not contain the start of an UTF-8 character
              // at all. Either way, this is invalid UTF8 and we can just
              // let the engine's decoder handle it.
              state_[kBufferedBytes] = 0;
              break;
            }",56,,154,2,,void
289413,BLOCK,-1,,"{
            // Found the first byte of a UTF-8 character. By looking at the
            // upper bits we can tell how long the character *should* be.
            if ((data[i] & 0xE0) == 0xC0) {
              state_[kMissingBytes] = 2;
            } else if ((data[i] & 0xF0) == 0xE0) {
              state_[kMissingBytes] = 3;
            } else if ((data[i] & 0xF8) == 0xF0) {
              state_[kMissingBytes] = 4;
            } else {
              // This lead byte would indicate a character outside of the
              // representable range.
              state_[kBufferedBytes] = 0;
              break;
            }

            if (BufferedBytes() >= MissingBytes()) {
              // Received more or exactly as many trailing bytes than the lead
              // character would indicate. In the ""=="" case, we have valid
              // data and don't need to slice anything off;
              // in the "">"" case, this is invalid UTF-8 anyway.
              state_[kMissingBytes...",18,,165,1,,void
289422,BLOCK,-1,,"{
              state_[kMissingBytes] = 2;
            }",43,,168,2,,void
289429,BLOCK,-1,,<empty>,20,,170,1,,void
289438,BLOCK,-1,,"{
              state_[kMissingBytes] = 3;
            }",50,,170,2,,void
289445,BLOCK,-1,,<empty>,20,,172,1,,void
289454,BLOCK,-1,,"{
              state_[kMissingBytes] = 4;
            }",50,,172,2,,void
289461,BLOCK,-1,,"{
              // This lead byte would indicate a character outside of the
              // representable range.
              state_[kBufferedBytes] = 0;
              break;
            }",20,,174,1,,void
289472,BLOCK,-1,,"{
              // Received more or exactly as many trailing bytes than the lead
              // character would indicate. In the ""=="" case, we have valid
              // data and don't need to slice anything off;
              // in the "">"" case, this is invalid UTF-8 anyway.
              state_[kMissingBytes] = 0;
              state_[kBufferedBytes] = 0;
            }",52,,181,2,,void
289492,BLOCK,-1,,<empty>,14,,194,1,,void
289497,BLOCK,-1,,"{
        if ((nread % 2) == 1) {
          // We got half a codepoint, and need the second byte of it.
          state_[kBufferedBytes] = 1;
          state_[kMissingBytes] = 1;
        } else if ((data[nread - 1] & 0xFC) == 0xD8) {
          // Half a split UTF-16 character.
          state_[kBufferedBytes] = 2;
          state_[kMissingBytes] = 2;
        }
      }",38,,194,2,,void
289504,BLOCK,-1,,"{
          // We got half a codepoint, and need the second byte of it.
          state_[kBufferedBytes] = 1;
          state_[kMissingBytes] = 1;
        }",31,,195,2,,void
289516,BLOCK,-1,,<empty>,16,,199,1,,void
289527,BLOCK,-1,,"{
          // Half a split UTF-16 character.
          state_[kBufferedBytes] = 2;
          state_[kMissingBytes] = 2;
        }",54,,199,2,,void
289539,BLOCK,-1,,<empty>,14,,204,1,,void
289548,BLOCK,-1,,"{
        state_[kBufferedBytes] = nread % 3;
        if (state_[kBufferedBytes] > 0)
          state_[kMissingBytes] = 3 - BufferedBytes();
      }",67,,204,2,,void
289562,BLOCK,-1,,<empty>,11,,207,2,,void
289574,BLOCK,-1,,"{
        // Copy the requested number of buffered bytes from the end of the
        // input into the incomplete character buffer.
        nread -= BufferedBytes();
        *nread_ptr -= BufferedBytes();
        memcpy(IncompleteCharacterBuffer(), data + nread, BufferedBytes());
      }",32,,210,2,,void
289592,BLOCK,-1,,"{
        if (!MakeString(isolate, data, nread, Encoding()).ToLocal(&body))
          return MaybeLocal<String>();
      }",22,,218,2,,void
289605,BLOCK,-1,,<empty>,11,,220,2,,void
289609,BLOCK,-1,,"{
        body = String::Empty(isolate);
      }",14,,221,1,,void
289622,BLOCK,-1,,"{
      return body;
    }",28,,226,2,,void
289626,BLOCK,-1,,"{
      return String::Concat(isolate, prepend, body);
    }",12,,228,1,,void
289636,BLOCK,-1,,"{
    CHECK(Encoding() == ASCII || Encoding() == HEX || Encoding() == LATIN1);
    return MakeString(isolate, data, nread, Encoding());
  }",10,,231,1,,void
289659,BLOCK,-1,,"{
  if (Encoding() == ASCII || Encoding() == HEX || Encoding() == LATIN1) {
    CHECK_EQ(MissingBytes(), 0);
    CHECK_EQ(BufferedBytes(), 0);
  }

  if (Encoding() == UCS2 && BufferedBytes() % 2 == 1) {
    // Ignore a single trailing byte, like the JS decoder does.
    state_[kMissingBytes]--;
    state_[kBufferedBytes]--;
  }

  if (BufferedBytes() == 0)
    return String::Empty(isolate);

  MaybeLocal<String> ret =
      MakeString(isolate,
                 IncompleteCharacterBuffer(),
                 BufferedBytes(),
                 Encoding());

  state_[kMissingBytes] = 0;
  state_[kBufferedBytes] = 0;

  return ret;
}",63,,237,2,,void
289672,BLOCK,-1,,"{
    CHECK_EQ(MissingBytes(), 0);
    CHECK_EQ(BufferedBytes(), 0);
  }",73,,238,2,,void
289689,BLOCK,-1,,"{
    // Ignore a single trailing byte, like the JS decoder does.
    state_[kMissingBytes]--;
    state_[kBufferedBytes]--;
  }",55,,243,2,,void
289702,BLOCK,-1,,<empty>,5,,250,2,,void
289737,BLOCK,-1,,"{
  StringDecoder* decoder =
      reinterpret_cast<StringDecoder*>(Buffer::Data(args[0]));
  CHECK_NOT_NULL(decoder);

  CHECK(args[1]->IsArrayBufferView());
  ArrayBufferViewContents<char> content(args[1].As<ArrayBufferView>());
  size_t length = content.length();

  MaybeLocal<String> ret =
      decoder->DecodeData(args.GetIsolate(), content.data(), &length);
  if (!ret.IsEmpty())
    args.GetReturnValue().Set(ret.ToLocalChecked());
}",58,,266,2,,void
289800,BLOCK,-1,,<empty>,5,,278,2,,void
289816,BLOCK,-1,,"{
  StringDecoder* decoder =
      reinterpret_cast<StringDecoder*>(Buffer::Data(args[0]));
  CHECK_NOT_NULL(decoder);
  MaybeLocal<String> ret = decoder->FlushData(args.GetIsolate());
  if (!ret.IsEmpty())
    args.GetReturnValue().Set(ret.ToLocalChecked());
}",57,,281,2,,void
289851,BLOCK,-1,,<empty>,5,,287,2,,void
289870,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

#define SET_DECODER_CONSTANT(name)                                            \
  target->Set(context,                                                        \
              FIXED_ONE_BYTE_STRING(isolate, #name),                          \
              Integer::New(isolate, StringDecoder::name)).FromJust()

  SET_DECODER_CONSTANT(kIncompleteCharactersStart);
  SET_DECODER_CONSTANT(kIncompleteCharactersEnd);
  SET_DECODER_CONSTANT(kMissingBytes);
  SET_DECODER_CONSTANT(kBufferedBytes);
  SET_DECODER_CONSTANT(kEncodingField);
  SET_DECODER_CONSTANT(kNumFields);

  Local<Array> encodings = Array::New(isolate);
#define ADD_TO_ENCODINGS_ARRAY(cname, jsname)                                 \
  encodings->Set(context,                                                     \
                 static_cast<int32_t>(cname),                                 \
                 FIXED_ONE_BYTE_STRING(isolate...",42,,293,5,,void
289887,BLOCK,1,,<empty>,,,,3,,void
289908,BLOCK,1,,<empty>,,,,3,,void
289929,BLOCK,1,,<empty>,,,,3,,void
289950,BLOCK,1,,<empty>,,,,3,,void
289971,BLOCK,1,,<empty>,,,,3,,void
289992,BLOCK,1,,<empty>,,,,3,,void
290026,BLOCK,1,,<empty>,,,,4,,void
290044,BLOCK,1,,<empty>,,,,4,,void
290062,BLOCK,1,,<empty>,,,,4,,void
290080,BLOCK,1,,<empty>,,,,4,,void
290098,BLOCK,1,,<empty>,,,,4,,void
290116,BLOCK,1,,<empty>,,,,4,,void
290134,BLOCK,1,,<empty>,,,,4,,void
290152,BLOCK,1,,<empty>,,,,4,,void
290211,BLOCK,-1,,"{
  registry->Register(DecodeData);
  registry->Register(FlushData);
}",42,,338,2,,void
290231,BLOCK,-1,,<empty>,1,,1,1,,ANY
290242,BLOCK,-1,,<empty>,1,,1,1,,ANY
290247,BLOCK,-1,,"{
      return uv_ip4_addr(ip_address, port, addr);
  }",74,,300,3,,void
290261,BLOCK,-1,,"{
      return uv_ip6_addr(ip_address, port, addr);
  }",76,,312,3,,void
290297,BLOCK,-1,,<empty>,1,,1,1,,ANY
290303,BLOCK,-1,,"{
  EscapableHandleScope handle_scope(env->isolate());
  AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(parent);
  CHECK_EQ(env->tcp_constructor_template().IsEmpty(), false);
  Local<Function> constructor = env->tcp_constructor_template()
                                    ->GetFunction(env->context())
                                    .ToLocalChecked();
  CHECK_EQ(constructor.IsEmpty(), false);
  Local<Value> type_value = Int32::New(env->isolate(), type);
  return handle_scope.EscapeMaybe(
      constructor->NewInstance(env->context(), 1, &type_value));
}",67,,58,4,,void
290386,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);
  t->InstanceTemplate()->SetInternalFieldCount(StreamBase::kInternalFieldCount);

  // Init properties
  t->InstanceTemplate()->Set(FIXED_ONE_BYTE_STRING(env->isolate(), ""reading""),
                             Boolean::New(env->isolate(), false));
  t->InstanceTemplate()->Set(env->owner_symbol(), Null(env->isolate()));
  t->InstanceTemplate()->Set(env->onconnection_string(), Null(env->isolate()));

  t->Inherit(LibuvStreamWrap::GetConstructorTemplate(env));

  SetProtoMethod(isolate, t, ""open"", Open);
  SetProtoMethod(isolate, t, ""bind"", Bind);
  SetProtoMethod(isolate, t, ""listen"", Listen);
  SetProtoMethod(isolate, t, ""connect"", Connect);
  SetProtoMethod(isolate, t, ""bind6"", Bind6);
  SetProtoMethod(isolate, t, ""connect6"", Connect6);
  SetProtoMethod(isolate,
                 t,
                 ""getsockname"",
           ...",38,,75,5,,void
290593,BLOCK,1,,<empty>,,,,7,,void
290595,BLOCK,-1,,"NODE_DEFINE_CONSTANT(constants, SOCKET)",3,,123,1,,void
290692,BLOCK,1,,<empty>,,,,7,,void
290694,BLOCK,-1,,"NODE_DEFINE_CONSTANT(constants, SERVER)",3,,124,1,,void
290791,BLOCK,1,,<empty>,,,,7,,void
290793,BLOCK,-1,,"NODE_DEFINE_CONSTANT(constants, UV_TCP_IPV6ONLY)",3,,125,1,,void
290902,BLOCK,-1,,"{
  registry->Register(New);
  registry->Register(Open);
  registry->Register(Bind);
  registry->Register(Listen);
  registry->Register(Connect);
  registry->Register(Bind6);
  registry->Register(Connect6);

  registry->Register(GetSockOrPeerName<TCPWrap, uv_tcp_getsockname>);
  registry->Register(GetSockOrPeerName<TCPWrap, uv_tcp_getpeername>);
  registry->Register(SetNoDelay);
  registry->Register(SetKeepAlive);
  registry->Register(Reset);
#ifdef _WIN32
  registry->Register(SetSimultaneousAccepts);
#endif
}",79,,131,2,,void
290967,BLOCK,-1,,"{
  // This constructor should not be exposed to public javascript.
  // Therefore we assert that we are not trying to call this as a
  // normal function.
  CHECK(args.IsConstructCall());
  CHECK(args[0]->IsInt32());
  Environment* env = Environment::GetCurrent(args);

  int type_value = args[0].As<Int32>()->Value();
  TCPWrap::SocketType type = static_cast<TCPWrap::SocketType>(type_value);

  ProviderType provider;
  switch (type) {
    case SOCKET:
      provider = PROVIDER_TCPWRAP;
      break;
    case SERVER:
      provider = PROVIDER_TCPSERVERWRAP;
      break;
    default:
      UNREACHABLE();
  }

  new TCPWrap(env, args.This(), provider);
}",60,,150,2,,void
291009,BLOCK,-1,,"{
    case SOCKET:
      provider = PROVIDER_TCPWRAP;
      break;
    case SERVER:
      provider = PROVIDER_TCPSERVERWRAP;
      break;
    default:
      UNREACHABLE();
  }",17,,162,2,,void
291038,BLOCK,-1,,"{
  int r = uv_tcp_init(env->event_loop(), &handle_);
  CHECK_EQ(r, 0);  // How do we proxy this error up to javascript?
                   // Suggestion: uv_tcp_init() returns void.
}",45,,178,4,,void
291056,BLOCK,-1,,"{
  TCPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));
  int enable = static_cast<int>(args[0]->IsTrue());
  int err = uv_tcp_nodelay(&wrap->handle_, enable);
  args.GetReturnValue().Set(err);
}",67,,185,2,,void
291105,BLOCK,-1,,"{
  TCPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));
  Environment* env = wrap->env();
  int enable;
  if (!args[0]->Int32Value(env->context()).To(&enable)) return;
  unsigned int delay = static_cast<unsigned int>(args[1].As<Uint32>()->Value());
  int err = uv_tcp_keepalive(&wrap->handle_, enable, delay);
  args.GetReturnValue().Set(err);
}",69,,196,2,,void
291147,BLOCK,-1,,<empty>,57,,203,2,,void
291185,BLOCK,-1,,"{
  TCPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));
  int64_t val;
  if (!args[0]->IntegerValue(args.GetIsolate()->GetCurrentContext()).To(&val))
    return;
  int fd = static_cast<int>(val);
  int err = uv_tcp_open(&wrap->handle_, fd);

  if (err == 0)
    wrap->set_fd(fd);

  args.GetReturnValue().Set(err);
}",61,,223,2,,void
291223,BLOCK,-1,,<empty>,5,,230,2,,void
291244,BLOCK,-1,,<empty>,5,,235,2,,void
291264,BLOCK,-1,,"{
  TCPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));
  Environment* env = wrap->env();
  node::Utf8Value ip_address(env->isolate(), args[0]);
  int port;
  unsigned int flags = 0;
  if (!args[1]->Int32Value(env->context()).To(&port)) return;
  if (family == AF_INET6 &&
      !args[2]->Uint32Value(env->context()).To(&flags)) {
    return;
  }

  T addr;
  int err = uv_ip_addr(*ip_address, port, &addr);

  if (err == 0) {
    err = uv_tcp_bind(&wrap->handle_,
                      reinterpret_cast<const sockaddr*>(&addr),
                      flags);
  }
  args.GetReturnValue().Set(err);
}",79,,244,4,,void
291319,BLOCK,-1,,<empty>,55,,253,2,,void
291342,BLOCK,-1,,"{
    return;
  }",57,,255,2,,void
291358,BLOCK,-1,,"{
    err = uv_tcp_bind(&wrap->handle_,
                      reinterpret_cast<const sockaddr*>(&addr),
                      flags);
  }",17,,262,2,,void
291383,BLOCK,-1,,"{
  Bind<sockaddr_in>(args, AF_INET, uv_ip4_addr);
}",61,,270,2,,void
291397,BLOCK,-1,,"{
  Bind<sockaddr_in6>(args, AF_INET6, uv_ip6_addr);
}",62,,275,2,,void
291411,BLOCK,-1,,"{
  TCPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));
  Environment* env = wrap->env();
  int backlog;
  if (!args[0]->Int32Value(env->context()).To(&backlog)) return;
  int err = uv_listen(reinterpret_cast<uv_stream_t*>(&wrap->handle_),
                      backlog,
                      OnConnection);
  args.GetReturnValue().Set(err);
}",63,,280,2,,void
291453,BLOCK,-1,,<empty>,58,,287,2,,void
291479,BLOCK,-1,,"{
  CHECK(args[2]->IsUint32());
  // explicit cast to fit to libuv's type expectation
  int port = static_cast<int>(args[2].As<Uint32>()->Value());
  Connect<sockaddr_in>(args,
                       [port](const char* ip_address, sockaddr_in* addr) {
      return uv_ip4_addr(ip_address, port, addr);
  });
}",64,,295,2,,void
291512,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[2]->IsUint32());
  int port;
  if (!args[2]->Int32Value(env->context()).To(&port)) return;
  Connect<sockaddr_in6>(args,
                        [port](const char* ip_address, sockaddr_in6* addr) {
      return uv_ip6_addr(ip_address, port, addr);
  });
}",65,,306,2,,void
291545,BLOCK,-1,,<empty>,55,,310,2,,void
291560,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  TCPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));

  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsString());

  Local<Object> req_wrap_obj = args[0].As<Object>();
  node::Utf8Value ip_address(env->isolate(), args[1]);

  T addr;
  int err = uv_ip_addr(*ip_address, &addr);

  if (err == 0) {
    AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(wrap);
    ConnectWrap* req_wrap =
        new ConnectWrap(env, req_wrap_obj, AsyncWrap::PROVIDER_TCPCONNECTWRAP);
    err = req_wrap->Dispatch(uv_tcp_connect,
                             &wrap->handle_,
                             reinterpret_cast<const sockaddr*>(&addr),
                             AfterConnect);
    if (err) {
      delete req_wrap;
    } else {
      CHECK(args[2]->Uint32Value(env->context()).IsJust());
      int port = args[2]->Uint32Value(env->context()).F...",69,,319,3,,void
291633,BLOCK,-1,,"{
    AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(wrap);
    ConnectWrap* req_wrap =
        new ConnectWrap(env, req_wrap_obj, AsyncWrap::PROVIDER_TCPCONNECTWRAP);
    err = req_wrap->Dispatch(uv_tcp_connect,
                             &wrap->handle_,
                             reinterpret_cast<const sockaddr*>(&addr),
                             AfterConnect);
    if (err) {
      delete req_wrap;
    } else {
      CHECK(args[2]->Uint32Value(env->context()).IsJust());
      int port = args[2]->Uint32Value(env->context()).FromJust();
      TRACE_EVENT_NESTABLE_ASYNC_BEGIN2(TRACING_CATEGORY_NODE2(net, native),
                                        ""connect"",
                                        req_wrap,
                                        ""ip"",
                                        TRACE_STR_COPY(*ip_address),
                                        ""port"",
                                        port);
    }
  }",17,,336,2,,void
291665,BLOCK,-1,,"{
      delete req_wrap;
    }",14,,344,2,,void
291669,BLOCK,-1,,"{
      CHECK(args[2]->Uint32Value(env->context()).IsJust());
      int port = args[2]->Uint32Value(env->context()).FromJust();
      TRACE_EVENT_NESTABLE_ASYNC_BEGIN2(TRACING_CATEGORY_NODE2(net, native),
                                        ""connect"",
                                        req_wrap,
                                        ""ip"",
                                        TRACE_STR_COPY(*ip_address),
                                        ""port"",
                                        port);
    }",12,,346,1,,void
291724,BLOCK,-1,,"{
  TCPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(
      &wrap, args.Holder(), args.GetReturnValue().Set(UV_EBADF));

  int err = wrap->Reset(args[0]);

  args.GetReturnValue().Set(err);
}",62,,361,2,,void
291763,BLOCK,-1,,"{
  if (state_ != kInitialized) return 0;

  int err = uv_tcp_close_reset(&handle_, OnClose);
  state_ = kClosing;
  if (!err & !close_callback.IsEmpty() && close_callback->IsFunction() &&
      !persistent().IsEmpty()) {
    object()
        ->Set(env()->context(), env()->handle_onclose_symbol(), close_callback)
        .Check();
  }
  return err;
}",49,,371,2,,void
291768,BLOCK,-1,,<empty>,31,,372,2,,void
291801,BLOCK,-1,,"{
    object()
        ->Set(env()->context(), env()->handle_onclose_symbol(), close_callback)
        .Check();
  }",32,,377,2,,void
291826,BLOCK,-1,,"{
  EscapableHandleScope scope(env->isolate());
  char ip[INET6_ADDRSTRLEN + UV_IF_NAMESIZE];
  const sockaddr_in* a4;
  const sockaddr_in6* a6;

  int port;

  if (info.IsEmpty())
    info = Object::New(env->isolate());

  switch (addr->sa_family) {
  case AF_INET6:
    a6 = reinterpret_cast<const sockaddr_in6*>(addr);
    uv_inet_ntop(AF_INET6, &a6->sin6_addr, ip, sizeof ip);
    // Add an interface identifier to a link local address.
    if (IN6_IS_ADDR_LINKLOCAL(&a6->sin6_addr) && a6->sin6_scope_id > 0) {
      const size_t addrlen = strlen(ip);
      CHECK_LT(addrlen, sizeof(ip));
      ip[addrlen] = '%';
      size_t scopeidlen = sizeof(ip) - addrlen - 1;
      CHECK_GE(scopeidlen, UV_IF_NAMESIZE);
      const int r = uv_if_indextoiid(a6->sin6_scope_id,
                                     ip + addrlen + 1,
                                     &scopeidlen);
      if (r) {
        env->ThrowUVException(r, ""uv_if_indextoiid"");
        return {};
      }
    }
    port = ntohs(a6...",52,,388,4,,void
291842,BLOCK,-1,,<empty>,5,,397,2,,void
291857,BLOCK,-1,,"{
  case AF_INET6:
    a6 = reinterpret_cast<const sockaddr_in6*>(addr);
    uv_inet_ntop(AF_INET6, &a6->sin6_addr, ip, sizeof ip);
    // Add an interface identifier to a link local address.
    if (IN6_IS_ADDR_LINKLOCAL(&a6->sin6_addr) && a6->sin6_scope_id > 0) {
      const size_t addrlen = strlen(ip);
      CHECK_LT(addrlen, sizeof(ip));
      ip[addrlen] = '%';
      size_t scopeidlen = sizeof(ip) - addrlen - 1;
      CHECK_GE(scopeidlen, UV_IF_NAMESIZE);
      const int r = uv_if_indextoiid(a6->sin6_scope_id,
                                     ip + addrlen + 1,
                                     &scopeidlen);
      if (r) {
        env->ThrowUVException(r, ""uv_if_indextoiid"");
        return {};
      }
    }
    port = ntohs(a6->sin6_port);
    info->Set(env->context(),
              env->address_string(),
              OneByteString(env->isolate(), ip)).Check();
    info->Set(env->context(), env->family_string(), env->ipv6_string()).Check();
    info->Set(env->context(),...",28,,399,2,,void
291886,BLOCK,-1,,"{
      const size_t addrlen = strlen(ip);
      CHECK_LT(addrlen, sizeof(ip));
      ip[addrlen] = '%';
      size_t scopeidlen = sizeof(ip) - addrlen - 1;
      CHECK_GE(scopeidlen, UV_IF_NAMESIZE);
      const int r = uv_if_indextoiid(a6->sin6_scope_id,
                                     ip + addrlen + 1,
                                     &scopeidlen);
      if (r) {
        env->ThrowUVException(r, ""uv_if_indextoiid"");
        return {};
      }
    }",73,,404,2,,void
291929,BLOCK,-1,,"{
        env->ThrowUVException(r, ""uv_if_indextoiid"");
        return {};
      }",14,,413,2,,void
292136,BLOCK,-1,,<empty>,1,,1,1,,ANY
292147,BLOCK,-1,,<empty>,1,,1,1,,ANY
292160,BLOCK,-1,,<empty>,1,,1,1,,ANY
292175,BLOCK,-1,,<empty>,1,,1,1,,ANY
292178,BLOCK,-1,,"{
  if (timer_.data == nullptr) return;
  uv_timer_stop(&timer_);
}",24,,10,1,,void
292185,BLOCK,-1,,<empty>,31,,11,2,,void
292191,BLOCK,-1,,"{
  timer_.data = nullptr;
  env_->CloseHandle(reinterpret_cast<uv_handle_t*>(&timer_), TimerClosedCb);
}",25,,15,1,,void
292210,BLOCK,-1,,"{
  std::unique_ptr<TimerWrap> ptr(
      ContainerOf(&TimerWrap::timer_,
                  reinterpret_cast<uv_timer_t*>(handle)));
}",52,,20,2,,void
292231,BLOCK,-1,,"{
  if (timer_.data == nullptr) return;
  uv_timer_start(&timer_, OnTimeout, interval, repeat);
}",60,,26,3,,void
292238,BLOCK,-1,,<empty>,31,,27,2,,void
292249,BLOCK,-1,,"{
  if (timer_.data == nullptr) return;
  uv_ref(reinterpret_cast<uv_handle_t*>(&timer_));
}",23,,31,1,,void
292256,BLOCK,-1,,<empty>,31,,32,2,,void
292266,BLOCK,-1,,"{
  if (timer_.data == nullptr) return;
  uv_unref(reinterpret_cast<uv_handle_t*>(&timer_));
}",25,,36,1,,void
292273,BLOCK,-1,,<empty>,31,,37,2,,void
292284,BLOCK,-1,,"{
  TimerWrap* t = ContainerOf(&TimerWrap::timer_, timer);
  t->fn_();
}",46,,41,2,,void
292301,BLOCK,-1,,"{
  if (timer_ != nullptr)
    return timer_->Stop();
}",30,,46,1,,void
292306,BLOCK,-1,,<empty>,5,,48,2,,void
292315,BLOCK,-1,,"{
  if (timer_ != nullptr) {
    timer_->env()->RemoveCleanupHook(CleanupHook, this);
    timer_->Close();
  }
  timer_ = nullptr;
}",31,,51,1,,void
292320,BLOCK,-1,,"{
    timer_->env()->RemoveCleanupHook(CleanupHook, this);
    timer_->Close();
  }",26,,52,2,,void
292340,BLOCK,-1,,"{
  if (timer_ != nullptr)
    timer_->Ref();
}",29,,59,1,,void
292345,BLOCK,-1,,<empty>,5,,61,2,,void
292353,BLOCK,-1,,"{
  if (timer_ != nullptr)
    timer_->Unref();
}",31,,64,1,,void
292358,BLOCK,-1,,<empty>,5,,66,2,,void
292368,BLOCK,-1,,"{
  if (timer_ != nullptr)
    timer_->Update(interval, repeat);
}",66,,69,3,,void
292373,BLOCK,-1,,<empty>,5,,71,2,,void
292384,BLOCK,-1,,"{
  if (timer_ != nullptr)
    tracker->TrackField(""timer"", *timer_);
}",64,,74,2,,void
292389,BLOCK,-1,,<empty>,5,,76,2,,void
292401,BLOCK,-1,,"{
  static_cast<TimerWrapHandle*>(data)->Close();
}",47,,79,2,,void
292422,BLOCK,-1,,<empty>,1,,1,1,,ANY
292439,BLOCK,-1,,<empty>,1,,1,1,,ANY
292444,BLOCK,-1,,"{
  CHECK(args[0]->IsFunction());
  CHECK(args[1]->IsFunction());
  auto env = Environment::GetCurrent(args);

  env->set_immediate_callback_function(args[0].As<Function>());
  env->set_timers_callback_function(args[1].As<Function>());
}",72,,22,2,,void
292491,BLOCK,-1,,"{
  double now = GetLibuvNowImpl(Realm::GetBindingData<BindingData>(args));
  args.GetReturnValue().Set(Number::New(args.GetIsolate(), now));
}",76,,31,2,,void
292523,BLOCK,-1,,"{
  return GetLibuvNowImpl(FromJSObject<BindingData>(receiver));
}",61,,36,2,,void
292535,BLOCK,-1,,"{
  return static_cast<double>(data->env()->GetNowUint64());
}",56,,40,2,,void
292550,BLOCK,-1,,"{
  int64_t duration =
      args[0]->IntegerValue(args.GetIsolate()->GetCurrentContext()).FromJust();
  ScheduleTimerImpl(Realm::GetBindingData<BindingData>(args), duration);
}",78,,44,2,,void
292584,BLOCK,-1,,"{
  ScheduleTimerImpl(FromJSObject<BindingData>(receiver), duration);
}",79,,50,3,,void
292597,BLOCK,-1,,"{
  data->env()->ScheduleTimer(duration);
}",74,,54,3,,void
292610,BLOCK,-1,,"{
  ToggleTimerRefImpl(Realm::GetBindingData<BindingData>(args),
                     args[0]->IsTrue());
}",54,,59,2,,void
292630,BLOCK,-1,,"{
  ToggleTimerRefImpl(FromJSObject<BindingData>(receiver), ref);
}",72,,64,3,,void
292643,BLOCK,-1,,"{
  data->env()->ToggleTimerRef(ref);
}",67,,68,3,,void
292656,BLOCK,-1,,"{
  ToggleImmediateRefImpl(Realm::GetBindingData<BindingData>(args),
                         args[0]->IsTrue());
}",54,,73,2,,void
292676,BLOCK,-1,,"{
  ToggleImmediateRefImpl(FromJSObject<BindingData>(receiver), ref);
}",76,,78,3,,void
292689,BLOCK,-1,,"{
  data->env()->ToggleImmediateRef(ref);
}",71,,82,3,,void
292703,BLOCK,-1,,<empty>,51,,87,3,,void
292709,BLOCK,-1,,"{
  // Return true because we need to maintain the reference to the binding from
  // JS land.
  return true;
}",73,,90,3,,void
292716,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  InternalFieldInfo* info =
      InternalFieldInfoBase::New<InternalFieldInfo>(type());
  return info;
}",58,,96,2,,void
292741,BLOCK,-1,,"{
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  v8::HandleScope scope(context->GetIsolate());
  Realm* realm = Realm::GetCurrent(context);
  // Recreate the buffer in the constructor.
  BindingData* binding = realm->AddBindingData<BindingData>(context, holder);
  CHECK_NOT_NULL(binding);
}",60,,106,5,,void
292780,BLOCK,-1,,<empty>,,,,2,,<empty>
292785,BLOCK,-1,,<empty>,,,,2,,<empty>
292790,BLOCK,-1,,<empty>,,,,2,,<empty>
292795,BLOCK,-1,,<empty>,,,,2,,<empty>
292801,BLOCK,-1,,"{
  Isolate* isolate = isolate_data->isolate();

  SetMethod(isolate, target, ""setupTimers"", SetupTimers);
  SetFastMethod(
      isolate, target, ""getLibuvNow"", SlowGetLibuvNow, &fast_get_libuv_now_);
  SetFastMethod(isolate,
                target,
                ""scheduleTimer"",
                SlowScheduleTimer,
                &fast_schedule_timers_);
  SetFastMethod(isolate,
                target,
                ""toggleTimerRef"",
                SlowToggleTimerRef,
                &fast_toggle_timer_ref_);
  SetFastMethod(isolate,
                target,
                ""toggleImmediateRef"",
                SlowToggleImmediateRef,
                &fast_toggle_immediate_ref_);
}",76,,125,3,,void
292849,BLOCK,-1,,"{
  Realm* realm = Realm::GetCurrent(context);
  Environment* env = realm->env();
  BindingData* const binding_data =
      realm->AddBindingData<BindingData>(context, target);
  if (binding_data == nullptr) return;

  // TODO(joyeecheung): move these into BindingData.
  target
      ->Set(context,
            FIXED_ONE_BYTE_STRING(realm->isolate(), ""immediateInfo""),
            env->immediate_info()->fields().GetJSArray())
      .Check();

  target
      ->Set(context,
            FIXED_ONE_BYTE_STRING(realm->isolate(), ""timeoutInfo""),
            env->timeout_info().GetJSArray())
      .Check();
}",58,,151,5,,void
292882,BLOCK,-1,,<empty>,32,,156,2,,void
292933,BLOCK,-1,,"{
  registry->Register(SetupTimers);

  registry->Register(SlowGetLibuvNow);
  registry->Register(FastGetLibuvNow);
  registry->Register(fast_get_libuv_now_.GetTypeInfo());

  registry->Register(SlowScheduleTimer);
  registry->Register(FastScheduleTimer);
  registry->Register(fast_schedule_timers_.GetTypeInfo());

  registry->Register(SlowToggleTimerRef);
  registry->Register(FastToggleTimerRef);
  registry->Register(fast_toggle_timer_ref_.GetTypeInfo());

  registry->Register(SlowToggleImmediateRef);
  registry->Register(FastToggleImmediateRef);
  registry->Register(fast_toggle_immediate_ref_.GetTypeInfo());
}",42,,173,2,,void
293022,BLOCK,-1,,<empty>,1,,1,1,,ANY
293026,BLOCK,-1,,"{
    Agent* agent = ContainerOf(&Agent::initialize_writer_async_, async);
    agent->InitializeWritersOnThread();
  }",48,,58,2,,void
293046,BLOCK,-1,,"{
    Agent* agent = static_cast<Agent*>(arg);
    uv_run(&agent->tracing_loop_, UV_RUN_DEFAULT);
  }",56,,97,2,,void
293076,BLOCK,-1,,<empty>,1,,1,1,,ANY
293084,BLOCK,-1,,"{
    if (do_suspend) {
      CHECK(agent_->started_);
      controller->StopTracing();
    }
  }",69,,16,4,,void
293087,BLOCK,-1,,"{
      CHECK(agent_->started_);
      controller->StopTracing();
    }",21,,17,2,,void
293099,BLOCK,-1,,"{
    if (agent_ == nullptr) return;
    TraceConfig* config = agent_->CreateTraceConfig();
    if (config != nullptr) {
      controller_->StartTracing(config);
    }
  }",27,,23,1,,void
293104,BLOCK,-1,,<empty>,28,,24,2,,void
293117,BLOCK,-1,,"{
      controller_->StartTracing(config);
    }",28,,26,2,,void
293130,BLOCK,-1,,"{
  std::set<std::string> result;
  for (const auto& id_value : map)
    result.insert(id_value.second.begin(), id_value.second.end());
  return result;
}",69,,39,2,,void
293164,BLOCK,-1,,"{
  tracing_controller_->Initialize(nullptr);

  CHECK_EQ(uv_loop_init(&tracing_loop_), 0);
  CHECK_EQ(uv_async_init(&tracing_loop_,
                         &initialize_writer_async_,
                         [](uv_async_t* async) {
    Agent* agent = ContainerOf(&Agent::initialize_writer_async_, async);
    agent->InitializeWritersOnThread();
  }), 0);
  uv_unref(reinterpret_cast<uv_handle_t*>(&initialize_writer_async_));
}",63,,52,1,,void
293191,BLOCK,-1,,"{
  Mutex::ScopedLock lock(initialize_writer_mutex_);
  while (!to_be_initialized_.empty()) {
    AsyncTraceWriter* head = *to_be_initialized_.begin();
    head->InitializeOnThread(&tracing_loop_);
    to_be_initialized_.erase(head);
  }
  initialize_writer_condvar_.Broadcast(lock);
}",41,,65,1,,void
293201,BLOCK,-1,,"{
    AsyncTraceWriter* head = *to_be_initialized_.begin();
    head->InitializeOnThread(&tracing_loop_);
    to_be_initialized_.erase(head);
  }",39,,67,2,,void
293229,BLOCK,-1,,"{
  categories_.clear();
  writers_.clear();

  StopTracing();

  uv_close(reinterpret_cast<uv_handle_t*>(&initialize_writer_async_), nullptr);
  uv_run(&tracing_loop_, UV_RUN_ONCE);
  CheckedUvLoopClose(&tracing_loop_);
}",17,,75,1,,void
293255,BLOCK,-1,,"{
  if (started_)
    return;

  NodeTraceBuffer* trace_buffer_ = new NodeTraceBuffer(
      NodeTraceBuffer::kBufferChunks, this, &tracing_loop_);
  tracing_controller_->Initialize(trace_buffer_);

  // This thread should be created *after* async handles are created
  // (within NodeTraceWriter and NodeTraceBuffer constructors).
  // Otherwise the thread could shut down prematurely.
  CHECK_EQ(0, uv_thread_create(&thread_, [](void* arg) {
    Agent* agent = static_cast<Agent*>(arg);
    uv_run(&agent->tracing_loop_, UV_RUN_DEFAULT);
  }, this));
  started_ = true;
}",21,,86,1,,void
293258,BLOCK,-1,,<empty>,5,,88,2,,void
293292,BLOCK,-1,,"{
  Start();

  const std::set<std::string>* use_categories = &categories;

  std::set<std::string> categories_with_default;
  if (mode == kUseDefaultCategories) {
    categories_with_default.insert(categories.begin(), categories.end());
    categories_with_default.insert(categories_[kDefaultHandleId].begin(),
                                   categories_[kDefaultHandleId].end());
    use_categories = &categories_with_default;
  }

  ScopedSuspendTracing suspend(tracing_controller_.get(), this);
  int id = next_writer_id_++;
  AsyncTraceWriter* raw = writer.get();
  writers_[id] = std::move(writer);
  categories_[id] = { use_categories->begin(), use_categories->end() };

  {
    Mutex::ScopedLock lock(initialize_writer_mutex_);
    to_be_initialized_.insert(raw);
    uv_async_send(&initialize_writer_async_);
    while (to_be_initialized_.count(raw) > 0)
      initialize_writer_condvar_.Wait(lock);
  }

  return AgentWriterHandle(this, id);
}",39,,107,4,,void
293312,BLOCK,-1,,"{
    categories_with_default.insert(categories.begin(), categories.end());
    categories_with_default.insert(categories_[kDefaultHandleId].begin(),
                                   categories_[kDefaultHandleId].end());
    use_categories = &categories_with_default;
  }",38,,113,2,,void
293377,BLOCK,14,,"{
    Mutex::ScopedLock lock(initialize_writer_mutex_);
    to_be_initialized_.insert(raw);
    uv_async_send(&initialize_writer_async_);
    while (to_be_initialized_.count(raw) > 0)
      initialize_writer_condvar_.Wait(lock);
  }",3,,126,14,,void
293409,BLOCK,-1,,"{
  return AgentWriterHandle(this, kDefaultHandleId);
}",42,,137,1,,void
293417,BLOCK,-1,,"{
  if (!started_)
    return;
  // Perform final Flush on TraceBuffer. We don't want the tracing controller
  // to flush the buffer again on destruction of the V8::Platform.
  tracing_controller_->StopTracing();
  tracing_controller_->Initialize(nullptr);
  started_ = false;

  // Thread should finish when the tracing loop is stopped.
  uv_thread_join(&thread_);
}",27,,141,1,,void
293421,BLOCK,-1,,<empty>,5,,143,2,,void
293442,BLOCK,-1,,"{
  if (client == kDefaultHandleId) return;
  {
    Mutex::ScopedLock lock(initialize_writer_mutex_);
    to_be_initialized_.erase(writers_[client].get());
  }
  ScopedSuspendTracing suspend(tracing_controller_.get(), this);
  writers_.erase(client);
  categories_.erase(client);
}",36,,154,2,,void
293447,BLOCK,-1,,<empty>,35,,155,2,,void
293449,BLOCK,2,,"{
    Mutex::ScopedLock lock(initialize_writer_mutex_);
    to_be_initialized_.erase(writers_[client].get());
  }",3,,156,2,,void
293485,BLOCK,-1,,"{
  if (categories.empty())
    return;

  ScopedSuspendTracing suspend(tracing_controller_.get(), this,
                               id != kDefaultHandleId);
  categories_[id].insert(categories.begin(), categories.end());
}",69,,165,3,,void
293491,BLOCK,-1,,<empty>,5,,167,2,,void
293522,BLOCK,-1,,"{
  ScopedSuspendTracing suspend(tracing_controller_.get(), this,
                               id != kDefaultHandleId);
  std::multiset<std::string>& writer_categories = categories_[id];
  for (const std::string& category : categories) {
    auto it = writer_categories.find(category);
    if (it != writer_categories.end())
      writer_categories.erase(it);
  }
}",70,,174,3,,void
293550,BLOCK,-1,,"{
    auto it = writer_categories.find(category);
    if (it != writer_categories.end())
      writer_categories.erase(it);
  }",50,,178,3,,void
293566,BLOCK,-1,,<empty>,7,,181,2,,void
293575,BLOCK,-1,,"{
  if (categories_.empty())
    return nullptr;
  TraceConfig* trace_config = new TraceConfig();
  for (const auto& category : flatten(categories_)) {
    trace_config->AddIncludedCategory(category.c_str());
  }
  return trace_config;
}",47,,185,1,,void
293581,BLOCK,-1,,<empty>,5,,187,2,,void
293593,BLOCK,-1,,"{
    trace_config->AddIncludedCategory(category.c_str());
  }",53,,189,3,,void
293607,BLOCK,-1,,"{
  std::string categories;
  for (const std::string& category : flatten(categories_)) {
    if (!categories.empty())
      categories += ',';
    categories += category;
  }
  return categories;
}",49,,195,1,,void
293613,BLOCK,-1,,"{
    if (!categories.empty())
      categories += ',';
    categories += category;
  }",60,,197,3,,void
293620,BLOCK,-1,,<empty>,7,,199,2,,void
293633,BLOCK,-1,,"{
  for (const auto& id_writer : writers_)
    id_writer.second->AppendTraceEvent(trace_event);
}",56,,205,2,,void
293648,BLOCK,-1,,"{
  Mutex::ScopedLock lock(metadata_events_mutex_);
  metadata_events_.push_back(std::move(event));
}",66,,210,2,,void
293665,BLOCK,-1,,"{
  {
    Mutex::ScopedLock lock(metadata_events_mutex_);
    for (const auto& event : metadata_events_)
      AppendTraceEvent(event.get());
  }

  for (const auto& id_writer : writers_)
    id_writer.second->Flush(blocking);
}",34,,215,2,,void
293666,BLOCK,1,,"{
    Mutex::ScopedLock lock(metadata_events_mutex_);
    for (const auto& event : metadata_events_)
      AppendTraceEvent(event.get());
  }",3,,216,1,,void
293699,BLOCK,-1,,"{
  std::unique_ptr<TraceObject> trace_event(new TraceObject);
  trace_event->Initialize(
      TRACE_EVENT_PHASE_METADATA, category_group_enabled, name,
      node::tracing::kGlobalScope,  // scope
      node::tracing::kNoId,         // id
      node::tracing::kNoId,         // bind_id
      num_args, arg_names, arg_types, arg_values, convertable_values,
      TRACE_EVENT_FLAG_NONE,
      CurrentTimestampMicroseconds(),
      CurrentCpuTimestampMicroseconds());
  Agent* node_agent = node::tracing::TraceEventHelper::GetAgent();
  if (node_agent != nullptr)
    node_agent->AddMetadataEvent(std::move(trace_event));
}",25,,234,9,,void
293714,BLOCK,1,,<empty>,,,,1,,void
293739,BLOCK,1,,<empty>,,,,1,,void
293760,BLOCK,-1,,<empty>,5,,247,2,,void
293792,BLOCK,-1,,<empty>,1,,1,1,,ANY
293801,BLOCK,-1,,<empty>,,,,1,,<empty>
293806,BLOCK,-1,,<empty>,,,,2,,<empty>
293811,BLOCK,-1,,<empty>,,,,2,,<empty>
293816,BLOCK,-1,,<empty>,52,,32,2,,void
293821,BLOCK,-1,,<empty>,68,,37,1,,void
293825,BLOCK,-1,,"{
    return uv_hrtime() / 1000;
  }",51,,39,1,,void
293841,BLOCK,-1,,<empty>,,,,9,,<empty>
293846,BLOCK,-1,,<empty>,,,,1,,<empty>
293850,BLOCK,-1,,{ reset(); },31,,56,1,,void
293856,BLOCK,-1,,<empty>,,,,2,,<empty>
293861,BLOCK,-1,,<empty>,,,,2,,<empty>
293865,BLOCK,-1,,{ return agent_ == nullptr; },29,,60,1,,void
293873,BLOCK,-1,,<empty>,,,,1,,<empty>
293878,BLOCK,-1,,<empty>,,,,2,,<empty>
293883,BLOCK,-1,,<empty>,,,,2,,<empty>
293887,BLOCK,-1,,<empty>,,,,1,,<empty>
293891,BLOCK,-1,,{ return agent_; },25,,68,1,,void
293897,BLOCK,-1,,<empty>,,,,1,,<empty>
293902,BLOCK,-1,,<empty>,,,,2,,<empty>
293907,BLOCK,-1,,<empty>,,,,2,,<empty>
293913,BLOCK,-1,,<empty>,75,,76,3,,void
293920,BLOCK,-1,,<empty>,,,,1,,<empty>
293931,BLOCK,-1,,<empty>,,,,1,,<empty>
293935,BLOCK,-1,,<empty>,,,,1,,<empty>
293939,BLOCK,-1,,"{
    TracingController* controller = tracing_controller_.get();
    CHECK_NOT_NULL(controller);
    return controller;
  }",45,,89,1,,void
293960,BLOCK,-1,,<empty>,,,,4,,<empty>
293964,BLOCK,-1,,<empty>,,,,1,,<empty>
293968,BLOCK,-1,,<empty>,,,,1,,<empty>
293973,BLOCK,-1,,<empty>,,,,2,,<empty>
293978,BLOCK,-1,,<empty>,,,,2,,<empty>
293983,BLOCK,-1,,<empty>,,,,2,,<empty>
293987,BLOCK,-1,,<empty>,,,,1,,<empty>
293992,BLOCK,-1,,<empty>,,,,1,,<empty>
293996,BLOCK,-1,,<empty>,,,,1,,<empty>
294000,BLOCK,-1,,<empty>,,,,1,,<empty>
294005,BLOCK,-1,,<empty>,,,,2,,<empty>
294011,BLOCK,-1,,<empty>,,,,3,,<empty>
294017,BLOCK,-1,,<empty>,,,,3,,<empty>
294028,BLOCK,-1,,<empty>,,,,1,,<empty>
294045,BLOCK,-1,,<empty>,,,,1,,<empty>
294055,BLOCK,-1,,"{
  if (agent_ != nullptr)
    agent_->Disconnect(id_);
  agent_ = nullptr;
}",33,,158,1,,void
294060,BLOCK,-1,,<empty>,5,,160,2,,void
294073,BLOCK,-1,,"{
  reset();
  agent_ = other.agent_;
  id_ = other.id_;
  other.agent_ = nullptr;
  return *this;
}",76,,164,2,,void
294097,BLOCK,-1,,"{
  *this = std::move(other);
}",65,,172,2,,void
294110,BLOCK,-1,,"{
  if (agent_ != nullptr) agent_->Enable(id_, categories);
}",73,,176,2,,void
294115,BLOCK,-1,,<empty>,26,,177,2,,void
294126,BLOCK,-1,,"{
  if (agent_ != nullptr) agent_->Disable(id_, categories);
}",74,,180,2,,void
294131,BLOCK,-1,,<empty>,26,,181,2,,void
294141,BLOCK,-1,,"{
  return agent_ != nullptr && id_ == Agent::kDefaultHandleId;
}",43,,184,1,,void
294155,BLOCK,-1,,"{
  return agent_ != nullptr ? agent_->GetTracingController() : nullptr;
}",73,,188,1,,void
294171,BLOCK,-1,,"{
      NodeTraceBuffer* buffer =
          ContainerOf(&NodeTraceBuffer::exit_signal_,
                      reinterpret_cast<uv_async_t*>(signal));
        Mutex::ScopedLock scoped_lock(buffer->exit_mutex_);
        buffer->exited_ = true;
        buffer->exit_cond_.Signal(scoped_lock);
    }",38,,187,2,,void
294207,BLOCK,-1,,"{
    NodeTraceBuffer* buffer =
        ContainerOf(&NodeTraceBuffer::flush_signal_,
                    reinterpret_cast<uv_async_t*>(signal));

    uv_close(reinterpret_cast<uv_handle_t*>(&buffer->exit_signal_),
             [](uv_handle_t* signal) {
      NodeTraceBuffer* buffer =
          ContainerOf(&NodeTraceBuffer::exit_signal_,
                      reinterpret_cast<uv_async_t*>(signal));
        Mutex::ScopedLock scoped_lock(buffer->exit_mutex_);
        buffer->exited_ = true;
        buffer->exit_cond_.Signal(scoped_lock);
    });
  }",36,,181,2,,void
294238,BLOCK,-1,,<empty>,1,,1,1,,ANY
294245,BLOCK,-1,,"{
  chunks_.resize(max_chunks);
}",30,,12,4,,void
294255,BLOCK,-1,,"{
  Mutex::ScopedLock scoped_lock(mutex_);
  // Create new chunk if last chunk is full or there is no chunk.
  if (total_chunks_ == 0 || chunks_[total_chunks_ - 1]->IsFull()) {
    auto& chunk = chunks_[total_chunks_++];
    if (chunk) {
      chunk->Reset(current_chunk_seq_++);
    } else {
      chunk = std::make_unique<TraceBufferChunk>(current_chunk_seq_++);
    }
  }
  auto& chunk = chunks_[total_chunks_ - 1];
  size_t event_index;
  TraceObject* trace_object = chunk->AddTraceEvent(&event_index);
  *handle = MakeHandle(total_chunks_ - 1, chunk->seq(), event_index);
  return trace_object;
}",67,,16,2,,void
294272,BLOCK,-1,,"{
    auto& chunk = chunks_[total_chunks_++];
    if (chunk) {
      chunk->Reset(current_chunk_seq_++);
    } else {
      chunk = std::make_unique<TraceBufferChunk>(current_chunk_seq_++);
    }
  }",67,,19,2,,void
294282,BLOCK,-1,,"{
      chunk->Reset(current_chunk_seq_++);
    }",16,,21,2,,void
294290,BLOCK,-1,,"{
      chunk = std::make_unique<TraceBufferChunk>(current_chunk_seq_++);
    }",12,,23,1,,void
294337,BLOCK,-1,,"{
  Mutex::ScopedLock scoped_lock(mutex_);
  if (handle == 0) {
    // A handle value of zero never has a trace event associated with it.
    return nullptr;
  }
  size_t chunk_index, event_index;
  uint32_t buffer_id, chunk_seq;
  ExtractHandle(handle, &buffer_id, &chunk_index, &chunk_seq, &event_index);
  if (buffer_id != id_ || chunk_index >= total_chunks_) {
    // Either the chunk belongs to the other buffer, or is outside the current
    // range of chunks loaded in memory (the latter being true suggests that
    // the chunk has already been flushed and is no longer in memory.)
    return nullptr;
  }
  auto& chunk = chunks_[chunk_index];
  if (chunk->seq() != chunk_seq) {
    // Chunk is no longer in memory.
    return nullptr;
  }
  return chunk->GetEventAt(event_index);
}",69,,34,2,,void
294345,BLOCK,-1,,"{
    // A handle value of zero never has a trace event associated with it.
    return nullptr;
  }",20,,36,2,,void
294370,BLOCK,-1,,"{
    // Either the chunk belongs to the other buffer, or is outside the current
    // range of chunks loaded in memory (the latter being true suggests that
    // the chunk has already been flushed and is no longer in memory.)
    return nullptr;
  }",57,,43,2,,void
294386,BLOCK,-1,,"{
    // Chunk is no longer in memory.
    return nullptr;
  }",34,,50,2,,void
294399,BLOCK,-1,,"{
  {
    Mutex::ScopedLock scoped_lock(mutex_);
    if (total_chunks_ > 0) {
      flushing_ = true;
      for (size_t i = 0; i < total_chunks_; ++i) {
        auto& chunk = chunks_[i];
        for (size_t j = 0; j < chunk->size(); ++j) {
          TraceObject* trace_event = chunk->GetEventAt(j);
          // Another thread may have added a trace that is yet to be
          // initialized. Skip such traces.
          // https://github.com/nodejs/node/issues/21038.
          if (trace_event->name()) {
            agent_->AppendTraceEvent(trace_event);
          }
        }
      }
      total_chunks_ = 0;
      flushing_ = false;
    }
  }
  agent_->Flush(blocking);
}",48,,57,2,,void
294400,BLOCK,1,,"{
    Mutex::ScopedLock scoped_lock(mutex_);
    if (total_chunks_ > 0) {
      flushing_ = true;
      for (size_t i = 0; i < total_chunks_; ++i) {
        auto& chunk = chunks_[i];
        for (size_t j = 0; j < chunk->size(); ++j) {
          TraceObject* trace_event = chunk->GetEventAt(j);
          // Another thread may have added a trace that is yet to be
          // initialized. Skip such traces.
          // https://github.com/nodejs/node/issues/21038.
          if (trace_event->name()) {
            agent_->AppendTraceEvent(trace_event);
          }
        }
      }
      total_chunks_ = 0;
      flushing_ = false;
    }
  }",3,,58,1,,void
294408,BLOCK,-1,,"{
      flushing_ = true;
      for (size_t i = 0; i < total_chunks_; ++i) {
        auto& chunk = chunks_[i];
        for (size_t j = 0; j < chunk->size(); ++j) {
          TraceObject* trace_event = chunk->GetEventAt(j);
          // Another thread may have added a trace that is yet to be
          // initialized. Skip such traces.
          // https://github.com/nodejs/node/issues/21038.
          if (trace_event->name()) {
            agent_->AppendTraceEvent(trace_event);
          }
        }
      }
      total_chunks_ = 0;
      flushing_ = false;
    }",28,,60,2,,void
294413,BLOCK,-1,,<empty>,7,,62,1,,void
294423,BLOCK,4,,"{
        auto& chunk = chunks_[i];
        for (size_t j = 0; j < chunk->size(); ++j) {
          TraceObject* trace_event = chunk->GetEventAt(j);
          // Another thread may have added a trace that is yet to be
          // initialized. Skip such traces.
          // https://github.com/nodejs/node/issues/21038.
          if (trace_event->name()) {
            agent_->AppendTraceEvent(trace_event);
          }
        }
      }",50,,62,4,,void
294431,BLOCK,-1,,<empty>,9,,64,1,,void
294444,BLOCK,4,,"{
          TraceObject* trace_event = chunk->GetEventAt(j);
          // Another thread may have added a trace that is yet to be
          // initialized. Skip such traces.
          // https://github.com/nodejs/node/issues/21038.
          if (trace_event->name()) {
            agent_->AppendTraceEvent(trace_event);
          }
        }",52,,64,4,,void
294458,BLOCK,-1,,"{
            agent_->AppendTraceEvent(trace_event);
          }",36,,69,2,,void
294481,BLOCK,-1,,"{
  return ((static_cast<uint64_t>(chunk_seq) * Capacity() +
          chunk_index * TraceBufferChunk::kChunkSize + event_index) << 1) + id_;
}",71,,82,4,,void
294508,BLOCK,-1,,"{
  *buffer_id = static_cast<uint32_t>(handle & 0x1);
  handle >>= 1;
  *chunk_seq = static_cast<uint32_t>(handle / Capacity());
  size_t indices = handle % Capacity();
  *chunk_index = indices / TraceBufferChunk::kChunkSize;
  *event_index = indices % TraceBufferChunk::kChunkSize;
}",53,,89,6,,void
294556,BLOCK,-1,,"{
  current_buf_.store(&buffer1_);

  flush_signal_.data = this;
  int err = uv_async_init(tracing_loop_, &flush_signal_,
                          NonBlockingFlushSignalCb);
  CHECK_EQ(err, 0);

  exit_signal_.data = this;
  err = uv_async_init(tracing_loop_, &exit_signal_, ExitSignalCb);
  CHECK_EQ(err, 0);
}",38,,102,4,,void
294597,BLOCK,-1,,"{
  uv_async_send(&exit_signal_);
  Mutex::ScopedLock scoped_lock(exit_mutex_);
  while (!exited_) {
    exit_cond_.Wait(scoped_lock);
  }
}",37,,115,1,,void
294607,BLOCK,-1,,"{
    exit_cond_.Wait(scoped_lock);
  }",20,,118,2,,void
294617,BLOCK,-1,,"{
  // If the buffer is full, attempt to perform a flush.
  if (!TryLoadAvailableBuffer()) {
    // Assign a value of zero as the trace event handle.
    // This is equivalent to calling InternalTraceBuffer::MakeHandle(0, 0, 0),
    // and will cause GetEventByHandle to return NULL if passed as an argument.
    *handle = 0;
    return nullptr;
  }
  return current_buf_.load()->AddTraceEvent(handle);
}",63,,123,2,,void
294621,BLOCK,-1,,"{
    // Assign a value of zero as the trace event handle.
    // This is equivalent to calling InternalTraceBuffer::MakeHandle(0, 0, 0),
    // and will cause GetEventByHandle to return NULL if passed as an argument.
    *handle = 0;
    return nullptr;
  }",34,,125,2,,void
294641,BLOCK,-1,,"{
  return current_buf_.load()->GetEventByHandle(handle);
}",65,,135,2,,void
294654,BLOCK,-1,,"{
  buffer1_.Flush(true);
  buffer2_.Flush(true);
  return true;
}",31,,139,1,,void
294670,BLOCK,-1,,"{
  InternalTraceBuffer* prev_buf = current_buf_.load();
  if (prev_buf->IsFull()) {
    uv_async_send(&flush_signal_);  // trigger flush on a separate thread
    InternalTraceBuffer* other_buf = prev_buf == &buffer1_ ?
      &buffer2_ : &buffer1_;
    if (!other_buf->IsFull()) {
      current_buf_.store(other_buf);
    } else {
      return false;
    }
  }
  return true;
}",48,,148,1,,void
294683,BLOCK,-1,,"{
    uv_async_send(&flush_signal_);  // trigger flush on a separate thread
    InternalTraceBuffer* other_buf = prev_buf == &buffer1_ ?
      &buffer2_ : &buffer1_;
    if (!other_buf->IsFull()) {
      current_buf_.store(other_buf);
    } else {
      return false;
    }
  }",27,,150,2,,void
294705,BLOCK,-1,,"{
      current_buf_.store(other_buf);
    }",31,,154,2,,void
294712,BLOCK,-1,,"{
      return false;
    }",12,,156,1,,void
294721,BLOCK,-1,,"{
  NodeTraceBuffer* buffer = static_cast<NodeTraceBuffer*>(signal->data);
  if (buffer->buffer1_.IsFull() && !buffer->buffer1_.IsFlushing()) {
    buffer->buffer1_.Flush(false);
  }
  if (buffer->buffer2_.IsFull() && !buffer->buffer2_.IsFlushing()) {
    buffer->buffer2_.Flush(false);
  }
}",68,,164,2,,void
294745,BLOCK,-1,,"{
    buffer->buffer1_.Flush(false);
  }",68,,166,2,,void
294768,BLOCK,-1,,"{
    buffer->buffer2_.Flush(false);
  }",68,,169,2,,void
294779,BLOCK,-1,,"{
  NodeTraceBuffer* buffer =
      ContainerOf(&NodeTraceBuffer::exit_signal_, signal);

  // Close both flush_signal_ and exit_signal_.
  uv_close(reinterpret_cast<uv_handle_t*>(&buffer->flush_signal_),
           [](uv_handle_t* signal) {
    NodeTraceBuffer* buffer =
        ContainerOf(&NodeTraceBuffer::flush_signal_,
                    reinterpret_cast<uv_async_t*>(signal));

    uv_close(reinterpret_cast<uv_handle_t*>(&buffer->exit_signal_),
             [](uv_handle_t* signal) {
      NodeTraceBuffer* buffer =
          ContainerOf(&NodeTraceBuffer::exit_signal_,
                      reinterpret_cast<uv_async_t*>(signal));
        Mutex::ScopedLock scoped_lock(buffer->exit_mutex_);
        buffer->exited_ = true;
        buffer->exit_cond_.Signal(scoped_lock);
    });
  });
}",56,,175,2,,void
294811,BLOCK,-1,,<empty>,1,,1,1,,ANY
294820,BLOCK,-1,,<empty>,,,,4,,<empty>
294825,BLOCK,-1,,<empty>,,,,2,,<empty>
294830,BLOCK,-1,,<empty>,,,,2,,<empty>
294835,BLOCK,-1,,<empty>,,,,2,,<empty>
294839,BLOCK,-1,,"{
    return total_chunks_ == max_chunks_ && chunks_[total_chunks_ - 1]->IsFull();
  }",23,,27,1,,void
294856,BLOCK,-1,,"{
    return flushing_;
  }",27,,30,1,,void
294865,BLOCK,-1,,<empty>,,,,4,,<empty>
294874,BLOCK,-1,,<empty>,,,,6,,<empty>
294878,BLOCK,-1,,{ return max_chunks_ * TraceBufferChunk::kChunkSize; },27,,39,1,,void
294896,BLOCK,-1,,<empty>,,,,1,,<empty>
294910,BLOCK,-1,,<empty>,,,,4,,<empty>
294914,BLOCK,-1,,<empty>,,,,1,,<empty>
294919,BLOCK,-1,,<empty>,,,,2,,<empty>
294924,BLOCK,-1,,<empty>,,,,2,,<empty>
294928,BLOCK,-1,,<empty>,,,,1,,<empty>
294933,BLOCK,-1,,<empty>,,,,1,,<empty>
294938,BLOCK,-1,,<empty>,,,,2,,<empty>
294943,BLOCK,-1,,<empty>,,,,2,,<empty>
294956,BLOCK,-1,,<empty>,,,,1,,<empty>
294968,BLOCK,-1,,"{
    NodeTraceWriter* trace_writer =
        ContainerOf(&NodeTraceWriter::flush_signal_, signal);
    trace_writer->FlushPrivate();
  }",50,,20,2,,void
294988,BLOCK,-1,,"{
        NodeTraceWriter* writer =
            ContainerOf(&NodeTraceWriter::write_req_, req);
        writer->AfterWrite();
      }",24,,187,2,,void
295007,BLOCK,-1,,"{
                   NodeTraceWriter* trace_writer =
                       ContainerOf(&NodeTraceWriter::exit_signal_,
                                   reinterpret_cast<uv_async_t*>(signal));
                   Mutex::ScopedLock scoped_lock(trace_writer->request_mutex_);
                   trace_writer->exited_ = true;
                   trace_writer->exit_cond_.Signal(scoped_lock);
                 }",42,,229,2,,void
295042,BLOCK,-1,,"{
             NodeTraceWriter* trace_writer =
                 ContainerOf(&NodeTraceWriter::flush_signal_,
                             reinterpret_cast<uv_async_t*>(signal));
             uv_close(
                 reinterpret_cast<uv_handle_t*>(&trace_writer->exit_signal_),
                 [](uv_handle_t* signal) {
                   NodeTraceWriter* trace_writer =
                       ContainerOf(&NodeTraceWriter::exit_signal_,
                                   reinterpret_cast<uv_async_t*>(signal));
                   Mutex::ScopedLock scoped_lock(trace_writer->request_mutex_);
                   trace_writer->exited_ = true;
                   trace_writer->exit_cond_.Signal(scoped_lock);
                 });
           }",36,,223,2,,void
295075,BLOCK,-1,,<empty>,1,,1,1,,ANY
295080,BLOCK,-1,,<empty>,43,,12,2,,void
295085,BLOCK,-1,,"{
  CHECK_NULL(tracing_loop_);
  tracing_loop_ = loop;

  flush_signal_.data = this;
  int err = uv_async_init(tracing_loop_, &flush_signal_,
                          [](uv_async_t* signal) {
    NodeTraceWriter* trace_writer =
        ContainerOf(&NodeTraceWriter::flush_signal_, signal);
    trace_writer->FlushPrivate();
  });
  CHECK_EQ(err, 0);

  exit_signal_.data = this;
  err = uv_async_init(tracing_loop_, &exit_signal_, ExitSignalCb);
  CHECK_EQ(err, 0);
}",59,,14,2,,void
295125,BLOCK,-1,,"{
  // If our final log file has traces, then end the file appropriately.
  // This means that if no trace events are recorded, then no trace file is
  // produced.
  bool should_flush = false;
  {
    Mutex::ScopedLock scoped_lock(stream_mutex_);
    if (total_traces_ > 0) {
      total_traces_ = kTracesPerFile;  // Act as if we reached the file limit.
      should_flush = true;
    }
  }
  if (should_flush) {
    Flush(true);
  }
}",37,,32,1,,void
295130,BLOCK,3,,"{
    Mutex::ScopedLock scoped_lock(stream_mutex_);
    if (total_traces_ > 0) {
      total_traces_ = kTracesPerFile;  // Act as if we reached the file limit.
      should_flush = true;
    }
  }",3,,37,3,,void
295138,BLOCK,-1,,"{
      total_traces_ = kTracesPerFile;  // Act as if we reached the file limit.
      should_flush = true;
    }",28,,39,2,,void
295147,BLOCK,-1,,"{
    Flush(true);
  }",21,,44,2,,void
295153,BLOCK,-1,,"{
  WriteSuffix();
  uv_fs_t req;
  if (fd_ != -1) {
    CHECK_EQ(0, uv_fs_close(nullptr, &req, fd_, nullptr));
    uv_fs_req_cleanup(&req);
  }
  uv_async_send(&exit_signal_);
  Mutex::ScopedLock scoped_lock(request_mutex_);
  while (!exited_) {
    exit_cond_.Wait(scoped_lock);
  }
}",37,,49,1,,void
295161,BLOCK,-1,,"{
    CHECK_EQ(0, uv_fs_close(nullptr, &req, fd_, nullptr));
    uv_fs_req_cleanup(&req);
  }",18,,52,2,,void
295182,BLOCK,-1,,"{
    exit_cond_.Wait(scoped_lock);
  }",20,,58,2,,void
295194,BLOCK,-1,,"{
  size_t pos = target->find(search);
  for (; pos != std::string::npos; pos = target->find(search, pos)) {
    target->replace(pos, search.size(), insert);
    pos += insert.size();
  }
}",51,,65,4,,void
295204,BLOCK,-1,,<empty>,3,,67,1,,void
295220,BLOCK,4,,"{
    target->replace(pos, search.size(), insert);
    pos += insert.size();
  }",69,,67,4,,void
295240,BLOCK,-1,,"{
  ++file_num_;
  uv_fs_t req;

  // Evaluate a JS-style template string, it accepts the values ${pid} and
  // ${rotation}
  std::string filepath(log_file_pattern_);
  replace_substring(&filepath, ""${pid}"", std::to_string(uv_os_getpid()));
  replace_substring(&filepath, ""${rotation}"", std::to_string(file_num_));

  if (fd_ != -1) {
    CHECK_EQ(uv_fs_close(nullptr, &req, fd_, nullptr), 0);
    uv_fs_req_cleanup(&req);
  }

  fd_ = uv_fs_open(nullptr, &req, filepath.c_str(),
      O_CREAT | O_WRONLY | O_TRUNC, 0644, nullptr);
  uv_fs_req_cleanup(&req);
  if (fd_ < 0) {
    fprintf(stderr, ""Could not open trace file %s: %s\n"",
                    filepath.c_str(),
                    uv_strerror(fd_));
    fd_ = -1;
  }
}",49,,73,1,,void
295270,BLOCK,-1,,"{
    CHECK_EQ(uv_fs_close(nullptr, &req, fd_, nullptr), 0);
    uv_fs_req_cleanup(&req);
  }",18,,83,2,,void
295306,BLOCK,-1,,"{
    fprintf(stderr, ""Could not open trace file %s: %s\n"",
                    filepath.c_str(),
                    uv_strerror(fd_));
    fd_ = -1;
  }",16,,91,2,,void
295324,BLOCK,-1,,"{
  Mutex::ScopedLock scoped_lock(stream_mutex_);
  // If this is the first trace event, open a new file for streaming.
  if (total_traces_ == 0) {
    OpenNewFileForStreaming();
    // Constructing a new JSONTraceWriter object appends ""{\""traceEvents\"":[""
    // to stream_.
    // In other words, the constructor initializes the serialization stream
    // to a state where we can start writing trace events to it.
    // Repeatedly constructing and destroying json_trace_writer_ allows
    // us to use V8's JSON writer instead of implementing our own.
    json_trace_writer_.reset(TraceWriter::CreateJSONTraceWriter(stream_));
  }
  ++total_traces_;
  json_trace_writer_->AppendTraceEvent(trace_event);
}",66,,99,2,,void
295332,BLOCK,-1,,"{
    OpenNewFileForStreaming();
    // Constructing a new JSONTraceWriter object appends ""{\""traceEvents\"":[""
    // to stream_.
    // In other words, the constructor initializes the serialization stream
    // to a state where we can start writing trace events to it.
    // Repeatedly constructing and destroying json_trace_writer_ allows
    // us to use V8's JSON writer instead of implementing our own.
    json_trace_writer_.reset(TraceWriter::CreateJSONTraceWriter(stream_));
  }",27,,102,2,,void
295353,BLOCK,-1,,"{
  std::string str;
  int highest_request_id;
  {
    Mutex::ScopedLock stream_scoped_lock(stream_mutex_);
    if (total_traces_ >= kTracesPerFile) {
      total_traces_ = 0;
      // Destroying the member JSONTraceWriter object appends ""]}"" to
      // stream_ - in other words, ending a JSON file.
      json_trace_writer_.reset();
    }
    // str() makes a copy of the contents of the stream.
    str = stream_.str();
    stream_.str("""");
    stream_.clear();
  }
  {
    Mutex::ScopedLock request_scoped_lock(request_mutex_);
    highest_request_id = num_write_requests_;
  }
  WriteToFile(std::move(str), highest_request_id);
}",38,,116,1,,void
295356,BLOCK,3,,"{
    Mutex::ScopedLock stream_scoped_lock(stream_mutex_);
    if (total_traces_ >= kTracesPerFile) {
      total_traces_ = 0;
      // Destroying the member JSONTraceWriter object appends ""]}"" to
      // stream_ - in other words, ending a JSON file.
      json_trace_writer_.reset();
    }
    // str() makes a copy of the contents of the stream.
    str = stream_.str();
    stream_.str("""");
    stream_.clear();
  }",3,,119,3,,void
295364,BLOCK,-1,,"{
      total_traces_ = 0;
      // Destroying the member JSONTraceWriter object appends ""]}"" to
      // stream_ - in other words, ending a JSON file.
      json_trace_writer_.reset();
    }",42,,121,2,,void
295387,BLOCK,4,,"{
    Mutex::ScopedLock request_scoped_lock(request_mutex_);
    highest_request_id = num_write_requests_;
  }",3,,132,4,,void
295405,BLOCK,-1,,"{
  Mutex::ScopedLock scoped_lock(request_mutex_);
  {
    // We need to lock the mutexes here in a nested fashion; stream_mutex_
    // protects json_trace_writer_, and without request_mutex_ there might be
    // a time window in which the stream state changes?
    Mutex::ScopedLock stream_mutex_lock(stream_mutex_);
    if (!json_trace_writer_)
      return;
  }
  int request_id = ++num_write_requests_;
  int err = uv_async_send(&flush_signal_);
  CHECK_EQ(err, 0);
  if (blocking) {
    // Wait until data associated with this request id has been written to disk.
    // This guarantees that data from all earlier requests have also been
    // written.
    while (request_id > highest_request_id_completed_) {
      request_cond_.Wait(scoped_lock);
    }
  }
}",44,,139,2,,void
295409,BLOCK,3,,"{
    // We need to lock the mutexes here in a nested fashion; stream_mutex_
    // protects json_trace_writer_, and without request_mutex_ there might be
    // a time window in which the stream state changes?
    Mutex::ScopedLock stream_mutex_lock(stream_mutex_);
    if (!json_trace_writer_)
      return;
  }",3,,141,3,,void
295416,BLOCK,-1,,<empty>,7,,147,2,,void
295434,BLOCK,-1,,"{
    // Wait until data associated with this request id has been written to disk.
    // This guarantees that data from all earlier requests have also been
    // written.
    while (request_id > highest_request_id_completed_) {
      request_cond_.Wait(scoped_lock);
    }
  }",17,,152,2,,void
295439,BLOCK,-1,,"{
      request_cond_.Wait(scoped_lock);
    }",56,,156,2,,void
295450,BLOCK,-1,,"{
  if (fd_ == -1) return;

  uv_buf_t buf = uv_buf_init(nullptr, 0);
  {
    Mutex::ScopedLock lock(request_mutex_);
    write_req_queue_.emplace(WriteRequest {
      std::move(str), highest_request_id
    });
    if (write_req_queue_.size() == 1) {
      buf = uv_buf_init(
          const_cast<char*>(write_req_queue_.front().str.c_str()),
          write_req_queue_.front().str.length());
    }
  }
  // Only one write request for the same file descriptor should be active at
  // a time.
  if (buf.base != nullptr && fd_ != -1) {
    StartWrite(buf);
  }
}",78,,162,3,,void
295456,BLOCK,-1,,<empty>,18,,163,2,,void
295464,BLOCK,4,,"{
    Mutex::ScopedLock lock(request_mutex_);
    write_req_queue_.emplace(WriteRequest {
      std::move(str), highest_request_id
    });
    if (write_req_queue_.size() == 1) {
      buf = uv_buf_init(
          const_cast<char*>(write_req_queue_.front().str.c_str()),
          write_req_queue_.front().str.length());
    }
  }",3,,166,4,,void
295487,BLOCK,-1,,"{
      buf = uv_buf_init(
          const_cast<char*>(write_req_queue_.front().str.c_str()),
          write_req_queue_.front().str.length());
    }",39,,171,2,,void
295522,BLOCK,-1,,"{
    StartWrite(buf);
  }",41,,179,2,,void
295529,BLOCK,-1,,"{
  int err = uv_fs_write(
      tracing_loop_, &write_req_, fd_, &buf, 1, -1,
      [](uv_fs_t* req) {
        NodeTraceWriter* writer =
            ContainerOf(&NodeTraceWriter::write_req_, req);
        writer->AfterWrite();
      });
  CHECK_EQ(err, 0);
}",48,,184,2,,void
295550,BLOCK,-1,,"{
  CHECK_GE(write_req_.result, 0);
  uv_fs_req_cleanup(&write_req_);

  uv_buf_t buf = uv_buf_init(nullptr, 0);
  {
    Mutex::ScopedLock scoped_lock(request_mutex_);
    int highest_request_id = write_req_queue_.front().highest_request_id;
    write_req_queue_.pop();
    highest_request_id_completed_ = highest_request_id;
    request_cond_.Broadcast(scoped_lock);
    if (!write_req_queue_.empty()) {
      buf = uv_buf_init(
          const_cast<char*>(write_req_queue_.front().str.c_str()),
          write_req_queue_.front().str.length());
    }
  }
  if (buf.base != nullptr && fd_ != -1) {
    StartWrite(buf);
  }
}",36,,195,1,,void
295565,BLOCK,5,,"{
    Mutex::ScopedLock scoped_lock(request_mutex_);
    int highest_request_id = write_req_queue_.front().highest_request_id;
    write_req_queue_.pop();
    highest_request_id_completed_ = highest_request_id;
    request_cond_.Broadcast(scoped_lock);
    if (!write_req_queue_.empty()) {
      buf = uv_buf_init(
          const_cast<char*>(write_req_queue_.front().str.c_str()),
          write_req_queue_.front().str.length());
    }
  }",3,,200,5,,void
295596,BLOCK,-1,,"{
      buf = uv_buf_init(
          const_cast<char*>(write_req_queue_.front().str.c_str()),
          write_req_queue_.front().str.length());
    }",36,,206,2,,void
295631,BLOCK,-1,,"{
    StartWrite(buf);
  }",41,,212,2,,void
295637,BLOCK,-1,,"{
  NodeTraceWriter* trace_writer =
      ContainerOf(&NodeTraceWriter::exit_signal_, signal);
  // Close both flush_signal_ and exit_signal_.
  uv_close(reinterpret_cast<uv_handle_t*>(&trace_writer->flush_signal_),
           [](uv_handle_t* signal) {
             NodeTraceWriter* trace_writer =
                 ContainerOf(&NodeTraceWriter::flush_signal_,
                             reinterpret_cast<uv_async_t*>(signal));
             uv_close(
                 reinterpret_cast<uv_handle_t*>(&trace_writer->exit_signal_),
                 [](uv_handle_t* signal) {
                   NodeTraceWriter* trace_writer =
                       ContainerOf(&NodeTraceWriter::exit_signal_,
                                   reinterpret_cast<uv_async_t*>(signal));
                   Mutex::ScopedLock scoped_lock(trace_writer->request_mutex_);
                   trace_writer->exited_ = true;
                   trace_writer->exit_cond_.Signal(scoped_lock);
                 });
           });
}",56,,218,2,,void
295671,BLOCK,-1,,<empty>,1,,1,1,,ANY
295677,BLOCK,-1,,<empty>,,,,2,,<empty>
295681,BLOCK,-1,,<empty>,,,,1,,<empty>
295686,BLOCK,-1,,<empty>,,,,2,,<empty>
295691,BLOCK,-1,,<empty>,,,,2,,<empty>
295696,BLOCK,-1,,<empty>,,,,2,,<empty>
295704,BLOCK,-1,,<empty>,,,,1,,<empty>
295709,BLOCK,-1,,<empty>,,,,2,,<empty>
295713,BLOCK,-1,,<empty>,,,,1,,<empty>
295719,BLOCK,-1,,<empty>,,,,3,,<empty>
295723,BLOCK,-1,,<empty>,,,,1,,<empty>
295727,BLOCK,-1,,<empty>,,,,1,,<empty>
295732,BLOCK,-1,,<empty>,,,,2,,<empty>
295754,BLOCK,-1,,<empty>,,,,1,,<empty>
295792,BLOCK,-1,,<empty>,1,,1,1,,ANY
295805,BLOCK,-1,,"{
  if (agent) {
    g_agent = agent;
    g_controller = agent->GetTracingController();
  } else {
    g_agent = nullptr;
    g_controller = nullptr;
  }
}",47,,10,2,,void
295808,BLOCK,-1,,"{
    g_agent = agent;
    g_controller = agent->GetTracingController();
  }",14,,11,2,,void
295819,BLOCK,-1,,"{
    g_agent = nullptr;
    g_controller = nullptr;
  }",10,,14,1,,void
295829,BLOCK,-1,,"{
  return g_agent;
}",37,,20,1,,void
295835,BLOCK,-1,,"{
  return g_controller;
}",65,,24,1,,void
295842,BLOCK,-1,,"{
  g_controller = controller;
}",80,,28,2,,void
295849,BLOCK,-1,,"{
  return tracing::TraceEventHelper::GetTracingController();
}",47,,34,1,,void
295861,BLOCK,-1,,"{
  tracing::TraceEventHelper::SetTracingController(controller);
}",62,,38,2,,void
295883,BLOCK,-1,,<empty>,1,,1,1,,ANY
295889,BLOCK,-1,,<empty>,,,,1,,<empty>
295923,BLOCK,-1,,<empty>,,,,1,,<empty>
295928,BLOCK,-1,,<empty>,,,,2,,<empty>
295932,BLOCK,-1,,<empty>,,,,1,,<empty>
295937,BLOCK,-1,,<empty>,,,,2,,<empty>
295942,BLOCK,-1,,"{
    v8::TracingController* controller = GetTracingController();
    static const uint8_t disabled = 0;
    if (UNLIKELY(controller == nullptr)) return &disabled;
    return controller->GetCategoryGroupEnabled(group);
  }",75,,321,2,,void
295956,BLOCK,-1,,<empty>,42,,324,2,,void
295973,BLOCK,-1,,<empty>,42,,337,3,,void
295977,BLOCK,-1,,{ return raw_id_; },29,,338,1,,void
295983,BLOCK,-1,,{ return scope_; },31,,339,1,,void
295991,BLOCK,-1,,<empty>,,,,1,,<empty>
296000,BLOCK,-1,,<empty>,79,,349,2,,void
296005,BLOCK,-1,,<empty>,60,,350,2,,void
296010,BLOCK,-1,,<empty>,64,,351,2,,void
296015,BLOCK,-1,,<empty>,60,,352,2,,void
296020,BLOCK,-1,,<empty>,65,,353,2,,void
296025,BLOCK,-1,,<empty>,50,,355,2,,void
296030,BLOCK,-1,,<empty>,78,,356,2,,void
296035,BLOCK,-1,,<empty>,50,,358,2,,void
296040,BLOCK,-1,,<empty>,50,,360,2,,void
296045,BLOCK,-1,,<empty>,66,,362,2,,void
296049,BLOCK,-1,,{ return scope_; },31,,363,1,,void
296055,BLOCK,-1,,{ return raw_id_; },29,,364,1,,void
296063,BLOCK,-1,,<empty>,,,,1,,<empty>
296072,BLOCK,-1,,<empty>,61,,373,2,,void
296077,BLOCK,-1,,<empty>,65,,374,2,,void
296082,BLOCK,-1,,<empty>,61,,375,2,,void
296087,BLOCK,-1,,<empty>,66,,376,2,,void
296092,BLOCK,-1,,<empty>,50,,378,2,,void
296097,BLOCK,-1,,<empty>,79,,379,2,,void
296102,BLOCK,-1,,<empty>,50,,381,2,,void
296107,BLOCK,-1,,<empty>,50,,383,2,,void
296111,BLOCK,-1,,{ return raw_id_; },29,,384,1,,void
296120,BLOCK,-1,,"{
    *flags |= TRACE_EVENT_FLAG_MANGLE_ID;
  }",77,,391,3,,void
296125,BLOCK,1,,<empty>,,,,1,,void
296136,BLOCK,-1,,"{
    *flags |= TRACE_EVENT_FLAG_MANGLE_ID;
  }",79,,394,3,,void
296141,BLOCK,1,,<empty>,,,,1,,void
296152,BLOCK,-1,,<empty>,76,,398,3,,void
296158,BLOCK,-1,,"{
    (void)flags;
  }",67,,399,3,,void
296167,BLOCK,-1,,"{
    (void)flags;
  }",71,,402,3,,void
296176,BLOCK,-1,,"{
    (void)flags;
  }",67,,405,3,,void
296185,BLOCK,-1,,"{
    (void)flags;
  }",72,,408,3,,void
296194,BLOCK,-1,,"{
    (void)flags;
  }",48,,412,3,,void
296203,BLOCK,-1,,"{
    (void)flags;
  }",48,,416,3,,void
296212,BLOCK,-1,,"{
    (void)flags;
  }",48,,420,3,,void
296221,BLOCK,-1,,"{
    (void)flags;
  }",48,,424,3,,void
296230,BLOCK,-1,,<empty>,64,,428,3,,void
296234,BLOCK,-1,,{ return raw_id_; },27,,430,1,,void
296240,BLOCK,-1,,{ return scope_; },29,,431,1,,void
296248,BLOCK,-1,,<empty>,,,,1,,<empty>
296264,BLOCK,-1,,<empty>,61,,451,2,,void
296268,BLOCK,-1,,{ return str_; },32,,452,1,,void
296286,BLOCK,-1,,"{
  std::unique_ptr<v8::ConvertableToTraceFormat> arg_convertibles[2];
  if (num_args > 0 && arg_types[0] == TRACE_VALUE_TYPE_CONVERTABLE) {
    arg_convertibles[0].reset(reinterpret_cast<v8::ConvertableToTraceFormat*>(
        static_cast<intptr_t>(arg_values[0])));
  }
  if (num_args > 1 && arg_types[1] == TRACE_VALUE_TYPE_CONVERTABLE) {
    arg_convertibles[1].reset(reinterpret_cast<v8::ConvertableToTraceFormat*>(
        static_cast<intptr_t>(arg_values[1])));
  }
  // DCHECK(num_args, 2);
  v8::TracingController* controller =
      node::tracing::TraceEventHelper::GetTracingController();
  if (controller == nullptr) return 0;
  return controller->AddTraceEvent(phase, category_group_enabled, name, scope, id,
                                   bind_id, num_args, arg_names, arg_types,
                                   arg_values, arg_convertibles, flags);
}",53,,462,12,,void
296298,BLOCK,1,,<empty>,,,,1,,void
296302,BLOCK,-1,,"{
    arg_convertibles[0].reset(reinterpret_cast<v8::ConvertableToTraceFormat*>(
        static_cast<intptr_t>(arg_values[0])));
  }",69,,464,2,,void
296326,BLOCK,1,,<empty>,,,,1,,void
296330,BLOCK,-1,,"{
    arg_convertibles[1].reset(reinterpret_cast<v8::ConvertableToTraceFormat*>(
        static_cast<intptr_t>(arg_values[1])));
  }",69,,468,2,,void
296359,BLOCK,-1,,<empty>,30,,475,2,,void
296387,BLOCK,-1,,"INTERNAL_DECLARE_SET_TRACE_VALUE_INT(uint64_t, TRACE_VALUE_TYPE_UINT)",1,,545,4,,void
296406,BLOCK,-1,,"INTERNAL_DECLARE_SET_TRACE_VALUE_INT(unsigned int, TRACE_VALUE_TYPE_UINT)",1,,546,4,,void
296425,BLOCK,-1,,"INTERNAL_DECLARE_SET_TRACE_VALUE_INT(uint16_t, TRACE_VALUE_TYPE_UINT)",1,,547,4,,void
296444,BLOCK,-1,,"INTERNAL_DECLARE_SET_TRACE_VALUE_INT(unsigned char, TRACE_VALUE_TYPE_UINT)",1,,548,4,,void
296463,BLOCK,-1,,"INTERNAL_DECLARE_SET_TRACE_VALUE_INT(int64_t, TRACE_VALUE_TYPE_INT)",1,,549,4,,void
296482,BLOCK,-1,,"INTERNAL_DECLARE_SET_TRACE_VALUE_INT(int, TRACE_VALUE_TYPE_INT)",1,,550,4,,void
296501,BLOCK,-1,,"INTERNAL_DECLARE_SET_TRACE_VALUE_INT(int16_t, TRACE_VALUE_TYPE_INT)",1,,551,4,,void
296520,BLOCK,-1,,"INTERNAL_DECLARE_SET_TRACE_VALUE_INT(signed char, TRACE_VALUE_TYPE_INT)",1,,552,4,,void
296539,BLOCK,-1,,"INTERNAL_DECLARE_SET_TRACE_VALUE(bool, as_bool, TRACE_VALUE_TYPE_BOOL)",1,,553,4,,void
296564,BLOCK,-1,,"INTERNAL_DECLARE_SET_TRACE_VALUE(double, as_double, TRACE_VALUE_TYPE_DOUBLE)",1,,554,4,,void
296589,BLOCK,-1,,"INTERNAL_DECLARE_SET_TRACE_VALUE(const void*, as_pointer,
                                 TRACE_VALUE_TYPE_POINTER)",1,,555,4,,void
296614,BLOCK,-1,,"INTERNAL_DECLARE_SET_TRACE_VALUE(const char*, as_string,
                                 TRACE_VALUE_TYPE_STRING)",1,,557,4,,void
296639,BLOCK,-1,,"INTERNAL_DECLARE_SET_TRACE_VALUE(const TraceStringWithCopy&, as_string,
                                 TRACE_VALUE_TYPE_COPY_STRING)",1,,559,4,,void
296664,BLOCK,-1,,"{
  *type = TRACE_VALUE_TYPE_CONVERTABLE;
  *value = static_cast<uint64_t>(reinterpret_cast<intptr_t>(convertable_value));
}",75,,566,4,,void
296669,BLOCK,1,,<empty>,,,,1,,void
296687,BLOCK,-1,,"{
  SetTraceValue(ptr.release(), type, value);
}",77,,574,4,,void
296705,BLOCK,-1,,"{
  return TRACE_EVENT_API_ADD_TRACE_EVENT(phase, category_group_enabled, name,
                                         scope, id, bind_id, kZeroNumArgs,
                                         nullptr, nullptr, nullptr, flags);
}",61,,588,8,,void
296708,BLOCK,1,,<empty>,,,,2,,void
296738,BLOCK,-1,,"{
  const int num_args = 1;
  uint8_t arg_type;
  uint64_t arg_value;
  SetTraceValue(std::forward<ARG1_TYPE>(arg1_val), &arg_type, &arg_value);
  return TRACE_EVENT_API_ADD_TRACE_EVENT(
      phase, category_group_enabled, name, scope, id, bind_id, num_args,
      &arg1_name, &arg_type, &arg_value, flags);
}",50,,598,10,,void
296759,BLOCK,1,,<empty>,,,,4,,void
296794,BLOCK,-1,,"{
  const int num_args = 2;
  const char* arg_names[2] = {arg1_name, arg2_name};
  unsigned char arg_types[2];
  uint64_t arg_values[2];
  SetTraceValue(std::forward<ARG1_TYPE>(arg1_val), &arg_types[0],
                &arg_values[0]);
  SetTraceValue(std::forward<ARG2_TYPE>(arg2_val), &arg_types[1],
                &arg_values[1]);
  return TRACE_EVENT_API_ADD_TRACE_EVENT(
      phase, category_group_enabled, name, scope, id, bind_id, num_args,
      arg_names, arg_types, arg_values, flags);
}",27,,613,12,,void
296841,BLOCK,1,,<empty>,,,,5,,void
296867,BLOCK,-1,,<empty>,37,,686,1,,void
296871,BLOCK,-1,,"{
    if (p_data_ && *data_.category_group_enabled)
      TRACE_EVENT_API_UPDATE_TRACE_EVENT_DURATION(
          data_.category_group_enabled, data_.name, data_.event_handle);
  }",19,,688,1,,void
296879,BLOCK,-1,,<empty>,7,,690,2,,void
296881,BLOCK,1,,<empty>,,,,1,,void
296883,BLOCK,-1,,<empty>,7,,690,1,,void
296895,BLOCK,-1,,<empty>,7,,690,2,,void
296915,BLOCK,-1,,"{
    data_.category_group_enabled = category_group_enabled;
    data_.name = name;
    data_.event_handle = event_handle;
    p_data_ = &data_;
  }",42,,695,4,,void
296947,BLOCK,-1,,<empty>,1,,1,1,,ANY
296966,BLOCK,-1,,<empty>,1,,1,1,,ANY
296972,BLOCK,-1,,"{
  std::string result;
  result += '""';
  char number_buffer[10];
#if defined(NODE_HAVE_I18N_SUPPORT)
  int32_t len = strlen(value);
  int32_t p = 0;
  int32_t i = 0;
  for (; i < len; p = i) {
    UChar32 c;
    U8_NEXT_OR_FFFD(value, i, len, c);
    switch (c) {
      case '\b': result += ""\\b""; break;
      case '\f': result += ""\\f""; break;
      case '\n': result += ""\\n""; break;
      case '\r': result += ""\\r""; break;
      case '\t': result += ""\\t""; break;
      case '\\': result += ""\\\\""; break;
      case '""': result += ""\\\""""; break;
      default:
        if (c < 32 || c > 126) {
          snprintf(
              number_buffer, arraysize(number_buffer), ""\\u%04X"",
              static_cast<uint16_t>(static_cast<uint16_t>(c)));
          result += number_buffer;
        } else {
          result.append(value + p, i - p);
        }
    }
  }
#else
  // If we do not have ICU, use a modified version of the non-UTF8 aware
  // code from V8's own TracedValue implementation....",45,,29,2,,void
296981,BLOCK,-1,,"{
    char c = *value++;
    switch (c) {
      case '\b': result += ""\\b""; break;
      case '\f': result += ""\\f""; break;
      case '\n': result += ""\\n""; break;
      case '\r': result += ""\\r""; break;
      case '\t': result += ""\\t""; break;
      case '\\': result += ""\\\\""; break;
      case '""': result += ""\\\""""; break;
      default:
        if (c < '\x20') {
          snprintf(
              number_buffer, arraysize(number_buffer), ""\\u%04X"",
              static_cast<unsigned>(static_cast<unsigned char>(c)));
          result += number_buffer;
        } else {
          result += c;
        }
    }
  }",18,,63,2,,void
296990,BLOCK,-1,,"{
      case '\b': result += ""\\b""; break;
      case '\f': result += ""\\f""; break;
      case '\n': result += ""\\n""; break;
      case '\r': result += ""\\r""; break;
      case '\t': result += ""\\t""; break;
      case '\\': result += ""\\\\""; break;
      case '""': result += ""\\\""""; break;
      default:
        if (c < '\x20') {
          snprintf(
              number_buffer, arraysize(number_buffer), ""\\u%04X"",
              static_cast<unsigned>(static_cast<unsigned char>(c)));
          result += number_buffer;
        } else {
          result += c;
        }
    }",16,,65,2,,void
297038,BLOCK,-1,,"{
          snprintf(
              number_buffer, arraysize(number_buffer), ""\\u%04X"",
              static_cast<unsigned>(static_cast<unsigned char>(c)));
          result += number_buffer;
        }",25,,74,2,,void
297053,BLOCK,-1,,"{
          result += c;
        }",16,,79,1,,void
297066,BLOCK,-1,,"{
  switch (FPCLASSIFY_NAMESPACE::fpclassify(v)) {
    case FP_NAN: return ""\""NaN\"""";
    case FP_INFINITE: return (v < 0.0 ? ""\""-Infinity\"""" : ""\""Infinity\"""");
    case FP_ZERO: return ""0"";
    default:
      // This is a far less sophisticated version than the one used inside v8.
      std::ostringstream stream;
      stream.imbue(std::locale::classic());  // Ignore current locale
      stream << v;
      return stream.str();
  }
}",39,,89,2,,void
297069,BLOCK,1,,<empty>,,,,1,,void
297075,BLOCK,-1,,"{
    case FP_NAN: return ""\""NaN\"""";
    case FP_INFINITE: return (v < 0.0 ? ""\""-Infinity\"""" : ""\""Infinity\"""");
    case FP_ZERO: return ""0"";
    default:
      // This is a far less sophisticated version than the one used inside v8.
      std::ostringstream stream;
      stream.imbue(std::locale::classic());  // Ignore current locale
      stream << v;
      return stream.str();
  }",48,,90,2,,void
297116,BLOCK,-1,,"{
  return std::unique_ptr<TracedValue>(new TracedValue(false));
}",52,,105,1,,void
297130,BLOCK,-1,,"{
  return std::unique_ptr<TracedValue>(new TracedValue(true));
}",57,,109,1,,void
297145,BLOCK,-1,,<empty>,54,,114,2,,void
297151,BLOCK,-1,,"{
  WriteName(name);
  data_ += std::to_string(value);
}",59,,116,3,,void
297166,BLOCK,-1,,"{
  WriteName(name);
  data_ += DoubleToCString(value);
}",61,,121,3,,void
297178,BLOCK,-1,,"{
  WriteName(name);
  data_ += value ? ""true"" : ""false"";
}",60,,126,3,,void
297191,BLOCK,-1,,"{
  WriteName(name);
  data_ += ""null"";
}",45,,131,2,,void
297202,BLOCK,-1,,"{
  WriteName(name);
  data_ += EscapeString(value);
}",66,,136,3,,void
297213,BLOCK,-1,,"{
  WriteName(name);
  data_ += '{';
  first_item_ = true;
}",53,,141,2,,void
297226,BLOCK,-1,,"{
  WriteName(name);
  data_ += '[';
  first_item_ = true;
}",48,,147,2,,void
297239,BLOCK,-1,,"{
  WriteComma();
  data_ += std::to_string(value);
}",44,,153,2,,void
297252,BLOCK,-1,,"{
  WriteComma();
  data_ += DoubleToCString(value);
}",46,,158,2,,void
297262,BLOCK,-1,,"{
  WriteComma();
  data_ += value ? ""true"" : ""false"";
}",45,,163,2,,void
297273,BLOCK,-1,,"{
  WriteComma();
  data_ += ""null"";
}",32,,168,1,,void
297282,BLOCK,-1,,"{
  WriteComma();
  data_ += EscapeString(value);
}",51,,173,2,,void
297291,BLOCK,-1,,"{
  WriteComma();
  data_ += '{';
  first_item_ = true;
}",37,,178,1,,void
297302,BLOCK,-1,,"{
  WriteComma();
  data_ += '[';
  first_item_ = true;
}",32,,184,1,,void
297313,BLOCK,-1,,"{
  data_ += '}';
  first_item_ = false;
}",35,,190,1,,void
297323,BLOCK,-1,,"{
  data_ += ']';
  first_item_ = false;
}",30,,195,1,,void
297333,BLOCK,-1,,"{
  if (first_item_) {
    first_item_ = false;
  } else {
    data_ += ',';
  }
}",32,,200,1,,void
297336,BLOCK,-1,,"{
    first_item_ = false;
  }",20,,201,2,,void
297341,BLOCK,-1,,"{
    data_ += ',';
  }",10,,203,1,,void
297349,BLOCK,-1,,"{
  WriteComma();
  data_ += '""';
  data_ += name;
  data_ += ""\"":"";
}",47,,208,2,,void
297364,BLOCK,-1,,"{
  *out += root_is_array_ ? '[' : '{';
  *out += data_;
  *out += root_is_array_ ? ']' : '}';
}",63,,215,2,,void
297401,BLOCK,-1,,<empty>,1,,1,1,,ANY
297406,BLOCK,-1,,<empty>,,,,1,,<empty>
297410,BLOCK,-1,,<empty>,,,,1,,<empty>
297414,BLOCK,-1,,<empty>,,,,1,,<empty>
297418,BLOCK,-1,,<empty>,,,,1,,<empty>
297422,BLOCK,-1,,<empty>,,,,1,,<empty>
297428,BLOCK,-1,,<empty>,,,,3,,<empty>
297434,BLOCK,-1,,<empty>,,,,3,,<empty>
297440,BLOCK,-1,,<empty>,,,,3,,<empty>
297445,BLOCK,-1,,<empty>,,,,2,,<empty>
297451,BLOCK,-1,,<empty>,,,,3,,<empty>
297457,BLOCK,-1,,"{
    SetString(name, value.c_str());
  }",62,,35,3,,void
297468,BLOCK,-1,,<empty>,,,,2,,<empty>
297473,BLOCK,-1,,<empty>,,,,2,,<empty>
297478,BLOCK,-1,,<empty>,,,,2,,<empty>
297483,BLOCK,-1,,<empty>,,,,2,,<empty>
297488,BLOCK,-1,,<empty>,,,,2,,<empty>
297492,BLOCK,-1,,<empty>,,,,1,,<empty>
297497,BLOCK,-1,,<empty>,,,,2,,<empty>
297502,BLOCK,-1,,{ AppendString(value.c_str()); },47,,46,2,,void
297511,BLOCK,-1,,<empty>,,,,1,,<empty>
297515,BLOCK,-1,,<empty>,,,,1,,<empty>
297520,BLOCK,-1,,<empty>,,,,2,,<empty>
297525,BLOCK,-1,,<empty>,,,,2,,<empty>
297530,BLOCK,-1,,<empty>,,,,2,,<empty>
297535,BLOCK,-1,,<empty>,,,,2,,<empty>
297539,BLOCK,-1,,<empty>,,,,1,,<empty>
297544,BLOCK,-1,,<empty>,,,,2,,<empty>
297570,BLOCK,-1,,<empty>,1,,1,1,,ANY
297574,BLOCK,-1,,"{
  registry->Register(New);
  registry->Register(GetWindowSize);
  registry->Register(SetRawMode);
  registry->Register(IsTTY);
}",79,,45,2,,void
297602,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<String> ttyString = FIXED_ONE_BYTE_STRING(env->isolate(), ""TTY"");

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);
  t->SetClassName(ttyString);
  t->InstanceTemplate()->SetInternalFieldCount(StreamBase::kInternalFieldCount);
  t->Inherit(LibuvStreamWrap::GetConstructorTemplate(env));

  SetProtoMethodNoSideEffect(
      isolate, t, ""getWindowSize"", TTYWrap::GetWindowSize);
  SetProtoMethod(isolate, t, ""setRawMode"", SetRawMode);

  SetMethodNoSideEffect(context, target, ""isTTY"", IsTTY);

  Local<Value> func;
  if (t->GetFunction(context).ToLocal(&func) &&
      target->Set(context, ttyString, func).IsJust()) {
    env->set_tty_constructor_template(t);
  }
}",38,,55,5,,void
297707,BLOCK,-1,,"{
    env->set_tty_constructor_template(t);
  }",55,,74,2,,void
297717,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  int fd;
  if (!args[0]->Int32Value(env->context()).To(&fd)) return;
  CHECK_GE(fd, 0);
  bool rc = uv_guess_handle(fd) == UV_TTY;
  args.GetReturnValue().Set(rc);
}",62,,80,2,,void
297744,BLOCK,-1,,<empty>,53,,83,2,,void
297768,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  TTYWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));
  CHECK(args[0]->IsArray());

  int width, height;
  int err = uv_tty_get_winsize(&wrap->handle_, &width, &height);

  if (err == 0) {
    Local<Array> a = args[0].As<Array>();
    a->Set(env->context(), 0, Integer::New(env->isolate(), width)).Check();
    a->Set(env->context(), 1, Integer::New(env->isolate(), height)).Check();
  }

  args.GetReturnValue().Set(err);
}",70,,90,2,,void
297818,BLOCK,-1,,"{
    Local<Array> a = args[0].As<Array>();
    a->Set(env->context(), 0, Integer::New(env->isolate(), width)).Check();
    a->Set(env->context(), 1, Integer::New(env->isolate(), height)).Check();
  }",17,,102,2,,void
297885,BLOCK,-1,,"{
  TTYWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));
  int err = uv_tty_set_mode(&wrap->handle_, args[0]->IsTrue());
  args.GetReturnValue().Set(err);
}",67,,112,2,,void
297928,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  // This constructor should not be exposed to public javascript.
  // Therefore we assert that we are not trying to call this as a
  // normal function.
  CHECK(args.IsConstructCall());

  int fd;
  if (!args[0]->Int32Value(env->context()).To(&fd)) return;
  CHECK_GE(fd, 0);

  int err = 0;
  new TTYWrap(env, args.This(), fd, &err);
  if (err != 0) {
    env->CollectUVExceptionInfo(args[1], err, ""uv_tty_init"");
    args.GetReturnValue().SetUndefined();
  }
}",60,,122,2,,void
297960,BLOCK,-1,,<empty>,53,,131,2,,void
297983,BLOCK,-1,,"{
    env->CollectUVExceptionInfo(args[1], err, ""uv_tty_init"");
    args.GetReturnValue().SetUndefined();
  }",17,,136,2,,void
298007,BLOCK,-1,,"{
  *init_err = uv_tty_init(env->event_loop(), &handle_, fd, 0);
  set_fd(fd);
  if (*init_err != 0)
    MarkAsUninitialized();
}",52,,150,5,,void
298027,BLOCK,-1,,<empty>,5,,154,2,,void
298040,BLOCK,-1,,<empty>,1,,1,1,,ANY
298045,BLOCK,-1,,"{
          UDPWrap* self = ContainerOf(&UDPWrap::handle_, req->handle);
          self->listener()->OnSendDone(
              ReqWrap<uv_udp_send_t>::from_req(req), status);
        }",59,,601,3,,void
298096,BLOCK,-1,,<empty>,1,,1,1,,ANY
298101,BLOCK,-1,,"{
  UDPWrap* wrap = Unwrap<UDPWrap>(args.Holder());
  if (wrap == nullptr) {
    args.GetReturnValue().Set(UV_EBADF);
    return;
  }
  Environment* env = wrap->env();
  CHECK_EQ(args.Length(), 1);
  int flag;
  if (!args[0]->Int32Value(env->context()).To(&flag)) {
    return;
  }
  int err = fn(wrap->GetLibuvHandle(), flag);
  args.GetReturnValue().Set(err);
}",61,,57,2,,void
298117,BLOCK,-1,,"{
    args.GetReturnValue().Set(UV_EBADF);
    return;
  }",24,,59,2,,void
298158,BLOCK,-1,,"{
    return;
  }",55,,66,2,,void
298184,BLOCK,-1,,<empty>,,,,4,,<empty>
298188,BLOCK,-1,,<empty>,,,,1,,<empty>
298197,BLOCK,-1,,"{
}",37,,93,4,,void
298201,BLOCK,-1,,"{
  return have_callback_;
}",38,,97,1,,void
298207,BLOCK,-1,,"{
  if (wrap_ != nullptr)
    wrap_->set_listener(nullptr);
}",29,,101,1,,void
298212,BLOCK,-1,,<empty>,5,,103,2,,void
298221,BLOCK,-1,,"{
  set_listener(nullptr);
}",29,,106,1,,void
298227,BLOCK,-1,,"{
  CHECK_NOT_NULL(listener_);
  return listener_;
}",44,,110,1,,void
298235,BLOCK,-1,,"{
  if (listener_ != nullptr)
    listener_->wrap_ = nullptr;
  listener_ = listener;
  if (listener_ != nullptr) {
    CHECK_NULL(listener_->wrap_);
    listener_->wrap_ = this;
  }
}",55,,115,2,,void
298240,BLOCK,-1,,<empty>,5,,117,2,,void
298253,BLOCK,-1,,"{
    CHECK_NULL(listener_->wrap_);
    listener_->wrap_ = this;
  }",29,,119,2,,void
298267,BLOCK,-1,,"{
  CHECK_GT(obj->InternalFieldCount(), UDPWrapBase::kUDPWrapBaseField);
  return static_cast<UDPWrapBase*>(
      obj->GetAlignedPointerFromInternalField(UDPWrapBase::kUDPWrapBaseField));
}",57,,125,2,,void
298291,BLOCK,-1,,"{
  SetProtoMethod(env->isolate(), t, ""recvStart"", RecvStart);
  SetProtoMethod(env->isolate(), t, ""recvStop"", RecvStop);
}",75,,131,3,,void
298313,BLOCK,-1,,"{
  object->SetAlignedPointerInInternalField(
      UDPWrapBase::kUDPWrapBaseField, static_cast<UDPWrapBase*>(this));

  int r = uv_udp_init(env->event_loop(), &handle_);
  CHECK_EQ(r, 0);  // can't fail anyway

  set_listener(this);
}",47,,140,3,,void
298346,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);
  t->InstanceTemplate()->SetInternalFieldCount(
      UDPWrapBase::kInternalFieldCount);

  enum PropertyAttribute attributes =
      static_cast<PropertyAttribute>(ReadOnly | DontDelete);

  Local<Signature> signature = Signature::New(isolate, t);

  Local<FunctionTemplate> get_fd_templ =
      FunctionTemplate::New(isolate, UDPWrap::GetFD, Local<Value>(), signature);

  t->PrototypeTemplate()->SetAccessorProperty(env->fd_string(),
                                              get_fd_templ,
                                              Local<FunctionTemplate>(),
                                              attributes);

  UDPWrapBase::AddMethods(env, t);
  SetProtoMethod(isolate, t, ""open"", Open);
  SetProtoMethod(isolate, t, ""bind"", Bind);
  SetProtoMethod(isolate, t, ""connect"", Connect);
  SetProtoMethod(isolate, t, ""send...",38,,154,5,,void
298614,BLOCK,1,,<empty>,,,,7,,void
298616,BLOCK,-1,,"NODE_DEFINE_CONSTANT(constants, UV_UDP_IPV6ONLY)",3,,225,1,,void
298713,BLOCK,1,,<empty>,,,,7,,void
298715,BLOCK,-1,,"NODE_DEFINE_CONSTANT(constants, UV_UDP_REUSEADDR)",3,,226,1,,void
298824,BLOCK,-1,,"{
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);
  new UDPWrap(env, args.This());
}",60,,233,2,,void
298849,BLOCK,-1,,"{
  int fd = UV_EBADF;
#if !defined(_WIN32)
  UDPWrap* wrap = Unwrap<UDPWrap>(args.This());
  if (wrap != nullptr)
    uv_fileno(reinterpret_cast<uv_handle_t*>(&wrap->handle_), &fd);
#endif
  args.GetReturnValue().Set(fd);
}",62,,240,2,,void
298869,BLOCK,-1,,<empty>,5,,245,2,,void
298894,BLOCK,-1,,"{
  switch (address_family) {
    case AF_INET:
      return uv_ip4_addr(address, port, reinterpret_cast<sockaddr_in*>(addr));
    case AF_INET6:
      return uv_ip6_addr(address, port, reinterpret_cast<sockaddr_in6*>(addr));
    default:
      UNREACHABLE(""unexpected address family"");
  }
}",56,,253,5,,void
298897,BLOCK,-1,,"{
    case AF_INET:
      return uv_ip4_addr(address, port, reinterpret_cast<sockaddr_in*>(addr));
    case AF_INET6:
      return uv_ip6_addr(address, port, reinterpret_cast<sockaddr_in6*>(addr));
    default:
      UNREACHABLE(""unexpected address family"");
  }",27,,254,2,,void
298924,BLOCK,-1,,"{
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));

  // bind(ip, port, flags)
  CHECK_EQ(args.Length(), 3);

  node::Utf8Value address(args.GetIsolate(), args[0]);
  Local<Context> ctx = args.GetIsolate()->GetCurrentContext();
  uint32_t port, flags;
  if (!args[1]->Uint32Value(ctx).To(&port) ||
      !args[2]->Uint32Value(ctx).To(&flags))
    return;
  struct sockaddr_storage addr_storage;
  int err = sockaddr_for_family(family, address.out(), port, &addr_storage);
  if (err == 0) {
    err = uv_udp_bind(&wrap->handle_,
                      reinterpret_cast<const sockaddr*>(&addr_storage),
                      flags);
  }

  if (err == 0)
    wrap->listener()->OnAfterBind();

  args.GetReturnValue().Set(err);
}",75,,264,3,,void
298999,BLOCK,-1,,<empty>,5,,278,2,,void
299018,BLOCK,-1,,"{
    err = uv_udp_bind(&wrap->handle_,
                      reinterpret_cast<const sockaddr*>(&addr_storage),
                      flags);
  }",17,,281,2,,void
299035,BLOCK,-1,,<empty>,5,,288,2,,void
299056,BLOCK,-1,,"{
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));

  CHECK_EQ(args.Length(), 2);

  node::Utf8Value address(args.GetIsolate(), args[0]);
  Local<Context> ctx = args.GetIsolate()->GetCurrentContext();
  uint32_t port;
  if (!args[1]->Uint32Value(ctx).To(&port))
    return;
  struct sockaddr_storage addr_storage;
  int err = sockaddr_for_family(family, address.out(), port, &addr_storage);
  if (err == 0) {
    err = uv_udp_connect(&wrap->handle_,
                         reinterpret_cast<const sockaddr*>(&addr_storage));
  }

  args.GetReturnValue().Set(err);
}",78,,294,3,,void
299116,BLOCK,-1,,<empty>,5,,306,2,,void
299135,BLOCK,-1,,"{
    err = uv_udp_connect(&wrap->handle_,
                         reinterpret_cast<const sockaddr*>(&addr_storage));
  }",17,,309,2,,void
299159,BLOCK,-1,,"{
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));
  CHECK(args[0]->IsNumber());
  int fd = static_cast<int>(args[0].As<Integer>()->Value());
  int err = uv_udp_open(&wrap->handle_, fd);

  args.GetReturnValue().Set(err);
}",61,,318,2,,void
299218,BLOCK,-1,,"{
  DoBind(args, AF_INET);
}",61,,331,2,,void
299226,BLOCK,-1,,"{
  DoBind(args, AF_INET6);
}",62,,336,2,,void
299234,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));

  CHECK(args[0]->IsUint32());
  CHECK(args[1]->IsBoolean());
  bool is_recv = args[1].As<Boolean>()->Value();
  const char* uv_func_name = is_recv ? ""uv_recv_buffer_size"" :
                                       ""uv_send_buffer_size"";

  if (!args[0]->IsInt32()) {
    env->CollectUVExceptionInfo(args[2], UV_EINVAL, uv_func_name);
    return args.GetReturnValue().SetUndefined();
  }

  uv_handle_t* handle = reinterpret_cast<uv_handle_t*>(&wrap->handle_);
  int size = static_cast<int>(args[0].As<Uint32>()->Value());
  int err;

  if (is_recv)
    err = uv_recv_buffer_size(handle, &size);
  else
    err = uv_send_buffer_size(handle, &size);

  if (err != 0) {
    env->CollectUVExceptionInfo(args[2], err, uv_func_name);
    return args.GetReturnValue().SetUndefined();
  }

  args....",67,,341,2,,void
299300,BLOCK,-1,,"{
    env->CollectUVExceptionInfo(args[2], UV_EINVAL, uv_func_name);
    return args.GetReturnValue().SetUndefined();
  }",28,,354,2,,void
299344,BLOCK,-1,,<empty>,5,,364,2,,void
299352,BLOCK,-1,,<empty>,5,,366,1,,void
299363,BLOCK,-1,,"{
    env->CollectUVExceptionInfo(args[2], err, uv_func_name);
    return args.GetReturnValue().SetUndefined();
  }",17,,368,2,,void
299393,BLOCK,-1,,"{
  DoConnect(args, AF_INET);
}",64,,377,2,,void
299401,BLOCK,-1,,"{
  DoConnect(args, AF_INET6);
}",65,,382,2,,void
299409,BLOCK,-1,,"{
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));

  CHECK_EQ(args.Length(), 0);

  int err = uv_udp_connect(&wrap->handle_, nullptr);

  args.GetReturnValue().Set(err);
}",67,,387,2,,void
299453,BLOCK,-1,,"{
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsString());

  Utf8Value iface(args.GetIsolate(), args[0]);

  const char* iface_cstr = *iface;

  int err = uv_udp_set_multicast_interface(&wrap->handle_, iface_cstr);
  args.GetReturnValue().Set(err);
}",78,,400,2,,void
299519,BLOCK,-1,,"{
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));

  CHECK_EQ(args.Length(), 2);

  node::Utf8Value address(args.GetIsolate(), args[0]);
  node::Utf8Value iface(args.GetIsolate(), args[1]);

  const char* iface_cstr = *iface;
  if (args[1]->IsUndefined() || args[1]->IsNull()) {
      iface_cstr = nullptr;
  }

  int err = uv_udp_set_membership(&wrap->handle_,
                                  *address,
                                  iface_cstr,
                                  membership);
  args.GetReturnValue().Set(err);
}",55,,418,3,,void
299579,BLOCK,-1,,"{
      iface_cstr = nullptr;
  }",52,,430,2,,void
299607,BLOCK,-1,,"{
  SetMembership(args, UV_JOIN_GROUP);
}",70,,442,2,,void
299615,BLOCK,-1,,"{
  SetMembership(args, UV_LEAVE_GROUP);
}",71,,447,2,,void
299624,BLOCK,-1,,"{
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));

  CHECK_EQ(args.Length(), 3);

  node::Utf8Value source_address(args.GetIsolate(), args[0]);
  node::Utf8Value group_address(args.GetIsolate(), args[1]);
  node::Utf8Value iface(args.GetIsolate(), args[2]);

  if (*iface == nullptr) return;
  const char* iface_cstr = *iface;
  if (args[2]->IsUndefined() || args[2]->IsNull()) {
    iface_cstr = nullptr;
  }

  int err = uv_udp_set_source_membership(&wrap->handle_,
                                         *group_address,
                                         iface_cstr,
                                         *source_address,
                                         membership);
  args.GetReturnValue().Set(err);
}",61,,452,3,,void
299679,BLOCK,-1,,<empty>,26,,464,2,,void
299700,BLOCK,-1,,"{
    iface_cstr = nullptr;
  }",52,,466,2,,void
299730,BLOCK,-1,,"{
  SetSourceMembership(args, UV_JOIN_GROUP);
}",44,,479,2,,void
299738,BLOCK,-1,,"{
  SetSourceMembership(args, UV_LEAVE_GROUP);
}",44,,485,2,,void
299747,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);

  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));

  CHECK(args.Length() == 4 || args.Length() == 6);
  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsArray());
  CHECK(args[2]->IsUint32());

  bool sendto = args.Length() == 6;
  if (sendto) {
    // send(req, list, list.length, port, address, hasCallback)
    CHECK(args[3]->IsUint32());
    CHECK(args[4]->IsString());
    CHECK(args[5]->IsBoolean());
  } else {
    // send(req, list, list.length, hasCallback)
    CHECK(args[3]->IsBoolean());
  }

  Local<Array> chunks = args[1].As<Array>();
  // it is faster to fetch the length of the
  // array in js-land
  size_t count = args[2].As<Uint32>()->Value();

  MaybeStackBuffer<uv_buf_t, 16> bufs(count);

  // construct uv_buf_t array
  for (size_t i = 0; i < count; i++) {
    Local<Value> chunk;
    if (!chunks->Get(env->context...",75,,490,3,,void
299818,BLOCK,-1,,"{
    // send(req, list, list.length, port, address, hasCallback)
    CHECK(args[3]->IsUint32());
    CHECK(args[4]->IsString());
    CHECK(args[5]->IsBoolean());
  }",15,,504,2,,void
299841,BLOCK,-1,,"{
    // send(req, list, list.length, hasCallback)
    CHECK(args[3]->IsBoolean());
  }",10,,509,1,,void
299882,BLOCK,-1,,<empty>,3,,522,1,,void
299892,BLOCK,4,,"{
    Local<Value> chunk;
    if (!chunks->Get(env->context(), i).ToLocal(&chunk)) return;

    size_t length = Buffer::Length(chunk);

    bufs[i] = uv_buf_init(Buffer::Data(chunk), length);
  }",38,,522,4,,void
299914,BLOCK,-1,,<empty>,58,,524,2,,void
299946,BLOCK,-1,,"{
    const unsigned short port = args[3].As<Uint32>()->Value();
    node::Utf8Value address(env->isolate(), args[4]);
    err = sockaddr_for_family(family, address.out(), port, &addr_storage);
    if (err == 0)
      addr = reinterpret_cast<sockaddr*>(&addr_storage);
  }",15,,534,2,,void
299983,BLOCK,-1,,<empty>,7,,539,2,,void
299994,BLOCK,-1,,"{
    wrap->current_send_req_wrap_ = args[0].As<Object>();
    wrap->current_send_has_callback_ =
        sendto ? args[5]->IsTrue() : args[3]->IsTrue();

    err = static_cast<int>(wrap->Send(*bufs, count, addr));

    wrap->current_send_req_wrap_.Clear();
    wrap->current_send_has_callback_ = false;
  }",17,,542,2,,void
300060,BLOCK,-1,,"{
  if (IsHandleClosing()) return UV_EBADF;

  size_t msg_size = 0;
  for (size_t i = 0; i < count; i++)
    msg_size += bufs_ptr[i].len;

  int err = 0;
  if (!UNLIKELY(env()->options()->test_udp_no_try_send)) {
    err = uv_udp_try_send(&handle_, bufs_ptr, count, addr);
    if (err == UV_ENOSYS || err == UV_EAGAIN) {
      err = 0;
    } else if (err >= 0) {
      size_t sent = err;
      while (count > 0 && bufs_ptr->len <= sent) {
        sent -= bufs_ptr->len;
        bufs_ptr++;
        count--;
      }
      if (count > 0) {
        CHECK_LT(sent, bufs_ptr->len);
        bufs_ptr->base += sent;
        bufs_ptr->len -= sent;
      } else {
        CHECK_EQ(static_cast<size_t>(err), msg_size);
        // + 1 so that the JS side can distinguish 0-length async sends from
        // 0-length sync sends.
        return msg_size + 1;
      }
    }
  }

  if (err == 0) {
    AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(this);
    ReqWrap<uv_udp_send_t>* req_wrap = listener()...",45,,558,4,,void
300063,BLOCK,-1,,<empty>,26,,559,2,,void
300071,BLOCK,-1,,<empty>,3,,562,1,,void
300101,BLOCK,-1,,"{
    err = uv_udp_try_send(&handle_, bufs_ptr, count, addr);
    if (err == UV_ENOSYS || err == UV_EAGAIN) {
      err = 0;
    } else if (err >= 0) {
      size_t sent = err;
      while (count > 0 && bufs_ptr->len <= sent) {
        sent -= bufs_ptr->len;
        bufs_ptr++;
        count--;
      }
      if (count > 0) {
        CHECK_LT(sent, bufs_ptr->len);
        bufs_ptr->base += sent;
        bufs_ptr->len -= sent;
      } else {
        CHECK_EQ(static_cast<size_t>(err), msg_size);
        // + 1 so that the JS side can distinguish 0-length async sends from
        // 0-length sync sends.
        return msg_size + 1;
      }
    }
  }",58,,566,2,,void
300118,BLOCK,-1,,"{
      err = 0;
    }",47,,568,2,,void
300123,BLOCK,-1,,<empty>,12,,570,1,,void
300128,BLOCK,-1,,"{
      size_t sent = err;
      while (count > 0 && bufs_ptr->len <= sent) {
        sent -= bufs_ptr->len;
        bufs_ptr++;
        count--;
      }
      if (count > 0) {
        CHECK_LT(sent, bufs_ptr->len);
        bufs_ptr->base += sent;
        bufs_ptr->len -= sent;
      } else {
        CHECK_EQ(static_cast<size_t>(err), msg_size);
        // + 1 so that the JS side can distinguish 0-length async sends from
        // 0-length sync sends.
        return msg_size + 1;
      }
    }",26,,570,2,,void
300143,BLOCK,-1,,"{
        sent -= bufs_ptr->len;
        bufs_ptr++;
        count--;
      }",50,,572,2,,void
300157,BLOCK,-1,,"{
        CHECK_LT(sent, bufs_ptr->len);
        bufs_ptr->base += sent;
        bufs_ptr->len -= sent;
      }",22,,577,2,,void
300174,BLOCK,-1,,"{
        CHECK_EQ(static_cast<size_t>(err), msg_size);
        // + 1 so that the JS side can distinguish 0-length async sends from
        // 0-length sync sends.
        return msg_size + 1;
      }",14,,581,1,,void
300188,BLOCK,-1,,"{
    AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(this);
    ReqWrap<uv_udp_send_t>* req_wrap = listener()->CreateSendWrap(msg_size);
    if (req_wrap == nullptr) return UV_ENOSYS;

    err = req_wrap->Dispatch(
        uv_udp_send,
        &handle_,
        bufs_ptr,
        count,
        addr,
        uv_udp_send_cb{[](uv_udp_send_t* req, int status) {
          UDPWrap* self = ContainerOf(&UDPWrap::handle_, req->handle);
          self->listener()->OnSendDone(
              ReqWrap<uv_udp_send_t>::from_req(req), status);
        }});
    if (err)
      delete req_wrap;
  }",17,,590,2,,void
300208,BLOCK,-1,,<empty>,30,,593,2,,void
300228,BLOCK,-1,,<empty>,7,,607,2,,void
300237,BLOCK,-1,,"{
  SendWrap* req_wrap = new SendWrap(env(),
                                    current_send_req_wrap_,
                                    current_send_has_callback_);
  req_wrap->msg_size = msg_size;
  return req_wrap;
}",66,,614,2,,void
300257,BLOCK,-1,,"{
  DoSend(args, AF_INET);
}",61,,623,2,,void
300265,BLOCK,-1,,"{
  DoSend(args, AF_INET6);
}",62,,628,2,,void
300272,BLOCK,-1,,"{
  return this;
}",36,,633,1,,void
300278,BLOCK,-1,,"{
  return SocketAddress::FromPeerName(handle_);
}",38,,637,1,,void
300288,BLOCK,-1,,"{
  return SocketAddress::FromSockName(handle_);
}",38,,641,1,,void
300299,BLOCK,-1,,"{
  UDPWrapBase* wrap = UDPWrapBase::FromObject(args.Holder());
  args.GetReturnValue().Set(wrap == nullptr ? UV_EBADF : wrap->RecvStart());
}",70,,645,2,,void
300330,BLOCK,-1,,"{
  if (IsHandleClosing()) return UV_EBADF;
  int err = uv_udp_recv_start(&handle_, OnAlloc, OnRecv);
  // UV_EALREADY means that the socket is already bound but that's okay
  if (err == UV_EALREADY)
    err = 0;
  return err;
}",26,,650,1,,void
300333,BLOCK,-1,,<empty>,26,,651,2,,void
300348,BLOCK,-1,,<empty>,5,,655,2,,void
300358,BLOCK,-1,,"{
  UDPWrapBase* wrap = UDPWrapBase::FromObject(args.Holder());
  args.GetReturnValue().Set(wrap == nullptr ? UV_EBADF : wrap->RecvStop());
}",69,,660,2,,void
300389,BLOCK,-1,,"{
  if (IsHandleClosing()) return UV_EBADF;
  return uv_udp_recv_stop(&handle_);
}",25,,665,1,,void
300392,BLOCK,-1,,<empty>,26,,666,2,,void
300404,BLOCK,-1,,"{
  BaseObjectPtr<SendWrap> req_wrap{static_cast<SendWrap*>(req)};
  if (req_wrap->have_callback()) {
    Environment* env = req_wrap->env();
    HandleScope handle_scope(env->isolate());
    Context::Scope context_scope(env->context());
    Local<Value> arg[] = {
      Integer::New(env->isolate(), status),
      Integer::New(env->isolate(), req_wrap->msg_size),
    };
    req_wrap->MakeCallback(env->oncomplete_string(), 2, arg);
  }
}",67,,671,3,,void
300419,BLOCK,-1,,"{
    Environment* env = req_wrap->env();
    HandleScope handle_scope(env->isolate());
    Context::Scope context_scope(env->context());
    Local<Value> arg[] = {
      Integer::New(env->isolate(), status),
      Integer::New(env->isolate(), req_wrap->msg_size),
    };
    req_wrap->MakeCallback(env->oncomplete_string(), 2, arg);
  }",34,,673,2,,void
300479,BLOCK,-1,,"{
  UDPWrap* wrap = ContainerOf(&UDPWrap::handle_,
                              reinterpret_cast<uv_udp_t*>(handle));
  *buf = wrap->listener()->OnAlloc(suggested_size);
}",38,,688,4,,void
300506,BLOCK,-1,,"{
  return env()->allocate_managed_buffer(suggested_size);
}",50,,694,2,,void
300521,BLOCK,-1,,"{
  UDPWrap* wrap = ContainerOf(&UDPWrap::handle_, handle);
  wrap->listener()->OnRecv(nread, *buf, addr, flags);
}",42,,702,6,,void
300550,BLOCK,-1,,"{
  Environment* env = this->env();
  Isolate* isolate = env->isolate();
  std::unique_ptr<BackingStore> bs = env->release_managed_buffer(buf_);
  if (nread == 0 && addr == nullptr) {
    return;
  }

  HandleScope handle_scope(isolate);
  Context::Scope context_scope(env->context());

  Local<Value> argv[] = {
      Integer::New(isolate, static_cast<int32_t>(nread)),
      object(),
      Undefined(isolate),
      Undefined(isolate)};

  if (nread < 0) {
    MakeCallback(env->onmessage_string(), arraysize(argv), argv);
    return;
  } else if (nread == 0) {
    bs = ArrayBuffer::NewBackingStore(isolate, 0);
  } else {
    CHECK_LE(static_cast<size_t>(nread), bs->ByteLength());
    bs = BackingStore::Reallocate(isolate, std::move(bs), nread);
  }

  Local<Object> address;
  {
    bool has_caught = false;
    {
      TryCatchScope try_catch(env);
      if (!AddressToJS(env, addr).ToLocal(&address)) {
        DCHECK(try_catch.HasCaught() && !try_catch.HasTerminated());
        argv[2]...",42,,710,5,,void
300586,BLOCK,-1,,"{
    return;
  }",38,,714,2,,void
300618,BLOCK,-1,,"{
    MakeCallback(env->onmessage_string(), arraysize(argv), argv);
    return;
  }",18,,727,2,,void
300629,BLOCK,-1,,<empty>,10,,730,1,,void
300634,BLOCK,-1,,"{
    bs = ArrayBuffer::NewBackingStore(isolate, 0);
  }",26,,730,2,,void
300644,BLOCK,-1,,"{
    CHECK_LE(static_cast<size_t>(nread), bs->ByteLength());
    bs = BackingStore::Reallocate(isolate, std::move(bs), nread);
  }",10,,732,1,,void
300671,BLOCK,15,,"{
    bool has_caught = false;
    {
      TryCatchScope try_catch(env);
      if (!AddressToJS(env, addr).ToLocal(&address)) {
        DCHECK(try_catch.HasCaught() && !try_catch.HasTerminated());
        argv[2] = try_catch.Exception();
        DCHECK(!argv[2].IsEmpty());
        has_caught = true;
      }
    }
    if (has_caught) {
      DCHECK(!argv[2].IsEmpty());
      MakeCallback(env->onerror_string(), arraysize(argv), argv);
      return;
    }
  }",3,,738,15,,void
300676,BLOCK,3,,"{
      TryCatchScope try_catch(env);
      if (!AddressToJS(env, addr).ToLocal(&address)) {
        DCHECK(try_catch.HasCaught() && !try_catch.HasTerminated());
        argv[2] = try_catch.Exception();
        DCHECK(!argv[2].IsEmpty());
        has_caught = true;
      }
    }",5,,740,3,,void
300690,BLOCK,-1,,"{
        DCHECK(try_catch.HasCaught() && !try_catch.HasTerminated());
        argv[2] = try_catch.Exception();
        DCHECK(!argv[2].IsEmpty());
        has_caught = true;
      }",54,,742,2,,void
300723,BLOCK,-1,,"{
      DCHECK(!argv[2].IsEmpty());
      MakeCallback(env->onerror_string(), arraysize(argv), argv);
      return;
    }",21,,749,2,,void
300757,BLOCK,17,,"{
    bool has_caught = false;
    {
      TryCatchScope try_catch(env);
      if (!Buffer::New(env, ab, 0, ab->ByteLength()).ToLocal(&argv[2])) {
        DCHECK(try_catch.HasCaught() && !try_catch.HasTerminated());
        argv[2] = try_catch.Exception();
        DCHECK(!argv[2].IsEmpty());
        has_caught = true;
      }
    }
    if (has_caught) {
      DCHECK(!argv[2].IsEmpty());
      MakeCallback(env->onerror_string(), arraysize(argv), argv);
      return;
    }
  }",3,,757,17,,void
300762,BLOCK,3,,"{
      TryCatchScope try_catch(env);
      if (!Buffer::New(env, ab, 0, ab->ByteLength()).ToLocal(&argv[2])) {
        DCHECK(try_catch.HasCaught() && !try_catch.HasTerminated());
        argv[2] = try_catch.Exception();
        DCHECK(!argv[2].IsEmpty());
        has_caught = true;
      }
    }",5,,759,3,,void
300786,BLOCK,-1,,"{
        DCHECK(try_catch.HasCaught() && !try_catch.HasTerminated());
        argv[2] = try_catch.Exception();
        DCHECK(!argv[2].IsEmpty());
        has_caught = true;
      }",73,,761,2,,void
300819,BLOCK,-1,,"{
      DCHECK(!argv[2].IsEmpty());
      MakeCallback(env->onerror_string(), arraysize(argv), argv);
      return;
    }",21,,768,2,,void
300856,BLOCK,-1,,"{
  AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(parent);

  // If this assert fires then Initialize hasn't been called yet.
  CHECK_EQ(env->udp_constructor_function().IsEmpty(), false);
  return env->udp_constructor_function()->NewInstance(env->context());
}",67,,781,4,,void
300885,BLOCK,-1,,"{
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(
      &wrap, args.Holder(), args.GetReturnValue().Set(UV_EBADF));

  size_t size = uv_udp_get_send_queue_size(&wrap->handle_);
  args.GetReturnValue().Set(static_cast<double>(size));
}",73,,789,2,,void
300924,BLOCK,-1,,"{
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(
      &wrap, args.Holder(), args.GetReturnValue().Set(UV_EBADF));

  size_t count = uv_udp_get_send_queue_count(&wrap->handle_);
  args.GetReturnValue().Set(static_cast<double>(count));
}",74,,798,2,,void
300976,BLOCK,-1,,<empty>,1,,1,1,,ANY
300981,BLOCK,-1,,<empty>,1,,1,1,,ANY
300996,BLOCK,-1,,<empty>,1,,1,1,,ANY
300999,BLOCK,-1,,"{
    uv_fs_req_cleanup(&req);
  }",50,,235,1,,void
301009,BLOCK,-1,,"{
    uv_fs_t close_req;
    CHECK_EQ(0, uv_fs_close(nullptr, &close_req, file, nullptr));
    uv_fs_req_cleanup(&close_req);
  }",44,,246,1,,void
301066,BLOCK,-1,,<empty>,1,,1,1,,ANY
301077,BLOCK,-1,,"{
  Local<String> string;
  if (!value->ToString(isolate->GetCurrentContext()).ToLocal(&string)) return;

  size_t storage;
  if (!StringBytes::StorageSize(isolate, string, UTF8).To(&storage)) return;
  storage += 1;
  target->AllocateSufficientStorage(storage);
  const int flags =
      String::NO_NULL_TERMINATION | String::REPLACE_INVALID_UTF8;
  const int length =
      string->WriteUtf8(isolate, target->out(), storage, nullptr, flags);
  target->SetLengthAndZeroTerminate(length);
}",57,,71,4,,void
301098,BLOCK,-1,,<empty>,72,,73,2,,void
301115,BLOCK,-1,,<empty>,70,,76,2,,void
301160,BLOCK,-1,,"{
  if (value.IsEmpty())
    return;

  MakeUtf8String(isolate, value, this);
}",60,,86,3,,void
301166,BLOCK,-1,,<empty>,5,,88,2,,void
301177,BLOCK,-1,,"{
  if (value.IsEmpty()) {
    return;
  }

  Local<String> string;
  if (!value->ToString(isolate->GetCurrentContext()).ToLocal(&string)) return;

  // Allocate enough space to include the null terminator
  const size_t storage = string->Length() + 1;
  AllocateSufficientStorage(storage);

  const int flags = String::NO_NULL_TERMINATION;
  const int length = string->Write(isolate, out(), 0, storage, flags);
  SetLengthAndZeroTerminate(length);
}",66,,94,3,,void
301183,BLOCK,-1,,"{
    return;
  }",24,,95,2,,void
301205,BLOCK,-1,,<empty>,72,,100,2,,void
301243,BLOCK,-1,,"{
  // Slightly different take on Utf8Value. If value is a String,
  // it will return a Utf8 encoded string. If value is a Buffer,
  // it will copy the data out of the Buffer as is.
  if (value.IsEmpty()) {
    // Dereferencing this object will return nullptr.
    Invalidate();
    return;
  }

  if (value->IsString()) {
    MakeUtf8String(isolate, value, this);
  } else if (value->IsArrayBufferView()) {
    const size_t len = value.As<ArrayBufferView>()->ByteLength();
    // Leave place for the terminating '\0' byte.
    AllocateSufficientStorage(len + 1);
    value.As<ArrayBufferView>()->CopyContents(out(), len);
    SetLengthAndZeroTerminate(len);
  } else {
    Invalidate();
  }
}",64,,111,3,,void
301249,BLOCK,-1,,"{
    // Dereferencing this object will return nullptr.
    Invalidate();
    return;
  }",24,,115,2,,void
301257,BLOCK,-1,,"{
    MakeUtf8String(isolate, value, this);
  }",26,,121,2,,void
301263,BLOCK,-1,,<empty>,10,,123,1,,void
301269,BLOCK,-1,,"{
    const size_t len = value.As<ArrayBufferView>()->ByteLength();
    // Leave place for the terminating '\0' byte.
    AllocateSufficientStorage(len + 1);
    value.As<ArrayBufferView>()->CopyContents(out(), len);
    SetLengthAndZeroTerminate(len);
  }",42,,123,2,,void
301296,BLOCK,-1,,"{
    Invalidate();
  }",10,,129,1,,void
301301,BLOCK,-1,,"{
  if (per_process::v8_initialized) {
    auto isolate = Isolate::TryGetCurrent();
    if (isolate != nullptr) {
      isolate->LowMemoryNotification();
    }
  }
}",30,,134,1,,void
301306,BLOCK,-1,,"{
    auto isolate = Isolate::TryGetCurrent();
    if (isolate != nullptr) {
      isolate->LowMemoryNotification();
    }
  }",36,,135,2,,void
301318,BLOCK,-1,,"{
      isolate->LowMemoryNotification();
    }",29,,137,2,,void
301327,BLOCK,-1,,"{
  std::string buf(16, '\0');

  for (;;) {
    const int rc = uv_get_process_title(buf.data(), buf.size());

    if (rc == 0)
      break;

    // If uv_setup_args() was not called, `uv_get_process_title()` will always
    // return `UV_ENOBUFS`, no matter the input size. Guard against a possible
    // infinite loop by limiting the buffer size.
    if (rc != UV_ENOBUFS || buf.size() >= 1024 * 1024)
      return default_title;

    buf.resize(2 * buf.size());
  }

  // Strip excess trailing nul bytes. Using strlen() here is safe,
  // uv_get_process_title() always zero-terminates the result.
  buf.resize(strlen(buf.data()));

  return buf;
}",56,,143,2,,void
301333,BLOCK,-1,,<empty>,3,,146,1,,void
301334,BLOCK,4,,"{
    const int rc = uv_get_process_title(buf.data(), buf.size());

    if (rc == 0)
      break;

    // If uv_setup_args() was not called, `uv_get_process_title()` will always
    // return `UV_ENOBUFS`, no matter the input size. Guard against a possible
    // infinite loop by limiting the buffer size.
    if (rc != UV_ENOBUFS || buf.size() >= 1024 * 1024)
      return default_title;

    buf.resize(2 * buf.size());
  }",12,,146,4,,void
301351,BLOCK,-1,,<empty>,7,,150,2,,void
301366,BLOCK,-1,,<empty>,7,,156,2,,void
301393,BLOCK,-1,,"{
  return SPrintF(""%s[%d]"", GetProcessTitle(""Node.js""), uv_os_getpid());
}",43,,168,1,,void
301405,BLOCK,-1,,"{
  std::vector<std::string_view> out;

  for (auto first = in.data(), second = in.data(), last = first + in.size();
       second != last && first != last;
       first = second + 1) {
    second =
        std::find_first_of(first, last, std::cbegin(delim), std::cend(delim));

    if (first != second) {
      out.emplace_back(first, second - first);
    }
  }

  return out;
}",73,,173,3,,void
301416,BLOCK,-1,,<empty>,3,,176,1,,void
301452,BLOCK,4,,"{
    second =
        std::find_first_of(first, last, std::cbegin(delim), std::cend(delim));

    if (first != second) {
      out.emplace_back(first, second - first);
    }
  }",28,,178,4,,void
301475,BLOCK,-1,,"{
      out.emplace_back(first, second - first);
    }",26,,182,2,,void
301490,BLOCK,-1,,"{
  isolate->ThrowException(ERR_STRING_TOO_LONG(isolate));
}",46,,190,2,,void
301500,BLOCK,-1,,"{
  constexpr double kMicrosecondsPerSecond = 1e6;
  uv_timeval64_t tv;
  CHECK_EQ(0, uv_gettimeofday(&tv));
  return kMicrosecondsPerSecond * tv.tv_sec + tv.tv_usec;
}",39,,194,1,,void
301526,BLOCK,-1,,"{
  uv_fs_t req;
  int fd = uv_fs_open(nullptr,
                      &req,
                      path,
                      O_WRONLY | O_CREAT | O_TRUNC,
                      S_IWUSR | S_IRUSR,
                      nullptr);
  uv_fs_req_cleanup(&req);
  if (fd < 0) {
    return fd;
  }

  int err = uv_fs_write(nullptr, &req, fd, &buf, 1, 0, nullptr);
  uv_fs_req_cleanup(&req);
  if (err < 0) {
    return err;
  }

  err = uv_fs_close(nullptr, &req, fd, nullptr);
  uv_fs_req_cleanup(&req);
  return err;
}",51,,201,3,,void
301552,BLOCK,-1,,"{
    return fd;
  }",15,,210,2,,void
301575,BLOCK,-1,,"{
    return err;
  }",16,,216,2,,void
301597,BLOCK,-1,,"{
  node::Utf8Value utf8(isolate, string);
  uv_buf_t buf = uv_buf_init(utf8.out(), utf8.length());
  return WriteFileSync(path, buf);
}",49,,227,4,,void
301623,BLOCK,-1,,"{
  uv_fs_t req;
  auto defer_req_cleanup = OnScopeLeave([&req]() {
    uv_fs_req_cleanup(&req);
  });

  uv_file file = uv_fs_open(nullptr, &req, path, O_RDONLY, 0, nullptr);
  if (req.result < 0) {
    // req will be cleaned up by scope leave.
    return req.result;
  }
  uv_fs_req_cleanup(&req);

  auto defer_close = OnScopeLeave([file]() {
    uv_fs_t close_req;
    CHECK_EQ(0, uv_fs_close(nullptr, &close_req, file, nullptr));
    uv_fs_req_cleanup(&close_req);
  });

  *result = std::string("""");
  char buffer[4096];
  uv_buf_t buf = uv_buf_init(buffer, sizeof(buffer));

  while (true) {
    const int r =
        uv_fs_read(nullptr, &req, file, &buf, 1, result->length(), nullptr);
    if (req.result < 0) {
      // req will be cleaned up by scope leave.
      return req.result;
    }
    uv_fs_req_cleanup(&req);
    if (r <= 0) {
      break;
    }
    result->append(buf.base, r);
  }
  return 0;
}",57,,233,3,,void
301645,BLOCK,-1,,"{
    // req will be cleaned up by scope leave.
    return req.result;
  }",23,,240,2,,void
301676,BLOCK,-1,,"{
    const int r =
        uv_fs_read(nullptr, &req, file, &buf, 1, result->length(), nullptr);
    if (req.result < 0) {
      // req will be cleaned up by scope leave.
      return req.result;
    }
    uv_fs_req_cleanup(&req);
    if (r <= 0) {
      break;
    }
    result->append(buf.base, r);
  }",16,,256,2,,void
301699,BLOCK,-1,,"{
      // req will be cleaned up by scope leave.
      return req.result;
    }",25,,259,2,,void
301711,BLOCK,-1,,"{
      break;
    }",17,,264,2,,void
301727,BLOCK,-1,,"{
  CHECK_EQ(ftell(fp), 0);
  int err = fseek(fp, 0, SEEK_END);
  CHECK_EQ(err, 0);
  size_t size = ftell(fp);
  CHECK_NE(size, static_cast<size_t>(-1L));
  err = fseek(fp, 0, SEEK_SET);
  CHECK_EQ(err, 0);

  std::vector<char> contents(size);
  size_t num_read = fread(contents.data(), size, 1, fp);
  CHECK_EQ(num_read, 1);
  return contents;
}",42,,272,2,,void
301785,BLOCK,-1,,"{
#ifdef _WIN32
  GetLocalTime(tm_struct);
#else  // UNIX, OSX
  struct timeval time_val;
  gettimeofday(&time_val, nullptr);
  localtime_r(&time_val.tv_sec, tm_struct);
#endif
}",58,,287,2,,void
301803,BLOCK,-1,,"{
  std::ostringstream oss;
  TIME_TYPE tm_struct;
  LocalTime(&tm_struct);
  oss << prefix;
#ifdef _WIN32
  oss << ""."" << std::setfill('0') << std::setw(4) << tm_struct.wYear;
  oss << std::setfill('0') << std::setw(2) << tm_struct.wMonth;
  oss << std::setfill('0') << std::setw(2) << tm_struct.wDay;
  oss << ""."" << std::setfill('0') << std::setw(2) << tm_struct.wHour;
  oss << std::setfill('0') << std::setw(2) << tm_struct.wMinute;
  oss << std::setfill('0') << std::setw(2) << tm_struct.wSecond;
#else  // UNIX, OSX
  oss << "".""
            << std::setfill('0')
            << std::setw(4)
            << tm_struct.tm_year + 1900;
  oss << std::setfill('0')
            << std::setw(2)
            << tm_struct.tm_mon + 1;
  oss << std::setfill('0')
            << std::setw(2)
            << tm_struct.tm_mday;
  oss << "".""
            << std::setfill('0')
            << std::setw(2)
            << tm_struct.tm_hour;
  oss << std::setfill('0')
            << std::setw(2)
            << ...",22,,301,4,,void
301969,BLOCK,-1,,"{
  return v8::FunctionTemplate::New(isolate,
                                   callback,
                                   Local<v8::Value>(),
                                   signature,
                                   0,
                                   behavior,
                                   side_effect_type,
                                   c_function);
}",38,,348,7,,void
301993,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  Local<v8::Function> function =
      NewFunctionTemplate(isolate,
                          callback,
                          Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasSideEffect)
          ->GetFunction(context)
          .ToLocalChecked();
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->Set(context, name_string, function).Check();
  function->SetName(name_string);  // NODE_SET_METHOD() compatibility.
}",47,,362,5,,void
302081,BLOCK,-1,,"{
  Local<v8::FunctionTemplate> t =
      NewFunctionTemplate(isolate,
                          callback,
                          Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasSideEffect);
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->Set(name_string, t);
}",47,,383,5,,void
302147,BLOCK,-1,,"{
  Local<v8::FunctionTemplate> t =
      NewFunctionTemplate(isolate,
                          slow_callback,
                          Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasSideEffect,
                          c_function);
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->Set(name_string, t);
}",53,,401,6,,void
302214,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  Local<v8::Function> function =
      NewFunctionTemplate(isolate,
                          slow_callback,
                          Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasSideEffect,
                          c_function)
          ->GetFunction(context)
          .ToLocalChecked();
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->Set(context, name_string, function).Check();
}",53,,420,6,,void
302299,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  Local<v8::Function> function =
      NewFunctionTemplate(isolate,
                          slow_callback,
                          Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasNoSideEffect,
                          c_function)
          ->GetFunction(context)
          .ToLocalChecked();
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->Set(context, name_string, function).Check();
}",65,,441,6,,void
302384,BLOCK,-1,,"{
  Local<v8::FunctionTemplate> t =
      NewFunctionTemplate(isolate,
                          slow_callback,
                          Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasNoSideEffect,
                          c_function);
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->Set(name_string, t);
}",65,,462,6,,void
302450,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  Local<v8::Function> function =
      NewFunctionTemplate(isolate,
                          callback,
                          Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasNoSideEffect)
          ->GetFunction(context)
          .ToLocalChecked();
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->Set(context, name_string, function).Check();
  function->SetName(name_string);  // NODE_SET_METHOD() compatibility.
}",59,,480,5,,void
302538,BLOCK,-1,,"{
  Local<v8::FunctionTemplate> t =
      NewFunctionTemplate(isolate,
                          callback,
                          Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasNoSideEffect);
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->Set(name_string, t);
}",59,,501,5,,void
302603,BLOCK,-1,,"{
  Local<v8::Signature> signature = v8::Signature::New(isolate, that);
  Local<v8::FunctionTemplate> t =
      NewFunctionTemplate(isolate,
                          callback,
                          signature,
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasSideEffect);
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->PrototypeTemplate()->Set(name_string, t);
  t->SetClassName(name_string);  // NODE_SET_PROTOTYPE_METHOD() compatibility.
}",52,,518,5,,void
302691,BLOCK,-1,,"{
  Local<v8::Signature> signature = v8::Signature::New(isolate, that);
  Local<v8::FunctionTemplate> t =
      NewFunctionTemplate(isolate,
                          callback,
                          signature,
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasNoSideEffect);
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->PrototypeTemplate()->Set(name_string, t);
  t->SetClassName(name_string);  // NODE_SET_PROTOTYPE_METHOD() compatibility.
}",64,,537,5,,void
302779,BLOCK,-1,,"{
  Local<v8::Signature> signature = v8::Signature::New(isolate, that);
  Local<v8::FunctionTemplate> t =
      NewFunctionTemplate(isolate,
                          callback,
                          signature,
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasSideEffect);
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->InstanceTemplate()->Set(name_string, t);
  t->SetClassName(name_string);
}",55,,556,5,,void
302868,BLOCK,-1,,"{
  Isolate* isolate = context->GetIsolate();
  SetConstructorFunction(
      context, that, OneByteString(isolate, name), tmpl, flag);
}",62,,576,6,,void
302892,BLOCK,-1,,"{
  if (LIKELY(flag == SetConstructorFunctionFlag::SET_CLASS_NAME))
    tmpl->SetClassName(name);
  that->Set(context, name, tmpl->GetFunction(context).ToLocalChecked()).Check();
}",62,,586,6,,void
302900,BLOCK,-1,,<empty>,5,,588,2,,void
302931,BLOCK,-1,,"{
  SetConstructorFunction(
      isolate, that, OneByteString(isolate, name), tmpl, flag);
}",62,,596,6,,void
302948,BLOCK,-1,,"{
  if (LIKELY(flag == SetConstructorFunctionFlag::SET_CLASS_NAME))
    tmpl->SetClassName(name);
  that->Set(name, tmpl);
}",62,,605,6,,void
302956,BLOCK,-1,,<empty>,5,,607,2,,void
302972,BLOCK,-1,,"{
  if (is_one_byte()) {
    return String::NewExternalOneByte(isolate, one_byte_resource_)
        .ToLocalChecked();
  } else {
    return String::NewExternalTwoByte(isolate, two_byte_resource_)
        .ToLocalChecked();
  }
}",67,,611,2,,void
302975,BLOCK,-1,,"{
    return String::NewExternalOneByte(isolate, one_byte_resource_)
        .ToLocalChecked();
  }",22,,612,2,,void
302987,BLOCK,-1,,"{
    return String::NewExternalTwoByte(isolate, two_byte_resource_)
        .ToLocalChecked();
  }",10,,615,1,,void
303040,BLOCK,-1,,<empty>,1,,1,1,,ANY
303055,BLOCK,-1,,<empty>,1,,1,1,,ANY
303072,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  if (env->options()->pending_deprecation && env->EmitErrNameWarning()) {
    if (ProcessEmitDeprecationWarning(
        env,
        ""Directly calling process.binding('uv').errname(<val>) is being""
        "" deprecated. ""
        ""Please make sure to use util.getSystemErrorName() instead."",
        ""DEP0119"").IsNothing())
    return;
  }
  int err;
  if (!args[0]->Int32Value(env->context()).To(&err)) return;
  CHECK_LT(err, 0);
  char name[50];
  uv_err_name_r(err, name, sizeof(name));
  args.GetReturnValue().Set(OneByteString(env->isolate(), name));
}",55,,62,2,,void
303093,BLOCK,-1,,"{
    if (ProcessEmitDeprecationWarning(
        env,
        ""Directly calling process.binding('uv').errname(<val>) is being""
        "" deprecated. ""
        ""Please make sure to use util.getSystemErrorName() instead."",
        ""DEP0119"").IsNothing())
    return;
  }",73,,64,2,,void
303102,BLOCK,-1,,<empty>,5,,71,2,,void
303122,BLOCK,-1,,<empty>,54,,74,2,,void
303150,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();

  // This can't return a SafeMap, because the uv binding can be referenced
  // by user code by using `process.binding('uv').getErrorMap()`:
  Local<Map> err_map = Map::New(isolate);

  size_t errors_len = arraysize(per_process::uv_errors_map);
  for (size_t i = 0; i < errors_len; ++i) {
    const auto& error = per_process::uv_errors_map[i];
    Local<Value> arr[] = {OneByteString(isolate, error.name),
                          OneByteString(isolate, error.message)};
    if (err_map
            ->Set(context,
                  Integer::New(isolate, error.value),
                  Array::New(isolate, arr, arraysize(arr)))
            .IsEmpty()) {
      return;
    }
  }

  args.GetReturnValue().Set(err_map);
}",57,,81,2,,void
303195,BLOCK,-1,,<empty>,3,,91,1,,void
303205,BLOCK,4,,"{
    const auto& error = per_process::uv_errors_map[i];
    Local<Value> arr[] = {OneByteString(isolate, error.name),
                          OneByteString(isolate, error.message)};
    if (err_map
            ->Set(context,
                  Integer::New(isolate, error.value),
                  Array::New(isolate, arr, arraysize(arr)))
            .IsEmpty()) {
      return;
    }
  }",43,,91,4,,void
303253,BLOCK,-1,,"{
      return;
    }",25,,99,2,,void
303270,BLOCK,-1,,"{
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();
  SetConstructorFunction(
      context, target, ""errname"", NewFunctionTemplate(isolate, ErrName));

  // TODO(joyeecheung): This should be deprecated in user land in favor of
  // `util.getSystemErrorName(err)`.
  PropertyAttribute attributes =
      static_cast<PropertyAttribute>(ReadOnly | DontDelete);
  size_t errors_len = arraysize(per_process::uv_errors_map);
  const std::string prefix = ""UV_"";
  for (size_t i = 0; i < errors_len; ++i) {
    const auto& error = per_process::uv_errors_map[i];
    const std::string prefixed_name = prefix + error.name;
    Local<String> name = OneByteString(isolate, prefixed_name.c_str());
    Local<Integer> value = Integer::New(isolate, error.value);
    target->DefineOwnProperty(context, name, value, attributes).Check();
  }

  SetMethod(context, target, ""getErrorMap"", GetErrMap);
}",29,,110,5,,void
303313,BLOCK,-1,,<empty>,3,,122,1,,void
303323,BLOCK,4,,"{
    const auto& error = per_process::uv_errors_map[i];
    const std::string prefixed_name = prefix + error.name;
    Local<String> name = OneByteString(isolate, prefixed_name.c_str());
    Local<Integer> value = Integer::New(isolate, error.value);
    target->DefineOwnProperty(context, name, value, attributes).Check();
  }",43,,122,4,,void
303386,BLOCK,-1,,"{
  registry->Register(ErrName);
  registry->Register(GetErrMap);
}",70,,133,2,,void
307193,BLOCK,-1,,<empty>,,,,1,,ANY
307608,BLOCK,1,,<empty>,,,,1,,ANY
307613,BLOCK,1,,<empty>,,,,1,,ANY
307621,BLOCK,1,,<empty>,,,,1,,ANY
307626,BLOCK,1,,<empty>,,,,1,,ANY
307631,BLOCK,1,,<empty>,,,,1,,ANY
307635,BLOCK,1,,<empty>,,,,1,,ANY
307640,BLOCK,1,,<empty>,,,,1,,ANY
307643,BLOCK,1,,<empty>,,,,1,,ANY
307649,BLOCK,1,,<empty>,,,,1,,ANY
307653,BLOCK,1,,<empty>,,,,1,,ANY
307657,BLOCK,1,,<empty>,,,,1,,ANY
307661,BLOCK,1,,<empty>,,,,1,,ANY
307665,BLOCK,1,,<empty>,,,,1,,ANY
307670,BLOCK,1,,<empty>,,,,1,,ANY
307674,BLOCK,1,,<empty>,,,,1,,ANY
307679,BLOCK,1,,<empty>,,,,1,,ANY
307683,BLOCK,1,,<empty>,,,,1,,ANY
307687,BLOCK,1,,<empty>,,,,1,,ANY
307691,BLOCK,1,,<empty>,,,,1,,ANY
307695,BLOCK,1,,<empty>,,,,1,,ANY
307699,BLOCK,1,,<empty>,,,,1,,ANY
307703,BLOCK,1,,<empty>,,,,1,,ANY
307708,BLOCK,1,,<empty>,,,,1,,ANY
307713,BLOCK,1,,<empty>,,,,1,,ANY
307717,BLOCK,1,,<empty>,,,,1,,ANY
307721,BLOCK,1,,<empty>,,,,1,,ANY
307726,BLOCK,1,,<empty>,,,,1,,ANY
307730,BLOCK,1,,<empty>,,,,1,,ANY
307735,BLOCK,1,,<empty>,,,,1,,ANY
307740,BLOCK,1,,<empty>,,,,1,,ANY
307747,BLOCK,1,,<empty>,,,,1,,ANY
307752,BLOCK,1,,<empty>,,,,1,,ANY
307758,BLOCK,1,,<empty>,,,,1,,ANY
307762,BLOCK,1,,<empty>,,,,1,,ANY
307766,BLOCK,1,,<empty>,,,,1,,ANY
307769,BLOCK,1,,<empty>,,,,1,,ANY
307773,BLOCK,1,,<empty>,,,,1,,ANY
307779,BLOCK,1,,<empty>,,,,1,,ANY
307784,BLOCK,1,,<empty>,,,,1,,ANY
307789,BLOCK,1,,<empty>,,,,1,,ANY
307793,BLOCK,1,,<empty>,,,,1,,ANY
307797,BLOCK,1,,<empty>,,,,1,,ANY
307801,BLOCK,1,,<empty>,,,,1,,ANY
307806,BLOCK,1,,<empty>,,,,1,,ANY
307810,BLOCK,1,,<empty>,,,,1,,ANY
307815,BLOCK,1,,<empty>,,,,1,,ANY
307819,BLOCK,1,,<empty>,,,,1,,ANY
307823,BLOCK,1,,<empty>,,,,1,,ANY
307827,BLOCK,1,,<empty>,,,,1,,ANY
307831,BLOCK,1,,<empty>,,,,1,,ANY
307834,BLOCK,1,,<empty>,,,,1,,ANY
307838,BLOCK,1,,<empty>,,,,1,,ANY
307842,BLOCK,1,,<empty>,,,,1,,ANY
307846,BLOCK,1,,<empty>,,,,1,,ANY
307854,BLOCK,1,,<empty>,,,,1,,ANY
307858,BLOCK,1,,<empty>,,,,1,,ANY
307863,BLOCK,1,,<empty>,,,,1,,ANY
307867,BLOCK,1,,<empty>,,,,1,,ANY
307871,BLOCK,1,,<empty>,,,,1,,ANY
307874,BLOCK,1,,<empty>,,,,1,,ANY
307878,BLOCK,1,,<empty>,,,,1,,ANY
307884,BLOCK,1,,<empty>,,,,1,,ANY
307888,BLOCK,1,,<empty>,,,,1,,ANY
307892,BLOCK,1,,<empty>,,,,1,,ANY
307896,BLOCK,1,,<empty>,,,,1,,ANY
307900,BLOCK,1,,<empty>,,,,1,,ANY
307904,BLOCK,1,,<empty>,,,,1,,ANY
307908,BLOCK,1,,<empty>,,,,1,,ANY
307916,BLOCK,1,,<empty>,,,,1,,ANY
307922,BLOCK,1,,<empty>,,,,1,,ANY
307926,BLOCK,1,,<empty>,,,,1,,ANY
307929,BLOCK,1,,<empty>,,,,1,,ANY
307934,BLOCK,1,,<empty>,,,,1,,ANY
307938,BLOCK,1,,<empty>,,,,1,,ANY
307942,BLOCK,1,,<empty>,,,,1,,ANY
307946,BLOCK,1,,<empty>,,,,1,,ANY
307950,BLOCK,1,,<empty>,,,,1,,ANY
307960,BLOCK,1,,<empty>,,,,1,,ANY
307965,BLOCK,1,,<empty>,,,,1,,ANY
307969,BLOCK,1,,<empty>,,,,1,,ANY
307974,BLOCK,1,,<empty>,,,,1,,ANY
307979,BLOCK,1,,<empty>,,,,1,,ANY
307984,BLOCK,1,,<empty>,,,,1,,ANY
307988,BLOCK,1,,<empty>,,,,1,,ANY
307993,BLOCK,1,,<empty>,,,,1,,ANY
308001,BLOCK,1,,<empty>,,,,1,,ANY
308011,BLOCK,1,,<empty>,,,,1,,ANY
308015,BLOCK,1,,<empty>,,,,1,,ANY
308020,BLOCK,1,,<empty>,,,,1,,ANY
308024,BLOCK,1,,<empty>,,,,1,,ANY
308028,BLOCK,1,,<empty>,,,,1,,ANY
308032,BLOCK,1,,<empty>,,,,1,,ANY
308035,BLOCK,1,,<empty>,,,,1,,ANY
308040,BLOCK,1,,<empty>,,,,1,,ANY
308044,BLOCK,1,,<empty>,,,,1,,ANY
308049,BLOCK,1,,<empty>,,,,1,,ANY
308053,BLOCK,1,,<empty>,,,,1,,ANY
308058,BLOCK,1,,<empty>,,,,1,,ANY
308062,BLOCK,1,,<empty>,,,,1,,ANY
308067,BLOCK,1,,<empty>,,,,1,,ANY
308071,BLOCK,1,,<empty>,,,,1,,ANY
308075,BLOCK,1,,<empty>,,,,1,,ANY
308079,BLOCK,1,,<empty>,,,,1,,ANY
308083,BLOCK,1,,<empty>,,,,1,,ANY
308088,BLOCK,1,,<empty>,,,,1,,ANY
308091,BLOCK,1,,<empty>,,,,1,,ANY
308095,BLOCK,1,,<empty>,,,,1,,ANY
308100,BLOCK,1,,<empty>,,,,1,,ANY
308104,BLOCK,1,,<empty>,,,,1,,ANY
308108,BLOCK,1,,<empty>,,,,1,,ANY
308114,BLOCK,1,,<empty>,,,,1,,ANY
308118,BLOCK,1,,<empty>,,,,1,,ANY
308123,BLOCK,1,,<empty>,,,,1,,ANY
308128,BLOCK,1,,<empty>,,,,1,,ANY
308132,BLOCK,1,,<empty>,,,,1,,ANY
308136,BLOCK,1,,<empty>,,,,1,,ANY
308142,BLOCK,1,,<empty>,,,,1,,ANY
308147,BLOCK,1,,<empty>,,,,1,,ANY
308151,BLOCK,1,,<empty>,,,,1,,ANY
308156,BLOCK,1,,<empty>,,,,1,,ANY
308161,BLOCK,1,,<empty>,,,,1,,ANY
308165,BLOCK,1,,<empty>,,,,1,,ANY
308172,BLOCK,1,,<empty>,,,,1,,ANY
308176,BLOCK,1,,<empty>,,,,1,,ANY
308180,BLOCK,1,,<empty>,,,,1,,ANY
308184,BLOCK,1,,<empty>,,,,1,,ANY
308189,BLOCK,1,,<empty>,,,,1,,ANY
308197,BLOCK,1,,<empty>,,,,1,,ANY
308201,BLOCK,1,,<empty>,,,,1,,ANY
308206,BLOCK,1,,<empty>,,,,1,,ANY
308210,BLOCK,1,,<empty>,,,,1,,ANY
308214,BLOCK,1,,<empty>,,,,1,,ANY
308219,BLOCK,1,,<empty>,,,,1,,ANY
308223,BLOCK,1,,<empty>,,,,1,,ANY
308228,BLOCK,1,,<empty>,,,,1,,ANY
308235,BLOCK,1,,<empty>,,,,1,,ANY
308239,BLOCK,1,,<empty>,,,,1,,ANY
308246,BLOCK,1,,<empty>,,,,1,,ANY
308251,BLOCK,1,,<empty>,,,,1,,ANY
308254,BLOCK,1,,<empty>,,,,1,,ANY
308258,BLOCK,1,,<empty>,,,,1,,ANY
308261,BLOCK,1,,<empty>,,,,1,,ANY
308268,BLOCK,1,,<empty>,,,,1,,ANY
308272,BLOCK,1,,<empty>,,,,1,,ANY
308275,BLOCK,1,,<empty>,,,,1,,ANY
308279,BLOCK,1,,<empty>,,,,1,,ANY
308283,BLOCK,1,,<empty>,,,,1,,ANY
308289,BLOCK,1,,<empty>,,,,1,,ANY
308294,BLOCK,1,,<empty>,,,,1,,ANY
308299,BLOCK,1,,<empty>,,,,1,,ANY
308303,BLOCK,1,,<empty>,,,,1,,ANY
308307,BLOCK,1,,<empty>,,,,1,,ANY
308313,BLOCK,1,,<empty>,,,,1,,ANY
308318,BLOCK,1,,<empty>,,,,1,,ANY
308322,BLOCK,1,,<empty>,,,,1,,ANY
308325,BLOCK,1,,<empty>,,,,1,,ANY
308330,BLOCK,1,,<empty>,,,,1,,ANY
308336,BLOCK,1,,<empty>,,,,1,,ANY
308341,BLOCK,1,,<empty>,,,,1,,ANY
308345,BLOCK,1,,<empty>,,,,1,,ANY
308349,BLOCK,1,,<empty>,,,,1,,ANY
308354,BLOCK,1,,<empty>,,,,1,,ANY
308359,BLOCK,1,,<empty>,,,,1,,ANY
308368,BLOCK,1,,<empty>,,,,1,,ANY
308375,BLOCK,1,,<empty>,,,,1,,ANY
308379,BLOCK,1,,<empty>,,,,1,,ANY
308388,BLOCK,1,,<empty>,,,,1,,ANY
308393,BLOCK,1,,<empty>,,,,1,,ANY
308397,BLOCK,1,,<empty>,,,,1,,ANY
308402,BLOCK,1,,<empty>,,,,1,,ANY
308407,BLOCK,1,,<empty>,,,,1,,ANY
308411,BLOCK,1,,<empty>,,,,1,,ANY
308415,BLOCK,1,,<empty>,,,,1,,ANY
308419,BLOCK,1,,<empty>,,,,1,,ANY
308423,BLOCK,1,,<empty>,,,,1,,ANY
308427,BLOCK,1,,<empty>,,,,1,,ANY
308431,BLOCK,1,,<empty>,,,,1,,ANY
308436,BLOCK,1,,<empty>,,,,1,,ANY
308441,BLOCK,1,,<empty>,,,,1,,ANY
308445,BLOCK,1,,<empty>,,,,1,,ANY
308449,BLOCK,1,,<empty>,,,,1,,ANY
308453,BLOCK,1,,<empty>,,,,1,,ANY
308457,BLOCK,1,,<empty>,,,,1,,ANY
308461,BLOCK,1,,<empty>,,,,1,,ANY
308465,BLOCK,1,,<empty>,,,,1,,ANY
308469,BLOCK,1,,<empty>,,,,1,,ANY
308474,BLOCK,1,,<empty>,,,,1,,ANY
308479,BLOCK,1,,<empty>,,,,1,,ANY
308483,BLOCK,1,,<empty>,,,,1,,ANY
308489,BLOCK,1,,<empty>,,,,1,,ANY
308496,BLOCK,1,,<empty>,,,,1,,ANY
308501,BLOCK,1,,<empty>,,,,1,,ANY
308507,BLOCK,1,,<empty>,,,,1,,ANY
308513,BLOCK,1,,<empty>,,,,1,,ANY
308517,BLOCK,1,,<empty>,,,,1,,ANY
308522,BLOCK,1,,<empty>,,,,1,,ANY
308527,BLOCK,1,,<empty>,,,,1,,ANY
308532,BLOCK,1,,<empty>,,,,1,,ANY
308537,BLOCK,1,,<empty>,,,,1,,ANY
308543,BLOCK,1,,<empty>,,,,1,,ANY
308550,BLOCK,1,,<empty>,,,,1,,ANY
308556,BLOCK,1,,<empty>,,,,1,,ANY
308560,BLOCK,1,,<empty>,,,,1,,ANY
308565,BLOCK,1,,<empty>,,,,1,,ANY
308571,BLOCK,1,,<empty>,,,,1,,ANY
308577,BLOCK,1,,<empty>,,,,1,,ANY
308582,BLOCK,1,,<empty>,,,,1,,ANY
308586,BLOCK,1,,<empty>,,,,1,,ANY
308590,BLOCK,1,,<empty>,,,,1,,ANY
308594,BLOCK,1,,<empty>,,,,1,,ANY
308597,BLOCK,1,,<empty>,,,,1,,ANY
308603,BLOCK,1,,<empty>,,,,1,,ANY
308606,BLOCK,1,,<empty>,,,,1,,ANY
308610,BLOCK,1,,<empty>,,,,1,,ANY
308616,BLOCK,1,,<empty>,,,,1,,ANY
308620,BLOCK,1,,<empty>,,,,1,,ANY
308626,BLOCK,1,,<empty>,,,,1,,ANY
308631,BLOCK,1,,<empty>,,,,1,,ANY
308636,BLOCK,1,,<empty>,,,,1,,ANY
308641,BLOCK,1,,<empty>,,,,1,,ANY
308646,BLOCK,1,,<empty>,,,,1,,ANY
308651,BLOCK,1,,<empty>,,,,1,,ANY
308656,BLOCK,1,,<empty>,,,,1,,ANY
308661,BLOCK,1,,<empty>,,,,1,,ANY
308665,BLOCK,1,,<empty>,,,,1,,ANY
308669,BLOCK,1,,<empty>,,,,1,,ANY
308674,BLOCK,1,,<empty>,,,,1,,ANY
308679,BLOCK,1,,<empty>,,,,1,,ANY
308684,BLOCK,1,,<empty>,,,,1,,ANY
308689,BLOCK,1,,<empty>,,,,1,,ANY
308694,BLOCK,1,,<empty>,,,,1,,ANY
308698,BLOCK,1,,<empty>,,,,1,,ANY
308704,BLOCK,1,,<empty>,,,,1,,ANY
308708,BLOCK,1,,<empty>,,,,1,,ANY
308714,BLOCK,1,,<empty>,,,,1,,ANY
308719,BLOCK,1,,<empty>,,,,1,,ANY
308723,BLOCK,1,,<empty>,,,,1,,ANY
308729,BLOCK,1,,<empty>,,,,1,,ANY
308733,BLOCK,1,,<empty>,,,,1,,ANY
308737,BLOCK,1,,<empty>,,,,1,,ANY
308743,BLOCK,1,,<empty>,,,,1,,ANY
308747,BLOCK,1,,<empty>,,,,1,,ANY
308752,BLOCK,1,,<empty>,,,,1,,ANY
308756,BLOCK,1,,<empty>,,,,1,,ANY
308761,BLOCK,1,,<empty>,,,,1,,ANY
308765,BLOCK,1,,<empty>,,,,1,,ANY
308769,BLOCK,1,,<empty>,,,,1,,ANY
308772,BLOCK,1,,<empty>,,,,1,,ANY
308776,BLOCK,1,,<empty>,,,,1,,ANY
308780,BLOCK,1,,<empty>,,,,1,,ANY
308787,BLOCK,1,,<empty>,,,,1,,ANY
308791,BLOCK,1,,<empty>,,,,1,,ANY
308795,BLOCK,1,,<empty>,,,,1,,ANY
308799,BLOCK,1,,<empty>,,,,1,,ANY
308804,BLOCK,1,,<empty>,,,,1,,ANY
308809,BLOCK,1,,<empty>,,,,1,,ANY
308813,BLOCK,1,,<empty>,,,,1,,ANY
308818,BLOCK,1,,<empty>,,,,1,,ANY
308822,BLOCK,1,,<empty>,,,,1,,ANY
308827,BLOCK,1,,<empty>,,,,1,,ANY
308831,BLOCK,1,,<empty>,,,,1,,ANY
308837,BLOCK,1,,<empty>,,,,1,,ANY
308842,BLOCK,1,,<empty>,,,,1,,ANY
308848,BLOCK,1,,<empty>,,,,1,,ANY
308851,BLOCK,1,,<empty>,,,,1,,ANY
308855,BLOCK,1,,<empty>,,,,1,,ANY
308859,BLOCK,1,,<empty>,,,,1,,ANY
308864,BLOCK,1,,<empty>,,,,1,,ANY
308871,BLOCK,1,,<empty>,,,,1,,ANY
308875,BLOCK,1,,<empty>,,,,1,,ANY
308880,BLOCK,1,,<empty>,,,,1,,ANY
308884,BLOCK,1,,<empty>,,,,1,,ANY
308887,BLOCK,1,,<empty>,,,,1,,ANY
308891,BLOCK,1,,<empty>,,,,1,,ANY
308895,BLOCK,1,,<empty>,,,,1,,ANY
308900,BLOCK,1,,<empty>,,,,1,,ANY
308906,BLOCK,1,,<empty>,,,,1,,ANY
308912,BLOCK,1,,<empty>,,,,1,,ANY
308915,BLOCK,1,,<empty>,,,,1,,ANY
308921,BLOCK,1,,<empty>,,,,1,,ANY
308927,BLOCK,1,,<empty>,,,,1,,ANY
308932,BLOCK,1,,<empty>,,,,1,,ANY
308937,BLOCK,1,,<empty>,,,,1,,ANY
308942,BLOCK,1,,<empty>,,,,1,,ANY
308949,BLOCK,1,,<empty>,,,,1,,ANY
308954,BLOCK,1,,<empty>,,,,1,,ANY
308958,BLOCK,1,,<empty>,,,,1,,ANY
308962,BLOCK,1,,<empty>,,,,1,,ANY
308968,BLOCK,1,,<empty>,,,,1,,ANY
308972,BLOCK,1,,<empty>,,,,1,,ANY
308977,BLOCK,1,,<empty>,,,,1,,ANY
308984,BLOCK,1,,<empty>,,,,1,,ANY
308988,BLOCK,1,,<empty>,,,,1,,ANY
308992,BLOCK,1,,<empty>,,,,1,,ANY
308996,BLOCK,1,,<empty>,,,,1,,ANY
309000,BLOCK,1,,<empty>,,,,1,,ANY
309004,BLOCK,1,,<empty>,,,,1,,ANY
309008,BLOCK,1,,<empty>,,,,1,,ANY
309013,BLOCK,1,,<empty>,,,,1,,ANY
309016,BLOCK,1,,<empty>,,,,1,,ANY
309020,BLOCK,1,,<empty>,,,,1,,ANY
309024,BLOCK,1,,<empty>,,,,1,,ANY
309028,BLOCK,1,,<empty>,,,,1,,ANY
309032,BLOCK,1,,<empty>,,,,1,,ANY
309035,BLOCK,1,,<empty>,,,,1,,ANY
309038,BLOCK,1,,<empty>,,,,1,,ANY
309043,BLOCK,1,,<empty>,,,,1,,ANY
309048,BLOCK,1,,<empty>,,,,1,,ANY
309053,BLOCK,1,,<empty>,,,,1,,ANY
309058,BLOCK,1,,<empty>,,,,1,,ANY
309063,BLOCK,1,,<empty>,,,,1,,ANY
309068,BLOCK,1,,<empty>,,,,1,,ANY
309072,BLOCK,1,,<empty>,,,,1,,ANY
309079,BLOCK,1,,<empty>,,,,1,,ANY
309084,BLOCK,1,,<empty>,,,,1,,ANY
309088,BLOCK,1,,<empty>,,,,1,,ANY
309092,BLOCK,1,,<empty>,,,,1,,ANY
309098,BLOCK,1,,<empty>,,,,1,,ANY
309102,BLOCK,1,,<empty>,,,,1,,ANY
309106,BLOCK,1,,<empty>,,,,1,,ANY
309110,BLOCK,1,,<empty>,,,,1,,ANY
309114,BLOCK,1,,<empty>,,,,1,,ANY
309119,BLOCK,1,,<empty>,,,,1,,ANY
309124,BLOCK,1,,<empty>,,,,1,,ANY
309128,BLOCK,1,,<empty>,,,,1,,ANY
309136,BLOCK,1,,<empty>,,,,1,,ANY
309143,BLOCK,1,,<empty>,,,,1,,ANY
309147,BLOCK,1,,<empty>,,,,1,,ANY
309153,BLOCK,1,,<empty>,,,,1,,ANY
309157,BLOCK,1,,<empty>,,,,1,,ANY
309162,BLOCK,1,,<empty>,,,,1,,ANY
309166,BLOCK,1,,<empty>,,,,1,,ANY
309170,BLOCK,1,,<empty>,,,,1,,ANY
309175,BLOCK,1,,<empty>,,,,1,,ANY
309180,BLOCK,1,,<empty>,,,,1,,ANY
309186,BLOCK,1,,<empty>,,,,1,,ANY
309190,BLOCK,1,,<empty>,,,,1,,ANY
309194,BLOCK,1,,<empty>,,,,1,,ANY
309200,BLOCK,1,,<empty>,,,,1,,ANY
309206,BLOCK,1,,<empty>,,,,1,,ANY
309210,BLOCK,1,,<empty>,,,,1,,ANY
309214,BLOCK,1,,<empty>,,,,1,,ANY
309218,BLOCK,1,,<empty>,,,,1,,ANY
309223,BLOCK,1,,<empty>,,,,1,,ANY
309227,BLOCK,1,,<empty>,,,,1,,ANY
309231,BLOCK,1,,<empty>,,,,1,,ANY
309240,BLOCK,1,,<empty>,,,,1,,ANY
309246,BLOCK,1,,<empty>,,,,1,,ANY
309249,BLOCK,1,,<empty>,,,,1,,ANY
309253,BLOCK,1,,<empty>,,,,1,,ANY
309259,BLOCK,1,,<empty>,,,,1,,ANY
309263,BLOCK,1,,<empty>,,,,1,,ANY
309267,BLOCK,1,,<empty>,,,,1,,ANY
309272,BLOCK,1,,<empty>,,,,1,,ANY
309278,BLOCK,1,,<empty>,,,,1,,ANY
309285,BLOCK,1,,<empty>,,,,1,,ANY
309289,BLOCK,1,,<empty>,,,,1,,ANY
309292,BLOCK,1,,<empty>,,,,1,,ANY
309296,BLOCK,1,,<empty>,,,,1,,ANY
309300,BLOCK,1,,<empty>,,,,1,,ANY
309304,BLOCK,1,,<empty>,,,,1,,ANY
309308,BLOCK,1,,<empty>,,,,1,,ANY
309311,BLOCK,1,,<empty>,,,,1,,ANY
309315,BLOCK,1,,<empty>,,,,1,,ANY
309319,BLOCK,1,,<empty>,,,,1,,ANY
309323,BLOCK,1,,<empty>,,,,1,,ANY
309327,BLOCK,1,,<empty>,,,,1,,ANY
309331,BLOCK,1,,<empty>,,,,1,,ANY
309339,BLOCK,1,,<empty>,,,,1,,ANY
309343,BLOCK,1,,<empty>,,,,1,,ANY
309347,BLOCK,1,,<empty>,,,,1,,ANY
309353,BLOCK,1,,<empty>,,,,1,,ANY
309357,BLOCK,1,,<empty>,,,,1,,ANY
309361,BLOCK,1,,<empty>,,,,1,,ANY
309365,BLOCK,1,,<empty>,,,,1,,ANY
309369,BLOCK,1,,<empty>,,,,1,,ANY
309373,BLOCK,1,,<empty>,,,,1,,ANY
309377,BLOCK,1,,<empty>,,,,1,,ANY
309381,BLOCK,1,,<empty>,,,,1,,ANY
309385,BLOCK,1,,<empty>,,,,1,,ANY
309391,BLOCK,1,,<empty>,,,,1,,ANY
309395,BLOCK,1,,<empty>,,,,1,,ANY
309398,BLOCK,1,,<empty>,,,,1,,ANY
309403,BLOCK,1,,<empty>,,,,1,,ANY
309408,BLOCK,1,,<empty>,,,,1,,ANY
309413,BLOCK,1,,<empty>,,,,1,,ANY
309418,BLOCK,1,,<empty>,,,,1,,ANY
309423,BLOCK,1,,<empty>,,,,1,,ANY
309427,BLOCK,1,,<empty>,,,,1,,ANY
309430,BLOCK,1,,<empty>,,,,1,,ANY
309435,BLOCK,1,,<empty>,,,,1,,ANY
309439,BLOCK,1,,<empty>,,,,1,,ANY
309444,BLOCK,1,,<empty>,,,,1,,ANY
309449,BLOCK,1,,<empty>,,,,1,,ANY
309456,BLOCK,1,,<empty>,,,,1,,ANY
309461,BLOCK,1,,<empty>,,,,1,,ANY
309468,BLOCK,1,,<empty>,,,,1,,ANY
309473,BLOCK,1,,<empty>,,,,1,,ANY
309477,BLOCK,1,,<empty>,,,,1,,ANY
309481,BLOCK,1,,<empty>,,,,1,,ANY
309485,BLOCK,1,,<empty>,,,,1,,ANY
309489,BLOCK,1,,<empty>,,,,1,,ANY
309493,BLOCK,1,,<empty>,,,,1,,ANY
309497,BLOCK,1,,<empty>,,,,1,,ANY
309501,BLOCK,1,,<empty>,,,,1,,ANY
309504,BLOCK,1,,<empty>,,,,1,,ANY
309510,BLOCK,1,,<empty>,,,,1,,ANY
309516,BLOCK,1,,<empty>,,,,1,,ANY
309522,BLOCK,1,,<empty>,,,,1,,ANY
309528,BLOCK,1,,<empty>,,,,1,,ANY
309534,BLOCK,1,,<empty>,,,,1,,ANY
309540,BLOCK,1,,<empty>,,,,1,,ANY
309546,BLOCK,1,,<empty>,,,,1,,ANY
309552,BLOCK,1,,<empty>,,,,1,,ANY
309558,BLOCK,1,,<empty>,,,,1,,ANY
309564,BLOCK,1,,<empty>,,,,1,,ANY
309570,BLOCK,1,,<empty>,,,,1,,ANY
309576,BLOCK,1,,<empty>,,,,1,,ANY
309582,BLOCK,1,,<empty>,,,,1,,ANY
309590,BLOCK,1,,<empty>,,,,1,,ANY
309598,BLOCK,1,,<empty>,,,,1,,ANY
309603,BLOCK,1,,<empty>,,,,1,,ANY
309608,BLOCK,1,,<empty>,,,,1,,ANY
309613,BLOCK,1,,<empty>,,,,1,,ANY
309618,BLOCK,1,,<empty>,,,,1,,ANY
309623,BLOCK,1,,<empty>,,,,1,,ANY
309628,BLOCK,1,,<empty>,,,,1,,ANY
309633,BLOCK,1,,<empty>,,,,1,,ANY
309638,BLOCK,1,,<empty>,,,,1,,ANY
309642,BLOCK,1,,<empty>,,,,1,,ANY
309646,BLOCK,1,,<empty>,,,,1,,ANY
309651,BLOCK,1,,<empty>,,,,1,,ANY
309655,BLOCK,1,,<empty>,,,,1,,ANY
309658,BLOCK,1,,<empty>,,,,1,,ANY
309662,BLOCK,1,,<empty>,,,,1,,ANY
309667,BLOCK,1,,<empty>,,,,1,,ANY
309670,BLOCK,1,,<empty>,,,,1,,ANY
309673,BLOCK,1,,<empty>,,,,1,,ANY
309678,BLOCK,1,,<empty>,,,,1,,ANY
309682,BLOCK,1,,<empty>,,,,1,,ANY
309686,BLOCK,1,,<empty>,,,,1,,ANY
309690,BLOCK,1,,<empty>,,,,1,,ANY
309694,BLOCK,1,,<empty>,,,,1,,ANY
309698,BLOCK,1,,<empty>,,,,1,,ANY
309701,BLOCK,1,,<empty>,,,,1,,ANY
309706,BLOCK,1,,<empty>,,,,1,,ANY
309710,BLOCK,1,,<empty>,,,,1,,ANY
309715,BLOCK,1,,<empty>,,,,1,,ANY
309720,BLOCK,1,,<empty>,,,,1,,ANY
309723,BLOCK,1,,<empty>,,,,1,,ANY
309729,BLOCK,1,,<empty>,,,,1,,ANY
309733,BLOCK,1,,<empty>,,,,1,,ANY
309737,BLOCK,1,,<empty>,,,,1,,ANY
309741,BLOCK,1,,<empty>,,,,1,,ANY
309745,BLOCK,1,,<empty>,,,,1,,ANY
309750,BLOCK,1,,<empty>,,,,1,,ANY
309754,BLOCK,1,,<empty>,,,,1,,ANY
309758,BLOCK,1,,<empty>,,,,1,,ANY
309763,BLOCK,1,,<empty>,,,,1,,ANY
309767,BLOCK,1,,<empty>,,,,1,,ANY
309770,BLOCK,1,,<empty>,,,,1,,ANY
309773,BLOCK,1,,<empty>,,,,1,,ANY
309777,BLOCK,1,,<empty>,,,,1,,ANY
309780,BLOCK,1,,<empty>,,,,1,,ANY
309784,BLOCK,1,,<empty>,,,,1,,ANY
309791,BLOCK,1,,<empty>,,,,1,,ANY
309795,BLOCK,1,,<empty>,,,,1,,ANY
309799,BLOCK,1,,<empty>,,,,1,,ANY
309804,BLOCK,1,,<empty>,,,,1,,ANY
309809,BLOCK,1,,<empty>,,,,1,,ANY
309813,BLOCK,1,,<empty>,,,,1,,ANY
309816,BLOCK,1,,<empty>,,,,1,,ANY
309822,BLOCK,1,,<empty>,,,,1,,ANY
309826,BLOCK,1,,<empty>,,,,1,,ANY
309830,BLOCK,1,,<empty>,,,,1,,ANY
309834,BLOCK,1,,<empty>,,,,1,,ANY
309838,BLOCK,1,,<empty>,,,,1,,ANY
309844,BLOCK,1,,<empty>,,,,1,,ANY
309850,BLOCK,1,,<empty>,,,,1,,ANY
309856,BLOCK,1,,<empty>,,,,1,,ANY
309862,BLOCK,1,,<empty>,,,,1,,ANY
309865,BLOCK,1,,<empty>,,,,1,,ANY
309870,BLOCK,1,,<empty>,,,,1,,ANY
309874,BLOCK,1,,<empty>,,,,1,,ANY
309880,BLOCK,1,,<empty>,,,,1,,ANY
309887,BLOCK,1,,<empty>,,,,1,,ANY
309891,BLOCK,1,,<empty>,,,,1,,ANY
309897,BLOCK,1,,<empty>,,,,1,,ANY
309901,BLOCK,1,,<empty>,,,,1,,ANY
309909,BLOCK,1,,<empty>,,,,1,,ANY
309917,BLOCK,1,,<empty>,,,,1,,ANY
309923,BLOCK,1,,<empty>,,,,1,,ANY
309932,BLOCK,1,,<empty>,,,,1,,ANY
309936,BLOCK,1,,<empty>,,,,1,,ANY
309941,BLOCK,1,,<empty>,,,,1,,ANY
309947,BLOCK,1,,<empty>,,,,1,,ANY
309951,BLOCK,1,,<empty>,,,,1,,ANY
309955,BLOCK,1,,<empty>,,,,1,,ANY
309959,BLOCK,1,,<empty>,,,,1,,ANY
309963,BLOCK,1,,<empty>,,,,1,,ANY
309969,BLOCK,1,,<empty>,,,,1,,ANY
309973,BLOCK,1,,<empty>,,,,1,,ANY
309977,BLOCK,1,,<empty>,,,,1,,ANY
309983,BLOCK,1,,<empty>,,,,1,,ANY
309987,BLOCK,1,,<empty>,,,,1,,ANY
309991,BLOCK,1,,<empty>,,,,1,,ANY
309997,BLOCK,1,,<empty>,,,,1,,ANY
310002,BLOCK,1,,<empty>,,,,1,,ANY
310006,BLOCK,1,,<empty>,,,,1,,ANY
310010,BLOCK,1,,<empty>,,,,1,,ANY
310014,BLOCK,1,,<empty>,,,,1,,ANY
310020,BLOCK,1,,<empty>,,,,1,,ANY
310024,BLOCK,1,,<empty>,,,,1,,ANY
310028,BLOCK,1,,<empty>,,,,1,,ANY
310032,BLOCK,1,,<empty>,,,,1,,ANY
310036,BLOCK,1,,<empty>,,,,1,,ANY
310040,BLOCK,1,,<empty>,,,,1,,ANY
310044,BLOCK,1,,<empty>,,,,1,,ANY
310048,BLOCK,1,,<empty>,,,,1,,ANY
310052,BLOCK,1,,<empty>,,,,1,,ANY
310060,BLOCK,1,,<empty>,,,,1,,ANY
310064,BLOCK,1,,<empty>,,,,1,,ANY
310069,BLOCK,1,,<empty>,,,,1,,ANY
310073,BLOCK,1,,<empty>,,,,1,,ANY
310077,BLOCK,1,,<empty>,,,,1,,ANY
310081,BLOCK,1,,<empty>,,,,1,,ANY
310085,BLOCK,1,,<empty>,,,,1,,ANY
310089,BLOCK,1,,<empty>,,,,1,,ANY
310093,BLOCK,1,,<empty>,,,,1,,ANY
310097,BLOCK,1,,<empty>,,,,1,,ANY
310101,BLOCK,1,,<empty>,,,,1,,ANY
310105,BLOCK,1,,<empty>,,,,1,,ANY
310109,BLOCK,1,,<empty>,,,,1,,ANY
310113,BLOCK,1,,<empty>,,,,1,,ANY
310117,BLOCK,1,,<empty>,,,,1,,ANY
310120,BLOCK,1,,<empty>,,,,1,,ANY
310126,BLOCK,1,,<empty>,,,,1,,ANY
310130,BLOCK,1,,<empty>,,,,1,,ANY
310134,BLOCK,1,,<empty>,,,,1,,ANY
310140,BLOCK,1,,<empty>,,,,1,,ANY
310146,BLOCK,1,,<empty>,,,,1,,ANY
310150,BLOCK,1,,<empty>,,,,1,,ANY
310155,BLOCK,1,,<empty>,,,,1,,ANY
310159,BLOCK,1,,<empty>,,,,1,,ANY
310165,BLOCK,1,,<empty>,,,,1,,ANY
310168,BLOCK,1,,<empty>,,,,1,,ANY
310173,BLOCK,1,,<empty>,,,,1,,ANY
310177,BLOCK,1,,<empty>,,,,1,,ANY
310184,BLOCK,1,,<empty>,,,,1,,ANY
310189,BLOCK,1,,<empty>,,,,1,,ANY
310193,BLOCK,1,,<empty>,,,,1,,ANY
310200,BLOCK,1,,<empty>,,,,1,,ANY
310203,BLOCK,1,,<empty>,,,,1,,ANY
310211,BLOCK,1,,<empty>,,,,1,,ANY
310215,BLOCK,1,,<empty>,,,,1,,ANY
310219,BLOCK,1,,<empty>,,,,1,,ANY
310223,BLOCK,1,,<empty>,,,,1,,ANY
310227,BLOCK,1,,<empty>,,,,1,,ANY
310231,BLOCK,1,,<empty>,,,,1,,ANY
310235,BLOCK,1,,<empty>,,,,1,,ANY
310242,BLOCK,1,,<empty>,,,,1,,ANY
310246,BLOCK,1,,<empty>,,,,1,,ANY
310253,BLOCK,1,,<empty>,,,,1,,ANY
310260,BLOCK,1,,<empty>,,,,1,,ANY
310264,BLOCK,1,,<empty>,,,,1,,ANY
310271,BLOCK,1,,<empty>,,,,1,,ANY
310274,BLOCK,1,,<empty>,,,,1,,ANY
310281,BLOCK,1,,<empty>,,,,1,,ANY
310288,BLOCK,1,,<empty>,,,,1,,ANY
310293,BLOCK,1,,<empty>,,,,1,,ANY
310299,BLOCK,1,,<empty>,,,,1,,ANY
310305,BLOCK,1,,<empty>,,,,1,,ANY
310315,BLOCK,1,,<empty>,,,,1,,ANY
310320,BLOCK,1,,<empty>,,,,1,,ANY
310324,BLOCK,1,,<empty>,,,,1,,ANY
310333,BLOCK,1,,<empty>,,,,1,,ANY
310337,BLOCK,1,,<empty>,,,,1,,ANY
310341,BLOCK,1,,<empty>,,,,1,,ANY
310345,BLOCK,1,,<empty>,,,,1,,ANY
310350,BLOCK,1,,<empty>,,,,1,,ANY
310354,BLOCK,1,,<empty>,,,,1,,ANY
310359,BLOCK,1,,<empty>,,,,1,,ANY
310364,BLOCK,1,,<empty>,,,,1,,ANY
310371,BLOCK,1,,<empty>,,,,1,,ANY
310375,BLOCK,1,,<empty>,,,,1,,ANY
310379,BLOCK,1,,<empty>,,,,1,,ANY
310383,BLOCK,1,,<empty>,,,,1,,ANY
310387,BLOCK,1,,<empty>,,,,1,,ANY
310397,BLOCK,1,,<empty>,,,,1,,ANY
310401,BLOCK,1,,<empty>,,,,1,,ANY
310406,BLOCK,1,,<empty>,,,,1,,ANY
310410,BLOCK,1,,<empty>,,,,1,,ANY
310415,BLOCK,1,,<empty>,,,,1,,ANY
310425,BLOCK,1,,<empty>,,,,1,,ANY
310429,BLOCK,1,,<empty>,,,,1,,ANY
310435,BLOCK,1,,<empty>,,,,1,,ANY
310441,BLOCK,1,,<empty>,,,,1,,ANY
310445,BLOCK,1,,<empty>,,,,1,,ANY
310449,BLOCK,1,,<empty>,,,,1,,ANY
310453,BLOCK,1,,<empty>,,,,1,,ANY
310458,BLOCK,1,,<empty>,,,,1,,ANY
310462,BLOCK,1,,<empty>,,,,1,,ANY
310467,BLOCK,1,,<empty>,,,,1,,ANY
310472,BLOCK,1,,<empty>,,,,1,,ANY
310477,BLOCK,1,,<empty>,,,,1,,ANY
310482,BLOCK,1,,<empty>,,,,1,,ANY
310487,BLOCK,1,,<empty>,,,,1,,ANY
310492,BLOCK,1,,<empty>,,,,1,,ANY
310497,BLOCK,1,,<empty>,,,,1,,ANY
310502,BLOCK,1,,<empty>,,,,1,,ANY
310508,BLOCK,1,,<empty>,,,,1,,ANY
310512,BLOCK,1,,<empty>,,,,1,,ANY
310516,BLOCK,1,,<empty>,,,,1,,ANY
310520,BLOCK,1,,<empty>,,,,1,,ANY
310527,BLOCK,1,,<empty>,,,,1,,ANY
310530,BLOCK,1,,<empty>,,,,1,,ANY
310533,BLOCK,1,,<empty>,,,,1,,ANY
310538,BLOCK,1,,<empty>,,,,1,,ANY
310543,BLOCK,1,,<empty>,,,,1,,ANY
310550,BLOCK,1,,<empty>,,,,1,,ANY
310557,BLOCK,1,,<empty>,,,,1,,ANY
310562,BLOCK,1,,<empty>,,,,1,,ANY
310566,BLOCK,1,,<empty>,,,,1,,ANY
310573,BLOCK,1,,<empty>,,,,1,,ANY
310576,BLOCK,1,,<empty>,,,,1,,ANY
310580,BLOCK,1,,<empty>,,,,1,,ANY
310585,BLOCK,1,,<empty>,,,,1,,ANY
310589,BLOCK,1,,<empty>,,,,1,,ANY
310596,BLOCK,1,,<empty>,,,,1,,ANY
310601,BLOCK,1,,<empty>,,,,1,,ANY
310605,BLOCK,1,,<empty>,,,,1,,ANY
310609,BLOCK,1,,<empty>,,,,1,,ANY
310613,BLOCK,1,,<empty>,,,,1,,ANY
310621,BLOCK,1,,<empty>,,,,1,,ANY
310625,BLOCK,1,,<empty>,,,,1,,ANY
310629,BLOCK,1,,<empty>,,,,1,,ANY
310633,BLOCK,1,,<empty>,,,,1,,ANY
310636,BLOCK,1,,<empty>,,,,1,,ANY
310640,BLOCK,1,,<empty>,,,,1,,ANY
310645,BLOCK,1,,<empty>,,,,1,,ANY
310654,BLOCK,1,,<empty>,,,,1,,ANY
310661,BLOCK,1,,<empty>,,,,1,,ANY
310666,BLOCK,1,,<empty>,,,,1,,ANY
310670,BLOCK,1,,<empty>,,,,1,,ANY
310674,BLOCK,1,,<empty>,,,,1,,ANY
310678,BLOCK,1,,<empty>,,,,1,,ANY
310682,BLOCK,1,,<empty>,,,,1,,ANY
310686,BLOCK,1,,<empty>,,,,1,,ANY
310694,BLOCK,1,,<empty>,,,,1,,ANY
310699,BLOCK,1,,<empty>,,,,1,,ANY
310704,BLOCK,1,,<empty>,,,,1,,ANY
310710,BLOCK,1,,<empty>,,,,1,,ANY
310715,BLOCK,1,,<empty>,,,,1,,ANY
310720,BLOCK,1,,<empty>,,,,1,,ANY
310724,BLOCK,1,,<empty>,,,,1,,ANY
310730,BLOCK,1,,<empty>,,,,1,,ANY
310735,BLOCK,1,,<empty>,,,,1,,ANY
310740,BLOCK,1,,<empty>,,,,1,,ANY
310745,BLOCK,1,,<empty>,,,,1,,ANY
310749,BLOCK,1,,<empty>,,,,1,,ANY
310754,BLOCK,1,,<empty>,,,,1,,ANY
310758,BLOCK,1,,<empty>,,,,1,,ANY
310762,BLOCK,1,,<empty>,,,,1,,ANY
310765,BLOCK,1,,<empty>,,,,1,,ANY
310771,BLOCK,1,,<empty>,,,,1,,ANY
310774,BLOCK,1,,<empty>,,,,1,,ANY
310778,BLOCK,1,,<empty>,,,,1,,ANY
310782,BLOCK,1,,<empty>,,,,1,,ANY
310787,BLOCK,1,,<empty>,,,,1,,ANY
310792,BLOCK,1,,<empty>,,,,1,,ANY
310796,BLOCK,1,,<empty>,,,,1,,ANY
310802,BLOCK,1,,<empty>,,,,1,,ANY
310807,BLOCK,1,,<empty>,,,,1,,ANY
310816,BLOCK,1,,<empty>,,,,1,,ANY
310820,BLOCK,1,,<empty>,,,,1,,ANY
310826,BLOCK,1,,<empty>,,,,1,,ANY
310830,BLOCK,1,,<empty>,,,,1,,ANY
310834,BLOCK,1,,<empty>,,,,1,,ANY
310838,BLOCK,1,,<empty>,,,,1,,ANY
310843,BLOCK,1,,<empty>,,,,1,,ANY
310847,BLOCK,1,,<empty>,,,,1,,ANY
310851,BLOCK,1,,<empty>,,,,1,,ANY
310855,BLOCK,1,,<empty>,,,,1,,ANY
310859,BLOCK,1,,<empty>,,,,1,,ANY
310863,BLOCK,1,,<empty>,,,,1,,ANY
310867,BLOCK,1,,<empty>,,,,1,,ANY
310871,BLOCK,1,,<empty>,,,,1,,ANY
310875,BLOCK,1,,<empty>,,,,1,,ANY
310879,BLOCK,1,,<empty>,,,,1,,ANY
310883,BLOCK,1,,<empty>,,,,1,,ANY
310889,BLOCK,1,,<empty>,,,,1,,ANY
310896,BLOCK,1,,<empty>,,,,1,,ANY
310902,BLOCK,1,,<empty>,,,,1,,ANY
310906,BLOCK,1,,<empty>,,,,1,,ANY
310914,BLOCK,1,,<empty>,,,,1,,ANY
310921,BLOCK,1,,<empty>,,,,1,,ANY
310925,BLOCK,1,,<empty>,,,,1,,ANY
310929,BLOCK,1,,<empty>,,,,1,,ANY
310933,BLOCK,1,,<empty>,,,,1,,ANY
310937,BLOCK,1,,<empty>,,,,1,,ANY
310943,BLOCK,1,,<empty>,,,,1,,ANY
310948,BLOCK,1,,<empty>,,,,1,,ANY
310953,BLOCK,1,,<empty>,,,,1,,ANY
310958,BLOCK,1,,<empty>,,,,1,,ANY
310963,BLOCK,1,,<empty>,,,,1,,ANY
310968,BLOCK,1,,<empty>,,,,1,,ANY
310973,BLOCK,1,,<empty>,,,,1,,ANY
310978,BLOCK,1,,<empty>,,,,1,,ANY
310983,BLOCK,1,,<empty>,,,,1,,ANY
310988,BLOCK,1,,<empty>,,,,1,,ANY
310993,BLOCK,1,,<empty>,,,,1,,ANY
310998,BLOCK,1,,<empty>,,,,1,,ANY
311004,BLOCK,1,,<empty>,,,,1,,ANY
311009,BLOCK,1,,<empty>,,,,1,,ANY
311012,BLOCK,1,,<empty>,,,,1,,ANY
311017,BLOCK,1,,<empty>,,,,1,,ANY
311022,BLOCK,1,,<empty>,,,,1,,ANY
311026,BLOCK,1,,<empty>,,,,1,,ANY
311030,BLOCK,1,,<empty>,,,,1,,ANY
311034,BLOCK,1,,<empty>,,,,1,,ANY
311038,BLOCK,1,,<empty>,,,,1,,ANY
311042,BLOCK,1,,<empty>,,,,1,,ANY
311047,BLOCK,1,,<empty>,,,,1,,ANY
311051,BLOCK,1,,<empty>,,,,1,,ANY
311055,BLOCK,1,,<empty>,,,,1,,ANY
311064,BLOCK,1,,<empty>,,,,1,,ANY
311070,BLOCK,1,,<empty>,,,,1,,ANY
311074,BLOCK,1,,<empty>,,,,1,,ANY
311079,BLOCK,1,,<empty>,,,,1,,ANY
311084,BLOCK,1,,<empty>,,,,1,,ANY
311090,BLOCK,1,,<empty>,,,,1,,ANY
311095,BLOCK,1,,<empty>,,,,1,,ANY
311098,BLOCK,1,,<empty>,,,,1,,ANY
311101,BLOCK,1,,<empty>,,,,1,,ANY
311105,BLOCK,1,,<empty>,,,,1,,ANY
311110,BLOCK,1,,<empty>,,,,1,,ANY
311116,BLOCK,1,,<empty>,,,,1,,ANY
311121,BLOCK,1,,<empty>,,,,1,,ANY
311124,BLOCK,1,,<empty>,,,,1,,ANY
311130,BLOCK,1,,<empty>,,,,1,,ANY
311138,BLOCK,1,,<empty>,,,,1,,ANY
311142,BLOCK,1,,<empty>,,,,1,,ANY
311146,BLOCK,1,,<empty>,,,,1,,ANY
311150,BLOCK,1,,<empty>,,,,1,,ANY
311154,BLOCK,1,,<empty>,,,,1,,ANY
311158,BLOCK,1,,<empty>,,,,1,,ANY
311162,BLOCK,1,,<empty>,,,,1,,ANY
311166,BLOCK,1,,<empty>,,,,1,,ANY
311170,BLOCK,1,,<empty>,,,,1,,ANY
311176,BLOCK,1,,<empty>,,,,1,,ANY
311180,BLOCK,1,,<empty>,,,,1,,ANY
311184,BLOCK,1,,<empty>,,,,1,,ANY
311188,BLOCK,1,,<empty>,,,,1,,ANY
311192,BLOCK,1,,<empty>,,,,1,,ANY
311196,BLOCK,1,,<empty>,,,,1,,ANY
311200,BLOCK,1,,<empty>,,,,1,,ANY
311205,BLOCK,1,,<empty>,,,,1,,ANY
311209,BLOCK,1,,<empty>,,,,1,,ANY
311214,BLOCK,1,,<empty>,,,,1,,ANY
311218,BLOCK,1,,<empty>,,,,1,,ANY
311223,BLOCK,1,,<empty>,,,,1,,ANY
311231,BLOCK,1,,<empty>,,,,1,,ANY
311239,BLOCK,1,,<empty>,,,,1,,ANY
311245,BLOCK,1,,<empty>,,,,1,,ANY
311249,BLOCK,1,,<empty>,,,,1,,ANY
311252,BLOCK,1,,<empty>,,,,1,,ANY
311256,BLOCK,1,,<empty>,,,,1,,ANY
311267,BLOCK,1,,<empty>,,,,1,,ANY
311270,BLOCK,1,,<empty>,,,,1,,ANY
311275,BLOCK,1,,<empty>,,,,1,,ANY
311285,BLOCK,1,,<empty>,,,,1,,ANY
311290,BLOCK,1,,<empty>,,,,1,,ANY
311294,BLOCK,1,,<empty>,,,,1,,ANY
311301,BLOCK,1,,<empty>,,,,1,,ANY
311307,BLOCK,1,,<empty>,,,,1,,ANY
311311,BLOCK,1,,<empty>,,,,1,,ANY
311315,BLOCK,1,,<empty>,,,,1,,ANY
311323,BLOCK,1,,<empty>,,,,1,,ANY
311327,BLOCK,1,,<empty>,,,,1,,ANY
311331,BLOCK,1,,<empty>,,,,1,,ANY
311337,BLOCK,1,,<empty>,,,,1,,ANY
311341,BLOCK,1,,<empty>,,,,1,,ANY
311348,BLOCK,1,,<empty>,,,,1,,ANY
311352,BLOCK,1,,<empty>,,,,1,,ANY
311356,BLOCK,1,,<empty>,,,,1,,ANY
311362,BLOCK,1,,<empty>,,,,1,,ANY
311367,BLOCK,1,,<empty>,,,,1,,ANY
311371,BLOCK,1,,<empty>,,,,1,,ANY
311374,BLOCK,1,,<empty>,,,,1,,ANY
311380,BLOCK,1,,<empty>,,,,1,,ANY
311384,BLOCK,1,,<empty>,,,,1,,ANY
311390,BLOCK,1,,<empty>,,,,1,,ANY
311394,BLOCK,1,,<empty>,,,,1,,ANY
311401,BLOCK,1,,<empty>,,,,1,,ANY
311406,BLOCK,1,,<empty>,,,,1,,ANY
311411,BLOCK,1,,<empty>,,,,1,,ANY
311416,BLOCK,1,,<empty>,,,,1,,ANY
311421,BLOCK,1,,<empty>,,,,1,,ANY
311426,BLOCK,1,,<empty>,,,,1,,ANY
311430,BLOCK,1,,<empty>,,,,1,,ANY
311435,BLOCK,1,,<empty>,,,,1,,ANY
311440,BLOCK,1,,<empty>,,,,1,,ANY
311445,BLOCK,1,,<empty>,,,,1,,ANY
311453,BLOCK,1,,<empty>,,,,1,,ANY
311459,BLOCK,1,,<empty>,,,,1,,ANY
311464,BLOCK,1,,<empty>,,,,1,,ANY
311468,BLOCK,1,,<empty>,,,,1,,ANY
311472,BLOCK,1,,<empty>,,,,1,,ANY
311476,BLOCK,1,,<empty>,,,,1,,ANY
311486,BLOCK,1,,<empty>,,,,1,,ANY
311491,BLOCK,1,,<empty>,,,,1,,ANY
311496,BLOCK,1,,<empty>,,,,1,,ANY
311500,BLOCK,1,,<empty>,,,,1,,ANY
311505,BLOCK,1,,<empty>,,,,1,,ANY
311510,BLOCK,1,,<empty>,,,,1,,ANY
311516,BLOCK,1,,<empty>,,,,1,,ANY
311520,BLOCK,1,,<empty>,,,,1,,ANY
311524,BLOCK,1,,<empty>,,,,1,,ANY
311528,BLOCK,1,,<empty>,,,,1,,ANY
311531,BLOCK,1,,<empty>,,,,1,,ANY
311538,BLOCK,1,,<empty>,,,,1,,ANY
311544,BLOCK,1,,<empty>,,,,1,,ANY
311548,BLOCK,1,,<empty>,,,,1,,ANY
311552,BLOCK,1,,<empty>,,,,1,,ANY
311558,BLOCK,1,,<empty>,,,,1,,ANY
311564,BLOCK,1,,<empty>,,,,1,,ANY
311569,BLOCK,1,,<empty>,,,,1,,ANY
311574,BLOCK,1,,<empty>,,,,1,,ANY
311579,BLOCK,1,,<empty>,,,,1,,ANY
311583,BLOCK,1,,<empty>,,,,1,,ANY
311589,BLOCK,1,,<empty>,,,,1,,ANY
311593,BLOCK,1,,<empty>,,,,1,,ANY
311597,BLOCK,1,,<empty>,,,,1,,ANY
311601,BLOCK,1,,<empty>,,,,1,,ANY
311605,BLOCK,1,,<empty>,,,,1,,ANY
311609,BLOCK,1,,<empty>,,,,1,,ANY
311613,BLOCK,1,,<empty>,,,,1,,ANY
311617,BLOCK,1,,<empty>,,,,1,,ANY
311621,BLOCK,1,,<empty>,,,,1,,ANY
311625,BLOCK,1,,<empty>,,,,1,,ANY
311629,BLOCK,1,,<empty>,,,,1,,ANY
311634,BLOCK,1,,<empty>,,,,1,,ANY
311639,BLOCK,1,,<empty>,,,,1,,ANY
311644,BLOCK,1,,<empty>,,,,1,,ANY
311649,BLOCK,1,,<empty>,,,,1,,ANY
311656,BLOCK,1,,<empty>,,,,1,,ANY
311661,BLOCK,1,,<empty>,,,,1,,ANY
311666,BLOCK,1,,<empty>,,,,1,,ANY
311669,BLOCK,1,,<empty>,,,,1,,ANY
311673,BLOCK,1,,<empty>,,,,1,,ANY
311677,BLOCK,1,,<empty>,,,,1,,ANY
311681,BLOCK,1,,<empty>,,,,1,,ANY
311686,BLOCK,1,,<empty>,,,,1,,ANY
311691,BLOCK,1,,<empty>,,,,1,,ANY
311695,BLOCK,1,,<empty>,,,,1,,ANY
311699,BLOCK,1,,<empty>,,,,1,,ANY
311704,BLOCK,1,,<empty>,,,,1,,ANY
311708,BLOCK,1,,<empty>,,,,1,,ANY
311713,BLOCK,1,,<empty>,,,,1,,ANY
311718,BLOCK,1,,<empty>,,,,1,,ANY
311725,BLOCK,1,,<empty>,,,,1,,ANY
311729,BLOCK,1,,<empty>,,,,1,,ANY
311734,BLOCK,1,,<empty>,,,,1,,ANY
311739,BLOCK,1,,<empty>,,,,1,,ANY
311743,BLOCK,1,,<empty>,,,,1,,ANY
311747,BLOCK,1,,<empty>,,,,1,,ANY
311755,BLOCK,1,,<empty>,,,,1,,ANY
311759,BLOCK,1,,<empty>,,,,1,,ANY
311763,BLOCK,1,,<empty>,,,,1,,ANY
311768,BLOCK,1,,<empty>,,,,1,,ANY
311772,BLOCK,1,,<empty>,,,,1,,ANY
311777,BLOCK,1,,<empty>,,,,1,,ANY
311782,BLOCK,1,,<empty>,,,,1,,ANY
311786,BLOCK,1,,<empty>,,,,1,,ANY
311790,BLOCK,1,,<empty>,,,,1,,ANY
311795,BLOCK,1,,<empty>,,,,1,,ANY
311799,BLOCK,1,,<empty>,,,,1,,ANY
311805,BLOCK,1,,<empty>,,,,1,,ANY
311809,BLOCK,1,,<empty>,,,,1,,ANY
311813,BLOCK,1,,<empty>,,,,1,,ANY
311820,BLOCK,1,,<empty>,,,,1,,ANY
311825,BLOCK,1,,<empty>,,,,1,,ANY
311830,BLOCK,1,,<empty>,,,,1,,ANY
311835,BLOCK,1,,<empty>,,,,1,,ANY
311842,BLOCK,1,,<empty>,,,,1,,ANY
311848,BLOCK,1,,<empty>,,,,1,,ANY
311853,BLOCK,1,,<empty>,,,,1,,ANY
311857,BLOCK,1,,<empty>,,,,1,,ANY
311861,BLOCK,1,,<empty>,,,,1,,ANY
311867,BLOCK,1,,<empty>,,,,1,,ANY
311873,BLOCK,1,,<empty>,,,,1,,ANY
311881,BLOCK,1,,<empty>,,,,1,,ANY
311887,BLOCK,1,,<empty>,,,,1,,ANY
311894,BLOCK,1,,<empty>,,,,1,,ANY
311899,BLOCK,1,,<empty>,,,,1,,ANY
311905,BLOCK,1,,<empty>,,,,1,,ANY
311909,BLOCK,1,,<empty>,,,,1,,ANY
311913,BLOCK,1,,<empty>,,,,1,,ANY
311917,BLOCK,1,,<empty>,,,,1,,ANY
311921,BLOCK,1,,<empty>,,,,1,,ANY
311926,BLOCK,1,,<empty>,,,,1,,ANY
311931,BLOCK,1,,<empty>,,,,1,,ANY
311936,BLOCK,1,,<empty>,,,,1,,ANY
311940,BLOCK,1,,<empty>,,,,1,,ANY
311945,BLOCK,1,,<empty>,,,,1,,ANY
311951,BLOCK,1,,<empty>,,,,1,,ANY
311956,BLOCK,1,,<empty>,,,,1,,ANY
311962,BLOCK,1,,<empty>,,,,1,,ANY
311967,BLOCK,1,,<empty>,,,,1,,ANY
311972,BLOCK,1,,<empty>,,,,1,,ANY
311977,BLOCK,1,,<empty>,,,,1,,ANY
311982,BLOCK,1,,<empty>,,,,1,,ANY
311986,BLOCK,1,,<empty>,,,,1,,ANY
311990,BLOCK,1,,<empty>,,,,1,,ANY
311994,BLOCK,1,,<empty>,,,,1,,ANY
311998,BLOCK,1,,<empty>,,,,1,,ANY
312003,BLOCK,1,,<empty>,,,,1,,ANY
312007,BLOCK,1,,<empty>,,,,1,,ANY
312011,BLOCK,1,,<empty>,,,,1,,ANY
312015,BLOCK,1,,<empty>,,,,1,,ANY
312020,BLOCK,1,,<empty>,,,,1,,ANY
312026,BLOCK,1,,<empty>,,,,1,,ANY
312031,BLOCK,1,,<empty>,,,,1,,ANY
312036,BLOCK,1,,<empty>,,,,1,,ANY
312041,BLOCK,1,,<empty>,,,,1,,ANY
312045,BLOCK,1,,<empty>,,,,1,,ANY
312050,BLOCK,1,,<empty>,,,,1,,ANY
312054,BLOCK,1,,<empty>,,,,1,,ANY
312057,BLOCK,1,,<empty>,,,,1,,ANY
312064,BLOCK,1,,<empty>,,,,1,,ANY
312069,BLOCK,1,,<empty>,,,,1,,ANY
312074,BLOCK,1,,<empty>,,,,1,,ANY
312079,BLOCK,1,,<empty>,,,,1,,ANY
312083,BLOCK,1,,<empty>,,,,1,,ANY
312088,BLOCK,1,,<empty>,,,,1,,ANY
312093,BLOCK,1,,<empty>,,,,1,,ANY
312097,BLOCK,1,,<empty>,,,,1,,ANY
312101,BLOCK,1,,<empty>,,,,1,,ANY
312108,BLOCK,1,,<empty>,,,,1,,ANY
312112,BLOCK,1,,<empty>,,,,1,,ANY
312119,BLOCK,1,,<empty>,,,,1,,ANY
312123,BLOCK,1,,<empty>,,,,1,,ANY
312127,BLOCK,1,,<empty>,,,,1,,ANY
312131,BLOCK,1,,<empty>,,,,1,,ANY
312135,BLOCK,1,,<empty>,,,,1,,ANY
312139,BLOCK,1,,<empty>,,,,1,,ANY
312143,BLOCK,1,,<empty>,,,,1,,ANY
312152,BLOCK,1,,<empty>,,,,1,,ANY
312156,BLOCK,1,,<empty>,,,,1,,ANY
312160,BLOCK,1,,<empty>,,,,1,,ANY
312165,BLOCK,1,,<empty>,,,,1,,ANY
312169,BLOCK,1,,<empty>,,,,1,,ANY
312176,BLOCK,1,,<empty>,,,,1,,ANY
312183,BLOCK,1,,<empty>,,,,1,,ANY
312187,BLOCK,1,,<empty>,,,,1,,ANY
312191,BLOCK,1,,<empty>,,,,1,,ANY
312195,BLOCK,1,,<empty>,,,,1,,ANY
312200,BLOCK,1,,<empty>,,,,1,,ANY
312204,BLOCK,1,,<empty>,,,,1,,ANY
312209,BLOCK,1,,<empty>,,,,1,,ANY
312213,BLOCK,1,,<empty>,,,,1,,ANY
312219,BLOCK,1,,<empty>,,,,1,,ANY
312223,BLOCK,1,,<empty>,,,,1,,ANY
312229,BLOCK,1,,<empty>,,,,1,,ANY
312236,BLOCK,1,,<empty>,,,,1,,ANY
312240,BLOCK,1,,<empty>,,,,1,,ANY
312244,BLOCK,1,,<empty>,,,,1,,ANY
312248,BLOCK,1,,<empty>,,,,1,,ANY
312252,BLOCK,1,,<empty>,,,,1,,ANY
312259,BLOCK,1,,<empty>,,,,1,,ANY
312263,BLOCK,1,,<empty>,,,,1,,ANY
312269,BLOCK,1,,<empty>,,,,1,,ANY
312273,BLOCK,1,,<empty>,,,,1,,ANY
312278,BLOCK,1,,<empty>,,,,1,,ANY
312282,BLOCK,1,,<empty>,,,,1,,ANY
312288,BLOCK,1,,<empty>,,,,1,,ANY
312292,BLOCK,1,,<empty>,,,,1,,ANY
312297,BLOCK,1,,<empty>,,,,1,,ANY
312303,BLOCK,1,,<empty>,,,,1,,ANY
312309,BLOCK,1,,<empty>,,,,1,,ANY
312313,BLOCK,1,,<empty>,,,,1,,ANY
312318,BLOCK,1,,<empty>,,,,1,,ANY
312322,BLOCK,1,,<empty>,,,,1,,ANY
312327,BLOCK,1,,<empty>,,,,1,,ANY
312331,BLOCK,1,,<empty>,,,,1,,ANY
312337,BLOCK,1,,<empty>,,,,1,,ANY
312341,BLOCK,1,,<empty>,,,,1,,ANY
312347,BLOCK,1,,<empty>,,,,1,,ANY
312351,BLOCK,1,,<empty>,,,,1,,ANY
312357,BLOCK,1,,<empty>,,,,1,,ANY
312360,BLOCK,1,,<empty>,,,,1,,ANY
312364,BLOCK,1,,<empty>,,,,1,,ANY
312367,BLOCK,1,,<empty>,,,,1,,ANY
312371,BLOCK,1,,<empty>,,,,1,,ANY
312374,BLOCK,1,,<empty>,,,,1,,ANY
312378,BLOCK,1,,<empty>,,,,1,,ANY
312383,BLOCK,1,,<empty>,,,,1,,ANY
312387,BLOCK,1,,<empty>,,,,1,,ANY
312392,BLOCK,1,,<empty>,,,,1,,ANY
312396,BLOCK,1,,<empty>,,,,1,,ANY
312401,BLOCK,1,,<empty>,,,,1,,ANY
312404,BLOCK,1,,<empty>,,,,1,,ANY
312408,BLOCK,1,,<empty>,,,,1,,ANY
312414,BLOCK,1,,<empty>,,,,1,,ANY
312417,BLOCK,1,,<empty>,,,,1,,ANY
312421,BLOCK,1,,<empty>,,,,1,,ANY
312428,BLOCK,1,,<empty>,,,,1,,ANY
312432,BLOCK,1,,<empty>,,,,1,,ANY
312435,BLOCK,1,,<empty>,,,,1,,ANY
312440,BLOCK,1,,<empty>,,,,1,,ANY
312443,BLOCK,1,,<empty>,,,,1,,ANY
312447,BLOCK,1,,<empty>,,,,1,,ANY
312451,BLOCK,1,,<empty>,,,,1,,ANY
312459,BLOCK,1,,<empty>,,,,1,,ANY
312466,BLOCK,1,,<empty>,,,,1,,ANY
312472,BLOCK,1,,<empty>,,,,1,,ANY
312475,BLOCK,1,,<empty>,,,,1,,ANY
312478,BLOCK,1,,<empty>,,,,1,,ANY
312484,BLOCK,1,,<empty>,,,,1,,ANY
312487,BLOCK,1,,<empty>,,,,1,,ANY
312491,BLOCK,1,,<empty>,,,,1,,ANY
312495,BLOCK,1,,<empty>,,,,1,,ANY
312499,BLOCK,1,,<empty>,,,,1,,ANY
312504,BLOCK,1,,<empty>,,,,1,,ANY
312512,BLOCK,1,,<empty>,,,,1,,ANY
312517,BLOCK,1,,<empty>,,,,1,,ANY
312521,BLOCK,1,,<empty>,,,,1,,ANY
312525,BLOCK,1,,<empty>,,,,1,,ANY
312530,BLOCK,1,,<empty>,,,,1,,ANY
312536,BLOCK,1,,<empty>,,,,1,,ANY
312542,BLOCK,1,,<empty>,,,,1,,ANY
312548,BLOCK,1,,<empty>,,,,1,,ANY
312554,BLOCK,1,,<empty>,,,,1,,ANY
312560,BLOCK,1,,<empty>,,,,1,,ANY
312568,BLOCK,1,,<empty>,,,,1,,ANY
312574,BLOCK,1,,<empty>,,,,1,,ANY
312582,BLOCK,1,,<empty>,,,,1,,ANY
312586,BLOCK,1,,<empty>,,,,1,,ANY
312589,BLOCK,1,,<empty>,,,,1,,ANY
312594,BLOCK,1,,<empty>,,,,1,,ANY
312599,BLOCK,1,,<empty>,,,,1,,ANY
312604,BLOCK,1,,<empty>,,,,1,,ANY
312607,BLOCK,1,,<empty>,,,,1,,ANY
312612,BLOCK,1,,<empty>,,,,1,,ANY
312618,BLOCK,1,,<empty>,,,,1,,ANY
312621,BLOCK,1,,<empty>,,,,1,,ANY
312624,BLOCK,1,,<empty>,,,,1,,ANY
312628,BLOCK,1,,<empty>,,,,1,,ANY
312633,BLOCK,1,,<empty>,,,,1,,ANY
312638,BLOCK,1,,<empty>,,,,1,,ANY
312643,BLOCK,1,,<empty>,,,,1,,ANY
312648,BLOCK,1,,<empty>,,,,1,,ANY
312653,BLOCK,1,,<empty>,,,,1,,ANY
312658,BLOCK,1,,<empty>,,,,1,,ANY
312662,BLOCK,1,,<empty>,,,,1,,ANY
312667,BLOCK,1,,<empty>,,,,1,,ANY
312671,BLOCK,1,,<empty>,,,,1,,ANY
312676,BLOCK,1,,<empty>,,,,1,,ANY
312680,BLOCK,1,,<empty>,,,,1,,ANY
312685,BLOCK,1,,<empty>,,,,1,,ANY
312690,BLOCK,1,,<empty>,,,,1,,ANY
312695,BLOCK,1,,<empty>,,,,1,,ANY
312700,BLOCK,1,,<empty>,,,,1,,ANY
312704,BLOCK,1,,<empty>,,,,1,,ANY
312709,BLOCK,1,,<empty>,,,,1,,ANY
312713,BLOCK,1,,<empty>,,,,1,,ANY
312717,BLOCK,1,,<empty>,,,,1,,ANY
312722,BLOCK,1,,<empty>,,,,1,,ANY
312728,BLOCK,1,,<empty>,,,,1,,ANY
312735,BLOCK,1,,<empty>,,,,1,,ANY
312740,BLOCK,1,,<empty>,,,,1,,ANY
312745,BLOCK,1,,<empty>,,,,1,,ANY
312750,BLOCK,1,,<empty>,,,,1,,ANY
312754,BLOCK,1,,<empty>,,,,1,,ANY
312759,BLOCK,1,,<empty>,,,,1,,ANY
312764,BLOCK,1,,<empty>,,,,1,,ANY
312769,BLOCK,1,,<empty>,,,,1,,ANY
312775,BLOCK,1,,<empty>,,,,1,,ANY
312780,BLOCK,1,,<empty>,,,,1,,ANY
312784,BLOCK,1,,<empty>,,,,1,,ANY
312789,BLOCK,1,,<empty>,,,,1,,ANY
312796,BLOCK,1,,<empty>,,,,1,,ANY
312802,BLOCK,1,,<empty>,,,,1,,ANY
312805,BLOCK,1,,<empty>,,,,1,,ANY
312810,BLOCK,1,,<empty>,,,,1,,ANY
312815,BLOCK,1,,<empty>,,,,1,,ANY
312820,BLOCK,1,,<empty>,,,,1,,ANY
312824,BLOCK,1,,<empty>,,,,1,,ANY
312831,BLOCK,1,,<empty>,,,,1,,ANY
312836,BLOCK,1,,<empty>,,,,1,,ANY
312841,BLOCK,1,,<empty>,,,,1,,ANY
312847,BLOCK,1,,<empty>,,,,1,,ANY
312851,BLOCK,1,,<empty>,,,,1,,ANY
312855,BLOCK,1,,<empty>,,,,1,,ANY
312860,BLOCK,1,,<empty>,,,,1,,ANY
312865,BLOCK,1,,<empty>,,,,1,,ANY
312870,BLOCK,1,,<empty>,,,,1,,ANY
312875,BLOCK,1,,<empty>,,,,1,,ANY
312880,BLOCK,1,,<empty>,,,,1,,ANY
312887,BLOCK,1,,<empty>,,,,1,,ANY
312894,BLOCK,1,,<empty>,,,,1,,ANY
312899,BLOCK,1,,<empty>,,,,1,,ANY
312903,BLOCK,1,,<empty>,,,,1,,ANY
312907,BLOCK,1,,<empty>,,,,1,,ANY
312912,BLOCK,1,,<empty>,,,,1,,ANY
312917,BLOCK,1,,<empty>,,,,1,,ANY
312923,BLOCK,1,,<empty>,,,,1,,ANY
312927,BLOCK,1,,<empty>,,,,1,,ANY
312932,BLOCK,1,,<empty>,,,,1,,ANY
312937,BLOCK,1,,<empty>,,,,1,,ANY
312941,BLOCK,1,,<empty>,,,,1,,ANY
312947,BLOCK,1,,<empty>,,,,1,,ANY
312951,BLOCK,1,,<empty>,,,,1,,ANY
312956,BLOCK,1,,<empty>,,,,1,,ANY
312962,BLOCK,1,,<empty>,,,,1,,ANY
312967,BLOCK,1,,<empty>,,,,1,,ANY
312975,BLOCK,1,,<empty>,,,,1,,ANY
312979,BLOCK,1,,<empty>,,,,1,,ANY
312984,BLOCK,1,,<empty>,,,,1,,ANY
312989,BLOCK,1,,<empty>,,,,1,,ANY
312993,BLOCK,1,,<empty>,,,,1,,ANY
312997,BLOCK,1,,<empty>,,,,1,,ANY
313002,BLOCK,1,,<empty>,,,,1,,ANY
313006,BLOCK,1,,<empty>,,,,1,,ANY
313014,BLOCK,1,,<empty>,,,,1,,ANY
313018,BLOCK,1,,<empty>,,,,1,,ANY
313026,BLOCK,1,,<empty>,,,,1,,ANY
313029,BLOCK,1,,<empty>,,,,1,,ANY
313037,BLOCK,1,,<empty>,,,,1,,ANY
313043,BLOCK,1,,<empty>,,,,1,,ANY
313049,BLOCK,1,,<empty>,,,,1,,ANY
313053,BLOCK,1,,<empty>,,,,1,,ANY
313058,BLOCK,1,,<empty>,,,,1,,ANY
313061,BLOCK,1,,<empty>,,,,1,,ANY
313066,BLOCK,1,,<empty>,,,,1,,ANY
313072,BLOCK,1,,<empty>,,,,1,,ANY
313079,BLOCK,1,,<empty>,,,,1,,ANY
313083,BLOCK,1,,<empty>,,,,1,,ANY
313089,BLOCK,1,,<empty>,,,,1,,ANY
313095,BLOCK,1,,<empty>,,,,1,,ANY
313100,BLOCK,1,,<empty>,,,,1,,ANY
313106,BLOCK,1,,<empty>,,,,1,,ANY
313111,BLOCK,1,,<empty>,,,,1,,ANY
313117,BLOCK,1,,<empty>,,,,1,,ANY
313123,BLOCK,1,,<empty>,,,,1,,ANY
313129,BLOCK,1,,<empty>,,,,1,,ANY
313134,BLOCK,1,,<empty>,,,,1,,ANY
313139,BLOCK,1,,<empty>,,,,1,,ANY
313144,BLOCK,1,,<empty>,,,,1,,ANY
313147,BLOCK,1,,<empty>,,,,1,,ANY
313154,BLOCK,1,,<empty>,,,,1,,ANY
313157,BLOCK,1,,<empty>,,,,1,,ANY
313161,BLOCK,1,,<empty>,,,,1,,ANY
313168,BLOCK,1,,<empty>,,,,1,,ANY
313176,BLOCK,1,,<empty>,,,,1,,ANY
313179,BLOCK,1,,<empty>,,,,1,,ANY
313182,BLOCK,1,,<empty>,,,,1,,ANY
313186,BLOCK,1,,<empty>,,,,1,,ANY
313190,BLOCK,1,,<empty>,,,,1,,ANY
313194,BLOCK,1,,<empty>,,,,1,,ANY
313198,BLOCK,1,,<empty>,,,,1,,ANY
313204,BLOCK,1,,<empty>,,,,1,,ANY
313209,BLOCK,1,,<empty>,,,,1,,ANY
313213,BLOCK,1,,<empty>,,,,1,,ANY
313217,BLOCK,1,,<empty>,,,,1,,ANY
313221,BLOCK,1,,<empty>,,,,1,,ANY
313225,BLOCK,1,,<empty>,,,,1,,ANY
313229,BLOCK,1,,<empty>,,,,1,,ANY
313233,BLOCK,1,,<empty>,,,,1,,ANY
313237,BLOCK,1,,<empty>,,,,1,,ANY
313241,BLOCK,1,,<empty>,,,,1,,ANY
313247,BLOCK,1,,<empty>,,,,1,,ANY
313251,BLOCK,1,,<empty>,,,,1,,ANY
313257,BLOCK,1,,<empty>,,,,1,,ANY
313261,BLOCK,1,,<empty>,,,,1,,ANY
313267,BLOCK,1,,<empty>,,,,1,,ANY
313273,BLOCK,1,,<empty>,,,,1,,ANY
313279,BLOCK,1,,<empty>,,,,1,,ANY
313284,BLOCK,1,,<empty>,,,,1,,ANY
313290,BLOCK,1,,<empty>,,,,1,,ANY
313295,BLOCK,1,,<empty>,,,,1,,ANY
313300,BLOCK,1,,<empty>,,,,1,,ANY
313304,BLOCK,1,,<empty>,,,,1,,ANY
313307,BLOCK,1,,<empty>,,,,1,,ANY
313311,BLOCK,1,,<empty>,,,,1,,ANY
313314,BLOCK,1,,<empty>,,,,1,,ANY
313319,BLOCK,1,,<empty>,,,,1,,ANY
313324,BLOCK,1,,<empty>,,,,1,,ANY
313328,BLOCK,1,,<empty>,,,,1,,ANY
313333,BLOCK,1,,<empty>,,,,1,,ANY
313337,BLOCK,1,,<empty>,,,,1,,ANY
313342,BLOCK,1,,<empty>,,,,1,,ANY
313347,BLOCK,1,,<empty>,,,,1,,ANY
313352,BLOCK,1,,<empty>,,,,1,,ANY
313356,BLOCK,1,,<empty>,,,,1,,ANY
313361,BLOCK,1,,<empty>,,,,1,,ANY
313366,BLOCK,1,,<empty>,,,,1,,ANY
313370,BLOCK,1,,<empty>,,,,1,,ANY
313375,BLOCK,1,,<empty>,,,,1,,ANY
313381,BLOCK,1,,<empty>,,,,1,,ANY
313387,BLOCK,1,,<empty>,,,,1,,ANY
313392,BLOCK,1,,<empty>,,,,1,,ANY
313397,BLOCK,1,,<empty>,,,,1,,ANY
313401,BLOCK,1,,<empty>,,,,1,,ANY
313406,BLOCK,1,,<empty>,,,,1,,ANY
313411,BLOCK,1,,<empty>,,,,1,,ANY
313415,BLOCK,1,,<empty>,,,,1,,ANY
313424,BLOCK,1,,<empty>,,,,1,,ANY
313428,BLOCK,1,,<empty>,,,,1,,ANY
313432,BLOCK,1,,<empty>,,,,1,,ANY
313436,BLOCK,1,,<empty>,,,,1,,ANY
313440,BLOCK,1,,<empty>,,,,1,,ANY
313447,BLOCK,1,,<empty>,,,,1,,ANY
313451,BLOCK,1,,<empty>,,,,1,,ANY
313455,BLOCK,1,,<empty>,,,,1,,ANY
313461,BLOCK,1,,<empty>,,,,1,,ANY
313467,BLOCK,1,,<empty>,,,,1,,ANY
313472,BLOCK,1,,<empty>,,,,1,,ANY
313477,BLOCK,1,,<empty>,,,,1,,ANY
313481,BLOCK,1,,<empty>,,,,1,,ANY
313485,BLOCK,1,,<empty>,,,,1,,ANY
313490,BLOCK,1,,<empty>,,,,1,,ANY
313496,BLOCK,1,,<empty>,,,,1,,ANY
313502,BLOCK,1,,<empty>,,,,1,,ANY
313508,BLOCK,1,,<empty>,,,,1,,ANY
313516,BLOCK,1,,<empty>,,,,1,,ANY
313524,BLOCK,1,,<empty>,,,,1,,ANY
313529,BLOCK,1,,<empty>,,,,1,,ANY
313534,BLOCK,1,,<empty>,,,,1,,ANY
313539,BLOCK,1,,<empty>,,,,1,,ANY
313544,BLOCK,1,,<empty>,,,,1,,ANY
313548,BLOCK,1,,<empty>,,,,1,,ANY
313556,BLOCK,1,,<empty>,,,,1,,ANY
313560,BLOCK,1,,<empty>,,,,1,,ANY
313564,BLOCK,1,,<empty>,,,,1,,ANY
313568,BLOCK,1,,<empty>,,,,1,,ANY
313572,BLOCK,1,,<empty>,,,,1,,ANY
313576,BLOCK,1,,<empty>,,,,1,,ANY
313579,BLOCK,1,,<empty>,,,,1,,ANY
313587,BLOCK,1,,<empty>,,,,1,,ANY
313591,BLOCK,1,,<empty>,,,,1,,ANY
313595,BLOCK,1,,<empty>,,,,1,,ANY
313602,BLOCK,1,,<empty>,,,,1,,ANY
313606,BLOCK,1,,<empty>,,,,1,,ANY
313614,BLOCK,1,,<empty>,,,,1,,ANY
313618,BLOCK,1,,<empty>,,,,1,,ANY
313622,BLOCK,1,,<empty>,,,,1,,ANY
313626,BLOCK,1,,<empty>,,,,1,,ANY
313631,BLOCK,1,,<empty>,,,,1,,ANY
313635,BLOCK,1,,<empty>,,,,1,,ANY
313639,BLOCK,1,,<empty>,,,,1,,ANY
313644,BLOCK,1,,<empty>,,,,1,,ANY
313653,BLOCK,1,,<empty>,,,,1,,ANY
313658,BLOCK,1,,<empty>,,,,1,,ANY
313662,BLOCK,1,,<empty>,,,,1,,ANY
313668,BLOCK,1,,<empty>,,,,1,,ANY
313672,BLOCK,1,,<empty>,,,,1,,ANY
313676,BLOCK,1,,<empty>,,,,1,,ANY
313680,BLOCK,1,,<empty>,,,,1,,ANY
313684,BLOCK,1,,<empty>,,,,1,,ANY
313688,BLOCK,1,,<empty>,,,,1,,ANY
313692,BLOCK,1,,<empty>,,,,1,,ANY
313696,BLOCK,1,,<empty>,,,,1,,ANY
313700,BLOCK,1,,<empty>,,,,1,,ANY
313705,BLOCK,1,,<empty>,,,,1,,ANY
313710,BLOCK,1,,<empty>,,,,1,,ANY
313715,BLOCK,1,,<empty>,,,,1,,ANY
313719,BLOCK,1,,<empty>,,,,1,,ANY
313724,BLOCK,1,,<empty>,,,,1,,ANY
313730,BLOCK,1,,<empty>,,,,1,,ANY
313733,BLOCK,1,,<empty>,,,,1,,ANY
313738,BLOCK,1,,<empty>,,,,1,,ANY
313742,BLOCK,1,,<empty>,,,,1,,ANY
313747,BLOCK,1,,<empty>,,,,1,,ANY
313752,BLOCK,1,,<empty>,,,,1,,ANY
313757,BLOCK,1,,<empty>,,,,1,,ANY
313761,BLOCK,1,,<empty>,,,,1,,ANY
313769,BLOCK,1,,<empty>,,,,1,,ANY
313772,BLOCK,1,,<empty>,,,,1,,ANY
313776,BLOCK,1,,<empty>,,,,1,,ANY
313780,BLOCK,1,,<empty>,,,,1,,ANY
313787,BLOCK,1,,<empty>,,,,1,,ANY
313791,BLOCK,1,,<empty>,,,,1,,ANY
313795,BLOCK,1,,<empty>,,,,1,,ANY
313801,BLOCK,1,,<empty>,,,,1,,ANY
313805,BLOCK,1,,<empty>,,,,1,,ANY
313809,BLOCK,1,,<empty>,,,,1,,ANY
313813,BLOCK,1,,<empty>,,,,1,,ANY
313816,BLOCK,1,,<empty>,,,,1,,ANY
313822,BLOCK,1,,<empty>,,,,1,,ANY
313828,BLOCK,1,,<empty>,,,,1,,ANY
313832,BLOCK,1,,<empty>,,,,1,,ANY
313836,BLOCK,1,,<empty>,,,,1,,ANY
313840,BLOCK,1,,<empty>,,,,1,,ANY
313845,BLOCK,1,,<empty>,,,,1,,ANY
313851,BLOCK,1,,<empty>,,,,1,,ANY
313857,BLOCK,1,,<empty>,,,,1,,ANY
313861,BLOCK,1,,<empty>,,,,1,,ANY
313867,BLOCK,1,,<empty>,,,,1,,ANY
313871,BLOCK,1,,<empty>,,,,1,,ANY
313875,BLOCK,1,,<empty>,,,,1,,ANY
313881,BLOCK,1,,<empty>,,,,1,,ANY
313886,BLOCK,1,,<empty>,,,,1,,ANY
313892,BLOCK,1,,<empty>,,,,1,,ANY
313897,BLOCK,1,,<empty>,,,,1,,ANY
313901,BLOCK,1,,<empty>,,,,1,,ANY
313906,BLOCK,1,,<empty>,,,,1,,ANY
313909,BLOCK,1,,<empty>,,,,1,,ANY
313913,BLOCK,1,,<empty>,,,,1,,ANY
313919,BLOCK,1,,<empty>,,,,1,,ANY
313924,BLOCK,1,,<empty>,,,,1,,ANY
313927,BLOCK,1,,<empty>,,,,1,,ANY
313933,BLOCK,1,,<empty>,,,,1,,ANY
313937,BLOCK,1,,<empty>,,,,1,,ANY
313941,BLOCK,1,,<empty>,,,,1,,ANY
313946,BLOCK,1,,<empty>,,,,1,,ANY
313952,BLOCK,1,,<empty>,,,,1,,ANY
313957,BLOCK,1,,<empty>,,,,1,,ANY
313961,BLOCK,1,,<empty>,,,,1,,ANY
313967,BLOCK,1,,<empty>,,,,1,,ANY
313973,BLOCK,1,,<empty>,,,,1,,ANY
313977,BLOCK,1,,<empty>,,,,1,,ANY
313983,BLOCK,1,,<empty>,,,,1,,ANY
313987,BLOCK,1,,<empty>,,,,1,,ANY
313992,BLOCK,1,,<empty>,,,,1,,ANY
313996,BLOCK,1,,<empty>,,,,1,,ANY
314000,BLOCK,1,,<empty>,,,,1,,ANY
314005,BLOCK,1,,<empty>,,,,1,,ANY
314011,BLOCK,1,,<empty>,,,,1,,ANY
314021,BLOCK,1,,<empty>,,,,1,,ANY
314026,BLOCK,1,,<empty>,,,,1,,ANY
314032,BLOCK,1,,<empty>,,,,1,,ANY
314038,BLOCK,1,,<empty>,,,,1,,ANY
314044,BLOCK,1,,<empty>,,,,1,,ANY
314049,BLOCK,1,,<empty>,,,,1,,ANY
314052,BLOCK,1,,<empty>,,,,1,,ANY
314059,BLOCK,1,,<empty>,,,,1,,ANY
314065,BLOCK,1,,<empty>,,,,1,,ANY
314071,BLOCK,1,,<empty>,,,,1,,ANY
314075,BLOCK,1,,<empty>,,,,1,,ANY
314079,BLOCK,1,,<empty>,,,,1,,ANY
314083,BLOCK,1,,<empty>,,,,1,,ANY
314088,BLOCK,1,,<empty>,,,,1,,ANY
314094,BLOCK,1,,<empty>,,,,1,,ANY
314100,BLOCK,1,,<empty>,,,,1,,ANY
314106,BLOCK,1,,<empty>,,,,1,,ANY
314111,BLOCK,1,,<empty>,,,,1,,ANY
314116,BLOCK,1,,<empty>,,,,1,,ANY
314122,BLOCK,1,,<empty>,,,,1,,ANY
314129,BLOCK,1,,<empty>,,,,1,,ANY
314133,BLOCK,1,,<empty>,,,,1,,ANY
314139,BLOCK,1,,<empty>,,,,1,,ANY
314143,BLOCK,1,,<empty>,,,,1,,ANY
314146,BLOCK,1,,<empty>,,,,1,,ANY
314156,BLOCK,1,,<empty>,,,,1,,ANY
314161,BLOCK,1,,<empty>,,,,1,,ANY
314166,BLOCK,1,,<empty>,,,,1,,ANY
314170,BLOCK,1,,<empty>,,,,1,,ANY
314175,BLOCK,1,,<empty>,,,,1,,ANY
314182,BLOCK,1,,<empty>,,,,1,,ANY
314188,BLOCK,1,,<empty>,,,,1,,ANY
314192,BLOCK,1,,<empty>,,,,1,,ANY
314199,BLOCK,1,,<empty>,,,,1,,ANY
314206,BLOCK,1,,<empty>,,,,1,,ANY
314211,BLOCK,1,,<empty>,,,,1,,ANY
314218,BLOCK,1,,<empty>,,,,1,,ANY
314222,BLOCK,1,,<empty>,,,,1,,ANY
314227,BLOCK,1,,<empty>,,,,1,,ANY
314231,BLOCK,1,,<empty>,,,,1,,ANY
314235,BLOCK,1,,<empty>,,,,1,,ANY
314245,BLOCK,1,,<empty>,,,,1,,ANY
314249,BLOCK,1,,<empty>,,,,1,,ANY
314254,BLOCK,1,,<empty>,,,,1,,ANY
314264,BLOCK,1,,<empty>,,,,1,,ANY
314274,BLOCK,1,,<empty>,,,,1,,ANY
314278,BLOCK,1,,<empty>,,,,1,,ANY
314288,BLOCK,1,,<empty>,,,,1,,ANY
314293,BLOCK,1,,<empty>,,,,1,,ANY
314299,BLOCK,1,,<empty>,,,,1,,ANY
314304,BLOCK,1,,<empty>,,,,1,,ANY
314309,BLOCK,1,,<empty>,,,,1,,ANY
314314,BLOCK,1,,<empty>,,,,1,,ANY
314320,BLOCK,1,,<empty>,,,,1,,ANY
314324,BLOCK,1,,<empty>,,,,1,,ANY
314328,BLOCK,1,,<empty>,,,,1,,ANY
314333,BLOCK,1,,<empty>,,,,1,,ANY
314339,BLOCK,1,,<empty>,,,,1,,ANY
314345,BLOCK,1,,<empty>,,,,1,,ANY
314351,BLOCK,1,,<empty>,,,,1,,ANY
314355,BLOCK,1,,<empty>,,,,1,,ANY
314362,BLOCK,1,,<empty>,,,,1,,ANY
314369,BLOCK,1,,<empty>,,,,1,,ANY
314373,BLOCK,1,,<empty>,,,,1,,ANY
314379,BLOCK,1,,<empty>,,,,1,,ANY
314385,BLOCK,1,,<empty>,,,,1,,ANY
314391,BLOCK,1,,<empty>,,,,1,,ANY
314397,BLOCK,1,,<empty>,,,,1,,ANY
314401,BLOCK,1,,<empty>,,,,1,,ANY
314404,BLOCK,1,,<empty>,,,,1,,ANY
314407,BLOCK,1,,<empty>,,,,1,,ANY
314413,BLOCK,1,,<empty>,,,,1,,ANY
314420,BLOCK,1,,<empty>,,,,1,,ANY
314424,BLOCK,1,,<empty>,,,,1,,ANY
314431,BLOCK,1,,<empty>,,,,1,,ANY
314437,BLOCK,1,,<empty>,,,,1,,ANY
314443,BLOCK,1,,<empty>,,,,1,,ANY
314450,BLOCK,1,,<empty>,,,,1,,ANY
314455,BLOCK,1,,<empty>,,,,1,,ANY
314458,BLOCK,1,,<empty>,,,,1,,ANY
314462,BLOCK,1,,<empty>,,,,1,,ANY
314466,BLOCK,1,,<empty>,,,,1,,ANY
314472,BLOCK,1,,<empty>,,,,1,,ANY
314479,BLOCK,1,,<empty>,,,,1,,ANY
314483,BLOCK,1,,<empty>,,,,1,,ANY
314490,BLOCK,1,,<empty>,,,,1,,ANY
314495,BLOCK,1,,<empty>,,,,1,,ANY
314502,BLOCK,1,,<empty>,,,,1,,ANY
314510,BLOCK,1,,<empty>,,,,1,,ANY
314515,BLOCK,1,,<empty>,,,,1,,ANY
314519,BLOCK,1,,<empty>,,,,1,,ANY
314524,BLOCK,1,,<empty>,,,,1,,ANY
314529,BLOCK,1,,<empty>,,,,1,,ANY
314534,BLOCK,1,,<empty>,,,,1,,ANY
314541,BLOCK,1,,<empty>,,,,1,,ANY
314546,BLOCK,1,,<empty>,,,,1,,ANY
314551,BLOCK,1,,<empty>,,,,1,,ANY
314559,BLOCK,1,,<empty>,,,,1,,ANY
314563,BLOCK,1,,<empty>,,,,1,,ANY
314567,BLOCK,1,,<empty>,,,,1,,ANY
314572,BLOCK,1,,<empty>,,,,1,,ANY
314576,BLOCK,1,,<empty>,,,,1,,ANY
314582,BLOCK,1,,<empty>,,,,1,,ANY
314587,BLOCK,1,,<empty>,,,,1,,ANY
314593,BLOCK,1,,<empty>,,,,1,,ANY
314599,BLOCK,1,,<empty>,,,,1,,ANY
314603,BLOCK,1,,<empty>,,,,1,,ANY
314607,BLOCK,1,,<empty>,,,,1,,ANY
314611,BLOCK,1,,<empty>,,,,1,,ANY
314615,BLOCK,1,,<empty>,,,,1,,ANY
314619,BLOCK,1,,<empty>,,,,1,,ANY
314623,BLOCK,1,,<empty>,,,,1,,ANY
314627,BLOCK,1,,<empty>,,,,1,,ANY
314631,BLOCK,1,,<empty>,,,,1,,ANY
314635,BLOCK,1,,<empty>,,,,1,,ANY
314639,BLOCK,1,,<empty>,,,,1,,ANY
314643,BLOCK,1,,<empty>,,,,1,,ANY
314650,BLOCK,1,,<empty>,,,,1,,ANY
314655,BLOCK,1,,<empty>,,,,1,,ANY
314662,BLOCK,1,,<empty>,,,,1,,ANY
314667,BLOCK,1,,<empty>,,,,1,,ANY
314672,BLOCK,1,,<empty>,,,,1,,ANY
314677,BLOCK,1,,<empty>,,,,1,,ANY
314682,BLOCK,1,,<empty>,,,,1,,ANY
314686,BLOCK,1,,<empty>,,,,1,,ANY
314690,BLOCK,1,,<empty>,,,,1,,ANY
314694,BLOCK,1,,<empty>,,,,1,,ANY
314698,BLOCK,1,,<empty>,,,,1,,ANY
314702,BLOCK,1,,<empty>,,,,1,,ANY
314706,BLOCK,1,,<empty>,,,,1,,ANY
314711,BLOCK,1,,<empty>,,,,1,,ANY
314719,BLOCK,1,,<empty>,,,,1,,ANY
314727,BLOCK,1,,<empty>,,,,1,,ANY
314735,BLOCK,1,,<empty>,,,,1,,ANY
314743,BLOCK,1,,<empty>,,,,1,,ANY
314751,BLOCK,1,,<empty>,,,,1,,ANY
314759,BLOCK,1,,<empty>,,,,1,,ANY
314767,BLOCK,1,,<empty>,,,,1,,ANY
314775,BLOCK,1,,<empty>,,,,1,,ANY
314783,BLOCK,1,,<empty>,,,,1,,ANY
314791,BLOCK,1,,<empty>,,,,1,,ANY
314799,BLOCK,1,,<empty>,,,,1,,ANY
314807,BLOCK,1,,<empty>,,,,1,,ANY
314815,BLOCK,1,,<empty>,,,,1,,ANY
314823,BLOCK,1,,<empty>,,,,1,,ANY
314831,BLOCK,1,,<empty>,,,,1,,ANY
314839,BLOCK,1,,<empty>,,,,1,,ANY
314847,BLOCK,1,,<empty>,,,,1,,ANY
314855,BLOCK,1,,<empty>,,,,1,,ANY
314863,BLOCK,1,,<empty>,,,,1,,ANY
314871,BLOCK,1,,<empty>,,,,1,,ANY
314876,BLOCK,1,,<empty>,,,,1,,ANY
314880,BLOCK,1,,<empty>,,,,1,,ANY
314884,BLOCK,1,,<empty>,,,,1,,ANY
314895,BLOCK,1,,<empty>,,,,1,,ANY
314900,BLOCK,1,,<empty>,,,,1,,ANY
314904,BLOCK,1,,<empty>,,,,1,,ANY
314908,BLOCK,1,,<empty>,,,,1,,ANY
314911,BLOCK,1,,<empty>,,,,1,,ANY
314920,BLOCK,1,,<empty>,,,,1,,ANY
314924,BLOCK,1,,<empty>,,,,1,,ANY
314927,BLOCK,1,,<empty>,,,,1,,ANY
314934,BLOCK,1,,<empty>,,,,1,,ANY
314940,BLOCK,1,,<empty>,,,,1,,ANY
314946,BLOCK,1,,<empty>,,,,1,,ANY
314952,BLOCK,1,,<empty>,,,,1,,ANY
314957,BLOCK,1,,<empty>,,,,1,,ANY
314962,BLOCK,1,,<empty>,,,,1,,ANY
314967,BLOCK,1,,<empty>,,,,1,,ANY
314972,BLOCK,1,,<empty>,,,,1,,ANY
314977,BLOCK,1,,<empty>,,,,1,,ANY
314982,BLOCK,1,,<empty>,,,,1,,ANY
314987,BLOCK,1,,<empty>,,,,1,,ANY
314992,BLOCK,1,,<empty>,,,,1,,ANY
314997,BLOCK,1,,<empty>,,,,1,,ANY
315002,BLOCK,1,,<empty>,,,,1,,ANY
315010,BLOCK,1,,<empty>,,,,1,,ANY
315016,BLOCK,1,,<empty>,,,,1,,ANY
315021,BLOCK,1,,<empty>,,,,1,,ANY
315029,BLOCK,1,,<empty>,,,,1,,ANY
315037,BLOCK,1,,<empty>,,,,1,,ANY
315040,BLOCK,1,,<empty>,,,,1,,ANY
315044,BLOCK,1,,<empty>,,,,1,,ANY
315048,BLOCK,1,,<empty>,,,,1,,ANY
315052,BLOCK,1,,<empty>,,,,1,,ANY
315056,BLOCK,1,,<empty>,,,,1,,ANY
315060,BLOCK,1,,<empty>,,,,1,,ANY
315066,BLOCK,1,,<empty>,,,,1,,ANY
315073,BLOCK,1,,<empty>,,,,1,,ANY
315077,BLOCK,1,,<empty>,,,,1,,ANY
315081,BLOCK,1,,<empty>,,,,1,,ANY
315085,BLOCK,1,,<empty>,,,,1,,ANY
315089,BLOCK,1,,<empty>,,,,1,,ANY
315093,BLOCK,1,,<empty>,,,,1,,ANY
315096,BLOCK,1,,<empty>,,,,1,,ANY
315103,BLOCK,1,,<empty>,,,,1,,ANY
315109,BLOCK,1,,<empty>,,,,1,,ANY
315116,BLOCK,1,,<empty>,,,,1,,ANY
315121,BLOCK,1,,<empty>,,,,1,,ANY
315125,BLOCK,1,,<empty>,,,,1,,ANY
315129,BLOCK,1,,<empty>,,,,1,,ANY
315133,BLOCK,1,,<empty>,,,,1,,ANY
315137,BLOCK,1,,<empty>,,,,1,,ANY
315141,BLOCK,1,,<empty>,,,,1,,ANY
315146,BLOCK,1,,<empty>,,,,1,,ANY
315150,BLOCK,1,,<empty>,,,,1,,ANY
315154,BLOCK,1,,<empty>,,,,1,,ANY
315160,BLOCK,1,,<empty>,,,,1,,ANY
315166,BLOCK,1,,<empty>,,,,1,,ANY
315172,BLOCK,1,,<empty>,,,,1,,ANY
315177,BLOCK,1,,<empty>,,,,1,,ANY
315182,BLOCK,1,,<empty>,,,,1,,ANY
315187,BLOCK,1,,<empty>,,,,1,,ANY
315192,BLOCK,1,,<empty>,,,,1,,ANY
315196,BLOCK,1,,<empty>,,,,1,,ANY
315209,BLOCK,1,,<empty>,,,,1,,ANY
315213,BLOCK,1,,<empty>,,,,1,,ANY
315219,BLOCK,1,,<empty>,,,,1,,ANY
315223,BLOCK,1,,<empty>,,,,1,,ANY
315228,BLOCK,1,,<empty>,,,,1,,ANY
315232,BLOCK,1,,<empty>,,,,1,,ANY
315236,BLOCK,1,,<empty>,,,,1,,ANY
315240,BLOCK,1,,<empty>,,,,1,,ANY
315247,BLOCK,1,,<empty>,,,,1,,ANY
315252,BLOCK,1,,<empty>,,,,1,,ANY
315260,BLOCK,1,,<empty>,,,,1,,ANY
315264,BLOCK,1,,<empty>,,,,1,,ANY
315268,BLOCK,1,,<empty>,,,,1,,ANY
315274,BLOCK,1,,<empty>,,,,1,,ANY
315278,BLOCK,1,,<empty>,,,,1,,ANY
315282,BLOCK,1,,<empty>,,,,1,,ANY
315286,BLOCK,1,,<empty>,,,,1,,ANY
315293,BLOCK,1,,<empty>,,,,1,,ANY
315297,BLOCK,1,,<empty>,,,,1,,ANY
315300,BLOCK,1,,<empty>,,,,1,,ANY
315306,BLOCK,1,,<empty>,,,,1,,ANY
315311,BLOCK,1,,<empty>,,,,1,,ANY
315314,BLOCK,1,,<empty>,,,,1,,ANY
315320,BLOCK,1,,<empty>,,,,1,,ANY
315325,BLOCK,1,,<empty>,,,,1,,ANY
315330,BLOCK,1,,<empty>,,,,1,,ANY
315335,BLOCK,1,,<empty>,,,,1,,ANY
315339,BLOCK,1,,<empty>,,,,1,,ANY
315347,BLOCK,1,,<empty>,,,,1,,ANY
315353,BLOCK,1,,<empty>,,,,1,,ANY
315357,BLOCK,1,,<empty>,,,,1,,ANY
315361,BLOCK,1,,<empty>,,,,1,,ANY
315369,BLOCK,1,,<empty>,,,,1,,ANY
315374,BLOCK,1,,<empty>,,,,1,,ANY
315378,BLOCK,1,,<empty>,,,,1,,ANY
315386,BLOCK,1,,<empty>,,,,1,,ANY
315390,BLOCK,1,,<empty>,,,,1,,ANY
315395,BLOCK,1,,<empty>,,,,1,,ANY
315404,BLOCK,1,,<empty>,,,,1,,ANY
315408,BLOCK,1,,<empty>,,,,1,,ANY
315413,BLOCK,1,,<empty>,,,,1,,ANY
315418,BLOCK,1,,<empty>,,,,1,,ANY
315426,BLOCK,1,,<empty>,,,,1,,ANY
315434,BLOCK,1,,<empty>,,,,1,,ANY
315438,BLOCK,1,,<empty>,,,,1,,ANY
315446,BLOCK,1,,<empty>,,,,1,,ANY
315452,BLOCK,1,,<empty>,,,,1,,ANY
315458,BLOCK,1,,<empty>,,,,1,,ANY
315466,BLOCK,1,,<empty>,,,,1,,ANY
315470,BLOCK,1,,<empty>,,,,1,,ANY
315475,BLOCK,1,,<empty>,,,,1,,ANY
315479,BLOCK,1,,<empty>,,,,1,,ANY
315484,BLOCK,1,,<empty>,,,,1,,ANY
315488,BLOCK,1,,<empty>,,,,1,,ANY
315492,BLOCK,1,,<empty>,,,,1,,ANY
315496,BLOCK,1,,<empty>,,,,1,,ANY
315500,BLOCK,1,,<empty>,,,,1,,ANY
315508,BLOCK,1,,<empty>,,,,1,,ANY
315513,BLOCK,1,,<empty>,,,,1,,ANY
315517,BLOCK,1,,<empty>,,,,1,,ANY
315521,BLOCK,1,,<empty>,,,,1,,ANY
315525,BLOCK,1,,<empty>,,,,1,,ANY
315531,BLOCK,1,,<empty>,,,,1,,ANY
315536,BLOCK,1,,<empty>,,,,1,,ANY
315542,BLOCK,1,,<empty>,,,,1,,ANY
315546,BLOCK,1,,<empty>,,,,1,,ANY
315551,BLOCK,1,,<empty>,,,,1,,ANY
315561,BLOCK,1,,<empty>,,,,1,,ANY
315565,BLOCK,1,,<empty>,,,,1,,ANY
315569,BLOCK,1,,<empty>,,,,1,,ANY
315574,BLOCK,1,,<empty>,,,,1,,ANY
315579,BLOCK,1,,<empty>,,,,1,,ANY
315583,BLOCK,1,,<empty>,,,,1,,ANY
315587,BLOCK,1,,<empty>,,,,1,,ANY
315591,BLOCK,1,,<empty>,,,,1,,ANY
315595,BLOCK,1,,<empty>,,,,1,,ANY
315599,BLOCK,1,,<empty>,,,,1,,ANY
315603,BLOCK,1,,<empty>,,,,1,,ANY
315607,BLOCK,1,,<empty>,,,,1,,ANY
315611,BLOCK,1,,<empty>,,,,1,,ANY
315615,BLOCK,1,,<empty>,,,,1,,ANY
315619,BLOCK,1,,<empty>,,,,1,,ANY
315624,BLOCK,1,,<empty>,,,,1,,ANY
315629,BLOCK,1,,<empty>,,,,1,,ANY
315633,BLOCK,1,,<empty>,,,,1,,ANY
315638,BLOCK,1,,<empty>,,,,1,,ANY
315642,BLOCK,1,,<empty>,,,,1,,ANY
315646,BLOCK,1,,<empty>,,,,1,,ANY
315650,BLOCK,1,,<empty>,,,,1,,ANY
315654,BLOCK,1,,<empty>,,,,1,,ANY
315658,BLOCK,1,,<empty>,,,,1,,ANY
315662,BLOCK,1,,<empty>,,,,1,,ANY
315666,BLOCK,1,,<empty>,,,,1,,ANY
315670,BLOCK,1,,<empty>,,,,1,,ANY
315674,BLOCK,1,,<empty>,,,,1,,ANY
315678,BLOCK,1,,<empty>,,,,1,,ANY
315687,BLOCK,1,,<empty>,,,,1,,ANY
315691,BLOCK,1,,<empty>,,,,1,,ANY
315697,BLOCK,1,,<empty>,,,,1,,ANY
315701,BLOCK,1,,<empty>,,,,1,,ANY
315705,BLOCK,1,,<empty>,,,,1,,ANY
315708,BLOCK,1,,<empty>,,,,1,,ANY
315712,BLOCK,1,,<empty>,,,,1,,ANY
315718,BLOCK,1,,<empty>,,,,1,,ANY
315722,BLOCK,1,,<empty>,,,,1,,ANY
315727,BLOCK,1,,<empty>,,,,1,,ANY
315732,BLOCK,1,,<empty>,,,,1,,ANY
315737,BLOCK,1,,<empty>,,,,1,,ANY
315741,BLOCK,1,,<empty>,,,,1,,ANY
315746,BLOCK,1,,<empty>,,,,1,,ANY
315751,BLOCK,1,,<empty>,,,,1,,ANY
315756,BLOCK,1,,<empty>,,,,1,,ANY
315759,BLOCK,1,,<empty>,,,,1,,ANY
315765,BLOCK,1,,<empty>,,,,1,,ANY
315769,BLOCK,1,,<empty>,,,,1,,ANY
315772,BLOCK,1,,<empty>,,,,1,,ANY
315777,BLOCK,1,,<empty>,,,,1,,ANY
315781,BLOCK,1,,<empty>,,,,1,,ANY
315786,BLOCK,1,,<empty>,,,,1,,ANY
315792,BLOCK,1,,<empty>,,,,1,,ANY
315798,BLOCK,1,,<empty>,,,,1,,ANY
315803,BLOCK,1,,<empty>,,,,1,,ANY
315808,BLOCK,1,,<empty>,,,,1,,ANY
315813,BLOCK,1,,<empty>,,,,1,,ANY
315818,BLOCK,1,,<empty>,,,,1,,ANY
315822,BLOCK,1,,<empty>,,,,1,,ANY
315828,BLOCK,1,,<empty>,,,,1,,ANY
315832,BLOCK,1,,<empty>,,,,1,,ANY
315837,BLOCK,1,,<empty>,,,,1,,ANY
315841,BLOCK,1,,<empty>,,,,1,,ANY
315846,BLOCK,1,,<empty>,,,,1,,ANY
315850,BLOCK,1,,<empty>,,,,1,,ANY
315854,BLOCK,1,,<empty>,,,,1,,ANY
315858,BLOCK,1,,<empty>,,,,1,,ANY
315861,BLOCK,1,,<empty>,,,,1,,ANY
315866,BLOCK,1,,<empty>,,,,1,,ANY
315872,BLOCK,1,,<empty>,,,,1,,ANY
315875,BLOCK,1,,<empty>,,,,1,,ANY
315878,BLOCK,1,,<empty>,,,,1,,ANY
315882,BLOCK,1,,<empty>,,,,1,,ANY
315886,BLOCK,1,,<empty>,,,,1,,ANY
315890,BLOCK,1,,<empty>,,,,1,,ANY
315894,BLOCK,1,,<empty>,,,,1,,ANY
315898,BLOCK,1,,<empty>,,,,1,,ANY
315901,BLOCK,1,,<empty>,,,,1,,ANY
315905,BLOCK,1,,<empty>,,,,1,,ANY
315909,BLOCK,1,,<empty>,,,,1,,ANY
315916,BLOCK,1,,<empty>,,,,1,,ANY
315921,BLOCK,1,,<empty>,,,,1,,ANY
315924,BLOCK,1,,<empty>,,,,1,,ANY
315927,BLOCK,1,,<empty>,,,,1,,ANY
315933,BLOCK,1,,<empty>,,,,1,,ANY
315937,BLOCK,1,,<empty>,,,,1,,ANY
315942,BLOCK,1,,<empty>,,,,1,,ANY
315947,BLOCK,1,,<empty>,,,,1,,ANY
315950,BLOCK,1,,<empty>,,,,1,,ANY
315954,BLOCK,1,,<empty>,,,,1,,ANY
315958,BLOCK,1,,<empty>,,,,1,,ANY
315962,BLOCK,1,,<empty>,,,,1,,ANY
315966,BLOCK,1,,<empty>,,,,1,,ANY
315970,BLOCK,1,,<empty>,,,,1,,ANY
315974,BLOCK,1,,<empty>,,,,1,,ANY
315978,BLOCK,1,,<empty>,,,,1,,ANY
315983,BLOCK,1,,<empty>,,,,1,,ANY
315989,BLOCK,1,,<empty>,,,,1,,ANY
315994,BLOCK,1,,<empty>,,,,1,,ANY
315997,BLOCK,1,,<empty>,,,,1,,ANY
316001,BLOCK,1,,<empty>,,,,1,,ANY
316005,BLOCK,1,,<empty>,,,,1,,ANY
316009,BLOCK,1,,<empty>,,,,1,,ANY
316013,BLOCK,1,,<empty>,,,,1,,ANY
316017,BLOCK,1,,<empty>,,,,1,,ANY
316020,BLOCK,1,,<empty>,,,,1,,ANY
316025,BLOCK,1,,<empty>,,,,1,,ANY
316030,BLOCK,1,,<empty>,,,,1,,ANY
316035,BLOCK,1,,<empty>,,,,1,,ANY
316040,BLOCK,1,,<empty>,,,,1,,ANY
316044,BLOCK,1,,<empty>,,,,1,,ANY
316048,BLOCK,1,,<empty>,,,,1,,ANY
316052,BLOCK,1,,<empty>,,,,1,,ANY
316056,BLOCK,1,,<empty>,,,,1,,ANY
316060,BLOCK,1,,<empty>,,,,1,,ANY
316065,BLOCK,1,,<empty>,,,,1,,ANY
316070,BLOCK,1,,<empty>,,,,1,,ANY
316075,BLOCK,1,,<empty>,,,,1,,ANY
316080,BLOCK,1,,<empty>,,,,1,,ANY
316085,BLOCK,1,,<empty>,,,,1,,ANY
316091,BLOCK,1,,<empty>,,,,1,,ANY
316097,BLOCK,1,,<empty>,,,,1,,ANY
316102,BLOCK,1,,<empty>,,,,1,,ANY
316106,BLOCK,1,,<empty>,,,,1,,ANY
316110,BLOCK,1,,<empty>,,,,1,,ANY
316115,BLOCK,1,,<empty>,,,,1,,ANY
316120,BLOCK,1,,<empty>,,,,1,,ANY
316125,BLOCK,1,,<empty>,,,,1,,ANY
316129,BLOCK,1,,<empty>,,,,1,,ANY
316133,BLOCK,1,,<empty>,,,,1,,ANY
316138,BLOCK,1,,<empty>,,,,1,,ANY
316143,BLOCK,1,,<empty>,,,,1,,ANY
316148,BLOCK,1,,<empty>,,,,1,,ANY
316153,BLOCK,1,,<empty>,,,,1,,ANY
316158,BLOCK,1,,<empty>,,,,1,,ANY
316163,BLOCK,1,,<empty>,,,,1,,ANY
316166,BLOCK,1,,<empty>,,,,1,,ANY
316171,BLOCK,1,,<empty>,,,,1,,ANY
316175,BLOCK,1,,<empty>,,,,1,,ANY
316179,BLOCK,1,,<empty>,,,,1,,ANY
316183,BLOCK,1,,<empty>,,,,1,,ANY
316187,BLOCK,1,,<empty>,,,,1,,ANY
316192,BLOCK,1,,<empty>,,,,1,,ANY
316197,BLOCK,1,,<empty>,,,,1,,ANY
316201,BLOCK,1,,<empty>,,,,1,,ANY
316206,BLOCK,1,,<empty>,,,,1,,ANY
316211,BLOCK,1,,<empty>,,,,1,,ANY
316215,BLOCK,1,,<empty>,,,,1,,ANY
316221,BLOCK,1,,<empty>,,,,1,,ANY
316227,BLOCK,1,,<empty>,,,,1,,ANY
316234,BLOCK,1,,<empty>,,,,1,,ANY
316241,BLOCK,1,,<empty>,,,,1,,ANY
316246,BLOCK,1,,<empty>,,,,1,,ANY
316252,BLOCK,1,,<empty>,,,,1,,ANY
316258,BLOCK,1,,<empty>,,,,1,,ANY
316264,BLOCK,1,,<empty>,,,,1,,ANY
316268,BLOCK,1,,<empty>,,,,1,,ANY
316273,BLOCK,1,,<empty>,,,,1,,ANY
316278,BLOCK,1,,<empty>,,,,1,,ANY
316283,BLOCK,1,,<empty>,,,,1,,ANY
316288,BLOCK,1,,<empty>,,,,1,,ANY
316298,BLOCK,1,,<empty>,,,,1,,ANY
316302,BLOCK,1,,<empty>,,,,1,,ANY
316307,BLOCK,1,,<empty>,,,,1,,ANY
316312,BLOCK,1,,<empty>,,,,1,,ANY
316323,BLOCK,1,,<empty>,,,,1,,ANY
316327,BLOCK,1,,<empty>,,,,1,,ANY
316333,BLOCK,1,,<empty>,,,,1,,ANY
316337,BLOCK,1,,<empty>,,,,1,,ANY
316342,BLOCK,1,,<empty>,,,,1,,ANY
316347,BLOCK,1,,<empty>,,,,1,,ANY
316351,BLOCK,1,,<empty>,,,,1,,ANY
316357,BLOCK,1,,<empty>,,,,1,,ANY
316361,BLOCK,1,,<empty>,,,,1,,ANY
316365,BLOCK,1,,<empty>,,,,1,,ANY
316369,BLOCK,1,,<empty>,,,,1,,ANY
316377,BLOCK,1,,<empty>,,,,1,,ANY
316381,BLOCK,1,,<empty>,,,,1,,ANY
316387,BLOCK,1,,<empty>,,,,1,,ANY
316392,BLOCK,1,,<empty>,,,,1,,ANY
316397,BLOCK,1,,<empty>,,,,1,,ANY
316400,BLOCK,1,,<empty>,,,,1,,ANY
316405,BLOCK,1,,<empty>,,,,1,,ANY
316408,BLOCK,1,,<empty>,,,,1,,ANY
316412,BLOCK,1,,<empty>,,,,1,,ANY
316417,BLOCK,1,,<empty>,,,,1,,ANY
316421,BLOCK,1,,<empty>,,,,1,,ANY
316424,BLOCK,1,,<empty>,,,,1,,ANY
316429,BLOCK,1,,<empty>,,,,1,,ANY
316434,BLOCK,1,,<empty>,,,,1,,ANY
316438,BLOCK,1,,<empty>,,,,1,,ANY
316443,BLOCK,1,,<empty>,,,,1,,ANY
316446,BLOCK,1,,<empty>,,,,1,,ANY
316449,BLOCK,1,,<empty>,,,,1,,ANY
316453,BLOCK,1,,<empty>,,,,1,,ANY
316458,BLOCK,1,,<empty>,,,,1,,ANY
316464,BLOCK,1,,<empty>,,,,1,,ANY
316469,BLOCK,1,,<empty>,,,,1,,ANY
316474,BLOCK,1,,<empty>,,,,1,,ANY
316478,BLOCK,1,,<empty>,,,,1,,ANY
316482,BLOCK,1,,<empty>,,,,1,,ANY
316487,BLOCK,1,,<empty>,,,,1,,ANY
316491,BLOCK,1,,<empty>,,,,1,,ANY
316495,BLOCK,1,,<empty>,,,,1,,ANY
316498,BLOCK,1,,<empty>,,,,1,,ANY
316503,BLOCK,1,,<empty>,,,,1,,ANY
316509,BLOCK,1,,<empty>,,,,1,,ANY
316514,BLOCK,1,,<empty>,,,,1,,ANY
316523,BLOCK,1,,<empty>,,,,1,,ANY
316528,BLOCK,1,,<empty>,,,,1,,ANY
316533,BLOCK,1,,<empty>,,,,1,,ANY
316538,BLOCK,1,,<empty>,,,,1,,ANY
316541,BLOCK,1,,<empty>,,,,1,,ANY
316548,BLOCK,1,,<empty>,,,,1,,ANY
316552,BLOCK,1,,<empty>,,,,1,,ANY
316559,BLOCK,1,,<empty>,,,,1,,ANY
316563,BLOCK,1,,<empty>,,,,1,,ANY
316567,BLOCK,1,,<empty>,,,,1,,ANY
316571,BLOCK,1,,<empty>,,,,1,,ANY
316578,BLOCK,1,,<empty>,,,,1,,ANY
316583,BLOCK,1,,<empty>,,,,1,,ANY
316588,BLOCK,1,,<empty>,,,,1,,ANY
316595,BLOCK,1,,<empty>,,,,1,,ANY
316600,BLOCK,1,,<empty>,,,,1,,ANY
316606,BLOCK,1,,<empty>,,,,1,,ANY
316610,BLOCK,1,,<empty>,,,,1,,ANY
316614,BLOCK,1,,<empty>,,,,1,,ANY
316621,BLOCK,1,,<empty>,,,,1,,ANY
316624,BLOCK,1,,<empty>,,,,1,,ANY
316630,BLOCK,1,,<empty>,,,,1,,ANY
316633,BLOCK,1,,<empty>,,,,1,,ANY
316641,BLOCK,1,,<empty>,,,,1,,ANY
316649,BLOCK,1,,<empty>,,,,1,,ANY
316652,BLOCK,1,,<empty>,,,,1,,ANY
316656,BLOCK,1,,<empty>,,,,1,,ANY
316661,BLOCK,1,,<empty>,,,,1,,ANY
316665,BLOCK,1,,<empty>,,,,1,,ANY
316669,BLOCK,1,,<empty>,,,,1,,ANY
316673,BLOCK,1,,<empty>,,,,1,,ANY
316679,BLOCK,1,,<empty>,,,,1,,ANY
316683,BLOCK,1,,<empty>,,,,1,,ANY
316686,BLOCK,1,,<empty>,,,,1,,ANY
316691,BLOCK,1,,<empty>,,,,1,,ANY
316695,BLOCK,1,,<empty>,,,,1,,ANY
316700,BLOCK,1,,<empty>,,,,1,,ANY
316708,BLOCK,1,,<empty>,,,,1,,ANY
316715,BLOCK,1,,<empty>,,,,1,,ANY
316721,BLOCK,1,,<empty>,,,,1,,ANY
316727,BLOCK,1,,<empty>,,,,1,,ANY
316732,BLOCK,1,,<empty>,,,,1,,ANY
316737,BLOCK,1,,<empty>,,,,1,,ANY
316745,BLOCK,1,,<empty>,,,,1,,ANY
316749,BLOCK,1,,<empty>,,,,1,,ANY
316753,BLOCK,1,,<empty>,,,,1,,ANY
316757,BLOCK,1,,<empty>,,,,1,,ANY
316761,BLOCK,1,,<empty>,,,,1,,ANY
316765,BLOCK,1,,<empty>,,,,1,,ANY
316769,BLOCK,1,,<empty>,,,,1,,ANY
316773,BLOCK,1,,<empty>,,,,1,,ANY
316779,BLOCK,1,,<empty>,,,,1,,ANY
316784,BLOCK,1,,<empty>,,,,1,,ANY
316789,BLOCK,1,,<empty>,,,,1,,ANY
316795,BLOCK,1,,<empty>,,,,1,,ANY
316798,BLOCK,1,,<empty>,,,,1,,ANY
316802,BLOCK,1,,<empty>,,,,1,,ANY
316805,BLOCK,1,,<empty>,,,,1,,ANY
316808,BLOCK,1,,<empty>,,,,1,,ANY
316816,BLOCK,1,,<empty>,,,,1,,ANY
316820,BLOCK,1,,<empty>,,,,1,,ANY
316824,BLOCK,1,,<empty>,,,,1,,ANY
316827,BLOCK,1,,<empty>,,,,1,,ANY
316831,BLOCK,1,,<empty>,,,,1,,ANY
316835,BLOCK,1,,<empty>,,,,1,,ANY
316840,BLOCK,1,,<empty>,,,,1,,ANY
316843,BLOCK,1,,<empty>,,,,1,,ANY
316850,BLOCK,1,,<empty>,,,,1,,ANY
316855,BLOCK,1,,<empty>,,,,1,,ANY
316862,BLOCK,1,,<empty>,,,,1,,ANY
316867,BLOCK,1,,<empty>,,,,1,,ANY
316876,BLOCK,1,,<empty>,,,,1,,ANY
316882,BLOCK,1,,<empty>,,,,1,,ANY
316889,BLOCK,1,,<empty>,,,,1,,ANY
316898,BLOCK,1,,<empty>,,,,1,,ANY
316901,BLOCK,1,,<empty>,,,,1,,ANY
316906,BLOCK,1,,<empty>,,,,1,,ANY
316911,BLOCK,1,,<empty>,,,,1,,ANY
316914,BLOCK,1,,<empty>,,,,1,,ANY
316919,BLOCK,1,,<empty>,,,,1,,ANY
316927,BLOCK,1,,<empty>,,,,1,,ANY
316933,BLOCK,1,,<empty>,,,,1,,ANY
316937,BLOCK,1,,<empty>,,,,1,,ANY
316944,BLOCK,1,,<empty>,,,,1,,ANY
316948,BLOCK,1,,<empty>,,,,1,,ANY
316952,BLOCK,1,,<empty>,,,,1,,ANY
316956,BLOCK,1,,<empty>,,,,1,,ANY
316960,BLOCK,1,,<empty>,,,,1,,ANY
316966,BLOCK,1,,<empty>,,,,1,,ANY
316972,BLOCK,1,,<empty>,,,,1,,ANY
316976,BLOCK,1,,<empty>,,,,1,,ANY
316980,BLOCK,1,,<empty>,,,,1,,ANY
316985,BLOCK,1,,<empty>,,,,1,,ANY
316990,BLOCK,1,,<empty>,,,,1,,ANY
316997,BLOCK,1,,<empty>,,,,1,,ANY
317003,BLOCK,1,,<empty>,,,,1,,ANY
317007,BLOCK,1,,<empty>,,,,1,,ANY
317013,BLOCK,1,,<empty>,,,,1,,ANY
317016,BLOCK,1,,<empty>,,,,1,,ANY
317022,BLOCK,1,,<empty>,,,,1,,ANY
317026,BLOCK,1,,<empty>,,,,1,,ANY
317033,BLOCK,1,,<empty>,,,,1,,ANY
317036,BLOCK,1,,<empty>,,,,1,,ANY
317039,BLOCK,1,,<empty>,,,,1,,ANY
317046,BLOCK,1,,<empty>,,,,1,,ANY
317053,BLOCK,1,,<empty>,,,,1,,ANY
317057,BLOCK,1,,<empty>,,,,1,,ANY
317063,BLOCK,1,,<empty>,,,,1,,ANY
317067,BLOCK,1,,<empty>,,,,1,,ANY
317071,BLOCK,1,,<empty>,,,,1,,ANY
317077,BLOCK,1,,<empty>,,,,1,,ANY
317084,BLOCK,1,,<empty>,,,,1,,ANY
317088,BLOCK,1,,<empty>,,,,1,,ANY
317092,BLOCK,1,,<empty>,,,,1,,ANY
317098,BLOCK,1,,<empty>,,,,1,,ANY
317102,BLOCK,1,,<empty>,,,,1,,ANY
317107,BLOCK,1,,<empty>,,,,1,,ANY
317113,BLOCK,1,,<empty>,,,,1,,ANY
317116,BLOCK,1,,<empty>,,,,1,,ANY
317121,BLOCK,1,,<empty>,,,,1,,ANY
317124,BLOCK,1,,<empty>,,,,1,,ANY
317130,BLOCK,1,,<empty>,,,,1,,ANY
317135,BLOCK,1,,<empty>,,,,1,,ANY
317139,BLOCK,1,,<empty>,,,,1,,ANY
317143,BLOCK,1,,<empty>,,,,1,,ANY
317147,BLOCK,1,,<empty>,,,,1,,ANY
317151,BLOCK,1,,<empty>,,,,1,,ANY
317157,BLOCK,1,,<empty>,,,,1,,ANY
317163,BLOCK,1,,<empty>,,,,1,,ANY
317169,BLOCK,1,,<empty>,,,,1,,ANY
317174,BLOCK,1,,<empty>,,,,1,,ANY
317178,BLOCK,1,,<empty>,,,,1,,ANY
317182,BLOCK,1,,<empty>,,,,1,,ANY
317186,BLOCK,1,,<empty>,,,,1,,ANY
317192,BLOCK,1,,<empty>,,,,1,,ANY
317197,BLOCK,1,,<empty>,,,,1,,ANY
317202,BLOCK,1,,<empty>,,,,1,,ANY
317206,BLOCK,1,,<empty>,,,,1,,ANY
317214,BLOCK,1,,<empty>,,,,1,,ANY
317220,BLOCK,1,,<empty>,,,,1,,ANY
317223,BLOCK,1,,<empty>,,,,1,,ANY
317227,BLOCK,1,,<empty>,,,,1,,ANY
317231,BLOCK,1,,<empty>,,,,1,,ANY
317235,BLOCK,1,,<empty>,,,,1,,ANY
317238,BLOCK,1,,<empty>,,,,1,,ANY
317243,BLOCK,1,,<empty>,,,,1,,ANY
317250,BLOCK,1,,<empty>,,,,1,,ANY
317254,BLOCK,1,,<empty>,,,,1,,ANY
317260,BLOCK,1,,<empty>,,,,1,,ANY
317264,BLOCK,1,,<empty>,,,,1,,ANY
317269,BLOCK,1,,<empty>,,,,1,,ANY
317274,BLOCK,1,,<empty>,,,,1,,ANY
317279,BLOCK,1,,<empty>,,,,1,,ANY
317282,BLOCK,1,,<empty>,,,,1,,ANY
317287,BLOCK,1,,<empty>,,,,1,,ANY
317291,BLOCK,1,,<empty>,,,,1,,ANY
317295,BLOCK,1,,<empty>,,,,1,,ANY
317301,BLOCK,1,,<empty>,,,,1,,ANY
317305,BLOCK,1,,<empty>,,,,1,,ANY
317310,BLOCK,1,,<empty>,,,,1,,ANY
317315,BLOCK,1,,<empty>,,,,1,,ANY
317319,BLOCK,1,,<empty>,,,,1,,ANY
317323,BLOCK,1,,<empty>,,,,1,,ANY
317327,BLOCK,1,,<empty>,,,,1,,ANY
317332,BLOCK,1,,<empty>,,,,1,,ANY
317337,BLOCK,1,,<empty>,,,,1,,ANY
317341,BLOCK,1,,<empty>,,,,1,,ANY
317345,BLOCK,1,,<empty>,,,,1,,ANY
317353,BLOCK,1,,<empty>,,,,1,,ANY
317358,BLOCK,1,,<empty>,,,,1,,ANY
317362,BLOCK,1,,<empty>,,,,1,,ANY
317367,BLOCK,1,,<empty>,,,,1,,ANY
317371,BLOCK,1,,<empty>,,,,1,,ANY
317376,BLOCK,1,,<empty>,,,,1,,ANY
317381,BLOCK,1,,<empty>,,,,1,,ANY
317385,BLOCK,1,,<empty>,,,,1,,ANY
317389,BLOCK,1,,<empty>,,,,1,,ANY
317393,BLOCK,1,,<empty>,,,,1,,ANY
317396,BLOCK,1,,<empty>,,,,1,,ANY
317399,BLOCK,1,,<empty>,,,,1,,ANY
317404,BLOCK,1,,<empty>,,,,1,,ANY
317409,BLOCK,1,,<empty>,,,,1,,ANY
317414,BLOCK,1,,<empty>,,,,1,,ANY
317418,BLOCK,1,,<empty>,,,,1,,ANY
317423,BLOCK,1,,<empty>,,,,1,,ANY
317427,BLOCK,1,,<empty>,,,,1,,ANY
317431,BLOCK,1,,<empty>,,,,1,,ANY
317439,BLOCK,1,,<empty>,,,,1,,ANY
317443,BLOCK,1,,<empty>,,,,1,,ANY
317449,BLOCK,1,,<empty>,,,,1,,ANY
317453,BLOCK,1,,<empty>,,,,1,,ANY
317457,BLOCK,1,,<empty>,,,,1,,ANY
317461,BLOCK,1,,<empty>,,,,1,,ANY
317467,BLOCK,1,,<empty>,,,,1,,ANY
317472,BLOCK,1,,<empty>,,,,1,,ANY
317477,BLOCK,1,,<empty>,,,,1,,ANY
317483,BLOCK,1,,<empty>,,,,1,,ANY
317487,BLOCK,1,,<empty>,,,,1,,ANY
317492,BLOCK,1,,<empty>,,,,1,,ANY
317498,BLOCK,1,,<empty>,,,,1,,ANY
317503,BLOCK,1,,<empty>,,,,1,,ANY
317506,BLOCK,1,,<empty>,,,,1,,ANY
317511,BLOCK,1,,<empty>,,,,1,,ANY
317514,BLOCK,1,,<empty>,,,,1,,ANY
317519,BLOCK,1,,<empty>,,,,1,,ANY
317524,BLOCK,1,,<empty>,,,,1,,ANY
317530,BLOCK,1,,<empty>,,,,1,,ANY
317533,BLOCK,1,,<empty>,,,,1,,ANY
317536,BLOCK,1,,<empty>,,,,1,,ANY
317540,BLOCK,1,,<empty>,,,,1,,ANY
317546,BLOCK,1,,<empty>,,,,1,,ANY
317550,BLOCK,1,,<empty>,,,,1,,ANY
317554,BLOCK,1,,<empty>,,,,1,,ANY
317559,BLOCK,1,,<empty>,,,,1,,ANY
317564,BLOCK,1,,<empty>,,,,1,,ANY
317567,BLOCK,1,,<empty>,,,,1,,ANY
317572,BLOCK,1,,<empty>,,,,1,,ANY
317579,BLOCK,1,,<empty>,,,,1,,ANY
317582,BLOCK,1,,<empty>,,,,1,,ANY
317586,BLOCK,1,,<empty>,,,,1,,ANY
317591,BLOCK,1,,<empty>,,,,1,,ANY
317595,BLOCK,1,,<empty>,,,,1,,ANY
317598,BLOCK,1,,<empty>,,,,1,,ANY
317601,BLOCK,1,,<empty>,,,,1,,ANY
317605,BLOCK,1,,<empty>,,,,1,,ANY
317610,BLOCK,1,,<empty>,,,,1,,ANY
317614,BLOCK,1,,<empty>,,,,1,,ANY
317619,BLOCK,1,,<empty>,,,,1,,ANY
317626,BLOCK,1,,<empty>,,,,1,,ANY
317630,BLOCK,1,,<empty>,,,,1,,ANY
317635,BLOCK,1,,<empty>,,,,1,,ANY
317639,BLOCK,1,,<empty>,,,,1,,ANY
317643,BLOCK,1,,<empty>,,,,1,,ANY
317648,BLOCK,1,,<empty>,,,,1,,ANY
317654,BLOCK,1,,<empty>,,,,1,,ANY
317659,BLOCK,1,,<empty>,,,,1,,ANY
317663,BLOCK,1,,<empty>,,,,1,,ANY
317667,BLOCK,1,,<empty>,,,,1,,ANY
317671,BLOCK,1,,<empty>,,,,1,,ANY
317674,BLOCK,1,,<empty>,,,,1,,ANY
317679,BLOCK,1,,<empty>,,,,1,,ANY
317684,BLOCK,1,,<empty>,,,,1,,ANY
317688,BLOCK,1,,<empty>,,,,1,,ANY
317692,BLOCK,1,,<empty>,,,,1,,ANY
317697,BLOCK,1,,<empty>,,,,1,,ANY
317701,BLOCK,1,,<empty>,,,,1,,ANY
317705,BLOCK,1,,<empty>,,,,1,,ANY
317709,BLOCK,1,,<empty>,,,,1,,ANY
317713,BLOCK,1,,<empty>,,,,1,,ANY
317717,BLOCK,1,,<empty>,,,,1,,ANY
317720,BLOCK,1,,<empty>,,,,1,,ANY
317725,BLOCK,1,,<empty>,,,,1,,ANY
317729,BLOCK,1,,<empty>,,,,1,,ANY
317734,BLOCK,1,,<empty>,,,,1,,ANY
317738,BLOCK,1,,<empty>,,,,1,,ANY
317742,BLOCK,1,,<empty>,,,,1,,ANY
317745,BLOCK,1,,<empty>,,,,1,,ANY
317749,BLOCK,1,,<empty>,,,,1,,ANY
317753,BLOCK,1,,<empty>,,,,1,,ANY
317756,BLOCK,1,,<empty>,,,,1,,ANY
317759,BLOCK,1,,<empty>,,,,1,,ANY
317763,BLOCK,1,,<empty>,,,,1,,ANY
317768,BLOCK,1,,<empty>,,,,1,,ANY
317773,BLOCK,1,,<empty>,,,,1,,ANY
317777,BLOCK,1,,<empty>,,,,1,,ANY
317783,BLOCK,1,,<empty>,,,,1,,ANY
317787,BLOCK,1,,<empty>,,,,1,,ANY
317791,BLOCK,1,,<empty>,,,,1,,ANY
317794,BLOCK,1,,<empty>,,,,1,,ANY
317798,BLOCK,1,,<empty>,,,,1,,ANY
317805,BLOCK,1,,<empty>,,,,1,,ANY
317810,BLOCK,1,,<empty>,,,,1,,ANY
317815,BLOCK,1,,<empty>,,,,1,,ANY
317819,BLOCK,1,,<empty>,,,,1,,ANY
317822,BLOCK,1,,<empty>,,,,1,,ANY
317825,BLOCK,1,,<empty>,,,,1,,ANY
317830,BLOCK,1,,<empty>,,,,1,,ANY
317834,BLOCK,1,,<empty>,,,,1,,ANY
317840,BLOCK,1,,<empty>,,,,1,,ANY
317845,BLOCK,1,,<empty>,,,,1,,ANY
317852,BLOCK,1,,<empty>,,,,1,,ANY
317856,BLOCK,1,,<empty>,,,,1,,ANY
317861,BLOCK,1,,<empty>,,,,1,,ANY
317865,BLOCK,1,,<empty>,,,,1,,ANY
317869,BLOCK,1,,<empty>,,,,1,,ANY
317873,BLOCK,1,,<empty>,,,,1,,ANY
317877,BLOCK,1,,<empty>,,,,1,,ANY
317881,BLOCK,1,,<empty>,,,,1,,ANY
317886,BLOCK,1,,<empty>,,,,1,,ANY
317890,BLOCK,1,,<empty>,,,,1,,ANY
317894,BLOCK,1,,<empty>,,,,1,,ANY
317899,BLOCK,1,,<empty>,,,,1,,ANY
317904,BLOCK,1,,<empty>,,,,1,,ANY
317908,BLOCK,1,,<empty>,,,,1,,ANY
317912,BLOCK,1,,<empty>,,,,1,,ANY
317915,BLOCK,1,,<empty>,,,,1,,ANY
317919,BLOCK,1,,<empty>,,,,1,,ANY
317923,BLOCK,1,,<empty>,,,,1,,ANY
317929,BLOCK,1,,<empty>,,,,1,,ANY
317933,BLOCK,1,,<empty>,,,,1,,ANY
317938,BLOCK,1,,<empty>,,,,1,,ANY
317941,BLOCK,1,,<empty>,,,,1,,ANY
317945,BLOCK,1,,<empty>,,,,1,,ANY
317949,BLOCK,1,,<empty>,,,,1,,ANY
317953,BLOCK,1,,<empty>,,,,1,,ANY
317957,BLOCK,1,,<empty>,,,,1,,ANY
317961,BLOCK,1,,<empty>,,,,1,,ANY
317966,BLOCK,1,,<empty>,,,,1,,ANY
317970,BLOCK,1,,<empty>,,,,1,,ANY
317974,BLOCK,1,,<empty>,,,,1,,ANY
317980,BLOCK,1,,<empty>,,,,1,,ANY
317984,BLOCK,1,,<empty>,,,,1,,ANY
317988,BLOCK,1,,<empty>,,,,1,,ANY
317992,BLOCK,1,,<empty>,,,,1,,ANY
317996,BLOCK,1,,<empty>,,,,1,,ANY
318000,BLOCK,1,,<empty>,,,,1,,ANY
318004,BLOCK,1,,<empty>,,,,1,,ANY
318008,BLOCK,1,,<empty>,,,,1,,ANY
318015,BLOCK,1,,<empty>,,,,1,,ANY
318019,BLOCK,1,,<empty>,,,,1,,ANY
318029,BLOCK,1,,<empty>,,,,1,,ANY
318034,BLOCK,1,,<empty>,,,,1,,ANY
318040,BLOCK,1,,<empty>,,,,1,,ANY
318043,BLOCK,1,,<empty>,,,,1,,ANY
318049,BLOCK,1,,<empty>,,,,1,,ANY
318053,BLOCK,1,,<empty>,,,,1,,ANY
318057,BLOCK,1,,<empty>,,,,1,,ANY
318062,BLOCK,1,,<empty>,,,,1,,ANY
318066,BLOCK,1,,<empty>,,,,1,,ANY
318071,BLOCK,1,,<empty>,,,,1,,ANY
318077,BLOCK,1,,<empty>,,,,1,,ANY
318084,BLOCK,1,,<empty>,,,,1,,ANY
318087,BLOCK,1,,<empty>,,,,1,,ANY
318090,BLOCK,1,,<empty>,,,,1,,ANY
318094,BLOCK,1,,<empty>,,,,1,,ANY
318100,BLOCK,1,,<empty>,,,,1,,ANY
318104,BLOCK,1,,<empty>,,,,1,,ANY
318108,BLOCK,1,,<empty>,,,,1,,ANY
318112,BLOCK,1,,<empty>,,,,1,,ANY
318116,BLOCK,1,,<empty>,,,,1,,ANY
318120,BLOCK,1,,<empty>,,,,1,,ANY
318125,BLOCK,1,,<empty>,,,,1,,ANY
318129,BLOCK,1,,<empty>,,,,1,,ANY
318133,BLOCK,1,,<empty>,,,,1,,ANY
318138,BLOCK,1,,<empty>,,,,1,,ANY
318142,BLOCK,1,,<empty>,,,,1,,ANY
318146,BLOCK,1,,<empty>,,,,1,,ANY
318151,BLOCK,1,,<empty>,,,,1,,ANY
318155,BLOCK,1,,<empty>,,,,1,,ANY
318160,BLOCK,1,,<empty>,,,,1,,ANY
318165,BLOCK,1,,<empty>,,,,1,,ANY
318168,BLOCK,1,,<empty>,,,,1,,ANY
318172,BLOCK,1,,<empty>,,,,1,,ANY
318176,BLOCK,1,,<empty>,,,,1,,ANY
318180,BLOCK,1,,<empty>,,,,1,,ANY
318184,BLOCK,1,,<empty>,,,,1,,ANY
318189,BLOCK,1,,<empty>,,,,1,,ANY
318194,BLOCK,1,,<empty>,,,,1,,ANY
318198,BLOCK,1,,<empty>,,,,1,,ANY
318203,BLOCK,1,,<empty>,,,,1,,ANY
318206,BLOCK,1,,<empty>,,,,1,,ANY
318211,BLOCK,1,,<empty>,,,,1,,ANY
318216,BLOCK,1,,<empty>,,,,1,,ANY
318220,BLOCK,1,,<empty>,,,,1,,ANY
318225,BLOCK,1,,<empty>,,,,1,,ANY
318229,BLOCK,1,,<empty>,,,,1,,ANY
318233,BLOCK,1,,<empty>,,,,1,,ANY
318237,BLOCK,1,,<empty>,,,,1,,ANY
318243,BLOCK,1,,<empty>,,,,1,,ANY
318247,BLOCK,1,,<empty>,,,,1,,ANY
318251,BLOCK,1,,<empty>,,,,1,,ANY
318256,BLOCK,1,,<empty>,,,,1,,ANY
318262,BLOCK,1,,<empty>,,,,1,,ANY
318269,BLOCK,1,,<empty>,,,,1,,ANY
318274,BLOCK,1,,<empty>,,,,1,,ANY
318282,BLOCK,1,,<empty>,,,,1,,ANY
318287,BLOCK,1,,<empty>,,,,1,,ANY
318291,BLOCK,1,,<empty>,,,,1,,ANY
318297,BLOCK,1,,<empty>,,,,1,,ANY
318302,BLOCK,1,,<empty>,,,,1,,ANY
318306,BLOCK,1,,<empty>,,,,1,,ANY
318311,BLOCK,1,,<empty>,,,,1,,ANY
318316,BLOCK,1,,<empty>,,,,1,,ANY
318322,BLOCK,1,,<empty>,,,,1,,ANY
318326,BLOCK,1,,<empty>,,,,1,,ANY
318332,BLOCK,1,,<empty>,,,,1,,ANY
318339,BLOCK,1,,<empty>,,,,1,,ANY
318344,BLOCK,1,,<empty>,,,,1,,ANY
318347,BLOCK,1,,<empty>,,,,1,,ANY
318352,BLOCK,1,,<empty>,,,,1,,ANY
318358,BLOCK,1,,<empty>,,,,1,,ANY
318363,BLOCK,1,,<empty>,,,,1,,ANY
318367,BLOCK,1,,<empty>,,,,1,,ANY
318371,BLOCK,1,,<empty>,,,,1,,ANY
318375,BLOCK,1,,<empty>,,,,1,,ANY
318381,BLOCK,1,,<empty>,,,,1,,ANY
318388,BLOCK,1,,<empty>,,,,1,,ANY
318393,BLOCK,1,,<empty>,,,,1,,ANY
318398,BLOCK,1,,<empty>,,,,1,,ANY
318402,BLOCK,1,,<empty>,,,,1,,ANY
318406,BLOCK,1,,<empty>,,,,1,,ANY
318412,BLOCK,1,,<empty>,,,,1,,ANY
318416,BLOCK,1,,<empty>,,,,1,,ANY
318422,BLOCK,1,,<empty>,,,,1,,ANY
318428,BLOCK,1,,<empty>,,,,1,,ANY
318434,BLOCK,1,,<empty>,,,,1,,ANY
318439,BLOCK,1,,<empty>,,,,1,,ANY
318445,BLOCK,1,,<empty>,,,,1,,ANY
318449,BLOCK,1,,<empty>,,,,1,,ANY
318453,BLOCK,1,,<empty>,,,,1,,ANY
318458,BLOCK,1,,<empty>,,,,1,,ANY
318463,BLOCK,1,,<empty>,,,,1,,ANY
318468,BLOCK,1,,<empty>,,,,1,,ANY
318473,BLOCK,1,,<empty>,,,,1,,ANY
318478,BLOCK,1,,<empty>,,,,1,,ANY
318482,BLOCK,1,,<empty>,,,,1,,ANY
318488,BLOCK,1,,<empty>,,,,1,,ANY
318493,BLOCK,1,,<empty>,,,,1,,ANY
318497,BLOCK,1,,<empty>,,,,1,,ANY
318504,BLOCK,1,,<empty>,,,,1,,ANY
318508,BLOCK,1,,<empty>,,,,1,,ANY
318512,BLOCK,1,,<empty>,,,,1,,ANY
318516,BLOCK,1,,<empty>,,,,1,,ANY
318521,BLOCK,1,,<empty>,,,,1,,ANY
318529,BLOCK,1,,<empty>,,,,1,,ANY
318534,BLOCK,1,,<empty>,,,,1,,ANY
318539,BLOCK,1,,<empty>,,,,1,,ANY
318543,BLOCK,1,,<empty>,,,,1,,ANY
318548,BLOCK,1,,<empty>,,,,1,,ANY
318553,BLOCK,1,,<empty>,,,,1,,ANY
318558,BLOCK,1,,<empty>,,,,1,,ANY
318563,BLOCK,1,,<empty>,,,,1,,ANY
318567,BLOCK,1,,<empty>,,,,1,,ANY
318573,BLOCK,1,,<empty>,,,,1,,ANY
318577,BLOCK,1,,<empty>,,,,1,,ANY
318583,BLOCK,1,,<empty>,,,,1,,ANY
318589,BLOCK,1,,<empty>,,,,1,,ANY
318594,BLOCK,1,,<empty>,,,,1,,ANY
318599,BLOCK,1,,<empty>,,,,1,,ANY
318604,BLOCK,1,,<empty>,,,,1,,ANY
318611,BLOCK,1,,<empty>,,,,1,,ANY
318617,BLOCK,1,,<empty>,,,,1,,ANY
318623,BLOCK,1,,<empty>,,,,1,,ANY
318627,BLOCK,1,,<empty>,,,,1,,ANY
318632,BLOCK,1,,<empty>,,,,1,,ANY
318636,BLOCK,1,,<empty>,,,,1,,ANY
318642,BLOCK,1,,<empty>,,,,1,,ANY
318647,BLOCK,1,,<empty>,,,,1,,ANY
318651,BLOCK,1,,<empty>,,,,1,,ANY
318657,BLOCK,1,,<empty>,,,,1,,ANY
318663,BLOCK,1,,<empty>,,,,1,,ANY
318668,BLOCK,1,,<empty>,,,,1,,ANY
318672,BLOCK,1,,<empty>,,,,1,,ANY
318678,BLOCK,1,,<empty>,,,,1,,ANY
318682,BLOCK,1,,<empty>,,,,1,,ANY
318685,BLOCK,1,,<empty>,,,,1,,ANY
318689,BLOCK,1,,<empty>,,,,1,,ANY
318694,BLOCK,1,,<empty>,,,,1,,ANY
318698,BLOCK,1,,<empty>,,,,1,,ANY
318706,BLOCK,1,,<empty>,,,,1,,ANY
318711,BLOCK,1,,<empty>,,,,1,,ANY
318715,BLOCK,1,,<empty>,,,,1,,ANY
318719,BLOCK,1,,<empty>,,,,1,,ANY
318726,BLOCK,1,,<empty>,,,,1,,ANY
318731,BLOCK,1,,<empty>,,,,1,,ANY
318737,BLOCK,1,,<empty>,,,,1,,ANY
318744,BLOCK,1,,<empty>,,,,1,,ANY
318749,BLOCK,1,,<empty>,,,,1,,ANY
318754,BLOCK,1,,<empty>,,,,1,,ANY
318762,BLOCK,1,,<empty>,,,,1,,ANY
318767,BLOCK,1,,<empty>,,,,1,,ANY
318771,BLOCK,1,,<empty>,,,,1,,ANY
318775,BLOCK,1,,<empty>,,,,1,,ANY
318779,BLOCK,1,,<empty>,,,,1,,ANY
318786,BLOCK,1,,<empty>,,,,1,,ANY
318792,BLOCK,1,,<empty>,,,,1,,ANY
318795,BLOCK,1,,<empty>,,,,1,,ANY
318799,BLOCK,1,,<empty>,,,,1,,ANY
318805,BLOCK,1,,<empty>,,,,1,,ANY
318808,BLOCK,1,,<empty>,,,,1,,ANY
318811,BLOCK,1,,<empty>,,,,1,,ANY
318814,BLOCK,1,,<empty>,,,,1,,ANY
318820,BLOCK,1,,<empty>,,,,1,,ANY
318825,BLOCK,1,,<empty>,,,,1,,ANY
318828,BLOCK,1,,<empty>,,,,1,,ANY
318831,BLOCK,1,,<empty>,,,,1,,ANY
318835,BLOCK,1,,<empty>,,,,1,,ANY
318839,BLOCK,1,,<empty>,,,,1,,ANY
318843,BLOCK,1,,<empty>,,,,1,,ANY
318847,BLOCK,1,,<empty>,,,,1,,ANY
318851,BLOCK,1,,<empty>,,,,1,,ANY
318855,BLOCK,1,,<empty>,,,,1,,ANY
318861,BLOCK,1,,<empty>,,,,1,,ANY
318874,BLOCK,1,,<empty>,,,,1,,ANY
318879,BLOCK,1,,<empty>,,,,1,,ANY
318883,BLOCK,1,,<empty>,,,,1,,ANY
318887,BLOCK,1,,<empty>,,,,1,,ANY
318892,BLOCK,1,,<empty>,,,,1,,ANY
318897,BLOCK,1,,<empty>,,,,1,,ANY
318903,BLOCK,1,,<empty>,,,,1,,ANY
318910,BLOCK,1,,<empty>,,,,1,,ANY
318915,BLOCK,1,,<empty>,,,,1,,ANY
318920,BLOCK,1,,<empty>,,,,1,,ANY
318925,BLOCK,1,,<empty>,,,,1,,ANY
318929,BLOCK,1,,<empty>,,,,1,,ANY
318933,BLOCK,1,,<empty>,,,,1,,ANY
318936,BLOCK,1,,<empty>,,,,1,,ANY
318939,BLOCK,1,,<empty>,,,,1,,ANY
318943,BLOCK,1,,<empty>,,,,1,,ANY
318947,BLOCK,1,,<empty>,,,,1,,ANY
318951,BLOCK,1,,<empty>,,,,1,,ANY
318955,BLOCK,1,,<empty>,,,,1,,ANY
318958,BLOCK,1,,<empty>,,,,1,,ANY
318962,BLOCK,1,,<empty>,,,,1,,ANY
318966,BLOCK,1,,<empty>,,,,1,,ANY
318970,BLOCK,1,,<empty>,,,,1,,ANY
318974,BLOCK,1,,<empty>,,,,1,,ANY
318978,BLOCK,1,,<empty>,,,,1,,ANY
318982,BLOCK,1,,<empty>,,,,1,,ANY
318986,BLOCK,1,,<empty>,,,,1,,ANY
318994,BLOCK,1,,<empty>,,,,1,,ANY
318998,BLOCK,1,,<empty>,,,,1,,ANY
319004,BLOCK,1,,<empty>,,,,1,,ANY
319008,BLOCK,1,,<empty>,,,,1,,ANY
319012,BLOCK,1,,<empty>,,,,1,,ANY
319016,BLOCK,1,,<empty>,,,,1,,ANY
319020,BLOCK,1,,<empty>,,,,1,,ANY
319026,BLOCK,1,,<empty>,,,,1,,ANY
319031,BLOCK,1,,<empty>,,,,1,,ANY
319036,BLOCK,1,,<empty>,,,,1,,ANY
319040,BLOCK,1,,<empty>,,,,1,,ANY
319045,BLOCK,1,,<empty>,,,,1,,ANY
319051,BLOCK,1,,<empty>,,,,1,,ANY
319058,BLOCK,1,,<empty>,,,,1,,ANY
319063,BLOCK,1,,<empty>,,,,1,,ANY
319068,BLOCK,1,,<empty>,,,,1,,ANY
319073,BLOCK,1,,<empty>,,,,1,,ANY
319077,BLOCK,1,,<empty>,,,,1,,ANY
319081,BLOCK,1,,<empty>,,,,1,,ANY
319085,BLOCK,1,,<empty>,,,,1,,ANY
319092,BLOCK,1,,<empty>,,,,1,,ANY
319096,BLOCK,1,,<empty>,,,,1,,ANY
319103,BLOCK,1,,<empty>,,,,1,,ANY
319107,BLOCK,1,,<empty>,,,,1,,ANY
319111,BLOCK,1,,<empty>,,,,1,,ANY
319116,BLOCK,1,,<empty>,,,,1,,ANY
319122,BLOCK,1,,<empty>,,,,1,,ANY
319128,BLOCK,1,,<empty>,,,,1,,ANY
319132,BLOCK,1,,<empty>,,,,1,,ANY
319139,BLOCK,1,,<empty>,,,,1,,ANY
319145,BLOCK,1,,<empty>,,,,1,,ANY
319149,BLOCK,1,,<empty>,,,,1,,ANY
319153,BLOCK,1,,<empty>,,,,1,,ANY
319156,BLOCK,1,,<empty>,,,,1,,ANY
319161,BLOCK,1,,<empty>,,,,1,,ANY
319167,BLOCK,1,,<empty>,,,,1,,ANY
319171,BLOCK,1,,<empty>,,,,1,,ANY
319175,BLOCK,1,,<empty>,,,,1,,ANY
319180,BLOCK,1,,<empty>,,,,1,,ANY
319185,BLOCK,1,,<empty>,,,,1,,ANY
319189,BLOCK,1,,<empty>,,,,1,,ANY
319193,BLOCK,1,,<empty>,,,,1,,ANY
319197,BLOCK,1,,<empty>,,,,1,,ANY
319205,BLOCK,1,,<empty>,,,,1,,ANY
319209,BLOCK,1,,<empty>,,,,1,,ANY
319214,BLOCK,1,,<empty>,,,,1,,ANY
319218,BLOCK,1,,<empty>,,,,1,,ANY
319225,BLOCK,1,,<empty>,,,,1,,ANY
319231,BLOCK,1,,<empty>,,,,1,,ANY
319239,BLOCK,1,,<empty>,,,,1,,ANY
319244,BLOCK,1,,<empty>,,,,1,,ANY
319250,BLOCK,1,,<empty>,,,,1,,ANY
319254,BLOCK,1,,<empty>,,,,1,,ANY
319259,BLOCK,1,,<empty>,,,,1,,ANY
319264,BLOCK,1,,<empty>,,,,1,,ANY
319269,BLOCK,1,,<empty>,,,,1,,ANY
319274,BLOCK,1,,<empty>,,,,1,,ANY
319279,BLOCK,1,,<empty>,,,,1,,ANY
319283,BLOCK,1,,<empty>,,,,1,,ANY
319287,BLOCK,1,,<empty>,,,,1,,ANY
319291,BLOCK,1,,<empty>,,,,1,,ANY
319296,BLOCK,1,,<empty>,,,,1,,ANY
319301,BLOCK,1,,<empty>,,,,1,,ANY
319305,BLOCK,1,,<empty>,,,,1,,ANY
319310,BLOCK,1,,<empty>,,,,1,,ANY
319315,BLOCK,1,,<empty>,,,,1,,ANY
319322,BLOCK,1,,<empty>,,,,1,,ANY
319327,BLOCK,1,,<empty>,,,,1,,ANY
319331,BLOCK,1,,<empty>,,,,1,,ANY
319336,BLOCK,1,,<empty>,,,,1,,ANY
319340,BLOCK,1,,<empty>,,,,1,,ANY
319346,BLOCK,1,,<empty>,,,,1,,ANY
319352,BLOCK,1,,<empty>,,,,1,,ANY
319356,BLOCK,1,,<empty>,,,,1,,ANY
319359,BLOCK,1,,<empty>,,,,1,,ANY
319364,BLOCK,1,,<empty>,,,,1,,ANY
319370,BLOCK,1,,<empty>,,,,1,,ANY
319376,BLOCK,1,,<empty>,,,,1,,ANY
319381,BLOCK,1,,<empty>,,,,1,,ANY
319386,BLOCK,1,,<empty>,,,,1,,ANY
319391,BLOCK,1,,<empty>,,,,1,,ANY
319400,BLOCK,1,,<empty>,,,,1,,ANY
319403,BLOCK,1,,<empty>,,,,1,,ANY
319407,BLOCK,1,,<empty>,,,,1,,ANY
319413,BLOCK,1,,<empty>,,,,1,,ANY
319416,BLOCK,1,,<empty>,,,,1,,ANY
319421,BLOCK,1,,<empty>,,,,1,,ANY
319424,BLOCK,1,,<empty>,,,,1,,ANY
319430,BLOCK,1,,<empty>,,,,1,,ANY
319434,BLOCK,1,,<empty>,,,,1,,ANY
319438,BLOCK,1,,<empty>,,,,1,,ANY
319444,BLOCK,1,,<empty>,,,,1,,ANY
319448,BLOCK,1,,<empty>,,,,1,,ANY
319452,BLOCK,1,,<empty>,,,,1,,ANY
319456,BLOCK,1,,<empty>,,,,1,,ANY
319460,BLOCK,1,,<empty>,,,,1,,ANY
319464,BLOCK,1,,<empty>,,,,1,,ANY
319468,BLOCK,1,,<empty>,,,,1,,ANY
319472,BLOCK,1,,<empty>,,,,1,,ANY
319476,BLOCK,1,,<empty>,,,,1,,ANY
319480,BLOCK,1,,<empty>,,,,1,,ANY
319484,BLOCK,1,,<empty>,,,,1,,ANY
319489,BLOCK,1,,<empty>,,,,1,,ANY
319494,BLOCK,1,,<empty>,,,,1,,ANY
319499,BLOCK,1,,<empty>,,,,1,,ANY
319504,BLOCK,1,,<empty>,,,,1,,ANY
319509,BLOCK,1,,<empty>,,,,1,,ANY
319514,BLOCK,1,,<empty>,,,,1,,ANY
319519,BLOCK,1,,<empty>,,,,1,,ANY
319524,BLOCK,1,,<empty>,,,,1,,ANY
319529,BLOCK,1,,<empty>,,,,1,,ANY
319534,BLOCK,1,,<empty>,,,,1,,ANY
319539,BLOCK,1,,<empty>,,,,1,,ANY
319544,BLOCK,1,,<empty>,,,,1,,ANY
319549,BLOCK,1,,<empty>,,,,1,,ANY
319553,BLOCK,1,,<empty>,,,,1,,ANY
319558,BLOCK,1,,<empty>,,,,1,,ANY
319564,BLOCK,1,,<empty>,,,,1,,ANY
319572,BLOCK,1,,<empty>,,,,1,,ANY
319577,BLOCK,1,,<empty>,,,,1,,ANY
319584,BLOCK,1,,<empty>,,,,1,,ANY
319591,BLOCK,1,,<empty>,,,,1,,ANY
319596,BLOCK,1,,<empty>,,,,1,,ANY
319601,BLOCK,1,,<empty>,,,,1,,ANY
319606,BLOCK,1,,<empty>,,,,1,,ANY
319610,BLOCK,1,,<empty>,,,,1,,ANY
319615,BLOCK,1,,<empty>,,,,1,,ANY
319619,BLOCK,1,,<empty>,,,,1,,ANY
319625,BLOCK,1,,<empty>,,,,1,,ANY
319628,BLOCK,1,,<empty>,,,,1,,ANY
319633,BLOCK,1,,<empty>,,,,1,,ANY
319637,BLOCK,1,,<empty>,,,,1,,ANY
319643,BLOCK,1,,<empty>,,,,1,,ANY
319651,BLOCK,1,,<empty>,,,,1,,ANY
319654,BLOCK,1,,<empty>,,,,1,,ANY
319658,BLOCK,1,,<empty>,,,,1,,ANY
319663,BLOCK,1,,<empty>,,,,1,,ANY
319666,BLOCK,1,,<empty>,,,,1,,ANY
319672,BLOCK,1,,<empty>,,,,1,,ANY
319676,BLOCK,1,,<empty>,,,,1,,ANY
319681,BLOCK,1,,<empty>,,,,1,,ANY
319686,BLOCK,1,,<empty>,,,,1,,ANY
319691,BLOCK,1,,<empty>,,,,1,,ANY
319697,BLOCK,1,,<empty>,,,,1,,ANY
319701,BLOCK,1,,<empty>,,,,1,,ANY
319704,BLOCK,1,,<empty>,,,,1,,ANY
319708,BLOCK,1,,<empty>,,,,1,,ANY
319714,BLOCK,1,,<empty>,,,,1,,ANY
319717,BLOCK,1,,<empty>,,,,1,,ANY
319724,BLOCK,1,,<empty>,,,,1,,ANY
319729,BLOCK,1,,<empty>,,,,1,,ANY
319735,BLOCK,1,,<empty>,,,,1,,ANY
319739,BLOCK,1,,<empty>,,,,1,,ANY
319743,BLOCK,1,,<empty>,,,,1,,ANY
319749,BLOCK,1,,<empty>,,,,1,,ANY
319753,BLOCK,1,,<empty>,,,,1,,ANY
319757,BLOCK,1,,<empty>,,,,1,,ANY
319761,BLOCK,1,,<empty>,,,,1,,ANY
319766,BLOCK,1,,<empty>,,,,1,,ANY
319773,BLOCK,1,,<empty>,,,,1,,ANY
319777,BLOCK,1,,<empty>,,,,1,,ANY
319781,BLOCK,1,,<empty>,,,,1,,ANY
319787,BLOCK,1,,<empty>,,,,1,,ANY
319792,BLOCK,1,,<empty>,,,,1,,ANY
319798,BLOCK,1,,<empty>,,,,1,,ANY
319802,BLOCK,1,,<empty>,,,,1,,ANY
319808,BLOCK,1,,<empty>,,,,1,,ANY
319814,BLOCK,1,,<empty>,,,,1,,ANY
319819,BLOCK,1,,<empty>,,,,1,,ANY
319825,BLOCK,1,,<empty>,,,,1,,ANY
319830,BLOCK,1,,<empty>,,,,1,,ANY
319838,BLOCK,1,,<empty>,,,,1,,ANY
319844,BLOCK,1,,<empty>,,,,1,,ANY
319848,BLOCK,1,,<empty>,,,,1,,ANY
319853,BLOCK,1,,<empty>,,,,1,,ANY
319857,BLOCK,1,,<empty>,,,,1,,ANY
319863,BLOCK,1,,<empty>,,,,1,,ANY
319868,BLOCK,1,,<empty>,,,,1,,ANY
319873,BLOCK,1,,<empty>,,,,1,,ANY
319877,BLOCK,1,,<empty>,,,,1,,ANY
319881,BLOCK,1,,<empty>,,,,1,,ANY
319885,BLOCK,1,,<empty>,,,,1,,ANY
319891,BLOCK,1,,<empty>,,,,1,,ANY
319897,BLOCK,1,,<empty>,,,,1,,ANY
319901,BLOCK,1,,<empty>,,,,1,,ANY
319906,BLOCK,1,,<empty>,,,,1,,ANY
319910,BLOCK,1,,<empty>,,,,1,,ANY
319916,BLOCK,1,,<empty>,,,,1,,ANY
319921,BLOCK,1,,<empty>,,,,1,,ANY
319926,BLOCK,1,,<empty>,,,,1,,ANY
319930,BLOCK,1,,<empty>,,,,1,,ANY
319934,BLOCK,1,,<empty>,,,,1,,ANY
319939,BLOCK,1,,<empty>,,,,1,,ANY
319943,BLOCK,1,,<empty>,,,,1,,ANY
319947,BLOCK,1,,<empty>,,,,1,,ANY
319953,BLOCK,1,,<empty>,,,,1,,ANY
319959,BLOCK,1,,<empty>,,,,1,,ANY
319964,BLOCK,1,,<empty>,,,,1,,ANY
319973,BLOCK,1,,<empty>,,,,1,,ANY
319977,BLOCK,1,,<empty>,,,,1,,ANY
319981,BLOCK,1,,<empty>,,,,1,,ANY
319985,BLOCK,1,,<empty>,,,,1,,ANY
319990,BLOCK,1,,<empty>,,,,1,,ANY
319996,BLOCK,1,,<empty>,,,,1,,ANY
320000,BLOCK,1,,<empty>,,,,1,,ANY
320004,BLOCK,1,,<empty>,,,,1,,ANY
320008,BLOCK,1,,<empty>,,,,1,,ANY
320013,BLOCK,1,,<empty>,,,,1,,ANY
320018,BLOCK,1,,<empty>,,,,1,,ANY
320022,BLOCK,1,,<empty>,,,,1,,ANY
320027,BLOCK,1,,<empty>,,,,1,,ANY
320031,BLOCK,1,,<empty>,,,,1,,ANY
320040,BLOCK,1,,<empty>,,,,1,,ANY
320044,BLOCK,1,,<empty>,,,,1,,ANY
320050,BLOCK,1,,<empty>,,,,1,,ANY
320053,BLOCK,1,,<empty>,,,,1,,ANY
320060,BLOCK,1,,<empty>,,,,1,,ANY
320064,BLOCK,1,,<empty>,,,,1,,ANY
320069,BLOCK,1,,<empty>,,,,1,,ANY
320073,BLOCK,1,,<empty>,,,,1,,ANY
320079,BLOCK,1,,<empty>,,,,1,,ANY
320084,BLOCK,1,,<empty>,,,,1,,ANY
320091,BLOCK,1,,<empty>,,,,1,,ANY
320094,BLOCK,1,,<empty>,,,,1,,ANY
320101,BLOCK,1,,<empty>,,,,1,,ANY
320107,BLOCK,1,,<empty>,,,,1,,ANY
320111,BLOCK,1,,<empty>,,,,1,,ANY
320117,BLOCK,1,,<empty>,,,,1,,ANY
320123,BLOCK,1,,<empty>,,,,1,,ANY
320126,BLOCK,1,,<empty>,,,,1,,ANY
320131,BLOCK,1,,<empty>,,,,1,,ANY
320135,BLOCK,1,,<empty>,,,,1,,ANY
320143,BLOCK,1,,<empty>,,,,1,,ANY
320151,BLOCK,1,,<empty>,,,,1,,ANY
320154,BLOCK,1,,<empty>,,,,1,,ANY
320160,BLOCK,1,,<empty>,,,,1,,ANY
320166,BLOCK,1,,<empty>,,,,1,,ANY
320171,BLOCK,1,,<empty>,,,,1,,ANY
320177,BLOCK,1,,<empty>,,,,1,,ANY
320181,BLOCK,1,,<empty>,,,,1,,ANY
320186,BLOCK,1,,<empty>,,,,1,,ANY
320191,BLOCK,1,,<empty>,,,,1,,ANY
320195,BLOCK,1,,<empty>,,,,1,,ANY
320201,BLOCK,1,,<empty>,,,,1,,ANY
320205,BLOCK,1,,<empty>,,,,1,,ANY
320213,BLOCK,1,,<empty>,,,,1,,ANY
320217,BLOCK,1,,<empty>,,,,1,,ANY
320220,BLOCK,1,,<empty>,,,,1,,ANY
320226,BLOCK,1,,<empty>,,,,1,,ANY
320232,BLOCK,1,,<empty>,,,,1,,ANY
320236,BLOCK,1,,<empty>,,,,1,,ANY
320240,BLOCK,1,,<empty>,,,,1,,ANY
320244,BLOCK,1,,<empty>,,,,1,,ANY
320248,BLOCK,1,,<empty>,,,,1,,ANY
320252,BLOCK,1,,<empty>,,,,1,,ANY
320256,BLOCK,1,,<empty>,,,,1,,ANY
320260,BLOCK,1,,<empty>,,,,1,,ANY
320264,BLOCK,1,,<empty>,,,,1,,ANY
320269,BLOCK,1,,<empty>,,,,1,,ANY
320274,BLOCK,1,,<empty>,,,,1,,ANY
320279,BLOCK,1,,<empty>,,,,1,,ANY
320283,BLOCK,1,,<empty>,,,,1,,ANY
320287,BLOCK,1,,<empty>,,,,1,,ANY
320291,BLOCK,1,,<empty>,,,,1,,ANY
320295,BLOCK,1,,<empty>,,,,1,,ANY
320299,BLOCK,1,,<empty>,,,,1,,ANY
320304,BLOCK,1,,<empty>,,,,1,,ANY
320308,BLOCK,1,,<empty>,,,,1,,ANY
320312,BLOCK,1,,<empty>,,,,1,,ANY
320318,BLOCK,1,,<empty>,,,,1,,ANY
320322,BLOCK,1,,<empty>,,,,1,,ANY
320326,BLOCK,1,,<empty>,,,,1,,ANY
320332,BLOCK,1,,<empty>,,,,1,,ANY
320343,BLOCK,1,,<empty>,,,,1,,ANY
320348,BLOCK,1,,<empty>,,,,1,,ANY
320353,BLOCK,1,,<empty>,,,,1,,ANY
320357,BLOCK,1,,<empty>,,,,1,,ANY
320361,BLOCK,1,,<empty>,,,,1,,ANY
320368,BLOCK,1,,<empty>,,,,1,,ANY
320372,BLOCK,1,,<empty>,,,,1,,ANY
320379,BLOCK,1,,<empty>,,,,1,,ANY
320383,BLOCK,1,,<empty>,,,,1,,ANY
320390,BLOCK,1,,<empty>,,,,1,,ANY
320402,BLOCK,1,,<empty>,,,,1,,ANY
320406,BLOCK,1,,<empty>,,,,1,,ANY
320411,BLOCK,1,,<empty>,,,,1,,ANY
320415,BLOCK,1,,<empty>,,,,1,,ANY
320419,BLOCK,1,,<empty>,,,,1,,ANY
320422,BLOCK,1,,<empty>,,,,1,,ANY
320425,BLOCK,1,,<empty>,,,,1,,ANY
320428,BLOCK,1,,<empty>,,,,1,,ANY
320431,BLOCK,1,,<empty>,,,,1,,ANY
320435,BLOCK,1,,<empty>,,,,1,,ANY
320439,BLOCK,1,,<empty>,,,,1,,ANY
320443,BLOCK,1,,<empty>,,,,1,,ANY
320447,BLOCK,1,,<empty>,,,,1,,ANY
320451,BLOCK,1,,<empty>,,,,1,,ANY
320456,BLOCK,1,,<empty>,,,,1,,ANY
320459,BLOCK,1,,<empty>,,,,1,,ANY
320467,BLOCK,1,,<empty>,,,,1,,ANY
320474,BLOCK,1,,<empty>,,,,1,,ANY
320478,BLOCK,1,,<empty>,,,,1,,ANY
320486,BLOCK,1,,<empty>,,,,1,,ANY
320493,BLOCK,1,,<empty>,,,,1,,ANY
320498,BLOCK,1,,<empty>,,,,1,,ANY
320506,BLOCK,1,,<empty>,,,,1,,ANY
320514,BLOCK,1,,<empty>,,,,1,,ANY
320520,BLOCK,1,,<empty>,,,,1,,ANY
320524,BLOCK,1,,<empty>,,,,1,,ANY
320531,BLOCK,1,,<empty>,,,,1,,ANY
320535,BLOCK,1,,<empty>,,,,1,,ANY
320540,BLOCK,1,,<empty>,,,,1,,ANY
320546,BLOCK,1,,<empty>,,,,1,,ANY
320550,BLOCK,1,,<empty>,,,,1,,ANY
320554,BLOCK,1,,<empty>,,,,1,,ANY
320559,BLOCK,1,,<empty>,,,,1,,ANY
320565,BLOCK,1,,<empty>,,,,1,,ANY
320569,BLOCK,1,,<empty>,,,,1,,ANY
320573,BLOCK,1,,<empty>,,,,1,,ANY
320577,BLOCK,1,,<empty>,,,,1,,ANY
320581,BLOCK,1,,<empty>,,,,1,,ANY
320585,BLOCK,1,,<empty>,,,,1,,ANY
320593,BLOCK,1,,<empty>,,,,1,,ANY
320601,BLOCK,1,,<empty>,,,,1,,ANY
320609,BLOCK,1,,<empty>,,,,1,,ANY
320616,BLOCK,1,,<empty>,,,,1,,ANY
320622,BLOCK,1,,<empty>,,,,1,,ANY
320628,BLOCK,1,,<empty>,,,,1,,ANY
320633,BLOCK,1,,<empty>,,,,1,,ANY
320637,BLOCK,1,,<empty>,,,,1,,ANY
320642,BLOCK,1,,<empty>,,,,1,,ANY
320646,BLOCK,1,,<empty>,,,,1,,ANY
320650,BLOCK,1,,<empty>,,,,1,,ANY
320654,BLOCK,1,,<empty>,,,,1,,ANY
320659,BLOCK,1,,<empty>,,,,1,,ANY
320663,BLOCK,1,,<empty>,,,,1,,ANY
320668,BLOCK,1,,<empty>,,,,1,,ANY
320674,BLOCK,1,,<empty>,,,,1,,ANY
320683,BLOCK,1,,<empty>,,,,1,,ANY
320696,BLOCK,1,,<empty>,,,,1,,ANY
320702,BLOCK,1,,<empty>,,,,1,,ANY
320708,BLOCK,1,,<empty>,,,,1,,ANY
320714,BLOCK,1,,<empty>,,,,1,,ANY
320720,BLOCK,1,,<empty>,,,,1,,ANY
320728,BLOCK,1,,<empty>,,,,1,,ANY
320732,BLOCK,1,,<empty>,,,,1,,ANY
320736,BLOCK,1,,<empty>,,,,1,,ANY
320741,BLOCK,1,,<empty>,,,,1,,ANY
320746,BLOCK,1,,<empty>,,,,1,,ANY
320752,BLOCK,1,,<empty>,,,,1,,ANY
320756,BLOCK,1,,<empty>,,,,1,,ANY
320760,BLOCK,1,,<empty>,,,,1,,ANY
320766,BLOCK,1,,<empty>,,,,1,,ANY
320770,BLOCK,1,,<empty>,,,,1,,ANY
320774,BLOCK,1,,<empty>,,,,1,,ANY
320778,BLOCK,1,,<empty>,,,,1,,ANY
320783,BLOCK,1,,<empty>,,,,1,,ANY
320787,BLOCK,1,,<empty>,,,,1,,ANY
320792,BLOCK,1,,<empty>,,,,1,,ANY
320797,BLOCK,1,,<empty>,,,,1,,ANY
320802,BLOCK,1,,<empty>,,,,1,,ANY
320807,BLOCK,1,,<empty>,,,,1,,ANY
320811,BLOCK,1,,<empty>,,,,1,,ANY
320814,BLOCK,1,,<empty>,,,,1,,ANY
320818,BLOCK,1,,<empty>,,,,1,,ANY
320822,BLOCK,1,,<empty>,,,,1,,ANY
320828,BLOCK,1,,<empty>,,,,1,,ANY
320832,BLOCK,1,,<empty>,,,,1,,ANY
320836,BLOCK,1,,<empty>,,,,1,,ANY
320840,BLOCK,1,,<empty>,,,,1,,ANY
320844,BLOCK,1,,<empty>,,,,1,,ANY
320848,BLOCK,1,,<empty>,,,,1,,ANY
320852,BLOCK,1,,<empty>,,,,1,,ANY
320857,BLOCK,1,,<empty>,,,,1,,ANY
320861,BLOCK,1,,<empty>,,,,1,,ANY
320865,BLOCK,1,,<empty>,,,,1,,ANY
320870,BLOCK,1,,<empty>,,,,1,,ANY
320874,BLOCK,1,,<empty>,,,,1,,ANY
320881,BLOCK,1,,<empty>,,,,1,,ANY
320885,BLOCK,1,,<empty>,,,,1,,ANY
320889,BLOCK,1,,<empty>,,,,1,,ANY
320893,BLOCK,1,,<empty>,,,,1,,ANY
320902,BLOCK,1,,<empty>,,,,1,,ANY
320907,BLOCK,1,,<empty>,,,,1,,ANY
320912,BLOCK,1,,<empty>,,,,1,,ANY
320916,BLOCK,1,,<empty>,,,,1,,ANY
320920,BLOCK,1,,<empty>,,,,1,,ANY
320924,BLOCK,1,,<empty>,,,,1,,ANY
320929,BLOCK,1,,<empty>,,,,1,,ANY
320933,BLOCK,1,,<empty>,,,,1,,ANY
320937,BLOCK,1,,<empty>,,,,1,,ANY
320941,BLOCK,1,,<empty>,,,,1,,ANY
320946,BLOCK,1,,<empty>,,,,1,,ANY
320950,BLOCK,1,,<empty>,,,,1,,ANY
320954,BLOCK,1,,<empty>,,,,1,,ANY
320958,BLOCK,1,,<empty>,,,,1,,ANY
320968,BLOCK,1,,<empty>,,,,1,,ANY
320976,BLOCK,1,,<empty>,,,,1,,ANY
320983,BLOCK,1,,<empty>,,,,1,,ANY
320987,BLOCK,1,,<empty>,,,,1,,ANY
320991,BLOCK,1,,<empty>,,,,1,,ANY
320996,BLOCK,1,,<empty>,,,,1,,ANY
321000,BLOCK,1,,<empty>,,,,1,,ANY
321005,BLOCK,1,,<empty>,,,,1,,ANY
321011,BLOCK,1,,<empty>,,,,1,,ANY
321017,BLOCK,1,,<empty>,,,,1,,ANY
321021,BLOCK,1,,<empty>,,,,1,,ANY
321025,BLOCK,1,,<empty>,,,,1,,ANY
321029,BLOCK,1,,<empty>,,,,1,,ANY
321033,BLOCK,1,,<empty>,,,,1,,ANY
321037,BLOCK,1,,<empty>,,,,1,,ANY
321041,BLOCK,1,,<empty>,,,,1,,ANY
321045,BLOCK,1,,<empty>,,,,1,,ANY
321049,BLOCK,1,,<empty>,,,,1,,ANY
321053,BLOCK,1,,<empty>,,,,1,,ANY
321057,BLOCK,1,,<empty>,,,,1,,ANY
321061,BLOCK,1,,<empty>,,,,1,,ANY
321065,BLOCK,1,,<empty>,,,,1,,ANY
321069,BLOCK,1,,<empty>,,,,1,,ANY
321072,BLOCK,1,,<empty>,,,,1,,ANY
321076,BLOCK,1,,<empty>,,,,1,,ANY
321080,BLOCK,1,,<empty>,,,,1,,ANY
321084,BLOCK,1,,<empty>,,,,1,,ANY
321089,BLOCK,1,,<empty>,,,,1,,ANY
321094,BLOCK,1,,<empty>,,,,1,,ANY
321099,BLOCK,1,,<empty>,,,,1,,ANY
321104,BLOCK,1,,<empty>,,,,1,,ANY
321108,BLOCK,1,,<empty>,,,,1,,ANY
321112,BLOCK,1,,<empty>,,,,1,,ANY
321116,BLOCK,1,,<empty>,,,,1,,ANY
321120,BLOCK,1,,<empty>,,,,1,,ANY
321126,BLOCK,1,,<empty>,,,,1,,ANY
321130,BLOCK,1,,<empty>,,,,1,,ANY
321136,BLOCK,1,,<empty>,,,,1,,ANY
321140,BLOCK,1,,<empty>,,,,1,,ANY
321144,BLOCK,1,,<empty>,,,,1,,ANY
321148,BLOCK,1,,<empty>,,,,1,,ANY
321157,BLOCK,1,,<empty>,,,,1,,ANY
321164,BLOCK,1,,<empty>,,,,1,,ANY
321171,BLOCK,1,,<empty>,,,,1,,ANY
321178,BLOCK,1,,<empty>,,,,1,,ANY
321185,BLOCK,1,,<empty>,,,,1,,ANY
321192,BLOCK,1,,<empty>,,,,1,,ANY
321199,BLOCK,1,,<empty>,,,,1,,ANY
321206,BLOCK,1,,<empty>,,,,1,,ANY
321213,BLOCK,1,,<empty>,,,,1,,ANY
321220,BLOCK,1,,<empty>,,,,1,,ANY
321227,BLOCK,1,,<empty>,,,,1,,ANY
321234,BLOCK,1,,<empty>,,,,1,,ANY
321238,BLOCK,1,,<empty>,,,,1,,ANY
321242,BLOCK,1,,<empty>,,,,1,,ANY
321246,BLOCK,1,,<empty>,,,,1,,ANY
321250,BLOCK,1,,<empty>,,,,1,,ANY
321254,BLOCK,1,,<empty>,,,,1,,ANY
321258,BLOCK,1,,<empty>,,,,1,,ANY
321262,BLOCK,1,,<empty>,,,,1,,ANY
321266,BLOCK,1,,<empty>,,,,1,,ANY
321270,BLOCK,1,,<empty>,,,,1,,ANY
321274,BLOCK,1,,<empty>,,,,1,,ANY
321278,BLOCK,1,,<empty>,,,,1,,ANY
321282,BLOCK,1,,<empty>,,,,1,,ANY
321289,BLOCK,1,,<empty>,,,,1,,ANY
321293,BLOCK,1,,<empty>,,,,1,,ANY
321297,BLOCK,1,,<empty>,,,,1,,ANY
321301,BLOCK,1,,<empty>,,,,1,,ANY
321304,BLOCK,1,,<empty>,,,,1,,ANY
321309,BLOCK,1,,<empty>,,,,1,,ANY
321314,BLOCK,1,,<empty>,,,,1,,ANY
321318,BLOCK,1,,<empty>,,,,1,,ANY
321326,BLOCK,1,,<empty>,,,,1,,ANY
321330,BLOCK,1,,<empty>,,,,1,,ANY
321336,BLOCK,1,,<empty>,,,,1,,ANY
321340,BLOCK,1,,<empty>,,,,1,,ANY
321344,BLOCK,1,,<empty>,,,,1,,ANY
321348,BLOCK,1,,<empty>,,,,1,,ANY
321352,BLOCK,1,,<empty>,,,,1,,ANY
321356,BLOCK,1,,<empty>,,,,1,,ANY
321362,BLOCK,1,,<empty>,,,,1,,ANY
321366,BLOCK,1,,<empty>,,,,1,,ANY
321370,BLOCK,1,,<empty>,,,,1,,ANY
321374,BLOCK,1,,<empty>,,,,1,,ANY
321378,BLOCK,1,,<empty>,,,,1,,ANY
321382,BLOCK,1,,<empty>,,,,1,,ANY
321386,BLOCK,1,,<empty>,,,,1,,ANY
321390,BLOCK,1,,<empty>,,,,1,,ANY
321395,BLOCK,1,,<empty>,,,,1,,ANY
321399,BLOCK,1,,<empty>,,,,1,,ANY
321403,BLOCK,1,,<empty>,,,,1,,ANY
321408,BLOCK,1,,<empty>,,,,1,,ANY
321413,BLOCK,1,,<empty>,,,,1,,ANY
321416,BLOCK,1,,<empty>,,,,1,,ANY
321420,BLOCK,1,,<empty>,,,,1,,ANY
321425,BLOCK,1,,<empty>,,,,1,,ANY
321429,BLOCK,1,,<empty>,,,,1,,ANY
321433,BLOCK,1,,<empty>,,,,1,,ANY
321437,BLOCK,1,,<empty>,,,,1,,ANY
321441,BLOCK,1,,<empty>,,,,1,,ANY
321445,BLOCK,1,,<empty>,,,,1,,ANY
321449,BLOCK,1,,<empty>,,,,1,,ANY
321454,BLOCK,1,,<empty>,,,,1,,ANY
321457,BLOCK,1,,<empty>,,,,1,,ANY
321461,BLOCK,1,,<empty>,,,,1,,ANY
321466,BLOCK,1,,<empty>,,,,1,,ANY
321471,BLOCK,1,,<empty>,,,,1,,ANY
321475,BLOCK,1,,<empty>,,,,1,,ANY
321483,BLOCK,1,,<empty>,,,,1,,ANY
321488,BLOCK,1,,<empty>,,,,1,,ANY
321495,BLOCK,1,,<empty>,,,,1,,ANY
321500,BLOCK,1,,<empty>,,,,1,,ANY
321508,BLOCK,1,,<empty>,,,,1,,ANY
321514,BLOCK,1,,<empty>,,,,1,,ANY
321518,BLOCK,1,,<empty>,,,,1,,ANY
321524,BLOCK,1,,<empty>,,,,1,,ANY
321528,BLOCK,1,,<empty>,,,,1,,ANY
321531,BLOCK,1,,<empty>,,,,1,,ANY
321536,BLOCK,1,,<empty>,,,,1,,ANY
321541,BLOCK,1,,<empty>,,,,1,,ANY
321546,BLOCK,1,,<empty>,,,,1,,ANY
321552,BLOCK,1,,<empty>,,,,1,,ANY
321557,BLOCK,1,,<empty>,,,,1,,ANY
321562,BLOCK,1,,<empty>,,,,1,,ANY
321568,BLOCK,1,,<empty>,,,,1,,ANY
321574,BLOCK,1,,<empty>,,,,1,,ANY
321578,BLOCK,1,,<empty>,,,,1,,ANY
321582,BLOCK,1,,<empty>,,,,1,,ANY
321590,BLOCK,1,,<empty>,,,,1,,ANY
321598,BLOCK,1,,<empty>,,,,1,,ANY
321602,BLOCK,1,,<empty>,,,,1,,ANY
321606,BLOCK,1,,<empty>,,,,1,,ANY
321613,BLOCK,1,,<empty>,,,,1,,ANY
321616,BLOCK,1,,<empty>,,,,1,,ANY
321623,BLOCK,1,,<empty>,,,,1,,ANY
321628,BLOCK,1,,<empty>,,,,1,,ANY
321632,BLOCK,1,,<empty>,,,,1,,ANY
321636,BLOCK,1,,<empty>,,,,1,,ANY
321640,BLOCK,1,,<empty>,,,,1,,ANY
321644,BLOCK,1,,<empty>,,,,1,,ANY
321648,BLOCK,1,,<empty>,,,,1,,ANY
321652,BLOCK,1,,<empty>,,,,1,,ANY
321657,BLOCK,1,,<empty>,,,,1,,ANY
321662,BLOCK,1,,<empty>,,,,1,,ANY
321666,BLOCK,1,,<empty>,,,,1,,ANY
321672,BLOCK,1,,<empty>,,,,1,,ANY
321678,BLOCK,1,,<empty>,,,,1,,ANY
321682,BLOCK,1,,<empty>,,,,1,,ANY
321688,BLOCK,1,,<empty>,,,,1,,ANY
321692,BLOCK,1,,<empty>,,,,1,,ANY
321696,BLOCK,1,,<empty>,,,,1,,ANY
321702,BLOCK,1,,<empty>,,,,1,,ANY
321707,BLOCK,1,,<empty>,,,,1,,ANY
321710,BLOCK,1,,<empty>,,,,1,,ANY
321714,BLOCK,1,,<empty>,,,,1,,ANY
321719,BLOCK,1,,<empty>,,,,1,,ANY
321723,BLOCK,1,,<empty>,,,,1,,ANY
321727,BLOCK,1,,<empty>,,,,1,,ANY
321731,BLOCK,1,,<empty>,,,,1,,ANY
321735,BLOCK,1,,<empty>,,,,1,,ANY
321739,BLOCK,1,,<empty>,,,,1,,ANY
321743,BLOCK,1,,<empty>,,,,1,,ANY
321746,BLOCK,1,,<empty>,,,,1,,ANY
321751,BLOCK,1,,<empty>,,,,1,,ANY
321755,BLOCK,1,,<empty>,,,,1,,ANY
321759,BLOCK,1,,<empty>,,,,1,,ANY
321762,BLOCK,1,,<empty>,,,,1,,ANY
321766,BLOCK,1,,<empty>,,,,1,,ANY
321770,BLOCK,1,,<empty>,,,,1,,ANY
321775,BLOCK,1,,<empty>,,,,1,,ANY
321781,BLOCK,1,,<empty>,,,,1,,ANY
321786,BLOCK,1,,<empty>,,,,1,,ANY
321791,BLOCK,1,,<empty>,,,,1,,ANY
321795,BLOCK,1,,<empty>,,,,1,,ANY
321800,BLOCK,1,,<empty>,,,,1,,ANY
321805,BLOCK,1,,<empty>,,,,1,,ANY
321812,BLOCK,1,,<empty>,,,,1,,ANY
321816,BLOCK,1,,<empty>,,,,1,,ANY
321819,BLOCK,1,,<empty>,,,,1,,ANY
321823,BLOCK,1,,<empty>,,,,1,,ANY
321827,BLOCK,1,,<empty>,,,,1,,ANY
321831,BLOCK,1,,<empty>,,,,1,,ANY
321835,BLOCK,1,,<empty>,,,,1,,ANY
321839,BLOCK,1,,<empty>,,,,1,,ANY
321843,BLOCK,1,,<empty>,,,,1,,ANY
321849,BLOCK,1,,<empty>,,,,1,,ANY
321854,BLOCK,1,,<empty>,,,,1,,ANY
321857,BLOCK,1,,<empty>,,,,1,,ANY
321861,BLOCK,1,,<empty>,,,,1,,ANY
321864,BLOCK,1,,<empty>,,,,1,,ANY
321870,BLOCK,1,,<empty>,,,,1,,ANY
321874,BLOCK,1,,<empty>,,,,1,,ANY
321878,BLOCK,1,,<empty>,,,,1,,ANY
321883,BLOCK,1,,<empty>,,,,1,,ANY
321887,BLOCK,1,,<empty>,,,,1,,ANY
321891,BLOCK,1,,<empty>,,,,1,,ANY
321895,BLOCK,1,,<empty>,,,,1,,ANY
321899,BLOCK,1,,<empty>,,,,1,,ANY
321903,BLOCK,1,,<empty>,,,,1,,ANY
321906,BLOCK,1,,<empty>,,,,1,,ANY
321916,BLOCK,1,,<empty>,,,,1,,ANY
321921,BLOCK,1,,<empty>,,,,1,,ANY
321925,BLOCK,1,,<empty>,,,,1,,ANY
321932,BLOCK,1,,<empty>,,,,1,,ANY
321939,BLOCK,1,,<empty>,,,,1,,ANY
321942,BLOCK,1,,<empty>,,,,1,,ANY
321946,BLOCK,1,,<empty>,,,,1,,ANY
321949,BLOCK,1,,<empty>,,,,1,,ANY
321955,BLOCK,1,,<empty>,,,,1,,ANY
321960,BLOCK,1,,<empty>,,,,1,,ANY
321965,BLOCK,1,,<empty>,,,,1,,ANY
321970,BLOCK,1,,<empty>,,,,1,,ANY
321974,BLOCK,1,,<empty>,,,,1,,ANY
321981,BLOCK,1,,<empty>,,,,1,,ANY
321985,BLOCK,1,,<empty>,,,,1,,ANY
321989,BLOCK,1,,<empty>,,,,1,,ANY
321993,BLOCK,1,,<empty>,,,,1,,ANY
321998,BLOCK,1,,<empty>,,,,1,,ANY
322001,BLOCK,1,,<empty>,,,,1,,ANY
322005,BLOCK,1,,<empty>,,,,1,,ANY
322010,BLOCK,1,,<empty>,,,,1,,ANY
322014,BLOCK,1,,<empty>,,,,1,,ANY
322018,BLOCK,1,,<empty>,,,,1,,ANY
322021,BLOCK,1,,<empty>,,,,1,,ANY
322025,BLOCK,1,,<empty>,,,,1,,ANY
322028,BLOCK,1,,<empty>,,,,1,,ANY
322031,BLOCK,1,,<empty>,,,,1,,ANY
322035,BLOCK,1,,<empty>,,,,1,,ANY
322039,BLOCK,1,,<empty>,,,,1,,ANY
322043,BLOCK,1,,<empty>,,,,1,,ANY
322047,BLOCK,1,,<empty>,,,,1,,ANY
322051,BLOCK,1,,<empty>,,,,1,,ANY
322055,BLOCK,1,,<empty>,,,,1,,ANY
322060,BLOCK,1,,<empty>,,,,1,,ANY
322064,BLOCK,1,,<empty>,,,,1,,ANY
322070,BLOCK,1,,<empty>,,,,1,,ANY
322078,BLOCK,1,,<empty>,,,,1,,ANY
322083,BLOCK,1,,<empty>,,,,1,,ANY
322087,BLOCK,1,,<empty>,,,,1,,ANY
322091,BLOCK,1,,<empty>,,,,1,,ANY
322096,BLOCK,1,,<empty>,,,,1,,ANY
322101,BLOCK,1,,<empty>,,,,1,,ANY
322106,BLOCK,1,,<empty>,,,,1,,ANY
322111,BLOCK,1,,<empty>,,,,1,,ANY
322117,BLOCK,1,,<empty>,,,,1,,ANY
322122,BLOCK,1,,<empty>,,,,1,,ANY
322127,BLOCK,1,,<empty>,,,,1,,ANY
322135,BLOCK,1,,<empty>,,,,1,,ANY
322139,BLOCK,1,,<empty>,,,,1,,ANY
322147,BLOCK,1,,<empty>,,,,1,,ANY
322151,BLOCK,1,,<empty>,,,,1,,ANY
322156,BLOCK,1,,<empty>,,,,1,,ANY
322160,BLOCK,1,,<empty>,,,,1,,ANY
322164,BLOCK,1,,<empty>,,,,1,,ANY
322168,BLOCK,1,,<empty>,,,,1,,ANY
322172,BLOCK,1,,<empty>,,,,1,,ANY
322176,BLOCK,1,,<empty>,,,,1,,ANY
322182,BLOCK,1,,<empty>,,,,1,,ANY
322186,BLOCK,1,,<empty>,,,,1,,ANY
322192,BLOCK,1,,<empty>,,,,1,,ANY
322196,BLOCK,1,,<empty>,,,,1,,ANY
322200,BLOCK,1,,<empty>,,,,1,,ANY
322204,BLOCK,1,,<empty>,,,,1,,ANY
322208,BLOCK,1,,<empty>,,,,1,,ANY
322214,BLOCK,1,,<empty>,,,,1,,ANY
322221,BLOCK,1,,<empty>,,,,1,,ANY
322227,BLOCK,1,,<empty>,,,,1,,ANY
322231,BLOCK,1,,<empty>,,,,1,,ANY
322235,BLOCK,1,,<empty>,,,,1,,ANY
322241,BLOCK,1,,<empty>,,,,1,,ANY
322244,BLOCK,1,,<empty>,,,,1,,ANY
322248,BLOCK,1,,<empty>,,,,1,,ANY
322253,BLOCK,1,,<empty>,,,,1,,ANY
322257,BLOCK,1,,<empty>,,,,1,,ANY
322263,BLOCK,1,,<empty>,,,,1,,ANY
322270,BLOCK,1,,<empty>,,,,1,,ANY
322273,BLOCK,1,,<empty>,,,,1,,ANY
322278,BLOCK,1,,<empty>,,,,1,,ANY
322284,BLOCK,1,,<empty>,,,,1,,ANY
322288,BLOCK,1,,<empty>,,,,1,,ANY
322293,BLOCK,1,,<empty>,,,,1,,ANY
322296,BLOCK,1,,<empty>,,,,1,,ANY
322301,BLOCK,1,,<empty>,,,,1,,ANY
322305,BLOCK,1,,<empty>,,,,1,,ANY
322309,BLOCK,1,,<empty>,,,,1,,ANY
322312,BLOCK,1,,<empty>,,,,1,,ANY
322315,BLOCK,1,,<empty>,,,,1,,ANY
322320,BLOCK,1,,<empty>,,,,1,,ANY
322327,BLOCK,1,,<empty>,,,,1,,ANY
322330,BLOCK,1,,<empty>,,,,1,,ANY
322335,BLOCK,1,,<empty>,,,,1,,ANY
322340,BLOCK,1,,<empty>,,,,1,,ANY
322343,BLOCK,1,,<empty>,,,,1,,ANY
322346,BLOCK,1,,<empty>,,,,1,,ANY
322349,BLOCK,1,,<empty>,,,,1,,ANY
322356,BLOCK,1,,<empty>,,,,1,,ANY
322360,BLOCK,1,,<empty>,,,,1,,ANY
322367,BLOCK,1,,<empty>,,,,1,,ANY
322371,BLOCK,1,,<empty>,,,,1,,ANY
322377,BLOCK,1,,<empty>,,,,1,,ANY
322381,BLOCK,1,,<empty>,,,,1,,ANY
322387,BLOCK,1,,<empty>,,,,1,,ANY
322391,BLOCK,1,,<empty>,,,,1,,ANY
322398,BLOCK,1,,<empty>,,,,1,,ANY
322402,BLOCK,1,,<empty>,,,,1,,ANY
322406,BLOCK,1,,<empty>,,,,1,,ANY
322410,BLOCK,1,,<empty>,,,,1,,ANY
322418,BLOCK,1,,<empty>,,,,1,,ANY
322421,BLOCK,1,,<empty>,,,,1,,ANY
322424,BLOCK,1,,<empty>,,,,1,,ANY
322427,BLOCK,1,,<empty>,,,,1,,ANY
322430,BLOCK,1,,<empty>,,,,1,,ANY
322435,BLOCK,1,,<empty>,,,,1,,ANY
322440,BLOCK,1,,<empty>,,,,1,,ANY
322444,BLOCK,1,,<empty>,,,,1,,ANY
322448,BLOCK,1,,<empty>,,,,1,,ANY
322458,BLOCK,1,,<empty>,,,,1,,ANY
322463,BLOCK,1,,<empty>,,,,1,,ANY
322466,BLOCK,1,,<empty>,,,,1,,ANY
322471,BLOCK,1,,<empty>,,,,1,,ANY
322476,BLOCK,1,,<empty>,,,,1,,ANY
322480,BLOCK,1,,<empty>,,,,1,,ANY
322484,BLOCK,1,,<empty>,,,,1,,ANY
322488,BLOCK,1,,<empty>,,,,1,,ANY
322492,BLOCK,1,,<empty>,,,,1,,ANY
322497,BLOCK,1,,<empty>,,,,1,,ANY
322501,BLOCK,1,,<empty>,,,,1,,ANY
322505,BLOCK,1,,<empty>,,,,1,,ANY
322510,BLOCK,1,,<empty>,,,,1,,ANY
322514,BLOCK,1,,<empty>,,,,1,,ANY
322518,BLOCK,1,,<empty>,,,,1,,ANY
322523,BLOCK,1,,<empty>,,,,1,,ANY
322527,BLOCK,1,,<empty>,,,,1,,ANY
322531,BLOCK,1,,<empty>,,,,1,,ANY
322535,BLOCK,1,,<empty>,,,,1,,ANY
322538,BLOCK,1,,<empty>,,,,1,,ANY
322542,BLOCK,1,,<empty>,,,,1,,ANY
322546,BLOCK,1,,<empty>,,,,1,,ANY
322554,BLOCK,1,,<empty>,,,,1,,ANY
322561,BLOCK,1,,<empty>,,,,1,,ANY
322566,BLOCK,1,,<empty>,,,,1,,ANY
322570,BLOCK,1,,<empty>,,,,1,,ANY
322576,BLOCK,1,,<empty>,,,,1,,ANY
322580,BLOCK,1,,<empty>,,,,1,,ANY
322585,BLOCK,1,,<empty>,,,,1,,ANY
322590,BLOCK,1,,<empty>,,,,1,,ANY
322594,BLOCK,1,,<empty>,,,,1,,ANY
322599,BLOCK,1,,<empty>,,,,1,,ANY
322603,BLOCK,1,,<empty>,,,,1,,ANY
322610,BLOCK,1,,<empty>,,,,1,,ANY
322614,BLOCK,1,,<empty>,,,,1,,ANY
322618,BLOCK,1,,<empty>,,,,1,,ANY
322624,BLOCK,1,,<empty>,,,,1,,ANY
322629,BLOCK,1,,<empty>,,,,1,,ANY
322635,BLOCK,1,,<empty>,,,,1,,ANY
322640,BLOCK,1,,<empty>,,,,1,,ANY
322645,BLOCK,1,,<empty>,,,,1,,ANY
322650,BLOCK,1,,<empty>,,,,1,,ANY
322654,BLOCK,1,,<empty>,,,,1,,ANY
322658,BLOCK,1,,<empty>,,,,1,,ANY
322664,BLOCK,1,,<empty>,,,,1,,ANY
322667,BLOCK,1,,<empty>,,,,1,,ANY
322674,BLOCK,1,,<empty>,,,,1,,ANY
322678,BLOCK,1,,<empty>,,,,1,,ANY
322683,BLOCK,1,,<empty>,,,,1,,ANY
322687,BLOCK,1,,<empty>,,,,1,,ANY
322691,BLOCK,1,,<empty>,,,,1,,ANY
322697,BLOCK,1,,<empty>,,,,1,,ANY
322703,BLOCK,1,,<empty>,,,,1,,ANY
322708,BLOCK,1,,<empty>,,,,1,,ANY
322714,BLOCK,1,,<empty>,,,,1,,ANY
322718,BLOCK,1,,<empty>,,,,1,,ANY
322723,BLOCK,1,,<empty>,,,,1,,ANY
322726,BLOCK,1,,<empty>,,,,1,,ANY
322730,BLOCK,1,,<empty>,,,,1,,ANY
322736,BLOCK,1,,<empty>,,,,1,,ANY
322742,BLOCK,1,,<empty>,,,,1,,ANY
322747,BLOCK,1,,<empty>,,,,1,,ANY
322753,BLOCK,1,,<empty>,,,,1,,ANY
322760,BLOCK,1,,<empty>,,,,1,,ANY
322764,BLOCK,1,,<empty>,,,,1,,ANY
322769,BLOCK,1,,<empty>,,,,1,,ANY
322773,BLOCK,1,,<empty>,,,,1,,ANY
322777,BLOCK,1,,<empty>,,,,1,,ANY
322783,BLOCK,1,,<empty>,,,,1,,ANY
322790,BLOCK,1,,<empty>,,,,1,,ANY
322794,BLOCK,1,,<empty>,,,,1,,ANY
322799,BLOCK,1,,<empty>,,,,1,,ANY
322804,BLOCK,1,,<empty>,,,,1,,ANY
322808,BLOCK,1,,<empty>,,,,1,,ANY
322816,BLOCK,1,,<empty>,,,,1,,ANY
322820,BLOCK,1,,<empty>,,,,1,,ANY
322824,BLOCK,1,,<empty>,,,,1,,ANY
322828,BLOCK,1,,<empty>,,,,1,,ANY
322831,BLOCK,1,,<empty>,,,,1,,ANY
322835,BLOCK,1,,<empty>,,,,1,,ANY
322839,BLOCK,1,,<empty>,,,,1,,ANY
322843,BLOCK,1,,<empty>,,,,1,,ANY
322846,BLOCK,1,,<empty>,,,,1,,ANY
322855,BLOCK,1,,<empty>,,,,1,,ANY
322859,BLOCK,1,,<empty>,,,,1,,ANY
322864,BLOCK,1,,<empty>,,,,1,,ANY
322868,BLOCK,1,,<empty>,,,,1,,ANY
322871,BLOCK,1,,<empty>,,,,1,,ANY
322878,BLOCK,1,,<empty>,,,,1,,ANY
322884,BLOCK,1,,<empty>,,,,1,,ANY
322890,BLOCK,1,,<empty>,,,,1,,ANY
322896,BLOCK,1,,<empty>,,,,1,,ANY
322901,BLOCK,1,,<empty>,,,,1,,ANY
322907,BLOCK,1,,<empty>,,,,1,,ANY
322913,BLOCK,1,,<empty>,,,,1,,ANY
322919,BLOCK,1,,<empty>,,,,1,,ANY
322925,BLOCK,1,,<empty>,,,,1,,ANY
322931,BLOCK,1,,<empty>,,,,1,,ANY
322934,BLOCK,1,,<empty>,,,,1,,ANY
322939,BLOCK,1,,<empty>,,,,1,,ANY
322944,BLOCK,1,,<empty>,,,,1,,ANY
322950,BLOCK,1,,<empty>,,,,1,,ANY
322956,BLOCK,1,,<empty>,,,,1,,ANY
322962,BLOCK,1,,<empty>,,,,1,,ANY
322967,BLOCK,1,,<empty>,,,,1,,ANY
322973,BLOCK,1,,<empty>,,,,1,,ANY
322979,BLOCK,1,,<empty>,,,,1,,ANY
322985,BLOCK,1,,<empty>,,,,1,,ANY
322989,BLOCK,1,,<empty>,,,,1,,ANY
322993,BLOCK,1,,<empty>,,,,1,,ANY
323000,BLOCK,1,,<empty>,,,,1,,ANY
323005,BLOCK,1,,<empty>,,,,1,,ANY
323012,BLOCK,1,,<empty>,,,,1,,ANY
323021,BLOCK,1,,<empty>,,,,1,,ANY
323026,BLOCK,1,,<empty>,,,,1,,ANY
323031,BLOCK,1,,<empty>,,,,1,,ANY
323035,BLOCK,1,,<empty>,,,,1,,ANY
323039,BLOCK,1,,<empty>,,,,1,,ANY
323045,BLOCK,1,,<empty>,,,,1,,ANY
323052,BLOCK,1,,<empty>,,,,1,,ANY
323057,BLOCK,1,,<empty>,,,,1,,ANY
323062,BLOCK,1,,<empty>,,,,1,,ANY
323066,BLOCK,1,,<empty>,,,,1,,ANY
323072,BLOCK,1,,<empty>,,,,1,,ANY
323078,BLOCK,1,,<empty>,,,,1,,ANY
323084,BLOCK,1,,<empty>,,,,1,,ANY
323088,BLOCK,1,,<empty>,,,,1,,ANY
323093,BLOCK,1,,<empty>,,,,1,,ANY
323097,BLOCK,1,,<empty>,,,,1,,ANY
323104,BLOCK,1,,<empty>,,,,1,,ANY
323108,BLOCK,1,,<empty>,,,,1,,ANY
323112,BLOCK,1,,<empty>,,,,1,,ANY
323120,BLOCK,1,,<empty>,,,,1,,ANY
323124,BLOCK,1,,<empty>,,,,1,,ANY
323127,BLOCK,1,,<empty>,,,,1,,ANY
323131,BLOCK,1,,<empty>,,,,1,,ANY
323135,BLOCK,1,,<empty>,,,,1,,ANY
323140,BLOCK,1,,<empty>,,,,1,,ANY
323144,BLOCK,1,,<empty>,,,,1,,ANY
323148,BLOCK,1,,<empty>,,,,1,,ANY
323153,BLOCK,1,,<empty>,,,,1,,ANY
323158,BLOCK,1,,<empty>,,,,1,,ANY
323162,BLOCK,1,,<empty>,,,,1,,ANY
323173,BLOCK,1,,<empty>,,,,1,,ANY
323176,BLOCK,1,,<empty>,,,,1,,ANY
323182,BLOCK,1,,<empty>,,,,1,,ANY
323186,BLOCK,1,,<empty>,,,,1,,ANY
323193,BLOCK,1,,<empty>,,,,1,,ANY
323199,BLOCK,1,,<empty>,,,,1,,ANY
323206,BLOCK,1,,<empty>,,,,1,,ANY
323210,BLOCK,1,,<empty>,,,,1,,ANY
323217,BLOCK,1,,<empty>,,,,1,,ANY
323221,BLOCK,1,,<empty>,,,,1,,ANY
323226,BLOCK,1,,<empty>,,,,1,,ANY
323231,BLOCK,1,,<empty>,,,,1,,ANY
323237,BLOCK,1,,<empty>,,,,1,,ANY
323241,BLOCK,1,,<empty>,,,,1,,ANY
323246,BLOCK,1,,<empty>,,,,1,,ANY
323251,BLOCK,1,,<empty>,,,,1,,ANY
323258,BLOCK,1,,<empty>,,,,1,,ANY
323262,BLOCK,1,,<empty>,,,,1,,ANY
323266,BLOCK,1,,<empty>,,,,1,,ANY
323271,BLOCK,1,,<empty>,,,,1,,ANY
323276,BLOCK,1,,<empty>,,,,1,,ANY
323282,BLOCK,1,,<empty>,,,,1,,ANY
323286,BLOCK,1,,<empty>,,,,1,,ANY
323290,BLOCK,1,,<empty>,,,,1,,ANY
323294,BLOCK,1,,<empty>,,,,1,,ANY
323298,BLOCK,1,,<empty>,,,,1,,ANY
323302,BLOCK,1,,<empty>,,,,1,,ANY
323308,BLOCK,1,,<empty>,,,,1,,ANY
323312,BLOCK,1,,<empty>,,,,1,,ANY
323319,BLOCK,1,,<empty>,,,,1,,ANY
323322,BLOCK,1,,<empty>,,,,1,,ANY
323327,BLOCK,1,,<empty>,,,,1,,ANY
323332,BLOCK,1,,<empty>,,,,1,,ANY
323336,BLOCK,1,,<empty>,,,,1,,ANY
323347,BLOCK,1,,<empty>,,,,1,,ANY
323358,BLOCK,1,,<empty>,,,,1,,ANY
323363,BLOCK,1,,<empty>,,,,1,,ANY
323368,BLOCK,1,,<empty>,,,,1,,ANY
323371,BLOCK,1,,<empty>,,,,1,,ANY
323376,BLOCK,1,,<empty>,,,,1,,ANY
323380,BLOCK,1,,<empty>,,,,1,,ANY
323385,BLOCK,1,,<empty>,,,,1,,ANY
323390,BLOCK,1,,<empty>,,,,1,,ANY
323394,BLOCK,1,,<empty>,,,,1,,ANY
323400,BLOCK,1,,<empty>,,,,1,,ANY
323404,BLOCK,1,,<empty>,,,,1,,ANY
323412,BLOCK,1,,<empty>,,,,1,,ANY
323417,BLOCK,1,,<empty>,,,,1,,ANY
323424,BLOCK,1,,<empty>,,,,1,,ANY
323428,BLOCK,1,,<empty>,,,,1,,ANY
323432,BLOCK,1,,<empty>,,,,1,,ANY
323436,BLOCK,1,,<empty>,,,,1,,ANY
323443,BLOCK,1,,<empty>,,,,1,,ANY
323448,BLOCK,1,,<empty>,,,,1,,ANY
323453,BLOCK,1,,<empty>,,,,1,,ANY
323457,BLOCK,1,,<empty>,,,,1,,ANY
323461,BLOCK,1,,<empty>,,,,1,,ANY
323467,BLOCK,1,,<empty>,,,,1,,ANY
323471,BLOCK,1,,<empty>,,,,1,,ANY
323477,BLOCK,1,,<empty>,,,,1,,ANY
323481,BLOCK,1,,<empty>,,,,1,,ANY
323487,BLOCK,1,,<empty>,,,,1,,ANY
323491,BLOCK,1,,<empty>,,,,1,,ANY
323495,BLOCK,1,,<empty>,,,,1,,ANY
323499,BLOCK,1,,<empty>,,,,1,,ANY
323503,BLOCK,1,,<empty>,,,,1,,ANY
323507,BLOCK,1,,<empty>,,,,1,,ANY
323511,BLOCK,1,,<empty>,,,,1,,ANY
323515,BLOCK,1,,<empty>,,,,1,,ANY
323519,BLOCK,1,,<empty>,,,,1,,ANY
323525,BLOCK,1,,<empty>,,,,1,,ANY
323530,BLOCK,1,,<empty>,,,,1,,ANY
323537,BLOCK,1,,<empty>,,,,1,,ANY
323543,BLOCK,1,,<empty>,,,,1,,ANY
323550,BLOCK,1,,<empty>,,,,1,,ANY
323555,BLOCK,1,,<empty>,,,,1,,ANY
323562,BLOCK,1,,<empty>,,,,1,,ANY
323569,BLOCK,1,,<empty>,,,,1,,ANY
323575,BLOCK,1,,<empty>,,,,1,,ANY
323580,BLOCK,1,,<empty>,,,,1,,ANY
323585,BLOCK,1,,<empty>,,,,1,,ANY
323594,BLOCK,1,,<empty>,,,,1,,ANY
323598,BLOCK,1,,<empty>,,,,1,,ANY
323602,BLOCK,1,,<empty>,,,,1,,ANY
323606,BLOCK,1,,<empty>,,,,1,,ANY
323610,BLOCK,1,,<empty>,,,,1,,ANY
323614,BLOCK,1,,<empty>,,,,1,,ANY
323618,BLOCK,1,,<empty>,,,,1,,ANY
323629,BLOCK,1,,<empty>,,,,1,,ANY
323635,BLOCK,1,,<empty>,,,,1,,ANY
323640,BLOCK,1,,<empty>,,,,1,,ANY
323644,BLOCK,1,,<empty>,,,,1,,ANY
323650,BLOCK,1,,<empty>,,,,1,,ANY
323655,BLOCK,1,,<empty>,,,,1,,ANY
323659,BLOCK,1,,<empty>,,,,1,,ANY
323663,BLOCK,1,,<empty>,,,,1,,ANY
323667,BLOCK,1,,<empty>,,,,1,,ANY
323671,BLOCK,1,,<empty>,,,,1,,ANY
323676,BLOCK,1,,<empty>,,,,1,,ANY
323680,BLOCK,1,,<empty>,,,,1,,ANY
323684,BLOCK,1,,<empty>,,,,1,,ANY
323692,BLOCK,1,,<empty>,,,,1,,ANY
323698,BLOCK,1,,<empty>,,,,1,,ANY
323703,BLOCK,1,,<empty>,,,,1,,ANY
323709,BLOCK,1,,<empty>,,,,1,,ANY
323715,BLOCK,1,,<empty>,,,,1,,ANY
323721,BLOCK,1,,<empty>,,,,1,,ANY
323726,BLOCK,1,,<empty>,,,,1,,ANY
323730,BLOCK,1,,<empty>,,,,1,,ANY
323735,BLOCK,1,,<empty>,,,,1,,ANY
323740,BLOCK,1,,<empty>,,,,1,,ANY
323745,BLOCK,1,,<empty>,,,,1,,ANY
323748,BLOCK,1,,<empty>,,,,1,,ANY
323751,BLOCK,1,,<empty>,,,,1,,ANY
323754,BLOCK,1,,<empty>,,,,1,,ANY
323757,BLOCK,1,,<empty>,,,,1,,ANY
323760,BLOCK,1,,<empty>,,,,1,,ANY
323764,BLOCK,1,,<empty>,,,,1,,ANY
323768,BLOCK,1,,<empty>,,,,1,,ANY
323774,BLOCK,1,,<empty>,,,,1,,ANY
323778,BLOCK,1,,<empty>,,,,1,,ANY
323783,BLOCK,1,,<empty>,,,,1,,ANY
323790,BLOCK,1,,<empty>,,,,1,,ANY
323794,BLOCK,1,,<empty>,,,,1,,ANY
323797,BLOCK,1,,<empty>,,,,1,,ANY
323802,BLOCK,1,,<empty>,,,,1,,ANY
323805,BLOCK,1,,<empty>,,,,1,,ANY
323809,BLOCK,1,,<empty>,,,,1,,ANY
323812,BLOCK,1,,<empty>,,,,1,,ANY
323815,BLOCK,1,,<empty>,,,,1,,ANY
323826,BLOCK,1,,<empty>,,,,1,,ANY
323833,BLOCK,1,,<empty>,,,,1,,ANY
323836,BLOCK,1,,<empty>,,,,1,,ANY
323847,BLOCK,1,,<empty>,,,,1,,ANY
323852,BLOCK,1,,<empty>,,,,1,,ANY
323857,BLOCK,1,,<empty>,,,,1,,ANY
323864,BLOCK,1,,<empty>,,,,1,,ANY
323877,BLOCK,1,,<empty>,,,,1,,ANY
323882,BLOCK,1,,<empty>,,,,1,,ANY
323886,BLOCK,1,,<empty>,,,,1,,ANY
323890,BLOCK,1,,<empty>,,,,1,,ANY
323894,BLOCK,1,,<empty>,,,,1,,ANY
323899,BLOCK,1,,<empty>,,,,1,,ANY
323904,BLOCK,1,,<empty>,,,,1,,ANY
323908,BLOCK,1,,<empty>,,,,1,,ANY
323919,BLOCK,1,,<empty>,,,,1,,ANY
323924,BLOCK,1,,<empty>,,,,1,,ANY
323933,BLOCK,1,,<empty>,,,,1,,ANY
323941,BLOCK,1,,<empty>,,,,1,,ANY
323945,BLOCK,1,,<empty>,,,,1,,ANY
323956,BLOCK,1,,<empty>,,,,1,,ANY
323967,BLOCK,1,,<empty>,,,,1,,ANY
323971,BLOCK,1,,<empty>,,,,1,,ANY
323977,BLOCK,1,,<empty>,,,,1,,ANY
323983,BLOCK,1,,<empty>,,,,1,,ANY
323988,BLOCK,1,,<empty>,,,,1,,ANY
323992,BLOCK,1,,<empty>,,,,1,,ANY
324003,BLOCK,1,,<empty>,,,,1,,ANY
324014,BLOCK,1,,<empty>,,,,1,,ANY
324019,BLOCK,1,,<empty>,,,,1,,ANY
324024,BLOCK,1,,<empty>,,,,1,,ANY
324028,BLOCK,1,,<empty>,,,,1,,ANY
324031,BLOCK,1,,<empty>,,,,1,,ANY
324036,BLOCK,1,,<empty>,,,,1,,ANY
324040,BLOCK,1,,<empty>,,,,1,,ANY
324043,BLOCK,1,,<empty>,,,,1,,ANY
324048,BLOCK,1,,<empty>,,,,1,,ANY
324053,BLOCK,1,,<empty>,,,,1,,ANY
324059,BLOCK,1,,<empty>,,,,1,,ANY
324063,BLOCK,1,,<empty>,,,,1,,ANY
324068,BLOCK,1,,<empty>,,,,1,,ANY
324072,BLOCK,1,,<empty>,,,,1,,ANY
324076,BLOCK,1,,<empty>,,,,1,,ANY
324079,BLOCK,1,,<empty>,,,,1,,ANY
324083,BLOCK,1,,<empty>,,,,1,,ANY
324088,BLOCK,1,,<empty>,,,,1,,ANY
324093,BLOCK,1,,<empty>,,,,1,,ANY
324098,BLOCK,1,,<empty>,,,,1,,ANY
324102,BLOCK,1,,<empty>,,,,1,,ANY
324107,BLOCK,1,,<empty>,,,,1,,ANY
324111,BLOCK,1,,<empty>,,,,1,,ANY
324115,BLOCK,1,,<empty>,,,,1,,ANY
324120,BLOCK,1,,<empty>,,,,1,,ANY
324126,BLOCK,1,,<empty>,,,,1,,ANY
324130,BLOCK,1,,<empty>,,,,1,,ANY
324142,BLOCK,1,,<empty>,,,,1,,ANY
324147,BLOCK,1,,<empty>,,,,1,,ANY
324152,BLOCK,1,,<empty>,,,,1,,ANY
324156,BLOCK,1,,<empty>,,,,1,,ANY
324162,BLOCK,1,,<empty>,,,,1,,ANY
324166,BLOCK,1,,<empty>,,,,1,,ANY
324171,BLOCK,1,,<empty>,,,,1,,ANY
324176,BLOCK,1,,<empty>,,,,1,,ANY
324181,BLOCK,1,,<empty>,,,,1,,ANY
324186,BLOCK,1,,<empty>,,,,1,,ANY
324190,BLOCK,1,,<empty>,,,,1,,ANY
324197,BLOCK,1,,<empty>,,,,1,,ANY
324201,BLOCK,1,,<empty>,,,,1,,ANY
324205,BLOCK,1,,<empty>,,,,1,,ANY
324210,BLOCK,1,,<empty>,,,,1,,ANY
324215,BLOCK,1,,<empty>,,,,1,,ANY
324219,BLOCK,1,,<empty>,,,,1,,ANY
324224,BLOCK,1,,<empty>,,,,1,,ANY
324228,BLOCK,1,,<empty>,,,,1,,ANY
324232,BLOCK,1,,<empty>,,,,1,,ANY
324236,BLOCK,1,,<empty>,,,,1,,ANY
324240,BLOCK,1,,<empty>,,,,1,,ANY
324245,BLOCK,1,,<empty>,,,,1,,ANY
324250,BLOCK,1,,<empty>,,,,1,,ANY
324257,BLOCK,1,,<empty>,,,,1,,ANY
324261,BLOCK,1,,<empty>,,,,1,,ANY
324265,BLOCK,1,,<empty>,,,,1,,ANY
324270,BLOCK,1,,<empty>,,,,1,,ANY
324275,BLOCK,1,,<empty>,,,,1,,ANY
324280,BLOCK,1,,<empty>,,,,1,,ANY
324283,BLOCK,1,,<empty>,,,,1,,ANY
324287,BLOCK,1,,<empty>,,,,1,,ANY
324291,BLOCK,1,,<empty>,,,,1,,ANY
324295,BLOCK,1,,<empty>,,,,1,,ANY
324299,BLOCK,1,,<empty>,,,,1,,ANY
324304,BLOCK,1,,<empty>,,,,1,,ANY
324309,BLOCK,1,,<empty>,,,,1,,ANY
324314,BLOCK,1,,<empty>,,,,1,,ANY
324320,BLOCK,1,,<empty>,,,,1,,ANY
324328,BLOCK,1,,<empty>,,,,1,,ANY
324332,BLOCK,1,,<empty>,,,,1,,ANY
324336,BLOCK,1,,<empty>,,,,1,,ANY
324339,BLOCK,1,,<empty>,,,,1,,ANY
324345,BLOCK,1,,<empty>,,,,1,,ANY
324352,BLOCK,1,,<empty>,,,,1,,ANY
324356,BLOCK,1,,<empty>,,,,1,,ANY
324360,BLOCK,1,,<empty>,,,,1,,ANY
324365,BLOCK,1,,<empty>,,,,1,,ANY
324372,BLOCK,1,,<empty>,,,,1,,ANY
324379,BLOCK,1,,<empty>,,,,1,,ANY
324384,BLOCK,1,,<empty>,,,,1,,ANY
324389,BLOCK,1,,<empty>,,,,1,,ANY
324394,BLOCK,1,,<empty>,,,,1,,ANY
324399,BLOCK,1,,<empty>,,,,1,,ANY
324404,BLOCK,1,,<empty>,,,,1,,ANY
324409,BLOCK,1,,<empty>,,,,1,,ANY
324413,BLOCK,1,,<empty>,,,,1,,ANY
324417,BLOCK,1,,<empty>,,,,1,,ANY
324421,BLOCK,1,,<empty>,,,,1,,ANY
324425,BLOCK,1,,<empty>,,,,1,,ANY
324429,BLOCK,1,,<empty>,,,,1,,ANY
324434,BLOCK,1,,<empty>,,,,1,,ANY
324439,BLOCK,1,,<empty>,,,,1,,ANY
324446,BLOCK,1,,<empty>,,,,1,,ANY
324450,BLOCK,1,,<empty>,,,,1,,ANY
324454,BLOCK,1,,<empty>,,,,1,,ANY
324458,BLOCK,1,,<empty>,,,,1,,ANY
324461,BLOCK,1,,<empty>,,,,1,,ANY
324465,BLOCK,1,,<empty>,,,,1,,ANY
324470,BLOCK,1,,<empty>,,,,1,,ANY
324474,BLOCK,1,,<empty>,,,,1,,ANY
324479,BLOCK,1,,<empty>,,,,1,,ANY
324483,BLOCK,1,,<empty>,,,,1,,ANY
324487,BLOCK,1,,<empty>,,,,1,,ANY
324491,BLOCK,1,,<empty>,,,,1,,ANY
324495,BLOCK,1,,<empty>,,,,1,,ANY
324503,BLOCK,1,,<empty>,,,,1,,ANY
324507,BLOCK,1,,<empty>,,,,1,,ANY
324512,BLOCK,1,,<empty>,,,,1,,ANY
324517,BLOCK,1,,<empty>,,,,1,,ANY
324521,BLOCK,1,,<empty>,,,,1,,ANY
324525,BLOCK,1,,<empty>,,,,1,,ANY
324528,BLOCK,1,,<empty>,,,,1,,ANY
324532,BLOCK,1,,<empty>,,,,1,,ANY
324538,BLOCK,1,,<empty>,,,,1,,ANY
324542,BLOCK,1,,<empty>,,,,1,,ANY
324545,BLOCK,1,,<empty>,,,,1,,ANY
324556,BLOCK,1,,<empty>,,,,1,,ANY
324559,BLOCK,1,,<empty>,,,,1,,ANY
324570,BLOCK,1,,<empty>,,,,1,,ANY
324574,BLOCK,1,,<empty>,,,,1,,ANY
324578,BLOCK,1,,<empty>,,,,1,,ANY
324582,BLOCK,1,,<empty>,,,,1,,ANY
324587,BLOCK,1,,<empty>,,,,1,,ANY
324591,BLOCK,1,,<empty>,,,,1,,ANY
324595,BLOCK,1,,<empty>,,,,1,,ANY
324599,BLOCK,1,,<empty>,,,,1,,ANY
324603,BLOCK,1,,<empty>,,,,1,,ANY
324607,BLOCK,1,,<empty>,,,,1,,ANY
324611,BLOCK,1,,<empty>,,,,1,,ANY
324615,BLOCK,1,,<empty>,,,,1,,ANY
324621,BLOCK,1,,<empty>,,,,1,,ANY
324625,BLOCK,1,,<empty>,,,,1,,ANY
324628,BLOCK,1,,<empty>,,,,1,,ANY
324634,BLOCK,1,,<empty>,,,,1,,ANY
324638,BLOCK,1,,<empty>,,,,1,,ANY
324642,BLOCK,1,,<empty>,,,,1,,ANY
324655,BLOCK,1,,<empty>,,,,1,,ANY
324659,BLOCK,1,,<empty>,,,,1,,ANY
324664,BLOCK,1,,<empty>,,,,1,,ANY
324669,BLOCK,1,,<empty>,,,,1,,ANY
324673,BLOCK,1,,<empty>,,,,1,,ANY
324678,BLOCK,1,,<empty>,,,,1,,ANY
324682,BLOCK,1,,<empty>,,,,1,,ANY
324686,BLOCK,1,,<empty>,,,,1,,ANY
324690,BLOCK,1,,<empty>,,,,1,,ANY
324695,BLOCK,1,,<empty>,,,,1,,ANY
324701,BLOCK,1,,<empty>,,,,1,,ANY
324706,BLOCK,1,,<empty>,,,,1,,ANY
324710,BLOCK,1,,<empty>,,,,1,,ANY
324721,BLOCK,1,,<empty>,,,,1,,ANY
324732,BLOCK,1,,<empty>,,,,1,,ANY
324737,BLOCK,1,,<empty>,,,,1,,ANY
324748,BLOCK,1,,<empty>,,,,1,,ANY
324752,BLOCK,1,,<empty>,,,,1,,ANY
324762,BLOCK,1,,<empty>,,,,1,,ANY
324767,BLOCK,1,,<empty>,,,,1,,ANY
324771,BLOCK,1,,<empty>,,,,1,,ANY
324782,BLOCK,1,,<empty>,,,,1,,ANY
324793,BLOCK,1,,<empty>,,,,1,,ANY
324798,BLOCK,1,,<empty>,,,,1,,ANY
324802,BLOCK,1,,<empty>,,,,1,,ANY
324813,BLOCK,1,,<empty>,,,,1,,ANY
324824,BLOCK,1,,<empty>,,,,1,,ANY
324835,BLOCK,1,,<empty>,,,,1,,ANY
324839,BLOCK,1,,<empty>,,,,1,,ANY
324850,BLOCK,1,,<empty>,,,,1,,ANY
324861,BLOCK,1,,<empty>,,,,1,,ANY
324866,BLOCK,1,,<empty>,,,,1,,ANY
324870,BLOCK,1,,<empty>,,,,1,,ANY
324881,BLOCK,1,,<empty>,,,,1,,ANY
324892,BLOCK,1,,<empty>,,,,1,,ANY
324899,BLOCK,1,,<empty>,,,,1,,ANY
324904,BLOCK,1,,<empty>,,,,1,,ANY
324908,BLOCK,1,,<empty>,,,,1,,ANY
324923,BLOCK,1,,<empty>,,,,1,,ANY
324934,BLOCK,1,,<empty>,,,,1,,ANY
324945,BLOCK,1,,<empty>,,,,1,,ANY
324950,BLOCK,1,,<empty>,,,,1,,ANY
324955,BLOCK,1,,<empty>,,,,1,,ANY
324960,BLOCK,1,,<empty>,,,,1,,ANY
324964,BLOCK,1,,<empty>,,,,1,,ANY
324975,BLOCK,1,,<empty>,,,,1,,ANY
324986,BLOCK,1,,<empty>,,,,1,,ANY
324991,BLOCK,1,,<empty>,,,,1,,ANY
324995,BLOCK,1,,<empty>,,,,1,,ANY
325006,BLOCK,1,,<empty>,,,,1,,ANY
325017,BLOCK,1,,<empty>,,,,1,,ANY
325022,BLOCK,1,,<empty>,,,,1,,ANY
325027,BLOCK,1,,<empty>,,,,1,,ANY
325032,BLOCK,1,,<empty>,,,,1,,ANY
325036,BLOCK,1,,<empty>,,,,1,,ANY
325047,BLOCK,1,,<empty>,,,,1,,ANY
325058,BLOCK,1,,<empty>,,,,1,,ANY
325069,BLOCK,1,,<empty>,,,,1,,ANY
325073,BLOCK,1,,<empty>,,,,1,,ANY
325084,BLOCK,1,,<empty>,,,,1,,ANY
325095,BLOCK,1,,<empty>,,,,1,,ANY
325106,BLOCK,1,,<empty>,,,,1,,ANY
325110,BLOCK,1,,<empty>,,,,1,,ANY
325121,BLOCK,1,,<empty>,,,,1,,ANY
325132,BLOCK,1,,<empty>,,,,1,,ANY
325143,BLOCK,1,,<empty>,,,,1,,ANY
325147,BLOCK,1,,<empty>,,,,1,,ANY
325158,BLOCK,1,,<empty>,,,,1,,ANY
325169,BLOCK,1,,<empty>,,,,1,,ANY
325174,BLOCK,1,,<empty>,,,,1,,ANY
325178,BLOCK,1,,<empty>,,,,1,,ANY
325189,BLOCK,1,,<empty>,,,,1,,ANY
325200,BLOCK,1,,<empty>,,,,1,,ANY
325205,BLOCK,1,,<empty>,,,,1,,ANY
325209,BLOCK,1,,<empty>,,,,1,,ANY
325220,BLOCK,1,,<empty>,,,,1,,ANY
325231,BLOCK,1,,<empty>,,,,1,,ANY
325236,BLOCK,1,,<empty>,,,,1,,ANY
325240,BLOCK,1,,<empty>,,,,1,,ANY
325248,BLOCK,1,,<empty>,,,,1,,ANY
325252,BLOCK,1,,<empty>,,,,1,,ANY
325260,BLOCK,1,,<empty>,,,,1,,ANY
325271,BLOCK,1,,<empty>,,,,1,,ANY
325279,BLOCK,1,,<empty>,,,,1,,ANY
325290,BLOCK,1,,<empty>,,,,1,,ANY
325295,BLOCK,1,,<empty>,,,,1,,ANY
325299,BLOCK,1,,<empty>,,,,1,,ANY
325310,BLOCK,1,,<empty>,,,,1,,ANY
325321,BLOCK,1,,<empty>,,,,1,,ANY
325326,BLOCK,1,,<empty>,,,,1,,ANY
325331,BLOCK,1,,<empty>,,,,1,,ANY
325335,BLOCK,1,,<empty>,,,,1,,ANY
325346,BLOCK,1,,<empty>,,,,1,,ANY
325357,BLOCK,1,,<empty>,,,,1,,ANY
325363,BLOCK,1,,<empty>,,,,1,,ANY
325374,BLOCK,1,,<empty>,,,,1,,ANY
325385,BLOCK,1,,<empty>,,,,1,,ANY
325396,BLOCK,1,,<empty>,,,,1,,ANY
325407,BLOCK,1,,<empty>,,,,1,,ANY
325412,BLOCK,1,,<empty>,,,,1,,ANY
325417,BLOCK,1,,<empty>,,,,1,,ANY
325421,BLOCK,1,,<empty>,,,,1,,ANY
325426,BLOCK,1,,<empty>,,,,1,,ANY
325430,BLOCK,1,,<empty>,,,,1,,ANY
325441,BLOCK,1,,<empty>,,,,1,,ANY
325452,BLOCK,1,,<empty>,,,,1,,ANY
325459,BLOCK,1,,<empty>,,,,1,,ANY
325463,BLOCK,1,,<empty>,,,,1,,ANY
325474,BLOCK,1,,<empty>,,,,1,,ANY
325478,BLOCK,1,,<empty>,,,,1,,ANY
325489,BLOCK,1,,<empty>,,,,1,,ANY
325502,BLOCK,1,,<empty>,,,,1,,ANY
325506,BLOCK,1,,<empty>,,,,1,,ANY
325510,BLOCK,1,,<empty>,,,,1,,ANY
325514,BLOCK,1,,<empty>,,,,1,,ANY
325517,BLOCK,1,,<empty>,,,,1,,ANY
325521,BLOCK,1,,<empty>,,,,1,,ANY
325525,BLOCK,1,,<empty>,,,,1,,ANY
325532,BLOCK,1,,<empty>,,,,1,,ANY
325536,BLOCK,1,,<empty>,,,,1,,ANY
325540,BLOCK,1,,<empty>,,,,1,,ANY
325551,BLOCK,1,,<empty>,,,,1,,ANY
325555,BLOCK,1,,<empty>,,,,1,,ANY
325568,BLOCK,1,,<empty>,,,,1,,ANY
325573,BLOCK,1,,<empty>,,,,1,,ANY
325577,BLOCK,1,,<empty>,,,,1,,ANY
325588,BLOCK,1,,<empty>,,,,1,,ANY
325599,BLOCK,1,,<empty>,,,,1,,ANY
325610,BLOCK,1,,<empty>,,,,1,,ANY
325614,BLOCK,1,,<empty>,,,,1,,ANY
325625,BLOCK,1,,<empty>,,,,1,,ANY
325636,BLOCK,1,,<empty>,,,,1,,ANY
325641,BLOCK,1,,<empty>,,,,1,,ANY
325645,BLOCK,1,,<empty>,,,,1,,ANY
325656,BLOCK,1,,<empty>,,,,1,,ANY
325667,BLOCK,1,,<empty>,,,,1,,ANY
325678,BLOCK,1,,<empty>,,,,1,,ANY
325682,BLOCK,1,,<empty>,,,,1,,ANY
325693,BLOCK,1,,<empty>,,,,1,,ANY
325704,BLOCK,1,,<empty>,,,,1,,ANY
325709,BLOCK,1,,<empty>,,,,1,,ANY
325713,BLOCK,1,,<empty>,,,,1,,ANY
325724,BLOCK,1,,<empty>,,,,1,,ANY
325735,BLOCK,1,,<empty>,,,,1,,ANY
325740,BLOCK,1,,<empty>,,,,1,,ANY
325744,BLOCK,1,,<empty>,,,,1,,ANY
325755,BLOCK,1,,<empty>,,,,1,,ANY
325766,BLOCK,1,,<empty>,,,,1,,ANY
325777,BLOCK,1,,<empty>,,,,1,,ANY
325781,BLOCK,1,,<empty>,,,,1,,ANY
325792,BLOCK,1,,<empty>,,,,1,,ANY
325803,BLOCK,1,,<empty>,,,,1,,ANY
325808,BLOCK,1,,<empty>,,,,1,,ANY
325812,BLOCK,1,,<empty>,,,,1,,ANY
325823,BLOCK,1,,<empty>,,,,1,,ANY
325834,BLOCK,1,,<empty>,,,,1,,ANY
325839,BLOCK,1,,<empty>,,,,1,,ANY
325844,BLOCK,1,,<empty>,,,,1,,ANY
325848,BLOCK,1,,<empty>,,,,1,,ANY
325859,BLOCK,1,,<empty>,,,,1,,ANY
325870,BLOCK,1,,<empty>,,,,1,,ANY
325874,BLOCK,1,,<empty>,,,,1,,ANY
325878,BLOCK,1,,<empty>,,,,1,,ANY
325883,BLOCK,1,,<empty>,,,,1,,ANY
325888,BLOCK,1,,<empty>,,,,1,,ANY
325894,BLOCK,1,,<empty>,,,,1,,ANY
325899,BLOCK,1,,<empty>,,,,1,,ANY
325904,BLOCK,1,,<empty>,,,,1,,ANY
325909,BLOCK,1,,<empty>,,,,1,,ANY
325915,BLOCK,1,,<empty>,,,,1,,ANY
325920,BLOCK,1,,<empty>,,,,1,,ANY
325925,BLOCK,1,,<empty>,,,,1,,ANY
325930,BLOCK,1,,<empty>,,,,1,,ANY
325935,BLOCK,1,,<empty>,,,,1,,ANY
325941,BLOCK,1,,<empty>,,,,1,,ANY
325947,BLOCK,1,,<empty>,,,,1,,ANY
325952,BLOCK,1,,<empty>,,,,1,,ANY
325957,BLOCK,1,,<empty>,,,,1,,ANY
325962,BLOCK,1,,<empty>,,,,1,,ANY
325967,BLOCK,1,,<empty>,,,,1,,ANY
325971,BLOCK,1,,<empty>,,,,1,,ANY
325976,BLOCK,1,,<empty>,,,,1,,ANY
325981,BLOCK,1,,<empty>,,,,1,,ANY
325986,BLOCK,1,,<empty>,,,,1,,ANY
325990,BLOCK,1,,<empty>,,,,1,,ANY
325995,BLOCK,1,,<empty>,,,,1,,ANY
325999,BLOCK,1,,<empty>,,,,1,,ANY
326002,BLOCK,1,,<empty>,,,,1,,ANY
326006,BLOCK,1,,<empty>,,,,1,,ANY
326011,BLOCK,1,,<empty>,,,,1,,ANY
326015,BLOCK,1,,<empty>,,,,1,,ANY
326019,BLOCK,1,,<empty>,,,,1,,ANY
326024,BLOCK,1,,<empty>,,,,1,,ANY
326027,BLOCK,1,,<empty>,,,,1,,ANY
326031,BLOCK,1,,<empty>,,,,1,,ANY
326036,BLOCK,1,,<empty>,,,,1,,ANY
326041,BLOCK,1,,<empty>,,,,1,,ANY
326046,BLOCK,1,,<empty>,,,,1,,ANY
326051,BLOCK,1,,<empty>,,,,1,,ANY
326056,BLOCK,1,,<empty>,,,,1,,ANY
326061,BLOCK,1,,<empty>,,,,1,,ANY
326066,BLOCK,1,,<empty>,,,,1,,ANY
326070,BLOCK,1,,<empty>,,,,1,,ANY
326074,BLOCK,1,,<empty>,,,,1,,ANY
326078,BLOCK,1,,<empty>,,,,1,,ANY
326082,BLOCK,1,,<empty>,,,,1,,ANY
326086,BLOCK,1,,<empty>,,,,1,,ANY
326091,BLOCK,1,,<empty>,,,,1,,ANY
326095,BLOCK,1,,<empty>,,,,1,,ANY
326101,BLOCK,1,,<empty>,,,,1,,ANY
326108,BLOCK,1,,<empty>,,,,1,,ANY
326112,BLOCK,1,,<empty>,,,,1,,ANY
326119,BLOCK,1,,<empty>,,,,1,,ANY
326126,BLOCK,1,,<empty>,,,,1,,ANY
326131,BLOCK,1,,<empty>,,,,1,,ANY
326135,BLOCK,1,,<empty>,,,,1,,ANY
326140,BLOCK,1,,<empty>,,,,1,,ANY
326145,BLOCK,1,,<empty>,,,,1,,ANY
326150,BLOCK,1,,<empty>,,,,1,,ANY
326155,BLOCK,1,,<empty>,,,,1,,ANY
326160,BLOCK,1,,<empty>,,,,1,,ANY
326165,BLOCK,1,,<empty>,,,,1,,ANY
326170,BLOCK,1,,<empty>,,,,1,,ANY
326175,BLOCK,1,,<empty>,,,,1,,ANY
326180,BLOCK,1,,<empty>,,,,1,,ANY
326185,BLOCK,1,,<empty>,,,,1,,ANY
326190,BLOCK,1,,<empty>,,,,1,,ANY
326195,BLOCK,1,,<empty>,,,,1,,ANY
326199,BLOCK,1,,<empty>,,,,1,,ANY
326204,BLOCK,1,,<empty>,,,,1,,ANY
326208,BLOCK,1,,<empty>,,,,1,,ANY
326212,BLOCK,1,,<empty>,,,,1,,ANY
326216,BLOCK,1,,<empty>,,,,1,,ANY
326220,BLOCK,1,,<empty>,,,,1,,ANY
326224,BLOCK,1,,<empty>,,,,1,,ANY
326228,BLOCK,1,,<empty>,,,,1,,ANY
326232,BLOCK,1,,<empty>,,,,1,,ANY
326235,BLOCK,1,,<empty>,,,,1,,ANY
326239,BLOCK,1,,<empty>,,,,1,,ANY
326243,BLOCK,1,,<empty>,,,,1,,ANY
326246,BLOCK,1,,<empty>,,,,1,,ANY
326249,BLOCK,1,,<empty>,,,,1,,ANY
326253,BLOCK,1,,<empty>,,,,1,,ANY
326257,BLOCK,1,,<empty>,,,,1,,ANY
326261,BLOCK,1,,<empty>,,,,1,,ANY
326264,BLOCK,1,,<empty>,,,,1,,ANY
326268,BLOCK,1,,<empty>,,,,1,,ANY
326272,BLOCK,1,,<empty>,,,,1,,ANY
326276,BLOCK,1,,<empty>,,,,1,,ANY
326279,BLOCK,1,,<empty>,,,,1,,ANY
326283,BLOCK,1,,<empty>,,,,1,,ANY
326287,BLOCK,1,,<empty>,,,,1,,ANY
326291,BLOCK,1,,<empty>,,,,1,,ANY
326295,BLOCK,1,,<empty>,,,,1,,ANY
326299,BLOCK,1,,<empty>,,,,1,,ANY
326303,BLOCK,1,,<empty>,,,,1,,ANY
326307,BLOCK,1,,<empty>,,,,1,,ANY
326311,BLOCK,1,,<empty>,,,,1,,ANY
326315,BLOCK,1,,<empty>,,,,1,,ANY
326318,BLOCK,1,,<empty>,,,,1,,ANY
326321,BLOCK,1,,<empty>,,,,1,,ANY
326324,BLOCK,1,,<empty>,,,,1,,ANY
326329,BLOCK,1,,<empty>,,,,1,,ANY
326332,BLOCK,1,,<empty>,,,,1,,ANY
326335,BLOCK,1,,<empty>,,,,1,,ANY
326339,BLOCK,1,,<empty>,,,,1,,ANY
326342,BLOCK,1,,<empty>,,,,1,,ANY
326346,BLOCK,1,,<empty>,,,,1,,ANY
326349,BLOCK,1,,<empty>,,,,1,,ANY
326352,BLOCK,1,,<empty>,,,,1,,ANY
326357,BLOCK,1,,<empty>,,,,1,,ANY
326361,BLOCK,1,,<empty>,,,,1,,ANY
326366,BLOCK,1,,<empty>,,,,1,,ANY
326370,BLOCK,1,,<empty>,,,,1,,ANY
326375,BLOCK,1,,<empty>,,,,1,,ANY
326379,BLOCK,1,,<empty>,,,,1,,ANY
326383,BLOCK,1,,<empty>,,,,1,,ANY
326387,BLOCK,1,,<empty>,,,,1,,ANY
326393,BLOCK,1,,<empty>,,,,1,,ANY
326396,BLOCK,1,,<empty>,,,,1,,ANY
326399,BLOCK,1,,<empty>,,,,1,,ANY
326403,BLOCK,1,,<empty>,,,,1,,ANY
326407,BLOCK,1,,<empty>,,,,1,,ANY
326411,BLOCK,1,,<empty>,,,,1,,ANY
326419,BLOCK,1,,<empty>,,,,1,,ANY
326426,BLOCK,1,,<empty>,,,,1,,ANY
326431,BLOCK,1,,<empty>,,,,1,,ANY
326438,BLOCK,1,,<empty>,,,,1,,ANY
326443,BLOCK,1,,<empty>,,,,1,,ANY
326448,BLOCK,1,,<empty>,,,,1,,ANY
326453,BLOCK,1,,<empty>,,,,1,,ANY
326458,BLOCK,1,,<empty>,,,,1,,ANY
326463,BLOCK,1,,<empty>,,,,1,,ANY
326468,BLOCK,1,,<empty>,,,,1,,ANY
326473,BLOCK,1,,<empty>,,,,1,,ANY
326478,BLOCK,1,,<empty>,,,,1,,ANY
326483,BLOCK,1,,<empty>,,,,1,,ANY
326487,BLOCK,1,,<empty>,,,,1,,ANY
326491,BLOCK,1,,<empty>,,,,1,,ANY
326495,BLOCK,1,,<empty>,,,,1,,ANY
326500,BLOCK,1,,<empty>,,,,1,,ANY
326504,BLOCK,1,,<empty>,,,,1,,ANY
326508,BLOCK,1,,<empty>,,,,1,,ANY
326513,BLOCK,1,,<empty>,,,,1,,ANY
326516,BLOCK,1,,<empty>,,,,1,,ANY
326522,BLOCK,1,,<empty>,,,,1,,ANY
326525,BLOCK,1,,<empty>,,,,1,,ANY
326531,BLOCK,1,,<empty>,,,,1,,ANY
326537,BLOCK,1,,<empty>,,,,1,,ANY
326541,BLOCK,1,,<empty>,,,,1,,ANY
326549,BLOCK,1,,<empty>,,,,1,,ANY
326553,BLOCK,1,,<empty>,,,,1,,ANY
326557,BLOCK,1,,<empty>,,,,1,,ANY
326562,BLOCK,1,,<empty>,,,,1,,ANY
326566,BLOCK,1,,<empty>,,,,1,,ANY
326570,BLOCK,1,,<empty>,,,,1,,ANY
326574,BLOCK,1,,<empty>,,,,1,,ANY
326578,BLOCK,1,,<empty>,,,,1,,ANY
326582,BLOCK,1,,<empty>,,,,1,,ANY
326586,BLOCK,1,,<empty>,,,,1,,ANY
326590,BLOCK,1,,<empty>,,,,1,,ANY
326594,BLOCK,1,,<empty>,,,,1,,ANY
326598,BLOCK,1,,<empty>,,,,1,,ANY
326601,BLOCK,1,,<empty>,,,,1,,ANY
326605,BLOCK,1,,<empty>,,,,1,,ANY
326609,BLOCK,1,,<empty>,,,,1,,ANY
326612,BLOCK,1,,<empty>,,,,1,,ANY
326616,BLOCK,1,,<empty>,,,,1,,ANY
326620,BLOCK,1,,<empty>,,,,1,,ANY
326623,BLOCK,1,,<empty>,,,,1,,ANY
326626,BLOCK,1,,<empty>,,,,1,,ANY
326631,BLOCK,1,,<empty>,,,,1,,ANY
326635,BLOCK,1,,<empty>,,,,1,,ANY
326638,BLOCK,1,,<empty>,,,,1,,ANY
326643,BLOCK,1,,<empty>,,,,1,,ANY
326649,BLOCK,1,,<empty>,,,,1,,ANY
326652,BLOCK,1,,<empty>,,,,1,,ANY
326657,BLOCK,1,,<empty>,,,,1,,ANY
326666,BLOCK,1,,<empty>,,,,1,,ANY
326670,BLOCK,1,,<empty>,,,,1,,ANY
326674,BLOCK,1,,<empty>,,,,1,,ANY
326679,BLOCK,1,,<empty>,,,,1,,ANY
326683,BLOCK,1,,<empty>,,,,1,,ANY
326688,BLOCK,1,,<empty>,,,,1,,ANY
326691,BLOCK,1,,<empty>,,,,1,,ANY
326694,BLOCK,1,,<empty>,,,,1,,ANY
326699,BLOCK,1,,<empty>,,,,1,,ANY
326704,BLOCK,1,,<empty>,,,,1,,ANY
326709,BLOCK,1,,<empty>,,,,1,,ANY
326713,BLOCK,1,,<empty>,,,,1,,ANY
326721,BLOCK,1,,<empty>,,,,1,,ANY
326731,BLOCK,1,,<empty>,,,,1,,ANY
326735,BLOCK,1,,<empty>,,,,1,,ANY
326742,BLOCK,1,,<empty>,,,,1,,ANY
326749,BLOCK,1,,<empty>,,,,1,,ANY
326755,BLOCK,1,,<empty>,,,,1,,ANY
326762,BLOCK,1,,<empty>,,,,1,,ANY
326766,BLOCK,1,,<empty>,,,,1,,ANY
326771,BLOCK,1,,<empty>,,,,1,,ANY
326780,BLOCK,1,,<empty>,,,,1,,ANY
326783,BLOCK,1,,<empty>,,,,1,,ANY
326786,BLOCK,1,,<empty>,,,,1,,ANY
326790,BLOCK,1,,<empty>,,,,1,,ANY
326795,BLOCK,1,,<empty>,,,,1,,ANY
326802,BLOCK,1,,<empty>,,,,1,,ANY
326807,BLOCK,1,,<empty>,,,,1,,ANY
326812,BLOCK,1,,<empty>,,,,1,,ANY
326818,BLOCK,1,,<empty>,,,,1,,ANY
326822,BLOCK,1,,<empty>,,,,1,,ANY
326826,BLOCK,1,,<empty>,,,,1,,ANY
326830,BLOCK,1,,<empty>,,,,1,,ANY
326835,BLOCK,1,,<empty>,,,,1,,ANY
326840,BLOCK,1,,<empty>,,,,1,,ANY
326845,BLOCK,1,,<empty>,,,,1,,ANY
326852,BLOCK,1,,<empty>,,,,1,,ANY
326858,BLOCK,1,,<empty>,,,,1,,ANY
326862,BLOCK,1,,<empty>,,,,1,,ANY
326866,BLOCK,1,,<empty>,,,,1,,ANY
326870,BLOCK,1,,<empty>,,,,1,,ANY
326874,BLOCK,1,,<empty>,,,,1,,ANY
326878,BLOCK,1,,<empty>,,,,1,,ANY
326882,BLOCK,1,,<empty>,,,,1,,ANY
326886,BLOCK,1,,<empty>,,,,1,,ANY
326890,BLOCK,1,,<empty>,,,,1,,ANY
326894,BLOCK,1,,<empty>,,,,1,,ANY
326899,BLOCK,1,,<empty>,,,,1,,ANY
326907,BLOCK,1,,<empty>,,,,1,,ANY
326914,BLOCK,1,,<empty>,,,,1,,ANY
326919,BLOCK,1,,<empty>,,,,1,,ANY
326928,BLOCK,1,,<empty>,,,,1,,ANY
326936,BLOCK,1,,<empty>,,,,1,,ANY
326940,BLOCK,1,,<empty>,,,,1,,ANY
326946,BLOCK,1,,<empty>,,,,1,,ANY
326951,BLOCK,1,,<empty>,,,,1,,ANY
326956,BLOCK,1,,<empty>,,,,1,,ANY
326963,BLOCK,1,,<empty>,,,,1,,ANY
326969,BLOCK,1,,<empty>,,,,1,,ANY
326973,BLOCK,1,,<empty>,,,,1,,ANY
326977,BLOCK,1,,<empty>,,,,1,,ANY
326981,BLOCK,1,,<empty>,,,,1,,ANY
326986,BLOCK,1,,<empty>,,,,1,,ANY
326991,BLOCK,1,,<empty>,,,,1,,ANY
326996,BLOCK,1,,<empty>,,,,1,,ANY
327006,BLOCK,1,,<empty>,,,,1,,ANY
327013,BLOCK,1,,<empty>,,,,1,,ANY
327022,BLOCK,1,,<empty>,,,,1,,ANY
327027,BLOCK,1,,<empty>,,,,1,,ANY
327033,BLOCK,1,,<empty>,,,,1,,ANY
327039,BLOCK,1,,<empty>,,,,1,,ANY
327044,BLOCK,1,,<empty>,,,,1,,ANY
327048,BLOCK,1,,<empty>,,,,1,,ANY
327052,BLOCK,1,,<empty>,,,,1,,ANY
327058,BLOCK,1,,<empty>,,,,1,,ANY
327062,BLOCK,1,,<empty>,,,,1,,ANY
327066,BLOCK,1,,<empty>,,,,1,,ANY
327070,BLOCK,1,,<empty>,,,,1,,ANY
327074,BLOCK,1,,<empty>,,,,1,,ANY
327078,BLOCK,1,,<empty>,,,,1,,ANY
327082,BLOCK,1,,<empty>,,,,1,,ANY
327086,BLOCK,1,,<empty>,,,,1,,ANY
327090,BLOCK,1,,<empty>,,,,1,,ANY
327094,BLOCK,1,,<empty>,,,,1,,ANY
327098,BLOCK,1,,<empty>,,,,1,,ANY
327102,BLOCK,1,,<empty>,,,,1,,ANY
327106,BLOCK,1,,<empty>,,,,1,,ANY
327111,BLOCK,1,,<empty>,,,,1,,ANY
327115,BLOCK,1,,<empty>,,,,1,,ANY
327119,BLOCK,1,,<empty>,,,,1,,ANY
327123,BLOCK,1,,<empty>,,,,1,,ANY
327127,BLOCK,1,,<empty>,,,,1,,ANY
327131,BLOCK,1,,<empty>,,,,1,,ANY
327135,BLOCK,1,,<empty>,,,,1,,ANY
327143,BLOCK,1,,<empty>,,,,1,,ANY
327151,BLOCK,1,,<empty>,,,,1,,ANY
327159,BLOCK,1,,<empty>,,,,1,,ANY
327167,BLOCK,1,,<empty>,,,,1,,ANY
327175,BLOCK,1,,<empty>,,,,1,,ANY
327183,BLOCK,1,,<empty>,,,,1,,ANY
327191,BLOCK,1,,<empty>,,,,1,,ANY
327199,BLOCK,1,,<empty>,,,,1,,ANY
327207,BLOCK,1,,<empty>,,,,1,,ANY
327215,BLOCK,1,,<empty>,,,,1,,ANY
327220,BLOCK,1,,<empty>,,,,1,,ANY
327225,BLOCK,1,,<empty>,,,,1,,ANY
327230,BLOCK,1,,<empty>,,,,1,,ANY
327234,BLOCK,1,,<empty>,,,,1,,ANY
327242,BLOCK,1,,<empty>,,,,1,,ANY
327248,BLOCK,1,,<empty>,,,,1,,ANY
327253,BLOCK,1,,<empty>,,,,1,,ANY
327258,BLOCK,1,,<empty>,,,,1,,ANY
327264,BLOCK,1,,<empty>,,,,1,,ANY
327268,BLOCK,1,,<empty>,,,,1,,ANY
327271,BLOCK,1,,<empty>,,,,1,,ANY
327275,BLOCK,1,,<empty>,,,,1,,ANY
327279,BLOCK,1,,<empty>,,,,1,,ANY
327283,BLOCK,1,,<empty>,,,,1,,ANY
327286,BLOCK,1,,<empty>,,,,1,,ANY
327289,BLOCK,1,,<empty>,,,,1,,ANY
327293,BLOCK,1,,<empty>,,,,1,,ANY
327298,BLOCK,1,,<empty>,,,,1,,ANY
327302,BLOCK,1,,<empty>,,,,1,,ANY
327307,BLOCK,1,,<empty>,,,,1,,ANY
327311,BLOCK,1,,<empty>,,,,1,,ANY
327316,BLOCK,1,,<empty>,,,,1,,ANY
327321,BLOCK,1,,<empty>,,,,1,,ANY
327326,BLOCK,1,,<empty>,,,,1,,ANY
327330,BLOCK,1,,<empty>,,,,1,,ANY
327334,BLOCK,1,,<empty>,,,,1,,ANY
327338,BLOCK,1,,<empty>,,,,1,,ANY
327342,BLOCK,1,,<empty>,,,,1,,ANY
327345,BLOCK,1,,<empty>,,,,1,,ANY
327349,BLOCK,1,,<empty>,,,,1,,ANY
327353,BLOCK,1,,<empty>,,,,1,,ANY
327357,BLOCK,1,,<empty>,,,,1,,ANY
327361,BLOCK,1,,<empty>,,,,1,,ANY
327366,BLOCK,1,,<empty>,,,,1,,ANY
327370,BLOCK,1,,<empty>,,,,1,,ANY
327375,BLOCK,1,,<empty>,,,,1,,ANY
327380,BLOCK,1,,<empty>,,,,1,,ANY
327385,BLOCK,1,,<empty>,,,,1,,ANY
327390,BLOCK,1,,<empty>,,,,1,,ANY
327395,BLOCK,1,,<empty>,,,,1,,ANY
327399,BLOCK,1,,<empty>,,,,1,,ANY
327403,BLOCK,1,,<empty>,,,,1,,ANY
327407,BLOCK,1,,<empty>,,,,1,,ANY
327411,BLOCK,1,,<empty>,,,,1,,ANY
327415,BLOCK,1,,<empty>,,,,1,,ANY
327419,BLOCK,1,,<empty>,,,,1,,ANY
327423,BLOCK,1,,<empty>,,,,1,,ANY
327428,BLOCK,1,,<empty>,,,,1,,ANY
327432,BLOCK,1,,<empty>,,,,1,,ANY
327436,BLOCK,1,,<empty>,,,,1,,ANY
327441,BLOCK,1,,<empty>,,,,1,,ANY
327446,BLOCK,1,,<empty>,,,,1,,ANY
327452,BLOCK,1,,<empty>,,,,1,,ANY
327456,BLOCK,1,,<empty>,,,,1,,ANY
327460,BLOCK,1,,<empty>,,,,1,,ANY
327464,BLOCK,1,,<empty>,,,,1,,ANY
327470,BLOCK,1,,<empty>,,,,1,,ANY
327474,BLOCK,1,,<empty>,,,,1,,ANY
327480,BLOCK,1,,<empty>,,,,1,,ANY
327485,BLOCK,1,,<empty>,,,,1,,ANY
327491,BLOCK,1,,<empty>,,,,1,,ANY
327495,BLOCK,1,,<empty>,,,,1,,ANY
327500,BLOCK,1,,<empty>,,,,1,,ANY
327505,BLOCK,1,,<empty>,,,,1,,ANY
327509,BLOCK,1,,<empty>,,,,1,,ANY
327513,BLOCK,1,,<empty>,,,,1,,ANY
327520,BLOCK,1,,<empty>,,,,1,,ANY
327525,BLOCK,1,,<empty>,,,,1,,ANY
327531,BLOCK,1,,<empty>,,,,1,,ANY
327535,BLOCK,1,,<empty>,,,,1,,ANY
327539,BLOCK,1,,<empty>,,,,1,,ANY
327543,BLOCK,1,,<empty>,,,,1,,ANY
327548,BLOCK,1,,<empty>,,,,1,,ANY
327553,BLOCK,1,,<empty>,,,,1,,ANY
327557,BLOCK,1,,<empty>,,,,1,,ANY
327562,BLOCK,1,,<empty>,,,,1,,ANY
327566,BLOCK,1,,<empty>,,,,1,,ANY
327572,BLOCK,1,,<empty>,,,,1,,ANY
327577,BLOCK,1,,<empty>,,,,1,,ANY
327581,BLOCK,1,,<empty>,,,,1,,ANY
327586,BLOCK,1,,<empty>,,,,1,,ANY
327590,BLOCK,1,,<empty>,,,,1,,ANY
327594,BLOCK,1,,<empty>,,,,1,,ANY
327599,BLOCK,1,,<empty>,,,,1,,ANY
327603,BLOCK,1,,<empty>,,,,1,,ANY
327607,BLOCK,1,,<empty>,,,,1,,ANY
327611,BLOCK,1,,<empty>,,,,1,,ANY
327615,BLOCK,1,,<empty>,,,,1,,ANY
327619,BLOCK,1,,<empty>,,,,1,,ANY
327623,BLOCK,1,,<empty>,,,,1,,ANY
327628,BLOCK,1,,<empty>,,,,1,,ANY
327632,BLOCK,1,,<empty>,,,,1,,ANY
327635,BLOCK,1,,<empty>,,,,1,,ANY
327639,BLOCK,1,,<empty>,,,,1,,ANY
327643,BLOCK,1,,<empty>,,,,1,,ANY
327647,BLOCK,1,,<empty>,,,,1,,ANY
327651,BLOCK,1,,<empty>,,,,1,,ANY
327655,BLOCK,1,,<empty>,,,,1,,ANY
327660,BLOCK,1,,<empty>,,,,1,,ANY
327664,BLOCK,1,,<empty>,,,,1,,ANY
327668,BLOCK,1,,<empty>,,,,1,,ANY
327672,BLOCK,1,,<empty>,,,,1,,ANY
327677,BLOCK,1,,<empty>,,,,1,,ANY
327683,BLOCK,1,,<empty>,,,,1,,ANY
327687,BLOCK,1,,<empty>,,,,1,,ANY
327691,BLOCK,1,,<empty>,,,,1,,ANY
327698,BLOCK,1,,<empty>,,,,1,,ANY
327702,BLOCK,1,,<empty>,,,,1,,ANY
327707,BLOCK,1,,<empty>,,,,1,,ANY
327711,BLOCK,1,,<empty>,,,,1,,ANY
327715,BLOCK,1,,<empty>,,,,1,,ANY
327722,BLOCK,1,,<empty>,,,,1,,ANY
327726,BLOCK,1,,<empty>,,,,1,,ANY
327734,BLOCK,1,,<empty>,,,,1,,ANY
327738,BLOCK,1,,<empty>,,,,1,,ANY
327744,BLOCK,1,,<empty>,,,,1,,ANY
327748,BLOCK,1,,<empty>,,,,1,,ANY
327753,BLOCK,1,,<empty>,,,,1,,ANY
327757,BLOCK,1,,<empty>,,,,1,,ANY
327761,BLOCK,1,,<empty>,,,,1,,ANY
327765,BLOCK,1,,<empty>,,,,1,,ANY
327769,BLOCK,1,,<empty>,,,,1,,ANY
327773,BLOCK,1,,<empty>,,,,1,,ANY
327778,BLOCK,1,,<empty>,,,,1,,ANY
327782,BLOCK,1,,<empty>,,,,1,,ANY
327785,BLOCK,1,,<empty>,,,,1,,ANY
327789,BLOCK,1,,<empty>,,,,1,,ANY
327793,BLOCK,1,,<empty>,,,,1,,ANY
327797,BLOCK,1,,<empty>,,,,1,,ANY
327801,BLOCK,1,,<empty>,,,,1,,ANY
327805,BLOCK,1,,<empty>,,,,1,,ANY
327810,BLOCK,1,,<empty>,,,,1,,ANY
327815,BLOCK,1,,<empty>,,,,1,,ANY
327820,BLOCK,1,,<empty>,,,,1,,ANY
327826,BLOCK,1,,<empty>,,,,1,,ANY
327830,BLOCK,1,,<empty>,,,,1,,ANY
327834,BLOCK,1,,<empty>,,,,1,,ANY
327839,BLOCK,1,,<empty>,,,,1,,ANY
327842,BLOCK,1,,<empty>,,,,1,,ANY
327846,BLOCK,1,,<empty>,,,,1,,ANY
327849,BLOCK,1,,<empty>,,,,1,,ANY
327852,BLOCK,1,,<empty>,,,,1,,ANY
327855,BLOCK,1,,<empty>,,,,1,,ANY
327858,BLOCK,1,,<empty>,,,,1,,ANY
327861,BLOCK,1,,<empty>,,,,1,,ANY
327864,BLOCK,1,,<empty>,,,,1,,ANY
327867,BLOCK,1,,<empty>,,,,1,,ANY
327871,BLOCK,1,,<empty>,,,,1,,ANY
327876,BLOCK,1,,<empty>,,,,1,,ANY
327879,BLOCK,1,,<empty>,,,,1,,ANY
327884,BLOCK,1,,<empty>,,,,1,,ANY
327890,BLOCK,1,,<empty>,,,,1,,ANY
327896,BLOCK,1,,<empty>,,,,1,,ANY
327901,BLOCK,1,,<empty>,,,,1,,ANY
327906,BLOCK,1,,<empty>,,,,1,,ANY
327910,BLOCK,1,,<empty>,,,,1,,ANY
327914,BLOCK,1,,<empty>,,,,1,,ANY
327919,BLOCK,1,,<empty>,,,,1,,ANY
327925,BLOCK,1,,<empty>,,,,1,,ANY
327929,BLOCK,1,,<empty>,,,,1,,ANY
327933,BLOCK,1,,<empty>,,,,1,,ANY
327938,BLOCK,1,,<empty>,,,,1,,ANY
327944,BLOCK,1,,<empty>,,,,1,,ANY
327949,BLOCK,1,,<empty>,,,,1,,ANY
327954,BLOCK,1,,<empty>,,,,1,,ANY
327958,BLOCK,1,,<empty>,,,,1,,ANY
327964,BLOCK,1,,<empty>,,,,1,,ANY
327968,BLOCK,1,,<empty>,,,,1,,ANY
327972,BLOCK,1,,<empty>,,,,1,,ANY
327976,BLOCK,1,,<empty>,,,,1,,ANY
327980,BLOCK,1,,<empty>,,,,1,,ANY
327984,BLOCK,1,,<empty>,,,,1,,ANY
327988,BLOCK,1,,<empty>,,,,1,,ANY
327992,BLOCK,1,,<empty>,,,,1,,ANY
327996,BLOCK,1,,<empty>,,,,1,,ANY
328000,BLOCK,1,,<empty>,,,,1,,ANY
328004,BLOCK,1,,<empty>,,,,1,,ANY
328008,BLOCK,1,,<empty>,,,,1,,ANY
328013,BLOCK,1,,<empty>,,,,1,,ANY
328020,BLOCK,1,,<empty>,,,,1,,ANY
328024,BLOCK,1,,<empty>,,,,1,,ANY
328029,BLOCK,1,,<empty>,,,,1,,ANY
328034,BLOCK,1,,<empty>,,,,1,,ANY
328038,BLOCK,1,,<empty>,,,,1,,ANY
328042,BLOCK,1,,<empty>,,,,1,,ANY
328046,BLOCK,1,,<empty>,,,,1,,ANY
328051,BLOCK,1,,<empty>,,,,1,,ANY
328055,BLOCK,1,,<empty>,,,,1,,ANY
328059,BLOCK,1,,<empty>,,,,1,,ANY
328065,BLOCK,1,,<empty>,,,,1,,ANY
328069,BLOCK,1,,<empty>,,,,1,,ANY
328074,BLOCK,1,,<empty>,,,,1,,ANY
328079,BLOCK,1,,<empty>,,,,1,,ANY
328083,BLOCK,1,,<empty>,,,,1,,ANY
328087,BLOCK,1,,<empty>,,,,1,,ANY
328091,BLOCK,1,,<empty>,,,,1,,ANY
328095,BLOCK,1,,<empty>,,,,1,,ANY
328099,BLOCK,1,,<empty>,,,,1,,ANY
328103,BLOCK,1,,<empty>,,,,1,,ANY
328107,BLOCK,1,,<empty>,,,,1,,ANY
328112,BLOCK,1,,<empty>,,,,1,,ANY
328117,BLOCK,1,,<empty>,,,,1,,ANY
328120,BLOCK,1,,<empty>,,,,1,,ANY
328126,BLOCK,1,,<empty>,,,,1,,ANY
328133,BLOCK,1,,<empty>,,,,1,,ANY
328137,BLOCK,1,,<empty>,,,,1,,ANY
328142,BLOCK,1,,<empty>,,,,1,,ANY
328146,BLOCK,1,,<empty>,,,,1,,ANY
328149,BLOCK,1,,<empty>,,,,1,,ANY
328155,BLOCK,1,,<empty>,,,,1,,ANY
328161,BLOCK,1,,<empty>,,,,1,,ANY
328167,BLOCK,1,,<empty>,,,,1,,ANY
328173,BLOCK,1,,<empty>,,,,1,,ANY
328179,BLOCK,1,,<empty>,,,,1,,ANY
328183,BLOCK,1,,<empty>,,,,1,,ANY
328187,BLOCK,1,,<empty>,,,,1,,ANY
328191,BLOCK,1,,<empty>,,,,1,,ANY
328195,BLOCK,1,,<empty>,,,,1,,ANY
328199,BLOCK,1,,<empty>,,,,1,,ANY
328203,BLOCK,1,,<empty>,,,,1,,ANY
328211,BLOCK,1,,<empty>,,,,1,,ANY
328215,BLOCK,1,,<empty>,,,,1,,ANY
328218,BLOCK,1,,<empty>,,,,1,,ANY
328224,BLOCK,1,,<empty>,,,,1,,ANY
328232,BLOCK,1,,<empty>,,,,1,,ANY
328240,BLOCK,1,,<empty>,,,,1,,ANY
328248,BLOCK,1,,<empty>,,,,1,,ANY
328256,BLOCK,1,,<empty>,,,,1,,ANY
328264,BLOCK,1,,<empty>,,,,1,,ANY
328272,BLOCK,1,,<empty>,,,,1,,ANY
328280,BLOCK,1,,<empty>,,,,1,,ANY
328288,BLOCK,1,,<empty>,,,,1,,ANY
328296,BLOCK,1,,<empty>,,,,1,,ANY
328304,BLOCK,1,,<empty>,,,,1,,ANY
328312,BLOCK,1,,<empty>,,,,1,,ANY
328317,BLOCK,1,,<empty>,,,,1,,ANY
328322,BLOCK,1,,<empty>,,,,1,,ANY
328326,BLOCK,1,,<empty>,,,,1,,ANY
328330,BLOCK,1,,<empty>,,,,1,,ANY
328334,BLOCK,1,,<empty>,,,,1,,ANY
328338,BLOCK,1,,<empty>,,,,1,,ANY
328345,BLOCK,1,,<empty>,,,,1,,ANY
328349,BLOCK,1,,<empty>,,,,1,,ANY
328353,BLOCK,1,,<empty>,,,,1,,ANY
328357,BLOCK,1,,<empty>,,,,1,,ANY
328362,BLOCK,1,,<empty>,,,,1,,ANY
328366,BLOCK,1,,<empty>,,,,1,,ANY
328370,BLOCK,1,,<empty>,,,,1,,ANY
328374,BLOCK,1,,<empty>,,,,1,,ANY
328379,BLOCK,1,,<empty>,,,,1,,ANY
328383,BLOCK,1,,<empty>,,,,1,,ANY
328387,BLOCK,1,,<empty>,,,,1,,ANY
328391,BLOCK,1,,<empty>,,,,1,,ANY
328397,BLOCK,1,,<empty>,,,,1,,ANY
328401,BLOCK,1,,<empty>,,,,1,,ANY
328405,BLOCK,1,,<empty>,,,,1,,ANY
328409,BLOCK,1,,<empty>,,,,1,,ANY
328414,BLOCK,1,,<empty>,,,,1,,ANY
328418,BLOCK,1,,<empty>,,,,1,,ANY
328422,BLOCK,1,,<empty>,,,,1,,ANY
328426,BLOCK,1,,<empty>,,,,1,,ANY
328430,BLOCK,1,,<empty>,,,,1,,ANY
328436,BLOCK,1,,<empty>,,,,1,,ANY
328439,BLOCK,1,,<empty>,,,,1,,ANY
328446,BLOCK,1,,<empty>,,,,1,,ANY
328450,BLOCK,1,,<empty>,,,,1,,ANY
328455,BLOCK,1,,<empty>,,,,1,,ANY
328459,BLOCK,1,,<empty>,,,,1,,ANY
328467,BLOCK,1,,<empty>,,,,1,,ANY
328471,BLOCK,1,,<empty>,,,,1,,ANY
328475,BLOCK,1,,<empty>,,,,1,,ANY
328479,BLOCK,1,,<empty>,,,,1,,ANY
328482,BLOCK,1,,<empty>,,,,1,,ANY
328485,BLOCK,1,,<empty>,,,,1,,ANY
328489,BLOCK,1,,<empty>,,,,1,,ANY
328492,BLOCK,1,,<empty>,,,,1,,ANY
328496,BLOCK,1,,<empty>,,,,1,,ANY
328499,BLOCK,1,,<empty>,,,,1,,ANY
328503,BLOCK,1,,<empty>,,,,1,,ANY
328507,BLOCK,1,,<empty>,,,,1,,ANY
328511,BLOCK,1,,<empty>,,,,1,,ANY
328517,BLOCK,1,,<empty>,,,,1,,ANY
328520,BLOCK,1,,<empty>,,,,1,,ANY
328524,BLOCK,1,,<empty>,,,,1,,ANY
328529,BLOCK,1,,<empty>,,,,1,,ANY
328534,BLOCK,1,,<empty>,,,,1,,ANY
328538,BLOCK,1,,<empty>,,,,1,,ANY
328542,BLOCK,1,,<empty>,,,,1,,ANY
328546,BLOCK,1,,<empty>,,,,1,,ANY
328550,BLOCK,1,,<empty>,,,,1,,ANY
328554,BLOCK,1,,<empty>,,,,1,,ANY
328558,BLOCK,1,,<empty>,,,,1,,ANY
328561,BLOCK,1,,<empty>,,,,1,,ANY
328565,BLOCK,1,,<empty>,,,,1,,ANY
328569,BLOCK,1,,<empty>,,,,1,,ANY
328573,BLOCK,1,,<empty>,,,,1,,ANY
328577,BLOCK,1,,<empty>,,,,1,,ANY
328581,BLOCK,1,,<empty>,,,,1,,ANY
328587,BLOCK,1,,<empty>,,,,1,,ANY
328591,BLOCK,1,,<empty>,,,,1,,ANY
328596,BLOCK,1,,<empty>,,,,1,,ANY
328600,BLOCK,1,,<empty>,,,,1,,ANY
328603,BLOCK,1,,<empty>,,,,1,,ANY
328607,BLOCK,1,,<empty>,,,,1,,ANY
328611,BLOCK,1,,<empty>,,,,1,,ANY
328615,BLOCK,1,,<empty>,,,,1,,ANY
328621,BLOCK,1,,<empty>,,,,1,,ANY
328625,BLOCK,1,,<empty>,,,,1,,ANY
328629,BLOCK,1,,<empty>,,,,1,,ANY
328633,BLOCK,1,,<empty>,,,,1,,ANY
328637,BLOCK,1,,<empty>,,,,1,,ANY
328641,BLOCK,1,,<empty>,,,,1,,ANY
328645,BLOCK,1,,<empty>,,,,1,,ANY
328649,BLOCK,1,,<empty>,,,,1,,ANY
328653,BLOCK,1,,<empty>,,,,1,,ANY
328657,BLOCK,1,,<empty>,,,,1,,ANY
328661,BLOCK,1,,<empty>,,,,1,,ANY
328665,BLOCK,1,,<empty>,,,,1,,ANY
328669,BLOCK,1,,<empty>,,,,1,,ANY
328673,BLOCK,1,,<empty>,,,,1,,ANY
328677,BLOCK,1,,<empty>,,,,1,,ANY
328681,BLOCK,1,,<empty>,,,,1,,ANY
328685,BLOCK,1,,<empty>,,,,1,,ANY
328691,BLOCK,1,,<empty>,,,,1,,ANY
328694,BLOCK,1,,<empty>,,,,1,,ANY
328697,BLOCK,1,,<empty>,,,,1,,ANY
328702,BLOCK,1,,<empty>,,,,1,,ANY
328707,BLOCK,1,,<empty>,,,,1,,ANY
328715,BLOCK,1,,<empty>,,,,1,,ANY
328720,BLOCK,1,,<empty>,,,,1,,ANY
328725,BLOCK,1,,<empty>,,,,1,,ANY
328729,BLOCK,1,,<empty>,,,,1,,ANY
328734,BLOCK,1,,<empty>,,,,1,,ANY
328738,BLOCK,1,,<empty>,,,,1,,ANY
328742,BLOCK,1,,<empty>,,,,1,,ANY
328747,BLOCK,1,,<empty>,,,,1,,ANY
328753,BLOCK,1,,<empty>,,,,1,,ANY
328757,BLOCK,1,,<empty>,,,,1,,ANY
328761,BLOCK,1,,<empty>,,,,1,,ANY
328766,BLOCK,1,,<empty>,,,,1,,ANY
328771,BLOCK,1,,<empty>,,,,1,,ANY
328775,BLOCK,1,,<empty>,,,,1,,ANY
328779,BLOCK,1,,<empty>,,,,1,,ANY
328783,BLOCK,1,,<empty>,,,,1,,ANY
328790,BLOCK,1,,<empty>,,,,1,,ANY
328795,BLOCK,1,,<empty>,,,,1,,ANY
328799,BLOCK,1,,<empty>,,,,1,,ANY
328803,BLOCK,1,,<empty>,,,,1,,ANY
328807,BLOCK,1,,<empty>,,,,1,,ANY
328811,BLOCK,1,,<empty>,,,,1,,ANY
328815,BLOCK,1,,<empty>,,,,1,,ANY
328820,BLOCK,1,,<empty>,,,,1,,ANY
328824,BLOCK,1,,<empty>,,,,1,,ANY
328828,BLOCK,1,,<empty>,,,,1,,ANY
328833,BLOCK,1,,<empty>,,,,1,,ANY
328837,BLOCK,1,,<empty>,,,,1,,ANY
328841,BLOCK,1,,<empty>,,,,1,,ANY
328845,BLOCK,1,,<empty>,,,,1,,ANY
328849,BLOCK,1,,<empty>,,,,1,,ANY
328853,BLOCK,1,,<empty>,,,,1,,ANY
328858,BLOCK,1,,<empty>,,,,1,,ANY
328863,BLOCK,1,,<empty>,,,,1,,ANY
328867,BLOCK,1,,<empty>,,,,1,,ANY
328872,BLOCK,1,,<empty>,,,,1,,ANY
328876,BLOCK,1,,<empty>,,,,1,,ANY
328884,BLOCK,1,,<empty>,,,,1,,ANY
328889,BLOCK,1,,<empty>,,,,1,,ANY
328895,BLOCK,1,,<empty>,,,,1,,ANY
328901,BLOCK,1,,<empty>,,,,1,,ANY
328907,BLOCK,1,,<empty>,,,,1,,ANY
328911,BLOCK,1,,<empty>,,,,1,,ANY
328915,BLOCK,1,,<empty>,,,,1,,ANY
328919,BLOCK,1,,<empty>,,,,1,,ANY
328923,BLOCK,1,,<empty>,,,,1,,ANY
328927,BLOCK,1,,<empty>,,,,1,,ANY
328931,BLOCK,1,,<empty>,,,,1,,ANY
328935,BLOCK,1,,<empty>,,,,1,,ANY
328939,BLOCK,1,,<empty>,,,,1,,ANY
328943,BLOCK,1,,<empty>,,,,1,,ANY
328947,BLOCK,1,,<empty>,,,,1,,ANY
328951,BLOCK,1,,<empty>,,,,1,,ANY
328955,BLOCK,1,,<empty>,,,,1,,ANY
328959,BLOCK,1,,<empty>,,,,1,,ANY
328963,BLOCK,1,,<empty>,,,,1,,ANY
328968,BLOCK,1,,<empty>,,,,1,,ANY
328972,BLOCK,1,,<empty>,,,,1,,ANY
328976,BLOCK,1,,<empty>,,,,1,,ANY
328982,BLOCK,1,,<empty>,,,,1,,ANY
328988,BLOCK,1,,<empty>,,,,1,,ANY
328992,BLOCK,1,,<empty>,,,,1,,ANY
329004,BLOCK,1,,<empty>,,,,1,,ANY
329009,BLOCK,1,,<empty>,,,,1,,ANY
329015,BLOCK,1,,<empty>,,,,1,,ANY
329020,BLOCK,1,,<empty>,,,,1,,ANY
329028,BLOCK,1,,<empty>,,,,1,,ANY
329033,BLOCK,1,,<empty>,,,,1,,ANY
329039,BLOCK,1,,<empty>,,,,1,,ANY
329046,BLOCK,1,,<empty>,,,,1,,ANY
329052,BLOCK,1,,<empty>,,,,1,,ANY
329058,BLOCK,1,,<empty>,,,,1,,ANY
329064,BLOCK,1,,<empty>,,,,1,,ANY
329069,BLOCK,1,,<empty>,,,,1,,ANY
329075,BLOCK,1,,<empty>,,,,1,,ANY
329081,BLOCK,1,,<empty>,,,,1,,ANY
329087,BLOCK,1,,<empty>,,,,1,,ANY
329091,BLOCK,1,,<empty>,,,,1,,ANY
329096,BLOCK,1,,<empty>,,,,1,,ANY
329101,BLOCK,1,,<empty>,,,,1,,ANY
329106,BLOCK,1,,<empty>,,,,1,,ANY
329110,BLOCK,1,,<empty>,,,,1,,ANY
329116,BLOCK,1,,<empty>,,,,1,,ANY
329120,BLOCK,1,,<empty>,,,,1,,ANY
329125,BLOCK,1,,<empty>,,,,1,,ANY
329130,BLOCK,1,,<empty>,,,,1,,ANY
329135,BLOCK,1,,<empty>,,,,1,,ANY
329139,BLOCK,1,,<empty>,,,,1,,ANY
329143,BLOCK,1,,<empty>,,,,1,,ANY
329149,BLOCK,1,,<empty>,,,,1,,ANY
329152,BLOCK,1,,<empty>,,,,1,,ANY
329156,BLOCK,1,,<empty>,,,,1,,ANY
329161,BLOCK,1,,<empty>,,,,1,,ANY
329165,BLOCK,1,,<empty>,,,,1,,ANY
329169,BLOCK,1,,<empty>,,,,1,,ANY
329172,BLOCK,1,,<empty>,,,,1,,ANY
329175,BLOCK,1,,<empty>,,,,1,,ANY
329178,BLOCK,1,,<empty>,,,,1,,ANY
329183,BLOCK,1,,<empty>,,,,1,,ANY
329188,BLOCK,1,,<empty>,,,,1,,ANY
329193,BLOCK,1,,<empty>,,,,1,,ANY
329197,BLOCK,1,,<empty>,,,,1,,ANY
329201,BLOCK,1,,<empty>,,,,1,,ANY
329205,BLOCK,1,,<empty>,,,,1,,ANY
329209,BLOCK,1,,<empty>,,,,1,,ANY
329215,BLOCK,1,,<empty>,,,,1,,ANY
329218,BLOCK,1,,<empty>,,,,1,,ANY
329222,BLOCK,1,,<empty>,,,,1,,ANY
329228,BLOCK,1,,<empty>,,,,1,,ANY
329233,BLOCK,1,,<empty>,,,,1,,ANY
329238,BLOCK,1,,<empty>,,,,1,,ANY
329243,BLOCK,1,,<empty>,,,,1,,ANY
329249,BLOCK,1,,<empty>,,,,1,,ANY
329253,BLOCK,1,,<empty>,,,,1,,ANY
329257,BLOCK,1,,<empty>,,,,1,,ANY
329262,BLOCK,1,,<empty>,,,,1,,ANY
329266,BLOCK,1,,<empty>,,,,1,,ANY
329272,BLOCK,1,,<empty>,,,,1,,ANY
329276,BLOCK,1,,<empty>,,,,1,,ANY
329281,BLOCK,1,,<empty>,,,,1,,ANY
329286,BLOCK,1,,<empty>,,,,1,,ANY
329292,BLOCK,1,,<empty>,,,,1,,ANY
329296,BLOCK,1,,<empty>,,,,1,,ANY
329301,BLOCK,1,,<empty>,,,,1,,ANY
329306,BLOCK,1,,<empty>,,,,1,,ANY
329311,BLOCK,1,,<empty>,,,,1,,ANY
329315,BLOCK,1,,<empty>,,,,1,,ANY
329319,BLOCK,1,,<empty>,,,,1,,ANY
329325,BLOCK,1,,<empty>,,,,1,,ANY
329328,BLOCK,1,,<empty>,,,,1,,ANY
329333,BLOCK,1,,<empty>,,,,1,,ANY
329338,BLOCK,1,,<empty>,,,,1,,ANY
329342,BLOCK,1,,<empty>,,,,1,,ANY
329346,BLOCK,1,,<empty>,,,,1,,ANY
329351,BLOCK,1,,<empty>,,,,1,,ANY
329354,BLOCK,1,,<empty>,,,,1,,ANY
329357,BLOCK,1,,<empty>,,,,1,,ANY
329361,BLOCK,1,,<empty>,,,,1,,ANY
329365,BLOCK,1,,<empty>,,,,1,,ANY
329370,BLOCK,1,,<empty>,,,,1,,ANY
329373,BLOCK,1,,<empty>,,,,1,,ANY
329376,BLOCK,1,,<empty>,,,,1,,ANY
329379,BLOCK,1,,<empty>,,,,1,,ANY
329382,BLOCK,1,,<empty>,,,,1,,ANY
329386,BLOCK,1,,<empty>,,,,1,,ANY
329390,BLOCK,1,,<empty>,,,,1,,ANY
329394,BLOCK,1,,<empty>,,,,1,,ANY
329398,BLOCK,1,,<empty>,,,,1,,ANY
329402,BLOCK,1,,<empty>,,,,1,,ANY
329405,BLOCK,1,,<empty>,,,,1,,ANY
329410,BLOCK,1,,<empty>,,,,1,,ANY
329415,BLOCK,1,,<empty>,,,,1,,ANY
329420,BLOCK,1,,<empty>,,,,1,,ANY
329425,BLOCK,1,,<empty>,,,,1,,ANY
329429,BLOCK,1,,<empty>,,,,1,,ANY
329432,BLOCK,1,,<empty>,,,,1,,ANY
329436,BLOCK,1,,<empty>,,,,1,,ANY
329440,BLOCK,1,,<empty>,,,,1,,ANY
329444,BLOCK,1,,<empty>,,,,1,,ANY
329448,BLOCK,1,,<empty>,,,,1,,ANY
329452,BLOCK,1,,<empty>,,,,1,,ANY
329456,BLOCK,1,,<empty>,,,,1,,ANY
329460,BLOCK,1,,<empty>,,,,1,,ANY
329464,BLOCK,1,,<empty>,,,,1,,ANY
329470,BLOCK,1,,<empty>,,,,1,,ANY
329475,BLOCK,1,,<empty>,,,,1,,ANY
329481,BLOCK,1,,<empty>,,,,1,,ANY
329485,BLOCK,1,,<empty>,,,,1,,ANY
329489,BLOCK,1,,<empty>,,,,1,,ANY
329492,BLOCK,1,,<empty>,,,,1,,ANY
329500,BLOCK,1,,<empty>,,,,1,,ANY
329506,BLOCK,1,,<empty>,,,,1,,ANY
329510,BLOCK,1,,<empty>,,,,1,,ANY
329518,BLOCK,1,,<empty>,,,,1,,ANY
329523,BLOCK,1,,<empty>,,,,1,,ANY
329529,BLOCK,1,,<empty>,,,,1,,ANY
329534,BLOCK,1,,<empty>,,,,1,,ANY
329538,BLOCK,1,,<empty>,,,,1,,ANY
329542,BLOCK,1,,<empty>,,,,1,,ANY
329549,BLOCK,1,,<empty>,,,,1,,ANY
329554,BLOCK,1,,<empty>,,,,1,,ANY
329558,BLOCK,1,,<empty>,,,,1,,ANY
329562,BLOCK,1,,<empty>,,,,1,,ANY
329566,BLOCK,1,,<empty>,,,,1,,ANY
329571,BLOCK,1,,<empty>,,,,1,,ANY
329576,BLOCK,1,,<empty>,,,,1,,ANY
329581,BLOCK,1,,<empty>,,,,1,,ANY
329585,BLOCK,1,,<empty>,,,,1,,ANY
329592,BLOCK,1,,<empty>,,,,1,,ANY
329596,BLOCK,1,,<empty>,,,,1,,ANY
329600,BLOCK,1,,<empty>,,,,1,,ANY
329607,BLOCK,1,,<empty>,,,,1,,ANY
329612,BLOCK,1,,<empty>,,,,1,,ANY
329616,BLOCK,1,,<empty>,,,,1,,ANY
329621,BLOCK,1,,<empty>,,,,1,,ANY
329626,BLOCK,1,,<empty>,,,,1,,ANY
329631,BLOCK,1,,<empty>,,,,1,,ANY
329636,BLOCK,1,,<empty>,,,,1,,ANY
329641,BLOCK,1,,<empty>,,,,1,,ANY
329646,BLOCK,1,,<empty>,,,,1,,ANY
329652,BLOCK,1,,<empty>,,,,1,,ANY
329658,BLOCK,1,,<empty>,,,,1,,ANY
329664,BLOCK,1,,<empty>,,,,1,,ANY
329670,BLOCK,1,,<empty>,,,,1,,ANY
329675,BLOCK,1,,<empty>,,,,1,,ANY
329680,BLOCK,1,,<empty>,,,,1,,ANY
329686,BLOCK,1,,<empty>,,,,1,,ANY
329691,BLOCK,1,,<empty>,,,,1,,ANY
329696,BLOCK,1,,<empty>,,,,1,,ANY
329700,BLOCK,1,,<empty>,,,,1,,ANY
329703,BLOCK,1,,<empty>,,,,1,,ANY
329709,BLOCK,1,,<empty>,,,,1,,ANY
329714,BLOCK,1,,<empty>,,,,1,,ANY
329720,BLOCK,1,,<empty>,,,,1,,ANY
329726,BLOCK,1,,<empty>,,,,1,,ANY
329731,BLOCK,1,,<empty>,,,,1,,ANY
329736,BLOCK,1,,<empty>,,,,1,,ANY
329742,BLOCK,1,,<empty>,,,,1,,ANY
329746,BLOCK,1,,<empty>,,,,1,,ANY
329751,BLOCK,1,,<empty>,,,,1,,ANY
329754,BLOCK,1,,<empty>,,,,1,,ANY
329758,BLOCK,1,,<empty>,,,,1,,ANY
329762,BLOCK,1,,<empty>,,,,1,,ANY
329767,BLOCK,1,,<empty>,,,,1,,ANY
329771,BLOCK,1,,<empty>,,,,1,,ANY
329775,BLOCK,1,,<empty>,,,,1,,ANY
329779,BLOCK,1,,<empty>,,,,1,,ANY
329784,BLOCK,1,,<empty>,,,,1,,ANY
329790,BLOCK,1,,<empty>,,,,1,,ANY
329795,BLOCK,1,,<empty>,,,,1,,ANY
329803,BLOCK,1,,<empty>,,,,1,,ANY
329810,BLOCK,1,,<empty>,,,,1,,ANY
329815,BLOCK,1,,<empty>,,,,1,,ANY
329819,BLOCK,1,,<empty>,,,,1,,ANY
329823,BLOCK,1,,<empty>,,,,1,,ANY
329832,BLOCK,1,,<empty>,,,,1,,ANY
329838,BLOCK,1,,<empty>,,,,1,,ANY
329842,BLOCK,1,,<empty>,,,,1,,ANY
329846,BLOCK,1,,<empty>,,,,1,,ANY
329852,BLOCK,1,,<empty>,,,,1,,ANY
329857,BLOCK,1,,<empty>,,,,1,,ANY
329862,BLOCK,1,,<empty>,,,,1,,ANY
329870,BLOCK,1,,<empty>,,,,1,,ANY
329878,BLOCK,1,,<empty>,,,,1,,ANY
329886,BLOCK,1,,<empty>,,,,1,,ANY
329894,BLOCK,1,,<empty>,,,,1,,ANY
329898,BLOCK,1,,<empty>,,,,1,,ANY
329901,BLOCK,1,,<empty>,,,,1,,ANY
329907,BLOCK,1,,<empty>,,,,1,,ANY
329913,BLOCK,1,,<empty>,,,,1,,ANY
329917,BLOCK,1,,<empty>,,,,1,,ANY
329922,BLOCK,1,,<empty>,,,,1,,ANY
329927,BLOCK,1,,<empty>,,,,1,,ANY
329931,BLOCK,1,,<empty>,,,,1,,ANY
329935,BLOCK,1,,<empty>,,,,1,,ANY
329939,BLOCK,1,,<empty>,,,,1,,ANY
329943,BLOCK,1,,<empty>,,,,1,,ANY
329947,BLOCK,1,,<empty>,,,,1,,ANY
329950,BLOCK,1,,<empty>,,,,1,,ANY
329955,BLOCK,1,,<empty>,,,,1,,ANY
329960,BLOCK,1,,<empty>,,,,1,,ANY
329965,BLOCK,1,,<empty>,,,,1,,ANY
329969,BLOCK,1,,<empty>,,,,1,,ANY
329974,BLOCK,1,,<empty>,,,,1,,ANY
329980,BLOCK,1,,<empty>,,,,1,,ANY
329985,BLOCK,1,,<empty>,,,,1,,ANY
329989,BLOCK,1,,<empty>,,,,1,,ANY
329995,BLOCK,1,,<empty>,,,,1,,ANY
329999,BLOCK,1,,<empty>,,,,1,,ANY
330004,BLOCK,1,,<empty>,,,,1,,ANY
330009,BLOCK,1,,<empty>,,,,1,,ANY
330014,BLOCK,1,,<empty>,,,,1,,ANY
330019,BLOCK,1,,<empty>,,,,1,,ANY
330024,BLOCK,1,,<empty>,,,,1,,ANY
330029,BLOCK,1,,<empty>,,,,1,,ANY
330034,BLOCK,1,,<empty>,,,,1,,ANY
330039,BLOCK,1,,<empty>,,,,1,,ANY
330044,BLOCK,1,,<empty>,,,,1,,ANY
330048,BLOCK,1,,<empty>,,,,1,,ANY
330052,BLOCK,1,,<empty>,,,,1,,ANY
330056,BLOCK,1,,<empty>,,,,1,,ANY
330060,BLOCK,1,,<empty>,,,,1,,ANY
330064,BLOCK,1,,<empty>,,,,1,,ANY
330069,BLOCK,1,,<empty>,,,,1,,ANY
330073,BLOCK,1,,<empty>,,,,1,,ANY
330077,BLOCK,1,,<empty>,,,,1,,ANY
330082,BLOCK,1,,<empty>,,,,1,,ANY
330086,BLOCK,1,,<empty>,,,,1,,ANY
330090,BLOCK,1,,<empty>,,,,1,,ANY
330094,BLOCK,1,,<empty>,,,,1,,ANY
330097,BLOCK,1,,<empty>,,,,1,,ANY
330103,BLOCK,1,,<empty>,,,,1,,ANY
330109,BLOCK,1,,<empty>,,,,1,,ANY
330115,BLOCK,1,,<empty>,,,,1,,ANY
330118,BLOCK,1,,<empty>,,,,1,,ANY
330124,BLOCK,1,,<empty>,,,,1,,ANY
330130,BLOCK,1,,<empty>,,,,1,,ANY
330136,BLOCK,1,,<empty>,,,,1,,ANY
330139,BLOCK,1,,<empty>,,,,1,,ANY
330145,BLOCK,1,,<empty>,,,,1,,ANY
330151,BLOCK,1,,<empty>,,,,1,,ANY
330157,BLOCK,1,,<empty>,,,,1,,ANY
330163,BLOCK,1,,<empty>,,,,1,,ANY
330169,BLOCK,1,,<empty>,,,,1,,ANY
330175,BLOCK,1,,<empty>,,,,1,,ANY
330178,BLOCK,1,,<empty>,,,,1,,ANY
330182,BLOCK,1,,<empty>,,,,1,,ANY
330185,BLOCK,1,,<empty>,,,,1,,ANY
330188,BLOCK,1,,<empty>,,,,1,,ANY
330192,BLOCK,1,,<empty>,,,,1,,ANY
330197,BLOCK,1,,<empty>,,,,1,,ANY
330201,BLOCK,1,,<empty>,,,,1,,ANY
330205,BLOCK,1,,<empty>,,,,1,,ANY
330210,BLOCK,1,,<empty>,,,,1,,ANY
330214,BLOCK,1,,<empty>,,,,1,,ANY
330218,BLOCK,1,,<empty>,,,,1,,ANY
330223,BLOCK,1,,<empty>,,,,1,,ANY
330227,BLOCK,1,,<empty>,,,,1,,ANY
330231,BLOCK,1,,<empty>,,,,1,,ANY
330235,BLOCK,1,,<empty>,,,,1,,ANY
330240,BLOCK,1,,<empty>,,,,1,,ANY
330246,BLOCK,1,,<empty>,,,,1,,ANY
330250,BLOCK,1,,<empty>,,,,1,,ANY
330254,BLOCK,1,,<empty>,,,,1,,ANY
330259,BLOCK,1,,<empty>,,,,1,,ANY
330264,BLOCK,1,,<empty>,,,,1,,ANY
330269,BLOCK,1,,<empty>,,,,1,,ANY
330272,BLOCK,1,,<empty>,,,,1,,ANY
330277,BLOCK,1,,<empty>,,,,1,,ANY
330280,BLOCK,1,,<empty>,,,,1,,ANY
330285,BLOCK,1,,<empty>,,,,1,,ANY
330291,BLOCK,1,,<empty>,,,,1,,ANY
330295,BLOCK,1,,<empty>,,,,1,,ANY
330301,BLOCK,1,,<empty>,,,,1,,ANY
330307,BLOCK,1,,<empty>,,,,1,,ANY
330311,BLOCK,1,,<empty>,,,,1,,ANY
330315,BLOCK,1,,<empty>,,,,1,,ANY
330319,BLOCK,1,,<empty>,,,,1,,ANY
330326,BLOCK,1,,<empty>,,,,1,,ANY
330330,BLOCK,1,,<empty>,,,,1,,ANY
330337,BLOCK,1,,<empty>,,,,1,,ANY
330343,BLOCK,1,,<empty>,,,,1,,ANY
330349,BLOCK,1,,<empty>,,,,1,,ANY
330355,BLOCK,1,,<empty>,,,,1,,ANY
330361,BLOCK,1,,<empty>,,,,1,,ANY
330367,BLOCK,1,,<empty>,,,,1,,ANY
330373,BLOCK,1,,<empty>,,,,1,,ANY
330379,BLOCK,1,,<empty>,,,,1,,ANY
330385,BLOCK,1,,<empty>,,,,1,,ANY
330392,BLOCK,1,,<empty>,,,,1,,ANY
330396,BLOCK,1,,<empty>,,,,1,,ANY
330402,BLOCK,1,,<empty>,,,,1,,ANY
330408,BLOCK,1,,<empty>,,,,1,,ANY
330416,BLOCK,1,,<empty>,,,,1,,ANY
330423,BLOCK,1,,<empty>,,,,1,,ANY
330428,BLOCK,1,,<empty>,,,,1,,ANY
330433,BLOCK,1,,<empty>,,,,1,,ANY
330439,BLOCK,1,,<empty>,,,,1,,ANY
330445,BLOCK,1,,<empty>,,,,1,,ANY
330451,BLOCK,1,,<empty>,,,,1,,ANY
330458,BLOCK,1,,<empty>,,,,1,,ANY
330464,BLOCK,1,,<empty>,,,,1,,ANY
330470,BLOCK,1,,<empty>,,,,1,,ANY
330476,BLOCK,1,,<empty>,,,,1,,ANY
330484,BLOCK,1,,<empty>,,,,1,,ANY
330492,BLOCK,1,,<empty>,,,,1,,ANY
330501,BLOCK,1,,<empty>,,,,1,,ANY
330507,BLOCK,1,,<empty>,,,,1,,ANY
330513,BLOCK,1,,<empty>,,,,1,,ANY
330520,BLOCK,1,,<empty>,,,,1,,ANY
330528,BLOCK,1,,<empty>,,,,1,,ANY
330537,BLOCK,1,,<empty>,,,,1,,ANY
330545,BLOCK,1,,<empty>,,,,1,,ANY
330554,BLOCK,1,,<empty>,,,,1,,ANY
330560,BLOCK,1,,<empty>,,,,1,,ANY
330568,BLOCK,1,,<empty>,,,,1,,ANY
330574,BLOCK,1,,<empty>,,,,1,,ANY
330579,BLOCK,1,,<empty>,,,,1,,ANY
330585,BLOCK,1,,<empty>,,,,1,,ANY
330593,BLOCK,1,,<empty>,,,,1,,ANY
330600,BLOCK,1,,<empty>,,,,1,,ANY
330609,BLOCK,1,,<empty>,,,,1,,ANY
330620,BLOCK,1,,<empty>,,,,1,,ANY
330631,BLOCK,1,,<empty>,,,,1,,ANY
330644,BLOCK,1,,<empty>,,,,1,,ANY
330654,BLOCK,1,,<empty>,,,,1,,ANY
330661,BLOCK,1,,<empty>,,,,1,,ANY
330671,BLOCK,1,,<empty>,,,,1,,ANY
330680,BLOCK,1,,<empty>,,,,1,,ANY
330687,BLOCK,1,,<empty>,,,,1,,ANY
330693,BLOCK,1,,<empty>,,,,1,,ANY
330701,BLOCK,1,,<empty>,,,,1,,ANY
330707,BLOCK,1,,<empty>,,,,1,,ANY
330712,BLOCK,1,,<empty>,,,,1,,ANY
330717,BLOCK,1,,<empty>,,,,1,,ANY
330723,BLOCK,1,,<empty>,,,,1,,ANY
330727,BLOCK,1,,<empty>,,,,1,,ANY
330734,BLOCK,1,,<empty>,,,,1,,ANY
330738,BLOCK,1,,<empty>,,,,1,,ANY
330748,BLOCK,1,,<empty>,,,,1,,ANY
330754,BLOCK,1,,<empty>,,,,1,,ANY
330758,BLOCK,1,,<empty>,,,,1,,ANY
330767,BLOCK,1,,<empty>,,,,1,,ANY
330773,BLOCK,1,,<empty>,,,,1,,ANY
330777,BLOCK,1,,<empty>,,,,1,,ANY
330781,BLOCK,1,,<empty>,,,,1,,ANY
330785,BLOCK,1,,<empty>,,,,1,,ANY
330793,BLOCK,1,,<empty>,,,,1,,ANY
330801,BLOCK,1,,<empty>,,,,1,,ANY
330809,BLOCK,1,,<empty>,,,,1,,ANY
330817,BLOCK,1,,<empty>,,,,1,,ANY
330825,BLOCK,1,,<empty>,,,,1,,ANY
330833,BLOCK,1,,<empty>,,,,1,,ANY
330841,BLOCK,1,,<empty>,,,,1,,ANY
330849,BLOCK,1,,<empty>,,,,1,,ANY
330857,BLOCK,1,,<empty>,,,,1,,ANY
330865,BLOCK,1,,<empty>,,,,1,,ANY
330873,BLOCK,1,,<empty>,,,,1,,ANY
330881,BLOCK,1,,<empty>,,,,1,,ANY
330889,BLOCK,1,,<empty>,,,,1,,ANY
330897,BLOCK,1,,<empty>,,,,1,,ANY
330905,BLOCK,1,,<empty>,,,,1,,ANY
330913,BLOCK,1,,<empty>,,,,1,,ANY
330921,BLOCK,1,,<empty>,,,,1,,ANY
330929,BLOCK,1,,<empty>,,,,1,,ANY
330937,BLOCK,1,,<empty>,,,,1,,ANY
330945,BLOCK,1,,<empty>,,,,1,,ANY
330953,BLOCK,1,,<empty>,,,,1,,ANY
330961,BLOCK,1,,<empty>,,,,1,,ANY
330969,BLOCK,1,,<empty>,,,,1,,ANY
330977,BLOCK,1,,<empty>,,,,1,,ANY
330985,BLOCK,1,,<empty>,,,,1,,ANY
330993,BLOCK,1,,<empty>,,,,1,,ANY
331001,BLOCK,1,,<empty>,,,,1,,ANY
331009,BLOCK,1,,<empty>,,,,1,,ANY
331017,BLOCK,1,,<empty>,,,,1,,ANY
331025,BLOCK,1,,<empty>,,,,1,,ANY
331033,BLOCK,1,,<empty>,,,,1,,ANY
331041,BLOCK,1,,<empty>,,,,1,,ANY
331049,BLOCK,1,,<empty>,,,,1,,ANY
331057,BLOCK,1,,<empty>,,,,1,,ANY
331065,BLOCK,1,,<empty>,,,,1,,ANY
331073,BLOCK,1,,<empty>,,,,1,,ANY
331081,BLOCK,1,,<empty>,,,,1,,ANY
331089,BLOCK,1,,<empty>,,,,1,,ANY
331097,BLOCK,1,,<empty>,,,,1,,ANY
331105,BLOCK,1,,<empty>,,,,1,,ANY
331113,BLOCK,1,,<empty>,,,,1,,ANY
331121,BLOCK,1,,<empty>,,,,1,,ANY
331129,BLOCK,1,,<empty>,,,,1,,ANY
331137,BLOCK,1,,<empty>,,,,1,,ANY
331145,BLOCK,1,,<empty>,,,,1,,ANY
331153,BLOCK,1,,<empty>,,,,1,,ANY
331160,BLOCK,1,,<empty>,,,,1,,ANY
331164,BLOCK,1,,<empty>,,,,1,,ANY
331169,BLOCK,1,,<empty>,,,,1,,ANY
331174,BLOCK,1,,<empty>,,,,1,,ANY
331180,BLOCK,1,,<empty>,,,,1,,ANY
331186,BLOCK,1,,<empty>,,,,1,,ANY
331192,BLOCK,1,,<empty>,,,,1,,ANY
331198,BLOCK,1,,<empty>,,,,1,,ANY
331202,BLOCK,1,,<empty>,,,,1,,ANY
331207,BLOCK,1,,<empty>,,,,1,,ANY
331212,BLOCK,1,,<empty>,,,,1,,ANY
331216,BLOCK,1,,<empty>,,,,1,,ANY
331220,BLOCK,1,,<empty>,,,,1,,ANY
331225,BLOCK,1,,<empty>,,,,1,,ANY
331232,BLOCK,1,,<empty>,,,,1,,ANY
331235,BLOCK,1,,<empty>,,,,1,,ANY
331239,BLOCK,1,,<empty>,,,,1,,ANY
331243,BLOCK,1,,<empty>,,,,1,,ANY
331247,BLOCK,1,,<empty>,,,,1,,ANY
331251,BLOCK,1,,<empty>,,,,1,,ANY
331256,BLOCK,1,,<empty>,,,,1,,ANY
331262,BLOCK,1,,<empty>,,,,1,,ANY
331267,BLOCK,1,,<empty>,,,,1,,ANY
331271,BLOCK,1,,<empty>,,,,1,,ANY
331277,BLOCK,1,,<empty>,,,,1,,ANY
331281,BLOCK,1,,<empty>,,,,1,,ANY
331285,BLOCK,1,,<empty>,,,,1,,ANY
331290,BLOCK,1,,<empty>,,,,1,,ANY
331294,BLOCK,1,,<empty>,,,,1,,ANY
331299,BLOCK,1,,<empty>,,,,1,,ANY
331304,BLOCK,1,,<empty>,,,,1,,ANY
331309,BLOCK,1,,<empty>,,,,1,,ANY
331314,BLOCK,1,,<empty>,,,,1,,ANY
331318,BLOCK,1,,<empty>,,,,1,,ANY
331323,BLOCK,1,,<empty>,,,,1,,ANY
331329,BLOCK,1,,<empty>,,,,1,,ANY
331334,BLOCK,1,,<empty>,,,,1,,ANY
331339,BLOCK,1,,<empty>,,,,1,,ANY
331344,BLOCK,1,,<empty>,,,,1,,ANY
331348,BLOCK,1,,<empty>,,,,1,,ANY
331352,BLOCK,1,,<empty>,,,,1,,ANY
331356,BLOCK,1,,<empty>,,,,1,,ANY
331359,BLOCK,1,,<empty>,,,,1,,ANY
331364,BLOCK,1,,<empty>,,,,1,,ANY
331368,BLOCK,1,,<empty>,,,,1,,ANY
331373,BLOCK,1,,<empty>,,,,1,,ANY
331377,BLOCK,1,,<empty>,,,,1,,ANY
331381,BLOCK,1,,<empty>,,,,1,,ANY
331385,BLOCK,1,,<empty>,,,,1,,ANY
331391,BLOCK,1,,<empty>,,,,1,,ANY
331395,BLOCK,1,,<empty>,,,,1,,ANY
331399,BLOCK,1,,<empty>,,,,1,,ANY
331404,BLOCK,1,,<empty>,,,,1,,ANY
331409,BLOCK,1,,<empty>,,,,1,,ANY
331413,BLOCK,1,,<empty>,,,,1,,ANY
331420,BLOCK,1,,<empty>,,,,1,,ANY
331425,BLOCK,1,,<empty>,,,,1,,ANY
331430,BLOCK,1,,<empty>,,,,1,,ANY
331435,BLOCK,1,,<empty>,,,,1,,ANY
331442,BLOCK,1,,<empty>,,,,1,,ANY
331447,BLOCK,1,,<empty>,,,,1,,ANY
331451,BLOCK,1,,<empty>,,,,1,,ANY
331455,BLOCK,1,,<empty>,,,,1,,ANY
331460,BLOCK,1,,<empty>,,,,1,,ANY
331468,BLOCK,1,,<empty>,,,,1,,ANY
331476,BLOCK,1,,<empty>,,,,1,,ANY
331484,BLOCK,1,,<empty>,,,,1,,ANY
331492,BLOCK,1,,<empty>,,,,1,,ANY
331500,BLOCK,1,,<empty>,,,,1,,ANY
331503,BLOCK,1,,<empty>,,,,1,,ANY
331507,BLOCK,1,,<empty>,,,,1,,ANY
331516,BLOCK,1,,<empty>,,,,1,,ANY
331524,BLOCK,1,,<empty>,,,,1,,ANY
331529,BLOCK,1,,<empty>,,,,1,,ANY
331533,BLOCK,1,,<empty>,,,,1,,ANY
331537,BLOCK,1,,<empty>,,,,1,,ANY
331541,BLOCK,1,,<empty>,,,,1,,ANY
331544,BLOCK,1,,<empty>,,,,1,,ANY
331547,BLOCK,1,,<empty>,,,,1,,ANY
331553,BLOCK,1,,<empty>,,,,1,,ANY
331557,BLOCK,1,,<empty>,,,,1,,ANY
331561,BLOCK,1,,<empty>,,,,1,,ANY
331566,BLOCK,1,,<empty>,,,,1,,ANY
331571,BLOCK,1,,<empty>,,,,1,,ANY
331575,BLOCK,1,,<empty>,,,,1,,ANY
331581,BLOCK,1,,<empty>,,,,1,,ANY
331586,BLOCK,1,,<empty>,,,,1,,ANY
331591,BLOCK,1,,<empty>,,,,1,,ANY
331595,BLOCK,1,,<empty>,,,,1,,ANY
331601,BLOCK,1,,<empty>,,,,1,,ANY
331607,BLOCK,1,,<empty>,,,,1,,ANY
331612,BLOCK,1,,<empty>,,,,1,,ANY
331617,BLOCK,1,,<empty>,,,,1,,ANY
331620,BLOCK,1,,<empty>,,,,1,,ANY
331624,BLOCK,1,,<empty>,,,,1,,ANY
331630,BLOCK,1,,<empty>,,,,1,,ANY
331637,BLOCK,1,,<empty>,,,,1,,ANY
331643,BLOCK,1,,<empty>,,,,1,,ANY
331647,BLOCK,1,,<empty>,,,,1,,ANY
331651,BLOCK,1,,<empty>,,,,1,,ANY
331655,BLOCK,1,,<empty>,,,,1,,ANY
331658,BLOCK,1,,<empty>,,,,1,,ANY
331663,BLOCK,1,,<empty>,,,,1,,ANY
331669,BLOCK,1,,<empty>,,,,1,,ANY
331672,BLOCK,1,,<empty>,,,,1,,ANY
331676,BLOCK,1,,<empty>,,,,1,,ANY
331680,BLOCK,1,,<empty>,,,,1,,ANY
331684,BLOCK,1,,<empty>,,,,1,,ANY
331688,BLOCK,1,,<empty>,,,,1,,ANY
331692,BLOCK,1,,<empty>,,,,1,,ANY
331696,BLOCK,1,,<empty>,,,,1,,ANY
331699,BLOCK,1,,<empty>,,,,1,,ANY
331702,BLOCK,1,,<empty>,,,,1,,ANY
331705,BLOCK,1,,<empty>,,,,1,,ANY
331708,BLOCK,1,,<empty>,,,,1,,ANY
331711,BLOCK,1,,<empty>,,,,1,,ANY
331714,BLOCK,1,,<empty>,,,,1,,ANY
331717,BLOCK,1,,<empty>,,,,1,,ANY
331726,BLOCK,1,,<empty>,,,,1,,ANY
331731,BLOCK,1,,<empty>,,,,1,,ANY
331737,BLOCK,1,,<empty>,,,,1,,ANY
331743,BLOCK,1,,<empty>,,,,1,,ANY
331753,BLOCK,1,,<empty>,,,,1,,ANY
331759,BLOCK,1,,<empty>,,,,1,,ANY
331765,BLOCK,1,,<empty>,,,,1,,ANY
331771,BLOCK,1,,<empty>,,,,1,,ANY
331780,BLOCK,1,,<empty>,,,,1,,ANY
331784,BLOCK,1,,<empty>,,,,1,,ANY
331788,BLOCK,1,,<empty>,,,,1,,ANY
331794,BLOCK,1,,<empty>,,,,1,,ANY
331800,BLOCK,1,,<empty>,,,,1,,ANY
331806,BLOCK,1,,<empty>,,,,1,,ANY
331811,BLOCK,1,,<empty>,,,,1,,ANY
331816,BLOCK,1,,<empty>,,,,1,,ANY
331821,BLOCK,1,,<empty>,,,,1,,ANY
331829,BLOCK,1,,<empty>,,,,1,,ANY
331837,BLOCK,1,,<empty>,,,,1,,ANY
331845,BLOCK,1,,<empty>,,,,1,,ANY
331853,BLOCK,1,,<empty>,,,,1,,ANY
331861,BLOCK,1,,<empty>,,,,1,,ANY
331869,BLOCK,1,,<empty>,,,,1,,ANY
331877,BLOCK,1,,<empty>,,,,1,,ANY
331885,BLOCK,1,,<empty>,,,,1,,ANY
331893,BLOCK,1,,<empty>,,,,1,,ANY
331901,BLOCK,1,,<empty>,,,,1,,ANY
331909,BLOCK,1,,<empty>,,,,1,,ANY
331917,BLOCK,1,,<empty>,,,,1,,ANY
331925,BLOCK,1,,<empty>,,,,1,,ANY
331933,BLOCK,1,,<empty>,,,,1,,ANY
331941,BLOCK,1,,<empty>,,,,1,,ANY
331949,BLOCK,1,,<empty>,,,,1,,ANY
331957,BLOCK,1,,<empty>,,,,1,,ANY
331965,BLOCK,1,,<empty>,,,,1,,ANY
331973,BLOCK,1,,<empty>,,,,1,,ANY
331981,BLOCK,1,,<empty>,,,,1,,ANY
331989,BLOCK,1,,<empty>,,,,1,,ANY
331997,BLOCK,1,,<empty>,,,,1,,ANY
332005,BLOCK,1,,<empty>,,,,1,,ANY
332013,BLOCK,1,,<empty>,,,,1,,ANY
332021,BLOCK,1,,<empty>,,,,1,,ANY
332029,BLOCK,1,,<empty>,,,,1,,ANY
332037,BLOCK,1,,<empty>,,,,1,,ANY
332045,BLOCK,1,,<empty>,,,,1,,ANY
332053,BLOCK,1,,<empty>,,,,1,,ANY
332061,BLOCK,1,,<empty>,,,,1,,ANY
332069,BLOCK,1,,<empty>,,,,1,,ANY
332077,BLOCK,1,,<empty>,,,,1,,ANY
332085,BLOCK,1,,<empty>,,,,1,,ANY
332093,BLOCK,1,,<empty>,,,,1,,ANY
332101,BLOCK,1,,<empty>,,,,1,,ANY
332109,BLOCK,1,,<empty>,,,,1,,ANY
332117,BLOCK,1,,<empty>,,,,1,,ANY
332125,BLOCK,1,,<empty>,,,,1,,ANY
332133,BLOCK,1,,<empty>,,,,1,,ANY
332141,BLOCK,1,,<empty>,,,,1,,ANY
332149,BLOCK,1,,<empty>,,,,1,,ANY
332157,BLOCK,1,,<empty>,,,,1,,ANY
332165,BLOCK,1,,<empty>,,,,1,,ANY
332173,BLOCK,1,,<empty>,,,,1,,ANY
332181,BLOCK,1,,<empty>,,,,1,,ANY
332189,BLOCK,1,,<empty>,,,,1,,ANY
332197,BLOCK,1,,<empty>,,,,1,,ANY
332205,BLOCK,1,,<empty>,,,,1,,ANY
332213,BLOCK,1,,<empty>,,,,1,,ANY
332221,BLOCK,1,,<empty>,,,,1,,ANY
332229,BLOCK,1,,<empty>,,,,1,,ANY
332237,BLOCK,1,,<empty>,,,,1,,ANY
332245,BLOCK,1,,<empty>,,,,1,,ANY
332253,BLOCK,1,,<empty>,,,,1,,ANY
332261,BLOCK,1,,<empty>,,,,1,,ANY
332269,BLOCK,1,,<empty>,,,,1,,ANY
332277,BLOCK,1,,<empty>,,,,1,,ANY
332285,BLOCK,1,,<empty>,,,,1,,ANY
332293,BLOCK,1,,<empty>,,,,1,,ANY
332301,BLOCK,1,,<empty>,,,,1,,ANY
332309,BLOCK,1,,<empty>,,,,1,,ANY
332317,BLOCK,1,,<empty>,,,,1,,ANY
332325,BLOCK,1,,<empty>,,,,1,,ANY
332333,BLOCK,1,,<empty>,,,,1,,ANY
332341,BLOCK,1,,<empty>,,,,1,,ANY
332349,BLOCK,1,,<empty>,,,,1,,ANY
332357,BLOCK,1,,<empty>,,,,1,,ANY
332365,BLOCK,1,,<empty>,,,,1,,ANY
332373,BLOCK,1,,<empty>,,,,1,,ANY
332381,BLOCK,1,,<empty>,,,,1,,ANY
332389,BLOCK,1,,<empty>,,,,1,,ANY
332397,BLOCK,1,,<empty>,,,,1,,ANY
332405,BLOCK,1,,<empty>,,,,1,,ANY
332413,BLOCK,1,,<empty>,,,,1,,ANY
332421,BLOCK,1,,<empty>,,,,1,,ANY
332429,BLOCK,1,,<empty>,,,,1,,ANY
332437,BLOCK,1,,<empty>,,,,1,,ANY
332445,BLOCK,1,,<empty>,,,,1,,ANY
332453,BLOCK,1,,<empty>,,,,1,,ANY
332461,BLOCK,1,,<empty>,,,,1,,ANY
332469,BLOCK,1,,<empty>,,,,1,,ANY
332477,BLOCK,1,,<empty>,,,,1,,ANY
332485,BLOCK,1,,<empty>,,,,1,,ANY
332493,BLOCK,1,,<empty>,,,,1,,ANY
332501,BLOCK,1,,<empty>,,,,1,,ANY
332509,BLOCK,1,,<empty>,,,,1,,ANY
332517,BLOCK,1,,<empty>,,,,1,,ANY
332525,BLOCK,1,,<empty>,,,,1,,ANY
332533,BLOCK,1,,<empty>,,,,1,,ANY
332541,BLOCK,1,,<empty>,,,,1,,ANY
332549,BLOCK,1,,<empty>,,,,1,,ANY
332557,BLOCK,1,,<empty>,,,,1,,ANY
332565,BLOCK,1,,<empty>,,,,1,,ANY
332573,BLOCK,1,,<empty>,,,,1,,ANY
332581,BLOCK,1,,<empty>,,,,1,,ANY
332589,BLOCK,1,,<empty>,,,,1,,ANY
332597,BLOCK,1,,<empty>,,,,1,,ANY
332605,BLOCK,1,,<empty>,,,,1,,ANY
332613,BLOCK,1,,<empty>,,,,1,,ANY
332621,BLOCK,1,,<empty>,,,,1,,ANY
332629,BLOCK,1,,<empty>,,,,1,,ANY
332637,BLOCK,1,,<empty>,,,,1,,ANY
332645,BLOCK,1,,<empty>,,,,1,,ANY
332653,BLOCK,1,,<empty>,,,,1,,ANY
332661,BLOCK,1,,<empty>,,,,1,,ANY
332669,BLOCK,1,,<empty>,,,,1,,ANY
332677,BLOCK,1,,<empty>,,,,1,,ANY
332681,BLOCK,1,,<empty>,,,,1,,ANY
332687,BLOCK,1,,<empty>,,,,1,,ANY
332692,BLOCK,1,,<empty>,,,,1,,ANY
332697,BLOCK,1,,<empty>,,,,1,,ANY
332702,BLOCK,1,,<empty>,,,,1,,ANY
332706,BLOCK,1,,<empty>,,,,1,,ANY
332711,BLOCK,1,,<empty>,,,,1,,ANY
332715,BLOCK,1,,<empty>,,,,1,,ANY
332721,BLOCK,1,,<empty>,,,,1,,ANY
332726,BLOCK,1,,<empty>,,,,1,,ANY
332730,BLOCK,1,,<empty>,,,,1,,ANY
332735,BLOCK,1,,<empty>,,,,1,,ANY
332740,BLOCK,1,,<empty>,,,,1,,ANY
332745,BLOCK,1,,<empty>,,,,1,,ANY
332749,BLOCK,1,,<empty>,,,,1,,ANY
332753,BLOCK,1,,<empty>,,,,1,,ANY
332757,BLOCK,1,,<empty>,,,,1,,ANY
332761,BLOCK,1,,<empty>,,,,1,,ANY
332765,BLOCK,1,,<empty>,,,,1,,ANY
332769,BLOCK,1,,<empty>,,,,1,,ANY
332773,BLOCK,1,,<empty>,,,,1,,ANY
332777,BLOCK,1,,<empty>,,,,1,,ANY
332781,BLOCK,1,,<empty>,,,,1,,ANY
332786,BLOCK,1,,<empty>,,,,1,,ANY
332791,BLOCK,1,,<empty>,,,,1,,ANY
332799,BLOCK,1,,<empty>,,,,1,,ANY
332807,BLOCK,1,,<empty>,,,,1,,ANY
332815,BLOCK,1,,<empty>,,,,1,,ANY
332823,BLOCK,1,,<empty>,,,,1,,ANY
332831,BLOCK,1,,<empty>,,,,1,,ANY
332837,BLOCK,1,,<empty>,,,,1,,ANY
332842,BLOCK,1,,<empty>,,,,1,,ANY
332847,BLOCK,1,,<empty>,,,,1,,ANY
332852,BLOCK,1,,<empty>,,,,1,,ANY
332856,BLOCK,1,,<empty>,,,,1,,ANY
332862,BLOCK,1,,<empty>,,,,1,,ANY
332866,BLOCK,1,,<empty>,,,,1,,ANY
332870,BLOCK,1,,<empty>,,,,1,,ANY
332874,BLOCK,1,,<empty>,,,,1,,ANY
332879,BLOCK,1,,<empty>,,,,1,,ANY
332883,BLOCK,1,,<empty>,,,,1,,ANY
332887,BLOCK,1,,<empty>,,,,1,,ANY
332891,BLOCK,1,,<empty>,,,,1,,ANY
332895,BLOCK,1,,<empty>,,,,1,,ANY
332900,BLOCK,1,,<empty>,,,,1,,ANY
332904,BLOCK,1,,<empty>,,,,1,,ANY
332909,BLOCK,1,,<empty>,,,,1,,ANY
332913,BLOCK,1,,<empty>,,,,1,,ANY
332918,BLOCK,1,,<empty>,,,,1,,ANY
332922,BLOCK,1,,<empty>,,,,1,,ANY
332927,BLOCK,1,,<empty>,,,,1,,ANY
332931,BLOCK,1,,<empty>,,,,1,,ANY
332935,BLOCK,1,,<empty>,,,,1,,ANY
332939,BLOCK,1,,<empty>,,,,1,,ANY
332943,BLOCK,1,,<empty>,,,,1,,ANY
332949,BLOCK,1,,<empty>,,,,1,,ANY
332953,BLOCK,1,,<empty>,,,,1,,ANY
332958,BLOCK,1,,<empty>,,,,1,,ANY
332963,BLOCK,1,,<empty>,,,,1,,ANY
332967,BLOCK,1,,<empty>,,,,1,,ANY
332972,BLOCK,1,,<empty>,,,,1,,ANY
332976,BLOCK,1,,<empty>,,,,1,,ANY
332982,BLOCK,1,,<empty>,,,,1,,ANY
332986,BLOCK,1,,<empty>,,,,1,,ANY
332990,BLOCK,1,,<empty>,,,,1,,ANY
332994,BLOCK,1,,<empty>,,,,1,,ANY
332998,BLOCK,1,,<empty>,,,,1,,ANY
333001,BLOCK,1,,<empty>,,,,1,,ANY
333004,BLOCK,1,,<empty>,,,,1,,ANY
333008,BLOCK,1,,<empty>,,,,1,,ANY
333014,BLOCK,1,,<empty>,,,,1,,ANY
333017,BLOCK,1,,<empty>,,,,1,,ANY
333020,BLOCK,1,,<empty>,,,,1,,ANY
333024,BLOCK,1,,<empty>,,,,1,,ANY
333029,BLOCK,1,,<empty>,,,,1,,ANY
333034,BLOCK,1,,<empty>,,,,1,,ANY
333038,BLOCK,1,,<empty>,,,,1,,ANY
333043,BLOCK,1,,<empty>,,,,1,,ANY
333047,BLOCK,1,,<empty>,,,,1,,ANY
333052,BLOCK,1,,<empty>,,,,1,,ANY
333057,BLOCK,1,,<empty>,,,,1,,ANY
333061,BLOCK,1,,<empty>,,,,1,,ANY
333064,BLOCK,1,,<empty>,,,,1,,ANY
333067,BLOCK,1,,<empty>,,,,1,,ANY
333071,BLOCK,1,,<empty>,,,,1,,ANY
333074,BLOCK,1,,<empty>,,,,1,,ANY
333077,BLOCK,1,,<empty>,,,,1,,ANY
333081,BLOCK,1,,<empty>,,,,1,,ANY
333084,BLOCK,1,,<empty>,,,,1,,ANY
333087,BLOCK,1,,<empty>,,,,1,,ANY
333091,BLOCK,1,,<empty>,,,,1,,ANY
333095,BLOCK,1,,<empty>,,,,1,,ANY
333099,BLOCK,1,,<empty>,,,,1,,ANY
333102,BLOCK,1,,<empty>,,,,1,,ANY
333106,BLOCK,1,,<empty>,,,,1,,ANY
333111,BLOCK,1,,<empty>,,,,1,,ANY
333116,BLOCK,1,,<empty>,,,,1,,ANY
333121,BLOCK,1,,<empty>,,,,1,,ANY
333125,BLOCK,1,,<empty>,,,,1,,ANY
333129,BLOCK,1,,<empty>,,,,1,,ANY
333133,BLOCK,1,,<empty>,,,,1,,ANY
333138,BLOCK,1,,<empty>,,,,1,,ANY
333142,BLOCK,1,,<empty>,,,,1,,ANY
333146,BLOCK,1,,<empty>,,,,1,,ANY
333150,BLOCK,1,,<empty>,,,,1,,ANY
333154,BLOCK,1,,<empty>,,,,1,,ANY
333161,BLOCK,1,,<empty>,,,,1,,ANY
333165,BLOCK,1,,<empty>,,,,1,,ANY
333170,BLOCK,1,,<empty>,,,,1,,ANY
333174,BLOCK,1,,<empty>,,,,1,,ANY
333178,BLOCK,1,,<empty>,,,,1,,ANY
333183,BLOCK,1,,<empty>,,,,1,,ANY
333189,BLOCK,1,,<empty>,,,,1,,ANY
333193,BLOCK,1,,<empty>,,,,1,,ANY
333197,BLOCK,1,,<empty>,,,,1,,ANY
333201,BLOCK,1,,<empty>,,,,1,,ANY
333206,BLOCK,1,,<empty>,,,,1,,ANY
333210,BLOCK,1,,<empty>,,,,1,,ANY
333215,BLOCK,1,,<empty>,,,,1,,ANY
333219,BLOCK,1,,<empty>,,,,1,,ANY
333223,BLOCK,1,,<empty>,,,,1,,ANY
333227,BLOCK,1,,<empty>,,,,1,,ANY
333231,BLOCK,1,,<empty>,,,,1,,ANY
333238,BLOCK,1,,<empty>,,,,1,,ANY
333242,BLOCK,1,,<empty>,,,,1,,ANY
333246,BLOCK,1,,<empty>,,,,1,,ANY
333250,BLOCK,1,,<empty>,,,,1,,ANY
333255,BLOCK,1,,<empty>,,,,1,,ANY
333260,BLOCK,1,,<empty>,,,,1,,ANY
333265,BLOCK,1,,<empty>,,,,1,,ANY
333274,BLOCK,1,,<empty>,,,,1,,ANY
333278,BLOCK,1,,<empty>,,,,1,,ANY
333282,BLOCK,1,,<empty>,,,,1,,ANY
333286,BLOCK,1,,<empty>,,,,1,,ANY
333291,BLOCK,1,,<empty>,,,,1,,ANY
333294,BLOCK,1,,<empty>,,,,1,,ANY
333299,BLOCK,1,,<empty>,,,,1,,ANY
333305,BLOCK,1,,<empty>,,,,1,,ANY
333311,BLOCK,1,,<empty>,,,,1,,ANY
333317,BLOCK,1,,<empty>,,,,1,,ANY
333321,BLOCK,1,,<empty>,,,,1,,ANY
333325,BLOCK,1,,<empty>,,,,1,,ANY
333329,BLOCK,1,,<empty>,,,,1,,ANY
333333,BLOCK,1,,<empty>,,,,1,,ANY
333337,BLOCK,1,,<empty>,,,,1,,ANY
333341,BLOCK,1,,<empty>,,,,1,,ANY
333345,BLOCK,1,,<empty>,,,,1,,ANY
333349,BLOCK,1,,<empty>,,,,1,,ANY
333353,BLOCK,1,,<empty>,,,,1,,ANY
333357,BLOCK,1,,<empty>,,,,1,,ANY
333363,BLOCK,1,,<empty>,,,,1,,ANY
333368,BLOCK,1,,<empty>,,,,1,,ANY
333372,BLOCK,1,,<empty>,,,,1,,ANY
333375,BLOCK,1,,<empty>,,,,1,,ANY
333382,BLOCK,1,,<empty>,,,,1,,ANY
333388,BLOCK,1,,<empty>,,,,1,,ANY
333394,BLOCK,1,,<empty>,,,,1,,ANY
333399,BLOCK,1,,<empty>,,,,1,,ANY
333404,BLOCK,1,,<empty>,,,,1,,ANY
333412,BLOCK,1,,<empty>,,,,1,,ANY
333420,BLOCK,1,,<empty>,,,,1,,ANY
333428,BLOCK,1,,<empty>,,,,1,,ANY
333436,BLOCK,1,,<empty>,,,,1,,ANY
333440,BLOCK,1,,<empty>,,,,1,,ANY
333445,BLOCK,1,,<empty>,,,,1,,ANY
333450,BLOCK,1,,<empty>,,,,1,,ANY
333453,BLOCK,1,,<empty>,,,,1,,ANY
333457,BLOCK,1,,<empty>,,,,1,,ANY
333461,BLOCK,1,,<empty>,,,,1,,ANY
333465,BLOCK,1,,<empty>,,,,1,,ANY
333469,BLOCK,1,,<empty>,,,,1,,ANY
333474,BLOCK,1,,<empty>,,,,1,,ANY
333479,BLOCK,1,,<empty>,,,,1,,ANY
333485,BLOCK,1,,<empty>,,,,1,,ANY
333490,BLOCK,1,,<empty>,,,,1,,ANY
333494,BLOCK,1,,<empty>,,,,1,,ANY
333497,BLOCK,1,,<empty>,,,,1,,ANY
333504,BLOCK,1,,<empty>,,,,1,,ANY
333509,BLOCK,1,,<empty>,,,,1,,ANY
333517,BLOCK,1,,<empty>,,,,1,,ANY
333522,BLOCK,1,,<empty>,,,,1,,ANY
333527,BLOCK,1,,<empty>,,,,1,,ANY
333533,BLOCK,1,,<empty>,,,,1,,ANY
333539,BLOCK,1,,<empty>,,,,1,,ANY
333543,BLOCK,1,,<empty>,,,,1,,ANY
333551,BLOCK,1,,<empty>,,,,1,,ANY
333558,BLOCK,1,,<empty>,,,,1,,ANY
333565,BLOCK,1,,<empty>,,,,1,,ANY
333568,BLOCK,1,,<empty>,,,,1,,ANY
333572,BLOCK,1,,<empty>,,,,1,,ANY
333577,BLOCK,1,,<empty>,,,,1,,ANY
333583,BLOCK,1,,<empty>,,,,1,,ANY
333588,BLOCK,1,,<empty>,,,,1,,ANY
333595,BLOCK,1,,<empty>,,,,1,,ANY
333599,BLOCK,1,,<empty>,,,,1,,ANY
333604,BLOCK,1,,<empty>,,,,1,,ANY
333610,BLOCK,1,,<empty>,,,,1,,ANY
333615,BLOCK,1,,<empty>,,,,1,,ANY
333621,BLOCK,1,,<empty>,,,,1,,ANY
333629,BLOCK,1,,<empty>,,,,1,,ANY
333637,BLOCK,1,,<empty>,,,,1,,ANY
333642,BLOCK,1,,<empty>,,,,1,,ANY
333650,BLOCK,1,,<empty>,,,,1,,ANY
333658,BLOCK,1,,<empty>,,,,1,,ANY
333666,BLOCK,1,,<empty>,,,,1,,ANY
333669,BLOCK,1,,<empty>,,,,1,,ANY
333672,BLOCK,1,,<empty>,,,,1,,ANY
333675,BLOCK,1,,<empty>,,,,1,,ANY
333678,BLOCK,1,,<empty>,,,,1,,ANY
333685,BLOCK,1,,<empty>,,,,1,,ANY
333690,BLOCK,1,,<empty>,,,,1,,ANY
333694,BLOCK,1,,<empty>,,,,1,,ANY
333701,BLOCK,1,,<empty>,,,,1,,ANY
333706,BLOCK,1,,<empty>,,,,1,,ANY
333709,BLOCK,1,,<empty>,,,,1,,ANY
333715,BLOCK,1,,<empty>,,,,1,,ANY
333721,BLOCK,1,,<empty>,,,,1,,ANY
333727,BLOCK,1,,<empty>,,,,1,,ANY
333733,BLOCK,1,,<empty>,,,,1,,ANY
333739,BLOCK,1,,<empty>,,,,1,,ANY
333745,BLOCK,1,,<empty>,,,,1,,ANY
333750,BLOCK,1,,<empty>,,,,1,,ANY
333757,BLOCK,1,,<empty>,,,,1,,ANY
333764,BLOCK,1,,<empty>,,,,1,,ANY
333771,BLOCK,1,,<empty>,,,,1,,ANY
333778,BLOCK,1,,<empty>,,,,1,,ANY
333785,BLOCK,1,,<empty>,,,,1,,ANY
333792,BLOCK,1,,<empty>,,,,1,,ANY
333799,BLOCK,1,,<empty>,,,,1,,ANY
333806,BLOCK,1,,<empty>,,,,1,,ANY
333810,BLOCK,1,,<empty>,,,,1,,ANY
333815,BLOCK,1,,<empty>,,,,1,,ANY
333823,BLOCK,1,,<empty>,,,,1,,ANY
333828,BLOCK,1,,<empty>,,,,1,,ANY
333834,BLOCK,1,,<empty>,,,,1,,ANY
333839,BLOCK,1,,<empty>,,,,1,,ANY
333844,BLOCK,1,,<empty>,,,,1,,ANY
333849,BLOCK,1,,<empty>,,,,1,,ANY
333854,BLOCK,1,,<empty>,,,,1,,ANY
333858,BLOCK,1,,<empty>,,,,1,,ANY
333864,BLOCK,1,,<empty>,,,,1,,ANY
333869,BLOCK,1,,<empty>,,,,1,,ANY
333874,BLOCK,1,,<empty>,,,,1,,ANY
333878,BLOCK,1,,<empty>,,,,1,,ANY
333883,BLOCK,1,,<empty>,,,,1,,ANY
333888,BLOCK,1,,<empty>,,,,1,,ANY
333893,BLOCK,1,,<empty>,,,,1,,ANY
333898,BLOCK,1,,<empty>,,,,1,,ANY
333906,BLOCK,1,,<empty>,,,,1,,ANY
333910,BLOCK,1,,<empty>,,,,1,,ANY
333914,BLOCK,1,,<empty>,,,,1,,ANY
333918,BLOCK,1,,<empty>,,,,1,,ANY
333923,BLOCK,1,,<empty>,,,,1,,ANY
333928,BLOCK,1,,<empty>,,,,1,,ANY
333931,BLOCK,1,,<empty>,,,,1,,ANY
333934,BLOCK,1,,<empty>,,,,1,,ANY
333940,BLOCK,1,,<empty>,,,,1,,ANY
333945,BLOCK,1,,<empty>,,,,1,,ANY
333949,BLOCK,1,,<empty>,,,,1,,ANY
333954,BLOCK,1,,<empty>,,,,1,,ANY
333959,BLOCK,1,,<empty>,,,,1,,ANY
333963,BLOCK,1,,<empty>,,,,1,,ANY
333966,BLOCK,1,,<empty>,,,,1,,ANY
333969,BLOCK,1,,<empty>,,,,1,,ANY
333972,BLOCK,1,,<empty>,,,,1,,ANY
333975,BLOCK,1,,<empty>,,,,1,,ANY
333980,BLOCK,1,,<empty>,,,,1,,ANY
333983,BLOCK,1,,<empty>,,,,1,,ANY
333987,BLOCK,1,,<empty>,,,,1,,ANY
334003,BLOCK,1,,<empty>,,,,1,,ANY
334009,BLOCK,1,,<empty>,,,,1,,ANY
334013,BLOCK,1,,<empty>,,,,1,,ANY
334021,BLOCK,1,,<empty>,,,,1,,ANY
334026,BLOCK,1,,<empty>,,,,1,,ANY
334029,BLOCK,1,,<empty>,,,,1,,ANY
334032,BLOCK,1,,<empty>,,,,1,,ANY
334037,BLOCK,1,,<empty>,,,,1,,ANY
334041,BLOCK,1,,<empty>,,,,1,,ANY
334045,BLOCK,1,,<empty>,,,,1,,ANY
334049,BLOCK,1,,<empty>,,,,1,,ANY
334053,BLOCK,1,,<empty>,,,,1,,ANY
334056,BLOCK,1,,<empty>,,,,1,,ANY
334063,BLOCK,1,,<empty>,,,,1,,ANY
334067,BLOCK,1,,<empty>,,,,1,,ANY
334073,BLOCK,1,,<empty>,,,,1,,ANY
334076,BLOCK,1,,<empty>,,,,1,,ANY
334080,BLOCK,1,,<empty>,,,,1,,ANY
334084,BLOCK,1,,<empty>,,,,1,,ANY
334089,BLOCK,1,,<empty>,,,,1,,ANY
334093,BLOCK,1,,<empty>,,,,1,,ANY
334097,BLOCK,1,,<empty>,,,,1,,ANY
334101,BLOCK,1,,<empty>,,,,1,,ANY
334105,BLOCK,1,,<empty>,,,,1,,ANY
334110,BLOCK,1,,<empty>,,,,1,,ANY
334113,BLOCK,1,,<empty>,,,,1,,ANY
334116,BLOCK,1,,<empty>,,,,1,,ANY
334122,BLOCK,1,,<empty>,,,,1,,ANY
334125,BLOCK,1,,<empty>,,,,1,,ANY
334140,BLOCK,1,,<empty>,,,,1,,ANY
334143,BLOCK,1,,<empty>,,,,1,,ANY
334150,BLOCK,1,,<empty>,,,,1,,ANY
334153,BLOCK,1,,<empty>,,,,1,,ANY
334158,BLOCK,1,,<empty>,,,,1,,ANY
334162,BLOCK,1,,<empty>,,,,1,,ANY
334166,BLOCK,1,,<empty>,,,,1,,ANY
334170,BLOCK,1,,<empty>,,,,1,,ANY
334173,BLOCK,1,,<empty>,,,,1,,ANY
334178,BLOCK,1,,<empty>,,,,1,,ANY
334183,BLOCK,1,,<empty>,,,,1,,ANY
334188,BLOCK,1,,<empty>,,,,1,,ANY
334195,BLOCK,1,,<empty>,,,,1,,ANY
334200,BLOCK,1,,<empty>,,,,1,,ANY
334204,BLOCK,1,,<empty>,,,,1,,ANY
334208,BLOCK,1,,<empty>,,,,1,,ANY
334213,BLOCK,1,,<empty>,,,,1,,ANY
334218,BLOCK,1,,<empty>,,,,1,,ANY
334226,BLOCK,1,,<empty>,,,,1,,ANY
334234,BLOCK,1,,<empty>,,,,1,,ANY
334240,BLOCK,1,,<empty>,,,,1,,ANY
334245,BLOCK,1,,<empty>,,,,1,,ANY
334250,BLOCK,1,,<empty>,,,,1,,ANY
334255,BLOCK,1,,<empty>,,,,1,,ANY
334260,BLOCK,1,,<empty>,,,,1,,ANY
334265,BLOCK,1,,<empty>,,,,1,,ANY
334270,BLOCK,1,,<empty>,,,,1,,ANY
334277,BLOCK,1,,<empty>,,,,1,,ANY
334282,BLOCK,1,,<empty>,,,,1,,ANY
334287,BLOCK,1,,<empty>,,,,1,,ANY
334292,BLOCK,1,,<empty>,,,,1,,ANY
334300,BLOCK,1,,<empty>,,,,1,,ANY
334305,BLOCK,1,,<empty>,,,,1,,ANY
334312,BLOCK,1,,<empty>,,,,1,,ANY
334316,BLOCK,1,,<empty>,,,,1,,ANY
334321,BLOCK,1,,<empty>,,,,1,,ANY
334326,BLOCK,1,,<empty>,,,,1,,ANY
334331,BLOCK,1,,<empty>,,,,1,,ANY
334336,BLOCK,1,,<empty>,,,,1,,ANY
334340,BLOCK,1,,<empty>,,,,1,,ANY
334346,BLOCK,1,,<empty>,,,,1,,ANY
334350,BLOCK,1,,<empty>,,,,1,,ANY
334354,BLOCK,1,,<empty>,,,,1,,ANY
334358,BLOCK,1,,<empty>,,,,1,,ANY
334362,BLOCK,1,,<empty>,,,,1,,ANY
334366,BLOCK,1,,<empty>,,,,1,,ANY
334372,BLOCK,1,,<empty>,,,,1,,ANY
334375,BLOCK,1,,<empty>,,,,1,,ANY
334379,BLOCK,1,,<empty>,,,,1,,ANY
334384,BLOCK,1,,<empty>,,,,1,,ANY
334392,BLOCK,1,,<empty>,,,,1,,ANY
334397,BLOCK,1,,<empty>,,,,1,,ANY
334402,BLOCK,1,,<empty>,,,,1,,ANY
334406,BLOCK,1,,<empty>,,,,1,,ANY
334412,BLOCK,1,,<empty>,,,,1,,ANY
334416,BLOCK,1,,<empty>,,,,1,,ANY
334423,BLOCK,1,,<empty>,,,,1,,ANY
334428,BLOCK,1,,<empty>,,,,1,,ANY
334433,BLOCK,1,,<empty>,,,,1,,ANY
334437,BLOCK,1,,<empty>,,,,1,,ANY
334442,BLOCK,1,,<empty>,,,,1,,ANY
334447,BLOCK,1,,<empty>,,,,1,,ANY
334451,BLOCK,1,,<empty>,,,,1,,ANY
334455,BLOCK,1,,<empty>,,,,1,,ANY
334458,BLOCK,1,,<empty>,,,,1,,ANY
334462,BLOCK,1,,<empty>,,,,1,,ANY
334466,BLOCK,1,,<empty>,,,,1,,ANY
