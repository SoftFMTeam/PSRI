,Id,Name,NodeType,Fullname,Signature,Filename,Code,LineNumber,LineNumberEnd,ColumnNumber,ColumnNumberEnd,LineOfCode,NumberOfOperators,SetOfOperators,NumberOfOperands,SetOfOperands,FanIn,FanOut,McCabe,AccCyc,ConCf,ConDf,ConZc,ConRf,ConVal,Parma,ParmaIn,ParmaOut,RetType
0,18434,setBackupAppender,1,FallbackErrorHandler.setBackupAppender,void FallbackErrorHandler.setBackupAppender (AppenderPtr),main\cpp\fallbackerrorhandler.cpp,"void FallbackErrorHandler::setBackupAppender(const AppenderPtr& backup1)
{
	LogLog::debug(((LogString) LOG4CXX_STR(""FB: Setting backup appender to [""))
		+ backup1->getName() + LOG4CXX_STR(""].""));
	m_priv->backup = backup1;

	// Make sure that we keep a reference to the appender around, since otherwise
	// the appender would be lost if it has no loggers that use it.
	LoggerRepository* repository = LogManager::getRootLogger()->getLoggerRepository();
	Hierarchy* hierarchy = dynamic_cast<Hierarchy*>(repository);
	if(hierarchy){
		hierarchy->addAppender(backup1);
	}

}",103.0,117.0,1.0,1.0,15.0,13,5,11,6,0,2,2,2,0,1,,0,1,2,1,1,void
1,34822,setOption,1,MapFilter.setOption,"void MapFilter.setOption (LogString,LogString)",main\cpp\mapfilter.cpp,"void MapFilter::setOption(  const LogString& option,
	const LogString& value)
{
	if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""ACCEPTONMATCH""), LOG4CXX_STR(""acceptonmatch"")))
	{
		priv->acceptOnMatch = OptionConverter::toBoolean(value, priv->acceptOnMatch);
	}
	else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""OPERATOR""), LOG4CXX_STR(""operator"")))
	{
		priv->mustMatchAll = StringHelper::equalsIgnoreCase(value, LOG4CXX_STR(""AND""), LOG4CXX_STR(""and"")) ? true : false;
	}
	else if (!option.empty() && !value.empty())
	{
		priv->keyVals[option] = value;
	}
}",51.0,66.0,1.0,2.0,16.0,9,4,6,5,0,2,2,2,1,2,,0,2,4,2,2,void
2,50185,AMPMToken,1,LOG4CXX_NS.helpers.SimpleDateFormatImpl.AMPMToken.AMPMToken,"ANY LOG4CXX_NS.helpers.SimpleDateFormatImpl.AMPMToken.AMPMToken (int,ANY*)",main\cpp\simpledateformat.cpp,"AMPMToken( int width, const std::locale* locale) : names( 2 )
		{
			renderFacet(locale, PatternToken::incrementHalfDay, 'p', 0x70, ""%p"", names);
		}",547.0,550.0,3.0,3.0,4.0,1,1,3,3,0,2,1,1,0,1,,0,1,4,2,2,ANY
3,40974,getSystemProperty,1,OptionConverter.getSystemProperty,"LogString OptionConverter.getSystemProperty (LogString,LogString)",main\cpp\optionconverter.cpp,"LogString OptionConverter::getSystemProperty(const LogString& key, const LogString& def)
{
	if (!key.empty())
	{
		LogString value(System::getProperty(key));

		if (!value.empty())
		{
			return value;
		}
	}

	return def;
}",288.0,301.0,1.0,1.0,14.0,5,2,6,4,6,1,3,4,0,1,,0,0,4,2,2,LogString
4,45073,doOnChange,1,LOG4CXX_NS.PropertyWatchdog.doOnChange,void LOG4CXX_NS.PropertyWatchdog.doOnChange (),main\cpp\propertyconfigurator.cpp,"void doOnChange()
		{
			PropertyConfigurator().doConfigure(file(),
				LogManager::getLoggerRepository());
		}",65.0,69.0,3.0,3.0,5.0,2,1,1,1,0,1,1,1,0,0,,0,0,0,0,0,void
5,4114,isDestructed,2,main\cpp\aprinitializer.cpp.isDestructed,,main\cpp\aprinitializer.cpp,bool isDestructed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
6,57364,push,1,ThreadSpecificData.push,void ThreadSpecificData.push (LogString),main\cpp\threadspecificdata.cpp,"void ThreadSpecificData::push(const LogString& val)
{
	ThreadSpecificData* data = getCurrentData();

	if (data == 0)
	{
		data = createCurrentData();
	}

	if (data != 0)
	{
		NDC::Stack& stack = data->getStack();

		if (stack.empty())
		{
			stack.push(NDC::DiagnosticContext(val, val));
		}
		else
		{
			LogString fullMessage(stack.top().second);
			fullMessage.append(1, (logchar) 0x20);
			fullMessage.append(val);
			stack.push(NDC::DiagnosticContext(val, fullMessage));
		}
	}
}",116.0,141.0,1.0,1.0,26.0,9,5,11,4,1,0,4,5,0,0,,0,0,2,1,1,void
7,50200,format,1,LOG4CXX_NS.helpers.SimpleDateFormatImpl.AMPMToken.format,"void LOG4CXX_NS.helpers.SimpleDateFormatImpl.AMPMToken.format (LogString,apr_time_exp_t,Pool)",main\cpp\simpledateformat.cpp,"void format( LogString& s, const apr_time_exp_t& tm, Pool& /* p */ ) const
		{
			s.append( names[tm.tm_hour / 12] );
		}",552.0,555.0,3.0,3.0,4.0,4,3,3,3,0,1,1,1,0,0,,0,1,6,3,3,void
8,26654,getByName,1,InetAddress.getByName,InetAddressPtr InetAddress.getByName (LogString),main\cpp\inetaddress.cpp,"InetAddressPtr InetAddress::getByName(const LogString& host)
{
	InetAddressPtr result;
	auto address = getAllByName(host);
	if (!address.empty())
		result = address.front();
	return result;
}",122.0,129.0,1.0,1.0,8.0,5,3,6,3,1,0,2,2,0,0,,0,0,2,1,1,InetAddressPtr
9,38943,pop,1,NDC.pop,LogString NDC.pop (),main\cpp\ndc.cpp,"bool NDC::pop(std::string& dst)
{
	bool retval = false;
	ThreadSpecificData* data = ThreadSpecificData::getCurrentData();

	if (data != 0)
	{
		Stack& stack = data->getStack();

		if (!stack.empty())
		{
			Transcoder::encode(getMessage(stack.top()), dst);
			stack.pop();
			retval = true;
		}

		data->recycle();
	}

	return retval;
}",150.0,170.0,1.0,1.0,21.0,11,5,11,4,0,1,3,4,0,0,,0,1,2,1,1,bool
10,21536,setOption,1,FixedWindowRollingPolicy.setOption,"void FixedWindowRollingPolicy.setOption (LogString,LogString)",main\cpp\fixedwindowrollingpolicy.cpp,"void FixedWindowRollingPolicy::setOption(const LogString& option,
	const LogString& value)
{
	if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""MININDEX""),
			LOG4CXX_STR(""minindex"")))
	{
		priv->minIndex = OptionConverter::toInt(value, 1);
	}
	else if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""MAXINDEX""),
			LOG4CXX_STR(""maxindex"")))
	{
		priv->maxIndex = OptionConverter::toInt(value, 7);
	}
	else if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""THROWIOEXCEPTIONONFORKFAILURE""),
			LOG4CXX_STR(""throwioexceptiononforkfailure"")))
	{
		priv->throwIOExceptionOnForkFailure = OptionConverter::toBoolean(value, true);
	}
	else
	{
		RollingPolicyBase::setOption(option, value);
	}
}",72.0,97.0,1.0,2.0,26.0,6,4,5,5,0,2,2,2,1,2,,0,2,4,2,2,void
11,46113,parseAppender,1,PropertyConfigurator.parseAppender,"AppenderPtr PropertyConfigurator.parseAppender (ANY,LogString)",main\cpp\propertyconfigurator.cpp,"AppenderPtr PropertyConfigurator::parseAppender(
	helpers::Properties& props, const LogString& appenderName)
{
	AppenderPtr appender = registryGet(appenderName);

	if (appender != 0)
	{
		LogLog::debug((LogString) LOG4CXX_STR(""Appender \"""")
			+ appenderName + LOG4CXX_STR(""\"" was already parsed.""));

		return appender;
	}

	static const WideLife<LogString> APPENDER_PREFIX(LOG4CXX_STR(""log4j.appender.""));

	// Appender was not previously initialized.
	LogString prefix = APPENDER_PREFIX.value() + appenderName;
	LogString layoutPrefix = prefix + LOG4CXX_STR("".layout"");

	std::shared_ptr<Object> obj =
		OptionConverter::instantiateByKey(
			props, prefix, Appender::getStaticClass(), 0);
	appender = LOG4CXX_NS::cast<Appender>( obj );

	// Map obsolete DailyRollingFileAppender property configuration
	if (!appender &&
		StringHelper::endsWith(OptionConverter::findAndSubst(prefix, props), LOG4CXX_STR(""DailyRollingFileAppender"")))
	{
		appender = std::make_shared<RollingFileAppender>();
		au...",420.0,535.0,1.0,1.0,116.0,120,10,134,29,0,20,13,28,4,20,,0,9,4,2,2,AppenderPtr
12,52256,create,1,Socket.create,"SocketUniquePtr Socket.create (InetAddressPtr,int)",main\cpp\socket.cpp,"SocketUniquePtr Socket::create(InetAddressPtr& address, int port){
	return std::make_unique<APRSocket>(address, port);
}",48.0,50.0,1.0,1.0,3.0,5,5,4,4,1,0,1,1,0,0,,0,0,4,2,2,SocketUniquePtr
13,56355,setEncoding,1,TelnetAppender.setEncoding,void TelnetAppender.setEncoding (LogString),main\cpp\telnetappender.cpp,"void TelnetAppender::setEncoding(const LogString& value)
{
	std::lock_guard<std::recursive_mutex> lock(_priv->mutex);
	_priv->encoder = CharsetEncoder::getEncoder(value);
	_priv->encoding = value;
}",105.0,110.0,1.0,44.0,6.0,16,6,8,4,0,1,1,1,0,1,,0,1,2,1,1,void
14,1060,SelectConfigurationFile,1,anonymous_namespace_2.SelectConfigurationFile,void anonymous_namespace_2.SelectConfigurationFile (),examples\cpp\com\foo\config3.cpp,"void SelectConfigurationFile() {
#if defined(_DEBUG)
	helpers::LogLog::setInternalDebugging(true);
#endif
	const char* extension[] = { "".xml"", "".properties"", 0 };
	std::string altPrefix;
	helpers::Pool pool;

	for (auto baseName : DefaultConfigurationFileNames(altPrefix)) {
		int i = 0;
		for (; extension[i]; ++i) {
			File current_working_dir_candidate(baseName + extension[i]);
			if (current_working_dir_candidate.exists(pool)) {
				DefaultConfigurator::setConfigurationFileName(current_working_dir_candidate.getPath());
				DefaultConfigurator::setConfigurationWatchSeconds(5);
				break;
			}
			if (!altPrefix.empty()) {
				File alt_dir_candidate(altPrefix + baseName + extension[i]);
				if (alt_dir_candidate.exists(pool)) {
					DefaultConfigurator::setConfigurationFileName(alt_dir_candidate.getPath());
					DefaultConfigurator::setConfigurationWatchSeconds(5);
					break;
				}
			}
		}
		if (extension[i]) // Found a configuration file?
			return;
	}
	// Configuration file not f...",117.0,148.0,1.0,1.0,32.0,21,6,26,9,0,5,9,16,0,5,,0,0,0,0,0,void
15,55333,setOption,1,SyslogAppender.setOption,"void SyslogAppender.setOption (LogString,LogString)",main\cpp\syslogappender.cpp,"void SyslogAppender::setOption(const LogString& option, const LogString& value)
{
	if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""SYSLOGHOST""), LOG4CXX_STR(""sysloghost"")))
	{
		setSyslogHost(value);
	}
	else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""FACILITY""), LOG4CXX_STR(""facility"")))
	{
		setFacility(value);
	}
	else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""MAXMESSAGELENGTH""), LOG4CXX_STR(""maxmessagelength"")))
	{
		setMaxMessageLength(OptionConverter::toInt(value, 1024));
	}
	else
	{
		AppenderSkeleton::setOption(option, value);
	}
}",379.0,397.0,1.0,1.0,19.0,1,1,3,3,0,1,2,2,1,1,,0,1,4,2,2,void
16,48164,rolloverInternal,1,RollingFileAppender.rolloverInternal,bool RollingFileAppender.rolloverInternal (Pool),main\cpp\rollingfileappender.cpp,"bool RollingFileAppender::rolloverInternal(Pool& p)
{
	//
	//   can't roll without a policy
	//
	if (_priv->rollingPolicy != NULL)
	{

		{
				try
				{
					RolloverDescriptionPtr rollover1(_priv->rollingPolicy->rollover(this->getFile(), this->getAppend(), p));

					if (rollover1 != NULL)
					{
						if (rollover1->getActiveFileName() == getFile())
						{
							closeWriter();

							bool success = true;

							if (rollover1->getSynchronous() != NULL)
							{
								success = false;

								try
								{
									success = rollover1->getSynchronous()->execute(p);
								}
								catch (std::exception& ex)
								{
									LOG4CXX_DECODE_CHAR(lsMsg, ex.what());
									LogString errorMsg = LOG4CXX_STR(""Exception on rollover: "");
									errorMsg.append(lsMsg);
									LogLog::error(errorMsg);
									_priv->errorHandler->error(lsMsg, ex, 0);
								}
							}

							if (success)
							{
								if (rollover1->getAppend())
								{
									_priv->fileLength = Fil...",308.0,448.0,1.0,5.0,141.0,55,6,49,10,0,2,10,39,0,2,,0,0,2,1,1,bool
17,29735,newInstance,1,LiteralPatternConverter.newInstance,PatternConverterPtr LiteralPatternConverter.newInstance (LogString),main\cpp\literalpatternconverter.cpp,"PatternConverterPtr LiteralPatternConverter::newInstance(
	const LogString& literal)
{
	if (literal.length() == 1 && literal[0] == 0x20 /* ' ' */)
	{
		static WideLife<PatternConverterPtr> blank = std::make_shared<LiteralPatternConverter>(literal);
		return blank;
	}

	return std::make_shared<LiteralPatternConverter>(literal);
}",51.0,61.0,1.0,1.0,11.0,12,7,10,4,2,0,2,2,0,0,,0,0,2,1,1,PatternConverterPtr
18,15399,parseErrorHandler,1,DOMConfigurator.parseErrorHandler,"void DOMConfigurator.parseErrorHandler (Pool,ANY,apr_xml_elem*,AppenderPtr,apr_xml_doc*,AppenderMap)",main\cpp\domconfigurator.cpp,"void DOMConfigurator::parseErrorHandler(Pool& p,
	LOG4CXX_NS::helpers::CharsetDecoderPtr& utf8Decoder,
	apr_xml_elem* element,
	AppenderPtr& appender,
	apr_xml_doc* doc,
	AppenderMap& appenders)
{

	ErrorHandlerPtr eh;
	std::shared_ptr<Object> obj = OptionConverter::instantiateByClassName(
			subst(getAttribute(utf8Decoder, element, CLASS_ATTR)),
			ErrorHandler::getStaticClass(),
			0);
	eh = LOG4CXX_NS::cast<ErrorHandler>(obj);

	if (eh != 0)
	{
		eh->setAppender(appender);

		PropertySetter propSetter(eh);

		for (apr_xml_elem* currentElement = element->first_child;
			currentElement;
			currentElement = currentElement->next)
		{
			std::string tagName(currentElement->name);

			if (tagName == PARAM_TAG)
			{
				setParameter(p, utf8Decoder, currentElement, propSetter);
			}
			else if (tagName == APPENDER_REF_TAG)
			{
				eh->setBackupAppender(findAppenderByReference(p, utf8Decoder, currentElement, doc, appenders));
			}
			else if (tagName == LOGGER_REF)
			{
				LogString log...",326.0,382.0,1.0,44.0,57.0,26,7,35,16,0,1,5,9,0,1,,0,1,12,6,6,void
19,50218,names,3,LOG4CXX_NS.helpers.SimpleDateFormatImpl.AMPMToken.names,,main\cpp\simpledateformat.cpp,names,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
20,41005,toLevel,1,OptionConverter.toLevel,"LevelPtr OptionConverter.toLevel (LogString,LevelPtr)",main\cpp\optionconverter.cpp,"LevelPtr OptionConverter::toLevel(const LogString& value,
	const LevelPtr& defaultValue)
{
	size_t hashIndex = value.find(LOG4CXX_STR(""#""));

	if (hashIndex == LogString::npos)
	{
		if (value.empty())
		{
			return defaultValue;
		}
		else
		{
			LogLog::debug(
				((LogString) LOG4CXX_STR(""OptionConverter::toLevel: no class name specified, level=[""))
				+ value
				+ LOG4CXX_STR(""]""));
			// no class name specified : use standard Level class
			return Level::toLevelLS(value, defaultValue);
		}
	}

	LogString clazz = value.substr(hashIndex + 1);
	LogString levelName = value.substr(0, hashIndex);
	LogLog::debug(((LogString) LOG4CXX_STR(""OptionConverter::toLevel: class=[""))
		+ clazz + LOG4CXX_STR(""], level=["") + levelName + LOG4CXX_STR(""]""));

	// This is degenerate case but you never know.
	if (levelName.empty())
	{
		return Level::toLevelLS(value, defaultValue);
	}

	try
	{
		Level::LevelClass& levelClass =
			(Level::LevelClass&)Loader::loadClass(clazz);
		return levelClass.toLev...",303.0,361.0,1.0,1.0,59.0,36,5,34,11,2,6,5,6,0,6,,0,1,4,2,2,LevelPtr
21,45102,doConfigure,1,PropertyConfigurator.doConfigure,"ConfigurationStatus PropertyConfigurator.doConfigure (File,ANY)",main\cpp\propertyconfigurator.cpp,"spi::ConfigurationStatus PropertyConfigurator::doConfigure(helpers::Properties& properties,
	spi::LoggerRepositoryPtr hierarchy)
{
	hierarchy->setConfigured(true);

	static const WideLife<LogString> DEBUG_KEY(LOG4CXX_STR(""log4j.debug""));
	LogString value(properties.getProperty(DEBUG_KEY));

	if (!value.empty())
	{
		LogLog::setInternalDebugging(OptionConverter::toBoolean(value, true));
	}

	static const WideLife<LogString> THRESHOLD_PREFIX(LOG4CXX_STR(""log4j.threshold""));
	LogString thresholdStr =
		OptionConverter::findAndSubst(THRESHOLD_PREFIX, properties);

	if (!thresholdStr.empty())
	{
		hierarchy->setThreshold(OptionConverter::toLevel(thresholdStr, Level::getAll()));
		LogLog::debug(((LogString) LOG4CXX_STR(""Hierarchy threshold set to [""))
			+ hierarchy->getThreshold()->toString()
			+ LOG4CXX_STR(""].""));
	}

	LogString threadConfigurationValue(properties.getProperty(LOG4CXX_STR(""log4j.threadConfiguration"")));

	if ( threadConfigurationValue == LOG4CXX_STR(""NoConfiguration"") ...",159.0,214.0,1.0,1.0,56.0,25,6,24,11,0,3,3,3,0,3,,0,0,4,2,2,ConfigurationStatus
22,25645,format,1,HTMLLayout.format,"void HTMLLayout.format (LogString,ANY,Pool)",main\cpp\htmllayout.cpp,"void HTMLLayout::format(LogString& output,
	const spi::LoggingEventPtr& event,
	Pool& p) const
{
	output.reserve(m_priv->expectedPatternLength + event->getMessage().size());
	output.append(LOG4CXX_EOL);
	output.append(LOG4CXX_STR(""<tr>""));
	output.append(LOG4CXX_EOL);
	output.append(LOG4CXX_STR(""<td>""));

	m_priv->dateFormat.format(output, event->getTimeStamp(), p);


	output.append(LOG4CXX_STR(""</td>""));
	output.append(LOG4CXX_EOL);

	output.append(LOG4CXX_STR(""<td title=\""""));
	LogString threadName(event->getThreadName());
	output.append(threadName);
	output.append(LOG4CXX_STR("" thread\"">""));
	output.append(threadName);
	output.append(LOG4CXX_STR(""</td>""));
	output.append(LOG4CXX_EOL);

	output.append(LOG4CXX_STR(""<td title=\""Level\"">""));

	if (event->getLevel()->equals(Level::getDebug()))
	{
		output.append(LOG4CXX_STR(""<font color=\""#339933\"">""));
		output.append(event->getLevel()->toString());
		output.append(LOG4CXX_STR(""</font>""));
	}
	else if (event->getLevel()->isGreaterOrE...",83.0,173.0,1.0,1.0,91.0,70,6,88,13,0,6,5,6,1,5,,0,1,6,3,3,void
23,50225,format,1,LOG4CXX_NS.helpers.SimpleDateFormatImpl.GeneralTimeZoneToken.format,"void LOG4CXX_NS.helpers.SimpleDateFormatImpl.GeneralTimeZoneToken.format (LogString,apr_time_exp_t,Pool)",main\cpp\simpledateformat.cpp,"void format( LogString& s, const apr_time_exp_t&, Pool& /* p */ ) const
		{
			s.append(timeZone->getID());
		}",570.0,573.0,3.0,3.0,4.0,2,2,2,2,0,1,1,1,0,0,,0,1,6,3,3,void
24,61490,createWriter,1,WriterAppender.createWriter,WriterPtr WriterAppender.createWriter (OutputStreamPtr),main\cpp\writerappender.cpp,"WriterPtr WriterAppender::createWriter(OutputStreamPtr& os)
{

	LogString enc(getEncoding());

	CharsetEncoderPtr encoder;

	if (enc.empty())
	{
		encoder = CharsetEncoder::getDefaultEncoder();
	}
	else
	{
		if (StringHelper::equalsIgnoreCase(enc,
				LOG4CXX_STR(""utf-16""), LOG4CXX_STR(""UTF-16"")))
		{
			encoder = CharsetEncoder::getEncoder(LOG4CXX_STR(""UTF-16BE""));
		}
		else
		{
			encoder = CharsetEncoder::getEncoder(enc);
		}

		if (encoder == NULL)
		{
			encoder = CharsetEncoder::getDefaultEncoder();
			LogLog::warn(LOG4CXX_STR(""Error initializing output writer.""));
			LogLog::warn(LOG4CXX_STR(""Unsupported encoding?""));
		}
	}

	return WriterPtr(new OutputStreamWriter(os, encoder));
}",209.0,241.0,1.0,1.0,33.0,4,3,6,5,0,1,2,2,0,0,,0,1,2,1,1,WriterPtr
25,39989,encode,1,ODBCAppender.encode,"void ODBCAppender.encode (short unsigned**,LogString,Pool)",main\cpp\odbcappender.cpp,"void ODBCAppender::encode(unsigned short** dest,
	const LogString& src, Pool& p)
{
	//  worst case double number of characters from UTF-8 or wchar_t
	*dest = (unsigned short*)
		p.palloc((src.size() + 1) * 2 * sizeof(unsigned short));
	unsigned short* current = *dest;

	for (LogString::const_iterator i = src.begin();
		i != src.end();)
	{
		unsigned int sv = Transcoder::decode(src, i);

		if (sv < 0x10000)
		{
			*current++ = (unsigned short) sv;
		}
		else
		{
			unsigned char u = (unsigned char) (sv >> 16);
			unsigned char w = (unsigned char) (u - 1);
			unsigned short hs = (0xD800 + ((w & 0xF) << 6) + ((sv & 0xFFFF) >> 10));
			unsigned short ls = (0xDC00 + (sv & 0x3FF));
			*current++ = (unsigned short) hs;
			*current++ = (unsigned short) ls;
		}
	}

	*current = 0;
}",626.0,655.0,1.0,1.0,30.0,24,10,18,8,0,1,3,4,0,1,,0,1,6,3,3,void
26,4159,APRInitializer,1,APRInitializer.APRInitializer,ANY APRInitializer.APRInitializer (),main\cpp\aprinitializer.cpp,"APRInitializer::APRInitializer() :
	m_priv(std::make_unique<APRInitializerPrivate>())
{
	apr_pool_create(&m_priv->p, NULL);
	m_priv->startTime = Date::currentTime();
#if APR_HAS_THREADS
	apr_status_t stat = apr_threadkey_private_create(&m_priv->tlsKey, tlsDestructImpl, m_priv->p);
	assert(stat == APR_SUCCESS);
#endif
}",83.0,92.0,1.0,1.0,10.0,5,4,4,3,0,1,1,1,0,0,,0,1,0,0,0,ANY
27,50240,setTimeZone,1,LOG4CXX_NS.helpers.SimpleDateFormatImpl.GeneralTimeZoneToken.setTimeZone,void LOG4CXX_NS.helpers.SimpleDateFormatImpl.GeneralTimeZoneToken.setTimeZone (TimeZonePtr),main\cpp\simpledateformat.cpp,"void setTimeZone( const TimeZonePtr& zone )
		{
			timeZone = zone;
		}",575.0,578.0,3.0,3.0,4.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
28,16449,parseLevel,1,DOMConfigurator.parseLevel,"void DOMConfigurator.parseLevel (ANY,ANY,apr_xml_elem*,LoggerPtr,bool)",main\cpp\domconfigurator.cpp,"void DOMConfigurator::parseLevel(
	LOG4CXX_NS::helpers::Pool& p,
	LOG4CXX_NS::helpers::CharsetDecoderPtr& utf8Decoder,
	apr_xml_elem* element, LoggerPtr logger, bool isRoot)
{
	LogString loggerName = logger->getName();

	if (isRoot)
	{
		loggerName = LOG4CXX_STR(""root"");
	}

	LogString levelStr(subst(getAttribute(utf8Decoder, element, VALUE_ATTR)));
	LogLog::debug(LOG4CXX_STR(""Level value for "") + loggerName + LOG4CXX_STR("" is ["") + levelStr + LOG4CXX_STR(""].""));

	if (StringHelper::equalsIgnoreCase(levelStr, LOG4CXX_STR(""INHERITED""), LOG4CXX_STR(""inherited""))
		|| StringHelper::equalsIgnoreCase(levelStr, LOG4CXX_STR(""NULL""), LOG4CXX_STR(""null"")))
	{
		if (isRoot)
		{
			LogLog::error(LOG4CXX_STR(""Root level cannot be inherited. Ignoring directive.""));
		}
		else
		{
			logger->setLevel(0);
		}
	}
	else
	{
		LogString className(subst(getAttribute(utf8Decoder, element, CLASS_ATTR)));

		if (className.empty())
		{
			logger->setLevel(OptionConverter::toLevel(levelStr, Level::getDebug(...",700.0,767.0,1.0,61.0,68.0,17,5,18,8,0,5,4,5,2,5,,0,2,10,5,5,void
29,43074,parse,1,PatternParser.parse,"void PatternParser.parse (LogString,ANY,ANY,PatternMap)",main\cpp\patternparser.cpp,"void PatternParser::parse(
	const LogString& pattern,
	std::vector<PatternConverterPtr>& patternConverters,
	std::vector<FormattingInfoPtr>& formattingInfos,
	const PatternMap& rules)
{

	LogString currentLiteral;

	size_t patternLength = pattern.length();
	int state = LITERAL_STATE;
	logchar c;
	size_t i = 0;
	FormattingInfoPtr formattingInfo(FormattingInfo::getDefault());

	while (i < patternLength)
	{
		c = pattern[i++];

		switch (state)
		{
			case LITERAL_STATE:

				// In literal state, the last char is always a literal.
				if (i == patternLength)
				{
					currentLiteral.append(1, c);

					continue;
				}

				if (c == ESCAPE_CHAR)
				{
					// peek at the next char.
					if (pattern[i] == ESCAPE_CHAR)
					{
						currentLiteral.append(1, c);
						i++; // move pointer
					}
					else
					{
						if (!currentLiteral.empty())
						{
							patternConverters.push_back(
								LiteralPatternConverter::newInstance(currentLiteral));
							formattingInfos.push_back(Forma...",115.0,304.0,1.0,1.0,190.0,91,17,89,18,2,5,20,31,2,1,,0,2,8,4,4,void
30,13379,setOption,1,DBAppender.setOption,"void DBAppender.setOption (LogString,LogString)",main\cpp\dbappender.cpp,"void DBAppender::setOption(const LogString& option, const LogString& value){
    if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""COLUMNMAPPING""), LOG4CXX_STR(""columnmapping"")))
    {
        _priv->mappedName.push_back(value);
    }
    else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""DRIVERNAME""), LOG4CXX_STR(""drivername"")))
    {
        Transcoder::encodeUTF8(value, _priv->driverName);
    }
    else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""DRIVERPARAMS""), LOG4CXX_STR(""driverparams"")))
    {
        Transcoder::encodeUTF8(value, _priv->driverParams);
    }
    else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""DATABASENAME""), LOG4CXX_STR(""databasename"")))
    {
        Transcoder::encodeUTF8(value, _priv->databaseName);
    }
    else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""SQL""), LOG4CXX_STR(""sql"")))
    {
        Transcoder::encodeUTF8(value, _priv->sqlStatement);
    }
    else
    {
        AppenderSkeleton::setOpti...",120.0,145.0,1.0,8.0,26.0,5,3,4,4,0,1,2,2,1,1,,0,1,4,2,2,void
31,50248,timeZone,3,LOG4CXX_NS.helpers.SimpleDateFormatImpl.GeneralTimeZoneToken.timeZone,,main\cpp\simpledateformat.cpp,timeZone,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
32,23628,hexdump,1,LOG4CXX_NS.hexdump,"LogString LOG4CXX_NS.hexdump (void*,uint32_t,HexdumpFlags)",main\cpp\hexdump.cpp,"LogString LOG4CXX_NS::hexdump(const void* bytes, uint32_t len, HexdumpFlags flags){
	LogString ret;
	const uint8_t* bytes_u8 = static_cast<const uint8_t*>(bytes);
	LogStream sstream;
#if LOG4CXX_LOGCHAR_IS_WCHAR
	const wchar_t fill_char = L'0';
	const wchar_t space_fill_char = L' ';
#else
	const logchar fill_char = '0';
	const logchar space_fill_char = ' ';
#endif

	if(flags & HexdumpFlags::AddStartingNewline){
		sstream << LOG4CXX_EOL;
	}

	for(uint32_t offset = 0; offset < len; offset += 16){
		if(offset != 0){
			sstream << LOG4CXX_EOL;
		}

		// Print out the offset
		sstream << std::hex << std::setw(8) << std::setfill(fill_char) << offset << std::resetiosflags(std::ios_base::fmtflags(0));

		sstream << std::setw(0) << LOG4CXX_STR(""  "");

		// Print out the first 8 bytes
		for(int byte = 0; byte < 8; byte++){
			if(offset + byte >= len){
				sstream << LOG4CXX_STR(""  "");
				if(byte != 8){
					sstream << LOG4CXX_STR("" "");
				}
				continue;
			}

			sstream << std::hex << std:...",34.0,116.0,1.0,1.0,83.0,91,10,93,14,0,2,19,38,2,0,,0,2,6,3,3,LogString
33,4177,~APRInitializer,1,APRInitializer.~APRInitializer,ANY APRInitializer.~APRInitializer (),main\cpp\aprinitializer.cpp,"APRInitializer::~APRInitializer()
{
	stopWatchDogs();
	isDestructed = true;
#if APR_HAS_THREADS
	std::unique_lock<std::mutex> lock(m_priv->mutex);
	apr_threadkey_private_delete(m_priv->tlsKey);
#endif
}",94.0,102.0,1.0,1.0,9.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
34,33875,getLoggerRepository,1,LogManager.getLoggerRepository,LoggerRepositoryPtr LogManager.getLoggerRepository (),main\cpp\logmanager.cpp,"LoggerRepositoryPtr LogManager::getLoggerRepository()
{
	return getRepositorySelector()->getLoggerRepository();
}",76.0,79.0,1.0,1.0,4.0,1,1,0,0,7,0,1,1,0,0,,0,0,0,0,0,LoggerRepositoryPtr
35,62548,DEFAULT_PORT,2,main\cpp\xmlsocketappender.cpp.DEFAULT_PORT,,main\cpp\xmlsocketappender.cpp,int DEFAULT_PORT,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
36,9304,encode,1,LOG4CXX_NS.helpers.UTF8CharsetEncoder.encode,"log4cxx_status_t LOG4CXX_NS.helpers.UTF8CharsetEncoder.encode (LogString,ANY,ByteBuffer)",main\cpp\charsetencoder.cpp,"virtual log4cxx_status_t encode(const LogString& in,
			LogString::const_iterator& iter,
			ByteBuffer& out)
		{
			while (iter != in.end() && out.remaining() >= 8)
			{
				unsigned int sv = Transcoder::decode(in, iter);

				if (sv == 0xFFFF)
				{
					return APR_BADARG;
				}

				Transcoder::encodeUTF8(sv, out);
			}

			return APR_SUCCESS;
		}",355.0,372.0,3.0,3.0,18.0,9,6,13,7,0,2,3,4,0,2,,0,1,6,3,3,log4cxx_status_t
37,62552,DEFAULT_RECONNECTION_DELAY,2,main\cpp\xmlsocketappender.cpp.DEFAULT_RECONNECTION_DELAY,,main\cpp\xmlsocketappender.cpp,int DEFAULT_RECONNECTION_DELAY,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
38,33884,getRootLogger,1,LogManager.getRootLogger,LoggerPtr LogManager.getRootLogger (),main\cpp\logmanager.cpp,"LoggerPtr LogManager::getRootLogger()
{
	// Delegate the actual manufacturing of the logger to the logger repository.
	auto r = getLoggerRepository();
	r->ensureIsConfigured(std::bind(DefaultConfigurator::configure, r));
	return r->getRootLogger();
}",81.0,87.0,1.0,1.0,7.0,5,3,6,3,3,0,1,1,0,0,,0,0,0,0,0,LoggerPtr
39,12383,create,1,DatagramSocket.create,DatagramSocketUniquePtr DatagramSocket.create (),main\cpp\datagramsocket.cpp,"DatagramSocketUniquePtr DatagramSocket::create(int localPort1, InetAddressPtr localAddress1){
	auto sock = std::make_unique<APRDatagramSocket>(localPort1, localAddress1);

	sock->bind(localPort1, localAddress1);
	return sock;
}",91.0,96.0,1.0,1.0,6.0,1,1,1,1,1,0,1,1,0,0,,0,0,4,2,2,DatagramSocketUniquePtr
40,37984,os,3,LOG4CXX_NS.rolling.CountingOutputStream.os,,main\cpp\multiprocessrollingfileappender.cpp,os,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
41,57442,inherit,1,ThreadSpecificData.inherit,void ThreadSpecificData.inherit (ANY),main\cpp\threadspecificdata.cpp,"void ThreadSpecificData::inherit(const NDC::Stack& src)
{
	ThreadSpecificData* data = getCurrentData();

	if (data == 0)
	{
		data = createCurrentData();
	}

	if (data != 0)
	{
		data->getStack() = src;
	}
}",143.0,156.0,1.0,1.0,14.0,6,4,6,2,1,0,3,3,0,0,,0,0,2,1,1,void
42,55395,setSyslogHost,1,SyslogAppender.setSyslogHost,void SyslogAppender.setSyslogHost (LogString),main\cpp\syslogappender.cpp,"void SyslogAppender::setSyslogHost(const LogString& syslogHost1)
{
	if (_priv->sw != 0)
	{
		_priv->sw = nullptr;
	}

	LogString slHost = syslogHost1;
	int slHostPort = -1;

	LogString::size_type colonPos = 0;
	colonPos = slHost.rfind(':');

	if (colonPos != LogString::npos)
	{
		slHostPort = StringHelper::toInt(slHost.substr(colonPos + 1));
		// Erase the :port part of the host name
		slHost.erase( colonPos );
	}

	// On the local host, we can directly use the system function 'syslog'
	// if it is available (cf. append)
#if LOG4CXX_HAVE_SYSLOG

	if (syslogHost1 != LOG4CXX_STR(""localhost"") && syslogHost1 != LOG4CXX_STR(""127.0.0.1"")
		&& !syslogHost1.empty())
#endif
	{
		if (slHostPort >= 0)
		{
			_priv->sw = std::make_unique<SyslogWriter>(slHost, slHostPort);
		}
		else
		{
			_priv->sw = std::make_unique<SyslogWriter>(slHost);
		}
	}

	_priv->syslogHost = slHost;
	_priv->syslogHostPort = slHostPort;
}",399.0,439.0,1.0,5.0,41.0,39,12,26,9,0,1,4,4,0,1,,0,1,2,1,1,void
43,37992,close,1,LOG4CXX_NS.rolling.CountingOutputStream.close,void LOG4CXX_NS.rolling.CountingOutputStream.close (Pool),main\cpp\rollingfileappender.cpp,"void close(Pool& p)
		{
			os->close(p);
			rfa = 0;
		}",560.0,564.0,3.0,3.0,5.0,2,2,3,3,0,2,1,1,0,0,,0,2,2,1,1,void
44,18538,decodeLS,1,decodeLS,LogString decodeLS<S> (S*),main\cpp\file.cpp,"static LogString decodeLS(const std::basic_string<S>& src)
{
	LogString dst;
	Transcoder::decode(src, dst);
	return dst;
}",68.0,73.0,1.0,1.0,6.0,2,2,5,3,0,1,2,2,0,1,,0,0,2,1,1,LogString
45,14445,getConfiguratorClass,1,DefaultConfigurator.getConfiguratorClass,LogString DefaultConfigurator.getConfiguratorClass (),main\cpp\defaultconfigurator.cpp,"const LogString DefaultConfigurator::getConfiguratorClass()
{

	// Use automatic configration to configure the default hierarchy
	const LogString log4jConfiguratorClassName(
		OptionConverter::getSystemProperty(LOG4CXX_STR(""log4j.configuratorClass""), LOG4CXX_STR("""")));
	const LogString configuratorClassName(
		OptionConverter::getSystemProperty(LOG4CXX_STR(""LOG4CXX_CONFIGURATOR_CLASS""),
			log4jConfiguratorClassName));
	return configuratorClassName;
}",124.0,134.0,1.0,1.0,11.0,2,1,4,3,0,2,1,1,0,2,,0,0,0,0,0,LogString
46,33909,getLoggerLS,1,LogManager.getLoggerLS,LoggerPtr LogManager.getLoggerLS (LogString),main\cpp\logmanager.cpp,"LoggerPtr LogManager::getLoggerLS(const LogString& name,
	const spi::LoggerFactoryPtr& factory)
{
	// Delegate the actual manufacturing of the logger to the logger repository.
	auto r = getLoggerRepository();
	r->ensureIsConfigured(std::bind(DefaultConfigurator::configure, r));
	return r->getLogger(name, factory);
}",102.0,109.0,1.0,1.0,8.0,5,3,7,4,1,0,1,1,0,0,,0,0,4,2,2,LoggerPtr
47,38005,flush,1,LOG4CXX_NS.rolling.CountingOutputStream.flush,void LOG4CXX_NS.rolling.CountingOutputStream.flush (Pool),main\cpp\rollingfileappender.cpp,"void flush(Pool& p)
		{
			os->flush(p);
		}",569.0,572.0,3.0,3.0,4.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
48,42108,activateOptions,1,PatternLayout.activateOptions,void PatternLayout.activateOptions (Pool),main\cpp\patternlayout.cpp,"void PatternLayout::activateOptions(Pool&)
{
	LogString pat(m_priv->conversionPattern);

	if (pat.empty())
	{
		pat = LOG4CXX_STR(""%m%n"");
	}

	m_priv->patternConverters.erase(m_priv->patternConverters.begin(), m_priv->patternConverters.end());
	m_priv->patternFields.erase(m_priv->patternFields.begin(), m_priv->patternFields.end());
	std::vector<PatternConverterPtr> converters;
	PatternParser::parse(pat,
		converters,
		m_priv->patternFields,
		getFormatSpecifiers());

	//
	//   strip out any pattern converters that don't handle LoggingEvents
	//
	//
	for (std::vector<PatternConverterPtr>::const_iterator converterIter = converters.begin();
		converterIter != converters.end();
		converterIter++)
	{
		LoggingEventPatternConverterPtr eventConverter =
			LOG4CXX_NS::cast<LoggingEventPatternConverter>(*converterIter);

		if (eventConverter != NULL)
		{
			m_priv->patternConverters.push_back(eventConverter);
		}
	}
	m_priv->expectedPatternLength = getFormattedEventCharacterCount() * 2;
}",177.0,211.0,1.0,1.0,35.0,35,8,29,11,0,2,4,5,0,1,,0,1,2,1,1,void
49,38015,write,1,LOG4CXX_NS.rolling.CountingOutputStream.write,"void LOG4CXX_NS.rolling.CountingOutputStream.write (ByteBuffer,Pool)",main\cpp\rollingfileappender.cpp,"void write(ByteBuffer& buf, Pool& p)
		{
			os->write(buf, p);

			if (rfa != 0)
			{
				rfa->incrementFileLength(buf.limit());
			}
		}",577.0,585.0,3.0,3.0,9.0,6,3,7,4,0,4,2,2,1,0,,0,4,4,2,2,void
50,8321,decode,1,LOG4CXX_NS.helpers.UTF8CharsetDecoder.decode,"log4cxx_status_t LOG4CXX_NS.helpers.UTF8CharsetDecoder.decode (ByteBuffer,LogString)",main\cpp\charsetdecoder.cpp,"virtual log4cxx_status_t decode(ByteBuffer& in,
			LogString& out)
		{
			if (in.remaining() > 0)
			{
				std::string tmp(in.current(), in.remaining());
				std::string::const_iterator iter = tmp.begin();

				while (iter != tmp.end())
				{
					unsigned int sv = Transcoder::decode(tmp, iter);

					if (sv == 0xFFFF)
					{
						size_t offset = iter - tmp.begin();
						in.position(in.position() + offset);
						return APR_BADARG;
					}
					else
					{
						Transcoder::encode(sv, out);
					}
				}

				in.position(in.limit());
			}

			return APR_SUCCESS;
		}",287.0,315.0,3.0,3.0,29.0,19,7,22,8,0,1,4,7,0,1,,0,1,4,2,2,log4cxx_status_t
51,14470,getConfigurationFileName,1,DefaultConfigurator.getConfigurationFileName,LogString DefaultConfigurator.getConfigurationFileName (),main\cpp\defaultconfigurator.cpp,"const LogString DefaultConfigurator::getConfigurationFileName()
{
	static const WideLife<LogString> LOG4CXX_DEFAULT_CONFIGURATION_KEY(LOG4CXX_STR(""LOG4CXX_CONFIGURATION""));
	static const WideLife<LogString> LOG4J_DEFAULT_CONFIGURATION_KEY(LOG4CXX_STR(""log4j.configuration""));
	const LogString log4jConfigurationFileName(
		OptionConverter::getSystemProperty(LOG4J_DEFAULT_CONFIGURATION_KEY, LOG4CXX_STR("""")));
	const LogString configurationFileName(
		OptionConverter::getSystemProperty(LOG4CXX_DEFAULT_CONFIGURATION_KEY,
			log4jConfigurationFileName));
	return configurationFileName;
}",137.0,147.0,1.0,1.0,11.0,2,1,6,5,0,2,1,1,0,2,,0,0,0,0,0,LogString
52,21638,activateOptions,1,FixedWindowRollingPolicy.activateOptions,void FixedWindowRollingPolicy.activateOptions (Pool),main\cpp\fixedwindowrollingpolicy.cpp,"void FixedWindowRollingPolicy::activateOptions(Pool& p)
{
	RollingPolicyBase::activateOptions(p);

	if (priv->maxIndex < priv->minIndex)
	{
		LogLog::warn(
			LOG4CXX_STR(""MaxIndex  cannot be smaller than MinIndex.""));
		priv->maxIndex = priv->minIndex;
	}

	if ((priv->maxIndex - priv->minIndex) > MAX_WINDOW_SIZE)
	{
		LogLog::warn(LOG4CXX_STR(""Large window sizes are not allowed.""));
		priv->maxIndex = priv->minIndex + MAX_WINDOW_SIZE;
	}

	PatternConverterPtr itc = getIntegerPatternConverter();

	if (itc == NULL)
	{
		throw IllegalStateException();
	}
}",102.0,125.0,1.0,5.0,24.0,36,10,17,7,0,3,4,4,0,3,,0,0,2,1,1,void
53,4232,unregisterAll,1,APRInitializer.unregisterAll,void APRInitializer.unregisterAll (),main\cpp\aprinitializer.cpp,"void APRInitializer::unregisterAll()
{
	getInstance().stopWatchDogs();
}",116.0,119.0,1.0,1.0,4.0,1,1,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
54,39054,peek,1,NDC.peek,LogString NDC.peek (),main\cpp\ndc.cpp,"bool NDC::peek(std::string& dst)
{
	ThreadSpecificData* data = ThreadSpecificData::getCurrentData();

	if (data != 0)
	{
		Stack& stack = data->getStack();

		if (!stack.empty())
		{
			Transcoder::encode(getMessage(stack.top()), dst);
			return true;
		}

		data->recycle();
	}

	return false;
}",191.0,209.0,1.0,1.0,19.0,9,5,8,3,0,1,3,4,0,0,,0,1,2,1,1,bool
55,51346,setOption,1,SMTPAppender.setOption,"void SMTPAppender.setOption (LogString,LogString)",main\cpp\smtpappender.cpp,"void SMTPAppender::setOption(const LogString& option,
	const LogString& value)
{
	if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""BUFFERSIZE""), LOG4CXX_STR(""buffersize"")))
	{
		setBufferSize(OptionConverter::toInt(value, 512));
	}
	else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""EVALUATORCLASS""), LOG4CXX_STR(""evaluatorclass"")))
	{
		setEvaluatorClass(value);
	}
	else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""FROM""), LOG4CXX_STR(""from"")))
	{
		setFrom(value);
	}
	else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""SMTPHOST""), LOG4CXX_STR(""smtphost"")))
	{
		setSMTPHost(value);
	}
	else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""SMTPUSERNAME""), LOG4CXX_STR(""smtpusername"")))
	{
		setSMTPUsername(value);
	}
	else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""SMTPPASSWORD""), LOG4CXX_STR(""smtppassword"")))
	{
		setSMTPPassword(value);
	}
	else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""SUBJECT""), LOG4CXX_STR(""su...",525.0,576.0,1.0,1.0,52.0,2,1,4,4,0,2,2,2,1,2,,0,1,4,2,2,void
56,32914,getMDCCopy,1,LoggingEvent.getMDCCopy,void LoggingEvent.getMDCCopy (),main\cpp\loggingevent.cpp,"void LoggingEvent::getMDCCopy() const
{
	if (m_priv->mdcCopyLookupRequired)
	{
		m_priv->mdcCopyLookupRequired = false;
		// the clone call is required for asynchronous logging.
		ThreadSpecificData* data = ThreadSpecificData::getCurrentData();

		if (data != 0)
		{
			m_priv->mdcCopy = new MDC::Map(data->getMap());
		}
		else
		{
			m_priv->mdcCopy = new MDC::Map();
		}
	}
}",285.0,302.0,1.0,1.0,18.0,10,5,8,4,0,1,3,4,0,0,,0,1,0,0,0,void
57,9365,encode,1,LOG4CXX_NS.helpers.UTF16BECharsetEncoder.encode,"log4cxx_status_t LOG4CXX_NS.helpers.UTF16BECharsetEncoder.encode (LogString,ANY,ByteBuffer)",main\cpp\charsetencoder.cpp,"virtual log4cxx_status_t encode(const LogString& in,
			LogString::const_iterator& iter,
			ByteBuffer& out)
		{
			while (iter != in.end() && out.remaining() >= 4)
			{
				unsigned int sv = Transcoder::decode(in, iter);

				if (sv == 0xFFFF)
				{
					return APR_BADARG;
				}

				Transcoder::encodeUTF16BE(sv, out);
			}

			return APR_SUCCESS;
		}",390.0,407.0,3.0,3.0,18.0,9,6,13,7,0,2,3,4,0,2,,0,1,6,3,3,log4cxx_status_t
58,45207,configure,1,PropertyConfigurator.configure,ConfigurationStatus PropertyConfigurator.configure (File),main\cpp\propertyconfigurator.cpp,"spi::ConfigurationStatus PropertyConfigurator::configure(helpers::Properties& properties)
{
	return PropertyConfigurator().doConfigure(properties, LogManager::getLoggerRepository());
}",128.0,131.0,1.0,1.0,4.0,2,1,2,2,0,1,1,1,0,0,,0,0,2,1,1,ConfigurationStatus
59,20632,~FileOutputStream,1,FileOutputStream.~FileOutputStream,ANY FileOutputStream.~FileOutputStream (),main\cpp\fileoutputstream.cpp,"FileOutputStream::~FileOutputStream()
{
	if (m_priv->fileptr != NULL && !APRInitializer::isDestructed)
	{
		apr_file_close(m_priv->fileptr);
	}
}",82.0,88.0,1.0,1.0,7.0,6,5,4,3,0,1,2,2,1,0,,0,1,0,0,0,ANY
60,4248,initialize,1,APRInitializer.initialize,log4cxx_time_t APRInitializer.initialize (),main\cpp\aprinitializer.cpp,"log4cxx_time_t APRInitializer::initialize()
{
	return getInstance().m_priv->startTime;
}",129.0,132.0,1.0,1.0,4.0,2,2,0,0,1,0,1,1,0,0,,0,0,0,0,0,log4cxx_time_t
61,38048,getFileOutPutStreamPtr,1,LOG4CXX_NS.rolling.CountingOutputStream.getFileOutPutStreamPtr,OutputStream LOG4CXX_NS.rolling.CountingOutputStream.getFileOutPutStreamPtr (),main\cpp\multiprocessrollingfileappender.cpp,"OutputStream& getFileOutPutStreamPtr()
		{
			return *os;
		}",651.0,654.0,3.0,3.0,4.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,OutputStream
62,4258,getRootPool,1,APRInitializer.getRootPool,apr_pool_t APRInitializer.getRootPool (),main\cpp\aprinitializer.cpp,"apr_pool_t* APRInitializer::getRootPool()
{
	return getInstance().m_priv->p;
}",134.0,137.0,1.0,1.0,4.0,2,2,0,0,1,0,1,1,0,0,,0,0,0,0,0,apr_pool_t
63,17571,formatMessage,1,RuntimeException.formatMessage,LogString RuntimeException.formatMessage (log4cxx_status_t),main\cpp\exception.cpp,"LogString RuntimeException::formatMessage(log4cxx_status_t stat)
{
	LogString s(LOG4CXX_STR(""RuntimeException: return code = ""));
	Pool p;
	StringHelper::toString(stat, p, s);
	return s;
}",106.0,112.0,1.0,1.0,7.0,1,1,5,4,0,1,1,1,0,1,,0,0,2,1,1,LogString
64,14501,getConfigurationWatchDelay,1,DefaultConfigurator.getConfigurationWatchDelay,int DefaultConfigurator.getConfigurationWatchDelay (),main\cpp\defaultconfigurator.cpp,"int DefaultConfigurator::getConfigurationWatchDelay()
{
	static const WideLife<LogString> LOG4CXX_DEFAULT_CONFIGURATION_WATCH_KEY(LOG4CXX_STR(""LOG4CXX_CONFIGURATION_WATCH_SECONDS""));
	LogString optionStr = OptionConverter::getSystemProperty(LOG4CXX_DEFAULT_CONFIGURATION_WATCH_KEY, LogString());
	int milliseconds = 0;
	if (!optionStr.empty())
		milliseconds = StringHelper::toInt(optionStr) * MillisecondsPerSecond;
	return milliseconds;
}",150.0,158.0,1.0,1.0,9.0,8,4,10,6,0,3,2,2,0,2,,0,3,0,0,0,int
65,1189,<lambda>0,1,configure.<lambda>0,ANY configure.<lambda>0 (),examples\cpp\console.cpp,"[r,err]() {
        auto appender = std::make_shared<ConsoleAppender>
            ( std::make_shared<SimpleLayout>()
            , err ? ConsoleAppender::getSystemErr() : ConsoleAppender::getSystemOut()
            );
        r->getRootLogger()->addAppender(appender);
    }",35.0,41.0,27.0,5.0,7.0,12,8,9,5,0,2,1,1,0,0,,0,2,0,0,0,ANY
66,62632,getDefaultDelay,1,XMLSocketAppender.getDefaultDelay,int XMLSocketAppender.getDefaultDelay (),main\cpp\xmlsocketappender.cpp,"int XMLSocketAppender::getDefaultDelay() const
{
	return DEFAULT_RECONNECTION_DELAY;
}",91.0,94.0,1.0,1.0,4.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,int
67,33965,getLogger,1,LogManager.getLogger,LoggerPtr LogManager.getLogger (ANY),main\cpp\logmanager.cpp,"LoggerPtr LogManager::getLogger(const std::string& name,
	const spi::LoggerFactoryPtr& factory)
{
	LOG4CXX_DECODE_CHAR(n, name);
	return getLoggerLS(n, factory);
}",117.0,122.0,1.0,1.0,6.0,0,0,3,2,2,0,1,1,0,0,,0,0,4,2,2,LoggerPtr
68,62638,getDefaultPort,1,XMLSocketAppender.getDefaultPort,int XMLSocketAppender.getDefaultPort (),main\cpp\xmlsocketappender.cpp,"int XMLSocketAppender::getDefaultPort() const
{
	return DEFAULT_PORT;
}",96.0,99.0,1.0,1.0,4.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,int
69,62644,setSocket,1,XMLSocketAppender.setSocket,"void XMLSocketAppender.setSocket (ANY,Pool)",main\cpp\xmlsocketappender.cpp,"void XMLSocketAppender::setSocket(LOG4CXX_NS::helpers::SocketPtr& socket, Pool& p)
{
	OutputStreamPtr os = std::make_shared<SocketOutputStream>(socket);
	CharsetEncoderPtr charset(CharsetEncoder::getUTF8Encoder());
	std::lock_guard<std::recursive_mutex> lock(_priv->mutex);
	_priv->writer = std::make_shared<OutputStreamWriter>(os, charset);
}",101.0,107.0,1.0,44.0,7.0,21,8,13,8,0,1,1,1,0,0,,0,0,4,2,2,void
70,4278,registerCleanup,1,APRInitializer.registerCleanup,void APRInitializer.registerCleanup (FileWatchdog*),main\cpp\aprinitializer.cpp,"void APRInitializer::registerCleanup(FileWatchdog* watchdog)
{
	APRInitializer& instance(getInstance());
	std::unique_lock<std::mutex> lock(instance.m_priv->mutex);
	instance.m_priv->watchdogs.push_back(watchdog);
}",144.0,149.0,1.0,1.0,6.0,9,4,5,3,1,0,1,1,0,0,,0,0,2,1,1,void
71,19639,activateOptionsInternal,1,FileAppender.activateOptionsInternal,void FileAppender.activateOptionsInternal (Pool),main\cpp\fileappender.cpp,"void FileAppender::activateOptionsInternal(Pool& p)
{
	int errors = 0;

	if (!_priv->fileName.empty())
	{
		try
		{
			setFileInternal(_priv->fileName, _priv->fileAppend, _priv->bufferedIO, _priv->bufferSize, p);
		}
		catch (IOException& e)
		{
			errors++;
			LogString msg(LOG4CXX_STR(""setFile(""));
			msg.append(_priv->fileName);
			msg.append(1, (logchar) 0x2C /* ',' */);
			StringHelper::toString(_priv->fileAppend, msg);
			msg.append(LOG4CXX_STR("") call failed.""));
			_priv->errorHandler->error(msg, e, ErrorCode::FILE_OPEN_FAILURE);
		}
	}
	else
	{
		errors++;
		LogLog::error(LogString(LOG4CXX_STR(""File option not set for appender [""))
			+  _priv->name + LOG4CXX_STR(""].""));
		LogLog::warn(LOG4CXX_STR(""Are you using FileAppender instead of ConsoleAppender?""));
	}

	if (errors == 0)
	{
		WriterAppender::activateOptions(p);
	}
}",155.0,188.0,1.0,6.0,34.0,37,7,22,8,2,3,4,5,0,2,,0,1,2,1,1,void
72,10427,ClassRegistration,1,ClassRegistration.ClassRegistration,ANY ClassRegistration.ClassRegistration (ClassAccessor),main\cpp\classregistration.cpp,"ClassRegistration::ClassRegistration(ClassAccessor accessor)
{
	Class::registerClass((*accessor)());
}",24.0,27.0,1.0,1.0,4.0,2,2,2,2,0,1,1,1,0,1,,0,0,2,1,1,ANY
73,24764,getRootLogger,1,Hierarchy.getRootLogger,LoggerPtr Hierarchy.getRootLogger (),main\cpp\hierarchy.cpp,"LoggerPtr Hierarchy::getRootLogger() const
{
	std::lock_guard<std::recursive_mutex> lock(m_priv->mutex);
	if (!m_priv->root)
	{
		m_priv->root = std::make_shared<RootLogger>(m_priv->pool, Level::getDebug());
		m_priv->root->setHierarchy(const_cast<Hierarchy*>(this));
	}

	return m_priv->root;
}",293.0,303.0,1.0,1.0,11.0,20,9,11,4,0,1,2,2,0,0,,0,1,0,0,0,LoggerPtr
74,29885,loadClass,1,Loader.loadClass,Class Loader.loadClass (LogString),main\cpp\loader.cpp,"const Class& Loader::loadClass(const LogString& clazz)
{
	return Class::forName(clazz);
}",57.0,60.0,1.0,1.0,4.0,1,1,2,2,10,1,1,1,0,1,,0,0,2,1,1,Class
75,64711,NoConfiguration,3,LOG4CXX_NS.helpers.ThreadConfigurationType.NoConfiguration,,main\include\log4cxx\helpers\threadutility.hpp,NoConfiguration,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
76,29896,getResourceAsStream,1,Loader.getResourceAsStream,InputStreamPtr Loader.getResourceAsStream (LogString),main\cpp\loader.cpp,"InputStreamPtr Loader::getResourceAsStream(const LogString& name)
{

	try
	{
		return std::make_shared<FileInputStream>(name);
	}
	catch (const IOException&)
	{
	}

	return 0;
}",63.0,75.0,1.0,1.0,13.0,3,3,3,3,1,0,2,2,0,0,,0,0,2,1,1,InputStreamPtr
77,31946,getLogger,1,Logger.getLogger,LoggerPtr Logger.getLogger (ANY),main\cpp\logger.cpp,"LoggerPtr Logger::getLogger(const char* const name)
{
	return LogManager::getLogger(name);
}",581.0,584.0,1.0,1.0,4.0,1,1,2,2,0,1,1,1,0,1,,0,0,2,1,1,LoggerPtr
78,58571,isTriggeringEvent,1,TimeBasedRollingPolicy.isTriggeringEvent,"bool TimeBasedRollingPolicy.isTriggeringEvent (Appender*,ANY,LogString,size_t)",main\cpp\timebasedrollingpolicy.cpp,"bool TimeBasedRollingPolicy::isTriggeringEvent(
	Appender* appender,
	const LOG4CXX_NS::spi::LoggingEventPtr& /* event */,
	const LogString&  filename,
	size_t /* fileLength */)
{
	if( m_priv->multiprocess ){
#if LOG4CXX_HAS_MULTIPROCESS_ROLLING_FILE_APPENDER
		if (m_priv->bRefreshCurFile && m_priv->_mmap && !isMapFileEmpty(m_priv->_mmapPool))
		{
			lockMMapFile(APR_FLOCK_SHARED);
			LogString mapCurrent((char*)m_priv->_mmap->mm);
			unLockMMapFile();
			LogString mapCurrentBase(mapCurrent.substr(0, mapCurrent.length() - m_priv->suffixLength));

			if (!mapCurrentBase.empty() && mapCurrentBase != filename)
			{
				const FileAppender* fappend = reinterpret_cast<const FileAppender*>(appender->cast(FileAppender::getStaticClass()));
				if( fappend ){
					const_cast<FileAppender*>(fappend)->setFile(mapCurrentBase);
				}
			}
		}

		return ( Date::currentTime() > m_priv->nextCheck) || (!m_priv->bAlreadyInitialized);
#endif
	}

	return Date::currentTime() > m_priv->nextCheck;
}",497.0,526.0,1.0,1.0,30.0,4,3,3,2,0,1,2,2,0,0,,0,0,8,4,4,bool
79,57548,priv_data,1,LOG4CXX_NS.helpers.priv_data.priv_data,ANY LOG4CXX_NS.helpers.priv_data.priv_data (),main\cpp\threadutility.cpp,"priv_data()
	{
		start_pre = nullptr;
		started = nullptr;
		start_post = nullptr;
	}",41.0,46.0,2.0,2.0,6.0,3,1,3,3,0,3,1,1,0,0,,0,3,0,0,0,ANY
80,59597,encodeUTF16BE,1,Transcoder.encodeUTF16BE,"void Transcoder.encodeUTF16BE (unsigned int,ByteBuffer)",main\cpp\transcoder.cpp,"size_t Transcoder::encodeUTF16BE(unsigned int ch, char* dst)
{
	if (ch <= 0xFFFF)
	{
		dst[0] = (char) (ch >> 8);
		dst[1] = (char) (ch & 0xFF);
		return 2;
	}

	if (ch <= 0x10FFFF)
	{
		unsigned char w = (unsigned char) ((ch >> 16) - 1);
		dst[0] = (char) (0xD8 + (w >> 2));
		dst[1] = (char) (((w & 0x03) << 6) + ((ch >> 10) & 0x3F));
		dst[2] = (char) (0xDC + ((ch & 0x30) >> 4));
		dst[3] = (char) (ch & 0xFF);
		return 4;
	}

	dst[0] = dst[1] = (char) 0xFF;
	return 2;
}",154.0,175.0,1.0,1.0,22.0,5,3,6,3,1,0,1,1,0,0,,0,0,4,2,2,size_t
81,63695,initialize,1,LOG4CXX_NS.helpers.APRInitializer.initialize,log4cxx_time_t LOG4CXX_NS.helpers.APRInitializer.initialize (),main\include\log4cxx\helpers\aprinitializer.hpp,static log4cxx_time_t initialize();,47.0,47.0,25.0,36.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,log4cxx_time_t
82,9426,encode,1,LOG4CXX_NS.helpers.UTF16LECharsetEncoder.encode,"log4cxx_status_t LOG4CXX_NS.helpers.UTF16LECharsetEncoder.encode (LogString,ANY,ByteBuffer)",main\cpp\charsetencoder.cpp,"virtual log4cxx_status_t encode(const LogString& in,
			LogString::const_iterator& iter,
			ByteBuffer& out)
		{
			while (iter != in.end() && out.remaining() >= 4)
			{
				unsigned int sv = Transcoder::decode(in, iter);

				if (sv == 0xFFFF)
				{
					return APR_BADARG;
				}

				Transcoder::encodeUTF16LE(sv, out);
			}

			return APR_SUCCESS;
		}",425.0,442.0,3.0,3.0,18.0,9,6,13,7,0,2,3,4,0,2,,0,1,6,3,3,log4cxx_status_t
83,28886,setOption,1,LevelMatchFilter.setOption,"void LevelMatchFilter.setOption (LogString,LogString)",main\cpp\levelmatchfilter.cpp,"void LevelMatchFilter::setOption(const LogString& option,
	const LogString& value)
{


	if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""LEVELTOMATCH""), LOG4CXX_STR(""leveltomatch"")))
	{
		setLevelToMatch(value);
	}
	else if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""ACCEPTONMATCH""), LOG4CXX_STR(""acceptonmatch"")))
	{
		priv->acceptOnMatch = OptionConverter::toBoolean(value, priv->acceptOnMatch);
	}
}",49.0,64.0,1.0,2.0,16.0,1,1,3,3,0,1,2,2,1,1,,0,1,4,2,2,void
84,41176,instantiateByKey,1,OptionConverter.instantiateByKey,"ObjectPtr OptionConverter.instantiateByKey (Properties,LogString,Class,ObjectPtr)",main\cpp\optionconverter.cpp,"ObjectPtr OptionConverter::instantiateByKey(Properties& props, const LogString& key,
	const Class& superClass, const ObjectPtr& defaultValue)
{
	// Get the value of the property in string form
	LogString className(findAndSubst(key, props));

	if (className.empty())
	{
		LogLog::error(
			((LogString) LOG4CXX_STR(""Could not find value for key "")) + key);
		return defaultValue;
	}

	// Trim className to avoid trailing spaces that cause problems.
	return OptionConverter::instantiateByClassName(
			StringHelper::trim(className), superClass, defaultValue);
}",364.0,380.0,1.0,1.0,17.0,6,3,11,8,4,3,2,2,0,3,,0,1,8,4,4,ObjectPtr
85,57561,start_pre,3,LOG4CXX_NS.helpers.priv_data.start_pre,,main\cpp\threadutility.cpp,start_pre,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
86,57562,started,3,LOG4CXX_NS.helpers.priv_data.started,,main\cpp\threadutility.cpp,started,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
87,63707,isDestructed,3,LOG4CXX_NS.helpers.APRInitializer.isDestructed,,main\include\log4cxx\helpers\aprinitializer.hpp,isDestructed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
88,57563,start_post,3,LOG4CXX_NS.helpers.priv_data.start_post,,main\cpp\threadutility.cpp,start_post,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
89,13530,activateOptions,1,DBAppender.activateOptions,void DBAppender.activateOptions (ANY),main\cpp\dbappender.cpp,"void DBAppender::activateOptions(helpers::Pool& p){
    apr_status_t stat = apr_dbd_get_driver(_priv->m_pool.getAPRPool(),
                                           _priv->driverName.c_str(),
                                           const_cast<const apr_dbd_driver_t**>(&_priv->m_driver));

    if(stat != APR_SUCCESS){
        LogString errMsg = LOG4CXX_STR(""Unable to get driver named "");
        LOG4CXX_DECODE_CHAR(driverName, _priv->driverName);
        errMsg.append(driverName);
        LogLog::error(errMsg);
        _priv->errorHandler->error(errMsg);
        return;
    }

    stat = apr_dbd_open(_priv->m_driver,
                        _priv->m_pool.getAPRPool(),
                        _priv->driverParams.c_str(),
                        &_priv->m_databaseHandle);
    if(stat != APR_SUCCESS){
        LogLog::error(LOG4CXX_STR(""Unable to open database""));
        _priv->errorHandler->error(LOG4CXX_STR(""Unable to open database""));
        return;
    }

    if(!_priv->databas...",147.0,209.0,1.0,43.0,63.0,110,9,59,13,0,6,7,8,0,5,,0,2,2,1,1,void
90,1249,configure,1,configure,void configure (bool),examples\cpp\console.cpp,"static void configure(bool err)
{
    using namespace log4cxx;
    auto r = LogManager::getLoggerRepository();
    r->ensureIsConfigured([r,err]() {
        auto appender = std::make_shared<ConsoleAppender>
            ( std::make_shared<SimpleLayout>()
            , err ? ConsoleAppender::getSystemErr() : ConsoleAppender::getSystemOut()
            );
        r->getRootLogger()->addAppender(appender);
    });
}",31.0,42.0,1.0,1.0,12.0,3,3,3,2,0,1,1,1,0,0,,0,1,2,1,1,void
91,34020,shutdown,1,LogManager.shutdown,void LogManager.shutdown (),main\cpp\logmanager.cpp,"void LogManager::shutdown()
{
	APRInitializer::unregisterAll();
	getLoggerRepository()->shutdown();
}",203.0,207.0,1.0,1.0,5.0,2,2,1,1,0,1,1,1,0,0,,0,0,0,0,0,void
92,12518,currentTime,1,Date.currentTime,log4cxx_time_t Date.currentTime (),main\cpp\date.cpp,"log4cxx_time_t Date::currentTime(){
	return getCurrentTimeFn ? getCurrentTimeFn() : getCurrentTimeStd();
}",67.0,69.0,1.0,1.0,3.0,1,1,1,1,3,0,1,1,0,0,,0,0,0,0,0,log4cxx_time_t
93,58598,setOption,1,TimeBasedRollingPolicy.setOption,"void TimeBasedRollingPolicy.setOption (LogString,LogString)",main\cpp\timebasedrollingpolicy.cpp,"void TimeBasedRollingPolicy::setOption(const LogString& option,
	const LogString& value)
{
	if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""THROWIOEXCEPTIONONFORKFAILURE""),
			LOG4CXX_STR(""throwioexceptiononforkfailure"")))
	{
		m_priv->throwIOExceptionOnForkFailure = OptionConverter::toBoolean(value, true);
	}
	else
	{
		RollingPolicyBase::setOption(option, value);
	}
}",535.0,548.0,1.0,1.0,14.0,4,3,5,5,0,2,2,2,1,2,,0,2,4,2,2,void
94,39145,pushLS,1,NDC.pushLS,void NDC.pushLS (LogString),main\cpp\ndc.cpp,"void NDC::pushLS(const LogString& message)
{
	ThreadSpecificData::push(message);
}",211.0,214.0,1.0,1.0,4.0,1,1,2,2,0,1,1,1,0,1,,0,0,2,1,1,void
95,31978,getRootLogger,1,Logger.getRootLogger,LoggerPtr Logger.getRootLogger (),main\cpp\logger.cpp,"LoggerPtr Logger::getRootLogger()
{
	return LogManager::getRootLogger();
}",591.0,594.0,1.0,1.0,4.0,1,1,1,1,1,1,1,1,0,0,,0,0,0,0,0,LoggerPtr
96,49387,setLevel,1,RootLogger.setLevel,void RootLogger.setLevel (LevelPtr),main\cpp\rootlogger.cpp,"void RootLogger::setLevel(const LevelPtr level1)
{
	if (level1 == 0)
	{
		LogLog::error(LOG4CXX_STR(""You have tried to set a null level to root.""));
	}
	else
	{
		Logger::setLevel(level1);
	}
}",38.0,48.0,1.0,1.0,11.0,2,2,2,2,0,1,2,2,0,1,,0,0,2,1,1,void
97,14572,configureFromFile,1,DefaultConfigurator.configureFromFile,"tuple<LOG4CXX_NS::spi::ConfigurationStatus,LogString> DefaultConfigurator.configureFromFile (ANY,ANY)",main\cpp\defaultconfigurator.cpp,"std::tuple<LOG4CXX_NS::spi::ConfigurationStatus,LogString>
DefaultConfigurator::configureFromFile(const std::vector<LogString>& directories, const std::vector<LogString>& filenames){
	using ResultType = std::tuple<LOG4CXX_NS::spi::ConfigurationStatus, LogString>;
	LOG4CXX_NS::helpers::Pool pool;

	for( LogString dir : directories ){
		for( LogString fname : filenames ){
			LogString canidate_str = dir + LOG4CXX_STR(""/"") + fname;
			File candidate(canidate_str);

			LogString debugMsg = LOG4CXX_STR(""Checking file "");
			debugMsg.append(canidate_str);
			LogLog::debug(debugMsg);
			if (candidate.exists(pool))
			{
				LOG4CXX_NS::spi::ConfigurationStatus configStatus = tryLoadFile(canidate_str);
				if( configStatus == LOG4CXX_NS::spi::ConfigurationStatus::Configured ){
					return ResultType{configStatus, canidate_str};
				}
				LogLog::debug(LOG4CXX_STR(""Unable to load file: trying next""));
			}
		}
	}

	return ResultType{LOG4CXX_NS::spi::ConfigurationStatus::NotConfigured, LogStri...",173.0,198.0,1.0,1.0,26.0,18,5,25,13,0,2,5,11,0,2,,0,0,4,2,2,"tuple<LOG4CXX_NS.spi.ConfigurationStatus,LogString>"
98,15595,parseFilters,1,DOMConfigurator.parseFilters,"void DOMConfigurator.parseFilters (Pool,ANY,apr_xml_elem*,ANY)",main\cpp\domconfigurator.cpp,"void DOMConfigurator::parseFilters(Pool& p,
	LOG4CXX_NS::helpers::CharsetDecoderPtr& utf8Decoder,
	apr_xml_elem* element,
	std::vector<LOG4CXX_NS::spi::FilterPtr>& filters)
{
	LogString clazz = subst(getAttribute(utf8Decoder, element, CLASS_ATTR));
	FilterPtr filter;
	std::shared_ptr<Object> obj = OptionConverter::instantiateByClassName(clazz,
			Filter::getStaticClass(), 0);
	filter = LOG4CXX_NS::cast<Filter>(obj);

	if (filter != 0)
	{
		PropertySetter propSetter(filter);

		for (apr_xml_elem* currentElement = element->first_child;
			currentElement;
			currentElement = currentElement->next)
		{
			std::string tagName(currentElement->name);

			if (tagName == PARAM_TAG)
			{
				setParameter(p, utf8Decoder, currentElement, propSetter);
			}
		}

		propSetter.activate(p);
		filters.push_back(filter);
	}
}",387.0,417.0,1.0,60.0,31.0,18,7,28,15,0,1,4,7,0,1,,0,1,8,4,4,void
99,47342,setOption,1,RollingFileAppender.setOption,"void RollingFileAppender.setOption (LogString,LogString)",main\cpp\rollingfileappender.cpp,"void RollingFileAppender::setOption(const LogString& option, const LogString& value)
{
	if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""MAXFILESIZE""), LOG4CXX_STR(""maxfilesize""))
		|| StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""MAXIMUMFILESIZE""), LOG4CXX_STR(""maximumfilesize"")))
	{
		setMaxFileSize(value);
	}
	else if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""MAXBACKUPINDEX""), LOG4CXX_STR(""maxbackupindex""))
		|| StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""MAXIMUMBACKUPINDEX""), LOG4CXX_STR(""maximumbackupindex"")))
	{
		setMaxBackupIndex(StringHelper::toInt(value));
	}
	else if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""FILEDATEPATTERN""), LOG4CXX_STR(""filedatepattern"")))
	{
		setDatePattern(value);
	}
	else
	{
		FileAppender::setOption(option, value);
	}
}",77.0,102.0,1.0,1.0,26.0,3,2,5,3,0,2,2,2,2,2,,0,2,4,2,2,void
100,8432,decode,1,LOG4CXX_NS.helpers.ISOLatinCharsetDecoder.decode,"log4cxx_status_t LOG4CXX_NS.helpers.ISOLatinCharsetDecoder.decode (ByteBuffer,LogString)",main\cpp\charsetdecoder.cpp,"virtual log4cxx_status_t decode(ByteBuffer& in,
			LogString& out)
		{
			if (in.remaining() > 0)
			{

				const unsigned char* src = (unsigned char*) in.current();
				const unsigned char* srcEnd = src + in.remaining();

				while (src < srcEnd)
				{
					unsigned int sv = *(src++);
					Transcoder::encode(sv, out);
				}

				in.position(in.limit());
			}

			return APR_SUCCESS;
		}",339.0,358.0,3.0,3.0,20.0,15,8,16,7,0,1,3,4,0,1,,0,0,4,2,2,log4cxx_status_t
101,34032,resetConfiguration,1,LogManager.resetConfiguration,void LogManager.resetConfiguration (),main\cpp\logmanager.cpp,"void LogManager::resetConfiguration()
{
	getLoggerRepository()->resetConfiguration();
}",209.0,212.0,1.0,1.0,4.0,1,1,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
102,52464,connect,1,SocketAppenderSkeleton.connect,void SocketAppenderSkeleton.connect (Pool),main\cpp\socketappenderskeleton.cpp,"void SocketAppenderSkeleton::connect(Pool& p)
{
	if (_priv->address == 0)
	{
		LogLog::error(LogString(LOG4CXX_STR(""No remote host is set for Appender named \"""")) +
			_priv->name + LOG4CXX_STR(""\"".""));
	}
	else
	{
		cleanUp(p);

		try
		{
			LogString msg(LOG4CXX_STR(""Connecting to ["")
				+ _priv->address->toString() + LOG4CXX_STR("":""));
			StringHelper::toString(_priv->port, p, msg);
			msg += LOG4CXX_STR(""]."");
			LogLog::debug(msg);
			SocketPtr socket = Socket::create(_priv->address, _priv->port);
			setSocket(socket, p);
		}
		catch (SocketException& e)
		{
			LogString msg = LOG4CXX_STR(""Could not connect to ["")
				+ _priv->address->toString() + LOG4CXX_STR("":"");
			StringHelper::toString(_priv->port, p, msg);
			msg += LOG4CXX_STR(""]."");

			fireConnector(); // fire the connector thread
			LogLog::error(msg, e);
		}
	}
}",92.0,124.0,1.0,5.0,33.0,10,5,3,2,0,1,2,2,0,1,,0,0,2,1,1,void
103,31987,getLoggerLS,1,Logger.getLoggerLS,"LoggerPtr Logger.getLoggerLS (LogString,ANY)",main\cpp\logger.cpp,"LoggerPtr Logger::getLoggerLS(const LogString& name)
{
	return LogManager::getLoggerLS(name);
}",733.0,736.0,1.0,1.0,4.0,1,1,3,3,0,1,1,1,0,1,,0,0,2,1,1,LoggerPtr
104,54516,initSyslogFacilityStr,1,SyslogAppender.initSyslogFacilityStr,void SyslogAppender.initSyslogFacilityStr (),main\cpp\syslogappender.cpp,"void SyslogAppender::initSyslogFacilityStr()
{
	_priv->facilityStr = getFacilityString(_priv->syslogFacility);

	if (_priv->facilityStr.empty())
	{
		Pool p;
		LogString msg(LOG4CXX_STR(""\""""));
		StringHelper::toString(_priv->syslogFacility, p, msg);
		msg.append(LOG4CXX_STR(""\"" is an unknown syslog facility. Defaulting to \""USER\"".""));
		LogLog::error(msg);
		_priv->syslogFacility = LOG_USER;
		_priv->facilityStr = LOG4CXX_STR(""user:"");
	}
	else
	{
		_priv->facilityStr += LOG4CXX_STR("":"");
	}
}",80.0,98.0,1.0,1.0,19.0,25,4,13,6,0,2,2,2,0,2,,0,0,0,0,0,void
105,55544,setFacility,1,SyslogAppender.setFacility,void SyslogAppender.setFacility (LogString),main\cpp\syslogappender.cpp,"void SyslogAppender::setFacility(const LogString& facilityName)
{
	if (facilityName.empty())
	{
		return;
	}

	_priv->syslogFacility = getFacility(facilityName);

	if (_priv->syslogFacility == LOG_UNDEF)
	{
		LogLog::error(LOG4CXX_STR(""["") + facilityName +
			LOG4CXX_STR(""] is an unknown syslog facility. Defaulting to [USER].""));
		_priv->syslogFacility = LOG_USER;
	}

	this->initSyslogFacilityStr();
}",442.0,459.0,1.0,1.0,18.0,18,7,8,4,0,1,3,3,0,1,,0,0,2,1,1,void
106,34040,removeLogger,1,LogManager.removeLogger,"bool LogManager.removeLogger (LogString,bool)",main\cpp\logmanager.cpp,"bool LogManager::removeLogger(const LogString& name, bool ifNotUsed)
{
#if LOG4CXX_ABI_VERSION <= 15
	bool result = false;
	if (auto r = dynamic_cast<Hierarchy*>(getLoggerRepository().get()))
		result = r->removeLogger(name, ifNotUsed);
	return result;
#else
	return getLoggerRepository()->removeLogger(name, ifNotUsed);
#endif
}",214.0,224.0,1.0,1.0,11.0,6,4,7,4,1,0,2,2,0,0,,0,0,4,2,2,bool
107,64767,WideLife,1,LOG4CXX_NS.helpers.WideLife.WideLife,ANY LOG4CXX_NS.helpers.WideLife.WideLife (),main\include\log4cxx\helpers\widelife.hpp,"WideLife(Arg0&& arg0, Args&&... args)
	{		
		new(&storage) T(std::forward<Arg0>(arg0), std::forward<Args>(args)...);
	}",47.0,50.0,2.0,2.0,4.0,2,2,2,2,0,1,1,1,0,0,,0,1,4,2,2,ANY
108,39169,empty,1,NDC.empty,bool NDC.empty (),main\cpp\ndc.cpp,"bool NDC::empty()
{
	bool empty = true;
	ThreadSpecificData* data = ThreadSpecificData::getCurrentData();

	if (data != 0)
	{
		Stack& stack = data->getStack();
		empty = stack.empty();

		if (empty)
		{
			data->recycle();
		}
	}

	return empty;
}",227.0,244.0,1.0,1.0,18.0,9,4,11,4,0,1,3,4,0,0,,0,1,0,0,0,bool
109,41219,instantiateByClassName,1,OptionConverter.instantiateByClassName,"ObjectPtr OptionConverter.instantiateByClassName (LogString,Class,ObjectPtr)",main\cpp\optionconverter.cpp,"ObjectPtr OptionConverter::instantiateByClassName(const LogString& className,
	const Class& superClass, const ObjectPtr& defaultValue)
{
	if (!className.empty())
	{
		try
		{
			const Class& classObj = Loader::loadClass(className);
			ObjectPtr newObject =  ObjectPtr(classObj.newInstance());

			if (!newObject->instanceof(superClass))
			{
				return defaultValue;
			}

			return newObject;
		}
		catch (Exception& e)
		{
			LogLog::error(LOG4CXX_STR(""Could not instantiate class ["") +
				className + LOG4CXX_STR(""].""), e);
		}
	}

	return defaultValue;
}",382.0,407.0,1.0,1.0,26.0,11,5,14,8,3,2,4,7,0,2,,0,1,6,3,3,ObjectPtr
110,57603,configure,1,LOG4CXX_NS.helpers.ThreadUtility.configure,void LOG4CXX_NS.helpers.ThreadUtility.configure (ThreadConfigurationType),main\cpp\threadutility.cpp,"void ThreadUtility::configure( ThreadConfigurationType type )
{
	auto utility = instance();

	if ( type == ThreadConfigurationType::NoConfiguration )
	{
		utility->configureFuncs( nullptr, nullptr, nullptr );
	}
	else if ( type == ThreadConfigurationType::NameThreadOnly )
	{
		utility->configureFuncs( nullptr,
			std::bind( &ThreadUtility::threadStartedNameThread, utility,
				std::placeholders::_1,
				std::placeholders::_2,
				std::placeholders::_3 ),
			nullptr );
	}
	else if ( type == ThreadConfigurationType::BlockSignalsOnly )
	{
		utility->configureFuncs( std::bind( &ThreadUtility::preThreadBlockSignals, utility ),
			nullptr,
			std::bind( &ThreadUtility::postThreadUnblockSignals, utility ) );
	}
	else if ( type == ThreadConfigurationType::BlockSignalsAndNameThread )
	{
		utility->configureFuncs( std::bind( &ThreadUtility::preThreadBlockSignals, utility ),
			std::bind( &ThreadUtility::threadStartedNameThread, utility,
				std::placeholders::_1,
				std::placeholders::_2,
		...",75.0,107.0,1.0,1.0,33.0,4,4,4,3,0,1,2,2,1,0,,0,1,2,1,1,void
111,17668,formatMessage,1,IOException.formatMessage,LogString IOException.formatMessage (log4cxx_status_t),main\cpp\exception.cpp,"LogString IOException::formatMessage(log4cxx_status_t stat)
{
	char err_buff[1024];
	LogString s(LOG4CXX_STR(""IO Exception : status code = ""));
	Pool p;
	StringHelper::toString(stat, p, s);
	s.append(LOG4CXX_STR(""(""));
	apr_strerror(stat, err_buff, sizeof(err_buff));
	std::string sMsg = err_buff;
	LOG4CXX_DECODE_CHAR(lsMsg, sMsg);
	s.append(lsMsg);
	s.append(LOG4CXX_STR("")""));
	return s;
}",173.0,186.0,1.0,1.0,14.0,6,3,16,7,0,1,1,1,0,1,,0,0,2,1,1,LogString
112,11529,getSystemOut,1,ConsoleAppender.getSystemOut,LogString ConsoleAppender.getSystemOut (),main\cpp\consoleappender.cpp,"const LogString& ConsoleAppender::getSystemOut()
{
	static const WideLife<LogString> name(LOG4CXX_STR(""System.out""));
	return name;
}",71.0,75.0,1.0,1.0,5.0,0,0,1,1,1,0,1,1,0,0,,0,0,0,0,0,LogString
113,10506,colorToANSISequence,1,colorToANSISequence,"LogString colorToANSISequence (LogString,bool,Pool)",main\cpp\colorstartpatternconverter.cpp,"static LogString colorToANSISequence(const LogString& color, bool isForeground, Pool& pool){
	int numberToConvert = 0;

	if(StringHelper::equalsIgnoreCase(color, LOG4CXX_STR(""BLACK""), LOG4CXX_STR(""black""))){
		numberToConvert = 30;
	}else if(StringHelper::equalsIgnoreCase(color, LOG4CXX_STR(""RED""), LOG4CXX_STR(""red""))){
		numberToConvert = 31;
	}else if(StringHelper::equalsIgnoreCase(color, LOG4CXX_STR(""GREEN""), LOG4CXX_STR(""green""))){
		numberToConvert = 32;
	}else if(StringHelper::equalsIgnoreCase(color, LOG4CXX_STR(""YELLOW""), LOG4CXX_STR(""yellow""))){
		numberToConvert = 33;
	}else if(StringHelper::equalsIgnoreCase(color, LOG4CXX_STR(""BLUE""), LOG4CXX_STR(""blue""))){
		numberToConvert = 34;
	}else if(StringHelper::equalsIgnoreCase(color, LOG4CXX_STR(""MAGENTA""), LOG4CXX_STR(""magenta""))){
		numberToConvert = 35;
	}else if(StringHelper::equalsIgnoreCase(color, LOG4CXX_STR(""CYAN""), LOG4CXX_STR(""cyan""))){
		numberToConvert = 36;
	}else if(StringHelper::equalsIgnoreCase(color, LOG4CXX_STR...",34.0,64.0,1.0,1.0,31.0,7,4,12,6,1,2,4,4,1,2,,0,1,6,3,3,LogString
114,9487,encode,1,LOG4CXX_NS.helpers.LocaleCharsetEncoder.encode,"log4cxx_status_t LOG4CXX_NS.helpers.LocaleCharsetEncoder.encode (LogString,ANY,ByteBuffer)",main\cpp\charsetencoder.cpp,"log4cxx_status_t encode
			( const LogString&           in
			, LogString::const_iterator& iter
			, ByteBuffer&                out
			) override
		{
			log4cxx_status_t result = APR_SUCCESS;
#if !LOG4CXX_CHARSET_EBCDIC
			char* current = out.current();
			size_t remain = out.remaining();
			if (std::mbsinit(&this->state)) // ByteBuffer not partially encoded?
			{
				// Copy single byte characters
				for (;
					iter != in.end() && ((unsigned int) *iter) < 0x80 && 0 < remain;
					iter++, remain--, current++)
				{
					*current = *iter;
				}
			}
#endif
			// Encode characters that may require multiple bytes
			while (iter != in.end() && MB_CUR_MAX <= remain)
			{
				auto ch = Transcoder::decode(in, iter);
				auto n = std::wcrtomb(current, ch, &this->state);
				if (static_cast<std::size_t>(-1) == n) // not a valid wide character?
				{
					result = APR_BADARG;
					break;
				}
				remain -= n;
				current += n;
			}
			out.position(current - out.data());
			return result;
		}",457.0,493.0,3.0,3.0,37.0,38,15,36,13,0,3,6,7,1,1,,0,3,6,3,3,log4cxx_status_t
115,28944,setLevelToMatch,1,LevelMatchFilter.setLevelToMatch,void LevelMatchFilter.setLevelToMatch (LogString),main\cpp\levelmatchfilter.cpp,"void LevelMatchFilter::setLevelToMatch(const LogString& levelToMatch1)
{
	priv->levelToMatch = OptionConverter::toLevel(levelToMatch1, priv->levelToMatch);
}",66.0,69.0,1.0,1.0,4.0,8,4,4,3,0,1,1,1,0,1,,0,1,2,1,1,void
116,11539,getSystemErr,1,ConsoleAppender.getSystemErr,LogString ConsoleAppender.getSystemErr (),main\cpp\consoleappender.cpp,"const LogString& ConsoleAppender::getSystemErr()
{
	static const WideLife<LogString> name(LOG4CXX_STR(""System.err""));
	return name;
}",77.0,81.0,1.0,1.0,5.0,0,0,1,1,1,0,1,1,0,0,,0,0,0,0,0,LogString
117,38166,count,3,LOG4CXX_NS.pattern.MaxElementAbbreviator.count,,main\cpp\nameabbreviator.cpp,count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
118,24858,resetConfiguration,1,Hierarchy.resetConfiguration,void Hierarchy.resetConfiguration (),main\cpp\hierarchy.cpp,"void Hierarchy::resetConfiguration()
{
	std::lock_guard<std::recursive_mutex> lock(m_priv->mutex);

	if (m_priv->root)
	{
		m_priv->root->setLevel(Level::getDebug());
		m_priv->root->setResourceBundle(0);
	}
	setThresholdInternal(Level::getAll());

	shutdownInternal();

	LoggerMap::const_iterator it, itEnd = m_priv->loggers.end();

	for (it = m_priv->loggers.begin(); it != itEnd; it++)
	{
		if (auto pLogger = it->second)
		{
			pLogger->setLevel(0);
			pLogger->setAdditivity(true);
			pLogger->setResourceBundle(0);
		}
	}

	//rendererMap.clear();
}",320.0,346.0,1.0,1.0,27.0,24,6,19,6,0,2,4,5,0,0,,0,0,0,0,0,void
119,38170,abbreviate,1,LOG4CXX_NS.pattern.MaxElementAbbreviator.abbreviate,"void LOG4CXX_NS.pattern.MaxElementAbbreviator.abbreviate (ANY,LogString)",main\cpp\nameabbreviator.cpp,"void abbreviate(LogString::size_type nameStart, LogString& buf) const override
		{
			// We substract 1 from 'len' when assigning to 'end' to avoid out of
			// bounds exception in return r.substring(end+1, len). This can happen if
			// precision is 1 and the logger name ends with a dot.
			LogString::size_type end = buf.length() - 1;

			for (LogString::size_type i = count; i > 0; i--)
			{
				end = buf.rfind(0x2E /* '.' */, end - 1);

				if ((end == LogString::npos) || (end < nameStart))
				{
					return;
				}
			}

			buf.erase(buf.begin() + nameStart, buf.begin() + (end + 1));
		}",99.0,117.0,3.0,3.0,19.0,18,8,17,6,0,1,3,4,0,0,,0,1,4,2,2,void
120,44629,DELIMITER,3,PropertyParser.LexemType.DELIMITER,,main\cpp\properties.cpp,DELIMITER,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
121,11549,setTarget,1,ConsoleAppender.setTarget,void ConsoleAppender.setTarget (LogString),main\cpp\consoleappender.cpp,"void ConsoleAppender::setTarget(const LogString& value)
{
	LogString v = StringHelper::trim(value);

	if (StringHelper::equalsIgnoreCase(v,
			LOG4CXX_STR(""SYSTEM.OUT""), LOG4CXX_STR(""system.out"")))
	{
		_priv->target = getSystemOut();
	}
	else if (StringHelper::equalsIgnoreCase(v,
			LOG4CXX_STR(""SYSTEM.ERR""), LOG4CXX_STR(""system.err"")))
	{
		_priv->target = getSystemErr();
	}
	else
	{
		targetWarn(value);
	}
}",83.0,101.0,1.0,2.0,19.0,7,4,6,4,0,2,2,2,1,2,,0,2,2,1,1,void
122,62752,append,1,XMLSocketAppender.append,"void XMLSocketAppender.append (ANY,ANY)",main\cpp\xmlsocketappender.cpp,"void XMLSocketAppender::append(const spi::LoggingEventPtr& event, LOG4CXX_NS::helpers::Pool& p)
{
	if (_priv->writer)
	{
		LogString output;
		_priv->layout->format(output, event, p);

		try
		{
			_priv->writer->write(output, p);
			_priv->writer->flush(p);
		}
		catch (std::exception& e)
		{
			_priv->writer = nullptr;
			LogLog::warn(LOG4CXX_STR(""Detected problem with connection: ""), e);

			if (getReconnectionDelay() > 0)
			{
				fireConnector();
			}
		}
	}
}",124.0,147.0,1.0,5.0,24.0,21,5,13,6,0,1,4,7,0,1,,0,0,4,2,2,void
123,12580,numberFormat,1,DateFormat.numberFormat,"void DateFormat.numberFormat (LogString,int,Pool)",main\cpp\dateformat.cpp,"void DateFormat::numberFormat(LogString& s, int n, Pool& p) const
{
	StringHelper::toString(n, p, s);
}",32.0,35.0,1.0,1.0,4.0,1,1,4,4,0,1,1,1,0,1,,0,0,6,3,3,void
124,16679,doConfigure,1,DOMConfigurator.doConfigure,"ConfigurationStatus DOMConfigurator.doConfigure (File,ANY)",main\cpp\domconfigurator.cpp,"spi::ConfigurationStatus DOMConfigurator::doConfigure(const File& filename, spi::LoggerRepositoryPtr repository1)
{
	repository1->setConfigured(true);
	m_priv->repository = repository1;
	LogString msg(LOG4CXX_STR(""DOMConfigurator configuring file ""));
	msg.append(filename.getPath());
	msg.append(LOG4CXX_STR(""...""));
	LogLog::debug(msg);

	m_priv->loggerFactory = std::make_shared<DefaultLoggerFactory>();

	Pool p;
	apr_file_t* fd;

	log4cxx_status_t rv = filename.open(&fd, APR_READ, APR_OS_DEFAULT, p);

	if (rv != APR_SUCCESS)
	{
		// There is not technically an exception thrown here, but this behavior matches
		// what the PropertyConfigurator does
		IOException io(rv);
		LogString msg2(LOG4CXX_STR(""Could not read configuration file [""));
		msg2.append(filename.getPath());
		msg2.append(LOG4CXX_STR(""]. ""));
		LOG4CXX_DECODE_CHAR(msg, io.what());
		msg2.append(msg);
		LogLog::error(msg2);
		return spi::ConfigurationStatus::NotConfigured;
	}
	else
	{
		apr_xml_parser* parser = NULL;
	...",780.0,850.0,1.0,1.0,71.0,24,5,32,16,0,2,2,2,0,2,,0,0,4,2,2,ConfigurationStatus
125,64807,value,1,LOG4CXX_NS.helpers.WideLife.value,T LOG4CXX_NS.helpers.WideLife.value (),main\include\log4cxx\helpers\widelife.hpp,"const T& value() const
	{
		return *reinterpret_cast<const T*>(&storage);
	}",66.0,69.0,2.0,2.0,4.0,3,3,1,1,0,1,1,1,0,0,,0,1,0,0,0,T
126,58664,getInstance,1,LOG4CXX_NS.helpers.TimeZoneImpl.GMTTimeZone.getInstance,TimeZonePtr LOG4CXX_NS.helpers.TimeZoneImpl.GMTTimeZone.getInstance (),main\cpp\timezone.cpp,"static const TimeZonePtr& getInstance()
		{
			static WideLife<TimeZonePtr> tz = std::make_shared<GMTTimeZone>();
			return tz;
		}",47.0,51.0,3.0,3.0,5.0,2,2,3,2,2,0,1,1,0,0,,0,0,0,0,0,TimeZonePtr
127,49453,create,1,ServerSocket.create,ServerSocketUniquePtr ServerSocket.create (int),main\cpp\serversocket.cpp,"ServerSocketUniquePtr ServerSocket::create(int port){
	return std::make_unique<APRServerSocket>(port);
}",54.0,56.0,1.0,1.0,3.0,3,3,3,3,1,0,1,1,0,0,,0,0,2,1,1,ServerSocketUniquePtr
128,30000,,2,main\cpp\locationinfo.cpp.nan,,main\cpp\locationinfo.cpp,const char* NA,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
129,3376,doAppendImpl,1,AppenderSkeleton.doAppendImpl,"void AppenderSkeleton.doAppendImpl (ANY,Pool)",main\cpp\appenderskeleton.cpp,"void AppenderSkeleton::doAppendImpl(const spi::LoggingEventPtr& event, Pool& pool1)
{
	if (m_priv->closed)
	{
		LogLog::error(((LogString) LOG4CXX_STR(""Attempted to append to closed appender named [""))
			+ m_priv->name + LOG4CXX_STR(""].""));
		return;
	}

	if (!isAsSevereAsThreshold(event->getLevel()))
	{
		return;
	}

	FilterPtr f = m_priv->headFilter;


	while (f != 0)
	{
		switch (f->decide(event))
		{
			case Filter::DENY:
				return;

			case Filter::ACCEPT:
				f = nullptr;
				break;

			case Filter::NEUTRAL:
				f = f->getNext();
		}
	}

	append(event, pool1);
}",98.0,132.0,1.0,1.0,35.0,18,7,17,6,0,1,6,6,0,1,,0,0,4,2,2,void
130,53554,equalsIgnoreCase,1,StringHelper.equalsIgnoreCase,"bool StringHelper.equalsIgnoreCase (LogString,logchar*,logchar*)",main\cpp\stringhelper.cpp,"bool StringHelper::equalsIgnoreCase(const LogString& s1, const LogString& upper, const LogString& lower)
{
	LogString::const_iterator u = upper.begin();
	LogString::const_iterator l = lower.begin();
	LogString::const_iterator iter = s1.begin();

	for (;
		iter != s1.end() && u != upper.end() && l != lower.end();
		iter++, u++, l++)
	{
		if (*iter != *u && *iter != *l)
		{
			return false;
		}
	}

	return u == upper.end() && iter == s1.end();
}",46.0,63.0,1.0,1.0,18.0,13,6,9,4,48,0,3,4,0,0,,0,0,6,3,3,bool
131,30004,NA_METHOD,2,main\cpp\locationinfo.cpp.NA_METHOD,,main\cpp\locationinfo.cpp,const char* NA_METHOD,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
132,60726,appendEscapingTags,1,Transform.appendEscapingTags,"void Transform.appendEscapingTags (LogString,LogString)",main\cpp\transform.cpp,"void Transform::appendEscapingTags(
	LogString& buf, const LogString& input)
{
	//Check if the string is zero length -- if so, return
	//what was sent in.

	if (input.length() == 0 )
	{
		return;
	}

	logchar specials[] = { 0x22 /* "" */, 0x26 /* & */, 0x3C /* < */, 0x3E /* > */, 0x00 };
	size_t start = 0;
	size_t special = input.find_first_of(specials, start);

	while (special != LogString::npos)
	{
		if (special > start)
		{
			buf.append(input, start, special - start);
		}

		switch (input[special])
		{
			case 0x22:
				buf.append(LOG4CXX_STR(""&quot;""));
				break;

			case 0x26:
				buf.append(LOG4CXX_STR(""&amp;""));
				break;

			case 0x3C:
				buf.append(LOG4CXX_STR(""&lt;""));
				break;

			case 0x3E:
				buf.append(LOG4CXX_STR(""&gt;""));
				break;

			default:
				buf.append(1, input[special]);
				break;
		}

		start = special + 1;

		if (special < input.size())
		{
			special = input.find_first_of(specials, start);
		}
		else
		{
			special = LogString::npos;
		}
	}

	if (s...",27.0,88.0,1.0,1.0,62.0,30,10,40,6,14,0,12,10,0,0,,0,0,4,2,2,void
133,5431,setOption,1,AsyncAppender.setOption,"void AsyncAppender.setOption (LogString,LogString)",main\cpp\asyncappender.cpp,"void AsyncAppender::setOption(const LogString& option,
	const LogString& value)
{
	if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""LOCATIONINFO""), LOG4CXX_STR(""locationinfo"")))
	{
		setLocationInfo(OptionConverter::toBoolean(value, false));
	}

	if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""BUFFERSIZE""), LOG4CXX_STR(""buffersize"")))
	{
		setBufferSize(OptionConverter::toInt(value, DEFAULT_BUFFER_SIZE));
	}

	if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""BLOCKING""), LOG4CXX_STR(""blocking"")))
	{
		setBlocking(OptionConverter::toBoolean(value, true));
	}
	else
	{
		AppenderSkeleton::setOption(option, value);
	}
}",194.0,215.0,1.0,1.0,22.0,6,1,13,5,0,6,4,4,3,6,,0,3,4,2,2,void
134,8510,decode,1,LOG4CXX_NS.helpers.USASCIICharsetDecoder.decode,"log4cxx_status_t LOG4CXX_NS.helpers.USASCIICharsetDecoder.decode (ByteBuffer,LogString)",main\cpp\charsetdecoder.cpp,"virtual log4cxx_status_t decode(ByteBuffer& in,
			LogString& out)
		{
			log4cxx_status_t stat = APR_SUCCESS;

			if (in.remaining() > 0)
			{

				const unsigned char* src = (unsigned char*) in.current();
				const unsigned char* srcEnd = src + in.remaining();

				while (src < srcEnd)
				{
					unsigned char sv = *src;

					if (sv < 0x80)
					{
						src++;
						Transcoder::encode(sv, out);
					}
					else
					{
						stat = APR_BADARG;
						break;
					}
				}

				in.position(src - (const unsigned char*) in.data());
			}

			return stat;
		}",385.0,416.0,3.0,3.0,32.0,19,9,21,8,0,1,4,7,0,1,,0,0,4,2,2,log4cxx_status_t
135,41278,selectAndConfigure,1,OptionConverter.selectAndConfigure,"void OptionConverter.selectAndConfigure (File,LogString,ANY,int)",main\cpp\optionconverter.cpp,"void OptionConverter::selectAndConfigure(const File& configFileName,
	const LogString& _clazz, spi::LoggerRepositoryPtr hierarchy, int delay)
{
	ConfiguratorPtr configurator;
	LogString clazz = _clazz;

	LogString filename(configFileName.getPath());

#if LOG4CXX_HAS_DOMCONFIGURATOR
	if (clazz.empty()
		&& filename.length() > 4
		&& StringHelper::equalsIgnoreCase(
			filename.substr(filename.length() - 4),
			LOG4CXX_STR("".XML""), LOG4CXX_STR("".xml"")))
	{
		clazz = LOG4CXX_NS::xml::DOMConfigurator::getStaticClass().toString();
	}
#endif

	if (!clazz.empty())
	{
		LogLog::debug(LOG4CXX_STR(""Preferred configurator class: "") + clazz);
		const Class& clazzObj = Loader::loadClass(clazz);
		ObjectPtr obj = ObjectPtr(clazzObj.newInstance());
		configurator = LOG4CXX_NS::cast<Configurator>(obj);

		if (configurator == 0)
		{
			LogLog::error(LOG4CXX_STR(""Could not instantiate configurator ["")
				+ clazz + LOG4CXX_STR(""].""));
			return;
		}
	}
	else
	{
		configurator = std::make_shared<Proper...",409.0,456.0,1.0,1.0,48.0,24,9,28,14,1,4,4,5,0,4,,0,1,8,4,4,void
136,36167,m_quote,3,anonymous_namespace_1.QuotedMessagePatternConverter.m_quote,,main\cpp\messagepatternconverter.cpp,m_quote,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
137,64839,storage,3,LOG4CXX_NS.helpers.WideLife.storage,,main\include\log4cxx\helpers\widelife.hpp,storage[sizeof(T)],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
138,15691,parseLogger,1,DOMConfigurator.parseLogger,"void DOMConfigurator.parseLogger (ANY,ANY,apr_xml_elem*,apr_xml_doc*,AppenderMap)",main\cpp\domconfigurator.cpp,"void DOMConfigurator::parseLogger(
	LOG4CXX_NS::helpers::Pool& p,
	LOG4CXX_NS::helpers::CharsetDecoderPtr& utf8Decoder,
	apr_xml_elem* loggerElement,
	apr_xml_doc* doc,
	AppenderMap& appenders)
{
	// Create a new Logger object from the <category> element.
	LogString loggerName = subst(getAttribute(utf8Decoder, loggerElement, NAME_ATTR));

	LogLog::debug(LOG4CXX_STR(""Retreiving an instance of Logger.""));
	LoggerPtr logger = m_priv->repository->getLogger(loggerName, m_priv->loggerFactory);

	// Setting up a logger needs to be an atomic operation, in order
	// to protect potential log operations while logger
	// configuration is in progress.
	bool additivity = OptionConverter::toBoolean(
			subst(getAttribute(utf8Decoder, loggerElement, ADDITIVITY_ATTR)),
			true);

	LogLog::debug(LOG4CXX_STR(""Setting ["") + logger->getName() + LOG4CXX_STR(""] additivity to ["") +
		(additivity ? LogString(LOG4CXX_STR(""true"")) : LogString(LOG4CXX_STR(""false""))) + LOG4CXX_STR(""].""));
	logger->setAdditivity...",422.0,446.0,1.0,71.0,25.0,16,5,23,11,0,3,1,1,0,3,,0,1,10,5,5,void
139,51533,asciiCheck,1,SMTPAppender.asciiCheck,"bool SMTPAppender.asciiCheck (LogString,LogString)",main\cpp\smtpappender.cpp,"bool SMTPAppender::asciiCheck(const LogString& value, const LogString& field)
{
	for (LogString::const_iterator iter = value.begin();
		iter != value.end();
		iter++)
	{
		if (0x7F < (unsigned int) *iter)
		{
			LogLog::warn(field + LOG4CXX_STR("" contains non-ASCII character""));
			return false;
		}
	}

	return true;
}",579.0,593.0,1.0,1.0,15.0,9,7,7,4,0,1,3,4,0,1,,0,0,4,2,2,bool
140,36173,format,1,anonymous_namespace_3.QuotedMessagePatternConverter.format,"void anonymous_namespace_3.QuotedMessagePatternConverter.format (ANY,LogString,ANY)",main\cpp\messagepatternconverter.cpp,"void format
			( const spi::LoggingEventPtr& event
			, LogString&                  toAppendTo
			, helpers::Pool&              p
			) const override
		{
			auto& input = event->getRenderedMessage();
			size_t endIndex, startIndex = 0;
			while ((endIndex = input.find(m_quote, startIndex)) != input.npos)
			{
				toAppendTo.append(input.substr(startIndex, endIndex - startIndex + 1));
				toAppendTo += m_quote;
				startIndex = endIndex + 1;
			}
			toAppendTo.append(input.substr(startIndex));
		}",45.0,60.0,3.0,3.0,16.0,16,7,20,6,0,2,2,2,1,0,,0,2,6,3,3,void
141,59733,encodeUTF16LE,1,Transcoder.encodeUTF16LE,"void Transcoder.encodeUTF16LE (unsigned int,ByteBuffer)",main\cpp\transcoder.cpp,"size_t Transcoder::encodeUTF16LE(unsigned int ch, char* dst)
{
	if (ch <= 0xFFFF)
	{
		dst[1] = (char) (ch >> 8);
		dst[0] = (char) (ch & 0xFF);
		return 2;
	}

	if (ch <= 0x10FFFF)
	{
		unsigned char w = (unsigned char) ((ch >> 16) - 1);
		dst[1] = (char) (0xD8 + (w >> 2));
		dst[0] = (char) (((w & 0x03) << 6) + ((ch >> 10) & 0x3F));
		dst[3] = (char) (0xDC + ((ch & 0x30) >> 4));
		dst[2] = (char) (ch & 0xFF);
		return 4;
	}

	dst[0] = dst[1] = (char) 0xFF;
	return 2;
}",183.0,204.0,1.0,1.0,22.0,5,3,6,3,1,0,1,1,0,0,,0,0,4,2,2,size_t
142,34135,set_stream_state,1,logstream_base.set_stream_state,"bool logstream_base.set_stream_state (ANY,int)",main\cpp\logstream.cpp,"bool logstream_base::set_stream_state(std::ios_base& dest, int& dstchar)
{
	std::ios_base::fmtflags setval = initset.flags();
	std::ios_base::fmtflags clrval = initclear.flags();
	std::ios_base::fmtflags mask = setval ^ (~clrval);
	dest.setf(clrval, mask);

	if (initset.precision() == initclear.precision())
	{
		dest.precision(initset.precision());
	}

	if (initset.width() == initclear.width())
	{
		dest.width(initset.width());
	}

	dstchar = fillchar;
	return fillset;
}",72.0,91.0,1.0,1.0,20.0,19,5,21,9,1,0,3,3,0,0,,0,0,4,2,2,bool
143,38238,charCount,3,LOG4CXX_NS.pattern.PatternAbbreviatorFragment.charCount,,main\cpp\nameabbreviator.cpp,charCount,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
144,38239,ellipsis,3,LOG4CXX_NS.pattern.PatternAbbreviatorFragment.ellipsis,,main\cpp\nameabbreviator.cpp,ellipsis,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
145,21862,rollover,1,FixedWindowRollingPolicy.rollover,"RolloverDescriptionPtr FixedWindowRollingPolicy.rollover (LogString,bool,Pool)",main\cpp\fixedwindowrollingpolicy.cpp,"RolloverDescriptionPtr FixedWindowRollingPolicy::rollover(
	const   LogString&  currentActiveFile,
	const   bool        append,
	Pool&       pool)
{
	RolloverDescriptionPtr desc;

	if (priv->maxIndex < 0)
	{
		return desc;
	}

	int purgeStart = priv->minIndex;

	if (!priv->explicitActiveFile)
	{
		purgeStart++;
	}

	if (!purge(purgeStart, priv->maxIndex, pool))
	{
		return desc;
	}

	LogString buf;
	ObjectPtr obj = std::make_shared<Integer>(purgeStart);
	formatFileName(obj, buf, pool);

	LogString renameTo(buf);
	LogString compressedName(renameTo);
	ActionPtr compressAction ;

	if(getCreateIntermediateDirectories()){
		File compressedFile(compressedName);
		File compressedParent (compressedFile.getParent(pool));
		compressedParent.mkdirs(pool);
	}

	if (StringHelper::endsWith(renameTo, LOG4CXX_STR("".gz"")))
	{
		renameTo.resize(renameTo.size() - 3);
		GZCompressActionPtr comp = std::make_shared<GZCompressAction>(
					File().setPath(renameTo),
					File().setPath(compressedName),
			...",160.0,229.0,1.0,5.0,70.0,54,11,50,21,0,1,6,6,1,1,,0,1,6,3,3,RolloverDescriptionPtr
146,30055,clear,1,LocationInfo.clear,void LocationInfo.clear (),main\cpp\locationinfo.cpp,"void LocationInfo::clear()
{
	fileName = NA;
	methodName = NA_METHOD;
	lineNumber = -1;
}",92.0,97.0,1.0,1.0,6.0,4,2,5,5,0,2,1,1,0,0,,0,2,0,0,0,void
147,58732,getInstance,1,LOG4CXX_NS.helpers.TimeZoneImpl.LocalTimeZone.getInstance,TimeZonePtr LOG4CXX_NS.helpers.TimeZoneImpl.LocalTimeZone.getInstance (),main\cpp\timezone.cpp,"static const TimeZonePtr& getInstance()
		{
			static WideLife<TimeZonePtr> tz = std::make_shared<LocalTimeZone>();
			return tz;
		}",86.0,90.0,3.0,3.0,5.0,2,2,3,2,1,0,1,1,0,0,,0,0,0,0,0,TimeZonePtr
148,11629,targetWarn,1,ConsoleAppender.targetWarn,void ConsoleAppender.targetWarn (LogString),main\cpp\consoleappender.cpp,"void ConsoleAppender::targetWarn(const LogString& val)
{
	LogLog::warn(((LogString) LOG4CXX_STR(""[""))
		+ val +  LOG4CXX_STR(""] should be system.out or system.err.""));
	LogLog::warn(LOG4CXX_STR(""Using previously set target, System.out by default.""));
}",108.0,113.0,1.0,1.0,6.0,5,3,3,2,0,2,1,1,0,2,,0,0,2,1,1,void
149,38255,operator =,1,LOG4CXX_NS.pattern.PatternAbbreviatorFragment.operator =,PatternAbbreviatorFragment LOG4CXX_NS.pattern.PatternAbbreviatorFragment.operator = (PatternAbbreviatorFragment),main\cpp\nameabbreviator.cpp,"PatternAbbreviatorFragment& operator=(const PatternAbbreviatorFragment& src)
		{
			charCount = src.charCount;
			ellipsis = src.ellipsis;
			return *this;
		}",158.0,163.0,3.0,3.0,6.0,5,3,4,3,0,4,1,1,0,0,,0,4,2,1,1,PatternAbbreviatorFragment
150,26992,format,1,IntegerPatternConverter.format,"void IntegerPatternConverter.format (ObjectPtr,LogString,Pool)",main\cpp\integerpatternconverter.cpp,"void IntegerPatternConverter::format(
	const ObjectPtr& obj,
	LogString& toAppendTo,
	Pool& p) const
{
	IntegerPtr i = LOG4CXX_NS::cast<Integer>(obj);

	if (i != NULL)
	{
		StringHelper::toString(i->intValue(), p, toAppendTo);
	}
}",42.0,53.0,1.0,1.0,12.0,7,6,10,8,0,1,2,2,0,1,,0,0,6,3,3,void
151,7535,digits,2,main\cpp\cacheddateformat.cpp.digits,,main\cpp\cacheddateformat.cpp,ANY digits,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
152,40308,error,1,OnlyOnceErrorHandler.error,"void OnlyOnceErrorHandler.error (LogString,ANY,int)",main\cpp\onlyonceerrorhandler.cpp,"void OnlyOnceErrorHandler::error(const LogString& message) const
{
	if (m_priv->firstTime)
	{
		LogLog::error(message);
		m_priv->firstTime = false;
	}
}",76.0,83.0,1.0,1.0,8.0,4,3,5,4,0,1,2,2,0,1,,0,0,2,1,1,void
153,66932,GENERIC_FAILURE,3,LOG4CXX_NS.spi.ErrorCode.anonymous_enum_0.GENERIC_FAILURE,,main\include\log4cxx\spi\errorhandler.hpp,GENERIC_FAILURE = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
154,66936,FILE_OPEN_FAILURE,3,LOG4CXX_NS.spi.ErrorCode.anonymous_enum_0.FILE_OPEN_FAILURE,,main\include\log4cxx\spi\errorhandler.hpp,FILE_OPEN_FAILURE = 4,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
155,7550,magic1,2,main\cpp\cacheddateformat.cpp.magic1,,main\cpp\cacheddateformat.cpp,const int magic1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
156,3456,setErrorHandler,1,AppenderSkeleton.setErrorHandler,void AppenderSkeleton.setErrorHandler (ANY),main\cpp\appenderskeleton.cpp,"void AppenderSkeleton::setErrorHandler(const spi::ErrorHandlerPtr errorHandler1)
{
	std::lock_guard<std::recursive_mutex> lock(m_priv->mutex);

	if (errorHandler1 == nullptr)
	{
		// We do not throw exception here since the cause is probably a
		// bad config file.
		LogLog::warn(LOG4CXX_STR(""You have tried to set a null error-handler.""));
	}
	else
	{
		m_priv->errorHandler = errorHandler1;
	}
}",134.0,148.0,1.0,1.0,15.0,7,5,5,4,0,1,2,2,0,1,,0,0,2,1,1,void
157,38273,abbreviate,1,LOG4CXX_NS.pattern.PatternAbbreviatorFragment.abbreviate,"size_type LOG4CXX_NS.pattern.PatternAbbreviatorFragment.abbreviate (LogString,ANY)",main\cpp\nameabbreviator.cpp,"LogString::size_type abbreviate(LogString& buf, LogString::size_type startPos) const
		{
			LogString::size_type nextDot = buf.find(0x2E /* '.' */, startPos);

			if (nextDot != LogString::npos)
			{
				if ((nextDot - startPos) > charCount)
				{
					buf.erase(buf.begin() + (startPos + charCount), buf.begin() + nextDot);
					nextDot = startPos + charCount;

					if (ellipsis != 0x00)
					{
						buf.insert(nextDot, 1, ellipsis);
						nextDot++;
					}
				}

				nextDot++;
			}

			return nextDot;
		}",171.0,193.0,3.0,3.0,23.0,18,7,24,6,0,5,4,7,2,0,,0,5,4,2,2,size_type
158,7554,magicString1,2,main\cpp\cacheddateformat.cpp.magicString1,,main\cpp\cacheddateformat.cpp,ANY magicString1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
159,61829,setOption,1,WriterAppender.setOption,"void WriterAppender.setOption (LogString,LogString)",main\cpp\writerappender.cpp,"void WriterAppender::setOption(const LogString& option, const LogString& value)
{
	if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""ENCODING""), LOG4CXX_STR(""encoding"")))
	{
		setEncoding(value);
	}
	else
	{
		AppenderSkeleton::setOption(option, value);
	}
}",307.0,317.0,1.0,1.0,11.0,1,1,3,3,0,1,2,2,1,1,,0,1,4,2,2,void
160,11653,activateOptions,1,ConsoleAppender.activateOptions,void ConsoleAppender.activateOptions (Pool),main\cpp\consoleappender.cpp,"void ConsoleAppender::activateOptions(Pool& p)
{
	if (StringHelper::equalsIgnoreCase(_priv->target,
			LOG4CXX_STR(""SYSTEM.OUT""), LOG4CXX_STR(""system.out"")))
	{
		WriterPtr writer1 = std::make_shared<SystemOutWriter>();
		setWriter(writer1);
	}
	else if (StringHelper::equalsIgnoreCase(_priv->target,
			LOG4CXX_STR(""SYSTEM.ERR""), LOG4CXX_STR(""system.err"")))
	{
		WriterPtr writer1 = std::make_shared<SystemErrWriter>();
		setWriter(writer1);
	}

	WriterAppender::activateOptions(p);
}",115.0,131.0,1.0,36.0,17.0,7,4,7,6,0,2,2,2,1,2,,0,1,2,1,1,void
161,28041,appendSerializedLocationInfo,1,JSONLayout.appendSerializedLocationInfo,"void JSONLayout.appendSerializedLocationInfo (LogString,LoggingEventPtr,Pool)",main\cpp\jsonlayout.cpp,"void JSONLayout::appendSerializedLocationInfo(LogString& buf,
	const LoggingEventPtr& event, Pool& p) const
{
	if (m_priv->prettyPrint)
	{
		buf.append(m_priv->ppIndentL1);
	}

	appendQuotedEscapedString(buf, LOG4CXX_STR(""location_info""));
	buf.append(LOG4CXX_STR("": {""));
	buf.append(m_priv->prettyPrint ? LOG4CXX_EOL : LOG4CXX_STR("" ""));
	const LocationInfo& locInfo = event->getLocationInformation();

	if (m_priv->prettyPrint)
	{
		buf.append(m_priv->ppIndentL2);
	}

	appendQuotedEscapedString(buf, LOG4CXX_STR(""file""));
	buf.append(LOG4CXX_STR("": ""));
	LOG4CXX_DECODE_CHAR(fileName, locInfo.getFileName());
	appendQuotedEscapedString(buf, fileName);
	buf.append(LOG4CXX_STR("",""));
	buf.append(m_priv->prettyPrint ? LOG4CXX_EOL : LOG4CXX_STR("" ""));

	if (m_priv->prettyPrint)
	{
		buf.append(m_priv->ppIndentL2);
	}

	appendQuotedEscapedString(buf, LOG4CXX_STR(""line""));
	buf.append(LOG4CXX_STR("": ""));
	LogString lineNumber;
	StringHelper::toString(locInfo.getLineNumber(), p, lineNumber);
	...",407.0,474.0,1.0,1.0,68.0,49,4,67,11,0,1,7,7,0,1,,0,0,6,3,3,void
162,7562,magic2,2,main\cpp\cacheddateformat.cpp.magic2,,main\cpp\cacheddateformat.cpp,const int magic2,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
163,35213,MDC,1,MDC.MDC,"ANY MDC.MDC (ANY,ANY)",main\cpp\mdc.cpp,"MDC::MDC(const std::string& key1, const std::string& value) : key()
{
	Transcoder::decode(key1, key);
	LOG4CXX_DECODE_CHAR(v, value);
	putLS(key, v);
}",30.0,35.0,1.0,1.0,6.0,1,1,7,5,0,1,1,1,0,1,,0,0,4,2,2,ANY
164,7566,magicString2,2,main\cpp\cacheddateformat.cpp.magicString2,,main\cpp\cacheddateformat.cpp,ANY magicString2,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
165,9618,state,3,LOG4CXX_NS.helpers.LocaleCharsetEncoder.state,,main\cpp\charsetencoder.cpp,state,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
166,64921,AddStartingNewline,3,LOG4CXX_NS.HexdumpFlags.AddStartingNewline,,main\include\log4cxx\hexdump.hpp,AddStartingNewline = (0x01 << 0),-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
167,64922,AddEndingNewline,3,LOG4CXX_NS.HexdumpFlags.AddEndingNewline,,main\include\log4cxx\hexdump.hpp,AddEndingNewline = (0x01 << 1),-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
168,9627,getDefaultEncoder,1,CharsetEncoder.getDefaultEncoder,CharsetEncoderPtr CharsetEncoder.getDefaultEncoder (),main\cpp\charsetencoder.cpp,"CharsetEncoderPtr CharsetEncoder::getDefaultEncoder()
{
	static WideLife<CharsetEncoderPtr> encoder(createDefaultEncoder());

	//
	//  if invoked after static variable destruction
	//     (if logging is called in the destructor of a static object)
	//     then create a new decoder.
	//
	if (encoder.value() == 0)
	{
		return CharsetEncoderPtr( createDefaultEncoder() );
	}

	return encoder;
}",514.0,529.0,1.0,1.0,16.0,2,2,2,1,1,0,2,2,0,0,,0,0,0,0,0,CharsetEncoderPtr
169,8604,decode,1,LOG4CXX_NS.helpers.LocaleCharsetDecoder.decode,"log4cxx_status_t LOG4CXX_NS.helpers.LocaleCharsetDecoder.decode (ByteBuffer,LogString)",main\cpp\charsetdecoder.cpp,"log4cxx_status_t decode(ByteBuffer& in, LogString& out) override
		{
			log4cxx_status_t result = APR_SUCCESS;
			const char* p = in.current();
			size_t i = in.position();
			size_t remain = in.limit() - i;
#if !LOG4CXX_CHARSET_EBCDIC
			if (std::mbsinit(&this->state)) // ByteBuffer not partially decoded?
			{
				// Copy single byte characters
				for (; 0 < remain && ((unsigned int) *p) < 0x80; --remain, ++i, p++)
				{
					out.append(1, *p);
				}
			}
#endif
			// Decode characters that may be represented by multiple bytes
			while (0 < remain)
			{
				wchar_t ch = 0;
				size_t n = std::mbrtowc(&ch, p, remain, &this->state);
				if (0 == n) // NULL encountered?
				{
					++i;
					break;
				}
				if (static_cast<std::size_t>(-1) == n) // decoding error?
				{
					result = APR_BADARG;
					break;
				}
				if (static_cast<std::size_t>(-2) == n) // incomplete sequence?
				{
					break;
				}
				Transcoder::encode(static_cast<unsigned int>(ch), out);
				remain -= n;
				i...",434.0,476.0,3.0,3.0,43.0,40,14,39,12,0,3,10,11,1,1,,0,2,4,2,2,log4cxx_status_t
170,52636,setOption,1,SocketAppenderSkeleton.setOption,"void SocketAppenderSkeleton.setOption (LogString,LogString)",main\cpp\socketappenderskeleton.cpp,"void SocketAppenderSkeleton::setOption(const LogString& option, const LogString& value)
{
	if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""REMOTEHOST""), LOG4CXX_STR(""remotehost"")))
	{
		setRemoteHost(value);
	}
	else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""PORT""), LOG4CXX_STR(""port"")))
	{
		setPort(OptionConverter::toInt(value, getDefaultPort()));
	}
	else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""LOCATIONINFO""), LOG4CXX_STR(""locationinfo"")))
	{
		setLocationInfo(OptionConverter::toBoolean(value, false));
	}
	else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""RECONNECTIONDELAY""), LOG4CXX_STR(""reconnectiondelay"")))
	{
		setReconnectionDelay(OptionConverter::toInt(value, getDefaultDelay()));
	}
	else
	{
		AppenderSkeleton::setOption(option, value);
	}
}",126.0,148.0,1.0,1.0,23.0,1,1,3,3,0,1,2,2,1,1,,0,1,4,2,2,void
171,45478,configureLoggerFactory,1,PropertyConfigurator.configureLoggerFactory,void PropertyConfigurator.configureLoggerFactory (ANY),main\cpp\propertyconfigurator.cpp,"void PropertyConfigurator::configureLoggerFactory(helpers::Properties& props)
{
	static const WideLife<LogString> LOGGER_FACTORY_KEY(LOG4CXX_STR(""log4j.loggerFactory""));

	LogString factoryClassName =
		OptionConverter::findAndSubst(LOGGER_FACTORY_KEY, props);

	if (!factoryClassName.empty())
	{
		LogString msg(LOG4CXX_STR(""Setting logger factory to [""));
		msg += factoryClassName;
		msg += LOG4CXX_STR(""]."");
		LogLog::debug(msg);
		std::shared_ptr<Object> instance = std::shared_ptr<Object>(
				Loader::loadClass(factoryClassName).newInstance() );

		loggerFactory = LOG4CXX_NS::cast<LoggerFactory>( instance );
		static const WideLife<LogString> FACTORY_PREFIX(LOG4CXX_STR(""log4j.factory.""));
		Pool p;
		PropertySetter::setProperties(loggerFactory, props, FACTORY_PREFIX, p);
	}
}",216.0,237.0,1.0,1.0,22.0,21,6,26,16,0,4,2,2,0,4,,0,2,2,1,1,void
172,35239,putLS,1,MDC.putLS,"void MDC.putLS (LogString,LogString)",main\cpp\mdc.cpp,"void MDC::putLS(const LogString& key, const LogString& value)
{
	ThreadSpecificData::put(key, value);
}",43.0,46.0,1.0,1.0,4.0,1,1,3,3,0,1,1,1,0,1,,0,0,4,2,2,void
173,20904,stop,1,FileWatchdog.stop,void FileWatchdog.stop (),main\cpp\filewatchdog.cpp,"void FileWatchdog::stop()
{
	LogLog::debug(LOG4CXX_STR(""Stopping file watchdog""));
	m_priv->interrupted = 0xFFFF;

	{
		std::unique_lock<std::mutex> lock(m_priv->interrupt_mutex);
		m_priv->interrupt.notify_all();
	}
	m_priv->thread.join();
}",73.0,83.0,1.0,1.0,11.0,12,5,7,3,0,1,1,1,0,1,,0,0,0,0,0,void
174,15783,parseLoggerFactory,1,DOMConfigurator.parseLoggerFactory,"void DOMConfigurator.parseLoggerFactory (ANY,ANY,apr_xml_elem*)",main\cpp\domconfigurator.cpp,"void DOMConfigurator::parseLoggerFactory(
	LOG4CXX_NS::helpers::Pool& p,
	LOG4CXX_NS::helpers::CharsetDecoderPtr& utf8Decoder,
	apr_xml_elem* factoryElement)
{
	LogString className(subst(getAttribute(utf8Decoder, factoryElement, CLASS_ATTR)));

	if (className.empty())
	{
		LogLog::error(LOG4CXX_STR(""Logger Factory tag class attribute not found.""));
		LogLog::debug(LOG4CXX_STR(""No Logger Factory configured.""));
	}
	else
	{
		LogLog::debug(LOG4CXX_STR(""Desired logger factory: ["") + className + LOG4CXX_STR(""]""));
		std::shared_ptr<Object> obj = OptionConverter::instantiateByClassName(
				className,
				LoggerFactory::getStaticClass(),
				0);
		m_priv->loggerFactory = LOG4CXX_NS::cast<LoggerFactory>(obj);
		PropertySetter propSetter(m_priv->loggerFactory);

		for (apr_xml_elem* currentElement = factoryElement->first_child;
			currentElement;
			currentElement = currentElement->next)
		{
			std::string tagName(currentElement->name);

			if (tagName == PARAM_TAG)
			{
				setParameter(p...",451.0,485.0,1.0,69.0,35.0,3,1,5,4,0,2,2,2,0,2,,0,0,6,3,3,void
175,62891,execute,1,ZipCompressAction.execute,bool ZipCompressAction.execute (ANY),main\cpp\zipcompressaction.cpp,"bool ZipCompressAction::execute(LOG4CXX_NS::helpers::Pool& p) const
{
	if (!priv->source.exists(p))
	{
		return false;
	}

	apr_pool_t* aprpool = p.getAPRPool();
	apr_procattr_t* attr;
	apr_status_t stat = apr_procattr_create(&attr, aprpool);

	if (stat != APR_SUCCESS)
	{
		throw IOException(stat);
	}

	stat = apr_procattr_io_set(attr, APR_NO_PIPE, APR_NO_PIPE, APR_FULL_BLOCK);

	if (stat != APR_SUCCESS)
	{
		throw IOException(stat);
	}

	stat = apr_procattr_cmdtype_set(attr, APR_PROGRAM_PATH);

	if (stat != APR_SUCCESS)
	{
		throw IOException(stat);
	}

	//
	// redirect the child's error stream to this processes' error stream
	//
	apr_file_t* child_err;
	stat = apr_file_open_stderr(&child_err, aprpool);

	if (stat == APR_SUCCESS)
	{
		stat =  apr_procattr_child_err_set(attr, child_err, NULL);

		if (stat != APR_SUCCESS)
		{
			throw IOException(stat);
		}
	}

	const char** args = (const char**)
		apr_palloc(aprpool, 5 * sizeof(*args));
	int i = 0;

	args[i++] = ""zip"";
	args[i++] = ...",55.0,150.0,1.0,6.0,96.0,81,15,81,17,0,2,11,12,0,2,,0,0,2,1,1,bool
176,10669,graphicsModeToANSISequence,1,graphicsModeToANSISequence,"LogString graphicsModeToANSISequence (LogString,Pool)",main\cpp\colorstartpatternconverter.cpp,"static LogString graphicsModeToANSISequence(const LogString& graphicsMode, Pool& pool){
	int numberToConvert = 0;

	if(StringHelper::equalsIgnoreCase(graphicsMode, LOG4CXX_STR(""BOLD""), LOG4CXX_STR(""bold""))){
		numberToConvert = 1;
	}else if(StringHelper::equalsIgnoreCase(graphicsMode, LOG4CXX_STR(""DIM""), LOG4CXX_STR(""dim""))){
		numberToConvert = 2;
	}else if(StringHelper::equalsIgnoreCase(graphicsMode, LOG4CXX_STR(""ITALIC""), LOG4CXX_STR(""italic""))){
		numberToConvert = 3;
	}else if(StringHelper::equalsIgnoreCase(graphicsMode, LOG4CXX_STR(""UNDERLINE""), LOG4CXX_STR(""underline""))){
		numberToConvert = 4;
	}else if(StringHelper::equalsIgnoreCase(graphicsMode, LOG4CXX_STR(""BLINKING""), LOG4CXX_STR(""blinking""))){
		numberToConvert = 5;
	}else if(StringHelper::equalsIgnoreCase(graphicsMode, LOG4CXX_STR(""INVERSE""), LOG4CXX_STR(""inverse""))){
		numberToConvert = 7;
	}else if(StringHelper::equalsIgnoreCase(graphicsMode, LOG4CXX_STR(""STRIKETHROUGH""), LOG4CXX_STR(""strikethrough""))){
		numberToCon...",66.0,91.0,1.0,1.0,26.0,5,3,10,5,0,2,3,3,1,2,,0,1,4,2,2,LogString
177,9654,getUTF8Encoder,1,CharsetEncoder.getUTF8Encoder,CharsetEncoderPtr CharsetEncoder.getUTF8Encoder (),main\cpp\charsetencoder.cpp,"CharsetEncoderPtr CharsetEncoder::getUTF8Encoder()
{
	return std::make_shared<UTF8CharsetEncoder>();
}",547.0,550.0,1.0,1.0,4.0,1,1,1,1,1,0,1,1,0,0,,0,0,0,0,0,CharsetEncoderPtr
178,3513,setOption,1,AppenderSkeleton.setOption,"void AppenderSkeleton.setOption (LogString,LogString)",main\cpp\appenderskeleton.cpp,"void AppenderSkeleton::setOption(const LogString& option,
	const LogString& value)
{
	if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""THRESHOLD""), LOG4CXX_STR(""threshold"")))
	{
		setThreshold(Level::toLevelLS(value));
	}
}",156.0,164.0,1.0,1.0,9.0,2,1,4,4,0,2,2,2,1,2,,0,1,4,2,2,void
179,55738,SyslogWriter,1,SyslogWriter.SyslogWriter,"ANY SyslogWriter.SyslogWriter (LogString,int)",main\cpp\syslogwriter.cpp,"SyslogWriter::SyslogWriter(const LogString& syslogHost1, int syslogHostPort1)
	: m_priv(std::make_unique<SyslogWriterPrivate>(syslogHost1, syslogHostPort1))
{
	try
	{
		m_priv->address = InetAddress::getByName(syslogHost1);
	}
	catch (UnknownHostException& e)
	{
		LogLog::error(((LogString) LOG4CXX_STR(""Could not find "")) + syslogHost1 +
			LOG4CXX_STR("". All logging will FAIL.""), e);
	}

	try
	{
		m_priv->ds = DatagramSocket::create();
	}
	catch (SocketException& e)
	{
		LogLog::error(((LogString) LOG4CXX_STR(""Could not instantiate DatagramSocket to "")) + syslogHost1 +
			LOG4CXX_STR("". All logging will FAIL.""), e);
	}
}",39.0,61.0,1.0,1.0,23.0,14,5,11,6,0,4,3,3,0,4,,0,2,4,2,2,ANY
180,53691,toLowerCase,1,StringHelper.toLowerCase,LogString StringHelper.toLowerCase (LogString),main\cpp\stringhelper.cpp,"LogString StringHelper::toLowerCase(const LogString& s)
{
	LogString d;
	std::transform(s.begin(), s.end(),
		std::insert_iterator<LogString>(d, d.begin()), tolower);
	return d;
}",67.0,73.0,1.0,1.0,7.0,9,5,9,5,4,0,1,1,0,0,,0,0,2,1,1,LogString
181,7610,findMillisecondStart,1,CachedDateFormat.findMillisecondStart,"int CachedDateFormat.findMillisecondStart (log4cxx_time_t,LogString,DateFormatPtr,Pool)",main\cpp\cacheddateformat.cpp,"int CachedDateFormat::findMillisecondStart(
	log4cxx_time_t time, const LogString& formatted,
	const DateFormatPtr& formatter,
	Pool& pool)
{

	log4cxx_time_t slotBegin = (time / 1000000) * 1000000;

	if (slotBegin > time)
	{
		slotBegin -= 1000000;
	}

	int millis = (int) (time - slotBegin) / 1000;

	// the magic numbers are in microseconds
	int magic = magic1;
	LogString magicString(magicString1);

	if (millis == magic1 / 1000)
	{
		magic = magic2;
		magicString = magicString2;
	}

	LogString plusMagic;
	formatter->format(plusMagic, slotBegin + magic, pool);

	/**
	 *   If the string lengths differ then
	 *      we can't use the cache except for duplicate requests.
	 */
	if (plusMagic.length() != formatted.length())
	{
		return UNRECOGNIZED_MILLISECONDS;
	}
	else
	{
		// find first difference between values
		for (LogString::size_type i = 0; i < formatted.length(); i++)
		{
			if (formatted[i] != plusMagic[i])
			{
				//
				//   determine the expected digits for the base time
		...",152.0,234.0,1.0,1.0,83.0,19,12,26,15,0,5,4,4,1,0,,0,5,8,4,4,int
182,17851,formatMessage,1,InterruptedException.formatMessage,LogString InterruptedException.formatMessage (log4cxx_status_t),main\cpp\exception.cpp,"LogString InterruptedException::formatMessage(log4cxx_status_t stat)
{
	LogString s(LOG4CXX_STR(""InterruptedException: stat = ""));
	Pool p;
	StringHelper::toString(stat, p, s);
	return s;
}",278.0,284.0,1.0,1.0,7.0,1,1,5,4,0,1,1,1,0,1,,0,0,2,1,1,LogString
183,22975,getDefault,1,FormattingInfo.getDefault,FormattingInfoPtr FormattingInfo.getDefault (),main\cpp\formattinginfo.cpp,"FormattingInfoPtr FormattingInfo::getDefault()
{
	static helpers::WideLife<FormattingInfoPtr> def= std::make_shared<FormattingInfo>(false, 0, INT_MAX);
	return def;
}",68.0,72.0,1.0,1.0,5.0,6,6,5,4,3,0,1,1,0,0,,0,0,0,0,0,FormattingInfoPtr
184,9663,getEncoder,1,CharsetEncoder.getEncoder,CharsetEncoderPtr CharsetEncoder.getEncoder (LogString),main\cpp\charsetencoder.cpp,"CharsetEncoderPtr CharsetEncoder::getEncoder(const LogString& charset)
{
	if (StringHelper::equalsIgnoreCase(charset, LOG4CXX_STR(""UTF-8""), LOG4CXX_STR(""utf-8""))
		|| StringHelper::equalsIgnoreCase(charset, LOG4CXX_STR(""CP65001""), LOG4CXX_STR(""cp65001"")))
	{
		return std::make_shared<UTF8CharsetEncoder>();
	}
	else if (StringHelper::equalsIgnoreCase(charset, LOG4CXX_STR(""C""), LOG4CXX_STR(""c"")) ||
		charset == LOG4CXX_STR(""646"") ||
		StringHelper::equalsIgnoreCase(charset, LOG4CXX_STR(""US-ASCII""), LOG4CXX_STR(""us-ascii"")) ||
		StringHelper::equalsIgnoreCase(charset, LOG4CXX_STR(""ISO646-US""), LOG4CXX_STR(""iso646-US"")) ||
		StringHelper::equalsIgnoreCase(charset, LOG4CXX_STR(""ANSI_X3.4-1968""), LOG4CXX_STR(""ansi_x3.4-1968"")) ||
		StringHelper::equalsIgnoreCase(charset, LOG4CXX_STR(""CP20127""), LOG4CXX_STR(""cp20127"")))
	{
		return std::make_shared<USASCIICharsetEncoder>();
	}
	else if (StringHelper::equalsIgnoreCase(charset, LOG4CXX_STR(""ISO-8859-1""), LOG4CXX_STR(""iso-8859-1"")) ||
		Strin...",554.0,596.0,1.0,1.0,43.0,5,3,6,3,1,2,2,2,2,2,,0,2,2,1,1,CharsetEncoderPtr
185,35266,get,1,MDC.get,"bool MDC.get (LogString,LogString)",main\cpp\mdc.cpp,"std::string MDC::get(const std::string& key)
{
	LOG4CXX_DECODE_CHAR(lkey, key);
	LogString lvalue;

	if (get(lkey, lvalue))
	{
		LOG4CXX_ENCODE_CHAR(value, lvalue);
		return value;
	}

	return std::string();
}",77.0,89.0,1.0,1.0,13.0,12,4,13,6,1,1,3,4,0,0,,0,1,2,1,1,string
186,26052,appendHeader,1,HTMLLayout.appendHeader,"void HTMLLayout.appendHeader (LogString,Pool)",main\cpp\htmllayout.cpp,"void HTMLLayout::appendHeader(LogString& output, Pool& p)
{
	output.append(LOG4CXX_STR(""<!DOCTYPE HTML PUBLIC ""));
	output.append(LOG4CXX_STR(""\""-//W3C//DTD HTML 4.01 Transitional//EN\"" ""));
	output.append(LOG4CXX_STR(""\""http://www.w3.org/TR/html4/loose.dtd\"">""));
	output.append(LOG4CXX_EOL);
	output.append(LOG4CXX_STR(""<html>""));
	output.append(LOG4CXX_EOL);
	output.append(LOG4CXX_STR(""<head>""));
	output.append(LOG4CXX_EOL);
	output.append(LOG4CXX_STR(""<title>""));
	output.append(m_priv->title);
	output.append(LOG4CXX_STR(""</title>""));
	output.append(LOG4CXX_EOL);
	output.append(LOG4CXX_STR(""<style type=\""text/css\"">""));
	output.append(LOG4CXX_EOL);
	output.append(LOG4CXX_STR(""<!--""));
	output.append(LOG4CXX_EOL);
	output.append(LOG4CXX_STR(""body, table {font-family: arial,sans-serif; font-size: x-small;}""));
	output.append(LOG4CXX_EOL);
	output.append(LOG4CXX_STR(""th {background: #336699; color: #FFFFFF; text-align: left;}""));
	output.append(LOG4CXX_EOL);
	output.append(LOG4CXX_STR...",175.0,238.0,1.0,1.0,64.0,58,2,83,5,0,1,2,2,0,0,,0,0,4,2,2,void
187,38344,fragments,3,LOG4CXX_NS.pattern.PatternAbbreviator.fragments,,main\cpp\nameabbreviator.cpp,fragments,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
188,54730,getFacility,1,SyslogAppender.getFacility,int SyslogAppender.getFacility (LogString),main\cpp\syslogappender.cpp,"LogString SyslogAppender::getFacility() const
{
	return getFacilityString(_priv->syslogFacility);
}",466.0,469.0,1.0,26.0,4.0,1,1,3,3,0,1,2,2,1,1,,0,1,0,0,0,LogString
189,11723,setOption,1,ConsoleAppender.setOption,"void ConsoleAppender.setOption (LogString,LogString)",main\cpp\consoleappender.cpp,"void ConsoleAppender::setOption(const LogString& option, const LogString& value)
{
	if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""TARGET""), LOG4CXX_STR(""target"")))
	{
		setTarget(value);
	}
	else
	{
		WriterAppender::setOption(option, value);
	}
}",133.0,144.0,1.0,1.0,12.0,1,1,3,3,0,1,2,2,1,1,,0,1,4,2,2,void
190,38348,abbreviate,1,LOG4CXX_NS.pattern.PatternAbbreviator.abbreviate,"void LOG4CXX_NS.pattern.PatternAbbreviator.abbreviate (ANY,LogString)",main\cpp\nameabbreviator.cpp,"void abbreviate(LogString::size_type nameStart, LogString& buf) const override
		{
			//
			//  all non-terminal patterns are executed once
			//
			LogString::size_type pos = nameStart;

			for (LogString::size_type i = 0; (i < (fragments.size() - 1)) && (pos < buf.length());
				i++)
			{
				pos = fragments[i].abbreviate(buf, pos);
			}

			//
			//   last pattern in executed repeatedly
			//
			PatternAbbreviatorFragment terminalFragment =
				fragments[fragments.size() - 1];

			while (pos < buf.length())
			{
				pos = terminalFragment.abbreviate(buf, pos);
			}
		}",233.0,256.0,3.0,3.0,24.0,19,6,21,6,0,4,3,3,1,0,,0,4,4,2,2,void
191,49613,renderFacet,1,LOG4CXX_NS.helpers.SimpleDateFormatImpl.PatternToken.renderFacet,"void LOG4CXX_NS.helpers.SimpleDateFormatImpl.PatternToken.renderFacet (ANY*,incrementFunction,char,unsigned int,char*,ANY)",main\cpp\simpledateformat.cpp,"static void renderFacet(const std::locale* locale,
			incrementFunction inc,
			char spec,
			unsigned int wspec,
			const char* aprspec,
			std::vector<LogString>& values)
		{
			std::vector<LogString>::iterator valueIter = values.begin();
			tm time;
			memset(&time, 0, sizeof(time));
			apr_time_exp_t aprtime;
			memset(&aprtime, 0, sizeof(aprtime));
#if LOG4CXX_HAS_STD_LOCALE

			if (locale != NULL)
			{
#if LOG4CXX_WCHAR_T_API

				if (HAS_FACET(*locale, std::time_put<wchar_t>))
				{
					const std::time_put<wchar_t>& facet = USE_FACET(*locale, std::time_put<wchar_t>);
					size_t start = 0;
					std::basic_ostringstream<wchar_t> os;

					for (; valueIter != values.end(); valueIter++)
					{
						PUT_FACET(facet, os, &time, (char)wspec);
						Transcoder::decode(os.str().substr(start), *valueIter);
						start = os.str().length();
						(*inc)(time, aprtime);
					}
				}
				else
#endif
					if (HAS_FACET(*locale,  std::time_put<char>))
					{
						const std::time_put<char...",117.0,187.0,3.0,3.0,71.0,18,7,28,13,5,1,3,4,0,1,,0,0,12,6,6,void
192,14802,doOnChange,1,LOG4CXX_NS.xml.XMLWatchdog.doOnChange,void LOG4CXX_NS.xml.XMLWatchdog.doOnChange (),main\cpp\domconfigurator.cpp,"void doOnChange()
		{
			DOMConfigurator().doConfigure(file(),
				LogManager::getLoggerRepository());
		}",83.0,87.0,3.0,3.0,5.0,2,1,1,1,0,1,1,1,0,0,,0,0,0,0,0,void
193,60883,appendEscapingCDATA,1,Transform.appendEscapingCDATA,"void Transform.appendEscapingCDATA (LogString,LogString)",main\cpp\transform.cpp,"void Transform::appendEscapingCDATA(
	LogString& buf, const LogString& input)
{
	static const WideLife<LogString> CDATA_END(LOG4CXX_STR(""]]>""));
	static const WideLife<LogString> CDATA_EMBEDED_END(LOG4CXX_STR(""]]>]]&gt;<![CDATA[""));

	const LogString::size_type CDATA_END_LEN = 3;


	if (input.length() == 0 )
	{
		return;
	}

	LogString::size_type end = input.find(CDATA_END);

	if (end == LogString::npos)
	{
		buf.append(input);
		return;
	}

	LogString::size_type start = 0;

	while (end != LogString::npos)
	{
		buf.append(input, start, end - start);
		buf.append(CDATA_EMBEDED_END);
		start = end + CDATA_END_LEN;

		if (start < input.length())
		{
			end = input.find(CDATA_END, start);
		}
		else
		{
			return;
		}
	}

	buf.append(input, start, input.length() - start);
}",90.0,131.0,1.0,1.0,42.0,23,7,33,8,2,0,5,6,0,0,,0,0,4,2,2,void
194,20952,checkAndConfigure,1,FileWatchdog.checkAndConfigure,void FileWatchdog.checkAndConfigure (),main\cpp\filewatchdog.cpp,"void FileWatchdog::checkAndConfigure()
{
	LogString msg(LOG4CXX_STR(""Checking [""));
	msg += m_priv->file.getPath();
	msg += LOG4CXX_STR(""]"");
	LogLog::debug(msg);
	Pool pool1;

	if (!m_priv->file.exists(pool1))
	{
		if (!m_priv->warnedAlready)
		{
			LogLog::debug(((LogString) LOG4CXX_STR(""[""))
				+ m_priv->file.getPath()
				+ LOG4CXX_STR(""] does not exist.""));
			m_priv->warnedAlready = true;
		}
	}
	else
	{
		auto thisMod = m_priv->file.lastModified(pool1);

		if (thisMod > m_priv->lastModif)
		{
			m_priv->lastModif = thisMod;
			doOnChange();
			m_priv->warnedAlready = false;
		}
	}
}",90.0,119.0,1.0,1.0,30.0,18,7,11,4,0,2,3,4,0,2,,0,0,0,0,0,void
195,59869,decode,1,Transcoder.decode,"unsigned int Transcoder.decode (ANY,ANY)",main\cpp\transcoder.cpp,"LogString Transcoder::decode(const char* val)
{
#if LOG4CXX_LOGCHAR_IS_UTF8 && !LOG4CXX_CHARSET_EBCDIC
	return val;
#else
	LogString dst;
	Transcoder::decode(val, dst);
	return dst;
#endif
}",670.0,679.0,1.0,1.0,10.0,67,13,54,8,17,0,14,37,0,0,,0,0,2,1,1,LogString
196,53725,trim,1,StringHelper.trim,LogString StringHelper.trim (LogString),main\cpp\stringhelper.cpp,"LogString StringHelper::trim(const LogString& s)
{
	LogString::size_type pos = s.find_first_not_of(' ');

	if (pos == std::string::npos)
	{
		return LogString();
	}

	LogString::size_type n = s.find_last_not_of(' ') - pos + 1;
	return s.substr(pos, n);
}",75.0,86.0,1.0,1.0,12.0,10,5,11,5,6,0,2,2,0,0,,0,0,2,1,1,LogString
197,48612,subAppend,1,RollingFileAppender.subAppend,"void RollingFileAppender.subAppend (LoggingEventPtr,Pool)",main\cpp\rollingfileappender.cpp,"void RollingFileAppender::subAppend(const LoggingEventPtr& event, Pool& p)
{
	// The rollover check must precede actual writing. This is the
	// only correct behavior for time driven triggers.
	if (
		_priv->triggeringPolicy->isTriggeringEvent(
			this, event, getFile(), getFileLength()))
	{
		//
		//   wrap rollover request in try block since
		//    rollover may fail in case read access to directory
		//    is not provided.  However appender should still be in good
		//     condition and the append should still happen.
		try
		{
			_priv->_event = event;
			rolloverInternal(p);
		}
		catch (std::exception& ex)
		{
			LOG4CXX_DECODE_CHAR(lsMsg, ex.what());
			LogString errorMsg = LOG4CXX_STR(""Exception during rollover attempt: "");
			errorMsg.append(lsMsg);
			LogLog::warn(errorMsg);
			_priv->errorHandler->error(lsMsg);
		}
	}

	FileAppender::subAppend(event, p);
}",453.0,482.0,1.0,2.0,30.0,17,4,17,8,0,1,3,4,0,1,,0,0,4,2,2,void
198,17898,formatMessage,1,ThreadException.formatMessage,LogString ThreadException.formatMessage (log4cxx_status_t),main\cpp\exception.cpp,"LogString ThreadException::formatMessage(log4cxx_status_t stat)
{
	LogString s(LOG4CXX_STR(""Thread exception: stat = ""));
	Pool p;
	StringHelper::toString(stat, p, s);
	return s;
}",307.0,313.0,1.0,1.0,7.0,1,1,5,4,0,1,1,1,0,1,,0,0,2,1,1,LogString
199,40428,m_config,3,LOG4CXX_NS.ConfiguratorWatchdog.m_config,,main\cpp\optionconverter.cpp,m_config,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
200,58860,explode,1,LOG4CXX_NS.helpers.TimeZoneImpl.FixedTimeZone.explode,"log4cxx_status_t LOG4CXX_NS.helpers.TimeZoneImpl.FixedTimeZone.explode (apr_time_exp_t*,log4cxx_time_t)",main\cpp\timezone.cpp,"log4cxx_status_t explode( apr_time_exp_t* result, log4cxx_time_t input ) const
		{
			apr_status_t stat;

			//  APR 1.1 and early mishandles microseconds on dates
			//   before 1970, APR bug 32520
			if (LOG4CXX_UNLIKELY(input < 0 && apr_time_usec(input) < 0))
			{
				apr_time_t floorTime = (apr_time_sec(input) - 1) * APR_USEC_PER_SEC;
				stat = apr_time_exp_tz(result, floorTime, offset);
				result->tm_usec = (int) (input - floorTime);
			}
			else
			{
				stat = apr_time_exp_tz( result, input, offset );
			}

			return stat;
		}",152.0,170.0,3.0,3.0,19.0,11,7,13,6,0,1,2,2,0,0,,0,1,4,2,2,log4cxx_status_t
201,18930,list,1,File.list,vector<LogString> File.list (Pool),main\cpp\file.cpp,"std::vector<LogString> File::list(Pool& p) const
{
	apr_dir_t* dir;
	apr_finfo_t entry;
	std::vector<LogString> filenames;

	apr_status_t stat = apr_dir_open(&dir,
			convertBackSlashes(getPath(p)),
			p.getAPRPool());

	if (stat == APR_SUCCESS)
	{
		int style = APR_FILEPATH_ENCODING_UNKNOWN;
		apr_filepath_encoding(&style, p.getAPRPool());
		stat = apr_dir_read(&entry, APR_FINFO_DIRENT, dir);

		while (stat == APR_SUCCESS)
		{
			if (entry.name != NULL)
			{
				LogString filename;

				if (style == APR_FILEPATH_ENCODING_UTF8)
				{
					Transcoder::decodeUTF8(entry.name, filename);
				}
				else
				{
					Transcoder::decode(entry.name, filename);
				}

				filenames.push_back(filename);
			}

			stat = apr_dir_read(&entry, APR_FINFO_DIRENT, dir);
		}

		stat = apr_dir_close(dir);
	}

	return filenames;
}",262.0,303.0,1.0,1.0,42.0,22,7,35,15,0,1,5,11,0,1,,0,0,2,1,1,vector<LogString>
202,52723,fireConnector,1,SocketAppenderSkeleton.fireConnector,void SocketAppenderSkeleton.fireConnector (),main\cpp\socketappenderskeleton.cpp,"void SocketAppenderSkeleton::fireConnector()
{
	std::lock_guard<std::recursive_mutex> lock(_priv->mutex);

	if ( !_priv->thread.joinable() )
	{
		LogLog::debug(LOG4CXX_STR(""Connector thread not alive: starting monitor.""));

		_priv->thread = ThreadUtility::instance()->createThread( LOG4CXX_STR(""SocketAppend""), &SocketAppenderSkeleton::monitor, this );
	}
}",150.0,160.0,1.0,44.0,11.0,21,8,8,5,0,1,2,2,0,1,,0,0,0,0,0,void
203,40435,doOnChange,1,LOG4CXX_NS.ConfiguratorWatchdog.doOnChange,void LOG4CXX_NS.ConfiguratorWatchdog.doOnChange (),main\cpp\optionconverter.cpp,"void doOnChange() override
    {
        m_config->doConfigure(file(), LogManager::getLoggerRepository());
    }",64.0,67.0,5.0,5.0,4.0,2,2,2,2,0,2,1,1,0,0,,0,1,0,0,0,void
204,45563,configureRootLogger,1,PropertyConfigurator.configureRootLogger,"void PropertyConfigurator.configureRootLogger (ANY,ANY)",main\cpp\propertyconfigurator.cpp,"void PropertyConfigurator::configureRootLogger(helpers::Properties& props,
	spi::LoggerRepositoryPtr& hierarchy)
{
	static const WideLife<LogString> ROOT_CATEGORY_PREFIX(LOG4CXX_STR(""log4j.rootCategory""));
	static const WideLife<LogString> ROOT_LOGGER_PREFIX(LOG4CXX_STR(""log4j.rootLogger""));



	LogString effectiveFrefix(ROOT_LOGGER_PREFIX);
	LogString value = OptionConverter::findAndSubst(ROOT_LOGGER_PREFIX, props);

	if (value.empty())
	{
		value = OptionConverter::findAndSubst(ROOT_CATEGORY_PREFIX, props);
		effectiveFrefix = ROOT_CATEGORY_PREFIX;
	}

	if (value.empty())
	{
		LogLog::debug(LOG4CXX_STR(""Could not find root logger information. Is this OK?""));
	}
	else
	{
		LoggerPtr root = hierarchy->getRootLogger();

		static const WideLife<LogString> INTERNAL_ROOT_NAME(LOG4CXX_STR(""root""));
		parseLogger(props, root, effectiveFrefix, INTERNAL_ROOT_NAME, value, true);
	}
}",239.0,267.0,1.0,1.0,29.0,8,2,14,7,0,3,3,3,0,3,,0,2,4,2,2,void
205,47613,setMaxFileSize,1,RollingFileAppender.setMaxFileSize,void RollingFileAppender.setMaxFileSize (LogString),main\cpp\rollingfileappender.cpp,"void RollingFileAppender::setMaxFileSize(const LogString& value)
{
	setMaximumFileSize(OptionConverter::toFileSize(value, long(getMaximumFileSize() + 1)));
}",143.0,146.0,1.0,1.0,4.0,3,3,2,2,0,1,1,1,0,1,,0,0,2,1,1,void
206,40448,convertSpecialChars,1,OptionConverter.convertSpecialChars,LogString OptionConverter.convertSpecialChars (LogString),main\cpp\optionconverter.cpp,"LogString OptionConverter::convertSpecialChars(const LogString& s)
{
	logchar c;
	LogString sbuf;

	LogString::const_iterator i = s.begin();

	while (i != s.end())
	{
		c = *i++;

		if (c == 0x5C /* '\\' */)
		{
			c =  *i++;

			switch (c)
			{
				case 0x6E: //'n'
					c = 0x0A;
					break;

				case 0x72: //'r'
					c = 0x0D;
					break;

				case 0x74: //'t'
					c = 0x09;
					break;

				case 0x66: //'f'
					c = 0x0C;
					break;

				default:
					break;
			}
		}

		sbuf.append(1, c);
	}

	return sbuf;
}",77.0,119.0,1.0,1.0,43.0,16,6,17,4,1,0,9,7,0,0,,0,0,2,1,1,LogString
207,61953,setOption,1,XMLLayout.setOption,"void XMLLayout.setOption (LogString,LogString)",main\cpp\xmllayout.cpp,"void XMLLayout::setOption(const LogString& option,
	const LogString& value)
{
	if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""LOCATIONINFO""), LOG4CXX_STR(""locationinfo"")))
	{
		setLocationInfo(OptionConverter::toBoolean(value, false));
		m_priv->expectedPatternLength = getFormattedEventCharacterCount() * 2;
	}

	if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""PROPERTIES""), LOG4CXX_STR(""properties"")))
	{
		setProperties(OptionConverter::toBoolean(value, false));
		m_priv->expectedPatternLength = getFormattedEventCharacterCount() * 2;
	}
}",61.0,75.0,1.0,1.0,15.0,10,4,10,5,0,4,3,3,2,4,,0,2,4,2,2,void
208,11778,CyclicBuffer,1,CyclicBuffer.CyclicBuffer,ANY CyclicBuffer.CyclicBuffer (int),main\cpp\cyclicbuffer.cpp,"CyclicBuffer::CyclicBuffer(int maxSize1)
	: m_priv(std::make_unique<CyclicBufferPriv>(maxSize1))
{
	if (maxSize1 < 1)
	{
		LogString msg(LOG4CXX_STR(""The maxSize argument (""));
		Pool p;
		StringHelper::toString(maxSize1, p, msg);
		msg.append(LOG4CXX_STR("") is not a positive integer.""));
		throw IllegalArgumentException(msg);
	}
}",45.0,56.0,1.0,1.0,12.0,4,3,7,4,0,1,2,2,0,1,,0,0,2,1,1,ANY
209,27142,setOption,1,JSONLayout.setOption,"void JSONLayout.setOption (LogString,LogString)",main\cpp\jsonlayout.cpp,"void JSONLayout::setOption(const LogString& option, const LogString& value)
{
	if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""LOCATIONINFO""), LOG4CXX_STR(""locationinfo"")))
	{
		setLocationInfo(OptionConverter::toBoolean(value, false));
	}
	else if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""THREADINFO""), LOG4CXX_STR(""threadinfo"")))
	{
		setThreadInfo(OptionConverter::toBoolean(value, false));
	}
	else if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""PRETTYPRINT""), LOG4CXX_STR(""prettyprint"")))
	{
		setPrettyPrint(OptionConverter::toBoolean(value, false));
	}
}",109.0,126.0,1.0,1.0,18.0,2,1,4,4,0,2,2,2,1,2,,0,1,4,2,2,void
210,53768,startsWith,1,StringHelper.startsWith,"bool StringHelper.startsWith (LogString,LogString)",main\cpp\stringhelper.cpp,"bool StringHelper::startsWith(const LogString& s, const LogString& prefix)
{
	if (s.length() < prefix.length())
	{
		return false;
	}

	return s.compare(0, prefix.length(), prefix) == 0;
}",88.0,96.0,1.0,1.0,9.0,6,3,5,2,3,0,2,2,0,0,,0,0,4,2,2,bool
211,35346,remove,1,MDC.remove,"bool MDC.remove (LogString,LogString)",main\cpp\mdc.cpp,"std::string MDC::remove(const std::string& key)
{
	LOG4CXX_DECODE_CHAR(lkey, key);
	LogString lvalue;

	if (remove(lkey, lvalue))
	{
		LOG4CXX_ENCODE_CHAR(value, lvalue);
		return value;
	}

	return std::string();
}",112.0,124.0,1.0,1.0,13.0,13,4,14,6,0,1,3,4,0,0,,0,1,2,1,1,string
212,534,rootLogger,2,examples\cpp\auto-configured.cpp.rootLogger,,examples\cpp\auto-configured.cpp,auto rootLogger,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
213,38425,getAbbreviator,1,NameAbbreviator.getAbbreviator,NameAbbreviatorPtr NameAbbreviator.getAbbreviator (LogString),main\cpp\nameabbreviator.cpp,"NameAbbreviatorPtr NameAbbreviator::getAbbreviator(const LogString& pattern)
{
	if (pattern.length() > 0)
	{
		//  if pattern is just spaces and numbers then
		//     use MaxElementAbbreviator
		LogString trimmed(StringHelper::trim(pattern));

		if (trimmed.length() == 0)
		{
			return getDefaultAbbreviator();
		}

		LogString::size_type i = 0;

		while (
			(i < trimmed.length()) && (trimmed[i] >= 0x30 /* '0' */)
			&& (trimmed[i] <= 0x39 /* '9' */))
		{
			i++;
		}

		//
		//  if all blanks and digits
		//
		if (i == trimmed.length())
		{
			return std::make_shared<MaxElementAbbreviator>(StringHelper::toInt(trimmed));
		}

		std::vector<PatternAbbreviatorFragment> fragments;
		logchar ellipsis;
		int charCount;
		LogString::size_type pos = 0;

		while (pos < trimmed.length())
		{
			LogString::size_type ellipsisPos = pos;

			if (trimmed[pos] == 0x2A /* '*' */)
			{
				charCount = INT_MAX;
				ellipsisPos++;
			}
			else
			{
				if ((trimmed[pos] >= 0x30 /* '0' */)
					&& (trim...",267.0,355.0,1.0,1.0,89.0,48,10,51,15,1,2,11,23,0,2,,0,0,2,1,1,NameAbbreviatorPtr
214,6684,~AtExitRegistryImpl,1,anonymous_namespace_2.AtExitRegistryImpl.~AtExitRegistryImpl,ANY anonymous_namespace_2.AtExitRegistryImpl.~AtExitRegistryImpl (),main\cpp\atexitregistry.cpp,"~AtExitRegistryImpl()
		{
			std::lock_guard<std::recursive_mutex> lock(mutex);
			while(!actions.empty())
			{
				std::function<void()> action = std::move(actions.begin()->second);
				actions.erase(actions.begin());
				action();
			}
		}",28.0,37.0,3.0,3.0,10.0,16,7,10,4,0,5,2,2,1,0,,0,5,0,0,0,ANY
215,16925,configure,1,DOMConfigurator.configure,ConfigurationStatus DOMConfigurator.configure (ANY),main\cpp\domconfigurator.cpp,"spi::ConfigurationStatus DOMConfigurator::configure(const std::string& filename)
{
	File file(filename);
	return DOMConfigurator().doConfigure(file, LogManager::getLoggerRepository());
}",852.0,856.0,1.0,1.0,5.0,2,1,3,3,0,1,1,1,0,0,,0,0,2,1,1,ConfigurationStatus
216,544,ExampleStaticData,1,ExampleStaticData.ExampleStaticData,ANY ExampleStaticData.ExampleStaticData (),examples\cpp\auto-configured.cpp,"ExampleStaticData()	{
		LOG4CXX_DEBUG(rootLogger, ""static initializer message"");
	}",22.0,24.0,2.0,2.0,3.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
217,58912,offset,3,LOG4CXX_NS.helpers.TimeZoneImpl.FixedTimeZone.offset,,main\cpp\timezone.cpp,offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
218,53800,endsWith,1,StringHelper.endsWith,"bool StringHelper.endsWith (LogString,LogString)",main\cpp\stringhelper.cpp,"bool StringHelper::endsWith(const LogString& s, const LogString& suffix)
{
	if (suffix.length() <= s.length())
	{
		return s.compare(s.length() - suffix.length(), suffix.length(), suffix) == 0;
	}

	return false;
}",98.0,106.0,1.0,1.0,9.0,9,4,7,2,2,0,2,2,0,0,,0,0,4,2,2,bool
219,58922,getDefault,1,TimeZone.getDefault,TimeZonePtr TimeZone.getDefault (),main\cpp\timezone.cpp,"const TimeZonePtr& TimeZone::getDefault()
{
	return LOG4CXX_NS::helpers::TimeZoneImpl::LocalTimeZone::getInstance();
}",191.0,194.0,1.0,1.0,4.0,4,1,4,4,0,1,1,1,0,0,,0,0,0,0,0,TimeZonePtr
220,1579,logger,3,DelayedLoop.logger,,examples\cpp\delayedloop.cpp,logger,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
221,1580,main,1,DelayedLoop.main,"void DelayedLoop.main (int,char[]*)",examples\cpp\delayedloop.cpp,"static void main(int argc, const char * const argv[])
        {
                if(argc == 2)
                {
                        init(argv[1]);
                }
                else
                {
                        usage(argv[0], ""Wrong number of arguments."");
                }

                test();
        }",43.0,55.0,9.0,9.0,13.0,2,2,2,2,0,1,2,2,0,0,,0,0,4,2,2,void
222,33326,~LogLogPrivate,1,LogLogPrivate.~LogLogPrivate,ANY LogLogPrivate.~LogLogPrivate (),main\cpp\loglog.cpp,"~LogLogPrivate()
	{
		quietMode = true; // Prevent output after deletion by onexit processing chain.
	}",39.0,42.0,2.0,2.0,4.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
223,8751,state,3,LOG4CXX_NS.helpers.LocaleCharsetDecoder.state,,main\cpp\charsetdecoder.cpp,state,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
224,12848,newInstance,1,DatePatternConverter.newInstance,PatternConverterPtr DatePatternConverter.newInstance (ANY),main\cpp\datepatternconverter.cpp,"PatternConverterPtr DatePatternConverter::newInstance(
	const std::vector<LogString>& options)
{
	return std::make_shared<DatePatternConverter>(options);
}",133.0,137.0,1.0,1.0,5.0,3,3,3,3,2,0,1,1,0,0,,0,0,2,1,1,PatternConverterPtr
225,44591,get,1,PropertyParser.get,"bool PropertyParser.get (LogString,logchar)",main\cpp\properties.cpp,"static bool get(LogString& in, logchar& c)
		{
			if (in.empty())
			{
				c = 0;
				return false;
			}

			c = in[0];
			in.erase(in.begin());
			return true;
		}",368.0,379.0,3.0,3.0,12.0,6,3,6,2,18,0,2,2,0,0,,0,0,4,2,2,bool
226,36401,activateOptions,1,MultiprocessRollingFileAppender.activateOptions,void MultiprocessRollingFileAppender.activateOptions (Pool),main\cpp\multiprocessrollingfileappender.cpp,"void MultiprocessRollingFileAppender::activateOptions(Pool& p)
{
	if (_priv->rollingPolicy == NULL)
	{
		auto fwrp = std::make_shared<FixedWindowRollingPolicy>();
		fwrp->setFileNamePattern(getFile() + LOG4CXX_STR("".%i""));
		_priv->rollingPolicy = fwrp;
	}

	//
	//  if no explicit triggering policy and rolling policy is both.
	//
	if (_priv->triggeringPolicy == NULL)
	{
		TriggeringPolicyPtr trig = LOG4CXX_NS::cast<TriggeringPolicy>(_priv->rollingPolicy);

		if (trig != NULL)
		{
			_priv->triggeringPolicy = trig;
		}
	}

	if (_priv->triggeringPolicy == NULL)
	{
		_priv->triggeringPolicy = std::make_shared<ManualTriggeringPolicy>();
	}

	{
		std::lock_guard<std::recursive_mutex> lock(_priv->mutex);
		_priv->triggeringPolicy->activateOptions(p);
		_priv->rollingPolicy->activateOptions(p);

		try
		{
			RolloverDescriptionPtr rollover1 =
				_priv->rollingPolicy->initialize(getFile(), getAppend(), p);

			if (rollover1 != NULL)
			{
				ActionPtr syncAction(rollover1->getSynchronous()...",88.0,169.0,1.0,5.0,82.0,83,9,54,14,0,2,10,17,0,2,,0,0,2,1,1,void
227,15922,parseChildrenOfLoggerElement,1,DOMConfigurator.parseChildrenOfLoggerElement,"void DOMConfigurator.parseChildrenOfLoggerElement (ANY,ANY,apr_xml_elem*,LoggerPtr,bool,apr_xml_doc*,AppenderMap)",main\cpp\domconfigurator.cpp,"void DOMConfigurator::parseChildrenOfLoggerElement(
	LOG4CXX_NS::helpers::Pool& p,
	LOG4CXX_NS::helpers::CharsetDecoderPtr& utf8Decoder,
	apr_xml_elem* loggerElement, LoggerPtr logger, bool isRoot,
	apr_xml_doc* doc,
	AppenderMap& appenders)
{
	PropertySetter propSetter(logger);
	std::vector<AppenderPtr> newappenders;

	// Remove all existing appenders from logger. They will be
	// reconstructed if need be.
	logger->removeAllAppenders();

	for (apr_xml_elem* currentElement = loggerElement->first_child;
		currentElement;
		currentElement = currentElement->next)
	{
		std::string tagName(currentElement->name);

		if (tagName == APPENDER_REF_TAG)
		{
			AppenderPtr appender = findAppenderByReference(p, utf8Decoder, currentElement, doc, appenders);
			LogString refName =  subst(getAttribute(utf8Decoder, currentElement, REF_ATTR));

			if (appender != 0)
			{
				LogLog::debug(LOG4CXX_STR(""Adding appender named ["") + refName +
					LOG4CXX_STR(""] to logger ["") + logger->getName() + LOG4CX...",504.0,558.0,1.0,17.0,55.0,19,8,27,15,0,1,4,7,0,1,,0,0,14,7,7,void
228,65076,m_otherCategory,3,LOG4CXX_NS.LevelChange.m_otherCategory,,main\include\log4cxx\levelchange.hpp,m_otherCategory,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
229,65077,m_savedLevel,3,LOG4CXX_NS.LevelChange.m_savedLevel,,main\include\log4cxx\levelchange.hpp,m_savedLevel,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
230,33334,quietMode,3,LogLogPrivate.quietMode,,main\cpp\loglog.cpp,quietMode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
231,10807,convertSingleSequence,1,convertSingleSequence,"LogString convertSingleSequence (LogString,Pool)",main\cpp\colorstartpatternconverter.cpp,"static LogString convertSingleSequence(const LogString& sequence, Pool& pool){
	LogString strInParens;
	bool inParens = false;
	bool hasParens = false;
	size_t x = 0;

	for(x = 0; x < sequence.length(); x++){
		if( sequence[x] == '(' && !inParens ){
			inParens = true;
			hasParens = true;
			continue;
		}else if( sequence[x] == '(' && inParens ){
			// Unbalanced parens - parse invalid
			return LOG4CXX_STR("""");
		}

		if( sequence[x] == ')' && inParens ){
			hasParens = true;
			inParens = false;
			break;
		}

		if( inParens ){
			strInParens.push_back(sequence[x]);
		}
	}

	if( (x != (sequence.length() - 1) || inParens) && hasParens ){
		// Unbalanced parens, or more data in the string than we expected - parse invalid
		return LOG4CXX_STR("""");
	}

	if(StringHelper::startsWith(sequence, LOG4CXX_STR(""fg(""))){
		// Parse foreground
		return colorToANSISequence(strInParens, true, pool);
	}else if(StringHelper::startsWith(sequence, LOG4CXX_STR(""bg(""))){
		return colorToANSISequence(s...",93.0,133.0,1.0,1.0,41.0,25,10,28,7,0,2,9,10,1,2,,0,1,4,2,2,LogString
232,33336,LogLog,1,LogLog.LogLog,ANY LogLog.LogLog (),main\cpp\loglog.cpp,"LogLog::LogLog() :
	m_priv(std::make_unique<LogLogPrivate>())
{
	LogString log4cxxDebug = OptionConverter::getSystemProperty(LOG4CXX_STR(""LOG4CXX_DEBUG""), LOG4CXX_STR(""false""));
	m_priv->debugEnabled = OptionConverter::toBoolean(log4cxxDebug, false);
}",53.0,58.0,1.0,1.0,6.0,5,3,5,3,0,2,1,1,0,2,,0,2,0,0,0,ANY
233,62009,format,1,XMLLayout.format,"void XMLLayout.format (LogString,ANY,Pool)",main\cpp\xmllayout.cpp,"void XMLLayout::format(LogString& output,
	const spi::LoggingEventPtr& event,
	Pool& p) const
{
	output.reserve(m_priv->expectedPatternLength + event->getMessage().size());
	output.append(LOG4CXX_STR(""<log4j:event logger=\""""));
	Transform::appendEscapingTags(output, event->getLoggerName());
	output.append(LOG4CXX_STR(""\"" timestamp=\""""));
	StringHelper::toString(event->getTimeStamp() / 1000L, p, output);
	output.append(LOG4CXX_STR(""\"" level=\""""));
	Transform::appendEscapingTags(output, event->getLevel()->toString());
	output.append(LOG4CXX_STR(""\"" thread=\""""));
	Transform::appendEscapingTags(output, event->getThreadName());
	output.append(LOG4CXX_STR(""\"">""));
	output.append(LOG4CXX_EOL);

	output.append(LOG4CXX_STR(""<log4j:message><![CDATA[""));
	// Append the rendered message. Also make sure to escape any
	// existing CDATA sections.
	Transform::appendEscapingCDATA(output, event->getRenderedMessage());
	output.append(LOG4CXX_STR(""]]></log4j:message>""));
	output.append(LOG4CXX_EOL);

...",77.0,182.0,1.0,1.0,106.0,86,9,122,18,0,14,9,20,0,14,,0,0,6,3,3,void
234,41529,write,1,OutputStreamWriter.write,"void OutputStreamWriter.write (LogString,Pool)",main\cpp\outputstreamwriter.cpp,"void OutputStreamWriter::write(const LogString& str, Pool& p)
{
	if (str.empty())
		return;
	if (CharsetEncoder::isTriviallyCopyable(str, m_priv->enc))
	{
		ByteBuffer buf((char*)str.data(), str.size() * sizeof (logchar));
		m_priv->out->write(buf, p);
	}
	else
	{
		enum { BUFSIZE = 1024 };
		char stackData[BUFSIZE];
		char* rawbuf = stackData;
		size_t bufSize = BUFSIZE;
#ifdef LOG4CXX_MULTI_PROCESS
		std::vector<char> heapData;
		// Ensure the logging event is a single write system call to keep events from each process separate
		if (bufSize < str.length() * 2)
		{
			heapData.resize(bufSize = str.length() * 2);
			rawbuf = heapData.data();
		}
#endif
		ByteBuffer buf(rawbuf, bufSize);
		m_priv->enc->reset();
		LogString::const_iterator iter = str.begin();

		while (iter != str.end())
		{
			CharsetEncoder::encode(m_priv->enc, str, iter, buf);
			buf.flip();
			m_priv->out->write(buf, p);
			buf.clear();
		}

		CharsetEncoder::encode(m_priv->enc, str, iter, buf);
		m_priv->enc->fl...",79.0,120.0,1.0,1.0,42.0,10,5,10,6,0,1,3,3,1,1,,0,1,4,2,2,void
235,21047,run,1,FileWatchdog.run,void FileWatchdog.run (),main\cpp\filewatchdog.cpp,"void FileWatchdog::run()
{
	LogString msg(LOG4CXX_STR(""Checking [""));
	msg += m_priv->file.getPath();
	msg += LOG4CXX_STR(""] at "");
	StringHelper::toString((int)m_priv->delay, m_priv->pool, msg);
	msg += LOG4CXX_STR("" ms interval"");
	LogLog::debug(msg);

	while (!is_interrupted())
	{
		std::unique_lock<std::mutex> lock( m_priv->interrupt_mutex );
		if (!m_priv->interrupt.wait_for( lock, std::chrono::milliseconds( m_priv->delay ),
			std::bind(&FileWatchdog::is_interrupted, this) ))
			checkAndConfigure();
	}

	LogString msg2(LOG4CXX_STR(""Stop checking [""));
	msg2 += m_priv->file.getPath();
	msg2 += LOG4CXX_STR(""]"");
	LogLog::debug(msg2);
}",121.0,142.0,1.0,1.0,22.0,30,8,25,9,0,3,3,4,0,3,,0,0,0,0,0,void
236,65078,LevelChange,1,LOG4CXX_NS.LevelChange.LevelChange,"ANY LOG4CXX_NS.LevelChange.LevelChange (LoggerPtr,LevelPtr)",main\include\log4cxx\levelchange.hpp,"LevelChange(const StringType& otherCategory, const LoggerPtr& thisCategory)
		: LevelChange(LogManager::getLogger(otherCategory), thisCategory->getLevel())
	{
	}",66.0,69.0,2.0,2.0,4.0,1,1,2,2,0,1,1,1,0,0,,0,1,4,2,2,ANY
237,52793,monitor,1,SocketAppenderSkeleton.monitor,void SocketAppenderSkeleton.monitor (),main\cpp\socketappenderskeleton.cpp,"void SocketAppenderSkeleton::monitor()
{
	Pool p;
	SocketPtr socket;

	while (!is_closed())
	{
		try
		{
			LogString msg(LOG4CXX_STR(""Attempting connection to ["")
				+ _priv->address->toString() + LOG4CXX_STR("":""));
			StringHelper::toString(_priv->port, p, msg);
			msg += LOG4CXX_STR(""]."");
			LogLog::debug(msg);
			socket = Socket::create(_priv->address, _priv->port);
			setSocket(socket, p);
			LogLog::debug(LOG4CXX_STR(""Connection established. Exiting connector thread.""));
			return;
		}
		catch (ConnectException& e)
		{
			LogLog::error(LOG4CXX_STR(""Remote host "")
				+ _priv->address->toString()
				+ LOG4CXX_STR("" refused connection.""), e);
		}
		catch (IOException& e)
		{
			LogString msg(LOG4CXX_STR(""Could not connect to ["")
				+ _priv->address->toString() + LOG4CXX_STR("":""));
			StringHelper::toString(_priv->port, p, msg);
			msg += LOG4CXX_STR(""]."");
			LogLog::error(msg, e);
		}

		if (_priv->reconnectionDelay > 0)
		{
			LogString msg(LOG4CXX_STR(""Waiting ""));
			Str...",162.0,212.0,1.0,6.0,51.0,81,10,51,12,0,10,6,9,0,10,,0,1,0,0,0,void
238,14910,findAppenderByReference,1,DOMConfigurator.findAppenderByReference,"AppenderPtr DOMConfigurator.findAppenderByReference (ANY,ANY,apr_xml_elem*,apr_xml_doc*,AppenderMap)",main\cpp\domconfigurator.cpp,"AppenderPtr DOMConfigurator::findAppenderByReference(
	LOG4CXX_NS::helpers::Pool& p,
	LOG4CXX_NS::helpers::CharsetDecoderPtr& utf8Decoder,
	apr_xml_elem* appenderRef,
	apr_xml_doc* doc,
	AppenderMap& appenders)
{
	LogString appenderName(subst(getAttribute(utf8Decoder, appenderRef, REF_ATTR)));
	AppenderMap::const_iterator match = appenders.find(appenderName);
	AppenderPtr appender;

	if (match != appenders.end())
	{
		appender = match->second;
	}
	else if (doc)
	{
		appender = findAppenderByName(p, utf8Decoder, doc->root, doc, appenderName, appenders);

		if (appender)
		{
			appenders.insert(AppenderMap::value_type(appenderName, appender));
		}
	}

	if (!appender)
	{
		LogLog::error(LOG4CXX_STR(""No appender named ["") +
			appenderName + LOG4CXX_STR(""] could be found.""));
	}

	return appender;
}",169.0,201.0,1.0,69.0,33.0,10,6,13,7,0,1,3,3,0,1,,0,0,10,5,5,AppenderPtr
239,58937,getGMT,1,TimeZone.getGMT,TimeZonePtr TimeZone.getGMT (),main\cpp\timezone.cpp,"const TimeZonePtr& TimeZone::getGMT()
{
	return LOG4CXX_NS::helpers::TimeZoneImpl::GMTTimeZone::getInstance();
}",196.0,199.0,1.0,1.0,4.0,4,1,4,4,1,1,1,1,0,0,,0,0,0,0,0,TimeZonePtr
240,49728,format,1,LOG4CXX_NS.helpers.SimpleDateFormatImpl.LiteralToken.format,"void LOG4CXX_NS.helpers.SimpleDateFormatImpl.LiteralToken.format (LogString,apr_time_exp_t,Pool)",main\cpp\simpledateformat.cpp,"void format( LogString& s, const apr_time_exp_t&, Pool& /* p */ ) const
		{
			s.append( count, ch );
		}",209.0,212.0,3.0,3.0,4.0,1,1,3,3,0,2,1,1,0,0,,0,2,6,3,3,void
241,24126,addHierarchyEventListener,1,Hierarchy.addHierarchyEventListener,void Hierarchy.addHierarchyEventListener (ANY),main\cpp\hierarchy.cpp,"void Hierarchy::addHierarchyEventListener(const spi::HierarchyEventListenerPtr& listener)
{
	std::lock_guard<std::recursive_mutex> lock(m_priv->mutex);

	if (std::find(m_priv->listeners.begin(), m_priv->listeners.end(), listener) != m_priv->listeners.end())
	{
		LogLog::warn(LOG4CXX_STR(""Ignoring attempt to add an existent listener.""));
	}
	else
	{
		m_priv->listeners.push_back(listener);
	}
}",98.0,110.0,1.0,1.0,13.0,14,5,9,4,0,1,2,2,0,1,,0,0,2,1,1,void
242,55875,getProperty,1,System.getProperty,LogString System.getProperty (LogString),main\cpp\system.cpp,"LogString System::getProperty(const LogString& lkey)
{
	if (lkey.empty())
	{
		throw IllegalArgumentException(LOG4CXX_STR(""key is empty""));
	}

	LogString rv;

	if (lkey == LOG4CXX_STR(""java.io.tmpdir""))
	{
		Pool p;
		const char* dir = NULL;
		apr_status_t stat = apr_temp_dir_get(&dir, p.getAPRPool());

		if (stat == APR_SUCCESS)
		{
			Transcoder::decode(dir, rv);
		}

		return rv;
	}

	if (lkey == LOG4CXX_STR(""user.dir""))
	{
		Pool p;
		char* dir = NULL;
		apr_status_t stat = apr_filepath_get(&dir, APR_FILEPATH_NATIVE,
				p.getAPRPool());

		if (stat == APR_SUCCESS)
		{
			Transcoder::decode(dir, rv);
		}

		return rv;
	}

#if APR_HAS_USER

	if (lkey == LOG4CXX_STR(""user.home"") || lkey == LOG4CXX_STR(""user.name""))
	{
		Pool pool;
		apr_uid_t userid;
		apr_gid_t groupid;
		apr_pool_t* p = pool.getAPRPool();
		apr_status_t stat = apr_uid_current(&userid, &groupid, p);

		if (stat == APR_SUCCESS)
		{
			char* username = NULL;
			stat = apr_uid_name_get(&username, userid, p);

			if...",32.0,121.0,1.0,1.0,90.0,24,6,40,11,1,3,7,9,0,3,,0,0,2,1,1,LogString
243,45638,parseCatsAndRenderers,1,PropertyConfigurator.parseCatsAndRenderers,"void PropertyConfigurator.parseCatsAndRenderers (ANY,ANY)",main\cpp\propertyconfigurator.cpp,"void PropertyConfigurator::parseCatsAndRenderers(helpers::Properties& props,
	spi::LoggerRepositoryPtr& hierarchy)
{
	static const WideLife<LogString> CATEGORY_PREFIX(LOG4CXX_STR(""log4j.category.""));
	static const WideLife<LogString> LOGGER_PREFIX(LOG4CXX_STR(""log4j.logger.""));

	std::vector<LogString> names = props.propertyNames();

	std::vector<LogString>::iterator it = names.begin();
	std::vector<LogString>::iterator itEnd = names.end();

	while (it != itEnd)
	{
		LogString key = *it++;

		if (key.find(CATEGORY_PREFIX) == 0 || key.find(LOGGER_PREFIX) == 0)
		{
			LogString loggerName;

			if (key.find(CATEGORY_PREFIX) == 0)
			{
				loggerName = key.substr(CATEGORY_PREFIX.value().length());
			}
			else if (key.find(LOGGER_PREFIX.value()) == 0)
			{
				loggerName = key.substr(LOGGER_PREFIX.value().length());
			}

			LogString value = OptionConverter::findAndSubst(key, props);
			LoggerPtr logger = hierarchy->getLogger(loggerName, loggerFactory);

			bool additivity = parseAddit...",269.0,305.0,1.0,1.0,37.0,29,10,39,16,0,1,4,7,0,1,,0,1,4,2,2,void
244,43592,createConverter,1,PatternParser.createConverter,"PatternConverterPtr PatternParser.createConverter (LogString,LogString,PatternMap,ANY)",main\cpp\patternparser.cpp,"PatternConverterPtr PatternParser::createConverter(
	const LogString& converterId,
	LogString& currentLiteral,
	const PatternMap& rules,
	std::vector<LogString>& options)
{

	LogString converterName(converterId);

	for (size_t i = converterId.length(); i > 0; i--)
	{
		converterName = converterName.substr(0, i);
		PatternMap::const_iterator iter = rules.find(converterName);

		if (iter != rules.end())
		{
			currentLiteral.erase(currentLiteral.begin(),
				currentLiteral.end() - (converterId.length() - i));
			return (iter->second)(options);
		}
	}

	LogLog::error(LogString(LOG4CXX_STR(""Unrecognized format specifier "")) + converterId);

	return PatternConverterPtr();
}",307.0,332.0,1.0,1.0,26.0,18,7,21,8,0,1,3,4,0,1,,0,0,8,4,4,PatternConverterPtr
245,58952,getTimeZone,1,TimeZone.getTimeZone,TimeZonePtr TimeZone.getTimeZone (LogString),main\cpp\timezone.cpp,"const TimeZonePtr TimeZone::getTimeZone( const LogString& id )
{
	const logchar gmt[] = { 0x47, 0x4D, 0x54, 0 };

	if ( id == gmt )
	{
		return LOG4CXX_NS::helpers::TimeZoneImpl::GMTTimeZone::getInstance();
	}

	if ( id.length() >= 5 && id.substr( 0, 3 ) == gmt )
	{
		int hours = 0;
		int minutes = 0;
		int sign = 1;

		if (id[3] == 0x2D /* '-' */)
		{
			sign = -1;
		}

		LogString off( id.substr( 4 ) );

		if ( id.length() >= 7 )
		{
			size_t colonPos = off.find( 0x3A /* ':' */);

			if ( colonPos == LogString::npos )
			{
				minutes = StringHelper::toInt(off.substr(off.length() - 2));
				hours = StringHelper::toInt(off.substr(0, off.length() - 2));
			}
			else
			{
				minutes = StringHelper::toInt(off.substr(colonPos + 1));
				hours = StringHelper::toInt(off.substr(0, colonPos));
			}
		}
		else
		{
			hours = StringHelper::toInt(off);
		}

		LogString s(gmt);
		Pool p;
		LogString hh;
		StringHelper::toString(hours, p, hh);

		if (sign > 0)
		{
			s.append(1, (logchar) 0x2...",201.0,285.0,1.0,1.0,85.0,68,17,62,20,0,5,10,17,0,4,,0,2,2,1,1,TimeZonePtr
246,40522,toBoolean,1,OptionConverter.toBoolean,"bool OptionConverter.toBoolean (LogString,bool)",main\cpp\optionconverter.cpp,"bool OptionConverter::toBoolean(const LogString& value, bool dEfault)
{
	if (value.length() >= 4)
	{
		if (StringHelper::equalsIgnoreCase(value.substr(0, 4),
				LOG4CXX_STR(""TRUE""), LOG4CXX_STR(""true"")))
		{
			return true;
		}
	}

	if (dEfault && value.length() >= 5)
	{
		if (StringHelper::equalsIgnoreCase(value.substr(0, 5),
				LOG4CXX_STR(""FALSE""), LOG4CXX_STR(""false"")))
		{
			return false;
		}
	}

	return dEfault;
}",122.0,143.0,1.0,1.0,22.0,9,3,8,3,13,2,5,7,2,2,,0,2,4,2,2,bool
247,6733,add,1,anonymous_namespace_3.AtExitRegistryImpl.add,"void anonymous_namespace_3.AtExitRegistryImpl.add (void*,ANY)",main\cpp\atexitregistry.cpp,"void add(void* key, std::function<void()> action)
		{
			std::lock_guard<std::recursive_mutex> lock(mutex);
			actions.emplace(key, std::move(action));
		}",39.0,43.0,3.0,3.0,5.0,6,3,7,5,0,2,1,1,0,0,,0,2,4,2,2,void
248,49742,count,3,LOG4CXX_NS.helpers.SimpleDateFormatImpl.LiteralToken.count,,main\cpp\simpledateformat.cpp,count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
249,49741,ch,3,LOG4CXX_NS.helpers.SimpleDateFormatImpl.LiteralToken.ch,,main\cpp\simpledateformat.cpp,ch,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
250,53840,toInt,1,StringHelper.toInt,int StringHelper.toInt (LogString),main\cpp\stringhelper.cpp,"int StringHelper::toInt(const LogString& s)
{
#if LOG4CXX_LOGCHAR_IS_UNICHAR
	std::string as;
	Transcoder::encode(s, as);
	return std::stoi(as);
#else
	return std::stoi(s);
#endif
}",109.0,118.0,1.0,1.0,10.0,1,1,2,2,5,0,1,1,0,0,,0,0,2,1,1,int
251,44624,BEGIN,3,PropertyParser.LexemType.BEGIN,,main\cpp\properties.cpp,BEGIN,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
252,44625,KEY,3,PropertyParser.LexemType.KEY,,main\cpp\properties.cpp,KEY,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
253,44626,KEY_ESCAPE,3,PropertyParser.LexemType.KEY_ESCAPE,,main\cpp\properties.cpp,KEY_ESCAPE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
254,44627,KEY_CONTINUE,3,PropertyParser.LexemType.KEY_CONTINUE,,main\cpp\properties.cpp,KEY_CONTINUE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
255,44628,KEY_CONTINUE2,3,PropertyParser.LexemType.KEY_CONTINUE2,,main\cpp\properties.cpp,KEY_CONTINUE2,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
256,32337,setOption,1,LoggerMatchFilter.setOption,"void LoggerMatchFilter.setOption (LogString,LogString)",main\cpp\loggermatchfilter.cpp,"void LoggerMatchFilter::setOption(const LogString& option,
	const LogString& value)
{

	if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""LOGGERTOMATCH""), LOG4CXX_STR(""loggertomatch"")))
	{
		setLoggerToMatch(value);
	}
	else if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""ACCEPTONMATCH""), LOG4CXX_STR(""acceptonmatch"")))
	{
		priv->acceptOnMatch = OptionConverter::toBoolean(value, priv->acceptOnMatch);
	}
}",62.0,76.0,1.0,2.0,15.0,1,1,3,3,0,1,2,2,1,1,,0,1,4,2,2,void
257,29271,setOption,1,LevelRangeFilter.setOption,"void LevelRangeFilter.setOption (LogString,LogString)",main\cpp\levelrangefilter.cpp,"void LevelRangeFilter::setOption(const LogString& option,
	const LogString& value)
{

	if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""LEVELMIN""), LOG4CXX_STR(""levelmin"")))
	{
		priv->levelMin = OptionConverter::toLevel(value, priv->levelMin);
	}
	else if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""LEVELMAX""), LOG4CXX_STR(""levelmax"")))
	{
		priv->levelMax = OptionConverter::toLevel(value, priv->levelMax);
	}
	else if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""ACCEPTONMATCH""), LOG4CXX_STR(""acceptonmatch"")))
	{
		priv->acceptOnMatch = OptionConverter::toBoolean(value, priv->acceptOnMatch);
	}
}",56.0,75.0,1.0,2.0,20.0,9,4,6,5,0,2,2,2,1,2,,0,2,4,2,2,void
258,44630,ELEMENT,3,PropertyParser.LexemType.ELEMENT,,main\cpp\properties.cpp,ELEMENT,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
259,44631,ELEMENT_ESCAPE,3,PropertyParser.LexemType.ELEMENT_ESCAPE,,main\cpp\properties.cpp,ELEMENT_ESCAPE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
260,44632,ELEMENT_CONTINUE,3,PropertyParser.LexemType.ELEMENT_CONTINUE,,main\cpp\properties.cpp,ELEMENT_CONTINUE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
261,44633,ELEMENT_CONTINUE2,3,PropertyParser.LexemType.ELEMENT_CONTINUE2,,main\cpp\properties.cpp,ELEMENT_CONTINUE2,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
262,33372,setInternalDebugging,1,LogLog.setInternalDebugging,void LogLog.setInternalDebugging (bool),main\cpp\loglog.cpp,"void LogLog::setInternalDebugging(bool debugEnabled1)
{
	auto p = getInstance().m_priv.get();
	std::unique_lock<std::mutex> lock(p->mutex);

	p->debugEnabled = debugEnabled1;
}",69.0,75.0,1.0,1.0,7.0,10,5,6,3,2,0,1,1,0,0,,0,0,2,1,1,void
263,44634,COMMENT,3,PropertyParser.LexemType.COMMENT,,main\cpp\properties.cpp,COMMENT,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
264,30299,setOption,1,LocationInfoFilter.setOption,"void LocationInfoFilter.setOption (LogString,LogString)",main\cpp\locationinfofilter.cpp,"void LocationInfoFilter::setOption(  const LogString& option,
	const LogString& value)
{
	LogLog::warn(option + LOG4CXX_STR("":"") + value);
	if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""ACCEPTONMATCH""), LOG4CXX_STR(""acceptonmatch"")))
	{
		priv->acceptOnMatch = OptionConverter::toBoolean(value, priv->acceptOnMatch);
	}
	else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""OPERATOR""), LOG4CXX_STR(""operator"")))
	{
		priv->mustMatchAll = StringHelper::equalsIgnoreCase(value, LOG4CXX_STR(""AND""), LOG4CXX_STR(""and"")) ? true : false;
	}
	else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""LINENUMBER""), LOG4CXX_STR(""linenumber"")))
	{
		priv->lineNumber = OptionConverter::toInt(value, -1);
	}
	else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""METHOD""), LOG4CXX_STR(""method"")))
	{
		LOG4CXX_ENCODE_CHAR(sName, value);
		priv->methodName = sName;
	}
}",57.0,78.0,1.0,2.0,22.0,12,5,9,6,0,3,2,2,1,3,,0,2,4,2,2,void
265,46689,setProperties,1,PropertySetter.setProperties,"void PropertySetter.setProperties (ANY,ANY,LogString,Pool)",main\cpp\propertysetter.cpp,"void PropertySetter::setProperties(helpers::Properties& properties,
	const LogString& prefix,
	Pool& p)
{
	size_t len = prefix.length();

	std::vector<LogString> names = properties.propertyNames();
	std::vector<LogString>::iterator it;

	for (it = names.begin(); it != names.end(); it++)
	{
		LogString key = *it;

		// handle only properties that start with the desired frefix.
		if (key.find(prefix) == 0)
		{
			// ignore key if it contains dots after the prefix
			if (key.find(0x2E /* '.' */, len + 1) != LogString::npos)
			{
				continue;
			}

			LogString value = OptionConverter::findAndSubst(key, properties);
			key = key.substr(len);

			if (key == LOG4CXX_STR(""layout"")
				&& obj != 0
				&& obj->instanceof(Appender::getStaticClass()))
			{
				continue;
			}

			setProperty(key, value, p);
		}
	}

	activate(p);
}",47.0,84.0,1.0,1.0,38.0,1,1,4,4,5,0,1,1,0,0,,0,0,6,3,3,void
266,23139,format,1,FullLocationPatternConverter.format,"void FullLocationPatternConverter.format (LoggingEventPtr,LogString,Pool)",main\cpp\fulllocationpatternconverter.cpp,"void FullLocationPatternConverter::format(
	const LoggingEventPtr& event,
	LogString& toAppendTo,
	Pool& p) const
{
	append(toAppendTo, event->getLocationInformation().getFileName());
	toAppendTo.append(1, (logchar) 0x28 /* '(' */);
	StringHelper::toString(
		event->getLocationInformation().getLineNumber(),
		p, toAppendTo);
	toAppendTo.append(1, (logchar) 0x29 /* ')' */);
}",44.0,55.0,1.0,1.0,12.0,9,3,8,4,0,1,1,1,0,1,,0,0,6,3,3,void
267,35428,clear,1,MDC.clear,void MDC.clear (),main\cpp\mdc.cpp,"void MDC::clear()
{
	ThreadSpecificData* data = ThreadSpecificData::getCurrentData();

	if (data != 0)
	{
		Map& map = data->getMap();
		map.erase(map.begin(), map.end());
		data->recycle();
	}
}",127.0,137.0,1.0,1.0,11.0,9,4,9,3,0,1,2,2,0,0,,0,1,0,0,0,void
268,53862,toString,1,StringHelper.toString,"void StringHelper.toString (int,Pool,LogString)",main\cpp\stringhelper.cpp,"void StringHelper::toString(size_t n, Pool& pool, LogString& dst)
{
#if LOG4CXX_LOGCHAR_IS_WCHAR
	dst.append(std::to_wstring(n));
#else
	Transcoder::decode(std::to_string(n), dst);
#endif
}",163.0,170.0,1.0,1.0,8.0,2,1,4,4,29,1,1,1,0,1,,0,0,6,3,3,void
269,16998,parse,1,DOMConfigurator.parse,"void DOMConfigurator.parse (Pool,ANY,apr_xml_elem*,apr_xml_doc*,AppenderMap)",main\cpp\domconfigurator.cpp,"void DOMConfigurator::parse(
	Pool& p,
	LOG4CXX_NS::helpers::CharsetDecoderPtr& utf8Decoder,
	apr_xml_elem* element,
	apr_xml_doc* doc,
	AppenderMap& appenders)
{
	std::string rootElementName(element->name);

	if (rootElementName != CONFIGURATION_TAG)
	{
		if (rootElementName == OLD_CONFIGURATION_TAG)
		{
			//LogLog::warn(LOG4CXX_STR(""The <"")+String(OLD_CONFIGURATION_TAG)+
			// LOG4CXX_STR(""> element has been deprecated.""));
			//LogLog::warn(LOG4CXX_STR(""Use the <"")+String(CONFIGURATION_TAG)+
			// LOG4CXX_STR(""> element instead.""));
		}
		else
		{
			LogLog::error(LOG4CXX_STR(""DOM element is - not a <configuration> element.""));
			return;
		}
	}

	LogString debugAttrib = subst(getAttribute(utf8Decoder, element, INTERNAL_DEBUG_ATTR));

	static const WideLife<LogString> NULL_STRING(LOG4CXX_STR(""NULL""));
	LogLog::debug(LOG4CXX_STR(""debug attribute= \"""") + debugAttrib + LOG4CXX_STR(""\"".""));

	// if the log4j.dtd is not specified in the XML file, then the
	// ""debug"" attribute is ret...",991.0,1101.0,1.0,24.0,111.0,55,9,64,19,0,9,12,16,0,8,,0,3,10,5,5,void
270,6759,del,1,anonymous_namespace_4.AtExitRegistryImpl.del,void anonymous_namespace_4.AtExitRegistryImpl.del (void*),main\cpp\atexitregistry.cpp,"void del(void* key)
		{
			std::lock_guard<std::recursive_mutex> lock(mutex);
			actions.erase(key);
		}",45.0,49.0,3.0,3.0,5.0,5,3,5,4,0,2,1,1,0,0,,0,2,2,1,1,void
271,8810,getISOLatinDecoder,1,CharsetDecoder.getISOLatinDecoder,CharsetDecoderPtr CharsetDecoder.getISOLatinDecoder (),main\cpp\charsetdecoder.cpp,"CharsetDecoderPtr CharsetDecoder::getISOLatinDecoder()
{
	return std::make_shared<ISOLatinCharsetDecoder>();
}",547.0,550.0,1.0,1.0,4.0,1,1,1,1,1,0,1,1,0,0,,0,0,0,0,0,CharsetDecoderPtr
272,8819,getDecoder,1,CharsetDecoder.getDecoder,CharsetDecoderPtr CharsetDecoder.getDecoder (LogString),main\cpp\charsetdecoder.cpp,"CharsetDecoderPtr CharsetDecoder::getDecoder(const LogString& charset)
{
	if (StringHelper::equalsIgnoreCase(charset, LOG4CXX_STR(""UTF-8""), LOG4CXX_STR(""utf-8"")) ||
		StringHelper::equalsIgnoreCase(charset, LOG4CXX_STR(""UTF8""), LOG4CXX_STR(""utf8"")) ||
		StringHelper::equalsIgnoreCase(charset, LOG4CXX_STR(""CP65001""), LOG4CXX_STR(""cp65001"")))
	{
		return std::make_shared<UTF8CharsetDecoder>();
	}
	else if (StringHelper::equalsIgnoreCase(charset, LOG4CXX_STR(""C""), LOG4CXX_STR(""c"")) ||
		charset == LOG4CXX_STR(""646"") ||
		StringHelper::equalsIgnoreCase(charset, LOG4CXX_STR(""US-ASCII""), LOG4CXX_STR(""us-ascii"")) ||
		StringHelper::equalsIgnoreCase(charset, LOG4CXX_STR(""ISO646-US""), LOG4CXX_STR(""iso646-US"")) ||
		StringHelper::equalsIgnoreCase(charset, LOG4CXX_STR(""ANSI_X3.4-1968""), LOG4CXX_STR(""ansi_x3.4-1968"")) ||
		StringHelper::equalsIgnoreCase(charset, LOG4CXX_STR(""CP20127""), LOG4CXX_STR(""cp20127"")))
	{
		return std::make_shared<USASCIICharsetDecoder>();
	}
	else if (StringHelper::equ...",553.0,586.0,1.0,1.0,34.0,7,3,8,3,0,3,2,2,3,3,,0,3,2,1,1,CharsetDecoderPtr
273,49784,format,1,LOG4CXX_NS.helpers.SimpleDateFormatImpl.NumericToken.format,"void LOG4CXX_NS.helpers.SimpleDateFormatImpl.NumericToken.format (LogString,apr_time_exp_t,Pool)",main\cpp\simpledateformat.cpp,"void format( LogString& s, const apr_time_exp_t& tm, Pool& p ) const
		{
			size_t initialLength = s.length();

			StringHelper::toString( getField( tm ), p, s );
			size_t finalLength = s.length();

			if ( initialLength + width > finalLength )
			{
				s.insert( initialLength, ( initialLength + width ) - finalLength, (logchar) 0x30 /* '0' */);
			}
		}",246.0,257.0,3.0,3.0,12.0,11,6,16,7,0,3,2,2,1,1,,0,2,6,3,3,void
274,33403,debug,1,LogLog.debug,void LogLog.debug (LogString),main\cpp\loglog.cpp,"void LogLog::debug(const LogString& msg, const std::exception& e)
{
	auto p = getInstance().m_priv.get();
	if (p && !p->quietMode) // Not deleted by onexit processing?
	{
		if (!p->debugEnabled)
			return;

		std::unique_lock<std::mutex> lock(p->mutex);
		emit(msg);
		emit(e);
	}
}",93.0,105.0,1.0,1.0,13.0,13,7,8,3,46,0,3,4,0,0,,0,0,4,2,2,void
275,6779,mutex,3,anonymous_namespace_1.AtExitRegistryImpl.mutex,,main\cpp\atexitregistry.cpp,mutex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
276,6780,actions,3,anonymous_namespace_1.AtExitRegistryImpl.actions,,main\cpp\atexitregistry.cpp,actions,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
277,48770,os,3,LOG4CXX_NS.rolling.CountingOutputStream.os,,main\cpp\rollingfileappender.cpp,os,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
278,643,ConfigureLogging,1,com.foo.ConfigureLogging,void com.foo.ConfigureLogging (),examples\cpp\com\foo\config-qt.cpp,"void ConfigureLogging() {
	using namespace log4cxx;
	static struct log4cxx_finalizer {
		~log4cxx_finalizer() {
			LogManager::shutdown();
		}
	} finaliser;
	QFileInfo app{QCoreApplication::applicationFilePath()};
	QString basename{app.baseName()};
	QVector<QString> paths =
		{ QString(""."")
		, app.absoluteDir().absolutePath()
		};
	QVector<QString> names =
		{ QString(basename + "".xml"")
		, QString(basename + "".properties"")
		, QString(""MyApp.properties"")
		, QString(""log4cxx.xml"")
		, QString(""log4cxx.properties"")
		, QString(""log4j.xml"")
		, QString(""log4j.properties"")
	};
#if defined(_DEBUG)
	helpers::LogLog::setInternalDebugging(true);
#endif
	auto status       = spi::ConfigurationStatus::NotConfigured;
	auto selectedPath = QString();
	std::tie(status, selectedPath) = qt::Configuration::configureFromFileAndWatch(paths, names);
	if (status == spi::ConfigurationStatus::NotConfigured)
		BasicConfigurator::configure(); // Send events to the console
}",31.0,61.0,1.0,1.0,31.0,24,6,25,15,0,1,2,2,0,1,,0,0,0,0,0,void
279,25220,updateChildren,1,Hierarchy.updateChildren,"void Hierarchy.updateChildren (ProvisionNode,LoggerPtr)",main\cpp\hierarchy.cpp,"void Hierarchy::updateChildren(const Logger* parent)
{
	for (auto& item : m_priv->loggers)
	{
		for (auto l = item.second; l; l = l->getParent())
		{
			if (l->getParent().get() == parent)
			{
				item.second->updateThreshold();
				break;
			}
		}
	}
}",447.0,460.0,1.0,1.0,14.0,15,6,15,6,0,1,3,4,1,1,,0,1,2,1,1,void
280,48771,rfa,3,LOG4CXX_NS.rolling.CountingOutputStream.rfa,,main\cpp\rollingfileappender.cpp,* rfa,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
281,40584,toInt,1,OptionConverter.toInt,"int OptionConverter.toInt (LogString,int)",main\cpp\optionconverter.cpp,"int OptionConverter::toInt(const LogString& value, int dEfault)
{
	LogString trimmed(StringHelper::trim(value));

	if (trimmed.empty())
	{
		return dEfault;
	}

	LOG4CXX_ENCODE_CHAR(cvalue, trimmed);

	return (int) atol(cvalue.c_str());
}",145.0,157.0,1.0,1.0,13.0,4,2,7,5,5,1,2,2,0,1,,0,0,4,2,2,int
282,56913,acceptConnections,1,TelnetAppender.acceptConnections,void TelnetAppender.acceptConnections (),main\cpp\telnetappender.cpp,"void TelnetAppender::acceptConnections()
{

	// main loop; is left when This->closed is != 0 after an accept()
	while (true)
	{
		try
		{
			SocketPtr newClient = _priv->serverSocket->accept();
			bool done = _priv->closed;

			if (done)
			{
				Pool p;
				writeStatus(newClient, LOG4CXX_STR(""Log closed.\r\n""), p);
				newClient->close();

				break;
			}

			size_t count = _priv->activeConnections;

			if (count >= _priv->connections.size())
			{
				Pool p;
				writeStatus(newClient, LOG4CXX_STR(""Too many connections.\r\n""), p);
				newClient->close();
			}
			else
			{
				//
				//   find unoccupied connection
				//
				std::lock_guard<std::recursive_mutex> lock(_priv->mutex);

				for (ConnectionList::iterator iter = _priv->connections.begin();
					iter != _priv->connections.end();
					iter++)
				{
					if (*iter == NULL)
					{
						*iter = newClient;
						_priv->activeConnections++;

						break;
					}
				}

				Pool p;
				LogString oss(LOG4CXX_STR(""TelnetAppender v...",235.0,310.0,1.0,25.0,76.0,28,6,19,7,0,1,9,16,0,1,,0,0,0,0,0,void
283,1675,test,1,DelayedLoop.test,void DelayedLoop.test (),examples\cpp\delayedloop.cpp,"static void test()
        {
                int i = 0;
                while(true)
                {
                   LOG4CXX_DEBUG(logger, ""MSG "" << i++);
                        try
                        {
                                apr_sleep(1000000);
                        }
                        catch(std::exception&)
                        {
                        }
                }
        }",79.0,93.0,9.0,9.0,15.0,3,3,3,2,1,1,3,4,0,0,,0,1,0,0,0,void
284,22158,purge,1,FixedWindowRollingPolicy.purge,"bool FixedWindowRollingPolicy.purge (int,int,Pool)",main\cpp\fixedwindowrollingpolicy.cpp,"bool FixedWindowRollingPolicy::purge(int lowIndex, int highIndex, Pool& p) const
{
	int suffixLength = 0;

	std::vector<FileRenameActionPtr> renames;
	LogString buf;
	ObjectPtr obj = std::make_shared<Integer>(lowIndex);
	formatFileName(obj, buf, p);

	LogString lowFilename(buf);

	if (lowFilename.compare(lowFilename.length() - 3, 3, LOG4CXX_STR("".gz"")) == 0)
	{
		suffixLength = 3;
	}
	else if (lowFilename.compare(lowFilename.length() - 4, 4, LOG4CXX_STR("".zip"")) == 0)
	{
		suffixLength = 4;
	}

	for (int i = lowIndex; i <= highIndex; i++)
	{
		File toRenameCompressed;
		toRenameCompressed.setPath(lowFilename);
		File toRenameBase;
		toRenameBase.setPath(lowFilename.substr(0, lowFilename.length() - suffixLength));
		File* toRename = &toRenameCompressed;
		bool isBase = false;
		bool exists = toRenameCompressed.exists(p);

		if (suffixLength > 0)
		{
			if (exists)
			{
				if (toRenameBase.exists(p))
				{
					toRenameBase.deleteFile(p);
				}
			}
			else
			{
				toRename = &toRen...",257.0,369.0,1.0,1.0,113.0,60,15,73,22,0,1,14,30,0,1,,0,0,6,3,3,bool
285,14996,parseAppender,1,DOMConfigurator.parseAppender,"AppenderPtr DOMConfigurator.parseAppender (Pool,ANY,apr_xml_elem*,apr_xml_doc*,AppenderMap)",main\cpp\domconfigurator.cpp,"AppenderPtr DOMConfigurator::parseAppender(Pool& p,
	LOG4CXX_NS::helpers::CharsetDecoderPtr& utf8Decoder,
	apr_xml_elem* appenderElement,
	apr_xml_doc* doc,
	AppenderMap& appenders)
{

	LogString className(subst(getAttribute(utf8Decoder, appenderElement, CLASS_ATTR)));
	LogLog::debug(LOG4CXX_STR(""Class name: ["") + className + LOG4CXX_STR(""]""));

	try
	{
		ObjectPtr instance = ObjectPtr(Loader::loadClass(className).newInstance());
		AppenderPtr appender = LOG4CXX_NS::cast<Appender>(instance);
		PropertySetter propSetter(appender);

		appender->setName(subst(getAttribute(utf8Decoder, appenderElement, NAME_ATTR)));

		for (apr_xml_elem* currentElement = appenderElement->first_child;
			currentElement;
			currentElement = currentElement->next)
		{

			std::string tagName(currentElement->name);

			// Parse appender parameters
			if (tagName == PARAM_TAG)
			{
				setParameter(p, utf8Decoder, currentElement, propSetter);
			}
			// Set appender layout
			else if (tagName == LAYOUT_TAG)
	...",206.0,321.0,1.0,70.0,116.0,17,7,29,14,0,3,4,7,0,3,,0,1,10,5,5,AppenderPtr
286,61077,activateOptions,1,WriterAppender.activateOptions,void WriterAppender.activateOptions (Pool),main\cpp\writerappender.cpp,"void WriterAppender::activateOptions(Pool& p)
{
	int errors = 0;

	if (_priv->layout == 0)
	{
		_priv->errorHandler->error(
			((LogString) LOG4CXX_STR(""No layout set for the appender named [""))
			+ _priv->name + LOG4CXX_STR(""].""));
		errors++;
	}

	if (_priv->writer == 0)
	{
		_priv->errorHandler->error(
			((LogString) LOG4CXX_STR(""No writer set for the appender named [""))
			+ _priv->name + LOG4CXX_STR(""].""));
		errors++;
	}

	if (errors == 0)
	{
		AppenderSkeleton::activateOptions(p);
	}
}",63.0,87.0,1.0,5.0,25.0,33,7,12,4,2,0,4,4,0,0,,0,0,2,1,1,void
287,43678,finalizeConverter,1,PatternParser.finalizeConverter,"size_t PatternParser.finalizeConverter (logchar,LogString,size_t,LogString,FormattingInfoPtr,PatternMap,ANY,ANY)",main\cpp\patternparser.cpp,"size_t PatternParser::finalizeConverter(
	logchar c, const LogString& pattern, size_t i,
	LogString& currentLiteral, const FormattingInfoPtr& formattingInfo,
	const PatternMap&  rules,
	std::vector<PatternConverterPtr>& patternConverters,
	std::vector<FormattingInfoPtr>&  formattingInfos)
{
	LogString convBuf;
	i = extractConverter(c, pattern, i, convBuf, currentLiteral);

	if (convBuf.empty())
	{
		LogLog::error(LOG4CXX_STR(""Empty conversion specifier""));
		patternConverters.push_back(
			LiteralPatternConverter::newInstance(currentLiteral));
		formattingInfos.push_back(FormattingInfo::getDefault());
	}
	else
	{
		LogString converterId(convBuf);

		std::vector<LogString> options;
		i = extractOptions(pattern, i, options);

		PatternConverterPtr pc(
			createConverter(
				converterId, currentLiteral, rules, options));

		if (pc == NULL)
		{
			LogString msg(LOG4CXX_STR(""Unrecognized conversion specifier [""));
			msg.append(converterId);
			msg.append(LOG4CXX_STR(""] in conversion pa...",334.0,392.0,1.0,1.0,59.0,12,3,18,10,0,3,3,3,0,2,,0,0,16,8,8,size_t
288,65183,m_hadConfiguration,3,LOG4CXX_NS.LoggerInstancePtr.m_hadConfiguration,,main\include\log4cxx\loggerinstance.hpp,m_hadConfiguration,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
289,65184,m_logger,3,LOG4CXX_NS.LoggerInstancePtr.m_logger,,main\include\log4cxx\loggerinstance.hpp,m_logger,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
290,13984,append,1,DBAppender.append,"void DBAppender.append (ANY,ANY)",main\cpp\dbappender.cpp,"void DBAppender::append(const spi::LoggingEventPtr& event, helpers::Pool& p){
	std::vector<std::string> ls_args;
    std::vector<const char*> args;
    int stat;
    int num_rows;

    if(_priv->m_driver == nullptr ||
            _priv->m_databaseHandle == nullptr ||
            _priv->preparedStmt == nullptr){
        _priv->errorHandler->error(LOG4CXX_STR(""DBAppender not initialized properly: logging not available""));
        return;
    }

    for(auto& converter : _priv->converters){
        LogString str_data;
        converter->format(event, str_data, p);
		LOG4CXX_ENCODE_CHAR(new_str_data, str_data);
		ls_args.push_back(new_str_data);
    }

	for(std::string& str : ls_args){
        args.push_back(str.data());
    }
    args.push_back(nullptr);

    stat = apr_dbd_pquery(_priv->m_driver,
                          _priv->m_pool.getAPRPool(),
                          _priv->m_databaseHandle,
                          &num_rows,
                          _priv->preparedStmt,
  ...",211.0,250.0,1.0,7.0,40.0,62,11,41,16,0,1,5,5,0,1,,0,0,4,2,2,void
291,44709,load,1,Properties.load,void Properties.load (InputStreamPtr),main\cpp\properties.cpp,"void Properties::load(InputStreamPtr inStream)
{
	Pool pool;
	auto lineReader = std::make_shared<InputStreamReader>(inStream, CharsetDecoder::getISOLatinDecoder());
	LogString contents = lineReader->read(pool);
	properties->clear();
	PropertyParser parser;
	parser.parse(contents, *this);
}",430.0,438.0,1.0,1.0,9.0,12,8,11,9,0,1,1,1,0,0,,0,1,2,1,1,void
292,40616,toFileSize,1,OptionConverter.toFileSize,"long OptionConverter.toFileSize (LogString,long)",main\cpp\optionconverter.cpp,"long OptionConverter::toFileSize(const LogString& s, long dEfault)
{
	if (s.empty())
	{
		return dEfault;
	}

	size_t index = s.find_first_of(LOG4CXX_STR(""bB""));

	if (index != LogString::npos && index > 0)
	{
		long multiplier = 1;
		index--;

		if (s[index] == 0x6B /* 'k' */ || s[index] == 0x4B /* 'K' */)
		{
			multiplier = 1024;
		}
		else if (s[index] == 0x6D /* 'm' */ || s[index] == 0x4D /* 'M' */)
		{
			multiplier = 1024 * 1024;
		}
		else if (s[index] == 0x67 /* 'g'*/ || s[index] == 0x47 /* 'G' */)
		{
			multiplier = 1024 * 1024 * 1024;
		}

		return toInt(s.substr(0, index), 1) * multiplier;
	}

	return toInt(s, 1);
}",159.0,190.0,1.0,1.0,32.0,17,10,18,5,2,0,4,5,0,0,,0,0,4,2,2,long
293,47785,activateOptions,1,RollingFileAppender.activateOptions,void RollingFileAppender.activateOptions (Pool),main\cpp\rollingfileappender.cpp,"void RollingFileAppender::activateOptions(Pool& p)
{
	if (!_priv->rollingPolicy)
	{
		LogLog::warn(LOG4CXX_STR(""No rolling policy configured for the appender named ["")
			+ _priv->name + LOG4CXX_STR(""].""));
		auto fwrp = std::make_shared<FixedWindowRollingPolicy>();
		fwrp->setFileNamePattern(getFile() + LOG4CXX_STR("".%i""));
		_priv->rollingPolicy = fwrp;
	}

	//
	//  if no explicit triggering policy and rolling policy is both.
	//
	if (!_priv->triggeringPolicy)
	{
		TriggeringPolicyPtr trig = LOG4CXX_NS::cast<TriggeringPolicy>(_priv->rollingPolicy);

		if (trig != NULL)
		{
			_priv->triggeringPolicy = trig;
		}
	}

	if (!_priv->triggeringPolicy)
	{
		LogLog::warn(LOG4CXX_STR(""No triggering policy configured for the appender named ["")
			+ _priv->name + LOG4CXX_STR(""].""));
		_priv->triggeringPolicy = std::make_shared<SizeBasedTriggeringPolicy>();
	}

	{
		std::lock_guard<std::recursive_mutex> lock(_priv->mutex);
		_priv->triggeringPolicy->activateOptions(p);
		_priv->rollingPolicy-...",200.0,285.0,1.0,6.0,86.0,95,9,55,14,0,4,10,17,0,4,,0,0,2,1,1,void
294,49833,width,3,LOG4CXX_NS.helpers.SimpleDateFormatImpl.NumericToken.width,,main\cpp\simpledateformat.cpp,width,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
295,28331,getFormattedEventCharacterCount,1,Layout.getFormattedEventCharacterCount,size_t Layout.getFormattedEventCharacterCount (),main\cpp\layout.cpp,"size_t Layout::getFormattedEventCharacterCount() const
{
	auto exampleEvent = std::make_shared<spi::LoggingEvent>
		( LOG4CXX_STR(""example.logger"")
		, Level::getDebug()
		, LOG4CXX_LOCATION
		, LogString()
		);
	LogString text;
	Pool pool;
	format(text, exampleEvent, pool);
	return text.size();
}",40.0,52.0,1.0,1.0,13.0,9,6,9,7,0,1,1,1,0,0,,0,1,0,0,0,size_t
296,65199,operator ->,1,LOG4CXX_NS.LoggerInstancePtr.operator ->,LoggerPtr LOG4CXX_NS.LoggerInstancePtr.operator -> (),main\include\log4cxx\loggerinstance.hpp,"const LoggerPtr& operator->() const noexcept
	{
		return m_logger;
	}",67.0,70.0,2.0,2.0,4.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,LoggerPtr
297,6835,configure,1,BasicConfigurator.configure,void BasicConfigurator.configure (LayoutPtr),main\cpp\basicconfigurator.cpp,"void BasicConfigurator::configure(const AppenderPtr& appender)
{
	LoggerPtr root = Logger::getRootLogger();
	root->addAppender(appender);
}",40.0,44.0,1.0,1.0,5.0,14,6,14,9,2,2,2,2,0,0,,0,0,2,1,1,void
298,11955,resize,1,CyclicBuffer.resize,void CyclicBuffer.resize (int),main\cpp\cyclicbuffer.cpp,"void CyclicBuffer::resize(int newSize)
{
	if (newSize < 0)
	{
		LogString msg(LOG4CXX_STR(""Negative array size [""));
		Pool p;
		StringHelper::toString(newSize, p, msg);
		msg.append(LOG4CXX_STR(""] not allowed.""));
		throw IllegalArgumentException(msg);
	}

	if (newSize == m_priv->numElems)
	{
		return;    // nothing to do
	}

	LoggingEventList temp(newSize);

	int loopLen = newSize < m_priv->numElems ? newSize : m_priv->numElems;
	int i;

	for (i = 0; i < loopLen; i++)
	{
		temp[i] = m_priv->ea[m_priv->first];
		m_priv->ea[m_priv->first] = 0;

		if (++m_priv->first == m_priv->numElems)
		{
			m_priv->first = 0;
		}
	}

	m_priv->ea = temp;
	m_priv->first = 0;
	m_priv->numElems = loopLen;
	m_priv->maxSize = newSize;

	if (loopLen == newSize)
	{
		m_priv->last = 0;
	}
	else
	{
		m_priv->last = loopLen;
	}
}",127.0,172.0,1.0,1.0,46.0,39,9,37,8,0,1,6,7,0,1,,0,0,2,1,1,void
299,65205,operator bool,1,LOG4CXX_NS.LoggerInstancePtr.operator bool,ANY LOG4CXX_NS.LoggerInstancePtr.operator bool (),main\include\log4cxx\loggerinstance.hpp,"explicit operator bool() const noexcept
	{
		return !!m_logger;
	}",72.0,75.0,2.0,2.0,4.0,2,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
300,60086,encode,1,Transcoder.encode,"void Transcoder.encode (unsigned int,ANY)",main\cpp\transcoder.cpp,"void Transcoder::encode(const LogString& src, std::string& dst)
{
#if LOG4CXX_CHARSET_UTF8 && LOG4CXX_LOGCHAR_IS_UTF8
	dst.append(src);
#else
	static CharsetEncoderPtr encoder(CharsetEncoder::getDefaultEncoder());
	dst.reserve(dst.size() + src.size());
	LogString::const_iterator iter = src.begin();
#if !LOG4CXX_CHARSET_EBCDIC

	for (;
		iter != src.end() && ((unsigned int) *iter) < 0x80;
		iter++)
	{
		dst.append(1, *iter);
	}

#endif

	if (iter != src.end())
	{
		char buf[BUFSIZE];
		ByteBuffer out(buf, BUFSIZE);

		while (iter != src.end())
		{
			log4cxx_status_t stat = encoder->encode(src, iter, out);
			out.flip();
			dst.append(out.data(), out.limit());
			out.clear();

			if (CharsetEncoder::isError(stat))
			{
				dst.append(1, LOSSCHAR);
				iter++;
			}
		}

		encoder->encode(src, iter, out);
	}

#endif
}",368.0,410.0,1.0,1.0,43.0,2,2,6,4,7,0,1,1,0,0,,0,0,4,2,2,void
301,9918,isTriviallyCopyable,1,CharsetEncoder.isTriviallyCopyable,"bool CharsetEncoder.isTriviallyCopyable (LogString,CharsetEncoderPtr)",main\cpp\charsetencoder.cpp,"bool CharsetEncoder::isTriviallyCopyable(const LogString& src, const CharsetEncoderPtr& enc)
{
	bool result;
#if !LOG4CXX_CHARSET_EBCDIC
	if (dynamic_cast<LocaleCharsetEncoder*>(enc.get()))
	{
		result = src.end() == std::find_if(src.begin(), src.end()
			, [](const logchar& ch) -> bool { return 0x80 <= (unsigned int)ch; });
	}
	else
#endif
		result = !!dynamic_cast<TrivialCharsetEncoder*>(enc.get());
	return result;
}",631.0,644.0,1.0,1.0,14.0,8,4,7,4,1,0,2,2,0,0,,0,0,4,2,2,bool
302,35523,format,1,MDCPatternConverter.format,"void MDCPatternConverter.format (ANY,LogString,ANY)",main\cpp\mdcpatternconverter.cpp,"void MDCPatternConverter::format
	( const spi::LoggingEventPtr& event
	, LogString&                  toAppendTo
	, helpers::Pool&           /* p */
	) const
{
	size_t startIndex = toAppendTo.size();
	if (m_priv->name.empty()) // Full MDC required?
	{
		bool first = true;
		for (auto key : event->getMDCKeySet())
		{
			toAppendTo.append(first ? LOG4CXX_STR(""{"") : LOG4CXX_STR("",""));
			JSONLayout::appendItem(key, toAppendTo);
			toAppendTo.append(LOG4CXX_STR("":""));
			LogString value;
			event->getMDC(key, value);
			JSONLayout::appendItem(value, toAppendTo);
			first = false;
		}
		if (!first)
			toAppendTo.append(LOG4CXX_STR(""}""));
	}
	else
		event->getMDC(m_priv->name, toAppendTo);
	if (!m_priv->style.empty()) // In a quoted context?
	{
		auto quote = m_priv->style.front();
		size_t endIndex;
		while ((endIndex = toAppendTo.find(quote, startIndex)) != toAppendTo.npos)
		{
			toAppendTo.insert(endIndex + 1, 1, quote);
			startIndex = endIndex + 2;
		}
	}
}",48.0,83.0,1.0,1.0,36.0,29,7,33,10,0,2,6,9,0,2,,0,0,6,3,3,void
303,23235,execute,1,GZCompressAction.execute,bool GZCompressAction.execute (ANY),main\cpp\gzcompressaction.cpp,"bool GZCompressAction::execute(LOG4CXX_NS::helpers::Pool& p) const
{
	if (priv->source.exists(p))
	{
		apr_pool_t* aprpool = p.getAPRPool();
		apr_procattr_t* attr;
		apr_status_t stat = apr_procattr_create(&attr, aprpool);

		if (stat != APR_SUCCESS)
		{
			throw IOException(stat);
		}

		stat = apr_procattr_io_set(attr, APR_NO_PIPE, APR_FULL_BLOCK, APR_FULL_BLOCK);

		if (stat != APR_SUCCESS)
		{
			throw IOException(stat);
		}

		stat = apr_procattr_cmdtype_set(attr, APR_PROGRAM_PATH);

		if (stat != APR_SUCCESS)
		{
			throw IOException(stat);
		}

		//
		//   set child process output to destination file
		//
		apr_file_t* child_out;
		apr_int32_t flags = APR_FOPEN_READ | APR_FOPEN_WRITE |
			APR_FOPEN_CREATE | APR_FOPEN_TRUNCATE;
		stat = priv->destination.open(&child_out, flags, APR_OS_DEFAULT, p);

		if (stat != APR_SUCCESS)
		{
			throw IOException(stat);
		}

		stat =  apr_procattr_child_out_set(attr, child_out, NULL);

		if (stat != APR_SUCCESS)
		{
			throw IOException(st...",57.0,174.0,1.0,5.0,118.0,87,15,97,23,0,1,12,23,0,1,,0,0,2,1,1,bool
304,24260,emitNoAppenderWarning,1,Hierarchy.emitNoAppenderWarning,void Hierarchy.emitNoAppenderWarning (Logger*),main\cpp\hierarchy.cpp,"void Hierarchy::emitNoAppenderWarning(const Logger* logger)
{
	bool emitWarning = false;
	{
		std::lock_guard<std::recursive_mutex> lock(m_priv->mutex);
		emitWarning = !m_priv->emittedNoAppenderWarning;
		m_priv->emittedNoAppenderWarning = true;
	}

	// No appender in hierarchy, warn user only once.
	if (emitWarning)
	{
		LogLog::warn(((LogString) LOG4CXX_STR(""No appender could be found for logger (""))
			+ logger->getName() + LOG4CXX_STR("").""));
		LogLog::warn(LOG4CXX_STR(""Please initialize the log4cxx system properly.""));
	}
}",128.0,144.0,1.0,1.0,17.0,17,8,11,5,0,2,2,2,0,2,,0,0,2,1,1,void
305,65225,get,1,LOG4CXX_NS.LoggerInstancePtr.get,Logger LOG4CXX_NS.LoggerInstancePtr.get (),main\include\log4cxx\loggerinstance.hpp,"const Logger* get() const noexcept
	{
		return m_logger.get();
	}",92.0,95.0,2.0,2.0,4.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,Logger
306,66250,strnlen_s,1,strnlen_s,"size_t strnlen_s (char*,size_t)",main\include\log4cxx\private\string_c11.hpp,"static size_t strnlen_s( const char *str, size_t strsz )
{
	size_t result = 0;
	if (!str)
		;
	else while (*str++ != 0 && result < strsz)
		++result;
	return result;
}",31.0,39.0,1.0,1.0,9.0,2,2,3,2,1,0,2,2,0,0,,0,0,4,2,2,size_t
307,716,getLogger,1,com.foo.getLogger,ANY com.foo.getLogger (QString),examples\cpp\com\foo\config3.cpp,"auto getLogger(const std::string& name) -> LoggerPtr {
	using namespace log4cxx;
	static struct log4cxx_initializer {
		log4cxx_initializer() {
			SelectConfigurationFile();
		}
		~log4cxx_initializer() {
			LogManager::shutdown();
		}
	} initialiser;
	return name.empty()
		? LogManager::getRootLogger()
		: LogManager::getLogger(name);
}",156.0,169.0,1.0,1.0,14.0,5,2,4,2,0,2,1,1,0,1,,0,0,2,1,1,ANY
308,49869,AbbreviatedMonthNameToken,1,LOG4CXX_NS.helpers.SimpleDateFormatImpl.AbbreviatedMonthNameToken.AbbreviatedMonthNameToken,"ANY LOG4CXX_NS.helpers.SimpleDateFormatImpl.AbbreviatedMonthNameToken.AbbreviatedMonthNameToken (int,ANY*)",main\cpp\simpledateformat.cpp,"AbbreviatedMonthNameToken(int, const std::locale* locale) : names( 12 )
		{
			renderFacet(locale, PatternToken::incrementMonth, 'b', 0x62, ""%b"", names);
		}",298.0,301.0,3.0,3.0,4.0,1,1,3,3,0,2,1,1,0,1,,0,1,4,2,2,ANY
309,33492,error,1,LogLog.error,void LogLog.error (LogString),main\cpp\loglog.cpp,"void LogLog::error(const LogString& msg, const std::exception& e)
{
	auto p = getInstance().m_priv.get();
	if (p && !p->quietMode) // Not deleted by onexit processing?
	{
		std::unique_lock<std::mutex> lock(p->mutex);
		emit(msg);
		emit(e);
	}
}",119.0,128.0,1.0,1.0,10.0,11,7,7,3,39,0,2,2,0,0,,0,0,4,2,2,void
310,16084,parseLayout,1,DOMConfigurator.parseLayout,"LayoutPtr DOMConfigurator.parseLayout (ANY,ANY,apr_xml_elem*)",main\cpp\domconfigurator.cpp,"LayoutPtr DOMConfigurator::parseLayout (
	LOG4CXX_NS::helpers::Pool& p,
	LOG4CXX_NS::helpers::CharsetDecoderPtr& utf8Decoder,
	apr_xml_elem* layout_element)
{
	LogString className(subst(getAttribute(utf8Decoder, layout_element, CLASS_ATTR)));
	LogLog::debug(LOG4CXX_STR(""Parsing layout of class: \"""") + className + LOG4CXX_STR(""\""""));

	try
	{
		ObjectPtr instance = ObjectPtr(Loader::loadClass(className).newInstance());
		LayoutPtr layout = LOG4CXX_NS::cast<Layout>(instance);
		PropertySetter propSetter(layout);

		for (apr_xml_elem* currentElement = layout_element->first_child;
			currentElement;
			currentElement = currentElement->next)
		{
			std::string tagName(currentElement->name);

			if (tagName == PARAM_TAG)
			{
				setParameter(p, utf8Decoder, currentElement, propSetter);
			}
		}

		propSetter.activate(p);
		return layout;
	}
	catch (Exception& oops)
	{
		LogLog::error(LOG4CXX_STR(""Could not create the Layout. Reported error follows.""),
			oops);
		return 0;
	}
}",563.0,598.0,1.0,69.0,36.0,16,7,26,14,0,3,4,7,0,3,,0,1,6,3,3,LayoutPtr
311,13014,DBAppenderPriv,1,DBAppenderPriv.DBAppenderPriv,ANY DBAppenderPriv.DBAppenderPriv (),main\cpp\dbappender.cpp,"DBAppenderPriv() :
        AppenderSkeletonPrivate()
	{
		static bool initialized = false;
		if (!initialized)
		{
			initialized = true;
			apr_status_t stat = apr_dbd_init(m_pool.getAPRPool());
			assert(stat == APR_SUCCESS);
		}
	}",53.0,63.0,5.0,2.0,11.0,6,4,7,4,0,1,2,2,0,0,,0,1,0,0,0,ANY
312,65243,reset,1,LOG4CXX_NS.LoggerInstancePtr.reset,void LOG4CXX_NS.LoggerInstancePtr.reset (),main\include\log4cxx\loggerinstance.hpp,"void reset(const StringType& instanceName)
	{
		reset();
		m_hadConfiguration = !!LogManager::exists(instanceName);
		m_logger = LogManager::getLogger(instanceName);
	}",115.0,120.0,2.0,2.0,6.0,6,5,7,4,0,5,2,2,2,1,,0,4,2,1,1,void
313,45788,parseAdditivityForLogger,1,PropertyConfigurator.parseAdditivityForLogger,"bool PropertyConfigurator.parseAdditivityForLogger (ANY,LoggerPtr,LogString)",main\cpp\propertyconfigurator.cpp,"bool PropertyConfigurator::parseAdditivityForLogger(helpers::Properties& props,
	LoggerPtr& cat, const LogString& loggerName)
{

	static const WideLife<LogString> ADDITIVITY_PREFIX(LOG4CXX_STR(""log4j.additivity.""));



	LogString value(OptionConverter::findAndSubst(ADDITIVITY_PREFIX.value() + loggerName, props));
	LogLog::debug((LogString) LOG4CXX_STR(""Handling "") + ADDITIVITY_PREFIX.value()
		+ loggerName + LOG4CXX_STR(""=["") +  value + LOG4CXX_STR(""]""));

	// touch additivity only if necessary
	if (!value.empty())
	{
		bool additivity = OptionConverter::toBoolean(value, true);
		LogLog::debug(((LogString) LOG4CXX_STR(""Setting additivity for \""""))
			+ loggerName
			+ ((additivity) ?  LOG4CXX_STR(""\"" to true"") :
				LOG4CXX_STR(""\"" to false"")));

		return additivity;
	}

	return true;
}",307.0,332.0,1.0,1.0,26.0,20,6,16,7,0,4,2,2,0,4,,0,1,6,3,3,bool
314,49884,format,1,LOG4CXX_NS.helpers.SimpleDateFormatImpl.AbbreviatedMonthNameToken.format,"void LOG4CXX_NS.helpers.SimpleDateFormatImpl.AbbreviatedMonthNameToken.format (LogString,apr_time_exp_t,Pool)",main\cpp\simpledateformat.cpp,"void format(LogString& s, const apr_time_exp_t& tm, Pool& /* p */ ) const
		{
			s.append( names[tm.tm_mon] );
		}",303.0,306.0,3.0,3.0,4.0,3,2,3,3,0,1,1,1,0,0,,0,1,6,3,3,void
315,1760,x,3,MyStruct.x,,examples\cpp\format-string.cpp,x,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
316,56033,write,1,SystemErrWriter.write,"void SystemErrWriter.write (LogString,Pool)",main\cpp\systemerrwriter.cpp,"void SystemErrWriter::write(const LogString& str)
{
#if LOG4CXX_WCHAR_T_API

	if (isWide())
	{
		LOG4CXX_ENCODE_WCHAR(msg, str);
		fputws(msg.c_str(), stderr);
		return;
	}

#endif
	LOG4CXX_ENCODE_CHAR(msg, str);
	fputs(msg.c_str(), stderr);
}",65.0,79.0,1.0,1.0,15.0,0,0,1,1,1,0,1,1,0,0,,0,0,2,1,1,void
317,1761,operator <<,1,operator <<,"ostream operator << (ANY,MyStruct)",main\include\log4cxx-qt\messagebuffer.hpp,"inline LOG4CXX_NS::helpers::CharMessageBuffer&
operator<<(LOG4CXX_NS::helpers::CharMessageBuffer& mb, const QString& msg)
{
	LOG4CXX_DECODE_QSTRING(tmp, msg);
	return mb << tmp;
}",64.0,69.0,2.0,1.0,6.0,4,2,3,2,0,1,1,1,0,0,,0,1,4,2,2,CharMessageBuffer
318,38626,getDefaultAbbreviator,1,NameAbbreviator.getDefaultAbbreviator,NameAbbreviatorPtr NameAbbreviator.getDefaultAbbreviator (),main\cpp\nameabbreviator.cpp,"NameAbbreviatorPtr NameAbbreviator::getDefaultAbbreviator()
{
	static WideLife<NameAbbreviatorPtr> def = std::make_shared<NOPAbbreviator>();
	return def;
}",362.0,366.0,1.0,1.0,5.0,2,2,3,2,1,0,1,1,0,0,,0,0,0,0,0,NameAbbreviatorPtr
319,55010,append,1,SyslogAppender.append,"void SyslogAppender.append (ANY,Pool)",main\cpp\syslogappender.cpp,"void SyslogAppender::append(const spi::LoggingEventPtr& event, Pool& p)
{
	if  (!isAsSevereAsThreshold(event->getLevel()))
	{
		return;
	}

	LogString msg;
	std::string encoded;
	_priv->layout->format(msg, event, p);

	Transcoder::encode(msg, encoded);

	// Split up the message if it is over maxMessageLength in size.
	// According to RFC 3164, the max message length is 1024, however
	// newer systems(such as syslog-ng) can go up to 8k in size for their
	// messages.  We will append (x/y) at the end of each message
	// to indicate how far through the message we are
	std::vector<LogString> packets;

	if ( msg.size() > _priv->maxMessageLength )
	{
		LogString::iterator start = msg.begin();

		while ( start != msg.end() )
		{
			LogString::iterator end = start + _priv->maxMessageLength - 12;

			if ( end > msg.end() )
			{
				end = msg.end();
			}

			LogString newMsg = LogString( start, end );
			packets.push_back( newMsg );
			start = end;
		}

		int current = 1;

		for ( std::vector...",274.0,373.0,1.0,1.0,100.0,80,14,64,18,0,2,9,14,0,2,,0,0,4,2,2,void
320,20196,newInstance,1,FileDatePatternConverter.newInstance,PatternConverterPtr FileDatePatternConverter.newInstance (ANY),main\cpp\filedatepatternconverter.cpp,"PatternConverterPtr FileDatePatternConverter::newInstance(
	const std::vector<LogString>& options)
{
	if (options.size() == 0)
	{
		std::vector<LogString> altOptions;
		altOptions.push_back(LOG4CXX_STR(""yyyy-MM-dd""));
		return DatePatternConverter::newInstance(altOptions);
	}

	return DatePatternConverter::newInstance(options);
}",27.0,38.0,1.0,1.0,12.0,8,4,9,5,0,2,2,2,0,2,,0,0,2,1,1,PatternConverterPtr
321,46820,setProperty,1,PropertySetter.setProperty,"void PropertySetter.setProperty (LogString,LogString,Pool)",main\cpp\propertysetter.cpp,"void PropertySetter::setProperty(const LogString& option,
	const LogString& value,
	Pool&)
{
	if (value.empty())
	{
		return;
	}

	if (obj != 0 && obj->instanceof(OptionHandler::getStaticClass()))
	{
		LogLog::debug(LOG4CXX_STR(""Setting option name=["") +
			option + LOG4CXX_STR(""], value=["") + value + LOG4CXX_STR(""]""));
		OptionHandlerPtr handler = LOG4CXX_NS::cast<OptionHandler>(obj);
		handler->setOption(option, value);
	}
}",86.0,102.0,1.0,1.0,17.0,15,8,14,7,0,1,3,3,0,1,,0,0,6,3,3,void
322,49900,names,3,LOG4CXX_NS.helpers.SimpleDateFormatImpl.AbbreviatedMonthNameToken.names,,main\cpp\simpledateformat.cpp,names,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
323,49902,FullMonthNameToken,1,LOG4CXX_NS.helpers.SimpleDateFormatImpl.FullMonthNameToken.FullMonthNameToken,"ANY LOG4CXX_NS.helpers.SimpleDateFormatImpl.FullMonthNameToken.FullMonthNameToken (int,ANY*)",main\cpp\simpledateformat.cpp,"FullMonthNameToken( int width, const std::locale* locale) : names( 12 )
		{
			renderFacet(locale, PatternToken::incrementMonth, 'B', 0x42, ""%B"", names);
		}",317.0,320.0,3.0,3.0,4.0,1,1,3,3,0,2,1,1,0,1,,0,1,4,2,2,ANY
324,39667,setOption,1,ODBCAppender.setOption,"void ODBCAppender.setOption (LogString,LogString)",main\cpp\odbcappender.cpp,"void ODBCAppender::setOption(const LogString& option, const LogString& value)
{
	if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""BUFFERSIZE""), LOG4CXX_STR(""buffersize"")))
	{
		setBufferSize((size_t)OptionConverter::toInt(value, 1));
	}
	else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""PASSWORD""), LOG4CXX_STR(""password"")))
	{
		setPassword(value);
	}
	else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""SQL""), LOG4CXX_STR(""sql"")))
	{
		setSql(value);
	}
	else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""URL""), LOG4CXX_STR(""url""))
		|| StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""DSN""), LOG4CXX_STR(""dsn""))
		|| StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""CONNECTIONSTRING""), LOG4CXX_STR(""connectionstring""))  )
	{
		setURL(value);
	}
	else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""USER""), LOG4CXX_STR(""user"")))
	{
		setUser(value);
	}
	else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""COLUMNMAPPING""), LOG4CXX_...",174.0,206.0,1.0,2.0,33.0,3,2,4,4,0,2,2,2,1,2,,0,1,4,2,2,void
325,6904,resetConfiguration,1,BasicConfigurator.resetConfiguration,void BasicConfigurator.resetConfiguration (),main\cpp\basicconfigurator.cpp,"void BasicConfigurator::resetConfiguration()
{
	LogManager::resetConfiguration();
}",46.0,49.0,1.0,1.0,4.0,1,1,1,1,0,1,1,1,0,0,,0,0,0,0,0,void
326,13049,m_pool,3,DBAppenderPriv.m_pool,,main\cpp\dbappender.cpp,m_pool,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
327,28408,getError,1,Level.getError,LevelPtr Level.getError (),main\cpp\level.cpp,"LevelPtr Level::getError()
{
	static WideLife<LevelPtr> errorLevel = std::make_shared<Level>(Level::ERROR_INT, LOG4CXX_STR(""ERROR""), 3);
	return errorLevel;
}",45.0,49.0,1.0,1.0,5.0,7,6,5,3,1,0,1,1,0,0,,0,0,0,0,0,LevelPtr
328,49917,format,1,LOG4CXX_NS.helpers.SimpleDateFormatImpl.FullMonthNameToken.format,"void LOG4CXX_NS.helpers.SimpleDateFormatImpl.FullMonthNameToken.format (LogString,apr_time_exp_t,Pool)",main\cpp\simpledateformat.cpp,"void format( LogString& s, const apr_time_exp_t& tm, Pool& /* p */ ) const
		{
			s.append( names[tm.tm_mon] );
		}",322.0,325.0,3.0,3.0,4.0,3,2,3,3,0,1,1,1,0,0,,0,1,6,3,3,void
329,13064,getFormatSpecifiers,1,getFormatSpecifiers,PatternMap getFormatSpecifiers (),main\cpp\odbcappender.cpp,"static PatternMap getFormatSpecifiers()
{
	PatternMap specs;
	if (specs.empty())
	{
		RULES_PUT(""logger"", LoggerPatternConverter);
		RULES_PUT(""class"", ClassNamePatternConverter);
		RULES_PUT(""time"", DatePatternConverter);
		RULES_PUT(""shortfilename"", ShortFileLocationPatternConverter);
		RULES_PUT(""fullfilename"", FileLocationPatternConverter);
		RULES_PUT(""location"", FullLocationPatternConverter);
		RULES_PUT(""line"", LineLocationPatternConverter);
		RULES_PUT(""message"", MessagePatternConverter);
		RULES_PUT(""method"", MethodLocationPatternConverter);
		RULES_PUT(""level"", LevelPatternConverter);
		RULES_PUT(""thread"", ThreadPatternConverter);
		RULES_PUT(""threadname"", ThreadUsernamePatternConverter);
		RULES_PUT(""mdc"", MDCPatternConverter);
		RULES_PUT(""ndc"", NDCPatternConverter);
	}
	return specs;
}",151.0,172.0,1.0,2.0,22.0,40,1,41,14,3,0,2,2,0,0,,0,0,0,0,0,PatternMap
330,49933,names,3,LOG4CXX_NS.helpers.SimpleDateFormatImpl.FullMonthNameToken.names,,main\cpp\simpledateformat.cpp,names,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
331,38672,getAbbreviator,1,NamePatternConverter.getAbbreviator,NameAbbreviatorPtr NamePatternConverter.getAbbreviator (ANY),main\cpp\namepatternconverter.cpp,"NameAbbreviatorPtr NamePatternConverter::getAbbreviator(
	const std::vector<LogString>& options)
{
	if (options.size() > 0)
	{
		return NameAbbreviator::getAbbreviator(options[0]);
	}

	return NameAbbreviator::getDefaultAbbreviator();
}",53.0,62.0,1.0,1.0,10.0,5,3,4,2,0,2,2,2,0,1,,0,0,2,1,1,NameAbbreviatorPtr
332,61202,checkEntryConditions,1,WriterAppender.checkEntryConditions,bool WriterAppender.checkEntryConditions (),main\cpp\writerappender.cpp,"bool WriterAppender::checkEntryConditions() const
{
	static bool warnedClosed = false;
	static bool warnedNoWriter = false;
	static bool warnedNoLayout = false;

	if (_priv->closed)
	{
		if (!warnedClosed)
		{
			LogLog::warn(LOG4CXX_STR(""Not allowed to write to a closed appender.""));
			warnedClosed = true;
		}

		return false;
	}

	if (_priv->writer == 0)
	{
		if (!warnedNoWriter)
		{
			_priv->errorHandler->error(
				LogString(LOG4CXX_STR(""No output stream or file set for the appender named ["")) +
				_priv->name + LOG4CXX_STR(""].""));
			warnedNoWriter = true;
		}

		return false;
	}

	if (_priv->layout == 0)
	{
		if (!warnedNoLayout)
		{
			_priv->errorHandler->error(
				LogString(LOG4CXX_STR(""No layout set for the appender named ["")) +
				_priv->name + LOG4CXX_STR(""].""));
			warnedNoLayout = true;
		}
		return false;
	}

	return true;
}",108.0,151.0,1.0,5.0,44.0,39,7,17,5,0,1,7,10,0,1,,0,0,0,0,0,bool
333,40729,findAndSubst,1,OptionConverter.findAndSubst,"LogString OptionConverter.findAndSubst (LogString,Properties)",main\cpp\optionconverter.cpp,"LogString OptionConverter::findAndSubst(const LogString& key, Properties& props)
{
	LogString value(props.getProperty(key));

	if (value.empty())
	{
		return value;
	}

	try
	{
		return substVars(value, props);
	}
	catch (IllegalArgumentException& e)
	{
		LogLog::error(((LogString) LOG4CXX_STR(""Bad option value [""))
			+ value + LOG4CXX_STR(""].""), e);
		return value;
	}
}",192.0,211.0,1.0,1.0,20.0,6,3,10,5,9,1,3,3,0,1,,0,0,4,2,2,LogString
334,54052,setOption,1,StringMatchFilter.setOption,"void StringMatchFilter.setOption (LogString,LogString)",main\cpp\stringmatchfilter.cpp,"void StringMatchFilter::setOption(const LogString& option,
	const LogString& value)
{

	if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""STRINGTOMATCH""), LOG4CXX_STR(""stringtomatch"")))
	{
		priv->stringToMatch = value;
	}
	else if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""ACCEPTONMATCH""), LOG4CXX_STR(""acceptonmatch"")))
	{
		priv->acceptOnMatch = OptionConverter::toBoolean(value, priv->acceptOnMatch);
	}
}",51.0,65.0,1.0,2.0,15.0,5,4,4,4,0,1,2,2,1,1,,0,1,4,2,2,void
335,25380,create,1,Hierarchy.create,HierarchyPtr Hierarchy.create (),main\cpp\hierarchy.cpp,"HierarchyPtr Hierarchy::create()
{
	HierarchyPtr ret(new Hierarchy);
	return ret;
}",475.0,479.0,1.0,1.0,5.0,1,1,2,2,1,0,1,1,0,0,,0,0,0,0,0,HierarchyPtr
336,48932,activateOptions,1,RollingPolicyBase.activateOptions,void RollingPolicyBase.activateOptions (ANY),main\cpp\rollingpolicybase.cpp,"void RollingPolicyBase::activateOptions(LOG4CXX_NS::helpers::Pool& /* pool */)
{
	if (m_priv->fileNamePatternStr.length() > 0)
	{
		parseFileNamePattern();
	}
	else
	{
		LogString msg(LOG4CXX_STR(""The FileNamePattern option must be set before using FixedWindowRollingPolicy.""));
		LogString ref1(LOG4CXX_STR(""See also http://logging.apache.org/log4j/codes.html#tbr_fnp_not_set""));
		LogLog::warn(msg);
		LogLog::warn(ref1);
		throw IllegalStateException();
	}
}",50.0,64.0,1.0,1.0,15.0,3,3,1,1,1,0,2,2,0,0,,0,0,2,1,1,void
337,50985,setOption,1,SizeBasedTriggeringPolicy.setOption,"void SizeBasedTriggeringPolicy.setOption (LogString,LogString)",main\cpp\sizebasedtriggeringpolicy.cpp,"void SizeBasedTriggeringPolicy::setOption(const LogString& option, const LogString& value)
{
	if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""MAXFILESIZE""),
			LOG4CXX_STR(""maxfilesize"")))
	{
		maxFileSize = OptionConverter::toFileSize(value, 10 * 1024 * 1024);
	}
}",55.0,63.0,1.0,1.0,9.0,5,3,5,5,0,2,2,2,1,2,,0,2,4,2,2,void
338,45872,parseLogger,1,PropertyConfigurator.parseLogger,"void PropertyConfigurator.parseLogger (ANY,LoggerPtr,LogString,LogString,LogString,bool)",main\cpp\propertyconfigurator.cpp,"void PropertyConfigurator::parseLogger(
	helpers::Properties& props, LoggerPtr& logger, const LogString& /* optionKey */,
	const LogString& loggerName, const LogString& value, bool additivity)
{
	LogLog::debug(((LogString) LOG4CXX_STR(""Parsing for [""))
		+ loggerName
		+ LOG4CXX_STR(""] with value=["")
		+ value + LOG4CXX_STR(""].""));

	// We must skip over ',' but not white space
	StringTokenizer st(value, LOG4CXX_STR("",""));

	// If value is not in the form "", appender.."" or """", then we should set
	// the level of the logger.
	if (!(value.find(LOG4CXX_STR("","")) == 0 || value.empty()))
	{
		// just to be on the safe side...
		if (!st.hasMoreTokens())
		{
			return;
		}

		LogString levelStr = st.nextToken();
		LogLog::debug((LogString) LOG4CXX_STR(""Level token is ["")
			+ levelStr +  LOG4CXX_STR(""].""));


		// If the level value is inherited, set logger level value to
		// null. We also check that the user has not specified inherited for the
		// root logger.
		if (StringHelper::equals...",337.0,418.0,1.0,1.0,82.0,42,11,38,15,0,7,9,14,2,7,,0,3,12,6,6,void
339,18224,setLogger,1,FallbackErrorHandler.setLogger,void FallbackErrorHandler.setLogger (LoggerPtr),main\cpp\fallbackerrorhandler.cpp,"void FallbackErrorHandler::setLogger(const LoggerPtr& logger)
{
	LogLog::debug(((LogString) LOG4CXX_STR(""FB: Adding logger [""))
		+ logger->getName() + LOG4CXX_STR(""].""));
	m_priv->loggers.push_back(logger);
}",49.0,54.0,1.0,1.0,6.0,7,4,4,3,0,1,1,1,0,1,,0,0,2,1,1,void
340,37690,subAppend,1,MultiprocessRollingFileAppender.subAppend,"void MultiprocessRollingFileAppender.subAppend (LoggingEventPtr,Pool)",main\cpp\multiprocessrollingfileappender.cpp,"void MultiprocessRollingFileAppender::subAppend(const LoggingEventPtr& event, Pool& p)
{
	// The rollover check must precede actual writing. This is the
	// only correct behavior for time driven triggers.
	if (
		_priv->triggeringPolicy->isTriggeringEvent(
			this, event, getFile(), getFileLength()))
	{
		//
		//   wrap rollover request in try block since
		//    rollover may fail in case read access to directory
		//    is not provided.  However appender should still be in good
		//     condition and the append should still happen.
		try
		{
			_priv->_event = event;
			rolloverInternal(p);
		}
		catch (std::exception& ex)
		{
			LogLog::warn(LOG4CXX_STR(""Exception during rollover attempt.""));
			LogString exmsg;
			LOG4CXX_NS::helpers::Transcoder::decode(ex.what(), exmsg);
			_priv->errorHandler->error(exmsg);
		}
	}

	//do re-check before every write
	//
	apr_finfo_t finfo1, finfo2;
	apr_status_t st1, st2;
	const WriterPtr writer = getWriter();
	const FileOutputStreamPtr fos = LO...",475.0,537.0,1.0,2.0,63.0,52,13,53,23,0,4,7,8,0,4,,0,0,4,2,2,void
341,16187,parseTriggeringPolicy,1,DOMConfigurator.parseTriggeringPolicy,"ObjectPtr DOMConfigurator.parseTriggeringPolicy (ANY,ANY,apr_xml_elem*)",main\cpp\domconfigurator.cpp,"ObjectPtr DOMConfigurator::parseTriggeringPolicy (
	LOG4CXX_NS::helpers::Pool& p,
	LOG4CXX_NS::helpers::CharsetDecoderPtr& utf8Decoder,
	apr_xml_elem* layout_element)
{
	LogString className = subst(getAttribute(utf8Decoder, layout_element, CLASS_ATTR));
	LogLog::debug(LOG4CXX_STR(""Parsing triggering policy of class: \"""") + className + LOG4CXX_STR(""\""""));

	try
	{
		ObjectPtr instance = ObjectPtr(Loader::loadClass(className).newInstance());
		PropertySetter propSetter(instance);

		for (apr_xml_elem* currentElement = layout_element->first_child;
			currentElement;
			currentElement = currentElement->next)
		{
			std::string tagName(currentElement->name);

			if (tagName == PARAM_TAG)
			{
				setParameter(p, utf8Decoder, currentElement, propSetter);
			}
			else if (tagName == FILTER_TAG)
			{
				std::vector<LOG4CXX_NS::spi::FilterPtr> filters;
				parseFilters(p, utf8Decoder, currentElement, filters);
				FilterBasedTriggeringPolicyPtr fbtp = LOG4CXX_NS::cast<FilterBasedTriggeringP...",603.0,653.0,1.0,71.0,51.0,13,5,23,11,0,3,4,7,0,3,,0,1,6,3,3,ObjectPtr
342,28477,getDebug,1,Level.getDebug,LevelPtr Level.getDebug (),main\cpp\level.cpp,"LevelPtr Level::getDebug()
{
	static WideLife<LevelPtr> debugLevel = std::make_shared<Level>(Level::DEBUG_INT, LOG4CXX_STR(""DEBUG""), 7);
	return debugLevel;
}",63.0,67.0,1.0,1.0,5.0,7,6,5,3,6,0,1,1,0,0,,0,0,0,0,0,LevelPtr
343,33598,warn,1,LogLog.warn,void LogLog.warn (LogString),main\cpp\loglog.cpp,"void LogLog::warn(const LogString& msg, const std::exception& e)
{
	auto p = getInstance().m_priv.get();
	if (p && !p->quietMode) // Not deleted by onexit processing?
	{
		std::unique_lock<std::mutex> lock(p->mutex);
		emit(msg);
		emit(e);
	}
}",148.0,157.0,1.0,1.0,10.0,11,7,7,3,35,0,2,2,0,0,,0,0,4,2,2,void
344,40773,substVars,1,OptionConverter.substVars,"LogString OptionConverter.substVars (LogString,Properties)",main\cpp\optionconverter.cpp,"LogString OptionConverter::substVars(const LogString& val, Properties& props)
{
	LogString sbuf;
	const logchar delimStartArray[] = { 0x24, 0x7B, 0 };
	const LogString delimStart(delimStartArray);
	const logchar delimStop = 0x7D; // '}';
	const size_t DELIM_START_LEN = 2;
	const size_t DELIM_STOP_LEN = 1;

	size_t i = 0;

	while (true)
	{
		size_t j = val.find(delimStart, i);

		if (j == val.npos)
		{
			// no more variables
			if (i == 0)
			{
				// this is a simple string
				return val;
			}
			else
			{
				// add the tail string which contails no variables and return the result.
				sbuf.append(val.substr(i, val.length() - i));
				return sbuf;
			}
		}
		else
		{
			sbuf.append(val.substr(i, j - i));
			size_t k = val.find(delimStop, j);

			if (k == val.npos)
			{
				LogString msg(1, (logchar) 0x22 /* '\""' */);
				msg.append(val);
				msg.append(LOG4CXX_STR(""\"" has no closing brace. Opening brace at position ""));
				Pool p;
				StringHelper::toString(j, p, msg);
				msg.a...",213.0,286.0,1.0,1.0,74.0,11,4,14,8,1,0,4,7,0,0,,0,0,4,2,2,LogString
345,8006,millisecondFormat,1,CachedDateFormat.millisecondFormat,"void CachedDateFormat.millisecondFormat (int,LogString,int)",main\cpp\cacheddateformat.cpp,"void CachedDateFormat::millisecondFormat(int millis,
	LogString& buf,
	int offset)
{
	buf[offset] = digits[millis / 100];
	buf[offset + 1] = digits[(millis / 10) % 10];
	buf[offset + 2] = digits[millis  % 10];
}",318.0,325.0,1.0,1.0,8.0,15,5,12,4,0,3,1,1,0,0,,0,3,6,3,3,void
346,9032,encode,1,LOG4CXX_NS.helpers.USASCIICharsetEncoder.encode,"log4cxx_status_t LOG4CXX_NS.helpers.USASCIICharsetEncoder.encode (LogString,ANY,ByteBuffer)",main\cpp\charsetencoder.cpp,"virtual log4cxx_status_t encode(const LogString& in,
			LogString::const_iterator& iter,
			ByteBuffer& out)
		{
			log4cxx_status_t stat = APR_SUCCESS;

			if (iter != in.end())
			{
				while (out.remaining() > 0 && iter != in.end())
				{
					LogString::const_iterator prev(iter);
					unsigned int sv = Transcoder::decode(in, iter);

					if (sv <= 0x7F)
					{
						out.put((char) sv);
					}
					else
					{
						iter = prev;
						stat = APR_BADARG;
						break;
					}
				}
			}

			return stat;
		}",225.0,252.0,3.0,3.0,28.0,13,7,16,7,0,1,4,7,0,1,,0,1,6,3,3,log4cxx_status_t
347,48970,setOption,1,RollingPolicyBase.setOption,"void RollingPolicyBase.setOption (LogString,LogString)",main\cpp\rollingpolicybase.cpp,"void RollingPolicyBase::setOption(const LogString& option, const LogString& value)
{
	if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""FILENAMEPATTERN""),
			LOG4CXX_STR(""filenamepattern"")))
	{
		m_priv->fileNamePatternStr = value;
	}else if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""CREATEINTERMEDIATEDIRECTORIES""),
			LOG4CXX_STR(""createintermediatedirectories"")))
	{
		m_priv->createIntermediateDirectories = OptionConverter::toBoolean(value, false);
	}
}",67.0,80.0,1.0,1.0,14.0,3,3,4,4,0,1,2,2,1,1,,0,1,4,2,2,void
348,50013,AbbreviatedDayNameToken,1,LOG4CXX_NS.helpers.SimpleDateFormatImpl.AbbreviatedDayNameToken.AbbreviatedDayNameToken,"ANY LOG4CXX_NS.helpers.SimpleDateFormatImpl.AbbreviatedDayNameToken.AbbreviatedDayNameToken (int,ANY*)",main\cpp\simpledateformat.cpp,"AbbreviatedDayNameToken( int width, const std::locale* locale) : names( 7 )
		{
			renderFacet(locale, PatternToken::incrementDay, 'a', 0x61, ""%a"", names);
		}",411.0,414.0,3.0,3.0,4.0,1,1,3,3,0,2,1,1,0,1,,0,1,4,2,2,ANY
349,43872,Pool,1,Pool.Pool,ANY Pool.Pool (),main\cpp\pool.cpp,"Pool::Pool(apr_pool_t* p, bool release1) : pool(p), release(release1)
{
	assert(p != NULL);
}",43.0,46.0,1.0,1.0,4.0,5,5,6,4,0,1,2,2,0,0,,0,1,4,2,2,ANY
350,35684,buf,3,anonymous_namespace_1.StringOrStream.buf,,main\cpp\messagebuffer.cpp,buf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
351,35685,stream,3,anonymous_namespace_1.StringOrStream.stream,,main\cpp\messagebuffer.cpp,* stream,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
352,46950,format,1,LOG4CXX_NS.helpers.RelativeTimeDateFormat.format,"void LOG4CXX_NS.helpers.RelativeTimeDateFormat.format (LogString,log4cxx_time_t,Pool)",main\cpp\relativetimedateformat.cpp,"void LOG4CXX_NS::helpers::RelativeTimeDateFormat::format(
	LogString& s,
	log4cxx_time_t date,
	Pool& p) const
{
	int64_t interval = (date - startTime) / int64_t(1000);
	StringHelper::toString(interval, p, s);
}",29.0,36.0,1.0,1.0,8.0,4,4,7,6,0,1,1,1,0,1,,0,0,6,3,3,void
353,38760,clear,1,NDC.clear,void NDC.clear (),main\cpp\ndc.cpp,"void NDC::clear()
{
	ThreadSpecificData* data = ThreadSpecificData::getCurrentData();

	if (data != 0)
	{
		Stack& stack = data->getStack();

		while (!stack.empty())
		{
			stack.pop();
		}

		data->recycle();
	}
}",46.0,61.0,1.0,1.0,16.0,9,5,8,3,0,1,3,4,0,0,,0,1,0,0,0,void
354,35690,~StringOrStream,1,anonymous_namespace_3.StringOrStream.~StringOrStream,ANY anonymous_namespace_3.StringOrStream.~StringOrStream (),main\cpp\messagebuffer.cpp,"~StringOrStream()
	{
#if !LOG4CXX_HAS_THREAD_LOCAL
		delete stream;
#endif
	}",43.0,48.0,2.0,2.0,6.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
355,28523,getAll,1,Level.getAll,LevelPtr Level.getAll (),main\cpp\level.cpp,"LevelPtr Level::getAll()
{
	static WideLife<LevelPtr> allLevel = std::make_shared<Level>(Level::ALL_INT, LOG4CXX_STR(""ALL""), 7);
	return allLevel;
}",76.0,80.0,1.0,1.0,5.0,7,6,5,3,2,0,1,1,0,0,,0,0,0,0,0,LevelPtr
356,50028,format,1,LOG4CXX_NS.helpers.SimpleDateFormatImpl.AbbreviatedDayNameToken.format,"void LOG4CXX_NS.helpers.SimpleDateFormatImpl.AbbreviatedDayNameToken.format (LogString,apr_time_exp_t,Pool)",main\cpp\simpledateformat.cpp,"void format( LogString& s, const apr_time_exp_t& tm, Pool& /* p */ ) const
		{
			s.append( names[tm.tm_wday] );
		}",416.0,419.0,3.0,3.0,4.0,3,2,3,3,0,1,1,1,0,0,,0,1,6,3,3,void
357,36716,releaseFileLock,1,MultiprocessRollingFileAppender.releaseFileLock,void MultiprocessRollingFileAppender.releaseFileLock (apr_file_t*),main\cpp\multiprocessrollingfileappender.cpp,"void MultiprocessRollingFileAppender::releaseFileLock(apr_file_t* lock_file)
{
	if (lock_file)
	{
		apr_status_t stat = apr_file_unlock(lock_file);

		if (stat != APR_SUCCESS)
		{
			LogLog::warn(LOG4CXX_STR(""flock: unlock failed""));
		}

		apr_file_close(lock_file);
		lock_file = NULL;
	}
}",171.0,185.0,1.0,1.0,15.0,4,3,9,5,0,1,3,4,0,1,,0,0,2,1,1,void
358,56174,DEFAULT_PORT,2,main\cpp\telnetappender.cpp.DEFAULT_PORT,,main\cpp\telnetappender.cpp,const int DEFAULT_PORT,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
359,35696,StreamFromBuf,1,anonymous_namespace_4.StringOrStream.StreamFromBuf,basic_ostringstream<T> anonymous_namespace_4.StringOrStream.StreamFromBuf (),main\cpp\messagebuffer.cpp,"std::basic_ostringstream<T>& StreamFromBuf()
	{
		if (!this->stream)
		{
#if LOG4CXX_HAS_THREAD_LOCAL
			const static std::basic_ostringstream<T> initialState;
			thread_local static std::basic_ostringstream<T> sStream;
			this->stream = &sStream;
			this->stream->clear();
			this->stream->precision(initialState.precision());
			this->stream->width(initialState.width());
			this->stream->setf(initialState.flags(), ~initialState.flags());
			this->stream->fill(initialState.fill());
#else
			this->stream = new std::basic_ostringstream<T>();
#endif
			auto index = this->buf.size();
			this->stream->str(std::move(this->buf));
			this->stream->seekp(index);
		}
		return *this->stream;
	}",52.0,73.0,2.0,2.0,22.0,16,6,4,3,0,7,2,2,1,0,,0,7,0,0,0,basic_ostringstream<T>
360,10096,forName,1,Class.forName,Class Class.forName (LogString),main\cpp\class.cpp,"const Class& Class::forName(const LogString& className)
{
	LogString lowerName(StringHelper::toLowerCase(className));
	//
	//  check registry using full class name
	//
	const Class* clazz = getRegistry()[lowerName];

	if (clazz == 0)
	{
		LogString::size_type pos = className.find_last_of(LOG4CXX_STR("".$""));

		if (pos != LogString::npos)
		{
			LogString terminalName(lowerName, pos + 1, LogString::npos);
			clazz = getRegistry()[terminalName];

			if (clazz == 0)
			{
				registerClasses();
				clazz = getRegistry()[lowerName];

				if (clazz == 0)
				{
					clazz = getRegistry()[terminalName];
				}
			}
		}
		else
		{
			registerClasses();
			clazz = getRegistry()[lowerName];
		}
	}

	if (clazz == 0)
	{
		throw ClassNotFoundException(className);
	}

	return *clazz;
}",122.0,163.0,1.0,1.0,42.0,21,8,23,7,1,1,6,12,0,1,,0,0,2,1,1,Class
361,32634,~LoggingEventPrivate,1,LoggingEventPrivate.~LoggingEventPrivate,ANY LoggingEventPrivate.~LoggingEventPrivate (),main\cpp\loggingevent.cpp,"~LoggingEventPrivate()
	{
		delete ndc;
		delete mdcCopy;
		delete properties;
	}",101.0,106.0,2.0,2.0,6.0,3,1,3,3,0,3,1,1,0,0,,0,3,0,0,0,ANY
362,50044,names,3,LOG4CXX_NS.helpers.SimpleDateFormatImpl.AbbreviatedDayNameToken.names,,main\cpp\simpledateformat.cpp,names,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
363,50046,FullDayNameToken,1,LOG4CXX_NS.helpers.SimpleDateFormatImpl.FullDayNameToken.FullDayNameToken,"ANY LOG4CXX_NS.helpers.SimpleDateFormatImpl.FullDayNameToken.FullDayNameToken (int,ANY*)",main\cpp\simpledateformat.cpp,"FullDayNameToken( int width, const std::locale* locale) : names( 7 )
		{
			renderFacet(locale, PatternToken::incrementDay, 'A', 0x41, ""%A"", names);
		}",431.0,434.0,3.0,3.0,4.0,1,1,3,3,0,2,1,1,0,1,,0,1,4,2,2,ANY
364,56191,activateOptions,1,TelnetAppender.activateOptions,void TelnetAppender.activateOptions (Pool),main\cpp\telnetappender.cpp,"void TelnetAppender::activateOptions(Pool& /* p */)
{
	if (_priv->serverSocket == NULL)
	{
		_priv->serverSocket = ServerSocket::create(_priv->port);
		_priv->serverSocket->setSoTimeout(1000);
	}

	_priv->sh = ThreadUtility::instance()->createThread( LOG4CXX_STR(""TelnetAppender""), &TelnetAppender::acceptConnections, this );
}",71.0,80.0,1.0,5.0,10.0,24,6,9,5,0,1,2,2,0,1,,0,1,2,1,1,void
365,28546,Level,1,Level.Level,"ANY Level.Level (int,LogString,int)",main\cpp\level.cpp,"Level::Level(int level1,
	const LogString& name1, int syslogEquivalent1)
	: level(level1), name(name1), syslogEquivalent(syslogEquivalent1)
{
	APRInitializer::initialize();
}",84.0,89.0,1.0,1.0,6.0,1,1,1,1,0,1,1,1,0,0,,0,0,6,3,3,ANY
366,20357,~FileInputStream,1,FileInputStream.~FileInputStream,ANY FileInputStream.~FileInputStream (),main\cpp\fileinputstream.cpp,"FileInputStream::~FileInputStream()
{
	if (m_priv->fileptr != NULL && !APRInitializer::isDestructed)
	{
		apr_file_close(m_priv->fileptr);
	}
}",83.0,89.0,1.0,1.0,7.0,6,5,4,3,0,1,2,2,1,0,,0,1,0,0,0,ANY
367,39814,activateOptions,1,ODBCAppender.activateOptions,void ODBCAppender.activateOptions (ANY),main\cpp\odbcappender.cpp,"void ODBCAppender::activateOptions(LOG4CXX_NS::helpers::Pool&)
{
#if !LOG4CXX_HAVE_ODBC
	LogLog::error(LOG4CXX_STR(""Can not activate ODBCAppender unless compiled with ODBC support.""));
#else
	if (_priv->mappedName.empty())
	{
		LogLog::error(LOG4CXX_STR(""ODBCAppender column mappings not defined, logging events will not be inserted""));
	}
	auto specs = getFormatSpecifiers();
	for (auto& name : _priv->mappedName)
	{
		auto lowerName = StringHelper::toLowerCase(name);
		auto pItem = specs.find(lowerName);
		if (specs.end() == pItem)
		{
			if (lowerName.size() < 5
			 || lowerName.substr(0, 4) != LOG4CXX_STR(""mdc{""))
				LogLog::error(name + LOG4CXX_STR("" is not a supported ColumnMapping value""));
			else // A single MDC entry
			{
				auto index = lowerName.find(0x7D /* '}' */, 4);
				auto len = (lowerName.npos == index ? lowerName.size() : index) - 4;
				ODBCAppenderPriv::DataBinding paramData{ 0, 0, 0, 0, 0 };
				paramData.converter = std::make_shared<MDCPatternConverter>(lowerNa...",215.0,254.0,1.0,1.0,40.0,1,1,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
368,32646,ndc,3,LoggingEventPrivate.ndc,,main\cpp\loggingevent.cpp,* ndc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
369,42887,ESCAPE_CHAR,2,main\cpp\patternparser.cpp.ESCAPE_CHAR,,main\cpp\patternparser.cpp,const logchar ESCAPE_CHAR,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
370,33673,emit,1,LogLog.emit,void LogLog.emit (LogString),main\cpp\loglog.cpp,"void LogLog::emit(const std::exception& ex)
{
	LogString out(LOG4CXX_STR(""log4cxx: ""));
	const char* raw = ex.what();

	if (raw != 0)
	{
		Transcoder::decode(raw, out);
	}
	else
	{
		out.append(LOG4CXX_STR(""std::exception::what() == null""));
	}

	out.append(1, (logchar) 0x0A);

	SystemErrWriter::write(out);
}",169.0,186.0,1.0,1.0,18.0,4,2,5,3,0,1,1,1,0,1,,0,0,2,1,1,void
371,32648,properties,3,LoggingEventPrivate.properties,,main\cpp\loggingevent.cpp,* properties,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
372,49033,parseFileNamePattern,1,RollingPolicyBase.parseFileNamePattern,void RollingPolicyBase.parseFileNamePattern (),main\cpp\rollingpolicybase.cpp,"void RollingPolicyBase::parseFileNamePattern()
{
	m_priv->patternConverters.erase(m_priv->patternConverters.begin(), m_priv->patternConverters.end());
	m_priv->patternFields.erase(m_priv->patternFields.begin(), m_priv->patternFields.end());
	PatternParser::parse(m_priv->fileNamePatternStr,
		m_priv->patternConverters,
		m_priv->patternFields,
		getFormatSpecifiers());
}",96.0,104.0,1.0,1.0,9.0,16,2,10,2,0,2,1,1,0,1,,0,1,0,0,0,void
373,32647,mdcCopy,3,LoggingEventPrivate.mdcCopy,,main\cpp\loggingevent.cpp,* mdcCopy,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
374,50061,format,1,LOG4CXX_NS.helpers.SimpleDateFormatImpl.FullDayNameToken.format,"void LOG4CXX_NS.helpers.SimpleDateFormatImpl.FullDayNameToken.format (LogString,apr_time_exp_t,Pool)",main\cpp\simpledateformat.cpp,"void format( LogString& s, const apr_time_exp_t& tm, Pool& /* p */ ) const
		{
			s.append( names[tm.tm_wday] );
		}",436.0,439.0,3.0,3.0,4.0,3,2,3,3,0,1,1,1,0,0,,0,1,6,3,3,void
375,28557,toLevelLS,1,Level.toLevelLS,LevelPtr Level.toLevelLS (LogString),main\cpp\level.cpp,"LevelPtr Level::toLevelLS(const LogString& sArg, const LevelPtr& defaultLevel)
{
	const LogString trimmed(StringHelper::trim(sArg));
	const size_t len = trimmed.length();

	if (len == 4)
	{
		if (StringHelper::equalsIgnoreCase(trimmed, LOG4CXX_STR(""INFO""), LOG4CXX_STR(""info"")))
		{
			return getInfo();
		}

		if (StringHelper::equalsIgnoreCase(trimmed, LOG4CXX_STR(""WARN""), LOG4CXX_STR(""warn"")))
		{
			return getWarn();
		}
	}
	else
	{
		if (len == 5)
		{
			if (StringHelper::equalsIgnoreCase(trimmed, LOG4CXX_STR(""DEBUG""), LOG4CXX_STR(""debug"")))
			{
				return getDebug();
			}

			if (StringHelper::equalsIgnoreCase(trimmed, LOG4CXX_STR(""TRACE""), LOG4CXX_STR(""trace"")))
			{
				return getTrace();
			}

			if (StringHelper::equalsIgnoreCase(trimmed, LOG4CXX_STR(""ERROR""), LOG4CXX_STR(""error"")))
			{
				return getError();
			}

			if (StringHelper::equalsIgnoreCase(trimmed, LOG4CXX_STR(""FATAL""), LOG4CXX_STR(""fatal"")))
			{
				return getFatal();
			}
		}
		else
		{
			if (len == 3)
			...",215.0,274.0,1.0,1.0,60.0,1,1,2,2,2,1,1,1,0,0,,0,0,4,2,2,LevelPtr
376,38798,cloneStack,1,NDC.cloneStack,Stack NDC.cloneStack (),main\cpp\ndc.cpp,"NDC::Stack* NDC::cloneStack()
{
	ThreadSpecificData* data = ThreadSpecificData::getCurrentData();

	if (data != 0)
	{
		Stack& stack = data->getStack();

		if (!stack.empty())
		{
			return new Stack(stack);
		}
	}

	return new Stack();
}",63.0,78.0,1.0,1.0,16.0,9,6,9,4,0,1,3,4,0,0,,0,1,0,0,0,Stack
377,51085,isTriggeringEvent,1,DefaultEvaluator.isTriggeringEvent,bool DefaultEvaluator.isTriggeringEvent (ANY),main\cpp\smtpappender.cpp,"bool DefaultEvaluator::isTriggeringEvent(const spi::LoggingEventPtr& event)
{
	return event->getLevel()->isGreaterOrEqual(Level::getError());
}",422.0,425.0,1.0,1.0,4.0,3,2,2,2,0,1,1,1,0,0,,0,0,2,1,1,bool
378,27537,appendItem,1,JSONLayout.appendItem,"void JSONLayout.appendItem (LogString,LogString)",main\cpp\jsonlayout.cpp,"void JSONLayout::appendItem(const LogString& input, LogString& buf)
{
	/* add leading quote */
	buf.push_back(0x22);

	logchar specialChars[] =
	{
		0x08,   /* \b backspace         */
		0x09,   /* \t tab               */
		0x0a,   /* \n newline           */
		0x0c,   /* \f form feed         */
		0x0d,   /* \r carriage return   */
		0x22,   /* \"" double quote      */
		0x5c,   /* \\ backslash         */
		0x00    /* terminating NULL for C-strings */
	};

	size_t start = 0;
	size_t found = input.find_first_of(specialChars, start);

	while (found != LogString::npos)
	{
		if (found > start)
		{
			buf.append(input, start, found - start);
		}

		switch (input[found])
		{
			case 0x08:
				/* \b backspace */
				buf.push_back(0x5c);
				buf.push_back('b');
				break;

			case 0x09:
				/* \t tab */
				buf.push_back(0x5c);
				buf.push_back('t');
				break;

			case 0x0a:
				/* \n newline */
				buf.push_back(0x5c);
				buf.push_back('n');
				break;

			case 0x0c:
				/* \f form feed */...",216.0,311.0,1.0,1.0,96.0,40,9,51,6,2,0,14,9,0,0,,0,0,4,2,2,void
379,65107,~LevelChange,1,LOG4CXX_NS.LevelChange.~LevelChange,ANY LOG4CXX_NS.LevelChange.~LevelChange (),main\include\log4cxx\levelchange.hpp,"~LevelChange()
	{
		m_otherCategory->setLevel(m_savedLevel);
	}",71.0,74.0,2.0,2.0,4.0,1,1,2,2,0,2,1,1,0,0,,0,2,0,0,0,ANY
380,19347,setOption,1,FileAppender.setOption,"void FileAppender.setOption (LogString,LogString)",main\cpp\fileappender.cpp,"void FileAppender::setOption(const LogString& option,
	const LogString& value)
{
	if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""FILE""), LOG4CXX_STR(""file""))
		|| StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""FILENAME""), LOG4CXX_STR(""filename"")))
	{
		std::lock_guard<std::recursive_mutex> lock(_priv->mutex);
		_priv->fileName = stripDuplicateBackslashes(value);
	}
	else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""APPEND""), LOG4CXX_STR(""append"")))
	{
		std::lock_guard<std::recursive_mutex> lock(_priv->mutex);
		_priv->fileAppend = OptionConverter::toBoolean(value, true);
	}
	else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""BUFFEREDIO""), LOG4CXX_STR(""bufferedio"")))
	{
		std::lock_guard<std::recursive_mutex> lock(_priv->mutex);
		_priv->bufferedIO = OptionConverter::toBoolean(value, false);
	}
	else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""IMMEDIATEFLUSH""), LOG4CXX_STR(""immediateflush"")))
	{
		std::lock_guard<std::recursive_mutex> l...",114.0,147.0,1.0,45.0,34.0,14,7,9,5,0,2,2,2,2,2,,0,2,4,2,2,void
381,32659,getStartTime,1,LoggingEvent.getStartTime,log4cxx_time_t LoggingEvent.getStartTime (),main\cpp\loggingevent.cpp,"log4cxx_time_t LoggingEvent::getStartTime()
{
	return LOG4CXX_NS::helpers::APRInitializer::initialize();
}",174.0,177.0,1.0,1.0,4.0,3,1,3,3,1,1,1,1,0,0,,0,0,0,0,0,log4cxx_time_t
382,26520,getAllByName,1,InetAddress.getAllByName,vector<InetAddressPtr> InetAddress.getAllByName (LogString),main\cpp\inetaddress.cpp,"std::vector<InetAddressPtr> InetAddress::getAllByName(const LogString& host)
{
	LOG4CXX_ENCODE_CHAR(encodedHost, host);

	// retrieve information about the given host
	Pool addrPool;

	apr_sockaddr_t* address = 0;
	apr_status_t status =
		apr_sockaddr_info_get(&address, encodedHost.c_str(),
			APR_INET, 0, 0, addrPool.getAPRPool());

	if (status != APR_SUCCESS)
	{
		LogString msg(LOG4CXX_STR(""Cannot get information about host: ""));
		msg.append(host);
		LogLog::error(msg);
		throw UnknownHostException(msg);
	}

	std::vector<InetAddressPtr> result;
	apr_sockaddr_t* currentAddr = address;

	while (currentAddr != NULL)
	{
		// retrieve the IP address of this InetAddress.
		LogString ipAddrString;
		char* ipAddr;
		status = apr_sockaddr_ip_get(&ipAddr, currentAddr);

		if (status == APR_SUCCESS)
		{
			std::string ip(ipAddr);
			Transcoder::decode(ip, ipAddrString);
		}

		// retrieve the host name of this InetAddress.
		LogString hostNameString;
		char* hostName;
		status = apr_getname...",65.0,117.0,1.0,1.0,53.0,30,11,48,21,0,3,5,7,0,3,,0,0,2,1,1,vector<InetAddressPtr>
383,59289,decodeUTF8,1,Transcoder.decodeUTF8,"void Transcoder.decodeUTF8 (ANY,LogString)",main\cpp\transcoder.cpp,"void Transcoder::decodeUTF8(const std::string& src, LogString& dst)
{
	std::string::const_iterator iter = src.begin();

	while (iter != src.end())
	{
		unsigned int sv = decode(src, iter);

		if (sv != 0xFFFF)
		{
			encode(sv, dst);
		}
		else
		{
			dst.append(1, LOSSCHAR);
			iter++;
		}
	}
}",43.0,61.0,1.0,1.0,19.0,6,3,10,4,1,0,3,4,0,0,,0,0,4,2,2,void
384,9116,encode,1,LOG4CXX_NS.helpers.ISOLatinCharsetEncoder.encode,"log4cxx_status_t LOG4CXX_NS.helpers.ISOLatinCharsetEncoder.encode (LogString,ANY,ByteBuffer)",main\cpp\charsetencoder.cpp,"virtual log4cxx_status_t encode(const LogString& in,
			LogString::const_iterator& iter,
			ByteBuffer& out)
		{
			log4cxx_status_t stat = APR_SUCCESS;

			if (iter != in.end())
			{
				while (out.remaining() > 0 && iter != in.end())
				{
					LogString::const_iterator prev(iter);
					unsigned int sv = Transcoder::decode(in, iter);

					if (sv <= 0xFF)
					{
						out.put((char) sv);
					}
					else
					{
						iter = prev;
						stat = APR_BADARG;
						break;
					}
				}
			}

			return stat;
		}",269.0,296.0,3.0,3.0,28.0,13,7,16,7,0,1,4,7,0,1,,0,1,6,3,3,log4cxx_status_t
385,50077,names,3,LOG4CXX_NS.helpers.SimpleDateFormatImpl.FullDayNameToken.names,,main\cpp\simpledateformat.cpp,names,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
386,28575,toLevel,1,Level.toLevel,LevelPtr Level.toLevel (int),main\cpp\level.cpp,"LevelPtr Level::toLevel(const std::string& sArg, const LevelPtr& defaultLevel)
{
	LOG4CXX_DECODE_CHAR(s, sArg);
	return toLevelLS(s, defaultLevel);
}",146.0,150.0,1.0,1.0,5.0,1,1,2,2,0,1,1,1,0,0,,0,0,4,2,2,LevelPtr
387,47008,format,1,RelativeTimePatternConverter.format,"void RelativeTimePatternConverter.format (LoggingEventPtr,LogString,Pool)",main\cpp\relativetimepatternconverter.cpp,"void RelativeTimePatternConverter::format(
	const LoggingEventPtr& event,
	LogString& toAppendTo,
	Pool& p) const
{
	log4cxx_time_t delta = (event->getTimeStamp() - LoggingEvent::getStartTime()) / 1000;
	StringHelper::toString(delta, p, toAppendTo);
}",44.0,51.0,1.0,1.0,8.0,6,5,7,6,0,2,1,1,0,1,,0,1,6,3,3,void
388,35746,BufFromStream,1,anonymous_namespace_5.StringOrStream.BufFromStream,basic_string<T> anonymous_namespace_5.StringOrStream.BufFromStream (),main\cpp\messagebuffer.cpp,"std::basic_string<T>& BufFromStream()
	{
		if (this->stream)
		{
			this->buf = std::move(*this->stream).str();
			this->stream->seekp(0);
			this->stream->str(std::basic_string<T>());
			this->stream->clear();
		}
		return this->buf;
	}",77.0,87.0,2.0,2.0,11.0,15,4,2,1,0,7,2,2,1,0,,0,7,0,0,0,basic_string<T>
389,36772,rolloverInternal,1,MultiprocessRollingFileAppender.rolloverInternal,bool MultiprocessRollingFileAppender.rolloverInternal (Pool),main\cpp\multiprocessrollingfileappender.cpp,"bool MultiprocessRollingFileAppender::rolloverInternal(Pool& p)
{
	//
	//   can't roll without a policy
	//
	if (_priv->rollingPolicy != NULL)
	{

		{
			LogString fileName(getFile());
			RollingPolicyBasePtr basePolicy = LOG4CXX_NS::cast<RollingPolicyBase>(_priv->rollingPolicy);
			apr_time_t n = apr_time_now();
			ObjectPtr obj = std::make_shared<Date>(n);
			LogString fileNamePattern;

			if (basePolicy)
			{
				if (basePolicy->getPatternConverterList().size())
				{
					(*(basePolicy->getPatternConverterList().begin()))->format(obj, fileNamePattern, p);
					fileName = std::string(fileNamePattern);
				}
			}

			bool bAlreadyRolled = true;
			char szDirName[MAX_FILE_LEN] = {'\0'};
			char szBaseName[MAX_FILE_LEN] = {'\0'};
			char szUid[MAX_FILE_LEN] = {'\0'};
			memcpy(szDirName, fileName.c_str(), fileName.size() > MAX_FILE_LEN ? MAX_FILE_LEN : fileName.size());
			memcpy(szBaseName, fileName.c_str(), fileName.size() > MAX_FILE_LEN ? MAX_FILE_LEN : fileName.size());
			apr_u...",208.0,455.0,1.0,5.0,248.0,154,19,147,47,0,6,19,69,0,6,,0,0,2,1,1,bool
390,50085,getField,1,LOG4CXX_NS.helpers.SimpleDateFormatImpl.MilitaryHourToken.getField,int LOG4CXX_NS.helpers.SimpleDateFormatImpl.MilitaryHourToken.getField (apr_time_exp_t),main\cpp\simpledateformat.cpp,"int getField( const apr_time_exp_t& tm ) const
		{
			return tm.tm_hour + offset;
		}",455.0,458.0,3.0,3.0,4.0,2,2,2,2,0,1,1,1,0,0,,0,1,2,1,1,int
391,34725,refresh_stream_state,1,logstream.refresh_stream_state,void logstream.refresh_stream_state (),main\cpp\logstream.cpp,"void logstream::refresh_stream_state()
{
	if (stream != 0)
	{
		int ch;

		if (logstream_base::set_stream_state(*stream, ch))
		{
			stream->fill(ch);
		}
	}
}",328.0,339.0,1.0,1.0,12.0,4,4,6,3,0,1,3,4,1,1,,0,1,0,0,0,void
392,14251,setConfigurationFileName,1,DefaultConfigurator.setConfigurationFileName,void DefaultConfigurator.setConfigurationFileName (LogString),main\cpp\defaultconfigurator.cpp,"void DefaultConfigurator::setConfigurationFileName(const LogString& path)
{
	DefaultConfiguratorPath = path;
}",38.0,41.0,1.0,1.0,4.0,1,1,2,2,2,0,1,1,0,0,,0,0,2,1,1,void
393,50096,offset,3,LOG4CXX_NS.helpers.SimpleDateFormatImpl.MilitaryHourToken.offset,,main\cpp\simpledateformat.cpp,offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
394,39857,close,1,ODBCAppender.close,void ODBCAppender.close (),main\cpp\odbcappender.cpp,"void ODBCAppender::close()
{
	if (_priv->closed)
	{
		return;
	}

	Pool p;

	try
	{
		flushBuffer(p);
	}
	catch (SQLException& e)
	{
		_priv->errorHandler->error(LOG4CXX_STR(""Error closing connection""),
			e, ErrorCode::GENERIC_FAILURE);
	}

#if LOG4CXX_HAVE_ODBC

	if (_priv->connection != SQL_NULL_HDBC)
	{
		SQLDisconnect(_priv->connection);
		SQLFreeHandle(SQL_HANDLE_DBC, _priv->connection);
	}

	if (_priv->env != SQL_NULL_HENV)
	{
		SQLFreeHandle(SQL_HANDLE_ENV, _priv->env);
	}

#endif
	_priv->closed = true;
}",375.0,409.0,1.0,5.0,35.0,12,4,6,4,0,1,3,3,0,0,,0,1,0,0,0,void
395,14259,setConfigurationWatchSeconds,1,DefaultConfigurator.setConfigurationWatchSeconds,void DefaultConfigurator.setConfigurationWatchSeconds (int),main\cpp\defaultconfigurator.cpp,"void DefaultConfigurator::setConfigurationWatchSeconds(int seconds)
{
	DefaultConfiguratorWatchSeconds = seconds;
}",44.0,47.0,1.0,1.0,4.0,1,1,2,2,2,0,1,1,0,0,,0,0,2,1,1,void
396,38835,inherit,1,NDC.inherit,void NDC.inherit (ANY*),main\cpp\ndc.cpp,"void NDC::inherit(NDC::Stack* stack)
{
	if (stack != NULL)
	{
		ThreadSpecificData::inherit(*stack);
		delete stack;
	}
}",80.0,87.0,1.0,1.0,8.0,4,4,5,3,0,1,2,2,0,1,,0,0,2,1,1,void
397,50104,getField,1,LOG4CXX_NS.helpers.SimpleDateFormatImpl.HourToken.getField,int LOG4CXX_NS.helpers.SimpleDateFormatImpl.HourToken.getField (apr_time_exp_t),main\cpp\simpledateformat.cpp,"int getField( const apr_time_exp_t& tm ) const
		{
			return ( ( tm.tm_hour + 12 - offset ) % 12 ) + offset;
		}",473.0,476.0,3.0,3.0,4.0,5,4,3,2,0,2,1,1,0,0,,0,2,2,1,1,int
398,29627,format,1,LineLocationPatternConverter.format,"void LineLocationPatternConverter.format (LoggingEventPtr,LogString,Pool)",main\cpp\linelocationpatternconverter.cpp,"void LineLocationPatternConverter::format(
	const LoggingEventPtr& event,
	LogString& toAppendTo,
	Pool& p) const
{
	StringHelper::toString(
		event->getLocationInformation().getLineNumber(),
		p, toAppendTo);
}",44.0,52.0,1.0,1.0,9.0,3,2,4,4,0,1,1,1,0,1,,0,0,6,3,3,void
399,14267,MillisecondsPerSecond,2,main\cpp\defaultconfigurator.cpp.MillisecondsPerSecond,,main\cpp\defaultconfigurator.cpp,static const int MillisecondsPerSecond,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
400,14271,configure,1,DefaultConfigurator.configure,void DefaultConfigurator.configure (LoggerRepositoryPtr),main\cpp\defaultconfigurator.cpp,"void DefaultConfigurator::configure(LoggerRepositoryPtr repository)
{
	repository->setConfigured(true);
	const LogString configuratorClassName(getConfiguratorClass());

	LogString configurationFileName = DefaultConfiguratorPath;
	if (configurationFileName.empty())
		configurationFileName = getConfigurationFileName();
	Pool pool;
	File configuration;

	if (configurationFileName.empty())
	{
		LogString names[4] =
			{ LOG4CXX_STR(""log4cxx.xml"")
			, LOG4CXX_STR(""log4cxx.properties"")
			, LOG4CXX_STR(""log4j.xml"")
			, LOG4CXX_STR(""log4j.properties"")
			};

		for (int i = 0; i < 4; i++)
		{
			File candidate(names[i]);

			LogString debugMsg = LOG4CXX_STR(""Checking file "");
			debugMsg.append(names[i]);
			LogLog::debug(debugMsg);
			if (candidate.exists(pool))
			{
				configuration = candidate;
				break;
			}
		}
	}
	else
	{
		configuration.setPath(configurationFileName);
	}

	if (configuration.exists(pool))
	{
		LogString msg(LOG4CXX_STR(""Using configuration file [""));
		msg += conf...",51.0,122.0,1.0,1.0,72.0,25,9,36,16,0,4,7,9,0,3,,0,1,2,1,1,void
401,32704,getNDC,1,LoggingEvent.getNDC,bool LoggingEvent.getNDC (LogString),main\cpp\loggingevent.cpp,"bool LoggingEvent::getNDC(LogString& dest) const
{
	if (m_priv->ndcLookupRequired)
	{
		m_priv->ndcLookupRequired = false;
		LogString val;

		if (NDC::get(val))
		{
			m_priv->ndc = new LogString(val);
		}
	}

	if (m_priv->ndc)
	{
		dest.append(*m_priv->ndc);
		return true;
	}

	return false;
}",209.0,229.0,1.0,1.0,21.0,11,5,10,5,0,1,4,5,1,1,,0,1,2,1,1,bool
402,52164,setEvaluatorClass,1,SMTPAppender.setEvaluatorClass,void SMTPAppender.setEvaluatorClass (LogString),main\cpp\smtpappender.cpp,"void SMTPAppender::setEvaluatorClass(const LogString& value)
{
	ObjectPtr obj = ObjectPtr(Loader::loadClass(value).newInstance());
	_priv->evaluator = LOG4CXX_NS::cast<TriggeringEventEvaluator>(obj);
}",820.0,824.0,1.0,1.0,5.0,10,6,7,6,0,1,1,1,0,1,,0,1,2,1,1,void
403,38853,get,1,NDC.get,bool NDC.get (LogString),main\cpp\ndc.cpp,"bool NDC::get(LogString& dest)
{
	ThreadSpecificData* data = ThreadSpecificData::getCurrentData();

	if (data != 0)
	{
		Stack& stack = data->getStack();

		if (!stack.empty())
		{
			dest.append(getFullMessage(stack.top()));
			return true;
		}

		data->recycle();
	}

	return false;
}",90.0,108.0,1.0,1.0,19.0,10,5,9,4,1,1,3,4,0,0,,0,1,2,1,1,bool
404,59334,encodeUTF8,1,Transcoder.encodeUTF8,"void Transcoder.encodeUTF8 (LogString,ANY)",main\cpp\transcoder.cpp,"size_t Transcoder::encodeUTF8(unsigned int ch, char* dst)
{
	if (ch < 0x80)
	{
		dst[0] = (char) ch;
		return 1;
	}
	else if (ch < 0x800)
	{
		dst[0] = (char) (0xC0 + (ch >> 6));
		dst[1] = (char) (0x80 + (ch & 0x3F));
		return 2;
	}
	else if (ch < 0x10000)
	{
		dst[0] = (char) (0xE0 + (ch >> 12));
		dst[1] = (char) (0x80 + ((ch >> 6) & 0x3F));
		dst[2] = (char) (0x80 + (ch & 0x3F));
		return 3;
	}
	else if (ch <= 0x10FFFF)
	{
		dst[0] = (char) (0xF0 + (ch >> 18));
		dst[1] = (char) (0x80 + ((ch >> 12) & 0x3F));
		dst[2] = (char) (0x80 + ((ch >> 6) & 0x3F));
		dst[3] = (char) (0x80 + (ch & 0x3F));
		return 4;
	}
	else
	{
		//
		//  output UTF-8 encoding of 0xFFFF
		//
		dst[0] = (char) 0xEF;
		dst[1] = (char) 0xBF;
		dst[2] = (char) 0xBF;
		return 3;
	}
}",107.0,145.0,1.0,1.0,39.0,6,3,10,4,1,0,3,4,0,0,,0,0,4,2,2,size_t
405,50121,offset,3,LOG4CXX_NS.helpers.SimpleDateFormatImpl.HourToken.offset,,main\cpp\simpledateformat.cpp,offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
406,17354,subst,1,DOMConfigurator.subst,LogString DOMConfigurator.subst (LogString),main\cpp\domconfigurator.cpp,"LogString DOMConfigurator::subst(const LogString& value)
{
	try
	{
		return OptionConverter::substVars(value, m_priv->props);
	}
	catch (IllegalArgumentException& e)
	{
		LogLog::warn(LOG4CXX_STR(""Could not perform variable substitution.""), e);
		return value;
	}
}",1103.0,1114.0,1.0,1.0,12.0,3,2,6,5,0,2,2,2,0,2,,0,0,2,1,1,LogString
407,10189,registerClass,1,Class.registerClass,bool Class.registerClass (Class),main\cpp\class.cpp,"bool Class::registerClass(const Class& newClass)
{
	getRegistry()[StringHelper::toLowerCase(newClass.getName())] = &newClass;
	return true;
}",165.0,169.0,1.0,1.0,5.0,5,4,3,2,1,1,1,1,0,1,,0,0,2,1,1,bool
408,47057,getBundle,1,ResourceBundle.getBundle,"ResourceBundlePtr ResourceBundle.getBundle (LogString,Locale)",main\cpp\resourcebundle.cpp,"ResourceBundlePtr ResourceBundle::getBundle(const LogString& baseName,
	const Locale& locale)
{
	LogString bundleName;
	PropertyResourceBundlePtr resourceBundle, previous;

	std::vector<LogString> bundlesNames;

	if (!locale.getVariant().empty())
	{
		bundlesNames.push_back(baseName + LOG4CXX_STR(""_"") +
			locale.getLanguage() + LOG4CXX_STR(""_"") +
			locale.getCountry() + LOG4CXX_STR(""_"") +
			locale.getVariant());
	}

	if (!locale.getCountry().empty())
	{
		bundlesNames.push_back(baseName + LOG4CXX_STR(""_"") +
			locale.getLanguage() + LOG4CXX_STR(""_"") +
			locale.getCountry());
	}

	if (!locale.getLanguage().empty())
	{
		bundlesNames.push_back(baseName + LOG4CXX_STR(""_"") +
			locale.getLanguage());
	}

	bundlesNames.push_back(baseName);

	for (std::vector<LogString>::iterator it = bundlesNames.begin();
		it != bundlesNames.end(); it++)
	{

		bundleName = *it;

		PropertyResourceBundlePtr current;

		// Try loading a class which implements ResourceBundle
		try
		{
			const Class& c...",30.0,124.0,1.0,1.0,95.0,66,11,53,16,0,2,12,18,0,2,,0,2,4,2,2,ResourceBundlePtr
409,56274,setOption,1,TelnetAppender.setOption,"void TelnetAppender.setOption (LogString,LogString)",main\cpp\telnetappender.cpp,"void TelnetAppender::setOption(const LogString& option,
	const LogString& value)
{
	if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""PORT""), LOG4CXX_STR(""port"")))
	{
		setPort(OptionConverter::toInt(value, DEFAULT_PORT));
	}
	else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""ENCODING""), LOG4CXX_STR(""encoding"")))
	{
		setEncoding(value);
	}
	else
	{
		AppenderSkeleton::setOption(option, value);
	}
}",82.0,97.0,1.0,1.0,16.0,2,1,5,5,0,3,2,2,1,2,,0,2,4,2,2,void
410,33749,<lambda>0,1,[]() -> ObjectPtr { LoggerRepositoryPtr hierarchy = Hierarchy.create(); return std.make_shared<DefaultRepositorySelector>(hierarchy); }.<lambda>0,ObjectPtr []() -> ObjectPtr { LoggerRepositoryPtr hierarchy = Hierarchy.create(); return std.make_shared<DefaultRepositorySelector>(hierarchy); }.<lambda>0 (),main\cpp\logmanager.cpp,"[]() -> ObjectPtr
		{
			LoggerRepositoryPtr hierarchy = Hierarchy::create();
			return std::make_shared<DefaultRepositorySelector>(hierarchy);
		}",49.0,53.0,73.0,3.0,5.0,5,4,5,4,0,1,1,1,0,0,,0,1,0,0,0,ObjectPtr
411,16345,parseRollingPolicy,1,DOMConfigurator.parseRollingPolicy,"RollingPolicyPtr DOMConfigurator.parseRollingPolicy (ANY,ANY,apr_xml_elem*)",main\cpp\domconfigurator.cpp,"RollingPolicyPtr DOMConfigurator::parseRollingPolicy (
	LOG4CXX_NS::helpers::Pool& p,
	LOG4CXX_NS::helpers::CharsetDecoderPtr& utf8Decoder,
	apr_xml_elem* layout_element)
{
	LogString className = subst(getAttribute(utf8Decoder, layout_element, CLASS_ATTR));
	LogLog::debug(LOG4CXX_STR(""Parsing rolling policy of class: \"""") + className + LOG4CXX_STR(""\""""));

	try
	{
		ObjectPtr instance = ObjectPtr(Loader::loadClass(className).newInstance());
		RollingPolicyPtr layout = LOG4CXX_NS::cast<RollingPolicy>(instance);
		PropertySetter propSetter(layout);

		for (apr_xml_elem* currentElement = layout_element->first_child;
			currentElement;
			currentElement = currentElement->next)
		{
			std::string tagName(currentElement->name);

			if (tagName == PARAM_TAG)
			{
				setParameter(p, utf8Decoder, currentElement, propSetter);
			}
		}

		propSetter.activate(p);
		return layout;
	}
	catch (Exception& oops)
	{
		LogLog::error(LOG4CXX_STR(""Could not create the RollingPolicy. Reported error foll...",658.0,693.0,1.0,71.0,36.0,17,7,27,14,0,3,4,7,0,3,,0,1,6,3,3,RollingPolicyPtr
412,61404,closeWriter,1,WriterAppender.closeWriter,void WriterAppender.closeWriter (),main\cpp\writerappender.cpp,"void WriterAppender::closeWriter()
{
	if (_priv->writer != NULL)
	{
		try
		{
			// before closing we have to output out layout's footer
			//
			//   Using the object's pool since this is a one-shot operation
			//    and pool is likely to be reclaimed soon when appender is destructed.
			//
			writeFooter(_priv->pool);
			_priv->writer->close(_priv->pool);
			_priv->writer = 0;
		}
		catch (IOException& e)
		{
			LogLog::error(LogString(LOG4CXX_STR(""Could not close writer for WriterAppender named "")) + _priv->name, e);
		}
	}

}",180.0,201.0,1.0,5.0,22.0,23,6,9,4,0,1,3,4,0,1,,0,0,0,0,0,void
413,17380,getAttribute,1,DOMConfigurator.getAttribute,"LogString DOMConfigurator.getAttribute (ANY,apr_xml_elem*,ANY)",main\cpp\domconfigurator.cpp,"LogString DOMConfigurator::getAttribute(
	LOG4CXX_NS::helpers::CharsetDecoderPtr& utf8Decoder,
	apr_xml_elem* element,
	const std::string& attrName)
{
	LogString attrValue;

	for (apr_xml_attr* attr = element->attr;
		attr;
		attr = attr->next)
	{
		if (attrName == attr->name)
		{
			ByteBuffer buf((char*) attr->value, strnlen_s(attr->value, MAX_ATTRIBUTE_NAME_LEN));
			utf8Decoder->decode(buf, attrValue);
		}
	}

	return attrValue;
}",1117.0,1136.0,1.0,62.0,20.0,8,4,11,6,0,1,3,4,0,1,,0,0,6,3,3,LogString
414,11237,parseColor,1,ColorStartPatternConverter.parseColor,"void ColorStartPatternConverter.parseColor (LogString,LogString*)",main\cpp\colorstartpatternconverter.cpp,"void ColorStartPatternConverter::parseColor(const LogString& color, LogString* result){
	LogString lower = StringHelper::toLowerCase(color);
	Pool pool;

	// If the color we are trying to parse is blank, clear our result
	if(StringHelper::trim(color).empty() ||
			StringHelper::equalsIgnoreCase(color,
										   LOG4CXX_STR(""NONE""),
										   LOG4CXX_STR(""none""))){
		result->clear();
		return;
	}

	if( StringHelper::startsWith(lower, LOG4CXX_STR(""\\x1b"")) ){
		if( color[color.size() - 1] != 'm' ){
			// In order for this to be a valid ANSI escape sequence,
			// it must end with an 'm'.  If it does not, reject.
			return;
		}
		// We start with an escape sequence, copy the data over after the escape byte
		result->clear();
		result->append(LOG4CXX_STR(""\x1b""));
		for( size_t x = 4; x < color.size(); x++ ){
			result->push_back(color[x]);
		}
	}else{
		// We do not start with an escape sequence: try to parse color
		// Escape sequence information:
		// https://gist.github.com/fn...",224.0,277.0,1.0,1.0,54.0,19,8,20,5,0,4,5,7,3,4,,0,4,4,2,2,void
415,25574,HTMLLayout,1,HTMLLayout.HTMLLayout,ANY HTMLLayout.HTMLLayout (),main\cpp\htmllayout.cpp,"HTMLLayout::HTMLLayout()
	: m_priv(std::make_unique<HTMLLayoutPrivate>())
{
	m_priv->dateFormat.setTimeZone(TimeZone::getGMT());
	m_priv->expectedPatternLength = getFormattedEventCharacterCount() * 2;
}",56.0,61.0,1.0,1.0,6.0,6,4,3,2,0,1,1,1,0,0,,0,0,0,0,0,ANY
416,18408,setAppender,1,FallbackErrorHandler.setAppender,void FallbackErrorHandler.setAppender (AppenderPtr),main\cpp\fallbackerrorhandler.cpp,"void FallbackErrorHandler::setAppender(const AppenderPtr& primary1)
{
	LogLog::debug(((LogString) LOG4CXX_STR(""FB: Setting primary appender to [""))
		+ primary1->getName() + LOG4CXX_STR(""].""));
	m_priv->primary = primary1;
}",96.0,101.0,1.0,1.0,6.0,7,5,4,3,0,1,1,1,0,1,,0,0,2,1,1,void
417,57322,getCurrentData,1,ThreadSpecificData.getCurrentData,ThreadSpecificData ThreadSpecificData.getCurrentData (),main\cpp\threadspecificdata.cpp,"ThreadSpecificData* ThreadSpecificData::getCurrentData()
{
#if APR_HAS_THREADS
	void* pData = NULL;
	apr_threadkey_private_get(&pData, APRInitializer::getTlsKey());
	return (ThreadSpecificData*) pData;
#elif LOG4CXX_HAS_THREAD_LOCAL
	thread_local ThreadSpecificData data;
	return &data;
#else
	return &getDataNoThreads();
#endif
}",61.0,73.0,1.0,1.0,13.0,1,1,0,0,11,0,1,1,0,0,,0,0,0,0,0,ThreadSpecificData
418,41963,setOption,1,PatternLayout.setOption,"void PatternLayout.setOption (LogString,LogString)",main\cpp\patternlayout.cpp,"void PatternLayout::setOption(const LogString& option, const LogString& value)
{
	if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""CONVERSIONPATTERN""),
			LOG4CXX_STR(""conversionpattern"")))
	{
		m_priv->conversionPattern = OptionConverter::convertSpecialChars(value);
	}else if(StringHelper::equalsIgnoreCase(option,
											LOG4CXX_STR(""ERRORCOLOR""),
											LOG4CXX_STR(""errorcolor""))){
		m_priv->m_errorColor = value;
		LogLog::debug(LOG4CXX_STR(""Setting error color to ""));
		LogLog::debug(value);
	}else if(StringHelper::equalsIgnoreCase(option,
											LOG4CXX_STR(""FATALCOLOR""),
											LOG4CXX_STR(""fatalcolor""))){
		m_priv->m_fatalColor = value;
	}else if(StringHelper::equalsIgnoreCase(option,
											LOG4CXX_STR(""WARNCOLOR""),
											LOG4CXX_STR(""warncolor""))){
		m_priv->m_warnColor = value;
	}else if(StringHelper::equalsIgnoreCase(option,
											LOG4CXX_STR(""INFOCOLOR""),
											LOG4CXX_STR(""infocolor""))){
		m_priv->m_infoColor = value;
	}else i...",141.0,175.0,1.0,1.0,35.0,4,3,5,5,0,2,2,2,1,2,,0,2,4,2,2,void
419,32751,getMDC,1,LoggingEvent.getMDC,"bool LoggingEvent.getMDC (LogString,LogString)",main\cpp\loggingevent.cpp,"bool LoggingEvent::getMDC(const LogString& key, LogString& dest) const
{
	// Note the mdcCopy is used if it exists. Otherwise we use the MDC
	// that is associated with the thread.
	if (m_priv->mdcCopy != 0 && !m_priv->mdcCopy->empty())
	{
		MDC::Map::const_iterator it = m_priv->mdcCopy->find(key);

		if (it != m_priv->mdcCopy->end())
		{
			if (!it->second.empty())
			{
				dest.append(it->second);
				return true;
			}
		}
	}

	return MDC::get(key, dest);

}",231.0,251.0,1.0,1.0,21.0,18,6,13,5,0,1,4,7,0,1,,0,0,4,2,2,bool
420,44020,parse,1,PropertyParser.parse,"void PropertyParser.parse (LogString,Properties)",main\cpp\properties.cpp,"void parse(LogString& in, Properties& properties)
		{
			LogString key, element;
			LexemType lexemType = BEGIN;
			logchar c;
			bool finished = false;

			if (!get(in, c))
			{
				return;
			}

			while (!finished)
			{
				switch (lexemType)
				{
					case BEGIN:
						switch (c)
						{
							case 0x20: // ' '
							case 0x09: // '\t'
							case 0x0A: // '\n'
							case 0x0D: // '\r'
								if (!get(in, c))
								{
									finished = true;
								}

								break;

							case 0x23: // '#'
							case 0x21: // '!'
								lexemType = COMMENT;

								if (!get(in, c))
								{
									finished = true;
								}

								break;

							default:
								lexemType = KEY;
								break;
						}

						break;

					case KEY:
						switch (c)
						{
							case 0x5C: // '\\'
								lexemType = KEY_ESCAPE;

								if (!get(in, c))
								{
									finished = true;
								}

								break;

							case 0x09: // '\t'
							case 0x20: // ' '
							case 0x3A: // ':'
		...",30.0,365.0,3.0,3.0,336.0,92,5,167,18,0,57,75,104,18,18,,0,57,4,2,2,void
421,38901,getDepth,1,NDC.getDepth,int NDC.getDepth (),main\cpp\ndc.cpp,"int NDC::getDepth()
{
	int size = 0;
	ThreadSpecificData* data = ThreadSpecificData::getCurrentData();

	if (data != 0)
	{
		size = (int)data->getStack().size();

		if (size == 0)
		{
			data->recycle();
		}
	}

	return size;
}",110.0,126.0,1.0,1.0,17.0,10,6,9,3,0,1,3,4,0,0,,0,1,0,0,0,int
422,57333,put,1,ThreadSpecificData.put,"void ThreadSpecificData.put (LogString,LogString)",main\cpp\threadspecificdata.cpp,"void ThreadSpecificData::put(const LogString& key, const LogString& val)
{
	ThreadSpecificData* data = getCurrentData();

	if (data == 0)
	{
		data = createCurrentData();
	}

	if (data != 0)
	{
		data->getMap()[key] = val;
	}
}",98.0,111.0,1.0,1.0,14.0,7,5,7,3,1,0,3,3,0,0,,0,0,4,2,2,void
423,24572,getThreshold,1,Hierarchy.getThreshold,LevelPtr Hierarchy.getThreshold (),main\cpp\hierarchy.cpp,"LevelPtr Hierarchy::getThreshold() const
{
	return m_priv->threshold ? m_priv->threshold : Level::getAll();
}",235.0,238.0,1.0,1.0,4.0,4,3,3,2,0,1,1,1,0,0,,0,0,0,0,0,LevelPtr
424,25599,setOption,1,HTMLLayout.setOption,"void HTMLLayout.setOption (LogString,LogString)",main\cpp\htmllayout.cpp,"void HTMLLayout::setOption(const LogString& option,
	const LogString& value)
{

	if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""TITLE""), LOG4CXX_STR(""title"")))
	{
		setTitle(value);
	}
	else if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""LOCATIONINFO""), LOG4CXX_STR(""locationinfo"")))
	{
		setLocationInfo(OptionConverter::toBoolean(value, false));
		m_priv->expectedPatternLength = getFormattedEventCharacterCount() * 2;
	}
}",66.0,81.0,1.0,1.0,16.0,1,1,3,3,0,1,2,2,1,1,,0,1,4,2,2,void
