1475,UNKNOWN,-1,,),43,<empty>,,27,2,CPPASTProblemDeclaration,,<empty>
1476,UNKNOWN,-1,,"BEGIN_LOG4CXX_CAST_MAP()
	LOG4CXX_CAST_ENTRY(NullWriterAppender)
	LOG4CXX_CAST_ENTRY_CHAIN(AppenderSkeleton)
	END_LOG4CXX_CAST_MAP()

	NullWriterAppender(){}",2,<empty>,,28,3,CPPASTProblemDeclaration,,<empty>
1518,UNKNOWN,-1,,),44,<empty>,,57,3,CPPASTProblemDeclaration,,<empty>
2495,UNKNOWN,2,,),32,<empty>,,27,2,CPPASTProblemDeclaration,,<empty>
2607,UNKNOWN,3,,),35,<empty>,,43,3,CPPASTProblemDeclaration,,<empty>
2625,UNKNOWN,1,,AndFilterPrivate *,6,<empty>,,54,1,CPPASTTypeId,,<empty>
2638,UNKNOWN,1,,AndFilterPrivate *,3,<empty>,,56,1,CPPASTTypeId,,<empty>
2650,UNKNOWN,1,,AndFilterPrivate *,3,<empty>,,57,1,CPPASTTypeId,,<empty>
2665,UNKNOWN,1,,AndFilterPrivate *,3,<empty>,,61,1,CPPASTTypeId,,<empty>
2683,UNKNOWN,1,,AndFilterPrivate *,2,<empty>,,68,1,CPPASTTypeId,,<empty>
2705,UNKNOWN,1,,AndFilterPrivate *,14,<empty>,,75,1,CPPASTTypeId,,<empty>
2743,UNKNOWN,1,,AndFilterPrivate *,7,<empty>,,85,1,CPPASTTypeId,,<empty>
2784,UNKNOWN,2,,),48,<empty>,,29,2,CPPASTProblemDeclaration,,<empty>
3236,UNKNOWN,2,,),42,<empty>,,31,2,CPPASTProblemDeclaration,,<empty>
3392,UNKNOWN,1,,LogString,19,<empty>,,102,1,CPPASTTypeId,,<empty>
3675,UNKNOWN,1,,APRDatagramSocketPriv *,19,<empty>,,73,1,CPPASTTypeId,,<empty>
3687,UNKNOWN,1,,APRDatagramSocketPriv *,2,<empty>,,74,1,CPPASTTypeId,,<empty>
3761,UNKNOWN,1,,APRDatagramSocketPriv *,37,<empty>,,100,1,CPPASTTypeId,,<empty>
3769,UNKNOWN,1,,char*,5,<empty>,,101,1,CPPASTTypeId,,<empty>
3842,UNKNOWN,1,,APRDatagramSocketPriv *,29,<empty>,,127,1,CPPASTTypeId,,<empty>
3851,UNKNOWN,1,,char*,5,<empty>,,128,1,CPPASTTypeId,,<empty>
3876,UNKNOWN,1,,APRDatagramSocketPriv *,6,<empty>,,137,1,CPPASTTypeId,,<empty>
3892,UNKNOWN,1,,APRDatagramSocketPriv *,42,<empty>,,139,1,CPPASTTypeId,,<empty>
3911,UNKNOWN,1,,APRDatagramSocketPriv *,3,<empty>,,146,1,CPPASTTypeId,,<empty>
3923,UNKNOWN,1,,APRDatagramSocketPriv *,3,<empty>,,147,1,CPPASTTypeId,,<empty>
3976,UNKNOWN,1,,APRDatagramSocketPriv *,27,<empty>,,168,1,CPPASTTypeId,,<empty>
4059,UNKNOWN,1,,APRDatagramSocketPriv *,30,<empty>,,200,1,CPPASTTypeId,,<empty>
4084,UNKNOWN,1,,APRDatagramSocketPriv *,9,<empty>,,211,1,CPPASTTypeId,,<empty>
4135,UNKNOWN,1,,ThreadSpecificData*,11,<empty>,,54,1,CPPASTTypeId,,<empty>
4487,UNKNOWN,1,,APRServerSocketPriv *,22,<empty>,,41,1,CPPASTTypeId,,<empty>
4502,UNKNOWN,1,,APRServerSocketPriv *,19,<empty>,,42,1,CPPASTTypeId,,<empty>
4524,UNKNOWN,1,,APRServerSocketPriv *,30,<empty>,,49,1,CPPASTTypeId,,<empty>
4556,UNKNOWN,1,,APRServerSocketPriv *,13,<empty>,,60,1,CPPASTTypeId,,<empty>
4578,UNKNOWN,1,,APRServerSocketPriv *,27,<empty>,,68,1,CPPASTTypeId,,<empty>
4600,UNKNOWN,1,,APRServerSocketPriv *,29,<empty>,,76,1,CPPASTTypeId,,<empty>
4632,UNKNOWN,1,,APRServerSocketPriv *,36,<empty>,,85,1,CPPASTTypeId,,<empty>
4644,UNKNOWN,1,,APRServerSocketPriv *,6,<empty>,,87,1,CPPASTTypeId,,<empty>
4660,UNKNOWN,1,,APRServerSocketPriv *,42,<empty>,,89,1,CPPASTTypeId,,<empty>
4679,UNKNOWN,1,,APRServerSocketPriv *,3,<empty>,,96,1,CPPASTTypeId,,<empty>
4703,UNKNOWN,1,,APRServerSocketPriv *,36,<empty>,,106,1,CPPASTTypeId,,<empty>
4715,UNKNOWN,1,,APRServerSocketPriv *,6,<empty>,,108,1,CPPASTTypeId,,<empty>
4736,UNKNOWN,1,,APRServerSocketPriv *,11,<empty>,,114,1,CPPASTTypeId,,<empty>
4768,UNKNOWN,1,,APRServerSocketPriv *,16,<empty>,,118,1,CPPASTTypeId,,<empty>
4788,UNKNOWN,1,,APRServerSocketPriv *,27,<empty>,,122,1,CPPASTTypeId,,<empty>
4846,UNKNOWN,1,,APRServerSocketPriv *,41,<empty>,,143,1,CPPASTTypeId,,<empty>
4939,UNKNOWN,1,,APRSocketPriv *,22,<empty>,,51,1,CPPASTTypeId,,<empty>
4954,UNKNOWN,1,,APRSocketPriv *,19,<empty>,,52,1,CPPASTTypeId,,<empty>
4994,UNKNOWN,1,,APRSocketPriv *,13,<empty>,,65,1,CPPASTTypeId,,<empty>
5016,UNKNOWN,1,,APRSocketPriv *,31,<empty>,,73,1,CPPASTTypeId,,<empty>
5056,UNKNOWN,1,,APRSocketPriv *,3,<empty>,,88,1,CPPASTTypeId,,<empty>
5108,UNKNOWN,1,,APRSocketPriv *,3,<empty>,,105,1,CPPASTTypeId,,<empty>
5135,UNKNOWN,1,,APRSocketPriv *,6,<empty>,,111,1,CPPASTTypeId,,<empty>
5172,UNKNOWN,1,,APRSocketPriv *,41,<empty>,,131,1,CPPASTTypeId,,<empty>
5217,UNKNOWN,1,,APRSocketPriv *,6,<empty>,,149,1,CPPASTTypeId,,<empty>
5233,UNKNOWN,1,,APRSocketPriv *,42,<empty>,,151,1,CPPASTTypeId,,<empty>
5252,UNKNOWN,1,,APRSocketPriv *,3,<empty>,,158,1,CPPASTTypeId,,<empty>
5271,UNKNOWN,1,,AsyncAppenderPriv *,12,<empty>,,273,1,CPPASTTypeId,,<empty>
5294,UNKNOWN,1,,AsyncAppenderPriv *,18,<empty>,,472,1,CPPASTTypeId,,<empty>
5305,UNKNOWN,1,,AsyncAppenderPriv *,41,<empty>,,472,1,CPPASTTypeId,,<empty>
5402,UNKNOWN,6,,),39,<empty>,,174,6,CPPASTProblemDeclaration,,<empty>
5421,UNKNOWN,1,,AsyncAppenderPriv *,2,<empty>,,190,1,CPPASTTypeId,,<empty>
5518,UNKNOWN,1,,AsyncAppenderPriv *,6,<empty>,,225,1,CPPASTTypeId,,<empty>
5532,UNKNOWN,1,,AsyncAppenderPriv *,3,<empty>,,227,1,CPPASTTypeId,,<empty>
5564,UNKNOWN,1,,AsyncAppenderPriv *,36,<empty>,,237,1,CPPASTTypeId,,<empty>
5578,UNKNOWN,1,,AsyncAppenderPriv *,7,<empty>,,238,1,CPPASTTypeId,,<empty>
5591,UNKNOWN,1,,AsyncAppenderPriv *,3,<empty>,,240,1,CPPASTTypeId,,<empty>
5623,UNKNOWN,1,,AsyncAppenderPriv *,25,<empty>,,244,1,CPPASTTypeId,,<empty>
5634,UNKNOWN,1,,size_t,23,<empty>,,246,1,CPPASTTypeId,,<empty>
5639,UNKNOWN,1,,AsyncAppenderPriv *,30,<empty>,,246,1,CPPASTTypeId,,<empty>
5652,UNKNOWN,1,,AsyncAppenderPriv *,4,<empty>,,248,1,CPPASTTypeId,,<empty>
5671,UNKNOWN,1,,AsyncAppenderPriv *,5,<empty>,,252,1,CPPASTTypeId,,<empty>
5690,UNKNOWN,1,,AsyncAppenderPriv *,7,<empty>,,267,1,CPPASTTypeId,,<empty>
5701,UNKNOWN,1,,AsyncAppenderPriv *,8,<empty>,,268,1,CPPASTTypeId,,<empty>
5714,UNKNOWN,1,,AsyncAppenderPriv *,8,<empty>,,269,1,CPPASTTypeId,,<empty>
5732,UNKNOWN,1,,AsyncAppenderPriv *,4,<empty>,,271,1,CPPASTTypeId,,<empty>
5763,UNKNOWN,1,,AsyncAppenderPriv *,32,<empty>,,285,1,CPPASTTypeId,,<empty>
5780,UNKNOWN,1,,AsyncAppenderPriv *,16,<empty>,,287,1,CPPASTTypeId,,<empty>
5797,UNKNOWN,1,,AsyncAppenderPriv *,5,<empty>,,290,1,CPPASTTypeId,,<empty>
5839,UNKNOWN,1,,AsyncAppenderPriv *,36,<empty>,,305,1,CPPASTTypeId,,<empty>
5852,UNKNOWN,1,,AsyncAppenderPriv *,3,<empty>,,306,1,CPPASTTypeId,,<empty>
5865,UNKNOWN,1,,AsyncAppenderPriv *,3,<empty>,,307,1,CPPASTTypeId,,<empty>
5878,UNKNOWN,1,,AsyncAppenderPriv *,3,<empty>,,308,1,CPPASTTypeId,,<empty>
5892,UNKNOWN,1,,AsyncAppenderPriv *,7,<empty>,,311,1,CPPASTTypeId,,<empty>
5906,UNKNOWN,1,,AsyncAppenderPriv *,3,<empty>,,313,1,CPPASTTypeId,,<empty>
5923,UNKNOWN,1,,AsyncAppenderPriv *,31,<empty>,,317,1,CPPASTTypeId,,<empty>
5964,UNKNOWN,1,,AsyncAppenderPriv *,9,<empty>,,330,1,CPPASTTypeId,,<empty>
5983,UNKNOWN,1,,AsyncAppenderPriv *,9,<empty>,,335,1,CPPASTTypeId,,<empty>
6003,UNKNOWN,1,,AsyncAppenderPriv *,9,<empty>,,340,1,CPPASTTypeId,,<empty>
6027,UNKNOWN,1,,AsyncAppenderPriv *,2,<empty>,,350,1,CPPASTTypeId,,<empty>
6045,UNKNOWN,1,,AsyncAppenderPriv *,2,<empty>,,355,1,CPPASTTypeId,,<empty>
6064,UNKNOWN,1,,AsyncAppenderPriv *,2,<empty>,,360,1,CPPASTTypeId,,<empty>
6081,UNKNOWN,1,,AsyncAppenderPriv *,9,<empty>,,365,1,CPPASTTypeId,,<empty>
6097,UNKNOWN,1,,AsyncAppenderPriv *,2,<empty>,,370,1,CPPASTTypeId,,<empty>
6131,UNKNOWN,1,,AsyncAppenderPriv *,35,<empty>,,381,1,CPPASTTypeId,,<empty>
6142,UNKNOWN,1,,AsyncAppenderPriv *,2,<empty>,,382,1,CPPASTTypeId,,<empty>
6160,UNKNOWN,1,,AsyncAppenderPriv *,2,<empty>,,383,1,CPPASTTypeId,,<empty>
6176,UNKNOWN,1,,AsyncAppenderPriv *,9,<empty>,,388,1,CPPASTTypeId,,<empty>
6200,UNKNOWN,1,,AsyncAppenderPriv *,35,<empty>,,393,1,CPPASTTypeId,,<empty>
6211,UNKNOWN,1,,AsyncAppenderPriv *,2,<empty>,,394,1,CPPASTTypeId,,<empty>
6224,UNKNOWN,1,,AsyncAppenderPriv *,2,<empty>,,395,1,CPPASTTypeId,,<empty>
6240,UNKNOWN,1,,AsyncAppenderPriv *,9,<empty>,,400,1,CPPASTTypeId,,<empty>
6425,UNKNOWN,1,,AsyncAppenderPriv *,38,<empty>,,470,1,CPPASTTypeId,,<empty>
6435,UNKNOWN,1,,AsyncAppenderPriv *,4,<empty>,,471,1,CPPASTTypeId,,<empty>
6451,UNKNOWN,1,,AsyncAppenderPriv *,16,<empty>,,474,1,CPPASTTypeId,,<empty>
6468,UNKNOWN,1,,AsyncAppenderPriv *,48,<empty>,,476,1,CPPASTTypeId,,<empty>
6483,UNKNOWN,1,,AsyncAppenderPriv *,18,<empty>,,477,1,CPPASTTypeId,,<empty>
6510,UNKNOWN,1,,AsyncAppenderPriv *,44,<empty>,,483,1,CPPASTTypeId,,<empty>
6525,UNKNOWN,1,,AsyncAppenderPriv *,20,<empty>,,484,1,CPPASTTypeId,,<empty>
6552,UNKNOWN,1,,AsyncAppenderPriv *,4,<empty>,,490,1,CPPASTTypeId,,<empty>
6565,UNKNOWN,1,,AsyncAppenderPriv *,4,<empty>,,491,1,CPPASTTypeId,,<empty>
6578,UNKNOWN,1,,AsyncAppenderPriv *,4,<empty>,,492,1,CPPASTTypeId,,<empty>
6611,UNKNOWN,1,,AsyncAppenderPriv *,5,<empty>,,501,1,CPPASTTypeId,,<empty>
6631,UNKNOWN,1,,AsyncAppenderPriv *,6,<empty>,,507,1,CPPASTTypeId,,<empty>
6657,UNKNOWN,1,,AsyncAppenderPriv *,6,<empty>,,515,1,CPPASTTypeId,,<empty>
6934,UNKNOWN,3,,),40,<empty>,,36,3,CPPASTProblemDeclaration,,<empty>
7113,UNKNOWN,3,,),46,<empty>,,39,3,CPPASTProblemDeclaration,,<empty>
7199,UNKNOWN,1,,int,11,<empty>,,70,1,CPPASTTypeId,,<empty>
7221,UNKNOWN,3,,),47,<empty>,,32,3,CPPASTProblemDeclaration,,<empty>
7637,UNKNOWN,1,,int,16,<empty>,,165,1,CPPASTTypeId,,<empty>
7891,UNKNOWN,1,,int,24,<empty>,,274,1,CPPASTTypeId,,<empty>
8233,UNKNOWN,2,,),40,<empty>,,38,2,CPPASTProblemDeclaration,,<empty>
8265,UNKNOWN,1,,const logchar*,27,<empty>,,251,1,CPPASTTypeId,,<empty>
8448,UNKNOWN,1,,unsigned char*,33,<empty>,,345,1,CPPASTTypeId,,<empty>
8530,UNKNOWN,1,,unsigned char*,33,<empty>,,393,1,CPPASTTypeId,,<empty>
8580,UNKNOWN,1,,const unsigned char*,24,<empty>,,412,1,CPPASTTypeId,,<empty>
8653,UNKNOWN,1,,unsigned int,28,<empty>,,444,1,CPPASTTypeId,,<empty>
8707,UNKNOWN,1,,std::size_t,21,<empty>,,460,1,CPPASTTypeId,,<empty>
8719,UNKNOWN,1,,std::size_t,21,<empty>,,465,1,CPPASTTypeId,,<empty>
8730,UNKNOWN,1,,unsigned int,36,<empty>,,469,1,CPPASTTypeId,,<empty>
8990,UNKNOWN,1,,unsigned int,54,<empty>,,638,1,CPPASTTypeId,,<empty>
9024,UNKNOWN,2,,),40,<empty>,,41,2,CPPASTProblemDeclaration,,<empty>
9086,UNKNOWN,1,,char,16,<empty>,,240,1,CPPASTTypeId,,<empty>
9170,UNKNOWN,1,,char,16,<empty>,,284,1,CPPASTTypeId,,<empty>
9254,UNKNOWN,1,,const char*,7,<empty>,,328,1,CPPASTTypeId,,<empty>
9532,UNKNOWN,1,,unsigned int,28,<empty>,,471,1,CPPASTTypeId,,<empty>
9589,UNKNOWN,1,,std::size_t,21,<empty>,,483,1,CPPASTTypeId,,<empty>
9925,UNKNOWN,1,,LocaleCharsetEncoder*,19,<empty>,,635,1,CPPASTTypeId,,<empty>
9958,UNKNOWN,1,,TrivialCharsetEncoder*,27,<empty>,,642,1,CPPASTTypeId,,<empty>
10057,UNKNOWN,2,,LOG4CXX_EXPORT,1,<empty>,,87,2,CPPASTProblemDeclaration,,<empty>
10349,UNKNOWN,2,,),51,<empty>,,28,2,CPPASTProblemDeclaration,,<empty>
10397,UNKNOWN,1,,int,23,<empty>,,54,1,CPPASTTypeId,,<empty>
10455,UNKNOWN,2,,),50,<empty>,,29,2,CPPASTProblemDeclaration,,<empty>
10505,UNKNOWN,2,,),52,<empty>,,30,2,CPPASTProblemDeclaration,,<empty>
11013,UNKNOWN,1,,ColorPatternConverterPrivate *,22,<empty>,,172,1,CPPASTTypeId,,<empty>
11034,UNKNOWN,1,,ColorPatternConverterPrivate *,22,<empty>,,176,1,CPPASTTypeId,,<empty>
11055,UNKNOWN,1,,ColorPatternConverterPrivate *,22,<empty>,,180,1,CPPASTTypeId,,<empty>
11076,UNKNOWN,1,,ColorPatternConverterPrivate *,22,<empty>,,184,1,CPPASTTypeId,,<empty>
11097,UNKNOWN,1,,ColorPatternConverterPrivate *,22,<empty>,,188,1,CPPASTTypeId,,<empty>
11118,UNKNOWN,1,,ColorPatternConverterPrivate *,22,<empty>,,192,1,CPPASTTypeId,,<empty>
11139,UNKNOWN,1,,ColorPatternConverterPrivate *,22,<empty>,,201,1,CPPASTTypeId,,<empty>
11157,UNKNOWN,1,,ColorPatternConverterPrivate *,22,<empty>,,205,1,CPPASTTypeId,,<empty>
11175,UNKNOWN,1,,ColorPatternConverterPrivate *,22,<empty>,,209,1,CPPASTTypeId,,<empty>
11193,UNKNOWN,1,,ColorPatternConverterPrivate *,22,<empty>,,213,1,CPPASTTypeId,,<empty>
11211,UNKNOWN,1,,ColorPatternConverterPrivate *,22,<empty>,,217,1,CPPASTTypeId,,<empty>
11229,UNKNOWN,1,,ColorPatternConverterPrivate *,22,<empty>,,221,1,CPPASTTypeId,,<empty>
11449,UNKNOWN,2,,),38,<empty>,,26,2,CPPASTProblemDeclaration,,<empty>
11485,UNKNOWN,3,,),41,<empty>,,41,3,CPPASTProblemDeclaration,,<empty>
11576,UNKNOWN,1,,ConsoleAppenderPriv *,3,<empty>,,90,1,CPPASTTypeId,,<empty>
11601,UNKNOWN,1,,ConsoleAppenderPriv *,3,<empty>,,95,1,CPPASTTypeId,,<empty>
11621,UNKNOWN,1,,ConsoleAppenderPriv *,9,<empty>,,105,1,CPPASTTypeId,,<empty>
11639,UNKNOWN,1,,LogString,17,<empty>,,110,1,CPPASTTypeId,,<empty>
11665,UNKNOWN,1,,ConsoleAppenderPriv *,37,<empty>,,117,1,CPPASTTypeId,,<empty>
11696,UNKNOWN,1,,ConsoleAppenderPriv *,42,<empty>,,123,1,CPPASTTypeId,,<empty>
12156,UNKNOWN,3,,),40,<empty>,,63,3,CPPASTProblemDeclaration,,<empty>
12313,UNKNOWN,2,,),40,<empty>,,27,2,CPPASTProblemDeclaration,,<empty>
12461,UNKNOWN,2,,),30,<empty>,,29,2,CPPASTProblemDeclaration,,<empty>
12570,UNKNOWN,2,,),36,<empty>,,26,2,CPPASTProblemDeclaration,,<empty>
12639,UNKNOWN,3,,),46,<empty>,,50,3,CPPASTProblemDeclaration,,<empty>
12784,UNKNOWN,1,,LogString,21,<empty>,,103,1,CPPASTTypeId,,<empty>
12872,UNKNOWN,1,,DatePatternConverterPrivate *,2,<empty>,,144,1,CPPASTTypeId,,<empty>
12945,UNKNOWN,1,,DatePatternConverterPrivate *,2,<empty>,,182,1,CPPASTTypeId,,<empty>
13012,UNKNOWN,2,,),36,<empty>,,47,2,CPPASTProblemDeclaration,,<empty>
13315,UNKNOWN,1,,DBAppenderPriv *,8,<empty>,,113,1,CPPASTTypeId,,<empty>
13325,UNKNOWN,1,,DBAppenderPriv *,27,<empty>,,113,1,CPPASTTypeId,,<empty>
13337,UNKNOWN,1,,DBAppenderPriv *,23,<empty>,,114,1,CPPASTTypeId,,<empty>
13347,UNKNOWN,1,,DBAppenderPriv *,40,<empty>,,114,1,CPPASTTypeId,,<empty>
13358,UNKNOWN,1,,DBAppenderPriv *,5,<empty>,,116,1,CPPASTTypeId,,<empty>
13370,UNKNOWN,1,,DBAppenderPriv *,5,<empty>,,117,1,CPPASTTypeId,,<empty>
13400,UNKNOWN,1,,DBAppenderPriv *,9,<empty>,,123,1,CPPASTTypeId,,<empty>
13430,UNKNOWN,1,,DBAppenderPriv *,39,<empty>,,127,1,CPPASTTypeId,,<empty>
13458,UNKNOWN,1,,DBAppenderPriv *,39,<empty>,,131,1,CPPASTTypeId,,<empty>
13486,UNKNOWN,1,,DBAppenderPriv *,39,<empty>,,135,1,CPPASTTypeId,,<empty>
13514,UNKNOWN,1,,DBAppenderPriv *,39,<empty>,,139,1,CPPASTTypeId,,<empty>
13543,UNKNOWN,1,,DBAppenderPriv *,44,<empty>,,148,1,CPPASTTypeId,,<empty>
13556,UNKNOWN,1,,DBAppenderPriv *,44,<empty>,,149,1,CPPASTTypeId,,<empty>
13564,UNKNOWN,1,,const apr_dbd_driver_t**,55,<empty>,,150,1,CPPASTTypeId,,<empty>
13570,UNKNOWN,1,,DBAppenderPriv *,82,<empty>,,150,1,CPPASTTypeId,,<empty>
13592,UNKNOWN,1,,DBAppenderPriv *,41,<empty>,,154,1,CPPASTTypeId,,<empty>
13614,UNKNOWN,1,,DBAppenderPriv *,9,<empty>,,157,1,CPPASTTypeId,,<empty>
13630,UNKNOWN,1,,DBAppenderPriv *,25,<empty>,,161,1,CPPASTTypeId,,<empty>
13642,UNKNOWN,1,,DBAppenderPriv *,25,<empty>,,162,1,CPPASTTypeId,,<empty>
13655,UNKNOWN,1,,DBAppenderPriv *,25,<empty>,,163,1,CPPASTTypeId,,<empty>
13667,UNKNOWN,1,,DBAppenderPriv *,26,<empty>,,164,1,CPPASTTypeId,,<empty>
13690,UNKNOWN,1,,DBAppenderPriv *,9,<empty>,,167,1,CPPASTTypeId,,<empty>
13708,UNKNOWN,1,,DBAppenderPriv *,9,<empty>,,171,1,CPPASTTypeId,,<empty>
13721,UNKNOWN,1,,DBAppenderPriv *,28,<empty>,,172,1,CPPASTTypeId,,<empty>
13733,UNKNOWN,1,,DBAppenderPriv *,28,<empty>,,173,1,CPPASTTypeId,,<empty>
13744,UNKNOWN,1,,DBAppenderPriv *,28,<empty>,,174,1,CPPASTTypeId,,<empty>
13756,UNKNOWN,1,,DBAppenderPriv *,28,<empty>,,175,1,CPPASTTypeId,,<empty>
13770,UNKNOWN,1,,DBAppenderPriv *,28,<empty>,,178,1,CPPASTTypeId,,<empty>
13782,UNKNOWN,1,,DBAppenderPriv *,28,<empty>,,179,1,CPPASTTypeId,,<empty>
13793,UNKNOWN,1,,DBAppenderPriv *,28,<empty>,,180,1,CPPASTTypeId,,<empty>
13805,UNKNOWN,1,,DBAppenderPriv *,28,<empty>,,181,1,CPPASTTypeId,,<empty>
13818,UNKNOWN,1,,DBAppenderPriv *,29,<empty>,,183,1,CPPASTTypeId,,<empty>
13841,UNKNOWN,1,,DBAppenderPriv *,42,<empty>,,186,1,CPPASTTypeId,,<empty>
13851,UNKNOWN,1,,DBAppenderPriv *,59,<empty>,,186,1,CPPASTTypeId,,<empty>
13877,UNKNOWN,1,,DBAppenderPriv *,9,<empty>,,190,1,CPPASTTypeId,,<empty>
13895,UNKNOWN,1,,DBAppenderPriv *,23,<empty>,,195,1,CPPASTTypeId,,<empty>
13974,UNKNOWN,1,,DBAppenderPriv *,13,<empty>,,206,1,CPPASTTypeId,,<empty>
14008,UNKNOWN,1,,DBAppenderPriv *,8,<empty>,,217,1,CPPASTTypeId,,<empty>
14020,UNKNOWN,1,,DBAppenderPriv *,13,<empty>,,218,1,CPPASTTypeId,,<empty>
14032,UNKNOWN,1,,DBAppenderPriv *,13,<empty>,,219,1,CPPASTTypeId,,<empty>
14046,UNKNOWN,1,,DBAppenderPriv *,9,<empty>,,220,1,CPPASTTypeId,,<empty>
14061,UNKNOWN,1,,DBAppenderPriv *,27,<empty>,,224,1,CPPASTTypeId,,<empty>
14109,UNKNOWN,1,,DBAppenderPriv *,27,<empty>,,236,1,CPPASTTypeId,,<empty>
14121,UNKNOWN,1,,DBAppenderPriv *,27,<empty>,,237,1,CPPASTTypeId,,<empty>
14132,UNKNOWN,1,,DBAppenderPriv *,27,<empty>,,238,1,CPPASTTypeId,,<empty>
14144,UNKNOWN,1,,DBAppenderPriv *,27,<empty>,,240,1,CPPASTTypeId,,<empty>
14177,UNKNOWN,1,,DBAppenderPriv *,50,<empty>,,245,1,CPPASTTypeId,,<empty>
14187,UNKNOWN,1,,DBAppenderPriv *,67,<empty>,,245,1,CPPASTTypeId,,<empty>
14210,UNKNOWN,1,,DBAppenderPriv *,9,<empty>,,248,1,CPPASTTypeId,,<empty>
14672,UNKNOWN,2,,),46,<empty>,,23,2,CPPASTProblemDeclaration,,<empty>
14820,UNKNOWN,6,,),41,<empty>,,94,6,CPPASTProblemDeclaration,,<empty>
16581,UNKNOWN,1,,Level::LevelClass&,7,<empty>,,742,1,CPPASTTypeId,,<empty>
17411,UNKNOWN,1,,char*,20,<empty>,,1130,1,CPPASTTypeId,,<empty>
18211,UNKNOWN,2,,),46,<empty>,,33,2,CPPASTProblemDeclaration,,<empty>
18234,UNKNOWN,1,,LogString,18,<empty>,,51,1,CPPASTTypeId,,<empty>
18276,UNKNOWN,1,,LogString,18,<empty>,,67,1,CPPASTTypeId,,<empty>
18328,UNKNOWN,1,,LogString,19,<empty>,,81,1,CPPASTTypeId,,<empty>
18354,UNKNOWN,1,,LogString,19,<empty>,,84,1,CPPASTTypeId,,<empty>
18388,UNKNOWN,1,,LogString,19,<empty>,,89,1,CPPASTTypeId,,<empty>
18418,UNKNOWN,1,,LogString,18,<empty>,,98,1,CPPASTTypeId,,<empty>
18444,UNKNOWN,1,,LogString,18,<empty>,,105,1,CPPASTTypeId,,<empty>
18472,UNKNOWN,1,,Hierarchy*,38,<empty>,,112,1,CPPASTTypeId,,<empty>
18892,UNKNOWN,1,,size_t,11,<empty>,,240,1,CPPASTTypeId,,<empty>
19181,UNKNOWN,2,,),38,<empty>,,36,2,CPPASTProblemDeclaration,,<empty>
19243,UNKNOWN,1,,FileAppenderPriv *,45,<empty>,,88,1,CPPASTTypeId,,<empty>
19254,UNKNOWN,1,,FileAppenderPriv *,2,<empty>,,89,1,CPPASTTypeId,,<empty>
19279,UNKNOWN,1,,FileAppenderPriv *,45,<empty>,,94,1,CPPASTTypeId,,<empty>
19297,UNKNOWN,1,,FileAppenderPriv *,2,<empty>,,100,1,CPPASTTypeId,,<empty>
19322,UNKNOWN,1,,FileAppenderPriv *,45,<empty>,,105,1,CPPASTTypeId,,<empty>
19333,UNKNOWN,1,,FileAppenderPriv *,2,<empty>,,106,1,CPPASTTypeId,,<empty>
19385,UNKNOWN,1,,FileAppenderPriv *,46,<empty>,,120,1,CPPASTTypeId,,<empty>
19396,UNKNOWN,1,,FileAppenderPriv *,3,<empty>,,121,1,CPPASTTypeId,,<empty>
19430,UNKNOWN,1,,FileAppenderPriv *,46,<empty>,,125,1,CPPASTTypeId,,<empty>
19441,UNKNOWN,1,,FileAppenderPriv *,3,<empty>,,126,1,CPPASTTypeId,,<empty>
19479,UNKNOWN,1,,FileAppenderPriv *,46,<empty>,,130,1,CPPASTTypeId,,<empty>
19490,UNKNOWN,1,,FileAppenderPriv *,3,<empty>,,131,1,CPPASTTypeId,,<empty>
19528,UNKNOWN,1,,FileAppenderPriv *,46,<empty>,,135,1,CPPASTTypeId,,<empty>
19539,UNKNOWN,1,,FileAppenderPriv *,3,<empty>,,136,1,CPPASTTypeId,,<empty>
19578,UNKNOWN,1,,FileAppenderPriv *,46,<empty>,,140,1,CPPASTTypeId,,<empty>
19589,UNKNOWN,1,,FileAppenderPriv *,3,<empty>,,141,1,CPPASTTypeId,,<empty>
19629,UNKNOWN,1,,FileAppenderPriv *,45,<empty>,,151,1,CPPASTTypeId,,<empty>
19654,UNKNOWN,1,,FileAppenderPriv *,7,<empty>,,159,1,CPPASTTypeId,,<empty>
19669,UNKNOWN,1,,FileAppenderPriv *,20,<empty>,,163,1,CPPASTTypeId,,<empty>
19679,UNKNOWN,1,,FileAppenderPriv *,37,<empty>,,163,1,CPPASTTypeId,,<empty>
19689,UNKNOWN,1,,FileAppenderPriv *,56,<empty>,,163,1,CPPASTTypeId,,<empty>
19699,UNKNOWN,1,,FileAppenderPriv *,75,<empty>,,163,1,CPPASTTypeId,,<empty>
19721,UNKNOWN,1,,FileAppenderPriv *,15,<empty>,,169,1,CPPASTTypeId,,<empty>
19733,UNKNOWN,1,,logchar,19,<empty>,,170,1,CPPASTTypeId,,<empty>
19743,UNKNOWN,1,,FileAppenderPriv *,27,<empty>,,171,1,CPPASTTypeId,,<empty>
19762,UNKNOWN,1,,FileAppenderPriv *,4,<empty>,,173,1,CPPASTTypeId,,<empty>
19791,UNKNOWN,1,,FileAppenderPriv *,7,<empty>,,180,1,CPPASTTypeId,,<empty>
20018,UNKNOWN,1,,char,19,<empty>,,336,1,CPPASTTypeId,,<empty>
20021,UNKNOWN,1,,char,32,<empty>,,336,1,CPPASTTypeId,,<empty>
20059,UNKNOWN,1,,FileAppenderPriv *,2,<empty>,,350,1,CPPASTTypeId,,<empty>
20071,UNKNOWN,1,,FileAppenderPriv *,2,<empty>,,351,1,CPPASTTypeId,,<empty>
20083,UNKNOWN,1,,FileAppenderPriv *,2,<empty>,,352,1,CPPASTTypeId,,<empty>
20095,UNKNOWN,1,,FileAppenderPriv *,2,<empty>,,353,1,CPPASTTypeId,,<empty>
20102,UNKNOWN,1,,int,23,<empty>,,353,1,CPPASTTypeId,,<empty>
20115,UNKNOWN,1,,FileAppenderPriv *,9,<empty>,,360,1,CPPASTTypeId,,<empty>
20130,UNKNOWN,1,,FileAppenderPriv *,9,<empty>,,365,1,CPPASTTypeId,,<empty>
20145,UNKNOWN,1,,FileAppenderPriv *,9,<empty>,,370,1,CPPASTTypeId,,<empty>
20161,UNKNOWN,1,,FileAppenderPriv *,2,<empty>,,375,1,CPPASTTypeId,,<empty>
20177,UNKNOWN,1,,FileAppenderPriv *,9,<empty>,,380,1,CPPASTTypeId,,<empty>
20261,UNKNOWN,3,,),41,<empty>,,40,3,CPPASTProblemDeclaration,,<empty>
20457,UNKNOWN,1,,int,13,<empty>,,121,1,CPPASTTypeId,,<empty>
20477,UNKNOWN,2,,),54,<empty>,,27,2,CPPASTProblemDeclaration,,<empty>
20539,UNKNOWN,3,,),42,<empty>,,40,3,CPPASTProblemDeclaration,,<empty>
20797,UNKNOWN,3,,),42,<empty>,,40,3,CPPASTProblemDeclaration,,<empty>
20815,UNKNOWN,1,,FileRenameActionPrivate *,9,<empty>,,51,1,CPPASTTypeId,,<empty>
20824,UNKNOWN,1,,FileRenameActionPrivate *,31,<empty>,,51,1,CPPASTTypeId,,<empty>
20999,UNKNOWN,1,,LogString,20,<empty>,,102,1,CPPASTTypeId,,<empty>
21070,UNKNOWN,1,,int,26,<empty>,,126,1,CPPASTTypeId,,<empty>
21277,UNKNOWN,2,,),53,<empty>,,26,2,CPPASTProblemDeclaration,,<empty>
21493,UNKNOWN,3,,),50,<empty>,,53,3,CPPASTProblemDeclaration,,<empty>
21510,UNKNOWN,1,,FixedWindowRollingPolicyPrivate *,2,<empty>,,64,1,CPPASTTypeId,,<empty>
21527,UNKNOWN,1,,FixedWindowRollingPolicyPrivate *,2,<empty>,,69,1,CPPASTTypeId,,<empty>
21556,UNKNOWN,1,,FixedWindowRollingPolicyPrivate *,3,<empty>,,79,1,CPPASTTypeId,,<empty>
21586,UNKNOWN,1,,FixedWindowRollingPolicyPrivate *,3,<empty>,,85,1,CPPASTTypeId,,<empty>
21616,UNKNOWN,1,,FixedWindowRollingPolicyPrivate *,3,<empty>,,91,1,CPPASTTypeId,,<empty>
21652,UNKNOWN,1,,FixedWindowRollingPolicyPrivate *,6,<empty>,,106,1,CPPASTTypeId,,<empty>
21662,UNKNOWN,1,,FixedWindowRollingPolicyPrivate *,23,<empty>,,106,1,CPPASTTypeId,,<empty>
21680,UNKNOWN,1,,FixedWindowRollingPolicyPrivate *,3,<empty>,,110,1,CPPASTTypeId,,<empty>
21690,UNKNOWN,1,,FixedWindowRollingPolicyPrivate *,20,<empty>,,110,1,CPPASTTypeId,,<empty>
21703,UNKNOWN,1,,FixedWindowRollingPolicyPrivate *,7,<empty>,,113,1,CPPASTTypeId,,<empty>
21713,UNKNOWN,1,,FixedWindowRollingPolicyPrivate *,24,<empty>,,113,1,CPPASTTypeId,,<empty>
21732,UNKNOWN,1,,FixedWindowRollingPolicyPrivate *,3,<empty>,,116,1,CPPASTTypeId,,<empty>
21743,UNKNOWN,1,,FixedWindowRollingPolicyPrivate *,20,<empty>,,116,1,CPPASTTypeId,,<empty>
21776,UNKNOWN,1,,FixedWindowRollingPolicyPrivate *,2,<empty>,,136,1,CPPASTTypeId,,<empty>
21796,UNKNOWN,1,,FixedWindowRollingPolicyPrivate *,3,<empty>,,140,1,CPPASTTypeId,,<empty>
21812,UNKNOWN,1,,FixedWindowRollingPolicyPrivate *,7,<empty>,,144,1,CPPASTTypeId,,<empty>
21833,UNKNOWN,1,,FixedWindowRollingPolicyPrivate *,45,<empty>,,147,1,CPPASTTypeId,,<empty>
21874,UNKNOWN,1,,FixedWindowRollingPolicyPrivate *,6,<empty>,,167,1,CPPASTTypeId,,<empty>
21891,UNKNOWN,1,,FixedWindowRollingPolicyPrivate *,19,<empty>,,172,1,CPPASTTypeId,,<empty>
21903,UNKNOWN,1,,FixedWindowRollingPolicyPrivate *,7,<empty>,,174,1,CPPASTTypeId,,<empty>
21920,UNKNOWN,1,,FixedWindowRollingPolicyPrivate *,25,<empty>,,179,1,CPPASTTypeId,,<empty>
22019,UNKNOWN,1,,FixedWindowRollingPolicyPrivate *,42,<empty>,,205,1,CPPASTTypeId,,<empty>
22079,UNKNOWN,1,,FixedWindowRollingPolicyPrivate *,42,<empty>,,215,1,CPPASTTypeId,,<empty>
22135,UNKNOWN,1,,FixedWindowRollingPolicyPrivate *,9,<empty>,,237,1,CPPASTTypeId,,<empty>
22150,UNKNOWN,1,,FixedWindowRollingPolicyPrivate *,9,<empty>,,246,1,CPPASTTypeId,,<empty>
22477,UNKNOWN,1,,PatternConstructor,2,<empty>,,378,1,CPPASTTypeId,,<empty>
22496,UNKNOWN,1,,PatternConstructor,2,<empty>,,379,1,CPPASTTypeId,,<empty>
22544,UNKNOWN,3,,),35,<empty>,,49,3,CPPASTProblemDeclaration,,<empty>
22963,UNKNOWN,3,,),40,<empty>,,48,3,CPPASTProblemDeclaration,,<empty>
23063,UNKNOWN,1,,logchar,50,<empty>,,93,1,CPPASTTypeId,,<empty>
23120,UNKNOWN,2,,),54,<empty>,,29,2,CPPASTProblemDeclaration,,<empty>
23159,UNKNOWN,1,,logchar,24,<empty>,,50,1,CPPASTTypeId,,<empty>
23180,UNKNOWN,1,,logchar,24,<empty>,,54,1,CPPASTTypeId,,<empty>
23223,UNKNOWN,3,,),42,<empty>,,45,3,CPPASTProblemDeclaration,,<empty>
23245,UNKNOWN,1,,GZCompressActionPrivate *,6,<empty>,,59,1,CPPASTTypeId,,<empty>
23324,UNKNOWN,1,,GZCompressActionPrivate *,10,<empty>,,90,1,CPPASTTypeId,,<empty>
23390,UNKNOWN,1,,GZCompressActionPrivate *,3,<empty>,,120,1,CPPASTTypeId,,<empty>
23402,UNKNOWN,1,,const char**,24,<empty>,,122,1,CPPASTTypeId,,<empty>
23441,UNKNOWN,1,,GZCompressActionPrivate *,34,<empty>,,127,1,CPPASTTypeId,,<empty>
23475,UNKNOWN,1,,GZCompressActionPrivate *,30,<empty>,,133,1,CPPASTTypeId,,<empty>
23497,UNKNOWN,1,,GZCompressActionPrivate *,36,<empty>,,136,1,CPPASTTypeId,,<empty>
23551,UNKNOWN,1,,GZCompressActionPrivate *,3,<empty>,,163,1,CPPASTTypeId,,<empty>
23564,UNKNOWN,1,,GZCompressActionPrivate *,7,<empty>,,165,1,CPPASTTypeId,,<empty>
23577,UNKNOWN,1,,GZCompressActionPrivate *,4,<empty>,,167,1,CPPASTTypeId,,<empty>
23599,UNKNOWN,1,,GZCompressActionPrivate *,2,<empty>,,177,1,CPPASTTypeId,,<empty>
23638,UNKNOWN,1,,const uint8_t*,40,<empty>,,36,1,CPPASTTypeId,,<empty>
23774,UNKNOWN,1,,int,82,<empty>,,70,1,CPPASTTypeId,,<empty>
23864,UNKNOWN,1,,int,82,<empty>,,89,1,CPPASTTypeId,,<empty>
24065,UNKNOWN,5,,),35,<empty>,,73,5,CPPASTProblemDeclaration,,<empty>
24301,UNKNOWN,1,,LogString,18,<empty>,,140,1,CPPASTTypeId,,<empty>
24414,UNKNOWN,1,,LogString,18,<empty>,,182,1,CPPASTTypeId,,<empty>
24810,UNKNOWN,1,,Hierarchy*,41,<empty>,,299,1,CPPASTTypeId,,<empty>
25573,UNKNOWN,3,,),36,<empty>,,53,3,CPPASTProblemDeclaration,,<empty>
25929,UNKNOWN,1,,logchar,21,<empty>,,142,1,CPPASTTypeId,,<empty>
26473,UNKNOWN,2,,),37,<empty>,,29,2,CPPASTProblemDeclaration,,<empty>
26749,UNKNOWN,2,,),37,<empty>,,24,2,CPPASTProblemDeclaration,,<empty>
26778,UNKNOWN,2,,),43,<empty>,,30,2,CPPASTProblemDeclaration,,<empty>
26945,UNKNOWN,2,,),33,<empty>,,24,2,CPPASTProblemDeclaration,,<empty>
26973,UNKNOWN,2,,),49,<empty>,,27,2,CPPASTProblemDeclaration,,<empty>
27048,UNKNOWN,2,,),36,<empty>,,33,2,CPPASTProblemDeclaration,,<empty>
28307,UNKNOWN,2,,),32,<empty>,,23,2,CPPASTProblemDeclaration,,<empty>
28384,UNKNOWN,1,,"IMPLEMENT_LOG4CXX_OBJECT_WITH_CUSTOM_CLASS(Level, LevelClass)

LevelPtr Level::getOff()
{
	static WideLife<LevelPtr> offLevel = std::make_shared<Level>(Level::OFF_INT, LOG4CXX_STR(""OFF""), 0);
	return offLevel;
}",1,<empty>,,31,1,CPPASTProblemDeclaration,,<empty>
28865,UNKNOWN,3,,),42,<empty>,,39,3,CPPASTProblemDeclaration,,<empty>
28873,UNKNOWN,1,,LevelMatchFilterPrivate *,2,<empty>,,44,1,CPPASTTypeId,,<empty>
28921,UNKNOWN,1,,LevelMatchFilterPrivate *,3,<empty>,,62,1,CPPASTTypeId,,<empty>
28936,UNKNOWN,1,,LevelMatchFilterPrivate *,59,<empty>,,62,1,CPPASTTypeId,,<empty>
28952,UNKNOWN,1,,LevelMatchFilterPrivate *,2,<empty>,,68,1,CPPASTTypeId,,<empty>
28967,UNKNOWN,1,,LevelMatchFilterPrivate *,63,<empty>,,68,1,CPPASTTypeId,,<empty>
28984,UNKNOWN,1,,LevelMatchFilterPrivate *,9,<empty>,,73,1,CPPASTTypeId,,<empty>
29003,UNKNOWN,1,,LevelMatchFilterPrivate *,6,<empty>,,79,1,CPPASTTypeId,,<empty>
29016,UNKNOWN,1,,LevelMatchFilterPrivate *,33,<empty>,,79,1,CPPASTTypeId,,<empty>
29033,UNKNOWN,1,,LevelMatchFilterPrivate *,7,<empty>,,81,1,CPPASTTypeId,,<empty>
29066,UNKNOWN,1,,LevelMatchFilterPrivate *,2,<empty>,,98,1,CPPASTTypeId,,<empty>
29082,UNKNOWN,1,,LevelMatchFilterPrivate *,9,<empty>,,103,1,CPPASTTypeId,,<empty>
29106,UNKNOWN,2,,),47,<empty>,,30,2,CPPASTProblemDeclaration,,<empty>
29262,UNKNOWN,3,,),42,<empty>,,46,3,CPPASTProblemDeclaration,,<empty>
29291,UNKNOWN,1,,LevelRangeFilterPrivate *,3,<empty>,,63,1,CPPASTTypeId,,<empty>
29306,UNKNOWN,1,,LevelRangeFilterPrivate *,52,<empty>,,63,1,CPPASTTypeId,,<empty>
29330,UNKNOWN,1,,LevelRangeFilterPrivate *,3,<empty>,,68,1,CPPASTTypeId,,<empty>
29345,UNKNOWN,1,,LevelRangeFilterPrivate *,52,<empty>,,68,1,CPPASTTypeId,,<empty>
29369,UNKNOWN,1,,LevelRangeFilterPrivate *,3,<empty>,,73,1,CPPASTTypeId,,<empty>
29384,UNKNOWN,1,,LevelRangeFilterPrivate *,59,<empty>,,73,1,CPPASTTypeId,,<empty>
29402,UNKNOWN,1,,LevelRangeFilterPrivate *,6,<empty>,,80,1,CPPASTTypeId,,<empty>
29421,UNKNOWN,1,,LevelRangeFilterPrivate *,66,<empty>,,80,1,CPPASTTypeId,,<empty>
29439,UNKNOWN,1,,LevelRangeFilterPrivate *,6,<empty>,,86,1,CPPASTTypeId,,<empty>
29460,UNKNOWN,1,,LevelRangeFilterPrivate *,58,<empty>,,86,1,CPPASTTypeId,,<empty>
29477,UNKNOWN,1,,LevelRangeFilterPrivate *,6,<empty>,,95,1,CPPASTTypeId,,<empty>
29504,UNKNOWN,1,,LevelRangeFilterPrivate *,2,<empty>,,110,1,CPPASTTypeId,,<empty>
29520,UNKNOWN,1,,LevelRangeFilterPrivate *,9,<empty>,,115,1,CPPASTTypeId,,<empty>
29536,UNKNOWN,1,,LevelRangeFilterPrivate *,2,<empty>,,120,1,CPPASTTypeId,,<empty>
29552,UNKNOWN,1,,LevelRangeFilterPrivate *,9,<empty>,,125,1,CPPASTTypeId,,<empty>
29568,UNKNOWN,1,,LevelRangeFilterPrivate *,2,<empty>,,130,1,CPPASTTypeId,,<empty>
29584,UNKNOWN,1,,LevelRangeFilterPrivate *,9,<empty>,,135,1,CPPASTTypeId,,<empty>
29608,UNKNOWN,2,,),54,<empty>,,29,2,CPPASTProblemDeclaration,,<empty>
29661,UNKNOWN,2,,),55,<empty>,,28,2,CPPASTProblemDeclaration,,<empty>
29729,UNKNOWN,3,,),49,<empty>,,43,3,CPPASTProblemDeclaration,,<empty>
29787,UNKNOWN,1,,LiteralPatternConverterPrivate *,20,<empty>,,68,1,CPPASTTypeId,,<empty>
29808,UNKNOWN,1,,LiteralPatternConverterPrivate *,20,<empty>,,76,1,CPPASTTypeId,,<empty>
29856,UNKNOWN,2,,),32,<empty>,,41,2,CPPASTProblemDeclaration,,<empty>
29858,UNKNOWN,4,,),39,<empty>,,42,4,CPPASTProblemDeclaration,,<empty>
29860,UNKNOWN,6,,),38,<empty>,,43,6,CPPASTProblemDeclaration,,<empty>
29862,UNKNOWN,8,,),34,<empty>,,44,8,CPPASTProblemDeclaration,,<empty>
29864,UNKNOWN,10,,),32,<empty>,,45,10,CPPASTProblemDeclaration,,<empty>
29866,UNKNOWN,12,,),44,<empty>,,46,12,CPPASTProblemDeclaration,,<empty>
29868,UNKNOWN,14,,),39,<empty>,,47,14,CPPASTProblemDeclaration,,<empty>
29870,UNKNOWN,16,,),42,<empty>,,48,16,CPPASTProblemDeclaration,,<empty>
29872,UNKNOWN,18,,),39,<empty>,,49,18,CPPASTProblemDeclaration,,<empty>
29874,UNKNOWN,20,,),44,<empty>,,50,20,CPPASTProblemDeclaration,,<empty>
29876,UNKNOWN,22,,),36,<empty>,,51,22,CPPASTProblemDeclaration,,<empty>
29878,UNKNOWN,24,,),40,<empty>,,52,24,CPPASTProblemDeclaration,,<empty>
29880,UNKNOWN,26,,),39,<empty>,,53,26,CPPASTProblemDeclaration,,<empty>
29882,UNKNOWN,28,,),40,<empty>,,54,28,CPPASTProblemDeclaration,,<empty>
29884,UNKNOWN,30,,),50,<empty>,,55,30,CPPASTProblemDeclaration,,<empty>
30290,UNKNOWN,3,,),44,<empty>,,48,3,CPPASTProblemDeclaration,,<empty>
30329,UNKNOWN,1,,LocationInfoFilterPrivate *,3,<empty>,,63,1,CPPASTTypeId,,<empty>
30344,UNKNOWN,1,,LocationInfoFilterPrivate *,59,<empty>,,63,1,CPPASTTypeId,,<empty>
30368,UNKNOWN,1,,LocationInfoFilterPrivate *,3,<empty>,,67,1,CPPASTTypeId,,<empty>
30404,UNKNOWN,1,,LocationInfoFilterPrivate *,3,<empty>,,71,1,CPPASTTypeId,,<empty>
30438,UNKNOWN,1,,LocationInfoFilterPrivate *,3,<empty>,,76,1,CPPASTTypeId,,<empty>
30457,UNKNOWN,1,,LocationInfoFilterPrivate *,6,<empty>,,83,1,CPPASTTypeId,,<empty>
30471,UNKNOWN,1,,LocationInfoFilterPrivate *,4,<empty>,,84,1,CPPASTTypeId,,<empty>
30527,UNKNOWN,1,,LocationInfoFilterPrivate *,25,<empty>,,95,1,CPPASTTypeId,,<empty>
30550,UNKNOWN,1,,LocationInfoFilterPrivate *,25,<empty>,,96,1,CPPASTTypeId,,<empty>
30570,UNKNOWN,1,,LocationInfoFilterPrivate *,5,<empty>,,98,1,CPPASTTypeId,,<empty>
30594,UNKNOWN,1,,LocationInfoFilterPrivate *,6,<empty>,,104,1,CPPASTTypeId,,<empty>
30631,UNKNOWN,1,,LocationInfoFilterPrivate *,2,<empty>,,116,1,CPPASTTypeId,,<empty>
30647,UNKNOWN,1,,LocationInfoFilterPrivate *,9,<empty>,,121,1,CPPASTTypeId,,<empty>
30662,UNKNOWN,1,,LocationInfoFilterPrivate *,9,<empty>,,126,1,CPPASTTypeId,,<empty>
30678,UNKNOWN,1,,LocationInfoFilterPrivate *,2,<empty>,,131,1,CPPASTTypeId,,<empty>
30695,UNKNOWN,1,,LocationInfoFilterPrivate *,2,<empty>,,135,1,CPPASTTypeId,,<empty>
30715,UNKNOWN,1,,LocationInfoFilterPrivate *,2,<empty>,,140,1,CPPASTTypeId,,<empty>
30774,UNKNOWN,3,,),32,<empty>,,87,3,CPPASTProblemDeclaration,,<empty>
30937,UNKNOWN,1,,Logger*,41,<empty>,,147,1,CPPASTTypeId,,<empty>
31918,UNKNOWN,1,,Hierarchy*,31,<empty>,,560,1,CPPASTTypeId,,<empty>
32296,UNKNOWN,3,,),43,<empty>,,42,3,CPPASTProblemDeclaration,,<empty>
32313,UNKNOWN,1,,LoggerMatchFilterPrivate *,2,<empty>,,54,1,CPPASTTypeId,,<empty>
32329,UNKNOWN,1,,LoggerMatchFilterPrivate *,9,<empty>,,59,1,CPPASTTypeId,,<empty>
32372,UNKNOWN,1,,LoggerMatchFilterPrivate *,3,<empty>,,74,1,CPPASTTypeId,,<empty>
32387,UNKNOWN,1,,LoggerMatchFilterPrivate *,59,<empty>,,74,1,CPPASTTypeId,,<empty>
32406,UNKNOWN,1,,LoggerMatchFilterPrivate *,22,<empty>,,81,1,CPPASTTypeId,,<empty>
32424,UNKNOWN,1,,LoggerMatchFilterPrivate *,7,<empty>,,85,1,CPPASTTypeId,,<empty>
32457,UNKNOWN,1,,LoggerMatchFilterPrivate *,2,<empty>,,102,1,CPPASTTypeId,,<empty>
32473,UNKNOWN,1,,LoggerMatchFilterPrivate *,9,<empty>,,107,1,CPPASTTypeId,,<empty>
32495,UNKNOWN,2,,),48,<empty>,,28,2,CPPASTProblemDeclaration,,<empty>
32543,UNKNOWN,1,,int,23,<empty>,,54,1,CPPASTTypeId,,<empty>
32658,UNKNOWN,3,,),38,<empty>,,168,3,CPPASTProblemDeclaration,,<empty>
33254,UNKNOWN,2,,),54,<empty>,,28,2,CPPASTProblemDeclaration,,<empty>
33691,UNKNOWN,1,,logchar,17,<empty>,,164,1,CPPASTTypeId,,<empty>
33739,UNKNOWN,1,,logchar,17,<empty>,,183,1,CPPASTTypeId,,<empty>
33806,UNKNOWN,2,,),51,<empty>,,43,2,CPPASTProblemDeclaration,,<empty>
34054,UNKNOWN,1,,Hierarchy*,28,<empty>,,218,1,CPPASTTypeId,,<empty>
34258,UNKNOWN,1,,int,16,<empty>,,120,1,CPPASTTypeId,,<empty>
34278,UNKNOWN,1,,int,10,<empty>,,128,1,CPPASTTypeId,,<empty>
34302,UNKNOWN,1,,int,16,<empty>,,135,1,CPPASTTypeId,,<empty>
34322,UNKNOWN,1,,int,10,<empty>,,143,1,CPPASTTypeId,,<empty>
34680,UNKNOWN,1,,int,16,<empty>,,317,1,CPPASTTypeId,,<empty>
34699,UNKNOWN,1,,int,20,<empty>,,320,1,CPPASTTypeId,,<empty>
34761,UNKNOWN,2,,),48,<empty>,,26,2,CPPASTProblemDeclaration,,<empty>
34813,UNKNOWN,3,,),35,<empty>,,42,3,CPPASTProblemDeclaration,,<empty>
34842,UNKNOWN,1,,MapFilterPrivate *,3,<empty>,,56,1,CPPASTTypeId,,<empty>
34857,UNKNOWN,1,,MapFilterPrivate *,59,<empty>,,56,1,CPPASTTypeId,,<empty>
34881,UNKNOWN,1,,MapFilterPrivate *,3,<empty>,,60,1,CPPASTTypeId,,<empty>
34920,UNKNOWN,1,,MapFilterPrivate *,3,<empty>,,64,1,CPPASTTypeId,,<empty>
34940,UNKNOWN,1,,MapFilterPrivate *,6,<empty>,,71,1,CPPASTTypeId,,<empty>
34967,UNKNOWN,1,,MapFilterPrivate *,36,<empty>,,78,1,CPPASTTypeId,,<empty>
34982,UNKNOWN,1,,MapFilterPrivate *,65,<empty>,,78,1,CPPASTTypeId,,<empty>
35027,UNKNOWN,1,,MapFilterPrivate *,7,<empty>,,92,1,CPPASTTypeId,,<empty>
35041,UNKNOWN,1,,MapFilterPrivate *,6,<empty>,,98,1,CPPASTTypeId,,<empty>
35080,UNKNOWN,1,,MapFilterPrivate *,2,<empty>,,110,1,CPPASTTypeId,,<empty>
35102,UNKNOWN,1,,MapFilterPrivate *,37,<empty>,,116,1,CPPASTTypeId,,<empty>
35120,UNKNOWN,1,,MapFilterPrivate *,16,<empty>,,118,1,CPPASTTypeId,,<empty>
35144,UNKNOWN,1,,MapFilterPrivate *,2,<empty>,,123,1,CPPASTTypeId,,<empty>
35160,UNKNOWN,1,,MapFilterPrivate *,9,<empty>,,128,1,CPPASTTypeId,,<empty>
35175,UNKNOWN,1,,MapFilterPrivate *,9,<empty>,,133,1,CPPASTTypeId,,<empty>
35191,UNKNOWN,1,,MapFilterPrivate *,2,<empty>,,138,1,CPPASTTypeId,,<empty>
35481,UNKNOWN,2,,),45,<empty>,,26,2,CPPASTProblemDeclaration,,<empty>
35884,UNKNOWN,1,,const char*,21,<empty>,,137,1,CPPASTTypeId,,<empty>
36017,UNKNOWN,1,,std::ostream&,11,<empty>,,194,1,CPPASTTypeId,,<empty>
36031,UNKNOWN,1,,std::ostream&,11,<empty>,,198,1,CPPASTTypeId,,<empty>
36045,UNKNOWN,1,,std::ostream&,11,<empty>,,202,1,CPPASTTypeId,,<empty>
36059,UNKNOWN,1,,std::ostream&,11,<empty>,,206,1,CPPASTTypeId,,<empty>
36073,UNKNOWN,1,,std::ostream&,11,<empty>,,210,1,CPPASTTypeId,,<empty>
36087,UNKNOWN,1,,std::ostream&,11,<empty>,,214,1,CPPASTTypeId,,<empty>
36101,UNKNOWN,1,,std::ostream&,11,<empty>,,218,1,CPPASTTypeId,,<empty>
36115,UNKNOWN,1,,std::ostream&,11,<empty>,,222,1,CPPASTTypeId,,<empty>
36129,UNKNOWN,1,,std::ostream&,11,<empty>,,226,1,CPPASTTypeId,,<empty>
36143,UNKNOWN,1,,std::ostream&,11,<empty>,,230,1,CPPASTTypeId,,<empty>
36164,UNKNOWN,2,,),49,<empty>,,27,2,CPPASTProblemDeclaration,,<empty>
36312,UNKNOWN,2,,),56,<empty>,,28,2,CPPASTProblemDeclaration,,<empty>
36396,UNKNOWN,3,,),57,<empty>,,74,3,CPPASTProblemDeclaration,,<empty>
36410,UNKNOWN,1,,MultiprocessRollingFileAppenderPriv *,6,<empty>,,90,1,CPPASTTypeId,,<empty>
36438,UNKNOWN,1,,MultiprocessRollingFileAppenderPriv *,3,<empty>,,94,1,CPPASTTypeId,,<empty>
36451,UNKNOWN,1,,MultiprocessRollingFileAppenderPriv *,6,<empty>,,100,1,CPPASTTypeId,,<empty>
36472,UNKNOWN,1,,MultiprocessRollingFileAppenderPriv *,65,<empty>,,102,1,CPPASTTypeId,,<empty>
36488,UNKNOWN,1,,MultiprocessRollingFileAppenderPriv *,4,<empty>,,106,1,CPPASTTypeId,,<empty>
36501,UNKNOWN,1,,MultiprocessRollingFileAppenderPriv *,6,<empty>,,110,1,CPPASTTypeId,,<empty>
36514,UNKNOWN,1,,MultiprocessRollingFileAppenderPriv *,3,<empty>,,112,1,CPPASTTypeId,,<empty>
36538,UNKNOWN,1,,MultiprocessRollingFileAppenderPriv *,46,<empty>,,116,1,CPPASTTypeId,,<empty>
36550,UNKNOWN,1,,MultiprocessRollingFileAppenderPriv *,3,<empty>,,117,1,CPPASTTypeId,,<empty>
36564,UNKNOWN,1,,MultiprocessRollingFileAppenderPriv *,3,<empty>,,118,1,CPPASTTypeId,,<empty>
36583,UNKNOWN,1,,MultiprocessRollingFileAppenderPriv *,5,<empty>,,123,1,CPPASTTypeId,,<empty>
36619,UNKNOWN,1,,MultiprocessRollingFileAppenderPriv *,5,<empty>,,134,1,CPPASTTypeId,,<empty>
36634,UNKNOWN,1,,MultiprocessRollingFileAppenderPriv *,5,<empty>,,135,1,CPPASTTypeId,,<empty>
36674,UNKNOWN,1,,MultiprocessRollingFileAppenderPriv *,5,<empty>,,153,1,CPPASTTypeId,,<empty>
36692,UNKNOWN,1,,MultiprocessRollingFileAppenderPriv *,5,<empty>,,157,1,CPPASTTypeId,,<empty>
36761,UNKNOWN,1,,MultiprocessRollingFileAppenderPriv *,45,<empty>,,204,1,CPPASTTypeId,,<empty>
36781,UNKNOWN,1,,MultiprocessRollingFileAppenderPriv *,6,<empty>,,213,1,CPPASTTypeId,,<empty>
36806,UNKNOWN,1,,MultiprocessRollingFileAppenderPriv *,74,<empty>,,218,1,CPPASTTypeId,,<empty>
36949,UNKNOWN,1,,unsigned int,42,<empty>,,247,1,CPPASTTypeId,,<empty>
37058,UNKNOWN,1,,MultiprocessRollingFileAppenderPriv *,10,<empty>,,277,1,CPPASTTypeId,,<empty>
37071,UNKNOWN,1,,MultiprocessRollingFileAppenderPriv *,7,<empty>,,279,1,CPPASTTypeId,,<empty>
37081,UNKNOWN,1,,MultiprocessRollingFileAppenderPriv *,56,<empty>,,279,1,CPPASTTypeId,,<empty>
37215,UNKNOWN,1,,MultiprocessRollingFileAppenderPriv *,39,<empty>,,319,1,CPPASTTypeId,,<empty>
37299,UNKNOWN,1,,MultiprocessRollingFileAppenderPriv *,10,<empty>,,342,1,CPPASTTypeId,,<empty>
37325,UNKNOWN,1,,MultiprocessRollingFileAppenderPriv *,10,<empty>,,350,1,CPPASTTypeId,,<empty>
37350,UNKNOWN,1,,MultiprocessRollingFileAppenderPriv *,10,<empty>,,354,1,CPPASTTypeId,,<empty>
37386,UNKNOWN,1,,MultiprocessRollingFileAppenderPriv *,10,<empty>,,369,1,CPPASTTypeId,,<empty>
37396,UNKNOWN,1,,MultiprocessRollingFileAppenderPriv *,29,<empty>,,369,1,CPPASTTypeId,,<empty>
37415,UNKNOWN,1,,MultiprocessRollingFileAppenderPriv *,48,<empty>,,374,1,CPPASTTypeId,,<empty>
37425,UNKNOWN,1,,MultiprocessRollingFileAppenderPriv *,67,<empty>,,374,1,CPPASTTypeId,,<empty>
37517,UNKNOWN,1,,MultiprocessRollingFileAppenderPriv *,10,<empty>,,403,1,CPPASTTypeId,,<empty>
37541,UNKNOWN,1,,MultiprocessRollingFileAppenderPriv *,10,<empty>,,411,1,CPPASTTypeId,,<empty>
37566,UNKNOWN,1,,MultiprocessRollingFileAppenderPriv *,10,<empty>,,415,1,CPPASTTypeId,,<empty>
37622,UNKNOWN,1,,MultiprocessRollingFileAppenderPriv *,6,<empty>,,441,1,CPPASTTypeId,,<empty>
37671,UNKNOWN,1,,MultiprocessRollingFileAppenderPriv *,2,<empty>,,467,1,CPPASTTypeId,,<empty>
37701,UNKNOWN,1,,MultiprocessRollingFileAppenderPriv *,3,<empty>,,480,1,CPPASTTypeId,,<empty>
37720,UNKNOWN,1,,MultiprocessRollingFileAppenderPriv *,4,<empty>,,490,1,CPPASTTypeId,,<empty>
37756,UNKNOWN,1,,MultiprocessRollingFileAppenderPriv *,4,<empty>,,498,1,CPPASTTypeId,,<empty>
37898,UNKNOWN,1,,MultiprocessRollingFileAppenderPriv *,9,<empty>,,545,1,CPPASTTypeId,,<empty>
37913,UNKNOWN,1,,MultiprocessRollingFileAppenderPriv *,9,<empty>,,554,1,CPPASTTypeId,,<empty>
37929,UNKNOWN,1,,MultiprocessRollingFileAppenderPriv *,2,<empty>,,563,1,CPPASTTypeId,,<empty>
37964,UNKNOWN,1,,MultiprocessRollingFileAppenderPriv *,2,<empty>,,577,1,CPPASTTypeId,,<empty>
38086,UNKNOWN,1,,MultiprocessRollingFileAppenderPriv *,9,<empty>,,680,1,CPPASTTypeId,,<empty>
38102,UNKNOWN,1,,MultiprocessRollingFileAppenderPriv *,2,<empty>,,685,1,CPPASTTypeId,,<empty>
38119,UNKNOWN,1,,MultiprocessRollingFileAppenderPriv *,2,<empty>,,694,1,CPPASTTypeId,,<empty>
38144,UNKNOWN,2,,),41,<empty>,,28,2,CPPASTProblemDeclaration,,<empty>
38157,UNKNOWN,-1,,),49,<empty>,,48,2,CPPASTProblemDeclaration,,<empty>
38158,UNKNOWN,-1,,"BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(NOPAbbreviator)
		LOG4CXX_CAST_ENTRY_CHAIN(NameAbbreviator)
		END_LOG4CXX_CAST_MAP()

		/**
		 * Constructor.
		 */
		NOPAbbreviator()
		{
		}",3,<empty>,,49,3,CPPASTProblemDeclaration,,<empty>
38168,UNKNOWN,-1,,),56,<empty>,,81,3,CPPASTProblemDeclaration,,<empty>
38169,UNKNOWN,-1,,"BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(MaxElementAbbreviator)
		LOG4CXX_CAST_ENTRY_CHAIN(NameAbbreviator)
		END_LOG4CXX_CAST_MAP()
		/**
		 * Create new instance.
		 * @param count maximum number of path elements to output.
		 */
		MaxElementAbbreviator(const int count1) : count(count1)
		{
		}",3,<empty>,,82,4,CPPASTProblemDeclaration,,<empty>
38346,UNKNOWN,-1,,),53,<empty>,,209,3,CPPASTProblemDeclaration,,<empty>
38347,UNKNOWN,-1,,"BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(PatternAbbreviator)
		LOG4CXX_CAST_ENTRY_CHAIN(NameAbbreviator)
		END_LOG4CXX_CAST_MAP()
		/**
		 * Create PatternAbbreviator.
		 *
		 * @param fragments element abbreviation patterns.
		 */
		PatternAbbreviator(const std::vector<PatternAbbreviatorFragment>& fragments1) :
			fragments(fragments1)
		{
			if (fragments1.size() == 0)
			{
				throw IllegalArgumentException(LOG4CXX_STR(""fragments parameter must contain at least one element""));
			}
		}",3,<empty>,,210,4,CPPASTProblemDeclaration,,<empty>
38420,UNKNOWN,7,,),40,<empty>,,261,7,CPPASTProblemDeclaration,,<empty>
38422,UNKNOWN,9,,),47,<empty>,,262,9,CPPASTProblemDeclaration,,<empty>
38424,UNKNOWN,11,,),44,<empty>,,263,11,CPPASTProblemDeclaration,,<empty>
38664,UNKNOWN,3,,),46,<empty>,,42,3,CPPASTProblemDeclaration,,<empty>
38708,UNKNOWN,1,,NamePatternConverterPrivate *,2,<empty>,,71,1,CPPASTTypeId,,<empty>
38922,UNKNOWN,1,,int,11,<empty>,,117,1,CPPASTTypeId,,<empty>
39225,UNKNOWN,2,,),45,<empty>,,28,2,CPPASTProblemDeclaration,,<empty>
39394,UNKNOWN,1,,apr_pool_t*,22,<empty>,,113,1,CPPASTTypeId,,<empty>
39406,UNKNOWN,7,,),38,<empty>,,117,7,CPPASTProblemDeclaration,,<empty>
39684,UNKNOWN,1,,size_t,18,<empty>,,178,1,CPPASTTypeId,,<empty>
39790,UNKNOWN,1,,ODBCAppenderPriv *,3,<empty>,,200,1,CPPASTTypeId,,<empty>
39864,UNKNOWN,1,,ODBCAppenderPriv *,6,<empty>,,377,1,CPPASTTypeId,,<empty>
39884,UNKNOWN,1,,ODBCAppenderPriv *,3,<empty>,,390,1,CPPASTTypeId,,<empty>
39902,UNKNOWN,1,,ODBCAppenderPriv *,2,<empty>,,408,1,CPPASTTypeId,,<empty>
39919,UNKNOWN,1,,ODBCAppenderPriv *,24,<empty>,,586,1,CPPASTTypeId,,<empty>
39934,UNKNOWN,1,,ODBCAppenderPriv *,7,<empty>,,588,1,CPPASTTypeId,,<empty>
39948,UNKNOWN,1,,ODBCAppenderPriv *,4,<empty>,,589,1,CPPASTTypeId,,<empty>
39963,UNKNOWN,1,,ODBCAppenderPriv *,2,<empty>,,611,1,CPPASTTypeId,,<empty>
39980,UNKNOWN,1,,ODBCAppenderPriv *,5,<empty>,,616,1,CPPASTTypeId,,<empty>
39998,UNKNOWN,1,,unsigned short*,11,<empty>,,630,1,CPPASTTypeId,,<empty>
40054,UNKNOWN,1,,unsigned short,18,<empty>,,641,1,CPPASTTypeId,,<empty>
40062,UNKNOWN,1,,unsigned char,23,<empty>,,645,1,CPPASTTypeId,,<empty>
40070,UNKNOWN,1,,unsigned char,23,<empty>,,646,1,CPPASTTypeId,,<empty>
40103,UNKNOWN,1,,unsigned short,18,<empty>,,649,1,CPPASTTypeId,,<empty>
40110,UNKNOWN,1,,unsigned short,18,<empty>,,650,1,CPPASTTypeId,,<empty>
40125,UNKNOWN,1,,ODBCAppenderPriv *,9,<empty>,,659,1,CPPASTTypeId,,<empty>
40141,UNKNOWN,1,,ODBCAppenderPriv *,2,<empty>,,664,1,CPPASTTypeId,,<empty>
40158,UNKNOWN,1,,ODBCAppenderPriv *,2,<empty>,,669,1,CPPASTTypeId,,<empty>
40175,UNKNOWN,1,,ODBCAppenderPriv *,2,<empty>,,674,1,CPPASTTypeId,,<empty>
40192,UNKNOWN,1,,ODBCAppenderPriv *,2,<empty>,,679,1,CPPASTTypeId,,<empty>
40208,UNKNOWN,1,,ODBCAppenderPriv *,9,<empty>,,684,1,CPPASTTypeId,,<empty>
40223,UNKNOWN,1,,ODBCAppenderPriv *,9,<empty>,,689,1,CPPASTTypeId,,<empty>
40238,UNKNOWN,1,,ODBCAppenderPriv *,9,<empty>,,694,1,CPPASTTypeId,,<empty>
40253,UNKNOWN,1,,ODBCAppenderPriv *,9,<empty>,,699,1,CPPASTTypeId,,<empty>
40275,UNKNOWN,2,,),46,<empty>,,27,2,CPPASTProblemDeclaration,,<empty>
40608,UNKNOWN,1,,int,10,<empty>,,156,1,CPPASTTypeId,,<empty>
40762,UNKNOWN,1,,LogString,19,<empty>,,207,1,CPPASTTypeId,,<empty>
40883,UNKNOWN,1,,logchar,23,<empty>,,250,1,CPPASTTypeId,,<empty>
40910,UNKNOWN,1,,logchar,20,<empty>,,255,1,CPPASTTypeId,,<empty>
41042,UNKNOWN,1,,LogString,7,<empty>,,317,1,CPPASTTypeId,,<empty>
41083,UNKNOWN,1,,LogString,18,<empty>,,327,1,CPPASTTypeId,,<empty>
41111,UNKNOWN,1,,Level::LevelClass&,5,<empty>,,339,1,CPPASTTypeId,,<empty>
41131,UNKNOWN,1,,LogString,18,<empty>,,344,1,CPPASTTypeId,,<empty>
41199,UNKNOWN,1,,LogString,6,<empty>,,373,1,CPPASTTypeId,,<empty>
41421,UNKNOWN,2,,),38,<empty>,,25,2,CPPASTProblemDeclaration,,<empty>
41448,UNKNOWN,2,,),44,<empty>,,28,2,CPPASTProblemDeclaration,,<empty>
41553,UNKNOWN,1,,char*,19,<empty>,,85,1,CPPASTTypeId,,<empty>
41688,UNKNOWN,2,,),42,<empty>,,26,2,CPPASTProblemDeclaration,,<empty>
41853,UNKNOWN,3,,),39,<empty>,,94,3,CPPASTProblemDeclaration,,<empty>
41941,UNKNOWN,1,,int,21,<empty>,,134,1,CPPASTTypeId,,<empty>
43954,UNKNOWN,1,,char*,10,<empty>,,82,1,CPPASTTypeId,,<empty>
44828,UNKNOWN,3,,),52,<empty>,,45,3,CPPASTProblemDeclaration,,<empty>
44908,UNKNOWN,1,,PropertiesPatternConverterPrivate *,6,<empty>,,75,1,CPPASTTypeId,,<empty>
44923,UNKNOWN,1,,logchar,25,<empty>,,77,1,CPPASTTypeId,,<empty>
44955,UNKNOWN,1,,logchar,26,<empty>,,85,1,CPPASTTypeId,,<empty>
44969,UNKNOWN,1,,logchar,26,<empty>,,87,1,CPPASTTypeId,,<empty>
44984,UNKNOWN,1,,logchar,26,<empty>,,89,1,CPPASTTypeId,,<empty>
44992,UNKNOWN,1,,logchar,25,<empty>,,92,1,CPPASTTypeId,,<empty>
45004,UNKNOWN,1,,PropertiesPatternConverterPrivate *,17,<empty>,,97,1,CPPASTTypeId,,<empty>
45091,UNKNOWN,5,,),46,<empty>,,75,5,CPPASTProblemDeclaration,,<empty>
45141,UNKNOWN,1,,LogString,19,<empty>,,102,1,CPPASTTypeId,,<empty>
45189,UNKNOWN,1,,LogString,19,<empty>,,116,1,CPPASTTypeId,,<empty>
45366,UNKNOWN,1,,LogString,19,<empty>,,179,1,CPPASTTypeId,,<empty>
45820,UNKNOWN,1,,LogString,17,<empty>,,316,1,CPPASTTypeId,,<empty>
45856,UNKNOWN,1,,LogString,19,<empty>,,323,1,CPPASTTypeId,,<empty>
45889,UNKNOWN,1,,LogString,18,<empty>,,341,1,CPPASTTypeId,,<empty>
45941,UNKNOWN,1,,LogString,18,<empty>,,360,1,CPPASTTypeId,,<empty>
46000,UNKNOWN,1,,LogString,20,<empty>,,379,1,CPPASTTypeId,,<empty>
46029,UNKNOWN,1,,LogString,19,<empty>,,387,1,CPPASTTypeId,,<empty>
46134,UNKNOWN,1,,LogString,18,<empty>,,427,1,CPPASTTypeId,,<empty>
46252,UNKNOWN,1,,LogString,18,<empty>,,456,1,CPPASTTypeId,,<empty>
46328,UNKNOWN,1,,LogString,20,<empty>,,478,1,CPPASTTypeId,,<empty>
46352,UNKNOWN,1,,LogString,20,<empty>,,482,1,CPPASTTypeId,,<empty>
46436,UNKNOWN,1,,LogString,21,<empty>,,502,1,CPPASTTypeId,,<empty>
46516,UNKNOWN,1,,LogString,21,<empty>,,520,1,CPPASTTypeId,,<empty>
46551,UNKNOWN,1,,LogString,18,<empty>,,528,1,CPPASTTypeId,,<empty>
46601,UNKNOWN,2,,),48,<empty>,,28,2,CPPASTProblemDeclaration,,<empty>
46619,UNKNOWN,1,,PropertyResourceBundle*,52,<empty>,,39,1,CPPASTTypeId,,<empty>
46644,UNKNOWN,1,,PropertyResourceBundle*,33,<empty>,,50,1,CPPASTTypeId,,<empty>
46924,UNKNOWN,2,,),32,<empty>,,23,2,CPPASTProblemDeclaration,,<empty>
46989,UNKNOWN,2,,),54,<empty>,,29,2,CPPASTProblemDeclaration,,<empty>
47056,UNKNOWN,2,,),40,<empty>,,28,2,CPPASTProblemDeclaration,,<empty>
47288,UNKNOWN,1,,LogString,6,<empty>,,120,1,CPPASTTypeId,,<empty>
47337,UNKNOWN,3,,),45,<empty>,,66,3,CPPASTProblemDeclaration,,<empty>
47444,UNKNOWN,1,,RollingFileAppenderPriv *,61,<empty>,,107,1,CPPASTTypeId,,<empty>
47477,UNKNOWN,1,,RollingFileAppenderPriv *,57,<empty>,,114,1,CPPASTTypeId,,<empty>
47506,UNKNOWN,1,,RollingFileAppenderPriv *,3,<empty>,,119,1,CPPASTTypeId,,<empty>
47545,UNKNOWN,1,,RollingFileAppenderPriv *,62,<empty>,,127,1,CPPASTTypeId,,<empty>
47578,UNKNOWN,1,,RollingFileAppenderPriv *,58,<empty>,,134,1,CPPASTTypeId,,<empty>
47599,UNKNOWN,1,,RollingFileAppenderPriv *,3,<empty>,,138,1,CPPASTTypeId,,<empty>
47680,UNKNOWN,1,,logchar,23,<empty>,,162,1,CPPASTTypeId,,<empty>
47727,UNKNOWN,1,,logchar,21,<empty>,,181,1,CPPASTTypeId,,<empty>
47749,UNKNOWN,1,,RollingFileAppenderPriv *,55,<empty>,,188,1,CPPASTTypeId,,<empty>
47770,UNKNOWN,1,,RollingFileAppenderPriv *,3,<empty>,,192,1,CPPASTTypeId,,<empty>
47794,UNKNOWN,1,,RollingFileAppenderPriv *,7,<empty>,,202,1,CPPASTTypeId,,<empty>
47813,UNKNOWN,1,,RollingFileAppenderPriv *,6,<empty>,,205,1,CPPASTTypeId,,<empty>
47841,UNKNOWN,1,,RollingFileAppenderPriv *,3,<empty>,,208,1,CPPASTTypeId,,<empty>
47854,UNKNOWN,1,,RollingFileAppenderPriv *,7,<empty>,,214,1,CPPASTTypeId,,<empty>
47874,UNKNOWN,1,,RollingFileAppenderPriv *,65,<empty>,,216,1,CPPASTTypeId,,<empty>
47890,UNKNOWN,1,,RollingFileAppenderPriv *,4,<empty>,,220,1,CPPASTTypeId,,<empty>
47903,UNKNOWN,1,,RollingFileAppenderPriv *,7,<empty>,,224,1,CPPASTTypeId,,<empty>
47922,UNKNOWN,1,,RollingFileAppenderPriv *,6,<empty>,,227,1,CPPASTTypeId,,<empty>
47935,UNKNOWN,1,,RollingFileAppenderPriv *,3,<empty>,,228,1,CPPASTTypeId,,<empty>
47959,UNKNOWN,1,,RollingFileAppenderPriv *,46,<empty>,,232,1,CPPASTTypeId,,<empty>
47971,UNKNOWN,1,,RollingFileAppenderPriv *,3,<empty>,,233,1,CPPASTTypeId,,<empty>
47985,UNKNOWN,1,,RollingFileAppenderPriv *,3,<empty>,,234,1,CPPASTTypeId,,<empty>
48004,UNKNOWN,1,,RollingFileAppenderPriv *,5,<empty>,,239,1,CPPASTTypeId,,<empty>
48040,UNKNOWN,1,,RollingFileAppenderPriv *,5,<empty>,,250,1,CPPASTTypeId,,<empty>
48055,UNKNOWN,1,,RollingFileAppenderPriv *,5,<empty>,,251,1,CPPASTTypeId,,<empty>
48095,UNKNOWN,1,,RollingFileAppenderPriv *,5,<empty>,,269,1,CPPASTTypeId,,<empty>
48113,UNKNOWN,1,,RollingFileAppenderPriv *,5,<empty>,,273,1,CPPASTTypeId,,<empty>
48153,UNKNOWN,1,,RollingFileAppenderPriv *,45,<empty>,,304,1,CPPASTTypeId,,<empty>
48173,UNKNOWN,1,,RollingFileAppenderPriv *,6,<empty>,,313,1,CPPASTTypeId,,<empty>
48192,UNKNOWN,1,,RollingFileAppenderPriv *,39,<empty>,,319,1,CPPASTTypeId,,<empty>
48277,UNKNOWN,1,,RollingFileAppenderPriv *,10,<empty>,,343,1,CPPASTTypeId,,<empty>
48301,UNKNOWN,1,,RollingFileAppenderPriv *,10,<empty>,,351,1,CPPASTTypeId,,<empty>
48326,UNKNOWN,1,,RollingFileAppenderPriv *,10,<empty>,,355,1,CPPASTTypeId,,<empty>
48362,UNKNOWN,1,,RollingFileAppenderPriv *,10,<empty>,,370,1,CPPASTTypeId,,<empty>
48372,UNKNOWN,1,,RollingFileAppenderPriv *,29,<empty>,,370,1,CPPASTTypeId,,<empty>
48391,UNKNOWN,1,,RollingFileAppenderPriv *,48,<empty>,,375,1,CPPASTTypeId,,<empty>
48401,UNKNOWN,1,,RollingFileAppenderPriv *,67,<empty>,,375,1,CPPASTTypeId,,<empty>
48494,UNKNOWN,1,,RollingFileAppenderPriv *,10,<empty>,,405,1,CPPASTTypeId,,<empty>
48518,UNKNOWN,1,,RollingFileAppenderPriv *,10,<empty>,,413,1,CPPASTTypeId,,<empty>
48543,UNKNOWN,1,,RollingFileAppenderPriv *,10,<empty>,,417,1,CPPASTTypeId,,<empty>
48598,UNKNOWN,1,,RollingFileAppenderPriv *,6,<empty>,,442,1,CPPASTTypeId,,<empty>
48623,UNKNOWN,1,,RollingFileAppenderPriv *,3,<empty>,,458,1,CPPASTTypeId,,<empty>
48642,UNKNOWN,1,,RollingFileAppenderPriv *,4,<empty>,,468,1,CPPASTTypeId,,<empty>
48679,UNKNOWN,1,,RollingFileAppenderPriv *,4,<empty>,,477,1,CPPASTTypeId,,<empty>
48702,UNKNOWN,1,,RollingFileAppenderPriv *,9,<empty>,,489,1,CPPASTTypeId,,<empty>
48717,UNKNOWN,1,,RollingFileAppenderPriv *,9,<empty>,,497,1,CPPASTTypeId,,<empty>
48733,UNKNOWN,1,,RollingFileAppenderPriv *,2,<empty>,,505,1,CPPASTTypeId,,<empty>
48750,UNKNOWN,1,,RollingFileAppenderPriv *,2,<empty>,,513,1,CPPASTTypeId,,<empty>
48857,UNKNOWN,1,,RollingFileAppenderPriv *,9,<empty>,,611,1,CPPASTTypeId,,<empty>
48873,UNKNOWN,1,,RollingFileAppenderPriv *,2,<empty>,,620,1,CPPASTTypeId,,<empty>
48889,UNKNOWN,1,,IMPLEMENT_LOG4CXX_OBJECT(RollingPolicy),1,<empty>,,23,1,CPPASTProblemDeclaration,,<empty>
48918,UNKNOWN,2,,),43,<empty>,,35,2,CPPASTProblemDeclaration,,<empty>
49147,UNKNOWN,1,,int,29,<empty>,,127,1,CPPASTTypeId,,<empty>
49292,UNKNOWN,2,,),45,<empty>,,25,2,CPPASTProblemDeclaration,,<empty>
49480,UNKNOWN,2,,),59,<empty>,,28,2,CPPASTProblemDeclaration,,<empty>
49707,UNKNOWN,1,,logchar,28,<empty>,,184,1,CPPASTTypeId,,<empty>
49761,UNKNOWN,1,,logchar,17,<empty>,,230,1,CPPASTTypeId,,<empty>
49769,UNKNOWN,1,,logchar,17,<empty>,,231,1,CPPASTTypeId,,<empty>
49829,UNKNOWN,1,,logchar,72,<empty>,,255,1,CPPASTTypeId,,<empty>
50273,UNKNOWN,1,,logchar,19,<empty>,,597,1,CPPASTTypeId,,<empty>
50899,UNKNOWN,2,,),38,<empty>,,25,2,CPPASTProblemDeclaration,,<empty>
50949,UNKNOWN,2,,),51,<empty>,,26,2,CPPASTProblemDeclaration,,<empty>
51053,UNKNOWN,-1,,"class LOG4CXX_EXPORT DefaultEvaluator :
	public virtual spi::TriggeringEventEvaluator,
	public virtual helpers::Object
{
	public:
		DECLARE_LOG4CXX_OBJECT(DefaultEvaluator)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(DefaultEvaluator)
		LOG4CXX_CAST_ENTRY(spi::TriggeringEventEvaluator)
		END_LOG4CXX_CAST_MAP()

		DefaultEvaluator();

		/**
		Is this <code>event</code> the e-mail triggering event?
		<p>This method returns <code>true</code>, if the event level
		has ERROR level or higher. Otherwise it returns
		<code>false</code>.
		*/
		bool isTriggeringEvent(const spi::LoggingEventPtr& event) override;
	private:
		DefaultEvaluator(const DefaultEvaluator&);
		DefaultEvaluator& operator=(const DefaultEvaluator&);
};",1,<empty>,,352,1,CPPASTProblemDeclaration,,<empty>
51055,UNKNOWN,3,,),42,<empty>,,380,3,CPPASTProblemDeclaration,,<empty>
51057,UNKNOWN,5,,),38,<empty>,,381,5,CPPASTProblemDeclaration,,<empty>
51129,UNKNOWN,1,,SMTPPriv *,9,<empty>,,452,1,CPPASTTypeId,,<empty>
51145,UNKNOWN,1,,SMTPPriv *,2,<empty>,,457,1,CPPASTTypeId,,<empty>
51161,UNKNOWN,1,,SMTPPriv *,9,<empty>,,463,1,CPPASTTypeId,,<empty>
51177,UNKNOWN,1,,SMTPPriv *,2,<empty>,,468,1,CPPASTTypeId,,<empty>
51193,UNKNOWN,1,,SMTPPriv *,9,<empty>,,473,1,CPPASTTypeId,,<empty>
51209,UNKNOWN,1,,SMTPPriv *,2,<empty>,,478,1,CPPASTTypeId,,<empty>
51225,UNKNOWN,1,,SMTPPriv *,9,<empty>,,483,1,CPPASTTypeId,,<empty>
51241,UNKNOWN,1,,SMTPPriv *,2,<empty>,,488,1,CPPASTTypeId,,<empty>
51257,UNKNOWN,1,,SMTPPriv *,9,<empty>,,493,1,CPPASTTypeId,,<empty>
51273,UNKNOWN,1,,SMTPPriv *,2,<empty>,,498,1,CPPASTTypeId,,<empty>
51289,UNKNOWN,1,,SMTPPriv *,9,<empty>,,503,1,CPPASTTypeId,,<empty>
51305,UNKNOWN,1,,SMTPPriv *,2,<empty>,,508,1,CPPASTTypeId,,<empty>
51321,UNKNOWN,1,,SMTPPriv *,9,<empty>,,513,1,CPPASTTypeId,,<empty>
51337,UNKNOWN,1,,SMTPPriv *,2,<empty>,,518,1,CPPASTTypeId,,<empty>
51559,UNKNOWN,1,,unsigned int,15,<empty>,,585,1,CPPASTTypeId,,<empty>
51590,UNKNOWN,1,,SMTPPriv *,6,<empty>,,602,1,CPPASTTypeId,,<empty>
51602,UNKNOWN,1,,SMTPPriv *,3,<empty>,,604,1,CPPASTTypeId,,<empty>
51617,UNKNOWN,1,,SMTPPriv *,82,<empty>,,604,1,CPPASTTypeId,,<empty>
51634,UNKNOWN,1,,SMTPPriv *,6,<empty>,,608,1,CPPASTTypeId,,<empty>
51648,UNKNOWN,1,,SMTPPriv *,3,<empty>,,610,1,CPPASTTypeId,,<empty>
51663,UNKNOWN,1,,SMTPPriv *,4,<empty>,,611,1,CPPASTTypeId,,<empty>
51681,UNKNOWN,1,,SMTPPriv *,6,<empty>,,615,1,CPPASTTypeId,,<empty>
51695,UNKNOWN,1,,SMTPPriv *,3,<empty>,,617,1,CPPASTTypeId,,<empty>
51710,UNKNOWN,1,,SMTPPriv *,4,<empty>,,618,1,CPPASTTypeId,,<empty>
51730,UNKNOWN,1,,SMTPPriv *,6,<empty>,,622,1,CPPASTTypeId,,<empty>
51743,UNKNOWN,1,,SMTPPriv *,27,<empty>,,622,1,CPPASTTypeId,,<empty>
51756,UNKNOWN,1,,SMTPPriv *,48,<empty>,,622,1,CPPASTTypeId,,<empty>
51770,UNKNOWN,1,,SMTPPriv *,3,<empty>,,624,1,CPPASTTypeId,,<empty>
51785,UNKNOWN,1,,SMTPPriv *,4,<empty>,,625,1,CPPASTTypeId,,<empty>
51803,UNKNOWN,1,,SMTPPriv *,25,<empty>,,629,1,CPPASTTypeId,,<empty>
51818,UNKNOWN,1,,SMTPPriv *,25,<empty>,,630,1,CPPASTTypeId,,<empty>
51833,UNKNOWN,1,,SMTPPriv *,25,<empty>,,631,1,CPPASTTypeId,,<empty>
51848,UNKNOWN,1,,SMTPPriv *,25,<empty>,,632,1,CPPASTTypeId,,<empty>
51862,UNKNOWN,1,,SMTPPriv *,2,<empty>,,635,1,CPPASTTypeId,,<empty>
51913,UNKNOWN,1,,SMTPPriv *,2,<empty>,,662,1,CPPASTTypeId,,<empty>
51928,UNKNOWN,1,,SMTPPriv *,6,<empty>,,664,1,CPPASTTypeId,,<empty>
51956,UNKNOWN,1,,SMTPPriv *,2,<empty>,,709,1,CPPASTTypeId,,<empty>
51972,UNKNOWN,1,,SMTPPriv *,9,<empty>,,714,1,CPPASTTypeId,,<empty>
51988,UNKNOWN,1,,SMTPPriv *,2,<empty>,,719,1,CPPASTTypeId,,<empty>
52004,UNKNOWN,1,,SMTPPriv *,9,<empty>,,724,1,CPPASTTypeId,,<empty>
52020,UNKNOWN,1,,SMTPPriv *,2,<empty>,,729,1,CPPASTTypeId,,<empty>
52036,UNKNOWN,1,,SMTPPriv *,9,<empty>,,734,1,CPPASTTypeId,,<empty>
52052,UNKNOWN,1,,SMTPPriv *,2,<empty>,,739,1,CPPASTTypeId,,<empty>
52075,UNKNOWN,1,,SMTPPriv *,9,<empty>,,787,1,CPPASTTypeId,,<empty>
52089,UNKNOWN,1,,SMTPPriv *,47,<empty>,,787,1,CPPASTTypeId,,<empty>
52106,UNKNOWN,1,,SMTPPriv *,9,<empty>,,792,1,CPPASTTypeId,,<empty>
52124,UNKNOWN,1,,SMTPPriv *,2,<empty>,,797,1,CPPASTTypeId,,<empty>
52141,UNKNOWN,1,,SMTPPriv *,2,<empty>,,809,1,CPPASTTypeId,,<empty>
52154,UNKNOWN,1,,SMTPPriv *,2,<empty>,,810,1,CPPASTTypeId,,<empty>
52184,UNKNOWN,1,,SMTPPriv *,2,<empty>,,823,1,CPPASTTypeId,,<empty>
52206,UNKNOWN,1,,SMTPPriv *,9,<empty>,,828,1,CPPASTTypeId,,<empty>
52230,UNKNOWN,2,,),32,<empty>,,27,2,CPPASTProblemDeclaration,,<empty>
52359,UNKNOWN,1,,SocketAppenderSkeletonPriv *,45,<empty>,,71,1,CPPASTTypeId,,<empty>
52370,UNKNOWN,1,,SocketAppenderSkeletonPriv *,6,<empty>,,73,1,CPPASTTypeId,,<empty>
52383,UNKNOWN,1,,SocketAppenderSkeletonPriv *,2,<empty>,,78,1,CPPASTTypeId,,<empty>
52395,UNKNOWN,1,,SocketAppenderSkeletonPriv *,10,<empty>,,79,1,CPPASTTypeId,,<empty>
52415,UNKNOWN,1,,SocketAppenderSkeletonPriv *,38,<empty>,,82,1,CPPASTTypeId,,<empty>
52427,UNKNOWN,1,,SocketAppenderSkeletonPriv *,3,<empty>,,83,1,CPPASTTypeId,,<empty>
52441,UNKNOWN,1,,SocketAppenderSkeletonPriv *,7,<empty>,,86,1,CPPASTTypeId,,<empty>
52455,UNKNOWN,1,,SocketAppenderSkeletonPriv *,3,<empty>,,88,1,CPPASTTypeId,,<empty>
52473,UNKNOWN,1,,SocketAppenderSkeletonPriv *,6,<empty>,,94,1,CPPASTTypeId,,<empty>
52494,UNKNOWN,1,,SocketAppenderSkeletonPriv *,4,<empty>,,97,1,CPPASTTypeId,,<empty>
52520,UNKNOWN,1,,SocketAppenderSkeletonPriv *,7,<empty>,,106,1,CPPASTTypeId,,<empty>
52537,UNKNOWN,1,,SocketAppenderSkeletonPriv *,27,<empty>,,107,1,CPPASTTypeId,,<empty>
52565,UNKNOWN,1,,SocketAppenderSkeletonPriv *,38,<empty>,,110,1,CPPASTTypeId,,<empty>
52575,UNKNOWN,1,,SocketAppenderSkeletonPriv *,54,<empty>,,110,1,CPPASTTypeId,,<empty>
52598,UNKNOWN,1,,SocketAppenderSkeletonPriv *,7,<empty>,,116,1,CPPASTTypeId,,<empty>
52615,UNKNOWN,1,,SocketAppenderSkeletonPriv *,27,<empty>,,117,1,CPPASTTypeId,,<empty>
52738,UNKNOWN,1,,SocketAppenderSkeletonPriv *,45,<empty>,,152,1,CPPASTTypeId,,<empty>
52752,UNKNOWN,1,,SocketAppenderSkeletonPriv *,8,<empty>,,154,1,CPPASTTypeId,,<empty>
52771,UNKNOWN,1,,SocketAppenderSkeletonPriv *,3,<empty>,,158,1,CPPASTTypeId,,<empty>
52815,UNKNOWN,1,,SocketAppenderSkeletonPriv *,7,<empty>,,172,1,CPPASTTypeId,,<empty>
52832,UNKNOWN,1,,SocketAppenderSkeletonPriv *,27,<empty>,,173,1,CPPASTTypeId,,<empty>
52859,UNKNOWN,1,,SocketAppenderSkeletonPriv *,28,<empty>,,176,1,CPPASTTypeId,,<empty>
52869,UNKNOWN,1,,SocketAppenderSkeletonPriv *,44,<empty>,,176,1,CPPASTTypeId,,<empty>
52900,UNKNOWN,1,,SocketAppenderSkeletonPriv *,7,<empty>,,184,1,CPPASTTypeId,,<empty>
52923,UNKNOWN,1,,SocketAppenderSkeletonPriv *,7,<empty>,,190,1,CPPASTTypeId,,<empty>
52940,UNKNOWN,1,,SocketAppenderSkeletonPriv *,27,<empty>,,191,1,CPPASTTypeId,,<empty>
52964,UNKNOWN,1,,SocketAppenderSkeletonPriv *,7,<empty>,,196,1,CPPASTTypeId,,<empty>
52984,UNKNOWN,1,,SocketAppenderSkeletonPriv *,27,<empty>,,199,1,CPPASTTypeId,,<empty>
53004,UNKNOWN,1,,SocketAppenderSkeletonPriv *,7,<empty>,,201,1,CPPASTTypeId,,<empty>
53021,UNKNOWN,1,,SocketAppenderSkeletonPriv *,27,<empty>,,202,1,CPPASTTypeId,,<empty>
53051,UNKNOWN,1,,SocketAppenderSkeletonPriv *,39,<empty>,,206,1,CPPASTTypeId,,<empty>
53062,UNKNOWN,1,,SocketAppenderSkeletonPriv *,8,<empty>,,207,1,CPPASTTypeId,,<empty>
53080,UNKNOWN,1,,SocketAppenderSkeletonPriv *,68,<empty>,,207,1,CPPASTTypeId,,<empty>
53106,UNKNOWN,1,,SocketAppenderSkeletonPriv *,9,<empty>,,216,1,CPPASTTypeId,,<empty>
53124,UNKNOWN,1,,SocketAppenderSkeletonPriv *,2,<empty>,,221,1,CPPASTTypeId,,<empty>
53143,UNKNOWN,1,,SocketAppenderSkeletonPriv *,2,<empty>,,222,1,CPPASTTypeId,,<empty>
53160,UNKNOWN,1,,SocketAppenderSkeletonPriv *,9,<empty>,,227,1,CPPASTTypeId,,<empty>
53176,UNKNOWN,1,,SocketAppenderSkeletonPriv *,2,<empty>,,232,1,CPPASTTypeId,,<empty>
53192,UNKNOWN,1,,SocketAppenderSkeletonPriv *,9,<empty>,,237,1,CPPASTTypeId,,<empty>
53208,UNKNOWN,1,,SocketAppenderSkeletonPriv *,2,<empty>,,242,1,CPPASTTypeId,,<empty>
53224,UNKNOWN,1,,SocketAppenderSkeletonPriv *,9,<empty>,,247,1,CPPASTTypeId,,<empty>
53240,UNKNOWN,1,,SocketAppenderSkeletonPriv *,2,<empty>,,252,1,CPPASTTypeId,,<empty>
53256,UNKNOWN,1,,SocketAppenderSkeletonPriv *,9,<empty>,,257,1,CPPASTTypeId,,<empty>
53285,UNKNOWN,3,,),44,<empty>,,35,3,CPPASTProblemDeclaration,,<empty>
53329,UNKNOWN,1,,char*,19,<empty>,,57,1,CPPASTTypeId,,<empty>
54043,UNKNOWN,3,,),43,<empty>,,42,3,CPPASTProblemDeclaration,,<empty>
54072,UNKNOWN,1,,StringMatchFilterPrivate *,3,<empty>,,58,1,CPPASTTypeId,,<empty>
54097,UNKNOWN,1,,StringMatchFilterPrivate *,3,<empty>,,63,1,CPPASTTypeId,,<empty>
54112,UNKNOWN,1,,StringMatchFilterPrivate *,59,<empty>,,63,1,CPPASTTypeId,,<empty>
54142,UNKNOWN,1,,StringMatchFilterPrivate *,21,<empty>,,72,1,CPPASTTypeId,,<empty>
54164,UNKNOWN,1,,StringMatchFilterPrivate *,16,<empty>,,78,1,CPPASTTypeId,,<empty>
54185,UNKNOWN,1,,StringMatchFilterPrivate *,7,<empty>,,85,1,CPPASTTypeId,,<empty>
54213,UNKNOWN,1,,StringMatchFilterPrivate *,2,<empty>,,98,1,CPPASTTypeId,,<empty>
54230,UNKNOWN,1,,StringMatchFilterPrivate *,9,<empty>,,103,1,CPPASTTypeId,,<empty>
54246,UNKNOWN,1,,StringMatchFilterPrivate *,2,<empty>,,108,1,CPPASTTypeId,,<empty>
54262,UNKNOWN,1,,StringMatchFilterPrivate *,9,<empty>,,113,1,CPPASTTypeId,,<empty>
54439,UNKNOWN,2,,),40,<empty>,,38,2,CPPASTProblemDeclaration,,<empty>
54483,UNKNOWN,1,,SyslogAppenderPriv *,2,<empty>,,72,1,CPPASTTypeId,,<empty>
54495,UNKNOWN,1,,SyslogAppenderPriv *,6,<empty>,,74,1,CPPASTTypeId,,<empty>
54507,UNKNOWN,1,,SyslogAppenderPriv *,3,<empty>,,76,1,CPPASTTypeId,,<empty>
54523,UNKNOWN,1,,SyslogAppenderPriv *,2,<empty>,,82,1,CPPASTTypeId,,<empty>
54534,UNKNOWN,1,,SyslogAppenderPriv *,41,<empty>,,82,1,CPPASTTypeId,,<empty>
54547,UNKNOWN,1,,SyslogAppenderPriv *,6,<empty>,,84,1,CPPASTTypeId,,<empty>
54568,UNKNOWN,1,,SyslogAppenderPriv *,26,<empty>,,88,1,CPPASTTypeId,,<empty>
54592,UNKNOWN,1,,SyslogAppenderPriv *,3,<empty>,,91,1,CPPASTTypeId,,<empty>
54604,UNKNOWN,1,,SyslogAppenderPriv *,3,<empty>,,92,1,CPPASTTypeId,,<empty>
54619,UNKNOWN,1,,SyslogAppenderPriv *,3,<empty>,,96,1,CPPASTTypeId,,<empty>
55031,UNKNOWN,1,,SyslogAppenderPriv *,2,<empty>,,283,1,CPPASTTypeId,,<empty>
55064,UNKNOWN,1,,SyslogAppenderPriv *,20,<empty>,,294,1,CPPASTTypeId,,<empty>
55096,UNKNOWN,1,,SyslogAppenderPriv *,38,<empty>,,300,1,CPPASTTypeId,,<empty>
55164,UNKNOWN,1,,int,57,<empty>,,319,1,CPPASTTypeId,,<empty>
55190,UNKNOWN,1,,SyslogAppenderPriv *,6,<empty>,,350,1,CPPASTTypeId,,<empty>
55202,UNKNOWN,1,,SyslogAppenderPriv *,3,<empty>,,352,1,CPPASTTypeId,,<empty>
55217,UNKNOWN,1,,SyslogAppenderPriv *,4,<empty>,,353,1,CPPASTTypeId,,<empty>
55257,UNKNOWN,1,,SyslogAppenderPriv *,27,<empty>,,362,1,CPPASTTypeId,,<empty>
55278,UNKNOWN,1,,logchar,19,<empty>,,363,1,CPPASTTypeId,,<empty>
55285,UNKNOWN,1,,SyslogAppenderPriv *,7,<empty>,,365,1,CPPASTTypeId,,<empty>
55300,UNKNOWN,1,,SyslogAppenderPriv *,16,<empty>,,367,1,CPPASTTypeId,,<empty>
55318,UNKNOWN,1,,SyslogAppenderPriv *,3,<empty>,,371,1,CPPASTTypeId,,<empty>
55404,UNKNOWN,1,,SyslogAppenderPriv *,6,<empty>,,401,1,CPPASTTypeId,,<empty>
55419,UNKNOWN,1,,SyslogAppenderPriv *,3,<empty>,,403,1,CPPASTTypeId,,<empty>
55482,UNKNOWN,1,,SyslogAppenderPriv *,4,<empty>,,429,1,CPPASTTypeId,,<empty>
55505,UNKNOWN,1,,SyslogAppenderPriv *,4,<empty>,,433,1,CPPASTTypeId,,<empty>
55523,UNKNOWN,1,,SyslogAppenderPriv *,2,<empty>,,437,1,CPPASTTypeId,,<empty>
55535,UNKNOWN,1,,SyslogAppenderPriv *,2,<empty>,,438,1,CPPASTTypeId,,<empty>
55559,UNKNOWN,1,,SyslogAppenderPriv *,2,<empty>,,449,1,CPPASTTypeId,,<empty>
55573,UNKNOWN,1,,SyslogAppenderPriv *,6,<empty>,,451,1,CPPASTTypeId,,<empty>
55600,UNKNOWN,1,,SyslogAppenderPriv *,3,<empty>,,455,1,CPPASTTypeId,,<empty>
55620,UNKNOWN,1,,SyslogAppenderPriv *,9,<empty>,,463,1,CPPASTTypeId,,<empty>
55636,UNKNOWN,1,,SyslogAppenderPriv *,27,<empty>,,468,1,CPPASTTypeId,,<empty>
55652,UNKNOWN,1,,SyslogAppenderPriv *,2,<empty>,,473,1,CPPASTTypeId,,<empty>
55668,UNKNOWN,1,,SyslogAppenderPriv *,9,<empty>,,478,1,CPPASTTypeId,,<empty>
55684,UNKNOWN,1,,SyslogAppenderPriv *,2,<empty>,,483,1,CPPASTTypeId,,<empty>
55700,UNKNOWN,1,,SyslogAppenderPriv *,9,<empty>,,488,1,CPPASTTypeId,,<empty>
55761,UNKNOWN,1,,LogString,19,<empty>,,48,1,CPPASTTypeId,,<empty>
55786,UNKNOWN,1,,LogString,19,<empty>,,58,1,CPPASTTypeId,,<empty>
55830,UNKNOWN,1,,void*,6,<empty>,,72,1,CPPASTTypeId,,<empty>
55836,UNKNOWN,1,,int,27,<empty>,,72,1,CPPASTTypeId,,<empty>
55990,UNKNOWN,1,,const char*,23,<empty>,,117,1,CPPASTTypeId,,<empty>
56013,UNKNOWN,2,,),41,<empty>,,30,2,CPPASTProblemDeclaration,,<empty>
56082,UNKNOWN,2,,),41,<empty>,,30,2,CPPASTProblemDeclaration,,<empty>
56159,UNKNOWN,2,,),40,<empty>,,32,2,CPPASTProblemDeclaration,,<empty>
56200,UNKNOWN,1,,TelnetAppenderPriv *,6,<empty>,,73,1,CPPASTTypeId,,<empty>
56213,UNKNOWN,1,,TelnetAppenderPriv *,3,<empty>,,75,1,CPPASTTypeId,,<empty>
56227,UNKNOWN,1,,TelnetAppenderPriv *,46,<empty>,,75,1,CPPASTTypeId,,<empty>
56239,UNKNOWN,1,,TelnetAppenderPriv *,3,<empty>,,76,1,CPPASTTypeId,,<empty>
56252,UNKNOWN,1,,TelnetAppenderPriv *,2,<empty>,,79,1,CPPASTTypeId,,<empty>
56336,UNKNOWN,1,,TelnetAppenderPriv *,45,<empty>,,101,1,CPPASTTypeId,,<empty>
56347,UNKNOWN,1,,TelnetAppenderPriv *,9,<empty>,,102,1,CPPASTTypeId,,<empty>
56371,UNKNOWN,1,,TelnetAppenderPriv *,45,<empty>,,107,1,CPPASTTypeId,,<empty>
56382,UNKNOWN,1,,TelnetAppenderPriv *,2,<empty>,,108,1,CPPASTTypeId,,<empty>
56398,UNKNOWN,1,,TelnetAppenderPriv *,2,<empty>,,109,1,CPPASTTypeId,,<empty>
56422,UNKNOWN,1,,TelnetAppenderPriv *,45,<empty>,,115,1,CPPASTTypeId,,<empty>
56433,UNKNOWN,1,,TelnetAppenderPriv *,6,<empty>,,117,1,CPPASTTypeId,,<empty>
56446,UNKNOWN,1,,TelnetAppenderPriv *,2,<empty>,,122,1,CPPASTTypeId,,<empty>
56465,UNKNOWN,1,,TelnetAppenderPriv *,39,<empty>,,126,1,CPPASTTypeId,,<empty>
56480,UNKNOWN,1,,TelnetAppenderPriv *,11,<empty>,,127,1,CPPASTTypeId,,<empty>
56511,UNKNOWN,1,,TelnetAppenderPriv *,6,<empty>,,137,1,CPPASTTypeId,,<empty>
56527,UNKNOWN,1,,TelnetAppenderPriv *,4,<empty>,,141,1,CPPASTTypeId,,<empty>
56542,UNKNOWN,1,,TelnetAppenderPriv *,7,<empty>,,148,1,CPPASTTypeId,,<empty>
56556,UNKNOWN,1,,TelnetAppenderPriv *,3,<empty>,,150,1,CPPASTTypeId,,<empty>
56568,UNKNOWN,1,,TelnetAppenderPriv *,2,<empty>,,153,1,CPPASTTypeId,,<empty>
56591,UNKNOWN,1,,TelnetAppenderPriv *,39,<empty>,,159,1,CPPASTTypeId,,<empty>
56606,UNKNOWN,1,,TelnetAppenderPriv *,11,<empty>,,160,1,CPPASTTypeId,,<empty>
56650,UNKNOWN,1,,TelnetAppenderPriv *,5,<empty>,,174,1,CPPASTTypeId,,<empty>
56704,UNKNOWN,1,,TelnetAppenderPriv *,3,<empty>,,190,1,CPPASTTypeId,,<empty>
56740,UNKNOWN,1,,TelnetAppenderPriv *,17,<empty>,,199,1,CPPASTTypeId,,<empty>
56758,UNKNOWN,1,,TelnetAppenderPriv *,3,<empty>,,204,1,CPPASTTypeId,,<empty>
56769,UNKNOWN,1,,TelnetAppenderPriv *,37,<empty>,,204,1,CPPASTTypeId,,<empty>
56821,UNKNOWN,1,,TelnetAppenderPriv *,46,<empty>,,212,1,CPPASTTypeId,,<empty>
56844,UNKNOWN,1,,TelnetAppenderPriv *,28,<empty>,,216,1,CPPASTTypeId,,<empty>
56889,UNKNOWN,1,,TelnetAppenderPriv *,12,<empty>,,225,1,CPPASTTypeId,,<empty>
56929,UNKNOWN,1,,TelnetAppenderPriv *,26,<empty>,,243,1,CPPASTTypeId,,<empty>
56943,UNKNOWN,1,,TelnetAppenderPriv *,16,<empty>,,244,1,CPPASTTypeId,,<empty>
56970,UNKNOWN,1,,TelnetAppenderPriv *,19,<empty>,,255,1,CPPASTTypeId,,<empty>
56985,UNKNOWN,1,,TelnetAppenderPriv *,17,<empty>,,257,1,CPPASTTypeId,,<empty>
57018,UNKNOWN,1,,TelnetAppenderPriv *,48,<empty>,,268,1,CPPASTTypeId,,<empty>
57035,UNKNOWN,1,,TelnetAppenderPriv *,42,<empty>,,270,1,CPPASTTypeId,,<empty>
57050,UNKNOWN,1,,TelnetAppenderPriv *,14,<empty>,,271,1,CPPASTTypeId,,<empty>
57075,UNKNOWN,1,,TelnetAppenderPriv *,7,<empty>,,277,1,CPPASTTypeId,,<empty>
57093,UNKNOWN,1,,int,29,<empty>,,285,1,CPPASTTypeId,,<empty>
57112,UNKNOWN,1,,TelnetAppenderPriv *,8,<empty>,,292,1,CPPASTTypeId,,<empty>
57127,UNKNOWN,1,,TelnetAppenderPriv *,9,<empty>,,299,1,CPPASTTypeId,,<empty>
57153,UNKNOWN,1,,TelnetAppenderPriv *,9,<empty>,,314,1,CPPASTTypeId,,<empty>
57171,UNKNOWN,1,,TelnetAppenderPriv *,2,<empty>,,319,1,CPPASTTypeId,,<empty>
57239,UNKNOWN,2,,),48,<empty>,,28,2,CPPASTProblemDeclaration,,<empty>
57423,UNKNOWN,1,,logchar,27,<empty>,,136,1,CPPASTTypeId,,<empty>
57490,UNKNOWN,2,,),56,<empty>,,28,2,CPPASTProblemDeclaration,,<empty>
57840,UNKNOWN,3,,),62,<empty>,,43,3,CPPASTProblemDeclaration,,<empty>
57945,UNKNOWN,2,,),48,<empty>,,40,2,CPPASTProblemDeclaration,,<empty>
58181,UNKNOWN,1,,PatternConstructor,2,<empty>,,352,1,CPPASTTypeId,,<empty>
58200,UNKNOWN,1,,PatternConstructor,2,<empty>,,353,1,CPPASTTypeId,,<empty>
58659,UNKNOWN,2,,),36,<empty>,,34,2,CPPASTProblemDeclaration,,<empty>
58712,UNKNOWN,1,,int,24,<empty>,,64,1,CPPASTTypeId,,<empty>
58780,UNKNOWN,1,,int,24,<empty>,,103,1,CPPASTTypeId,,<empty>
58896,UNKNOWN,1,,int,24,<empty>,,162,1,CPPASTTypeId,,<empty>
59141,UNKNOWN,1,,logchar,17,<empty>,,250,1,CPPASTTypeId,,<empty>
59151,UNKNOWN,1,,logchar,17,<empty>,,254,1,CPPASTTypeId,,<empty>
59167,UNKNOWN,1,,logchar,17,<empty>,,259,1,CPPASTTypeId,,<empty>
59180,UNKNOWN,1,,logchar,16,<empty>,,263,1,CPPASTTypeId,,<empty>
59204,UNKNOWN,1,,logchar,17,<empty>,,269,1,CPPASTTypeId,,<empty>
59434,UNKNOWN,1,,char,13,<empty>,,111,1,CPPASTTypeId,,<empty>
59450,UNKNOWN,1,,char,13,<empty>,,116,1,CPPASTTypeId,,<empty>
59461,UNKNOWN,1,,char,13,<empty>,,117,1,CPPASTTypeId,,<empty>
59481,UNKNOWN,1,,char,13,<empty>,,122,1,CPPASTTypeId,,<empty>
59492,UNKNOWN,1,,char,13,<empty>,,123,1,CPPASTTypeId,,<empty>
59505,UNKNOWN,1,,char,13,<empty>,,124,1,CPPASTTypeId,,<empty>
59525,UNKNOWN,1,,char,13,<empty>,,129,1,CPPASTTypeId,,<empty>
59536,UNKNOWN,1,,char,13,<empty>,,130,1,CPPASTTypeId,,<empty>
59549,UNKNOWN,1,,char,13,<empty>,,131,1,CPPASTTypeId,,<empty>
59562,UNKNOWN,1,,char,13,<empty>,,132,1,CPPASTTypeId,,<empty>
59577,UNKNOWN,1,,char,13,<empty>,,140,1,CPPASTTypeId,,<empty>
59584,UNKNOWN,1,,char,13,<empty>,,141,1,CPPASTTypeId,,<empty>
59591,UNKNOWN,1,,char,13,<empty>,,142,1,CPPASTTypeId,,<empty>
59636,UNKNOWN,1,,char,13,<empty>,,158,1,CPPASTTypeId,,<empty>
59645,UNKNOWN,1,,char,13,<empty>,,159,1,CPPASTTypeId,,<empty>
59660,UNKNOWN,1,,unsigned char,22,<empty>,,165,1,CPPASTTypeId,,<empty>
59671,UNKNOWN,1,,char,13,<empty>,,166,1,CPPASTTypeId,,<empty>
59682,UNKNOWN,1,,char,13,<empty>,,167,1,CPPASTTypeId,,<empty>
59699,UNKNOWN,1,,char,13,<empty>,,168,1,CPPASTTypeId,,<empty>
59712,UNKNOWN,1,,char,13,<empty>,,169,1,CPPASTTypeId,,<empty>
59727,UNKNOWN,1,,char,21,<empty>,,173,1,CPPASTTypeId,,<empty>
59772,UNKNOWN,1,,char,13,<empty>,,187,1,CPPASTTypeId,,<empty>
59781,UNKNOWN,1,,char,13,<empty>,,188,1,CPPASTTypeId,,<empty>
59796,UNKNOWN,1,,unsigned char,22,<empty>,,194,1,CPPASTTypeId,,<empty>
59807,UNKNOWN,1,,char,13,<empty>,,195,1,CPPASTTypeId,,<empty>
59818,UNKNOWN,1,,char,13,<empty>,,196,1,CPPASTTypeId,,<empty>
59835,UNKNOWN,1,,char,13,<empty>,,197,1,CPPASTTypeId,,<empty>
59848,UNKNOWN,1,,char,13,<empty>,,198,1,CPPASTTypeId,,<empty>
59863,UNKNOWN,1,,char,21,<empty>,,202,1,CPPASTTypeId,,<empty>
60146,UNKNOWN,1,,unsigned char,26,<empty>,,325,1,CPPASTTypeId,,<empty>
60180,UNKNOWN,1,,char*,29,<empty>,,336,1,CPPASTTypeId,,<empty>
60298,UNKNOWN,1,,unsigned int,26,<empty>,,379,1,CPPASTTypeId,,<empty>
60489,UNKNOWN,1,,unsigned char,22,<empty>,,470,1,CPPASTTypeId,,<empty>
60497,UNKNOWN,1,,unsigned char,22,<empty>,,471,1,CPPASTTypeId,,<empty>
61000,UNKNOWN,2,,),42,<empty>,,24,2,CPPASTProblemDeclaration,,<empty>
61019,UNKNOWN,2,,),32,<empty>,,25,2,CPPASTProblemDeclaration,,<empty>
61048,UNKNOWN,2,,),40,<empty>,,32,2,CPPASTProblemDeclaration,,<empty>
61090,UNKNOWN,1,,WriterAppenderPriv *,6,<empty>,,67,1,CPPASTTypeId,,<empty>
61102,UNKNOWN,1,,WriterAppenderPriv *,3,<empty>,,69,1,CPPASTTypeId,,<empty>
61112,UNKNOWN,1,,LogString,6,<empty>,,70,1,CPPASTTypeId,,<empty>
61119,UNKNOWN,1,,WriterAppenderPriv *,6,<empty>,,71,1,CPPASTTypeId,,<empty>
61135,UNKNOWN,1,,WriterAppenderPriv *,6,<empty>,,75,1,CPPASTTypeId,,<empty>
61149,UNKNOWN,1,,WriterAppenderPriv *,3,<empty>,,77,1,CPPASTTypeId,,<empty>
61159,UNKNOWN,1,,LogString,6,<empty>,,78,1,CPPASTTypeId,,<empty>
61166,UNKNOWN,1,,WriterAppenderPriv *,6,<empty>,,79,1,CPPASTTypeId,,<empty>
61221,UNKNOWN,1,,WriterAppenderPriv *,6,<empty>,,114,1,CPPASTTypeId,,<empty>
61249,UNKNOWN,1,,WriterAppenderPriv *,6,<empty>,,125,1,CPPASTTypeId,,<empty>
61267,UNKNOWN,1,,WriterAppenderPriv *,4,<empty>,,129,1,CPPASTTypeId,,<empty>
61283,UNKNOWN,1,,WriterAppenderPriv *,5,<empty>,,131,1,CPPASTTypeId,,<empty>
61302,UNKNOWN,1,,WriterAppenderPriv *,6,<empty>,,138,1,CPPASTTypeId,,<empty>
61320,UNKNOWN,1,,WriterAppenderPriv *,4,<empty>,,142,1,CPPASTTypeId,,<empty>
61336,UNKNOWN,1,,WriterAppenderPriv *,5,<empty>,,144,1,CPPASTTypeId,,<empty>
61368,UNKNOWN,1,,WriterAppenderPriv *,45,<empty>,,166,1,CPPASTTypeId,,<empty>
61379,UNKNOWN,1,,WriterAppenderPriv *,6,<empty>,,168,1,CPPASTTypeId,,<empty>
61394,UNKNOWN,1,,WriterAppenderPriv *,2,<empty>,,173,1,CPPASTTypeId,,<empty>
61412,UNKNOWN,1,,WriterAppenderPriv *,6,<empty>,,182,1,CPPASTTypeId,,<empty>
61427,UNKNOWN,1,,WriterAppenderPriv *,16,<empty>,,191,1,CPPASTTypeId,,<empty>
61439,UNKNOWN,1,,WriterAppenderPriv *,4,<empty>,,192,1,CPPASTTypeId,,<empty>
61448,UNKNOWN,1,,WriterAppenderPriv *,25,<empty>,,192,1,CPPASTTypeId,,<empty>
61461,UNKNOWN,1,,WriterAppenderPriv *,4,<empty>,,193,1,CPPASTTypeId,,<empty>
61481,UNKNOWN,1,,WriterAppenderPriv *,95,<empty>,,197,1,CPPASTTypeId,,<empty>
61577,UNKNOWN,1,,WriterAppenderPriv *,9,<empty>,,245,1,CPPASTTypeId,,<empty>
61593,UNKNOWN,1,,WriterAppenderPriv *,2,<empty>,,250,1,CPPASTTypeId,,<empty>
61613,UNKNOWN,1,,WriterAppenderPriv *,2,<empty>,,256,1,CPPASTTypeId,,<empty>
61629,UNKNOWN,1,,WriterAppenderPriv *,6,<empty>,,258,1,CPPASTTypeId,,<empty>
61643,UNKNOWN,1,,WriterAppenderPriv *,3,<empty>,,260,1,CPPASTTypeId,,<empty>
61657,UNKNOWN,1,,WriterAppenderPriv *,7,<empty>,,262,1,CPPASTTypeId,,<empty>
61670,UNKNOWN,1,,WriterAppenderPriv *,4,<empty>,,264,1,CPPASTTypeId,,<empty>
61689,UNKNOWN,1,,WriterAppenderPriv *,6,<empty>,,272,1,CPPASTTypeId,,<empty>
61704,UNKNOWN,1,,WriterAppenderPriv *,3,<empty>,,275,1,CPPASTTypeId,,<empty>
61719,UNKNOWN,1,,WriterAppenderPriv *,3,<empty>,,276,1,CPPASTTypeId,,<empty>
61739,UNKNOWN,1,,WriterAppenderPriv *,6,<empty>,,282,1,CPPASTTypeId,,<empty>
61754,UNKNOWN,1,,WriterAppenderPriv *,3,<empty>,,285,1,CPPASTTypeId,,<empty>
61769,UNKNOWN,1,,WriterAppenderPriv *,3,<empty>,,286,1,CPPASTTypeId,,<empty>
61796,UNKNOWN,1,,WriterAppenderPriv *,46,<empty>,,293,1,CPPASTTypeId,,<empty>
61814,UNKNOWN,1,,WriterAppenderPriv *,2,<empty>,,299,1,CPPASTTypeId,,<empty>
61864,UNKNOWN,1,,WriterAppenderPriv *,2,<empty>,,322,1,CPPASTTypeId,,<empty>
61880,UNKNOWN,1,,WriterAppenderPriv *,9,<empty>,,327,1,CPPASTTypeId,,<empty>
61895,UNKNOWN,1,,WriterAppenderPriv *,9,<empty>,,331,1,CPPASTTypeId,,<empty>
61937,UNKNOWN,3,,),35,<empty>,,51,3,CPPASTProblemDeclaration,,<empty>
62547,UNKNOWN,3,,),43,<empty>,,51,3,CPPASTProblemDeclaration,,<empty>
62567,UNKNOWN,1,,XMLSocketAppenderPriv *,2,<empty>,,66,1,CPPASTTypeId,,<empty>
62588,UNKNOWN,1,,XMLSocketAppenderPriv *,2,<empty>,,72,1,CPPASTTypeId,,<empty>
62612,UNKNOWN,1,,XMLSocketAppenderPriv *,2,<empty>,,80,1,CPPASTTypeId,,<empty>
62677,UNKNOWN,1,,XMLSocketAppenderPriv *,45,<empty>,,105,1,CPPASTTypeId,,<empty>
62688,UNKNOWN,1,,XMLSocketAppenderPriv *,2,<empty>,,106,1,CPPASTTypeId,,<empty>
62714,UNKNOWN,1,,XMLSocketAppenderPriv *,6,<empty>,,111,1,CPPASTTypeId,,<empty>
62729,UNKNOWN,1,,XMLSocketAppenderPriv *,4,<empty>,,115,1,CPPASTTypeId,,<empty>
62742,UNKNOWN,1,,XMLSocketAppenderPriv *,4,<empty>,,116,1,CPPASTTypeId,,<empty>
62761,UNKNOWN,1,,XMLSocketAppenderPriv *,6,<empty>,,126,1,CPPASTTypeId,,<empty>
62775,UNKNOWN,1,,XMLSocketAppenderPriv *,3,<empty>,,129,1,CPPASTTypeId,,<empty>
62793,UNKNOWN,1,,XMLSocketAppenderPriv *,4,<empty>,,133,1,CPPASTTypeId,,<empty>
62808,UNKNOWN,1,,XMLSocketAppenderPriv *,4,<empty>,,134,1,CPPASTTypeId,,<empty>
62822,UNKNOWN,1,,XMLSocketAppenderPriv *,4,<empty>,,138,1,CPPASTTypeId,,<empty>
62883,UNKNOWN,3,,),43,<empty>,,45,3,CPPASTProblemDeclaration,,<empty>
62902,UNKNOWN,1,,ZipCompressActionPrivate *,7,<empty>,,57,1,CPPASTTypeId,,<empty>
62994,UNKNOWN,1,,const char**,23,<empty>,,101,1,CPPASTTypeId,,<empty>
63033,UNKNOWN,1,,ZipCompressActionPrivate *,33,<empty>,,107,1,CPPASTTypeId,,<empty>
63056,UNKNOWN,1,,ZipCompressActionPrivate *,33,<empty>,,108,1,CPPASTTypeId,,<empty>
63077,UNKNOWN,1,,ZipCompressActionPrivate *,6,<empty>,,111,1,CPPASTTypeId,,<empty>
63092,UNKNOWN,1,,ZipCompressActionPrivate *,3,<empty>,,113,1,CPPASTTypeId,,<empty>
63120,UNKNOWN,1,,ZipCompressActionPrivate *,29,<empty>,,119,1,CPPASTTypeId,,<empty>
63142,UNKNOWN,1,,ZipCompressActionPrivate *,35,<empty>,,122,1,CPPASTTypeId,,<empty>
63178,UNKNOWN,1,,ZipCompressActionPrivate *,6,<empty>,,144,1,CPPASTTypeId,,<empty>
63191,UNKNOWN,1,,ZipCompressActionPrivate *,3,<empty>,,146,1,CPPASTTypeId,,<empty>
63211,UNKNOWN,1,,ZipCompressActionPrivate *,2,<empty>,,153,1,CPPASTTypeId,,<empty>
63235,UNKNOWN,-1,,"class LOG4CXX_EXPORT Configuration {
private:
	Configuration();

	static LOG4CXX_NS::spi::ConfigurationStatus tryLoadFile(const QString& filename);

public:
	/**
	 * Configure Log4cxx and watch the file for changes.  See also DefaultConfigurator::configureFromFile.
	 *
	 * @param directories
	 * @param filenames
	 * @return
	 */
	static std::tuple<LOG4CXX_NS::spi::ConfigurationStatus,QString> configureFromFileAndWatch(const QVector<QString>& directories,
																						   const QVector<QString>& filenames);
};",1,<empty>,,28,1,CPPASTProblemDeclaration,,<empty>
63276,UNKNOWN,-1,,LOG4CXX_EXPORT,1,<empty>,,39,1,CPPASTProblemDeclaration,,<empty>
63314,UNKNOWN,-1,,"class LOG4CXX_EXPORT Appender :
	public virtual spi::OptionHandler
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(Appender)

		virtual ~Appender() {}

		/**
		 Add a filter to the end of the filter list.
		*/
		virtual void addFilter(const spi::FilterPtr newFilter) = 0;

		/**
		 Returns the head Filter. The Filters are organized in a linked list
		 and so all Filters on this Appender are available through the result.

		 @return the head Filter or null, if no Filters are present
		 */
		virtual spi::FilterPtr getFilter() const = 0;

		/**
		 Clear the list of filters by removing all the filters in it.
		*/
		virtual void clearFilters() = 0;

		/**
		 Release any resources allocated within the appender such as file
		 handles, network connections, etc.
		 <p>It is a programming error to append to a closed appender.
		*/
		virtual void close() = 0;

		/**
		 Log in <code>Appender</code> specific way. When appropriate,
		 Loggers will call the <code>doAppend</code> method of appender
		...",1,<empty>,,49,4,CPPASTProblemDeclaration,,<empty>
63316,UNKNOWN,-1,,"LOG4CXX_LIST_DEF(AppenderList, AppenderPtr);",1,<empty>,,133,6,CPPASTProblemDeclaration,,<empty>
63337,UNKNOWN,-1,,"class LOG4CXX_EXPORT AppenderSkeleton :
	public virtual Appender,
	public virtual helpers::Object
{
	protected:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(AppenderSkeletonPrivate, m_priv)
		AppenderSkeleton(LOG4CXX_PRIVATE_PTR(AppenderSkeletonPrivate) priv);

		/**
		Subclasses of <code>AppenderSkeleton</code> should implement this
		method to perform actual logging. See also AppenderSkeleton::doAppend
		method.
		*/
		virtual void append(const spi::LoggingEventPtr& event, LOG4CXX_NS::helpers::Pool& p) = 0;

		void doAppendImpl(const spi::LoggingEventPtr& event, LOG4CXX_NS::helpers::Pool& pool);

	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(AppenderSkeleton)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(AppenderSkeleton)
		LOG4CXX_CAST_ENTRY(Appender)
		LOG4CXX_CAST_ENTRY(spi::OptionHandler)
		END_LOG4CXX_CAST_MAP()

		AppenderSkeleton();
		AppenderSkeleton(const LayoutPtr& layout);
		virtual ~AppenderSkeleton();

		/**
		Finalize this appender by calling the derived class'
		<code>close<...",1,<empty>,,38,1,CPPASTProblemDeclaration,,<empty>
63350,UNKNOWN,-1,,"LOG4CXX_LIST_DEF(LoggingEventList, spi::LoggingEventPtr);",1,<empty>,,27,1,CPPASTProblemDeclaration,,<empty>
63351,UNKNOWN,-1,,"class LOG4CXX_EXPORT AsyncAppender :
	public virtual spi::AppenderAttachable,
	public virtual AppenderSkeleton
{
	protected:
		struct AsyncAppenderPriv;

	public:
		DECLARE_LOG4CXX_OBJECT(AsyncAppender)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(AsyncAppender)
		LOG4CXX_CAST_ENTRY_CHAIN(AppenderSkeleton)
		LOG4CXX_CAST_ENTRY(spi::AppenderAttachable)
		END_LOG4CXX_CAST_MAP()

		/**
		 * Create new instance.
		*/
		AsyncAppender();

		/**
		 *  Destructor.
		 */
		virtual ~AsyncAppender();

		/**
		 * Add appender.
		 *
		 * @param newAppender appender to add, may not be null.
		*/
		void addAppender(const AppenderPtr newAppender) override;

		void doAppend(const spi::LoggingEventPtr& event,
			helpers::Pool& pool1) override;

		void append(const spi::LoggingEventPtr& event, helpers::Pool& p) override;

		/**
		Close this <code>AsyncAppender</code> by interrupting the
		dispatcher thread which will process all pending events before
		exiting.
		*/
		void close() override;

		/**
...",1,<empty>,,43,2,CPPASTProblemDeclaration,,<empty>
63369,UNKNOWN,-1,,"class LOG4CXX_EXPORT BasicConfigurator
{
	protected:
		BasicConfigurator() {}

	public:
		/**
		Add a ConsoleAppender to the root logger that formats output using \c layout.

		If \c layout is not provided,
		use a PatternLayout with <code>%%r [%%t] %%p %%c %%x - %%m%%n</code>
		as the conversion pattern.
		*/
		static void configure(const LayoutPtr& layout = LayoutPtr());

		/**
		Add <code>appender</code> to the root logger.
		@param appender The appender to add to the root logger.
		*/
		static void configure(const AppenderPtr& appender);

		/**
		Reset the default hierarchy to its defaut. It is equivalent to
		calling
		<code>Logger::getDefaultHierarchy()->resetConfiguration()</code>.
		See Hierarchy#resetConfiguration() for more details.  */
		static void resetConfiguration();
};",1,<empty>,,38,3,CPPASTProblemDeclaration,,<empty>
63389,UNKNOWN,-1,,"class LOG4CXX_EXPORT PropertySetter
{
	protected:
		helpers::ObjectPtr obj;

	public:
		/**
		Create a new PropertySetter for the specified Object. This is done
		in prepartion for invoking #setProperty one or more times.

		@param obj  the object for which to set properties
		*/
		PropertySetter(const helpers::ObjectPtr& obj);

		/**
		Set the properties of an object passed as a parameter in one
		go. The <code>properties</code> are parsed relative to a
		<code>prefix</code>.

		@param obj The object to configure.
		@param properties A java.util.Properties containing keys and values.
		@param prefix Only keys having the specified prefix will be set.
		@param p pool to use for any allocations required during call.
		*/
		static void setProperties(const helpers::ObjectPtr& obj,
			helpers::Properties& properties,
			const LogString& prefix,
			LOG4CXX_NS::helpers::Pool& p);

		/**
		Set the properites for the object that match the
		<code>prefix</code> passed as parameter.
		*/
		voi...",1,<empty>,,62,1,CPPASTProblemDeclaration,,<empty>
63398,UNKNOWN,-1,,"class LOG4CXX_EXPORT ConsoleAppender : public WriterAppender
{
	private:
		struct ConsoleAppenderPriv;

	public:
		DECLARE_LOG4CXX_OBJECT(ConsoleAppender)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(ConsoleAppender)
		LOG4CXX_CAST_ENTRY_CHAIN(AppenderSkeleton)
		END_LOG4CXX_CAST_MAP()

		/**
		* A <code>stdout</code> log event appender.
		*
		* See also #setLayout and #setTarget.
		*/
		ConsoleAppender();

		/**
		* A <code>stdout</code> log event appender formatted using \c layout.
		*
		* @param layout formats a log event
		*/
		ConsoleAppender(const LayoutPtr& layout);

		/**
		* A \c target log event appender formatted using \c layout.
		*
		* @param layout formats a log event
		* @param target the value provided by #getSystemOut or #getSystemErr
		*/
		ConsoleAppender(const LayoutPtr& layout, const LogString& target);
		~ConsoleAppender();


		/**
		*  Use \c newValue for the <b>target</b> property.
		*
		* @param newValue the value provided by #getSystemOut or #getSystemEr...",1,<empty>,,37,1,CPPASTProblemDeclaration,,<empty>
63419,UNKNOWN,-1,,"class LOG4CXX_EXPORT DBAppender : public AppenderSkeleton
{
        public:
                DECLARE_LOG4CXX_OBJECT(DBAppender)
                BEGIN_LOG4CXX_CAST_MAP()
                LOG4CXX_CAST_ENTRY(DBAppender)
                LOG4CXX_CAST_ENTRY_CHAIN(AppenderSkeleton)
                END_LOG4CXX_CAST_MAP()

                DBAppender();
                virtual ~DBAppender();

                /**
                \copybrief AppenderSkeleton::setOption()

                Supported options | Supported values | Default value
                :-------------- | :----------------: | :---------------:
                DriverName | {any} | -
                DriverParams | {any} | -
                DatabaseName | {any} | -
                SQL | {any} | -
                ColumnMapping | (\ref rep ""^"") | -

                \anchor rep (^) One value for each '%%' character in the SQL value.
                \sa AppenderSkeleton::setOption()
                */
                void setOption(cons...",1,<empty>,,113,1,CPPASTProblemDeclaration,,<empty>
63442,UNKNOWN,-1,,"class LOG4CXX_EXPORT SQLException : public LOG4CXX_NS::helpers::Exception
{
	public:
		SQLException(short fHandleType,
			void* hInput, const char* prolog,
			LOG4CXX_NS::helpers::Pool& p);
		SQLException(const char* msg);
		SQLException(const SQLException& src);
	private:
		const char* formatMessage(short fHandleType,
			void* hInput, const char* prolog,
			LOG4CXX_NS::helpers::Pool& p);
};",1,<empty>,,38,1,CPPASTProblemDeclaration,,<empty>
63443,UNKNOWN,-1,,"class LOG4CXX_EXPORT ODBCAppender : public AppenderSkeleton
{
	public:
		DECLARE_LOG4CXX_OBJECT(ODBCAppender)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(ODBCAppender)
		LOG4CXX_CAST_ENTRY_CHAIN(AppenderSkeleton)
		END_LOG4CXX_CAST_MAP()

		typedef void* SQLHDBC;
		typedef void* SQLHENV;
		typedef void* SQLHANDLE;
		typedef short SQLSMALLINT;

		ODBCAppender();
		virtual ~ODBCAppender();

		/**
		\copybrief AppenderSkeleton::setOption()

		Supported options | Supported values | Default value
		:-------------- | :----------------: | :---------------:
		BufferSize | {int} | 1
		ConnectionString | {any} | -
		URL | {any} | -
		DSN | {any} | -
		User | {any} | -
		Password | {any} | -
		SQL | {any} | -
		ColumnMapping | (\ref colName ""^"") | -

		\anchor colName (^) One value for each '?' character in the SQL value.

		\sa AppenderSkeleton::setOption()
		*/
		void setOption(const LogString& option, const LogString& value) override;

		/**
		Activate the specified options.
		*/
		void...",1,<empty>,,142,2,CPPASTProblemDeclaration,,<empty>
63457,UNKNOWN,-1,,"class LOG4CXX_EXPORT DefaultConfigurator
{
	private:
		DefaultConfigurator() {}

	public:
		/**
		Configure \c repository.

		If the configuration file name has not been provided by a call to setConfigurationFileName(),
		the environment variables ""LOG4CXX_CONFIGURATION"" and ""log4j.configuration"" are examined.
		Unless a custom configurator is specified using the
		""LOG4CXX_CONFIGURATOR_CLASS"" or ""log4j.configuratorClass""
		environment variable, the PropertyConfigurator will be used to
		configure log4cxx unless the file name ends with the "".xml""
		extension, in which case the DOMConfigurator will be used. If a
		custom configurator is specified, the environment variable should
		contain a fully qualified class name of a class that implements the
		Configurator interface.

		If the configuration file name is not found using any of the previous approaches,
		the current directory is examined for a file with extension "".xml"" or "".properties""
		with a base name ""log4cxx"" or ""log4j"".

	...",1,<empty>,,32,1,CPPASTProblemDeclaration,,<empty>
63470,UNKNOWN,-1,,"class LOG4CXX_EXPORT DefaultLoggerFactory :
	public virtual spi::LoggerFactory,
	public virtual helpers::Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(DefaultLoggerFactory)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(spi::LoggerFactory)
		END_LOG4CXX_CAST_MAP()

		LoggerPtr makeNewLoggerInstance(helpers::Pool& pool, const LogString& name) const override;
};",1,<empty>,,29,3,CPPASTProblemDeclaration,,<empty>
63486,UNKNOWN,-1,,"class LOG4CXX_EXPORT File
{
	public:
		/**
		*   Construct a new instance.
		*/
		File();
		/**
		*   Construct a new instance.  Use setPath to specify path using a LogString.
		* @param path file path in local encoding.
		*/
		File(const char* path);
		/**
		*   Construct a new instance.  Use setPath to specify path using a LogString.
		* @param path file path in current encoding.
		*/
		File(const std::string& path);
#if LOG4CXX_WCHAR_T_API
		/**
		*   Construct a new instance.  Use setPath to specify path using a LogString.
		* @param path file path.
		*/
		File(const wchar_t* path);
		/**
		*   Construct a new instance.  Use setPath to specify path using a LogString.
		* @param path file path.
		*/
		File(const std::wstring& path);
#endif
#if LOG4CXX_UNICHAR_API || LOG4CXX_LOGCHAR_IS_UNICHAR
		/**
		*   Construct a new instance.  Use setPath to specify path using a LogString.
		* @param path file path.
		*/
		File(const UniChar* path);
		/**
		*   Construct a new instance.  Use ...",1,<empty>,,40,2,CPPASTProblemDeclaration,,<empty>
63505,UNKNOWN,-1,,"class LOG4CXX_EXPORT FileAppender : public WriterAppender
{
	protected:
		struct FileAppenderPriv;

	public:
		DECLARE_LOG4CXX_OBJECT(FileAppender)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(FileAppender)
		LOG4CXX_CAST_ENTRY_CHAIN(WriterAppender)
		END_LOG4CXX_CAST_MAP()

		/**
		The default constructor does not do anything.
		*/
		FileAppender();

		/**
		Instantiate a <code>FileAppender</code> and open the file
		designated by <code>filename</code>. The opened filename will
		become the output destination for this appender.

		<p>If the <code>append</code> parameter is true, the file will be
		appended to. Otherwise, the file designated by
		<code>filename</code> will be truncated before being opened.

		<p>If the <code>bufferedIO</code> parameter is <code>true</code>,
		then buffered IO will be used to write to the output file.

		*/
		FileAppender(const LayoutPtr& layout, const LogString& filename, bool append,
			bool bufferedIO, int bufferSize);

		/**
		Instantiate a Fi...",1,<empty>,,41,2,CPPASTProblemDeclaration,,<empty>
63518,UNKNOWN,-1,,"class LOG4CXX_EXPORT AndFilter: public LOG4CXX_NS::spi::Filter
{
	private:
		struct AndFilterPrivate;

		AndFilter(const AndFilter&);
		AndFilter& operator=(const AndFilter&);

	public:
		DECLARE_LOG4CXX_OBJECT(AndFilter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(LOG4CXX_NS::spi::Filter)
		END_LOG4CXX_CAST_MAP()

		AndFilter();
		~AndFilter();

		void addFilter(const spi::FilterPtr& filter);

		void setAcceptOnMatch(bool acceptOnMatch);

		FilterDecision decide(const spi::LoggingEventPtr& event) const override;
};",1,<empty>,,73,1,CPPASTProblemDeclaration,,<empty>
63529,UNKNOWN,-1,,"class LOG4CXX_EXPORT DenyAllFilter : public spi::Filter
{
	public:
		DenyAllFilter() : spi::Filter()
		{
		}

		typedef spi::Filter BASE_CLASS;
		DECLARE_LOG4CXX_OBJECT(DenyAllFilter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(DenyAllFilter)
		LOG4CXX_CAST_ENTRY_CHAIN(BASE_CLASS)
		END_LOG4CXX_CAST_MAP()

		/**
		Always returns the integer constant {@link spi::Filter#DENY DENY}
		regardless of the {@link spi::LoggingEventPtr LoggingEvent} parameter.
		@param event The LoggingEvent to filter.
		@return Always returns {@link spi::Filter#DENY DENY}.
		*/
		FilterDecision decide(const spi::LoggingEventPtr& event) const override
		{
			return spi::Filter::DENY;
		}
};",1,<empty>,,35,1,CPPASTProblemDeclaration,,<empty>
63543,UNKNOWN,-1,,"class LOG4CXX_EXPORT ExpressionFilter: public LOG4CXX_NS::spi::Filter
{
	private:
		bool acceptOnMatch;
		bool convertInFixToPostFix;
		LOG4CXX_DECLARE_PRIVATE_MEMBER(LogString, expression)
		LOG4CXX_DECLARE_PRIVATE_MEMBER(rule::RulePtr, expressionRule)
		ExpressionFilter(const ExpressionFilter&);
		ExpressionFilter& operator=(const ExpressionFilter&);

	public:
		DECLARE_LOG4CXX_OBJECT(ExpressionFilter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(LOG4CXX_NS::spi::Filter)
		END_LOG4CXX_CAST_MAP()


		ExpressionFilter();

		void activateOptions(helpers::Pool& p) override;

		void setExpression(const LogString& expression);

		LogString getExpression() const;

		void setConvertInFixToPostFix(bool convertInFixToPostFix);

		bool getConvertInFixToPostFix() const;

		void setAcceptOnMatch(bool acceptOnMatch);

		bool getAcceptOnMatch() const;

		/**
		   Returns {@link log4cxx::spi::Filter#NEUTRAL} is there is no string match.
		 */
		FilterDecision decide(const spi::LoggingEventPtr&...",1,<empty>,,78,1,CPPASTProblemDeclaration,,<empty>
63556,UNKNOWN,-1,,"class LOG4CXX_EXPORT LevelMatchFilter : public spi::Filter
{
	private:
		struct LevelMatchFilterPrivate;

	public:
		typedef spi::Filter BASE_CLASS;
		DECLARE_LOG4CXX_OBJECT(LevelMatchFilter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(LevelMatchFilter)
		LOG4CXX_CAST_ENTRY_CHAIN(BASE_CLASS)
		END_LOG4CXX_CAST_MAP()

		LevelMatchFilter();
		~LevelMatchFilter();

		/**
		\copybrief spi::OptionHandler::setOption()

		Supported options | Supported values | Default value
		-------------- | ---------------- | ---------------
		LevelToMatch | (\ref validLevel ""1"") | -
		AcceptOnMatch | True,False | True

		\anchor validLevel (1) One of Trace, Debug, Info, Warn, Error, Fatal, Off, All
		or a custom level in which case it is of the form <code>{levelName}#{registeredClassName}</code>.
		*/
		void setOption(const LogString& option, const LogString& value) override;

		void setLevelToMatch(const LogString& levelToMatch);

		LogString getLevelToMatch() const;

		void setAcceptOnMatch(bool a...",1,<empty>,,42,1,CPPASTProblemDeclaration,,<empty>
63569,UNKNOWN,-1,,"class LOG4CXX_EXPORT LevelRangeFilter : public spi::Filter
{
	private:
		struct LevelRangeFilterPrivate;

	public:
		typedef spi::Filter BASE_CLASS;
		DECLARE_LOG4CXX_OBJECT(LevelRangeFilter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(LevelRangeFilter)
		LOG4CXX_CAST_ENTRY_CHAIN(BASE_CLASS)
		END_LOG4CXX_CAST_MAP()

		LevelRangeFilter();
		~LevelRangeFilter();

		/**
		\copybrief spi::OptionHandler::setOption()

		Supported options | Supported values | Default value
		-------------- | ---------------- | ---------------
		LevelMin | (\ref validLevels ""1"") | ALL
		LevelMax | (\ref validLevels ""1"") | OFF
		AcceptOnMatch | True,False | True

		\anchor validLevels (1). One of ""Trace"", ""Debug"", ""Info"", ""Warn"", ""Error"", ""Fatal"", ""Off"", ""All""
		or a custom level in which case it is of the form <code>{levelName}#{registeredClassName}</code>.
		*/
		void setOption(const LogString& option, const LogString& value) override;

		/**
		Set the <code>levelMin</code> option.
		*/
		void setLeve...",1,<empty>,,56,1,CPPASTProblemDeclaration,,<empty>
63580,UNKNOWN,-1,,"class LOG4CXX_EXPORT LocationInfoFilter: public LOG4CXX_NS::spi::Filter
{
		struct LocationInfoFilterPrivate;
	public:
		DECLARE_LOG4CXX_OBJECT(LocationInfoFilter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(LocationInfoFilter)
		LOG4CXX_CAST_ENTRY_CHAIN(LOG4CXX_NS::spi::Filter)
		END_LOG4CXX_CAST_MAP()

		LocationInfoFilter();

		~LocationInfoFilter();

		/**
		\copybrief spi::OptionHandler::setOption()

		Supported options | Supported values | Default value
		-------------- | ---------------- | ---------------
		Method | {any} | -
		LineNumber | {int} | -
		Operator | (\ref andOrAny ""1"") | Or
		AcceptOnMatch | True,False | True

		\anchor andOrAny (1) If ""And"", both method name and line number must match,
		otherwise either method name or line number match. 
		*/
		void setOption(const LogString& option, const LogString& value) override;

		void setLineNumber(int lineNum);

		void setMethodName(const LogString& methodName);

		void setAcceptOnMatch(bool acceptOnMatch1);

		boo...",1,<empty>,,41,1,CPPASTProblemDeclaration,,<empty>
63594,UNKNOWN,-1,,"class LOG4CXX_EXPORT LoggerMatchFilter : public spi::Filter
{
	private:
		struct LoggerMatchFilterPrivate;

	public:
		typedef spi::Filter BASE_CLASS;
		DECLARE_LOG4CXX_OBJECT(LoggerMatchFilter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(LoggerMatchFilter)
		LOG4CXX_CAST_ENTRY_CHAIN(BASE_CLASS)
		END_LOG4CXX_CAST_MAP()

		LoggerMatchFilter();
		~LoggerMatchFilter();

		/**
		\copybrief spi::OptionHandler::setOption()

		Supported options | Supported values | Default value
		-------------- | ---------------- | ---------------
		LoggerToMatch | {any} | root
		AcceptOnMatch | True,False | True
		*/
		void setOption(const LogString& option, const LogString& value) override;

		void setLoggerToMatch(const LogString& levelToMatch);

		LogString getLoggerToMatch() const;

		void setAcceptOnMatch(bool acceptOnMatch1);

		bool getAcceptOnMatch() const;

		/**
		Return the decision of this filter.

		Returns {@link spi::Filter#NEUTRAL NEUTRAL} if the
		<code>loggerToMatch</code> option i...",1,<empty>,,45,1,CPPASTProblemDeclaration,,<empty>
63605,UNKNOWN,-1,,"class LOG4CXX_EXPORT MapFilter: public LOG4CXX_NS::spi::Filter
{
		typedef std::map < LogString, LogString > KeyVals;

	private:
		struct MapFilterPrivate;

	public:
		DECLARE_LOG4CXX_OBJECT(MapFilter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(MapFilter)
		LOG4CXX_CAST_ENTRY_CHAIN(LOG4CXX_NS::spi::Filter)
		END_LOG4CXX_CAST_MAP()

		MapFilter();
		~MapFilter();

		/**
		\copybrief spi::OptionHandler::setOption()

		Supported options | Supported values | Default value
		-------------- | ---------------- | ---------------
		Operator | (\ref andOrOne ""1"") | Or
		AcceptOnMatch | True,False | True
		{anyKey} | {anyValue} | -

		\anchor andOrOne (1) If ""And"", the MDC must contain all configured key-value pairs,
		otherwise only one configured key-value pair needs to match. 
		*/
		void setOption(const LogString& option, const LogString& value) override;

		void setKeyValue(const LogString& strKey, const LogString& strValue);

		const LogString& getValue(const LogString& strKey) cons...",1,<empty>,,41,1,CPPASTProblemDeclaration,,<empty>
63618,UNKNOWN,-1,,"class LOG4CXX_EXPORT PropertyFilter : public LOG4CXX_NS::spi::Filter
{
		typedef std::map < LogString, LogString > PropertyMap;
		PropertyMap* properties;
		PropertyFilter(const PropertyFilter&);
		PropertyFilter& operator=(const PropertyFilter&);

	public:
		DECLARE_LOG4CXX_OBJECT(PropertyFilter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(LOG4CXX_NS::spi::Filter)
		END_LOG4CXX_CAST_MAP()

		PropertyFilter();
		~PropertyFilter();
		void setProperties(const LogString& props);

		FilterDecision decide(const spi::LoggingEventPtr& event) const override;

};",1,<empty>,,47,1,CPPASTProblemDeclaration,,<empty>
63628,UNKNOWN,-1,,"class LOG4CXX_EXPORT StringMatchFilter : public spi::Filter
{
	private:
		struct StringMatchFilterPrivate;

	public:
		typedef spi::Filter BASE_CLASS;
		DECLARE_LOG4CXX_OBJECT(StringMatchFilter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(StringMatchFilter)
		LOG4CXX_CAST_ENTRY_CHAIN(BASE_CLASS)
		END_LOG4CXX_CAST_MAP()

		StringMatchFilter();
		~StringMatchFilter();

		/**
		\copybrief spi::OptionHandler::setOption()

		Supported options | Supported values | Default value
		-------------- | ---------------- | ---------------
		StringToMatch | {any} | -
		AcceptOnMatch | True,False | True
		 */
		void setOption(const LogString& option, const LogString& value) override;

		void setStringToMatch(const LogString& stringToMatch1);

		const LogString& getStringToMatch() const;

		void setAcceptOnMatch(bool acceptOnMatch1);

		bool getAcceptOnMatch() const;

		/**
		Returns {@link log4cxx::spi::Filter#NEUTRAL NEUTRAL}
		is there is no string match.
		*/
		FilterDecision decide(const s...",1,<empty>,,48,1,CPPASTProblemDeclaration,,<empty>
63638,UNKNOWN,-1,,"class LOG4CXX_EXPORT FMTLayout : public Layout
{
    LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(FMTLayoutPrivate, m_priv)

	public:
		DECLARE_LOG4CXX_OBJECT(FMTLayout)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(FMTLayout)
		LOG4CXX_CAST_ENTRY_CHAIN(Layout)
		END_LOG4CXX_CAST_MAP()

		FMTLayout();

		FMTLayout(const LogString& pattern);

		~FMTLayout();


		/**
		 * Set the <strong>ConversionPattern</strong> option. This is the string which
		 * controls formatting and consists of a mix of literal content and
		 * conversion specifiers.
		 */
		void setConversionPattern(const LogString& conversionPattern);

		/**
		 * Returns the value of the <strong>ConversionPattern</strong> option.
		 */
		LogString getConversionPattern() const;

		/**
		Returns the log statement in a format consisting of the
		<code>level</code>, followed by "" - "" and then the
		<code>message</code>. For example, <pre> INFO - ""A message""
		</pre>
		*/
		void format(LogString& output,
			const spi::LoggingEventPtr& e...",1,<empty>,,213,1,CPPASTProblemDeclaration,,<empty>
63649,UNKNOWN,-1,,"class LOG4CXX_EXPORT AbsoluteTimeDateFormat : public SimpleDateFormat
{
	public:
		AbsoluteTimeDateFormat()
			: SimpleDateFormat(LOG4CXX_STR(""HH:mm:ss,SSS"")) {}
};",1,<empty>,,31,1,CPPASTProblemDeclaration,,<empty>
63670,UNKNOWN,-1,,"class LOG4CXX_EXPORT AppenderAttachableImpl :
	public virtual spi::AppenderAttachable
{
	protected:
		AppenderList& appenderList();

	public:
		/**
		 *   Create new instance.
		 *   @param pool pool, must be longer-lived than instance.
		 */
		AppenderAttachableImpl(Pool& pool);

		~AppenderAttachableImpl();

		DECLARE_ABSTRACT_LOG4CXX_OBJECT(AppenderAttachableImpl)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(AppenderAttachableImpl)
		LOG4CXX_CAST_ENTRY(spi::AppenderAttachable)
		END_LOG4CXX_CAST_MAP()

		// Methods
		/**
		 * Add an appender.
		 */
		void addAppender(const AppenderPtr newAppender) override;

		/**
		 Call the <code>doAppend</code> method on all attached appenders.
		*/
		int appendLoopOnAppenders(const spi::LoggingEventPtr& event,
			LOG4CXX_NS::helpers::Pool& p);

		/**
		 * Get all previously added appenders as an Enumeration.
		 */
		AppenderList getAllAppenders() const override;

		/**
		 * Get an appender by name.
		 */
		AppenderPtr getAppender(const Log...",1,<empty>,,39,1,CPPASTProblemDeclaration,,<empty>
63788,UNKNOWN,-1,,"LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(APRInitializerPrivate, m_priv)
	private: // Class methods
		static APRInitializer& getInstance();",3,<empty>,,86,17,CPPASTProblemDeclaration,,<empty>
63802,UNKNOWN,-1,,"class LOG4CXX_EXPORT BufferedWriter : public Writer
{
	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(BufferedWriterPriv, m_priv)

	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(BufferedWriter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(BufferedWriter)
		LOG4CXX_CAST_ENTRY_CHAIN(Writer)
		END_LOG4CXX_CAST_MAP()

		BufferedWriter(WriterPtr& out);
		BufferedWriter(WriterPtr& out, size_t sz);
		virtual ~BufferedWriter();

		void close(Pool& p) override;
		void flush(Pool& p) override;
		void write(const LogString& str, Pool& p) override;

	private:
		BufferedWriter(const BufferedWriter&);
		BufferedWriter& operator=(const BufferedWriter&);
};",1,<empty>,,33,1,CPPASTProblemDeclaration,,<empty>
63814,UNKNOWN,-1,,"LOG4CXX_LIST_DEF(ByteList, unsigned char);",1,<empty>,,30,1,CPPASTProblemDeclaration,,<empty>
63815,UNKNOWN,-1,,"class LOG4CXX_EXPORT ByteArrayInputStream : public InputStream
{
	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(ByteArrayInputStreamPriv, m_priv)

	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(ByteArrayInputStream)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(ByteArrayInputStream)
		LOG4CXX_CAST_ENTRY_CHAIN(InputStream)
		END_LOG4CXX_CAST_MAP()

		/**
		 * Creates a ByteArrayInputStream.
		 *
		 * @param bytes array of bytes to copy into stream.
		 */
		ByteArrayInputStream(const ByteList& bytes);

		virtual ~ByteArrayInputStream();

		/**
		 * Closes this file input stream and releases any system
		 * resources associated with the stream.
		 */
		void close() override;

		/**
		 * Reads a sequence of bytes into the given buffer.
		 *
		 * @param buf The buffer into which bytes are to be transferred.
		 * @return the total number of bytes read into the buffer, or -1 if there
		 *         is no more data because the end of the stream has been reached.
		 */
		int read(ByteBuffer& buf...",1,<empty>,,35,2,CPPASTProblemDeclaration,,<empty>
63829,UNKNOWN,-1,,"LOG4CXX_LIST_DEF(ByteList, unsigned char);",1,<empty>,,31,2,CPPASTProblemDeclaration,,<empty>
63830,UNKNOWN,-1,,"class LOG4CXX_EXPORT ByteArrayOutputStream : public OutputStream
{
	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(ByteArrayOutputStreamPriv, m_priv)

	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(ByteArrayOutputStream)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(ByteArrayOutputStream)
		LOG4CXX_CAST_ENTRY_CHAIN(OutputStream)
		END_LOG4CXX_CAST_MAP()

		ByteArrayOutputStream();
		virtual ~ByteArrayOutputStream();

		void close(Pool& p) override;
		void flush(Pool& p) override;
		void write(ByteBuffer& buf, Pool& p) override;
		ByteList toByteArray() const;

	private:
		ByteArrayOutputStream(const ByteArrayOutputStream&);
		ByteArrayOutputStream& operator=(const ByteArrayOutputStream&);
};",1,<empty>,,36,3,CPPASTProblemDeclaration,,<empty>
63843,UNKNOWN,-1,,"class LOG4CXX_EXPORT ByteBuffer
{
	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(ByteBufferPriv, m_priv)

	public:
		ByteBuffer(char* data, size_t capacity);
		~ByteBuffer();

		void clear();
		void flip();

		char* data();
		const char* data() const;
		char* current();
		const char* current() const;
		size_t limit() const;
		void limit(size_t newLimit);
		size_t position() const;
		size_t remaining() const;
		void position(size_t newPosition);

		bool put(char byte);


	private:
		ByteBuffer(const ByteBuffer&);
		ByteBuffer& operator=(const ByteBuffer&);
};",1,<empty>,,33,1,CPPASTProblemDeclaration,,<empty>
63853,UNKNOWN,-1,,"class LOG4CXX_EXPORT CachedDateFormat : public LOG4CXX_NS::helpers::DateFormat
{
	public:
		enum
		{
			/*
			 *  Constant used to represent that there was no change
			 *  observed when changing the millisecond count.
			 */
			NO_MILLISECONDS = -2,
			/*
			 *  Constant used to represent that there was an
			 *  observed change, but was an expected change.
			 */
			UNRECOGNIZED_MILLISECONDS = -1
		};

	private:
		/**
		 *  Supported digit set.  If the wrapped DateFormat uses
		 *  a different unit set, the millisecond pattern
		 *  will not be recognized and duplicate requests
		 *  will use the cache.
		 */
		static const logchar digits[];


		/**
		 * First magic number (in microseconds) used to detect
		 * the millisecond position.
		 */
		static const int magic1;


		/**
		 *  Expected representation of first magic number in milliseconds.
		 */
		static const logchar magicString1[];


		/**
		 * Second magic number (in microseconds) used to detect
		 * the millisecond positio...",1,<empty>,,27,1,CPPASTProblemDeclaration,,<empty>
63866,UNKNOWN,-1,,"class LOG4CXX_EXPORT CharsetDecoder : public Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(CharsetDecoder)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(CharsetDecoder)
		END_LOG4CXX_CAST_MAP()
	protected:
		/**
		*  Protected constructor.
		*/
		CharsetDecoder();
	public:
		/**
		*  Destructor.
		*/
		virtual ~CharsetDecoder();

		/**
		 *   Get decoder for default charset.
		 */
		static CharsetDecoderPtr getDefaultDecoder();
		/**
		 *  Get decoder for specified character set.
		 *  @param charset the following values should be recognized:
		 *     ""US-ASCII"", ""ISO-8859-1"", ""UTF-8"",
		 *     ""UTF-16BE"", ""UTF-16LE"".
		 *  @return decoder
		 *  @throws IllegalArgumentException if charset is not recognized.
		 */
		static CharsetDecoderPtr getDecoder(const LogString& charset);

		/**
		 *   Get decoder for UTF-8.
		 */
		static CharsetDecoderPtr getUTF8Decoder();
		/**
		 *   Get decoder for ISO-8859-1.
		 */
		static CharsetDecoderPtr getISOLatinDecoder();



		/**
		 *  De...",1,<empty>,,36,4,CPPASTProblemDeclaration,,<empty>
63881,UNKNOWN,-1,,"class LOG4CXX_EXPORT CharsetEncoder : public Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(CharsetEncoder)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(CharsetEncoder)
		END_LOG4CXX_CAST_MAP()

	protected:
		/**
		*  Protected constructor.
		*/
		CharsetEncoder();

	public:
		/**
		* Destructor.
		*/
		virtual ~CharsetEncoder();
		/**
		 *  Get encoder for default charset.
		 */
		static CharsetEncoderPtr getDefaultEncoder();

		/**
		 *  Get encoder for specified character set.
		 *  @param charset the following values should be recognized:
		 *     ""US-ASCII"", ""ISO-8859-1"", ""UTF-8"",
		 *     ""UTF-16BE"", ""UTF-16LE"".
		 *  @return encoder.
		 *  @throws IllegalArgumentException if encoding is not recognized.
		 */
		static CharsetEncoderPtr getEncoder(const LogString& charset);


		/**
		 *   Get encoder for UTF-8.
		 */
		static CharsetEncoderPtr getUTF8Encoder();

		/**
		* Encodes a string replacing unmappable
		* characters with escape sequences.
		*
		*/
		static void ...",1,<empty>,,37,4,CPPASTProblemDeclaration,,<empty>
63894,UNKNOWN,-1,,"class LOG4CXX_EXPORT Class
{
	public:
		virtual ~Class();
		virtual Object* newInstance() const;
		LogString toString() const;
		virtual LogString getName() const = 0;
		static const Class& forName(const LogString& className);
		static bool registerClass(const Class& newClass);

	protected:
		Class();

	private:
		Class(const Class&);
		Class& operator=(const Class&);
		typedef std::map<LogString, const Class*> ClassMap;
		static ClassMap& getRegistry();
		static void registerClasses();
};",1,<empty>,,31,2,CPPASTProblemDeclaration,,<empty>
63905,UNKNOWN,-1,,"class LOG4CXX_EXPORT ClassRegistration
{
	public:
		typedef const Class& (*ClassAccessor)();
		ClassRegistration(ClassAccessor classAccessor);

	private:
		ClassRegistration(const ClassRegistration&);
		ClassRegistration& operator=(const ClassRegistration&);
};",1,<empty>,,28,2,CPPASTProblemDeclaration,,<empty>
63917,UNKNOWN,-1,,"class LOG4CXX_EXPORT CyclicBuffer
{
	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(CyclicBufferPriv, m_priv)

	public:
		/**
		Instantiate a new CyclicBuffer of at most <code>maxSize</code>
		events.
		The <code>maxSize</code> argument must a positive integer.
		@param maxSize The maximum number of elements in the buffer.
		@throws IllegalArgumentException if <code>maxSize</code>
		is negative.
		*/
		CyclicBuffer(int maxSize);
		~CyclicBuffer();

		/**
		Add an <code>event</code> as the last event in the buffer.
		*/
		void add(const spi::LoggingEventPtr& event);

		/**
		Get the <i>i</i>th oldest event currently in the buffer. If
		<em>i</em> is outside the range 0 to the number of elements
		currently in the buffer, then <code>null</code> is returned.
		*/
		spi::LoggingEventPtr get(int i);

		int getMaxSize() const;

		/**
		Get the oldest (first) element in the buffer. The oldest element
		is removed from the buffer.
		*/
		spi::LoggingEventPtr get();

		/**
		Get the number of...",1,<empty>,,35,1,CPPASTProblemDeclaration,,<empty>
63929,UNKNOWN,-1,,"class LOG4CXX_EXPORT DatagramPacket : public helpers::Object
{
	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(DatagramPacketPriv, m_priv)

	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(DatagramPacket)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(DatagramPacket)
		END_LOG4CXX_CAST_MAP()

		/** Constructs a DatagramPacket for receiving packets of length
		<code>length</code>. */
		DatagramPacket(void* buf, int length);

		/** Constructs a datagram packet for sending packets of length
		<code>length</code> to the specified port number on the specified
		host. */
		DatagramPacket(void* buf, int length, InetAddressPtr address, int port);

		/** Constructs a DatagramPacket for receiving packets of length
		<code>length</code>, specifying an offset into the buffer. */
		DatagramPacket(void* buf, int offset, int length);

		/** Constructs a datagram packet for sending packets of length
		<code>length</code> with offset <code>offset</code> to the
		specified port number on the specified host...",1,<empty>,,36,1,CPPASTProblemDeclaration,,<empty>
63949,UNKNOWN,-1,,"class LOG4CXX_EXPORT DatagramSocket : public helpers::Object
{
	protected:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(DatagramSocketPriv, m_priv)
		DatagramSocket(LOG4CXX_PRIVATE_PTR(DatagramSocketPriv) priv);

	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(DatagramSocket)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(DatagramSocket)
		END_LOG4CXX_CAST_MAP()

		/** ensure the socket is closed. */
		virtual ~DatagramSocket();

		/**  Binds a datagram socket to a local port and address.*/
		virtual void bind(int lport, InetAddressPtr laddress) = 0;

		/** Closes this datagram socket */
		virtual void close();

		/** Connects the socket to a remote address for this socket. */
		virtual void connect(InetAddressPtr address, int port) = 0;

		/** Returns the address to which this socket is connected. */
		InetAddressPtr getInetAddress() const;

		/** Gets the local address to which the socket is bound. */
		InetAddressPtr getLocalAddress() const;

		/**  Returns the port number on the local host ...",1,<empty>,,37,4,CPPASTProblemDeclaration,,<empty>
63963,UNKNOWN,-1,,"class LOG4CXX_EXPORT Date : public Object
{
		const log4cxx_time_t time;

	public:
		DECLARE_LOG4CXX_OBJECT(Date)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(Date)
		END_LOG4CXX_CAST_MAP()

		Date();
		Date(log4cxx_time_t time);
		virtual ~Date();

		inline log4cxx_time_t getTime() const
		{
			return time;
		}

		/**
		 *   Get start of next second
		 */
		log4cxx_time_t getNextSecond() const;


		static log4cxx_time_t getMicrosecondsPerDay();
		static log4cxx_time_t getMicrosecondsPerSecond();
		static log4cxx_time_t getCurrentTimeStd();
		static log4cxx_time_t currentTime();

		/**
		 * A function that will return the current time(in microseconds) when called
		 */
		typedef std::function<log4cxx_time_t()> GetCurrentTimeFn;

		/**
		 * Set the function that is used to get the current time.
		 * This is used only for testing purposes and should never be called
		 * under normal circumstances.
		 *
		 * @param fn
		 */
		static void setGetCurrentTimeFunction(GetCurrentTimeFn fn...",1,<empty>,,35,1,CPPASTProblemDeclaration,,<empty>
63974,UNKNOWN,-1,,"class LOG4CXX_EXPORT DateFormat : public Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(DateFormat)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(DateFormat)
		END_LOG4CXX_CAST_MAP()

		/**
		*  Destructor
		*/
		virtual ~DateFormat();

		/**
		* Formats an log4cxx_time_t into a date/time string.
		* @param s string to which the date/time string is appended.
		* @param tm date to be formatted.
		* @param p memory pool used during formatting.
		*/
		virtual void format(LogString& s, log4cxx_time_t tm, LOG4CXX_NS::helpers::Pool& p) const = 0;

		/**
		* Sets the time zone.
		* @param zone the given new time zone.
		*/
		virtual void setTimeZone(const TimeZonePtr& zone);

		/**
		* Format an integer consistent with the format method.
		* @param s string to which the numeric string is appended.
		* @param n integer value.
		* @param p memory pool used during formatting.
		* @remarks This method is used by CachedDateFormat to
		* format the milliseconds.
		*/
		virtual void number...",1,<empty>,,33,1,CPPASTProblemDeclaration,,<empty>
63985,UNKNOWN,-1,,"class LOG4CXX_EXPORT DateTimeDateFormat : public SimpleDateFormat
{
	public:
		DateTimeDateFormat()
			: SimpleDateFormat(LOG4CXX_STR(""dd MMM yyyy HH:mm:ss,SSS"")) {}
		DateTimeDateFormat(const std::locale* locale)
			: SimpleDateFormat(LOG4CXX_STR(""dd MMM yyyy HH:mm:ss,SSS""), locale) {}
};",1,<empty>,,31,1,CPPASTProblemDeclaration,,<empty>
63999,UNKNOWN,-1,,"class LOG4CXX_EXPORT Exception : public ::std::exception
{
	public:
		Exception(const char* msg);
		Exception(const LogString& msg);
		Exception(const Exception& src);
		Exception& operator=(const Exception& src);
		const char* what() const throw();
	private:
		enum { MSG_SIZE = 128 };
		char msg[MSG_SIZE + 1];
};",1,<empty>,,37,1,CPPASTProblemDeclaration,,<empty>
64000,UNKNOWN,-1,,"class LOG4CXX_EXPORT RuntimeException : public Exception
{
	public:
		RuntimeException(log4cxx_status_t stat);
		RuntimeException(const LogString& msg);
		RuntimeException(const RuntimeException& msg);
		RuntimeException& operator=(const RuntimeException& src);
	private:
		static LogString formatMessage(log4cxx_status_t stat);
};",1,<empty>,,53,2,CPPASTProblemDeclaration,,<empty>
64001,UNKNOWN,-1,,"class LOG4CXX_EXPORT  NullPointerException : public RuntimeException
{
	public:
		NullPointerException(const LogString& msg);
		NullPointerException(const NullPointerException& msg);
		NullPointerException& operator=(const NullPointerException& src);
};",1,<empty>,,67,3,CPPASTProblemDeclaration,,<empty>
64002,UNKNOWN,-1,,"class LOG4CXX_EXPORT IllegalArgumentException : public RuntimeException
{
	public:
		IllegalArgumentException(const LogString& msg);
		IllegalArgumentException(const IllegalArgumentException&);
		IllegalArgumentException& operator=(const IllegalArgumentException&);
};",1,<empty>,,77,4,CPPASTProblemDeclaration,,<empty>
64003,UNKNOWN,-1,,"class LOG4CXX_EXPORT IOException : public Exception
{
	public:
		IOException();
		IOException(log4cxx_status_t stat);
		IOException(const LogString& msg);
		IOException(const IOException& src);
		IOException& operator=(const IOException&);
	private:
		static LogString formatMessage(log4cxx_status_t stat);
};",1,<empty>,,89,5,CPPASTProblemDeclaration,,<empty>
64004,UNKNOWN,-1,,"class LOG4CXX_EXPORT MissingResourceException : public Exception
{
	public:
		MissingResourceException(const LogString& key);
		MissingResourceException(const MissingResourceException& src);
		MissingResourceException& operator=(const MissingResourceException&);
	private:
		static LogString formatMessage(const LogString& key);
};",1,<empty>,,101,6,CPPASTProblemDeclaration,,<empty>
64005,UNKNOWN,-1,,"class LOG4CXX_EXPORT PoolException : public Exception
{
	public:
		PoolException(log4cxx_status_t stat);
		PoolException(const PoolException& src);
		PoolException& operator=(const PoolException&);
	private:
		static LogString formatMessage(log4cxx_status_t stat);
};",1,<empty>,,111,7,CPPASTProblemDeclaration,,<empty>
64006,UNKNOWN,-1,,"class LOG4CXX_EXPORT InterruptedException : public Exception
{
	public:
		InterruptedException();
		InterruptedException(log4cxx_status_t stat);
		InterruptedException(const InterruptedException& src);
		InterruptedException& operator=(const InterruptedException&);
	private:
		static LogString formatMessage(log4cxx_status_t stat);
};",1,<empty>,,122,8,CPPASTProblemDeclaration,,<empty>
64007,UNKNOWN,-1,,"class LOG4CXX_EXPORT ThreadException
	: public Exception
{
	public:
		ThreadException(log4cxx_status_t stat);
		ThreadException(const LogString& msg);
		ThreadException(const ThreadException& src);
		ThreadException& operator=(const ThreadException&);
	private:
		static LogString formatMessage(log4cxx_status_t stat);
};",1,<empty>,,133,9,CPPASTProblemDeclaration,,<empty>
64008,UNKNOWN,-1,,"class LOG4CXX_EXPORT TranscoderException : public Exception
{
	public:
		TranscoderException(log4cxx_status_t stat);
		TranscoderException(const TranscoderException& src);
		TranscoderException& operator=(const TranscoderException&);
	private:
		static LogString formatMessage(log4cxx_status_t stat);
};",1,<empty>,,145,10,CPPASTProblemDeclaration,,<empty>
64009,UNKNOWN,-1,,"class LOG4CXX_EXPORT IllegalMonitorStateException
	: public Exception
{
	public:
		IllegalMonitorStateException(const LogString& msg);
		IllegalMonitorStateException(const IllegalMonitorStateException& msg);
		IllegalMonitorStateException& operator=(const IllegalMonitorStateException& msg);
};",1,<empty>,,155,11,CPPASTProblemDeclaration,,<empty>
64010,UNKNOWN,-1,,"class LOG4CXX_EXPORT InstantiationException : public Exception
{
	public:
		InstantiationException(const LogString& msg);
		InstantiationException(const InstantiationException& msg);
		InstantiationException& operator=(const InstantiationException& msg);
};",1,<empty>,,169,12,CPPASTProblemDeclaration,,<empty>
64011,UNKNOWN,-1,,"class LOG4CXX_EXPORT ClassNotFoundException : public Exception
{
	public:
		ClassNotFoundException(const LogString& className);
		ClassNotFoundException(const ClassNotFoundException& msg);
		ClassNotFoundException& operator=(const ClassNotFoundException& msg);
	private:
		static LogString formatMessage(const LogString& className);
};",1,<empty>,,182,13,CPPASTProblemDeclaration,,<empty>
64042,UNKNOWN,-1,,"class LOG4CXX_EXPORT SocketException : public IOException
{
	public:
		SocketException(const LogString& msg);
		SocketException(log4cxx_status_t status);
		SocketException(const SocketException&);
		SocketException& operator=(const SocketException&);
};",1,<empty>,,212,16,CPPASTProblemDeclaration,,<empty>
64043,UNKNOWN,-1,,"class LOG4CXX_EXPORT ConnectException : public SocketException
{
	public:
		ConnectException(log4cxx_status_t status);
		ConnectException(const ConnectException& src);
		ConnectException& operator=(const ConnectException&);
};",1,<empty>,,225,17,CPPASTProblemDeclaration,,<empty>
64044,UNKNOWN,-1,,"class LOG4CXX_EXPORT ClosedChannelException : public SocketException
{
	public:
		ClosedChannelException();
		ClosedChannelException(const ClosedChannelException& src);
		ClosedChannelException& operator=(const ClosedChannelException&);
};",1,<empty>,,233,18,CPPASTProblemDeclaration,,<empty>
64045,UNKNOWN,-1,,"class LOG4CXX_EXPORT BindException : public SocketException
{
	public:
		BindException(log4cxx_status_t status);
		BindException(const BindException&);
		BindException& operator=(const BindException&);
};",1,<empty>,,245,19,CPPASTProblemDeclaration,,<empty>
64046,UNKNOWN,-1,,"class LOG4CXX_EXPORT InterruptedIOException : public IOException
{
	public:
		InterruptedIOException(const LogString& msg);
		InterruptedIOException(const InterruptedIOException&);
		InterruptedIOException& operator=(const InterruptedIOException&);
};",1,<empty>,,259,20,CPPASTProblemDeclaration,,<empty>
64047,UNKNOWN,-1,,"class LOG4CXX_EXPORT SocketTimeoutException : public InterruptedIOException
{
	public:
		SocketTimeoutException();
		SocketTimeoutException(const SocketTimeoutException&);
		SocketTimeoutException& operator=(const SocketTimeoutException&);
};",1,<empty>,,274,21,CPPASTProblemDeclaration,,<empty>
64063,UNKNOWN,-1,,"class LOG4CXX_EXPORT FileInputStream : public InputStream
{
	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(FileInputStreamPrivate, m_priv)

	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(FileInputStream)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(FileInputStream)
		LOG4CXX_CAST_ENTRY_CHAIN(InputStream)
		END_LOG4CXX_CAST_MAP()

		/**
		 * Creates a FileInputStream by opening a connection to an actual
		 * file, the file named by the path name name in the file system.
		 *
		 * @param filename The system-dependent file name.
		 */
		FileInputStream(const LogString& filename);
		FileInputStream(const logchar* filename);

		/**
		 * Creates a FileInputStream by opening a connection to an actual
		 * file, the file named by the File object file in the file system.
		 *
		 * @param aFile The file to be opened for reading.
		 */
		FileInputStream(const File& aFile);

		virtual ~FileInputStream();

		/**
		 * Closes this file input stream and releases any system
		 * resources associated ...",1,<empty>,,36,1,CPPASTProblemDeclaration,,<empty>
64078,UNKNOWN,-1,,"class LOG4CXX_EXPORT FileOutputStream : public OutputStream
{
	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(FileOutputStreamPrivate, m_priv)

	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(FileOutputStream)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(FileOutputStream)
		LOG4CXX_CAST_ENTRY_CHAIN(OutputStream)
		END_LOG4CXX_CAST_MAP()

		FileOutputStream(const LogString& filename, bool append = false);
		FileOutputStream(const logchar* filename, bool append = false);
		virtual ~FileOutputStream();

		void close(Pool& p) override;
		void flush(Pool& p) override;
		void write(ByteBuffer& buf, Pool& p) override;

		apr_file_t* getFilePtr() const;

	private:
		FileOutputStream(const FileOutputStream&);
		FileOutputStream& operator=(const FileOutputStream&);
		static apr_file_t* open(const LogString& fn, bool append,
			LOG4CXX_NS::helpers::Pool& p);
};",1,<empty>,,35,1,CPPASTProblemDeclaration,,<empty>
64101,UNKNOWN,-1,,"class LOG4CXX_EXPORT FileWatchdog
{
	public:
		virtual ~FileWatchdog();
		/**
		The default delay between every file modification check, set to 60
		seconds.  */
		static long DEFAULT_DELAY /*= 60000*/;

	protected:
		FileWatchdog(const File& filename);
		virtual void doOnChange() = 0;
		void checkAndConfigure();
		const File& file();

	public:
		/**
		Set the delay to observe between each check of the file changes.
		*/
		void setDelay(long delay1);

		/**
		Create a thread that periodically checks for a file change after first calling doOnChange() on the current thread.
		*/
		void start();

		/**
		Stop the thread that periodically checks for a file change.
		*/
		void stop();

		/**
		Is the thread that periodically checks for a file change running?
		*/
		bool is_active();

	private:
		void run();
		bool is_interrupted();


		FileWatchdog(const FileWatchdog&);
		FileWatchdog& operator=(const FileWatchdog&);

		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(FileWatchdogPrivate, m_priv)
};",1,<empty>,,38,1,CPPASTProblemDeclaration,,<empty>
64135,UNKNOWN,-1,,"LOG4CXX_LIST_DEF(InetAddressList, InetAddressPtr);",1,<empty>,,41,4,CPPASTProblemDeclaration,,<empty>
64136,UNKNOWN,-1,,"class LOG4CXX_EXPORT InetAddress : public Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(InetAddress)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(InetAddress)
		END_LOG4CXX_CAST_MAP()

		InetAddress(const LogString& hostName, const LogString& hostAddr);

		~InetAddress();

		/** Determines all the IP addresses of a host, given the host's name.
		*/
		static InetAddressList getAllByName(const LogString& host);

		/** Determines the IP address of a host, given the host's name.
		*/
		static InetAddressPtr getByName(const LogString& host);

		/** Returns the IP address string ""%d.%d.%d.%d"".
		*/
		LogString getHostAddress() const;

		/** Gets the host name for this IP address.
		*/
		LogString getHostName() const;

		/** Returns the local host.
		*/
		static InetAddressPtr  getLocalHost();

		/** Returns an InetAddress which can be used as any
		 *  address, for example when listening on a port from any
		 *  remote addresss.
		 */
		static InetAddressPtr anyAddress();

		/** ...",1,<empty>,,43,5,CPPASTProblemDeclaration,,<empty>
64147,UNKNOWN,-1,,"class LOG4CXX_EXPORT InputStream : public Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(InputStream)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(InputStream)
		END_LOG4CXX_CAST_MAP()

	protected:
		InputStream();

		virtual ~InputStream();

	public:
		/**
		 * Reads a sequence of bytes into the given buffer.
		 *
		 * @param dst The buffer into which bytes are to be transferred.
		 * @return the total number of bytes read into the buffer, or -1 if there
		 *         is no more data because the end of the stream has been reached.
		 */
		virtual int read(ByteBuffer& dst) = 0;

		/**
		 * Closes this input stream and releases any system
		 * resources associated with the stream.
		 */
		virtual void close() = 0;

	private:
		InputStream(const InputStream&);
		InputStream& operator=(const InputStream&);
};",1,<empty>,,34,2,CPPASTProblemDeclaration,,<empty>
64164,UNKNOWN,-1,,"class LOG4CXX_EXPORT InputStreamReader : public Reader
{
	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(InputStreamReaderPrivate, m_priv)

	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(InputStreamReader)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(InputStreamReader)
		LOG4CXX_CAST_ENTRY_CHAIN(Reader)
		END_LOG4CXX_CAST_MAP()

		/**
		 * Creates an InputStreamReader that uses the default charset.
		 *
		 * @param in The input stream to decorate.
		 */
		InputStreamReader(const InputStreamPtr& in);

		/**
		 * Creates an InputStreamReader that uses the given charset decoder.
		 *
		 * @param in The input stream to decorate.
		 * @param enc The charset decoder to use for the conversion.
		 */
		InputStreamReader(const InputStreamPtr& in, const CharsetDecoderPtr& enc);

		~InputStreamReader();

		/**
		 * Closes the stream.
		 *
		 * @param p The memory pool associated with the reader.
		 */
		void close(Pool& p) override;

		/**
		 * @return The complete stream contents as a LogString...",1,<empty>,,40,1,CPPASTProblemDeclaration,,<empty>
64175,UNKNOWN,-1,,"class LOG4CXX_EXPORT Integer : public Object
{
		const int val;
	public:
		DECLARE_LOG4CXX_OBJECT(Integer)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(Integer)
		END_LOG4CXX_CAST_MAP()

		Integer();
		Integer(int i);
		virtual ~Integer();

		inline int intValue() const
		{
			return val;
		}

};",1,<empty>,,28,1,CPPASTProblemDeclaration,,<empty>
64186,UNKNOWN,-1,,"class LOG4CXX_EXPORT ISO8601DateFormat : public SimpleDateFormat
{
	public:
		ISO8601DateFormat()
			: SimpleDateFormat(LOG4CXX_STR(""yyyy-MM-dd HH:mm:ss,SSS"")) {}
};",1,<empty>,,36,1,CPPASTProblemDeclaration,,<empty>
64203,UNKNOWN,-1,,"class LOG4CXX_EXPORT Loader
{
	public:
		static const Class& loadClass(const LogString& clazz);

		static InputStreamPtr getResourceAsStream(
			const LogString& name);
};",1,<empty>,,33,2,CPPASTProblemDeclaration,,<empty>
64215,UNKNOWN,-1,,"class LOG4CXX_EXPORT Locale
{
	public:
		Locale(const LogString& language);
		Locale(const LogString& language, const LogString& country);
		Locale(const LogString& language, const LogString& country,
			const LogString& variant);
		~Locale();

		const LogString& getLanguage() const;
		const LogString& getCountry() const;
		const LogString& getVariant() const;

	protected:
		Locale(const Locale&);
		Locale& operator=(const Locale&);
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(LocalePrivate, m_priv)
};",1,<empty>,,28,1,CPPASTProblemDeclaration,,<empty>
64231,UNKNOWN,-1,,"class LOG4CXX_EXPORT LogLog
{
	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(LogLogPrivate, m_priv)

		friend WideLife<LogLog>;
		LogLog();
		LogLog(const LogLog&);
		LogLog& operator=(const LogLog&);
		static LogLog& getInstance();

	public:
		~LogLog();

		/**
		Use the value of \c enabled as the new internal debug logging state.
		*/
		static void setInternalDebugging(bool enabled);

		/**
		Output \c msg to SystemErrWriter if internal debug logging is enabled.
		*/
		static void debug(const LogString& msg);
		/**
		Output \c msg and <code>ex.what()</code> to SystemErrWriter if internal debug logging is enabled.
		*/
		static void debug(const LogString& msg, const std::exception& e);


		/**
		Output \c msg to SystemErrWriter unconditionally.
		*/
		static void error(const LogString& msg);
		/**
		Output \c msg and <code>ex.what()</code> to SystemErrWriter unconditionally.
		*/
		static void error(const LogString& msg, const std::exception& ex);


		/**
		Change quiet mode to \c ...",1,<empty>,,41,1,CPPASTProblemDeclaration,,<empty>
64250,UNKNOWN,-1,,"class LOG4CXX_EXPORT CharMessageBuffer
{
	public:
		/**
		 *  Creates a new instance.
		 */
		CharMessageBuffer();
		/**
		 *  Destructor.
		 */
		~CharMessageBuffer();


		/**
		 *   Appends string to buffer.
		 *   @param msg string append.
		 *   @return this buffer.
		 */
		CharMessageBuffer& operator<<(const std::basic_string<char>& msg);
		/**
		 *   Appends string to buffer.
		 *   @param msg string to append.
		 *   @return this buffer.
		 */
		CharMessageBuffer& operator<<(const char* msg);
		/**
		 *   Appends string to buffer.
		 *   @param msg string to append.
		 *   @return this buffer.
		 */
		CharMessageBuffer& operator<<(char* msg);

		/**
		 *   Appends character to buffer.
		 *   @param msg character to append.
		 *   @return this buffer.
		 */
		CharMessageBuffer& operator<<(const char msg);
#if LOG4CXX_CFSTRING_API
		/**
		   *   Appends a string into the buffer and
		   *   fixes the buffer to use char characters.
		   *   @param msg message to append.
		   *  ...",1,<empty>,,39,2,CPPASTProblemDeclaration,,<empty>
64258,UNKNOWN,1,,std::basic_ostream<char>&,11,<empty>,,210,1,CPPASTTypeId,,<empty>
64283,UNKNOWN,-1,,"class LOG4CXX_EXPORT Object
{
	public:
		virtual ~Object() {}
		virtual const helpers::Class& getClass() const = 0;
		virtual bool instanceof(const Class& clazz) const = 0;
		virtual const void* cast(const Class& clazz) const = 0;
		DECLARE_LOG4CXX_CLAZZ_OBJECT(Object)
};",1,<empty>,,105,2,CPPASTProblemDeclaration,,<empty>
64301,UNKNOWN,1,,Ret*,33,<empty>,,134,1,CPPASTTypeId,,<empty>
64303,UNKNOWN,1,,void*,50,<empty>,,134,1,CPPASTTypeId,,<empty>
64344,UNKNOWN,-1,,"class LOG4CXX_EXPORT OnlyOnceErrorHandler :
	public virtual spi::ErrorHandler,
	public virtual Object
{
	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(OnlyOnceErrorHandlerPrivate, m_priv)

	public:
		DECLARE_LOG4CXX_OBJECT(OnlyOnceErrorHandler)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(spi::OptionHandler)
		LOG4CXX_CAST_ENTRY(spi::ErrorHandler)
		END_LOG4CXX_CAST_MAP()

		OnlyOnceErrorHandler();

		~OnlyOnceErrorHandler();

		/**
		 Does not do anything.
		 */
		void setLogger(const LoggerPtr& logger) override;


		/**
		\copybrief spi::OptionHandler::activateOptions()

		No action is performed in this implementation.
		*/
		void activateOptions(helpers::Pool& p) override;

		/**
		\copybrief spi::OptionHandler::setOption()

		Supported options | Supported values | Default value
		-------------- | ---------------- | ---------------
		- | - | -
		*/
		void setOption(const LogString& option, const LogString& value) override;


		/**
		Prints the message and the stack trace of th...",1,<empty>,,38,1,CPPASTProblemDeclaration,,<empty>
64366,UNKNOWN,-1,,"class LOG4CXX_EXPORT OptionConverter
{
		/** OptionConverter is a static class. */
	private:
		OptionConverter() {}

	public:
		static LogString convertSpecialChars(const LogString& s);

		/**
		 The boolean equivalent of \c value if it is not empty, otherwise \c defaultValue.

		If <code>value</code> is ""true"", then <code>true</code> is
		returned. If <code>value</code> is ""false"", then
		<code>true</code> is returned. Case of \c value is unimportant.

		@return  <code>defaultValue</code> if \c value is not ""true"" or ""false"", otherwise the boolean equivalent of \c value
		*/
		static bool toBoolean(const LogString& value, bool defaultValue);
		/**
		 The numeric equivalent of \c value if it is not empty, otherwise \c defaultValue.

		@return Zero if \c value does not begin with a valid integral number otherwise the numeric equivalent of \c value
		*/
		static int toInt(const LogString& value, int defaultValue);
		/**
		 The numeric equivalent of \c value if it is not empty, otherwi...",1,<empty>,,46,5,CPPASTProblemDeclaration,,<empty>
64377,UNKNOWN,-1,,"class LOG4CXX_EXPORT OutputStream : public Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(OutputStream)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(OutputStream)
		END_LOG4CXX_CAST_MAP()

	protected:
		OutputStream();
		virtual ~OutputStream();

	public:
		virtual void close(Pool& p) = 0;
		virtual void flush(Pool& p) = 0;
		virtual void write(ByteBuffer& buf, Pool& p) = 0;

	private:
		OutputStream(const OutputStream&);
		OutputStream& operator=(const OutputStream&);
};",1,<empty>,,33,2,CPPASTProblemDeclaration,,<empty>
64392,UNKNOWN,-1,,"class LOG4CXX_EXPORT OutputStreamWriter : public Writer
{
	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(OutputStreamWriterPrivate, m_priv)

	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(OutputStreamWriter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(OutputStreamWriter)
		LOG4CXX_CAST_ENTRY_CHAIN(Writer)
		END_LOG4CXX_CAST_MAP()

		OutputStreamWriter(OutputStreamPtr& out);
		OutputStreamWriter(OutputStreamPtr& out, CharsetEncoderPtr& enc);
		~OutputStreamWriter();

		void close(Pool& p) override;
		void flush(Pool& p) override;
		void write(const LogString& str, Pool& p) override;
		LogString getEncoding() const;

		OutputStreamPtr getOutputStreamPtr() const;

	private:
		OutputStreamWriter(const OutputStreamWriter&);
		OutputStreamWriter& operator=(const OutputStreamWriter&);
};",1,<empty>,,34,1,CPPASTProblemDeclaration,,<empty>
64406,UNKNOWN,-1,,"class LOG4CXX_EXPORT Pool
{
	public:
		Pool();
		Pool(apr_pool_t* pool, bool release);
		~Pool();

		apr_pool_t* getAPRPool();
		apr_pool_t* create();
		void* palloc(size_t length);
		char* pstralloc(size_t length);
		char* itoa(int n);
		char* pstrndup(const char* s, size_t len);
		char* pstrdup(const char* s);
		char* pstrdup(const std::string&);

	protected:
		apr_pool_t* pool;
		const bool release;

	private:
		Pool(const LOG4CXX_NS::helpers::Pool&);
		Pool& operator=(const Pool&);
};",1,<empty>,,32,1,CPPASTProblemDeclaration,,<empty>
64426,UNKNOWN,-1,,"class LOG4CXX_EXPORT Properties
{
	private:
		typedef std::map<LogString, LogString> PropertyMap;
		PropertyMap* properties;
		Properties(const Properties&);
		Properties& operator=(const Properties&);

	public:
		/**
		 *  Create new instance.
		 */
		Properties();
		/**
		 * Destructor.
		 */
		~Properties();
		/**
		Reads a property list (key and element pairs) from the input stream.
		The stream is assumed to be using the ISO 8859-1 character encoding.

		<p>Every property occupies one line of the input stream.
		Each line is terminated by a line terminator (<code>\\n</code> or
		<code>\\r</code> or <code>\\r\\n</code>).
		Lines from the input stream are processed until end of file is reached
		on the input stream.

		<p>A line that contains only whitespace or whose first non-whitespace
		character is an ASCII <code>#</code> or <code>!</code> is ignored
		(thus, <code>#</code> or <code>!</code> indicate comment lines).

		<p>Every line other than a blank line or a comment line d...",1,<empty>,,32,1,CPPASTProblemDeclaration,,<empty>
64440,UNKNOWN,-1,,"class LOG4CXX_EXPORT PropertyResourceBundle : public ResourceBundle
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(PropertyResourceBundle)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(PropertyResourceBundle)
		LOG4CXX_CAST_ENTRY_CHAIN(ResourceBundle)
		END_LOG4CXX_CAST_MAP()

		/**
		Creates a property resource bundle.
		@param inStream property file to read from.
		@throw IOException if an error occurred when reading from the
		input stream.
		*/
		PropertyResourceBundle(InputStreamPtr inStream);

		LogString getString(const LogString& key) const override;

	protected:
		Properties properties;
};",1,<empty>,,35,1,CPPASTProblemDeclaration,,<empty>
64451,UNKNOWN,-1,,"class LOG4CXX_EXPORT Reader : public Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(Reader)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(Reader)
		END_LOG4CXX_CAST_MAP()

	protected:
		/**
		 * Creates a new character-stream reader.
		 */
		Reader();

		virtual ~Reader();

	public:
		/**
		 * Closes the stream.
		 * @param p The memory pool associated with the reader.
		 */
		virtual void close(Pool& p) = 0;

		/**
		 * @return The complete stream contents as a LogString.
		 * @param p The memory pool associated with the reader.
		 */
		virtual LogString read(Pool& p) = 0;

	private:
		Reader(const Reader&);

		Reader& operator=(const Reader&);
};",1,<empty>,,33,1,CPPASTProblemDeclaration,,<empty>
64462,UNKNOWN,-1,,"class LOG4CXX_EXPORT RelativeTimeDateFormat : public DateFormat
{
	public:
		RelativeTimeDateFormat();
		virtual void format(LogString& s,
			log4cxx_time_t tm,
			LOG4CXX_NS::helpers::Pool& p) const;

	private:
		log4cxx_time_t startTime;

};",1,<empty>,,32,1,CPPASTProblemDeclaration,,<empty>
64475,UNKNOWN,-1,,"class LOG4CXX_EXPORT ResourceBundle : public Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(ResourceBundle)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(ResourceBundle)
		END_LOG4CXX_CAST_MAP()

		/**
		Gets a string for the given key from this resource bundle or one of
		its parents. Calling this method is equivalent to calling

		@param key the key for the desired string
		@return the string for the given key
		@throw MissingResourceException - if no object for the given key
		can be found
		*/
		virtual LogString getString(const LogString& key) const = 0;

		/**
		Gets a resource bundle using the specified base name and locale

		@param baseName the base name of the resource bundle, a fully
		qualified class name or property filename
		@param locale the locale for which a resource bundle is desired
		*/
		static ResourceBundlePtr getBundle(const LogString& baseName,
			const Locale& locale);

	protected:
		/*
		Sets the parent bundle of this bundle. The parent bundle is
	...",1,<empty>,,35,4,CPPASTProblemDeclaration,,<empty>
64490,UNKNOWN,-1,,"class LOG4CXX_EXPORT ServerSocket
{
	protected:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(ServerSocketPrivate, m_priv)
		ServerSocket(LOG4CXX_PRIVATE_PTR(ServerSocketPrivate) priv);

	public:

		virtual ~ServerSocket();

		/** Listens for a connection to be made to this socket and
		accepts it
		*/
		virtual SocketPtr accept() = 0;

		/** Closes this socket.
		*/
		virtual void close();

		/** Retrive setting for SO_TIMEOUT.
		*/
		int getSoTimeout() const;

		/** Enable/disable SO_TIMEOUT with the specified timeout, in milliseconds.
		*/
		void setSoTimeout(int timeout);

		static ServerSocketUniquePtr create(int port);

};",1,<empty>,,33,4,CPPASTProblemDeclaration,,<empty>
64508,UNKNOWN,-1,,"LOG4CXX_LIST_DEF(PatternTokenList, LOG4CXX_NS::helpers::SimpleDateFormatImpl::PatternToken*);",1,<empty>,,38,2,CPPASTProblemDeclaration,,<empty>
64509,UNKNOWN,-1,,"class LOG4CXX_EXPORT SimpleDateFormat : public DateFormat
{
	public:
		/**
		 * A time converter and formatter using \c pattern and the default std::locale.
		 *
		 * @param pattern the specifiers describing the date and time format
		 */
		SimpleDateFormat(const LogString& pattern);
		/**
		 * A time converter and formatter using \c pattern and \c locale.
		 *
		 * @param pattern the specifiers describing the date and time format
		 * @param locale the user-preferred set of immutable facets
		 */
		SimpleDateFormat(const LogString& pattern, const std::locale* locale);
		~SimpleDateFormat();

		virtual void format(LogString& s,
			log4cxx_time_t tm,
			LOG4CXX_NS::helpers::Pool& p) const;

		/**
		 * Set time zone.
		 * @param zone new time zone.
		 */
		void setTimeZone(const TimeZonePtr& zone);

	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(SimpleDateFormatPrivate, m_priv)

		static void addToken(const logchar spec, const int repeat, const std::locale* locale, PatternTokenList& p...",1,<empty>,,69,3,CPPASTProblemDeclaration,,<empty>
64525,UNKNOWN,-1,,"class LOG4CXX_EXPORT Socket : public helpers::Object
{
	protected:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(SocketPrivate, m_priv)
		Socket(LOG4CXX_PRIVATE_PTR(SocketPrivate) priv);

	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(Socket)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(Socket)
		END_LOG4CXX_CAST_MAP()

		virtual ~Socket();

		virtual size_t write(ByteBuffer&) = 0;

		/** Closes this socket. */
		virtual void close() = 0;

		/** Returns the value of this socket's address field. */
		InetAddressPtr getInetAddress() const;

		/** Returns the value of this socket's port field. */
		int getPort() const;

		static SocketUniquePtr create(InetAddressPtr& address, int port);

	private:
		Socket(const Socket&);
		Socket& operator=(const Socket&);

};",1,<empty>,,43,5,CPPASTProblemDeclaration,,<empty>
64539,UNKNOWN,-1,,"LOG4CXX_LIST_DEF(ByteList, unsigned char);",1,<empty>,,29,1,CPPASTProblemDeclaration,,<empty>
64540,UNKNOWN,-1,,"class LOG4CXX_EXPORT SocketOutputStream : public OutputStream
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(SocketOutputStream)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(SocketOutputStream)
		LOG4CXX_CAST_ENTRY_CHAIN(OutputStream)
		END_LOG4CXX_CAST_MAP()

		SocketOutputStream(const SocketPtr& socket);
		~SocketOutputStream();

		void close(Pool& p) override;
		void flush(Pool& p) override;
		void write(ByteBuffer& buf, Pool& p) override;

	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(SocketOutputStreamPrivate, m_priv)
		//
		//   prevent copy and assignment statements
		SocketOutputStream(const SocketOutputStream&);
		SocketOutputStream& operator=(const SocketOutputStream&);

};",1,<empty>,,31,2,CPPASTProblemDeclaration,,<empty>
64551,UNKNOWN,-1,,"class LOG4CXX_EXPORT StrftimeDateFormat : public DateFormat
{
	public:
		/**
		Constructs a DateFormat using the given pattern and the default
		time zone.

		@param pattern the pattern describing the date and time format
		*/
		StrftimeDateFormat(const LogString& pattern);
		~StrftimeDateFormat();

		virtual void format(LogString& s,
			log4cxx_time_t tm,
			LOG4CXX_NS::helpers::Pool& p) const;

		/**
		*    Set time zone.
		* @param zone new time zone.
		*/
		void setTimeZone(const TimeZonePtr& zone);


	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(StrftimeDateFormatPrivate, m_priv)
};",1,<empty>,,33,1,CPPASTProblemDeclaration,,<empty>
64600,UNKNOWN,-1,,"class LOG4CXX_EXPORT StringHelper
{
	public:
		static LogString trim(const LogString& s);
		static bool startsWith(const LogString& s, const LogString& suffix);
		static bool endsWith(const LogString& s, const LogString& suffix);
		static bool equalsIgnoreCase(const LogString& s1,
			const logchar* upper, const logchar* lower);
		static bool equalsIgnoreCase(const LogString& s1,
			const LogString& upper, const LogString& lower);


		static int toInt(const LogString& s);
		static int64_t toInt64(const LogString& s);

		static void toString(int i, LOG4CXX_NS::helpers::Pool& pool, LogString& dst);
		static void toString(int64_t i, LOG4CXX_NS::helpers::Pool& pool, LogString& dst);
		static void toString(size_t i, LOG4CXX_NS::helpers::Pool& pool, LogString& dst);

		static void toString(bool val, LogString& dst);

		static LogString toLowerCase(const LogString& s);

		static LogString format(const LogString& pattern, const std::vector<LogString>& params);
};",1,<empty>,,33,2,CPPASTProblemDeclaration,,<empty>
64612,UNKNOWN,-1,,"class LOG4CXX_EXPORT StringTokenizer
{
	public:
		StringTokenizer(const LogString& str, const LogString& delim);
		~StringTokenizer();
		bool hasMoreTokens() const;
		LogString nextToken();

	private:
		//   prevent copy and assignment statements
		StringTokenizer(const StringTokenizer&);
		StringTokenizer& operator=(const StringTokenizer&);

		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(StringTokenizerPrivate, m_priv)
};",1,<empty>,,28,1,CPPASTProblemDeclaration,,<empty>
64626,UNKNOWN,-1,,"class LOG4CXX_EXPORT SyslogWriter
{
	public:
#define SYSLOG_PORT 514
		SyslogWriter(const LogString& syslogHost, int syslogHostPort = SYSLOG_PORT);
		~SyslogWriter();
		void write(const LogString& string);

	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(SyslogWriterPrivate, m_priv)
};",1,<empty>,,33,1,CPPASTProblemDeclaration,,<empty>
64639,UNKNOWN,-1,,"class LOG4CXX_EXPORT System
{
	public:

		/**
		Gets the system property indicated by the specified key.

		@param key the name of the system property.

		@return the string value of the system property, or the default value if
		there is no property with that key.

		@throws IllegalArgumentException if key is empty.
		*/
		static LogString getProperty(const LogString& key);

};",1,<empty>,,33,2,CPPASTProblemDeclaration,,<empty>
64649,UNKNOWN,-1,,"class LOG4CXX_EXPORT SystemErrWriter : public Writer
{
	public:
		DECLARE_LOG4CXX_OBJECT(SystemErrWriter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(SystemErrWriter)
		LOG4CXX_CAST_ENTRY_CHAIN(Writer)
		END_LOG4CXX_CAST_MAP()

		SystemErrWriter();
		virtual ~SystemErrWriter();

		void close(Pool& p) override;
		void flush(Pool& p) override;
		void write(const LogString& str, Pool& p) override;

		static void write(const LogString& str);
		static void flush();

	private:
		SystemErrWriter(const SystemErrWriter&);
		SystemErrWriter& operator=(const SystemErrWriter&);
		static bool isWide();
};",1,<empty>,,31,1,CPPASTProblemDeclaration,,<empty>
64659,UNKNOWN,-1,,"class LOG4CXX_EXPORT SystemOutWriter : public Writer
{
	public:
		DECLARE_LOG4CXX_OBJECT(SystemOutWriter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(SystemOutWriter)
		LOG4CXX_CAST_ENTRY_CHAIN(Writer)
		END_LOG4CXX_CAST_MAP()

		SystemOutWriter();
		~SystemOutWriter();

		void close(Pool& p) override;
		void flush(Pool& p) override;
		void write(const LogString& str, Pool& p) override;

		static void write(const LogString& str);
		static void flush();
	private:
		SystemOutWriter(const SystemOutWriter&);
		SystemOutWriter& operator=(const SystemOutWriter&);
		static bool isWide();
};",1,<empty>,,31,1,CPPASTProblemDeclaration,,<empty>
64677,UNKNOWN,-1,,"class LOG4CXX_EXPORT ThreadLocal
{
	public:
		/**
		 *   Create new instance.
		 */
		ThreadLocal();
		/**
		 *    Destructor.
		 */
		~ThreadLocal();
		/**
		 *  Sets the value in the current thread's copy of this thread-local variable.
		 *  @param priv new value.
		 */
		void set(void* priv);
		/**
		 *  Returns the value in the current thread's copy of this thread-local variable.
		 *  @return value of thread-local variable for the current thread.
		 */
		void* get();

	private:
		/**
		 * Prevent use of default copy constructor.
		 */
		ThreadLocal(const ThreadLocal&);
		/**
		 *   Prevent use of default assignment operator.
		 */
		ThreadLocal& operator=(const ThreadLocal&);

		static apr_threadkey_t* create(Pool& p);

		Pool p;
		apr_threadkey_t* key;
};",1,<empty>,,46,1,CPPASTProblemDeclaration,,<empty>
64689,UNKNOWN,-1,,"class LOG4CXX_EXPORT ThreadSpecificData
{
	public:
		ThreadSpecificData();
		~ThreadSpecificData();

		/**
		 *  Gets current thread specific data.
		 *  @return thread specific data, may be null.
		 */
		static ThreadSpecificData* getCurrentData();
		/**
		 *  Release this ThreadSpecficData if empty.
		 */
		void recycle();

		static void put(const LogString& key, const LogString& val);
		static void push(const LogString& val);
		static void inherit(const LOG4CXX_NS::NDC::Stack& stack);

		LOG4CXX_NS::NDC::Stack& getStack();
		LOG4CXX_NS::MDC::Map& getMap();


	private:
		static ThreadSpecificData& getDataNoThreads();
		static ThreadSpecificData* createCurrentData();
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(ThreadSpecificDataPrivate, m_priv)
};",1,<empty>,,32,1,CPPASTProblemDeclaration,,<empty>
64717,UNKNOWN,-1,,"class LOG4CXX_EXPORT ThreadUtility
{
	private:
		friend class LOG4CXX_NS::helpers::WideLife<ThreadUtility>;
		ThreadUtility();

		LOG4CXX_NS::helpers::ThreadStartPre preStartFunction();
		LOG4CXX_NS::helpers::ThreadStarted threadStartedFunction();
		LOG4CXX_NS::helpers::ThreadStartPost postStartFunction();

		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(priv_data, m_priv)
	public:
		~ThreadUtility();

		static ThreadUtility* instance();

		/**
		 * Utility method for configuring the ThreadUtility in a standard
		 * configuration.
		 */
		static void configure( ThreadConfigurationType type );

		/**
		 * Configure the thread functions that log4cxx will use.
		 * Note that setting any of these parameters to nullptr is valid,
		 * and simply results in the callback not being called.
		 */
		void configureFuncs( ThreadStartPre pre_start,
			ThreadStarted started,
			ThreadStartPost post_start );

		/**
		 * A pre-start thread function that blocks signals to the new thread
		 * (if the system has ...",1,<empty>,,70,7,CPPASTProblemDeclaration,,<empty>
64732,UNKNOWN,-1,,"class LOG4CXX_EXPORT TimeZone : public helpers::Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(TimeZone)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(TimeZone)
		END_LOG4CXX_CAST_MAP()

		static const TimeZonePtr& getDefault();
		static const TimeZonePtr& getGMT();
		static const TimeZonePtr getTimeZone(const LogString& ID);

		const LogString getID() const
		{
			return id;
		}


		/**
		 *   Expand an APR time into the human readable
		 *      components for this timezone.
		 */
		virtual log4cxx_status_t explode(apr_time_exp_t* result,
			log4cxx_time_t input) const = 0;


	protected:
		TimeZone(const LogString& ID);
		virtual ~TimeZone();

		LOG4CXX_DECLARE_PRIVATE_MEMBER(LogString, id)
};",1,<empty>,,33,3,CPPASTProblemDeclaration,,<empty>
64744,UNKNOWN,-1,,"class LOG4CXX_EXPORT Transcoder
{
	public:


		/**
		 *   Appends this specified string of UTF-8 characters to LogString.
		 */
		static void decodeUTF8(const std::string& src, LogString& dst);
		/**
		 *    Converts the LogString to a UTF-8 string.
		 */
		static void encodeUTF8(const LogString& src, std::string& dst);
		/**
		 *    Converts the LogString to a UTF-8 string.
		 */
		static char* encodeUTF8(const LogString& src, LOG4CXX_NS::helpers::Pool& p);
		/**
		 *    Append UCS-4 code point to a byte buffer as UTF-8.
		 */
		static void encodeUTF8(unsigned int sv, ByteBuffer& dst);
		/**
		 *    Append UCS-4 code point to a byte buffer as UTF-16LE.
		 */
		static void encodeUTF16LE(unsigned int sv, ByteBuffer& dst);
		/**
		 *    Append UCS-4 code point to a byte buffer as UTF-16BE.
		 */
		static void encodeUTF16BE(unsigned int sv, ByteBuffer& dst);


		/**
		 *   Decodes next character from a UTF-8 string.
		 *   @param in string from which the character is extracted.
		 *   ...",1,<empty>,,36,3,CPPASTProblemDeclaration,,<empty>
64754,UNKNOWN,-1,,"class LOG4CXX_EXPORT Transform
{
	public:
		/**
		* Add \c input, which may contain HTML tags
		* (ie, &lt;b&gt;, &lt;table&gt;, etc) to \c buf
		* while replacing any '<' and '>' characters
		* with respective predefined entity references.
		*
		* @param buf output stream where to write the modified string.
		* @param input The text to be converted.
		* */
		static void appendEscapingTags(
			LogString& buf, const LogString& input);

		/**
		* Add \c input to \c buf while ensuring embeded CDEnd strings (]]>)
		* are handled properly within the message, NDC and throwable tag text.
		*
		* @param buf output stream holding the XML data to this point.  The
		* initial CDStart (<![CDATA[) and final CDEnd (]]>) of the CDATA
		* section are the responsibility of the calling method.
		* @param input The String that is inserted into an existing CDATA
		* Section within buf.
		*/
		static void appendEscapingCDATA(
			LogString& buf, const LogString& input);
};",1,<empty>,,30,1,CPPASTProblemDeclaration,,<empty>
64812,UNKNOWN,1,,T*,28,<empty>,,63,1,CPPASTTypeId,,<empty>
64822,UNKNOWN,1,,const T*,28,<empty>,,68,1,CPPASTTypeId,,<empty>
64878,UNKNOWN,-1,,"class LOG4CXX_EXPORT Writer : public Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(Writer)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(Writer)
		END_LOG4CXX_CAST_MAP()

	protected:
		Writer();
		virtual ~Writer();

	public:
		virtual void close(Pool& p) = 0;
		virtual void flush(Pool& p) = 0;
		virtual void write(const LogString& str, Pool& p) = 0;

	private:
		Writer(const Writer&);
		Writer& operator=(const Writer&);
};",1,<empty>,,33,1,CPPASTProblemDeclaration,,<empty>
64900,UNKNOWN,-1,,"class LOG4CXX_EXPORT DOMException : public RuntimeException
{
	public:
		DOMException() : RuntimeException(LOG4CXX_STR(""DOM exception"")) {}
};",1,<empty>,,39,7,CPPASTProblemDeclaration,,<empty>
64901,UNKNOWN,-1,,"class LOG4CXX_EXPORT XMLDOMNode : virtual public Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(XMLDOMNode)
		enum XMLDOMNodeType
		{
			NOT_IMPLEMENTED_NODE = 0,
			ELEMENT_NODE = 1,
			DOCUMENT_NODE = 9
		};

		virtual XMLDOMNodeListPtr getChildNodes() = 0;
		virtual XMLDOMNodeType getNodeType() = 0;
		virtual XMLDOMDocumentPtr getOwnerDocument() = 0;
};",1,<empty>,,50,8,CPPASTProblemDeclaration,,<empty>
64903,UNKNOWN,-1,,"class LOG4CXX_EXPORT XMLDOMElement : virtual public XMLDOMNode
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(XMLDOMElement)
		virtual LogString getTagName() = 0;
		virtual LogString getAttribute(const LogString& name) = 0;
};",1,<empty>,,71,10,CPPASTProblemDeclaration,,<empty>
64905,UNKNOWN,-1,,"class LOG4CXX_EXPORT XMLDOMDocument : virtual public XMLDOMNode
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(XMLDOMDocument)
		virtual void load(const File& fileName) = 0;
		virtual XMLDOMElementPtr getDocumentElement() = 0;
		virtual XMLDOMElementPtr getElementById(const LogString& tagName,
			const LogString& elementId) = 0;
};",1,<empty>,,86,12,CPPASTProblemDeclaration,,<empty>
64907,UNKNOWN,-1,,"class LOG4CXX_EXPORT XMLDOMNodeList : virtual public Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(XMLDOMNodeList)
		virtual int getLength() = 0;
		virtual XMLDOMNodePtr item(int index) = 0;
};",1,<empty>,,107,14,CPPASTProblemDeclaration,,<empty>
64952,UNKNOWN,1,,uint32_t,24,<empty>,,35,1,CPPASTTypeId,,<empty>
64955,UNKNOWN,1,,uint32_t,51,<empty>,,35,1,CPPASTTypeId,,<empty>
64965,UNKNOWN,1,,HexdumpFlags,21,<empty>,,39,1,CPPASTTypeId,,<empty>
64968,UNKNOWN,1,,uint32_t,47,<empty>,,39,1,CPPASTTypeId,,<empty>
64971,UNKNOWN,1,,uint32_t,74,<empty>,,39,1,CPPASTTypeId,,<empty>
64975,UNKNOWN,-1,,LOG4CXX_EXPORT,1,<empty>,,53,4,CPPASTProblemDeclaration,,<empty>
65007,UNKNOWN,-1,,"class LOG4CXX_EXPORT Hierarchy : public spi::LoggerRepository
{
	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(HierarchyPrivate, m_priv)

	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(Hierarchy)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(spi::LoggerRepository)
		END_LOG4CXX_CAST_MAP()

	private:
		/**
		Create a new logger hierarchy.
		*/
		Hierarchy();

	public:
		static HierarchyPtr create();

		~Hierarchy();

		void addHierarchyEventListener(const spi::HierarchyEventListenerPtr& listener) override;

		/**
		 * Remove a previously added HierarchyEventListener.
		 *
		 */
#if LOG4CXX_ABI_VERSION <= 15
		void removeHierarchyEventListener(const spi::HierarchyEventListenerPtr& listener);
#else
		void removeHierarchyEventListener(const spi::HierarchyEventListenerPtr& listener) override;
#endif
		/**
		 * Call \c configurator if not yet configured.
		 */
		void ensureIsConfigured(std::function<void()> configurator) override;

		/**
		This call will clear all logger definitions from th...",1,<empty>,,55,3,CPPASTProblemDeclaration,,<empty>
65018,UNKNOWN,-1,,"class LOG4CXX_EXPORT HTMLLayout : public Layout
{
	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(HTMLLayoutPrivate, m_priv)

	public:
		DECLARE_LOG4CXX_OBJECT(HTMLLayout)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(HTMLLayout)
		LOG4CXX_CAST_ENTRY_CHAIN(Layout)
		END_LOG4CXX_CAST_MAP()

		HTMLLayout();
		~HTMLLayout();

		/**
		The <b>LocationInfo</b> option takes a boolean value. By
		default, it is set to false which means there will be no location
		information output by this layout. If the the option is set to
		true, then the file name and line number of the statement
		at the origin of the log statement will be output.

		<p>If you are embedding this layout within an
		{@link net::SMTPAppender SMTPAppender} then make sure
		to set the <b>LocationInfo</b> option of that appender as well.
		*/
		void setLocationInfo(bool locationInfoFlag);

		/**
		Returns the current value of the <b>LocationInfo</b> option.
		*/
		bool getLocationInfo() const;

		/**
		The <b>Title</b> opti...",1,<empty>,,31,1,CPPASTProblemDeclaration,,<empty>
65032,UNKNOWN,-1,,"class LOG4CXX_EXPORT JSONLayout : public Layout
{
	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(JSONLayoutPrivate, m_priv)

	protected:
		void appendQuotedEscapedString(LogString& buf, const LogString& input) const;
		void appendSerializedMDC(LogString& buf,
			const spi::LoggingEventPtr& event) const;
		void appendSerializedNDC(LogString& buf,
			const spi::LoggingEventPtr& event) const;
		void appendSerializedLocationInfo(LogString& buf,
			const spi::LoggingEventPtr& event, LOG4CXX_NS::helpers::Pool& p) const;

	public:
		static void appendItem(const LogString& item, LogString& toAppendTo);
		DECLARE_LOG4CXX_OBJECT(JSONLayout)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(JSONLayout)
		LOG4CXX_CAST_ENTRY_CHAIN(Layout)
		END_LOG4CXX_CAST_MAP()

		JSONLayout();

		~JSONLayout();

		/**
		The <b>LocationInfo</b> option takes a boolean value. By
		default, it is set to false which means there will be no location
		information output by this layout. If the the option is set to
		tr...",1,<empty>,,31,1,CPPASTProblemDeclaration,,<empty>
65046,UNKNOWN,-1,,"class LOG4CXX_EXPORT Layout :
	public virtual spi::OptionHandler,
	public virtual helpers::Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(Layout)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(Layout)
		LOG4CXX_CAST_ENTRY(spi::OptionHandler)
		END_LOG4CXX_CAST_MAP()

		virtual ~Layout();

		/**
		Implement this method to create your own layout format.
		*/
		virtual void format(LogString& output,
			const spi::LoggingEventPtr& event, LOG4CXX_NS::helpers::Pool& pool) const = 0;

		/**
		Returns the content type output by this layout. The base class
		returns ""text/plain"".
		*/
		virtual LogString getContentType() const;

		/**
		Append the header for the layout format. The base class does
		nothing.
		*/
		virtual void appendHeader(LogString& output, LOG4CXX_NS::helpers::Pool& p);

		/**
		Append the footer for the layout format. The base class does
		nothing.
		*/
		virtual void appendFooter(LogString& output, LOG4CXX_NS::helpers::Pool& p);

		/**
		If the layout handles the t...",1,<empty>,,31,1,CPPASTProblemDeclaration,,<empty>
65064,UNKNOWN,-1,,"class LOG4CXX_EXPORT Level : public helpers::Object
{
	public:
		class LOG4CXX_EXPORT LevelClass : public helpers::Class
		{
			public:
				LevelClass() : helpers::Class() {}

				virtual LogString getName() const
				{
					return LOG4CXX_STR(""Level"");
				}

				virtual LevelPtr toLevel(const LogString& sArg) const
				{
					return Level::toLevelLS(sArg);
				}

				virtual LevelPtr toLevel(int val) const
				{
					return Level::toLevel(val);
				}
		};

		DECLARE_LOG4CXX_OBJECT_WITH_CUSTOM_CLASS(Level, LevelClass)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(Level)
		END_LOG4CXX_CAST_MAP()

		/**
		Instantiate a Level object.
		*/
		Level(int level,
			const LogString& name,
			int syslogEquivalent);

		/**
		Convert the string passed as argument to a level. If the
		conversion fails, then this method returns DEBUG.
		* @param sArg level name.
		*/
		static LevelPtr toLevel(const std::string& sArg);
		/**
		Convert the string passed as argument to a level. If the
		conversio...",1,<empty>,,48,3,CPPASTProblemDeclaration,,<empty>
65169,UNKNOWN,-1,,"LOG4CXX_LIST_DEF(LoggerList, LoggerPtr);",1,<empty>,,42,4,CPPASTProblemDeclaration,,<empty>
65170,UNKNOWN,-1,,"class LOG4CXX_EXPORT Logger :
	public virtual LOG4CXX_NS::spi::AppenderAttachable
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(Logger)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(Logger)
		LOG4CXX_CAST_ENTRY(spi::AppenderAttachable)
		END_LOG4CXX_CAST_MAP()

	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(LoggerPrivate, m_priv)
		int m_threshold; //!< The cached level of this logger

	public:
		/**
		This constructor initializes a new <code>logger</code> instance and
		sets its name.

		<p>It is intended to be only used by factory-classes.

		@param pool lifetime of pool must be longer than logger.
		@param name The name of the logger.
		*/
		Logger(helpers::Pool& pool, const LogString& name);

		~Logger();


		/**
		Add <code>newAppender</code> to the list of appenders of this
		Logger instance.

		<p>If <code>newAppender</code> is already in the list of
		appenders, then it won't be added again.
		*/
		void addAppender(const AppenderPtr newAppender) override;


		/**
		Call the...",1,<empty>,,49,5,CPPASTProblemDeclaration,,<empty>
65171,UNKNOWN,-1,,"LOG4CXX_LIST_DEF(LoggerList, LoggerPtr);",1,<empty>,,1972,6,CPPASTProblemDeclaration,,<empty>
65318,UNKNOWN,-1,,"class LOG4CXX_EXPORT LogManager
{
	private:
		static void* guard;
		static spi::RepositorySelectorPtr getRepositorySelector();

	public:
		/**
		Use \c selector to source the {@link spi::LoggerRepository LoggerRepository}, but only if the correct
		\c guard is passed as parameter.

		<p>Initally the guard is null.  If the guard is
		<code>null</code>, then invoking this method sets the logger
		factory and the guard. Following invocations will throw a
		{@link helpers::IllegalArgumentException IllegalArgumentException},
		unless the previously set \c guard is passed as the second
		parameter.

		<p>This allows a high-level component to set the
		{@link spi::RepositorySelector RepositorySelector}
		used by the LogManager.
		*/

		static void setRepositorySelector(spi::RepositorySelectorPtr selector,
			void* guard);

		static spi::LoggerRepositoryPtr getLoggerRepository();

		/**
		Retrieve the root logger from the {@link spi::LoggerRepository LoggerRepository}.

		Calls {@link spi::...",1,<empty>,,44,5,CPPASTProblemDeclaration,,<empty>
65344,UNKNOWN,-1,,"class LOG4CXX_EXPORT MDC
{
	public:
		/** String to string stl map.
		*/
		typedef std::map<LogString, LogString> Map;

		/**
		 *  Places a key/value pair in the MDC for the current thread
		 *    which will be removed during the corresponding destructor.  Both
		 *    construction and destruction are expected to be on the same thread.
		 *    @param key context identifier
		 *    @param value a string that distinguishes this context.
		 */
		MDC(const std::string& key, const std::string& value);
		~MDC();

		/**
		* Set the <code>key</code> context in the current thread's context map to <code>value</code>.
		*
		* <p>If the current thread does not have a context map it is
		* created as a side effect.
		 *    @param key context identifier
		 *    @param value a string that distinguishes this context.
		*/
		static void put(const std::string& key, const std::string& value);
		/**
		* Set the <code>key</code> context in the current thread's context map to <code>value</code>.
		*
		*...",1,<empty>,,45,1,CPPASTProblemDeclaration,,<empty>
65357,UNKNOWN,-1,,"class LOG4CXX_EXPORT NDC
{
	public:
		/**
		 *  Pair of Message and FullMessage.
		 */
		typedef std::pair<LogString, LogString> DiagnosticContext;
		typedef std::stack<DiagnosticContext> Stack;

		/**
		 Add \c message onto the context stack.
		 @see The #push method.

		 @param message The text added to the diagnostic context information.
		 */
		NDC(const std::string& message);

		/**
		Remove the topmost element from the context stack associated with the current thread.

		@see The #pop method.
		*/
		~NDC();

		/**
		Clear any nested diagnostic information if any. This method is
		useful in cases where the same thread can be potentially used
		over and over in different unrelated contexts.
		*/
		static void clear();

		/**
		    Clone the diagnostic context for the current thread.
		    <p>Internally a diagnostic context is represented as a stack.  A
		    given thread can supply the stack (i.e. diagnostic context) to a
		    child thread so that the child can inherit the pare...",1,<empty>,,78,1,CPPASTProblemDeclaration,,<empty>
65371,UNKNOWN,-1,,"class LOG4CXX_EXPORT SMTPAppender : public AppenderSkeleton
{
	private:
		struct SMTPPriv;
		SMTPAppender(const SMTPAppender&);
		SMTPAppender& operator=(const SMTPAppender&);
		static bool asciiCheck(const LogString& value, const LogString& label);

		/**
		This method determines if there is a sense in attempting to append.
		<p>It checks whether there is a set output target and also if
		there is a set layout. If these checks fail, then the boolean
		value <code>false</code> is returned. */
		bool checkEntryConditions();

	public:
		DECLARE_LOG4CXX_OBJECT(SMTPAppender)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(SMTPAppender)
		LOG4CXX_CAST_ENTRY_CHAIN(AppenderSkeleton)
		END_LOG4CXX_CAST_MAP()

		SMTPAppender();
		/**
		The default constructor will instantiate the appender with a
		spi::TriggeringEventEvaluator that will trigger on events with
		level ERROR or higher.*/
		SMTPAppender(LOG4CXX_NS::helpers::Pool& p);

		/**
		Use <code>evaluator</code> passed as parameter as th...",1,<empty>,,71,1,CPPASTProblemDeclaration,,<empty>
65388,UNKNOWN,-1,,"class LOG4CXX_EXPORT SocketAppenderSkeleton : public AppenderSkeleton
{
	protected:
		struct SocketAppenderSkeletonPriv;

	public:
		SocketAppenderSkeleton(int defaultPort, int reconnectionDelay);
		~SocketAppenderSkeleton();

		/**
		Connects to remote server at <code>address</code> and <code>port</code>.
		*/
		SocketAppenderSkeleton(helpers::InetAddressPtr address, int port, int reconnectionDelay);

		/**
		Connects to remote server at <code>host</code> and <code>port</code>.
		*/
		SocketAppenderSkeleton(const LogString& host, int port, int reconnectionDelay);

		/**
		\copybrief AppenderSkeleton::activateOptions()

		Connects to the specified <b>RemoteHost</b> and <b>Port</b>.
		*/
		void activateOptions(helpers::Pool& p) override;

		void close() override;


		/**
		* This appender does not use a layout. Hence, this method
		* returns <code>false</code>.
		*
		     */
		bool requiresLayout() const override
		{
			return false;
		}

		/**
		* The <b>RemoteHost</b> option takes ...",1,<empty>,,35,1,CPPASTProblemDeclaration,,<empty>
65400,UNKNOWN,-1,,"class LOG4CXX_EXPORT SyslogAppender : public AppenderSkeleton
{
	public:
		DECLARE_LOG4CXX_OBJECT(SyslogAppender)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(SyslogAppender)
		LOG4CXX_CAST_ENTRY_CHAIN(AppenderSkeleton)
		END_LOG4CXX_CAST_MAP()



		SyslogAppender();
		SyslogAppender(const LayoutPtr& layout, int syslogFacility);
		SyslogAppender(const LayoutPtr& layout,
			const LogString& syslogHost, int syslogFacility);
		~SyslogAppender();
		/** Release any resources held by this SyslogAppender.*/
		void close() override;

		/**
		Returns the specified syslog facility as a lower-case String,
		e.g. ""kern"", ""user"", etc.
		*/
		static LogString getFacilityString(int syslogFacility);

		/**
		Returns the integer value corresponding to the named syslog
		facility, or -1 if it couldn't be recognized.
		@param facilityName one of the strings KERN, USER, MAIL, DAEMON,
		AUTH, SYSLOG, LPR, NEWS, UUCP, CRON, AUTHPRIV, FTP, LOCAL0,
		LOCAL1, LOCAL2, LOCAL3, LOCAL4, LOCAL5, LOCAL6, LOCAL...",1,<empty>,,41,1,CPPASTProblemDeclaration,,<empty>
65424,UNKNOWN,-1,,"LOG4CXX_LIST_DEF(ConnectionList, Connection);",1,<empty>,,37,2,CPPASTProblemDeclaration,,<empty>
65425,UNKNOWN,-1,,"class LOG4CXX_EXPORT TelnetAppender : public AppenderSkeleton
{
		class SocketHandler;
		friend class SocketHandler;
	private:
		static const int DEFAULT_PORT;
		static const int MAX_CONNECTIONS;

	public:
		DECLARE_LOG4CXX_OBJECT(TelnetAppender)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(TelnetAppender)
		LOG4CXX_CAST_ENTRY_CHAIN(AppenderSkeleton)
		END_LOG4CXX_CAST_MAP()

		TelnetAppender();
		~TelnetAppender();

		/**
		This appender requires a layout to format the text to the
		attached client(s). */
		bool requiresLayout() const override
		{
			return true;
		}

		/**
		The current encoding value.

		\sa setOption
		 */
		LogString getEncoding() const;
		/**
		Set the encoding to \c value.

		\sa setOption
		 */
		void setEncoding(const LogString& value);


		/**
		\copybrief AppenderSkeleton::activateOptions()

		Create the socket handler and wait for connections.
		*/
		void activateOptions(helpers::Pool& p) override;


		/**
		\copybrief AppenderSkeleton::setOption()

	...",1,<empty>,,64,3,CPPASTProblemDeclaration,,<empty>
65438,UNKNOWN,-1,,"class LOG4CXX_EXPORT XMLSocketAppender : public SocketAppenderSkeleton
{
	public:
		/**
		The default port number of remote logging server (4560).
		*/
		static int DEFAULT_PORT;

		/**
		The default reconnection delay (30000 milliseconds or 30 seconds).
		*/
		static int DEFAULT_RECONNECTION_DELAY;

		/**
		Unused
		*/
		static const int MAX_EVENT_LEN;

		DECLARE_LOG4CXX_OBJECT(XMLSocketAppender)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(XMLSocketAppender)
		LOG4CXX_CAST_ENTRY_CHAIN(AppenderSkeleton)
		END_LOG4CXX_CAST_MAP()

		XMLSocketAppender();
		~XMLSocketAppender();

		/**
		Connects to remote server at <code>address</code> and <code>port</code>.
		*/
		XMLSocketAppender(helpers::InetAddressPtr address, int port);

		/**
		Connects to remote server at <code>host</code> and <code>port</code>.
		*/
		XMLSocketAppender(const LogString& host, int port);


	protected:
		void setSocket(LOG4CXX_NS::helpers::SocketPtr& socket, helpers::Pool& p) override;

		void cleanUp(helpers...",1,<empty>,,99,1,CPPASTProblemDeclaration,,<empty>
65449,UNKNOWN,-1,,"class LOG4CXX_EXPORT NTEventLogAppender : public AppenderSkeleton
{
	public:
		DECLARE_LOG4CXX_OBJECT(NTEventLogAppender)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(NTEventLogAppender)
		LOG4CXX_CAST_ENTRY_CHAIN(AppenderSkeleton)
		END_LOG4CXX_CAST_MAP()

		NTEventLogAppender();
		NTEventLogAppender(const LogString& server, const LogString& log,
			const LogString& source, const LayoutPtr& layout);

		virtual ~NTEventLogAppender();

		/**
		\copybrief AppenderSkeleton::activateOptions()

		Calls <a href=""https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-registereventsourcew"">RegisterEventSource</a>.
		*/
		void activateOptions(helpers::Pool& p) override;
		void close() override;

		/**
		\copybrief AppenderSkeleton::setOption()

		Supported options | Supported values | Default value
		-------------- | ---------------- | ---------------
		Server | (\ref winapi ""1"") | NULL
		Source | (\ref winapi ""1"") | -
		Log | (\ref eventLog ""2"") | Application

		\anchor w...",1,<empty>,,30,1,CPPASTProblemDeclaration,,<empty>
65460,UNKNOWN,-1,,"class LOG4CXX_EXPORT OutputDebugStringAppender : public AppenderSkeleton
{
	public:
		DECLARE_LOG4CXX_OBJECT(OutputDebugStringAppender)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(OutputDebugStringAppender)
		LOG4CXX_CAST_ENTRY_CHAIN(AppenderSkeleton)
		END_LOG4CXX_CAST_MAP()

		OutputDebugStringAppender();

		bool requiresLayout() const override
		{
			return true;
		}

		void close() override {}

		void append(const spi::LoggingEventPtr& event, helpers::Pool& p) override;
};",1,<empty>,,27,1,CPPASTProblemDeclaration,,<empty>
65470,UNKNOWN,-1,,"class LOG4CXX_EXPORT ClassNamePatternConverter : public NamePatternConverter
{
	public:
		/**
		 * @param options options, may be null.
		 */
		ClassNamePatternConverter(const std::vector<LogString>& options);

		DECLARE_LOG4CXX_PATTERN(ClassNamePatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(ClassNamePatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(NamePatternConverter)
		END_LOG4CXX_CAST_MAP()

		/**
		 * Gets an instance of ClassNamePatternConverter.
		 * @param options options, may be null.
		 * @return instance of pattern converter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		using NamePatternConverter::format;

		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			helpers::Pool& p) const override;
};",1,<empty>,,36,1,CPPASTProblemDeclaration,,<empty>
65480,UNKNOWN,-1,,"class LOG4CXX_EXPORT ColorEndPatternConverter
	: public LoggingEventPatternConverter
{
	public:
		DECLARE_LOG4CXX_PATTERN(ColorEndPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(ColorEndPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		ColorEndPatternConverter();

		/**
		 * Obtains an instance of pattern converter.
		 * @param options options, may be null.
		 * @return instance of pattern converter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		using LoggingEventPatternConverter::format;

		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			helpers::Pool& p) const override;
};",1,<empty>,,35,1,CPPASTProblemDeclaration,,<empty>
65490,UNKNOWN,-1,,"class LOG4CXX_EXPORT ColorStartPatternConverter
	: public LoggingEventPatternConverter
{
	struct ColorPatternConverterPrivate;

	public:
		DECLARE_LOG4CXX_PATTERN(ColorStartPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(ColorStartPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		ColorStartPatternConverter();

		/**
		 * Obtains an instance of pattern converter.
		 * @param options options, may be null.
		 * @return instance of pattern converter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		using LoggingEventPatternConverter::format;

		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			helpers::Pool& p) const override;

		void setFatalColor(const LogString& color);
		void setErrorColor(const LogString& color);
		void setWarnColor(const LogString& color);
		void setInfoColor(const LogString& color);
		void setDebugColor(const LogString& col...",1,<empty>,,35,1,CPPASTProblemDeclaration,,<empty>
65506,UNKNOWN,-1,,"class LOG4CXX_EXPORT DatePatternConverter : public LoggingEventPatternConverter
{
		struct DatePatternConverterPrivate;

		/**
		 * Obtains an instance of pattern converter.
		 * @param options options, may be null.
		 * @return instance of pattern converter.
		 */
		static helpers::DateFormatPtr getDateFormat(const OptionsList& options);
	public:
		DECLARE_LOG4CXX_PATTERN(DatePatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(DatePatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		/**
		 * An object that can convert a date or timestamp to the format
		 * described by the conversion specifier in the first element in \c options.
		 *
		 * If the conversion specifier contains a \% character,
		 * the date is formated using <a href=""https://en.cppreference.com/w/cpp/chrono/c/strftime"">strftime</a>.
		 *
		 * Otherwise the conversion specifier must be a pattern compatible with
		 * java.text.SimpleDateFormat, ""ABSOLUTE"", ...",1,<empty>,,35,1,CPPASTProblemDeclaration,,<empty>
65517,UNKNOWN,-1,,"class LOG4CXX_EXPORT FileDatePatternConverter
{
		/**
		 * Private constructor.
		 */
		FileDatePatternConverter();

	public:
		/**
		 * An instance of pattern converter for date conversion and formatting.
		 *
		 * \sa DatePatternConverter::newInstance()
		 *
		 * @param options If empty, used the patterm ""yyyy-MM-dd"".
		 * @return The date conversion and formatting instance.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);
};",1,<empty>,,37,1,CPPASTProblemDeclaration,,<empty>
65527,UNKNOWN,-1,,"class LOG4CXX_EXPORT FileLocationPatternConverter
	: public LoggingEventPatternConverter
{
	public:
		DECLARE_LOG4CXX_PATTERN(FileLocationPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(FileLocationPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		FileLocationPatternConverter();

		/**
		 * Obtains an instance of pattern converter.
		 * @param options options, may be null.
		 * @return instance of pattern converter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		using LoggingEventPatternConverter::format;

		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			helpers::Pool& p) const override;
};",1,<empty>,,35,1,CPPASTProblemDeclaration,,<empty>
65541,UNKNOWN,-1,,"class LOG4CXX_EXPORT FormattingInfo : public virtual LOG4CXX_NS::helpers::Object
{
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(FormattingInfoPrivate, m_priv)

	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(FormattingInfo)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(FormattingInfo)
		END_LOG4CXX_CAST_MAP()


		/**
		 * Creates new instance.
		 * @param leftAlign left align if true.
		 * @param minLength minimum length.
		 * @param maxLength maximum length.
		 */
		FormattingInfo(
			const bool leftAlign, const int minLength, const int maxLength);
		~FormattingInfo();

		/**
		 * Gets default instance.
		 * @return default instance.
		 */
		static FormattingInfoPtr getDefault();

		/**
		 * Determine if left aligned.
		 * @return true if left aligned.
		 */
		bool isLeftAligned() const;

		/**
		 * Get minimum length.
		 * @return minimum length.
		 */
		int getMinLength() const;

		/**
		 * Get maximum length.
		 * @return maximum length.
		 */
		int getMaxLength() const;

		/**
		 * Adjust...",1,<empty>,,43,3,CPPASTProblemDeclaration,,<empty>
65552,UNKNOWN,-1,,"class LOG4CXX_EXPORT FullLocationPatternConverter
	: public LoggingEventPatternConverter
{
	public:
		DECLARE_LOG4CXX_PATTERN(FullLocationPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(FullLocationPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		FullLocationPatternConverter();

		/**
		 * Obtains an instance of pattern converter.
		 * @param options options, may be null.
		 * @return instance of pattern converter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		using LoggingEventPatternConverter::format;

		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			helpers::Pool& p) const override;
};",1,<empty>,,35,1,CPPASTProblemDeclaration,,<empty>
65562,UNKNOWN,-1,,"class LOG4CXX_EXPORT IntegerPatternConverter : public PatternConverter
{
	public:
		DECLARE_LOG4CXX_PATTERN(IntegerPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(IntegerPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(PatternConverter)
		END_LOG4CXX_CAST_MAP()

		IntegerPatternConverter();

		/**
		 * Obtains an instance of pattern converter.
		 * @param options options, may be null.
		 * @return instance of pattern converter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		void format(const helpers::ObjectPtr& obj,
			LogString& toAppendTo,
			helpers::Pool& p) const override;
};",1,<empty>,,35,1,CPPASTProblemDeclaration,,<empty>
65573,UNKNOWN,-1,,"class LOG4CXX_EXPORT LevelPatternConverter : public LoggingEventPatternConverter
{
	public:
		DECLARE_LOG4CXX_PATTERN(LevelPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(LevelPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		LevelPatternConverter();

		/**
		 * Obtains an instance of pattern converter.
		 * @param options options, may be null.
		 * @return instance of pattern converter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		using LoggingEventPatternConverter::format;

		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			helpers::Pool& p) const override;

		LogString getStyleClass(const 	helpers::ObjectPtr& e) const override;
};",1,<empty>,,35,1,CPPASTProblemDeclaration,,<empty>
65583,UNKNOWN,-1,,"class LOG4CXX_EXPORT LineLocationPatternConverter
	: public LoggingEventPatternConverter
{
	public:
		DECLARE_LOG4CXX_PATTERN(LineLocationPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(LineLocationPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		LineLocationPatternConverter();

		/**
		 * Obtains an instance of pattern converter.
		 * @param options options, may be null.
		 * @return instance of pattern converter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		using LoggingEventPatternConverter::format;

		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			helpers::Pool& p) const override;
};",1,<empty>,,35,1,CPPASTProblemDeclaration,,<empty>
65593,UNKNOWN,-1,,"class LOG4CXX_EXPORT LineSeparatorPatternConverter
	: public LoggingEventPatternConverter
{
	public:
		DECLARE_LOG4CXX_PATTERN(LineSeparatorPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(LineSeparatorPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		LineSeparatorPatternConverter();

		/**
		 * Obtains an instance of pattern converter.
		 * @param options options, may be null.
		 * @return instance of pattern converter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		using LoggingEventPatternConverter::format;

		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			helpers::Pool& p) const override;

		void format(const helpers::ObjectPtr& obj,
			LogString& toAppendTo,
			helpers::Pool& p) const override;
};",1,<empty>,,35,1,CPPASTProblemDeclaration,,<empty>
65603,UNKNOWN,-1,,"class LOG4CXX_EXPORT LiteralPatternConverter : public LoggingEventPatternConverter
{
		struct LiteralPatternConverterPrivate;

	public:
		DECLARE_LOG4CXX_PATTERN(LiteralPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(LiteralPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		LiteralPatternConverter(const LogString& literal);

		static PatternConverterPtr newInstance(const LogString& literal);

		using LoggingEventPatternConverter::format;

		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			helpers::Pool& p) const override;

		void format(const helpers::ObjectPtr& obj,
			LogString& toAppendTo,
			helpers::Pool& p) const override;
};",1,<empty>,,35,1,CPPASTProblemDeclaration,,<empty>
65613,UNKNOWN,-1,,"class LOG4CXX_EXPORT LoggerPatternConverter : public NamePatternConverter
{
	public:
		DECLARE_LOG4CXX_PATTERN(LoggerPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(LoggerPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(NamePatternConverter)
		END_LOG4CXX_CAST_MAP()

		LoggerPatternConverter(const std::vector<LogString>& options);

		/**
		 * Obtains an instance of pattern converter.
		 * @param options options, may be null.
		 * @return instance of pattern converter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		using NamePatternConverter::format;

		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			helpers::Pool& p) const override;
};",1,<empty>,,36,1,CPPASTProblemDeclaration,,<empty>
65625,UNKNOWN,-1,,"class LOG4CXX_EXPORT LoggingEventPatternConverter : public PatternConverter
{
	protected:
		/**
		 * Constructs an instance of LoggingEventPatternConverter.
		 * @param name name of converter.
		 * @param style CSS style for output.
		 */
		LoggingEventPatternConverter(
			const LogString& name, const LogString& style);

		LoggingEventPatternConverter(std::unique_ptr<PatternConverterPrivate> priv);

	public:
		DECLARE_LOG4CXX_PATTERN(LoggingEventPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(LoggingEventPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(PatternConverter)
		END_LOG4CXX_CAST_MAP()

		/**
		 * Formats an event into a string buffer.
		 * @param event event to format, may not be null.
		 * @param toAppendTo string buffer to which the formatted event will be appended.  May not be null.
		 * @param p pool for memory allocations needing during format.
		 */
		virtual void format(
			const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			helpers::Pool& ...",1,<empty>,,37,1,CPPASTProblemDeclaration,,<empty>
65636,UNKNOWN,-1,,"class LOG4CXX_EXPORT MDCPatternConverter : public LoggingEventPatternConverter
{
	public:
		DECLARE_LOG4CXX_PATTERN(MDCPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(MDCPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		MDCPatternConverter
			( const LogString&              name = LogString()
			, const LogString&              style = LogString()
			, const std::vector<LogString>& options = std::vector<LogString>()
			);

		/**
		 * An instance of MDCPatternConverter.
		 * @param options if not empty, options[0][0] is the character to duplicate
		 */
		static PatternConverterPtr newInstance(const std::vector<LogString>& options);

		using LoggingEventPatternConverter::format;

		void format
			( const spi::LoggingEventPtr& event
			, LogString&                  toAppendTo
			, helpers::Pool&              p
			) const override;
};",1,<empty>,,32,1,CPPASTProblemDeclaration,,<empty>
65646,UNKNOWN,-1,,"class LOG4CXX_EXPORT MessagePatternConverter : public LoggingEventPatternConverter
{
	public:
		DECLARE_LOG4CXX_PATTERN(MessagePatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(MessagePatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		MessagePatternConverter();

		/**
		 * Obtains an instance of pattern converter.
		 * @param options options, may be null.
		 * @return instance of pattern converter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		using LoggingEventPatternConverter::format;

		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			helpers::Pool& p) const override;
};",1,<empty>,,35,1,CPPASTProblemDeclaration,,<empty>
65656,UNKNOWN,-1,,"class LOG4CXX_EXPORT MethodLocationPatternConverter
	: public LoggingEventPatternConverter
{
	public:
		DECLARE_LOG4CXX_PATTERN(MethodLocationPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(MethodLocationPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		MethodLocationPatternConverter();

		/**
		 * Obtains an instance of MethodLocationPatternConverter.
		 * @param options options, may be null.
		 * @return instance of MethodLocationPatternConverter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		using LoggingEventPatternConverter::format;

		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			helpers::Pool& p) const override;
};",1,<empty>,,35,1,CPPASTProblemDeclaration,,<empty>
65670,UNKNOWN,-1,,"class LOG4CXX_EXPORT NameAbbreviator : public LOG4CXX_NS::helpers::Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(NameAbbreviator)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(NameAbbreviator)
		END_LOG4CXX_CAST_MAP()

	protected:
		NameAbbreviator();

	public:
		virtual ~NameAbbreviator();

		/**
		 * Gets an abbreviator.
		 *
		 * For example, ""%logger{2}"" will output only 2 elements of the logger name,
		 * ""%logger{1.}"" will output only the first character of the non-final elements in the name,
		 * ""%logger(1~.2~} will output the first character of the first element, two characters of
		 * the second and subsequent elements and will use a tilde to indicate abbreviated characters.
		 *
		 * @param pattern abbreviation pattern.
		 * @return abbreviator, will not be null.
		 */
		static NameAbbreviatorPtr getAbbreviator(const LogString& pattern);

		/**
		 * Gets default abbreviator.
		 *
		 * @return default abbreviator.
		 */
		static NameAbbreviatorPtr getDefaultAbbrevi...",1,<empty>,,38,3,CPPASTProblemDeclaration,,<empty>
65684,UNKNOWN,-1,,"class LOG4CXX_EXPORT NamePatternConverter : public LoggingEventPatternConverter
{
		struct NamePatternConverterPrivate;

	public:
		DECLARE_LOG4CXX_PATTERN(NamePatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(NamePatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()


	protected:
		/**
		 * Constructor.
		 * @param name name of converter.
		 * @param style style name for associated output.
		 * @param options options, may be null, first element will be interpreted as an abbreviation pattern.
		 */
		NamePatternConverter(
			const LogString& name,
			const LogString& style,
			const std::vector<LogString>& options);

		/**
		 * Abbreviate name in string buffer.
		 * @param nameStart starting position of name to abbreviate.
		 * @param buf string buffer containing name.
		 */
		void abbreviate(LogString::size_type nameStart, LogString& buf) const;

	private:
		NameAbbreviatorPtr getAbbreviator(const std::vector<LogString>&...",1,<empty>,,36,1,CPPASTProblemDeclaration,,<empty>
65694,UNKNOWN,-1,,"class LOG4CXX_EXPORT NDCPatternConverter : public LoggingEventPatternConverter
{
	public:
		DECLARE_LOG4CXX_PATTERN(NDCPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(NDCPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		NDCPatternConverter();

		/**
		 * Obtains an instance of NDCPatternConverter.
		 * @param options options, may be null.
		 * @return instance of NDCPatternConverter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		using LoggingEventPatternConverter::format;

		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			helpers::Pool& p) const override;
};",1,<empty>,,35,1,CPPASTProblemDeclaration,,<empty>
65709,UNKNOWN,-1,,"class LOG4CXX_EXPORT PatternConverter : public virtual helpers::Object
{
	protected:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(PatternConverterPrivate, m_priv)
		PatternConverter(LOG4CXX_PRIVATE_PTR(PatternConverterPrivate) priv);

		/**
		 * Create a new pattern converter.  Use this constructor when you have a subclass
		 * that does not have any private data.
		 * @param name name for pattern converter.
		 * @param style CSS style for formatted output.
		 */
		PatternConverter(const LogString& name,
			const LogString& style);

		virtual ~PatternConverter();

	public:
        DECLARE_LOG4CXX_PATTERN(PatternConverter)
        BEGIN_LOG4CXX_CAST_MAP()
        LOG4CXX_CAST_ENTRY(PatternConverter)
        END_LOG4CXX_CAST_MAP()

		/**
		 * Formats an object into a string buffer.
		 * @param obj event to format, may not be null.
		 * @param toAppendTo string buffer to which the formatted event will be appended.  May not be null.
		 * @param p pool for any allocations necessary during format...",1,<empty>,,45,2,CPPASTProblemDeclaration,,<empty>
65732,UNKNOWN,-1,,"class LOG4CXX_EXPORT PatternParser
{
		/**
		 * Escape character for format specifier.
		 */
		static const logchar ESCAPE_CHAR;

		enum
		{
			LITERAL_STATE = 0,
			CONVERTER_STATE = 1,
			DOT_STATE = 3,
			MIN_STATE = 4,
			MAX_STATE = 5
		};

		/**
		 * Private constructor.
		 */
		PatternParser();

	private:
		/** Extract the converter identifier found at position i.
		 *
		 * After this function returns, the variable i will point to the
		 * first char after the end of the converter identifier.
		 *
		 * If i points to a char which is not a character acceptable at the
		 * start of a unicode identifier, the value null is returned.
		 *
		 * @param lastChar last processed character.
		 * @param pattern format string.
		 * @param i current index into pattern format.
		 * @param convBuf buffer to receive conversion specifier.
		 * @param currentLiteral literal to be output in case format specifier in unrecognized.
		 * @return position in pattern after converter.
		 */
		static si...",1,<empty>,,50,3,CPPASTProblemDeclaration,,<empty>
65742,UNKNOWN,-1,,"class LOG4CXX_EXPORT PropertiesPatternConverter
	: public LoggingEventPatternConverter
{
		struct PropertiesPatternConverterPrivate;

	public:
		DECLARE_LOG4CXX_PATTERN(PropertiesPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(PropertiesPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		/**
		 * A Property bundle converter.
		 *
		 * @param name of the converter.
		 * @param option may be null.
		 */
		PropertiesPatternConverter(const LogString& name, const LogString& option);

		/**
		 * Obtains an instance of PropertiesPatternConverter.
		 * @param options options, may be null or first element contains name of property to format.
		 * @return instance of PropertiesPatternConverter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		using LoggingEventPatternConverter::format;

		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			LOG4CXX_NS::helpe...",1,<empty>,,39,1,CPPASTProblemDeclaration,,<empty>
65752,UNKNOWN,-1,,"class LOG4CXX_EXPORT RelativeTimePatternConverter : public LoggingEventPatternConverter
{
	public:
		DECLARE_LOG4CXX_PATTERN(RelativeTimePatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(RelativeTimePatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		/**
		 * Private constructor.
		 */
		RelativeTimePatternConverter();

		/**
		 * Obtains an instance of RelativeTimePatternConverter.
		 * @param options options, currently ignored, may be null.
		 * @return instance of RelativeTimePatternConverter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		using LoggingEventPatternConverter::format;


		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			LOG4CXX_NS::helpers::Pool& p) const override;
};",1,<empty>,,35,1,CPPASTProblemDeclaration,,<empty>
65762,UNKNOWN,-1,,"class LOG4CXX_EXPORT ShortFileLocationPatternConverter
	: public LoggingEventPatternConverter
{
		/**
		 * Private constructor.
		 */
		ShortFileLocationPatternConverter();

	public:
		DECLARE_LOG4CXX_PATTERN(ShortFileLocationPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(ShortFileLocationPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		/**
		 * Obtains an instance of pattern converter.
		 * @param options options, may be null.
		 * @return instance of pattern converter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		using LoggingEventPatternConverter::format;

		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			helpers::Pool& p) const override;
};",1,<empty>,,35,1,CPPASTProblemDeclaration,,<empty>
65772,UNKNOWN,-1,,"class LOG4CXX_EXPORT ThreadPatternConverter : public LoggingEventPatternConverter
{
	public:
		DECLARE_LOG4CXX_PATTERN(ThreadPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(ThreadPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		ThreadPatternConverter();

		/**
		 * Obtains an instance of ThreadPatternConverter.
		 * @param options options, currently ignored, may be null.
		 * @return instance of ThreadPatternConverter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		using LoggingEventPatternConverter::format;

		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			helpers::Pool& p) const override;
};",1,<empty>,,35,1,CPPASTProblemDeclaration,,<empty>
65784,UNKNOWN,-1,,"class LOG4CXX_EXPORT ThreadUsernamePatternConverter : public LoggingEventPatternConverter
{

    public:
	    DECLARE_LOG4CXX_PATTERN(ThreadUsernamePatternConverter)
	    BEGIN_LOG4CXX_CAST_MAP()
	    LOG4CXX_CAST_ENTRY(ThreadUsernamePatternConverter)
	    LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
	    END_LOG4CXX_CAST_MAP()

		ThreadUsernamePatternConverter();

	    static PatternConverterPtr newInstance(
	            const std::vector<LogString>& options);

	    void format(const spi::LoggingEventPtr& event,
	            LogString& toAppendTo,
	            LOG4CXX_NS::helpers::Pool& p) const override;
};",1,<empty>,,30,1,CPPASTProblemDeclaration,,<empty>
65794,UNKNOWN,-1,,"class LOG4CXX_EXPORT ThrowableInformationPatternConverter
	: public LoggingEventPatternConverter
{
		struct ThrowableInformationPatternConverterPrivate;

	public:
		DECLARE_LOG4CXX_PATTERN(ThrowableInformationPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(ThrowableInformationPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		ThrowableInformationPatternConverter(bool shortReport);

		/**
		 * Gets an instance of the class.
		  * @param options pattern options, may be null.  If first element is ""short"",
		 * only the first line of the throwable will be formatted.
		 * @return instance of class.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		using LoggingEventPatternConverter::format;

		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			helpers::Pool& p) const override;

		/**
		 * This converter obviously handles throwables.
		 * @return true....",1,<empty>,,37,1,CPPASTProblemDeclaration,,<empty>
65809,UNKNOWN,-1,,"LOG4CXX_LIST_DEF(LoggingEventPatternConverterList, LOG4CXX_NS::pattern::LoggingEventPatternConverterPtr);",1,<empty>,,28,1,CPPASTProblemDeclaration,,<empty>
65810,UNKNOWN,-1,,"LOG4CXX_LIST_DEF(FormattingInfoList, LOG4CXX_NS::pattern::FormattingInfoPtr);",1,<empty>,,29,2,CPPASTProblemDeclaration,,<empty>
65811,UNKNOWN,-1,,"class LOG4CXX_EXPORT PatternLayout : public Layout
{
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(PatternLayoutPrivate, m_priv)

	public:
		DECLARE_LOG4CXX_OBJECT(PatternLayout)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(PatternLayout)
		LOG4CXX_CAST_ENTRY_CHAIN(Layout)
		END_LOG4CXX_CAST_MAP()

		/**
		 * Does nothing
		 */
		PatternLayout();

		/**
		 * Constructs a PatternLayout using the supplied conversion pattern.
		 */
		PatternLayout(const LogString& pattern);

		~PatternLayout();

		/**
		 * Use \c conversionPattern as to control formatting.
		 *
		 * The pattern can be a mix of literal content and
		 * conversion specifiers.
		 */
		void setConversionPattern(const LogString& conversionPattern);

		/**
		 * Returns the value of the <strong>ConversionPattern</strong> option.
		 */
		LogString getConversionPattern() const;

		/**
		\copybrief spi::OptionHandler::activateOptions()

		Calls createPatternParser
		 */
		void activateOptions(helpers::Pool& p) override;

		/**
		\copy...",1,<empty>,,446,3,CPPASTProblemDeclaration,,<empty>
65939,UNKNOWN,-1,,"class LOG4CXX_EXPORT APRServerSocket : public helpers::ServerSocket
{
        public:
            APRServerSocket(int port);

	    void close() override;

	    SocketPtr accept() override;

	private:
		struct APRServerSocketPriv;
};",1,<empty>,,31,1,CPPASTProblemDeclaration,,<empty>
65950,UNKNOWN,-1,,"class LOG4CXX_EXPORT APRSocket : public helpers::Socket
{
	public:
		/** Creates a stream socket and connects it to the specified port
		number at the specified IP address.
		*/
		APRSocket(InetAddressPtr& address, int port);
		APRSocket(apr_socket_t*, apr_pool_t* pool);

		virtual size_t write(ByteBuffer&);

		/** Closes this socket. */
		virtual void close();

	private:
		struct APRSocketPriv;
};",1,<empty>,,30,1,CPPASTProblemDeclaration,,<empty>
65962,UNKNOWN,-1,,"class LOG4CXX_EXPORT AtExitRegistry
{
public:
	struct Raii
	{
		Raii(std::function<void()> action)
		{
			AtExitRegistry::instance().add(this, std::move(action));
		}
		
		~Raii()
		{
			AtExitRegistry::instance().del(this);
		}
		
		Raii(const Raii&) = delete;
		void operator=(const Raii&) = delete;
	};
	
private:
	friend Raii;
	static AtExitRegistry& instance();
	void add(void* key, std::function<void()> action);
	void del(void* key);
};",1,<empty>,,36,1,CPPASTProblemDeclaration,,<empty>
66475,UNKNOWN,-1,,"class LOG4CXX_EXPORT PropertyConfigurator :
	virtual public spi::Configurator,
	virtual public helpers::Object
{
	protected:

		/**
		Used internally to keep track of configured appenders.
		*/
		std::map<LogString, AppenderPtr>* registry;

		/**
		Used to create new instances of logger
		*/
		LOG4CXX_DECLARE_PRIVATE_MEMBER(spi::LoggerFactoryPtr, loggerFactory)

	public:
		DECLARE_LOG4CXX_OBJECT(PropertyConfigurator)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(spi::Configurator)
		END_LOG4CXX_CAST_MAP()

		PropertyConfigurator();
		virtual ~PropertyConfigurator();
		/**
		Read configuration from a file. <b>The existing configuration is
		not cleared nor reset.</b> If you require a different behavior,
		then call {@link LogManager#resetConfiguration
		resetConfiguration} method before calling
		<code>doConfigure</code>.

		<p>The configuration file consists of statements in the format
		<code>key=value</code>. The syntax of different configuration
		elements are discussed below.
...",1,<empty>,,85,8,CPPASTProblemDeclaration,,<empty>
66508,UNKNOWN,-1,,),41,<empty>,,37,2,CPPASTProblemDeclaration,,<empty>
66509,UNKNOWN,-1,,"BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(Action)
		END_LOG4CXX_CAST_MAP()

		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(ActionPrivate, m_priv)

	protected:
		/**
		 * Constructor.
		 */
		Action();",3,<empty>,,38,3,CPPASTProblemDeclaration,,<empty>
66510,UNKNOWN,-1,,Action(LOG4CXX_PRIVATE_PTR(ActionPrivate) priv);,3,<empty>,,49,4,CPPASTProblemDeclaration,,<empty>
66553,UNKNOWN,-1,,),51,<empty>,,34,3,CPPASTProblemDeclaration,,<empty>
66554,UNKNOWN,-1,,"BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(FileRenameAction)
		LOG4CXX_CAST_ENTRY_CHAIN(Action)
		END_LOG4CXX_CAST_MAP()

		/**
		 * Constructor.
		 */
		FileRenameAction(const File& toRename,
			const File& renameTo,
			bool renameEmptyFile);",3,<empty>,,35,4,CPPASTProblemDeclaration,,<empty>
66576,UNKNOWN,-1,,"class LOG4CXX_EXPORT FilterBasedTriggeringPolicy : public TriggeringPolicy
{

		DECLARE_LOG4CXX_OBJECT(FilterBasedTriggeringPolicy)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(FilterBasedTriggeringPolicy)
		LOG4CXX_CAST_ENTRY_CHAIN(TriggeringPolicy)
		END_LOG4CXX_CAST_MAP()

		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(FilterBasedTriggeringPolicyPrivate, m_priv)

	public:
		/**
		 *  Creates a new FilterBasedTriggeringPolicy.
		 */
		FilterBasedTriggeringPolicy();
		virtual ~FilterBasedTriggeringPolicy();

		/**
		 * Determines if a rollover may be appropriate at this time.  If
		 * true is returned, RolloverPolicy.rollover will be called but it
		 * can determine that a rollover is not warranted.
		 *
		 * @param appender A reference to the appender.
		 * @param event A reference to the currently event.
		 * @param filename The filename for the currently active log file.
		 * @param fileLength Length of the file in bytes.
		 * @return true if a rollover should occur.
		 */
		bool isTri...",1,<empty>,,50,1,CPPASTProblemDeclaration,,<empty>
66589,UNKNOWN,-1,,"class LOG4CXX_EXPORT FixedWindowRollingPolicy : public RollingPolicyBase
{
		DECLARE_LOG4CXX_OBJECT(FixedWindowRollingPolicy)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(FixedWindowRollingPolicy)
		LOG4CXX_CAST_ENTRY_CHAIN(RollingPolicyBase)
		END_LOG4CXX_CAST_MAP()

		struct FixedWindowRollingPolicyPrivate;

		/**
		 * It's almost always a bad idea to have a large window size, say over 12.
		 */
		enum { MAX_WINDOW_SIZE = 12 };

		bool purge(int purgeStart, int maxIndex, LOG4CXX_NS::helpers::Pool& p) const;

	public:

		FixedWindowRollingPolicy();
		~FixedWindowRollingPolicy();

		/**
		\copybrief RollingPolicyBase::activateOptions()

		Logs a warning if an option is not valid.

		\sa RollingPolicyBase::activateOptions()
		*/
		void activateOptions(helpers::Pool& p) override;

		/**
		\copybrief RollingPolicyBase::setOption()

		Supported options | Supported values | Default value
		:-------------- | :----------------: | :---------------:
		MinIndex | 1-12 | 1
		MaxIndex | 1-12...",1,<empty>,,71,1,CPPASTProblemDeclaration,,<empty>
66605,UNKNOWN,-1,,),51,<empty>,,34,3,CPPASTProblemDeclaration,,<empty>
66606,UNKNOWN,-1,,"BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(GZCompressAction)
		LOG4CXX_CAST_ENTRY_CHAIN(Action)
		END_LOG4CXX_CAST_MAP()

		/**
		 * Constructor.
		 */
		GZCompressAction(const File& source,
			const File& destination,
			bool deleteSource);",3,<empty>,,35,4,CPPASTProblemDeclaration,,<empty>
66644,UNKNOWN,-1,,"class LOG4CXX_EXPORT ManualTriggeringPolicy : public TriggeringPolicy
{
		DECLARE_LOG4CXX_OBJECT(ManualTriggeringPolicy)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(ManualTriggeringPolicy)
		LOG4CXX_CAST_ENTRY_CHAIN(TriggeringPolicy)
		END_LOG4CXX_CAST_MAP()

	public:
		ManualTriggeringPolicy();
		/**
		 * Determines if a rollover may be appropriate at this time.  If
		 * true is returned, RolloverPolicy.rollover will be called but it
		 * can determine that a rollover is not warranted.
		 *
		 * @param appender A reference to the appender.
		 * @param event A reference to the currently event.
		 * @param filename The filename for the currently active log file.
		 * @param fileLength Length of the file in bytes.
		 * @return true if a rollover should occur.
		 */
		bool isTriggeringEvent(
			Appender* appender,
			const spi::LoggingEventPtr& event,
			const LogString& filename,
			size_t fileLength) override;

		/**
		\copybrief spi::OptionHandler::activateOptions()

		No action...",1,<empty>,,43,1,CPPASTProblemDeclaration,,<empty>
66664,UNKNOWN,-1,,"class LOG4CXX_EXPORT MultiprocessRollingFileAppender : public FileAppender
{
		DECLARE_LOG4CXX_OBJECT(MultiprocessRollingFileAppender)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(MultiprocessRollingFileAppender)
		LOG4CXX_CAST_ENTRY_CHAIN(FileAppender)
		END_LOG4CXX_CAST_MAP()
	protected:
		struct MultiprocessRollingFileAppenderPriv;

	public:
		MultiprocessRollingFileAppender();

		/**
		\copybrief FileAppender::activateOptions()

		Activate the attached TriggeringPolicy and RollingPolicy.

		\sa FileAppender::activateOptions()
		*/
		void activateOptions(helpers::Pool&) override;


		/**
		   Implements the usual roll over behaviour.

		   <p>If <code>MaxBackupIndex</code> is positive, then files
		   {<code>File.1</code>, ..., <code>File.MaxBackupIndex -1</code>}
		   are renamed to {<code>File.2</code>, ...,
		   <code>File.MaxBackupIndex</code>}. Moreover, <code>File</code> is
		   renamed <code>File.1</code> and closed. A new <code>File</code> is
		   created to receive fu...",1,<empty>,,37,1,CPPASTProblemDeclaration,,<empty>
66685,UNKNOWN,-1,,"class LOG4CXX_EXPORT RollingFileAppender : public FileAppender
{
		DECLARE_LOG4CXX_OBJECT(RollingFileAppender)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(RollingFileAppender)
		LOG4CXX_CAST_ENTRY_CHAIN(FileAppender)
		END_LOG4CXX_CAST_MAP()
	protected:
		struct RollingFileAppenderPriv;

	public:
		RollingFileAppender();

		/** Returns the value of the <b>MaxBackupIndex</b> option. */
		int getMaxBackupIndex() const;

		/** Get the maximum size that the output file is allowed to reach before being rolled over to backup files. */
		size_t getMaximumFileSize() const;


		/**
		Set the maximum number of backup files to keep around.

		<p>The <b>MaxBackupIndex</b> option determines how many backup
		 files are kept before the oldest is erased. This option takes
		 a positive integer value. If set to zero, then there will be no
		 backup files and the log file will be truncated when it reaches <code>MaxFileSize</code>.
		*/
		void setMaxBackupIndex( int maxBackupIndex );

		/**
		Set...",1,<empty>,,79,1,CPPASTProblemDeclaration,,<empty>
66700,UNKNOWN,-1,,"class LOG4CXX_EXPORT RollingPolicy :
	public virtual spi::OptionHandler
{
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(RollingPolicy)

	public:
		virtual ~RollingPolicy() {}

		/**
		 * Initialize the policy and return any initial actions for rolling file appender.
		 *
		 * @param currentActiveFile current value of RollingFileAppender.getFile().
		 * @param append current value of RollingFileAppender.getAppend().
		 * @param pool pool for memory allocations during call.
		 * @return Description of the initialization, may be null to indicate
		 * no initialization needed.
		 * @throws SecurityException if denied access to log files.
		 */
		virtual RolloverDescriptionPtr initialize(
			const   LogString&              currentActiveFile,
			const   bool                    append,
			LOG4CXX_NS::helpers::Pool& pool) = 0;

		/**
		 * Prepare for a rollover.  This method is called prior to
		 * closing the active log file, performs any necessary
		 * preliminary actions and describes actions needed...",1,<empty>,,41,1,CPPASTProblemDeclaration,,<empty>
66723,UNKNOWN,-1,,"LOG4CXX_LIST_DEF(PatternConverterList, LOG4CXX_NS::pattern::PatternConverterPtr);",1,<empty>,,33,1,CPPASTProblemDeclaration,,<empty>
66724,UNKNOWN,-1,,"LOG4CXX_LIST_DEF(FormattingInfoList, LOG4CXX_NS::pattern::FormattingInfoPtr);",1,<empty>,,34,2,CPPASTProblemDeclaration,,<empty>
66725,UNKNOWN,-1,,"class LOG4CXX_EXPORT RollingPolicyBase :
	public virtual RollingPolicy,
	public virtual helpers::Object
{
	protected:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(RollingPolicyBase)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(RollingPolicy)
		LOG4CXX_CAST_ENTRY(spi::OptionHandler)
		END_LOG4CXX_CAST_MAP()

		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(RollingPolicyBasePrivate, m_priv)

	public:
		RollingPolicyBase();
		virtual ~RollingPolicyBase();

		/**
		\copybrief RollingPolicy::activateOptions()

		Logs a warning if FileNamePattern is not set.

		\sa RollingPolicy::activateOptions()
		*/
		void activateOptions(helpers::Pool& p) override;

		/**
		A map from a name to the object implementing the (date or index) formatting.
		*/
		virtual pattern::PatternMap getFormatSpecifiers() const = 0;


		/**
		\copybrief spi::OptionHandler::setOption()

		Supported options | Supported values | Default value
		:-------------- | :----------------: | :---------------:
		FileNamePattern | (\ref legalChars ""^""...",1,<empty>,,43,3,CPPASTProblemDeclaration,,<empty>
66738,UNKNOWN,-1,,),45,<empty>,,31,2,CPPASTProblemDeclaration,,<empty>
66739,UNKNOWN,-1,,"BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(RolloverDescription)
		END_LOG4CXX_CAST_MAP()

		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(RolloverDescriptionPrivate, m_priv)

	public:
		RolloverDescription();",3,<empty>,,32,3,CPPASTProblemDeclaration,,<empty>
66781,UNKNOWN,-1,,"class LOG4CXX_EXPORT SizeBasedTriggeringPolicy : public TriggeringPolicy
{
		DECLARE_LOG4CXX_OBJECT(SizeBasedTriggeringPolicy)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(SizeBasedTriggeringPolicy)
		LOG4CXX_CAST_ENTRY_CHAIN(TriggeringPolicy)
		END_LOG4CXX_CAST_MAP()

	protected:
		size_t maxFileSize;

	public:
		SizeBasedTriggeringPolicy();
		/**
		 * Determines if a rollover may be appropriate at this time.  If
		 * true is returned, RolloverPolicy.rollover will be called but it
		 * can determine that a rollover is not warranted.
		 *
		 * @param appender A reference to the appender.
		 * @param event A reference to the currently event.
		 * @param filename The filename for the currently active log file.
		 * @param fileLength Length of the file in bytes.
		 * @return true if a rollover should occur.
		 */
		bool isTriggeringEvent(
			Appender* appender,
			const spi::LoggingEventPtr& event,
			const LogString& filename,
			size_t fileLength) override;

		size_t getMaxFileSiz...",1,<empty>,,43,1,CPPASTProblemDeclaration,,<empty>
66800,UNKNOWN,-1,,"class LOG4CXX_EXPORT TimeBasedRollingPolicy : public virtual RollingPolicyBase,
	public virtual TriggeringPolicy
{
		DECLARE_LOG4CXX_OBJECT(TimeBasedRollingPolicy)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(TimeBasedRollingPolicy)
		LOG4CXX_CAST_ENTRY_CHAIN(RollingPolicyBase)
		LOG4CXX_CAST_ENTRY_CHAIN(TriggeringPolicy)
		END_LOG4CXX_CAST_MAP()

	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(TimeBasedRollingPolicyPrivate, m_priv)

	public:
		TimeBasedRollingPolicy();
		virtual ~TimeBasedRollingPolicy();

		/**
		\copybrief RollingPolicyBase::activateOptions()

		Logs a warning if an option is not valid.

		\sa RollingPolicyBase::activateOptions()
		*/
		void activateOptions(helpers::Pool& ) override;

		void setMultiprocess(bool multiprocess);

		/**
		 * {@inheritDoc}
		 */
		RolloverDescriptionPtr initialize(
			const   LogString&              currentActiveFile,
			const   bool                    append,
			helpers::Pool& pool) override;

		/**
		 * {@inheritDoc}
		 */
		Roll...",1,<empty>,,140,1,CPPASTProblemDeclaration,,<empty>
66818,UNKNOWN,-1,,"class LOG4CXX_EXPORT TriggeringPolicy :
	public virtual spi::OptionHandler,
	public virtual helpers::Object
{
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(TriggeringPolicy)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(TriggeringPolicy)
		LOG4CXX_CAST_ENTRY(spi::OptionHandler)
		END_LOG4CXX_CAST_MAP()
	public:
		virtual ~TriggeringPolicy();

		/**
		 * Determines if a rollover may be appropriate at this time.  If
		 * true is returned, RolloverPolicy.rollover will be called but it
		 * can determine that a rollover is not warranted.
		 *
		 * @param appender A reference to the appender.
		 * @param event A reference to the currently event.
		 * @param filename The filename for the currently active log file.
		 * @param fileLength Length of the file in bytes.
		 * @return true if a rollover should occur.
		 */
		virtual bool isTriggeringEvent(
			Appender* appender,
			const spi::LoggingEventPtr& event,
			const LogString& filename,
			size_t fileLength) = 0;

};",1,<empty>,,44,1,CPPASTProblemDeclaration,,<empty>
66834,UNKNOWN,-1,,),52,<empty>,,34,3,CPPASTProblemDeclaration,,<empty>
66835,UNKNOWN,-1,,"BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(ZipCompressAction)
		LOG4CXX_CAST_ENTRY_CHAIN(Action)
		END_LOG4CXX_CAST_MAP()

		/**
		 * Constructor.
		 */
		ZipCompressAction(const File& source,
			const File& destination,
			bool deleteSource);",3,<empty>,,35,4,CPPASTProblemDeclaration,,<empty>
66865,UNKNOWN,-1,,"class LOG4CXX_EXPORT SimpleLayout : public Layout
{
	public:
		DECLARE_LOG4CXX_OBJECT(SimpleLayout)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(SimpleLayout)
		LOG4CXX_CAST_ENTRY_CHAIN(Layout)
		END_LOG4CXX_CAST_MAP()

		/**
		Returns the log statement in a format consisting of the
		<code>level</code>, followed by "" - "" and then the
		<code>message</code>. For example, <pre> INFO - ""A message""
		</pre>
		*/
		void format(LogString& output,
			const spi::LoggingEventPtr& event,
			helpers::Pool& pool) const override;

		/**
		The SimpleLayout does not handle the throwable contained within
		{@link spi::LoggingEvent LoggingEvents}. Thus, it returns
		<code>true</code>.
		*/
		bool ignoresThrowable() const override
		{
			return true;
		}

		/**
		\copybrief spi::OptionHandler::activateOptions()

		No action is performed in this implementation.
		*/
		void activateOptions(helpers::Pool& /* p */) override {}

		/**
		\copybrief spi::OptionHandler::setOption()

		Supported options |...",1,<empty>,,37,1,CPPASTProblemDeclaration,,<empty>
66882,UNKNOWN,-1,,"class LOG4CXX_EXPORT AppenderAttachable : public virtual helpers::Object
{
	public:
		// Methods
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(AppenderAttachable)

		/**
		 * Add an appender.
		 */
		virtual void addAppender(const AppenderPtr newAppender) = 0;

		/**
		 * Get all previously added appenders as an AppenderList.
		 */
		virtual AppenderList getAllAppenders() const = 0;

		/**
		 * Get an appender by name.
		 */
		virtual AppenderPtr getAppender(const LogString& name) const = 0;

		/**
		 * Returns <code>true</code> if the specified appender is in list of
		 * attached appenders, <code>false</code> otherwise.
		 */
		virtual bool isAttached(const AppenderPtr appender) const = 0;

		/**
		 * Remove all previously added appenders.
		 */
		virtual void removeAllAppenders() = 0;

		/**
		 * Remove the appender passed as parameter from the list of appenders.
		 */
		virtual void removeAppender(const AppenderPtr appender) = 0;

		/**
		 * Remove the appender with the name passed as param...",1,<empty>,,33,1,CPPASTProblemDeclaration,,<empty>
66897,UNKNOWN,-1,,"class LOG4CXX_EXPORT Configurator : virtual public helpers::Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(Configurator)

		/**
		Interpret a resource pointed by a URL and set up log4j accordingly.

		The configuration is done relative to the <code>hierarchy</code>
		parameter.

		@param configFileName The file to parse
		@param repository The hierarchy to operation upon.
		*/
		virtual ConfigurationStatus doConfigure(const File& configFileName,
			spi::LoggerRepositoryPtr repository) = 0;

	protected:
		Configurator();

	private:
		Configurator(const Configurator&);
		Configurator& operator=(const Configurator&);
};",1,<empty>,,38,2,CPPASTProblemDeclaration,,<empty>
66914,UNKNOWN,-1,,"class LOG4CXX_EXPORT DefaultRepositorySelector :
	public virtual RepositorySelector,
	public virtual helpers::Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(DefaultRepositorySelector)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(RepositorySelector)
		END_LOG4CXX_CAST_MAP()

		DefaultRepositorySelector(const LoggerRepositoryPtr repository1);
		~DefaultRepositorySelector();
		LoggerRepositoryPtr getLoggerRepository() override;

	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(DefaultRepositorySelectorPrivate, m_priv)
};",1,<empty>,,30,1,CPPASTProblemDeclaration,,<empty>
66964,UNKNOWN,-1,,"class LOG4CXX_EXPORT ErrorHandler : public virtual OptionHandler
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(ErrorHandler)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(ErrorHandler)
		LOG4CXX_CAST_ENTRY(OptionHandler)
		END_LOG4CXX_CAST_MAP()

		virtual ~ErrorHandler() {}

		/**
		Add a reference to a logger to which the failing appender might
		be attached to. The failing appender will be searched and
		replaced only in the loggers you add through this method.

		@param logger One of the loggers that will be searched for the failing
		appender in view of replacement.
		*/
		virtual void setLogger(const LoggerPtr& logger) = 0;


		/**
		Equivalent to the error(const String&, helpers::Exception&, int,
		spi::LoggingEvent&) with the the event parameteter set to
		null.
		*/
		virtual void error(const LogString& message, const std::exception& e,
			int errorCode) const = 0;

		/**
		This method is normally used to just print the error message
		passed as a parameter.
		*/
		virtual...",1,<empty>,,58,2,CPPASTProblemDeclaration,,<empty>
66981,UNKNOWN,-1,,"class LOG4CXX_EXPORT Filter : public virtual OptionHandler
{
	protected:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(FilterPrivate, m_priv)

	public:
		Filter();
		Filter(std::unique_ptr<FilterPrivate> priv);
		virtual ~Filter();

		DECLARE_ABSTRACT_LOG4CXX_OBJECT(Filter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(Filter)
		LOG4CXX_CAST_ENTRY(spi::OptionHandler)
		END_LOG4CXX_CAST_MAP()

		LOG4CXX_NS::spi::FilterPtr getNext() const;
		void setNext(const LOG4CXX_NS::spi::FilterPtr& newNext);

		enum FilterDecision
		{
			/**
			The log event must be dropped immediately without consulting
			            with the remaining filters, if any, in the chain.  */
			DENY = -1,
			/**
			This filter is neutral with respect to the log event. The
			remaining filters, if any, should be consulted for a final decision.
			*/
			NEUTRAL = 0,
			/**
			The log event must be logged immediately without consulting with
			the remaining filters, if any, in the chain.
			            */
			ACCEPT = 1

		};...",1,<empty>,,67,3,CPPASTProblemDeclaration,,<empty>
66995,UNKNOWN,-1,,"class LOG4CXX_EXPORT HierarchyEventListener :
	public virtual LOG4CXX_NS::helpers::Object
{
	public:
		virtual ~HierarchyEventListener() {}

		virtual void addAppenderEvent(
			const Logger* logger,
			const Appender* appender) = 0;

		virtual void removeAppenderEvent(
			const Logger* logger,
			const Appender* appender) = 0;
};",1,<empty>,,34,1,CPPASTProblemDeclaration,,<empty>
66997,UNKNOWN,-1,,"LOG4CXX_LIST_DEF(HierarchyEventListenerList, HierarchyEventListenerPtr);",1,<empty>,,49,3,CPPASTProblemDeclaration,,<empty>
67013,UNKNOWN,-1,,"class LOG4CXX_EXPORT LocationInfo
{
	public:



		/**
		  *   When location information is not available the constant
		  * <code>NA</code> is returned. Current value of this string constant is <b>?</b>.
		  */
		static const char* const NA;
		static const char* const NA_METHOD;

		static const LocationInfo& getLocationUnavailable();

#ifdef LOG4CXX_HAS_STRING_VIEW
		static constexpr const char* calcShortFileName(const char* fileName){
			std::string_view view(fileName);
			// If the separator is not found, rfind will return -1.  Adding 1 to
			// that will have it pointing at fileName, which is a good fallback.
			return fileName + view.rfind(LOG4CXX_SHORT_FILENAME_SPLIT_CHAR) + 1;
		}
#else
		static const char* calcShortFileName(const char* fileName){
			const char* location = strrchr(fileName, LOG4CXX_SHORT_FILENAME_SPLIT_CHAR);
			return location == nullptr ? fileName : location + 1;
		}
#endif

		/**
		 *   Constructor.
		 *   @remarks Used by LOG4CXX_LOCATION to generate
		 * ...",1,<empty>,,45,1,CPPASTProblemDeclaration,,<empty>
67023,UNKNOWN,-1,,"class LOG4CXX_EXPORT LoggerFactory : public virtual helpers::Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(LoggerFactory)
		virtual ~LoggerFactory() {}
		virtual LoggerPtr makeNewLoggerInstance(helpers::Pool& pool, const LogString& name) const = 0;
};",1,<empty>,,32,1,CPPASTProblemDeclaration,,<empty>
67041,UNKNOWN,-1,,"class LOG4CXX_EXPORT LoggerRepository : public virtual helpers::Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(LoggerRepository)
		virtual ~LoggerRepository() {}

		/**
		Add a {@link spi::HierarchyEventListener HierarchyEventListener}
		        event to the repository.
		*/
		virtual void addHierarchyEventListener(const HierarchyEventListenerPtr&
			listener) = 0;

#if 15 < LOG4CXX_ABI_VERSION
		/**
		 * Remove a previously added HierarchyEventListener from the repository.
		 *
		 */
		virtual void removeHierarchyEventListener(const spi::HierarchyEventListenerPtr& listener) = 0;
#endif

		/**
		 * Call \c configurator if not yet configured.
		 */
		virtual void ensureIsConfigured(std::function<void()> configurator) = 0;

		/**
		Is the repository disabled for a given level? The answer depends
		on the repository threshold and the <code>level</code>
		parameter. See also #setThreshold method.  */
		virtual bool isDisabled(int level) const = 0;

		/**
		Set the repository-wide t...",1,<empty>,,42,1,CPPASTProblemDeclaration,,<empty>
67065,UNKNOWN,-1,,"LOG4CXX_LIST_DEF(KeySet, LogString);",1,<empty>,,39,1,CPPASTProblemDeclaration,,<empty>
67066,UNKNOWN,-1,,"class LOG4CXX_EXPORT LoggingEvent :
	public virtual helpers::Object
{
	public:
		DECLARE_LOG4CXX_OBJECT(LoggingEvent)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(LoggingEvent)
		END_LOG4CXX_CAST_MAP()

		typedef spi::KeySet KeySet;

		/** For serialization only
		*/
		LoggingEvent();

		/**
		Instantiate a LoggingEvent from the supplied parameters.

		<p>Except timeStamp all the other fields of
		<code>LoggingEvent</code> are filled when actually needed.
		<p>
		@param logger The logger of this event.
		@param level The level of this event.
		@param location The source code location of the logging request.
		@param message  The text to add to this event.
		*/
		LoggingEvent
			( const LogString& logger
			, const LevelPtr& level
			, const spi::LocationInfo& location
			, LogString&& message
			);

		/**
		Instantiate a LoggingEvent from the supplied parameters.

		<p>Except timeStamp all the other fields of
		<code>LoggingEvent</code> are filled when actually needed.
		<p>
		@p...",1,<empty>,,49,2,CPPASTProblemDeclaration,,<empty>
67068,UNKNOWN,-1,,"LOG4CXX_LIST_DEF(LoggingEventList, LoggingEventPtr);",1,<empty>,,212,4,CPPASTProblemDeclaration,,<empty>
67082,UNKNOWN,-1,,"class LOG4CXX_EXPORT OptionHandler : public virtual helpers::Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(OptionHandler)
		virtual ~OptionHandler() {}

		/**
		Activate the options that were previously set with calls to option
		setters.

		<p>This allows to defer activiation of the options until all
		options have been set. This is required for components which have
		related options that remain ambigous until all are set.

		<p>For example, the FileAppender has
		the <code>File</code> and <b>Append</b> options both of
		which are ambigous until the other is also set.
		*/
		virtual void activateOptions(helpers::Pool& p) = 0;


		/**
		Set <code>option</code> to <code>value</code>.

		<p>The handling of each option depends on the OptionHandler
		instance. Some options may become active immediately whereas
		other may be activated only when #activateOptions is
		called.
		*/
		virtual void setOption(const LogString& option,
			const LogString& value) = 0;

};",1,<empty>,,34,3,CPPASTProblemDeclaration,,<empty>
67094,UNKNOWN,-1,,"class LOG4CXX_EXPORT RepositorySelector : public virtual helpers::Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(RepositorySelector)
		virtual ~RepositorySelector() {}
		virtual LoggerRepositoryPtr getLoggerRepository() = 0;
};",1,<empty>,,42,3,CPPASTProblemDeclaration,,<empty>
67105,UNKNOWN,-1,,"class LOG4CXX_EXPORT RootLogger : public Logger
{
	public:
		/**
		The root logger names itself as ""root"". However, the root
		logger cannot be retrieved by name.
		*/
		RootLogger(LOG4CXX_NS::helpers::Pool& pool, const LevelPtr level);

		~RootLogger() {}

		/**
		Return the assigned level value without walking the logger
		hierarchy.
		*/
		virtual const LevelPtr& getEffectiveLevel() const;

		/**
		            Setting a null value to the level of the root logger may have catastrophic
		            results. We prevent this here.
		            */
		void setLevel(const LevelPtr level);
};",1,<empty>,,36,1,CPPASTProblemDeclaration,,<empty>
67115,UNKNOWN,-1,,"class LOG4CXX_EXPORT TriggeringEventEvaluator : public virtual helpers::Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(TriggeringEventEvaluator)
		/**
		Is this the triggering event?
		*/
		virtual bool isTriggeringEvent(const spi::LoggingEventPtr& event) = 0;
};",1,<empty>,,37,1,CPPASTProblemDeclaration,,<empty>
67129,UNKNOWN,-1,,"class LOG4CXX_EXPORT logstream_base
{
	public:
		/**
		 *  Create new instance.
		 *  @param logger logger logger used in log requests.
		 *  @param level indicates level that will be used in log requests.  Can
		 *      be modified later by inserting a level or calling setLevel.
		 */
		logstream_base(const LOG4CXX_NS::LoggerPtr& logger,
			const LOG4CXX_NS::LevelPtr& level);
		/**
		 *  Destructor.
		 */
		virtual ~logstream_base();
		/**
		 *  Insertion operator for std::fixed and similar manipulators.
		 */
		void insert(std::ios_base & (*manip)(std::ios_base&));

		/**
		 *   get precision.
		 */
		int precision();
		/**
		 *   get width.
		 */
		int width();
		/**
		 *   set precision.  This should be used in preference to inserting an std::setprecision(n)
		 *   since the other requires construction of an STL stream which may be expensive.
		 */
		int precision(int newval);
		/**
		 *   set width.  This should be used in preference to inserting an std::setw(n)
		 *   since th...",1,<empty>,,37,1,CPPASTProblemDeclaration,,<empty>
67135,UNKNOWN,-1,,"class LOG4CXX_EXPORT logstream : public logstream_base
{
		typedef char Ch;
	public:
		/**
		 *   Constructor.
		 */
		logstream(const LOG4CXX_NS::LoggerPtr& logger,
			const LOG4CXX_NS::LevelPtr& level);

		/**
		 *   Constructor.
		 */
		logstream(const Ch* loggerName,
			const LOG4CXX_NS::LevelPtr& level);

		/**
		 *   Constructor.
		 */
		logstream(const std::basic_string<Ch>& loggerName,
			const LOG4CXX_NS::LevelPtr& level);

		~logstream();

		/**
		 *   Insertion operator for std::fixed and similar manipulators.
		 */
		logstream& operator<<(std::ios_base & (*manip)(std::ios_base&));

		/**
		 *   Insertion operator for logstream_base::endmsg.
		 */
		logstream& operator<<(logstream_manipulator manip);

		/**
		 *   Insertion operator for level.
		 */
		logstream& operator<<(const LOG4CXX_NS::LevelPtr& level);
		/**
		 *   Insertion operator for location.
		 */
		logstream& operator<<(const LOG4CXX_NS::spi::LocationInfo& location);

		/**
		 *   Alias for insertion operator...",1,<empty>,,226,3,CPPASTProblemDeclaration,,<empty>
67153,UNKNOWN,-1,,"class LOG4CXX_EXPORT FallbackErrorHandler :
	public virtual spi::ErrorHandler
{
	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(FallbackErrorHandlerPrivate, m_priv)

	public:
		DECLARE_LOG4CXX_OBJECT(FallbackErrorHandler)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(FallbackErrorHandler)
		LOG4CXX_CAST_ENTRY_CHAIN(spi::ErrorHandler)
		END_LOG4CXX_CAST_MAP()

		FallbackErrorHandler();
		~FallbackErrorHandler();

		/**
		<em>Adds</em> the logger passed as parameter to the list of
		loggers that we need to search for in case of appender failure.
		*/
		void setLogger(const LoggerPtr& logger) override;


		/**
		\copybrief spi::OptionHandler::activateOptions()

		No action is performed in this implementation.
		*/
		void activateOptions(helpers::Pool& p) override;
		/**
		\copybrief spi::OptionHandler::setOption()
		 */
		void setOption(const LogString& option, const LogString& value) override;


		/**
		Prints the message and the stack trace of the exception on
		<code>System.err</co...",1,<empty>,,40,1,CPPASTProblemDeclaration,,<empty>
67169,UNKNOWN,-1,,"class LOG4CXX_EXPORT WriterAppender : public AppenderSkeleton
{
	protected:
		struct WriterAppenderPriv;
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(WriterAppender)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(WriterAppender)
		LOG4CXX_CAST_ENTRY_CHAIN(AppenderSkeleton)
		END_LOG4CXX_CAST_MAP()

		/**
		This default constructor does nothing.*/
		WriterAppender();
	protected:
		WriterAppender(const LayoutPtr& layout,
			LOG4CXX_NS::helpers::WriterPtr& writer);
		WriterAppender(const LayoutPtr& layout);
		WriterAppender(std::unique_ptr<WriterAppenderPriv> priv);

	public:
		~WriterAppender();

		/**
		Derived appenders should override this method if option structure
		requires it.
		*/
		void activateOptions(helpers::Pool& pool) override;

		/**
		If the <b>ImmediateFlush</b> option is set to
		<code>true</code>, the appender will flush at the end of each
		write. This is the default behavior. If the option is set to
		<code>false</code>, then the underlying stream can defer writing...",1,<empty>,,36,2,CPPASTProblemDeclaration,,<empty>
67211,UNKNOWN,-1,,"class LOG4CXX_EXPORT XMLLayout : public Layout
{
	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(XMLLayoutPrivate, m_priv)

	public:
		DECLARE_LOG4CXX_OBJECT(XMLLayout)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(XMLLayout)
		LOG4CXX_CAST_ENTRY_CHAIN(Layout)
		END_LOG4CXX_CAST_MAP()

		XMLLayout();
		~XMLLayout();

		/**
		The <b>LocationInfo</b> option takes a boolean value. By
		default, it is set to false which means there will be no location
		information output by this layout. If the the option is set to
		true, then the file name and line number of the statement
		at the origin of the log statement will be output.

		<p>If you are embedding this layout within a SMTPAppender
		then make sure to set the
		<b>LocationInfo</b> option of that appender as well.
		*/
		void setLocationInfo(bool locationInfo1);

		/**
		Returns the current value of the <b>LocationInfo</b> option.
		*/
		bool getLocationInfo() const;

		/**
		 * Sets whether MDC key-value pairs should be output, def...",1,<empty>,,53,1,CPPASTProblemDeclaration,,<empty>
67274,UNKNOWN,1,,UniChar*,19,<empty>,,43,1,CPPASTTypeId,,<empty>
67299,UNKNOWN,1,,UniChar*,19,<empty>,,50,1,CPPASTTypeId,,<empty>
67337,UNKNOWN,1,,UniChar*,21,<empty>,,59,1,CPPASTTypeId,,<empty>
67371,UNKNOWN,1,,CFStringRef,10,<empty>,,63,1,CPPASTTypeId,,<empty>
67384,UNKNOWN,1,,UniChar*,21,<empty>,,66,1,CPPASTTypeId,,<empty>
67409,UNKNOWN,1,,CFStringRef,10,<empty>,,69,1,CPPASTTypeId,,<empty>
