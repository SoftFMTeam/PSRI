2,NAMESPACE_BLOCK,<empty>,,<unknown>,<global>,,<global>,1
7,NAMESPACE_BLOCK,<empty>,,cmake\SQLAllocHandleTest.cpp,cmake\SQLAllocHandleTest.cpp:<global>,,<global>,1
41,NAMESPACE_BLOCK,<empty>,,cmake\boost-fallback\test-boostatomic.cpp,cmake\boost-fallback\test-boostatomic.cpp:<global>,,<global>,1
55,NAMESPACE_BLOCK,<empty>,,cmake\boost-fallback\test-boostfilesystem.cpp,cmake\boost-fallback\test-boostfilesystem.cpp:<global>,,<global>,1
69,NAMESPACE_BLOCK,<empty>,,cmake\boost-fallback\test-boostmutex.cpp,cmake\boost-fallback\test-boostmutex.cpp:<global>,,<global>,1
85,NAMESPACE_BLOCK,<empty>,,cmake\boost-fallback\test-boostsharedmutex.cpp,cmake\boost-fallback\test-boostsharedmutex.cpp:<global>,,<global>,1
101,NAMESPACE_BLOCK,<empty>,,cmake\boost-fallback\test-boostsharedptr.cpp,cmake\boost-fallback\test-boostsharedptr.cpp:<global>,,<global>,1
119,NAMESPACE_BLOCK,<empty>,,cmake\boost-fallback\test-boostthread.cpp,cmake\boost-fallback\test-boostthread.cpp:<global>,,<global>,1
135,NAMESPACE_BLOCK,<empty>,,cmake\boost-fallback\test-stdatomic.cpp,cmake\boost-fallback\test-stdatomic.cpp:<global>,,<global>,1
149,NAMESPACE_BLOCK,<empty>,,cmake\boost-fallback\test-stdexpfilesystem.cpp,cmake\boost-fallback\test-stdexpfilesystem.cpp:<global>,,<global>,1
163,NAMESPACE_BLOCK,<empty>,,cmake\boost-fallback\test-stdfilesystem.cpp,cmake\boost-fallback\test-stdfilesystem.cpp:<global>,,<global>,1
177,NAMESPACE_BLOCK,<empty>,,cmake\boost-fallback\test-stdmutex.cpp,cmake\boost-fallback\test-stdmutex.cpp:<global>,,<global>,1
193,NAMESPACE_BLOCK,<empty>,,cmake\boost-fallback\test-stdsharedmutex.cpp,cmake\boost-fallback\test-stdsharedmutex.cpp:<global>,,<global>,1
209,NAMESPACE_BLOCK,<empty>,,cmake\boost-fallback\test-stdsharedptr.cpp,cmake\boost-fallback\test-stdsharedptr.cpp:<global>,,<global>,1
227,NAMESPACE_BLOCK,<empty>,,cmake\boost-fallback\test-stdthread.cpp,cmake\boost-fallback\test-stdthread.cpp:<global>,,<global>,1
243,NAMESPACE_BLOCK,<empty>,,cmake\compiler-features\test-make-unique.cpp,cmake\compiler-features\test-make-unique.cpp:<global>,,<global>,1
263,NAMESPACE_BLOCK,<empty>,,cmake\compiler-features\test-thread-local.cpp,cmake\compiler-features\test-thread-local.cpp:<global>,,<global>,1
286,NAMESPACE_BLOCK,<empty>,,cmake\compiler-features\test-unicode.cpp,cmake\compiler-features\test-unicode.cpp:<global>,,<global>,1
307,NAMESPACE_BLOCK,<empty>,,cmake\pthread\test-pthread-getname.cpp,cmake\pthread\test-pthread-getname.cpp:<global>,,<global>,1
325,NAMESPACE_BLOCK,<empty>,,cmake\pthread\test-pthread-setname.cpp,cmake\pthread\test-pthread-setname.cpp:<global>,,<global>,1
344,NAMESPACE_BLOCK,<empty>,,examples\cpp\MyApp-qt.cpp,examples\cpp\MyApp-qt.cpp:<global>,,<global>,1
412,NAMESPACE_BLOCK,<empty>,,examples\cpp\MyApp1.cpp,examples\cpp\MyApp1.cpp:<global>,,<global>,1
484,NAMESPACE_BLOCK,<empty>,,examples\cpp\MyApp2.cpp,examples\cpp\MyApp2.cpp:<global>,,<global>,1
530,NAMESPACE_BLOCK,<empty>,,examples\cpp\auto-configured.cpp,examples\cpp\auto-configured.cpp:<global>,,<global>,1
566,NAMESPACE_BLOCK,<empty>,,examples\cpp\com\foo\bar-qt.cpp,examples\cpp\com\foo\bar-qt.cpp:<global>,,<global>,1
588,NAMESPACE_BLOCK,<empty>,,examples\cpp\com\foo\bar.cpp,examples\cpp\com\foo\bar.cpp:<global>,,<global>,1
606,NAMESPACE_BLOCK,<empty>,,examples\cpp\com\foo\bar.hpp,examples\cpp\com\foo\bar.hpp:<global>,,<global>,1
610,NAMESPACE_BLOCK,"namespace com { namespace foo {

class Bar {
    static LoggerPtr m_logger;
    public:
        void doIt();
};

} }",1,examples\cpp\com\foo\bar.hpp,com,4,com,1
611,NAMESPACE_BLOCK,"namespace foo {

class Bar {
    static LoggerPtr m_logger;
    public:
        void doIt();
};

}",17,examples\cpp\com\foo\bar.hpp,com.foo,4,foo,1
637,NAMESPACE_BLOCK,<empty>,,examples\cpp\com\foo\config-qt.cpp,examples\cpp\com\foo\config-qt.cpp:<global>,,<global>,1
641,NAMESPACE_BLOCK,"namespace com { namespace foo {

// Provide the name of the configuration file to Log4cxx.
// Reload the configuration on a QFileSystemWatcher::fileChanged event.
void ConfigureLogging() {
	using namespace log4cxx;
	static struct log4cxx_finalizer {
		~log4cxx_finalizer() {
			LogManager::shutdown();
		}
	} finaliser;
	QFileInfo app{QCoreApplication::applicationFilePath()};
	QString basename{app.baseName()};
	QVector<QString> paths =
		{ QString(""."")
		, app.absoluteDir().absolutePath()
		};
	QVector<QString> names =
		{ QString(basename + "".xml"")
		, QString(basename + "".properties"")
		, QString(""MyApp.properties"")
		, QString(""log4cxx.xml"")
		, QString(""log4cxx.properties"")
		, QString(""log4j.xml"")
		, QString(""log4j.properties"")
	};
#if defined(_DEBUG)
	helpers::LogLog::setInternalDebugging(true);
#endif
	auto status       = spi::ConfigurationStatus::NotConfigured;
	auto selectedPath = QString();
	std::tie(status, selectedPath) = qt::Configuration::configureFromFileAndWatch(paths...",1,examples\cpp\com\foo\config-qt.cpp,com,27,com,1
642,NAMESPACE_BLOCK,"namespace foo {

// Provide the name of the configuration file to Log4cxx.
// Reload the configuration on a QFileSystemWatcher::fileChanged event.
void ConfigureLogging() {
	using namespace log4cxx;
	static struct log4cxx_finalizer {
		~log4cxx_finalizer() {
			LogManager::shutdown();
		}
	} finaliser;
	QFileInfo app{QCoreApplication::applicationFilePath()};
	QString basename{app.baseName()};
	QVector<QString> paths =
		{ QString(""."")
		, app.absoluteDir().absolutePath()
		};
	QVector<QString> names =
		{ QString(basename + "".xml"")
		, QString(basename + "".properties"")
		, QString(""MyApp.properties"")
		, QString(""log4cxx.xml"")
		, QString(""log4cxx.properties"")
		, QString(""log4j.xml"")
		, QString(""log4j.properties"")
	};
#if defined(_DEBUG)
	helpers::LogLog::setInternalDebugging(true);
#endif
	auto status       = spi::ConfigurationStatus::NotConfigured;
	auto selectedPath = QString();
	std::tie(status, selectedPath) = qt::Configuration::configureFromFileAndWatch(paths, names);
	if (s...",17,examples\cpp\com\foo\config-qt.cpp,com.foo,27,foo,1
759,NAMESPACE_BLOCK,<empty>,,examples\cpp\com\foo\config-qt.hpp,examples\cpp\com\foo\config-qt.hpp:<global>,,<global>,1
763,NAMESPACE_BLOCK,"namespace com { namespace foo {

// Provide the name of the configuration file to Log4cxx.
void ConfigureLogging();

/// The logger pointer we use
using LoggerPtr = log4cxx::LoggerPtr;

/// Retrieve the \c name logger pointer.
extern auto getLogger(const QString& name) -> LoggerPtr;

/// Retrieve the \c name logger pointer.
extern auto getLogger(const char* name = NULL) -> LoggerPtr;

} }",1,examples\cpp\com\foo\config-qt.hpp,com,6,com,1
764,NAMESPACE_BLOCK,"namespace foo {

// Provide the name of the configuration file to Log4cxx.
void ConfigureLogging();

/// The logger pointer we use
using LoggerPtr = log4cxx::LoggerPtr;

/// Retrieve the \c name logger pointer.
extern auto getLogger(const QString& name) -> LoggerPtr;

/// Retrieve the \c name logger pointer.
extern auto getLogger(const char* name = NULL) -> LoggerPtr;

}",17,examples\cpp\com\foo\config-qt.hpp,com.foo,6,foo,1
783,NAMESPACE_BLOCK,<empty>,,examples\cpp\com\foo\config.hpp,examples\cpp\com\foo\config.hpp:<global>,,<global>,1
787,NAMESPACE_BLOCK,"namespace com { namespace foo {

/// The logger pointer we use
using LoggerPtr = log4cxx::LoggerPtr;

/// Retrieve the \c name logger pointer.
/// Configure Log4cxx on the first call.
extern auto getLogger(const std::string& name = std::string()) -> LoggerPtr;

} }",1,examples\cpp\com\foo\config.hpp,com,6,com,1
788,NAMESPACE_BLOCK,"namespace foo {

/// The logger pointer we use
using LoggerPtr = log4cxx::LoggerPtr;

/// Retrieve the \c name logger pointer.
/// Configure Log4cxx on the first call.
extern auto getLogger(const std::string& name = std::string()) -> LoggerPtr;

}",17,examples\cpp\com\foo\config.hpp,com.foo,6,foo,1
802,NAMESPACE_BLOCK,<empty>,,examples\cpp\com\foo\config1.cpp,examples\cpp\com\foo\config1.cpp:<global>,,<global>,1
806,NAMESPACE_BLOCK,"namespace com { namespace foo {

auto getLogger(const std::string& name) -> LoggerPtr {
	using namespace log4cxx;
	static struct log4cxx_initializer {
		log4cxx_initializer() {
			// Set up a simple configuration that logs on the console.
			BasicConfigurator::configure();
		}
		~log4cxx_initializer() {
			LogManager::shutdown();
		}
	} initAndShutdown;
	return name.empty()
		? LogManager::getRootLogger()
		: LogManager::getLogger(name);
}

} }",1,examples\cpp\com\foo\config1.cpp,com,5,com,1
807,NAMESPACE_BLOCK,"namespace foo {

auto getLogger(const std::string& name) -> LoggerPtr {
	using namespace log4cxx;
	static struct log4cxx_initializer {
		log4cxx_initializer() {
			// Set up a simple configuration that logs on the console.
			BasicConfigurator::configure();
		}
		~log4cxx_initializer() {
			LogManager::shutdown();
		}
	} initAndShutdown;
	return name.empty()
		? LogManager::getRootLogger()
		: LogManager::getLogger(name);
}

}",17,examples\cpp\com\foo\config1.cpp,com.foo,5,foo,1
838,NAMESPACE_BLOCK,<empty>,,examples\cpp\com\foo\config2.cpp,examples\cpp\com\foo\config2.cpp:<global>,,<global>,1
842,NAMESPACE_BLOCK,"namespace com { namespace foo {

auto getLogger(const std::string& name) -> LoggerPtr {
	using namespace log4cxx;
	static struct log4cxx_initializer {
		log4cxx_initializer() {
			if (PropertyConfigurator::configure(""MyApp.properties"") == spi::ConfigurationStatus::NotConfigured)
				BasicConfigurator::configure(); // Send events to the console
		}
		~log4cxx_initializer() {
			LogManager::shutdown();
		}
	} initAndShutdown;
	return name.empty()
		? LogManager::getRootLogger()
		: LogManager::getLogger(name);
}

} }",1,examples\cpp\com\foo\config2.cpp,com,6,com,1
843,NAMESPACE_BLOCK,"namespace foo {

auto getLogger(const std::string& name) -> LoggerPtr {
	using namespace log4cxx;
	static struct log4cxx_initializer {
		log4cxx_initializer() {
			if (PropertyConfigurator::configure(""MyApp.properties"") == spi::ConfigurationStatus::NotConfigured)
				BasicConfigurator::configure(); // Send events to the console
		}
		~log4cxx_initializer() {
			LogManager::shutdown();
		}
	} initAndShutdown;
	return name.empty()
		? LogManager::getRootLogger()
		: LogManager::getLogger(name);
}

}",17,examples\cpp\com\foo\config2.cpp,com.foo,6,foo,1
892,NAMESPACE_BLOCK,<empty>,,examples\cpp\com\foo\config3.cpp,examples\cpp\com\foo\config3.cpp:<global>,,<global>,1
896,NAMESPACE_BLOCK,"namespace {
using namespace log4cxx;

// Get a list of file base names that may contain configuration data
// and put an alternate path into \c altPrefix
auto DefaultConfigurationFileNames(std::string& altPrefix) -> std::vector<std::string> {
	std::vector<std::string> result;

	// Find the executable file name
	static const int bufSize = 4096;
	char buf[bufSize+1] = {0}, pathSepar = '/';
	uint32_t bufCount = 0;
#if defined(WIN32)
	GetModuleFileName(NULL, buf, bufSize);
	pathSepar = '\\';
#elif defined(__APPLE__)
	_NSGetExecutablePath(buf, &bufCount);
#elif (defined(_XOPEN_SOURCE) && _XOPEN_SOURCE >= 500) || (defined(_POSIX_C_SOURCE) && _POSIX_C_SOURCE >= 200112L)
	std::ostringstream exeLink;
	exeLink << ""/proc/"" << getpid() << ""/exe"";
	bufCount = readlink(exeLink.str().c_str(), buf, bufSize);
	if (0 < bufCount)
		buf[bufCount] = 0;
#else
	strncpy(buf, ""auto-configured"", bufSize);
#endif
	std::string programFileName(buf);
	auto slashIndex = programFileName.rfind(pathSepar);
	if (std:...",1,examples\cpp\com\foo\config3.cpp,anonymous_namespace_0,39,,1
1165,NAMESPACE_BLOCK,"namespace com { namespace foo {

// Retrieve the \c name logger pointer.
// Configure Log4cxx on the first call.
auto getLogger(const std::string& name) -> LoggerPtr {
	using namespace log4cxx;
	static struct log4cxx_initializer {
		log4cxx_initializer() {
			SelectConfigurationFile();
		}
		~log4cxx_initializer() {
			LogManager::shutdown();
		}
	} initialiser;
	return name.empty()
		? LogManager::getRootLogger()
		: LogManager::getLogger(name);
}

} }",1,examples\cpp\com\foo\config3.cpp,com,152,com,2
1166,NAMESPACE_BLOCK,"namespace foo {

// Retrieve the \c name logger pointer.
// Configure Log4cxx on the first call.
auto getLogger(const std::string& name) -> LoggerPtr {
	using namespace log4cxx;
	static struct log4cxx_initializer {
		log4cxx_initializer() {
			SelectConfigurationFile();
		}
		~log4cxx_initializer() {
			LogManager::shutdown();
		}
	} initialiser;
	return name.empty()
		? LogManager::getRootLogger()
		: LogManager::getLogger(name);
}

}",17,examples\cpp\com\foo\config3.cpp,com.foo,152,foo,1
1246,NAMESPACE_BLOCK,<empty>,,examples\cpp\console.cpp,examples\cpp\console.cpp:<global>,,<global>,1
1468,NAMESPACE_BLOCK,<empty>,,examples\cpp\custom-appender.cpp,examples\cpp\custom-appender.cpp:<global>,,<global>,1
1472,NAMESPACE_BLOCK,"namespace LOG4CXX_NS {

class NullWriterAppender : public AppenderSkeleton {
public:
	DECLARE_LOG4CXX_OBJECT(NullWriterAppender)
	BEGIN_LOG4CXX_CAST_MAP()
	LOG4CXX_CAST_ENTRY(NullWriterAppender)
	LOG4CXX_CAST_ENTRY_CHAIN(AppenderSkeleton)
	END_LOG4CXX_CAST_MAP()

	NullWriterAppender(){}

	void close() override{}

	bool requiresLayout() const override {
		return false;
	}

	void append(const spi::LoggingEventPtr& event, helpers::Pool& p) override {
		// This gets called whenever there is a valid event for our appender.
	}

	void activateOptions(helpers::Pool& /* pool */) override {
		// Given all of our options, do something useful(e.g. open a file)
	}

	void setOption(const LogString& option, const LogString& value) override {
		if (helpers::StringHelper::equalsIgnoreCase(option,
										   LOG4CXX_STR(""SOMEVALUE""), LOG4CXX_STR(""somevalue""))){
			// Do something with the 'value' here.
		}
	}
};

IMPLEMENT_LOG4CXX_OBJECT(NullWriterAppender)

}",1,examples\cpp\custom-appender.cpp,LOG4CXX_NS,23,LOG4CXX_NS,1
1574,NAMESPACE_BLOCK,<empty>,,examples\cpp\delayedloop.cpp,examples\cpp\delayedloop.cpp:<global>,,<global>,1
1755,NAMESPACE_BLOCK,<empty>,,examples\cpp\format-string.cpp,examples\cpp\format-string.cpp:<global>,,<global>,1
1865,NAMESPACE_BLOCK,<empty>,,examples\cpp\ndc-example.cpp,examples\cpp\ndc-example.cpp:<global>,,<global>,1
1928,NAMESPACE_BLOCK,<empty>,,examples\cpp\stream.cpp,examples\cpp\stream.cpp:<global>,,<global>,1
2049,NAMESPACE_BLOCK,<empty>,,main\cpp-qt\configuration.cpp,main\cpp-qt\configuration.cpp:<global>,,<global>,1
2053,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace qt
{
using LOG4CXX_NS::helpers::LogLog;

static std::unique_ptr<QFileSystemWatcher> watcher;
static QString configFilename;

static void loadXMLFile(const QString& path){
	QFileInfo fi(configFilename);
	if(!fi.exists()){
		return;
	}
	LOG4CXX_NS::xml::DOMConfigurator::configure(path.toStdString());
}

static void loadPropertiesFile(const QString& path){
	QFileInfo fi(configFilename);
	if(!fi.exists()){
		return;
	}
	LOG4CXX_NS::PropertyConfigurator::configure(path.toStdString());
}

static void dirChanged(const QString&){
	QFileInfo fi(configFilename);
	if(fi.exists()){
		// From the Qt docs:
		// Note that QFileSystemWatcher stops monitoring files once they have been renamed
		// or removed from disk, and directories once they have been removed from disk.
		//
		// Some text editing programs will replace the file with a new one, which deletes
		// the old file(thus causing Qt to remove the watch), so we need to add in the
		// file whenever the dire...",1,main\cpp-qt\configuration.cpp,LOG4CXX_NS,29,LOG4CXX_NS,1
2054,NAMESPACE_BLOCK,"namespace qt
{
using LOG4CXX_NS::helpers::LogLog;

static std::unique_ptr<QFileSystemWatcher> watcher;
static QString configFilename;

static void loadXMLFile(const QString& path){
	QFileInfo fi(configFilename);
	if(!fi.exists()){
		return;
	}
	LOG4CXX_NS::xml::DOMConfigurator::configure(path.toStdString());
}

static void loadPropertiesFile(const QString& path){
	QFileInfo fi(configFilename);
	if(!fi.exists()){
		return;
	}
	LOG4CXX_NS::PropertyConfigurator::configure(path.toStdString());
}

static void dirChanged(const QString&){
	QFileInfo fi(configFilename);
	if(fi.exists()){
		// From the Qt docs:
		// Note that QFileSystemWatcher stops monitoring files once they have been renamed
		// or removed from disk, and directories once they have been removed from disk.
		//
		// Some text editing programs will replace the file with a new one, which deletes
		// the old file(thus causing Qt to remove the watch), so we need to add in the
		// file whenever the directory changes.
		// See...",1,main\cpp-qt\configuration.cpp,LOG4CXX_NS.qt,31,qt,1
2356,NAMESPACE_BLOCK,<empty>,,main\cpp-qt\messagehandler.cpp,main\cpp-qt\messagehandler.cpp:<global>,,<global>,1
2360,NAMESPACE_BLOCK,"namespace LOG4CXX_NS {
namespace qt {

void messageHandler(QtMsgType type, const QMessageLogContext& context, const QString& message )
{
	LOG4CXX_NS::LoggerPtr qtLogger = LOG4CXX_NS::Logger::getLogger( context.category );
	LOG4CXX_NS::spi::LocationInfo location( context.file,
										 LOG4CXX_NS::spi::LocationInfo::calcShortFileName(context.file),
										 context.function,
										 context.line );

	switch ( type )
	{
		case QtMsgType::QtDebugMsg:
			qtLogger->debug( message.toStdString(), location );
			break;

		case QtMsgType::QtWarningMsg:
			qtLogger->warn( message.toStdString(), location );
			break;
#if QT_VERSION >= QT_VERSION_CHECK(5, 5, 0)

		case QtMsgType::QtInfoMsg:
			qtLogger->info( message.toStdString(), location );
			break;
#endif

		case QtMsgType::QtCriticalMsg:
			qtLogger->error( message.toStdString(), location );
			break;

		case QtMsgType::QtFatalMsg:
			qtLogger->fatal( message.toStdString(), location );
			std::abort();
	}
}

} /* namespace qt */
}",1,main\cpp-qt\messagehandler.cpp,LOG4CXX_NS,21,LOG4CXX_NS,1
2361,NAMESPACE_BLOCK,"namespace qt {

void messageHandler(QtMsgType type, const QMessageLogContext& context, const QString& message )
{
	LOG4CXX_NS::LoggerPtr qtLogger = LOG4CXX_NS::Logger::getLogger( context.category );
	LOG4CXX_NS::spi::LocationInfo location( context.file,
										 LOG4CXX_NS::spi::LocationInfo::calcShortFileName(context.file),
										 context.function,
										 context.line );

	switch ( type )
	{
		case QtMsgType::QtDebugMsg:
			qtLogger->debug( message.toStdString(), location );
			break;

		case QtMsgType::QtWarningMsg:
			qtLogger->warn( message.toStdString(), location );
			break;
#if QT_VERSION >= QT_VERSION_CHECK(5, 5, 0)

		case QtMsgType::QtInfoMsg:
			qtLogger->info( message.toStdString(), location );
			break;
#endif

		case QtMsgType::QtCriticalMsg:
			qtLogger->error( message.toStdString(), location );
			break;

		case QtMsgType::QtFatalMsg:
			qtLogger->fatal( message.toStdString(), location );
			std::abort();
	}
}

}",1,main\cpp-qt\messagehandler.cpp,LOG4CXX_NS.qt,22,qt,1
2490,NAMESPACE_BLOCK,<empty>,,main\cpp\action.cpp,main\cpp\action.cpp:<global>,,<global>,1
2594,NAMESPACE_BLOCK,<empty>,,main\cpp\andfilter.cpp,main\cpp\andfilter.cpp:<global>,,<global>,1
2779,NAMESPACE_BLOCK,<empty>,,main\cpp\appenderattachableimpl.cpp,main\cpp\appenderattachableimpl.cpp:<global>,,<global>,1
3231,NAMESPACE_BLOCK,<empty>,,main\cpp\appenderskeleton.cpp,main\cpp\appenderskeleton.cpp:<global>,,<global>,1
3615,NAMESPACE_BLOCK,<empty>,,main\cpp\aprdatagramsocket.cpp,main\cpp\aprdatagramsocket.cpp:<global>,,<global>,1
3619,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{

#define _priv static_cast<APRDatagramSocketPriv*>(m_priv.get())

struct APRDatagramSocket::APRDatagramSocketPriv : public DatagramSocketPriv {
	APRDatagramSocketPriv() :
		DatagramSocketPriv(),
		socket(nullptr)
	{}

	APRDatagramSocketPriv(int port) :
		DatagramSocketPriv(port),
		socket(nullptr)
	{}

	APRDatagramSocketPriv(int port, InetAddressPtr localAddress) :
		DatagramSocketPriv(port, localAddress),
		socket(nullptr)
	{}

	/** The APR socket */
	apr_socket_t* socket;

	/** The memory pool for the socket */
	Pool socketPool;
};

APRDatagramSocket::APRDatagramSocket() :
	DatagramSocket(std::make_unique<APRDatagramSocketPriv>()){
	init();
}

APRDatagramSocket::APRDatagramSocket(int port) :
	DatagramSocket(std::make_unique<APRDatagramSocketPriv>(port)){
	init();
}

APRDatagramSocket::APRDatagramSocket(int port, InetAddressPtr laddr) :
	DatagramSocket(std::make_unique<APRDatagramSocketPriv>(port, laddr)){
	init();
}

void APRDatagramSocke...",1,main\cpp\aprdatagramsocket.cpp,LOG4CXX_NS,23,LOG4CXX_NS,1
3620,NAMESPACE_BLOCK,"namespace helpers
{

#define _priv static_cast<APRDatagramSocketPriv*>(m_priv.get())

struct APRDatagramSocket::APRDatagramSocketPriv : public DatagramSocketPriv {
	APRDatagramSocketPriv() :
		DatagramSocketPriv(),
		socket(nullptr)
	{}

	APRDatagramSocketPriv(int port) :
		DatagramSocketPriv(port),
		socket(nullptr)
	{}

	APRDatagramSocketPriv(int port, InetAddressPtr localAddress) :
		DatagramSocketPriv(port, localAddress),
		socket(nullptr)
	{}

	/** The APR socket */
	apr_socket_t* socket;

	/** The memory pool for the socket */
	Pool socketPool;
};

APRDatagramSocket::APRDatagramSocket() :
	DatagramSocket(std::make_unique<APRDatagramSocketPriv>()){
	init();
}

APRDatagramSocket::APRDatagramSocket(int port) :
	DatagramSocket(std::make_unique<APRDatagramSocketPriv>(port)){
	init();
}

APRDatagramSocket::APRDatagramSocket(int port, InetAddressPtr laddr) :
	DatagramSocket(std::make_unique<APRDatagramSocketPriv>(port, laddr)){
	init();
}

void APRDatagramSocket::init()
{
	apr_socket...",1,main\cpp\aprdatagramsocket.cpp,LOG4CXX_NS.helpers,25,helpers,1
4110,NAMESPACE_BLOCK,<empty>,,main\cpp\aprinitializer.cpp,main\cpp\aprinitializer.cpp:<global>,,<global>,1
4129,NAMESPACE_BLOCK,"namespace
{
void tlsDestructImpl(void* ptr)
{
	delete ((ThreadSpecificData*) ptr);
}
}",1,main\cpp\aprinitializer.cpp,anonymous_namespace_0,50,,4
4147,NAMESPACE_BLOCK,"namespace
{
// The first object created and the last object destroyed
struct apr_environment
{
    apr_environment()
    {
        apr_initialize();
    }
    ~apr_environment()
    {
        apr_terminate();
    }
};

}",1,main\cpp\aprinitializer.cpp,anonymous_namespace_3,65,,6
4465,NAMESPACE_BLOCK,<empty>,,main\cpp\aprserversocket.cpp,main\cpp\aprserversocket.cpp:<global>,,<global>,1
4469,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{

#define _priv static_cast<APRServerSocketPriv*>(m_priv.get())

struct APRServerSocket::APRServerSocketPriv : public ServerSocketPrivate {
	Pool pool;
	std::mutex mutex;
	apr_socket_t* socket;
};

APRServerSocket::APRServerSocket(int port) :
	ServerSocket(std::make_unique<APRServerSocketPriv>()){
	apr_status_t status =
		apr_socket_create(&_priv->socket, APR_INET, SOCK_STREAM,
			APR_PROTO_TCP, _priv->pool.getAPRPool());

	if (status != APR_SUCCESS)
	{
		throw SocketException(status);
	}

	status = apr_socket_opt_set(_priv->socket, APR_SO_NONBLOCK, 1);

	if (status != APR_SUCCESS)
	{
		throw SocketException(status);
	}

	// Create server socket address (including port number)
	apr_sockaddr_t* server_addr;
	status =
		apr_sockaddr_info_get(&server_addr, NULL, APR_INET,
			port, 0, _priv->pool.getAPRPool());

	if (status != APR_SUCCESS)
	{
		throw ConnectException(status);
	}

	// bind the socket to the address
	status = apr_socket_bind(_priv...",1,main\cpp\aprserversocket.cpp,LOG4CXX_NS,25,LOG4CXX_NS,1
4470,NAMESPACE_BLOCK,"namespace helpers
{

#define _priv static_cast<APRServerSocketPriv*>(m_priv.get())

struct APRServerSocket::APRServerSocketPriv : public ServerSocketPrivate {
	Pool pool;
	std::mutex mutex;
	apr_socket_t* socket;
};

APRServerSocket::APRServerSocket(int port) :
	ServerSocket(std::make_unique<APRServerSocketPriv>()){
	apr_status_t status =
		apr_socket_create(&_priv->socket, APR_INET, SOCK_STREAM,
			APR_PROTO_TCP, _priv->pool.getAPRPool());

	if (status != APR_SUCCESS)
	{
		throw SocketException(status);
	}

	status = apr_socket_opt_set(_priv->socket, APR_SO_NONBLOCK, 1);

	if (status != APR_SUCCESS)
	{
		throw SocketException(status);
	}

	// Create server socket address (including port number)
	apr_sockaddr_t* server_addr;
	status =
		apr_sockaddr_info_get(&server_addr, NULL, APR_INET,
			port, 0, _priv->pool.getAPRPool());

	if (status != APR_SUCCESS)
	{
		throw ConnectException(status);
	}

	// bind the socket to the address
	status = apr_socket_bind(_priv->socket, server_addr);...",1,main\cpp\aprserversocket.cpp,LOG4CXX_NS.helpers,27,helpers,1
4905,NAMESPACE_BLOCK,<empty>,,main\cpp\aprsocket.cpp,main\cpp\aprsocket.cpp:<global>,,<global>,1
4909,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{

struct APRSocket::APRSocketPriv : public Socket::SocketPrivate {
	APRSocketPriv(InetAddressPtr& address, int port)
		: Socket::SocketPrivate(address, port)
		, socket(nullptr)
	{}

	APRSocketPriv(apr_socket_t* sock, apr_pool_t* p) :
		pool(p, true),
		socket(sock)
	{}

	Pool pool;
	apr_socket_t* socket;
};

#define _priv static_cast<APRSocketPriv*>(m_priv.get())

APRSocket::APRSocket(InetAddressPtr& address, int port) :
	Socket(std::make_unique<APRSocketPriv>(address, port)){
	apr_status_t status =
		apr_socket_create(&_priv->socket, APR_INET, SOCK_STREAM,
			APR_PROTO_TCP, _priv->pool.getAPRPool());

	if (status != APR_SUCCESS)
	{
		throw SocketException(status);
	}

	LOG4CXX_ENCODE_CHAR(host, address->getHostAddress());

	// create socket address (including port)
	apr_sockaddr_t* client_addr;
	status =
		apr_sockaddr_info_get(&client_addr, host.c_str(), APR_INET,
			port, 0, _priv->pool.getAPRPool());

	if (status != APR_SUCCESS)
	{
		th...",1,main\cpp\aprsocket.cpp,LOG4CXX_NS,26,LOG4CXX_NS,1
4910,NAMESPACE_BLOCK,"namespace helpers
{

struct APRSocket::APRSocketPriv : public Socket::SocketPrivate {
	APRSocketPriv(InetAddressPtr& address, int port)
		: Socket::SocketPrivate(address, port)
		, socket(nullptr)
	{}

	APRSocketPriv(apr_socket_t* sock, apr_pool_t* p) :
		pool(p, true),
		socket(sock)
	{}

	Pool pool;
	apr_socket_t* socket;
};

#define _priv static_cast<APRSocketPriv*>(m_priv.get())

APRSocket::APRSocket(InetAddressPtr& address, int port) :
	Socket(std::make_unique<APRSocketPriv>(address, port)){
	apr_status_t status =
		apr_socket_create(&_priv->socket, APR_INET, SOCK_STREAM,
			APR_PROTO_TCP, _priv->pool.getAPRPool());

	if (status != APR_SUCCESS)
	{
		throw SocketException(status);
	}

	LOG4CXX_ENCODE_CHAR(host, address->getHostAddress());

	// create socket address (including port)
	apr_sockaddr_t* client_addr;
	status =
		apr_sockaddr_info_get(&client_addr, host.c_str(), APR_INET,
			port, 0, _priv->pool.getAPRPool());

	if (status != APR_SUCCESS)
	{
		throw ConnectException(st...",1,main\cpp\aprsocket.cpp,LOG4CXX_NS.helpers,28,helpers,1
5334,NAMESPACE_BLOCK,<empty>,,main\cpp\asyncappender.cpp,main\cpp\asyncappender.cpp:<global>,,<global>,1
6678,NAMESPACE_BLOCK,<empty>,,main\cpp\atexitregistry.cpp,main\cpp\atexitregistry.cpp:<global>,,<global>,1
6682,NAMESPACE_BLOCK,"namespace
{
	struct AtExitRegistryImpl : public AtExitRegistry
	{
		~AtExitRegistryImpl()
		{
			std::lock_guard<std::recursive_mutex> lock(mutex);
			while(!actions.empty())
			{
				std::function<void()> action = std::move(actions.begin()->second);
				actions.erase(actions.begin());
				action();
			}
		}

		void add(void* key, std::function<void()> action)
		{
			std::lock_guard<std::recursive_mutex> lock(mutex);
			actions.emplace(key, std::move(action));
		}

		void del(void* key)
		{
			std::lock_guard<std::recursive_mutex> lock(mutex);
			actions.erase(key);
		}

	private:
		std::recursive_mutex mutex;
		std::map<void*, std::function<void()>> actions;
	} s_instance;
}",1,main\cpp\atexitregistry.cpp,anonymous_namespace_0,24,,1
6831,NAMESPACE_BLOCK,<empty>,,main\cpp\basicconfigurator.cpp,main\cpp\basicconfigurator.cpp:<global>,,<global>,1
6919,NAMESPACE_BLOCK,<empty>,,main\cpp\bufferedwriter.cpp,main\cpp\bufferedwriter.cpp:<global>,,<global>,1
7100,NAMESPACE_BLOCK,<empty>,,main\cpp\bytearrayinputstream.cpp,main\cpp\bytearrayinputstream.cpp:<global>,,<global>,1
7214,NAMESPACE_BLOCK,<empty>,,main\cpp\bytearrayoutputstream.cpp,main\cpp\bytearrayoutputstream.cpp:<global>,,<global>,1
7307,NAMESPACE_BLOCK,<empty>,,main\cpp\bytebuffer.cpp,main\cpp\bytebuffer.cpp:<global>,,<global>,1
7518,NAMESPACE_BLOCK,<empty>,,main\cpp\cacheddateformat.cpp,main\cpp\cacheddateformat.cpp:<global>,,<global>,1
8228,NAMESPACE_BLOCK,<empty>,,main\cpp\charsetdecoder.cpp,main\cpp\charsetdecoder.cpp:<global>,,<global>,1
8234,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{

#if APR_HAS_XLATE
/**
 *  Converts from an arbitrary encoding to LogString
 *    using apr_xlate.  Requires real iconv implementation,
*    apr-iconv will crash in use.
 */
class APRCharsetDecoder : public CharsetDecoder
{
	public:
		/**
		 *  Creates a new instance.
		 *  @param frompage name of source encoding.
		 */
		APRCharsetDecoder(const LogString& frompage) : pool()
		{
#if LOG4CXX_LOGCHAR_IS_WCHAR
			const char* topage = ""WCHAR_T"";
#endif
#if LOG4CXX_LOGCHAR_IS_UTF8
			const char* topage = ""UTF-8"";
#endif
#if LOG4CXX_LOGCHAR_IS_UNICHAR
			const char* topage = ""UTF-16"";
#endif
			std::string fpage(Transcoder::encodeCharsetName(frompage));
			apr_status_t stat = apr_xlate_open(&convset,
					topage,
					fpage.c_str(),
					pool.getAPRPool());

			if (stat != APR_SUCCESS)
			{
				throw IllegalArgumentException(frompage);
			}
		}

		/**
		 *  Destructor.
		 */
		virtual ~APRCharsetDecoder()
		{
		}

		virtual log4cxx_status_t decod...",1,main\cpp\charsetdecoder.cpp,LOG4CXX_NS,41,LOG4CXX_NS,3
8235,NAMESPACE_BLOCK,"namespace helpers
{

#if APR_HAS_XLATE
/**
 *  Converts from an arbitrary encoding to LogString
 *    using apr_xlate.  Requires real iconv implementation,
*    apr-iconv will crash in use.
 */
class APRCharsetDecoder : public CharsetDecoder
{
	public:
		/**
		 *  Creates a new instance.
		 *  @param frompage name of source encoding.
		 */
		APRCharsetDecoder(const LogString& frompage) : pool()
		{
#if LOG4CXX_LOGCHAR_IS_WCHAR
			const char* topage = ""WCHAR_T"";
#endif
#if LOG4CXX_LOGCHAR_IS_UTF8
			const char* topage = ""UTF-8"";
#endif
#if LOG4CXX_LOGCHAR_IS_UNICHAR
			const char* topage = ""UTF-16"";
#endif
			std::string fpage(Transcoder::encodeCharsetName(frompage));
			apr_status_t stat = apr_xlate_open(&convset,
					topage,
					fpage.c_str(),
					pool.getAPRPool());

			if (stat != APR_SUCCESS)
			{
				throw IllegalArgumentException(frompage);
			}
		}

		/**
		 *  Destructor.
		 */
		virtual ~APRCharsetDecoder()
		{
		}

		virtual log4cxx_status_t decode(ByteBuffer& in,
			Lo...",1,main\cpp\charsetdecoder.cpp,LOG4CXX_NS.helpers,43,helpers,1
9020,NAMESPACE_BLOCK,<empty>,,main\cpp\charsetencoder.cpp,main\cpp\charsetencoder.cpp:<global>,,<global>,1
9025,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{

namespace helpers
{

#if APR_HAS_XLATE
/**
* A character encoder implemented using apr_xlate.
*/
class APRCharsetEncoder : public CharsetEncoder
{
	public:
		APRCharsetEncoder(const LogString& topage) : pool()
		{
#if LOG4CXX_LOGCHAR_IS_WCHAR
			const char* frompage = ""WCHAR_T"";
#endif
#if LOG4CXX_LOGCHAR_IS_UTF8
			const char* frompage = ""UTF-8"";
#endif
#if LOG4CXX_LOGCHAR_IS_UNICHAR
			const char* frompage = ""UTF-16"";
#endif
			std::string tpage(Transcoder::encodeCharsetName(topage));
			apr_status_t stat = apr_xlate_open(&convset,
					tpage.c_str(),
					frompage,
					pool.getAPRPool());

			if (stat != APR_SUCCESS)
			{
				throw IllegalArgumentException(topage);
			}
		}

		virtual ~APRCharsetEncoder()
		{
		}

		virtual log4cxx_status_t encode(const LogString& in,
			LogString::const_iterator& iter,
			ByteBuffer& out)
		{
			apr_status_t stat;
			size_t outbytes_left = out.remaining();
			size_t initial_outbytes_left = outbytes_left;
			size_t positi...",1,main\cpp\charsetencoder.cpp,LOG4CXX_NS,43,LOG4CXX_NS,3
9026,NAMESPACE_BLOCK,"namespace helpers
{

#if APR_HAS_XLATE
/**
* A character encoder implemented using apr_xlate.
*/
class APRCharsetEncoder : public CharsetEncoder
{
	public:
		APRCharsetEncoder(const LogString& topage) : pool()
		{
#if LOG4CXX_LOGCHAR_IS_WCHAR
			const char* frompage = ""WCHAR_T"";
#endif
#if LOG4CXX_LOGCHAR_IS_UTF8
			const char* frompage = ""UTF-8"";
#endif
#if LOG4CXX_LOGCHAR_IS_UNICHAR
			const char* frompage = ""UTF-16"";
#endif
			std::string tpage(Transcoder::encodeCharsetName(topage));
			apr_status_t stat = apr_xlate_open(&convset,
					tpage.c_str(),
					frompage,
					pool.getAPRPool());

			if (stat != APR_SUCCESS)
			{
				throw IllegalArgumentException(topage);
			}
		}

		virtual ~APRCharsetEncoder()
		{
		}

		virtual log4cxx_status_t encode(const LogString& in,
			LogString::const_iterator& iter,
			ByteBuffer& out)
		{
			apr_status_t stat;
			size_t outbytes_left = out.remaining();
			size_t initial_outbytes_left = outbytes_left;
			size_t position = out.position();

		...",1,main\cpp\charsetencoder.cpp,LOG4CXX_NS.helpers,46,helpers,1
10046,NAMESPACE_BLOCK,<empty>,,main\cpp\class.cpp,main\cpp\class.cpp:<global>,,<global>,1
10050,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
uint32_t libraryVersion()
{
	// This function defined in log4cxx.h
	return LOG4CXX_VERSION;
}
}",1,main\cpp\class.cpp,LOG4CXX_NS,77,LOG4CXX_NS,1
10344,NAMESPACE_BLOCK,<empty>,,main\cpp\classnamepatternconverter.cpp,main\cpp\classnamepatternconverter.cpp:<global>,,<global>,1
10423,NAMESPACE_BLOCK,<empty>,,main\cpp\classregistration.cpp,main\cpp\classregistration.cpp:<global>,,<global>,1
10450,NAMESPACE_BLOCK,<empty>,,main\cpp\colorendpatternconverter.cpp,main\cpp\colorendpatternconverter.cpp:<global>,,<global>,1
10500,NAMESPACE_BLOCK,<empty>,,main\cpp\colorstartpatternconverter.cpp,main\cpp\colorstartpatternconverter.cpp:<global>,,<global>,1
11444,NAMESPACE_BLOCK,<empty>,,main\cpp\configurator.cpp,main\cpp\configurator.cpp:<global>,,<global>,1
11473,NAMESPACE_BLOCK,<empty>,,main\cpp\consoleappender.cpp,main\cpp\consoleappender.cpp:<global>,,<global>,1
11763,NAMESPACE_BLOCK,<empty>,,main\cpp\cyclicbuffer.cpp,main\cpp\cyclicbuffer.cpp:<global>,,<global>,1
12115,NAMESPACE_BLOCK,<empty>,,main\cpp\datagrampacket.cpp,main\cpp\datagrampacket.cpp:<global>,,<global>,1
12308,NAMESPACE_BLOCK,<empty>,,main\cpp\datagramsocket.cpp,main\cpp\datagramsocket.cpp:<global>,,<global>,1
12456,NAMESPACE_BLOCK,<empty>,,main\cpp\date.cpp,main\cpp\date.cpp:<global>,,<global>,1
12462,NAMESPACE_BLOCK,"namespace {
Date::GetCurrentTimeFn getCurrentTimeFn = 0;
}",1,main\cpp\date.cpp,anonymous_namespace_0,31,,3
12565,NAMESPACE_BLOCK,<empty>,,main\cpp\dateformat.cpp,main\cpp\dateformat.cpp:<global>,,<global>,1
12625,NAMESPACE_BLOCK,<empty>,,main\cpp\datepatternconverter.cpp,main\cpp\datepatternconverter.cpp:<global>,,<global>,1
13007,NAMESPACE_BLOCK,<empty>,,main\cpp\dbappender.cpp,main\cpp\dbappender.cpp:<global>,,<global>,1
14241,NAMESPACE_BLOCK,<empty>,,main\cpp\defaultconfigurator.cpp,main\cpp\defaultconfigurator.cpp:<global>,,<global>,1
14245,NAMESPACE_BLOCK,"namespace
{
	LogString DefaultConfiguratorPath;
	int DefaultConfiguratorWatchSeconds = 0;
}",1,main\cpp\defaultconfigurator.cpp,anonymous_namespace_0,32,,1
14667,NAMESPACE_BLOCK,<empty>,,main\cpp\defaultloggerfactory.cpp,main\cpp\defaultloggerfactory.cpp:<global>,,<global>,1
14693,NAMESPACE_BLOCK,<empty>,,main\cpp\defaultrepositoryselector.cpp,main\cpp\defaultrepositoryselector.cpp:<global>,,<global>,1
14786,NAMESPACE_BLOCK,<empty>,,main\cpp\domconfigurator.cpp,main\cpp\domconfigurator.cpp:<global>,,<global>,1
14794,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace xml
{
class XMLWatchdog  : public FileWatchdog
{
	public:
		XMLWatchdog(const File& filename) : FileWatchdog(filename)
		{
		}

		/**
		Call DOMConfigurator#doConfigure with the
		<code>filename</code> to reconfigure log4cxx.
		*/
		void doOnChange()
		{
			DOMConfigurator().doConfigure(file(),
				LogManager::getLoggerRepository());
		}
};
}
}",1,main\cpp\domconfigurator.cpp,LOG4CXX_NS,68,LOG4CXX_NS,2
14795,NAMESPACE_BLOCK,"namespace xml
{
class XMLWatchdog  : public FileWatchdog
{
	public:
		XMLWatchdog(const File& filename) : FileWatchdog(filename)
		{
		}

		/**
		Call DOMConfigurator#doConfigure with the
		<code>filename</code> to reconfigure log4cxx.
		*/
		void doOnChange()
		{
			DOMConfigurator().doConfigure(file(),
				LogManager::getLoggerRepository());
		}
};
}",1,main\cpp\domconfigurator.cpp,LOG4CXX_NS.xml,70,xml,1
17449,NAMESPACE_BLOCK,<empty>,,main\cpp\exception.cpp,main\cpp\exception.cpp:<global>,,<global>,1
18206,NAMESPACE_BLOCK,<empty>,,main\cpp\fallbackerrorhandler.cpp,main\cpp\fallbackerrorhandler.cpp:<global>,,<global>,1
18512,NAMESPACE_BLOCK,<empty>,,main\cpp\file.cpp,main\cpp\file.cpp:<global>,,<global>,1
19176,NAMESPACE_BLOCK,<empty>,,main\cpp\fileappender.cpp,main\cpp\fileappender.cpp:<global>,,<global>,1
20192,NAMESPACE_BLOCK,<empty>,,main\cpp\filedatepatternconverter.cpp,main\cpp\filedatepatternconverter.cpp:<global>,,<global>,1
20249,NAMESPACE_BLOCK,<empty>,,main\cpp\fileinputstream.cpp,main\cpp\fileinputstream.cpp:<global>,,<global>,1
20472,NAMESPACE_BLOCK,<empty>,,main\cpp\filelocationpatternconverter.cpp,main\cpp\filelocationpatternconverter.cpp:<global>,,<global>,1
20527,NAMESPACE_BLOCK,<empty>,,main\cpp\fileoutputstream.cpp,main\cpp\fileoutputstream.cpp:<global>,,<global>,1
20781,NAMESPACE_BLOCK,<empty>,,main\cpp\filerenameaction.cpp,main\cpp\filerenameaction.cpp:<global>,,<global>,1
20852,NAMESPACE_BLOCK,<empty>,,main\cpp\filewatchdog.cpp,main\cpp\filewatchdog.cpp:<global>,,<global>,1
21219,NAMESPACE_BLOCK,<empty>,,main\cpp\filter.cpp,main\cpp\filter.cpp:<global>,,<global>,1
21272,NAMESPACE_BLOCK,<empty>,,main\cpp\filterbasedtriggeringpolicy.cpp,main\cpp\filterbasedtriggeringpolicy.cpp:<global>,,<global>,1
21472,NAMESPACE_BLOCK,<empty>,,main\cpp\fixedwindowrollingpolicy.cpp,main\cpp\fixedwindowrollingpolicy.cpp:<global>,,<global>,1
22527,NAMESPACE_BLOCK,<empty>,,main\cpp\fmtlayout.cpp,main\cpp\fmtlayout.cpp:<global>,,<global>,1
22947,NAMESPACE_BLOCK,<empty>,,main\cpp\formattinginfo.cpp,main\cpp\formattinginfo.cpp:<global>,,<global>,1
23115,NAMESPACE_BLOCK,<empty>,,main\cpp\fulllocationpatternconverter.cpp,main\cpp\fulllocationpatternconverter.cpp:<global>,,<global>,1
23199,NAMESPACE_BLOCK,<empty>,,main\cpp\gzcompressaction.cpp,main\cpp\gzcompressaction.cpp:<global>,,<global>,1
23623,NAMESPACE_BLOCK,<empty>,,main\cpp\hexdump.cpp,main\cpp\hexdump.cpp:<global>,,<global>,1
24041,NAMESPACE_BLOCK,<empty>,,main\cpp\hierarchy.cpp,main\cpp\hierarchy.cpp:<global>,,<global>,1
25559,NAMESPACE_BLOCK,<empty>,,main\cpp\htmllayout.cpp,main\cpp\htmllayout.cpp:<global>,,<global>,1
26468,NAMESPACE_BLOCK,<empty>,,main\cpp\inetaddress.cpp,main\cpp\inetaddress.cpp:<global>,,<global>,1
26744,NAMESPACE_BLOCK,<empty>,,main\cpp\inputstream.cpp,main\cpp\inputstream.cpp:<global>,,<global>,1
26773,NAMESPACE_BLOCK,<empty>,,main\cpp\inputstreamreader.cpp,main\cpp\inputstreamreader.cpp:<global>,,<global>,1
26940,NAMESPACE_BLOCK,<empty>,,main\cpp\integer.cpp,main\cpp\integer.cpp:<global>,,<global>,1
26968,NAMESPACE_BLOCK,<empty>,,main\cpp\integerpatternconverter.cpp,main\cpp\integerpatternconverter.cpp:<global>,,<global>,1
27043,NAMESPACE_BLOCK,<empty>,,main\cpp\jsonlayout.cpp,main\cpp\jsonlayout.cpp:<global>,,<global>,1
28302,NAMESPACE_BLOCK,<empty>,,main\cpp\layout.cpp,main\cpp\layout.cpp:<global>,,<global>,1
28380,NAMESPACE_BLOCK,<empty>,,main\cpp\level.cpp,main\cpp\level.cpp:<global>,,<global>,1
28857,NAMESPACE_BLOCK,<empty>,,main\cpp\levelmatchfilter.cpp,main\cpp\levelmatchfilter.cpp:<global>,,<global>,1
29101,NAMESPACE_BLOCK,<empty>,,main\cpp\levelpatternconverter.cpp,main\cpp\levelpatternconverter.cpp:<global>,,<global>,1
29249,NAMESPACE_BLOCK,<empty>,,main\cpp\levelrangefilter.cpp,main\cpp\levelrangefilter.cpp:<global>,,<global>,1
29603,NAMESPACE_BLOCK,<empty>,,main\cpp\linelocationpatternconverter.cpp,main\cpp\linelocationpatternconverter.cpp:<global>,,<global>,1
29656,NAMESPACE_BLOCK,<empty>,,main\cpp\lineseparatorpatternconverter.cpp,main\cpp\lineseparatorpatternconverter.cpp:<global>,,<global>,1
29715,NAMESPACE_BLOCK,<empty>,,main\cpp\literalpatternconverter.cpp,main\cpp\literalpatternconverter.cpp:<global>,,<global>,1
29851,NAMESPACE_BLOCK,<empty>,,main\cpp\loader.cpp,main\cpp\loader.cpp:<global>,,<global>,1
29917,NAMESPACE_BLOCK,<empty>,,main\cpp\locale.cpp,main\cpp\locale.cpp:<global>,,<global>,1
29996,NAMESPACE_BLOCK,<empty>,,main\cpp\locationinfo.cpp,main\cpp\locationinfo.cpp:<global>,,<global>,1
30276,NAMESPACE_BLOCK,<empty>,,main\cpp\locationinfofilter.cpp,main\cpp\locationinfofilter.cpp:<global>,,<global>,1
30755,NAMESPACE_BLOCK,<empty>,,main\cpp\logger.cpp,main\cpp\logger.cpp:<global>,,<global>,1
32284,NAMESPACE_BLOCK,<empty>,,main\cpp\loggermatchfilter.cpp,main\cpp\loggermatchfilter.cpp:<global>,,<global>,1
32490,NAMESPACE_BLOCK,<empty>,,main\cpp\loggerpatternconverter.cpp,main\cpp\loggerpatternconverter.cpp:<global>,,<global>,1
32610,NAMESPACE_BLOCK,<empty>,,main\cpp\loggingevent.cpp,main\cpp\loggingevent.cpp:<global>,,<global>,1
33249,NAMESPACE_BLOCK,<empty>,,main\cpp\loggingeventpatternconverter.cpp,main\cpp\loggingeventpatternconverter.cpp:<global>,,<global>,1
33317,NAMESPACE_BLOCK,<empty>,,main\cpp\loglog.cpp,main\cpp\loglog.cpp:<global>,,<global>,1
33802,NAMESPACE_BLOCK,<empty>,,main\cpp\logmanager.cpp,main\cpp\logmanager.cpp:<global>,,<global>,1
34083,NAMESPACE_BLOCK,<empty>,,main\cpp\logstream.cpp,main\cpp\logstream.cpp:<global>,,<global>,1
34756,NAMESPACE_BLOCK,<empty>,,main\cpp\manualtriggeringpolicy.cpp,main\cpp\manualtriggeringpolicy.cpp:<global>,,<global>,1
34800,NAMESPACE_BLOCK,<empty>,,main\cpp\mapfilter.cpp,main\cpp\mapfilter.cpp:<global>,,<global>,1
35209,NAMESPACE_BLOCK,<empty>,,main\cpp\mdc.cpp,main\cpp\mdc.cpp:<global>,,<global>,1
35476,NAMESPACE_BLOCK,<empty>,,main\cpp\mdcpatternconverter.cpp,main\cpp\mdcpatternconverter.cpp:<global>,,<global>,1
35678,NAMESPACE_BLOCK,<empty>,,main\cpp\messagebuffer.cpp,main\cpp\messagebuffer.cpp:<global>,,<global>,1
35682,NAMESPACE_BLOCK,"namespace {

template <typename T>
struct StringOrStream
{
	std::basic_string<T> buf;
	std::basic_ostringstream<T>* stream;

	StringOrStream()
		: stream(nullptr)
		{}
	~StringOrStream()
	{
#if !LOG4CXX_HAS_THREAD_LOCAL
		delete stream;
#endif
	}
	/**
	 * Move the character buffer from \c buf to \c stream
	 */
	std::basic_ostringstream<T>& StreamFromBuf()
	{
		if (!this->stream)
		{
#if LOG4CXX_HAS_THREAD_LOCAL
			const static std::basic_ostringstream<T> initialState;
			thread_local static std::basic_ostringstream<T> sStream;
			this->stream = &sStream;
			this->stream->clear();
			this->stream->precision(initialState.precision());
			this->stream->width(initialState.width());
			this->stream->setf(initialState.flags(), ~initialState.flags());
			this->stream->fill(initialState.fill());
#else
			this->stream = new std::basic_ostringstream<T>();
#endif
			auto index = this->buf.size();
			this->stream->str(std::move(this->buf));
			this->stream->seekp(index);
		}
		return *this->str...",1,main\cpp\messagebuffer.cpp,anonymous_namespace_0,32,,1
36159,NAMESPACE_BLOCK,<empty>,,main\cpp\messagepatternconverter.cpp,main\cpp\messagepatternconverter.cpp:<global>,,<global>,1
36165,NAMESPACE_BLOCK,"namespace {
/**
 * Formats the message of an logging event for a quoted context
  */
class QuotedMessagePatternConverter : public LoggingEventPatternConverter
{
	logchar m_quote;
	public:
		QuotedMessagePatternConverter(logchar quote)
			: LoggingEventPatternConverter(LOG4CXX_STR(""Message""), LOG4CXX_STR(""quoted""))
			, m_quote(quote)
			{}

		using LoggingEventPatternConverter::format;

		// Duplicate any quote character in the event message
		void format
			( const spi::LoggingEventPtr& event
			, LogString&                  toAppendTo
			, helpers::Pool&              p
			) const override
		{
			auto& input = event->getRenderedMessage();
			size_t endIndex, startIndex = 0;
			while ((endIndex = input.find(m_quote, startIndex)) != input.npos)
			{
				toAppendTo.append(input.substr(startIndex, endIndex - startIndex + 1));
				toAppendTo += m_quote;
				startIndex = endIndex + 1;
			}
			toAppendTo.append(input.substr(startIndex));
		}
};
}",1,main\cpp\messagepatternconverter.cpp,anonymous_namespace_0,29,,3
36307,NAMESPACE_BLOCK,<empty>,,main\cpp\methodlocationpatternconverter.cpp,main\cpp\methodlocationpatternconverter.cpp:<global>,,<global>,1
36382,NAMESPACE_BLOCK,<empty>,,main\cpp\multiprocessrollingfileappender.cpp,main\cpp\multiprocessrollingfileappender.cpp:<global>,,<global>,1
37981,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace rolling
{
/**
 * Wrapper for OutputStream that will report all write
 * operations back to this class for file length calculations.
 */
class CountingOutputStream : public OutputStream
{
		/**
		 * Wrapped output stream.
		 */
	private:
		OutputStreamPtr os;

		/**
		 * Rolling file appender to inform of stream writes.
		 */
		MultiprocessRollingFileAppender* rfa;

	public:
		/**
		 * Constructor.
		 * @param os output stream to wrap.
		 * @param rfa rolling file appender to inform.
		 */
		CountingOutputStream(
			OutputStreamPtr& os1, MultiprocessRollingFileAppender* rfa1) :
			os(os1), rfa(rfa1)
		{
		}

		/**
		 * {@inheritDoc}
		 */
		void close(Pool& p)
		{
			os->close(p);
			rfa = 0;
		}

		/**
		 * {@inheritDoc}
		 */
		void flush(Pool& p)
		{
			os->flush(p);
		}

		/**
		 * {@inheritDoc}
		 */
		void write(ByteBuffer& buf, Pool& p)
		{
			os->write(buf, p);

			if (rfa != 0)
			{
				rfa->setFileLength(File().setPath(rfa->getFile()).length...",1,main\cpp\multiprocessrollingfileappender.cpp,LOG4CXX_NS,588,LOG4CXX_NS,16
37982,NAMESPACE_BLOCK,"namespace rolling
{
/**
 * Wrapper for OutputStream that will report all write
 * operations back to this class for file length calculations.
 */
class CountingOutputStream : public OutputStream
{
		/**
		 * Wrapped output stream.
		 */
	private:
		OutputStreamPtr os;

		/**
		 * Rolling file appender to inform of stream writes.
		 */
		MultiprocessRollingFileAppender* rfa;

	public:
		/**
		 * Constructor.
		 * @param os output stream to wrap.
		 * @param rfa rolling file appender to inform.
		 */
		CountingOutputStream(
			OutputStreamPtr& os1, MultiprocessRollingFileAppender* rfa1) :
			os(os1), rfa(rfa1)
		{
		}

		/**
		 * {@inheritDoc}
		 */
		void close(Pool& p)
		{
			os->close(p);
			rfa = 0;
		}

		/**
		 * {@inheritDoc}
		 */
		void flush(Pool& p)
		{
			os->flush(p);
		}

		/**
		 * {@inheritDoc}
		 */
		void write(ByteBuffer& buf, Pool& p)
		{
			os->write(buf, p);

			if (rfa != 0)
			{
				rfa->setFileLength(File().setPath(rfa->getFile()).length(p));
			}
		}

		Outpu...",1,main\cpp\multiprocessrollingfileappender.cpp,LOG4CXX_NS.rolling,590,rolling,1
38139,NAMESPACE_BLOCK,<empty>,,main\cpp\nameabbreviator.cpp,main\cpp\nameabbreviator.cpp:<global>,,<global>,1
38153,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace pattern
{
/**
 * Abbreviator that simply appends full name to buffer.
 */
class NOPAbbreviator : public NameAbbreviator
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(NOPAbbreviator)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(NOPAbbreviator)
		LOG4CXX_CAST_ENTRY_CHAIN(NameAbbreviator)
		END_LOG4CXX_CAST_MAP()

		/**
		 * Constructor.
		 */
		NOPAbbreviator()
		{
		}

		/**
		 * {@inheritDoc}
		 */
		void abbreviate(LogString::size_type /* nameStart */, LogString& /* buf */) const override
		{
		}
};


/**
 * Abbreviator that drops starting path elements.
 */
class MaxElementAbbreviator : public NameAbbreviator
{
		/**
		 * Maximum number of path elements to output.
		 */
		const int count;

	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(MaxElementAbbreviator)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(MaxElementAbbreviator)
		LOG4CXX_CAST_ENTRY_CHAIN(NameAbbreviator)
		END_LOG4CXX_CAST_MAP()
		/**
		 * Create new instance.
		 * @param count maxim...",1,main\cpp\nameabbreviator.cpp,LOG4CXX_NS,38,LOG4CXX_NS,5
38154,NAMESPACE_BLOCK,"namespace pattern
{
/**
 * Abbreviator that simply appends full name to buffer.
 */
class NOPAbbreviator : public NameAbbreviator
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(NOPAbbreviator)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(NOPAbbreviator)
		LOG4CXX_CAST_ENTRY_CHAIN(NameAbbreviator)
		END_LOG4CXX_CAST_MAP()

		/**
		 * Constructor.
		 */
		NOPAbbreviator()
		{
		}

		/**
		 * {@inheritDoc}
		 */
		void abbreviate(LogString::size_type /* nameStart */, LogString& /* buf */) const override
		{
		}
};


/**
 * Abbreviator that drops starting path elements.
 */
class MaxElementAbbreviator : public NameAbbreviator
{
		/**
		 * Maximum number of path elements to output.
		 */
		const int count;

	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(MaxElementAbbreviator)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(MaxElementAbbreviator)
		LOG4CXX_CAST_ENTRY_CHAIN(NameAbbreviator)
		END_LOG4CXX_CAST_MAP()
		/**
		 * Create new instance.
		 * @param count maximum number of path eleme...",1,main\cpp\nameabbreviator.cpp,LOG4CXX_NS.pattern,40,pattern,1
38650,NAMESPACE_BLOCK,<empty>,,main\cpp\namepatternconverter.cpp,main\cpp\namepatternconverter.cpp:<global>,,<global>,1
38726,NAMESPACE_BLOCK,<empty>,,main\cpp\ndc.cpp,main\cpp\ndc.cpp:<global>,,<global>,1
39220,NAMESPACE_BLOCK,<empty>,,main\cpp\ndcpatternconverter.cpp,main\cpp\ndcpatternconverter.cpp:<global>,,<global>,1
39286,NAMESPACE_BLOCK,<empty>,,main\cpp\nteventlogappender.cpp,main\cpp\nteventlogappender.cpp:<global>,,<global>,1
39349,NAMESPACE_BLOCK,<empty>,,main\cpp\odbcappender.cpp,main\cpp\odbcappender.cpp:<global>,,<global>,1
40270,NAMESPACE_BLOCK,<empty>,,main\cpp\onlyonceerrorhandler.cpp,main\cpp\onlyonceerrorhandler.cpp:<global>,,<global>,1
40422,NAMESPACE_BLOCK,<empty>,,main\cpp\optionconverter.cpp,main\cpp\optionconverter.cpp:<global>,,<global>,1
40426,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{

class ConfiguratorWatchdog  : public helpers::FileWatchdog
{
	spi::ConfiguratorPtr m_config;
	public:
    ConfiguratorWatchdog(const spi::ConfiguratorPtr& config, const File& filename)
        : helpers::FileWatchdog(filename)
        , m_config(config)
    {
    }

    /**
    Call PropertyConfigurator#doConfigure(const String& configFileName,
    const spi::LoggerRepositoryPtr& hierarchy) with the
    <code>filename</code> to reconfigure log4cxx.
    */
    void doOnChange() override
    {
        m_config->doConfigure(file(), LogManager::getLoggerRepository());
    }
};

}",1,main\cpp\optionconverter.cpp,LOG4CXX_NS,46,LOG4CXX_NS,1
41405,NAMESPACE_BLOCK,<empty>,,main\cpp\outputdebugstringappender.cpp,main\cpp\outputdebugstringappender.cpp:<global>,,<global>,1
41416,NAMESPACE_BLOCK,<empty>,,main\cpp\outputstream.cpp,main\cpp\outputstream.cpp:<global>,,<global>,1
41443,NAMESPACE_BLOCK,<empty>,,main\cpp\outputstreamwriter.cpp,main\cpp\outputstreamwriter.cpp:<global>,,<global>,1
41683,NAMESPACE_BLOCK,<empty>,,main\cpp\patternconverter.cpp,main\cpp\patternconverter.cpp:<global>,,<global>,1
41800,NAMESPACE_BLOCK,<empty>,,main\cpp\patternlayout.cpp,main\cpp\patternlayout.cpp:<global>,,<global>,1
42883,NAMESPACE_BLOCK,<empty>,,main\cpp\patternparser.cpp,main\cpp\patternparser.cpp:<global>,,<global>,1
43868,NAMESPACE_BLOCK,<empty>,,main\cpp\pool.cpp,main\cpp\pool.cpp:<global>,,<global>,1
44015,NAMESPACE_BLOCK,<empty>,,main\cpp\properties.cpp,main\cpp\properties.cpp:<global>,,<global>,1
44814,NAMESPACE_BLOCK,<empty>,,main\cpp\propertiespatternconverter.cpp,main\cpp\propertiespatternconverter.cpp:<global>,,<global>,1
45062,NAMESPACE_BLOCK,<empty>,,main\cpp\propertyconfigurator.cpp,main\cpp\propertyconfigurator.cpp:<global>,,<global>,1
45066,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
class PropertyWatchdog  : public FileWatchdog
{
	public:
		PropertyWatchdog(const File& filename) : FileWatchdog(filename)
		{
		}

		/**
		Call PropertyConfigurator#doConfigure(const String& configFileName,
		const spi::LoggerRepositoryPtr& hierarchy) with the
		<code>filename</code> to reconfigure log4cxx.
		*/
		void doOnChange()
		{
			PropertyConfigurator().doConfigure(file(),
				LogManager::getLoggerRepository());
		}
};
}",1,main\cpp\propertyconfigurator.cpp,LOG4CXX_NS,51,LOG4CXX_NS,1
46596,NAMESPACE_BLOCK,<empty>,,main\cpp\propertyresourcebundle.cpp,main\cpp\propertyresourcebundle.cpp:<global>,,<global>,1
46680,NAMESPACE_BLOCK,<empty>,,main\cpp\propertysetter.cpp,main\cpp\propertysetter.cpp:<global>,,<global>,1
46919,NAMESPACE_BLOCK,<empty>,,main\cpp\reader.cpp,main\cpp\reader.cpp:<global>,,<global>,1
46942,NAMESPACE_BLOCK,<empty>,,main\cpp\relativetimedateformat.cpp,main\cpp\relativetimedateformat.cpp:<global>,,<global>,1
46984,NAMESPACE_BLOCK,<empty>,,main\cpp\relativetimepatternconverter.cpp,main\cpp\relativetimepatternconverter.cpp:<global>,,<global>,1
47051,NAMESPACE_BLOCK,<empty>,,main\cpp\resourcebundle.cpp,main\cpp\resourcebundle.cpp:<global>,,<global>,1
47323,NAMESPACE_BLOCK,<empty>,,main\cpp\rollingfileappender.cpp,main\cpp\rollingfileappender.cpp:<global>,,<global>,1
48767,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace rolling
{
/**
 * Wrapper for OutputStream that will report all write
 * operations back to this class for file length calculations.
 */
class CountingOutputStream : public OutputStream
{
		/**
		 * Wrapped output stream.
		 */
	private:
		OutputStreamPtr os;

		/**
		 * Rolling file appender to inform of stream writes.
		 */
		RollingFileAppender* rfa;

	public:
		/**
		 * Constructor.
		 * @param os output stream to wrap.
		 * @param rfa rolling file appender to inform.
		 */
		CountingOutputStream(
			OutputStreamPtr& os1, RollingFileAppender* rfa1) :
			os(os1), rfa(rfa1)
		{
		}

		/**
		 * {@inheritDoc}
		 */
		void close(Pool& p)
		{
			os->close(p);
			rfa = 0;
		}

		/**
		 * {@inheritDoc}
		 */
		void flush(Pool& p)
		{
			os->flush(p);
		}

		/**
		 * {@inheritDoc}
		 */
		void write(ByteBuffer& buf, Pool& p)
		{
			os->write(buf, p);

			if (rfa != 0)
			{
				rfa->incrementFileLength(buf.limit());
			}
		}
};
}
}",1,main\cpp\rollingfileappender.cpp,LOG4CXX_NS,524,LOG4CXX_NS,22
48768,NAMESPACE_BLOCK,"namespace rolling
{
/**
 * Wrapper for OutputStream that will report all write
 * operations back to this class for file length calculations.
 */
class CountingOutputStream : public OutputStream
{
		/**
		 * Wrapped output stream.
		 */
	private:
		OutputStreamPtr os;

		/**
		 * Rolling file appender to inform of stream writes.
		 */
		RollingFileAppender* rfa;

	public:
		/**
		 * Constructor.
		 * @param os output stream to wrap.
		 * @param rfa rolling file appender to inform.
		 */
		CountingOutputStream(
			OutputStreamPtr& os1, RollingFileAppender* rfa1) :
			os(os1), rfa(rfa1)
		{
		}

		/**
		 * {@inheritDoc}
		 */
		void close(Pool& p)
		{
			os->close(p);
			rfa = 0;
		}

		/**
		 * {@inheritDoc}
		 */
		void flush(Pool& p)
		{
			os->flush(p);
		}

		/**
		 * {@inheritDoc}
		 */
		void write(ByteBuffer& buf, Pool& p)
		{
			os->write(buf, p);

			if (rfa != 0)
			{
				rfa->incrementFileLength(buf.limit());
			}
		}
};
}",1,main\cpp\rollingfileappender.cpp,LOG4CXX_NS.rolling,526,rolling,1
48885,NAMESPACE_BLOCK,<empty>,,main\cpp\rollingpolicy.cpp,main\cpp\rollingpolicy.cpp:<global>,,<global>,1
48913,NAMESPACE_BLOCK,<empty>,,main\cpp\rollingpolicybase.cpp,main\cpp\rollingpolicybase.cpp:<global>,,<global>,1
49287,NAMESPACE_BLOCK,<empty>,,main\cpp\rolloverdescription.cpp,main\cpp\rolloverdescription.cpp:<global>,,<global>,1
49369,NAMESPACE_BLOCK,<empty>,,main\cpp\rootlogger.cpp,main\cpp\rootlogger.cpp:<global>,,<global>,1
49417,NAMESPACE_BLOCK,<empty>,,main\cpp\serversocket.cpp,main\cpp\serversocket.cpp:<global>,,<global>,1
49475,NAMESPACE_BLOCK,<empty>,,main\cpp\shortfilelocationpatternconverter.cpp,main\cpp\shortfilelocationpatternconverter.cpp:<global>,,<global>,1
49535,NAMESPACE_BLOCK,<empty>,,main\cpp\simpledateformat.cpp,main\cpp\simpledateformat.cpp:<global>,,<global>,1
49539,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{
namespace SimpleDateFormatImpl
{
typedef void (*incrementFunction)(tm& time, apr_time_exp_t& apr_time);

/**
 * Abstract inner class representing one format token
 * (one or more instances of a character).
 */
class PatternToken
{
	public:
		PatternToken()
		{
		}

		virtual ~PatternToken()
		{
		}

		/**
		 * Sets the time zone.
		 * @param zone new time zone.
		 */
		virtual void setTimeZone(const TimeZonePtr& zone)
		{
		}

		/**
		 * Appends the formatted content to the string.
		 * @param s string to which format contribution is appended.
		 * @param date exploded date/time.
		 * @param p memory pool.
		 */
		virtual void format(LogString& s,
			const apr_time_exp_t& date,
			LOG4CXX_NS::helpers::Pool& p) const = 0;

	protected:

		static void incrementMonth(tm& time, apr_time_exp_t& aprtime)
		{
			time.tm_mon++;
			aprtime.tm_mon++;
		}

		static void incrementDay(tm& time, apr_time_exp_t& aprtime)
		{
			time.tm_wday++;
			aprtime.t...",1,main\cpp\simpledateformat.cpp,LOG4CXX_NS,56,LOG4CXX_NS,1
49540,NAMESPACE_BLOCK,"namespace helpers
{
namespace SimpleDateFormatImpl
{
typedef void (*incrementFunction)(tm& time, apr_time_exp_t& apr_time);

/**
 * Abstract inner class representing one format token
 * (one or more instances of a character).
 */
class PatternToken
{
	public:
		PatternToken()
		{
		}

		virtual ~PatternToken()
		{
		}

		/**
		 * Sets the time zone.
		 * @param zone new time zone.
		 */
		virtual void setTimeZone(const TimeZonePtr& zone)
		{
		}

		/**
		 * Appends the formatted content to the string.
		 * @param s string to which format contribution is appended.
		 * @param date exploded date/time.
		 * @param p memory pool.
		 */
		virtual void format(LogString& s,
			const apr_time_exp_t& date,
			LOG4CXX_NS::helpers::Pool& p) const = 0;

	protected:

		static void incrementMonth(tm& time, apr_time_exp_t& aprtime)
		{
			time.tm_mon++;
			aprtime.tm_mon++;
		}

		static void incrementDay(tm& time, apr_time_exp_t& aprtime)
		{
			time.tm_wday++;
			aprtime.tm_wday++;
		}

		static...",1,main\cpp\simpledateformat.cpp,LOG4CXX_NS.helpers,58,helpers,1
49541,NAMESPACE_BLOCK,"namespace SimpleDateFormatImpl
{
typedef void (*incrementFunction)(tm& time, apr_time_exp_t& apr_time);

/**
 * Abstract inner class representing one format token
 * (one or more instances of a character).
 */
class PatternToken
{
	public:
		PatternToken()
		{
		}

		virtual ~PatternToken()
		{
		}

		/**
		 * Sets the time zone.
		 * @param zone new time zone.
		 */
		virtual void setTimeZone(const TimeZonePtr& zone)
		{
		}

		/**
		 * Appends the formatted content to the string.
		 * @param s string to which format contribution is appended.
		 * @param date exploded date/time.
		 * @param p memory pool.
		 */
		virtual void format(LogString& s,
			const apr_time_exp_t& date,
			LOG4CXX_NS::helpers::Pool& p) const = 0;

	protected:

		static void incrementMonth(tm& time, apr_time_exp_t& aprtime)
		{
			time.tm_mon++;
			aprtime.tm_mon++;
		}

		static void incrementDay(tm& time, apr_time_exp_t& aprtime)
		{
			time.tm_wday++;
			aprtime.tm_wday++;
		}

		static void incrementHalfD...",1,main\cpp\simpledateformat.cpp,LOG4CXX_NS.helpers.SimpleDateFormatImpl,60,SimpleDateFormatImpl,1
50894,NAMESPACE_BLOCK,<empty>,,main\cpp\simplelayout.cpp,main\cpp\simplelayout.cpp:<global>,,<global>,1
50944,NAMESPACE_BLOCK,<empty>,,main\cpp\sizebasedtriggeringpolicy.cpp,main\cpp\sizebasedtriggeringpolicy.cpp:<global>,,<global>,1
51047,NAMESPACE_BLOCK,<empty>,,main\cpp\smtpappender.cpp,main\cpp\smtpappender.cpp:<global>,,<global>,1
51051,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace net
{
//
//   The following two classes implement an C++ SMTP wrapper over libesmtp.
//   The same signatures could be implemented over different SMTP implementations
//   or libesmtp could be combined with libgmime to enable support for non-ASCII
//   content.

#if LOG4CXX_HAVE_LIBESMTP
/**
 *   SMTP Session.
 */
class SMTPSession
{
	public:
		/**
		*   Create new instance.
		*/
		SMTPSession(const LogString& smtpHost,
			int smtpPort,
			const LogString& smtpUsername,
			const LogString& smtpPassword,
			Pool& p) : session(0), authctx(0),
			user(toAscii(smtpUsername, p)),
			pwd(toAscii(smtpPassword, p))
		{
			auth_client_init();
			session = smtp_create_session();

			if (session == 0)
			{
				throw Exception(""Could not initialize session."");
			}

			std::string host(toAscii(smtpHost, p));
			host.append(1, ':');
			host.append(p.itoa(smtpPort));
			smtp_set_server(session, host.c_str());

			authctx = auth_create_context();
			auth_set_mechan...",1,main\cpp\smtpappender.cpp,LOG4CXX_NS,47,LOG4CXX_NS,1
51052,NAMESPACE_BLOCK,"namespace net
{
//
//   The following two classes implement an C++ SMTP wrapper over libesmtp.
//   The same signatures could be implemented over different SMTP implementations
//   or libesmtp could be combined with libgmime to enable support for non-ASCII
//   content.

#if LOG4CXX_HAVE_LIBESMTP
/**
 *   SMTP Session.
 */
class SMTPSession
{
	public:
		/**
		*   Create new instance.
		*/
		SMTPSession(const LogString& smtpHost,
			int smtpPort,
			const LogString& smtpUsername,
			const LogString& smtpPassword,
			Pool& p) : session(0), authctx(0),
			user(toAscii(smtpUsername, p)),
			pwd(toAscii(smtpPassword, p))
		{
			auth_client_init();
			session = smtp_create_session();

			if (session == 0)
			{
				throw Exception(""Could not initialize session."");
			}

			std::string host(toAscii(smtpHost, p));
			host.append(1, ':');
			host.append(p.itoa(smtpPort));
			smtp_set_server(session, host.c_str());

			authctx = auth_create_context();
			auth_set_mechanism_flags(authctx, AUTH...",1,main\cpp\smtpappender.cpp,LOG4CXX_NS.net,49,net,1
52225,NAMESPACE_BLOCK,<empty>,,main\cpp\socket.cpp,main\cpp\socket.cpp:<global>,,<global>,1
52298,NAMESPACE_BLOCK,<empty>,,main\cpp\socketappenderskeleton.cpp,main\cpp\socketappenderskeleton.cpp:<global>,,<global>,1
53277,NAMESPACE_BLOCK,<empty>,,main\cpp\socketoutputstream.cpp,main\cpp\socketoutputstream.cpp:<global>,,<global>,1
53425,NAMESPACE_BLOCK,<empty>,,main\cpp\strftimedateformat.cpp,main\cpp\strftimedateformat.cpp:<global>,,<global>,1
53550,NAMESPACE_BLOCK,<empty>,,main\cpp\stringhelper.cpp,main\cpp\stringhelper.cpp:<global>,,<global>,1
54031,NAMESPACE_BLOCK,<empty>,,main\cpp\stringmatchfilter.cpp,main\cpp\stringmatchfilter.cpp:<global>,,<global>,1
54279,NAMESPACE_BLOCK,<empty>,,main\cpp\stringtokenizer.cpp,main\cpp\stringtokenizer.cpp:<global>,,<global>,1
54434,NAMESPACE_BLOCK,<empty>,,main\cpp\syslogappender.cpp,main\cpp\syslogappender.cpp:<global>,,<global>,1
55723,NAMESPACE_BLOCK,<empty>,,main\cpp\syslogwriter.cpp,main\cpp\syslogwriter.cpp:<global>,,<global>,1
55871,NAMESPACE_BLOCK,<empty>,,main\cpp\system.cpp,main\cpp\system.cpp:<global>,,<global>,1
56008,NAMESPACE_BLOCK,<empty>,,main\cpp\systemerrwriter.cpp,main\cpp\systemerrwriter.cpp:<global>,,<global>,1
56077,NAMESPACE_BLOCK,<empty>,,main\cpp\systemoutwriter.cpp,main\cpp\systemoutwriter.cpp:<global>,,<global>,1
56154,NAMESPACE_BLOCK,<empty>,,main\cpp\telnetappender.cpp,main\cpp\telnetappender.cpp:<global>,,<global>,1
57187,NAMESPACE_BLOCK,<empty>,,main\cpp\threadlocal.cpp,main\cpp\threadlocal.cpp:<global>,,<global>,1
57234,NAMESPACE_BLOCK,<empty>,,main\cpp\threadpatternconverter.cpp,main\cpp\threadpatternconverter.cpp:<global>,,<global>,1
57284,NAMESPACE_BLOCK,<empty>,,main\cpp\threadspecificdata.cpp,main\cpp\threadspecificdata.cpp:<global>,,<global>,1
57485,NAMESPACE_BLOCK,<empty>,,main\cpp\threadusernamepatternconverter.cpp,main\cpp\threadusernamepatternconverter.cpp:<global>,,<global>,1
57541,NAMESPACE_BLOCK,<empty>,,main\cpp\threadutility.cpp,main\cpp\threadutility.cpp:<global>,,<global>,1
57545,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{

struct ThreadUtility::priv_data
{
	priv_data()
	{
		start_pre = nullptr;
		started = nullptr;
		start_post = nullptr;
	}

	ThreadStartPre start_pre;
	ThreadStarted started;
	ThreadStartPost start_post;
};

#if LOG4CXX_HAS_PTHREAD_SIGMASK
	static thread_local sigset_t old_mask;
	static thread_local bool sigmask_valid;
#endif

ThreadUtility::ThreadUtility() :
	m_priv( new priv_data() )
{
	// Block signals by default.
	configureFuncs( std::bind( &ThreadUtility::preThreadBlockSignals, this ),
		nullptr,
		std::bind( &ThreadUtility::postThreadUnblockSignals, this ) );
}

ThreadUtility::~ThreadUtility() {}

ThreadUtility* ThreadUtility::instance()
{
	static WideLife<ThreadUtility> instance;
	return &instance.value();
}

void ThreadUtility::configure( ThreadConfigurationType type )
{
	auto utility = instance();

	if ( type == ThreadConfigurationType::NoConfiguration )
	{
		utility->configureFuncs( nullptr, nullptr, nullptr );
	}
	else if ( type =...",1,main\cpp\threadutility.cpp,LOG4CXX_NS,34,LOG4CXX_NS,1
57546,NAMESPACE_BLOCK,"namespace helpers
{

struct ThreadUtility::priv_data
{
	priv_data()
	{
		start_pre = nullptr;
		started = nullptr;
		start_post = nullptr;
	}

	ThreadStartPre start_pre;
	ThreadStarted started;
	ThreadStartPost start_post;
};

#if LOG4CXX_HAS_PTHREAD_SIGMASK
	static thread_local sigset_t old_mask;
	static thread_local bool sigmask_valid;
#endif

ThreadUtility::ThreadUtility() :
	m_priv( new priv_data() )
{
	// Block signals by default.
	configureFuncs( std::bind( &ThreadUtility::preThreadBlockSignals, this ),
		nullptr,
		std::bind( &ThreadUtility::postThreadUnblockSignals, this ) );
}

ThreadUtility::~ThreadUtility() {}

ThreadUtility* ThreadUtility::instance()
{
	static WideLife<ThreadUtility> instance;
	return &instance.value();
}

void ThreadUtility::configure( ThreadConfigurationType type )
{
	auto utility = instance();

	if ( type == ThreadConfigurationType::NoConfiguration )
	{
		utility->configureFuncs( nullptr, nullptr, nullptr );
	}
	else if ( type == ThreadConfigurationTy...",1,main\cpp\threadutility.cpp,LOG4CXX_NS.helpers,36,helpers,1
57826,NAMESPACE_BLOCK,<empty>,,main\cpp\throwableinformationpatternconverter.cpp,main\cpp\throwableinformationpatternconverter.cpp:<global>,,<global>,1
57940,NAMESPACE_BLOCK,<empty>,,main\cpp\timebasedrollingpolicy.cpp,main\cpp\timebasedrollingpolicy.cpp:<global>,,<global>,1
58654,NAMESPACE_BLOCK,<empty>,,main\cpp\timezone.cpp,main\cpp\timezone.cpp:<global>,,<global>,1
58660,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{
namespace TimeZoneImpl
{
/** Time zone object that represents GMT. */
class GMTTimeZone : public TimeZone
{
	public:
		/** Class factory. */
		static const TimeZonePtr& getInstance()
		{
			static WideLife<TimeZonePtr> tz = std::make_shared<GMTTimeZone>();
			return tz;
		}

		/** Explode time to human readable form. */
		log4cxx_status_t explode( apr_time_exp_t* result, log4cxx_time_t input ) const
		{
			apr_status_t stat;

			//  APR 1.1 and early mishandles microseconds on dates
			//   before 1970, APR bug 32520
			if (LOG4CXX_UNLIKELY(input < 0 && apr_time_usec(input) < 0))
			{
				apr_time_t floorTime = (apr_time_sec(input) - 1) * APR_USEC_PER_SEC;
				stat = apr_time_exp_gmt(result, floorTime);
				result->tm_usec = (int) (input - floorTime);
			}
			else
			{
				stat = apr_time_exp_gmt( result, input );
			}

			return stat;
		}

		GMTTimeZone() : TimeZone( LOG4CXX_STR(""GMT"") )
		{
		}
};



/** Time zone object that represents G...",1,main\cpp\timezone.cpp,LOG4CXX_NS,36,LOG4CXX_NS,3
58661,NAMESPACE_BLOCK,"namespace helpers
{
namespace TimeZoneImpl
{
/** Time zone object that represents GMT. */
class GMTTimeZone : public TimeZone
{
	public:
		/** Class factory. */
		static const TimeZonePtr& getInstance()
		{
			static WideLife<TimeZonePtr> tz = std::make_shared<GMTTimeZone>();
			return tz;
		}

		/** Explode time to human readable form. */
		log4cxx_status_t explode( apr_time_exp_t* result, log4cxx_time_t input ) const
		{
			apr_status_t stat;

			//  APR 1.1 and early mishandles microseconds on dates
			//   before 1970, APR bug 32520
			if (LOG4CXX_UNLIKELY(input < 0 && apr_time_usec(input) < 0))
			{
				apr_time_t floorTime = (apr_time_sec(input) - 1) * APR_USEC_PER_SEC;
				stat = apr_time_exp_gmt(result, floorTime);
				result->tm_usec = (int) (input - floorTime);
			}
			else
			{
				stat = apr_time_exp_gmt( result, input );
			}

			return stat;
		}

		GMTTimeZone() : TimeZone( LOG4CXX_STR(""GMT"") )
		{
		}
};



/** Time zone object that represents GMT. */
class LocalTimeZ...",1,main\cpp\timezone.cpp,LOG4CXX_NS.helpers,38,helpers,1
58662,NAMESPACE_BLOCK,"namespace TimeZoneImpl
{
/** Time zone object that represents GMT. */
class GMTTimeZone : public TimeZone
{
	public:
		/** Class factory. */
		static const TimeZonePtr& getInstance()
		{
			static WideLife<TimeZonePtr> tz = std::make_shared<GMTTimeZone>();
			return tz;
		}

		/** Explode time to human readable form. */
		log4cxx_status_t explode( apr_time_exp_t* result, log4cxx_time_t input ) const
		{
			apr_status_t stat;

			//  APR 1.1 and early mishandles microseconds on dates
			//   before 1970, APR bug 32520
			if (LOG4CXX_UNLIKELY(input < 0 && apr_time_usec(input) < 0))
			{
				apr_time_t floorTime = (apr_time_sec(input) - 1) * APR_USEC_PER_SEC;
				stat = apr_time_exp_gmt(result, floorTime);
				result->tm_usec = (int) (input - floorTime);
			}
			else
			{
				stat = apr_time_exp_gmt( result, input );
			}

			return stat;
		}

		GMTTimeZone() : TimeZone( LOG4CXX_STR(""GMT"") )
		{
		}
};



/** Time zone object that represents GMT. */
class LocalTimeZone : public TimeZon...",1,main\cpp\timezone.cpp,LOG4CXX_NS.helpers.TimeZoneImpl,40,TimeZoneImpl,1
59285,NAMESPACE_BLOCK,<empty>,,main\cpp\transcoder.cpp,main\cpp\transcoder.cpp:<global>,,<global>,1
60722,NAMESPACE_BLOCK,<empty>,,main\cpp\transform.cpp,main\cpp\transform.cpp:<global>,,<global>,1
60995,NAMESPACE_BLOCK,<empty>,,main\cpp\triggeringpolicy.cpp,main\cpp\triggeringpolicy.cpp:<global>,,<global>,1
61014,NAMESPACE_BLOCK,<empty>,,main\cpp\writer.cpp,main\cpp\writer.cpp:<global>,,<global>,1
61043,NAMESPACE_BLOCK,<empty>,,main\cpp\writerappender.cpp,main\cpp\writerappender.cpp:<global>,,<global>,1
61924,NAMESPACE_BLOCK,<empty>,,main\cpp\xmllayout.cpp,main\cpp\xmllayout.cpp:<global>,,<global>,1
62520,NAMESPACE_BLOCK,<empty>,,main\cpp\xmlsocketappender.cpp,main\cpp\xmlsocketappender.cpp:<global>,,<global>,1
62859,NAMESPACE_BLOCK,<empty>,,main\cpp\zipcompressaction.cpp,main\cpp\zipcompressaction.cpp:<global>,,<global>,1
63229,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx-qt\configuration.hpp,main\include\log4cxx-qt\configuration.hpp:<global>,,<global>,1
63233,NAMESPACE_BLOCK,"namespace LOG4CXX_NS {
namespace qt {

class LOG4CXX_EXPORT Configuration {
private:
	Configuration();

	static LOG4CXX_NS::spi::ConfigurationStatus tryLoadFile(const QString& filename);

public:
	/**
	 * Configure Log4cxx and watch the file for changes.  See also DefaultConfigurator::configureFromFile.
	 *
	 * @param directories
	 * @param filenames
	 * @return
	 */
	static std::tuple<LOG4CXX_NS::spi::ConfigurationStatus,QString> configureFromFileAndWatch(const QVector<QString>& directories,
																						   const QVector<QString>& filenames);
};

} /* namespace qt */
}",1,main\include\log4cxx-qt\configuration.hpp,LOG4CXX_NS,25,LOG4CXX_NS,1
63234,NAMESPACE_BLOCK,"namespace qt {

class LOG4CXX_EXPORT Configuration {
private:
	Configuration();

	static LOG4CXX_NS::spi::ConfigurationStatus tryLoadFile(const QString& filename);

public:
	/**
	 * Configure Log4cxx and watch the file for changes.  See also DefaultConfigurator::configureFromFile.
	 *
	 * @param directories
	 * @param filenames
	 * @return
	 */
	static std::tuple<LOG4CXX_NS::spi::ConfigurationStatus,QString> configureFromFileAndWatch(const QVector<QString>& directories,
																						   const QVector<QString>& filenames);
};

}",1,main\include\log4cxx-qt\configuration.hpp,LOG4CXX_NS.qt,26,qt,1
63241,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx-qt\logger.hpp,main\include\log4cxx-qt\logger.hpp:<global>,,<global>,1
63248,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx-qt\messagebuffer.hpp,main\include\log4cxx-qt\messagebuffer.hpp:<global>,,<global>,1
63270,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx-qt\messagehandler.hpp,main\include\log4cxx-qt\messagehandler.hpp:<global>,,<global>,1
63274,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace qt
{

/**
 * The messageHandler function is a log4cxx replacement of the standard
 * Qt message handler.
 *
 * Use this function as follows:
 *   qInstallMessageHandler( log4cxx::qt::messageHandler );
 *
 * Note that similar to Qt, upon receipt of a fatal message this calls
 * std::abort().
 */
LOG4CXX_EXPORT
void messageHandler(QtMsgType type, const QMessageLogContext& context, const QString& message);

} /* namespace qt */
}",1,main\include\log4cxx-qt\messagehandler.hpp,LOG4CXX_NS,24,LOG4CXX_NS,1
63275,NAMESPACE_BLOCK,"namespace qt
{

/**
 * The messageHandler function is a log4cxx replacement of the standard
 * Qt message handler.
 *
 * Use this function as follows:
 *   qInstallMessageHandler( log4cxx::qt::messageHandler );
 *
 * Note that similar to Qt, upon receipt of a fatal message this calls
 * std::abort().
 */
LOG4CXX_EXPORT
void messageHandler(QtMsgType type, const QMessageLogContext& context, const QString& message);

}",1,main\include\log4cxx-qt\messagehandler.hpp,LOG4CXX_NS.qt,26,qt,1
63289,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx-qt\transcoder.hpp,main\include\log4cxx-qt\transcoder.hpp:<global>,,<global>,1
63300,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\appender.hpp,main\include\log4cxx\appender.hpp:<global>,,<global>,1
63304,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
// Forward declarations
namespace spi
{
class LoggingEvent;
typedef std::shared_ptr<LoggingEvent> LoggingEventPtr;

class Filter;
typedef std::shared_ptr<Filter> FilterPtr;

class ErrorHandler;
typedef std::shared_ptr<ErrorHandler> ErrorHandlerPtr;
}

class Layout;
typedef std::shared_ptr<Layout> LayoutPtr;


/**
Implement this interface for your own strategies for outputting log
statements.
*/
class LOG4CXX_EXPORT Appender :
	public virtual spi::OptionHandler
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(Appender)

		virtual ~Appender() {}

		/**
		 Add a filter to the end of the filter list.
		*/
		virtual void addFilter(const spi::FilterPtr newFilter) = 0;

		/**
		 Returns the head Filter. The Filters are organized in a linked list
		 and so all Filters on this Appender are available through the result.

		 @return the head Filter or null, if no Filters are present
		 */
		virtual spi::FilterPtr getFilter() const = 0;

		/**
		 Clear the list of filters by ...",1,main\include\log4cxx\appender.hpp,LOG4CXX_NS,26,LOG4CXX_NS,1
63305,NAMESPACE_BLOCK,"namespace spi
{
class LoggingEvent;
typedef std::shared_ptr<LoggingEvent> LoggingEventPtr;

class Filter;
typedef std::shared_ptr<Filter> FilterPtr;

class ErrorHandler;
typedef std::shared_ptr<ErrorHandler> ErrorHandlerPtr;
}",1,main\include\log4cxx\appender.hpp,LOG4CXX_NS.spi,29,spi,1
63332,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\appenderskeleton.hpp,main\include\log4cxx\appenderskeleton.hpp:<global>,,<global>,1
63336,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{

/**
*  Implementation base class for all appenders.
*
*  This class provides the code for common functionality, such as
*  support for threshold filtering and support for general filters.
* */
class LOG4CXX_EXPORT AppenderSkeleton :
	public virtual Appender,
	public virtual helpers::Object
{
	protected:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(AppenderSkeletonPrivate, m_priv)
		AppenderSkeleton(LOG4CXX_PRIVATE_PTR(AppenderSkeletonPrivate) priv);

		/**
		Subclasses of <code>AppenderSkeleton</code> should implement this
		method to perform actual logging. See also AppenderSkeleton::doAppend
		method.
		*/
		virtual void append(const spi::LoggingEventPtr& event, LOG4CXX_NS::helpers::Pool& p) = 0;

		void doAppendImpl(const spi::LoggingEventPtr& event, LOG4CXX_NS::helpers::Pool& pool);

	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(AppenderSkeleton)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(AppenderSkeleton)
		LOG4CXX_CAST_ENTRY(Appender)
		LOG4CXX_CAST_ENTRY(spi...",1,main\include\log4cxx\appenderskeleton.hpp,LOG4CXX_NS,29,LOG4CXX_NS,1
63345,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\asyncappender.hpp,main\include\log4cxx\asyncappender.hpp:<global>,,<global>,1
63349,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
LOG4CXX_LIST_DEF(LoggingEventList, spi::LoggingEventPtr);

/**
The AsyncAppender lets users log events asynchronously. It uses a
bounded buffer to store logging events.

<p>The AsyncAppender will collect the events sent to it and then
dispatch them to all the appenders that are attached to it. You can
attach multiple appenders to an AsyncAppender.

<p>The AsyncAppender uses a separate thread to serve the events in
its bounded buffer.

<p><b>Important note:</b> The <code>AsyncAppender</code> can only
be script configured using the {@link xml::DOMConfigurator DOMConfigurator}.
*/
class LOG4CXX_EXPORT AsyncAppender :
	public virtual spi::AppenderAttachable,
	public virtual AppenderSkeleton
{
	protected:
		struct AsyncAppenderPriv;

	public:
		DECLARE_LOG4CXX_OBJECT(AsyncAppender)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(AsyncAppender)
		LOG4CXX_CAST_ENTRY_CHAIN(AppenderSkeleton)
		LOG4CXX_CAST_ENTRY(spi::AppenderAttachable)
		END_LOG4CXX_CAST_MAP()

		/**
...",1,main\include\log4cxx\asyncappender.hpp,LOG4CXX_NS,25,LOG4CXX_NS,1
63362,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\basicconfigurator.hpp,main\include\log4cxx\basicconfigurator.hpp:<global>,,<global>,1
63366,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
class Appender;
typedef std::shared_ptr<Appender> AppenderPtr;

/**
Use BasicConfigurator (static) methods to configure Log4cxx
when not using a configuration file.

For <code>key=value</code> format configuration see PropertyConfigurator.
For XML format configuration see xml::DOMConfigurator.
*/
class LOG4CXX_EXPORT BasicConfigurator
{
	protected:
		BasicConfigurator() {}

	public:
		/**
		Add a ConsoleAppender to the root logger that formats output using \c layout.

		If \c layout is not provided,
		use a PatternLayout with <code>%%r [%%t] %%p %%c %%x - %%m%%n</code>
		as the conversion pattern.
		*/
		static void configure(const LayoutPtr& layout = LayoutPtr());

		/**
		Add <code>appender</code> to the root logger.
		@param appender The appender to add to the root logger.
		*/
		static void configure(const AppenderPtr& appender);

		/**
		Reset the default hierarchy to its defaut. It is equivalent to
		calling
		<code>Logger::getDefaultHierarchy()->resetCo...",1,main\include\log4cxx\basicconfigurator.hpp,LOG4CXX_NS,26,LOG4CXX_NS,1
63375,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\config\propertysetter.hpp,main\include\log4cxx\config\propertysetter.hpp:<global>,,<global>,1
63379,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{
class Object;
LOG4CXX_PTR_DEF(Object);
}
}",1,main\include\log4cxx\config\propertysetter.hpp,LOG4CXX_NS,24,LOG4CXX_NS,1
63380,NAMESPACE_BLOCK,"namespace helpers
{
class Object;
LOG4CXX_PTR_DEF(Object);
}",1,main\include\log4cxx\config\propertysetter.hpp,LOG4CXX_NS.helpers,26,helpers,1
63384,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{
class Properties;
class Pool;
}

namespace config
{
/**
General purpose Object property setter. Clients repeatedly invokes
{@link #setProperty setProperty(name,value)} in order to invoke setters
on the Object specified in the constructor.

<p>Usage:
<pre>
PropertySetter ps(anObject);
ps.set(""name"", ""Joe"");
ps.set(""age"", ""32"");
ps.set(""isMale"", ""true"");
</pre>
will cause the invocations anObject->setOption(""name"", ""Joe""),
anObject->setOption(""age"", ""32"") and anObject->setOption(""isMale"", ""true"")
if the spi::OptionHandler interface is supported by anObject.
*/
class LOG4CXX_EXPORT PropertySetter
{
	protected:
		helpers::ObjectPtr obj;

	public:
		/**
		Create a new PropertySetter for the specified Object. This is done
		in prepartion for invoking #setProperty one or more times.

		@param obj  the object for which to set properties
		*/
		PropertySetter(const helpers::ObjectPtr& obj);

		/**
		Set the properties of an object passed as a parame...",1,main\include\log4cxx\config\propertysetter.hpp,LOG4CXX_NS,36,LOG4CXX_NS,3
63385,NAMESPACE_BLOCK,"namespace helpers
{
class Properties;
class Pool;
}",1,main\include\log4cxx\config\propertysetter.hpp,LOG4CXX_NS.helpers,38,helpers,1
63388,NAMESPACE_BLOCK,"namespace config
{
/**
General purpose Object property setter. Clients repeatedly invokes
{@link #setProperty setProperty(name,value)} in order to invoke setters
on the Object specified in the constructor.

<p>Usage:
<pre>
PropertySetter ps(anObject);
ps.set(""name"", ""Joe"");
ps.set(""age"", ""32"");
ps.set(""isMale"", ""true"");
</pre>
will cause the invocations anObject->setOption(""name"", ""Joe""),
anObject->setOption(""age"", ""32"") and anObject->setOption(""isMale"", ""true"")
if the spi::OptionHandler interface is supported by anObject.
*/
class LOG4CXX_EXPORT PropertySetter
{
	protected:
		helpers::ObjectPtr obj;

	public:
		/**
		Create a new PropertySetter for the specified Object. This is done
		in prepartion for invoking #setProperty one or more times.

		@param obj  the object for which to set properties
		*/
		PropertySetter(const helpers::ObjectPtr& obj);

		/**
		Set the properties of an object passed as a parameter in one
		go. The <code>properties</code> are parsed relative to a
		<cod...",1,main\include\log4cxx\config\propertysetter.hpp,LOG4CXX_NS.config,44,config,2
63393,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\consoleappender.hpp,main\include\log4cxx\consoleappender.hpp:<global>,,<global>,1
63397,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{

/**
* ConsoleAppender appends log events to <code>stdout</code> or
* <code>stderr</code> using a layout specified by the user.
*
* The default target is <code>stdout</code>.
*
* You can use <a href=""https://en.cppreference.com/w/c/io/fwide"">fwide(stdout, 1)</a> in your configuration code
* or use the cmake directive `LOG4CXX_FORCE_WIDE_CONSOLE=ON` when building Log4cxx
* to force Log4cxx to use <a href=""https://en.cppreference.com/w/c/io/fputws"">fputws</a>.
* If doing this ensure the cmake directive `LOG4CXX_WCHAR_T` is also enabled.
*/
class LOG4CXX_EXPORT ConsoleAppender : public WriterAppender
{
	private:
		struct ConsoleAppenderPriv;

	public:
		DECLARE_LOG4CXX_OBJECT(ConsoleAppender)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(ConsoleAppender)
		LOG4CXX_CAST_ENTRY_CHAIN(AppenderSkeleton)
		END_LOG4CXX_CAST_MAP()

		/**
		* A <code>stdout</code> log event appender.
		*
		* See also #setLayout and #setTarget.
		*/
		ConsoleAppender();

		/**
		* A <cod...",1,main\include\log4cxx\consoleappender.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
63413,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\db\dbappender.hpp,main\include\log4cxx\db\dbappender.hpp:<global>,,<global>,1
63417,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace db
{

/**
 * The DBAppender lets you log messages to a database.  This utilizes the APR's database support in order
 * to provide a single way of logging to multiple databases, not just ODBC as the ODBCAppender does.
 *
 * The following SQL script is an example of how you may make a table that stores log messages:
 *
 * ~~~{.sql}
 * CREATE TABLE logs (
 *  logger VARCHAR(200),
 *  time DATETIME,
 *  level CHAR(5),
 *  file VARCHAR(200),
 *  line_number INT,
 *  message VARCHAR(1000)
 * );
 * ~~~
 *
 * Once you have defined the table, you must define the order in which the columns are formatted when they are inserted
 * along with the insert statement.
 *
 * Using APR, the following insert statement can be used to insert log statements: <code>INSERT INTO logs (logger, time, level, file, line_number, message) VALUES (%s, %pDa, %s, %s, %d, %s)</code>
 * The values to insert must be formatted appropriately and in the correct order.  In order to do this, ...",1,main\include\log4cxx\db\dbappender.hpp,LOG4CXX_NS,29,LOG4CXX_NS,1
63418,NAMESPACE_BLOCK,"namespace db
{

/**
 * The DBAppender lets you log messages to a database.  This utilizes the APR's database support in order
 * to provide a single way of logging to multiple databases, not just ODBC as the ODBCAppender does.
 *
 * The following SQL script is an example of how you may make a table that stores log messages:
 *
 * ~~~{.sql}
 * CREATE TABLE logs (
 *  logger VARCHAR(200),
 *  time DATETIME,
 *  level CHAR(5),
 *  file VARCHAR(200),
 *  line_number INT,
 *  message VARCHAR(1000)
 * );
 * ~~~
 *
 * Once you have defined the table, you must define the order in which the columns are formatted when they are inserted
 * along with the insert statement.
 *
 * Using APR, the following insert statement can be used to insert log statements: <code>INSERT INTO logs (logger, time, level, file, line_number, message) VALUES (%s, %pDa, %s, %s, %d, %s)</code>
 * The values to insert must be formatted appropriately and in the correct order.  In order to do this, the parameter <code>Col...",1,main\include\log4cxx\db\dbappender.hpp,LOG4CXX_NS.db,31,db,1
63436,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\db\odbcappender.hpp,main\include\log4cxx\db\odbcappender.hpp:<global>,,<global>,1
63440,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace db
{
class LOG4CXX_EXPORT SQLException : public LOG4CXX_NS::helpers::Exception
{
	public:
		SQLException(short fHandleType,
			void* hInput, const char* prolog,
			LOG4CXX_NS::helpers::Pool& p);
		SQLException(const char* msg);
		SQLException(const SQLException& src);
	private:
		const char* formatMessage(short fHandleType,
			void* hInput, const char* prolog,
			LOG4CXX_NS::helpers::Pool& p);
};

/**
The ODBCAppender sends log events to a database.

<p>Each append call adds the spi::LoggingEvent to a buffer.
When the buffer is full, values are extracted from each spi::LoggingEvent
and the sql insert statement executed.

The SQL insert statement pattern must be provided
either in the Log4cxx configuration file
using the <b>sql</b> parameter element
or programatically by calling the <code>setSql(String sql)</code> method.

The following <b>param</b> elements are optional:
- one of <b>DSN</b>, <b>URL</b>, <b>ConnectionString</b> -
  The <b>serverName</...",1,main\include\log4cxx\db\odbcappender.hpp,LOG4CXX_NS,34,LOG4CXX_NS,1
63441,NAMESPACE_BLOCK,"namespace db
{
class LOG4CXX_EXPORT SQLException : public LOG4CXX_NS::helpers::Exception
{
	public:
		SQLException(short fHandleType,
			void* hInput, const char* prolog,
			LOG4CXX_NS::helpers::Pool& p);
		SQLException(const char* msg);
		SQLException(const SQLException& src);
	private:
		const char* formatMessage(short fHandleType,
			void* hInput, const char* prolog,
			LOG4CXX_NS::helpers::Pool& p);
};

/**
The ODBCAppender sends log events to a database.

<p>Each append call adds the spi::LoggingEvent to a buffer.
When the buffer is full, values are extracted from each spi::LoggingEvent
and the sql insert statement executed.

The SQL insert statement pattern must be provided
either in the Log4cxx configuration file
using the <b>sql</b> parameter element
or programatically by calling the <code>setSql(String sql)</code> method.

The following <b>param</b> elements are optional:
- one of <b>DSN</b>, <b>URL</b>, <b>ConnectionString</b> -
  The <b>serverName</b> parameter value in t...",1,main\include\log4cxx\db\odbcappender.hpp,LOG4CXX_NS.db,36,db,1
63452,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\defaultconfigurator.hpp,main\include\log4cxx\defaultconfigurator.hpp:<global>,,<global>,1
63456,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{

/**
 *   Configures the repository from environmental settings and files.
*
*/
class LOG4CXX_EXPORT DefaultConfigurator
{
	private:
		DefaultConfigurator() {}

	public:
		/**
		Configure \c repository.

		If the configuration file name has not been provided by a call to setConfigurationFileName(),
		the environment variables ""LOG4CXX_CONFIGURATION"" and ""log4j.configuration"" are examined.
		Unless a custom configurator is specified using the
		""LOG4CXX_CONFIGURATOR_CLASS"" or ""log4j.configuratorClass""
		environment variable, the PropertyConfigurator will be used to
		configure log4cxx unless the file name ends with the "".xml""
		extension, in which case the DOMConfigurator will be used. If a
		custom configurator is specified, the environment variable should
		contain a fully qualified class name of a class that implements the
		Configurator interface.

		If the configuration file name is not found using any of the previous approaches,
		the current directory is...",1,main\include\log4cxx\defaultconfigurator.hpp,LOG4CXX_NS,25,LOG4CXX_NS,1
63463,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\defaultloggerfactory.hpp,main\include\log4cxx\defaultloggerfactory.hpp:<global>,,<global>,1
63467,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
class Logger;
typedef std::shared_ptr<Logger> LoggerPtr;

class LOG4CXX_EXPORT DefaultLoggerFactory :
	public virtual spi::LoggerFactory,
	public virtual helpers::Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(DefaultLoggerFactory)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(spi::LoggerFactory)
		END_LOG4CXX_CAST_MAP()

		LoggerPtr makeNewLoggerInstance(helpers::Pool& pool, const LogString& name) const override;
};
}",1,main\include\log4cxx\defaultloggerfactory.hpp,LOG4CXX_NS,24,LOG4CXX_NS,1
63476,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\file.hpp,main\include\log4cxx\file.hpp:<global>,,<global>,1
63482,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{
class Transcoder;
class Pool;
}

/**
* An abstract representation of file and directory path names.
*/
class LOG4CXX_EXPORT File
{
	public:
		/**
		*   Construct a new instance.
		*/
		File();
		/**
		*   Construct a new instance.  Use setPath to specify path using a LogString.
		* @param path file path in local encoding.
		*/
		File(const char* path);
		/**
		*   Construct a new instance.  Use setPath to specify path using a LogString.
		* @param path file path in current encoding.
		*/
		File(const std::string& path);
#if LOG4CXX_WCHAR_T_API
		/**
		*   Construct a new instance.  Use setPath to specify path using a LogString.
		* @param path file path.
		*/
		File(const wchar_t* path);
		/**
		*   Construct a new instance.  Use setPath to specify path using a LogString.
		* @param path file path.
		*/
		File(const std::wstring& path);
#endif
#if LOG4CXX_UNICHAR_API || LOG4CXX_LOGCHAR_IS_UNICHAR
		/**
		*   Construct a new instance.  Use s...",1,main\include\log4cxx\file.hpp,LOG4CXX_NS,29,LOG4CXX_NS,3
63483,NAMESPACE_BLOCK,"namespace helpers
{
class Transcoder;
class Pool;
}",1,main\include\log4cxx\file.hpp,LOG4CXX_NS.helpers,31,helpers,1
63498,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\fileappender.hpp,main\include\log4cxx\fileappender.hpp:<global>,,<global>,1
63502,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{
class Pool;
}

/**
*  FileAppender appends log events to a file.
*
*  <p>Support for <code>java.io.Writer</code> and console appending
*  has been deprecated and then removed. See the replacement
*  solutions: WriterAppender and ConsoleAppender.
*/
class LOG4CXX_EXPORT FileAppender : public WriterAppender
{
	protected:
		struct FileAppenderPriv;

	public:
		DECLARE_LOG4CXX_OBJECT(FileAppender)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(FileAppender)
		LOG4CXX_CAST_ENTRY_CHAIN(WriterAppender)
		END_LOG4CXX_CAST_MAP()

		/**
		The default constructor does not do anything.
		*/
		FileAppender();

		/**
		Instantiate a <code>FileAppender</code> and open the file
		designated by <code>filename</code>. The opened filename will
		become the output destination for this appender.

		<p>If the <code>append</code> parameter is true, the file will be
		appended to. Otherwise, the file designated by
		<code>filename</code> will be truncated before ...",1,main\include\log4cxx\fileappender.hpp,LOG4CXX_NS,27,LOG4CXX_NS,1
63503,NAMESPACE_BLOCK,"namespace helpers
{
class Pool;
}",1,main\include\log4cxx\fileappender.hpp,LOG4CXX_NS.helpers,29,helpers,1
63512,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\filter\andfilter.hpp,main\include\log4cxx\filter\andfilter.hpp:<global>,,<global>,1
63516,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace filter
{

/**
 * A filter that 'and's the results of any number of contained filters together.
 *
 * For the filter to process events, all contained filters must return Filter::ACCEPT.
 *
 * If the contained filters do not return Filter::ACCEPT, Filter::NEUTRAL is returned.
 *
 * If acceptOnMatch is set to true, Filter::ACCEPT is returned.
 * If acceptOnMatch is set to false, Filter::DENY is returned.
 *
 * Here is an example config that will accept only events that contain BOTH
 * a DEBUG level AND 'test' in the message:
 *<pre>
 * &lt;appender name=""STDOUT"" class=""org.apache.log4j.ConsoleAppender""&gt;
 *  &lt;filter class=""org.apache.log4j.filter.AndFilter""&gt;
 *   &lt;filter class=""org.apache.log4j.filter.LevelMatchFilter""&gt;
 *        &lt;param name=""levelToMatch"" value=""DEBUG"" /&gt;
 *        &lt;param name=""acceptOnMatch"" value=""true"" /&gt;
 *   &lt;/filter>
 *   &lt;filter class=""org.apache.log4j.filter.StringMatchFilter""&gt;
 *        &lt;p...",1,main\include\log4cxx\filter\andfilter.hpp,LOG4CXX_NS,24,LOG4CXX_NS,1
63517,NAMESPACE_BLOCK,"namespace filter
{

/**
 * A filter that 'and's the results of any number of contained filters together.
 *
 * For the filter to process events, all contained filters must return Filter::ACCEPT.
 *
 * If the contained filters do not return Filter::ACCEPT, Filter::NEUTRAL is returned.
 *
 * If acceptOnMatch is set to true, Filter::ACCEPT is returned.
 * If acceptOnMatch is set to false, Filter::DENY is returned.
 *
 * Here is an example config that will accept only events that contain BOTH
 * a DEBUG level AND 'test' in the message:
 *<pre>
 * &lt;appender name=""STDOUT"" class=""org.apache.log4j.ConsoleAppender""&gt;
 *  &lt;filter class=""org.apache.log4j.filter.AndFilter""&gt;
 *   &lt;filter class=""org.apache.log4j.filter.LevelMatchFilter""&gt;
 *        &lt;param name=""levelToMatch"" value=""DEBUG"" /&gt;
 *        &lt;param name=""acceptOnMatch"" value=""true"" /&gt;
 *   &lt;/filter>
 *   &lt;filter class=""org.apache.log4j.filter.StringMatchFilter""&gt;
 *        &lt;param name=""stringToMatc...",1,main\include\log4cxx\filter\andfilter.hpp,LOG4CXX_NS.filter,26,filter,1
63523,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\filter\denyallfilter.hpp,main\include\log4cxx\filter\denyallfilter.hpp:<global>,,<global>,1
63527,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace filter
{
/**
This filter drops all logging events.
<p>You can add this filter to the end of a filter chain to
switch from the default ""accept all unless instructed otherwise""
filtering behaviour to a ""deny all unless instructed otherwise""
behaviour.
*/

class LOG4CXX_EXPORT DenyAllFilter : public spi::Filter
{
	public:
		DenyAllFilter() : spi::Filter()
		{
		}

		typedef spi::Filter BASE_CLASS;
		DECLARE_LOG4CXX_OBJECT(DenyAllFilter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(DenyAllFilter)
		LOG4CXX_CAST_ENTRY_CHAIN(BASE_CLASS)
		END_LOG4CXX_CAST_MAP()

		/**
		Always returns the integer constant {@link spi::Filter#DENY DENY}
		regardless of the {@link spi::LoggingEventPtr LoggingEvent} parameter.
		@param event The LoggingEvent to filter.
		@return Always returns {@link spi::Filter#DENY DENY}.
		*/
		FilterDecision decide(const spi::LoggingEventPtr& event) const override
		{
			return spi::Filter::DENY;
		}
}; // class DenyAllFilter

LOG4CXX_P...",1,main\include\log4cxx\filter\denyallfilter.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
63528,NAMESPACE_BLOCK,"namespace filter
{
/**
This filter drops all logging events.
<p>You can add this filter to the end of a filter chain to
switch from the default ""accept all unless instructed otherwise""
filtering behaviour to a ""deny all unless instructed otherwise""
behaviour.
*/

class LOG4CXX_EXPORT DenyAllFilter : public spi::Filter
{
	public:
		DenyAllFilter() : spi::Filter()
		{
		}

		typedef spi::Filter BASE_CLASS;
		DECLARE_LOG4CXX_OBJECT(DenyAllFilter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(DenyAllFilter)
		LOG4CXX_CAST_ENTRY_CHAIN(BASE_CLASS)
		END_LOG4CXX_CAST_MAP()

		/**
		Always returns the integer constant {@link spi::Filter#DENY DENY}
		regardless of the {@link spi::LoggingEventPtr LoggingEvent} parameter.
		@param event The LoggingEvent to filter.
		@return Always returns {@link spi::Filter#DENY DENY}.
		*/
		FilterDecision decide(const spi::LoggingEventPtr& event) const override
		{
			return spi::Filter::DENY;
		}
}; // class DenyAllFilter

LOG4CXX_PTR_DEF(DenyAllFilter);
}",1,main\include\log4cxx\filter\denyallfilter.hpp,LOG4CXX_NS.filter,25,filter,1
63534,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\filter\expressionfilter.hpp,main\include\log4cxx\filter\expressionfilter.hpp:<global>,,<global>,1
63538,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace rule
{
class Rule;
typedef helpers::ObjectPtrT < Rule > RulePtr;
}


namespace filter
{


/**
 *A filter supporting complex expressions - supports both infix and postfix
 * expressions (infix expressions must first be converted to postfix prior
 * to processing).
 *
 * <p>See <code>org.apache.log4j.chainsaw.LoggingEventFieldResolver.java</code>
 * for the correct names for logging event fields used when building expressions.
 *
 * <p>See <code>org.apache.log4j.chainsaw.rule</code> package for a list of available
 * rules which can be applied using the expression syntax.
 *
 * <p>See <code>org.apache.log4j.chainsaw.RuleFactory</code> for the symbols
 * used to activate the corresponding rules.
 *
 *NOTE:  Grouping using parentheses is supported - all tokens must be separated by spaces, and
 *operands which contain spaces are not yet supported.
 *
 *Example:
 *
 *In order to build a filter that displays all messages with infomsg-45 or infomsg-44 in the...",1,main\include\log4cxx\filter\expressionfilter.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
63539,NAMESPACE_BLOCK,"namespace rule
{
class Rule;
typedef helpers::ObjectPtrT < Rule > RulePtr;
}",1,main\include\log4cxx\filter\expressionfilter.hpp,LOG4CXX_NS.rule,25,rule,1
63542,NAMESPACE_BLOCK,"namespace filter
{


/**
 *A filter supporting complex expressions - supports both infix and postfix
 * expressions (infix expressions must first be converted to postfix prior
 * to processing).
 *
 * <p>See <code>org.apache.log4j.chainsaw.LoggingEventFieldResolver.java</code>
 * for the correct names for logging event fields used when building expressions.
 *
 * <p>See <code>org.apache.log4j.chainsaw.rule</code> package for a list of available
 * rules which can be applied using the expression syntax.
 *
 * <p>See <code>org.apache.log4j.chainsaw.RuleFactory</code> for the symbols
 * used to activate the corresponding rules.
 *
 *NOTE:  Grouping using parentheses is supported - all tokens must be separated by spaces, and
 *operands which contain spaces are not yet supported.
 *
 *Example:
 *
 *In order to build a filter that displays all messages with infomsg-45 or infomsg-44 in the message,
 *as well as all messages with a level of WARN or higher, build an expression using
 *the Li...",1,main\include\log4cxx\filter\expressionfilter.hpp,LOG4CXX_NS.filter,32,filter,2
63549,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\filter\levelmatchfilter.hpp,main\include\log4cxx\filter\levelmatchfilter.hpp:<global>,,<global>,1
63553,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
class Level;

namespace filter
{
/**
This is a very simple filter based on level matching.

<p>The filter admits two options <code>levelToMatch</code> and
<code>acceptOnMatch</code>. If there is an exact match between the value
of the <code>levelToMatch</code> option and the level of the
{@link spi::LoggingEvent LoggingEvent}, then the #decide method returns
{@link spi::Filter::ACCEPT ACCEPT} in case the <code>acceptOnMatch</code>
option value is set to <code>true</code>,
if it is <code>false</code> then {@link spi::Filter::DENY DENY} is returned.
If there is no match, {@link spi::Filter::NEUTRAL NEUTRAL} is returned.
*/
class LOG4CXX_EXPORT LevelMatchFilter : public spi::Filter
{
	private:
		struct LevelMatchFilterPrivate;

	public:
		typedef spi::Filter BASE_CLASS;
		DECLARE_LOG4CXX_OBJECT(LevelMatchFilter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(LevelMatchFilter)
		LOG4CXX_CAST_ENTRY_CHAIN(BASE_CLASS)
		END_LOG4CXX_CAST_MAP()

		LevelMatchFilter();
...",1,main\include\log4cxx\filter\levelmatchfilter.hpp,LOG4CXX_NS,24,LOG4CXX_NS,1
63555,NAMESPACE_BLOCK,"namespace filter
{
/**
This is a very simple filter based on level matching.

<p>The filter admits two options <code>levelToMatch</code> and
<code>acceptOnMatch</code>. If there is an exact match between the value
of the <code>levelToMatch</code> option and the level of the
{@link spi::LoggingEvent LoggingEvent}, then the #decide method returns
{@link spi::Filter::ACCEPT ACCEPT} in case the <code>acceptOnMatch</code>
option value is set to <code>true</code>,
if it is <code>false</code> then {@link spi::Filter::DENY DENY} is returned.
If there is no match, {@link spi::Filter::NEUTRAL NEUTRAL} is returned.
*/
class LOG4CXX_EXPORT LevelMatchFilter : public spi::Filter
{
	private:
		struct LevelMatchFilterPrivate;

	public:
		typedef spi::Filter BASE_CLASS;
		DECLARE_LOG4CXX_OBJECT(LevelMatchFilter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(LevelMatchFilter)
		LOG4CXX_CAST_ENTRY_CHAIN(BASE_CLASS)
		END_LOG4CXX_CAST_MAP()

		LevelMatchFilter();
		~LevelMatchFilter();

		/**
		\copy...",1,main\include\log4cxx\filter\levelmatchfilter.hpp,LOG4CXX_NS.filter,28,filter,2
63563,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\filter\levelrangefilter.hpp,main\include\log4cxx\filter\levelrangefilter.hpp:<global>,,<global>,1
63567,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace filter
{
/**
This is a very simple filter based on level matching, which can be
used to reject messages with priorities outside a certain range.

<p>The filter admits three options <code>levelMin</code>, <code>levelMax</code>
and <code>acceptOnMatch</code>.

<p>If the level of the {@link spi::LoggingEvent LoggingEvent} is not
between Min and Max (inclusive), then {@link spi::Filter#DENY DENY}
is returned.

<p> If the Logging event level is within the specified range, then if
<code>acceptOnMatch</code> is true, {@link spi::Filter#ACCEPT ACCEPT} is
returned, and if <code>acceptOnMatch</code> is false,
{@link spi::Filter#NEUTRAL NEUTRAL} is returned.

<p>If <code>levelMin</code>w is not defined, then there is no
minimum acceptable level (ie a level is never rejected for
being too ""low""/unimportant).  If <code>levelMax</code> is not
defined, then there is no maximum acceptable level (ie a
level is never rejected for beeing too ""high""/important).

<p>Refe...",1,main\include\log4cxx\filter\levelrangefilter.hpp,LOG4CXX_NS,24,LOG4CXX_NS,1
63568,NAMESPACE_BLOCK,"namespace filter
{
/**
This is a very simple filter based on level matching, which can be
used to reject messages with priorities outside a certain range.

<p>The filter admits three options <code>levelMin</code>, <code>levelMax</code>
and <code>acceptOnMatch</code>.

<p>If the level of the {@link spi::LoggingEvent LoggingEvent} is not
between Min and Max (inclusive), then {@link spi::Filter#DENY DENY}
is returned.

<p> If the Logging event level is within the specified range, then if
<code>acceptOnMatch</code> is true, {@link spi::Filter#ACCEPT ACCEPT} is
returned, and if <code>acceptOnMatch</code> is false,
{@link spi::Filter#NEUTRAL NEUTRAL} is returned.

<p>If <code>levelMin</code>w is not defined, then there is no
minimum acceptable level (ie a level is never rejected for
being too ""low""/unimportant).  If <code>levelMax</code> is not
defined, then there is no maximum acceptable level (ie a
level is never rejected for beeing too ""high""/important).

<p>Refer to the {@link Appende...",1,main\include\log4cxx\filter\levelrangefilter.hpp,LOG4CXX_NS.filter,26,filter,1
63574,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\filter\locationinfofilter.hpp,main\include\log4cxx\filter\locationinfofilter.hpp:<global>,,<global>,1
63578,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{

namespace filter
{

/**
 * When location information is available, individual log statements can be turned on or off
 * depending on their source location.
 *
 * This filter allows for filtering messages based off of either the line number of the
 * message, or the name of the method that the log mesage is in.  The 'operator' parameter
 * may be used to determine if both the method name and line number must match.
 * If 'operator' is set to 'AND', then both the line number and method name must match,
 * otherwise only one needs to match.  By default, 'operator' is set to 'OR'.
 *
 * If location information is not available, this filter does nothing.
 *
 */
class LOG4CXX_EXPORT LocationInfoFilter: public LOG4CXX_NS::spi::Filter
{
		struct LocationInfoFilterPrivate;
	public:
		DECLARE_LOG4CXX_OBJECT(LocationInfoFilter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(LocationInfoFilter)
		LOG4CXX_CAST_ENTRY_CHAIN(LOG4CXX_NS::spi::Filter)
		END_LOG4CXX_CAST_MAP()...",1,main\include\log4cxx\filter\locationinfofilter.hpp,LOG4CXX_NS,22,LOG4CXX_NS,1
63579,NAMESPACE_BLOCK,"namespace filter
{

/**
 * When location information is available, individual log statements can be turned on or off
 * depending on their source location.
 *
 * This filter allows for filtering messages based off of either the line number of the
 * message, or the name of the method that the log mesage is in.  The 'operator' parameter
 * may be used to determine if both the method name and line number must match.
 * If 'operator' is set to 'AND', then both the line number and method name must match,
 * otherwise only one needs to match.  By default, 'operator' is set to 'OR'.
 *
 * If location information is not available, this filter does nothing.
 *
 */
class LOG4CXX_EXPORT LocationInfoFilter: public LOG4CXX_NS::spi::Filter
{
		struct LocationInfoFilterPrivate;
	public:
		DECLARE_LOG4CXX_OBJECT(LocationInfoFilter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(LocationInfoFilter)
		LOG4CXX_CAST_ENTRY_CHAIN(LOG4CXX_NS::spi::Filter)
		END_LOG4CXX_CAST_MAP()

		LocationInfoFilter()...",1,main\include\log4cxx\filter\locationinfofilter.hpp,LOG4CXX_NS.filter,25,filter,1
63587,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\filter\loggermatchfilter.hpp,main\include\log4cxx\filter\loggermatchfilter.hpp:<global>,,<global>,1
63591,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
class Level;

namespace filter
{
/**
   This is a very simple filter based on logger name matching.

   <p>The filter admits two options <code>loggerToMatch</code> and
   <code>acceptOnMatch</code>. If there is an exact match between the value
   of the <code>loggerToMatch</code> option and the logger of the
   {@link spi::LoggingEvent LoggingEvent}, then the #decide method returns
   {@link spi::Filter#ACCEPT ACCEPT} in case the <code>acceptOnMatch</code> option value is set
   to <code>true</code>, if it is <code>false</code> then
   {@link spi::Filter#DENY} is returned. If there is no match,
   {@link spi::Filter#NEUTRAL} is returned.
   A loggerToMatch of ""root"" matches both the root logger and a logger named ""root"".

   */

class LOG4CXX_EXPORT LoggerMatchFilter : public spi::Filter
{
	private:
		struct LoggerMatchFilterPrivate;

	public:
		typedef spi::Filter BASE_CLASS;
		DECLARE_LOG4CXX_OBJECT(LoggerMatchFilter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAS...",1,main\include\log4cxx\filter\loggermatchfilter.hpp,LOG4CXX_NS,24,LOG4CXX_NS,1
63593,NAMESPACE_BLOCK,"namespace filter
{
/**
   This is a very simple filter based on logger name matching.

   <p>The filter admits two options <code>loggerToMatch</code> and
   <code>acceptOnMatch</code>. If there is an exact match between the value
   of the <code>loggerToMatch</code> option and the logger of the
   {@link spi::LoggingEvent LoggingEvent}, then the #decide method returns
   {@link spi::Filter#ACCEPT ACCEPT} in case the <code>acceptOnMatch</code> option value is set
   to <code>true</code>, if it is <code>false</code> then
   {@link spi::Filter#DENY} is returned. If there is no match,
   {@link spi::Filter#NEUTRAL} is returned.
   A loggerToMatch of ""root"" matches both the root logger and a logger named ""root"".

   */

class LOG4CXX_EXPORT LoggerMatchFilter : public spi::Filter
{
	private:
		struct LoggerMatchFilterPrivate;

	public:
		typedef spi::Filter BASE_CLASS;
		DECLARE_LOG4CXX_OBJECT(LoggerMatchFilter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(LoggerMatchFilter)
		LOG4CXX_...",1,main\include\log4cxx\filter\loggermatchfilter.hpp,LOG4CXX_NS.filter,28,filter,2
63599,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\filter\mapfilter.hpp,main\include\log4cxx\filter\mapfilter.hpp:<global>,,<global>,1
63603,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace filter
{

/**
 * A Filter that operates on the current thread's MDC map.

 For example, to exclude entries from the log where the context
 has ""user.name"" set to ""test2"" and ""user.ip"" is ""127.0.0.1"":
 * <pre>
 * &lt;filter class=""MapFilter""&gt;
 *     &lt;param name=""user.ip""       value=""127.0.0.1"" /&gt;
 *     &lt;param name=""user.name""     value=""test2""     /&gt;
 *     &lt;param name=""Operator""      value=""AND""       /&gt;
 *     &lt;param name=""AcceptOnMatch"" value=""false""     /&gt;
 * &lt;/filter&gt;
 * </pre>
 */
class LOG4CXX_EXPORT MapFilter: public LOG4CXX_NS::spi::Filter
{
		typedef std::map < LogString, LogString > KeyVals;

	private:
		struct MapFilterPrivate;

	public:
		DECLARE_LOG4CXX_OBJECT(MapFilter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(MapFilter)
		LOG4CXX_CAST_ENTRY_CHAIN(LOG4CXX_NS::spi::Filter)
		END_LOG4CXX_CAST_MAP()

		MapFilter();
		~MapFilter();

		/**
		\copybrief spi::OptionHandler::setOption()

		Supported opt...",1,main\include\log4cxx\filter\mapfilter.hpp,LOG4CXX_NS,22,LOG4CXX_NS,1
63604,NAMESPACE_BLOCK,"namespace filter
{

/**
 * A Filter that operates on the current thread's MDC map.

 For example, to exclude entries from the log where the context
 has ""user.name"" set to ""test2"" and ""user.ip"" is ""127.0.0.1"":
 * <pre>
 * &lt;filter class=""MapFilter""&gt;
 *     &lt;param name=""user.ip""       value=""127.0.0.1"" /&gt;
 *     &lt;param name=""user.name""     value=""test2""     /&gt;
 *     &lt;param name=""Operator""      value=""AND""       /&gt;
 *     &lt;param name=""AcceptOnMatch"" value=""false""     /&gt;
 * &lt;/filter&gt;
 * </pre>
 */
class LOG4CXX_EXPORT MapFilter: public LOG4CXX_NS::spi::Filter
{
		typedef std::map < LogString, LogString > KeyVals;

	private:
		struct MapFilterPrivate;

	public:
		DECLARE_LOG4CXX_OBJECT(MapFilter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(MapFilter)
		LOG4CXX_CAST_ENTRY_CHAIN(LOG4CXX_NS::spi::Filter)
		END_LOG4CXX_CAST_MAP()

		MapFilter();
		~MapFilter();

		/**
		\copybrief spi::OptionHandler::setOption()

		Supported options | Supported values...",1,main\include\log4cxx\filter\mapfilter.hpp,LOG4CXX_NS.filter,24,filter,1
63612,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\filter\propertyfilter.hpp,main\include\log4cxx\filter\propertyfilter.hpp:<global>,,<global>,1
63616,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace filter
{

/**
 * NOTE: This filter modifies logging events by adding properties to the event.
 *
 * The 'properties' param is converted to event properties, which are
 * set on every event processed by the filter.
 *
 * Individual properties are only set if they do not already exist on the
 * logging event (will not override existing properties).
 *
 * This class relies on the convention that property name/value pairs are
 * equals-symbol delimited, and each name/value pair is comma-delimited
 *
 * Example properties param:
 * somename=somevalue,anothername=anothervalue,thirdname=third value
 *
 *
 */
class LOG4CXX_EXPORT PropertyFilter : public LOG4CXX_NS::spi::Filter
{
		typedef std::map < LogString, LogString > PropertyMap;
		PropertyMap* properties;
		PropertyFilter(const PropertyFilter&);
		PropertyFilter& operator=(const PropertyFilter&);

	public:
		DECLARE_LOG4CXX_OBJECT(PropertyFilter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(LOG4CXX_...",1,main\include\log4cxx\filter\propertyfilter.hpp,LOG4CXX_NS,25,LOG4CXX_NS,1
63617,NAMESPACE_BLOCK,"namespace filter
{

/**
 * NOTE: This filter modifies logging events by adding properties to the event.
 *
 * The 'properties' param is converted to event properties, which are
 * set on every event processed by the filter.
 *
 * Individual properties are only set if they do not already exist on the
 * logging event (will not override existing properties).
 *
 * This class relies on the convention that property name/value pairs are
 * equals-symbol delimited, and each name/value pair is comma-delimited
 *
 * Example properties param:
 * somename=somevalue,anothername=anothervalue,thirdname=third value
 *
 *
 */
class LOG4CXX_EXPORT PropertyFilter : public LOG4CXX_NS::spi::Filter
{
		typedef std::map < LogString, LogString > PropertyMap;
		PropertyMap* properties;
		PropertyFilter(const PropertyFilter&);
		PropertyFilter& operator=(const PropertyFilter&);

	public:
		DECLARE_LOG4CXX_OBJECT(PropertyFilter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(LOG4CXX_NS::spi::Filter)
		END_...",1,main\include\log4cxx\filter\propertyfilter.hpp,LOG4CXX_NS.filter,27,filter,1
63622,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\filter\stringmatchfilter.hpp,main\include\log4cxx\filter\stringmatchfilter.hpp:<global>,,<global>,1
63626,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace filter
{
/**
This is a very simple filter based on string matching.

<p>The filter admits two options <b>StringToMatch</b> and
<b>AcceptOnMatch</b>. If there is a match between the value of the
StringToMatch option and the message of the {@link spi::LoggingEvent
LoggingEvent}, then the #decide method returns
{@link log4cxx::spi::Filter#ACCEPT ACCEPT} if the <b>AcceptOnMatch</b> option
value is true, if it is false then {@link log4cxx::spi::Filter#DENY DENY} is
returned. If there is no match, {@link log4cxx::spi::Filter#NEUTRAL NEUTRAL}
is returned.

<p>See configuration files <a
href=""../xml/doc-files/test6.xml"">test6.xml</a>, <a
href=""../xml/doc-files/test7.xml"">test7.xml</a>, <a
href=""../xml/doc-files/test8.xml"">test8.xml</a>, <a
href=""../xml/doc-files/test9.xml"">test9.xml</a>, and <a
href=""../xml/doc-files/test10.xml"">test10.xml</a> for examples of
seeting up a <code>StringMatchFilter</code>.
*/

class LOG4CXX_EXPORT StringMatchFilter : public spi...",1,main\include\log4cxx\filter\stringmatchfilter.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
63627,NAMESPACE_BLOCK,"namespace filter
{
/**
This is a very simple filter based on string matching.

<p>The filter admits two options <b>StringToMatch</b> and
<b>AcceptOnMatch</b>. If there is a match between the value of the
StringToMatch option and the message of the {@link spi::LoggingEvent
LoggingEvent}, then the #decide method returns
{@link log4cxx::spi::Filter#ACCEPT ACCEPT} if the <b>AcceptOnMatch</b> option
value is true, if it is false then {@link log4cxx::spi::Filter#DENY DENY} is
returned. If there is no match, {@link log4cxx::spi::Filter#NEUTRAL NEUTRAL}
is returned.

<p>See configuration files <a
href=""../xml/doc-files/test6.xml"">test6.xml</a>, <a
href=""../xml/doc-files/test7.xml"">test7.xml</a>, <a
href=""../xml/doc-files/test8.xml"">test8.xml</a>, <a
href=""../xml/doc-files/test9.xml"">test9.xml</a>, and <a
href=""../xml/doc-files/test10.xml"">test10.xml</a> for examples of
seeting up a <code>StringMatchFilter</code>.
*/

class LOG4CXX_EXPORT StringMatchFilter : public spi::Filter
{
	private:
		...",1,main\include\log4cxx\filter\stringmatchfilter.hpp,LOG4CXX_NS.filter,25,filter,1
63633,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\fmtlayout.hpp,main\include\log4cxx\fmtlayout.hpp:<global>,,<global>,1
63637,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
/**
 * The FMTLayout class uses libfmt to layout messages.  This is an alternative to the PatternLayout class.
 * Most of the standard PatternLayout arguments are also accepted as arguments, so that you can easily
 * convert a PatternLayout to a FMTLayout.  For example, given the following PatternLayout:
 *
 * <pre>%c %-5p - %m%n</pre>
 * which outputs something like:
 * <pre>root INFO  - Hello there!</pre>
 *
 * The equivalent FMTLayout can be written as:
 * <pre>{c} {p:<5} - {m}{n}</pre>
 * Or more verbosely as:
 * <pre>{logger} {level:<5} - {message}{newline}</pre>
 *
 * All replacements are done using the named arguments feature of {fmt}.
 *
 * <p>The recognized conversion strings are:</p>
 *
 * <table border=""1"" cellpadding=""8"">
 *  <tr>
 *      <th align=""center""><strong>Conversion string</strong></th>
 *      <th align=""center""><strong>Effect</strong></th>
 *  </tr>
 *  <tr>
 *      <td align=""center"">
 *        <p><strong>c</strong></p>
 *        <p><s...",1,main\include\log4cxx\fmtlayout.hpp,LOG4CXX_NS,29,LOG4CXX_NS,1
63643,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\absolutetimedateformat.hpp,main\include\log4cxx\helpers\absolutetimedateformat.hpp:<global>,,<global>,1
63647,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{
/**
Formats a date in the format <b>HH:mm:ss,SSS</b> for example,
""15:49:37,459"".
*/
class LOG4CXX_EXPORT AbsoluteTimeDateFormat : public SimpleDateFormat
{
	public:
		AbsoluteTimeDateFormat()
			: SimpleDateFormat(LOG4CXX_STR(""HH:mm:ss,SSS"")) {}
};
}  // namespace helpers
}",1,main\include\log4cxx\helpers\absolutetimedateformat.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
63648,NAMESPACE_BLOCK,"namespace helpers
{
/**
Formats a date in the format <b>HH:mm:ss,SSS</b> for example,
""15:49:37,459"".
*/
class LOG4CXX_EXPORT AbsoluteTimeDateFormat : public SimpleDateFormat
{
	public:
		AbsoluteTimeDateFormat()
			: SimpleDateFormat(LOG4CXX_STR(""HH:mm:ss,SSS"")) {}
};
}",1,main\include\log4cxx\helpers\absolutetimedateformat.hpp,LOG4CXX_NS.helpers,25,helpers,1
63661,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\appenderattachableimpl.hpp,main\include\log4cxx\helpers\appenderattachableimpl.hpp:<global>,,<global>,1
63665,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace spi
{
class LoggingEvent;
typedef std::shared_ptr<LoggingEvent> LoggingEventPtr;
}

namespace helpers
{

class LOG4CXX_EXPORT AppenderAttachableImpl :
	public virtual spi::AppenderAttachable
{
	protected:
		AppenderList& appenderList();

	public:
		/**
		 *   Create new instance.
		 *   @param pool pool, must be longer-lived than instance.
		 */
		AppenderAttachableImpl(Pool& pool);

		~AppenderAttachableImpl();

		DECLARE_ABSTRACT_LOG4CXX_OBJECT(AppenderAttachableImpl)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(AppenderAttachableImpl)
		LOG4CXX_CAST_ENTRY(spi::AppenderAttachable)
		END_LOG4CXX_CAST_MAP()

		// Methods
		/**
		 * Add an appender.
		 */
		void addAppender(const AppenderPtr newAppender) override;

		/**
		 Call the <code>doAppend</code> method on all attached appenders.
		*/
		int appendLoopOnAppenders(const spi::LoggingEventPtr& event,
			LOG4CXX_NS::helpers::Pool& p);

		/**
		 * Get all previously added appenders as an Enumerat...",1,main\include\log4cxx\helpers\appenderattachableimpl.hpp,LOG4CXX_NS,28,LOG4CXX_NS,1
63666,NAMESPACE_BLOCK,"namespace spi
{
class LoggingEvent;
typedef std::shared_ptr<LoggingEvent> LoggingEventPtr;
}",1,main\include\log4cxx\helpers\appenderattachableimpl.hpp,LOG4CXX_NS.spi,30,spi,1
63669,NAMESPACE_BLOCK,"namespace helpers
{

class LOG4CXX_EXPORT AppenderAttachableImpl :
	public virtual spi::AppenderAttachable
{
	protected:
		AppenderList& appenderList();

	public:
		/**
		 *   Create new instance.
		 *   @param pool pool, must be longer-lived than instance.
		 */
		AppenderAttachableImpl(Pool& pool);

		~AppenderAttachableImpl();

		DECLARE_ABSTRACT_LOG4CXX_OBJECT(AppenderAttachableImpl)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(AppenderAttachableImpl)
		LOG4CXX_CAST_ENTRY(spi::AppenderAttachable)
		END_LOG4CXX_CAST_MAP()

		// Methods
		/**
		 * Add an appender.
		 */
		void addAppender(const AppenderPtr newAppender) override;

		/**
		 Call the <code>doAppend</code> method on all attached appenders.
		*/
		int appendLoopOnAppenders(const spi::LoggingEventPtr& event,
			LOG4CXX_NS::helpers::Pool& p);

		/**
		 * Get all previously added appenders as an Enumeration.
		 */
		AppenderList getAllAppenders() const override;

		/**
		 * Get an appender by name.
		 */
		AppenderPtr ...",1,main\include\log4cxx\helpers\appenderattachableimpl.hpp,LOG4CXX_NS.helpers,36,helpers,2
63685,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\aprinitializer.hpp,main\include\log4cxx\helpers\aprinitializer.hpp:<global>,,<global>,1
63691,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{
class FileWatchdog;

class APRInitializer
{
	public:
		static log4cxx_time_t initialize();
		static apr_pool_t* getRootPool();
		static apr_threadkey_t* getTlsKey();
		static bool isDestructed;

		/**
		 *  Register a FileWatchdog for deletion prior to termination.
		 *    FileWatchdog must be
		 *    allocated on heap and not deleted elsewhere.
		 */
		static void registerCleanup(FileWatchdog* watchdog);
		static void unregisterCleanup(FileWatchdog* watchdog);
		static void unregisterAll();
		/**
		 *  Store a single instance type ObjectPtr for deletion prior to termination
		 */
		template <class T> static void setUnique(const std::shared_ptr<T>& pObject)
		{
			getInstance().addObject(typeid(T).hash_code(), pObject);
		}
		/**
		 *  Fetch or add a single instance type ObjectPtr for deletion prior to termination
		 */
		template <class T> static std::shared_ptr<T> getOrAddUnique(std::function<ObjectPtr()> creator)
		{
			return cast<T>(ge...",1,main\include\log4cxx\helpers\aprinitializer.hpp,LOG4CXX_NS,38,LOG4CXX_NS,3
63692,NAMESPACE_BLOCK,"namespace helpers
{
class FileWatchdog;

class APRInitializer
{
	public:
		static log4cxx_time_t initialize();
		static apr_pool_t* getRootPool();
		static apr_threadkey_t* getTlsKey();
		static bool isDestructed;

		/**
		 *  Register a FileWatchdog for deletion prior to termination.
		 *    FileWatchdog must be
		 *    allocated on heap and not deleted elsewhere.
		 */
		static void registerCleanup(FileWatchdog* watchdog);
		static void unregisterCleanup(FileWatchdog* watchdog);
		static void unregisterAll();
		/**
		 *  Store a single instance type ObjectPtr for deletion prior to termination
		 */
		template <class T> static void setUnique(const std::shared_ptr<T>& pObject)
		{
			getInstance().addObject(typeid(T).hash_code(), pObject);
		}
		/**
		 *  Fetch or add a single instance type ObjectPtr for deletion prior to termination
		 */
		template <class T> static std::shared_ptr<T> getOrAddUnique(std::function<ObjectPtr()> creator)
		{
			return cast<T>(getInstance().findOrAddOb...",1,main\include\log4cxx\helpers\aprinitializer.hpp,LOG4CXX_NS.helpers,40,helpers,1
63796,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\bufferedwriter.hpp,main\include\log4cxx\helpers\bufferedwriter.hpp:<global>,,<global>,1
63800,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{

namespace helpers
{

/**
*   Writes text to a character-output stream buffering
*       requests to increase efficiency.
*/
class LOG4CXX_EXPORT BufferedWriter : public Writer
{
	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(BufferedWriterPriv, m_priv)

	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(BufferedWriter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(BufferedWriter)
		LOG4CXX_CAST_ENTRY_CHAIN(Writer)
		END_LOG4CXX_CAST_MAP()

		BufferedWriter(WriterPtr& out);
		BufferedWriter(WriterPtr& out, size_t sz);
		virtual ~BufferedWriter();

		void close(Pool& p) override;
		void flush(Pool& p) override;
		void write(const LogString& str, Pool& p) override;

	private:
		BufferedWriter(const BufferedWriter&);
		BufferedWriter& operator=(const BufferedWriter&);
};

} // namespace helpers

}",1,main\include\log4cxx\helpers\bufferedwriter.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
63801,NAMESPACE_BLOCK,"namespace helpers
{

/**
*   Writes text to a character-output stream buffering
*       requests to increase efficiency.
*/
class LOG4CXX_EXPORT BufferedWriter : public Writer
{
	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(BufferedWriterPriv, m_priv)

	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(BufferedWriter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(BufferedWriter)
		LOG4CXX_CAST_ENTRY_CHAIN(Writer)
		END_LOG4CXX_CAST_MAP()

		BufferedWriter(WriterPtr& out);
		BufferedWriter(WriterPtr& out, size_t sz);
		virtual ~BufferedWriter();

		void close(Pool& p) override;
		void flush(Pool& p) override;
		void write(const LogString& str, Pool& p) override;

	private:
		BufferedWriter(const BufferedWriter&);
		BufferedWriter& operator=(const BufferedWriter&);
};

}",1,main\include\log4cxx\helpers\bufferedwriter.hpp,LOG4CXX_NS.helpers,26,helpers,1
63808,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\bytearrayinputstream.hpp,main\include\log4cxx\helpers\bytearrayinputstream.hpp:<global>,,<global>,1
63812,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{

namespace helpers
{
LOG4CXX_LIST_DEF(ByteList, unsigned char);

/**
 * InputStream implemented on top of a byte array.
 */
class LOG4CXX_EXPORT ByteArrayInputStream : public InputStream
{
	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(ByteArrayInputStreamPriv, m_priv)

	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(ByteArrayInputStream)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(ByteArrayInputStream)
		LOG4CXX_CAST_ENTRY_CHAIN(InputStream)
		END_LOG4CXX_CAST_MAP()

		/**
		 * Creates a ByteArrayInputStream.
		 *
		 * @param bytes array of bytes to copy into stream.
		 */
		ByteArrayInputStream(const ByteList& bytes);

		virtual ~ByteArrayInputStream();

		/**
		 * Closes this file input stream and releases any system
		 * resources associated with the stream.
		 */
		void close() override;

		/**
		 * Reads a sequence of bytes into the given buffer.
		 *
		 * @param buf The buffer into which bytes are to be transferred.
		 * @return the total number of bytes...",1,main\include\log4cxx\helpers\bytearrayinputstream.hpp,LOG4CXX_NS,25,LOG4CXX_NS,1
63813,NAMESPACE_BLOCK,"namespace helpers
{
LOG4CXX_LIST_DEF(ByteList, unsigned char);

/**
 * InputStream implemented on top of a byte array.
 */
class LOG4CXX_EXPORT ByteArrayInputStream : public InputStream
{
	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(ByteArrayInputStreamPriv, m_priv)

	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(ByteArrayInputStream)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(ByteArrayInputStream)
		LOG4CXX_CAST_ENTRY_CHAIN(InputStream)
		END_LOG4CXX_CAST_MAP()

		/**
		 * Creates a ByteArrayInputStream.
		 *
		 * @param bytes array of bytes to copy into stream.
		 */
		ByteArrayInputStream(const ByteList& bytes);

		virtual ~ByteArrayInputStream();

		/**
		 * Closes this file input stream and releases any system
		 * resources associated with the stream.
		 */
		void close() override;

		/**
		 * Reads a sequence of bytes into the given buffer.
		 *
		 * @param buf The buffer into which bytes are to be transferred.
		 * @return the total number of bytes read into the buffer, o...",1,main\include\log4cxx\helpers\bytearrayinputstream.hpp,LOG4CXX_NS.helpers,28,helpers,1
63822,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\bytearrayoutputstream.hpp,main\include\log4cxx\helpers\bytearrayoutputstream.hpp:<global>,,<global>,1
63826,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{

namespace helpers
{
class Pool;

LOG4CXX_LIST_DEF(ByteList, unsigned char);

/**
*   OutputStream implemented on top of std::vector
*/
class LOG4CXX_EXPORT ByteArrayOutputStream : public OutputStream
{
	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(ByteArrayOutputStreamPriv, m_priv)

	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(ByteArrayOutputStream)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(ByteArrayOutputStream)
		LOG4CXX_CAST_ENTRY_CHAIN(OutputStream)
		END_LOG4CXX_CAST_MAP()

		ByteArrayOutputStream();
		virtual ~ByteArrayOutputStream();

		void close(Pool& p) override;
		void flush(Pool& p) override;
		void write(ByteBuffer& buf, Pool& p) override;
		ByteList toByteArray() const;

	private:
		ByteArrayOutputStream(const ByteArrayOutputStream&);
		ByteArrayOutputStream& operator=(const ByteArrayOutputStream&);
};

LOG4CXX_PTR_DEF(ByteArrayOutputStream);
} // namespace helpers

}",1,main\include\log4cxx\helpers\bytearrayoutputstream.hpp,LOG4CXX_NS,24,LOG4CXX_NS,1
63827,NAMESPACE_BLOCK,"namespace helpers
{
class Pool;

LOG4CXX_LIST_DEF(ByteList, unsigned char);

/**
*   OutputStream implemented on top of std::vector
*/
class LOG4CXX_EXPORT ByteArrayOutputStream : public OutputStream
{
	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(ByteArrayOutputStreamPriv, m_priv)

	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(ByteArrayOutputStream)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(ByteArrayOutputStream)
		LOG4CXX_CAST_ENTRY_CHAIN(OutputStream)
		END_LOG4CXX_CAST_MAP()

		ByteArrayOutputStream();
		virtual ~ByteArrayOutputStream();

		void close(Pool& p) override;
		void flush(Pool& p) override;
		void write(ByteBuffer& buf, Pool& p) override;
		ByteList toByteArray() const;

	private:
		ByteArrayOutputStream(const ByteArrayOutputStream&);
		ByteArrayOutputStream& operator=(const ByteArrayOutputStream&);
};

LOG4CXX_PTR_DEF(ByteArrayOutputStream);
}",1,main\include\log4cxx\helpers\bytearrayoutputstream.hpp,LOG4CXX_NS.helpers,27,helpers,1
63837,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\bytebuffer.hpp,main\include\log4cxx\helpers\bytebuffer.hpp:<global>,,<global>,1
63841,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{

namespace helpers
{

/**
* A byte buffer.
*/
class LOG4CXX_EXPORT ByteBuffer
{
	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(ByteBufferPriv, m_priv)

	public:
		ByteBuffer(char* data, size_t capacity);
		~ByteBuffer();

		void clear();
		void flip();

		char* data();
		const char* data() const;
		char* current();
		const char* current() const;
		size_t limit() const;
		void limit(size_t newLimit);
		size_t position() const;
		size_t remaining() const;
		void position(size_t newPosition);

		bool put(char byte);


	private:
		ByteBuffer(const ByteBuffer&);
		ByteBuffer& operator=(const ByteBuffer&);
};
} // namespace helpers

}",1,main\include\log4cxx\helpers\bytebuffer.hpp,LOG4CXX_NS,24,LOG4CXX_NS,1
63842,NAMESPACE_BLOCK,"namespace helpers
{

/**
* A byte buffer.
*/
class LOG4CXX_EXPORT ByteBuffer
{
	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(ByteBufferPriv, m_priv)

	public:
		ByteBuffer(char* data, size_t capacity);
		~ByteBuffer();

		void clear();
		void flip();

		char* data();
		const char* data() const;
		char* current();
		const char* current() const;
		size_t limit() const;
		void limit(size_t newLimit);
		size_t position() const;
		size_t remaining() const;
		void position(size_t newPosition);

		bool put(char byte);


	private:
		ByteBuffer(const ByteBuffer&);
		ByteBuffer& operator=(const ByteBuffer&);
};
}",1,main\include\log4cxx\helpers\bytebuffer.hpp,LOG4CXX_NS.helpers,27,helpers,1
63847,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\cacheddateformat.hpp,main\include\log4cxx\helpers\cacheddateformat.hpp:<global>,,<global>,1
63851,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace pattern
{
class LOG4CXX_EXPORT CachedDateFormat : public LOG4CXX_NS::helpers::DateFormat
{
	public:
		enum
		{
			/*
			 *  Constant used to represent that there was no change
			 *  observed when changing the millisecond count.
			 */
			NO_MILLISECONDS = -2,
			/*
			 *  Constant used to represent that there was an
			 *  observed change, but was an expected change.
			 */
			UNRECOGNIZED_MILLISECONDS = -1
		};

	private:
		/**
		 *  Supported digit set.  If the wrapped DateFormat uses
		 *  a different unit set, the millisecond pattern
		 *  will not be recognized and duplicate requests
		 *  will use the cache.
		 */
		static const logchar digits[];


		/**
		 * First magic number (in microseconds) used to detect
		 * the millisecond position.
		 */
		static const int magic1;


		/**
		 *  Expected representation of first magic number in milliseconds.
		 */
		static const logchar magicString1[];


		/**
		 * Second magic number (in microseconds) ...",1,main\include\log4cxx\helpers\cacheddateformat.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
63852,NAMESPACE_BLOCK,"namespace pattern
{
class LOG4CXX_EXPORT CachedDateFormat : public LOG4CXX_NS::helpers::DateFormat
{
	public:
		enum
		{
			/*
			 *  Constant used to represent that there was no change
			 *  observed when changing the millisecond count.
			 */
			NO_MILLISECONDS = -2,
			/*
			 *  Constant used to represent that there was an
			 *  observed change, but was an expected change.
			 */
			UNRECOGNIZED_MILLISECONDS = -1
		};

	private:
		/**
		 *  Supported digit set.  If the wrapped DateFormat uses
		 *  a different unit set, the millisecond pattern
		 *  will not be recognized and duplicate requests
		 *  will use the cache.
		 */
		static const logchar digits[];


		/**
		 * First magic number (in microseconds) used to detect
		 * the millisecond position.
		 */
		static const int magic1;


		/**
		 *  Expected representation of first magic number in milliseconds.
		 */
		static const logchar magicString1[];


		/**
		 * Second magic number (in microseconds) used to detect
		 * the...",1,main\include\log4cxx\helpers\cacheddateformat.hpp,LOG4CXX_NS.pattern,25,pattern,1
63857,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\charsetdecoder.hpp,main\include\log4cxx\helpers\charsetdecoder.hpp:<global>,,<global>,1
63861,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{
class CharsetDecoder;
LOG4CXX_PTR_DEF(CharsetDecoder);
class ByteBuffer;


/**
*   An abstract engine to transform a sequences of bytes in a specific charset
*   into a LogString.
*/
class LOG4CXX_EXPORT CharsetDecoder : public Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(CharsetDecoder)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(CharsetDecoder)
		END_LOG4CXX_CAST_MAP()
	protected:
		/**
		*  Protected constructor.
		*/
		CharsetDecoder();
	public:
		/**
		*  Destructor.
		*/
		virtual ~CharsetDecoder();

		/**
		 *   Get decoder for default charset.
		 */
		static CharsetDecoderPtr getDefaultDecoder();
		/**
		 *  Get decoder for specified character set.
		 *  @param charset the following values should be recognized:
		 *     ""US-ASCII"", ""ISO-8859-1"", ""UTF-8"",
		 *     ""UTF-16BE"", ""UTF-16LE"".
		 *  @return decoder
		 *  @throws IllegalArgumentException if charset is not recognized.
		 */
		static CharsetDecoderPtr getDecoder(co...",1,main\include\log4cxx\helpers\charsetdecoder.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
63862,NAMESPACE_BLOCK,"namespace helpers
{
class CharsetDecoder;
LOG4CXX_PTR_DEF(CharsetDecoder);
class ByteBuffer;


/**
*   An abstract engine to transform a sequences of bytes in a specific charset
*   into a LogString.
*/
class LOG4CXX_EXPORT CharsetDecoder : public Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(CharsetDecoder)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(CharsetDecoder)
		END_LOG4CXX_CAST_MAP()
	protected:
		/**
		*  Protected constructor.
		*/
		CharsetDecoder();
	public:
		/**
		*  Destructor.
		*/
		virtual ~CharsetDecoder();

		/**
		 *   Get decoder for default charset.
		 */
		static CharsetDecoderPtr getDefaultDecoder();
		/**
		 *  Get decoder for specified character set.
		 *  @param charset the following values should be recognized:
		 *     ""US-ASCII"", ""ISO-8859-1"", ""UTF-8"",
		 *     ""UTF-16BE"", ""UTF-16LE"".
		 *  @return decoder
		 *  @throws IllegalArgumentException if charset is not recognized.
		 */
		static CharsetDecoderPtr getDecoder(const LogString& charset)...",1,main\include\log4cxx\helpers\charsetdecoder.hpp,LOG4CXX_NS.helpers,25,helpers,1
63872,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\charsetencoder.hpp,main\include\log4cxx\helpers\charsetencoder.hpp:<global>,,<global>,1
63876,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{

namespace helpers
{
class ByteBuffer;
class CharsetEncoder;
LOG4CXX_PTR_DEF(CharsetEncoder);

/**
*   An engine to transform LogStrings into bytes
*     for the specific character set.
*/
class LOG4CXX_EXPORT CharsetEncoder : public Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(CharsetEncoder)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(CharsetEncoder)
		END_LOG4CXX_CAST_MAP()

	protected:
		/**
		*  Protected constructor.
		*/
		CharsetEncoder();

	public:
		/**
		* Destructor.
		*/
		virtual ~CharsetEncoder();
		/**
		 *  Get encoder for default charset.
		 */
		static CharsetEncoderPtr getDefaultEncoder();

		/**
		 *  Get encoder for specified character set.
		 *  @param charset the following values should be recognized:
		 *     ""US-ASCII"", ""ISO-8859-1"", ""UTF-8"",
		 *     ""UTF-16BE"", ""UTF-16LE"".
		 *  @return encoder.
		 *  @throws IllegalArgumentException if encoding is not recognized.
		 */
		static CharsetEncoderPtr getEncoder(const LogStrin...",1,main\include\log4cxx\helpers\charsetencoder.hpp,LOG4CXX_NS,24,LOG4CXX_NS,1
63877,NAMESPACE_BLOCK,"namespace helpers
{
class ByteBuffer;
class CharsetEncoder;
LOG4CXX_PTR_DEF(CharsetEncoder);

/**
*   An engine to transform LogStrings into bytes
*     for the specific character set.
*/
class LOG4CXX_EXPORT CharsetEncoder : public Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(CharsetEncoder)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(CharsetEncoder)
		END_LOG4CXX_CAST_MAP()

	protected:
		/**
		*  Protected constructor.
		*/
		CharsetEncoder();

	public:
		/**
		* Destructor.
		*/
		virtual ~CharsetEncoder();
		/**
		 *  Get encoder for default charset.
		 */
		static CharsetEncoderPtr getDefaultEncoder();

		/**
		 *  Get encoder for specified character set.
		 *  @param charset the following values should be recognized:
		 *     ""US-ASCII"", ""ISO-8859-1"", ""UTF-8"",
		 *     ""UTF-16BE"", ""UTF-16LE"".
		 *  @return encoder.
		 *  @throws IllegalArgumentException if encoding is not recognized.
		 */
		static CharsetEncoderPtr getEncoder(const LogString& charset);


		/**
		 ...",1,main\include\log4cxx\helpers\charsetencoder.hpp,LOG4CXX_NS.helpers,27,helpers,1
63887,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\class.hpp,main\include\log4cxx\helpers\class.hpp:<global>,,<global>,1
63891,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{
class Object;


class LOG4CXX_EXPORT Class
{
	public:
		virtual ~Class();
		virtual Object* newInstance() const;
		LogString toString() const;
		virtual LogString getName() const = 0;
		static const Class& forName(const LogString& className);
		static bool registerClass(const Class& newClass);

	protected:
		Class();

	private:
		Class(const Class&);
		Class& operator=(const Class&);
		typedef std::map<LogString, const Class*> ClassMap;
		static ClassMap& getRegistry();
		static void registerClasses();
};
}  // namespace helpers
}",1,main\include\log4cxx\helpers\class.hpp,LOG4CXX_NS,24,LOG4CXX_NS,1
63892,NAMESPACE_BLOCK,"namespace helpers
{
class Object;


class LOG4CXX_EXPORT Class
{
	public:
		virtual ~Class();
		virtual Object* newInstance() const;
		LogString toString() const;
		virtual LogString getName() const = 0;
		static const Class& forName(const LogString& className);
		static bool registerClass(const Class& newClass);

	protected:
		Class();

	private:
		Class(const Class&);
		Class& operator=(const Class&);
		typedef std::map<LogString, const Class*> ClassMap;
		static ClassMap& getRegistry();
		static void registerClasses();
};
}",1,main\include\log4cxx\helpers\class.hpp,LOG4CXX_NS.helpers,26,helpers,1
63898,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\classregistration.hpp,main\include\log4cxx\helpers\classregistration.hpp:<global>,,<global>,1
63902,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{
class Class;
class LOG4CXX_EXPORT ClassRegistration
{
	public:
		typedef const Class& (*ClassAccessor)();
		ClassRegistration(ClassAccessor classAccessor);

	private:
		ClassRegistration(const ClassRegistration&);
		ClassRegistration& operator=(const ClassRegistration&);
};
}  // namespace log4cxx
}",1,main\include\log4cxx\helpers\classregistration.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
63903,NAMESPACE_BLOCK,"namespace helpers
{
class Class;
class LOG4CXX_EXPORT ClassRegistration
{
	public:
		typedef const Class& (*ClassAccessor)();
		ClassRegistration(ClassAccessor classAccessor);

	private:
		ClassRegistration(const ClassRegistration&);
		ClassRegistration& operator=(const ClassRegistration&);
};
}",1,main\include\log4cxx\helpers\classregistration.hpp,LOG4CXX_NS.helpers,25,helpers,1
63911,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\cyclicbuffer.hpp,main\include\log4cxx\helpers\cyclicbuffer.hpp:<global>,,<global>,1
63915,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{
/**
CyclicBuffer is used by other appenders to hold instances of
{@link log4cxx::spi::LoggingEvent LoggingEvent} for immediate
or deferred display.
<p>This buffer gives read access to any element in the buffer not
just the first or last element.
*/
class LOG4CXX_EXPORT CyclicBuffer
{
	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(CyclicBufferPriv, m_priv)

	public:
		/**
		Instantiate a new CyclicBuffer of at most <code>maxSize</code>
		events.
		The <code>maxSize</code> argument must a positive integer.
		@param maxSize The maximum number of elements in the buffer.
		@throws IllegalArgumentException if <code>maxSize</code>
		is negative.
		*/
		CyclicBuffer(int maxSize);
		~CyclicBuffer();

		/**
		Add an <code>event</code> as the last event in the buffer.
		*/
		void add(const spi::LoggingEventPtr& event);

		/**
		Get the <i>i</i>th oldest event currently in the buffer. If
		<em>i</em> is outside the range 0 to the number of elements
		c...",1,main\include\log4cxx\helpers\cyclicbuffer.hpp,LOG4CXX_NS,24,LOG4CXX_NS,1
63916,NAMESPACE_BLOCK,"namespace helpers
{
/**
CyclicBuffer is used by other appenders to hold instances of
{@link log4cxx::spi::LoggingEvent LoggingEvent} for immediate
or deferred display.
<p>This buffer gives read access to any element in the buffer not
just the first or last element.
*/
class LOG4CXX_EXPORT CyclicBuffer
{
	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(CyclicBufferPriv, m_priv)

	public:
		/**
		Instantiate a new CyclicBuffer of at most <code>maxSize</code>
		events.
		The <code>maxSize</code> argument must a positive integer.
		@param maxSize The maximum number of elements in the buffer.
		@throws IllegalArgumentException if <code>maxSize</code>
		is negative.
		*/
		CyclicBuffer(int maxSize);
		~CyclicBuffer();

		/**
		Add an <code>event</code> as the last event in the buffer.
		*/
		void add(const spi::LoggingEventPtr& event);

		/**
		Get the <i>i</i>th oldest event currently in the buffer. If
		<em>i</em> is outside the range 0 to the number of elements
		currently in the buffer,...",1,main\include\log4cxx\helpers\cyclicbuffer.hpp,LOG4CXX_NS.helpers,26,helpers,1
63923,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\datagrampacket.hpp,main\include\log4cxx\helpers\datagrampacket.hpp:<global>,,<global>,1
63927,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{

/** This class represents a datagram packet.
<p>Datagram packets are used to implement a connectionless packet
delivery service. Each message is routed from one machine to another
based solely on information contained within that packet. Multiple
packets sent from one machine to another might be routed differently,
and might arrive in any order.
*/
class LOG4CXX_EXPORT DatagramPacket : public helpers::Object
{
	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(DatagramPacketPriv, m_priv)

	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(DatagramPacket)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(DatagramPacket)
		END_LOG4CXX_CAST_MAP()

		/** Constructs a DatagramPacket for receiving packets of length
		<code>length</code>. */
		DatagramPacket(void* buf, int length);

		/** Constructs a datagram packet for sending packets of length
		<code>length</code> to the specified port number on the specified
		host. */
		DatagramPacket(void* buf, int leng...",1,main\include\log4cxx\helpers\datagrampacket.hpp,LOG4CXX_NS,24,LOG4CXX_NS,1
63928,NAMESPACE_BLOCK,"namespace helpers
{

/** This class represents a datagram packet.
<p>Datagram packets are used to implement a connectionless packet
delivery service. Each message is routed from one machine to another
based solely on information contained within that packet. Multiple
packets sent from one machine to another might be routed differently,
and might arrive in any order.
*/
class LOG4CXX_EXPORT DatagramPacket : public helpers::Object
{
	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(DatagramPacketPriv, m_priv)

	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(DatagramPacket)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(DatagramPacket)
		END_LOG4CXX_CAST_MAP()

		/** Constructs a DatagramPacket for receiving packets of length
		<code>length</code>. */
		DatagramPacket(void* buf, int length);

		/** Constructs a datagram packet for sending packets of length
		<code>length</code> to the specified port number on the specified
		host. */
		DatagramPacket(void* buf, int length, InetAddressPtr addr...",1,main\include\log4cxx\helpers\datagrampacket.hpp,LOG4CXX_NS.helpers,26,helpers,1
63940,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\datagramsocket.hpp,main\include\log4cxx\helpers\datagramsocket.hpp:<global>,,<global>,1
63944,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{

class DatagramSocket;
LOG4CXX_PTR_DEF(DatagramSocket);
LOG4CXX_UNIQUE_PTR_DEF(DatagramSocket);

/** This class represents a socket for sending and receiving
datagram packets.*/
class LOG4CXX_EXPORT DatagramSocket : public helpers::Object
{
	protected:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(DatagramSocketPriv, m_priv)
		DatagramSocket(LOG4CXX_PRIVATE_PTR(DatagramSocketPriv) priv);

	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(DatagramSocket)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(DatagramSocket)
		END_LOG4CXX_CAST_MAP()

		/** ensure the socket is closed. */
		virtual ~DatagramSocket();

		/**  Binds a datagram socket to a local port and address.*/
		virtual void bind(int lport, InetAddressPtr laddress) = 0;

		/** Closes this datagram socket */
		virtual void close();

		/** Connects the socket to a remote address for this socket. */
		virtual void connect(InetAddressPtr address, int port) = 0;

		/** Returns the address to which this...",1,main\include\log4cxx\helpers\datagramsocket.hpp,LOG4CXX_NS,26,LOG4CXX_NS,1
63945,NAMESPACE_BLOCK,"namespace helpers
{

class DatagramSocket;
LOG4CXX_PTR_DEF(DatagramSocket);
LOG4CXX_UNIQUE_PTR_DEF(DatagramSocket);

/** This class represents a socket for sending and receiving
datagram packets.*/
class LOG4CXX_EXPORT DatagramSocket : public helpers::Object
{
	protected:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(DatagramSocketPriv, m_priv)
		DatagramSocket(LOG4CXX_PRIVATE_PTR(DatagramSocketPriv) priv);

	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(DatagramSocket)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(DatagramSocket)
		END_LOG4CXX_CAST_MAP()

		/** ensure the socket is closed. */
		virtual ~DatagramSocket();

		/**  Binds a datagram socket to a local port and address.*/
		virtual void bind(int lport, InetAddressPtr laddress) = 0;

		/** Closes this datagram socket */
		virtual void close();

		/** Connects the socket to a remote address for this socket. */
		virtual void connect(InetAddressPtr address, int port) = 0;

		/** Returns the address to which this socket is connected. *...",1,main\include\log4cxx\helpers\datagramsocket.hpp,LOG4CXX_NS.helpers,28,helpers,1
63957,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\date.hpp,main\include\log4cxx\helpers\date.hpp:<global>,,<global>,1
63961,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{
/**
*    Simple transcoder for converting between
*      external char and wchar_t strings and
*      internal strings.
*
*/
class LOG4CXX_EXPORT Date : public Object
{
		const log4cxx_time_t time;

	public:
		DECLARE_LOG4CXX_OBJECT(Date)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(Date)
		END_LOG4CXX_CAST_MAP()

		Date();
		Date(log4cxx_time_t time);
		virtual ~Date();

		inline log4cxx_time_t getTime() const
		{
			return time;
		}

		/**
		 *   Get start of next second
		 */
		log4cxx_time_t getNextSecond() const;


		static log4cxx_time_t getMicrosecondsPerDay();
		static log4cxx_time_t getMicrosecondsPerSecond();
		static log4cxx_time_t getCurrentTimeStd();
		static log4cxx_time_t currentTime();

		/**
		 * A function that will return the current time(in microseconds) when called
		 */
		typedef std::function<log4cxx_time_t()> GetCurrentTimeFn;

		/**
		 * Set the function that is used to get the current time.
		 * This is used onl...",1,main\include\log4cxx\helpers\date.hpp,LOG4CXX_NS,25,LOG4CXX_NS,1
63962,NAMESPACE_BLOCK,"namespace helpers
{
/**
*    Simple transcoder for converting between
*      external char and wchar_t strings and
*      internal strings.
*
*/
class LOG4CXX_EXPORT Date : public Object
{
		const log4cxx_time_t time;

	public:
		DECLARE_LOG4CXX_OBJECT(Date)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(Date)
		END_LOG4CXX_CAST_MAP()

		Date();
		Date(log4cxx_time_t time);
		virtual ~Date();

		inline log4cxx_time_t getTime() const
		{
			return time;
		}

		/**
		 *   Get start of next second
		 */
		log4cxx_time_t getNextSecond() const;


		static log4cxx_time_t getMicrosecondsPerDay();
		static log4cxx_time_t getMicrosecondsPerSecond();
		static log4cxx_time_t getCurrentTimeStd();
		static log4cxx_time_t currentTime();

		/**
		 * A function that will return the current time(in microseconds) when called
		 */
		typedef std::function<log4cxx_time_t()> GetCurrentTimeFn;

		/**
		 * Set the function that is used to get the current time.
		 * This is used only for testing purposes ...",1,main\include\log4cxx\helpers\date.hpp,LOG4CXX_NS.helpers,27,helpers,1
63968,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\dateformat.hpp,main\include\log4cxx\helpers\dateformat.hpp:<global>,,<global>,1
63972,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{

/**
*  DateFormat is an abstract class for date/time formatting
* patterned after java.text.DateFormat.
*/
class LOG4CXX_EXPORT DateFormat : public Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(DateFormat)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(DateFormat)
		END_LOG4CXX_CAST_MAP()

		/**
		*  Destructor
		*/
		virtual ~DateFormat();

		/**
		* Formats an log4cxx_time_t into a date/time string.
		* @param s string to which the date/time string is appended.
		* @param tm date to be formatted.
		* @param p memory pool used during formatting.
		*/
		virtual void format(LogString& s, log4cxx_time_t tm, LOG4CXX_NS::helpers::Pool& p) const = 0;

		/**
		* Sets the time zone.
		* @param zone the given new time zone.
		*/
		virtual void setTimeZone(const TimeZonePtr& zone);

		/**
		* Format an integer consistent with the format method.
		* @param s string to which the numeric string is appended.
		* @param n integer value.
		* @para...",1,main\include\log4cxx\helpers\dateformat.hpp,LOG4CXX_NS,24,LOG4CXX_NS,1
63973,NAMESPACE_BLOCK,"namespace helpers
{

/**
*  DateFormat is an abstract class for date/time formatting
* patterned after java.text.DateFormat.
*/
class LOG4CXX_EXPORT DateFormat : public Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(DateFormat)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(DateFormat)
		END_LOG4CXX_CAST_MAP()

		/**
		*  Destructor
		*/
		virtual ~DateFormat();

		/**
		* Formats an log4cxx_time_t into a date/time string.
		* @param s string to which the date/time string is appended.
		* @param tm date to be formatted.
		* @param p memory pool used during formatting.
		*/
		virtual void format(LogString& s, log4cxx_time_t tm, LOG4CXX_NS::helpers::Pool& p) const = 0;

		/**
		* Sets the time zone.
		* @param zone the given new time zone.
		*/
		virtual void setTimeZone(const TimeZonePtr& zone);

		/**
		* Format an integer consistent with the format method.
		* @param s string to which the numeric string is appended.
		* @param n integer value.
		* @param p memory pool used du...",1,main\include\log4cxx\helpers\dateformat.hpp,LOG4CXX_NS.helpers,26,helpers,1
63979,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\datetimedateformat.hpp,main\include\log4cxx\helpers\datetimedateformat.hpp:<global>,,<global>,1
63983,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{
/**
Formats a date in the format <b>dd MMM yyyy HH:mm:ss,SSS</b> for example,
""06 Nov 1994 15:49:37,459"".
*/
class LOG4CXX_EXPORT DateTimeDateFormat : public SimpleDateFormat
{
	public:
		DateTimeDateFormat()
			: SimpleDateFormat(LOG4CXX_STR(""dd MMM yyyy HH:mm:ss,SSS"")) {}
		DateTimeDateFormat(const std::locale* locale)
			: SimpleDateFormat(LOG4CXX_STR(""dd MMM yyyy HH:mm:ss,SSS""), locale) {}
};
}  // namespace helpers
}",1,main\include\log4cxx\helpers\datetimedateformat.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
63984,NAMESPACE_BLOCK,"namespace helpers
{
/**
Formats a date in the format <b>dd MMM yyyy HH:mm:ss,SSS</b> for example,
""06 Nov 1994 15:49:37,459"".
*/
class LOG4CXX_EXPORT DateTimeDateFormat : public SimpleDateFormat
{
	public:
		DateTimeDateFormat()
			: SimpleDateFormat(LOG4CXX_STR(""dd MMM yyyy HH:mm:ss,SSS"")) {}
		DateTimeDateFormat(const std::locale* locale)
			: SimpleDateFormat(LOG4CXX_STR(""dd MMM yyyy HH:mm:ss,SSS""), locale) {}
};
}",1,main\include\log4cxx\helpers\datetimedateformat.hpp,LOG4CXX_NS.helpers,25,helpers,1
63993,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\exception.hpp,main\include\log4cxx\helpers\exception.hpp:<global>,,<global>,1
63997,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{
/** The class Exception and its subclasses indicate conditions that a
reasonable application might want to catch.
*/
class LOG4CXX_EXPORT Exception : public ::std::exception
{
	public:
		Exception(const char* msg);
		Exception(const LogString& msg);
		Exception(const Exception& src);
		Exception& operator=(const Exception& src);
		const char* what() const throw();
	private:
		enum { MSG_SIZE = 128 };
		char msg[MSG_SIZE + 1];
}; // class Exception

/** RuntimeException is the parent class of those exceptions that can be
thrown during the normal operation of the process.
*/
class LOG4CXX_EXPORT RuntimeException : public Exception
{
	public:
		RuntimeException(log4cxx_status_t stat);
		RuntimeException(const LogString& msg);
		RuntimeException(const RuntimeException& msg);
		RuntimeException& operator=(const RuntimeException& src);
	private:
		static LogString formatMessage(log4cxx_status_t stat);
}; // class RuntimeException

/** Thrown when...",1,main\include\log4cxx\helpers\exception.hpp,LOG4CXX_NS,30,LOG4CXX_NS,1
63998,NAMESPACE_BLOCK,"namespace helpers
{
/** The class Exception and its subclasses indicate conditions that a
reasonable application might want to catch.
*/
class LOG4CXX_EXPORT Exception : public ::std::exception
{
	public:
		Exception(const char* msg);
		Exception(const LogString& msg);
		Exception(const Exception& src);
		Exception& operator=(const Exception& src);
		const char* what() const throw();
	private:
		enum { MSG_SIZE = 128 };
		char msg[MSG_SIZE + 1];
}; // class Exception

/** RuntimeException is the parent class of those exceptions that can be
thrown during the normal operation of the process.
*/
class LOG4CXX_EXPORT RuntimeException : public Exception
{
	public:
		RuntimeException(log4cxx_status_t stat);
		RuntimeException(const LogString& msg);
		RuntimeException(const RuntimeException& msg);
		RuntimeException& operator=(const RuntimeException& src);
	private:
		static LogString formatMessage(log4cxx_status_t stat);
}; // class RuntimeException

/** Thrown when an application attempt...",1,main\include\log4cxx\helpers\exception.hpp,LOG4CXX_NS.helpers,32,helpers,1
64057,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\fileinputstream.hpp,main\include\log4cxx\helpers\fileinputstream.hpp:<global>,,<global>,1
64061,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{

namespace helpers
{

/**
 * InputStream implemented on top of APR file IO.
 *
 */
class LOG4CXX_EXPORT FileInputStream : public InputStream
{
	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(FileInputStreamPrivate, m_priv)

	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(FileInputStream)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(FileInputStream)
		LOG4CXX_CAST_ENTRY_CHAIN(InputStream)
		END_LOG4CXX_CAST_MAP()

		/**
		 * Creates a FileInputStream by opening a connection to an actual
		 * file, the file named by the path name name in the file system.
		 *
		 * @param filename The system-dependent file name.
		 */
		FileInputStream(const LogString& filename);
		FileInputStream(const logchar* filename);

		/**
		 * Creates a FileInputStream by opening a connection to an actual
		 * file, the file named by the File object file in the file system.
		 *
		 * @param aFile The file to be opened for reading.
		 */
		FileInputStream(const File& aFile);

		virtual ~FileI...",1,main\include\log4cxx\helpers\fileinputstream.hpp,LOG4CXX_NS,26,LOG4CXX_NS,1
64062,NAMESPACE_BLOCK,"namespace helpers
{

/**
 * InputStream implemented on top of APR file IO.
 *
 */
class LOG4CXX_EXPORT FileInputStream : public InputStream
{
	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(FileInputStreamPrivate, m_priv)

	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(FileInputStream)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(FileInputStream)
		LOG4CXX_CAST_ENTRY_CHAIN(InputStream)
		END_LOG4CXX_CAST_MAP()

		/**
		 * Creates a FileInputStream by opening a connection to an actual
		 * file, the file named by the path name name in the file system.
		 *
		 * @param filename The system-dependent file name.
		 */
		FileInputStream(const LogString& filename);
		FileInputStream(const logchar* filename);

		/**
		 * Creates a FileInputStream by opening a connection to an actual
		 * file, the file named by the File object file in the file system.
		 *
		 * @param aFile The file to be opened for reading.
		 */
		FileInputStream(const File& aFile);

		virtual ~FileInputStream();

		/**
		 ...",1,main\include\log4cxx\helpers\fileinputstream.hpp,LOG4CXX_NS.helpers,29,helpers,1
64072,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\fileoutputstream.hpp,main\include\log4cxx\helpers\fileoutputstream.hpp:<global>,,<global>,1
64076,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{

namespace helpers
{

/**
*   OutputStream implemented on top of APR file IO.
*/
class LOG4CXX_EXPORT FileOutputStream : public OutputStream
{
	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(FileOutputStreamPrivate, m_priv)

	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(FileOutputStream)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(FileOutputStream)
		LOG4CXX_CAST_ENTRY_CHAIN(OutputStream)
		END_LOG4CXX_CAST_MAP()

		FileOutputStream(const LogString& filename, bool append = false);
		FileOutputStream(const logchar* filename, bool append = false);
		virtual ~FileOutputStream();

		void close(Pool& p) override;
		void flush(Pool& p) override;
		void write(ByteBuffer& buf, Pool& p) override;

		apr_file_t* getFilePtr() const;

	private:
		FileOutputStream(const FileOutputStream&);
		FileOutputStream& operator=(const FileOutputStream&);
		static apr_file_t* open(const LogString& fn, bool append,
			LOG4CXX_NS::helpers::Pool& p);
};

LOG4CXX_PTR_DEF(FileOutputStream...",1,main\include\log4cxx\helpers\fileoutputstream.hpp,LOG4CXX_NS,26,LOG4CXX_NS,1
64077,NAMESPACE_BLOCK,"namespace helpers
{

/**
*   OutputStream implemented on top of APR file IO.
*/
class LOG4CXX_EXPORT FileOutputStream : public OutputStream
{
	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(FileOutputStreamPrivate, m_priv)

	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(FileOutputStream)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(FileOutputStream)
		LOG4CXX_CAST_ENTRY_CHAIN(OutputStream)
		END_LOG4CXX_CAST_MAP()

		FileOutputStream(const LogString& filename, bool append = false);
		FileOutputStream(const logchar* filename, bool append = false);
		virtual ~FileOutputStream();

		void close(Pool& p) override;
		void flush(Pool& p) override;
		void write(ByteBuffer& buf, Pool& p) override;

		apr_file_t* getFilePtr() const;

	private:
		FileOutputStream(const FileOutputStream&);
		FileOutputStream& operator=(const FileOutputStream&);
		static apr_file_t* open(const LogString& fn, bool append,
			LOG4CXX_NS::helpers::Pool& p);
};

LOG4CXX_PTR_DEF(FileOutputStream);
}",1,main\include\log4cxx\helpers\fileoutputstream.hpp,LOG4CXX_NS.helpers,29,helpers,1
64095,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\filewatchdog.hpp,main\include\log4cxx\helpers\filewatchdog.hpp:<global>,,<global>,1
64099,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{

/**
Check every now and then that a certain file has not changed. If it
has, then call the #doOnChange method.
*/
class LOG4CXX_EXPORT FileWatchdog
{
	public:
		virtual ~FileWatchdog();
		/**
		The default delay between every file modification check, set to 60
		seconds.  */
		static long DEFAULT_DELAY /*= 60000*/;

	protected:
		FileWatchdog(const File& filename);
		virtual void doOnChange() = 0;
		void checkAndConfigure();
		const File& file();

	public:
		/**
		Set the delay to observe between each check of the file changes.
		*/
		void setDelay(long delay1);

		/**
		Create a thread that periodically checks for a file change after first calling doOnChange() on the current thread.
		*/
		void start();

		/**
		Stop the thread that periodically checks for a file change.
		*/
		void stop();

		/**
		Is the thread that periodically checks for a file change running?
		*/
		bool is_active();

	private:
		void run();
		bool is_interrupted();
...",1,main\include\log4cxx\helpers\filewatchdog.hpp,LOG4CXX_NS,29,LOG4CXX_NS,1
64100,NAMESPACE_BLOCK,"namespace helpers
{

/**
Check every now and then that a certain file has not changed. If it
has, then call the #doOnChange method.
*/
class LOG4CXX_EXPORT FileWatchdog
{
	public:
		virtual ~FileWatchdog();
		/**
		The default delay between every file modification check, set to 60
		seconds.  */
		static long DEFAULT_DELAY /*= 60000*/;

	protected:
		FileWatchdog(const File& filename);
		virtual void doOnChange() = 0;
		void checkAndConfigure();
		const File& file();

	public:
		/**
		Set the delay to observe between each check of the file changes.
		*/
		void setDelay(long delay1);

		/**
		Create a thread that periodically checks for a file change after first calling doOnChange() on the current thread.
		*/
		void start();

		/**
		Stop the thread that periodically checks for a file change.
		*/
		void stop();

		/**
		Is the thread that periodically checks for a file change running?
		*/
		bool is_active();

	private:
		void run();
		bool is_interrupted();


		FileWatchdog(const ...",1,main\include\log4cxx\helpers\filewatchdog.hpp,LOG4CXX_NS.helpers,31,helpers,1
64111,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\inetaddress.hpp,main\include\log4cxx\helpers\inetaddress.hpp:<global>,,<global>,1
64115,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{
class UnknownHostException : public Exception
{
	public:
		UnknownHostException(const LogString& msg);
		UnknownHostException(const UnknownHostException& src);
		UnknownHostException& operator=(const UnknownHostException& src);
};


class InetAddress;
LOG4CXX_PTR_DEF(InetAddress);
LOG4CXX_LIST_DEF(InetAddressList, InetAddressPtr);

class LOG4CXX_EXPORT InetAddress : public Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(InetAddress)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(InetAddress)
		END_LOG4CXX_CAST_MAP()

		InetAddress(const LogString& hostName, const LogString& hostAddr);

		~InetAddress();

		/** Determines all the IP addresses of a host, given the host's name.
		*/
		static InetAddressList getAllByName(const LogString& host);

		/** Determines the IP address of a host, given the host's name.
		*/
		static InetAddressPtr getByName(const LogString& host);

		/** Returns the IP address string ""%d.%d.%d.%d"".
		*/
		LogString...",1,main\include\log4cxx\helpers\inetaddress.hpp,LOG4CXX_NS,26,LOG4CXX_NS,1
64116,NAMESPACE_BLOCK,"namespace helpers
{
class UnknownHostException : public Exception
{
	public:
		UnknownHostException(const LogString& msg);
		UnknownHostException(const UnknownHostException& src);
		UnknownHostException& operator=(const UnknownHostException& src);
};


class InetAddress;
LOG4CXX_PTR_DEF(InetAddress);
LOG4CXX_LIST_DEF(InetAddressList, InetAddressPtr);

class LOG4CXX_EXPORT InetAddress : public Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(InetAddress)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(InetAddress)
		END_LOG4CXX_CAST_MAP()

		InetAddress(const LogString& hostName, const LogString& hostAddr);

		~InetAddress();

		/** Determines all the IP addresses of a host, given the host's name.
		*/
		static InetAddressList getAllByName(const LogString& host);

		/** Determines the IP address of a host, given the host's name.
		*/
		static InetAddressPtr getByName(const LogString& host);

		/** Returns the IP address string ""%d.%d.%d.%d"".
		*/
		LogString getHostAddress() const...",1,main\include\log4cxx\helpers\inetaddress.hpp,LOG4CXX_NS.helpers,28,helpers,1
64140,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\inputstream.hpp,main\include\log4cxx\helpers\inputstream.hpp:<global>,,<global>,1
64144,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{

namespace helpers
{
class ByteBuffer;

/**
 * Abstract class for reading from character streams.
 *
 */
class LOG4CXX_EXPORT InputStream : public Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(InputStream)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(InputStream)
		END_LOG4CXX_CAST_MAP()

	protected:
		InputStream();

		virtual ~InputStream();

	public:
		/**
		 * Reads a sequence of bytes into the given buffer.
		 *
		 * @param dst The buffer into which bytes are to be transferred.
		 * @return the total number of bytes read into the buffer, or -1 if there
		 *         is no more data because the end of the stream has been reached.
		 */
		virtual int read(ByteBuffer& dst) = 0;

		/**
		 * Closes this input stream and releases any system
		 * resources associated with the stream.
		 */
		virtual void close() = 0;

	private:
		InputStream(const InputStream&);
		InputStream& operator=(const InputStream&);
};

LOG4CXX_PTR_DEF(InputStream);
} // namespac...",1,main\include\log4cxx\helpers\inputstream.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
64145,NAMESPACE_BLOCK,"namespace helpers
{
class ByteBuffer;

/**
 * Abstract class for reading from character streams.
 *
 */
class LOG4CXX_EXPORT InputStream : public Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(InputStream)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(InputStream)
		END_LOG4CXX_CAST_MAP()

	protected:
		InputStream();

		virtual ~InputStream();

	public:
		/**
		 * Reads a sequence of bytes into the given buffer.
		 *
		 * @param dst The buffer into which bytes are to be transferred.
		 * @return the total number of bytes read into the buffer, or -1 if there
		 *         is no more data because the end of the stream has been reached.
		 */
		virtual int read(ByteBuffer& dst) = 0;

		/**
		 * Closes this input stream and releases any system
		 * resources associated with the stream.
		 */
		virtual void close() = 0;

	private:
		InputStream(const InputStream&);
		InputStream& operator=(const InputStream&);
};

LOG4CXX_PTR_DEF(InputStream);
}",1,main\include\log4cxx\helpers\inputstream.hpp,LOG4CXX_NS.helpers,26,helpers,1
64156,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\inputstreamreader.hpp,main\include\log4cxx\helpers\inputstreamreader.hpp:<global>,,<global>,1
64162,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{

namespace helpers
{

/**
 * Class for reading from character streams.
 * Decorates a byte based InputStream and provides appropriate
 * conversion to characters.
 */
class LOG4CXX_EXPORT InputStreamReader : public Reader
{
	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(InputStreamReaderPrivate, m_priv)

	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(InputStreamReader)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(InputStreamReader)
		LOG4CXX_CAST_ENTRY_CHAIN(Reader)
		END_LOG4CXX_CAST_MAP()

		/**
		 * Creates an InputStreamReader that uses the default charset.
		 *
		 * @param in The input stream to decorate.
		 */
		InputStreamReader(const InputStreamPtr& in);

		/**
		 * Creates an InputStreamReader that uses the given charset decoder.
		 *
		 * @param in The input stream to decorate.
		 * @param enc The charset decoder to use for the conversion.
		 */
		InputStreamReader(const InputStreamPtr& in, const CharsetDecoderPtr& enc);

		~InputStreamReader();

		/*...",1,main\include\log4cxx\helpers\inputstreamreader.hpp,LOG4CXX_NS,29,LOG4CXX_NS,3
64163,NAMESPACE_BLOCK,"namespace helpers
{

/**
 * Class for reading from character streams.
 * Decorates a byte based InputStream and provides appropriate
 * conversion to characters.
 */
class LOG4CXX_EXPORT InputStreamReader : public Reader
{
	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(InputStreamReaderPrivate, m_priv)

	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(InputStreamReader)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(InputStreamReader)
		LOG4CXX_CAST_ENTRY_CHAIN(Reader)
		END_LOG4CXX_CAST_MAP()

		/**
		 * Creates an InputStreamReader that uses the default charset.
		 *
		 * @param in The input stream to decorate.
		 */
		InputStreamReader(const InputStreamPtr& in);

		/**
		 * Creates an InputStreamReader that uses the given charset decoder.
		 *
		 * @param in The input stream to decorate.
		 * @param enc The charset decoder to use for the conversion.
		 */
		InputStreamReader(const InputStreamPtr& in, const CharsetDecoderPtr& enc);

		~InputStreamReader();

		/**
		 * Closes the stream...",1,main\include\log4cxx\helpers\inputstreamreader.hpp,LOG4CXX_NS.helpers,32,helpers,1
64169,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\integer.hpp,main\include\log4cxx\helpers\integer.hpp:<global>,,<global>,1
64173,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{
class LOG4CXX_EXPORT Integer : public Object
{
		const int val;
	public:
		DECLARE_LOG4CXX_OBJECT(Integer)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(Integer)
		END_LOG4CXX_CAST_MAP()

		Integer();
		Integer(int i);
		virtual ~Integer();

		inline int intValue() const
		{
			return val;
		}

};

LOG4CXX_PTR_DEF(Integer);

}
}",1,main\include\log4cxx\helpers\integer.hpp,LOG4CXX_NS,24,LOG4CXX_NS,1
64174,NAMESPACE_BLOCK,"namespace helpers
{
class LOG4CXX_EXPORT Integer : public Object
{
		const int val;
	public:
		DECLARE_LOG4CXX_OBJECT(Integer)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(Integer)
		END_LOG4CXX_CAST_MAP()

		Integer();
		Integer(int i);
		virtual ~Integer();

		inline int intValue() const
		{
			return val;
		}

};

LOG4CXX_PTR_DEF(Integer);

}",1,main\include\log4cxx\helpers\integer.hpp,LOG4CXX_NS.helpers,26,helpers,1
64180,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\iso8601dateformat.hpp,main\include\log4cxx\helpers\iso8601dateformat.hpp:<global>,,<global>,1
64184,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{
/**
Formats a date in the format <b>yyyy-MM-dd HH:mm:ss,SSS</b> for example
""1999-11-27 15:49:37,459"".

<p>Refer to the
<a href=http://www.cl.cam.ac.uk/~mgk25/iso-time.html>summary of the
International Standard Date and Time Notation</a> for more
information on this format.
*/
class LOG4CXX_EXPORT ISO8601DateFormat : public SimpleDateFormat
{
	public:
		ISO8601DateFormat()
			: SimpleDateFormat(LOG4CXX_STR(""yyyy-MM-dd HH:mm:ss,SSS"")) {}
};
}  // namespace helpers
}",1,main\include\log4cxx\helpers\iso8601dateformat.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
64185,NAMESPACE_BLOCK,"namespace helpers
{
/**
Formats a date in the format <b>yyyy-MM-dd HH:mm:ss,SSS</b> for example
""1999-11-27 15:49:37,459"".

<p>Refer to the
<a href=http://www.cl.cam.ac.uk/~mgk25/iso-time.html>summary of the
International Standard Date and Time Notation</a> for more
information on this format.
*/
class LOG4CXX_EXPORT ISO8601DateFormat : public SimpleDateFormat
{
	public:
		ISO8601DateFormat()
			: SimpleDateFormat(LOG4CXX_STR(""yyyy-MM-dd HH:mm:ss,SSS"")) {}
};
}",1,main\include\log4cxx\helpers\iso8601dateformat.hpp,LOG4CXX_NS.helpers,25,helpers,1
64196,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\loader.hpp,main\include\log4cxx\helpers\loader.hpp:<global>,,<global>,1
64200,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{
class Class;

class LOG4CXX_EXPORT Loader
{
	public:
		static const Class& loadClass(const LogString& clazz);

		static InputStreamPtr getResourceAsStream(
			const LogString& name);
};
}  // namespace helpers
}",1,main\include\log4cxx\helpers\loader.hpp,LOG4CXX_NS,27,LOG4CXX_NS,1
64201,NAMESPACE_BLOCK,"namespace helpers
{
class Class;

class LOG4CXX_EXPORT Loader
{
	public:
		static const Class& loadClass(const LogString& clazz);

		static InputStreamPtr getResourceAsStream(
			const LogString& name);
};
}",1,main\include\log4cxx\helpers\loader.hpp,LOG4CXX_NS.helpers,29,helpers,1
64209,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\locale.hpp,main\include\log4cxx\helpers\locale.hpp:<global>,,<global>,1
64213,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{
class LOG4CXX_EXPORT Locale
{
	public:
		Locale(const LogString& language);
		Locale(const LogString& language, const LogString& country);
		Locale(const LogString& language, const LogString& country,
			const LogString& variant);
		~Locale();

		const LogString& getLanguage() const;
		const LogString& getCountry() const;
		const LogString& getVariant() const;

	protected:
		Locale(const Locale&);
		Locale& operator=(const Locale&);
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(LocalePrivate, m_priv)
}; // class Locale
}  // namespace helpers
}",1,main\include\log4cxx\helpers\locale.hpp,LOG4CXX_NS,24,LOG4CXX_NS,1
64214,NAMESPACE_BLOCK,"namespace helpers
{
class LOG4CXX_EXPORT Locale
{
	public:
		Locale(const LogString& language);
		Locale(const LogString& language, const LogString& country);
		Locale(const LogString& language, const LogString& country,
			const LogString& variant);
		~Locale();

		const LogString& getLanguage() const;
		const LogString& getCountry() const;
		const LogString& getVariant() const;

	protected:
		Locale(const Locale&);
		Locale& operator=(const Locale&);
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(LocalePrivate, m_priv)
}; // class Locale
}",1,main\include\log4cxx\helpers\locale.hpp,LOG4CXX_NS.helpers,26,helpers,1
64225,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\loglog.hpp,main\include\log4cxx\helpers\loglog.hpp:<global>,,<global>,1
64229,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{
/**
This class used to output log statements from within the log4cxx package.

<p>Log4cxx components cannot make log4cxx logging calls. However, it is
sometimes useful for the user to learn about what log4cxx is
doing. You can enable log4cxx internal debug logging by calling the
<b>#setInternalDebugging</b> method.

<p>All LogLog messages are written to SystemErrWriter
prepended with the string ""log4cxx: "".
*/
class LOG4CXX_EXPORT LogLog
{
	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(LogLogPrivate, m_priv)

		friend WideLife<LogLog>;
		LogLog();
		LogLog(const LogLog&);
		LogLog& operator=(const LogLog&);
		static LogLog& getInstance();

	public:
		~LogLog();

		/**
		Use the value of \c enabled as the new internal debug logging state.
		*/
		static void setInternalDebugging(bool enabled);

		/**
		Output \c msg to SystemErrWriter if internal debug logging is enabled.
		*/
		static void debug(const LogString& msg);
		/**
		Output \c msg a...",1,main\include\log4cxx\helpers\loglog.hpp,LOG4CXX_NS,26,LOG4CXX_NS,1
64230,NAMESPACE_BLOCK,"namespace helpers
{
/**
This class used to output log statements from within the log4cxx package.

<p>Log4cxx components cannot make log4cxx logging calls. However, it is
sometimes useful for the user to learn about what log4cxx is
doing. You can enable log4cxx internal debug logging by calling the
<b>#setInternalDebugging</b> method.

<p>All LogLog messages are written to SystemErrWriter
prepended with the string ""log4cxx: "".
*/
class LOG4CXX_EXPORT LogLog
{
	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(LogLogPrivate, m_priv)

		friend WideLife<LogLog>;
		LogLog();
		LogLog(const LogLog&);
		LogLog& operator=(const LogLog&);
		static LogLog& getInstance();

	public:
		~LogLog();

		/**
		Use the value of \c enabled as the new internal debug logging state.
		*/
		static void setInternalDebugging(bool enabled);

		/**
		Output \c msg to SystemErrWriter if internal debug logging is enabled.
		*/
		static void debug(const LogString& msg);
		/**
		Output \c msg and <code>ex.what()</cod...",1,main\include\log4cxx\helpers\loglog.hpp,LOG4CXX_NS.helpers,28,helpers,1
64239,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\messagebuffer.hpp,main\include\log4cxx\helpers\messagebuffer.hpp:<global>,,<global>,1
64243,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{


namespace helpers
{

typedef std::ios_base& (*ios_base_manip)(std::ios_base&);

/**
 *   This class is used by the LOG4CXX_INFO and similar
 *   macros to support insertion operators in the message parameter.
 *   The class is not intended for use outside of that context.
 */
class LOG4CXX_EXPORT CharMessageBuffer
{
	public:
		/**
		 *  Creates a new instance.
		 */
		CharMessageBuffer();
		/**
		 *  Destructor.
		 */
		~CharMessageBuffer();


		/**
		 *   Appends string to buffer.
		 *   @param msg string append.
		 *   @return this buffer.
		 */
		CharMessageBuffer& operator<<(const std::basic_string<char>& msg);
		/**
		 *   Appends string to buffer.
		 *   @param msg string to append.
		 *   @return this buffer.
		 */
		CharMessageBuffer& operator<<(const char* msg);
		/**
		 *   Appends string to buffer.
		 *   @param msg string to append.
		 *   @return this buffer.
		 */
		CharMessageBuffer& operator<<(char* msg);

		/**
		 *   Appends character to bu...",1,main\include\log4cxx\helpers\messagebuffer.hpp,LOG4CXX_NS,25,LOG4CXX_NS,1
64244,NAMESPACE_BLOCK,"namespace helpers
{

typedef std::ios_base& (*ios_base_manip)(std::ios_base&);

/**
 *   This class is used by the LOG4CXX_INFO and similar
 *   macros to support insertion operators in the message parameter.
 *   The class is not intended for use outside of that context.
 */
class LOG4CXX_EXPORT CharMessageBuffer
{
	public:
		/**
		 *  Creates a new instance.
		 */
		CharMessageBuffer();
		/**
		 *  Destructor.
		 */
		~CharMessageBuffer();


		/**
		 *   Appends string to buffer.
		 *   @param msg string append.
		 *   @return this buffer.
		 */
		CharMessageBuffer& operator<<(const std::basic_string<char>& msg);
		/**
		 *   Appends string to buffer.
		 *   @param msg string to append.
		 *   @return this buffer.
		 */
		CharMessageBuffer& operator<<(const char* msg);
		/**
		 *   Appends string to buffer.
		 *   @param msg string to append.
		 *   @return this buffer.
		 */
		CharMessageBuffer& operator<<(char* msg);

		/**
		 *   Appends character to buffer.
		 *   @param msg c...",1,main\include\log4cxx\helpers\messagebuffer.hpp,LOG4CXX_NS.helpers,29,helpers,1
64274,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\object.hpp,main\include\log4cxx\helpers\object.hpp:<global>,,<global>,1
64278,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
class AppenderSkeleton;
class Logger;

namespace helpers
{
class Pool;

/** base class for java-like objects.*/
class LOG4CXX_EXPORT Object
{
	public:
		virtual ~Object() {}
		virtual const helpers::Class& getClass() const = 0;
		virtual bool instanceof(const Class& clazz) const = 0;
		virtual const void* cast(const Class& clazz) const = 0;
		DECLARE_LOG4CXX_CLAZZ_OBJECT(Object)
};
LOG4CXX_PTR_DEF(Object);
}

/**
 * Attempt to cast one Object to another kind of Object.
 *
 * On success, returns a new shared pointer that points at incoming.
 * On failure, returns an invalid shared pointer.
 */
template<typename Ret,
	typename Type,
	bool = std::is_base_of<Ret, helpers::Object>::value,
	bool = std::is_base_of<Type, helpers::Object>::value>
std::shared_ptr<Ret> cast(const std::shared_ptr<Type>& incoming)
{
	if(!incoming)
	{
		return std::shared_ptr<Ret>();
	}

	Ret* casted = reinterpret_cast<Ret*>(const_cast<void*>(incoming->cast(Ret::getStaticClass())));

	if ( ...",1,main\include\log4cxx\helpers\object.hpp,LOG4CXX_NS,95,LOG4CXX_NS,1
64281,NAMESPACE_BLOCK,"namespace helpers
{
class Pool;

/** base class for java-like objects.*/
class LOG4CXX_EXPORT Object
{
	public:
		virtual ~Object() {}
		virtual const helpers::Class& getClass() const = 0;
		virtual bool instanceof(const Class& clazz) const = 0;
		virtual const void* cast(const Class& clazz) const = 0;
		DECLARE_LOG4CXX_CLAZZ_OBJECT(Object)
};
LOG4CXX_PTR_DEF(Object);
}",1,main\include\log4cxx\helpers\object.hpp,LOG4CXX_NS.helpers,100,helpers,3
64338,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\onlyonceerrorhandler.hpp,main\include\log4cxx\helpers\onlyonceerrorhandler.hpp:<global>,,<global>,1
64342,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{
/**
The <code>OnlyOnceErrorHandler</code> implements log4cxx's default
error handling policy which consists of emitting a message for the
first error in an appender and ignoring all following errors.

<p>The error message is printed on <code>System.err</code>.

<p>This policy aims at protecting an otherwise working application
from being flooded with error messages when logging fails
*/
class LOG4CXX_EXPORT OnlyOnceErrorHandler :
	public virtual spi::ErrorHandler,
	public virtual Object
{
	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(OnlyOnceErrorHandlerPrivate, m_priv)

	public:
		DECLARE_LOG4CXX_OBJECT(OnlyOnceErrorHandler)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(spi::OptionHandler)
		LOG4CXX_CAST_ENTRY(spi::ErrorHandler)
		END_LOG4CXX_CAST_MAP()

		OnlyOnceErrorHandler();

		~OnlyOnceErrorHandler();

		/**
		 Does not do anything.
		 */
		void setLogger(const LoggerPtr& logger) override;


		/**
		\copybrief spi::OptionHandler::...",1,main\include\log4cxx\helpers\onlyonceerrorhandler.hpp,LOG4CXX_NS,24,LOG4CXX_NS,1
64343,NAMESPACE_BLOCK,"namespace helpers
{
/**
The <code>OnlyOnceErrorHandler</code> implements log4cxx's default
error handling policy which consists of emitting a message for the
first error in an appender and ignoring all following errors.

<p>The error message is printed on <code>System.err</code>.

<p>This policy aims at protecting an otherwise working application
from being flooded with error messages when logging fails
*/
class LOG4CXX_EXPORT OnlyOnceErrorHandler :
	public virtual spi::ErrorHandler,
	public virtual Object
{
	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(OnlyOnceErrorHandlerPrivate, m_priv)

	public:
		DECLARE_LOG4CXX_OBJECT(OnlyOnceErrorHandler)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(spi::OptionHandler)
		LOG4CXX_CAST_ENTRY(spi::ErrorHandler)
		END_LOG4CXX_CAST_MAP()

		OnlyOnceErrorHandler();

		~OnlyOnceErrorHandler();

		/**
		 Does not do anything.
		 */
		void setLogger(const LoggerPtr& logger) override;


		/**
		\copybrief spi::OptionHandler::activateOptions()

		No...",1,main\include\log4cxx\helpers\onlyonceerrorhandler.hpp,LOG4CXX_NS.helpers,26,helpers,1
64350,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\optionconverter.hpp,main\include\log4cxx\helpers\optionconverter.hpp:<global>,,<global>,1
64354,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
class Level;
class File;
typedef std::shared_ptr<Level> LevelPtr;

namespace spi
{
class LoggerRepository;
typedef std::shared_ptr<LoggerRepository> LoggerRepositoryPtr;
}

namespace helpers
{
class Properties;

class Object;
typedef std::shared_ptr<Object> ObjectPtr;

class Class;

/** A convenience class to convert property values to specific types.*/
class LOG4CXX_EXPORT OptionConverter
{
		/** OptionConverter is a static class. */
	private:
		OptionConverter() {}

	public:
		static LogString convertSpecialChars(const LogString& s);

		/**
		 The boolean equivalent of \c value if it is not empty, otherwise \c defaultValue.

		If <code>value</code> is ""true"", then <code>true</code> is
		returned. If <code>value</code> is ""false"", then
		<code>true</code> is returned. Case of \c value is unimportant.

		@return  <code>defaultValue</code> if \c value is not ""true"" or ""false"", otherwise the boolean equivalent of \c value
		*/
		static bool toBoolean(const LogSt...",1,main\include\log4cxx\helpers\optionconverter.hpp,LOG4CXX_NS,24,LOG4CXX_NS,1
64358,NAMESPACE_BLOCK,"namespace spi
{
class LoggerRepository;
typedef std::shared_ptr<LoggerRepository> LoggerRepositoryPtr;
}",1,main\include\log4cxx\helpers\optionconverter.hpp,LOG4CXX_NS.spi,30,spi,4
64361,NAMESPACE_BLOCK,"namespace helpers
{
class Properties;

class Object;
typedef std::shared_ptr<Object> ObjectPtr;

class Class;

/** A convenience class to convert property values to specific types.*/
class LOG4CXX_EXPORT OptionConverter
{
		/** OptionConverter is a static class. */
	private:
		OptionConverter() {}

	public:
		static LogString convertSpecialChars(const LogString& s);

		/**
		 The boolean equivalent of \c value if it is not empty, otherwise \c defaultValue.

		If <code>value</code> is ""true"", then <code>true</code> is
		returned. If <code>value</code> is ""false"", then
		<code>true</code> is returned. Case of \c value is unimportant.

		@return  <code>defaultValue</code> if \c value is not ""true"" or ""false"", otherwise the boolean equivalent of \c value
		*/
		static bool toBoolean(const LogString& value, bool defaultValue);
		/**
		 The numeric equivalent of \c value if it is not empty, otherwise \c defaultValue.

		@return Zero if \c value does not begin with a valid integral number ...",1,main\include\log4cxx\helpers\optionconverter.hpp,LOG4CXX_NS.helpers,36,helpers,5
64370,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\outputstream.hpp,main\include\log4cxx\helpers\outputstream.hpp:<global>,,<global>,1
64374,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{

namespace helpers
{
class ByteBuffer;

/**
*   Abstract class for writing to character streams.
*/
class LOG4CXX_EXPORT OutputStream : public Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(OutputStream)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(OutputStream)
		END_LOG4CXX_CAST_MAP()

	protected:
		OutputStream();
		virtual ~OutputStream();

	public:
		virtual void close(Pool& p) = 0;
		virtual void flush(Pool& p) = 0;
		virtual void write(ByteBuffer& buf, Pool& p) = 0;

	private:
		OutputStream(const OutputStream&);
		OutputStream& operator=(const OutputStream&);
};

LOG4CXX_PTR_DEF(OutputStream);
} // namespace helpers

}",1,main\include\log4cxx\helpers\outputstream.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
64375,NAMESPACE_BLOCK,"namespace helpers
{
class ByteBuffer;

/**
*   Abstract class for writing to character streams.
*/
class LOG4CXX_EXPORT OutputStream : public Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(OutputStream)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(OutputStream)
		END_LOG4CXX_CAST_MAP()

	protected:
		OutputStream();
		virtual ~OutputStream();

	public:
		virtual void close(Pool& p) = 0;
		virtual void flush(Pool& p) = 0;
		virtual void write(ByteBuffer& buf, Pool& p) = 0;

	private:
		OutputStream(const OutputStream&);
		OutputStream& operator=(const OutputStream&);
};

LOG4CXX_PTR_DEF(OutputStream);
}",1,main\include\log4cxx\helpers\outputstream.hpp,LOG4CXX_NS.helpers,26,helpers,1
64386,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\outputstreamwriter.hpp,main\include\log4cxx\helpers\outputstreamwriter.hpp:<global>,,<global>,1
64390,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{

namespace helpers
{

/**
*   Abstract class for writing to character streams.
*/
class LOG4CXX_EXPORT OutputStreamWriter : public Writer
{
	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(OutputStreamWriterPrivate, m_priv)

	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(OutputStreamWriter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(OutputStreamWriter)
		LOG4CXX_CAST_ENTRY_CHAIN(Writer)
		END_LOG4CXX_CAST_MAP()

		OutputStreamWriter(OutputStreamPtr& out);
		OutputStreamWriter(OutputStreamPtr& out, CharsetEncoderPtr& enc);
		~OutputStreamWriter();

		void close(Pool& p) override;
		void flush(Pool& p) override;
		void write(const LogString& str, Pool& p) override;
		LogString getEncoding() const;

		OutputStreamPtr getOutputStreamPtr() const;

	private:
		OutputStreamWriter(const OutputStreamWriter&);
		OutputStreamWriter& operator=(const OutputStreamWriter&);
};

LOG4CXX_PTR_DEF(OutputStreamWriter);
} // namespace helpers

}",1,main\include\log4cxx\helpers\outputstreamwriter.hpp,LOG4CXX_NS,25,LOG4CXX_NS,1
64391,NAMESPACE_BLOCK,"namespace helpers
{

/**
*   Abstract class for writing to character streams.
*/
class LOG4CXX_EXPORT OutputStreamWriter : public Writer
{
	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(OutputStreamWriterPrivate, m_priv)

	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(OutputStreamWriter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(OutputStreamWriter)
		LOG4CXX_CAST_ENTRY_CHAIN(Writer)
		END_LOG4CXX_CAST_MAP()

		OutputStreamWriter(OutputStreamPtr& out);
		OutputStreamWriter(OutputStreamPtr& out, CharsetEncoderPtr& enc);
		~OutputStreamWriter();

		void close(Pool& p) override;
		void flush(Pool& p) override;
		void write(const LogString& str, Pool& p) override;
		LogString getEncoding() const;

		OutputStreamPtr getOutputStreamPtr() const;

	private:
		OutputStreamWriter(const OutputStreamWriter&);
		OutputStreamWriter& operator=(const OutputStreamWriter&);
};

LOG4CXX_PTR_DEF(OutputStreamWriter);
}",1,main\include\log4cxx\helpers\outputstreamwriter.hpp,LOG4CXX_NS.helpers,28,helpers,1
64399,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\pool.hpp,main\include\log4cxx\helpers\pool.hpp:<global>,,<global>,1
64404,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{
class LOG4CXX_EXPORT Pool
{
	public:
		Pool();
		Pool(apr_pool_t* pool, bool release);
		~Pool();

		apr_pool_t* getAPRPool();
		apr_pool_t* create();
		void* palloc(size_t length);
		char* pstralloc(size_t length);
		char* itoa(int n);
		char* pstrndup(const char* s, size_t len);
		char* pstrdup(const char* s);
		char* pstrdup(const std::string&);

	protected:
		apr_pool_t* pool;
		const bool release;

	private:
		Pool(const LOG4CXX_NS::helpers::Pool&);
		Pool& operator=(const Pool&);
};
} // namespace helpers
}",1,main\include\log4cxx\helpers\pool.hpp,LOG4CXX_NS,28,LOG4CXX_NS,2
64405,NAMESPACE_BLOCK,"namespace helpers
{
class LOG4CXX_EXPORT Pool
{
	public:
		Pool();
		Pool(apr_pool_t* pool, bool release);
		~Pool();

		apr_pool_t* getAPRPool();
		apr_pool_t* create();
		void* palloc(size_t length);
		char* pstralloc(size_t length);
		char* itoa(int n);
		char* pstrndup(const char* s, size_t len);
		char* pstrdup(const char* s);
		char* pstrdup(const std::string&);

	protected:
		apr_pool_t* pool;
		const bool release;

	private:
		Pool(const LOG4CXX_NS::helpers::Pool&);
		Pool& operator=(const Pool&);
};
}",1,main\include\log4cxx\helpers\pool.hpp,LOG4CXX_NS.helpers,30,helpers,1
64420,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\properties.hpp,main\include\log4cxx\helpers\properties.hpp:<global>,,<global>,1
64424,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{
class LOG4CXX_EXPORT Properties
{
	private:
		typedef std::map<LogString, LogString> PropertyMap;
		PropertyMap* properties;
		Properties(const Properties&);
		Properties& operator=(const Properties&);

	public:
		/**
		 *  Create new instance.
		 */
		Properties();
		/**
		 * Destructor.
		 */
		~Properties();
		/**
		Reads a property list (key and element pairs) from the input stream.
		The stream is assumed to be using the ISO 8859-1 character encoding.

		<p>Every property occupies one line of the input stream.
		Each line is terminated by a line terminator (<code>\\n</code> or
		<code>\\r</code> or <code>\\r\\n</code>).
		Lines from the input stream are processed until end of file is reached
		on the input stream.

		<p>A line that contains only whitespace or whose first non-whitespace
		character is an ASCII <code>#</code> or <code>!</code> is ignored
		(thus, <code>#</code> or <code>!</code> indicate comment lines).

		<p>Every line ...",1,main\include\log4cxx\helpers\properties.hpp,LOG4CXX_NS,28,LOG4CXX_NS,1
64425,NAMESPACE_BLOCK,"namespace helpers
{
class LOG4CXX_EXPORT Properties
{
	private:
		typedef std::map<LogString, LogString> PropertyMap;
		PropertyMap* properties;
		Properties(const Properties&);
		Properties& operator=(const Properties&);

	public:
		/**
		 *  Create new instance.
		 */
		Properties();
		/**
		 * Destructor.
		 */
		~Properties();
		/**
		Reads a property list (key and element pairs) from the input stream.
		The stream is assumed to be using the ISO 8859-1 character encoding.

		<p>Every property occupies one line of the input stream.
		Each line is terminated by a line terminator (<code>\\n</code> or
		<code>\\r</code> or <code>\\r\\n</code>).
		Lines from the input stream are processed until end of file is reached
		on the input stream.

		<p>A line that contains only whitespace or whose first non-whitespace
		character is an ASCII <code>#</code> or <code>!</code> is ignored
		(thus, <code>#</code> or <code>!</code> indicate comment lines).

		<p>Every line other than a blank line...",1,main\include\log4cxx\helpers\properties.hpp,LOG4CXX_NS.helpers,30,helpers,1
64434,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\propertyresourcebundle.hpp,main\include\log4cxx\helpers\propertyresourcebundle.hpp:<global>,,<global>,1
64438,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{

/**
PropertyResourceBundle is a concrete subclass of ResourceBundle that
manages resources for a locale using a set of static strings from a
property file.
*/
class LOG4CXX_EXPORT PropertyResourceBundle : public ResourceBundle
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(PropertyResourceBundle)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(PropertyResourceBundle)
		LOG4CXX_CAST_ENTRY_CHAIN(ResourceBundle)
		END_LOG4CXX_CAST_MAP()

		/**
		Creates a property resource bundle.
		@param inStream property file to read from.
		@throw IOException if an error occurred when reading from the
		input stream.
		*/
		PropertyResourceBundle(InputStreamPtr inStream);

		LogString getString(const LogString& key) const override;

	protected:
		Properties properties;
}; // class PropertyResourceBundle
LOG4CXX_PTR_DEF(PropertyResourceBundle);
}  // namespace helpers
}",1,main\include\log4cxx\helpers\propertyresourcebundle.hpp,LOG4CXX_NS,25,LOG4CXX_NS,1
64439,NAMESPACE_BLOCK,"namespace helpers
{

/**
PropertyResourceBundle is a concrete subclass of ResourceBundle that
manages resources for a locale using a set of static strings from a
property file.
*/
class LOG4CXX_EXPORT PropertyResourceBundle : public ResourceBundle
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(PropertyResourceBundle)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(PropertyResourceBundle)
		LOG4CXX_CAST_ENTRY_CHAIN(ResourceBundle)
		END_LOG4CXX_CAST_MAP()

		/**
		Creates a property resource bundle.
		@param inStream property file to read from.
		@throw IOException if an error occurred when reading from the
		input stream.
		*/
		PropertyResourceBundle(InputStreamPtr inStream);

		LogString getString(const LogString& key) const override;

	protected:
		Properties properties;
}; // class PropertyResourceBundle
LOG4CXX_PTR_DEF(PropertyResourceBundle);
}",1,main\include\log4cxx\helpers\propertyresourcebundle.hpp,LOG4CXX_NS.helpers,27,helpers,1
64445,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\reader.hpp,main\include\log4cxx\helpers\reader.hpp:<global>,,<global>,1
64449,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{

namespace helpers
{

/**
 * Abstract class for reading from character streams.
 *
 */
class LOG4CXX_EXPORT Reader : public Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(Reader)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(Reader)
		END_LOG4CXX_CAST_MAP()

	protected:
		/**
		 * Creates a new character-stream reader.
		 */
		Reader();

		virtual ~Reader();

	public:
		/**
		 * Closes the stream.
		 * @param p The memory pool associated with the reader.
		 */
		virtual void close(Pool& p) = 0;

		/**
		 * @return The complete stream contents as a LogString.
		 * @param p The memory pool associated with the reader.
		 */
		virtual LogString read(Pool& p) = 0;

	private:
		Reader(const Reader&);

		Reader& operator=(const Reader&);
};

LOG4CXX_PTR_DEF(Reader);
} // namespace helpers

}",1,main\include\log4cxx\helpers\reader.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
64450,NAMESPACE_BLOCK,"namespace helpers
{

/**
 * Abstract class for reading from character streams.
 *
 */
class LOG4CXX_EXPORT Reader : public Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(Reader)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(Reader)
		END_LOG4CXX_CAST_MAP()

	protected:
		/**
		 * Creates a new character-stream reader.
		 */
		Reader();

		virtual ~Reader();

	public:
		/**
		 * Closes the stream.
		 * @param p The memory pool associated with the reader.
		 */
		virtual void close(Pool& p) = 0;

		/**
		 * @return The complete stream contents as a LogString.
		 * @param p The memory pool associated with the reader.
		 */
		virtual LogString read(Pool& p) = 0;

	private:
		Reader(const Reader&);

		Reader& operator=(const Reader&);
};

LOG4CXX_PTR_DEF(Reader);
}",1,main\include\log4cxx\helpers\reader.hpp,LOG4CXX_NS.helpers,26,helpers,1
64456,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\relativetimedateformat.hpp,main\include\log4cxx\helpers\relativetimedateformat.hpp:<global>,,<global>,1
64460,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{
/**
Formats a date by printing the number of milliseconds
elapsed since the start of the application. This is the fastest
printing DateFormat in the package.
*/
class LOG4CXX_EXPORT RelativeTimeDateFormat : public DateFormat
{
	public:
		RelativeTimeDateFormat();
		virtual void format(LogString& s,
			log4cxx_time_t tm,
			LOG4CXX_NS::helpers::Pool& p) const;

	private:
		log4cxx_time_t startTime;

};
}  // namespace helpers
}",1,main\include\log4cxx\helpers\relativetimedateformat.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
64461,NAMESPACE_BLOCK,"namespace helpers
{
/**
Formats a date by printing the number of milliseconds
elapsed since the start of the application. This is the fastest
printing DateFormat in the package.
*/
class LOG4CXX_EXPORT RelativeTimeDateFormat : public DateFormat
{
	public:
		RelativeTimeDateFormat();
		virtual void format(LogString& s,
			log4cxx_time_t tm,
			LOG4CXX_NS::helpers::Pool& p) const;

	private:
		log4cxx_time_t startTime;

};
}",1,main\include\log4cxx\helpers\relativetimedateformat.hpp,LOG4CXX_NS.helpers,25,helpers,1
64466,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\resourcebundle.hpp,main\include\log4cxx\helpers\resourcebundle.hpp:<global>,,<global>,1
64470,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{
class Locale;

class ResourceBundle;
LOG4CXX_PTR_DEF(ResourceBundle);

/**
Resource bundles contain locale-specific objects
*/
class LOG4CXX_EXPORT ResourceBundle : public Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(ResourceBundle)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(ResourceBundle)
		END_LOG4CXX_CAST_MAP()

		/**
		Gets a string for the given key from this resource bundle or one of
		its parents. Calling this method is equivalent to calling

		@param key the key for the desired string
		@return the string for the given key
		@throw MissingResourceException - if no object for the given key
		can be found
		*/
		virtual LogString getString(const LogString& key) const = 0;

		/**
		Gets a resource bundle using the specified base name and locale

		@param baseName the base name of the resource bundle, a fully
		qualified class name or property filename
		@param locale the locale for which a resource bundle is desired
		*/
	...",1,main\include\log4cxx\helpers\resourcebundle.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
64471,NAMESPACE_BLOCK,"namespace helpers
{
class Locale;

class ResourceBundle;
LOG4CXX_PTR_DEF(ResourceBundle);

/**
Resource bundles contain locale-specific objects
*/
class LOG4CXX_EXPORT ResourceBundle : public Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(ResourceBundle)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(ResourceBundle)
		END_LOG4CXX_CAST_MAP()

		/**
		Gets a string for the given key from this resource bundle or one of
		its parents. Calling this method is equivalent to calling

		@param key the key for the desired string
		@return the string for the given key
		@throw MissingResourceException - if no object for the given key
		can be found
		*/
		virtual LogString getString(const LogString& key) const = 0;

		/**
		Gets a resource bundle using the specified base name and locale

		@param baseName the base name of the resource bundle, a fully
		qualified class name or property filename
		@param locale the locale for which a resource bundle is desired
		*/
		static ResourceBundleP...",1,main\include\log4cxx\helpers\resourcebundle.hpp,LOG4CXX_NS.helpers,25,helpers,1
64481,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\serversocket.hpp,main\include\log4cxx\helpers\serversocket.hpp:<global>,,<global>,1
64485,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{

class ServerSocket;
LOG4CXX_PTR_DEF(ServerSocket);
LOG4CXX_UNIQUE_PTR_DEF(ServerSocket);

class LOG4CXX_EXPORT ServerSocket
{
	protected:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(ServerSocketPrivate, m_priv)
		ServerSocket(LOG4CXX_PRIVATE_PTR(ServerSocketPrivate) priv);

	public:

		virtual ~ServerSocket();

		/** Listens for a connection to be made to this socket and
		accepts it
		*/
		virtual SocketPtr accept() = 0;

		/** Closes this socket.
		*/
		virtual void close();

		/** Retrive setting for SO_TIMEOUT.
		*/
		int getSoTimeout() const;

		/** Enable/disable SO_TIMEOUT with the specified timeout, in milliseconds.
		*/
		void setSoTimeout(int timeout);

		static ServerSocketUniquePtr create(int port);

};
}  // namespace helpers
}",1,main\include\log4cxx\helpers\serversocket.hpp,LOG4CXX_NS,24,LOG4CXX_NS,1
64486,NAMESPACE_BLOCK,"namespace helpers
{

class ServerSocket;
LOG4CXX_PTR_DEF(ServerSocket);
LOG4CXX_UNIQUE_PTR_DEF(ServerSocket);

class LOG4CXX_EXPORT ServerSocket
{
	protected:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(ServerSocketPrivate, m_priv)
		ServerSocket(LOG4CXX_PRIVATE_PTR(ServerSocketPrivate) priv);

	public:

		virtual ~ServerSocket();

		/** Listens for a connection to be made to this socket and
		accepts it
		*/
		virtual SocketPtr accept() = 0;

		/** Closes this socket.
		*/
		virtual void close();

		/** Retrive setting for SO_TIMEOUT.
		*/
		int getSoTimeout() const;

		/** Enable/disable SO_TIMEOUT with the specified timeout, in milliseconds.
		*/
		void setSoTimeout(int timeout);

		static ServerSocketUniquePtr create(int port);

};
}",1,main\include\log4cxx\helpers\serversocket.hpp,LOG4CXX_NS.helpers,26,helpers,1
64500,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\simpledateformat.hpp,main\include\log4cxx\helpers\simpledateformat.hpp:<global>,,<global>,1
64504,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{
namespace SimpleDateFormatImpl
{
class PatternToken;
}

LOG4CXX_LIST_DEF(PatternTokenList, LOG4CXX_NS::helpers::SimpleDateFormatImpl::PatternToken*);


/**
 * Concrete class for converting and formatting a date/time
 * in a locale-sensitive manner.
 *
 * Specifier | Date/time component
 * --------- | ---------------------
 * G | era
 * y | year
 * M | month number
 * MMM | abbreviated month name
 * MMMM | full month name
 * w | week in year
 * W | week in month
 * D | day in year
 * d | day in month
 * EEE | abbreviated day name
 * EEEE | full day name
 * a | AM or PM
 * H | hour 0 - 23
 * k | hour 1 - 24
 * K | hour 0 - 11
 * h | hour 1 - 12
 * m | minute
 * s | second
 * S | millisecond
 * z | time zone identifier
 * Z | RFC822 time zone
 */
class LOG4CXX_EXPORT SimpleDateFormat : public DateFormat
{
	public:
		/**
		 * A time converter and formatter using \c pattern and the default std::locale.
		 *
		 * @param pattern the specifiers des...",1,main\include\log4cxx\helpers\simpledateformat.hpp,LOG4CXX_NS,29,LOG4CXX_NS,1
64505,NAMESPACE_BLOCK,"namespace helpers
{
namespace SimpleDateFormatImpl
{
class PatternToken;
}

LOG4CXX_LIST_DEF(PatternTokenList, LOG4CXX_NS::helpers::SimpleDateFormatImpl::PatternToken*);


/**
 * Concrete class for converting and formatting a date/time
 * in a locale-sensitive manner.
 *
 * Specifier | Date/time component
 * --------- | ---------------------
 * G | era
 * y | year
 * M | month number
 * MMM | abbreviated month name
 * MMMM | full month name
 * w | week in year
 * W | week in month
 * D | day in year
 * d | day in month
 * EEE | abbreviated day name
 * EEEE | full day name
 * a | AM or PM
 * H | hour 0 - 23
 * k | hour 1 - 24
 * K | hour 0 - 11
 * h | hour 1 - 12
 * m | minute
 * s | second
 * S | millisecond
 * z | time zone identifier
 * Z | RFC822 time zone
 */
class LOG4CXX_EXPORT SimpleDateFormat : public DateFormat
{
	public:
		/**
		 * A time converter and formatter using \c pattern and the default std::locale.
		 *
		 * @param pattern the specifiers describing the date and ti...",1,main\include\log4cxx\helpers\simpledateformat.hpp,LOG4CXX_NS.helpers,31,helpers,1
64506,NAMESPACE_BLOCK,"namespace SimpleDateFormatImpl
{
class PatternToken;
}",1,main\include\log4cxx\helpers\simpledateformat.hpp,LOG4CXX_NS.helpers.SimpleDateFormatImpl,33,SimpleDateFormatImpl,1
64515,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\socket.hpp,main\include\log4cxx\helpers\socket.hpp:<global>,,<global>,1
64519,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{
class ByteBuffer;

class Socket;
LOG4CXX_PTR_DEF(Socket);
LOG4CXX_UNIQUE_PTR_DEF(Socket);

/**
<p>This class implements client sockets (also called just ""sockets""). A socket
is an endpoint for communication between two machines.
<p>The actual work of the socket is performed by an instance of the SocketImpl
class. An application, by changing the socket factory that creates the socket
implementation, can configure itself to create sockets appropriate to the
local firewall.
*/
class LOG4CXX_EXPORT Socket : public helpers::Object
{
	protected:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(SocketPrivate, m_priv)
		Socket(LOG4CXX_PRIVATE_PTR(SocketPrivate) priv);

	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(Socket)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(Socket)
		END_LOG4CXX_CAST_MAP()

		virtual ~Socket();

		virtual size_t write(ByteBuffer&) = 0;

		/** Closes this socket. */
		virtual void close() = 0;

		/** Returns the value of this socket's ...",1,main\include\log4cxx\helpers\socket.hpp,LOG4CXX_NS,25,LOG4CXX_NS,1
64520,NAMESPACE_BLOCK,"namespace helpers
{
class ByteBuffer;

class Socket;
LOG4CXX_PTR_DEF(Socket);
LOG4CXX_UNIQUE_PTR_DEF(Socket);

/**
<p>This class implements client sockets (also called just ""sockets""). A socket
is an endpoint for communication between two machines.
<p>The actual work of the socket is performed by an instance of the SocketImpl
class. An application, by changing the socket factory that creates the socket
implementation, can configure itself to create sockets appropriate to the
local firewall.
*/
class LOG4CXX_EXPORT Socket : public helpers::Object
{
	protected:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(SocketPrivate, m_priv)
		Socket(LOG4CXX_PRIVATE_PTR(SocketPrivate) priv);

	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(Socket)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(Socket)
		END_LOG4CXX_CAST_MAP()

		virtual ~Socket();

		virtual size_t write(ByteBuffer&) = 0;

		/** Closes this socket. */
		virtual void close() = 0;

		/** Returns the value of this socket's address field. */
		Ine...",1,main\include\log4cxx\helpers\socket.hpp,LOG4CXX_NS.helpers,27,helpers,1
64533,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\socketoutputstream.hpp,main\include\log4cxx\helpers\socketoutputstream.hpp:<global>,,<global>,1
64537,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{
LOG4CXX_LIST_DEF(ByteList, unsigned char);

class LOG4CXX_EXPORT SocketOutputStream : public OutputStream
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(SocketOutputStream)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(SocketOutputStream)
		LOG4CXX_CAST_ENTRY_CHAIN(OutputStream)
		END_LOG4CXX_CAST_MAP()

		SocketOutputStream(const SocketPtr& socket);
		~SocketOutputStream();

		void close(Pool& p) override;
		void flush(Pool& p) override;
		void write(ByteBuffer& buf, Pool& p) override;

	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(SocketOutputStreamPrivate, m_priv)
		//
		//   prevent copy and assignment statements
		SocketOutputStream(const SocketOutputStream&);
		SocketOutputStream& operator=(const SocketOutputStream&);

};

LOG4CXX_PTR_DEF(SocketOutputStream);

}  // namespace helpers
}",1,main\include\log4cxx\helpers\socketoutputstream.hpp,LOG4CXX_NS,25,LOG4CXX_NS,1
64538,NAMESPACE_BLOCK,"namespace helpers
{
LOG4CXX_LIST_DEF(ByteList, unsigned char);

class LOG4CXX_EXPORT SocketOutputStream : public OutputStream
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(SocketOutputStream)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(SocketOutputStream)
		LOG4CXX_CAST_ENTRY_CHAIN(OutputStream)
		END_LOG4CXX_CAST_MAP()

		SocketOutputStream(const SocketPtr& socket);
		~SocketOutputStream();

		void close(Pool& p) override;
		void flush(Pool& p) override;
		void write(ByteBuffer& buf, Pool& p) override;

	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(SocketOutputStreamPrivate, m_priv)
		//
		//   prevent copy and assignment statements
		SocketOutputStream(const SocketOutputStream&);
		SocketOutputStream& operator=(const SocketOutputStream&);

};

LOG4CXX_PTR_DEF(SocketOutputStream);

}",1,main\include\log4cxx\helpers\socketoutputstream.hpp,LOG4CXX_NS.helpers,27,helpers,1
64545,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\strftimedateformat.hpp,main\include\log4cxx\helpers\strftimedateformat.hpp:<global>,,<global>,1
64549,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{

/**
Concrete class for formatting and parsing dates in a
locale-sensitive manner.

*/
class LOG4CXX_EXPORT StrftimeDateFormat : public DateFormat
{
	public:
		/**
		Constructs a DateFormat using the given pattern and the default
		time zone.

		@param pattern the pattern describing the date and time format
		*/
		StrftimeDateFormat(const LogString& pattern);
		~StrftimeDateFormat();

		virtual void format(LogString& s,
			log4cxx_time_t tm,
			LOG4CXX_NS::helpers::Pool& p) const;

		/**
		*    Set time zone.
		* @param zone new time zone.
		*/
		void setTimeZone(const TimeZonePtr& zone);


	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(StrftimeDateFormatPrivate, m_priv)
};


}  // namespace helpers
}",1,main\include\log4cxx\helpers\strftimedateformat.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
64550,NAMESPACE_BLOCK,"namespace helpers
{

/**
Concrete class for formatting and parsing dates in a
locale-sensitive manner.

*/
class LOG4CXX_EXPORT StrftimeDateFormat : public DateFormat
{
	public:
		/**
		Constructs a DateFormat using the given pattern and the default
		time zone.

		@param pattern the pattern describing the date and time format
		*/
		StrftimeDateFormat(const LogString& pattern);
		~StrftimeDateFormat();

		virtual void format(LogString& s,
			log4cxx_time_t tm,
			LOG4CXX_NS::helpers::Pool& p) const;

		/**
		*    Set time zone.
		* @param zone new time zone.
		*/
		void setTimeZone(const TimeZonePtr& zone);


	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(StrftimeDateFormatPrivate, m_priv)
};


}",1,main\include\log4cxx\helpers\strftimedateformat.hpp,LOG4CXX_NS.helpers,25,helpers,1
64555,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\strictmath.hpp,main\include\log4cxx\helpers\strictmath.hpp:<global>,,<global>,1
64559,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{
/**
The class StrictMath contains methods for performing basic numeric
operations
*/
class StrictMath
{
	public:
		template<typename _type> static inline const _type&
		minimum(const _type& a, const _type& b)
		{
			return (a < b) ? a : b;
		}

		template<typename _type> static inline const _type&
		maximum(const _type& a, const _type& b)
		{
			return (a > b) ? a : b;
		}
}; // class StrictMath
}  // namespace helpers
}",1,main\include\log4cxx\helpers\strictmath.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
64560,NAMESPACE_BLOCK,"namespace helpers
{
/**
The class StrictMath contains methods for performing basic numeric
operations
*/
class StrictMath
{
	public:
		template<typename _type> static inline const _type&
		minimum(const _type& a, const _type& b)
		{
			return (a < b) ? a : b;
		}

		template<typename _type> static inline const _type&
		maximum(const _type& a, const _type& b)
		{
			return (a > b) ? a : b;
		}
}; // class StrictMath
}",1,main\include\log4cxx\helpers\strictmath.hpp,LOG4CXX_NS.helpers,25,helpers,1
64593,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\stringhelper.hpp,main\include\log4cxx\helpers\stringhelper.hpp:<global>,,<global>,1
64597,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{
class Pool;
/**
String manipulation routines
*/
class LOG4CXX_EXPORT StringHelper
{
	public:
		static LogString trim(const LogString& s);
		static bool startsWith(const LogString& s, const LogString& suffix);
		static bool endsWith(const LogString& s, const LogString& suffix);
		static bool equalsIgnoreCase(const LogString& s1,
			const logchar* upper, const logchar* lower);
		static bool equalsIgnoreCase(const LogString& s1,
			const LogString& upper, const LogString& lower);


		static int toInt(const LogString& s);
		static int64_t toInt64(const LogString& s);

		static void toString(int i, LOG4CXX_NS::helpers::Pool& pool, LogString& dst);
		static void toString(int64_t i, LOG4CXX_NS::helpers::Pool& pool, LogString& dst);
		static void toString(size_t i, LOG4CXX_NS::helpers::Pool& pool, LogString& dst);

		static void toString(bool val, LogString& dst);

		static LogString toLowerCase(const LogString& s);

		static LogString format(const...",1,main\include\log4cxx\helpers\stringhelper.hpp,LOG4CXX_NS,25,LOG4CXX_NS,1
64598,NAMESPACE_BLOCK,"namespace helpers
{
class Pool;
/**
String manipulation routines
*/
class LOG4CXX_EXPORT StringHelper
{
	public:
		static LogString trim(const LogString& s);
		static bool startsWith(const LogString& s, const LogString& suffix);
		static bool endsWith(const LogString& s, const LogString& suffix);
		static bool equalsIgnoreCase(const LogString& s1,
			const logchar* upper, const logchar* lower);
		static bool equalsIgnoreCase(const LogString& s1,
			const LogString& upper, const LogString& lower);


		static int toInt(const LogString& s);
		static int64_t toInt64(const LogString& s);

		static void toString(int i, LOG4CXX_NS::helpers::Pool& pool, LogString& dst);
		static void toString(int64_t i, LOG4CXX_NS::helpers::Pool& pool, LogString& dst);
		static void toString(size_t i, LOG4CXX_NS::helpers::Pool& pool, LogString& dst);

		static void toString(bool val, LogString& dst);

		static LogString toLowerCase(const LogString& s);

		static LogString format(const LogString& pattern, co...",1,main\include\log4cxx\helpers\stringhelper.hpp,LOG4CXX_NS.helpers,27,helpers,1
64606,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\stringtokenizer.hpp,main\include\log4cxx\helpers\stringtokenizer.hpp:<global>,,<global>,1
64610,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{
class LOG4CXX_EXPORT StringTokenizer
{
	public:
		StringTokenizer(const LogString& str, const LogString& delim);
		~StringTokenizer();
		bool hasMoreTokens() const;
		LogString nextToken();

	private:
		//   prevent copy and assignment statements
		StringTokenizer(const StringTokenizer&);
		StringTokenizer& operator=(const StringTokenizer&);

		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(StringTokenizerPrivate, m_priv)
}; // class StringTokenizer
}  // namespace helpers;
}",1,main\include\log4cxx\helpers\stringtokenizer.hpp,LOG4CXX_NS,24,LOG4CXX_NS,1
64611,NAMESPACE_BLOCK,"namespace helpers
{
class LOG4CXX_EXPORT StringTokenizer
{
	public:
		StringTokenizer(const LogString& str, const LogString& delim);
		~StringTokenizer();
		bool hasMoreTokens() const;
		LogString nextToken();

	private:
		//   prevent copy and assignment statements
		StringTokenizer(const StringTokenizer&);
		StringTokenizer& operator=(const StringTokenizer&);

		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(StringTokenizerPrivate, m_priv)
}; // class StringTokenizer
}",1,main\include\log4cxx\helpers\stringtokenizer.hpp,LOG4CXX_NS.helpers,26,helpers,1
64620,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\syslogwriter.hpp,main\include\log4cxx\helpers\syslogwriter.hpp:<global>,,<global>,1
64624,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{
/**
SyslogWriter is a wrapper around the DatagramSocket class
it writes text to the specified host on the port 514 (UNIX syslog)
*/
class LOG4CXX_EXPORT SyslogWriter
{
	public:
#define SYSLOG_PORT 514
		SyslogWriter(const LogString& syslogHost, int syslogHostPort = SYSLOG_PORT);
		~SyslogWriter();
		void write(const LogString& string);

	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(SyslogWriterPrivate, m_priv)
};
}  // namespace helpers
}",1,main\include\log4cxx\helpers\syslogwriter.hpp,LOG4CXX_NS,25,LOG4CXX_NS,1
64625,NAMESPACE_BLOCK,"namespace helpers
{
/**
SyslogWriter is a wrapper around the DatagramSocket class
it writes text to the specified host on the port 514 (UNIX syslog)
*/
class LOG4CXX_EXPORT SyslogWriter
{
	public:
#define SYSLOG_PORT 514
		SyslogWriter(const LogString& syslogHost, int syslogHostPort = SYSLOG_PORT);
		~SyslogWriter();
		void write(const LogString& string);

	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(SyslogWriterPrivate, m_priv)
};
}",1,main\include\log4cxx\helpers\syslogwriter.hpp,LOG4CXX_NS.helpers,27,helpers,1
64632,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\system.hpp,main\include\log4cxx\helpers\system.hpp:<global>,,<global>,1
64636,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{
class Properties;

/** The System class contains several useful class fields and methods.
It cannot be instantiated.
*/
class LOG4CXX_EXPORT System
{
	public:

		/**
		Gets the system property indicated by the specified key.

		@param key the name of the system property.

		@return the string value of the system property, or the default value if
		there is no property with that key.

		@throws IllegalArgumentException if key is empty.
		*/
		static LogString getProperty(const LogString& key);

};
} // namespace helpers
}",1,main\include\log4cxx\helpers\system.hpp,LOG4CXX_NS,24,LOG4CXX_NS,1
64637,NAMESPACE_BLOCK,"namespace helpers
{
class Properties;

/** The System class contains several useful class fields and methods.
It cannot be instantiated.
*/
class LOG4CXX_EXPORT System
{
	public:

		/**
		Gets the system property indicated by the specified key.

		@param key the name of the system property.

		@return the string value of the system property, or the default value if
		there is no property with that key.

		@throws IllegalArgumentException if key is empty.
		*/
		static LogString getProperty(const LogString& key);

};
}",1,main\include\log4cxx\helpers\system.hpp,LOG4CXX_NS.helpers,26,helpers,1
64643,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\systemerrwriter.hpp,main\include\log4cxx\helpers\systemerrwriter.hpp:<global>,,<global>,1
64647,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{

/**
*   Sends output to <code>stderr</code>.
*/
class LOG4CXX_EXPORT SystemErrWriter : public Writer
{
	public:
		DECLARE_LOG4CXX_OBJECT(SystemErrWriter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(SystemErrWriter)
		LOG4CXX_CAST_ENTRY_CHAIN(Writer)
		END_LOG4CXX_CAST_MAP()

		SystemErrWriter();
		virtual ~SystemErrWriter();

		void close(Pool& p) override;
		void flush(Pool& p) override;
		void write(const LogString& str, Pool& p) override;

		static void write(const LogString& str);
		static void flush();

	private:
		SystemErrWriter(const SystemErrWriter&);
		SystemErrWriter& operator=(const SystemErrWriter&);
		static bool isWide();
};

} // namespace helpers

}",1,main\include\log4cxx\helpers\systemerrwriter.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
64648,NAMESPACE_BLOCK,"namespace helpers
{

/**
*   Sends output to <code>stderr</code>.
*/
class LOG4CXX_EXPORT SystemErrWriter : public Writer
{
	public:
		DECLARE_LOG4CXX_OBJECT(SystemErrWriter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(SystemErrWriter)
		LOG4CXX_CAST_ENTRY_CHAIN(Writer)
		END_LOG4CXX_CAST_MAP()

		SystemErrWriter();
		virtual ~SystemErrWriter();

		void close(Pool& p) override;
		void flush(Pool& p) override;
		void write(const LogString& str, Pool& p) override;

		static void write(const LogString& str);
		static void flush();

	private:
		SystemErrWriter(const SystemErrWriter&);
		SystemErrWriter& operator=(const SystemErrWriter&);
		static bool isWide();
};

}",1,main\include\log4cxx\helpers\systemerrwriter.hpp,LOG4CXX_NS.helpers,25,helpers,1
64653,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\systemoutwriter.hpp,main\include\log4cxx\helpers\systemoutwriter.hpp:<global>,,<global>,1
64657,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{

/**
*   Sends output to <code>stdout</code>.
*/
class LOG4CXX_EXPORT SystemOutWriter : public Writer
{
	public:
		DECLARE_LOG4CXX_OBJECT(SystemOutWriter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(SystemOutWriter)
		LOG4CXX_CAST_ENTRY_CHAIN(Writer)
		END_LOG4CXX_CAST_MAP()

		SystemOutWriter();
		~SystemOutWriter();

		void close(Pool& p) override;
		void flush(Pool& p) override;
		void write(const LogString& str, Pool& p) override;

		static void write(const LogString& str);
		static void flush();
	private:
		SystemOutWriter(const SystemOutWriter&);
		SystemOutWriter& operator=(const SystemOutWriter&);
		static bool isWide();
};

} // namespace helpers

}",1,main\include\log4cxx\helpers\systemoutwriter.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
64658,NAMESPACE_BLOCK,"namespace helpers
{

/**
*   Sends output to <code>stdout</code>.
*/
class LOG4CXX_EXPORT SystemOutWriter : public Writer
{
	public:
		DECLARE_LOG4CXX_OBJECT(SystemOutWriter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(SystemOutWriter)
		LOG4CXX_CAST_ENTRY_CHAIN(Writer)
		END_LOG4CXX_CAST_MAP()

		SystemOutWriter();
		~SystemOutWriter();

		void close(Pool& p) override;
		void flush(Pool& p) override;
		void write(const LogString& str, Pool& p) override;

		static void write(const LogString& str);
		static void flush();
	private:
		SystemOutWriter(const SystemOutWriter&);
		SystemOutWriter& operator=(const SystemOutWriter&);
		static bool isWide();
};

}",1,main\include\log4cxx\helpers\systemoutwriter.hpp,LOG4CXX_NS.helpers,25,helpers,1
64661,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\tchar.hpp,main\include\log4cxx\helpers\tchar.hpp:<global>,,<global>,1
64670,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\threadlocal.hpp,main\include\log4cxx\helpers\threadlocal.hpp:<global>,,<global>,1
64675,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{

/**
 *  This class provides thread-local variables.  This class is similar in function
 *  to java.lang.ThreadLocal.
 */
class LOG4CXX_EXPORT ThreadLocal
{
	public:
		/**
		 *   Create new instance.
		 */
		ThreadLocal();
		/**
		 *    Destructor.
		 */
		~ThreadLocal();
		/**
		 *  Sets the value in the current thread's copy of this thread-local variable.
		 *  @param priv new value.
		 */
		void set(void* priv);
		/**
		 *  Returns the value in the current thread's copy of this thread-local variable.
		 *  @return value of thread-local variable for the current thread.
		 */
		void* get();

	private:
		/**
		 * Prevent use of default copy constructor.
		 */
		ThreadLocal(const ThreadLocal&);
		/**
		 *   Prevent use of default assignment operator.
		 */
		ThreadLocal& operator=(const ThreadLocal&);

		static apr_threadkey_t* create(Pool& p);

		Pool p;
		apr_threadkey_t* key;
};
} // namespace helpers
}",1,main\include\log4cxx\helpers\threadlocal.hpp,LOG4CXX_NS,37,LOG4CXX_NS,2
64676,NAMESPACE_BLOCK,"namespace helpers
{

/**
 *  This class provides thread-local variables.  This class is similar in function
 *  to java.lang.ThreadLocal.
 */
class LOG4CXX_EXPORT ThreadLocal
{
	public:
		/**
		 *   Create new instance.
		 */
		ThreadLocal();
		/**
		 *    Destructor.
		 */
		~ThreadLocal();
		/**
		 *  Sets the value in the current thread's copy of this thread-local variable.
		 *  @param priv new value.
		 */
		void set(void* priv);
		/**
		 *  Returns the value in the current thread's copy of this thread-local variable.
		 *  @return value of thread-local variable for the current thread.
		 */
		void* get();

	private:
		/**
		 * Prevent use of default copy constructor.
		 */
		ThreadLocal(const ThreadLocal&);
		/**
		 *   Prevent use of default assignment operator.
		 */
		ThreadLocal& operator=(const ThreadLocal&);

		static apr_threadkey_t* create(Pool& p);

		Pool p;
		apr_threadkey_t* key;
};
}",1,main\include\log4cxx\helpers\threadlocal.hpp,LOG4CXX_NS.helpers,39,helpers,1
64683,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\threadspecificdata.hpp,main\include\log4cxx\helpers\threadspecificdata.hpp:<global>,,<global>,1
64687,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{
/**
  *   This class contains all the thread-specific
  *   data in use by log4cxx.
  */
class LOG4CXX_EXPORT ThreadSpecificData
{
	public:
		ThreadSpecificData();
		~ThreadSpecificData();

		/**
		 *  Gets current thread specific data.
		 *  @return thread specific data, may be null.
		 */
		static ThreadSpecificData* getCurrentData();
		/**
		 *  Release this ThreadSpecficData if empty.
		 */
		void recycle();

		static void put(const LogString& key, const LogString& val);
		static void push(const LogString& val);
		static void inherit(const LOG4CXX_NS::NDC::Stack& stack);

		LOG4CXX_NS::NDC::Stack& getStack();
		LOG4CXX_NS::MDC::Map& getMap();


	private:
		static ThreadSpecificData& getDataNoThreads();
		static ThreadSpecificData* createCurrentData();
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(ThreadSpecificDataPrivate, m_priv)
};

}  // namespace helpers
}",1,main\include\log4cxx\helpers\threadspecificdata.hpp,LOG4CXX_NS,24,LOG4CXX_NS,1
64688,NAMESPACE_BLOCK,"namespace helpers
{
/**
  *   This class contains all the thread-specific
  *   data in use by log4cxx.
  */
class LOG4CXX_EXPORT ThreadSpecificData
{
	public:
		ThreadSpecificData();
		~ThreadSpecificData();

		/**
		 *  Gets current thread specific data.
		 *  @return thread specific data, may be null.
		 */
		static ThreadSpecificData* getCurrentData();
		/**
		 *  Release this ThreadSpecficData if empty.
		 */
		void recycle();

		static void put(const LogString& key, const LogString& val);
		static void push(const LogString& val);
		static void inherit(const LOG4CXX_NS::NDC::Stack& stack);

		LOG4CXX_NS::NDC::Stack& getStack();
		LOG4CXX_NS::MDC::Map& getMap();


	private:
		static ThreadSpecificData& getDataNoThreads();
		static ThreadSpecificData* createCurrentData();
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(ThreadSpecificDataPrivate, m_priv)
};

}",1,main\include\log4cxx\helpers\threadspecificdata.hpp,LOG4CXX_NS.helpers,26,helpers,1
64701,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\threadutility.hpp,main\include\log4cxx\helpers\threadutility.hpp:<global>,,<global>,1
64705,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{

/**
 * A function that will be called before a thread is started.  This can
 * be used to (for example) block all of the signals in the thread, so
 * that when the thread is created it will have a correct signal mask.
 */
typedef std::function<void()> ThreadStartPre;

/**
 * Called when a new thread has started.  This can be used to set
 * parameters for the thread in a platform-specific manner.
 *
 * @param threadName The name of the thread
 * @param threadId The ID of the thread as reported by std::thread::get_id
 * @param nativeHandle The native handle of the thread, as reported by
 * std::thread::native_handle
 */
typedef std::function<void( LogString threadName,
	std::thread::id threadId,
	std::thread::native_handle_type nativeHandle )> ThreadStarted;

/**
 * Called after a thread has started. This can be used to (for example)
 * unblock the signals in the thread.
 */
typedef std::function<void()> ThreadStartPost;

enum class ThreadCo...",1,main\include\log4cxx\helpers\threadutility.hpp,LOG4CXX_NS,28,LOG4CXX_NS,1
64706,NAMESPACE_BLOCK,"namespace helpers
{

/**
 * A function that will be called before a thread is started.  This can
 * be used to (for example) block all of the signals in the thread, so
 * that when the thread is created it will have a correct signal mask.
 */
typedef std::function<void()> ThreadStartPre;

/**
 * Called when a new thread has started.  This can be used to set
 * parameters for the thread in a platform-specific manner.
 *
 * @param threadName The name of the thread
 * @param threadId The ID of the thread as reported by std::thread::get_id
 * @param nativeHandle The native handle of the thread, as reported by
 * std::thread::native_handle
 */
typedef std::function<void( LogString threadName,
	std::thread::id threadId,
	std::thread::native_handle_type nativeHandle )> ThreadStarted;

/**
 * Called after a thread has started. This can be used to (for example)
 * unblock the signals in the thread.
 */
typedef std::function<void()> ThreadStartPost;

enum class ThreadConfigurationType
{
	NoCo...",1,main\include\log4cxx\helpers\threadutility.hpp,LOG4CXX_NS.helpers,30,helpers,1
64723,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\timezone.hpp,main\include\log4cxx\helpers\timezone.hpp:<global>,,<global>,1
64728,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{
class TimeZone;
LOG4CXX_PTR_DEF(TimeZone);

class LOG4CXX_EXPORT TimeZone : public helpers::Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(TimeZone)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(TimeZone)
		END_LOG4CXX_CAST_MAP()

		static const TimeZonePtr& getDefault();
		static const TimeZonePtr& getGMT();
		static const TimeZonePtr getTimeZone(const LogString& ID);

		const LogString getID() const
		{
			return id;
		}


		/**
		 *   Expand an APR time into the human readable
		 *      components for this timezone.
		 */
		virtual log4cxx_status_t explode(apr_time_exp_t* result,
			log4cxx_time_t input) const = 0;


	protected:
		TimeZone(const LogString& ID);
		virtual ~TimeZone();

		LOG4CXX_DECLARE_PRIVATE_MEMBER(LogString, id)
};


}
}",1,main\include\log4cxx\helpers\timezone.hpp,LOG4CXX_NS,26,LOG4CXX_NS,2
64729,NAMESPACE_BLOCK,"namespace helpers
{
class TimeZone;
LOG4CXX_PTR_DEF(TimeZone);

class LOG4CXX_EXPORT TimeZone : public helpers::Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(TimeZone)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(TimeZone)
		END_LOG4CXX_CAST_MAP()

		static const TimeZonePtr& getDefault();
		static const TimeZonePtr& getGMT();
		static const TimeZonePtr getTimeZone(const LogString& ID);

		const LogString getID() const
		{
			return id;
		}


		/**
		 *   Expand an APR time into the human readable
		 *      components for this timezone.
		 */
		virtual log4cxx_status_t explode(apr_time_exp_t* result,
			log4cxx_time_t input) const = 0;


	protected:
		TimeZone(const LogString& ID);
		virtual ~TimeZone();

		LOG4CXX_DECLARE_PRIVATE_MEMBER(LogString, id)
};


}",1,main\include\log4cxx\helpers\timezone.hpp,LOG4CXX_NS.helpers,28,helpers,1
64736,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\transcoder.hpp,main\include\log4cxx\helpers\transcoder.hpp:<global>,,<global>,1
64740,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{
class ByteBuffer;
class Pool;
/**
*    Simple transcoder for converting between
*      external char and wchar_t strings and
*      internal strings.
*
*/
class LOG4CXX_EXPORT Transcoder
{
	public:


		/**
		 *   Appends this specified string of UTF-8 characters to LogString.
		 */
		static void decodeUTF8(const std::string& src, LogString& dst);
		/**
		 *    Converts the LogString to a UTF-8 string.
		 */
		static void encodeUTF8(const LogString& src, std::string& dst);
		/**
		 *    Converts the LogString to a UTF-8 string.
		 */
		static char* encodeUTF8(const LogString& src, LOG4CXX_NS::helpers::Pool& p);
		/**
		 *    Append UCS-4 code point to a byte buffer as UTF-8.
		 */
		static void encodeUTF8(unsigned int sv, ByteBuffer& dst);
		/**
		 *    Append UCS-4 code point to a byte buffer as UTF-16LE.
		 */
		static void encodeUTF16LE(unsigned int sv, ByteBuffer& dst);
		/**
		 *    Append UCS-4 code point to a byte buffer as UTF-16BE.
...",1,main\include\log4cxx\helpers\transcoder.hpp,LOG4CXX_NS,24,LOG4CXX_NS,1
64741,NAMESPACE_BLOCK,"namespace helpers
{
class ByteBuffer;
class Pool;
/**
*    Simple transcoder for converting between
*      external char and wchar_t strings and
*      internal strings.
*
*/
class LOG4CXX_EXPORT Transcoder
{
	public:


		/**
		 *   Appends this specified string of UTF-8 characters to LogString.
		 */
		static void decodeUTF8(const std::string& src, LogString& dst);
		/**
		 *    Converts the LogString to a UTF-8 string.
		 */
		static void encodeUTF8(const LogString& src, std::string& dst);
		/**
		 *    Converts the LogString to a UTF-8 string.
		 */
		static char* encodeUTF8(const LogString& src, LOG4CXX_NS::helpers::Pool& p);
		/**
		 *    Append UCS-4 code point to a byte buffer as UTF-8.
		 */
		static void encodeUTF8(unsigned int sv, ByteBuffer& dst);
		/**
		 *    Append UCS-4 code point to a byte buffer as UTF-16LE.
		 */
		static void encodeUTF16LE(unsigned int sv, ByteBuffer& dst);
		/**
		 *    Append UCS-4 code point to a byte buffer as UTF-16BE.
		 */
		static void enc...",1,main\include\log4cxx\helpers\transcoder.hpp,LOG4CXX_NS.helpers,26,helpers,1
64748,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\transform.hpp,main\include\log4cxx\helpers\transform.hpp:<global>,,<global>,1
64752,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{
/**
Utility class for transforming strings.
*/
class LOG4CXX_EXPORT Transform
{
	public:
		/**
		* Add \c input, which may contain HTML tags
		* (ie, &lt;b&gt;, &lt;table&gt;, etc) to \c buf
		* while replacing any '<' and '>' characters
		* with respective predefined entity references.
		*
		* @param buf output stream where to write the modified string.
		* @param input The text to be converted.
		* */
		static void appendEscapingTags(
			LogString& buf, const LogString& input);

		/**
		* Add \c input to \c buf while ensuring embeded CDEnd strings (]]>)
		* are handled properly within the message, NDC and throwable tag text.
		*
		* @param buf output stream holding the XML data to this point.  The
		* initial CDStart (<![CDATA[) and final CDEnd (]]>) of the CDATA
		* section are the responsibility of the calling method.
		* @param input The String that is inserted into an existing CDATA
		* Section within buf.
		*/
		static void appendEsc...",1,main\include\log4cxx\helpers\transform.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
64753,NAMESPACE_BLOCK,"namespace helpers
{
/**
Utility class for transforming strings.
*/
class LOG4CXX_EXPORT Transform
{
	public:
		/**
		* Add \c input, which may contain HTML tags
		* (ie, &lt;b&gt;, &lt;table&gt;, etc) to \c buf
		* while replacing any '<' and '>' characters
		* with respective predefined entity references.
		*
		* @param buf output stream where to write the modified string.
		* @param input The text to be converted.
		* */
		static void appendEscapingTags(
			LogString& buf, const LogString& input);

		/**
		* Add \c input to \c buf while ensuring embeded CDEnd strings (]]>)
		* are handled properly within the message, NDC and throwable tag text.
		*
		* @param buf output stream holding the XML data to this point.  The
		* initial CDStart (<![CDATA[) and final CDEnd (]]>) of the CDATA
		* section are the responsibility of the calling method.
		* @param input The String that is inserted into an existing CDATA
		* Section within buf.
		*/
		static void appendEscapingCDATA(
			LogStrin...",1,main\include\log4cxx\helpers\transform.hpp,LOG4CXX_NS.helpers,25,helpers,1
64760,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\widelife.hpp,main\include\log4cxx\helpers\widelife.hpp:<global>,,<global>,1
64764,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{
	

/**
The WideLife wrapper is destined to prolongate the runtime logger state lifetime from static duration to infinite
*/
template <class T>
class WideLife
{
public:
	WideLife()
	{		
		new(&storage) T();
	}
	template <class Arg0, class... Args>
#if defined(__cpp_concepts) && __cpp_concepts >= 201500
		requires (!std::same_as<WideLife, Arg0>)
#endif
	WideLife(Arg0&& arg0, Args&&... args)
	{		
		new(&storage) T(std::forward<Arg0>(arg0), std::forward<Args>(args)...);
	}
	
	~WideLife()
	{
#if LOG4CXX_EVENTS_AT_EXIT
		// keep the holded value alive
#else
		value().~T();
#endif
	}

	T& value()
	{
		return *reinterpret_cast<T*>(&storage);
	}
	
	const T& value() const
	{
		return *reinterpret_cast<const T*>(&storage);
	}
	
	operator T&()
	{
		return value();
	}
	
	operator const T&() const
	{
		return value();
	}

private:
	alignas(T) char storage[sizeof(T)];
	// Non-copyable
	WideLife(const WideLife& other) = delete;
	WideLife(const WideLife&& o...",1,main\include\log4cxx\helpers\widelife.hpp,LOG4CXX_NS,26,LOG4CXX_NS,1
64765,NAMESPACE_BLOCK,"namespace helpers
{
	

/**
The WideLife wrapper is destined to prolongate the runtime logger state lifetime from static duration to infinite
*/
template <class T>
class WideLife
{
public:
	WideLife()
	{		
		new(&storage) T();
	}
	template <class Arg0, class... Args>
#if defined(__cpp_concepts) && __cpp_concepts >= 201500
		requires (!std::same_as<WideLife, Arg0>)
#endif
	WideLife(Arg0&& arg0, Args&&... args)
	{		
		new(&storage) T(std::forward<Arg0>(arg0), std::forward<Args>(args)...);
	}
	
	~WideLife()
	{
#if LOG4CXX_EVENTS_AT_EXIT
		// keep the holded value alive
#else
		value().~T();
#endif
	}

	T& value()
	{
		return *reinterpret_cast<T*>(&storage);
	}
	
	const T& value() const
	{
		return *reinterpret_cast<const T*>(&storage);
	}
	
	operator T&()
	{
		return value();
	}
	
	operator const T&() const
	{
		return value();
	}

private:
	alignas(T) char storage[sizeof(T)];
	// Non-copyable
	WideLife(const WideLife& other) = delete;
	WideLife(const WideLife&& other) = delete;
	// Non...",1,main\include\log4cxx\helpers\widelife.hpp,LOG4CXX_NS.helpers,28,helpers,1
64872,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\writer.hpp,main\include\log4cxx\helpers\writer.hpp:<global>,,<global>,1
64876,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{

namespace helpers
{

/**
*   Abstract class for writing to character streams.
*/
class LOG4CXX_EXPORT Writer : public Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(Writer)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(Writer)
		END_LOG4CXX_CAST_MAP()

	protected:
		Writer();
		virtual ~Writer();

	public:
		virtual void close(Pool& p) = 0;
		virtual void flush(Pool& p) = 0;
		virtual void write(const LogString& str, Pool& p) = 0;

	private:
		Writer(const Writer&);
		Writer& operator=(const Writer&);
};

LOG4CXX_PTR_DEF(Writer);
} // namespace helpers

}",1,main\include\log4cxx\helpers\writer.hpp,LOG4CXX_NS,24,LOG4CXX_NS,1
64877,NAMESPACE_BLOCK,"namespace helpers
{

/**
*   Abstract class for writing to character streams.
*/
class LOG4CXX_EXPORT Writer : public Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(Writer)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(Writer)
		END_LOG4CXX_CAST_MAP()

	protected:
		Writer();
		virtual ~Writer();

	public:
		virtual void close(Pool& p) = 0;
		virtual void flush(Pool& p) = 0;
		virtual void write(const LogString& str, Pool& p) = 0;

	private:
		Writer(const Writer&);
		Writer& operator=(const Writer&);
};

LOG4CXX_PTR_DEF(Writer);
}",1,main\include\log4cxx\helpers\writer.hpp,LOG4CXX_NS.helpers,27,helpers,1
64887,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\helpers\xml.hpp,main\include\log4cxx\helpers\xml.hpp:<global>,,<global>,1
64891,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
class File;
namespace helpers
{
class XMLDOMNode;
typedef std::shared_ptr<XMLDOMNode> XMLDOMNodePtr;

class XMLDOMDocument;
typedef std::shared_ptr<XMLDOMDocument> XMLDOMDocumentPtr;

class XMLDOMNodeList;
typedef std::shared_ptr<XMLDOMNodeList> XMLDOMNodeListPtr;

class LOG4CXX_EXPORT DOMException : public RuntimeException
{
	public:
		DOMException() : RuntimeException(LOG4CXX_STR(""DOM exception"")) {}
};


/**
The XMLDOMNode interface is the primary datatype for the entire Document
Object Model.
*/
class LOG4CXX_EXPORT XMLDOMNode : virtual public Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(XMLDOMNode)
		enum XMLDOMNodeType
		{
			NOT_IMPLEMENTED_NODE = 0,
			ELEMENT_NODE = 1,
			DOCUMENT_NODE = 9
		};

		virtual XMLDOMNodeListPtr getChildNodes() = 0;
		virtual XMLDOMNodeType getNodeType() = 0;
		virtual XMLDOMDocumentPtr getOwnerDocument() = 0;
};
LOG4CXX_PTR_DEF(XMLDOMNode);


/**
The XMLDOMElement interface represents an element in an XML document
*...",1,main\include\log4cxx\helpers\xml.hpp,LOG4CXX_NS,25,LOG4CXX_NS,1
64893,NAMESPACE_BLOCK,"namespace helpers
{
class XMLDOMNode;
typedef std::shared_ptr<XMLDOMNode> XMLDOMNodePtr;

class XMLDOMDocument;
typedef std::shared_ptr<XMLDOMDocument> XMLDOMDocumentPtr;

class XMLDOMNodeList;
typedef std::shared_ptr<XMLDOMNodeList> XMLDOMNodeListPtr;

class LOG4CXX_EXPORT DOMException : public RuntimeException
{
	public:
		DOMException() : RuntimeException(LOG4CXX_STR(""DOM exception"")) {}
};


/**
The XMLDOMNode interface is the primary datatype for the entire Document
Object Model.
*/
class LOG4CXX_EXPORT XMLDOMNode : virtual public Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(XMLDOMNode)
		enum XMLDOMNodeType
		{
			NOT_IMPLEMENTED_NODE = 0,
			ELEMENT_NODE = 1,
			DOCUMENT_NODE = 9
		};

		virtual XMLDOMNodeListPtr getChildNodes() = 0;
		virtual XMLDOMNodeType getNodeType() = 0;
		virtual XMLDOMDocumentPtr getOwnerDocument() = 0;
};
LOG4CXX_PTR_DEF(XMLDOMNode);


/**
The XMLDOMElement interface represents an element in an XML document
*/
class LOG4CXX_EXPORT XMLDOMElemen...",1,main\include\log4cxx\helpers\xml.hpp,LOG4CXX_NS.helpers,28,helpers,2
64914,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\hexdump.hpp,main\include\log4cxx\hexdump.hpp:<global>,,<global>,1
64918,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{

enum class HexdumpFlags : uint32_t{
	None,
	AddStartingNewline = (0x01 << 0),
	AddEndingNewline = (0x01 << 1),
	AddNewline = AddStartingNewline | AddEndingNewline,
};

inline bool operator&(HexdumpFlags a, HexdumpFlags b){
	return !!(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}

inline HexdumpFlags operator|(HexdumpFlags a, HexdumpFlags b){
	return static_cast<HexdumpFlags>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

/**
 * Hexdump the given bytes and return a LogString with the dumped bytes.
 *
 * Sample output:
 * 00000000  0a 20 20 20 20 20 20 20  20 20 20 20 20 20 20 20  |.               |
 *
 * @param bytes A pointer to the bytes to dump
 * @param len How many bytes to dump
 * @param flags Flags to control the output format of the hexdump
 * @return A LogString with the hexdump output
 */
LOG4CXX_EXPORT
LogString hexdump(const void* bytes, uint32_t len, HexdumpFlags flags = HexdumpFlags::None);

}",1,main\include\log4cxx\hexdump.hpp,LOG4CXX_NS,24,LOG4CXX_NS,1
65000,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\hierarchy.hpp,main\include\log4cxx\hierarchy.hpp:<global>,,<global>,1
65004,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{

class Hierarchy;
LOG4CXX_PTR_DEF(Hierarchy);

/**
This class is specialized in retrieving loggers by name and also
maintaining the logger hierarchy.

<p><em>The casual user does not have to deal with this class
directly.</em>

<p>The structure of the logger hierarchy is maintained by the
#getLogger method. The hierarchy is such that children link
to their parent but parents do not have any pointers to their
children. Moreover, loggers can be instantiated in any order, in
particular descendant before ancestor.

<p>In case a descendant is created before a particular ancestor,
then it creates a provision node for the ancestor and adds itself
to the provision node. Other descendants of the same ancestor add
themselves to the previously created provision node.
*/
class LOG4CXX_EXPORT Hierarchy : public spi::LoggerRepository
{
	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(HierarchyPrivate, m_priv)

	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(Hierarchy)
		BEGIN_LOG4...",1,main\include\log4cxx\hierarchy.hpp,LOG4CXX_NS,31,LOG4CXX_NS,1
65013,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\htmllayout.hpp,main\include\log4cxx\htmllayout.hpp:<global>,,<global>,1
65017,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
/**
This layout outputs events in a HTML table.
*/
class LOG4CXX_EXPORT HTMLLayout : public Layout
{
	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(HTMLLayoutPrivate, m_priv)

	public:
		DECLARE_LOG4CXX_OBJECT(HTMLLayout)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(HTMLLayout)
		LOG4CXX_CAST_ENTRY_CHAIN(Layout)
		END_LOG4CXX_CAST_MAP()

		HTMLLayout();
		~HTMLLayout();

		/**
		The <b>LocationInfo</b> option takes a boolean value. By
		default, it is set to false which means there will be no location
		information output by this layout. If the the option is set to
		true, then the file name and line number of the statement
		at the origin of the log statement will be output.

		<p>If you are embedding this layout within an
		{@link net::SMTPAppender SMTPAppender} then make sure
		to set the <b>LocationInfo</b> option of that appender as well.
		*/
		void setLocationInfo(bool locationInfoFlag);

		/**
		Returns the current value of the <b>LocationInfo</b> o...",1,main\include\log4cxx\htmllayout.hpp,LOG4CXX_NS,26,LOG4CXX_NS,1
65027,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\jsonlayout.hpp,main\include\log4cxx\jsonlayout.hpp:<global>,,<global>,1
65031,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
/**
This layout outputs events in a JSON dictionary.
*/
class LOG4CXX_EXPORT JSONLayout : public Layout
{
	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(JSONLayoutPrivate, m_priv)

	protected:
		void appendQuotedEscapedString(LogString& buf, const LogString& input) const;
		void appendSerializedMDC(LogString& buf,
			const spi::LoggingEventPtr& event) const;
		void appendSerializedNDC(LogString& buf,
			const spi::LoggingEventPtr& event) const;
		void appendSerializedLocationInfo(LogString& buf,
			const spi::LoggingEventPtr& event, LOG4CXX_NS::helpers::Pool& p) const;

	public:
		static void appendItem(const LogString& item, LogString& toAppendTo);
		DECLARE_LOG4CXX_OBJECT(JSONLayout)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(JSONLayout)
		LOG4CXX_CAST_ENTRY_CHAIN(Layout)
		END_LOG4CXX_CAST_MAP()

		JSONLayout();

		~JSONLayout();

		/**
		The <b>LocationInfo</b> option takes a boolean value. By
		default, it is set to false which means there will be no...",1,main\include\log4cxx\jsonlayout.hpp,LOG4CXX_NS,26,LOG4CXX_NS,1
65041,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\layout.hpp,main\include\log4cxx\layout.hpp:<global>,,<global>,1
65045,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
/**
Extend this abstract class to create your own log layout format.
*/
class LOG4CXX_EXPORT Layout :
	public virtual spi::OptionHandler,
	public virtual helpers::Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(Layout)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(Layout)
		LOG4CXX_CAST_ENTRY(spi::OptionHandler)
		END_LOG4CXX_CAST_MAP()

		virtual ~Layout();

		/**
		Implement this method to create your own layout format.
		*/
		virtual void format(LogString& output,
			const spi::LoggingEventPtr& event, LOG4CXX_NS::helpers::Pool& pool) const = 0;

		/**
		Returns the content type output by this layout. The base class
		returns ""text/plain"".
		*/
		virtual LogString getContentType() const;

		/**
		Append the header for the layout format. The base class does
		nothing.
		*/
		virtual void appendHeader(LogString& output, LOG4CXX_NS::helpers::Pool& p);

		/**
		Append the footer for the layout format. The base class does
		nothing.
		*/
		virtual void appe...",1,main\include\log4cxx\layout.hpp,LOG4CXX_NS,26,LOG4CXX_NS,1
65057,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\level.hpp,main\include\log4cxx\level.hpp:<global>,,<global>,1
65061,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
/**
 * LOG4CXX_PTR_DEF can't be used to get a smart pointer for Level because we need to override
 * the comparison operator and this doesn't work if the template has alread been initialized,
 * which is what the macro does on some platforms. The overriding takes place underneath the
 * definition of Level because we need one of it's methods.
 *
 * https://issues.apache.org/jira/browse/LOGCXX-394
 */
class Level;
typedef std::shared_ptr<Level> LevelPtr;

/**
Defines the minimum set of levels recognized by the system, that is
<code>OFF</code>, <code>FATAL</code>, <code>ERROR</code>,
<code>WARN</code>, <code>INFO</code>, <code>DEBUG</code> and
<code>ALL</code>.
<p>The <code>Level</code> class may be subclassed to define a larger
level set.
*/
class LOG4CXX_EXPORT Level : public helpers::Object
{
	public:
		class LOG4CXX_EXPORT LevelClass : public helpers::Class
		{
			public:
				LevelClass() : helpers::Class() {}

				virtual LogString getName() const
				{
			...",1,main\include\log4cxx\level.hpp,LOG4CXX_NS,27,LOG4CXX_NS,1
65070,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\levelchange.hpp,main\include\log4cxx\levelchange.hpp:<global>,,<global>,1
65074,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{

/**
 * Changes a verbosity level for the instance variable's lifetime.

 * Create a LevelChange variable on the stack
 * to temporarily (e.g. for a single method)
 * increase the quantity of information logged.

 * Typically used to propagate the locally used logger's level (e.g. DEBUG or TRACE)
 * to another named (e.g. the name of the class of the method invoked next) logger.

 * The LevelChange variable does not need to be removed from the code (e.g. for a release build)
 * as it has no impact when the local and other logger point to the same level
 * (e.g. null_ptr, implying their level is inherited).
 */
 class LevelChange
{
	LoggerPtr m_otherCategory;
	LevelPtr m_savedLevel;
public: // ...structors
	/// Set \c otherCategory to \c level
	LevelChange(const LoggerPtr& otherCategory, const LevelPtr& level)
		: m_otherCategory(otherCategory)
		, m_savedLevel(otherCategory->getLevel())
	{
		m_otherCategory->setLevel(level);
	}
	/// Set \c otherCategory to the...",1,main\include\log4cxx\levelchange.hpp,LOG4CXX_NS,24,LOG4CXX_NS,1
65157,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\logger.hpp,main\include\log4cxx\logger.hpp:<global>,,<global>,1
65161,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{

namespace spi
{
class LoggerRepository;
LOG4CXX_PTR_DEF(LoggerRepository);
class LoggerFactory;
LOG4CXX_PTR_DEF(LoggerFactory);
}

class Logger;
/** smart pointer to a Logger class */
LOG4CXX_PTR_DEF(Logger);
LOG4CXX_LIST_DEF(LoggerList, LoggerPtr);


/**
This is the central class in the log4cxx package. Most logging
operations, except configuration, are done through this class.
*/
class LOG4CXX_EXPORT Logger :
	public virtual LOG4CXX_NS::spi::AppenderAttachable
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(Logger)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(Logger)
		LOG4CXX_CAST_ENTRY(spi::AppenderAttachable)
		END_LOG4CXX_CAST_MAP()

	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(LoggerPrivate, m_priv)
		int m_threshold; //!< The cached level of this logger

	public:
		/**
		This constructor initializes a new <code>logger</code> instance and
		sets its name.

		<p>It is intended to be only used by factory-classes.

		@param pool lifetime of pool must be...",1,main\include\log4cxx\logger.hpp,LOG4CXX_NS,28,LOG4CXX_NS,1
65162,NAMESPACE_BLOCK,"namespace spi
{
class LoggerRepository;
LOG4CXX_PTR_DEF(LoggerRepository);
class LoggerFactory;
LOG4CXX_PTR_DEF(LoggerFactory);
}",1,main\include\log4cxx\logger.hpp,LOG4CXX_NS.spi,31,spi,1
65177,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\loggerinstance.hpp,main\include\log4cxx\loggerinstance.hpp:<global>,,<global>,1
65181,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{

/**
 * A smart pointer (implicity convertable to LoggerPtr)
 * that conditionally removes a Logger from the spi::LoggerRepository
 * at the end of the instance variable's lifetime.

 * If the configuration process loaded settings for the logger,
 * or the logger is referenced elsewhere,
 * the LoggerInstancePtr destructor will not remove it from the spi::LoggerRepository.

 * Use a LoggerInstancePtr to prevent unbounded growth
 * of data in the spi::LoggerRepository
 * when using runtime generated logger names.

 * A runtime generated logger name is a technique for marking logging messages
 * that allows control of the logger level at a class instance level (i.e. a per object logger).

 * A per object logger is useful when the object instance has a identifiable name
 * (e.g. when it is instantiated from configuration data).
 */
 class LoggerInstancePtr
{
	bool m_hadConfiguration; //!< Did the logger repository hold a \c m_logger before creation of this instan...",1,main\include\log4cxx\loggerinstance.hpp,LOG4CXX_NS,24,LOG4CXX_NS,1
65307,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\logmanager.hpp,main\include\log4cxx\logmanager.hpp:<global>,,<global>,1
65311,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
class Logger;
typedef std::shared_ptr<Logger> LoggerPtr;
typedef std::vector<LoggerPtr> LoggerList;

namespace spi
{
class LoggerFactory;
typedef std::shared_ptr<LoggerFactory> LoggerFactoryPtr;
}

/**
* Use the <code>LogManager</code> class to retreive Logger
* instances or to operate on the current
* {@link log4cxx::spi::LoggerRepository LoggerRepository}.
* DefaultConfigurator::configure will be used to configure LoggerRepository
* when the first logger is retrieved if it is not already configured.
*/
class LOG4CXX_EXPORT LogManager
{
	private:
		static void* guard;
		static spi::RepositorySelectorPtr getRepositorySelector();

	public:
		/**
		Use \c selector to source the {@link spi::LoggerRepository LoggerRepository}, but only if the correct
		\c guard is passed as parameter.

		<p>Initally the guard is null.  If the guard is
		<code>null</code>, then invoking this method sets the logger
		factory and the guard. Following invocations will throw a
		{@link...",1,main\include\log4cxx\logmanager.hpp,LOG4CXX_NS,25,LOG4CXX_NS,1
65315,NAMESPACE_BLOCK,"namespace spi
{
class LoggerFactory;
typedef std::shared_ptr<LoggerFactory> LoggerFactoryPtr;
}",1,main\include\log4cxx\logmanager.hpp,LOG4CXX_NS.spi,31,spi,4
65326,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\logstring.hpp,main\include\log4cxx\logstring.hpp:<global>,,<global>,1
65330,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{

#if LOG4CXX_LOGCHAR_IS_UNICHAR || LOG4CXX_UNICHAR_API
	typedef unsigned short UniChar;
#endif

#if LOG4CXX_LOGCHAR_IS_WCHAR
	typedef wchar_t logchar;
	#define LOG4CXX_STR(str) L ## str
#endif

#if LOG4CXX_LOGCHAR_IS_UTF8
	typedef char logchar;
	#if LOG4CXX_CHARSET_EBCDIC
		#define LOG4CXX_STR(str) LOG4CXX_NS::helpers::Transcoder::decode(str)
	#else
		#define LOG4CXX_STR(str) str
	#endif
#endif

#if LOG4CXX_LOGCHAR_IS_UNICHAR
	typedef UniChar logchar;
	#define LOG4CXX_STR(str) LOG4CXX_NS::helpers::Transcoder::decode(str)
#endif

typedef std::basic_string<logchar> LogString;

}",1,main\include\log4cxx\logstring.hpp,LOG4CXX_NS,34,LOG4CXX_NS,1
65339,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\mdc.hpp,main\include\log4cxx\mdc.hpp:<global>,,<global>,1
65343,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{

/**
A <em>Mapped Diagnostic Context</em>, or
MDC in short, is an instrument for distinguishing interleaved log
output from different sources. Log output is typically interleaved
when a server handles multiple clients near-simultaneously.

#MDC provides a constructor and destructor which simply call the #put and
#remove methods, allowing for automatic cleanup when the current scope ends.

#MDC operations such as #put, #remove and #clear
affect only logging events emitted in the <em>calling</em> thread.
The contexts of other threads are not changed.
That is, <em><b>contexts are managed on a per thread basis</b></em>.

The MDC class is similar to the {@link log4cxx::NDC NDC} class except that it is
based on a map instead of a stack.
*/
class LOG4CXX_EXPORT MDC
{
	public:
		/** String to string stl map.
		*/
		typedef std::map<LogString, LogString> Map;

		/**
		 *  Places a key/value pair in the MDC for the current thread
		 *    which will be removed during the...",1,main\include\log4cxx\mdc.hpp,LOG4CXX_NS,25,LOG4CXX_NS,1
65352,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\ndc.hpp,main\include\log4cxx\ndc.hpp:<global>,,<global>,1
65356,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{

/**
A <em>Nested Diagnostic Context</em>, or #NDC in short, is an instrument
to distinguish interleaved log output from different sources.
Log output is typically interleaved when a server handles multiple
clients near-simultaneously.
Interleaved log output can still be meaningful if each log entry
from different contexts have a distinctive stamp.
This is where contexts come into play.

#NDC provides a constructor and destructor which simply call the #push and
#pop methods, allowing for automatic cleanup when the current scope ends.

#NDC operations such as #push, #pop, #clear and #remove
affect only logging events emitted in the <em>calling</em> thread.
The contexts of other threads are not changed.
That is, <em><b>contexts are managed on a per thread basis</b></em>.

For example, a servlet can build a per client request context
consisting of the client's host name and other information contained in
the the request. <em>Cookies</em> are another source of dis...",1,main\include\log4cxx\ndc.hpp,LOG4CXX_NS,25,LOG4CXX_NS,1
65365,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\net\smtpappender.hpp,main\include\log4cxx\net\smtpappender.hpp:<global>,,<global>,1
65369,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace net
{
/**
Send an e-mail when a specific logging event occurs, typically when
an <b>ERROR</b> level logging event is sent to the appender.

A value must be provided for the following <b>param</b> elements :
- <b>smtpHost</b> -
  The URL or IP address of the SMTP server.
- <b>from</b> -
  The email address in the <b>from</b> field of the message.
- one of <b>to</b>, <b>cc</b>, <b>bcc</b> -
  An email address in the message.

The following <b>param</b> elements  are optional:
- <b>smtpPort</b> -
  The TCP/IP port number on the SMTP server.
  By default port 25 is assumed.
- <b>subject</b> -
  Content for the the <b>subject</b> field of the message.
- <b>smtpUsername</b> -
  Provided when the SMTP server requests authentication.
- <b>smtpPassword</b> -
  Provided when the SMTP server requests authentication.
- <b>BufferSize</b> -
  The number of logging events delivered in an e-mail.
  The <code>SMTPAppender</code> keeps only the last
  <code>BufferSize...",1,main\include\log4cxx\net\smtpappender.hpp,LOG4CXX_NS,26,LOG4CXX_NS,1
65370,NAMESPACE_BLOCK,"namespace net
{
/**
Send an e-mail when a specific logging event occurs, typically when
an <b>ERROR</b> level logging event is sent to the appender.

A value must be provided for the following <b>param</b> elements :
- <b>smtpHost</b> -
  The URL or IP address of the SMTP server.
- <b>from</b> -
  The email address in the <b>from</b> field of the message.
- one of <b>to</b>, <b>cc</b>, <b>bcc</b> -
  An email address in the message.

The following <b>param</b> elements  are optional:
- <b>smtpPort</b> -
  The TCP/IP port number on the SMTP server.
  By default port 25 is assumed.
- <b>subject</b> -
  Content for the the <b>subject</b> field of the message.
- <b>smtpUsername</b> -
  Provided when the SMTP server requests authentication.
- <b>smtpPassword</b> -
  Provided when the SMTP server requests authentication.
- <b>BufferSize</b> -
  The number of logging events delivered in an e-mail.
  The <code>SMTPAppender</code> keeps only the last
  <code>BufferSize</code> logging events ...",1,main\include\log4cxx\net\smtpappender.hpp,LOG4CXX_NS.net,28,net,1
65382,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\net\socketappenderskeleton.hpp,main\include\log4cxx\net\socketappenderskeleton.hpp:<global>,,<global>,1
65386,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{

namespace net
{

/**
 *  Abstract base class for SocketAppender and XMLSocketAppender
 */
class LOG4CXX_EXPORT SocketAppenderSkeleton : public AppenderSkeleton
{
	protected:
		struct SocketAppenderSkeletonPriv;

	public:
		SocketAppenderSkeleton(int defaultPort, int reconnectionDelay);
		~SocketAppenderSkeleton();

		/**
		Connects to remote server at <code>address</code> and <code>port</code>.
		*/
		SocketAppenderSkeleton(helpers::InetAddressPtr address, int port, int reconnectionDelay);

		/**
		Connects to remote server at <code>host</code> and <code>port</code>.
		*/
		SocketAppenderSkeleton(const LogString& host, int port, int reconnectionDelay);

		/**
		\copybrief AppenderSkeleton::activateOptions()

		Connects to the specified <b>RemoteHost</b> and <b>Port</b>.
		*/
		void activateOptions(helpers::Pool& p) override;

		void close() override;


		/**
		* This appender does not use a layout. Hence, this method
		* returns <code>false</code>.
		*
		    ...",1,main\include\log4cxx\net\socketappenderskeleton.hpp,LOG4CXX_NS,26,LOG4CXX_NS,1
65387,NAMESPACE_BLOCK,"namespace net
{

/**
 *  Abstract base class for SocketAppender and XMLSocketAppender
 */
class LOG4CXX_EXPORT SocketAppenderSkeleton : public AppenderSkeleton
{
	protected:
		struct SocketAppenderSkeletonPriv;

	public:
		SocketAppenderSkeleton(int defaultPort, int reconnectionDelay);
		~SocketAppenderSkeleton();

		/**
		Connects to remote server at <code>address</code> and <code>port</code>.
		*/
		SocketAppenderSkeleton(helpers::InetAddressPtr address, int port, int reconnectionDelay);

		/**
		Connects to remote server at <code>host</code> and <code>port</code>.
		*/
		SocketAppenderSkeleton(const LogString& host, int port, int reconnectionDelay);

		/**
		\copybrief AppenderSkeleton::activateOptions()

		Connects to the specified <b>RemoteHost</b> and <b>Port</b>.
		*/
		void activateOptions(helpers::Pool& p) override;

		void close() override;


		/**
		* This appender does not use a layout. Hence, this method
		* returns <code>false</code>.
		*
		     */
		bool requiresLayou...",1,main\include\log4cxx\net\socketappenderskeleton.hpp,LOG4CXX_NS.net,29,net,1
65394,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\net\syslogappender.hpp,main\include\log4cxx\net\syslogappender.hpp:<global>,,<global>,1
65398,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace net
{
/**
 * Use SyslogAppender to send log messages to a remote syslog daemon.
 *
 * Note that by default, this appender will split up messages that are
 * more than 1024 bytes long, for compatability with BSD syslog(see
 * RFC 3164).  Modern syslog implementations(e.g. syslog-ng) can accept
 * messages much larger, and may have a default of 8k.  You may modify
 * the default size of the messages by setting the MaxMessageLength option.
 *
 * When the message is too large for the current MaxMessageLength,
 * the packet number and total # will be appended to the end of the
 * message like this: (5/10)
 */
class LOG4CXX_EXPORT SyslogAppender : public AppenderSkeleton
{
	public:
		DECLARE_LOG4CXX_OBJECT(SyslogAppender)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(SyslogAppender)
		LOG4CXX_CAST_ENTRY_CHAIN(AppenderSkeleton)
		END_LOG4CXX_CAST_MAP()



		SyslogAppender();
		SyslogAppender(const LayoutPtr& layout, int syslogFacility);
		SyslogAppender(c...",1,main\include\log4cxx\net\syslogappender.hpp,LOG4CXX_NS,24,LOG4CXX_NS,1
65399,NAMESPACE_BLOCK,"namespace net
{
/**
 * Use SyslogAppender to send log messages to a remote syslog daemon.
 *
 * Note that by default, this appender will split up messages that are
 * more than 1024 bytes long, for compatability with BSD syslog(see
 * RFC 3164).  Modern syslog implementations(e.g. syslog-ng) can accept
 * messages much larger, and may have a default of 8k.  You may modify
 * the default size of the messages by setting the MaxMessageLength option.
 *
 * When the message is too large for the current MaxMessageLength,
 * the packet number and total # will be appended to the end of the
 * message like this: (5/10)
 */
class LOG4CXX_EXPORT SyslogAppender : public AppenderSkeleton
{
	public:
		DECLARE_LOG4CXX_OBJECT(SyslogAppender)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(SyslogAppender)
		LOG4CXX_CAST_ENTRY_CHAIN(AppenderSkeleton)
		END_LOG4CXX_CAST_MAP()



		SyslogAppender();
		SyslogAppender(const LayoutPtr& layout, int syslogFacility);
		SyslogAppender(const LayoutPtr& layout,...",1,main\include\log4cxx\net\syslogappender.hpp,LOG4CXX_NS.net,26,net,1
65415,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\net\telnetappender.hpp,main\include\log4cxx\net\telnetappender.hpp:<global>,,<global>,1
65419,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{
class ByteBuffer;
}
namespace net
{
typedef LOG4CXX_NS::helpers::SocketPtr Connection;
LOG4CXX_LIST_DEF(ConnectionList, Connection);

/**
<p>The TelnetAppender is a log4cxx appender that specializes in
writing to a read-only socket.  The output is provided in a
telnet-friendly way so that a log can be monitored over TCP/IP.
Clients using telnet connect to the socket and receive log data.
This is handy for remote monitoring, especially when monitoring a
servlet.

<p>Here is a list of the available configuration options:

<table border=1>
<tr>
<td align=center><b>Name</b></td>
<td align=center><b>Requirement</b></td>
<td align=center><b>Description</b></td>
<td align=center><b>Sample Value</b></td>
</tr>

<tr>
<td>Port</td>
<td>optional</td>
<td>This parameter determines the port to use for announcing log events.  The default port is 23 (telnet).</td>
<td>5875</td>
</table>
*/
class LOG4CXX_EXPORT TelnetAppender : public AppenderSkeleton
{
		...",1,main\include\log4cxx\net\telnetappender.hpp,LOG4CXX_NS,28,LOG4CXX_NS,1
65420,NAMESPACE_BLOCK,"namespace helpers
{
class ByteBuffer;
}",1,main\include\log4cxx\net\telnetappender.hpp,LOG4CXX_NS.helpers,30,helpers,1
65422,NAMESPACE_BLOCK,"namespace net
{
typedef LOG4CXX_NS::helpers::SocketPtr Connection;
LOG4CXX_LIST_DEF(ConnectionList, Connection);

/**
<p>The TelnetAppender is a log4cxx appender that specializes in
writing to a read-only socket.  The output is provided in a
telnet-friendly way so that a log can be monitored over TCP/IP.
Clients using telnet connect to the socket and receive log data.
This is handy for remote monitoring, especially when monitoring a
servlet.

<p>Here is a list of the available configuration options:

<table border=1>
<tr>
<td align=center><b>Name</b></td>
<td align=center><b>Requirement</b></td>
<td align=center><b>Description</b></td>
<td align=center><b>Sample Value</b></td>
</tr>

<tr>
<td>Port</td>
<td>optional</td>
<td>This parameter determines the port to use for announcing log events.  The default port is 23 (telnet).</td>
<td>5875</td>
</table>
*/
class LOG4CXX_EXPORT TelnetAppender : public AppenderSkeleton
{
		class SocketHandler;
		friend class SocketHandler;
	private:
		...",1,main\include\log4cxx\net\telnetappender.hpp,LOG4CXX_NS.net,34,net,2
65432,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\net\xmlsocketappender.hpp,main\include\log4cxx\net\xmlsocketappender.hpp:<global>,,<global>,1
65436,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace net
{

/**
Sends spi::LoggingEvent elements
to a remote a log server, usually in XML format.

Here is an example configuration that writes JSON to the
<a href=""https://docs.fluentbit.io/manual/pipeline/inputs/tcp"">TCP input plugin of a fluent-bit log server</a>
running on the same system as the application:
~~~{.xml}
<log4j:configuration xmlns:log4j=""http://jakarta.apache.org/log4j/"">
<appender name=""A1"" class=""XMLSocketAppender"">
  <param name=""RemoteHost"" value=""localhost"" />
  <param name=""Port""       value=""5170"" />
  <layout class=""JSONLayout""/>
</appender>
<root>
  <priority value =""INFO"" />
  <appender-ref ref=""A1"" />
</root>
</log4j:configuration>
~~~

<p>XMLSocketAppender has the following properties:

- The event will be logged with the same time stamp,
NDC, location info as if it were logged locally by
the client.

- Remote logging uses the TCP protocol. Consequently, if
the server is reachable, then log events will eventually arrive
at th...",1,main\include\log4cxx\net\xmlsocketappender.hpp,LOG4CXX_NS,24,LOG4CXX_NS,1
65437,NAMESPACE_BLOCK,"namespace net
{

/**
Sends spi::LoggingEvent elements
to a remote a log server, usually in XML format.

Here is an example configuration that writes JSON to the
<a href=""https://docs.fluentbit.io/manual/pipeline/inputs/tcp"">TCP input plugin of a fluent-bit log server</a>
running on the same system as the application:
~~~{.xml}
<log4j:configuration xmlns:log4j=""http://jakarta.apache.org/log4j/"">
<appender name=""A1"" class=""XMLSocketAppender"">
  <param name=""RemoteHost"" value=""localhost"" />
  <param name=""Port""       value=""5170"" />
  <layout class=""JSONLayout""/>
</appender>
<root>
  <priority value =""INFO"" />
  <appender-ref ref=""A1"" />
</root>
</log4j:configuration>
~~~

<p>XMLSocketAppender has the following properties:

- The event will be logged with the same time stamp,
NDC, location info as if it were logged locally by
the client.

- Remote logging uses the TCP protocol. Consequently, if
the server is reachable, then log events will eventually arrive
at the server.

- If the rem...",1,main\include\log4cxx\net\xmlsocketappender.hpp,LOG4CXX_NS.net,26,net,1
65443,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\nt\nteventlogappender.hpp,main\include\log4cxx\nt\nteventlogappender.hpp:<global>,,<global>,1
65447,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace nt
{
/**
 * Appends log events to NT EventLog.
 */
class LOG4CXX_EXPORT NTEventLogAppender : public AppenderSkeleton
{
	public:
		DECLARE_LOG4CXX_OBJECT(NTEventLogAppender)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(NTEventLogAppender)
		LOG4CXX_CAST_ENTRY_CHAIN(AppenderSkeleton)
		END_LOG4CXX_CAST_MAP()

		NTEventLogAppender();
		NTEventLogAppender(const LogString& server, const LogString& log,
			const LogString& source, const LayoutPtr& layout);

		virtual ~NTEventLogAppender();

		/**
		\copybrief AppenderSkeleton::activateOptions()

		Calls <a href=""https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-registereventsourcew"">RegisterEventSource</a>.
		*/
		void activateOptions(helpers::Pool& p) override;
		void close() override;

		/**
		\copybrief AppenderSkeleton::setOption()

		Supported options | Supported values | Default value
		-------------- | ---------------- | ---------------
		Server | (\ref winapi ""1"") | NULL
		S...",1,main\include\log4cxx\nt\nteventlogappender.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
65448,NAMESPACE_BLOCK,"namespace nt
{
/**
 * Appends log events to NT EventLog.
 */
class LOG4CXX_EXPORT NTEventLogAppender : public AppenderSkeleton
{
	public:
		DECLARE_LOG4CXX_OBJECT(NTEventLogAppender)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(NTEventLogAppender)
		LOG4CXX_CAST_ENTRY_CHAIN(AppenderSkeleton)
		END_LOG4CXX_CAST_MAP()

		NTEventLogAppender();
		NTEventLogAppender(const LogString& server, const LogString& log,
			const LogString& source, const LayoutPtr& layout);

		virtual ~NTEventLogAppender();

		/**
		\copybrief AppenderSkeleton::activateOptions()

		Calls <a href=""https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-registereventsourcew"">RegisterEventSource</a>.
		*/
		void activateOptions(helpers::Pool& p) override;
		void close() override;

		/**
		\copybrief AppenderSkeleton::setOption()

		Supported options | Supported values | Default value
		-------------- | ---------------- | ---------------
		Server | (\ref winapi ""1"") | NULL
		Source | (\ref winapi ""1...",1,main\include\log4cxx\nt\nteventlogappender.hpp,LOG4CXX_NS.nt,25,nt,1
65454,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\nt\outputdebugstringappender.hpp,main\include\log4cxx\nt\outputdebugstringappender.hpp:<global>,,<global>,1
65458,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace nt
{
class LOG4CXX_EXPORT OutputDebugStringAppender : public AppenderSkeleton
{
	public:
		DECLARE_LOG4CXX_OBJECT(OutputDebugStringAppender)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(OutputDebugStringAppender)
		LOG4CXX_CAST_ENTRY_CHAIN(AppenderSkeleton)
		END_LOG4CXX_CAST_MAP()

		OutputDebugStringAppender();

		bool requiresLayout() const override
		{
			return true;
		}

		void close() override {}

		void append(const spi::LoggingEventPtr& event, helpers::Pool& p) override;
};
}
}",1,main\include\log4cxx\nt\outputdebugstringappender.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
65459,NAMESPACE_BLOCK,"namespace nt
{
class LOG4CXX_EXPORT OutputDebugStringAppender : public AppenderSkeleton
{
	public:
		DECLARE_LOG4CXX_OBJECT(OutputDebugStringAppender)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(OutputDebugStringAppender)
		LOG4CXX_CAST_ENTRY_CHAIN(AppenderSkeleton)
		END_LOG4CXX_CAST_MAP()

		OutputDebugStringAppender();

		bool requiresLayout() const override
		{
			return true;
		}

		void close() override {}

		void append(const spi::LoggingEventPtr& event, helpers::Pool& p) override;
};
}",1,main\include\log4cxx\nt\outputdebugstringappender.hpp,LOG4CXX_NS.nt,25,nt,1
65464,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\pattern\classnamepatternconverter.hpp,main\include\log4cxx\pattern\classnamepatternconverter.hpp:<global>,,<global>,1
65468,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace pattern
{


/**
 * Formats the class name of the site of the logging request.
 *
 *
 *
 */
class LOG4CXX_EXPORT ClassNamePatternConverter : public NamePatternConverter
{
	public:
		/**
		 * @param options options, may be null.
		 */
		ClassNamePatternConverter(const std::vector<LogString>& options);

		DECLARE_LOG4CXX_PATTERN(ClassNamePatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(ClassNamePatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(NamePatternConverter)
		END_LOG4CXX_CAST_MAP()

		/**
		 * Gets an instance of ClassNamePatternConverter.
		 * @param options options, may be null.
		 * @return instance of pattern converter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		using NamePatternConverter::format;

		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			helpers::Pool& p) const override;
};

}
}",1,main\include\log4cxx\pattern\classnamepatternconverter.hpp,LOG4CXX_NS,24,LOG4CXX_NS,1
65469,NAMESPACE_BLOCK,"namespace pattern
{


/**
 * Formats the class name of the site of the logging request.
 *
 *
 *
 */
class LOG4CXX_EXPORT ClassNamePatternConverter : public NamePatternConverter
{
	public:
		/**
		 * @param options options, may be null.
		 */
		ClassNamePatternConverter(const std::vector<LogString>& options);

		DECLARE_LOG4CXX_PATTERN(ClassNamePatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(ClassNamePatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(NamePatternConverter)
		END_LOG4CXX_CAST_MAP()

		/**
		 * Gets an instance of ClassNamePatternConverter.
		 * @param options options, may be null.
		 * @return instance of pattern converter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		using NamePatternConverter::format;

		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			helpers::Pool& p) const override;
};

}",1,main\include\log4cxx\pattern\classnamepatternconverter.hpp,LOG4CXX_NS.pattern,26,pattern,1
65474,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\pattern\colorendpatternconverter.hpp,main\include\log4cxx\pattern\colorendpatternconverter.hpp:<global>,,<global>,1
65478,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace pattern
{


/**
 * Format the event's color end information.
 *
 *
 *
 */
class LOG4CXX_EXPORT ColorEndPatternConverter
	: public LoggingEventPatternConverter
{
	public:
		DECLARE_LOG4CXX_PATTERN(ColorEndPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(ColorEndPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		ColorEndPatternConverter();

		/**
		 * Obtains an instance of pattern converter.
		 * @param options options, may be null.
		 * @return instance of pattern converter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		using LoggingEventPatternConverter::format;

		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			helpers::Pool& p) const override;
};

}
}",1,main\include\log4cxx\pattern\colorendpatternconverter.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
65479,NAMESPACE_BLOCK,"namespace pattern
{


/**
 * Format the event's color end information.
 *
 *
 *
 */
class LOG4CXX_EXPORT ColorEndPatternConverter
	: public LoggingEventPatternConverter
{
	public:
		DECLARE_LOG4CXX_PATTERN(ColorEndPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(ColorEndPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		ColorEndPatternConverter();

		/**
		 * Obtains an instance of pattern converter.
		 * @param options options, may be null.
		 * @return instance of pattern converter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		using LoggingEventPatternConverter::format;

		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			helpers::Pool& p) const override;
};

}",1,main\include\log4cxx\pattern\colorendpatternconverter.hpp,LOG4CXX_NS.pattern,25,pattern,1
65484,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\pattern\colorstartpatternconverter.hpp,main\include\log4cxx\pattern\colorstartpatternconverter.hpp:<global>,,<global>,1
65488,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace pattern
{


/**
 * Format the event's color start information.
 *
 *
 *
 */
class LOG4CXX_EXPORT ColorStartPatternConverter
	: public LoggingEventPatternConverter
{
	struct ColorPatternConverterPrivate;

	public:
		DECLARE_LOG4CXX_PATTERN(ColorStartPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(ColorStartPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		ColorStartPatternConverter();

		/**
		 * Obtains an instance of pattern converter.
		 * @param options options, may be null.
		 * @return instance of pattern converter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		using LoggingEventPatternConverter::format;

		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			helpers::Pool& p) const override;

		void setFatalColor(const LogString& color);
		void setErrorColor(const LogString& color);
		void setWarnColor(co...",1,main\include\log4cxx\pattern\colorstartpatternconverter.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
65489,NAMESPACE_BLOCK,"namespace pattern
{


/**
 * Format the event's color start information.
 *
 *
 *
 */
class LOG4CXX_EXPORT ColorStartPatternConverter
	: public LoggingEventPatternConverter
{
	struct ColorPatternConverterPrivate;

	public:
		DECLARE_LOG4CXX_PATTERN(ColorStartPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(ColorStartPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		ColorStartPatternConverter();

		/**
		 * Obtains an instance of pattern converter.
		 * @param options options, may be null.
		 * @return instance of pattern converter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		using LoggingEventPatternConverter::format;

		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			helpers::Pool& p) const override;

		void setFatalColor(const LogString& color);
		void setErrorColor(const LogString& color);
		void setWarnColor(const LogString& color);
...",1,main\include\log4cxx\pattern\colorstartpatternconverter.hpp,LOG4CXX_NS.pattern,25,pattern,1
65500,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\pattern\datepatternconverter.hpp,main\include\log4cxx\pattern\datepatternconverter.hpp:<global>,,<global>,1
65504,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace pattern
{


/**
 * Convert and format a date or timestamp into a string.
 */
class LOG4CXX_EXPORT DatePatternConverter : public LoggingEventPatternConverter
{
		struct DatePatternConverterPrivate;

		/**
		 * Obtains an instance of pattern converter.
		 * @param options options, may be null.
		 * @return instance of pattern converter.
		 */
		static helpers::DateFormatPtr getDateFormat(const OptionsList& options);
	public:
		DECLARE_LOG4CXX_PATTERN(DatePatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(DatePatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		/**
		 * An object that can convert a date or timestamp to the format
		 * described by the conversion specifier in the first element in \c options.
		 *
		 * If the conversion specifier contains a \% character,
		 * the date is formated using <a href=""https://en.cppreference.com/w/cpp/chrono/c/strftime"">strftime</a>.
		 *
		 * Othe...",1,main\include\log4cxx\pattern\datepatternconverter.hpp,LOG4CXX_NS,26,LOG4CXX_NS,1
65505,NAMESPACE_BLOCK,"namespace pattern
{


/**
 * Convert and format a date or timestamp into a string.
 */
class LOG4CXX_EXPORT DatePatternConverter : public LoggingEventPatternConverter
{
		struct DatePatternConverterPrivate;

		/**
		 * Obtains an instance of pattern converter.
		 * @param options options, may be null.
		 * @return instance of pattern converter.
		 */
		static helpers::DateFormatPtr getDateFormat(const OptionsList& options);
	public:
		DECLARE_LOG4CXX_PATTERN(DatePatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(DatePatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		/**
		 * An object that can convert a date or timestamp to the format
		 * described by the conversion specifier in the first element in \c options.
		 *
		 * If the conversion specifier contains a \% character,
		 * the date is formated using <a href=""https://en.cppreference.com/w/cpp/chrono/c/strftime"">strftime</a>.
		 *
		 * Otherwise the conversion sp...",1,main\include\log4cxx\pattern\datepatternconverter.hpp,LOG4CXX_NS.pattern,28,pattern,1
65511,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\pattern\filedatepatternconverter.hpp,main\include\log4cxx\pattern\filedatepatternconverter.hpp:<global>,,<global>,1
65515,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace pattern
{


/**
 * Formats an date by delegating to DatePatternConverter.  The default
 * date pattern for a %d specifier in a file name is different than
 * the %d pattern in pattern layout.
 *
 *
 *
 */
class LOG4CXX_EXPORT FileDatePatternConverter
{
		/**
		 * Private constructor.
		 */
		FileDatePatternConverter();

	public:
		/**
		 * An instance of pattern converter for date conversion and formatting.
		 *
		 * \sa DatePatternConverter::newInstance()
		 *
		 * @param options If empty, used the patterm ""yyyy-MM-dd"".
		 * @return The date conversion and formatting instance.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);
};
}
}",1,main\include\log4cxx\pattern\filedatepatternconverter.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
65516,NAMESPACE_BLOCK,"namespace pattern
{


/**
 * Formats an date by delegating to DatePatternConverter.  The default
 * date pattern for a %d specifier in a file name is different than
 * the %d pattern in pattern layout.
 *
 *
 *
 */
class LOG4CXX_EXPORT FileDatePatternConverter
{
		/**
		 * Private constructor.
		 */
		FileDatePatternConverter();

	public:
		/**
		 * An instance of pattern converter for date conversion and formatting.
		 *
		 * \sa DatePatternConverter::newInstance()
		 *
		 * @param options If empty, used the patterm ""yyyy-MM-dd"".
		 * @return The date conversion and formatting instance.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);
};
}",1,main\include\log4cxx\pattern\filedatepatternconverter.hpp,LOG4CXX_NS.pattern,25,pattern,1
65521,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\pattern\filelocationpatternconverter.hpp,main\include\log4cxx\pattern\filelocationpatternconverter.hpp:<global>,,<global>,1
65525,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace pattern
{


/**
 * Return the event's line location information in a StringBuffer.
 *
 *
 *
 */
class LOG4CXX_EXPORT FileLocationPatternConverter
	: public LoggingEventPatternConverter
{
	public:
		DECLARE_LOG4CXX_PATTERN(FileLocationPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(FileLocationPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		FileLocationPatternConverter();

		/**
		 * Obtains an instance of pattern converter.
		 * @param options options, may be null.
		 * @return instance of pattern converter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		using LoggingEventPatternConverter::format;

		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			helpers::Pool& p) const override;
};

}
}",1,main\include\log4cxx\pattern\filelocationpatternconverter.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
65526,NAMESPACE_BLOCK,"namespace pattern
{


/**
 * Return the event's line location information in a StringBuffer.
 *
 *
 *
 */
class LOG4CXX_EXPORT FileLocationPatternConverter
	: public LoggingEventPatternConverter
{
	public:
		DECLARE_LOG4CXX_PATTERN(FileLocationPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(FileLocationPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		FileLocationPatternConverter();

		/**
		 * Obtains an instance of pattern converter.
		 * @param options options, may be null.
		 * @return instance of pattern converter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		using LoggingEventPatternConverter::format;

		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			helpers::Pool& p) const override;
};

}",1,main\include\log4cxx\pattern\filelocationpatternconverter.hpp,LOG4CXX_NS.pattern,25,pattern,1
65533,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\pattern\formattinginfo.hpp,main\include\log4cxx\pattern\formattinginfo.hpp:<global>,,<global>,1
65537,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace pattern
{


class FormattingInfo;
typedef std::shared_ptr<FormattingInfo> FormattingInfoPtr;


/**
 * Modifies the output of a pattern converter for a specified minimum
 * and maximum width and alignment.
 *
 *
 *
 *
 */
class LOG4CXX_EXPORT FormattingInfo : public virtual LOG4CXX_NS::helpers::Object
{
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(FormattingInfoPrivate, m_priv)

	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(FormattingInfo)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(FormattingInfo)
		END_LOG4CXX_CAST_MAP()


		/**
		 * Creates new instance.
		 * @param leftAlign left align if true.
		 * @param minLength minimum length.
		 * @param maxLength maximum length.
		 */
		FormattingInfo(
			const bool leftAlign, const int minLength, const int maxLength);
		~FormattingInfo();

		/**
		 * Gets default instance.
		 * @return default instance.
		 */
		static FormattingInfoPtr getDefault();

		/**
		 * Determine if left aligned.
		 * @return true if left...",1,main\include\log4cxx\pattern\formattinginfo.hpp,LOG4CXX_NS,25,LOG4CXX_NS,1
65538,NAMESPACE_BLOCK,"namespace pattern
{


class FormattingInfo;
typedef std::shared_ptr<FormattingInfo> FormattingInfoPtr;


/**
 * Modifies the output of a pattern converter for a specified minimum
 * and maximum width and alignment.
 *
 *
 *
 *
 */
class LOG4CXX_EXPORT FormattingInfo : public virtual LOG4CXX_NS::helpers::Object
{
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(FormattingInfoPrivate, m_priv)

	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(FormattingInfo)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(FormattingInfo)
		END_LOG4CXX_CAST_MAP()


		/**
		 * Creates new instance.
		 * @param leftAlign left align if true.
		 * @param minLength minimum length.
		 * @param maxLength maximum length.
		 */
		FormattingInfo(
			const bool leftAlign, const int minLength, const int maxLength);
		~FormattingInfo();

		/**
		 * Gets default instance.
		 * @return default instance.
		 */
		static FormattingInfoPtr getDefault();

		/**
		 * Determine if left aligned.
		 * @return true if left aligned.
		 */
		bool ...",1,main\include\log4cxx\pattern\formattinginfo.hpp,LOG4CXX_NS.pattern,27,pattern,1
65546,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\pattern\fulllocationpatternconverter.hpp,main\include\log4cxx\pattern\fulllocationpatternconverter.hpp:<global>,,<global>,1
65550,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace pattern
{


/**
 * Format the event's line location information.
 *
 *
 *
 */
class LOG4CXX_EXPORT FullLocationPatternConverter
	: public LoggingEventPatternConverter
{
	public:
		DECLARE_LOG4CXX_PATTERN(FullLocationPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(FullLocationPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		FullLocationPatternConverter();

		/**
		 * Obtains an instance of pattern converter.
		 * @param options options, may be null.
		 * @return instance of pattern converter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		using LoggingEventPatternConverter::format;

		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			helpers::Pool& p) const override;
};

}
}",1,main\include\log4cxx\pattern\fulllocationpatternconverter.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
65551,NAMESPACE_BLOCK,"namespace pattern
{


/**
 * Format the event's line location information.
 *
 *
 *
 */
class LOG4CXX_EXPORT FullLocationPatternConverter
	: public LoggingEventPatternConverter
{
	public:
		DECLARE_LOG4CXX_PATTERN(FullLocationPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(FullLocationPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		FullLocationPatternConverter();

		/**
		 * Obtains an instance of pattern converter.
		 * @param options options, may be null.
		 * @return instance of pattern converter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		using LoggingEventPatternConverter::format;

		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			helpers::Pool& p) const override;
};

}",1,main\include\log4cxx\pattern\fulllocationpatternconverter.hpp,LOG4CXX_NS.pattern,25,pattern,1
65556,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\pattern\integerpatternconverter.hpp,main\include\log4cxx\pattern\integerpatternconverter.hpp:<global>,,<global>,1
65560,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace pattern
{


/**
 * Formats an integer.
 *
 *
 *
 */
class LOG4CXX_EXPORT IntegerPatternConverter : public PatternConverter
{
	public:
		DECLARE_LOG4CXX_PATTERN(IntegerPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(IntegerPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(PatternConverter)
		END_LOG4CXX_CAST_MAP()

		IntegerPatternConverter();

		/**
		 * Obtains an instance of pattern converter.
		 * @param options options, may be null.
		 * @return instance of pattern converter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		void format(const helpers::ObjectPtr& obj,
			LogString& toAppendTo,
			helpers::Pool& p) const override;
};

LOG4CXX_PTR_DEF(IntegerPatternConverter);

}
}",1,main\include\log4cxx\pattern\integerpatternconverter.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
65561,NAMESPACE_BLOCK,"namespace pattern
{


/**
 * Formats an integer.
 *
 *
 *
 */
class LOG4CXX_EXPORT IntegerPatternConverter : public PatternConverter
{
	public:
		DECLARE_LOG4CXX_PATTERN(IntegerPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(IntegerPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(PatternConverter)
		END_LOG4CXX_CAST_MAP()

		IntegerPatternConverter();

		/**
		 * Obtains an instance of pattern converter.
		 * @param options options, may be null.
		 * @return instance of pattern converter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		void format(const helpers::ObjectPtr& obj,
			LogString& toAppendTo,
			helpers::Pool& p) const override;
};

LOG4CXX_PTR_DEF(IntegerPatternConverter);

}",1,main\include\log4cxx\pattern\integerpatternconverter.hpp,LOG4CXX_NS.pattern,25,pattern,1
65567,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\pattern\levelpatternconverter.hpp,main\include\log4cxx\pattern\levelpatternconverter.hpp:<global>,,<global>,1
65571,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace pattern
{


/**
 * Return the event's level in a StringBuffer.
 *
 *
 *
 */
class LOG4CXX_EXPORT LevelPatternConverter : public LoggingEventPatternConverter
{
	public:
		DECLARE_LOG4CXX_PATTERN(LevelPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(LevelPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		LevelPatternConverter();

		/**
		 * Obtains an instance of pattern converter.
		 * @param options options, may be null.
		 * @return instance of pattern converter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		using LoggingEventPatternConverter::format;

		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			helpers::Pool& p) const override;

		LogString getStyleClass(const 	helpers::ObjectPtr& e) const override;
};
}
}",1,main\include\log4cxx\pattern\levelpatternconverter.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
65572,NAMESPACE_BLOCK,"namespace pattern
{


/**
 * Return the event's level in a StringBuffer.
 *
 *
 *
 */
class LOG4CXX_EXPORT LevelPatternConverter : public LoggingEventPatternConverter
{
	public:
		DECLARE_LOG4CXX_PATTERN(LevelPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(LevelPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		LevelPatternConverter();

		/**
		 * Obtains an instance of pattern converter.
		 * @param options options, may be null.
		 * @return instance of pattern converter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		using LoggingEventPatternConverter::format;

		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			helpers::Pool& p) const override;

		LogString getStyleClass(const 	helpers::ObjectPtr& e) const override;
};
}",1,main\include\log4cxx\pattern\levelpatternconverter.hpp,LOG4CXX_NS.pattern,25,pattern,1
65577,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\pattern\linelocationpatternconverter.hpp,main\include\log4cxx\pattern\linelocationpatternconverter.hpp:<global>,,<global>,1
65581,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace pattern
{


/**
 * Format the event's line location information.
 *
 *
 *
 */
class LOG4CXX_EXPORT LineLocationPatternConverter
	: public LoggingEventPatternConverter
{
	public:
		DECLARE_LOG4CXX_PATTERN(LineLocationPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(LineLocationPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		LineLocationPatternConverter();

		/**
		 * Obtains an instance of pattern converter.
		 * @param options options, may be null.
		 * @return instance of pattern converter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		using LoggingEventPatternConverter::format;

		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			helpers::Pool& p) const override;
};

}
}",1,main\include\log4cxx\pattern\linelocationpatternconverter.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
65582,NAMESPACE_BLOCK,"namespace pattern
{


/**
 * Format the event's line location information.
 *
 *
 *
 */
class LOG4CXX_EXPORT LineLocationPatternConverter
	: public LoggingEventPatternConverter
{
	public:
		DECLARE_LOG4CXX_PATTERN(LineLocationPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(LineLocationPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		LineLocationPatternConverter();

		/**
		 * Obtains an instance of pattern converter.
		 * @param options options, may be null.
		 * @return instance of pattern converter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		using LoggingEventPatternConverter::format;

		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			helpers::Pool& p) const override;
};

}",1,main\include\log4cxx\pattern\linelocationpatternconverter.hpp,LOG4CXX_NS.pattern,25,pattern,1
65587,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\pattern\lineseparatorpatternconverter.hpp,main\include\log4cxx\pattern\lineseparatorpatternconverter.hpp:<global>,,<global>,1
65591,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace pattern
{


/**
 * Formats a line separator.
 *
 *
 *
 */
class LOG4CXX_EXPORT LineSeparatorPatternConverter
	: public LoggingEventPatternConverter
{
	public:
		DECLARE_LOG4CXX_PATTERN(LineSeparatorPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(LineSeparatorPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		LineSeparatorPatternConverter();

		/**
		 * Obtains an instance of pattern converter.
		 * @param options options, may be null.
		 * @return instance of pattern converter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		using LoggingEventPatternConverter::format;

		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			helpers::Pool& p) const override;

		void format(const helpers::ObjectPtr& obj,
			LogString& toAppendTo,
			helpers::Pool& p) const override;
};

}
}",1,main\include\log4cxx\pattern\lineseparatorpatternconverter.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
65592,NAMESPACE_BLOCK,"namespace pattern
{


/**
 * Formats a line separator.
 *
 *
 *
 */
class LOG4CXX_EXPORT LineSeparatorPatternConverter
	: public LoggingEventPatternConverter
{
	public:
		DECLARE_LOG4CXX_PATTERN(LineSeparatorPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(LineSeparatorPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		LineSeparatorPatternConverter();

		/**
		 * Obtains an instance of pattern converter.
		 * @param options options, may be null.
		 * @return instance of pattern converter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		using LoggingEventPatternConverter::format;

		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			helpers::Pool& p) const override;

		void format(const helpers::ObjectPtr& obj,
			LogString& toAppendTo,
			helpers::Pool& p) const override;
};

}",1,main\include\log4cxx\pattern\lineseparatorpatternconverter.hpp,LOG4CXX_NS.pattern,25,pattern,1
65597,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\pattern\literalpatternconverter.hpp,main\include\log4cxx\pattern\literalpatternconverter.hpp:<global>,,<global>,1
65601,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace pattern
{

/**
 * Formats a string literal.
 *
 *
 *
 *
 */
class LOG4CXX_EXPORT LiteralPatternConverter : public LoggingEventPatternConverter
{
		struct LiteralPatternConverterPrivate;

	public:
		DECLARE_LOG4CXX_PATTERN(LiteralPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(LiteralPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		LiteralPatternConverter(const LogString& literal);

		static PatternConverterPtr newInstance(const LogString& literal);

		using LoggingEventPatternConverter::format;

		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			helpers::Pool& p) const override;

		void format(const helpers::ObjectPtr& obj,
			LogString& toAppendTo,
			helpers::Pool& p) const override;
};

}
}",1,main\include\log4cxx\pattern\literalpatternconverter.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
65602,NAMESPACE_BLOCK,"namespace pattern
{

/**
 * Formats a string literal.
 *
 *
 *
 *
 */
class LOG4CXX_EXPORT LiteralPatternConverter : public LoggingEventPatternConverter
{
		struct LiteralPatternConverterPrivate;

	public:
		DECLARE_LOG4CXX_PATTERN(LiteralPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(LiteralPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		LiteralPatternConverter(const LogString& literal);

		static PatternConverterPtr newInstance(const LogString& literal);

		using LoggingEventPatternConverter::format;

		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			helpers::Pool& p) const override;

		void format(const helpers::ObjectPtr& obj,
			LogString& toAppendTo,
			helpers::Pool& p) const override;
};

}",1,main\include\log4cxx\pattern\literalpatternconverter.hpp,LOG4CXX_NS.pattern,25,pattern,1
65607,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\pattern\loggerpatternconverter.hpp,main\include\log4cxx\pattern\loggerpatternconverter.hpp:<global>,,<global>,1
65611,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace pattern
{


/**
 * Formats a logger name.
 *
 *
 *
 *
 */
class LOG4CXX_EXPORT LoggerPatternConverter : public NamePatternConverter
{
	public:
		DECLARE_LOG4CXX_PATTERN(LoggerPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(LoggerPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(NamePatternConverter)
		END_LOG4CXX_CAST_MAP()

		LoggerPatternConverter(const std::vector<LogString>& options);

		/**
		 * Obtains an instance of pattern converter.
		 * @param options options, may be null.
		 * @return instance of pattern converter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		using NamePatternConverter::format;

		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			helpers::Pool& p) const override;
};

}
}",1,main\include\log4cxx\pattern\loggerpatternconverter.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
65612,NAMESPACE_BLOCK,"namespace pattern
{


/**
 * Formats a logger name.
 *
 *
 *
 *
 */
class LOG4CXX_EXPORT LoggerPatternConverter : public NamePatternConverter
{
	public:
		DECLARE_LOG4CXX_PATTERN(LoggerPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(LoggerPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(NamePatternConverter)
		END_LOG4CXX_CAST_MAP()

		LoggerPatternConverter(const std::vector<LogString>& options);

		/**
		 * Obtains an instance of pattern converter.
		 * @param options options, may be null.
		 * @return instance of pattern converter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		using NamePatternConverter::format;

		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			helpers::Pool& p) const override;
};

}",1,main\include\log4cxx\pattern\loggerpatternconverter.hpp,LOG4CXX_NS.pattern,25,pattern,1
65619,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\pattern\loggingeventpatternconverter.hpp,main\include\log4cxx\pattern\loggingeventpatternconverter.hpp:<global>,,<global>,1
65623,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{

namespace pattern
{
/**
* LoggingEventPatternConverter is a base class for pattern converters
* that can format information from instances of LoggingEvent.
*
*
*
*
*/
class LOG4CXX_EXPORT LoggingEventPatternConverter : public PatternConverter
{
	protected:
		/**
		 * Constructs an instance of LoggingEventPatternConverter.
		 * @param name name of converter.
		 * @param style CSS style for output.
		 */
		LoggingEventPatternConverter(
			const LogString& name, const LogString& style);

		LoggingEventPatternConverter(std::unique_ptr<PatternConverterPrivate> priv);

	public:
		DECLARE_LOG4CXX_PATTERN(LoggingEventPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(LoggingEventPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(PatternConverter)
		END_LOG4CXX_CAST_MAP()

		/**
		 * Formats an event into a string buffer.
		 * @param event event to format, may not be null.
		 * @param toAppendTo string buffer to which the formatted event will be appended.  Ma...",1,main\include\log4cxx\pattern\loggingeventpatternconverter.hpp,LOG4CXX_NS,24,LOG4CXX_NS,1
65624,NAMESPACE_BLOCK,"namespace pattern
{
/**
* LoggingEventPatternConverter is a base class for pattern converters
* that can format information from instances of LoggingEvent.
*
*
*
*
*/
class LOG4CXX_EXPORT LoggingEventPatternConverter : public PatternConverter
{
	protected:
		/**
		 * Constructs an instance of LoggingEventPatternConverter.
		 * @param name name of converter.
		 * @param style CSS style for output.
		 */
		LoggingEventPatternConverter(
			const LogString& name, const LogString& style);

		LoggingEventPatternConverter(std::unique_ptr<PatternConverterPrivate> priv);

	public:
		DECLARE_LOG4CXX_PATTERN(LoggingEventPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(LoggingEventPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(PatternConverter)
		END_LOG4CXX_CAST_MAP()

		/**
		 * Formats an event into a string buffer.
		 * @param event event to format, may not be null.
		 * @param toAppendTo string buffer to which the formatted event will be appended.  May not be null.
		 * @par...",1,main\include\log4cxx\pattern\loggingeventpatternconverter.hpp,LOG4CXX_NS.pattern,27,pattern,1
65630,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\pattern\mdcpatternconverter.hpp,main\include\log4cxx\pattern\mdcpatternconverter.hpp:<global>,,<global>,1
65634,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace pattern
{


/**
 * Provides all key value pairs in JSON or a single value from an event's mapped diagnostic context
 */
class LOG4CXX_EXPORT MDCPatternConverter : public LoggingEventPatternConverter
{
	public:
		DECLARE_LOG4CXX_PATTERN(MDCPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(MDCPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		MDCPatternConverter
			( const LogString&              name = LogString()
			, const LogString&              style = LogString()
			, const std::vector<LogString>& options = std::vector<LogString>()
			);

		/**
		 * An instance of MDCPatternConverter.
		 * @param options if not empty, options[0][0] is the character to duplicate
		 */
		static PatternConverterPtr newInstance(const std::vector<LogString>& options);

		using LoggingEventPatternConverter::format;

		void format
			( const spi::LoggingEventPtr& event
			, LogString&                  t...",1,main\include\log4cxx\pattern\mdcpatternconverter.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
65635,NAMESPACE_BLOCK,"namespace pattern
{


/**
 * Provides all key value pairs in JSON or a single value from an event's mapped diagnostic context
 */
class LOG4CXX_EXPORT MDCPatternConverter : public LoggingEventPatternConverter
{
	public:
		DECLARE_LOG4CXX_PATTERN(MDCPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(MDCPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		MDCPatternConverter
			( const LogString&              name = LogString()
			, const LogString&              style = LogString()
			, const std::vector<LogString>& options = std::vector<LogString>()
			);

		/**
		 * An instance of MDCPatternConverter.
		 * @param options if not empty, options[0][0] is the character to duplicate
		 */
		static PatternConverterPtr newInstance(const std::vector<LogString>& options);

		using LoggingEventPatternConverter::format;

		void format
			( const spi::LoggingEventPtr& event
			, LogString&                  toAppendTo
			, helpers:...",1,main\include\log4cxx\pattern\mdcpatternconverter.hpp,LOG4CXX_NS.pattern,25,pattern,1
65640,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\pattern\messagepatternconverter.hpp,main\include\log4cxx\pattern\messagepatternconverter.hpp:<global>,,<global>,1
65644,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace pattern
{


/**
 * Formats the message of an logging event.
 *
 *
 *
 */
class LOG4CXX_EXPORT MessagePatternConverter : public LoggingEventPatternConverter
{
	public:
		DECLARE_LOG4CXX_PATTERN(MessagePatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(MessagePatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		MessagePatternConverter();

		/**
		 * Obtains an instance of pattern converter.
		 * @param options options, may be null.
		 * @return instance of pattern converter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		using LoggingEventPatternConverter::format;

		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			helpers::Pool& p) const override;
};
}
}",1,main\include\log4cxx\pattern\messagepatternconverter.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
65645,NAMESPACE_BLOCK,"namespace pattern
{


/**
 * Formats the message of an logging event.
 *
 *
 *
 */
class LOG4CXX_EXPORT MessagePatternConverter : public LoggingEventPatternConverter
{
	public:
		DECLARE_LOG4CXX_PATTERN(MessagePatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(MessagePatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		MessagePatternConverter();

		/**
		 * Obtains an instance of pattern converter.
		 * @param options options, may be null.
		 * @return instance of pattern converter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		using LoggingEventPatternConverter::format;

		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			helpers::Pool& p) const override;
};
}",1,main\include\log4cxx\pattern\messagepatternconverter.hpp,LOG4CXX_NS.pattern,25,pattern,1
65650,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\pattern\methodlocationpatternconverter.hpp,main\include\log4cxx\pattern\methodlocationpatternconverter.hpp:<global>,,<global>,1
65654,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace pattern
{


/**
 * Return the event's line location information in a StringBuffer.
 *
 *
 *
 */
class LOG4CXX_EXPORT MethodLocationPatternConverter
	: public LoggingEventPatternConverter
{
	public:
		DECLARE_LOG4CXX_PATTERN(MethodLocationPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(MethodLocationPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		MethodLocationPatternConverter();

		/**
		 * Obtains an instance of MethodLocationPatternConverter.
		 * @param options options, may be null.
		 * @return instance of MethodLocationPatternConverter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		using LoggingEventPatternConverter::format;

		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			helpers::Pool& p) const override;
};
}
}",1,main\include\log4cxx\pattern\methodlocationpatternconverter.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
65655,NAMESPACE_BLOCK,"namespace pattern
{


/**
 * Return the event's line location information in a StringBuffer.
 *
 *
 *
 */
class LOG4CXX_EXPORT MethodLocationPatternConverter
	: public LoggingEventPatternConverter
{
	public:
		DECLARE_LOG4CXX_PATTERN(MethodLocationPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(MethodLocationPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		MethodLocationPatternConverter();

		/**
		 * Obtains an instance of MethodLocationPatternConverter.
		 * @param options options, may be null.
		 * @return instance of MethodLocationPatternConverter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		using LoggingEventPatternConverter::format;

		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			helpers::Pool& p) const override;
};
}",1,main\include\log4cxx\pattern\methodlocationpatternconverter.hpp,LOG4CXX_NS.pattern,25,pattern,1
65662,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\pattern\nameabbreviator.hpp,main\include\log4cxx\pattern\nameabbreviator.hpp:<global>,,<global>,1
65666,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace pattern
{

class NameAbbreviator;
LOG4CXX_PTR_DEF(NameAbbreviator);

/**
 * NameAbbreviator generates abbreviated logger and class names.
 *
 *
 *
 */
class LOG4CXX_EXPORT NameAbbreviator : public LOG4CXX_NS::helpers::Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(NameAbbreviator)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(NameAbbreviator)
		END_LOG4CXX_CAST_MAP()

	protected:
		NameAbbreviator();

	public:
		virtual ~NameAbbreviator();

		/**
		 * Gets an abbreviator.
		 *
		 * For example, ""%logger{2}"" will output only 2 elements of the logger name,
		 * ""%logger{1.}"" will output only the first character of the non-final elements in the name,
		 * ""%logger(1~.2~} will output the first character of the first element, two characters of
		 * the second and subsequent elements and will use a tilde to indicate abbreviated characters.
		 *
		 * @param pattern abbreviation pattern.
		 * @return abbreviator, will not be null.
		 */
		static NameA...",1,main\include\log4cxx\pattern\nameabbreviator.hpp,LOG4CXX_NS,24,LOG4CXX_NS,1
65667,NAMESPACE_BLOCK,"namespace pattern
{

class NameAbbreviator;
LOG4CXX_PTR_DEF(NameAbbreviator);

/**
 * NameAbbreviator generates abbreviated logger and class names.
 *
 *
 *
 */
class LOG4CXX_EXPORT NameAbbreviator : public LOG4CXX_NS::helpers::Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(NameAbbreviator)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(NameAbbreviator)
		END_LOG4CXX_CAST_MAP()

	protected:
		NameAbbreviator();

	public:
		virtual ~NameAbbreviator();

		/**
		 * Gets an abbreviator.
		 *
		 * For example, ""%logger{2}"" will output only 2 elements of the logger name,
		 * ""%logger{1.}"" will output only the first character of the non-final elements in the name,
		 * ""%logger(1~.2~} will output the first character of the first element, two characters of
		 * the second and subsequent elements and will use a tilde to indicate abbreviated characters.
		 *
		 * @param pattern abbreviation pattern.
		 * @return abbreviator, will not be null.
		 */
		static NameAbbreviatorPtr getAbbrev...",1,main\include\log4cxx\pattern\nameabbreviator.hpp,LOG4CXX_NS.pattern,26,pattern,1
65678,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\pattern\namepatternconverter.hpp,main\include\log4cxx\pattern\namepatternconverter.hpp:<global>,,<global>,1
65682,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace pattern
{

/**
 *
 * Base class for other pattern converters which can return only parts of their name.
 *
 */
class LOG4CXX_EXPORT NamePatternConverter : public LoggingEventPatternConverter
{
		struct NamePatternConverterPrivate;

	public:
		DECLARE_LOG4CXX_PATTERN(NamePatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(NamePatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()


	protected:
		/**
		 * Constructor.
		 * @param name name of converter.
		 * @param style style name for associated output.
		 * @param options options, may be null, first element will be interpreted as an abbreviation pattern.
		 */
		NamePatternConverter(
			const LogString& name,
			const LogString& style,
			const std::vector<LogString>& options);

		/**
		 * Abbreviate name in string buffer.
		 * @param nameStart starting position of name to abbreviate.
		 * @param buf string buffer containing name.
		 */
		voi...",1,main\include\log4cxx\pattern\namepatternconverter.hpp,LOG4CXX_NS,26,LOG4CXX_NS,1
65683,NAMESPACE_BLOCK,"namespace pattern
{

/**
 *
 * Base class for other pattern converters which can return only parts of their name.
 *
 */
class LOG4CXX_EXPORT NamePatternConverter : public LoggingEventPatternConverter
{
		struct NamePatternConverterPrivate;

	public:
		DECLARE_LOG4CXX_PATTERN(NamePatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(NamePatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()


	protected:
		/**
		 * Constructor.
		 * @param name name of converter.
		 * @param style style name for associated output.
		 * @param options options, may be null, first element will be interpreted as an abbreviation pattern.
		 */
		NamePatternConverter(
			const LogString& name,
			const LogString& style,
			const std::vector<LogString>& options);

		/**
		 * Abbreviate name in string buffer.
		 * @param nameStart starting position of name to abbreviate.
		 * @param buf string buffer containing name.
		 */
		void abbreviate(LogString:...",1,main\include\log4cxx\pattern\namepatternconverter.hpp,LOG4CXX_NS.pattern,28,pattern,1
65688,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\pattern\ndcpatternconverter.hpp,main\include\log4cxx\pattern\ndcpatternconverter.hpp:<global>,,<global>,1
65692,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace pattern
{


/**
 * Return the event's NDC in a StringBuffer.
 *
 *
 *
 */
class LOG4CXX_EXPORT NDCPatternConverter : public LoggingEventPatternConverter
{
	public:
		DECLARE_LOG4CXX_PATTERN(NDCPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(NDCPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		NDCPatternConverter();

		/**
		 * Obtains an instance of NDCPatternConverter.
		 * @param options options, may be null.
		 * @return instance of NDCPatternConverter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		using LoggingEventPatternConverter::format;

		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			helpers::Pool& p) const override;
};
}
}",1,main\include\log4cxx\pattern\ndcpatternconverter.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
65693,NAMESPACE_BLOCK,"namespace pattern
{


/**
 * Return the event's NDC in a StringBuffer.
 *
 *
 *
 */
class LOG4CXX_EXPORT NDCPatternConverter : public LoggingEventPatternConverter
{
	public:
		DECLARE_LOG4CXX_PATTERN(NDCPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(NDCPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		NDCPatternConverter();

		/**
		 * Obtains an instance of NDCPatternConverter.
		 * @param options options, may be null.
		 * @return instance of NDCPatternConverter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		using LoggingEventPatternConverter::format;

		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			helpers::Pool& p) const override;
};
}",1,main\include\log4cxx\pattern\ndcpatternconverter.hpp,LOG4CXX_NS.pattern,25,pattern,1
65702,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\pattern\patternconverter.hpp,main\include\log4cxx\pattern\patternconverter.hpp:<global>,,<global>,1
65706,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace pattern
{

typedef std::vector<LogString> OptionsList;

/**

   <p>PatternConverter is an abstract class that provides the
   formatting functionality that derived classes need.

   <p>Conversion specifiers in a conversion patterns are parsed to
   individual PatternConverters. Each of which is responsible for
   converting an object in a converter specific manner.

 */
class LOG4CXX_EXPORT PatternConverter : public virtual helpers::Object
{
	protected:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(PatternConverterPrivate, m_priv)
		PatternConverter(LOG4CXX_PRIVATE_PTR(PatternConverterPrivate) priv);

		/**
		 * Create a new pattern converter.  Use this constructor when you have a subclass
		 * that does not have any private data.
		 * @param name name for pattern converter.
		 * @param style CSS style for formatted output.
		 */
		PatternConverter(const LogString& name,
			const LogString& style);

		virtual ~PatternConverter();

	public:
        DECLARE_LOG...",1,main\include\log4cxx\pattern\patternconverter.hpp,LOG4CXX_NS,28,LOG4CXX_NS,1
65707,NAMESPACE_BLOCK,"namespace pattern
{

typedef std::vector<LogString> OptionsList;

/**

   <p>PatternConverter is an abstract class that provides the
   formatting functionality that derived classes need.

   <p>Conversion specifiers in a conversion patterns are parsed to
   individual PatternConverters. Each of which is responsible for
   converting an object in a converter specific manner.

 */
class LOG4CXX_EXPORT PatternConverter : public virtual helpers::Object
{
	protected:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(PatternConverterPrivate, m_priv)
		PatternConverter(LOG4CXX_PRIVATE_PTR(PatternConverterPrivate) priv);

		/**
		 * Create a new pattern converter.  Use this constructor when you have a subclass
		 * that does not have any private data.
		 * @param name name for pattern converter.
		 * @param style CSS style for formatted output.
		 */
		PatternConverter(const LogString& name,
			const LogString& style);

		virtual ~PatternConverter();

	public:
        DECLARE_LOG4CXX_PATTERN(PatternCon...",1,main\include\log4cxx\pattern\patternconverter.hpp,LOG4CXX_NS.pattern,30,pattern,1
65724,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\pattern\patternparser.hpp,main\include\log4cxx\pattern\patternparser.hpp:<global>,,<global>,1
65728,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace pattern
{

typedef std::function<PatternConverterPtr(const std::vector<LogString>& options)> PatternConstructor;
typedef std::map<LogString, PatternConstructor> PatternMap;


// Contributors:   Nelson Minar <(nelson@monkey.org>
//                 Igor E. Poteryaev <jah@mail.ru>
//                 Reinhard Deschler <reinhard.deschler@web.de>

/**
 * Most of the work of the {@link log4cxx::PatternLayout PatternLayout} class
 * is delegated to the PatternParser class.
 * <p>It is this class that parses conversion patterns and creates
 * a chained list of {@link PatternConverter PatternConverters}.
 *
 *
*/
class LOG4CXX_EXPORT PatternParser
{
		/**
		 * Escape character for format specifier.
		 */
		static const logchar ESCAPE_CHAR;

		enum
		{
			LITERAL_STATE = 0,
			CONVERTER_STATE = 1,
			DOT_STATE = 3,
			MIN_STATE = 4,
			MAX_STATE = 5
		};

		/**
		 * Private constructor.
		 */
		PatternParser();

	private:
		/** Extract the converter identifier ...",1,main\include\log4cxx\pattern\patternparser.hpp,LOG4CXX_NS,29,LOG4CXX_NS,1
65729,NAMESPACE_BLOCK,"namespace pattern
{

typedef std::function<PatternConverterPtr(const std::vector<LogString>& options)> PatternConstructor;
typedef std::map<LogString, PatternConstructor> PatternMap;


// Contributors:   Nelson Minar <(nelson@monkey.org>
//                 Igor E. Poteryaev <jah@mail.ru>
//                 Reinhard Deschler <reinhard.deschler@web.de>

/**
 * Most of the work of the {@link log4cxx::PatternLayout PatternLayout} class
 * is delegated to the PatternParser class.
 * <p>It is this class that parses conversion patterns and creates
 * a chained list of {@link PatternConverter PatternConverters}.
 *
 *
*/
class LOG4CXX_EXPORT PatternParser
{
		/**
		 * Escape character for format specifier.
		 */
		static const logchar ESCAPE_CHAR;

		enum
		{
			LITERAL_STATE = 0,
			CONVERTER_STATE = 1,
			DOT_STATE = 3,
			MIN_STATE = 4,
			MAX_STATE = 5
		};

		/**
		 * Private constructor.
		 */
		PatternParser();

	private:
		/** Extract the converter identifier found at position i.
		...",1,main\include\log4cxx\pattern\patternparser.hpp,LOG4CXX_NS.pattern,31,pattern,1
65736,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\pattern\propertiespatternconverter.hpp,main\include\log4cxx\pattern\propertiespatternconverter.hpp:<global>,,<global>,1
65740,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace pattern
{


/**
 * Able to handle the contents of the LoggingEvent's Property bundle and either
 * output the entire contents of the properties in a similar format to the
 * java.util.Hashtable.toString(), or to output the value of a specific key
 * within the property bundle
 * when this pattern converter has the option set.
 *
 *
 *
 */
class LOG4CXX_EXPORT PropertiesPatternConverter
	: public LoggingEventPatternConverter
{
		struct PropertiesPatternConverterPrivate;

	public:
		DECLARE_LOG4CXX_PATTERN(PropertiesPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(PropertiesPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		/**
		 * A Property bundle converter.
		 *
		 * @param name of the converter.
		 * @param option may be null.
		 */
		PropertiesPatternConverter(const LogString& name, const LogString& option);

		/**
		 * Obtains an instance of PropertiesPatternConverter.
		 * @pa...",1,main\include\log4cxx\pattern\propertiespatternconverter.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
65741,NAMESPACE_BLOCK,"namespace pattern
{


/**
 * Able to handle the contents of the LoggingEvent's Property bundle and either
 * output the entire contents of the properties in a similar format to the
 * java.util.Hashtable.toString(), or to output the value of a specific key
 * within the property bundle
 * when this pattern converter has the option set.
 *
 *
 *
 */
class LOG4CXX_EXPORT PropertiesPatternConverter
	: public LoggingEventPatternConverter
{
		struct PropertiesPatternConverterPrivate;

	public:
		DECLARE_LOG4CXX_PATTERN(PropertiesPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(PropertiesPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		/**
		 * A Property bundle converter.
		 *
		 * @param name of the converter.
		 * @param option may be null.
		 */
		PropertiesPatternConverter(const LogString& name, const LogString& option);

		/**
		 * Obtains an instance of PropertiesPatternConverter.
		 * @param options options, ma...",1,main\include\log4cxx\pattern\propertiespatternconverter.hpp,LOG4CXX_NS.pattern,25,pattern,1
65746,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\pattern\relativetimepatternconverter.hpp,main\include\log4cxx\pattern\relativetimepatternconverter.hpp:<global>,,<global>,1
65750,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace pattern
{


/**
 * Format the relative time in milliseconds.
 *
 *
 *
 */
class LOG4CXX_EXPORT RelativeTimePatternConverter : public LoggingEventPatternConverter
{
	public:
		DECLARE_LOG4CXX_PATTERN(RelativeTimePatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(RelativeTimePatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		/**
		 * Private constructor.
		 */
		RelativeTimePatternConverter();

		/**
		 * Obtains an instance of RelativeTimePatternConverter.
		 * @param options options, currently ignored, may be null.
		 * @return instance of RelativeTimePatternConverter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		using LoggingEventPatternConverter::format;


		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			LOG4CXX_NS::helpers::Pool& p) const override;
};
}
}",1,main\include\log4cxx\pattern\relativetimepatternconverter.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
65751,NAMESPACE_BLOCK,"namespace pattern
{


/**
 * Format the relative time in milliseconds.
 *
 *
 *
 */
class LOG4CXX_EXPORT RelativeTimePatternConverter : public LoggingEventPatternConverter
{
	public:
		DECLARE_LOG4CXX_PATTERN(RelativeTimePatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(RelativeTimePatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		/**
		 * Private constructor.
		 */
		RelativeTimePatternConverter();

		/**
		 * Obtains an instance of RelativeTimePatternConverter.
		 * @param options options, currently ignored, may be null.
		 * @return instance of RelativeTimePatternConverter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		using LoggingEventPatternConverter::format;


		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			LOG4CXX_NS::helpers::Pool& p) const override;
};
}",1,main\include\log4cxx\pattern\relativetimepatternconverter.hpp,LOG4CXX_NS.pattern,25,pattern,1
65756,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\pattern\shortfilelocationpatternconverter.hpp,main\include\log4cxx\pattern\shortfilelocationpatternconverter.hpp:<global>,,<global>,1
65760,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace pattern
{


/**
 * Return the event's line location information in a StringBuffer.
 *
 *
 *
 */
class LOG4CXX_EXPORT ShortFileLocationPatternConverter
	: public LoggingEventPatternConverter
{
		/**
		 * Private constructor.
		 */
		ShortFileLocationPatternConverter();

	public:
		DECLARE_LOG4CXX_PATTERN(ShortFileLocationPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(ShortFileLocationPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		/**
		 * Obtains an instance of pattern converter.
		 * @param options options, may be null.
		 * @return instance of pattern converter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		using LoggingEventPatternConverter::format;

		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			helpers::Pool& p) const override;
};

}
}",1,main\include\log4cxx\pattern\shortfilelocationpatternconverter.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
65761,NAMESPACE_BLOCK,"namespace pattern
{


/**
 * Return the event's line location information in a StringBuffer.
 *
 *
 *
 */
class LOG4CXX_EXPORT ShortFileLocationPatternConverter
	: public LoggingEventPatternConverter
{
		/**
		 * Private constructor.
		 */
		ShortFileLocationPatternConverter();

	public:
		DECLARE_LOG4CXX_PATTERN(ShortFileLocationPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(ShortFileLocationPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		/**
		 * Obtains an instance of pattern converter.
		 * @param options options, may be null.
		 * @return instance of pattern converter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		using LoggingEventPatternConverter::format;

		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			helpers::Pool& p) const override;
};

}",1,main\include\log4cxx\pattern\shortfilelocationpatternconverter.hpp,LOG4CXX_NS.pattern,25,pattern,1
65766,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\pattern\threadpatternconverter.hpp,main\include\log4cxx\pattern\threadpatternconverter.hpp:<global>,,<global>,1
65770,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace pattern
{


/**
 * Formats the event thread name.
 *
 *
 *
 */
class LOG4CXX_EXPORT ThreadPatternConverter : public LoggingEventPatternConverter
{
	public:
		DECLARE_LOG4CXX_PATTERN(ThreadPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(ThreadPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		ThreadPatternConverter();

		/**
		 * Obtains an instance of ThreadPatternConverter.
		 * @param options options, currently ignored, may be null.
		 * @return instance of ThreadPatternConverter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		using LoggingEventPatternConverter::format;

		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			helpers::Pool& p) const override;
};
}
}",1,main\include\log4cxx\pattern\threadpatternconverter.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
65771,NAMESPACE_BLOCK,"namespace pattern
{


/**
 * Formats the event thread name.
 *
 *
 *
 */
class LOG4CXX_EXPORT ThreadPatternConverter : public LoggingEventPatternConverter
{
	public:
		DECLARE_LOG4CXX_PATTERN(ThreadPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(ThreadPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		ThreadPatternConverter();

		/**
		 * Obtains an instance of ThreadPatternConverter.
		 * @param options options, currently ignored, may be null.
		 * @return instance of ThreadPatternConverter.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		using LoggingEventPatternConverter::format;

		void format(const spi::LoggingEventPtr& event,
			LogString& toAppendTo,
			helpers::Pool& p) const override;
};
}",1,main\include\log4cxx\pattern\threadpatternconverter.hpp,LOG4CXX_NS.pattern,25,pattern,1
65778,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\pattern\threadusernamepatternconverter.hpp,main\include\log4cxx\pattern\threadusernamepatternconverter.hpp:<global>,,<global>,1
65782,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{

namespace pattern
{

class LOG4CXX_EXPORT ThreadUsernamePatternConverter : public LoggingEventPatternConverter
{

    public:
	    DECLARE_LOG4CXX_PATTERN(ThreadUsernamePatternConverter)
	    BEGIN_LOG4CXX_CAST_MAP()
	    LOG4CXX_CAST_ENTRY(ThreadUsernamePatternConverter)
	    LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
	    END_LOG4CXX_CAST_MAP()

		ThreadUsernamePatternConverter();

	    static PatternConverterPtr newInstance(
	            const std::vector<LogString>& options);

	    void format(const spi::LoggingEventPtr& event,
	            LogString& toAppendTo,
	            LOG4CXX_NS::helpers::Pool& p) const override;
};

}
}",1,main\include\log4cxx\pattern\threadusernamepatternconverter.hpp,LOG4CXX_NS,24,LOG4CXX_NS,1
65783,NAMESPACE_BLOCK,"namespace pattern
{

class LOG4CXX_EXPORT ThreadUsernamePatternConverter : public LoggingEventPatternConverter
{

    public:
	    DECLARE_LOG4CXX_PATTERN(ThreadUsernamePatternConverter)
	    BEGIN_LOG4CXX_CAST_MAP()
	    LOG4CXX_CAST_ENTRY(ThreadUsernamePatternConverter)
	    LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
	    END_LOG4CXX_CAST_MAP()

		ThreadUsernamePatternConverter();

	    static PatternConverterPtr newInstance(
	            const std::vector<LogString>& options);

	    void format(const spi::LoggingEventPtr& event,
	            LogString& toAppendTo,
	            LOG4CXX_NS::helpers::Pool& p) const override;
};

}",1,main\include\log4cxx\pattern\threadusernamepatternconverter.hpp,LOG4CXX_NS.pattern,27,pattern,1
65788,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\pattern\throwableinformationpatternconverter.hpp,main\include\log4cxx\pattern\throwableinformationpatternconverter.hpp:<global>,,<global>,1
65792,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace pattern
{


/**
 * Outputs the ThrowableInformation portion of the LoggingiEvent as a full stacktrace
 * unless this converter's option is 'short', where it just outputs the first line of the trace.
 *
 *
 *
 *
 */
class LOG4CXX_EXPORT ThrowableInformationPatternConverter
	: public LoggingEventPatternConverter
{
		struct ThrowableInformationPatternConverterPrivate;

	public:
		DECLARE_LOG4CXX_PATTERN(ThrowableInformationPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(ThrowableInformationPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		ThrowableInformationPatternConverter(bool shortReport);

		/**
		 * Gets an instance of the class.
		  * @param options pattern options, may be null.  If first element is ""short"",
		 * only the first line of the throwable will be formatted.
		 * @return instance of class.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString...",1,main\include\log4cxx\pattern\throwableinformationpatternconverter.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
65793,NAMESPACE_BLOCK,"namespace pattern
{


/**
 * Outputs the ThrowableInformation portion of the LoggingiEvent as a full stacktrace
 * unless this converter's option is 'short', where it just outputs the first line of the trace.
 *
 *
 *
 *
 */
class LOG4CXX_EXPORT ThrowableInformationPatternConverter
	: public LoggingEventPatternConverter
{
		struct ThrowableInformationPatternConverterPrivate;

	public:
		DECLARE_LOG4CXX_PATTERN(ThrowableInformationPatternConverter)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(ThrowableInformationPatternConverter)
		LOG4CXX_CAST_ENTRY_CHAIN(LoggingEventPatternConverter)
		END_LOG4CXX_CAST_MAP()

		ThrowableInformationPatternConverter(bool shortReport);

		/**
		 * Gets an instance of the class.
		  * @param options pattern options, may be null.  If first element is ""short"",
		 * only the first line of the throwable will be formatted.
		 * @return instance of class.
		 */
		static PatternConverterPtr newInstance(
			const std::vector<LogString>& options);

		using L...",1,main\include\log4cxx\pattern\throwableinformationpatternconverter.hpp,LOG4CXX_NS.pattern,25,pattern,1
65804,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\patternlayout.hpp,main\include\log4cxx\patternlayout.hpp:<global>,,<global>,1
65808,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
LOG4CXX_LIST_DEF(LoggingEventPatternConverterList, LOG4CXX_NS::pattern::LoggingEventPatternConverterPtr);
LOG4CXX_LIST_DEF(FormattingInfoList, LOG4CXX_NS::pattern::FormattingInfoPtr);

/**
 * A flexible layout configurable with pattern string.
 *
 * <p>
 *  The goal of this class is to format a {@link spi::LoggingEvent LoggingEvent} and
 *  return the results as a string. The results depend on the <em>conversion pattern</em>.
 * </p>
 *
 * <p>
 *  The conversion pattern is closely related to the conversion pattern of the printf
 *  function in C. A conversion pattern is composed of literal text and format control
 *  expressions called <em>conversion specifiers</em>.
 * </p>
 *
 * <p>
 *  <i>You are free to insert any literal text within the conversion pattern.</i>
 * </p>
 *
 * <p>
 *  Each conversion specifier starts with a percent sign (%) and is followed by optional
 *  <em>format modifiers</em> and a <em>conversion character</em>. The conversion character...",1,main\include\log4cxx\patternlayout.hpp,LOG4CXX_NS,26,LOG4CXX_NS,1
65816,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\private\action_priv.hpp,main\include\log4cxx\private\action_priv.hpp:<global>,,<global>,1
65820,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace rolling
{

struct Action::ActionPrivate
{
	ActionPrivate() :
		complete(false),
		interrupted(false),
		pool() {}

	virtual ~ActionPrivate(){}

	/**
	 * Is action complete.
	 */
	bool complete;

	/**
	 * Is action interrupted.
	 */
	bool interrupted;

	LOG4CXX_NS::helpers::Pool pool;
	std::mutex mutex;
};

}
}",1,main\include\log4cxx\private\action_priv.hpp,LOG4CXX_NS,22,LOG4CXX_NS,1
65821,NAMESPACE_BLOCK,"namespace rolling
{

struct Action::ActionPrivate
{
	ActionPrivate() :
		complete(false),
		interrupted(false),
		pool() {}

	virtual ~ActionPrivate(){}

	/**
	 * Is action complete.
	 */
	bool complete;

	/**
	 * Is action interrupted.
	 */
	bool interrupted;

	LOG4CXX_NS::helpers::Pool pool;
	std::mutex mutex;
};

}",1,main\include\log4cxx\private\action_priv.hpp,LOG4CXX_NS.rolling,24,rolling,1
65842,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\private\appenderskeleton_priv.hpp,main\include\log4cxx\private\appenderskeleton_priv.hpp:<global>,,<global>,1
65846,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{

struct AppenderSkeleton::AppenderSkeletonPrivate
{
	AppenderSkeletonPrivate() :
		threshold(Level::getAll()),
		errorHandler(std::make_shared<LOG4CXX_NS::helpers::OnlyOnceErrorHandler>()),
		closed(false) {}

	AppenderSkeletonPrivate( LayoutPtr lay ) :
		layout( lay ),
		threshold(Level::getAll()),
		errorHandler(std::make_shared<LOG4CXX_NS::helpers::OnlyOnceErrorHandler>()),
		closed(false) {}

	virtual ~AppenderSkeletonPrivate(){}

	/** The layout variable does not need to be set if the appender
	implementation has its own layout. */
	LayoutPtr layout;

	/** Appenders are named. */
	LogString name;

	/**
	There is no level threshold filtering by default.  */
	LevelPtr threshold;

	/**
	It is assumed and enforced that errorHandler is never null.
	*/
	spi::ErrorHandlerPtr errorHandler;

	/** The first filter in the filter chain. Set to <code>null</code>
	initially. */
	spi::FilterPtr headFilter;

	/** The last filter in the filter chain. */
	spi::FilterPtr ta...",1,main\include\log4cxx\private\appenderskeleton_priv.hpp,LOG4CXX_NS,25,LOG4CXX_NS,1
65873,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\private\aprdatagramsocket.hpp,main\include\log4cxx\private\aprdatagramsocket.hpp:<global>,,<global>,1
65877,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{

class APRDatagramSocket : public DatagramSocket {
    private:
        struct APRDatagramSocketPriv;

    public:
	APRDatagramSocket();

	APRDatagramSocket(int port);

	APRDatagramSocket(int port, InetAddressPtr laddr);

	void bind(int lport, InetAddressPtr laddress) override;

	void close() override;

	bool isClosed() const override;

	/**  Receives a datagram packet from this socket. */
	virtual void receive(DatagramPacketPtr& p) override;

	/** Sends a datagram packet from this socket. */
	virtual void  send(DatagramPacketPtr& p) override;

	virtual void connect(InetAddressPtr address, int port) override;

    private:
	void init();
};

}
}",1,main\include\log4cxx\private\aprdatagramsocket.hpp,LOG4CXX_NS,22,LOG4CXX_NS,1
65878,NAMESPACE_BLOCK,"namespace helpers
{

class APRDatagramSocket : public DatagramSocket {
    private:
        struct APRDatagramSocketPriv;

    public:
	APRDatagramSocket();

	APRDatagramSocket(int port);

	APRDatagramSocket(int port, InetAddressPtr laddr);

	void bind(int lport, InetAddressPtr laddress) override;

	void close() override;

	bool isClosed() const override;

	/**  Receives a datagram packet from this socket. */
	virtual void receive(DatagramPacketPtr& p) override;

	/** Sends a datagram packet from this socket. */
	virtual void  send(DatagramPacketPtr& p) override;

	virtual void connect(InetAddressPtr address, int port) override;

    private:
	void init();
};

}",1,main\include\log4cxx\private\aprdatagramsocket.hpp,LOG4CXX_NS.helpers,24,helpers,1
65933,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\private\aprserversocket.hpp,main\include\log4cxx\private\aprserversocket.hpp:<global>,,<global>,1
65937,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{

/**
 * A ServerSocket that uses APR as the network implementation
 */
class LOG4CXX_EXPORT APRServerSocket : public helpers::ServerSocket
{
        public:
            APRServerSocket(int port);

	    void close() override;

	    SocketPtr accept() override;

	private:
		struct APRServerSocketPriv;
};

}
}",1,main\include\log4cxx\private\aprserversocket.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
65938,NAMESPACE_BLOCK,"namespace helpers
{

/**
 * A ServerSocket that uses APR as the network implementation
 */
class LOG4CXX_EXPORT APRServerSocket : public helpers::ServerSocket
{
        public:
            APRServerSocket(int port);

	    void close() override;

	    SocketPtr accept() override;

	private:
		struct APRServerSocketPriv;
};

}",1,main\include\log4cxx\private\aprserversocket.hpp,LOG4CXX_NS.helpers,25,helpers,1
65943,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\private\aprsocket.hpp,main\include\log4cxx\private\aprsocket.hpp:<global>,,<global>,1
65948,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{

class LOG4CXX_EXPORT APRSocket : public helpers::Socket
{
	public:
		/** Creates a stream socket and connects it to the specified port
		number at the specified IP address.
		*/
		APRSocket(InetAddressPtr& address, int port);
		APRSocket(apr_socket_t*, apr_pool_t* pool);

		virtual size_t write(ByteBuffer&);

		/** Closes this socket. */
		virtual void close();

	private:
		struct APRSocketPriv;
};

}
}",1,main\include\log4cxx\private\aprsocket.hpp,LOG4CXX_NS,25,LOG4CXX_NS,2
65949,NAMESPACE_BLOCK,"namespace helpers
{

class LOG4CXX_EXPORT APRSocket : public helpers::Socket
{
	public:
		/** Creates a stream socket and connects it to the specified port
		number at the specified IP address.
		*/
		APRSocket(InetAddressPtr& address, int port);
		APRSocket(apr_socket_t*, apr_pool_t* pool);

		virtual size_t write(ByteBuffer&);

		/** Closes this socket. */
		virtual void close();

	private:
		struct APRSocketPriv;
};

}",1,main\include\log4cxx\private\aprsocket.hpp,LOG4CXX_NS.helpers,27,helpers,1
65956,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\private\atexitregistry.hpp,main\include\log4cxx\private\atexitregistry.hpp:<global>,,<global>,1
65960,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{
	
/* 
 * Provides the initiation of the minimum necessary actions (buffers flushing for example) at the static deinitialization phase.
 */
class LOG4CXX_EXPORT AtExitRegistry
{
public:
	struct Raii
	{
		Raii(std::function<void()> action)
		{
			AtExitRegistry::instance().add(this, std::move(action));
		}
		
		~Raii()
		{
			AtExitRegistry::instance().del(this);
		}
		
		Raii(const Raii&) = delete;
		void operator=(const Raii&) = delete;
	};
	
private:
	friend Raii;
	static AtExitRegistry& instance();
	void add(void* key, std::function<void()> action);
	void del(void* key);
};
}
}",1,main\include\log4cxx\private\atexitregistry.hpp,LOG4CXX_NS,28,LOG4CXX_NS,1
65961,NAMESPACE_BLOCK,"namespace helpers
{
	
/* 
 * Provides the initiation of the minimum necessary actions (buffers flushing for example) at the static deinitialization phase.
 */
class LOG4CXX_EXPORT AtExitRegistry
{
public:
	struct Raii
	{
		Raii(std::function<void()> action)
		{
			AtExitRegistry::instance().add(this, std::move(action));
		}
		
		~Raii()
		{
			AtExitRegistry::instance().del(this);
		}
		
		Raii(const Raii&) = delete;
		void operator=(const Raii&) = delete;
	};
	
private:
	friend Raii;
	static AtExitRegistry& instance();
	void add(void* key, std::function<void()> action);
	void del(void* key);
};
}",1,main\include\log4cxx\private\atexitregistry.hpp,LOG4CXX_NS.helpers,30,helpers,1
65966,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\private\datagramsocket_priv.hpp,main\include\log4cxx\private\datagramsocket_priv.hpp:<global>,,<global>,1
65970,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{

struct DatagramSocket::DatagramSocketPriv
{
	DatagramSocketPriv()
		: port(0), localPort(0)
	{
	}

	DatagramSocketPriv(int localPort1)
		: port(0), localPort(localPort1)
	{
	}

	DatagramSocketPriv(int localPort1, InetAddressPtr localAddress1)
		: localAddress(localAddress1), port(0), localPort(localPort1)
	{
	}

	~DatagramSocketPriv() = default;

	InetAddressPtr address;

	InetAddressPtr localAddress;

	int port;

	/** The local port number to which this socket is connected. */
	int localPort;
};

}
}",1,main\include\log4cxx\private\datagramsocket_priv.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
65971,NAMESPACE_BLOCK,"namespace helpers
{

struct DatagramSocket::DatagramSocketPriv
{
	DatagramSocketPriv()
		: port(0), localPort(0)
	{
	}

	DatagramSocketPriv(int localPort1)
		: port(0), localPort(localPort1)
	{
	}

	DatagramSocketPriv(int localPort1, InetAddressPtr localAddress1)
		: localAddress(localAddress1), port(0), localPort(localPort1)
	{
	}

	~DatagramSocketPriv() = default;

	InetAddressPtr address;

	InetAddressPtr localAddress;

	int port;

	/** The local port number to which this socket is connected. */
	int localPort;
};

}",1,main\include\log4cxx\private\datagramsocket_priv.hpp,LOG4CXX_NS.helpers,25,helpers,1
66001,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\private\fileappender_priv.hpp,main\include\log4cxx\private\fileappender_priv.hpp:<global>,,<global>,1
66005,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{

struct FileAppender::FileAppenderPriv : public WriterAppender::WriterAppenderPriv
{
	FileAppenderPriv
		( LayoutPtr _layout = LayoutPtr()
		, const LogString& _fileName = LogString()
		, bool _fileAppend = true
		, bool _bufferedIO = false
		, int _bufferSize = 8 * 1024
		)
		: WriterAppenderPriv(_layout)
		, fileAppend(_fileAppend)
		, fileName(_fileName)
		, bufferedIO(_bufferedIO)
		, bufferSize(_bufferSize)
		{}

	/** Append to or truncate the file? The default value for this
	variable is <code>true</code>, meaning that by default a
	<code>FileAppender</code> will append to an existing file and
	not truncate it.
	<p>This option is meaningful only if the FileAppender opens the
	file.
	*/
	bool fileAppend;

	/**
	The name of the log file. */
	LogString fileName;

	/**
	Do we do bufferedIO? */
	bool bufferedIO;

	/**
	How big should the IO buffer be? Default is 8K. */
	int bufferSize;
};

}",1,main\include\log4cxx\private\fileappender_priv.hpp,LOG4CXX_NS,24,LOG4CXX_NS,1
66023,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\private\filter_priv.hpp,main\include\log4cxx\private\filter_priv.hpp:<global>,,<global>,1
66027,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace spi
{

struct Filter::FilterPrivate
{
	virtual ~FilterPrivate(){}

	/**
	Points to the next filter in the filter chain.
	*/
	FilterPtr next;
};

}
}",1,main\include\log4cxx\private\filter_priv.hpp,LOG4CXX_NS,22,LOG4CXX_NS,1
66028,NAMESPACE_BLOCK,"namespace spi
{

struct Filter::FilterPrivate
{
	virtual ~FilterPrivate(){}

	/**
	Points to the next filter in the filter chain.
	*/
	FilterPtr next;
};

}",1,main\include\log4cxx\private\filter_priv.hpp,LOG4CXX_NS.spi,24,spi,1
66036,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\private\nteventlogappender_priv.hpp,main\include\log4cxx\private\nteventlogappender_priv.hpp:<global>,,<global>,1
66055,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\private\odbcappender_priv.hpp,main\include\log4cxx\private\odbcappender_priv.hpp:<global>,,<global>,1
66065,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace db
{

struct ODBCAppender::ODBCAppenderPriv : public AppenderSkeleton::AppenderSkeletonPrivate
{
	ODBCAppenderPriv(
#if LOG4CXX_EVENTS_AT_EXIT
		std::function<void()> atExitActivated
#endif
			)
		: AppenderSkeletonPrivate()
		, connection(0)
		, env(0)
		, preparedStatement(0)
		, bufferSize(1)
		, timeZone(helpers::TimeZone::getDefault())
#if LOG4CXX_EVENTS_AT_EXIT
		, atExitRegistryRaii(std::move(atExitActivated))
#endif
		{}

	/**
	* URL of the DB for default connection handling
	*/
	LogString databaseURL;

	/**
	* User to connect as for default connection handling
	*/
	LogString databaseUser;

	/**
	* User to use for default connection handling
	*/
	LogString databasePassword;

	/**
	* Connection used by default.  The connection is opened the first time it
	* is needed and then held open until the appender is closed (usually at
	* garbage collection).  This behavior is best modified by creating a
	* sub-class and overriding the <code>getConnecti...",1,main\include\log4cxx\private\odbcappender_priv.hpp,LOG4CXX_NS,47,LOG4CXX_NS,7
66066,NAMESPACE_BLOCK,"namespace db
{

struct ODBCAppender::ODBCAppenderPriv : public AppenderSkeleton::AppenderSkeletonPrivate
{
	ODBCAppenderPriv(
#if LOG4CXX_EVENTS_AT_EXIT
		std::function<void()> atExitActivated
#endif
			)
		: AppenderSkeletonPrivate()
		, connection(0)
		, env(0)
		, preparedStatement(0)
		, bufferSize(1)
		, timeZone(helpers::TimeZone::getDefault())
#if LOG4CXX_EVENTS_AT_EXIT
		, atExitRegistryRaii(std::move(atExitActivated))
#endif
		{}

	/**
	* URL of the DB for default connection handling
	*/
	LogString databaseURL;

	/**
	* User to connect as for default connection handling
	*/
	LogString databaseUser;

	/**
	* User to use for default connection handling
	*/
	LogString databasePassword;

	/**
	* Connection used by default.  The connection is opened the first time it
	* is needed and then held open until the appender is closed (usually at
	* garbage collection).  This behavior is best modified by creating a
	* sub-class and overriding the <code>getConnection</code> and
	* <code>...",1,main\include\log4cxx\private\odbcappender_priv.hpp,LOG4CXX_NS.db,49,db,1
66108,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\private\patternconverter_priv.hpp,main\include\log4cxx\private\patternconverter_priv.hpp:<global>,,<global>,1
66112,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace pattern
{

/**
 * Create a new pattern converter.
 * @param name name for pattern converter.
 * @param style CSS style for formatted output.
 */
struct PatternConverter::PatternConverterPrivate
{
	PatternConverterPrivate( const LogString& _name, const LogString& _style ) :
		name(_name),
		style(_style) {}

	virtual ~PatternConverterPrivate(){}

	/**
	 * Converter name.
	 */
	const LogString name;
	/**
	 * Converter style name.
	 */
	const LogString style;
};

}
}",1,main\include\log4cxx\private\patternconverter_priv.hpp,LOG4CXX_NS,21,LOG4CXX_NS,1
66113,NAMESPACE_BLOCK,"namespace pattern
{

/**
 * Create a new pattern converter.
 * @param name name for pattern converter.
 * @param style CSS style for formatted output.
 */
struct PatternConverter::PatternConverterPrivate
{
	PatternConverterPrivate( const LogString& _name, const LogString& _style ) :
		name(_name),
		style(_style) {}

	virtual ~PatternConverterPrivate(){}

	/**
	 * Converter name.
	 */
	const LogString name;
	/**
	 * Converter style name.
	 */
	const LogString style;
};

}",1,main\include\log4cxx\private\patternconverter_priv.hpp,LOG4CXX_NS.pattern,23,pattern,1
66136,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\private\rollingpolicybase_priv.hpp,main\include\log4cxx\private\rollingpolicybase_priv.hpp:<global>,,<global>,1
66140,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace rolling{

struct RollingPolicyBase::RollingPolicyBasePrivate {
    virtual ~RollingPolicyBasePrivate() = default;

    /**
     * File name pattern converters.
     */
    PatternConverterList patternConverters;

    /**
     * File name field specifiers.
     */
    FormattingInfoList patternFields;

    /**
     * File name pattern.
     */
    LogString fileNamePatternStr;

	bool createIntermediateDirectories = true;
};

}

}",1,main\include\log4cxx\private\rollingpolicybase_priv.hpp,LOG4CXX_NS,26,LOG4CXX_NS,1
66141,NAMESPACE_BLOCK,"namespace rolling{

struct RollingPolicyBase::RollingPolicyBasePrivate {
    virtual ~RollingPolicyBasePrivate() = default;

    /**
     * File name pattern converters.
     */
    PatternConverterList patternConverters;

    /**
     * File name field specifiers.
     */
    FormattingInfoList patternFields;

    /**
     * File name pattern.
     */
    LogString fileNamePatternStr;

	bool createIntermediateDirectories = true;
};

}",1,main\include\log4cxx\private\rollingpolicybase_priv.hpp,LOG4CXX_NS.rolling,28,rolling,1
66161,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\private\serversocket_priv.hpp,main\include\log4cxx\private\serversocket_priv.hpp:<global>,,<global>,1
66165,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{

struct ServerSocket::ServerSocketPrivate{
	ServerSocketPrivate() :
		timeout(0){}
	virtual ~ServerSocketPrivate() = default;
	int timeout;
};

}
}",1,main\include\log4cxx\private\serversocket_priv.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
66166,NAMESPACE_BLOCK,"namespace helpers
{

struct ServerSocket::ServerSocketPrivate{
	ServerSocketPrivate() :
		timeout(0){}
	virtual ~ServerSocketPrivate() = default;
	int timeout;
};

}",1,main\include\log4cxx\private\serversocket_priv.hpp,LOG4CXX_NS.helpers,25,helpers,1
66180,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\private\socket_priv.hpp,main\include\log4cxx\private\socket_priv.hpp:<global>,,<global>,1
66184,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{

struct Socket::SocketPrivate
{
	SocketPrivate(const InetAddressPtr& addr = InetAddressPtr(), int _port = 0)
		: address(addr), port(_port) {}
	virtual ~SocketPrivate() = default;
	/** The IP address of the remote end of this socket. */
	InetAddressPtr address;

	/** The port number on the remote host to which
	this socket is connected. */
	int port;
};

}
}",1,main\include\log4cxx\private\socket_priv.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
66185,NAMESPACE_BLOCK,"namespace helpers
{

struct Socket::SocketPrivate
{
	SocketPrivate(const InetAddressPtr& addr = InetAddressPtr(), int _port = 0)
		: address(addr), port(_port) {}
	virtual ~SocketPrivate() = default;
	/** The IP address of the remote end of this socket. */
	InetAddressPtr address;

	/** The port number on the remote host to which
	this socket is connected. */
	int port;
};

}",1,main\include\log4cxx\private\socket_priv.hpp,LOG4CXX_NS.helpers,25,helpers,1
66206,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\private\socketappenderskeleton_priv.hpp,main\include\log4cxx\private\socketappenderskeleton_priv.hpp:<global>,,<global>,1
66210,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace net
{

struct SocketAppenderSkeleton::SocketAppenderSkeletonPriv : public AppenderSkeletonPrivate
{
	SocketAppenderSkeletonPriv(int defaultPort, int reconnectionDelay) :
		AppenderSkeletonPrivate(),
		remoteHost(),
		address(),
		port(defaultPort),
		reconnectionDelay(reconnectionDelay),
		locationInfo(false),
		thread() {}

	SocketAppenderSkeletonPriv(helpers::InetAddressPtr address, int defaultPort, int reconnectionDelay) :
		AppenderSkeletonPrivate(),
		remoteHost(),
		address(address),
		port(defaultPort),
		reconnectionDelay(reconnectionDelay),
		locationInfo(false),
		thread() {}

	SocketAppenderSkeletonPriv(const LogString& host, int port, int delay) :
		AppenderSkeletonPrivate(),
		remoteHost(host),
		address(helpers::InetAddress::getByName(host)),
		port(port),
		reconnectionDelay(delay),
		locationInfo(false),
		thread() {}

	/**
	host name
	*/
	LogString remoteHost;

	/**
	IP address
	*/
	helpers::InetAddressPtr address;

	int port;
	int r...",1,main\include\log4cxx\private\socketappenderskeleton_priv.hpp,LOG4CXX_NS,24,LOG4CXX_NS,1
66211,NAMESPACE_BLOCK,"namespace net
{

struct SocketAppenderSkeleton::SocketAppenderSkeletonPriv : public AppenderSkeletonPrivate
{
	SocketAppenderSkeletonPriv(int defaultPort, int reconnectionDelay) :
		AppenderSkeletonPrivate(),
		remoteHost(),
		address(),
		port(defaultPort),
		reconnectionDelay(reconnectionDelay),
		locationInfo(false),
		thread() {}

	SocketAppenderSkeletonPriv(helpers::InetAddressPtr address, int defaultPort, int reconnectionDelay) :
		AppenderSkeletonPrivate(),
		remoteHost(),
		address(address),
		port(defaultPort),
		reconnectionDelay(reconnectionDelay),
		locationInfo(false),
		thread() {}

	SocketAppenderSkeletonPriv(const LogString& host, int port, int delay) :
		AppenderSkeletonPrivate(),
		remoteHost(host),
		address(helpers::InetAddress::getByName(host)),
		port(port),
		reconnectionDelay(delay),
		locationInfo(false),
		thread() {}

	/**
	host name
	*/
	LogString remoteHost;

	/**
	IP address
	*/
	helpers::InetAddressPtr address;

	int port;
	int reconnectionDelay;
	bool...",1,main\include\log4cxx\private\socketappenderskeleton_priv.hpp,LOG4CXX_NS.net,26,net,1
66246,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\private\string_c11.hpp,main\include\log4cxx\private\string_c11.hpp:<global>,,<global>,1
66378,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\private\syslogappender_priv.hpp,main\include\log4cxx\private\syslogappender_priv.hpp:<global>,,<global>,1
66382,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace net
{

struct SyslogAppender::SyslogAppenderPriv : public AppenderSkeleton::AppenderSkeletonPrivate
{
	SyslogAppenderPriv() :
		AppenderSkeletonPrivate(),
		syslogFacility(LOG_USER),
		facilityPrinting(false),
		maxMessageLength(1024)
	{

	}

	SyslogAppenderPriv(const LayoutPtr& layout, int syslogFacility) :
		AppenderSkeletonPrivate (layout),
		syslogFacility(syslogFacility),
		facilityPrinting(false),
		maxMessageLength(1024)
	{

	}

	SyslogAppenderPriv(const LayoutPtr& layout,
		const LogString& syslogHost, int syslogFacility) :
		AppenderSkeletonPrivate(layout),
		syslogFacility(syslogFacility),
		facilityPrinting(false),
		maxMessageLength(1024)
	{

	}

	int syslogFacility; // Have LOG_USER as default
	LogString facilityStr;
	bool facilityPrinting;
	std::unique_ptr<helpers::SyslogWriter> sw;
	LogString syslogHost;
	int syslogHostPort;
	int maxMessageLength;
};

}
}",1,main\include\log4cxx\private\syslogappender_priv.hpp,LOG4CXX_NS,52,LOG4CXX_NS,1
66383,NAMESPACE_BLOCK,"namespace net
{

struct SyslogAppender::SyslogAppenderPriv : public AppenderSkeleton::AppenderSkeletonPrivate
{
	SyslogAppenderPriv() :
		AppenderSkeletonPrivate(),
		syslogFacility(LOG_USER),
		facilityPrinting(false),
		maxMessageLength(1024)
	{

	}

	SyslogAppenderPriv(const LayoutPtr& layout, int syslogFacility) :
		AppenderSkeletonPrivate (layout),
		syslogFacility(syslogFacility),
		facilityPrinting(false),
		maxMessageLength(1024)
	{

	}

	SyslogAppenderPriv(const LayoutPtr& layout,
		const LogString& syslogHost, int syslogFacility) :
		AppenderSkeletonPrivate(layout),
		syslogFacility(syslogFacility),
		facilityPrinting(false),
		maxMessageLength(1024)
	{

	}

	int syslogFacility; // Have LOG_USER as default
	LogString facilityStr;
	bool facilityPrinting;
	std::unique_ptr<helpers::SyslogWriter> sw;
	LogString syslogHost;
	int syslogHostPort;
	int maxMessageLength;
};

}",1,main\include\log4cxx\private\syslogappender_priv.hpp,LOG4CXX_NS.net,54,net,1
66420,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\private\writerappender_priv.hpp,main\include\log4cxx\private\writerappender_priv.hpp:<global>,,<global>,1
66424,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{

struct WriterAppender::WriterAppenderPriv : public AppenderSkeleton::AppenderSkeletonPrivate
{
	WriterAppenderPriv() :
		AppenderSkeletonPrivate(),
		immediateFlush(true)
#if LOG4CXX_EVENTS_AT_EXIT
		, atExitRegistryRaii([this]{atExitActivated();})
#endif
	{
	}

	WriterAppenderPriv(const LayoutPtr& layout1,
		LOG4CXX_NS::helpers::WriterPtr& writer1) :
		AppenderSkeletonPrivate(layout1),
		immediateFlush(true),
		writer(writer1)
#if LOG4CXX_EVENTS_AT_EXIT
		, atExitRegistryRaii([this]{atExitActivated();})
#endif
	{
	}

	WriterAppenderPriv(const LayoutPtr& layout1) :
		AppenderSkeletonPrivate(layout1),
		immediateFlush(true)
#if LOG4CXX_EVENTS_AT_EXIT
		, atExitRegistryRaii([this]{atExitActivated();})
#endif
	{
	}

#if LOG4CXX_EVENTS_AT_EXIT
	void atExitActivated()
	{
		std::lock_guard<std::recursive_mutex> lock(mutex);
		if (writer)
			writer->flush(pool);
	}
#endif

	/**
	Immediate flush means that the underlying writer or output stream
	will be flushed at th...",1,main\include\log4cxx\private\writerappender_priv.hpp,LOG4CXX_NS,31,LOG4CXX_NS,1
66460,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\propertyconfigurator.hpp,main\include\log4cxx\propertyconfigurator.hpp:<global>,,<global>,1
66464,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
class Logger;
typedef std::shared_ptr<Logger> LoggerPtr;

class Appender;
typedef std::shared_ptr<Appender> AppenderPtr;

namespace helpers
{
class Properties;
}


namespace spi
{
class LoggerFactory;
typedef std::shared_ptr<LoggerFactory> LoggerFactoryPtr;
}

class PropertyWatchdog;
/**
Allows the configuration of log4cxx from an external file.
See {@link PropertyConfigurator#doConfigure doConfigure} for the expected format.

<p>It is sometimes useful to see how log4cxx is reading configuration
files. You can enable log4cxx internal logging by defining the
<b>log4j.debug</b> variable.

<P>At class initialization time class,
the file <b>log4j.properties</b> will be searched in the current directory.
If the file can be found, then it will
be fed to the
{@link PropertyConfigurator#configure(const File& configFilename) configure}
method.

<p>The <code>PropertyConfigurator</code> does not handle the
advanced configuration features supported by the
{@link xml::DOMC...",1,main\include\log4cxx\propertyconfigurator.hpp,LOG4CXX_NS,28,LOG4CXX_NS,1
66469,NAMESPACE_BLOCK,"namespace helpers
{
class Properties;
}",1,main\include\log4cxx\propertyconfigurator.hpp,LOG4CXX_NS.helpers,36,helpers,5
66471,NAMESPACE_BLOCK,"namespace spi
{
class LoggerFactory;
typedef std::shared_ptr<LoggerFactory> LoggerFactoryPtr;
}",1,main\include\log4cxx\propertyconfigurator.hpp,LOG4CXX_NS.spi,42,spi,6
66483,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\provisionnode.hpp,main\include\log4cxx\provisionnode.hpp:<global>,,<global>,1
66487,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
class Logger;
typedef std::shared_ptr<Logger> LoggerPtr;


typedef std::vector<LoggerPtr> ProvisionNode;

}",1,main\include\log4cxx\provisionnode.hpp,LOG4CXX_NS,25,LOG4CXX_NS,1
66500,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\rolling\action.hpp,main\include\log4cxx\rolling\action.hpp:<global>,,<global>,1
66504,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace rolling
{


/**
 *  A file system action performed as part of a rollover event.
 */
class Action : public virtual LOG4CXX_NS::helpers::Object
{
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(Action)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(Action)
		END_LOG4CXX_CAST_MAP()

		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(ActionPrivate, m_priv)

	protected:
		/**
		 * Constructor.
		 */
		Action();
		Action(LOG4CXX_PRIVATE_PTR(ActionPrivate) priv);
		virtual ~Action();

	public:
		/**
		 * Perform action.
		 *
		 * @return true if successful.
		 */
		virtual bool execute(LOG4CXX_NS::helpers::Pool& pool) const = 0;

		void run(LOG4CXX_NS::helpers::Pool& pool);

		void close();

		/**
		 * Tests if the action is complete.
		 * @return true if action is complete.
		 */
		bool isComplete() const;

		void reportException(const std::exception&);


};

LOG4CXX_PTR_DEF(Action);

}
}",1,main\include\log4cxx\rolling\action.hpp,LOG4CXX_NS,26,LOG4CXX_NS,1
66505,NAMESPACE_BLOCK,"namespace rolling
{


/**
 *  A file system action performed as part of a rollover event.
 */
class Action : public virtual LOG4CXX_NS::helpers::Object
{
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(Action)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(Action)
		END_LOG4CXX_CAST_MAP()

		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(ActionPrivate, m_priv)

	protected:
		/**
		 * Constructor.
		 */
		Action();
		Action(LOG4CXX_PRIVATE_PTR(ActionPrivate) priv);
		virtual ~Action();

	public:
		/**
		 * Perform action.
		 *
		 * @return true if successful.
		 */
		virtual bool execute(LOG4CXX_NS::helpers::Pool& pool) const = 0;

		void run(LOG4CXX_NS::helpers::Pool& pool);

		void close();

		/**
		 * Tests if the action is complete.
		 * @return true if action is complete.
		 */
		bool isComplete() const;

		void reportException(const std::exception&);


};

LOG4CXX_PTR_DEF(Action);

}",1,main\include\log4cxx\rolling\action.hpp,LOG4CXX_NS.rolling,28,rolling,1
66544,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\rolling\filerenameaction.hpp,main\include\log4cxx\rolling\filerenameaction.hpp:<global>,,<global>,1
66548,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace rolling
{


class FileRenameAction : public Action
{
		struct FileRenameActionPrivate;
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(FileRenameAction)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(FileRenameAction)
		LOG4CXX_CAST_ENTRY_CHAIN(Action)
		END_LOG4CXX_CAST_MAP()

		/**
		 * Constructor.
		 */
		FileRenameAction(const File& toRename,
			const File& renameTo,
			bool renameEmptyFile);

		/**
		 * Perform action.
		 *
		 * @return true if successful.
		 */
		bool execute(LOG4CXX_NS::helpers::Pool& pool) const override;
};

LOG4CXX_PTR_DEF(FileRenameAction);

}
}",1,main\include\log4cxx\rolling\filerenameaction.hpp,LOG4CXX_NS,24,LOG4CXX_NS,1
66549,NAMESPACE_BLOCK,"namespace rolling
{


class FileRenameAction : public Action
{
		struct FileRenameActionPrivate;
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(FileRenameAction)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(FileRenameAction)
		LOG4CXX_CAST_ENTRY_CHAIN(Action)
		END_LOG4CXX_CAST_MAP()

		/**
		 * Constructor.
		 */
		FileRenameAction(const File& toRename,
			const File& renameTo,
			bool renameEmptyFile);

		/**
		 * Perform action.
		 *
		 * @return true if successful.
		 */
		bool execute(LOG4CXX_NS::helpers::Pool& pool) const override;
};

LOG4CXX_PTR_DEF(FileRenameAction);

}",1,main\include\log4cxx\rolling\filerenameaction.hpp,LOG4CXX_NS.rolling,26,rolling,1
66566,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\rolling\filterbasedtriggeringpolicy.hpp,main\include\log4cxx\rolling\filterbasedtriggeringpolicy.hpp:<global>,,<global>,1
66571,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{

class File;

namespace helpers
{
class Pool;
}


namespace rolling
{

/**
 * FilterBasedTriggeringPolicy determines if rolling should be triggered
 * by evaluating the current message against a set of filters.  Unless a
 * filter rejects a message, a rolling event will be triggered.
 *
 *
 *
 *
 */
class LOG4CXX_EXPORT FilterBasedTriggeringPolicy : public TriggeringPolicy
{

		DECLARE_LOG4CXX_OBJECT(FilterBasedTriggeringPolicy)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(FilterBasedTriggeringPolicy)
		LOG4CXX_CAST_ENTRY_CHAIN(TriggeringPolicy)
		END_LOG4CXX_CAST_MAP()

		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(FilterBasedTriggeringPolicyPrivate, m_priv)

	public:
		/**
		 *  Creates a new FilterBasedTriggeringPolicy.
		 */
		FilterBasedTriggeringPolicy();
		virtual ~FilterBasedTriggeringPolicy();

		/**
		 * Determines if a rollover may be appropriate at this time.  If
		 * true is returned, RolloverPolicy.rollover will be called but it
		 * can determine that...",1,main\include\log4cxx\rolling\filterbasedtriggeringpolicy.hpp,LOG4CXX_NS,27,LOG4CXX_NS,2
66573,NAMESPACE_BLOCK,"namespace helpers
{
class Pool;
}",1,main\include\log4cxx\rolling\filterbasedtriggeringpolicy.hpp,LOG4CXX_NS.helpers,32,helpers,2
66575,NAMESPACE_BLOCK,"namespace rolling
{

/**
 * FilterBasedTriggeringPolicy determines if rolling should be triggered
 * by evaluating the current message against a set of filters.  Unless a
 * filter rejects a message, a rolling event will be triggered.
 *
 *
 *
 *
 */
class LOG4CXX_EXPORT FilterBasedTriggeringPolicy : public TriggeringPolicy
{

		DECLARE_LOG4CXX_OBJECT(FilterBasedTriggeringPolicy)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(FilterBasedTriggeringPolicy)
		LOG4CXX_CAST_ENTRY_CHAIN(TriggeringPolicy)
		END_LOG4CXX_CAST_MAP()

		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(FilterBasedTriggeringPolicyPrivate, m_priv)

	public:
		/**
		 *  Creates a new FilterBasedTriggeringPolicy.
		 */
		FilterBasedTriggeringPolicy();
		virtual ~FilterBasedTriggeringPolicy();

		/**
		 * Determines if a rollover may be appropriate at this time.  If
		 * true is returned, RolloverPolicy.rollover will be called but it
		 * can determine that a rollover is not warranted.
		 *
		 * @param appender A reference to th...",1,main\include\log4cxx\rolling\filterbasedtriggeringpolicy.hpp,LOG4CXX_NS.rolling,38,rolling,3
66581,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\rolling\fixedwindowrollingpolicy.hpp,main\include\log4cxx\rolling\fixedwindowrollingpolicy.hpp:<global>,,<global>,1
66585,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{

namespace helpers
{
class Pool;
}

namespace rolling
{


/**
 * When rolling over, <code>FixedWindowRollingPolicy</code> renames files
 * according to a fixed window algorithm as described below.
 *
 * <p>The <b>ActiveFileName</b> property, which is required, represents the name
 * of the file where current logging output will be written.
 * The <b>FileNamePattern</b>  option represents the file name pattern for the
 * archived (rolled over) log files. If present, the <b>FileNamePattern</b>
 * option must include an integer token, that is the string ""%i"" somwhere
 * within the pattern.
 *
 * <p>Let <em>max</em> and <em>min</em> represent the values of respectively
 * the <b>MaxIndex</b> and <b>MinIndex</b> options. Let ""foo.log"" be the value
 * of the <b>ActiveFile</b> option and ""foo.%i.log"" the value of
 * <b>FileNamePattern</b>. Then, when rolling over, the file
 * <code>foo.<em>max</em>.log</code> will be deleted, the file
 * <code>foo.<em>max-1</em>.log<...",1,main\include\log4cxx\rolling\fixedwindowrollingpolicy.hpp,LOG4CXX_NS,26,LOG4CXX_NS,1
66586,NAMESPACE_BLOCK,"namespace helpers
{
class Pool;
}",1,main\include\log4cxx\rolling\fixedwindowrollingpolicy.hpp,LOG4CXX_NS.helpers,29,helpers,1
66588,NAMESPACE_BLOCK,"namespace rolling
{


/**
 * When rolling over, <code>FixedWindowRollingPolicy</code> renames files
 * according to a fixed window algorithm as described below.
 *
 * <p>The <b>ActiveFileName</b> property, which is required, represents the name
 * of the file where current logging output will be written.
 * The <b>FileNamePattern</b>  option represents the file name pattern for the
 * archived (rolled over) log files. If present, the <b>FileNamePattern</b>
 * option must include an integer token, that is the string ""%i"" somwhere
 * within the pattern.
 *
 * <p>Let <em>max</em> and <em>min</em> represent the values of respectively
 * the <b>MaxIndex</b> and <b>MinIndex</b> options. Let ""foo.log"" be the value
 * of the <b>ActiveFile</b> option and ""foo.%i.log"" the value of
 * <b>FileNamePattern</b>. Then, when rolling over, the file
 * <code>foo.<em>max</em>.log</code> will be deleted, the file
 * <code>foo.<em>max-1</em>.log</code> will be renamed as
 * <code>foo.<em>max</em>.log</co...",1,main\include\log4cxx\rolling\fixedwindowrollingpolicy.hpp,LOG4CXX_NS.rolling,34,rolling,2
66596,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\rolling\gzcompressaction.hpp,main\include\log4cxx\rolling\gzcompressaction.hpp:<global>,,<global>,1
66600,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace rolling
{


class GZCompressAction : public Action
{
		struct GZCompressActionPrivate;
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(GZCompressAction)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(GZCompressAction)
		LOG4CXX_CAST_ENTRY_CHAIN(Action)
		END_LOG4CXX_CAST_MAP()

		/**
		 * Constructor.
		 */
		GZCompressAction(const File& source,
			const File& destination,
			bool deleteSource);
		~GZCompressAction();

		/**
		 * Perform action.
		 *
		 * @return true if successful.
		 */
		bool execute(LOG4CXX_NS::helpers::Pool& pool) const override;

		/**
		 * Set to true to throw an IOException on a fork failure.  By default, this
		 * is true.  When an IOException is thrown, this will automatically cause the
		 * error handler to be called(which is the recommended way of handling this
		 * problem).  By setting this to false, the GZCompressAction effectively
		 * turns into a FileRenameAction if any errors are encountered.
		 *
		 * @param throwIO
	...",1,main\include\log4cxx\rolling\gzcompressaction.hpp,LOG4CXX_NS,24,LOG4CXX_NS,1
66601,NAMESPACE_BLOCK,"namespace rolling
{


class GZCompressAction : public Action
{
		struct GZCompressActionPrivate;
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(GZCompressAction)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(GZCompressAction)
		LOG4CXX_CAST_ENTRY_CHAIN(Action)
		END_LOG4CXX_CAST_MAP()

		/**
		 * Constructor.
		 */
		GZCompressAction(const File& source,
			const File& destination,
			bool deleteSource);
		~GZCompressAction();

		/**
		 * Perform action.
		 *
		 * @return true if successful.
		 */
		bool execute(LOG4CXX_NS::helpers::Pool& pool) const override;

		/**
		 * Set to true to throw an IOException on a fork failure.  By default, this
		 * is true.  When an IOException is thrown, this will automatically cause the
		 * error handler to be called(which is the recommended way of handling this
		 * problem).  By setting this to false, the GZCompressAction effectively
		 * turns into a FileRenameAction if any errors are encountered.
		 *
		 * @param throwIO
		 */
		void setThrowIOE...",1,main\include\log4cxx\rolling\gzcompressaction.hpp,LOG4CXX_NS.rolling,26,rolling,1
66635,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\rolling\manualtriggeringpolicy.hpp,main\include\log4cxx\rolling\manualtriggeringpolicy.hpp:<global>,,<global>,1
66639,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{

class File;

namespace helpers
{
class Pool;
}

namespace rolling
{

/**
 * ManualTriggeringPolicy only rolls over on explicit calls to
 * RollingFileAppender.rollover().
 *
 *
 *
 */
class LOG4CXX_EXPORT ManualTriggeringPolicy : public TriggeringPolicy
{
		DECLARE_LOG4CXX_OBJECT(ManualTriggeringPolicy)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(ManualTriggeringPolicy)
		LOG4CXX_CAST_ENTRY_CHAIN(TriggeringPolicy)
		END_LOG4CXX_CAST_MAP()

	public:
		ManualTriggeringPolicy();
		/**
		 * Determines if a rollover may be appropriate at this time.  If
		 * true is returned, RolloverPolicy.rollover will be called but it
		 * can determine that a rollover is not warranted.
		 *
		 * @param appender A reference to the appender.
		 * @param event A reference to the currently event.
		 * @param filename The filename for the currently active log file.
		 * @param fileLength Length of the file in bytes.
		 * @return true if a rollover should occur.
		 */
		bool isTr...",1,main\include\log4cxx\rolling\manualtriggeringpolicy.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
66641,NAMESPACE_BLOCK,"namespace helpers
{
class Pool;
}",1,main\include\log4cxx\rolling\manualtriggeringpolicy.hpp,LOG4CXX_NS.helpers,28,helpers,2
66643,NAMESPACE_BLOCK,"namespace rolling
{

/**
 * ManualTriggeringPolicy only rolls over on explicit calls to
 * RollingFileAppender.rollover().
 *
 *
 *
 */
class LOG4CXX_EXPORT ManualTriggeringPolicy : public TriggeringPolicy
{
		DECLARE_LOG4CXX_OBJECT(ManualTriggeringPolicy)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(ManualTriggeringPolicy)
		LOG4CXX_CAST_ENTRY_CHAIN(TriggeringPolicy)
		END_LOG4CXX_CAST_MAP()

	public:
		ManualTriggeringPolicy();
		/**
		 * Determines if a rollover may be appropriate at this time.  If
		 * true is returned, RolloverPolicy.rollover will be called but it
		 * can determine that a rollover is not warranted.
		 *
		 * @param appender A reference to the appender.
		 * @param event A reference to the currently event.
		 * @param filename The filename for the currently active log file.
		 * @param fileLength Length of the file in bytes.
		 * @return true if a rollover should occur.
		 */
		bool isTriggeringEvent(
			Appender* appender,
			const spi::LoggingEventPtr& eve...",1,main\include\log4cxx\rolling\manualtriggeringpolicy.hpp,LOG4CXX_NS.rolling,33,rolling,3
66658,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\rolling\multiprocessrollingfileappender.hpp,main\include\log4cxx\rolling\multiprocessrollingfileappender.hpp:<global>,,<global>,1
66662,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace rolling
{


/**
 * A special version of the RollingFileAppender that acts properly with multiple processes
 */
class LOG4CXX_EXPORT MultiprocessRollingFileAppender : public FileAppender
{
		DECLARE_LOG4CXX_OBJECT(MultiprocessRollingFileAppender)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(MultiprocessRollingFileAppender)
		LOG4CXX_CAST_ENTRY_CHAIN(FileAppender)
		END_LOG4CXX_CAST_MAP()
	protected:
		struct MultiprocessRollingFileAppenderPriv;

	public:
		MultiprocessRollingFileAppender();

		/**
		\copybrief FileAppender::activateOptions()

		Activate the attached TriggeringPolicy and RollingPolicy.

		\sa FileAppender::activateOptions()
		*/
		void activateOptions(helpers::Pool&) override;


		/**
		   Implements the usual roll over behaviour.

		   <p>If <code>MaxBackupIndex</code> is positive, then files
		   {<code>File.1</code>, ..., <code>File.MaxBackupIndex -1</code>}
		   are renamed to {<code>File.2</code>, ...,
		   <code>File.MaxBackup...",1,main\include\log4cxx\rolling\multiprocessrollingfileappender.hpp,LOG4CXX_NS,28,LOG4CXX_NS,1
66663,NAMESPACE_BLOCK,"namespace rolling
{


/**
 * A special version of the RollingFileAppender that acts properly with multiple processes
 */
class LOG4CXX_EXPORT MultiprocessRollingFileAppender : public FileAppender
{
		DECLARE_LOG4CXX_OBJECT(MultiprocessRollingFileAppender)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(MultiprocessRollingFileAppender)
		LOG4CXX_CAST_ENTRY_CHAIN(FileAppender)
		END_LOG4CXX_CAST_MAP()
	protected:
		struct MultiprocessRollingFileAppenderPriv;

	public:
		MultiprocessRollingFileAppender();

		/**
		\copybrief FileAppender::activateOptions()

		Activate the attached TriggeringPolicy and RollingPolicy.

		\sa FileAppender::activateOptions()
		*/
		void activateOptions(helpers::Pool&) override;


		/**
		   Implements the usual roll over behaviour.

		   <p>If <code>MaxBackupIndex</code> is positive, then files
		   {<code>File.1</code>, ..., <code>File.MaxBackupIndex -1</code>}
		   are renamed to {<code>File.2</code>, ...,
		   <code>File.MaxBackupIndex</code>}. Moreover...",1,main\include\log4cxx\rolling\multiprocessrollingfileappender.hpp,LOG4CXX_NS.rolling,30,rolling,1
66679,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\rolling\rollingfileappender.hpp,main\include\log4cxx\rolling\rollingfileappender.hpp:<global>,,<global>,1
66683,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace rolling
{


/**
 * <code>RollingFileAppender</code> extends {@link log4cxx::FileAppender} to backup the log files
 * depending on {@link log4cxx::rolling::RollingPolicy RollingPolicy} and {@link log4cxx::rolling::TriggeringPolicy TriggeringPolicy}.
 * <p>
 * To be of any use, a <code>RollingFileAppender</code> instance must have both
 * a <code>RollingPolicy</code> and a <code>TriggeringPolicy</code> set up.
 * However, if its <code>RollingPolicy</code> also implements the
 * <code>TriggeringPolicy</code> interface, then only the former needs to be
 * set up. For example, {@link log4cxx::rolling::TimeBasedRollingPolicy TimeBasedRollingPolicy} acts both as a
 * <code>RollingPolicy</code> and a <code>TriggeringPolicy</code>.
 *
 * <p><code>RollingFileAppender</code> can be configured programattically or
 * using {@link log4cxx::xml::DOMConfigurator}. Here is a sample
 * configration file:

<pre>&lt;?xml version=""1.0"" encoding=""UTF-8"" ?>
&lt;!DOCTYPE lo...",1,main\include\log4cxx\rolling\rollingfileappender.hpp,LOG4CXX_NS,28,LOG4CXX_NS,1
66684,NAMESPACE_BLOCK,"namespace rolling
{


/**
 * <code>RollingFileAppender</code> extends {@link log4cxx::FileAppender} to backup the log files
 * depending on {@link log4cxx::rolling::RollingPolicy RollingPolicy} and {@link log4cxx::rolling::TriggeringPolicy TriggeringPolicy}.
 * <p>
 * To be of any use, a <code>RollingFileAppender</code> instance must have both
 * a <code>RollingPolicy</code> and a <code>TriggeringPolicy</code> set up.
 * However, if its <code>RollingPolicy</code> also implements the
 * <code>TriggeringPolicy</code> interface, then only the former needs to be
 * set up. For example, {@link log4cxx::rolling::TimeBasedRollingPolicy TimeBasedRollingPolicy} acts both as a
 * <code>RollingPolicy</code> and a <code>TriggeringPolicy</code>.
 *
 * <p><code>RollingFileAppender</code> can be configured programattically or
 * using {@link log4cxx::xml::DOMConfigurator}. Here is a sample
 * configration file:

<pre>&lt;?xml version=""1.0"" encoding=""UTF-8"" ?>
&lt;!DOCTYPE log4j:configuration>

&lt...",1,main\include\log4cxx\rolling\rollingfileappender.hpp,LOG4CXX_NS.rolling,30,rolling,1
66694,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\rolling\rollingpolicy.hpp,main\include\log4cxx\rolling\rollingpolicy.hpp:<global>,,<global>,1
66698,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace rolling
{


/**
 * A <code>RollingPolicy</code> is responsible for performing the
 * rolling over of the active log file. The <code>RollingPolicy</code>
 * is also responsible for providing the <em>active log file</em>,
 * that is the live file where logging output will be directed.
 *
 *
 *
 *
*/
class LOG4CXX_EXPORT RollingPolicy :
	public virtual spi::OptionHandler
{
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(RollingPolicy)

	public:
		virtual ~RollingPolicy() {}

		/**
		 * Initialize the policy and return any initial actions for rolling file appender.
		 *
		 * @param currentActiveFile current value of RollingFileAppender.getFile().
		 * @param append current value of RollingFileAppender.getAppend().
		 * @param pool pool for memory allocations during call.
		 * @return Description of the initialization, may be null to indicate
		 * no initialization needed.
		 * @throws SecurityException if denied access to log files.
		 */
		virtual RolloverDescription...",1,main\include\log4cxx\rolling\rollingpolicy.hpp,LOG4CXX_NS,25,LOG4CXX_NS,1
66699,NAMESPACE_BLOCK,"namespace rolling
{


/**
 * A <code>RollingPolicy</code> is responsible for performing the
 * rolling over of the active log file. The <code>RollingPolicy</code>
 * is also responsible for providing the <em>active log file</em>,
 * that is the live file where logging output will be directed.
 *
 *
 *
 *
*/
class LOG4CXX_EXPORT RollingPolicy :
	public virtual spi::OptionHandler
{
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(RollingPolicy)

	public:
		virtual ~RollingPolicy() {}

		/**
		 * Initialize the policy and return any initial actions for rolling file appender.
		 *
		 * @param currentActiveFile current value of RollingFileAppender.getFile().
		 * @param append current value of RollingFileAppender.getAppend().
		 * @param pool pool for memory allocations during call.
		 * @return Description of the initialization, may be null to indicate
		 * no initialization needed.
		 * @throws SecurityException if denied access to log files.
		 */
		virtual RolloverDescriptionPtr initialize(
			cons...",1,main\include\log4cxx\rolling\rollingpolicy.hpp,LOG4CXX_NS.rolling,27,rolling,1
66717,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\rolling\rollingpolicybase.hpp,main\include\log4cxx\rolling\rollingpolicybase.hpp:<global>,,<global>,1
66721,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace rolling
{
LOG4CXX_LIST_DEF(PatternConverterList, LOG4CXX_NS::pattern::PatternConverterPtr);
LOG4CXX_LIST_DEF(FormattingInfoList, LOG4CXX_NS::pattern::FormattingInfoPtr);

/**
 * Implements methods common to most, it not all, rolling
 * policies.
 *
 *
 *
 */
class LOG4CXX_EXPORT RollingPolicyBase :
	public virtual RollingPolicy,
	public virtual helpers::Object
{
	protected:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(RollingPolicyBase)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(RollingPolicy)
		LOG4CXX_CAST_ENTRY(spi::OptionHandler)
		END_LOG4CXX_CAST_MAP()

		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(RollingPolicyBasePrivate, m_priv)

	public:
		RollingPolicyBase();
		virtual ~RollingPolicyBase();

		/**
		\copybrief RollingPolicy::activateOptions()

		Logs a warning if FileNamePattern is not set.

		\sa RollingPolicy::activateOptions()
		*/
		void activateOptions(helpers::Pool& p) override;

		/**
		A map from a name to the object implementing the (date or ind...",1,main\include\log4cxx\rolling\rollingpolicybase.hpp,LOG4CXX_NS,29,LOG4CXX_NS,1
66722,NAMESPACE_BLOCK,"namespace rolling
{
LOG4CXX_LIST_DEF(PatternConverterList, LOG4CXX_NS::pattern::PatternConverterPtr);
LOG4CXX_LIST_DEF(FormattingInfoList, LOG4CXX_NS::pattern::FormattingInfoPtr);

/**
 * Implements methods common to most, it not all, rolling
 * policies.
 *
 *
 *
 */
class LOG4CXX_EXPORT RollingPolicyBase :
	public virtual RollingPolicy,
	public virtual helpers::Object
{
	protected:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(RollingPolicyBase)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(RollingPolicy)
		LOG4CXX_CAST_ENTRY(spi::OptionHandler)
		END_LOG4CXX_CAST_MAP()

		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(RollingPolicyBasePrivate, m_priv)

	public:
		RollingPolicyBase();
		virtual ~RollingPolicyBase();

		/**
		\copybrief RollingPolicy::activateOptions()

		Logs a warning if FileNamePattern is not set.

		\sa RollingPolicy::activateOptions()
		*/
		void activateOptions(helpers::Pool& p) override;

		/**
		A map from a name to the object implementing the (date or index) formatting.
		*/
		...",1,main\include\log4cxx\rolling\rollingpolicybase.hpp,LOG4CXX_NS.rolling,31,rolling,1
66730,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\rolling\rolloverdescription.hpp,main\include\log4cxx\rolling\rolloverdescription.hpp:<global>,,<global>,1
66734,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace rolling
{


class RolloverDescription : public LOG4CXX_NS::helpers::Object
{
		DECLARE_LOG4CXX_OBJECT(RolloverDescription)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(RolloverDescription)
		END_LOG4CXX_CAST_MAP()

		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(RolloverDescriptionPrivate, m_priv)

	public:
		RolloverDescription();
		/**
		 * Create new instance.
		 * @param activeFileName active log file name after rollover, may not be null.
		 * @param append true if active log file after rollover should be opened for appending.
		 * @param synchronous action to be completed after close of current active log file, may be null.
		 * @param asynchronous action to be completed after close of current active log file and
		 * before next rollover attempt.
		 */
		RolloverDescription(
			const LogString& activeFileName,
			const bool append,
			const ActionPtr& synchronous,
			const ActionPtr& asynchronous);

		~RolloverDescription();

		/**
		 * Active log file...",1,main\include\log4cxx\rolling\rolloverdescription.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
66735,NAMESPACE_BLOCK,"namespace rolling
{


class RolloverDescription : public LOG4CXX_NS::helpers::Object
{
		DECLARE_LOG4CXX_OBJECT(RolloverDescription)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(RolloverDescription)
		END_LOG4CXX_CAST_MAP()

		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(RolloverDescriptionPrivate, m_priv)

	public:
		RolloverDescription();
		/**
		 * Create new instance.
		 * @param activeFileName active log file name after rollover, may not be null.
		 * @param append true if active log file after rollover should be opened for appending.
		 * @param synchronous action to be completed after close of current active log file, may be null.
		 * @param asynchronous action to be completed after close of current active log file and
		 * before next rollover attempt.
		 */
		RolloverDescription(
			const LogString& activeFileName,
			const bool append,
			const ActionPtr& synchronous,
			const ActionPtr& asynchronous);

		~RolloverDescription();

		/**
		 * Active log file name after rollover.
	...",1,main\include\log4cxx\rolling\rolloverdescription.hpp,LOG4CXX_NS.rolling,25,rolling,1
66772,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\rolling\sizebasedtriggeringpolicy.hpp,main\include\log4cxx\rolling\sizebasedtriggeringpolicy.hpp:<global>,,<global>,1
66776,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{

class File;

namespace helpers
{
class Pool;
}

namespace rolling
{

/**
 * SizeBasedTriggeringPolicy looks at size of the file being
 * currently written to.
 *
 *
 *
 */
class LOG4CXX_EXPORT SizeBasedTriggeringPolicy : public TriggeringPolicy
{
		DECLARE_LOG4CXX_OBJECT(SizeBasedTriggeringPolicy)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(SizeBasedTriggeringPolicy)
		LOG4CXX_CAST_ENTRY_CHAIN(TriggeringPolicy)
		END_LOG4CXX_CAST_MAP()

	protected:
		size_t maxFileSize;

	public:
		SizeBasedTriggeringPolicy();
		/**
		 * Determines if a rollover may be appropriate at this time.  If
		 * true is returned, RolloverPolicy.rollover will be called but it
		 * can determine that a rollover is not warranted.
		 *
		 * @param appender A reference to the appender.
		 * @param event A reference to the currently event.
		 * @param filename The filename for the currently active log file.
		 * @param fileLength Length of the file in bytes.
		 * @return true if a rollo...",1,main\include\log4cxx\rolling\sizebasedtriggeringpolicy.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
66778,NAMESPACE_BLOCK,"namespace helpers
{
class Pool;
}",1,main\include\log4cxx\rolling\sizebasedtriggeringpolicy.hpp,LOG4CXX_NS.helpers,28,helpers,2
66780,NAMESPACE_BLOCK,"namespace rolling
{

/**
 * SizeBasedTriggeringPolicy looks at size of the file being
 * currently written to.
 *
 *
 *
 */
class LOG4CXX_EXPORT SizeBasedTriggeringPolicy : public TriggeringPolicy
{
		DECLARE_LOG4CXX_OBJECT(SizeBasedTriggeringPolicy)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(SizeBasedTriggeringPolicy)
		LOG4CXX_CAST_ENTRY_CHAIN(TriggeringPolicy)
		END_LOG4CXX_CAST_MAP()

	protected:
		size_t maxFileSize;

	public:
		SizeBasedTriggeringPolicy();
		/**
		 * Determines if a rollover may be appropriate at this time.  If
		 * true is returned, RolloverPolicy.rollover will be called but it
		 * can determine that a rollover is not warranted.
		 *
		 * @param appender A reference to the appender.
		 * @param event A reference to the currently event.
		 * @param filename The filename for the currently active log file.
		 * @param fileLength Length of the file in bytes.
		 * @return true if a rollover should occur.
		 */
		bool isTriggeringEvent(
			Appender* appender,...",1,main\include\log4cxx\rolling\sizebasedtriggeringpolicy.hpp,LOG4CXX_NS.rolling,33,rolling,3
66794,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\rolling\timebasedrollingpolicy.hpp,main\include\log4cxx\rolling\timebasedrollingpolicy.hpp:<global>,,<global>,1
66798,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{

namespace rolling
{



/**
 * <code>TimeBasedRollingPolicy</code> is both easy to configure and quite
 * powerful.
 *
 * <p>In order to use  <code>TimeBasedRollingPolicy</code>, the
 * <b>FileNamePattern</b> option must be set. It basically specifies the name of the
 * rolled log files. The value <code>FileNamePattern</code> should consist of
 * the name of the file, plus a suitably placed <code>%d</code> conversion
 * specifier. The <code>%d</code> conversion specifier may contain a date and
 * time pattern as specified by the {@link log4cxx::helpers::SimpleDateFormat} class. If
 * the date and time pattern is ommitted, then the default pattern of
 * ""yyyy-MM-dd"" is assumed. The following examples should clarify the point.
 *
 * <p>
 * <table cellspacing=""5px"" border=""1"">
 *   <tr>
 *     <th><code>FileNamePattern</code> value</th>
 *     <th>Rollover schedule</th>
 *     <th>Example</th>
 *   </tr>
 *   <tr>
 *     <td nowrap=""true""><code>/wombat/folder/foo...",1,main\include\log4cxx\rolling\timebasedrollingpolicy.hpp,LOG4CXX_NS,28,LOG4CXX_NS,1
66799,NAMESPACE_BLOCK,"namespace rolling
{



/**
 * <code>TimeBasedRollingPolicy</code> is both easy to configure and quite
 * powerful.
 *
 * <p>In order to use  <code>TimeBasedRollingPolicy</code>, the
 * <b>FileNamePattern</b> option must be set. It basically specifies the name of the
 * rolled log files. The value <code>FileNamePattern</code> should consist of
 * the name of the file, plus a suitably placed <code>%d</code> conversion
 * specifier. The <code>%d</code> conversion specifier may contain a date and
 * time pattern as specified by the {@link log4cxx::helpers::SimpleDateFormat} class. If
 * the date and time pattern is ommitted, then the default pattern of
 * ""yyyy-MM-dd"" is assumed. The following examples should clarify the point.
 *
 * <p>
 * <table cellspacing=""5px"" border=""1"">
 *   <tr>
 *     <th><code>FileNamePattern</code> value</th>
 *     <th>Rollover schedule</th>
 *     <th>Example</th>
 *   </tr>
 *   <tr>
 *     <td nowrap=""true""><code>/wombat/folder/foo.%d</code></td>
 *     <...",1,main\include\log4cxx\rolling\timebasedrollingpolicy.hpp,LOG4CXX_NS.rolling,31,rolling,1
66811,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\rolling\triggeringpolicy.hpp,main\include\log4cxx\rolling\triggeringpolicy.hpp:<global>,,<global>,1
66815,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
class File;

namespace rolling
{

/**
 * A <code>TriggeringPolicy</code> controls the conditions under which rollover
 * occurs. Such conditions include time of day, file size, an
 * external event or a combination thereof.
 *
 *
 *
 * */

class LOG4CXX_EXPORT TriggeringPolicy :
	public virtual spi::OptionHandler,
	public virtual helpers::Object
{
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(TriggeringPolicy)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(TriggeringPolicy)
		LOG4CXX_CAST_ENTRY(spi::OptionHandler)
		END_LOG4CXX_CAST_MAP()
	public:
		virtual ~TriggeringPolicy();

		/**
		 * Determines if a rollover may be appropriate at this time.  If
		 * true is returned, RolloverPolicy.rollover will be called but it
		 * can determine that a rollover is not warranted.
		 *
		 * @param appender A reference to the appender.
		 * @param event A reference to the currently event.
		 * @param filename The filename for the currently active log file.
		 * @param fileLength Len...",1,main\include\log4cxx\rolling\triggeringpolicy.hpp,LOG4CXX_NS,28,LOG4CXX_NS,1
66817,NAMESPACE_BLOCK,"namespace rolling
{

/**
 * A <code>TriggeringPolicy</code> controls the conditions under which rollover
 * occurs. Such conditions include time of day, file size, an
 * external event or a combination thereof.
 *
 *
 *
 * */

class LOG4CXX_EXPORT TriggeringPolicy :
	public virtual spi::OptionHandler,
	public virtual helpers::Object
{
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(TriggeringPolicy)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(TriggeringPolicy)
		LOG4CXX_CAST_ENTRY(spi::OptionHandler)
		END_LOG4CXX_CAST_MAP()
	public:
		virtual ~TriggeringPolicy();

		/**
		 * Determines if a rollover may be appropriate at this time.  If
		 * true is returned, RolloverPolicy.rollover will be called but it
		 * can determine that a rollover is not warranted.
		 *
		 * @param appender A reference to the appender.
		 * @param event A reference to the currently event.
		 * @param filename The filename for the currently active log file.
		 * @param fileLength Length of the file in bytes.
		 * @retu...",1,main\include\log4cxx\rolling\triggeringpolicy.hpp,LOG4CXX_NS.rolling,32,rolling,2
66825,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\rolling\zipcompressaction.hpp,main\include\log4cxx\rolling\zipcompressaction.hpp:<global>,,<global>,1
66829,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace rolling
{


class ZipCompressAction : public Action
{
		struct ZipCompressActionPrivate;
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(ZipCompressAction)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(ZipCompressAction)
		LOG4CXX_CAST_ENTRY_CHAIN(Action)
		END_LOG4CXX_CAST_MAP()

		/**
		 * Constructor.
		 */
		ZipCompressAction(const File& source,
			const File& destination,
			bool deleteSource);

		/**
		 * Perform action.
		 *
		 * @return true if successful.
		 */
		bool execute(LOG4CXX_NS::helpers::Pool& pool) const override;

		/**
		 * Set to true to throw an IOException on a fork failure.  By default, this
		 * is true.  When an IOException is thrown, this will automatically cause the
		 * error handler to be called(which is the recommended way of handling this
		 * problem).  By setting this to false, the ZipCompressAction effectively
		 * turns into a FileRenameAction if any errors are encountered.
		 *
		 * @param throwIO
		 */
		void setTh...",1,main\include\log4cxx\rolling\zipcompressaction.hpp,LOG4CXX_NS,24,LOG4CXX_NS,1
66830,NAMESPACE_BLOCK,"namespace rolling
{


class ZipCompressAction : public Action
{
		struct ZipCompressActionPrivate;
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(ZipCompressAction)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(ZipCompressAction)
		LOG4CXX_CAST_ENTRY_CHAIN(Action)
		END_LOG4CXX_CAST_MAP()

		/**
		 * Constructor.
		 */
		ZipCompressAction(const File& source,
			const File& destination,
			bool deleteSource);

		/**
		 * Perform action.
		 *
		 * @return true if successful.
		 */
		bool execute(LOG4CXX_NS::helpers::Pool& pool) const override;

		/**
		 * Set to true to throw an IOException on a fork failure.  By default, this
		 * is true.  When an IOException is thrown, this will automatically cause the
		 * error handler to be called(which is the recommended way of handling this
		 * problem).  By setting this to false, the ZipCompressAction effectively
		 * turns into a FileRenameAction if any errors are encountered.
		 *
		 * @param throwIO
		 */
		void setThrowIOExceptionOnForkFai...",1,main\include\log4cxx\rolling\zipcompressaction.hpp,LOG4CXX_NS.rolling,26,rolling,1
66860,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\simplelayout.hpp,main\include\log4cxx\simplelayout.hpp:<global>,,<global>,1
66864,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
/**
SimpleLayout consists of the level of the log statement,
followed by "" - "" and then the log message itself. For example,

<pre>
        DEBUG - Hello world
</pre>

<p>

<p>PatternLayout offers a much more powerful alternative.
*/
class LOG4CXX_EXPORT SimpleLayout : public Layout
{
	public:
		DECLARE_LOG4CXX_OBJECT(SimpleLayout)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(SimpleLayout)
		LOG4CXX_CAST_ENTRY_CHAIN(Layout)
		END_LOG4CXX_CAST_MAP()

		/**
		Returns the log statement in a format consisting of the
		<code>level</code>, followed by "" - "" and then the
		<code>message</code>. For example, <pre> INFO - ""A message""
		</pre>
		*/
		void format(LogString& output,
			const spi::LoggingEventPtr& event,
			helpers::Pool& pool) const override;

		/**
		The SimpleLayout does not handle the throwable contained within
		{@link spi::LoggingEvent LoggingEvents}. Thus, it returns
		<code>true</code>.
		*/
		bool ignoresThrowable() const override
		{
			return...",1,main\include\log4cxx\simplelayout.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
66876,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\spi\appenderattachable.hpp,main\include\log4cxx\spi\appenderattachable.hpp:<global>,,<global>,1
66880,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace spi
{
/**
 * This Interface is for attaching Appenders to objects.
 */
class LOG4CXX_EXPORT AppenderAttachable : public virtual helpers::Object
{
	public:
		// Methods
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(AppenderAttachable)

		/**
		 * Add an appender.
		 */
		virtual void addAppender(const AppenderPtr newAppender) = 0;

		/**
		 * Get all previously added appenders as an AppenderList.
		 */
		virtual AppenderList getAllAppenders() const = 0;

		/**
		 * Get an appender by name.
		 */
		virtual AppenderPtr getAppender(const LogString& name) const = 0;

		/**
		 * Returns <code>true</code> if the specified appender is in list of
		 * attached appenders, <code>false</code> otherwise.
		 */
		virtual bool isAttached(const AppenderPtr appender) const = 0;

		/**
		 * Remove all previously added appenders.
		 */
		virtual void removeAllAppenders() = 0;

		/**
		 * Remove the appender passed as parameter from the list of appenders.
		 */
		virtual void remov...",1,main\include\log4cxx\spi\appenderattachable.hpp,LOG4CXX_NS,26,LOG4CXX_NS,1
66881,NAMESPACE_BLOCK,"namespace spi
{
/**
 * This Interface is for attaching Appenders to objects.
 */
class LOG4CXX_EXPORT AppenderAttachable : public virtual helpers::Object
{
	public:
		// Methods
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(AppenderAttachable)

		/**
		 * Add an appender.
		 */
		virtual void addAppender(const AppenderPtr newAppender) = 0;

		/**
		 * Get all previously added appenders as an AppenderList.
		 */
		virtual AppenderList getAllAppenders() const = 0;

		/**
		 * Get an appender by name.
		 */
		virtual AppenderPtr getAppender(const LogString& name) const = 0;

		/**
		 * Returns <code>true</code> if the specified appender is in list of
		 * attached appenders, <code>false</code> otherwise.
		 */
		virtual bool isAttached(const AppenderPtr appender) const = 0;

		/**
		 * Remove all previously added appenders.
		 */
		virtual void removeAllAppenders() = 0;

		/**
		 * Remove the appender passed as parameter from the list of appenders.
		 */
		virtual void removeAppender(const Appende...",1,main\include\log4cxx\spi\appenderattachable.hpp,LOG4CXX_NS.spi,28,spi,1
66887,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\spi\configurator.hpp,main\include\log4cxx\spi\configurator.hpp:<global>,,<global>,1
66891,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
class File;

namespace spi
{

enum class ConfigurationStatus{
	Configured,
	NotConfigured,
};

/**
Implemented by classes capable of configuring log4j using a URL.
*/
class LOG4CXX_EXPORT Configurator : virtual public helpers::Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(Configurator)

		/**
		Interpret a resource pointed by a URL and set up log4j accordingly.

		The configuration is done relative to the <code>hierarchy</code>
		parameter.

		@param configFileName The file to parse
		@param repository The hierarchy to operation upon.
		*/
		virtual ConfigurationStatus doConfigure(const File& configFileName,
			spi::LoggerRepositoryPtr repository) = 0;

	protected:
		Configurator();

	private:
		Configurator(const Configurator&);
		Configurator& operator=(const Configurator&);
};

LOG4CXX_PTR_DEF(Configurator);
}
}",1,main\include\log4cxx\spi\configurator.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
66893,NAMESPACE_BLOCK,"namespace spi
{

enum class ConfigurationStatus{
	Configured,
	NotConfigured,
};

/**
Implemented by classes capable of configuring log4j using a URL.
*/
class LOG4CXX_EXPORT Configurator : virtual public helpers::Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(Configurator)

		/**
		Interpret a resource pointed by a URL and set up log4j accordingly.

		The configuration is done relative to the <code>hierarchy</code>
		parameter.

		@param configFileName The file to parse
		@param repository The hierarchy to operation upon.
		*/
		virtual ConfigurationStatus doConfigure(const File& configFileName,
			spi::LoggerRepositoryPtr repository) = 0;

	protected:
		Configurator();

	private:
		Configurator(const Configurator&);
		Configurator& operator=(const Configurator&);
};

LOG4CXX_PTR_DEF(Configurator);
}",1,main\include\log4cxx\spi\configurator.hpp,LOG4CXX_NS.spi,27,spi,2
66908,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\spi\defaultrepositoryselector.hpp,main\include\log4cxx\spi\defaultrepositoryselector.hpp:<global>,,<global>,1
66912,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace spi
{
class LOG4CXX_EXPORT DefaultRepositorySelector :
	public virtual RepositorySelector,
	public virtual helpers::Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(DefaultRepositorySelector)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(RepositorySelector)
		END_LOG4CXX_CAST_MAP()

		DefaultRepositorySelector(const LoggerRepositoryPtr repository1);
		~DefaultRepositorySelector();
		LoggerRepositoryPtr getLoggerRepository() override;

	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(DefaultRepositorySelectorPrivate, m_priv)
};
}  // namespace spi
}",1,main\include\log4cxx\spi\defaultrepositoryselector.hpp,LOG4CXX_NS,26,LOG4CXX_NS,1
66913,NAMESPACE_BLOCK,"namespace spi
{
class LOG4CXX_EXPORT DefaultRepositorySelector :
	public virtual RepositorySelector,
	public virtual helpers::Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(DefaultRepositorySelector)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(RepositorySelector)
		END_LOG4CXX_CAST_MAP()

		DefaultRepositorySelector(const LoggerRepositoryPtr repository1);
		~DefaultRepositorySelector();
		LoggerRepositoryPtr getLoggerRepository() override;

	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(DefaultRepositorySelectorPrivate, m_priv)
};
}",1,main\include\log4cxx\spi\defaultrepositoryselector.hpp,LOG4CXX_NS.spi,28,spi,1
66924,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\spi\errorhandler.hpp,main\include\log4cxx\spi\errorhandler.hpp:<global>,,<global>,1
66928,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace spi
{
class ErrorCode
{
	public:
		enum
		{
			GENERIC_FAILURE = 0,
			WRITE_FAILURE = 1,
			FLUSH_FAILURE = 2,
			CLOSE_FAILURE = 3,
			FILE_OPEN_FAILURE = 4,
			MISSING_LAYOUT = 5,
			ADDRESS_PARSE_FAILURE = 6
		};
};


/**
Appenders may delegate their error handling to
<code>ErrorHandlers</code>.

<p>Error handling is a particularly tedious to get right because by
definition errors are hard to predict and to reproduce.


<p>Please take the time to contact the author in case you discover
that errors are not properly handled. You are most welcome to
suggest new error handling policies or criticize existing policies.
*/
class LOG4CXX_EXPORT ErrorHandler : public virtual OptionHandler
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(ErrorHandler)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(ErrorHandler)
		LOG4CXX_CAST_ENTRY(OptionHandler)
		END_LOG4CXX_CAST_MAP()

		virtual ~ErrorHandler() {}

		/**
		Add a reference to a logger to which the failing a...",1,main\include\log4cxx\spi\errorhandler.hpp,LOG4CXX_NS,26,LOG4CXX_NS,1
66929,NAMESPACE_BLOCK,"namespace spi
{
class ErrorCode
{
	public:
		enum
		{
			GENERIC_FAILURE = 0,
			WRITE_FAILURE = 1,
			FLUSH_FAILURE = 2,
			CLOSE_FAILURE = 3,
			FILE_OPEN_FAILURE = 4,
			MISSING_LAYOUT = 5,
			ADDRESS_PARSE_FAILURE = 6
		};
};


/**
Appenders may delegate their error handling to
<code>ErrorHandlers</code>.

<p>Error handling is a particularly tedious to get right because by
definition errors are hard to predict and to reproduce.


<p>Please take the time to contact the author in case you discover
that errors are not properly handled. You are most welcome to
suggest new error handling policies or criticize existing policies.
*/
class LOG4CXX_EXPORT ErrorHandler : public virtual OptionHandler
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(ErrorHandler)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(ErrorHandler)
		LOG4CXX_CAST_ENTRY(OptionHandler)
		END_LOG4CXX_CAST_MAP()

		virtual ~ErrorHandler() {}

		/**
		Add a reference to a logger to which the failing appender might
		be atta...",1,main\include\log4cxx\spi\errorhandler.hpp,LOG4CXX_NS.spi,28,spi,1
66973,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\spi\filter.hpp,main\include\log4cxx\spi\filter.hpp:<global>,,<global>,1
66977,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace spi
{
class Filter;
LOG4CXX_PTR_DEF(Filter);


/**
Users should extend this class to implement customized logging
event filtering. Note that Logger and
AppenderSkeleton, the parent class of all standard
appenders, have built-in filtering rules. It is suggested that you
first use and understand the built-in rules before rushing to write
your own custom filters.

<p>This abstract class assumes and also imposes that filters be
organized in a linear chain. The {@link #decide
decide(LoggingEvent)} method of each filter is called sequentially,
in the order of their addition to the chain.

<p>The {@link #decide decide(LoggingEvent)} method must return one
of the integer constants #DENY, #NEUTRAL or
#ACCEPT.

<p>If the value #DENY is returned, then the log event is
dropped immediately without consulting with the remaining
filters.

<p>If the value #NEUTRAL is returned, then the next filter
in the chain is consulted. If there are no more filters in the
chain,...",1,main\include\log4cxx\spi\filter.hpp,LOG4CXX_NS,25,LOG4CXX_NS,1
66978,NAMESPACE_BLOCK,"namespace spi
{
class Filter;
LOG4CXX_PTR_DEF(Filter);


/**
Users should extend this class to implement customized logging
event filtering. Note that Logger and
AppenderSkeleton, the parent class of all standard
appenders, have built-in filtering rules. It is suggested that you
first use and understand the built-in rules before rushing to write
your own custom filters.

<p>This abstract class assumes and also imposes that filters be
organized in a linear chain. The {@link #decide
decide(LoggingEvent)} method of each filter is called sequentially,
in the order of their addition to the chain.

<p>The {@link #decide decide(LoggingEvent)} method must return one
of the integer constants #DENY, #NEUTRAL or
#ACCEPT.

<p>If the value #DENY is returned, then the log event is
dropped immediately without consulting with the remaining
filters.

<p>If the value #NEUTRAL is returned, then the next filter
in the chain is consulted. If there are no more filters in the
chain, then the log event is ...",1,main\include\log4cxx\spi\filter.hpp,LOG4CXX_NS.spi,27,spi,1
66987,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\spi\hierarchyeventlistener.hpp,main\include\log4cxx\spi\hierarchyeventlistener.hpp:<global>,,<global>,1
66991,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
class Logger;
class Appender;


namespace spi
{

/** Listen to events occuring within a Hierarchy.*/
class LOG4CXX_EXPORT HierarchyEventListener :
	public virtual LOG4CXX_NS::helpers::Object
{
	public:
		virtual ~HierarchyEventListener() {}

		virtual void addAppenderEvent(
			const Logger* logger,
			const Appender* appender) = 0;

		virtual void removeAppenderEvent(
			const Logger* logger,
			const Appender* appender) = 0;
};
LOG4CXX_PTR_DEF(HierarchyEventListener);
LOG4CXX_LIST_DEF(HierarchyEventListenerList, HierarchyEventListenerPtr);

}  // namespace spi
}",1,main\include\log4cxx\spi\hierarchyeventlistener.hpp,LOG4CXX_NS,24,LOG4CXX_NS,1
66994,NAMESPACE_BLOCK,"namespace spi
{

/** Listen to events occuring within a Hierarchy.*/
class LOG4CXX_EXPORT HierarchyEventListener :
	public virtual LOG4CXX_NS::helpers::Object
{
	public:
		virtual ~HierarchyEventListener() {}

		virtual void addAppenderEvent(
			const Logger* logger,
			const Appender* appender) = 0;

		virtual void removeAppenderEvent(
			const Logger* logger,
			const Appender* appender) = 0;
};
LOG4CXX_PTR_DEF(HierarchyEventListener);
LOG4CXX_LIST_DEF(HierarchyEventListenerList, HierarchyEventListenerPtr);

}",1,main\include\log4cxx\spi\hierarchyeventlistener.hpp,LOG4CXX_NS.spi,30,spi,3
67007,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\spi\location\locationinfo.hpp,main\include\log4cxx\spi\location\locationinfo.hpp:<global>,,<global>,1
67011,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace spi
{
/**
 * This class represents the location of a logging statement.
 *
 */
class LOG4CXX_EXPORT LocationInfo
{
	public:



		/**
		  *   When location information is not available the constant
		  * <code>NA</code> is returned. Current value of this string constant is <b>?</b>.
		  */
		static const char* const NA;
		static const char* const NA_METHOD;

		static const LocationInfo& getLocationUnavailable();

#ifdef LOG4CXX_HAS_STRING_VIEW
		static constexpr const char* calcShortFileName(const char* fileName){
			std::string_view view(fileName);
			// If the separator is not found, rfind will return -1.  Adding 1 to
			// that will have it pointing at fileName, which is a good fallback.
			return fileName + view.rfind(LOG4CXX_SHORT_FILENAME_SPLIT_CHAR) + 1;
		}
#else
		static const char* calcShortFileName(const char* fileName){
			const char* location = strrchr(fileName, LOG4CXX_SHORT_FILENAME_SPLIT_CHAR);
			return location == nullptr ? fileName ...",1,main\include\log4cxx\spi\location\locationinfo.hpp,LOG4CXX_NS,37,LOG4CXX_NS,1
67012,NAMESPACE_BLOCK,"namespace spi
{
/**
 * This class represents the location of a logging statement.
 *
 */
class LOG4CXX_EXPORT LocationInfo
{
	public:



		/**
		  *   When location information is not available the constant
		  * <code>NA</code> is returned. Current value of this string constant is <b>?</b>.
		  */
		static const char* const NA;
		static const char* const NA_METHOD;

		static const LocationInfo& getLocationUnavailable();

#ifdef LOG4CXX_HAS_STRING_VIEW
		static constexpr const char* calcShortFileName(const char* fileName){
			std::string_view view(fileName);
			// If the separator is not found, rfind will return -1.  Adding 1 to
			// that will have it pointing at fileName, which is a good fallback.
			return fileName + view.rfind(LOG4CXX_SHORT_FILENAME_SPLIT_CHAR) + 1;
		}
#else
		static const char* calcShortFileName(const char* fileName){
			const char* location = strrchr(fileName, LOG4CXX_SHORT_FILENAME_SPLIT_CHAR);
			return location == nullptr ? fileName : location + 1;
		}
#en...",1,main\include\log4cxx\spi\location\locationinfo.hpp,LOG4CXX_NS.spi,39,spi,1
67017,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\spi\loggerfactory.hpp,main\include\log4cxx\spi\loggerfactory.hpp:<global>,,<global>,1
67021,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{

namespace spi
{
/**
Implement this interface to create new instances of Logger or
a sub-class of Logger.
*/
class LOG4CXX_EXPORT LoggerFactory : public virtual helpers::Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(LoggerFactory)
		virtual ~LoggerFactory() {}
		virtual LoggerPtr makeNewLoggerInstance(helpers::Pool& pool, const LogString& name) const = 0;
};


}  // namespace spi
}",1,main\include\log4cxx\spi\loggerfactory.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
67022,NAMESPACE_BLOCK,"namespace spi
{
/**
Implement this interface to create new instances of Logger or
a sub-class of Logger.
*/
class LOG4CXX_EXPORT LoggerFactory : public virtual helpers::Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(LoggerFactory)
		virtual ~LoggerFactory() {}
		virtual LoggerPtr makeNewLoggerInstance(helpers::Pool& pool, const LogString& name) const = 0;
};


}",1,main\include\log4cxx\spi\loggerfactory.hpp,LOG4CXX_NS.spi,26,spi,1
67035,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\spi\loggerrepository.hpp,main\include\log4cxx\spi\loggerrepository.hpp:<global>,,<global>,1
67039,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace spi
{

/**
A <code>LoggerRepository</code> is used to create and retrieve
<code>Loggers</code>. The relation between loggers in a repository
depends on the repository but typically loggers are arranged in a
named hierarchy.

<p>In addition to the creational methods, a
<code>LoggerRepository</code> can be queried for existing loggers,
can act as a point of registry for events related to loggers.
*/
class LOG4CXX_EXPORT LoggerRepository : public virtual helpers::Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(LoggerRepository)
		virtual ~LoggerRepository() {}

		/**
		Add a {@link spi::HierarchyEventListener HierarchyEventListener}
		        event to the repository.
		*/
		virtual void addHierarchyEventListener(const HierarchyEventListenerPtr&
			listener) = 0;

#if 15 < LOG4CXX_ABI_VERSION
		/**
		 * Remove a previously added HierarchyEventListener from the repository.
		 *
		 */
		virtual void removeHierarchyEventListener(const spi::HierarchyEven...",1,main\include\log4cxx\spi\loggerrepository.hpp,LOG4CXX_NS,27,LOG4CXX_NS,1
67040,NAMESPACE_BLOCK,"namespace spi
{

/**
A <code>LoggerRepository</code> is used to create and retrieve
<code>Loggers</code>. The relation between loggers in a repository
depends on the repository but typically loggers are arranged in a
named hierarchy.

<p>In addition to the creational methods, a
<code>LoggerRepository</code> can be queried for existing loggers,
can act as a point of registry for events related to loggers.
*/
class LOG4CXX_EXPORT LoggerRepository : public virtual helpers::Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(LoggerRepository)
		virtual ~LoggerRepository() {}

		/**
		Add a {@link spi::HierarchyEventListener HierarchyEventListener}
		        event to the repository.
		*/
		virtual void addHierarchyEventListener(const HierarchyEventListenerPtr&
			listener) = 0;

#if 15 < LOG4CXX_ABI_VERSION
		/**
		 * Remove a previously added HierarchyEventListener from the repository.
		 *
		 */
		virtual void removeHierarchyEventListener(const spi::HierarchyEventListenerPtr& listener)...",1,main\include\log4cxx\spi\loggerrepository.hpp,LOG4CXX_NS.spi,29,spi,1
67057,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\spi\loggingevent.hpp,main\include\log4cxx\spi\loggingevent.hpp:<global>,,<global>,1
67061,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace helpers
{
class ObjectOutputStream;
}

namespace spi
{
LOG4CXX_LIST_DEF(KeySet, LogString);

/**
The internal representation of logging events. When an affirmative
decision is made to log then a <code>LoggingEvent</code> instance
is created. This instance is passed around to the different log4cxx
components.

<p>This class is of concern to those wishing to extend log4cxx.
*/
class LOG4CXX_EXPORT LoggingEvent :
	public virtual helpers::Object
{
	public:
		DECLARE_LOG4CXX_OBJECT(LoggingEvent)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(LoggingEvent)
		END_LOG4CXX_CAST_MAP()

		typedef spi::KeySet KeySet;

		/** For serialization only
		*/
		LoggingEvent();

		/**
		Instantiate a LoggingEvent from the supplied parameters.

		<p>Except timeStamp all the other fields of
		<code>LoggingEvent</code> are filled when actually needed.
		<p>
		@param logger The logger of this event.
		@param level The level of this event.
		@param location The source code l...",1,main\include\log4cxx\spi\loggingevent.hpp,LOG4CXX_NS,30,LOG4CXX_NS,1
67062,NAMESPACE_BLOCK,"namespace helpers
{
class ObjectOutputStream;
}",1,main\include\log4cxx\spi\loggingevent.hpp,LOG4CXX_NS.helpers,32,helpers,1
67064,NAMESPACE_BLOCK,"namespace spi
{
LOG4CXX_LIST_DEF(KeySet, LogString);

/**
The internal representation of logging events. When an affirmative
decision is made to log then a <code>LoggingEvent</code> instance
is created. This instance is passed around to the different log4cxx
components.

<p>This class is of concern to those wishing to extend log4cxx.
*/
class LOG4CXX_EXPORT LoggingEvent :
	public virtual helpers::Object
{
	public:
		DECLARE_LOG4CXX_OBJECT(LoggingEvent)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(LoggingEvent)
		END_LOG4CXX_CAST_MAP()

		typedef spi::KeySet KeySet;

		/** For serialization only
		*/
		LoggingEvent();

		/**
		Instantiate a LoggingEvent from the supplied parameters.

		<p>Except timeStamp all the other fields of
		<code>LoggingEvent</code> are filled when actually needed.
		<p>
		@param logger The logger of this event.
		@param level The level of this event.
		@param location The source code location of the logging request.
		@param message  The text to add to thi...",1,main\include\log4cxx\spi\loggingevent.hpp,LOG4CXX_NS.spi,37,spi,2
67074,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\spi\optionhandler.hpp,main\include\log4cxx\spi\optionhandler.hpp:<global>,,<global>,1
67078,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace spi
{
class OptionHandler;
typedef std::shared_ptr<OptionHandler> OptionHandlerPtr;

/**
A string based interface to configure package components.
*/
class LOG4CXX_EXPORT OptionHandler : public virtual helpers::Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(OptionHandler)
		virtual ~OptionHandler() {}

		/**
		Activate the options that were previously set with calls to option
		setters.

		<p>This allows to defer activiation of the options until all
		options have been set. This is required for components which have
		related options that remain ambigous until all are set.

		<p>For example, the FileAppender has
		the <code>File</code> and <b>Append</b> options both of
		which are ambigous until the other is also set.
		*/
		virtual void activateOptions(helpers::Pool& p) = 0;


		/**
		Set <code>option</code> to <code>value</code>.

		<p>The handling of each option depends on the OptionHandler
		instance. Some options may become active immediate...",1,main\include\log4cxx\spi\optionhandler.hpp,LOG4CXX_NS,24,LOG4CXX_NS,1
67079,NAMESPACE_BLOCK,"namespace spi
{
class OptionHandler;
typedef std::shared_ptr<OptionHandler> OptionHandlerPtr;

/**
A string based interface to configure package components.
*/
class LOG4CXX_EXPORT OptionHandler : public virtual helpers::Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(OptionHandler)
		virtual ~OptionHandler() {}

		/**
		Activate the options that were previously set with calls to option
		setters.

		<p>This allows to defer activiation of the options until all
		options have been set. This is required for components which have
		related options that remain ambigous until all are set.

		<p>For example, the FileAppender has
		the <code>File</code> and <b>Append</b> options both of
		which are ambigous until the other is also set.
		*/
		virtual void activateOptions(helpers::Pool& p) = 0;


		/**
		Set <code>option</code> to <code>value</code>.

		<p>The handling of each option depends on the OptionHandler
		instance. Some options may become active immediately whereas
		other may ...",1,main\include\log4cxx\spi\optionhandler.hpp,LOG4CXX_NS.spi,26,spi,1
67086,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\spi\repositoryselector.hpp,main\include\log4cxx\spi\repositoryselector.hpp:<global>,,<global>,1
67090,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace spi
{
class LoggerRepository;
typedef std::shared_ptr<LoggerRepository> LoggerRepositoryPtr;

/**
The <code>LogManager</code> uses one (and only one)
<code>RepositorySelector</code> implementation to select the
{@link log4cxx::spi::LoggerRepository LoggerRepository}
    for a particular application context.

<p>It is the responsability of the <code>RepositorySelector</code>
implementation to track the application context. log4cxx makes no
assumptions about the application context or on its management.

<p>See also LogManager.
*/
class LOG4CXX_EXPORT RepositorySelector : public virtual helpers::Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(RepositorySelector)
		virtual ~RepositorySelector() {}
		virtual LoggerRepositoryPtr getLoggerRepository() = 0;
};
LOG4CXX_PTR_DEF(RepositorySelector);
}  //namespace spi
}",1,main\include\log4cxx\spi\repositoryselector.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
67091,NAMESPACE_BLOCK,"namespace spi
{
class LoggerRepository;
typedef std::shared_ptr<LoggerRepository> LoggerRepositoryPtr;

/**
The <code>LogManager</code> uses one (and only one)
<code>RepositorySelector</code> implementation to select the
{@link log4cxx::spi::LoggerRepository LoggerRepository}
    for a particular application context.

<p>It is the responsability of the <code>RepositorySelector</code>
implementation to track the application context. log4cxx makes no
assumptions about the application context or on its management.

<p>See also LogManager.
*/
class LOG4CXX_EXPORT RepositorySelector : public virtual helpers::Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(RepositorySelector)
		virtual ~RepositorySelector() {}
		virtual LoggerRepositoryPtr getLoggerRepository() = 0;
};
LOG4CXX_PTR_DEF(RepositorySelector);
}",1,main\include\log4cxx\spi\repositoryselector.hpp,LOG4CXX_NS.spi,25,spi,1
67099,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\spi\rootlogger.hpp,main\include\log4cxx\spi\rootlogger.hpp:<global>,,<global>,1
67103,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace spi
{
/**
RootLogger sits at the top of the logger hierachy. It is a
regular logger except that it provides several guarantees.

<p>First, it cannot be assigned a null
level. Second, since root logger cannot have a parent, the
#getEffectiveLevel method always returns the value of the
level field without walking the hierarchy.
*/
class LOG4CXX_EXPORT RootLogger : public Logger
{
	public:
		/**
		The root logger names itself as ""root"". However, the root
		logger cannot be retrieved by name.
		*/
		RootLogger(LOG4CXX_NS::helpers::Pool& pool, const LevelPtr level);

		~RootLogger() {}

		/**
		Return the assigned level value without walking the logger
		hierarchy.
		*/
		virtual const LevelPtr& getEffectiveLevel() const;

		/**
		            Setting a null value to the level of the root logger may have catastrophic
		            results. We prevent this here.
		            */
		void setLevel(const LevelPtr level);
};
}  // namespace spi
}",1,main\include\log4cxx\spi\rootlogger.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
67104,NAMESPACE_BLOCK,"namespace spi
{
/**
RootLogger sits at the top of the logger hierachy. It is a
regular logger except that it provides several guarantees.

<p>First, it cannot be assigned a null
level. Second, since root logger cannot have a parent, the
#getEffectiveLevel method always returns the value of the
level field without walking the hierarchy.
*/
class LOG4CXX_EXPORT RootLogger : public Logger
{
	public:
		/**
		The root logger names itself as ""root"". However, the root
		logger cannot be retrieved by name.
		*/
		RootLogger(LOG4CXX_NS::helpers::Pool& pool, const LevelPtr level);

		~RootLogger() {}

		/**
		Return the assigned level value without walking the logger
		hierarchy.
		*/
		virtual const LevelPtr& getEffectiveLevel() const;

		/**
		            Setting a null value to the level of the root logger may have catastrophic
		            results. We prevent this here.
		            */
		void setLevel(const LevelPtr level);
};
}",1,main\include\log4cxx\spi\rootlogger.hpp,LOG4CXX_NS.spi,25,spi,1
67109,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\spi\triggeringeventevaluator.hpp,main\include\log4cxx\spi\triggeringeventevaluator.hpp:<global>,,<global>,1
67113,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace spi
{
/**
Implementions of this interface allow certain appenders to decide
when to perform an appender specific action.

<p>For example the {@link net::SMTPAppender SMTPAppender} sends
an email when the #isTriggeringEvent method returns
<code>true</code> and adds the event to an internal buffer when the
returned result is <code>false</code>.

*/
class LOG4CXX_EXPORT TriggeringEventEvaluator : public virtual helpers::Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(TriggeringEventEvaluator)
		/**
		Is this the triggering event?
		*/
		virtual bool isTriggeringEvent(const spi::LoggingEventPtr& event) = 0;
};
LOG4CXX_PTR_DEF(TriggeringEventEvaluator);
}
}",1,main\include\log4cxx\spi\triggeringeventevaluator.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
67114,NAMESPACE_BLOCK,"namespace spi
{
/**
Implementions of this interface allow certain appenders to decide
when to perform an appender specific action.

<p>For example the {@link net::SMTPAppender SMTPAppender} sends
an email when the #isTriggeringEvent method returns
<code>true</code> and adds the event to an internal buffer when the
returned result is <code>false</code>.

*/
class LOG4CXX_EXPORT TriggeringEventEvaluator : public virtual helpers::Object
{
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(TriggeringEventEvaluator)
		/**
		Is this the triggering event?
		*/
		virtual bool isTriggeringEvent(const spi::LoggingEventPtr& event) = 0;
};
LOG4CXX_PTR_DEF(TriggeringEventEvaluator);
}",1,main\include\log4cxx\spi\triggeringeventevaluator.hpp,LOG4CXX_NS.spi,25,spi,1
67124,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\stream.hpp,main\include\log4cxx\stream.hpp:<global>,,<global>,1
67128,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{

/**
  *   Base class for the basic_logstream template which attempts
  *   to emulate std::basic_ostream but attempts to short-circuit
  *   unnecessary operations.
  *
  *   The logstream has a logger and level that are used for logging
  *   requests.  The level of the stream is compared against the
  *   current level of the logger to determine if the request should be processed.
  */
class LOG4CXX_EXPORT logstream_base
{
	public:
		/**
		 *  Create new instance.
		 *  @param logger logger logger used in log requests.
		 *  @param level indicates level that will be used in log requests.  Can
		 *      be modified later by inserting a level or calling setLevel.
		 */
		logstream_base(const LOG4CXX_NS::LoggerPtr& logger,
			const LOG4CXX_NS::LevelPtr& level);
		/**
		 *  Destructor.
		 */
		virtual ~logstream_base();
		/**
		 *  Insertion operator for std::fixed and similar manipulators.
		 */
		void insert(std::ios_base & (*manip)(std::ios_base&));

		/**
	...",1,main\include\log4cxx\stream.hpp,LOG4CXX_NS,25,LOG4CXX_NS,1
67147,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\varia\fallbackerrorhandler.hpp,main\include\log4cxx\varia\fallbackerrorhandler.hpp:<global>,,<global>,1
67151,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace varia
{
/**
The <code>FallbackErrorHandler</code> implements the ErrorHandler
interface such that a secondary appender may be specified.  This
secondary appender takes over if the primary appender fails for
whatever reason.

<p>The error message is printed on <code>System.err</code>, and
logged in the new secondary appender.
*/
class LOG4CXX_EXPORT FallbackErrorHandler :
	public virtual spi::ErrorHandler
{
	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(FallbackErrorHandlerPrivate, m_priv)

	public:
		DECLARE_LOG4CXX_OBJECT(FallbackErrorHandler)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(FallbackErrorHandler)
		LOG4CXX_CAST_ENTRY_CHAIN(spi::ErrorHandler)
		END_LOG4CXX_CAST_MAP()

		FallbackErrorHandler();
		~FallbackErrorHandler();

		/**
		<em>Adds</em> the logger passed as parameter to the list of
		loggers that we need to search for in case of appender failure.
		*/
		void setLogger(const LoggerPtr& logger) override;


		/**
		\copybrief spi::...",1,main\include\log4cxx\varia\fallbackerrorhandler.hpp,LOG4CXX_NS,27,LOG4CXX_NS,1
67152,NAMESPACE_BLOCK,"namespace varia
{
/**
The <code>FallbackErrorHandler</code> implements the ErrorHandler
interface such that a secondary appender may be specified.  This
secondary appender takes over if the primary appender fails for
whatever reason.

<p>The error message is printed on <code>System.err</code>, and
logged in the new secondary appender.
*/
class LOG4CXX_EXPORT FallbackErrorHandler :
	public virtual spi::ErrorHandler
{
	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(FallbackErrorHandlerPrivate, m_priv)

	public:
		DECLARE_LOG4CXX_OBJECT(FallbackErrorHandler)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(FallbackErrorHandler)
		LOG4CXX_CAST_ENTRY_CHAIN(spi::ErrorHandler)
		END_LOG4CXX_CAST_MAP()

		FallbackErrorHandler();
		~FallbackErrorHandler();

		/**
		<em>Adds</em> the logger passed as parameter to the list of
		loggers that we need to search for in case of appender failure.
		*/
		void setLogger(const LoggerPtr& logger) override;


		/**
		\copybrief spi::OptionHandler::activate...",1,main\include\log4cxx\varia\fallbackerrorhandler.hpp,LOG4CXX_NS.varia,29,varia,1
67162,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\writerappender.hpp,main\include\log4cxx\writerappender.hpp:<global>,,<global>,1
67166,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{

namespace helpers
{
class Transcoder;
}

/**
WriterAppender appends log events to a standard output stream
*/
class LOG4CXX_EXPORT WriterAppender : public AppenderSkeleton
{
	protected:
		struct WriterAppenderPriv;
	public:
		DECLARE_ABSTRACT_LOG4CXX_OBJECT(WriterAppender)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(WriterAppender)
		LOG4CXX_CAST_ENTRY_CHAIN(AppenderSkeleton)
		END_LOG4CXX_CAST_MAP()

		/**
		This default constructor does nothing.*/
		WriterAppender();
	protected:
		WriterAppender(const LayoutPtr& layout,
			LOG4CXX_NS::helpers::WriterPtr& writer);
		WriterAppender(const LayoutPtr& layout);
		WriterAppender(std::unique_ptr<WriterAppenderPriv> priv);

	public:
		~WriterAppender();

		/**
		Derived appenders should override this method if option structure
		requires it.
		*/
		void activateOptions(helpers::Pool& pool) override;

		/**
		If the <b>ImmediateFlush</b> option is set to
		<code>true</code>, the appender will flush at the end of ...",1,main\include\log4cxx\writerappender.hpp,LOG4CXX_NS,25,LOG4CXX_NS,1
67167,NAMESPACE_BLOCK,"namespace helpers
{
class Transcoder;
}",1,main\include\log4cxx\writerappender.hpp,LOG4CXX_NS.helpers,28,helpers,1
67198,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\xml\domconfigurator.hpp,main\include\log4cxx\xml\domconfigurator.hpp:<global>,,<global>,1
67205,NAMESPACE_BLOCK,<empty>,,main\include\log4cxx\xml\xmllayout.hpp,main\include\log4cxx\xml\xmllayout.hpp:<global>,,<global>,1
67209,NAMESPACE_BLOCK,"namespace LOG4CXX_NS
{
namespace xml
{

/**
The output of the XMLLayout consists of a series of log4j:event
elements. It does not output a
 complete well-formed XML file. The output is designed to be
included as an <em>external entity</em> in a separate file to form
a correct XML file.

<p>For example, if <code>abc</code> is the name of the file where
the XMLLayout ouput goes, then a well-formed XML file would be:

<code>
<?xml version=""1.0"" ?>

<!DOCTYPE log4j:eventSet [<!ENTITY data SYSTEM ""abc"">]>

<log4j:eventSet version=""1.2"" xmlns:log4j=""http://jakarta.apache.org/log4j/"">

        @&data;

</log4j:eventSet>
</code>

<p>This approach enforces the independence of the XMLLayout and the
appender where it is embedded.
*/
class LOG4CXX_EXPORT XMLLayout : public Layout
{
	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(XMLLayoutPrivate, m_priv)

	public:
		DECLARE_LOG4CXX_OBJECT(XMLLayout)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(XMLLayout)
		LOG4CXX_CAST_ENTRY_CHAIN(Layout)
		E...",1,main\include\log4cxx\xml\xmllayout.hpp,LOG4CXX_NS,23,LOG4CXX_NS,1
67210,NAMESPACE_BLOCK,"namespace xml
{

/**
The output of the XMLLayout consists of a series of log4j:event
elements. It does not output a
 complete well-formed XML file. The output is designed to be
included as an <em>external entity</em> in a separate file to form
a correct XML file.

<p>For example, if <code>abc</code> is the name of the file where
the XMLLayout ouput goes, then a well-formed XML file would be:

<code>
<?xml version=""1.0"" ?>

<!DOCTYPE log4j:eventSet [<!ENTITY data SYSTEM ""abc"">]>

<log4j:eventSet version=""1.2"" xmlns:log4j=""http://jakarta.apache.org/log4j/"">

        @&data;

</log4j:eventSet>
</code>

<p>This approach enforces the independence of the XMLLayout and the
appender where it is embedded.
*/
class LOG4CXX_EXPORT XMLLayout : public Layout
{
	private:
		LOG4CXX_DECLARE_PRIVATE_MEMBER_PTR(XMLLayoutPrivate, m_priv)

	public:
		DECLARE_LOG4CXX_OBJECT(XMLLayout)
		BEGIN_LOG4CXX_CAST_MAP()
		LOG4CXX_CAST_ENTRY(XMLLayout)
		LOG4CXX_CAST_ENTRY_CHAIN(Layout)
		END_LOG4CXX_CAST_MAP()

...",1,main\include\log4cxx\xml\xmllayout.hpp,LOG4CXX_NS.xml,25,xml,1
67222,NAMESPACE_BLOCK,<empty>,,main\mock-apple\CFString.cpp,main\mock-apple\CFString.cpp:<global>,,<global>,1
67226,NAMESPACE_BLOCK,"namespace {
int throw_out_of_mem(int status)
{
	throw std::bad_alloc();
	return status;
}
apr_pool_t* getStringPool()
{
	struct cfstring_pool
	{
		apr_pool_t* ptr = 0;
		cfstring_pool()
		{
			apr_pool_create_core_ex(&ptr, throw_out_of_mem, NULL);
		}
		~cfstring_pool()
		{
			apr_pool_destroy(ptr);
		}
	};
	static LOG4CXX_NS::helpers::WideLife<cfstring_pool> pool;
	return pool.ptr;
}
}",1,main\mock-apple\CFString.cpp,anonymous_namespace_0,8,,1
67416,NAMESPACE_BLOCK,<empty>,,main\mock-apple\CoreFoundation\CFString.hpp,main\mock-apple\CoreFoundation\CFString.hpp:<global>,,<global>,1
68710,NAMESPACE_BLOCK,<empty>,,<includes>,<includes>:<global>,,<global>,1
