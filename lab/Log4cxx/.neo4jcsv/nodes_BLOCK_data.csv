10,BLOCK,-1,,<empty>,1,,1,1,,ANY
12,BLOCK,-1,,"{
   SQLHENV henv;
   SQLRETURN retcode;

   retcode = SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &henv);
   if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) {
       SQLFreeHandle(SQL_HANDLE_ENV, henv);
   }
   return 1;
}",12,,6,1,,void
30,BLOCK,-1,,"{
       SQLFreeHandle(SQL_HANDLE_ENV, henv);
   }",68,,11,2,,void
44,BLOCK,-1,,<empty>,1,,1,1,,ANY
48,BLOCK,-1,,"{
	boost::atomic<bool> b;
}",32,,3,3,,void
58,BLOCK,-1,,<empty>,1,,1,1,,ANY
62,BLOCK,-1,,"{
	boost::filesystem::path p;
}",32,,3,3,,void
72,BLOCK,-1,,<empty>,1,,1,1,,ANY
76,BLOCK,-1,,"{
	boost::mutex mutex;
	return 0;
}",32,,3,3,,void
88,BLOCK,-1,,<empty>,1,,1,1,,ANY
92,BLOCK,-1,,"{
	boost::shared_mutex mtx;
	return 0;
}",32,,3,3,,void
104,BLOCK,-1,,<empty>,1,,1,1,,ANY
110,BLOCK,-1,,"{
	boost::shared_ptr<foo> fooptr;
	return 0;
}",32,,7,3,,void
122,BLOCK,-1,,<empty>,1,,1,1,,ANY
126,BLOCK,-1,,"{
	boost::thread th;
	return 0;
}",32,,3,3,,void
138,BLOCK,-1,,<empty>,1,,1,1,,ANY
142,BLOCK,-1,,"{
	std::atomic<bool> b;
}",32,,3,3,,void
152,BLOCK,-1,,<empty>,1,,1,1,,ANY
156,BLOCK,-1,,"{
	std::experimental::filesystem::path p;
}",32,,3,3,,void
166,BLOCK,-1,,<empty>,1,,1,1,,ANY
170,BLOCK,-1,,"{
	std::filesystem::path p;
}",32,,3,3,,void
180,BLOCK,-1,,<empty>,1,,1,1,,ANY
184,BLOCK,-1,,"{
	std::mutex mutex;
	return 0;
}",32,,3,3,,void
196,BLOCK,-1,,<empty>,1,,1,1,,ANY
200,BLOCK,-1,,"{
	std::shared_mutex shared;
	return 0;
}",32,,3,3,,void
212,BLOCK,-1,,<empty>,1,,1,1,,ANY
218,BLOCK,-1,,"{
	std::shared_ptr<foo> fooptr;
	return 0;
}",32,,7,3,,void
230,BLOCK,-1,,<empty>,1,,1,1,,ANY
234,BLOCK,-1,,"{
	std::thread th;
	return 0;
}",32,,3,3,,void
246,BLOCK,-1,,<empty>,1,,1,1,,ANY
250,BLOCK,-1,,"{
	std::make_unique<int>(5);
	return 0;
}",32,,3,3,,void
266,BLOCK,-1,,<empty>,1,,1,1,,ANY
268,BLOCK,-1,,"{
	thread_local std::string thread_id_string;
    return thread_id_string;
}",1,,4,1,,void
275,BLOCK,-1,,"{
	getCurrentThreadVar() = ""name"";
}",11,,9,1,,void
289,BLOCK,-1,,<empty>,1,,1,1,,ANY
294,BLOCK,-1,,"{
	StringType str;
	StreamType ss;
    ss << str;
    return 0;
}",1,,12,1,,void
310,BLOCK,-1,,<empty>,1,,1,1,,ANY
312,BLOCK,-1,,"{
	pthread_t tid;
	char buffer[16];
	pthread_getname_np(tid, buffer, sizeof(buffer));
}",11,,3,1,,void
328,BLOCK,-1,,<empty>,1,,1,1,,ANY
330,BLOCK,-1,,"{
	pthread_t tid;
	pthread_setname_np(tid, ""name"");
}",11,,3,1,,void
347,BLOCK,-1,,<empty>,1,,1,1,,ANY
351,BLOCK,-1,,"{
	int result = EXIT_SUCCESS;
	QCoreApplication app(argc, argv);
	com::foo::ConfigureLogging();
	try {
		auto logger = com::foo::getLogger(""MyApp"");
		LOG4CXX_INFO(logger, QString(""Message %1"").arg(1));
		com::foo::Bar bar;
		bar.doIt();
		LOG4CXX_INFO(logger, QString(""Message %1"").arg(2));
	}
	catch(std::exception&) {
		result = EXIT_FAILURE;
	}
	return result;
}",33,,5,3,,void
367,BLOCK,-1,,"{
		auto logger = com::foo::getLogger(""MyApp"");
		LOG4CXX_INFO(logger, QString(""Message %1"").arg(1));
		com::foo::Bar bar;
		bar.doIt();
		LOG4CXX_INFO(logger, QString(""Message %1"").arg(2));
	}",6,,9,1,,void
399,BLOCK,2,,"{
		result = EXIT_FAILURE;
	}",25,,16,2,,void
415,BLOCK,-1,,<empty>,1,,1,1,,ANY
427,BLOCK,-1,,"{
	// Get a logger that is a child of the statically declared logger
	auto fooLogger = log4cxx::Logger::getLogger(""MyApp.foo"");
	LOG4CXX_TRACE(fooLogger, ""Doing foo at trace level"");
	LOG4CXX_DEBUG(fooLogger, ""Doing foo at debug level"");
	LOG4CXX_INFO(fooLogger, ""Doing foo at info level"");
	LOG4CXX_WARN(fooLogger, ""Doing foo at warn level"");
	LOG4CXX_ERROR(fooLogger, ""Doing foo at error level"");
	LOG4CXX_FATAL(fooLogger, ""Doing foo at fatal level"");
}",12,,6,1,,void
461,BLOCK,-1,,"{
	// Log to standard output.
	log4cxx::BasicConfigurator::configure();
	LOG4CXX_INFO(logger, ""Entering application."");
	foo();
	LOG4CXX_INFO(logger, ""Exiting application."");
	return EXIT_SUCCESS;
}",33,,17,3,,void
487,BLOCK,-1,,<empty>,1,,1,1,,ANY
491,BLOCK,-1,,"{
	int result = EXIT_SUCCESS;
	try {
		auto logger = com::foo::getLogger(""MyApp"");
		LOG4CXX_INFO(logger, ""Entering application."");
		com::foo::Bar bar;
		bar.doIt();
		LOG4CXX_INFO(logger, ""Exiting application."");
	}
	catch(std::exception&) {
		result = EXIT_FAILURE;
	}
	return result;
}",33,,4,3,,void
497,BLOCK,-1,,"{
		auto logger = com::foo::getLogger(""MyApp"");
		LOG4CXX_INFO(logger, ""Entering application."");
		com::foo::Bar bar;
		bar.doIt();
		LOG4CXX_INFO(logger, ""Exiting application."");
	}",6,,6,1,,void
519,BLOCK,2,,"{
		result = EXIT_FAILURE;
	}",25,,13,2,,void
533,BLOCK,-1,,<empty>,1,,1,1,,ANY
545,BLOCK,-1,,"{
		LOG4CXX_DEBUG(rootLogger, ""static initializer message"");
	}",22,,22,1,,void
553,BLOCK,-1,,"{
	LOG4CXX_INFO(rootLogger, ""main function message"");
	return EXIT_SUCCESS;
}",12,,27,1,,void
569,BLOCK,-1,,<empty>,1,,1,1,,ANY
575,BLOCK,-1,,"{
	LOG4CXX_DEBUG(m_logger, QString(""Did it again!"") << QString("" - again!""));
}",18,,8,1,,void
591,BLOCK,-1,,<empty>,1,,1,1,,ANY
597,BLOCK,-1,,"{
	LOG4CXX_DEBUG(m_logger, ""Did it again!"");
}",18,,7,1,,void
609,BLOCK,-1,,<empty>,1,,1,1,,ANY
615,BLOCK,-1,,<empty>,,,,1,,<empty>
640,BLOCK,-1,,<empty>,1,,1,1,,ANY
644,BLOCK,-1,,"{
	using namespace log4cxx;
	static struct log4cxx_finalizer {
		~log4cxx_finalizer() {
			LogManager::shutdown();
		}
	} finaliser;
	QFileInfo app{QCoreApplication::applicationFilePath()};
	QString basename{app.baseName()};
	QVector<QString> paths =
		{ QString(""."")
		, app.absoluteDir().absolutePath()
		};
	QVector<QString> names =
		{ QString(basename + "".xml"")
		, QString(basename + "".properties"")
		, QString(""MyApp.properties"")
		, QString(""log4cxx.xml"")
		, QString(""log4cxx.properties"")
		, QString(""log4j.xml"")
		, QString(""log4j.properties"")
	};
#if defined(_DEBUG)
	helpers::LogLog::setInternalDebugging(true);
#endif
	auto status       = spi::ConfigurationStatus::NotConfigured;
	auto selectedPath = QString();
	std::tie(status, selectedPath) = qt::Configuration::configureFromFileAndWatch(paths, names);
	if (status == spi::ConfigurationStatus::NotConfigured)
		BasicConfigurator::configure(); // Send events to the console
}",25,,31,1,,void
709,BLOCK,-1,,<empty>,3,,60,2,,void
718,BLOCK,-1,,"{
	using namespace log4cxx;
	return name.isEmpty()
		? LogManager::getRootLogger()
		: LogManager::getLogger(name.toStdString());
}",50,,64,2,,void
741,BLOCK,-1,,"{
	using namespace log4cxx;
	return name
		? LogManager::getLogger(name)
		: LogManager::getRootLogger();
}",47,,72,2,,void
762,BLOCK,-1,,<empty>,1,,1,1,,ANY
766,BLOCK,-1,,<empty>,,,,1,,<empty>
772,BLOCK,-1,,<empty>,,,,2,,<empty>
777,BLOCK,-1,,<empty>,,,,2,,<empty>
786,BLOCK,-1,,<empty>,1,,1,1,,ANY
792,BLOCK,-1,,<empty>,,,,2,,<empty>
805,BLOCK,-1,,<empty>,1,,1,1,,ANY
810,BLOCK,-1,,"{
	using namespace log4cxx;
	static struct log4cxx_initializer {
		log4cxx_initializer() {
			// Set up a simple configuration that logs on the console.
			BasicConfigurator::configure();
		}
		~log4cxx_initializer() {
			LogManager::shutdown();
		}
	} initAndShutdown;
	return name.empty()
		? LogManager::getRootLogger()
		: LogManager::getLogger(name);
}",54,,7,2,,void
841,BLOCK,-1,,<empty>,1,,1,1,,ANY
846,BLOCK,-1,,"{
	using namespace log4cxx;
	static struct log4cxx_initializer {
		log4cxx_initializer() {
			if (PropertyConfigurator::configure(""MyApp.properties"") == spi::ConfigurationStatus::NotConfigured)
				BasicConfigurator::configure(); // Send events to the console
		}
		~log4cxx_initializer() {
			LogManager::shutdown();
		}
	} initAndShutdown;
	return name.empty()
		? LogManager::getRootLogger()
		: LogManager::getLogger(name);
}",54,,8,2,,void
895,BLOCK,-1,,<empty>,1,,1,1,,ANY
899,BLOCK,-1,,"{
	std::vector<std::string> result;

	// Find the executable file name
	static const int bufSize = 4096;
	char buf[bufSize+1] = {0}, pathSepar = '/';
	uint32_t bufCount = 0;
#if defined(WIN32)
	GetModuleFileName(NULL, buf, bufSize);
	pathSepar = '\\';
#elif defined(__APPLE__)
	_NSGetExecutablePath(buf, &bufCount);
#elif (defined(_XOPEN_SOURCE) && _XOPEN_SOURCE >= 500) || (defined(_POSIX_C_SOURCE) && _POSIX_C_SOURCE >= 200112L)
	std::ostringstream exeLink;
	exeLink << ""/proc/"" << getpid() << ""/exe"";
	bufCount = readlink(exeLink.str().c_str(), buf, bufSize);
	if (0 < bufCount)
		buf[bufCount] = 0;
#else
	strncpy(buf, ""auto-configured"", bufSize);
#endif
	std::string programFileName(buf);
	auto slashIndex = programFileName.rfind(pathSepar);
	if (std::string::npos != slashIndex) {
		// Extract the path
		altPrefix = programFileName.substr(0, slashIndex + 1);
#if defined(_DEBUG)
		LogString msg1 = LOG4CXX_STR(""Alternate prefix ["");
		helpers::Transcoder::decode(altPrefix, msg1);
		msg1 +=...",88,,44,2,,void
949,BLOCK,-1,,"{
		// Extract the path
		altPrefix = programFileName.substr(0, slashIndex + 1);
#if defined(_DEBUG)
		LogString msg1 = LOG4CXX_STR(""Alternate prefix ["");
		helpers::Transcoder::decode(altPrefix, msg1);
		msg1 += LOG4CXX_STR(""]"");
		helpers::LogLog::debug(msg1);
#endif
		// Add a local directory relative name
		result.push_back(programFileName.substr(slashIndex + 1));
#if defined(_DEBUG)
		LogString msg2(LOG4CXX_STR(""Alternate configuration file name [""));
		helpers::Transcoder::decode(result.back(), msg2);
		msg2 += LOG4CXX_STR(""]"");
		helpers::LogLog::debug(msg2);
#endif
		// Add a local directory relative name without any extension
		auto dotIndex = result.back().rfind('.');
		if (std::string::npos != dotIndex) {
			result.push_back(result.back());
			result.back().erase(dotIndex);
#if defined(_DEBUG)
			LogString msg3(LOG4CXX_STR(""Alternate configuration file name [""));
			helpers::Transcoder::decode(result.back(), msg3);
			msg3 += LOG4CXX_STR(""]"");
			helpers::LogLog::debug(ms...",39,,67,2,,void
990,BLOCK,-1,,"{
			result.push_back(result.back());
			result.back().erase(dotIndex);
#if defined(_DEBUG)
			LogString msg3(LOG4CXX_STR(""Alternate configuration file name [""));
			helpers::Transcoder::decode(result.back(), msg3);
			msg3 += LOG4CXX_STR(""]"");
			helpers::LogLog::debug(msg3);
#endif
		}",38,,86,2,,void
1008,BLOCK,-1,,<empty>,7,,97,1,,void
1015,BLOCK,-1,,"{
		auto dotIndex = result.back().rfind('.');
		if (std::string::npos != dotIndex) {
			programFileName.erase(dotIndex);
			result.push_back(programFileName);
#if defined(_DEBUG)
			LogString msg(LOG4CXX_STR(""Alternate configuration file name [""));
			helpers::Transcoder::decode(result.back(), msg);
			msg += LOG4CXX_STR(""]"");
			helpers::LogLog::debug(msg);
#endif
		}
	}",37,,97,2,,void
1035,BLOCK,-1,,"{
			programFileName.erase(dotIndex);
			result.push_back(programFileName);
#if defined(_DEBUG)
			LogString msg(LOG4CXX_STR(""Alternate configuration file name [""));
			helpers::Transcoder::decode(result.back(), msg);
			msg += LOG4CXX_STR(""]"");
			helpers::LogLog::debug(msg);
#endif
		}",38,,99,2,,void
1061,BLOCK,-1,,"{
#if defined(_DEBUG)
	helpers::LogLog::setInternalDebugging(true);
#endif
	const char* extension[] = { "".xml"", "".properties"", 0 };
	std::string altPrefix;
	helpers::Pool pool;

	for (auto baseName : DefaultConfigurationFileNames(altPrefix)) {
		int i = 0;
		for (; extension[i]; ++i) {
			File current_working_dir_candidate(baseName + extension[i]);
			if (current_working_dir_candidate.exists(pool)) {
				DefaultConfigurator::setConfigurationFileName(current_working_dir_candidate.getPath());
				DefaultConfigurator::setConfigurationWatchSeconds(5);
				break;
			}
			if (!altPrefix.empty()) {
				File alt_dir_candidate(altPrefix + baseName + extension[i]);
				if (alt_dir_candidate.exists(pool)) {
					DefaultConfigurator::setConfigurationFileName(alt_dir_candidate.getPath());
					DefaultConfigurator::setConfigurationWatchSeconds(5);
					break;
				}
			}
		}
		if (extension[i]) // Found a configuration file?
			return;
	}
	// Configuration file not found - send events to the conso...",32,,117,1,,void
1075,BLOCK,-1,,"{
		int i = 0;
		for (; extension[i]; ++i) {
			File current_working_dir_candidate(baseName + extension[i]);
			if (current_working_dir_candidate.exists(pool)) {
				DefaultConfigurator::setConfigurationFileName(current_working_dir_candidate.getPath());
				DefaultConfigurator::setConfigurationWatchSeconds(5);
				break;
			}
			if (!altPrefix.empty()) {
				File alt_dir_candidate(altPrefix + baseName + extension[i]);
				if (alt_dir_candidate.exists(pool)) {
					DefaultConfigurator::setConfigurationFileName(alt_dir_candidate.getPath());
					DefaultConfigurator::setConfigurationWatchSeconds(5);
					break;
				}
			}
		}
		if (extension[i]) // Found a configuration file?
			return;
	}",65,,125,3,,void
1081,BLOCK,-1,,<empty>,3,,127,1,,void
1087,BLOCK,4,,"{
			File current_working_dir_candidate(baseName + extension[i]);
			if (current_working_dir_candidate.exists(pool)) {
				DefaultConfigurator::setConfigurationFileName(current_working_dir_candidate.getPath());
				DefaultConfigurator::setConfigurationWatchSeconds(5);
				break;
			}
			if (!altPrefix.empty()) {
				File alt_dir_candidate(altPrefix + baseName + extension[i]);
				if (alt_dir_candidate.exists(pool)) {
					DefaultConfigurator::setConfigurationFileName(alt_dir_candidate.getPath());
					DefaultConfigurator::setConfigurationWatchSeconds(5);
					break;
				}
			}
		}",29,,127,4,,void
1101,BLOCK,-1,,"{
				DefaultConfigurator::setConfigurationFileName(current_working_dir_candidate.getPath());
				DefaultConfigurator::setConfigurationWatchSeconds(5);
				break;
			}",52,,129,2,,void
1122,BLOCK,-1,,"{
				File alt_dir_candidate(altPrefix + baseName + extension[i]);
				if (alt_dir_candidate.exists(pool)) {
					DefaultConfigurator::setConfigurationFileName(alt_dir_candidate.getPath());
					DefaultConfigurator::setConfigurationWatchSeconds(5);
					break;
				}
			}",28,,134,2,,void
1138,BLOCK,-1,,"{
					DefaultConfigurator::setConfigurationFileName(alt_dir_candidate.getPath());
					DefaultConfigurator::setConfigurationWatchSeconds(5);
					break;
				}",41,,136,2,,void
1157,BLOCK,-1,,<empty>,4,,144,2,,void
1169,BLOCK,-1,,"{
	using namespace log4cxx;
	static struct log4cxx_initializer {
		log4cxx_initializer() {
			SelectConfigurationFile();
		}
		~log4cxx_initializer() {
			LogManager::shutdown();
		}
	} initialiser;
	return name.empty()
		? LogManager::getRootLogger()
		: LogManager::getLogger(name);
}",54,,156,2,,void
1190,BLOCK,-1,,"{
        auto appender = std::make_shared<ConsoleAppender>
            ( std::make_shared<SimpleLayout>()
            , err ? ConsoleAppender::getSystemErr() : ConsoleAppender::getSystemOut()
            );
        r->getRootLogger()->addAppender(appender);
    }",37,,35,1,,void
1248,BLOCK,-1,,<empty>,1,,1,1,,ANY
1250,BLOCK,-1,,"{
    using namespace log4cxx;
    auto r = LogManager::getLoggerRepository();
    r->ensureIsConfigured([r,err]() {
        auto appender = std::make_shared<ConsoleAppender>
            ( std::make_shared<SimpleLayout>()
            , err ? ConsoleAppender::getSystemErr() : ConsoleAppender::getSystemOut()
            );
        r->getRootLogger()->addAppender(appender);
    });
}",1,,32,2,,void
1267,BLOCK,-1,,"{
    setlocale(LC_ALL, """");
    if (argc <= 1) {
        puts(""Console test program\nUsage: console [-err] [ puts | putws | cout | wcout | configure | log | wide | byte ]*\n"");  
    }
    bool configured = false;
    bool err = false;
    for (int i = 1; i < argc; i++) {
        if (strcmp(""-err"", argv[i]) == 0) {
            err = true;
        } else if (strcmp(""puts"", argv[i]) == 0) {
            fputs(""Hello, fputs\n"", err ? stderr : stdout);
#if LOG4CXX_WCHAR_T_API
        } else if (strcmp(""putws"", argv[i]) == 0) {
            fputws(L""Hello, fputws\n"", err ? stderr : stdout);
#endif
        } else if (strcmp(""cout"", argv[i]) == 0) {
            if (err) {
                std::cerr << ""Hello, cout"" << std::endl;
            } else {
                std::cout << ""Hello, cout"" << std::endl;
            }
        } else if (strcmp(""wcout"", argv[i]) == 0) {
            if (err) {
            #if LOG4CXX_HAS_STD_WCOUT
                std::wcerr << L""Hello, wcout"" << std::endl;
  ...",1,,53,3,,void
1275,BLOCK,-1,,"{
        puts(""Console test program\nUsage: console [-err] [ puts | putws | cout | wcout | configure | log | wide | byte ]*\n"");  
    }",20,,55,2,,void
1287,BLOCK,-1,,<empty>,5,,60,1,,void
1297,BLOCK,4,,"{
        if (strcmp(""-err"", argv[i]) == 0) {
            err = true;
        } else if (strcmp(""puts"", argv[i]) == 0) {
            fputs(""Hello, fputs\n"", err ? stderr : stdout);
#if LOG4CXX_WCHAR_T_API
        } else if (strcmp(""putws"", argv[i]) == 0) {
            fputws(L""Hello, fputws\n"", err ? stderr : stdout);
#endif
        } else if (strcmp(""cout"", argv[i]) == 0) {
            if (err) {
                std::cerr << ""Hello, cout"" << std::endl;
            } else {
                std::cout << ""Hello, cout"" << std::endl;
            }
        } else if (strcmp(""wcout"", argv[i]) == 0) {
            if (err) {
            #if LOG4CXX_HAS_STD_WCOUT
                std::wcerr << L""Hello, wcout"" << std::endl;
            #else
                std::cerr << ""Log4cxx has not wcout"" << std::endl;
            #endif
            } else {
            #if LOG4CXX_HAS_STD_WCOUT
                std::wcout << L""Hello, wcout"" << std::endl;
            #else
                std::cout << ""Log...",36,,60,4,,void
1306,BLOCK,-1,,"{
            err = true;
        }",43,,61,2,,void
1311,BLOCK,-1,,<empty>,16,,63,1,,void
1320,BLOCK,-1,,"{
            fputs(""Hello, fputs\n"", err ? stderr : stdout);
#if LOG4CXX_WCHAR_T_API
        } else if (strcmp(""putws"", argv[i]) == 0) {
            fputws(L""Hello, fputws\n"", err ? stderr : stdout);
#endif
        }",50,,63,2,,void
1328,BLOCK,-1,,<empty>,16,,69,1,,void
1337,BLOCK,-1,,"{
            if (err) {
                std::cerr << ""Hello, cout"" << std::endl;
            } else {
                std::cout << ""Hello, cout"" << std::endl;
            }
        }",50,,69,2,,void
1340,BLOCK,-1,,"{
                std::cerr << ""Hello, cout"" << std::endl;
            }",22,,70,2,,void
1351,BLOCK,-1,,"{
                std::cout << ""Hello, cout"" << std::endl;
            }",20,,72,1,,void
1362,BLOCK,-1,,<empty>,16,,75,1,,void
1371,BLOCK,-1,,"{
            if (err) {
            #if LOG4CXX_HAS_STD_WCOUT
                std::wcerr << L""Hello, wcout"" << std::endl;
            #else
                std::cerr << ""Log4cxx has not wcout"" << std::endl;
            #endif
            } else {
            #if LOG4CXX_HAS_STD_WCOUT
                std::wcout << L""Hello, wcout"" << std::endl;
            #else
                std::cout << ""Log4cxx has not wcout"" << std::endl;
            #endif
            }
        }",51,,75,2,,void
1374,BLOCK,-1,,"{
            #if LOG4CXX_HAS_STD_WCOUT
                std::wcerr << L""Hello, wcout"" << std::endl;
            #else
                std::cerr << ""Log4cxx has not wcout"" << std::endl;
            #endif
            }",22,,76,2,,void
1385,BLOCK,-1,,"{
            #if LOG4CXX_HAS_STD_WCOUT
                std::wcout << L""Hello, wcout"" << std::endl;
            #else
                std::cout << ""Log4cxx has not wcout"" << std::endl;
            #endif
            }",20,,82,1,,void
1396,BLOCK,-1,,<empty>,16,,89,1,,void
1405,BLOCK,-1,,"{
            configure(err);
            configured = true;
        }",55,,89,2,,void
1412,BLOCK,-1,,<empty>,16,,92,1,,void
1421,BLOCK,-1,,"{
            if (!configured) {
                configure(err);
                configured = true;
            }
            log4cxx::Logger::getRootLogger()->info(""Hello, log4cxx"");
#if LOG4CXX_WCHAR_T_API
        } else if (strcmp(""wide"", argv[i]) == 0) {
            fwide(err ? stderr : stdout, 1);
        } else if (strcmp(""byte"", argv[i]) == 0) {
            fwide(err ? stderr : stdout, -1);
#endif
        }",49,,92,2,,void
1425,BLOCK,-1,,"{
                configure(err);
                configured = true;
            }",30,,93,2,,void
1442,BLOCK,-1,,"{
            fputs(""Unrecognized option: "", stderr);
            fputs(argv[i], stderr);
            fputs(""\n"", stderr);
            fflush(stderr);
        }",16,,104,1,,void
1471,BLOCK,-1,,<empty>,1,,1,1,,ANY
1478,BLOCK,-1,,<empty>,23,,35,1,,void
1482,BLOCK,-1,,"{
		return false;
	}",39,,37,1,,void
1490,BLOCK,-1,,"{
		// This gets called whenever there is a valid event for our appender.
	}",76,,41,3,,void
1495,BLOCK,-1,,"{
		// Given all of our options, do something useful(e.g. open a file)
	}",59,,45,2,,void
1501,BLOCK,-1,,"{
		if (helpers::StringHelper::equalsIgnoreCase(option,
										   LOG4CXX_STR(""SOMEVALUE""), LOG4CXX_STR(""somevalue""))){
			// Do something with the 'value' here.
		}
	}",75,,49,3,,void
1514,BLOCK,-1,,"{
			// Do something with the 'value' here.
		}",66,,51,2,,void
1522,BLOCK,-1,,"{
    using namespace log4cxx;

	xml::DOMConfigurator::configure( ""custom-appender.xml"" );

	LoggerPtr rootLogger = Logger::getRootLogger();
	LoggerPtr nullLogger = Logger::getLogger( ""NullLogger"" );

	LOG4CXX_INFO( rootLogger, ""This is some root message"" );
	LOG4CXX_INFO( nullLogger, ""This message will be discarded"" );
}",1,,62,3,,void
1577,BLOCK,-1,,<empty>,1,,1,1,,ANY
1583,BLOCK,-1,,"{
                if(argc == 2)
                {
                        init(argv[1]);
                }
                else
                {
                        usage(argv[0], ""Wrong number of arguments."");
                }

                test();
        }",9,,44,3,,void
1588,BLOCK,-1,,"{
                        init(argv[1]);
                }",17,,46,2,,void
1594,BLOCK,-1,,"{
                        usage(argv[0], ""Wrong number of arguments."");
                }",17,,50,1,,void
1606,BLOCK,-1,,"{
                std::cout << msg << std::endl;
                std::cout << ""Usage: "" << programName <<
                                "" configFile"" << std::endl;
                exit(1);
        }",9,,58,3,,void
1635,BLOCK,-1,,"{
                if(configFile.length() > 4 &&
                     configFile.substr(configFile.length() - 4) == "".xml"")
                {
                        xml::DOMConfigurator::configureAndWatch(configFile, 3000);
                }
                else
                {
                        PropertyConfigurator::configureAndWatch(configFile, 3000);
                }
        }",9,,67,2,,void
1656,BLOCK,-1,,"{
                        xml::DOMConfigurator::configureAndWatch(configFile, 3000);
                }",17,,70,2,,void
1666,BLOCK,-1,,"{
                        PropertyConfigurator::configureAndWatch(configFile, 3000);
                }",17,,74,1,,void
1676,BLOCK,-1,,"{
                int i = 0;
                while(true)
                {
                   LOG4CXX_DEBUG(logger, ""MSG "" << i++);
                        try
                        {
                                apr_sleep(1000000);
                        }
                        catch(std::exception&)
                        {
                        }
                }
        }",9,,80,1,,void
1683,BLOCK,-1,,"{
                   LOG4CXX_DEBUG(logger, ""MSG "" << i++);
                        try
                        {
                                apr_sleep(1000000);
                        }
                        catch(std::exception&)
                        {
                        }
                }",17,,83,2,,void
1691,BLOCK,-1,,"{
                                apr_sleep(1000000);
                        }",25,,86,1,,void
1694,BLOCK,2,,"{
                        }",25,,90,2,,void
1708,BLOCK,-1,,"{
    apr_app_initialize(&argc, &argv, NULL);
    int result = EXIT_SUCCESS;
    try
    {
        DelayedLoop::main(argc, argv);
    }
    catch(std::exception&)
    {
        result = EXIT_FAILURE;
    }

    apr_terminate();
    return result;
}",1,,99,3,,void
1720,BLOCK,-1,,"{
        DelayedLoop::main(argc, argv);
    }",5,,103,1,,void
1727,BLOCK,2,,"{
        result = EXIT_FAILURE;
    }",5,,107,2,,void
1758,BLOCK,-1,,<empty>,1,,1,1,,ANY
1764,BLOCK,-1,,"{
		stream << ""[MyStruct x:"" << mystruct.x << ""]"";
		return stream;
}",75,,35,3,,void
1779,BLOCK,-1,,"{
	setlocale(LC_ALL, """");

	using namespace log4cxx;
	BasicConfigurator::configure();
	auto rootLogger = Logger::getRootLogger();

	LOG4CXX_INFO_FMT( rootLogger, ""This is a {} mesage"", ""test"" );
#if !LOG4CXX_USING_STD_FORMAT
	LOG4CXX_INFO_FMT( rootLogger, fmt::fg(fmt::color::red), ""Messages can be colored"" );
#endif
	LOG4CXX_INFO_FMT( rootLogger, ""We can also align text to the {:<10} or {:>10}"", ""left"", ""right"" );

	MyStruct mine{ 42 };
	LOG4CXX_INFO_FMT( rootLogger, ""This custom type {} can also be logged, since it implements operator<<"", mine );

	LOG4CXX_INFO( rootLogger, ""Numbers can be formatted with excessive operator<<: ""
				  << std::setprecision(3) << 22.456
				  << "" And as hex: ""
				  << std::setbase( 16 ) << 123 );
	LOG4CXX_INFO_FMT( rootLogger, ""Numbers can be formatted with a format string {:.1f} and as hex: {:x}"", 22.456, 123 );

	return 0;
}",1,,59,1,,void
1868,BLOCK,-1,,<empty>,1,,1,1,,ANY
1870,BLOCK,-1,,"{
    setlocale(LC_ALL, """"); // Use the user-preferred locale
    int result = EXIT_SUCCESS;
    try
    {
        BasicConfigurator::configure();
        LoggerPtr rootLogger = Logger::getRootLogger();

        NDC context1(""[outer]"");
        LOG4CXX_INFO(rootLogger, ""info message""); // log entry contains ""[outer]""
        {
            NDC context2(""[inner]"");
            LOG4CXX_DEBUG(rootLogger, ""debug message""); // log entry contains ""[outer] [inner]""
        }
        LOG4CXX_WARN(rootLogger, ""warn message""); // log entry contains ""[outer]""
    }
    catch(std::exception&)
    {
        result = EXIT_FAILURE;
    }

    return result;
}",1,,26,1,,void
1879,BLOCK,-1,,"{
        BasicConfigurator::configure();
        LoggerPtr rootLogger = Logger::getRootLogger();

        NDC context1(""[outer]"");
        LOG4CXX_INFO(rootLogger, ""info message""); // log entry contains ""[outer]""
        {
            NDC context2(""[inner]"");
            LOG4CXX_DEBUG(rootLogger, ""debug message""); // log entry contains ""[outer] [inner]""
        }
        LOG4CXX_WARN(rootLogger, ""warn message""); // log entry contains ""[outer]""
    }",5,,30,1,,void
1897,BLOCK,7,,"{
            NDC context2(""[inner]"");
            LOG4CXX_DEBUG(rootLogger, ""debug message""); // log entry contains ""[outer] [inner]""
        }",9,,36,7,,void
1907,BLOCK,2,,"{
        result = EXIT_FAILURE;
    }",5,,43,2,,void
1931,BLOCK,-1,,<empty>,1,,1,1,,ANY
1933,BLOCK,-1,,"{
    setlocale(LC_ALL, """");
    int result = EXIT_SUCCESS;
    try
    {
                BasicConfigurator::configure();
                LoggerPtr rootLogger = Logger::getRootLogger();

                NDC::push(""trivial context"");

                log4cxx::logstream logstream(rootLogger, Level::getDebug());
                logstream << ""debug message "" << 1 << LOG4CXX_ENDMSG;
                logstream.setLevel(Level::getInfo());
                logstream << ""info message"" << LOG4CXX_ENDMSG;
                logstream << Level::getWarn() << ""warn message"" << LOG4CXX_ENDMSG;
                logstream << Level::getError() << ""error message"" << LOG4CXX_ENDMSG;
                logstream << Level::getFatal() << ""fatal message"" << LOG4CXX_ENDMSG;


                NDC::pop();
        }
        catch(std::exception&)
        {
                result = EXIT_FAILURE;
        }

    return result;
}",1,,29,1,,void
1942,BLOCK,-1,,"{
                BasicConfigurator::configure();
                LoggerPtr rootLogger = Logger::getRootLogger();

                NDC::push(""trivial context"");

                log4cxx::logstream logstream(rootLogger, Level::getDebug());
                logstream << ""debug message "" << 1 << LOG4CXX_ENDMSG;
                logstream.setLevel(Level::getInfo());
                logstream << ""info message"" << LOG4CXX_ENDMSG;
                logstream << Level::getWarn() << ""warn message"" << LOG4CXX_ENDMSG;
                logstream << Level::getError() << ""error message"" << LOG4CXX_ENDMSG;
                logstream << Level::getFatal() << ""fatal message"" << LOG4CXX_ENDMSG;


                NDC::pop();
        }",5,,33,1,,void
2020,BLOCK,2,,"{
                result = EXIT_FAILURE;
        }",9,,51,2,,void
2052,BLOCK,-1,,<empty>,1,,1,1,,ANY
2059,BLOCK,-1,,"{
	QFileInfo fi(configFilename);
	if(!fi.exists()){
		return;
	}
	LOG4CXX_NS::xml::DOMConfigurator::configure(path.toStdString());
}",45,,38,2,,void
2069,BLOCK,-1,,"{
		return;
	}",18,,40,2,,void
2087,BLOCK,-1,,"{
	QFileInfo fi(configFilename);
	if(!fi.exists()){
		return;
	}
	LOG4CXX_NS::PropertyConfigurator::configure(path.toStdString());
}",52,,46,2,,void
2097,BLOCK,-1,,"{
		return;
	}",18,,48,2,,void
2113,BLOCK,-1,,"{
	QFileInfo fi(configFilename);
	if(fi.exists()){
		// From the Qt docs:
		// Note that QFileSystemWatcher stops monitoring files once they have been renamed
		// or removed from disk, and directories once they have been removed from disk.
		//
		// Some text editing programs will replace the file with a new one, which deletes
		// the old file(thus causing Qt to remove the watch), so we need to add in the
		// file whenever the directory changes.
		// See also: https://stackoverflow.com/questions/18300376/qt-qfilesystemwatcher-signal-filechanged-gets-emited-only-once
		watcher->addPath(configFilename);
	}
}",39,,54,2,,void
2122,BLOCK,-1,,"{
		// From the Qt docs:
		// Note that QFileSystemWatcher stops monitoring files once they have been renamed
		// or removed from disk, and directories once they have been removed from disk.
		//
		// Some text editing programs will replace the file with a new one, which deletes
		// the old file(thus causing Qt to remove the watch), so we need to add in the
		// file whenever the directory changes.
		// See also: https://stackoverflow.com/questions/18300376/qt-qfilesystemwatcher-signal-filechanged-gets-emited-only-once
		watcher->addPath(configFilename);
	}",17,,56,2,,void
2131,BLOCK,-1,,<empty>,31,,69,1,,void
2136,BLOCK,-1,,"{
	LOG4CXX_NS::spi::ConfigurationStatus stat =LOG4CXX_NS::spi::ConfigurationStatus::NotConfigured;
	bool isXML = false;

	if(filename.endsWith("".xml"")){
		stat = LOG4CXX_NS::xml::DOMConfigurator::configure(filename.toStdString());
		isXML = true;
	}else if(filename.endsWith("".properties"")){
		stat = LOG4CXX_NS::PropertyConfigurator::configure(filename.toStdString());
	}

	if( stat == LOG4CXX_NS::spi::ConfigurationStatus::Configured ){
		watcher = std::make_unique<QFileSystemWatcher>();
		configFilename = filename;
		QFileInfo fi(filename);
		watcher->addPath(fi.dir().absolutePath());
		watcher->addPath(filename);

		QObject::connect(watcher.get(), &QFileSystemWatcher::directoryChanged,
						 &dirChanged);
		if(isXML){
			QObject::connect(watcher.get(), &QFileSystemWatcher::fileChanged,
							 &loadXMLFile);
		}else{
			QObject::connect(watcher.get(), &QFileSystemWatcher::fileChanged,
							 &loadPropertiesFile);
		}
	}

	return stat;
}",89,,71,2,,void
2157,BLOCK,-1,,"{
		stat = LOG4CXX_NS::xml::DOMConfigurator::configure(filename.toStdString());
		isXML = true;
	}",31,,75,2,,void
2176,BLOCK,-1,,<empty>,8,,78,1,,void
2183,BLOCK,-1,,"{
		stat = LOG4CXX_NS::PropertyConfigurator::configure(filename.toStdString());
	}",44,,78,2,,void
2206,BLOCK,-1,,"{
		watcher = std::make_unique<QFileSystemWatcher>();
		configFilename = filename;
		QFileInfo fi(filename);
		watcher->addPath(fi.dir().absolutePath());
		watcher->addPath(filename);

		QObject::connect(watcher.get(), &QFileSystemWatcher::directoryChanged,
						 &dirChanged);
		if(isXML){
			QObject::connect(watcher.get(), &QFileSystemWatcher::fileChanged,
							 &loadXMLFile);
		}else{
			QObject::connect(watcher.get(), &QFileSystemWatcher::fileChanged,
							 &loadPropertiesFile);
		}
	}",64,,82,2,,void
2251,BLOCK,-1,,"{
			QObject::connect(watcher.get(), &QFileSystemWatcher::fileChanged,
							 &loadXMLFile);
		}",12,,91,2,,void
2267,BLOCK,-1,,"{
			QObject::connect(watcher.get(), &QFileSystemWatcher::fileChanged,
							 &loadPropertiesFile);
		}",8,,94,1,,void
2289,BLOCK,-1,,"{
	for( QString dir : directories ){
		for( QString fname : filenames ){
			QString canidate_str = dir + ""/"" + fname;
			QFile candidate(canidate_str);

			LOG4CXX_DECODE_QSTRING(msg, ""Checking file "" + canidate_str);
			LogLog::debug(msg);
			if (candidate.exists())
			{
				LOG4CXX_NS::spi::ConfigurationStatus configStatus = tryLoadFile(canidate_str);
				if( configStatus == LOG4CXX_NS::spi::ConfigurationStatus::Configured ){
					return {configStatus, canidate_str};
				}
				LOG4CXX_DECODE_QSTRING(failmsg, ""Unable to load  "" + canidate_str + "": trying next"");
				LogLog::debug(failmsg);
			}
		}
	}

	return {LOG4CXX_NS::spi::ConfigurationStatus::NotConfigured, QString()};
}",46,,105,3,,void
2293,BLOCK,-1,,"{
		for( QString fname : filenames ){
			QString canidate_str = dir + ""/"" + fname;
			QFile candidate(canidate_str);

			LOG4CXX_DECODE_QSTRING(msg, ""Checking file "" + canidate_str);
			LogLog::debug(msg);
			if (candidate.exists())
			{
				LOG4CXX_NS::spi::ConfigurationStatus configStatus = tryLoadFile(canidate_str);
				if( configStatus == LOG4CXX_NS::spi::ConfigurationStatus::Configured ){
					return {configStatus, canidate_str};
				}
				LOG4CXX_DECODE_QSTRING(failmsg, ""Unable to load  "" + canidate_str + "": trying next"");
				LogLog::debug(failmsg);
			}
		}
	}",34,,106,3,,void
2297,BLOCK,-1,,"{
			QString canidate_str = dir + ""/"" + fname;
			QFile candidate(canidate_str);

			LOG4CXX_DECODE_QSTRING(msg, ""Checking file "" + canidate_str);
			LogLog::debug(msg);
			if (candidate.exists())
			{
				LOG4CXX_NS::spi::ConfigurationStatus configStatus = tryLoadFile(canidate_str);
				if( configStatus == LOG4CXX_NS::spi::ConfigurationStatus::Configured ){
					return {configStatus, canidate_str};
				}
				LOG4CXX_DECODE_QSTRING(failmsg, ""Unable to load  "" + canidate_str + "": trying next"");
				LogLog::debug(failmsg);
			}
		}",35,,107,3,,void
2320,BLOCK,-1,,"{
				LOG4CXX_NS::spi::ConfigurationStatus configStatus = tryLoadFile(canidate_str);
				if( configStatus == LOG4CXX_NS::spi::ConfigurationStatus::Configured ){
					return {configStatus, canidate_str};
				}
				LOG4CXX_DECODE_QSTRING(failmsg, ""Unable to load  "" + canidate_str + "": trying next"");
				LogLog::debug(failmsg);
			}",4,,114,2,,void
2336,BLOCK,-1,,"{
					return {configStatus, canidate_str};
				}",75,,116,2,,void
2359,BLOCK,-1,,<empty>,1,,1,1,,ANY
2366,BLOCK,-1,,"{
	LOG4CXX_NS::LoggerPtr qtLogger = LOG4CXX_NS::Logger::getLogger( context.category );
	LOG4CXX_NS::spi::LocationInfo location( context.file,
										 LOG4CXX_NS::spi::LocationInfo::calcShortFileName(context.file),
										 context.function,
										 context.line );

	switch ( type )
	{
		case QtMsgType::QtDebugMsg:
			qtLogger->debug( message.toStdString(), location );
			break;

		case QtMsgType::QtWarningMsg:
			qtLogger->warn( message.toStdString(), location );
			break;
#if QT_VERSION >= QT_VERSION_CHECK(5, 5, 0)

		case QtMsgType::QtInfoMsg:
			qtLogger->info( message.toStdString(), location );
			break;
#endif

		case QtMsgType::QtCriticalMsg:
			qtLogger->error( message.toStdString(), location );
			break;

		case QtMsgType::QtFatalMsg:
			qtLogger->fatal( message.toStdString(), location );
			std::abort();
	}
}",1,,25,4,,void
2403,BLOCK,-1,,"{
		case QtMsgType::QtDebugMsg:
			qtLogger->debug( message.toStdString(), location );
			break;

		case QtMsgType::QtWarningMsg:
			qtLogger->warn( message.toStdString(), location );
			break;
#if QT_VERSION >= QT_VERSION_CHECK(5, 5, 0)

		case QtMsgType::QtInfoMsg:
			qtLogger->info( message.toStdString(), location );
			break;
#endif

		case QtMsgType::QtCriticalMsg:
			qtLogger->error( message.toStdString(), location );
			break;

		case QtMsgType::QtFatalMsg:
			qtLogger->fatal( message.toStdString(), location );
			std::abort();
	}",2,,33,2,,void
2493,BLOCK,-1,,<empty>,1,,1,1,,ANY
2497,BLOCK,-1,,"{
}",1,,31,1,,void
2502,BLOCK,-1,,<empty>,28,,35,2,,void
2506,BLOCK,-1,,"{
}",1,,38,1,,void
2511,BLOCK,-1,,"{
	std::unique_lock<std::mutex> lock(m_priv->mutex);

	if (!m_priv->interrupted)
	{
		try
		{
			execute(pool1);
		}
		catch (std::exception& ex)
		{
			reportException(ex);
		}

		m_priv->complete = true;
		m_priv->interrupted = true;
	}
}",1,,45,2,,void
2529,BLOCK,-1,,"{
		try
		{
			execute(pool1);
		}
		catch (std::exception& ex)
		{
			reportException(ex);
		}

		m_priv->complete = true;
		m_priv->interrupted = true;
	}",2,,49,2,,void
2531,BLOCK,-1,,"{
			execute(pool1);
		}",3,,51,1,,void
2534,BLOCK,2,,"{
			reportException(ex);
		}",3,,55,2,,void
2550,BLOCK,-1,,"{
	std::unique_lock<std::mutex> lock(m_priv->mutex);
	m_priv->interrupted = true;
}",1,,68,1,,void
2571,BLOCK,-1,,"{
	return m_priv->complete;
}",1,,78,1,,void
2580,BLOCK,-1,,"{
}",1,,88,2,,void
2597,BLOCK,-1,,<empty>,1,,1,1,,ANY
2600,BLOCK,-1,,<empty>,23,,36,1,,void
2609,BLOCK,-1,,"{
}",1,,47,1,,void
2613,BLOCK,-1,,<empty>,25,,50,1,,void
2618,BLOCK,-1,,"{
	if (priv->headFilter == NULL)
	{
		priv->headFilter = filter;
		priv->tailFilter = filter;
	}
	else
	{
		priv->tailFilter->setNext(filter);
	}
}",1,,53,2,,void
2622,BLOCK,1,,<empty>,,,,1,,void
2632,BLOCK,-1,,"{
		priv->headFilter = filter;
		priv->tailFilter = filter;
	}",2,,55,2,,void
2635,BLOCK,1,,<empty>,,,,1,,void
2647,BLOCK,1,,<empty>,,,,1,,void
2658,BLOCK,-1,,"{
		priv->tailFilter->setNext(filter);
	}",2,,60,1,,void
2660,BLOCK,1,,<empty>,,,,1,,void
2677,BLOCK,-1,,"{
	priv->acceptOnMatch = newValue;
}",1,,67,2,,void
2680,BLOCK,1,,<empty>,,,,1,,void
2694,BLOCK,-1,,"{
	bool accepted = true;
	FilterPtr f(priv->headFilter);

	while (f != NULL)
	{
		accepted = accepted && (Filter::ACCEPT == f->decide(event));
		f = f->getNext();
	}

	if (accepted)
	{
		if (priv->acceptOnMatch)
		{
			return Filter::ACCEPT;
		}

		return Filter::DENY;
	}

	return Filter::NEUTRAL;
}",1,,73,2,,void
2702,BLOCK,1,,<empty>,,,,1,,void
2715,BLOCK,-1,,"{
		accepted = accepted && (Filter::ACCEPT == f->decide(event));
		f = f->getNext();
	}",2,,78,2,,void
2737,BLOCK,-1,,"{
		if (priv->acceptOnMatch)
		{
			return Filter::ACCEPT;
		}

		return Filter::DENY;
	}",2,,84,2,,void
2740,BLOCK,1,,<empty>,,,,1,,void
2749,BLOCK,-1,,"{
			return Filter::ACCEPT;
		}",3,,86,2,,void
2782,BLOCK,-1,,<empty>,1,,1,1,,ANY
2790,BLOCK,-1,,"{
}",1,,41,2,,void
2794,BLOCK,-1,,"{

}",1,,45,1,,void
2799,BLOCK,-1,,"{
	// Null values for newAppender parameter are strictly forbidden.
	if (newAppender == 0)
	{
		return;
	}

	std::lock_guard<std::mutex> lock( m_priv->m_mutex );
	AppenderList::iterator it = std::find(
			m_priv->appenderList.begin(), m_priv->appenderList.end(), newAppender);

	if (it == m_priv->appenderList.end())
	{
		m_priv->appenderList.push_back(newAppender);
	}
}",1,,50,2,,void
2804,BLOCK,-1,,"{
		return;
	}",2,,53,2,,void
2847,BLOCK,-1,,"{
		m_priv->appenderList.push_back(newAppender);
	}",2,,62,2,,void
2860,BLOCK,-1,,"{
	int numberAppended = 0;
	// FallbackErrorHandler::error() may modify our list of appenders
	// while we are iterating over them (if it holds the same logger).
	// So, make a local copy of the appenders that we want to iterate over
	// before actually iterating over them.
	AppenderList allAppenders = getAllAppenders();
	for (auto appender : allAppenders)
	{
		appender->doAppend(event, p);
		numberAppended++;
	}

	return numberAppended;
}",1,,70,3,,void
2872,BLOCK,-1,,"{
		appender->doAppend(event, p);
		numberAppended++;
	}",2,,78,3,,void
2886,BLOCK,-1,,"{
	std::lock_guard<std::mutex> lock( m_priv->m_mutex );
	return m_priv->appenderList;
}",1,,87,1,,void
2907,BLOCK,-1,,"{
	if (name.empty())
	{
		return 0;
	}

	std::lock_guard<std::mutex> lock( m_priv->m_mutex );
	AppenderList::const_iterator it, itEnd = m_priv->appenderList.end();
	AppenderPtr appender;

	for (it = m_priv->appenderList.begin(); it != itEnd; it++)
	{
		appender = *it;

		if (name == appender->getName())
		{
			return appender;
		}
	}

	return 0;
}",1,,93,2,,void
2913,BLOCK,-1,,"{
		return 0;
	}",2,,95,2,,void
2940,BLOCK,-1,,<empty>,2,,103,1,,void
2954,BLOCK,4,,"{
		appender = *it;

		if (name == appender->getName())
		{
			return appender;
		}
	}",2,,104,4,,void
2966,BLOCK,-1,,"{
			return appender;
		}",3,,108,2,,void
2975,BLOCK,-1,,"{
	if (appender == 0)
	{
		return false;
	}

	std::lock_guard<std::mutex> lock( m_priv->m_mutex );
	AppenderList::const_iterator it = std::find(
			m_priv->appenderList.begin(), m_priv->appenderList.end(), appender);

	return it != m_priv->appenderList.end();
}",1,,117,2,,void
2980,BLOCK,-1,,"{
		return false;
	}",2,,119,2,,void
3027,BLOCK,-1,,"{
	std::lock_guard<std::mutex> lock( m_priv->m_mutex );
	AppenderList::iterator it, itEnd = m_priv->appenderList.end();
	AppenderPtr a;

	for (it = m_priv->appenderList.begin(); it != itEnd; it++)
	{
		a = *it;
		a->close();
	}

	m_priv->appenderList.clear();
}",1,,131,1,,void
3052,BLOCK,-1,,<empty>,2,,136,1,,void
3066,BLOCK,4,,"{
		a = *it;
		a->close();
	}",2,,137,4,,void
3085,BLOCK,-1,,"{
	if (appender == 0)
	{
		return;
	}

	std::lock_guard<std::mutex> lock( m_priv->m_mutex );
	AppenderList::iterator it = std::find(
			m_priv->appenderList.begin(), m_priv->appenderList.end(), appender);

	if (it != m_priv->appenderList.end())
	{
		m_priv->appenderList.erase(it);
	}
}",1,,146,2,,void
3090,BLOCK,-1,,"{
		return;
	}",2,,148,2,,void
3133,BLOCK,-1,,"{
		m_priv->appenderList.erase(it);
	}",2,,157,2,,void
3145,BLOCK,-1,,"{
	if (name.empty())
	{
		return;
	}

	std::lock_guard<std::mutex> lock( m_priv->m_mutex );
	AppenderList::iterator it, itEnd = m_priv->appenderList.end();
	AppenderPtr appender;

	for (it = m_priv->appenderList.begin(); it != itEnd; it++)
	{
		appender = *it;

		if (name == appender->getName())
		{
			m_priv->appenderList.erase(it);
			return;
		}
	}
}",1,,163,2,,void
3151,BLOCK,-1,,"{
		return;
	}",2,,165,2,,void
3177,BLOCK,-1,,<empty>,2,,173,1,,void
3191,BLOCK,4,,"{
		appender = *it;

		if (name == appender->getName())
		{
			m_priv->appenderList.erase(it);
			return;
		}
	}",2,,174,4,,void
3203,BLOCK,-1,,"{
			m_priv->appenderList.erase(it);
			return;
		}",3,,178,2,,void
3234,BLOCK,-1,,<empty>,1,,1,1,,ANY
3239,BLOCK,-1,,"{

}",1,,35,2,,void
3243,BLOCK,-1,,"{

}",1,,41,1,,void
3248,BLOCK,-1,,"{

}",1,,47,2,,void
3252,BLOCK,-1,,<empty>,39,,51,1,,void
3256,BLOCK,-1,,"{
	// An appender might be closed then garbage collected. There is no
	// point in closing twice.
	if (m_priv->closed)
	{
		return;
	}

	close();
}",1,,54,1,,void
3261,BLOCK,-1,,"{
		return;
	}",2,,58,2,,void
3268,BLOCK,-1,,"{
	std::lock_guard<std::recursive_mutex> lock(m_priv->mutex);

	if (m_priv->headFilter == nullptr)
	{
		m_priv->headFilter = m_priv->tailFilter = newFilter;
	}
	else
	{
		m_priv->tailFilter->setNext(newFilter);
		m_priv->tailFilter = newFilter;
	}
}",1,,66,2,,void
3287,BLOCK,-1,,"{
		m_priv->headFilter = m_priv->tailFilter = newFilter;
	}",2,,70,2,,void
3298,BLOCK,-1,,"{
		m_priv->tailFilter->setNext(newFilter);
		m_priv->tailFilter = newFilter;
	}",2,,74,1,,void
3314,BLOCK,-1,,"{
	std::lock_guard<std::recursive_mutex> lock(m_priv->mutex);
	m_priv->headFilter = m_priv->tailFilter = nullptr;
}",1,,81,1,,void
3340,BLOCK,-1,,"{
	return ((level == 0) || level->isGreaterOrEqual(m_priv->threshold));
}",1,,87,2,,void
3358,BLOCK,-1,,"{
	std::lock_guard<std::recursive_mutex> lock(m_priv->mutex);

	doAppendImpl(event, pool1);
}",1,,92,3,,void
3379,BLOCK,-1,,"{
	if (m_priv->closed)
	{
		LogLog::error(((LogString) LOG4CXX_STR(""Attempted to append to closed appender named [""))
			+ m_priv->name + LOG4CXX_STR(""].""));
		return;
	}

	if (!isAsSevereAsThreshold(event->getLevel()))
	{
		return;
	}

	FilterPtr f = m_priv->headFilter;


	while (f != 0)
	{
		switch (f->decide(event))
		{
			case Filter::DENY:
				return;

			case Filter::ACCEPT:
				f = nullptr;
				break;

			case Filter::NEUTRAL:
				f = f->getNext();
		}
	}

	append(event, pool1);
}",1,,99,3,,void
3384,BLOCK,-1,,"{
		LogLog::error(((LogString) LOG4CXX_STR(""Attempted to append to closed appender named [""))
			+ m_priv->name + LOG4CXX_STR(""].""));
		return;
	}",2,,101,2,,void
3408,BLOCK,-1,,"{
		return;
	}",2,,108,2,,void
3420,BLOCK,-1,,"{
		switch (f->decide(event))
		{
			case Filter::DENY:
				return;

			case Filter::ACCEPT:
				f = nullptr;
				break;

			case Filter::NEUTRAL:
				f = f->getNext();
		}
	}",2,,116,2,,void
3427,BLOCK,-1,,"{
			case Filter::DENY:
				return;

			case Filter::ACCEPT:
				f = nullptr;
				break;

			case Filter::NEUTRAL:
				f = f->getNext();
		}",3,,118,2,,void
3458,BLOCK,-1,,"{
	std::lock_guard<std::recursive_mutex> lock(m_priv->mutex);

	if (errorHandler1 == nullptr)
	{
		// We do not throw exception here since the cause is probably a
		// bad config file.
		LogLog::warn(LOG4CXX_STR(""You have tried to set a null error-handler.""));
	}
	else
	{
		m_priv->errorHandler = errorHandler1;
	}
}",1,,135,2,,void
3475,BLOCK,-1,,"{
		// We do not throw exception here since the cause is probably a
		// bad config file.
		LogLog::warn(LOG4CXX_STR(""You have tried to set a null error-handler.""));
	}",2,,139,2,,void
3483,BLOCK,-1,,"{
		m_priv->errorHandler = errorHandler1;
	}",2,,145,1,,void
3493,BLOCK,-1,,"{
	std::lock_guard<std::recursive_mutex> lock(m_priv->mutex);
	m_priv->threshold = threshold1;
}",1,,151,2,,void
3516,BLOCK,-1,,"{
	if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""THRESHOLD""), LOG4CXX_STR(""threshold"")))
	{
		setThreshold(Level::toLevelLS(value));
	}
}",1,,158,3,,void
3527,BLOCK,-1,,"{
		setThreshold(Level::toLevelLS(value));
	}",2,,161,2,,void
3537,BLOCK,-1,,"{
	return m_priv->errorHandler;
}",1,,167,1,,void
3545,BLOCK,-1,,"{
	return m_priv->headFilter;
}",1,,172,1,,void
3553,BLOCK,-1,,"{
	return m_priv->headFilter;
}",1,,177,1,,void
3561,BLOCK,-1,,"{
	return m_priv->layout;
}",1,,182,1,,void
3569,BLOCK,-1,,"{
	return m_priv->name;
}",1,,187,1,,void
3577,BLOCK,-1,,"{
	return m_priv->threshold;
}",1,,192,1,,void
3586,BLOCK,-1,,"{
	m_priv->layout = layout1;
}",1,,197,2,,void
3596,BLOCK,-1,,"{
	m_priv->name.assign(name1);
}",1,,202,2,,void
3618,BLOCK,-1,,<empty>,1,,1,1,,ANY
3623,BLOCK,-1,,<empty>,2,,34,1,,void
3628,BLOCK,-1,,<empty>,2,,39,2,,void
3634,BLOCK,-1,,<empty>,2,,44,3,,void
3640,BLOCK,-1,,"{
	init();
}",59,,54,1,,void
3646,BLOCK,-1,,"{
	init();
}",63,,59,2,,void
3653,BLOCK,-1,,"{
	init();
}",70,,64,3,,void
3658,BLOCK,-1,,"{
	apr_socket_t* newSocket;
	apr_status_t status =
		apr_socket_create(&newSocket, APR_INET, SOCK_DGRAM,
			APR_PROTO_UDP, _priv->socketPool.getAPRPool());
	_priv->socket = newSocket;

	if (status != APR_SUCCESS)
	{
		throw SocketException(status);
	}
}",1,,69,1,,void
3670,BLOCK,1,,<empty>,,,,1,,void
3684,BLOCK,1,,<empty>,,,,1,,void
3698,BLOCK,-1,,"{
		throw SocketException(status);
	}",2,,77,2,,void
3706,BLOCK,-1,,"{
	Pool addrPool;

	// Create the address from which to receive the datagram packet
	LOG4CXX_ENCODE_CHAR(hostAddr, p->getAddress()->getHostAddress());
	apr_sockaddr_t* addr;
	apr_status_t status =
		apr_sockaddr_info_get(&addr, hostAddr.c_str(), APR_INET,
			p->getPort(), 0, addrPool.getAPRPool());

	if (status != APR_SUCCESS)
	{
		throw SocketException(status);
	}

	// receive the datagram packet
	apr_size_t len = p->getLength();
	status = apr_socket_recvfrom(addr, _priv->socket, 0,
			(char*)p->getData(), &len);

	if (status != APR_SUCCESS)
	{
		throw IOException(status);
	}
}",1,,83,2,,void
3742,BLOCK,-1,,"{
		throw SocketException(status);
	}",2,,94,2,,void
3758,BLOCK,1,,<empty>,,,,1,,void
3780,BLOCK,-1,,"{
		throw IOException(status);
	}",2,,104,2,,void
3788,BLOCK,-1,,"{
	Pool addrPool;

	// create the adress to which to send the datagram packet
	LOG4CXX_ENCODE_CHAR(hostAddr, p->getAddress()->getHostAddress());
	apr_sockaddr_t* addr;
	apr_status_t status =
		apr_sockaddr_info_get(&addr, hostAddr.c_str(), APR_INET, p->getPort(),
			0, addrPool.getAPRPool());

	if (status != APR_SUCCESS)
	{
		throw SocketException(status);
	}

	// send the datagram packet
	apr_size_t len = p->getLength();
	status = apr_socket_sendto(_priv->socket, addr, 0,
			(char*)p->getData(), &len);

	if (status != APR_SUCCESS)
	{
		throw IOException(status);
	}
}",1,,110,2,,void
3824,BLOCK,-1,,"{
		throw SocketException(status);
	}",2,,121,2,,void
3839,BLOCK,1,,<empty>,,,,1,,void
3862,BLOCK,-1,,"{
		throw IOException(status);
	}",2,,131,2,,void
3869,BLOCK,-1,,"{
	if (_priv->socket != 0)
	{
		apr_status_t status = apr_socket_close(_priv->socket);

		if (status != APR_SUCCESS)
		{
			throw SocketException(status);
		}

		_priv->socket = 0;
		_priv->localPort = 0;
	}
}",32,,136,1,,void
3873,BLOCK,1,,<empty>,,,,1,,void
3883,BLOCK,-1,,"{
		apr_status_t status = apr_socket_close(_priv->socket);

		if (status != APR_SUCCESS)
		{
			throw SocketException(status);
		}

		_priv->socket = 0;
		_priv->localPort = 0;
	}",2,,138,2,,void
3889,BLOCK,1,,<empty>,,,,1,,void
3902,BLOCK,-1,,"{
			throw SocketException(status);
		}",3,,142,2,,void
3908,BLOCK,1,,<empty>,,,,1,,void
3920,BLOCK,1,,<empty>,,,,1,,void
3935,BLOCK,-1,,"{
	Pool addrPool;

	// Create server socket address (including port number)
	LOG4CXX_ENCODE_CHAR(hostAddr, localAddress1->getHostAddress());
	apr_sockaddr_t* server_addr;
	apr_status_t status =
		apr_sockaddr_info_get(&server_addr, hostAddr.c_str(), APR_INET,
			localPort1, 0, addrPool.getAPRPool());

	if (status != APR_SUCCESS)
	{
		throw BindException(status);
	}

	// bind the socket to the address
	status = apr_socket_bind(_priv->socket, server_addr);

	if (status != APR_SUCCESS)
	{
		throw BindException(status);
	}

	m_priv->localPort = localPort1;
	m_priv->localAddress = localAddress1;
}",1,,152,3,,void
3965,BLOCK,-1,,"{
		throw BindException(status);
	}",2,,163,2,,void
3973,BLOCK,1,,<empty>,,,,1,,void
3987,BLOCK,-1,,"{
		throw BindException(status);
	}",2,,171,2,,void
4006,BLOCK,-1,,"{
	m_priv->address = address1;
	m_priv->port = port1;

	Pool addrPool;

	// create socket address
	LOG4CXX_ENCODE_CHAR(hostAddr, address1->getHostAddress());
	apr_sockaddr_t* client_addr;
	apr_status_t status =
		apr_sockaddr_info_get(&client_addr, hostAddr.c_str(), APR_INET,
			m_priv->port, 0, addrPool.getAPRPool());

	if (status != APR_SUCCESS)
	{
		throw ConnectException(status);
	}

	// connect the socket
	status = apr_socket_connect(_priv->socket, client_addr);

	if (status != APR_SUCCESS)
	{
		throw ConnectException(status);
	}
}",1,,181,3,,void
4048,BLOCK,-1,,"{
		throw ConnectException(status);
	}",2,,195,2,,void
4056,BLOCK,1,,<empty>,,,,1,,void
4070,BLOCK,-1,,"{
		throw ConnectException(status);
	}",2,,203,2,,void
4077,BLOCK,-1,,"{
	return _priv->socket != nullptr;
}",1,,210,1,,void
4081,BLOCK,1,,<empty>,,,,1,,void
4113,BLOCK,-1,,<empty>,1,,1,1,,ANY
4120,BLOCK,-1,,"{

	}",12,,38,1,,void
4132,BLOCK,-1,,"{
	delete ((ThreadSpecificData*) ptr);
}",1,,53,2,,void
4141,BLOCK,-1,,"{
	return tlsDestructImpl(ptr);
}",1,,60,2,,void
4150,BLOCK,-1,,"{
        apr_initialize();
    }",5,,71,1,,void
4155,BLOCK,-1,,"{
        apr_terminate();
    }",5,,75,1,,void
4160,BLOCK,-1,,"{
	apr_pool_create(&m_priv->p, NULL);
	m_priv->startTime = Date::currentTime();
#if APR_HAS_THREADS
	apr_status_t stat = apr_threadkey_private_create(&m_priv->tlsKey, tlsDestructImpl, m_priv->p);
	assert(stat == APR_SUCCESS);
#endif
}",1,,85,1,,void
4178,BLOCK,-1,,"{
	stopWatchDogs();
	isDestructed = true;
#if APR_HAS_THREADS
	std::unique_lock<std::mutex> lock(m_priv->mutex);
	apr_threadkey_private_delete(m_priv->tlsKey);
#endif
}",1,,95,1,,void
4186,BLOCK,-1,,"{
	std::unique_lock<std::mutex> lock(m_priv->mutex);

	while (!m_priv->watchdogs.empty())
	{
		m_priv->watchdogs.back()->stop();
		delete m_priv->watchdogs.back();
		m_priv->watchdogs.pop_back();
	}
}",1,,105,1,,void
4207,BLOCK,-1,,"{
		m_priv->watchdogs.back()->stop();
		delete m_priv->watchdogs.back();
		m_priv->watchdogs.pop_back();
	}",2,,109,2,,void
4233,BLOCK,-1,,"{
	getInstance().stopWatchDogs();
}",1,,117,1,,void
4241,BLOCK,-1,,"{
	static WideLife<apr_environment> env;
	static WideLife<APRInitializer> init;
	return init;
}",1,,122,1,,void
4249,BLOCK,-1,,"{
	return getInstance().m_priv->startTime;
}",1,,130,1,,void
4259,BLOCK,-1,,"{
	return getInstance().m_priv->p;
}",1,,135,1,,void
4269,BLOCK,-1,,"{
	return getInstance().m_priv->tlsKey;
}",1,,140,1,,void
4280,BLOCK,-1,,"{
	APRInitializer& instance(getInstance());
	std::unique_lock<std::mutex> lock(instance.m_priv->mutex);
	instance.m_priv->watchdogs.push_back(watchdog);
}",1,,145,2,,void
4311,BLOCK,-1,,"{
	APRInitializer& instance(getInstance());
	std::unique_lock<std::mutex> lock(instance.m_priv->mutex);

	for (std::list<FileWatchdog*>::iterator iter = instance.m_priv->watchdogs.begin();
		iter != instance.m_priv->watchdogs.end();
		iter++)
	{
		if (*iter == watchdog)
		{
			instance.m_priv->watchdogs.erase(iter);
			return;
		}
	}
}",1,,152,2,,void
4330,BLOCK,-1,,<empty>,2,,156,1,,void
4354,BLOCK,4,,"{
		if (*iter == watchdog)
		{
			instance.m_priv->watchdogs.erase(iter);
			return;
		}
	}",2,,159,4,,void
4360,BLOCK,-1,,"{
			instance.m_priv->watchdogs.erase(iter);
			return;
		}",3,,161,2,,void
4376,BLOCK,-1,,"{
	std::unique_lock<std::mutex> lock(m_priv->mutex);
	m_priv->objects[key] = pObject;
}",1,,169,3,,void
4401,BLOCK,-1,,"{
	std::unique_lock<std::mutex> lock(m_priv->mutex);
	auto pItem = m_priv->objects.find(key);
	if (m_priv->objects.end() == pItem)
		pItem = m_priv->objects.emplace(key, creator()).first;
	return pItem->second;
}",1,,175,3,,void
4433,BLOCK,-1,,<empty>,3,,179,2,,void
4468,BLOCK,-1,,<empty>,1,,1,1,,ANY
4477,BLOCK,-1,,"{
	apr_status_t status =
		apr_socket_create(&_priv->socket, APR_INET, SOCK_STREAM,
			APR_PROTO_TCP, _priv->pool.getAPRPool());

	if (status != APR_SUCCESS)
	{
		throw SocketException(status);
	}

	status = apr_socket_opt_set(_priv->socket, APR_SO_NONBLOCK, 1);

	if (status != APR_SUCCESS)
	{
		throw SocketException(status);
	}

	// Create server socket address (including port number)
	apr_sockaddr_t* server_addr;
	status =
		apr_sockaddr_info_get(&server_addr, NULL, APR_INET,
			port, 0, _priv->pool.getAPRPool());

	if (status != APR_SUCCESS)
	{
		throw ConnectException(status);
	}

	// bind the socket to the address
	status = apr_socket_bind(_priv->socket, server_addr);

	if (status != APR_SUCCESS)
	{
		throw BindException(status);
	}


	status = apr_socket_listen(_priv->socket, 50);

	if (status != APR_SUCCESS)
	{
		throw SocketException(status);
	}
}",55,,39,2,,void
4484,BLOCK,1,,<empty>,,,,1,,void
4497,BLOCK,1,,<empty>,,,,1,,void
4513,BLOCK,-1,,"{
		throw SocketException(status);
	}",2,,45,2,,void
4521,BLOCK,1,,<empty>,,,,1,,void
4536,BLOCK,-1,,"{
		throw SocketException(status);
	}",2,,52,2,,void
4551,BLOCK,1,,<empty>,,,,1,,void
4567,BLOCK,-1,,"{
		throw ConnectException(status);
	}",2,,63,2,,void
4575,BLOCK,1,,<empty>,,,,1,,void
4589,BLOCK,-1,,"{
		throw BindException(status);
	}",2,,71,2,,void
4597,BLOCK,1,,<empty>,,,,1,,void
4611,BLOCK,-1,,"{
		throw SocketException(status);
	}",2,,79,2,,void
4618,BLOCK,-1,,"{
	std::unique_lock<std::mutex> lock(_priv->mutex);

	if (_priv->socket != 0)
	{
		apr_status_t status = apr_socket_close(_priv->socket);

		if (status != APR_SUCCESS)
		{
			throw SocketException(status);
		}

		_priv->socket = 0;
	}
}",30,,84,1,,void
4629,BLOCK,1,,<empty>,,,,1,,void
4641,BLOCK,1,,<empty>,,,,1,,void
4651,BLOCK,-1,,"{
		apr_status_t status = apr_socket_close(_priv->socket);

		if (status != APR_SUCCESS)
		{
			throw SocketException(status);
		}

		_priv->socket = 0;
	}",2,,88,2,,void
4657,BLOCK,1,,<empty>,,,,1,,void
4670,BLOCK,-1,,"{
			throw SocketException(status);
		}",3,,92,2,,void
4676,BLOCK,1,,<empty>,,,,1,,void
4689,BLOCK,-1,,"{
	std::unique_lock<std::mutex> lock(_priv->mutex);

	if (_priv->socket == 0)
	{
		throw IOException();
	}

	apr_pollfd_t poll;
	poll.p = _priv->pool.getAPRPool();
	poll.desc_type = APR_POLL_SOCKET;
	poll.reqevents = APR_POLLIN;
	poll.rtnevents = 0;
	poll.desc.s = _priv->socket;
	poll.client_data = NULL;

	apr_int32_t signaled;
	apr_interval_time_t to = _priv->timeout * 1000;
	apr_status_t status = apr_poll(&poll, 1, &signaled, to);

	if (APR_STATUS_IS_TIMEUP(status))
	{
		throw SocketTimeoutException();
	}
	else if (status != APR_SUCCESS)
	{
		throw SocketException(status);
	}

	apr_pool_t* newPool;
	status = apr_pool_create(&newPool, 0);

	if (status != APR_SUCCESS)
	{
		throw PoolException(status);
	}

	apr_socket_t* newSocket;
	status = apr_socket_accept(&newSocket, _priv->socket, newPool);

	if (status != APR_SUCCESS)
	{
		apr_pool_destroy(newPool);
		throw SocketException(status);
	}

	status = apr_socket_opt_set(newSocket, APR_SO_NONBLOCK, 0);

	if (status != APR_SUCCESS)
	{
...",1,,105,1,,void
4700,BLOCK,1,,<empty>,,,,1,,void
4712,BLOCK,1,,<empty>,,,,1,,void
4722,BLOCK,-1,,"{
		throw IOException();
	}",2,,109,2,,void
4731,BLOCK,1,,<empty>,,,,1,,void
4765,BLOCK,1,,<empty>,,,,1,,void
4785,BLOCK,1,,<empty>,,,,1,,void
4808,BLOCK,-1,,"{
		throw SocketTimeoutException();
	}",2,,126,2,,void
4812,BLOCK,-1,,<empty>,7,,129,1,,void
4817,BLOCK,-1,,"{
		throw SocketException(status);
	}",2,,130,2,,void
4832,BLOCK,-1,,"{
		throw PoolException(status);
	}",2,,138,2,,void
4843,BLOCK,1,,<empty>,,,,1,,void
4857,BLOCK,-1,,"{
		apr_pool_destroy(newPool);
		throw SocketException(status);
	}",2,,146,2,,void
4873,BLOCK,-1,,"{
		apr_pool_destroy(newPool);
		throw SocketException(status);
	}",2,,154,2,,void
4908,BLOCK,-1,,<empty>,1,,1,1,,ANY
4915,BLOCK,-1,,<empty>,2,,35,3,,void
4921,BLOCK,-1,,<empty>,2,,40,3,,void
4929,BLOCK,-1,,"{
	apr_status_t status =
		apr_socket_create(&_priv->socket, APR_INET, SOCK_STREAM,
			APR_PROTO_TCP, _priv->pool.getAPRPool());

	if (status != APR_SUCCESS)
	{
		throw SocketException(status);
	}

	LOG4CXX_ENCODE_CHAR(host, address->getHostAddress());

	// create socket address (including port)
	apr_sockaddr_t* client_addr;
	status =
		apr_sockaddr_info_get(&client_addr, host.c_str(), APR_INET,
			port, 0, _priv->pool.getAPRPool());

	if (status != APR_SUCCESS)
	{
		throw ConnectException(status);
	}

	// connect the socket
	status =  apr_socket_connect(_priv->socket, client_addr);

	if (status != APR_SUCCESS)
	{
		throw ConnectException(status);
	}
}",56,,49,3,,void
4936,BLOCK,1,,<empty>,,,,1,,void
4949,BLOCK,1,,<empty>,,,,1,,void
4965,BLOCK,-1,,"{
		throw SocketException(status);
	}",2,,55,2,,void
4989,BLOCK,1,,<empty>,,,,1,,void
5005,BLOCK,-1,,"{
		throw ConnectException(status);
	}",2,,68,2,,void
5013,BLOCK,1,,<empty>,,,,1,,void
5027,BLOCK,-1,,"{
		throw ConnectException(status);
	}",2,,76,2,,void
5036,BLOCK,-1,,"{
	apr_sockaddr_t* sa;
	apr_status_t status = apr_socket_addr_get(&sa, APR_REMOTE, s);

	if (status == APR_SUCCESS)
	{
		_priv->port = sa->port;
		LogString remotename;
		LogString remoteip;

		if (sa->hostname != NULL)
		{
			Transcoder::decode(sa->hostname, remotename);
		}

		char* buf = 0;
		status = apr_sockaddr_ip_get(&buf, sa);

		if (status == APR_SUCCESS)
		{
			Transcoder::decode(buf, remoteip);
		}

		_priv->address = std::make_shared<InetAddress>(remotename, remoteip);
	}
}",50,,82,3,,void
5050,BLOCK,-1,,"{
		_priv->port = sa->port;
		LogString remotename;
		LogString remoteip;

		if (sa->hostname != NULL)
		{
			Transcoder::decode(sa->hostname, remotename);
		}

		char* buf = 0;
		status = apr_sockaddr_ip_get(&buf, sa);

		if (status == APR_SUCCESS)
		{
			Transcoder::decode(buf, remoteip);
		}

		_priv->address = std::make_shared<InetAddress>(remotename, remoteip);
	}",2,,87,2,,void
5053,BLOCK,1,,<empty>,,,,1,,void
5073,BLOCK,-1,,"{
			Transcoder::decode(sa->hostname, remotename);
		}",3,,93,2,,void
5096,BLOCK,-1,,"{
			Transcoder::decode(buf, remoteip);
		}",3,,101,2,,void
5105,BLOCK,1,,<empty>,,,,1,,void
5128,BLOCK,-1,,"{
	if (_priv->socket == 0)
	{
		throw ClosedChannelException();
	}

	size_t totalWritten = 0;

	while (buf.remaining() > 0)
	{
		apr_size_t written = buf.remaining();

		// while writing to the socket, we need to ignore the SIGPIPE
		// signal. Otherwise, when the client has closed the connection,
		// the send() function would not return an error but call the
		// SIGPIPE handler.
#if APR_HAVE_SIGACTION
		apr_sigfunc_t* old = apr_signal(SIGPIPE, SIG_IGN);
		apr_status_t status = apr_socket_send(_priv->socket, buf.current(), &written);
		apr_signal(SIGPIPE, old);
#else
		apr_status_t status = apr_socket_send(_priv->socket, buf.current(), &written);
#endif

		buf.position(buf.position() + written);
		totalWritten += written;

		if (status != APR_SUCCESS)
		{
			throw SocketException(status);
		}
	}

	return totalWritten;
}",1,,110,2,,void
5132,BLOCK,1,,<empty>,,,,1,,void
5142,BLOCK,-1,,"{
		throw ClosedChannelException();
	}",2,,112,2,,void
5156,BLOCK,-1,,"{
		apr_size_t written = buf.remaining();

		// while writing to the socket, we need to ignore the SIGPIPE
		// signal. Otherwise, when the client has closed the connection,
		// the send() function would not return an error but call the
		// SIGPIPE handler.
#if APR_HAVE_SIGACTION
		apr_sigfunc_t* old = apr_signal(SIGPIPE, SIG_IGN);
		apr_status_t status = apr_socket_send(_priv->socket, buf.current(), &written);
		apr_signal(SIGPIPE, old);
#else
		apr_status_t status = apr_socket_send(_priv->socket, buf.current(), &written);
#endif

		buf.position(buf.position() + written);
		totalWritten += written;

		if (status != APR_SUCCESS)
		{
			throw SocketException(status);
		}
	}",2,,119,2,,void
5169,BLOCK,1,,<empty>,,,,1,,void
5201,BLOCK,-1,,"{
			throw SocketException(status);
		}",3,,138,2,,void
5210,BLOCK,-1,,"{
	if (_priv->socket != 0)
	{
		apr_status_t status = apr_socket_close(_priv->socket);

		if (status != APR_SUCCESS)
		{
			throw SocketException(status);
		}

		_priv->socket = 0;
	}
}",1,,148,1,,void
5214,BLOCK,1,,<empty>,,,,1,,void
5224,BLOCK,-1,,"{
		apr_status_t status = apr_socket_close(_priv->socket);

		if (status != APR_SUCCESS)
		{
			throw SocketException(status);
		}

		_priv->socket = 0;
	}",2,,150,2,,void
5230,BLOCK,1,,<empty>,,,,1,,void
5243,BLOCK,-1,,"{
			throw SocketException(status);
		}",3,,154,2,,void
5249,BLOCK,1,,<empty>,,,,1,,void
5263,BLOCK,-1,,"{
				return priv->buffer.empty();
			}",4,,272,1,,void
5266,BLOCK,1,,<empty>,,,,1,,void
5283,BLOCK,-1,,{ return 0 < priv->buffer.size() || priv->closed; },5,,472,1,,void
5289,BLOCK,1,,<empty>,,,,1,,void
5302,BLOCK,1,,<empty>,,,,1,,void
5336,BLOCK,-1,,<empty>,1,,1,1,,ANY
5340,BLOCK,-1,,<empty>,,,,1,,<empty>
5351,BLOCK,-1,,<empty>,,,,2,,<empty>
5356,BLOCK,-1,,<empty>,,,,2,,<empty>
5361,BLOCK,-1,,<empty>,,,,2,,<empty>
5366,BLOCK,-1,,<empty>,,,,2,,<empty>
5371,BLOCK,-1,,<empty>,,,,2,,<empty>
5377,BLOCK,-1,,<empty>,,,,3,,<empty>
5383,BLOCK,-1,,"{
	}",2,,112,1,,void
5387,BLOCK,-1,,"{
		std::unique_lock<std::mutex> lock(bufferMutex);
		bufferNotFull.wait(lock, [this]() -> bool
			{ return buffer.empty() || closed; }
		);
	}",2,,117,1,,void
5404,BLOCK,-1,,"{
}",1,,180,1,,void
5408,BLOCK,-1,,"{
	finalize();
}",1,,184,1,,void
5414,BLOCK,-1,,"{
	priv->appenders->addAppender(newAppender);
}",1,,189,2,,void
5416,BLOCK,1,,<empty>,,,,1,,void
5434,BLOCK,-1,,"{
	if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""LOCATIONINFO""), LOG4CXX_STR(""locationinfo"")))
	{
		setLocationInfo(OptionConverter::toBoolean(value, false));
	}

	if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""BUFFERSIZE""), LOG4CXX_STR(""buffersize"")))
	{
		setBufferSize(OptionConverter::toInt(value, DEFAULT_BUFFER_SIZE));
	}

	if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""BLOCKING""), LOG4CXX_STR(""blocking"")))
	{
		setBlocking(OptionConverter::toBoolean(value, true));
	}
	else
	{
		AppenderSkeleton::setOption(option, value);
	}
}",1,,196,3,,void
5445,BLOCK,-1,,"{
		setLocationInfo(OptionConverter::toBoolean(value, false));
	}",2,,198,2,,void
5463,BLOCK,-1,,"{
		setBufferSize(OptionConverter::toInt(value, DEFAULT_BUFFER_SIZE));
	}",2,,203,2,,void
5481,BLOCK,-1,,"{
		setBlocking(OptionConverter::toBoolean(value, true));
	}",2,,208,2,,void
5490,BLOCK,-1,,"{
		AppenderSkeleton::setOption(option, value);
	}",2,,212,1,,void
5502,BLOCK,-1,,"{
	doAppendImpl(event, pool1);
}",1,,219,3,,void
5511,BLOCK,-1,,"{
	if (priv->bufferSize <= 0)
	{
		priv->appenders->appendLoopOnAppenders(event, p);
	}

	// Set the NDC and MDC for the calling thread as these
	// LoggingEvent fields were not set at event creation time.
	LogString ndcVal;
	event->getNDC(ndcVal);
	// Get a copy of this thread's MDC.
	event->getMDCCopy();

	std::unique_lock<std::mutex> lock(priv->bufferMutex);
	if (!priv->dispatcher.joinable())
	{
		priv->dispatcher = ThreadUtility::instance()->createThread( LOG4CXX_STR(""AsyncAppender""), &AsyncAppender::dispatch, this );
	}
	while (true)
	{
		size_t previousSize = priv->buffer.size();

		if (previousSize < (size_t)priv->bufferSize)
		{
			priv->buffer.push_back(event);

			if (previousSize == 0)
			{
				priv->bufferNotEmpty.notify_all();
			}

			break;
		}

		//
		//   Following code is only reachable if buffer is full
		//
		//
		//   if blocking and thread is not already interrupted
		//      and not the dispatcher then
		//      wait for a buffer notification
		bool discard = ...",1,,224,3,,void
5515,BLOCK,1,,<empty>,,,,1,,void
5525,BLOCK,-1,,"{
		priv->appenders->appendLoopOnAppenders(event, p);
	}",2,,226,2,,void
5527,BLOCK,1,,<empty>,,,,1,,void
5561,BLOCK,1,,<empty>,,,,1,,void
5573,BLOCK,1,,<empty>,,,,1,,void
5585,BLOCK,-1,,"{
		priv->dispatcher = ThreadUtility::instance()->createThread( LOG4CXX_STR(""AsyncAppender""), &AsyncAppender::dispatch, this );
	}",2,,239,2,,void
5588,BLOCK,1,,<empty>,,,,1,,void
5613,BLOCK,-1,,"{
		size_t previousSize = priv->buffer.size();

		if (previousSize < (size_t)priv->bufferSize)
		{
			priv->buffer.push_back(event);

			if (previousSize == 0)
			{
				priv->bufferNotEmpty.notify_all();
			}

			break;
		}

		//
		//   Following code is only reachable if buffer is full
		//
		//
		//   if blocking and thread is not already interrupted
		//      and not the dispatcher then
		//      wait for a buffer notification
		bool discard = true;

		if (priv->blocking
			&& !priv->closed
			&& (priv->dispatcher.get_id() != std::this_thread::get_id()) )
		{
			priv->bufferNotFull.wait(lock, [this]()
			{
				return priv->buffer.empty();
			});
			discard = false;
		}

		//
		//   if blocking is false or thread has been interrupted
		//   add event to discard map.
		//
		if (discard)
		{
			LogString loggerName = event->getLoggerName();
			DiscardMap::iterator iter = priv->discardMap.find(loggerName);

			if (iter == priv->discardMap.end())
			{
				DiscardSummary summary(event)...",2,,243,2,,void
5618,BLOCK,1,,<empty>,,,,1,,void
5636,BLOCK,1,,<empty>,,,,1,,void
5645,BLOCK,-1,,"{
			priv->buffer.push_back(event);

			if (previousSize == 0)
			{
				priv->bufferNotEmpty.notify_all();
			}

			break;
		}",3,,247,2,,void
5647,BLOCK,1,,<empty>,,,,1,,void
5664,BLOCK,-1,,"{
				priv->bufferNotEmpty.notify_all();
			}",4,,251,2,,void
5666,BLOCK,1,,<empty>,,,,1,,void
5687,BLOCK,1,,<empty>,,,,1,,void
5698,BLOCK,1,,<empty>,,,,1,,void
5709,BLOCK,1,,<empty>,,,,1,,void
5727,BLOCK,-1,,"{
			priv->bufferNotFull.wait(lock, [this]()
			{
				return priv->buffer.empty();
			});
			discard = false;
		}",3,,270,2,,void
5746,BLOCK,-1,,"{
			LogString loggerName = event->getLoggerName();
			DiscardMap::iterator iter = priv->discardMap.find(loggerName);

			if (iter == priv->discardMap.end())
			{
				DiscardSummary summary(event);
				priv->discardMap.insert(DiscardMap::value_type(loggerName, summary));
			}
			else
			{
				(*iter).second.add(event);
			}

			break;
		}",3,,283,2,,void
5758,BLOCK,1,,<empty>,,,,2,,void
5775,BLOCK,1,,<empty>,,,,1,,void
5787,BLOCK,-1,,"{
				DiscardSummary summary(event);
				priv->discardMap.insert(DiscardMap::value_type(loggerName, summary));
			}",4,,288,2,,void
5792,BLOCK,1,,<empty>,,,,3,,void
5811,BLOCK,-1,,"{
				(*iter).second.add(event);
			}",4,,293,1,,void
5824,BLOCK,-1,,"{
	{
		std::lock_guard<std::mutex> lock(priv->bufferMutex);
		priv->closed = true;
		priv->bufferNotEmpty.notify_all();
		priv->bufferNotFull.notify_all();
	}

	if ( priv->dispatcher.joinable() )
	{
		priv->dispatcher.join();
	}

	{
		AppenderList appenderList = priv->appenders->getAllAppenders();

		for (AppenderList::iterator iter = appenderList.begin();
			iter != appenderList.end();
			iter++)
		{
			(*iter)->close();
		}
	}
}",1,,303,1,,void
5825,BLOCK,1,,"{
		std::lock_guard<std::mutex> lock(priv->bufferMutex);
		priv->closed = true;
		priv->bufferNotEmpty.notify_all();
		priv->bufferNotFull.notify_all();
	}",2,,304,1,,void
5836,BLOCK,1,,<empty>,,,,1,,void
5846,BLOCK,1,,<empty>,,,,1,,void
5849,BLOCK,1,,<empty>,,,,1,,void
5860,BLOCK,1,,<empty>,,,,1,,void
5873,BLOCK,1,,<empty>,,,,1,,void
5887,BLOCK,1,,<empty>,,,,1,,void
5899,BLOCK,-1,,"{
		priv->dispatcher.join();
	}",2,,312,2,,void
5901,BLOCK,1,,<empty>,,,,1,,void
5913,BLOCK,3,,"{
		AppenderList appenderList = priv->appenders->getAllAppenders();

		for (AppenderList::iterator iter = appenderList.begin();
			iter != appenderList.end();
			iter++)
		{
			(*iter)->close();
		}
	}",2,,316,3,,void
5918,BLOCK,1,,<empty>,,,,1,,void
5931,BLOCK,-1,,<empty>,3,,319,1,,void
5947,BLOCK,4,,"{
			(*iter)->close();
		}",3,,322,4,,void
5956,BLOCK,-1,,"{
	return priv->appenders->getAllAppenders();
}",1,,329,1,,void
5959,BLOCK,1,,<empty>,,,,1,,void
5975,BLOCK,-1,,"{
	return priv->appenders->getAppender(n);
}",1,,334,2,,void
5978,BLOCK,1,,<empty>,,,,1,,void
5995,BLOCK,-1,,"{
	return priv->appenders->isAttached(appender);
}",1,,339,2,,void
5998,BLOCK,1,,<empty>,,,,1,,void
6014,BLOCK,-1,,"{
	return false;
}",1,,344,1,,void
6020,BLOCK,-1,,"{
	priv->appenders->removeAllAppenders();
}",1,,349,1,,void
6022,BLOCK,1,,<empty>,,,,1,,void
6038,BLOCK,-1,,"{
	priv->appenders->removeAppender(appender);
}",1,,354,2,,void
6040,BLOCK,1,,<empty>,,,,1,,void
6057,BLOCK,-1,,"{
	priv->appenders->removeAppender(n);
}",1,,359,2,,void
6059,BLOCK,1,,<empty>,,,,1,,void
6075,BLOCK,-1,,"{
	return priv->locationInfo;
}",1,,364,1,,void
6078,BLOCK,1,,<empty>,,,,1,,void
6091,BLOCK,-1,,"{
	priv->locationInfo = flag;
}",1,,369,2,,void
6094,BLOCK,1,,<empty>,,,,1,,void
6108,BLOCK,-1,,"{
	if (size < 0)
	{
		throw IllegalArgumentException(LOG4CXX_STR(""size argument must be non-negative""));
	}

	std::lock_guard<std::mutex> lock(priv->bufferMutex);
	priv->bufferSize = (size < 1) ? 1 : size;
	priv->bufferNotFull.notify_all();
}",1,,375,2,,void
6113,BLOCK,-1,,"{
		throw IllegalArgumentException(LOG4CXX_STR(""size argument must be non-negative""));
	}",2,,377,2,,void
6128,BLOCK,1,,<empty>,,,,1,,void
6139,BLOCK,1,,<empty>,,,,1,,void
6155,BLOCK,1,,<empty>,,,,1,,void
6170,BLOCK,-1,,"{
	return priv->bufferSize;
}",1,,387,1,,void
6173,BLOCK,1,,<empty>,,,,1,,void
6186,BLOCK,-1,,"{
	std::lock_guard<std::mutex> lock(priv->bufferMutex);
	priv->blocking = value;
	priv->bufferNotFull.notify_all();
}",1,,392,2,,void
6197,BLOCK,1,,<empty>,,,,1,,void
6208,BLOCK,1,,<empty>,,,,1,,void
6219,BLOCK,1,,<empty>,,,,1,,void
6234,BLOCK,-1,,"{
	return priv->blocking;
}",1,,399,1,,void
6237,BLOCK,1,,<empty>,,,,1,,void
6250,BLOCK,-1,,"{
}",1,,405,2,,void
6255,BLOCK,-1,,"{
}",1,,410,2,,void
6260,BLOCK,-1,,"{
	maxEvent = src.maxEvent;
	count = src.count;
	return *this;
}",1,,414,2,,void
6278,BLOCK,-1,,"{
	if (event->getLevel()->toInt() > maxEvent->getLevel()->toInt())
	{
		maxEvent = event;
	}

	count++;
}",1,,421,2,,void
6295,BLOCK,-1,,"{
		maxEvent = event;
	}",2,,423,2,,void
6305,BLOCK,-1,,"{
	LogString msg(LOG4CXX_STR(""Discarded ""));
	StringHelper::toString(count, p, msg);
	msg.append(LOG4CXX_STR("" messages due to a full event buffer including: ""));
	msg.append(maxEvent->getMessage());
	return std::make_shared<LoggingEvent>(
				maxEvent->getLoggerName(),
				maxEvent->getLevel(),
				msg,
				LocationInfo::getLocationUnavailable() );
}",1,,431,2,,void
6358,BLOCK,-1,,"{
	LogString msg(LOG4CXX_STR(""Discarded ""));
	StringHelper::toString(discardedCount, p, msg);
	msg.append(LOG4CXX_STR("" messages due to a full event buffer""));

	return std::make_shared<LoggingEvent>(
				LOG4CXX_STR(""""),
				LOG4CXX_NS::Level::getError(),
				msg,
				LocationInfo::getLocationUnavailable() );
}",1,,446,3,,void
6401,BLOCK,-1,,"{
	bool isActive = true;

	while (isActive)
	{
		//
		//   process events after lock on buffer is released.
		//
		Pool p;
		LoggingEventList events;
		{
			std::unique_lock<std::mutex> lock(priv->bufferMutex);
			priv->bufferNotEmpty.wait(lock, [this]() -> bool
				{ return 0 < priv->buffer.size() || priv->closed; }
			);
			isActive = !priv->closed;

			for (LoggingEventList::iterator eventIter = priv->buffer.begin();
				eventIter != priv->buffer.end();
				eventIter++)
			{
				events.push_back(*eventIter);
			}

			for (DiscardMap::iterator discardIter = priv->discardMap.begin();
				discardIter != priv->discardMap.end();
				discardIter++)
			{
				events.push_back(discardIter->second.createEvent(p));
			}

			priv->buffer.clear();
			priv->discardMap.clear();
			priv->bufferNotFull.notify_all();
		}

		for (LoggingEventList::iterator iter = events.begin();
			iter != events.end();
			iter++)
		{
			try
			{
				priv->appenders->appendLoopOnAppenders(*iter, p);
			}
			catch (...",1,,459,1,,void
6408,BLOCK,-1,,"{
		//
		//   process events after lock on buffer is released.
		//
		Pool p;
		LoggingEventList events;
		{
			std::unique_lock<std::mutex> lock(priv->bufferMutex);
			priv->bufferNotEmpty.wait(lock, [this]() -> bool
				{ return 0 < priv->buffer.size() || priv->closed; }
			);
			isActive = !priv->closed;

			for (LoggingEventList::iterator eventIter = priv->buffer.begin();
				eventIter != priv->buffer.end();
				eventIter++)
			{
				events.push_back(*eventIter);
			}

			for (DiscardMap::iterator discardIter = priv->discardMap.begin();
				discardIter != priv->discardMap.end();
				discardIter++)
			{
				events.push_back(discardIter->second.createEvent(p));
			}

			priv->buffer.clear();
			priv->discardMap.clear();
			priv->bufferNotFull.notify_all();
		}

		for (LoggingEventList::iterator iter = events.begin();
			iter != events.end();
			iter++)
		{
			try
			{
				priv->appenders->appendLoopOnAppenders(*iter, p);
			}
			catch (std::exception& ex)
			{
				if (isActive)
		...",2,,463,2,,void
6411,BLOCK,3,,"{
			std::unique_lock<std::mutex> lock(priv->bufferMutex);
			priv->bufferNotEmpty.wait(lock, [this]() -> bool
				{ return 0 < priv->buffer.size() || priv->closed; }
			);
			isActive = !priv->closed;

			for (LoggingEventList::iterator eventIter = priv->buffer.begin();
				eventIter != priv->buffer.end();
				eventIter++)
			{
				events.push_back(*eventIter);
			}

			for (DiscardMap::iterator discardIter = priv->discardMap.begin();
				discardIter != priv->discardMap.end();
				discardIter++)
			{
				events.push_back(discardIter->second.createEvent(p));
			}

			priv->buffer.clear();
			priv->discardMap.clear();
			priv->bufferNotFull.notify_all();
		}",3,,469,3,,void
6422,BLOCK,1,,<empty>,,,,1,,void
6448,BLOCK,1,,<empty>,,,,1,,void
6458,BLOCK,-1,,<empty>,4,,476,1,,void
6463,BLOCK,1,,<empty>,,,,1,,void
6478,BLOCK,1,,<empty>,,,,1,,void
6492,BLOCK,4,,"{
				events.push_back(*eventIter);
			}",4,,479,4,,void
6500,BLOCK,-1,,<empty>,4,,483,1,,void
6505,BLOCK,1,,<empty>,,,,1,,void
6520,BLOCK,1,,<empty>,,,,1,,void
6534,BLOCK,4,,"{
				events.push_back(discardIter->second.createEvent(p));
			}",4,,486,4,,void
6547,BLOCK,1,,<empty>,,,,1,,void
6560,BLOCK,1,,<empty>,,,,1,,void
6573,BLOCK,1,,<empty>,,,,1,,void
6586,BLOCK,-1,,<empty>,3,,495,1,,void
6602,BLOCK,4,,"{
			try
			{
				priv->appenders->appendLoopOnAppenders(*iter, p);
			}
			catch (std::exception& ex)
			{
				if (isActive)
				{
					priv->errorHandler->error(LOG4CXX_STR(""async dispatcher""), ex, 0, *iter);
					isActive = false;
				}
			}
			catch (...)
			{
				if (isActive)
				{
					priv->errorHandler->error(LOG4CXX_STR(""async dispatcher""));
					isActive = false;
				}
			}
		}",3,,498,4,,void
6604,BLOCK,-1,,"{
				priv->appenders->appendLoopOnAppenders(*iter, p);
			}",4,,500,1,,void
6606,BLOCK,1,,<empty>,,,,2,,void
6621,BLOCK,2,,"{
				if (isActive)
				{
					priv->errorHandler->error(LOG4CXX_STR(""async dispatcher""), ex, 0, *iter);
					isActive = false;
				}
			}",4,,504,2,,void
6624,BLOCK,-1,,"{
					priv->errorHandler->error(LOG4CXX_STR(""async dispatcher""), ex, 0, *iter);
					isActive = false;
				}",5,,506,2,,void
6626,BLOCK,1,,<empty>,,,,1,,void
6647,BLOCK,2,,"{
				if (isActive)
				{
					priv->errorHandler->error(LOG4CXX_STR(""async dispatcher""));
					isActive = false;
				}
			}",4,,512,2,,void
6650,BLOCK,-1,,"{
					priv->errorHandler->error(LOG4CXX_STR(""async dispatcher""));
					isActive = false;
				}",5,,514,2,,void
6652,BLOCK,1,,<empty>,,,,1,,void
6681,BLOCK,-1,,<empty>,1,,1,1,,ANY
6685,BLOCK,-1,,"{
			std::lock_guard<std::recursive_mutex> lock(mutex);
			while(!actions.empty())
			{
				std::function<void()> action = std::move(actions.begin()->second);
				actions.erase(actions.begin());
				action();
			}
		}",3,,29,1,,void
6702,BLOCK,-1,,"{
				std::function<void()> action = std::move(actions.begin()->second);
				actions.erase(actions.begin());
				action();
			}",4,,32,2,,void
6736,BLOCK,-1,,"{
			std::lock_guard<std::recursive_mutex> lock(mutex);
			actions.emplace(key, std::move(action));
		}",3,,40,3,,void
6761,BLOCK,-1,,"{
			std::lock_guard<std::recursive_mutex> lock(mutex);
			actions.erase(key);
		}",3,,46,2,,void
6783,BLOCK,-1,,"{
	return s_instance;
}",1,,58,1,,void
6791,BLOCK,-1,,"{
	return s_instance.add(key, std::move(action));
}",1,,63,3,,void
6807,BLOCK,-1,,"{
	return s_instance.del(key);
}",1,,68,2,,void
6834,BLOCK,-1,,<empty>,1,,1,1,,ANY
6837,BLOCK,-1,,"{
	LogManager::getLoggerRepository()->setConfigured(true);
	auto layout = layoutArg;
	if (!layout)
	{
		static const helpers::WideLife<LogString> TTCC_CONVERSION_PATTERN(LOG4CXX_STR(""%r [%t] %p %c %x - %m%n""));
		layout = std::make_shared<PatternLayout>(TTCC_CONVERSION_PATTERN);
	}
	auto appender = std::make_shared<ConsoleAppender>(layout);
	Logger::getRootLogger()->addAppender(appender);
}",1,,28,2,,void
6853,BLOCK,-1,,"{
		static const helpers::WideLife<LogString> TTCC_CONVERSION_PATTERN(LOG4CXX_STR(""%r [%t] %p %c %x - %m%n""));
		layout = std::make_shared<PatternLayout>(TTCC_CONVERSION_PATTERN);
	}",2,,32,2,,void
6889,BLOCK,-1,,"{
	LoggerPtr root = Logger::getRootLogger();
	root->addAppender(appender);
}",1,,41,2,,void
6905,BLOCK,-1,,"{
	LogManager::resetConfiguration();
}",1,,47,1,,void
6922,BLOCK,-1,,<empty>,1,,1,1,,ANY
6927,BLOCK,-1,,<empty>,2,,29,3,,void
6937,BLOCK,-1,,"{
}",1,,40,2,,void
6943,BLOCK,-1,,"{
}",1,,45,3,,void
6947,BLOCK,-1,,"{
}",1,,49,1,,void
6952,BLOCK,-1,,"{
	flush(p);
	m_priv->out->close(p);
}",1,,53,2,,void
6966,BLOCK,-1,,"{
	if (m_priv->buf.length() > 0)
	{
		m_priv->out->write(m_priv->buf, p);
		m_priv->buf.erase(m_priv->buf.begin(), m_priv->buf.end());
	}
}",1,,59,2,,void
6976,BLOCK,-1,,"{
		m_priv->out->write(m_priv->buf, p);
		m_priv->buf.erase(m_priv->buf.begin(), m_priv->buf.end());
	}",2,,61,2,,void
7010,BLOCK,-1,,"{
	if (m_priv->buf.length() + str.length() > m_priv->sz)
	{
		m_priv->out->write(m_priv->buf, p);
		m_priv->buf.erase(m_priv->buf.begin(), m_priv->buf.end());
	}

	if (str.length() > m_priv->sz)
	{
		m_priv->out->write(str, p);
	}
	else
	{
		m_priv->buf.append(str);
	}
}",1,,68,3,,void
7027,BLOCK,-1,,"{
		m_priv->out->write(m_priv->buf, p);
		m_priv->buf.erase(m_priv->buf.begin(), m_priv->buf.end());
	}",2,,70,2,,void
7065,BLOCK,-1,,"{
		m_priv->out->write(str, p);
	}",2,,76,2,,void
7075,BLOCK,-1,,"{
		m_priv->buf.append(str);
	}",2,,80,1,,void
7103,BLOCK,-1,,<empty>,1,,1,1,,ANY
7107,BLOCK,-1,,<empty>,10,,33,2,,void
7116,BLOCK,-1,,"{
}",1,,43,2,,void
7120,BLOCK,-1,,"{
}",1,,49,1,,void
7124,BLOCK,-1,,"{
}",1,,54,1,,void
7129,BLOCK,-1,,"{
	if (m_priv->pos >= m_priv->buf.size())
	{
		return -1;
	}
	else
	{
		size_t bytesCopied = min(dst.remaining(), m_priv->buf.size() - m_priv->pos);
		std::memcpy(dst.current(), &m_priv->buf[m_priv->pos], bytesCopied);
		m_priv->pos += bytesCopied;
		dst.position(dst.position() + bytesCopied);
		return (int)bytesCopied;
	}
}",1,,59,2,,void
7141,BLOCK,-1,,"{
		return -1;
	}",2,,61,2,,void
7146,BLOCK,-1,,"{
		size_t bytesCopied = min(dst.remaining(), m_priv->buf.size() - m_priv->pos);
		std::memcpy(dst.current(), &m_priv->buf[m_priv->pos], bytesCopied);
		m_priv->pos += bytesCopied;
		dst.position(dst.position() + bytesCopied);
		return (int)bytesCopied;
	}",2,,65,1,,void
7217,BLOCK,-1,,<empty>,1,,1,1,,ANY
7223,BLOCK,-1,,"{
}",1,,35,1,,void
7227,BLOCK,-1,,"{
}",1,,39,1,,void
7232,BLOCK,-1,,"{
}",1,,43,2,,void
7237,BLOCK,-1,,"{
}",1,,47,2,,void
7243,BLOCK,-1,,"{
	size_t sz = m_priv->array.size();
	m_priv->array.resize(sz + buf.remaining());
	memcpy(&m_priv->array[sz], buf.current(), buf.remaining());
	buf.position(buf.limit());
}",1,,51,3,,void
7291,BLOCK,-1,,"{
	return m_priv->array;
}",1,,59,1,,void
7310,BLOCK,-1,,<empty>,1,,1,1,,ANY
7315,BLOCK,-1,,<empty>,53,,28,3,,void
7325,BLOCK,-1,,"{
}",1,,38,3,,void
7329,BLOCK,-1,,"{
}",1,,42,1,,void
7333,BLOCK,-1,,"{
	m_priv->lim = m_priv->cap;
	m_priv->pos = 0;
}",1,,46,1,,void
7349,BLOCK,-1,,"{
	m_priv->lim = m_priv->pos;
	m_priv->pos = 0;
}",1,,52,1,,void
7366,BLOCK,-1,,"{
	if (newPosition < m_priv->lim)
	{
		m_priv->pos = newPosition;
	}
	else
	{
		m_priv->pos = m_priv->lim;
	}
}",1,,58,2,,void
7373,BLOCK,-1,,"{
		m_priv->pos = newPosition;
	}",2,,60,2,,void
7380,BLOCK,-1,,"{
		m_priv->pos = m_priv->lim;
	}",2,,64,1,,void
7392,BLOCK,-1,,"{
	if (newLimit > m_priv->cap)
	{
		throw IllegalArgumentException(LOG4CXX_STR(""newLimit""));
	}

	m_priv->lim = newLimit;
}",1,,70,2,,void
7399,BLOCK,-1,,"{
		throw IllegalArgumentException(LOG4CXX_STR(""newLimit""));
	}",2,,72,2,,void
7413,BLOCK,-1,,"{
	if (m_priv->pos < m_priv->lim)
	{
		m_priv->base[m_priv->pos++] = byte;
		return true;
	}

	return false;
}",1,,81,2,,void
7422,BLOCK,-1,,"{
		m_priv->base[m_priv->pos++] = byte;
		return true;
	}",2,,83,2,,void
7440,BLOCK,-1,,"{
	return m_priv->base;
}",1,,92,1,,void
7448,BLOCK,-1,,"{
	return m_priv->base;
}",1,,97,1,,void
7456,BLOCK,-1,,"{
	return m_priv->base + m_priv->pos;
}",1,,102,1,,void
7468,BLOCK,-1,,"{
	return m_priv->base + m_priv->pos;
}",1,,107,1,,void
7480,BLOCK,-1,,"{
	return m_priv->lim;
}",1,,112,1,,void
7488,BLOCK,-1,,"{
	return m_priv->pos;
}",1,,117,1,,void
7496,BLOCK,-1,,"{
	return m_priv->lim - m_priv->pos;
}",1,,122,1,,void
7521,BLOCK,-1,,<empty>,1,,1,1,,ANY
7526,BLOCK,-1,,<empty>,2,,38,3,,void
7585,BLOCK,-1,,"{
	if (dateFormat == NULL)
	{
		throw IllegalArgumentException(LOG4CXX_STR(""dateFormat cannot be null""));
	}

	if (expiration1 < 0)
	{
		throw IllegalArgumentException(LOG4CXX_STR(""expiration must be non-negative""));
	}
}",1,,128,3,,void
7590,BLOCK,-1,,"{
		throw IllegalArgumentException(LOG4CXX_STR(""dateFormat cannot be null""));
	}",2,,130,2,,void
7599,BLOCK,-1,,"{
		throw IllegalArgumentException(LOG4CXX_STR(""expiration must be non-negative""));
	}",2,,135,2,,void
7607,BLOCK,-1,,<empty>,39,,140,1,,void
7615,BLOCK,-1,,"{

	log4cxx_time_t slotBegin = (time / 1000000) * 1000000;

	if (slotBegin > time)
	{
		slotBegin -= 1000000;
	}

	int millis = (int) (time - slotBegin) / 1000;

	// the magic numbers are in microseconds
	int magic = magic1;
	LogString magicString(magicString1);

	if (millis == magic1 / 1000)
	{
		magic = magic2;
		magicString = magicString2;
	}

	LogString plusMagic;
	formatter->format(plusMagic, slotBegin + magic, pool);

	/**
	 *   If the string lengths differ then
	 *      we can't use the cache except for duplicate requests.
	 */
	if (plusMagic.length() != formatted.length())
	{
		return UNRECOGNIZED_MILLISECONDS;
	}
	else
	{
		// find first difference between values
		for (LogString::size_type i = 0; i < formatted.length(); i++)
		{
			if (formatted[i] != plusMagic[i])
			{
				//
				//   determine the expected digits for the base time
				const logchar abc[] = { 0x41, 0x42, 0x43, 0 };
				LogString formattedMillis(abc);
				millisecondFormat(millis, formattedMillis, 0);

			...",1,,156,5,,void
7628,BLOCK,-1,,"{
		slotBegin -= 1000000;
	}",2,,161,2,,void
7655,BLOCK,-1,,"{
		magic = magic2;
		magicString = magicString2;
	}",2,,172,2,,void
7682,BLOCK,-1,,"{
		return UNRECOGNIZED_MILLISECONDS;
	}",2,,185,2,,void
7686,BLOCK,-1,,"{
		// find first difference between values
		for (LogString::size_type i = 0; i < formatted.length(); i++)
		{
			if (formatted[i] != plusMagic[i])
			{
				//
				//   determine the expected digits for the base time
				const logchar abc[] = { 0x41, 0x42, 0x43, 0 };
				LogString formattedMillis(abc);
				millisecondFormat(millis, formattedMillis, 0);

				LogString plusZero;
				formatter->format(plusZero, slotBegin, pool);

				// Test if the next 1..3 characters match the magic string, main problem is that magic
				// available millis in formatted can overlap. Therefore the current i is not always the
				// index of the first millis char, but may be already within the millis. Besides that
				// the millis can occur everywhere in formatted. See LOGCXX-420 and following.
				size_t  magicLength     = magicString.length();
				size_t  overlapping     = magicString.find(plusMagic[i]);
				int     possibleRetVal  = int(i - overlapping);

				if (plusZero.length() == formatted.len...",2,,189,1,,void
7688,BLOCK,-1,,<empty>,3,,191,1,,void
7701,BLOCK,4,,"{
			if (formatted[i] != plusMagic[i])
			{
				//
				//   determine the expected digits for the base time
				const logchar abc[] = { 0x41, 0x42, 0x43, 0 };
				LogString formattedMillis(abc);
				millisecondFormat(millis, formattedMillis, 0);

				LogString plusZero;
				formatter->format(plusZero, slotBegin, pool);

				// Test if the next 1..3 characters match the magic string, main problem is that magic
				// available millis in formatted can overlap. Therefore the current i is not always the
				// index of the first millis char, but may be already within the millis. Besides that
				// the millis can occur everywhere in formatted. See LOGCXX-420 and following.
				size_t  magicLength     = magicString.length();
				size_t  overlapping     = magicString.find(plusMagic[i]);
				int     possibleRetVal  = int(i - overlapping);

				if (plusZero.length() == formatted.length()
					&& regionMatches(magicString,       0, plusMagic,   possibleRetVal, magicLength)
					&& regionMatc...",3,,192,4,,void
7710,BLOCK,-1,,"{
				//
				//   determine the expected digits for the base time
				const logchar abc[] = { 0x41, 0x42, 0x43, 0 };
				LogString formattedMillis(abc);
				millisecondFormat(millis, formattedMillis, 0);

				LogString plusZero;
				formatter->format(plusZero, slotBegin, pool);

				// Test if the next 1..3 characters match the magic string, main problem is that magic
				// available millis in formatted can overlap. Therefore the current i is not always the
				// index of the first millis char, but may be already within the millis. Besides that
				// the millis can occur everywhere in formatted. See LOGCXX-420 and following.
				size_t  magicLength     = magicString.length();
				size_t  overlapping     = magicString.find(plusMagic[i]);
				int     possibleRetVal  = int(i - overlapping);

				if (plusZero.length() == formatted.length()
					&& regionMatches(magicString,       0, plusMagic,   possibleRetVal, magicLength)
					&& regionMatches(formattedMillis,   0, formatted,   pos...",4,,194,2,,void
7819,BLOCK,-1,,"{
					return possibleRetVal;
				}",5,,222,2,,void
7823,BLOCK,-1,,"{
					return UNRECOGNIZED_MILLISECONDS;
				}",5,,226,1,,void
7834,BLOCK,-1,,"{

	//
	// If the current requested time is identical to the previously
	//     requested time, then append the cache contents.
	//
	if (now == m_priv->previousTime)
	{
		buf.append(m_priv->cache);
		return;
	}

	//
	//   If millisecond pattern was not unrecognized
	//     (that is if it was found or milliseconds did not appear)
	//
	if (m_priv->millisecondStart != UNRECOGNIZED_MILLISECONDS)
	{
		//    Check if the cache is still valid.
		//    If the requested time is within the same integral second
		//       as the last request and a shorter expiration was not requested.
		if (now < m_priv->slotBegin + m_priv->expiration
			&& now >= m_priv->slotBegin
			&& now < m_priv->slotBegin + 1000000L)
		{
			//
			//    if there was a millisecond field then update it
			//
			if (m_priv->millisecondStart >= 0)
			{
				millisecondFormat((int) ((now - m_priv->slotBegin) / 1000), m_priv->cache, m_priv->millisecondStart);
			}

			//
			//   update the previously requested time
			//      (t...",1,,244,4,,void
7841,BLOCK,-1,,"{
		buf.append(m_priv->cache);
		return;
	}",2,,251,2,,void
7856,BLOCK,-1,,"{
		//    Check if the cache is still valid.
		//    If the requested time is within the same integral second
		//       as the last request and a shorter expiration was not requested.
		if (now < m_priv->slotBegin + m_priv->expiration
			&& now >= m_priv->slotBegin
			&& now < m_priv->slotBegin + 1000000L)
		{
			//
			//    if there was a millisecond field then update it
			//
			if (m_priv->millisecondStart >= 0)
			{
				millisecondFormat((int) ((now - m_priv->slotBegin) / 1000), m_priv->cache, m_priv->millisecondStart);
			}

			//
			//   update the previously requested time
			//      (the slot begin should be unchanged)
			m_priv->previousTime = now;
			buf.append(m_priv->cache);

			return;
		}
	}",2,,261,2,,void
7881,BLOCK,-1,,"{
			//
			//    if there was a millisecond field then update it
			//
			if (m_priv->millisecondStart >= 0)
			{
				millisecondFormat((int) ((now - m_priv->slotBegin) / 1000), m_priv->cache, m_priv->millisecondStart);
			}

			//
			//   update the previously requested time
			//      (the slot begin should be unchanged)
			m_priv->previousTime = now;
			buf.append(m_priv->cache);

			return;
		}",3,,268,2,,void
7888,BLOCK,-1,,"{
				millisecondFormat((int) ((now - m_priv->slotBegin) / 1000), m_priv->cache, m_priv->millisecondStart);
			}",4,,273,2,,void
7978,BLOCK,-1,,"{
		m_priv->slotBegin -= 1000000;
	}",2,,297,2,,void
7990,BLOCK,-1,,"{
		m_priv->millisecondStart = findMillisecondStart(now, m_priv->cache, m_priv->formatter, p);
	}",2,,306,2,,void
8010,BLOCK,-1,,"{
	buf[offset] = digits[millis / 100];
	buf[offset + 1] = digits[(millis / 10) % 10];
	buf[offset + 2] = digits[millis  % 10];
}",1,,321,4,,void
8048,BLOCK,-1,,"{
	m_priv->formatter->setTimeZone(timeZone);
	m_priv->previousTime = std::numeric_limits<log4cxx_time_t>::min();
	m_priv->slotBegin = std::numeric_limits<log4cxx_time_t>::min();
}",1,,335,2,,void
8090,BLOCK,-1,,"{
	m_priv->formatter->numberFormat(s, n, p);
}",1,,344,4,,void
8104,BLOCK,-1,,"{
	//
	//   If there are more ""S"" in the pattern than just one ""SSS"" then
	//      (for example, ""HH:mm:ss,SSS SSS""), then set the expiration to
	//      one millisecond which should only perform duplicate request caching.
	//
	const logchar S = 0x53;
	const logchar SSS[] = { 0x53, 0x53, 0x53, 0 };
	size_t firstS = pattern.find(S);
	size_t len = pattern.length();

	//
	//   if there are no S's or
	//      three that start with the first S and no fourth S in the string
	//
	if (firstS == LogString::npos ||
		(len >= firstS + 3 && pattern.compare(firstS, 3, SSS) == 0
			&& (len == firstS + 3 ||
				pattern.find(S, firstS + 3) == LogString::npos)))
	{
		return 1000000;
	}

	return 1000;
}",1,,357,2,,void
8173,BLOCK,-1,,"{
		return 1000000;
	}",2,,376,2,,void
8186,BLOCK,-1,,"{
	return target.compare(toffset, len, other, ooffset, len) == 0;
}",1,,399,6,,void
8231,BLOCK,-1,,<empty>,1,,1,1,,ANY
8238,BLOCK,-1,,"{
		}",3,,237,1,,void
8242,BLOCK,-1,,"{
		}",3,,241,1,,void
8248,BLOCK,-1,,"{
			size_t remaining = in.remaining();

			if ( remaining > 0)
			{
				const logchar* src = (const logchar*) (in.data() + in.position());
				size_t count = remaining / sizeof(logchar);
				out.append(src, count);
				in.position(in.position() + remaining);
			}

			return APR_SUCCESS;
		}",3,,246,3,,void
8260,BLOCK,-1,,"{
				const logchar* src = (const logchar*) (in.data() + in.position());
				size_t count = remaining / sizeof(logchar);
				out.append(src, count);
				in.position(in.position() + remaining);
			}",4,,250,2,,void
8304,BLOCK,-1,,<empty>,,,,2,,<empty>
8309,BLOCK,-1,,<empty>,,,,2,,<empty>
8314,BLOCK,-1,,"{
		}",3,,279,1,,void
8318,BLOCK,-1,,"{
		}",3,,283,1,,void
8324,BLOCK,-1,,"{
			if (in.remaining() > 0)
			{
				std::string tmp(in.current(), in.remaining());
				std::string::const_iterator iter = tmp.begin();

				while (iter != tmp.end())
				{
					unsigned int sv = Transcoder::decode(tmp, iter);

					if (sv == 0xFFFF)
					{
						size_t offset = iter - tmp.begin();
						in.position(in.position() + offset);
						return APR_BADARG;
					}
					else
					{
						Transcoder::encode(sv, out);
					}
				}

				in.position(in.limit());
			}

			return APR_SUCCESS;
		}",3,,289,3,,void
8332,BLOCK,-1,,"{
				std::string tmp(in.current(), in.remaining());
				std::string::const_iterator iter = tmp.begin();

				while (iter != tmp.end())
				{
					unsigned int sv = Transcoder::decode(tmp, iter);

					if (sv == 0xFFFF)
					{
						size_t offset = iter - tmp.begin();
						in.position(in.position() + offset);
						return APR_BADARG;
					}
					else
					{
						Transcoder::encode(sv, out);
					}
				}

				in.position(in.limit());
			}",4,,291,2,,void
8357,BLOCK,-1,,"{
					unsigned int sv = Transcoder::decode(tmp, iter);

					if (sv == 0xFFFF)
					{
						size_t offset = iter - tmp.begin();
						in.position(in.position() + offset);
						return APR_BADARG;
					}
					else
					{
						Transcoder::encode(sv, out);
					}
				}",5,,296,2,,void
8371,BLOCK,-1,,"{
						size_t offset = iter - tmp.begin();
						in.position(in.position() + offset);
						return APR_BADARG;
					}",6,,300,2,,void
8394,BLOCK,-1,,"{
						Transcoder::encode(sv, out);
					}",6,,306,1,,void
8415,BLOCK,-1,,<empty>,,,,2,,<empty>
8420,BLOCK,-1,,<empty>,,,,2,,<empty>
8425,BLOCK,-1,,"{
		}",3,,331,1,,void
8429,BLOCK,-1,,"{
		}",3,,335,1,,void
8435,BLOCK,-1,,"{
			if (in.remaining() > 0)
			{

				const unsigned char* src = (unsigned char*) in.current();
				const unsigned char* srcEnd = src + in.remaining();

				while (src < srcEnd)
				{
					unsigned int sv = *(src++);
					Transcoder::encode(sv, out);
				}

				in.position(in.limit());
			}

			return APR_SUCCESS;
		}",3,,341,3,,void
8443,BLOCK,-1,,"{

				const unsigned char* src = (unsigned char*) in.current();
				const unsigned char* srcEnd = src + in.remaining();

				while (src < srcEnd)
				{
					unsigned int sv = *(src++);
					Transcoder::encode(sv, out);
				}

				in.position(in.limit());
			}",4,,343,2,,void
8466,BLOCK,-1,,"{
					unsigned int sv = *(src++);
					Transcoder::encode(sv, out);
				}",5,,349,2,,void
8493,BLOCK,-1,,<empty>,,,,2,,<empty>
8498,BLOCK,-1,,<empty>,,,,2,,<empty>
8503,BLOCK,-1,,"{
		}",3,,376,1,,void
8507,BLOCK,-1,,"{
		}",3,,380,1,,void
8513,BLOCK,-1,,"{
			log4cxx_status_t stat = APR_SUCCESS;

			if (in.remaining() > 0)
			{

				const unsigned char* src = (unsigned char*) in.current();
				const unsigned char* srcEnd = src + in.remaining();

				while (src < srcEnd)
				{
					unsigned char sv = *src;

					if (sv < 0x80)
					{
						src++;
						Transcoder::encode(sv, out);
					}
					else
					{
						stat = APR_BADARG;
						break;
					}
				}

				in.position(src - (const unsigned char*) in.data());
			}

			return stat;
		}",3,,387,3,,void
8525,BLOCK,-1,,"{

				const unsigned char* src = (unsigned char*) in.current();
				const unsigned char* srcEnd = src + in.remaining();

				while (src < srcEnd)
				{
					unsigned char sv = *src;

					if (sv < 0x80)
					{
						src++;
						Transcoder::encode(sv, out);
					}
					else
					{
						stat = APR_BADARG;
						break;
					}
				}

				in.position(src - (const unsigned char*) in.data());
			}",4,,391,2,,void
8548,BLOCK,-1,,"{
					unsigned char sv = *src;

					if (sv < 0x80)
					{
						src++;
						Transcoder::encode(sv, out);
					}
					else
					{
						stat = APR_BADARG;
						break;
					}
				}",5,,397,2,,void
8558,BLOCK,-1,,"{
						src++;
						Transcoder::encode(sv, out);
					}",6,,401,2,,void
8568,BLOCK,-1,,"{
						stat = APR_BADARG;
						break;
					}",6,,406,1,,void
8591,BLOCK,-1,,<empty>,,,,2,,<empty>
8596,BLOCK,-1,,<empty>,,,,2,,<empty>
8601,BLOCK,-1,,"{
		}",3,,432,1,,void
8607,BLOCK,-1,,"{
			log4cxx_status_t result = APR_SUCCESS;
			const char* p = in.current();
			size_t i = in.position();
			size_t remain = in.limit() - i;
#if !LOG4CXX_CHARSET_EBCDIC
			if (std::mbsinit(&this->state)) // ByteBuffer not partially decoded?
			{
				// Copy single byte characters
				for (; 0 < remain && ((unsigned int) *p) < 0x80; --remain, ++i, p++)
				{
					out.append(1, *p);
				}
			}
#endif
			// Decode characters that may be represented by multiple bytes
			while (0 < remain)
			{
				wchar_t ch = 0;
				size_t n = std::mbrtowc(&ch, p, remain, &this->state);
				if (0 == n) // NULL encountered?
				{
					++i;
					break;
				}
				if (static_cast<std::size_t>(-1) == n) // decoding error?
				{
					result = APR_BADARG;
					break;
				}
				if (static_cast<std::size_t>(-2) == n) // incomplete sequence?
				{
					break;
				}
				Transcoder::encode(static_cast<unsigned int>(ch), out);
				remain -= n;
				i += n;
				p += n;
			}
			in.position(i);
			return result;
		}",3,,435,3,,void
8644,BLOCK,-1,,"{
				// Copy single byte characters
				for (; 0 < remain && ((unsigned int) *p) < 0x80; --remain, ++i, p++)
				{
					out.append(1, *p);
				}
			}",4,,442,2,,void
8646,BLOCK,-1,,<empty>,5,,444,1,,void
8664,BLOCK,4,,"{
					out.append(1, *p);
				}",5,,445,4,,void
8676,BLOCK,-1,,"{
				wchar_t ch = 0;
				size_t n = std::mbrtowc(&ch, p, remain, &this->state);
				if (0 == n) // NULL encountered?
				{
					++i;
					break;
				}
				if (static_cast<std::size_t>(-1) == n) // decoding error?
				{
					result = APR_BADARG;
					break;
				}
				if (static_cast<std::size_t>(-2) == n) // incomplete sequence?
				{
					break;
				}
				Transcoder::encode(static_cast<unsigned int>(ch), out);
				remain -= n;
				i += n;
				p += n;
			}",4,,452,2,,void
8700,BLOCK,-1,,"{
					++i;
					break;
				}",5,,456,2,,void
8711,BLOCK,-1,,"{
					result = APR_BADARG;
					break;
				}",5,,461,2,,void
8723,BLOCK,-1,,"{
					break;
				}",5,,466,2,,void
8753,BLOCK,-1,,"{
}",1,,490,1,,void
8757,BLOCK,-1,,"{
}",1,,495,1,,void
8761,BLOCK,-1,,"{
#if LOG4CXX_CHARSET_UTF8
	return new UTF8CharsetDecoder();
#elif LOG4CXX_CHARSET_ISO88591 || defined(_WIN32_WCE)
	return new ISOLatinCharsetDecoder();
#elif LOG4CXX_CHARSET_USASCII
	return new USASCIICharsetDecoder();
#elif LOG4CXX_LOGCHAR_IS_WCHAR && LOG4CXX_HAS_MBSRTOWCS
	return new MbstowcsCharsetDecoder();
#else
	return new LocaleCharsetDecoder();
#endif
}",1,,499,1,,void
8768,BLOCK,-1,,"{
	static WideLife<CharsetDecoderPtr> decoder(createDefaultDecoder());

	//
	//  if invoked after static variable destruction
	//     (if logging is called in the destructor of a static object)
	//     then create a new decoder.
	//
	if (decoder.value() == 0)
	{
		return CharsetDecoderPtr( createDefaultDecoder() );
	}

	return decoder;
}",1,,514,1,,void
8779,BLOCK,-1,,"{
		return CharsetDecoderPtr( createDefaultDecoder() );
	}",2,,523,2,,void
8788,BLOCK,-1,,"{
	static WideLife<CharsetDecoderPtr> decoder(new UTF8CharsetDecoder());

	//
	//  if invoked after static variable destruction
	//     (if logging is called in the destructor of a static object)
	//     then create a new decoder.
	//
	if (decoder.value() == 0)
	{
		return std::make_shared<UTF8CharsetDecoder>();
	}

	return decoder;
}",1,,531,1,,void
8800,BLOCK,-1,,"{
		return std::make_shared<UTF8CharsetDecoder>();
	}",2,,540,2,,void
8811,BLOCK,-1,,"{
	return std::make_shared<ISOLatinCharsetDecoder>();
}",1,,548,1,,void
8821,BLOCK,-1,,"{
	if (StringHelper::equalsIgnoreCase(charset, LOG4CXX_STR(""UTF-8""), LOG4CXX_STR(""utf-8"")) ||
		StringHelper::equalsIgnoreCase(charset, LOG4CXX_STR(""UTF8""), LOG4CXX_STR(""utf8"")) ||
		StringHelper::equalsIgnoreCase(charset, LOG4CXX_STR(""CP65001""), LOG4CXX_STR(""cp65001"")))
	{
		return std::make_shared<UTF8CharsetDecoder>();
	}
	else if (StringHelper::equalsIgnoreCase(charset, LOG4CXX_STR(""C""), LOG4CXX_STR(""c"")) ||
		charset == LOG4CXX_STR(""646"") ||
		StringHelper::equalsIgnoreCase(charset, LOG4CXX_STR(""US-ASCII""), LOG4CXX_STR(""us-ascii"")) ||
		StringHelper::equalsIgnoreCase(charset, LOG4CXX_STR(""ISO646-US""), LOG4CXX_STR(""iso646-US"")) ||
		StringHelper::equalsIgnoreCase(charset, LOG4CXX_STR(""ANSI_X3.4-1968""), LOG4CXX_STR(""ansi_x3.4-1968"")) ||
		StringHelper::equalsIgnoreCase(charset, LOG4CXX_STR(""CP20127""), LOG4CXX_STR(""cp20127"")))
	{
		return std::make_shared<USASCIICharsetDecoder>();
	}
	else if (StringHelper::equalsIgnoreCase(charset, LOG4CXX_STR(""ISO-8859-1""), LOG4CXX_STR(""iso-8859...",1,,554,2,,void
8852,BLOCK,-1,,"{
		return std::make_shared<UTF8CharsetDecoder>();
	}",2,,558,2,,void
8859,BLOCK,-1,,<empty>,7,,561,1,,void
8915,BLOCK,-1,,"{
		return std::make_shared<USASCIICharsetDecoder>();
	}",2,,567,2,,void
8922,BLOCK,-1,,<empty>,7,,570,1,,void
8953,BLOCK,-1,,"{
		return std::make_shared<ISOLatinCharsetDecoder>();
	}",2,,573,2,,void
8960,BLOCK,-1,,<empty>,7,,576,1,,void
8971,BLOCK,-1,,"{
		return std::make_shared<LocaleCharsetDecoder>();
	}",2,,577,2,,void
8985,BLOCK,-1,,{ return 0x80 <= (unsigned int)ch; },36,,638,2,,void
9022,BLOCK,-1,,<empty>,1,,1,1,,ANY
9029,BLOCK,-1,,"{
		}",3,,222,1,,void
9036,BLOCK,-1,,"{
			log4cxx_status_t stat = APR_SUCCESS;

			if (iter != in.end())
			{
				while (out.remaining() > 0 && iter != in.end())
				{
					LogString::const_iterator prev(iter);
					unsigned int sv = Transcoder::decode(in, iter);

					if (sv <= 0x7F)
					{
						out.put((char) sv);
					}
					else
					{
						iter = prev;
						stat = APR_BADARG;
						break;
					}
				}
			}

			return stat;
		}",3,,228,4,,void
9048,BLOCK,-1,,"{
				while (out.remaining() > 0 && iter != in.end())
				{
					LogString::const_iterator prev(iter);
					unsigned int sv = Transcoder::decode(in, iter);

					if (sv <= 0x7F)
					{
						out.put((char) sv);
					}
					else
					{
						iter = prev;
						stat = APR_BADARG;
						break;
					}
				}
			}",4,,232,2,,void
9063,BLOCK,-1,,"{
					LogString::const_iterator prev(iter);
					unsigned int sv = Transcoder::decode(in, iter);

					if (sv <= 0x7F)
					{
						out.put((char) sv);
					}
					else
					{
						iter = prev;
						stat = APR_BADARG;
						break;
					}
				}",5,,234,2,,void
9080,BLOCK,-1,,"{
						out.put((char) sv);
					}",6,,239,2,,void
9089,BLOCK,-1,,"{
						iter = prev;
						stat = APR_BADARG;
						break;
					}",6,,243,1,,void
9103,BLOCK,-1,,<empty>,,,,2,,<empty>
9108,BLOCK,-1,,<empty>,,,,2,,<empty>
9113,BLOCK,-1,,"{
		}",3,,266,1,,void
9120,BLOCK,-1,,"{
			log4cxx_status_t stat = APR_SUCCESS;

			if (iter != in.end())
			{
				while (out.remaining() > 0 && iter != in.end())
				{
					LogString::const_iterator prev(iter);
					unsigned int sv = Transcoder::decode(in, iter);

					if (sv <= 0xFF)
					{
						out.put((char) sv);
					}
					else
					{
						iter = prev;
						stat = APR_BADARG;
						break;
					}
				}
			}

			return stat;
		}",3,,272,4,,void
9132,BLOCK,-1,,"{
				while (out.remaining() > 0 && iter != in.end())
				{
					LogString::const_iterator prev(iter);
					unsigned int sv = Transcoder::decode(in, iter);

					if (sv <= 0xFF)
					{
						out.put((char) sv);
					}
					else
					{
						iter = prev;
						stat = APR_BADARG;
						break;
					}
				}
			}",4,,276,2,,void
9147,BLOCK,-1,,"{
					LogString::const_iterator prev(iter);
					unsigned int sv = Transcoder::decode(in, iter);

					if (sv <= 0xFF)
					{
						out.put((char) sv);
					}
					else
					{
						iter = prev;
						stat = APR_BADARG;
						break;
					}
				}",5,,278,2,,void
9164,BLOCK,-1,,"{
						out.put((char) sv);
					}",6,,283,2,,void
9173,BLOCK,-1,,"{
						iter = prev;
						stat = APR_BADARG;
						break;
					}",6,,287,1,,void
9187,BLOCK,-1,,<empty>,,,,2,,<empty>
9192,BLOCK,-1,,<empty>,,,,2,,<empty>
9197,BLOCK,-1,,"{
		}",3,,310,1,,void
9204,BLOCK,-1,,"{
			if (iter != in.end())
			{
				size_t requested = in.length() - (iter - in.begin());

				if (requested > out.remaining() / sizeof(logchar))
				{
					requested = out.remaining() / sizeof(logchar);
				}

				memcpy(out.current(),
					(const char*) in.data() + (iter - in.begin()),
					requested * sizeof(logchar));
				iter += requested;
				out.position(out.position() + requested * sizeof(logchar));
			}

			return APR_SUCCESS;
		}",3,,317,4,,void
9212,BLOCK,-1,,"{
				size_t requested = in.length() - (iter - in.begin());

				if (requested > out.remaining() / sizeof(logchar))
				{
					requested = out.remaining() / sizeof(logchar);
				}

				memcpy(out.current(),
					(const char*) in.data() + (iter - in.begin()),
					requested * sizeof(logchar));
				iter += requested;
				out.position(out.position() + requested * sizeof(logchar));
			}",4,,319,2,,void
9237,BLOCK,-1,,"{
					requested = out.remaining() / sizeof(logchar);
				}",5,,323,2,,void
9291,BLOCK,-1,,<empty>,,,,2,,<empty>
9296,BLOCK,-1,,<empty>,,,,2,,<empty>
9301,BLOCK,-1,,"{
		}",3,,352,1,,void
9308,BLOCK,-1,,"{
			while (iter != in.end() && out.remaining() >= 8)
			{
				unsigned int sv = Transcoder::decode(in, iter);

				if (sv == 0xFFFF)
				{
					return APR_BADARG;
				}

				Transcoder::encodeUTF8(sv, out);
			}

			return APR_SUCCESS;
		}",3,,358,4,,void
9323,BLOCK,-1,,"{
				unsigned int sv = Transcoder::decode(in, iter);

				if (sv == 0xFFFF)
				{
					return APR_BADARG;
				}

				Transcoder::encodeUTF8(sv, out);
			}",4,,360,2,,void
9337,BLOCK,-1,,"{
					return APR_BADARG;
				}",5,,364,2,,void
9352,BLOCK,-1,,<empty>,,,,2,,<empty>
9357,BLOCK,-1,,<empty>,,,,2,,<empty>
9362,BLOCK,-1,,"{
		}",3,,387,1,,void
9369,BLOCK,-1,,"{
			while (iter != in.end() && out.remaining() >= 4)
			{
				unsigned int sv = Transcoder::decode(in, iter);

				if (sv == 0xFFFF)
				{
					return APR_BADARG;
				}

				Transcoder::encodeUTF16BE(sv, out);
			}

			return APR_SUCCESS;
		}",3,,393,4,,void
9384,BLOCK,-1,,"{
				unsigned int sv = Transcoder::decode(in, iter);

				if (sv == 0xFFFF)
				{
					return APR_BADARG;
				}

				Transcoder::encodeUTF16BE(sv, out);
			}",4,,395,2,,void
9398,BLOCK,-1,,"{
					return APR_BADARG;
				}",5,,399,2,,void
9413,BLOCK,-1,,<empty>,,,,2,,<empty>
9418,BLOCK,-1,,<empty>,,,,2,,<empty>
9423,BLOCK,-1,,"{
		}",3,,421,1,,void
9430,BLOCK,-1,,"{
			while (iter != in.end() && out.remaining() >= 4)
			{
				unsigned int sv = Transcoder::decode(in, iter);

				if (sv == 0xFFFF)
				{
					return APR_BADARG;
				}

				Transcoder::encodeUTF16LE(sv, out);
			}

			return APR_SUCCESS;
		}",3,,428,4,,void
9445,BLOCK,-1,,"{
				unsigned int sv = Transcoder::decode(in, iter);

				if (sv == 0xFFFF)
				{
					return APR_BADARG;
				}

				Transcoder::encodeUTF16LE(sv, out);
			}",4,,430,2,,void
9459,BLOCK,-1,,"{
					return APR_BADARG;
				}",5,,434,2,,void
9474,BLOCK,-1,,<empty>,,,,2,,<empty>
9479,BLOCK,-1,,<empty>,,,,2,,<empty>
9484,BLOCK,-1,,"{
		}",3,,455,1,,void
9491,BLOCK,-1,,"{
			log4cxx_status_t result = APR_SUCCESS;
#if !LOG4CXX_CHARSET_EBCDIC
			char* current = out.current();
			size_t remain = out.remaining();
			if (std::mbsinit(&this->state)) // ByteBuffer not partially encoded?
			{
				// Copy single byte characters
				for (;
					iter != in.end() && ((unsigned int) *iter) < 0x80 && 0 < remain;
					iter++, remain--, current++)
				{
					*current = *iter;
				}
			}
#endif
			// Encode characters that may require multiple bytes
			while (iter != in.end() && MB_CUR_MAX <= remain)
			{
				auto ch = Transcoder::decode(in, iter);
				auto n = std::wcrtomb(current, ch, &this->state);
				if (static_cast<std::size_t>(-1) == n) // not a valid wide character?
				{
					result = APR_BADARG;
					break;
				}
				remain -= n;
				current += n;
			}
			out.position(current - out.data());
			return result;
		}",3,,462,4,,void
9519,BLOCK,-1,,"{
				// Copy single byte characters
				for (;
					iter != in.end() && ((unsigned int) *iter) < 0x80 && 0 < remain;
					iter++, remain--, current++)
				{
					*current = *iter;
				}
			}",4,,468,2,,void
9521,BLOCK,-1,,<empty>,5,,470,1,,void
9546,BLOCK,4,,"{
					*current = *iter;
				}",5,,473,4,,void
9563,BLOCK,-1,,"{
				auto ch = Transcoder::decode(in, iter);
				auto n = std::wcrtomb(current, ch, &this->state);
				if (static_cast<std::size_t>(-1) == n) // not a valid wide character?
				{
					result = APR_BADARG;
					break;
				}
				remain -= n;
				current += n;
			}",4,,480,2,,void
9593,BLOCK,-1,,"{
					result = APR_BADARG;
					break;
				}",5,,484,2,,void
9620,BLOCK,-1,,"{
}",1,,507,1,,void
9624,BLOCK,-1,,"{
}",1,,511,1,,void
9628,BLOCK,-1,,"{
	static WideLife<CharsetEncoderPtr> encoder(createDefaultEncoder());

	//
	//  if invoked after static variable destruction
	//     (if logging is called in the destructor of a static object)
	//     then create a new decoder.
	//
	if (encoder.value() == 0)
	{
		return CharsetEncoderPtr( createDefaultEncoder() );
	}

	return encoder;
}",1,,515,1,,void
9639,BLOCK,-1,,"{
		return CharsetEncoderPtr( createDefaultEncoder() );
	}",2,,524,2,,void
9648,BLOCK,-1,,"{
#if LOG4CXX_CHARSET_UTF8
	return new UTF8CharsetEncoder();
#elif LOG4CXX_CHARSET_ISO88591
	return new ISOLatinCharsetEncoder();
#elif LOG4CXX_CHARSET_USASCII
	return new USASCIICharsetEncoder();
#elif LOG4CXX_LOGCHAR_IS_WCHAR && LOG4CXX_HAS_WCSTOMBS
	return new WcstombsCharsetEncoder();
#else
	return new LocaleCharsetEncoder();
#endif
}",1,,532,1,,void
9655,BLOCK,-1,,"{
	return std::make_shared<UTF8CharsetEncoder>();
}",1,,548,1,,void
9665,BLOCK,-1,,"{
	if (StringHelper::equalsIgnoreCase(charset, LOG4CXX_STR(""UTF-8""), LOG4CXX_STR(""utf-8""))
		|| StringHelper::equalsIgnoreCase(charset, LOG4CXX_STR(""CP65001""), LOG4CXX_STR(""cp65001"")))
	{
		return std::make_shared<UTF8CharsetEncoder>();
	}
	else if (StringHelper::equalsIgnoreCase(charset, LOG4CXX_STR(""C""), LOG4CXX_STR(""c"")) ||
		charset == LOG4CXX_STR(""646"") ||
		StringHelper::equalsIgnoreCase(charset, LOG4CXX_STR(""US-ASCII""), LOG4CXX_STR(""us-ascii"")) ||
		StringHelper::equalsIgnoreCase(charset, LOG4CXX_STR(""ISO646-US""), LOG4CXX_STR(""iso646-US"")) ||
		StringHelper::equalsIgnoreCase(charset, LOG4CXX_STR(""ANSI_X3.4-1968""), LOG4CXX_STR(""ansi_x3.4-1968"")) ||
		StringHelper::equalsIgnoreCase(charset, LOG4CXX_STR(""CP20127""), LOG4CXX_STR(""cp20127"")))
	{
		return std::make_shared<USASCIICharsetEncoder>();
	}
	else if (StringHelper::equalsIgnoreCase(charset, LOG4CXX_STR(""ISO-8859-1""), LOG4CXX_STR(""iso-8859-1"")) ||
		StringHelper::equalsIgnoreCase(charset, LOG4CXX_STR(""ISO-LATIN-1""), LOG4CXX_...",1,,555,2,,void
9686,BLOCK,-1,,"{
		return std::make_shared<UTF8CharsetEncoder>();
	}",2,,558,2,,void
9693,BLOCK,-1,,<empty>,7,,561,1,,void
9749,BLOCK,-1,,"{
		return std::make_shared<USASCIICharsetEncoder>();
	}",2,,567,2,,void
9756,BLOCK,-1,,<empty>,7,,570,1,,void
9787,BLOCK,-1,,"{
		return std::make_shared<ISOLatinCharsetEncoder>();
	}",2,,573,2,,void
9794,BLOCK,-1,,<empty>,7,,576,1,,void
9825,BLOCK,-1,,"{
		return std::make_shared<UTF16BECharsetEncoder>();
	}",2,,579,2,,void
9832,BLOCK,-1,,<empty>,7,,582,1,,void
9843,BLOCK,-1,,"{
		return std::make_shared<UTF16LECharsetEncoder>();
	}",2,,583,2,,void
9850,BLOCK,-1,,<empty>,7,,586,1,,void
9861,BLOCK,-1,,"{
		return std::make_shared<LocaleCharsetEncoder>();
	}",2,,587,2,,void
9873,BLOCK,-1,,"{
}",1,,600,1,,void
9878,BLOCK,-1,,"{
}",1,,604,2,,void
9886,BLOCK,-1,,"{
	log4cxx_status_t stat = enc->encode(src, iter, dst);

	if (stat != APR_SUCCESS && iter != src.end())
	{
#if LOG4CXX_LOGCHAR_IS_WCHAR || LOG4CXX_LOGCHAR_IS_UNICHAR
		iter++;
#elif LOG4CXX_LOGCHAR_IS_UTF8

		//  advance past this character and all continuation characters
		while ((*(++iter) & 0xC0) == 0x80);

#else
#error logchar is unrecognized
#endif
		dst.put(Transcoder::LOSSCHAR);
	}
}",1,,612,5,,void
9908,BLOCK,-1,,"{
#if LOG4CXX_LOGCHAR_IS_WCHAR || LOG4CXX_LOGCHAR_IS_UNICHAR
		iter++;
#elif LOG4CXX_LOGCHAR_IS_UTF8

		//  advance past this character and all continuation characters
		while ((*(++iter) & 0xC0) == 0x80);

#else
#error logchar is unrecognized
#endif
		dst.put(Transcoder::LOSSCHAR);
	}",2,,616,2,,void
9921,BLOCK,-1,,"{
	bool result;
#if !LOG4CXX_CHARSET_EBCDIC
	if (dynamic_cast<LocaleCharsetEncoder*>(enc.get()))
	{
		result = src.end() == std::find_if(src.begin(), src.end()
			, [](const logchar& ch) -> bool { return 0x80 <= (unsigned int)ch; });
	}
	else
#endif
		result = !!dynamic_cast<TrivialCharsetEncoder*>(enc.get());
	return result;
}",1,,632,3,,void
9930,BLOCK,-1,,"{
		result = src.end() == std::find_if(src.begin(), src.end()
			, [](const logchar& ch) -> bool { return 0x80 <= (unsigned int)ch; });
	}",2,,636,2,,void
9952,BLOCK,-1,,<empty>,3,,642,1,,void
10049,BLOCK,-1,,<empty>,1,,1,1,,ANY
10052,BLOCK,-1,,"{
	// This function defined in log4cxx.h
	return LOG4CXX_VERSION;
}",1,,80,1,,void
10059,BLOCK,-1,,"{
	return  LOG4CXX_NS::libraryVersion();
}",1,,88,1,,void
10068,BLOCK,-1,,"{
}",1,,94,1,,void
10072,BLOCK,-1,,"{
}",1,,98,1,,void
10076,BLOCK,-1,,"{
	return getName();
}",1,,102,1,,void
10082,BLOCK,-1,,"{
	throw InstantiationException(LOG4CXX_STR(""Cannot create new instances of Class.""));
#if LOG4CXX_RETURN_AFTER_THROW
	return 0;
#endif
}",1,,107,1,,void
10090,BLOCK,-1,,"{
	static WideLife<ClassMap> registry;
	return registry;
}",1,,117,1,,void
10098,BLOCK,-1,,"{
	LogString lowerName(StringHelper::toLowerCase(className));
	//
	//  check registry using full class name
	//
	const Class* clazz = getRegistry()[lowerName];

	if (clazz == 0)
	{
		LogString::size_type pos = className.find_last_of(LOG4CXX_STR("".$""));

		if (pos != LogString::npos)
		{
			LogString terminalName(lowerName, pos + 1, LogString::npos);
			clazz = getRegistry()[terminalName];

			if (clazz == 0)
			{
				registerClasses();
				clazz = getRegistry()[lowerName];

				if (clazz == 0)
				{
					clazz = getRegistry()[terminalName];
				}
			}
		}
		else
		{
			registerClasses();
			clazz = getRegistry()[lowerName];
		}
	}

	if (clazz == 0)
	{
		throw ClassNotFoundException(className);
	}

	return *clazz;
}",1,,123,2,,void
10116,BLOCK,-1,,"{
		LogString::size_type pos = className.find_last_of(LOG4CXX_STR("".$""));

		if (pos != LogString::npos)
		{
			LogString terminalName(lowerName, pos + 1, LogString::npos);
			clazz = getRegistry()[terminalName];

			if (clazz == 0)
			{
				registerClasses();
				clazz = getRegistry()[lowerName];

				if (clazz == 0)
				{
					clazz = getRegistry()[terminalName];
				}
			}
		}
		else
		{
			registerClasses();
			clazz = getRegistry()[lowerName];
		}
	}",2,,131,2,,void
10132,BLOCK,-1,,"{
			LogString terminalName(lowerName, pos + 1, LogString::npos);
			clazz = getRegistry()[terminalName];

			if (clazz == 0)
			{
				registerClasses();
				clazz = getRegistry()[lowerName];

				if (clazz == 0)
				{
					clazz = getRegistry()[terminalName];
				}
			}
		}",3,,135,2,,void
10151,BLOCK,-1,,"{
				registerClasses();
				clazz = getRegistry()[lowerName];

				if (clazz == 0)
				{
					clazz = getRegistry()[terminalName];
				}
			}",4,,140,2,,void
10162,BLOCK,-1,,"{
					clazz = getRegistry()[terminalName];
				}",5,,145,2,,void
10169,BLOCK,-1,,"{
			registerClasses();
			clazz = getRegistry()[lowerName];
		}",3,,151,1,,void
10180,BLOCK,-1,,"{
		throw ClassNotFoundException(className);
	}",2,,158,2,,void
10191,BLOCK,-1,,"{
	getRegistry()[StringHelper::toLowerCase(newClass.getName())] = &newClass;
	return true;
}",1,,166,2,,void
10210,BLOCK,-1,,"{
	AsyncAppender::registerClass();
	ConsoleAppender::registerClass();
	FileAppender::registerClass();
	LOG4CXX_NS::db::ODBCAppender::registerClass();
#if (defined(WIN32) || defined(_WIN32))
#if !defined(_WIN32_WCE)
	LOG4CXX_NS::nt::NTEventLogAppender::registerClass();
#endif
	LOG4CXX_NS::nt::OutputDebugStringAppender::registerClass();
#endif
	SMTPAppender::registerClass();
	JSONLayout::registerClass();
	HTMLLayout::registerClass();
	PatternLayout::registerClass();
	SimpleLayout::registerClass();
	XMLLayout::registerClass();
	LevelMatchFilter::registerClass();
	LevelRangeFilter::registerClass();
	StringMatchFilter::registerClass();
	LocationInfoFilter::registerClass();
	LOG4CXX_NS::rolling::RollingFileAppender::registerClass();
	LOG4CXX_NS::rolling::SizeBasedTriggeringPolicy::registerClass();
	LOG4CXX_NS::rolling::TimeBasedRollingPolicy::registerClass();
	LOG4CXX_NS::rolling::ManualTriggeringPolicy::registerClass();
	LOG4CXX_NS::rolling::FixedWindowRollingPolicy::registerClass();
	LO...",1,,172,1,,void
10347,BLOCK,-1,,<empty>,1,,1,1,,ANY
10352,BLOCK,-1,,"{
}",1,,34,2,,void
10357,BLOCK,-1,,"{
	if (options.size() == 0)
	{
		static WideLife<PatternConverterPtr> def = std::make_shared<ClassNamePatternConverter>(options);
		return def;
	}

	return std::make_shared<ClassNamePatternConverter>(options);
}",1,,39,2,,void
10365,BLOCK,-1,,"{
		static WideLife<PatternConverterPtr> def = std::make_shared<ClassNamePatternConverter>(options);
		return def;
	}",2,,41,2,,void
10392,BLOCK,-1,,"{
	int initialLength = (int)toAppendTo.length();
	append(toAppendTo, event->getLocationInformation().getClassName());
	abbreviate(initialLength, toAppendTo);
}",1,,53,4,,void
10426,BLOCK,-1,,<empty>,1,,1,1,,ANY
10429,BLOCK,-1,,"{
	Class::registerClass((*accessor)());
}",1,,25,2,,void
10453,BLOCK,-1,,<empty>,1,,1,1,,ANY
10457,BLOCK,-1,,"{
}",1,,34,1,,void
10462,BLOCK,-1,,"{
	static WideLife<PatternConverterPtr> instance = std::make_shared<ColorEndPatternConverter>();
	return instance;
}",1,,39,2,,void
10478,BLOCK,-1,,"{

	// Reset all colors on the output(code 0)
	// Code 39 would be to reset colors only
	toAppendTo.append(LOG4CXX_STR(""\x1B[0m""));
}",1,,48,4,,void
10503,BLOCK,-1,,<empty>,1,,1,1,,ANY
10510,BLOCK,-1,,"{
	int numberToConvert = 0;

	if(StringHelper::equalsIgnoreCase(color, LOG4CXX_STR(""BLACK""), LOG4CXX_STR(""black""))){
		numberToConvert = 30;
	}else if(StringHelper::equalsIgnoreCase(color, LOG4CXX_STR(""RED""), LOG4CXX_STR(""red""))){
		numberToConvert = 31;
	}else if(StringHelper::equalsIgnoreCase(color, LOG4CXX_STR(""GREEN""), LOG4CXX_STR(""green""))){
		numberToConvert = 32;
	}else if(StringHelper::equalsIgnoreCase(color, LOG4CXX_STR(""YELLOW""), LOG4CXX_STR(""yellow""))){
		numberToConvert = 33;
	}else if(StringHelper::equalsIgnoreCase(color, LOG4CXX_STR(""BLUE""), LOG4CXX_STR(""blue""))){
		numberToConvert = 34;
	}else if(StringHelper::equalsIgnoreCase(color, LOG4CXX_STR(""MAGENTA""), LOG4CXX_STR(""magenta""))){
		numberToConvert = 35;
	}else if(StringHelper::equalsIgnoreCase(color, LOG4CXX_STR(""CYAN""), LOG4CXX_STR(""cyan""))){
		numberToConvert = 36;
	}else if(StringHelper::equalsIgnoreCase(color, LOG4CXX_STR(""WHITE""), LOG4CXX_STR(""white""))){
		numberToConvert = 37;
	}

	if( numberToConvert == 0 ){...",92,,34,4,,void
10525,BLOCK,-1,,"{
		numberToConvert = 30;
	}",87,,37,2,,void
10530,BLOCK,-1,,<empty>,8,,39,1,,void
10541,BLOCK,-1,,"{
		numberToConvert = 31;
	}",89,,39,2,,void
10546,BLOCK,-1,,<empty>,8,,41,1,,void
10557,BLOCK,-1,,"{
		numberToConvert = 32;
	}",93,,41,2,,void
10562,BLOCK,-1,,<empty>,8,,43,1,,void
10573,BLOCK,-1,,"{
		numberToConvert = 33;
	}",95,,43,2,,void
10578,BLOCK,-1,,<empty>,8,,45,1,,void
10589,BLOCK,-1,,"{
		numberToConvert = 34;
	}",91,,45,2,,void
10594,BLOCK,-1,,<empty>,8,,47,1,,void
10605,BLOCK,-1,,"{
		numberToConvert = 35;
	}",97,,47,2,,void
10610,BLOCK,-1,,<empty>,8,,49,1,,void
10621,BLOCK,-1,,"{
		numberToConvert = 36;
	}",91,,49,2,,void
10626,BLOCK,-1,,<empty>,8,,51,1,,void
10637,BLOCK,-1,,"{
		numberToConvert = 37;
	}",93,,51,2,,void
10645,BLOCK,-1,,"{
		return LOG4CXX_STR("""");
	}",28,,55,2,,void
10654,BLOCK,-1,,"{
		numberToConvert += 10;
	}",29,,59,2,,void
10672,BLOCK,-1,,"{
	int numberToConvert = 0;

	if(StringHelper::equalsIgnoreCase(graphicsMode, LOG4CXX_STR(""BOLD""), LOG4CXX_STR(""bold""))){
		numberToConvert = 1;
	}else if(StringHelper::equalsIgnoreCase(graphicsMode, LOG4CXX_STR(""DIM""), LOG4CXX_STR(""dim""))){
		numberToConvert = 2;
	}else if(StringHelper::equalsIgnoreCase(graphicsMode, LOG4CXX_STR(""ITALIC""), LOG4CXX_STR(""italic""))){
		numberToConvert = 3;
	}else if(StringHelper::equalsIgnoreCase(graphicsMode, LOG4CXX_STR(""UNDERLINE""), LOG4CXX_STR(""underline""))){
		numberToConvert = 4;
	}else if(StringHelper::equalsIgnoreCase(graphicsMode, LOG4CXX_STR(""BLINKING""), LOG4CXX_STR(""blinking""))){
		numberToConvert = 5;
	}else if(StringHelper::equalsIgnoreCase(graphicsMode, LOG4CXX_STR(""INVERSE""), LOG4CXX_STR(""inverse""))){
		numberToConvert = 7;
	}else if(StringHelper::equalsIgnoreCase(graphicsMode, LOG4CXX_STR(""STRIKETHROUGH""), LOG4CXX_STR(""strikethrough""))){
		numberToConvert = 9;
	}

	if( numberToConvert == 0 ){
		return LOG4CXX_STR("""");
	}
	LogString ret...",87,,66,3,,void
10687,BLOCK,-1,,"{
		numberToConvert = 1;
	}",92,,69,2,,void
10692,BLOCK,-1,,<empty>,8,,71,1,,void
10703,BLOCK,-1,,"{
		numberToConvert = 2;
	}",96,,71,2,,void
10708,BLOCK,-1,,<empty>,8,,73,1,,void
10719,BLOCK,-1,,"{
		numberToConvert = 3;
	}",102,,73,2,,void
10724,BLOCK,-1,,<empty>,8,,75,1,,void
10735,BLOCK,-1,,"{
		numberToConvert = 4;
	}",108,,75,2,,void
10740,BLOCK,-1,,<empty>,8,,77,1,,void
10751,BLOCK,-1,,"{
		numberToConvert = 5;
	}",106,,77,2,,void
10756,BLOCK,-1,,<empty>,8,,79,1,,void
10767,BLOCK,-1,,"{
		numberToConvert = 7;
	}",104,,79,2,,void
10772,BLOCK,-1,,<empty>,8,,81,1,,void
10783,BLOCK,-1,,"{
		numberToConvert = 9;
	}",116,,81,2,,void
10791,BLOCK,-1,,"{
		return LOG4CXX_STR("""");
	}",28,,85,2,,void
10810,BLOCK,-1,,"{
	LogString strInParens;
	bool inParens = false;
	bool hasParens = false;
	size_t x = 0;

	for(x = 0; x < sequence.length(); x++){
		if( sequence[x] == '(' && !inParens ){
			inParens = true;
			hasParens = true;
			continue;
		}else if( sequence[x] == '(' && inParens ){
			// Unbalanced parens - parse invalid
			return LOG4CXX_STR("""");
		}

		if( sequence[x] == ')' && inParens ){
			hasParens = true;
			inParens = false;
			break;
		}

		if( inParens ){
			strInParens.push_back(sequence[x]);
		}
	}

	if( (x != (sequence.length() - 1) || inParens) && hasParens ){
		// Unbalanced parens, or more data in the string than we expected - parse invalid
		return LOG4CXX_STR("""");
	}

	if(StringHelper::startsWith(sequence, LOG4CXX_STR(""fg(""))){
		// Parse foreground
		return colorToANSISequence(strInParens, true, pool);
	}else if(StringHelper::startsWith(sequence, LOG4CXX_STR(""bg(""))){
		return colorToANSISequence(strInParens, false, pool);
	}else{
		return graphicsModeToANSISequence(sequenc...",78,,93,3,,void
10825,BLOCK,-1,,<empty>,2,,99,1,,void
10837,BLOCK,4,,"{
		if( sequence[x] == '(' && !inParens ){
			inParens = true;
			hasParens = true;
			continue;
		}else if( sequence[x] == '(' && inParens ){
			// Unbalanced parens - parse invalid
			return LOG4CXX_STR("""");
		}

		if( sequence[x] == ')' && inParens ){
			hasParens = true;
			inParens = false;
			break;
		}

		if( inParens ){
			strInParens.push_back(sequence[x]);
		}
	}",40,,99,4,,void
10847,BLOCK,-1,,"{
			inParens = true;
			hasParens = true;
			continue;
		}",40,,100,2,,void
10856,BLOCK,-1,,<empty>,9,,104,1,,void
10865,BLOCK,-1,,"{
			// Unbalanced parens - parse invalid
			return LOG4CXX_STR("""");
		}",45,,104,2,,void
10877,BLOCK,-1,,"{
			hasParens = true;
			inParens = false;
			break;
		}",39,,109,2,,void
10887,BLOCK,-1,,"{
			strInParens.push_back(sequence[x]);
		}",17,,115,2,,void
10908,BLOCK,-1,,"{
		// Unbalanced parens, or more data in the string than we expected - parse invalid
		return LOG4CXX_STR("""");
	}",63,,120,2,,void
10920,BLOCK,-1,,"{
		// Parse foreground
		return colorToANSISequence(strInParens, true, pool);
	}",60,,125,2,,void
10927,BLOCK,-1,,<empty>,8,,128,1,,void
10936,BLOCK,-1,,"{
		return colorToANSISequence(strInParens, false, pool);
	}",66,,128,2,,void
10943,BLOCK,-1,,"{
		return graphicsModeToANSISequence(sequence, pool);
	}",7,,130,1,,void
10954,BLOCK,-1,,<empty>,41,,138,3,,void
10964,BLOCK,-1,,"{
}",1,,151,1,,void
10969,BLOCK,-1,,"{
	static WideLife<PatternConverterPtr> instance = std::make_shared<ColorStartPatternConverter>();
	return instance;
}",1,,156,2,,void
10985,BLOCK,-1,,"{

	LOG4CXX_NS::LevelPtr lvl = event->getLevel();

	switch (lvl->toInt())
	{
		case LOG4CXX_NS::Level::FATAL_INT:
			toAppendTo.append(priv->m_fatalColor);
			break;

		case LOG4CXX_NS::Level::ERROR_INT:
			toAppendTo.append(priv->m_errorColor);
			break;

		case LOG4CXX_NS::Level::WARN_INT:
			toAppendTo.append(priv->m_warnColor);
			break;

		case LOG4CXX_NS::Level::INFO_INT:
			toAppendTo.append(priv->m_infoColor);
			break;

		case LOG4CXX_NS::Level::DEBUG_INT:
			toAppendTo.append(priv->m_debugColor);
			break;

		case LOG4CXX_NS::Level::TRACE_INT:
			toAppendTo.append(priv->m_traceColor);
			break;

		default:
			break;
	}
}",1,,165,4,,void
10998,BLOCK,-1,,"{
		case LOG4CXX_NS::Level::FATAL_INT:
			toAppendTo.append(priv->m_fatalColor);
			break;

		case LOG4CXX_NS::Level::ERROR_INT:
			toAppendTo.append(priv->m_errorColor);
			break;

		case LOG4CXX_NS::Level::WARN_INT:
			toAppendTo.append(priv->m_warnColor);
			break;

		case LOG4CXX_NS::Level::INFO_INT:
			toAppendTo.append(priv->m_infoColor);
			break;

		case LOG4CXX_NS::Level::DEBUG_INT:
			toAppendTo.append(priv->m_debugColor);
			break;

		case LOG4CXX_NS::Level::TRACE_INT:
			toAppendTo.append(priv->m_traceColor);
			break;

		default:
			break;
	}",2,,170,2,,void
11010,BLOCK,1,,<empty>,,,,1,,void
11031,BLOCK,1,,<empty>,,,,1,,void
11052,BLOCK,1,,<empty>,,,,1,,void
11073,BLOCK,1,,<empty>,,,,1,,void
11094,BLOCK,1,,<empty>,,,,1,,void
11115,BLOCK,1,,<empty>,,,,1,,void
11131,BLOCK,-1,,"{
	parseColor(color, &(priv->m_fatalColor));
}",71,,200,2,,void
11136,BLOCK,1,,<empty>,,,,1,,void
11149,BLOCK,-1,,"{
	parseColor(color, &(priv->m_errorColor));
}",71,,204,2,,void
11154,BLOCK,1,,<empty>,,,,1,,void
11167,BLOCK,-1,,"{
	parseColor(color, &(priv->m_warnColor));
}",70,,208,2,,void
11172,BLOCK,1,,<empty>,,,,1,,void
11185,BLOCK,-1,,"{
	parseColor(color, &(priv->m_infoColor));
}",70,,212,2,,void
11190,BLOCK,1,,<empty>,,,,1,,void
11203,BLOCK,-1,,"{
	parseColor(color, &(priv->m_debugColor));
}",71,,216,2,,void
11208,BLOCK,1,,<empty>,,,,1,,void
11221,BLOCK,-1,,"{
	parseColor(color, &(priv->m_traceColor));
}",71,,220,2,,void
11226,BLOCK,1,,<empty>,,,,1,,void
11240,BLOCK,-1,,"{
	LogString lower = StringHelper::toLowerCase(color);
	Pool pool;

	// If the color we are trying to parse is blank, clear our result
	if(StringHelper::trim(color).empty() ||
			StringHelper::equalsIgnoreCase(color,
										   LOG4CXX_STR(""NONE""),
										   LOG4CXX_STR(""none""))){
		result->clear();
		return;
	}

	if( StringHelper::startsWith(lower, LOG4CXX_STR(""\\x1b"")) ){
		if( color[color.size() - 1] != 'm' ){
			// In order for this to be a valid ANSI escape sequence,
			// it must end with an 'm'.  If it does not, reject.
			return;
		}
		// We start with an escape sequence, copy the data over after the escape byte
		result->clear();
		result->append(LOG4CXX_STR(""\x1b""));
		for( size_t x = 4; x < color.size(); x++ ){
			result->push_back(color[x]);
		}
	}else{
		// We do not start with an escape sequence: try to parse color
		// Escape sequence information:
		// https://gist.github.com/fnky/458719343aabd01cfb17a3a4f7296797
		// https://en.wikipedia.org/wiki/ANSI_escape_cod...",87,,224,3,,void
11269,BLOCK,-1,,"{
		result->clear();
		return;
	}",35,,232,2,,void
11283,BLOCK,-1,,"{
		if( color[color.size() - 1] != 'm' ){
			// In order for this to be a valid ANSI escape sequence,
			// it must end with an 'm'.  If it does not, reject.
			return;
		}
		// We start with an escape sequence, copy the data over after the escape byte
		result->clear();
		result->append(LOG4CXX_STR(""\x1b""));
		for( size_t x = 4; x < color.size(); x++ ){
			result->push_back(color[x]);
		}
	}",61,,237,2,,void
11295,BLOCK,-1,,"{
			// In order for this to be a valid ANSI escape sequence,
			// it must end with an 'm'.  If it does not, reject.
			return;
		}",39,,238,2,,void
11308,BLOCK,-1,,<empty>,3,,246,1,,void
11321,BLOCK,4,,"{
			result->push_back(color[x]);
		}",45,,246,4,,void
11330,BLOCK,-1,,"{
		// We do not start with an escape sequence: try to parse color
		// Escape sequence information:
		// https://gist.github.com/fnky/458719343aabd01cfb17a3a4f7296797
		// https://en.wikipedia.org/wiki/ANSI_escape_code
		result->clear();
		result->append(LOG4CXX_STR(""\x1b[""));
		LogString tmp;
		for( size_t x = 0; x < color.size(); x++ ){
			if(color[x] == '|' ){
				LogString toAppend = convertSingleSequence(tmp, pool);
				tmp.clear();
				if(!toAppend.empty()){
					result->push_back(';');
					result->append(toAppend);
				}
			}else{
				tmp.push_back(color[x]);
			}
		}
		LogString toAppend = convertSingleSequence(tmp, pool);
		tmp.clear();
		if(!toAppend.empty()){
			result->push_back(';');
			result->append(toAppend);
		}
		result->append(LOG4CXX_STR(""m""));
	}",7,,249,1,,void
11343,BLOCK,-1,,<empty>,3,,257,1,,void
11356,BLOCK,4,,"{
			if(color[x] == '|' ){
				LogString toAppend = convertSingleSequence(tmp, pool);
				tmp.clear();
				if(!toAppend.empty()){
					result->push_back(';');
					result->append(toAppend);
				}
			}else{
				tmp.push_back(color[x]);
			}
		}",45,,257,4,,void
11363,BLOCK,-1,,"{
				LogString toAppend = convertSingleSequence(tmp, pool);
				tmp.clear();
				if(!toAppend.empty()){
					result->push_back(';');
					result->append(toAppend);
				}
			}",24,,258,2,,void
11380,BLOCK,-1,,"{
					result->push_back(';');
					result->append(toAppend);
				}",26,,261,2,,void
11392,BLOCK,-1,,"{
				tmp.push_back(color[x]);
			}",9,,265,1,,void
11416,BLOCK,-1,,"{
			result->push_back(';');
			result->append(toAppend);
		}",24,,271,2,,void
11447,BLOCK,-1,,<empty>,1,,1,1,,ANY
11451,BLOCK,-1,,"{
}",1,,32,1,,void
11476,BLOCK,-1,,<empty>,1,,1,1,,ANY
11480,BLOCK,-1,,<empty>,18,,34,2,,void
11487,BLOCK,-1,,"{
}",1,,45,1,,void
11492,BLOCK,-1,,"{
	setLayout(layout);
	Pool p;
	setWriter(std::make_shared<SystemOutWriter>());
	WriterAppender::activateOptions(p);
}",1,,50,2,,void
11511,BLOCK,-1,,"{
	setLayout(layout);
	setTarget(target);
	Pool p;
	ConsoleAppender::activateOptions(p);
}",1,,59,3,,void
11525,BLOCK,-1,,"{
	finalize();
}",1,,67,1,,void
11530,BLOCK,-1,,"{
	static const WideLife<LogString> name(LOG4CXX_STR(""System.out""));
	return name;
}",1,,72,1,,void
11540,BLOCK,-1,,"{
	static const WideLife<LogString> name(LOG4CXX_STR(""System.err""));
	return name;
}",1,,78,1,,void
11551,BLOCK,-1,,"{
	LogString v = StringHelper::trim(value);

	if (StringHelper::equalsIgnoreCase(v,
			LOG4CXX_STR(""SYSTEM.OUT""), LOG4CXX_STR(""system.out"")))
	{
		_priv->target = getSystemOut();
	}
	else if (StringHelper::equalsIgnoreCase(v,
			LOG4CXX_STR(""SYSTEM.ERR""), LOG4CXX_STR(""system.err"")))
	{
		_priv->target = getSystemErr();
	}
	else
	{
		targetWarn(value);
	}
}",1,,84,2,,void
11570,BLOCK,-1,,"{
		_priv->target = getSystemOut();
	}",2,,89,2,,void
11573,BLOCK,1,,<empty>,,,,1,,void
11584,BLOCK,-1,,<empty>,7,,92,1,,void
11595,BLOCK,-1,,"{
		_priv->target = getSystemErr();
	}",2,,94,2,,void
11598,BLOCK,1,,<empty>,,,,1,,void
11609,BLOCK,-1,,"{
		targetWarn(value);
	}",2,,98,1,,void
11615,BLOCK,-1,,"{
	return _priv->target;
}",1,,104,1,,void
11618,BLOCK,1,,<empty>,,,,1,,void
11631,BLOCK,-1,,"{
	LogLog::warn(((LogString) LOG4CXX_STR(""[""))
		+ val +  LOG4CXX_STR(""] should be system.out or system.err.""));
	LogLog::warn(LOG4CXX_STR(""Using previously set target, System.out by default.""));
}",1,,109,2,,void
11655,BLOCK,-1,,"{
	if (StringHelper::equalsIgnoreCase(_priv->target,
			LOG4CXX_STR(""SYSTEM.OUT""), LOG4CXX_STR(""system.out"")))
	{
		WriterPtr writer1 = std::make_shared<SystemOutWriter>();
		setWriter(writer1);
	}
	else if (StringHelper::equalsIgnoreCase(_priv->target,
			LOG4CXX_STR(""SYSTEM.ERR""), LOG4CXX_STR(""system.err"")))
	{
		WriterPtr writer1 = std::make_shared<SystemErrWriter>();
		setWriter(writer1);
	}

	WriterAppender::activateOptions(p);
}",1,,116,2,,void
11662,BLOCK,1,,<empty>,,,,1,,void
11675,BLOCK,-1,,"{
		WriterPtr writer1 = std::make_shared<SystemOutWriter>();
		setWriter(writer1);
	}",2,,119,2,,void
11686,BLOCK,-1,,<empty>,7,,123,1,,void
11693,BLOCK,1,,<empty>,,,,1,,void
11706,BLOCK,-1,,"{
		WriterPtr writer1 = std::make_shared<SystemErrWriter>();
		setWriter(writer1);
	}",2,,125,2,,void
11726,BLOCK,-1,,"{
	if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""TARGET""), LOG4CXX_STR(""target"")))
	{
		setTarget(value);
	}
	else
	{
		WriterAppender::setOption(option, value);
	}
}",1,,134,3,,void
11737,BLOCK,-1,,"{
		setTarget(value);
	}",2,,137,2,,void
11741,BLOCK,-1,,"{
		WriterAppender::setOption(option, value);
	}",2,,141,1,,void
11766,BLOCK,-1,,<empty>,1,,1,1,,ANY
11770,BLOCK,-1,,<empty>,67,,31,2,,void
11780,BLOCK,-1,,"{
	if (maxSize1 < 1)
	{
		LogString msg(LOG4CXX_STR(""The maxSize argument (""));
		Pool p;
		StringHelper::toString(maxSize1, p, msg);
		msg.append(LOG4CXX_STR("") is not a positive integer.""));
		throw IllegalArgumentException(msg);
	}
}",1,,47,2,,void
11785,BLOCK,-1,,"{
		LogString msg(LOG4CXX_STR(""The maxSize argument (""));
		Pool p;
		StringHelper::toString(maxSize1, p, msg);
		msg.append(LOG4CXX_STR("") is not a positive integer.""));
		throw IllegalArgumentException(msg);
	}",2,,49,2,,void
11810,BLOCK,-1,,"{
}",1,,59,1,,void
11815,BLOCK,-1,,"{
	m_priv->ea[m_priv->last] = event;

	if (++m_priv->last == m_priv->maxSize)
	{
		m_priv->last = 0;
	}

	if (m_priv->numElems < m_priv->maxSize)
	{
		m_priv->numElems++;
	}
	else if (++m_priv->first == m_priv->maxSize)
	{
		m_priv->first = 0;
	}
}",1,,66,2,,void
11834,BLOCK,-1,,"{
		m_priv->last = 0;
	}",2,,70,2,,void
11848,BLOCK,-1,,"{
		m_priv->numElems++;
	}",2,,75,2,,void
11854,BLOCK,-1,,<empty>,7,,78,1,,void
11864,BLOCK,-1,,"{
		m_priv->first = 0;
	}",2,,79,2,,void
11874,BLOCK,-1,,"{
	if (i < 0 || i >= m_priv->numElems)
	{
		return 0;
	}

	return m_priv->ea[(m_priv->first + i) % m_priv->maxSize];
}",1,,91,2,,void
11885,BLOCK,-1,,"{
		return 0;
	}",2,,93,2,,void
11905,BLOCK,-1,,"{
	LoggingEventPtr r;

	if (m_priv->numElems > 0)
	{
		m_priv->numElems--;
		r = m_priv->ea[m_priv->first];
		m_priv->ea[m_priv->first] = 0;

		if (++m_priv->first == m_priv->maxSize)
		{
			m_priv->first = 0;
		}
	}

	return r;
}",1,,105,1,,void
11913,BLOCK,-1,,"{
		m_priv->numElems--;
		r = m_priv->ea[m_priv->first];
		m_priv->ea[m_priv->first] = 0;

		if (++m_priv->first == m_priv->maxSize)
		{
			m_priv->first = 0;
		}
	}",2,,109,2,,void
11945,BLOCK,-1,,"{
			m_priv->first = 0;
		}",3,,115,2,,void
11957,BLOCK,-1,,"{
	if (newSize < 0)
	{
		LogString msg(LOG4CXX_STR(""Negative array size [""));
		Pool p;
		StringHelper::toString(newSize, p, msg);
		msg.append(LOG4CXX_STR(""] not allowed.""));
		throw IllegalArgumentException(msg);
	}

	if (newSize == m_priv->numElems)
	{
		return;    // nothing to do
	}

	LoggingEventList temp(newSize);

	int loopLen = newSize < m_priv->numElems ? newSize : m_priv->numElems;
	int i;

	for (i = 0; i < loopLen; i++)
	{
		temp[i] = m_priv->ea[m_priv->first];
		m_priv->ea[m_priv->first] = 0;

		if (++m_priv->first == m_priv->numElems)
		{
			m_priv->first = 0;
		}
	}

	m_priv->ea = temp;
	m_priv->first = 0;
	m_priv->numElems = loopLen;
	m_priv->maxSize = newSize;

	if (loopLen == newSize)
	{
		m_priv->last = 0;
	}
	else
	{
		m_priv->last = loopLen;
	}
}",1,,128,2,,void
11962,BLOCK,-1,,"{
		LogString msg(LOG4CXX_STR(""Negative array size [""));
		Pool p;
		StringHelper::toString(newSize, p, msg);
		msg.append(LOG4CXX_STR(""] not allowed.""));
		throw IllegalArgumentException(msg);
	}",2,,130,2,,void
11990,BLOCK,-1,,"{
		return;    // nothing to do
	}",2,,139,2,,void
12010,BLOCK,-1,,<empty>,2,,148,1,,void
12019,BLOCK,4,,"{
		temp[i] = m_priv->ea[m_priv->first];
		m_priv->ea[m_priv->first] = 0;

		if (++m_priv->first == m_priv->numElems)
		{
			m_priv->first = 0;
		}
	}",2,,149,4,,void
12049,BLOCK,-1,,"{
			m_priv->first = 0;
		}",3,,154,2,,void
12079,BLOCK,-1,,"{
		m_priv->last = 0;
	}",2,,165,2,,void
12086,BLOCK,-1,,"{
		m_priv->last = loopLen;
	}",2,,169,1,,void
12095,BLOCK,-1,,"{
	return m_priv->maxSize;
}",1,,175,1,,void
12103,BLOCK,-1,,"{
	return m_priv->numElems;
}",1,,180,1,,void
12118,BLOCK,-1,,<empty>,1,,1,1,,ANY
12123,BLOCK,-1,,"{
	}",2,,27,3,,void
12131,BLOCK,-1,,"{
	}",2,,33,5,,void
12138,BLOCK,-1,,"{
	}",2,,38,4,,void
12147,BLOCK,-1,,"{
	}",2,,44,6,,void
12160,BLOCK,-1,,"{
}",1,,69,3,,void
12168,BLOCK,-1,,"{
}",1,,78,5,,void
12175,BLOCK,-1,,"{
}",1,,85,4,,void
12184,BLOCK,-1,,"{
}",1,,93,6,,void
12188,BLOCK,-1,,"{
}",1,,97,1,,void
12192,BLOCK,-1,,"{
	return m_priv->address;
}",1,,101,1,,void
12200,BLOCK,-1,,"{
	return m_priv->buf;
}",1,,106,1,,void
12208,BLOCK,-1,,"{
	return m_priv->length;
}",1,,111,1,,void
12216,BLOCK,-1,,"{
	return m_priv->offset;
}",1,,116,1,,void
12224,BLOCK,-1,,"{
	return m_priv->port;
}",1,,121,1,,void
12233,BLOCK,-1,,"{
	m_priv->address = address1;
}",1,,126,2,,void
12243,BLOCK,-1,,"{
	m_priv->buf = buf1;
}",1,,131,2,,void
12255,BLOCK,-1,,"{
	m_priv->buf = buf1;
	m_priv->offset = offset1;
	m_priv->length = length1;
}",1,,136,4,,void
12275,BLOCK,-1,,"{
	m_priv->length = length1;
}",1,,143,2,,void
12285,BLOCK,-1,,"{
	m_priv->port = port1;
}",1,,148,2,,void
12311,BLOCK,-1,,<empty>,1,,1,1,,ANY
12316,BLOCK,-1,,<empty>,1,,31,2,,void
12320,BLOCK,-1,,"{
	try
	{
		close();
	}
	catch (SocketException&)
	{
	}
}",1,,34,1,,void
12322,BLOCK,-1,,"{
		close();
	}",2,,36,1,,void
12324,BLOCK,2,,"{
	}",2,,40,2,,void
12328,BLOCK,-1,,"{
}",1,,46,1,,void
12332,BLOCK,-1,,"{
	return m_priv->address;
}",1,,50,1,,void
12340,BLOCK,-1,,"{
	return m_priv->localAddress;
}",1,,55,1,,void
12348,BLOCK,-1,,"{
	return m_priv->localPort;
}",1,,60,1,,void
12356,BLOCK,-1,,"{
	return m_priv->port;
}",1,,65,1,,void
12364,BLOCK,-1,,"{
	return m_priv->localPort != 0;
}",1,,70,1,,void
12374,BLOCK,-1,,"{
	return m_priv->port != 0;
}",1,,75,1,,void
12384,BLOCK,-1,,"{
	return std::make_unique<APRDatagramSocket>();
}",49,,79,1,,void
12394,BLOCK,-1,,"{
	auto sock = std::make_unique<APRDatagramSocket>(localPort1);
	InetAddressPtr bindAddr = InetAddress::anyAddress();

	sock->bind(localPort1, bindAddr);
	return sock;
}",63,,83,2,,void
12425,BLOCK,-1,,"{
	auto sock = std::make_unique<APRDatagramSocket>(localPort1, localAddress1);

	sock->bind(localPort1, localAddress1);
	return sock;
}",93,,91,3,,void
12459,BLOCK,-1,,<empty>,1,,1,1,,ANY
12468,BLOCK,-1,,"{
}",1,,36,1,,void
12473,BLOCK,-1,,"{
}",1,,40,2,,void
12477,BLOCK,-1,,"{
}",1,,44,1,,void
12481,BLOCK,-1,,"{
	return 86400000000ull;
}",1,,48,1,,void
12487,BLOCK,-1,,"{
	return LOG4CXX_USEC_PER_SEC;
}",1,,53,1,,void
12490,BLOCK,1,,<empty>,,,,1,,void
12495,BLOCK,-1,,"{
	return ((time / LOG4CXX_USEC_PER_SEC) + 1) * LOG4CXX_USEC_PER_SEC;
}",1,,59,1,,void
12502,BLOCK,1,,<empty>,,,,1,,void
12506,BLOCK,1,,<empty>,,,,1,,void
12512,BLOCK,-1,,"{
	getCurrentTimeFn = fn;
}",58,,63,2,,void
12519,BLOCK,-1,,"{
	return getCurrentTimeFn ? getCurrentTimeFn() : getCurrentTimeStd();
}",35,,67,1,,void
12528,BLOCK,-1,,"{
	return std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::system_clock::now().time_since_epoch()).count();
}",41,,71,1,,void
12568,BLOCK,-1,,<empty>,1,,1,1,,ANY
12572,BLOCK,-1,,<empty>,27,,28,1,,void
12577,BLOCK,-1,,<empty>,50,,30,2,,void
12584,BLOCK,-1,,"{
	StringHelper::toString(n, p, s);
}",1,,33,4,,void
12595,BLOCK,-1,,<empty>,26,,37,1,,void
12628,BLOCK,-1,,<empty>,1,,1,1,,ANY
12634,BLOCK,-1,,<empty>,11,,41,4,,void
12642,BLOCK,-1,,"{
}",1,,56,2,,void
12646,BLOCK,-1,,<empty>,47,,59,1,,void
12651,BLOCK,-1,,"{
	DateFormatPtr df;
	int maximumCacheValidity = 1000000;

	if (options.size() == 0)
	{
		df = std::make_shared<ISO8601DateFormat>();
	}
	else
	{
		LogString dateFormatStr(options[0]);

		if (dateFormatStr.empty() ||
			StringHelper::equalsIgnoreCase(dateFormatStr,
				LOG4CXX_STR(""ISO8601""), LOG4CXX_STR(""iso8601"")))
		{
			df = std::make_shared<ISO8601DateFormat>();
		}
		else if (StringHelper::equalsIgnoreCase(dateFormatStr,
				LOG4CXX_STR(""ABSOLUTE""), LOG4CXX_STR(""absolute"")))
		{
			df = std::make_shared<AbsoluteTimeDateFormat>();
		}
		else if (StringHelper::equalsIgnoreCase(dateFormatStr,
				LOG4CXX_STR(""DATE""), LOG4CXX_STR(""date"")))
		{
			df = std::make_shared<DateTimeDateFormat>();
		}
		else
		{
			if (dateFormatStr.find(0x25 /*'%'*/) == std::string::npos)
			{
				try
				{
					df = std::make_shared<SimpleDateFormat>(dateFormatStr);
					maximumCacheValidity =
						CachedDateFormat::getMaximumCacheValidity(dateFormatStr);
				}
				catch (IllegalArgumentException& e)
...",1,,62,2,,void
12664,BLOCK,-1,,"{
		df = std::make_shared<ISO8601DateFormat>();
	}",2,,67,2,,void
12672,BLOCK,-1,,"{
		LogString dateFormatStr(options[0]);

		if (dateFormatStr.empty() ||
			StringHelper::equalsIgnoreCase(dateFormatStr,
				LOG4CXX_STR(""ISO8601""), LOG4CXX_STR(""iso8601"")))
		{
			df = std::make_shared<ISO8601DateFormat>();
		}
		else if (StringHelper::equalsIgnoreCase(dateFormatStr,
				LOG4CXX_STR(""ABSOLUTE""), LOG4CXX_STR(""absolute"")))
		{
			df = std::make_shared<AbsoluteTimeDateFormat>();
		}
		else if (StringHelper::equalsIgnoreCase(dateFormatStr,
				LOG4CXX_STR(""DATE""), LOG4CXX_STR(""date"")))
		{
			df = std::make_shared<DateTimeDateFormat>();
		}
		else
		{
			if (dateFormatStr.find(0x25 /*'%'*/) == std::string::npos)
			{
				try
				{
					df = std::make_shared<SimpleDateFormat>(dateFormatStr);
					maximumCacheValidity =
						CachedDateFormat::getMaximumCacheValidity(dateFormatStr);
				}
				catch (IllegalArgumentException& e)
				{
					df = std::make_shared<ISO8601DateFormat>();
					LogLog::warn(((LogString)
							LOG4CXX_STR(""Could not instantiate SimpleDateFormat...",2,,71,1,,void
12693,BLOCK,-1,,"{
			df = std::make_shared<ISO8601DateFormat>();
		}",3,,77,2,,void
12701,BLOCK,-1,,<empty>,8,,80,1,,void
12712,BLOCK,-1,,"{
			df = std::make_shared<AbsoluteTimeDateFormat>();
		}",3,,82,2,,void
12720,BLOCK,-1,,<empty>,8,,85,1,,void
12731,BLOCK,-1,,"{
			df = std::make_shared<DateTimeDateFormat>();
		}",3,,87,2,,void
12739,BLOCK,-1,,"{
			if (dateFormatStr.find(0x25 /*'%'*/) == std::string::npos)
			{
				try
				{
					df = std::make_shared<SimpleDateFormat>(dateFormatStr);
					maximumCacheValidity =
						CachedDateFormat::getMaximumCacheValidity(dateFormatStr);
				}
				catch (IllegalArgumentException& e)
				{
					df = std::make_shared<ISO8601DateFormat>();
					LogLog::warn(((LogString)
							LOG4CXX_STR(""Could not instantiate SimpleDateFormat with pattern ""))
						+ dateFormatStr, e);
				}
			}
			else
			{
				df = std::make_shared<StrftimeDateFormat>(dateFormatStr);
			}
		}",3,,91,1,,void
12752,BLOCK,-1,,"{
				try
				{
					df = std::make_shared<SimpleDateFormat>(dateFormatStr);
					maximumCacheValidity =
						CachedDateFormat::getMaximumCacheValidity(dateFormatStr);
				}
				catch (IllegalArgumentException& e)
				{
					df = std::make_shared<ISO8601DateFormat>();
					LogLog::warn(((LogString)
							LOG4CXX_STR(""Could not instantiate SimpleDateFormat with pattern ""))
						+ dateFormatStr, e);
				}
			}",4,,93,2,,void
12754,BLOCK,-1,,"{
					df = std::make_shared<SimpleDateFormat>(dateFormatStr);
					maximumCacheValidity =
						CachedDateFormat::getMaximumCacheValidity(dateFormatStr);
				}",5,,95,1,,void
12771,BLOCK,2,,"{
					df = std::make_shared<ISO8601DateFormat>();
					LogLog::warn(((LogString)
							LOG4CXX_STR(""Could not instantiate SimpleDateFormat with pattern ""))
						+ dateFormatStr, e);
				}",5,,101,2,,void
12790,BLOCK,-1,,"{
				df = std::make_shared<StrftimeDateFormat>(dateFormatStr);
			}",4,,109,1,,void
12807,BLOCK,-1,,"{
			TimeZonePtr tz(TimeZone::getTimeZone(options[1]));

			if (tz != NULL)
			{
				df->setTimeZone(tz);
			}
		}",3,,115,2,,void
12821,BLOCK,-1,,"{
				df->setTimeZone(tz);
			}",4,,119,2,,void
12831,BLOCK,-1,,"{
		df = std::make_shared<CachedDateFormat>(df, maximumCacheValidity);
	}",2,,126,2,,void
12850,BLOCK,-1,,"{
	return std::make_shared<DatePatternConverter>(options);
}",1,,135,2,,void
12865,BLOCK,-1,,"{
	priv->df->format(toAppendTo, event->getTimeStamp(), p);
}",1,,143,4,,void
12867,BLOCK,1,,<empty>,,,,1,,void
12891,BLOCK,-1,,"{
	DatePtr date = LOG4CXX_NS::cast<Date>(obj);

	if (date != NULL)
	{
		format(date, toAppendTo, p);
	}
	else
	{
		LoggingEventPtr event = LOG4CXX_NS::cast<LoggingEvent>(obj);

		if (event != NULL)
		{
			format(event, toAppendTo, p);
		}
	}
}",1,,154,4,,void
12906,BLOCK,-1,,"{
		format(date, toAppendTo, p);
	}",2,,158,2,,void
12912,BLOCK,-1,,"{
		LoggingEventPtr event = LOG4CXX_NS::cast<LoggingEvent>(obj);

		if (event != NULL)
		{
			format(event, toAppendTo, p);
		}
	}",2,,162,1,,void
12927,BLOCK,-1,,"{
			format(event, toAppendTo, p);
		}",3,,166,2,,void
12938,BLOCK,-1,,"{
	priv->df->format(toAppendTo, date->getTime(), p);
}",1,,181,4,,void
12940,BLOCK,1,,<empty>,,,,1,,void
13010,BLOCK,-1,,<empty>,1,,1,1,,ANY
13015,BLOCK,-1,,"{
		static bool initialized = false;
		if (!initialized)
		{
			initialized = true;
			apr_status_t stat = apr_dbd_init(m_pool.getAPRPool());
			assert(stat == APR_SUCCESS);
		}
	}",2,,55,1,,void
13023,BLOCK,-1,,"{
			initialized = true;
			apr_status_t stat = apr_dbd_init(m_pool.getAPRPool());
			assert(stat == APR_SUCCESS);
		}",3,,58,2,,void
13052,BLOCK,-1,,<empty>,,,,1,,<empty>
13065,BLOCK,-1,,"{
    PatternMap specs;
    if (specs.empty())
    {
        RULES_PUT(""logger"", LoggerPatternConverter);
        RULES_PUT(""class"", ClassNamePatternConverter);
        RULES_PUT(""time"", DatePatternConverter);
        RULES_PUT(""shortfilename"", ShortFileLocationPatternConverter);
        RULES_PUT(""fullfilename"", FileLocationPatternConverter);
        RULES_PUT(""location"", FullLocationPatternConverter);
        RULES_PUT(""line"", LineLocationPatternConverter);
        RULES_PUT(""message"", MessagePatternConverter);
        RULES_PUT(""method"", MethodLocationPatternConverter);
        RULES_PUT(""level"", LevelPatternConverter);
        RULES_PUT(""thread"", ThreadPatternConverter);
        RULES_PUT(""threadname"", ThreadUsernamePatternConverter);
        RULES_PUT(""ndc"", NDCPatternConverter);
    }
    return specs;
}",1,,81,1,,void
13072,BLOCK,-1,,"{
        RULES_PUT(""logger"", LoggerPatternConverter);
        RULES_PUT(""class"", ClassNamePatternConverter);
        RULES_PUT(""time"", DatePatternConverter);
        RULES_PUT(""shortfilename"", ShortFileLocationPatternConverter);
        RULES_PUT(""fullfilename"", FileLocationPatternConverter);
        RULES_PUT(""location"", FullLocationPatternConverter);
        RULES_PUT(""line"", LineLocationPatternConverter);
        RULES_PUT(""message"", MessagePatternConverter);
        RULES_PUT(""method"", MethodLocationPatternConverter);
        RULES_PUT(""level"", LevelPatternConverter);
        RULES_PUT(""thread"", ThreadPatternConverter);
        RULES_PUT(""threadname"", ThreadUsernamePatternConverter);
        RULES_PUT(""ndc"", NDCPatternConverter);
    }",5,,84,2,,void
13075,BLOCK,1,,<empty>,,,,3,,void
13092,BLOCK,1,,<empty>,,,,3,,void
13109,BLOCK,1,,<empty>,,,,3,,void
13126,BLOCK,1,,<empty>,,,,3,,void
13143,BLOCK,1,,<empty>,,,,3,,void
13160,BLOCK,1,,<empty>,,,,3,,void
13177,BLOCK,1,,<empty>,,,,3,,void
13194,BLOCK,1,,<empty>,,,,3,,void
13211,BLOCK,1,,<empty>,,,,3,,void
13228,BLOCK,1,,<empty>,,,,3,,void
13245,BLOCK,1,,<empty>,,,,3,,void
13262,BLOCK,1,,<empty>,,,,3,,void
13279,BLOCK,1,,<empty>,,,,3,,void
13299,BLOCK,-1,,"{
}",1,,104,1,,void
13303,BLOCK,-1,,"{
    close();
}",1,,108,1,,void
13308,BLOCK,-1,,"{
    if(_priv->m_driver && _priv->m_databaseHandle){
        apr_dbd_close(_priv->m_driver, _priv->m_databaseHandle);
    }
    _priv->m_driver = nullptr;
    _priv->m_databaseHandle = nullptr;
}",25,,112,1,,void
13312,BLOCK,1,,<empty>,,,,1,,void
13322,BLOCK,1,,<empty>,,,,1,,void
13331,BLOCK,-1,,"{
        apr_dbd_close(_priv->m_driver, _priv->m_databaseHandle);
    }",51,,113,2,,void
13334,BLOCK,1,,<empty>,,,,1,,void
13344,BLOCK,1,,<empty>,,,,1,,void
13355,BLOCK,1,,<empty>,,,,1,,void
13367,BLOCK,1,,<empty>,,,,1,,void
13382,BLOCK,-1,,"{
    if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""COLUMNMAPPING""), LOG4CXX_STR(""columnmapping"")))
    {
        _priv->mappedName.push_back(value);
    }
    else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""DRIVERNAME""), LOG4CXX_STR(""drivername"")))
    {
        Transcoder::encodeUTF8(value, _priv->driverName);
    }
    else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""DRIVERPARAMS""), LOG4CXX_STR(""driverparams"")))
    {
        Transcoder::encodeUTF8(value, _priv->driverParams);
    }
    else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""DATABASENAME""), LOG4CXX_STR(""databasename"")))
    {
        Transcoder::encodeUTF8(value, _priv->databaseName);
    }
    else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""SQL""), LOG4CXX_STR(""sql"")))
    {
        Transcoder::encodeUTF8(value, _priv->sqlStatement);
    }
    else
    {
        AppenderSkeleton::setOption(option, value);
    }
}",76,,120,3,,void
13393,BLOCK,-1,,"{
        _priv->mappedName.push_back(value);
    }",5,,122,2,,void
13395,BLOCK,1,,<empty>,,,,1,,void
13409,BLOCK,-1,,<empty>,10,,125,1,,void
13420,BLOCK,-1,,"{
        Transcoder::encodeUTF8(value, _priv->driverName);
    }",5,,126,2,,void
13427,BLOCK,1,,<empty>,,,,1,,void
13437,BLOCK,-1,,<empty>,10,,129,1,,void
13448,BLOCK,-1,,"{
        Transcoder::encodeUTF8(value, _priv->driverParams);
    }",5,,130,2,,void
13455,BLOCK,1,,<empty>,,,,1,,void
13465,BLOCK,-1,,<empty>,10,,133,1,,void
13476,BLOCK,-1,,"{
        Transcoder::encodeUTF8(value, _priv->databaseName);
    }",5,,134,2,,void
13483,BLOCK,1,,<empty>,,,,1,,void
13493,BLOCK,-1,,<empty>,10,,137,1,,void
13504,BLOCK,-1,,"{
        Transcoder::encodeUTF8(value, _priv->sqlStatement);
    }",5,,138,2,,void
13511,BLOCK,1,,<empty>,,,,1,,void
13521,BLOCK,-1,,"{
        AppenderSkeleton::setOption(option, value);
    }",5,,142,1,,void
13532,BLOCK,-1,,"{
    apr_status_t stat = apr_dbd_get_driver(_priv->m_pool.getAPRPool(),
                                           _priv->driverName.c_str(),
                                           const_cast<const apr_dbd_driver_t**>(&_priv->m_driver));

    if(stat != APR_SUCCESS){
        LogString errMsg = LOG4CXX_STR(""Unable to get driver named "");
        LOG4CXX_DECODE_CHAR(driverName, _priv->driverName);
        errMsg.append(driverName);
        LogLog::error(errMsg);
        _priv->errorHandler->error(errMsg);
        return;
    }

    stat = apr_dbd_open(_priv->m_driver,
                        _priv->m_pool.getAPRPool(),
                        _priv->driverParams.c_str(),
                        &_priv->m_databaseHandle);
    if(stat != APR_SUCCESS){
        LogLog::error(LOG4CXX_STR(""Unable to open database""));
        _priv->errorHandler->error(LOG4CXX_STR(""Unable to open database""));
        return;
    }

    if(!_priv->databaseName.empty()){
        apr_dbd_set_dbname(_priv->...",51,,147,2,,void
13538,BLOCK,1,,<empty>,,,,1,,void
13551,BLOCK,1,,<empty>,,,,1,,void
13567,BLOCK,1,,<empty>,,,,1,,void
13580,BLOCK,-1,,"{
        LogString errMsg = LOG4CXX_STR(""Unable to get driver named "");
        LOG4CXX_DECODE_CHAR(driverName, _priv->driverName);
        errMsg.append(driverName);
        LogLog::error(errMsg);
        _priv->errorHandler->error(errMsg);
        return;
    }",28,,152,2,,void
13589,BLOCK,1,,<empty>,,,,1,,void
13609,BLOCK,1,,<empty>,,,,2,,void
13627,BLOCK,1,,<empty>,,,,1,,void
13637,BLOCK,1,,<empty>,,,,1,,void
13650,BLOCK,1,,<empty>,,,,1,,void
13664,BLOCK,1,,<empty>,,,,1,,void
13677,BLOCK,-1,,"{
        LogLog::error(LOG4CXX_STR(""Unable to open database""));
        _priv->errorHandler->error(LOG4CXX_STR(""Unable to open database""));
        return;
    }",28,,165,2,,void
13685,BLOCK,1,,<empty>,,,,1,,void
13703,BLOCK,1,,<empty>,,,,1,,void
13715,BLOCK,-1,,"{
        apr_dbd_set_dbname(_priv->m_driver,
                           _priv->m_pool.getAPRPool(),
                           _priv->m_databaseHandle,
                           _priv->databaseName.c_str());
    }",37,,171,2,,void
13718,BLOCK,1,,<empty>,,,,1,,void
13728,BLOCK,1,,<empty>,,,,1,,void
13741,BLOCK,1,,<empty>,,,,1,,void
13751,BLOCK,1,,<empty>,,,,1,,void
13767,BLOCK,1,,<empty>,,,,1,,void
13777,BLOCK,1,,<empty>,,,,1,,void
13790,BLOCK,1,,<empty>,,,,1,,void
13800,BLOCK,1,,<empty>,,,,1,,void
13815,BLOCK,1,,<empty>,,,,1,,void
13828,BLOCK,-1,,"{
        LogString error = LOG4CXX_STR(""Unable to prepare statement: "");
        std::string dbdErr(apr_dbd_error(_priv->m_driver, _priv->m_databaseHandle, stat));
        LOG4CXX_DECODE_CHAR(dbdErrLS, dbdErr);
        error.append(dbdErrLS);
        LogLog::error(error);
        _priv->errorHandler->error(error);
        return;
    }",28,,184,2,,void
13838,BLOCK,1,,<empty>,,,,1,,void
13848,BLOCK,1,,<empty>,,,,1,,void
13872,BLOCK,1,,<empty>,,,,2,,void
13892,BLOCK,1,,<empty>,,,,1,,void
13902,BLOCK,-1,,"{
        auto pItem = specs.find(StringHelper::toLowerCase(name));
        if (specs.end() == pItem)
            LogLog::error(name + LOG4CXX_STR("" is not a supported ColumnMapping value""));
        else
        {
            std::vector<LogString> options;
            if (LOG4CXX_STR(""time"") == pItem->first)
                options.push_back(LOG4CXX_STR(""yyyy-MM-ddTHH:mm:ss.SSS""));
            pattern::LoggingEventPatternConverterPtr converter = LOG4CXX_NS::cast<LoggingEventPatternConverter>((pItem->second)(options));
            _priv->converters.push_back(converter);
        }
    }",5,,196,3,,void
13922,BLOCK,-1,,<empty>,13,,199,2,,void
13932,BLOCK,-1,,"{
            std::vector<LogString> options;
            if (LOG4CXX_STR(""time"") == pItem->first)
                options.push_back(LOG4CXX_STR(""yyyy-MM-ddTHH:mm:ss.SSS""));
            pattern::LoggingEventPatternConverterPtr converter = LOG4CXX_NS::cast<LoggingEventPatternConverter>((pItem->second)(options));
            _priv->converters.push_back(converter);
        }",9,,201,1,,void
13947,BLOCK,-1,,<empty>,17,,204,2,,void
13969,BLOCK,1,,<empty>,,,,2,,void
13987,BLOCK,-1,,"{
	std::vector<std::string> ls_args;
    std::vector<const char*> args;
    int stat;
    int num_rows;

    if(_priv->m_driver == nullptr ||
            _priv->m_databaseHandle == nullptr ||
            _priv->preparedStmt == nullptr){
        _priv->errorHandler->error(LOG4CXX_STR(""DBAppender not initialized properly: logging not available""));
        return;
    }

    for(auto& converter : _priv->converters){
        LogString str_data;
        converter->format(event, str_data, p);
		LOG4CXX_ENCODE_CHAR(new_str_data, str_data);
		ls_args.push_back(new_str_data);
    }

	for(std::string& str : ls_args){
        args.push_back(str.data());
    }
    args.push_back(nullptr);

    stat = apr_dbd_pquery(_priv->m_driver,
                          _priv->m_pool.getAPRPool(),
                          _priv->m_databaseHandle,
                          &num_rows,
                          _priv->preparedStmt,
                          int(args.size()),
                          args.dat...",77,,211,3,,void
14005,BLOCK,1,,<empty>,,,,1,,void
14017,BLOCK,1,,<empty>,,,,1,,void
14029,BLOCK,1,,<empty>,,,,1,,void
14039,BLOCK,-1,,"{
        _priv->errorHandler->error(LOG4CXX_STR(""DBAppender not initialized properly: logging not available""));
        return;
    }",44,,219,2,,void
14041,BLOCK,1,,<empty>,,,,1,,void
14058,BLOCK,1,,<empty>,,,,1,,void
14068,BLOCK,-1,,"{
        LogString str_data;
        converter->format(event, str_data, p);
		LOG4CXX_ENCODE_CHAR(new_str_data, str_data);
		ls_args.push_back(new_str_data);
    }",45,,224,3,,void
14088,BLOCK,-1,,"{
        args.push_back(str.data());
    }",33,,231,3,,void
14106,BLOCK,1,,<empty>,,,,1,,void
14116,BLOCK,1,,<empty>,,,,1,,void
14129,BLOCK,1,,<empty>,,,,1,,void
14141,BLOCK,1,,<empty>,,,,1,,void
14164,BLOCK,-1,,"{
        LogString error = LOG4CXX_STR(""Unable to insert: "");
		LOG4CXX_DECODE_CHAR(local_error, apr_dbd_error(_priv->m_driver, _priv->m_databaseHandle, stat));
		error.append(local_error);
        LogLog::error(error);
        _priv->errorHandler->error(error);
    }",28,,243,2,,void
14174,BLOCK,1,,<empty>,,,,1,,void
14184,BLOCK,1,,<empty>,,,,1,,void
14205,BLOCK,1,,<empty>,,,,2,,void
14244,BLOCK,-1,,<empty>,1,,1,1,,ANY
14253,BLOCK,-1,,"{
	DefaultConfiguratorPath = path;
}",1,,39,2,,void
14261,BLOCK,-1,,"{
	DefaultConfiguratorWatchSeconds = seconds;
}",1,,45,2,,void
14273,BLOCK,-1,,"{
	repository->setConfigured(true);
	const LogString configuratorClassName(getConfiguratorClass());

	LogString configurationFileName = DefaultConfiguratorPath;
	if (configurationFileName.empty())
		configurationFileName = getConfigurationFileName();
	Pool pool;
	File configuration;

	if (configurationFileName.empty())
	{
		LogString names[4] =
			{ LOG4CXX_STR(""log4cxx.xml"")
			, LOG4CXX_STR(""log4cxx.properties"")
			, LOG4CXX_STR(""log4j.xml"")
			, LOG4CXX_STR(""log4j.properties"")
			};

		for (int i = 0; i < 4; i++)
		{
			File candidate(names[i]);

			LogString debugMsg = LOG4CXX_STR(""Checking file "");
			debugMsg.append(names[i]);
			LogLog::debug(debugMsg);
			if (candidate.exists(pool))
			{
				configuration = candidate;
				break;
			}
		}
	}
	else
	{
		configuration.setPath(configurationFileName);
	}

	if (configuration.exists(pool))
	{
		LogString msg(LOG4CXX_STR(""Using configuration file [""));
		msg += configuration.getPath();
		msg += LOG4CXX_STR(""] for automatic log4cxx c...",1,,52,2,,void
14291,BLOCK,-1,,<empty>,3,,58,2,,void
14302,BLOCK,-1,,"{
		LogString names[4] =
			{ LOG4CXX_STR(""log4cxx.xml"")
			, LOG4CXX_STR(""log4cxx.properties"")
			, LOG4CXX_STR(""log4j.xml"")
			, LOG4CXX_STR(""log4j.properties"")
			};

		for (int i = 0; i < 4; i++)
		{
			File candidate(names[i]);

			LogString debugMsg = LOG4CXX_STR(""Checking file "");
			debugMsg.append(names[i]);
			LogLog::debug(debugMsg);
			if (candidate.exists(pool))
			{
				configuration = candidate;
				break;
			}
		}
	}",2,,63,2,,void
14316,BLOCK,-1,,<empty>,3,,71,1,,void
14326,BLOCK,4,,"{
			File candidate(names[i]);

			LogString debugMsg = LOG4CXX_STR(""Checking file "");
			debugMsg.append(names[i]);
			LogLog::debug(debugMsg);
			if (candidate.exists(pool))
			{
				configuration = candidate;
				break;
			}
		}",3,,72,4,,void
14355,BLOCK,-1,,"{
				configuration = candidate;
				break;
			}",4,,79,2,,void
14361,BLOCK,-1,,"{
		configuration.setPath(configurationFileName);
	}",2,,86,1,,void
14373,BLOCK,-1,,"{
		LogString msg(LOG4CXX_STR(""Using configuration file [""));
		msg += configuration.getPath();
		msg += LOG4CXX_STR(""] for automatic log4cxx configuration"");
		LogLog::debug(msg);

		LoggerRepositoryPtr repo(repository);
		OptionConverter::selectAndConfigure(
			configuration,
			configuratorClassName,
			repo,
			0 < DefaultConfiguratorWatchSeconds
				? DefaultConfiguratorWatchSeconds * MillisecondsPerSecond
				: getConfigurationWatchDelay()
			);
	}",2,,91,2,,void
14412,BLOCK,-1,,"{
		if (configurationFileName.empty())
		{
			LogLog::debug(LOG4CXX_STR(""Could not find default configuration file.""));
		}
		else
		{
			LogString msg(LOG4CXX_STR(""Could not find configuration file: [""));
			msg += configurationFileName;
			msg += LOG4CXX_STR(""]."");
			LogLog::debug(msg);
		}
	}",2,,108,1,,void
14418,BLOCK,-1,,"{
			LogLog::debug(LOG4CXX_STR(""Could not find default configuration file.""));
		}",3,,110,2,,void
14426,BLOCK,-1,,"{
			LogString msg(LOG4CXX_STR(""Could not find configuration file: [""));
			msg += configurationFileName;
			msg += LOG4CXX_STR(""]."");
			LogLog::debug(msg);
		}",3,,114,1,,void
14446,BLOCK,-1,,"{

	// Use automatic configration to configure the default hierarchy
	const LogString log4jConfiguratorClassName(
		OptionConverter::getSystemProperty(LOG4CXX_STR(""log4j.configuratorClass""), LOG4CXX_STR("""")));
	const LogString configuratorClassName(
		OptionConverter::getSystemProperty(LOG4CXX_STR(""LOG4CXX_CONFIGURATOR_CLASS""),
			log4jConfiguratorClassName));
	return configuratorClassName;
}",1,,125,1,,void
14471,BLOCK,-1,,"{
	static const WideLife<LogString> LOG4CXX_DEFAULT_CONFIGURATION_KEY(LOG4CXX_STR(""LOG4CXX_CONFIGURATION""));
	static const WideLife<LogString> LOG4J_DEFAULT_CONFIGURATION_KEY(LOG4CXX_STR(""log4j.configuration""));
	const LogString log4jConfigurationFileName(
		OptionConverter::getSystemProperty(LOG4J_DEFAULT_CONFIGURATION_KEY, LOG4CXX_STR("""")));
	const LogString configurationFileName(
		OptionConverter::getSystemProperty(LOG4CXX_DEFAULT_CONFIGURATION_KEY,
			log4jConfigurationFileName));
	return configurationFileName;
}",1,,138,1,,void
14502,BLOCK,-1,,"{
	static const WideLife<LogString> LOG4CXX_DEFAULT_CONFIGURATION_WATCH_KEY(LOG4CXX_STR(""LOG4CXX_CONFIGURATION_WATCH_SECONDS""));
	LogString optionStr = OptionConverter::getSystemProperty(LOG4CXX_DEFAULT_CONFIGURATION_WATCH_KEY, LogString());
	int milliseconds = 0;
	if (!optionStr.empty())
		milliseconds = StringHelper::toInt(optionStr) * MillisecondsPerSecond;
	return milliseconds;
}",1,,151,1,,void
14526,BLOCK,-1,,<empty>,3,,156,2,,void
14542,BLOCK,-1,,"{
#if LOG4CXX_HAS_DOMCONFIGURATOR
	if(helpers::StringHelper::endsWith(filename, LOG4CXX_STR("".xml""))){
		return LOG4CXX_NS::xml::DOMConfigurator::configure(filename);
	}
#endif
	if(helpers::StringHelper::endsWith(filename, LOG4CXX_STR("".properties""))){
		return LOG4CXX_NS::PropertyConfigurator::configure(filename);
	}

	return LOG4CXX_NS::spi::ConfigurationStatus::NotConfigured;
}",97,,160,2,,void
14553,BLOCK,-1,,"{
		return LOG4CXX_NS::PropertyConfigurator::configure(filename);
	}",75,,166,2,,void
14575,BLOCK,-1,,"{
	using ResultType = std::tuple<LOG4CXX_NS::spi::ConfigurationStatus, LogString>;
	LOG4CXX_NS::helpers::Pool pool;

	for( LogString dir : directories ){
		for( LogString fname : filenames ){
			LogString canidate_str = dir + LOG4CXX_STR(""/"") + fname;
			File candidate(canidate_str);

			LogString debugMsg = LOG4CXX_STR(""Checking file "");
			debugMsg.append(canidate_str);
			LogLog::debug(debugMsg);
			if (candidate.exists(pool))
			{
				LOG4CXX_NS::spi::ConfigurationStatus configStatus = tryLoadFile(canidate_str);
				if( configStatus == LOG4CXX_NS::spi::ConfigurationStatus::Configured ){
					return ResultType{configStatus, canidate_str};
				}
				LogLog::debug(LOG4CXX_STR(""Unable to load file: trying next""));
			}
		}
	}

	return ResultType{LOG4CXX_NS::spi::ConfigurationStatus::NotConfigured, LogString()};
}",123,,174,3,,void
14581,BLOCK,-1,,"{
		for( LogString fname : filenames ){
			LogString canidate_str = dir + LOG4CXX_STR(""/"") + fname;
			File candidate(canidate_str);

			LogString debugMsg = LOG4CXX_STR(""Checking file "");
			debugMsg.append(canidate_str);
			LogLog::debug(debugMsg);
			if (candidate.exists(pool))
			{
				LOG4CXX_NS::spi::ConfigurationStatus configStatus = tryLoadFile(canidate_str);
				if( configStatus == LOG4CXX_NS::spi::ConfigurationStatus::Configured ){
					return ResultType{configStatus, canidate_str};
				}
				LogLog::debug(LOG4CXX_STR(""Unable to load file: trying next""));
			}
		}
	}",36,,178,3,,void
14585,BLOCK,-1,,"{
			LogString canidate_str = dir + LOG4CXX_STR(""/"") + fname;
			File candidate(canidate_str);

			LogString debugMsg = LOG4CXX_STR(""Checking file "");
			debugMsg.append(canidate_str);
			LogLog::debug(debugMsg);
			if (candidate.exists(pool))
			{
				LOG4CXX_NS::spi::ConfigurationStatus configStatus = tryLoadFile(canidate_str);
				if( configStatus == LOG4CXX_NS::spi::ConfigurationStatus::Configured ){
					return ResultType{configStatus, canidate_str};
				}
				LogLog::debug(LOG4CXX_STR(""Unable to load file: trying next""));
			}
		}",37,,179,3,,void
14619,BLOCK,-1,,"{
				LOG4CXX_NS::spi::ConfigurationStatus configStatus = tryLoadFile(canidate_str);
				if( configStatus == LOG4CXX_NS::spi::ConfigurationStatus::Configured ){
					return ResultType{configStatus, canidate_str};
				}
				LogLog::debug(LOG4CXX_STR(""Unable to load file: trying next""));
			}",4,,187,2,,void
14635,BLOCK,-1,,"{
					return ResultType{configStatus, canidate_str};
				}",75,,189,2,,void
14670,BLOCK,-1,,<empty>,1,,1,1,,ANY
14676,BLOCK,-1,,"{
	return std::make_shared<Logger>(pool, name);
}",1,,28,3,,void
14696,BLOCK,-1,,<empty>,1,,1,1,,ANY
14701,BLOCK,-1,,"{
	m_priv->repository = repository1;
}",1,,31,2,,void
14710,BLOCK,-1,,<empty>,57,,35,1,,void
14714,BLOCK,-1,,"{
	return m_priv->repository;
}",1,,38,1,,void
14789,BLOCK,-1,,<empty>,1,,1,1,,ANY
14799,BLOCK,-1,,"{
		}",3,,76,2,,void
14803,BLOCK,-1,,"{
			DOMConfigurator().doConfigure(file(),
				LogManager::getLoggerRepository());
		}",3,,84,1,,void
14822,BLOCK,-1,,"{
}",1,,127,1,,void
14826,BLOCK,-1,,<empty>,37,,130,1,,void
14836,BLOCK,-1,,"{
	AppenderPtr appender;
	std::string tagName(element->name);

	if (tagName == APPENDER_TAG)
	{
		if (appenderName == getAttribute(utf8Decoder, element, NAME_ATTR))
		{
			appender = parseAppender(p, utf8Decoder, element, doc, appenders);
		}
	}

	if (element->first_child && !appender)
	{
		appender = findAppenderByName(p, utf8Decoder, element->first_child, doc, appenderName, appenders);
	}

	if (element->next && !appender)
	{
		appender = findAppenderByName(p, utf8Decoder, element->next, doc, appenderName, appenders);
	}

	return appender;
}",1,,141,7,,void
14847,BLOCK,1,,<empty>,,,,1,,void
14849,BLOCK,-1,,"{
		if (appenderName == getAttribute(utf8Decoder, element, NAME_ATTR))
		{
			appender = parseAppender(p, utf8Decoder, element, doc, appenders);
		}
	}",2,,146,2,,void
14857,BLOCK,1,,<empty>,,,,1,,void
14859,BLOCK,-1,,"{
			appender = parseAppender(p, utf8Decoder, element, doc, appenders);
		}",3,,148,2,,void
14875,BLOCK,-1,,"{
		appender = findAppenderByName(p, utf8Decoder, element->first_child, doc, appenderName, appenders);
	}",2,,154,2,,void
14894,BLOCK,-1,,"{
		appender = findAppenderByName(p, utf8Decoder, element->next, doc, appenderName, appenders);
	}",2,,159,2,,void
14916,BLOCK,-1,,"{
	LogString appenderName(subst(getAttribute(utf8Decoder, appenderRef, REF_ATTR)));
	AppenderMap::const_iterator match = appenders.find(appenderName);
	AppenderPtr appender;

	if (match != appenders.end())
	{
		appender = match->second;
	}
	else if (doc)
	{
		appender = findAppenderByName(p, utf8Decoder, doc->root, doc, appenderName, appenders);

		if (appender)
		{
			appenders.insert(AppenderMap::value_type(appenderName, appender));
		}
	}

	if (!appender)
	{
		LogLog::error(LOG4CXX_STR(""No appender named ["") +
			appenderName + LOG4CXX_STR(""] could be found.""));
	}

	return appender;
}",1,,175,6,,void
14924,BLOCK,1,,<empty>,,,,1,,void
14942,BLOCK,-1,,"{
		appender = match->second;
	}",2,,181,2,,void
14949,BLOCK,-1,,<empty>,7,,184,1,,void
14952,BLOCK,-1,,"{
		appender = findAppenderByName(p, utf8Decoder, doc->root, doc, appenderName, appenders);

		if (appender)
		{
			appenders.insert(AppenderMap::value_type(appenderName, appender));
		}
	}",2,,185,2,,void
14966,BLOCK,-1,,"{
			appenders.insert(AppenderMap::value_type(appenderName, appender));
		}",3,,189,2,,void
14980,BLOCK,-1,,"{
		LogLog::error(LOG4CXX_STR(""No appender named ["") +
			appenderName + LOG4CXX_STR(""] could be found.""));
	}",2,,195,2,,void
15002,BLOCK,-1,,"{

	LogString className(subst(getAttribute(utf8Decoder, appenderElement, CLASS_ATTR)));
	LogLog::debug(LOG4CXX_STR(""Class name: ["") + className + LOG4CXX_STR(""]""));

	try
	{
		ObjectPtr instance = ObjectPtr(Loader::loadClass(className).newInstance());
		AppenderPtr appender = LOG4CXX_NS::cast<Appender>(instance);
		PropertySetter propSetter(appender);

		appender->setName(subst(getAttribute(utf8Decoder, appenderElement, NAME_ATTR)));

		for (apr_xml_elem* currentElement = appenderElement->first_child;
			currentElement;
			currentElement = currentElement->next)
		{

			std::string tagName(currentElement->name);

			// Parse appender parameters
			if (tagName == PARAM_TAG)
			{
				setParameter(p, utf8Decoder, currentElement, propSetter);
			}
			// Set appender layout
			else if (tagName == LAYOUT_TAG)
			{
				appender->setLayout(parseLayout(p, utf8Decoder, currentElement));
			}
			// Add filters
			else if (tagName == FILTER_TAG)
			{
				std::vector<LOG4CXX_NS::spi::FilterPtr> f...",1,,211,6,,void
15010,BLOCK,1,,<empty>,,,,1,,void
15024,BLOCK,-1,,"{
		ObjectPtr instance = ObjectPtr(Loader::loadClass(className).newInstance());
		AppenderPtr appender = LOG4CXX_NS::cast<Appender>(instance);
		PropertySetter propSetter(appender);

		appender->setName(subst(getAttribute(utf8Decoder, appenderElement, NAME_ATTR)));

		for (apr_xml_elem* currentElement = appenderElement->first_child;
			currentElement;
			currentElement = currentElement->next)
		{

			std::string tagName(currentElement->name);

			// Parse appender parameters
			if (tagName == PARAM_TAG)
			{
				setParameter(p, utf8Decoder, currentElement, propSetter);
			}
			// Set appender layout
			else if (tagName == LAYOUT_TAG)
			{
				appender->setLayout(parseLayout(p, utf8Decoder, currentElement));
			}
			// Add filters
			else if (tagName == FILTER_TAG)
			{
				std::vector<LOG4CXX_NS::spi::FilterPtr> filters;
				parseFilters(p, utf8Decoder, currentElement, filters);

				for (std::vector<LOG4CXX_NS::spi::FilterPtr>::iterator iter = filters.begin();
					iter != filters....",2,,217,1,,void
15059,BLOCK,1,,<empty>,,,,1,,void
15062,BLOCK,-1,,<empty>,3,,224,1,,void
15075,BLOCK,4,,"{

			std::string tagName(currentElement->name);

			// Parse appender parameters
			if (tagName == PARAM_TAG)
			{
				setParameter(p, utf8Decoder, currentElement, propSetter);
			}
			// Set appender layout
			else if (tagName == LAYOUT_TAG)
			{
				appender->setLayout(parseLayout(p, utf8Decoder, currentElement));
			}
			// Add filters
			else if (tagName == FILTER_TAG)
			{
				std::vector<LOG4CXX_NS::spi::FilterPtr> filters;
				parseFilters(p, utf8Decoder, currentElement, filters);

				for (std::vector<LOG4CXX_NS::spi::FilterPtr>::iterator iter = filters.begin();
					iter != filters.end();
					iter++)
				{
					appender->addFilter(*iter);
				}
			}
			else if (tagName == ERROR_HANDLER_TAG)
			{
				parseErrorHandler(p, utf8Decoder, currentElement, appender, doc, appenders);
			}
			else if (tagName == ROLLING_POLICY_TAG)
			{
				RollingPolicyPtr rollPolicy(parseRollingPolicy(p, utf8Decoder, currentElement));
				RollingFileAppenderPtr rfa = LOG4CXX_NS::cast<RollingFileA...",3,,227,4,,void
15085,BLOCK,1,,<empty>,,,,1,,void
15087,BLOCK,-1,,"{
				setParameter(p, utf8Decoder, currentElement, propSetter);
			}",4,,233,2,,void
15094,BLOCK,-1,,<empty>,9,,237,1,,void
15099,BLOCK,1,,<empty>,,,,1,,void
15101,BLOCK,-1,,"{
				appender->setLayout(parseLayout(p, utf8Decoder, currentElement));
			}",4,,238,2,,void
15111,BLOCK,-1,,<empty>,9,,242,1,,void
15116,BLOCK,1,,<empty>,,,,1,,void
15118,BLOCK,-1,,"{
				std::vector<LOG4CXX_NS::spi::FilterPtr> filters;
				parseFilters(p, utf8Decoder, currentElement, filters);

				for (std::vector<LOG4CXX_NS::spi::FilterPtr>::iterator iter = filters.begin();
					iter != filters.end();
					iter++)
				{
					appender->addFilter(*iter);
				}
			}",4,,243,2,,void
15136,BLOCK,-1,,<empty>,5,,247,1,,void
15152,BLOCK,4,,"{
					appender->addFilter(*iter);
				}",5,,250,4,,void
15160,BLOCK,-1,,<empty>,9,,254,1,,void
15165,BLOCK,1,,<empty>,,,,1,,void
15167,BLOCK,-1,,"{
				parseErrorHandler(p, utf8Decoder, currentElement, appender, doc, appenders);
			}",4,,255,2,,void
15176,BLOCK,-1,,<empty>,9,,258,1,,void
15181,BLOCK,1,,<empty>,,,,1,,void
15183,BLOCK,-1,,"{
				RollingPolicyPtr rollPolicy(parseRollingPolicy(p, utf8Decoder, currentElement));
				RollingFileAppenderPtr rfa = LOG4CXX_NS::cast<RollingFileAppender>(appender);

				if (rfa != NULL)
				{
					rfa->setRollingPolicy(rollPolicy);
				}
			}",4,,259,2,,void
15204,BLOCK,-1,,"{
					rfa->setRollingPolicy(rollPolicy);
				}",5,,264,2,,void
15211,BLOCK,-1,,<empty>,9,,268,1,,void
15216,BLOCK,1,,<empty>,,,,1,,void
15218,BLOCK,-1,,"{
				ObjectPtr policy(parseTriggeringPolicy(p, utf8Decoder, currentElement));
				RollingFileAppenderPtr rfa = LOG4CXX_NS::cast<RollingFileAppender>(appender);
				TriggeringPolicyPtr policyPtr = LOG4CXX_NS::cast<TriggeringPolicy>(policy);

				if (rfa != NULL)
				{
					rfa->setTriggeringPolicy(policyPtr);
				}
				else
				{
					auto smtpa = LOG4CXX_NS::cast<LOG4CXX_NS::net::SMTPAppender>(appender);

					if (smtpa != NULL)
					{
						auto evaluator = LOG4CXX_NS::cast<TriggeringEventEvaluator>(policy);
						smtpa->setEvaluator(evaluator);
					}
				}
			}",4,,269,2,,void
15249,BLOCK,-1,,"{
					rfa->setTriggeringPolicy(policyPtr);
				}",5,,275,2,,void
15256,BLOCK,-1,,"{
					auto smtpa = LOG4CXX_NS::cast<LOG4CXX_NS::net::SMTPAppender>(appender);

					if (smtpa != NULL)
					{
						auto evaluator = LOG4CXX_NS::cast<TriggeringEventEvaluator>(policy);
						smtpa->setEvaluator(evaluator);
					}
				}",5,,279,1,,void
15275,BLOCK,-1,,"{
						auto evaluator = LOG4CXX_NS::cast<TriggeringEventEvaluator>(policy);
						smtpa->setEvaluator(evaluator);
					}",6,,283,2,,void
15292,BLOCK,-1,,<empty>,9,,289,1,,void
15297,BLOCK,1,,<empty>,,,,1,,void
15299,BLOCK,-1,,"{
				LogString refName = subst(getAttribute(utf8Decoder, currentElement, REF_ATTR));

				if (appender->instanceof(AppenderAttachable::getStaticClass()))
				{
					AppenderAttachablePtr aa = LOG4CXX_NS::cast<AppenderAttachable>(appender);
					LogLog::debug(LOG4CXX_STR(""Attaching appender named ["") +
						refName + LOG4CXX_STR(""] to appender named ["") +
						appender->getName() + LOG4CXX_STR(""].""));
					aa->addAppender(findAppenderByReference(p, utf8Decoder, currentElement, doc, appenders));
				}
				else
				{
					LogLog::error(LOG4CXX_STR(""Requesting attachment of appender named ["") +
						refName + LOG4CXX_STR(""] to appender named ["") + appender->getName() +
						LOG4CXX_STR(""] which does not implement AppenderAttachable.""));
				}
			}",4,,290,2,,void
15308,BLOCK,1,,<empty>,,,,1,,void
15319,BLOCK,-1,,"{
					AppenderAttachablePtr aa = LOG4CXX_NS::cast<AppenderAttachable>(appender);
					LogLog::debug(LOG4CXX_STR(""Attaching appender named ["") +
						refName + LOG4CXX_STR(""] to appender named ["") +
						appender->getName() + LOG4CXX_STR(""].""));
					aa->addAppender(findAppenderByReference(p, utf8Decoder, currentElement, doc, appenders));
				}",5,,294,2,,void
15360,BLOCK,-1,,"{
					LogLog::error(LOG4CXX_STR(""Requesting attachment of appender named ["") +
						refName + LOG4CXX_STR(""] to appender named ["") + appender->getName() +
						LOG4CXX_STR(""] which does not implement AppenderAttachable.""));
				}",5,,302,1,,void
15387,BLOCK,2,,"{
		LogLog::error(LOG4CXX_STR(""Could not create an Appender. Reported error follows.""),
			oops);
		return 0;
	}",2,,316,2,,void
15406,BLOCK,-1,,"{

	ErrorHandlerPtr eh;
	std::shared_ptr<Object> obj = OptionConverter::instantiateByClassName(
			subst(getAttribute(utf8Decoder, element, CLASS_ATTR)),
			ErrorHandler::getStaticClass(),
			0);
	eh = LOG4CXX_NS::cast<ErrorHandler>(obj);

	if (eh != 0)
	{
		eh->setAppender(appender);

		PropertySetter propSetter(eh);

		for (apr_xml_elem* currentElement = element->first_child;
			currentElement;
			currentElement = currentElement->next)
		{
			std::string tagName(currentElement->name);

			if (tagName == PARAM_TAG)
			{
				setParameter(p, utf8Decoder, currentElement, propSetter);
			}
			else if (tagName == APPENDER_REF_TAG)
			{
				eh->setBackupAppender(findAppenderByReference(p, utf8Decoder, currentElement, doc, appenders));
			}
			else if (tagName == LOGGER_REF)
			{
				LogString loggerName(getAttribute(utf8Decoder, currentElement, REF_ATTR));
				LoggerPtr logger = m_priv->repository->getLogger(loggerName, m_priv->loggerFactory);
				eh->setLogger(logger);
			}
			else if (...",1,,332,7,,void
15425,BLOCK,1,,<empty>,,,,1,,void
15445,BLOCK,-1,,"{
		eh->setAppender(appender);

		PropertySetter propSetter(eh);

		for (apr_xml_elem* currentElement = element->first_child;
			currentElement;
			currentElement = currentElement->next)
		{
			std::string tagName(currentElement->name);

			if (tagName == PARAM_TAG)
			{
				setParameter(p, utf8Decoder, currentElement, propSetter);
			}
			else if (tagName == APPENDER_REF_TAG)
			{
				eh->setBackupAppender(findAppenderByReference(p, utf8Decoder, currentElement, doc, appenders));
			}
			else if (tagName == LOGGER_REF)
			{
				LogString loggerName(getAttribute(utf8Decoder, currentElement, REF_ATTR));
				LoggerPtr logger = m_priv->repository->getLogger(loggerName, m_priv->loggerFactory);
				eh->setLogger(logger);
			}
			else if (tagName == ROOT_REF)
			{
				LoggerPtr root = m_priv->repository->getRootLogger();
				eh->setLogger(root);
			}
		}

		propSetter.activate(p);
		std::shared_ptr<AppenderSkeleton> appSkeleton = LOG4CXX_NS::cast<AppenderSkeleton>(appender);

		if (appSkel...",2,,342,2,,void
15455,BLOCK,-1,,<empty>,3,,347,1,,void
15468,BLOCK,4,,"{
			std::string tagName(currentElement->name);

			if (tagName == PARAM_TAG)
			{
				setParameter(p, utf8Decoder, currentElement, propSetter);
			}
			else if (tagName == APPENDER_REF_TAG)
			{
				eh->setBackupAppender(findAppenderByReference(p, utf8Decoder, currentElement, doc, appenders));
			}
			else if (tagName == LOGGER_REF)
			{
				LogString loggerName(getAttribute(utf8Decoder, currentElement, REF_ATTR));
				LoggerPtr logger = m_priv->repository->getLogger(loggerName, m_priv->loggerFactory);
				eh->setLogger(logger);
			}
			else if (tagName == ROOT_REF)
			{
				LoggerPtr root = m_priv->repository->getRootLogger();
				eh->setLogger(root);
			}
		}",3,,350,4,,void
15478,BLOCK,1,,<empty>,,,,1,,void
15480,BLOCK,-1,,"{
				setParameter(p, utf8Decoder, currentElement, propSetter);
			}",4,,354,2,,void
15487,BLOCK,-1,,<empty>,9,,357,1,,void
15492,BLOCK,1,,<empty>,,,,1,,void
15494,BLOCK,-1,,"{
				eh->setBackupAppender(findAppenderByReference(p, utf8Decoder, currentElement, doc, appenders));
			}",4,,358,2,,void
15506,BLOCK,-1,,<empty>,9,,361,1,,void
15511,BLOCK,1,,<empty>,,,,1,,void
15513,BLOCK,-1,,"{
				LogString loggerName(getAttribute(utf8Decoder, currentElement, REF_ATTR));
				LoggerPtr logger = m_priv->repository->getLogger(loggerName, m_priv->loggerFactory);
				eh->setLogger(logger);
			}",4,,362,2,,void
15520,BLOCK,1,,<empty>,,,,1,,void
15541,BLOCK,-1,,<empty>,9,,367,1,,void
15546,BLOCK,1,,<empty>,,,,1,,void
15548,BLOCK,-1,,"{
				LoggerPtr root = m_priv->repository->getRootLogger();
				eh->setLogger(root);
			}",4,,368,2,,void
15587,BLOCK,-1,,"{
			appSkeleton->setErrorHandler(eh);
		}",3,,378,2,,void
15600,BLOCK,-1,,"{
	LogString clazz = subst(getAttribute(utf8Decoder, element, CLASS_ATTR));
	FilterPtr filter;
	std::shared_ptr<Object> obj = OptionConverter::instantiateByClassName(clazz,
			Filter::getStaticClass(), 0);
	filter = LOG4CXX_NS::cast<Filter>(obj);

	if (filter != 0)
	{
		PropertySetter propSetter(filter);

		for (apr_xml_elem* currentElement = element->first_child;
			currentElement;
			currentElement = currentElement->next)
		{
			std::string tagName(currentElement->name);

			if (tagName == PARAM_TAG)
			{
				setParameter(p, utf8Decoder, currentElement, propSetter);
			}
		}

		propSetter.activate(p);
		filters.push_back(filter);
	}
}",1,,391,5,,void
15609,BLOCK,1,,<empty>,,,,1,,void
15643,BLOCK,-1,,"{
		PropertySetter propSetter(filter);

		for (apr_xml_elem* currentElement = element->first_child;
			currentElement;
			currentElement = currentElement->next)
		{
			std::string tagName(currentElement->name);

			if (tagName == PARAM_TAG)
			{
				setParameter(p, utf8Decoder, currentElement, propSetter);
			}
		}

		propSetter.activate(p);
		filters.push_back(filter);
	}",2,,399,2,,void
15648,BLOCK,-1,,<empty>,3,,402,1,,void
15661,BLOCK,4,,"{
			std::string tagName(currentElement->name);

			if (tagName == PARAM_TAG)
			{
				setParameter(p, utf8Decoder, currentElement, propSetter);
			}
		}",3,,405,4,,void
15671,BLOCK,1,,<empty>,,,,1,,void
15673,BLOCK,-1,,"{
				setParameter(p, utf8Decoder, currentElement, propSetter);
			}",4,,409,2,,void
15697,BLOCK,-1,,"{
	// Create a new Logger object from the <category> element.
	LogString loggerName = subst(getAttribute(utf8Decoder, loggerElement, NAME_ATTR));

	LogLog::debug(LOG4CXX_STR(""Retreiving an instance of Logger.""));
	LoggerPtr logger = m_priv->repository->getLogger(loggerName, m_priv->loggerFactory);

	// Setting up a logger needs to be an atomic operation, in order
	// to protect potential log operations while logger
	// configuration is in progress.
	bool additivity = OptionConverter::toBoolean(
			subst(getAttribute(utf8Decoder, loggerElement, ADDITIVITY_ATTR)),
			true);

	LogLog::debug(LOG4CXX_STR(""Setting ["") + logger->getName() + LOG4CXX_STR(""] additivity to ["") +
		(additivity ? LogString(LOG4CXX_STR(""true"")) : LogString(LOG4CXX_STR(""false""))) + LOG4CXX_STR(""].""));
	logger->setAdditivity(additivity);
	parseChildrenOfLoggerElement(p, utf8Decoder, loggerElement, logger, false, doc, appenders);
}",1,,428,6,,void
15706,BLOCK,1,,<empty>,,,,1,,void
15739,BLOCK,1,,<empty>,,,,1,,void
15787,BLOCK,-1,,"{
	LogString className(subst(getAttribute(utf8Decoder, factoryElement, CLASS_ATTR)));

	if (className.empty())
	{
		LogLog::error(LOG4CXX_STR(""Logger Factory tag class attribute not found.""));
		LogLog::debug(LOG4CXX_STR(""No Logger Factory configured.""));
	}
	else
	{
		LogLog::debug(LOG4CXX_STR(""Desired logger factory: ["") + className + LOG4CXX_STR(""]""));
		std::shared_ptr<Object> obj = OptionConverter::instantiateByClassName(
				className,
				LoggerFactory::getStaticClass(),
				0);
		m_priv->loggerFactory = LOG4CXX_NS::cast<LoggerFactory>(obj);
		PropertySetter propSetter(m_priv->loggerFactory);

		for (apr_xml_elem* currentElement = factoryElement->first_child;
			currentElement;
			currentElement = currentElement->next)
		{
			std::string tagName(currentElement->name);

			if (tagName == PARAM_TAG)
			{
				setParameter(p, utf8Decoder, currentElement, propSetter);
			}
		}
	}
}",1,,455,4,,void
15795,BLOCK,1,,<empty>,,,,1,,void
15802,BLOCK,-1,,"{
		LogLog::error(LOG4CXX_STR(""Logger Factory tag class attribute not found.""));
		LogLog::debug(LOG4CXX_STR(""No Logger Factory configured.""));
	}",2,,459,2,,void
15816,BLOCK,-1,,"{
		LogLog::debug(LOG4CXX_STR(""Desired logger factory: ["") + className + LOG4CXX_STR(""]""));
		std::shared_ptr<Object> obj = OptionConverter::instantiateByClassName(
				className,
				LoggerFactory::getStaticClass(),
				0);
		m_priv->loggerFactory = LOG4CXX_NS::cast<LoggerFactory>(obj);
		PropertySetter propSetter(m_priv->loggerFactory);

		for (apr_xml_elem* currentElement = factoryElement->first_child;
			currentElement;
			currentElement = currentElement->next)
		{
			std::string tagName(currentElement->name);

			if (tagName == PARAM_TAG)
			{
				setParameter(p, utf8Decoder, currentElement, propSetter);
			}
		}
	}",2,,464,1,,void
15863,BLOCK,-1,,<empty>,3,,473,1,,void
15876,BLOCK,4,,"{
			std::string tagName(currentElement->name);

			if (tagName == PARAM_TAG)
			{
				setParameter(p, utf8Decoder, currentElement, propSetter);
			}
		}",3,,476,4,,void
15886,BLOCK,1,,<empty>,,,,1,,void
15888,BLOCK,-1,,"{
				setParameter(p, utf8Decoder, currentElement, propSetter);
			}",4,,480,2,,void
15902,BLOCK,-1,,"{
	LoggerPtr root = m_priv->repository->getRootLogger();
	parseChildrenOfLoggerElement(p, utf8Decoder, rootElement, root, true, doc, appenders);
}",1,,496,6,,void
15930,BLOCK,-1,,"{
	PropertySetter propSetter(logger);
	std::vector<AppenderPtr> newappenders;

	// Remove all existing appenders from logger. They will be
	// reconstructed if need be.
	logger->removeAllAppenders();

	for (apr_xml_elem* currentElement = loggerElement->first_child;
		currentElement;
		currentElement = currentElement->next)
	{
		std::string tagName(currentElement->name);

		if (tagName == APPENDER_REF_TAG)
		{
			AppenderPtr appender = findAppenderByReference(p, utf8Decoder, currentElement, doc, appenders);
			LogString refName =  subst(getAttribute(utf8Decoder, currentElement, REF_ATTR));

			if (appender != 0)
			{
				LogLog::debug(LOG4CXX_STR(""Adding appender named ["") + refName +
					LOG4CXX_STR(""] to logger ["") + logger->getName() + LOG4CXX_STR(""].""));
			}
			else
			{
				LogLog::debug(LOG4CXX_STR(""Appender named ["") + refName +
					LOG4CXX_STR(""] not found.""));
			}

			logger->addAppender(appender);

		}
		else if (tagName == LEVEL_TAG)
		{
			parseLevel(p, utf8Decoder, c...",1,,510,8,,void
15946,BLOCK,-1,,<empty>,2,,518,1,,void
15959,BLOCK,4,,"{
		std::string tagName(currentElement->name);

		if (tagName == APPENDER_REF_TAG)
		{
			AppenderPtr appender = findAppenderByReference(p, utf8Decoder, currentElement, doc, appenders);
			LogString refName =  subst(getAttribute(utf8Decoder, currentElement, REF_ATTR));

			if (appender != 0)
			{
				LogLog::debug(LOG4CXX_STR(""Adding appender named ["") + refName +
					LOG4CXX_STR(""] to logger ["") + logger->getName() + LOG4CXX_STR(""].""));
			}
			else
			{
				LogLog::debug(LOG4CXX_STR(""Appender named ["") + refName +
					LOG4CXX_STR(""] not found.""));
			}

			logger->addAppender(appender);

		}
		else if (tagName == LEVEL_TAG)
		{
			parseLevel(p, utf8Decoder, currentElement, logger, isRoot);
		}
		else if (tagName == PRIORITY_TAG)
		{
			parseLevel(p, utf8Decoder, currentElement, logger, isRoot);
		}
		else if (tagName == PARAM_TAG)
		{
			setParameter(p, utf8Decoder, currentElement, propSetter);
		}
	}",2,,521,4,,void
15969,BLOCK,1,,<empty>,,,,1,,void
15971,BLOCK,-1,,"{
			AppenderPtr appender = findAppenderByReference(p, utf8Decoder, currentElement, doc, appenders);
			LogString refName =  subst(getAttribute(utf8Decoder, currentElement, REF_ATTR));

			if (appender != 0)
			{
				LogLog::debug(LOG4CXX_STR(""Adding appender named ["") + refName +
					LOG4CXX_STR(""] to logger ["") + logger->getName() + LOG4CXX_STR(""].""));
			}
			else
			{
				LogLog::debug(LOG4CXX_STR(""Appender named ["") + refName +
					LOG4CXX_STR(""] not found.""));
			}

			logger->addAppender(appender);

		}",3,,525,2,,void
15989,BLOCK,1,,<empty>,,,,1,,void
15995,BLOCK,-1,,"{
				LogLog::debug(LOG4CXX_STR(""Adding appender named ["") + refName +
					LOG4CXX_STR(""] to logger ["") + logger->getName() + LOG4CXX_STR(""].""));
			}",4,,530,2,,void
16016,BLOCK,-1,,"{
				LogLog::debug(LOG4CXX_STR(""Appender named ["") + refName +
					LOG4CXX_STR(""] not found.""));
			}",4,,535,1,,void
16034,BLOCK,-1,,<empty>,8,,543,1,,void
16039,BLOCK,1,,<empty>,,,,1,,void
16041,BLOCK,-1,,"{
			parseLevel(p, utf8Decoder, currentElement, logger, isRoot);
		}",3,,544,2,,void
16049,BLOCK,-1,,<empty>,8,,547,1,,void
16054,BLOCK,1,,<empty>,,,,1,,void
16056,BLOCK,-1,,"{
			parseLevel(p, utf8Decoder, currentElement, logger, isRoot);
		}",3,,548,2,,void
16064,BLOCK,-1,,<empty>,8,,551,1,,void
16069,BLOCK,1,,<empty>,,,,1,,void
16071,BLOCK,-1,,"{
			setParameter(p, utf8Decoder, currentElement, propSetter);
		}",3,,552,2,,void
16088,BLOCK,-1,,"{
	LogString className(subst(getAttribute(utf8Decoder, layout_element, CLASS_ATTR)));
	LogLog::debug(LOG4CXX_STR(""Parsing layout of class: \"""") + className + LOG4CXX_STR(""\""""));

	try
	{
		ObjectPtr instance = ObjectPtr(Loader::loadClass(className).newInstance());
		LayoutPtr layout = LOG4CXX_NS::cast<Layout>(instance);
		PropertySetter propSetter(layout);

		for (apr_xml_elem* currentElement = layout_element->first_child;
			currentElement;
			currentElement = currentElement->next)
		{
			std::string tagName(currentElement->name);

			if (tagName == PARAM_TAG)
			{
				setParameter(p, utf8Decoder, currentElement, propSetter);
			}
		}

		propSetter.activate(p);
		return layout;
	}
	catch (Exception& oops)
	{
		LogLog::error(LOG4CXX_STR(""Could not create the Layout. Reported error follows.""),
			oops);
		return 0;
	}
}",1,,567,4,,void
16096,BLOCK,1,,<empty>,,,,1,,void
16110,BLOCK,-1,,"{
		ObjectPtr instance = ObjectPtr(Loader::loadClass(className).newInstance());
		LayoutPtr layout = LOG4CXX_NS::cast<Layout>(instance);
		PropertySetter propSetter(layout);

		for (apr_xml_elem* currentElement = layout_element->first_child;
			currentElement;
			currentElement = currentElement->next)
		{
			std::string tagName(currentElement->name);

			if (tagName == PARAM_TAG)
			{
				setParameter(p, utf8Decoder, currentElement, propSetter);
			}
		}

		propSetter.activate(p);
		return layout;
	}",2,,572,1,,void
16137,BLOCK,-1,,<empty>,3,,577,1,,void
16150,BLOCK,4,,"{
			std::string tagName(currentElement->name);

			if (tagName == PARAM_TAG)
			{
				setParameter(p, utf8Decoder, currentElement, propSetter);
			}
		}",3,,580,4,,void
16160,BLOCK,1,,<empty>,,,,1,,void
16162,BLOCK,-1,,"{
				setParameter(p, utf8Decoder, currentElement, propSetter);
			}",4,,584,2,,void
16175,BLOCK,2,,"{
		LogLog::error(LOG4CXX_STR(""Could not create the Layout. Reported error follows.""),
			oops);
		return 0;
	}",2,,593,2,,void
16191,BLOCK,-1,,"{
	LogString className = subst(getAttribute(utf8Decoder, layout_element, CLASS_ATTR));
	LogLog::debug(LOG4CXX_STR(""Parsing triggering policy of class: \"""") + className + LOG4CXX_STR(""\""""));

	try
	{
		ObjectPtr instance = ObjectPtr(Loader::loadClass(className).newInstance());
		PropertySetter propSetter(instance);

		for (apr_xml_elem* currentElement = layout_element->first_child;
			currentElement;
			currentElement = currentElement->next)
		{
			std::string tagName(currentElement->name);

			if (tagName == PARAM_TAG)
			{
				setParameter(p, utf8Decoder, currentElement, propSetter);
			}
			else if (tagName == FILTER_TAG)
			{
				std::vector<LOG4CXX_NS::spi::FilterPtr> filters;
				parseFilters(p, utf8Decoder, currentElement, filters);
				FilterBasedTriggeringPolicyPtr fbtp = LOG4CXX_NS::cast<FilterBasedTriggeringPolicy>(instance);

				if (fbtp != NULL)
				{
					for (std::vector<LOG4CXX_NS::spi::FilterPtr>::iterator iter = filters.begin();
						iter != filters.end();
						i...",1,,607,4,,void
16200,BLOCK,1,,<empty>,,,,1,,void
16214,BLOCK,-1,,"{
		ObjectPtr instance = ObjectPtr(Loader::loadClass(className).newInstance());
		PropertySetter propSetter(instance);

		for (apr_xml_elem* currentElement = layout_element->first_child;
			currentElement;
			currentElement = currentElement->next)
		{
			std::string tagName(currentElement->name);

			if (tagName == PARAM_TAG)
			{
				setParameter(p, utf8Decoder, currentElement, propSetter);
			}
			else if (tagName == FILTER_TAG)
			{
				std::vector<LOG4CXX_NS::spi::FilterPtr> filters;
				parseFilters(p, utf8Decoder, currentElement, filters);
				FilterBasedTriggeringPolicyPtr fbtp = LOG4CXX_NS::cast<FilterBasedTriggeringPolicy>(instance);

				if (fbtp != NULL)
				{
					for (std::vector<LOG4CXX_NS::spi::FilterPtr>::iterator iter = filters.begin();
						iter != filters.end();
						iter++)
					{
						fbtp->addFilter(*iter);
					}
				}
			}
		}

		propSetter.activate(p);
		return instance;
	}",2,,612,1,,void
16231,BLOCK,-1,,<empty>,3,,616,1,,void
16244,BLOCK,4,,"{
			std::string tagName(currentElement->name);

			if (tagName == PARAM_TAG)
			{
				setParameter(p, utf8Decoder, currentElement, propSetter);
			}
			else if (tagName == FILTER_TAG)
			{
				std::vector<LOG4CXX_NS::spi::FilterPtr> filters;
				parseFilters(p, utf8Decoder, currentElement, filters);
				FilterBasedTriggeringPolicyPtr fbtp = LOG4CXX_NS::cast<FilterBasedTriggeringPolicy>(instance);

				if (fbtp != NULL)
				{
					for (std::vector<LOG4CXX_NS::spi::FilterPtr>::iterator iter = filters.begin();
						iter != filters.end();
						iter++)
					{
						fbtp->addFilter(*iter);
					}
				}
			}
		}",3,,619,4,,void
16254,BLOCK,1,,<empty>,,,,1,,void
16256,BLOCK,-1,,"{
				setParameter(p, utf8Decoder, currentElement, propSetter);
			}",4,,623,2,,void
16263,BLOCK,-1,,<empty>,9,,626,1,,void
16268,BLOCK,1,,<empty>,,,,1,,void
16270,BLOCK,-1,,"{
				std::vector<LOG4CXX_NS::spi::FilterPtr> filters;
				parseFilters(p, utf8Decoder, currentElement, filters);
				FilterBasedTriggeringPolicyPtr fbtp = LOG4CXX_NS::cast<FilterBasedTriggeringPolicy>(instance);

				if (fbtp != NULL)
				{
					for (std::vector<LOG4CXX_NS::spi::FilterPtr>::iterator iter = filters.begin();
						iter != filters.end();
						iter++)
					{
						fbtp->addFilter(*iter);
					}
				}
			}",4,,627,2,,void
16301,BLOCK,-1,,"{
					for (std::vector<LOG4CXX_NS::spi::FilterPtr>::iterator iter = filters.begin();
						iter != filters.end();
						iter++)
					{
						fbtp->addFilter(*iter);
					}
				}",5,,633,2,,void
16303,BLOCK,-1,,<empty>,6,,634,1,,void
16319,BLOCK,4,,"{
						fbtp->addFilter(*iter);
					}",6,,637,4,,void
16333,BLOCK,2,,"{
		LogLog::error(LOG4CXX_STR(""Could not create the TriggeringPolicy. Reported error follows.""),
			oops);
		return 0;
	}",2,,648,2,,void
16349,BLOCK,-1,,"{
	LogString className = subst(getAttribute(utf8Decoder, layout_element, CLASS_ATTR));
	LogLog::debug(LOG4CXX_STR(""Parsing rolling policy of class: \"""") + className + LOG4CXX_STR(""\""""));

	try
	{
		ObjectPtr instance = ObjectPtr(Loader::loadClass(className).newInstance());
		RollingPolicyPtr layout = LOG4CXX_NS::cast<RollingPolicy>(instance);
		PropertySetter propSetter(layout);

		for (apr_xml_elem* currentElement = layout_element->first_child;
			currentElement;
			currentElement = currentElement->next)
		{
			std::string tagName(currentElement->name);

			if (tagName == PARAM_TAG)
			{
				setParameter(p, utf8Decoder, currentElement, propSetter);
			}
		}

		propSetter.activate(p);
		return layout;
	}
	catch (Exception& oops)
	{
		LogLog::error(LOG4CXX_STR(""Could not create the RollingPolicy. Reported error follows.""),
			oops);
		return 0;
	}
}",1,,662,4,,void
16358,BLOCK,1,,<empty>,,,,1,,void
16372,BLOCK,-1,,"{
		ObjectPtr instance = ObjectPtr(Loader::loadClass(className).newInstance());
		RollingPolicyPtr layout = LOG4CXX_NS::cast<RollingPolicy>(instance);
		PropertySetter propSetter(layout);

		for (apr_xml_elem* currentElement = layout_element->first_child;
			currentElement;
			currentElement = currentElement->next)
		{
			std::string tagName(currentElement->name);

			if (tagName == PARAM_TAG)
			{
				setParameter(p, utf8Decoder, currentElement, propSetter);
			}
		}

		propSetter.activate(p);
		return layout;
	}",2,,667,1,,void
16399,BLOCK,-1,,<empty>,3,,672,1,,void
16412,BLOCK,4,,"{
			std::string tagName(currentElement->name);

			if (tagName == PARAM_TAG)
			{
				setParameter(p, utf8Decoder, currentElement, propSetter);
			}
		}",3,,675,4,,void
16422,BLOCK,1,,<empty>,,,,1,,void
16424,BLOCK,-1,,"{
				setParameter(p, utf8Decoder, currentElement, propSetter);
			}",4,,679,2,,void
16437,BLOCK,2,,"{
		LogLog::error(LOG4CXX_STR(""Could not create the RollingPolicy. Reported error follows.""),
			oops);
		return 0;
	}",2,,688,2,,void
16455,BLOCK,-1,,"{
	LogString loggerName = logger->getName();

	if (isRoot)
	{
		loggerName = LOG4CXX_STR(""root"");
	}

	LogString levelStr(subst(getAttribute(utf8Decoder, element, VALUE_ATTR)));
	LogLog::debug(LOG4CXX_STR(""Level value for "") + loggerName + LOG4CXX_STR("" is ["") + levelStr + LOG4CXX_STR(""].""));

	if (StringHelper::equalsIgnoreCase(levelStr, LOG4CXX_STR(""INHERITED""), LOG4CXX_STR(""inherited""))
		|| StringHelper::equalsIgnoreCase(levelStr, LOG4CXX_STR(""NULL""), LOG4CXX_STR(""null"")))
	{
		if (isRoot)
		{
			LogLog::error(LOG4CXX_STR(""Root level cannot be inherited. Ignoring directive.""));
		}
		else
		{
			logger->setLevel(0);
		}
	}
	else
	{
		LogString className(subst(getAttribute(utf8Decoder, element, CLASS_ATTR)));

		if (className.empty())
		{
			logger->setLevel(OptionConverter::toLevel(levelStr, Level::getDebug()));
		}
		else
		{
			LogLog::debug(LOG4CXX_STR(""Desired Level sub-class: ["") + className + LOG4CXX_STR(""]""));

			try
			{
				Level::LevelClass& levelClass =
					(Level::...",1,,704,6,,void
16465,BLOCK,-1,,"{
		loggerName = LOG4CXX_STR(""root"");
	}",2,,708,2,,void
16477,BLOCK,1,,<empty>,,,,1,,void
16515,BLOCK,-1,,"{
		if (isRoot)
		{
			LogLog::error(LOG4CXX_STR(""Root level cannot be inherited. Ignoring directive.""));
		}
		else
		{
			logger->setLevel(0);
		}
	}",2,,717,2,,void
16518,BLOCK,-1,,"{
			LogLog::error(LOG4CXX_STR(""Root level cannot be inherited. Ignoring directive.""));
		}",3,,719,2,,void
16526,BLOCK,-1,,"{
			logger->setLevel(0);
		}",3,,723,1,,void
16533,BLOCK,-1,,"{
		LogString className(subst(getAttribute(utf8Decoder, element, CLASS_ATTR)));

		if (className.empty())
		{
			logger->setLevel(OptionConverter::toLevel(levelStr, Level::getDebug()));
		}
		else
		{
			LogLog::debug(LOG4CXX_STR(""Desired Level sub-class: ["") + className + LOG4CXX_STR(""]""));

			try
			{
				Level::LevelClass& levelClass =
					(Level::LevelClass&)Loader::loadClass(className);
				LevelPtr level = levelClass.toLevel(levelStr);
				logger->setLevel(level);
			}
			catch (Exception& oops)
			{
				LogLog::error(
					LOG4CXX_STR(""Could not create level ["") + levelStr +
					LOG4CXX_STR(""]. Reported error follows.""),
					oops);

				return;
			}
			catch (...)
			{
				LogLog::error(
					LOG4CXX_STR(""Could not create level ["") + levelStr);

				return;
			}
		}
	}",2,,728,1,,void
16541,BLOCK,1,,<empty>,,,,1,,void
16548,BLOCK,-1,,"{
			logger->setLevel(OptionConverter::toLevel(levelStr, Level::getDebug()));
		}",3,,732,2,,void
16563,BLOCK,-1,,"{
			LogLog::debug(LOG4CXX_STR(""Desired Level sub-class: ["") + className + LOG4CXX_STR(""]""));

			try
			{
				Level::LevelClass& levelClass =
					(Level::LevelClass&)Loader::loadClass(className);
				LevelPtr level = levelClass.toLevel(levelStr);
				logger->setLevel(level);
			}
			catch (Exception& oops)
			{
				LogLog::error(
					LOG4CXX_STR(""Could not create level ["") + levelStr +
					LOG4CXX_STR(""]. Reported error follows.""),
					oops);

				return;
			}
			catch (...)
			{
				LogLog::error(
					LOG4CXX_STR(""Could not create level ["") + levelStr);

				return;
			}
		}",3,,736,1,,void
16576,BLOCK,-1,,"{
				Level::LevelClass& levelClass =
					(Level::LevelClass&)Loader::loadClass(className);
				LevelPtr level = levelClass.toLevel(levelStr);
				logger->setLevel(level);
			}",4,,740,1,,void
16600,BLOCK,2,,"{
				LogLog::error(
					LOG4CXX_STR(""Could not create level ["") + levelStr +
					LOG4CXX_STR(""]. Reported error follows.""),
					oops);

				return;
			}",4,,747,2,,void
16614,BLOCK,2,,"{
				LogLog::error(
					LOG4CXX_STR(""Could not create level ["") + levelStr);

				return;
			}",4,,756,2,,void
16647,BLOCK,-1,,"{
	LogString name(subst(getAttribute(utf8Decoder, elem, NAME_ATTR)));
	LogString value(subst(getAttribute(utf8Decoder, elem, VALUE_ATTR)));
	value = subst(value);
	propSetter.setProperty(name, value, p);
}",1,,773,5,,void
16655,BLOCK,1,,<empty>,,,,1,,void
16664,BLOCK,1,,<empty>,,,,1,,void
16682,BLOCK,-1,,"{
	repository1->setConfigured(true);
	m_priv->repository = repository1;
	LogString msg(LOG4CXX_STR(""DOMConfigurator configuring file ""));
	msg.append(filename.getPath());
	msg.append(LOG4CXX_STR(""...""));
	LogLog::debug(msg);

	m_priv->loggerFactory = std::make_shared<DefaultLoggerFactory>();

	Pool p;
	apr_file_t* fd;

	log4cxx_status_t rv = filename.open(&fd, APR_READ, APR_OS_DEFAULT, p);

	if (rv != APR_SUCCESS)
	{
		// There is not technically an exception thrown here, but this behavior matches
		// what the PropertyConfigurator does
		IOException io(rv);
		LogString msg2(LOG4CXX_STR(""Could not read configuration file [""));
		msg2.append(filename.getPath());
		msg2.append(LOG4CXX_STR(""]. ""));
		LOG4CXX_DECODE_CHAR(msg, io.what());
		msg2.append(msg);
		LogLog::error(msg2);
		return spi::ConfigurationStatus::NotConfigured;
	}
	else
	{
		apr_xml_parser* parser = NULL;
		apr_xml_doc* doc = NULL;

		LogString debugMsg = LOG4CXX_STR(""Loading configuration file ["")
				+ filename.getPa...",1,,781,3,,void
16742,BLOCK,-1,,"{
		// There is not technically an exception thrown here, but this behavior matches
		// what the PropertyConfigurator does
		IOException io(rv);
		LogString msg2(LOG4CXX_STR(""Could not read configuration file [""));
		msg2.append(filename.getPath());
		msg2.append(LOG4CXX_STR(""]. ""));
		LOG4CXX_DECODE_CHAR(msg, io.what());
		msg2.append(msg);
		LogLog::error(msg2);
		return spi::ConfigurationStatus::NotConfigured;
	}",2,,797,2,,void
16787,BLOCK,-1,,"{
		apr_xml_parser* parser = NULL;
		apr_xml_doc* doc = NULL;

		LogString debugMsg = LOG4CXX_STR(""Loading configuration file ["")
				+ filename.getPath() + LOG4CXX_STR(""]."");
		LogLog::debug(debugMsg);

		rv = apr_xml_parse_file(p.getAPRPool(), &parser, &doc, fd, 2000);

		if (rv != APR_SUCCESS)
		{
			char errbuf[2000];
			char errbufXML[2000];
			LogString msg2(LOG4CXX_STR(""Error parsing file [""));
			msg2.append(filename.getPath());
			msg2.append(LOG4CXX_STR(""], ""));
			apr_strerror(rv, errbuf, sizeof(errbuf));
			LOG4CXX_DECODE_CHAR(lerrbuf, std::string(errbuf));
			msg2.append(lerrbuf);

			if (parser)
			{
				apr_xml_parser_geterror(parser, errbufXML, sizeof(errbufXML));
				LOG4CXX_DECODE_CHAR(lerrbufXML, std::string(errbufXML));
				msg2.append(lerrbufXML);
			}

			LogLog::error(msg2);
			return spi::ConfigurationStatus::NotConfigured;
		}
		else
		{
			AppenderMap appenders;
			CharsetDecoderPtr utf8Decoder(CharsetDecoder::getUTF8Decoder());
			parse(p, utf8Decoder, doc...",2,,810,1,,void
16831,BLOCK,-1,,"{
			char errbuf[2000];
			char errbufXML[2000];
			LogString msg2(LOG4CXX_STR(""Error parsing file [""));
			msg2.append(filename.getPath());
			msg2.append(LOG4CXX_STR(""], ""));
			apr_strerror(rv, errbuf, sizeof(errbuf));
			LOG4CXX_DECODE_CHAR(lerrbuf, std::string(errbuf));
			msg2.append(lerrbuf);

			if (parser)
			{
				apr_xml_parser_geterror(parser, errbufXML, sizeof(errbufXML));
				LOG4CXX_DECODE_CHAR(lerrbufXML, std::string(errbufXML));
				msg2.append(lerrbufXML);
			}

			LogLog::error(msg2);
			return spi::ConfigurationStatus::NotConfigured;
		}",3,,821,2,,void
16871,BLOCK,-1,,"{
				apr_xml_parser_geterror(parser, errbufXML, sizeof(errbufXML));
				LOG4CXX_DECODE_CHAR(lerrbufXML, std::string(errbufXML));
				msg2.append(lerrbufXML);
			}",4,,832,2,,void
16901,BLOCK,-1,,"{
			AppenderMap appenders;
			CharsetDecoderPtr utf8Decoder(CharsetDecoder::getUTF8Decoder());
			parse(p, utf8Decoder, doc->root, doc, appenders);
		}",3,,842,1,,void
16927,BLOCK,-1,,"{
	File file(filename);
	return DOMConfigurator().doConfigure(file, LogManager::getLoggerRepository());
}",1,,853,2,,void
16945,BLOCK,-1,,"{
	return configureAndWatch(filename, FileWatchdog::DEFAULT_DELAY);
}",1,,884,2,,void
16957,BLOCK,-1,,"{
	File file(filename);
	if ( xdog )
	{
		APRInitializer::unregisterCleanup(xdog);
		delete xdog;
	}

	spi::ConfigurationStatus status = DOMConfigurator().doConfigure(file, LogManager::getLoggerRepository());

	xdog = new XMLWatchdog(file);
	APRInitializer::registerCleanup(xdog);
	xdog->setDelay(delay);
	xdog->start();

	return status;
}",1,,910,3,,void
16963,BLOCK,-1,,"{
		APRInitializer::unregisterCleanup(xdog);
		delete xdog;
	}",2,,913,2,,void
17004,BLOCK,-1,,"{
	std::string rootElementName(element->name);

	if (rootElementName != CONFIGURATION_TAG)
	{
		if (rootElementName == OLD_CONFIGURATION_TAG)
		{
			//LogLog::warn(LOG4CXX_STR(""The <"")+String(OLD_CONFIGURATION_TAG)+
			// LOG4CXX_STR(""> element has been deprecated.""));
			//LogLog::warn(LOG4CXX_STR(""Use the <"")+String(CONFIGURATION_TAG)+
			// LOG4CXX_STR(""> element instead.""));
		}
		else
		{
			LogLog::error(LOG4CXX_STR(""DOM element is - not a <configuration> element.""));
			return;
		}
	}

	LogString debugAttrib = subst(getAttribute(utf8Decoder, element, INTERNAL_DEBUG_ATTR));

	static const WideLife<LogString> NULL_STRING(LOG4CXX_STR(""NULL""));
	LogLog::debug(LOG4CXX_STR(""debug attribute= \"""") + debugAttrib + LOG4CXX_STR(""\"".""));

	// if the log4j.dtd is not specified in the XML file, then the
	// ""debug"" attribute is returned as the empty string.
	if (!debugAttrib.empty() && debugAttrib != NULL_STRING.value())
	{
		LogLog::setInternalDebugging(OptionConverter::toBoolean(debugAtt...",1,,997,6,,void
17014,BLOCK,1,,<empty>,,,,1,,void
17016,BLOCK,-1,,"{
		if (rootElementName == OLD_CONFIGURATION_TAG)
		{
			//LogLog::warn(LOG4CXX_STR(""The <"")+String(OLD_CONFIGURATION_TAG)+
			// LOG4CXX_STR(""> element has been deprecated.""));
			//LogLog::warn(LOG4CXX_STR(""Use the <"")+String(CONFIGURATION_TAG)+
			// LOG4CXX_STR(""> element instead.""));
		}
		else
		{
			LogLog::error(LOG4CXX_STR(""DOM element is - not a <configuration> element.""));
			return;
		}
	}",2,,1001,2,,void
17021,BLOCK,1,,<empty>,,,,1,,void
17023,BLOCK,-1,,"{
			//LogLog::warn(LOG4CXX_STR(""The <"")+String(OLD_CONFIGURATION_TAG)+
			// LOG4CXX_STR(""> element has been deprecated.""));
			//LogLog::warn(LOG4CXX_STR(""Use the <"")+String(CONFIGURATION_TAG)+
			// LOG4CXX_STR(""> element instead.""));
		}",3,,1003,2,,void
17025,BLOCK,-1,,"{
			LogLog::error(LOG4CXX_STR(""DOM element is - not a <configuration> element.""));
			return;
		}",3,,1010,1,,void
17041,BLOCK,1,,<empty>,,,,1,,void
17071,BLOCK,-1,,"{
		LogLog::setInternalDebugging(OptionConverter::toBoolean(debugAttrib, true));
	}",2,,1024,2,,void
17083,BLOCK,-1,,"{
		LogLog::debug(LOG4CXX_STR(""Ignoring internalDebug attribute.""));
	}",2,,1028,1,,void
17098,BLOCK,1,,<empty>,,,,1,,void
17113,BLOCK,-1,,"{
		LogLog::warn(LOG4CXX_STR(""The \""configDebug\"" attribute is deprecated.""));
		LogLog::warn(LOG4CXX_STR(""Use the \""internalDebug\"" attribute instead.""));
		LogLog::setInternalDebugging(OptionConverter::toBoolean(confDebug, true));
	}",2,,1036,2,,void
17144,BLOCK,1,,<empty>,,,,1,,void
17170,BLOCK,-1,,"{
		m_priv->repository->setThreshold(thresholdStr);
	}",2,,1046,2,,void
17186,BLOCK,1,,<empty>,,,,1,,void
17201,BLOCK,-1,,"{
		if ( threadSignalValue == LOG4CXX_STR(""NoConfiguration"") )
		{
			helpers::ThreadUtility::configure( ThreadConfigurationType::NoConfiguration );
		}
		else if ( threadSignalValue == LOG4CXX_STR(""BlockSignalsOnly"") )
		{
			helpers::ThreadUtility::configure( ThreadConfigurationType::BlockSignalsOnly );
		}
		else if ( threadSignalValue == LOG4CXX_STR(""NameThreadOnly"") )
		{
			helpers::ThreadUtility::configure( ThreadConfigurationType::NameThreadOnly );
		}
		else if ( threadSignalValue == LOG4CXX_STR(""BlockSignalsAndNameThread"") )
		{
			helpers::ThreadUtility::configure( ThreadConfigurationType::BlockSignalsAndNameThread );
		}
	}",2,,1053,2,,void
17207,BLOCK,-1,,"{
			helpers::ThreadUtility::configure( ThreadConfigurationType::NoConfiguration );
		}",3,,1055,2,,void
17218,BLOCK,-1,,<empty>,8,,1058,1,,void
17224,BLOCK,-1,,"{
			helpers::ThreadUtility::configure( ThreadConfigurationType::BlockSignalsOnly );
		}",3,,1059,2,,void
17235,BLOCK,-1,,<empty>,8,,1062,1,,void
17241,BLOCK,-1,,"{
			helpers::ThreadUtility::configure( ThreadConfigurationType::NameThreadOnly );
		}",3,,1063,2,,void
17252,BLOCK,-1,,<empty>,8,,1066,1,,void
17258,BLOCK,-1,,"{
			helpers::ThreadUtility::configure( ThreadConfigurationType::BlockSignalsAndNameThread );
		}",3,,1067,2,,void
17270,BLOCK,-1,,<empty>,2,,1074,1,,void
17282,BLOCK,4,,"{
		std::string tagName(currentElement->name);

		if (tagName == CATEGORY_FACTORY_TAG)
		{
			parseLoggerFactory(p, utf8Decoder, currentElement);
		}
	}",2,,1077,4,,void
17292,BLOCK,1,,<empty>,,,,1,,void
17294,BLOCK,-1,,"{
			parseLoggerFactory(p, utf8Decoder, currentElement);
		}",3,,1081,2,,void
17300,BLOCK,-1,,<empty>,2,,1086,1,,void
17312,BLOCK,4,,"{
		std::string tagName(currentElement->name);

		if (tagName == CATEGORY || tagName == LOGGER)
		{
			parseLogger(p, utf8Decoder, currentElement, doc, appenders);
		}
		else if (tagName == ROOT_TAG)
		{
			parseRoot(p, utf8Decoder, currentElement, doc, appenders);
		}
	}",2,,1089,4,,void
17323,BLOCK,1,,<empty>,,,,1,,void
17328,BLOCK,1,,<empty>,,,,1,,void
17330,BLOCK,-1,,"{
			parseLogger(p, utf8Decoder, currentElement, doc, appenders);
		}",3,,1093,2,,void
17338,BLOCK,-1,,<empty>,8,,1096,1,,void
17343,BLOCK,1,,<empty>,,,,1,,void
17345,BLOCK,-1,,"{
			parseRoot(p, utf8Decoder, currentElement, doc, appenders);
		}",3,,1097,2,,void
17356,BLOCK,-1,,"{
	try
	{
		return OptionConverter::substVars(value, m_priv->props);
	}
	catch (IllegalArgumentException& e)
	{
		LogLog::warn(LOG4CXX_STR(""Could not perform variable substitution.""), e);
		return value;
	}
}",1,,1104,2,,void
17358,BLOCK,-1,,"{
		return OptionConverter::substVars(value, m_priv->props);
	}",2,,1106,1,,void
17368,BLOCK,2,,"{
		LogLog::warn(LOG4CXX_STR(""Could not perform variable substitution.""), e);
		return value;
	}",2,,1110,2,,void
17384,BLOCK,-1,,"{
	LogString attrValue;

	for (apr_xml_attr* attr = element->attr;
		attr;
		attr = attr->next)
	{
		if (attrName == attr->name)
		{
			ByteBuffer buf((char*) attr->value, strnlen_s(attr->value, MAX_ATTRIBUTE_NAME_LEN));
			utf8Decoder->decode(buf, attrValue);
		}
	}

	return attrValue;
}",1,,1121,4,,void
17387,BLOCK,-1,,<empty>,2,,1124,1,,void
17400,BLOCK,4,,"{
		if (attrName == attr->name)
		{
			ByteBuffer buf((char*) attr->value, strnlen_s(attr->value, MAX_ATTRIBUTE_NAME_LEN));
			utf8Decoder->decode(buf, attrValue);
		}
	}",2,,1127,4,,void
17407,BLOCK,-1,,"{
			ByteBuffer buf((char*) attr->value, strnlen_s(attr->value, MAX_ATTRIBUTE_NAME_LEN));
			utf8Decoder->decode(buf, attrValue);
		}",3,,1129,2,,void
17420,BLOCK,1,,<empty>,,,,1,,void
17452,BLOCK,-1,,<empty>,1,,1,1,,ANY
17455,BLOCK,-1,,"{
	LOG4CXX_ENCODE_CHAR(m, msg1);
	size_t len = m.size();

	if (len > MSG_SIZE)
	{
		len = MSG_SIZE;
	}

#if defined(__STDC_LIB_EXT1__) || defined(__STDC_SECURE_LIB__)
	memcpy_s(msg, sizeof msg, m.data(), len);
#else
	memcpy(msg, m.data(), len);
#endif
	msg[len] = 0;
}",1,,31,2,,void
17470,BLOCK,-1,,"{
		len = MSG_SIZE;
	}",2,,36,2,,void
17490,BLOCK,-1,,"{
#if defined(__STDC_LIB_EXT1__) || defined(__STDC_SECURE_LIB__)
	strncpy_s(msg, sizeof msg, m, MSG_SIZE);
#else
	strncpy(msg, m, MSG_SIZE);
#endif
	msg[MSG_SIZE] = 0;
}",1,,49,2,,void
17504,BLOCK,-1,,"{
#if defined(__STDC_LIB_EXT1__) || defined(__STDC_SECURE_LIB__)
	strcpy_s(msg, sizeof msg, src.msg);
#else
	strncpy(msg, src.msg, MSG_SIZE);
	msg[MSG_SIZE] = 0;
#endif
}",1,,60,2,,void
17520,BLOCK,-1,,"{
#if defined(__STDC_LIB_EXT1__) || defined(__STDC_SECURE_LIB__)
	strcpy_s(msg, sizeof msg, src.msg);
#else
	strncpy(msg, src.msg, MSG_SIZE);
	msg[MSG_SIZE] = 0;
#endif
	return *this;
}",1,,70,2,,void
17538,BLOCK,-1,,"{
	return msg;
}",1,,81,1,,void
17545,BLOCK,-1,,"{
}",1,,87,2,,void
17550,BLOCK,-1,,"{
}",1,,92,2,,void
17555,BLOCK,-1,,"{
}",1,,97,2,,void
17560,BLOCK,-1,,"{
	Exception::operator=(src);
	return *this;
}",1,,101,2,,void
17573,BLOCK,-1,,"{
	LogString s(LOG4CXX_STR(""RuntimeException: return code = ""));
	Pool p;
	StringHelper::toString(stat, p, s);
	return s;
}",1,,107,2,,void
17592,BLOCK,-1,,"{
}",1,,116,2,,void
17597,BLOCK,-1,,"{
}",1,,121,2,,void
17602,BLOCK,-1,,"{
	RuntimeException::operator=(src);
	return *this;
}",1,,125,2,,void
17615,BLOCK,-1,,"{
}",1,,132,2,,void
17620,BLOCK,-1,,"{
}",1,,137,2,,void
17625,BLOCK,-1,,"{
	RuntimeException::operator=(src);
	return *this;
}",1,,141,2,,void
17637,BLOCK,-1,,"{
}",1,,148,1,,void
17642,BLOCK,-1,,"{
}",1,,153,2,,void
17647,BLOCK,-1,,"{
}",1,,159,2,,void
17652,BLOCK,-1,,"{
}",1,,164,2,,void
17657,BLOCK,-1,,"{
	Exception::operator=(src);
	return *this;
}",1,,168,2,,void
17670,BLOCK,-1,,"{
	char err_buff[1024];
	LogString s(LOG4CXX_STR(""IO Exception : status code = ""));
	Pool p;
	StringHelper::toString(stat, p, s);
	s.append(LOG4CXX_STR(""(""));
	apr_strerror(stat, err_buff, sizeof(err_buff));
	std::string sMsg = err_buff;
	LOG4CXX_DECODE_CHAR(lsMsg, sMsg);
	s.append(lsMsg);
	s.append(LOG4CXX_STR("")""));
	return s;
}",1,,174,2,,void
17719,BLOCK,-1,,"{
}",1,,191,2,,void
17724,BLOCK,-1,,"{
}",1,,197,2,,void
17729,BLOCK,-1,,"{
	Exception::operator=(src);
	return *this;
}",1,,201,2,,void
17742,BLOCK,-1,,"{
	LogString s(LOG4CXX_STR(""MissingResourceException: resource key = \""""));
	s.append(key);
	s.append(LOG4CXX_STR(""\"".""));
	return s;
}",1,,207,2,,void
17764,BLOCK,-1,,"{
}",1,,216,2,,void
17769,BLOCK,-1,,"{
}",1,,221,2,,void
17774,BLOCK,-1,,"{
	Exception::operator=(src);
	return *this;
}",1,,225,2,,void
17787,BLOCK,-1,,"{
	return LOG4CXX_STR(""Pool exception"");
}",1,,231,2,,void
17795,BLOCK,-1,,"{
}",1,,238,2,,void
17800,BLOCK,-1,,"{
}",1,,243,2,,void
17805,BLOCK,-1,,"{
	Exception::operator=(src);
	return *this;
}",1,,247,2,,void
17818,BLOCK,-1,,"{
	return LOG4CXX_STR(""Transcoder exception"");
}",1,,253,2,,void
17825,BLOCK,-1,,"{
}",1,,259,1,,void
17830,BLOCK,-1,,"{
}",1,,264,2,,void
17835,BLOCK,-1,,"{
}",1,,269,2,,void
17840,BLOCK,-1,,"{
	Exception::operator=(src);
	return *this;
}",1,,273,2,,void
17853,BLOCK,-1,,"{
	LogString s(LOG4CXX_STR(""InterruptedException: stat = ""));
	Pool p;
	StringHelper::toString(stat, p, s);
	return s;
}",1,,279,2,,void
17872,BLOCK,-1,,"{
}",1,,288,2,,void
17877,BLOCK,-1,,"{
}",1,,293,2,,void
17882,BLOCK,-1,,"{
}",1,,298,2,,void
17887,BLOCK,-1,,"{
	Exception::operator=(src);
	return *this;
}",1,,302,2,,void
17900,BLOCK,-1,,"{
	LogString s(LOG4CXX_STR(""Thread exception: stat = ""));
	Pool p;
	StringHelper::toString(stat, p, s);
	return s;
}",1,,308,2,,void
17919,BLOCK,-1,,"{
}",1,,317,2,,void
17924,BLOCK,-1,,"{
}",1,,322,2,,void
17929,BLOCK,-1,,"{
	Exception::operator=(src);
	return *this;
}",1,,326,2,,void
17942,BLOCK,-1,,"{
}",1,,333,2,,void
17947,BLOCK,-1,,"{
}",1,,338,2,,void
17952,BLOCK,-1,,"{
	Exception::operator=(src);
	return *this;
}",1,,342,2,,void
17965,BLOCK,-1,,"{
}",1,,349,2,,void
17970,BLOCK,-1,,"{
}",1,,354,2,,void
17975,BLOCK,-1,,"{
	Exception::operator=(src);
	return *this;
}",1,,359,2,,void
17988,BLOCK,-1,,"{
	LogString s(LOG4CXX_STR(""Class not found: ""));
	s.append(className);
	return s;
}",1,,365,2,,void
18003,BLOCK,-1,,"{
}",1,,374,1,,void
18008,BLOCK,-1,,"{
}",1,,379,2,,void
18013,BLOCK,-1,,"{
	Exception::operator=(src);
	return *this;
}",1,,383,2,,void
18025,BLOCK,-1,,"{
}",1,,391,1,,void
18030,BLOCK,-1,,"{
}",1,,396,2,,void
18035,BLOCK,-1,,"{
	Exception::operator=(src);
	return *this;
}",1,,400,2,,void
18048,BLOCK,-1,,"{
}",1,,406,2,,void
18053,BLOCK,-1,,"{
}",1,,410,2,,void
18058,BLOCK,-1,,"{
}",1,,415,2,,void
18063,BLOCK,-1,,"{
	IOException::operator=(src);
	return *this;
}",1,,419,2,,void
18076,BLOCK,-1,,"{
}",1,,425,2,,void
18081,BLOCK,-1,,"{
}",1,,430,2,,void
18086,BLOCK,-1,,"{
	SocketException::operator=(src);
	return *this;
}",1,,434,2,,void
18098,BLOCK,-1,,"{
}",1,,440,1,,void
18103,BLOCK,-1,,"{
}",1,,445,2,,void
18108,BLOCK,-1,,"{
	SocketException::operator=(src);
	return *this;
}",1,,449,2,,void
18121,BLOCK,-1,,"{
}",1,,455,2,,void
18126,BLOCK,-1,,"{
}",1,,460,2,,void
18131,BLOCK,-1,,"{
	SocketException::operator=(src);
	return *this;
}",1,,464,2,,void
18144,BLOCK,-1,,"{
}",1,,470,2,,void
18149,BLOCK,-1,,"{
}",1,,475,2,,void
18154,BLOCK,-1,,"{
	IOException::operator=(src);
	return *this;
}",1,,479,2,,void
18166,BLOCK,-1,,"{
}",1,,486,1,,void
18171,BLOCK,-1,,"{
}",1,,491,2,,void
18176,BLOCK,-1,,"{
	InterruptedIOException::operator=(src);
	return *this;
}",1,,495,2,,void
18209,BLOCK,-1,,<empty>,1,,1,1,,ANY
18217,BLOCK,-1,,"{
}",1,,44,1,,void
18221,BLOCK,-1,,<empty>,47,,47,1,,void
18226,BLOCK,-1,,"{
	LogLog::debug(((LogString) LOG4CXX_STR(""FB: Adding logger [""))
		+ logger->getName() + LOG4CXX_STR(""].""));
	m_priv->loggers.push_back(logger);
}",1,,50,2,,void
18256,BLOCK,-1,,"{
	error(message, e, errorCode, 0);
}",1,,59,4,,void
18269,BLOCK,-1,,"{
	LogLog::debug(((LogString) LOG4CXX_STR(""FB: The following error reported: ""))
		+  message, e);
	LogLog::debug(LOG4CXX_STR(""FB: INITIATING FALLBACK PROCEDURE.""));

	AppenderPtr primaryLocked = m_priv->primary.lock();
	AppenderPtr backupLocked = m_priv->backup.lock();

	if ( !primaryLocked || !backupLocked )
	{
		return;
	}

	for (LoggerPtr l : m_priv->loggers)
	{
		LogLog::debug(((LogString) LOG4CXX_STR(""FB: Searching for [""))
			+ primaryLocked->getName() + LOG4CXX_STR(""] in logger ["")
			+ l->getName() + LOG4CXX_STR(""].""));
		LogLog::debug(((LogString) LOG4CXX_STR(""FB: Replacing [""))
			+ primaryLocked->getName() + LOG4CXX_STR(""] by ["")
			+ backupLocked->getName() + LOG4CXX_STR(""] in logger ["")
			+ l->getName() + LOG4CXX_STR(""].""));
		l->removeAppender(primaryLocked);
		LogLog::debug(((LogString) LOG4CXX_STR(""FB: Adding appender [""))
			+ backupLocked->getName() + LOG4CXX_STR(""] to logger "")
			+ l->getName());
		l->addAppender(backupLocked);
	}
}",1,,66,5,,void
18311,BLOCK,-1,,"{
		return;
	}",2,,75,2,,void
18318,BLOCK,-1,,"{
		LogLog::debug(((LogString) LOG4CXX_STR(""FB: Searching for [""))
			+ primaryLocked->getName() + LOG4CXX_STR(""] in logger ["")
			+ l->getName() + LOG4CXX_STR(""].""));
		LogLog::debug(((LogString) LOG4CXX_STR(""FB: Replacing [""))
			+ primaryLocked->getName() + LOG4CXX_STR(""] by ["")
			+ backupLocked->getName() + LOG4CXX_STR(""] in logger ["")
			+ l->getName() + LOG4CXX_STR(""].""));
		l->removeAppender(primaryLocked);
		LogLog::debug(((LogString) LOG4CXX_STR(""FB: Adding appender [""))
			+ backupLocked->getName() + LOG4CXX_STR(""] to logger "")
			+ l->getName());
		l->addAppender(backupLocked);
	}",2,,80,3,,void
18410,BLOCK,-1,,"{
	LogLog::debug(((LogString) LOG4CXX_STR(""FB: Setting primary appender to [""))
		+ primary1->getName() + LOG4CXX_STR(""].""));
	m_priv->primary = primary1;
}",1,,97,2,,void
18436,BLOCK,-1,,"{
	LogLog::debug(((LogString) LOG4CXX_STR(""FB: Setting backup appender to [""))
		+ backup1->getName() + LOG4CXX_STR(""].""));
	m_priv->backup = backup1;

	// Make sure that we keep a reference to the appender around, since otherwise
	// the appender would be lost if it has no loggers that use it.
	LoggerRepository* repository = LogManager::getRootLogger()->getLoggerRepository();
	Hierarchy* hierarchy = dynamic_cast<Hierarchy*>(repository);
	if(hierarchy){
		hierarchy->addAppender(backup1);
	}

}",1,,104,2,,void
18476,BLOCK,-1,,"{
		hierarchy->addAppender(backup1);
	}",15,,113,2,,void
18486,BLOCK,-1,,"{
}",1,,120,2,,void
18492,BLOCK,-1,,"{
}",1,,124,3,,void
18515,BLOCK,-1,,<empty>,1,,1,1,,ANY
18518,BLOCK,-1,,<empty>,2,,33,1,,void
18523,BLOCK,-1,,<empty>,2,,38,2,,void
18529,BLOCK,-1,,<empty>,2,,43,3,,void
18535,BLOCK,-1,,"{
}",1,,51,1,,void
18540,BLOCK,-1,,"{
	LogString dst;

	if (src != 0)
	{
		Transcoder::decode(src, dst);
	}

	return dst;
}",1,,56,2,,void
18546,BLOCK,-1,,"{
		Transcoder::decode(src, dst);
	}",2,,60,2,,void
18559,BLOCK,-1,,"{
	LogString dst;
	Transcoder::decode(src, dst);
	return dst;
}",1,,69,2,,void
18573,BLOCK,-1,,"{
}",1,,78,2,,void
18578,BLOCK,-1,,"{
}",1,,83,2,,void
18583,BLOCK,-1,,"{
}",1,,119,2,,void
18588,BLOCK,-1,,"{
	if (this == &src)
	{
		return *this;
	}

	m_priv->path.assign(src.m_priv->path);
	m_priv->autoDelete = src.m_priv->autoDelete;

	return *this;
}",1,,123,2,,void
18594,BLOCK,-1,,"{
		return *this;
	}",2,,125,2,,void
18624,BLOCK,-1,,"{
	if(m_priv->autoDelete){
		Pool p;
		deleteFile(p);
	}
}",1,,137,1,,void
18629,BLOCK,-1,,"{
		Pool p;
		deleteFile(p);
	}",24,,138,2,,void
18636,BLOCK,-1,,"{
	return m_priv->path;
}",1,,146,1,,void
18645,BLOCK,-1,,"{
	m_priv->path.assign(newName);
	return *this;
}",1,,151,2,,void
18659,BLOCK,-1,,"{
	const logchar slashes[] = { 0x2F, 0x5C, 0 };
	size_t lastSlash = m_priv->path.find_last_of(slashes);

	if (lastSlash != LogString::npos)
	{
		return m_priv->path.substr(lastSlash + 1);
	}

	return m_priv->path;
}",1,,157,1,,void
18683,BLOCK,-1,,"{
		return m_priv->path.substr(lastSlash + 1);
	}",2,,162,2,,void
18702,BLOCK,-1,,"{
	int style = APR_FILEPATH_ENCODING_UNKNOWN;
	apr_filepath_encoding(&style, p.getAPRPool());
	char* retval = NULL;

	if (style == APR_FILEPATH_ENCODING_UTF8)
	{
		retval = Transcoder::encodeUTF8(m_priv->path, p);
	}
	else
	{
		retval = Transcoder::encode(m_priv->path, p);
	}

	return retval;
}",1,,170,2,,void
18722,BLOCK,-1,,"{
		retval = Transcoder::encodeUTF8(m_priv->path, p);
	}",2,,176,2,,void
18734,BLOCK,-1,,"{
		retval = Transcoder::encode(m_priv->path, p);
	}",2,,180,1,,void
18754,BLOCK,-1,,"{
	return apr_file_open(file, getPath(p), flags, perm, p.getAPRPool());
}",1,,189,5,,void
18770,BLOCK,-1,,"{
	apr_finfo_t finfo;
	apr_status_t rv = apr_stat(&finfo, getPath(p),
			0, p.getAPRPool());
	return rv == APR_SUCCESS;
}",1,,196,2,,void
18793,BLOCK,-1,,"{
	for (char* c = src; *c != 0; c++)
	{
		if (*c == '\\')
		{
			*c = '/';
		}
	}

	return src;
}",1,,204,2,,void
18795,BLOCK,-1,,<empty>,2,,205,1,,void
18806,BLOCK,4,,"{
		if (*c == '\\')
		{
			*c = '/';
		}
	}",2,,206,4,,void
18812,BLOCK,-1,,"{
			*c = '/';
		}",3,,208,2,,void
18823,BLOCK,-1,,"{
	apr_status_t rv = apr_file_remove(convertBackSlashes(getPath(p)),
			p.getAPRPool());
	return rv == APR_SUCCESS;
}",1,,217,2,,void
18844,BLOCK,-1,,"{
	apr_status_t rv = apr_file_rename(convertBackSlashes(getPath(p)),
			convertBackSlashes(dest.getPath(p)),
			p.getAPRPool());
	return rv == APR_SUCCESS;
}",1,,224,3,,void
18870,BLOCK,-1,,"{
	apr_finfo_t finfo;
	apr_status_t rv = apr_stat(&finfo, getPath(pool),
			APR_FINFO_SIZE, pool.getAPRPool());

	if (rv == APR_SUCCESS)
	{
		return (size_t) finfo.size;
	}

	return 0;
}",1,,233,2,,void
18889,BLOCK,-1,,"{
		return (size_t) finfo.size;
	}",2,,239,2,,void
18902,BLOCK,-1,,"{
	apr_finfo_t finfo;
	apr_status_t rv = apr_stat(&finfo, getPath(pool),
			APR_FINFO_MTIME, pool.getAPRPool());

	if (rv == APR_SUCCESS)
	{
		return finfo.mtime;
	}

	return 0;
}",1,,248,2,,void
18921,BLOCK,-1,,"{
		return finfo.mtime;
	}",2,,254,2,,void
18932,BLOCK,-1,,"{
	apr_dir_t* dir;
	apr_finfo_t entry;
	std::vector<LogString> filenames;

	apr_status_t stat = apr_dir_open(&dir,
			convertBackSlashes(getPath(p)),
			p.getAPRPool());

	if (stat == APR_SUCCESS)
	{
		int style = APR_FILEPATH_ENCODING_UNKNOWN;
		apr_filepath_encoding(&style, p.getAPRPool());
		stat = apr_dir_read(&entry, APR_FINFO_DIRENT, dir);

		while (stat == APR_SUCCESS)
		{
			if (entry.name != NULL)
			{
				LogString filename;

				if (style == APR_FILEPATH_ENCODING_UTF8)
				{
					Transcoder::decodeUTF8(entry.name, filename);
				}
				else
				{
					Transcoder::decode(entry.name, filename);
				}

				filenames.push_back(filename);
			}

			stat = apr_dir_read(&entry, APR_FINFO_DIRENT, dir);
		}

		stat = apr_dir_close(dir);
	}

	return filenames;
}",1,,263,2,,void
18959,BLOCK,-1,,"{
		int style = APR_FILEPATH_ENCODING_UNKNOWN;
		apr_filepath_encoding(&style, p.getAPRPool());
		stat = apr_dir_read(&entry, APR_FINFO_DIRENT, dir);

		while (stat == APR_SUCCESS)
		{
			if (entry.name != NULL)
			{
				LogString filename;

				if (style == APR_FILEPATH_ENCODING_UTF8)
				{
					Transcoder::decodeUTF8(entry.name, filename);
				}
				else
				{
					Transcoder::decode(entry.name, filename);
				}

				filenames.push_back(filename);
			}

			stat = apr_dir_read(&entry, APR_FINFO_DIRENT, dir);
		}

		stat = apr_dir_close(dir);
	}",2,,273,2,,void
18982,BLOCK,-1,,"{
			if (entry.name != NULL)
			{
				LogString filename;

				if (style == APR_FILEPATH_ENCODING_UTF8)
				{
					Transcoder::decodeUTF8(entry.name, filename);
				}
				else
				{
					Transcoder::decode(entry.name, filename);
				}

				filenames.push_back(filename);
			}

			stat = apr_dir_read(&entry, APR_FINFO_DIRENT, dir);
		}",3,,279,2,,void
18989,BLOCK,-1,,"{
				LogString filename;

				if (style == APR_FILEPATH_ENCODING_UTF8)
				{
					Transcoder::decodeUTF8(entry.name, filename);
				}
				else
				{
					Transcoder::decode(entry.name, filename);
				}

				filenames.push_back(filename);
			}",4,,281,2,,void
18995,BLOCK,-1,,"{
					Transcoder::decodeUTF8(entry.name, filename);
				}",5,,285,2,,void
19005,BLOCK,-1,,"{
					Transcoder::decode(entry.name, filename);
				}",5,,289,1,,void
19036,BLOCK,-1,,"{
	LogString::size_type slashPos = m_priv->path.rfind(LOG4CXX_STR('/'));
	LogString::size_type backPos = m_priv->path.rfind(LOG4CXX_STR('\\'));

	if (slashPos == LogString::npos)
	{
		slashPos = backPos;
	}
	else
	{
		if (backPos != LogString::npos && backPos > slashPos)
		{
			slashPos = backPos;
		}
	}

	LogString parent;

	if (slashPos != LogString::npos && slashPos > 0)
	{
		parent.assign(m_priv->path, 0, slashPos);
	}

	return parent;
}",1,,306,2,,void
19065,BLOCK,-1,,"{
		slashPos = backPos;
	}",2,,311,2,,void
19070,BLOCK,-1,,"{
		if (backPos != LogString::npos && backPos > slashPos)
		{
			slashPos = backPos;
		}
	}",2,,315,1,,void
19081,BLOCK,-1,,"{
			slashPos = backPos;
		}",3,,317,2,,void
19096,BLOCK,-1,,"{
		parent.assign(m_priv->path, 0, slashPos);
	}",2,,325,2,,void
19112,BLOCK,-1,,"{
	apr_status_t stat = apr_dir_make_recursive(convertBackSlashes(getPath(p)),
			APR_OS_DEFAULT, p.getAPRPool());
	return stat == APR_SUCCESS;
}",1,,333,2,,void
19133,BLOCK,-1,,"{
	m_priv->autoDelete = autoDelete;
}",42,,339,2,,void
19142,BLOCK,-1,,"{
	return m_priv->autoDelete;
}",33,,343,1,,void
19179,BLOCK,-1,,<empty>,1,,1,1,,ANY
19183,BLOCK,-1,,"{
}",1,,42,1,,void
19192,BLOCK,-1,,"{
	Pool p;
	activateOptions(p);
}",1,,53,6,,void
19202,BLOCK,-1,,"{
	Pool p;
	activateOptions(p);
}",1,,64,4,,void
19211,BLOCK,-1,,"{
	Pool p;
	activateOptions(p);
}",1,,71,3,,void
19219,BLOCK,-1,,"{
}",1,,78,2,,void
19223,BLOCK,-1,,"{
	finalize();
}",1,,82,1,,void
19229,BLOCK,-1,,"{
	std::lock_guard<std::recursive_mutex> lock(_priv->mutex);
	_priv->fileAppend = fileAppend1;
}",1,,87,2,,void
19240,BLOCK,1,,<empty>,,,,1,,void
19251,BLOCK,1,,<empty>,,,,1,,void
19265,BLOCK,-1,,"{
	std::lock_guard<std::recursive_mutex> lock(_priv->mutex);
	setFileInternal(file);
}",1,,93,2,,void
19276,BLOCK,1,,<empty>,,,,1,,void
19291,BLOCK,-1,,"{
	_priv->fileName = file;
}",1,,99,2,,void
19294,BLOCK,1,,<empty>,,,,1,,void
19308,BLOCK,-1,,"{
	std::lock_guard<std::recursive_mutex> lock(_priv->mutex);
	_priv->bufferedIO = bufferedIO1;

	if (bufferedIO1)
	{
		setImmediateFlush(false);
	}
}",1,,104,2,,void
19319,BLOCK,1,,<empty>,,,,1,,void
19330,BLOCK,1,,<empty>,,,,1,,void
19342,BLOCK,-1,,"{
		setImmediateFlush(false);
	}",2,,109,2,,void
19350,BLOCK,-1,,"{
	if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""FILE""), LOG4CXX_STR(""file""))
		|| StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""FILENAME""), LOG4CXX_STR(""filename"")))
	{
		std::lock_guard<std::recursive_mutex> lock(_priv->mutex);
		_priv->fileName = stripDuplicateBackslashes(value);
	}
	else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""APPEND""), LOG4CXX_STR(""append"")))
	{
		std::lock_guard<std::recursive_mutex> lock(_priv->mutex);
		_priv->fileAppend = OptionConverter::toBoolean(value, true);
	}
	else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""BUFFEREDIO""), LOG4CXX_STR(""bufferedio"")))
	{
		std::lock_guard<std::recursive_mutex> lock(_priv->mutex);
		_priv->bufferedIO = OptionConverter::toBoolean(value, false);
	}
	else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""IMMEDIATEFLUSH""), LOG4CXX_STR(""immediateflush"")))
	{
		std::lock_guard<std::recursive_mutex> lock(_priv->mutex);
		_priv->bufferedIO = !OptionConverter::toBoolean(value, fal...",1,,116,3,,void
19371,BLOCK,-1,,"{
		std::lock_guard<std::recursive_mutex> lock(_priv->mutex);
		_priv->fileName = stripDuplicateBackslashes(value);
	}",2,,119,2,,void
19382,BLOCK,1,,<empty>,,,,1,,void
19393,BLOCK,1,,<empty>,,,,1,,void
19405,BLOCK,-1,,<empty>,7,,123,1,,void
19416,BLOCK,-1,,"{
		std::lock_guard<std::recursive_mutex> lock(_priv->mutex);
		_priv->fileAppend = OptionConverter::toBoolean(value, true);
	}",2,,124,2,,void
19427,BLOCK,1,,<empty>,,,,1,,void
19438,BLOCK,1,,<empty>,,,,1,,void
19454,BLOCK,-1,,<empty>,7,,128,1,,void
19465,BLOCK,-1,,"{
		std::lock_guard<std::recursive_mutex> lock(_priv->mutex);
		_priv->bufferedIO = OptionConverter::toBoolean(value, false);
	}",2,,129,2,,void
19476,BLOCK,1,,<empty>,,,,1,,void
19487,BLOCK,1,,<empty>,,,,1,,void
19503,BLOCK,-1,,<empty>,7,,133,1,,void
19514,BLOCK,-1,,"{
		std::lock_guard<std::recursive_mutex> lock(_priv->mutex);
		_priv->bufferedIO = !OptionConverter::toBoolean(value, false);
	}",2,,134,2,,void
19525,BLOCK,1,,<empty>,,,,1,,void
19536,BLOCK,1,,<empty>,,,,1,,void
19553,BLOCK,-1,,<empty>,7,,138,1,,void
19564,BLOCK,-1,,"{
		std::lock_guard<std::recursive_mutex> lock(_priv->mutex);
		_priv->bufferSize = OptionConverter::toFileSize(value, 8 * 1024);
	}",2,,139,2,,void
19575,BLOCK,1,,<empty>,,,,1,,void
19586,BLOCK,1,,<empty>,,,,1,,void
19604,BLOCK,-1,,"{
		WriterAppender::setOption(option, value);
	}",2,,144,1,,void
19615,BLOCK,-1,,"{
	std::lock_guard<std::recursive_mutex> lock(_priv->mutex);
	activateOptionsInternal(p);
}",1,,150,2,,void
19626,BLOCK,1,,<empty>,,,,1,,void
19641,BLOCK,-1,,"{
	int errors = 0;

	if (!_priv->fileName.empty())
	{
		try
		{
			setFileInternal(_priv->fileName, _priv->fileAppend, _priv->bufferedIO, _priv->bufferSize, p);
		}
		catch (IOException& e)
		{
			errors++;
			LogString msg(LOG4CXX_STR(""setFile(""));
			msg.append(_priv->fileName);
			msg.append(1, (logchar) 0x2C /* ',' */);
			StringHelper::toString(_priv->fileAppend, msg);
			msg.append(LOG4CXX_STR("") call failed.""));
			_priv->errorHandler->error(msg, e, ErrorCode::FILE_OPEN_FAILURE);
		}
	}
	else
	{
		errors++;
		LogLog::error(LogString(LOG4CXX_STR(""File option not set for appender [""))
			+  _priv->name + LOG4CXX_STR(""].""));
		LogLog::warn(LOG4CXX_STR(""Are you using FileAppender instead of ConsoleAppender?""));
	}

	if (errors == 0)
	{
		WriterAppender::activateOptions(p);
	}
}",1,,156,2,,void
19649,BLOCK,1,,<empty>,,,,1,,void
19661,BLOCK,-1,,"{
		try
		{
			setFileInternal(_priv->fileName, _priv->fileAppend, _priv->bufferedIO, _priv->bufferSize, p);
		}
		catch (IOException& e)
		{
			errors++;
			LogString msg(LOG4CXX_STR(""setFile(""));
			msg.append(_priv->fileName);
			msg.append(1, (logchar) 0x2C /* ',' */);
			StringHelper::toString(_priv->fileAppend, msg);
			msg.append(LOG4CXX_STR("") call failed.""));
			_priv->errorHandler->error(msg, e, ErrorCode::FILE_OPEN_FAILURE);
		}
	}",2,,160,2,,void
19663,BLOCK,-1,,"{
			setFileInternal(_priv->fileName, _priv->fileAppend, _priv->bufferedIO, _priv->bufferSize, p);
		}",3,,162,1,,void
19666,BLOCK,1,,<empty>,,,,1,,void
19676,BLOCK,1,,<empty>,,,,1,,void
19686,BLOCK,1,,<empty>,,,,1,,void
19696,BLOCK,1,,<empty>,,,,1,,void
19706,BLOCK,2,,"{
			errors++;
			LogString msg(LOG4CXX_STR(""setFile(""));
			msg.append(_priv->fileName);
			msg.append(1, (logchar) 0x2C /* ',' */);
			StringHelper::toString(_priv->fileAppend, msg);
			msg.append(LOG4CXX_STR("") call failed.""));
			_priv->errorHandler->error(msg, e, ErrorCode::FILE_OPEN_FAILURE);
		}",3,,166,2,,void
19718,BLOCK,1,,<empty>,,,,1,,void
19740,BLOCK,1,,<empty>,,,,1,,void
19757,BLOCK,1,,<empty>,,,,2,,void
19775,BLOCK,-1,,"{
		errors++;
		LogLog::error(LogString(LOG4CXX_STR(""File option not set for appender [""))
			+  _priv->name + LOG4CXX_STR(""].""));
		LogLog::warn(LOG4CXX_STR(""Are you using FileAppender instead of ConsoleAppender?""));
	}",2,,177,1,,void
19788,BLOCK,1,,<empty>,,,,1,,void
19809,BLOCK,-1,,"{
		WriterAppender::activateOptions(p);
	}",2,,185,2,,void
19819,BLOCK,-1,,"{
	logchar backslash = 0x5C; // '\\'
	LogString::size_type i = src.find_last_of(backslash);

	if (i != LogString::npos)
	{
		LogString tmp(src);

		for (;
			i != LogString::npos && i > 0;
			i = tmp.find_last_of(backslash, i - 1))
		{
			//
			//   if the preceding character is a slash then
			//      remove the preceding character
			//      and continue processing
			if (tmp[i - 1] == backslash)
			{
				tmp.erase(i, 1);
				i--;

				if (i == 0)
				{
					break;
				}
			}
			else
			{
				//
				//  if there an odd number of slashes
				//     the string wasn't trying to work around
				//     OptionConverter::convertSpecialChars
				return src;
			}
		}

		return tmp;
	}

	return src;
}",1,,203,2,,void
19838,BLOCK,-1,,"{
		LogString tmp(src);

		for (;
			i != LogString::npos && i > 0;
			i = tmp.find_last_of(backslash, i - 1))
		{
			//
			//   if the preceding character is a slash then
			//      remove the preceding character
			//      and continue processing
			if (tmp[i - 1] == backslash)
			{
				tmp.erase(i, 1);
				i--;

				if (i == 0)
				{
					break;
				}
			}
			else
			{
				//
				//  if there an odd number of slashes
				//     the string wasn't trying to work around
				//     OptionConverter::convertSpecialChars
				return src;
			}
		}

		return tmp;
	}",2,,208,2,,void
19843,BLOCK,-1,,<empty>,3,,211,1,,void
19863,BLOCK,4,,"{
			//
			//   if the preceding character is a slash then
			//      remove the preceding character
			//      and continue processing
			if (tmp[i - 1] == backslash)
			{
				tmp.erase(i, 1);
				i--;

				if (i == 0)
				{
					break;
				}
			}
			else
			{
				//
				//  if there an odd number of slashes
				//     the string wasn't trying to work around
				//     OptionConverter::convertSpecialChars
				return src;
			}
		}",3,,214,4,,void
19872,BLOCK,-1,,"{
				tmp.erase(i, 1);
				i--;

				if (i == 0)
				{
					break;
				}
			}",4,,220,2,,void
19885,BLOCK,-1,,"{
					break;
				}",5,,225,2,,void
19888,BLOCK,-1,,"{
				//
				//  if there an odd number of slashes
				//     the string wasn't trying to work around
				//     OptionConverter::convertSpecialChars
				return src;
			}",4,,230,1,,void
19903,BLOCK,-1,,"{
	// It does not make sense to have immediate flush and bufferedIO.
	if (bufferedIO1)
	{
		setImmediateFlush(false);
	}

	closeWriter();

	bool writeBOM = false;

	if (StringHelper::equalsIgnoreCase(getEncoding(),
			LOG4CXX_STR(""utf-16""), LOG4CXX_STR(""UTF-16"")))
	{
		//
		//    don't want to write a byte order mark if the file exists
		//
		if (append1)
		{
			File outFile;
			outFile.setPath(filename);
			writeBOM = !outFile.exists(p);
		}
		else
		{
			writeBOM = true;
		}
	}

	OutputStreamPtr outStream;

	try
	{
		outStream = FileOutputStreamPtr(new FileOutputStream(filename, append1));
	}
	catch (IOException&)
	{
		LogString parentName = File().setPath(filename).getParent(p);

		if (!parentName.empty())
		{
			File parentDir;
			parentDir.setPath(parentName);

			if (!parentDir.exists(p) && parentDir.mkdirs(p))
			{
				outStream = OutputStreamPtr(new FileOutputStream(filename, append1));
			}
			else
			{
				throw;
			}
		}
		else
		{
			throw;
		}
	}


	//
	//   if a new fi...",1,,271,6,,void
19906,BLOCK,-1,,"{
		setImmediateFlush(false);
	}",2,,274,2,,void
19924,BLOCK,-1,,"{
		//
		//    don't want to write a byte order mark if the file exists
		//
		if (append1)
		{
			File outFile;
			outFile.setPath(filename);
			writeBOM = !outFile.exists(p);
		}
		else
		{
			writeBOM = true;
		}
	}",2,,284,2,,void
19927,BLOCK,-1,,"{
			File outFile;
			outFile.setPath(filename);
			writeBOM = !outFile.exists(p);
		}",3,,289,2,,void
19943,BLOCK,-1,,"{
			writeBOM = true;
		}",3,,295,1,,void
19949,BLOCK,-1,,"{
		outStream = FileOutputStreamPtr(new FileOutputStream(filename, append1));
	}",2,,303,1,,void
19957,BLOCK,2,,"{
		LogString parentName = File().setPath(filename).getParent(p);

		if (!parentName.empty())
		{
			File parentDir;
			parentDir.setPath(parentName);

			if (!parentDir.exists(p) && parentDir.mkdirs(p))
			{
				outStream = OutputStreamPtr(new FileOutputStream(filename, append1));
			}
			else
			{
				throw;
			}
		}
		else
		{
			throw;
		}
	}",2,,307,2,,void
19976,BLOCK,-1,,"{
			File parentDir;
			parentDir.setPath(parentName);

			if (!parentDir.exists(p) && parentDir.mkdirs(p))
			{
				outStream = OutputStreamPtr(new FileOutputStream(filename, append1));
			}
			else
			{
				throw;
			}
		}",3,,311,2,,void
19996,BLOCK,-1,,"{
				outStream = OutputStreamPtr(new FileOutputStream(filename, append1));
			}",4,,316,2,,void
20005,BLOCK,-1,,"{
				throw;
			}",4,,320,1,,void
20008,BLOCK,-1,,"{
			throw;
		}",3,,325,1,,void
20012,BLOCK,-1,,"{
		char bom[] = { (char) 0xFE, (char) 0xFF };
		ByteBuffer buf(bom, 2);
		outStream->write(buf, p);
	}",2,,335,2,,void
20039,BLOCK,-1,,"{
		newWriter = std::make_shared<BufferedWriter>(newWriter, bufferSize1);
	}",2,,344,2,,void
20056,BLOCK,1,,<empty>,,,,1,,void
20068,BLOCK,1,,<empty>,,,,1,,void
20080,BLOCK,1,,<empty>,,,,1,,void
20092,BLOCK,1,,<empty>,,,,1,,void
20109,BLOCK,-1,,"{
	return _priv->fileName;
}",1,,359,1,,void
20112,BLOCK,1,,<empty>,,,,1,,void
20124,BLOCK,-1,,"{
	return _priv->bufferedIO;
}",1,,364,1,,void
20127,BLOCK,1,,<empty>,,,,1,,void
20139,BLOCK,-1,,"{
	return _priv->bufferSize;
}",1,,369,1,,void
20142,BLOCK,1,,<empty>,,,,1,,void
20155,BLOCK,-1,,"{
	_priv->bufferSize = bufferSize1;
}",1,,374,2,,void
20158,BLOCK,1,,<empty>,,,,1,,void
20171,BLOCK,-1,,"{
	return _priv->fileAppend;
}",1,,379,1,,void
20174,BLOCK,1,,<empty>,,,,1,,void
20195,BLOCK,-1,,<empty>,1,,1,1,,ANY
20198,BLOCK,-1,,"{
	if (options.size() == 0)
	{
		std::vector<LogString> altOptions;
		altOptions.push_back(LOG4CXX_STR(""yyyy-MM-dd""));
		return DatePatternConverter::newInstance(altOptions);
	}

	return DatePatternConverter::newInstance(options);
}",1,,29,2,,void
20206,BLOCK,-1,,"{
		std::vector<LogString> altOptions;
		altOptions.push_back(LOG4CXX_STR(""yyyy-MM-dd""));
		return DatePatternConverter::newInstance(altOptions);
	}",2,,31,2,,void
20252,BLOCK,-1,,<empty>,1,,1,1,,ANY
20255,BLOCK,-1,,<empty>,46,,34,1,,void
20264,BLOCK,-1,,"{
	open(filename);
}",1,,44,2,,void
20271,BLOCK,-1,,"{
	LogString fn(filename);
	open(fn);
}",1,,50,2,,void
20281,BLOCK,-1,,"{
	apr_fileperms_t perm = APR_OS_DEFAULT;
	apr_int32_t flags = APR_READ;
	apr_status_t stat = File().setPath(filename).open(&m_priv->fileptr, flags, perm, m_priv->pool);

	if (stat != APR_SUCCESS)
	{
		throw IOException(stat);
	}
}",1,,57,2,,void
20314,BLOCK,-1,,"{
		throw IOException(stat);
	}",2,,63,2,,void
20322,BLOCK,-1,,"{
	apr_fileperms_t perm = APR_OS_DEFAULT;
	apr_int32_t flags = APR_READ;
	apr_status_t stat = aFile.open(&m_priv->fileptr, flags, perm, m_priv->pool);

	if (stat != APR_SUCCESS)
	{
		throw IOException(stat);
	}
}",1,,71,2,,void
20351,BLOCK,-1,,"{
		throw IOException(stat);
	}",2,,77,2,,void
20358,BLOCK,-1,,"{
	if (m_priv->fileptr != NULL && !APRInitializer::isDestructed)
	{
		apr_file_close(m_priv->fileptr);
	}
}",1,,84,1,,void
20370,BLOCK,-1,,"{
		apr_file_close(m_priv->fileptr);
	}",2,,86,2,,void
20378,BLOCK,-1,,"{
	apr_status_t stat = apr_file_close(m_priv->fileptr);

	if (stat == APR_SUCCESS)
	{
		m_priv->fileptr = NULL;
	}
	else
	{
		throw IOException(stat);
	}
}",1,,93,1,,void
20390,BLOCK,-1,,"{
		m_priv->fileptr = NULL;
	}",2,,97,2,,void
20397,BLOCK,-1,,"{
		throw IOException(stat);
	}",2,,101,1,,void
20405,BLOCK,-1,,"{
	apr_size_t bytesRead = buf.remaining();
	apr_status_t stat = apr_file_read(m_priv->fileptr, buf.current(), &bytesRead);
	int retval = -1;

	if (!APR_STATUS_IS_EOF(stat))
	{
		if (stat != APR_SUCCESS)
		{
			throw IOException(stat);
		}

		buf.position(buf.position() + bytesRead);
		retval = (int)bytesRead;
	}

	return retval;
}",1,,108,2,,void
20435,BLOCK,-1,,"{
		if (stat != APR_SUCCESS)
		{
			throw IOException(stat);
		}

		buf.position(buf.position() + bytesRead);
		retval = (int)bytesRead;
	}",2,,114,2,,void
20440,BLOCK,-1,,"{
			throw IOException(stat);
		}",3,,116,2,,void
20475,BLOCK,-1,,<empty>,1,,1,1,,ANY
20479,BLOCK,-1,,"{
}",1,,32,1,,void
20484,BLOCK,-1,,"{
	static WideLife<PatternConverterPtr> instance = std::make_shared<FileLocationPatternConverter>();
	return instance;
}",1,,37,2,,void
20500,BLOCK,-1,,"{
	append(toAppendTo, event->getLocationInformation().getFileName());
}",1,,46,4,,void
20530,BLOCK,-1,,<empty>,1,,1,1,,ANY
20533,BLOCK,-1,,<empty>,47,,34,1,,void
20543,BLOCK,-1,,"{
	m_priv->fileptr = open(filename, append, m_priv->pool);
}",1,,44,3,,void
20559,BLOCK,-1,,"{
	m_priv->fileptr = open(filename, append, m_priv->pool);
}",1,,50,3,,void
20576,BLOCK,-1,,"{
	apr_fileperms_t perm = APR_OS_DEFAULT;
	apr_int32_t flags = APR_WRITE | APR_CREATE;

	if (append)
	{
		flags |= APR_APPEND;
	}
	else
	{
		flags |= APR_TRUNCATE;
	}

	File fn;
	fn.setPath(filename);
	apr_file_t* fileptr = 0;
	apr_status_t stat = fn.open(&fileptr, flags, perm, pool);

	if (stat != APR_SUCCESS)
	{
		throw IOException(stat);
	}

	return fileptr;
}",1,,56,4,,void
20589,BLOCK,-1,,"{
		flags |= APR_APPEND;
	}",2,,61,2,,void
20594,BLOCK,-1,,"{
		flags |= APR_TRUNCATE;
	}",2,,65,1,,void
20624,BLOCK,-1,,"{
		throw IOException(stat);
	}",2,,75,2,,void
20633,BLOCK,-1,,"{
	if (m_priv->fileptr != NULL && !APRInitializer::isDestructed)
	{
		apr_file_close(m_priv->fileptr);
	}
}",1,,83,1,,void
20645,BLOCK,-1,,"{
		apr_file_close(m_priv->fileptr);
	}",2,,85,2,,void
20654,BLOCK,-1,,"{
	if (m_priv->fileptr != NULL)
	{
		apr_status_t stat = apr_file_close(m_priv->fileptr);

		if (stat != APR_SUCCESS)
		{
			throw IOException(stat);
		}

		m_priv->fileptr = NULL;
	}
}",1,,91,2,,void
20661,BLOCK,-1,,"{
		apr_status_t stat = apr_file_close(m_priv->fileptr);

		if (stat != APR_SUCCESS)
		{
			throw IOException(stat);
		}

		m_priv->fileptr = NULL;
	}",2,,93,2,,void
20673,BLOCK,-1,,"{
			throw IOException(stat);
		}",3,,97,2,,void
20686,BLOCK,-1,,"{
}",1,,106,2,,void
20692,BLOCK,-1,,"{
	if (m_priv->fileptr == NULL)
	{
		throw IOException(-1);
	}

	size_t nbytes = buf.remaining();
	size_t pos = buf.position();
	const char* data = buf.data();

	while (nbytes > 0)
	{
		apr_status_t stat = apr_file_write(
				m_priv->fileptr, data + pos, &nbytes);

		if (stat != APR_SUCCESS)
		{
			throw IOException(stat);
		}

		pos += nbytes;
		buf.position(pos);
		nbytes = buf.remaining();
	}
}",1,,110,3,,void
20699,BLOCK,-1,,"{
		throw IOException(-1);
	}",2,,112,2,,void
20729,BLOCK,-1,,"{
		apr_status_t stat = apr_file_write(
				m_priv->fileptr, data + pos, &nbytes);

		if (stat != APR_SUCCESS)
		{
			throw IOException(stat);
		}

		pos += nbytes;
		buf.position(pos);
		nbytes = buf.remaining();
	}",2,,121,2,,void
20746,BLOCK,-1,,"{
			throw IOException(stat);
		}",3,,126,2,,void
20767,BLOCK,-1,,"{
	return m_priv->fileptr;
}",49,,136,1,,void
20784,BLOCK,-1,,<empty>,1,,1,1,,ANY
20790,BLOCK,-1,,<empty>,78,,33,4,,void
20802,BLOCK,-1,,"{
}",1,,46,4,,void
20807,BLOCK,-1,,"{
	return priv->source.renameTo(priv->destination, pool1);
}",1,,50,2,,void
20810,BLOCK,1,,<empty>,,,,1,,void
20855,BLOCK,-1,,<empty>,1,,1,1,,ANY
20863,BLOCK,-1,,<empty>,49,,36,2,,void
20877,BLOCK,-1,,"{
}",1,,58,2,,void
20881,BLOCK,-1,,"{
	if (m_priv->thread.joinable())
		stop();
}",1,,62,1,,void
20889,BLOCK,-1,,<empty>,3,,64,2,,void
20894,BLOCK,-1,,"{
	return m_priv->thread.joinable();
}",1,,69,1,,void
20905,BLOCK,-1,,"{
	LogLog::debug(LOG4CXX_STR(""Stopping file watchdog""));
	m_priv->interrupted = 0xFFFF;

	{
		std::unique_lock<std::mutex> lock(m_priv->interrupt_mutex);
		m_priv->interrupt.notify_all();
	}
	m_priv->thread.join();
}",1,,74,1,,void
20917,BLOCK,3,,"{
		std::unique_lock<std::mutex> lock(m_priv->interrupt_mutex);
		m_priv->interrupt.notify_all();
	}",2,,78,3,,void
20945,BLOCK,-1,,"{
	return m_priv->file;
}",1,,86,1,,void
20953,BLOCK,-1,,"{
	LogString msg(LOG4CXX_STR(""Checking [""));
	msg += m_priv->file.getPath();
	msg += LOG4CXX_STR(""]"");
	LogLog::debug(msg);
	Pool pool1;

	if (!m_priv->file.exists(pool1))
	{
		if (!m_priv->warnedAlready)
		{
			LogLog::debug(((LogString) LOG4CXX_STR(""[""))
				+ m_priv->file.getPath()
				+ LOG4CXX_STR(""] does not exist.""));
			m_priv->warnedAlready = true;
		}
	}
	else
	{
		auto thisMod = m_priv->file.lastModified(pool1);

		if (thisMod > m_priv->lastModif)
		{
			m_priv->lastModif = thisMod;
			doOnChange();
			m_priv->warnedAlready = false;
		}
	}
}",1,,91,1,,void
20985,BLOCK,-1,,"{
		if (!m_priv->warnedAlready)
		{
			LogLog::debug(((LogString) LOG4CXX_STR(""[""))
				+ m_priv->file.getPath()
				+ LOG4CXX_STR(""] does not exist.""));
			m_priv->warnedAlready = true;
		}
	}",2,,99,2,,void
20991,BLOCK,-1,,"{
			LogLog::debug(((LogString) LOG4CXX_STR(""[""))
				+ m_priv->file.getPath()
				+ LOG4CXX_STR(""] does not exist.""));
			m_priv->warnedAlready = true;
		}",3,,101,2,,void
21016,BLOCK,-1,,"{
		auto thisMod = m_priv->file.lastModified(pool1);

		if (thisMod > m_priv->lastModif)
		{
			m_priv->lastModif = thisMod;
			doOnChange();
			m_priv->warnedAlready = false;
		}
	}",2,,109,1,,void
21033,BLOCK,-1,,"{
			m_priv->lastModif = thisMod;
			doOnChange();
			m_priv->warnedAlready = false;
		}",3,,113,2,,void
21048,BLOCK,-1,,"{
	LogString msg(LOG4CXX_STR(""Checking [""));
	msg += m_priv->file.getPath();
	msg += LOG4CXX_STR(""] at "");
	StringHelper::toString((int)m_priv->delay, m_priv->pool, msg);
	msg += LOG4CXX_STR("" ms interval"");
	LogLog::debug(msg);

	while (!is_interrupted())
	{
		std::unique_lock<std::mutex> lock( m_priv->interrupt_mutex );
		if (!m_priv->interrupt.wait_for( lock, std::chrono::milliseconds( m_priv->delay ),
			std::bind(&FileWatchdog::is_interrupted, this) ))
			checkAndConfigure();
	}

	LogString msg2(LOG4CXX_STR(""Stop checking [""));
	msg2 += m_priv->file.getPath();
	msg2 += LOG4CXX_STR(""]"");
	LogLog::debug(msg2);
}",1,,122,1,,void
21090,BLOCK,-1,,"{
		std::unique_lock<std::mutex> lock( m_priv->interrupt_mutex );
		if (!m_priv->interrupt.wait_for( lock, std::chrono::milliseconds( m_priv->delay ),
			std::bind(&FileWatchdog::is_interrupted, this) ))
			checkAndConfigure();
	}",2,,131,2,,void
21130,BLOCK,-1,,<empty>,4,,135,2,,void
21156,BLOCK,-1,,"{
	checkAndConfigure();
	if (!m_priv->thread.joinable())
	{
		m_priv->interrupted = 0;
		m_priv->thread = ThreadUtility::instance()->createThread(LOG4CXX_STR(""FileWatchdog""), &FileWatchdog::run, this);
	}
}",1,,145,1,,void
21166,BLOCK,-1,,"{
		m_priv->interrupted = 0;
		m_priv->thread = ThreadUtility::instance()->createThread(LOG4CXX_STR(""FileWatchdog""), &FileWatchdog::run, this);
	}",2,,148,2,,void
21193,BLOCK,-1,,"{
	return m_priv->interrupted == 0xFFFF;
}",1,,155,1,,void
21204,BLOCK,-1,,"{
	m_priv->delay = delay1;
}",41,,159,2,,void
21222,BLOCK,-1,,<empty>,1,,1,1,,ANY
21224,BLOCK,-1,,"{
}",1,,27,1,,void
21229,BLOCK,-1,,"{

}",1,,32,2,,void
21233,BLOCK,-1,,<empty>,19,,36,1,,void
21237,BLOCK,-1,,"{
	return m_priv->next;
}",1,,39,1,,void
21246,BLOCK,-1,,"{
	m_priv->next = newNext;
}",1,,44,2,,void
21256,BLOCK,-1,,"{
}",1,,49,2,,void
21262,BLOCK,-1,,"{
}",1,,53,3,,void
21275,BLOCK,-1,,<empty>,1,,1,1,,ANY
21282,BLOCK,-1,,"{
}",1,,43,1,,void
21286,BLOCK,-1,,"{
}",1,,48,1,,void
21294,BLOCK,-1,,"{
	if (m_priv->headFilter == NULL)
	{
		return false;
	}

	for (LOG4CXX_NS::spi::FilterPtr f = m_priv->headFilter; f != NULL; f = f->getNext())
	{
		switch (f->decide(event))
		{
			case Filter::DENY:
				return false;

			case Filter::ACCEPT:
				return true;

			case Filter::NEUTRAL:
				break;
		}
	}

	return true;
}",1,,57,5,,void
21301,BLOCK,-1,,"{
		return false;
	}",2,,59,2,,void
21305,BLOCK,-1,,<empty>,2,,63,1,,void
21321,BLOCK,4,,"{
		switch (f->decide(event))
		{
			case Filter::DENY:
				return false;

			case Filter::ACCEPT:
				return true;

			case Filter::NEUTRAL:
				break;
		}
	}",2,,64,4,,void
21328,BLOCK,-1,,"{
			case Filter::DENY:
				return false;

			case Filter::ACCEPT:
				return true;

			case Filter::NEUTRAL:
				break;
		}",3,,66,2,,void
21352,BLOCK,-1,,"{
	if (m_priv->headFilter == NULL)
	{
		m_priv->headFilter = newFilter;
		m_priv->tailFilter = newFilter;
	}
	else
	{
		m_priv->tailFilter->setNext(newFilter);
		m_priv->tailFilter = newFilter;
	}
}",1,,86,2,,void
21359,BLOCK,-1,,"{
		m_priv->headFilter = newFilter;
		m_priv->tailFilter = newFilter;
	}",2,,88,2,,void
21371,BLOCK,-1,,"{
		m_priv->tailFilter->setNext(newFilter);
		m_priv->tailFilter = newFilter;
	}",2,,93,1,,void
21387,BLOCK,-1,,"{
	LOG4CXX_NS::spi::FilterPtr empty;
	m_priv->headFilter = empty;
	m_priv->tailFilter = empty;
}",1,,100,1,,void
21402,BLOCK,-1,,"{
	return m_priv->headFilter;
}",1,,107,1,,void
21411,BLOCK,-1,,"{
	for (LOG4CXX_NS::spi::FilterPtr f = m_priv->headFilter; f != NULL; f = f->getNext())
	{
		f->activateOptions(p);
	}
}",1,,115,2,,void
21413,BLOCK,-1,,<empty>,2,,116,1,,void
21429,BLOCK,4,,"{
		f->activateOptions(p);
	}",2,,117,4,,void
21440,BLOCK,-1,,"{
}",1,,123,3,,void
21475,BLOCK,-1,,<empty>,1,,1,1,,ANY
21478,BLOCK,-1,,<empty>,2,,45,1,,void
21486,BLOCK,-1,,<empty>,,,,1,,<empty>
21495,BLOCK,-1,,"{
}",1,,57,1,,void
21499,BLOCK,-1,,<empty>,54,,60,1,,void
21504,BLOCK,-1,,"{
	priv->maxIndex = maxIndex1;
}",1,,63,2,,void
21507,BLOCK,1,,<empty>,,,,1,,void
21521,BLOCK,-1,,"{
	priv->minIndex = minIndex1;
}",1,,68,2,,void
21524,BLOCK,1,,<empty>,,,,1,,void
21539,BLOCK,-1,,"{
	if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""MININDEX""),
			LOG4CXX_STR(""minindex"")))
	{
		priv->minIndex = OptionConverter::toInt(value, 1);
	}
	else if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""MAXINDEX""),
			LOG4CXX_STR(""maxindex"")))
	{
		priv->maxIndex = OptionConverter::toInt(value, 7);
	}
	else if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""THROWIOEXCEPTIONONFORKFAILURE""),
			LOG4CXX_STR(""throwioexceptiononforkfailure"")))
	{
		priv->throwIOExceptionOnForkFailure = OptionConverter::toBoolean(value, true);
	}
	else
	{
		RollingPolicyBase::setOption(option, value);
	}
}",1,,74,3,,void
21550,BLOCK,-1,,"{
		priv->minIndex = OptionConverter::toInt(value, 1);
	}",2,,78,2,,void
21553,BLOCK,1,,<empty>,,,,1,,void
21569,BLOCK,-1,,<empty>,7,,81,1,,void
21580,BLOCK,-1,,"{
		priv->maxIndex = OptionConverter::toInt(value, 7);
	}",2,,84,2,,void
21583,BLOCK,1,,<empty>,,,,1,,void
21599,BLOCK,-1,,<empty>,7,,87,1,,void
21610,BLOCK,-1,,"{
		priv->throwIOExceptionOnForkFailure = OptionConverter::toBoolean(value, true);
	}",2,,90,2,,void
21613,BLOCK,1,,<empty>,,,,1,,void
21629,BLOCK,-1,,"{
		RollingPolicyBase::setOption(option, value);
	}",2,,94,1,,void
21640,BLOCK,-1,,"{
	RollingPolicyBase::activateOptions(p);

	if (priv->maxIndex < priv->minIndex)
	{
		LogLog::warn(
			LOG4CXX_STR(""MaxIndex  cannot be smaller than MinIndex.""));
		priv->maxIndex = priv->minIndex;
	}

	if ((priv->maxIndex - priv->minIndex) > MAX_WINDOW_SIZE)
	{
		LogLog::warn(LOG4CXX_STR(""Large window sizes are not allowed.""));
		priv->maxIndex = priv->minIndex + MAX_WINDOW_SIZE;
	}

	PatternConverterPtr itc = getIntegerPatternConverter();

	if (itc == NULL)
	{
		throw IllegalStateException();
	}
}",1,,103,2,,void
21649,BLOCK,1,,<empty>,,,,1,,void
21659,BLOCK,1,,<empty>,,,,1,,void
21668,BLOCK,-1,,"{
		LogLog::warn(
			LOG4CXX_STR(""MaxIndex  cannot be smaller than MinIndex.""));
		priv->maxIndex = priv->minIndex;
	}",2,,107,2,,void
21677,BLOCK,1,,<empty>,,,,1,,void
21687,BLOCK,1,,<empty>,,,,1,,void
21700,BLOCK,1,,<empty>,,,,1,,void
21710,BLOCK,1,,<empty>,,,,1,,void
21720,BLOCK,-1,,"{
		LogLog::warn(LOG4CXX_STR(""Large window sizes are not allowed.""));
		priv->maxIndex = priv->minIndex + MAX_WINDOW_SIZE;
	}",2,,114,2,,void
21729,BLOCK,1,,<empty>,,,,1,,void
21740,BLOCK,1,,<empty>,,,,1,,void
21758,BLOCK,-1,,"{
		throw IllegalStateException();
	}",2,,122,2,,void
21767,BLOCK,-1,,"{
	LogString newActiveFile(currentActiveFile);
	priv->explicitActiveFile = false;

	if (currentActiveFile.length() > 0)
	{
		priv->explicitActiveFile = true;
		newActiveFile = currentActiveFile;
	}

	if (!priv->explicitActiveFile)
	{
		LogString buf;
		ObjectPtr obj = std::make_shared<Integer>(priv->minIndex);
		formatFileName(obj, buf, pool);
		newActiveFile = buf;
	}

	ActionPtr noAction;

	return std::make_shared<RolloverDescription>(newActiveFile, append, noAction, noAction);
}",1,,134,4,,void
21773,BLOCK,1,,<empty>,,,,1,,void
21790,BLOCK,-1,,"{
		priv->explicitActiveFile = true;
		newActiveFile = currentActiveFile;
	}",2,,139,2,,void
21793,BLOCK,1,,<empty>,,,,1,,void
21809,BLOCK,1,,<empty>,,,,1,,void
21818,BLOCK,-1,,"{
		LogString buf;
		ObjectPtr obj = std::make_shared<Integer>(priv->minIndex);
		formatFileName(obj, buf, pool);
		newActiveFile = buf;
	}",2,,145,2,,void
21830,BLOCK,1,,<empty>,,,,1,,void
21866,BLOCK,-1,,"{
	RolloverDescriptionPtr desc;

	if (priv->maxIndex < 0)
	{
		return desc;
	}

	int purgeStart = priv->minIndex;

	if (!priv->explicitActiveFile)
	{
		purgeStart++;
	}

	if (!purge(purgeStart, priv->maxIndex, pool))
	{
		return desc;
	}

	LogString buf;
	ObjectPtr obj = std::make_shared<Integer>(purgeStart);
	formatFileName(obj, buf, pool);

	LogString renameTo(buf);
	LogString compressedName(renameTo);
	ActionPtr compressAction ;

	if(getCreateIntermediateDirectories()){
		File compressedFile(compressedName);
		File compressedParent (compressedFile.getParent(pool));
		compressedParent.mkdirs(pool);
	}

	if (StringHelper::endsWith(renameTo, LOG4CXX_STR("".gz"")))
	{
		renameTo.resize(renameTo.size() - 3);
		GZCompressActionPtr comp = std::make_shared<GZCompressAction>(
					File().setPath(renameTo),
					File().setPath(compressedName),
					true);
		comp->setThrowIOExceptionOnForkFailure(priv->throwIOExceptionOnForkFailure);
		compressAction = comp;
	}
	else if (StringHelper::endsWit...",1,,164,4,,void
21871,BLOCK,1,,<empty>,,,,1,,void
21881,BLOCK,-1,,"{
		return desc;
	}",2,,168,2,,void
21888,BLOCK,1,,<empty>,,,,1,,void
21900,BLOCK,1,,<empty>,,,,1,,void
21909,BLOCK,-1,,"{
		purgeStart++;
	}",2,,175,2,,void
21917,BLOCK,1,,<empty>,,,,1,,void
21927,BLOCK,-1,,"{
		return desc;
	}",2,,180,2,,void
21954,BLOCK,-1,,"{
		File compressedFile(compressedName);
		File compressedParent (compressedFile.getParent(pool));
		compressedParent.mkdirs(pool);
	}",40,,192,2,,void
21978,BLOCK,-1,,"{
		renameTo.resize(renameTo.size() - 3);
		GZCompressActionPtr comp = std::make_shared<GZCompressAction>(
					File().setPath(renameTo),
					File().setPath(compressedName),
					true);
		comp->setThrowIOExceptionOnForkFailure(priv->throwIOExceptionOnForkFailure);
		compressAction = comp;
	}",2,,199,2,,void
22016,BLOCK,1,,<empty>,,,,1,,void
22029,BLOCK,-1,,<empty>,7,,208,1,,void
22038,BLOCK,-1,,"{
		renameTo.resize(renameTo.size() - 4);
		ZipCompressActionPtr comp = std::make_shared<ZipCompressAction>(
					File().setPath(renameTo),
					File().setPath(compressedName),
					true);
		comp->setThrowIOExceptionOnForkFailure(priv->throwIOExceptionOnForkFailure);
		compressAction = comp;
	}",2,,209,2,,void
22076,BLOCK,1,,<empty>,,,,1,,void
22129,BLOCK,-1,,"{
	return priv->maxIndex;
}",1,,236,1,,void
22132,BLOCK,1,,<empty>,,,,1,,void
22144,BLOCK,-1,,"{
	return priv->minIndex;
}",1,,245,1,,void
22147,BLOCK,1,,<empty>,,,,1,,void
22162,BLOCK,-1,,"{
	int suffixLength = 0;

	std::vector<FileRenameActionPtr> renames;
	LogString buf;
	ObjectPtr obj = std::make_shared<Integer>(lowIndex);
	formatFileName(obj, buf, p);

	LogString lowFilename(buf);

	if (lowFilename.compare(lowFilename.length() - 3, 3, LOG4CXX_STR("".gz"")) == 0)
	{
		suffixLength = 3;
	}
	else if (lowFilename.compare(lowFilename.length() - 4, 4, LOG4CXX_STR("".zip"")) == 0)
	{
		suffixLength = 4;
	}

	for (int i = lowIndex; i <= highIndex; i++)
	{
		File toRenameCompressed;
		toRenameCompressed.setPath(lowFilename);
		File toRenameBase;
		toRenameBase.setPath(lowFilename.substr(0, lowFilename.length() - suffixLength));
		File* toRename = &toRenameCompressed;
		bool isBase = false;
		bool exists = toRenameCompressed.exists(p);

		if (suffixLength > 0)
		{
			if (exists)
			{
				if (toRenameBase.exists(p))
				{
					toRenameBase.deleteFile(p);
				}
			}
			else
			{
				toRename = &toRenameBase;
				exists = toRenameBase.exists(p);
				isBase = true;
			}
		}

		if (...",1,,258,4,,void
22208,BLOCK,-1,,"{
		suffixLength = 3;
	}",2,,269,2,,void
22213,BLOCK,-1,,<empty>,7,,272,1,,void
22230,BLOCK,-1,,"{
		suffixLength = 4;
	}",2,,273,2,,void
22235,BLOCK,-1,,<empty>,2,,277,1,,void
22245,BLOCK,4,,"{
		File toRenameCompressed;
		toRenameCompressed.setPath(lowFilename);
		File toRenameBase;
		toRenameBase.setPath(lowFilename.substr(0, lowFilename.length() - suffixLength));
		File* toRename = &toRenameCompressed;
		bool isBase = false;
		bool exists = toRenameCompressed.exists(p);

		if (suffixLength > 0)
		{
			if (exists)
			{
				if (toRenameBase.exists(p))
				{
					toRenameBase.deleteFile(p);
				}
			}
			else
			{
				toRename = &toRenameBase;
				exists = toRenameBase.exists(p);
				isBase = true;
			}
		}

		if (exists)
		{
			//
			//    if at upper index then
			//        attempt to delete last file
			//        if that fails then abandon purge
			if (i == highIndex)
			{
				if (!toRename->deleteFile(p))
				{
					return false;
				}

				break;
			}

			//
			//   if intermediate index
			//     add a rename action to the list
			buf.erase(buf.begin(), buf.end());
			obj = std::make_shared<Integer>(i + 1);
			formatFileName(obj, buf, p);

			LogString highFilename...",2,,278,4,,void
22289,BLOCK,-1,,"{
			if (exists)
			{
				if (toRenameBase.exists(p))
				{
					toRenameBase.deleteFile(p);
				}
			}
			else
			{
				toRename = &toRenameBase;
				exists = toRenameBase.exists(p);
				isBase = true;
			}
		}",3,,288,2,,void
22292,BLOCK,-1,,"{
				if (toRenameBase.exists(p))
				{
					toRenameBase.deleteFile(p);
				}
			}",4,,290,2,,void
22299,BLOCK,-1,,"{
					toRenameBase.deleteFile(p);
				}",5,,292,2,,void
22306,BLOCK,-1,,"{
				toRename = &toRenameBase;
				exists = toRenameBase.exists(p);
				isBase = true;
			}",4,,297,1,,void
22323,BLOCK,-1,,"{
			//
			//    if at upper index then
			//        attempt to delete last file
			//        if that fails then abandon purge
			if (i == highIndex)
			{
				if (!toRename->deleteFile(p))
				{
					return false;
				}

				break;
			}

			//
			//   if intermediate index
			//     add a rename action to the list
			buf.erase(buf.begin(), buf.end());
			obj = std::make_shared<Integer>(i + 1);
			formatFileName(obj, buf, p);

			LogString highFilename(buf);
			LogString renameTo(highFilename);

			if (isBase)
			{
				renameTo =
					highFilename.substr(0, highFilename.length() - suffixLength);
			}

			renames.push_back(std::make_shared<FileRenameAction>(*toRename, File().setPath(renameTo), true));
			lowFilename = highFilename;
		}",3,,305,2,,void
22328,BLOCK,-1,,"{
				if (!toRename->deleteFile(p))
				{
					return false;
				}

				break;
			}",4,,311,2,,void
22336,BLOCK,-1,,"{
					return false;
				}",5,,313,2,,void
22375,BLOCK,-1,,"{
				renameTo =
					highFilename.substr(0, highFilename.length() - suffixLength);
			}",4,,331,2,,void
22413,BLOCK,-1,,"{
			break;
		}",3,,340,1,,void
22416,BLOCK,-1,,<empty>,2,,348,1,,void
22432,BLOCK,4,,"{

		try
		{
			if (!(*iter)->execute(p))
			{
				return false;
			}
		}
		catch (std::exception&)
		{
			LogLog::warn(LOG4CXX_STR(""Exception during purge in RollingFileAppender""));

			return false;
		}
	}",2,,351,4,,void
22434,BLOCK,-1,,"{
			if (!(*iter)->execute(p))
			{
				return false;
			}
		}",3,,354,1,,void
22443,BLOCK,-1,,"{
				return false;
			}",4,,356,2,,void
22446,BLOCK,2,,"{
			LogLog::warn(LOG4CXX_STR(""Exception during purge in RollingFileAppender""));

			return false;
		}",3,,361,2,,void
22460,BLOCK,-1,,"{
	PatternMap specs;
	RULES_PUT(""i"", IntegerPatternConverter);
	RULES_PUT(""index"", IntegerPatternConverter);
	return specs;
}",1,,376,1,,void
22464,BLOCK,1,,<empty>,,,,3,,void
22483,BLOCK,1,,<empty>,,,,3,,void
22530,BLOCK,-1,,<empty>,1,,1,1,,ANY
22533,BLOCK,-1,,<empty>,3,,36,1,,void
22538,BLOCK,-1,,<empty>,2,,41,2,,void
22546,BLOCK,-1,,<empty>,1,,53,1,,void
22551,BLOCK,-1,,<empty>,1,,57,2,,void
22555,BLOCK,-1,,<empty>,24,,59,1,,void
22560,BLOCK,-1,,"{
	m_priv->conversionPattern = pattern;
	helpers::Pool pool;
	activateOptions(pool);
}",1,,62,2,,void
22572,BLOCK,-1,,"{
	return m_priv->conversionPattern;
}",1,,69,1,,void
22582,BLOCK,-1,,"{
	if (helpers::StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""CONVERSIONPATTERN""),
			LOG4CXX_STR(""conversionpattern"")))
	{
		m_priv->conversionPattern = helpers::OptionConverter::convertSpecialChars(value);
	}
}",1,,74,3,,void
22595,BLOCK,-1,,"{
		m_priv->conversionPattern = helpers::OptionConverter::convertSpecialChars(value);
	}",2,,78,2,,void
22611,BLOCK,-1,,"{
	m_priv->expectedPatternLength = getFormattedEventCharacterCount() * 2;
}",1,,84,2,,void
22625,BLOCK,-1,,"{
	output.reserve(m_priv->expectedPatternLength + event->getMessage().size());
	auto locationFull = fmt::format(""{}({})"",
										 event->getLocationInformation().getFileName(),
										 event->getLocationInformation().getLineNumber());
	LogString ndc;
	event->getNDC(ndc);
#if LOG4CXX_LOGCHAR_IS_WCHAR || LOG4CXX_LOGCHAR_IS_UNICHAR
	LOG4CXX_ENCODE_CHAR(sNDC, ndc);
	LOG4CXX_ENCODE_CHAR(sPattern, m_priv->conversionPattern);
	LOG4CXX_ENCODE_CHAR(sLogger, event->getLoggerName());
	LOG4CXX_ENCODE_CHAR(sLevel, event->getLevel()->toString());
	LOG4CXX_ENCODE_CHAR(sMsg, event->getMessage());
	LOG4CXX_ENCODE_CHAR(sThread, event->getThreadName());
	LOG4CXX_ENCODE_CHAR(endOfLine, LOG4CXX_EOL);
#else
	auto& sNDC = ndc;
	auto& sPattern = m_priv->conversionPattern;
	auto& sLogger = event->getLoggerName();
	auto sLevel = event->getLevel()->toString();
	auto& sMsg = event->getMessage();
	auto& sThread = event->getThreadName();
	auto endOfLine = LOG4CXX_EOL;
#endif
	fmt::format_to(std::back_inser...",1,,91,4,,void
22950,BLOCK,-1,,<empty>,1,,1,1,,ANY
22956,BLOCK,-1,,<empty>,25,,30,4,,void
22968,BLOCK,-1,,"{
}",1,,59,4,,void
22972,BLOCK,-1,,<empty>,35,,62,1,,void
22976,BLOCK,-1,,"{
	static helpers::WideLife<FormattingInfoPtr> def= std::make_shared<FormattingInfo>(false, 0, INT_MAX);
	return def;
}",1,,69,1,,void
22998,BLOCK,-1,,"{
	int rawLength = int(buffer.length() - fieldStart);

	if (rawLength > m_priv->maxLength)
	{
		buffer.erase(buffer.begin() + fieldStart,
			buffer.begin() + fieldStart + (rawLength - m_priv->maxLength));
	}
	else if (rawLength < m_priv->minLength)
	{
		if (m_priv->leftAlign)
		{
			buffer.append(m_priv->minLength - rawLength, (logchar) 0x20 /* ' ' */);
		}
		else
		{
			buffer.insert(fieldStart, m_priv->minLength - rawLength, 0x20 /* ' ' */);
		}
	}
}",1,,81,3,,void
23016,BLOCK,-1,,"{
		buffer.erase(buffer.begin() + fieldStart,
			buffer.begin() + fieldStart + (rawLength - m_priv->maxLength));
	}",2,,85,2,,void
23040,BLOCK,-1,,<empty>,7,,89,1,,void
23047,BLOCK,-1,,"{
		if (m_priv->leftAlign)
		{
			buffer.append(m_priv->minLength - rawLength, (logchar) 0x20 /* ' ' */);
		}
		else
		{
			buffer.insert(fieldStart, m_priv->minLength - rawLength, 0x20 /* ' ' */);
		}
	}",2,,90,2,,void
23052,BLOCK,-1,,"{
			buffer.append(m_priv->minLength - rawLength, (logchar) 0x20 /* ' ' */);
		}",3,,92,2,,void
23066,BLOCK,-1,,"{
			buffer.insert(fieldStart, m_priv->minLength - rawLength, 0x20 /* ' ' */);
		}",3,,96,1,,void
23081,BLOCK,-1,,"{
	return m_priv->leftAlign;
}",1,,103,1,,void
23089,BLOCK,-1,,"{
	return m_priv->minLength;
}",1,,108,1,,void
23097,BLOCK,-1,,"{
	return m_priv->maxLength;
}",1,,113,1,,void
23118,BLOCK,-1,,<empty>,1,,1,1,,ANY
23122,BLOCK,-1,,"{
}",1,,34,1,,void
23127,BLOCK,-1,,"{
	static WideLife<PatternConverterPtr> instance = std::make_shared<FullLocationPatternConverter>();
	return instance;
}",1,,39,2,,void
23143,BLOCK,-1,,"{
	append(toAppendTo, event->getLocationInformation().getFileName());
	toAppendTo.append(1, (logchar) 0x28 /* '(' */);
	StringHelper::toString(
		event->getLocationInformation().getLineNumber(),
		p, toAppendTo);
	toAppendTo.append(1, (logchar) 0x29 /* ')' */);
}",1,,48,4,,void
23202,BLOCK,-1,,<empty>,1,,1,1,,ANY
23208,BLOCK,-1,,<empty>,71,,37,4,,void
23216,BLOCK,-1,,<empty>,,,,1,,<empty>
23228,BLOCK,-1,,"{
}",1,,52,4,,void
23232,BLOCK,-1,,<empty>,39,,55,1,,void
23237,BLOCK,-1,,"{
	if (priv->source.exists(p))
	{
		apr_pool_t* aprpool = p.getAPRPool();
		apr_procattr_t* attr;
		apr_status_t stat = apr_procattr_create(&attr, aprpool);

		if (stat != APR_SUCCESS)
		{
			throw IOException(stat);
		}

		stat = apr_procattr_io_set(attr, APR_NO_PIPE, APR_FULL_BLOCK, APR_FULL_BLOCK);

		if (stat != APR_SUCCESS)
		{
			throw IOException(stat);
		}

		stat = apr_procattr_cmdtype_set(attr, APR_PROGRAM_PATH);

		if (stat != APR_SUCCESS)
		{
			throw IOException(stat);
		}

		//
		//   set child process output to destination file
		//
		apr_file_t* child_out;
		apr_int32_t flags = APR_FOPEN_READ | APR_FOPEN_WRITE |
			APR_FOPEN_CREATE | APR_FOPEN_TRUNCATE;
		stat = priv->destination.open(&child_out, flags, APR_OS_DEFAULT, p);

		if (stat != APR_SUCCESS)
		{
			throw IOException(stat);
		}

		stat =  apr_procattr_child_out_set(attr, child_out, NULL);

		if (stat != APR_SUCCESS)
		{
			throw IOException(stat);
		}

		//
		//   redirect the child's error stream to this pro...",1,,58,2,,void
23240,BLOCK,1,,<empty>,,,,1,,void
23253,BLOCK,-1,,"{
		apr_pool_t* aprpool = p.getAPRPool();
		apr_procattr_t* attr;
		apr_status_t stat = apr_procattr_create(&attr, aprpool);

		if (stat != APR_SUCCESS)
		{
			throw IOException(stat);
		}

		stat = apr_procattr_io_set(attr, APR_NO_PIPE, APR_FULL_BLOCK, APR_FULL_BLOCK);

		if (stat != APR_SUCCESS)
		{
			throw IOException(stat);
		}

		stat = apr_procattr_cmdtype_set(attr, APR_PROGRAM_PATH);

		if (stat != APR_SUCCESS)
		{
			throw IOException(stat);
		}

		//
		//   set child process output to destination file
		//
		apr_file_t* child_out;
		apr_int32_t flags = APR_FOPEN_READ | APR_FOPEN_WRITE |
			APR_FOPEN_CREATE | APR_FOPEN_TRUNCATE;
		stat = priv->destination.open(&child_out, flags, APR_OS_DEFAULT, p);

		if (stat != APR_SUCCESS)
		{
			throw IOException(stat);
		}

		stat =  apr_procattr_child_out_set(attr, child_out, NULL);

		if (stat != APR_SUCCESS)
		{
			throw IOException(stat);
		}

		//
		//   redirect the child's error stream to this processes' error stream
		//
		apr_...",2,,60,2,,void
23273,BLOCK,-1,,"{
			throw IOException(stat);
		}",3,,66,2,,void
23288,BLOCK,-1,,"{
			throw IOException(stat);
		}",3,,73,2,,void
23301,BLOCK,-1,,"{
			throw IOException(stat);
		}",3,,80,2,,void
23319,BLOCK,1,,<empty>,,,,3,,void
23340,BLOCK,-1,,"{
			throw IOException(stat);
		}",3,,93,2,,void
23354,BLOCK,-1,,"{
			throw IOException(stat);
		}",3,,100,2,,void
23369,BLOCK,-1,,"{
			stat =  apr_procattr_child_err_set(attr, child_err, NULL);

			if (stat != APR_SUCCESS)
			{
				throw IOException(stat);
			}
		}",3,,111,2,,void
23380,BLOCK,-1,,"{
				throw IOException(stat);
			}",4,,115,2,,void
23385,BLOCK,1,,<empty>,,,,1,,void
23436,BLOCK,1,,<empty>,,,,1,,void
23472,BLOCK,1,,<empty>,,,,1,,void
23481,BLOCK,-1,,"{
			throw IOException(stat);
		}",3,,134,2,,void
23486,BLOCK,-1,,<empty>,9,,136,1,,void
23494,BLOCK,1,,<empty>,,,,1,,void
23503,BLOCK,-1,,"{
			/* If we fail here (to create the gzip child process),
			 * skip the compression and consider the rotation to be
			 * otherwise successful. The caller has already rotated
			 * the log file (`source` here refers to the
			 * uncompressed, rotated path, and `destination` the
			 * same path with `.gz` appended). Remove the empty
			 * destination file and leave source as-is.
			 */
			LogLog::warn(LOG4CXX_STR(""Failed to fork gzip during log rotation; leaving log file uncompressed""));
			stat = apr_file_close(child_out);
			if (stat != APR_SUCCESS)
			{
				LogLog::warn(LOG4CXX_STR(""Failed to close abandoned .gz file; ignoring""));
			}
			return true;
		}",3,,137,2,,void
23518,BLOCK,-1,,"{
				LogLog::warn(LOG4CXX_STR(""Failed to close abandoned .gz file; ignoring""));
			}",4,,149,2,,void
23541,BLOCK,-1,,"{
			throw IOException(stat);
		}",3,,159,2,,void
23546,BLOCK,1,,<empty>,,,,1,,void
23561,BLOCK,1,,<empty>,,,,1,,void
23570,BLOCK,-1,,"{
			priv->source.deleteFile(p);
		}",3,,166,2,,void
23572,BLOCK,1,,<empty>,,,,1,,void
23593,BLOCK,-1,,"{
	priv->throwIOExceptionOnForkFailure = throwIO;
}",70,,176,2,,void
23596,BLOCK,1,,<empty>,,,,1,,void
23626,BLOCK,-1,,<empty>,1,,1,1,,ANY
23632,BLOCK,-1,,"{
	LogString ret;
	const uint8_t* bytes_u8 = static_cast<const uint8_t*>(bytes);
	LogStream sstream;
#if LOG4CXX_LOGCHAR_IS_WCHAR
	const wchar_t fill_char = L'0';
	const wchar_t space_fill_char = L' ';
#else
	const logchar fill_char = '0';
	const logchar space_fill_char = ' ';
#endif

	if(flags & HexdumpFlags::AddStartingNewline){
		sstream << LOG4CXX_EOL;
	}

	for(uint32_t offset = 0; offset < len; offset += 16){
		if(offset != 0){
			sstream << LOG4CXX_EOL;
		}

		// Print out the offset
		sstream << std::hex << std::setw(8) << std::setfill(fill_char) << offset << std::resetiosflags(std::ios_base::fmtflags(0));

		sstream << std::setw(0) << LOG4CXX_STR(""  "");

		// Print out the first 8 bytes
		for(int byte = 0; byte < 8; byte++){
			if(offset + byte >= len){
				sstream << LOG4CXX_STR(""  "");
				if(byte != 8){
					sstream << LOG4CXX_STR("" "");
				}
				continue;
			}

			sstream << std::hex << std::setw(2) << std::setfill(fill_char) << static_cast<int>(bytes_u8[offset + byte]) <...",83,,34,4,,void
23655,BLOCK,-1,,"{
		sstream << LOG4CXX_EOL;
	}",46,,46,2,,void
23660,BLOCK,-1,,<empty>,2,,50,1,,void
23671,BLOCK,4,,"{
		if(offset != 0){
			sstream << LOG4CXX_EOL;
		}

		// Print out the offset
		sstream << std::hex << std::setw(8) << std::setfill(fill_char) << offset << std::resetiosflags(std::ios_base::fmtflags(0));

		sstream << std::setw(0) << LOG4CXX_STR(""  "");

		// Print out the first 8 bytes
		for(int byte = 0; byte < 8; byte++){
			if(offset + byte >= len){
				sstream << LOG4CXX_STR(""  "");
				if(byte != 8){
					sstream << LOG4CXX_STR("" "");
				}
				continue;
			}

			sstream << std::hex << std::setw(2) << std::setfill(fill_char) << static_cast<int>(bytes_u8[offset + byte]) << std::resetiosflags(std::ios_base::fmtflags(0));
			sstream << std::setfill(space_fill_char);
			if(byte != 8){
				sstream << LOG4CXX_STR("" "");
			}
		}

		sstream << LOG4CXX_STR("" "");

		// Print out the last 8 bytes
		for(int byte = 8; byte < 16; byte++){
			if(offset + byte >= len){
				sstream << LOG4CXX_STR(""  "");
				if(byte != 15){
					sstream << LOG4CXX_STR("" "");
				}
				continue;
			}

			sstream <<...",54,,50,4,,void
23676,BLOCK,-1,,"{
			sstream << LOG4CXX_EOL;
		}",18,,51,2,,void
23722,BLOCK,-1,,<empty>,3,,61,1,,void
23732,BLOCK,4,,"{
			if(offset + byte >= len){
				sstream << LOG4CXX_STR(""  "");
				if(byte != 8){
					sstream << LOG4CXX_STR("" "");
				}
				continue;
			}

			sstream << std::hex << std::setw(2) << std::setfill(fill_char) << static_cast<int>(bytes_u8[offset + byte]) << std::resetiosflags(std::ios_base::fmtflags(0));
			sstream << std::setfill(space_fill_char);
			if(byte != 8){
				sstream << LOG4CXX_STR("" "");
			}
		}",38,,61,4,,void
23739,BLOCK,-1,,"{
				sstream << LOG4CXX_STR(""  "");
				if(byte != 8){
					sstream << LOG4CXX_STR("" "");
				}
				continue;
			}",28,,62,2,,void
23748,BLOCK,-1,,"{
					sstream << LOG4CXX_STR("" "");
				}",18,,64,2,,void
23802,BLOCK,-1,,"{
				sstream << LOG4CXX_STR("" "");
			}",17,,72,2,,void
23812,BLOCK,-1,,<empty>,3,,80,1,,void
23822,BLOCK,4,,"{
			if(offset + byte >= len){
				sstream << LOG4CXX_STR(""  "");
				if(byte != 15){
					sstream << LOG4CXX_STR("" "");
				}
				continue;
			}

			sstream << std::hex << std::setw(2) << std::setfill(fill_char) << static_cast<int>(bytes_u8[offset + byte]) << std::resetiosflags(std::ios_base::fmtflags(0));
			if(byte != 15){
				sstream << LOG4CXX_STR("" "");
			}
		}",39,,80,4,,void
23829,BLOCK,-1,,"{
				sstream << LOG4CXX_STR(""  "");
				if(byte != 15){
					sstream << LOG4CXX_STR("" "");
				}
				continue;
			}",28,,81,2,,void
23838,BLOCK,-1,,"{
					sstream << LOG4CXX_STR("" "");
				}",19,,83,2,,void
23885,BLOCK,-1,,"{
				sstream << LOG4CXX_STR("" "");
			}",18,,90,2,,void
23895,BLOCK,-1,,<empty>,3,,97,1,,void
23905,BLOCK,4,,"{
			if(offset + byte >= len){
				break;
			}
			if(std::isprint(bytes_u8[offset + byte])){
				logchar to_append = bytes_u8[offset + byte];
				sstream << to_append;
			}else{
				sstream << LOG4CXX_STR(""."");
			}
		}",39,,97,4,,void
23912,BLOCK,-1,,"{
				break;
			}",28,,98,2,,void
23924,BLOCK,-1,,"{
				logchar to_append = bytes_u8[offset + byte];
				sstream << to_append;
			}",45,,101,2,,void
23937,BLOCK,-1,,"{
				sstream << LOG4CXX_STR(""."");
			}",9,,104,1,,void
23952,BLOCK,-1,,"{
		sstream << LOG4CXX_EOL;
	}",44,,111,2,,void
23966,BLOCK,-1,,"{
		int result = 0;
		for (auto& node : m_priv->provisionNodes)
		{
			if (node.second.end() != std::find(node.second.begin(), node.second.end(), child))
				++result;
		}
		return result;
	}",2,,494,2,,void
23976,BLOCK,-1,,"{
			if (node.second.end() != std::find(node.second.begin(), node.second.end(), child))
				++result;
		}",3,,497,3,,void
24002,BLOCK,-1,,<empty>,5,,499,2,,void
24043,BLOCK,-1,,<empty>,1,,1,1,,ANY
24048,BLOCK,-1,,"{
	}",2,,53,1,,void
24067,BLOCK,-1,,"{
}",1,,77,1,,void
24071,BLOCK,-1,,"{
	std::lock_guard<std::recursive_mutex> lock(m_priv->mutex);
	for (auto& item : m_priv->loggers)
	{
		if (auto& pLogger = item.second)
		{
			pLogger->removeHierarchy();
			pLogger->removeAllAppenders();
		}
	}
	if (m_priv->root)
	{
		m_priv->root->removeHierarchy();
		m_priv->root->removeAllAppenders();
	}
}",1,,81,1,,void
24089,BLOCK,-1,,"{
		if (auto& pLogger = item.second)
		{
			pLogger->removeHierarchy();
			pLogger->removeAllAppenders();
		}
	}",2,,84,3,,void
24091,BLOCK,-1,,<empty>,7,,85,1,,void
24098,BLOCK,-1,,"{
			pLogger->removeHierarchy();
			pLogger->removeAllAppenders();
		}",3,,86,2,,void
24111,BLOCK,-1,,"{
		m_priv->root->removeHierarchy();
		m_priv->root->removeAllAppenders();
	}",2,,92,2,,void
24128,BLOCK,-1,,"{
	std::lock_guard<std::recursive_mutex> lock(m_priv->mutex);

	if (std::find(m_priv->listeners.begin(), m_priv->listeners.end(), listener) != m_priv->listeners.end())
	{
		LogLog::warn(LOG4CXX_STR(""Ignoring attempt to add an existent listener.""));
	}
	else
	{
		m_priv->listeners.push_back(listener);
	}
}",1,,99,2,,void
24166,BLOCK,-1,,"{
		LogLog::warn(LOG4CXX_STR(""Ignoring attempt to add an existent listener.""));
	}",2,,103,2,,void
24174,BLOCK,-1,,"{
		m_priv->listeners.push_back(listener);
	}",2,,107,1,,void
24186,BLOCK,-1,,"{
	std::lock_guard<std::recursive_mutex> lock(m_priv->mutex);

    auto found = std::find(m_priv->listeners.begin(), m_priv->listeners.end(), listener);
    if(found != m_priv->listeners.end()){
        m_priv->listeners.erase(found);
    }
}",1,,113,2,,void
24228,BLOCK,-1,,"{
        m_priv->listeners.erase(found);
    }",41,,117,2,,void
24239,BLOCK,-1,,"{
	std::lock_guard<std::recursive_mutex> lock(m_priv->mutex);
	m_priv->loggers.clear();
}",1,,123,1,,void
24262,BLOCK,-1,,"{
	bool emitWarning = false;
	{
		std::lock_guard<std::recursive_mutex> lock(m_priv->mutex);
		emitWarning = !m_priv->emittedNoAppenderWarning;
		m_priv->emittedNoAppenderWarning = true;
	}

	// No appender in hierarchy, warn user only once.
	if (emitWarning)
	{
		LogLog::warn(((LogString) LOG4CXX_STR(""No appender could be found for logger (""))
			+ logger->getName() + LOG4CXX_STR("").""));
		LogLog::warn(LOG4CXX_STR(""Please initialize the log4cxx system properly.""));
	}
}",1,,129,2,,void
24267,BLOCK,3,,"{
		std::lock_guard<std::recursive_mutex> lock(m_priv->mutex);
		emitWarning = !m_priv->emittedNoAppenderWarning;
		m_priv->emittedNoAppenderWarning = true;
	}",2,,131,3,,void
24293,BLOCK,-1,,"{
		LogLog::warn(((LogString) LOG4CXX_STR(""No appender could be found for logger (""))
			+ logger->getName() + LOG4CXX_STR("").""));
		LogLog::warn(LOG4CXX_STR(""Please initialize the log4cxx system properly.""));
	}",2,,139,2,,void
24320,BLOCK,-1,,"{
	std::lock_guard<std::recursive_mutex> lock(m_priv->mutex);

	LoggerPtr logger;
	LoggerMap::iterator it = m_priv->loggers.find(name);

	if (it != m_priv->loggers.end())
	{
		logger = it->second;
	}


	return logger;
}",1,,148,2,,void
24353,BLOCK,-1,,"{
		logger = it->second;
	}",2,,155,2,,void
24365,BLOCK,-1,,"{
	if (l != 0)
	{
		std::lock_guard<std::recursive_mutex> lock(m_priv->mutex);
		setThresholdInternal(l);
	}
}",1,,164,2,,void
24370,BLOCK,-1,,"{
		std::lock_guard<std::recursive_mutex> lock(m_priv->mutex);
		setThresholdInternal(l);
	}",2,,166,2,,void
24389,BLOCK,-1,,"{
	LevelPtr l(Level::toLevelLS(levelStr, 0));

	if (l != 0)
	{
		setThreshold(l);
	}
	else
	{
		LogLog::warn(((LogString) LOG4CXX_STR(""No level could be found named \""""))
			+ levelStr + LOG4CXX_STR(""\"".""));
	}
}",1,,173,2,,void
24402,BLOCK,-1,,"{
		setThreshold(l);
	}",2,,177,2,,void
24406,BLOCK,-1,,"{
		LogLog::warn(((LogString) LOG4CXX_STR(""No level could be found named \""""))
			+ levelStr + LOG4CXX_STR(""\"".""));
	}",2,,181,1,,void
24424,BLOCK,-1,,"{
	m_priv->thresholdInt = l->toInt();
	m_priv->threshold = l;

	if (m_priv->thresholdInt != Level::ALL_INT)
	{
		m_priv->configured = true;
	}
}",1,,188,2,,void
24446,BLOCK,-1,,"{
		m_priv->configured = true;
	}",2,,193,2,,void
24457,BLOCK,-1,,"{
	setConfigured(true);
	HierarchyEventListenerList clonedList;
	{
		std::lock_guard<std::recursive_mutex> lock(m_priv->mutex);
		clonedList = m_priv->listeners;
	}

	HierarchyEventListenerList::iterator it, itEnd = clonedList.end();
	HierarchyEventListenerPtr listener;

	for (it = clonedList.begin(); it != itEnd; it++)
	{
		listener = *it;
		listener->addAppenderEvent(logger, appender);
	}
}",1,,199,3,,void
24461,BLOCK,3,,"{
		std::lock_guard<std::recursive_mutex> lock(m_priv->mutex);
		clonedList = m_priv->listeners;
	}",2,,202,3,,void
24489,BLOCK,-1,,<empty>,2,,210,1,,void
24501,BLOCK,4,,"{
		listener = *it;
		listener->addAppenderEvent(logger, appender);
	}",2,,211,4,,void
24517,BLOCK,-1,,"{
	HierarchyEventListenerList clonedList;
	{
		std::lock_guard<std::recursive_mutex> lock(m_priv->mutex);
		clonedList = m_priv->listeners;
	}
	HierarchyEventListenerList::iterator it, itEnd = clonedList.end();
	HierarchyEventListenerPtr listener;

	for (it = clonedList.begin(); it != itEnd; it++)
	{
		listener = *it;
		listener->removeAppenderEvent(logger, appender);
	}
}",1,,219,3,,void
24519,BLOCK,2,,"{
		std::lock_guard<std::recursive_mutex> lock(m_priv->mutex);
		clonedList = m_priv->listeners;
	}",2,,221,2,,void
24547,BLOCK,-1,,<empty>,2,,228,1,,void
24559,BLOCK,4,,"{
		listener = *it;
		listener->removeAppenderEvent(logger, appender);
	}",2,,229,4,,void
24573,BLOCK,-1,,"{
	return m_priv->threshold ? m_priv->threshold : Level::getAll();
}",1,,236,1,,void
24590,BLOCK,-1,,"{
	static WideLife<spi::LoggerFactoryPtr> defaultFactory = std::make_shared<DefaultLoggerFactory>();
	return getLogger(name, defaultFactory);
}",1,,241,2,,void
24607,BLOCK,-1,,"{
	auto root = getRootLogger();
	std::lock_guard<std::recursive_mutex> lock(m_priv->mutex);

	LoggerMap::iterator it = m_priv->loggers.find(name);
	LoggerPtr result;

	if (it != m_priv->loggers.end())
	{
		result = it->second;
	}
	if (!result && factory)
	{
		LoggerPtr logger(factory->makeNewLoggerInstance(m_priv->pool, name));
		logger->setHierarchy(this);
		m_priv->loggers.insert(LoggerMap::value_type(name, logger));

		ProvisionNodeMap::iterator it2 = m_priv->provisionNodes.find(name);

		if (it2 != m_priv->provisionNodes.end())
		{
			updateChildren(it2->second, logger);
			m_priv->provisionNodes.erase(it2);
		}

		updateParents(logger, root);
		result = logger;
	}
	return result;

}",1,,248,3,,void
24644,BLOCK,-1,,"{
		result = it->second;
	}",2,,256,2,,void
24655,BLOCK,-1,,"{
		LoggerPtr logger(factory->makeNewLoggerInstance(m_priv->pool, name));
		logger->setHierarchy(this);
		m_priv->loggers.insert(LoggerMap::value_type(name, logger));

		ProvisionNodeMap::iterator it2 = m_priv->provisionNodes.find(name);

		if (it2 != m_priv->provisionNodes.end())
		{
			updateChildren(it2->second, logger);
			m_priv->provisionNodes.erase(it2);
		}

		updateParents(logger, root);
		result = logger;
	}",2,,260,2,,void
24702,BLOCK,-1,,"{
			updateChildren(it2->second, logger);
			m_priv->provisionNodes.erase(it2);
		}",3,,268,2,,void
24726,BLOCK,-1,,"{
	std::lock_guard<std::recursive_mutex> lock(m_priv->mutex);

	LoggerList v;
	for (auto& item : m_priv->loggers)
	{
		if (auto pLogger = item.second)
			v.push_back(pLogger);
	}
	return v;
}",1,,281,1,,void
24745,BLOCK,-1,,"{
		if (auto pLogger = item.second)
			v.push_back(pLogger);
	}",2,,286,3,,void
24747,BLOCK,-1,,<empty>,7,,287,1,,void
24754,BLOCK,-1,,<empty>,4,,288,2,,void
24765,BLOCK,-1,,"{
	std::lock_guard<std::recursive_mutex> lock(m_priv->mutex);
	if (!m_priv->root)
	{
		m_priv->root = std::make_shared<RootLogger>(m_priv->pool, Level::getDebug());
		m_priv->root->setHierarchy(const_cast<Hierarchy*>(this));
	}

	return m_priv->root;
}",1,,294,1,,void
24783,BLOCK,-1,,"{
		m_priv->root = std::make_shared<RootLogger>(m_priv->pool, Level::getDebug());
		m_priv->root->setHierarchy(const_cast<Hierarchy*>(this));
	}",2,,297,2,,void
24820,BLOCK,-1,,"{
	return m_priv->thresholdInt > level;
}",1,,306,2,,void
24831,BLOCK,-1,,"{
	std::unique_lock<std::mutex> lock(m_priv->configuredMutex);
	if (!m_priv->configured)
	{
		configurator();
		m_priv->configured = true;
	}
}",1,,311,2,,void
24849,BLOCK,-1,,"{
		configurator();
		m_priv->configured = true;
	}",2,,314,2,,void
24859,BLOCK,-1,,"{
	std::lock_guard<std::recursive_mutex> lock(m_priv->mutex);

	if (m_priv->root)
	{
		m_priv->root->setLevel(Level::getDebug());
		m_priv->root->setResourceBundle(0);
	}
	setThresholdInternal(Level::getAll());

	shutdownInternal();

	LoggerMap::const_iterator it, itEnd = m_priv->loggers.end();

	for (it = m_priv->loggers.begin(); it != itEnd; it++)
	{
		if (auto pLogger = it->second)
		{
			pLogger->setLevel(0);
			pLogger->setAdditivity(true);
			pLogger->setResourceBundle(0);
		}
	}

	//rendererMap.clear();
}",1,,321,1,,void
24876,BLOCK,-1,,"{
		m_priv->root->setLevel(Level::getDebug());
		m_priv->root->setResourceBundle(0);
	}",2,,325,2,,void
24911,BLOCK,-1,,<empty>,2,,335,1,,void
24925,BLOCK,4,,"{
		if (auto pLogger = it->second)
		{
			pLogger->setLevel(0);
			pLogger->setAdditivity(true);
			pLogger->setResourceBundle(0);
		}
	}",2,,336,4,,void
24927,BLOCK,-1,,<empty>,7,,337,1,,void
24934,BLOCK,-1,,"{
			pLogger->setLevel(0);
			pLogger->setAdditivity(true);
			pLogger->setResourceBundle(0);
		}",3,,338,2,,void
24953,BLOCK,-1,,"{
	std::lock_guard<std::recursive_mutex> lock(m_priv->mutex);

	shutdownInternal();
}",1,,349,1,,void
24970,BLOCK,-1,,"{
	m_priv->configured = false;

	// begin by closing nested appenders
	if (m_priv->root)
		m_priv->root->closeNestedAppenders();

	LoggerMap::iterator it, itEnd = m_priv->loggers.end();

	for (it = m_priv->loggers.begin(); it != itEnd; it++)
	{
		if (auto pLogger = it->second)
			pLogger->closeNestedAppenders();
	}

	// then, remove all appenders
	if (m_priv->root)
		m_priv->root->removeAllAppenders();

	for (it = m_priv->loggers.begin(); it != itEnd; it++)
	{
		if (auto pLogger = it->second)
			pLogger->removeAllAppenders();
	}
}",1,,356,1,,void
24980,BLOCK,-1,,<empty>,3,,361,2,,void
24998,BLOCK,-1,,<empty>,2,,365,1,,void
25012,BLOCK,4,,"{
		if (auto pLogger = it->second)
			pLogger->closeNestedAppenders();
	}",2,,366,4,,void
25014,BLOCK,-1,,<empty>,7,,367,1,,void
25021,BLOCK,-1,,<empty>,4,,368,2,,void
25030,BLOCK,-1,,<empty>,3,,373,2,,void
25038,BLOCK,-1,,<empty>,2,,375,1,,void
25052,BLOCK,4,,"{
		if (auto pLogger = it->second)
			pLogger->removeAllAppenders();
	}",2,,376,4,,void
25054,BLOCK,-1,,<empty>,7,,377,1,,void
25061,BLOCK,-1,,<empty>,4,,378,2,,void
25071,BLOCK,-1,,"{
	const LogString name(logger->getName());
	size_t length = name.size();
	bool parentFound = false;


	// if name = ""w.x.y.z"", loop through ""w.x.y"", ""w.x"" and ""w"", but not ""w.x.y.z""
	for (size_t i = name.find_last_of(0x2E /* '.' */, length - 1);
		(i != LogString::npos) && (i != 0);
		i = name.find_last_of(0x2E /* '.' */, i - 1))
	{
		LogString substr = name.substr(0, i);

		LoggerMap::iterator it = m_priv->loggers.find(substr);

		if (it != m_priv->loggers.end())
		{
			parentFound = true;
			logger->setParent( it->second );
			break; // no need to update the ancestors of the closest ancestor
		}
		else
		{
			ProvisionNodeMap::iterator it2 = m_priv->provisionNodes.find(substr);

			if (it2 != m_priv->provisionNodes.end())
			{
				it2->second.push_back(logger);
			}
			else
			{
				ProvisionNode node(1, logger);
				m_priv->provisionNodes.insert(
					ProvisionNodeMap::value_type(substr, node));
			}
		}
	}

	// If we could not find any existing parents, then link with root.
	if...",1,,383,3,,void
25090,BLOCK,-1,,<empty>,2,,390,1,,void
25121,BLOCK,4,,"{
		LogString substr = name.substr(0, i);

		LoggerMap::iterator it = m_priv->loggers.find(substr);

		if (it != m_priv->loggers.end())
		{
			parentFound = true;
			logger->setParent( it->second );
			break; // no need to update the ancestors of the closest ancestor
		}
		else
		{
			ProvisionNodeMap::iterator it2 = m_priv->provisionNodes.find(substr);

			if (it2 != m_priv->provisionNodes.end())
			{
				it2->second.push_back(logger);
			}
			else
			{
				ProvisionNode node(1, logger);
				m_priv->provisionNodes.insert(
					ProvisionNodeMap::value_type(substr, node));
			}
		}
	}",2,,393,4,,void
25150,BLOCK,-1,,"{
			parentFound = true;
			logger->setParent( it->second );
			break; // no need to update the ancestors of the closest ancestor
		}",3,,399,2,,void
25163,BLOCK,-1,,"{
			ProvisionNodeMap::iterator it2 = m_priv->provisionNodes.find(substr);

			if (it2 != m_priv->provisionNodes.end())
			{
				it2->second.push_back(logger);
			}
			else
			{
				ProvisionNode node(1, logger);
				m_priv->provisionNodes.insert(
					ProvisionNodeMap::value_type(substr, node));
			}
		}",3,,405,1,,void
25183,BLOCK,-1,,"{
				it2->second.push_back(logger);
			}",4,,409,2,,void
25192,BLOCK,-1,,"{
				ProvisionNode node(1, logger);
				m_priv->provisionNodes.insert(
					ProvisionNodeMap::value_type(substr, node));
			}",4,,413,1,,void
25212,BLOCK,-1,,"{
		logger->setParent( root );
	}",2,,423,2,,void
25223,BLOCK,-1,,"{
	ProvisionNode::iterator it, itEnd = pn.end();

	for (it = pn.begin(); it != itEnd; it++)
	{
		LoggerPtr& l = *it;

		// Unless this child already points to a correct (lower) parent,
		// make logger.parent point to l.parent and l.parent to logger.
		if (!StringHelper::startsWith(l->getParent()->getName(), logger->getName()))
		{
			logger->setParent( l->getParent() );
			l->setParent( logger );
		}
	}
    
}",1,,429,3,,void
25233,BLOCK,-1,,<empty>,2,,432,1,,void
25245,BLOCK,4,,"{
		LoggerPtr& l = *it;

		// Unless this child already points to a correct (lower) parent,
		// make logger.parent point to l.parent and l.parent to logger.
		if (!StringHelper::startsWith(l->getParent()->getName(), logger->getName()))
		{
			logger->setParent( l->getParent() );
			l->setParent( logger );
		}
	}",2,,433,4,,void
25268,BLOCK,-1,,"{
			logger->setParent( l->getParent() );
			l->setParent( logger );
		}",3,,439,2,,void
25286,BLOCK,-1,,"{
	for (auto& item : m_priv->loggers)
	{
		for (auto l = item.second; l; l = l->getParent())
		{
			if (l->getParent().get() == parent)
			{
				item.second->updateThreshold();
				break;
			}
		}
	}
}",1,,448,2,,void
25292,BLOCK,-1,,"{
		for (auto l = item.second; l; l = l->getParent())
		{
			if (l->getParent().get() == parent)
			{
				item.second->updateThreshold();
				break;
			}
		}
	}",2,,450,3,,void
25294,BLOCK,-1,,<empty>,3,,451,1,,void
25308,BLOCK,4,,"{
			if (l->getParent().get() == parent)
			{
				item.second->updateThreshold();
				break;
			}
		}",3,,452,4,,void
25319,BLOCK,-1,,"{
				item.second->updateThreshold();
				break;
			}",4,,454,2,,void
25331,BLOCK,-1,,"{
	std::unique_lock<std::mutex> lock(m_priv->configuredMutex, std::try_to_lock);
	if (lock.owns_lock()) // Not being auto-configured?
		m_priv->configured = newValue;
}",1,,463,2,,void
25352,BLOCK,-1,,<empty>,3,,466,2,,void
25361,BLOCK,-1,,"{
	std::unique_lock<std::mutex> lock(m_priv->configuredMutex); // Blocks while auto-configuration is active
	return m_priv->configured;
}",1,,470,1,,void
25381,BLOCK,-1,,"{
	HierarchyPtr ret(new Hierarchy);
	return ret;
}",1,,476,1,,void
25391,BLOCK,-1,,"{
	m_priv->allAppenders.clear();
}",1,,482,1,,void
25402,BLOCK,-1,,"{
	m_priv->allAppenders.push_back(appender);
}",1,,487,2,,void
25415,BLOCK,-1,,"{
	auto parentRefCount = [this](const LoggerPtr& child) -> int
	{
		int result = 0;
		for (auto& node : m_priv->provisionNodes)
		{
			if (node.second.end() != std::find(node.second.begin(), node.second.end(), child))
				++result;
		}
		return result;
	};
	bool result = false;
	std::lock_guard<std::recursive_mutex> lock(m_priv->mutex);
	auto it = m_priv->loggers.find(name);
	if (it == m_priv->loggers.end())
		;
	else if (ifNotUsed && 1 + parentRefCount(it->second) < it->second.use_count())
		;
	else
	{
		for (auto& node : m_priv->provisionNodes)
		{
			for (size_t i = node.second.size(); 0 < i; )
			{
				if (node.second[--i] == it->second)
					node.second.erase(node.second.begin() + i);
			}
		}
		m_priv->loggers.erase(it);
		result = true;
	}
	return result;
}",1,,492,3,,void
25455,BLOCK,-1,,<empty>,3,,507,2,,void
25457,BLOCK,-1,,<empty>,7,,508,1,,void
25474,BLOCK,-1,,<empty>,3,,509,2,,void
25476,BLOCK,-1,,"{
		for (auto& node : m_priv->provisionNodes)
		{
			for (size_t i = node.second.size(); 0 < i; )
			{
				if (node.second[--i] == it->second)
					node.second.erase(node.second.begin() + i);
			}
		}
		m_priv->loggers.erase(it);
		result = true;
	}",2,,511,1,,void
25482,BLOCK,-1,,"{
			for (size_t i = node.second.size(); 0 < i; )
			{
				if (node.second[--i] == it->second)
					node.second.erase(node.second.begin() + i);
			}
		}",3,,513,3,,void
25484,BLOCK,-1,,<empty>,4,,514,1,,void
25497,BLOCK,4,,"{
				if (node.second[--i] == it->second)
					node.second.erase(node.second.begin() + i);
			}",4,,515,4,,void
25509,BLOCK,-1,,<empty>,6,,517,2,,void
25562,BLOCK,-1,,<empty>,1,,1,1,,ANY
25565,BLOCK,-1,,<empty>,3,,40,1,,void
25575,BLOCK,-1,,"{
	m_priv->dateFormat.setTimeZone(TimeZone::getGMT());
	m_priv->expectedPatternLength = getFormattedEventCharacterCount() * 2;
}",1,,58,1,,void
25596,BLOCK,-1,,<empty>,27,,63,1,,void
25602,BLOCK,-1,,"{

	if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""TITLE""), LOG4CXX_STR(""title"")))
	{
		setTitle(value);
	}
	else if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""LOCATIONINFO""), LOG4CXX_STR(""locationinfo"")))
	{
		setLocationInfo(OptionConverter::toBoolean(value, false));
		m_priv->expectedPatternLength = getFormattedEventCharacterCount() * 2;
	}
}",1,,68,3,,void
25613,BLOCK,-1,,"{
		setTitle(value);
	}",2,,72,2,,void
25617,BLOCK,-1,,<empty>,7,,75,1,,void
25628,BLOCK,-1,,"{
		setLocationInfo(OptionConverter::toBoolean(value, false));
		m_priv->expectedPatternLength = getFormattedEventCharacterCount() * 2;
	}",2,,77,2,,void
25649,BLOCK,-1,,"{
	output.reserve(m_priv->expectedPatternLength + event->getMessage().size());
	output.append(LOG4CXX_EOL);
	output.append(LOG4CXX_STR(""<tr>""));
	output.append(LOG4CXX_EOL);
	output.append(LOG4CXX_STR(""<td>""));

	m_priv->dateFormat.format(output, event->getTimeStamp(), p);


	output.append(LOG4CXX_STR(""</td>""));
	output.append(LOG4CXX_EOL);

	output.append(LOG4CXX_STR(""<td title=\""""));
	LogString threadName(event->getThreadName());
	output.append(threadName);
	output.append(LOG4CXX_STR("" thread\"">""));
	output.append(threadName);
	output.append(LOG4CXX_STR(""</td>""));
	output.append(LOG4CXX_EOL);

	output.append(LOG4CXX_STR(""<td title=\""Level\"">""));

	if (event->getLevel()->equals(Level::getDebug()))
	{
		output.append(LOG4CXX_STR(""<font color=\""#339933\"">""));
		output.append(event->getLevel()->toString());
		output.append(LOG4CXX_STR(""</font>""));
	}
	else if (event->getLevel()->isGreaterOrEqual(Level::getWarn()))
	{
		output.append(LOG4CXX_STR(""<font color=\""#993300\""><strong>""));
		...",1,,86,4,,void
25767,BLOCK,-1,,"{
		output.append(LOG4CXX_STR(""<font color=\""#339933\"">""));
		output.append(event->getLevel()->toString());
		output.append(LOG4CXX_STR(""</font>""));
	}",2,,110,2,,void
25792,BLOCK,-1,,<empty>,7,,115,1,,void
25805,BLOCK,-1,,"{
		output.append(LOG4CXX_STR(""<font color=\""#993300\""><strong>""));
		output.append(event->getLevel()->toString());
		output.append(LOG4CXX_STR(""</strong></font>""));
	}",2,,116,2,,void
25830,BLOCK,-1,,"{
		output.append(event->getLevel()->toString());
	}",2,,122,1,,void
25897,BLOCK,-1,,"{
		output.append(LOG4CXX_STR(""<td>""));
		const LocationInfo& locInfo = event->getLocationInformation();
		LOG4CXX_DECODE_CHAR(fileName, locInfo.getFileName());
		Transform::appendEscapingTags(output, fileName);
		output.append(1, (logchar) 0x3A /* ':' */);
		int line = event->getLocationInformation().getLineNumber();

		if (line != 0)
		{
			StringHelper::toString(line, p, output);
		}

		output.append(LOG4CXX_STR(""</td>""));
		output.append(LOG4CXX_EOL);
	}",2,,137,2,,void
25945,BLOCK,-1,,"{
			StringHelper::toString(line, p, output);
		}",3,,146,2,,void
26008,BLOCK,-1,,"{
		output.append(LOG4CXX_STR(""<tr><td bgcolor=\""#EEEEEE\"" ""));
		output.append(LOG4CXX_STR(""style=\""font-size : xx-small;\"" colspan=\""6\"" ""));
		output.append(LOG4CXX_STR(""title=\""Nested Diagnostic Context\"">""));
		output.append(LOG4CXX_STR(""NDC: ""));
		Transform::appendEscapingTags(output, ndcVal);
		output.append(LOG4CXX_STR(""</td></tr>""));
		output.append(LOG4CXX_EOL);
	}",2,,164,2,,void
26055,BLOCK,-1,,"{
	output.append(LOG4CXX_STR(""<!DOCTYPE HTML PUBLIC ""));
	output.append(LOG4CXX_STR(""\""-//W3C//DTD HTML 4.01 Transitional//EN\"" ""));
	output.append(LOG4CXX_STR(""\""http://www.w3.org/TR/html4/loose.dtd\"">""));
	output.append(LOG4CXX_EOL);
	output.append(LOG4CXX_STR(""<html>""));
	output.append(LOG4CXX_EOL);
	output.append(LOG4CXX_STR(""<head>""));
	output.append(LOG4CXX_EOL);
	output.append(LOG4CXX_STR(""<title>""));
	output.append(m_priv->title);
	output.append(LOG4CXX_STR(""</title>""));
	output.append(LOG4CXX_EOL);
	output.append(LOG4CXX_STR(""<style type=\""text/css\"">""));
	output.append(LOG4CXX_EOL);
	output.append(LOG4CXX_STR(""<!--""));
	output.append(LOG4CXX_EOL);
	output.append(LOG4CXX_STR(""body, table {font-family: arial,sans-serif; font-size: x-small;}""));
	output.append(LOG4CXX_EOL);
	output.append(LOG4CXX_STR(""th {background: #336699; color: #FFFFFF; text-align: left;}""));
	output.append(LOG4CXX_EOL);
	output.append(LOG4CXX_STR(""-->""));
	output.append(LOG4CXX_EOL);
	output.append(LOG4...",1,,176,3,,void
26334,BLOCK,-1,,"{
		output.append(LOG4CXX_STR(""<th>File:Line</th>""));
		output.append(LOG4CXX_EOL);
	}",2,,229,2,,void
26373,BLOCK,-1,,"{
	output.append(LOG4CXX_STR(""</table>""));
	output.append(LOG4CXX_EOL);
	output.append(LOG4CXX_STR(""<br>""));
	output.append(LOG4CXX_EOL);
	output.append(LOG4CXX_STR(""</body></html>""));
}",1,,241,3,,void
26406,BLOCK,-1,,"{
	m_priv->locationInfo = locationInfoFlag;
}",1,,250,2,,void
26415,BLOCK,-1,,"{
	return m_priv->locationInfo;
}",1,,255,1,,void
26424,BLOCK,-1,,"{
	m_priv->title.assign(title1);
}",1,,260,2,,void
26435,BLOCK,-1,,"{
	return m_priv->title;
}",1,,265,1,,void
26443,BLOCK,-1,,"{
	return LOG4CXX_STR(""text/html"");
}",1,,270,1,,void
26450,BLOCK,-1,,"{
	return false;
}",1,,275,1,,void
26471,BLOCK,-1,,<empty>,1,,1,1,,ANY
26479,BLOCK,-1,,"{
}",1,,39,2,,void
26484,BLOCK,-1,,"{
}",1,,44,2,,void
26489,BLOCK,-1,,"{
	Exception::operator=(src);
	return *this;
}",1,,48,2,,void
26503,BLOCK,-1,,"{
	m_priv->ipAddrString = hostAddr;
	m_priv->hostNameString = hostName;
}",1,,56,3,,void
26517,BLOCK,-1,,<empty>,28,,61,1,,void
26522,BLOCK,-1,,"{
	LOG4CXX_ENCODE_CHAR(encodedHost, host);

	// retrieve information about the given host
	Pool addrPool;

	apr_sockaddr_t* address = 0;
	apr_status_t status =
		apr_sockaddr_info_get(&address, encodedHost.c_str(),
			APR_INET, 0, 0, addrPool.getAPRPool());

	if (status != APR_SUCCESS)
	{
		LogString msg(LOG4CXX_STR(""Cannot get information about host: ""));
		msg.append(host);
		LogLog::error(msg);
		throw UnknownHostException(msg);
	}

	std::vector<InetAddressPtr> result;
	apr_sockaddr_t* currentAddr = address;

	while (currentAddr != NULL)
	{
		// retrieve the IP address of this InetAddress.
		LogString ipAddrString;
		char* ipAddr;
		status = apr_sockaddr_ip_get(&ipAddr, currentAddr);

		if (status == APR_SUCCESS)
		{
			std::string ip(ipAddr);
			Transcoder::decode(ip, ipAddrString);
		}

		// retrieve the host name of this InetAddress.
		LogString hostNameString;
		char* hostName;
		status = apr_getnameinfo(&hostName, currentAddr, 0);

		if (status == APR_SUCCESS)
		{
			std::st...",1,,66,2,,void
26552,BLOCK,-1,,"{
		LogString msg(LOG4CXX_STR(""Cannot get information about host: ""));
		msg.append(host);
		LogLog::error(msg);
		throw UnknownHostException(msg);
	}",2,,78,2,,void
26585,BLOCK,-1,,"{
		// retrieve the IP address of this InetAddress.
		LogString ipAddrString;
		char* ipAddr;
		status = apr_sockaddr_ip_get(&ipAddr, currentAddr);

		if (status == APR_SUCCESS)
		{
			std::string ip(ipAddr);
			Transcoder::decode(ip, ipAddrString);
		}

		// retrieve the host name of this InetAddress.
		LogString hostNameString;
		char* hostName;
		status = apr_getnameinfo(&hostName, currentAddr, 0);

		if (status == APR_SUCCESS)
		{
			std::string host(hostName);
			Transcoder::decode(host, hostNameString);
		}

		result.push_back(std::make_shared<InetAddress>(hostNameString, ipAddrString));
		currentAddr = currentAddr->next;
	}",2,,89,2,,void
26598,BLOCK,-1,,"{
			std::string ip(ipAddr);
			Transcoder::decode(ip, ipAddrString);
		}",3,,96,2,,void
26621,BLOCK,-1,,"{
			std::string host(hostName);
			Transcoder::decode(host, hostNameString);
		}",3,,107,2,,void
26656,BLOCK,-1,,"{
	InetAddressPtr result;
	auto address = getAllByName(host);
	if (!address.empty())
		result = address.front();
	return result;
}",1,,123,2,,void
26669,BLOCK,-1,,<empty>,3,,127,2,,void
26681,BLOCK,-1,,"{
	return m_priv->ipAddrString;
}",1,,134,1,,void
26689,BLOCK,-1,,"{
	return m_priv->hostNameString;
}",1,,141,1,,void
26697,BLOCK,-1,,"{
	return getByName(LOG4CXX_STR(""127.0.0.1""));
}",1,,148,1,,void
26705,BLOCK,-1,,"{
	// APR_ANYADDR does not work with the LOG4CXX_STR macro
	return getByName(LOG4CXX_STR(""0.0.0.0""));
}",1,,154,1,,void
26713,BLOCK,-1,,"{
	LogString rv(getHostName());
	if (!rv.empty())
		rv.append(LOG4CXX_STR(""/""));
	rv.append(getHostAddress());
	return rv;
}",1,,163,1,,void
26723,BLOCK,-1,,<empty>,3,,166,2,,void
26747,BLOCK,-1,,<empty>,1,,1,1,,ANY
26751,BLOCK,-1,,"{
}",1,,27,1,,void
26755,BLOCK,-1,,"{
}",1,,31,1,,void
26776,BLOCK,-1,,<empty>,1,,1,1,,ANY
26782,BLOCK,-1,,<empty>,52,,34,2,,void
26788,BLOCK,-1,,<empty>,22,,37,3,,void
26795,BLOCK,-1,,"{
	if (in1 == 0)
	{
		throw NullPointerException(LOG4CXX_STR(""in parameter may not be null.""));
	}
}",1,,45,2,,void
26800,BLOCK,-1,,"{
		throw NullPointerException(LOG4CXX_STR(""in parameter may not be null.""));
	}",2,,47,2,,void
26810,BLOCK,-1,,"{
	if (in1 == 0)
	{
		throw NullPointerException(LOG4CXX_STR(""in parameter may not be null.""));
	}

	if (dec1 == 0)
	{
		throw NullPointerException(LOG4CXX_STR(""dec parameter may not be null.""));
	}
}",1,,54,3,,void
26815,BLOCK,-1,,"{
		throw NullPointerException(LOG4CXX_STR(""in parameter may not be null.""));
	}",2,,56,2,,void
26824,BLOCK,-1,,"{
		throw NullPointerException(LOG4CXX_STR(""dec parameter may not be null.""));
	}",2,,61,2,,void
26832,BLOCK,-1,,"{
}",1,,67,1,,void
26837,BLOCK,-1,,"{
	m_priv->in->close();
}",1,,71,2,,void
26848,BLOCK,-1,,"{
	const size_t BUFSIZE = 4096;
	ByteBuffer buf(p.pstralloc(BUFSIZE), BUFSIZE);
	LogString output;

	// read whole file
	while (m_priv->in->read(buf) >= 0)
	{
		buf.flip();
		log4cxx_status_t stat = m_priv->dec->decode(buf, output);

		if (stat != 0)
		{
			throw IOException(stat);
		}

		if (buf.remaining() > 0)
		{
			memmove(buf.data(), buf.current(), buf.remaining());
			buf.limit(buf.remaining());
		}
		else
		{
			buf.clear();
		}
	}

	return output;
}",1,,76,2,,void
26872,BLOCK,-1,,"{
		buf.flip();
		log4cxx_status_t stat = m_priv->dec->decode(buf, output);

		if (stat != 0)
		{
			throw IOException(stat);
		}

		if (buf.remaining() > 0)
		{
			memmove(buf.data(), buf.current(), buf.remaining());
			buf.limit(buf.remaining());
		}
		else
		{
			buf.clear();
		}
	}",2,,83,2,,void
26892,BLOCK,-1,,"{
			throw IOException(stat);
		}",3,,88,2,,void
26903,BLOCK,-1,,"{
			memmove(buf.data(), buf.current(), buf.remaining());
			buf.limit(buf.remaining());
		}",3,,93,2,,void
26926,BLOCK,-1,,"{
			buf.clear();
		}",3,,98,1,,void
26943,BLOCK,-1,,<empty>,1,,1,1,,ANY
26947,BLOCK,-1,,"{
}",1,,28,1,,void
26952,BLOCK,-1,,"{
}",1,,32,2,,void
26956,BLOCK,-1,,"{
}",1,,36,1,,void
26971,BLOCK,-1,,<empty>,1,,1,1,,ANY
26975,BLOCK,-1,,"{
}",1,,32,1,,void
26980,BLOCK,-1,,"{
	static WideLife<PatternConverterPtr> instance = std::make_shared<IntegerPatternConverter>();
	return instance;
}",1,,37,2,,void
26996,BLOCK,-1,,"{
	IntegerPtr i = LOG4CXX_NS::cast<Integer>(obj);

	if (i != NULL)
	{
		StringHelper::toString(i->intValue(), p, toAppendTo);
	}
}",1,,46,4,,void
27011,BLOCK,-1,,"{
		StringHelper::toString(i->intValue(), p, toAppendTo);
	}",2,,50,2,,void
27046,BLOCK,-1,,<empty>,1,,1,1,,ANY
27051,BLOCK,-1,,<empty>,21,,44,1,,void
27062,BLOCK,-1,,"{
}",1,,64,1,,void
27066,BLOCK,-1,,<empty>,26,,67,1,,void
27071,BLOCK,-1,,"{
	m_priv->locationInfo = locationInfoFlag;
}",1,,70,2,,void
27080,BLOCK,-1,,"{
	return m_priv->locationInfo;
}",1,,75,1,,void
27089,BLOCK,-1,,"{
	m_priv->prettyPrint = prettyPrintFlag;
}",1,,80,2,,void
27098,BLOCK,-1,,"{
	return m_priv->prettyPrint;
}",1,,85,1,,void
27107,BLOCK,-1,,"{
	m_priv->threadInfo = newValue;
}",1,,90,2,,void
27116,BLOCK,-1,,"{
	return m_priv->threadInfo;
}",1,,95,1,,void
27124,BLOCK,-1,,"{
	return LOG4CXX_STR(""application/json"");
}",1,,100,1,,void
27132,BLOCK,-1,,"{
	m_priv->expectedPatternLength = getFormattedEventCharacterCount() * 2;
}",1,,105,2,,void
27145,BLOCK,-1,,"{
	if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""LOCATIONINFO""), LOG4CXX_STR(""locationinfo"")))
	{
		setLocationInfo(OptionConverter::toBoolean(value, false));
	}
	else if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""THREADINFO""), LOG4CXX_STR(""threadinfo"")))
	{
		setThreadInfo(OptionConverter::toBoolean(value, false));
	}
	else if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""PRETTYPRINT""), LOG4CXX_STR(""prettyprint"")))
	{
		setPrettyPrint(OptionConverter::toBoolean(value, false));
	}
}",1,,110,3,,void
27156,BLOCK,-1,,"{
		setLocationInfo(OptionConverter::toBoolean(value, false));
	}",2,,113,2,,void
27165,BLOCK,-1,,<empty>,7,,116,1,,void
27176,BLOCK,-1,,"{
		setThreadInfo(OptionConverter::toBoolean(value, false));
	}",2,,118,2,,void
27185,BLOCK,-1,,<empty>,7,,121,1,,void
27196,BLOCK,-1,,"{
		setPrettyPrint(OptionConverter::toBoolean(value, false));
	}",2,,123,2,,void
27210,BLOCK,-1,,"{
	output.reserve(m_priv->expectedPatternLength + event->getMessage().size());
	output.append(LOG4CXX_STR(""{""));
	output.append(m_priv->prettyPrint ? LOG4CXX_EOL : LOG4CXX_STR("" ""));

	if (m_priv->prettyPrint)
	{
		output.append(m_priv->ppIndentL1);
	}

	appendQuotedEscapedString(output, LOG4CXX_STR(""timestamp""));
	output.append(LOG4CXX_STR("": ""));
	LogString timestamp;
	m_priv->dateFormat.format(timestamp, event->getTimeStamp(), p);
	appendQuotedEscapedString(output, timestamp);
	output.append(LOG4CXX_STR("",""));
	output.append(m_priv->prettyPrint ? LOG4CXX_EOL : LOG4CXX_STR("" ""));

	if (m_priv->threadInfo)
	{
		if (m_priv->prettyPrint)
		{
			output.append(m_priv->ppIndentL1);
		}
		appendQuotedEscapedString(output, LOG4CXX_STR(""thread""));
		output.append(LOG4CXX_STR("": ""));
		appendQuotedEscapedString(output, event->getThreadName());
		output.append(LOG4CXX_STR("",""));
		output.append(m_priv->prettyPrint ? LOG4CXX_EOL : LOG4CXX_STR("" ""));
	}

	if (m_priv->prettyPrint)
	{
		output.a...",1,,131,4,,void
27247,BLOCK,-1,,"{
		output.append(m_priv->ppIndentL1);
	}",2,,137,2,,void
27302,BLOCK,-1,,"{
		if (m_priv->prettyPrint)
		{
			output.append(m_priv->ppIndentL1);
		}
		appendQuotedEscapedString(output, LOG4CXX_STR(""thread""));
		output.append(LOG4CXX_STR("": ""));
		appendQuotedEscapedString(output, event->getThreadName());
		output.append(LOG4CXX_STR("",""));
		output.append(m_priv->prettyPrint ? LOG4CXX_EOL : LOG4CXX_STR("" ""));
	}",2,,150,2,,void
27307,BLOCK,-1,,"{
			output.append(m_priv->ppIndentL1);
		}",3,,152,2,,void
27352,BLOCK,-1,,"{
		output.append(m_priv->ppIndentL1);
	}",2,,163,2,,void
27403,BLOCK,-1,,"{
		output.append(m_priv->ppIndentL1);
	}",2,,176,2,,void
27448,BLOCK,-1,,"{
		output.append(m_priv->ppIndentL1);
	}",2,,187,2,,void
27482,BLOCK,-1,,"{
		output.append(LOG4CXX_STR("",""));
		output.append(m_priv->prettyPrint ? LOG4CXX_EOL : LOG4CXX_STR("" ""));
		appendSerializedLocationInfo(output, event, p);
	}",2,,199,2,,void
27531,BLOCK,-1,,"{
	appendItem(input, buf);
}",1,,212,3,,void
27540,BLOCK,-1,,"{
	/* add leading quote */
	buf.push_back(0x22);

	logchar specialChars[] =
	{
		0x08,   /* \b backspace         */
		0x09,   /* \t tab               */
		0x0a,   /* \n newline           */
		0x0c,   /* \f form feed         */
		0x0d,   /* \r carriage return   */
		0x22,   /* \"" double quote      */
		0x5c,   /* \\ backslash         */
		0x00    /* terminating NULL for C-strings */
	};

	size_t start = 0;
	size_t found = input.find_first_of(specialChars, start);

	while (found != LogString::npos)
	{
		if (found > start)
		{
			buf.append(input, start, found - start);
		}

		switch (input[found])
		{
			case 0x08:
				/* \b backspace */
				buf.push_back(0x5c);
				buf.push_back('b');
				break;

			case 0x09:
				/* \t tab */
				buf.push_back(0x5c);
				buf.push_back('t');
				break;

			case 0x0a:
				/* \n newline */
				buf.push_back(0x5c);
				buf.push_back('n');
				break;

			case 0x0c:
				/* \f form feed */
				buf.push_back(0x5c);
				buf.push_back('f');
				break;

			cas...",1,,217,3,,void
27577,BLOCK,-1,,"{
		if (found > start)
		{
			buf.append(input, start, found - start);
		}

		switch (input[found])
		{
			case 0x08:
				/* \b backspace */
				buf.push_back(0x5c);
				buf.push_back('b');
				break;

			case 0x09:
				/* \t tab */
				buf.push_back(0x5c);
				buf.push_back('t');
				break;

			case 0x0a:
				/* \n newline */
				buf.push_back(0x5c);
				buf.push_back('n');
				break;

			case 0x0c:
				/* \f form feed */
				buf.push_back(0x5c);
				buf.push_back('f');
				break;

			case 0x0d:
				/* \r carriage return */
				buf.push_back(0x5c);
				buf.push_back('r');
				break;

			case 0x22:
				/* \"" double quote */
				buf.push_back(0x5c);
				buf.push_back(0x22);
				break;

			case 0x5c:
				/* \\ backslash */
				buf.push_back(0x5c);
				buf.push_back(0x5c);
				break;

			default:
				buf.push_back(input[found]);
				break;
		}

		start = found + 1;

		if (found < input.size())
		{
			found = input.find_first_of(specialChars, start);
		}
		else
		{
			found = LogString:...",2,,237,2,,void
27582,BLOCK,-1,,"{
			buf.append(input, start, found - start);
		}",3,,239,2,,void
27596,BLOCK,-1,,"{
			case 0x08:
				/* \b backspace */
				buf.push_back(0x5c);
				buf.push_back('b');
				break;

			case 0x09:
				/* \t tab */
				buf.push_back(0x5c);
				buf.push_back('t');
				break;

			case 0x0a:
				/* \n newline */
				buf.push_back(0x5c);
				buf.push_back('n');
				break;

			case 0x0c:
				/* \f form feed */
				buf.push_back(0x5c);
				buf.push_back('f');
				break;

			case 0x0d:
				/* \r carriage return */
				buf.push_back(0x5c);
				buf.push_back('r');
				break;

			case 0x22:
				/* \"" double quote */
				buf.push_back(0x5c);
				buf.push_back(0x22);
				break;

			case 0x5c:
				/* \\ backslash */
				buf.push_back(0x5c);
				buf.push_back(0x5c);
				break;

			default:
				buf.push_back(input[found]);
				break;
		}",3,,244,2,,void
27709,BLOCK,-1,,"{
			found = input.find_first_of(specialChars, start);
		}",3,,295,2,,void
27719,BLOCK,-1,,"{
			found = LogString::npos;
		}",3,,299,1,,void
27732,BLOCK,-1,,"{
		buf.append(input, start, input.size() - start);
	}",2,,305,2,,void
27755,BLOCK,-1,,"{
	LoggingEvent::KeySet keys = event->getMDCKeySet();

	if (keys.empty())
	{
		return;
	}

	buf.append(LOG4CXX_STR("",""));
	buf.append(m_priv->prettyPrint ? LOG4CXX_EOL : LOG4CXX_STR("" ""));

	if (m_priv->prettyPrint)
	{
		buf.append(m_priv->ppIndentL1);
	}

	appendQuotedEscapedString(buf, LOG4CXX_STR(""context_map""));
	buf.append(LOG4CXX_STR("": {""));
	buf.append(m_priv->prettyPrint ? LOG4CXX_EOL : LOG4CXX_STR("" ""));

	for (LoggingEvent::KeySet::iterator it = keys.begin();
		it != keys.end(); ++it)
	{
		if (m_priv->prettyPrint)
		{
			buf.append(m_priv->ppIndentL2);
		}

		appendQuotedEscapedString(buf, *it);
		buf.append(LOG4CXX_STR("": ""));
		LogString value;
		event->getMDC(*it, value);
		appendQuotedEscapedString(buf, value);

		/* if this isn't the last k:v pair, we need a comma */
		if (it + 1 != keys.end())
		{
			buf.append(LOG4CXX_STR("",""));
			buf.append(m_priv->prettyPrint ? LOG4CXX_EOL : LOG4CXX_STR("" ""));
		}
		else
		{
			buf.append(m_priv->prettyPrint ? LOG4CXX_EOL : LOG4...",1,,315,3,,void
27768,BLOCK,-1,,"{
		return;
	}",2,,319,2,,void
27791,BLOCK,-1,,"{
		buf.append(m_priv->ppIndentL1);
	}",2,,327,2,,void
27821,BLOCK,-1,,<empty>,2,,335,1,,void
27837,BLOCK,4,,"{
		if (m_priv->prettyPrint)
		{
			buf.append(m_priv->ppIndentL2);
		}

		appendQuotedEscapedString(buf, *it);
		buf.append(LOG4CXX_STR("": ""));
		LogString value;
		event->getMDC(*it, value);
		appendQuotedEscapedString(buf, value);

		/* if this isn't the last k:v pair, we need a comma */
		if (it + 1 != keys.end())
		{
			buf.append(LOG4CXX_STR("",""));
			buf.append(m_priv->prettyPrint ? LOG4CXX_EOL : LOG4CXX_STR("" ""));
		}
		else
		{
			buf.append(m_priv->prettyPrint ? LOG4CXX_EOL : LOG4CXX_STR("" ""));
		}
	}",2,,337,4,,void
27842,BLOCK,-1,,"{
			buf.append(m_priv->ppIndentL2);
		}",3,,339,2,,void
27880,BLOCK,-1,,"{
			buf.append(LOG4CXX_STR("",""));
			buf.append(m_priv->prettyPrint ? LOG4CXX_EOL : LOG4CXX_STR("" ""));
		}",3,,351,2,,void
27899,BLOCK,-1,,"{
			buf.append(m_priv->prettyPrint ? LOG4CXX_EOL : LOG4CXX_STR("" ""));
		}",3,,356,1,,void
27915,BLOCK,-1,,"{
		buf.append(m_priv->ppIndentL1);
	}",2,,362,2,,void
27934,BLOCK,-1,,"{
	LogString ndcVal;

	if (!event->getNDC(ndcVal))
	{
		return;
	}

	buf.append(LOG4CXX_STR("",""));
	buf.append(m_priv->prettyPrint ? LOG4CXX_EOL : LOG4CXX_STR("" ""));

	if (m_priv->prettyPrint)
	{
		buf.append(m_priv->ppIndentL1);
	}

	appendQuotedEscapedString(buf, LOG4CXX_STR(""context_stack""));
	buf.append(LOG4CXX_STR("": [""));
	buf.append(m_priv->prettyPrint ? LOG4CXX_EOL : LOG4CXX_STR("" ""));

	if (m_priv->prettyPrint)
	{
		buf.append(m_priv->ppIndentL2);
	}

	appendQuotedEscapedString(buf, ndcVal);
	buf.append(m_priv->prettyPrint ? LOG4CXX_EOL : LOG4CXX_STR("" ""));

	if (m_priv->prettyPrint)
	{
		buf.append(m_priv->ppIndentL1);
	}

	buf.append(LOG4CXX_STR(""]""));
}",1,,371,3,,void
27943,BLOCK,-1,,"{
		return;
	}",2,,375,2,,void
27966,BLOCK,-1,,"{
		buf.append(m_priv->ppIndentL1);
	}",2,,383,2,,void
27999,BLOCK,-1,,"{
		buf.append(m_priv->ppIndentL2);
	}",2,,392,2,,void
28025,BLOCK,-1,,"{
		buf.append(m_priv->ppIndentL1);
	}",2,,400,2,,void
28045,BLOCK,-1,,"{
	if (m_priv->prettyPrint)
	{
		buf.append(m_priv->ppIndentL1);
	}

	appendQuotedEscapedString(buf, LOG4CXX_STR(""location_info""));
	buf.append(LOG4CXX_STR("": {""));
	buf.append(m_priv->prettyPrint ? LOG4CXX_EOL : LOG4CXX_STR("" ""));
	const LocationInfo& locInfo = event->getLocationInformation();

	if (m_priv->prettyPrint)
	{
		buf.append(m_priv->ppIndentL2);
	}

	appendQuotedEscapedString(buf, LOG4CXX_STR(""file""));
	buf.append(LOG4CXX_STR("": ""));
	LOG4CXX_DECODE_CHAR(fileName, locInfo.getFileName());
	appendQuotedEscapedString(buf, fileName);
	buf.append(LOG4CXX_STR("",""));
	buf.append(m_priv->prettyPrint ? LOG4CXX_EOL : LOG4CXX_STR("" ""));

	if (m_priv->prettyPrint)
	{
		buf.append(m_priv->ppIndentL2);
	}

	appendQuotedEscapedString(buf, LOG4CXX_STR(""line""));
	buf.append(LOG4CXX_STR("": ""));
	LogString lineNumber;
	StringHelper::toString(locInfo.getLineNumber(), p, lineNumber);
	appendQuotedEscapedString(buf, lineNumber);
	buf.append(LOG4CXX_STR("",""));
	buf.append(m_priv->prettyPrint ?...",1,,409,4,,void
28050,BLOCK,-1,,"{
		buf.append(m_priv->ppIndentL1);
	}",2,,411,2,,void
28090,BLOCK,-1,,"{
		buf.append(m_priv->ppIndentL2);
	}",2,,421,2,,void
28138,BLOCK,-1,,"{
		buf.append(m_priv->ppIndentL2);
	}",2,,433,2,,void
28191,BLOCK,-1,,"{
		buf.append(m_priv->ppIndentL2);
	}",2,,446,2,,void
28239,BLOCK,-1,,"{
		buf.append(m_priv->ppIndentL2);
	}",2,,458,2,,void
28281,BLOCK,-1,,"{
		buf.append(m_priv->ppIndentL1);
	}",2,,469,2,,void
28305,BLOCK,-1,,<empty>,1,,1,1,,ANY
28309,BLOCK,-1,,<empty>,19,,26,1,,void
28313,BLOCK,-1,,"{
	return LOG4CXX_STR(""text/plain"");
}",1,,29,1,,void
28322,BLOCK,-1,,<empty>,67,,33,3,,void
28328,BLOCK,-1,,<empty>,67,,35,3,,void
28332,BLOCK,-1,,"{
	auto exampleEvent = std::make_shared<spi::LoggingEvent>
		( LOG4CXX_STR(""example.logger"")
		, Level::getDebug()
		, LOG4CXX_LOCATION
		, LogString()
		);
	LogString text;
	Pool pool;
	format(text, exampleEvent, pool);
	return text.size();
}",1,,41,1,,void
28383,BLOCK,-1,,<empty>,1,,1,1,,ANY
28386,BLOCK,-1,,"{
	static WideLife<LevelPtr> fatalLevel = std::make_shared<Level>(Level::FATAL_INT, LOG4CXX_STR(""FATAL""), 0);
	return fatalLevel;
}",1,,40,1,,void
28409,BLOCK,-1,,"{
	static WideLife<LevelPtr> errorLevel = std::make_shared<Level>(Level::ERROR_INT, LOG4CXX_STR(""ERROR""), 3);
	return errorLevel;
}",1,,46,1,,void
28432,BLOCK,-1,,"{
	static WideLife<LevelPtr> warnLevel = std::make_shared<Level>(Level::WARN_INT, LOG4CXX_STR(""WARN""), 4);
	return warnLevel;
}",1,,52,1,,void
28455,BLOCK,-1,,"{
	static WideLife<LevelPtr> infoLevel = std::make_shared<Level>(Level::INFO_INT, LOG4CXX_STR(""INFO""), 6);
	return infoLevel;
}",1,,58,1,,void
28478,BLOCK,-1,,"{
	static WideLife<LevelPtr> debugLevel = std::make_shared<Level>(Level::DEBUG_INT, LOG4CXX_STR(""DEBUG""), 7);
	return debugLevel;
}",1,,64,1,,void
28501,BLOCK,-1,,"{
	static WideLife<LevelPtr> traceLevel = std::make_shared<Level>(Level::TRACE_INT, LOG4CXX_STR(""TRACE""), 7);
	return traceLevel;
}",1,,70,1,,void
28524,BLOCK,-1,,"{
	static WideLife<LevelPtr> allLevel = std::make_shared<Level>(Level::ALL_INT, LOG4CXX_STR(""ALL""), 7);
	return allLevel;
}",1,,77,1,,void
28550,BLOCK,-1,,"{
	APRInitializer::initialize();
}",1,,87,4,,void
28559,BLOCK,-1,,"{
	return toLevelLS(sArg, Level::getDebug());
}",1,,93,2,,void
28570,BLOCK,-1,,"{
	return name;
}",1,,98,1,,void
28577,BLOCK,-1,,"{
	return toLevel(val, Level::getDebug());
}",1,,104,2,,void
28590,BLOCK,-1,,"{
	switch (val)
	{
		case ALL_INT:
			return getAll();

		case DEBUG_INT:
			return getDebug();

		case TRACE_INT:
			return getTrace();

		case INFO_INT:
			return getInfo();

		case WARN_INT:
			return getWarn();

		case ERROR_INT:
			return getError();

		case FATAL_INT:
			return getFatal();

		case OFF_INT:
			return getOff();

		default:
			return defaultLevel;
	}
}",1,,109,3,,void
28593,BLOCK,-1,,"{
		case ALL_INT:
			return getAll();

		case DEBUG_INT:
			return getDebug();

		case TRACE_INT:
			return getTrace();

		case INFO_INT:
			return getInfo();

		case WARN_INT:
			return getWarn();

		case ERROR_INT:
			return getError();

		case FATAL_INT:
			return getFatal();

		case OFF_INT:
			return getOff();

		default:
			return defaultLevel;
	}",2,,111,2,,void
28633,BLOCK,-1,,"{
	return toLevel(sArg, Level::getDebug());
}",1,,142,2,,void
28646,BLOCK,-1,,"{
	LOG4CXX_DECODE_CHAR(s, sArg);
	return toLevelLS(s, defaultLevel);
}",1,,147,3,,void
28658,BLOCK,-1,,"{
	Transcoder::encode(name, dst);
}",1,,153,2,,void
28670,BLOCK,-1,,"{
	const LogString trimmed(StringHelper::trim(sArg));
	const size_t len = trimmed.length();

	if (len == 4)
	{
		if (StringHelper::equalsIgnoreCase(trimmed, LOG4CXX_STR(""INFO""), LOG4CXX_STR(""info"")))
		{
			return getInfo();
		}

		if (StringHelper::equalsIgnoreCase(trimmed, LOG4CXX_STR(""WARN""), LOG4CXX_STR(""warn"")))
		{
			return getWarn();
		}
	}
	else
	{
		if (len == 5)
		{
			if (StringHelper::equalsIgnoreCase(trimmed, LOG4CXX_STR(""DEBUG""), LOG4CXX_STR(""debug"")))
			{
				return getDebug();
			}

			if (StringHelper::equalsIgnoreCase(trimmed, LOG4CXX_STR(""TRACE""), LOG4CXX_STR(""trace"")))
			{
				return getTrace();
			}

			if (StringHelper::equalsIgnoreCase(trimmed, LOG4CXX_STR(""ERROR""), LOG4CXX_STR(""error"")))
			{
				return getError();
			}

			if (StringHelper::equalsIgnoreCase(trimmed, LOG4CXX_STR(""FATAL""), LOG4CXX_STR(""fatal"")))
			{
				return getFatal();
			}
		}
		else
		{
			if (len == 3)
			{
				if (StringHelper::equalsIgnoreCase(trimmed, LOG4CXX_STR(""OFF""), LOG4CXX_S...",1,,216,3,,void
28689,BLOCK,-1,,"{
		if (StringHelper::equalsIgnoreCase(trimmed, LOG4CXX_STR(""INFO""), LOG4CXX_STR(""info"")))
		{
			return getInfo();
		}

		if (StringHelper::equalsIgnoreCase(trimmed, LOG4CXX_STR(""WARN""), LOG4CXX_STR(""warn"")))
		{
			return getWarn();
		}
	}",2,,221,2,,void
28700,BLOCK,-1,,"{
			return getInfo();
		}",3,,223,2,,void
28713,BLOCK,-1,,"{
			return getWarn();
		}",3,,228,2,,void
28717,BLOCK,-1,,"{
		if (len == 5)
		{
			if (StringHelper::equalsIgnoreCase(trimmed, LOG4CXX_STR(""DEBUG""), LOG4CXX_STR(""debug"")))
			{
				return getDebug();
			}

			if (StringHelper::equalsIgnoreCase(trimmed, LOG4CXX_STR(""TRACE""), LOG4CXX_STR(""trace"")))
			{
				return getTrace();
			}

			if (StringHelper::equalsIgnoreCase(trimmed, LOG4CXX_STR(""ERROR""), LOG4CXX_STR(""error"")))
			{
				return getError();
			}

			if (StringHelper::equalsIgnoreCase(trimmed, LOG4CXX_STR(""FATAL""), LOG4CXX_STR(""fatal"")))
			{
				return getFatal();
			}
		}
		else
		{
			if (len == 3)
			{
				if (StringHelper::equalsIgnoreCase(trimmed, LOG4CXX_STR(""OFF""), LOG4CXX_STR(""off"")))
				{
					return getOff();
				}

				if (StringHelper::equalsIgnoreCase(trimmed, LOG4CXX_STR(""ALL""), LOG4CXX_STR(""all"")))
				{
					return getAll();
				}
			}
		}
	}",2,,233,1,,void
28722,BLOCK,-1,,"{
			if (StringHelper::equalsIgnoreCase(trimmed, LOG4CXX_STR(""DEBUG""), LOG4CXX_STR(""debug"")))
			{
				return getDebug();
			}

			if (StringHelper::equalsIgnoreCase(trimmed, LOG4CXX_STR(""TRACE""), LOG4CXX_STR(""trace"")))
			{
				return getTrace();
			}

			if (StringHelper::equalsIgnoreCase(trimmed, LOG4CXX_STR(""ERROR""), LOG4CXX_STR(""error"")))
			{
				return getError();
			}

			if (StringHelper::equalsIgnoreCase(trimmed, LOG4CXX_STR(""FATAL""), LOG4CXX_STR(""fatal"")))
			{
				return getFatal();
			}
		}",3,,235,2,,void
28733,BLOCK,-1,,"{
				return getDebug();
			}",4,,237,2,,void
28746,BLOCK,-1,,"{
				return getTrace();
			}",4,,242,2,,void
28759,BLOCK,-1,,"{
				return getError();
			}",4,,247,2,,void
28772,BLOCK,-1,,"{
				return getFatal();
			}",4,,252,2,,void
28776,BLOCK,-1,,"{
			if (len == 3)
			{
				if (StringHelper::equalsIgnoreCase(trimmed, LOG4CXX_STR(""OFF""), LOG4CXX_STR(""off"")))
				{
					return getOff();
				}

				if (StringHelper::equalsIgnoreCase(trimmed, LOG4CXX_STR(""ALL""), LOG4CXX_STR(""all"")))
				{
					return getAll();
				}
			}
		}",3,,257,1,,void
28781,BLOCK,-1,,"{
				if (StringHelper::equalsIgnoreCase(trimmed, LOG4CXX_STR(""OFF""), LOG4CXX_STR(""off"")))
				{
					return getOff();
				}

				if (StringHelper::equalsIgnoreCase(trimmed, LOG4CXX_STR(""ALL""), LOG4CXX_STR(""all"")))
				{
					return getAll();
				}
			}",4,,259,2,,void
28792,BLOCK,-1,,"{
					return getOff();
				}",5,,261,2,,void
28805,BLOCK,-1,,"{
					return getAll();
				}",5,,266,2,,void
28814,BLOCK,-1,,"{
	return level1 && this->level == level1->level;
}",1,,278,2,,void
28829,BLOCK,-1,,"{
	return level1 && this->level >= level1->level;
}",1,,283,2,,void
28860,BLOCK,-1,,<empty>,1,,1,1,,ANY
28867,BLOCK,-1,,"{
	priv->acceptOnMatch = true;
}",1,,43,1,,void
28870,BLOCK,1,,<empty>,,,,1,,void
28883,BLOCK,-1,,<empty>,39,,47,1,,void
28889,BLOCK,-1,,"{


	if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""LEVELTOMATCH""), LOG4CXX_STR(""leveltomatch"")))
	{
		setLevelToMatch(value);
	}
	else if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""ACCEPTONMATCH""), LOG4CXX_STR(""acceptonmatch"")))
	{
		priv->acceptOnMatch = OptionConverter::toBoolean(value, priv->acceptOnMatch);
	}
}",1,,51,3,,void
28900,BLOCK,-1,,"{
		setLevelToMatch(value);
	}",2,,56,2,,void
28904,BLOCK,-1,,<empty>,7,,59,1,,void
28915,BLOCK,-1,,"{
		priv->acceptOnMatch = OptionConverter::toBoolean(value, priv->acceptOnMatch);
	}",2,,61,2,,void
28918,BLOCK,1,,<empty>,,,,1,,void
28933,BLOCK,1,,<empty>,,,,1,,void
28946,BLOCK,-1,,"{
	priv->levelToMatch = OptionConverter::toLevel(levelToMatch1, priv->levelToMatch);
}",1,,67,2,,void
28949,BLOCK,1,,<empty>,,,,1,,void
28964,BLOCK,1,,<empty>,,,,1,,void
28976,BLOCK,-1,,"{
	return priv->levelToMatch->toString();
}",1,,72,1,,void
28979,BLOCK,1,,<empty>,,,,1,,void
28995,BLOCK,-1,,"{
	if (priv->levelToMatch != 0 && priv->levelToMatch->equals(event->getLevel()))
	{
		if (priv->acceptOnMatch)
		{
			return Filter::ACCEPT;
		}
		else
		{
			return Filter::DENY;
		}
	}
	else
	{
		return Filter::NEUTRAL;
	}
}",1,,78,2,,void
29000,BLOCK,1,,<empty>,,,,1,,void
29011,BLOCK,1,,<empty>,,,,1,,void
29027,BLOCK,-1,,"{
		if (priv->acceptOnMatch)
		{
			return Filter::ACCEPT;
		}
		else
		{
			return Filter::DENY;
		}
	}",2,,80,2,,void
29030,BLOCK,1,,<empty>,,,,1,,void
29039,BLOCK,-1,,"{
			return Filter::ACCEPT;
		}",3,,82,2,,void
29045,BLOCK,-1,,"{
			return Filter::DENY;
		}",3,,86,1,,void
29051,BLOCK,-1,,"{
		return Filter::NEUTRAL;
	}",2,,91,1,,void
29060,BLOCK,-1,,"{
	priv->acceptOnMatch = acceptOnMatch1;
}",1,,97,2,,void
29063,BLOCK,1,,<empty>,,,,1,,void
29076,BLOCK,-1,,"{
	return priv->acceptOnMatch;
}",1,,102,1,,void
29079,BLOCK,1,,<empty>,,,,1,,void
29104,BLOCK,-1,,<empty>,1,,1,1,,ANY
29108,BLOCK,-1,,"{
}",1,,35,1,,void
29113,BLOCK,-1,,"{
	static WideLife<PatternConverterPtr> def = std::make_shared<LevelPatternConverter>();
	return def;
}",1,,40,2,,void
29129,BLOCK,-1,,"{
	toAppendTo.append(event->getLevel()->toString());
}",1,,49,4,,void
29145,BLOCK,-1,,"{
	LoggingEventPtr e = LOG4CXX_NS::cast<LoggingEvent>(obj);

	if (e != NULL)
	{
		int lint = e->getLevel()->toInt();

		switch (lint)
		{
			case Level::TRACE_INT:
				return LOG4CXX_STR(""level trace"");

			case Level::DEBUG_INT:
				return LOG4CXX_STR(""level debug"");

			case Level::INFO_INT:
				return LOG4CXX_STR(""level info"");

			case Level::WARN_INT:
				return LOG4CXX_STR(""level warn"");

			case Level::ERROR_INT:
				return LOG4CXX_STR(""level error"");

			case Level::FATAL_INT:
				return LOG4CXX_STR(""level fatal"");

			default:
				return LogString(LOG4CXX_STR(""level "")) + e->getLevel()->toString();
		}
	}

	return LOG4CXX_STR(""level"");
}",1,,58,2,,void
29160,BLOCK,-1,,"{
		int lint = e->getLevel()->toInt();

		switch (lint)
		{
			case Level::TRACE_INT:
				return LOG4CXX_STR(""level trace"");

			case Level::DEBUG_INT:
				return LOG4CXX_STR(""level debug"");

			case Level::INFO_INT:
				return LOG4CXX_STR(""level info"");

			case Level::WARN_INT:
				return LOG4CXX_STR(""level warn"");

			case Level::ERROR_INT:
				return LOG4CXX_STR(""level error"");

			case Level::FATAL_INT:
				return LOG4CXX_STR(""level fatal"");

			default:
				return LogString(LOG4CXX_STR(""level "")) + e->getLevel()->toString();
		}
	}",2,,62,2,,void
29173,BLOCK,-1,,"{
			case Level::TRACE_INT:
				return LOG4CXX_STR(""level trace"");

			case Level::DEBUG_INT:
				return LOG4CXX_STR(""level debug"");

			case Level::INFO_INT:
				return LOG4CXX_STR(""level info"");

			case Level::WARN_INT:
				return LOG4CXX_STR(""level warn"");

			case Level::ERROR_INT:
				return LOG4CXX_STR(""level error"");

			case Level::FATAL_INT:
				return LOG4CXX_STR(""level fatal"");

			default:
				return LogString(LOG4CXX_STR(""level "")) + e->getLevel()->toString();
		}",3,,66,2,,void
29252,BLOCK,-1,,<empty>,1,,1,1,,ANY
29255,BLOCK,-1,,<empty>,105,,35,1,,void
29264,BLOCK,-1,,"{
}",1,,51,1,,void
29268,BLOCK,-1,,<empty>,39,,54,1,,void
29274,BLOCK,-1,,"{

	if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""LEVELMIN""), LOG4CXX_STR(""levelmin"")))
	{
		priv->levelMin = OptionConverter::toLevel(value, priv->levelMin);
	}
	else if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""LEVELMAX""), LOG4CXX_STR(""levelmax"")))
	{
		priv->levelMax = OptionConverter::toLevel(value, priv->levelMax);
	}
	else if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""ACCEPTONMATCH""), LOG4CXX_STR(""acceptonmatch"")))
	{
		priv->acceptOnMatch = OptionConverter::toBoolean(value, priv->acceptOnMatch);
	}
}",1,,58,3,,void
29285,BLOCK,-1,,"{
		priv->levelMin = OptionConverter::toLevel(value, priv->levelMin);
	}",2,,62,2,,void
29288,BLOCK,1,,<empty>,,,,1,,void
29303,BLOCK,1,,<empty>,,,,1,,void
29313,BLOCK,-1,,<empty>,7,,65,1,,void
29324,BLOCK,-1,,"{
		priv->levelMax = OptionConverter::toLevel(value, priv->levelMax);
	}",2,,67,2,,void
29327,BLOCK,1,,<empty>,,,,1,,void
29342,BLOCK,1,,<empty>,,,,1,,void
29352,BLOCK,-1,,<empty>,7,,70,1,,void
29363,BLOCK,-1,,"{
		priv->acceptOnMatch = OptionConverter::toBoolean(value, priv->acceptOnMatch);
	}",2,,72,2,,void
29366,BLOCK,1,,<empty>,,,,1,,void
29381,BLOCK,1,,<empty>,,,,1,,void
29394,BLOCK,-1,,"{
	if (priv->levelMin != 0 && !event->getLevel()->isGreaterOrEqual(priv->levelMin))
	{
		// level of event is less than minimum
		return Filter::DENY;
	}

	if (priv->levelMax != 0 && event->getLevel()->toInt() > priv->levelMax->toInt())
	{
		// level of event is greater than maximum
		// Alas, there is no Level.isGreater method. and using
		// a combo of isGreaterOrEqual && !Equal seems worse than
		// checking the int values of the level objects..
		return Filter::DENY;
	}

	if (priv->acceptOnMatch)
	{
		// this filter set up to bypass later filters and always return
		// accept if level in range
		return Filter::ACCEPT;
	}
	else
	{
		// event is ok for this filter; allow later filters to have a look..
		return Filter::NEUTRAL;
	}
}",1,,79,2,,void
29399,BLOCK,1,,<empty>,,,,1,,void
29418,BLOCK,1,,<empty>,,,,1,,void
29427,BLOCK,-1,,"{
		// level of event is less than minimum
		return Filter::DENY;
	}",2,,81,2,,void
29436,BLOCK,1,,<empty>,,,,1,,void
29455,BLOCK,1,,<empty>,,,,1,,void
29467,BLOCK,-1,,"{
		// level of event is greater than maximum
		// Alas, there is no Level.isGreater method. and using
		// a combo of isGreaterOrEqual && !Equal seems worse than
		// checking the int values of the level objects..
		return Filter::DENY;
	}",2,,87,2,,void
29474,BLOCK,1,,<empty>,,,,1,,void
29483,BLOCK,-1,,"{
		// this filter set up to bypass later filters and always return
		// accept if level in range
		return Filter::ACCEPT;
	}",2,,96,2,,void
29489,BLOCK,-1,,"{
		// event is ok for this filter; allow later filters to have a look..
		return Filter::NEUTRAL;
	}",2,,102,1,,void
29498,BLOCK,-1,,"{
	priv->levelMin = levelMin1;
}",1,,109,2,,void
29501,BLOCK,1,,<empty>,,,,1,,void
29514,BLOCK,-1,,"{
	return priv->levelMin;
}",1,,114,1,,void
29517,BLOCK,1,,<empty>,,,,1,,void
29530,BLOCK,-1,,"{
	priv->levelMax = levelMax1;
}",1,,119,2,,void
29533,BLOCK,1,,<empty>,,,,1,,void
29546,BLOCK,-1,,"{
	return priv->levelMax;
}",1,,124,1,,void
29549,BLOCK,1,,<empty>,,,,1,,void
29562,BLOCK,-1,,"{
	priv->acceptOnMatch = acceptOnMatch1;
}",1,,129,2,,void
29565,BLOCK,1,,<empty>,,,,1,,void
29578,BLOCK,-1,,"{
	return priv->acceptOnMatch;
}",1,,134,1,,void
29581,BLOCK,1,,<empty>,,,,1,,void
29606,BLOCK,-1,,<empty>,1,,1,1,,ANY
29610,BLOCK,-1,,"{
}",1,,34,1,,void
29615,BLOCK,-1,,"{
	static WideLife<PatternConverterPtr> instance = std::make_shared<LineLocationPatternConverter>();
	return instance;
}",1,,39,2,,void
29631,BLOCK,-1,,"{
	StringHelper::toString(
		event->getLocationInformation().getLineNumber(),
		p, toAppendTo);
}",1,,48,4,,void
29659,BLOCK,-1,,<empty>,1,,1,1,,ANY
29663,BLOCK,-1,,"{
}",1,,33,1,,void
29668,BLOCK,-1,,"{
	static WideLife<PatternConverterPtr> instance = std::make_shared<LineSeparatorPatternConverter>();
	return instance;
}",1,,38,2,,void
29684,BLOCK,-1,,"{
	toAppendTo.append(LOG4CXX_EOL);
}",1,,47,4,,void
29696,BLOCK,-1,,"{
	toAppendTo.append(LOG4CXX_EOL);
}",1,,55,4,,void
29718,BLOCK,-1,,<empty>,1,,1,1,,ANY
29724,BLOCK,-1,,<empty>,21,,35,4,,void
29732,BLOCK,-1,,"{
}",1,,48,2,,void
29737,BLOCK,-1,,"{
	if (literal.length() == 1 && literal[0] == 0x20 /* ' ' */)
	{
		static WideLife<PatternConverterPtr> blank = std::make_shared<LiteralPatternConverter>(literal);
		return blank;
	}

	return std::make_shared<LiteralPatternConverter>(literal);
}",1,,53,2,,void
29751,BLOCK,-1,,"{
		static WideLife<PatternConverterPtr> blank = std::make_shared<LiteralPatternConverter>(literal);
		return blank;
	}",2,,55,2,,void
29778,BLOCK,-1,,"{
	toAppendTo.append(priv->literal);
}",1,,67,4,,void
29784,BLOCK,1,,<empty>,,,,1,,void
29799,BLOCK,-1,,"{
	toAppendTo.append(priv->literal);
}",1,,75,4,,void
29805,BLOCK,1,,<empty>,,,,1,,void
29854,BLOCK,-1,,<empty>,1,,1,1,,ANY
29887,BLOCK,-1,,"{
	return Class::forName(clazz);
}",1,,58,2,,void
29898,BLOCK,-1,,"{

	try
	{
		return std::make_shared<FileInputStream>(name);
	}
	catch (const IOException&)
	{
	}

	return 0;
}",1,,64,2,,void
29900,BLOCK,-1,,"{
		return std::make_shared<FileInputStream>(name);
	}",2,,67,1,,void
29909,BLOCK,2,,"{
	}",2,,71,2,,void
29920,BLOCK,-1,,<empty>,1,,1,1,,ANY
29924,BLOCK,-1,,"{
	}",2,,27,2,,void
29930,BLOCK,-1,,"{
	}",2,,32,3,,void
29937,BLOCK,-1,,"{
	}",2,,38,4,,void
29945,BLOCK,-1,,"{
}",1,,48,2,,void
29951,BLOCK,-1,,"{
}",1,,53,3,,void
29958,BLOCK,-1,,"{
}",1,,59,4,,void
29962,BLOCK,-1,,<empty>,19,,62,1,,void
29966,BLOCK,-1,,"{
	return m_priv->language;
}",1,,65,1,,void
29974,BLOCK,-1,,"{
	return m_priv->country;
}",1,,70,1,,void
29982,BLOCK,-1,,"{
	return m_priv->variant;
}",1,,75,1,,void
29999,BLOCK,-1,,<empty>,1,,1,1,,ANY
30009,BLOCK,-1,,"{
	static const WideLife<LocationInfo> unavailable;
	return unavailable;
}",1,,33,1,,void
30020,BLOCK,-1,,"{
}",1,,51,5,,void
30024,BLOCK,-1,,"{
}",1,,62,1,,void
30029,BLOCK,-1,,"{
}",1,,74,2,,void
30034,BLOCK,-1,,"{
	fileName = src.fileName;
	methodName = src.methodName;
	lineNumber = src.lineNumber;
	return * this;
}",1,,82,2,,void
30056,BLOCK,-1,,"{
	fileName = NA;
	methodName = NA_METHOD;
	lineNumber = -1;
}",1,,93,1,,void
30070,BLOCK,-1,,"{
	return fileName;
}",1,,105,1,,void
30076,BLOCK,-1,,"{
	return shortFileName;
}",51,,109,1,,void
30082,BLOCK,-1,,"{
	return lineNumber;
}",1,,118,1,,void
30088,BLOCK,-1,,"{
	std::string tmp(methodName);
	size_t parenPos = tmp.find('(');

	if (parenPos != std::string::npos)
	{
		tmp.erase(parenPos);
	}

	size_t colonPos = tmp.rfind(""::"");

	if (colonPos != std::string::npos)
	{
		tmp.erase(0, colonPos + 2);
	}
	else
	{
		size_t spacePos = tmp.find(' ');

		if (spacePos != std::string::npos)
		{
			tmp.erase(0, spacePos + 1);
		}
	}

	return tmp;
}",1,,124,1,,void
30108,BLOCK,-1,,"{
		tmp.erase(parenPos);
	}",2,,129,2,,void
30130,BLOCK,-1,,"{
		tmp.erase(0, colonPos + 2);
	}",2,,136,2,,void
30140,BLOCK,-1,,"{
		size_t spacePos = tmp.find(' ');

		if (spacePos != std::string::npos)
		{
			tmp.erase(0, spacePos + 1);
		}
	}",2,,140,1,,void
30157,BLOCK,-1,,"{
			tmp.erase(0, spacePos + 1);
		}",3,,144,2,,void
30171,BLOCK,-1,,"{
	std::string tmp(methodName);
	size_t parenPos = tmp.find('(');

	if (parenPos != std::string::npos)
	{
		tmp.erase(parenPos);
	}

	size_t colonPos = tmp.rfind(""::"");

	if (colonPos != std::string::npos)
	{
		tmp.erase(colonPos);
		size_t spacePos = tmp.find_last_of(' ');

		if (spacePos != std::string::npos)
		{
			tmp.erase(0, spacePos + 1);
		}

		return tmp;
	}

	tmp.erase(0, tmp.length() );
	return tmp;
}",1,,154,1,,void
30191,BLOCK,-1,,"{
		tmp.erase(parenPos);
	}",2,,159,2,,void
30213,BLOCK,-1,,"{
		tmp.erase(colonPos);
		size_t spacePos = tmp.find_last_of(' ');

		if (spacePos != std::string::npos)
		{
			tmp.erase(0, spacePos + 1);
		}

		return tmp;
	}",2,,166,2,,void
30235,BLOCK,-1,,"{
			tmp.erase(0, spacePos + 1);
		}",3,,171,2,,void
30279,BLOCK,-1,,<empty>,1,,1,1,,ANY
30282,BLOCK,-1,,<empty>,2,,40,1,,void
30292,BLOCK,-1,,"{
}",1,,52,1,,void
30296,BLOCK,-1,,<empty>,43,,55,1,,void
30302,BLOCK,-1,,"{
	LogLog::warn(option + LOG4CXX_STR("":"") + value);
	if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""ACCEPTONMATCH""), LOG4CXX_STR(""acceptonmatch"")))
	{
		priv->acceptOnMatch = OptionConverter::toBoolean(value, priv->acceptOnMatch);
	}
	else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""OPERATOR""), LOG4CXX_STR(""operator"")))
	{
		priv->mustMatchAll = StringHelper::equalsIgnoreCase(value, LOG4CXX_STR(""AND""), LOG4CXX_STR(""and"")) ? true : false;
	}
	else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""LINENUMBER""), LOG4CXX_STR(""linenumber"")))
	{
		priv->lineNumber = OptionConverter::toInt(value, -1);
	}
	else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""METHOD""), LOG4CXX_STR(""method"")))
	{
		LOG4CXX_ENCODE_CHAR(sName, value);
		priv->methodName = sName;
	}
}",1,,59,3,,void
30323,BLOCK,-1,,"{
		priv->acceptOnMatch = OptionConverter::toBoolean(value, priv->acceptOnMatch);
	}",2,,62,2,,void
30326,BLOCK,1,,<empty>,,,,1,,void
30341,BLOCK,1,,<empty>,,,,1,,void
30351,BLOCK,-1,,<empty>,7,,65,1,,void
30362,BLOCK,-1,,"{
		priv->mustMatchAll = StringHelper::equalsIgnoreCase(value, LOG4CXX_STR(""AND""), LOG4CXX_STR(""and"")) ? true : false;
	}",2,,66,2,,void
30365,BLOCK,1,,<empty>,,,,1,,void
30387,BLOCK,-1,,<empty>,7,,69,1,,void
30398,BLOCK,-1,,"{
		priv->lineNumber = OptionConverter::toInt(value, -1);
	}",2,,70,2,,void
30401,BLOCK,1,,<empty>,,,,1,,void
30418,BLOCK,-1,,<empty>,7,,73,1,,void
30429,BLOCK,-1,,"{
		LOG4CXX_ENCODE_CHAR(sName, value);
		priv->methodName = sName;
	}",2,,74,2,,void
30435,BLOCK,1,,<empty>,,,,1,,void
30449,BLOCK,-1,,"{
	if (priv->lineNumber == -1 &&
			priv->methodName.empty())
	{
		return Filter::NEUTRAL;
	}

	if (event->getLocationInformation().getLineNumber() == -1 ||
			event->getLocationInformation().getMethodName().compare(LocationInfo::NA_METHOD) == 0){
		return Filter::NEUTRAL;
	}

	bool matched = false;
	bool matchLineNumber = priv->lineNumber == event->getLocationInformation().getLineNumber();
	bool matchMethodName = priv->methodName.compare(event->getLocationInformation().getMethodName()) == 0;

	if(priv->mustMatchAll){
		matched = matchLineNumber && matchMethodName;
	}else{
		matched = matchLineNumber || matchMethodName;
	}

	if (priv->acceptOnMatch)
	{
		return matched ? Filter::ACCEPT : Filter::NEUTRAL;
	}
	else
	{
		return matched ? Filter::DENY : Filter::NEUTRAL;
	}
}",1,,82,2,,void
30454,BLOCK,1,,<empty>,,,,1,,void
30466,BLOCK,1,,<empty>,,,,1,,void
30478,BLOCK,-1,,"{
		return Filter::NEUTRAL;
	}",2,,85,2,,void
30510,BLOCK,-1,,"{
		return Filter::NEUTRAL;
	}",90,,90,2,,void
30524,BLOCK,1,,<empty>,,,,1,,void
30545,BLOCK,1,,<empty>,,,,1,,void
30567,BLOCK,1,,<empty>,,,,1,,void
30576,BLOCK,-1,,"{
		matched = matchLineNumber && matchMethodName;
	}",24,,98,2,,void
30583,BLOCK,-1,,"{
		matched = matchLineNumber || matchMethodName;
	}",7,,100,1,,void
30591,BLOCK,1,,<empty>,,,,1,,void
30600,BLOCK,-1,,"{
		return matched ? Filter::ACCEPT : Filter::NEUTRAL;
	}",2,,105,2,,void
30611,BLOCK,-1,,"{
		return matched ? Filter::DENY : Filter::NEUTRAL;
	}",2,,109,1,,void
30625,BLOCK,-1,,"{
	priv->acceptOnMatch = acceptOnMatch1;
}",1,,115,2,,void
30628,BLOCK,1,,<empty>,,,,1,,void
30641,BLOCK,-1,,"{
	return priv->acceptOnMatch;
}",1,,120,1,,void
30644,BLOCK,1,,<empty>,,,,1,,void
30656,BLOCK,-1,,"{
	return priv->mustMatchAll;
}",1,,125,1,,void
30659,BLOCK,1,,<empty>,,,,1,,void
30672,BLOCK,-1,,"{
	priv->mustMatchAll = mustMatchAll1;
}",1,,130,2,,void
30675,BLOCK,1,,<empty>,,,,1,,void
30689,BLOCK,-1,,"{
	priv->lineNumber = lineNum;
}",52,,134,2,,void
30692,BLOCK,1,,<empty>,,,,1,,void
30706,BLOCK,-1,,"{
	LOG4CXX_ENCODE_CHAR(sName, methodName);
	priv->methodName = sName;
}",68,,138,2,,void
30712,BLOCK,1,,<empty>,,,,1,,void
30758,BLOCK,-1,,<empty>,1,,1,1,,ANY
30763,BLOCK,-1,,<empty>,18,,47,3,,void
30778,BLOCK,-1,,"{
}",1,,92,3,,void
30782,BLOCK,-1,,"{
}",1,,96,1,,void
30787,BLOCK,-1,,"{
	m_priv->aai.addAppender(newAppender);
	if (auto rep = getHierarchy())
	{
		rep->fireAddAppenderEvent(this, newAppender.get());
	}
}",1,,100,2,,void
30796,BLOCK,-1,,<empty>,6,,102,1,,void
30801,BLOCK,-1,,"{
		rep->fireAddAppenderEvent(this, newAppender.get());
	}",2,,103,2,,void
30816,BLOCK,-1,,"{
	m_priv->additive = additive1;

	m_priv->aai.removeAllAppenders();

	for ( std::vector<AppenderPtr>::const_iterator it = appenders.cbegin();
		it != appenders.cend();
		it++ )
	{
		m_priv->aai.addAppender( *it );

		if (auto rep = getHierarchy())
		{
			rep->fireAddAppenderEvent(this, it->get());
		}
	}
}",1,,109,3,,void
30829,BLOCK,-1,,<empty>,2,,114,1,,void
30845,BLOCK,4,,"{
		m_priv->aai.addAppender( *it );

		if (auto rep = getHierarchy())
		{
			rep->fireAddAppenderEvent(this, it->get());
		}
	}",2,,117,4,,void
30855,BLOCK,-1,,<empty>,7,,120,1,,void
30860,BLOCK,-1,,"{
			rep->fireAddAppenderEvent(this, it->get());
		}",3,,121,2,,void
30875,BLOCK,-1,,"{
	int writes = 0;

	for (const Logger* logger = this;
		logger != 0;
		logger = logger->m_priv->parent.get())
	{
		writes += logger->m_priv->aai.appendLoopOnAppenders(event, p);

		if (!logger->m_priv->additive)
		{
			break;
		}
	}

	auto rep = getHierarchy();

	if (writes == 0 && rep)
	{
		rep->emitNoAppenderWarning(const_cast<Logger*>(this));
	}
}",1,,128,3,,void
30881,BLOCK,-1,,<empty>,2,,131,1,,void
30899,BLOCK,4,,"{
		writes += logger->m_priv->aai.appendLoopOnAppenders(event, p);

		if (!logger->m_priv->additive)
		{
			break;
		}
	}",2,,134,4,,void
30919,BLOCK,-1,,"{
			break;
		}",3,,138,2,,void
30931,BLOCK,-1,,"{
		rep->emitNoAppenderWarning(const_cast<Logger*>(this));
	}",2,,146,2,,void
30942,BLOCK,-1,,"{
	AppenderList appenders = getAllAppenders();

	for (AppenderList::iterator it = appenders.begin(); it != appenders.end(); ++it)
	{
		(*it)->close();
	}
}",1,,152,1,,void
30948,BLOCK,-1,,<empty>,2,,155,1,,void
30964,BLOCK,4,,"{
		(*it)->close();
	}",2,,156,4,,void
30976,BLOCK,-1,,"{
	if (!getHierarchy()) // Has removeHierarchy() been called?
		return;
#if LOG4CXX_LOGCHAR_IS_UTF8
	auto event = std::make_shared<LoggingEvent>(m_priv->name, level, location, std::move(message));
#else
	LOG4CXX_DECODE_CHAR(msg, message);
	auto event = std::make_shared<LoggingEvent>(m_priv->name, level, location, std::move(msg));
#endif
	Pool p;
	callAppenders(event, p);
}",1,,162,4,,void
30980,BLOCK,-1,,<empty>,3,,164,2,,void
31016,BLOCK,-1,,"{
	if (!getHierarchy()) // Has removeHierarchy() been called?
		return;
#if LOG4CXX_LOGCHAR_IS_UTF8
	auto event = std::make_shared<LoggingEvent>(m_priv->name, level, message, location);
#else
	LOG4CXX_DECODE_CHAR(msg, message);
	auto event = std::make_shared<LoggingEvent>(m_priv->name, level, location, std::move(msg));
#endif
	Pool p;
	callAppenders(event, p);
}",1,,177,4,,void
31020,BLOCK,-1,,<empty>,3,,179,2,,void
31055,BLOCK,-1,,"{
	forcedLog(level1, message, LocationInfo::getLocationUnavailable());
}",1,,191,3,,void
31069,BLOCK,-1,,"{
	if (!getHierarchy()) // Has removeHierarchy() been called?
		return;
	Pool p;
	auto event = std::make_shared<LoggingEvent>(m_priv->name, level, location, std::move(message));
	callAppenders(event, p);
}",1,,196,4,,void
31073,BLOCK,-1,,<empty>,3,,198,2,,void
31106,BLOCK,-1,,"{
	if (!getHierarchy()) // Has removeHierarchy() been called?
		return;
	Pool p;
	auto event = std::make_shared<LoggingEvent>(m_priv->name, level1, message, location);
	callAppenders(event, p);
}",1,,206,4,,void
31110,BLOCK,-1,,<empty>,3,,208,2,,void
31136,BLOCK,-1,,"{
	return m_priv->additive;
}",1,,216,1,,void
31144,BLOCK,-1,,"{
	return m_priv->aai.getAllAppenders();
}",1,,221,1,,void
31156,BLOCK,-1,,"{
	return m_priv->aai.getAppender(name1);
}",1,,226,2,,void
31168,BLOCK,-1,,"{
	for (const Logger* l = this; l != 0; l = l->m_priv->parent.get())
	{
		if (l->m_priv->level != 0)
		{
			return l->m_priv->level;
		}
	}

	throw NullPointerException(LOG4CXX_STR(""No level specified for logger or ancestors.""));
#if LOG4CXX_RETURN_AFTER_THROW
	return m_priv->level;
#endif
}",1,,231,1,,void
31170,BLOCK,-1,,<empty>,2,,232,1,,void
31188,BLOCK,4,,"{
		if (l->m_priv->level != 0)
		{
			return l->m_priv->level;
		}
	}",2,,233,4,,void
31197,BLOCK,-1,,"{
			return l->m_priv->level;
		}",3,,235,2,,void
31211,BLOCK,-1,,"{
	return m_priv->repositoryRaw;
}",1,,247,1,,void
31219,BLOCK,-1,,"{
	return m_priv->repositoryRaw;
}",1,,252,1,,void
31227,BLOCK,-1,,"{
	for (const Logger* l = this; l != 0; l = l->m_priv->parent.get())
	{
		if (l->m_priv->resourceBundle != 0)
		{
			return l->m_priv->resourceBundle;
		}
	}

	// It might be the case that there is no resource bundle
	return 0;
}",1,,257,1,,void
31229,BLOCK,-1,,<empty>,2,,258,1,,void
31247,BLOCK,4,,"{
		if (l->m_priv->resourceBundle != 0)
		{
			return l->m_priv->resourceBundle;
		}
	}",2,,259,4,,void
31256,BLOCK,-1,,"{
			return l->m_priv->resourceBundle;
		}",3,,261,2,,void
31269,BLOCK,-1,,"{
	ResourceBundlePtr rb = getResourceBundle();

	// This is one of the rare cases where we can use logging in order
	// to report errors from within log4j.
	if (rb == 0)
	{
		return LogString();
	}
	else
	{
		try
		{
			return rb->getString(key);
		}
		catch (MissingResourceException&)
		{
			logLS(Level::getError(), LOG4CXX_STR(""No resource is associated with key \"""") +
				key + LOG4CXX_STR(""\"".""), LocationInfo::getLocationUnavailable());

			return LogString();
		}
	}
}",1,,272,2,,void
31278,BLOCK,-1,,"{
		return LogString();
	}",2,,278,2,,void
31282,BLOCK,-1,,"{
		try
		{
			return rb->getString(key);
		}
		catch (MissingResourceException&)
		{
			logLS(Level::getError(), LOG4CXX_STR(""No resource is associated with key \"""") +
				key + LOG4CXX_STR(""\"".""), LocationInfo::getLocationUnavailable());

			return LogString();
		}
	}",2,,282,1,,void
31284,BLOCK,-1,,"{
			return rb->getString(key);
		}",3,,284,1,,void
31291,BLOCK,2,,"{
			logLS(Level::getError(), LOG4CXX_STR(""No resource is associated with key \"""") +
				key + LOG4CXX_STR(""\"".""), LocationInfo::getLocationUnavailable());

			return LogString();
		}",3,,288,2,,void
31313,BLOCK,-1,,"{
	return m_priv->parent;
}",1,,299,1,,void
31321,BLOCK,-1,,"{
	return m_priv->level;
}",1,,304,1,,void
31330,BLOCK,-1,,"{
	return m_priv->aai.isAttached(appender);
}",1,,309,2,,void
31342,BLOCK,-1,,"{
	auto rep = getHierarchy();

	if (!rep || rep->isDisabled(Level::TRACE_INT))
	{
		return false;
	}

	return getEffectiveLevel()->toInt() <= Level::TRACE_INT;
}",1,,314,1,,void
31358,BLOCK,-1,,"{
		return false;
	}",2,,318,2,,void
31373,BLOCK,-1,,"{
	auto rep = getHierarchy();

	if (!rep || rep->isDisabled(Level::DEBUG_INT))
	{
		return false;
	}

	return getEffectiveLevel()->toInt() <= Level::DEBUG_INT;
}",1,,326,1,,void
31389,BLOCK,-1,,"{
		return false;
	}",2,,330,2,,void
31405,BLOCK,-1,,"{
	auto rep = getHierarchy();

	if (!rep || rep->isDisabled(level1->toInt()))
	{
		return false;
	}

	return level1->isGreaterOrEqual(getEffectiveLevel());
}",1,,338,2,,void
31422,BLOCK,-1,,"{
		return false;
	}",2,,342,2,,void
31434,BLOCK,-1,,"{
	auto rep = getHierarchy();

	if (!rep || rep->isDisabled(Level::INFO_INT))
	{
		return false;
	}

	return getEffectiveLevel()->toInt() <= Level::INFO_INT;
}",1,,351,1,,void
31450,BLOCK,-1,,"{
		return false;
	}",2,,355,2,,void
31465,BLOCK,-1,,"{
	auto rep = getHierarchy();

	if (!rep || rep->isDisabled(Level::ERROR_INT))
	{
		return false;
	}

	return getEffectiveLevel()->toInt() <= Level::ERROR_INT;
}",1,,363,1,,void
31481,BLOCK,-1,,"{
		return false;
	}",2,,367,2,,void
31496,BLOCK,-1,,"{
	auto rep = getHierarchy();

	if (!rep || rep->isDisabled(Level::WARN_INT))
	{
		return false;
	}

	return getEffectiveLevel()->toInt() <= Level::WARN_INT;
}",1,,375,1,,void
31512,BLOCK,-1,,"{
		return false;
	}",2,,379,2,,void
31527,BLOCK,-1,,"{
	auto rep = getHierarchy();

	if (!rep || rep->isDisabled(Level::FATAL_INT))
	{
		return false;
	}

	return getEffectiveLevel()->toInt() <= Level::FATAL_INT;
}",1,,387,1,,void
31543,BLOCK,-1,,"{
		return false;
	}",2,,391,2,,void
31562,BLOCK,-1,,"{
	auto rep = getHierarchy();

	if (!rep || rep->isDisabled(level1->toInt()))
	{
		return;
	}

	if (level1->isGreaterOrEqual(getEffectiveLevel()))
	{
		LogString pattern = getResourceBundleString(key);
		LogString msg;

		if (pattern.empty())
		{
			msg = key;
		}
		else
		{
			msg = StringHelper::format(pattern, params);
		}

		addEventLS(level1, std::move(msg), location);
	}
}",1,,427,5,,void
31579,BLOCK,-1,,"{
		return;
	}",2,,431,2,,void
31587,BLOCK,-1,,"{
		LogString pattern = getResourceBundleString(key);
		LogString msg;

		if (pattern.empty())
		{
			msg = key;
		}
		else
		{
			msg = StringHelper::format(pattern, params);
		}

		addEventLS(level1, std::move(msg), location);
	}",2,,436,2,,void
31599,BLOCK,-1,,"{
			msg = key;
		}",3,,441,2,,void
31604,BLOCK,-1,,"{
			msg = StringHelper::format(pattern, params);
		}",3,,445,1,,void
31627,BLOCK,-1,,"{
	LOG4CXX_DECODE_CHAR(lkey, key);

	std::vector<LogString> values(0);
	l7dlog(level1, lkey, location, values);
}",1,,455,4,,void
31651,BLOCK,-1,,"{
	LOG4CXX_DECODE_CHAR(lkey, key);
	LOG4CXX_DECODE_CHAR(lval1, val1);

	std::vector<LogString> values(1);
	values[0] = lval1;
	l7dlog(level1, lkey, location, values);
}",1,,464,5,,void
31684,BLOCK,-1,,"{
	LOG4CXX_DECODE_CHAR(lkey, key);
	LOG4CXX_DECODE_CHAR(lval1, val1);
	LOG4CXX_DECODE_CHAR(lval2, val2);

	std::vector<LogString> values(2);
	values[0] = lval1;
	values[1] = lval2;
	l7dlog(level1, lkey, location, values);
}",1,,476,6,,void
31726,BLOCK,-1,,"{
	LOG4CXX_DECODE_CHAR(lkey, key);
	LOG4CXX_DECODE_CHAR(lval1, val1);
	LOG4CXX_DECODE_CHAR(lval2, val2);
	LOG4CXX_DECODE_CHAR(lval3, val3);

	std::vector<LogString> values(3);
	values[0] = lval1;
	values[1] = lval2;
	values[2] = lval3;
	l7dlog(level1, lkey, location, values);
}",1,,490,7,,void
31770,BLOCK,-1,,"{
	AppenderList currentAppenders = m_priv->aai.getAllAppenders();
	m_priv->aai.removeAllAppenders();

	auto rep = getHierarchy();
	if(rep){
		for(AppenderPtr appender : currentAppenders){
			rep->fireRemoveAppenderEvent(this, appender.get());
		}
	}
}",1,,504,1,,void
31792,BLOCK,-1,,"{
		for(AppenderPtr appender : currentAppenders){
			rep->fireRemoveAppenderEvent(this, appender.get());
		}
	}",9,,509,2,,void
31796,BLOCK,-1,,"{
			rep->fireRemoveAppenderEvent(this, appender.get());
		}",47,,510,3,,void
31810,BLOCK,-1,,"{
	m_priv->aai.removeAppender(appender);
	if (auto rep = getHierarchy())
	{
		rep->fireRemoveAppenderEvent(this, appender.get());
	}
}",1,,517,2,,void
31819,BLOCK,-1,,<empty>,6,,519,1,,void
31824,BLOCK,-1,,"{
		rep->fireRemoveAppenderEvent(this, appender.get());
	}",2,,520,2,,void
31838,BLOCK,-1,,"{
	AppenderPtr appender = m_priv->aai.getAppender(name1);
	if(appender){
		removeAppender(appender);
	}
}",1,,526,2,,void
31851,BLOCK,-1,,"{
		removeAppender(appender);
	}",14,,528,2,,void
31857,BLOCK,-1,,"{
	m_priv->repositoryRaw = 0;
}",1,,534,1,,void
31867,BLOCK,-1,,"{
	m_priv->additive = additive1;
}",1,,539,2,,void
31877,BLOCK,-1,,"{
	m_priv->repositoryRaw = repository1;
}",1,,544,2,,void
31887,BLOCK,-1,,"{
	m_priv->parent = parentLogger;
	updateThreshold();
}",1,,549,2,,void
31898,BLOCK,-1,,"{
	if (m_priv->level != level1)
	{
		m_priv->level = level1;
		updateThreshold();
		if (auto rep = dynamic_cast<Hierarchy*>(getHierarchy()))
			rep->updateChildren(this);
	}
}",1,,555,2,,void
31905,BLOCK,-1,,"{
		m_priv->level = level1;
		updateThreshold();
		if (auto rep = dynamic_cast<Hierarchy*>(getHierarchy()))
			rep->updateChildren(this);
	}",2,,557,2,,void
31913,BLOCK,-1,,<empty>,7,,560,1,,void
31920,BLOCK,-1,,<empty>,4,,561,2,,void
31929,BLOCK,-1,,"{
	m_threshold = getEffectiveLevel()->toInt();
}",1,,566,1,,void
31939,BLOCK,-1,,"{
	return m_priv->name;
}",1,,571,1,,void
31948,BLOCK,-1,,"{
	return LogManager::getLogger(name);
}",1,,576,2,,void
31959,BLOCK,-1,,"{
	return LogManager::getLogger(name);
}",1,,582,2,,void
31970,BLOCK,-1,,"{
	m_priv->resourceBundle = bundle;
}",1,,587,2,,void
31979,BLOCK,-1,,"{
	return LogManager::getRootLogger();
}",1,,592,1,,void
31990,BLOCK,-1,,"{
	return LogManager::getLoggerLS(name, factory);
}",1,,598,3,,void
32002,BLOCK,-1,,"{
	Transcoder::encode(m_priv->name, rv);
}",1,,603,2,,void
32016,BLOCK,-1,,"{
	if (isTraceEnabled())
	{
		forcedLog(LOG4CXX_NS::Level::getTrace(), msg, location);
	}
}",1,,609,3,,void
32019,BLOCK,-1,,"{
		forcedLog(LOG4CXX_NS::Level::getTrace(), msg, location);
	}",2,,611,2,,void
32033,BLOCK,-1,,"{
	if (isTraceEnabled())
	{
		forcedLog(LOG4CXX_NS::Level::getTrace(), msg);
	}
}",1,,618,2,,void
32036,BLOCK,-1,,"{
		forcedLog(LOG4CXX_NS::Level::getTrace(), msg);
	}",2,,620,2,,void
32050,BLOCK,-1,,"{
	if (isDebugEnabled())
	{
		forcedLog(LOG4CXX_NS::Level::getDebug(), msg, location);
	}
}",1,,626,3,,void
32053,BLOCK,-1,,"{
		forcedLog(LOG4CXX_NS::Level::getDebug(), msg, location);
	}",2,,628,2,,void
32067,BLOCK,-1,,"{
	if (isDebugEnabled())
	{
		forcedLog(LOG4CXX_NS::Level::getDebug(), msg);
	}
}",1,,634,2,,void
32070,BLOCK,-1,,"{
		forcedLog(LOG4CXX_NS::Level::getDebug(), msg);
	}",2,,636,2,,void
32084,BLOCK,-1,,"{
	if (isErrorEnabled())
	{
		forcedLog(LOG4CXX_NS::Level::getError(), msg, location);
	}
}",1,,643,3,,void
32087,BLOCK,-1,,"{
		forcedLog(LOG4CXX_NS::Level::getError(), msg, location);
	}",2,,645,2,,void
32101,BLOCK,-1,,"{
	if (isErrorEnabled())
	{
		forcedLog(LOG4CXX_NS::Level::getError(), msg);
	}
}",1,,652,2,,void
32104,BLOCK,-1,,"{
		forcedLog(LOG4CXX_NS::Level::getError(), msg);
	}",2,,654,2,,void
32118,BLOCK,-1,,"{
	if (isFatalEnabled())
	{
		forcedLog(LOG4CXX_NS::Level::getFatal(), msg, location);
	}
}",1,,660,3,,void
32121,BLOCK,-1,,"{
		forcedLog(LOG4CXX_NS::Level::getFatal(), msg, location);
	}",2,,662,2,,void
32135,BLOCK,-1,,"{
	if (isFatalEnabled())
	{
		forcedLog(LOG4CXX_NS::Level::getFatal(), msg);
	}
}",1,,668,2,,void
32138,BLOCK,-1,,"{
		forcedLog(LOG4CXX_NS::Level::getFatal(), msg);
	}",2,,670,2,,void
32152,BLOCK,-1,,"{
	if (isInfoEnabled())
	{
		forcedLog(LOG4CXX_NS::Level::getInfo(), msg, location);
	}
}",1,,676,3,,void
32155,BLOCK,-1,,"{
		forcedLog(LOG4CXX_NS::Level::getInfo(), msg, location);
	}",2,,678,2,,void
32169,BLOCK,-1,,"{
	if (isInfoEnabled())
	{
		forcedLog(LOG4CXX_NS::Level::getInfo(), msg);
	}
}",1,,684,2,,void
32172,BLOCK,-1,,"{
		forcedLog(LOG4CXX_NS::Level::getInfo(), msg);
	}",2,,686,2,,void
32187,BLOCK,-1,,"{
	if (isEnabledFor(level1))
	{
		forcedLog(level1, message, location);
	}
}",1,,693,4,,void
32191,BLOCK,-1,,"{
		forcedLog(level1, message, location);
	}",2,,695,2,,void
32201,BLOCK,-1,,"{
	if (isEnabledFor(level1))
	{
		forcedLog(level1, message);
	}
}",1,,701,3,,void
32205,BLOCK,-1,,"{
		forcedLog(level1, message);
	}",2,,703,2,,void
32215,BLOCK,-1,,"{
	if (isEnabledFor(level1))
	{
		forcedLogLS(level1, message, location);
	}
}",1,,710,4,,void
32219,BLOCK,-1,,"{
		forcedLogLS(level1, message, location);
	}",2,,712,2,,void
32229,BLOCK,-1,,"{
	if (isWarnEnabled())
	{
		forcedLog(LOG4CXX_NS::Level::getWarn(), msg, location);
	}
}",1,,718,3,,void
32232,BLOCK,-1,,"{
		forcedLog(LOG4CXX_NS::Level::getWarn(), msg, location);
	}",2,,720,2,,void
32246,BLOCK,-1,,"{
	if (isWarnEnabled())
	{
		forcedLog(LOG4CXX_NS::Level::getWarn(), msg);
	}
}",1,,726,2,,void
32249,BLOCK,-1,,"{
		forcedLog(LOG4CXX_NS::Level::getWarn(), msg);
	}",2,,728,2,,void
32262,BLOCK,-1,,"{
	return LogManager::getLoggerLS(name);
}",1,,734,2,,void
32287,BLOCK,-1,,<empty>,1,,1,1,,ANY
32290,BLOCK,-1,,<empty>,38,,36,1,,void
32298,BLOCK,-1,,"{
}",1,,47,1,,void
32302,BLOCK,-1,,<empty>,41,,50,1,,void
32307,BLOCK,-1,,"{
	priv->loggerToMatch = value;
}",1,,53,2,,void
32310,BLOCK,1,,<empty>,,,,1,,void
32323,BLOCK,-1,,"{
	return priv->loggerToMatch;
}",1,,58,1,,void
32326,BLOCK,1,,<empty>,,,,1,,void
32340,BLOCK,-1,,"{

	if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""LOGGERTOMATCH""), LOG4CXX_STR(""loggertomatch"")))
	{
		setLoggerToMatch(value);
	}
	else if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""ACCEPTONMATCH""), LOG4CXX_STR(""acceptonmatch"")))
	{
		priv->acceptOnMatch = OptionConverter::toBoolean(value, priv->acceptOnMatch);
	}
}",1,,64,3,,void
32351,BLOCK,-1,,"{
		setLoggerToMatch(value);
	}",2,,68,2,,void
32355,BLOCK,-1,,<empty>,7,,71,1,,void
32366,BLOCK,-1,,"{
		priv->acceptOnMatch = OptionConverter::toBoolean(value, priv->acceptOnMatch);
	}",2,,73,2,,void
32369,BLOCK,1,,<empty>,,,,1,,void
32384,BLOCK,1,,<empty>,,,,1,,void
32397,BLOCK,-1,,"{
	bool matchOccured = priv->loggerToMatch == event->getLoggerName();

	if (matchOccured)
	{
		if (priv->acceptOnMatch)
		{
			return Filter::ACCEPT;
		}
		else
		{
			return Filter::DENY;
		}
	}
	else
	{
		return Filter::NEUTRAL;
	}
}",1,,80,2,,void
32403,BLOCK,1,,<empty>,,,,1,,void
32418,BLOCK,-1,,"{
		if (priv->acceptOnMatch)
		{
			return Filter::ACCEPT;
		}
		else
		{
			return Filter::DENY;
		}
	}",2,,84,2,,void
32421,BLOCK,1,,<empty>,,,,1,,void
32430,BLOCK,-1,,"{
			return Filter::ACCEPT;
		}",3,,86,2,,void
32436,BLOCK,-1,,"{
			return Filter::DENY;
		}",3,,90,1,,void
32442,BLOCK,-1,,"{
		return Filter::NEUTRAL;
	}",2,,95,1,,void
32451,BLOCK,-1,,"{
	priv->acceptOnMatch = acceptOnMatch1;
}",1,,101,2,,void
32454,BLOCK,1,,<empty>,,,,1,,void
32467,BLOCK,-1,,"{
	return priv->acceptOnMatch;
}",1,,106,1,,void
32470,BLOCK,1,,<empty>,,,,1,,void
32493,BLOCK,-1,,<empty>,1,,1,1,,ANY
32498,BLOCK,-1,,"{
}",1,,34,2,,void
32503,BLOCK,-1,,"{
	if (options.size() == 0)
	{
		static WideLife<PatternConverterPtr> def = std::make_shared<LoggerPatternConverter>(options);
		return def;
	}

	return std::make_shared<LoggerPatternConverter>(options);
}",1,,39,2,,void
32511,BLOCK,-1,,"{
		static WideLife<PatternConverterPtr> def = std::make_shared<LoggerPatternConverter>(options);
		return def;
	}",2,,41,2,,void
32538,BLOCK,-1,,"{
	int initialLength = (int)toAppendTo.length();
	toAppendTo.append(event->getLoggerName());
	abbreviate(initialLength, toAppendTo);
}",1,,53,4,,void
32564,BLOCK,-1,,{ return threadId == item.first; },38,,361,2,,void
32612,BLOCK,-1,,<empty>,1,,1,1,,ANY
32615,BLOCK,-1,,"{
	}",2,,57,1,,void
32623,BLOCK,-1,,"{
	}",2,,79,5,,void
32631,BLOCK,-1,,"{
	}",2,,98,5,,void
32635,BLOCK,-1,,"{
		delete ndc;
		delete mdcCopy;
		delete properties;
	}",2,,102,1,,void
32660,BLOCK,-1,,"{
	return LOG4CXX_NS::helpers::APRInitializer::initialize();
}",1,,175,1,,void
32673,BLOCK,-1,,"{
}",1,,181,1,,void
32681,BLOCK,-1,,"{
}",1,,191,5,,void
32689,BLOCK,-1,,"{
}",1,,198,5,,void
32693,BLOCK,-1,,"{
}",1,,202,1,,void
32697,BLOCK,-1,,"{
	return m_priv->threadUserName;
}",57,,205,1,,void
32706,BLOCK,-1,,"{
	if (m_priv->ndcLookupRequired)
	{
		m_priv->ndcLookupRequired = false;
		LogString val;

		if (NDC::get(val))
		{
			m_priv->ndc = new LogString(val);
		}
	}

	if (m_priv->ndc)
	{
		dest.append(*m_priv->ndc);
		return true;
	}

	return false;
}",1,,210,2,,void
32711,BLOCK,-1,,"{
		m_priv->ndcLookupRequired = false;
		LogString val;

		if (NDC::get(val))
		{
			m_priv->ndc = new LogString(val);
		}
	}",2,,212,2,,void
32724,BLOCK,-1,,"{
			m_priv->ndc = new LogString(val);
		}",3,,217,2,,void
32736,BLOCK,-1,,"{
		dest.append(*m_priv->ndc);
		return true;
	}",2,,223,2,,void
32754,BLOCK,-1,,"{
	// Note the mdcCopy is used if it exists. Otherwise we use the MDC
	// that is associated with the thread.
	if (m_priv->mdcCopy != 0 && !m_priv->mdcCopy->empty())
	{
		MDC::Map::const_iterator it = m_priv->mdcCopy->find(key);

		if (it != m_priv->mdcCopy->end())
		{
			if (!it->second.empty())
			{
				dest.append(it->second);
				return true;
			}
		}
	}

	return MDC::get(key, dest);

}",1,,232,3,,void
32769,BLOCK,-1,,"{
		MDC::Map::const_iterator it = m_priv->mdcCopy->find(key);

		if (it != m_priv->mdcCopy->end())
		{
			if (!it->second.empty())
			{
				dest.append(it->second);
				return true;
			}
		}
	}",2,,236,2,,void
32789,BLOCK,-1,,"{
			if (!it->second.empty())
			{
				dest.append(it->second);
				return true;
			}
		}",3,,240,2,,void
32798,BLOCK,-1,,"{
				dest.append(it->second);
				return true;
			}",4,,242,2,,void
32818,BLOCK,-1,,"{
	LoggingEvent::KeySet set;

	if (m_priv->mdcCopy != 0 && !m_priv->mdcCopy->empty())
	{
		MDC::Map::const_iterator it;

		for (it = m_priv->mdcCopy->begin(); it != m_priv->mdcCopy->end(); it++)
		{
			set.push_back(it->first);

		}
	}
	else
	{
		ThreadSpecificData* data = ThreadSpecificData::getCurrentData();

		if (data != 0)
		{
			MDC::Map& m = data->getMap();

			for (MDC::Map::const_iterator it = m.begin(); it != m.end(); it++)
			{
				set.push_back(it->first);
			}
		}
	}

	return set;
}",1,,254,1,,void
32834,BLOCK,-1,,"{
		MDC::Map::const_iterator it;

		for (it = m_priv->mdcCopy->begin(); it != m_priv->mdcCopy->end(); it++)
		{
			set.push_back(it->first);

		}
	}",2,,258,2,,void
32837,BLOCK,-1,,<empty>,3,,261,1,,void
32856,BLOCK,4,,"{
			set.push_back(it->first);

		}",3,,262,4,,void
32865,BLOCK,-1,,"{
		ThreadSpecificData* data = ThreadSpecificData::getCurrentData();

		if (data != 0)
		{
			MDC::Map& m = data->getMap();

			for (MDC::Map::const_iterator it = m.begin(); it != m.end(); it++)
			{
				set.push_back(it->first);
			}
		}
	}",2,,268,1,,void
32877,BLOCK,-1,,"{
			MDC::Map& m = data->getMap();

			for (MDC::Map::const_iterator it = m.begin(); it != m.end(); it++)
			{
				set.push_back(it->first);
			}
		}",3,,272,2,,void
32886,BLOCK,-1,,<empty>,4,,275,1,,void
32902,BLOCK,4,,"{
				set.push_back(it->first);
			}",4,,276,4,,void
32915,BLOCK,-1,,"{
	if (m_priv->mdcCopyLookupRequired)
	{
		m_priv->mdcCopyLookupRequired = false;
		// the clone call is required for asynchronous logging.
		ThreadSpecificData* data = ThreadSpecificData::getCurrentData();

		if (data != 0)
		{
			m_priv->mdcCopy = new MDC::Map(data->getMap());
		}
		else
		{
			m_priv->mdcCopy = new MDC::Map();
		}
	}
}",1,,286,1,,void
32920,BLOCK,-1,,"{
		m_priv->mdcCopyLookupRequired = false;
		// the clone call is required for asynchronous logging.
		ThreadSpecificData* data = ThreadSpecificData::getCurrentData();

		if (data != 0)
		{
			m_priv->mdcCopy = new MDC::Map(data->getMap());
		}
		else
		{
			m_priv->mdcCopy = new MDC::Map();
		}
	}",2,,288,2,,void
32937,BLOCK,-1,,"{
			m_priv->mdcCopy = new MDC::Map(data->getMap());
		}",3,,294,2,,void
32949,BLOCK,-1,,"{
			m_priv->mdcCopy = new MDC::Map();
		}",3,,298,1,,void
32961,BLOCK,-1,,"{
	if (m_priv->properties == 0)
	{
		return false;
	}

	std::map<LogString, LogString>::const_iterator  it = m_priv->properties->find(key);

	if (it != m_priv->properties->end())
	{
		dest.append(it->second);
		return true;
	}

	return false;
}",1,,305,3,,void
32968,BLOCK,-1,,"{
		return false;
	}",2,,307,2,,void
32990,BLOCK,-1,,"{
		dest.append(it->second);
		return true;
	}",2,,314,2,,void
33005,BLOCK,-1,,"{
	LoggingEvent::KeySet set;

	if (m_priv->properties != 0)
	{
		std::map<LogString, LogString>::const_iterator it;

		for (it = m_priv->properties->begin(); it != m_priv->properties->end(); it++)
		{
			set.push_back(it->first);
		}
	}

	return set;
}",1,,323,1,,void
33013,BLOCK,-1,,"{
		std::map<LogString, LogString>::const_iterator it;

		for (it = m_priv->properties->begin(); it != m_priv->properties->end(); it++)
		{
			set.push_back(it->first);
		}
	}",2,,327,2,,void
33016,BLOCK,-1,,<empty>,3,,330,1,,void
33035,BLOCK,4,,"{
			set.push_back(it->first);
		}",3,,331,4,,void
33048,BLOCK,-1,,"{
#if defined(_WIN32)
	using ThreadIdType = DWORD;
	ThreadIdType threadId = GetCurrentThreadId();
#elif LOG4CXX_HAS_PTHREAD_SELF
	using ThreadIdType = pthread_t;
	ThreadIdType threadId = pthread_self();
#else
	using ThreadIdType = int;
	ThreadIdType threadId = 0;
#endif

#if LOG4CXX_HAS_THREAD_LOCAL
	thread_local LogString thread_id_string;
#else
	using ListItem = std::pair<ThreadIdType, LogString>;
	static std::list<ListItem> thread_id_map;
	static std::mutex mutex;
	std::lock_guard<std::mutex> lock(mutex);
	auto pThreadId = std::find_if(thread_id_map.begin(), thread_id_map.end()
		, [threadId](const ListItem& item) { return threadId == item.first; });
	if (thread_id_map.end() == pThreadId)
		pThreadId = thread_id_map.insert(thread_id_map.begin(), ListItem(threadId, LogString()));
	LogString& thread_id_string = pThreadId->second;
#endif
	if ( !thread_id_string.empty() )
	{
		return thread_id_string;
	}

#if defined(_WIN32)
	char result[20];
	apr_snprintf(result, sizeof(result), LOG...",1,,341,1,,void
33089,BLOCK,-1,,<empty>,3,,363,2,,void
33115,BLOCK,-1,,"{
		return thread_id_string;
	}",2,,367,2,,void
33127,BLOCK,-1,,"{
#if LOG4CXX_HAS_THREAD_LOCAL
	thread_local LogString thread_name;
#else
	static WideLife<LogString> thread_name = LOG4CXX_STR(""(noname)"");
#endif
	if( !thread_name.empty() ){
		return thread_name;
	}

#if LOG4CXX_HAS_PTHREAD_GETNAME
	char result[16];
	pthread_t current_thread = pthread_self();
	if (pthread_getname_np(current_thread, result, sizeof(result)) < 0 || 0 == result[0])
		thread_name = getCurrentThreadName();
	else
		thread_name = Transcoder::decode(result);
#elif WIN32
	typedef HRESULT (WINAPI *TGetThreadDescription)(HANDLE, PWSTR*);
	static struct initialiser
	{
		HMODULE hKernelBase;
		TGetThreadDescription GetThreadDescription;
		initialiser()
			: hKernelBase(GetModuleHandleA(""KernelBase.dll""))
			, GetThreadDescription(nullptr)
		{
			if (hKernelBase)
				GetThreadDescription = reinterpret_cast<TGetThreadDescription>(GetProcAddress(hKernelBase, ""GetThreadDescription""));
		}
	} win32func;
	if (win32func.GetThreadDescription)
	{
		PWSTR result = 0;
		HRESULT hr = win3...",1,,388,1,,void
33139,BLOCK,-1,,"{
		return thread_name;
	}",28,,394,2,,void
33152,BLOCK,-1,,"{
	if (m_priv->properties == 0)
	{
		m_priv->properties = new std::map<LogString, LogString>;
	}

	(*m_priv->properties)[key] = value;
}",1,,440,3,,void
33159,BLOCK,-1,,"{
		m_priv->properties = new std::map<LogString, LogString>;
	}",2,,442,2,,void
33177,BLOCK,-1,,"{
	return m_priv->level;
}",1,,450,1,,void
33185,BLOCK,-1,,"{
	return m_priv->logger;
}",1,,455,1,,void
33193,BLOCK,-1,,"{
	return m_priv->message;
}",1,,460,1,,void
33201,BLOCK,-1,,"{
	return m_priv->message;
}",1,,465,1,,void
33209,BLOCK,-1,,"{
	return m_priv->threadName;
}",1,,470,1,,void
33217,BLOCK,-1,,"{
	return m_priv->timeStamp;
}",1,,475,1,,void
33225,BLOCK,-1,,"{
	return m_priv->locationInfo;
}",1,,480,1,,void
33233,BLOCK,-1,,"{
	return m_priv->chronoTimeStamp;
}",92,,484,1,,void
33252,BLOCK,-1,,<empty>,1,,1,1,,ANY
33258,BLOCK,-1,,"{
}",1,,34,3,,void
33263,BLOCK,-1,,"{

}",1,,39,2,,void
33270,BLOCK,-1,,"{
	LoggingEventPtr le = LOG4CXX_NS::cast<LoggingEvent>(obj);

	if (le != NULL)
	{
		format(le, output, p);
	}
}",1,,46,4,,void
33285,BLOCK,-1,,"{
		format(le, output, p);
	}",2,,50,2,,void
33293,BLOCK,-1,,"{
	return false;
}",1,,56,1,,void
33320,BLOCK,-1,,<empty>,1,,1,1,,ANY
33323,BLOCK,-1,,<empty>,19,,37,1,,void
33327,BLOCK,-1,,"{
		quietMode = true; // Prevent output after deletion by onexit processing chain.
	}",2,,40,1,,void
33337,BLOCK,-1,,"{
	LogString log4cxxDebug = OptionConverter::getSystemProperty(LOG4CXX_STR(""LOG4CXX_DEBUG""), LOG4CXX_STR(""false""));
	m_priv->debugEnabled = OptionConverter::toBoolean(log4cxxDebug, false);
}",1,,55,1,,void
33362,BLOCK,-1,,<empty>,18,,60,1,,void
33366,BLOCK,-1,,"{
	static WideLife<LogLog> internalLogger;

	return internalLogger;
}",1,,63,1,,void
33374,BLOCK,-1,,"{
	auto p = getInstance().m_priv.get();
	std::unique_lock<std::mutex> lock(p->mutex);

	p->debugEnabled = debugEnabled1;
}",1,,70,2,,void
33405,BLOCK,-1,,"{
	auto p = getInstance().m_priv.get();
	if (p && !p->quietMode) // Not deleted by onexit processing?
	{
		if (!p->debugEnabled)
		{
			return;
		}

		std::unique_lock<std::mutex> lock(p->mutex);

		emit(msg);
	}
}",1,,78,2,,void
33422,BLOCK,-1,,"{
		if (!p->debugEnabled)
		{
			return;
		}

		std::unique_lock<std::mutex> lock(p->mutex);

		emit(msg);
	}",2,,81,2,,void
33428,BLOCK,-1,,"{
			return;
		}",3,,83,2,,void
33449,BLOCK,-1,,"{
	auto p = getInstance().m_priv.get();
	if (p && !p->quietMode) // Not deleted by onexit processing?
	{
		if (!p->debugEnabled)
			return;

		std::unique_lock<std::mutex> lock(p->mutex);
		emit(msg);
		emit(e);
	}
}",1,,94,3,,void
33466,BLOCK,-1,,"{
		if (!p->debugEnabled)
			return;

		std::unique_lock<std::mutex> lock(p->mutex);
		emit(msg);
		emit(e);
	}",2,,97,2,,void
33472,BLOCK,-1,,<empty>,4,,99,2,,void
33494,BLOCK,-1,,"{
	auto p = getInstance().m_priv.get();
	if (p && !p->quietMode) // Not deleted by onexit processing?
	{
		std::unique_lock<std::mutex> lock(p->mutex);

		emit(msg);
	}
}",1,,109,2,,void
33511,BLOCK,-1,,"{
		std::unique_lock<std::mutex> lock(p->mutex);

		emit(msg);
	}",2,,112,2,,void
33531,BLOCK,-1,,"{
	auto p = getInstance().m_priv.get();
	if (p && !p->quietMode) // Not deleted by onexit processing?
	{
		std::unique_lock<std::mutex> lock(p->mutex);
		emit(msg);
		emit(e);
	}
}",1,,120,3,,void
33548,BLOCK,-1,,"{
		std::unique_lock<std::mutex> lock(p->mutex);
		emit(msg);
		emit(e);
	}",2,,123,2,,void
33569,BLOCK,-1,,"{
	auto p = getInstance().m_priv.get();
	std::unique_lock<std::mutex> lock(p->mutex);

	p->quietMode = quietMode1;
}",1,,131,2,,void
33600,BLOCK,-1,,"{
	auto p = getInstance().m_priv.get();
	if (p && !p->quietMode) // Not deleted by onexit processing?
	{
		std::unique_lock<std::mutex> lock(p->mutex);
		emit(msg);
	}
}",1,,139,2,,void
33617,BLOCK,-1,,"{
		std::unique_lock<std::mutex> lock(p->mutex);
		emit(msg);
	}",2,,142,2,,void
33637,BLOCK,-1,,"{
	auto p = getInstance().m_priv.get();
	if (p && !p->quietMode) // Not deleted by onexit processing?
	{
		std::unique_lock<std::mutex> lock(p->mutex);
		emit(msg);
		emit(e);
	}
}",1,,149,3,,void
33654,BLOCK,-1,,"{
		std::unique_lock<std::mutex> lock(p->mutex);
		emit(msg);
		emit(e);
	}",2,,152,2,,void
33675,BLOCK,-1,,"{
	LogString out(LOG4CXX_STR(""log4cxx: ""));

	out.append(msg);
	out.append(1, (logchar) 0x0A);

	SystemErrWriter::write(out);
}",1,,160,2,,void
33702,BLOCK,-1,,"{
	LogString out(LOG4CXX_STR(""log4cxx: ""));
	const char* raw = ex.what();

	if (raw != 0)
	{
		Transcoder::decode(raw, out);
	}
	else
	{
		out.append(LOG4CXX_STR(""std::exception::what() == null""));
	}

	out.append(1, (logchar) 0x0A);

	SystemErrWriter::write(out);
}",1,,170,2,,void
33718,BLOCK,-1,,"{
		Transcoder::decode(raw, out);
	}",2,,175,2,,void
33726,BLOCK,-1,,"{
		out.append(LOG4CXX_STR(""std::exception::what() == null""));
	}",2,,179,1,,void
33750,BLOCK,-1,,"{
			LoggerRepositoryPtr hierarchy = Hierarchy::create();
			return std::make_shared<DefaultRepositorySelector>(hierarchy);
		}",3,,50,1,,void
33804,BLOCK,-1,,<empty>,1,,1,1,,ANY
33812,BLOCK,-1,,"{
	auto result = APRInitializer::getOrAddUnique<spi::RepositorySelector>( []() -> ObjectPtr
		{
			LoggerRepositoryPtr hierarchy = Hierarchy::create();
			return std::make_shared<DefaultRepositorySelector>(hierarchy);
		}
	);
	return result;
}",1,,48,1,,void
33832,BLOCK,-1,,"{
	if ((LogManager::guard != 0) && (LogManager::guard != guard1))
	{
		throw IllegalArgumentException(LOG4CXX_STR(""Attempted to reset the LoggerFactory without possessing the guard.""));
	}

	if (selector == 0)
	{
		throw IllegalArgumentException(LOG4CXX_STR(""RepositorySelector must be non-null.""));
	}

	LogManager::guard = guard1;
	APRInitializer::setUnique<spi::RepositorySelector>(selector);
}",1,,59,3,,void
33845,BLOCK,-1,,"{
		throw IllegalArgumentException(LOG4CXX_STR(""Attempted to reset the LoggerFactory without possessing the guard.""));
	}",2,,61,2,,void
33854,BLOCK,-1,,"{
		throw IllegalArgumentException(LOG4CXX_STR(""RepositorySelector must be non-null.""));
	}",2,,66,2,,void
33876,BLOCK,-1,,"{
	return getRepositorySelector()->getLoggerRepository();
}",1,,77,1,,void
33885,BLOCK,-1,,"{
	// Delegate the actual manufacturing of the logger to the logger repository.
	auto r = getLoggerRepository();
	r->ensureIsConfigured(std::bind(DefaultConfigurator::configure, r));
	return r->getRootLogger();
}",1,,82,1,,void
33911,BLOCK,-1,,"{
	auto r = getLoggerRepository();
	r->ensureIsConfigured(std::bind(DefaultConfigurator::configure, r));
	return r->getLogger(name);
}",1,,93,2,,void
33939,BLOCK,-1,,"{
	// Delegate the actual manufacturing of the logger to the logger repository.
	auto r = getLoggerRepository();
	r->ensureIsConfigured(std::bind(DefaultConfigurator::configure, r));
	return r->getLogger(name, factory);
}",1,,104,3,,void
33967,BLOCK,-1,,"{
	LOG4CXX_DECODE_CHAR(n, name);
	return getLoggerLS(n);
}",1,,112,2,,void
33979,BLOCK,-1,,"{
	LOG4CXX_DECODE_CHAR(n, name);
	return getLoggerLS(n, factory);
}",1,,119,3,,void
33991,BLOCK,-1,,"{
	LOG4CXX_DECODE_CHAR(n, name);
	return existsLS(n);
}",1,,125,2,,void
34002,BLOCK,-1,,"{
	return getLoggerRepository()->exists(name);
}",1,,194,2,,void
34012,BLOCK,-1,,"{
	return getLoggerRepository()->getCurrentLoggers();
}",1,,199,1,,void
34021,BLOCK,-1,,"{
	APRInitializer::unregisterAll();
	getLoggerRepository()->shutdown();
}",1,,204,1,,void
34033,BLOCK,-1,,"{
	getLoggerRepository()->resetConfiguration();
}",1,,210,1,,void
34043,BLOCK,-1,,"{
#if LOG4CXX_ABI_VERSION <= 15
	bool result = false;
	if (auto r = dynamic_cast<Hierarchy*>(getLoggerRepository().get()))
		result = r->removeLogger(name, ifNotUsed);
	return result;
#else
	return getLoggerRepository()->removeLogger(name, ifNotUsed);
#endif
}",1,,215,3,,void
34049,BLOCK,-1,,<empty>,6,,218,1,,void
34059,BLOCK,-1,,<empty>,3,,219,2,,void
34086,BLOCK,-1,,<empty>,1,,1,1,,ANY
34090,BLOCK,-1,,"{
#if LOG4CXX_MEMSET_IOS_BASE
	//
	//    the destructor for std::ios_base in the MSVC STL
	//        releases a pointer that was not initialized in the constructor.
	//
	memset(this, 0, sizeof(*this));
#endif
#if LOG4CXX_INIT_IOS_BASE
	init(NULL);
#endif
	flags(initval);
	precision(initsize);
	width(initsize);

}",1,,35,3,,void
34102,BLOCK,-1,,"{
	enabled = logger->isEnabledFor(level);
}",1,,56,3,,void
34113,BLOCK,-1,,"{
}",1,,61,1,,void
34118,BLOCK,-1,,"{
	get_stream_state(initclear, initset, fillchar, fillset);
	(*manip)(initset);
	(*manip)(initclear);
	refresh_stream_state();
}",1,,65,2,,void
34138,BLOCK,-1,,"{
	std::ios_base::fmtflags setval = initset.flags();
	std::ios_base::fmtflags clrval = initclear.flags();
	std::ios_base::fmtflags mask = setval ^ (~clrval);
	dest.setf(clrval, mask);

	if (initset.precision() == initclear.precision())
	{
		dest.precision(initset.precision());
	}

	if (initset.width() == initclear.width())
	{
		dest.width(initset.width());
	}

	dstchar = fillchar;
	return fillset;
}",1,,73,3,,void
34176,BLOCK,-1,,"{
		dest.precision(initset.precision());
	}",2,,80,2,,void
34195,BLOCK,-1,,"{
		dest.width(initset.width());
	}",2,,85,2,,void
34213,BLOCK,-1,,"{
	stream.end_message();
	return stream;
}",1,,94,2,,void
34224,BLOCK,-1,,"{
	return stream;
}",1,,100,2,,void
34230,BLOCK,-1,,"{
	if (isEnabled())
	{
		log(logger, level, location);
	}

	erase();
}",1,,105,1,,void
34233,BLOCK,-1,,"{
		log(logger, level, location);
	}",2,,107,2,,void
34243,BLOCK,-1,,"{
	get_stream_state(initclear, initset, fillchar, fillset);
	initset.precision(p);
	int oldVal = (int)initclear.precision(p);
	refresh_stream_state();
	return oldVal;
}",1,,117,2,,void
34270,BLOCK,-1,,"{
	get_stream_state(initclear, initset, fillchar, fillset);
	return (int)initclear.precision();
}",1,,126,1,,void
34287,BLOCK,-1,,"{
	get_stream_state(initclear, initset, fillchar, fillset);
	initset.width(w);
	int oldVal = (int)initclear.width(w);
	refresh_stream_state();
	return oldVal;
}",1,,132,2,,void
34314,BLOCK,-1,,"{
	get_stream_state(initclear, initset, fillchar, fillset);
	return (int)initclear.width();
}",1,,141,1,,void
34331,BLOCK,-1,,"{
	get_stream_state(initclear, initset, fillchar, fillset);
	int oldfill = fillchar;
	fillchar = newfill;
	fillset = true;
	refresh_stream_state();
	return oldfill;
}",1,,147,2,,void
34353,BLOCK,-1,,"{
	get_stream_state(initclear, initset, fillchar, fillset);
	return fillchar;
}",1,,157,1,,void
34365,BLOCK,-1,,"{
	get_stream_state(initclear, initset, fillchar, fillset);
	initset.flags(newflags);
	std::ios_base::fmtflags oldVal = initclear.flags(newflags);
	refresh_stream_state();
	return oldVal;
}",1,,163,2,,void
34392,BLOCK,-1,,"{
	get_stream_state(initclear, initset, fillchar, fillset);
	initset.setf(newflags, mask);
	std::ios_base::fmtflags oldVal = initclear.setf(newflags, mask);
	refresh_stream_state();
	return oldVal;
}",1,,172,3,,void
34420,BLOCK,-1,,"{
	get_stream_state(initclear, initset, fillchar, fillset);
	initset.setf(newflags);
	std::ios_base::fmtflags oldVal = initclear.setf(newflags);
	refresh_stream_state();
	return oldVal;
}",1,,181,2,,void
34446,BLOCK,-1,,"{
	level = newlevel;
	bool oldLevel = enabled;
	enabled = logger->isEnabledFor(level);

	if (oldLevel != enabled)
	{
		erase();
	}
}",1,,192,2,,void
34465,BLOCK,-1,,"{
		erase();
	}",2,,198,2,,void
34471,BLOCK,-1,,"{
	return logger->isEnabledFor(l);
}",1,,204,2,,void
34482,BLOCK,-1,,"{
	if (LOG4CXX_UNLIKELY(enabled))
	{
		location = newlocation;
	}
}",1,,210,2,,void
34484,BLOCK,-1,,<empty>,6,,211,1,,void
34486,BLOCK,-1,,"{
		location = newlocation;
	}",2,,212,2,,void
34495,BLOCK,-1,,"{
}",1,,220,3,,void
34501,BLOCK,-1,,"{
}",1,,226,3,,void
34507,BLOCK,-1,,"{
}",1,,232,3,,void
34511,BLOCK,-1,,"{
	delete stream;
}",1,,236,1,,void
34518,BLOCK,-1,,"{
	(*manip)(*this);
	return *this;
}",1,,241,2,,void
34531,BLOCK,-1,,"{
	setLevel(l);
	return *this;
}",1,,247,2,,void
34541,BLOCK,-1,,"{
	setLocation(newlocation);
	return *this;
}",1,,253,2,,void
34551,BLOCK,-1,,"{
	setLocation(newlocation);
	return *this;
}",1,,259,2,,void
34561,BLOCK,-1,,"{
	logstream_base::insert(manip);
	return *this;
}",1,,265,2,,void
34573,BLOCK,-1,,"{
	if (stream == 0)
	{
		stream = new std::basic_stringstream<Ch>();
		refresh_stream_state();
	}

	return *stream;
}",1,,271,1,,void
34578,BLOCK,-1,,"{
		stream = new std::basic_stringstream<Ch>();
		refresh_stream_state();
	}",2,,273,2,,void
34593,BLOCK,-1,,"{
	if (stream != 0)
	{
		std::basic_string<Ch> msg = stream->str();

		if (!msg.empty())
		{
			log->log(lev, msg, loc);
		}
	}
}",1,,284,4,,void
34598,BLOCK,-1,,"{
		std::basic_string<Ch> msg = stream->str();

		if (!msg.empty())
		{
			log->log(lev, msg, loc);
		}
	}",2,,286,2,,void
34617,BLOCK,-1,,"{
			log->log(lev, msg, loc);
		}",3,,290,2,,void
34628,BLOCK,-1,,"{
	if (stream != 0)
	{
		std::basic_string<Ch> emptyStr;
		stream->str(emptyStr);
	}
}",1,,298,1,,void
34633,BLOCK,-1,,"{
		std::basic_string<Ch> emptyStr;
		stream->str(emptyStr);
	}",2,,300,2,,void
34653,BLOCK,-1,,"{
	if (stream != 0)
	{
		std::ios_base::fmtflags flags = stream->flags();
		base.flags(flags);
		mask.flags(flags);
		int width = (int)stream->width();
		base.width(width);
		mask.width(width);
		int precision = (int)stream->precision();
		base.precision(precision);
		mask.precision(precision);
		fill = stream->fill();
		fillSet = true;
	}
}",1,,311,5,,void
34658,BLOCK,-1,,"{
		std::ios_base::fmtflags flags = stream->flags();
		base.flags(flags);
		mask.flags(flags);
		int width = (int)stream->width();
		base.width(width);
		mask.width(width);
		int precision = (int)stream->precision();
		base.precision(precision);
		mask.precision(precision);
		fill = stream->fill();
		fillSet = true;
	}",2,,313,2,,void
34726,BLOCK,-1,,"{
	if (stream != 0)
	{
		int ch;

		if (logstream_base::set_stream_state(*stream, ch))
		{
			stream->fill(ch);
		}
	}
}",1,,329,1,,void
34731,BLOCK,-1,,"{
		int ch;

		if (logstream_base::set_stream_state(*stream, ch))
		{
			stream->fill(ch);
		}
	}",2,,331,2,,void
34741,BLOCK,-1,,"{
			stream->fill(ch);
		}",3,,335,2,,void
34759,BLOCK,-1,,<empty>,1,,1,1,,ANY
34763,BLOCK,-1,,"{
}",1,,29,1,,void
34771,BLOCK,-1,,"{
	return false;
}",1,,36,5,,void
34778,BLOCK,-1,,"{
}",1,,41,2,,void
34784,BLOCK,-1,,"{
}",1,,45,3,,void
34803,BLOCK,-1,,<empty>,1,,1,1,,ANY
34806,BLOCK,-1,,<empty>,44,,35,1,,void
34815,BLOCK,-1,,"{

}",1,,45,1,,void
34819,BLOCK,-1,,<empty>,25,,49,1,,void
34825,BLOCK,-1,,"{
	if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""ACCEPTONMATCH""), LOG4CXX_STR(""acceptonmatch"")))
	{
		priv->acceptOnMatch = OptionConverter::toBoolean(value, priv->acceptOnMatch);
	}
	else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""OPERATOR""), LOG4CXX_STR(""operator"")))
	{
		priv->mustMatchAll = StringHelper::equalsIgnoreCase(value, LOG4CXX_STR(""AND""), LOG4CXX_STR(""and"")) ? true : false;
	}
	else if (!option.empty() && !value.empty())
	{
		priv->keyVals[option] = value;
	}
}",1,,53,3,,void
34836,BLOCK,-1,,"{
		priv->acceptOnMatch = OptionConverter::toBoolean(value, priv->acceptOnMatch);
	}",2,,55,2,,void
34839,BLOCK,1,,<empty>,,,,1,,void
34854,BLOCK,1,,<empty>,,,,1,,void
34864,BLOCK,-1,,<empty>,7,,58,1,,void
34875,BLOCK,-1,,"{
		priv->mustMatchAll = StringHelper::equalsIgnoreCase(value, LOG4CXX_STR(""AND""), LOG4CXX_STR(""and"")) ? true : false;
	}",2,,59,2,,void
34878,BLOCK,1,,<empty>,,,,1,,void
34900,BLOCK,-1,,<empty>,7,,62,1,,void
34913,BLOCK,-1,,"{
		priv->keyVals[option] = value;
	}",2,,63,2,,void
34916,BLOCK,1,,<empty>,,,,1,,void
34932,BLOCK,-1,,"{
	if (priv->keyVals.empty())
	{
		return Filter::NEUTRAL;
	}

	bool matched = true;

	for (KeyVals::const_iterator it = priv->keyVals.begin(); it != priv->keyVals.end(); ++it)
	{
		LogString curval;
		event->getMDC(it->first, curval);

		if (curval.empty() || curval != it->second)
		{
			matched = false;
		}
		else
		{
			matched = true;
		}

		if (priv->mustMatchAll != matched)
		{
			break;
		}
	}

	if (priv->acceptOnMatch)
	{
		return matched ? Filter::ACCEPT : Filter::NEUTRAL;
	}
	else
	{
		return matched ? Filter::DENY : Filter::NEUTRAL;
	}
}",1,,70,2,,void
34935,BLOCK,1,,<empty>,,,,1,,void
34947,BLOCK,-1,,"{
		return Filter::NEUTRAL;
	}",2,,72,2,,void
34957,BLOCK,-1,,<empty>,2,,78,1,,void
34962,BLOCK,1,,<empty>,,,,1,,void
34977,BLOCK,1,,<empty>,,,,1,,void
34991,BLOCK,4,,"{
		LogString curval;
		event->getMDC(it->first, curval);

		if (curval.empty() || curval != it->second)
		{
			matched = false;
		}
		else
		{
			matched = true;
		}

		if (priv->mustMatchAll != matched)
		{
			break;
		}
	}",2,,79,4,,void
35012,BLOCK,-1,,"{
			matched = false;
		}",3,,84,2,,void
35017,BLOCK,-1,,"{
			matched = true;
		}",3,,88,1,,void
35024,BLOCK,1,,<empty>,,,,1,,void
35034,BLOCK,-1,,"{
			break;
		}",3,,93,2,,void
35038,BLOCK,1,,<empty>,,,,1,,void
35047,BLOCK,-1,,"{
		return matched ? Filter::ACCEPT : Filter::NEUTRAL;
	}",2,,99,2,,void
35058,BLOCK,-1,,"{
		return matched ? Filter::DENY : Filter::NEUTRAL;
	}",2,,103,1,,void
35073,BLOCK,-1,,"{
	priv->keyVals[strKey] = strValue;
}",1,,109,3,,void
35076,BLOCK,1,,<empty>,,,,1,,void
35092,BLOCK,-1,,"{
	static const WideLife<LogString> empty;
	const KeyVals::const_iterator   it(priv->keyVals.find(strKey));

	return (it != priv->keyVals.end() ? it->second : empty.value());
}",1,,114,2,,void
35097,BLOCK,1,,<empty>,,,,1,,void
35115,BLOCK,1,,<empty>,,,,1,,void
35138,BLOCK,-1,,"{
	priv->acceptOnMatch = acceptOnMatch1;
}",1,,122,2,,void
35141,BLOCK,1,,<empty>,,,,1,,void
35154,BLOCK,-1,,"{
	return priv->acceptOnMatch;
}",1,,127,1,,void
35157,BLOCK,1,,<empty>,,,,1,,void
35169,BLOCK,-1,,"{
	return priv->mustMatchAll;
}",1,,132,1,,void
35172,BLOCK,1,,<empty>,,,,1,,void
35185,BLOCK,-1,,"{
	priv->mustMatchAll = mustMatchAll1;
}",1,,137,2,,void
35188,BLOCK,1,,<empty>,,,,1,,void
35212,BLOCK,-1,,<empty>,1,,1,1,,ANY
35216,BLOCK,-1,,"{
	Transcoder::decode(key1, key);
	LOG4CXX_DECODE_CHAR(v, value);
	putLS(key, v);
}",1,,31,3,,void
35232,BLOCK,-1,,"{
	LogString prevVal;
	remove(key, prevVal);
}",1,,38,1,,void
35242,BLOCK,-1,,"{
	ThreadSpecificData::put(key, value);
}",1,,44,3,,void
35254,BLOCK,-1,,"{
	LOG4CXX_DECODE_CHAR(lkey, key);
	LOG4CXX_DECODE_CHAR(lvalue, value);
	putLS(lkey, lvalue);
}",1,,49,3,,void
35269,BLOCK,-1,,"{
	ThreadSpecificData* data = ThreadSpecificData::getCurrentData();

	if (data != 0)
	{
		Map& map = data->getMap();

		Map::iterator it = map.find(key);

		if (it != map.end())
		{
			value.append(it->second);
			return true;
		}

		data->recycle();
	}

	return false;
}",1,,56,3,,void
35281,BLOCK,-1,,"{
		Map& map = data->getMap();

		Map::iterator it = map.find(key);

		if (it != map.end())
		{
			value.append(it->second);
			return true;
		}

		data->recycle();
	}",2,,60,2,,void
35304,BLOCK,-1,,"{
			value.append(it->second);
			return true;
		}",3,,66,2,,void
35324,BLOCK,-1,,"{
	LOG4CXX_DECODE_CHAR(lkey, key);
	LogString lvalue;

	if (get(lkey, lvalue))
	{
		LOG4CXX_ENCODE_CHAR(value, lvalue);
		return value;
	}

	return std::string();
}",1,,78,2,,void
35333,BLOCK,-1,,"{
		LOG4CXX_ENCODE_CHAR(value, lvalue);
		return value;
	}",2,,83,2,,void
35349,BLOCK,-1,,"{
	ThreadSpecificData* data = ThreadSpecificData::getCurrentData();

	if (data != 0)
	{
		Map& map = data->getMap();
		Map::iterator it;

		if ((it = map.find(key)) != map.end())
		{
			value = it->second;
			map.erase(it);
			data->recycle();
			return true;
		}
	}

	return false;
}",1,,92,3,,void
35361,BLOCK,-1,,"{
		Map& map = data->getMap();
		Map::iterator it;

		if ((it = map.find(key)) != map.end())
		{
			value = it->second;
			map.erase(it);
			data->recycle();
			return true;
		}
	}",2,,96,2,,void
35383,BLOCK,-1,,"{
			value = it->second;
			map.erase(it);
			data->recycle();
			return true;
		}",3,,101,2,,void
35406,BLOCK,-1,,"{
	LOG4CXX_DECODE_CHAR(lkey, key);
	LogString lvalue;

	if (remove(lkey, lvalue))
	{
		LOG4CXX_ENCODE_CHAR(value, lvalue);
		return value;
	}

	return std::string();
}",1,,113,2,,void
35415,BLOCK,-1,,"{
		LOG4CXX_ENCODE_CHAR(value, lvalue);
		return value;
	}",2,,118,2,,void
35429,BLOCK,-1,,"{
	ThreadSpecificData* data = ThreadSpecificData::getCurrentData();

	if (data != 0)
	{
		Map& map = data->getMap();
		map.erase(map.begin(), map.end());
		data->recycle();
	}
}",1,,128,1,,void
35441,BLOCK,-1,,"{
		Map& map = data->getMap();
		map.erase(map.begin(), map.end());
		data->recycle();
	}",2,,132,2,,void
35479,BLOCK,-1,,<empty>,1,,1,1,,ANY
35486,BLOCK,-1,,"{
}",1,,34,4,,void
35491,BLOCK,-1,,"{
	if (options.empty())
	{
		static helpers::WideLife<PatternConverterPtr> def = std::make_shared<MDCPatternConverter>();
		return def;
	}
	return std::make_shared<MDCPatternConverter>(LogString(), options.front());
}",1,,39,2,,void
35497,BLOCK,-1,,"{
		static helpers::WideLife<PatternConverterPtr> def = std::make_shared<MDCPatternConverter>();
		return def;
	}",2,,41,2,,void
35527,BLOCK,-1,,"{
	size_t startIndex = toAppendTo.size();
	if (m_priv->name.empty()) // Full MDC required?
	{
		bool first = true;
		for (auto key : event->getMDCKeySet())
		{
			toAppendTo.append(first ? LOG4CXX_STR(""{"") : LOG4CXX_STR("",""));
			JSONLayout::appendItem(key, toAppendTo);
			toAppendTo.append(LOG4CXX_STR("":""));
			LogString value;
			event->getMDC(key, value);
			JSONLayout::appendItem(value, toAppendTo);
			first = false;
		}
		if (!first)
			toAppendTo.append(LOG4CXX_STR(""}""));
	}
	else
		event->getMDC(m_priv->name, toAppendTo);
	if (!m_priv->style.empty()) // In a quoted context?
	{
		auto quote = m_priv->style.front();
		size_t endIndex;
		while ((endIndex = toAppendTo.find(quote, startIndex)) != toAppendTo.npos)
		{
			toAppendTo.insert(endIndex + 1, 1, quote);
			startIndex = endIndex + 2;
		}
	}
}",1,,53,4,,void
35542,BLOCK,-1,,"{
		bool first = true;
		for (auto key : event->getMDCKeySet())
		{
			toAppendTo.append(first ? LOG4CXX_STR(""{"") : LOG4CXX_STR("",""));
			JSONLayout::appendItem(key, toAppendTo);
			toAppendTo.append(LOG4CXX_STR("":""));
			LogString value;
			event->getMDC(key, value);
			JSONLayout::appendItem(value, toAppendTo);
			first = false;
		}
		if (!first)
			toAppendTo.append(LOG4CXX_STR(""}""));
	}",2,,56,2,,void
35553,BLOCK,-1,,"{
			toAppendTo.append(first ? LOG4CXX_STR(""{"") : LOG4CXX_STR("",""));
			JSONLayout::appendItem(key, toAppendTo);
			toAppendTo.append(LOG4CXX_STR("":""));
			LogString value;
			event->getMDC(key, value);
			JSONLayout::appendItem(value, toAppendTo);
			first = false;
		}",3,,59,3,,void
35595,BLOCK,-1,,<empty>,4,,69,2,,void
35603,BLOCK,-1,,<empty>,3,,72,1,,void
35620,BLOCK,-1,,"{
		auto quote = m_priv->style.front();
		size_t endIndex;
		while ((endIndex = toAppendTo.find(quote, startIndex)) != toAppendTo.npos)
		{
			toAppendTo.insert(endIndex + 1, 1, quote);
			startIndex = endIndex + 2;
		}
	}",2,,74,2,,void
35644,BLOCK,-1,,"{
			toAppendTo.insert(endIndex + 1, 1, quote);
			startIndex = endIndex + 2;
		}",3,,78,2,,void
35681,BLOCK,-1,,<empty>,1,,1,1,,ANY
35687,BLOCK,-1,,<empty>,3,,42,1,,void
35691,BLOCK,-1,,"{
#if !LOG4CXX_HAS_THREAD_LOCAL
		delete stream;
#endif
	}",2,,44,1,,void
35697,BLOCK,-1,,"{
		if (!this->stream)
		{
#if LOG4CXX_HAS_THREAD_LOCAL
			const static std::basic_ostringstream<T> initialState;
			thread_local static std::basic_ostringstream<T> sStream;
			this->stream = &sStream;
			this->stream->clear();
			this->stream->precision(initialState.precision());
			this->stream->width(initialState.width());
			this->stream->setf(initialState.flags(), ~initialState.flags());
			this->stream->fill(initialState.fill());
#else
			this->stream = new std::basic_ostringstream<T>();
#endif
			auto index = this->buf.size();
			this->stream->str(std::move(this->buf));
			this->stream->seekp(index);
		}
		return *this->stream;
	}",2,,53,1,,void
35703,BLOCK,-1,,"{
#if LOG4CXX_HAS_THREAD_LOCAL
			const static std::basic_ostringstream<T> initialState;
			thread_local static std::basic_ostringstream<T> sStream;
			this->stream = &sStream;
			this->stream->clear();
			this->stream->precision(initialState.precision());
			this->stream->width(initialState.width());
			this->stream->setf(initialState.flags(), ~initialState.flags());
			this->stream->fill(initialState.fill());
#else
			this->stream = new std::basic_ostringstream<T>();
#endif
			auto index = this->buf.size();
			this->stream->str(std::move(this->buf));
			this->stream->seekp(index);
		}",3,,55,2,,void
35747,BLOCK,-1,,"{
		if (this->stream)
		{
			this->buf = std::move(*this->stream).str();
			this->stream->seekp(0);
			this->stream->str(std::basic_string<T>());
			this->stream->clear();
		}
		return this->buf;
	}",2,,78,1,,void
35752,BLOCK,-1,,"{
			this->buf = std::move(*this->stream).str();
			this->stream->seekp(0);
			this->stream->str(std::basic_string<T>());
			this->stream->clear();
		}",3,,80,2,,void
35799,BLOCK,-1,,"{
}",1,,94,1,,void
35803,BLOCK,-1,,"{
}",1,,98,1,,void
35808,BLOCK,-1,,"{
	if (m_priv->stream == 0)
	{
		m_priv->buf.append(msg);
	}
	else
	{
		*m_priv->stream << msg;
	}

	return *this;
}",1,,102,2,,void
35815,BLOCK,-1,,"{
		m_priv->buf.append(msg);
	}",2,,104,2,,void
35824,BLOCK,-1,,"{
		*m_priv->stream << msg;
	}",2,,108,1,,void
35838,BLOCK,-1,,"{
	const char* actualMsg = msg;

	if (actualMsg == 0)
	{
		actualMsg = ""null"";
	}

	if (m_priv->stream == 0)
	{
		m_priv->buf.append(actualMsg);
	}
	else
	{
		*m_priv->stream << actualMsg;
	}

	return *this;
}",1,,116,2,,void
35847,BLOCK,-1,,"{
		actualMsg = ""null"";
	}",2,,120,2,,void
35857,BLOCK,-1,,"{
		m_priv->buf.append(actualMsg);
	}",2,,125,2,,void
35866,BLOCK,-1,,"{
		*m_priv->stream << actualMsg;
	}",2,,129,1,,void
35880,BLOCK,-1,,"{
	return operator<<((const char*) msg);
}",1,,136,2,,void
35890,BLOCK,-1,,"{
	if (m_priv->stream == 0)
	{
		m_priv->buf.append(1, msg);
	}
	else
	{
		m_priv->buf.assign(1, msg);
		*m_priv->stream << m_priv->buf;
	}

	return *this;
}",1,,141,2,,void
35897,BLOCK,-1,,"{
		m_priv->buf.append(1, msg);
	}",2,,143,2,,void
35907,BLOCK,-1,,"{
		m_priv->buf.assign(1, msg);
		*m_priv->stream << m_priv->buf;
	}",2,,147,1,,void
35930,BLOCK,-1,,"{
	return m_priv->StreamFromBuf();
}",1,,156,1,,void
35940,BLOCK,-1,,"{
	return std::move(m_priv->BufFromStream());
}",1,,161,2,,void
35954,BLOCK,-1,,"{
	return std::move(m_priv->buf);
}",1,,166,2,,void
35967,BLOCK,-1,,"{
	return m_priv->BufFromStream();
}",1,,171,2,,void
35977,BLOCK,-1,,"{
	return m_priv->buf;
}",1,,176,2,,void
35985,BLOCK,-1,,"{
	return (m_priv->stream != 0);
}",1,,181,1,,void
35996,BLOCK,-1,,"{
	std::ostream& s = *this;
	(*manip)(s);
	return s;
}",1,,186,2,,void
36012,BLOCK,-1,,"{
	return ((std::ostream&) * this).operator << (val);
}",1,,193,2,,void
36026,BLOCK,-1,,"{
	return ((std::ostream&) * this).operator << (val);
}",1,,197,2,,void
36040,BLOCK,-1,,"{
	return ((std::ostream&) * this).operator << (val);
}",1,,201,2,,void
36054,BLOCK,-1,,"{
	return ((std::ostream&) * this).operator << (val);
}",1,,205,2,,void
36068,BLOCK,-1,,"{
	return ((std::ostream&) * this).operator << (val);
}",1,,209,2,,void
36082,BLOCK,-1,,"{
	return ((std::ostream&) * this).operator << (val);
}",1,,213,2,,void
36096,BLOCK,-1,,"{
	return ((std::ostream&) * this).operator << (val);
}",1,,217,2,,void
36110,BLOCK,-1,,"{
	return ((std::ostream&) * this).operator << (val);
}",1,,221,2,,void
36124,BLOCK,-1,,"{
	return ((std::ostream&) * this).operator << (val);
}",1,,225,2,,void
36138,BLOCK,-1,,"{
	return ((std::ostream&) * this).operator << (val);
}",1,,229,2,,void
36162,BLOCK,-1,,<empty>,1,,1,1,,ANY
36170,BLOCK,-1,,<empty>,4,,40,2,,void
36177,BLOCK,-1,,"{
			auto& input = event->getRenderedMessage();
			size_t endIndex, startIndex = 0;
			while ((endIndex = input.find(m_quote, startIndex)) != input.npos)
			{
				toAppendTo.append(input.substr(startIndex, endIndex - startIndex + 1));
				toAppendTo += m_quote;
				startIndex = endIndex + 1;
			}
			toAppendTo.append(input.substr(startIndex));
		}",3,,50,4,,void
36203,BLOCK,-1,,"{
				toAppendTo.append(input.substr(startIndex, endIndex - startIndex + 1));
				toAppendTo += m_quote;
				startIndex = endIndex + 1;
			}",4,,54,2,,void
36238,BLOCK,-1,,"{
}",1,,67,1,,void
36243,BLOCK,-1,,"{
	if (options.empty() || options.front().empty())
	{
		static helpers::WideLife<PatternConverterPtr> def = std::make_shared<MessagePatternConverter>();
		return def;
	}
	return std::make_shared<QuotedMessagePatternConverter>(options.front().front());
}",1,,72,2,,void
36257,BLOCK,-1,,"{
		static helpers::WideLife<PatternConverterPtr> def = std::make_shared<MessagePatternConverter>();
		return def;
	}",2,,74,2,,void
36287,BLOCK,-1,,"{
	toAppendTo.append(event->getRenderedMessage());
}",1,,86,4,,void
36310,BLOCK,-1,,<empty>,1,,1,1,,ANY
36314,BLOCK,-1,,"{
}",1,,33,1,,void
36319,BLOCK,-1,,"{
	static WideLife<PatternConverterPtr> def = std::make_shared<MethodLocationPatternConverter>();
	return def;
}",1,,38,2,,void
36335,BLOCK,-1,,"{
	append(toAppendTo, event->getLocationInformation().getMethodName());
}",1,,47,4,,void
36385,BLOCK,-1,,<empty>,1,,1,1,,ANY
36388,BLOCK,-1,,<empty>,17,,49,1,,void
36398,BLOCK,-1,,"{
}",1,,82,1,,void
36403,BLOCK,-1,,"{
	if (_priv->rollingPolicy == NULL)
	{
		auto fwrp = std::make_shared<FixedWindowRollingPolicy>();
		fwrp->setFileNamePattern(getFile() + LOG4CXX_STR("".%i""));
		_priv->rollingPolicy = fwrp;
	}

	//
	//  if no explicit triggering policy and rolling policy is both.
	//
	if (_priv->triggeringPolicy == NULL)
	{
		TriggeringPolicyPtr trig = LOG4CXX_NS::cast<TriggeringPolicy>(_priv->rollingPolicy);

		if (trig != NULL)
		{
			_priv->triggeringPolicy = trig;
		}
	}

	if (_priv->triggeringPolicy == NULL)
	{
		_priv->triggeringPolicy = std::make_shared<ManualTriggeringPolicy>();
	}

	{
		std::lock_guard<std::recursive_mutex> lock(_priv->mutex);
		_priv->triggeringPolicy->activateOptions(p);
		_priv->rollingPolicy->activateOptions(p);

		try
		{
			RolloverDescriptionPtr rollover1 =
				_priv->rollingPolicy->initialize(getFile(), getAppend(), p);

			if (rollover1 != NULL)
			{
				ActionPtr syncAction(rollover1->getSynchronous());

				if (syncAction != NULL)
				{
					syncAction->execute(...",1,,89,2,,void
36407,BLOCK,1,,<empty>,,,,1,,void
36417,BLOCK,-1,,"{
		auto fwrp = std::make_shared<FixedWindowRollingPolicy>();
		fwrp->setFileNamePattern(getFile() + LOG4CXX_STR("".%i""));
		_priv->rollingPolicy = fwrp;
	}",2,,91,2,,void
36435,BLOCK,1,,<empty>,,,,1,,void
36448,BLOCK,1,,<empty>,,,,1,,void
36458,BLOCK,-1,,"{
		TriggeringPolicyPtr trig = LOG4CXX_NS::cast<TriggeringPolicy>(_priv->rollingPolicy);

		if (trig != NULL)
		{
			_priv->triggeringPolicy = trig;
		}
	}",2,,101,2,,void
36469,BLOCK,1,,<empty>,,,,1,,void
36482,BLOCK,-1,,"{
			_priv->triggeringPolicy = trig;
		}",3,,105,2,,void
36485,BLOCK,1,,<empty>,,,,1,,void
36498,BLOCK,1,,<empty>,,,,1,,void
36508,BLOCK,-1,,"{
		_priv->triggeringPolicy = std::make_shared<ManualTriggeringPolicy>();
	}",2,,111,2,,void
36511,BLOCK,1,,<empty>,,,,1,,void
36524,BLOCK,4,,"{
		std::lock_guard<std::recursive_mutex> lock(_priv->mutex);
		_priv->triggeringPolicy->activateOptions(p);
		_priv->rollingPolicy->activateOptions(p);

		try
		{
			RolloverDescriptionPtr rollover1 =
				_priv->rollingPolicy->initialize(getFile(), getAppend(), p);

			if (rollover1 != NULL)
			{
				ActionPtr syncAction(rollover1->getSynchronous());

				if (syncAction != NULL)
				{
					syncAction->execute(p);
				}

				_priv->fileName = rollover1->getActiveFileName();
				_priv->fileAppend = rollover1->getAppend();

				//
				//  async action not yet implemented
				//
				ActionPtr asyncAction(rollover1->getAsynchronous());

				if (asyncAction != NULL)
				{
					asyncAction->execute(p);
				}
			}

			File activeFile;
			activeFile.setPath(getFile());

			if (getAppend())
			{
				_priv->fileLength = activeFile.length(p);
			}
			else
			{
				_priv->fileLength = 0;
			}

			FileAppender::activateOptionsInternal(p);
		}
		catch (std::exception&)
		{
			LogLog::warn(
				Lo...",2,,115,4,,void
36535,BLOCK,1,,<empty>,,,,1,,void
36545,BLOCK,1,,<empty>,,,,1,,void
36559,BLOCK,1,,<empty>,,,,1,,void
36573,BLOCK,-1,,"{
			RolloverDescriptionPtr rollover1 =
				_priv->rollingPolicy->initialize(getFile(), getAppend(), p);

			if (rollover1 != NULL)
			{
				ActionPtr syncAction(rollover1->getSynchronous());

				if (syncAction != NULL)
				{
					syncAction->execute(p);
				}

				_priv->fileName = rollover1->getActiveFileName();
				_priv->fileAppend = rollover1->getAppend();

				//
				//  async action not yet implemented
				//
				ActionPtr asyncAction(rollover1->getAsynchronous());

				if (asyncAction != NULL)
				{
					asyncAction->execute(p);
				}
			}

			File activeFile;
			activeFile.setPath(getFile());

			if (getAppend())
			{
				_priv->fileLength = activeFile.length(p);
			}
			else
			{
				_priv->fileLength = 0;
			}

			FileAppender::activateOptionsInternal(p);
		}",3,,121,1,,void
36578,BLOCK,1,,<empty>,,,,1,,void
36597,BLOCK,-1,,"{
				ActionPtr syncAction(rollover1->getSynchronous());

				if (syncAction != NULL)
				{
					syncAction->execute(p);
				}

				_priv->fileName = rollover1->getActiveFileName();
				_priv->fileAppend = rollover1->getAppend();

				//
				//  async action not yet implemented
				//
				ActionPtr asyncAction(rollover1->getAsynchronous());

				if (asyncAction != NULL)
				{
					asyncAction->execute(p);
				}
			}",4,,126,2,,void
36608,BLOCK,-1,,"{
					syncAction->execute(p);
				}",5,,130,2,,void
36616,BLOCK,1,,<empty>,,,,1,,void
36631,BLOCK,1,,<empty>,,,,1,,void
36654,BLOCK,-1,,"{
					asyncAction->execute(p);
				}",5,,143,2,,void
36668,BLOCK,-1,,"{
				_priv->fileLength = activeFile.length(p);
			}",4,,152,2,,void
36671,BLOCK,1,,<empty>,,,,1,,void
36686,BLOCK,-1,,"{
				_priv->fileLength = 0;
			}",4,,156,1,,void
36689,BLOCK,1,,<empty>,,,,1,,void
36704,BLOCK,2,,"{
			LogLog::warn(
				LogString(LOG4CXX_STR(""Exception will initializing RollingFileAppender named ""))
				+ getName());
		}",3,,163,2,,void
36718,BLOCK,-1,,"{
	if (lock_file)
	{
		apr_status_t stat = apr_file_unlock(lock_file);

		if (stat != APR_SUCCESS)
		{
			LogLog::warn(LOG4CXX_STR(""flock: unlock failed""));
		}

		apr_file_close(lock_file);
		lock_file = NULL;
	}
}",1,,172,2,,void
36721,BLOCK,-1,,"{
		apr_status_t stat = apr_file_unlock(lock_file);

		if (stat != APR_SUCCESS)
		{
			LogLog::warn(LOG4CXX_STR(""flock: unlock failed""));
		}

		apr_file_close(lock_file);
		lock_file = NULL;
	}",2,,174,2,,void
36731,BLOCK,-1,,"{
			LogLog::warn(LOG4CXX_STR(""flock: unlock failed""));
		}",3,,178,2,,void
36747,BLOCK,-1,,"{
	std::lock_guard<std::recursive_mutex> lock(_priv->mutex);
	return rolloverInternal(p);
}",1,,203,2,,void
36758,BLOCK,1,,<empty>,,,,1,,void
36774,BLOCK,-1,,"{
	//
	//   can't roll without a policy
	//
	if (_priv->rollingPolicy != NULL)
	{

		{
			LogString fileName(getFile());
			RollingPolicyBasePtr basePolicy = LOG4CXX_NS::cast<RollingPolicyBase>(_priv->rollingPolicy);
			apr_time_t n = apr_time_now();
			ObjectPtr obj = std::make_shared<Date>(n);
			LogString fileNamePattern;

			if (basePolicy)
			{
				if (basePolicy->getPatternConverterList().size())
				{
					(*(basePolicy->getPatternConverterList().begin()))->format(obj, fileNamePattern, p);
					fileName = std::string(fileNamePattern);
				}
			}

			bool bAlreadyRolled = true;
			char szDirName[MAX_FILE_LEN] = {'\0'};
			char szBaseName[MAX_FILE_LEN] = {'\0'};
			char szUid[MAX_FILE_LEN] = {'\0'};
			memcpy(szDirName, fileName.c_str(), fileName.size() > MAX_FILE_LEN ? MAX_FILE_LEN : fileName.size());
			memcpy(szBaseName, fileName.c_str(), fileName.size() > MAX_FILE_LEN ? MAX_FILE_LEN : fileName.size());
			apr_uid_t uid;
			apr_gid_t groupid;
			apr_status_t stat = apr_uid_c...",1,,209,2,,void
36778,BLOCK,1,,<empty>,,,,1,,void
36788,BLOCK,-1,,"{

		{
			LogString fileName(getFile());
			RollingPolicyBasePtr basePolicy = LOG4CXX_NS::cast<RollingPolicyBase>(_priv->rollingPolicy);
			apr_time_t n = apr_time_now();
			ObjectPtr obj = std::make_shared<Date>(n);
			LogString fileNamePattern;

			if (basePolicy)
			{
				if (basePolicy->getPatternConverterList().size())
				{
					(*(basePolicy->getPatternConverterList().begin()))->format(obj, fileNamePattern, p);
					fileName = std::string(fileNamePattern);
				}
			}

			bool bAlreadyRolled = true;
			char szDirName[MAX_FILE_LEN] = {'\0'};
			char szBaseName[MAX_FILE_LEN] = {'\0'};
			char szUid[MAX_FILE_LEN] = {'\0'};
			memcpy(szDirName, fileName.c_str(), fileName.size() > MAX_FILE_LEN ? MAX_FILE_LEN : fileName.size());
			memcpy(szBaseName, fileName.c_str(), fileName.size() > MAX_FILE_LEN ? MAX_FILE_LEN : fileName.size());
			apr_uid_t uid;
			apr_gid_t groupid;
			apr_status_t stat = apr_uid_current(&uid, &groupid, p.getAPRPool());

			if (stat == APR_SUCCESS)
			{
#ifdef...",2,,214,2,,void
36789,BLOCK,1,,"{
			LogString fileName(getFile());
			RollingPolicyBasePtr basePolicy = LOG4CXX_NS::cast<RollingPolicyBase>(_priv->rollingPolicy);
			apr_time_t n = apr_time_now();
			ObjectPtr obj = std::make_shared<Date>(n);
			LogString fileNamePattern;

			if (basePolicy)
			{
				if (basePolicy->getPatternConverterList().size())
				{
					(*(basePolicy->getPatternConverterList().begin()))->format(obj, fileNamePattern, p);
					fileName = std::string(fileNamePattern);
				}
			}

			bool bAlreadyRolled = true;
			char szDirName[MAX_FILE_LEN] = {'\0'};
			char szBaseName[MAX_FILE_LEN] = {'\0'};
			char szUid[MAX_FILE_LEN] = {'\0'};
			memcpy(szDirName, fileName.c_str(), fileName.size() > MAX_FILE_LEN ? MAX_FILE_LEN : fileName.size());
			memcpy(szBaseName, fileName.c_str(), fileName.size() > MAX_FILE_LEN ? MAX_FILE_LEN : fileName.size());
			apr_uid_t uid;
			apr_gid_t groupid;
			apr_status_t stat = apr_uid_current(&uid, &groupid, p.getAPRPool());

			if (stat == APR_SUCCESS)
			{
#ifdef WIN3...",3,,216,1,,void
36803,BLOCK,1,,<empty>,,,,1,,void
36829,BLOCK,-1,,"{
				if (basePolicy->getPatternConverterList().size())
				{
					(*(basePolicy->getPatternConverterList().begin()))->format(obj, fileNamePattern, p);
					fileName = std::string(fileNamePattern);
				}
			}",4,,224,2,,void
36838,BLOCK,-1,,"{
					(*(basePolicy->getPatternConverterList().begin()))->format(obj, fileNamePattern, p);
					fileName = std::string(fileNamePattern);
				}",5,,226,2,,void
36892,BLOCK,1,,<empty>,,,,1,,void
36895,BLOCK,1,,<empty>,,,,1,,void
36914,BLOCK,1,,<empty>,,,,1,,void
36917,BLOCK,1,,<empty>,,,,1,,void
36941,BLOCK,-1,,"{
#ifdef WIN32
				snprintf(szUid, MAX_FILE_LEN, ""%p"", uid);
#else
				snprintf(szUid, MAX_FILE_LEN, ""%u"", (unsigned int)uid);
#endif
			}",4,,243,2,,void
36945,BLOCK,1,,<empty>,,,,1,,void
37001,BLOCK,-1,,"{
				LogString err = LOG4CXX_STR(""lockfile return error: open lockfile failed. "");
				err += (strerror(errno));
				LogLog::warn(err);
				bAlreadyRolled = false;
				lock_file = NULL;
			}",4,,257,2,,void
37023,BLOCK,-1,,"{
				stat = apr_file_lock(lock_file, APR_FLOCK_EXCLUSIVE);

				if (stat != APR_SUCCESS)
				{
					LogString err = LOG4CXX_STR(""apr_file_lock: lock failed. "");
					err += (strerror(errno));
					LogLog::warn(err);
					bAlreadyRolled = false;
				}
				else
				{
					if (_priv->_event)
					{
						_priv->triggeringPolicy->isTriggeringEvent(this, _priv->_event, getFile(), getFileLength());
					}
				}
			}",4,,265,1,,void
37033,BLOCK,-1,,"{
					LogString err = LOG4CXX_STR(""apr_file_lock: lock failed. "");
					err += (strerror(errno));
					LogLog::warn(err);
					bAlreadyRolled = false;
				}",5,,269,2,,void
37052,BLOCK,-1,,"{
					if (_priv->_event)
					{
						_priv->triggeringPolicy->isTriggeringEvent(this, _priv->_event, getFile(), getFileLength());
					}
				}",5,,276,1,,void
37055,BLOCK,1,,<empty>,,,,1,,void
37064,BLOCK,-1,,"{
						_priv->triggeringPolicy->isTriggeringEvent(this, _priv->_event, getFile(), getFileLength());
					}",6,,278,2,,void
37066,BLOCK,1,,<empty>,,,,1,,void
37091,BLOCK,-1,,"{
				apr_finfo_t finfo1, finfo2;
				apr_status_t st1, st2;
				const WriterPtr writer = getWriter();
				const FileOutputStreamPtr fos = LOG4CXX_NS::cast<FileOutputStream>( writer );
				if( !fos ){
					LogLog::error( LOG4CXX_STR(""Can't cast writer to FileOutputStream"") );
					return false;
				}
				apr_file_t* _fd = fos->getFilePtr();
				st1 = apr_file_info_get(&finfo1, APR_FINFO_IDENT, _fd);

				if (st1 != APR_SUCCESS)
				{
					LogLog::warn(LOG4CXX_STR(""apr_file_info_get failed""));
				}

				LogString fname = getFile();
				st2 = apr_stat(&finfo2, fname.c_str(), APR_FINFO_IDENT, p.getAPRPool());

				if (st2 != APR_SUCCESS)
				{
					LogLog::warn(LOG4CXX_STR(""apr_stat failed.""));
				}

				bAlreadyRolled = ((st1 == APR_SUCCESS) && (st2 == APR_SUCCESS)
						&& ((finfo1.device != finfo2.device) || (finfo1.inode != finfo2.inode)));
			}",4,,285,2,,void
37113,BLOCK,-1,,"{
					LogLog::error( LOG4CXX_STR(""Can't cast writer to FileOutputStream"") );
					return false;
				}",15,,290,2,,void
37140,BLOCK,-1,,"{
					LogLog::warn(LOG4CXX_STR(""apr_file_info_get failed""));
				}",5,,298,2,,void
37169,BLOCK,-1,,"{
					LogLog::warn(LOG4CXX_STR(""apr_stat failed.""));
				}",5,,306,2,,void
37204,BLOCK,-1,,"{

				try
				{
					RolloverDescriptionPtr rollover1(_priv->rollingPolicy->rollover(this->getFile(), this->getAppend(), p));

					if (rollover1 != NULL)
					{
						if (rollover1->getActiveFileName() == getFile())
						{
							closeWriter();

							bool success = true;

							if (rollover1->getSynchronous() != NULL)
							{
								success = false;

								try
								{
									success = rollover1->getSynchronous()->execute(p);
								}
								catch (std::exception& ex)
								{
									LogLog::warn(LOG4CXX_STR(""Exception on rollover""));
									LogString exmsg;
									LOG4CXX_NS::helpers::Transcoder::decode(ex.what(), exmsg);
									_priv->errorHandler->error(exmsg, ex, 0);
								}
							}

							if (success)
							{
								if (rollover1->getAppend())
								{
									_priv->fileLength = File().setPath(rollover1->getActiveFileName()).length(p);
								}
								else
								{
									_priv->fileLength = 0;
								}

								//
								//  async action...",4,,315,2,,void
37206,BLOCK,-1,,"{
					RolloverDescriptionPtr rollover1(_priv->rollingPolicy->rollover(this->getFile(), this->getAppend(), p));

					if (rollover1 != NULL)
					{
						if (rollover1->getActiveFileName() == getFile())
						{
							closeWriter();

							bool success = true;

							if (rollover1->getSynchronous() != NULL)
							{
								success = false;

								try
								{
									success = rollover1->getSynchronous()->execute(p);
								}
								catch (std::exception& ex)
								{
									LogLog::warn(LOG4CXX_STR(""Exception on rollover""));
									LogString exmsg;
									LOG4CXX_NS::helpers::Transcoder::decode(ex.what(), exmsg);
									_priv->errorHandler->error(exmsg, ex, 0);
								}
							}

							if (success)
							{
								if (rollover1->getAppend())
								{
									_priv->fileLength = File().setPath(rollover1->getActiveFileName()).length(p);
								}
								else
								{
									_priv->fileLength = 0;
								}

								//
								//  async action not yet implem...",5,,318,1,,void
37210,BLOCK,1,,<empty>,,,,1,,void
37235,BLOCK,-1,,"{
						if (rollover1->getActiveFileName() == getFile())
						{
							closeWriter();

							bool success = true;

							if (rollover1->getSynchronous() != NULL)
							{
								success = false;

								try
								{
									success = rollover1->getSynchronous()->execute(p);
								}
								catch (std::exception& ex)
								{
									LogLog::warn(LOG4CXX_STR(""Exception on rollover""));
									LogString exmsg;
									LOG4CXX_NS::helpers::Transcoder::decode(ex.what(), exmsg);
									_priv->errorHandler->error(exmsg, ex, 0);
								}
							}

							if (success)
							{
								if (rollover1->getAppend())
								{
									_priv->fileLength = File().setPath(rollover1->getActiveFileName()).length(p);
								}
								else
								{
									_priv->fileLength = 0;
								}

								//
								//  async action not yet implemented
								//
								ActionPtr asyncAction(rollover1->getAsynchronous());

								if (asyncAction != NULL)
								{
									asyncAction->ex...",6,,322,2,,void
37243,BLOCK,-1,,"{
							closeWriter();

							bool success = true;

							if (rollover1->getSynchronous() != NULL)
							{
								success = false;

								try
								{
									success = rollover1->getSynchronous()->execute(p);
								}
								catch (std::exception& ex)
								{
									LogLog::warn(LOG4CXX_STR(""Exception on rollover""));
									LogString exmsg;
									LOG4CXX_NS::helpers::Transcoder::decode(ex.what(), exmsg);
									_priv->errorHandler->error(exmsg, ex, 0);
								}
							}

							if (success)
							{
								if (rollover1->getAppend())
								{
									_priv->fileLength = File().setPath(rollover1->getActiveFileName()).length(p);
								}
								else
								{
									_priv->fileLength = 0;
								}

								//
								//  async action not yet implemented
								//
								ActionPtr asyncAction(rollover1->getAsynchronous());

								if (asyncAction != NULL)
								{
									asyncAction->execute(p);
								}

								setFileInternal(
									rollover...",7,,324,2,,void
37256,BLOCK,-1,,"{
								success = false;

								try
								{
									success = rollover1->getSynchronous()->execute(p);
								}
								catch (std::exception& ex)
								{
									LogLog::warn(LOG4CXX_STR(""Exception on rollover""));
									LogString exmsg;
									LOG4CXX_NS::helpers::Transcoder::decode(ex.what(), exmsg);
									_priv->errorHandler->error(exmsg, ex, 0);
								}
							}",8,,330,2,,void
37261,BLOCK,-1,,"{
									success = rollover1->getSynchronous()->execute(p);
								}",9,,334,1,,void
37272,BLOCK,2,,"{
									LogLog::warn(LOG4CXX_STR(""Exception on rollover""));
									LogString exmsg;
									LOG4CXX_NS::helpers::Transcoder::decode(ex.what(), exmsg);
									_priv->errorHandler->error(exmsg, ex, 0);
								}",9,,338,2,,void
37294,BLOCK,1,,<empty>,,,,2,,void
37311,BLOCK,-1,,"{
								if (rollover1->getAppend())
								{
									_priv->fileLength = File().setPath(rollover1->getActiveFileName()).length(p);
								}
								else
								{
									_priv->fileLength = 0;
								}

								//
								//  async action not yet implemented
								//
								ActionPtr asyncAction(rollover1->getAsynchronous());

								if (asyncAction != NULL)
								{
									asyncAction->execute(p);
								}

								setFileInternal(
									rollover1->getActiveFileName(), rollover1->getAppend(),
									_priv->bufferedIO, _priv->bufferSize, p);
							}",8,,347,2,,void
37317,BLOCK,-1,,"{
									_priv->fileLength = File().setPath(rollover1->getActiveFileName()).length(p);
								}",9,,349,2,,void
37319,BLOCK,1,,<empty>,,,,2,,void
37322,BLOCK,1,,<empty>,,,,1,,void
37344,BLOCK,-1,,"{
									_priv->fileLength = 0;
								}",9,,353,1,,void
37347,BLOCK,1,,<empty>,,,,1,,void
37367,BLOCK,-1,,"{
									asyncAction->execute(p);
								}",9,,363,2,,void
37383,BLOCK,1,,<empty>,,,,1,,void
37393,BLOCK,1,,<empty>,,,,1,,void
37404,BLOCK,-1,,"{
								setFileInternal(
									rollover1->getActiveFileName(), true, _priv->bufferedIO, _priv->bufferSize, p);
							}",8,,372,1,,void
37412,BLOCK,1,,<empty>,,,,1,,void
37422,BLOCK,1,,<empty>,,,,1,,void
37433,BLOCK,-1,,"{
							closeWriter();
							setFileInternal(rollover1->getActiveFileName());
							// Call activateOptions to create any intermediate directories(if required)
							FileAppender::activateOptionsInternal(p);
							OutputStreamPtr os(new FileOutputStream(
									rollover1->getActiveFileName(), rollover1->getAppend()));
							WriterPtr newWriter(createWriter(os));
							setWriterInternal(newWriter);

							bool success = true;

							if (rollover1->getSynchronous() != NULL)
							{
								success = false;

								try
								{
									success = rollover1->getSynchronous()->execute(p);
								}
								catch (std::exception& ex)
								{
									LogLog::warn(LOG4CXX_STR(""Exception during rollover""));
									LogString exmsg;
									LOG4CXX_NS::helpers::Transcoder::decode(ex.what(), exmsg);
									_priv->errorHandler->error(exmsg, ex, 0);
								}
							}

							if (success)
							{
								if (rollover1->getAppend())
								{
									_priv->fileLength = Fil...",7,,378,1,,void
37474,BLOCK,-1,,"{
								success = false;

								try
								{
									success = rollover1->getSynchronous()->execute(p);
								}
								catch (std::exception& ex)
								{
									LogLog::warn(LOG4CXX_STR(""Exception during rollover""));
									LogString exmsg;
									LOG4CXX_NS::helpers::Transcoder::decode(ex.what(), exmsg);
									_priv->errorHandler->error(exmsg, ex, 0);
								}
							}",8,,391,2,,void
37479,BLOCK,-1,,"{
									success = rollover1->getSynchronous()->execute(p);
								}",9,,395,1,,void
37490,BLOCK,2,,"{
									LogLog::warn(LOG4CXX_STR(""Exception during rollover""));
									LogString exmsg;
									LOG4CXX_NS::helpers::Transcoder::decode(ex.what(), exmsg);
									_priv->errorHandler->error(exmsg, ex, 0);
								}",9,,399,2,,void
37512,BLOCK,1,,<empty>,,,,2,,void
37529,BLOCK,-1,,"{
								if (rollover1->getAppend())
								{
									_priv->fileLength = File().setPath(rollover1->getActiveFileName()).length(p);
								}
								else
								{
									_priv->fileLength = 0;
								}

								//
								//   async action not yet implemented
								//
								ActionPtr asyncAction(rollover1->getAsynchronous());

								if (asyncAction != NULL)
								{
									asyncAction->execute(p);
								}
							}",8,,408,2,,void
37535,BLOCK,-1,,"{
									_priv->fileLength = File().setPath(rollover1->getActiveFileName()).length(p);
								}",9,,410,2,,void
37538,BLOCK,1,,<empty>,,,,1,,void
37560,BLOCK,-1,,"{
									_priv->fileLength = 0;
								}",9,,414,1,,void
37563,BLOCK,1,,<empty>,,,,1,,void
37583,BLOCK,-1,,"{
									asyncAction->execute(p);
								}",9,,424,2,,void
37595,BLOCK,2,,"{
					LogLog::warn(LOG4CXX_STR(""Exception during rollover""));
					LogString exmsg;
					LOG4CXX_NS::helpers::Transcoder::decode(ex.what(), exmsg);
					_priv->errorHandler->error(exmsg, ex, 0);
				}",5,,437,2,,void
37617,BLOCK,1,,<empty>,,,,2,,void
37633,BLOCK,-1,,"{
				reopenLatestFile(p);
			}",4,,446,1,,void
37644,BLOCK,-1,,"{
	closeWriter();
	OutputStreamPtr os = std::make_shared<FileOutputStream>(getFile(), true);
	WriterPtr newWriter(createWriter(os));
	setFile(getFile());
	setWriter(newWriter);
	_priv->fileLength = File().setPath(getFile()).length(p);
	writeHeader(p);
}",1,,461,2,,void
37668,BLOCK,1,,<empty>,,,,1,,void
37693,BLOCK,-1,,"{
	// The rollover check must precede actual writing. This is the
	// only correct behavior for time driven triggers.
	if (
		_priv->triggeringPolicy->isTriggeringEvent(
			this, event, getFile(), getFileLength()))
	{
		//
		//   wrap rollover request in try block since
		//    rollover may fail in case read access to directory
		//    is not provided.  However appender should still be in good
		//     condition and the append should still happen.
		try
		{
			_priv->_event = event;
			rolloverInternal(p);
		}
		catch (std::exception& ex)
		{
			LogLog::warn(LOG4CXX_STR(""Exception during rollover attempt.""));
			LogString exmsg;
			LOG4CXX_NS::helpers::Transcoder::decode(ex.what(), exmsg);
			_priv->errorHandler->error(exmsg);
		}
	}

	//do re-check before every write
	//
	apr_finfo_t finfo1, finfo2;
	apr_status_t st1, st2;
	const WriterPtr writer = getWriter();
	const FileOutputStreamPtr fos = LOG4CXX_NS::cast<FileOutputStream>( writer );
	if( !fos ){
		LogLog::error( LOG4CXX_STR(""...",1,,476,3,,void
37696,BLOCK,1,,<empty>,,,,1,,void
37712,BLOCK,-1,,"{
		//
		//   wrap rollover request in try block since
		//    rollover may fail in case read access to directory
		//    is not provided.  However appender should still be in good
		//     condition and the append should still happen.
		try
		{
			_priv->_event = event;
			rolloverInternal(p);
		}
		catch (std::exception& ex)
		{
			LogLog::warn(LOG4CXX_STR(""Exception during rollover attempt.""));
			LogString exmsg;
			LOG4CXX_NS::helpers::Transcoder::decode(ex.what(), exmsg);
			_priv->errorHandler->error(exmsg);
		}
	}",2,,482,2,,void
37714,BLOCK,-1,,"{
			_priv->_event = event;
			rolloverInternal(p);
		}",3,,489,1,,void
37717,BLOCK,1,,<empty>,,,,1,,void
37729,BLOCK,2,,"{
			LogLog::warn(LOG4CXX_STR(""Exception during rollover attempt.""));
			LogString exmsg;
			LOG4CXX_NS::helpers::Transcoder::decode(ex.what(), exmsg);
			_priv->errorHandler->error(exmsg);
		}",3,,494,2,,void
37751,BLOCK,1,,<empty>,,,,2,,void
37785,BLOCK,-1,,"{
		LogLog::error( LOG4CXX_STR(""Can't cast writer to FileOutputStream"") );
		return;
	}",12,,508,2,,void
37811,BLOCK,-1,,"{
		LogLog::warn(LOG4CXX_STR(""apr_file_info_get failed""));
	}",2,,516,2,,void
37840,BLOCK,-1,,"{
		LogString err = ""apr_stat failed. file:"" + getFile();
		LogLog::warn(err);
	}",2,,523,2,,void
37880,BLOCK,-1,,"{
		reopenLatestFile(p);
	}",2,,532,2,,void
37892,BLOCK,-1,,"{
	return _priv->rollingPolicy;
}",1,,544,1,,void
37895,BLOCK,1,,<empty>,,,,1,,void
37907,BLOCK,-1,,"{
	return _priv->triggeringPolicy;
}",1,,553,1,,void
37910,BLOCK,1,,<empty>,,,,1,,void
37923,BLOCK,-1,,"{
	_priv->rollingPolicy = policy;

	TimeBasedRollingPolicyPtr timeBased = LOG4CXX_NS::cast<TimeBasedRollingPolicy>(policy);
	if( timeBased ){
		timeBased->setMultiprocess(true);
	}
}",1,,562,2,,void
37926,BLOCK,1,,<empty>,,,,1,,void
37948,BLOCK,-1,,"{
		timeBased->setMultiprocess(true);
	}",17,,566,2,,void
37958,BLOCK,-1,,"{
	_priv->triggeringPolicy = policy;
}",1,,576,2,,void
37961,BLOCK,1,,<empty>,,,,1,,void
37974,BLOCK,-1,,"{
	FileAppender::close();
}",1,,584,1,,void
37989,BLOCK,-1,,"{
		}",3,,618,3,,void
37994,BLOCK,-1,,"{
			os->close(p);
			rfa = 0;
		}",3,,625,2,,void
38007,BLOCK,-1,,"{
			os->flush(p);
		}",3,,634,2,,void
38018,BLOCK,-1,,"{
			os->write(buf, p);

			if (rfa != 0)
			{
				rfa->setFileLength(File().setPath(rfa->getFile()).length(p));
			}
		}",3,,642,3,,void
38029,BLOCK,-1,,"{
				rfa->setFileLength(File().setPath(rfa->getFile()).length(p));
			}",4,,646,2,,void
38049,BLOCK,-1,,"{
			return *os;
		}",3,,652,1,,void
38057,BLOCK,-1,,"{
	OutputStreamPtr cos = std::make_shared<CountingOutputStream>(os, this);
	return FileAppender::createWriter(cos);
}",1,,669,2,,void
38080,BLOCK,-1,,"{
	return _priv->fileLength;
}",1,,679,1,,void
38083,BLOCK,1,,<empty>,,,,1,,void
38096,BLOCK,-1,,"{
	_priv->fileLength = length;
}",1,,684,2,,void
38099,BLOCK,1,,<empty>,,,,1,,void
38113,BLOCK,-1,,"{
	_priv->fileLength += increment;
}",1,,693,2,,void
38116,BLOCK,1,,<empty>,,,,1,,void
38142,BLOCK,-1,,<empty>,1,,1,1,,ANY
38146,BLOCK,-1,,"{
}",1,,31,1,,void
38150,BLOCK,-1,,"{
}",1,,35,1,,void
38162,BLOCK,-1,,"{
		}",3,,65,3,,void
38173,BLOCK,-1,,"{
			// We substract 1 from 'len' when assigning to 'end' to avoid out of
			// bounds exception in return r.substring(end+1, len). This can happen if
			// precision is 1 and the logger name ends with a dot.
			LogString::size_type end = buf.length() - 1;

			for (LogString::size_type i = count; i > 0; i--)
			{
				end = buf.rfind(0x2E /* '.' */, end - 1);

				if ((end == LogString::npos) || (end < nameStart))
				{
					return;
				}
			}

			buf.erase(buf.begin() + nameStart, buf.begin() + (end + 1));
		}",3,,100,3,,void
38184,BLOCK,-1,,<empty>,4,,106,1,,void
38194,BLOCK,4,,"{
				end = buf.rfind(0x2E /* '.' */, end - 1);

				if ((end == LogString::npos) || (end < nameStart))
				{
					return;
				}
			}",4,,107,4,,void
38215,BLOCK,-1,,"{
					return;
				}",5,,111,2,,void
38243,BLOCK,-1,,"{
		}",3,,147,3,,void
38247,BLOCK,-1,,"{
		}",3,,150,1,,void
38252,BLOCK,-1,,"{
		}",3,,155,2,,void
38257,BLOCK,-1,,"{
			charCount = src.charCount;
			ellipsis = src.ellipsis;
			return *this;
		}",3,,159,2,,void
38276,BLOCK,-1,,"{
			LogString::size_type nextDot = buf.find(0x2E /* '.' */, startPos);

			if (nextDot != LogString::npos)
			{
				if ((nextDot - startPos) > charCount)
				{
					buf.erase(buf.begin() + (startPos + charCount), buf.begin() + nextDot);
					nextDot = startPos + charCount;

					if (ellipsis != 0x00)
					{
						buf.insert(nextDot, 1, ellipsis);
						nextDot++;
					}
				}

				nextDot++;
			}

			return nextDot;
		}",3,,172,3,,void
38292,BLOCK,-1,,"{
				if ((nextDot - startPos) > charCount)
				{
					buf.erase(buf.begin() + (startPos + charCount), buf.begin() + nextDot);
					nextDot = startPos + charCount;

					if (ellipsis != 0x00)
					{
						buf.insert(nextDot, 1, ellipsis);
						nextDot++;
					}
				}

				nextDot++;
			}",4,,176,2,,void
38299,BLOCK,-1,,"{
					buf.erase(buf.begin() + (startPos + charCount), buf.begin() + nextDot);
					nextDot = startPos + charCount;

					if (ellipsis != 0x00)
					{
						buf.insert(nextDot, 1, ellipsis);
						nextDot++;
					}
				}",5,,178,2,,void
38327,BLOCK,-1,,"{
						buf.insert(nextDot, 1, ellipsis);
						nextDot++;
					}",6,,183,2,,void
38351,BLOCK,-1,,"{
			//
			//  all non-terminal patterns are executed once
			//
			LogString::size_type pos = nameStart;

			for (LogString::size_type i = 0; (i < (fragments.size() - 1)) && (pos < buf.length());
				i++)
			{
				pos = fragments[i].abbreviate(buf, pos);
			}

			//
			//   last pattern in executed repeatedly
			//
			PatternAbbreviatorFragment terminalFragment =
				fragments[fragments.size() - 1];

			while (pos < buf.length())
			{
				pos = terminalFragment.abbreviate(buf, pos);
			}
		}",3,,234,3,,void
38357,BLOCK,-1,,<empty>,4,,240,1,,void
38379,BLOCK,4,,"{
				pos = fragments[i].abbreviate(buf, pos);
			}",4,,242,4,,void
38408,BLOCK,-1,,"{
				pos = terminalFragment.abbreviate(buf, pos);
			}",4,,253,2,,void
38427,BLOCK,-1,,"{
	if (pattern.length() > 0)
	{
		//  if pattern is just spaces and numbers then
		//     use MaxElementAbbreviator
		LogString trimmed(StringHelper::trim(pattern));

		if (trimmed.length() == 0)
		{
			return getDefaultAbbreviator();
		}

		LogString::size_type i = 0;

		while (
			(i < trimmed.length()) && (trimmed[i] >= 0x30 /* '0' */)
			&& (trimmed[i] <= 0x39 /* '9' */))
		{
			i++;
		}

		//
		//  if all blanks and digits
		//
		if (i == trimmed.length())
		{
			return std::make_shared<MaxElementAbbreviator>(StringHelper::toInt(trimmed));
		}

		std::vector<PatternAbbreviatorFragment> fragments;
		logchar ellipsis;
		int charCount;
		LogString::size_type pos = 0;

		while (pos < trimmed.length())
		{
			LogString::size_type ellipsisPos = pos;

			if (trimmed[pos] == 0x2A /* '*' */)
			{
				charCount = INT_MAX;
				ellipsisPos++;
			}
			else
			{
				if ((trimmed[pos] >= 0x30 /* '0' */)
					&& (trimmed[pos] <= 0x39 /* '9' */))
				{
					charCount = trimmed[pos] - 0x30 /* '0...",1,,268,2,,void
38435,BLOCK,-1,,"{
		//  if pattern is just spaces and numbers then
		//     use MaxElementAbbreviator
		LogString trimmed(StringHelper::trim(pattern));

		if (trimmed.length() == 0)
		{
			return getDefaultAbbreviator();
		}

		LogString::size_type i = 0;

		while (
			(i < trimmed.length()) && (trimmed[i] >= 0x30 /* '0' */)
			&& (trimmed[i] <= 0x39 /* '9' */))
		{
			i++;
		}

		//
		//  if all blanks and digits
		//
		if (i == trimmed.length())
		{
			return std::make_shared<MaxElementAbbreviator>(StringHelper::toInt(trimmed));
		}

		std::vector<PatternAbbreviatorFragment> fragments;
		logchar ellipsis;
		int charCount;
		LogString::size_type pos = 0;

		while (pos < trimmed.length())
		{
			LogString::size_type ellipsisPos = pos;

			if (trimmed[pos] == 0x2A /* '*' */)
			{
				charCount = INT_MAX;
				ellipsisPos++;
			}
			else
			{
				if ((trimmed[pos] >= 0x30 /* '0' */)
					&& (trimmed[pos] <= 0x39 /* '9' */))
				{
					charCount = trimmed[pos] - 0x30 /* '0' */;
					ellipsisPos++;
				...",2,,270,2,,void
38450,BLOCK,-1,,"{
			return getDefaultAbbreviator();
		}",3,,276,2,,void
38476,BLOCK,-1,,"{
			i++;
		}",3,,285,2,,void
38486,BLOCK,-1,,"{
			return std::make_shared<MaxElementAbbreviator>(StringHelper::toInt(trimmed));
		}",3,,293,2,,void
38519,BLOCK,-1,,"{
			LogString::size_type ellipsisPos = pos;

			if (trimmed[pos] == 0x2A /* '*' */)
			{
				charCount = INT_MAX;
				ellipsisPos++;
			}
			else
			{
				if ((trimmed[pos] >= 0x30 /* '0' */)
					&& (trimmed[pos] <= 0x39 /* '9' */))
				{
					charCount = trimmed[pos] - 0x30 /* '0' */;
					ellipsisPos++;
				}
				else
				{
					charCount = 0;
				}
			}

			ellipsis = 0;

			if (ellipsisPos < trimmed.length())
			{
				ellipsis = trimmed[ellipsisPos];

				if (ellipsis == 0x2E /* '.' */)
				{
					ellipsis = 0;
				}
			}

			fragments.push_back(PatternAbbreviatorFragment(charCount, ellipsis));
			pos = trimmed.find(0x2E /* '.' */, pos);

			if (pos == LogString::npos)
			{
				break;
			}

			pos++;
		}",3,,303,2,,void
38530,BLOCK,-1,,"{
				charCount = INT_MAX;
				ellipsisPos++;
			}",4,,307,2,,void
38537,BLOCK,-1,,"{
				if ((trimmed[pos] >= 0x30 /* '0' */)
					&& (trimmed[pos] <= 0x39 /* '9' */))
				{
					charCount = trimmed[pos] - 0x30 /* '0' */;
					ellipsisPos++;
				}
				else
				{
					charCount = 0;
				}
			}",4,,312,1,,void
38550,BLOCK,-1,,"{
					charCount = trimmed[pos] - 0x30 /* '0' */;
					ellipsisPos++;
				}",5,,315,2,,void
38561,BLOCK,-1,,"{
					charCount = 0;
				}",5,,320,1,,void
38575,BLOCK,-1,,"{
				ellipsis = trimmed[ellipsisPos];

				if (ellipsis == 0x2E /* '.' */)
				{
					ellipsis = 0;
				}
			}",4,,328,2,,void
38585,BLOCK,-1,,"{
					ellipsis = 0;
				}",5,,332,2,,void
38610,BLOCK,-1,,"{
				break;
			}",4,,341,2,,void
38627,BLOCK,-1,,"{
	static WideLife<NameAbbreviatorPtr> def = std::make_shared<NOPAbbreviator>();
	return def;
}",1,,363,1,,void
38653,BLOCK,-1,,<empty>,1,,1,1,,ANY
38659,BLOCK,-1,,<empty>,23,,34,4,,void
38669,BLOCK,-1,,"{
}",1,,50,4,,void
38674,BLOCK,-1,,"{
	if (options.size() > 0)
	{
		return NameAbbreviator::getAbbreviator(options[0]);
	}

	return NameAbbreviator::getDefaultAbbreviator();
}",1,,55,2,,void
38682,BLOCK,-1,,"{
		return NameAbbreviator::getAbbreviator(options[0]);
	}",2,,57,2,,void
38701,BLOCK,-1,,"{
	priv->abbreviator->abbreviate(nameStart, buf);
}",1,,70,3,,void
38703,BLOCK,1,,<empty>,,,,1,,void
38729,BLOCK,-1,,<empty>,1,,1,1,,ANY
38732,BLOCK,-1,,"{
	push(message);
}",1,,26,2,,void
38738,BLOCK,-1,,"{
	pop();
}",1,,31,1,,void
38744,BLOCK,-1,,"{
	return ctx.first;
}",1,,37,2,,void
38753,BLOCK,-1,,"{
	return ctx.second;
}",1,,42,2,,void
38761,BLOCK,-1,,"{
	ThreadSpecificData* data = ThreadSpecificData::getCurrentData();

	if (data != 0)
	{
		Stack& stack = data->getStack();

		while (!stack.empty())
		{
			stack.pop();
		}

		data->recycle();
	}
}",1,,47,1,,void
38773,BLOCK,-1,,"{
		Stack& stack = data->getStack();

		while (!stack.empty())
		{
			stack.pop();
		}

		data->recycle();
	}",2,,51,2,,void
38787,BLOCK,-1,,"{
			stack.pop();
		}",3,,55,2,,void
38799,BLOCK,-1,,"{
	ThreadSpecificData* data = ThreadSpecificData::getCurrentData();

	if (data != 0)
	{
		Stack& stack = data->getStack();

		if (!stack.empty())
		{
			return new Stack(stack);
		}
	}

	return new Stack();
}",1,,64,1,,void
38811,BLOCK,-1,,"{
		Stack& stack = data->getStack();

		if (!stack.empty())
		{
			return new Stack(stack);
		}
	}",2,,68,2,,void
38825,BLOCK,-1,,"{
			return new Stack(stack);
		}",3,,72,2,,void
38837,BLOCK,-1,,"{
	if (stack != NULL)
	{
		ThreadSpecificData::inherit(*stack);
		delete stack;
	}
}",1,,81,2,,void
38842,BLOCK,-1,,"{
		ThreadSpecificData::inherit(*stack);
		delete stack;
	}",2,,83,2,,void
38855,BLOCK,-1,,"{
	ThreadSpecificData* data = ThreadSpecificData::getCurrentData();

	if (data != 0)
	{
		Stack& stack = data->getStack();

		if (!stack.empty())
		{
			dest.append(getFullMessage(stack.top()));
			return true;
		}

		data->recycle();
	}

	return false;
}",1,,91,2,,void
38867,BLOCK,-1,,"{
		Stack& stack = data->getStack();

		if (!stack.empty())
		{
			dest.append(getFullMessage(stack.top()));
			return true;
		}

		data->recycle();
	}",2,,95,2,,void
38881,BLOCK,-1,,"{
			dest.append(getFullMessage(stack.top()));
			return true;
		}",3,,99,2,,void
38902,BLOCK,-1,,"{
	int size = 0;
	ThreadSpecificData* data = ThreadSpecificData::getCurrentData();

	if (data != 0)
	{
		size = (int)data->getStack().size();

		if (size == 0)
		{
			data->recycle();
		}
	}

	return size;
}",1,,111,1,,void
38918,BLOCK,-1,,"{
		size = (int)data->getStack().size();

		if (size == 0)
		{
			data->recycle();
		}
	}",2,,116,2,,void
38934,BLOCK,-1,,"{
			data->recycle();
		}",3,,120,2,,void
38944,BLOCK,-1,,"{
	ThreadSpecificData* data = ThreadSpecificData::getCurrentData();

	if (data != 0)
	{
		Stack& stack = data->getStack();

		if (!stack.empty())
		{
			LogString value(getMessage(stack.top()));
			stack.pop();
			data->recycle();
			return value;
		}

		data->recycle();
	}

	return LogString();
}",1,,129,1,,void
38956,BLOCK,-1,,"{
		Stack& stack = data->getStack();

		if (!stack.empty())
		{
			LogString value(getMessage(stack.top()));
			stack.pop();
			data->recycle();
			return value;
		}

		data->recycle();
	}",2,,133,2,,void
38970,BLOCK,-1,,"{
			LogString value(getMessage(stack.top()));
			stack.pop();
			data->recycle();
			return value;
		}",3,,137,2,,void
38998,BLOCK,-1,,"{
	bool retval = false;
	ThreadSpecificData* data = ThreadSpecificData::getCurrentData();

	if (data != 0)
	{
		Stack& stack = data->getStack();

		if (!stack.empty())
		{
			Transcoder::encode(getMessage(stack.top()), dst);
			stack.pop();
			retval = true;
		}

		data->recycle();
	}

	return retval;
}",1,,151,2,,void
39014,BLOCK,-1,,"{
		Stack& stack = data->getStack();

		if (!stack.empty())
		{
			Transcoder::encode(getMessage(stack.top()), dst);
			stack.pop();
			retval = true;
		}

		data->recycle();
	}",2,,156,2,,void
39028,BLOCK,-1,,"{
			Transcoder::encode(getMessage(stack.top()), dst);
			stack.pop();
			retval = true;
		}",3,,160,2,,void
39055,BLOCK,-1,,"{
	ThreadSpecificData* data = ThreadSpecificData::getCurrentData();

	if (data != 0)
	{
		Stack& stack = data->getStack();

		if (!stack.empty())
		{
			return getMessage(stack.top());
		}

		data->recycle();
	}

	return LogString();
}",1,,173,1,,void
39067,BLOCK,-1,,"{
		Stack& stack = data->getStack();

		if (!stack.empty())
		{
			return getMessage(stack.top());
		}

		data->recycle();
	}",2,,177,2,,void
39081,BLOCK,-1,,"{
			return getMessage(stack.top());
		}",3,,181,2,,void
39098,BLOCK,-1,,"{
	ThreadSpecificData* data = ThreadSpecificData::getCurrentData();

	if (data != 0)
	{
		Stack& stack = data->getStack();

		if (!stack.empty())
		{
			Transcoder::encode(getMessage(stack.top()), dst);
			return true;
		}

		data->recycle();
	}

	return false;
}",1,,192,2,,void
39110,BLOCK,-1,,"{
		Stack& stack = data->getStack();

		if (!stack.empty())
		{
			Transcoder::encode(getMessage(stack.top()), dst);
			return true;
		}

		data->recycle();
	}",2,,196,2,,void
39124,BLOCK,-1,,"{
			Transcoder::encode(getMessage(stack.top()), dst);
			return true;
		}",3,,200,2,,void
39147,BLOCK,-1,,"{
	ThreadSpecificData::push(message);
}",1,,212,2,,void
39157,BLOCK,-1,,"{
	LOG4CXX_DECODE_CHAR(msg, message);
	pushLS(msg);
}",1,,217,2,,void
39165,BLOCK,-1,,"{
	clear();
}",1,,223,1,,void
39170,BLOCK,-1,,"{
	bool empty = true;
	ThreadSpecificData* data = ThreadSpecificData::getCurrentData();

	if (data != 0)
	{
		Stack& stack = data->getStack();
		empty = stack.empty();

		if (empty)
		{
			data->recycle();
		}
	}

	return empty;
}",1,,228,1,,void
39186,BLOCK,-1,,"{
		Stack& stack = data->getStack();
		empty = stack.empty();

		if (empty)
		{
			data->recycle();
		}
	}",2,,233,2,,void
39202,BLOCK,-1,,"{
			data->recycle();
		}",3,,238,2,,void
39223,BLOCK,-1,,<empty>,1,,1,1,,ANY
39227,BLOCK,-1,,"{
}",1,,33,1,,void
39232,BLOCK,-1,,"{
	static WideLife<PatternConverterPtr> def = std::make_shared<NDCPatternConverter>();
	return def;
}",1,,38,2,,void
39248,BLOCK,-1,,"{
	if (!event->getNDC(toAppendTo))
	{
		toAppendTo.append(LOG4CXX_STR(""null""));
	}
}",1,,47,4,,void
39256,BLOCK,-1,,"{
		toAppendTo.append(LOG4CXX_STR(""null""));
	}",2,,49,2,,void
39289,BLOCK,-1,,<empty>,1,,1,1,,ANY
39352,BLOCK,-1,,<empty>,1,,1,1,,ANY
39359,BLOCK,-1,,"{
}",1,,72,5,,void
39364,BLOCK,-1,,"{
}",1,,78,2,,void
39369,BLOCK,-1,,"{
}",1,,83,2,,void
39377,BLOCK,-1,,"{
	std::string strReturn(prolog);
	strReturn.append("" - "");
#if LOG4CXX_HAVE_ODBC
	SQLCHAR       SqlState[6];
	SQLCHAR       Msg[SQL_MAX_MESSAGE_LENGTH];
	SQLINTEGER    NativeError;
	SQLSMALLINT   i;
	SQLSMALLINT   MsgLen;
	SQLRETURN     rc2;

	// Get the status records.
	i = 1;

	while ((rc2 = SQLGetDiagRecA(fHandleType, hInput, i, SqlState, &NativeError,
					Msg, sizeof(Msg), &MsgLen)) != SQL_NO_DATA)
	{
		strReturn.append((char*) Msg);
		i++;
	}

#else
	strReturn.append(""log4cxx built without ODBC support"");
#endif

	return apr_pstrdup((apr_pool_t*) p.getAPRPool(), strReturn.c_str());
}",1,,88,5,,void
39408,BLOCK,-1,,"{
}",1,,140,1,,void
39412,BLOCK,-1,,"{
	finalize();
}",1,,144,1,,void
39417,BLOCK,-1,,"{
	PatternMap specs;
	if (specs.empty())
	{
		RULES_PUT(""logger"", LoggerPatternConverter);
		RULES_PUT(""class"", ClassNamePatternConverter);
		RULES_PUT(""time"", DatePatternConverter);
		RULES_PUT(""shortfilename"", ShortFileLocationPatternConverter);
		RULES_PUT(""fullfilename"", FileLocationPatternConverter);
		RULES_PUT(""location"", FullLocationPatternConverter);
		RULES_PUT(""line"", LineLocationPatternConverter);
		RULES_PUT(""message"", MessagePatternConverter);
		RULES_PUT(""method"", MethodLocationPatternConverter);
		RULES_PUT(""level"", LevelPatternConverter);
		RULES_PUT(""thread"", ThreadPatternConverter);
		RULES_PUT(""threadname"", ThreadUsernamePatternConverter);
		RULES_PUT(""mdc"", MDCPatternConverter);
		RULES_PUT(""ndc"", NDCPatternConverter);
	}
	return specs;
}",1,,152,1,,void
39424,BLOCK,-1,,"{
		RULES_PUT(""logger"", LoggerPatternConverter);
		RULES_PUT(""class"", ClassNamePatternConverter);
		RULES_PUT(""time"", DatePatternConverter);
		RULES_PUT(""shortfilename"", ShortFileLocationPatternConverter);
		RULES_PUT(""fullfilename"", FileLocationPatternConverter);
		RULES_PUT(""location"", FullLocationPatternConverter);
		RULES_PUT(""line"", LineLocationPatternConverter);
		RULES_PUT(""message"", MessagePatternConverter);
		RULES_PUT(""method"", MethodLocationPatternConverter);
		RULES_PUT(""level"", LevelPatternConverter);
		RULES_PUT(""thread"", ThreadPatternConverter);
		RULES_PUT(""threadname"", ThreadUsernamePatternConverter);
		RULES_PUT(""mdc"", MDCPatternConverter);
		RULES_PUT(""ndc"", NDCPatternConverter);
	}",2,,155,2,,void
39427,BLOCK,1,,<empty>,,,,3,,void
39444,BLOCK,1,,<empty>,,,,3,,void
39461,BLOCK,1,,<empty>,,,,3,,void
39478,BLOCK,1,,<empty>,,,,3,,void
39495,BLOCK,1,,<empty>,,,,3,,void
39512,BLOCK,1,,<empty>,,,,3,,void
39529,BLOCK,1,,<empty>,,,,3,,void
39546,BLOCK,1,,<empty>,,,,3,,void
39563,BLOCK,1,,<empty>,,,,3,,void
39580,BLOCK,1,,<empty>,,,,3,,void
39597,BLOCK,1,,<empty>,,,,3,,void
39614,BLOCK,1,,<empty>,,,,3,,void
39631,BLOCK,1,,<empty>,,,,3,,void
39648,BLOCK,1,,<empty>,,,,3,,void
39670,BLOCK,-1,,"{
	if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""BUFFERSIZE""), LOG4CXX_STR(""buffersize"")))
	{
		setBufferSize((size_t)OptionConverter::toInt(value, 1));
	}
	else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""PASSWORD""), LOG4CXX_STR(""password"")))
	{
		setPassword(value);
	}
	else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""SQL""), LOG4CXX_STR(""sql"")))
	{
		setSql(value);
	}
	else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""URL""), LOG4CXX_STR(""url""))
		|| StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""DSN""), LOG4CXX_STR(""dsn""))
		|| StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""CONNECTIONSTRING""), LOG4CXX_STR(""connectionstring""))  )
	{
		setURL(value);
	}
	else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""USER""), LOG4CXX_STR(""user"")))
	{
		setUser(value);
	}
	else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""COLUMNMAPPING""), LOG4CXX_STR(""columnmapping"")))
	{
		_priv->mappedName.push_back(value);
	}
	else
	{
		...",1,,175,3,,void
39681,BLOCK,-1,,"{
		setBufferSize((size_t)OptionConverter::toInt(value, 1));
	}",2,,177,2,,void
39692,BLOCK,-1,,<empty>,7,,180,1,,void
39703,BLOCK,-1,,"{
		setPassword(value);
	}",2,,181,2,,void
39707,BLOCK,-1,,<empty>,7,,184,1,,void
39718,BLOCK,-1,,"{
		setSql(value);
	}",2,,185,2,,void
39722,BLOCK,-1,,<empty>,7,,188,1,,void
39753,BLOCK,-1,,"{
		setURL(value);
	}",2,,191,2,,void
39757,BLOCK,-1,,<empty>,7,,194,1,,void
39768,BLOCK,-1,,"{
		setUser(value);
	}",2,,195,2,,void
39772,BLOCK,-1,,<empty>,7,,198,1,,void
39783,BLOCK,-1,,"{
		_priv->mappedName.push_back(value);
	}",2,,199,2,,void
39785,BLOCK,1,,<empty>,,,,1,,void
39799,BLOCK,-1,,"{
		AppenderSkeleton::setOption(option, value);
	}",2,,203,1,,void
39809,BLOCK,-1,,"{
	return false;
}",1,,211,1,,void
39816,BLOCK,-1,,"{
#if !LOG4CXX_HAVE_ODBC
	LogLog::error(LOG4CXX_STR(""Can not activate ODBCAppender unless compiled with ODBC support.""));
#else
	if (_priv->mappedName.empty())
	{
		LogLog::error(LOG4CXX_STR(""ODBCAppender column mappings not defined, logging events will not be inserted""));
	}
	auto specs = getFormatSpecifiers();
	for (auto& name : _priv->mappedName)
	{
		auto lowerName = StringHelper::toLowerCase(name);
		auto pItem = specs.find(lowerName);
		if (specs.end() == pItem)
		{
			if (lowerName.size() < 5
			 || lowerName.substr(0, 4) != LOG4CXX_STR(""mdc{""))
				LogLog::error(name + LOG4CXX_STR("" is not a supported ColumnMapping value""));
			else // A single MDC entry
			{
				auto index = lowerName.find(0x7D /* '}' */, 4);
				auto len = (lowerName.npos == index ? lowerName.size() : index) - 4;
				ODBCAppenderPriv::DataBinding paramData{ 0, 0, 0, 0, 0 };
				paramData.converter = std::make_shared<MDCPatternConverter>(lowerName.substr(4, len));
				_priv->parameterValue.push_back(paramDa...",1,,216,2,,void
39828,BLOCK,-1,,"{
#if LOG4CXX_HAVE_ODBC
	_priv->buffer.push_back(event);

	if (_priv->buffer.size() >= _priv->bufferSize)
	{
		flushBuffer(p);
	}

#endif
}",1,,258,3,,void
39834,BLOCK,-1,,"{
    return LogString();
}",1,,271,3,,void
39842,BLOCK,-1,,"{
}",1,,276,3,,void
39847,BLOCK,-1,,"{
}",1,,282,2,,void
39852,BLOCK,-1,,"{
#if LOG4CXX_HAVE_ODBC
	SQLRETURN ret;

	if (_priv->env == SQL_NULL_HENV)
	{
		ret = SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &_priv->env);

		if (ret < 0)
		{
			SQLException ex(SQL_HANDLE_ENV, _priv->env, ""Failed to allocate SQL handle"", p);
			_priv->env = SQL_NULL_HENV;
			throw ex;
		}

		ret = SQLSetEnvAttr(_priv->env, SQL_ATTR_ODBC_VERSION, (SQLPOINTER) SQL_OV_ODBC3, SQL_IS_INTEGER);

		if (ret < 0)
		{
			SQLException ex(SQL_HANDLE_ENV, _priv->env, ""Failed to set odbc version"", p);
			SQLFreeHandle(SQL_HANDLE_ENV, _priv->env);
			_priv->env = SQL_NULL_HENV;
			throw ex;
		}
	}

	if (_priv->connection == SQL_NULL_HDBC)
	{
		ret = SQLAllocHandle(SQL_HANDLE_DBC, _priv->env, &_priv->connection);

		if (ret < 0)
		{
			SQLException ex(SQL_HANDLE_DBC, _priv->connection, ""Failed to allocate sql handle"", p);
			_priv->connection = SQL_NULL_HDBC;
			throw ex;
		}

#if LOG4CXX_LOGCHAR_IS_WCHAR
		SQLWCHAR *wUser = nullptr, *wPwd = nullptr;
		if (!_priv->databaseUser.empty())
		...",1,,286,2,,void
39858,BLOCK,-1,,"{
	if (_priv->closed)
	{
		return;
	}

	Pool p;

	try
	{
		flushBuffer(p);
	}
	catch (SQLException& e)
	{
		_priv->errorHandler->error(LOG4CXX_STR(""Error closing connection""),
			e, ErrorCode::GENERIC_FAILURE);
	}

#if LOG4CXX_HAVE_ODBC

	if (_priv->connection != SQL_NULL_HDBC)
	{
		SQLDisconnect(_priv->connection);
		SQLFreeHandle(SQL_HANDLE_DBC, _priv->connection);
	}

	if (_priv->env != SQL_NULL_HENV)
	{
		SQLFreeHandle(SQL_HANDLE_ENV, _priv->env);
	}

#endif
	_priv->closed = true;
}",1,,376,1,,void
39861,BLOCK,1,,<empty>,,,,1,,void
39870,BLOCK,-1,,"{
		return;
	}",2,,378,2,,void
39874,BLOCK,-1,,"{
		flushBuffer(p);
	}",2,,385,1,,void
39877,BLOCK,2,,"{
		_priv->errorHandler->error(LOG4CXX_STR(""Error closing connection""),
			e, ErrorCode::GENERIC_FAILURE);
	}",2,,389,2,,void
39879,BLOCK,1,,<empty>,,,,1,,void
39899,BLOCK,1,,<empty>,,,,1,,void
39913,BLOCK,-1,,"{
	for (auto& logEvent : _priv->buffer)
	{
		if (_priv->parameterValue.empty())
			_priv->errorHandler->error(LOG4CXX_STR(""ODBCAppender column mappings not defined""));
#if LOG4CXX_HAVE_ODBC
		else try
		{
			if (0 == _priv->preparedStatement)
				_priv->setPreparedStatement(getConnection(p), p);
			_priv->setParameterValues(logEvent, p);
			auto ret = SQLExecute(_priv->preparedStatement);
			if (ret < 0)
			{
				throw SQLException(SQL_HANDLE_STMT, _priv->preparedStatement, ""Failed to execute prepared statement"", p);
			}
		}
		catch (SQLException& e)
		{
			_priv->errorHandler->error(LOG4CXX_STR(""Failed to execute sql""), e,
				ErrorCode::FLUSH_FAILURE);
		}
#endif
	}

	// clear the buffer of reported events
	_priv->buffer.clear();
}",1,,585,2,,void
39916,BLOCK,1,,<empty>,,,,1,,void
39926,BLOCK,-1,,"{
		if (_priv->parameterValue.empty())
			_priv->errorHandler->error(LOG4CXX_STR(""ODBCAppender column mappings not defined""));
#if LOG4CXX_HAVE_ODBC
		else try
		{
			if (0 == _priv->preparedStatement)
				_priv->setPreparedStatement(getConnection(p), p);
			_priv->setParameterValues(logEvent, p);
			auto ret = SQLExecute(_priv->preparedStatement);
			if (ret < 0)
			{
				throw SQLException(SQL_HANDLE_STMT, _priv->preparedStatement, ""Failed to execute prepared statement"", p);
			}
		}
		catch (SQLException& e)
		{
			_priv->errorHandler->error(LOG4CXX_STR(""Failed to execute sql""), e,
				ErrorCode::FLUSH_FAILURE);
		}
#endif
	}",2,,587,3,,void
39929,BLOCK,1,,<empty>,,,,1,,void
39941,BLOCK,-1,,<empty>,4,,589,2,,void
39943,BLOCK,1,,<empty>,,,,1,,void
39958,BLOCK,1,,<empty>,,,,1,,void
39974,BLOCK,-1,,"{
    _priv->sqlStatement = s;
}",1,,615,2,,void
39977,BLOCK,1,,<empty>,,,,1,,void
39993,BLOCK,-1,,"{
	//  worst case double number of characters from UTF-8 or wchar_t
	*dest = (unsigned short*)
		p.palloc((src.size() + 1) * 2 * sizeof(unsigned short));
	unsigned short* current = *dest;

	for (LogString::const_iterator i = src.begin();
		i != src.end();)
	{
		unsigned int sv = Transcoder::decode(src, i);

		if (sv < 0x10000)
		{
			*current++ = (unsigned short) sv;
		}
		else
		{
			unsigned char u = (unsigned char) (sv >> 16);
			unsigned char w = (unsigned char) (u - 1);
			unsigned short hs = (0xD800 + ((w & 0xF) << 6) + ((sv & 0xFFFF) >> 10));
			unsigned short ls = (0xDC00 + (sv & 0x3FF));
			*current++ = (unsigned short) hs;
			*current++ = (unsigned short) ls;
		}
	}

	*current = 0;
}",1,,628,4,,void
40020,BLOCK,-1,,<empty>,2,,634,1,,void
40034,BLOCK,4,,"{
		unsigned int sv = Transcoder::decode(src, i);

		if (sv < 0x10000)
		{
			*current++ = (unsigned short) sv;
		}
		else
		{
			unsigned char u = (unsigned char) (sv >> 16);
			unsigned char w = (unsigned char) (u - 1);
			unsigned short hs = (0xD800 + ((w & 0xF) << 6) + ((sv & 0xFFFF) >> 10));
			unsigned short ls = (0xDC00 + (sv & 0x3FF));
			*current++ = (unsigned short) hs;
			*current++ = (unsigned short) ls;
		}
	}",2,,636,4,,void
40048,BLOCK,-1,,"{
			*current++ = (unsigned short) sv;
		}",3,,640,2,,void
40057,BLOCK,-1,,"{
			unsigned char u = (unsigned char) (sv >> 16);
			unsigned char w = (unsigned char) (u - 1);
			unsigned short hs = (0xD800 + ((w & 0xF) << 6) + ((sv & 0xFFFF) >> 10));
			unsigned short ls = (0xDC00 + (sv & 0x3FF));
			*current++ = (unsigned short) hs;
			*current++ = (unsigned short) ls;
		}",3,,644,1,,void
40119,BLOCK,-1,,"{
	return _priv->sqlStatement;
}",1,,658,1,,void
40122,BLOCK,1,,<empty>,,,,1,,void
40135,BLOCK,-1,,"{
	_priv->databaseUser = user;
}",1,,663,2,,void
40138,BLOCK,1,,<empty>,,,,1,,void
40152,BLOCK,-1,,"{
	_priv->databaseURL = url;
}",1,,668,2,,void
40155,BLOCK,1,,<empty>,,,,1,,void
40169,BLOCK,-1,,"{
	_priv->databasePassword = password;
}",1,,673,2,,void
40172,BLOCK,1,,<empty>,,,,1,,void
40186,BLOCK,-1,,"{
	_priv->bufferSize = newBufferSize;
}",1,,678,2,,void
40189,BLOCK,1,,<empty>,,,,1,,void
40202,BLOCK,-1,,"{
	return _priv->databaseUser;
}",1,,683,1,,void
40205,BLOCK,1,,<empty>,,,,1,,void
40217,BLOCK,-1,,"{
	return _priv->databaseURL;
}",1,,688,1,,void
40220,BLOCK,1,,<empty>,,,,1,,void
40232,BLOCK,-1,,"{
	return _priv->databasePassword;
}",1,,693,1,,void
40235,BLOCK,1,,<empty>,,,,1,,void
40247,BLOCK,-1,,"{
	return _priv->bufferSize;
}",1,,698,1,,void
40250,BLOCK,1,,<empty>,,,,1,,void
40273,BLOCK,-1,,<empty>,1,,1,1,,ANY
40278,BLOCK,-1,,<empty>,18,,33,1,,void
40285,BLOCK,-1,,"{
}",1,,42,1,,void
40289,BLOCK,-1,,<empty>,46,,45,1,,void
40294,BLOCK,-1,,"{
}",1,,48,2,,void
40299,BLOCK,-1,,"{
}",1,,52,2,,void
40305,BLOCK,-1,,"{
}",1,,56,3,,void
40312,BLOCK,-1,,"{
	if (m_priv->firstTime)
	{
		LogLog::error(message, e);
		m_priv->firstTime = false;
	}
}",1,,61,4,,void
40317,BLOCK,-1,,"{
		LogLog::error(message, e);
		m_priv->firstTime = false;
	}",2,,63,2,,void
40336,BLOCK,-1,,"{
	error(message, e, errorCode);
}",1,,71,5,,void
40345,BLOCK,-1,,"{
	if (m_priv->firstTime)
	{
		LogLog::error(message);
		m_priv->firstTime = false;
	}
}",1,,77,2,,void
40350,BLOCK,-1,,"{
		LogLog::error(message);
		m_priv->firstTime = false;
	}",2,,79,2,,void
40365,BLOCK,-1,,"{
}",1,,87,2,,void
40370,BLOCK,-1,,"{
}",1,,92,2,,void
40425,BLOCK,-1,,<empty>,1,,1,1,,ANY
40432,BLOCK,-1,,"{
    }",5,,56,3,,void
40436,BLOCK,-1,,"{
        m_config->doConfigure(file(), LogManager::getLoggerRepository());
    }",5,,65,1,,void
40450,BLOCK,-1,,"{
	logchar c;
	LogString sbuf;

	LogString::const_iterator i = s.begin();

	while (i != s.end())
	{
		c = *i++;

		if (c == 0x5C /* '\\' */)
		{
			c =  *i++;

			switch (c)
			{
				case 0x6E: //'n'
					c = 0x0A;
					break;

				case 0x72: //'r'
					c = 0x0D;
					break;

				case 0x74: //'t'
					c = 0x09;
					break;

				case 0x66: //'f'
					c = 0x0C;
					break;

				default:
					break;
			}
		}

		sbuf.append(1, c);
	}

	return sbuf;
}",1,,78,2,,void
40467,BLOCK,-1,,"{
		c = *i++;

		if (c == 0x5C /* '\\' */)
		{
			c =  *i++;

			switch (c)
			{
				case 0x6E: //'n'
					c = 0x0A;
					break;

				case 0x72: //'r'
					c = 0x0D;
					break;

				case 0x74: //'t'
					c = 0x09;
					break;

				case 0x66: //'f'
					c = 0x0C;
					break;

				default:
					break;
			}
		}

		sbuf.append(1, c);
	}",2,,85,2,,void
40477,BLOCK,-1,,"{
			c =  *i++;

			switch (c)
			{
				case 0x6E: //'n'
					c = 0x0A;
					break;

				case 0x72: //'r'
					c = 0x0D;
					break;

				case 0x74: //'t'
					c = 0x09;
					break;

				case 0x66: //'f'
					c = 0x0C;
					break;

				default:
					break;
			}
		}",3,,89,2,,void
40485,BLOCK,-1,,"{
				case 0x6E: //'n'
					c = 0x0A;
					break;

				case 0x72: //'r'
					c = 0x0D;
					break;

				case 0x74: //'t'
					c = 0x09;
					break;

				case 0x66: //'f'
					c = 0x0C;
					break;

				default:
					break;
			}",4,,93,2,,void
40525,BLOCK,-1,,"{
	if (value.length() >= 4)
	{
		if (StringHelper::equalsIgnoreCase(value.substr(0, 4),
				LOG4CXX_STR(""TRUE""), LOG4CXX_STR(""true"")))
		{
			return true;
		}
	}

	if (dEfault && value.length() >= 5)
	{
		if (StringHelper::equalsIgnoreCase(value.substr(0, 5),
				LOG4CXX_STR(""FALSE""), LOG4CXX_STR(""false"")))
		{
			return false;
		}
	}

	return dEfault;
}",1,,123,3,,void
40533,BLOCK,-1,,"{
		if (StringHelper::equalsIgnoreCase(value.substr(0, 4),
				LOG4CXX_STR(""TRUE""), LOG4CXX_STR(""true"")))
		{
			return true;
		}
	}",2,,125,2,,void
40549,BLOCK,-1,,"{
			return true;
		}",3,,128,2,,void
40561,BLOCK,-1,,"{
		if (StringHelper::equalsIgnoreCase(value.substr(0, 5),
				LOG4CXX_STR(""FALSE""), LOG4CXX_STR(""false"")))
		{
			return false;
		}
	}",2,,134,2,,void
40577,BLOCK,-1,,"{
			return false;
		}",3,,137,2,,void
40587,BLOCK,-1,,"{
	LogString trimmed(StringHelper::trim(value));

	if (trimmed.empty())
	{
		return dEfault;
	}

	LOG4CXX_ENCODE_CHAR(cvalue, trimmed);

	return (int) atol(cvalue.c_str());
}",1,,146,3,,void
40600,BLOCK,-1,,"{
		return dEfault;
	}",2,,150,2,,void
40619,BLOCK,-1,,"{
	if (s.empty())
	{
		return dEfault;
	}

	size_t index = s.find_first_of(LOG4CXX_STR(""bB""));

	if (index != LogString::npos && index > 0)
	{
		long multiplier = 1;
		index--;

		if (s[index] == 0x6B /* 'k' */ || s[index] == 0x4B /* 'K' */)
		{
			multiplier = 1024;
		}
		else if (s[index] == 0x6D /* 'm' */ || s[index] == 0x4D /* 'M' */)
		{
			multiplier = 1024 * 1024;
		}
		else if (s[index] == 0x67 /* 'g'*/ || s[index] == 0x47 /* 'G' */)
		{
			multiplier = 1024 * 1024 * 1024;
		}

		return toInt(s.substr(0, index), 1) * multiplier;
	}

	return toInt(s, 1);
}",1,,160,3,,void
40625,BLOCK,-1,,"{
		return dEfault;
	}",2,,162,2,,void
40647,BLOCK,-1,,"{
		long multiplier = 1;
		index--;

		if (s[index] == 0x6B /* 'k' */ || s[index] == 0x4B /* 'K' */)
		{
			multiplier = 1024;
		}
		else if (s[index] == 0x6D /* 'm' */ || s[index] == 0x4D /* 'M' */)
		{
			multiplier = 1024 * 1024;
		}
		else if (s[index] == 0x67 /* 'g'*/ || s[index] == 0x47 /* 'G' */)
		{
			multiplier = 1024 * 1024 * 1024;
		}

		return toInt(s.substr(0, index), 1) * multiplier;
	}",2,,169,2,,void
40666,BLOCK,-1,,"{
			multiplier = 1024;
		}",3,,174,2,,void
40671,BLOCK,-1,,<empty>,8,,177,1,,void
40684,BLOCK,-1,,"{
			multiplier = 1024 * 1024;
		}",3,,178,2,,void
40691,BLOCK,-1,,<empty>,8,,181,1,,void
40704,BLOCK,-1,,"{
			multiplier = 1024 * 1024 * 1024;
		}",3,,182,2,,void
40732,BLOCK,-1,,"{
	LogString value(props.getProperty(key));

	if (value.empty())
	{
		return value;
	}

	try
	{
		return substVars(value, props);
	}
	catch (IllegalArgumentException& e)
	{
		LogLog::error(((LogString) LOG4CXX_STR(""Bad option value [""))
			+ value + LOG4CXX_STR(""].""), e);
		return value;
	}
}",1,,193,3,,void
40745,BLOCK,-1,,"{
		return value;
	}",2,,197,2,,void
40749,BLOCK,-1,,"{
		return substVars(value, props);
	}",2,,202,1,,void
40754,BLOCK,2,,"{
		LogLog::error(((LogString) LOG4CXX_STR(""Bad option value [""))
			+ value + LOG4CXX_STR(""].""), e);
		return value;
	}",2,,206,2,,void
40776,BLOCK,-1,,"{
	LogString sbuf;
	const logchar delimStartArray[] = { 0x24, 0x7B, 0 };
	const LogString delimStart(delimStartArray);
	const logchar delimStop = 0x7D; // '}';
	const size_t DELIM_START_LEN = 2;
	const size_t DELIM_STOP_LEN = 1;

	size_t i = 0;

	while (true)
	{
		size_t j = val.find(delimStart, i);

		if (j == val.npos)
		{
			// no more variables
			if (i == 0)
			{
				// this is a simple string
				return val;
			}
			else
			{
				// add the tail string which contails no variables and return the result.
				sbuf.append(val.substr(i, val.length() - i));
				return sbuf;
			}
		}
		else
		{
			sbuf.append(val.substr(i, j - i));
			size_t k = val.find(delimStop, j);

			if (k == val.npos)
			{
				LogString msg(1, (logchar) 0x22 /* '\""' */);
				msg.append(val);
				msg.append(LOG4CXX_STR(""\"" has no closing brace. Opening brace at position ""));
				Pool p;
				StringHelper::toString(j, p, msg);
				msg.append(1, (logchar) 0x2E /* '.' */);
				throw IllegalArgumentException(msg);
	...",1,,214,3,,void
40806,BLOCK,-1,,"{
		size_t j = val.find(delimStart, i);

		if (j == val.npos)
		{
			// no more variables
			if (i == 0)
			{
				// this is a simple string
				return val;
			}
			else
			{
				// add the tail string which contails no variables and return the result.
				sbuf.append(val.substr(i, val.length() - i));
				return sbuf;
			}
		}
		else
		{
			sbuf.append(val.substr(i, j - i));
			size_t k = val.find(delimStop, j);

			if (k == val.npos)
			{
				LogString msg(1, (logchar) 0x22 /* '\""' */);
				msg.append(val);
				msg.append(LOG4CXX_STR(""\"" has no closing brace. Opening brace at position ""));
				Pool p;
				StringHelper::toString(j, p, msg);
				msg.append(1, (logchar) 0x2E /* '.' */);
				throw IllegalArgumentException(msg);
			}
			else
			{
				j += DELIM_START_LEN;
				LogString key = val.substr(j, k - j);
				// first try in System properties
				LogString replacement(getSystemProperty(key, LogString()));

				// then try props parameter
				if (replacement.empty())
				{
					r...",2,,225,2,,void
40822,BLOCK,-1,,"{
			// no more variables
			if (i == 0)
			{
				// this is a simple string
				return val;
			}
			else
			{
				// add the tail string which contails no variables and return the result.
				sbuf.append(val.substr(i, val.length() - i));
				return sbuf;
			}
		}",3,,229,2,,void
40827,BLOCK,-1,,"{
				// this is a simple string
				return val;
			}",4,,232,2,,void
40831,BLOCK,-1,,"{
				// add the tail string which contails no variables and return the result.
				sbuf.append(val.substr(i, val.length() - i));
				return sbuf;
			}",4,,237,1,,void
40850,BLOCK,-1,,"{
			sbuf.append(val.substr(i, j - i));
			size_t k = val.find(delimStop, j);

			if (k == val.npos)
			{
				LogString msg(1, (logchar) 0x22 /* '\""' */);
				msg.append(val);
				msg.append(LOG4CXX_STR(""\"" has no closing brace. Opening brace at position ""));
				Pool p;
				StringHelper::toString(j, p, msg);
				msg.append(1, (logchar) 0x2E /* '.' */);
				throw IllegalArgumentException(msg);
			}
			else
			{
				j += DELIM_START_LEN;
				LogString key = val.substr(j, k - j);
				// first try in System properties
				LogString replacement(getSystemProperty(key, LogString()));

				// then try props parameter
				if (replacement.empty())
				{
					replacement = props.getProperty(key);
				}

				if (!replacement.empty())
				{
					// Do variable substitution on the replacement string
					// such that we can solve ""Hello ${x2}"" as ""Hello p1""
					// the where the properties are
					// x1=p1
					// x2=${x1}
					LogString recursiveReplacement = substVars(replacement, props);
			...",3,,244,1,,void
40878,BLOCK,-1,,"{
				LogString msg(1, (logchar) 0x22 /* '\""' */);
				msg.append(val);
				msg.append(LOG4CXX_STR(""\"" has no closing brace. Opening brace at position ""));
				Pool p;
				StringHelper::toString(j, p, msg);
				msg.append(1, (logchar) 0x2E /* '.' */);
				throw IllegalArgumentException(msg);
			}",4,,249,2,,void
40916,BLOCK,-1,,"{
				j += DELIM_START_LEN;
				LogString key = val.substr(j, k - j);
				// first try in System properties
				LogString replacement(getSystemProperty(key, LogString()));

				// then try props parameter
				if (replacement.empty())
				{
					replacement = props.getProperty(key);
				}

				if (!replacement.empty())
				{
					// Do variable substitution on the replacement string
					// such that we can solve ""Hello ${x2}"" as ""Hello p1""
					// the where the properties are
					// x1=p1
					// x2=${x1}
					LogString recursiveReplacement = substVars(replacement, props);
					sbuf.append(recursiveReplacement);
				}

				i = k + DELIM_STOP_LEN;
			}",4,,259,1,,void
40941,BLOCK,-1,,"{
					replacement = props.getProperty(key);
				}",5,,267,2,,void
40955,BLOCK,-1,,"{
					// Do variable substitution on the replacement string
					// such that we can solve ""Hello ${x2}"" as ""Hello p1""
					// the where the properties are
					// x1=p1
					// x2=${x1}
					LogString recursiveReplacement = substVars(replacement, props);
					sbuf.append(recursiveReplacement);
				}",5,,272,2,,void
40977,BLOCK,-1,,"{
	if (!key.empty())
	{
		LogString value(System::getProperty(key));

		if (!value.empty())
		{
			return value;
		}
	}

	return def;
}",1,,289,3,,void
40984,BLOCK,-1,,"{
		LogString value(System::getProperty(key));

		if (!value.empty())
		{
			return value;
		}
	}",2,,291,2,,void
40998,BLOCK,-1,,"{
			return value;
		}",3,,295,2,,void
41008,BLOCK,-1,,"{
	size_t hashIndex = value.find(LOG4CXX_STR(""#""));

	if (hashIndex == LogString::npos)
	{
		if (value.empty())
		{
			return defaultValue;
		}
		else
		{
			LogLog::debug(
				((LogString) LOG4CXX_STR(""OptionConverter::toLevel: no class name specified, level=[""))
				+ value
				+ LOG4CXX_STR(""]""));
			// no class name specified : use standard Level class
			return Level::toLevelLS(value, defaultValue);
		}
	}

	LogString clazz = value.substr(hashIndex + 1);
	LogString levelName = value.substr(0, hashIndex);
	LogLog::debug(((LogString) LOG4CXX_STR(""OptionConverter::toLevel: class=[""))
		+ clazz + LOG4CXX_STR(""], level=["") + levelName + LOG4CXX_STR(""]""));

	// This is degenerate case but you never know.
	if (levelName.empty())
	{
		return Level::toLevelLS(value, defaultValue);
	}

	try
	{
		Level::LevelClass& levelClass =
			(Level::LevelClass&)Loader::loadClass(clazz);
		return levelClass.toLevel(levelName);
	}
	catch (ClassNotFoundException&)
	{
		LogLog::warn(((LogString) LOG4CXX...",1,,305,3,,void
41024,BLOCK,-1,,"{
		if (value.empty())
		{
			return defaultValue;
		}
		else
		{
			LogLog::debug(
				((LogString) LOG4CXX_STR(""OptionConverter::toLevel: no class name specified, level=[""))
				+ value
				+ LOG4CXX_STR(""]""));
			// no class name specified : use standard Level class
			return Level::toLevelLS(value, defaultValue);
		}
	}",2,,309,2,,void
41030,BLOCK,-1,,"{
			return defaultValue;
		}",3,,311,2,,void
41034,BLOCK,-1,,"{
			LogLog::debug(
				((LogString) LOG4CXX_STR(""OptionConverter::toLevel: no class name specified, level=[""))
				+ value
				+ LOG4CXX_STR(""]""));
			// no class name specified : use standard Level class
			return Level::toLevelLS(value, defaultValue);
		}",3,,315,1,,void
41097,BLOCK,-1,,"{
		return Level::toLevelLS(value, defaultValue);
	}",2,,332,2,,void
41106,BLOCK,-1,,"{
		Level::LevelClass& levelClass =
			(Level::LevelClass&)Loader::loadClass(clazz);
		return levelClass.toLevel(levelName);
	}",2,,337,1,,void
41123,BLOCK,2,,"{
		LogLog::warn(((LogString) LOG4CXX_STR(""custom level class [""))
			+ clazz + LOG4CXX_STR(""] not found.""));
	}",2,,343,2,,void
41137,BLOCK,2,,"{
		LogLog::warn(
			LOG4CXX_STR(""class ["") + clazz + LOG4CXX_STR(""], level ["") + levelName +
			LOG4CXX_STR(""] conversion) failed.""), oops);
	}",2,,348,2,,void
41155,BLOCK,2,,"{
		LogLog::warn(
			LOG4CXX_STR(""class ["") + clazz + LOG4CXX_STR(""], level ["") + levelName +
			LOG4CXX_STR(""] conversion) failed.""));
	}",2,,354,2,,void
41181,BLOCK,-1,,"{
	// Get the value of the property in string form
	LogString className(findAndSubst(key, props));

	if (className.empty())
	{
		LogLog::error(
			((LogString) LOG4CXX_STR(""Could not find value for key "")) + key);
		return defaultValue;
	}

	// Trim className to avoid trailing spaces that cause problems.
	return OptionConverter::instantiateByClassName(
			StringHelper::trim(className), superClass, defaultValue);
}",1,,366,5,,void
41192,BLOCK,-1,,"{
		LogLog::error(
			((LogString) LOG4CXX_STR(""Could not find value for key "")) + key);
		return defaultValue;
	}",2,,371,2,,void
41223,BLOCK,-1,,"{
	if (!className.empty())
	{
		try
		{
			const Class& classObj = Loader::loadClass(className);
			ObjectPtr newObject =  ObjectPtr(classObj.newInstance());

			if (!newObject->instanceof(superClass))
			{
				return defaultValue;
			}

			return newObject;
		}
		catch (Exception& e)
		{
			LogLog::error(LOG4CXX_STR(""Could not instantiate class ["") +
				className + LOG4CXX_STR(""].""), e);
		}
	}

	return defaultValue;
}",1,,384,4,,void
41230,BLOCK,-1,,"{
		try
		{
			const Class& classObj = Loader::loadClass(className);
			ObjectPtr newObject =  ObjectPtr(classObj.newInstance());

			if (!newObject->instanceof(superClass))
			{
				return defaultValue;
			}

			return newObject;
		}
		catch (Exception& e)
		{
			LogLog::error(LOG4CXX_STR(""Could not instantiate class ["") +
				className + LOG4CXX_STR(""].""), e);
		}
	}",2,,386,2,,void
41232,BLOCK,-1,,"{
			const Class& classObj = Loader::loadClass(className);
			ObjectPtr newObject =  ObjectPtr(classObj.newInstance());

			if (!newObject->instanceof(superClass))
			{
				return defaultValue;
			}

			return newObject;
		}",3,,388,1,,void
41256,BLOCK,-1,,"{
				return defaultValue;
			}",4,,393,2,,void
41261,BLOCK,2,,"{
			LogLog::error(LOG4CXX_STR(""Could not instantiate class ["") +
				className + LOG4CXX_STR(""].""), e);
		}",3,,400,2,,void
41283,BLOCK,-1,,"{
	ConfiguratorPtr configurator;
	LogString clazz = _clazz;

	LogString filename(configFileName.getPath());

#if LOG4CXX_HAS_DOMCONFIGURATOR
	if (clazz.empty()
		&& filename.length() > 4
		&& StringHelper::equalsIgnoreCase(
			filename.substr(filename.length() - 4),
			LOG4CXX_STR("".XML""), LOG4CXX_STR("".xml"")))
	{
		clazz = LOG4CXX_NS::xml::DOMConfigurator::getStaticClass().toString();
	}
#endif

	if (!clazz.empty())
	{
		LogLog::debug(LOG4CXX_STR(""Preferred configurator class: "") + clazz);
		const Class& clazzObj = Loader::loadClass(clazz);
		ObjectPtr obj = ObjectPtr(clazzObj.newInstance());
		configurator = LOG4CXX_NS::cast<Configurator>(obj);

		if (configurator == 0)
		{
			LogLog::error(LOG4CXX_STR(""Could not instantiate configurator ["")
				+ clazz + LOG4CXX_STR(""].""));
			return;
		}
	}
	else
	{
		configurator = std::make_shared<PropertyConfigurator>();
	}

	if (0 < delay)
	{
		auto dog = new ConfiguratorWatchdog(configurator, configFileName);
		APRInitializer::registerClean...",1,,411,5,,void
41301,BLOCK,-1,,"{
		LogLog::debug(LOG4CXX_STR(""Preferred configurator class: "") + clazz);
		const Class& clazzObj = Loader::loadClass(clazz);
		ObjectPtr obj = ObjectPtr(clazzObj.newInstance());
		configurator = LOG4CXX_NS::cast<Configurator>(obj);

		if (configurator == 0)
		{
			LogLog::error(LOG4CXX_STR(""Could not instantiate configurator ["")
				+ clazz + LOG4CXX_STR(""].""));
			return;
		}
	}",2,,429,2,,void
41339,BLOCK,-1,,"{
			LogLog::error(LOG4CXX_STR(""Could not instantiate configurator ["")
				+ clazz + LOG4CXX_STR(""].""));
			return;
		}",3,,436,2,,void
41353,BLOCK,-1,,"{
		configurator = std::make_shared<PropertyConfigurator>();
	}",2,,443,1,,void
41364,BLOCK,-1,,"{
		auto dog = new ConfiguratorWatchdog(configurator, configFileName);
		APRInitializer::registerCleanup(dog);
		dog->setDelay(delay);
		dog->start();
	}",2,,448,2,,void
41387,BLOCK,-1,,<empty>,3,,455,1,,void
41408,BLOCK,-1,,<empty>,1,,1,1,,ANY
41419,BLOCK,-1,,<empty>,1,,1,1,,ANY
41423,BLOCK,-1,,"{
}",1,,28,1,,void
41427,BLOCK,-1,,"{
}",1,,32,1,,void
41446,BLOCK,-1,,<empty>,1,,1,1,,ANY
41452,BLOCK,-1,,<empty>,104,,31,2,,void
41458,BLOCK,-1,,<empty>,25,,35,3,,void
41465,BLOCK,-1,,"{
	if (out1 == 0)
	{
		throw NullPointerException(LOG4CXX_STR(""out parameter may not be null.""));
	}
}",1,,43,2,,void
41470,BLOCK,-1,,"{
		throw NullPointerException(LOG4CXX_STR(""out parameter may not be null.""));
	}",2,,45,2,,void
41480,BLOCK,-1,,"{
	if (out1 == 0)
	{
		throw NullPointerException(LOG4CXX_STR(""out parameter may not be null.""));
	}

	if (enc1 == 0)
	{
		throw NullPointerException(LOG4CXX_STR(""enc parameter may not be null.""));
	}
}",1,,53,3,,void
41485,BLOCK,-1,,"{
		throw NullPointerException(LOG4CXX_STR(""out parameter may not be null.""));
	}",2,,55,2,,void
41494,BLOCK,-1,,"{
		throw NullPointerException(LOG4CXX_STR(""enc parameter may not be null.""));
	}",2,,60,2,,void
41502,BLOCK,-1,,"{
}",1,,66,1,,void
41507,BLOCK,-1,,"{
	m_priv->out->close(p);
}",1,,70,2,,void
41519,BLOCK,-1,,"{
	m_priv->out->flush(p);
}",1,,75,2,,void
41532,BLOCK,-1,,"{
	if (str.empty())
		return;
	if (CharsetEncoder::isTriviallyCopyable(str, m_priv->enc))
	{
		ByteBuffer buf((char*)str.data(), str.size() * sizeof (logchar));
		m_priv->out->write(buf, p);
	}
	else
	{
		enum { BUFSIZE = 1024 };
		char stackData[BUFSIZE];
		char* rawbuf = stackData;
		size_t bufSize = BUFSIZE;
#ifdef LOG4CXX_MULTI_PROCESS
		std::vector<char> heapData;
		// Ensure the logging event is a single write system call to keep events from each process separate
		if (bufSize < str.length() * 2)
		{
			heapData.resize(bufSize = str.length() * 2);
			rawbuf = heapData.data();
		}
#endif
		ByteBuffer buf(rawbuf, bufSize);
		m_priv->enc->reset();
		LogString::const_iterator iter = str.begin();

		while (iter != str.end())
		{
			CharsetEncoder::encode(m_priv->enc, str, iter, buf);
			buf.flip();
			m_priv->out->write(buf, p);
			buf.clear();
		}

		CharsetEncoder::encode(m_priv->enc, str, iter, buf);
		m_priv->enc->flush(buf);
		buf.flip();
		m_priv->out->write(buf, p);
	}
}",1,,80,3,,void
41538,BLOCK,-1,,<empty>,3,,82,2,,void
41549,BLOCK,-1,,"{
		ByteBuffer buf((char*)str.data(), str.size() * sizeof (logchar));
		m_priv->out->write(buf, p);
	}",2,,84,2,,void
41574,BLOCK,-1,,"{
		enum { BUFSIZE = 1024 };
		char stackData[BUFSIZE];
		char* rawbuf = stackData;
		size_t bufSize = BUFSIZE;
#ifdef LOG4CXX_MULTI_PROCESS
		std::vector<char> heapData;
		// Ensure the logging event is a single write system call to keep events from each process separate
		if (bufSize < str.length() * 2)
		{
			heapData.resize(bufSize = str.length() * 2);
			rawbuf = heapData.data();
		}
#endif
		ByteBuffer buf(rawbuf, bufSize);
		m_priv->enc->reset();
		LogString::const_iterator iter = str.begin();

		while (iter != str.end())
		{
			CharsetEncoder::encode(m_priv->enc, str, iter, buf);
			buf.flip();
			m_priv->out->write(buf, p);
			buf.clear();
		}

		CharsetEncoder::encode(m_priv->enc, str, iter, buf);
		m_priv->enc->flush(buf);
		buf.flip();
		m_priv->out->write(buf, p);
	}",2,,89,1,,void
41608,BLOCK,-1,,"{
			CharsetEncoder::encode(m_priv->enc, str, iter, buf);
			buf.flip();
			m_priv->out->write(buf, p);
			buf.clear();
		}",3,,108,2,,void
41667,BLOCK,-1,,"{
	return m_priv->out;
}",1,,123,1,,void
41686,BLOCK,-1,,<empty>,1,,1,1,,ANY
41691,BLOCK,-1,,"{
}",1,,31,2,,void
41697,BLOCK,-1,,"{

}",1,,37,3,,void
41701,BLOCK,-1,,"{
}",1,,42,1,,void
41705,BLOCK,-1,,"{
	return m_priv->name;
}",1,,46,1,,void
41714,BLOCK,-1,,"{
	return m_priv->style;
}",1,,51,2,,void
41724,BLOCK,-1,,"{
	LOG4CXX_DECODE_CHAR(decoded, src);
	toAppendTo.append(decoded);
}",1,,56,3,,void
41803,BLOCK,-1,,<empty>,1,,1,1,,ANY
41806,BLOCK,-1,,<empty>,3,,62,1,,void
41811,BLOCK,-1,,<empty>,3,,66,2,,void
41825,BLOCK,-1,,<empty>,,,,1,,<empty>
41855,BLOCK,-1,,"{
}",1,,99,1,,void
41860,BLOCK,-1,,"{
	Pool pool;
	activateOptions(pool);
}",1,,107,2,,void
41867,BLOCK,-1,,<empty>,33,,112,1,,void
41872,BLOCK,-1,,"{
	m_priv->conversionPattern = pattern;
	Pool pool;
	activateOptions(pool);
}",1,,115,2,,void
41887,BLOCK,-1,,"{
	output.reserve(m_priv->expectedPatternLength + event->getMessage().size());
	std::vector<FormattingInfoPtr>::const_iterator formatterIter =
		m_priv->patternFields.begin();

	for (std::vector<LoggingEventPatternConverterPtr>::const_iterator
		converterIter = m_priv->patternConverters.begin();
		converterIter != m_priv->patternConverters.end();
		converterIter++, formatterIter++)
	{
		int startField = (int)output.length();
		(*converterIter)->format(event, output, pool);
		(*formatterIter)->format(startField, output);
	}

}",1,,124,4,,void
41913,BLOCK,-1,,<empty>,2,,129,1,,void
41936,BLOCK,4,,"{
		int startField = (int)output.length();
		(*converterIter)->format(event, output, pool);
		(*formatterIter)->format(startField, output);
	}",2,,133,4,,void
41966,BLOCK,-1,,"{
	if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""CONVERSIONPATTERN""),
			LOG4CXX_STR(""conversionpattern"")))
	{
		m_priv->conversionPattern = OptionConverter::convertSpecialChars(value);
	}else if(StringHelper::equalsIgnoreCase(option,
											LOG4CXX_STR(""ERRORCOLOR""),
											LOG4CXX_STR(""errorcolor""))){
		m_priv->m_errorColor = value;
		LogLog::debug(LOG4CXX_STR(""Setting error color to ""));
		LogLog::debug(value);
	}else if(StringHelper::equalsIgnoreCase(option,
											LOG4CXX_STR(""FATALCOLOR""),
											LOG4CXX_STR(""fatalcolor""))){
		m_priv->m_fatalColor = value;
	}else if(StringHelper::equalsIgnoreCase(option,
											LOG4CXX_STR(""WARNCOLOR""),
											LOG4CXX_STR(""warncolor""))){
		m_priv->m_warnColor = value;
	}else if(StringHelper::equalsIgnoreCase(option,
											LOG4CXX_STR(""INFOCOLOR""),
											LOG4CXX_STR(""infocolor""))){
		m_priv->m_infoColor = value;
	}else if(StringHelper::equalsIgnoreCase(option,
											LOG4CXX_STR(""DEBUGCOLOR""),
...",1,,142,3,,void
41977,BLOCK,-1,,"{
		m_priv->conversionPattern = OptionConverter::convertSpecialChars(value);
	}",2,,146,2,,void
41988,BLOCK,-1,,<empty>,8,,148,1,,void
41999,BLOCK,-1,,"{
		m_priv->m_errorColor = value;
		LogLog::debug(LOG4CXX_STR(""Setting error color to ""));
		LogLog::debug(value);
	}",39,,150,2,,void
42017,BLOCK,-1,,<empty>,8,,154,1,,void
42028,BLOCK,-1,,"{
		m_priv->m_fatalColor = value;
	}",39,,156,2,,void
42035,BLOCK,-1,,<empty>,8,,158,1,,void
42046,BLOCK,-1,,"{
		m_priv->m_warnColor = value;
	}",38,,160,2,,void
42053,BLOCK,-1,,<empty>,8,,162,1,,void
42064,BLOCK,-1,,"{
		m_priv->m_infoColor = value;
	}",38,,164,2,,void
42071,BLOCK,-1,,<empty>,8,,166,1,,void
42082,BLOCK,-1,,"{
		m_priv->m_debugColor = value;
	}",39,,168,2,,void
42089,BLOCK,-1,,<empty>,8,,170,1,,void
42100,BLOCK,-1,,"{
		m_priv->m_traceColor = value;
	}",39,,172,2,,void
42110,BLOCK,-1,,"{
	LogString pat(m_priv->conversionPattern);

	if (pat.empty())
	{
		pat = LOG4CXX_STR(""%m%n"");
	}

	m_priv->patternConverters.erase(m_priv->patternConverters.begin(), m_priv->patternConverters.end());
	m_priv->patternFields.erase(m_priv->patternFields.begin(), m_priv->patternFields.end());
	std::vector<PatternConverterPtr> converters;
	PatternParser::parse(pat,
		converters,
		m_priv->patternFields,
		getFormatSpecifiers());

	//
	//   strip out any pattern converters that don't handle LoggingEvents
	//
	//
	for (std::vector<PatternConverterPtr>::const_iterator converterIter = converters.begin();
		converterIter != converters.end();
		converterIter++)
	{
		LoggingEventPatternConverterPtr eventConverter =
			LOG4CXX_NS::cast<LoggingEventPatternConverter>(*converterIter);

		if (eventConverter != NULL)
		{
			m_priv->patternConverters.push_back(eventConverter);
		}
	}
	m_priv->expectedPatternLength = getFormattedEventCharacterCount() * 2;
}",1,,178,2,,void
42121,BLOCK,-1,,"{
		pat = LOG4CXX_STR(""%m%n"");
	}",2,,182,2,,void
42180,BLOCK,-1,,<empty>,2,,198,1,,void
42196,BLOCK,4,,"{
		LoggingEventPatternConverterPtr eventConverter =
			LOG4CXX_NS::cast<LoggingEventPatternConverter>(*converterIter);

		if (eventConverter != NULL)
		{
			m_priv->patternConverters.push_back(eventConverter);
		}
	}",2,,201,4,,void
42212,BLOCK,-1,,"{
			m_priv->patternConverters.push_back(eventConverter);
		}",3,,206,2,,void
42230,BLOCK,-1,,"{
	PatternMap specs;
	RULES_PUT(""c"", LoggerPatternConverter);
	RULES_PUT(""logger"", LoggerPatternConverter);

	RULES_PUT(""C"", ClassNamePatternConverter);
	RULES_PUT(""class"", ClassNamePatternConverter);

	specs.insert(PatternMap::value_type(LogString(LOG4CXX_STR(""Y"")), std::bind(&PatternLayout::createColorStartPatternConverter, this, std::placeholders::_1)));
	RULES_PUT(""y"", ColorEndPatternConverter);

	RULES_PUT(""d"", DatePatternConverter);
	RULES_PUT(""date"", DatePatternConverter);

	RULES_PUT(""f"", ShortFileLocationPatternConverter);

	RULES_PUT(""F"", FileLocationPatternConverter);
	RULES_PUT(""file"", FileLocationPatternConverter);

	RULES_PUT(""l"", FullLocationPatternConverter);

	RULES_PUT(""L"", LineLocationPatternConverter);
	RULES_PUT(""line"", LineLocationPatternConverter);

	RULES_PUT(""m"", MessagePatternConverter);
	RULES_PUT(""message"", MessagePatternConverter);

	RULES_PUT(""n"", LineSeparatorPatternConverter);

	RULES_PUT(""M"", MethodLocationPatternConverter);
	RULES_PUT(""method"", Meth...",1,,218,1,,void
42234,BLOCK,1,,<empty>,,,,3,,void
42251,BLOCK,1,,<empty>,,,,3,,void
42268,BLOCK,1,,<empty>,,,,3,,void
42285,BLOCK,1,,<empty>,,,,3,,void
42327,BLOCK,1,,<empty>,,,,3,,void
42344,BLOCK,1,,<empty>,,,,3,,void
42361,BLOCK,1,,<empty>,,,,3,,void
42378,BLOCK,1,,<empty>,,,,3,,void
42395,BLOCK,1,,<empty>,,,,3,,void
42412,BLOCK,1,,<empty>,,,,3,,void
42429,BLOCK,1,,<empty>,,,,3,,void
42446,BLOCK,1,,<empty>,,,,3,,void
42463,BLOCK,1,,<empty>,,,,3,,void
42480,BLOCK,1,,<empty>,,,,3,,void
42497,BLOCK,1,,<empty>,,,,3,,void
42514,BLOCK,1,,<empty>,,,,3,,void
42531,BLOCK,1,,<empty>,,,,3,,void
42548,BLOCK,1,,<empty>,,,,3,,void
42565,BLOCK,1,,<empty>,,,,3,,void
42582,BLOCK,1,,<empty>,,,,3,,void
42599,BLOCK,1,,<empty>,,,,3,,void
42616,BLOCK,1,,<empty>,,,,3,,void
42633,BLOCK,1,,<empty>,,,,3,,void
42650,BLOCK,1,,<empty>,,,,3,,void
42667,BLOCK,1,,<empty>,,,,3,,void
42684,BLOCK,1,,<empty>,,,,3,,void
42701,BLOCK,1,,<empty>,,,,3,,void
42718,BLOCK,1,,<empty>,,,,3,,void
42735,BLOCK,1,,<empty>,,,,3,,void
42752,BLOCK,1,,<empty>,,,,3,,void
42769,BLOCK,1,,<empty>,,,,3,,void
42786,BLOCK,1,,<empty>,,,,3,,void
42806,BLOCK,-1,,"{
	return m_priv->conversionPattern;
}",1,,274,1,,void
42815,BLOCK,-1,,"{
	std::shared_ptr<ColorStartPatternConverter> colorPatternConverter = std::make_shared<ColorStartPatternConverter>();

	colorPatternConverter->setErrorColor(m_priv->m_errorColor);
	colorPatternConverter->setFatalColor(m_priv->m_fatalColor);
	colorPatternConverter->setWarnColor(m_priv->m_warnColor);
	colorPatternConverter->setInfoColor(m_priv->m_infoColor);
	colorPatternConverter->setDebugColor(m_priv->m_debugColor);
	colorPatternConverter->setTraceColor(m_priv->m_traceColor);

	return colorPatternConverter;
}",116,,278,2,,void
42886,BLOCK,-1,,<empty>,1,,1,1,,ANY
42892,BLOCK,-1,,"{
}",1,,34,1,,void
42897,BLOCK,-1,,"{
	//
	//   greatly simplified version checks if
	//     character is USACII alpha or number
	//
	return (ch >= 0x41 /* 'A' */ && ch <= 0x5A /* 'Z' */) ||
		(ch >= 0x61 /* 'a' */ && ch <= 0x7A /* 'z' */) ||
		(ch >= 0x30 /* '0' */ && ch <= 0x39 /* '9' */);
}",1,,38,2,,void
42926,BLOCK,-1,,"{
	//
	//   greatly simplified version checks if
	//     character is USACII alpha or number
	//
	return isUnicodeIdentifierStart(ch)
		|| (ch == 0x5F /* '_' */);
}",1,,49,2,,void
42942,BLOCK,-1,,"{
	if (!convBuf.empty())
	{
		convBuf.erase(convBuf.begin(), convBuf.end());
	}

	// When this method is called, lastChar points to the first character of the
	// conversion word. For example:
	// For ""%hello""     lastChar = 'h'
	// For ""%-5hello""   lastChar = 'h'
	//System.out.println(""lastchar is ""+lastChar);
	if (!isUnicodeIdentifierStart(lastChar))
	{
		return i;
	}

	convBuf.append(1, lastChar);

	while (
		(i < pattern.length())
		&& isUnicodeIdentifierPart(pattern[i]))
	{
		convBuf.append(1, pattern[i]);
		currentLiteral.append(1, pattern[i]);

		//System.out.println(""conv buffer is now [""+convBuf+""]."");
		i++;
	}

	return i;
}",1,,62,6,,void
42949,BLOCK,-1,,"{
		convBuf.erase(convBuf.begin(), convBuf.end());
	}",2,,64,2,,void
42966,BLOCK,-1,,"{
		return i;
	}",2,,74,2,,void
42987,BLOCK,-1,,"{
		convBuf.append(1, pattern[i]);
		currentLiteral.append(1, pattern[i]);

		//System.out.println(""conv buffer is now [""+convBuf+""]."");
		i++;
	}",2,,83,2,,void
43014,BLOCK,-1,,"{
	while ((i < pattern.length()) && (pattern[i] == 0x7B /* '{' */))
	{
		size_t end = pattern.find(0x7D /* '}' */, i);

		if (end == pattern.npos)
		{
			break;
		}

		LogString r(pattern.substr(i + 1, end - i - 1));
		options.push_back(r);
		i = end + 1;
	}

	return i;
}",1,,97,4,,void
43028,BLOCK,-1,,"{
		size_t end = pattern.find(0x7D /* '}' */, i);

		if (end == pattern.npos)
		{
			break;
		}

		LogString r(pattern.substr(i + 1, end - i - 1));
		options.push_back(r);
		i = end + 1;
	}",2,,99,2,,void
43044,BLOCK,-1,,"{
			break;
		}",3,,103,2,,void
43079,BLOCK,-1,,"{

	LogString currentLiteral;

	size_t patternLength = pattern.length();
	int state = LITERAL_STATE;
	logchar c;
	size_t i = 0;
	FormattingInfoPtr formattingInfo(FormattingInfo::getDefault());

	while (i < patternLength)
	{
		c = pattern[i++];

		switch (state)
		{
			case LITERAL_STATE:

				// In literal state, the last char is always a literal.
				if (i == patternLength)
				{
					currentLiteral.append(1, c);

					continue;
				}

				if (c == ESCAPE_CHAR)
				{
					// peek at the next char.
					if (pattern[i] == ESCAPE_CHAR)
					{
						currentLiteral.append(1, c);
						i++; // move pointer
					}
					else
					{
						if (!currentLiteral.empty())
						{
							patternConverters.push_back(
								LiteralPatternConverter::newInstance(currentLiteral));
							formattingInfos.push_back(FormattingInfo::getDefault());
							currentLiteral.erase(currentLiteral.begin(), currentLiteral.end());
						}

						currentLiteral.append(1, c); // append %
						state = CONVERTER_STA...",1,,120,5,,void
43107,BLOCK,-1,,"{
		c = pattern[i++];

		switch (state)
		{
			case LITERAL_STATE:

				// In literal state, the last char is always a literal.
				if (i == patternLength)
				{
					currentLiteral.append(1, c);

					continue;
				}

				if (c == ESCAPE_CHAR)
				{
					// peek at the next char.
					if (pattern[i] == ESCAPE_CHAR)
					{
						currentLiteral.append(1, c);
						i++; // move pointer
					}
					else
					{
						if (!currentLiteral.empty())
						{
							patternConverters.push_back(
								LiteralPatternConverter::newInstance(currentLiteral));
							formattingInfos.push_back(FormattingInfo::getDefault());
							currentLiteral.erase(currentLiteral.begin(), currentLiteral.end());
						}

						currentLiteral.append(1, c); // append %
						state = CONVERTER_STATE;
						formattingInfo = FormattingInfo::getDefault();
					}
				}
				else
				{
					currentLiteral.append(1, c);
				}

				break;

			case CONVERTER_STATE:
				currentLiteral.append(1, c);

				switch (c)
				{
				...",2,,131,2,,void
43116,BLOCK,-1,,"{
			case LITERAL_STATE:

				// In literal state, the last char is always a literal.
				if (i == patternLength)
				{
					currentLiteral.append(1, c);

					continue;
				}

				if (c == ESCAPE_CHAR)
				{
					// peek at the next char.
					if (pattern[i] == ESCAPE_CHAR)
					{
						currentLiteral.append(1, c);
						i++; // move pointer
					}
					else
					{
						if (!currentLiteral.empty())
						{
							patternConverters.push_back(
								LiteralPatternConverter::newInstance(currentLiteral));
							formattingInfos.push_back(FormattingInfo::getDefault());
							currentLiteral.erase(currentLiteral.begin(), currentLiteral.end());
						}

						currentLiteral.append(1, c); // append %
						state = CONVERTER_STATE;
						formattingInfo = FormattingInfo::getDefault();
					}
				}
				else
				{
					currentLiteral.append(1, c);
				}

				break;

			case CONVERTER_STATE:
				currentLiteral.append(1, c);

				switch (c)
				{
					case 0x2D: // '-'
						formattingInfo = ...",3,,135,2,,void
43123,BLOCK,-1,,"{
					currentLiteral.append(1, c);

					continue;
				}",5,,140,2,,void
43135,BLOCK,-1,,"{
					// peek at the next char.
					if (pattern[i] == ESCAPE_CHAR)
					{
						currentLiteral.append(1, c);
						i++; // move pointer
					}
					else
					{
						if (!currentLiteral.empty())
						{
							patternConverters.push_back(
								LiteralPatternConverter::newInstance(currentLiteral));
							formattingInfos.push_back(FormattingInfo::getDefault());
							currentLiteral.erase(currentLiteral.begin(), currentLiteral.end());
						}

						currentLiteral.append(1, c); // append %
						state = CONVERTER_STATE;
						formattingInfo = FormattingInfo::getDefault();
					}
				}",5,,147,2,,void
43142,BLOCK,-1,,"{
						currentLiteral.append(1, c);
						i++; // move pointer
					}",6,,150,2,,void
43152,BLOCK,-1,,"{
						if (!currentLiteral.empty())
						{
							patternConverters.push_back(
								LiteralPatternConverter::newInstance(currentLiteral));
							formattingInfos.push_back(FormattingInfo::getDefault());
							currentLiteral.erase(currentLiteral.begin(), currentLiteral.end());
						}

						currentLiteral.append(1, c); // append %
						state = CONVERTER_STATE;
						formattingInfo = FormattingInfo::getDefault();
					}",6,,155,1,,void
43159,BLOCK,-1,,"{
							patternConverters.push_back(
								LiteralPatternConverter::newInstance(currentLiteral));
							formattingInfos.push_back(FormattingInfo::getDefault());
							currentLiteral.erase(currentLiteral.begin(), currentLiteral.end());
						}",7,,157,2,,void
43205,BLOCK,-1,,"{
					currentLiteral.append(1, c);
				}",5,,170,1,,void
43223,BLOCK,-1,,"{
					case 0x2D: // '-'
						formattingInfo = std::make_shared<FormattingInfo>(
									true, formattingInfo->getMinLength(),
									formattingInfo->getMaxLength());

						break;

					case 0x2E: // '.'
						state = DOT_STATE;

						break;

					default:

						if ((c >= 0x30 /* '0' */) && (c <= 0x39 /* '9' */))
						{
							formattingInfo = std::make_shared<FormattingInfo>(
										formattingInfo->isLeftAligned(), c - 0x30 /* '0' */,
										formattingInfo->getMaxLength());
							state = MIN_STATE;
						}
						else
						{
							i = finalizeConverter(
									c, pattern, i, currentLiteral, formattingInfo,
									rules, patternConverters, formattingInfos);

							// Next pattern is assumed to be a literal.
							state = LITERAL_STATE;
							formattingInfo = FormattingInfo::getDefault();

							if (!currentLiteral.empty())
							{
								currentLiteral.erase(currentLiteral.begin(), currentLiteral.end());
							}
						}
				}",5,,180,2,,void
43261,BLOCK,-1,,"{
							formattingInfo = std::make_shared<FormattingInfo>(
										formattingInfo->isLeftAligned(), c - 0x30 /* '0' */,
										formattingInfo->getMaxLength());
							state = MIN_STATE;
						}",7,,196,2,,void
43287,BLOCK,-1,,"{
							i = finalizeConverter(
									c, pattern, i, currentLiteral, formattingInfo,
									rules, patternConverters, formattingInfos);

							// Next pattern is assumed to be a literal.
							state = LITERAL_STATE;
							formattingInfo = FormattingInfo::getDefault();

							if (!currentLiteral.empty())
							{
								currentLiteral.erase(currentLiteral.begin(), currentLiteral.end());
							}
						}",7,,203,1,,void
43314,BLOCK,-1,,"{
								currentLiteral.erase(currentLiteral.begin(), currentLiteral.end());
							}",8,,213,2,,void
43344,BLOCK,-1,,"{
					formattingInfo = std::make_shared<FormattingInfo>(
								formattingInfo->isLeftAligned(),
								(formattingInfo->getMinLength() * 10) + (c - 0x30 /* '0' */),
								formattingInfo->getMaxLength());
				}",5,,225,2,,void
43374,BLOCK,-1,,<empty>,10,,231,1,,void
43379,BLOCK,-1,,"{
					state = DOT_STATE;
				}",5,,232,2,,void
43384,BLOCK,-1,,"{
					i = finalizeConverter(
							c, pattern, i, currentLiteral, formattingInfo,
							rules, patternConverters, formattingInfos);
					state = LITERAL_STATE;
					formattingInfo = FormattingInfo::getDefault();

					if (!currentLiteral.empty())
					{
						currentLiteral.erase(currentLiteral.begin(), currentLiteral.end());
					}
				}",5,,236,1,,void
43411,BLOCK,-1,,"{
						currentLiteral.erase(currentLiteral.begin(), currentLiteral.end());
					}",6,,244,2,,void
43441,BLOCK,-1,,"{
					formattingInfo = std::make_shared<FormattingInfo>(
								formattingInfo->isLeftAligned(), formattingInfo->getMinLength(),
								c - 0x30 /* '0' */);
					state = MAX_STATE;
				}",5,,255,2,,void
43467,BLOCK,-1,,"{
					LogLog::error(LOG4CXX_STR(""Error in pattern, was expecting digit.""));

					state = LITERAL_STATE;
				}",5,,262,1,,void
43494,BLOCK,-1,,"{
					formattingInfo = std::make_shared<FormattingInfo>(
								formattingInfo->isLeftAligned(), formattingInfo->getMinLength(),
								(formattingInfo->getMaxLength() * 10) + (c - 0x30 /* '0' */));
				}",5,,274,2,,void
43524,BLOCK,-1,,"{
					i = finalizeConverter(
							c, pattern, i, currentLiteral, formattingInfo,
							rules, patternConverters, formattingInfos);
					state = LITERAL_STATE;
					formattingInfo = FormattingInfo::getDefault();

					if (!currentLiteral.empty())
					{
						currentLiteral.erase(currentLiteral.begin(), currentLiteral.end());
					}
				}",5,,280,1,,void
43551,BLOCK,-1,,"{
						currentLiteral.erase(currentLiteral.begin(), currentLiteral.end());
					}",6,,288,2,,void
43572,BLOCK,-1,,"{
		patternConverters.push_back(
			LiteralPatternConverter::newInstance(currentLiteral));
		formattingInfos.push_back(FormattingInfo::getDefault());
	}",2,,299,2,,void
43597,BLOCK,-1,,"{

	LogString converterName(converterId);

	for (size_t i = converterId.length(); i > 0; i--)
	{
		converterName = converterName.substr(0, i);
		PatternMap::const_iterator iter = rules.find(converterName);

		if (iter != rules.end())
		{
			currentLiteral.erase(currentLiteral.begin(),
				currentLiteral.end() - (converterId.length() - i));
			return (iter->second)(options);
		}
	}

	LogLog::error(LogString(LOG4CXX_STR(""Unrecognized format specifier "")) + converterId);

	return PatternConverterPtr();
}",1,,312,5,,void
43602,BLOCK,-1,,<empty>,2,,316,1,,void
43615,BLOCK,4,,"{
		converterName = converterName.substr(0, i);
		PatternMap::const_iterator iter = rules.find(converterName);

		if (iter != rules.end())
		{
			currentLiteral.erase(currentLiteral.begin(),
				currentLiteral.end() - (converterId.length() - i));
			return (iter->second)(options);
		}
	}",2,,317,4,,void
43639,BLOCK,-1,,"{
			currentLiteral.erase(currentLiteral.begin(),
				currentLiteral.end() - (converterId.length() - i));
			return (iter->second)(options);
		}",3,,322,2,,void
43687,BLOCK,-1,,"{
	LogString convBuf;
	i = extractConverter(c, pattern, i, convBuf, currentLiteral);

	if (convBuf.empty())
	{
		LogLog::error(LOG4CXX_STR(""Empty conversion specifier""));
		patternConverters.push_back(
			LiteralPatternConverter::newInstance(currentLiteral));
		formattingInfos.push_back(FormattingInfo::getDefault());
	}
	else
	{
		LogString converterId(convBuf);

		std::vector<LogString> options;
		i = extractOptions(pattern, i, options);

		PatternConverterPtr pc(
			createConverter(
				converterId, currentLiteral, rules, options));

		if (pc == NULL)
		{
			LogString msg(LOG4CXX_STR(""Unrecognized conversion specifier [""));
			msg.append(converterId);
			msg.append(LOG4CXX_STR(""] in conversion pattern.""));
			LogLog::error(msg);
			patternConverters.push_back(
				LiteralPatternConverter::newInstance(currentLiteral));
			formattingInfos.push_back(FormattingInfo::getDefault());
		}
		else
		{
			patternConverters.push_back(pc);
			formattingInfos.push_back(formattingInfo);

			if (...",1,,340,9,,void
43702,BLOCK,-1,,"{
		LogLog::error(LOG4CXX_STR(""Empty conversion specifier""));
		patternConverters.push_back(
			LiteralPatternConverter::newInstance(currentLiteral));
		formattingInfos.push_back(FormattingInfo::getDefault());
	}",2,,345,2,,void
43727,BLOCK,-1,,"{
		LogString converterId(convBuf);

		std::vector<LogString> options;
		i = extractOptions(pattern, i, options);

		PatternConverterPtr pc(
			createConverter(
				converterId, currentLiteral, rules, options));

		if (pc == NULL)
		{
			LogString msg(LOG4CXX_STR(""Unrecognized conversion specifier [""));
			msg.append(converterId);
			msg.append(LOG4CXX_STR(""] in conversion pattern.""));
			LogLog::error(msg);
			patternConverters.push_back(
				LiteralPatternConverter::newInstance(currentLiteral));
			formattingInfos.push_back(FormattingInfo::getDefault());
		}
		else
		{
			patternConverters.push_back(pc);
			formattingInfos.push_back(formattingInfo);

			if (currentLiteral.length() > 0)
			{
				patternConverters.push_back(
					LiteralPatternConverter::newInstance(currentLiteral));
				formattingInfos.push_back(FormattingInfo::getDefault());
			}
		}
	}",2,,352,1,,void
43755,BLOCK,-1,,"{
			LogString msg(LOG4CXX_STR(""Unrecognized conversion specifier [""));
			msg.append(converterId);
			msg.append(LOG4CXX_STR(""] in conversion pattern.""));
			LogLog::error(msg);
			patternConverters.push_back(
				LiteralPatternConverter::newInstance(currentLiteral));
			formattingInfos.push_back(FormattingInfo::getDefault());
		}",3,,363,2,,void
43794,BLOCK,-1,,"{
			patternConverters.push_back(pc);
			formattingInfos.push_back(formattingInfo);

			if (currentLiteral.length() > 0)
			{
				patternConverters.push_back(
					LiteralPatternConverter::newInstance(currentLiteral));
				formattingInfos.push_back(FormattingInfo::getDefault());
			}
		}",3,,373,1,,void
43812,BLOCK,-1,,"{
				patternConverters.push_back(
					LiteralPatternConverter::newInstance(currentLiteral));
				formattingInfos.push_back(FormattingInfo::getDefault());
			}",4,,378,2,,void
43836,BLOCK,-1,,"{
		currentLiteral.erase(currentLiteral.begin(), currentLiteral.end());
	}",2,,387,2,,void
43871,BLOCK,-1,,<empty>,1,,1,1,,ANY
43873,BLOCK,-1,,"{
	apr_status_t stat = apr_pool_create(&pool, APRInitializer::getRootPool());

	if (stat != APR_SUCCESS)
	{
		throw PoolException(stat);
	}
}",1,,34,1,,void
43888,BLOCK,-1,,"{
		throw PoolException(stat);
	}",2,,38,2,,void
43897,BLOCK,-1,,"{
	assert(p != NULL);
}",1,,44,3,,void
43905,BLOCK,-1,,"{
	if (release)
	{
		apr_pool_destroy(pool);
	}
}",1,,49,1,,void
43908,BLOCK,-1,,"{
		apr_pool_destroy(pool);
	}",2,,51,2,,void
43913,BLOCK,-1,,"{
	return pool;
}",1,,58,1,,void
43919,BLOCK,-1,,"{
	apr_pool_t* child;
	apr_status_t stat = apr_pool_create(&child, pool);

	if (stat != APR_SUCCESS)
	{
		throw PoolException(stat);
	}

	return child;
}",1,,63,1,,void
43932,BLOCK,-1,,"{
		throw PoolException(stat);
	}",2,,68,2,,void
43942,BLOCK,-1,,"{
	return apr_palloc(pool, size);
}",1,,76,2,,void
43951,BLOCK,-1,,"{
	return (char*) palloc(size);
}",1,,81,2,,void
43961,BLOCK,-1,,"{
	return apr_itoa(pool, n);
}",1,,86,2,,void
43971,BLOCK,-1,,"{
	return apr_pstrndup(pool, s, len);
}",1,,91,3,,void
43981,BLOCK,-1,,"{
	return apr_pstrdup(pool, s);
}",1,,96,2,,void
43990,BLOCK,-1,,"{
	return apr_pstrndup(pool, s.data(), s.length());
}",1,,101,2,,void
44018,BLOCK,-1,,<empty>,1,,1,1,,ANY
44023,BLOCK,-1,,"{
			LogString key, element;
			LexemType lexemType = BEGIN;
			logchar c;
			bool finished = false;

			if (!get(in, c))
			{
				return;
			}

			while (!finished)
			{
				switch (lexemType)
				{
					case BEGIN:
						switch (c)
						{
							case 0x20: // ' '
							case 0x09: // '\t'
							case 0x0A: // '\n'
							case 0x0D: // '\r'
								if (!get(in, c))
								{
									finished = true;
								}

								break;

							case 0x23: // '#'
							case 0x21: // '!'
								lexemType = COMMENT;

								if (!get(in, c))
								{
									finished = true;
								}

								break;

							default:
								lexemType = KEY;
								break;
						}

						break;

					case KEY:
						switch (c)
						{
							case 0x5C: // '\\'
								lexemType = KEY_ESCAPE;

								if (!get(in, c))
								{
									finished = true;
								}

								break;

							case 0x09: // '\t'
							case 0x20: // ' '
							case 0x3A: // ':'
							case 0x3D: // '='
								lexemType = DELIMITER...",3,,31,3,,void
44040,BLOCK,-1,,"{
				return;
			}",4,,38,2,,void
44045,BLOCK,-1,,"{
				switch (lexemType)
				{
					case BEGIN:
						switch (c)
						{
							case 0x20: // ' '
							case 0x09: // '\t'
							case 0x0A: // '\n'
							case 0x0D: // '\r'
								if (!get(in, c))
								{
									finished = true;
								}

								break;

							case 0x23: // '#'
							case 0x21: // '!'
								lexemType = COMMENT;

								if (!get(in, c))
								{
									finished = true;
								}

								break;

							default:
								lexemType = KEY;
								break;
						}

						break;

					case KEY:
						switch (c)
						{
							case 0x5C: // '\\'
								lexemType = KEY_ESCAPE;

								if (!get(in, c))
								{
									finished = true;
								}

								break;

							case 0x09: // '\t'
							case 0x20: // ' '
							case 0x3A: // ':'
							case 0x3D: // '='
								lexemType = DELIMITER;

								if (!get(in, c))
								{
									finished = true;
								}

								break;

							case 0x0A:
							case 0x0D:
								// key associated with an empty st...",4,,43,2,,void
44048,BLOCK,-1,,"{
					case BEGIN:
						switch (c)
						{
							case 0x20: // ' '
							case 0x09: // '\t'
							case 0x0A: // '\n'
							case 0x0D: // '\r'
								if (!get(in, c))
								{
									finished = true;
								}

								break;

							case 0x23: // '#'
							case 0x21: // '!'
								lexemType = COMMENT;

								if (!get(in, c))
								{
									finished = true;
								}

								break;

							default:
								lexemType = KEY;
								break;
						}

						break;

					case KEY:
						switch (c)
						{
							case 0x5C: // '\\'
								lexemType = KEY_ESCAPE;

								if (!get(in, c))
								{
									finished = true;
								}

								break;

							case 0x09: // '\t'
							case 0x20: // ' '
							case 0x3A: // ':'
							case 0x3D: // '='
								lexemType = DELIMITER;

								if (!get(in, c))
								{
									finished = true;
								}

								break;

							case 0x0A:
							case 0x0D:
								// key associated with an empty string element
								properti...",5,,45,2,,void
44053,BLOCK,-1,,"{
							case 0x20: // ' '
							case 0x09: // '\t'
							case 0x0A: // '\n'
							case 0x0D: // '\r'
								if (!get(in, c))
								{
									finished = true;
								}

								break;

							case 0x23: // '#'
							case 0x21: // '!'
								lexemType = COMMENT;

								if (!get(in, c))
								{
									finished = true;
								}

								break;

							default:
								lexemType = KEY;
								break;
						}",7,,48,2,,void
44067,BLOCK,-1,,"{
									finished = true;
								}",9,,54,2,,void
44084,BLOCK,-1,,"{
									finished = true;
								}",9,,65,2,,void
44099,BLOCK,-1,,"{
							case 0x5C: // '\\'
								lexemType = KEY_ESCAPE;

								if (!get(in, c))
								{
									finished = true;
								}

								break;

							case 0x09: // '\t'
							case 0x20: // ' '
							case 0x3A: // ':'
							case 0x3D: // '='
								lexemType = DELIMITER;

								if (!get(in, c))
								{
									finished = true;
								}

								break;

							case 0x0A:
							case 0x0D:
								// key associated with an empty string element
								properties.setProperty(key, LogString());
								key.erase(key.begin(), key.end());
								lexemType = BEGIN;

								if (!get(in, c))
								{
									finished = true;
								}

								break;

							default:
								key.append(1, c);

								if (!get(in, c))
								{
									finished = true;
								}

								break;
						}",7,,80,2,,void
44110,BLOCK,-1,,"{
									finished = true;
								}",9,,85,2,,void
44131,BLOCK,-1,,"{
									finished = true;
								}",9,,98,2,,void
44166,BLOCK,-1,,"{
									finished = true;
								}",9,,112,2,,void
44183,BLOCK,-1,,"{
									finished = true;
								}",9,,122,2,,void
44193,BLOCK,-1,,"{
							case 0x74: // 't'
								key.append(1, 0x09);
								lexemType = KEY;
								break;

							case 0x6E: // 'n'
								key.append(1, 0x0A);
								lexemType = KEY;
								break;

							case 0x72: // 'r'
								key.append(1, 0x0D);
								lexemType = KEY;
								break;

							case 0x0A: // '\n'
								lexemType = KEY_CONTINUE;
								break;

							case 0x0D: // '\r'
								lexemType = KEY_CONTINUE2;
								break;

							default:
								key.append(1, c);
								lexemType = KEY;
						}",7,,133,2,,void
44257,BLOCK,-1,,"{
							finished = true;
						}",7,,163,2,,void
44266,BLOCK,-1,,"{
							case 0x20:  // ' '
							case 0x09: //  '\t'
								if (!get(in, c))
								{
									finished = true;
								}

								break;

							default:
								lexemType = KEY;
								break;
						}",7,,171,2,,void
44276,BLOCK,-1,,"{
									finished = true;
								}",9,,175,2,,void
44291,BLOCK,-1,,"{
							case 0x0A: // '\n'
								if (!get(in, c))
								{
									finished = true;
								}

								lexemType = KEY_CONTINUE;
								break;

							default:
								lexemType = KEY_CONTINUE;
								break;
						}",7,,190,2,,void
44299,BLOCK,-1,,"{
									finished = true;
								}",9,,193,2,,void
44317,BLOCK,-1,,"{
							case 0x09: // '\t'
							case 0x20: // ' '
							case 0x3A: // ':'
							case 0x3D: // '='
								if (!get(in, c))
								{
									finished = true;
								}

								break;

							default:
								lexemType = ELEMENT;
								break;
						}",7,,209,2,,void
44331,BLOCK,-1,,"{
									finished = true;
								}",9,,215,2,,void
44346,BLOCK,-1,,"{
							case 0x5C: // '\\'
								lexemType = ELEMENT_ESCAPE;

								if (!get(in, c))
								{
									finished = true;
								}

								break;

							case 0x0A: // '\n'
							case 0x0D: // '\r'
								// key associated with an empty string element
								properties.setProperty(key, element);
								key.erase(key.begin(), key.end());
								element.erase(element.begin(), element.end());
								lexemType = BEGIN;

								if (!get(in, c))
								{
									finished = true;
								}

								break;

							default:
								element.append(1, c);

								if (!get(in, c))
								{
									finished = true;
								}

								break;
						}",7,,230,2,,void
44357,BLOCK,-1,,"{
									finished = true;
								}",9,,235,2,,void
44404,BLOCK,-1,,"{
									finished = true;
								}",9,,250,2,,void
44421,BLOCK,-1,,"{
									finished = true;
								}",9,,260,2,,void
44431,BLOCK,-1,,"{
							case 0x74: // 't'
								element.append(1, 0x09);
								lexemType = ELEMENT;
								break;

							case 0x6E: // 'n'
								element.append(1, 0x0A);
								lexemType = ELEMENT;
								break;

							case 0x72: // 'r'
								element.append(1, 0x0D);
								lexemType = ELEMENT;
								break;

							case 0x0A: // '\n'
								lexemType = ELEMENT_CONTINUE;
								break;

							case 0x0D: // '\r'
								lexemType = ELEMENT_CONTINUE2;
								break;

							default:
								element.append(1, c);
								lexemType = ELEMENT;
								break;
						}",7,,271,2,,void
44496,BLOCK,-1,,"{
							finished = true;
						}",7,,302,2,,void
44505,BLOCK,-1,,"{
							case 0x20: // ' '
							case 0x09: // '\t'
								if (!get(in, c))
								{
									finished = true;
								}

								break;

							default:
								lexemType = ELEMENT;
								break;
						}",7,,310,2,,void
44515,BLOCK,-1,,"{
									finished = true;
								}",9,,314,2,,void
44530,BLOCK,-1,,"{
							case 0x0A: // '\n'
								if (!get(in, c))
								{
									finished = true;
								}

								lexemType = ELEMENT_CONTINUE;
								break;

							default:
								lexemType = ELEMENT_CONTINUE;
								break;
						}",7,,329,2,,void
44538,BLOCK,-1,,"{
									finished = true;
								}",9,,332,2,,void
44562,BLOCK,-1,,"{
							lexemType = BEGIN;
						}",7,,348,2,,void
44571,BLOCK,-1,,"{
							finished = true;
						}",7,,353,2,,void
44582,BLOCK,-1,,"{
				properties.setProperty(key, element);
			}",4,,362,2,,void
44594,BLOCK,-1,,"{
			if (in.empty())
			{
				c = 0;
				return false;
			}

			c = in[0];
			in.erase(in.begin());
			return true;
		}",3,,369,3,,void
44600,BLOCK,-1,,"{
				c = 0;
				return false;
			}",4,,371,2,,void
44637,BLOCK,-1,,"{
}",1,,399,1,,void
44641,BLOCK,-1,,"{
	delete properties;
}",1,,403,1,,void
44649,BLOCK,-1,,"{
	return put(key, value);
}",1,,408,3,,void
44659,BLOCK,-1,,"{
	LogString oldValue((*properties)[key]);
	(*properties)[key] = value;
	return oldValue;
}",1,,413,3,,void
44678,BLOCK,-1,,"{
	return get(key);
}",1,,420,2,,void
44686,BLOCK,-1,,"{
	PropertyMap::const_iterator it = properties->find(key);
	return (it != properties->end()) ? it->second : LogString();
}",1,,425,2,,void
44711,BLOCK,-1,,"{
	Pool pool;
	auto lineReader = std::make_shared<InputStreamReader>(inStream, CharsetDecoder::getISOLatinDecoder());
	LogString contents = lineReader->read(pool);
	properties->clear();
	PropertyParser parser;
	parser.parse(contents, *this);
}",1,,431,2,,void
44752,BLOCK,-1,,"{
	std::vector<LogString> names;
	names.reserve(properties->size());

	PropertyMap::const_iterator it;

	for (it = properties->begin(); it != properties->end(); it++)
	{
		const LogString& key = it->first;
		names.push_back(key);
	}

	return names;
}",1,,441,1,,void
44770,BLOCK,-1,,<empty>,2,,447,1,,void
44785,BLOCK,4,,"{
		const LogString& key = it->first;
		names.push_back(key);
	}",2,,448,4,,void
44817,BLOCK,-1,,<empty>,1,,1,1,,ANY
44823,BLOCK,-1,,<empty>,24,,37,4,,void
44832,BLOCK,-1,,"{
}",1,,51,3,,void
44837,BLOCK,-1,,"{
	if (options.size() == 0)
	{
		static WideLife<PatternConverterPtr> def = std::make_shared<PropertiesPatternConverter>(
				LOG4CXX_STR(""Properties""), LOG4CXX_STR(""""));
		return def;
	}

	LogString converterName(LOG4CXX_STR(""Property{""));
	converterName.append(options[0]);
	converterName.append(LOG4CXX_STR(""}""));
	return std::make_shared<PropertiesPatternConverter>(converterName, options[0]);
}",1,,56,2,,void
44845,BLOCK,-1,,"{
		static WideLife<PatternConverterPtr> def = std::make_shared<PropertiesPatternConverter>(
				LOG4CXX_STR(""Properties""), LOG4CXX_STR(""""));
		return def;
	}",2,,58,2,,void
44899,BLOCK,-1,,"{
	if (priv->option.length() == 0)
	{
		toAppendTo.append(1, (logchar) 0x7B /* '{' */);

		LoggingEvent::KeySet keySet(event->getMDCKeySet());

		for (LoggingEvent::KeySet::const_iterator iter = keySet.begin();
			iter != keySet.end();
			iter++)
		{
			toAppendTo.append(1, (logchar) 0x7B /* '{' */);
			toAppendTo.append(*iter);
			toAppendTo.append(1, (logchar) 0x2C /* ',' */);
			event->getMDC(*iter, toAppendTo);
			toAppendTo.append(1, (logchar) 0x7D /* '}' */);
		}

		toAppendTo.append(1, (logchar) 0x7D /* '}' */);

	}
	else
	{
		event->getMDC(priv->option, toAppendTo);
	}
}",1,,74,4,,void
44903,BLOCK,1,,<empty>,,,,1,,void
44916,BLOCK,-1,,"{
		toAppendTo.append(1, (logchar) 0x7B /* '{' */);

		LoggingEvent::KeySet keySet(event->getMDCKeySet());

		for (LoggingEvent::KeySet::const_iterator iter = keySet.begin();
			iter != keySet.end();
			iter++)
		{
			toAppendTo.append(1, (logchar) 0x7B /* '{' */);
			toAppendTo.append(*iter);
			toAppendTo.append(1, (logchar) 0x2C /* ',' */);
			event->getMDC(*iter, toAppendTo);
			toAppendTo.append(1, (logchar) 0x7D /* '}' */);
		}

		toAppendTo.append(1, (logchar) 0x7D /* '}' */);

	}",2,,76,2,,void
44932,BLOCK,-1,,<empty>,3,,81,1,,void
44948,BLOCK,4,,"{
			toAppendTo.append(1, (logchar) 0x7B /* '{' */);
			toAppendTo.append(*iter);
			toAppendTo.append(1, (logchar) 0x2C /* ',' */);
			event->getMDC(*iter, toAppendTo);
			toAppendTo.append(1, (logchar) 0x7D /* '}' */);
		}",3,,84,4,,void
44995,BLOCK,-1,,"{
		event->getMDC(priv->option, toAppendTo);
	}",2,,96,1,,void
45001,BLOCK,1,,<empty>,,,,1,,void
45065,BLOCK,-1,,<empty>,1,,1,1,,ANY
45070,BLOCK,-1,,"{
		}",3,,57,2,,void
45074,BLOCK,-1,,"{
			PropertyConfigurator().doConfigure(file(),
				LogManager::getLoggerRepository());
		}",3,,66,1,,void
45093,BLOCK,-1,,"{
}",1,,79,1,,void
45097,BLOCK,-1,,"{
	delete registry;
}",1,,83,1,,void
45105,BLOCK,-1,,"{
	hierarchy->setConfigured(true);

	Properties props;

	try
	{
		InputStreamPtr inputStream = InputStreamPtr( new FileInputStream(configFileName) );
		props.load(inputStream);
	}
	catch (const IOException& ex)
	{
		LOG4CXX_DECODE_CHAR(lsMsg, ex.what());
		LogLog::error(((LogString) LOG4CXX_STR(""Could not read configuration file [""))
			+ configFileName.getPath() + LOG4CXX_STR(""]: "") + lsMsg);
		return spi::ConfigurationStatus::NotConfigured;
	}

	try
	{
		LogString debugMsg = LOG4CXX_STR(""Loading configuration file ["")
				+ configFileName.getPath() + LOG4CXX_STR(""]."");
		LogLog::debug(debugMsg);
		return doConfigure(props, hierarchy);
	}
	catch (const std::exception& ex)
	{
		LogLog::error(((LogString) LOG4CXX_STR(""Could not parse configuration file [""))
			+ configFileName.getPath() + LOG4CXX_STR(""]: ""), ex);
	}

	return spi::ConfigurationStatus::NotConfigured;
}",1,,89,3,,void
45113,BLOCK,-1,,"{
		InputStreamPtr inputStream = InputStreamPtr( new FileInputStream(configFileName) );
		props.load(inputStream);
	}",2,,95,1,,void
45126,BLOCK,2,,"{
		LOG4CXX_DECODE_CHAR(lsMsg, ex.what());
		LogLog::error(((LogString) LOG4CXX_STR(""Could not read configuration file [""))
			+ configFileName.getPath() + LOG4CXX_STR(""]: "") + lsMsg);
		return spi::ConfigurationStatus::NotConfigured;
	}",2,,100,2,,void
45158,BLOCK,-1,,"{
		LogString debugMsg = LOG4CXX_STR(""Loading configuration file ["")
				+ configFileName.getPath() + LOG4CXX_STR(""]."");
		LogLog::debug(debugMsg);
		return doConfigure(props, hierarchy);
	}",2,,108,1,,void
45181,BLOCK,2,,"{
		LogLog::error(((LogString) LOG4CXX_STR(""Could not parse configuration file [""))
			+ configFileName.getPath() + LOG4CXX_STR(""]: ""), ex);
	}",2,,115,2,,void
45209,BLOCK,-1,,"{
	return PropertyConfigurator().doConfigure(configFilename, LogManager::getLoggerRepository());
}",1,,124,2,,void
45224,BLOCK,-1,,"{
	return PropertyConfigurator().doConfigure(properties, LogManager::getLoggerRepository());
}",1,,129,2,,void
45239,BLOCK,-1,,"{
	return configureAndWatch(configFilename, FileWatchdog::DEFAULT_DELAY);
}",1,,134,2,,void
45251,BLOCK,-1,,"{
	if (pdog)
	{
		APRInitializer::unregisterCleanup(pdog);
		delete pdog;
	}

	spi::ConfigurationStatus stat = PropertyConfigurator().doConfigure(configFilename, LogManager::getLoggerRepository());

	pdog = new PropertyWatchdog(configFilename);
	APRInitializer::registerCleanup(pdog);
	pdog->setDelay(delay);
	pdog->start();

	return stat;
}",1,,142,3,,void
45254,BLOCK,-1,,"{
		APRInitializer::unregisterCleanup(pdog);
		delete pdog;
	}",2,,144,2,,void
45292,BLOCK,-1,,"{
	hierarchy->setConfigured(true);

	static const WideLife<LogString> DEBUG_KEY(LOG4CXX_STR(""log4j.debug""));
	LogString value(properties.getProperty(DEBUG_KEY));

	if (!value.empty())
	{
		LogLog::setInternalDebugging(OptionConverter::toBoolean(value, true));
	}

	static const WideLife<LogString> THRESHOLD_PREFIX(LOG4CXX_STR(""log4j.threshold""));
	LogString thresholdStr =
		OptionConverter::findAndSubst(THRESHOLD_PREFIX, properties);

	if (!thresholdStr.empty())
	{
		hierarchy->setThreshold(OptionConverter::toLevel(thresholdStr, Level::getAll()));
		LogLog::debug(((LogString) LOG4CXX_STR(""Hierarchy threshold set to [""))
			+ hierarchy->getThreshold()->toString()
			+ LOG4CXX_STR(""].""));
	}

	LogString threadConfigurationValue(properties.getProperty(LOG4CXX_STR(""log4j.threadConfiguration"")));

	if ( threadConfigurationValue == LOG4CXX_STR(""NoConfiguration"") )
	{
		helpers::ThreadUtility::configure( ThreadConfigurationType::NoConfiguration );
	}
	else if ( threadConfigurationValue == L...",1,,161,3,,void
45315,BLOCK,-1,,"{
		LogLog::setInternalDebugging(OptionConverter::toBoolean(value, true));
	}",2,,168,2,,void
45345,BLOCK,-1,,"{
		hierarchy->setThreshold(OptionConverter::toLevel(thresholdStr, Level::getAll()));
		LogLog::debug(((LogString) LOG4CXX_STR(""Hierarchy threshold set to [""))
			+ hierarchy->getThreshold()->toString()
			+ LOG4CXX_STR(""].""));
	}",2,,177,2,,void
45391,BLOCK,-1,,"{
		helpers::ThreadUtility::configure( ThreadConfigurationType::NoConfiguration );
	}",2,,187,2,,void
45402,BLOCK,-1,,<empty>,7,,190,1,,void
45408,BLOCK,-1,,"{
		helpers::ThreadUtility::configure( ThreadConfigurationType::BlockSignalsOnly );
	}",2,,191,2,,void
45419,BLOCK,-1,,<empty>,7,,194,1,,void
45425,BLOCK,-1,,"{
		helpers::ThreadUtility::configure( ThreadConfigurationType::NameThreadOnly );
	}",2,,195,2,,void
45436,BLOCK,-1,,<empty>,7,,198,1,,void
45442,BLOCK,-1,,"{
		helpers::ThreadUtility::configure( ThreadConfigurationType::BlockSignalsAndNameThread );
	}",2,,199,2,,void
45480,BLOCK,-1,,"{
	static const WideLife<LogString> LOGGER_FACTORY_KEY(LOG4CXX_STR(""log4j.loggerFactory""));

	LogString factoryClassName =
		OptionConverter::findAndSubst(LOGGER_FACTORY_KEY, props);

	if (!factoryClassName.empty())
	{
		LogString msg(LOG4CXX_STR(""Setting logger factory to [""));
		msg += factoryClassName;
		msg += LOG4CXX_STR(""]."");
		LogLog::debug(msg);
		std::shared_ptr<Object> instance = std::shared_ptr<Object>(
				Loader::loadClass(factoryClassName).newInstance() );

		loggerFactory = LOG4CXX_NS::cast<LoggerFactory>( instance );
		static const WideLife<LogString> FACTORY_PREFIX(LOG4CXX_STR(""log4j.factory.""));
		Pool p;
		PropertySetter::setProperties(loggerFactory, props, FACTORY_PREFIX, p);
	}
}",1,,217,2,,void
45500,BLOCK,-1,,"{
		LogString msg(LOG4CXX_STR(""Setting logger factory to [""));
		msg += factoryClassName;
		msg += LOG4CXX_STR(""]."");
		LogLog::debug(msg);
		std::shared_ptr<Object> instance = std::shared_ptr<Object>(
				Loader::loadClass(factoryClassName).newInstance() );

		loggerFactory = LOG4CXX_NS::cast<LoggerFactory>( instance );
		static const WideLife<LogString> FACTORY_PREFIX(LOG4CXX_STR(""log4j.factory.""));
		Pool p;
		PropertySetter::setProperties(loggerFactory, props, FACTORY_PREFIX, p);
	}",2,,224,2,,void
45566,BLOCK,-1,,"{
	static const WideLife<LogString> ROOT_CATEGORY_PREFIX(LOG4CXX_STR(""log4j.rootCategory""));
	static const WideLife<LogString> ROOT_LOGGER_PREFIX(LOG4CXX_STR(""log4j.rootLogger""));



	LogString effectiveFrefix(ROOT_LOGGER_PREFIX);
	LogString value = OptionConverter::findAndSubst(ROOT_LOGGER_PREFIX, props);

	if (value.empty())
	{
		value = OptionConverter::findAndSubst(ROOT_CATEGORY_PREFIX, props);
		effectiveFrefix = ROOT_CATEGORY_PREFIX;
	}

	if (value.empty())
	{
		LogLog::debug(LOG4CXX_STR(""Could not find root logger information. Is this OK?""));
	}
	else
	{
		LoggerPtr root = hierarchy->getRootLogger();

		static const WideLife<LogString> INTERNAL_ROOT_NAME(LOG4CXX_STR(""root""));
		parseLogger(props, root, effectiveFrefix, INTERNAL_ROOT_NAME, value, true);
	}
}",1,,241,3,,void
45592,BLOCK,-1,,"{
		value = OptionConverter::findAndSubst(ROOT_CATEGORY_PREFIX, props);
		effectiveFrefix = ROOT_CATEGORY_PREFIX;
	}",2,,251,2,,void
45609,BLOCK,-1,,"{
		LogLog::debug(LOG4CXX_STR(""Could not find root logger information. Is this OK?""));
	}",2,,257,2,,void
45617,BLOCK,-1,,"{
		LoggerPtr root = hierarchy->getRootLogger();

		static const WideLife<LogString> INTERNAL_ROOT_NAME(LOG4CXX_STR(""root""));
		parseLogger(props, root, effectiveFrefix, INTERNAL_ROOT_NAME, value, true);
	}",2,,261,1,,void
45641,BLOCK,-1,,"{
	static const WideLife<LogString> CATEGORY_PREFIX(LOG4CXX_STR(""log4j.category.""));
	static const WideLife<LogString> LOGGER_PREFIX(LOG4CXX_STR(""log4j.logger.""));

	std::vector<LogString> names = props.propertyNames();

	std::vector<LogString>::iterator it = names.begin();
	std::vector<LogString>::iterator itEnd = names.end();

	while (it != itEnd)
	{
		LogString key = *it++;

		if (key.find(CATEGORY_PREFIX) == 0 || key.find(LOGGER_PREFIX) == 0)
		{
			LogString loggerName;

			if (key.find(CATEGORY_PREFIX) == 0)
			{
				loggerName = key.substr(CATEGORY_PREFIX.value().length());
			}
			else if (key.find(LOGGER_PREFIX.value()) == 0)
			{
				loggerName = key.substr(LOGGER_PREFIX.value().length());
			}

			LogString value = OptionConverter::findAndSubst(key, props);
			LoggerPtr logger = hierarchy->getLogger(loggerName, loggerFactory);

			bool additivity = parseAdditivityForLogger(props, logger, loggerName);
			parseLogger(props, logger, key, loggerName, value, additivity);

		}
...",1,,271,3,,void
45680,BLOCK,-1,,"{
		LogString key = *it++;

		if (key.find(CATEGORY_PREFIX) == 0 || key.find(LOGGER_PREFIX) == 0)
		{
			LogString loggerName;

			if (key.find(CATEGORY_PREFIX) == 0)
			{
				loggerName = key.substr(CATEGORY_PREFIX.value().length());
			}
			else if (key.find(LOGGER_PREFIX.value()) == 0)
			{
				loggerName = key.substr(LOGGER_PREFIX.value().length());
			}

			LogString value = OptionConverter::findAndSubst(key, props);
			LoggerPtr logger = hierarchy->getLogger(loggerName, loggerFactory);

			bool additivity = parseAdditivityForLogger(props, logger, loggerName);
			parseLogger(props, logger, key, loggerName, value, additivity);

		}
	}",2,,281,2,,void
45703,BLOCK,-1,,"{
			LogString loggerName;

			if (key.find(CATEGORY_PREFIX) == 0)
			{
				loggerName = key.substr(CATEGORY_PREFIX.value().length());
			}
			else if (key.find(LOGGER_PREFIX.value()) == 0)
			{
				loggerName = key.substr(LOGGER_PREFIX.value().length());
			}

			LogString value = OptionConverter::findAndSubst(key, props);
			LoggerPtr logger = hierarchy->getLogger(loggerName, loggerFactory);

			bool additivity = parseAdditivityForLogger(props, logger, loggerName);
			parseLogger(props, logger, key, loggerName, value, additivity);

		}",3,,285,2,,void
45713,BLOCK,-1,,"{
				loggerName = key.substr(CATEGORY_PREFIX.value().length());
			}",4,,289,2,,void
45728,BLOCK,-1,,<empty>,9,,292,1,,void
45740,BLOCK,-1,,"{
				loggerName = key.substr(LOGGER_PREFIX.value().length());
			}",4,,293,2,,void
45792,BLOCK,-1,,"{

	static const WideLife<LogString> ADDITIVITY_PREFIX(LOG4CXX_STR(""log4j.additivity.""));



	LogString value(OptionConverter::findAndSubst(ADDITIVITY_PREFIX.value() + loggerName, props));
	LogLog::debug((LogString) LOG4CXX_STR(""Handling "") + ADDITIVITY_PREFIX.value()
		+ loggerName + LOG4CXX_STR(""=["") +  value + LOG4CXX_STR(""]""));

	// touch additivity only if necessary
	if (!value.empty())
	{
		bool additivity = OptionConverter::toBoolean(value, true);
		LogLog::debug(((LogString) LOG4CXX_STR(""Setting additivity for \""""))
			+ loggerName
			+ ((additivity) ?  LOG4CXX_STR(""\"" to true"") :
				LOG4CXX_STR(""\"" to false"")));

		return additivity;
	}

	return true;
}",1,,309,4,,void
45839,BLOCK,-1,,"{
		bool additivity = OptionConverter::toBoolean(value, true);
		LogLog::debug(((LogString) LOG4CXX_STR(""Setting additivity for \""""))
			+ loggerName
			+ ((additivity) ?  LOG4CXX_STR(""\"" to true"") :
				LOG4CXX_STR(""\"" to false"")));

		return additivity;
	}",2,,321,2,,void
45879,BLOCK,-1,,"{
	LogLog::debug(((LogString) LOG4CXX_STR(""Parsing for [""))
		+ loggerName
		+ LOG4CXX_STR(""] with value=["")
		+ value + LOG4CXX_STR(""].""));

	// We must skip over ',' but not white space
	StringTokenizer st(value, LOG4CXX_STR("",""));

	// If value is not in the form "", appender.."" or """", then we should set
	// the level of the logger.
	if (!(value.find(LOG4CXX_STR("","")) == 0 || value.empty()))
	{
		// just to be on the safe side...
		if (!st.hasMoreTokens())
		{
			return;
		}

		LogString levelStr = st.nextToken();
		LogLog::debug((LogString) LOG4CXX_STR(""Level token is ["")
			+ levelStr +  LOG4CXX_STR(""].""));


		// If the level value is inherited, set logger level value to
		// null. We also check that the user has not specified inherited for the
		// root logger.
		if (StringHelper::equalsIgnoreCase(levelStr, LOG4CXX_STR(""INHERITED""), LOG4CXX_STR(""inherited""))
			|| StringHelper::equalsIgnoreCase(levelStr, LOG4CXX_STR(""NULL""), LOG4CXX_STR(""null"")))
		{
			static const WideLife<L...",1,,340,7,,void
45918,BLOCK,-1,,"{
		// just to be on the safe side...
		if (!st.hasMoreTokens())
		{
			return;
		}

		LogString levelStr = st.nextToken();
		LogLog::debug((LogString) LOG4CXX_STR(""Level token is ["")
			+ levelStr +  LOG4CXX_STR(""].""));


		// If the level value is inherited, set logger level value to
		// null. We also check that the user has not specified inherited for the
		// root logger.
		if (StringHelper::equalsIgnoreCase(levelStr, LOG4CXX_STR(""INHERITED""), LOG4CXX_STR(""inherited""))
			|| StringHelper::equalsIgnoreCase(levelStr, LOG4CXX_STR(""NULL""), LOG4CXX_STR(""null"")))
		{
			static const WideLife<LogString> INTERNAL_ROOT_NAME(LOG4CXX_STR(""root""));

			if (loggerName == INTERNAL_ROOT_NAME.value())
			{
				LogLog::warn(LOG4CXX_STR(""The root logger cannot be set to null.""));
			}
			else
			{
				logger->setLevel(0);
				LogLog::debug((LogString) LOG4CXX_STR(""Logger "")
					+ loggerName + LOG4CXX_STR("" set to null""));
			}
		}
		else
		{
			logger->setLevel(OptionConverter::toLevel(levelStr...",2,,352,2,,void
45925,BLOCK,-1,,"{
			return;
		}",3,,355,2,,void
45967,BLOCK,-1,,"{
			static const WideLife<LogString> INTERNAL_ROOT_NAME(LOG4CXX_STR(""root""));

			if (loggerName == INTERNAL_ROOT_NAME.value())
			{
				LogLog::warn(LOG4CXX_STR(""The root logger cannot be set to null.""));
			}
			else
			{
				logger->setLevel(0);
				LogLog::debug((LogString) LOG4CXX_STR(""Logger "")
					+ loggerName + LOG4CXX_STR("" set to null""));
			}
		}",3,,369,2,,void
45979,BLOCK,-1,,"{
				LogLog::warn(LOG4CXX_STR(""The root logger cannot be set to null.""));
			}",4,,373,2,,void
45987,BLOCK,-1,,"{
				logger->setLevel(0);
				LogLog::debug((LogString) LOG4CXX_STR(""Logger "")
					+ loggerName + LOG4CXX_STR("" set to null""));
			}",4,,377,1,,void
46007,BLOCK,-1,,"{
			logger->setLevel(OptionConverter::toLevel(levelStr, Level::getDebug()));

			LogLog::debug((LogString) LOG4CXX_STR(""Logger "")
				+ loggerName + LOG4CXX_STR("" set to "")
				+ logger->getLevel()->toString());
		}",3,,384,1,,void
46056,BLOCK,-1,,"{
		appenderName = StringHelper::trim(st.nextToken());

		if (appenderName.empty() || appenderName == LOG4CXX_STR("",""))
		{
			continue;
		}

		LogLog::debug(LOG4CXX_STR(""Parsing appender named "")
			+ appenderName + LOG4CXX_STR(""\"".""));
		appender = parseAppender(props, appenderName);

		if (appender != 0)
		{
			newappenders.push_back(appender);
		}
	}",2,,399,2,,void
46077,BLOCK,-1,,"{
			continue;
		}",3,,403,2,,void
46099,BLOCK,-1,,"{
			newappenders.push_back(appender);
		}",3,,412,2,,void
46116,BLOCK,-1,,"{
	AppenderPtr appender = registryGet(appenderName);

	if (appender != 0)
	{
		LogLog::debug((LogString) LOG4CXX_STR(""Appender \"""")
			+ appenderName + LOG4CXX_STR(""\"" was already parsed.""));

		return appender;
	}

	static const WideLife<LogString> APPENDER_PREFIX(LOG4CXX_STR(""log4j.appender.""));

	// Appender was not previously initialized.
	LogString prefix = APPENDER_PREFIX.value() + appenderName;
	LogString layoutPrefix = prefix + LOG4CXX_STR("".layout"");

	std::shared_ptr<Object> obj =
		OptionConverter::instantiateByKey(
			props, prefix, Appender::getStaticClass(), 0);
	appender = LOG4CXX_NS::cast<Appender>( obj );

	// Map obsolete DailyRollingFileAppender property configuration
	if (!appender &&
		StringHelper::endsWith(OptionConverter::findAndSubst(prefix, props), LOG4CXX_STR(""DailyRollingFileAppender"")))
	{
		appender = std::make_shared<RollingFileAppender>();
		auto datePattern = OptionConverter::findAndSubst(prefix + LOG4CXX_STR("".datePattern""), props);
		if (!datePatte...",1,,422,3,,void
46126,BLOCK,-1,,"{
		LogLog::debug((LogString) LOG4CXX_STR(""Appender \"""")
			+ appenderName + LOG4CXX_STR(""\"" was already parsed.""));

		return appender;
	}",2,,426,2,,void
46206,BLOCK,-1,,"{
		appender = std::make_shared<RollingFileAppender>();
		auto datePattern = OptionConverter::findAndSubst(prefix + LOG4CXX_STR("".datePattern""), props);
		if (!datePattern.empty())
			props.put(prefix + LOG4CXX_STR("".fileDatePattern""), datePattern);
	}",2,,447,2,,void
46231,BLOCK,-1,,<empty>,4,,451,2,,void
46244,BLOCK,-1,,"{
		LogLog::error((LogString) LOG4CXX_STR(""Could not instantiate appender named \"""")
			+ appenderName + LOG4CXX_STR(""\"".""));
		return 0;
	}",2,,455,2,,void
46274,BLOCK,-1,,"{
		Pool p;

		if (appender->requiresLayout())
		{
			LayoutPtr layout;
			std::shared_ptr<Object> obj =
				OptionConverter::instantiateByKey(
					props, layoutPrefix, Layout::getStaticClass(), 0);
			layout = LOG4CXX_NS::cast<Layout>( obj );

			if (layout != 0)
			{
				appender->setLayout(layout);
				LogLog::debug((LogString) LOG4CXX_STR(""Parsing layout options for \"""")
					+ appenderName + LOG4CXX_STR(""\"".""));

				PropertySetter::setProperties(layout, props, layoutPrefix + LOG4CXX_STR("".""), p);
				LogLog::debug((LogString) LOG4CXX_STR(""End of parsing for \"""")
					+ appenderName +  LOG4CXX_STR(""\"".""));
			}
		}

		RollingFileAppenderPtr rolling = LOG4CXX_NS::cast<rolling::RollingFileAppender>(appender);
		if (rolling)
		{
			LogString rollingPolicyKey = prefix + LOG4CXX_STR("".rollingPolicy"");
			if (!OptionConverter::findAndSubst(rollingPolicyKey, props).empty())
			{
				RollingPolicyPtr rollingPolicy;
				std::shared_ptr<Object> rolling_obj =
					OptionConverter::instan...",2,,464,2,,void
46281,BLOCK,-1,,"{
			LayoutPtr layout;
			std::shared_ptr<Object> obj =
				OptionConverter::instantiateByKey(
					props, layoutPrefix, Layout::getStaticClass(), 0);
			layout = LOG4CXX_NS::cast<Layout>( obj );

			if (layout != 0)
			{
				appender->setLayout(layout);
				LogLog::debug((LogString) LOG4CXX_STR(""Parsing layout options for \"""")
					+ appenderName + LOG4CXX_STR(""\"".""));

				PropertySetter::setProperties(layout, props, layoutPrefix + LOG4CXX_STR("".""), p);
				LogLog::debug((LogString) LOG4CXX_STR(""End of parsing for \"""")
					+ appenderName +  LOG4CXX_STR(""\"".""));
			}
		}",3,,468,2,,void
46315,BLOCK,-1,,"{
				appender->setLayout(layout);
				LogLog::debug((LogString) LOG4CXX_STR(""Parsing layout options for \"""")
					+ appenderName + LOG4CXX_STR(""\"".""));

				PropertySetter::setProperties(layout, props, layoutPrefix + LOG4CXX_STR("".""), p);
				LogLog::debug((LogString) LOG4CXX_STR(""End of parsing for \"""")
					+ appenderName +  LOG4CXX_STR(""\"".""));
			}",4,,476,2,,void
46372,BLOCK,-1,,"{
			LogString rollingPolicyKey = prefix + LOG4CXX_STR("".rollingPolicy"");
			if (!OptionConverter::findAndSubst(rollingPolicyKey, props).empty())
			{
				RollingPolicyPtr rollingPolicy;
				std::shared_ptr<Object> rolling_obj =
					OptionConverter::instantiateByKey(
						props, rollingPolicyKey, RollingPolicy::getStaticClass(), 0);
				rollingPolicy = LOG4CXX_NS::cast<RollingPolicy>( rolling_obj );
				if(rollingPolicy)
				{
					rolling->setRollingPolicy(rollingPolicy);

					LogLog::debug((LogString) LOG4CXX_STR(""Parsing rolling policy options for \"""")
						+ appenderName + LOG4CXX_STR(""\"".""));
					PropertySetter::setProperties(rollingPolicy, props, rollingPolicyKey + LOG4CXX_STR("".""), p);
				}
			}

			LogString triggeringPolicyKey = prefix + LOG4CXX_STR("".triggeringPolicy"");
			if (!OptionConverter::findAndSubst(triggeringPolicyKey, props).empty())
			{
				TriggeringPolicyPtr triggeringPolicy;
				std::shared_ptr<Object> triggering_obj =
					OptionConverter::instantiate...",3,,489,2,,void
46391,BLOCK,-1,,"{
				RollingPolicyPtr rollingPolicy;
				std::shared_ptr<Object> rolling_obj =
					OptionConverter::instantiateByKey(
						props, rollingPolicyKey, RollingPolicy::getStaticClass(), 0);
				rollingPolicy = LOG4CXX_NS::cast<RollingPolicy>( rolling_obj );
				if(rollingPolicy)
				{
					rolling->setRollingPolicy(rollingPolicy);

					LogLog::debug((LogString) LOG4CXX_STR(""Parsing rolling policy options for \"""")
						+ appenderName + LOG4CXX_STR(""\"".""));
					PropertySetter::setProperties(rollingPolicy, props, rollingPolicyKey + LOG4CXX_STR("".""), p);
				}
			}",4,,492,2,,void
46423,BLOCK,-1,,"{
					rolling->setRollingPolicy(rollingPolicy);

					LogLog::debug((LogString) LOG4CXX_STR(""Parsing rolling policy options for \"""")
						+ appenderName + LOG4CXX_STR(""\"".""));
					PropertySetter::setProperties(rollingPolicy, props, rollingPolicyKey + LOG4CXX_STR("".""), p);
				}",5,,499,2,,void
46471,BLOCK,-1,,"{
				TriggeringPolicyPtr triggeringPolicy;
				std::shared_ptr<Object> triggering_obj =
					OptionConverter::instantiateByKey(
						props, triggeringPolicyKey, TriggeringPolicy::getStaticClass(), 0);
				triggeringPolicy = LOG4CXX_NS::cast<TriggeringPolicy>( triggering_obj );
				if(triggeringPolicy)
				{
					rolling->setTriggeringPolicy(triggeringPolicy);

					LogLog::debug((LogString) LOG4CXX_STR(""Parsing triggering policy options for \"""")
						+ appenderName + LOG4CXX_STR(""\"".""));
					PropertySetter::setProperties(triggeringPolicy, props, triggeringPolicyKey + LOG4CXX_STR("".""), p);
				}
			}",4,,510,2,,void
46503,BLOCK,-1,,"{
					rolling->setTriggeringPolicy(triggeringPolicy);

					LogLog::debug((LogString) LOG4CXX_STR(""Parsing triggering policy options for \"""")
						+ appenderName + LOG4CXX_STR(""\"".""));
					PropertySetter::setProperties(triggeringPolicy, props, triggeringPolicyKey + LOG4CXX_STR("".""), p);
				}",5,,517,2,,void
46565,BLOCK,-1,,"{
	(*registry)[appender->getName()] = appender;
}",1,,538,2,,void
46579,BLOCK,-1,,"{
	return (*registry)[name];
}",1,,543,2,,void
46599,BLOCK,-1,,<empty>,1,,1,1,,ANY
46604,BLOCK,-1,,"{
	properties.load(inStream);
}",1,,32,2,,void
46614,BLOCK,-1,,"{
	LogString resource;
	PropertyResourceBundle* resourceBundle(const_cast<PropertyResourceBundle*>(this));

	do
	{
		resource = resourceBundle->properties.getProperty(key);

		if (!resource.empty())
		{
			return resource;
		}

		resourceBundle = dynamic_cast<PropertyResourceBundle*>(resourceBundle->parent.get());
	}
	while (resourceBundle != 0);

	throw MissingResourceException(key);
#if LOG4CXX_RETURN_AFTER_THROW
	return resource;
#endif
}",1,,37,2,,void
46622,BLOCK,-1,,"{
		resource = resourceBundle->properties.getProperty(key);

		if (!resource.empty())
		{
			return resource;
		}

		resourceBundle = dynamic_cast<PropertyResourceBundle*>(resourceBundle->parent.get());
	}",2,,42,1,,void
46638,BLOCK,-1,,"{
			return resource;
		}",3,,46,2,,void
46683,BLOCK,-1,,<empty>,1,,1,1,,ANY
46686,BLOCK,-1,,"{
}",1,,35,2,,void
46694,BLOCK,-1,,"{
	PropertySetter(obj).setProperties(properties, prefix, p);
}",1,,42,5,,void
46709,BLOCK,-1,,"{
	size_t len = prefix.length();

	std::vector<LogString> names = properties.propertyNames();
	std::vector<LogString>::iterator it;

	for (it = names.begin(); it != names.end(); it++)
	{
		LogString key = *it;

		// handle only properties that start with the desired frefix.
		if (key.find(prefix) == 0)
		{
			// ignore key if it contains dots after the prefix
			if (key.find(0x2E /* '.' */, len + 1) != LogString::npos)
			{
				continue;
			}

			LogString value = OptionConverter::findAndSubst(key, properties);
			key = key.substr(len);

			if (key == LOG4CXX_STR(""layout"")
				&& obj != 0
				&& obj->instanceof(Appender::getStaticClass()))
			{
				continue;
			}

			setProperty(key, value, p);
		}
	}

	activate(p);
}",1,,50,4,,void
46731,BLOCK,-1,,<empty>,2,,56,1,,void
46746,BLOCK,4,,"{
		LogString key = *it;

		// handle only properties that start with the desired frefix.
		if (key.find(prefix) == 0)
		{
			// ignore key if it contains dots after the prefix
			if (key.find(0x2E /* '.' */, len + 1) != LogString::npos)
			{
				continue;
			}

			LogString value = OptionConverter::findAndSubst(key, properties);
			key = key.substr(len);

			if (key == LOG4CXX_STR(""layout"")
				&& obj != 0
				&& obj->instanceof(Appender::getStaticClass()))
			{
				continue;
			}

			setProperty(key, value, p);
		}
	}",2,,57,4,,void
46760,BLOCK,-1,,"{
			// ignore key if it contains dots after the prefix
			if (key.find(0x2E /* '.' */, len + 1) != LogString::npos)
			{
				continue;
			}

			LogString value = OptionConverter::findAndSubst(key, properties);
			key = key.substr(len);

			if (key == LOG4CXX_STR(""layout"")
				&& obj != 0
				&& obj->instanceof(Appender::getStaticClass()))
			{
				continue;
			}

			setProperty(key, value, p);
		}",3,,62,2,,void
46774,BLOCK,-1,,"{
				continue;
			}",4,,65,2,,void
46810,BLOCK,-1,,"{
				continue;
			}",4,,75,2,,void
46824,BLOCK,-1,,"{
	if (value.empty())
	{
		return;
	}

	if (obj != 0 && obj->instanceof(OptionHandler::getStaticClass()))
	{
		LogLog::debug(LOG4CXX_STR(""Setting option name=["") +
			option + LOG4CXX_STR(""], value=["") + value + LOG4CXX_STR(""]""));
		OptionHandlerPtr handler = LOG4CXX_NS::cast<OptionHandler>(obj);
		handler->setOption(option, value);
	}
}",1,,89,4,,void
46830,BLOCK,-1,,"{
		return;
	}",2,,91,2,,void
46845,BLOCK,-1,,"{
		LogLog::debug(LOG4CXX_STR(""Setting option name=["") +
			option + LOG4CXX_STR(""], value=["") + value + LOG4CXX_STR(""]""));
		OptionHandlerPtr handler = LOG4CXX_NS::cast<OptionHandler>(obj);
		handler->setOption(option, value);
	}",2,,96,2,,void
46882,BLOCK,-1,,"{
	if (obj != 0 && obj->instanceof(OptionHandler::getStaticClass()))
	{
		OptionHandlerPtr handler = LOG4CXX_NS::cast<OptionHandler>(obj);
		handler->activateOptions(p);
	}
}",1,,105,2,,void
46896,BLOCK,-1,,"{
		OptionHandlerPtr handler = LOG4CXX_NS::cast<OptionHandler>(obj);
		handler->activateOptions(p);
	}",2,,107,2,,void
46922,BLOCK,-1,,<empty>,1,,1,1,,ANY
46926,BLOCK,-1,,"{
}",1,,26,1,,void
46930,BLOCK,-1,,"{
}",1,,30,1,,void
46945,BLOCK,-1,,<empty>,1,,1,1,,ANY
46947,BLOCK,-1,,"{
}",1,,26,1,,void
46954,BLOCK,-1,,"{
	int64_t interval = (date - startTime) / int64_t(1000);
	StringHelper::toString(interval, p, s);
}",1,,33,4,,void
46987,BLOCK,-1,,<empty>,1,,1,1,,ANY
46991,BLOCK,-1,,"{
}",1,,34,1,,void
46996,BLOCK,-1,,"{
	static WideLife<PatternConverterPtr> def = std::make_shared<RelativeTimePatternConverter>();
	return def;
}",1,,39,2,,void
47012,BLOCK,-1,,"{
	log4cxx_time_t delta = (event->getTimeStamp() - LoggingEvent::getStartTime()) / 1000;
	StringHelper::toString(delta, p, toAppendTo);
}",1,,48,4,,void
47054,BLOCK,-1,,<empty>,1,,1,1,,ANY
47060,BLOCK,-1,,"{
	LogString bundleName;
	PropertyResourceBundlePtr resourceBundle, previous;

	std::vector<LogString> bundlesNames;

	if (!locale.getVariant().empty())
	{
		bundlesNames.push_back(baseName + LOG4CXX_STR(""_"") +
			locale.getLanguage() + LOG4CXX_STR(""_"") +
			locale.getCountry() + LOG4CXX_STR(""_"") +
			locale.getVariant());
	}

	if (!locale.getCountry().empty())
	{
		bundlesNames.push_back(baseName + LOG4CXX_STR(""_"") +
			locale.getLanguage() + LOG4CXX_STR(""_"") +
			locale.getCountry());
	}

	if (!locale.getLanguage().empty())
	{
		bundlesNames.push_back(baseName + LOG4CXX_STR(""_"") +
			locale.getLanguage());
	}

	bundlesNames.push_back(baseName);

	for (std::vector<LogString>::iterator it = bundlesNames.begin();
		it != bundlesNames.end(); it++)
	{

		bundleName = *it;

		PropertyResourceBundlePtr current;

		// Try loading a class which implements ResourceBundle
		try
		{
			const Class& classObj = Loader::loadClass(bundleName);
			ObjectPtr obj = ObjectPtr(classObj.newInstance());...",1,,32,3,,void
47080,BLOCK,-1,,"{
		bundlesNames.push_back(baseName + LOG4CXX_STR(""_"") +
			locale.getLanguage() + LOG4CXX_STR(""_"") +
			locale.getCountry() + LOG4CXX_STR(""_"") +
			locale.getVariant());
	}",2,,39,2,,void
47119,BLOCK,-1,,"{
		bundlesNames.push_back(baseName + LOG4CXX_STR(""_"") +
			locale.getLanguage() + LOG4CXX_STR(""_"") +
			locale.getCountry());
	}",2,,47,2,,void
47150,BLOCK,-1,,"{
		bundlesNames.push_back(baseName + LOG4CXX_STR(""_"") +
			locale.getLanguage());
	}",2,,54,2,,void
47170,BLOCK,-1,,<empty>,2,,61,1,,void
47186,BLOCK,4,,"{

		bundleName = *it;

		PropertyResourceBundlePtr current;

		// Try loading a class which implements ResourceBundle
		try
		{
			const Class& classObj = Loader::loadClass(bundleName);
			ObjectPtr obj = ObjectPtr(classObj.newInstance());
			current = LOG4CXX_NS::cast<PropertyResourceBundle>(obj);
		}
		catch (ClassNotFoundException&)
		{
			current = 0;
		}

		// No class found, then try to create a PropertyResourceBundle from a file
		if (current == 0)
		{
			InputStreamPtr bundleStream =
				Loader::getResourceAsStream(
					bundleName + LOG4CXX_STR("".properties""));

			if (bundleStream == 0)
			{
				continue;
			}

			try
			{
				current = std::make_shared<PropertyResourceBundle>(bundleStream);
			}
			catch (Exception&)
			{
				throw;
			}
		}

		// Add the new resource bundle to the hierarchy
		if (resourceBundle == 0)
		{
			resourceBundle = current;
			previous = current;
		}
		else
		{
			previous->setParent(current);
			previous = current;
		}
	}",2,,63,4,,void
47193,BLOCK,-1,,"{
			const Class& classObj = Loader::loadClass(bundleName);
			ObjectPtr obj = ObjectPtr(classObj.newInstance());
			current = LOG4CXX_NS::cast<PropertyResourceBundle>(obj);
		}",3,,71,1,,void
47219,BLOCK,2,,"{
			current = 0;
		}",3,,77,2,,void
47227,BLOCK,-1,,"{
			InputStreamPtr bundleStream =
				Loader::getResourceAsStream(
					bundleName + LOG4CXX_STR("".properties""));

			if (bundleStream == 0)
			{
				continue;
			}

			try
			{
				current = std::make_shared<PropertyResourceBundle>(bundleStream);
			}
			catch (Exception&)
			{
				throw;
			}
		}",3,,83,2,,void
47243,BLOCK,-1,,"{
				continue;
			}",4,,89,2,,void
47246,BLOCK,-1,,"{
				current = std::make_shared<PropertyResourceBundle>(bundleStream);
			}",4,,94,1,,void
47256,BLOCK,2,,"{
				throw;
			}",4,,98,2,,void
47262,BLOCK,-1,,"{
			resourceBundle = current;
			previous = current;
		}",3,,105,2,,void
47270,BLOCK,-1,,"{
			previous->setParent(current);
			previous = current;
		}",3,,110,1,,void
47283,BLOCK,-1,,"{
		throw MissingResourceException(
			((LogString) LOG4CXX_STR(""Missing resource bundle "")) + baseName);
	}",2,,118,2,,void
47326,BLOCK,-1,,<empty>,1,,1,1,,ANY
47329,BLOCK,-1,,<empty>,17,,41,1,,void
47339,BLOCK,-1,,"{
}",1,,74,1,,void
47345,BLOCK,-1,,"{
	if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""MAXFILESIZE""), LOG4CXX_STR(""maxfilesize""))
		|| StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""MAXIMUMFILESIZE""), LOG4CXX_STR(""maximumfilesize"")))
	{
		setMaxFileSize(value);
	}
	else if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""MAXBACKUPINDEX""), LOG4CXX_STR(""maxbackupindex""))
		|| StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""MAXIMUMBACKUPINDEX""), LOG4CXX_STR(""maximumbackupindex"")))
	{
		setMaxBackupIndex(StringHelper::toInt(value));
	}
	else if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""FILEDATEPATTERN""), LOG4CXX_STR(""filedatepattern"")))
	{
		setDatePattern(value);
	}
	else
	{
		FileAppender::setOption(option, value);
	}
}",1,,78,3,,void
47366,BLOCK,-1,,"{
		setMaxFileSize(value);
	}",2,,83,2,,void
47370,BLOCK,-1,,<empty>,7,,86,1,,void
47391,BLOCK,-1,,"{
		setMaxBackupIndex(StringHelper::toInt(value));
	}",2,,90,2,,void
47399,BLOCK,-1,,<empty>,7,,93,1,,void
47410,BLOCK,-1,,"{
		setDatePattern(value);
	}",2,,95,2,,void
47414,BLOCK,-1,,"{
		FileAppender::setOption(option, value);
	}",2,,99,1,,void
47424,BLOCK,-1,,"{
	int result = 1;
	if (auto fwrp = LOG4CXX_NS::cast<FixedWindowRollingPolicy>(_priv->rollingPolicy))
		result = fwrp->getMaxIndex();
	return result;
}",1,,105,1,,void
47430,BLOCK,-1,,<empty>,6,,107,1,,void
47441,BLOCK,1,,<empty>,,,,1,,void
47450,BLOCK,-1,,<empty>,3,,108,2,,void
47463,BLOCK,-1,,"{
	auto fwrp = LOG4CXX_NS::cast<FixedWindowRollingPolicy>(_priv->rollingPolicy);
	if (!fwrp)
	{
		fwrp = std::make_shared<FixedWindowRollingPolicy>();
		fwrp->setFileNamePattern(getFile() + LOG4CXX_STR("".%i""));
		_priv->rollingPolicy = fwrp;
	}
	fwrp->setMaxIndex(maxBackups);
}",1,,113,2,,void
47474,BLOCK,1,,<empty>,,,,1,,void
47486,BLOCK,-1,,"{
		fwrp = std::make_shared<FixedWindowRollingPolicy>();
		fwrp->setFileNamePattern(getFile() + LOG4CXX_STR("".%i""));
		_priv->rollingPolicy = fwrp;
	}",2,,116,2,,void
47503,BLOCK,1,,<empty>,,,,1,,void
47521,BLOCK,-1,,"{
	size_t result = 10 * 1024 * 1024;
	if (auto sbtp = LOG4CXX_NS::cast<SizeBasedTriggeringPolicy>(_priv->triggeringPolicy))
		result = sbtp->getMaxFileSize();
	return result;
}",1,,125,1,,void
47531,BLOCK,-1,,<empty>,6,,127,1,,void
47542,BLOCK,1,,<empty>,,,,1,,void
47551,BLOCK,-1,,<empty>,3,,128,2,,void
47564,BLOCK,-1,,"{
	auto sbtp = LOG4CXX_NS::cast<SizeBasedTriggeringPolicy>(_priv->triggeringPolicy);
	if (!sbtp)
	{
		sbtp = std::make_shared<SizeBasedTriggeringPolicy>();
		_priv->triggeringPolicy = sbtp;
	}
	sbtp->setMaxFileSize(maxFileSize);
}",1,,133,2,,void
47575,BLOCK,1,,<empty>,,,,1,,void
47587,BLOCK,-1,,"{
		sbtp = std::make_shared<SizeBasedTriggeringPolicy>();
		_priv->triggeringPolicy = sbtp;
	}",2,,136,2,,void
47596,BLOCK,1,,<empty>,,,,1,,void
47615,BLOCK,-1,,"{
	setMaximumFileSize(OptionConverter::toFileSize(value, long(getMaximumFileSize() + 1)));
}",1,,144,2,,void
47631,BLOCK,-1,,"{
	LogString result(getFile());
	bool inLiteral = false;
	bool inPattern = false;

	for (size_t i = 0; i < datePattern.length(); i++)
	{
		if (datePattern[i] == 0x27 /* '\'' */)
		{
			inLiteral = !inLiteral;

			if (inLiteral && inPattern)
			{
				result.append(1, (logchar) 0x7D /* '}' */);
				inPattern = false;
			}
		}
		else
		{
			if (!inLiteral && !inPattern)
			{
				const logchar dbrace[] = { 0x25, 0x64, 0x7B, 0 }; // ""%d{""
				result.append(dbrace);
				inPattern = true;
			}

			result.append(1, datePattern[i]);
		}
	}

	if (inPattern)
	{
		result.append(1, (logchar) 0x7D /* '}' */);
	}
	return result;
}",1,,149,2,,void
47644,BLOCK,-1,,<empty>,2,,154,1,,void
47657,BLOCK,4,,"{
		if (datePattern[i] == 0x27 /* '\'' */)
		{
			inLiteral = !inLiteral;

			if (inLiteral && inPattern)
			{
				result.append(1, (logchar) 0x7D /* '}' */);
				inPattern = false;
			}
		}
		else
		{
			if (!inLiteral && !inPattern)
			{
				const logchar dbrace[] = { 0x25, 0x64, 0x7B, 0 }; // ""%d{""
				result.append(dbrace);
				inPattern = true;
			}

			result.append(1, datePattern[i]);
		}
	}",2,,155,4,,void
47664,BLOCK,-1,,"{
			inLiteral = !inLiteral;

			if (inLiteral && inPattern)
			{
				result.append(1, (logchar) 0x7D /* '}' */);
				inPattern = false;
			}
		}",3,,157,2,,void
47673,BLOCK,-1,,"{
				result.append(1, (logchar) 0x7D /* '}' */);
				inPattern = false;
			}",4,,161,2,,void
47686,BLOCK,-1,,"{
			if (!inLiteral && !inPattern)
			{
				const logchar dbrace[] = { 0x25, 0x64, 0x7B, 0 }; // ""%d{""
				result.append(dbrace);
				inPattern = true;
			}

			result.append(1, datePattern[i]);
		}",3,,167,1,,void
47693,BLOCK,-1,,"{
				const logchar dbrace[] = { 0x25, 0x64, 0x7B, 0 }; // ""%d{""
				result.append(dbrace);
				inPattern = true;
			}",4,,169,2,,void
47720,BLOCK,-1,,"{
		result.append(1, (logchar) 0x7D /* '}' */);
	}",2,,180,2,,void
47735,BLOCK,-1,,"{
	auto tbrp = LOG4CXX_NS::cast<TimeBasedRollingPolicy>(_priv->rollingPolicy);
	if (!tbrp)
	{
		tbrp = std::make_shared<TimeBasedRollingPolicy>();
		_priv->rollingPolicy = tbrp;
	}
	tbrp->setFileNamePattern(makeFileNamePattern(newPattern));
}",1,,187,2,,void
47746,BLOCK,1,,<empty>,,,,1,,void
47758,BLOCK,-1,,"{
		tbrp = std::make_shared<TimeBasedRollingPolicy>();
		_priv->rollingPolicy = tbrp;
	}",2,,190,2,,void
47767,BLOCK,1,,<empty>,,,,1,,void
47787,BLOCK,-1,,"{
	if (!_priv->rollingPolicy)
	{
		LogLog::warn(LOG4CXX_STR(""No rolling policy configured for the appender named ["")
			+ _priv->name + LOG4CXX_STR(""].""));
		auto fwrp = std::make_shared<FixedWindowRollingPolicy>();
		fwrp->setFileNamePattern(getFile() + LOG4CXX_STR("".%i""));
		_priv->rollingPolicy = fwrp;
	}

	//
	//  if no explicit triggering policy and rolling policy is both.
	//
	if (!_priv->triggeringPolicy)
	{
		TriggeringPolicyPtr trig = LOG4CXX_NS::cast<TriggeringPolicy>(_priv->rollingPolicy);

		if (trig != NULL)
		{
			_priv->triggeringPolicy = trig;
		}
	}

	if (!_priv->triggeringPolicy)
	{
		LogLog::warn(LOG4CXX_STR(""No triggering policy configured for the appender named ["")
			+ _priv->name + LOG4CXX_STR(""].""));
		_priv->triggeringPolicy = std::make_shared<SizeBasedTriggeringPolicy>();
	}

	{
		std::lock_guard<std::recursive_mutex> lock(_priv->mutex);
		_priv->triggeringPolicy->activateOptions(p);
		_priv->rollingPolicy->activateOptions(p);

		try
		{
			RolloverDescript...",1,,201,2,,void
47791,BLOCK,1,,<empty>,,,,1,,void
47800,BLOCK,-1,,"{
		LogLog::warn(LOG4CXX_STR(""No rolling policy configured for the appender named ["")
			+ _priv->name + LOG4CXX_STR(""].""));
		auto fwrp = std::make_shared<FixedWindowRollingPolicy>();
		fwrp->setFileNamePattern(getFile() + LOG4CXX_STR("".%i""));
		_priv->rollingPolicy = fwrp;
	}",2,,203,2,,void
47810,BLOCK,1,,<empty>,,,,1,,void
47838,BLOCK,1,,<empty>,,,,1,,void
47851,BLOCK,1,,<empty>,,,,1,,void
47860,BLOCK,-1,,"{
		TriggeringPolicyPtr trig = LOG4CXX_NS::cast<TriggeringPolicy>(_priv->rollingPolicy);

		if (trig != NULL)
		{
			_priv->triggeringPolicy = trig;
		}
	}",2,,215,2,,void
47871,BLOCK,1,,<empty>,,,,1,,void
47884,BLOCK,-1,,"{
			_priv->triggeringPolicy = trig;
		}",3,,219,2,,void
47887,BLOCK,1,,<empty>,,,,1,,void
47900,BLOCK,1,,<empty>,,,,1,,void
47909,BLOCK,-1,,"{
		LogLog::warn(LOG4CXX_STR(""No triggering policy configured for the appender named ["")
			+ _priv->name + LOG4CXX_STR(""].""));
		_priv->triggeringPolicy = std::make_shared<SizeBasedTriggeringPolicy>();
	}",2,,225,2,,void
47919,BLOCK,1,,<empty>,,,,1,,void
47932,BLOCK,1,,<empty>,,,,1,,void
47945,BLOCK,4,,"{
		std::lock_guard<std::recursive_mutex> lock(_priv->mutex);
		_priv->triggeringPolicy->activateOptions(p);
		_priv->rollingPolicy->activateOptions(p);

		try
		{
			RolloverDescriptionPtr rollover1 =
				_priv->rollingPolicy->initialize(getFile(), getAppend(), p);

			if (rollover1 != NULL)
			{
				ActionPtr syncAction(rollover1->getSynchronous());

				if (syncAction != NULL)
				{
					syncAction->execute(p);
				}

				_priv->fileName = rollover1->getActiveFileName();
				_priv->fileAppend = rollover1->getAppend();

				//
				//  async action not yet implemented
				//
				ActionPtr asyncAction(rollover1->getAsynchronous());

				if (asyncAction != NULL)
				{
					asyncAction->execute(p);
				}
			}

			File activeFile;
			activeFile.setPath(getFile());

			if (getAppend())
			{
				_priv->fileLength = activeFile.length(p);
			}
			else
			{
				_priv->fileLength = 0;
			}

			FileAppender::activateOptionsInternal(p);
		}
		catch (std::exception&)
		{
			LogLog::warn(
				Lo...",2,,231,4,,void
47956,BLOCK,1,,<empty>,,,,1,,void
47966,BLOCK,1,,<empty>,,,,1,,void
47980,BLOCK,1,,<empty>,,,,1,,void
47994,BLOCK,-1,,"{
			RolloverDescriptionPtr rollover1 =
				_priv->rollingPolicy->initialize(getFile(), getAppend(), p);

			if (rollover1 != NULL)
			{
				ActionPtr syncAction(rollover1->getSynchronous());

				if (syncAction != NULL)
				{
					syncAction->execute(p);
				}

				_priv->fileName = rollover1->getActiveFileName();
				_priv->fileAppend = rollover1->getAppend();

				//
				//  async action not yet implemented
				//
				ActionPtr asyncAction(rollover1->getAsynchronous());

				if (asyncAction != NULL)
				{
					asyncAction->execute(p);
				}
			}

			File activeFile;
			activeFile.setPath(getFile());

			if (getAppend())
			{
				_priv->fileLength = activeFile.length(p);
			}
			else
			{
				_priv->fileLength = 0;
			}

			FileAppender::activateOptionsInternal(p);
		}",3,,237,1,,void
47999,BLOCK,1,,<empty>,,,,1,,void
48018,BLOCK,-1,,"{
				ActionPtr syncAction(rollover1->getSynchronous());

				if (syncAction != NULL)
				{
					syncAction->execute(p);
				}

				_priv->fileName = rollover1->getActiveFileName();
				_priv->fileAppend = rollover1->getAppend();

				//
				//  async action not yet implemented
				//
				ActionPtr asyncAction(rollover1->getAsynchronous());

				if (asyncAction != NULL)
				{
					asyncAction->execute(p);
				}
			}",4,,242,2,,void
48029,BLOCK,-1,,"{
					syncAction->execute(p);
				}",5,,246,2,,void
48037,BLOCK,1,,<empty>,,,,1,,void
48052,BLOCK,1,,<empty>,,,,1,,void
48075,BLOCK,-1,,"{
					asyncAction->execute(p);
				}",5,,259,2,,void
48089,BLOCK,-1,,"{
				_priv->fileLength = activeFile.length(p);
			}",4,,268,2,,void
48092,BLOCK,1,,<empty>,,,,1,,void
48107,BLOCK,-1,,"{
				_priv->fileLength = 0;
			}",4,,272,1,,void
48110,BLOCK,1,,<empty>,,,,1,,void
48125,BLOCK,2,,"{
			LogLog::warn(
				LogString(LOG4CXX_STR(""Exception will initializing RollingFileAppender named ""))
				+ getName());
		}",3,,279,2,,void
48139,BLOCK,-1,,"{
	std::lock_guard<std::recursive_mutex> lock(_priv->mutex);
	return rolloverInternal(p);
}",1,,303,2,,void
48150,BLOCK,1,,<empty>,,,,1,,void
48166,BLOCK,-1,,"{
	//
	//   can't roll without a policy
	//
	if (_priv->rollingPolicy != NULL)
	{

		{
				try
				{
					RolloverDescriptionPtr rollover1(_priv->rollingPolicy->rollover(this->getFile(), this->getAppend(), p));

					if (rollover1 != NULL)
					{
						if (rollover1->getActiveFileName() == getFile())
						{
							closeWriter();

							bool success = true;

							if (rollover1->getSynchronous() != NULL)
							{
								success = false;

								try
								{
									success = rollover1->getSynchronous()->execute(p);
								}
								catch (std::exception& ex)
								{
									LOG4CXX_DECODE_CHAR(lsMsg, ex.what());
									LogString errorMsg = LOG4CXX_STR(""Exception on rollover: "");
									errorMsg.append(lsMsg);
									LogLog::error(errorMsg);
									_priv->errorHandler->error(lsMsg, ex, 0);
								}
							}

							if (success)
							{
								if (rollover1->getAppend())
								{
									_priv->fileLength = File().setPath(rollover1->getActiveFileName()).length(p...",1,,309,2,,void
48170,BLOCK,1,,<empty>,,,,1,,void
48180,BLOCK,-1,,"{

		{
				try
				{
					RolloverDescriptionPtr rollover1(_priv->rollingPolicy->rollover(this->getFile(), this->getAppend(), p));

					if (rollover1 != NULL)
					{
						if (rollover1->getActiveFileName() == getFile())
						{
							closeWriter();

							bool success = true;

							if (rollover1->getSynchronous() != NULL)
							{
								success = false;

								try
								{
									success = rollover1->getSynchronous()->execute(p);
								}
								catch (std::exception& ex)
								{
									LOG4CXX_DECODE_CHAR(lsMsg, ex.what());
									LogString errorMsg = LOG4CXX_STR(""Exception on rollover: "");
									errorMsg.append(lsMsg);
									LogLog::error(errorMsg);
									_priv->errorHandler->error(lsMsg, ex, 0);
								}
							}

							if (success)
							{
								if (rollover1->getAppend())
								{
									_priv->fileLength = File().setPath(rollover1->getActiveFileName()).length(p);
								}
								else
								{
									_priv->fileLength = 0;
								}

	...",2,,314,2,,void
48181,BLOCK,1,,"{
				try
				{
					RolloverDescriptionPtr rollover1(_priv->rollingPolicy->rollover(this->getFile(), this->getAppend(), p));

					if (rollover1 != NULL)
					{
						if (rollover1->getActiveFileName() == getFile())
						{
							closeWriter();

							bool success = true;

							if (rollover1->getSynchronous() != NULL)
							{
								success = false;

								try
								{
									success = rollover1->getSynchronous()->execute(p);
								}
								catch (std::exception& ex)
								{
									LOG4CXX_DECODE_CHAR(lsMsg, ex.what());
									LogString errorMsg = LOG4CXX_STR(""Exception on rollover: "");
									errorMsg.append(lsMsg);
									LogLog::error(errorMsg);
									_priv->errorHandler->error(lsMsg, ex, 0);
								}
							}

							if (success)
							{
								if (rollover1->getAppend())
								{
									_priv->fileLength = File().setPath(rollover1->getActiveFileName()).length(p);
								}
								else
								{
									_priv->fileLength = 0;
								}

						...",3,,316,1,,void
48183,BLOCK,-1,,"{
					RolloverDescriptionPtr rollover1(_priv->rollingPolicy->rollover(this->getFile(), this->getAppend(), p));

					if (rollover1 != NULL)
					{
						if (rollover1->getActiveFileName() == getFile())
						{
							closeWriter();

							bool success = true;

							if (rollover1->getSynchronous() != NULL)
							{
								success = false;

								try
								{
									success = rollover1->getSynchronous()->execute(p);
								}
								catch (std::exception& ex)
								{
									LOG4CXX_DECODE_CHAR(lsMsg, ex.what());
									LogString errorMsg = LOG4CXX_STR(""Exception on rollover: "");
									errorMsg.append(lsMsg);
									LogLog::error(errorMsg);
									_priv->errorHandler->error(lsMsg, ex, 0);
								}
							}

							if (success)
							{
								if (rollover1->getAppend())
								{
									_priv->fileLength = File().setPath(rollover1->getActiveFileName()).length(p);
								}
								else
								{
									_priv->fileLength = 0;
								}

								//
								/...",5,,318,1,,void
48187,BLOCK,1,,<empty>,,,,1,,void
48212,BLOCK,-1,,"{
						if (rollover1->getActiveFileName() == getFile())
						{
							closeWriter();

							bool success = true;

							if (rollover1->getSynchronous() != NULL)
							{
								success = false;

								try
								{
									success = rollover1->getSynchronous()->execute(p);
								}
								catch (std::exception& ex)
								{
									LOG4CXX_DECODE_CHAR(lsMsg, ex.what());
									LogString errorMsg = LOG4CXX_STR(""Exception on rollover: "");
									errorMsg.append(lsMsg);
									LogLog::error(errorMsg);
									_priv->errorHandler->error(lsMsg, ex, 0);
								}
							}

							if (success)
							{
								if (rollover1->getAppend())
								{
									_priv->fileLength = File().setPath(rollover1->getActiveFileName()).length(p);
								}
								else
								{
									_priv->fileLength = 0;
								}

								//
								//  async action not yet implemented
								//
								ActionPtr asyncAction(rollover1->getAsynchronous());

								if (asyncAction != NULL)
				...",6,,322,2,,void
48220,BLOCK,-1,,"{
							closeWriter();

							bool success = true;

							if (rollover1->getSynchronous() != NULL)
							{
								success = false;

								try
								{
									success = rollover1->getSynchronous()->execute(p);
								}
								catch (std::exception& ex)
								{
									LOG4CXX_DECODE_CHAR(lsMsg, ex.what());
									LogString errorMsg = LOG4CXX_STR(""Exception on rollover: "");
									errorMsg.append(lsMsg);
									LogLog::error(errorMsg);
									_priv->errorHandler->error(lsMsg, ex, 0);
								}
							}

							if (success)
							{
								if (rollover1->getAppend())
								{
									_priv->fileLength = File().setPath(rollover1->getActiveFileName()).length(p);
								}
								else
								{
									_priv->fileLength = 0;
								}

								//
								//  async action not yet implemented
								//
								ActionPtr asyncAction(rollover1->getAsynchronous());

								if (asyncAction != NULL)
								{
									asyncAction->execute(p);
								}

								setF...",7,,324,2,,void
48233,BLOCK,-1,,"{
								success = false;

								try
								{
									success = rollover1->getSynchronous()->execute(p);
								}
								catch (std::exception& ex)
								{
									LOG4CXX_DECODE_CHAR(lsMsg, ex.what());
									LogString errorMsg = LOG4CXX_STR(""Exception on rollover: "");
									errorMsg.append(lsMsg);
									LogLog::error(errorMsg);
									_priv->errorHandler->error(lsMsg, ex, 0);
								}
							}",8,,330,2,,void
48238,BLOCK,-1,,"{
									success = rollover1->getSynchronous()->execute(p);
								}",9,,334,1,,void
48249,BLOCK,2,,"{
									LOG4CXX_DECODE_CHAR(lsMsg, ex.what());
									LogString errorMsg = LOG4CXX_STR(""Exception on rollover: "");
									errorMsg.append(lsMsg);
									LogLog::error(errorMsg);
									_priv->errorHandler->error(lsMsg, ex, 0);
								}",9,,338,2,,void
48272,BLOCK,1,,<empty>,,,,1,,void
48289,BLOCK,-1,,"{
								if (rollover1->getAppend())
								{
									_priv->fileLength = File().setPath(rollover1->getActiveFileName()).length(p);
								}
								else
								{
									_priv->fileLength = 0;
								}

								//
								//  async action not yet implemented
								//
								ActionPtr asyncAction(rollover1->getAsynchronous());

								if (asyncAction != NULL)
								{
									asyncAction->execute(p);
								}

								setFileInternal(
									rollover1->getActiveFileName(), rollover1->getAppend(),
									_priv->bufferedIO, _priv->bufferSize, p);
							}",8,,348,2,,void
48295,BLOCK,-1,,"{
									_priv->fileLength = File().setPath(rollover1->getActiveFileName()).length(p);
								}",9,,350,2,,void
48298,BLOCK,1,,<empty>,,,,1,,void
48320,BLOCK,-1,,"{
									_priv->fileLength = 0;
								}",9,,354,1,,void
48323,BLOCK,1,,<empty>,,,,1,,void
48343,BLOCK,-1,,"{
									asyncAction->execute(p);
								}",9,,364,2,,void
48359,BLOCK,1,,<empty>,,,,1,,void
48369,BLOCK,1,,<empty>,,,,1,,void
48380,BLOCK,-1,,"{
								setFileInternal(
									rollover1->getActiveFileName(), true, _priv->bufferedIO, _priv->bufferSize, p);
							}",8,,373,1,,void
48388,BLOCK,1,,<empty>,,,,1,,void
48398,BLOCK,1,,<empty>,,,,1,,void
48409,BLOCK,-1,,"{
							closeWriter();
							setFileInternal(rollover1->getActiveFileName());
							// Call activateOptions to create any intermediate directories(if required)
							FileAppender::activateOptionsInternal(p);
							OutputStreamPtr os(new FileOutputStream(
									rollover1->getActiveFileName(), rollover1->getAppend()));
							WriterPtr newWriter(createWriter(os));
							setWriterInternal(newWriter);

							bool success = true;

							if (rollover1->getSynchronous() != NULL)
							{
								success = false;

								try
								{
									success = rollover1->getSynchronous()->execute(p);
								}
								catch (std::exception& ex)
								{
									LOG4CXX_DECODE_CHAR(lsMsg, ex.what());
									LogString errorMsg = LOG4CXX_STR(""Exception during rollover: "");
									errorMsg.append(lsMsg);
									LogLog::warn(errorMsg);
									_priv->errorHandler->error(lsMsg, ex, 0);
								}
							}

							if (success)
							{
								if (rollover1->getAppend())
								{
			...",7,,379,1,,void
48450,BLOCK,-1,,"{
								success = false;

								try
								{
									success = rollover1->getSynchronous()->execute(p);
								}
								catch (std::exception& ex)
								{
									LOG4CXX_DECODE_CHAR(lsMsg, ex.what());
									LogString errorMsg = LOG4CXX_STR(""Exception during rollover: "");
									errorMsg.append(lsMsg);
									LogLog::warn(errorMsg);
									_priv->errorHandler->error(lsMsg, ex, 0);
								}
							}",8,,392,2,,void
48455,BLOCK,-1,,"{
									success = rollover1->getSynchronous()->execute(p);
								}",9,,396,1,,void
48466,BLOCK,2,,"{
									LOG4CXX_DECODE_CHAR(lsMsg, ex.what());
									LogString errorMsg = LOG4CXX_STR(""Exception during rollover: "");
									errorMsg.append(lsMsg);
									LogLog::warn(errorMsg);
									_priv->errorHandler->error(lsMsg, ex, 0);
								}",9,,400,2,,void
48489,BLOCK,1,,<empty>,,,,1,,void
48506,BLOCK,-1,,"{
								if (rollover1->getAppend())
								{
									_priv->fileLength = File().setPath(rollover1->getActiveFileName()).length(p);
								}
								else
								{
									_priv->fileLength = 0;
								}

								//
								//   async action not yet implemented
								//
								ActionPtr asyncAction(rollover1->getAsynchronous());

								if (asyncAction != NULL)
								{
									asyncAction->execute(p);
								}
							}",8,,410,2,,void
48512,BLOCK,-1,,"{
									_priv->fileLength = File().setPath(rollover1->getActiveFileName()).length(p);
								}",9,,412,2,,void
48515,BLOCK,1,,<empty>,,,,1,,void
48537,BLOCK,-1,,"{
									_priv->fileLength = 0;
								}",9,,416,1,,void
48540,BLOCK,1,,<empty>,,,,1,,void
48560,BLOCK,-1,,"{
									asyncAction->execute(p);
								}",9,,426,2,,void
48570,BLOCK,2,,"{
					LOG4CXX_DECODE_CHAR(lsMsg, ex.what());
					LogString errorMsg = LOG4CXX_STR(""Exception during rollover: "");
					errorMsg.append(lsMsg);
					LogLog::warn(errorMsg);
					_priv->errorHandler->error(lsMsg, ex, 0);
				}",5,,437,2,,void
48593,BLOCK,1,,<empty>,,,,1,,void
48615,BLOCK,-1,,"{
	// The rollover check must precede actual writing. This is the
	// only correct behavior for time driven triggers.
	if (
		_priv->triggeringPolicy->isTriggeringEvent(
			this, event, getFile(), getFileLength()))
	{
		//
		//   wrap rollover request in try block since
		//    rollover may fail in case read access to directory
		//    is not provided.  However appender should still be in good
		//     condition and the append should still happen.
		try
		{
			_priv->_event = event;
			rolloverInternal(p);
		}
		catch (std::exception& ex)
		{
			LOG4CXX_DECODE_CHAR(lsMsg, ex.what());
			LogString errorMsg = LOG4CXX_STR(""Exception during rollover attempt: "");
			errorMsg.append(lsMsg);
			LogLog::warn(errorMsg);
			_priv->errorHandler->error(lsMsg);
		}
	}

	FileAppender::subAppend(event, p);
}",1,,454,3,,void
48618,BLOCK,1,,<empty>,,,,1,,void
48634,BLOCK,-1,,"{
		//
		//   wrap rollover request in try block since
		//    rollover may fail in case read access to directory
		//    is not provided.  However appender should still be in good
		//     condition and the append should still happen.
		try
		{
			_priv->_event = event;
			rolloverInternal(p);
		}
		catch (std::exception& ex)
		{
			LOG4CXX_DECODE_CHAR(lsMsg, ex.what());
			LogString errorMsg = LOG4CXX_STR(""Exception during rollover attempt: "");
			errorMsg.append(lsMsg);
			LogLog::warn(errorMsg);
			_priv->errorHandler->error(lsMsg);
		}
	}",2,,460,2,,void
48636,BLOCK,-1,,"{
			_priv->_event = event;
			rolloverInternal(p);
		}",3,,467,1,,void
48639,BLOCK,1,,<empty>,,,,1,,void
48651,BLOCK,2,,"{
			LOG4CXX_DECODE_CHAR(lsMsg, ex.what());
			LogString errorMsg = LOG4CXX_STR(""Exception during rollover attempt: "");
			errorMsg.append(lsMsg);
			LogLog::warn(errorMsg);
			_priv->errorHandler->error(lsMsg);
		}",3,,472,2,,void
48674,BLOCK,1,,<empty>,,,,1,,void
48696,BLOCK,-1,,"{
	return _priv->rollingPolicy;
}",1,,488,1,,void
48699,BLOCK,1,,<empty>,,,,1,,void
48711,BLOCK,-1,,"{
	return _priv->triggeringPolicy;
}",1,,496,1,,void
48714,BLOCK,1,,<empty>,,,,1,,void
48727,BLOCK,-1,,"{
	_priv->rollingPolicy = policy;
}",1,,504,2,,void
48730,BLOCK,1,,<empty>,,,,1,,void
48744,BLOCK,-1,,"{
	_priv->triggeringPolicy = policy;
}",1,,512,2,,void
48747,BLOCK,1,,<empty>,,,,1,,void
48760,BLOCK,-1,,"{
	FileAppender::close();
}",1,,520,1,,void
48775,BLOCK,-1,,"{
		}",3,,554,3,,void
48780,BLOCK,-1,,"{
			os->close(p);
			rfa = 0;
		}",3,,561,2,,void
48793,BLOCK,-1,,"{
			os->flush(p);
		}",3,,570,2,,void
48804,BLOCK,-1,,"{
			os->write(buf, p);

			if (rfa != 0)
			{
				rfa->incrementFileLength(buf.limit());
			}
		}",3,,578,3,,void
48815,BLOCK,-1,,"{
				rfa->incrementFileLength(buf.limit());
			}",4,,582,2,,void
48828,BLOCK,-1,,"{
	OutputStreamPtr cos = std::make_shared<CountingOutputStream>(os, this);
	return FileAppender::createWriter(cos);
}",1,,600,2,,void
48851,BLOCK,-1,,"{
	return _priv->fileLength;
}",1,,610,1,,void
48854,BLOCK,1,,<empty>,,,,1,,void
48867,BLOCK,-1,,"{
	_priv->fileLength += increment;
}",1,,619,2,,void
48870,BLOCK,1,,<empty>,,,,1,,void
48888,BLOCK,-1,,<empty>,1,,1,1,,ANY
48916,BLOCK,-1,,<empty>,1,,1,1,,ANY
48920,BLOCK,-1,,"{
}",1,,39,1,,void
48925,BLOCK,-1,,"{
}",25,,43,2,,void
48929,BLOCK,-1,,"{
}",1,,47,1,,void
48934,BLOCK,-1,,"{
	if (m_priv->fileNamePatternStr.length() > 0)
	{
		parseFileNamePattern();
	}
	else
	{
		LogString msg(LOG4CXX_STR(""The FileNamePattern option must be set before using FixedWindowRollingPolicy.""));
		LogString ref1(LOG4CXX_STR(""See also http://logging.apache.org/log4j/codes.html#tbr_fnp_not_set""));
		LogLog::warn(msg);
		LogLog::warn(ref1);
		throw IllegalStateException();
	}
}",1,,51,2,,void
48944,BLOCK,-1,,"{
		parseFileNamePattern();
	}",2,,53,2,,void
48947,BLOCK,-1,,"{
		LogString msg(LOG4CXX_STR(""The FileNamePattern option must be set before using FixedWindowRollingPolicy.""));
		LogString ref1(LOG4CXX_STR(""See also http://logging.apache.org/log4j/codes.html#tbr_fnp_not_set""));
		LogLog::warn(msg);
		LogLog::warn(ref1);
		throw IllegalStateException();
	}",2,,57,1,,void
48973,BLOCK,-1,,"{
	if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""FILENAMEPATTERN""),
			LOG4CXX_STR(""filenamepattern"")))
	{
		m_priv->fileNamePatternStr = value;
	}else if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""CREATEINTERMEDIATEDIRECTORIES""),
			LOG4CXX_STR(""createintermediatedirectories"")))
	{
		m_priv->createIntermediateDirectories = OptionConverter::toBoolean(value, false);
	}
}",1,,68,3,,void
48984,BLOCK,-1,,"{
		m_priv->fileNamePatternStr = value;
	}",2,,72,2,,void
48991,BLOCK,-1,,<empty>,8,,74,1,,void
49002,BLOCK,-1,,"{
		m_priv->createIntermediateDirectories = OptionConverter::toBoolean(value, false);
	}",2,,77,2,,void
49017,BLOCK,-1,,"{
	m_priv->fileNamePatternStr = fnp;
}",1,,83,2,,void
49026,BLOCK,-1,,"{
	return m_priv->fileNamePatternStr;
}",1,,89,1,,void
49034,BLOCK,-1,,"{
	m_priv->patternConverters.erase(m_priv->patternConverters.begin(), m_priv->patternConverters.end());
	m_priv->patternFields.erase(m_priv->patternFields.begin(), m_priv->patternFields.end());
	PatternParser::parse(m_priv->fileNamePatternStr,
		m_priv->patternConverters,
		m_priv->patternFields,
		getFormatSpecifiers());
}",1,,97,1,,void
49091,BLOCK,-1,,"{
	std::vector<FormattingInfoPtr>::const_iterator formatterIter =
		m_priv->patternFields.begin();

	for (std::vector<PatternConverterPtr>::const_iterator
		converterIter = m_priv->patternConverters.begin();
		converterIter != m_priv->patternConverters.end();
		converterIter++, formatterIter++)
	{
		auto startField = toAppendTo.length();
		(*converterIter)->format(obj, toAppendTo, pool);
		(*formatterIter)->format((int)startField, toAppendTo);
	}
}",1,,116,4,,void
49102,BLOCK,-1,,<empty>,2,,120,1,,void
49125,BLOCK,4,,"{
		auto startField = toAppendTo.length();
		(*converterIter)->format(obj, toAppendTo, pool);
		(*formatterIter)->format((int)startField, toAppendTo);
	}",2,,124,4,,void
49153,BLOCK,-1,,"{
	for (std::vector<PatternConverterPtr>::const_iterator
		converterIter = m_priv->patternConverters.begin();
		converterIter != m_priv->patternConverters.end();
		converterIter++)
	{
		IntegerPatternConverterPtr intPattern;
		PatternConverterPtr patternptr = (*converterIter);
		intPattern = LOG4CXX_NS::cast<IntegerPatternConverter>(patternptr);

		if (intPattern != NULL)
		{
			return *converterIter;
		}
	}

	PatternConverterPtr noMatch;
	return noMatch;
}",1,,133,1,,void
49155,BLOCK,-1,,<empty>,2,,134,1,,void
49175,BLOCK,4,,"{
		IntegerPatternConverterPtr intPattern;
		PatternConverterPtr patternptr = (*converterIter);
		intPattern = LOG4CXX_NS::cast<IntegerPatternConverter>(patternptr);

		if (intPattern != NULL)
		{
			return *converterIter;
		}
	}",2,,138,4,,void
49195,BLOCK,-1,,"{
			return *converterIter;
		}",3,,144,2,,void
49205,BLOCK,-1,,"{
	for (std::vector<PatternConverterPtr>::const_iterator
		converterIter = m_priv->patternConverters.begin();
		converterIter != m_priv->patternConverters.end();
		converterIter++)
	{
		DatePatternConverterPtr datePattern;
		PatternConverterPtr patternptr = (*converterIter);
		datePattern = LOG4CXX_NS::cast<DatePatternConverter>(patternptr);

		if (datePattern != NULL)
		{
			return *converterIter;
		}
	}

	PatternConverterPtr noMatch;
	return noMatch;
}",1,,154,1,,void
49207,BLOCK,-1,,<empty>,2,,155,1,,void
49227,BLOCK,4,,"{
		DatePatternConverterPtr datePattern;
		PatternConverterPtr patternptr = (*converterIter);
		datePattern = LOG4CXX_NS::cast<DatePatternConverter>(patternptr);

		if (datePattern != NULL)
		{
			return *converterIter;
		}
	}",2,,159,4,,void
49247,BLOCK,-1,,"{
			return *converterIter;
		}",3,,165,2,,void
49257,BLOCK,-1,,"{
	return m_priv->createIntermediateDirectories;
}",65,,174,1,,void
49266,BLOCK,-1,,"{
	m_priv->createIntermediateDirectories = createIntermediate;
}",82,,178,2,,void
49275,BLOCK,-1,,"{
	return m_priv->patternConverters;
}",1,,183,1,,void
49290,BLOCK,-1,,<empty>,1,,1,1,,ANY
49295,BLOCK,-1,,<empty>,30,,28,1,,void
49303,BLOCK,-1,,<empty>,2,,39,5,,void
49311,BLOCK,-1,,"{
}",1,,67,1,,void
49319,BLOCK,-1,,"{
}",1,,76,5,,void
49323,BLOCK,-1,,<empty>,44,,79,1,,void
49327,BLOCK,-1,,"{
	return m_priv->activeFileName;
}",1,,82,1,,void
49335,BLOCK,-1,,"{
	return m_priv->append;
}",1,,87,1,,void
49343,BLOCK,-1,,"{
	return m_priv->synchronous;
}",1,,92,1,,void
49351,BLOCK,-1,,"{
	return m_priv->asynchronous;
}",1,,103,1,,void
49372,BLOCK,-1,,<empty>,1,,1,1,,ANY
49376,BLOCK,-1,,"{
	setLevel(level1);
}",1,,29,3,,void
49382,BLOCK,-1,,"{
	return getLevel();
}",1,,34,1,,void
49389,BLOCK,-1,,"{
	if (level1 == 0)
	{
		LogLog::error(LOG4CXX_STR(""You have tried to set a null level to root.""));
	}
	else
	{
		Logger::setLevel(level1);
	}
}",1,,39,2,,void
49394,BLOCK,-1,,"{
		LogLog::error(LOG4CXX_STR(""You have tried to set a null level to root.""));
	}",2,,41,2,,void
49402,BLOCK,-1,,"{
		Logger::setLevel(level1);
	}",2,,45,1,,void
49420,BLOCK,-1,,<empty>,1,,1,1,,ANY
49423,BLOCK,-1,,"{
}",1,,28,2,,void
49427,BLOCK,-1,,"{
	close();
}",1,,32,1,,void
49432,BLOCK,-1,,"{
}",1,,37,1,,void
49436,BLOCK,-1,,"{
	return m_priv->timeout;
}",1,,43,1,,void
49445,BLOCK,-1,,"{
	m_priv->timeout = newVal;
}",1,,50,2,,void
49455,BLOCK,-1,,"{
	return std::make_unique<APRServerSocket>(port);
}",53,,54,2,,void
49478,BLOCK,-1,,<empty>,1,,1,1,,ANY
49482,BLOCK,-1,,"{
}",60,,32,1,,void
49487,BLOCK,-1,,"{
  static WideLife<PatternConverterPtr> instance(new ShortFileLocationPatternConverter());
  return instance;
}",52,,36,2,,void
49500,BLOCK,-1,,"{
  append(toAppendTo, event->getLocationInformation().getShortFileName());
}",28,,44,4,,void
49538,BLOCK,-1,,<empty>,1,,1,1,,ANY
49545,BLOCK,-1,,<empty>,,,,3,,<empty>
49550,BLOCK,-1,,"{
		}",3,,72,1,,void
49554,BLOCK,-1,,"{
		}",3,,76,1,,void
49559,BLOCK,-1,,"{
		}",3,,84,2,,void
49566,BLOCK,-1,,<empty>,,,,4,,<empty>
49572,BLOCK,-1,,"{
			time.tm_mon++;
			aprtime.tm_mon++;
		}",3,,100,3,,void
49586,BLOCK,-1,,"{
			time.tm_wday++;
			aprtime.tm_wday++;
		}",3,,106,3,,void
49600,BLOCK,-1,,"{
			time.tm_hour += 12;
			aprtime.tm_hour += 12;
		}",3,,112,3,,void
49620,BLOCK,-1,,"{
			std::vector<LogString>::iterator valueIter = values.begin();
			tm time;
			memset(&time, 0, sizeof(time));
			apr_time_exp_t aprtime;
			memset(&aprtime, 0, sizeof(aprtime));
#if LOG4CXX_HAS_STD_LOCALE

			if (locale != NULL)
			{
#if LOG4CXX_WCHAR_T_API

				if (HAS_FACET(*locale, std::time_put<wchar_t>))
				{
					const std::time_put<wchar_t>& facet = USE_FACET(*locale, std::time_put<wchar_t>);
					size_t start = 0;
					std::basic_ostringstream<wchar_t> os;

					for (; valueIter != values.end(); valueIter++)
					{
						PUT_FACET(facet, os, &time, (char)wspec);
						Transcoder::decode(os.str().substr(start), *valueIter);
						start = os.str().length();
						(*inc)(time, aprtime);
					}
				}
				else
#endif
					if (HAS_FACET(*locale,  std::time_put<char>))
					{
						const std::time_put<char>& facet = USE_FACET(*locale, std::time_put<char> );
						size_t start = 0;
						std::ostringstream os;

						for (; valueIter != values.end(); valueIter++)
						{
							...",3,,123,7,,void
49656,BLOCK,-1,,<empty>,4,,173,1,,void
49665,BLOCK,4,,"{
				apr_status_t stat = apr_strftime(buf, &retsize, BUFSIZE, aprspec, &aprtime);
				(*inc)(time, aprtime);

				if (stat == APR_SUCCESS)
				{
					Transcoder::decode(std::string(buf, retsize), *valueIter);
				}
				else
				{
					valueIter->append(1, (logchar) 0x3F);
				}
			}",4,,174,4,,void
49686,BLOCK,-1,,"{
					Transcoder::decode(std::string(buf, retsize), *valueIter);
				}",5,,179,2,,void
49700,BLOCK,-1,,"{
					valueIter->append(1, (logchar) 0x3F);
				}",5,,183,1,,void
49713,BLOCK,-1,,<empty>,,,,2,,<empty>
49718,BLOCK,-1,,<empty>,,,,2,,<empty>
49725,BLOCK,-1,,"{
		}",3,,206,3,,void
49732,BLOCK,-1,,"{
			s.append( count, ch );
		}",3,,210,4,,void
49747,BLOCK,-1,,"{
		}",3,,225,3,,void
49754,BLOCK,-1,,"{
			s.append(1, (logchar) 0x41 /* 'A' */);
			s.append(1, (logchar) 0x44 /* 'D' */);
		}",3,,229,4,,void
49776,BLOCK,-1,,"{
		}",3,,241,2,,void
49781,BLOCK,-1,,<empty>,,,,2,,<empty>
49788,BLOCK,-1,,"{
			size_t initialLength = s.length();

			StringHelper::toString( getField( tm ), p, s );
			size_t finalLength = s.length();

			if ( initialLength + width > finalLength )
			{
				s.insert( initialLength, ( initialLength + width ) - finalLength, (logchar) 0x30 /* '0' */);
			}
		}",3,,247,4,,void
49817,BLOCK,-1,,"{
				s.insert( initialLength, ( initialLength + width ) - finalLength, (logchar) 0x30 /* '0' */);
			}",4,,254,2,,void
49837,BLOCK,-1,,"{
		}",3,,269,2,,void
49842,BLOCK,-1,,"{
			return 1900 + tm.tm_year;
		}",3,,273,2,,void
49854,BLOCK,-1,,"{
		}",3,,284,2,,void
49859,BLOCK,-1,,"{
			return tm.tm_mon + 1;
		}",3,,288,2,,void
49872,BLOCK,-1,,"{
			renderFacet(locale, PatternToken::incrementMonth, 'b', 0x62, ""%b"", names);
		}",3,,299,3,,void
49888,BLOCK,-1,,"{
			s.append( names[tm.tm_mon] );
		}",3,,304,4,,void
49905,BLOCK,-1,,"{
			renderFacet(locale, PatternToken::incrementMonth, 'B', 0x42, ""%B"", names);
		}",3,,318,3,,void
49921,BLOCK,-1,,"{
			s.append( names[tm.tm_mon] );
		}",3,,323,4,,void
49937,BLOCK,-1,,"{
		}",3,,337,2,,void
49942,BLOCK,-1,,"{
			return tm.tm_yday / 7;
		}",3,,341,2,,void
49954,BLOCK,-1,,"{
		}",3,,352,2,,void
49959,BLOCK,-1,,"{
			return tm.tm_mday / 7;
		}",3,,356,2,,void
49971,BLOCK,-1,,"{
		}",3,,367,2,,void
49976,BLOCK,-1,,"{
			return tm.tm_mday;
		}",3,,371,2,,void
49986,BLOCK,-1,,"{
		}",3,,382,2,,void
49991,BLOCK,-1,,"{
			return tm.tm_yday;
		}",3,,386,2,,void
50001,BLOCK,-1,,"{
		}",3,,397,2,,void
50006,BLOCK,-1,,"{
			return -1;
		}",3,,401,2,,void
50016,BLOCK,-1,,"{
			renderFacet(locale, PatternToken::incrementDay, 'a', 0x61, ""%a"", names);
		}",3,,412,3,,void
50032,BLOCK,-1,,"{
			s.append( names[tm.tm_wday] );
		}",3,,417,4,,void
50049,BLOCK,-1,,"{
			renderFacet(locale, PatternToken::incrementDay, 'A', 0x41, ""%A"", names);
		}",3,,432,3,,void
50065,BLOCK,-1,,"{
			s.append( names[tm.tm_wday] );
		}",3,,437,4,,void
50082,BLOCK,-1,,"{
		}",3,,452,3,,void
50087,BLOCK,-1,,"{
			return tm.tm_hour + offset;
		}",3,,456,2,,void
50101,BLOCK,-1,,"{
		}",3,,470,3,,void
50106,BLOCK,-1,,"{
			return ( ( tm.tm_hour + 12 - offset ) % 12 ) + offset;
		}",3,,474,2,,void
50125,BLOCK,-1,,"{
		}",3,,488,2,,void
50130,BLOCK,-1,,"{
			return tm.tm_min;
		}",3,,492,2,,void
50140,BLOCK,-1,,"{
		}",3,,503,2,,void
50145,BLOCK,-1,,"{
			return tm.tm_sec;
		}",3,,507,2,,void
50155,BLOCK,-1,,"{
		}",3,,518,2,,void
50160,BLOCK,-1,,"{
			return tm.tm_usec / 1000;
		}",3,,522,2,,void
50172,BLOCK,-1,,"{
		}",3,,533,2,,void
50177,BLOCK,-1,,"{
			return tm.tm_usec;
		}",3,,537,2,,void
50188,BLOCK,-1,,"{
			renderFacet(locale, PatternToken::incrementHalfDay, 'p', 0x70, ""%p"", names);
		}",3,,548,3,,void
50204,BLOCK,-1,,"{
			s.append( names[tm.tm_hour / 12] );
		}",3,,553,4,,void
50222,BLOCK,-1,,"{
		}",3,,567,2,,void
50229,BLOCK,-1,,"{
			s.append(timeZone->getID());
		}",3,,571,4,,void
50242,BLOCK,-1,,"{
			timeZone = zone;
		}",3,,576,2,,void
50252,BLOCK,-1,,"{
		}",3,,590,2,,void
50259,BLOCK,-1,,"{
			if ( tm.tm_gmtoff == 0 )
			{
				s.append( 1, (logchar) 0x5A /* 'Z'  */ );
			}
			else
			{
				apr_int32_t off = tm.tm_gmtoff;
				size_t basePos = s.length();
				s.append( LOG4CXX_STR( ""+0000"" ) );

				if ( off < 0 )
				{
					s[basePos] = 0x2D; // '-'
					off = -off;
				}

				LogString hours;
				StringHelper::toString( off / 3600, p, hours );
				size_t hourPos = basePos + 2;

				//
				//   assumes that point values for 0-9 are same between char and wchar_t
				//
				for ( size_t i = hours.length(); i-- > 0; )
				{
					s[hourPos--] = hours[i];
				}

				LogString min;
				StringHelper::toString( ( off % 3600 ) / 60, p, min );
				size_t minPos = basePos + 4;

				//
				//   assumes that point values for 0-9 are same between char and wchar_t
				//
				for ( size_t j = min.length(); j-- > 0; )
				{
					s[minPos--] = min[j];
				}
			}
		}",3,,594,4,,void
50266,BLOCK,-1,,"{
				s.append( 1, (logchar) 0x5A /* 'Z'  */ );
			}",4,,596,2,,void
50276,BLOCK,-1,,"{
				apr_int32_t off = tm.tm_gmtoff;
				size_t basePos = s.length();
				s.append( LOG4CXX_STR( ""+0000"" ) );

				if ( off < 0 )
				{
					s[basePos] = 0x2D; // '-'
					off = -off;
				}

				LogString hours;
				StringHelper::toString( off / 3600, p, hours );
				size_t hourPos = basePos + 2;

				//
				//   assumes that point values for 0-9 are same between char and wchar_t
				//
				for ( size_t i = hours.length(); i-- > 0; )
				{
					s[hourPos--] = hours[i];
				}

				LogString min;
				StringHelper::toString( ( off % 3600 ) / 60, p, min );
				size_t minPos = basePos + 4;

				//
				//   assumes that point values for 0-9 are same between char and wchar_t
				//
				for ( size_t j = min.length(); j-- > 0; )
				{
					s[minPos--] = min[j];
				}
			}",4,,600,1,,void
50300,BLOCK,-1,,"{
					s[basePos] = 0x2D; // '-'
					off = -off;
				}",5,,606,2,,void
50327,BLOCK,-1,,<empty>,5,,618,1,,void
50339,BLOCK,4,,"{
					s[hourPos--] = hours[i];
				}",5,,619,4,,void
50367,BLOCK,-1,,<empty>,5,,630,1,,void
50379,BLOCK,4,,"{
					s[minPos--] = min[j];
				}",5,,631,4,,void
50395,BLOCK,-1,,"{
	PatternToken* token = NULL;

	switch ( spec )
	{
		case 0x47: // 'G'
			token = ( new EraToken( repeat, locale ) );
			break;

		case 0x79: // 'y'
			token = ( new YearToken( repeat ) );
			break;

		case 0x4D: // 'M'
			if ( repeat <= 2 )
			{
				token = ( new MonthToken( repeat ) );
			}
			else if ( repeat <= 3 )
			{
				token = ( new AbbreviatedMonthNameToken( repeat, locale ) );
			}
			else
			{
				token = ( new FullMonthNameToken( repeat, locale ) );
			}

			break;

		case 0x77: // 'w'
			token = ( new WeekInYearToken( repeat ) );
			break;

		case 0x57: // 'W'
			token = ( new WeekInMonthToken( repeat ) );
			break;

		case 0x44: // 'D'
			token = ( new DayInYearToken( repeat ) );
			break;

		case 0x64: // 'd'
			token = ( new DayInMonthToken( repeat ) );
			break;

		case 0x46: // 'F'
			token = ( new DayOfWeekInMonthToken( repeat ) );
			break;

		case 0x45: // 'E'
			if ( repeat <= 3 )
			{
				token = ( new AbbreviatedDayNameToken( repeat, locale ) );
			}
			els...",1,,650,5,,void
50402,BLOCK,-1,,"{
		case 0x47: // 'G'
			token = ( new EraToken( repeat, locale ) );
			break;

		case 0x79: // 'y'
			token = ( new YearToken( repeat ) );
			break;

		case 0x4D: // 'M'
			if ( repeat <= 2 )
			{
				token = ( new MonthToken( repeat ) );
			}
			else if ( repeat <= 3 )
			{
				token = ( new AbbreviatedMonthNameToken( repeat, locale ) );
			}
			else
			{
				token = ( new FullMonthNameToken( repeat, locale ) );
			}

			break;

		case 0x77: // 'w'
			token = ( new WeekInYearToken( repeat ) );
			break;

		case 0x57: // 'W'
			token = ( new WeekInMonthToken( repeat ) );
			break;

		case 0x44: // 'D'
			token = ( new DayInYearToken( repeat ) );
			break;

		case 0x64: // 'd'
			token = ( new DayInMonthToken( repeat ) );
			break;

		case 0x46: // 'F'
			token = ( new DayOfWeekInMonthToken( repeat ) );
			break;

		case 0x45: // 'E'
			if ( repeat <= 3 )
			{
				token = ( new AbbreviatedDayNameToken( repeat, locale ) );
			}
			else
			{
				token = ( new FullDayNameToken( repeat,...",2,,654,2,,void
50426,BLOCK,-1,,"{
				token = ( new MonthToken( repeat ) );
			}",4,,665,2,,void
50433,BLOCK,-1,,<empty>,9,,668,1,,void
50438,BLOCK,-1,,"{
				token = ( new AbbreviatedMonthNameToken( repeat, locale ) );
			}",4,,669,2,,void
50446,BLOCK,-1,,"{
				token = ( new FullMonthNameToken( repeat, locale ) );
			}",4,,673,1,,void
50500,BLOCK,-1,,"{
				token = ( new AbbreviatedDayNameToken( repeat, locale ) );
			}",4,,701,2,,void
50508,BLOCK,-1,,"{
				token = ( new FullDayNameToken( repeat, locale ) );
			}",4,,705,1,,void
50583,BLOCK,-1,,"{
				token = ( new MicrosecondToken( repeat ) );
			}",4,,741,2,,void
50590,BLOCK,-1,,"{
				// It would be nice to support patterns with arbitrary
				// subsecond precision (like ""s.S"" or ""s.SSSS""), but we
				// don't; so this is a back-compatible default.
				token = ( new MillisecondToken( repeat ) );
			}",4,,745,1,,void
50635,BLOCK,-1,,"{
	if ( !fmt.empty() )
	{
		LogString::const_iterator iter = fmt.begin();
		int repeat = 1;
		logchar prevChar = * iter;

		for ( iter++; iter != fmt.end(); iter++ )
		{
			if ( * iter == prevChar )
			{
				repeat++;
			}
			else
			{
				addToken( prevChar, repeat, locale, pattern );
				prevChar = * iter;
				repeat = 1;
			}
		}

		addToken( prevChar, repeat, locale, pattern );
	}
}",1,,773,4,,void
50642,BLOCK,-1,,"{
		LogString::const_iterator iter = fmt.begin();
		int repeat = 1;
		logchar prevChar = * iter;

		for ( iter++; iter != fmt.end(); iter++ )
		{
			if ( * iter == prevChar )
			{
				repeat++;
			}
			else
			{
				addToken( prevChar, repeat, locale, pattern );
				prevChar = * iter;
				repeat = 1;
			}
		}

		addToken( prevChar, repeat, locale, pattern );
	}",2,,775,2,,void
50660,BLOCK,-1,,<empty>,3,,780,1,,void
50671,BLOCK,4,,"{
			if ( * iter == prevChar )
			{
				repeat++;
			}
			else
			{
				addToken( prevChar, repeat, locale, pattern );
				prevChar = * iter;
				repeat = 1;
			}
		}",3,,781,4,,void
50677,BLOCK,-1,,"{
				repeat++;
			}",4,,783,2,,void
50681,BLOCK,-1,,"{
				addToken( prevChar, repeat, locale, pattern );
				prevChar = * iter;
				repeat = 1;
			}",4,,787,1,,void
50703,BLOCK,-1,,<empty>,2,,802,1,,void
50710,BLOCK,-1,,"{
#if LOG4CXX_HAS_STD_LOCALE
	std::locale defaultLocale;
	parsePattern( fmt, & defaultLocale, m_priv->pattern );
#else
	parsePattern( fmt, NULL, m_priv->pattern );
#endif

	for ( PatternTokenList::iterator iter = m_priv->pattern.begin(); iter != m_priv->pattern.end(); iter++ )
	{
		( * iter )->setTimeZone( m_priv->timeZone );
	}
}",1,,816,2,,void
50718,BLOCK,-1,,<empty>,2,,824,1,,void
50738,BLOCK,4,,"{
		( * iter )->setTimeZone( m_priv->timeZone );
	}",2,,825,4,,void
50752,BLOCK,-1,,"{
	parsePattern( fmt, locale, m_priv->pattern );

	for ( PatternTokenList::iterator iter = m_priv->pattern.begin(); iter != m_priv->pattern.end(); iter++ )
	{
		( * iter )->setTimeZone( m_priv->timeZone );
	}
}",1,,831,3,,void
50760,BLOCK,-1,,<empty>,2,,834,1,,void
50780,BLOCK,4,,"{
		( * iter )->setTimeZone( m_priv->timeZone );
	}",2,,835,4,,void
50792,BLOCK,-1,,"{
	for ( PatternTokenList::iterator iter = m_priv->pattern.begin(); iter != m_priv->pattern.end(); iter++ )
	{
		delete * iter;
	}
}",1,,842,1,,void
50794,BLOCK,-1,,<empty>,2,,843,1,,void
50814,BLOCK,4,,"{
		delete * iter;
	}",2,,844,4,,void
50824,BLOCK,-1,,"{
	apr_time_exp_t exploded;
	apr_status_t stat = m_priv->timeZone->explode( & exploded, time );

	if ( stat == APR_SUCCESS )
	{
		for ( PatternTokenList::const_iterator iter = m_priv->pattern.begin(); iter != m_priv->pattern.end(); iter++ )
		{
			( * iter )->format( s, exploded, p );
		}
	}
}",1,,851,4,,void
50842,BLOCK,-1,,"{
		for ( PatternTokenList::const_iterator iter = m_priv->pattern.begin(); iter != m_priv->pattern.end(); iter++ )
		{
			( * iter )->format( s, exploded, p );
		}
	}",2,,856,2,,void
50844,BLOCK,-1,,<empty>,3,,857,1,,void
50864,BLOCK,4,,"{
			( * iter )->format( s, exploded, p );
		}",3,,858,4,,void
50877,BLOCK,-1,,"{
	m_priv->timeZone = zone;
}",1,,865,2,,void
50897,BLOCK,-1,,<empty>,1,,1,1,,ANY
50904,BLOCK,-1,,"{
	output.append(event->getLevel()->toString());
	output.append(LOG4CXX_STR("" - ""));
	output.append(event->getRenderedMessage());
	output.append(LOG4CXX_EOL);
}",1,,32,4,,void
50947,BLOCK,-1,,<empty>,1,,1,1,,ANY
50951,BLOCK,-1,,"{
}",1,,30,1,,void
50959,BLOCK,-1,,"{
	return (fileLength >= maxFileSize);
}",1,,37,5,,void
50967,BLOCK,-1,,"{
	return maxFileSize;
}",1,,42,1,,void
50974,BLOCK,-1,,"{
	maxFileSize = l;
}",1,,47,2,,void
50982,BLOCK,-1,,"{
}",1,,52,2,,void
50988,BLOCK,-1,,"{
	if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""MAXFILESIZE""),
			LOG4CXX_STR(""maxfilesize"")))
	{
		maxFileSize = OptionConverter::toFileSize(value, 10 * 1024 * 1024);
	}
}",1,,56,3,,void
50999,BLOCK,-1,,"{
		maxFileSize = OptionConverter::toFileSize(value, 10 * 1024 * 1024);
	}",2,,60,2,,void
51050,BLOCK,-1,,<empty>,1,,1,1,,ANY
51060,BLOCK,-1,,<empty>,37,,391,1,,void
51065,BLOCK,-1,,<empty>,24,,399,2,,void
51082,BLOCK,-1,,"{
}",1,,419,1,,void
51087,BLOCK,-1,,"{
	return event->getLevel()->isGreaterOrEqual(Level::getError());
}",1,,423,2,,void
51103,BLOCK,-1,,"{
}",1,,429,1,,void
51108,BLOCK,-1,,"{
}",1,,437,2,,void
51112,BLOCK,-1,,"{
	finalize();
}",1,,441,1,,void
51117,BLOCK,-1,,"{
	return true;
}",1,,446,1,,void
51123,BLOCK,-1,,"{
	return _priv->from;
}",1,,451,1,,void
51126,BLOCK,1,,<empty>,,,,1,,void
51139,BLOCK,-1,,"{
	_priv->from = newVal;
}",1,,456,2,,void
51142,BLOCK,1,,<empty>,,,,1,,void
51155,BLOCK,-1,,"{
	return _priv->subject;
}",1,,462,1,,void
51158,BLOCK,1,,<empty>,,,,1,,void
51171,BLOCK,-1,,"{
	_priv->subject = newVal;
}",1,,467,2,,void
51174,BLOCK,1,,<empty>,,,,1,,void
51187,BLOCK,-1,,"{
	return _priv->smtpHost;
}",1,,472,1,,void
51190,BLOCK,1,,<empty>,,,,1,,void
51203,BLOCK,-1,,"{
	_priv->smtpHost = newVal;
}",1,,477,2,,void
51206,BLOCK,1,,<empty>,,,,1,,void
51219,BLOCK,-1,,"{
	return _priv->smtpPort;
}",1,,482,1,,void
51222,BLOCK,1,,<empty>,,,,1,,void
51235,BLOCK,-1,,"{
	_priv->smtpPort = newVal;
}",1,,487,2,,void
51238,BLOCK,1,,<empty>,,,,1,,void
51251,BLOCK,-1,,"{
	return _priv->locationInfo;
}",1,,492,1,,void
51254,BLOCK,1,,<empty>,,,,1,,void
51267,BLOCK,-1,,"{
	_priv->locationInfo = newVal;
}",1,,497,2,,void
51270,BLOCK,1,,<empty>,,,,1,,void
51283,BLOCK,-1,,"{
	return _priv->smtpUsername;
}",1,,502,1,,void
51286,BLOCK,1,,<empty>,,,,1,,void
51299,BLOCK,-1,,"{
	_priv->smtpUsername = newVal;
}",1,,507,2,,void
51302,BLOCK,1,,<empty>,,,,1,,void
51315,BLOCK,-1,,"{
	return _priv->smtpPassword;
}",1,,512,1,,void
51318,BLOCK,1,,<empty>,,,,1,,void
51331,BLOCK,-1,,"{
	_priv->smtpPassword = newVal;
}",1,,517,2,,void
51334,BLOCK,1,,<empty>,,,,1,,void
51349,BLOCK,-1,,"{
	if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""BUFFERSIZE""), LOG4CXX_STR(""buffersize"")))
	{
		setBufferSize(OptionConverter::toInt(value, 512));
	}
	else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""EVALUATORCLASS""), LOG4CXX_STR(""evaluatorclass"")))
	{
		setEvaluatorClass(value);
	}
	else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""FROM""), LOG4CXX_STR(""from"")))
	{
		setFrom(value);
	}
	else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""SMTPHOST""), LOG4CXX_STR(""smtphost"")))
	{
		setSMTPHost(value);
	}
	else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""SMTPUSERNAME""), LOG4CXX_STR(""smtpusername"")))
	{
		setSMTPUsername(value);
	}
	else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""SMTPPASSWORD""), LOG4CXX_STR(""smtppassword"")))
	{
		setSMTPPassword(value);
	}
	else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""SUBJECT""), LOG4CXX_STR(""subject"")))
	{
		setSubject(value);
	}
	else if (StringHelper::equalsIgnoreCase(o...",1,,527,3,,void
51360,BLOCK,-1,,"{
		setBufferSize(OptionConverter::toInt(value, 512));
	}",2,,529,2,,void
51369,BLOCK,-1,,<empty>,7,,532,1,,void
51380,BLOCK,-1,,"{
		setEvaluatorClass(value);
	}",2,,533,2,,void
51384,BLOCK,-1,,<empty>,7,,536,1,,void
51395,BLOCK,-1,,"{
		setFrom(value);
	}",2,,537,2,,void
51399,BLOCK,-1,,<empty>,7,,540,1,,void
51410,BLOCK,-1,,"{
		setSMTPHost(value);
	}",2,,541,2,,void
51414,BLOCK,-1,,<empty>,7,,544,1,,void
51425,BLOCK,-1,,"{
		setSMTPUsername(value);
	}",2,,545,2,,void
51429,BLOCK,-1,,<empty>,7,,548,1,,void
51440,BLOCK,-1,,"{
		setSMTPPassword(value);
	}",2,,549,2,,void
51444,BLOCK,-1,,<empty>,7,,552,1,,void
51455,BLOCK,-1,,"{
		setSubject(value);
	}",2,,553,2,,void
51459,BLOCK,-1,,<empty>,7,,556,1,,void
51470,BLOCK,-1,,"{
		setTo(value);
	}",2,,557,2,,void
51474,BLOCK,-1,,<empty>,7,,560,1,,void
51485,BLOCK,-1,,"{
		setCc(value);
	}",2,,561,2,,void
51489,BLOCK,-1,,<empty>,7,,564,1,,void
51500,BLOCK,-1,,"{
		setBcc(value);
	}",2,,565,2,,void
51504,BLOCK,-1,,<empty>,7,,568,1,,void
51515,BLOCK,-1,,"{
		setSMTPPort(OptionConverter::toInt(value, 25));
	}",2,,569,2,,void
51524,BLOCK,-1,,"{
		AppenderSkeleton::setOption(option, value);
	}",2,,573,1,,void
51536,BLOCK,-1,,"{
	for (LogString::const_iterator iter = value.begin();
		iter != value.end();
		iter++)
	{
		if (0x7F < (unsigned int) *iter)
		{
			LogLog::warn(field + LOG4CXX_STR("" contains non-ASCII character""));
			return false;
		}
	}

	return true;
}",1,,580,3,,void
51538,BLOCK,-1,,<empty>,2,,581,1,,void
51554,BLOCK,4,,"{
		if (0x7F < (unsigned int) *iter)
		{
			LogLog::warn(field + LOG4CXX_STR("" contains non-ASCII character""));
			return false;
		}
	}",2,,584,4,,void
51562,BLOCK,-1,,"{
			LogLog::warn(field + LOG4CXX_STR("" contains non-ASCII character""));
			return false;
		}",3,,586,2,,void
51579,BLOCK,-1,,"{
	bool activate = true;

	if (_priv->layout == 0)
	{
		_priv->errorHandler->error(LOG4CXX_STR(""No layout set for appender named ["") + _priv->name + LOG4CXX_STR(""].""));
		activate = false;
	}

	if (_priv->evaluator == 0)
	{
		_priv->errorHandler->error(LOG4CXX_STR(""No TriggeringEventEvaluator is set for appender ["") +
			_priv->name + LOG4CXX_STR(""].""));
		activate = false;
	}

	if (_priv->smtpHost.empty())
	{
		_priv->errorHandler->error(LOG4CXX_STR(""No smtpHost is set for appender ["") +
			_priv->name + LOG4CXX_STR(""].""));
		activate = false;
	}

	if (_priv->to.empty() && _priv->cc.empty() && _priv->bcc.empty())
	{
		_priv->errorHandler->error(LOG4CXX_STR(""No recipient address is set for appender ["") +
			_priv->name + LOG4CXX_STR(""].""));
		activate = false;
	}

	activate &= asciiCheck(_priv->to, LOG4CXX_STR(""to""));
	activate &= asciiCheck(_priv->cc, LOG4CXX_STR(""cc""));
	activate &= asciiCheck(_priv->bcc, LOG4CXX_STR(""bcc""));
	activate &= asciiCheck(_priv->from, LOG4CXX_STR(""from""...",1,,599,2,,void
51587,BLOCK,1,,<empty>,,,,1,,void
51597,BLOCK,-1,,"{
		_priv->errorHandler->error(LOG4CXX_STR(""No layout set for appender named ["") + _priv->name + LOG4CXX_STR(""].""));
		activate = false;
	}",2,,603,2,,void
51614,BLOCK,1,,<empty>,,,,1,,void
51631,BLOCK,1,,<empty>,,,,1,,void
51641,BLOCK,-1,,"{
		_priv->errorHandler->error(LOG4CXX_STR(""No TriggeringEventEvaluator is set for appender ["") +
			_priv->name + LOG4CXX_STR(""].""));
		activate = false;
	}",2,,609,2,,void
51643,BLOCK,1,,<empty>,,,,1,,void
51660,BLOCK,1,,<empty>,,,,1,,void
51676,BLOCK,1,,<empty>,,,,1,,void
51688,BLOCK,-1,,"{
		_priv->errorHandler->error(LOG4CXX_STR(""No smtpHost is set for appender ["") +
			_priv->name + LOG4CXX_STR(""].""));
		activate = false;
	}",2,,616,2,,void
51690,BLOCK,1,,<empty>,,,,1,,void
51707,BLOCK,1,,<empty>,,,,1,,void
51725,BLOCK,1,,<empty>,,,,1,,void
51738,BLOCK,1,,<empty>,,,,1,,void
51751,BLOCK,1,,<empty>,,,,1,,void
51763,BLOCK,-1,,"{
		_priv->errorHandler->error(LOG4CXX_STR(""No recipient address is set for appender ["") +
			_priv->name + LOG4CXX_STR(""].""));
		activate = false;
	}",2,,623,2,,void
51765,BLOCK,1,,<empty>,,,,1,,void
51782,BLOCK,1,,<empty>,,,,1,,void
51800,BLOCK,1,,<empty>,,,,1,,void
51815,BLOCK,1,,<empty>,,,,1,,void
51830,BLOCK,1,,<empty>,,,,1,,void
51845,BLOCK,1,,<empty>,,,,1,,void
51857,BLOCK,1,,<empty>,,,,1,,void
51876,BLOCK,-1,,"{
		AppenderSkeleton::activateOptions(p);
	}",2,,640,2,,void
51887,BLOCK,-1,,"{
	if (!checkEntryConditions())
	{
		return;
	}

	LogString ndc;
	event->getNDC(ndc);
	event->getThreadName();
	// Get a copy of this thread's MDC.
	event->getMDCCopy();

	_priv->cb.add(event);

	if (_priv->evaluator->isTriggeringEvent(event))
	{
		sendBuffer(p);
	}
}",1,,650,3,,void
51891,BLOCK,-1,,"{
		return;
	}",2,,652,2,,void
51908,BLOCK,1,,<empty>,,,,1,,void
51923,BLOCK,1,,<empty>,,,,1,,void
51936,BLOCK,-1,,"{
		sendBuffer(p);
	}",2,,665,2,,void
51942,BLOCK,-1,,"{
#if LOG4CXX_HAVE_LIBESMTP

	if ((_priv->to.empty() && _priv->cc.empty() && _priv->bcc.empty()) || _priv->from.empty() || _priv->smtpHost.empty())
	{
		_priv->errorHandler->error(LOG4CXX_STR(""Message not configured.""));
		return false;
	}

	if (_priv->evaluator == 0)
	{
		_priv->errorHandler->error(LOG4CXX_STR(""No TriggeringEventEvaluator is set for appender ["") +
			_priv->name + LOG4CXX_STR(""].""));
		return false;
	}


	if (_priv->layout == 0)
	{
		_priv->errorHandler->error(LOG4CXX_STR(""No layout set for appender named ["") + _priv->name + LOG4CXX_STR(""].""));
		return false;
	}

	return true;
#else
	return false;
#endif
}",1,,676,1,,void
51948,BLOCK,-1,,"{
	_priv->closed = true;
}",1,,708,1,,void
51950,BLOCK,1,,<empty>,,,,1,,void
51953,BLOCK,1,,<empty>,,,,1,,void
51966,BLOCK,-1,,"{
	return _priv->to;
}",1,,713,1,,void
51969,BLOCK,1,,<empty>,,,,1,,void
51982,BLOCK,-1,,"{
	_priv->to = addressStr;
}",1,,718,2,,void
51985,BLOCK,1,,<empty>,,,,1,,void
51998,BLOCK,-1,,"{
	return _priv->cc;
}",1,,723,1,,void
52001,BLOCK,1,,<empty>,,,,1,,void
52014,BLOCK,-1,,"{
	_priv->cc = addressStr;
}",1,,728,2,,void
52017,BLOCK,1,,<empty>,,,,1,,void
52030,BLOCK,-1,,"{
	return _priv->bcc;
}",1,,733,1,,void
52033,BLOCK,1,,<empty>,,,,1,,void
52046,BLOCK,-1,,"{
	_priv->bcc = addressStr;
}",1,,738,2,,void
52049,BLOCK,1,,<empty>,,,,1,,void
52063,BLOCK,-1,,"{
#if LOG4CXX_HAVE_LIBESMTP

	// Note: this code already owns the monitor for this
	// appender. This frees us from needing to synchronize on 'cb'.
	try
	{
		LogString sbuf;
		_priv->layout->appendHeader(sbuf, p);

		int len = _priv->cb.length();

		for (int i = 0; i < len; i++)
		{
			LoggingEventPtr event = _priv->cb.get();
			_priv->layout->format(sbuf, event, p);
		}

		_priv->layout->appendFooter(sbuf, p);

		SMTPSession session(_priv->smtpHost, _priv->smtpPort, _priv->smtpUsername, _priv->smtpPassword, p);

		SMTPMessage message(session, _priv->from, _priv->to, _priv->cc,
			_priv->bcc, _priv->subject, sbuf, p);

		session.send(p);

	}
	catch (std::exception& e)
	{
		LogLog::error(LOG4CXX_STR(""Error occured while sending e-mail notification.""), e);
	}

#endif
}",1,,746,2,,void
52067,BLOCK,-1,,"{
	return _priv->evaluator == 0 ? LogString() : _priv->evaluator->getClass().getName();
}",1,,786,1,,void
52072,BLOCK,1,,<empty>,,,,1,,void
52100,BLOCK,-1,,"{
	return _priv->evaluator;
}",1,,791,1,,void
52103,BLOCK,1,,<empty>,,,,1,,void
52116,BLOCK,-1,,"{
	_priv->evaluator = trigger;
}",1,,796,2,,void
52118,BLOCK,1,,<empty>,,,,1,,void
52121,BLOCK,1,,<empty>,,,,1,,void
52135,BLOCK,-1,,"{
	_priv->bufferSize = sz;
	_priv->cb.resize(sz);
}",1,,808,2,,void
52138,BLOCK,1,,<empty>,,,,1,,void
52149,BLOCK,1,,<empty>,,,,1,,void
52166,BLOCK,-1,,"{
	ObjectPtr obj = ObjectPtr(Loader::loadClass(value).newInstance());
	_priv->evaluator = LOG4CXX_NS::cast<TriggeringEventEvaluator>(obj);
}",1,,821,2,,void
52181,BLOCK,1,,<empty>,,,,1,,void
52200,BLOCK,-1,,"{
	return _priv->bufferSize;
}",1,,827,1,,void
52203,BLOCK,1,,<empty>,,,,1,,void
52228,BLOCK,-1,,<empty>,1,,1,1,,ANY
52233,BLOCK,-1,,"{

}",25,,30,2,,void
52237,BLOCK,-1,,"{
}",1,,35,1,,void
52241,BLOCK,-1,,"{
	return m_priv->address;
}",1,,39,1,,void
52249,BLOCK,-1,,"{
	return m_priv->port;
}",1,,44,1,,void
52259,BLOCK,-1,,"{
	return std::make_unique<APRSocket>(address, port);
}",66,,48,3,,void
52301,BLOCK,-1,,<empty>,1,,1,1,,ANY
52305,BLOCK,-1,,"{
}",1,,40,3,,void
52312,BLOCK,-1,,"{
}",1,,45,4,,void
52319,BLOCK,-1,,"{
}",1,,50,4,,void
52324,BLOCK,-1,,"{
}",1,,55,2,,void
52328,BLOCK,-1,,"{
	finalize();
}",1,,59,1,,void
52334,BLOCK,-1,,"{
	AppenderSkeleton::activateOptions(p);
	connect(p);
}",1,,64,2,,void
52345,BLOCK,-1,,"{
	std::lock_guard<std::recursive_mutex> lock(_priv->mutex);

	if (_priv->closed)
	{
		return;
	}

	_priv->closed = true;
	cleanUp(_priv->pool);

	{
		std::unique_lock<std::mutex> lock2(_priv->interrupt_mutex);
		_priv->interrupt.notify_all();
	}

	if ( _priv->thread.joinable() )
	{
		_priv->thread.join();
	}
}",1,,70,1,,void
52356,BLOCK,1,,<empty>,,,,1,,void
52367,BLOCK,1,,<empty>,,,,1,,void
52376,BLOCK,-1,,"{
		return;
	}",2,,74,2,,void
52380,BLOCK,1,,<empty>,,,,1,,void
52392,BLOCK,1,,<empty>,,,,1,,void
52401,BLOCK,5,,"{
		std::unique_lock<std::mutex> lock2(_priv->interrupt_mutex);
		_priv->interrupt.notify_all();
	}",2,,81,5,,void
52412,BLOCK,1,,<empty>,,,,1,,void
52422,BLOCK,1,,<empty>,,,,1,,void
52436,BLOCK,1,,<empty>,,,,1,,void
52448,BLOCK,-1,,"{
		_priv->thread.join();
	}",2,,87,2,,void
52450,BLOCK,1,,<empty>,,,,1,,void
52466,BLOCK,-1,,"{
	if (_priv->address == 0)
	{
		LogLog::error(LogString(LOG4CXX_STR(""No remote host is set for Appender named \"""")) +
			_priv->name + LOG4CXX_STR(""\"".""));
	}
	else
	{
		cleanUp(p);

		try
		{
			LogString msg(LOG4CXX_STR(""Connecting to ["")
				+ _priv->address->toString() + LOG4CXX_STR("":""));
			StringHelper::toString(_priv->port, p, msg);
			msg += LOG4CXX_STR(""]."");
			LogLog::debug(msg);
			SocketPtr socket = Socket::create(_priv->address, _priv->port);
			setSocket(socket, p);
		}
		catch (SocketException& e)
		{
			LogString msg = LOG4CXX_STR(""Could not connect to ["")
				+ _priv->address->toString() + LOG4CXX_STR("":"");
			StringHelper::toString(_priv->port, p, msg);
			msg += LOG4CXX_STR(""]."");

			fireConnector(); // fire the connector thread
			LogLog::error(msg, e);
		}
	}
}",1,,93,2,,void
52470,BLOCK,1,,<empty>,,,,1,,void
52480,BLOCK,-1,,"{
		LogLog::error(LogString(LOG4CXX_STR(""No remote host is set for Appender named \"""")) +
			_priv->name + LOG4CXX_STR(""\"".""));
	}",2,,95,2,,void
52491,BLOCK,1,,<empty>,,,,1,,void
52503,BLOCK,-1,,"{
		cleanUp(p);

		try
		{
			LogString msg(LOG4CXX_STR(""Connecting to ["")
				+ _priv->address->toString() + LOG4CXX_STR("":""));
			StringHelper::toString(_priv->port, p, msg);
			msg += LOG4CXX_STR(""]."");
			LogLog::debug(msg);
			SocketPtr socket = Socket::create(_priv->address, _priv->port);
			setSocket(socket, p);
		}
		catch (SocketException& e)
		{
			LogString msg = LOG4CXX_STR(""Could not connect to ["")
				+ _priv->address->toString() + LOG4CXX_STR("":"");
			StringHelper::toString(_priv->port, p, msg);
			msg += LOG4CXX_STR(""]."");

			fireConnector(); // fire the connector thread
			LogLog::error(msg, e);
		}
	}",2,,100,1,,void
52507,BLOCK,-1,,"{
			LogString msg(LOG4CXX_STR(""Connecting to ["")
				+ _priv->address->toString() + LOG4CXX_STR("":""));
			StringHelper::toString(_priv->port, p, msg);
			msg += LOG4CXX_STR(""]."");
			LogLog::debug(msg);
			SocketPtr socket = Socket::create(_priv->address, _priv->port);
			setSocket(socket, p);
		}",3,,104,1,,void
52515,BLOCK,1,,<empty>,,,,1,,void
52534,BLOCK,1,,<empty>,,,,1,,void
52562,BLOCK,1,,<empty>,,,,1,,void
52572,BLOCK,1,,<empty>,,,,1,,void
52584,BLOCK,2,,"{
			LogString msg = LOG4CXX_STR(""Could not connect to ["")
				+ _priv->address->toString() + LOG4CXX_STR("":"");
			StringHelper::toString(_priv->port, p, msg);
			msg += LOG4CXX_STR(""]."");

			fireConnector(); // fire the connector thread
			LogLog::error(msg, e);
		}",3,,114,2,,void
52593,BLOCK,1,,<empty>,,,,1,,void
52612,BLOCK,1,,<empty>,,,,1,,void
52639,BLOCK,-1,,"{
	if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""REMOTEHOST""), LOG4CXX_STR(""remotehost"")))
	{
		setRemoteHost(value);
	}
	else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""PORT""), LOG4CXX_STR(""port"")))
	{
		setPort(OptionConverter::toInt(value, getDefaultPort()));
	}
	else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""LOCATIONINFO""), LOG4CXX_STR(""locationinfo"")))
	{
		setLocationInfo(OptionConverter::toBoolean(value, false));
	}
	else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""RECONNECTIONDELAY""), LOG4CXX_STR(""reconnectiondelay"")))
	{
		setReconnectionDelay(OptionConverter::toInt(value, getDefaultDelay()));
	}
	else
	{
		AppenderSkeleton::setOption(option, value);
	}
}",1,,127,3,,void
52650,BLOCK,-1,,"{
		setRemoteHost(value);
	}",2,,129,2,,void
52654,BLOCK,-1,,<empty>,7,,132,1,,void
52665,BLOCK,-1,,"{
		setPort(OptionConverter::toInt(value, getDefaultPort()));
	}",2,,133,2,,void
52674,BLOCK,-1,,<empty>,7,,136,1,,void
52685,BLOCK,-1,,"{
		setLocationInfo(OptionConverter::toBoolean(value, false));
	}",2,,137,2,,void
52694,BLOCK,-1,,<empty>,7,,140,1,,void
52705,BLOCK,-1,,"{
		setReconnectionDelay(OptionConverter::toInt(value, getDefaultDelay()));
	}",2,,141,2,,void
52714,BLOCK,-1,,"{
		AppenderSkeleton::setOption(option, value);
	}",2,,145,1,,void
52724,BLOCK,-1,,"{
	std::lock_guard<std::recursive_mutex> lock(_priv->mutex);

	if ( !_priv->thread.joinable() )
	{
		LogLog::debug(LOG4CXX_STR(""Connector thread not alive: starting monitor.""));

		_priv->thread = ThreadUtility::instance()->createThread( LOG4CXX_STR(""SocketAppend""), &SocketAppenderSkeleton::monitor, this );
	}
}",1,,151,1,,void
52735,BLOCK,1,,<empty>,,,,1,,void
52747,BLOCK,1,,<empty>,,,,1,,void
52759,BLOCK,-1,,"{
		LogLog::debug(LOG4CXX_STR(""Connector thread not alive: starting monitor.""));

		_priv->thread = ThreadUtility::instance()->createThread( LOG4CXX_STR(""SocketAppend""), &SocketAppenderSkeleton::monitor, this );
	}",2,,155,2,,void
52768,BLOCK,1,,<empty>,,,,1,,void
52794,BLOCK,-1,,"{
	Pool p;
	SocketPtr socket;

	while (!is_closed())
	{
		try
		{
			LogString msg(LOG4CXX_STR(""Attempting connection to ["")
				+ _priv->address->toString() + LOG4CXX_STR("":""));
			StringHelper::toString(_priv->port, p, msg);
			msg += LOG4CXX_STR(""]."");
			LogLog::debug(msg);
			socket = Socket::create(_priv->address, _priv->port);
			setSocket(socket, p);
			LogLog::debug(LOG4CXX_STR(""Connection established. Exiting connector thread.""));
			return;
		}
		catch (ConnectException& e)
		{
			LogLog::error(LOG4CXX_STR(""Remote host "")
				+ _priv->address->toString()
				+ LOG4CXX_STR("" refused connection.""), e);
		}
		catch (IOException& e)
		{
			LogString msg(LOG4CXX_STR(""Could not connect to ["")
				+ _priv->address->toString() + LOG4CXX_STR("":""));
			StringHelper::toString(_priv->port, p, msg);
			msg += LOG4CXX_STR(""]."");
			LogLog::error(msg, e);
		}

		if (_priv->reconnectionDelay > 0)
		{
			LogString msg(LOG4CXX_STR(""Waiting ""));
			StringHelper::toString(_priv->reconnection...",1,,163,1,,void
52800,BLOCK,-1,,"{
		try
		{
			LogString msg(LOG4CXX_STR(""Attempting connection to ["")
				+ _priv->address->toString() + LOG4CXX_STR("":""));
			StringHelper::toString(_priv->port, p, msg);
			msg += LOG4CXX_STR(""]."");
			LogLog::debug(msg);
			socket = Socket::create(_priv->address, _priv->port);
			setSocket(socket, p);
			LogLog::debug(LOG4CXX_STR(""Connection established. Exiting connector thread.""));
			return;
		}
		catch (ConnectException& e)
		{
			LogLog::error(LOG4CXX_STR(""Remote host "")
				+ _priv->address->toString()
				+ LOG4CXX_STR("" refused connection.""), e);
		}
		catch (IOException& e)
		{
			LogString msg(LOG4CXX_STR(""Could not connect to ["")
				+ _priv->address->toString() + LOG4CXX_STR("":""));
			StringHelper::toString(_priv->port, p, msg);
			msg += LOG4CXX_STR(""]."");
			LogLog::error(msg, e);
		}

		if (_priv->reconnectionDelay > 0)
		{
			LogString msg(LOG4CXX_STR(""Waiting ""));
			StringHelper::toString(_priv->reconnectionDelay, p, msg);
			msg += LOG4CXX_STR("" ms before retr...",2,,168,2,,void
52802,BLOCK,-1,,"{
			LogString msg(LOG4CXX_STR(""Attempting connection to ["")
				+ _priv->address->toString() + LOG4CXX_STR("":""));
			StringHelper::toString(_priv->port, p, msg);
			msg += LOG4CXX_STR(""]."");
			LogLog::debug(msg);
			socket = Socket::create(_priv->address, _priv->port);
			setSocket(socket, p);
			LogLog::debug(LOG4CXX_STR(""Connection established. Exiting connector thread.""));
			return;
		}",3,,170,1,,void
52810,BLOCK,1,,<empty>,,,,1,,void
52829,BLOCK,1,,<empty>,,,,1,,void
52856,BLOCK,1,,<empty>,,,,1,,void
52866,BLOCK,1,,<empty>,,,,1,,void
52885,BLOCK,2,,"{
			LogLog::error(LOG4CXX_STR(""Remote host "")
				+ _priv->address->toString()
				+ LOG4CXX_STR("" refused connection.""), e);
		}",3,,182,2,,void
52895,BLOCK,1,,<empty>,,,,1,,void
52910,BLOCK,2,,"{
			LogString msg(LOG4CXX_STR(""Could not connect to ["")
				+ _priv->address->toString() + LOG4CXX_STR("":""));
			StringHelper::toString(_priv->port, p, msg);
			msg += LOG4CXX_STR(""]."");
			LogLog::error(msg, e);
		}",3,,188,2,,void
52918,BLOCK,1,,<empty>,,,,1,,void
52937,BLOCK,1,,<empty>,,,,1,,void
52961,BLOCK,1,,<empty>,,,,1,,void
52971,BLOCK,-1,,"{
			LogString msg(LOG4CXX_STR(""Waiting ""));
			StringHelper::toString(_priv->reconnectionDelay, p, msg);
			msg += LOG4CXX_STR("" ms before retrying ["")
				+ _priv->address->toString() + LOG4CXX_STR("":"");
			StringHelper::toString(_priv->port, p, msg);
			msg += LOG4CXX_STR(""]."");
			LogLog::debug(msg);

			std::unique_lock<std::mutex> lock( _priv->interrupt_mutex );
			if (_priv->interrupt.wait_for( lock, std::chrono::milliseconds( _priv->reconnectionDelay ),
				std::bind(&SocketAppenderSkeleton::is_closed, this) ))
				break;
		}",3,,197,2,,void
52981,BLOCK,1,,<empty>,,,,1,,void
52999,BLOCK,1,,<empty>,,,,1,,void
53018,BLOCK,1,,<empty>,,,,1,,void
53048,BLOCK,1,,<empty>,,,,1,,void
53077,BLOCK,1,,<empty>,,,,1,,void
53095,BLOCK,-1,,<empty>,5,,209,2,,void
53100,BLOCK,-1,,"{
	return _priv->closed;
}",1,,215,1,,void
53103,BLOCK,1,,<empty>,,,,1,,void
53116,BLOCK,-1,,"{
	_priv->address = helpers::InetAddress::getByName(host);
	_priv->remoteHost.assign(host);
}",1,,220,2,,void
53118,BLOCK,1,,<empty>,,,,1,,void
53121,BLOCK,1,,<empty>,,,,1,,void
53138,BLOCK,1,,<empty>,,,,1,,void
53154,BLOCK,-1,,"{
	return _priv->remoteHost;
}",1,,226,1,,void
53157,BLOCK,1,,<empty>,,,,1,,void
53170,BLOCK,-1,,"{
	_priv->port = port1;
}",1,,231,2,,void
53173,BLOCK,1,,<empty>,,,,1,,void
53186,BLOCK,-1,,"{
	return _priv->port;
}",1,,236,1,,void
53189,BLOCK,1,,<empty>,,,,1,,void
53202,BLOCK,-1,,"{
	_priv->locationInfo = locationInfo1;
}",1,,241,2,,void
53205,BLOCK,1,,<empty>,,,,1,,void
53218,BLOCK,-1,,"{
	return _priv->locationInfo;
}",1,,246,1,,void
53221,BLOCK,1,,<empty>,,,,1,,void
53234,BLOCK,-1,,"{
	_priv->reconnectionDelay = reconnectionDelay1;
}",1,,251,2,,void
53237,BLOCK,1,,<empty>,,,,1,,void
53250,BLOCK,-1,,"{
	return _priv->reconnectionDelay;
}",1,,256,1,,void
53253,BLOCK,1,,<empty>,,,,1,,void
53280,BLOCK,-1,,<empty>,1,,1,1,,ANY
53288,BLOCK,-1,,"{
	m_priv->socket = socket1;
}",1,,39,2,,void
53297,BLOCK,-1,,"{
}",1,,44,1,,void
53302,BLOCK,-1,,"{
	flush(p);
	m_priv->socket->close();
}",1,,48,2,,void
53315,BLOCK,-1,,"{
	if (m_priv->array.size() > 0)
	{
		ByteBuffer buf((char*) &m_priv->array[0], m_priv->array.size());
		m_priv->socket->write(buf);
		m_priv->array.resize(0);
	}
}",1,,54,2,,void
53325,BLOCK,-1,,"{
		ByteBuffer buf((char*) &m_priv->array[0], m_priv->array.size());
		m_priv->socket->write(buf);
		m_priv->array.resize(0);
	}",2,,56,2,,void
53361,BLOCK,-1,,"{
	if (buf.remaining() > 0)
	{
		size_t sz = m_priv->array.size();
		m_priv->array.resize(sz + buf.remaining());
		memcpy(&m_priv->array[sz], buf.current(), buf.remaining());
		buf.position(buf.limit());
	}
}",1,,64,3,,void
53369,BLOCK,-1,,"{
		size_t sz = m_priv->array.size();
		m_priv->array.resize(sz + buf.remaining());
		memcpy(&m_priv->array[sz], buf.current(), buf.remaining());
		buf.position(buf.limit());
	}",2,,66,2,,void
53428,BLOCK,-1,,<empty>,1,,1,1,,ANY
53431,BLOCK,-1,,<empty>,2,,30,1,,void
53438,BLOCK,-1,,"{
	LOG4CXX_NS::helpers::Transcoder::encode(fmt, m_priv->pattern);
}",1,,42,2,,void
53454,BLOCK,-1,,"{
}",1,,47,1,,void
53461,BLOCK,-1,,"{
	apr_time_exp_t exploded;
	apr_status_t stat = m_priv->timeZone->explode(&exploded, time);

	if (stat == APR_SUCCESS)
	{
		const apr_size_t bufSize = 255;
		char buf[bufSize];
		apr_size_t bufLen;
		stat = apr_strftime(buf, &bufLen, bufSize, m_priv->pattern.c_str(), &exploded);

		if (stat == APR_SUCCESS)
		{
			LOG4CXX_NS::helpers::Transcoder::decode(std::string(buf, bufLen), s);
		}
	}
}",1,,52,4,,void
53479,BLOCK,-1,,"{
		const apr_size_t bufSize = 255;
		char buf[bufSize];
		apr_size_t bufLen;
		stat = apr_strftime(buf, &bufLen, bufSize, m_priv->pattern.c_str(), &exploded);

		if (stat == APR_SUCCESS)
		{
			LOG4CXX_NS::helpers::Transcoder::decode(std::string(buf, bufLen), s);
		}
	}",2,,57,2,,void
53505,BLOCK,-1,,"{
			LOG4CXX_NS::helpers::Transcoder::decode(std::string(buf, bufLen), s);
		}",3,,64,2,,void
53525,BLOCK,-1,,"{
	m_priv->timeZone = zone;
}",1,,71,2,,void
53553,BLOCK,-1,,<empty>,1,,1,1,,ANY
53558,BLOCK,-1,,"{
	for (LogString::const_iterator iter = s1.begin();
		iter != s1.end();
		iter++, upper++, lower++)
	{
		if (*iter != *upper && *iter != * lower)
		{
			return false;
		}
	}

	return (*upper == 0);
}",1,,32,4,,void
53560,BLOCK,-1,,<empty>,2,,33,1,,void
53581,BLOCK,4,,"{
		if (*iter != *upper && *iter != * lower)
		{
			return false;
		}
	}",2,,36,4,,void
53594,BLOCK,-1,,"{
			return false;
		}",3,,38,2,,void
53608,BLOCK,-1,,"{
	LogString::const_iterator u = upper.begin();
	LogString::const_iterator l = lower.begin();
	LogString::const_iterator iter = s1.begin();

	for (;
		iter != s1.end() && u != upper.end() && l != lower.end();
		iter++, u++, l++)
	{
		if (*iter != *u && *iter != *l)
		{
			return false;
		}
	}

	return u == upper.end() && iter == s1.end();
}",1,,47,4,,void
53631,BLOCK,-1,,<empty>,2,,52,1,,void
53659,BLOCK,4,,"{
		if (*iter != *u && *iter != *l)
		{
			return false;
		}
	}",2,,55,4,,void
53672,BLOCK,-1,,"{
			return false;
		}",3,,57,2,,void
53693,BLOCK,-1,,"{
	LogString d;
	std::transform(s.begin(), s.end(),
		std::insert_iterator<LogString>(d, d.begin()), tolower);
	return d;
}",1,,68,2,,void
53727,BLOCK,-1,,"{
	LogString::size_type pos = s.find_first_not_of(' ');

	if (pos == std::string::npos)
	{
		return LogString();
	}

	LogString::size_type n = s.find_last_not_of(' ') - pos + 1;
	return s.substr(pos, n);
}",1,,76,2,,void
53744,BLOCK,-1,,"{
		return LogString();
	}",2,,80,2,,void
53771,BLOCK,-1,,"{
	if (s.length() < prefix.length())
	{
		return false;
	}

	return s.compare(0, prefix.length(), prefix) == 0;
}",1,,89,3,,void
53782,BLOCK,-1,,"{
		return false;
	}",2,,91,2,,void
53803,BLOCK,-1,,"{
	if (suffix.length() <= s.length())
	{
		return s.compare(s.length() - suffix.length(), suffix.length(), suffix) == 0;
	}

	return false;
}",1,,99,3,,void
53814,BLOCK,-1,,"{
		return s.compare(s.length() - suffix.length(), suffix.length(), suffix) == 0;
	}",2,,101,2,,void
53842,BLOCK,-1,,"{
#if LOG4CXX_LOGCHAR_IS_UNICHAR
	std::string as;
	Transcoder::encode(s, as);
	return std::stoi(as);
#else
	return std::stoi(s);
#endif
}",1,,110,2,,void
53853,BLOCK,-1,,"{
#if LOG4CXX_LOGCHAR_IS_UNICHAR
	std::string as;
	Transcoder::encode(s, as);
	return std::stoll(as);
#else
	return std::stoll(s);
#endif
}",1,,121,2,,void
53866,BLOCK,-1,,"{
#if LOG4CXX_LOGCHAR_IS_WCHAR
	dst.append(std::to_wstring(n));
#else
	Transcoder::decode(std::to_string(n), dst);
#endif
}",1,,132,4,,void
53882,BLOCK,-1,,"{
	if (val)
	{
		dst.append(LOG4CXX_STR(""true""));
	}
	else
	{
		dst.append(LOG4CXX_STR(""false""));
	}
}",1,,141,3,,void
53885,BLOCK,-1,,"{
		dst.append(LOG4CXX_STR(""true""));
	}",2,,143,2,,void
53893,BLOCK,-1,,"{
		dst.append(LOG4CXX_STR(""false""));
	}",2,,147,1,,void
53906,BLOCK,-1,,"{
#if LOG4CXX_LOGCHAR_IS_WCHAR
	dst.append(std::to_wstring(n));
#else
	Transcoder::decode(std::to_string(n), dst);
#endif
}",1,,154,4,,void
53923,BLOCK,-1,,"{
#if LOG4CXX_LOGCHAR_IS_WCHAR
	dst.append(std::to_wstring(n));
#else
	Transcoder::decode(std::to_string(n), dst);
#endif
}",1,,164,4,,void
53939,BLOCK,-1,,"{

	LogString result;
	int i = 0;

	while (pattern[i] != 0)
	{
		if (pattern[i] == 0x7B /* '{' */ && pattern[i + 1] >= 0x30 /* '0' */ &&
			pattern[i + 1] <= 0x39 /* '9' */ && pattern[i + 2] == 0x7D /* '}' */)
		{
			int arg = pattern[i + 1] - 0x30 /* '0' */;
			result = result + params[arg];
			i += 3;
		}
		else
		{
			result = result + pattern[i];
			i++;
		}
	}

	return result;
}",1,,173,3,,void
53951,BLOCK,-1,,"{
		if (pattern[i] == 0x7B /* '{' */ && pattern[i + 1] >= 0x30 /* '0' */ &&
			pattern[i + 1] <= 0x39 /* '9' */ && pattern[i + 2] == 0x7D /* '}' */)
		{
			int arg = pattern[i + 1] - 0x30 /* '0' */;
			result = result + params[arg];
			i += 3;
		}
		else
		{
			result = result + pattern[i];
			i++;
		}
	}",2,,179,2,,void
53982,BLOCK,-1,,"{
			int arg = pattern[i + 1] - 0x30 /* '0' */;
			result = result + params[arg];
			i += 3;
		}",3,,182,2,,void
54004,BLOCK,-1,,"{
			result = result + pattern[i];
			i++;
		}",3,,188,1,,void
54034,BLOCK,-1,,<empty>,1,,1,1,,ANY
54037,BLOCK,-1,,<empty>,19,,36,1,,void
54045,BLOCK,-1,,"{
}",1,,46,1,,void
54049,BLOCK,-1,,<empty>,41,,49,1,,void
54055,BLOCK,-1,,"{

	if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""STRINGTOMATCH""), LOG4CXX_STR(""stringtomatch"")))
	{
		priv->stringToMatch = value;
	}
	else if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""ACCEPTONMATCH""), LOG4CXX_STR(""acceptonmatch"")))
	{
		priv->acceptOnMatch = OptionConverter::toBoolean(value, priv->acceptOnMatch);
	}
}",1,,53,3,,void
54066,BLOCK,-1,,"{
		priv->stringToMatch = value;
	}",2,,57,2,,void
54069,BLOCK,1,,<empty>,,,,1,,void
54080,BLOCK,-1,,<empty>,7,,60,1,,void
54091,BLOCK,-1,,"{
		priv->acceptOnMatch = OptionConverter::toBoolean(value, priv->acceptOnMatch);
	}",2,,62,2,,void
54094,BLOCK,1,,<empty>,,,,1,,void
54109,BLOCK,1,,<empty>,,,,1,,void
54122,BLOCK,-1,,"{
	const LogString& msg = event->getRenderedMessage();

	if (msg.empty() || priv->stringToMatch.empty())
	{
		return Filter::NEUTRAL;
	}


	if ( msg.find(priv->stringToMatch) == LogString::npos )
	{
		return Filter::NEUTRAL;
	}
	else
	{
		// we've got a match
		if (priv->acceptOnMatch)
		{
			return Filter::ACCEPT;
		}
		else
		{
			return Filter::DENY;
		}
	}
}",1,,69,2,,void
54137,BLOCK,1,,<empty>,,,,1,,void
54149,BLOCK,-1,,"{
		return Filter::NEUTRAL;
	}",2,,73,2,,void
54161,BLOCK,1,,<empty>,,,,1,,void
54173,BLOCK,-1,,"{
		return Filter::NEUTRAL;
	}",2,,79,2,,void
54179,BLOCK,-1,,"{
		// we've got a match
		if (priv->acceptOnMatch)
		{
			return Filter::ACCEPT;
		}
		else
		{
			return Filter::DENY;
		}
	}",2,,83,1,,void
54182,BLOCK,1,,<empty>,,,,1,,void
54191,BLOCK,-1,,"{
			return Filter::ACCEPT;
		}",3,,86,2,,void
54197,BLOCK,-1,,"{
			return Filter::DENY;
		}",3,,90,1,,void
54206,BLOCK,-1,,"{
	priv->stringToMatch.assign(stringToMatch1);
}",1,,97,2,,void
54208,BLOCK,1,,<empty>,,,,1,,void
54224,BLOCK,-1,,"{
	return priv->stringToMatch;
}",1,,102,1,,void
54227,BLOCK,1,,<empty>,,,,1,,void
54240,BLOCK,-1,,"{
	priv->acceptOnMatch = acceptOnMatch1;
}",1,,107,2,,void
54243,BLOCK,1,,<empty>,,,,1,,void
54256,BLOCK,-1,,"{
	return priv->acceptOnMatch;
}",1,,112,1,,void
54259,BLOCK,1,,<empty>,,,,1,,void
54282,BLOCK,-1,,<empty>,1,,1,1,,ANY
54287,BLOCK,-1,,<empty>,105,,30,3,,void
54296,BLOCK,-1,,"{
}",1,,39,3,,void
54300,BLOCK,-1,,"{
}",1,,43,1,,void
54304,BLOCK,-1,,"{
	return (m_priv->pos != LogString::npos
			&& m_priv->src.find_first_not_of(m_priv->delim, m_priv->pos) != LogString::npos);
}",1,,47,1,,void
54333,BLOCK,-1,,"{
	if (m_priv->pos != LogString::npos)
	{
		size_t nextPos = m_priv->src.find_first_not_of(m_priv->delim, m_priv->pos);

		if (nextPos != LogString::npos)
		{
			m_priv->pos = m_priv->src.find_first_of(m_priv->delim, nextPos);

			if (m_priv->pos == LogString::npos)
			{
				return m_priv->src.substr(nextPos);
			}

			return m_priv->src.substr(nextPos, m_priv->pos - nextPos);
		}
	}

	throw NoSuchElementException();
#if LOG4CXX_RETURN_AFTER_THROW
	return LogString();
#endif
}",1,,53,1,,void
54342,BLOCK,-1,,"{
		size_t nextPos = m_priv->src.find_first_not_of(m_priv->delim, m_priv->pos);

		if (nextPos != LogString::npos)
		{
			m_priv->pos = m_priv->src.find_first_of(m_priv->delim, nextPos);

			if (m_priv->pos == LogString::npos)
			{
				return m_priv->src.substr(nextPos);
			}

			return m_priv->src.substr(nextPos, m_priv->pos - nextPos);
		}
	}",2,,55,2,,void
54364,BLOCK,-1,,"{
			m_priv->pos = m_priv->src.find_first_of(m_priv->delim, nextPos);

			if (m_priv->pos == LogString::npos)
			{
				return m_priv->src.substr(nextPos);
			}

			return m_priv->src.substr(nextPos, m_priv->pos - nextPos);
		}",3,,59,2,,void
54387,BLOCK,-1,,"{
				return m_priv->src.substr(nextPos);
			}",4,,63,2,,void
54437,BLOCK,-1,,<empty>,1,,1,1,,ANY
54441,BLOCK,-1,,"{
	this->initSyslogFacilityStr();

}",1,,44,1,,void
54451,BLOCK,-1,,"{
	this->initSyslogFacilityStr();
}",1,,52,3,,void
54462,BLOCK,-1,,"{
	this->initSyslogFacilityStr();
	setSyslogHost(syslogHost1);
}",1,,59,4,,void
54472,BLOCK,-1,,"{
	finalize();
}",1,,65,1,,void
54477,BLOCK,-1,,"{
	_priv->closed = true;

	if (_priv->sw)
	{
		_priv->sw = nullptr;
	}
}",1,,71,1,,void
54480,BLOCK,1,,<empty>,,,,1,,void
54492,BLOCK,1,,<empty>,,,,1,,void
54501,BLOCK,-1,,"{
		_priv->sw = nullptr;
	}",2,,75,2,,void
54504,BLOCK,1,,<empty>,,,,1,,void
54517,BLOCK,-1,,"{
	_priv->facilityStr = getFacilityString(_priv->syslogFacility);

	if (_priv->facilityStr.empty())
	{
		Pool p;
		LogString msg(LOG4CXX_STR(""\""""));
		StringHelper::toString(_priv->syslogFacility, p, msg);
		msg.append(LOG4CXX_STR(""\"" is an unknown syslog facility. Defaulting to \""USER\"".""));
		LogLog::error(msg);
		_priv->syslogFacility = LOG_USER;
		_priv->facilityStr = LOG4CXX_STR(""user:"");
	}
	else
	{
		_priv->facilityStr += LOG4CXX_STR("":"");
	}
}",1,,81,1,,void
54520,BLOCK,1,,<empty>,,,,1,,void
54531,BLOCK,1,,<empty>,,,,1,,void
54542,BLOCK,1,,<empty>,,,,1,,void
54554,BLOCK,-1,,"{
		Pool p;
		LogString msg(LOG4CXX_STR(""\""""));
		StringHelper::toString(_priv->syslogFacility, p, msg);
		msg.append(LOG4CXX_STR(""\"" is an unknown syslog facility. Defaulting to \""USER\"".""));
		LogLog::error(msg);
		_priv->syslogFacility = LOG_USER;
		_priv->facilityStr = LOG4CXX_STR(""user:"");
	}",2,,85,2,,void
54565,BLOCK,1,,<empty>,,,,1,,void
54589,BLOCK,1,,<empty>,,,,1,,void
54601,BLOCK,1,,<empty>,,,,1,,void
54613,BLOCK,-1,,"{
		_priv->facilityStr += LOG4CXX_STR("":"");
	}",2,,95,1,,void
54616,BLOCK,1,,<empty>,,,,1,,void
54631,BLOCK,-1,,"{
	switch (syslogFacility)
	{
		case LOG_KERN:
			return LOG4CXX_STR(""kern"");

		case LOG_USER:
			return LOG4CXX_STR(""user"");

		case LOG_MAIL:
			return LOG4CXX_STR(""mail"");

		case LOG_DAEMON:
			return LOG4CXX_STR(""daemon"");

		case LOG_AUTH:
			return LOG4CXX_STR(""auth"");

		case LOG_SYSLOG:
			return LOG4CXX_STR(""syslog"");

		case LOG_LPR:
			return LOG4CXX_STR(""lpr"");

		case LOG_NEWS:
			return LOG4CXX_STR(""news"");

		case LOG_UUCP:
			return LOG4CXX_STR(""uucp"");

		case LOG_CRON:
			return LOG4CXX_STR(""cron"");
#ifdef LOG_AUTHPRIV

		case LOG_AUTHPRIV:
			return LOG4CXX_STR(""authpriv"");
#endif
#ifdef LOG_FTP

		case LOG_FTP:
			return LOG4CXX_STR(""ftp"");
#endif

		case LOG_LOCAL0:
			return LOG4CXX_STR(""local0"");

		case LOG_LOCAL1:
			return LOG4CXX_STR(""local1"");

		case LOG_LOCAL2:
			return LOG4CXX_STR(""local2"");

		case LOG_LOCAL3:
			return LOG4CXX_STR(""local3"");

		case LOG_LOCAL4:
			return LOG4CXX_STR(""local4"");

		case LOG_LOCAL5:
			return LOG4CXX_STR(""local5"");

...",1,,106,2,,void
54634,BLOCK,-1,,"{
		case LOG_KERN:
			return LOG4CXX_STR(""kern"");

		case LOG_USER:
			return LOG4CXX_STR(""user"");

		case LOG_MAIL:
			return LOG4CXX_STR(""mail"");

		case LOG_DAEMON:
			return LOG4CXX_STR(""daemon"");

		case LOG_AUTH:
			return LOG4CXX_STR(""auth"");

		case LOG_SYSLOG:
			return LOG4CXX_STR(""syslog"");

		case LOG_LPR:
			return LOG4CXX_STR(""lpr"");

		case LOG_NEWS:
			return LOG4CXX_STR(""news"");

		case LOG_UUCP:
			return LOG4CXX_STR(""uucp"");

		case LOG_CRON:
			return LOG4CXX_STR(""cron"");
#ifdef LOG_AUTHPRIV

		case LOG_AUTHPRIV:
			return LOG4CXX_STR(""authpriv"");
#endif
#ifdef LOG_FTP

		case LOG_FTP:
			return LOG4CXX_STR(""ftp"");
#endif

		case LOG_LOCAL0:
			return LOG4CXX_STR(""local0"");

		case LOG_LOCAL1:
			return LOG4CXX_STR(""local1"");

		case LOG_LOCAL2:
			return LOG4CXX_STR(""local2"");

		case LOG_LOCAL3:
			return LOG4CXX_STR(""local3"");

		case LOG_LOCAL4:
			return LOG4CXX_STR(""local4"");

		case LOG_LOCAL5:
			return LOG4CXX_STR(""local5"");

		case LOG_LOCAL6:
			return...",2,,108,2,,void
54732,BLOCK,-1,,"{
	if (StringHelper::equalsIgnoreCase(s, LOG4CXX_STR(""KERN""), LOG4CXX_STR(""kern"")))
	{
		return LOG_KERN;
	}
	else if (StringHelper::equalsIgnoreCase(s, LOG4CXX_STR(""USER""), LOG4CXX_STR(""user"")))
	{
		return LOG_USER;
	}
	else if (StringHelper::equalsIgnoreCase(s, LOG4CXX_STR(""MAIL""), LOG4CXX_STR(""mail"")))
	{
		return LOG_MAIL;
	}
	else if (StringHelper::equalsIgnoreCase(s, LOG4CXX_STR(""DAEMON""), LOG4CXX_STR(""daemon"")))
	{
		return LOG_DAEMON;
	}
	else if (StringHelper::equalsIgnoreCase(s, LOG4CXX_STR(""AUTH""), LOG4CXX_STR(""auth"")))
	{
		return LOG_AUTH;
	}
	else if (StringHelper::equalsIgnoreCase(s, LOG4CXX_STR(""SYSLOG""), LOG4CXX_STR(""syslog"")))
	{
		return LOG_SYSLOG;
	}
	else if (StringHelper::equalsIgnoreCase(s, LOG4CXX_STR(""LPR""), LOG4CXX_STR(""lpr"")))
	{
		return LOG_LPR;
	}
	else if (StringHelper::equalsIgnoreCase(s, LOG4CXX_STR(""NEWS""), LOG4CXX_STR(""news"")))
	{
		return LOG_NEWS;
	}
	else if (StringHelper::equalsIgnoreCase(s, LOG4CXX_STR(""UUCP""), LOG4CXX_STR(""uucp"")))
	{
		ret...",1,,180,2,,void
54743,BLOCK,-1,,"{
		return LOG_KERN;
	}",2,,182,2,,void
54747,BLOCK,-1,,<empty>,7,,185,1,,void
54758,BLOCK,-1,,"{
		return LOG_USER;
	}",2,,186,2,,void
54762,BLOCK,-1,,<empty>,7,,189,1,,void
54773,BLOCK,-1,,"{
		return LOG_MAIL;
	}",2,,190,2,,void
54777,BLOCK,-1,,<empty>,7,,193,1,,void
54788,BLOCK,-1,,"{
		return LOG_DAEMON;
	}",2,,194,2,,void
54792,BLOCK,-1,,<empty>,7,,197,1,,void
54803,BLOCK,-1,,"{
		return LOG_AUTH;
	}",2,,198,2,,void
54807,BLOCK,-1,,<empty>,7,,201,1,,void
54818,BLOCK,-1,,"{
		return LOG_SYSLOG;
	}",2,,202,2,,void
54822,BLOCK,-1,,<empty>,7,,205,1,,void
54833,BLOCK,-1,,"{
		return LOG_LPR;
	}",2,,206,2,,void
54837,BLOCK,-1,,<empty>,7,,209,1,,void
54848,BLOCK,-1,,"{
		return LOG_NEWS;
	}",2,,210,2,,void
54852,BLOCK,-1,,<empty>,7,,213,1,,void
54863,BLOCK,-1,,"{
		return LOG_UUCP;
	}",2,,214,2,,void
54867,BLOCK,-1,,<empty>,7,,217,1,,void
54878,BLOCK,-1,,"{
		return LOG_CRON;
	}",2,,218,2,,void
54882,BLOCK,-1,,<empty>,7,,236,1,,void
54893,BLOCK,-1,,"{
		return LOG_LOCAL0;
	}",2,,237,2,,void
54897,BLOCK,-1,,<empty>,7,,240,1,,void
54908,BLOCK,-1,,"{
		return LOG_LOCAL1;
	}",2,,241,2,,void
54912,BLOCK,-1,,<empty>,7,,244,1,,void
54923,BLOCK,-1,,"{
		return LOG_LOCAL2;
	}",2,,245,2,,void
54927,BLOCK,-1,,<empty>,7,,248,1,,void
54938,BLOCK,-1,,"{
		return LOG_LOCAL3;
	}",2,,249,2,,void
54942,BLOCK,-1,,<empty>,7,,252,1,,void
54953,BLOCK,-1,,"{
		return LOG_LOCAL4;
	}",2,,253,2,,void
54957,BLOCK,-1,,<empty>,7,,256,1,,void
54968,BLOCK,-1,,"{
		return LOG_LOCAL5;
	}",2,,257,2,,void
54972,BLOCK,-1,,<empty>,7,,260,1,,void
54983,BLOCK,-1,,"{
		return LOG_LOCAL6;
	}",2,,261,2,,void
54987,BLOCK,-1,,<empty>,7,,264,1,,void
54998,BLOCK,-1,,"{
		return LOG_LOCAL7;
	}",2,,265,2,,void
55002,BLOCK,-1,,"{
		return LOG_UNDEF;
	}",2,,269,1,,void
55005,BLOCK,1,,<empty>,,,,1,,void
55013,BLOCK,-1,,"{
	if  (!isAsSevereAsThreshold(event->getLevel()))
	{
		return;
	}

	LogString msg;
	std::string encoded;
	_priv->layout->format(msg, event, p);

	Transcoder::encode(msg, encoded);

	// Split up the message if it is over maxMessageLength in size.
	// According to RFC 3164, the max message length is 1024, however
	// newer systems(such as syslog-ng) can go up to 8k in size for their
	// messages.  We will append (x/y) at the end of each message
	// to indicate how far through the message we are
	std::vector<LogString> packets;

	if ( msg.size() > _priv->maxMessageLength )
	{
		LogString::iterator start = msg.begin();

		while ( start != msg.end() )
		{
			LogString::iterator end = start + _priv->maxMessageLength - 12;

			if ( end > msg.end() )
			{
				end = msg.end();
			}

			LogString newMsg = LogString( start, end );
			packets.push_back( newMsg );
			start = end;
		}

		int current = 1;

		for ( std::vector<LogString>::iterator it = packets.begin();
			it != packets.end();
			i...",1,,275,3,,void
55021,BLOCK,-1,,"{
		return;
	}",2,,277,2,,void
55026,BLOCK,1,,<empty>,,,,2,,void
55061,BLOCK,1,,<empty>,,,,1,,void
55070,BLOCK,-1,,"{
		LogString::iterator start = msg.begin();

		while ( start != msg.end() )
		{
			LogString::iterator end = start + _priv->maxMessageLength - 12;

			if ( end > msg.end() )
			{
				end = msg.end();
			}

			LogString newMsg = LogString( start, end );
			packets.push_back( newMsg );
			start = end;
		}

		int current = 1;

		for ( std::vector<LogString>::iterator it = packets.begin();
			it != packets.end();
			it++, current++ )
		{
			char buf[12];
			apr_snprintf( buf, sizeof(buf), ""(%d/%d)"", current, (int)packets.size() );
			LOG4CXX_DECODE_CHAR(str, buf);
			it->append( str );
		}
	}",2,,295,2,,void
55085,BLOCK,-1,,"{
			LogString::iterator end = start + _priv->maxMessageLength - 12;

			if ( end > msg.end() )
			{
				end = msg.end();
			}

			LogString newMsg = LogString( start, end );
			packets.push_back( newMsg );
			start = end;
		}",3,,299,2,,void
55093,BLOCK,1,,<empty>,,,,1,,void
55110,BLOCK,-1,,"{
				end = msg.end();
			}",4,,303,2,,void
55136,BLOCK,-1,,<empty>,3,,314,1,,void
55155,BLOCK,4,,"{
			char buf[12];
			apr_snprintf( buf, sizeof(buf), ""(%d/%d)"", current, (int)packets.size() );
			LOG4CXX_DECODE_CHAR(str, buf);
			it->append( str );
		}",3,,317,4,,void
55178,BLOCK,-1,,"{
		packets.push_back( msg );
	}",2,,325,1,,void
55187,BLOCK,1,,<empty>,,,,1,,void
55197,BLOCK,-1,,"{
		_priv->errorHandler->error(LOG4CXX_STR(""No syslog host is set for SyslogAppedender named \"""") +
			_priv->name + LOG4CXX_STR(""\"".""));
		return;
	}",2,,351,2,,void
55214,BLOCK,1,,<empty>,,,,1,,void
55227,BLOCK,-1,,<empty>,2,,357,1,,void
55243,BLOCK,4,,"{
		LogString sbuf(1, 0x3C /* '<' */);
		StringHelper::toString((_priv->syslogFacility | event->getLevel()->getSyslogEquivalent()), p, sbuf);
		sbuf.append(1, (logchar) 0x3E /* '>' */);

		if (_priv->facilityPrinting)
		{
			sbuf.append(_priv->facilityStr);
		}

		sbuf.append(*it);
		_priv->sw->write(sbuf);
	}",2,,360,4,,void
55254,BLOCK,1,,<empty>,,,,1,,void
55282,BLOCK,1,,<empty>,,,,1,,void
55291,BLOCK,-1,,"{
			sbuf.append(_priv->facilityStr);
		}",3,,366,2,,void
55297,BLOCK,1,,<empty>,,,,1,,void
55313,BLOCK,1,,<empty>,,,,2,,void
55330,BLOCK,-1,,"{
}",1,,376,2,,void
55336,BLOCK,-1,,"{
	if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""SYSLOGHOST""), LOG4CXX_STR(""sysloghost"")))
	{
		setSyslogHost(value);
	}
	else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""FACILITY""), LOG4CXX_STR(""facility"")))
	{
		setFacility(value);
	}
	else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""MAXMESSAGELENGTH""), LOG4CXX_STR(""maxmessagelength"")))
	{
		setMaxMessageLength(OptionConverter::toInt(value, 1024));
	}
	else
	{
		AppenderSkeleton::setOption(option, value);
	}
}",1,,380,3,,void
55347,BLOCK,-1,,"{
		setSyslogHost(value);
	}",2,,382,2,,void
55351,BLOCK,-1,,<empty>,7,,385,1,,void
55362,BLOCK,-1,,"{
		setFacility(value);
	}",2,,386,2,,void
55366,BLOCK,-1,,<empty>,7,,389,1,,void
55377,BLOCK,-1,,"{
		setMaxMessageLength(OptionConverter::toInt(value, 1024));
	}",2,,390,2,,void
55386,BLOCK,-1,,"{
		AppenderSkeleton::setOption(option, value);
	}",2,,394,1,,void
55397,BLOCK,-1,,"{
	if (_priv->sw != 0)
	{
		_priv->sw = nullptr;
	}

	LogString slHost = syslogHost1;
	int slHostPort = -1;

	LogString::size_type colonPos = 0;
	colonPos = slHost.rfind(':');

	if (colonPos != LogString::npos)
	{
		slHostPort = StringHelper::toInt(slHost.substr(colonPos + 1));
		// Erase the :port part of the host name
		slHost.erase( colonPos );
	}

	// On the local host, we can directly use the system function 'syslog'
	// if it is available (cf. append)
#if LOG4CXX_HAVE_SYSLOG

	if (syslogHost1 != LOG4CXX_STR(""localhost"") && syslogHost1 != LOG4CXX_STR(""127.0.0.1"")
		&& !syslogHost1.empty())
#endif
	{
		if (slHostPort >= 0)
		{
			_priv->sw = std::make_unique<SyslogWriter>(slHost, slHostPort);
		}
		else
		{
			_priv->sw = std::make_unique<SyslogWriter>(slHost);
		}
	}

	_priv->syslogHost = slHost;
	_priv->syslogHostPort = slHostPort;
}",1,,400,2,,void
55401,BLOCK,1,,<empty>,,,,1,,void
55411,BLOCK,-1,,"{
		_priv->sw = nullptr;
	}",2,,402,2,,void
55413,BLOCK,1,,<empty>,,,,1,,void
55416,BLOCK,1,,<empty>,,,,1,,void
55452,BLOCK,-1,,"{
		slHostPort = StringHelper::toInt(slHost.substr(colonPos + 1));
		// Erase the :port part of the host name
		slHost.erase( colonPos );
	}",2,,413,2,,void
55471,BLOCK,10,,"{
		if (slHostPort >= 0)
		{
			_priv->sw = std::make_unique<SyslogWriter>(slHost, slHostPort);
		}
		else
		{
			_priv->sw = std::make_unique<SyslogWriter>(slHost);
		}
	}",2,,426,10,,void
55476,BLOCK,-1,,"{
			_priv->sw = std::make_unique<SyslogWriter>(slHost, slHostPort);
		}",3,,428,2,,void
55479,BLOCK,1,,<empty>,,,,1,,void
55499,BLOCK,-1,,"{
			_priv->sw = std::make_unique<SyslogWriter>(slHost);
		}",3,,432,1,,void
55502,BLOCK,1,,<empty>,,,,1,,void
55520,BLOCK,1,,<empty>,,,,1,,void
55532,BLOCK,1,,<empty>,,,,1,,void
55546,BLOCK,-1,,"{
	if (facilityName.empty())
	{
		return;
	}

	_priv->syslogFacility = getFacility(facilityName);

	if (_priv->syslogFacility == LOG_UNDEF)
	{
		LogLog::error(LOG4CXX_STR(""["") + facilityName +
			LOG4CXX_STR(""] is an unknown syslog facility. Defaulting to [USER].""));
		_priv->syslogFacility = LOG_USER;
	}

	this->initSyslogFacilityStr();
}",1,,443,2,,void
55552,BLOCK,-1,,"{
		return;
	}",2,,445,2,,void
55556,BLOCK,1,,<empty>,,,,1,,void
55570,BLOCK,1,,<empty>,,,,1,,void
55580,BLOCK,1,,<empty>,,,,1,,void
55583,BLOCK,-1,,"{
		LogLog::error(LOG4CXX_STR(""["") + facilityName +
			LOG4CXX_STR(""] is an unknown syslog facility. Defaulting to [USER].""));
		_priv->syslogFacility = LOG_USER;
	}",2,,452,2,,void
55597,BLOCK,1,,<empty>,,,,1,,void
55614,BLOCK,-1,,"{
	return _priv->syslogHost;
}",1,,462,1,,void
55617,BLOCK,1,,<empty>,,,,1,,void
55629,BLOCK,-1,,"{
	return getFacilityString(_priv->syslogFacility);
}",1,,467,1,,void
55633,BLOCK,1,,<empty>,,,,1,,void
55646,BLOCK,-1,,"{
	_priv->facilityPrinting = facilityPrinting1;
}",1,,472,2,,void
55649,BLOCK,1,,<empty>,,,,1,,void
55662,BLOCK,-1,,"{
	return _priv->facilityPrinting;
}",1,,477,1,,void
55665,BLOCK,1,,<empty>,,,,1,,void
55678,BLOCK,-1,,"{
	_priv->maxMessageLength = maxMessageLength1;
}",1,,482,2,,void
55681,BLOCK,1,,<empty>,,,,1,,void
55694,BLOCK,-1,,"{
	return _priv->maxMessageLength;
}",1,,487,1,,void
55697,BLOCK,1,,<empty>,,,,1,,void
55726,BLOCK,-1,,<empty>,1,,1,1,,ANY
55731,BLOCK,-1,,<empty>,61,,31,3,,void
55741,BLOCK,-1,,"{
	try
	{
		m_priv->address = InetAddress::getByName(syslogHost1);
	}
	catch (UnknownHostException& e)
	{
		LogLog::error(((LogString) LOG4CXX_STR(""Could not find "")) + syslogHost1 +
			LOG4CXX_STR("". All logging will FAIL.""), e);
	}

	try
	{
		m_priv->ds = DatagramSocket::create();
	}
	catch (SocketException& e)
	{
		LogLog::error(((LogString) LOG4CXX_STR(""Could not instantiate DatagramSocket to "")) + syslogHost1 +
			LOG4CXX_STR("". All logging will FAIL.""), e);
	}
}",1,,41,3,,void
55743,BLOCK,-1,,"{
		m_priv->address = InetAddress::getByName(syslogHost1);
	}",2,,43,1,,void
55753,BLOCK,2,,"{
		LogLog::error(((LogString) LOG4CXX_STR(""Could not find "")) + syslogHost1 +
			LOG4CXX_STR("". All logging will FAIL.""), e);
	}",2,,47,2,,void
55769,BLOCK,-1,,"{
		m_priv->ds = DatagramSocket::create();
	}",2,,53,1,,void
55778,BLOCK,2,,"{
		LogLog::error(((LogString) LOG4CXX_STR(""Could not instantiate DatagramSocket to "")) + syslogHost1 +
			LOG4CXX_STR("". All logging will FAIL.""), e);
	}",2,,57,2,,void
55796,BLOCK,-1,,<empty>,30,,63,1,,void
55801,BLOCK,-1,,"{
	if (m_priv->ds != 0 && m_priv->address != 0)
	{
		LOG4CXX_ENCODE_CHAR(data, source);

		auto packet = std::make_shared<DatagramPacket>(
				(void*) data.data(), (int)data.length(),
				m_priv->address, m_priv->syslogHostPort);

		m_priv->ds->send(packet);
	}
}",1,,66,2,,void
55814,BLOCK,-1,,"{
		LOG4CXX_ENCODE_CHAR(data, source);

		auto packet = std::make_shared<DatagramPacket>(
				(void*) data.data(), (int)data.length(),
				m_priv->address, m_priv->syslogHostPort);

		m_priv->ds->send(packet);
	}",2,,68,2,,void
55874,BLOCK,-1,,<empty>,1,,1,1,,ANY
55877,BLOCK,-1,,"{
	if (lkey.empty())
	{
		throw IllegalArgumentException(LOG4CXX_STR(""key is empty""));
	}

	LogString rv;

	if (lkey == LOG4CXX_STR(""java.io.tmpdir""))
	{
		Pool p;
		const char* dir = NULL;
		apr_status_t stat = apr_temp_dir_get(&dir, p.getAPRPool());

		if (stat == APR_SUCCESS)
		{
			Transcoder::decode(dir, rv);
		}

		return rv;
	}

	if (lkey == LOG4CXX_STR(""user.dir""))
	{
		Pool p;
		char* dir = NULL;
		apr_status_t stat = apr_filepath_get(&dir, APR_FILEPATH_NATIVE,
				p.getAPRPool());

		if (stat == APR_SUCCESS)
		{
			Transcoder::decode(dir, rv);
		}

		return rv;
	}

#if APR_HAS_USER

	if (lkey == LOG4CXX_STR(""user.home"") || lkey == LOG4CXX_STR(""user.name""))
	{
		Pool pool;
		apr_uid_t userid;
		apr_gid_t groupid;
		apr_pool_t* p = pool.getAPRPool();
		apr_status_t stat = apr_uid_current(&userid, &groupid, p);

		if (stat == APR_SUCCESS)
		{
			char* username = NULL;
			stat = apr_uid_name_get(&username, userid, p);

			if (stat == APR_SUCCESS)
			{
				if (lkey == LOG4CXX_S...",1,,33,2,,void
55883,BLOCK,-1,,"{
		throw IllegalArgumentException(LOG4CXX_STR(""key is empty""));
	}",2,,35,2,,void
55894,BLOCK,-1,,"{
		Pool p;
		const char* dir = NULL;
		apr_status_t stat = apr_temp_dir_get(&dir, p.getAPRPool());

		if (stat == APR_SUCCESS)
		{
			Transcoder::decode(dir, rv);
		}

		return rv;
	}",2,,42,2,,void
55914,BLOCK,-1,,"{
			Transcoder::decode(dir, rv);
		}",3,,48,2,,void
55928,BLOCK,-1,,"{
		Pool p;
		char* dir = NULL;
		apr_status_t stat = apr_filepath_get(&dir, APR_FILEPATH_NATIVE,
				p.getAPRPool());

		if (stat == APR_SUCCESS)
		{
			Transcoder::decode(dir, rv);
		}

		return rv;
	}",2,,56,2,,void
55949,BLOCK,-1,,"{
			Transcoder::decode(dir, rv);
		}",3,,63,2,,void
55984,BLOCK,-1,,"{
		Transcoder::decode((const char*) value, rv);
	}",2,,116,2,,void
56011,BLOCK,-1,,<empty>,1,,1,1,,ANY
56015,BLOCK,-1,,"{
}",1,,33,1,,void
56019,BLOCK,-1,,"{
}",1,,37,1,,void
56024,BLOCK,-1,,"{
}",1,,41,2,,void
56029,BLOCK,-1,,"{
	flush();
}",1,,45,2,,void
56036,BLOCK,-1,,"{
	write(str);
}",1,,50,3,,void
56042,BLOCK,-1,,"{
#if LOG4CXX_FORCE_WIDE_CONSOLE
	return true;
#elif LOG4CXX_FORCE_BYTE_CONSOLE || !LOG4CXX_HAS_FWIDE
	return false;
#else
	return fwide(stderr, 0) > 0;
#endif
}",1,,55,1,,void
56049,BLOCK,-1,,"{
#if LOG4CXX_WCHAR_T_API

	if (isWide())
	{
		LOG4CXX_ENCODE_WCHAR(msg, str);
		fputws(msg.c_str(), stderr);
		return;
	}

#endif
	LOG4CXX_ENCODE_CHAR(msg, str);
	fputs(msg.c_str(), stderr);
}",1,,66,2,,void
56062,BLOCK,-1,,"{
	fflush(stderr);
}",1,,82,1,,void
56080,BLOCK,-1,,<empty>,1,,1,1,,ANY
56084,BLOCK,-1,,"{
}",1,,33,1,,void
56088,BLOCK,-1,,"{
}",1,,37,1,,void
56093,BLOCK,-1,,"{
}",1,,41,2,,void
56098,BLOCK,-1,,"{
	flush();
}",1,,45,2,,void
56105,BLOCK,-1,,"{
	write(str);
}",1,,50,3,,void
56111,BLOCK,-1,,"{
#if LOG4CXX_FORCE_WIDE_CONSOLE
	return true;
#elif LOG4CXX_FORCE_BYTE_CONSOLE || !LOG4CXX_HAS_FWIDE
	return false;
#else
	return fwide(stdout, 0) > 0;
#endif
}",1,,55,1,,void
56118,BLOCK,-1,,"{
#if LOG4CXX_WCHAR_T_API

	if (isWide())
	{
		LOG4CXX_ENCODE_WCHAR(msg, str);
		fputws(msg.c_str(), stdout);
		return;
	}

#endif
	LOG4CXX_ENCODE_CHAR(msg, str);
	fputs(msg.c_str(), stdout);
}",1,,66,2,,void
56131,BLOCK,-1,,"{
	fflush(stdout);
}",1,,82,1,,void
56157,BLOCK,-1,,<empty>,1,,1,1,,ANY
56164,BLOCK,-1,,<empty>,24,,42,3,,void
56183,BLOCK,-1,,"{
}",1,,63,1,,void
56187,BLOCK,-1,,"{
	finalize();
}",1,,67,1,,void
56193,BLOCK,-1,,"{
	if (_priv->serverSocket == NULL)
	{
		_priv->serverSocket = ServerSocket::create(_priv->port);
		_priv->serverSocket->setSoTimeout(1000);
	}

	_priv->sh = ThreadUtility::instance()->createThread( LOG4CXX_STR(""TelnetAppender""), &TelnetAppender::acceptConnections, this );
}",1,,72,2,,void
56197,BLOCK,1,,<empty>,,,,1,,void
56207,BLOCK,-1,,"{
		_priv->serverSocket = ServerSocket::create(_priv->port);
		_priv->serverSocket->setSoTimeout(1000);
	}",2,,74,2,,void
56210,BLOCK,1,,<empty>,,,,1,,void
56224,BLOCK,1,,<empty>,,,,1,,void
56234,BLOCK,1,,<empty>,,,,1,,void
56249,BLOCK,1,,<empty>,,,,1,,void
56277,BLOCK,-1,,"{
	if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""PORT""), LOG4CXX_STR(""port"")))
	{
		setPort(OptionConverter::toInt(value, DEFAULT_PORT));
	}
	else if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""ENCODING""), LOG4CXX_STR(""encoding"")))
	{
		setEncoding(value);
	}
	else
	{
		AppenderSkeleton::setOption(option, value);
	}
}",1,,84,3,,void
56288,BLOCK,-1,,"{
		setPort(OptionConverter::toInt(value, DEFAULT_PORT));
	}",2,,86,2,,void
56297,BLOCK,-1,,<empty>,7,,89,1,,void
56308,BLOCK,-1,,"{
		setEncoding(value);
	}",2,,90,2,,void
56312,BLOCK,-1,,"{
		AppenderSkeleton::setOption(option, value);
	}",2,,94,1,,void
56322,BLOCK,-1,,"{
	std::lock_guard<std::recursive_mutex> lock(_priv->mutex);
	return _priv->encoding;
}",1,,100,1,,void
56333,BLOCK,1,,<empty>,,,,1,,void
56344,BLOCK,1,,<empty>,,,,1,,void
56357,BLOCK,-1,,"{
	std::lock_guard<std::recursive_mutex> lock(_priv->mutex);
	_priv->encoder = CharsetEncoder::getEncoder(value);
	_priv->encoding = value;
}",1,,106,2,,void
56368,BLOCK,1,,<empty>,,,,1,,void
56379,BLOCK,1,,<empty>,,,,1,,void
56395,BLOCK,1,,<empty>,,,,1,,void
56408,BLOCK,-1,,"{
	std::lock_guard<std::recursive_mutex> lock(_priv->mutex);

	if (_priv->closed)
	{
		return;
	}

	_priv->closed = true;

	SocketPtr nullSocket;

	for (ConnectionList::iterator iter = _priv->connections.begin();
		iter != _priv->connections.end();
		iter++)
	{
		if (*iter != 0)
		{
			(*iter)->close();
			*iter = nullSocket;
		}
	}

	if (_priv->serverSocket != NULL)
	{
		try
		{
			_priv->serverSocket->close();
		}
		catch (Exception&)
		{
		}
	}

	if ( _priv->sh.joinable() )
	{
		_priv->sh.join();
	}

	_priv->activeConnections = 0;
}",1,,114,1,,void
56419,BLOCK,1,,<empty>,,,,1,,void
56430,BLOCK,1,,<empty>,,,,1,,void
56439,BLOCK,-1,,"{
		return;
	}",2,,118,2,,void
56443,BLOCK,1,,<empty>,,,,1,,void
56455,BLOCK,-1,,<empty>,2,,126,1,,void
56460,BLOCK,1,,<empty>,,,,1,,void
56475,BLOCK,1,,<empty>,,,,1,,void
56489,BLOCK,4,,"{
		if (*iter != 0)
		{
			(*iter)->close();
			*iter = nullSocket;
		}
	}",2,,129,4,,void
56495,BLOCK,-1,,"{
			(*iter)->close();
			*iter = nullSocket;
		}",3,,131,2,,void
56508,BLOCK,1,,<empty>,,,,1,,void
56518,BLOCK,-1,,"{
		try
		{
			_priv->serverSocket->close();
		}
		catch (Exception&)
		{
		}
	}",2,,138,2,,void
56520,BLOCK,-1,,"{
			_priv->serverSocket->close();
		}",3,,140,1,,void
56522,BLOCK,1,,<empty>,,,,1,,void
56534,BLOCK,2,,"{
		}",3,,144,2,,void
56537,BLOCK,1,,<empty>,,,,1,,void
56549,BLOCK,-1,,"{
		_priv->sh.join();
	}",2,,149,2,,void
56551,BLOCK,1,,<empty>,,,,1,,void
56565,BLOCK,1,,<empty>,,,,1,,void
56579,BLOCK,-1,,"{
	for (ConnectionList::iterator iter = _priv->connections.begin();
		iter != _priv->connections.end();
		iter++)
	{
		if (*iter != 0)
		{
			try
			{
				ByteBuffer b(buf.current(), buf.remaining());
				(*iter)->write(b);
			}
			catch (Exception&)
			{
				// The client has closed the connection, remove it from our list:
				*iter = 0;
				_priv->activeConnections--;
			}
		}
	}
}",1,,158,2,,void
56581,BLOCK,-1,,<empty>,2,,159,1,,void
56586,BLOCK,1,,<empty>,,,,1,,void
56601,BLOCK,1,,<empty>,,,,1,,void
56615,BLOCK,4,,"{
		if (*iter != 0)
		{
			try
			{
				ByteBuffer b(buf.current(), buf.remaining());
				(*iter)->write(b);
			}
			catch (Exception&)
			{
				// The client has closed the connection, remove it from our list:
				*iter = 0;
				_priv->activeConnections--;
			}
		}
	}",2,,162,4,,void
56621,BLOCK,-1,,"{
			try
			{
				ByteBuffer b(buf.current(), buf.remaining());
				(*iter)->write(b);
			}
			catch (Exception&)
			{
				// The client has closed the connection, remove it from our list:
				*iter = 0;
				_priv->activeConnections--;
			}
		}",3,,164,2,,void
56623,BLOCK,-1,,"{
				ByteBuffer b(buf.current(), buf.remaining());
				(*iter)->write(b);
			}",4,,166,1,,void
56640,BLOCK,2,,"{
				// The client has closed the connection, remove it from our list:
				*iter = 0;
				_priv->activeConnections--;
			}",4,,171,2,,void
56646,BLOCK,1,,<empty>,,,,1,,void
56662,BLOCK,-1,,"{
	size_t bytesSize = msg.size() * 2;
	char* bytes = p.pstralloc(bytesSize);

	LogString::const_iterator msgIter(msg.begin());
	ByteBuffer buf(bytes, bytesSize);

	while (msgIter != msg.end())
	{
		_priv->encoder->encode(msg, msgIter, buf);
		buf.flip();
		socket->write(buf);
		buf.clear();
	}
}",1,,181,4,,void
56697,BLOCK,-1,,"{
		_priv->encoder->encode(msg, msgIter, buf);
		buf.flip();
		socket->write(buf);
		buf.clear();
	}",2,,189,2,,void
56699,BLOCK,1,,<empty>,,,,3,,void
56732,BLOCK,-1,,"{
	size_t count = _priv->activeConnections;

	if (count > 0)
	{
		LogString msg;
		_priv->layout->format(msg, event, _priv->pool);
		msg.append(LOG4CXX_STR(""\r\n""));
		size_t bytesSize = msg.size() * 2;
		char* bytes = p.pstralloc(bytesSize);

		LogString::const_iterator msgIter(msg.begin());
		ByteBuffer buf(bytes, bytesSize);

		std::lock_guard<std::recursive_mutex> lock(_priv->mutex);

		while (msgIter != msg.end())
		{
			log4cxx_status_t stat = _priv->encoder->encode(msg, msgIter, buf);
			buf.flip();
			write(buf);
			buf.clear();

			if (CharsetEncoder::isError(stat))
			{
				LogString unrepresented(1, 0x3F /* '?' */);
				LogString::const_iterator unrepresentedIter(unrepresented.begin());
				stat = _priv->encoder->encode(unrepresented, unrepresentedIter, buf);
				buf.flip();
				write(buf);
				buf.clear();
				msgIter++;
			}
		}
	}
}",1,,198,3,,void
56737,BLOCK,1,,<empty>,,,,1,,void
56750,BLOCK,-1,,"{
		LogString msg;
		_priv->layout->format(msg, event, _priv->pool);
		msg.append(LOG4CXX_STR(""\r\n""));
		size_t bytesSize = msg.size() * 2;
		char* bytes = p.pstralloc(bytesSize);

		LogString::const_iterator msgIter(msg.begin());
		ByteBuffer buf(bytes, bytesSize);

		std::lock_guard<std::recursive_mutex> lock(_priv->mutex);

		while (msgIter != msg.end())
		{
			log4cxx_status_t stat = _priv->encoder->encode(msg, msgIter, buf);
			buf.flip();
			write(buf);
			buf.clear();

			if (CharsetEncoder::isError(stat))
			{
				LogString unrepresented(1, 0x3F /* '?' */);
				LogString::const_iterator unrepresentedIter(unrepresented.begin());
				stat = _priv->encoder->encode(unrepresented, unrepresentedIter, buf);
				buf.flip();
				write(buf);
				buf.clear();
				msgIter++;
			}
		}
	}",2,,202,2,,void
56753,BLOCK,1,,<empty>,,,,2,,void
56818,BLOCK,1,,<empty>,,,,1,,void
56834,BLOCK,-1,,"{
			log4cxx_status_t stat = _priv->encoder->encode(msg, msgIter, buf);
			buf.flip();
			write(buf);
			buf.clear();

			if (CharsetEncoder::isError(stat))
			{
				LogString unrepresented(1, 0x3F /* '?' */);
				LogString::const_iterator unrepresentedIter(unrepresented.begin());
				stat = _priv->encoder->encode(unrepresented, unrepresentedIter, buf);
				buf.flip();
				write(buf);
				buf.clear();
				msgIter++;
			}
		}",3,,215,2,,void
56839,BLOCK,1,,<empty>,,,,4,,void
56870,BLOCK,-1,,"{
				LogString unrepresented(1, 0x3F /* '?' */);
				LogString::const_iterator unrepresentedIter(unrepresented.begin());
				stat = _priv->encoder->encode(unrepresented, unrepresentedIter, buf);
				buf.flip();
				write(buf);
				buf.clear();
				msgIter++;
			}",4,,222,2,,void
56884,BLOCK,1,,<empty>,,,,4,,void
56914,BLOCK,-1,,"{

	// main loop; is left when This->closed is != 0 after an accept()
	while (true)
	{
		try
		{
			SocketPtr newClient = _priv->serverSocket->accept();
			bool done = _priv->closed;

			if (done)
			{
				Pool p;
				writeStatus(newClient, LOG4CXX_STR(""Log closed.\r\n""), p);
				newClient->close();

				break;
			}

			size_t count = _priv->activeConnections;

			if (count >= _priv->connections.size())
			{
				Pool p;
				writeStatus(newClient, LOG4CXX_STR(""Too many connections.\r\n""), p);
				newClient->close();
			}
			else
			{
				//
				//   find unoccupied connection
				//
				std::lock_guard<std::recursive_mutex> lock(_priv->mutex);

				for (ConnectionList::iterator iter = _priv->connections.begin();
					iter != _priv->connections.end();
					iter++)
				{
					if (*iter == NULL)
					{
						*iter = newClient;
						_priv->activeConnections++;

						break;
					}
				}

				Pool p;
				LogString oss(LOG4CXX_STR(""TelnetAppender v1.0 (""));
				StringHelper::toString((int...",1,,236,1,,void
56917,BLOCK,-1,,"{
		try
		{
			SocketPtr newClient = _priv->serverSocket->accept();
			bool done = _priv->closed;

			if (done)
			{
				Pool p;
				writeStatus(newClient, LOG4CXX_STR(""Log closed.\r\n""), p);
				newClient->close();

				break;
			}

			size_t count = _priv->activeConnections;

			if (count >= _priv->connections.size())
			{
				Pool p;
				writeStatus(newClient, LOG4CXX_STR(""Too many connections.\r\n""), p);
				newClient->close();
			}
			else
			{
				//
				//   find unoccupied connection
				//
				std::lock_guard<std::recursive_mutex> lock(_priv->mutex);

				for (ConnectionList::iterator iter = _priv->connections.begin();
					iter != _priv->connections.end();
					iter++)
				{
					if (*iter == NULL)
					{
						*iter = newClient;
						_priv->activeConnections++;

						break;
					}
				}

				Pool p;
				LogString oss(LOG4CXX_STR(""TelnetAppender v1.0 (""));
				StringHelper::toString((int) count + 1, p, oss);
				oss += LOG4CXX_STR("" active connections)\r\n\r\n"");
				wri...",2,,240,2,,void
56919,BLOCK,-1,,"{
			SocketPtr newClient = _priv->serverSocket->accept();
			bool done = _priv->closed;

			if (done)
			{
				Pool p;
				writeStatus(newClient, LOG4CXX_STR(""Log closed.\r\n""), p);
				newClient->close();

				break;
			}

			size_t count = _priv->activeConnections;

			if (count >= _priv->connections.size())
			{
				Pool p;
				writeStatus(newClient, LOG4CXX_STR(""Too many connections.\r\n""), p);
				newClient->close();
			}
			else
			{
				//
				//   find unoccupied connection
				//
				std::lock_guard<std::recursive_mutex> lock(_priv->mutex);

				for (ConnectionList::iterator iter = _priv->connections.begin();
					iter != _priv->connections.end();
					iter++)
				{
					if (*iter == NULL)
					{
						*iter = newClient;
						_priv->activeConnections++;

						break;
					}
				}

				Pool p;
				LogString oss(LOG4CXX_STR(""TelnetAppender v1.0 (""));
				StringHelper::toString((int) count + 1, p, oss);
				oss += LOG4CXX_STR("" active connections)\r\n\r\n"");
				writeStatus(n...",3,,242,1,,void
56924,BLOCK,1,,<empty>,,,,1,,void
56940,BLOCK,1,,<empty>,,,,1,,void
56951,BLOCK,-1,,"{
				Pool p;
				writeStatus(newClient, LOG4CXX_STR(""Log closed.\r\n""), p);
				newClient->close();

				break;
			}",4,,247,2,,void
56967,BLOCK,1,,<empty>,,,,1,,void
56980,BLOCK,1,,<empty>,,,,1,,void
56992,BLOCK,-1,,"{
				Pool p;
				writeStatus(newClient, LOG4CXX_STR(""Too many connections.\r\n""), p);
				newClient->close();
			}",4,,258,2,,void
57004,BLOCK,-1,,"{
				//
				//   find unoccupied connection
				//
				std::lock_guard<std::recursive_mutex> lock(_priv->mutex);

				for (ConnectionList::iterator iter = _priv->connections.begin();
					iter != _priv->connections.end();
					iter++)
				{
					if (*iter == NULL)
					{
						*iter = newClient;
						_priv->activeConnections++;

						break;
					}
				}

				Pool p;
				LogString oss(LOG4CXX_STR(""TelnetAppender v1.0 (""));
				StringHelper::toString((int) count + 1, p, oss);
				oss += LOG4CXX_STR("" active connections)\r\n\r\n"");
				writeStatus(newClient, oss, p);
			}",4,,264,1,,void
57015,BLOCK,1,,<empty>,,,,1,,void
57025,BLOCK,-1,,<empty>,5,,270,1,,void
57030,BLOCK,1,,<empty>,,,,1,,void
57045,BLOCK,1,,<empty>,,,,1,,void
57059,BLOCK,4,,"{
					if (*iter == NULL)
					{
						*iter = newClient;
						_priv->activeConnections++;

						break;
					}
				}",5,,273,4,,void
57065,BLOCK,-1,,"{
						*iter = newClient;
						_priv->activeConnections++;

						break;
					}",6,,275,2,,void
57071,BLOCK,1,,<empty>,,,,1,,void
57106,BLOCK,2,,"{
			if (_priv->closed)
			{
				break;
			}
		}",3,,291,2,,void
57109,BLOCK,1,,<empty>,,,,1,,void
57118,BLOCK,-1,,"{
				break;
			}",4,,293,2,,void
57120,BLOCK,2,,"{
			if (!_priv->closed)
			{
				LogLog::error(LOG4CXX_STR(""Encountered error while in SocketHandler loop.""), e);
			}
			else
			{
				break;
			}
		}",3,,298,2,,void
57124,BLOCK,1,,<empty>,,,,1,,void
57133,BLOCK,-1,,"{
				LogLog::error(LOG4CXX_STR(""Encountered error while in SocketHandler loop.""), e);
			}",4,,300,2,,void
57142,BLOCK,-1,,"{
				break;
			}",4,,304,1,,void
57147,BLOCK,-1,,"{
	return _priv->port;
}",1,,313,1,,void
57150,BLOCK,1,,<empty>,,,,1,,void
57163,BLOCK,-1,,"{
	_priv->port = port1;
}",1,,318,2,,void
57165,BLOCK,1,,<empty>,,,,1,,void
57168,BLOCK,1,,<empty>,,,,1,,void
57190,BLOCK,-1,,<empty>,1,,1,1,,ANY
57193,BLOCK,-1,,"{
	apr_threadkey_t* key = 0;
#if APR_HAS_THREADS
	apr_status_t stat = apr_threadkey_private_create(&key, 0, p.getAPRPool());

	if (stat != APR_SUCCESS)
	{
		throw RuntimeException(stat);
	}

#endif
	return key;
}",1,,26,2,,void
57203,BLOCK,-1,,"{
}",1,,41,1,,void
57207,BLOCK,-1,,"{
}",1,,45,1,,void
57212,BLOCK,-1,,"{
#if APR_HAS_THREADS
	apr_status_t stat = apr_threadkey_private_set(priv, key);

	if (stat != APR_SUCCESS)
	{
		throw RuntimeException(stat);
	}

#endif
}",1,,49,2,,void
57216,BLOCK,-1,,"{
	void* retval = 0;
#if APR_HAS_THREADS
	apr_status_t stat = apr_threadkey_private_get(&retval, key);

	if (stat != APR_SUCCESS)
	{
		throw RuntimeException(stat);
	}

#endif
	return retval;
}",1,,62,1,,void
57237,BLOCK,-1,,<empty>,1,,1,1,,ANY
57241,BLOCK,-1,,"{
}",1,,33,1,,void
57246,BLOCK,-1,,"{
	static WideLife<PatternConverterPtr> def = std::make_shared<ThreadPatternConverter>();
	return def;
}",1,,38,2,,void
57262,BLOCK,-1,,"{
	toAppendTo.append(event->getThreadName());
}",1,,47,4,,void
57287,BLOCK,-1,,<empty>,1,,1,1,,ANY
57292,BLOCK,-1,,"{
}",1,,37,1,,void
57296,BLOCK,-1,,"{
}",1,,41,1,,void
57300,BLOCK,-1,,"{
	return m_priv->ndcStack;
}",1,,46,1,,void
57308,BLOCK,-1,,"{
	return m_priv->mdcMap;
}",1,,51,1,,void
57316,BLOCK,-1,,"{
	static WideLife<ThreadSpecificData> noThreadData;
	return noThreadData;
}",1,,56,1,,void
57323,BLOCK,-1,,"{
#if APR_HAS_THREADS
	void* pData = NULL;
	apr_threadkey_private_get(&pData, APRInitializer::getTlsKey());
	return (ThreadSpecificData*) pData;
#elif LOG4CXX_HAS_THREAD_LOCAL
	thread_local ThreadSpecificData data;
	return &data;
#else
	return &getDataNoThreads();
#endif
}",1,,62,1,,void
57330,BLOCK,-1,,"{
#if APR_HAS_THREADS

	if (m_priv->ndcStack.empty() && m_priv->mdcMap.empty())
	{
		void* pData = NULL;
		apr_status_t stat = apr_threadkey_private_get(&pData, APRInitializer::getTlsKey());

		if (stat == APR_SUCCESS && pData == this)
		{
			stat = apr_threadkey_private_set(0, APRInitializer::getTlsKey());

			if (stat == APR_SUCCESS)
			{
				delete this;
			}
		}
	}

#endif
}",1,,76,1,,void
57336,BLOCK,-1,,"{
	ThreadSpecificData* data = getCurrentData();

	if (data == 0)
	{
		data = createCurrentData();
	}

	if (data != 0)
	{
		data->getMap()[key] = val;
	}
}",1,,99,3,,void
57345,BLOCK,-1,,"{
		data = createCurrentData();
	}",2,,103,2,,void
57353,BLOCK,-1,,"{
		data->getMap()[key] = val;
	}",2,,108,2,,void
57366,BLOCK,-1,,"{
	ThreadSpecificData* data = getCurrentData();

	if (data == 0)
	{
		data = createCurrentData();
	}

	if (data != 0)
	{
		NDC::Stack& stack = data->getStack();

		if (stack.empty())
		{
			stack.push(NDC::DiagnosticContext(val, val));
		}
		else
		{
			LogString fullMessage(stack.top().second);
			fullMessage.append(1, (logchar) 0x20);
			fullMessage.append(val);
			stack.push(NDC::DiagnosticContext(val, fullMessage));
		}
	}
}",1,,117,2,,void
57375,BLOCK,-1,,"{
		data = createCurrentData();
	}",2,,121,2,,void
57383,BLOCK,-1,,"{
		NDC::Stack& stack = data->getStack();

		if (stack.empty())
		{
			stack.push(NDC::DiagnosticContext(val, val));
		}
		else
		{
			LogString fullMessage(stack.top().second);
			fullMessage.append(1, (logchar) 0x20);
			fullMessage.append(val);
			stack.push(NDC::DiagnosticContext(val, fullMessage));
		}
	}",2,,126,2,,void
57396,BLOCK,-1,,"{
			stack.push(NDC::DiagnosticContext(val, val));
		}",3,,130,2,,void
57408,BLOCK,-1,,"{
			LogString fullMessage(stack.top().second);
			fullMessage.append(1, (logchar) 0x20);
			fullMessage.append(val);
			stack.push(NDC::DiagnosticContext(val, fullMessage));
		}",3,,134,1,,void
57444,BLOCK,-1,,"{
	ThreadSpecificData* data = getCurrentData();

	if (data == 0)
	{
		data = createCurrentData();
	}

	if (data != 0)
	{
		data->getStack() = src;
	}
}",1,,144,2,,void
57453,BLOCK,-1,,"{
		data = createCurrentData();
	}",2,,148,2,,void
57461,BLOCK,-1,,"{
		data->getStack() = src;
	}",2,,153,2,,void
57471,BLOCK,-1,,"{
#if APR_HAS_THREADS
	ThreadSpecificData* newData = new ThreadSpecificData();
	apr_status_t stat = apr_threadkey_private_set(newData, APRInitializer::getTlsKey());

	if (stat != APR_SUCCESS)
	{
		delete newData;
		newData = NULL;
	}

	return newData;
#elif LOG4CXX_HAS_THREAD_LOCAL
	return getCurrentData();
#else
	return 0;
#endif
}",1,,161,1,,void
57488,BLOCK,-1,,<empty>,1,,1,1,,ANY
57492,BLOCK,-1,,"{
}",1,,33,1,,void
57497,BLOCK,-1,,"{
	static WideLife<PatternConverterPtr> def = std::make_shared<ThreadUsernamePatternConverter>();
	return def;
}",1,,38,2,,void
57513,BLOCK,-1,,"{
	toAppendTo.append(event->getThreadUserName());
}",1,,47,4,,void
57544,BLOCK,-1,,<empty>,1,,1,1,,ANY
57549,BLOCK,-1,,"{
		start_pre = nullptr;
		started = nullptr;
		start_post = nullptr;
	}",2,,42,1,,void
57565,BLOCK,-1,,"{
	// Block signals by default.
	configureFuncs( std::bind( &ThreadUtility::preThreadBlockSignals, this ),
		nullptr,
		std::bind( &ThreadUtility::postThreadUnblockSignals, this ) );
}",1,,60,1,,void
57589,BLOCK,-1,,<empty>,33,,67,1,,void
57593,BLOCK,-1,,"{
	static WideLife<ThreadUtility> instance;
	return &instance.value();
}",1,,70,1,,void
57605,BLOCK,-1,,"{
	auto utility = instance();

	if ( type == ThreadConfigurationType::NoConfiguration )
	{
		utility->configureFuncs( nullptr, nullptr, nullptr );
	}
	else if ( type == ThreadConfigurationType::NameThreadOnly )
	{
		utility->configureFuncs( nullptr,
			std::bind( &ThreadUtility::threadStartedNameThread, utility,
				std::placeholders::_1,
				std::placeholders::_2,
				std::placeholders::_3 ),
			nullptr );
	}
	else if ( type == ThreadConfigurationType::BlockSignalsOnly )
	{
		utility->configureFuncs( std::bind( &ThreadUtility::preThreadBlockSignals, utility ),
			nullptr,
			std::bind( &ThreadUtility::postThreadUnblockSignals, utility ) );
	}
	else if ( type == ThreadConfigurationType::BlockSignalsAndNameThread )
	{
		utility->configureFuncs( std::bind( &ThreadUtility::preThreadBlockSignals, utility ),
			std::bind( &ThreadUtility::threadStartedNameThread, utility,
				std::placeholders::_1,
				std::placeholders::_2,
				std::placeholders::_3 ),
			std::bind( &ThreadUtility::postT...",1,,76,2,,void
57616,BLOCK,-1,,"{
		utility->configureFuncs( nullptr, nullptr, nullptr );
	}",2,,80,2,,void
57625,BLOCK,-1,,<empty>,7,,83,1,,void
57632,BLOCK,-1,,"{
		utility->configureFuncs( nullptr,
			std::bind( &ThreadUtility::threadStartedNameThread, utility,
				std::placeholders::_1,
				std::placeholders::_2,
				std::placeholders::_3 ),
			nullptr );
	}",2,,84,2,,void
57664,BLOCK,-1,,<empty>,7,,92,1,,void
57671,BLOCK,-1,,"{
		utility->configureFuncs( std::bind( &ThreadUtility::preThreadBlockSignals, utility ),
			nullptr,
			std::bind( &ThreadUtility::postThreadUnblockSignals, utility ) );
	}",2,,93,2,,void
57696,BLOCK,-1,,<empty>,7,,98,1,,void
57703,BLOCK,-1,,"{
		utility->configureFuncs( std::bind( &ThreadUtility::preThreadBlockSignals, utility ),
			std::bind( &ThreadUtility::threadStartedNameThread, utility,
				std::placeholders::_1,
				std::placeholders::_2,
				std::placeholders::_3 ),
			std::bind( &ThreadUtility::postThreadUnblockSignals, utility ) );
	}",2,,99,2,,void
57756,BLOCK,-1,,"{
	m_priv->start_pre = pre_start;
	m_priv->started = started;
	m_priv->start_post = post_start;
}",1,,112,4,,void
57775,BLOCK,-1,,"{
#if LOG4CXX_HAS_PTHREAD_SIGMASK
	sigset_t set;
	sigfillset(&set);

	if ( pthread_sigmask(SIG_SETMASK, &set, &old_mask) < 0 )
	{
		LOGLOG_ERROR( LOG4CXX_STR(""Unable to set thread sigmask"") );
		sigmask_valid = false;
	}
	else
	{
		sigmask_valid = true;
	}

#endif /* LOG4CXX_HAS_PTHREAD_SIGMASK */
}",1,,119,1,,void
57782,BLOCK,-1,,"{
#if LOG4CXX_HAS_PTHREAD_SETNAME
	LOG4CXX_ENCODE_CHAR(sthreadName, threadName);
	if (pthread_setname_np(static_cast<pthread_t>(nativeHandle), sthreadName.c_str()) < 0) {
		LOGLOG_ERROR(LOG4CXX_STR(""unable to set thread name""));
	}
#elif WIN32
	typedef HRESULT (WINAPI *TSetThreadDescription)(HANDLE, PCWSTR);
	static struct initialiser
	{
		HMODULE hKernelBase;
		TSetThreadDescription SetThreadDescription;
		initialiser()
			: hKernelBase(GetModuleHandleA(""KernelBase.dll""))
			, SetThreadDescription(nullptr)
		{
			if (hKernelBase)
				SetThreadDescription = reinterpret_cast<TSetThreadDescription>(GetProcAddress(hKernelBase, ""SetThreadDescription""));
		}
	} win32Func;
	if (win32Func.SetThreadDescription)
	{
		LOG4CXX_ENCODE_WCHAR(wthreadName, threadName);
		if(FAILED(win32Func.SetThreadDescription(static_cast<HANDLE>(nativeHandle), wthreadName.c_str())))
			LOGLOG_ERROR( LOG4CXX_STR(""unable to set thread name"") );
	}
#endif
}",1,,140,4,,void
57786,BLOCK,-1,,"{
#if LOG4CXX_HAS_PTHREAD_SIGMASK

	// Only restore the signal mask if we were able to set it in the first place.
	if ( sigmask_valid )
	{
		if ( pthread_sigmask(SIG_SETMASK, &old_mask, nullptr) < 0 )
		{
			LOGLOG_ERROR( LOG4CXX_STR(""Unable to set thread sigmask"") );
		}
	}

#endif /* LOG4CXX_HAS_PTHREAD_SIGMASK */
}",1,,170,1,,void
57790,BLOCK,-1,,"{
	return m_priv->start_pre;
}",1,,187,1,,void
57798,BLOCK,-1,,"{
	return m_priv->started;
}",1,,192,1,,void
57806,BLOCK,-1,,"{
	return m_priv->start_post;
}",1,,197,1,,void
57829,BLOCK,-1,,<empty>,1,,1,1,,ANY
57835,BLOCK,-1,,<empty>,28,,35,4,,void
57843,BLOCK,-1,,"{
}",1,,51,2,,void
57848,BLOCK,-1,,"{
	if (options.size() > 0 && options[0].compare(LOG4CXX_STR(""short"")) == 0)
	{
		static WideLife<PatternConverterPtr> shortConverter = std::make_shared<ThrowableInformationPatternConverter>(true);
		return shortConverter;
	}

	static WideLife<PatternConverterPtr> converter = std::make_shared<ThrowableInformationPatternConverter>(false);
	return converter;
}",1,,56,2,,void
57867,BLOCK,-1,,"{
		static WideLife<PatternConverterPtr> shortConverter = std::make_shared<ThrowableInformationPatternConverter>(true);
		return shortConverter;
	}",2,,58,2,,void
57898,BLOCK,-1,,"{
}",1,,71,4,,void
57902,BLOCK,-1,,"{
	return true;
}",1,,79,1,,void
57943,BLOCK,-1,,<empty>,1,,1,1,,ANY
57948,BLOCK,-1,,<empty>,25,,49,1,,void
57952,BLOCK,-1,,<empty>,33,,51,1,,void
57969,BLOCK,-1,,<empty>,,,,1,,<empty>
57981,BLOCK,-1,,"{
	return 0;
}",92,,248,3,,void
57988,BLOCK,-1,,"{
	return true;
}",72,,252,2,,void
57996,BLOCK,-1,,<empty>,88,,256,3,,void
58001,BLOCK,-1,,"{
	return 0;
}",46,,258,2,,void
58007,BLOCK,-1,,"{
	return 0;
}",45,,262,1,,void
58016,BLOCK,-1,,"{
	return """";
}",121,,266,4,,void
58022,BLOCK,-1,,"{
}",1,,273,1,,void
58026,BLOCK,-1,,<empty>,50,,276,1,,void
58031,BLOCK,-1,,"{
	// find out period from the filename pattern
	if (getFileNamePattern().length() > 0)
	{
		parseFileNamePattern();
	}
	else
	{
		LogLog::warn(
			LOG4CXX_STR(""The FileNamePattern option must be set before using TimeBasedRollingPolicy. ""));
		throw IllegalStateException();
	}

	PatternConverterPtr dtc(getDatePatternConverter());

	if (dtc == NULL)
	{
		throw IllegalStateException();
	}

	LogString buf;
	ObjectPtr obj = std::make_shared<Date>();
	formatFileName(obj, buf, pool);
	m_priv->lastFileName = buf;

	if( m_priv->multiprocess ){
#if LOG4CXX_HAS_MULTIPROCESS_ROLLING_FILE_APPENDER
		if (getPatternConverterList().size())
		{
			(*(getPatternConverterList().begin()))->format(obj, m_priv->_fileNamePattern, pool);
		}
		else
		{
			m_priv->_fileNamePattern = m_priv->lastFileName;
		}

		if (!m_priv->_lock_file)
		{
			const std::string lockname = createFile(std::string(m_priv->_fileNamePattern), LOCK_FILE_SUFFIX, m_priv->_mmapPool);
			apr_status_t stat = apr_file_open(&m_priv->_lo...",1,,279,2,,void
58039,BLOCK,-1,,"{
		parseFileNamePattern();
	}",2,,282,2,,void
58042,BLOCK,-1,,"{
		LogLog::warn(
			LOG4CXX_STR(""The FileNamePattern option must be set before using TimeBasedRollingPolicy. ""));
		throw IllegalStateException();
	}",2,,286,1,,void
58058,BLOCK,-1,,"{
		throw IllegalStateException();
	}",2,,295,2,,void
58082,BLOCK,-1,,"{
#if LOG4CXX_HAS_MULTIPROCESS_ROLLING_FILE_APPENDER
		if (getPatternConverterList().size())
		{
			(*(getPatternConverterList().begin()))->format(obj, m_priv->_fileNamePattern, pool);
		}
		else
		{
			m_priv->_fileNamePattern = m_priv->lastFileName;
		}

		if (!m_priv->_lock_file)
		{
			const std::string lockname = createFile(std::string(m_priv->_fileNamePattern), LOCK_FILE_SUFFIX, m_priv->_mmapPool);
			apr_status_t stat = apr_file_open(&m_priv->_lock_file, lockname.c_str(), APR_CREATE | APR_READ | APR_WRITE, APR_OS_DEFAULT, m_priv->_mmapPool.getAPRPool());

			if (stat != APR_SUCCESS)
			{
				LogLog::warn(LOG4CXX_STR(""open lock file failed.""));
			}
		}

		initMMapFile(m_priv->lastFileName, m_priv->_mmapPool);
#endif
	}",28,,304,2,,void
58097,BLOCK,-1,,"{
		if (m_priv->lastFileName.compare(m_priv->lastFileName.length() - 3, 3, LOG4CXX_STR("".gz"")) == 0)
		{
			m_priv->suffixLength = 3;
		}
		else if (m_priv->lastFileName.length() >= 4 && m_priv->lastFileName.compare(m_priv->lastFileName.length() - 4, 4, LOG4CXX_STR("".zip"")) == 0)
		{
			m_priv->suffixLength = 4;
		}
	}",2,,333,2,,void
58118,BLOCK,-1,,"{
			m_priv->suffixLength = 3;
		}",3,,335,2,,void
58125,BLOCK,-1,,<empty>,8,,338,1,,void
58155,BLOCK,-1,,"{
			m_priv->suffixLength = 4;
		}",3,,339,2,,void
58164,BLOCK,-1,,"{
	PatternMap specs;
	RULES_PUT(""d"", FileDatePatternConverter);
	RULES_PUT(""date"", FileDatePatternConverter);
	return specs;
}",1,,350,1,,void
58168,BLOCK,1,,<empty>,,,,3,,void
58187,BLOCK,1,,<empty>,,,,3,,void
58212,BLOCK,-1,,"{
	Date now;
	log4cxx_time_t n = now.getTime();
	m_priv->nextCheck = now.getNextSecond();

	File currentFile(currentActiveFile);

	LogString buf;
	ObjectPtr obj = std::make_shared<Date>(currentFile.exists(pool) ? currentFile.lastModified(pool) : n);
	formatFileName(obj, buf, pool);
	m_priv->lastFileName = buf;

	ActionPtr noAction;

	if (currentActiveFile.length() > 0)
	{
		return std::make_shared<RolloverDescription>(
					currentActiveFile, append, noAction, noAction);
	}
	else
	{
		m_priv->bRefreshCurFile = true;
		return std::make_shared<RolloverDescription>(
					m_priv->lastFileName.substr(0, m_priv->lastFileName.length() - m_priv->suffixLength), append,
					noAction, noAction);
	}
}",1,,364,4,,void
58271,BLOCK,-1,,"{
		return std::make_shared<RolloverDescription>(
					currentActiveFile, append, noAction, noAction);
	}",2,,379,2,,void
58286,BLOCK,-1,,"{
		m_priv->bRefreshCurFile = true;
		return std::make_shared<RolloverDescription>(
					m_priv->lastFileName.substr(0, m_priv->lastFileName.length() - m_priv->suffixLength), append,
					noAction, noAction);
	}",2,,384,1,,void
58327,BLOCK,-1,,"{
	Date now;
	log4cxx_time_t n = now.getTime();
	m_priv->nextCheck = now.getNextSecond();

	LogString buf;
	ObjectPtr obj = std::make_shared<Date>(n);
	formatFileName(obj, buf, pool);

	LogString newFileName(buf);

	if( m_priv->multiprocess ){
#if LOG4CXX_HAS_MULTIPROCESS_ROLLING_FILE_APPENDER
		m_priv->bAlreadyInitialized = true;

		if (m_priv->_mmap && !isMapFileEmpty(m_priv->_mmapPool))
		{
			lockMMapFile(APR_FLOCK_SHARED);
			LogString mapLastFile((char*)m_priv->_mmap->mm);
			m_priv->lastFileName = mapLastFile;
			unLockMMapFile();
		}
		else
		{
			m_priv->_mmap = NULL;
			initMMapFile(m_priv->lastFileName, m_priv->_mmapPool);
		}
#endif
	}

	//
	//  if file names haven't changed, no rollover
	//
	if (newFileName == m_priv->lastFileName)
	{
		RolloverDescriptionPtr desc;
		return desc;
	}

	ActionPtr renameAction;
	ActionPtr compressAction;
	LogString lastBaseName(
		m_priv->lastFileName.substr(0, m_priv->lastFileName.length() - m_priv->suffixLength));
	LogString nextActiveFi...",1,,396,4,,void
58366,BLOCK,-1,,"{
#if LOG4CXX_HAS_MULTIPROCESS_ROLLING_FILE_APPENDER
		m_priv->bAlreadyInitialized = true;

		if (m_priv->_mmap && !isMapFileEmpty(m_priv->_mmapPool))
		{
			lockMMapFile(APR_FLOCK_SHARED);
			LogString mapLastFile((char*)m_priv->_mmap->mm);
			m_priv->lastFileName = mapLastFile;
			unLockMMapFile();
		}
		else
		{
			m_priv->_mmap = NULL;
			initMMapFile(m_priv->lastFileName, m_priv->_mmapPool);
		}
#endif
	}",28,,407,2,,void
58373,BLOCK,-1,,"{
		RolloverDescriptionPtr desc;
		return desc;
	}",2,,430,2,,void
58415,BLOCK,-1,,"{
		File compressedFile(m_priv->lastFileName);
		File compressedParent (compressedFile.getParent(pool));
		compressedParent.mkdirs(pool);
	}",40,,442,2,,void
58437,BLOCK,-1,,"{
		renameAction = std::make_shared<FileRenameAction>(
					File().setPath(currentActiveFile), File().setPath(lastBaseName), true);
		nextActiveFile = currentActiveFile;
	}",2,,453,2,,void
58468,BLOCK,-1,,"{
		GZCompressActionPtr comp = std::make_shared<GZCompressAction>(
					File().setPath(lastBaseName), File().setPath(m_priv->lastFileName), true);
		comp->setThrowIOExceptionOnForkFailure(m_priv->throwIOExceptionOnForkFailure);
		compressAction = comp;
	}",2,,460,2,,void
58509,BLOCK,-1,,"{
		ZipCompressActionPtr comp = std::make_shared<ZipCompressAction>(
					File().setPath(lastBaseName), File().setPath(m_priv->lastFileName), true);
		comp->setThrowIOExceptionOnForkFailure(m_priv->throwIOExceptionOnForkFailure);
		compressAction = comp;
	}",2,,468,2,,void
58548,BLOCK,-1,,"{
#if LOG4CXX_HAS_MULTIPROCESS_ROLLING_FILE_APPENDER
		if (m_priv->_mmap && !isMapFileEmpty(m_priv->_mmapPool))
		{
			lockMMapFile(APR_FLOCK_EXCLUSIVE);
			memset(m_priv->_mmap->mm, 0, MAX_FILE_LEN);
			memcpy(m_priv->_mmap->mm, std::string(newFileName).c_str(), std::string(newFileName).size());
			unLockMMapFile();
		}
		else
		{
			m_priv->_mmap = NULL;
			initMMapFile(newFileName, m_priv->_mmapPool);
		}
#endif
	}",28,,475,2,,void
58550,BLOCK,-1,,"{
		m_priv->lastFileName = newFileName;
	}",7,,490,1,,void
58576,BLOCK,-1,,"{
	if( m_priv->multiprocess ){
#if LOG4CXX_HAS_MULTIPROCESS_ROLLING_FILE_APPENDER
		if (m_priv->bRefreshCurFile && m_priv->_mmap && !isMapFileEmpty(m_priv->_mmapPool))
		{
			lockMMapFile(APR_FLOCK_SHARED);
			LogString mapCurrent((char*)m_priv->_mmap->mm);
			unLockMMapFile();
			LogString mapCurrentBase(mapCurrent.substr(0, mapCurrent.length() - m_priv->suffixLength));

			if (!mapCurrentBase.empty() && mapCurrentBase != filename)
			{
				const FileAppender* fappend = reinterpret_cast<const FileAppender*>(appender->cast(FileAppender::getStaticClass()));
				if( fappend ){
					const_cast<FileAppender*>(fappend)->setFile(mapCurrentBase);
				}
			}
		}

		return ( Date::currentTime() > m_priv->nextCheck) || (!m_priv->bAlreadyInitialized);
#endif
	}

	return Date::currentTime() > m_priv->nextCheck;
}",1,,502,5,,void
58581,BLOCK,-1,,"{
#if LOG4CXX_HAS_MULTIPROCESS_ROLLING_FILE_APPENDER
		if (m_priv->bRefreshCurFile && m_priv->_mmap && !isMapFileEmpty(m_priv->_mmapPool))
		{
			lockMMapFile(APR_FLOCK_SHARED);
			LogString mapCurrent((char*)m_priv->_mmap->mm);
			unLockMMapFile();
			LogString mapCurrentBase(mapCurrent.substr(0, mapCurrent.length() - m_priv->suffixLength));

			if (!mapCurrentBase.empty() && mapCurrentBase != filename)
			{
				const FileAppender* fappend = reinterpret_cast<const FileAppender*>(appender->cast(FileAppender::getStaticClass()));
				if( fappend ){
					const_cast<FileAppender*>(fappend)->setFile(mapCurrentBase);
				}
			}
		}

		return ( Date::currentTime() > m_priv->nextCheck) || (!m_priv->bAlreadyInitialized);
#endif
	}",28,,503,2,,void
58595,BLOCK,-1,,"{
#if LOG4CXX_HAS_MULTIPROCESS_ROLLING_FILE_APPENDER
	// If we don't have the multiprocess stuff, disregard any attempt to set this value
	m_priv->multiprocess = multiprocess;
#endif
}",64,,528,2,,void
58601,BLOCK,-1,,"{
	if (StringHelper::equalsIgnoreCase(option,
			LOG4CXX_STR(""THROWIOEXCEPTIONONFORKFAILURE""),
			LOG4CXX_STR(""throwioexceptiononforkfailure"")))
	{
		m_priv->throwIOExceptionOnForkFailure = OptionConverter::toBoolean(value, true);
	}
	else
	{
		RollingPolicyBase::setOption(option, value);
	}
}",1,,537,3,,void
58612,BLOCK,-1,,"{
		m_priv->throwIOExceptionOnForkFailure = OptionConverter::toBoolean(value, true);
	}",2,,541,2,,void
58624,BLOCK,-1,,"{
		RollingPolicyBase::setOption(option, value);
	}",2,,545,1,,void
58657,BLOCK,-1,,<empty>,1,,1,1,,ANY
58665,BLOCK,-1,,"{
			static WideLife<TimeZonePtr> tz = std::make_shared<GMTTimeZone>();
			return tz;
		}",3,,48,1,,void
58680,BLOCK,-1,,"{
			apr_status_t stat;

			//  APR 1.1 and early mishandles microseconds on dates
			//   before 1970, APR bug 32520
			if (LOG4CXX_UNLIKELY(input < 0 && apr_time_usec(input) < 0))
			{
				apr_time_t floorTime = (apr_time_sec(input) - 1) * APR_USEC_PER_SEC;
				stat = apr_time_exp_gmt(result, floorTime);
				result->tm_usec = (int) (input - floorTime);
			}
			else
			{
				stat = apr_time_exp_gmt( result, input );
			}

			return stat;
		}",3,,55,3,,void
58692,BLOCK,-1,,"{
				apr_time_t floorTime = (apr_time_sec(input) - 1) * APR_USEC_PER_SEC;
				stat = apr_time_exp_gmt(result, floorTime);
				result->tm_usec = (int) (input - floorTime);
			}",4,,61,2,,void
58717,BLOCK,-1,,"{
				stat = apr_time_exp_gmt( result, input );
			}",4,,67,1,,void
58728,BLOCK,-1,,"{
		}",3,,75,1,,void
58733,BLOCK,-1,,"{
			static WideLife<TimeZonePtr> tz = std::make_shared<LocalTimeZone>();
			return tz;
		}",3,,87,1,,void
58748,BLOCK,-1,,"{
			apr_status_t stat;

			//  APR 1.1 and early mishandles microseconds on dates
			//   before 1970, APR bug 32520
			if (LOG4CXX_UNLIKELY(input < 0 && apr_time_usec(input) < 0))
			{
				apr_time_t floorTime = (apr_time_sec(input) - 1) * APR_USEC_PER_SEC;
				stat = apr_time_exp_lt(result, floorTime);
				result->tm_usec = (int) (input - floorTime);
			}
			else
			{
				stat = apr_time_exp_lt( result, input );
			}

			return stat;
		}",3,,94,3,,void
58760,BLOCK,-1,,"{
				apr_time_t floorTime = (apr_time_sec(input) - 1) * APR_USEC_PER_SEC;
				stat = apr_time_exp_lt(result, floorTime);
				result->tm_usec = (int) (input - floorTime);
			}",4,,100,2,,void
58785,BLOCK,-1,,"{
				stat = apr_time_exp_lt( result, input );
			}",4,,106,1,,void
58796,BLOCK,-1,,"{
		}",3,,115,1,,void
58800,BLOCK,-1,,"{
			const int MAX_TZ_LENGTH = 255;
			char tzName[MAX_TZ_LENGTH];
			apr_size_t tzLength;
			apr_time_exp_t tm;
			apr_time_exp_lt(&tm, 0);
			apr_strftime(tzName, &tzLength, MAX_TZ_LENGTH, ""%Z"", &tm);

			if (tzLength == 0)
			{
				apr_strftime(tzName, &tzLength, MAX_TZ_LENGTH, ""%z"", &tm);
			}

			tzName[tzLength] = 0;
			LogString retval;
			LOG4CXX_NS::helpers::Transcoder::decode(tzName, retval);
			return retval;
		}",3,,120,1,,void
58824,BLOCK,-1,,"{
				apr_strftime(tzName, &tzLength, MAX_TZ_LENGTH, ""%z"", &tm);
			}",4,,129,2,,void
58857,BLOCK,-1,,"{
		}",3,,148,3,,void
58863,BLOCK,-1,,"{
			apr_status_t stat;

			//  APR 1.1 and early mishandles microseconds on dates
			//   before 1970, APR bug 32520
			if (LOG4CXX_UNLIKELY(input < 0 && apr_time_usec(input) < 0))
			{
				apr_time_t floorTime = (apr_time_sec(input) - 1) * APR_USEC_PER_SEC;
				stat = apr_time_exp_tz(result, floorTime, offset);
				result->tm_usec = (int) (input - floorTime);
			}
			else
			{
				stat = apr_time_exp_tz( result, input, offset );
			}

			return stat;
		}",3,,153,3,,void
58875,BLOCK,-1,,"{
				apr_time_t floorTime = (apr_time_sec(input) - 1) * APR_USEC_PER_SEC;
				stat = apr_time_exp_tz(result, floorTime, offset);
				result->tm_usec = (int) (input - floorTime);
			}",4,,159,2,,void
58901,BLOCK,-1,,"{
				stat = apr_time_exp_tz( result, input, offset );
			}",4,,165,1,,void
58915,BLOCK,-1,,"{
}",1,,184,2,,void
58919,BLOCK,-1,,"{
}",1,,188,1,,void
58923,BLOCK,-1,,"{
	return LOG4CXX_NS::helpers::TimeZoneImpl::LocalTimeZone::getInstance();
}",1,,192,1,,void
58938,BLOCK,-1,,"{
	return LOG4CXX_NS::helpers::TimeZoneImpl::GMTTimeZone::getInstance();
}",1,,197,1,,void
58954,BLOCK,-1,,"{
	const logchar gmt[] = { 0x47, 0x4D, 0x54, 0 };

	if ( id == gmt )
	{
		return LOG4CXX_NS::helpers::TimeZoneImpl::GMTTimeZone::getInstance();
	}

	if ( id.length() >= 5 && id.substr( 0, 3 ) == gmt )
	{
		int hours = 0;
		int minutes = 0;
		int sign = 1;

		if (id[3] == 0x2D /* '-' */)
		{
			sign = -1;
		}

		LogString off( id.substr( 4 ) );

		if ( id.length() >= 7 )
		{
			size_t colonPos = off.find( 0x3A /* ':' */);

			if ( colonPos == LogString::npos )
			{
				minutes = StringHelper::toInt(off.substr(off.length() - 2));
				hours = StringHelper::toInt(off.substr(0, off.length() - 2));
			}
			else
			{
				minutes = StringHelper::toInt(off.substr(colonPos + 1));
				hours = StringHelper::toInt(off.substr(0, colonPos));
			}
		}
		else
		{
			hours = StringHelper::toInt(off);
		}

		LogString s(gmt);
		Pool p;
		LogString hh;
		StringHelper::toString(hours, p, hh);

		if (sign > 0)
		{
			s.append(1, (logchar) 0x2B /* '+' */);
		}
		else
		{
			s.append(1, (logchar) 0x2D /* '...",1,,202,2,,void
58967,BLOCK,-1,,"{
		return LOG4CXX_NS::helpers::TimeZoneImpl::GMTTimeZone::getInstance();
	}",2,,206,2,,void
58995,BLOCK,-1,,"{
		int hours = 0;
		int minutes = 0;
		int sign = 1;

		if (id[3] == 0x2D /* '-' */)
		{
			sign = -1;
		}

		LogString off( id.substr( 4 ) );

		if ( id.length() >= 7 )
		{
			size_t colonPos = off.find( 0x3A /* ':' */);

			if ( colonPos == LogString::npos )
			{
				minutes = StringHelper::toInt(off.substr(off.length() - 2));
				hours = StringHelper::toInt(off.substr(0, off.length() - 2));
			}
			else
			{
				minutes = StringHelper::toInt(off.substr(colonPos + 1));
				hours = StringHelper::toInt(off.substr(0, colonPos));
			}
		}
		else
		{
			hours = StringHelper::toInt(off);
		}

		LogString s(gmt);
		Pool p;
		LogString hh;
		StringHelper::toString(hours, p, hh);

		if (sign > 0)
		{
			s.append(1, (logchar) 0x2B /* '+' */);
		}
		else
		{
			s.append(1, (logchar) 0x2D /* '-' */);
		}

		if (hh.length() == 1)
		{
			s.append(1, (logchar) 0x30 /* '0' */);
		}

		s.append(hh);
		s.append(1, (logchar) 0x3A /*' :' */);
		LogString mm;
		StringHelper::toString(minutes, p, mm);...",2,,211,2,,void
59014,BLOCK,-1,,"{
			sign = -1;
		}",3,,217,2,,void
59033,BLOCK,-1,,"{
			size_t colonPos = off.find( 0x3A /* ':' */);

			if ( colonPos == LogString::npos )
			{
				minutes = StringHelper::toInt(off.substr(off.length() - 2));
				hours = StringHelper::toInt(off.substr(0, off.length() - 2));
			}
			else
			{
				minutes = StringHelper::toInt(off.substr(colonPos + 1));
				hours = StringHelper::toInt(off.substr(0, colonPos));
			}
		}",3,,224,2,,void
59048,BLOCK,-1,,"{
				minutes = StringHelper::toInt(off.substr(off.length() - 2));
				hours = StringHelper::toInt(off.substr(0, off.length() - 2));
			}",4,,228,2,,void
59083,BLOCK,-1,,"{
				minutes = StringHelper::toInt(off.substr(colonPos + 1));
				hours = StringHelper::toInt(off.substr(0, colonPos));
			}",4,,233,1,,void
59110,BLOCK,-1,,"{
			hours = StringHelper::toInt(off);
		}",3,,239,1,,void
59134,BLOCK,-1,,"{
			s.append(1, (logchar) 0x2B /* '+' */);
		}",3,,249,2,,void
59144,BLOCK,-1,,"{
			s.append(1, (logchar) 0x2D /* '-' */);
		}",3,,253,1,,void
59160,BLOCK,-1,,"{
			s.append(1, (logchar) 0x30 /* '0' */);
		}",3,,258,2,,void
59197,BLOCK,-1,,"{
			s.append(1, (logchar) 0x30 /* '0' */);
		}",3,,268,2,,void
59249,BLOCK,-1,,"{
		return ltz;
	}",2,,280,2,,void
59288,BLOCK,-1,,<empty>,1,,1,1,,ANY
59292,BLOCK,-1,,"{
	std::string::const_iterator iter = src.begin();

	while (iter != src.end())
	{
		unsigned int sv = decode(src, iter);

		if (sv != 0xFFFF)
		{
			encode(sv, dst);
		}
		else
		{
			dst.append(1, LOSSCHAR);
			iter++;
		}
	}
}",1,,44,3,,void
59307,BLOCK,-1,,"{
		unsigned int sv = decode(src, iter);

		if (sv != 0xFFFF)
		{
			encode(sv, dst);
		}
		else
		{
			dst.append(1, LOSSCHAR);
			iter++;
		}
	}",2,,48,2,,void
59318,BLOCK,-1,,"{
			encode(sv, dst);
		}",3,,52,2,,void
59323,BLOCK,-1,,"{
			dst.append(1, LOSSCHAR);
			iter++;
		}",3,,56,1,,void
59337,BLOCK,-1,,"{
#if LOG4CXX_LOGCHAR_IS_UTF8
	dst.append(src);
#else
	LogString::const_iterator iter = src.begin();

	while (iter != src.end())
	{
		unsigned int sv = decode(src, iter);

		if (sv != 0xFFFF)
		{
			encode(sv, dst);
		}
		else
		{
			dst.append(1, LOSSCHAR);
			iter++;
		}
	}

#endif
}",1,,64,3,,void
59352,BLOCK,-1,,"{
		unsigned int sv = decode(src, iter);

		if (sv != 0xFFFF)
		{
			encode(sv, dst);
		}
		else
		{
			dst.append(1, LOSSCHAR);
			iter++;
		}
	}",2,,71,2,,void
59363,BLOCK,-1,,"{
			encode(sv, dst);
		}",3,,75,2,,void
59368,BLOCK,-1,,"{
			dst.append(1, LOSSCHAR);
			iter++;
		}",3,,79,1,,void
59382,BLOCK,-1,,"{
#if LOG4CXX_LOGCHAR_IS_UTF8
	return p.pstrdup(src);
#else
	std::string tmp;
	encodeUTF8(src, tmp);
	return p.pstrdup(tmp);
#endif
}",1,,89,3,,void
59398,BLOCK,-1,,"{
	size_t bytes = encodeUTF8(sv, dst.current());
	dst.position(dst.position() + bytes);
}",1,,101,3,,void
59423,BLOCK,-1,,"{
	if (ch < 0x80)
	{
		dst[0] = (char) ch;
		return 1;
	}
	else if (ch < 0x800)
	{
		dst[0] = (char) (0xC0 + (ch >> 6));
		dst[1] = (char) (0x80 + (ch & 0x3F));
		return 2;
	}
	else if (ch < 0x10000)
	{
		dst[0] = (char) (0xE0 + (ch >> 12));
		dst[1] = (char) (0x80 + ((ch >> 6) & 0x3F));
		dst[2] = (char) (0x80 + (ch & 0x3F));
		return 3;
	}
	else if (ch <= 0x10FFFF)
	{
		dst[0] = (char) (0xF0 + (ch >> 18));
		dst[1] = (char) (0x80 + ((ch >> 12) & 0x3F));
		dst[2] = (char) (0x80 + ((ch >> 6) & 0x3F));
		dst[3] = (char) (0x80 + (ch & 0x3F));
		return 4;
	}
	else
	{
		//
		//  output UTF-8 encoding of 0xFFFF
		//
		dst[0] = (char) 0xEF;
		dst[1] = (char) 0xBF;
		dst[2] = (char) 0xBF;
		return 3;
	}
}",1,,108,3,,void
59428,BLOCK,-1,,"{
		dst[0] = (char) ch;
		return 1;
	}",2,,110,2,,void
59439,BLOCK,-1,,<empty>,7,,114,1,,void
59444,BLOCK,-1,,"{
		dst[0] = (char) (0xC0 + (ch >> 6));
		dst[1] = (char) (0x80 + (ch & 0x3F));
		return 2;
	}",2,,115,2,,void
59470,BLOCK,-1,,<empty>,7,,120,1,,void
59475,BLOCK,-1,,"{
		dst[0] = (char) (0xE0 + (ch >> 12));
		dst[1] = (char) (0x80 + ((ch >> 6) & 0x3F));
		dst[2] = (char) (0x80 + (ch & 0x3F));
		return 3;
	}",2,,121,2,,void
59514,BLOCK,-1,,<empty>,7,,127,1,,void
59519,BLOCK,-1,,"{
		dst[0] = (char) (0xF0 + (ch >> 18));
		dst[1] = (char) (0x80 + ((ch >> 12) & 0x3F));
		dst[2] = (char) (0x80 + ((ch >> 6) & 0x3F));
		dst[3] = (char) (0x80 + (ch & 0x3F));
		return 4;
	}",2,,128,2,,void
59571,BLOCK,-1,,"{
		//
		//  output UTF-8 encoding of 0xFFFF
		//
		dst[0] = (char) 0xEF;
		dst[1] = (char) 0xBF;
		dst[2] = (char) 0xBF;
		return 3;
	}",2,,136,1,,void
59600,BLOCK,-1,,"{
	size_t bytes = encodeUTF16BE(sv, dst.current());
	dst.position(dst.position() + bytes);
}",1,,148,3,,void
59625,BLOCK,-1,,"{
	if (ch <= 0xFFFF)
	{
		dst[0] = (char) (ch >> 8);
		dst[1] = (char) (ch & 0xFF);
		return 2;
	}

	if (ch <= 0x10FFFF)
	{
		unsigned char w = (unsigned char) ((ch >> 16) - 1);
		dst[0] = (char) (0xD8 + (w >> 2));
		dst[1] = (char) (((w & 0x03) << 6) + ((ch >> 10) & 0x3F));
		dst[2] = (char) (0xDC + ((ch & 0x30) >> 4));
		dst[3] = (char) (ch & 0xFF);
		return 4;
	}

	dst[0] = dst[1] = (char) 0xFF;
	return 2;
}",1,,155,3,,void
59630,BLOCK,-1,,"{
		dst[0] = (char) (ch >> 8);
		dst[1] = (char) (ch & 0xFF);
		return 2;
	}",2,,157,2,,void
59655,BLOCK,-1,,"{
		unsigned char w = (unsigned char) ((ch >> 16) - 1);
		dst[0] = (char) (0xD8 + (w >> 2));
		dst[1] = (char) (((w & 0x03) << 6) + ((ch >> 10) & 0x3F));
		dst[2] = (char) (0xDC + ((ch & 0x30) >> 4));
		dst[3] = (char) (ch & 0xFF);
		return 4;
	}",2,,164,2,,void
59736,BLOCK,-1,,"{
	size_t bytes = encodeUTF16LE(sv, dst.current());
	dst.position(dst.position() + bytes);
}",1,,178,3,,void
59761,BLOCK,-1,,"{
	if (ch <= 0xFFFF)
	{
		dst[1] = (char) (ch >> 8);
		dst[0] = (char) (ch & 0xFF);
		return 2;
	}

	if (ch <= 0x10FFFF)
	{
		unsigned char w = (unsigned char) ((ch >> 16) - 1);
		dst[1] = (char) (0xD8 + (w >> 2));
		dst[0] = (char) (((w & 0x03) << 6) + ((ch >> 10) & 0x3F));
		dst[3] = (char) (0xDC + ((ch & 0x30) >> 4));
		dst[2] = (char) (ch & 0xFF);
		return 4;
	}

	dst[0] = dst[1] = (char) 0xFF;
	return 2;
}",1,,184,3,,void
59766,BLOCK,-1,,"{
		dst[1] = (char) (ch >> 8);
		dst[0] = (char) (ch & 0xFF);
		return 2;
	}",2,,186,2,,void
59791,BLOCK,-1,,"{
		unsigned char w = (unsigned char) ((ch >> 16) - 1);
		dst[1] = (char) (0xD8 + (w >> 2));
		dst[0] = (char) (((w & 0x03) << 6) + ((ch >> 10) & 0x3F));
		dst[3] = (char) (0xDC + ((ch & 0x30) >> 4));
		dst[2] = (char) (ch & 0xFF);
		return 4;
	}",2,,193,2,,void
59872,BLOCK,-1,,"{
	std::string::const_iterator start(iter);
	unsigned char ch1 = *(iter++);

	if (ch1 <= 0x7F)
	{
		return ch1;
	}

	//
	//   should not have continuation character here
	//
	if ((ch1 & 0xC0) != 0x80 && iter != src.end())
	{
		unsigned char ch2 = *(iter++);

		//
		//   should be continuation
		if ((ch2 & 0xC0) != 0x80)
		{
			iter = start;
			return 0xFFFF;
		}

		if ((ch1 & 0xE0) == 0xC0)
		{
			if ((ch2 & 0xC0) == 0x80)
			{
				unsigned int rv = ((ch1 & 0x1F) << 6) + (ch2 & 0x3F);

				if (rv >= 0x80)
				{
					return rv;
				}
			}

			iter = start;
			return 0xFFFF;
		}

		if (iter != src.end())
		{
			unsigned char ch3 = *(iter++);

			//
			//   should be continuation
			//
			if ((ch3 & 0xC0) != 0x80)
			{
				iter = start;
				return 0xFFFF;
			}

			if ((ch1 & 0xF0) == 0xE0)
			{
				unsigned rv = ((ch1 & 0x0F) << 12)
					+ ((ch2 & 0x3F) << 6)
					+ (ch3 & 0x3F);

				if (rv <= 0x800)
				{
					iter = start;
					return 0xFFFF;
				}

				return rv;
			}

			if (iter ...",1,,209,3,,void
59886,BLOCK,-1,,"{
		return ch1;
	}",2,,214,2,,void
59902,BLOCK,-1,,"{
		unsigned char ch2 = *(iter++);

		//
		//   should be continuation
		if ((ch2 & 0xC0) != 0x80)
		{
			iter = start;
			return 0xFFFF;
		}

		if ((ch1 & 0xE0) == 0xC0)
		{
			if ((ch2 & 0xC0) == 0x80)
			{
				unsigned int rv = ((ch1 & 0x1F) << 6) + (ch2 & 0x3F);

				if (rv >= 0x80)
				{
					return rv;
				}
			}

			iter = start;
			return 0xFFFF;
		}

		if (iter != src.end())
		{
			unsigned char ch3 = *(iter++);

			//
			//   should be continuation
			//
			if ((ch3 & 0xC0) != 0x80)
			{
				iter = start;
				return 0xFFFF;
			}

			if ((ch1 & 0xF0) == 0xE0)
			{
				unsigned rv = ((ch1 & 0x0F) << 12)
					+ ((ch2 & 0x3F) << 6)
					+ (ch3 & 0x3F);

				if (rv <= 0x800)
				{
					iter = start;
					return 0xFFFF;
				}

				return rv;
			}

			if (iter != src.end())
			{
				unsigned char ch4 = *(iter++);

				if ((ch4 & 0xC0) != 0x80)
				{
					iter = start;
					return 0xFFFF;
				}

				unsigned int rv = ((ch1 & 0x07) << 18)
					+ ((ch2 & 0x3F) << 12)
					+ ((ch3 & ...",2,,222,2,,void
59915,BLOCK,-1,,"{
			iter = start;
			return 0xFFFF;
		}",3,,228,2,,void
59927,BLOCK,-1,,"{
			if ((ch2 & 0xC0) == 0x80)
			{
				unsigned int rv = ((ch1 & 0x1F) << 6) + (ch2 & 0x3F);

				if (rv >= 0x80)
				{
					return rv;
				}
			}

			iter = start;
			return 0xFFFF;
		}",3,,234,2,,void
59934,BLOCK,-1,,"{
				unsigned int rv = ((ch1 & 0x1F) << 6) + (ch2 & 0x3F);

				if (rv >= 0x80)
				{
					return rv;
				}
			}",4,,236,2,,void
59951,BLOCK,-1,,"{
					return rv;
				}",5,,240,2,,void
59966,BLOCK,-1,,"{
			unsigned char ch3 = *(iter++);

			//
			//   should be continuation
			//
			if ((ch3 & 0xC0) != 0x80)
			{
				iter = start;
				return 0xFFFF;
			}

			if ((ch1 & 0xF0) == 0xE0)
			{
				unsigned rv = ((ch1 & 0x0F) << 12)
					+ ((ch2 & 0x3F) << 6)
					+ (ch3 & 0x3F);

				if (rv <= 0x800)
				{
					iter = start;
					return 0xFFFF;
				}

				return rv;
			}

			if (iter != src.end())
			{
				unsigned char ch4 = *(iter++);

				if ((ch4 & 0xC0) != 0x80)
				{
					iter = start;
					return 0xFFFF;
				}

				unsigned int rv = ((ch1 & 0x07) << 18)
					+ ((ch2 & 0x3F) << 12)
					+ ((ch3 & 0x3F) << 6)
					+ (ch4 & 0x3F);

				if (rv > 0xFFFF)
				{
					return rv;
				}

			}
		}",3,,250,2,,void
59979,BLOCK,-1,,"{
				iter = start;
				return 0xFFFF;
			}",4,,257,2,,void
59991,BLOCK,-1,,"{
				unsigned rv = ((ch1 & 0x0F) << 12)
					+ ((ch2 & 0x3F) << 6)
					+ (ch3 & 0x3F);

				if (rv <= 0x800)
				{
					iter = start;
					return 0xFFFF;
				}

				return rv;
			}",4,,263,2,,void
60014,BLOCK,-1,,"{
					iter = start;
					return 0xFFFF;
				}",5,,269,2,,void
60029,BLOCK,-1,,"{
				unsigned char ch4 = *(iter++);

				if ((ch4 & 0xC0) != 0x80)
				{
					iter = start;
					return 0xFFFF;
				}

				unsigned int rv = ((ch1 & 0x07) << 18)
					+ ((ch2 & 0x3F) << 12)
					+ ((ch3 & 0x3F) << 6)
					+ (ch4 & 0x3F);

				if (rv > 0xFFFF)
				{
					return rv;
				}

			}",4,,278,2,,void
60042,BLOCK,-1,,"{
					iter = start;
					return 0xFFFF;
				}",5,,282,2,,void
60076,BLOCK,-1,,"{
					return rv;
				}",5,,293,2,,void
60089,BLOCK,-1,,"{
	char tmp[8];
	size_t bytes = encodeUTF8(sv, tmp);
	dst.append(tmp, bytes);
}",1,,307,3,,void
60108,BLOCK,-1,,"{
#if LOG4CXX_CHARSET_UTF8 && LOG4CXX_LOGCHAR_IS_UTF8
	dst.append(src);
#else
	static CharsetDecoderPtr decoder(CharsetDecoder::getDefaultDecoder());
	dst.reserve(dst.size() + src.size());
	std::string::const_iterator iter = src.begin();
#if !LOG4CXX_CHARSET_EBCDIC

	for (;
		iter != src.end() && ((unsigned char) *iter) < 0x80;
		iter++)
	{
		dst.append(1, *iter);
	}

#endif

	if (iter != src.end())
	{
		size_t offset = iter - src.begin();
		ByteBuffer buf(const_cast<char*>(src.data() + offset), src.size() - offset);

		while (buf.remaining() > 0)
		{
			log4cxx_status_t stat = decoder->decode(buf, dst);

			if (CharsetDecoder::isError(stat))
			{
				dst.append(1, LOSSCHAR);
				buf.position(buf.position() + 1);
			}
		}

		decoder->decode(buf, dst);
	}

#endif
}",1,,315,3,,void
60136,BLOCK,-1,,<empty>,2,,324,1,,void
60152,BLOCK,4,,"{
		dst.append(1, *iter);
	}",2,,327,4,,void
60167,BLOCK,-1,,"{
		size_t offset = iter - src.begin();
		ByteBuffer buf(const_cast<char*>(src.data() + offset), src.size() - offset);

		while (buf.remaining() > 0)
		{
			log4cxx_status_t stat = decoder->decode(buf, dst);

			if (CharsetDecoder::isError(stat))
			{
				dst.append(1, LOSSCHAR);
				buf.position(buf.position() + 1);
			}
		}

		decoder->decode(buf, dst);
	}",2,,334,2,,void
60200,BLOCK,-1,,"{
			log4cxx_status_t stat = decoder->decode(buf, dst);

			if (CharsetDecoder::isError(stat))
			{
				dst.append(1, LOSSCHAR);
				buf.position(buf.position() + 1);
			}
		}",3,,339,2,,void
60216,BLOCK,-1,,"{
				dst.append(1, LOSSCHAR);
				buf.position(buf.position() + 1);
			}",4,,343,2,,void
60244,BLOCK,-1,,"{
#if LOG4CXX_CHARSET_UTF8 && LOG4CXX_LOGCHAR_IS_UTF8
	return p.pstrdup(src);
#else
	std::string tmp;
	encode(src, tmp);
	return p.pstrdup(tmp);
#endif
}",1,,356,3,,void
60260,BLOCK,-1,,"{
#if LOG4CXX_CHARSET_UTF8 && LOG4CXX_LOGCHAR_IS_UTF8
	dst.append(src);
#else
	static CharsetEncoderPtr encoder(CharsetEncoder::getDefaultEncoder());
	dst.reserve(dst.size() + src.size());
	LogString::const_iterator iter = src.begin();
#if !LOG4CXX_CHARSET_EBCDIC

	for (;
		iter != src.end() && ((unsigned int) *iter) < 0x80;
		iter++)
	{
		dst.append(1, *iter);
	}

#endif

	if (iter != src.end())
	{
		char buf[BUFSIZE];
		ByteBuffer out(buf, BUFSIZE);

		while (iter != src.end())
		{
			log4cxx_status_t stat = encoder->encode(src, iter, out);
			out.flip();
			dst.append(out.data(), out.limit());
			out.clear();

			if (CharsetEncoder::isError(stat))
			{
				dst.append(1, LOSSCHAR);
				iter++;
			}
		}

		encoder->encode(src, iter, out);
	}

#endif
}",1,,369,3,,void
60288,BLOCK,-1,,<empty>,2,,378,1,,void
60304,BLOCK,4,,"{
		dst.append(1, *iter);
	}",2,,381,4,,void
60319,BLOCK,-1,,"{
		char buf[BUFSIZE];
		ByteBuffer out(buf, BUFSIZE);

		while (iter != src.end())
		{
			log4cxx_status_t stat = encoder->encode(src, iter, out);
			out.flip();
			dst.append(out.data(), out.limit());
			out.clear();

			if (CharsetEncoder::isError(stat))
			{
				dst.append(1, LOSSCHAR);
				iter++;
			}
		}

		encoder->encode(src, iter, out);
	}",2,,388,2,,void
60332,BLOCK,-1,,"{
			log4cxx_status_t stat = encoder->encode(src, iter, out);
			out.flip();
			dst.append(out.data(), out.limit());
			out.clear();

			if (CharsetEncoder::isError(stat))
			{
				dst.append(1, LOSSCHAR);
				iter++;
			}
		}",3,,393,2,,void
60369,BLOCK,-1,,"{
				dst.append(1, LOSSCHAR);
				iter++;
			}",4,,400,2,,void
60390,BLOCK,-1,,"{
	unsigned int ch1 = *iter;

	//
	//   if not surrogate pair
	//
	if (ch1 < 0xD800 || ch1 > 0xDFFF)
	{
		//
		//  then advance iterator and return wchar_t value
		//
		if (ch1 != 0xFFFF)
		{
			iter++;
		}

		return ch1;
	}
	else if (ch1 < 0xDC00)
	{
		//
		//  started with high-surrogate value
		//     if there is an additional wchar_t
		Iterator iter2 = iter + 1;

		if (iter2 != in.end())
		{
			unsigned int ch2 = *iter2;

			//
			//    if it is a matching low surrogate then
			//       advance the iterator and return the scalar value
			if (ch2 >= 0xDC00 && ch2 <= 0xDFFF)
			{
				iter += 2;
				return (ch1 - 0xD800) * 0x400 + (ch2 - 0xDC00) + 0x10000;
			}
		}
	}

	//
	//    unrecognized value, do not advance iterator
	//
	return 0xFFFF;
}",1,,415,3,,void
60404,BLOCK,-1,,"{
		//
		//  then advance iterator and return wchar_t value
		//
		if (ch1 != 0xFFFF)
		{
			iter++;
		}

		return ch1;
	}",2,,422,2,,void
60409,BLOCK,-1,,"{
			iter++;
		}",3,,427,2,,void
60415,BLOCK,-1,,<empty>,7,,433,1,,void
60420,BLOCK,-1,,"{
		//
		//  started with high-surrogate value
		//     if there is an additional wchar_t
		Iterator iter2 = iter + 1;

		if (iter2 != in.end())
		{
			unsigned int ch2 = *iter2;

			//
			//    if it is a matching low surrogate then
			//       advance the iterator and return the scalar value
			if (ch2 >= 0xDC00 && ch2 <= 0xDFFF)
			{
				iter += 2;
				return (ch1 - 0xD800) * 0x400 + (ch2 - 0xDC00) + 0x10000;
			}
		}
	}",2,,434,2,,void
60434,BLOCK,-1,,"{
			unsigned int ch2 = *iter2;

			//
			//    if it is a matching low surrogate then
			//       advance the iterator and return the scalar value
			if (ch2 >= 0xDC00 && ch2 <= 0xDFFF)
			{
				iter += 2;
				return (ch1 - 0xD800) * 0x400 + (ch2 - 0xDC00) + 0x10000;
			}
		}",3,,441,2,,void
60448,BLOCK,-1,,"{
				iter += 2;
				return (ch1 - 0xD800) * 0x400 + (ch2 - 0xDC00) + 0x10000;
			}",4,,448,2,,void
60471,BLOCK,-1,,"{
	if (sv < 0x10000)
	{
		dst.append(1, sv);
	}
	else
	{
		unsigned char u = (unsigned char) (sv >> 16);
		unsigned char w = (unsigned char) (u - 1);
		unsigned short hs = (0xD800 + ((w & 0xF) << 6) + ((sv & 0xFFFF) >> 10));
		unsigned short ls = (0xDC00 + (sv & 0x3FF));
		dst.append(1, hs);
		dst.append(1, ls);
	}
}",1,,463,3,,void
60476,BLOCK,-1,,"{
		dst.append(1, sv);
	}",2,,465,2,,void
60484,BLOCK,-1,,"{
		unsigned char u = (unsigned char) (sv >> 16);
		unsigned char w = (unsigned char) (u - 1);
		unsigned short hs = (0xD800 + ((w & 0xF) << 6) + ((sv & 0xFFFF) >> 10));
		unsigned short ls = (0xDC00 + (sv & 0x3FF));
		dst.append(1, hs);
		dst.append(1, ls);
	}",2,,469,1,,void
60541,BLOCK,-1,,"{
#if LOG4CXX_CHARSET_EBCDIC
	LogString dst;
	Transcoder::decode(std::string(1, val), dst);
	return dst[0];
#else
	return val;
#endif
}",1,,660,2,,void
60548,BLOCK,-1,,"{
#if LOG4CXX_LOGCHAR_IS_UTF8 && !LOG4CXX_CHARSET_EBCDIC
	return val;
#else
	LogString dst;
	Transcoder::decode(val, dst);
	return dst;
#endif
}",1,,671,2,,void
60562,BLOCK,-1,,"{
	char asciiTable[] = { ' ', '!', '""', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
			'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=', '>', '?',
			'@', 'A', 'B', 'C', 'D', 'E', 'F',  'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
			'P', 'Q', 'R', 'S', 'T', 'U', 'V',  'W', 'X', 'Y', 'Z', '[', '\\', ']', '^', '_',
			'`', 'a', 'b', 'c', 'd', 'e', 'f',  'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
			'p', 'q', 'r', 's', 't', 'u', 'v',  'w', 'x', 'y', 'z', '{', '|', '}', '~'
		};
	std::string out;

	for (LogString::const_iterator iter = val.begin();
		iter != val.end();
		iter++)
	{
		if (*iter >= 0x20 && *iter < 0x7F)
		{
			out.append(1, asciiTable[*iter - 0x20]);
		}
		else
		{
			out.append(1, LOSSCHAR);
		}
	}

	return out;
}",1,,683,2,,void
60664,BLOCK,-1,,<empty>,2,,693,1,,void
60680,BLOCK,4,,"{
		if (*iter >= 0x20 && *iter < 0x7F)
		{
			out.append(1, asciiTable[*iter - 0x20]);
		}
		else
		{
			out.append(1, LOSSCHAR);
		}
	}",2,,696,4,,void
60691,BLOCK,-1,,"{
			out.append(1, asciiTable[*iter - 0x20]);
		}",3,,698,2,,void
60704,BLOCK,-1,,"{
			out.append(1, LOSSCHAR);
		}",3,,702,1,,void
60725,BLOCK,-1,,<empty>,1,,1,1,,ANY
60729,BLOCK,-1,,"{
	//Check if the string is zero length -- if so, return
	//what was sent in.

	if (input.length() == 0 )
	{
		return;
	}

	logchar specials[] = { 0x22 /* "" */, 0x26 /* & */, 0x3C /* < */, 0x3E /* > */, 0x00 };
	size_t start = 0;
	size_t special = input.find_first_of(specials, start);

	while (special != LogString::npos)
	{
		if (special > start)
		{
			buf.append(input, start, special - start);
		}

		switch (input[special])
		{
			case 0x22:
				buf.append(LOG4CXX_STR(""&quot;""));
				break;

			case 0x26:
				buf.append(LOG4CXX_STR(""&amp;""));
				break;

			case 0x3C:
				buf.append(LOG4CXX_STR(""&lt;""));
				break;

			case 0x3E:
				buf.append(LOG4CXX_STR(""&gt;""));
				break;

			default:
				buf.append(1, input[special]);
				break;
		}

		start = special + 1;

		if (special < input.size())
		{
			special = input.find_first_of(specials, start);
		}
		else
		{
			special = LogString::npos;
		}
	}

	if (start < input.size())
	{
		buf.append(input, start, input.size() - start);
	}
}",1,,29,3,,void
60737,BLOCK,-1,,"{
		return;
	}",2,,34,2,,void
60767,BLOCK,-1,,"{
		if (special > start)
		{
			buf.append(input, start, special - start);
		}

		switch (input[special])
		{
			case 0x22:
				buf.append(LOG4CXX_STR(""&quot;""));
				break;

			case 0x26:
				buf.append(LOG4CXX_STR(""&amp;""));
				break;

			case 0x3C:
				buf.append(LOG4CXX_STR(""&lt;""));
				break;

			case 0x3E:
				buf.append(LOG4CXX_STR(""&gt;""));
				break;

			default:
				buf.append(1, input[special]);
				break;
		}

		start = special + 1;

		if (special < input.size())
		{
			special = input.find_first_of(specials, start);
		}
		else
		{
			special = LogString::npos;
		}
	}",2,,43,2,,void
60772,BLOCK,-1,,"{
			buf.append(input, start, special - start);
		}",3,,45,2,,void
60786,BLOCK,-1,,"{
			case 0x22:
				buf.append(LOG4CXX_STR(""&quot;""));
				break;

			case 0x26:
				buf.append(LOG4CXX_STR(""&amp;""));
				break;

			case 0x3C:
				buf.append(LOG4CXX_STR(""&lt;""));
				break;

			case 0x3E:
				buf.append(LOG4CXX_STR(""&gt;""));
				break;

			default:
				buf.append(1, input[special]);
				break;
		}",3,,50,2,,void
60845,BLOCK,-1,,"{
			special = input.find_first_of(specials, start);
		}",3,,75,2,,void
60855,BLOCK,-1,,"{
			special = LogString::npos;
		}",3,,79,1,,void
60868,BLOCK,-1,,"{
		buf.append(input, start, input.size() - start);
	}",2,,85,2,,void
60886,BLOCK,-1,,"{
	static const WideLife<LogString> CDATA_END(LOG4CXX_STR(""]]>""));
	static const WideLife<LogString> CDATA_EMBEDED_END(LOG4CXX_STR(""]]>]]&gt;<![CDATA[""));

	const LogString::size_type CDATA_END_LEN = 3;


	if (input.length() == 0 )
	{
		return;
	}

	LogString::size_type end = input.find(CDATA_END);

	if (end == LogString::npos)
	{
		buf.append(input);
		return;
	}

	LogString::size_type start = 0;

	while (end != LogString::npos)
	{
		buf.append(input, start, end - start);
		buf.append(CDATA_EMBEDED_END);
		start = end + CDATA_END_LEN;

		if (start < input.length())
		{
			end = input.find(CDATA_END, start);
		}
		else
		{
			return;
		}
	}

	buf.append(input, start, input.length() - start);
}",1,,92,3,,void
60906,BLOCK,-1,,"{
		return;
	}",2,,100,2,,void
60922,BLOCK,-1,,"{
		buf.append(input);
		return;
	}",2,,107,2,,void
60939,BLOCK,-1,,"{
		buf.append(input, start, end - start);
		buf.append(CDATA_EMBEDED_END);
		start = end + CDATA_END_LEN;

		if (start < input.length())
		{
			end = input.find(CDATA_END, start);
		}
		else
		{
			return;
		}
	}",2,,115,2,,void
60966,BLOCK,-1,,"{
			end = input.find(CDATA_END, start);
		}",3,,121,2,,void
60976,BLOCK,-1,,"{
			return;
		}",3,,125,1,,void
60998,BLOCK,-1,,<empty>,1,,1,1,,ANY
61002,BLOCK,-1,,"{
}",1,,27,1,,void
61017,BLOCK,-1,,<empty>,1,,1,1,,ANY
61021,BLOCK,-1,,"{
}",1,,28,1,,void
61025,BLOCK,-1,,"{
}",1,,32,1,,void
61046,BLOCK,-1,,<empty>,1,,1,1,,ANY
61050,BLOCK,-1,,"{
}",1,,36,1,,void
61056,BLOCK,-1,,"{
	Pool p;
	activateOptions(p);
}",1,,42,3,,void
61064,BLOCK,-1,,"{
}",1,,49,2,,void
61069,BLOCK,-1,,"{

}",1,,54,2,,void
61073,BLOCK,-1,,"{
	finalize();
}",1,,59,1,,void
61079,BLOCK,-1,,"{
	int errors = 0;

	if (_priv->layout == 0)
	{
		_priv->errorHandler->error(
			((LogString) LOG4CXX_STR(""No layout set for the appender named [""))
			+ _priv->name + LOG4CXX_STR(""].""));
		errors++;
	}

	if (_priv->writer == 0)
	{
		_priv->errorHandler->error(
			((LogString) LOG4CXX_STR(""No writer set for the appender named [""))
			+ _priv->name + LOG4CXX_STR(""].""));
		errors++;
	}

	if (errors == 0)
	{
		AppenderSkeleton::activateOptions(p);
	}
}",1,,64,2,,void
61087,BLOCK,1,,<empty>,,,,1,,void
61097,BLOCK,-1,,"{
		_priv->errorHandler->error(
			((LogString) LOG4CXX_STR(""No layout set for the appender named [""))
			+ _priv->name + LOG4CXX_STR(""].""));
		errors++;
	}",2,,68,2,,void
61116,BLOCK,1,,<empty>,,,,1,,void
61132,BLOCK,1,,<empty>,,,,1,,void
61142,BLOCK,-1,,"{
		_priv->errorHandler->error(
			((LogString) LOG4CXX_STR(""No writer set for the appender named [""))
			+ _priv->name + LOG4CXX_STR(""].""));
		errors++;
	}",2,,76,2,,void
61144,BLOCK,1,,<empty>,,,,1,,void
61163,BLOCK,1,,<empty>,,,,1,,void
61180,BLOCK,-1,,"{
		AppenderSkeleton::activateOptions(p);
	}",2,,84,2,,void
61191,BLOCK,-1,,"{

	if (!checkEntryConditions())
	{
		return;
	}

	subAppend(event, pool1);
}",1,,92,3,,void
61195,BLOCK,-1,,"{
		return;
	}",2,,95,2,,void
61203,BLOCK,-1,,"{
	static bool warnedClosed = false;
	static bool warnedNoWriter = false;
	static bool warnedNoLayout = false;

	if (_priv->closed)
	{
		if (!warnedClosed)
		{
			LogLog::warn(LOG4CXX_STR(""Not allowed to write to a closed appender.""));
			warnedClosed = true;
		}

		return false;
	}

	if (_priv->writer == 0)
	{
		if (!warnedNoWriter)
		{
			_priv->errorHandler->error(
				LogString(LOG4CXX_STR(""No output stream or file set for the appender named ["")) +
				_priv->name + LOG4CXX_STR(""].""));
			warnedNoWriter = true;
		}

		return false;
	}

	if (_priv->layout == 0)
	{
		if (!warnedNoLayout)
		{
			_priv->errorHandler->error(
				LogString(LOG4CXX_STR(""No layout set for the appender named ["")) +
				_priv->name + LOG4CXX_STR(""].""));
			warnedNoLayout = true;
		}
		return false;
	}

	return true;
}",1,,109,1,,void
61218,BLOCK,1,,<empty>,,,,1,,void
61227,BLOCK,-1,,"{
		if (!warnedClosed)
		{
			LogLog::warn(LOG4CXX_STR(""Not allowed to write to a closed appender.""));
			warnedClosed = true;
		}

		return false;
	}",2,,115,2,,void
61231,BLOCK,-1,,"{
			LogLog::warn(LOG4CXX_STR(""Not allowed to write to a closed appender.""));
			warnedClosed = true;
		}",3,,117,2,,void
61246,BLOCK,1,,<empty>,,,,1,,void
61256,BLOCK,-1,,"{
		if (!warnedNoWriter)
		{
			_priv->errorHandler->error(
				LogString(LOG4CXX_STR(""No output stream or file set for the appender named ["")) +
				_priv->name + LOG4CXX_STR(""].""));
			warnedNoWriter = true;
		}

		return false;
	}",2,,126,2,,void
61260,BLOCK,-1,,"{
			_priv->errorHandler->error(
				LogString(LOG4CXX_STR(""No output stream or file set for the appender named ["")) +
				_priv->name + LOG4CXX_STR(""].""));
			warnedNoWriter = true;
		}",3,,128,2,,void
61262,BLOCK,1,,<empty>,,,,1,,void
61280,BLOCK,1,,<empty>,,,,1,,void
61299,BLOCK,1,,<empty>,,,,1,,void
61309,BLOCK,-1,,"{
		if (!warnedNoLayout)
		{
			_priv->errorHandler->error(
				LogString(LOG4CXX_STR(""No layout set for the appender named ["")) +
				_priv->name + LOG4CXX_STR(""].""));
			warnedNoLayout = true;
		}
		return false;
	}",2,,139,2,,void
61313,BLOCK,-1,,"{
			_priv->errorHandler->error(
				LogString(LOG4CXX_STR(""No layout set for the appender named ["")) +
				_priv->name + LOG4CXX_STR(""].""));
			warnedNoLayout = true;
		}",3,,141,2,,void
61315,BLOCK,1,,<empty>,,,,1,,void
61333,BLOCK,1,,<empty>,,,,1,,void
61354,BLOCK,-1,,"{
	std::lock_guard<std::recursive_mutex> lock(_priv->mutex);

	if (_priv->closed)
	{
		return;
	}

	_priv->closed = true;
	closeWriter();
}",1,,165,1,,void
61365,BLOCK,1,,<empty>,,,,1,,void
61376,BLOCK,1,,<empty>,,,,1,,void
61385,BLOCK,-1,,"{
		return;
	}",2,,169,2,,void
61388,BLOCK,1,,<empty>,,,,1,,void
61391,BLOCK,1,,<empty>,,,,1,,void
61405,BLOCK,-1,,"{
	if (_priv->writer != NULL)
	{
		try
		{
			// before closing we have to output out layout's footer
			//
			//   Using the object's pool since this is a one-shot operation
			//    and pool is likely to be reclaimed soon when appender is destructed.
			//
			writeFooter(_priv->pool);
			_priv->writer->close(_priv->pool);
			_priv->writer = 0;
		}
		catch (IOException& e)
		{
			LogLog::error(LogString(LOG4CXX_STR(""Could not close writer for WriterAppender named "")) + _priv->name, e);
		}
	}

}",1,,181,1,,void
61409,BLOCK,1,,<empty>,,,,1,,void
61419,BLOCK,-1,,"{
		try
		{
			// before closing we have to output out layout's footer
			//
			//   Using the object's pool since this is a one-shot operation
			//    and pool is likely to be reclaimed soon when appender is destructed.
			//
			writeFooter(_priv->pool);
			_priv->writer->close(_priv->pool);
			_priv->writer = 0;
		}
		catch (IOException& e)
		{
			LogLog::error(LogString(LOG4CXX_STR(""Could not close writer for WriterAppender named "")) + _priv->name, e);
		}
	}",2,,183,2,,void
61421,BLOCK,-1,,"{
			// before closing we have to output out layout's footer
			//
			//   Using the object's pool since this is a one-shot operation
			//    and pool is likely to be reclaimed soon when appender is destructed.
			//
			writeFooter(_priv->pool);
			_priv->writer->close(_priv->pool);
			_priv->writer = 0;
		}",3,,185,1,,void
61424,BLOCK,1,,<empty>,,,,1,,void
61434,BLOCK,1,,<empty>,,,,1,,void
61455,BLOCK,1,,<empty>,,,,1,,void
61458,BLOCK,1,,<empty>,,,,1,,void
61468,BLOCK,2,,"{
			LogLog::error(LogString(LOG4CXX_STR(""Could not close writer for WriterAppender named "")) + _priv->name, e);
		}",3,,196,2,,void
61478,BLOCK,1,,<empty>,,,,1,,void
61492,BLOCK,-1,,"{

	LogString enc(getEncoding());

	CharsetEncoderPtr encoder;

	if (enc.empty())
	{
		encoder = CharsetEncoder::getDefaultEncoder();
	}
	else
	{
		if (StringHelper::equalsIgnoreCase(enc,
				LOG4CXX_STR(""utf-16""), LOG4CXX_STR(""UTF-16"")))
		{
			encoder = CharsetEncoder::getEncoder(LOG4CXX_STR(""UTF-16BE""));
		}
		else
		{
			encoder = CharsetEncoder::getEncoder(enc);
		}

		if (encoder == NULL)
		{
			encoder = CharsetEncoder::getDefaultEncoder();
			LogLog::warn(LOG4CXX_STR(""Error initializing output writer.""));
			LogLog::warn(LOG4CXX_STR(""Unsupported encoding?""));
		}
	}

	return WriterPtr(new OutputStreamWriter(os, encoder));
}",1,,210,2,,void
61502,BLOCK,-1,,"{
		encoder = CharsetEncoder::getDefaultEncoder();
	}",2,,217,2,,void
61510,BLOCK,-1,,"{
		if (StringHelper::equalsIgnoreCase(enc,
				LOG4CXX_STR(""utf-16""), LOG4CXX_STR(""UTF-16"")))
		{
			encoder = CharsetEncoder::getEncoder(LOG4CXX_STR(""UTF-16BE""));
		}
		else
		{
			encoder = CharsetEncoder::getEncoder(enc);
		}

		if (encoder == NULL)
		{
			encoder = CharsetEncoder::getDefaultEncoder();
			LogLog::warn(LOG4CXX_STR(""Error initializing output writer.""));
			LogLog::warn(LOG4CXX_STR(""Unsupported encoding?""));
		}
	}",2,,221,1,,void
61521,BLOCK,-1,,"{
			encoder = CharsetEncoder::getEncoder(LOG4CXX_STR(""UTF-16BE""));
		}",3,,224,2,,void
61531,BLOCK,-1,,"{
			encoder = CharsetEncoder::getEncoder(enc);
		}",3,,228,1,,void
61543,BLOCK,-1,,"{
			encoder = CharsetEncoder::getDefaultEncoder();
			LogLog::warn(LOG4CXX_STR(""Error initializing output writer.""));
			LogLog::warn(LOG4CXX_STR(""Unsupported encoding?""));
		}",3,,233,2,,void
61571,BLOCK,-1,,"{
	return _priv->encoding;
}",1,,244,1,,void
61574,BLOCK,1,,<empty>,,,,1,,void
61587,BLOCK,-1,,"{
	_priv->encoding = enc;
}",1,,249,2,,void
61590,BLOCK,1,,<empty>,,,,1,,void
61605,BLOCK,-1,,"{
	LogString msg;
	_priv->layout->format(msg, event, p);

	if (_priv->writer != NULL)
	{
		_priv->writer->write(msg, p);

		if (_priv->immediateFlush)
		{
			_priv->writer->flush(p);
		}
	}
}",1,,254,3,,void
61608,BLOCK,1,,<empty>,,,,2,,void
61626,BLOCK,1,,<empty>,,,,1,,void
61636,BLOCK,-1,,"{
		_priv->writer->write(msg, p);

		if (_priv->immediateFlush)
		{
			_priv->writer->flush(p);
		}
	}",2,,259,2,,void
61638,BLOCK,1,,<empty>,,,,2,,void
61654,BLOCK,1,,<empty>,,,,1,,void
61663,BLOCK,-1,,"{
			_priv->writer->flush(p);
		}",3,,263,2,,void
61665,BLOCK,1,,<empty>,,,,1,,void
61682,BLOCK,-1,,"{
	if (_priv->layout != NULL)
	{
		LogString foot;
		_priv->layout->appendFooter(foot, p);
		_priv->writer->write(foot, p);
	}
}",1,,271,2,,void
61686,BLOCK,1,,<empty>,,,,1,,void
61696,BLOCK,-1,,"{
		LogString foot;
		_priv->layout->appendFooter(foot, p);
		_priv->writer->write(foot, p);
	}",2,,273,2,,void
61699,BLOCK,1,,<empty>,,,,2,,void
61714,BLOCK,1,,<empty>,,,,2,,void
61732,BLOCK,-1,,"{
	if (_priv->layout != NULL)
	{
		LogString header;
		_priv->layout->appendHeader(header, p);
		_priv->writer->write(header, p);
	}
}",1,,281,2,,void
61736,BLOCK,1,,<empty>,,,,1,,void
61746,BLOCK,-1,,"{
		LogString header;
		_priv->layout->appendHeader(header, p);
		_priv->writer->write(header, p);
	}",2,,283,2,,void
61749,BLOCK,1,,<empty>,,,,2,,void
61764,BLOCK,1,,<empty>,,,,2,,void
61782,BLOCK,-1,,"{
	std::unique_lock<std::recursive_mutex> lock(_priv->mutex);
	setWriterInternal(newWriter);
}",1,,292,2,,void
61793,BLOCK,1,,<empty>,,,,1,,void
61808,BLOCK,-1,,"{
	_priv->writer = newWriter;
}",1,,298,2,,void
61811,BLOCK,1,,<empty>,,,,1,,void
61824,BLOCK,-1,,"{
	return true;
}",1,,303,1,,void
61832,BLOCK,-1,,"{
	if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""ENCODING""), LOG4CXX_STR(""encoding"")))
	{
		setEncoding(value);
	}
	else
	{
		AppenderSkeleton::setOption(option, value);
	}
}",1,,308,3,,void
61843,BLOCK,-1,,"{
		setEncoding(value);
	}",2,,310,2,,void
61847,BLOCK,-1,,"{
		AppenderSkeleton::setOption(option, value);
	}",2,,314,1,,void
61858,BLOCK,-1,,"{
	_priv->immediateFlush = value;
}",1,,321,2,,void
61861,BLOCK,1,,<empty>,,,,1,,void
61874,BLOCK,-1,,"{
	return _priv->immediateFlush;
}",1,,326,1,,void
61877,BLOCK,1,,<empty>,,,,1,,void
61889,BLOCK,-1,,"{
	return _priv->writer;
}",71,,330,1,,void
61892,BLOCK,1,,<empty>,,,,1,,void
61927,BLOCK,-1,,<empty>,1,,1,1,,ANY
61930,BLOCK,-1,,<empty>,3,,41,1,,void
61939,BLOCK,-1,,"{
	m_priv->expectedPatternLength = getFormattedEventCharacterCount() * 2;
}",1,,55,1,,void
61950,BLOCK,-1,,<empty>,25,,59,1,,void
61956,BLOCK,-1,,"{
	if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""LOCATIONINFO""), LOG4CXX_STR(""locationinfo"")))
	{
		setLocationInfo(OptionConverter::toBoolean(value, false));
		m_priv->expectedPatternLength = getFormattedEventCharacterCount() * 2;
	}

	if (StringHelper::equalsIgnoreCase(option, LOG4CXX_STR(""PROPERTIES""), LOG4CXX_STR(""properties"")))
	{
		setProperties(OptionConverter::toBoolean(value, false));
		m_priv->expectedPatternLength = getFormattedEventCharacterCount() * 2;
	}
}",1,,63,3,,void
61967,BLOCK,-1,,"{
		setLocationInfo(OptionConverter::toBoolean(value, false));
		m_priv->expectedPatternLength = getFormattedEventCharacterCount() * 2;
	}",2,,65,2,,void
61992,BLOCK,-1,,"{
		setProperties(OptionConverter::toBoolean(value, false));
		m_priv->expectedPatternLength = getFormattedEventCharacterCount() * 2;
	}",2,,71,2,,void
62013,BLOCK,-1,,"{
	output.reserve(m_priv->expectedPatternLength + event->getMessage().size());
	output.append(LOG4CXX_STR(""<log4j:event logger=\""""));
	Transform::appendEscapingTags(output, event->getLoggerName());
	output.append(LOG4CXX_STR(""\"" timestamp=\""""));
	StringHelper::toString(event->getTimeStamp() / 1000L, p, output);
	output.append(LOG4CXX_STR(""\"" level=\""""));
	Transform::appendEscapingTags(output, event->getLevel()->toString());
	output.append(LOG4CXX_STR(""\"" thread=\""""));
	Transform::appendEscapingTags(output, event->getThreadName());
	output.append(LOG4CXX_STR(""\"">""));
	output.append(LOG4CXX_EOL);

	output.append(LOG4CXX_STR(""<log4j:message><![CDATA[""));
	// Append the rendered message. Also make sure to escape any
	// existing CDATA sections.
	Transform::appendEscapingCDATA(output, event->getRenderedMessage());
	output.append(LOG4CXX_STR(""]]></log4j:message>""));
	output.append(LOG4CXX_EOL);

	LogString ndc;

	if (event->getNDC(ndc))
	{
		output.append(LOG4CXX_STR(""<log4j:NDC><![CDATA[...",1,,80,4,,void
62139,BLOCK,-1,,"{
		output.append(LOG4CXX_STR(""<log4j:NDC><![CDATA[""));
		Transform::appendEscapingCDATA(output, ndc);
		output.append(LOG4CXX_STR(""]]></log4j:NDC>""));
		output.append(LOG4CXX_EOL);
	}",2,,103,2,,void
62167,BLOCK,-1,,"{
		output.append(LOG4CXX_STR(""<log4j:locationInfo class=\""""));
		const LocationInfo& locInfo = event->getLocationInformation();
		LOG4CXX_DECODE_CHAR(className, locInfo.getClassName());
		Transform::appendEscapingTags(output, className);
		output.append(LOG4CXX_STR(""\"" method=\""""));
		LOG4CXX_DECODE_CHAR(method, locInfo.getMethodName());
		Transform::appendEscapingTags(output, method);
		output.append(LOG4CXX_STR(""\"" file=\""""));
		LOG4CXX_DECODE_CHAR(fileName, locInfo.getFileName());
		Transform::appendEscapingTags(output, fileName);
		output.append(LOG4CXX_STR(""\"" line=\""""));
		StringHelper::toString(locInfo.getLineNumber(), p, output);
		output.append(LOG4CXX_STR(""\""/>""));
		output.append(LOG4CXX_EOL);
	}",2,,111,2,,void
62260,BLOCK,-1,,"{
		LoggingEvent::KeySet propertySet(event->getPropertyKeySet());
		LoggingEvent::KeySet keySet(event->getMDCKeySet());

		if (!(keySet.empty() && propertySet.empty()))
		{
			output.append(LOG4CXX_STR(""<log4j:properties>""));
			output.append(LOG4CXX_EOL);

			for (LoggingEvent::KeySet::const_iterator i = keySet.begin();
				i != keySet.end();
				i++)
			{
				LogString key(*i);
				LogString value;

				if (event->getMDC(key, value))
				{
					output.append(LOG4CXX_STR(""<log4j:data name=\""""));
					Transform::appendEscapingTags(output, key);
					output.append(LOG4CXX_STR(""\"" value=\""""));
					Transform::appendEscapingTags(output, value);
					output.append(LOG4CXX_STR(""\""/>""));
					output.append(LOG4CXX_EOL);
				}
			}

			for (LoggingEvent::KeySet::const_iterator i2 = propertySet.begin();
				i2 != propertySet.end();
				i2++)
			{
				LogString key(*i2);
				LogString value;

				if (event->getProperty(key, value))
				{
					output.append(LOG4CXX_STR(""<log4j:data name=\""""))...",2,,129,2,,void
62284,BLOCK,-1,,"{
			output.append(LOG4CXX_STR(""<log4j:properties>""));
			output.append(LOG4CXX_EOL);

			for (LoggingEvent::KeySet::const_iterator i = keySet.begin();
				i != keySet.end();
				i++)
			{
				LogString key(*i);
				LogString value;

				if (event->getMDC(key, value))
				{
					output.append(LOG4CXX_STR(""<log4j:data name=\""""));
					Transform::appendEscapingTags(output, key);
					output.append(LOG4CXX_STR(""\"" value=\""""));
					Transform::appendEscapingTags(output, value);
					output.append(LOG4CXX_STR(""\""/>""));
					output.append(LOG4CXX_EOL);
				}
			}

			for (LoggingEvent::KeySet::const_iterator i2 = propertySet.begin();
				i2 != propertySet.end();
				i2++)
			{
				LogString key(*i2);
				LogString value;

				if (event->getProperty(key, value))
				{
					output.append(LOG4CXX_STR(""<log4j:data name=\""""));
					Transform::appendEscapingTags(output, key);
					output.append(LOG4CXX_STR(""\"" value=\""""));
					Transform::appendEscapingTags(output, value);
					output.append(LO...",3,,134,2,,void
62297,BLOCK,-1,,<empty>,4,,138,1,,void
62313,BLOCK,4,,"{
				LogString key(*i);
				LogString value;

				if (event->getMDC(key, value))
				{
					output.append(LOG4CXX_STR(""<log4j:data name=\""""));
					Transform::appendEscapingTags(output, key);
					output.append(LOG4CXX_STR(""\"" value=\""""));
					Transform::appendEscapingTags(output, value);
					output.append(LOG4CXX_STR(""\""/>""));
					output.append(LOG4CXX_EOL);
				}
			}",4,,141,4,,void
62326,BLOCK,-1,,"{
					output.append(LOG4CXX_STR(""<log4j:data name=\""""));
					Transform::appendEscapingTags(output, key);
					output.append(LOG4CXX_STR(""\"" value=\""""));
					Transform::appendEscapingTags(output, value);
					output.append(LOG4CXX_STR(""\""/>""));
					output.append(LOG4CXX_EOL);
				}",5,,146,2,,void
62363,BLOCK,-1,,<empty>,4,,156,1,,void
62379,BLOCK,4,,"{
				LogString key(*i2);
				LogString value;

				if (event->getProperty(key, value))
				{
					output.append(LOG4CXX_STR(""<log4j:data name=\""""));
					Transform::appendEscapingTags(output, key);
					output.append(LOG4CXX_STR(""\"" value=\""""));
					Transform::appendEscapingTags(output, value);
					output.append(LOG4CXX_STR(""\""/>""));
					output.append(LOG4CXX_EOL);
				}
			}",4,,159,4,,void
62392,BLOCK,-1,,"{
					output.append(LOG4CXX_STR(""<log4j:data name=\""""));
					Transform::appendEscapingTags(output, key);
					output.append(LOG4CXX_STR(""\"" value=\""""));
					Transform::appendEscapingTags(output, value);
					output.append(LOG4CXX_STR(""\""/>""));
					output.append(LOG4CXX_EOL);
				}",5,,164,2,,void
62459,BLOCK,-1,,"{
	m_priv->locationInfo = locationInfo1;
}",1,,185,2,,void
62468,BLOCK,-1,,"{
	return m_priv->locationInfo;
}",1,,190,1,,void
62477,BLOCK,-1,,"{
	m_priv->properties = flag;
}",1,,195,2,,void
62486,BLOCK,-1,,"{
	return m_priv->properties;
}",1,,200,1,,void
62523,BLOCK,-1,,<empty>,1,,1,1,,ANY
62528,BLOCK,-1,,<empty>,62,,40,3,,void
62535,BLOCK,-1,,<empty>,73,,43,4,,void
62542,BLOCK,-1,,<empty>,51,,46,4,,void
62561,BLOCK,-1,,"{
	_priv->layout = std::make_shared<XMLLayout>();
}",1,,65,1,,void
62564,BLOCK,1,,<empty>,,,,1,,void
62582,BLOCK,-1,,"{
	_priv->layout = std::make_shared<XMLLayout>();
	Pool p;
	activateOptions(p);
}",1,,71,3,,void
62585,BLOCK,1,,<empty>,,,,1,,void
62606,BLOCK,-1,,"{
	_priv->layout = std::make_shared<XMLLayout>();
	Pool p;
	activateOptions(p);
}",1,,79,3,,void
62609,BLOCK,1,,<empty>,,,,1,,void
62628,BLOCK,-1,,"{
	finalize();
}",1,,86,1,,void
62633,BLOCK,-1,,"{
	return DEFAULT_RECONNECTION_DELAY;
}",1,,92,1,,void
62639,BLOCK,-1,,"{
	return DEFAULT_PORT;
}",1,,97,1,,void
62647,BLOCK,-1,,"{
	OutputStreamPtr os = std::make_shared<SocketOutputStream>(socket);
	CharsetEncoderPtr charset(CharsetEncoder::getUTF8Encoder());
	std::lock_guard<std::recursive_mutex> lock(_priv->mutex);
	_priv->writer = std::make_shared<OutputStreamWriter>(os, charset);
}",1,,102,3,,void
62674,BLOCK,1,,<empty>,,,,1,,void
62685,BLOCK,1,,<empty>,,,,1,,void
62708,BLOCK,-1,,"{
	if (_priv->writer)
	{
		try
		{
			_priv->writer->close(p);
			_priv->writer = nullptr;
		}
		catch (std::exception&)
		{
		}
	}
}",1,,110,2,,void
62711,BLOCK,1,,<empty>,,,,1,,void
62720,BLOCK,-1,,"{
		try
		{
			_priv->writer->close(p);
			_priv->writer = nullptr;
		}
		catch (std::exception&)
		{
		}
	}",2,,112,2,,void
62722,BLOCK,-1,,"{
			_priv->writer->close(p);
			_priv->writer = nullptr;
		}",3,,114,1,,void
62724,BLOCK,1,,<empty>,,,,1,,void
62739,BLOCK,1,,<empty>,,,,1,,void
62749,BLOCK,2,,"{
		}",3,,119,2,,void
62755,BLOCK,-1,,"{
	if (_priv->writer)
	{
		LogString output;
		_priv->layout->format(output, event, p);

		try
		{
			_priv->writer->write(output, p);
			_priv->writer->flush(p);
		}
		catch (std::exception& e)
		{
			_priv->writer = nullptr;
			LogLog::warn(LOG4CXX_STR(""Detected problem with connection: ""), e);

			if (getReconnectionDelay() > 0)
			{
				fireConnector();
			}
		}
	}
}",1,,125,3,,void
62758,BLOCK,1,,<empty>,,,,1,,void
62767,BLOCK,-1,,"{
		LogString output;
		_priv->layout->format(output, event, p);

		try
		{
			_priv->writer->write(output, p);
			_priv->writer->flush(p);
		}
		catch (std::exception& e)
		{
			_priv->writer = nullptr;
			LogLog::warn(LOG4CXX_STR(""Detected problem with connection: ""), e);

			if (getReconnectionDelay() > 0)
			{
				fireConnector();
			}
		}
	}",2,,127,2,,void
62770,BLOCK,1,,<empty>,,,,2,,void
62786,BLOCK,-1,,"{
			_priv->writer->write(output, p);
			_priv->writer->flush(p);
		}",3,,132,1,,void
62788,BLOCK,1,,<empty>,,,,2,,void
62803,BLOCK,1,,<empty>,,,,1,,void
62816,BLOCK,2,,"{
			_priv->writer = nullptr;
			LogLog::warn(LOG4CXX_STR(""Detected problem with connection: ""), e);

			if (getReconnectionDelay() > 0)
			{
				fireConnector();
			}
		}",3,,137,2,,void
62819,BLOCK,1,,<empty>,,,,1,,void
62840,BLOCK,-1,,"{
				fireConnector();
			}",4,,142,2,,void
62862,BLOCK,-1,,<empty>,1,,1,1,,ANY
62868,BLOCK,-1,,<empty>,71,,37,4,,void
62876,BLOCK,-1,,<empty>,,,,1,,<empty>
62888,BLOCK,-1,,"{
}",1,,52,4,,void
62893,BLOCK,-1,,"{
	if (!priv->source.exists(p))
	{
		return false;
	}

	apr_pool_t* aprpool = p.getAPRPool();
	apr_procattr_t* attr;
	apr_status_t stat = apr_procattr_create(&attr, aprpool);

	if (stat != APR_SUCCESS)
	{
		throw IOException(stat);
	}

	stat = apr_procattr_io_set(attr, APR_NO_PIPE, APR_NO_PIPE, APR_FULL_BLOCK);

	if (stat != APR_SUCCESS)
	{
		throw IOException(stat);
	}

	stat = apr_procattr_cmdtype_set(attr, APR_PROGRAM_PATH);

	if (stat != APR_SUCCESS)
	{
		throw IOException(stat);
	}

	//
	// redirect the child's error stream to this processes' error stream
	//
	apr_file_t* child_err;
	stat = apr_file_open_stderr(&child_err, aprpool);

	if (stat == APR_SUCCESS)
	{
		stat =  apr_procattr_child_err_set(attr, child_err, NULL);

		if (stat != APR_SUCCESS)
		{
			throw IOException(stat);
		}
	}

	const char** args = (const char**)
		apr_palloc(aprpool, 5 * sizeof(*args));
	int i = 0;

	args[i++] = ""zip"";
	args[i++] = ""-q"";
	args[i++] = Transcoder::encode(priv->destination.getPath(), p...",1,,56,2,,void
62897,BLOCK,1,,<empty>,,,,1,,void
62910,BLOCK,-1,,"{
		return false;
	}",2,,58,2,,void
62932,BLOCK,-1,,"{
		throw IOException(stat);
	}",2,,67,2,,void
62947,BLOCK,-1,,"{
		throw IOException(stat);
	}",2,,74,2,,void
62960,BLOCK,-1,,"{
		throw IOException(stat);
	}",2,,81,2,,void
62975,BLOCK,-1,,"{
		stat =  apr_procattr_child_err_set(attr, child_err, NULL);

		if (stat != APR_SUCCESS)
		{
			throw IOException(stat);
		}
	}",2,,92,2,,void
62986,BLOCK,-1,,"{
			throw IOException(stat);
		}",3,,96,2,,void
63028,BLOCK,1,,<empty>,,,,1,,void
63051,BLOCK,1,,<empty>,,,,1,,void
63072,BLOCK,1,,<empty>,,,,1,,void
63085,BLOCK,-1,,"{
		priv->destination.deleteFile(p);
	}",2,,112,2,,void
63087,BLOCK,1,,<empty>,,,,1,,void
63117,BLOCK,1,,<empty>,,,,1,,void
63126,BLOCK,-1,,"{
		throw IOException(stat);
	}",2,,120,2,,void
63131,BLOCK,-1,,<empty>,8,,122,1,,void
63139,BLOCK,1,,<empty>,,,,1,,void
63148,BLOCK,-1,,"{
		/* If we fail here (to create the zip child process),
		 * skip the compression and consider the rotation to be
		 * otherwise successful. The caller has already rotated
		 * the log file (`source` here refers to the
		 * uncompressed, rotated path, and `destination` the
		 * same path with `.zip` appended). Remove the empty
		 * destination file and leave source as-is.
		 */
		LogLog::warn(LOG4CXX_STR(""Failed to fork zip during log rotation; leaving log file uncompressed""));
		return true;
	}",2,,123,2,,void
63169,BLOCK,-1,,"{
		throw IOException(exitCode);
	}",2,,140,2,,void
63175,BLOCK,1,,<empty>,,,,1,,void
63184,BLOCK,-1,,"{
		priv->source.deleteFile(p);
	}",2,,145,2,,void
63186,BLOCK,1,,<empty>,,,,1,,void
63205,BLOCK,-1,,"{
	priv->throwIOExceptionOnForkFailure = throwIO;
}",71,,152,2,,void
63208,BLOCK,1,,<empty>,,,,1,,void
63232,BLOCK,-1,,<empty>,1,,1,1,,ANY
63244,BLOCK,-1,,<empty>,1,,1,1,,ANY
63251,BLOCK,-1,,<empty>,1,,1,1,,ANY
63255,BLOCK,-1,,"{
	LOG4CXX_DECODE_QSTRING(tmp, msg);
	return mb << tmp;
}",1,,66,3,,void
63273,BLOCK,-1,,<empty>,1,,1,1,,ANY
63281,BLOCK,-1,,<empty>,,,,4,,<empty>
63292,BLOCK,-1,,<empty>,1,,1,1,,ANY
63303,BLOCK,-1,,<empty>,1,,1,1,,ANY
63335,BLOCK,-1,,<empty>,1,,1,1,,ANY
63348,BLOCK,-1,,<empty>,1,,1,1,,ANY
63365,BLOCK,-1,,<empty>,1,,1,1,,ANY
63378,BLOCK,-1,,<empty>,1,,1,1,,ANY
63396,BLOCK,-1,,<empty>,1,,1,1,,ANY
63416,BLOCK,-1,,<empty>,1,,1,1,,ANY
63439,BLOCK,-1,,<empty>,1,,1,1,,ANY
63455,BLOCK,-1,,<empty>,1,,1,1,,ANY
63466,BLOCK,-1,,<empty>,1,,1,1,,ANY
63479,BLOCK,-1,,<empty>,1,,1,1,,ANY
63501,BLOCK,-1,,<empty>,1,,1,1,,ANY
63515,BLOCK,-1,,<empty>,1,,1,1,,ANY
63526,BLOCK,-1,,<empty>,1,,1,1,,ANY
63537,BLOCK,-1,,<empty>,1,,1,1,,ANY
63552,BLOCK,-1,,<empty>,1,,1,1,,ANY
63566,BLOCK,-1,,<empty>,1,,1,1,,ANY
63577,BLOCK,-1,,<empty>,1,,1,1,,ANY
63590,BLOCK,-1,,<empty>,1,,1,1,,ANY
63602,BLOCK,-1,,<empty>,1,,1,1,,ANY
63615,BLOCK,-1,,<empty>,1,,1,1,,ANY
63625,BLOCK,-1,,<empty>,1,,1,1,,ANY
63636,BLOCK,-1,,<empty>,1,,1,1,,ANY
63646,BLOCK,-1,,<empty>,1,,1,1,,ANY
63664,BLOCK,-1,,<empty>,1,,1,1,,ANY
63688,BLOCK,-1,,<empty>,1,,1,1,,ANY
63696,BLOCK,-1,,<empty>,,,,1,,<empty>
63700,BLOCK,-1,,<empty>,,,,1,,<empty>
63704,BLOCK,-1,,<empty>,,,,1,,<empty>
63710,BLOCK,-1,,<empty>,,,,2,,<empty>
63715,BLOCK,-1,,<empty>,,,,2,,<empty>
63719,BLOCK,-1,,<empty>,,,,1,,<empty>
63724,BLOCK,-1,,"{
			getInstance().addObject(typeid(T).hash_code(), pObject);
		}",3,,64,2,,void
63739,BLOCK,-1,,"{
			return cast<T>(getInstance().findOrAddObject(typeid(T).hash_code(), creator));
		}",3,,71,2,,void
63759,BLOCK,-1,,<empty>,,,,1,,<empty>
63764,BLOCK,-1,,<empty>,,,,2,,<empty>
63769,BLOCK,-1,,<empty>,,,,2,,<empty>
63775,BLOCK,-1,,<empty>,,,,3,,<empty>
63781,BLOCK,-1,,<empty>,,,,3,,<empty>
63785,BLOCK,-1,,<empty>,,,,1,,<empty>
63790,BLOCK,-1,,<empty>,,,,1,,<empty>
63799,BLOCK,-1,,<empty>,1,,1,1,,ANY
63811,BLOCK,-1,,<empty>,1,,1,1,,ANY
63825,BLOCK,-1,,<empty>,1,,1,1,,ANY
63840,BLOCK,-1,,<empty>,1,,1,1,,ANY
63850,BLOCK,-1,,<empty>,1,,1,1,,ANY
63860,BLOCK,-1,,<empty>,1,,1,1,,ANY
63875,BLOCK,-1,,<empty>,1,,1,1,,ANY
63890,BLOCK,-1,,<empty>,1,,1,1,,ANY
63901,BLOCK,-1,,<empty>,1,,1,1,,ANY
63914,BLOCK,-1,,<empty>,1,,1,1,,ANY
63926,BLOCK,-1,,<empty>,1,,1,1,,ANY
63943,BLOCK,-1,,<empty>,1,,1,1,,ANY
63960,BLOCK,-1,,<empty>,1,,1,1,,ANY
63971,BLOCK,-1,,<empty>,1,,1,1,,ANY
63982,BLOCK,-1,,<empty>,1,,1,1,,ANY
63996,BLOCK,-1,,<empty>,1,,1,1,,ANY
64014,BLOCK,-1,,<empty>,,,,1,,<empty>
64019,BLOCK,-1,,<empty>,,,,2,,<empty>
64024,BLOCK,-1,,<empty>,,,,2,,<empty>
64029,BLOCK,-1,,<empty>,,,,1,,<empty>
64034,BLOCK,-1,,<empty>,,,,2,,<empty>
64039,BLOCK,-1,,<empty>,,,,2,,<empty>
64060,BLOCK,-1,,<empty>,1,,1,1,,ANY
64075,BLOCK,-1,,<empty>,1,,1,1,,ANY
64098,BLOCK,-1,,<empty>,1,,1,1,,ANY
64114,BLOCK,-1,,<empty>,1,,1,1,,ANY
64120,BLOCK,-1,,<empty>,,,,2,,<empty>
64125,BLOCK,-1,,<empty>,,,,2,,<empty>
64130,BLOCK,-1,,<empty>,,,,2,,<empty>
64143,BLOCK,-1,,<empty>,1,,1,1,,ANY
64159,BLOCK,-1,,<empty>,1,,1,1,,ANY
64172,BLOCK,-1,,<empty>,1,,1,1,,ANY
64183,BLOCK,-1,,<empty>,1,,1,1,,ANY
64199,BLOCK,-1,,<empty>,1,,1,1,,ANY
64212,BLOCK,-1,,<empty>,1,,1,1,,ANY
64228,BLOCK,-1,,<empty>,1,,1,1,,ANY
64242,BLOCK,-1,,<empty>,1,,1,1,,ANY
64247,BLOCK,-1,,<empty>,,,,2,,<empty>
64254,BLOCK,-1,,"{
	return ((std::basic_ostream<char>&) os) << val;
}",1,,209,3,,void
64277,BLOCK,-1,,<empty>,1,,1,1,,ANY
64287,BLOCK,-1,,"{
	if(!incoming)
	{
		return std::shared_ptr<Ret>();
	}

	Ret* casted = reinterpret_cast<Ret*>(const_cast<void*>(incoming->cast(Ret::getStaticClass())));

	if ( casted )
	{
		return std::shared_ptr<Ret>( incoming, casted );
	}

	return std::shared_ptr<Ret>();
}",1,,128,2,,void
64291,BLOCK,-1,,"{
		return std::shared_ptr<Ret>();
	}",2,,130,2,,void
64314,BLOCK,-1,,"{
		return std::shared_ptr<Ret>( incoming, casted );
	}",2,,137,2,,void
64341,BLOCK,-1,,<empty>,1,,1,1,,ANY
64353,BLOCK,-1,,<empty>,1,,1,1,,ANY
64373,BLOCK,-1,,<empty>,1,,1,1,,ANY
64389,BLOCK,-1,,<empty>,1,,1,1,,ANY
64402,BLOCK,-1,,<empty>,1,,1,1,,ANY
64423,BLOCK,-1,,<empty>,1,,1,1,,ANY
64437,BLOCK,-1,,<empty>,1,,1,1,,ANY
64448,BLOCK,-1,,<empty>,1,,1,1,,ANY
64459,BLOCK,-1,,<empty>,1,,1,1,,ANY
64469,BLOCK,-1,,<empty>,1,,1,1,,ANY
64484,BLOCK,-1,,<empty>,1,,1,1,,ANY
64503,BLOCK,-1,,<empty>,1,,1,1,,ANY
64518,BLOCK,-1,,<empty>,1,,1,1,,ANY
64536,BLOCK,-1,,<empty>,1,,1,1,,ANY
64548,BLOCK,-1,,<empty>,1,,1,1,,ANY
64558,BLOCK,-1,,<empty>,1,,1,1,,ANY
64565,BLOCK,-1,,"{
			return (a < b) ? a : b;
		}",3,,36,3,,void
64578,BLOCK,-1,,"{
			return (a > b) ? a : b;
		}",3,,42,3,,void
64596,BLOCK,-1,,<empty>,1,,1,1,,ANY
64609,BLOCK,-1,,<empty>,1,,1,1,,ANY
64623,BLOCK,-1,,<empty>,1,,1,1,,ANY
64635,BLOCK,-1,,<empty>,1,,1,1,,ANY
64646,BLOCK,-1,,<empty>,1,,1,1,,ANY
64656,BLOCK,-1,,<empty>,1,,1,1,,ANY
64664,BLOCK,-1,,<empty>,1,,1,1,,ANY
64673,BLOCK,-1,,<empty>,1,,1,1,,ANY
64686,BLOCK,-1,,<empty>,1,,1,1,,ANY
64704,BLOCK,-1,,<empty>,1,,1,1,,ANY
64726,BLOCK,-1,,<empty>,1,,1,1,,ANY
64739,BLOCK,-1,,<empty>,1,,1,1,,ANY
64751,BLOCK,-1,,<empty>,1,,1,1,,ANY
64763,BLOCK,-1,,<empty>,1,,1,1,,ANY
64768,BLOCK,-1,,"{		
		new(&storage) T();
	}",2,,40,1,,void
64778,BLOCK,-1,,"{		
		new(&storage) T(std::forward<Arg0>(arg0), std::forward<Args>(args)...);
	}",2,,48,3,,void
64800,BLOCK,-1,,"{
#if LOG4CXX_EVENTS_AT_EXIT
		// keep the holded value alive
#else
		value().~T();
#endif
	}",2,,53,1,,void
64808,BLOCK,-1,,"{
		return *reinterpret_cast<T*>(&storage);
	}",2,,62,1,,void
64818,BLOCK,-1,,"{
		return *reinterpret_cast<const T*>(&storage);
	}",2,,67,1,,void
64828,BLOCK,-1,,"{
		return value();
	}",2,,72,1,,void
64834,BLOCK,-1,,"{
		return value();
	}",2,,77,1,,void
64842,BLOCK,-1,,<empty>,,,,2,,<empty>
64847,BLOCK,-1,,<empty>,,,,2,,<empty>
64852,BLOCK,-1,,<empty>,,,,2,,<empty>
64857,BLOCK,-1,,<empty>,,,,2,,<empty>
64861,BLOCK,-1,,<empty>,,,,1,,<empty>
64875,BLOCK,-1,,<empty>,1,,1,1,,ANY
64890,BLOCK,-1,,<empty>,1,,1,1,,ANY
64917,BLOCK,-1,,<empty>,1,,1,1,,ANY
64925,BLOCK,-1,,<empty>,,,,1,,<empty>
64946,BLOCK,-1,,"{
	return !!(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}",54,,34,3,,void
64962,BLOCK,-1,,"{
	return static_cast<HexdumpFlags>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}",62,,38,3,,void
64980,BLOCK,-1,,<empty>,,,,4,,<empty>
65003,BLOCK,-1,,<empty>,1,,1,1,,ANY
65016,BLOCK,-1,,<empty>,1,,1,1,,ANY
65030,BLOCK,-1,,<empty>,1,,1,1,,ANY
65044,BLOCK,-1,,<empty>,1,,1,1,,ANY
65060,BLOCK,-1,,<empty>,1,,1,1,,ANY
65073,BLOCK,-1,,<empty>,1,,1,1,,ANY
65081,BLOCK,-1,,"{
		m_otherCategory->setLevel(level);
	}",2,,50,3,,void
65092,BLOCK,-1,,"{
	}",2,,56,3,,void
65098,BLOCK,-1,,"{
	}",2,,62,3,,void
65104,BLOCK,-1,,"{
	}",2,,68,3,,void
65108,BLOCK,-1,,"{
		m_otherCategory->setLevel(m_savedLevel);
	}",2,,72,1,,void
65118,BLOCK,-1,,<empty>,,,,2,,<empty>
65123,BLOCK,-1,,<empty>,,,,2,,<empty>
65128,BLOCK,-1,,<empty>,,,,2,,<empty>
65133,BLOCK,-1,,<empty>,,,,2,,<empty>
65160,BLOCK,-1,,<empty>,1,,1,1,,ANY
65180,BLOCK,-1,,<empty>,1,,1,1,,ANY
65186,BLOCK,-1,,<empty>,2,,53,1,,void
65191,BLOCK,-1,,"{
	}",2,,59,2,,void
65195,BLOCK,-1,,"{
		reset();
	}",2,,63,1,,void
65200,BLOCK,-1,,"{
		return m_logger;
	}",2,,68,1,,void
65206,BLOCK,-1,,"{
		return !!m_logger;
	}",2,,73,1,,void
65214,BLOCK,-1,,"{
		return m_logger;
	}",2,,78,1,,void
65220,BLOCK,-1,,"{
		return m_logger;
	}",2,,83,1,,void
65226,BLOCK,-1,,"{
		return m_logger.get();
	}",2,,88,1,,void
65235,BLOCK,-1,,"{
		return m_logger.get();
	}",2,,93,1,,void
65244,BLOCK,-1,,"{
		if (m_logger && !m_hadConfiguration)
		{
			auto name = m_logger->getName();
			m_logger.reset(); // Decrease reference count
			LogManager::removeLogger(name);
		}
		else
		{
			m_hadConfiguration = false;
			m_logger.reset();
		}
	}",2,,99,1,,void
65250,BLOCK,-1,,"{
			auto name = m_logger->getName();
			m_logger.reset(); // Decrease reference count
			LogManager::removeLogger(name);
		}",3,,101,2,,void
65268,BLOCK,-1,,"{
			m_hadConfiguration = false;
			m_logger.reset();
		}",3,,107,1,,void
65280,BLOCK,-1,,"{
		reset();
		m_hadConfiguration = !!LogManager::exists(instanceName);
		m_logger = LogManager::getLogger(instanceName);
	}",2,,116,2,,void
65310,BLOCK,-1,,<empty>,1,,1,1,,ANY
65329,BLOCK,-1,,<empty>,1,,1,1,,ANY
65342,BLOCK,-1,,<empty>,1,,1,1,,ANY
65355,BLOCK,-1,,<empty>,1,,1,1,,ANY
65368,BLOCK,-1,,<empty>,1,,1,1,,ANY
65385,BLOCK,-1,,<empty>,1,,1,1,,ANY
65397,BLOCK,-1,,<empty>,1,,1,1,,ANY
65418,BLOCK,-1,,<empty>,1,,1,1,,ANY
65435,BLOCK,-1,,<empty>,1,,1,1,,ANY
65446,BLOCK,-1,,<empty>,1,,1,1,,ANY
65457,BLOCK,-1,,<empty>,1,,1,1,,ANY
65467,BLOCK,-1,,<empty>,1,,1,1,,ANY
65477,BLOCK,-1,,<empty>,1,,1,1,,ANY
65487,BLOCK,-1,,<empty>,1,,1,1,,ANY
65503,BLOCK,-1,,<empty>,1,,1,1,,ANY
65514,BLOCK,-1,,<empty>,1,,1,1,,ANY
65524,BLOCK,-1,,<empty>,1,,1,1,,ANY
65536,BLOCK,-1,,<empty>,1,,1,1,,ANY
65549,BLOCK,-1,,<empty>,1,,1,1,,ANY
65559,BLOCK,-1,,<empty>,1,,1,1,,ANY
65570,BLOCK,-1,,<empty>,1,,1,1,,ANY
65580,BLOCK,-1,,<empty>,1,,1,1,,ANY
65590,BLOCK,-1,,<empty>,1,,1,1,,ANY
65600,BLOCK,-1,,<empty>,1,,1,1,,ANY
65610,BLOCK,-1,,<empty>,1,,1,1,,ANY
65622,BLOCK,-1,,<empty>,1,,1,1,,ANY
65633,BLOCK,-1,,<empty>,1,,1,1,,ANY
65643,BLOCK,-1,,<empty>,1,,1,1,,ANY
65653,BLOCK,-1,,<empty>,1,,1,1,,ANY
65665,BLOCK,-1,,<empty>,1,,1,1,,ANY
65681,BLOCK,-1,,<empty>,1,,1,1,,ANY
65691,BLOCK,-1,,<empty>,1,,1,1,,ANY
65705,BLOCK,-1,,<empty>,1,,1,1,,ANY
65727,BLOCK,-1,,<empty>,1,,1,1,,ANY
65739,BLOCK,-1,,<empty>,1,,1,1,,ANY
65749,BLOCK,-1,,<empty>,1,,1,1,,ANY
65759,BLOCK,-1,,<empty>,1,,1,1,,ANY
65769,BLOCK,-1,,<empty>,1,,1,1,,ANY
65781,BLOCK,-1,,<empty>,1,,1,1,,ANY
65791,BLOCK,-1,,<empty>,1,,1,1,,ANY
65807,BLOCK,-1,,<empty>,1,,1,1,,ANY
65819,BLOCK,-1,,<empty>,1,,1,1,,ANY
65824,BLOCK,-1,,<empty>,10,,32,1,,void
65828,BLOCK,-1,,<empty>,26,,34,1,,void
65845,BLOCK,-1,,<empty>,1,,1,1,,ANY
65849,BLOCK,-1,,<empty>,17,,33,1,,void
65854,BLOCK,-1,,<empty>,17,,39,2,,void
65858,BLOCK,-1,,<empty>,36,,41,1,,void
65876,BLOCK,-1,,<empty>,1,,1,1,,ANY
65882,BLOCK,-1,,<empty>,,,,1,,<empty>
65887,BLOCK,-1,,<empty>,,,,2,,<empty>
65893,BLOCK,-1,,<empty>,,,,3,,<empty>
65899,BLOCK,-1,,<empty>,,,,3,,<empty>
65903,BLOCK,-1,,<empty>,,,,1,,<empty>
65907,BLOCK,-1,,<empty>,,,,1,,<empty>
65912,BLOCK,-1,,<empty>,,,,2,,<empty>
65917,BLOCK,-1,,<empty>,,,,2,,<empty>
65923,BLOCK,-1,,<empty>,,,,3,,<empty>
65927,BLOCK,-1,,<empty>,,,,1,,<empty>
65936,BLOCK,-1,,<empty>,1,,1,1,,ANY
65946,BLOCK,-1,,<empty>,1,,1,1,,ANY
65959,BLOCK,-1,,<empty>,1,,1,1,,ANY
65969,BLOCK,-1,,<empty>,1,,1,1,,ANY
65974,BLOCK,-1,,"{
	}",2,,32,1,,void
65979,BLOCK,-1,,"{
	}",2,,37,2,,void
65985,BLOCK,-1,,"{
	}",2,,42,3,,void
65989,BLOCK,-1,,<empty>,,,,1,,<empty>
66004,BLOCK,-1,,<empty>,1,,1,1,,ANY
66013,BLOCK,-1,,<empty>,3,,41,6,,void
66026,BLOCK,-1,,<empty>,1,,1,1,,ANY
66031,BLOCK,-1,,<empty>,26,,29,1,,void
66039,BLOCK,-1,,<empty>,,,,1,,ANY
66058,BLOCK,-1,,<empty>,1,,1,1,,ANY
66069,BLOCK,-1,,<empty>,3,,68,1,,void
66095,BLOCK,-1,,<empty>,,,,3,,<empty>
66101,BLOCK,-1,,<empty>,,,,3,,<empty>
66111,BLOCK,-1,,<empty>,1,,1,1,,ANY
66118,BLOCK,-1,,<empty>,17,,35,3,,void
66122,BLOCK,-1,,<empty>,36,,37,1,,void
66139,BLOCK,-1,,<empty>,1,,1,1,,ANY
66144,BLOCK,-1,,<empty>,,,,1,,<empty>
66152,BLOCK,-1,,<empty>,,,,1,,<empty>
66164,BLOCK,-1,,<empty>,1,,1,1,,ANY
66169,BLOCK,-1,,<empty>,13,,30,1,,void
66173,BLOCK,-1,,<empty>,,,,1,,<empty>
66183,BLOCK,-1,,<empty>,1,,1,1,,ANY
66190,BLOCK,-1,,<empty>,32,,31,3,,void
66194,BLOCK,-1,,<empty>,,,,1,,<empty>
66209,BLOCK,-1,,<empty>,1,,1,1,,ANY
66216,BLOCK,-1,,<empty>,12,,38,3,,void
66223,BLOCK,-1,,<empty>,12,,47,4,,void
66230,BLOCK,-1,,<empty>,12,,56,4,,void
66249,BLOCK,-1,,<empty>,1,,1,1,,ANY
66253,BLOCK,-1,,"{
	size_t result = 0;
	if (!str)
		;
	else while (*str++ != 0 && result < strsz)
		++result;
	return result;
}",1,,32,3,,void
66261,BLOCK,-1,,<empty>,3,,35,2,,void
66263,BLOCK,-1,,<empty>,7,,36,1,,void
66284,BLOCK,-1,,"{
	if (!src || !destArg || RSIZE_MAX < destsz)
		return -1;
	if (0 == destsz)
		return -2;
	--destsz;
	char* dest = destArg;
	size_t index = 0;
	while (*dest && index < destsz)
		++index, ++dest;
	while (*src && index < destsz)
	{
		*dest++ = *src++;
		++index;
	}
	*dest = 0;
	if (*src) // longer than destsz?
	{
		*destArg = 0; // Do not return a partial result
		return -3;
	}
	return 0;
}",1,,41,4,,void
66294,BLOCK,1,,<empty>,,,,1,,void
66299,BLOCK,-1,,<empty>,3,,43,2,,void
66307,BLOCK,-1,,<empty>,3,,45,2,,void
66340,BLOCK,-1,,"{
		*dest++ = *src++;
		++index;
	}",2,,52,2,,void
66357,BLOCK,-1,,"{
		*destArg = 0; // Do not return a partial result
		return -3;
	}",2,,58,2,,void
66381,BLOCK,-1,,<empty>,1,,1,1,,ANY
66386,BLOCK,-1,,"{

	}",2,,64,1,,void
66392,BLOCK,-1,,"{

	}",2,,73,3,,void
66399,BLOCK,-1,,"{

	}",2,,83,4,,void
66423,BLOCK,-1,,<empty>,1,,1,1,,ANY
66427,BLOCK,-1,,"{
	}",2,,42,1,,void
66433,BLOCK,-1,,"{
	}",2,,53,3,,void
66438,BLOCK,-1,,"{
	}",2,,62,2,,void
66442,BLOCK,-1,,"{
		std::lock_guard<std::recursive_mutex> lock(mutex);
		if (writer)
			writer->flush(pool);
	}",2,,67,1,,void
66463,BLOCK,-1,,<empty>,1,,1,1,,ANY
66486,BLOCK,-1,,<empty>,1,,1,1,,ANY
66503,BLOCK,-1,,<empty>,1,,1,1,,ANY
66512,BLOCK,-1,,<empty>,,,,1,,<empty>
66517,BLOCK,-1,,<empty>,,,,2,,<empty>
66522,BLOCK,-1,,<empty>,,,,2,,<empty>
66526,BLOCK,-1,,<empty>,,,,1,,<empty>
66530,BLOCK,-1,,<empty>,,,,1,,<empty>
66535,BLOCK,-1,,<empty>,,,,2,,<empty>
66547,BLOCK,-1,,<empty>,1,,1,1,,ANY
66557,BLOCK,-1,,<empty>,,,,2,,<empty>
66569,BLOCK,-1,,<empty>,1,,1,1,,ANY
66584,BLOCK,-1,,<empty>,1,,1,1,,ANY
66599,BLOCK,-1,,<empty>,1,,1,1,,ANY
66608,BLOCK,-1,,<empty>,,,,1,,<empty>
66613,BLOCK,-1,,<empty>,,,,2,,<empty>
66618,BLOCK,-1,,<empty>,,,,2,,<empty>
66623,BLOCK,-1,,<empty>,,,,2,,<empty>
66628,BLOCK,-1,,<empty>,,,,2,,<empty>
66638,BLOCK,-1,,<empty>,1,,1,1,,ANY
66661,BLOCK,-1,,<empty>,1,,1,1,,ANY
66682,BLOCK,-1,,<empty>,1,,1,1,,ANY
66697,BLOCK,-1,,<empty>,1,,1,1,,ANY
66720,BLOCK,-1,,<empty>,1,,1,1,,ANY
66733,BLOCK,-1,,<empty>,1,,1,1,,ANY
66745,BLOCK,-1,,<empty>,,,,5,,<empty>
66749,BLOCK,-1,,<empty>,,,,1,,<empty>
66753,BLOCK,-1,,<empty>,,,,1,,<empty>
66757,BLOCK,-1,,<empty>,,,,1,,<empty>
66761,BLOCK,-1,,<empty>,,,,1,,<empty>
66765,BLOCK,-1,,<empty>,,,,1,,<empty>
66775,BLOCK,-1,,<empty>,1,,1,1,,ANY
66797,BLOCK,-1,,<empty>,1,,1,1,,ANY
66814,BLOCK,-1,,<empty>,1,,1,1,,ANY
66828,BLOCK,-1,,<empty>,1,,1,1,,ANY
66838,BLOCK,-1,,<empty>,,,,2,,<empty>
66843,BLOCK,-1,,<empty>,,,,2,,<empty>
66848,BLOCK,-1,,<empty>,,,,2,,<empty>
66853,BLOCK,-1,,<empty>,,,,2,,<empty>
66863,BLOCK,-1,,<empty>,1,,1,1,,ANY
66879,BLOCK,-1,,<empty>,1,,1,1,,ANY
66890,BLOCK,-1,,<empty>,1,,1,1,,ANY
66911,BLOCK,-1,,<empty>,1,,1,1,,ANY
66927,BLOCK,-1,,<empty>,1,,1,1,,ANY
66940,BLOCK,-1,,<empty>,,,,1,,<empty>
66976,BLOCK,-1,,<empty>,1,,1,1,,ANY
66990,BLOCK,-1,,<empty>,1,,1,1,,ANY
67010,BLOCK,-1,,<empty>,1,,1,1,,ANY
67020,BLOCK,-1,,<empty>,1,,1,1,,ANY
67038,BLOCK,-1,,<empty>,1,,1,1,,ANY
67060,BLOCK,-1,,<empty>,1,,1,1,,ANY
67077,BLOCK,-1,,<empty>,1,,1,1,,ANY
67089,BLOCK,-1,,<empty>,1,,1,1,,ANY
67102,BLOCK,-1,,<empty>,1,,1,1,,ANY
67112,BLOCK,-1,,<empty>,1,,1,1,,ANY
67127,BLOCK,-1,,<empty>,1,,1,1,,ANY
67132,BLOCK,-1,,<empty>,,,,2,,<empty>
67150,BLOCK,-1,,<empty>,1,,1,1,,ANY
67165,BLOCK,-1,,<empty>,1,,1,1,,ANY
67201,BLOCK,-1,,<empty>,1,,1,1,,ANY
67208,BLOCK,-1,,<empty>,1,,1,1,,ANY
67225,BLOCK,-1,,<empty>,1,,1,1,,ANY
67229,BLOCK,-1,,"{
	throw std::bad_alloc();
	return status;
}",1,,10,2,,void
67240,BLOCK,-1,,"{
	struct cfstring_pool
	{
		apr_pool_t* ptr = 0;
		cfstring_pool()
		{
			apr_pool_create_core_ex(&ptr, throw_out_of_mem, NULL);
		}
		~cfstring_pool()
		{
			apr_pool_destroy(ptr);
		}
	};
	static LOG4CXX_NS::helpers::WideLife<cfstring_pool> pool;
	return pool.ptr;
}",1,,15,1,,void
67251,BLOCK,-1,,"{
	CFRange result;
	result.location = loc;
	result.length = len;
	return result;
}",47,,35,3,,void
67269,BLOCK,-1,,"{
	UniChar* data = (UniChar*)theString;
	CFIndex result = 0;
	while (data[result])
		++result;
	return result;
}",50,,42,2,,void
67294,BLOCK,-1,,"{
	UniChar* data = (UniChar*)theString;
	CFIndex index = 0;
	while (index < range.length) {
		*buffer = data[range.location + index];
		++index;
		++buffer;
	}
}",83,,49,4,,void
67311,BLOCK,-1,,"{
		*buffer = data[range.location + index];
		++index;
		++buffer;
	}",31,,52,2,,void
67332,BLOCK,-1,,"{
	UniChar* result = (UniChar*)apr_palloc(getStringPool(), (numChars + 1) * sizeof(UniChar));
	result[numChars] = 0;
	for (UniChar* p = result; 0 < numChars; --numChars)
		*p++ = *chars++;
	return (CFStringRef)result;
}",104,,58,4,,void
67352,BLOCK,-1,,<empty>,2,,61,1,,void
67379,BLOCK,-1,,"{
	UniChar* result = (UniChar*)apr_palloc(getStringPool(), (strlen(cStr) + 1) * sizeof(UniChar));
	for (UniChar *p = result; *p++ = *cStr++;)
		;
	return (CFStringRef)result;
}",106,,65,4,,void
67395,BLOCK,-1,,<empty>,2,,67,1,,void
67419,BLOCK,-1,,<empty>,1,,1,1,,ANY
67434,BLOCK,-1,,<empty>,,,,3,,<empty>
67439,BLOCK,-1,,<empty>,,,,2,,<empty>
67446,BLOCK,-1,,<empty>,,,,4,,<empty>
67453,BLOCK,-1,,<empty>,,,,4,,<empty>
67460,BLOCK,-1,,<empty>,,,,4,,<empty>
68712,BLOCK,-1,,<empty>,,,,1,,ANY
69133,BLOCK,1,,<empty>,,,,1,,ANY
69139,BLOCK,1,,<empty>,,,,1,,ANY
69143,BLOCK,1,,<empty>,,,,1,,ANY
69148,BLOCK,1,,<empty>,,,,1,,ANY
69153,BLOCK,1,,<empty>,,,,1,,ANY
69158,BLOCK,1,,<empty>,,,,1,,ANY
69163,BLOCK,1,,<empty>,,,,1,,ANY
69168,BLOCK,1,,<empty>,,,,1,,ANY
69173,BLOCK,1,,<empty>,,,,1,,ANY
69179,BLOCK,1,,<empty>,,,,1,,ANY
69183,BLOCK,1,,<empty>,,,,1,,ANY
69188,BLOCK,1,,<empty>,,,,1,,ANY
69193,BLOCK,1,,<empty>,,,,1,,ANY
69198,BLOCK,1,,<empty>,,,,1,,ANY
69203,BLOCK,1,,<empty>,,,,1,,ANY
69206,BLOCK,1,,<empty>,,,,1,,ANY
69211,BLOCK,1,,<empty>,,,,1,,ANY
69216,BLOCK,1,,<empty>,,,,1,,ANY
69221,BLOCK,1,,<empty>,,,,1,,ANY
69226,BLOCK,1,,<empty>,,,,1,,ANY
69231,BLOCK,1,,<empty>,,,,1,,ANY
69236,BLOCK,1,,<empty>,,,,1,,ANY
69240,BLOCK,1,,<empty>,,,,1,,ANY
69244,BLOCK,1,,<empty>,,,,1,,ANY
69250,BLOCK,1,,<empty>,,,,1,,ANY
69254,BLOCK,1,,<empty>,,,,1,,ANY
69258,BLOCK,1,,<empty>,,,,1,,ANY
69262,BLOCK,1,,<empty>,,,,1,,ANY
69267,BLOCK,1,,<empty>,,,,1,,ANY
69272,BLOCK,1,,<empty>,,,,1,,ANY
69278,BLOCK,1,,<empty>,,,,1,,ANY
69284,BLOCK,1,,<empty>,,,,1,,ANY
69290,BLOCK,1,,<empty>,,,,1,,ANY
69294,BLOCK,1,,<empty>,,,,1,,ANY
69298,BLOCK,1,,<empty>,,,,1,,ANY
69302,BLOCK,1,,<empty>,,,,1,,ANY
69308,BLOCK,1,,<empty>,,,,1,,ANY
69312,BLOCK,1,,<empty>,,,,1,,ANY
69317,BLOCK,1,,<empty>,,,,1,,ANY
69322,BLOCK,1,,<empty>,,,,1,,ANY
69328,BLOCK,1,,<empty>,,,,1,,ANY
69333,BLOCK,1,,<empty>,,,,1,,ANY
69338,BLOCK,1,,<empty>,,,,1,,ANY
69342,BLOCK,1,,<empty>,,,,1,,ANY
69347,BLOCK,1,,<empty>,,,,1,,ANY
69351,BLOCK,1,,<empty>,,,,1,,ANY
69355,BLOCK,1,,<empty>,,,,1,,ANY
69360,BLOCK,1,,<empty>,,,,1,,ANY
69364,BLOCK,1,,<empty>,,,,1,,ANY
69368,BLOCK,1,,<empty>,,,,1,,ANY
69373,BLOCK,1,,<empty>,,,,1,,ANY
69377,BLOCK,1,,<empty>,,,,1,,ANY
69381,BLOCK,1,,<empty>,,,,1,,ANY
69385,BLOCK,1,,<empty>,,,,1,,ANY
69390,BLOCK,1,,<empty>,,,,1,,ANY
69394,BLOCK,1,,<empty>,,,,1,,ANY
69399,BLOCK,1,,<empty>,,,,1,,ANY
69404,BLOCK,1,,<empty>,,,,1,,ANY
69408,BLOCK,1,,<empty>,,,,1,,ANY
69413,BLOCK,1,,<empty>,,,,1,,ANY
69418,BLOCK,1,,<empty>,,,,1,,ANY
69423,BLOCK,1,,<empty>,,,,1,,ANY
69427,BLOCK,1,,<empty>,,,,1,,ANY
69431,BLOCK,1,,<empty>,,,,1,,ANY
69436,BLOCK,1,,<empty>,,,,1,,ANY
69441,BLOCK,1,,<empty>,,,,1,,ANY
69447,BLOCK,1,,<empty>,,,,1,,ANY
69451,BLOCK,1,,<empty>,,,,1,,ANY
69458,BLOCK,1,,<empty>,,,,1,,ANY
69462,BLOCK,1,,<empty>,,,,1,,ANY
69467,BLOCK,1,,<empty>,,,,1,,ANY
69470,BLOCK,1,,<empty>,,,,1,,ANY
69474,BLOCK,1,,<empty>,,,,1,,ANY
69479,BLOCK,1,,<empty>,,,,1,,ANY
69483,BLOCK,1,,<empty>,,,,1,,ANY
69488,BLOCK,1,,<empty>,,,,1,,ANY
69494,BLOCK,1,,<empty>,,,,1,,ANY
69498,BLOCK,1,,<empty>,,,,1,,ANY
69504,BLOCK,1,,<empty>,,,,1,,ANY
69507,BLOCK,1,,<empty>,,,,1,,ANY
69514,BLOCK,1,,<empty>,,,,1,,ANY
69519,BLOCK,1,,<empty>,,,,1,,ANY
69524,BLOCK,1,,<empty>,,,,1,,ANY
69529,BLOCK,1,,<empty>,,,,1,,ANY
69533,BLOCK,1,,<empty>,,,,1,,ANY
69537,BLOCK,1,,<empty>,,,,1,,ANY
69542,BLOCK,1,,<empty>,,,,1,,ANY
69547,BLOCK,1,,<empty>,,,,1,,ANY
69551,BLOCK,1,,<empty>,,,,1,,ANY
69556,BLOCK,1,,<empty>,,,,1,,ANY
69561,BLOCK,1,,<empty>,,,,1,,ANY
69566,BLOCK,1,,<empty>,,,,1,,ANY
69571,BLOCK,1,,<empty>,,,,1,,ANY
69575,BLOCK,1,,<empty>,,,,1,,ANY
69579,BLOCK,1,,<empty>,,,,1,,ANY
69583,BLOCK,1,,<empty>,,,,1,,ANY
69590,BLOCK,1,,<empty>,,,,1,,ANY
69594,BLOCK,1,,<empty>,,,,1,,ANY
69598,BLOCK,1,,<empty>,,,,1,,ANY
69603,BLOCK,1,,<empty>,,,,1,,ANY
69607,BLOCK,1,,<empty>,,,,1,,ANY
69612,BLOCK,1,,<empty>,,,,1,,ANY
69619,BLOCK,1,,<empty>,,,,1,,ANY
69624,BLOCK,1,,<empty>,,,,1,,ANY
69630,BLOCK,1,,<empty>,,,,1,,ANY
69636,BLOCK,1,,<empty>,,,,1,,ANY
69641,BLOCK,1,,<empty>,,,,1,,ANY
69647,BLOCK,1,,<empty>,,,,1,,ANY
69651,BLOCK,1,,<empty>,,,,1,,ANY
69655,BLOCK,1,,<empty>,,,,1,,ANY
69660,BLOCK,1,,<empty>,,,,1,,ANY
69664,BLOCK,1,,<empty>,,,,1,,ANY
69667,BLOCK,1,,<empty>,,,,1,,ANY
69672,BLOCK,1,,<empty>,,,,1,,ANY
69676,BLOCK,1,,<empty>,,,,1,,ANY
69681,BLOCK,1,,<empty>,,,,1,,ANY
69685,BLOCK,1,,<empty>,,,,1,,ANY
69690,BLOCK,1,,<empty>,,,,1,,ANY
69694,BLOCK,1,,<empty>,,,,1,,ANY
69701,BLOCK,1,,<empty>,,,,1,,ANY
69705,BLOCK,1,,<empty>,,,,1,,ANY
69709,BLOCK,1,,<empty>,,,,1,,ANY
69713,BLOCK,1,,<empty>,,,,1,,ANY
69719,BLOCK,1,,<empty>,,,,1,,ANY
69723,BLOCK,1,,<empty>,,,,1,,ANY
69727,BLOCK,1,,<empty>,,,,1,,ANY
69732,BLOCK,1,,<empty>,,,,1,,ANY
69736,BLOCK,1,,<empty>,,,,1,,ANY
69741,BLOCK,1,,<empty>,,,,1,,ANY
69746,BLOCK,1,,<empty>,,,,1,,ANY
69750,BLOCK,1,,<empty>,,,,1,,ANY
69754,BLOCK,1,,<empty>,,,,1,,ANY
69759,BLOCK,1,,<empty>,,,,1,,ANY
69764,BLOCK,1,,<empty>,,,,1,,ANY
69769,BLOCK,1,,<empty>,,,,1,,ANY
69777,BLOCK,1,,<empty>,,,,1,,ANY
69780,BLOCK,1,,<empty>,,,,1,,ANY
69784,BLOCK,1,,<empty>,,,,1,,ANY
69788,BLOCK,1,,<empty>,,,,1,,ANY
69792,BLOCK,1,,<empty>,,,,1,,ANY
69796,BLOCK,1,,<empty>,,,,1,,ANY
69801,BLOCK,1,,<empty>,,,,1,,ANY
69804,BLOCK,1,,<empty>,,,,1,,ANY
69808,BLOCK,1,,<empty>,,,,1,,ANY
69817,BLOCK,1,,<empty>,,,,1,,ANY
69821,BLOCK,1,,<empty>,,,,1,,ANY
69825,BLOCK,1,,<empty>,,,,1,,ANY
69829,BLOCK,1,,<empty>,,,,1,,ANY
69837,BLOCK,1,,<empty>,,,,1,,ANY
69841,BLOCK,1,,<empty>,,,,1,,ANY
69845,BLOCK,1,,<empty>,,,,1,,ANY
69853,BLOCK,1,,<empty>,,,,1,,ANY
69857,BLOCK,1,,<empty>,,,,1,,ANY
69861,BLOCK,1,,<empty>,,,,1,,ANY
69866,BLOCK,1,,<empty>,,,,1,,ANY
69870,BLOCK,1,,<empty>,,,,1,,ANY
69875,BLOCK,1,,<empty>,,,,1,,ANY
69879,BLOCK,1,,<empty>,,,,1,,ANY
69883,BLOCK,1,,<empty>,,,,1,,ANY
69886,BLOCK,1,,<empty>,,,,1,,ANY
69891,BLOCK,1,,<empty>,,,,1,,ANY
69895,BLOCK,1,,<empty>,,,,1,,ANY
69898,BLOCK,1,,<empty>,,,,1,,ANY
69902,BLOCK,1,,<empty>,,,,1,,ANY
69905,BLOCK,1,,<empty>,,,,1,,ANY
69908,BLOCK,1,,<empty>,,,,1,,ANY
69914,BLOCK,1,,<empty>,,,,1,,ANY
69920,BLOCK,1,,<empty>,,,,1,,ANY
69923,BLOCK,1,,<empty>,,,,1,,ANY
69926,BLOCK,1,,<empty>,,,,1,,ANY
69932,BLOCK,1,,<empty>,,,,1,,ANY
69937,BLOCK,1,,<empty>,,,,1,,ANY
69942,BLOCK,1,,<empty>,,,,1,,ANY
69949,BLOCK,1,,<empty>,,,,1,,ANY
69953,BLOCK,1,,<empty>,,,,1,,ANY
69956,BLOCK,1,,<empty>,,,,1,,ANY
69960,BLOCK,1,,<empty>,,,,1,,ANY
69966,BLOCK,1,,<empty>,,,,1,,ANY
69970,BLOCK,1,,<empty>,,,,1,,ANY
69973,BLOCK,1,,<empty>,,,,1,,ANY
69979,BLOCK,1,,<empty>,,,,1,,ANY
69984,BLOCK,1,,<empty>,,,,1,,ANY
69987,BLOCK,1,,<empty>,,,,1,,ANY
69991,BLOCK,1,,<empty>,,,,1,,ANY
69997,BLOCK,1,,<empty>,,,,1,,ANY
70001,BLOCK,1,,<empty>,,,,1,,ANY
70005,BLOCK,1,,<empty>,,,,1,,ANY
70010,BLOCK,1,,<empty>,,,,1,,ANY
70013,BLOCK,1,,<empty>,,,,1,,ANY
70017,BLOCK,1,,<empty>,,,,1,,ANY
70020,BLOCK,1,,<empty>,,,,1,,ANY
70024,BLOCK,1,,<empty>,,,,1,,ANY
70028,BLOCK,1,,<empty>,,,,1,,ANY
70032,BLOCK,1,,<empty>,,,,1,,ANY
70038,BLOCK,1,,<empty>,,,,1,,ANY
70043,BLOCK,1,,<empty>,,,,1,,ANY
70047,BLOCK,1,,<empty>,,,,1,,ANY
70051,BLOCK,1,,<empty>,,,,1,,ANY
70058,BLOCK,1,,<empty>,,,,1,,ANY
70062,BLOCK,1,,<empty>,,,,1,,ANY
70066,BLOCK,1,,<empty>,,,,1,,ANY
70070,BLOCK,1,,<empty>,,,,1,,ANY
70074,BLOCK,1,,<empty>,,,,1,,ANY
70080,BLOCK,1,,<empty>,,,,1,,ANY
70084,BLOCK,1,,<empty>,,,,1,,ANY
70088,BLOCK,1,,<empty>,,,,1,,ANY
70095,BLOCK,1,,<empty>,,,,1,,ANY
70101,BLOCK,1,,<empty>,,,,1,,ANY
70106,BLOCK,1,,<empty>,,,,1,,ANY
70110,BLOCK,1,,<empty>,,,,1,,ANY
70115,BLOCK,1,,<empty>,,,,1,,ANY
70120,BLOCK,1,,<empty>,,,,1,,ANY
70124,BLOCK,1,,<empty>,,,,1,,ANY
70128,BLOCK,1,,<empty>,,,,1,,ANY
70132,BLOCK,1,,<empty>,,,,1,,ANY
70137,BLOCK,1,,<empty>,,,,1,,ANY
70141,BLOCK,1,,<empty>,,,,1,,ANY
70145,BLOCK,1,,<empty>,,,,1,,ANY
70149,BLOCK,1,,<empty>,,,,1,,ANY
70154,BLOCK,1,,<empty>,,,,1,,ANY
70158,BLOCK,1,,<empty>,,,,1,,ANY
70162,BLOCK,1,,<empty>,,,,1,,ANY
70167,BLOCK,1,,<empty>,,,,1,,ANY
70170,BLOCK,1,,<empty>,,,,1,,ANY
70175,BLOCK,1,,<empty>,,,,1,,ANY
70180,BLOCK,1,,<empty>,,,,1,,ANY
70184,BLOCK,1,,<empty>,,,,1,,ANY
70189,BLOCK,1,,<empty>,,,,1,,ANY
70195,BLOCK,1,,<empty>,,,,1,,ANY
70200,BLOCK,1,,<empty>,,,,1,,ANY
70204,BLOCK,1,,<empty>,,,,1,,ANY
70208,BLOCK,1,,<empty>,,,,1,,ANY
70215,BLOCK,1,,<empty>,,,,1,,ANY
70220,BLOCK,1,,<empty>,,,,1,,ANY
70226,BLOCK,1,,<empty>,,,,1,,ANY
70230,BLOCK,1,,<empty>,,,,1,,ANY
70235,BLOCK,1,,<empty>,,,,1,,ANY
70240,BLOCK,1,,<empty>,,,,1,,ANY
70244,BLOCK,1,,<empty>,,,,1,,ANY
70251,BLOCK,1,,<empty>,,,,1,,ANY
70255,BLOCK,1,,<empty>,,,,1,,ANY
70261,BLOCK,1,,<empty>,,,,1,,ANY
70265,BLOCK,1,,<empty>,,,,1,,ANY
70273,BLOCK,1,,<empty>,,,,1,,ANY
70280,BLOCK,1,,<empty>,,,,1,,ANY
70287,BLOCK,1,,<empty>,,,,1,,ANY
70292,BLOCK,1,,<empty>,,,,1,,ANY
70297,BLOCK,1,,<empty>,,,,1,,ANY
70304,BLOCK,1,,<empty>,,,,1,,ANY
70308,BLOCK,1,,<empty>,,,,1,,ANY
70312,BLOCK,1,,<empty>,,,,1,,ANY
70317,BLOCK,1,,<empty>,,,,1,,ANY
70321,BLOCK,1,,<empty>,,,,1,,ANY
70329,BLOCK,1,,<empty>,,,,1,,ANY
70336,BLOCK,1,,<empty>,,,,1,,ANY
70340,BLOCK,1,,<empty>,,,,1,,ANY
70343,BLOCK,1,,<empty>,,,,1,,ANY
70346,BLOCK,1,,<empty>,,,,1,,ANY
70350,BLOCK,1,,<empty>,,,,1,,ANY
70354,BLOCK,1,,<empty>,,,,1,,ANY
70358,BLOCK,1,,<empty>,,,,1,,ANY
70362,BLOCK,1,,<empty>,,,,1,,ANY
70366,BLOCK,1,,<empty>,,,,1,,ANY
70370,BLOCK,1,,<empty>,,,,1,,ANY
70376,BLOCK,1,,<empty>,,,,1,,ANY
70380,BLOCK,1,,<empty>,,,,1,,ANY
70387,BLOCK,1,,<empty>,,,,1,,ANY
70391,BLOCK,1,,<empty>,,,,1,,ANY
70394,BLOCK,1,,<empty>,,,,1,,ANY
70398,BLOCK,1,,<empty>,,,,1,,ANY
70402,BLOCK,1,,<empty>,,,,1,,ANY
70406,BLOCK,1,,<empty>,,,,1,,ANY
70410,BLOCK,1,,<empty>,,,,1,,ANY
70414,BLOCK,1,,<empty>,,,,1,,ANY
70418,BLOCK,1,,<empty>,,,,1,,ANY
70422,BLOCK,1,,<empty>,,,,1,,ANY
70429,BLOCK,1,,<empty>,,,,1,,ANY
70436,BLOCK,1,,<empty>,,,,1,,ANY
70440,BLOCK,1,,<empty>,,,,1,,ANY
70444,BLOCK,1,,<empty>,,,,1,,ANY
70447,BLOCK,1,,<empty>,,,,1,,ANY
70452,BLOCK,1,,<empty>,,,,1,,ANY
70458,BLOCK,1,,<empty>,,,,1,,ANY
70461,BLOCK,1,,<empty>,,,,1,,ANY
70465,BLOCK,1,,<empty>,,,,1,,ANY
70469,BLOCK,1,,<empty>,,,,1,,ANY
70473,BLOCK,1,,<empty>,,,,1,,ANY
70477,BLOCK,1,,<empty>,,,,1,,ANY
70481,BLOCK,1,,<empty>,,,,1,,ANY
70485,BLOCK,1,,<empty>,,,,1,,ANY
70489,BLOCK,1,,<empty>,,,,1,,ANY
70493,BLOCK,1,,<empty>,,,,1,,ANY
70497,BLOCK,1,,<empty>,,,,1,,ANY
70501,BLOCK,1,,<empty>,,,,1,,ANY
70505,BLOCK,1,,<empty>,,,,1,,ANY
70509,BLOCK,1,,<empty>,,,,1,,ANY
70513,BLOCK,1,,<empty>,,,,1,,ANY
70517,BLOCK,1,,<empty>,,,,1,,ANY
70521,BLOCK,1,,<empty>,,,,1,,ANY
70525,BLOCK,1,,<empty>,,,,1,,ANY
70529,BLOCK,1,,<empty>,,,,1,,ANY
70533,BLOCK,1,,<empty>,,,,1,,ANY
70537,BLOCK,1,,<empty>,,,,1,,ANY
70541,BLOCK,1,,<empty>,,,,1,,ANY
70545,BLOCK,1,,<empty>,,,,1,,ANY
70549,BLOCK,1,,<empty>,,,,1,,ANY
70553,BLOCK,1,,<empty>,,,,1,,ANY
70557,BLOCK,1,,<empty>,,,,1,,ANY
70561,BLOCK,1,,<empty>,,,,1,,ANY
70567,BLOCK,1,,<empty>,,,,1,,ANY
70571,BLOCK,1,,<empty>,,,,1,,ANY
70575,BLOCK,1,,<empty>,,,,1,,ANY
70579,BLOCK,1,,<empty>,,,,1,,ANY
70582,BLOCK,1,,<empty>,,,,1,,ANY
70587,BLOCK,1,,<empty>,,,,1,,ANY
70592,BLOCK,1,,<empty>,,,,1,,ANY
70596,BLOCK,1,,<empty>,,,,1,,ANY
70600,BLOCK,1,,<empty>,,,,1,,ANY
70604,BLOCK,1,,<empty>,,,,1,,ANY
70608,BLOCK,1,,<empty>,,,,1,,ANY
70611,BLOCK,1,,<empty>,,,,1,,ANY
70614,BLOCK,1,,<empty>,,,,1,,ANY
70617,BLOCK,1,,<empty>,,,,1,,ANY
70621,BLOCK,1,,<empty>,,,,1,,ANY
70625,BLOCK,1,,<empty>,,,,1,,ANY
70629,BLOCK,1,,<empty>,,,,1,,ANY
70633,BLOCK,1,,<empty>,,,,1,,ANY
70639,BLOCK,1,,<empty>,,,,1,,ANY
70642,BLOCK,1,,<empty>,,,,1,,ANY
70645,BLOCK,1,,<empty>,,,,1,,ANY
70648,BLOCK,1,,<empty>,,,,1,,ANY
70652,BLOCK,1,,<empty>,,,,1,,ANY
70656,BLOCK,1,,<empty>,,,,1,,ANY
70660,BLOCK,1,,<empty>,,,,1,,ANY
70664,BLOCK,1,,<empty>,,,,1,,ANY
70668,BLOCK,1,,<empty>,,,,1,,ANY
70672,BLOCK,1,,<empty>,,,,1,,ANY
70676,BLOCK,1,,<empty>,,,,1,,ANY
70680,BLOCK,1,,<empty>,,,,1,,ANY
70683,BLOCK,1,,<empty>,,,,1,,ANY
70687,BLOCK,1,,<empty>,,,,1,,ANY
70691,BLOCK,1,,<empty>,,,,1,,ANY
70695,BLOCK,1,,<empty>,,,,1,,ANY
70699,BLOCK,1,,<empty>,,,,1,,ANY
70703,BLOCK,1,,<empty>,,,,1,,ANY
70709,BLOCK,1,,<empty>,,,,1,,ANY
70713,BLOCK,1,,<empty>,,,,1,,ANY
70719,BLOCK,1,,<empty>,,,,1,,ANY
70725,BLOCK,1,,<empty>,,,,1,,ANY
70731,BLOCK,1,,<empty>,,,,1,,ANY
70737,BLOCK,1,,<empty>,,,,1,,ANY
70743,BLOCK,1,,<empty>,,,,1,,ANY
70749,BLOCK,1,,<empty>,,,,1,,ANY
70755,BLOCK,1,,<empty>,,,,1,,ANY
70761,BLOCK,1,,<empty>,,,,1,,ANY
70767,BLOCK,1,,<empty>,,,,1,,ANY
70773,BLOCK,1,,<empty>,,,,1,,ANY
70779,BLOCK,1,,<empty>,,,,1,,ANY
70785,BLOCK,1,,<empty>,,,,1,,ANY
70788,BLOCK,1,,<empty>,,,,1,,ANY
70793,BLOCK,1,,<empty>,,,,1,,ANY
70799,BLOCK,1,,<empty>,,,,1,,ANY
70804,BLOCK,1,,<empty>,,,,1,,ANY
70811,BLOCK,1,,<empty>,,,,1,,ANY
70818,BLOCK,1,,<empty>,,,,1,,ANY
70827,BLOCK,1,,<empty>,,,,1,,ANY
70831,BLOCK,1,,<empty>,,,,1,,ANY
70837,BLOCK,1,,<empty>,,,,1,,ANY
70842,BLOCK,1,,<empty>,,,,1,,ANY
70852,BLOCK,1,,<empty>,,,,1,,ANY
70856,BLOCK,1,,<empty>,,,,1,,ANY
70859,BLOCK,1,,<empty>,,,,1,,ANY
70862,BLOCK,1,,<empty>,,,,1,,ANY
70867,BLOCK,1,,<empty>,,,,1,,ANY
70871,BLOCK,1,,<empty>,,,,1,,ANY
70874,BLOCK,1,,<empty>,,,,1,,ANY
70878,BLOCK,1,,<empty>,,,,1,,ANY
70882,BLOCK,1,,<empty>,,,,1,,ANY
70886,BLOCK,1,,<empty>,,,,1,,ANY
70890,BLOCK,1,,<empty>,,,,1,,ANY
70894,BLOCK,1,,<empty>,,,,1,,ANY
70898,BLOCK,1,,<empty>,,,,1,,ANY
70904,BLOCK,1,,<empty>,,,,1,,ANY
70908,BLOCK,1,,<empty>,,,,1,,ANY
70914,BLOCK,1,,<empty>,,,,1,,ANY
70917,BLOCK,1,,<empty>,,,,1,,ANY
70920,BLOCK,1,,<empty>,,,,1,,ANY
70924,BLOCK,1,,<empty>,,,,1,,ANY
70927,BLOCK,1,,<empty>,,,,1,,ANY
70933,BLOCK,1,,<empty>,,,,1,,ANY
70936,BLOCK,1,,<empty>,,,,1,,ANY
70941,BLOCK,1,,<empty>,,,,1,,ANY
70950,BLOCK,1,,<empty>,,,,1,,ANY
70954,BLOCK,1,,<empty>,,,,1,,ANY
70958,BLOCK,1,,<empty>,,,,1,,ANY
70961,BLOCK,1,,<empty>,,,,1,,ANY
70967,BLOCK,1,,<empty>,,,,1,,ANY
70971,BLOCK,1,,<empty>,,,,1,,ANY
70974,BLOCK,1,,<empty>,,,,1,,ANY
70978,BLOCK,1,,<empty>,,,,1,,ANY
70982,BLOCK,1,,<empty>,,,,1,,ANY
70986,BLOCK,1,,<empty>,,,,1,,ANY
70991,BLOCK,1,,<empty>,,,,1,,ANY
70994,BLOCK,1,,<empty>,,,,1,,ANY
71001,BLOCK,1,,<empty>,,,,1,,ANY
71004,BLOCK,1,,<empty>,,,,1,,ANY
71010,BLOCK,1,,<empty>,,,,1,,ANY
71013,BLOCK,1,,<empty>,,,,1,,ANY
71020,BLOCK,1,,<empty>,,,,1,,ANY
71025,BLOCK,1,,<empty>,,,,1,,ANY
71028,BLOCK,1,,<empty>,,,,1,,ANY
71037,BLOCK,1,,<empty>,,,,1,,ANY
71040,BLOCK,1,,<empty>,,,,1,,ANY
71044,BLOCK,1,,<empty>,,,,1,,ANY
71050,BLOCK,1,,<empty>,,,,1,,ANY
71055,BLOCK,1,,<empty>,,,,1,,ANY
71058,BLOCK,1,,<empty>,,,,1,,ANY
71062,BLOCK,1,,<empty>,,,,1,,ANY
71068,BLOCK,1,,<empty>,,,,1,,ANY
71073,BLOCK,1,,<empty>,,,,1,,ANY
71078,BLOCK,1,,<empty>,,,,1,,ANY
71081,BLOCK,1,,<empty>,,,,1,,ANY
71086,BLOCK,1,,<empty>,,,,1,,ANY
71090,BLOCK,1,,<empty>,,,,1,,ANY
71098,BLOCK,1,,<empty>,,,,1,,ANY
71102,BLOCK,1,,<empty>,,,,1,,ANY
71106,BLOCK,1,,<empty>,,,,1,,ANY
71111,BLOCK,1,,<empty>,,,,1,,ANY
71116,BLOCK,1,,<empty>,,,,1,,ANY
71119,BLOCK,1,,<empty>,,,,1,,ANY
71123,BLOCK,1,,<empty>,,,,1,,ANY
71128,BLOCK,1,,<empty>,,,,1,,ANY
71131,BLOCK,1,,<empty>,,,,1,,ANY
71136,BLOCK,1,,<empty>,,,,1,,ANY
71140,BLOCK,1,,<empty>,,,,1,,ANY
71143,BLOCK,1,,<empty>,,,,1,,ANY
71148,BLOCK,1,,<empty>,,,,1,,ANY
71158,BLOCK,1,,<empty>,,,,1,,ANY
71162,BLOCK,1,,<empty>,,,,1,,ANY
71165,BLOCK,1,,<empty>,,,,1,,ANY
71173,BLOCK,1,,<empty>,,,,1,,ANY
71176,BLOCK,1,,<empty>,,,,1,,ANY
71180,BLOCK,1,,<empty>,,,,1,,ANY
71183,BLOCK,1,,<empty>,,,,1,,ANY
71188,BLOCK,1,,<empty>,,,,1,,ANY
71192,BLOCK,1,,<empty>,,,,1,,ANY
71195,BLOCK,1,,<empty>,,,,1,,ANY
71201,BLOCK,1,,<empty>,,,,1,,ANY
71205,BLOCK,1,,<empty>,,,,1,,ANY
71213,BLOCK,1,,<empty>,,,,1,,ANY
71217,BLOCK,1,,<empty>,,,,1,,ANY
71221,BLOCK,1,,<empty>,,,,1,,ANY
71225,BLOCK,1,,<empty>,,,,1,,ANY
71233,BLOCK,1,,<empty>,,,,1,,ANY
71239,BLOCK,1,,<empty>,,,,1,,ANY
71245,BLOCK,1,,<empty>,,,,1,,ANY
71251,BLOCK,1,,<empty>,,,,1,,ANY
71255,BLOCK,1,,<empty>,,,,1,,ANY
71261,BLOCK,1,,<empty>,,,,1,,ANY
71266,BLOCK,1,,<empty>,,,,1,,ANY
71271,BLOCK,1,,<empty>,,,,1,,ANY
71275,BLOCK,1,,<empty>,,,,1,,ANY
71279,BLOCK,1,,<empty>,,,,1,,ANY
71282,BLOCK,1,,<empty>,,,,1,,ANY
71285,BLOCK,1,,<empty>,,,,1,,ANY
71288,BLOCK,1,,<empty>,,,,1,,ANY
71292,BLOCK,1,,<empty>,,,,1,,ANY
71295,BLOCK,1,,<empty>,,,,1,,ANY
71298,BLOCK,1,,<empty>,,,,1,,ANY
71301,BLOCK,1,,<empty>,,,,1,,ANY
71306,BLOCK,1,,<empty>,,,,1,,ANY
71309,BLOCK,1,,<empty>,,,,1,,ANY
71315,BLOCK,1,,<empty>,,,,1,,ANY
71318,BLOCK,1,,<empty>,,,,1,,ANY
71321,BLOCK,1,,<empty>,,,,1,,ANY
71330,BLOCK,1,,<empty>,,,,1,,ANY
71333,BLOCK,1,,<empty>,,,,1,,ANY
71341,BLOCK,1,,<empty>,,,,1,,ANY
71346,BLOCK,1,,<empty>,,,,1,,ANY
71349,BLOCK,1,,<empty>,,,,1,,ANY
71355,BLOCK,1,,<empty>,,,,1,,ANY
71360,BLOCK,1,,<empty>,,,,1,,ANY
71364,BLOCK,1,,<empty>,,,,1,,ANY
71369,BLOCK,1,,<empty>,,,,1,,ANY
71374,BLOCK,1,,<empty>,,,,1,,ANY
71379,BLOCK,1,,<empty>,,,,1,,ANY
71384,BLOCK,1,,<empty>,,,,1,,ANY
71387,BLOCK,1,,<empty>,,,,1,,ANY
71392,BLOCK,1,,<empty>,,,,1,,ANY
71397,BLOCK,1,,<empty>,,,,1,,ANY
71405,BLOCK,1,,<empty>,,,,1,,ANY
71412,BLOCK,1,,<empty>,,,,1,,ANY
71417,BLOCK,1,,<empty>,,,,1,,ANY
71421,BLOCK,1,,<empty>,,,,1,,ANY
71427,BLOCK,1,,<empty>,,,,1,,ANY
71433,BLOCK,1,,<empty>,,,,1,,ANY
71439,BLOCK,1,,<empty>,,,,1,,ANY
71443,BLOCK,1,,<empty>,,,,1,,ANY
71449,BLOCK,1,,<empty>,,,,1,,ANY
71453,BLOCK,1,,<empty>,,,,1,,ANY
71456,BLOCK,1,,<empty>,,,,1,,ANY
71460,BLOCK,1,,<empty>,,,,1,,ANY
71464,BLOCK,1,,<empty>,,,,1,,ANY
71468,BLOCK,1,,<empty>,,,,1,,ANY
71472,BLOCK,1,,<empty>,,,,1,,ANY
71475,BLOCK,1,,<empty>,,,,1,,ANY
71478,BLOCK,1,,<empty>,,,,1,,ANY
71482,BLOCK,1,,<empty>,,,,1,,ANY
71487,BLOCK,1,,<empty>,,,,1,,ANY
71490,BLOCK,1,,<empty>,,,,1,,ANY
71495,BLOCK,1,,<empty>,,,,1,,ANY
71499,BLOCK,1,,<empty>,,,,1,,ANY
71503,BLOCK,1,,<empty>,,,,1,,ANY
71507,BLOCK,1,,<empty>,,,,1,,ANY
71511,BLOCK,1,,<empty>,,,,1,,ANY
71515,BLOCK,1,,<empty>,,,,1,,ANY
71519,BLOCK,1,,<empty>,,,,1,,ANY
71523,BLOCK,1,,<empty>,,,,1,,ANY
71529,BLOCK,1,,<empty>,,,,1,,ANY
71533,BLOCK,1,,<empty>,,,,1,,ANY
71537,BLOCK,1,,<empty>,,,,1,,ANY
71541,BLOCK,1,,<empty>,,,,1,,ANY
71546,BLOCK,1,,<empty>,,,,1,,ANY
71551,BLOCK,1,,<empty>,,,,1,,ANY
71557,BLOCK,1,,<empty>,,,,1,,ANY
71560,BLOCK,1,,<empty>,,,,1,,ANY
71564,BLOCK,1,,<empty>,,,,1,,ANY
71569,BLOCK,1,,<empty>,,,,1,,ANY
71572,BLOCK,1,,<empty>,,,,1,,ANY
71575,BLOCK,1,,<empty>,,,,1,,ANY
71582,BLOCK,1,,<empty>,,,,1,,ANY
71587,BLOCK,1,,<empty>,,,,1,,ANY
71593,BLOCK,1,,<empty>,,,,1,,ANY
71596,BLOCK,1,,<empty>,,,,1,,ANY
71599,BLOCK,1,,<empty>,,,,1,,ANY
71602,BLOCK,1,,<empty>,,,,1,,ANY
71605,BLOCK,1,,<empty>,,,,1,,ANY
71609,BLOCK,1,,<empty>,,,,1,,ANY
71615,BLOCK,1,,<empty>,,,,1,,ANY
71621,BLOCK,1,,<empty>,,,,1,,ANY
71625,BLOCK,1,,<empty>,,,,1,,ANY
71628,BLOCK,1,,<empty>,,,,1,,ANY
71632,BLOCK,1,,<empty>,,,,1,,ANY
71636,BLOCK,1,,<empty>,,,,1,,ANY
71641,BLOCK,1,,<empty>,,,,1,,ANY
71645,BLOCK,1,,<empty>,,,,1,,ANY
71649,BLOCK,1,,<empty>,,,,1,,ANY
71653,BLOCK,1,,<empty>,,,,1,,ANY
71657,BLOCK,1,,<empty>,,,,1,,ANY
71661,BLOCK,1,,<empty>,,,,1,,ANY
71667,BLOCK,1,,<empty>,,,,1,,ANY
71673,BLOCK,1,,<empty>,,,,1,,ANY
71678,BLOCK,1,,<empty>,,,,1,,ANY
71681,BLOCK,1,,<empty>,,,,1,,ANY
71686,BLOCK,1,,<empty>,,,,1,,ANY
71693,BLOCK,1,,<empty>,,,,1,,ANY
71697,BLOCK,1,,<empty>,,,,1,,ANY
71701,BLOCK,1,,<empty>,,,,1,,ANY
71733,BLOCK,1,,<empty>,,,,1,,ANY
71738,BLOCK,1,,<empty>,,,,1,,ANY
71743,BLOCK,1,,<empty>,,,,1,,ANY
71749,BLOCK,1,,<empty>,,,,1,,ANY
71753,BLOCK,1,,<empty>,,,,1,,ANY
71757,BLOCK,1,,<empty>,,,,1,,ANY
71761,BLOCK,1,,<empty>,,,,1,,ANY
71765,BLOCK,1,,<empty>,,,,1,,ANY
71768,BLOCK,1,,<empty>,,,,1,,ANY
71773,BLOCK,1,,<empty>,,,,1,,ANY
71780,BLOCK,1,,<empty>,,,,1,,ANY
71785,BLOCK,1,,<empty>,,,,1,,ANY
71791,BLOCK,1,,<empty>,,,,1,,ANY
71796,BLOCK,1,,<empty>,,,,1,,ANY
71802,BLOCK,1,,<empty>,,,,1,,ANY
71807,BLOCK,1,,<empty>,,,,1,,ANY
71812,BLOCK,1,,<empty>,,,,1,,ANY
71821,BLOCK,1,,<empty>,,,,1,,ANY
71828,BLOCK,1,,<empty>,,,,1,,ANY
71833,BLOCK,1,,<empty>,,,,1,,ANY
71838,BLOCK,1,,<empty>,,,,1,,ANY
71843,BLOCK,1,,<empty>,,,,1,,ANY
71848,BLOCK,1,,<empty>,,,,1,,ANY
71853,BLOCK,1,,<empty>,,,,1,,ANY
71858,BLOCK,1,,<empty>,,,,1,,ANY
71863,BLOCK,1,,<empty>,,,,1,,ANY
71867,BLOCK,1,,<empty>,,,,1,,ANY
71871,BLOCK,1,,<empty>,,,,1,,ANY
71875,BLOCK,1,,<empty>,,,,1,,ANY
71881,BLOCK,1,,<empty>,,,,1,,ANY
71887,BLOCK,1,,<empty>,,,,1,,ANY
71891,BLOCK,1,,<empty>,,,,1,,ANY
71897,BLOCK,1,,<empty>,,,,1,,ANY
71902,BLOCK,1,,<empty>,,,,1,,ANY
71908,BLOCK,1,,<empty>,,,,1,,ANY
71913,BLOCK,1,,<empty>,,,,1,,ANY
71918,BLOCK,1,,<empty>,,,,1,,ANY
71921,BLOCK,1,,<empty>,,,,1,,ANY
71926,BLOCK,1,,<empty>,,,,1,,ANY
71929,BLOCK,1,,<empty>,,,,1,,ANY
71933,BLOCK,1,,<empty>,,,,1,,ANY
71938,BLOCK,1,,<empty>,,,,1,,ANY
71943,BLOCK,1,,<empty>,,,,1,,ANY
71949,BLOCK,1,,<empty>,,,,1,,ANY
71952,BLOCK,1,,<empty>,,,,1,,ANY
71956,BLOCK,1,,<empty>,,,,1,,ANY
71960,BLOCK,1,,<empty>,,,,1,,ANY
71964,BLOCK,1,,<empty>,,,,1,,ANY
71968,BLOCK,1,,<empty>,,,,1,,ANY
71972,BLOCK,1,,<empty>,,,,1,,ANY
71976,BLOCK,1,,<empty>,,,,1,,ANY
71981,BLOCK,1,,<empty>,,,,1,,ANY
71985,BLOCK,1,,<empty>,,,,1,,ANY
71989,BLOCK,1,,<empty>,,,,1,,ANY
71993,BLOCK,1,,<empty>,,,,1,,ANY
71999,BLOCK,1,,<empty>,,,,1,,ANY
72003,BLOCK,1,,<empty>,,,,1,,ANY
72007,BLOCK,1,,<empty>,,,,1,,ANY
72011,BLOCK,1,,<empty>,,,,1,,ANY
72015,BLOCK,1,,<empty>,,,,1,,ANY
72019,BLOCK,1,,<empty>,,,,1,,ANY
72022,BLOCK,1,,<empty>,,,,1,,ANY
72026,BLOCK,1,,<empty>,,,,1,,ANY
72031,BLOCK,1,,<empty>,,,,1,,ANY
72036,BLOCK,1,,<empty>,,,,1,,ANY
72040,BLOCK,1,,<empty>,,,,1,,ANY
72046,BLOCK,1,,<empty>,,,,1,,ANY
72050,BLOCK,1,,<empty>,,,,1,,ANY
72054,BLOCK,1,,<empty>,,,,1,,ANY
72058,BLOCK,1,,<empty>,,,,1,,ANY
72062,BLOCK,1,,<empty>,,,,1,,ANY
72067,BLOCK,1,,<empty>,,,,1,,ANY
72072,BLOCK,1,,<empty>,,,,1,,ANY
72077,BLOCK,1,,<empty>,,,,1,,ANY
72083,BLOCK,1,,<empty>,,,,1,,ANY
72088,BLOCK,1,,<empty>,,,,1,,ANY
72094,BLOCK,1,,<empty>,,,,1,,ANY
72098,BLOCK,1,,<empty>,,,,1,,ANY
72104,BLOCK,1,,<empty>,,,,1,,ANY
72109,BLOCK,1,,<empty>,,,,1,,ANY
72112,BLOCK,1,,<empty>,,,,1,,ANY
72115,BLOCK,1,,<empty>,,,,1,,ANY
72118,BLOCK,1,,<empty>,,,,1,,ANY
72121,BLOCK,1,,<empty>,,,,1,,ANY
72124,BLOCK,1,,<empty>,,,,1,,ANY
72127,BLOCK,1,,<empty>,,,,1,,ANY
72130,BLOCK,1,,<empty>,,,,1,,ANY
72133,BLOCK,1,,<empty>,,,,1,,ANY
72137,BLOCK,1,,<empty>,,,,1,,ANY
72140,BLOCK,1,,<empty>,,,,1,,ANY
72144,BLOCK,1,,<empty>,,,,1,,ANY
72148,BLOCK,1,,<empty>,,,,1,,ANY
72151,BLOCK,1,,<empty>,,,,1,,ANY
72155,BLOCK,1,,<empty>,,,,1,,ANY
72159,BLOCK,1,,<empty>,,,,1,,ANY
72162,BLOCK,1,,<empty>,,,,1,,ANY
72165,BLOCK,1,,<empty>,,,,1,,ANY
72168,BLOCK,1,,<empty>,,,,1,,ANY
72174,BLOCK,1,,<empty>,,,,1,,ANY
72178,BLOCK,1,,<empty>,,,,1,,ANY
72182,BLOCK,1,,<empty>,,,,1,,ANY
72187,BLOCK,1,,<empty>,,,,1,,ANY
72192,BLOCK,1,,<empty>,,,,1,,ANY
72197,BLOCK,1,,<empty>,,,,1,,ANY
72200,BLOCK,1,,<empty>,,,,1,,ANY
72205,BLOCK,1,,<empty>,,,,1,,ANY
72211,BLOCK,1,,<empty>,,,,1,,ANY
72216,BLOCK,1,,<empty>,,,,1,,ANY
72220,BLOCK,1,,<empty>,,,,1,,ANY
72226,BLOCK,1,,<empty>,,,,1,,ANY
72230,BLOCK,1,,<empty>,,,,1,,ANY
72237,BLOCK,1,,<empty>,,,,1,,ANY
72243,BLOCK,1,,<empty>,,,,1,,ANY
72246,BLOCK,1,,<empty>,,,,1,,ANY
72250,BLOCK,1,,<empty>,,,,1,,ANY
72253,BLOCK,1,,<empty>,,,,1,,ANY
72257,BLOCK,1,,<empty>,,,,1,,ANY
72260,BLOCK,1,,<empty>,,,,1,,ANY
72263,BLOCK,1,,<empty>,,,,1,,ANY
72267,BLOCK,1,,<empty>,,,,1,,ANY
72270,BLOCK,1,,<empty>,,,,1,,ANY
72274,BLOCK,1,,<empty>,,,,1,,ANY
72279,BLOCK,1,,<empty>,,,,1,,ANY
72285,BLOCK,1,,<empty>,,,,1,,ANY
72288,BLOCK,1,,<empty>,,,,1,,ANY
72292,BLOCK,1,,<empty>,,,,1,,ANY
72295,BLOCK,1,,<empty>,,,,1,,ANY
72299,BLOCK,1,,<empty>,,,,1,,ANY
72303,BLOCK,1,,<empty>,,,,1,,ANY
72308,BLOCK,1,,<empty>,,,,1,,ANY
72311,BLOCK,1,,<empty>,,,,1,,ANY
72315,BLOCK,1,,<empty>,,,,1,,ANY
72320,BLOCK,1,,<empty>,,,,1,,ANY
72323,BLOCK,1,,<empty>,,,,1,,ANY
72328,BLOCK,1,,<empty>,,,,1,,ANY
72332,BLOCK,1,,<empty>,,,,1,,ANY
72336,BLOCK,1,,<empty>,,,,1,,ANY
72340,BLOCK,1,,<empty>,,,,1,,ANY
72344,BLOCK,1,,<empty>,,,,1,,ANY
72350,BLOCK,1,,<empty>,,,,1,,ANY
72355,BLOCK,1,,<empty>,,,,1,,ANY
72360,BLOCK,1,,<empty>,,,,1,,ANY
72365,BLOCK,1,,<empty>,,,,1,,ANY
72372,BLOCK,1,,<empty>,,,,1,,ANY
72377,BLOCK,1,,<empty>,,,,1,,ANY
72380,BLOCK,1,,<empty>,,,,1,,ANY
72385,BLOCK,1,,<empty>,,,,1,,ANY
72389,BLOCK,1,,<empty>,,,,1,,ANY
72394,BLOCK,1,,<empty>,,,,1,,ANY
72398,BLOCK,1,,<empty>,,,,1,,ANY
72401,BLOCK,1,,<empty>,,,,1,,ANY
72408,BLOCK,1,,<empty>,,,,1,,ANY
72412,BLOCK,1,,<empty>,,,,1,,ANY
72417,BLOCK,1,,<empty>,,,,1,,ANY
72420,BLOCK,1,,<empty>,,,,1,,ANY
72424,BLOCK,1,,<empty>,,,,1,,ANY
72429,BLOCK,1,,<empty>,,,,1,,ANY
72434,BLOCK,1,,<empty>,,,,1,,ANY
72438,BLOCK,1,,<empty>,,,,1,,ANY
72442,BLOCK,1,,<empty>,,,,1,,ANY
72447,BLOCK,1,,<empty>,,,,1,,ANY
72451,BLOCK,1,,<empty>,,,,1,,ANY
72455,BLOCK,1,,<empty>,,,,1,,ANY
72459,BLOCK,1,,<empty>,,,,1,,ANY
72463,BLOCK,1,,<empty>,,,,1,,ANY
72467,BLOCK,1,,<empty>,,,,1,,ANY
72470,BLOCK,1,,<empty>,,,,1,,ANY
72474,BLOCK,1,,<empty>,,,,1,,ANY
72479,BLOCK,1,,<empty>,,,,1,,ANY
72482,BLOCK,1,,<empty>,,,,1,,ANY
72486,BLOCK,1,,<empty>,,,,1,,ANY
72493,BLOCK,1,,<empty>,,,,1,,ANY
72497,BLOCK,1,,<empty>,,,,1,,ANY
72501,BLOCK,1,,<empty>,,,,1,,ANY
72505,BLOCK,1,,<empty>,,,,1,,ANY
72509,BLOCK,1,,<empty>,,,,1,,ANY
72513,BLOCK,1,,<empty>,,,,1,,ANY
72517,BLOCK,1,,<empty>,,,,1,,ANY
72521,BLOCK,1,,<empty>,,,,1,,ANY
72525,BLOCK,1,,<empty>,,,,1,,ANY
72529,BLOCK,1,,<empty>,,,,1,,ANY
72532,BLOCK,1,,<empty>,,,,1,,ANY
72536,BLOCK,1,,<empty>,,,,1,,ANY
72539,BLOCK,1,,<empty>,,,,1,,ANY
72545,BLOCK,1,,<empty>,,,,1,,ANY
72552,BLOCK,1,,<empty>,,,,1,,ANY
72556,BLOCK,1,,<empty>,,,,1,,ANY
72560,BLOCK,1,,<empty>,,,,1,,ANY
72564,BLOCK,1,,<empty>,,,,1,,ANY
72568,BLOCK,1,,<empty>,,,,1,,ANY
72573,BLOCK,1,,<empty>,,,,1,,ANY
72578,BLOCK,1,,<empty>,,,,1,,ANY
72581,BLOCK,1,,<empty>,,,,1,,ANY
72584,BLOCK,1,,<empty>,,,,1,,ANY
72588,BLOCK,1,,<empty>,,,,1,,ANY
72594,BLOCK,1,,<empty>,,,,1,,ANY
72598,BLOCK,1,,<empty>,,,,1,,ANY
72605,BLOCK,1,,<empty>,,,,1,,ANY
72611,BLOCK,1,,<empty>,,,,1,,ANY
72615,BLOCK,1,,<empty>,,,,1,,ANY
72619,BLOCK,1,,<empty>,,,,1,,ANY
72623,BLOCK,1,,<empty>,,,,1,,ANY
72629,BLOCK,1,,<empty>,,,,1,,ANY
72634,BLOCK,1,,<empty>,,,,1,,ANY
72638,BLOCK,1,,<empty>,,,,1,,ANY
72643,BLOCK,1,,<empty>,,,,1,,ANY
72648,BLOCK,1,,<empty>,,,,1,,ANY
72654,BLOCK,1,,<empty>,,,,1,,ANY
72657,BLOCK,1,,<empty>,,,,1,,ANY
72662,BLOCK,1,,<empty>,,,,1,,ANY
72666,BLOCK,1,,<empty>,,,,1,,ANY
72669,BLOCK,1,,<empty>,,,,1,,ANY
72674,BLOCK,1,,<empty>,,,,1,,ANY
72678,BLOCK,1,,<empty>,,,,1,,ANY
72682,BLOCK,1,,<empty>,,,,1,,ANY
72686,BLOCK,1,,<empty>,,,,1,,ANY
72690,BLOCK,1,,<empty>,,,,1,,ANY
72694,BLOCK,1,,<empty>,,,,1,,ANY
72698,BLOCK,1,,<empty>,,,,1,,ANY
72703,BLOCK,1,,<empty>,,,,1,,ANY
72707,BLOCK,1,,<empty>,,,,1,,ANY
72713,BLOCK,1,,<empty>,,,,1,,ANY
72717,BLOCK,1,,<empty>,,,,1,,ANY
72721,BLOCK,1,,<empty>,,,,1,,ANY
72725,BLOCK,1,,<empty>,,,,1,,ANY
72729,BLOCK,1,,<empty>,,,,1,,ANY
72732,BLOCK,1,,<empty>,,,,1,,ANY
72736,BLOCK,1,,<empty>,,,,1,,ANY
72740,BLOCK,1,,<empty>,,,,1,,ANY
72745,BLOCK,1,,<empty>,,,,1,,ANY
72749,BLOCK,1,,<empty>,,,,1,,ANY
72755,BLOCK,1,,<empty>,,,,1,,ANY
72760,BLOCK,1,,<empty>,,,,1,,ANY
72764,BLOCK,1,,<empty>,,,,1,,ANY
72768,BLOCK,1,,<empty>,,,,1,,ANY
72773,BLOCK,1,,<empty>,,,,1,,ANY
72778,BLOCK,1,,<empty>,,,,1,,ANY
72782,BLOCK,1,,<empty>,,,,1,,ANY
72786,BLOCK,1,,<empty>,,,,1,,ANY
72790,BLOCK,1,,<empty>,,,,1,,ANY
72794,BLOCK,1,,<empty>,,,,1,,ANY
72800,BLOCK,1,,<empty>,,,,1,,ANY
72806,BLOCK,1,,<empty>,,,,1,,ANY
72812,BLOCK,1,,<empty>,,,,1,,ANY
72818,BLOCK,1,,<empty>,,,,1,,ANY
72824,BLOCK,1,,<empty>,,,,1,,ANY
72830,BLOCK,1,,<empty>,,,,1,,ANY
72836,BLOCK,1,,<empty>,,,,1,,ANY
72842,BLOCK,1,,<empty>,,,,1,,ANY
72848,BLOCK,1,,<empty>,,,,1,,ANY
72854,BLOCK,1,,<empty>,,,,1,,ANY
72860,BLOCK,1,,<empty>,,,,1,,ANY
72866,BLOCK,1,,<empty>,,,,1,,ANY
72872,BLOCK,1,,<empty>,,,,1,,ANY
72878,BLOCK,1,,<empty>,,,,1,,ANY
72884,BLOCK,1,,<empty>,,,,1,,ANY
72890,BLOCK,1,,<empty>,,,,1,,ANY
72896,BLOCK,1,,<empty>,,,,1,,ANY
72902,BLOCK,1,,<empty>,,,,1,,ANY
72908,BLOCK,1,,<empty>,,,,1,,ANY
72914,BLOCK,1,,<empty>,,,,1,,ANY
72920,BLOCK,1,,<empty>,,,,1,,ANY
72926,BLOCK,1,,<empty>,,,,1,,ANY
72932,BLOCK,1,,<empty>,,,,1,,ANY
72938,BLOCK,1,,<empty>,,,,1,,ANY
72943,BLOCK,1,,<empty>,,,,1,,ANY
72948,BLOCK,1,,<empty>,,,,1,,ANY
72953,BLOCK,1,,<empty>,,,,1,,ANY
72958,BLOCK,1,,<empty>,,,,1,,ANY
72963,BLOCK,1,,<empty>,,,,1,,ANY
72968,BLOCK,1,,<empty>,,,,1,,ANY
72972,BLOCK,1,,<empty>,,,,1,,ANY
72976,BLOCK,1,,<empty>,,,,1,,ANY
72980,BLOCK,1,,<empty>,,,,1,,ANY
72984,BLOCK,1,,<empty>,,,,1,,ANY
72988,BLOCK,1,,<empty>,,,,1,,ANY
72992,BLOCK,1,,<empty>,,,,1,,ANY
72996,BLOCK,1,,<empty>,,,,1,,ANY
73007,BLOCK,1,,<empty>,,,,1,,ANY
73011,BLOCK,1,,<empty>,,,,1,,ANY
73016,BLOCK,1,,<empty>,,,,1,,ANY
73019,BLOCK,1,,<empty>,,,,1,,ANY
73027,BLOCK,1,,<empty>,,,,1,,ANY
73031,BLOCK,1,,<empty>,,,,1,,ANY
73037,BLOCK,1,,<empty>,,,,1,,ANY
73041,BLOCK,1,,<empty>,,,,1,,ANY
73048,BLOCK,1,,<empty>,,,,1,,ANY
73053,BLOCK,1,,<empty>,,,,1,,ANY
73059,BLOCK,1,,<empty>,,,,1,,ANY
73063,BLOCK,1,,<empty>,,,,1,,ANY
73066,BLOCK,1,,<empty>,,,,1,,ANY
73070,BLOCK,1,,<empty>,,,,1,,ANY
73073,BLOCK,1,,<empty>,,,,1,,ANY
73077,BLOCK,1,,<empty>,,,,1,,ANY
73082,BLOCK,1,,<empty>,,,,1,,ANY
73086,BLOCK,1,,<empty>,,,,1,,ANY
73090,BLOCK,1,,<empty>,,,,1,,ANY
73094,BLOCK,1,,<empty>,,,,1,,ANY
73098,BLOCK,1,,<empty>,,,,1,,ANY
73103,BLOCK,1,,<empty>,,,,1,,ANY
73107,BLOCK,1,,<empty>,,,,1,,ANY
73112,BLOCK,1,,<empty>,,,,1,,ANY
73116,BLOCK,1,,<empty>,,,,1,,ANY
73120,BLOCK,1,,<empty>,,,,1,,ANY
73124,BLOCK,1,,<empty>,,,,1,,ANY
73128,BLOCK,1,,<empty>,,,,1,,ANY
73132,BLOCK,1,,<empty>,,,,1,,ANY
73136,BLOCK,1,,<empty>,,,,1,,ANY
73140,BLOCK,1,,<empty>,,,,1,,ANY
73144,BLOCK,1,,<empty>,,,,1,,ANY
73148,BLOCK,1,,<empty>,,,,1,,ANY
73154,BLOCK,1,,<empty>,,,,1,,ANY
73158,BLOCK,1,,<empty>,,,,1,,ANY
73163,BLOCK,1,,<empty>,,,,1,,ANY
73167,BLOCK,1,,<empty>,,,,1,,ANY
73171,BLOCK,1,,<empty>,,,,1,,ANY
73177,BLOCK,1,,<empty>,,,,1,,ANY
73181,BLOCK,1,,<empty>,,,,1,,ANY
73185,BLOCK,1,,<empty>,,,,1,,ANY
73189,BLOCK,1,,<empty>,,,,1,,ANY
73193,BLOCK,1,,<empty>,,,,1,,ANY
73197,BLOCK,1,,<empty>,,,,1,,ANY
73201,BLOCK,1,,<empty>,,,,1,,ANY
73205,BLOCK,1,,<empty>,,,,1,,ANY
73209,BLOCK,1,,<empty>,,,,1,,ANY
73213,BLOCK,1,,<empty>,,,,1,,ANY
73217,BLOCK,1,,<empty>,,,,1,,ANY
73221,BLOCK,1,,<empty>,,,,1,,ANY
73225,BLOCK,1,,<empty>,,,,1,,ANY
73229,BLOCK,1,,<empty>,,,,1,,ANY
73233,BLOCK,1,,<empty>,,,,1,,ANY
73239,BLOCK,1,,<empty>,,,,1,,ANY
73243,BLOCK,1,,<empty>,,,,1,,ANY
73247,BLOCK,1,,<empty>,,,,1,,ANY
73251,BLOCK,1,,<empty>,,,,1,,ANY
73255,BLOCK,1,,<empty>,,,,1,,ANY
73259,BLOCK,1,,<empty>,,,,1,,ANY
73264,BLOCK,1,,<empty>,,,,1,,ANY
73268,BLOCK,1,,<empty>,,,,1,,ANY
73272,BLOCK,1,,<empty>,,,,1,,ANY
73275,BLOCK,1,,<empty>,,,,1,,ANY
73279,BLOCK,1,,<empty>,,,,1,,ANY
73284,BLOCK,1,,<empty>,,,,1,,ANY
73288,BLOCK,1,,<empty>,,,,1,,ANY
73292,BLOCK,1,,<empty>,,,,1,,ANY
73296,BLOCK,1,,<empty>,,,,1,,ANY
73300,BLOCK,1,,<empty>,,,,1,,ANY
73303,BLOCK,1,,<empty>,,,,1,,ANY
73307,BLOCK,1,,<empty>,,,,1,,ANY
73311,BLOCK,1,,<empty>,,,,1,,ANY
73315,BLOCK,1,,<empty>,,,,1,,ANY
73320,BLOCK,1,,<empty>,,,,1,,ANY
73323,BLOCK,1,,<empty>,,,,1,,ANY
73327,BLOCK,1,,<empty>,,,,1,,ANY
73333,BLOCK,1,,<empty>,,,,1,,ANY
73341,BLOCK,1,,<empty>,,,,1,,ANY
73347,BLOCK,1,,<empty>,,,,1,,ANY
73351,BLOCK,1,,<empty>,,,,1,,ANY
73355,BLOCK,1,,<empty>,,,,1,,ANY
73362,BLOCK,1,,<empty>,,,,1,,ANY
73368,BLOCK,1,,<empty>,,,,1,,ANY
73374,BLOCK,1,,<empty>,,,,1,,ANY
73377,BLOCK,1,,<empty>,,,,1,,ANY
73381,BLOCK,1,,<empty>,,,,1,,ANY
73385,BLOCK,1,,<empty>,,,,1,,ANY
73389,BLOCK,1,,<empty>,,,,1,,ANY
73393,BLOCK,1,,<empty>,,,,1,,ANY
73397,BLOCK,1,,<empty>,,,,1,,ANY
73401,BLOCK,1,,<empty>,,,,1,,ANY
73405,BLOCK,1,,<empty>,,,,1,,ANY
73409,BLOCK,1,,<empty>,,,,1,,ANY
73413,BLOCK,1,,<empty>,,,,1,,ANY
73417,BLOCK,1,,<empty>,,,,1,,ANY
73422,BLOCK,1,,<empty>,,,,1,,ANY
73427,BLOCK,1,,<empty>,,,,1,,ANY
73432,BLOCK,1,,<empty>,,,,1,,ANY
73435,BLOCK,1,,<empty>,,,,1,,ANY
73439,BLOCK,1,,<empty>,,,,1,,ANY
73443,BLOCK,1,,<empty>,,,,1,,ANY
73447,BLOCK,1,,<empty>,,,,1,,ANY
73450,BLOCK,1,,<empty>,,,,1,,ANY
73454,BLOCK,1,,<empty>,,,,1,,ANY
73458,BLOCK,1,,<empty>,,,,1,,ANY
73463,BLOCK,1,,<empty>,,,,1,,ANY
73466,BLOCK,1,,<empty>,,,,1,,ANY
73470,BLOCK,1,,<empty>,,,,1,,ANY
73474,BLOCK,1,,<empty>,,,,1,,ANY
73477,BLOCK,1,,<empty>,,,,1,,ANY
73481,BLOCK,1,,<empty>,,,,1,,ANY
73484,BLOCK,1,,<empty>,,,,1,,ANY
73487,BLOCK,1,,<empty>,,,,1,,ANY
73492,BLOCK,1,,<empty>,,,,1,,ANY
73498,BLOCK,1,,<empty>,,,,1,,ANY
73506,BLOCK,1,,<empty>,,,,1,,ANY
73512,BLOCK,1,,<empty>,,,,1,,ANY
73517,BLOCK,1,,<empty>,,,,1,,ANY
73522,BLOCK,1,,<empty>,,,,1,,ANY
73527,BLOCK,1,,<empty>,,,,1,,ANY
73532,BLOCK,1,,<empty>,,,,1,,ANY
73535,BLOCK,1,,<empty>,,,,1,,ANY
73538,BLOCK,1,,<empty>,,,,1,,ANY
73542,BLOCK,1,,<empty>,,,,1,,ANY
73546,BLOCK,1,,<empty>,,,,1,,ANY
73549,BLOCK,1,,<empty>,,,,1,,ANY
73553,BLOCK,1,,<empty>,,,,1,,ANY
73556,BLOCK,1,,<empty>,,,,1,,ANY
73564,BLOCK,1,,<empty>,,,,1,,ANY
73569,BLOCK,1,,<empty>,,,,1,,ANY
73573,BLOCK,1,,<empty>,,,,1,,ANY
73577,BLOCK,1,,<empty>,,,,1,,ANY
73581,BLOCK,1,,<empty>,,,,1,,ANY
73585,BLOCK,1,,<empty>,,,,1,,ANY
73590,BLOCK,1,,<empty>,,,,1,,ANY
73595,BLOCK,1,,<empty>,,,,1,,ANY
73601,BLOCK,1,,<empty>,,,,1,,ANY
73607,BLOCK,1,,<empty>,,,,1,,ANY
73610,BLOCK,1,,<empty>,,,,1,,ANY
73615,BLOCK,1,,<empty>,,,,1,,ANY
73619,BLOCK,1,,<empty>,,,,1,,ANY
73624,BLOCK,1,,<empty>,,,,1,,ANY
73628,BLOCK,1,,<empty>,,,,1,,ANY
73633,BLOCK,1,,<empty>,,,,1,,ANY
73638,BLOCK,1,,<empty>,,,,1,,ANY
73642,BLOCK,1,,<empty>,,,,1,,ANY
73646,BLOCK,1,,<empty>,,,,1,,ANY
73652,BLOCK,1,,<empty>,,,,1,,ANY
73656,BLOCK,1,,<empty>,,,,1,,ANY
73660,BLOCK,1,,<empty>,,,,1,,ANY
73663,BLOCK,1,,<empty>,,,,1,,ANY
73666,BLOCK,1,,<empty>,,,,1,,ANY
73669,BLOCK,1,,<empty>,,,,1,,ANY
73675,BLOCK,1,,<empty>,,,,1,,ANY
73679,BLOCK,1,,<empty>,,,,1,,ANY
73683,BLOCK,1,,<empty>,,,,1,,ANY
73687,BLOCK,1,,<empty>,,,,1,,ANY
73694,BLOCK,1,,<empty>,,,,1,,ANY
73697,BLOCK,1,,<empty>,,,,1,,ANY
73701,BLOCK,1,,<empty>,,,,1,,ANY
73704,BLOCK,1,,<empty>,,,,1,,ANY
73708,BLOCK,1,,<empty>,,,,1,,ANY
73712,BLOCK,1,,<empty>,,,,1,,ANY
73718,BLOCK,1,,<empty>,,,,1,,ANY
73724,BLOCK,1,,<empty>,,,,1,,ANY
73728,BLOCK,1,,<empty>,,,,1,,ANY
73732,BLOCK,1,,<empty>,,,,1,,ANY
73736,BLOCK,1,,<empty>,,,,1,,ANY
73740,BLOCK,1,,<empty>,,,,1,,ANY
73744,BLOCK,1,,<empty>,,,,1,,ANY
73748,BLOCK,1,,<empty>,,,,1,,ANY
73752,BLOCK,1,,<empty>,,,,1,,ANY
73756,BLOCK,1,,<empty>,,,,1,,ANY
73760,BLOCK,1,,<empty>,,,,1,,ANY
73765,BLOCK,1,,<empty>,,,,1,,ANY
73769,BLOCK,1,,<empty>,,,,1,,ANY
73774,BLOCK,1,,<empty>,,,,1,,ANY
73780,BLOCK,1,,<empty>,,,,1,,ANY
73784,BLOCK,1,,<empty>,,,,1,,ANY
73787,BLOCK,1,,<empty>,,,,1,,ANY
73790,BLOCK,1,,<empty>,,,,1,,ANY
73795,BLOCK,1,,<empty>,,,,1,,ANY
73800,BLOCK,1,,<empty>,,,,1,,ANY
73805,BLOCK,1,,<empty>,,,,1,,ANY
73810,BLOCK,1,,<empty>,,,,1,,ANY
73815,BLOCK,1,,<empty>,,,,1,,ANY
73821,BLOCK,1,,<empty>,,,,1,,ANY
73825,BLOCK,1,,<empty>,,,,1,,ANY
73829,BLOCK,1,,<empty>,,,,1,,ANY
73832,BLOCK,1,,<empty>,,,,1,,ANY
73837,BLOCK,1,,<empty>,,,,1,,ANY
73841,BLOCK,1,,<empty>,,,,1,,ANY
73845,BLOCK,1,,<empty>,,,,1,,ANY
73849,BLOCK,1,,<empty>,,,,1,,ANY
73855,BLOCK,1,,<empty>,,,,1,,ANY
73861,BLOCK,1,,<empty>,,,,1,,ANY
73865,BLOCK,1,,<empty>,,,,1,,ANY
73869,BLOCK,1,,<empty>,,,,1,,ANY
73873,BLOCK,1,,<empty>,,,,1,,ANY
73876,BLOCK,1,,<empty>,,,,1,,ANY
73880,BLOCK,1,,<empty>,,,,1,,ANY
73884,BLOCK,1,,<empty>,,,,1,,ANY
73887,BLOCK,1,,<empty>,,,,1,,ANY
73890,BLOCK,1,,<empty>,,,,1,,ANY
73896,BLOCK,1,,<empty>,,,,1,,ANY
73900,BLOCK,1,,<empty>,,,,1,,ANY
73906,BLOCK,1,,<empty>,,,,1,,ANY
73910,BLOCK,1,,<empty>,,,,1,,ANY
73915,BLOCK,1,,<empty>,,,,1,,ANY
73919,BLOCK,1,,<empty>,,,,1,,ANY
73923,BLOCK,1,,<empty>,,,,1,,ANY
73926,BLOCK,1,,<empty>,,,,1,,ANY
73929,BLOCK,1,,<empty>,,,,1,,ANY
73933,BLOCK,1,,<empty>,,,,1,,ANY
73936,BLOCK,1,,<empty>,,,,1,,ANY
73940,BLOCK,1,,<empty>,,,,1,,ANY
