,Id,Name,NodeType,Fullname,Signature,Filename,Code,LineNumber,LineNumberEnd,ColumnNumber,ColumnNumberEnd,LineOfCode,NumberOfOperators,SetOfOperators,NumberOfOperands,SetOfOperands,FanIn,FanOut,McCabe,AccCyc,ConCf,ConDf,ConZc,ConRf,ConVal,Parma,ParmaIn,ParmaOut,RetType
0,219564,android\error.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1,219565,android\specific.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2,219566,android\thread.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3,219567,audio_output\aout_internal.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4,219568,audio_output\common.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5,219569,audio_output\dec.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
6,219570,audio_output\filters.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7,219571,audio_output\output.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8,219572,audio_output\volume.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
9,219573,config\chain.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
10,219574,config\cmdline.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
11,219575,config\configuration.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
12,219576,config\core.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
13,219577,config\file.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
14,219578,config\getopt.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
15,219579,config\help.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
16,219580,config\intf.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
17,219581,config\vlc_getopt.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
18,219582,darwin\dirs.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
19,219583,darwin\error.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
20,219584,darwin\netconf.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
21,219585,darwin\specific.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
22,219586,darwin\thread.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
23,219587,extras\libc.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
24,219588,input\access.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
25,219589,input\clock.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
26,219590,input\clock.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
27,219591,input\control.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
28,219592,input\decoder.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
29,219593,input\decoder.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
30,219594,input\demux.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
31,219595,input\demux.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
32,219596,input\demux_chained.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
33,219597,input\es_out.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
34,219598,input\es_out.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
35,219599,input\es_out_timeshift.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
36,219600,input\es_out_timeshift.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
37,219601,input\event.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
38,219602,input\event.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
39,219603,input\info.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
40,219604,input\input.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
41,219605,input\input_interface.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
42,219606,input\input_internal.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
43,219607,input\item.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
44,219608,input\item.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
45,219609,input\meta.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
46,219610,input\mrl_helpers.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
47,219611,input\resource.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
48,219612,input\resource.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
49,219613,input\services_discovery.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
50,219614,input\stats.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
51,219615,input\stream.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
52,219616,input\stream.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
53,219617,input\stream_extractor.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
54,219618,input\stream_fifo.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
55,219619,input\stream_filter.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
56,219620,input\stream_memory.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
57,219621,input\subtitles.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
58,219622,input\var.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
59,219623,input\vlm.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
60,219624,input\vlm_event.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
61,219625,input\vlm_event.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
62,219626,input\vlm_internal.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
63,219627,input\vlmshell.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
64,219628,interface\dialog.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
65,219629,interface\interface.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
66,219630,libvlc-module.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
67,219631,libvlc.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
68,219632,libvlc.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
69,219633,linux\cpu.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
70,219634,linux\dirs.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
71,219635,linux\getaddrinfo.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
72,219636,linux\thread.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
73,219637,misc\actions.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
74,219638,misc\addons.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
75,219639,misc\background_worker.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
76,219640,misc\background_worker.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
77,219641,misc\block.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
78,219642,misc\cpu.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
79,219643,misc\epg.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
80,219644,misc\error.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
81,219645,misc\es_format.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
82,219646,misc\events.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
83,219647,misc\exit.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
84,219648,misc\fifo.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
85,219649,misc\filter.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
86,219650,misc\filter_chain.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
87,219651,misc\fingerprinter.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
88,219652,misc\fourcc.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
89,219653,misc\fourcc_gen.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
90,219654,misc\fourcc_list.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
91,219655,misc\httpcookies.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
92,219656,misc\image.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
93,219657,misc\interrupt.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
94,219658,misc\interrupt.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
95,219659,misc\keystore.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
96,219660,misc\md5.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
97,219661,misc\messages.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
98,219662,misc\mime.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
99,219663,misc\mtime.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
100,219664,misc\objects.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
101,219665,misc\objres.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
102,219666,misc\picture.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
103,219667,misc\picture.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
104,219668,misc\picture_fifo.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
105,219669,misc\picture_pool.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
106,219670,misc\probe.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
107,219671,misc\rand.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
108,219672,misc\renderer_discovery.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
109,219673,misc\subpicture.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
110,219674,misc\subpicture.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
111,219675,misc\text_style.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
112,219676,misc\threads.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
113,219677,misc\update.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
114,219678,misc\update.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
115,219679,misc\update_crypto.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
116,219680,misc\variables.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
117,219681,misc\variables.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
118,219682,misc\xml.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
119,219683,missing.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
120,219684,modules\bank.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
121,219685,modules\cache.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
122,219686,modules\entry.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
123,219687,modules\modules.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
124,219688,modules\modules.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
125,219689,modules\textdomain.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
126,219690,network\getaddrinfo.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
127,219691,network\http_auth.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
128,219692,network\httpd.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
129,219693,network\io.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
130,219694,network\rootbind.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
131,219695,network\tcp.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
132,219696,network\tls.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
133,219697,network\udp.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
134,219698,os2\dirs.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
135,219699,os2\filesystem.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
136,219700,os2\getaddrinfo.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
137,219701,os2\netconf.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
138,219702,os2\plugin.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
139,219703,os2\rand.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
140,219704,os2\specific.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
141,219705,os2\thread.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
142,219706,playlist\aout.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
143,219707,playlist\art.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
144,219708,playlist\art.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
145,219709,playlist\control.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
146,219710,playlist\engine.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
147,219711,playlist\fetcher.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
148,219712,playlist\fetcher.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
149,219713,playlist\item.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
150,219714,playlist\loadsave.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
151,219715,playlist\playlist_internal.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
152,219716,playlist\preparser.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
153,219717,playlist\preparser.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
154,219718,playlist\renderer.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
155,219719,playlist\search.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
156,219720,playlist\services_discovery.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
157,219721,playlist\sort.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
158,219722,playlist\thread.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
159,219723,playlist\tree.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
160,219724,posix\dirs.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
161,219725,posix\error.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
162,219726,posix\filesystem.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
163,219727,posix\getaddrinfo.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
164,219728,posix\netconf.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
165,219729,posix\plugin.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
166,219730,posix\rand.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
167,219731,posix\specific.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
168,219732,posix\thread.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
169,219733,posix\timer.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
170,219734,stream_output\sap.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
171,219735,stream_output\sdp.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
172,219736,stream_output\stream_output.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
173,219737,stream_output\stream_output.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
174,219738,text\charset.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
175,219739,text\filesystem.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
176,219740,text\iso-639_def.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
177,219741,text\iso_lang.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
178,219742,text\memstream.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
179,219743,text\strings.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
180,219744,text\unicode.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
181,219745,text\url.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
182,219746,version.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
183,219747,video_output\chrono.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
184,219748,video_output\control.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
185,219749,video_output\control.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
186,219750,video_output\display.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
187,219751,video_output\display.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
188,219752,video_output\event.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
189,219753,video_output\inhibit.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
190,219754,video_output\inhibit.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
191,219755,video_output\interlacing.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
192,219756,video_output\interlacing.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
193,219757,video_output\opengl.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
194,219758,video_output\snapshot.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
195,219759,video_output\snapshot.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
196,219760,video_output\statistic.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
197,219761,video_output\video_epg.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
198,219762,video_output\video_output.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
199,219763,video_output\video_text.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
200,219764,video_output\video_widgets.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
201,219765,video_output\vout_control.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
202,219766,video_output\vout_internal.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
203,219767,video_output\vout_intf.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
204,219768,video_output\vout_spuregion_helper.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
205,219769,video_output\vout_subpictures.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
206,219770,video_output\vout_wrapper.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
207,219771,video_output\window.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
208,219772,video_output\window.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
209,219773,win32\dirs.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
210,219774,win32\error.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
211,219775,win32\filesystem.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
212,219776,win32\mta_holder.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
213,219777,win32\netconf.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
214,219778,win32\plugin.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
215,219779,win32\rand.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
216,219780,win32\specific.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
217,219781,win32\thread.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
218,219782,win32\timer.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
219,219783,win32\winsock.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
220,66,clazz,3,fields.Environment.clazz,,android\specific.c,clazz,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
221,67,getExternalStoragePublicDirectory,3,fields.Environment.getExternalStoragePublicDirectory,,android\specific.c,getExternalStoragePublicDirectory,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
222,68,Environment,3,fields.Environment,,android\specific.c,Environment,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
223,70,getAbsolutePath,3,fields.File.getAbsolutePath,,android\specific.c,getAbsolutePath,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
224,71,File,3,fields.File,,android\specific.c,File,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
225,73,clazz,3,fields.System.clazz,,android\specific.c,clazz,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
226,74,getProperty,3,fields.System.getProperty,,android\specific.c,getProperty,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
227,75,System,3,fields.System,,android\specific.c,System,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
228,1460,thread,3,vlc_thread.thread,,android\thread.c,thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
229,1461,finished,3,vlc_thread.finished,,android\thread.c,finished,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
230,1467,data,3,vlc_thread.data,,android\thread.c,*data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
231,1469,addr,3,vlc_thread.wait.addr,,android\thread.c,*addr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
232,1470,lock,3,vlc_thread.wait.lock,,android\thread.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
233,1471,wait,3,vlc_thread.wait,,android\thread.c,wait,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
234,1472,killed,3,vlc_thread.killed,,android\thread.c,killed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
235,1473,killable,3,vlc_thread.killable,,android\thread.c,killable,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
236,2115,AOUT_RESAMPLING_NONE,3,anonymous_enum_0.AOUT_RESAMPLING_NONE,,audio_output\aout_internal.h,AOUT_RESAMPLING_NONE=0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
237,2116,AOUT_RESAMPLING_UP,3,anonymous_enum_0.AOUT_RESAMPLING_UP,,audio_output\aout_internal.h,AOUT_RESAMPLING_UP,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
238,2117,AOUT_RESAMPLING_DOWN,3,anonymous_enum_0.AOUT_RESAMPLING_DOWN,,audio_output\aout_internal.h,AOUT_RESAMPLING_DOWN,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
239,2127,,3,aout_request_vout.nan,,audio_output\aout_internal.h,"*(*pf_request_vout)( void *, struct vout_thread_t *,
                                               const video_format_t *, bool )",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
240,2128,p_private,3,aout_request_vout.p_private,,audio_output\aout_internal.h,*p_private,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
241,2134,lock,3,aout_owner_t.lock,,audio_output\aout_internal.h,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
242,2135,module,3,aout_owner_t.module,,audio_output\aout_internal.h,*module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
243,2136,filters,3,aout_owner_t.filters,,audio_output\aout_internal.h,*filters,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
244,2137,volume,3,aout_owner_t.volume,,audio_output\aout_internal.h,*volume,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
245,2139,lock,3,aout_owner_t.req.lock,,audio_output\aout_internal.h,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
246,2140,device,3,aout_owner_t.req.device,,audio_output\aout_internal.h,*device,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
247,2141,volume,3,aout_owner_t.req.volume,,audio_output\aout_internal.h,volume,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
248,2142,mute,3,aout_owner_t.req.mute,,audio_output\aout_internal.h,mute,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
249,2143,req,3,aout_owner_t.req,,audio_output\aout_internal.h,req,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
250,2145,lock,3,aout_owner_t.dev.lock,,audio_output\aout_internal.h,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
251,2146,list,3,aout_owner_t.dev.list,,audio_output\aout_internal.h,*list,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
252,2147,count,3,aout_owner_t.dev.count,,audio_output\aout_internal.h,count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
253,2148,dev,3,aout_owner_t.dev,,audio_output\aout_internal.h,dev,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
254,2150,update,3,aout_owner_t.vp.update,,audio_output\aout_internal.h,update,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
255,2151,lock,3,aout_owner_t.vp.lock,,audio_output\aout_internal.h,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
256,2152,value,3,aout_owner_t.vp.value,,audio_output\aout_internal.h,value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
257,2153,vp,3,aout_owner_t.vp,,audio_output\aout_internal.h,vp,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
258,2155,end,3,aout_owner_t.sync.end,,audio_output\aout_internal.h,end,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
259,2156,resamp_start_drift,3,aout_owner_t.sync.resamp_start_drift,,audio_output\aout_internal.h,resamp_start_drift,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
260,2157,resamp_type,3,aout_owner_t.sync.resamp_type,,audio_output\aout_internal.h,resamp_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
261,2158,discontinuity,3,aout_owner_t.sync.discontinuity,,audio_output\aout_internal.h,discontinuity,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
262,2159,sync,3,aout_owner_t.sync,,audio_output\aout_internal.h,sync,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
263,2160,initial_stereo_mode,3,aout_owner_t.initial_stereo_mode,,audio_output\aout_internal.h,initial_stereo_mode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
264,2161,input_format,3,aout_owner_t.input_format,,audio_output\aout_internal.h,input_format,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
265,2162,mixer_format,3,aout_owner_t.mixer_format,,audio_output\aout_internal.h,mixer_format,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
266,2163,request_vout,3,aout_owner_t.request_vout,,audio_output\aout_internal.h,request_vout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
267,2164,filters_cfg,3,aout_owner_t.filters_cfg,,audio_output\aout_internal.h,filters_cfg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
268,2165,buffers_lost,3,aout_owner_t.buffers_lost,,audio_output\aout_internal.h,buffers_lost,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
269,2166,buffers_played,3,aout_owner_t.buffers_played,,audio_output\aout_internal.h,buffers_played,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
270,2167,restart,3,aout_owner_t.restart,,audio_output\aout_internal.h,restart,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
271,2170,output,3,aout_instance_t.output,,audio_output\aout_internal.h,output,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
272,2171,owner,3,aout_instance_t.owner,,audio_output\aout_internal.h,owner,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
273,7007,rate_filter,3,aout_filters.rate_filter,,audio_output\filters.c,*rate_filter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
274,7008,resampler,3,aout_filters.resampler,,audio_output\filters.c,*resampler,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
275,7009,resampling,3,aout_filters.resampling,,audio_output\filters.c,resampling,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
276,7010,count,3,aout_filters.count,,audio_output\filters.c,count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
277,7011,tab,3,aout_filters.tab,,audio_output\filters.c,*tab[AOUT_MAX_FILTERS],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
278,8311,next,3,aout_dev.next,,audio_output\output.c,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
279,8312,name,3,aout_dev.name,,audio_output\output.c,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
280,8313,id,3,aout_dev.id,,audio_output\output.c,id[1],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
281,10894,object,3,aout_volume.object,,audio_output\volume.c,object,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
282,10895,replay_gain,3,aout_volume.replay_gain,,audio_output\volume.c,replay_gain,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
283,10896,gain_factor,3,aout_volume.gain_factor,,audio_output\volume.c,gain_factor,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
284,10897,output_factor,3,aout_volume.output_factor,,audio_output\volume.c,output_factor,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
285,10898,module,3,aout_volume.module,,audio_output\volume.c,*module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
286,14612,list,3,config.list,,config\core.c,**list,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
287,14613,count,3,config.count,,config\core.c,count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
288,19521,arg,3,vlc_getopt_s.arg,,config\vlc_getopt.h,*arg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
289,19522,ind,3,vlc_getopt_s.ind,,config\vlc_getopt.h,ind,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
290,19523,opt,3,vlc_getopt_s.opt,,config\vlc_getopt.h,opt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
291,19524,nextchar,3,vlc_getopt_s.nextchar,,config\vlc_getopt.h,*nextchar,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
292,19525,first_nonopt,3,vlc_getopt_s.first_nonopt,,config\vlc_getopt.h,first_nonopt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
293,19526,last_nonopt,3,vlc_getopt_s.last_nonopt,,config\vlc_getopt.h,last_nonopt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
294,19529,name,3,vlc_option.name,,config\vlc_getopt.h,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
295,19530,has_arg,3,vlc_option.has_arg,,config\vlc_getopt.h,has_arg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
296,19531,flag,3,vlc_option.flag,,config\vlc_getopt.h,*flag,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
297,19532,val,3,vlc_option.val,,config\vlc_getopt.h,val,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
298,24095,i_value,3,average_t.i_value,,input\clock.c,i_value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
299,24096,i_residue,3,average_t.i_residue,,input\clock.c,i_residue,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
300,24097,i_count,3,average_t.i_count,,input\clock.c,i_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
301,24098,i_divider,3,average_t.i_divider,,input\clock.c,i_divider,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
302,24134,i_stream,3,clock_point_t.i_stream,,input\clock.c,i_stream,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
303,24135,i_system,3,clock_point_t.i_system,,input\clock.c,i_system,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
304,24158,lock,3,input_clock_t.lock,,input\clock.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,28,0,1,1,0,0,,0,0,0,0,0,
305,24159,last,3,input_clock_t.last,,input\clock.c,last,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
306,24160,i_ts_max,3,input_clock_t.i_ts_max,,input\clock.c,i_ts_max,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
307,24161,i_buffering_duration,3,input_clock_t.i_buffering_duration,,input\clock.c,i_buffering_duration,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
308,24162,i_next_drift_update,3,input_clock_t.i_next_drift_update,,input\clock.c,i_next_drift_update,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
309,24163,drift,3,input_clock_t.drift,,input\clock.c,drift,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
310,24165,pi_value,3,input_clock_t.late.pi_value,,input\clock.c,pi_value[INPUT_CLOCK_LATE_COUNT],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
311,24166,i_index,3,input_clock_t.late.i_index,,input\clock.c,i_index,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
312,24175,late,3,input_clock_t.late,,input\clock.c,late,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
313,24176,ref,3,input_clock_t.ref,,input\clock.c,ref,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
314,24177,b_has_reference,3,input_clock_t.b_has_reference,,input\clock.c,b_has_reference,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
315,24178,i_external_clock,3,input_clock_t.i_external_clock,,input\clock.c,i_external_clock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
316,24179,b_has_external_clock,3,input_clock_t.b_has_external_clock,,input\clock.c,b_has_external_clock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
317,24180,b_paused,3,input_clock_t.b_paused,,input\clock.c,b_paused,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
318,24181,i_rate,3,input_clock_t.i_rate,,input\clock.c,i_rate,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
319,24182,i_pts_delay,3,input_clock_t.i_pts_delay,,input\clock.c,i_pts_delay,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
320,24183,i_pause_date,3,input_clock_t.i_pause_date,,input\clock.c,i_pause_date,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
321,27538,RELOAD_NO_REQUEST,3,reload.RELOAD_NO_REQUEST,,input\decoder.c,RELOAD_NO_REQUEST,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
322,27539,RELOAD_DECODER,3,reload.RELOAD_DECODER,,input\decoder.c,RELOAD_DECODER,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
323,27540,RELOAD_DECODER_AOUT,3,reload.RELOAD_DECODER_AOUT,,input\decoder.c,RELOAD_DECODER_AOUT,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
324,27542,p_input,3,decoder_owner_sys_t.p_input,,input\decoder.c,*p_input,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
325,27543,p_resource,3,decoder_owner_sys_t.p_resource,,input\decoder.c,*p_resource,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
326,27544,p_clock,3,decoder_owner_sys_t.p_clock,,input\decoder.c,*p_clock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
327,27545,i_last_rate,3,decoder_owner_sys_t.i_last_rate,,input\decoder.c,i_last_rate,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
328,27546,p_spu_vout,3,decoder_owner_sys_t.p_spu_vout,,input\decoder.c,*p_spu_vout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
329,27547,i_spu_channel,3,decoder_owner_sys_t.i_spu_channel,,input\decoder.c,i_spu_channel,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
330,27548,i_spu_order,3,decoder_owner_sys_t.i_spu_order,,input\decoder.c,i_spu_order,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
331,27549,p_sout,3,decoder_owner_sys_t.p_sout,,input\decoder.c,*p_sout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
332,27550,p_sout_input,3,decoder_owner_sys_t.p_sout_input,,input\decoder.c,*p_sout_input,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
333,27551,thread,3,decoder_owner_sys_t.thread,,input\decoder.c,thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
334,27559,p_packetizer,3,decoder_owner_sys_t.p_packetizer,,input\decoder.c,*p_packetizer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
335,27560,b_packetizer,3,decoder_owner_sys_t.b_packetizer,,input\decoder.c,b_packetizer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
336,27561,fmt,3,decoder_owner_sys_t.fmt,,input\decoder.c,fmt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,33,0,1,1,0,0,,0,0,0,0,0,
337,27562,b_fmt_description,3,decoder_owner_sys_t.b_fmt_description,,input\decoder.c,b_fmt_description,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
338,27563,p_description,3,decoder_owner_sys_t.p_description,,input\decoder.c,*p_description,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
339,27564,reload,3,decoder_owner_sys_t.reload,,input\decoder.c,reload,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
340,27565,p_fifo,3,decoder_owner_sys_t.p_fifo,,input\decoder.c,*p_fifo,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,47,0,1,1,0,0,,0,0,0,0,0,
341,27566,lock,3,decoder_owner_sys_t.lock,,input\decoder.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,67,0,1,1,0,0,,0,0,0,0,0,
342,27567,wait_request,3,decoder_owner_sys_t.wait_request,,input\decoder.c,wait_request,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
343,27568,wait_acknowledge,3,decoder_owner_sys_t.wait_acknowledge,,input\decoder.c,wait_acknowledge,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
344,27569,wait_fifo,3,decoder_owner_sys_t.wait_fifo,,input\decoder.c,wait_fifo,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
345,27570,wait_timed,3,decoder_owner_sys_t.wait_timed,,input\decoder.c,wait_timed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
346,27571,p_aout,3,decoder_owner_sys_t.p_aout,,input\decoder.c,*p_aout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,27,0,1,1,0,0,,0,0,0,0,0,
347,27572,p_vout,3,decoder_owner_sys_t.p_vout,,input\decoder.c,*p_vout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,25,0,1,1,0,0,,0,0,0,0,0,
348,27573,i_preroll_end,3,decoder_owner_sys_t.i_preroll_end,,input\decoder.c,i_preroll_end,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
349,27574,pause_date,3,decoder_owner_sys_t.pause_date,,input\decoder.c,pause_date,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
350,27575,frames_countdown,3,decoder_owner_sys_t.frames_countdown,,input\decoder.c,frames_countdown,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
351,27576,paused,3,decoder_owner_sys_t.paused,,input\decoder.c,paused,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
352,27577,error,3,decoder_owner_sys_t.error,,input\decoder.c,error,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
353,27578,b_waiting,3,decoder_owner_sys_t.b_waiting,,input\decoder.c,b_waiting,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
354,27579,b_first,3,decoder_owner_sys_t.b_first,,input\decoder.c,b_first,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
355,27580,b_has_data,3,decoder_owner_sys_t.b_has_data,,input\decoder.c,b_has_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
356,27581,flushing,3,decoder_owner_sys_t.flushing,,input\decoder.c,flushing,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
357,27582,b_draining,3,decoder_owner_sys_t.b_draining,,input\decoder.c,b_draining,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
358,27583,drained,3,decoder_owner_sys_t.drained,,input\decoder.c,drained,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
359,27584,b_idle,3,decoder_owner_sys_t.b_idle,,input\decoder.c,b_idle,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
360,27586,b_supported,3,decoder_owner_sys_t.cc.b_supported,,input\decoder.c,b_supported,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
361,27587,desc,3,decoder_owner_sys_t.cc.desc,,input\decoder.c,desc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
362,27588,pp_decoder,3,decoder_owner_sys_t.cc.pp_decoder,,input\decoder.c,*pp_decoder[MAX_CC_DECODERS],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
363,27597,cc,3,decoder_owner_sys_t.cc,,input\decoder.c,cc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
364,27598,i_ts_delay,3,decoder_owner_sys_t.i_ts_delay,,input\decoder.c,i_ts_delay,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
365,34094,key,3,demux_mapping.key,,input\demux.c,key[20],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
366,34095,name,3,demux_mapping.name,,input\demux.c,name[8],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
367,34386,demux,3,demux_priv_t.demux,,input\demux.c,demux,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
368,35808,fifo,3,vlc_demux_chained_t.fifo,,input\demux_chained.c,*fifo,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
369,35809,thread,3,vlc_demux_chained_t.thread,,input\demux_chained.c,thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
370,35810,lock,3,vlc_demux_chained_t.lock,,input\demux_chained.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
371,35812,position,3,vlc_demux_chained_t.stats.position,,input\demux_chained.c,position,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
372,35813,length,3,vlc_demux_chained_t.stats.length,,input\demux_chained.c,length,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
373,35814,time,3,vlc_demux_chained_t.stats.time,,input\demux_chained.c,time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
374,35815,stats,3,vlc_demux_chained_t.stats,,input\demux_chained.c,stats,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
375,35816,out,3,vlc_demux_chained_t.out,,input\demux_chained.c,*out,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
376,35817,name,3,vlc_demux_chained_t.name,,input\demux_chained.c,name[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
377,36226,i_id,3,es_out_pgrm_t.i_id,,input\es_out.c,i_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
378,36227,i_es,3,es_out_pgrm_t.i_es,,input\es_out.c,i_es,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
379,36228,b_selected,3,es_out_pgrm_t.b_selected,,input\es_out.c,b_selected,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
380,36229,b_scrambled,3,es_out_pgrm_t.b_scrambled,,input\es_out.c,b_scrambled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
381,36230,p_clock,3,es_out_pgrm_t.p_clock,,input\es_out.c,*p_clock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
382,36231,i_last_pcr,3,es_out_pgrm_t.i_last_pcr,,input\es_out.c,i_last_pcr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
383,36232,p_meta,3,es_out_pgrm_t.p_meta,,input\es_out.c,*p_meta,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,24,0,1,1,0,0,,0,0,0,0,0,
384,36235,i_id,3,es_out_id_t.i_id,,input\es_out.c,i_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
385,36236,p_pgrm,3,es_out_id_t.p_pgrm,,input\es_out.c,*p_pgrm,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
386,36237,b_scrambled,3,es_out_id_t.b_scrambled,,input\es_out.c,b_scrambled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
387,36238,i_channel,3,es_out_id_t.i_channel,,input\es_out.c,i_channel,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
388,36239,fmt,3,es_out_id_t.fmt,,input\es_out.c,fmt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,44,0,1,1,0,0,,0,0,0,0,0,
389,36240,psz_language,3,es_out_id_t.psz_language,,input\es_out.c,*psz_language,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
390,36241,psz_language_code,3,es_out_id_t.psz_language_code,,input\es_out.c,*psz_language_code,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
391,36242,p_dec,3,es_out_id_t.p_dec,,input\es_out.c,*p_dec,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,21,0,1,1,0,0,,0,0,0,0,0,
392,36243,p_dec_record,3,es_out_id_t.p_dec_record,,input\es_out.c,*p_dec_record,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
393,36244,i_pts_level,3,es_out_id_t.i_pts_level,,input\es_out.c,i_pts_level,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
394,36246,type,3,es_out_id_t.cc.type,,input\es_out.c,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
395,36247,i_bitmap,3,es_out_id_t.cc.i_bitmap,,input\es_out.c,i_bitmap,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
396,36248,pp_es,3,es_out_id_t.cc.pp_es,,input\es_out.c,*pp_es[64],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
397,36255,cc,3,es_out_id_t.cc,,input\es_out.c,cc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
398,36256,p_master,3,es_out_id_t.p_master,,input\es_out.c,*p_master,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
399,36257,i_meta_id,3,es_out_id_t.i_meta_id,,input\es_out.c,i_meta_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
400,36259,i_count,3,es_out_es_props_t.i_count,,input\es_out.c,i_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
401,36260,p_main_es,3,es_out_es_props_t.p_main_es,,input\es_out.c,*p_main_es,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
402,36262,e_policy,3,es_out_es_props_t.e_policy,,input\es_out.c,e_policy,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
403,36263,b_autoselect,3,es_out_es_props_t.b_autoselect,,input\es_out.c,b_autoselect,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
404,36264,i_id,3,es_out_es_props_t.i_id,,input\es_out.c,i_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
405,36265,i_demux_id,3,es_out_es_props_t.i_demux_id,,input\es_out.c,i_demux_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
406,36266,i_channel,3,es_out_es_props_t.i_channel,,input\es_out.c,i_channel,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
407,36267,ppsz_language,3,es_out_es_props_t.ppsz_language,,input\es_out.c,**ppsz_language,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
408,36270,p_input,3,es_out_sys_t.p_input,,input\es_out.c,*p_input,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
409,36271,lock,3,es_out_sys_t.lock,,input\es_out.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
410,36272,i_pgrm,3,es_out_sys_t.i_pgrm,,input\es_out.c,i_pgrm,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
411,36273,pgrm,3,es_out_sys_t.pgrm,,input\es_out.c,**pgrm,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
412,36274,p_pgrm,3,es_out_sys_t.p_pgrm,,input\es_out.c,*p_pgrm,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,26,0,1,1,0,0,,0,0,0,0,0,
413,36275,i_id,3,es_out_sys_t.i_id,,input\es_out.c,i_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
414,36276,i_es,3,es_out_sys_t.i_es,,input\es_out.c,i_es,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
415,36277,es,3,es_out_sys_t.es,,input\es_out.c,**es,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,28,0,1,1,0,0,,0,0,0,0,0,
416,36278,b_active,3,es_out_sys_t.b_active,,input\es_out.c,b_active,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
417,36279,i_mode,3,es_out_sys_t.i_mode,,input\es_out.c,i_mode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
418,36280,video,3,es_out_sys_t.video,,input\es_out.c,video,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
419,36281,audio,3,es_out_sys_t.audio,,input\es_out.c,audio,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
420,36282,sub,3,es_out_sys_t.sub,,input\es_out.c,sub,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
421,36283,i_group_id,3,es_out_sys_t.i_group_id,,input\es_out.c,i_group_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
422,36284,i_audio_delay,3,es_out_sys_t.i_audio_delay,,input\es_out.c,i_audio_delay,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
423,36285,i_spu_delay,3,es_out_sys_t.i_spu_delay,,input\es_out.c,i_spu_delay,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
424,36286,i_pts_delay,3,es_out_sys_t.i_pts_delay,,input\es_out.c,i_pts_delay,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
425,36287,i_pts_jitter,3,es_out_sys_t.i_pts_jitter,,input\es_out.c,i_pts_jitter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
426,36288,i_cr_average,3,es_out_sys_t.i_cr_average,,input\es_out.c,i_cr_average,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
427,36289,i_rate,3,es_out_sys_t.i_rate,,input\es_out.c,i_rate,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
428,36290,b_paused,3,es_out_sys_t.b_paused,,input\es_out.c,b_paused,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
429,36291,i_pause_date,3,es_out_sys_t.i_pause_date,,input\es_out.c,i_pause_date,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
430,36292,i_preroll_end,3,es_out_sys_t.i_preroll_end,,input\es_out.c,i_preroll_end,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
431,36293,b_buffering,3,es_out_sys_t.b_buffering,,input\es_out.c,b_buffering,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,17,0,1,1,0,0,,0,0,0,0,0,
432,36294,i_buffering_extra_initial,3,es_out_sys_t.i_buffering_extra_initial,,input\es_out.c,i_buffering_extra_initial,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
433,36295,i_buffering_extra_stream,3,es_out_sys_t.i_buffering_extra_stream,,input\es_out.c,i_buffering_extra_stream,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
434,36296,i_buffering_extra_system,3,es_out_sys_t.i_buffering_extra_system,,input\es_out.c,i_buffering_extra_system,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
435,36297,p_sout_record,3,es_out_sys_t.p_sout_record,,input\es_out.c,*p_sout_record,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
436,36298,i_prev_stream_level,3,es_out_sys_t.i_prev_stream_level,,input\es_out.c,i_prev_stream_level,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
437,46663,ES_OUT_MODE_NONE,3,es_out_mode_e.ES_OUT_MODE_NONE,,input\es_out.h,ES_OUT_MODE_NONE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
438,46664,ES_OUT_MODE_ALL,3,es_out_mode_e.ES_OUT_MODE_ALL,,input\es_out.h,ES_OUT_MODE_ALL,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
439,46665,ES_OUT_MODE_AUTO,3,es_out_mode_e.ES_OUT_MODE_AUTO,,input\es_out.h,ES_OUT_MODE_AUTO,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
440,46666,ES_OUT_MODE_PARTIAL,3,es_out_mode_e.ES_OUT_MODE_PARTIAL,,input\es_out.h,ES_OUT_MODE_PARTIAL,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
441,46667,ES_OUT_MODE_END,3,es_out_mode_e.ES_OUT_MODE_END,,input\es_out.h,ES_OUT_MODE_END,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
442,46669,ES_OUT_SET_MODE,3,es_out_query_private_e.ES_OUT_SET_MODE,,input\es_out.h,ES_OUT_SET_MODE = ES_OUT_PRIVATE_START,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
443,46670,ES_OUT_GET_WAKE_UP,3,es_out_query_private_e.ES_OUT_GET_WAKE_UP,,input\es_out.h,ES_OUT_GET_WAKE_UP,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
444,46671,ES_OUT_SET_ES_BY_ID,3,es_out_query_private_e.ES_OUT_SET_ES_BY_ID,,input\es_out.h,ES_OUT_SET_ES_BY_ID,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
445,46672,ES_OUT_RESTART_ES_BY_ID,3,es_out_query_private_e.ES_OUT_RESTART_ES_BY_ID,,input\es_out.h,ES_OUT_RESTART_ES_BY_ID,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
446,46673,ES_OUT_SET_ES_DEFAULT_BY_ID,3,es_out_query_private_e.ES_OUT_SET_ES_DEFAULT_BY_ID,,input\es_out.h,ES_OUT_SET_ES_DEFAULT_BY_ID,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
447,46674,ES_OUT_GET_ES_OBJECTS_BY_ID,3,es_out_query_private_e.ES_OUT_GET_ES_OBJECTS_BY_ID,,input\es_out.h,ES_OUT_GET_ES_OBJECTS_BY_ID,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
448,46675,ES_OUT_STOP_ALL_ES,3,es_out_query_private_e.ES_OUT_STOP_ALL_ES,,input\es_out.h,ES_OUT_STOP_ALL_ES,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
449,46676,ES_OUT_START_ALL_ES,3,es_out_query_private_e.ES_OUT_START_ALL_ES,,input\es_out.h,ES_OUT_START_ALL_ES,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
450,46677,ES_OUT_GET_BUFFERING,3,es_out_query_private_e.ES_OUT_GET_BUFFERING,,input\es_out.h,ES_OUT_GET_BUFFERING,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
451,46678,ES_OUT_SET_DELAY,3,es_out_query_private_e.ES_OUT_SET_DELAY,,input\es_out.h,ES_OUT_SET_DELAY,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
452,46679,ES_OUT_SET_RECORD_STATE,3,es_out_query_private_e.ES_OUT_SET_RECORD_STATE,,input\es_out.h,ES_OUT_SET_RECORD_STATE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
453,46680,ES_OUT_SET_PAUSE_STATE,3,es_out_query_private_e.ES_OUT_SET_PAUSE_STATE,,input\es_out.h,ES_OUT_SET_PAUSE_STATE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
454,46681,ES_OUT_SET_RATE,3,es_out_query_private_e.ES_OUT_SET_RATE,,input\es_out.h,ES_OUT_SET_RATE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
455,46682,ES_OUT_SET_TIME,3,es_out_query_private_e.ES_OUT_SET_TIME,,input\es_out.h,ES_OUT_SET_TIME,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
456,46683,ES_OUT_SET_FRAME_NEXT,3,es_out_query_private_e.ES_OUT_SET_FRAME_NEXT,,input\es_out.h,ES_OUT_SET_FRAME_NEXT,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
457,46684,ES_OUT_SET_TIMES,3,es_out_query_private_e.ES_OUT_SET_TIMES,,input\es_out.h,ES_OUT_SET_TIMES,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
458,46685,ES_OUT_SET_JITTER,3,es_out_query_private_e.ES_OUT_SET_JITTER,,input\es_out.h,ES_OUT_SET_JITTER,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
459,46686,ES_OUT_GET_GROUP_FORCED,3,es_out_query_private_e.ES_OUT_GET_GROUP_FORCED,,input\es_out.h,ES_OUT_GET_GROUP_FORCED,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
460,46687,ES_OUT_SET_EOS,3,es_out_query_private_e.ES_OUT_SET_EOS,,input\es_out.h,ES_OUT_SET_EOS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
461,46981,C_ADD,3,anonymous_enum_0.C_ADD,,input\es_out_timeshift.c,C_ADD,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
462,46982,C_SEND,3,anonymous_enum_0.C_SEND,,input\es_out_timeshift.c,C_SEND,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
463,46983,C_DEL,3,anonymous_enum_0.C_DEL,,input\es_out_timeshift.c,C_DEL,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
464,46984,C_CONTROL,3,anonymous_enum_0.C_CONTROL,,input\es_out_timeshift.c,C_CONTROL,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
465,46986,p_es,3,ts_cmd_add_t.p_es,,input\es_out_timeshift.c,*p_es,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
466,46987,p_fmt,3,ts_cmd_add_t.p_fmt,,input\es_out_timeshift.c,*p_fmt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
467,46990,p_es,3,ts_cmd_del_t.p_es,,input\es_out_timeshift.c,*p_es,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
468,46993,p_es,3,ts_cmd_send_t.p_es,,input\es_out_timeshift.c,*p_es,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
469,46994,p_block,3,ts_cmd_send_t.p_block,,input\es_out_timeshift.c,*p_block,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
470,46995,i_offset,3,ts_cmd_send_t.i_offset,,input\es_out_timeshift.c,i_offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
471,46998,i_query,3,ts_cmd_control_t.i_query,,input\es_out_timeshift.c,i_query,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
472,47000,b_bool,3,ts_cmd_control_t.u.b_bool,,input\es_out_timeshift.c,b_bool,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
473,47001,i_int,3,ts_cmd_control_t.u.i_int,,input\es_out_timeshift.c,i_int,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
474,47002,i_i64,3,ts_cmd_control_t.u.i_i64,,input\es_out_timeshift.c,i_i64,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
475,47003,p_es,3,ts_cmd_control_t.u.p_es,,input\es_out_timeshift.c,*p_es,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
476,47005,i_int,3,ts_cmd_control_t.u.int_i64.i_int,,input\es_out_timeshift.c,i_int,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
477,47006,i_i64,3,ts_cmd_control_t.u.int_i64.i_i64,,input\es_out_timeshift.c,i_i64,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
478,47007,int_i64,3,ts_cmd_control_t.u.int_i64,,input\es_out_timeshift.c,int_i64,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
479,47009,i_int,3,ts_cmd_control_t.u.int_meta.i_int,,input\es_out_timeshift.c,i_int,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
480,47010,p_meta,3,ts_cmd_control_t.u.int_meta.p_meta,,input\es_out_timeshift.c,*p_meta,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
481,47011,int_meta,3,ts_cmd_control_t.u.int_meta,,input\es_out_timeshift.c,int_meta,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
482,47013,i_int,3,ts_cmd_control_t.u.int_epg.i_int,,input\es_out_timeshift.c,i_int,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
483,47014,p_epg,3,ts_cmd_control_t.u.int_epg.p_epg,,input\es_out_timeshift.c,*p_epg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
484,47015,int_epg,3,ts_cmd_control_t.u.int_epg,,input\es_out_timeshift.c,int_epg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
485,47017,i_int,3,ts_cmd_control_t.u.int_epg_evt.i_int,,input\es_out_timeshift.c,i_int,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
486,47018,p_evt,3,ts_cmd_control_t.u.int_epg_evt.p_evt,,input\es_out_timeshift.c,*p_evt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
487,47019,int_epg_evt,3,ts_cmd_control_t.u.int_epg_evt,,input\es_out_timeshift.c,int_epg_evt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
488,47021,p_es,3,ts_cmd_control_t.u.es_bool.p_es,,input\es_out_timeshift.c,*p_es,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
489,47022,b_bool,3,ts_cmd_control_t.u.es_bool.b_bool,,input\es_out_timeshift.c,b_bool,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
490,47023,es_bool,3,ts_cmd_control_t.u.es_bool,,input\es_out_timeshift.c,es_bool,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
491,47025,p_es,3,ts_cmd_control_t.u.es_fmt.p_es,,input\es_out_timeshift.c,*p_es,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
492,47026,p_fmt,3,ts_cmd_control_t.u.es_fmt.p_fmt,,input\es_out_timeshift.c,*p_fmt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
493,47027,es_fmt,3,ts_cmd_control_t.u.es_fmt,,input\es_out_timeshift.c,es_fmt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
494,47029,i_cat,3,ts_cmd_control_t.u.es_policy.i_cat,,input\es_out_timeshift.c,i_cat,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
495,47030,i_policy,3,ts_cmd_control_t.u.es_policy.i_policy,,input\es_out_timeshift.c,i_policy,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
496,47031,es_policy,3,ts_cmd_control_t.u.es_policy,,input\es_out_timeshift.c,es_policy,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
497,47033,f_position,3,ts_cmd_control_t.u.times.f_position,,input\es_out_timeshift.c,f_position,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
498,47034,i_time,3,ts_cmd_control_t.u.times.i_time,,input\es_out_timeshift.c,i_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
499,47035,i_length,3,ts_cmd_control_t.u.times.i_length,,input\es_out_timeshift.c,i_length,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
500,47036,times,3,ts_cmd_control_t.u.times,,input\es_out_timeshift.c,times,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
501,47038,i_pts_delay,3,ts_cmd_control_t.u.jitter.i_pts_delay,,input\es_out_timeshift.c,i_pts_delay,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
502,47039,i_pts_jitter,3,ts_cmd_control_t.u.jitter.i_pts_jitter,,input\es_out_timeshift.c,i_pts_jitter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
503,47040,i_cr_average,3,ts_cmd_control_t.u.jitter.i_cr_average,,input\es_out_timeshift.c,i_cr_average,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
504,47041,jitter,3,ts_cmd_control_t.u.jitter,,input\es_out_timeshift.c,jitter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
505,47042,u,3,ts_cmd_control_t.u,,input\es_out_timeshift.c,u,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
506,47045,i_type,3,ts_cmd_t.i_type,,input\es_out_timeshift.c,i_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
507,47046,i_date,3,ts_cmd_t.i_date,,input\es_out_timeshift.c,i_date,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
508,47048,add,3,ts_cmd_t.u.add,,input\es_out_timeshift.c,add,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
509,47049,del,3,ts_cmd_t.u.del,,input\es_out_timeshift.c,del,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
510,47050,send,3,ts_cmd_t.u.send,,input\es_out_timeshift.c,send,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
511,47051,control,3,ts_cmd_t.u.control,,input\es_out_timeshift.c,control,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
512,47052,u,3,ts_cmd_t.u,,input\es_out_timeshift.c,u,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
513,47057,p_next,3,ts_storage_t.p_next,,input\es_out_timeshift.c,*p_next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
514,47058,psz_file,3,ts_storage_t.psz_file,,input\es_out_timeshift.c,*psz_file,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
515,47059,i_file_max,3,ts_storage_t.i_file_max,,input\es_out_timeshift.c,i_file_max,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
516,47060,i_file_size,3,ts_storage_t.i_file_size,,input\es_out_timeshift.c,i_file_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
517,47061,p_filew,3,ts_storage_t.p_filew,,input\es_out_timeshift.c,*p_filew,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
518,47062,p_filer,3,ts_storage_t.p_filer,,input\es_out_timeshift.c,*p_filer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
519,47063,i_cmd_r,3,ts_storage_t.i_cmd_r,,input\es_out_timeshift.c,i_cmd_r,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
520,47064,i_cmd_w,3,ts_storage_t.i_cmd_w,,input\es_out_timeshift.c,i_cmd_w,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
521,47065,i_cmd_max,3,ts_storage_t.i_cmd_max,,input\es_out_timeshift.c,i_cmd_max,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
522,47066,p_cmd,3,ts_storage_t.p_cmd,,input\es_out_timeshift.c,*p_cmd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
523,47068,thread,3,ts_thread_t.thread,,input\es_out_timeshift.c,thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
524,47069,p_input,3,ts_thread_t.p_input,,input\es_out_timeshift.c,*p_input,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
525,47070,p_out,3,ts_thread_t.p_out,,input\es_out_timeshift.c,*p_out,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
526,47071,i_tmp_size_max,3,ts_thread_t.i_tmp_size_max,,input\es_out_timeshift.c,i_tmp_size_max,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
527,47072,psz_tmp_path,3,ts_thread_t.psz_tmp_path,,input\es_out_timeshift.c,*psz_tmp_path,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
528,47073,lock,3,ts_thread_t.lock,,input\es_out_timeshift.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
529,47074,wait,3,ts_thread_t.wait,,input\es_out_timeshift.c,wait,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
530,47075,b_paused,3,ts_thread_t.b_paused,,input\es_out_timeshift.c,b_paused,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
531,47076,i_pause_date,3,ts_thread_t.i_pause_date,,input\es_out_timeshift.c,i_pause_date,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
532,47077,i_rate,3,ts_thread_t.i_rate,,input\es_out_timeshift.c,i_rate,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
533,47078,i_rate_source,3,ts_thread_t.i_rate_source,,input\es_out_timeshift.c,i_rate_source,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
534,47079,i_rate_date,3,ts_thread_t.i_rate_date,,input\es_out_timeshift.c,i_rate_date,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
535,47080,i_rate_delay,3,ts_thread_t.i_rate_delay,,input\es_out_timeshift.c,i_rate_delay,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
536,47081,i_buffering_delay,3,ts_thread_t.i_buffering_delay,,input\es_out_timeshift.c,i_buffering_delay,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
537,47082,p_storage_r,3,ts_thread_t.p_storage_r,,input\es_out_timeshift.c,*p_storage_r,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
538,47083,p_storage_w,3,ts_thread_t.p_storage_w,,input\es_out_timeshift.c,*p_storage_w,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
539,47084,i_cmd_delay,3,ts_thread_t.i_cmd_delay,,input\es_out_timeshift.c,i_cmd_delay,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
540,47087,p_es,3,es_out_id_t.p_es,,input\es_out_timeshift.c,*p_es,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
541,47089,p_input,3,es_out_sys_t.p_input,,input\es_out_timeshift.c,*p_input,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,35,0,1,1,0,0,,0,0,0,0,0,
542,47090,p_out,3,es_out_sys_t.p_out,,input\es_out_timeshift.c,*p_out,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
543,47091,i_tmp_size_max,3,es_out_sys_t.i_tmp_size_max,,input\es_out_timeshift.c,i_tmp_size_max,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
544,47092,psz_tmp_path,3,es_out_sys_t.psz_tmp_path,,input\es_out_timeshift.c,*psz_tmp_path,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
545,47093,lock,3,es_out_sys_t.lock,,input\es_out_timeshift.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
546,47094,b_delayed,3,es_out_sys_t.b_delayed,,input\es_out_timeshift.c,b_delayed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
547,47095,p_ts,3,es_out_sys_t.p_ts,,input\es_out_timeshift.c,*p_ts,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
548,47096,b_input_paused,3,es_out_sys_t.b_input_paused,,input\es_out_timeshift.c,b_input_paused,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
549,47097,b_input_paused_source,3,es_out_sys_t.b_input_paused_source,,input\es_out_timeshift.c,b_input_paused_source,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
550,47098,i_input_rate,3,es_out_sys_t.i_input_rate,,input\es_out_timeshift.c,i_input_rate,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
551,47099,i_input_rate_source,3,es_out_sys_t.i_input_rate_source,,input\es_out_timeshift.c,i_input_rate_source,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
552,47100,i_es,3,es_out_sys_t.i_es,,input\es_out_timeshift.c,i_es,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,21,0,1,1,0,0,,0,0,0,0,0,
553,47101,pp_es,3,es_out_sys_t.pp_es,,input\es_out_timeshift.c,**pp_es,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
554,63230,INPUT_STATISTIC_DECODED_VIDEO,3,input_statistic_t.INPUT_STATISTIC_DECODED_VIDEO,,input\input_interface.h,INPUT_STATISTIC_DECODED_VIDEO,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
555,63231,INPUT_STATISTIC_DECODED_AUDIO,3,input_statistic_t.INPUT_STATISTIC_DECODED_AUDIO,,input\input_interface.h,INPUT_STATISTIC_DECODED_AUDIO,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
556,63232,INPUT_STATISTIC_DECODED_SUBTITLE,3,input_statistic_t.INPUT_STATISTIC_DECODED_SUBTITLE,,input\input_interface.h,INPUT_STATISTIC_DECODED_SUBTITLE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
557,63233,INPUT_STATISTIC_SENT_PACKET,3,input_statistic_t.INPUT_STATISTIC_SENT_PACKET,,input\input_interface.h,INPUT_STATISTIC_SENT_PACKET,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
558,63234,INPUT_STATISTIC_SENT_BYTE,3,input_statistic_t.INPUT_STATISTIC_SENT_BYTE,,input\input_interface.h,INPUT_STATISTIC_SENT_BYTE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
559,63267,p_demux,3,input_source_t.p_demux,,input\input_internal.h,*p_demux,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
560,63268,b_title_demux,3,input_source_t.b_title_demux,,input\input_internal.h,b_title_demux,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
561,63269,i_title,3,input_source_t.i_title,,input\input_internal.h,i_title,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
562,63270,title,3,input_source_t.title,,input\input_internal.h,**title,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
563,63271,i_title_offset,3,input_source_t.i_title_offset,,input\input_internal.h,i_title_offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
564,63272,i_seekpoint_offset,3,input_source_t.i_seekpoint_offset,,input\input_internal.h,i_seekpoint_offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
565,63273,i_title_start,3,input_source_t.i_title_start,,input\input_internal.h,i_title_start,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
566,63274,i_title_end,3,input_source_t.i_title_end,,input\input_internal.h,i_title_end,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
567,63275,i_seekpoint_start,3,input_source_t.i_seekpoint_start,,input\input_internal.h,i_seekpoint_start,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
568,63276,i_seekpoint_end,3,input_source_t.i_seekpoint_end,,input\input_internal.h,i_seekpoint_end,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
569,63277,b_can_pause,3,input_source_t.b_can_pause,,input\input_internal.h,b_can_pause,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
570,63278,b_can_pace_control,3,input_source_t.b_can_pace_control,,input\input_internal.h,b_can_pace_control,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
571,63279,b_can_rate_control,3,input_source_t.b_can_rate_control,,input\input_internal.h,b_can_rate_control,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
572,63280,b_can_stream_record,3,input_source_t.b_can_stream_record,,input\input_internal.h,b_can_stream_record,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
573,63281,b_rescale_ts,3,input_source_t.b_rescale_ts,,input\input_internal.h,b_rescale_ts,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
574,63282,f_fps,3,input_source_t.f_fps,,input\input_internal.h,f_fps,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
575,63283,i_pts_delay,3,input_source_t.i_pts_delay,,input\input_internal.h,i_pts_delay,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
576,63284,b_eof,3,input_source_t.b_eof,,input\input_internal.h,b_eof,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
577,63287,i_type,3,input_control_t.i_type,,input\input_internal.h,i_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
578,63288,val,3,input_control_t.val,,input\input_internal.h,val,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
579,63292,input,3,input_thread_private_t.input,,input\input_internal.h,input,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
580,63293,b_preparsing,3,input_thread_private_t.b_preparsing,,input\input_internal.h,b_preparsing,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
581,63294,b_can_pause,3,input_thread_private_t.b_can_pause,,input\input_internal.h,b_can_pause,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
582,63295,b_can_rate_control,3,input_thread_private_t.b_can_rate_control,,input\input_internal.h,b_can_rate_control,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
583,63296,b_can_pace_control,3,input_thread_private_t.b_can_pace_control,,input\input_internal.h,b_can_pace_control,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
584,63297,i_state,3,input_thread_private_t.i_state,,input\input_internal.h,i_state,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
585,63298,is_running,3,input_thread_private_t.is_running,,input\input_internal.h,is_running,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
586,63299,is_stopped,3,input_thread_private_t.is_stopped,,input\input_internal.h,is_stopped,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
587,63300,b_recording,3,input_thread_private_t.b_recording,,input\input_internal.h,b_recording,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
588,63301,i_rate,3,input_thread_private_t.i_rate,,input\input_internal.h,i_rate,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
589,63302,i_start,3,input_thread_private_t.i_start,,input\input_internal.h,i_start,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
590,63303,i_stop,3,input_thread_private_t.i_stop,,input\input_internal.h,i_stop,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
591,63304,i_time,3,input_thread_private_t.i_time,,input\input_internal.h,i_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
592,63305,b_fast_seek,3,input_thread_private_t.b_fast_seek,,input\input_internal.h,b_fast_seek,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
593,63306,b_out_pace_control,3,input_thread_private_t.b_out_pace_control,,input\input_internal.h,b_out_pace_control,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
594,63307,p_sout,3,input_thread_private_t.p_sout,,input\input_internal.h,*p_sout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
595,63308,p_es_out,3,input_thread_private_t.p_es_out,,input\input_internal.h,*p_es_out,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
596,63309,p_es_out_display,3,input_thread_private_t.p_es_out_display,,input\input_internal.h,*p_es_out_display,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
597,63310,viewpoint,3,input_thread_private_t.viewpoint,,input\input_internal.h,viewpoint,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
598,63311,viewpoint_changed,3,input_thread_private_t.viewpoint_changed,,input\input_internal.h,viewpoint_changed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
599,63312,p_renderer,3,input_thread_private_t.p_renderer,,input\input_internal.h,*p_renderer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
600,63313,i_title,3,input_thread_private_t.i_title,,input\input_internal.h,i_title,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
601,63314,title,3,input_thread_private_t.title,,input\input_internal.h,**title,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
602,63315,i_title_offset,3,input_thread_private_t.i_title_offset,,input\input_internal.h,i_title_offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
603,63316,i_seekpoint_offset,3,input_thread_private_t.i_seekpoint_offset,,input\input_internal.h,i_seekpoint_offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
604,63317,bookmark,3,input_thread_private_t.bookmark,,input\input_internal.h,bookmark,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
605,63318,i_bookmark,3,input_thread_private_t.i_bookmark,,input\input_internal.h,i_bookmark,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
606,63319,pp_bookmark,3,input_thread_private_t.pp_bookmark,,input\input_internal.h,**pp_bookmark,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
607,63320,i_attachment,3,input_thread_private_t.i_attachment,,input\input_internal.h,i_attachment,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
608,63321,attachment,3,input_thread_private_t.attachment,,input\input_internal.h,**attachment,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
609,63322,attachment_demux,3,input_thread_private_t.attachment_demux,,input\input_internal.h,**attachment_demux,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
610,63323,p_item,3,input_thread_private_t.p_item,,input\input_internal.h,*p_item,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,36,0,1,1,0,0,,0,0,0,0,0,
611,63324,master,3,input_thread_private_t.master,,input\input_internal.h,*master,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
612,63325,i_slave,3,input_thread_private_t.i_slave,,input\input_internal.h,i_slave,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
613,63326,slave,3,input_thread_private_t.slave,,input\input_internal.h,**slave,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
614,63327,p_resource,3,input_thread_private_t.p_resource,,input\input_internal.h,*p_resource,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
615,63328,p_resource_private,3,input_thread_private_t.p_resource_private,,input\input_internal.h,*p_resource_private,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
616,63330,p_read_packets,3,input_thread_private_t.counters.p_read_packets,,input\input_internal.h,*p_read_packets,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
617,63331,p_read_bytes,3,input_thread_private_t.counters.p_read_bytes,,input\input_internal.h,*p_read_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
618,63332,p_input_bitrate,3,input_thread_private_t.counters.p_input_bitrate,,input\input_internal.h,*p_input_bitrate,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
619,63333,p_demux_read,3,input_thread_private_t.counters.p_demux_read,,input\input_internal.h,*p_demux_read,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
620,63334,p_demux_bitrate,3,input_thread_private_t.counters.p_demux_bitrate,,input\input_internal.h,*p_demux_bitrate,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
621,63335,p_demux_corrupted,3,input_thread_private_t.counters.p_demux_corrupted,,input\input_internal.h,*p_demux_corrupted,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
622,63336,p_demux_discontinuity,3,input_thread_private_t.counters.p_demux_discontinuity,,input\input_internal.h,*p_demux_discontinuity,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
623,63337,p_decoded_audio,3,input_thread_private_t.counters.p_decoded_audio,,input\input_internal.h,*p_decoded_audio,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
624,63338,p_decoded_video,3,input_thread_private_t.counters.p_decoded_video,,input\input_internal.h,*p_decoded_video,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
625,63339,p_decoded_sub,3,input_thread_private_t.counters.p_decoded_sub,,input\input_internal.h,*p_decoded_sub,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
626,63340,p_sout_sent_packets,3,input_thread_private_t.counters.p_sout_sent_packets,,input\input_internal.h,*p_sout_sent_packets,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
627,63341,p_sout_sent_bytes,3,input_thread_private_t.counters.p_sout_sent_bytes,,input\input_internal.h,*p_sout_sent_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
628,63342,p_sout_send_bitrate,3,input_thread_private_t.counters.p_sout_send_bitrate,,input\input_internal.h,*p_sout_send_bitrate,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
629,63343,p_played_abuffers,3,input_thread_private_t.counters.p_played_abuffers,,input\input_internal.h,*p_played_abuffers,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
630,63344,p_lost_abuffers,3,input_thread_private_t.counters.p_lost_abuffers,,input\input_internal.h,*p_lost_abuffers,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
631,63345,p_displayed_pictures,3,input_thread_private_t.counters.p_displayed_pictures,,input\input_internal.h,*p_displayed_pictures,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
632,63346,p_lost_pictures,3,input_thread_private_t.counters.p_lost_pictures,,input\input_internal.h,*p_lost_pictures,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
633,63347,counters_lock,3,input_thread_private_t.counters.counters_lock,,input\input_internal.h,counters_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
634,63348,counters,3,input_thread_private_t.counters,,input\input_internal.h,counters,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
635,63349,lock_control,3,input_thread_private_t.lock_control,,input\input_internal.h,lock_control,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
636,63350,wait_control,3,input_thread_private_t.wait_control,,input\input_internal.h,wait_control,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
637,63351,i_control,3,input_thread_private_t.i_control,,input\input_internal.h,i_control,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
638,63352,control,3,input_thread_private_t.control,,input\input_internal.h,control[INPUT_CONTROL_FIFO_SIZE],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
639,63353,thread,3,input_thread_private_t.thread,,input\input_internal.h,thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
640,63354,interrupt,3,input_thread_private_t.interrupt,,input\input_internal.h,interrupt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
641,63375,INPUT_CONTROL_SET_STATE,3,input_control_e.INPUT_CONTROL_SET_STATE,,input\input_internal.h,INPUT_CONTROL_SET_STATE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
642,63376,INPUT_CONTROL_SET_RATE,3,input_control_e.INPUT_CONTROL_SET_RATE,,input\input_internal.h,INPUT_CONTROL_SET_RATE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
643,63377,INPUT_CONTROL_SET_POSITION,3,input_control_e.INPUT_CONTROL_SET_POSITION,,input\input_internal.h,INPUT_CONTROL_SET_POSITION,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
644,63378,INPUT_CONTROL_SET_TIME,3,input_control_e.INPUT_CONTROL_SET_TIME,,input\input_internal.h,INPUT_CONTROL_SET_TIME,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
645,63379,INPUT_CONTROL_SET_PROGRAM,3,input_control_e.INPUT_CONTROL_SET_PROGRAM,,input\input_internal.h,INPUT_CONTROL_SET_PROGRAM,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
646,63380,INPUT_CONTROL_SET_TITLE,3,input_control_e.INPUT_CONTROL_SET_TITLE,,input\input_internal.h,INPUT_CONTROL_SET_TITLE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
647,63381,INPUT_CONTROL_SET_TITLE_NEXT,3,input_control_e.INPUT_CONTROL_SET_TITLE_NEXT,,input\input_internal.h,INPUT_CONTROL_SET_TITLE_NEXT,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
648,63382,INPUT_CONTROL_SET_TITLE_PREV,3,input_control_e.INPUT_CONTROL_SET_TITLE_PREV,,input\input_internal.h,INPUT_CONTROL_SET_TITLE_PREV,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
649,63383,INPUT_CONTROL_SET_SEEKPOINT,3,input_control_e.INPUT_CONTROL_SET_SEEKPOINT,,input\input_internal.h,INPUT_CONTROL_SET_SEEKPOINT,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
650,63384,INPUT_CONTROL_SET_SEEKPOINT_NEXT,3,input_control_e.INPUT_CONTROL_SET_SEEKPOINT_NEXT,,input\input_internal.h,INPUT_CONTROL_SET_SEEKPOINT_NEXT,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
651,63385,INPUT_CONTROL_SET_SEEKPOINT_PREV,3,input_control_e.INPUT_CONTROL_SET_SEEKPOINT_PREV,,input\input_internal.h,INPUT_CONTROL_SET_SEEKPOINT_PREV,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
652,63386,INPUT_CONTROL_SET_BOOKMARK,3,input_control_e.INPUT_CONTROL_SET_BOOKMARK,,input\input_internal.h,INPUT_CONTROL_SET_BOOKMARK,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
653,63387,INPUT_CONTROL_NAV_ACTIVATE,3,input_control_e.INPUT_CONTROL_NAV_ACTIVATE,,input\input_internal.h,INPUT_CONTROL_NAV_ACTIVATE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
654,63388,INPUT_CONTROL_NAV_UP,3,input_control_e.INPUT_CONTROL_NAV_UP,,input\input_internal.h,INPUT_CONTROL_NAV_UP,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
655,63389,INPUT_CONTROL_NAV_DOWN,3,input_control_e.INPUT_CONTROL_NAV_DOWN,,input\input_internal.h,INPUT_CONTROL_NAV_DOWN,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
656,63390,INPUT_CONTROL_NAV_LEFT,3,input_control_e.INPUT_CONTROL_NAV_LEFT,,input\input_internal.h,INPUT_CONTROL_NAV_LEFT,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
657,63391,INPUT_CONTROL_NAV_RIGHT,3,input_control_e.INPUT_CONTROL_NAV_RIGHT,,input\input_internal.h,INPUT_CONTROL_NAV_RIGHT,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
658,63392,INPUT_CONTROL_NAV_POPUP,3,input_control_e.INPUT_CONTROL_NAV_POPUP,,input\input_internal.h,INPUT_CONTROL_NAV_POPUP,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
659,63393,INPUT_CONTROL_NAV_MENU,3,input_control_e.INPUT_CONTROL_NAV_MENU,,input\input_internal.h,INPUT_CONTROL_NAV_MENU,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
660,63394,INPUT_CONTROL_SET_ES,3,input_control_e.INPUT_CONTROL_SET_ES,,input\input_internal.h,INPUT_CONTROL_SET_ES,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
661,63395,INPUT_CONTROL_RESTART_ES,3,input_control_e.INPUT_CONTROL_RESTART_ES,,input\input_internal.h,INPUT_CONTROL_RESTART_ES,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
662,63396,INPUT_CONTROL_SET_VIEWPOINT,3,input_control_e.INPUT_CONTROL_SET_VIEWPOINT,,input\input_internal.h,INPUT_CONTROL_SET_VIEWPOINT,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
663,63397,INPUT_CONTROL_SET_INITIAL_VIEWPOINT,3,input_control_e.INPUT_CONTROL_SET_INITIAL_VIEWPOINT,,input\input_internal.h,INPUT_CONTROL_SET_INITIAL_VIEWPOINT,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
664,63398,INPUT_CONTROL_UPDATE_VIEWPOINT,3,input_control_e.INPUT_CONTROL_UPDATE_VIEWPOINT,,input\input_internal.h,INPUT_CONTROL_UPDATE_VIEWPOINT,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
665,63399,INPUT_CONTROL_SET_AUDIO_DELAY,3,input_control_e.INPUT_CONTROL_SET_AUDIO_DELAY,,input\input_internal.h,INPUT_CONTROL_SET_AUDIO_DELAY,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
666,63400,INPUT_CONTROL_SET_SPU_DELAY,3,input_control_e.INPUT_CONTROL_SET_SPU_DELAY,,input\input_internal.h,INPUT_CONTROL_SET_SPU_DELAY,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
667,63401,INPUT_CONTROL_ADD_SLAVE,3,input_control_e.INPUT_CONTROL_ADD_SLAVE,,input\input_internal.h,INPUT_CONTROL_ADD_SLAVE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
668,63402,INPUT_CONTROL_SET_RECORD_STATE,3,input_control_e.INPUT_CONTROL_SET_RECORD_STATE,,input\input_internal.h,INPUT_CONTROL_SET_RECORD_STATE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
669,63403,INPUT_CONTROL_SET_FRAME_NEXT,3,input_control_e.INPUT_CONTROL_SET_FRAME_NEXT,,input\input_internal.h,INPUT_CONTROL_SET_FRAME_NEXT,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
670,63404,INPUT_CONTROL_SET_RENDERER,3,input_control_e.INPUT_CONTROL_SET_RENDERER,,input\input_internal.h,INPUT_CONTROL_SET_RENDERER,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
671,63516,next,3,input_item_opaque.next,,input\item.c,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
672,63517,value,3,input_item_opaque.value,,input\item.c,*value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
673,63518,name,3,input_item_opaque.name,,input\item.c,name[1],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
674,66805,psz_scheme,3,item_type_entry.psz_scheme,,input\item.c,*psz_scheme,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
675,66806,i_type,3,item_type_entry.i_type,,input\item.c,i_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
676,66807,b_net,3,item_type_entry.b_net,,input\item.c,b_net,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
677,67712,p_slave,3,rdh_slave.p_slave,,input\item.c,*p_slave,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
678,67713,psz_filename,3,rdh_slave.psz_filename,,input\item.c,*psz_filename,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
679,67714,p_node,3,rdh_slave.p_node,,input\item.c,*p_node,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
680,67716,p_node,3,rdh_dir.p_node,,input\item.c,*p_node,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
681,67717,psz_path,3,rdh_dir.psz_path,,input\item.c,psz_path[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
682,68886,item,3,input_item_owner.item,,input\item.h,item,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
683,68887,refs,3,input_item_owner.refs,,input\item.h,refs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
684,68915,ppsz_meta,3,vlc_meta_t.ppsz_meta,,input\meta.c,* ppsz_meta[VLC_META_TYPE_COUNT],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
685,68916,extra_tags,3,vlc_meta_t.extra_tags,,input\meta.c,extra_tags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
686,68917,i_status,3,vlc_meta_t.i_status,,input\meta.c,i_status,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
687,69998,refs,3,input_resource_t.refs,,input\resource.c,refs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
688,69999,p_parent,3,input_resource_t.p_parent,,input\resource.c,*p_parent,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
689,70000,lock,3,input_resource_t.lock,,input\resource.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
690,70001,p_input,3,input_resource_t.p_input,,input\resource.c,*p_input,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
691,70002,p_sout,3,input_resource_t.p_sout,,input\resource.c,*p_sout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
692,70003,p_vout_free,3,input_resource_t.p_vout_free,,input\resource.c,*p_vout_free,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
693,70004,lock_hold,3,input_resource_t.lock_hold,,input\resource.c,lock_hold,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,18,0,1,1,0,0,,0,0,0,0,0,
694,70005,pp_vout,3,input_resource_t.pp_vout,,input\resource.c,**pp_vout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
695,70006,i_vout,3,input_resource_t.i_vout,,input\resource.c,i_vout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
696,70007,b_aout_busy,3,input_resource_t.b_aout_busy,,input\resource.c,b_aout_busy,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
697,70008,p_aout,3,input_resource_t.p_aout,,input\resource.c,*p_aout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
698,71142,name,3,vlc_sd_probe_t.name,,input\services_discovery.c,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
699,71143,longname,3,vlc_sd_probe_t.longname,,input\services_discovery.c,*longname,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
700,71144,category,3,vlc_sd_probe_t.category,,input\services_discovery.c,category,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
701,72151,stream,3,stream_priv_t.stream,,input\stream.c,stream,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
702,72157,block,3,stream_priv_t.block,,input\stream.c,*block,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
703,72158,peek,3,stream_priv_t.peek,,input\stream.c,*peek,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
704,72159,offset,3,stream_priv_t.offset,,input\stream.c,offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
705,72160,eof,3,stream_priv_t.eof,,input\stream.c,eof,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
706,72162,conv,3,stream_priv_t.text.conv,,input\stream.c,conv,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
707,72163,char_width,3,stream_priv_t.text.char_width,,input\stream.c,char_width,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
708,72164,little_endian,3,stream_priv_t.text.little_endian,,input\stream.c,little_endian,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
709,72165,text,3,stream_priv_t.text,,input\stream.c,text,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
710,74149,extractor,3,stream_extractor_private.anonymous_composite_type_0.extractor,,input\stream_extractor.c,extractor,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
711,74150,directory,3,stream_extractor_private.anonymous_composite_type_0.directory,,input\stream_extractor.c,directory,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
712,74162,wrapper,3,stream_extractor_private.wrapper,,input\stream_extractor.c,* wrapper,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
713,74163,source,3,stream_extractor_private.source,,input\stream_extractor.c,* source,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
714,74164,module,3,stream_extractor_private.module,,input\stream_extractor.c,* module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
715,74165,object,3,stream_extractor_private.object,,input\stream_extractor.c,* object,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
716,74922,fifo,3,stream_sys_t.fifo,,input\stream_fifo.c,*fifo,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
717,74923,eof,3,stream_sys_t.eof,,input\stream_fifo.c,eof,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
718,75526,i_pos,3,stream_sys_t.i_pos,,input\stream_memory.c,i_pos,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
719,75527,i_size,3,stream_sys_t.i_size,,input\stream_memory.c,i_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
720,75528,p_buffer,3,stream_sys_t.p_buffer,,input\stream_memory.c,*p_buffer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
721,76977,psz_name,3,vlc_input_callback_t.psz_name,,input\var.c,*psz_name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
722,76978,callback,3,vlc_input_callback_t.callback,,input\var.c,callback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
723,79347,p_sem,3,preparse_data_t.p_sem,,input\vlm.c,*p_sem,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
724,79348,b_mux,3,preparse_data_t.b_mux,,input\vlm.c,b_mux,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
725,83657,psz_name,3,vlm_media_instance_sys_t.psz_name,,input\vlm_internal.h,*psz_name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
726,83658,i_index,3,vlm_media_instance_sys_t.i_index,,input\vlm_internal.h,i_index,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
727,83659,b_sout_keep,3,vlm_media_instance_sys_t.b_sout_keep,,input\vlm_internal.h,b_sout_keep,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
728,83660,p_parent,3,vlm_media_instance_sys_t.p_parent,,input\vlm_internal.h,*p_parent,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
729,83661,p_item,3,vlm_media_instance_sys_t.p_item,,input\vlm_internal.h,*p_item,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
730,83662,p_input,3,vlm_media_instance_sys_t.p_input,,input\vlm_internal.h,*p_input,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,25,0,1,1,0,0,,0,0,0,0,0,
731,83663,p_input_resource,3,vlm_media_instance_sys_t.p_input_resource,,input\vlm_internal.h,*p_input_resource,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
732,83666,cfg,3,vlm_media_sys_t.cfg,,input\vlm_internal.h,cfg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,30,0,1,1,0,0,,0,0,0,0,0,
733,83668,p_item,3,vlm_media_sys_t.vod.p_item,,input\vlm_internal.h,*p_item,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
734,83669,p_media,3,vlm_media_sys_t.vod.p_media,,input\vlm_internal.h,*p_media,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
735,83670,vod,3,vlm_media_sys_t.vod,,input\vlm_internal.h,vod,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
736,83671,i_instance,3,vlm_media_sys_t.i_instance,,input\vlm_internal.h,i_instance,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
737,83672,instance,3,vlm_media_sys_t.instance,,input\vlm_internal.h,**instance,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
738,83675,psz_name,3,vlm_schedule_sys_t.psz_name,,input\vlm_internal.h,*psz_name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
739,83676,b_enabled,3,vlm_schedule_sys_t.b_enabled,,input\vlm_internal.h,b_enabled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
740,83677,i_command,3,vlm_schedule_sys_t.i_command,,input\vlm_internal.h,i_command,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
741,83678,command,3,vlm_schedule_sys_t.command,,input\vlm_internal.h,**command,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
742,83679,date,3,vlm_schedule_sys_t.date,,input\vlm_internal.h,date,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
743,83680,period,3,vlm_schedule_sys_t.period,,input\vlm_internal.h,period,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
744,83681,i_repeat,3,vlm_schedule_sys_t.i_repeat,,input\vlm_internal.h,i_repeat,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
745,83686,lock,3,vlm_t.lock,,input\vlm_internal.h,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
746,83687,lock_delete,3,vlm_t.lock_delete,,input\vlm_internal.h,lock_delete,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
747,83688,wait_delete,3,vlm_t.wait_delete,,input\vlm_internal.h,wait_delete,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
748,83689,thread,3,vlm_t.thread,,input\vlm_internal.h,thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
749,83690,lock_manage,3,vlm_t.lock_manage,,input\vlm_internal.h,lock_manage,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
750,83691,wait_manage,3,vlm_t.wait_manage,,input\vlm_internal.h,wait_manage,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
751,83692,users,3,vlm_t.users,,input\vlm_internal.h,users,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
752,83693,input_state_changed,3,vlm_t.input_state_changed,,input\vlm_internal.h,input_state_changed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
753,83694,i_id,3,vlm_t.i_id,,input\vlm_internal.h,i_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
754,83695,p_vod,3,vlm_t.p_vod,,input\vlm_internal.h,*p_vod,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,19,0,1,1,0,0,,0,0,0,0,0,
755,83696,i_media,3,vlm_t.i_media,,input\vlm_internal.h,i_media,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
756,83697,media,3,vlm_t.media,,input\vlm_internal.h,**media,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
757,83698,i_schedule,3,vlm_t.i_schedule,,input\vlm_internal.h,i_schedule,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
758,83699,schedule,3,vlm_t.schedule,,input\vlm_internal.h,**schedule,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
759,83700,i_consecutive_errors,3,vlm_t.i_consecutive_errors,,input\vlm_internal.h,i_consecutive_errors,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
760,83787,lock,3,vlc_dialog_provider.lock,,interface\dialog.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,39,0,1,1,0,0,,0,0,0,0,0,
761,83788,dialog_array,3,vlc_dialog_provider.dialog_array,,interface\dialog.c,dialog_array,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
762,83789,cbs,3,vlc_dialog_provider.cbs,,interface\dialog.c,cbs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,19,0,1,1,0,0,,0,0,0,0,0,
763,83790,p_cbs_data,3,vlc_dialog_provider.p_cbs_data,,interface\dialog.c,*                      p_cbs_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
764,83791,pf_ext_update,3,vlc_dialog_provider.pf_ext_update,,interface\dialog.c,pf_ext_update,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
765,83792,p_ext_data,3,vlc_dialog_provider.p_ext_data,,interface\dialog.c,*                      p_ext_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
766,83794,VLC_DIALOG_ERROR,3,dialog_type.VLC_DIALOG_ERROR,,interface\dialog.c,VLC_DIALOG_ERROR,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
767,83795,VLC_DIALOG_LOGIN,3,dialog_type.VLC_DIALOG_LOGIN,,interface\dialog.c,VLC_DIALOG_LOGIN,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
768,83796,VLC_DIALOG_QUESTION,3,dialog_type.VLC_DIALOG_QUESTION,,interface\dialog.c,VLC_DIALOG_QUESTION,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
769,83797,VLC_DIALOG_PROGRESS,3,dialog_type.VLC_DIALOG_PROGRESS,,interface\dialog.c,VLC_DIALOG_PROGRESS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
770,83800,i_type,3,dialog_answer.i_type,,interface\dialog.c,i_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
771,83803,psz_username,3,dialog_answer.u.login.psz_username,,interface\dialog.c,*psz_username,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
772,83804,psz_password,3,dialog_answer.u.login.psz_password,,interface\dialog.c,*psz_password,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
773,83805,b_store,3,dialog_answer.u.login.b_store,,interface\dialog.c,b_store,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
774,83806,login,3,dialog_answer.u.login,,interface\dialog.c,login,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
775,83808,i_action,3,dialog_answer.u.question.i_action,,interface\dialog.c,i_action,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
776,83809,question,3,dialog_answer.u.question,,interface\dialog.c,question,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
777,83810,u,3,dialog_answer.u,,interface\dialog.c,u,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
778,83813,i_type,3,dialog.i_type,,interface\dialog.c,i_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
779,83814,psz_title,3,dialog.psz_title,,interface\dialog.c,*psz_title,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
780,83815,psz_text,3,dialog.psz_text,,interface\dialog.c,*psz_text,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
781,83818,psz_default_username,3,dialog.u.login.psz_default_username,,interface\dialog.c,*psz_default_username,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
782,83819,b_ask_store,3,dialog.u.login.b_ask_store,,interface\dialog.c,b_ask_store,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
783,83820,login,3,dialog.u.login,,interface\dialog.c,login,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
784,83822,i_type,3,dialog.u.question.i_type,,interface\dialog.c,i_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
785,83823,psz_cancel,3,dialog.u.question.psz_cancel,,interface\dialog.c,*psz_cancel,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
786,83824,psz_action1,3,dialog.u.question.psz_action1,,interface\dialog.c,*psz_action1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
787,83825,psz_action2,3,dialog.u.question.psz_action2,,interface\dialog.c,*psz_action2,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
788,83826,question,3,dialog.u.question,,interface\dialog.c,question,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
789,83828,b_indeterminate,3,dialog.u.progress.b_indeterminate,,interface\dialog.c,b_indeterminate,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
790,83829,f_position,3,dialog.u.progress.f_position,,interface\dialog.c,f_position,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
791,83830,psz_cancel,3,dialog.u.progress.psz_cancel,,interface\dialog.c,*psz_cancel,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
792,83831,progress,3,dialog.u.progress,,interface\dialog.c,progress,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
793,83832,u,3,dialog.u,,interface\dialog.c,u,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
794,83834,lock,3,vlc_dialog_id.lock,,interface\dialog.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,19,0,1,1,0,0,,0,0,0,0,0,
795,83835,wait,3,vlc_dialog_id.wait,,interface\dialog.c,wait,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
796,83837,i_type,3,vlc_dialog_id.i_type,,interface\dialog.c,i_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
797,83838,p_context,3,vlc_dialog_id.p_context,,interface\dialog.c,*                  p_context,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
798,83839,i_refcount,3,vlc_dialog_id.i_refcount,,interface\dialog.c,i_refcount,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
799,83840,b_cancelled,3,vlc_dialog_id.b_cancelled,,interface\dialog.c,b_cancelled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
800,83841,b_answered,3,vlc_dialog_id.b_answered,,interface\dialog.c,b_answered,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
801,83842,b_progress_indeterminate,3,vlc_dialog_id.b_progress_indeterminate,,interface\dialog.c,b_progress_indeterminate,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
802,83843,psz_progress_text,3,vlc_dialog_id.psz_progress_text,,interface\dialog.c,*                  psz_progress_text,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
803,83845,answer,3,vlc_dialog_id.answer,,interface\dialog.c,answer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
804,83847,p_provider,3,dialog_i11e_context.p_provider,,interface\dialog.c,*   p_provider,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
805,83848,p_id,3,dialog_i11e_context.p_id,,interface\dialog.c,*         p_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
806,87878,lock,3,vlc_exit.lock,,libvlc.h,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
807,87884,opaque,3,vlc_exit.opaque,,libvlc.h,*opaque,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
808,87951,public_data,3,libvlc_priv_t.public_data,,libvlc.h,public_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
809,87952,b_stats,3,libvlc_priv_t.b_stats,,libvlc.h,b_stats,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
810,87953,logger,3,libvlc_priv_t.logger,,libvlc.h,*logger,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
811,87954,p_vlm,3,libvlc_priv_t.p_vlm,,libvlc.h,*p_vlm,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
812,87955,p_dialog_provider,3,libvlc_priv_t.p_dialog_provider,,libvlc.h,*p_dialog_provider,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
813,87956,p_memory_keystore,3,libvlc_priv_t.p_memory_keystore,,libvlc.h,*p_memory_keystore,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
814,87958,playlist,3,libvlc_priv_t.playlist,,libvlc.h,*playlist,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
815,87960,parser,3,libvlc_priv_t.parser,,libvlc.h,*parser,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
816,87961,actions,3,libvlc_priv_t.actions,,libvlc.h,*actions,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
817,87962,exit,3,libvlc_priv_t.exit,,libvlc.h,exit,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
818,88005,STATS_COUNTER,3,anonymous_enum_0.STATS_COUNTER,,libvlc.h,STATS_COUNTER,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
819,88006,STATS_DERIVATIVE,3,anonymous_enum_0.STATS_DERIVATIVE,,libvlc.h,STATS_DERIVATIVE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
820,88008,value,3,counter_sample_t.value,,libvlc.h,value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
821,88009,date,3,counter_sample_t.date,,libvlc.h,date,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
822,88012,i_compute_type,3,counter_t.i_compute_type,,libvlc.h,i_compute_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
823,88013,i_samples,3,counter_t.i_samples,,libvlc.h,i_samples,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
824,88014,pp_samples,3,counter_t.pp_samples,,libvlc.h,** pp_samples,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
825,88015,last_update,3,counter_t.last_update,,libvlc.h,last_update,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
826,88018,STATS_INPUT_BITRATE,3,anonymous_enum_1.STATS_INPUT_BITRATE,,libvlc.h,STATS_INPUT_BITRATE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
827,88019,STATS_READ_BYTES,3,anonymous_enum_1.STATS_READ_BYTES,,libvlc.h,STATS_READ_BYTES,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
828,88020,STATS_READ_PACKETS,3,anonymous_enum_1.STATS_READ_PACKETS,,libvlc.h,STATS_READ_PACKETS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
829,88021,STATS_DEMUX_READ,3,anonymous_enum_1.STATS_DEMUX_READ,,libvlc.h,STATS_DEMUX_READ,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
830,88022,STATS_DEMUX_BITRATE,3,anonymous_enum_1.STATS_DEMUX_BITRATE,,libvlc.h,STATS_DEMUX_BITRATE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
831,88023,STATS_DEMUX_CORRUPTED,3,anonymous_enum_1.STATS_DEMUX_CORRUPTED,,libvlc.h,STATS_DEMUX_CORRUPTED,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
832,88024,STATS_DEMUX_DISCONTINUITY,3,anonymous_enum_1.STATS_DEMUX_DISCONTINUITY,,libvlc.h,STATS_DEMUX_DISCONTINUITY,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
833,88025,STATS_PLAYED_ABUFFERS,3,anonymous_enum_1.STATS_PLAYED_ABUFFERS,,libvlc.h,STATS_PLAYED_ABUFFERS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
834,88026,STATS_LOST_ABUFFERS,3,anonymous_enum_1.STATS_LOST_ABUFFERS,,libvlc.h,STATS_LOST_ABUFFERS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
835,88027,STATS_DECODED_AUDIO,3,anonymous_enum_1.STATS_DECODED_AUDIO,,libvlc.h,STATS_DECODED_AUDIO,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
836,88028,STATS_DECODED_VIDEO,3,anonymous_enum_1.STATS_DECODED_VIDEO,,libvlc.h,STATS_DECODED_VIDEO,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
837,88029,STATS_DECODED_SUB,3,anonymous_enum_1.STATS_DECODED_SUB,,libvlc.h,STATS_DECODED_SUB,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
838,88030,STATS_CLIENT_CONNECTIONS,3,anonymous_enum_1.STATS_CLIENT_CONNECTIONS,,libvlc.h,STATS_CLIENT_CONNECTIONS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
839,88031,STATS_ACTIVE_CONNECTIONS,3,anonymous_enum_1.STATS_ACTIVE_CONNECTIONS,,libvlc.h,STATS_ACTIVE_CONNECTIONS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
840,88032,STATS_SOUT_SENT_PACKETS,3,anonymous_enum_1.STATS_SOUT_SENT_PACKETS,,libvlc.h,STATS_SOUT_SENT_PACKETS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
841,88033,STATS_SOUT_SENT_BYTES,3,anonymous_enum_1.STATS_SOUT_SENT_BYTES,,libvlc.h,STATS_SOUT_SENT_BYTES,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
842,88034,STATS_SOUT_SEND_BITRATE,3,anonymous_enum_1.STATS_SOUT_SEND_BITRATE,,libvlc.h,STATS_SOUT_SEND_BITRATE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
843,88035,STATS_DISPLAYED_PICTURES,3,anonymous_enum_1.STATS_DISPLAYED_PICTURES,,libvlc.h,STATS_DISPLAYED_PICTURES,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
844,88036,STATS_LOST_PICTURES,3,anonymous_enum_1.STATS_LOST_PICTURES,,libvlc.h,STATS_LOST_PICTURES,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
845,88742,psz,3,key_descriptor.psz,,misc\actions.c,psz[20],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
846,88743,i_code,3,key_descriptor.i_code,,misc\actions.c,i_code,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
847,89498,psz,3,name2action.psz,,misc\actions.c,psz[MAXACTION],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
848,89499,id,3,name2action.id,,misc\actions.c,id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
849,89846,key,3,mapping.key,,misc\actions.c,key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
850,89847,action,3,mapping.action,,misc\actions.c,action,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
851,89885,map,3,vlc_actions_t.map,,misc\actions.c,*map,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
852,89886,global_map,3,vlc_actions_t.global_map,,misc\actions.c,*global_map,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
853,89887,ppsz_keys,3,vlc_actions_t.ppsz_keys,,misc\actions.c,*ppsz_keys[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
854,90648,entry,3,addon_entry_owner.entry,,misc\addons.c,entry,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
855,90649,refs,3,addon_entry_owner.refs,,misc\addons.c,refs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
856,90652,p_parent,3,addons_manager_private_t.p_parent,,misc\addons.c,*p_parent,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
857,90654,thread,3,addons_manager_private_t.finder.thread,,misc\addons.c,thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
858,90655,waitcond,3,addons_manager_private_t.finder.waitcond,,misc\addons.c,waitcond,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
859,90656,b_live,3,addons_manager_private_t.finder.b_live,,misc\addons.c,b_live,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
860,90657,lock,3,addons_manager_private_t.finder.lock,,misc\addons.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
861,90658,p_interrupt,3,addons_manager_private_t.finder.p_interrupt,,misc\addons.c,*p_interrupt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
862,90665,,3,addons_manager_private_t.finder.nan,,misc\addons.c,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
863,90672,,3,addons_manager_private_t.finder.nan,,misc\addons.c,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
864,90673,finder,3,addons_manager_private_t.finder,,misc\addons.c,finder,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
865,90675,thread,3,addons_manager_private_t.installer.thread,,misc\addons.c,thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
866,90676,waitcond,3,addons_manager_private_t.installer.waitcond,,misc\addons.c,waitcond,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
867,90677,b_live,3,addons_manager_private_t.installer.b_live,,misc\addons.c,b_live,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
868,90678,lock,3,addons_manager_private_t.installer.lock,,misc\addons.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
869,90679,p_interrupt,3,addons_manager_private_t.installer.p_interrupt,,misc\addons.c,*p_interrupt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
870,90686,,3,addons_manager_private_t.installer.nan,,misc\addons.c,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
871,90687,installer,3,addons_manager_private_t.installer,,misc\addons.c,installer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
872,92620,id,3,bg_queued_item.id,,misc\background_worker.c,* id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
873,92621,entity,3,bg_queued_item.entity,,misc\background_worker.c,* entity,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
874,92622,timeout,3,bg_queued_item.timeout,,misc\background_worker.c,timeout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
875,92624,owner,3,background_worker.owner,,misc\background_worker.c,* owner,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
876,92626,conf,3,background_worker.conf,,misc\background_worker.c,conf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
877,92627,lock,3,background_worker.lock,,misc\background_worker.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,17,0,1,1,0,0,,0,0,0,0,0,
878,92629,probe_request,3,background_worker.head.probe_request,,misc\background_worker.c,probe_request,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
879,92630,wait,3,background_worker.head.wait,,misc\background_worker.c,wait,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
880,92631,worker_wait,3,background_worker.head.worker_wait,,misc\background_worker.c,worker_wait,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
881,92632,deadline,3,background_worker.head.deadline,,misc\background_worker.c,deadline,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
882,92633,id,3,background_worker.head.id,,misc\background_worker.c,* id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
883,92634,active,3,background_worker.head.active,,misc\background_worker.c,active,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
884,92635,head,3,background_worker.head,,misc\background_worker.c,head,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
885,92637,wait,3,background_worker.tail.wait,,misc\background_worker.c,wait,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
886,92638,data,3,background_worker.tail.data,,misc\background_worker.c,data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
887,92639,tail,3,background_worker.tail,,misc\background_worker.c,tail,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
888,93420,default_timeout,3,background_worker_config.default_timeout,,misc\background_worker.h,default_timeout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
889,97271,p_user_data,3,vlc_event_listener_t.p_user_data,,misc\events.c,*               p_user_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
890,97272,pf_callback,3,vlc_event_listener_t.pf_callback,,misc\events.c,pf_callback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
891,97668,lock,3,block_fifo_t.lock,,misc\fifo.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
892,97669,wait,3,block_fifo_t.wait,,misc\fifo.c,wait,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
893,97670,p_first,3,block_fifo_t.p_first,,misc\fifo.c,*p_first,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
894,97671,pp_last,3,block_fifo_t.pp_last,,misc\fifo.c,**pp_last,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
895,97672,i_depth,3,block_fifo_t.i_depth,,misc\fifo.c,i_depth,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
896,97673,i_size,3,block_fifo_t.i_size,,misc\fifo.c,i_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
897,98768,filter,3,chained_filter_t.filter,,misc\filter_chain.c,filter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
898,98770,prev,3,chained_filter_t.prev,,misc\filter_chain.c,*prev,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
899,98771,next,3,chained_filter_t.next,,misc\filter_chain.c,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
900,98772,mouse,3,chained_filter_t.mouse,,misc\filter_chain.c,*mouse,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
901,98773,pending,3,chained_filter_t.pending,,misc\filter_chain.c,*pending,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
902,98786,callbacks,3,filter_chain_t.callbacks,,misc\filter_chain.c,callbacks,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
903,98787,owner,3,filter_chain_t.owner,,misc\filter_chain.c,owner,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
904,98788,first,3,filter_chain_t.first,,misc\filter_chain.c,*first,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
905,98789,last,3,filter_chain_t.last,,misc\filter_chain.c,*last,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
906,98790,fmt_in,3,filter_chain_t.fmt_in,,misc\filter_chain.c,fmt_in,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
907,98791,fmt_out,3,filter_chain_t.fmt_out,,misc\filter_chain.c,fmt_out,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
908,98792,b_allow_fmt_out_change,3,filter_chain_t.b_allow_fmt_out_change,,misc\filter_chain.c,b_allow_fmt_out_change,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
909,98793,filter_cap,3,filter_chain_t.filter_cap,,misc\filter_chain.c,*filter_cap,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
910,98794,conv_cap,3,filter_chain_t.conv_cap,,misc\filter_chain.c,*conv_cap,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
911,102114,p_fourcc,3,p_list_chroma_description.p_fourcc,,misc\fourcc.c,p_fourcc[4],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
912,102115,description,3,p_list_chroma_description.description,,misc\fourcc.c,description,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
913,104852,num,3,vlc_rational_t.num,,misc\fourcc_gen.c,num,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
914,104853,den,3,vlc_rational_t.den,,misc\fourcc_gen.c,den,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
915,104856,klass,3,staticentry_t.klass,,misc\fourcc_gen.c,klass,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
916,104857,fourcc,3,staticentry_t.fourcc,,misc\fourcc_gen.c,fourcc[4],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
917,104858,description,3,staticentry_t.description,,misc\fourcc_gen.c,*description,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
918,104867,fourcc,3,entry.fourcc,,misc\fourcc_gen.c,fourcc[4],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
919,104868,alias,3,entry.alias,,misc\fourcc_gen.c,alias[4],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
920,104869,desc,3,entry.desc,,misc\fourcc_gen.c,*desc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
921,108245,psz_name,3,http_cookie_t.psz_name,,misc\httpcookies.c,*psz_name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
922,108246,psz_value,3,http_cookie_t.psz_value,,misc\httpcookies.c,*psz_value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
923,108247,psz_domain,3,http_cookie_t.psz_domain,,misc\httpcookies.c,*psz_domain,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
924,108248,psz_path,3,http_cookie_t.psz_path,,misc\httpcookies.c,*psz_path,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
925,108249,b_host_only,3,http_cookie_t.b_host_only,,misc\httpcookies.c,b_host_only,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
926,108250,b_secure,3,http_cookie_t.b_secure,,misc\httpcookies.c,b_secure,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
927,108943,cookies,3,vlc_http_cookie_jar_t.cookies,,misc\httpcookies.c,cookies,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
928,108944,lock,3,vlc_http_cookie_jar_t.lock,,misc\httpcookies.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
929,111176,i_codec,3,ext_table.i_codec,,misc\image.c,i_codec,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
930,111177,psz_ext,3,ext_table.psz_ext,,misc\image.c,psz_ext[7],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
931,111328,i_codec,3,mime_table.i_codec,,misc\image.c,i_codec,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
932,111329,psz_mime,3,mime_table.psz_mime,,misc\image.c,*psz_mime,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
933,113376,lock,3,vlc_interrupt.lock,,misc\interrupt.h,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
934,113377,interrupted,3,vlc_interrupt.interrupted,,misc\interrupt.h,interrupted,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
935,113378,killed,3,vlc_interrupt.killed,,misc\interrupt.h,killed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
936,113384,data,3,vlc_interrupt.data,,misc\interrupt.h,*data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
937,113857,psz_protocol,3,protocol_default_ports.psz_protocol,,misc\keystore.c,*    psz_protocol,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
938,113858,i_port,3,protocol_default_ports.i_port,,misc\keystore.c,i_port,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
939,118028,lock,3,vlc_logger_t.lock,,misc\messages.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
940,118029,log,3,vlc_logger_t.log,,misc\messages.c,log,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
941,118030,sys,3,vlc_logger_t.sys,,misc\messages.c,*sys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
942,118031,module,3,vlc_logger_t.module,,misc\messages.c,*module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
943,118306,next,3,vlc_log_early_t.next,,misc\messages.c,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
944,118307,type,3,vlc_log_early_t.type,,misc\messages.c,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
945,118308,meta,3,vlc_log_early_t.meta,,misc\messages.c,meta,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
946,118309,msg,3,vlc_log_early_t.msg,,misc\messages.c,*msg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
947,118312,lock,3,vlc_logger_early_t.lock,,misc\messages.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
948,118313,head,3,vlc_logger_early_t.head,,misc\messages.c,*head,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
949,118314,tailp,3,vlc_logger_early_t.tailp,,misc\messages.c,**tailp,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
950,119011,psz_ext,3,ext_mime.psz_ext,,misc\mime.c,psz_ext[8],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
951,119012,psz_mime,3,ext_mime.psz_mime,,misc\mime.c,*psz_mime,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
952,121108,prev,3,vlc_res.prev,,misc\objres.c,*prev,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
953,121114,payload,3,vlc_res.payload,,misc\objres.c,payload[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
954,123148,picture,3,picture_priv_t.picture,,misc\picture.h,picture,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
955,123150,refs,3,picture_priv_t.gc.refs,,misc\picture.h,refs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
956,123156,opaque,3,picture_priv_t.gc.opaque,,misc\picture.h,*opaque,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
957,123157,gc,3,picture_priv_t.gc,,misc\picture.h,gc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
958,123173,lock,3,picture_fifo_t.lock,,misc\picture_fifo.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
959,123174,first,3,picture_fifo_t.first,,misc\picture_fifo.c,*first,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
960,123175,last_ptr,3,picture_fifo_t.last_ptr,,misc\picture_fifo.c,**last_ptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
961,123527,lock,3,picture_pool_t.lock,,misc\picture_pool.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,17,0,1,1,0,0,,0,0,0,0,0,
962,123528,wait,3,picture_pool_t.wait,,misc\picture_pool.c,wait,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
963,123529,canceled,3,picture_pool_t.canceled,,misc\picture_pool.c,canceled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
964,123530,available,3,picture_pool_t.available,,misc\picture_pool.c,available,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
965,123531,refs,3,picture_pool_t.refs,,misc\picture_pool.c,refs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
966,123532,picture_count,3,picture_pool_t.picture_count,,misc\picture_pool.c,picture_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
967,123533,picture,3,picture_pool_t.picture,,misc\picture_pool.c,*picture[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
968,124665,init,3,rand48.init,,misc\rand.c,init,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
969,124666,subi,3,rand48.subi,,misc\rand.c,subi[3],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
970,124667,lock,3,rand48.lock,,misc\rand.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
971,124805,psz_name,3,vlc_renderer_item_t.psz_name,,misc\renderer_discovery.c,*psz_name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
972,124806,psz_type,3,vlc_renderer_item_t.psz_type,,misc\renderer_discovery.c,*psz_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
973,124807,psz_sout,3,vlc_renderer_item_t.psz_sout,,misc\renderer_discovery.c,*psz_sout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
974,124808,psz_icon_uri,3,vlc_renderer_item_t.psz_icon_uri,,misc\renderer_discovery.c,*psz_icon_uri,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
975,124809,psz_demux_filter,3,vlc_renderer_item_t.psz_demux_filter,,misc\renderer_discovery.c,*psz_demux_filter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
976,124810,i_flags,3,vlc_renderer_item_t.i_flags,,misc\renderer_discovery.c,i_flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
977,124811,refs,3,vlc_renderer_item_t.refs,,misc\renderer_discovery.c,refs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
978,125158,psz_name,3,vlc_rd_probe.psz_name,,misc\renderer_discovery.c,*psz_name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
979,125159,psz_longname,3,vlc_rd_probe.psz_longname,,misc\renderer_discovery.c,*psz_longname,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
980,125436,src,3,subpicture_private_t.src,,misc\subpicture.c,src,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
981,125437,dst,3,subpicture_private_t.dst,,misc\subpicture.c,dst,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
982,126314,fmt,3,subpicture_region_private_t.fmt,,misc\subpicture.h,fmt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
983,126315,p_picture,3,subpicture_region_private_t.p_picture,,misc\subpicture.h,*p_picture,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
984,129269,SIGNATURE_PACKET,3,anonymous_enum_0.SIGNATURE_PACKET,,misc\update.h,SIGNATURE_PACKET    = 0x02,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
985,129270,PUBLIC_KEY_PACKET,3,anonymous_enum_0.PUBLIC_KEY_PACKET,,misc\update.h,PUBLIC_KEY_PACKET   = 0x06,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
986,129271,USER_ID_PACKET,3,anonymous_enum_0.USER_ID_PACKET,,misc\update.h,USER_ID_PACKET      = 0x0d,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
987,129286,BINARY_SIGNATURE,3,anonymous_enum_1.BINARY_SIGNATURE,,misc\update.h,BINARY_SIGNATURE        = 0x00,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
988,129287,TEXT_SIGNATURE,3,anonymous_enum_1.TEXT_SIGNATURE,,misc\update.h,TEXT_SIGNATURE          = 0x01,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
989,129288,GENERIC_KEY_SIGNATURE,3,anonymous_enum_1.GENERIC_KEY_SIGNATURE,,misc\update.h,GENERIC_KEY_SIGNATURE   = 0x10,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
990,129289,PERSONA_KEY_SIGNATURE,3,anonymous_enum_1.PERSONA_KEY_SIGNATURE,,misc\update.h,PERSONA_KEY_SIGNATURE   = 0x11,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
991,129290,CASUAL_KEY_SIGNATURE,3,anonymous_enum_1.CASUAL_KEY_SIGNATURE,,misc\update.h,CASUAL_KEY_SIGNATURE    = 0x12,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
992,129291,POSITIVE_KEY_SIGNATURE,3,anonymous_enum_1.POSITIVE_KEY_SIGNATURE,,misc\update.h,POSITIVE_KEY_SIGNATURE  = 0x13,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
993,129315,ISSUER_SUBPACKET,3,anonymous_enum_2.ISSUER_SUBPACKET,,misc\update.h,ISSUER_SUBPACKET    = 0x10,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
994,129324,version,3,public_key_packet_t.version,,misc\update.h,version,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
995,129325,timestamp,3,public_key_packet_t.timestamp,,misc\update.h,timestamp[4],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
996,129326,algo,3,public_key_packet_t.algo,,misc\update.h,algo,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
997,129329,p,3,public_key_packet_t.sig.dsa.p,,misc\update.h,p[2+3072/8],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
998,129330,q,3,public_key_packet_t.sig.dsa.q,,misc\update.h,q[2+256/8],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
999,129331,g,3,public_key_packet_t.sig.dsa.g,,misc\update.h,g[2+3072/8],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1000,129332,y,3,public_key_packet_t.sig.dsa.y,,misc\update.h,y[2+3072/8],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1001,129361,dsa,3,public_key_packet_t.sig.dsa,,misc\update.h,dsa,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1002,129363,n,3,public_key_packet_t.sig.rsa.n,,misc\update.h,n[2+4096/8],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1003,129364,e,3,public_key_packet_t.sig.rsa.e,,misc\update.h,e[2+4096/8],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1004,129381,rsa,3,public_key_packet_t.sig.rsa,,misc\update.h,rsa,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1005,129382,sig,3,public_key_packet_t.sig,,misc\update.h,sig,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,20,0,1,1,0,0,,0,0,0,0,0,
1006,129390,version,3,signature_packet_t.version,,misc\update.h,version,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1007,129391,type,3,signature_packet_t.type,,misc\update.h,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1008,129392,public_key_algo,3,signature_packet_t.public_key_algo,,misc\update.h,public_key_algo,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1009,129393,digest_algo,3,signature_packet_t.digest_algo,,misc\update.h,digest_algo,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1010,129394,hash_verification,3,signature_packet_t.hash_verification,,misc\update.h,hash_verification[2],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1011,129395,issuer_longid,3,signature_packet_t.issuer_longid,,misc\update.h,issuer_longid[8],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1012,129398,hashed_data_len,3,signature_packet_t.specific.v4.hashed_data_len,,misc\update.h,hashed_data_len[2],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1013,129399,hashed_data,3,signature_packet_t.specific.v4.hashed_data,,misc\update.h,*hashed_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1014,129400,unhashed_data_len,3,signature_packet_t.specific.v4.unhashed_data_len,,misc\update.h,unhashed_data_len[2],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1015,129401,unhashed_data,3,signature_packet_t.specific.v4.unhashed_data,,misc\update.h,*unhashed_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1016,129410,v4,3,signature_packet_t.specific.v4,,misc\update.h,v4,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1017,129412,hashed_data_len,3,signature_packet_t.specific.v3.hashed_data_len,,misc\update.h,hashed_data_len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1018,129413,timestamp,3,signature_packet_t.specific.v3.timestamp,,misc\update.h,timestamp[4],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1019,129420,v3,3,signature_packet_t.specific.v3,,misc\update.h,v3,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1020,129421,specific,3,signature_packet_t.specific,,misc\update.h,specific,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,20,0,1,1,0,0,,0,0,0,0,0,
1021,129424,r,3,signature_packet_t.algo_specific.dsa.r,,misc\update.h,r[2+256/8],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1022,129425,s,3,signature_packet_t.algo_specific.dsa.s,,misc\update.h,s[2+256/8],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1023,129442,dsa,3,signature_packet_t.algo_specific.dsa,,misc\update.h,dsa,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1024,129444,s,3,signature_packet_t.algo_specific.rsa.s,,misc\update.h,s[2+4096/8],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1025,129455,rsa,3,signature_packet_t.algo_specific.rsa,,misc\update.h,rsa,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1026,129456,algo_specific,3,signature_packet_t.algo_specific,,misc\update.h,algo_specific,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1027,129470,longid,3,public_key_t.longid,,misc\update.h,longid[8],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1028,129471,psz_username,3,public_key_t.psz_username,,misc\update.h,*psz_username,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1029,129472,key,3,public_key_t.key,,misc\update.h,key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1030,129473,sig,3,public_key_t.sig,,misc\update.h,sig,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1031,129485,thread,3,update_download_thread_t.thread,,misc\update.h,thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1032,129486,aborted,3,update_download_thread_t.aborted,,misc\update.h,aborted,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1033,129487,p_update,3,update_download_thread_t.p_update,,misc\update.h,*p_update,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1034,129488,psz_destdir,3,update_download_thread_t.psz_destdir,,misc\update.h,*psz_destdir,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1035,129491,thread,3,update_check_thread_t.thread,,misc\update.h,thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1036,129492,p_update,3,update_check_thread_t.p_update,,misc\update.h,*p_update,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1037,129499,p_data,3,update_check_thread_t.p_data,,misc\update.h,*p_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1038,129502,p_libvlc,3,update_t.p_libvlc,,misc\update.h,*p_libvlc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,20,0,1,1,0,0,,0,0,0,0,0,
1039,129503,lock,3,update_t.lock,,misc\update.h,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1040,129505,release,3,update_t.release,,misc\update.h,release,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,25,0,1,1,0,0,,0,0,0,0,0,
1041,129506,p_pkey,3,update_t.p_pkey,,misc\update.h,*p_pkey,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
1042,129507,p_download,3,update_t.p_download,,misc\update.h,*p_download,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
1043,129508,p_check,3,update_t.p_check,,misc\update.h,*p_check,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1044,133440,pf_value_callback,3,callback_entry_t.anonymous_composite_type_0.pf_value_callback,,misc\variables.c,pf_value_callback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1045,133441,pf_list_callback,3,callback_entry_t.anonymous_composite_type_0.pf_list_callback,,misc\variables.c,pf_list_callback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1046,133442,p_callback,3,callback_entry_t.anonymous_composite_type_0.p_callback,,misc\variables.c,*               p_callback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1047,133443,p_data,3,callback_entry_t.p_data,,misc\variables.c,*         p_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1048,133464,i_entries,3,callback_table_t.i_entries,,misc\variables.c,i_entries,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1049,133465,p_entries,3,callback_table_t.p_entries,,misc\variables.c,* p_entries,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1050,133468,psz_name,3,variable_t.psz_name,,misc\variables.c,*       psz_name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1051,133469,val,3,variable_t.val,,misc\variables.c,val,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,27,0,1,1,0,0,,0,0,0,0,0,
1052,133470,psz_text,3,variable_t.psz_text,,misc\variables.c,*       psz_text,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1053,133471,ops,3,variable_t.ops,,misc\variables.c,*ops,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,17,0,1,1,0,0,,0,0,0,0,0,
1054,133472,i_type,3,variable_t.i_type,,misc\variables.c,i_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,17,0,1,1,0,0,,0,0,0,0,0,
1055,133473,i_usage,3,variable_t.i_usage,,misc\variables.c,i_usage,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1056,133474,min,3,variable_t.min,,misc\variables.c,min,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1057,133475,max,3,variable_t.max,,misc\variables.c,max,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1058,133476,step,3,variable_t.step,,misc\variables.c,step,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
1059,133477,choices,3,variable_t.choices,,misc\variables.c,choices,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,24,0,1,1,0,0,,0,0,0,0,0,
1060,133478,choices_text,3,variable_t.choices_text,,misc\variables.c,choices_text,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
1061,133479,b_incallback,3,variable_t.b_incallback,,misc\variables.c,b_incallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1062,133480,value_callbacks,3,variable_t.value_callbacks,,misc\variables.c,value_callbacks,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1063,133481,list_callbacks,3,variable_t.list_callbacks,,misc\variables.c,list_callbacks,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1064,135990,vlc_value_callback,3,vlc_callback_type_t.vlc_value_callback,,misc\variables.c,vlc_value_callback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1065,135991,vlc_list_callback,3,vlc_callback_type_t.vlc_list_callback,,misc\variables.c,vlc_list_callback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1066,137403,,3,vlc_object_internals.nan,,misc\variables.h,(max_align_t),-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1067,137405,psz_name,3,vlc_object_internals.psz_name,,misc\variables.h,*psz_name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1068,137406,var_root,3,vlc_object_internals.var_root,,misc\variables.h,*var_root,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1069,137407,var_lock,3,vlc_object_internals.var_lock,,misc\variables.h,var_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1070,137408,var_wait,3,vlc_object_internals.var_wait,,misc\variables.h,var_wait,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1071,137409,refs,3,vlc_object_internals.refs,,misc\variables.h,refs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1072,137410,pf_destructor,3,vlc_object_internals.pf_destructor,,misc\variables.h,pf_destructor,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1073,137411,next,3,vlc_object_internals.next,,misc\variables.h,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1074,137412,prev,3,vlc_object_internals.prev,,misc\variables.h,*prev,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1075,137413,first,3,vlc_object_internals.first,,misc\variables.h,*first,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1076,137414,tree_lock,3,vlc_object_internals.tree_lock,,misc\variables.h,tree_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1077,137416,resources,3,vlc_object_internals.resources,,misc\variables.h,*resources,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1078,138114,name,3,vlc_modcap.name,,modules\bank.c,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1079,138115,modv,3,vlc_modcap.modv,,modules\bank.c,**modv,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1080,138116,modc,3,vlc_modcap.modc,,modules\bank.c,modc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1081,138226,lock,3,modules.lock,,modules\bank.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1082,138227,caches,3,modules.caches,,modules\bank.c,*caches,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1083,138228,caps_tree,3,modules.caps_tree,,modules\bank.c,*caps_tree,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1084,138229,usage,3,modules.usage,,modules\bank.c,usage,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1085,139952,name,3,vlc_plugin_symbol.name,,modules\entry.c,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1086,139953,addr,3,vlc_plugin_symbol.addr,,modules\entry.c,*addr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1087,141179,next,3,vlc_plugin_t.next,,modules\modules.h,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1088,141180,module,3,vlc_plugin_t.module,,modules\modules.h,*module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1089,141181,modules_count,3,vlc_plugin_t.modules_count,,modules\modules.h,modules_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1090,141182,textdomain,3,vlc_plugin_t.textdomain,,modules\modules.h,*textdomain,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1091,141184,items,3,vlc_plugin_t.conf.items,,modules\modules.h,*items,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1092,141185,size,3,vlc_plugin_t.conf.size,,modules\modules.h,size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1093,141186,count,3,vlc_plugin_t.conf.count,,modules\modules.h,count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1094,141187,booleans,3,vlc_plugin_t.conf.booleans,,modules\modules.h,booleans,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1095,141188,conf,3,vlc_plugin_t.conf,,modules\modules.h,conf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,18,0,1,1,0,0,,0,0,0,0,0,
1096,141189,loaded,3,vlc_plugin_t.loaded,,modules\modules.h,loaded,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1097,141190,unloadable,3,vlc_plugin_t.unloadable,,modules\modules.h,unloadable,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1098,141191,handle,3,vlc_plugin_t.handle,,modules\modules.h,handle,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1099,141192,abspath,3,vlc_plugin_t.abspath,,modules\modules.h,*abspath,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1100,141193,path,3,vlc_plugin_t.path,,modules\modules.h,*path,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1101,141194,mtime,3,vlc_plugin_t.mtime,,modules\modules.h,mtime,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1102,141195,size,3,vlc_plugin_t.size,,modules\modules.h,size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1103,141212,plugin,3,module_t.plugin,,modules\modules.h,*plugin,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1104,141213,next,3,module_t.next,,modules\modules.h,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1105,141214,i_shortcuts,3,module_t.i_shortcuts,,modules\modules.h,i_shortcuts,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
1106,141215,pp_shortcuts,3,module_t.pp_shortcuts,,modules\modules.h,**pp_shortcuts,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
1107,141216,psz_shortname,3,module_t.psz_shortname,,modules\modules.h,*psz_shortname,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1108,141217,psz_longname,3,module_t.psz_longname,,modules\modules.h,*psz_longname,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1109,141218,psz_help,3,module_t.psz_help,,modules\modules.h,*psz_help,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1110,141219,psz_capability,3,module_t.psz_capability,,modules\modules.h,*psz_capability,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1111,141220,i_score,3,module_t.i_score,,modules\modules.h,i_score,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1112,141221,activate_name,3,module_t.activate_name,,modules\modules.h,*activate_name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1113,141222,deactivate_name,3,module_t.deactivate_name,,modules\modules.h,*deactivate_name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1114,141223,pf_activate,3,module_t.pf_activate,,modules\modules.h,*pf_activate,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1115,141224,pf_deactivate,3,module_t.pf_deactivate,,modules\modules.h,*pf_deactivate,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1116,142848,i_ref,3,httpd_host_t.i_ref,,network\httpd.c,i_ref,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1117,142849,fds,3,httpd_host_t.fds,,network\httpd.c,*fds,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1118,142850,nfd,3,httpd_host_t.nfd,,network\httpd.c,nfd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1119,142851,port,3,httpd_host_t.port,,network\httpd.c,port,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1120,142852,thread,3,httpd_host_t.thread,,network\httpd.c,thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1121,142853,lock,3,httpd_host_t.lock,,network\httpd.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
1122,142854,wait,3,httpd_host_t.wait,,network\httpd.c,wait,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1123,142855,i_url,3,httpd_host_t.i_url,,network\httpd.c,i_url,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1124,142856,url,3,httpd_host_t.url,,network\httpd.c,**url,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1125,142857,b_no_timeout,3,httpd_host_t.b_no_timeout,,network\httpd.c,b_no_timeout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1126,142858,i_client,3,httpd_host_t.i_client,,network\httpd.c,i_client,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1127,142859,client,3,httpd_host_t.client,,network\httpd.c,**client,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1128,142860,timeout_sec,3,httpd_host_t.timeout_sec,,network\httpd.c,timeout_sec,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1129,142861,p_tls,3,httpd_host_t.p_tls,,network\httpd.c,*p_tls,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1130,142863,host,3,httpd_url_t.host,,network\httpd.c,*host,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1131,142864,lock,3,httpd_url_t.lock,,network\httpd.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1132,142865,psz_url,3,httpd_url_t.psz_url,,network\httpd.c,*psz_url,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1133,142866,psz_user,3,httpd_url_t.psz_user,,network\httpd.c,*psz_user,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1134,142867,psz_password,3,httpd_url_t.psz_password,,network\httpd.c,*psz_password,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1135,142869,cb,3,httpd_url_t.catch.cb,,network\httpd.c,cb,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1136,142870,p_sys,3,httpd_url_t.catch.p_sys,,network\httpd.c,*p_sys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1137,142871,catch,3,httpd_url_t.catch,,network\httpd.c,catch[HTTPD_MSG_MAX],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1138,142879,HTTPD_CLIENT_RECEIVING,3,anonymous_enum_0.HTTPD_CLIENT_RECEIVING,,network\httpd.c,HTTPD_CLIENT_RECEIVING,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1139,142880,HTTPD_CLIENT_RECEIVE_DONE,3,anonymous_enum_0.HTTPD_CLIENT_RECEIVE_DONE,,network\httpd.c,HTTPD_CLIENT_RECEIVE_DONE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1140,142881,HTTPD_CLIENT_SENDING,3,anonymous_enum_0.HTTPD_CLIENT_SENDING,,network\httpd.c,HTTPD_CLIENT_SENDING,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1141,142882,HTTPD_CLIENT_SEND_DONE,3,anonymous_enum_0.HTTPD_CLIENT_SEND_DONE,,network\httpd.c,HTTPD_CLIENT_SEND_DONE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1142,142883,HTTPD_CLIENT_WAITING,3,anonymous_enum_0.HTTPD_CLIENT_WAITING,,network\httpd.c,HTTPD_CLIENT_WAITING,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1143,142884,HTTPD_CLIENT_DEAD,3,anonymous_enum_0.HTTPD_CLIENT_DEAD,,network\httpd.c,HTTPD_CLIENT_DEAD,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1144,142885,HTTPD_CLIENT_TLS_HS_IN,3,anonymous_enum_0.HTTPD_CLIENT_TLS_HS_IN,,network\httpd.c,HTTPD_CLIENT_TLS_HS_IN,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1145,142886,HTTPD_CLIENT_TLS_HS_OUT,3,anonymous_enum_0.HTTPD_CLIENT_TLS_HS_OUT,,network\httpd.c,HTTPD_CLIENT_TLS_HS_OUT,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1146,142888,url,3,httpd_client_t.url,,network\httpd.c,*url,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
1147,142889,sock,3,httpd_client_t.sock,,network\httpd.c,*sock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1148,142890,i_ref,3,httpd_client_t.i_ref,,network\httpd.c,i_ref,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1149,142891,b_stream_mode,3,httpd_client_t.b_stream_mode,,network\httpd.c,b_stream_mode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1150,142892,i_state,3,httpd_client_t.i_state,,network\httpd.c,i_state,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,18,0,1,1,0,0,,0,0,0,0,0,
1151,142893,i_timeout_date,3,httpd_client_t.i_timeout_date,,network\httpd.c,i_timeout_date,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1152,142894,i_buffer_size,3,httpd_client_t.i_buffer_size,,network\httpd.c,i_buffer_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
1153,142895,i_buffer,3,httpd_client_t.i_buffer,,network\httpd.c,i_buffer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
1154,142896,p_buffer,3,httpd_client_t.p_buffer,,network\httpd.c,*p_buffer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
1155,142897,i_keyframe_wait_to_pass,3,httpd_client_t.i_keyframe_wait_to_pass,,network\httpd.c,i_keyframe_wait_to_pass,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1156,142898,query,3,httpd_client_t.query,,network\httpd.c,query,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,19,0,1,1,0,0,,0,0,0,0,0,
1157,142899,answer,3,httpd_client_t.answer,,network\httpd.c,answer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,31,0,1,1,0,0,,0,0,0,0,0,
1158,143077,url,3,httpd_file_t.url,,network\httpd.c,*url,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1159,143078,pf_fill,3,httpd_file_t.pf_fill,,network\httpd.c,pf_fill,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1160,143079,p_sys,3,httpd_file_t.p_sys,,network\httpd.c,*p_sys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1161,143080,mime,3,httpd_file_t.mime,,network\httpd.c,mime[1],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1162,143375,url,3,httpd_handler_t.url,,network\httpd.c,*url,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1163,143376,pf_fill,3,httpd_handler_t.pf_fill,,network\httpd.c,pf_fill,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1164,143377,p_sys,3,httpd_handler_t.p_sys,,network\httpd.c,*p_sys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1165,143782,url,3,httpd_redirect_t.url,,network\httpd.c,*url,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1166,143783,dst,3,httpd_redirect_t.dst,,network\httpd.c,dst[1],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1167,143991,lock,3,httpd_stream_t.lock,,network\httpd.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
1168,143992,url,3,httpd_stream_t.url,,network\httpd.c,*url,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1169,143993,psz_mime,3,httpd_stream_t.psz_mime,,network\httpd.c,*psz_mime,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1170,143994,p_header,3,httpd_stream_t.p_header,,network\httpd.c,*p_header,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1171,143995,i_header,3,httpd_stream_t.i_header,,network\httpd.c,i_header,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1172,143996,b_has_keyframes,3,httpd_stream_t.b_has_keyframes,,network\httpd.c,b_has_keyframes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1173,143997,i_last_keyframe_seen_pos,3,httpd_stream_t.i_last_keyframe_seen_pos,,network\httpd.c,i_last_keyframe_seen_pos,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1174,143998,i_buffer_size,3,httpd_stream_t.i_buffer_size,,network\httpd.c,i_buffer_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1175,143999,p_buffer,3,httpd_stream_t.p_buffer,,network\httpd.c,*p_buffer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1176,144000,i_buffer_pos,3,httpd_stream_t.i_buffer_pos,,network\httpd.c,i_buffer_pos,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1177,144001,i_buffer_last_pos,3,httpd_stream_t.i_buffer_last_pos,,network\httpd.c,i_buffer_last_pos,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1178,144002,i_http_headers,3,httpd_stream_t.i_http_headers,,network\httpd.c,i_http_headers,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1179,144003,p_http_headers,3,httpd_stream_t.p_http_headers,,network\httpd.c,* p_http_headers,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,17,0,1,1,0,0,,0,0,0,0,0,
1180,145006,mutex,3,httpd.mutex,,network\httpd.c,mutex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1181,145007,host,3,httpd.host,,network\httpd.c,**host,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1182,145008,i_host,3,httpd.i_host,,network\httpd.c,i_host,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1183,146182,name,3,msg_type.name,,network\httpd.c,name[16],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1184,146183,i_type,3,msg_type.i_type,,network\httpd.c,i_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1185,146184,i_proto,3,msg_type.i_proto,,network\httpd.c,i_proto,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1186,152592,tls,3,vlc_tls_socket.tls,,network\tls.c,tls,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1187,152593,fd,3,vlc_tls_socket.fd,,network\tls.c,fd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1188,152594,peerlen,3,vlc_tls_socket.peerlen,,network\tls.c,peerlen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1189,152596,peer,3,vlc_tls_socket.peer,,network\tls.c,peer[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1190,156620,tid,3,vlc_thread.tid,,os2\thread.c,tid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1191,156621,cancel_event,3,vlc_thread.cancel_event,,os2\thread.c,cancel_event,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1192,156622,done_event,3,vlc_thread.done_event,,os2\thread.c,done_event,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1193,156623,cancel_sock,3,vlc_thread.cancel_sock,,os2\thread.c,cancel_sock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1194,156624,detached,3,vlc_thread.detached,,os2\thread.c,detached,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1195,156625,killable,3,vlc_thread.killable,,os2\thread.c,killable,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1196,156626,killed,3,vlc_thread.killed,,os2\thread.c,killed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1197,156627,cleaners,3,vlc_thread.cleaners,,os2\thread.c,*cleaners,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1198,156633,data,3,vlc_thread.data,,os2\thread.c,*data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1199,157006,condvar,3,vlc_static_cond_t.condvar,,os2\thread.c,condvar,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1200,157007,next,3,vlc_static_cond_t.next,,os2\thread.c,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1201,157411,id,3,vlc_threadvar.id,,os2\thread.c,id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1202,157418,prev,3,vlc_threadvar.prev,,os2\thread.c,*prev,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1203,157420,next,3,vlc_threadvar.next,,os2\thread.c,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1204,158661,tid,3,vlc_timer.tid,,os2\thread.c,tid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1205,158662,hev,3,vlc_timer.hev,,os2\thread.c,hev,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1206,158663,htimer,3,vlc_timer.htimer,,os2\thread.c,htimer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1207,158664,interval,3,vlc_timer.interval,,os2\thread.c,interval,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1208,158665,quit,3,vlc_timer.quit,,os2\thread.c,quit,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1209,158671,data,3,vlc_timer.data,,os2\thread.c,*data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1210,161877,local,3,playlist_fetcher_t.local,,playlist\fetcher.c,* local,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1211,161879,network,3,playlist_fetcher_t.network,,playlist\fetcher.c,* network,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1212,161881,downloader,3,playlist_fetcher_t.downloader,,playlist\fetcher.c,* downloader,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1213,161882,album_cache,3,playlist_fetcher_t.album_cache,,playlist\fetcher.c,album_cache,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1214,161883,owner,3,playlist_fetcher_t.owner,,playlist\fetcher.c,* owner,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1215,161884,lock,3,playlist_fetcher_t.lock,,playlist\fetcher.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1216,161886,item,3,fetcher_request.item,,playlist\fetcher.c,* item,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
1217,161887,refs,3,fetcher_request.refs,,playlist\fetcher.c,refs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1218,161888,preparse_status,3,fetcher_request.preparse_status,,playlist\fetcher.c,preparse_status,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1219,161889,options,3,fetcher_request.options,,playlist\fetcher.c,options,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1220,161898,worker,3,fetcher_thread.worker,,playlist\fetcher.c,* worker,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1221,161900,req,3,fetcher_thread.req,,playlist\fetcher.c,* req,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1222,161901,fetcher,3,fetcher_thread.fetcher,,playlist\fetcher.c,* fetcher,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1223,161902,interrupt,3,fetcher_thread.interrupt,,playlist\fetcher.c,interrupt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1224,161903,thread,3,fetcher_thread.thread,,playlist\fetcher.c,thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1225,161904,active,3,fetcher_thread.active,,playlist\fetcher.c,active,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1226,165500,public_data,3,playlist_private_t.public_data,,playlist\playlist_internal.h,public_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1227,165502,interface,3,playlist_private_t.interface,,playlist\playlist_internal.h,*interface,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1228,165503,input_tree,3,playlist_private_t.input_tree,,playlist\playlist_internal.h,*input_tree,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1229,165504,id_tree,3,playlist_private_t.id_tree,,playlist\playlist_internal.h,*id_tree,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1230,165505,pp_sds,3,playlist_private_t.pp_sds,,playlist\playlist_internal.h,**pp_sds,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1231,165506,i_sds,3,playlist_private_t.i_sds,,playlist\playlist_internal.h,i_sds,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1232,165507,p_input,3,playlist_private_t.p_input,,playlist\playlist_internal.h,*      p_input,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1233,165508,p_input_resource,3,playlist_private_t.p_input_resource,,playlist\playlist_internal.h,*   p_input_resource,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1234,165509,p_renderer,3,playlist_private_t.p_renderer,,playlist\playlist_internal.h,*p_renderer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1235,165511,p_item,3,playlist_private_t.status.p_item,,playlist\playlist_internal.h,*   p_item,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1236,165512,p_node,3,playlist_private_t.status.p_node,,playlist\playlist_internal.h,*   p_node,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1237,165513,status,3,playlist_private_t.status,,playlist\playlist_internal.h,status,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1238,165515,p_node,3,playlist_private_t.request.p_node,,playlist\playlist_internal.h,*   p_node,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1239,165516,p_item,3,playlist_private_t.request.p_item,,playlist\playlist_internal.h,*   p_item,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1240,165517,i_skip,3,playlist_private_t.request.i_skip,,playlist\playlist_internal.h,i_skip,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1241,165518,b_request,3,playlist_private_t.request.b_request,,playlist\playlist_internal.h,b_request,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1242,165519,input_dead,3,playlist_private_t.request.input_dead,,playlist\playlist_internal.h,input_dead,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1243,165520,request,3,playlist_private_t.request,,playlist\playlist_internal.h,request,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1244,165521,thread,3,playlist_private_t.thread,,playlist\playlist_internal.h,thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1245,165522,lock,3,playlist_private_t.lock,,playlist\playlist_internal.h,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1246,165523,signal,3,playlist_private_t.signal,,playlist\playlist_internal.h,signal,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1247,165524,killed,3,playlist_private_t.killed,,playlist\playlist_internal.h,killed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1248,165525,cork_effective,3,playlist_private_t.cork_effective,,playlist\playlist_internal.h,cork_effective,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1249,165526,i_last_playlist_id,3,playlist_private_t.i_last_playlist_id,,playlist\playlist_internal.h,i_last_playlist_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1250,165527,b_reset_currently_playing,3,playlist_private_t.b_reset_currently_playing,,playlist\playlist_internal.h,b_reset_currently_playing,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1251,165528,i_consecutive_errors,3,playlist_private_t.i_consecutive_errors,,playlist\playlist_internal.h,i_consecutive_errors,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1252,165529,b_tree,3,playlist_private_t.b_tree,,playlist\playlist_internal.h,b_tree,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1253,165530,b_preparse,3,playlist_private_t.b_preparse,,playlist\playlist_internal.h,b_preparse,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1254,165686,owner,3,playlist_preparser_t.owner,,playlist\preparser.c,* owner,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1255,165687,fetcher,3,playlist_preparser_t.fetcher,,playlist\preparser.c,* fetcher,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1256,165689,worker,3,playlist_preparser_t.worker,,playlist\preparser.c,* worker,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1257,165690,deactivated,3,playlist_preparser_t.deactivated,,playlist\preparser.c,deactivated,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1258,166538,node,3,vlc_sd_internal_t.node,,playlist\services_discovery.c,*node,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1259,166539,sd,3,vlc_sd_internal_t.sd,,playlist\services_discovery.c,*sd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1260,166540,name,3,vlc_sd_internal_t.name,,playlist\services_discovery.c,name[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1261,171617,name,3,vlc_gai_req.name,,posix\getaddrinfo.c,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1262,171618,service,3,vlc_gai_req.service,,posix\getaddrinfo.c,*service,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1263,171620,hints,3,vlc_gai_req.hints,,posix\getaddrinfo.c,*hints,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1264,171622,result,3,vlc_gai_req.result,,posix\getaddrinfo.c,*result,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1265,171623,error,3,vlc_gai_req.error,,posix\getaddrinfo.c,error,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1266,171624,done,3,vlc_gai_req.done,,posix\getaddrinfo.c,done,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1267,173496,thread,3,vlc_timer.thread,,posix\timer.c,thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1268,173497,reschedule,3,vlc_timer.reschedule,,posix\timer.c,reschedule,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1269,173498,lock,3,vlc_timer.lock,,posix\timer.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1270,173504,data,3,vlc_timer.data,,posix\timer.c,*data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1271,173505,value,3,vlc_timer.value,,posix\timer.c,value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1272,173506,interval,3,vlc_timer.interval,,posix\timer.c,interval,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1273,173507,overruns,3,vlc_timer.overruns,,posix\timer.c,overruns,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1274,173888,next,3,session_descriptor_t.next,,stream_output\sap.c,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1275,173889,length,3,session_descriptor_t.length,,stream_output\sap.c,length,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1276,173890,data,3,session_descriptor_t.data,,stream_output\sap.c,*data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1277,173893,next,3,sap_address_t.next,,stream_output\sap.c,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1278,173894,thread,3,sap_address_t.thread,,stream_output\sap.c,thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1279,173895,lock,3,sap_address_t.lock,,stream_output\sap.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1280,173896,wait,3,sap_address_t.wait,,stream_output\sap.c,wait,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1281,173897,group,3,sap_address_t.group,,stream_output\sap.c,group[NI_MAXNUMERICHOST],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1282,173899,orig,3,sap_address_t.orig,,stream_output\sap.c,orig,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1283,173900,origlen,3,sap_address_t.origlen,,stream_output\sap.c,origlen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1284,173901,fd,3,sap_address_t.fd,,stream_output\sap.c,fd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1285,173902,interval,3,sap_address_t.interval,,stream_output\sap.c,interval,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1286,173903,session_count,3,sap_address_t.session_count,,stream_output\sap.c,session_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1287,173904,first,3,sap_address_t.first,,stream_output\sap.c,*first,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1288,175278,psz_access,3,mrl_t.psz_access,,stream_output\stream_output.c,*psz_access,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1289,175279,psz_way,3,mrl_t.psz_way,,stream_output\stream_output.c,*psz_way,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1290,175280,psz_name,3,mrl_t.psz_name,,stream_output\stream_output.c,*psz_name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1291,177291,p_sout,3,sout_packetizer_input_t.p_sout,,stream_output\stream_output.h,*p_sout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1292,177292,id,3,sout_packetizer_input_t.id,,stream_output\stream_output.h,*id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1293,179267,psz_entity,3,xml_entity_s.psz_entity,,text\strings.c,psz_entity[8],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1294,179268,psz_char,3,xml_entity_s.psz_char,,text\strings.c,psz_char[4],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1295,184896,shift,3,vout_chrono_t.shift,,video_output\chrono.h,shift,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1296,184897,avg,3,vout_chrono_t.avg,,video_output\chrono.h,avg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1297,184898,avg_initial,3,vout_chrono_t.avg_initial,,video_output\chrono.h,avg_initial,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1298,184899,shift_var,3,vout_chrono_t.shift_var,,video_output\chrono.h,shift_var,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1299,184900,var,3,vout_chrono_t.var,,video_output\chrono.h,var,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1300,184901,start,3,vout_chrono_t.start,,video_output\chrono.h,start,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1301,185677,VOUT_CONTROL_INIT,3,anonymous_enum_0.VOUT_CONTROL_INIT,,video_output\control.h,VOUT_CONTROL_INIT,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1302,185678,VOUT_CONTROL_CLEAN,3,anonymous_enum_0.VOUT_CONTROL_CLEAN,,video_output\control.h,VOUT_CONTROL_CLEAN,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1303,185679,VOUT_CONTROL_REINIT,3,anonymous_enum_0.VOUT_CONTROL_REINIT,,video_output\control.h,VOUT_CONTROL_REINIT,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1304,185680,VOUT_CONTROL_CANCEL,3,anonymous_enum_0.VOUT_CONTROL_CANCEL,,video_output\control.h,VOUT_CONTROL_CANCEL,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1305,185681,VOUT_CONTROL_SUBPICTURE,3,anonymous_enum_0.VOUT_CONTROL_SUBPICTURE,,video_output\control.h,VOUT_CONTROL_SUBPICTURE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1306,185682,VOUT_CONTROL_FLUSH_SUBPICTURE,3,anonymous_enum_0.VOUT_CONTROL_FLUSH_SUBPICTURE,,video_output\control.h,VOUT_CONTROL_FLUSH_SUBPICTURE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1307,185683,VOUT_CONTROL_OSD_TITLE,3,anonymous_enum_0.VOUT_CONTROL_OSD_TITLE,,video_output\control.h,VOUT_CONTROL_OSD_TITLE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1308,185684,VOUT_CONTROL_CHANGE_FILTERS,3,anonymous_enum_0.VOUT_CONTROL_CHANGE_FILTERS,,video_output\control.h,VOUT_CONTROL_CHANGE_FILTERS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1309,185685,VOUT_CONTROL_CHANGE_INTERLACE,3,anonymous_enum_0.VOUT_CONTROL_CHANGE_INTERLACE,,video_output\control.h,VOUT_CONTROL_CHANGE_INTERLACE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1310,185686,VOUT_CONTROL_CHANGE_SUB_SOURCES,3,anonymous_enum_0.VOUT_CONTROL_CHANGE_SUB_SOURCES,,video_output\control.h,VOUT_CONTROL_CHANGE_SUB_SOURCES,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1311,185687,VOUT_CONTROL_CHANGE_SUB_FILTERS,3,anonymous_enum_0.VOUT_CONTROL_CHANGE_SUB_FILTERS,,video_output\control.h,VOUT_CONTROL_CHANGE_SUB_FILTERS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1312,185688,VOUT_CONTROL_CHANGE_SUB_MARGIN,3,anonymous_enum_0.VOUT_CONTROL_CHANGE_SUB_MARGIN,,video_output\control.h,VOUT_CONTROL_CHANGE_SUB_MARGIN,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1313,185689,VOUT_CONTROL_PAUSE,3,anonymous_enum_0.VOUT_CONTROL_PAUSE,,video_output\control.h,VOUT_CONTROL_PAUSE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1314,185690,VOUT_CONTROL_FLUSH,3,anonymous_enum_0.VOUT_CONTROL_FLUSH,,video_output\control.h,VOUT_CONTROL_FLUSH,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1315,185691,VOUT_CONTROL_STEP,3,anonymous_enum_0.VOUT_CONTROL_STEP,,video_output\control.h,VOUT_CONTROL_STEP,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1316,185692,VOUT_CONTROL_FULLSCREEN,3,anonymous_enum_0.VOUT_CONTROL_FULLSCREEN,,video_output\control.h,VOUT_CONTROL_FULLSCREEN,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1317,185693,VOUT_CONTROL_WINDOW_STATE,3,anonymous_enum_0.VOUT_CONTROL_WINDOW_STATE,,video_output\control.h,VOUT_CONTROL_WINDOW_STATE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1318,185694,VOUT_CONTROL_WINDOW_MOUSE,3,anonymous_enum_0.VOUT_CONTROL_WINDOW_MOUSE,,video_output\control.h,VOUT_CONTROL_WINDOW_MOUSE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1319,185695,VOUT_CONTROL_DISPLAY_FILLED,3,anonymous_enum_0.VOUT_CONTROL_DISPLAY_FILLED,,video_output\control.h,VOUT_CONTROL_DISPLAY_FILLED,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1320,185696,VOUT_CONTROL_ZOOM,3,anonymous_enum_0.VOUT_CONTROL_ZOOM,,video_output\control.h,VOUT_CONTROL_ZOOM,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1321,185697,VOUT_CONTROL_ASPECT_RATIO,3,anonymous_enum_0.VOUT_CONTROL_ASPECT_RATIO,,video_output\control.h,VOUT_CONTROL_ASPECT_RATIO,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1322,185698,VOUT_CONTROL_CROP_BORDER,3,anonymous_enum_0.VOUT_CONTROL_CROP_BORDER,,video_output\control.h,VOUT_CONTROL_CROP_BORDER,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1323,185699,VOUT_CONTROL_CROP_RATIO,3,anonymous_enum_0.VOUT_CONTROL_CROP_RATIO,,video_output\control.h,VOUT_CONTROL_CROP_RATIO,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1324,185700,VOUT_CONTROL_CROP_WINDOW,3,anonymous_enum_0.VOUT_CONTROL_CROP_WINDOW,,video_output\control.h,VOUT_CONTROL_CROP_WINDOW,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1325,185701,VOUT_CONTROL_VIEWPOINT,3,anonymous_enum_0.VOUT_CONTROL_VIEWPOINT,,video_output\control.h,VOUT_CONTROL_VIEWPOINT,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1326,185703,type,3,vout_control_cmd_t.type,,video_output\control.h,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1327,185705,boolean,3,vout_control_cmd_t.u.boolean,,video_output\control.h,boolean,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1328,185706,time,3,vout_control_cmd_t.u.time,,video_output\control.h,time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1329,185707,time_ptr,3,vout_control_cmd_t.u.time_ptr,,video_output\control.h,*time_ptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1330,185708,string,3,vout_control_cmd_t.u.string,,video_output\control.h,*string,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1331,185709,integer,3,vout_control_cmd_t.u.integer,,video_output\control.h,integer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1332,185711,a,3,vout_control_cmd_t.u.pair.a,,video_output\control.h,a,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1333,185712,b,3,vout_control_cmd_t.u.pair.b,,video_output\control.h,b,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1334,185713,pair,3,vout_control_cmd_t.u.pair,,video_output\control.h,pair,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1335,185715,is_on,3,vout_control_cmd_t.u.pause.is_on,,video_output\control.h,is_on,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1336,185716,date,3,vout_control_cmd_t.u.pause.date,,video_output\control.h,date,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1337,185717,pause,3,vout_control_cmd_t.u.pause,,video_output\control.h,pause,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1338,185719,channel,3,vout_control_cmd_t.u.message.channel,,video_output\control.h,channel,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1339,185720,string,3,vout_control_cmd_t.u.message.string,,video_output\control.h,*string,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1340,185721,message,3,vout_control_cmd_t.u.message,,video_output\control.h,message,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1341,185723,left,3,vout_control_cmd_t.u.border.left,,video_output\control.h,left,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1342,185724,top,3,vout_control_cmd_t.u.border.top,,video_output\control.h,top,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1343,185725,right,3,vout_control_cmd_t.u.border.right,,video_output\control.h,right,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1344,185726,bottom,3,vout_control_cmd_t.u.border.bottom,,video_output\control.h,bottom,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1345,185727,border,3,vout_control_cmd_t.u.border,,video_output\control.h,border,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1346,185729,x,3,vout_control_cmd_t.u.window.x,,video_output\control.h,x,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1347,185730,y,3,vout_control_cmd_t.u.window.y,,video_output\control.h,y,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1348,185731,width,3,vout_control_cmd_t.u.window.width,,video_output\control.h,width,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1349,185732,height,3,vout_control_cmd_t.u.window.height,,video_output\control.h,height,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1350,185733,window,3,vout_control_cmd_t.u.window,,video_output\control.h,window,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1351,185734,window_mouse,3,vout_control_cmd_t.u.window_mouse,,video_output\control.h,window_mouse,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1352,185735,cfg,3,vout_control_cmd_t.u.cfg,,video_output\control.h,*cfg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1353,185736,subpicture,3,vout_control_cmd_t.u.subpicture,,video_output\control.h,*subpicture,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1354,185737,viewpoint,3,vout_control_cmd_t.u.viewpoint,,video_output\control.h,viewpoint,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1355,185738,u,3,vout_control_cmd_t.u,,video_output\control.h,u,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,61,0,1,1,0,0,,0,0,0,0,0,
1356,185752,lock,3,vout_control_t.lock,,video_output\control.h,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
1357,185753,wait_request,3,vout_control_t.wait_request,,video_output\control.h,wait_request,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1358,185754,wait_acknowledge,3,vout_control_t.wait_acknowledge,,video_output\control.h,wait_acknowledge,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1359,185755,is_dead,3,vout_control_t.is_dead,,video_output\control.h,is_dead,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1360,185756,can_sleep,3,vout_control_t.can_sleep,,video_output\control.h,can_sleep,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1361,185757,is_processing,3,vout_control_t.is_processing,,video_output\control.h,is_processing,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1362,187046,vout,3,vout_display_owner_sys_t.vout,,video_output\display.c,*vout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
1363,187047,is_splitter,3,vout_display_owner_sys_t.is_splitter,,video_output\display.c,is_splitter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1364,187048,cfg,3,vout_display_owner_sys_t.cfg,,video_output\display.c,cfg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
1365,187049,sar_initial,3,vout_display_owner_sys_t.sar_initial,,video_output\display.c,sar_initial,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1366,187050,is_display_filled,3,vout_display_owner_sys_t.is_display_filled,,video_output\display.c,is_display_filled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1367,187051,ch_zoom,3,vout_display_owner_sys_t.ch_zoom,,video_output\display.c,ch_zoom,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1368,187052,zoom,3,vout_display_owner_sys_t.zoom,,video_output\display.c,zoom,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1369,187053,width_saved,3,vout_display_owner_sys_t.width_saved,,video_output\display.c,width_saved,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1370,187054,height_saved,3,vout_display_owner_sys_t.height_saved,,video_output\display.c,height_saved,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1371,187055,ch_fullscreen,3,vout_display_owner_sys_t.ch_fullscreen,,video_output\display.c,ch_fullscreen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1372,187056,is_fullscreen,3,vout_display_owner_sys_t.is_fullscreen,,video_output\display.c,is_fullscreen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1373,187057,window_fullscreen,3,vout_display_owner_sys_t.window_fullscreen,,video_output\display.c,window_fullscreen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1374,187058,ch_wm_state,3,vout_display_owner_sys_t.ch_wm_state,,video_output\display.c,ch_wm_state,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1375,187059,wm_state,3,vout_display_owner_sys_t.wm_state,,video_output\display.c,wm_state,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1376,187060,wm_state_initial,3,vout_display_owner_sys_t.wm_state_initial,,video_output\display.c,wm_state_initial,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1377,187061,ch_sar,3,vout_display_owner_sys_t.ch_sar,,video_output\display.c,ch_sar,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1378,187062,sar,3,vout_display_owner_sys_t.sar,,video_output\display.c,sar,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
1379,187063,ch_crop,3,vout_display_owner_sys_t.ch_crop,,video_output\display.c,ch_crop,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1380,187065,left,3,vout_display_owner_sys_t.crop.left,,video_output\display.c,left,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1381,187066,top,3,vout_display_owner_sys_t.crop.top,,video_output\display.c,top,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1382,187067,right,3,vout_display_owner_sys_t.crop.right,,video_output\display.c,right,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1383,187068,bottom,3,vout_display_owner_sys_t.crop.bottom,,video_output\display.c,bottom,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1384,187069,num,3,vout_display_owner_sys_t.crop.num,,video_output\display.c,num,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1385,187070,den,3,vout_display_owner_sys_t.crop.den,,video_output\display.c,den,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1386,187071,crop,3,vout_display_owner_sys_t.crop,,video_output\display.c,crop,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1387,187072,ch_viewpoint,3,vout_display_owner_sys_t.ch_viewpoint,,video_output\display.c,ch_viewpoint,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1388,187073,viewpoint,3,vout_display_owner_sys_t.viewpoint,,video_output\display.c,viewpoint,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1389,187074,display_viewpoint,3,vout_display_owner_sys_t.display_viewpoint,,video_output\display.c,display_viewpoint,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1390,187075,source,3,vout_display_owner_sys_t.source,,video_output\display.c,source,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,36,0,1,1,0,0,,0,0,0,0,0,
1391,187076,filters,3,vout_display_owner_sys_t.filters,,video_output\display.c,*filters,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
1392,187077,lock,3,vout_display_owner_sys_t.lock,,video_output\display.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
1393,187079,state,3,vout_display_owner_sys_t.mouse.state,,video_output\display.c,state,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1394,187080,last_pressed,3,vout_display_owner_sys_t.mouse.last_pressed,,video_output\display.c,last_pressed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1395,187081,last_moved,3,vout_display_owner_sys_t.mouse.last_moved,,video_output\display.c,last_moved,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1396,187082,is_hidden,3,vout_display_owner_sys_t.mouse.is_hidden,,video_output\display.c,is_hidden,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1397,187083,ch_activity,3,vout_display_owner_sys_t.mouse.ch_activity,,video_output\display.c,ch_activity,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1398,187084,double_click_timeout,3,vout_display_owner_sys_t.mouse.double_click_timeout,,video_output\display.c,double_click_timeout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1399,187085,hide_timeout,3,vout_display_owner_sys_t.mouse.hide_timeout,,video_output\display.c,hide_timeout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1400,187086,mouse,3,vout_display_owner_sys_t.mouse,,video_output\display.c,mouse,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1401,187087,reset_pictures,3,vout_display_owner_sys_t.reset_pictures,,video_output\display.c,reset_pictures,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1402,187088,fit_window,3,vout_display_owner_sys_t.fit_window,,video_output\display.c,fit_window,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1403,187089,ch_display_size,3,vout_display_owner_sys_t.ch_display_size,,video_output\display.c,ch_display_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1404,187090,display_width,3,vout_display_owner_sys_t.display_width,,video_output\display.c,display_width,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1405,187091,display_height,3,vout_display_owner_sys_t.display_height,,video_output\display.c,display_height,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1406,190140,pool,3,vout_display_sys_t.pool,,video_output\display.c,*pool,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1407,190141,splitter,3,vout_display_sys_t.splitter,,video_output\display.c,*splitter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1408,190142,count,3,vout_display_sys_t.count,,video_output\display.c,count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1409,190143,picture,3,vout_display_sys_t.picture,,video_output\display.c,**picture,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
1410,190144,display,3,vout_display_sys_t.display,,video_output\display.c,**display,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1411,190146,wrapper,3,video_splitter_owner_t.wrapper,,video_output\display.c,*wrapper,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1412,191437,ih,3,inhibit_t.ih,,video_output\inhibit.c,ih,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1413,191438,module,3,inhibit_t.module,,video_output\inhibit.c,*module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1414,192155,gl,3,vlc_gl_priv_t.gl,,video_output\opengl.c,gl,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1415,192156,ref_count,3,vlc_gl_priv_t.ref_count,,video_output\opengl.c,ref_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1416,192306,width,3,vlc_gl_surface.width,,video_output\opengl.c,width,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1417,192307,height,3,vlc_gl_surface.height,,video_output\opengl.c,height,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1418,192308,lock,3,vlc_gl_surface.lock,,video_output\opengl.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1419,193128,lock,3,vout_snapshot_t.lock,,video_output\snapshot.h,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
1420,193129,wait,3,vout_snapshot_t.wait,,video_output\snapshot.h,wait,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1421,193130,is_available,3,vout_snapshot_t.is_available,,video_output\snapshot.h,is_available,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1422,193131,request_count,3,vout_snapshot_t.request_count,,video_output\snapshot.h,request_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1423,193132,picture,3,vout_snapshot_t.picture,,video_output\snapshot.h,*picture,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1424,193173,is_sequential,3,vout_snapshot_save_cfg_t.is_sequential,,video_output\snapshot.h,is_sequential,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1425,193174,sequence,3,vout_snapshot_save_cfg_t.sequence,,video_output\snapshot.h,sequence,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1426,193175,path,3,vout_snapshot_save_cfg_t.path,,video_output\snapshot.h,*path,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1427,193176,format,3,vout_snapshot_save_cfg_t.format,,video_output\snapshot.h,*format,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1428,193177,prefix_fmt,3,vout_snapshot_save_cfg_t.prefix_fmt,,video_output\snapshot.h,*prefix_fmt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1429,193196,displayed,3,vout_statistic_t.displayed,,video_output\statistic.h,displayed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1430,193197,lost,3,vout_statistic_t.lost,,video_output\statistic.h,lost,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1431,193299,epg,3,subpicture_updater_sys_t.epg,,video_output\video_epg.c,*epg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
1432,193300,time,3,subpicture_updater_sys_t.time,,video_output\video_epg.c,time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1433,193301,art,3,subpicture_updater_sys_t.art,,video_output\video_epg.c,*art,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1434,193302,obj,3,subpicture_updater_sys_t.obj,,video_output\video_epg.c,*obj,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1435,197866,name,3,vout_filter_t.name,,video_output\video_output.c,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1436,197867,cfg,3,vout_filter_t.cfg,,video_output\video_output.c,*cfg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1437,202019,position,3,subpicture_updater_sys_t.position,,video_output\video_text.c,position,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1438,202020,text,3,subpicture_updater_sys_t.text,,video_output\video_text.c,*text,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1439,203777,type,3,subpicture_updater_sys_t.type,,video_output\video_widgets.c,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1440,203778,position,3,subpicture_updater_sys_t.position,,video_output\video_widgets.c,position,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1441,204183,splitter_name,3,vout_thread_sys_t.splitter_name,,video_output\vout_internal.h,*splitter_name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1442,204184,input,3,vout_thread_sys_t.input,,video_output\vout_internal.h,*input,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1443,204185,original,3,vout_thread_sys_t.original,,video_output\vout_internal.h,original,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1444,204186,dpb_size,3,vout_thread_sys_t.dpb_size,,video_output\vout_internal.h,dpb_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1445,204187,snapshot,3,vout_thread_sys_t.snapshot,,video_output\vout_internal.h,snapshot,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1446,204188,statistic,3,vout_thread_sys_t.statistic,,video_output\vout_internal.h,statistic,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1447,204189,spu_lock,3,vout_thread_sys_t.spu_lock,,video_output\vout_internal.h,spu_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1448,204190,spu,3,vout_thread_sys_t.spu,,video_output\vout_internal.h,*spu,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1449,204191,spu_blend_chroma,3,vout_thread_sys_t.spu_blend_chroma,,video_output\vout_internal.h,spu_blend_chroma,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1450,204192,spu_blend,3,vout_thread_sys_t.spu_blend,,video_output\vout_internal.h,*spu_blend,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1451,204193,window,3,vout_thread_sys_t.window,,video_output\vout_internal.h,*window,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1452,204194,thread,3,vout_thread_sys_t.thread,,video_output\vout_internal.h,thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1453,204195,dead,3,vout_thread_sys_t.dead,,video_output\vout_internal.h,dead,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1454,204196,control,3,vout_thread_sys_t.control,,video_output\vout_internal.h,control,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1455,204198,title,3,vout_thread_sys_t.display.title,,video_output\vout_internal.h,*title,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1456,204199,vd,3,vout_thread_sys_t.display.vd,,video_output\vout_internal.h,*vd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1457,204200,use_dr,3,vout_thread_sys_t.display.use_dr,,video_output\vout_internal.h,use_dr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1458,204201,display,3,vout_thread_sys_t.display,,video_output\vout_internal.h,display,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1459,204203,date,3,vout_thread_sys_t.displayed.date,,video_output\vout_internal.h,date,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1460,204204,timestamp,3,vout_thread_sys_t.displayed.timestamp,,video_output\vout_internal.h,timestamp,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1461,204205,is_interlaced,3,vout_thread_sys_t.displayed.is_interlaced,,video_output\vout_internal.h,is_interlaced,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1462,204206,decoded,3,vout_thread_sys_t.displayed.decoded,,video_output\vout_internal.h,*decoded,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1463,204207,current,3,vout_thread_sys_t.displayed.current,,video_output\vout_internal.h,*current,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1464,204208,next,3,vout_thread_sys_t.displayed.next,,video_output\vout_internal.h,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1465,204209,displayed,3,vout_thread_sys_t.displayed,,video_output\vout_internal.h,displayed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1466,204211,last,3,vout_thread_sys_t.step.last,,video_output\vout_internal.h,last,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1467,204212,timestamp,3,vout_thread_sys_t.step.timestamp,,video_output\vout_internal.h,timestamp,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1468,204213,step,3,vout_thread_sys_t.step,,video_output\vout_internal.h,step,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1469,204215,is_on,3,vout_thread_sys_t.pause.is_on,,video_output\vout_internal.h,is_on,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1470,204216,date,3,vout_thread_sys_t.pause.date,,video_output\vout_internal.h,date,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1471,204217,pause,3,vout_thread_sys_t.pause,,video_output\vout_internal.h,pause,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1472,204219,show,3,vout_thread_sys_t.title.show,,video_output\vout_internal.h,show,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1473,204220,timeout,3,vout_thread_sys_t.title.timeout,,video_output\vout_internal.h,timeout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1474,204221,position,3,vout_thread_sys_t.title.position,,video_output\vout_internal.h,position,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1475,204222,title,3,vout_thread_sys_t.title,,video_output\vout_internal.h,title,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1476,204224,is_interlaced,3,vout_thread_sys_t.interlacing.is_interlaced,,video_output\vout_internal.h,is_interlaced,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1477,204225,date,3,vout_thread_sys_t.interlacing.date,,video_output\vout_internal.h,date,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1478,204226,interlacing,3,vout_thread_sys_t.interlacing,,video_output\vout_internal.h,interlacing,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1479,204227,is_late_dropped,3,vout_thread_sys_t.is_late_dropped,,video_output\vout_internal.h,is_late_dropped,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1480,204229,lock,3,vout_thread_sys_t.filter.lock,,video_output\vout_internal.h,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1481,204230,configuration,3,vout_thread_sys_t.filter.configuration,,video_output\vout_internal.h,*configuration,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1482,204231,format,3,vout_thread_sys_t.filter.format,,video_output\vout_internal.h,format,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1483,204233,chain_static,3,vout_thread_sys_t.filter.chain_static,,video_output\vout_internal.h,*chain_static,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1484,204235,chain_interactive,3,vout_thread_sys_t.filter.chain_interactive,,video_output\vout_internal.h,*chain_interactive,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1485,204236,has_deint,3,vout_thread_sys_t.filter.has_deint,,video_output\vout_internal.h,has_deint,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1486,204237,filter,3,vout_thread_sys_t.filter,,video_output\vout_internal.h,filter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1487,204238,mouse,3,vout_thread_sys_t.mouse,,video_output\vout_internal.h,mouse,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1488,204239,private_pool,3,vout_thread_sys_t.private_pool,,video_output\vout_internal.h,*private_pool,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1489,204240,display_pool,3,vout_thread_sys_t.display_pool,,video_output\vout_internal.h,*display_pool,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1490,204241,decoder_pool,3,vout_thread_sys_t.decoder_pool,,video_output\vout_internal.h,*decoder_pool,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1491,204242,decoder_fifo,3,vout_thread_sys_t.decoder_fifo,,video_output\vout_internal.h,*decoder_fifo,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1492,204243,render,3,vout_thread_sys_t.render,,video_output\vout_internal.h,render,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1493,204545,f_value,3,p_zoom_values.f_value,,video_output\vout_intf.c,f_value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1494,204546,psz_label,3,p_zoom_values.psz_label,,video_output\vout_intf.c,psz_label[13],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1495,204574,psz_value,3,p_crop_values.psz_value,,video_output\vout_intf.c,psz_value[8],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1496,204575,psz_label,3,p_crop_values.psz_label,,video_output\vout_intf.c,psz_label[8],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1497,204623,psz_value,3,p_aspect_ratio_values.psz_value,,video_output\vout_intf.c,psz_value[8],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1498,204624,psz_label,3,p_aspect_ratio_values.psz_label,,video_output\vout_intf.c,psz_label[8],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1499,206449,subpicture,3,spu_heap_entry_t.subpicture,,video_output\vout_subpictures.c,*subpicture,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
1500,206450,reject,3,spu_heap_entry_t.reject,,video_output\vout_subpictures.c,reject,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1501,206453,entry,3,spu_heap_t.entry,,video_output\vout_subpictures.c,entry[VOUT_MAX_SUBPICTURES],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1502,206468,lock,3,spu_private_t.lock,,video_output\vout_subpictures.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,25,0,1,1,0,0,,0,0,0,0,0,
1503,206469,input,3,spu_private_t.input,,video_output\vout_subpictures.c,*input,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1504,206470,heap,3,spu_private_t.heap,,video_output\vout_subpictures.c,heap,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1505,206471,channel,3,spu_private_t.channel,,video_output\vout_subpictures.c,channel,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1506,206472,text,3,spu_private_t.text,,video_output\vout_subpictures.c,*text,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1507,206473,scale_yuvp,3,spu_private_t.scale_yuvp,,video_output\vout_subpictures.c,*scale_yuvp,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1508,206474,scale,3,spu_private_t.scale,,video_output\vout_subpictures.c,*scale,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1509,206475,force_crop,3,spu_private_t.force_crop,,video_output\vout_subpictures.c,force_crop,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1510,206477,x,3,spu_private_t.crop.x,,video_output\vout_subpictures.c,x,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1511,206478,y,3,spu_private_t.crop.y,,video_output\vout_subpictures.c,y,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1512,206479,width,3,spu_private_t.crop.width,,video_output\vout_subpictures.c,width,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1513,206480,height,3,spu_private_t.crop.height,,video_output\vout_subpictures.c,height,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1514,206481,crop,3,spu_private_t.crop,,video_output\vout_subpictures.c,crop,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1515,206482,margin,3,spu_private_t.margin,,video_output\vout_subpictures.c,margin,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1516,206483,force_palette,3,spu_private_t.force_palette,,video_output\vout_subpictures.c,force_palette,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1517,206484,palette,3,spu_private_t.palette,,video_output\vout_subpictures.c,palette[4][4],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1518,206485,source_chain_current,3,spu_private_t.source_chain_current,,video_output\vout_subpictures.c,*source_chain_current,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1519,206486,source_chain_update,3,spu_private_t.source_chain_update,,video_output\vout_subpictures.c,*source_chain_update,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
1520,206487,source_chain_lock,3,spu_private_t.source_chain_lock,,video_output\vout_subpictures.c,source_chain_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1521,206488,source_chain,3,spu_private_t.source_chain,,video_output\vout_subpictures.c,*source_chain,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
1522,206489,filter_chain_current,3,spu_private_t.filter_chain_current,,video_output\vout_subpictures.c,*filter_chain_current,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1523,206490,filter_chain_update,3,spu_private_t.filter_chain_update,,video_output\vout_subpictures.c,*filter_chain_update,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1524,206491,filter_chain_lock,3,spu_private_t.filter_chain_lock,,video_output\vout_subpictures.c,filter_chain_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1525,206492,filter_chain,3,spu_private_t.filter_chain,,video_output\vout_subpictures.c,*filter_chain,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1526,206493,last_sort_date,3,spu_private_t.last_sort_date,,video_output\vout_subpictures.c,last_sort_date,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1527,206494,vout,3,spu_private_t.vout,,video_output\vout_subpictures.c,*vout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
1528,207105,w,3,spu_scale_t.w,,video_output\vout_subpictures.c,w,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1529,207106,h,3,spu_scale_t.h,,video_output\vout_subpictures.c,h,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1530,207258,x,3,spu_area_t.x,,video_output\vout_subpictures.c,x,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
1531,207259,y,3,spu_area_t.y,,video_output\vout_subpictures.c,y,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,17,0,1,1,0,0,,0,0,0,0,0,
1532,207260,width,3,spu_area_t.width,,video_output\vout_subpictures.c,width,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1533,207261,height,3,spu_area_t.height,,video_output\vout_subpictures.c,height,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
1534,207262,scale,3,spu_area_t.scale,,video_output\vout_subpictures.c,scale,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
1535,212443,wnd,3,window_t.wnd,,video_output\window.c,wnd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1536,212444,module,3,window_t.module,,video_output\window.c,*module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1537,212445,inhibit,3,window_t.inhibit,,video_output\window.c,*inhibit,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1538,212699,vd,3,vout_display_window.vd,,video_output\window.c,*vd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1539,212700,width,3,vout_display_window.width,,video_output\window.c,width,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1540,212701,height,3,vout_display_window.height,,video_output\window.c,height,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1541,212702,lock,3,vout_display_window.lock,,video_output\window.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1542,213281,code,3,wsaerrmsg_t.code,,win32\error.c,code,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1543,213282,msg,3,wsaerrmsg_t.msg,,win32\error.c,*msg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1544,214512,thread,3,vlc_mta_holder.thread,,win32\mta_holder.h,thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1545,214513,i_refcount,3,vlc_mta_holder.i_refcount,,win32\mta_holder.h,i_refcount,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1546,214514,ready_sem,3,vlc_mta_holder.ready_sem,,win32\mta_holder.h,ready_sem,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1547,214515,release_sem,3,vlc_mta_holder.release_sem,,win32\mta_holder.h,release_sem,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1548,215155,argc,3,vlc_ipc_data_t.argc,,win32\specific.c,argc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1549,215156,enqueue,3,vlc_ipc_data_t.enqueue,,win32\specific.c,enqueue,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1550,215157,data,3,vlc_ipc_data_t.data,,win32\specific.c,data[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1551,215393,id,3,vlc_thread.id,,win32\thread.c,id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1552,215394,killable,3,vlc_thread.killable,,win32\thread.c,killable,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1553,215395,killed,3,vlc_thread.killed,,win32\thread.c,killed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1554,215396,cleaners,3,vlc_thread.cleaners,,win32\thread.c,*cleaners,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1555,215402,data,3,vlc_thread.data,,win32\thread.c,*data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1556,215404,addr,3,vlc_thread.wait.addr,,win32\thread.c,*addr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1557,215405,lock,3,vlc_thread.wait.lock,,win32\thread.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1558,215406,wait,3,vlc_thread.wait,,win32\thread.c,wait,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1559,215585,id,3,vlc_threadvar.id,,win32\thread.c,id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1560,215592,prev,3,vlc_threadvar.prev,,win32\thread.c,*prev,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1561,215594,next,3,vlc_threadvar.next,,win32\thread.c,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1562,216531,interrupt,3,clk.interrupt,,win32\thread.c,interrupt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1563,216538,tick,3,clk.tick,,win32\thread.c,tick,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1564,216540,freq,3,clk.perf.freq,,win32\thread.c,freq,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1565,216541,perf,3,clk.perf,,win32\thread.c,perf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1566,216557,multimedia,3,clk.multimedia,,win32\thread.c,multimedia,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1567,217280,handle,3,vlc_timer.handle,,win32\timer.c,handle,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1568,217286,data,3,vlc_timer.data,,win32\timer.c,*data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1569,13,vlc_strerror,1,vlc_strerror,const char* vlc_strerror (int),win32\error.c,"const char *vlc_strerror(int errnum)
{
    return /*vlc_gettext*/(vlc_strerror_c(errnum));
}",150.0,153.0,1.0,1.0,4.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,const char*
1570,21,vlc_strerror_c,1,vlc_strerror_c,const char* vlc_strerror_c (int),win32\error.c,"const char *vlc_strerror_c(int errnum)
{
    /* C run-time errors */
    if ((unsigned)errnum < (unsigned)_sys_nerr)
        return _sys_errlist[errnum];

    /* Windows socket errors */
    for (const wsaerrmsg_t *e = wsaerrmsg; e->msg != NULL; e++)
        if (e->code == errnum)
            return e->msg;

    return ""Unknown error"";
}",136.0,148.0,1.0,1.0,13.0,0,0,3,2,33,0,1,1,0,0,,0,0,2,1,1,const char*
1571,87,get_java_string,1,get_java_string,"char* get_java_string (JNIEnv*,jclass,char*)",android\specific.c,"static char *
get_java_string(JNIEnv *env, jclass clazz, const char *psz_name)
{
    jfieldID id = (*env)->GetStaticFieldID(env, clazz, psz_name,
                                           ""Ljava/lang/String;"");
    if ((*env)->ExceptionCheck(env))
    {
        (*env)->ExceptionClear(env);
        return NULL;
    }

    jstring jstr = (*env)->GetStaticObjectField(env, clazz, id);

    const char *psz_str = (*env)->GetStringUTFChars(env, jstr, 0);
    if (psz_str == NULL)
        return NULL;

    char *psz_strdup = strdup(psz_str);

    (*env)->ReleaseStringUTFChars(env, jstr, psz_str);
    (*env)->DeleteLocalRef(env, jstr);

    return psz_strdup;
}",53.0,76.0,1.0,1.0,24.0,19,4,32,8,1,0,3,3,0,0,,0,0,6,3,3,char*
1572,173,JNI_OnUnload,1,JNI_OnUnload,"void JNI_OnUnload (JavaVM*,void*)",android\specific.c,"void
JNI_OnUnload(JavaVM* vm, void* reserved)
{
    (void) reserved;

    for (size_t i = 0; i < GENERIC_DIR_COUNT; ++i)
        free(ppsz_generic_names[i]);

    JNIEnv* env = NULL;
    if ((*vm)->GetEnv(vm, (void**) &env, JNI_VERSION_1_2) != JNI_OK)
        return;

    if (fields.Environment.clazz)
        (*env)->DeleteGlobalRef(env, fields.Environment.clazz);

    if (fields.System.clazz)
        (*env)->DeleteGlobalRef(env, fields.System.clazz);
}",78.0,95.0,1.0,27.0,18.0,23,10,20,10,1,4,5,5,2,0,,0,4,4,2,2,void
1573,259,JNI_OnLoad,1,JNI_OnLoad,"jint JNI_OnLoad (JavaVM*,void*)",android\specific.c,"jint
JNI_OnLoad(JavaVM *vm, void *reserved)
{
    s_jvm = vm;
    JNIEnv* env = NULL;

    if ((*vm)->GetEnv(vm, (void**) &env, JNI_VERSION_1_2) != JNI_OK)
        return -1;

    jclass clazz = (*env)->FindClass(env, ""android/os/Environment"");
    if ((*env)->ExceptionCheck(env))
        return -1;

    static const char *ppsz_env_names[GENERIC_DIR_COUNT] = {
        NULL,                   /* VLC_DESKTOP_DIR */
        ""DIRECTORY_DOWNLOADS"",  /* VLC_DOWNLOAD_DIR */
        NULL,                   /* VLC_TEMPLATES_DIR */
        NULL,                   /* VLC_PUBLICSHARE_DIR */
        ""DIRECTORY_DOCUMENTS"",  /* VLC_DOCUMENTS_DIR */
        ""DIRECTORY_MUSIC"",      /* VLC_MUSIC_DIR */
        ""DIRECTORY_PICTURES"",   /* VLC_PICTURES_DIR */
        ""DIRECTORY_MOVIES"",     /* VLC_VIDEOS_DIR */
    };
    for (size_t i = 0; i < GENERIC_DIR_COUNT; ++i)
    {
        if (ppsz_env_names[i] != NULL)
            ppsz_generic_names[i] = get_java_string(env, clazz,
                            ...",100.0,163.0,1.0,38.0,64.0,71,13,79,14,0,9,12,10,0,2,,0,8,4,2,2,jint
1574,514,system_Init,1,system_Init,void system_Init (void),win32\specific.c,"void system_Init(void)
{
    if (system_InitWSA(2, 2) && system_InitWSA(1, 1))
        fputs(""Error: cannot initialize Winsocks\n"", stderr);

#if !VLC_WINSTORE_APP
# if (_WIN32_WINNT < _WIN32_WINNT_WIN8)
    if (GetProcAddress(GetModuleHandle(TEXT(""kernel32.dll"")),
                                       ""SetDefaultDllDirectories"") != NULL)
# endif /* FIXME: not reentrant */
        LoadLibraryFlags = LOAD_LIBRARY_SEARCH_SYSTEM32;
#endif
}",61.0,73.0,1.0,1.0,13.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1575,519,system_Configure,1,system_Configure,"void system_Configure (libvlc_int_t*,int,char[]*)",win32\specific.c,"void system_Configure( libvlc_int_t *p_this, int i_argc, const char *const ppsz_argv[] )
{
#if !VLC_WINSTORE_APP
    if( var_InheritBool( p_this, ""one-instance"" )
     || ( var_InheritBool( p_this, ""one-instance-when-started-from-file"" )
       && var_InheritBool( p_this, ""started-from-file"" ) ) )
    {
        HANDLE hmutex;

        msg_Info( p_this, ""one instance mode ENABLED"");

        /* Use a named mutex to check if another instance is already running */
        if( !( hmutex = CreateMutex( 0, TRUE, L""VLC ipc "" TEXT(VERSION) ) ) )
        {
            /* Failed for some reason. Just ignore the option and go on as
             * normal. */
            msg_Err( p_this, ""one instance mode DISABLED ""
                     ""(mutex couldn't be created)"" );
            return;
        }

        if( GetLastError() != ERROR_ALREADY_EXISTS )
        {
            libvlc_InternalAddIntf( p_this, ""win_msg,none"" );
            /* Initialization done.
             * Release the mutex to u...",87.0,182.0,1.0,1.0,96.0,3,2,8,6,1,3,1,1,0,1,,0,2,6,3,3,void
1576,544,config_GetHomeDir,1,config_GetHomeDir,"char* config_GetHomeDir (char*,char*)",posix\dirs.c,"static char *config_GetHomeDir (void)
{
    /* 1/ Try $HOME  */
    const char *home = getenv (""HOME"");
    if (home != NULL)
        return strdup (home);
#if defined(HAVE_GETPWUID_R)
    /* 2/ Try /etc/passwd */
    long max = sysconf (_SC_GETPW_R_SIZE_MAX);
    if (max != -1)
    {
        char buf[max];
        struct passwd pwbuf, *pw;

        if (getpwuid_r (getuid (), &pwbuf, buf, sizeof (buf), &pw) == 0
          && pw != NULL)
            return strdup (pw->pw_dir);
    }
#endif
    return NULL;
}",61.0,81.0,1.0,1.0,21.0,12,7,18,7,6,1,8,5,1,1,,0,1,2,1,1,char*
1577,608,get_env,1,get_env,JNIEnv get_env (bool*),android\specific.c,"static JNIEnv *get_env(bool *p_detach)
{
    JNIEnv *env;
    if ((*s_jvm)->GetEnv(s_jvm, (void **)&env, JNI_VERSION_1_2) != JNI_OK)
    {
        /* attach the thread to the Java VM */
        JavaVMAttachArgs args;

        args.version = JNI_VERSION_1_2;
        args.name = ""config_GetGenericDir"";
        args.group = NULL;

        if ((*s_jvm)->AttachCurrentThread(s_jvm, &env, &args) != JNI_OK)
            return NULL;
        *p_detach = true;
    }
    else
        *p_detach = false;
    return env;
}",202.0,221.0,1.0,1.0,20.0,18,7,19,8,2,4,3,4,4,0,,0,4,2,1,1,JNIEnv
1578,673,release_env,1,release_env,void release_env (bool),android\specific.c,"static void release_env(bool b_detach)
{
    if (b_detach)
        (*s_jvm)->DetachCurrentThread(s_jvm);
}",223.0,227.0,1.0,1.0,5.0,2,2,3,2,2,2,2,2,0,0,,0,2,2,1,1,void
1579,687,config_GetGenericDir,1,config_GetGenericDir,char* config_GetGenericDir (char*),android\specific.c,"static char *config_GetGenericDir(const char *psz_name)
{
    JNIEnv *env;
    bool b_detach;
    char *psz_ret = NULL;

    env = get_env(&b_detach);
    if (env == NULL)
        return NULL;

    jstring jname= (*env)->NewStringUTF(env, psz_name);
    if ((*env)->ExceptionCheck(env))
    {
        (*env)->ExceptionClear(env);
        jname = NULL;
    }
    if (jname == NULL)
        goto error;

    jobject jfile = (*env)->CallStaticObjectMethod(env,
                        fields.Environment.clazz,
                        fields.Environment.getExternalStoragePublicDirectory,
                        jname);
    (*env)->DeleteLocalRef(env, jname);
    if (jfile == NULL)
        goto error;

    jstring jpath = (*env)->CallObjectMethod(env, jfile,
                                             fields.File.getAbsolutePath);
    (*env)->DeleteLocalRef(env, jfile);

    const char *psz_path = (*env)->GetStringUTFChars(env, jpath, 0);
    if (psz_path == NULL)
        goto error;
    psz...",229.0,270.0,1.0,1.0,42.0,39,6,55,10,1,5,9,6,0,2,,0,4,2,1,1,char*
1580,839,config_GetUserDir,1,config_GetUserDir,char* config_GetUserDir (vlc_userdir_t),win32\dirs.c,"char *config_GetUserDir (vlc_userdir_t type)
{
    switch (type)
    {
        case VLC_HOME_DIR:
            return config_GetShellDir (CSIDL_PERSONAL);
        case VLC_CONFIG_DIR:
        case VLC_DATA_DIR:
            return config_GetAppDir ();
        case VLC_CACHE_DIR:
#if !VLC_WINSTORE_APP
            return config_GetAppDir ();
#else
            return config_GetShellDir (CSIDL_LOCAL_APPDATA);
#endif

        case VLC_DESKTOP_DIR:
        case VLC_DOWNLOAD_DIR:
        case VLC_TEMPLATES_DIR:
        case VLC_PUBLICSHARE_DIR:
        case VLC_DOCUMENTS_DIR:
            return config_GetUserDir(VLC_HOME_DIR);
        case VLC_MUSIC_DIR:
            return config_GetShellDir (CSIDL_MYMUSIC);
        case VLC_PICTURES_DIR:
            return config_GetShellDir (CSIDL_MYPICTURES);
        case VLC_VIDEOS_DIR:
            return config_GetShellDir (CSIDL_MYVIDEO);
    }
    vlc_assert_unreachable ();
}",255.0,285.0,1.0,1.0,31.0,7,7,28,16,7,6,3,4,0,5,,0,1,2,1,1,char*
1581,914,vlc_getProxyUrl,1,vlc_getProxyUrl,char* vlc_getProxyUrl (char*),win32\netconf.c,"char *vlc_getProxyUrl(const char *psz_url)
{
    VLC_UNUSED(psz_url);

    char *proxy = config_GetPsz( (vlc_object_t *)(NULL), ""http-proxy"" );
    if (proxy == NULL)
        return NULL;

    char *proxy_pwd = config_GetPsz( (vlc_object_t *)(NULL), ""http-proxy-pwd"" );
    if (proxy_pwd == NULL)
        return proxy;

    vlc_url_t url;
    if (vlc_UrlParse(&url, proxy) < 0) {
        vlc_UrlClean(&url);
        free (proxy);
        free (proxy_pwd);
        return NULL;
    }

    if (url.psz_password == NULL )
        url.psz_password = proxy_pwd;

    char *proxy_url = vlc_uri_compose (&url);
    vlc_UrlClean (&url);

    free (proxy_pwd);
    free (proxy);

#if 0
    /* Try to get the proxy server address from Windows internet settings. */
    HKEY h_key;

    /* Open the key */
    if( RegOpenKeyEx( HKEY_CURRENT_USER, ""Software\\Microsoft""
                      ""\\Windows\\CurrentVersion\\Internet Settings"",
                      0, KEY_READ, &h_key ) == ERROR_SUCCESS )
      ...",32.0,110.0,1.0,1.0,79.0,86,12,114,11,0,6,19,16,0,2,,0,5,2,1,1,char*
1582,1252,vlc_thread_fatal_print,1,vlc_thread_fatal_print,"void vlc_thread_fatal_print (char*,int,char*,char*,unsigned)",android\thread.c,"static void
vlc_thread_fatal_print (const char *action, int error,
                        const char *function, const char *file, unsigned line)
{
    char buf[1000];
    const char *msg;

    switch (strerror_r (error, buf, sizeof (buf)))
    {
        case 0:
            msg = buf;
            break;
        case ERANGE: /* should never happen */
            msg = ""unknown (too big to display)"";
            break;
        default:
            msg = ""unknown (invalid error number)"";
            break;
    }

    fprintf(stderr, ""LibVLC fatal error %s (%d) in thread %lu ""
            ""at %s:%u in %s\n Error message: %s\n"",
            action, error, vlc_thread_id (), file, line, function, msg);
    fflush (stderr);
}",48.0,72.0,1.0,1.0,25.0,4,2,16,9,5,1,5,2,0,1,,0,0,10,5,5,void
1583,1299,vlc_mutex_init,1,vlc_mutex_init,void vlc_mutex_init (vlc_mutex_t*),win32\thread.c,"void vlc_mutex_init( vlc_mutex_t *p_mutex )
{
    /* This creates a recursive mutex. This is OK as fast mutexes have
     * no defined behavior in case of recursive locking. */
    InitializeCriticalSection (&p_mutex->mutex);
    p_mutex->dynamic = true;
}",100.0,106.0,1.0,1.0,7.0,4,1,6,3,39,0,1,1,0,0,,0,0,2,1,1,void
1584,1319,vlc_mutex_init_recursive,1,vlc_mutex_init_recursive,void vlc_mutex_init_recursive (vlc_mutex_t*),win32\thread.c,"void vlc_mutex_init_recursive( vlc_mutex_t *p_mutex )
{
    InitializeCriticalSection( &p_mutex->mutex );
    p_mutex->dynamic = true;
}",108.0,112.0,1.0,1.0,5.0,4,1,6,3,3,0,1,1,0,0,,0,0,2,1,1,void
1585,1339,vlc_mutex_destroy,1,vlc_mutex_destroy,void vlc_mutex_destroy (vlc_mutex_t*),win32\thread.c,"void vlc_mutex_destroy (vlc_mutex_t *p_mutex)
{
    assert (p_mutex->dynamic);
    DeleteCriticalSection (&p_mutex->mutex);
}",115.0,119.0,1.0,1.0,5.0,2,2,5,3,53,1,1,1,0,1,,0,0,2,1,1,void
1586,1368,vlc_mutex_lock,1,vlc_mutex_lock,void vlc_mutex_lock (vlc_mutex_t*),win32\thread.c,"void vlc_mutex_lock (vlc_mutex_t *p_mutex)
{
    if (!p_mutex->dynamic)
    {   /* static mutexes */
        EnterCriticalSection(&super_mutex);
        while (p_mutex->locked)
        {
            p_mutex->contention++;
            SleepConditionVariableCS(&super_variable, &super_mutex, INFINITE);
            p_mutex->contention--;
        }
        p_mutex->locked = true;
        LeaveCriticalSection(&super_mutex);
        return;
    }

    EnterCriticalSection (&p_mutex->mutex);
}",121.0,138.0,1.0,1.0,18.0,2,2,5,3,296,1,1,1,0,1,,0,0,2,1,1,void
1587,1396,vlc_mutex_trylock,1,vlc_mutex_trylock,int vlc_mutex_trylock (vlc_mutex_t*),win32\thread.c,"int vlc_mutex_trylock (vlc_mutex_t *p_mutex)
{
    if (!p_mutex->dynamic)
    {   /* static mutexes */
        int ret = EBUSY;

        EnterCriticalSection(&super_mutex);
        if (!p_mutex->locked)
        {
            p_mutex->locked = true;
            ret = 0;
        }
        LeaveCriticalSection(&super_mutex);
        return ret;
    }

    return TryEnterCriticalSection (&p_mutex->mutex) ? 0 : EBUSY;
}",140.0,157.0,1.0,1.0,18.0,3,3,8,4,2,1,2,2,0,1,,0,0,2,1,1,int
1588,1431,vlc_mutex_unlock,1,vlc_mutex_unlock,void vlc_mutex_unlock (vlc_mutex_t*),win32\thread.c,"void vlc_mutex_unlock (vlc_mutex_t *p_mutex)
{
    if (!p_mutex->dynamic)
    {   /* static mutexes */
        EnterCriticalSection(&super_mutex);
        assert (p_mutex->locked);
        p_mutex->locked = false;
        if (p_mutex->contention)
            WakeAllConditionVariable(&super_variable);
        LeaveCriticalSection(&super_mutex);
        return;
    }

    LeaveCriticalSection (&p_mutex->mutex);
}",159.0,173.0,1.0,1.0,15.0,2,2,5,3,370,1,1,1,0,1,,0,0,2,1,1,void
1589,1462,entry,1,vlc_thread.entry,void* vlc_thread.entry (void*),android\thread.c,void *(*entry)(void*);,149.0,149.0,10.0,25.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void*
1590,1475,vlc_thread_self,1,vlc_thread_self,vlc_thread_t vlc_thread_self (void),win32\thread.c,"vlc_thread_t vlc_thread_self (void)
{
    return TlsGetValue(thread_key);
}",566.0,569.0,1.0,1.0,4.0,0,0,1,1,3,0,1,1,0,0,,0,0,2,1,1,vlc_thread_t
1591,1482,vlc_threads_setup,1,vlc_threads_setup,void vlc_threads_setup (libvlc_int_t*),win32\thread.c,"void vlc_threads_setup(libvlc_int_t *vlc)
{
    EnterCriticalSection(&setup_lock);
    if (mdate_selected != mdate_default)
    {
        LeaveCriticalSection(&setup_lock);
        return;
    }

    if (!SelectClockSource((vlc != NULL) ? VLC_OBJECT(vlc) : NULL))
        abort();
    assert(mdate_selected != mdate_default);

#if !VLC_WINSTORE_APP
    /* Raise default priority of the current process */
#ifndef ABOVE_NORMAL_PRIORITY_CLASS
#   define ABOVE_NORMAL_PRIORITY_CLASS 0x00008000
#endif
    if (var_InheritBool(vlc, ""high-priority""))
    {
        if (SetPriorityClass(GetCurrentProcess(), ABOVE_NORMAL_PRIORITY_CLASS)
         || SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS))
            msg_Dbg(vlc, ""raised process priority"");
        else
            msg_Dbg(vlc, ""could not raise process priority"");
    }
#endif
    LeaveCriticalSection(&setup_lock);
}",1008.0,1036.0,1.0,50.0,29.0,1,1,1,1,2,0,1,1,0,0,,0,0,2,1,1,void
1592,1490,clean_detached_thread,1,clean_detached_thread,void clean_detached_thread (void*),android\thread.c,"static void clean_detached_thread(void *data)
{
    struct vlc_thread *th = data;

    /* release thread handle */
    vlc_mutex_destroy(&th->wait.lock);
    free(th);
}",175.0,182.0,1.0,1.0,8.0,4,4,4,2,2,1,1,1,0,1,,0,0,2,1,1,void
1593,1508,detached_thread,1,detached_thread,void* detached_thread (void*),android\thread.c,"static void *detached_thread(void *data)
{
    vlc_thread_t th = data;

    thread = th;

    vlc_cleanup_push(clean_detached_thread, th);
    th->entry(th->data);
    vlc_cleanup_pop();
    clean_detached_thread(th);
    return NULL;
}",184.0,195.0,1.0,1.0,12.0,4,2,9,4,0,1,1,1,0,1,,0,0,2,1,1,void*
1594,1535,finish_joinable_thread,1,finish_joinable_thread,void finish_joinable_thread (void*),android\thread.c,"static void finish_joinable_thread(void *data)
{
    vlc_thread_t th = data;

    vlc_sem_post(&th->finished);
}",197.0,202.0,1.0,1.0,6.0,3,3,3,2,0,1,1,1,0,1,,0,0,2,1,1,void
1595,1549,joinable_thread,1,joinable_thread,void* joinable_thread (void*),android\thread.c,"static void *joinable_thread(void *data)
{
    vlc_thread_t th = data;
    void *ret;

    vlc_cleanup_push(finish_joinable_thread, th);
    thread = th;
    ret = th->entry(th->data);
    vlc_cleanup_pop();
    vlc_sem_post(&th->finished);

    return ret;
}",204.0,216.0,1.0,1.0,13.0,7,3,10,4,0,1,1,1,0,1,,0,0,2,1,1,void*
1596,1582,vlc_clone_attr,1,vlc_clone_attr,"int vlc_clone_attr (vlc_thread_t*,void*,void*,bool)",win32\thread.c,"static int vlc_clone_attr (vlc_thread_t *p_handle, bool detached,
                           void *(*entry) (void *), void *data, int priority)
{
    struct vlc_thread *th = malloc (sizeof (*th));
    if (unlikely(th == NULL))
        return ENOMEM;
    th->entry = entry;
    th->data = data;
    th->killable = false; /* not until vlc_entry() ! */
    atomic_init(&th->killed, false);
    th->cleaners = NULL;
    th->wait.addr = NULL;
    InitializeCriticalSection(&th->wait.lock);

    HANDLE h;
#if VLC_WINSTORE_APP
    h = CreateThread(NULL, 0, vlc_entry, th, 0, NULL);
#else // !VLC_WINSTORE_APP
    /* When using the MSVCRT C library you have to use the _beginthreadex
     * function instead of CreateThread, otherwise you'll end up with
     * memory leaks and the signal functions not working (see Microsoft
     * Knowledge Base, article 104641) */
    h = (HANDLE)(uintptr_t) _beginthreadex (NULL, 0, vlc_entry, th, 0, NULL);
#endif // !VLC_WINSTORE_APP
    if (h == 0)
    {
        ...",484.0,530.0,1.0,1.0,47.0,41,9,49,22,2,2,3,3,0,2,,0,0,10,5,5,int
1597,1722,vlc_clone,1,vlc_clone,"int vlc_clone (vlc_thread_t*,void*,void*,int)",win32\thread.c,"int vlc_clone (vlc_thread_t *p_handle, void *(*entry) (void *),
                void *data, int priority)
{
    return vlc_clone_attr (p_handle, false, entry, data, priority);
}",532.0,536.0,1.0,1.0,5.0,1,1,5,5,12,1,1,1,0,1,,0,0,8,4,4,int
1598,1739,vlc_join,1,vlc_join,"void vlc_join (vlc_thread_t,void**)",win32\thread.c,"void vlc_join (vlc_thread_t th, void **result)
{
    DWORD ret;

    do
    {
        vlc_testcancel ();
        ret = WaitForSingleObjectEx(th->id, INFINITE, TRUE);
        assert(ret != WAIT_ABANDONED_0);
    }
    while (ret == WAIT_IO_COMPLETION || ret == WAIT_FAILED);

    if (result != NULL)
        *result = th->data;
    CloseHandle (th->id);
    vlc_thread_destroy(th);
}",538.0,554.0,1.0,1.0,17.0,7,4,9,4,16,4,1,1,0,4,,0,0,4,2,2,void
1599,1783,vlc_clone_detach,1,vlc_clone_detach,"int vlc_clone_detach (vlc_thread_t*,void*,void*,int)",win32\thread.c,"int vlc_clone_detach (vlc_thread_t *p_handle, void *(*entry) (void *),
                      void *data, int priority)
{
    vlc_thread_t th;
    if (p_handle == NULL)
        p_handle = &th;

    return vlc_clone_attr (p_handle, true, entry, data, priority);
}",556.0,564.0,1.0,1.0,9.0,4,4,9,7,1,1,2,2,0,1,,0,0,8,4,4,int
1600,1810,vlc_set_priority,1,vlc_set_priority,"int vlc_set_priority (vlc_thread_t,int)",win32\thread.c,"int vlc_set_priority (vlc_thread_t th, int priority)
{
    if (!SetThreadPriority (th->id, priority))
        return VLC_EGENERIC;
    return VLC_SUCCESS;
}",576.0,581.0,1.0,1.0,6.0,2,1,3,3,0,0,1,1,0,0,,0,0,4,2,2,int
1601,1824,vlc_cancel,1,vlc_cancel,void vlc_cancel (vlc_thread_t),win32\thread.c,"void vlc_cancel (vlc_thread_t th)
{
    atomic_store_explicit(&th->killed, true, memory_order_relaxed);

    EnterCriticalSection(&th->wait.lock);
    if (th->wait.addr != NULL)
    {
        atomic_fetch_or_explicit(th->wait.addr, 1, memory_order_relaxed);
        vlc_addr_broadcast(th->wait.addr);
    }
    LeaveCriticalSection(&th->wait.lock);

#if IS_INTERRUPTIBLE
    QueueUserAPC (vlc_cancel_self, th->id, (uintptr_t)th);
#endif
}",593.0,608.0,1.0,4.0,16.0,12,5,11,5,4,3,2,2,0,3,,0,0,2,1,1,void
1602,1868,vlc_savecancel,1,vlc_savecancel,int vlc_savecancel (void),win32\thread.c,"int vlc_savecancel (void)
{
    struct vlc_thread *th = vlc_thread_self();
    if (th == NULL)
        return false; /* Main thread - cannot be cancelled anyway */

    int state = th->killable;
    th->killable = false;
    return state;
}",610.0,619.0,1.0,1.0,10.0,5,3,7,4,18,0,2,2,0,0,,0,0,2,1,1,int
1603,1892,vlc_restorecancel,1,vlc_restorecancel,void vlc_restorecancel (int),win32\thread.c,"void vlc_restorecancel (int state)
{
    struct vlc_thread *th = vlc_thread_self();
    assert (state == false || state == true);

    if (th == NULL)
        return; /* Main thread - cannot be cancelled anyway */

    assert (!th->killable);
    th->killable = state != 0;
}",621.0,631.0,1.0,1.0,11.0,3,3,3,2,18,0,2,2,0,0,,0,0,2,1,1,void
1604,1907,vlc_testcancel,1,vlc_testcancel,void vlc_testcancel (void),win32\thread.c,"void vlc_testcancel (void)
{
    struct vlc_thread *th = vlc_thread_self();
    if (th == NULL)
        return; /* Main thread - cannot be cancelled anyway */
    if (!th->killable)
        return;
    if (!atomic_load_explicit(&th->killed, memory_order_relaxed))
        return;

    th->killable = true; /* Do not re-enter cancellation cleanup */

    for (vlc_cleanup_t *p = th->cleaners; p != NULL; p = p->next)
        p->proc (p->data);

    th->data = NULL; /* TODO: special value? */
    if (th->id == NULL) /* Detached thread */
        vlc_thread_destroy(th);
#if VLC_WINSTORE_APP
    ExitThread(0);
#else // !VLC_WINSTORE_APP
    _endthreadex(0);
#endif // !VLC_WINSTORE_APP
}",633.0,656.0,1.0,1.0,24.0,6,3,4,2,7,0,4,4,0,0,,0,0,2,1,1,void
1605,1935,vlc_control_cancel,1,vlc_control_cancel,void vlc_control_cancel (int...),win32\thread.c,"void vlc_control_cancel (int cmd, ...)
{
    /* NOTE: This function only modifies thread-specific data, so there is no
     * need to lock anything. */
    va_list ap;

    struct vlc_thread *th = vlc_thread_self();
    if (th == NULL)
        return; /* Main thread - cannot be cancelled anyway */

    va_start (ap, cmd);
    switch (cmd)
    {
        case VLC_CLEANUP_PUSH:
        {
            /* cleaner is a pointer to the caller stack, no need to allocate
             * and copy anything. As a nice side effect, this cannot fail. */
            vlc_cleanup_t *cleaner = va_arg (ap, vlc_cleanup_t *);
            cleaner->next = th->cleaners;
            th->cleaners = cleaner;
            break;
        }

        case VLC_CLEANUP_POP:
        {
            th->cleaners = th->cleaners->next;
            break;
        }

        case VLC_CANCEL_ADDR_SET:
        {
            void *addr = va_arg(ap, void *);

            EnterCriticalSection(&th->wait.lock);
            assert(th-...",658.0,710.0,1.0,1.0,53.0,27,6,22,7,0,5,5,3,0,5,,0,1,2,1,1,void
1606,2032,vlc_threadvar_create,1,vlc_threadvar_create,"int vlc_threadvar_create (vlc_threadvar_t*,void)",win32\thread.c,"int vlc_threadvar_create (vlc_threadvar_t *p_tls, void (*destr) (void *))
{
    struct vlc_threadvar *var = malloc (sizeof (*var));
    if (unlikely(var == NULL))
        return errno;

    var->id = TlsAlloc();
    if (var->id == TLS_OUT_OF_INDEXES)
    {
        free (var);
        return EAGAIN;
    }
    var->destroy = destr;
    var->next = NULL;
    *p_tls = var;

    EnterCriticalSection(&super_mutex);
    var->prev = vlc_threadvar_last;
    if (var->prev)
        var->prev->next = var;

    vlc_threadvar_last = var;
    LeaveCriticalSection(&super_mutex);
    return 0;
}",235.0,259.0,1.0,1.0,25.0,0,0,2,2,0,0,1,1,0,0,,0,0,4,2,2,int
1607,2042,vlc_threadvar_delete,1,vlc_threadvar_delete,void vlc_threadvar_delete (vlc_threadvar_t*),win32\thread.c,"void vlc_threadvar_delete (vlc_threadvar_t *p_tls)
{
    struct vlc_threadvar *var = *p_tls;

    EnterCriticalSection(&super_mutex);
    if (var->prev != NULL)
        var->prev->next = var->next;

    if (var->next != NULL)
        var->next->prev = var->prev;
    else
        vlc_threadvar_last = var->prev;

    LeaveCriticalSection(&super_mutex);

    TlsFree (var->id);
    free (var);
}",261.0,278.0,1.0,1.0,18.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
1608,2050,vlc_threadvar_set,1,vlc_threadvar_set,"int vlc_threadvar_set (vlc_threadvar_t,void*)",win32\thread.c,"int vlc_threadvar_set (vlc_threadvar_t key, void *value)
{
    int saved = GetLastError ();

    if (!TlsSetValue(key->id, value))
        return ENOMEM;

    SetLastError(saved);
    return 0;
}",280.0,289.0,1.0,1.0,10.0,0,0,2,2,3,0,1,1,0,0,,0,0,4,2,2,int
1609,2060,vlc_threadvar_get,1,vlc_threadvar_get,void* vlc_threadvar_get (vlc_threadvar_t),win32\thread.c,"void *vlc_threadvar_get (vlc_threadvar_t key)
{
    int saved = GetLastError ();
    void *value = TlsGetValue (key->id);

    SetLastError(saved);
    return value;
}",291.0,298.0,1.0,1.0,8.0,0,0,1,1,2,0,1,1,0,0,,0,0,2,1,1,void*
1610,2068,mdate,1,mdate,mtime_t mdate (void),win32\thread.c,"mtime_t mdate (void)
{
    return mdate_selected ();
}",820.0,823.0,1.0,1.0,4.0,7,6,4,2,39,0,2,2,0,0,,0,0,2,1,1,mtime_t
1611,2097,vlc_GetCPUCount,1,vlc_GetCPUCount,unsigned vlc_GetCPUCount (void),win32\thread.c,"unsigned vlc_GetCPUCount (void)
{
    SYSTEM_INFO systemInfo;

    GetNativeSystemInfo(&systemInfo);

    return systemInfo.dwNumberOfProcessors;
}",995.0,1002.0,1.0,1.0,8.0,0,0,1,1,0,0,1,1,0,0,,0,0,2,1,1,unsigned
1612,2173,aout_owner,1,aout_owner,aout_owner_t aout_owner (audio_output_t*),audio_output\aout_internal.h,"static inline aout_owner_t *aout_owner (audio_output_t *aout)
{
    return &((aout_instance_t *)aout)->owner;
}",105.0,108.0,1.0,1.0,4.0,3,3,1,1,12,0,1,1,0,0,,0,0,2,1,1,aout_owner_t
1613,2185,aout_volume_New,1,aout_volume_New,"aout_volume_t* aout_volume_New (vlc_object_t*,audio_replay_gain_t*)",audio_output\volume.c,"aout_volume_t *aout_volume_New(vlc_object_t *parent,
                               const audio_replay_gain_t *gain)
{
    aout_volume_t *vol = vlc_custom_create(parent, sizeof (aout_volume_t),
                                           ""volume"");
    if (unlikely(vol == NULL))
        return NULL;
    vol->module = NULL;
    vol->output_factor = 1.f;

    //audio_volume_t *obj = &vol->object;

    /* Gain */
    if (gain != NULL)
        memcpy(&vol->replay_gain, gain, sizeof (vol->replay_gain));
    else
        memset(&vol->replay_gain, 0, sizeof (vol->replay_gain));

    var_AddCallback(parent, ""audio-replay-gain-mode"",
                    ReplayGainCallback, vol);
    var_TriggerCallback(parent, ""audio-replay-gain-mode"");

    return vol;
}",52.0,75.0,1.0,1.0,24.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,aout_volume_t
1614,2191,aout_volume_SetFormat,1,aout_volume_SetFormat,"int aout_volume_SetFormat (aout_volume_t*,ANY)",audio_output\volume.c,"int aout_volume_SetFormat(aout_volume_t *vol, vlc_fourcc_t format)
{
    if (unlikely(vol == NULL))
        return -1;

    audio_volume_t *obj = &vol->object;
    if (vol->module != NULL)
    {
        if (obj->format == format)
        {
            msg_Dbg (obj, ""retaining sample format"");
            return 0;
        }
        msg_Dbg (obj, ""changing sample format"");
        module_unneed(obj, vol->module);
    }

    obj->format = format;
    vol->module = module_need(obj, ""audio volume"", NULL, false);
    if (vol->module == NULL)
        return -1;
    return 0;
}",80.0,102.0,1.0,1.0,23.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
1615,2197,aout_volume_SetVolume,1,aout_volume_SetVolume,"void aout_volume_SetVolume (aout_volume_t*,float)",audio_output\volume.c,"void aout_volume_SetVolume(aout_volume_t *vol, float factor)
{
    if (unlikely(vol == NULL))
        return;

    vol->output_factor = factor;
}",121.0,127.0,1.0,1.0,7.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
1616,2203,aout_volume_Amplify,1,aout_volume_Amplify,"int aout_volume_Amplify (aout_volume_t*,block_t*)",audio_output\volume.c,"int aout_volume_Amplify(aout_volume_t *vol, block_t *block)
{
    if (unlikely(vol == NULL) || vol->module == NULL)
        return -1;

    float amp = vol->output_factor
              * vlc_atomic_load_float (&vol->gain_factor);

    vol->object.amplify(&vol->object, block, amp);
    return 0;
}",132.0,142.0,1.0,1.0,11.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
1617,2209,aout_volume_Delete,1,aout_volume_Delete,void aout_volume_Delete (aout_volume_t*),audio_output\volume.c,"void aout_volume_Delete(aout_volume_t *vol)
{
    if (vol == NULL)
        return;

    audio_volume_t *obj = &vol->object;

    if (vol->module != NULL)
        module_unneed(obj, vol->module);
    var_DelCallback(obj->obj.parent, ""audio-replay-gain-mode"",
                    ReplayGainCallback, vol);
    vlc_object_release(obj);
}",107.0,119.0,1.0,1.0,13.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1618,2214,aout_New,1,aout_New,audio_output_t* aout_New (vlc_object_t*),audio_output\output.c,"audio_output_t *aout_New (vlc_object_t *parent)
{
    vlc_value_t val, text;

    audio_output_t *aout = vlc_custom_create (parent, sizeof (aout_instance_t),
                                              ""audio output"");
    if (unlikely(aout == NULL))
        return NULL;

    aout_owner_t *owner = aout_owner (aout);

    vlc_mutex_init (&owner->lock);
    vlc_mutex_init (&owner->req.lock);
    vlc_mutex_init (&owner->dev.lock);
    vlc_mutex_init (&owner->vp.lock);
    vlc_viewpoint_init (&owner->vp.value);
    atomic_init (&owner->vp.update, false);
    owner->req.device = (char *)unset_str;
    owner->req.volume = -1.f;
    owner->req.mute = -1;

    vlc_object_set_destructor (aout, aout_Destructor);

    /* Audio output module callbacks */
    var_Create (aout, ""volume"", VLC_VAR_FLOAT);
    var_AddCallback (aout, ""volume"", var_Copy, parent);
    var_Create (aout, ""mute"", VLC_VAR_BOOL | VLC_VAR_DOINHERIT);
    var_AddCallback (aout, ""mute"", var_Copy, parent);
    var_Create (aou...",197.0,354.0,1.0,27.0,158.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,audio_output_t
1619,2219,aout_Destroy,1,aout_Destroy,void aout_Destroy (audio_output_t*),audio_output\output.c,"void aout_Destroy (audio_output_t *aout)
{
    aout_owner_t *owner = aout_owner (aout);

    aout_OutputLock (aout);
    module_unneed (aout, owner->module);
    /* Protect against late call from intf.c */
    aout->volume_set = NULL;
    aout->mute_set = NULL;
    aout->device_select = NULL;
    aout_OutputUnlock (aout);

    var_DelCallback (aout, ""viewpoint"", ViewpointCallback, NULL);
    var_DelCallback (aout, ""audio-filter"", FilterCallback, NULL);
    var_DelCallback (aout, ""device"", var_CopyDevice, aout->obj.parent);
    var_DelCallback (aout, ""mute"", var_Copy, aout->obj.parent);
    var_SetFloat (aout, ""volume"", -1.f);
    var_DelCallback (aout, ""volume"", var_Copy, aout->obj.parent);
    var_DelCallback (aout, ""stereo-mode"", StereoModeCallback, NULL);
    vlc_object_release (aout);
}",359.0,379.0,1.0,1.0,21.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,void
1620,2224,aout_OutputNew,1,aout_OutputNew,"int aout_OutputNew (audio_output_t*,audio_sample_format_t*,aout_filters_cfg_t*)",audio_output\output.c,"int aout_OutputNew (audio_output_t *aout, audio_sample_format_t *restrict fmt,
                    aout_filters_cfg_t *filters_cfg)
{
    aout_OutputAssertLocked (aout);

    audio_channel_type_t input_chan_type = fmt->channel_type;
    int i_forced_stereo_mode = AOUT_VAR_CHAN_UNSET;
    unsigned i_nb_input_channels = fmt->i_channels;

    /* Ideally, the audio filters would be created before the audio output,
     * and the ideal audio format would be the output of the filters chain.
     * But that scheme would not really play well with digital pass-through. */
    if (AOUT_FMT_LINEAR(fmt))
    {
        if (fmt->channel_type == AUDIO_CHANNEL_TYPE_BITMAP
         && aout_FormatNbChannels(fmt) == 0)
        {
            /* The output channel map is unknown, use the WAVE one. */
            assert(fmt->i_channels > 0);
            aout_SetWavePhysicalChannels(fmt);
        }

        if (fmt->channel_type == AUDIO_CHANNEL_TYPE_AMBISONICS)
        {
            /* Set the maximum of...",517.0,580.0,1.0,1.0,64.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,int
1621,2231,aout_OutputTimeGet,1,aout_OutputTimeGet,"int aout_OutputTimeGet (audio_output_t*,mtime_t*)",audio_output\output.c,"int aout_OutputTimeGet (audio_output_t *aout, mtime_t *delay)
{
    aout_OutputAssertLocked (aout);

    if (aout->time_get == NULL)
        return -1;
    return aout->time_get (aout, delay);
}",595.0,602.0,1.0,1.0,8.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,int
1622,2237,aout_OutputPlay,1,aout_OutputPlay,"void aout_OutputPlay (audio_output_t*,block_t*)",audio_output\output.c,"void aout_OutputPlay (audio_output_t *aout, block_t *block)
{
    aout_OutputAssertLocked (aout);
#ifndef NDEBUG
    aout_owner_t *owner = aout_owner (aout);
    assert (owner->mixer_format.i_frame_length > 0);
    assert (block->i_buffer == 0 || block->i_buffer / block->i_nb_samples ==
            owner->mixer_format.i_bytes_per_frame /
            owner->mixer_format.i_frame_length);
#endif
    aout->play (aout, block);
}",609.0,620.0,1.0,1.0,12.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
1623,2243,aout_OutputPause,1,aout_OutputPause,"void aout_OutputPause (audio_output_t*,ANY,ANY)",audio_output\output.c,"void aout_OutputPause( audio_output_t *aout, bool pause, mtime_t date )
{
    aout_OutputAssertLocked (aout);
    ((aout->pause != NULL) ? aout->pause : PauseDefault) (aout, pause, date);
}",636.0,640.0,1.0,1.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
1624,2250,aout_OutputFlush,1,aout_OutputFlush,"void aout_OutputFlush (audio_output_t*,ANY)",audio_output\output.c,"void aout_OutputFlush( audio_output_t *aout, bool wait )
{
    aout_OutputAssertLocked( aout );
    aout->flush (aout, wait);
}",650.0,654.0,1.0,1.0,5.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,void
1625,2256,aout_OutputDelete,1,aout_OutputDelete,void aout_OutputDelete (audio_output_t*),audio_output\output.c,"void aout_OutputDelete (audio_output_t *aout)
{
    aout_OutputAssertLocked (aout);

    if (aout->stop != NULL)
        aout->stop (aout);
}",587.0,593.0,1.0,1.0,7.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
1626,2261,aout_OutputLock,1,aout_OutputLock,void aout_OutputLock (audio_output_t*),audio_output\output.c,"void aout_OutputLock (audio_output_t *aout)
{
    aout_owner_t *owner = aout_owner (aout);

    vlc_mutex_lock (&owner->lock);
}",674.0,679.0,1.0,1.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1627,2266,aout_OutputUnlock,1,aout_OutputUnlock,void aout_OutputUnlock (audio_output_t*),audio_output\output.c,"void aout_OutputUnlock (audio_output_t *aout)
{
    aout_owner_t *owner = aout_owner (aout);

    vlc_assert_locked (&owner->lock);
    vlc_mutex_lock (&owner->req.lock);

    if (owner->req.device != unset_str)
    {
        aout_OutputDeviceSet (aout, owner->req.device);
        free (owner->req.device);
        owner->req.device = (char *)unset_str;
    }

    if (owner->req.volume >= 0.f)
    {
        aout_OutputVolumeSet (aout, owner->req.volume);
        owner->req.volume = -1.f;
    }

    if (owner->req.mute >= 0)
    {
        aout_OutputMuteSet (aout, owner->req.mute);
        owner->req.mute = -1;
    }

    vlc_mutex_unlock (&owner->lock);
    /* If another thread is blocked waiting for owner->req.lock at this point,
     * this aout_OutputUnlock() call will not see and apply its change request.
     * The other thread will need to apply the change request itself, which
     * implies it is able to (try-)lock owner->lock. Therefore this thread must
     * release owner-...",688.0,721.0,1.0,4.0,34.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,void
1628,2271,aout_FormatsPrint,1,aout_FormatsPrint,"void aout_FormatsPrint (vlc_object_t*,char*,audio_sample_format_t*,audio_sample_format_t*)",audio_output\common.c,"void aout_FormatsPrint( vlc_object_t *obj, const char * psz_text,
                        const audio_sample_format_t * p_format1,
                        const audio_sample_format_t * p_format2 )
{
    msg_Dbg( obj, ""%s '%4.4s'->'%4.4s' %d Hz->%d Hz %s->%s"",
             psz_text,
             (char *)&p_format1->i_format, (char *)&p_format2->i_format,
             p_format1->i_rate, p_format2->i_rate,
             aout_FormatPrintChannels( p_format1 ),
             aout_FormatPrintChannels( p_format2 ) );
}",242.0,252.0,1.0,1.0,11.0,0,0,0,0,2,0,1,1,0,0,,0,0,8,4,4,void
1629,2279,aout_ChangeFilterString,1,aout_ChangeFilterString,"bool aout_ChangeFilterString (vlc_object_t*,vlc_object_t*,char*,char*,bool)",audio_output\common.c,"bool aout_ChangeFilterString( vlc_object_t *p_obj, vlc_object_t *p_aout,
                              const char *psz_variable,
                              const char *psz_name, bool b_add )
{
    if( *psz_name == '\0' )
        return false;

    char *psz_list;
    if( p_aout )
    {
        psz_list = var_GetString( p_aout, psz_variable );
    }
    else
    {
        psz_list = var_InheritString( p_obj, psz_variable );
    }

    /* Split the string into an array of filters */
    int i_count = 1;
    for( char *p = psz_list; p && *p; p++ )
        i_count += *p == ':';
    i_count += b_add;

    const char **ppsz_filter = calloc( i_count, sizeof(*ppsz_filter) );
    if( !ppsz_filter )
    {
        free( psz_list );
        return false;
    }
    bool b_present = false;
    i_count = 0;
    for( char *p = psz_list; p && *p; )
    {
        char *psz_end = strchr(p, ':');
        if( psz_end )
            *psz_end++ = '\0';
        else
            psz_end = p + strlen(p);
 ...",543.0,648.0,1.0,1.0,106.0,0,0,0,0,1,0,1,1,0,0,,0,0,10,5,5,bool
1630,2288,aout_DecNew,1,aout_DecNew,"int aout_DecNew (audio_output_t*,audio_sample_format_t*,audio_replay_gain_t*,aout_request_vout_t*)",audio_output\dec.c,"int aout_DecNew( audio_output_t *p_aout,
                 const audio_sample_format_t *p_format,
                 const audio_replay_gain_t *p_replay_gain,
                 const aout_request_vout_t *p_request_vout )
{
    if( p_format->i_bitspersample > 0 )
    {
        /* Sanitize audio format, input need to have a valid physical channels
         * layout or a valid number of channels. */
        int i_map_channels = aout_FormatNbChannels( p_format );
        if( ( i_map_channels == 0 && p_format->i_channels == 0 )
           || i_map_channels > AOUT_CHAN_MAX || p_format->i_channels > INPUT_CHAN_MAX )
        {
            msg_Err( p_aout, ""invalid audio channels count"" );
            return -1;
        }
    }

    if( p_format->i_rate > 384000 )
    {
        msg_Err( p_aout, ""excessive audio sample frequency (%u)"",
                 p_format->i_rate );
        return -1;
    }
    if( p_format->i_rate < 4000 )
    {
        msg_Err( p_aout, ""too low audio sample frequency (%u)...",43.0,119.0,1.0,20.0,77.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,int
1631,2296,aout_DecDelete,1,aout_DecDelete,void aout_DecDelete (audio_output_t*),audio_output\dec.c,"void aout_DecDelete (audio_output_t *aout)
{
    aout_owner_t *owner = aout_owner (aout);

    aout_OutputLock (aout);
    if (owner->mixer_format.i_format)
    {
        aout_FiltersDelete (aout, owner->filters);
        aout_OutputDelete (aout);
    }
    aout_volume_Delete (owner->volume);
    owner->volume = NULL;
    aout_OutputUnlock (aout);
}",124.0,137.0,1.0,1.0,14.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,void
1632,2301,aout_DecPlay,1,aout_DecPlay,"int aout_DecPlay (audio_output_t*,block_t*,int)",audio_output\dec.c,"int aout_DecPlay (audio_output_t *aout, block_t *block, int input_rate)
{
    aout_owner_t *owner = aout_owner (aout);

    assert (input_rate >= INPUT_RATE_DEFAULT / AOUT_MAX_INPUT_RATE);
    assert (input_rate <= INPUT_RATE_DEFAULT * AOUT_MAX_INPUT_RATE);
    assert (block->i_pts >= VLC_TS_0);

    block->i_length = CLOCK_FREQ * block->i_nb_samples
                                 / owner->input_format.i_rate;

    aout_OutputLock (aout);
    int ret = aout_CheckReady (aout);
    if (unlikely(ret == AOUT_DEC_FAILED))
        goto drop; /* Pipeline is unrecoverably broken :-( */

    const mtime_t now = mdate (), advance = block->i_pts - now;
    if (advance < -AOUT_MAX_PTS_DELAY)
    {   /* Late buffer can be caused by bugs in the decoder, by scheduling
         * latency spikes (excessive load, SIGSTOP, etc.) or if buffering is
         * insufficient. We assume the PTS is wrong and play the buffer anyway:
         * Hopefully video has encountered a similar PTS problem as audio....",357.0,421.0,1.0,47.0,65.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,int
1633,2308,aout_DecGetResetStats,1,aout_DecGetResetStats,"void aout_DecGetResetStats (audio_output_t*,unsigned*,unsigned*)",audio_output\dec.c,"void aout_DecGetResetStats(audio_output_t *aout, unsigned *restrict lost,
                           unsigned *restrict played)
{
    aout_owner_t *owner = aout_owner (aout);

    *lost = atomic_exchange(&owner->buffers_lost, 0);
    *played = atomic_exchange(&owner->buffers_played, 0);
}",423.0,430.0,1.0,1.0,8.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
1634,2315,aout_DecChangePause,1,aout_DecChangePause,"void aout_DecChangePause (audio_output_t*,bool,mtime_t)",audio_output\dec.c,"void aout_DecChangePause (audio_output_t *aout, bool paused, mtime_t date)
{
    aout_owner_t *owner = aout_owner (aout);

    aout_OutputLock (aout);
    if (owner->sync.end != VLC_TS_INVALID)
    {
        if (paused)
            owner->sync.end -= date;
        else
            owner->sync.end += date;
    }
    if (owner->mixer_format.i_format)
        aout_OutputPause (aout, paused, date);
    aout_OutputUnlock (aout);
}",432.0,447.0,1.0,1.0,16.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
1635,2322,aout_DecFlush,1,aout_DecFlush,"void aout_DecFlush (audio_output_t*,bool)",audio_output\dec.c,"void aout_DecFlush (audio_output_t *aout, bool wait)
{
    aout_owner_t *owner = aout_owner (aout);

    aout_OutputLock (aout);
    owner->sync.end = VLC_TS_INVALID;
    if (owner->mixer_format.i_format)
    {
        if (wait)
        {
            block_t *block = aout_FiltersDrain (owner->filters);
            if (block)
                aout_OutputPlay (aout, block);
        }
        else
            aout_FiltersFlush (owner->filters);
        aout_OutputFlush (aout, wait);
    }
    aout_OutputUnlock (aout);
}",449.0,468.0,1.0,1.0,20.0,0,0,0,0,4,0,1,1,0,0,,0,0,4,2,2,void
1636,2328,aout_RequestRestart,1,aout_RequestRestart,"void aout_RequestRestart (audio_output_t*,unsigned)",audio_output\dec.c,"void aout_RequestRestart (audio_output_t *aout, unsigned mode)
{
    aout_owner_t *owner = aout_owner (aout);
    atomic_fetch_or (&owner->restart, mode);
    msg_Dbg (aout, ""restart requested (%u)"", mode);
}",197.0,202.0,1.0,1.0,6.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,void
1637,2334,aout_InputRequestRestart,1,aout_InputRequestRestart,void aout_InputRequestRestart (audio_output_t*),audio_output\aout_internal.h,"static inline void aout_InputRequestRestart(audio_output_t *aout)
{
    aout_RequestRestart(aout, AOUT_RESTART_FILTERS);
}",162.0,165.0,1.0,1.0,4.0,0,0,2,2,2,1,1,1,0,1,,0,0,2,1,1,void
1638,2342,aout_SetWavePhysicalChannels,1,aout_SetWavePhysicalChannels,void aout_SetWavePhysicalChannels (audio_sample_format_t*),audio_output\aout_internal.h,"static inline void aout_SetWavePhysicalChannels(audio_sample_format_t *fmt)
{
    static const uint32_t wave_channels[] = {
        AOUT_CHAN_LEFT, AOUT_CHAN_RIGHT, AOUT_CHAN_CENTER,
        AOUT_CHAN_LFE, AOUT_CHAN_REARLEFT, AOUT_CHAN_REARRIGHT,
        AOUT_CHAN_MIDDLELEFT, AOUT_CHAN_MIDDLERIGHT, AOUT_CHAN_REARCENTER };

    fmt->i_physical_channels = 0;
    for (int i = 0; i < fmt->i_channels && i < AOUT_CHAN_MAX; ++i)
        fmt->i_physical_channels |= wave_channels[i];
    aout_FormatPrepare(fmt);
}",167.0,178.0,1.0,1.0,12.0,9,5,17,13,1,1,2,2,0,1,,0,0,2,1,1,void
1639,2391,aout_FiltersCanResample,1,aout_FiltersCanResample,bool aout_FiltersCanResample (aout_filters_t*),audio_output\filters.c,"bool aout_FiltersCanResample (aout_filters_t *filters)
{
    return (filters->resampler != NULL);
}",682.0,685.0,1.0,1.0,4.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,bool
1640,2396,aout_ChangeViewpoint,1,aout_ChangeViewpoint,"void aout_ChangeViewpoint (audio_output_t*,vlc_viewpoint_t*)",audio_output\dec.c,"void aout_ChangeViewpoint(audio_output_t *aout,
                          const vlc_viewpoint_t *p_viewpoint)
{
    aout_owner_t *owner = aout_owner (aout);

    vlc_mutex_lock (&owner->vp.lock);
    owner->vp.value = *p_viewpoint;
    atomic_store(&owner->vp.update, true);
    vlc_mutex_unlock (&owner->vp.lock);
}",470.0,479.0,1.0,1.0,10.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
1641,2419,aout_BitsPerSample,1,aout_BitsPerSample,unsigned int aout_BitsPerSample (vlc_fourcc_t),audio_output\common.c,"unsigned int aout_BitsPerSample( vlc_fourcc_t i_format )
{
    switch( vlc_fourcc_GetCodec( AUDIO_ES, i_format ) )
    {
    case VLC_CODEC_U8:
    case VLC_CODEC_S8:
    case VLC_CODEC_ALAW:
    case VLC_CODEC_MULAW:
        return 8;

    case VLC_CODEC_U16L:
    case VLC_CODEC_S16L:
    case VLC_CODEC_U16B:
    case VLC_CODEC_S16B:
        return 16;

    case VLC_CODEC_U24L:
    case VLC_CODEC_S24L:
    case VLC_CODEC_U24B:
    case VLC_CODEC_S24B:
        return 24;

    case VLC_CODEC_S24L32:
    case VLC_CODEC_S24B32:
    case VLC_CODEC_U32L:
    case VLC_CODEC_U32B:
    case VLC_CODEC_S32L:
    case VLC_CODEC_S32B:
    case VLC_CODEC_F32L:
    case VLC_CODEC_F32B:
        return 32;

    case VLC_CODEC_F64L:
    case VLC_CODEC_F64B:
        return 64;

    default:
        /* For these formats the caller has to indicate the parameters
         * by hand. */
        return 0;
    }
}",42.0,83.0,1.0,1.0,42.0,0,0,24,24,2,1,2,2,1,1,,0,1,2,1,1,unsigned int
1642,2486,aout_FormatPrepare,1,aout_FormatPrepare,void aout_FormatPrepare (audio_sample_format_t*),audio_output\common.c,"void aout_FormatPrepare( audio_sample_format_t * p_format )
{

    unsigned i_channels = aout_FormatNbChannels( p_format );
    if( i_channels > 0 )
        p_format->i_channels = i_channels;
    p_format->i_bitspersample = aout_BitsPerSample( p_format->i_format );
    if( p_format->i_bitspersample > 0 )
    {
        p_format->i_bytes_per_frame = ( p_format->i_bitspersample / 8 )
                                    * p_format->i_channels;
        p_format->i_frame_length = 1;
    }
}",88.0,101.0,1.0,1.0,14.0,17,5,12,2,6,1,3,3,0,1,,0,1,2,1,1,void
1643,2539,aout_FormatPrintChannels,1,aout_FormatPrintChannels,const char* aout_FormatPrintChannels (audio_sample_format_t*),audio_output\common.c,"const char * aout_FormatPrintChannels( const audio_sample_format_t * p_format )
{
    if (p_format->channel_type == AUDIO_CHANNEL_TYPE_AMBISONICS)
        return ""Ambisonics"";

    /* AUDIO_CHANNEL_TYPE_BITMAP */
    switch ( p_format->i_physical_channels )
    {
    case AOUT_CHAN_LEFT:
    case AOUT_CHAN_RIGHT:
    case AOUT_CHAN_CENTER:
        if ( (p_format->i_physical_channels & AOUT_CHAN_CENTER)
              || (p_format->i_physical_channels
                   & (AOUT_CHAN_LEFT | AOUT_CHAN_RIGHT)) )
            return ""Mono"";
        else if ( p_format->i_physical_channels & AOUT_CHAN_LEFT )
            return ""Left"";
        return ""Right"";
    case AOUT_CHAN_LEFT | AOUT_CHAN_RIGHT:
        if ( p_format->i_chan_mode & AOUT_CHANMODE_DOLBYSTEREO )
            return ""Dolby"";
        else if ( p_format->i_chan_mode & AOUT_CHANMODE_DUALMONO )
            return ""Dual-mono"";
        else if ( p_format->i_physical_channels == AOUT_CHAN_CENTER )
            return ""Stereo/Mono"";
...",106.0,223.0,1.0,1.0,118.0,110,5,134,12,1,0,7,11,0,0,,0,0,2,1,1,const char*
1644,3008,aout_FormatPrint,1,aout_FormatPrint,"void aout_FormatPrint (vlc_object_t*,char*,audio_sample_format_t*)",audio_output\common.c,"void aout_FormatPrint( vlc_object_t *obj, const char *psz_text,
                       const audio_sample_format_t *p_format )
{
    msg_Dbg( obj, ""%s '%4.4s' %d Hz %s frame=%d samples/%d bytes"", psz_text,
             (char *)&p_format->i_format, p_format->i_rate,
             aout_FormatPrintChannels( p_format ),
             p_format->i_frame_length, p_format->i_bytes_per_frame );
}",229.0,236.0,1.0,1.0,8.0,6,3,7,3,1,1,1,1,0,1,,0,0,6,3,3,void
1645,3070,aout_CheckChannelReorder,1,aout_CheckChannelReorder,"unsigned aout_CheckChannelReorder (uint32_t*,uint32_t*,uint32_t,uint8_t*)",audio_output\common.c,"unsigned aout_CheckChannelReorder( const uint32_t *chans_in,
                                   const uint32_t *chans_out,
                                   uint32_t mask, uint8_t *restrict table )
{
    static_assert(AOUT_CHAN_MAX <= (sizeof (mask) * CHAR_BIT), ""Missing bits"");

    unsigned channels = 0;

    if( chans_in == NULL )
        chans_in = pi_vlc_chan_order_wg4;
    if( chans_out == NULL )
        chans_out = pi_vlc_chan_order_wg4;

    for( unsigned i = 0; chans_in[i]; i++ )
    {
        const uint32_t chan = chans_in[i];
        if( !(mask & chan) )
            continue;

        unsigned index = 0;
        for( unsigned j = 0; chan != chans_out[j]; j++ )
            if( mask & chans_out[j] )
                index++;

        table[channels++] = index;
    }

    for( unsigned i = 0; i < channels; i++ )
        if( table[i] != i )
            return channels;
    return 0;
}",257.0,288.0,1.0,1.0,32.0,23,11,31,13,0,0,8,9,0,0,,0,0,8,4,4,unsigned
1646,3185,aout_ChannelReorder,1,aout_ChannelReorder,"void aout_ChannelReorder (void*,size_t,uint8_t,uint8_t*,vlc_fourcc_t)",audio_output\common.c,"void aout_ChannelReorder( void *ptr, size_t bytes, uint8_t channels,
                          const uint8_t *restrict chans_table, vlc_fourcc_t fourcc )
{
    if( unlikely(bytes == 0) )
        return;

    assert( channels != 0 );

    /* The audio formats supported in audio output are inlined. For other
     * formats (used in demuxers and muxers), memcpy() is used to avoid
     * breaking type punning. */
#define REORDER_TYPE(type) \
do { \
    const size_t frames = (bytes / sizeof (type)) / channels; \
    type *buf = ptr; \
\
    for( size_t i = 0; i < frames; i++ ) \
    { \
        type tmp[AOUT_CHAN_MAX]; \
\
        for( size_t j = 0; j < channels; j++ ) \
            tmp[chans_table[j]] = buf[j]; \
        memcpy( buf, tmp, sizeof (type) * channels ); \
        buf += channels; \
    } \
} while(0)

    if( likely(channels <= AOUT_CHAN_MAX) )
    {
        switch( fourcc )
        {
            case VLC_CODEC_U8:   REORDER_TYPE(uint8_t); return;
            case VLC_CODEC...",301.0,355.0,1.0,33.0,55.0,109,12,163,27,0,1,6,8,0,1,,0,1,10,5,5,void
1647,3630,aout_Interleave,1,aout_Interleave,"void aout_Interleave (void*,void**,unsigned,unsigned,vlc_fourcc_t)",audio_output\common.c,"void aout_Interleave( void *restrict dst, const void *const *srcv,
                      unsigned samples, unsigned chans, vlc_fourcc_t fourcc )
{
#define INTERLEAVE_TYPE(type) \
do { \
    type *d = dst; \
    for( size_t i = 0; i < chans; i++ ) { \
        const type *s = srcv[i]; \
        for( size_t j = 0, k = 0; j < samples; j++, k += chans ) \
            d[k] = *(s++); \
        d++; \
    } \
} while(0)

    switch( fourcc )
    {
        case VLC_CODEC_U8:   INTERLEAVE_TYPE(uint8_t);  break;
        case VLC_CODEC_S16N: INTERLEAVE_TYPE(int16_t);  break;
        case VLC_CODEC_FL32: INTERLEAVE_TYPE(float);    break;
        case VLC_CODEC_S32N: INTERLEAVE_TYPE(int32_t);  break;
        case VLC_CODEC_FL64: INTERLEAVE_TYPE(double);   break;
        default:             vlc_assert_unreachable();
    }
#undef INTERLEAVE_TYPE
}",367.0,391.0,1.0,29.0,25.0,85,7,106,20,0,0,7,2,0,0,,0,0,10,5,5,void
1648,3944,aout_Deinterleave,1,aout_Deinterleave,"void aout_Deinterleave (void*,void*,unsigned,unsigned,vlc_fourcc_t)",audio_output\common.c,"void aout_Deinterleave( void *restrict dst, const void *restrict src,
                      unsigned samples, unsigned chans, vlc_fourcc_t fourcc )
{
#define DEINTERLEAVE_TYPE(type) \
do { \
    type *d = dst; \
    const type *s = src; \
    for( size_t i = 0; i < chans; i++ ) { \
        for( size_t j = 0, k = 0; j < samples; j++, k += chans ) \
            *(d++) = s[k]; \
        s++; \
    } \
} while(0)

    switch( fourcc )
    {
        case VLC_CODEC_U8:   DEINTERLEAVE_TYPE(uint8_t);  break;
        case VLC_CODEC_S16N: DEINTERLEAVE_TYPE(int16_t);  break;
        case VLC_CODEC_FL32: DEINTERLEAVE_TYPE(float);    break;
        case VLC_CODEC_S32N: DEINTERLEAVE_TYPE(int32_t);  break;
        case VLC_CODEC_FL64: DEINTERLEAVE_TYPE(double);   break;
        default:             vlc_assert_unreachable();
    }
#undef DEINTERLEAVE_TYPE
}",403.0,427.0,1.0,29.0,25.0,80,7,101,20,0,0,7,2,0,0,,0,0,10,5,5,void
1649,4248,ExtractChannel,1,ExtractChannel,"void ExtractChannel (uint8_t*,int,uint8_t*,int,int,int*,int)",audio_output\common.c,"static inline void ExtractChannel( uint8_t *pi_dst, int i_dst_channels,
                                   const uint8_t *pi_src, int i_src_channels,
                                   int i_sample_count,
                                   const int *pi_selection, int i_bytes )
{
    for( int i = 0; i < i_sample_count; i++ )
    {
        for( int j = 0; j < i_dst_channels; j++ )
            memcpy( &pi_dst[j * i_bytes], &pi_src[pi_selection[j] * i_bytes], i_bytes );
        pi_dst += i_dst_channels * i_bytes;
        pi_src += i_src_channels * i_bytes;
    }
}",432.0,444.0,1.0,1.0,13.0,8,4,12,8,1,0,3,4,0,0,,0,0,14,7,7,void
1650,4308,aout_ChannelExtract,1,aout_ChannelExtract,"void aout_ChannelExtract (void*,int,void*,int,int,int*,int)",audio_output\common.c,"void aout_ChannelExtract( void *p_dst, int i_dst_channels,
                          const void *p_src, int i_src_channels,
                          int i_sample_count, const int *pi_selection, int i_bits_per_sample )
{
    /* It does not work in place */
    assert( p_dst != p_src );

    /* Force the compiler to inline for the specific cases so it can optimize */
    if( i_bits_per_sample == 8 )
        ExtractChannel( p_dst, i_dst_channels, p_src, i_src_channels, i_sample_count, pi_selection, 1 );
    else  if( i_bits_per_sample == 16 )
        ExtractChannel( p_dst, i_dst_channels, p_src, i_src_channels, i_sample_count, pi_selection, 2 );
    else  if( i_bits_per_sample == 32 )
        ExtractChannel( p_dst, i_dst_channels, p_src, i_src_channels, i_sample_count, pi_selection, 4 );
    else  if( i_bits_per_sample == 64 )
        ExtractChannel( p_dst, i_dst_channels, p_src, i_src_channels, i_sample_count, pi_selection, 8 );
}",446.0,462.0,1.0,1.0,17.0,2,2,9,7,0,1,2,2,0,1,,0,0,14,7,7,void
1651,4381,aout_CheckChannelExtraction,1,aout_CheckChannelExtraction,"bool aout_CheckChannelExtraction (int*,uint32_t*,int*,uint32_t[AOUT_CHAN_MAX],uint32_t*,int)",audio_output\common.c,"bool aout_CheckChannelExtraction( int *pi_selection,
                                  uint32_t *pi_layout, int *pi_channels,
                                  const uint32_t pi_order_dst[AOUT_CHAN_MAX],
                                  const uint32_t *pi_order_src, int i_channels )
{
    static_assert(AOUT_CHAN_MAX <= (sizeof (*pi_order_dst) * CHAR_BIT),
                  ""Missing bits"");

    uint32_t i_layout = 0;
    int i_out = 0;
    int pi_index[AOUT_CHAN_MAX];

    /* */
    if( !pi_order_dst )
        pi_order_dst = pi_vlc_chan_order_wg4;

    /* */
    for( int i = 0; i < i_channels; i++ )
    {
        /* Ignore unknown or duplicated channels or not present in output */
        if( !pi_order_src[i] || (i_layout & pi_order_src[i]) )
            continue;

        for( int j = 0; j < AOUT_CHAN_MAX; j++ )
        {
            if( pi_order_dst[j] == pi_order_src[i] )
            {
                assert( i_out < AOUT_CHAN_MAX );
                pi_index[i_out++] = i;
      ...",464.0,521.0,1.0,1.0,58.0,47,13,60,16,0,0,14,19,0,0,,0,0,12,6,6,bool
1652,4559,FilterOrder,1,FilterOrder,int FilterOrder (char*),audio_output\common.c,"static int FilterOrder( const char *psz_name )
{
    static const struct {
        const char psz_name[10];
        int        i_order;
    } filter[] = {
        { ""equalizer"",  0 },
    };
    for( unsigned i = 0; i < ARRAY_SIZE(filter); i++ )
    {
        if( !strcmp( filter[i].psz_name, psz_name ) )
            return filter[i].i_order;
    }
    return INT_MAX;
}",524.0,538.0,1.0,1.0,15.0,10,6,10,4,0,0,3,4,0,0,,0,0,2,1,1,int
1653,5238,aout_CheckReady,1,aout_CheckReady,int aout_CheckReady (audio_output_t*),audio_output\dec.c,"static int aout_CheckReady (audio_output_t *aout)
{
    aout_owner_t *owner = aout_owner (aout);

    int status = AOUT_DEC_SUCCESS;
    int restart = atomic_exchange (&owner->restart, 0);
    if (unlikely(restart))
    {
        if (owner->mixer_format.i_format)
            aout_FiltersDelete (aout, owner->filters);

        if (restart & AOUT_RESTART_OUTPUT)
        {   /* Reinitializes the output */
            msg_Dbg (aout, ""restarting output..."");
            if (owner->mixer_format.i_format)
                aout_OutputDelete (aout);
            owner->mixer_format = owner->input_format;
            owner->filters_cfg = AOUT_FILTERS_CFG_INIT;
            if (aout_OutputNew (aout, &owner->mixer_format, &owner->filters_cfg))
                owner->mixer_format.i_format = 0;
            aout_volume_SetFormat (owner->volume,
                                   owner->mixer_format.i_format);

            /* Notify the decoder that the aout changed in order to try a new
             ...",139.0,191.0,1.0,17.0,53.0,54,7,46,10,0,28,9,20,7,7,,0,24,2,1,1,int
1654,5440,aout_StopResampling,1,aout_StopResampling,void aout_StopResampling (audio_output_t*),audio_output\dec.c,"static void aout_StopResampling (audio_output_t *aout)
{
    aout_owner_t *owner = aout_owner (aout);

    owner->sync.resamp_type = AOUT_RESAMPLING_NONE;
    aout_FiltersAdjustResampling (owner->filters, 0);
}",208.0,214.0,1.0,1.0,7.0,5,3,5,3,3,3,1,1,0,2,,0,2,2,1,1,void
1655,5462,aout_DecSilence,1,aout_DecSilence,"void aout_DecSilence (audio_output_t*,mtime_t,mtime_t)",audio_output\dec.c,"static void aout_DecSilence (audio_output_t *aout, mtime_t length, mtime_t pts)
{
    aout_owner_t *owner = aout_owner (aout);
    const audio_sample_format_t *fmt = &owner->mixer_format;
    size_t frames = (fmt->i_rate * length) / CLOCK_FREQ;

    block_t *block = block_Alloc (frames * fmt->i_bytes_per_frame
                                  / fmt->i_frame_length);
    if (unlikely(block == NULL))
        return; /* uho! */

    msg_Dbg (aout, ""inserting %zu zeroes"", frames);
    memset (block->p_buffer, 0, block->i_buffer);
    block->i_nb_samples = frames;
    block->i_pts = pts;
    block->i_dts = pts;
    block->i_length = length;
    aout_OutputPlay (aout, block);
}",216.0,234.0,1.0,1.0,19.0,24,6,28,9,1,4,2,2,0,3,,0,3,6,3,3,void
1656,5546,aout_DecSynchronize,1,aout_DecSynchronize,"void aout_DecSynchronize (audio_output_t*,mtime_t,int)",audio_output\dec.c,"static void aout_DecSynchronize (audio_output_t *aout, mtime_t dec_pts,
                                 int input_rate)
{
    aout_owner_t *owner = aout_owner (aout);
    mtime_t drift;

    /**
     * Depending on the drift between the actual and intended playback times,
     * the audio core may ignore the drift, trigger upsampling or downsampling,
     * insert silence or even discard samples.
     * Future VLC versions may instead adjust the input rate.
     *
     * The audio output plugin is responsible for estimating its actual
     * playback time, or rather the estimated time when the next sample will
     * be played. (The actual playback time is always the current time, that is
     * to say mdate(). It is not an useful statistic.)
     *
     * Most audio output plugins can estimate the delay until playback of
     * the next sample to be written to the buffer, or equally the time until
     * all samples in the buffer will have been played. Then:
     *    pts = mdate(...",236.0,352.0,1.0,1.0,117.0,89,19,66,15,0,14,12,13,6,12,,0,7,6,3,3,void
1657,6233,CreateFilter,1,CreateFilter,"filter_t CreateFilter (vlc_object_t*,char*,char*,filter_owner_sys_t*,audio_sample_format_t*,audio_sample_format_t*,config_chain_t*,bool)",misc\image.c,"static filter_t *CreateFilter( vlc_object_t *p_this, const es_format_t *p_fmt_in,
                               const video_format_t *p_fmt_out )
{
    filter_t *p_filter;

    p_filter = vlc_custom_create( p_this, sizeof(filter_t), ""filter"" );
    p_filter->owner.video.buffer_new = filter_new_picture;

    es_format_Copy( &p_filter->fmt_in, p_fmt_in );
    es_format_Copy( &p_filter->fmt_out, p_fmt_in );
    video_format_Copy( &p_filter->fmt_out.video, p_fmt_out );

    /* whatever the input offset, write at offset 0 in the target image */
    p_filter->fmt_out.video.i_x_offset = 0;
    p_filter->fmt_out.video.i_y_offset = 0;

    p_filter->fmt_out.i_codec = p_fmt_out->i_chroma;
    p_filter->p_module = module_need( p_filter, ""video converter"", NULL, false );

    if( !p_filter->p_module )
    {
        msg_Dbg( p_filter, ""no video converter found"" );
        DeleteFilter( p_filter );
        return NULL;
    }

    return p_filter;
}",801.0,828.0,1.0,1.0,28.0,47,9,43,11,4,3,6,6,0,3,,0,2,6,3,3,filter_t
1658,6394,FindConverter,1,FindConverter,"filter_t FindConverter (vlc_object_t*,audio_sample_format_t*,audio_sample_format_t*)",audio_output\filters.c,"static filter_t *FindConverter (vlc_object_t *obj,
                                const audio_sample_format_t *infmt,
                                const audio_sample_format_t *outfmt)
{
    return CreateFilter (obj, ""audio converter"", NULL, NULL, infmt, outfmt,
                         NULL, true);
}",92.0,98.0,1.0,1.0,7.0,0,0,7,5,4,1,1,1,0,1,,0,0,6,3,3,filter_t
1659,6411,FindResampler,1,FindResampler,"filter_t FindResampler (vlc_object_t*,audio_sample_format_t*,audio_sample_format_t*)",audio_output\filters.c,"static filter_t *FindResampler (vlc_object_t *obj,
                                const audio_sample_format_t *infmt,
                                const audio_sample_format_t *outfmt)
{
    return CreateFilter (obj, ""audio resampler"", ""$audio-resampler"", NULL,
                         infmt, outfmt, NULL, true);
}",100.0,106.0,1.0,1.0,7.0,0,0,6,5,1,1,1,1,0,1,,0,0,6,3,3,filter_t
1660,6428,aout_FiltersPipelineDestroy,1,aout_FiltersPipelineDestroy,"void aout_FiltersPipelineDestroy (filter_t**,unsigned)",audio_output\filters.c,"static void aout_FiltersPipelineDestroy(filter_t *const *filters, unsigned n)
{
    for( unsigned i = 0; i < n; i++ )
    {
        filter_t *p_filter = filters[i];

        module_unneed( p_filter, p_filter->p_module );
        vlc_object_release( p_filter );
    }
}",111.0,120.0,1.0,1.0,10.0,5,4,9,4,4,2,2,2,0,2,,0,0,4,2,2,void
1661,6459,TryFormat,1,TryFormat,"filter_t TryFormat (vlc_object_t*,vlc_fourcc_t,audio_sample_format_t*)",audio_output\filters.c,"static filter_t *TryFormat (vlc_object_t *obj, vlc_fourcc_t codec,
                            audio_sample_format_t *restrict fmt)
{
    audio_sample_format_t output = *fmt;

    assert (codec != fmt->i_format);
    output.i_format = codec;
    aout_FormatPrepare (&output);

    filter_t *filter = FindConverter (obj, fmt, &output);
    if (filter != NULL)
        *fmt = output;
    return filter;
}",122.0,135.0,1.0,1.0,14.0,12,6,16,6,2,2,2,2,0,2,,0,1,6,3,3,filter_t
1662,6504,aout_FiltersPipelineCreate,1,aout_FiltersPipelineCreate,"int aout_FiltersPipelineCreate (vlc_object_t*,filter_t**,unsigned*,unsigned,audio_sample_format_t*,audio_sample_format_t*,bool)",audio_output\filters.c,"static int aout_FiltersPipelineCreate(vlc_object_t *obj, filter_t **filters,
                                      unsigned *count, unsigned max,
                                 const audio_sample_format_t *restrict infmt,
                                 const audio_sample_format_t *restrict outfmt,
                                 bool headphones)
{
    aout_FormatsPrint (obj, ""conversion:"", infmt, outfmt);
    max -= *count;
    filters += *count;

    /* There is a lot of second guessing on what the conversion plugins can
     * and cannot do. This seems hardly avoidable, the conversion problem need
     * to be reduced somehow. */
    audio_sample_format_t input = *infmt;
    unsigned n = 0;

    if (!AOUT_FMT_LINEAR(&input))
    {
        msg_Err(obj, ""Can't convert non linear input"");
        return -1;
    }

    /* Remix channels */
    if (infmt->i_physical_channels != outfmt->i_physical_channels
     || infmt->i_chan_mode != outfmt->i_chan_mode
     || infmt->channel_typ...",147.0,272.0,1.0,4.0,126.0,92,15,116,16,3,10,24,29,0,10,,0,4,14,7,7,int
1663,6848,aout_FiltersPipelinePlay,1,aout_FiltersPipelinePlay,"block_t aout_FiltersPipelinePlay (filter_t**,unsigned,block_t*)",audio_output\filters.c,"static block_t *aout_FiltersPipelinePlay(filter_t *const *filters,
                                         unsigned count, block_t *block)
{
    /* TODO: use filter chain */
    for (unsigned i = 0; (i < count) && (block != NULL); i++)
    {
        filter_t *filter = filters[i];

        /* Please note that p_block->i_nb_samples & i_buffer
         * shall be set by the filter plug-in. */
        block = filter->pf_audio_filter (filter, block);
    }
    return block;
}",277.0,290.0,1.0,1.0,14.0,8,6,13,6,4,0,2,2,0,0,,0,0,6,3,3,block_t
1664,6887,aout_FiltersPipelineDrain,1,aout_FiltersPipelineDrain,"block_t aout_FiltersPipelineDrain (filter_t**,unsigned)",audio_output\filters.c,"static block_t *aout_FiltersPipelineDrain(filter_t *const *filters,
                                          unsigned count)
{
    block_t *chain = NULL;

    for (unsigned i = 0; i < count; i++)
    {
        filter_t *filter = filters[i];

        block_t *block = filter_DrainAudio (filter);
        if (block)
        {
            /* If there is a drained block, filter it through the following
             * chain of filters  */
            if (i + 1 < count)
                block = aout_FiltersPipelinePlay (&filters[i + 1],
                                                  count - i - 1, block);
            if (block)
                block_ChainAppend (&chain, block);
        }
    }

    if (chain)
        return block_ChainGather(chain);
    else
        return NULL;
}",296.0,322.0,1.0,1.0,27.0,15,6,24,7,2,1,6,11,0,1,,0,1,4,2,2,block_t
1665,6962,aout_FiltersPipelineFlush,1,aout_FiltersPipelineFlush,"void aout_FiltersPipelineFlush (filter_t**,unsigned)",audio_output\filters.c,"static void aout_FiltersPipelineFlush(filter_t *const *filters,
                                      unsigned count)
{
    for (unsigned i = 0; i < count; i++)
        filter_Flush (filters[i]);
}",327.0,332.0,1.0,1.0,6.0,2,2,3,2,2,0,2,2,0,0,,0,0,4,2,2,void
1666,6983,aout_FiltersPipelineChangeViewpoint,1,aout_FiltersPipelineChangeViewpoint,"void aout_FiltersPipelineChangeViewpoint (filter_t**,unsigned,vlc_viewpoint_t*)",audio_output\filters.c,"static void aout_FiltersPipelineChangeViewpoint(filter_t *const *filters,
                                                unsigned count,
                                                const vlc_viewpoint_t *vp)
{
    for (unsigned i = 0; i < count; i++)
        filter_ChangeViewpoint (filters[i], vp);
}",334.0,340.0,1.0,1.0,7.0,2,2,3,2,1,0,2,2,0,0,,0,0,6,3,3,void
1667,7020,VisualizationCallback,1,VisualizationCallback,"int VisualizationCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",audio_output\filters.c,"static int VisualizationCallback (vlc_object_t *obj, const char *var,
                                  vlc_value_t oldval, vlc_value_t newval,
                                  void *data)
{
    const char *mode = newval.psz_string;

    if (!*mode)
        mode = ""none"";
    /* FIXME: This ugly hack enforced by visual effect-list, as is the need for
     * separate ""visual"" (external) and ""audio-visual"" (internal) variables...
     * The visual plugin should have one submodule per effect instead. */
    if (strcasecmp (mode, ""none"") && strcasecmp (mode, ""goom"")
     && strcasecmp (mode, ""projectm"") && strcasecmp (mode, ""vsxu"")
     && strcasecmp (mode, ""glspectrum""))
    {
        var_Create (obj, ""effect-list"", VLC_VAR_STRING);
        var_SetString (obj, ""effect-list"", mode);
        mode = ""visual"";
    }

    var_SetString (obj, ""audio-visual"", mode);
    aout_InputRequestRestart ((audio_output_t *)obj);
    (void) var; (void) oldval; (void) data;
    return VLC_SUCCESS;
}",357.0,381.0,1.0,1.0,25.0,14,6,21,8,0,2,3,3,0,2,,0,0,10,5,5,int
1668,7094,aout_filter_RequestVout,1,aout_filter_RequestVout,"vout_thread_t aout_filter_RequestVout (filter_t*,vout_thread_t*,video_format_t*)",audio_output\filters.c,"vout_thread_t *aout_filter_RequestVout (filter_t *filter, vout_thread_t *vout,
                                        const video_format_t *fmt)
{
    /* NOTE: This only works from aout_filters_t.
     * If you want to use visualization filters from another place, you will
     * need to add a new pf_aout_request_vout callback or store a pointer
     * to aout_request_vout_t inside filter_t (i.e. a level of indirection). */
    const aout_request_vout_t *req = filter->owner.sys;
    char *visual = var_InheritString (filter->obj.parent, ""audio-visual"");
    /* NOTE: Disable recycling to always close the filter vout because OpenGL
     * visualizations do not use this function to ask for a context. */
    bool recycle = false;
    free (visual);

    return req->pf_request_vout (req->p_private, vout, fmt, recycle);
}",383.0,398.0,1.0,1.0,16.0,9,3,12,7,0,0,1,1,0,0,,0,0,6,3,3,vout_thread_t
1669,7136,AppendFilter,1,AppendFilter,"int AppendFilter (vlc_object_t*,char*,char*,aout_filters_t*,void*,audio_sample_format_t*,audio_sample_format_t*,config_chain_t*)",audio_output\filters.c,"static int AppendFilter(vlc_object_t *obj, const char *type, const char *name,
                        aout_filters_t *restrict filters, const void *owner,
                        audio_sample_format_t *restrict infmt,
                        const audio_sample_format_t *restrict outfmt,
                        config_chain_t *cfg)
{
    const unsigned max = sizeof (filters->tab) / sizeof (filters->tab[0]);
    if (filters->count >= max)
    {
        msg_Err (obj, ""maximum of %u filters reached"", max);
        return -1;
    }

    filter_t *filter = CreateFilter (obj, type, name,
                                     (void *)owner, infmt, outfmt, cfg, false);
    if (filter == NULL)
    {
        msg_Err (obj, ""cannot add user %s \""%s\"" (skipped)"", type, name);
        return -1;
    }

    /* convert to the filter input format if necessary */
    if (aout_FiltersPipelineCreate (obj, filters->tab, &filters->count,
                                    max - 1, infmt, &filter->fmt_in....",400.0,436.0,1.0,1.0,37.0,35,15,42,12,5,4,4,4,1,4,,0,2,16,8,8,int
1670,7269,AppendRemapFilter,1,AppendRemapFilter,"int AppendRemapFilter (vlc_object_t*,aout_filters_t*,audio_sample_format_t*,audio_sample_format_t*,int*)",audio_output\filters.c,"static int AppendRemapFilter(vlc_object_t *obj, aout_filters_t *restrict filters,
                             audio_sample_format_t *restrict infmt,
                             const audio_sample_format_t *restrict outfmt,
                             const int *wg4_remap)
{
    char *name;
    config_chain_t *cfg;

    /* The remap audio filter use a different order than wg4 */
    static const uint8_t wg4_to_remap[] = { 0, 2, 6, 7, 3, 5, 4, 1, 8 };
    int remap[AOUT_CHAN_MAX];
    bool needed = false;
    for (int i = 0; i < AOUT_CHAN_MAX; ++i)
    {
        if (wg4_remap[i] != i)
            needed = true;
        remap[i] = wg4_remap[i] >= 0 ? wg4_to_remap[wg4_remap[i]] : -1;
    }
    if (!needed)
        return 0;

    char *str;
    int ret = asprintf(&str, ""remap{channel-left=%d,channel-right=%d,""
                       ""channel-middleleft=%d,channel-middleright=%d,""
                       ""channel-rearleft=%d,channel-rearright=%d,""
                       ""channel-rearcen...",438.0,482.0,1.0,1.0,45.0,37,12,51,17,1,3,7,8,0,3,,0,1,10,5,5,int
1671,7431,aout_FiltersNew,1,aout_FiltersNew,"aout_filters_t aout_FiltersNew (vlc_object_t*,audio_sample_format_t*,audio_sample_format_t*,aout_request_vout_t*,aout_filters_cfg_t*)",audio_output\filters.c,"aout_filters_t *aout_FiltersNew (vlc_object_t *obj,
                                 const audio_sample_format_t *restrict infmt,
                                 const audio_sample_format_t *restrict outfmt,
                                 const aout_request_vout_t *request_vout,
                                 const aout_filters_cfg_t *cfg)
{
    aout_filters_t *filters = malloc (sizeof (*filters));
    if (unlikely(filters == NULL))
        return NULL;

    filters->rate_filter = NULL;
    filters->resampler = NULL;
    filters->resampling = 0;
    filters->count = 0;

    /* Prepare format structure */
    aout_FormatPrint (obj, ""input"", infmt);
    audio_sample_format_t input_format = *infmt;
    audio_sample_format_t output_format = *outfmt;

    /* Callbacks (before reading values and also before return statement) */
    if (request_vout != NULL)
        var_AddCallback (obj, ""visual"", VisualizationCallback, NULL);

    if (!AOUT_FMT_LINEAR(outfmt))
    {   /* Non-linear o...",500.0,661.0,1.0,12.0,162.0,127,14,171,17,1,17,28,32,3,17,,0,6,10,5,5,aout_filters_t
1672,7934,aout_FiltersDelete,1,aout_FiltersDelete,"void aout_FiltersDelete (vlc_object_t*,aout_filters_t*)",audio_output\filters.c,"void aout_FiltersDelete (vlc_object_t *obj, aout_filters_t *filters)
{
    if (filters->resampler != NULL)
        aout_FiltersPipelineDestroy (&filters->resampler, 1);
    aout_FiltersPipelineDestroy (filters->tab, filters->count);
    if (obj != NULL)
        var_DelCallback (obj, ""visual"", VisualizationCallback, NULL);
    free (filters);
}",672.0,680.0,1.0,1.0,9.0,7,3,10,3,1,3,3,3,0,3,,0,0,4,2,2,void
1673,7983,aout_FiltersAdjustResampling,1,aout_FiltersAdjustResampling,"bool aout_FiltersAdjustResampling (aout_filters_t*,int)",audio_output\filters.c,"bool aout_FiltersAdjustResampling (aout_filters_t *filters, int adjust)
{
    if (filters->resampler == NULL)
        return false;

    if (adjust)
        filters->resampling += adjust;
    else
        filters->resampling = 0;
    return filters->resampling != 0;
}",687.0,697.0,1.0,1.0,11.0,6,4,7,4,2,0,3,3,0,0,,0,0,4,2,2,bool
1674,8019,aout_FiltersPlay,1,aout_FiltersPlay,"block_t aout_FiltersPlay (aout_filters_t*,block_t*,int)",audio_output\filters.c,"block_t *aout_FiltersPlay (aout_filters_t *filters, block_t *block, int rate)
{
    int nominal_rate = 0;

    if (rate != INPUT_RATE_DEFAULT)
    {
        filter_t *rate_filter = filters->rate_filter;

        if (rate_filter == NULL)
            goto drop; /* Without linear, non-nominal rate is impossible. */

        /* Override input rate */
        nominal_rate = rate_filter->fmt_in.audio.i_rate;
        rate_filter->fmt_in.audio.i_rate =
            (nominal_rate * INPUT_RATE_DEFAULT) / rate;
    }

    block = aout_FiltersPipelinePlay (filters->tab, filters->count, block);
    if (filters->resampler != NULL)
    {   /* NOTE: the resampler needs to run even if resampling is 0.
         * The decoder and output rates can still be different. */
        filters->resampler->fmt_in.audio.i_rate += filters->resampling;
        block = aout_FiltersPipelinePlay (&filters->resampler, 1, block);
        filters->resampler->fmt_in.audio.i_rate -= filters->resampling;
    }

    if (nomi...",699.0,735.0,1.0,1.0,37.0,43,10,34,7,0,2,6,6,0,2,,0,2,6,3,3,block_t
1675,8150,aout_FiltersDrain,1,aout_FiltersDrain,block_t aout_FiltersDrain (aout_filters_t*),audio_output\filters.c,"block_t *aout_FiltersDrain (aout_filters_t *filters)
{
    /* Drain the filters pipeline */
    block_t *block = aout_FiltersPipelineDrain (filters->tab, filters->count);

    if (filters->resampler != NULL)
    {
        block_t *chain = NULL;

        filters->resampler->fmt_in.audio.i_rate += filters->resampling;

        if (block)
        {
            /* Resample the drained block from the filters pipeline */
            block = aout_FiltersPipelinePlay (&filters->resampler, 1, block);
            if (block)
                block_ChainAppend (&chain, block);
        }

        /* Drain the resampler filter */
        block = aout_FiltersPipelineDrain (&filters->resampler, 1);
        if (block)
            block_ChainAppend (&chain, block);

        filters->resampler->fmt_in.audio.i_rate -= filters->resampling;

        return chain ? block_ChainGather (chain) : NULL;
    }
    else
        return block;
}",737.0,767.0,1.0,1.0,31.0,27,8,26,4,0,3,5,9,0,3,,0,3,2,1,1,block_t
1676,8246,aout_FiltersFlush,1,aout_FiltersFlush,void aout_FiltersFlush (aout_filters_t*),audio_output\filters.c,"void aout_FiltersFlush (aout_filters_t *filters)
{
    aout_FiltersPipelineFlush (filters->tab, filters->count);

    if (filters->resampler != NULL)
        aout_FiltersPipelineFlush (&filters->resampler, 1);
}",769.0,775.0,1.0,1.0,7.0,6,3,5,2,0,2,2,2,0,2,,0,0,2,1,1,void
1677,8271,aout_FiltersChangeViewpoint,1,aout_FiltersChangeViewpoint,"void aout_FiltersChangeViewpoint (aout_filters_t*,vlc_viewpoint_t*)",audio_output\filters.c,"void aout_FiltersChangeViewpoint (aout_filters_t *filters,
                                  const vlc_viewpoint_t *vp)
{
    aout_FiltersPipelineChangeViewpoint (filters->tab, filters->count, vp);
}",777.0,781.0,1.0,1.0,5.0,2,1,3,2,0,1,1,1,0,1,,0,0,4,2,2,void
1678,8320,aout_OutputAssertLocked,1,aout_OutputAssertLocked,void aout_OutputAssertLocked (audio_output_t*),audio_output\output.c,"static void aout_OutputAssertLocked (audio_output_t *aout)
{
    aout_owner_t *owner = aout_owner (aout);

    vlc_assert_locked (&owner->lock);
}",49.0,54.0,1.0,4.0,6.0,6,4,4,2,4,3,1,1,0,1,,0,3,2,1,1,void
1679,8342,aout_Destructor,1,aout_Destructor,void aout_Destructor (vlc_object_t*),audio_output\output.c,"static void aout_Destructor (vlc_object_t *obj)
{
    audio_output_t *aout = (audio_output_t *)obj;
    aout_owner_t *owner = aout_owner (aout);

    vlc_mutex_destroy (&owner->dev.lock);
    for (aout_dev_t *dev = owner->dev.list, *next; dev != NULL; dev = next)
    {
        next = dev->next;
        free (dev->name);
        free (dev);
    }

    assert (owner->req.device == unset_str);
    vlc_mutex_destroy (&owner->vp.lock);
    vlc_mutex_destroy (&owner->req.lock);
    vlc_mutex_destroy (&owner->lock);
}",384.0,401.0,1.0,1.0,18.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1680,8347,var_Copy,1,var_Copy,"int var_Copy (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",audio_output\output.c,"static int var_Copy (vlc_object_t *src, const char *name, vlc_value_t prev,
                     vlc_value_t value, void *data)
{
    vlc_object_t *dst = data;

    (void) src; (void) prev;
    return var_Set (dst, name, value);
}",58.0,65.0,1.0,1.0,8.0,3,2,7,6,0,1,1,1,0,1,,0,0,10,5,5,int
1681,8371,var_CopyDevice,1,var_CopyDevice,"int var_CopyDevice (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",audio_output\output.c,"static int var_CopyDevice (vlc_object_t *src, const char *name,
                           vlc_value_t prev, vlc_value_t value, void *data)
{
    vlc_object_t *dst = data;

    (void) src; (void) name; (void) prev;
    return var_Set (dst, ""audio-device"", value);
}",67.0,74.0,1.0,1.0,8.0,4,2,7,6,0,1,1,1,0,1,,0,0,10,5,5,int
1682,8398,aout_VolumeNotify,1,aout_VolumeNotify,"void aout_VolumeNotify (audio_output_t*,float)",audio_output\output.c,"static void aout_VolumeNotify (audio_output_t *aout, float volume)
{
    var_SetFloat (aout, ""volume"", volume);
}",86.0,89.0,1.0,1.0,4.0,0,0,2,2,0,0,1,1,0,0,,0,0,4,2,2,void
1683,8408,aout_MuteNotify,1,aout_MuteNotify,"void aout_MuteNotify (audio_output_t*,bool)",audio_output\output.c,"static void aout_MuteNotify (audio_output_t *aout, bool mute)
{
    var_SetBool (aout, ""mute"", mute);
}",91.0,94.0,1.0,1.0,4.0,0,0,2,2,0,0,1,1,0,0,,0,0,4,2,2,void
1684,8418,aout_PolicyNotify,1,aout_PolicyNotify,"void aout_PolicyNotify (audio_output_t*,bool)",audio_output\output.c,"static void aout_PolicyNotify (audio_output_t *aout, bool cork)
{
    (cork ? var_IncInteger : var_DecInteger) (aout->obj.parent, ""corks"");
}",96.0,99.0,1.0,1.0,4.0,3,3,4,4,0,0,1,1,0,0,,0,0,4,2,2,void
1685,8435,aout_DeviceNotify,1,aout_DeviceNotify,"void aout_DeviceNotify (audio_output_t*,char*)",audio_output\output.c,"static void aout_DeviceNotify (audio_output_t *aout, const char *id)
{
    var_SetString (aout, ""device"", (id != NULL) ? id : """");
}",101.0,104.0,1.0,1.0,4.0,2,2,4,3,0,0,1,1,0,0,,0,0,4,2,2,void
1686,8450,aout_HotplugNotify,1,aout_HotplugNotify,"void aout_HotplugNotify (audio_output_t*,char*,char*)",audio_output\output.c,"static void aout_HotplugNotify (audio_output_t *aout,
                                const char *id, const char *name)
{
    aout_owner_t *owner = aout_owner (aout);
    aout_dev_t *dev, **pp = &owner->dev.list;

    vlc_mutex_lock (&owner->dev.lock);
    while ((dev = *pp) != NULL)
    {
        if (!strcmp (id, dev->id))
            break;
        pp = &dev->next;
    }

    if (name != NULL)
    {
        if (dev == NULL) /* Added device */
        {
            dev = malloc (sizeof (*dev) + strlen (id));
            if (unlikely(dev == NULL))
                goto out;
            dev->next = NULL;
            strcpy (dev->id, id);
            *pp = dev;
            owner->dev.count++;
        }
        else /* Modified device */
            free (dev->name);
        dev->name = strdup (name);
    }
    else
    {
        if (dev != NULL) /* Removed device */
        {
            owner->dev.count--;
            *pp = dev->next;
            free (dev->name);
            free (de...",106.0,148.0,1.0,1.0,43.0,36,11,31,7,0,3,8,10,0,3,,0,1,6,3,3,void
1687,8593,aout_RestartNotify,1,aout_RestartNotify,"void aout_RestartNotify (audio_output_t*,unsigned)",audio_output\output.c,"static void aout_RestartNotify (audio_output_t *aout, unsigned mode)
{
    aout_RequestRestart (aout, mode);
}",150.0,153.0,1.0,1.0,4.0,0,0,2,2,0,1,1,1,0,1,,0,0,4,2,2,void
1688,8602,aout_GainNotify,1,aout_GainNotify,"int aout_GainNotify (audio_output_t*,float)",audio_output\output.c,"static int aout_GainNotify (audio_output_t *aout, float gain)
{
    aout_owner_t *owner = aout_owner (aout);

    aout_OutputAssertLocked (aout);
    aout_volume_SetVolume (owner->volume, gain);
    /* XXX: ideally, return -1 if format cannot be amplified */
    return 0;
}",155.0,163.0,1.0,1.0,9.0,2,2,5,3,0,4,1,1,0,3,,0,2,4,2,2,int
1689,8622,FilterCallback,1,FilterCallback,"int FilterCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",audio_output\output.c,"static int FilterCallback (vlc_object_t *obj, const char *var,
                           vlc_value_t prev, vlc_value_t cur, void *data)
{
    if (strcmp(prev.psz_string, cur.psz_string))
        aout_InputRequestRestart ((audio_output_t *)obj);
    (void) var; (void) data;
    return VLC_SUCCESS;
}",165.0,172.0,1.0,1.0,8.0,5,2,6,6,0,1,2,2,0,1,,0,0,10,5,5,int
1690,8652,StereoModeCallback,1,StereoModeCallback,"int StereoModeCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",audio_output\output.c,"static int StereoModeCallback (vlc_object_t *obj, const char *varname,
                               vlc_value_t oldval, vlc_value_t newval, void *data)
{
    audio_output_t *aout = (audio_output_t *)obj;
    (void)varname; (void)oldval; (void)newval; (void)data;

    aout_RestartRequest (aout, AOUT_RESTART_STEREOMODE);
    return 0;
}",174.0,182.0,1.0,1.0,9.0,6,2,8,7,0,0,1,1,0,0,,0,0,10,5,5,int
1691,8684,ViewpointCallback,1,ViewpointCallback,"int ViewpointCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",video_output\vout_intf.c,"static int ViewpointCallback( vlc_object_t *p_this, char const *psz_cmd,
                              vlc_value_t oldval, vlc_value_t newval, void *p_data)
{
    vout_thread_t *p_vout = (vout_thread_t *)p_this;
    VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval); VLC_UNUSED(p_data);

    if( newval.p_address != NULL )
        vout_ControlChangeViewpoint( p_vout, newval.p_address );
    return VLC_SUCCESS;
}",609.0,618.0,1.0,1.0,10.0,7,3,8,7,0,1,2,2,0,1,,0,0,10,5,5,int
1692,9538,aout_PrepareStereoMode,1,aout_PrepareStereoMode,"void aout_PrepareStereoMode (audio_output_t*,audio_sample_format_t*,aout_filters_cfg_t*,audio_channel_type_t,unsigned,int)",audio_output\output.c,"static void aout_PrepareStereoMode (audio_output_t *aout,
                                    audio_sample_format_t *restrict fmt,
                                    aout_filters_cfg_t *filters_cfg,
                                    audio_channel_type_t input_chan_type,
                                    unsigned i_nb_input_channels,
                                    int i_forced_stereo_mode)
{
    /* Fill Stereo mode choices */
    var_Change (aout, ""stereo-mode"", VLC_VAR_CLEARCHOICES, NULL, NULL);
    vlc_value_t val, txt, default_val = { .i_int = AOUT_VAR_CHAN_UNSET };
    val.i_int = 0;

    if (!AOUT_FMT_LINEAR(fmt) || i_nb_input_channels == 1)
        return;

    val.i_int = AOUT_VAR_CHAN_MONO;
    txt.psz_string = _(""Mono"");
    var_Change (aout, ""stereo-mode"", VLC_VAR_ADDCHOICE, &val, &txt);

    if (i_nb_input_channels != 2)
    {
        val.i_int = AOUT_VAR_CHAN_UNSET;
        txt.psz_string = _(""Original"");
        var_Change (aout, ""stereo-mode"", VLC_VAR_ADDCHOIC...",403.0,510.0,1.0,1.0,108.0,99,14,119,31,0,10,18,13,0,10,,0,0,12,6,6,void
1693,10158,PauseDefault,1,PauseDefault,"void PauseDefault (audio_output_t*,bool,mtime_t)",audio_output\output.c,"static void PauseDefault (audio_output_t *aout, bool pause, mtime_t date)
{
    if (pause)
        aout_OutputFlush (aout, false);
    (void) date;
}",622.0,627.0,1.0,1.0,6.0,1,1,4,4,0,1,2,2,0,1,,0,0,6,3,3,void
1694,10211,aout_OutputVolumeSet,1,aout_OutputVolumeSet,"int aout_OutputVolumeSet (audio_output_t*,float)",audio_output\output.c,"static int aout_OutputVolumeSet (audio_output_t *aout, float vol)
{
    aout_OutputAssertLocked (aout);
    return (aout->volume_set != NULL) ? aout->volume_set (aout, vol) : -1;
}",656.0,660.0,1.0,1.0,5.0,5,4,6,3,0,1,1,1,0,1,,0,0,4,2,2,int
1695,10234,aout_OutputMuteSet,1,aout_OutputMuteSet,"int aout_OutputMuteSet (audio_output_t*,bool)",audio_output\output.c,"static int aout_OutputMuteSet (audio_output_t *aout, bool mute)
{
    aout_OutputAssertLocked (aout);
    return (aout->mute_set != NULL) ? aout->mute_set (aout, mute) : -1;
}",662.0,666.0,1.0,1.0,5.0,5,4,6,3,0,1,1,1,0,1,,0,0,4,2,2,int
1696,10257,aout_OutputDeviceSet,1,aout_OutputDeviceSet,"int aout_OutputDeviceSet (audio_output_t*,char*)",audio_output\output.c,"static int aout_OutputDeviceSet (audio_output_t *aout, const char *id)
{
    aout_OutputAssertLocked (aout);
    return (aout->device_select != NULL) ? aout->device_select (aout, id) : -1;
}",668.0,672.0,1.0,1.0,5.0,5,4,6,3,0,1,1,1,0,1,,0,0,4,2,2,int
1697,10295,aout_OutputTryLock,1,aout_OutputTryLock,int aout_OutputTryLock (audio_output_t*),audio_output\output.c,"static int aout_OutputTryLock (audio_output_t *aout)
{
    aout_owner_t *owner = aout_owner (aout);

    return vlc_mutex_trylock (&owner->lock);
}",681.0,686.0,1.0,1.0,6.0,3,3,3,2,3,3,1,1,0,2,,0,2,2,1,1,int
1698,10431,aout_VolumeGet,1,aout_VolumeGet,float aout_VolumeGet (audio_output_t*),audio_output\output.c,"float aout_VolumeGet (audio_output_t *aout)
{
    return var_GetFloat (aout, ""volume"");
}",728.0,731.0,1.0,1.0,4.0,0,0,1,1,3,0,1,1,0,0,,0,0,2,1,1,float
1699,10440,aout_VolumeSet,1,aout_VolumeSet,"int aout_VolumeSet (audio_output_t*,float)",audio_output\output.c,"int aout_VolumeSet (audio_output_t *aout, float vol)
{
    aout_owner_t *owner = aout_owner (aout);

    assert (vol >= 0.f);
    vlc_mutex_lock (&owner->req.lock);
    owner->req.volume = vol;
    vlc_mutex_unlock (&owner->req.lock);

    if (aout_OutputTryLock (aout) == 0)
        aout_OutputUnlock (aout);
    return 0;
}",738.0,750.0,1.0,1.0,13.0,12,6,9,3,2,5,2,2,1,5,,0,2,4,2,2,int
1700,10486,aout_VolumeUpdate,1,aout_VolumeUpdate,"int aout_VolumeUpdate (audio_output_t*,int,float*)",audio_output\output.c,"int aout_VolumeUpdate (audio_output_t *aout, int value, float *volp)
{
    int ret = -1;
    float stepSize = var_InheritFloat (aout, ""volume-step"") / (float)AOUT_VOLUME_DEFAULT;
    float delta = value * stepSize;
    float vol = aout_VolumeGet (aout);

    if (vol >= 0.f)
    {
        vol += delta;
        if (vol < 0.f)
            vol = 0.f;
        if (vol > 2.f)
            vol = 2.f;
        vol = (roundf (vol / stepSize)) * stepSize;
        if (volp != NULL)
            *volp = vol;
        ret = aout_VolumeSet (aout, vol);
    }
    return ret;
}",757.0,777.0,1.0,1.0,21.0,21,11,28,9,1,2,5,8,0,2,,0,2,6,3,3,int
1701,10567,aout_MuteGet,1,aout_MuteGet,int aout_MuteGet (audio_output_t*),audio_output\output.c,"int aout_MuteGet (audio_output_t *aout)
{
    return var_InheritBool (aout, ""mute"");
}",783.0,786.0,1.0,1.0,4.0,0,0,1,1,1,0,1,1,0,0,,0,0,2,1,1,int
1702,10576,aout_MuteSet,1,aout_MuteSet,"int aout_MuteSet (audio_output_t*,bool)",audio_output\output.c,"int aout_MuteSet (audio_output_t *aout, bool mute)
{
    aout_owner_t *owner = aout_owner (aout);

    vlc_mutex_lock (&owner->req.lock);
    owner->req.mute = mute;
    vlc_mutex_unlock (&owner->req.lock);

    if (aout_OutputTryLock (aout) == 0)
        aout_OutputUnlock (aout);
    return 0;
}",792.0,803.0,1.0,1.0,12.0,11,5,8,3,1,5,2,2,1,5,,0,2,4,2,2,int
1703,10618,aout_DeviceGet,1,aout_DeviceGet,char* aout_DeviceGet (audio_output_t*),audio_output\output.c,"char *aout_DeviceGet (audio_output_t *aout)
{
    return var_GetNonEmptyString (aout, ""device"");
}",810.0,813.0,1.0,1.0,4.0,0,0,1,1,0,0,1,1,0,0,,0,0,2,1,1,char*
1704,10627,aout_DeviceSet,1,aout_DeviceSet,"int aout_DeviceSet (audio_output_t*,char*)",audio_output\output.c,"int aout_DeviceSet (audio_output_t *aout, const char *id)
{
    aout_owner_t *owner = aout_owner (aout);

    char *dev = NULL;
    if (id != NULL)
    {
        dev = strdup (id);
        if (unlikely(dev == NULL))
            return -1;
    }

    vlc_mutex_lock (&owner->req.lock);
    if (owner->req.device != unset_str)
        free (owner->req.device);
    owner->req.device = dev;
    vlc_mutex_unlock (&owner->req.lock);

    if (aout_OutputTryLock (aout) == 0)
        aout_OutputUnlock (aout);
    return 0;
}",820.0,841.0,1.0,1.0,22.0,21,7,19,6,0,6,5,6,2,5,,0,3,4,2,2,int
1705,10706,aout_DevicesList,1,aout_DevicesList,"int aout_DevicesList (audio_output_t*,char***,char***)",audio_output\output.c,"int aout_DevicesList (audio_output_t *aout, char ***ids, char ***names)
{
    aout_owner_t *owner = aout_owner (aout);
    char **tabid, **tabname;
    unsigned i = 0;

    vlc_mutex_lock (&owner->dev.lock);
    tabid = vlc_alloc (owner->dev.count, sizeof (*tabid));
    tabname = vlc_alloc (owner->dev.count, sizeof (*tabname));

    if (unlikely(tabid == NULL || tabname == NULL))
        goto error;

    *ids = tabid;
    *names = tabname;

    for (aout_dev_t *dev = owner->dev.list; dev != NULL; dev = dev->next)
    {
        tabid[i] = strdup(dev->id);
        if (unlikely(tabid[i] == NULL))
            goto error;

        tabname[i] = strdup(dev->name);
        if (unlikely(tabname[i] == NULL))
        {
            free(tabid[i]);
            goto error;
        }

        i++;
    }
    vlc_mutex_unlock (&owner->dev.lock);

    return i;

error:
    vlc_mutex_unlock(&owner->dev.lock);
    while (i > 0)
    {
        i--;
        free(tabname[i]);
        free(tabid[i]);
    }
...",854.0,900.0,1.0,1.0,47.0,49,14,48,9,0,4,9,8,0,4,,0,1,6,3,3,int
1706,10899,ReplayGainCallback,1,ReplayGainCallback,"int ReplayGainCallback (vlc_object_t*,char*,ANY,ANY,void*)",audio_output\volume.c,"static int ReplayGainCallback (vlc_object_t *obj, char const *var,
                               vlc_value_t oldval, vlc_value_t val, void *data)
{
    aout_volume_t *vol = data;
    float multiplier = aout_ReplayGainSelect(obj, val.psz_string,
                                             &vol->replay_gain);
    vlc_atomic_store_float (&vol->gain_factor, multiplier);
    VLC_UNUSED(var); VLC_UNUSED(oldval);
    return VLC_SUCCESS;
}",194.0,203.0,1.0,1.0,10.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,int
1707,11158,aout_ReplayGainSelect,1,aout_ReplayGainSelect,"float aout_ReplayGainSelect (vlc_object_t*,char*,audio_replay_gain_t*)",audio_output\volume.c,"static float aout_ReplayGainSelect(vlc_object_t *obj, const char *str,
                                   const audio_replay_gain_t *replay_gain)
{
    unsigned mode = AUDIO_REPLAY_GAIN_MAX;

    if (likely(str != NULL))
    {   /* Find selectrf mode */
        if (!strcmp (str, ""track""))
            mode = AUDIO_REPLAY_GAIN_TRACK;
        else
        if (!strcmp (str, ""album""))
            mode = AUDIO_REPLAY_GAIN_ALBUM;
    }

    /* */
    float multiplier;

    if (mode == AUDIO_REPLAY_GAIN_MAX)
    {
        multiplier = 1.f;
    }
    else
    {
        float gain;

        /* If the selectrf mode is not available, prefer the other one */
        if (!replay_gain->pb_gain[mode] && replay_gain->pb_gain[!mode])
            mode = !mode;

        if (replay_gain->pb_gain[mode])
            gain = replay_gain->pf_gain[mode]
                 + var_InheritFloat (obj, ""audio-replay-gain-preamp"");
        else
            gain = var_InheritFloat (obj, ""audio-replay-gain-default"");

 ...",145.0,192.0,1.0,1.0,48.0,7,5,13,7,0,0,4,5,0,0,,0,0,6,3,3,float
1708,11344,IsEscapeNeeded,1,IsEscapeNeeded,bool IsEscapeNeeded (char),config\chain.c,"static bool IsEscapeNeeded( char c )
{
    return c == '\'' || c == '""' || c == '\\';
}",45.0,48.0,1.0,1.0,4.0,5,2,3,1,2,0,1,1,0,0,,0,0,2,1,1,bool
1709,11361,IsEscape,1,IsEscape,bool IsEscape (char*),config\chain.c,"static bool IsEscape( const char *psz )
{
    if( !psz )
        return false;
    return psz[0] == '\\' && IsEscapeNeeded( psz[1] );
}",49.0,54.0,1.0,1.0,6.0,5,4,4,2,2,1,2,2,0,1,,0,0,2,1,1,bool
1710,11383,IsSpace,1,IsSpace,bool IsSpace (char),config\chain.c,"static bool IsSpace( char c  )
{
    return c == ' ' || c == '\t';
}",55.0,58.0,1.0,1.0,4.0,3,2,2,1,0,0,1,1,0,0,,0,0,2,1,1,bool
1711,11396,ChainGetEnd,1,ChainGetEnd,const char* ChainGetEnd (char*),config\chain.c,"static const char *ChainGetEnd( const char *psz_string )
{
    const char *p = psz_string;
    char c;

    if( !psz_string )
        return NULL;

    /* Look for a opening character */
    SKIPSPACE( p );

    for( ;; p++)
    {
        if( *p == '\0' || *p == ',' || *p == '}' )
            return p;

        if( *p == '{' || *p == '""' || *p == '\'' )
            break;
    }

    /* Set c to the closing character */
    if( *p == '{' )
        c = '}';
    else
        c = *p;
    p++;

    /* Search the closing character, handle nested {..} */
    for( ;; )
    {
        if( *p == '\0')
            return p;

        if( IsEscape( p ) )
            p += 2;
        else if( *p == c )
            return ++p;
        else if( *p == '{' && c == '}' )
            p = ChainGetEnd( p );
        else
            p++;
    }
}",71.0,113.0,1.0,4.0,43.0,27,7,22,4,1,1,10,13,1,1,,0,1,2,1,1,const char*
1712,11526,ChainGetValue,1,ChainGetValue,char* ChainGetValue (char**),config\chain.c,"static char *ChainGetValue( const char **ppsz_string )
{
    const char *p = *ppsz_string;

    char *psz_value = NULL;
    const char *end;
    bool b_keep_brackets = (*p == '{');

    if( *p == '=' )
        p++;

    end = ChainGetEnd( p );
    if( end <= p )
    {
        psz_value = NULL;
    }
    else
    {
        /* Skip heading and trailing spaces.
         * This ain't necessary but will avoid simple
         * user mistakes. */
        SKIPSPACE( p );
    }

    if( end <= p )
    {
        psz_value = NULL;
    }
    else
    {
        if( *p == '\'' || *p == '""' || ( !b_keep_brackets && *p == '{' ) )
        {
            p++;

            if( *(end-1) != '\'' && *(end-1) == '""' )
                SKIPTRAILINGSPACE( p, end );

            if( end - 1 <= p )
                psz_value = NULL;
            else
                psz_value = strndup( p, end -1 - p );
        }
        else
        {
            SKIPTRAILINGSPACE( p, end );
            if( end <= p )
          ...",119.0,178.0,1.0,8.0,60.0,16,5,23,6,1,2,5,5,0,2,,0,1,2,1,1,char*
1713,11713,config_ChainParseOptions,1,config_ChainParseOptions,"const char* config_ChainParseOptions (config_chain_t**,char*)",config\chain.c,"const char *config_ChainParseOptions( config_chain_t **pp_cfg, const char *psz_opts )
{
    config_chain_t **pp_next = pp_cfg;
    bool first = true;
    do
    {
        if (!first)
            psz_opts++; /* skip previous delimiter */
        SKIPSPACE( psz_opts );

        first = false;

        /* Look for the end of the name (,={}_space_) */
        size_t len = strcspn( psz_opts, ""=,{} \t"" );
        if( len == 0 )
            continue; /* ignore empty parameter */

        /* Append the new parameter */
        config_chain_t *p_cfg = malloc( sizeof(*p_cfg) );
        if( !p_cfg )
            break;
        p_cfg->psz_name = strndup( psz_opts, len );
        psz_opts += len;
        p_cfg->psz_value = NULL;
        p_cfg->p_next = NULL;

        *pp_next = p_cfg;
        pp_next = &p_cfg->p_next;

        /* Extract the option value */
        SKIPSPACE( psz_opts );
        if( strchr( ""={"", *psz_opts ) )
        {
            p_cfg->psz_value = ChainGetValue( &psz_opts );
 ...",181.0,224.0,1.0,8.0,44.0,35,9,46,9,2,1,9,11,0,1,,0,1,4,2,2,const char*
1714,11851,config_ChainCreate,1,config_ChainCreate,"char* config_ChainCreate (char**,config_chain_t**,char*)",config\chain.c,"char *config_ChainCreate( char **ppsz_name, config_chain_t **pp_cfg,
                          const char *psz_chain )
{
    size_t len;

    *ppsz_name = NULL;
    *pp_cfg    = NULL;

    if( !psz_chain )
        return NULL;
    SKIPSPACE( psz_chain );

    /* Look for parameter (a {...} or :...) or end of name (space or nul) */
    len = strcspn( psz_chain, ""{: \t"" );
    *ppsz_name = strndup( psz_chain, len );
    psz_chain += len;

    /* Parse the parameters */
    SKIPSPACE( psz_chain );
    if( *psz_chain == '{' )
        psz_chain = config_ChainParseOptions( pp_cfg, psz_chain );

    if( *psz_chain == ':' )
        return strdup( psz_chain + 1 );

    return NULL;
}",226.0,252.0,1.0,4.0,27.0,17,6,26,5,8,1,4,4,0,1,,0,1,6,3,3,char*
1715,11927,config_ChainDestroy,1,config_ChainDestroy,void config_ChainDestroy (config_chain_t*),config\chain.c,"void config_ChainDestroy( config_chain_t *p_cfg )
{
    while( p_cfg != NULL )
    {
        config_chain_t *p_next;

        p_next = p_cfg->p_next;

        FREENULL( p_cfg->psz_name );
        FREENULL( p_cfg->psz_value );
        free( p_cfg );

        p_cfg = p_next;
    }
}",254.0,268.0,1.0,1.0,15.0,6,3,9,3,11,0,2,2,0,0,,0,0,2,1,1,void
1716,11956,config_ChainParse,1,config_ChainParse,"void config_ChainParse (vlc_object_t*,char*,char**,config_chain_t*)",config\chain.c,"void config_ChainParse( vlc_object_t *p_this, const char *psz_prefix,
                        const char *const *ppsz_options, config_chain_t *cfg )
{
    if( psz_prefix == NULL ) psz_prefix = """";
    size_t plen = 1 + strlen( psz_prefix );

    /* First, var_Create all variables */
    for( size_t i = 0; ppsz_options[i] != NULL; i++ )
    {
        const char *optname = ppsz_options[i];
        if (optname[0] == '*')
            optname++;

        char name[plen + strlen( optname )];
        snprintf( name, sizeof (name), ""%s%s"", psz_prefix, optname );
        if( var_Create( p_this, name,
                        config_GetType( name ) | VLC_VAR_DOINHERIT ) )
            return /* VLC_xxx */;

        module_config_t* p_conf = config_FindConfig( name );
        if( p_conf )
        {
            switch( CONFIG_CLASS( p_conf->i_type ) )
            {
                case CONFIG_ITEM_INTEGER:
                    var_Change( p_this, name, VLC_VAR_SETMINMAX,
                        &(...",271.0,434.0,1.0,20.0,164.0,130,20,148,29,0,10,39,46,2,10,,0,6,8,4,4,void
1717,12446,config_ChainDuplicate,1,config_ChainDuplicate,config_chain_t config_ChainDuplicate (config_chain_t*),config\chain.c,"config_chain_t *config_ChainDuplicate( const config_chain_t *p_src )
{
    config_chain_t *p_dst = NULL;
    config_chain_t **pp_last = &p_dst;

    for( ; p_src != NULL; p_src = p_src->p_next )
    {
        config_chain_t *p = malloc( sizeof(*p) );
        if( !p )
            break;
        p->p_next    = NULL;
        p->psz_name  = p_src->psz_name  ? strdup( p_src->psz_name )  : NULL;
        p->psz_value = p_src->psz_value ? strdup( p_src->psz_value ) : NULL;

        *pp_last = p;
        pp_last = &p->p_next;
    }
    return p_dst;
}",436.0,454.0,1.0,1.0,19.0,25,8,24,5,0,0,4,4,0,0,,0,0,2,1,1,config_chain_t
1718,12526,config_StringUnescape,1,config_StringUnescape,char* config_StringUnescape (char*),config\chain.c,"char *config_StringUnescape( char *psz_string )
{
    char *psz_src = psz_string;
    char *psz_dst = psz_string;
    if( !psz_src )
        return NULL;

    while( *psz_src )
    {
        if( IsEscape( psz_src ) )
            psz_src++;
        *psz_dst++ = *psz_src++;
    }
    *psz_dst = '\0';

    return psz_string;
}",456.0,472.0,1.0,1.0,17.0,12,4,13,4,1,1,4,5,1,1,,0,1,2,1,1,char*
1719,12568,config_StringEscape,1,config_StringEscape,char* config_StringEscape (char*),config\chain.c,"char *config_StringEscape( const char *str )
{
    size_t length = 0;

    if( str == NULL )
        return NULL;

    for( const char *p = str; *p; p++ )
        length += IsEscapeNeeded( *p ) ? 2 : 1;

    char *ret = malloc( length + 1 ), *dst = ret;

    if( unlikely( !ret ) )
        return NULL;

    for( const char *p = str; *p; p++ )
    {
        if( IsEscapeNeeded( *p ) )
            *dst++ = '\\';
        *dst++ = *p;
    }
    *dst = '\0';;
    return ret;
}",474.0,497.0,1.0,1.0,24.0,20,6,22,6,0,1,6,7,1,1,,0,1,2,1,1,char*
1720,12680,config_LoadCmdLine,1,config_LoadCmdLine,"int config_LoadCmdLine (vlc_object_t*,int,char[]*,int*)",config\cmdline.c,"int config_LoadCmdLine( vlc_object_t *p_this, int i_argc,
                        const char *ppsz_argv[], int *pindex )
{
    int i_cmd, i_index, i_opts, i_shortopts, flag, i_verbose = 0;
    struct vlc_option *p_longopts;
    const char **argv_copy = NULL;
#define b_ignore_errors (pindex == NULL)

    /* Short options */
    const module_config_t *pp_shortopts[256];
    char *psz_shortopts;

    /*
     * Generate the longopts and shortopts structures used by getopt_long
     */

    i_opts = 0;
    for (const vlc_plugin_t *p = vlc_plugins; p != NULL; p = p->next)
        /* count the number of exported configuration options (to allocate
         * longopts). We also need to allocate space for two options when
         * dealing with boolean to allow for --foo and --no-foo */
        i_opts += p->conf.count + 2 * p->conf.booleans;

    p_longopts = vlc_alloc( i_opts + 1, sizeof(*p_longopts)  );
    if( p_longopts == NULL )
        return -1;

    psz_shortopts = malloc( 2 * i_opts...",58.0,304.0,1.0,8.0,247.0,166,22,208,38,2,12,40,60,1,12,,0,2,8,4,4,int
1721,13461,config_CreateDir,1,config_CreateDir,"int config_CreateDir (vlc_object_t*,char*)",config\file.c,"int config_CreateDir( vlc_object_t *p_this, const char *psz_dirname )
{
    if( !psz_dirname || !*psz_dirname ) return -1;

    if( vlc_mkdir( psz_dirname, 0700 ) == 0 )
        return 0;

    switch( errno )
    {
        case EEXIST:
            return 0;

        case ENOENT:
        {
            /* Let's try to create the parent directory */
            char psz_parent[strlen( psz_dirname ) + 1], *psz_end;
            strcpy( psz_parent, psz_dirname );

            psz_end = strrchr( psz_parent, DIR_SEP_CHAR );
            if( psz_end && psz_end != psz_parent )
            {
                *psz_end = '\0';
                if( config_CreateDir( p_this, psz_parent ) == 0 )
                {
                    if( !vlc_mkdir( psz_dirname, 0700 ) )
                        return 0;
                }
            }
        }
    }

    msg_Warn( p_this, ""could not create %s: %s"", psz_dirname,
              vlc_strerror_c(errno) );
    return -1;
}",266.0,300.0,1.0,1.0,35.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,int
1722,13467,config_AutoSaveConfigFile,1,config_AutoSaveConfigFile,int config_AutoSaveConfigFile (vlc_object_t*),config\file.c,"int config_AutoSaveConfigFile( vlc_object_t *p_this )
{
    int ret = 0;

    assert( p_this );

    vlc_rwlock_rdlock (&config_lock);
    if (config_dirty)
    {
        /* Note: this will get the read lock recursively. Ok. */
        ret = config_SaveConfigFile (p_this);
        config_dirty = (ret != 0);
    }
    vlc_rwlock_unlock (&config_lock);

    return ret;
}",525.0,541.0,1.0,1.0,17.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
1723,13472,config_Free,1,config_Free,"void config_Free (module_config_t*,ANY)",config\core.c,"void config_Free (module_config_t *tab, size_t confsize)
{
    for (size_t j = 0; j < confsize; j++)
    {
        module_config_t *p_item = &tab[j];

        if (IsConfigStringType (p_item->i_type))
        {
            free (p_item->value.psz);
            if (p_item->list_count)
                free (p_item->list.psz);
        }

        free (p_item->list_text);
    }

    free (tab);
}",538.0,555.0,1.0,12.0,18.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
1724,13486,config_LoadConfigFile,1,config_LoadConfigFile,int config_LoadConfigFile (vlc_object_t*),config\file.c,"int config_LoadConfigFile( vlc_object_t *p_this )
{
    FILE *file;

    file = config_OpenConfigFile (p_this);
    if (file == NULL)
        return VLC_EGENERIC;

    /* Skip UTF-8 Byte Order Mark if present */
    char bom[3];
    if (fread (bom, 1, 3, file) != 3 || memcmp (bom, ""\xEF\xBB\xBF"", 3))
        rewind (file); /* no BOM, rewind */

    char *line = NULL;
    size_t bufsize;
    ssize_t linelen;

    /* Ensure consistent number formatting... */
    locale_t loc = newlocale (LC_NUMERIC_MASK, ""C"", NULL);
    locale_t baseloc = uselocale (loc);

    vlc_rwlock_wrlock (&config_lock);
    while ((linelen = getline (&line, &bufsize, file)) != -1)
    {
        line[linelen - 1] = '\0'; /* trim newline */

        /* Ignore comments, section and empty lines */
        if (memchr (""#["", line[0], 3) != NULL)
            continue;

        /* look for option name */
        const char *psz_option_name = line;

        char *ptr = strchr (line, '=');
        if (ptr == NULL)
      ...",169.0,261.0,1.0,16.0,93.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
1725,13491,config_PrintHelp,1,config_PrintHelp,bool config_PrintHelp (vlc_object_t*),config\help.c,"bool config_PrintHelp (vlc_object_t *obj)
{
    char *str;

    /* Check for short help option */
    if (var_InheritBool (obj, ""help""))
    {
        Help (obj, ""help"");
        return true;
    }

    /* Check for version option */
    if (var_InheritBool (obj, ""version""))
    {
        Version();
        return true;
    }

    /* Check for help on modules */
    str = var_InheritString (obj, ""module"");
    if (str != NULL)
    {
        Help (obj, str);
        free (str);
        return true;
    }

    /* Check for full help option */
    if (var_InheritBool (obj, ""full-help""))
    {
        var_Create (obj, ""advanced"", VLC_VAR_BOOL);
        var_SetBool (obj, ""advanced"", true);
        var_Create (obj, ""help-verbose"", VLC_VAR_BOOL);
        var_SetBool (obj, ""help-verbose"", true);
        Help (obj, ""full-help"");
        return true;
    }

    /* Check for long help option */
    if (var_InheritBool (obj, ""longhelp""))
    {
        Help (obj, ""longhelp"");
        return true...",95.0,154.0,1.0,1.0,60.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,bool
1726,13496,config_SortConfig,1,config_SortConfig,int config_SortConfig (void),config\core.c,"int config_SortConfig (void)
{
    vlc_plugin_t *p;
    size_t nconf = 0;

    for (p = vlc_plugins; p != NULL; p = p->next)
         nconf += p->conf.size;

    module_config_t **clist = vlc_alloc (nconf, sizeof (*clist));
    if (unlikely(clist == NULL))
        return VLC_ENOMEM;

    nconf = 0;
    for (p = vlc_plugins; p != NULL; p = p->next)
    {
        module_config_t *item, *end;

        for (item = p->conf.items, end = item + p->conf.size;
             item < end;
             item++)
        {
            if (!CONFIG_ITEM(item->i_type))
                continue; /* ignore hints */
            clist[nconf++] = item;
        }
    }

    qsort (clist, nconf, sizeof (*clist), confcmp);

    config.list = clist;
    config.count = nconf;
    return VLC_SUCCESS;
}",475.0,507.0,1.0,1.0,33.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,int
1727,13501,config_UnsortConfig,1,config_UnsortConfig,void config_UnsortConfig (void),config\core.c,"void config_UnsortConfig (void)
{
    module_config_t **clist;

    clist = config.list;
    config.list = NULL;
    config.count = 0;

    free (clist);
}",509.0,518.0,1.0,1.0,10.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
1728,13508,config_IsSafe,1,config_IsSafe,bool config_IsSafe (char*),config\core.c,"bool config_IsSafe( const char *name )
{
    module_config_t *p_config = config_FindConfig( name );
    return p_config != NULL && p_config->b_safe;
}",79.0,83.0,1.0,1.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,bool
1729,13546,strdupnull,1,strdupnull,char* strdupnull (char*),config\file.c,"static inline char *strdupnull (const char *src)
{
    return src ? strdup (src) : NULL;
}",51.0,54.0,1.0,1.0,4.0,1,1,3,2,1,0,1,1,0,0,,0,0,2,1,1,char*
1730,13557,config_GetType,1,config_GetType,int config_GetType (char*),config\core.c,"int config_GetType(const char *psz_name)
{
    module_config_t *p_config = config_FindConfig(psz_name);

    /* sanity checks */
    if( !p_config )
    {
        return 0;
    }

    switch( CONFIG_CLASS(p_config->i_type) )
    {
        case CONFIG_ITEM_FLOAT:
            return VLC_VAR_FLOAT;
        case CONFIG_ITEM_INTEGER:
            return VLC_VAR_INTEGER;
        case CONFIG_ITEM_BOOL:
            return VLC_VAR_BOOL;
        case CONFIG_ITEM_STRING:
            return VLC_VAR_STRING;
        default:
            return 0;
    }
}",54.0,77.0,1.0,12.0,24.0,6,5,13,10,2,1,3,3,0,1,,0,1,2,1,1,int
1731,13623,config_GetInt,1,config_GetInt,"int64_t config_GetInt (vlc_object_t*,char*)",config\core.c,"int64_t config_GetInt( vlc_object_t *p_this, const char *psz_name )
{
    module_config_t *p_config = config_FindConfig( psz_name );

    /* sanity checks */
    if( !p_config )
    {
        msg_Err( p_this, ""option %s does not exist"", psz_name );
        return -1;
    }

    assert(IsConfigIntegerType(p_config->i_type));

    int64_t val;

    vlc_rwlock_rdlock (&config_lock);
    val = p_config->value.i;
    vlc_rwlock_unlock (&config_lock);
    return val;
}",93.0,112.0,1.0,11.0,20.0,12,8,13,6,2,5,2,2,0,3,,0,3,4,2,2,int64_t
1732,13674,config_GetFloat,1,config_GetFloat,"float config_GetFloat (vlc_object_t*,char*)",config\core.c,"float config_GetFloat( vlc_object_t *p_this, const char *psz_name )
{
    module_config_t *p_config;

    p_config = config_FindConfig( psz_name );

    /* sanity checks */
    if( !p_config )
    {
        msg_Err( p_this, ""option %s does not exist"", psz_name );
        return -1;
    }

    assert(IsConfigFloatType(p_config->i_type));

    float val;

    vlc_rwlock_rdlock (&config_lock);
    val = p_config->value.f;
    vlc_rwlock_unlock (&config_lock);
    return val;
}",121.0,142.0,1.0,11.0,22.0,11,7,13,6,1,5,2,2,0,3,,0,3,4,2,2,float
1733,13723,config_GetPsz,1,config_GetPsz,"char* config_GetPsz (vlc_object_t*,char*)",config\core.c,"char * config_GetPsz( vlc_object_t *p_this, const char *psz_name )
{
    module_config_t *p_config;

    p_config = config_FindConfig( psz_name );

    /* sanity checks */
    if( !p_config )
    {
        msg_Err( p_this, ""option %s does not exist"", psz_name );
        return NULL;
    }

    assert(IsConfigStringType (p_config->i_type));

    /* return a copy of the string */
    vlc_rwlock_rdlock (&config_lock);
    char *psz_value = strdupnull (p_config->value.psz);
    vlc_rwlock_unlock (&config_lock);

    return psz_value;
}",156.0,177.0,1.0,11.0,22.0,11,7,14,7,7,6,2,2,0,4,,0,4,4,2,2,char*
1734,13774,config_PutPsz,1,config_PutPsz,"void config_PutPsz (vlc_object_t*,char*,char*)",config\core.c,"void config_PutPsz( vlc_object_t *p_this,
                      const char *psz_name, const char *psz_value )
{
    module_config_t *p_config = config_FindConfig( psz_name );


    /* sanity checks */
    if( !p_config )
    {
        msg_Warn( p_this, ""option %s does not exist"", psz_name );
        return;
    }

    assert(IsConfigStringType(p_config->i_type));

    char *str, *oldstr;
    if ((psz_value != NULL) && *psz_value)
        str = strdup (psz_value);
    else
        str = NULL;

    vlc_rwlock_wrlock (&config_lock);
    oldstr = (char *)p_config->value.psz;
    p_config->value.psz = str;
    config_dirty = true;
    vlc_rwlock_unlock (&config_lock);

    free (oldstr);
}",187.0,215.0,1.0,11.0,29.0,20,10,22,11,3,6,3,3,0,3,,0,4,6,3,3,void
1735,13854,config_PutInt,1,config_PutInt,"void config_PutInt (vlc_object_t*,char*,int64_t)",config\core.c,"void config_PutInt( vlc_object_t *p_this, const char *psz_name,
                    int64_t i_value )
{
    module_config_t *p_config = config_FindConfig( psz_name );

    /* sanity checks */
    if( !p_config )
    {
        msg_Warn( p_this, ""option %s does not exist"", psz_name );
        return;
    }

    assert(IsConfigIntegerType(p_config->i_type));

    if (i_value < p_config->min.i)
        i_value = p_config->min.i;
    if (i_value > p_config->max.i)
        i_value = p_config->max.i;

    vlc_rwlock_wrlock (&config_lock);
    p_config->value.i = i_value;
    config_dirty = true;
    vlc_rwlock_unlock (&config_lock);
}",225.0,248.0,1.0,11.0,24.0,24,9,22,8,0,6,4,4,0,3,,0,4,6,3,3,void
1736,13936,config_PutFloat,1,config_PutFloat,"void config_PutFloat (vlc_object_t*,char*,float)",config\core.c,"void config_PutFloat( vlc_object_t *p_this,
                      const char *psz_name, float f_value )
{
    module_config_t *p_config = config_FindConfig( psz_name );

    /* sanity checks */
    if( !p_config )
    {
        msg_Warn( p_this, ""option %s does not exist"", psz_name );
        return;
    }

    assert(IsConfigFloatType(p_config->i_type));

    /* if f_min == f_max == 0, then do not use them */
    if ((p_config->min.f == 0.f) && (p_config->max.f == 0.f))
        ;
    else if (f_value < p_config->min.f)
        f_value = p_config->min.f;
    else if (f_value > p_config->max.f)
        f_value = p_config->max.f;

    vlc_rwlock_wrlock (&config_lock);
    p_config->value.f = f_value;
    config_dirty = true;
    vlc_rwlock_unlock (&config_lock);
}",257.0,283.0,1.0,11.0,27.0,18,7,16,8,0,6,3,3,0,3,,0,4,6,3,3,void
1737,14037,config_GetIntChoices,1,config_GetIntChoices,"ssize_t config_GetIntChoices (vlc_object_t*,char*,int64_t**,char***)",config\core.c,"ssize_t config_GetIntChoices (vlc_object_t *obj, const char *name,
                             int64_t **restrict values, char ***restrict texts)
{
    *values = NULL;
    *texts = NULL;

    module_config_t *cfg = config_FindConfig(name);
    if (cfg == NULL)
    {
        msg_Warn (obj, ""option %s does not exist"", name);
        errno = ENOENT;
        return -1;
    }

    size_t count = cfg->list_count;
    if (count == 0)
    {
        if (module_Map(obj, cfg->owner))
        {
            errno = EIO;
            return -1;
        }

        if (cfg->list.i_cb == NULL)
            return 0;
        return cfg->list.i_cb(obj, name, values, texts);
    }

    int64_t *vals = vlc_alloc (count, sizeof (*vals));
    char **txts = vlc_alloc (count, sizeof (*txts));
    if (vals == NULL || txts == NULL)
    {
        errno = ENOMEM;
        goto error;
    }

    for (size_t i = 0; i < count; i++)
    {
        vals[i] = cfg->list.i[i];
        /* FIXME: use module_gettext() instea...",293.0,352.0,1.0,1.0,60.0,55,14,67,15,1,3,11,14,1,3,,0,3,8,4,4,ssize_t
1738,14238,config_ListModules,1,config_ListModules,"ssize_t config_ListModules (char*,char***,char***)",config\core.c,"static ssize_t config_ListModules (const char *cap, char ***restrict values,
                                   char ***restrict texts)
{
    module_t **list;
    ssize_t n = module_list_cap (&list, cap);
    if (unlikely(n < 0))
    {
        *values = *texts = NULL;
        return n;
    }

    char **vals = xmalloc ((n + 2) * sizeof (*vals));
    char **txts = xmalloc ((n + 2) * sizeof (*txts));

    vals[0] = xstrdup (""any"");
    txts[0] = xstrdup (_(""Automatic""));

    for (ssize_t i = 0; i < n; i++)
    {
        vals[i + 1] = xstrdup (module_get_object (list[i]));
        txts[i + 1] = xstrdup (module_gettext (list[i],
                               module_get_name (list[i], true)));
    }

    vals[n + 1] = xstrdup (""none"");
    txts[n + 1] = xstrdup (_(""Disable""));

    *values = vals;
    *texts = txts;
    module_list_free (list);
    return n + 2;
}",355.0,386.0,1.0,1.0,32.0,43,8,40,10,1,5,3,3,0,5,,0,4,6,3,3,ssize_t
1739,14373,config_GetPszChoices,1,config_GetPszChoices,"ssize_t config_GetPszChoices (vlc_object_t*,char*,char***,char***)",config\core.c,"ssize_t config_GetPszChoices (vlc_object_t *obj, const char *name,
                              char ***restrict values, char ***restrict texts)
{
    *values = *texts = NULL;

    module_config_t *cfg = config_FindConfig(name);
    if (cfg == NULL)
    {
        errno = ENOENT;
        return -1;
    }

    switch (cfg->i_type)
    {
        case CONFIG_ITEM_MODULE:
            return config_ListModules (cfg->psz_type, values, texts);
        default:
            if (!IsConfigStringType (cfg->i_type))
            {
                errno = EINVAL;
                return -1;
            }
            break;
    }

    size_t count = cfg->list_count;
    if (count == 0)
    {
        if (module_Map(obj, cfg->owner))
        {
            errno = EIO;
            return -1;
        }

        if (cfg->list.psz_cb == NULL)
            return 0;
        return cfg->list.psz_cb(obj, name, values, texts);
    }

    char **vals = xmalloc (sizeof (*vals) * count);
    char **txts = xmalloc...",397.0,450.0,1.0,17.0,54.0,60,14,61,16,1,4,9,11,1,4,,0,3,8,4,4,ssize_t
1740,14570,confcmp,1,confcmp,"int confcmp (void*,void*)",config\core.c,"static int confcmp (const void *a, const void *b)
{
    const module_config_t *const *ca = a, *const *cb = b;

    return strcmp ((*ca)->psz_name, (*cb)->psz_name);
}",452.0,457.0,1.0,1.0,6.0,6,3,6,4,0,0,1,1,0,0,,0,0,4,2,2,int
1741,14594,confnamecmp,1,confnamecmp,"int confnamecmp (void*,void*)",config\core.c,"static int confnamecmp (const void *key, const void *elem)
{
    const module_config_t *const *conf = elem;

    return strcmp (key, (*conf)->psz_name);
}",459.0,464.0,1.0,1.0,6.0,3,3,4,3,0,0,1,1,0,0,,0,0,4,2,2,int
1742,14766,config_FindConfig,1,config_FindConfig,module_config_t config_FindConfig (char*),config\core.c,"module_config_t *config_FindConfig(const char *name)
{
    if (unlikely(name == NULL))
        return NULL;

    module_config_t *const *p;
    p = bsearch (name, config.list, config.count, sizeof (*p), confnamecmp);
    return p ? *p : NULL;
}",523.0,531.0,1.0,1.0,9.0,8,6,11,4,14,2,2,2,0,0,,0,2,2,1,1,module_config_t
1743,14862,config_ResetAll,1,config_ResetAll,void config_ResetAll (vlc_object_t*),config\core.c,"void config_ResetAll( vlc_object_t *p_this )
{
    vlc_rwlock_wrlock (&config_lock);
    for (vlc_plugin_t *p = vlc_plugins; p != NULL; p = p->next)
    {
        for (size_t i = 0; i < p->conf.size; i++ )
        {
            module_config_t *p_config = p->conf.items + i;

            if (IsConfigIntegerType (p_config->i_type))
                p_config->value.i = p_config->orig.i;
            else
            if (IsConfigFloatType (p_config->i_type))
                p_config->value.f = p_config->orig.f;
            else
            if (IsConfigStringType (p_config->i_type))
            {
                free ((char *)p_config->value.psz);
                p_config->value.psz =
                        strdupnull (p_config->orig.psz);
            }
        }
    }
    vlc_rwlock_unlock (&config_lock);

    VLC_UNUSED(p_this);
}",561.0,587.0,1.0,16.0,27.0,21,8,18,8,0,4,4,7,0,2,,0,2,2,1,1,void
1744,15054,config_GetConfigFile,1,config_GetConfigFile,char* config_GetConfigFile (vlc_object_t*),config\file.c,"static char *config_GetConfigFile( vlc_object_t *obj )
{
    char *psz_file = var_CreateGetNonEmptyString( obj, ""config"" );
    var_Destroy( obj, ""config"" );
    if( psz_file == NULL )
    {
        char *psz_dir = config_GetUserDir( VLC_CONFIG_DIR );

        if( asprintf( &psz_file, ""%s"" DIR_SEP CONFIG_FILE, psz_dir ) == -1 )
            psz_file = NULL;
        free( psz_dir );
    }
    return psz_file;
}",59.0,72.0,1.0,46.0,14.0,4,2,11,5,2,1,3,4,0,1,,0,1,2,1,1,char*
1745,15088,config_OpenConfigFile,1,config_OpenConfigFile,FILE config_OpenConfigFile (vlc_object_t*),config\file.c,"static FILE *config_OpenConfigFile( vlc_object_t *p_obj )
{
    char *psz_filename = config_GetConfigFile( p_obj );
    if( psz_filename == NULL )
        return NULL;

    msg_Dbg( p_obj, ""opening config file (%s)"", psz_filename );

    FILE *p_stream = vlc_fopen( psz_filename, ""rt"" );
    if( p_stream == NULL && errno != ENOENT )
    {
        msg_Err( p_obj, ""cannot open config file (%s): %s"",
                 psz_filename, vlc_strerror_c(errno) );

    }
#if !( defined(_WIN32) || defined(__APPLE__) || defined(__OS2__) )
    else if( p_stream == NULL && errno == ENOENT )
    {
        /* This is the fallback for pre XDG Base Directory
         * Specification configs */
        char *home = config_GetUserDir(VLC_HOME_DIR);
        char *psz_old;

        if( home != NULL
         && asprintf( &psz_old, ""%s/.vlc/"" CONFIG_FILE,
                      home ) != -1 )
        {
            p_stream = vlc_fopen( psz_old, ""rt"" );
            if( p_stream )
            {
                /...",74.0,138.0,1.0,43.0,65.0,6,4,18,6,0,3,3,3,0,3,,0,2,2,1,1,FILE
1746,15212,vlc_strtoi,1,vlc_strtoi,int64_t vlc_strtoi (char*),config\file.c,"static int64_t vlc_strtoi (const char *str)
{
    char *end;
    long long l;

    errno = 0;
    l = strtoll (str, &end, 0);

    if (!errno)
    {
#if (LLONG_MAX > 0x7fffffffffffffffLL)
        if (l > 0x7fffffffffffffffLL
         || l < -0x8000000000000000LL)
            errno = ERANGE;
#endif
        if (*end)
            errno = EINVAL;
    }
    return l;
}",141.0,160.0,1.0,1.0,20.0,6,4,9,5,0,0,3,4,0,0,,0,0,2,1,1,int64_t
1747,15578,config_Write,1,config_Write,"int config_Write (FILE*,char*,char*,bool,char*,char*...)",config\file.c,"static int
config_Write (FILE *file, const char *desc, const char *type,
              bool comment, const char *name, const char *fmt, ...)
{
    va_list ap;
    int ret;

    if (desc == NULL)
        desc = ""?"";

    if (fprintf (file, ""# %s (%s)\n%s%s="", desc, vlc_gettext (type),
                 comment ? ""#"" : """", name) < 0)
        return -1;

    va_start (ap, fmt);
    ret = vfprintf (file, fmt, ap);
    va_end (ap);
    if (ret < 0)
        return -1;

    if (fputs (""\n\n"", file) == EOF)
        return -1;
    return 0;
}",302.0,325.0,1.0,1.0,24.0,10,5,18,10,0,1,5,5,1,1,,0,1,12,6,6,int
1748,15647,config_PrepareDir,1,config_PrepareDir,int config_PrepareDir (vlc_object_t*),config\file.c,"static int config_PrepareDir (vlc_object_t *obj)
{
    char *psz_configdir = config_GetUserDir (VLC_CONFIG_DIR);
    if (psz_configdir == NULL)
        return -1;

    int ret = config_CreateDir (obj, psz_configdir);
    free (psz_configdir);
    return ret;
}",328.0,337.0,1.0,1.0,10.0,4,3,9,5,1,2,2,2,0,2,,0,2,2,1,1,int
1749,15675,config_SaveConfigFile,1,config_SaveConfigFile,int config_SaveConfigFile (vlc_object_t*),config\file.c,"int config_SaveConfigFile (vlc_object_t *p_this)
{

    if( config_PrepareDir( p_this ) )
    {
        msg_Err( p_this, ""no configuration directory"" );
        return -1;
    }

    /*
     * Save module config in file
     */
    char *temporary;
    char *permanent = config_GetConfigFile (p_this);
    if (permanent == NULL)
        return -1;
    if (asprintf (&temporary, ""%s.%u"", permanent, getpid ()) == -1)
    {
        free (permanent);
        return -1;
    }
    else
    {
        struct stat st;

        /* Some users make vlcrc read-only to prevent changes.
         * The atomic replacement scheme breaks this ""feature"",
         * so we check for read-only by hand. */
        if (stat (permanent, &st) == 0 && !(st.st_mode & S_IWUSR))
        {
            msg_Err (p_this, ""configuration file is read-only"");
            goto error;
        }
    }

    /* Configuration lock must be taken before vlcrc serializer below. */
    vlc_rwlock_rdlock (&config_lock);

    /* The t...",344.0,523.0,1.0,16.0,180.0,62,15,84,25,1,20,20,22,3,18,,0,6,2,1,1,int
1750,16142,exchange,1,exchange,"void exchange (char**,vlc_getopt_t*)",config\getopt.c,"static void exchange(char **argv, vlc_getopt_t *restrict state)
{
    int bottom = state->first_nonopt;
    int middle = state->last_nonopt;
    int top = state->ind;
    char *tem;

    /* Exchange the shorter segment with the far end of the longer segment.
       That puts the shorter segment into the right place.
       It leaves the longer segment in the right place overall,
       but it consists of two parts that need to be swapped next.  */

    while (top > middle && middle > bottom)
    {
        if (top - middle > middle - bottom)
        {
            /* Bottom segment is the short one.  */
            int len = middle - bottom;
            register int i;

            /* Swap it with the top part of the top segment.  */
            for (i = 0; i < len; i++)
            {
                tem = argv[bottom + i];
                argv[bottom + i] = argv[top - (middle - bottom) + i];
                argv[top - (middle - bottom) + i] = tem;
            }
            /* Exclude...",41.0,93.0,1.0,1.0,53.0,40,10,45,8,2,0,4,7,0,0,,0,0,4,2,2,void
1751,16305,vlc_getopt_long,1,vlc_getopt_long,"int vlc_getopt_long (int,char**,char*,vlc_option*,int*,vlc_getopt_t*)",config\getopt.c,"int vlc_getopt_long(int argc, char *const *argv,
                    const char *optstring,
                    const struct vlc_option *restrict longopts, int *longind,
                    vlc_getopt_t *restrict state)
{
    state->arg = NULL;

    if (state->ind == 0)
    {
        /* Initialize the internal data when the first call is made.  */
        /* Start processing options with ARGV-element 1 (since ARGV-element 0
           is the program name); the sequence of previously skipped
           non-option ARGV-elements is empty.  */
        state->first_nonopt = state->last_nonopt = state->ind = 1;
        state->nextchar = NULL;
    }

#define NONOPTION_P (argv[state->ind][0] != '-' || argv[state->ind][1] == '\0')

    if (state->nextchar == NULL || *state->nextchar == '\0')
    {
        /* Advance to the next ARGV-element.  */

        /* Give FIRST_NONOPT & LAST_NONOPT rational values if OPTIND has been
           moved back by the user (who may also have changed the argu...",146.0,479.0,1.0,36.0,334.0,246,18,174,16,1,14,35,74,6,2,,0,12,12,6,6,int
1752,17411,Help,1,Help,"void Help (vlc_object_t*,char*)",config\help.c,"static void Help (vlc_object_t *p_this, char const *psz_help_name)
{
    ShowConsole();

    if( psz_help_name && !strcmp( psz_help_name, ""help"" ) )
    {
        printf(_(vlc_usage), ""vlc"");
        Usage( p_this, ""=core"" );
        print_help_on_full_help();
    }
    else if( psz_help_name && !strcmp( psz_help_name, ""longhelp"" ) )
    {
        printf(_(vlc_usage), ""vlc"");
        Usage( p_this, NULL );
        print_help_on_full_help();
    }
    else if( psz_help_name && !strcmp( psz_help_name, ""full-help"" ) )
    {
        printf(_(vlc_usage), ""vlc"");
        Usage( p_this, NULL );
    }
    else if( psz_help_name )
    {
        Usage( p_this, psz_help_name );
    }

    PauseConsole();
}",201.0,228.0,1.0,4.0,28.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
1753,17417,Usage,1,Usage,"void Usage (vlc_object_t*,char*)",config\help.c,"static void Usage (vlc_object_t *p_this, char const *psz_search)
{
    bool b_has_advanced = false;
    bool found = false;
    unsigned i_only_advanced = 0; /* Number of modules ignored because they
                               * only have advanced options */
    bool strict = false;
    if (psz_search != NULL && psz_search[0] == '=')
    {
        strict = true;
        psz_search++;
    }

    bool color = false;
#ifndef _WIN32
    if (isatty(STDOUT_FILENO))
        color = var_InheritBool(p_this, ""color"");
#endif

    const bool desc = var_InheritBool(p_this, ""help-verbose"");
    const bool advanced = var_InheritBool(p_this, ""advanced"");

    /* Enumerate the config for each module */
    for (const vlc_plugin_t *p = vlc_plugins; p != NULL; p = p->next)
    {
        const module_t *m = p->module;
        const module_config_t *section = NULL;
        const char *objname = module_get_object(m);

        if (p->conf.count == 0)
            continue; /* Ignore modules without co...",585.0,665.0,1.0,29.0,81.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
1754,17423,Version,1,Version,void Version (void),config\help.c,"static void Version( void )
{
    ShowConsole();
    printf(_(""VLC version %s (%s)\n""), VERSION_MESSAGE, psz_vlc_changeset);
    printf(_(""Compiled by %s on %s (%s)\n""), VLC_CompileBy(),
           VLC_CompileHost(), __DATE__"" ""__TIME__ );
    printf(_(""Compiler: %s\n""), VLC_Compiler());
    fputs(LICENSE_MSG, stdout);
    PauseConsole();
}",718.0,727.0,1.0,4.0,10.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1755,17428,ListModules,1,ListModules,"void ListModules (vlc_object_t*,ANY)",config\help.c,"static void ListModules (vlc_object_t *p_this, bool b_verbose)
{
    bool color = false;

    ShowConsole();
#ifndef _WIN32
    if (isatty(STDOUT_FILENO))
        color = var_InheritBool(p_this, ""color"");
#else
    (void) p_this;
#endif

    /* List all modules */
    size_t count;
    module_t **list = module_list_get (&count);

    /* Enumerate each module */
    for (size_t j = 0; j < count; j++)
    {
        module_t *p_parser = list[j];
        const char *objname = module_get_object (p_parser);
        printf(color ? GREEN""  %-22s ""WHITE""%s\n""GRAY : ""  %-22s %s\n"",
               objname, module_gettext(p_parser, p_parser->psz_longname));

        if( b_verbose )
        {
            const char *const *pp_shortcuts = p_parser->pp_shortcuts;
            for( unsigned i = 0; i < p_parser->i_shortcuts; i++ )
                if( strcmp( pp_shortcuts[i], objname ) )
                    printf(color ? CYAN""   s %s\n""GRAY : ""   s %s\n"",
                           pp_shortcuts[i]);
...",673.0,711.0,1.0,4.0,39.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
1756,17434,ConsoleWidth,1,ConsoleWidth,unsigned ConsoleWidth (void),config\help.c,"static unsigned ConsoleWidth(void)
{
#ifdef TIOCGWINSZ
    struct winsize ws;

    if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &ws) == 0)
        return ws.ws_col;
#endif
#ifdef WIOCGETD
    struct uwdata uw;

    if (ioctl(STDOUT_FILENO, WIOCGETD, &uw) == 0)
        return uw.uw_height / uw.uw_vs;
#endif
#if defined (_WIN32) && !VLC_WINSTORE_APP
    CONSOLE_SCREEN_BUFFER_INFO buf;

    if (GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &buf))
        return buf.dwSize.X;
#endif
    return 80;
}",66.0,87.0,1.0,1.0,22.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,unsigned
1757,17540,print_help_on_full_help,1,print_help_on_full_help,void print_help_on_full_help (void),config\help.c,"static inline void print_help_on_full_help( void )
{
    putchar('\n');
    puts(_(""To get exhaustive help, use '-H'.""));
}",161.0,165.0,1.0,1.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1758,17630,print_section,1,print_section,"void print_section (module_t*,module_config_t**,bool,bool)",config\help.c,"static void print_section(const module_t *m, const module_config_t **sect,
                          bool color, bool desc)
{
    const module_config_t *item = *sect;

    if (item == NULL)
        return;
    *sect = NULL;

    printf(color ? RED""   %s:\n""GRAY : ""   %s:\n"",
           module_gettext(m, item->psz_text));
    if (desc && item->psz_longtext != NULL)
        printf(color ? MAGENTA""   %s\n""GRAY : ""   %s\n"",
               module_gettext(m, item->psz_longtext));
}",247.0,261.0,1.0,19.0,15.0,12,7,15,6,1,2,3,3,0,2,,0,0,8,4,4,void
1759,17686,print_desc,1,print_desc,"void print_desc (char*,unsigned,bool)",config\help.c,"static void print_desc(const char *str, unsigned margin, bool color)
{
    unsigned width = ConsoleWidth() - margin;

    if (color)
        fputs(BLUE, stdout);

    const char *word = str;
    int wordlen = 0, wordwidth = 0;
    unsigned offset = 0;
    bool newline = true;

    while (str[0])
    {
        uint32_t cp;
        size_t charlen = vlc_towc(str, &cp);
        if (unlikely(charlen == (size_t)-1))
            break;

        int charwidth = wcwidth(cp);
        if (charwidth < 0)
            charwidth = 0;

        str += charlen;

        if (iswspace(cp))
        {
            if (!newline)
            {
                putchar(' '); /* insert space */
                charwidth = 1;
            }
            fwrite(word, 1, wordlen, stdout); /* write complete word */
            word = str;
            wordlen = 0;
            wordwidth = 0;
            newline = false;
        }
        else
        {
            wordlen += charlen;
            wordwidth += charwidth...",263.0,326.0,1.0,14.0,64.0,33,10,59,16,3,2,11,18,0,2,,0,2,6,3,3,void
1760,17854,vlc_swidth,1,vlc_swidth,int vlc_swidth (char*),config\help.c,"static int vlc_swidth(const char *str)
{
    for (int total = 0;;)
    {
        uint32_t cp;
        size_t charlen = vlc_towc(str, &cp);

        if (charlen == 0)
            return total;
        if (charlen == (size_t)-1)
            return -1;
        str += charlen;

        int w = wcwidth(cp);
        if (w == -1)
            return -1;
        total += w;
    }
}",328.0,346.0,1.0,1.0,19.0,13,6,15,6,2,1,5,8,0,1,,0,1,2,1,1,int
1761,17911,print_item,1,print_item,"void print_item (vlc_object_t*,module_t*,module_config_t*,module_config_t**,bool,bool)",config\help.c,"static void print_item(const vlc_object_t *p_this, const module_t *m, const module_config_t *item,
                       const module_config_t **section, bool color, bool desc)
{
#ifndef _WIN32
# define OPTION_VALUE_SEP "" ""
#else
# define OPTION_VALUE_SEP ""=""
#endif
    const char *bra = OPTION_VALUE_SEP ""<"", *type, *ket = "">"";
    const char *prefix = NULL, *suffix = NULL;
    char *typebuf = NULL;

    switch (CONFIG_CLASS(item->i_type))
    {
        case 0: // hint class
            switch (item->i_type)
            {
                case CONFIG_HINT_CATEGORY:
                case CONFIG_HINT_USAGE:
                    printf(color ? GREEN ""\n %s\n"" GRAY : ""\n %s\n"",
                           module_gettext(m, item->psz_text));

                    if (desc && item->psz_longtext != NULL)
                        printf(color ? CYAN "" %s\n"" GRAY : "" %s\n"",
                               module_gettext(m, item->psz_longtext));
                    break;

                case CONF...",348.0,544.0,1.0,22.0,197.0,132,20,160,30,0,12,32,54,0,12,,0,5,12,6,6,void
1762,18586,module_match,1,module_match,"bool module_match (module_t*,char*,bool)",config\help.c,"static bool module_match(const module_t *m, const char *pattern, bool strict)
{
    if (pattern == NULL)
        return true;

    const char *objname = module_get_object(m);

    if (strict ? (strcmp(objname, pattern) == 0)
               : (strstr(objname, pattern) != NULL))
        return true;

    for (unsigned i = 0; i < m->i_shortcuts; i++)
    {
        const char *shortcut = m->pp_shortcuts[i];

        if (strict ? (strcmp(shortcut, pattern) == 0)
                   : (strstr(shortcut, pattern) != NULL))
            return true;
    }
    return false;
}",546.0,566.0,1.0,1.0,21.0,14,7,26,9,0,3,5,6,1,1,,0,3,6,3,3,bool
1763,18661,plugin_show,1,plugin_show,"bool plugin_show (vlc_plugin_t*,bool)",config\help.c,"static bool plugin_show(const vlc_plugin_t *plugin, bool advanced)
{
    for (size_t i = 0; i < plugin->conf.size; i++)
    {
        const module_config_t *item = plugin->conf.items + i;

        if (!CONFIG_ITEM(item->i_type))
            continue;
        if (item->b_removed)
            continue;
        if ((!advanced) && item->b_advanced)
            continue;
        return true;
    }
    return false;
}",568.0,583.0,1.0,1.0,16.0,14,7,12,6,0,2,8,8,1,0,,0,2,4,2,2,bool
1764,19147,config_AddIntf,1,config_AddIntf,"void config_AddIntf (vlc_object_t*,char*)",config\intf.c,"void config_AddIntf( vlc_object_t *p_this, const char *psz_intf )
{
    vlc_object_t *libvlc = VLC_OBJECT(p_this->obj.libvlc);

    assert( psz_intf );

    char *psz_config, *psz_parser;
    size_t i_len = strlen( psz_intf );

    psz_config = psz_parser = config_GetPsz( libvlc, ""control"" );
    while( psz_parser )
    {
        if( !strncmp( psz_intf, psz_parser, i_len ) )
        {
            free( psz_config );
            return;
        }
        psz_parser = strchr( psz_parser, ':' );
        if( psz_parser ) psz_parser++; /* skip the ':' */
    }
    free( psz_config );

    psz_config = psz_parser = config_GetPsz( libvlc, ""extraintf"" );
    while( psz_parser )
    {
        if( !strncmp( psz_intf, psz_parser, i_len ) )
        {
            free( psz_config );
            return;
        }
        psz_parser = strchr( psz_parser, ':' );
        if( psz_parser ) psz_parser++; /* skip the ':' */
    }

    /* interface not found in the config, let's add it */
    if( psz_con...",34.0,82.0,1.0,1.0,49.0,19,10,39,7,0,3,9,14,0,3,,0,2,4,2,2,void
1765,19267,config_RemoveIntf,1,config_RemoveIntf,"void config_RemoveIntf (vlc_object_t*,char*)",config\intf.c,"void config_RemoveIntf( vlc_object_t *p_this, const char *psz_intf )
{
    vlc_object_t *libvlc = VLC_OBJECT(p_this->obj.libvlc);

    assert( psz_intf );

    char *psz_config, *psz_parser;
    size_t i_len = strlen( psz_intf );

    psz_config = psz_parser = config_GetPsz( libvlc, ""extraintf"" );
    while( psz_parser )
    {
        if( !strncmp( psz_intf, psz_parser, i_len ) )
        {
            char *psz_newconfig;
            char *psz_end = psz_parser + i_len;
            if( *psz_end == ':' ) psz_end++;
            *psz_parser = '\0';
            if( asprintf( &psz_newconfig, ""%s%s"", psz_config, psz_end ) != -1 )
            {
                config_PutPsz( libvlc, ""extraintf"", psz_newconfig );
                free( psz_newconfig );
            }
            break;
        }
        psz_parser = strchr( psz_parser, ':' );
        if( psz_parser ) psz_parser++; /* skip the ':' */
    }
    free( psz_config );

    psz_config = psz_parser = config_GetPsz( libvlc, ""control"" )...",86.0,136.0,1.0,1.0,51.0,34,11,53,8,0,4,13,23,0,4,,0,2,4,2,2,void
1766,19423,config_ExistIntf,1,config_ExistIntf,"bool config_ExistIntf (vlc_object_t*,char*)",config\intf.c,"bool config_ExistIntf( vlc_object_t *p_this, const char *psz_intf )
{
    vlc_object_t *libvlc = VLC_OBJECT(p_this->obj.libvlc);

    assert( psz_intf );

    char *psz_config, *psz_parser;
    size_t i_len = strlen( psz_intf );

    psz_config = psz_parser = config_GetPsz( libvlc, ""extraintf"" );
    while( psz_parser )
    {
        if( !strncmp( psz_parser, psz_intf, i_len ) )
        {
            free( psz_config );
            return true;
        }
        psz_parser = strchr( psz_parser, ':' );
        if( psz_parser ) psz_parser++; /* skip the ':' */
    }
    free( psz_config );

    psz_config = psz_parser = config_GetPsz( libvlc, ""control"" );
    while( psz_parser )
    {
        if( !strncmp( psz_parser, psz_intf, i_len ) )
        {
            free( psz_config );
            return true;
        }
        psz_parser = strchr( psz_parser, ':' );
        if( psz_parser ) psz_parser++; /* skip the ':' */
    }
    free( psz_config );

    return false;
}",143.0,179.0,1.0,1.0,37.0,14,5,34,8,0,2,7,11,0,2,,0,2,4,2,2,bool
1767,19562,config_GetLibDir,1,config_GetLibDir,char* config_GetLibDir (void),win32\dirs.c,"char *config_GetLibDir (void)
{
#if VLC_WINSTORE_APP
    return NULL;
#else
    /* Get our full path */
    MEMORY_BASIC_INFORMATION mbi;
    if (!VirtualQuery (config_GetLibDir, &mbi, sizeof(mbi)))
        goto error;

    wchar_t wpath[MAX_PATH];
    if (!GetModuleFileName ((HMODULE) mbi.AllocationBase, wpath, MAX_PATH))
        goto error;

    wchar_t *file = wcsrchr (wpath, L'\\');
    if (file == NULL)
        goto error;
    *file = L'\0';

    return FromWide (wpath);
error:
    abort ();
#endif
}",184.0,207.0,1.0,1.0,24.0,34,12,39,9,1,0,9,16,0,0,,0,0,2,1,1,char*
1768,19717,config_GetDataDir,1,config_GetDataDir,char* config_GetDataDir (void),win32\dirs.c,"char *config_GetDataDir (void)
{
    const char *path = getenv (""VLC_DATA_PATH"");
    return (path != NULL) ? strdup (path) : config_GetLibDir ();
}",209.0,213.0,1.0,1.0,5.0,6,4,10,4,1,1,3,3,0,1,,0,1,2,1,1,char*
1769,19776,getAppDependentDir,1,getAppDependentDir,char* getAppDependentDir (vlc_userdir_t),darwin\dirs.c,"static char *getAppDependentDir(vlc_userdir_t type)
{
    const char *psz_path;
    switch (type) {
        case VLC_CONFIG_DIR:
            psz_path = ""%s/Library/Preferences/%s"";
            break;
        case VLC_TEMPLATES_DIR:
        case VLC_DATA_DIR:
            psz_path = ""%s/Library/Application Support/%s"";
            break;
        case VLC_CACHE_DIR:
            psz_path = ""%s/Library/Caches/%s"";
            break;
        default:
            vlc_assert_unreachable();
            break;
    }

    // Default fallback
    const char *fallback = ""org.videolan.vlc"";
    char *name = NULL;

    CFBundleRef mainBundle = CFBundleGetMainBundle();
    if (mainBundle) {
        CFStringRef identifierAsNS = CFBundleGetIdentifier(mainBundle);
        if (identifierAsNS) {
            CFIndex len = CFStringGetLength(identifierAsNS);
            CFIndex size = CFStringGetMaximumSizeForEncoding(len, kCFStringEncodingUTF8);
            char *identifier = calloc(len + 1, sizeof(char))...",121.0,169.0,1.0,1.0,49.0,21,8,46,19,0,1,11,13,0,1,,0,1,2,1,1,char*
1770,20212,vlc_clock_setup_once,1,vlc_clock_setup_once,void vlc_clock_setup_once (void),darwin\thread.c,"static void vlc_clock_setup_once (void)
{
    if (unlikely(mach_timebase_info (&vlc_clock_conversion_factor) != 0))
        abort ();
}",47.0,51.0,1.0,1.0,5.0,2,2,1,1,0,1,2,2,1,0,,0,1,2,1,1,void
1771,20230,mtime_to_ts,1,mtime_to_ts,struct timespec mtime_to_ts (mtime_t),posix\thread.c,"static struct timespec mtime_to_ts (mtime_t date)
{
    lldiv_t d = lldiv (date, CLOCK_FREQ);
    struct timespec ts = { d.quot, d.rem * (1000000000 / CLOCK_FREQ) };

    return ts;
}",110.0,116.0,1.0,1.0,7.0,7,5,8,4,3,0,1,1,0,0,,0,0,2,1,1,struct timespec
1772,20257,vlc_trace,1,vlc_trace,"void vlc_trace (char*,char*,unsigned)",posix\thread.c,"void vlc_trace (const char *fn, const char *file, unsigned line)
{
     fprintf (stderr, ""at %s:%u in %s\n"", file, line, fn);
     fflush (stderr); /* needed before switch to low-level I/O */
#ifdef HAVE_BACKTRACE
     void *stack[20];
     int len = backtrace (stack, sizeof (stack) / sizeof (stack[0]));
     backtrace_symbols_fd (stack, len, 2);
#endif
     fsync (2);
}",121.0,131.0,1.0,1.0,11.0,5,4,11,6,1,0,1,1,0,0,,0,0,6,3,3,void
1773,20291,vlc_thread_fatal,1,vlc_thread_fatal,"void vlc_thread_fatal (char*,int,char*,char*,unsigned)",posix\thread.c,"static void
vlc_thread_fatal (const char *action, int error,
                  const char *function, const char *file, unsigned line)
{
    int canc = vlc_savecancel ();
    fprintf (stderr, ""LibVLC fatal error %s (%d) in thread %lu "",
             action, error, vlc_thread_id ());
    vlc_trace (function, file, line);
    perror (""Thread error"");
    fflush (stderr);

    vlc_restorecancel (canc);
    abort ();
}",137.0,150.0,1.0,1.0,14.0,5,2,19,10,12,4,5,2,0,4,,0,1,10,5,5,void
1774,20506,vlc_cond_init,1,vlc_cond_init,void vlc_cond_init (vlc_cond_t*),posix\thread.c,"void vlc_cond_init (vlc_cond_t *p_condvar)
{
    pthread_condattr_t attr;

    if (unlikely(pthread_condattr_init (&attr)))
        abort ();
#if (_POSIX_CLOCK_SELECTION > 0)
    vlc_clock_setup ();
    pthread_condattr_setclock (&attr, vlc_clock_id);
#endif
    if (unlikely(pthread_cond_init (p_condvar, &attr)))
        abort ();
    pthread_condattr_destroy (&attr);
}",232.0,245.0,1.0,5.0,14.0,0,0,2,2,20,0,2,2,0,0,,0,0,2,1,1,void
1775,20518,vlc_cond_init_daytime,1,vlc_cond_init_daytime,void vlc_cond_init_daytime (vlc_cond_t*),posix\thread.c,"void vlc_cond_init_daytime (vlc_cond_t *p_condvar)
{
    if (unlikely(pthread_cond_init (p_condvar, NULL)))
        abort ();
}",247.0,251.0,1.0,1.0,5.0,0,0,2,2,1,0,2,2,0,0,,0,0,2,1,1,void
1776,20530,vlc_cond_destroy,1,vlc_cond_destroy,void vlc_cond_destroy (vlc_cond_t*),posix\thread.c,"void vlc_cond_destroy (vlc_cond_t *p_condvar)
{
    int val = pthread_cond_destroy( p_condvar );
    VLC_THREAD_ASSERT (""destroying condition"");
}",253.0,257.0,1.0,4.0,5.0,3,3,9,4,27,1,3,4,0,1,,0,0,2,1,1,void
1777,20566,vlc_cond_signal,1,vlc_cond_signal,void vlc_cond_signal (vlc_cond_t*),posix\thread.c,"void vlc_cond_signal (vlc_cond_t *p_condvar)
{
    int val = pthread_cond_signal( p_condvar );
    VLC_THREAD_ASSERT (""signaling condition variable"");
}",259.0,263.0,1.0,4.0,5.0,1,1,5,3,39,1,1,1,0,1,,0,0,2,1,1,void
1778,20588,vlc_cond_broadcast,1,vlc_cond_broadcast,void vlc_cond_broadcast (vlc_cond_t*),posix\thread.c,"void vlc_cond_broadcast (vlc_cond_t *p_condvar)
{
    pthread_cond_broadcast (p_condvar);
}",265.0,268.0,1.0,1.0,4.0,0,0,1,1,8,0,1,1,0,0,,0,0,2,1,1,void
1779,20595,vlc_cond_wait,1,vlc_cond_wait,"void vlc_cond_wait (vlc_cond_t*,vlc_mutex_t*)",posix\thread.c,"void vlc_cond_wait (vlc_cond_t *p_condvar, vlc_mutex_t *p_mutex)
{
    int val = pthread_cond_wait( p_condvar, p_mutex );
    VLC_THREAD_ASSERT (""waiting on condition"");
}",270.0,274.0,1.0,4.0,5.0,1,1,6,4,9,1,1,1,0,1,,0,0,4,2,2,void
1780,20619,vlc_cond_timedwait,1,vlc_cond_timedwait,"int vlc_cond_timedwait (vlc_cond_t*,vlc_mutex_t*,mtime_t)",posix\thread.c,"int vlc_cond_timedwait (vlc_cond_t *p_condvar, vlc_mutex_t *p_mutex,
                        mtime_t deadline)
{
    struct timespec ts = mtime_to_ts (deadline);
    int val = pthread_cond_timedwait (p_condvar, p_mutex, &ts);
    if (val != ETIMEDOUT)
        VLC_THREAD_ASSERT (""timed-waiting on condition"");
    return val;
}",276.0,284.0,1.0,8.0,9.0,8,5,17,8,7,3,3,3,0,3,,0,2,6,3,3,int
1781,20674,vlc_cond_timedwait_daytime,1,vlc_cond_timedwait_daytime,"int vlc_cond_timedwait_daytime (vlc_cond_t*,vlc_mutex_t*,time_t)",posix\thread.c,"int vlc_cond_timedwait_daytime (vlc_cond_t *p_condvar, vlc_mutex_t *p_mutex,
                                time_t deadline)
{
    struct timespec ts = { deadline, 0 };
    int val = pthread_cond_timedwait (p_condvar, p_mutex, &ts);
    if (val != ETIMEDOUT)
        VLC_THREAD_ASSERT (""timed-waiting on condition"");
    return val;
}",286.0,294.0,1.0,8.0,9.0,4,3,12,7,0,2,2,2,0,2,,0,1,6,3,3,int
1782,20714,vlc_sem_init,1,vlc_sem_init,"void vlc_sem_init (vlc_sem_t*,unsigned)",posix\thread.c,"void vlc_sem_init (vlc_sem_t *sem, unsigned value)
{
    if (unlikely(sem_init (sem, 0, value)))
        abort ();
}",296.0,300.0,1.0,1.0,5.0,1,1,4,4,4,0,2,2,0,0,,0,0,4,2,2,void
1783,20731,vlc_sem_destroy,1,vlc_sem_destroy,void vlc_sem_destroy (vlc_sem_t*),posix\thread.c,"void vlc_sem_destroy (vlc_sem_t *sem)
{
    int val;

    if (likely(sem_destroy (sem) == 0))
        return;

    val = errno;

    VLC_THREAD_ASSERT (""destroying semaphore"");
}",302.0,312.0,1.0,4.0,11.0,3,3,7,5,7,1,2,2,0,1,,0,0,2,1,1,void
1784,20762,vlc_sem_post,1,vlc_sem_post,int vlc_sem_post (vlc_sem_t*),posix\thread.c,"int vlc_sem_post (vlc_sem_t *sem)
{
    int val;

    if (likely(sem_post (sem) == 0))
        return 0;

    val = errno;

    if (unlikely(val != EOVERFLOW))
        VLC_THREAD_ASSERT (""unlocking semaphore"");
    return val;
}",314.0,326.0,1.0,8.0,13.0,4,4,10,6,8,1,3,3,0,1,,0,0,2,1,1,int
1785,20801,vlc_sem_wait,1,vlc_sem_wait,void vlc_sem_wait (vlc_sem_t*),posix\thread.c,"void vlc_sem_wait (vlc_sem_t *sem)
{
    int val;

    do
        if (likely(sem_wait (sem) == 0))
            return;
    while ((val = errno) == EINTR);

    VLC_THREAD_ASSERT (""locking semaphore"");
}",328.0,338.0,1.0,4.0,11.0,3,3,7,5,6,1,2,2,0,1,,0,0,2,1,1,void
1786,20831,vlc_rwlock_init,1,vlc_rwlock_init,void vlc_rwlock_init (vlc_rwlock_t*),posix\thread.c,"void vlc_rwlock_init (vlc_rwlock_t *lock)
{
    if (unlikely(pthread_rwlock_init (lock, NULL)))
        abort ();
}",340.0,344.0,1.0,1.0,5.0,0,0,2,2,0,0,2,2,0,0,,0,0,2,1,1,void
1787,20843,vlc_rwlock_destroy,1,vlc_rwlock_destroy,void vlc_rwlock_destroy (vlc_rwlock_t*),posix\thread.c,"void vlc_rwlock_destroy (vlc_rwlock_t *lock)
{
    int val = pthread_rwlock_destroy (lock);
    VLC_THREAD_ASSERT (""destroying R/W lock"");
}",346.0,350.0,1.0,4.0,5.0,1,1,5,3,0,1,1,1,0,1,,0,0,2,1,1,void
1788,20865,vlc_rwlock_rdlock,1,vlc_rwlock_rdlock,void vlc_rwlock_rdlock (vlc_rwlock_t*),posix\thread.c,"void vlc_rwlock_rdlock (vlc_rwlock_t *lock)
{
    int val = pthread_rwlock_rdlock (lock);
    VLC_THREAD_ASSERT (""acquiring R/W lock for reading"");
}",352.0,356.0,1.0,4.0,5.0,1,1,5,3,5,1,1,1,0,1,,0,0,2,1,1,void
1789,20887,vlc_rwlock_wrlock,1,vlc_rwlock_wrlock,void vlc_rwlock_wrlock (vlc_rwlock_t*),posix\thread.c,"void vlc_rwlock_wrlock (vlc_rwlock_t *lock)
{
    int val = pthread_rwlock_wrlock (lock);
    VLC_THREAD_ASSERT (""acquiring R/W lock for writing"");
}",358.0,362.0,1.0,4.0,5.0,1,1,5,3,5,1,1,1,0,1,,0,0,2,1,1,void
1790,20909,vlc_rwlock_unlock,1,vlc_rwlock_unlock,void vlc_rwlock_unlock (vlc_rwlock_t*),posix\thread.c,"void vlc_rwlock_unlock (vlc_rwlock_t *lock)
{
    int val = pthread_rwlock_unlock (lock);
    VLC_THREAD_ASSERT (""releasing R/W lock"");
}",364.0,368.0,1.0,4.0,5.0,1,1,5,3,12,1,1,1,0,1,,0,0,2,1,1,void
1791,21137,vlc_thread_id,1,vlc_thread_id,unsigned long vlc_thread_id (void),win32\thread.c,"unsigned long vlc_thread_id (void)
{
    return GetCurrentThreadId ();
}",571.0,574.0,1.0,1.0,4.0,1,1,0,0,3,0,1,1,0,0,,0,0,2,1,1,unsigned long
1792,21295,mwait,1,mwait,void mwait (mtime_t),posix\thread.c,"void mwait (mtime_t deadline)
{
#if (_POSIX_CLOCK_SELECTION > 0)
    vlc_clock_setup ();
    /* If the deadline is already elapsed, or within the clock precision,
     * do not even bother the system timer. */
    deadline -= vlc_clock_prec;

    struct timespec ts = mtime_to_ts (deadline);

    while (clock_nanosleep (vlc_clock_id, TIMER_ABSTIME, &ts, NULL) == EINTR);

#else
    deadline -= mdate ();
    if (deadline > 0)
        msleep (deadline);

#endif
}",648.0,666.0,1.0,5.0,19.0,2,2,3,1,2,2,2,2,0,2,,0,0,2,1,1,void
1793,21310,msleep,1,msleep,void msleep (mtime_t),posix\thread.c,"void msleep (mtime_t delay)
{
    struct timespec ts = mtime_to_ts (delay);

#if (_POSIX_CLOCK_SELECTION > 0)
    vlc_clock_setup ();
    while (clock_nanosleep (vlc_clock_id, 0, &ts, &ts) == EINTR);

#else
    while (nanosleep (&ts, &ts) == -1)
        assert (errno == EINTR);

#endif
}",669.0,682.0,1.0,5.0,14.0,5,4,4,2,2,1,2,2,0,1,,0,1,2,1,1,void
1794,22731,ISO6937toUTF8,1,ISO6937toUTF8,"size_t ISO6937toUTF8 (char**,size_t*,unsigned char**,size_t*,uint16_t*)",extras\libc.c,"static size_t ISO6937toUTF8( const char **inbuf, size_t *inbytesleft,
                             unsigned char **outbuf, size_t *outbytesleft,
                             const uint16_t *ucs4_table )


{
    if( !inbuf || !(*inbuf) )
        return (size_t)(0);    /* Reset state requested */

    const char *iptr = *inbuf;
    const char *iend = iptr + *inbytesleft;
    unsigned char *optr = *outbuf;
    unsigned char *oend = optr + *outbytesleft;
    int err = 0;

    while ( iptr < iend )
    {
        unsigned char c1 = *iptr;
        uint_fast16_t ch = ucs4_table[c1];

        if( c1 >= 0xc1 && c1 <= 0xcf )
        {
            /* Composed character */
            if ( iptr + 1 >= iend )
            {
                err = EINVAL;
                break;    /* No next character */
            }

            unsigned char c2 = iptr[1];
            if ( c2 < 0x40 || c2 >= 0x80 ||
                 !(ch = to_ucs4_comb[c1 - 0xc1][c2 - 0x40]) )
            {
                err = E...",292.0,391.0,1.0,1.0,100.0,58,14,57,18,1,1,12,17,1,0,,0,1,10,5,5,size_t
1795,22999,vlc_iconv_open,1,vlc_iconv_open,"vlc_iconv_t vlc_iconv_open (char*,char*)",extras\libc.c,"vlc_iconv_t vlc_iconv_open( const char *tocode, const char *fromcode )
{
#ifndef __linux__
    if( !strcasecmp(tocode, ""UTF-8"") && !strcasecmp(fromcode, ""ISO_6937"") )
        return (vlc_iconv_t)(-2);
    else if( !strcasecmp(tocode, ""UTF-8"") && !strcasecmp(fromcode, ""ISO_6937-2"") )
        return (vlc_iconv_t)(-3);
#endif
#if defined(HAVE_ICONV)
# if defined(__OS2__) && defined(__INNOTEK_LIBC__)
    char tocode_ucs2[] = ""UCS-2LE"";
    char fromcode_ucs2[] = ""UCS-2LE"";
    os2_iconv_t *p_os2_iconv;

    /* Workaround for UTF-16 because OS/2 supports UCS-2 only not UTF-16 */
    if( !strncmp( tocode, ""UTF-16"", 6 ))
    {
        strncpy( tocode_ucs2 + 5, tocode + 6, 2 );
        tocode = tocode_ucs2;
    }

    if( !strncmp( fromcode, ""UTF-16"", 6 ))
    {
        strncpy( fromcode_ucs2 + 5, fromcode + 6, 2 );
        fromcode = fromcode_ucs2;
    }

    p_os2_iconv = ( os2_iconv_t * )iconv_open( tocode, fromcode );

    if( p_os2_iconv != ( iconv_t )(-1))
    {
        /* Mimic a beh...",397.0,445.0,1.0,1.0,49.0,5,3,2,2,3,0,2,2,0,0,,0,0,4,2,2,vlc_iconv_t
1796,23041,vlc_iconv,1,vlc_iconv,"size_t vlc_iconv (vlc_iconv_t,char**,size_t*,char**,size_t*)",extras\libc.c,"size_t vlc_iconv( vlc_iconv_t cd, const char **inbuf, size_t *inbytesleft,
                  char **outbuf, size_t *outbytesleft )
{
    size_t ret;

#ifndef __linux__
    if ( cd == (vlc_iconv_t)(-2) || cd == (vlc_iconv_t)(-3) )
    {
        unsigned char *out = NULL;
        if (outbuf != NULL)
            out = (unsigned char *)*outbuf;

        const uint16_t *ucs4_table = ( cd == (vlc_iconv_t)(-2) ? ISO6937toUCS4 : ISO6937_2toUCS4 );

        ret = ISO6937toUTF8( inbuf, inbytesleft, &out, outbytesleft, ucs4_table );
        if (outbuf != NULL)
            *outbuf = (char *)out;
    }
    else
#endif
#if defined(HAVE_ICONV)
    {
        ICONV_CONST char *cin = NULL;
        if (inbuf != NULL)
            cin = (ICONV_CONST char *)*inbuf;

        ret = iconv( cd, &cin, inbytesleft, outbuf, outbytesleft );
        if (inbuf != NULL)
            *inbuf = cin;
    }
#else
        abort ();
#endif
    return ret;
}",447.0,481.0,1.0,1.0,35.0,20,9,23,11,4,3,4,6,0,1,,0,3,10,5,5,size_t
1797,23115,vlc_iconv_close,1,vlc_iconv_close,int vlc_iconv_close (vlc_iconv_t),extras\libc.c,"int vlc_iconv_close( vlc_iconv_t cd )
{
#ifndef __linux__
    if ( cd == (vlc_iconv_t)(-2) || cd == (vlc_iconv_t)(-3) )
        return 0;
#endif
#if defined(HAVE_ICONV)
    return iconv_close( cd );
#else
    abort ();
#endif
}",483.0,494.0,1.0,1.0,12.0,5,3,2,1,4,0,2,2,0,0,,0,0,2,1,1,int
1798,23136,vlc_ureduce,1,vlc_ureduce,"bool vlc_ureduce (unsigned*,unsigned*,uint64_t,uint64_t,uint64_t)",extras\libc.c,"bool vlc_ureduce( unsigned *pi_dst_nom, unsigned *pi_dst_den,
                        uint64_t i_nom, uint64_t i_den, uint64_t i_max )
{
    bool b_exact = 1;
    uint64_t i_gcd;

    if( i_den == 0 )
    {
        *pi_dst_nom = 0;
        *pi_dst_den = 1;
        return 1;
    }

    i_gcd = GCD( i_nom, i_den );
    i_nom /= i_gcd;
    i_den /= i_gcd;

    if( i_max == 0 ) i_max = INT64_C(0xFFFFFFFF);

    if( i_nom > i_max || i_den > i_max )
    {
        uint64_t i_a0_num = 0, i_a0_den = 1, i_a1_num = 1, i_a1_den = 0;
        b_exact = 0;

        for( ; ; )
        {
            uint64_t i_x = i_nom / i_den;
            uint64_t i_a2n = i_x * i_a1_num + i_a0_num;
            uint64_t i_a2d = i_x * i_a1_den + i_a0_den;

            if( i_a2n > i_max || i_a2d > i_max ) break;

            i_nom %= i_den;

            i_a0_num = i_a1_num; i_a0_den = i_a1_den;
            i_a1_num = i_a2n; i_a1_den = i_a2d;
            if( i_nom == 0 ) break;
            i_x = i_nom; i_nom = i_den; ...",500.0,547.0,1.0,1.0,48.0,44,9,63,14,11,0,9,12,0,0,,0,0,10,5,5,bool
1799,23321,get_path,1,get_path,char* get_path (char*),input\access.c,"char *get_path(const char *location)
{
    char *url, *path;

    /* Prepending ""file://"" is a bit hackish. But then again, we do not want
     * to hard-code the list of schemes that use file paths in vlc_uri2path().
     */
    if (asprintf(&url, ""file://%s"", location) == -1)
        return NULL;

    path = vlc_uri2path (url);
    free (url);
    return path;
}",42.0,55.0,1.0,1.0,14.0,4,4,7,4,3,1,2,2,0,1,,0,1,2,1,1,char*
1800,23348,vlc_access_Destroy,1,vlc_access_Destroy,void vlc_access_Destroy (stream_t*),input\access.c,"static void vlc_access_Destroy(stream_t *access)
{
    module_unneed(access, access->p_module);
    free(access->psz_filepath);
    free(access->psz_name);
}",57.0,62.0,1.0,1.0,6.0,3,1,4,1,0,1,1,1,0,1,,0,0,2,1,1,void
1801,23366,access_New,1,access_New,"stream_t access_New (vlc_object_t*,input_thread_t*,bool,char*)",input\access.c,"static stream_t *access_New(vlc_object_t *parent, input_thread_t *input,
                            bool preparsing, const char *mrl)
{
    char *redirv[MAX_REDIR];
    unsigned redirc = 0;

    stream_t *access = vlc_stream_CommonNew(parent, vlc_access_Destroy);
    if (unlikely(access == NULL))
        return NULL;

    access->p_input = input;
    access->psz_name = NULL;
    access->psz_url = strdup(mrl);
    access->psz_filepath = NULL;
    access->b_preparsing = preparsing;

    if (unlikely(access->psz_url == NULL))
        goto error;

    while (redirc < MAX_REDIR)
    {
        char *url = access->psz_url;
        msg_Dbg(access, ""creating access: %s"", url);

        const char *p = strstr(url, ""://"");
        if (p == NULL)
            goto error;

        access->psz_name = strndup(url, p - url);
        if (unlikely(access->psz_name == NULL))
            goto error;

        access->psz_location = p + 3;
        access->psz_filepath = get_path(access->psz_location);
  ...",69.0,144.0,1.0,17.0,76.0,59,10,72,12,2,4,16,20,0,4,,0,3,8,4,4,stream_t
1802,23625,vlc_access_NewMRL,1,vlc_access_NewMRL,"stream_t vlc_access_NewMRL (vlc_object_t*,char*)",input\access.c,"stream_t *vlc_access_NewMRL(vlc_object_t *parent, const char *mrl)
{
    return access_New(parent, NULL, false, mrl);
}",146.0,149.0,1.0,1.0,4.0,0,0,4,4,0,1,1,1,0,1,,0,0,4,2,2,stream_t
1803,23637,access_vaDirectoryControlHelper,1,access_vaDirectoryControlHelper,"int access_vaDirectoryControlHelper (stream_t*,int,va_list)",input\access.c,"int access_vaDirectoryControlHelper( stream_t *p_access, int i_query, va_list args )
{
    VLC_UNUSED( p_access );

    switch( i_query )
    {
        case STREAM_CAN_SEEK:
        case STREAM_CAN_FASTSEEK:
        case STREAM_CAN_PAUSE:
        case STREAM_CAN_CONTROL_PACE:
            *va_arg( args, bool* ) = false;
            break;
        case STREAM_GET_PTS_DELAY:
            *va_arg( args, int64_t * ) = 0;
            break;
        case STREAM_IS_DIRECTORY:
            break;
        default:
            return VLC_EGENERIC;
     }
     return VLC_SUCCESS;
}",154.0,175.0,1.0,1.0,22.0,0,0,10,10,0,0,5,2,0,0,,0,0,6,3,3,int
1804,23671,AStreamNoReadDir,1,AStreamNoReadDir,"int AStreamNoReadDir (stream_t*,input_item_node_t*)",input\access.c,"static int AStreamNoReadDir(stream_t *s, input_item_node_t *p_node)
{
    (void) s; (void) p_node;
    return VLC_EGENERIC;;
}",177.0,181.0,1.0,1.0,5.0,2,1,3,3,0,0,1,1,0,0,,0,0,4,2,2,int
1805,23685,AStreamReadBlock,1,AStreamReadBlock,"block_t AStreamReadBlock (stream_t*,bool*)",input\access.c,"static block_t *AStreamReadBlock(stream_t *s, bool *restrict eof)
{
    stream_t *access = s->p_sys;
    input_thread_t *input = s->p_input;
    block_t * block;

    if (vlc_stream_Eof(access))
    {
        *eof = true;
        return NULL;
    }
    if (vlc_killed())
        return NULL;

    block = vlc_stream_ReadBlock(access);

    if (block != NULL && input != NULL)
    {
        uint64_t total;

        vlc_mutex_lock(&input_priv(input)->counters.counters_lock);
        stats_Update(input_priv(input)->counters.p_read_bytes,
                     block->i_buffer, &total);
        stats_Update(input_priv(input)->counters.p_input_bitrate, total, NULL);
        stats_Update(input_priv(input)->counters.p_read_packets, 1, NULL);
        vlc_mutex_unlock(&input_priv(input)->counters.counters_lock);
    }

    return block;
}",184.0,213.0,1.0,1.0,30.0,24,7,26,8,0,13,4,4,2,13,,0,8,4,2,2,block_t
1806,23781,AStreamReadStream,1,AStreamReadStream,"ssize_t AStreamReadStream (stream_t*,void*,size_t)",input\access.c,"static ssize_t AStreamReadStream(stream_t *s, void *buf, size_t len)
{
    stream_t *access = s->p_sys;
    input_thread_t *input = s->p_input;

    if (vlc_stream_Eof(access))
        return 0;
    if (vlc_killed())
        return -1;

    ssize_t val = vlc_stream_ReadPartial(access, buf, len);

    if (val > 0 && input != NULL)
    {
        uint64_t total;

        vlc_mutex_lock(&input_priv(input)->counters.counters_lock);
        stats_Update(input_priv(input)->counters.p_read_bytes, val, &total);
        stats_Update(input_priv(input)->counters.p_input_bitrate, total, NULL);
        stats_Update(input_priv(input)->counters.p_read_packets, 1, NULL);
        vlc_mutex_unlock(&input_priv(input)->counters.counters_lock);
    }

    return val;
}",216.0,240.0,1.0,1.0,25.0,22,8,23,8,0,13,4,4,2,13,,0,8,6,3,3,ssize_t
1807,23875,AStreamReadDir,1,AStreamReadDir,"int AStreamReadDir (stream_t*,input_item_node_t*)",input\access.c,"static int AStreamReadDir(stream_t *s, input_item_node_t *p_node)
{
    stream_t *access = s->p_sys;

    return access->pf_readdir(access, p_node);
}",243.0,248.0,1.0,1.0,6.0,3,2,5,3,0,0,1,1,0,0,,0,0,4,2,2,int
1808,23894,AStreamSeek,1,AStreamSeek,"int AStreamSeek (stream_t*,uint64_t)",input\access.c,"static int AStreamSeek(stream_t *s, uint64_t offset)
{
    stream_t *access = s->p_sys;

    return vlc_stream_Seek(access, offset);
}",251.0,256.0,1.0,1.0,6.0,2,2,4,3,0,1,1,1,0,1,,0,0,4,2,2,int
1809,23910,AStreamControl,1,AStreamControl,"int AStreamControl (stream_t*,int,va_list)",input\access.c,"static int AStreamControl(stream_t *s, int cmd, va_list args)
{
    stream_t *access = s->p_sys;

    return vlc_stream_vaControl(access, cmd, args);
}",258.0,263.0,1.0,1.0,6.0,2,2,5,4,0,1,1,1,0,1,,0,0,6,3,3,int
1810,23928,AStreamDestroy,1,AStreamDestroy,void AStreamDestroy (stream_t*),input\access.c,"static void AStreamDestroy(stream_t *s)
{
    stream_t *access = s->p_sys;

    vlc_stream_Delete(access);
}",265.0,270.0,1.0,1.0,6.0,2,2,3,2,0,1,1,1,0,1,,0,0,2,1,1,void
1811,23941,stream_AccessNew,1,stream_AccessNew,"stream_t stream_AccessNew (vlc_object_t*,input_thread_t*,bool,char*)",input\access.c,"stream_t *stream_AccessNew(vlc_object_t *parent, input_thread_t *input,
                           bool preparsing, const char *url)
{
    stream_t *s = vlc_stream_CommonNew(parent, AStreamDestroy);
    if (unlikely(s == NULL))
        return NULL;

    stream_t *access = access_New(VLC_OBJECT(s), input, preparsing, url);
    if (access == NULL)
    {
        stream_CommonDelete(s);
        return NULL;
    }

    s->p_input = input;
    s->psz_url = strdup(access->psz_url);

    const char *cachename;

    if (access->pf_block != NULL)
    {
        s->pf_block = AStreamReadBlock;
        cachename = ""prefetch,cache_block"";
    }
    else
    if (access->pf_read != NULL)
    {
        s->pf_read = AStreamReadStream;
        cachename = ""prefetch,cache_read"";
    }
    else
    {
        cachename = NULL;
    }

    if (access->pf_readdir != NULL)
        s->pf_readdir = AStreamReadDir;
    else
        s->pf_readdir = AStreamNoReadDir;

    s->pf_seek    = AStreamSeek;
    s->pf_co...",272.0,319.0,1.0,1.0,48.0,26,4,35,8,2,5,6,6,0,5,,0,3,8,4,4,stream_t
1812,24100,AvgInit,1,AvgInit,"void AvgInit (average_t*,int)",input\clock.c,"static void AvgInit( average_t *p_avg, int i_divider )
{
    p_avg->i_divider = i_divider;
    AvgReset( p_avg );
}",637.0,641.0,1.0,1.0,5.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
1813,24106,AvgClean,1,AvgClean,void AvgClean (average_t*),input\clock.c,"static void AvgClean( average_t *p_avg )
{
    VLC_UNUSED(p_avg);
}",642.0,645.0,1.0,1.0,4.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1814,24111,AvgReset,1,AvgReset,void AvgReset (average_t*),input\clock.c,"static void AvgReset( average_t *p_avg )
{
    p_avg->i_value = 0;
    p_avg->i_residue = 0;
    p_avg->i_count = 0;
}",646.0,651.0,1.0,1.0,6.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1815,24116,AvgUpdate,1,AvgUpdate,"void AvgUpdate (average_t*,mtime_t)",input\clock.c,"static void AvgUpdate( average_t *p_avg, mtime_t i_value )
{
    const int i_f0 = __MIN( p_avg->i_divider - 1, p_avg->i_count );
    const int i_f1 = p_avg->i_divider - i_f0;

    const mtime_t i_tmp = i_f0 * p_avg->i_value + i_f1 * i_value + p_avg->i_residue;

    p_avg->i_value   = i_tmp / p_avg->i_divider;
    p_avg->i_residue = i_tmp % p_avg->i_divider;

    p_avg->i_count++;
}",652.0,663.0,1.0,1.0,12.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
1816,24122,AvgGet,1,AvgGet,mtime_t AvgGet (average_t*),input\clock.c,"static mtime_t AvgGet( average_t *p_avg )
{
    return p_avg->i_value;
}",664.0,667.0,1.0,1.0,4.0,0,0,0,0,4,0,1,1,0,0,,0,0,2,1,1,mtime_t
1817,24127,AvgRescale,1,AvgRescale,"void AvgRescale (average_t*,int)",input\clock.c,"static void AvgRescale( average_t *p_avg, int i_divider )
{
    const mtime_t i_tmp = p_avg->i_value * p_avg->i_divider + p_avg->i_residue;

    p_avg->i_divider = i_divider;
    p_avg->i_value   = i_tmp / p_avg->i_divider;
    p_avg->i_residue = i_tmp % p_avg->i_divider;
}",668.0,675.0,1.0,1.0,8.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
1818,24137,clock_point_Create,1,clock_point_Create,"clock_point_t clock_point_Create (mtime_t,mtime_t)",input\clock.c,"static inline clock_point_t clock_point_Create( mtime_t i_stream, mtime_t i_system )
{
    clock_point_t p = { .i_stream = i_stream, .i_system = i_system };
    return p;
}",132.0,136.0,1.0,1.0,5.0,4,2,6,3,5,0,1,1,0,0,,0,0,4,2,2,clock_point_t
1819,24184,ClockStreamToSystem,1,ClockStreamToSystem,"mtime_t ClockStreamToSystem (input_clock_t*,mtime_t)",input\clock.c,"static mtime_t ClockStreamToSystem( input_clock_t *cl, mtime_t i_stream )
{
    if( !cl->b_has_reference )
        return VLC_TS_INVALID;

    return ( i_stream - cl->ref.i_stream ) * cl->i_rate / INPUT_RATE_DEFAULT +
           cl->ref.i_system;
}",604.0,611.0,1.0,1.0,8.0,0,0,0,0,4,0,1,1,0,0,,0,0,4,2,2,mtime_t
1820,24190,ClockSystemToStream,1,ClockSystemToStream,"mtime_t ClockSystemToStream (input_clock_t*,mtime_t)",input\clock.c,"static mtime_t ClockSystemToStream( input_clock_t *cl, mtime_t i_system )
{
    assert( cl->b_has_reference );
    return ( i_system - cl->ref.i_system ) * INPUT_RATE_DEFAULT / cl->i_rate +
            cl->ref.i_stream;
}",618.0,623.0,1.0,1.0,6.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,mtime_t
1821,24196,ClockGetTsOffset,1,ClockGetTsOffset,mtime_t ClockGetTsOffset (input_clock_t*),input\clock.c,"static mtime_t ClockGetTsOffset( input_clock_t *cl )
{
    return cl->i_pts_delay * ( cl->i_rate - INPUT_RATE_DEFAULT ) / INPUT_RATE_DEFAULT;
}",629.0,632.0,1.0,1.0,4.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,mtime_t
1822,24201,input_clock_New,1,input_clock_New,input_clock_t input_clock_New (int),input\clock.c,"input_clock_t *input_clock_New( int i_rate )
{
    input_clock_t *cl = malloc( sizeof(*cl) );
    if( !cl )
        return NULL;

    vlc_mutex_init( &cl->lock );
    cl->b_has_reference = false;
    cl->ref = clock_point_Create( VLC_TS_INVALID, VLC_TS_INVALID );
    cl->b_has_external_clock = false;

    cl->last = clock_point_Create( VLC_TS_INVALID, VLC_TS_INVALID );

    cl->i_ts_max = VLC_TS_INVALID;

    cl->i_buffering_duration = 0;

    cl->i_next_drift_update = VLC_TS_INVALID;
    AvgInit( &cl->drift, 10 );

    cl->late.i_index = 0;
    for( int i = 0; i < INPUT_CLOCK_LATE_COUNT; i++ )
        cl->late.pi_value[i] = 0;

    cl->i_rate = i_rate;
    cl->i_pts_delay = 0;
    cl->b_paused = false;
    cl->i_pause_date = VLC_TS_INVALID;

    return cl;
}",191.0,221.0,1.0,24.0,31.0,35,8,32,6,1,17,3,3,0,4,,0,15,2,1,1,input_clock_t
1823,24320,input_clock_Delete,1,input_clock_Delete,void input_clock_Delete (input_clock_t*),input\clock.c,"void input_clock_Delete( input_clock_t *cl )
{
    AvgClean( &cl->drift );
    vlc_mutex_destroy( &cl->lock );
    free( cl );
}",226.0,231.0,1.0,1.0,6.0,4,2,3,1,1,4,1,1,0,2,,0,2,2,1,1,void
1824,24337,input_clock_Update,1,input_clock_Update,"void input_clock_Update (input_clock_t*,vlc_object_t*,bool*,bool,bool,mtime_t,mtime_t)",input\clock.c,"void input_clock_Update( input_clock_t *cl, vlc_object_t *p_log,
                         bool *pb_late,
                         bool b_can_pace_control, bool b_buffering_allowed,
                         mtime_t i_ck_stream, mtime_t i_ck_system )
{
    bool b_reset_reference = false;

    assert( i_ck_stream > VLC_TS_INVALID && i_ck_system > VLC_TS_INVALID );

    vlc_mutex_lock( &cl->lock );

    if( !cl->b_has_reference )
    {
        /* */
        b_reset_reference= true;
    }
    else if( cl->last.i_stream > VLC_TS_INVALID &&
             ( (cl->last.i_stream - i_ck_stream) > CR_MAX_GAP ||
               (cl->last.i_stream - i_ck_stream) < -CR_MAX_GAP ) )
    {
        /* Stream discontinuity, for which we haven't received a
         * warning from the stream control facilities (dd-edited
         * stream ?). */
        msg_Warn( p_log, ""clock gap, unexpected stream discontinuity"" );
        cl->i_ts_max = VLC_TS_INVALID;

        /* */
        msg_Warn( p_log, ""feeding syn...",239.0,327.0,1.0,51.0,89.0,66,15,57,13,1,25,6,6,2,9,,0,21,14,7,7,void
1825,24631,input_clock_Reset,1,input_clock_Reset,void input_clock_Reset (input_clock_t*),input\clock.c,"void input_clock_Reset( input_clock_t *cl )
{
    vlc_mutex_lock( &cl->lock );

    cl->b_has_reference = false;
    cl->ref = clock_point_Create( VLC_TS_INVALID, VLC_TS_INVALID );
    cl->b_has_external_clock = false;
    cl->i_ts_max = VLC_TS_INVALID;

    vlc_mutex_unlock( &cl->lock );
}",332.0,342.0,1.0,1.0,11.0,12,3,11,3,1,9,1,1,0,3,,0,7,2,1,1,void
1826,24668,input_clock_ChangeRate,1,input_clock_ChangeRate,"void input_clock_ChangeRate (input_clock_t*,int)",input\clock.c,"void input_clock_ChangeRate( input_clock_t *cl, int i_rate )
{
    vlc_mutex_lock( &cl->lock );

    if( cl->b_has_reference )
    {
        /* Move the reference point (as if we were playing at the new rate
         * from the start */
        cl->ref.i_system = cl->last.i_system - (cl->last.i_system - cl->ref.i_system) * i_rate / cl->i_rate;
    }
    cl->i_rate = i_rate;

    vlc_mutex_unlock( &cl->lock );
}",347.0,360.0,1.0,1.0,14.0,21,7,11,2,0,11,2,2,1,2,,0,9,4,2,2,void
1827,24723,input_clock_ChangePause,1,input_clock_ChangePause,"void input_clock_ChangePause (input_clock_t*,bool,mtime_t)",input\clock.c,"void input_clock_ChangePause( input_clock_t *cl, bool b_paused, mtime_t i_date )
{
    vlc_mutex_lock( &cl->lock );
    assert( (!cl->b_paused) != (!b_paused) );

    if( cl->b_paused )
    {
        const mtime_t i_duration = i_date - cl->i_pause_date;

        if( cl->b_has_reference && i_duration > 0 )
        {
            cl->ref.i_system += i_duration;
            cl->last.i_system += i_duration;
        }
    }
    cl->i_pause_date = i_date;
    cl->b_paused = b_paused;

    vlc_mutex_unlock( &cl->lock );
}",365.0,384.0,1.0,1.0,20.0,25,10,18,4,1,12,3,4,2,2,,0,10,6,3,3,void
1828,24794,input_clock_GetWakeup,1,input_clock_GetWakeup,mtime_t input_clock_GetWakeup (input_clock_t*),input\clock.c,"mtime_t input_clock_GetWakeup( input_clock_t *cl )
{
    mtime_t i_wakeup = 0;

    vlc_mutex_lock( &cl->lock );

    /* Synchronized, we can wait */
    if( cl->b_has_reference )
        i_wakeup = ClockStreamToSystem( cl, cl->last.i_stream + AvgGet( &cl->drift ) - cl->i_buffering_duration );

    vlc_mutex_unlock( &cl->lock );

    return i_wakeup;
}",389.0,402.0,1.0,1.0,14.0,14,6,10,2,1,10,2,2,1,4,,0,8,2,1,1,mtime_t
1829,24839,input_clock_ConvertTS,1,input_clock_ConvertTS,"int input_clock_ConvertTS (vlc_object_t*,input_clock_t*,int*,mtime_t*,mtime_t*,mtime_t)",input\clock.c,"int input_clock_ConvertTS( vlc_object_t *p_object, input_clock_t *cl,
                           int *pi_rate, mtime_t *pi_ts0, mtime_t *pi_ts1,
                           mtime_t i_ts_bound )
{
    assert( pi_ts0 );
    vlc_mutex_lock( &cl->lock );

    if( pi_rate )
        *pi_rate = cl->i_rate;

    if( !cl->b_has_reference )
    {
        vlc_mutex_unlock( &cl->lock );
        msg_Err(p_object, ""Timestamp conversion failed for %""PRId64"": ""
                ""no reference clock"", *pi_ts0);
        *pi_ts0 = VLC_TS_INVALID;
        if( pi_ts1 )
            *pi_ts1 = VLC_TS_INVALID;
        return VLC_EGENERIC;
    }

    /* */
    const mtime_t i_ts_buffering = cl->i_buffering_duration * cl->i_rate / INPUT_RATE_DEFAULT;
    const mtime_t i_ts_delay = cl->i_pts_delay + ClockGetTsOffset( cl );

    /* */
    if( *pi_ts0 > VLC_TS_INVALID )
    {
        *pi_ts0 = ClockStreamToSystem( cl, *pi_ts0 + AvgGet( &cl->drift ) );
        if( *pi_ts0 > cl->i_ts_max )
            cl->i_ts_max = ...",407.0,462.0,1.0,1.0,56.0,58,13,51,12,2,21,9,12,3,9,,0,18,12,6,6,int
1830,25003,input_clock_GetRate,1,input_clock_GetRate,int input_clock_GetRate (input_clock_t*),input\clock.c,"int input_clock_GetRate( input_clock_t *cl )
{
    int i_rate;

    vlc_mutex_lock( &cl->lock );
    i_rate = cl->i_rate;
    vlc_mutex_unlock( &cl->lock );

    return i_rate;
}",466.0,475.0,1.0,1.0,10.0,6,3,5,2,2,5,1,1,0,2,,0,3,2,1,1,int
1831,25026,input_clock_GetState,1,input_clock_GetState,"int input_clock_GetState (input_clock_t*,mtime_t*,mtime_t*,mtime_t*,mtime_t*)",input\clock.c,"int input_clock_GetState( input_clock_t *cl,
                          mtime_t *pi_stream_start, mtime_t *pi_system_start,
                          mtime_t *pi_stream_duration, mtime_t *pi_system_duration )
{
    vlc_mutex_lock( &cl->lock );

    if( !cl->b_has_reference )
    {
        vlc_mutex_unlock( &cl->lock );
        return VLC_EGENERIC;
    }

    *pi_stream_start = cl->ref.i_stream;
    *pi_system_start = cl->ref.i_system;

    *pi_stream_duration = cl->last.i_stream - cl->ref.i_stream;
    *pi_system_duration = cl->last.i_system - cl->ref.i_system;

    vlc_mutex_unlock( &cl->lock );

    return VLC_SUCCESS;
}",477.0,498.0,1.0,1.0,22.0,30,7,16,7,1,13,2,2,1,3,,0,10,10,5,5,int
1832,25104,input_clock_ChangeSystemOrigin,1,input_clock_ChangeSystemOrigin,"void input_clock_ChangeSystemOrigin (input_clock_t*,bool,mtime_t)",input\clock.c,"void input_clock_ChangeSystemOrigin( input_clock_t *cl, bool b_absolute, mtime_t i_system )
{
    vlc_mutex_lock( &cl->lock );

    assert( cl->b_has_reference );
    mtime_t i_offset;
    if( b_absolute )
    {
        i_offset = i_system - cl->ref.i_system - ClockGetTsOffset( cl );
    }
    else
    {
        if( !cl->b_has_external_clock )
        {
            cl->b_has_external_clock = true;
            cl->i_external_clock     = i_system;
        }
        i_offset = i_system - cl->i_external_clock;
    }

    cl->ref.i_system += i_offset;
    cl->last.i_system += i_offset;

    vlc_mutex_unlock( &cl->lock );
}",500.0,524.0,1.0,1.0,25.0,16,6,12,4,1,9,2,2,0,3,,0,7,6,3,3,void
1833,25180,input_clock_GetSystemOrigin,1,input_clock_GetSystemOrigin,"void input_clock_GetSystemOrigin (input_clock_t*,mtime_t*,mtime_t*)",input\clock.c,"void input_clock_GetSystemOrigin( input_clock_t *cl, mtime_t *pi_system, mtime_t *pi_delay )
{
    vlc_mutex_lock( &cl->lock );

    assert( cl->b_has_reference );

    *pi_system = cl->ref.i_system;
    if( pi_delay )
        *pi_delay  = cl->i_pts_delay;

    vlc_mutex_unlock( &cl->lock );
}",526.0,537.0,1.0,1.0,12.0,12,5,8,3,1,7,2,2,0,2,,0,5,6,3,3,void
1834,25218,input_clock_SetJitter,1,input_clock_SetJitter,"void input_clock_SetJitter (input_clock_t*,mtime_t,int)",input\clock.c,"void input_clock_SetJitter( input_clock_t *cl,
                            mtime_t i_pts_delay, int i_cr_average )
{
    vlc_mutex_lock( &cl->lock );

    /* Update late observations */
    const mtime_t i_delay_delta = i_pts_delay - cl->i_pts_delay;
    mtime_t pi_late[INPUT_CLOCK_LATE_COUNT];
    for( int i = 0; i < INPUT_CLOCK_LATE_COUNT; i++ )
        pi_late[i] = __MAX( cl->late.pi_value[(cl->late.i_index + 1 + i)%INPUT_CLOCK_LATE_COUNT] - i_delay_delta, 0 );

    for( int i = 0; i < INPUT_CLOCK_LATE_COUNT; i++ )
        cl->late.pi_value[i] = 0;
    cl->late.i_index = 0;

    for( int i = 0; i < INPUT_CLOCK_LATE_COUNT; i++ )
    {
        if( pi_late[i] <= 0 )
            continue;
        cl->late.pi_value[cl->late.i_index] = pi_late[i];
        cl->late.i_index = ( cl->late.i_index + 1 ) % INPUT_CLOCK_LATE_COUNT;
    }

    /* TODO always save the value, and when rebuffering use the new one if smaller
     * TODO when increasing -> force rebuffering
     */
    if( cl->i_pts...",540.0,577.0,1.0,20.0,38.0,43,11,30,6,1,10,9,9,2,3,,0,7,6,3,3,void
1835,25402,input_clock_GetJitter,1,input_clock_GetJitter,mtime_t input_clock_GetJitter (input_clock_t*),input\clock.c,"mtime_t input_clock_GetJitter( input_clock_t *cl )
{
    vlc_mutex_lock( &cl->lock );

#if INPUT_CLOCK_LATE_COUNT != 3
#   error ""unsupported INPUT_CLOCK_LATE_COUNT""
#endif
    /* Find the median of the last late values
     * It works pretty well at rejecting bad values
     *
     * XXX we only increase pts_delay over time, decreasing it is
     * not that easy if we want to be robust.
     */
    const mtime_t *p = cl->late.pi_value;
    mtime_t i_late_median = p[0] + p[1] + p[2] - __MIN(__MIN(p[0],p[1]),p[2]) - __MAX(__MAX(p[0],p[1]),p[2]);
    mtime_t i_pts_delay = cl->i_pts_delay ;

    vlc_mutex_unlock( &cl->lock );

    return i_pts_delay + i_late_median;
}",579.0,599.0,1.0,4.0,21.0,24,7,18,4,0,5,1,1,0,2,,0,3,2,1,1,mtime_t
1836,25842,UpdateBookmarksOption,1,UpdateBookmarksOption,void UpdateBookmarksOption (input_thread_t*),input\control.c,"static void UpdateBookmarksOption( input_thread_t *p_input )
{
    input_thread_private_t *priv = input_priv(p_input);
    input_item_t* item = priv->p_item;
    struct vlc_memstream vstr;

    vlc_memstream_open( &vstr );
    vlc_memstream_puts( &vstr, ""bookmarks="" );

    vlc_mutex_lock( &item->lock );
    var_Change( p_input, ""bookmark"", VLC_VAR_CLEARCHOICES, 0, 0 );

    for( int i = 0; i < priv->i_bookmark; i++ )
    {
        seekpoint_t const* sp = priv->pp_bookmark[i];

        /* Add bookmark to choice-list */
        var_Change( p_input, ""bookmark"", VLC_VAR_ADDCHOICE,
                    &(vlc_value_t){ .i_int = i },
                    &(vlc_value_t){ .psz_string = sp->psz_name } );

        /* Append bookmark to option-buffer */
        /* TODO: escape inappropriate values */
        vlc_memstream_printf( &vstr, ""%s{name=%s,time=%.3f}"",
            i > 0 ? "","" : """", sp->psz_name, ( 1. * sp->i_time_offset ) / CLOCK_FREQ );
    }

    if( vlc_memstream_close( &vstr ) )
   ...",591.0,663.0,1.0,1.0,73.0,0,0,0,0,4,0,1,1,0,0,,0,0,2,1,1,void
1837,25847,input_Control,1,input_Control,"int input_Control (input_thread_t*,int...)",input\control.c,"int input_Control( input_thread_t *p_input, int i_query, ...  )
{
    va_list args;
    int     i_result;

    va_start( args, i_query );
    i_result = input_vaControl( p_input, i_query, args );
    va_end( args );

    return i_result;
}",53.0,63.0,1.0,1.0,11.0,1,1,8,4,9,1,1,1,0,1,,0,1,4,2,2,int
1838,25868,input_vaControl,1,input_vaControl,"int input_vaControl (input_thread_t*,int,va_list)",input\control.c,"int input_vaControl( input_thread_t *p_input, int i_query, va_list args )
{
    input_thread_private_t *priv = input_priv(p_input);
    seekpoint_t *p_bkmk, ***ppp_bkmk;
    int i_bkmk = 0;
    int *pi_bkmk;

    int i_int, *pi_int;
    bool b_bool, *pb_bool;
    double f, *pf;
    int64_t i_64, *pi_64;

    char *psz;
    vlc_value_t val;

    switch( i_query )
    {
        case INPUT_GET_POSITION:
            pf = va_arg( args, double * );
            *pf = var_GetFloat( p_input, ""position"" );
            return VLC_SUCCESS;

        case INPUT_SET_POSITION:
            f = va_arg( args, double );
            return var_SetFloat( p_input, ""position"", f );

        case INPUT_GET_LENGTH:
            pi_64 = va_arg( args, int64_t * );
            *pi_64 = var_GetInteger( p_input, ""length"" );
            return VLC_SUCCESS;

        case INPUT_GET_TIME:
            pi_64 = va_arg( args, int64_t * );
            *pi_64 = var_GetInteger( p_input, ""time"" );
            return VLC_SUCCE...",65.0,589.0,1.0,1.0,525.0,320,21,416,123,1,129,42,83,18,57,,0,82,6,3,3,int
1839,27552,pf_update_stat,1,decoder_owner_sys_t.pf_update_stat,"void decoder_owner_sys_t.pf_update_stat (decoder_owner_sys_t*,unsigned,unsigned)",input\decoder.c,"void (*pf_update_stat)( decoder_owner_sys_t *, unsigned decoded, unsigned lost );",83.0,83.0,10.0,84.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
1840,27599,LoadDecoder,1,LoadDecoder,"int LoadDecoder (decoder_t*,bool,es_format_t*)",input\decoder.c,"static int LoadDecoder( decoder_t *p_dec, bool b_packetizer,
                        const es_format_t *restrict p_fmt )
{
    p_dec->b_frame_drop_allowed = true;
    p_dec->i_extra_picture_buffers = 0;

    p_dec->pf_decode = NULL;
    p_dec->pf_get_cc = NULL;
    p_dec->pf_packetize = NULL;
    p_dec->pf_flush = NULL;

    es_format_Copy( &p_dec->fmt_in, p_fmt );
    es_format_Init( &p_dec->fmt_out, p_fmt->i_cat, 0 );

    /* Find a suitable decoder/packetizer module */
    if( !b_packetizer )
    {
        static const char caps[ES_CATEGORY_COUNT][16] = {
            [VIDEO_ES] = ""video decoder"",
            [AUDIO_ES] = ""audio decoder"",
            [SPU_ES] = ""spu decoder"",
        };
        p_dec->p_module = module_need( p_dec, caps[p_dec->fmt_in.i_cat],
                                       ""$codec"", false );
    }
    else
        p_dec->p_module = module_need( p_dec, ""packetizer"", ""$packetizer"", false );

    if( !p_dec->p_module )
    {
        es_format_Clean( &p_dec->fm...",157.0,192.0,1.0,1.0,36.0,33,8,27,10,3,4,3,3,0,4,,0,1,6,3,3,int
1841,27715,UnloadDecoder,1,UnloadDecoder,void UnloadDecoder (decoder_t*),input\decoder.c,"static void UnloadDecoder( decoder_t *p_dec )
{
    if( p_dec->p_module )
    {
        module_unneed( p_dec, p_dec->p_module );
        p_dec->p_module = NULL;
    }

    if( p_dec->p_description )
    {
        vlc_meta_Delete( p_dec->p_description );
        p_dec->p_description = NULL;
    }

    es_format_Clean( &p_dec->fmt_in );
    es_format_Clean( &p_dec->fmt_out );
}",197.0,213.0,1.0,1.0,17.0,12,3,11,2,4,4,3,3,0,4,,0,0,2,1,1,void
1842,27759,ReloadDecoder,1,ReloadDecoder,"int ReloadDecoder (decoder_t*,bool,es_format_t*,reload)",input\decoder.c,"static int ReloadDecoder( decoder_t *p_dec, bool b_packetizer,
                          const es_format_t *restrict p_fmt, enum reload reload )
{
    /* Copy p_fmt since it can be destroyed by UnloadDecoder */
    es_format_t fmt_in;
    if( es_format_Copy( &fmt_in, p_fmt ) != VLC_SUCCESS )
    {
        p_dec->p_owner->error = true;
        return VLC_EGENERIC;
    }

    /* Restart the decoder module */
    UnloadDecoder( p_dec );
    p_dec->p_owner->error = false;

    if( reload == RELOAD_DECODER_AOUT )
    {
        decoder_owner_sys_t *p_owner = p_dec->p_owner;
        assert( p_owner->fmt.i_cat == AUDIO_ES );
        audio_output_t *p_aout = p_owner->p_aout;

        vlc_mutex_lock( &p_owner->lock );
        p_owner->p_aout = NULL;
        vlc_mutex_unlock( &p_owner->lock );
        if( p_aout )
        {
            aout_DecDelete( p_aout );
            input_resource_PutAout( p_owner->p_resource, p_aout );
        }
    }

    if( LoadDecoder( p_dec, b_packetizer, &fmt_in ...",215.0,254.0,1.0,1.0,40.0,29,6,34,14,0,15,5,6,2,9,,0,8,8,4,4,int
1843,27868,DecoderUpdateFormatLocked,1,DecoderUpdateFormatLocked,void DecoderUpdateFormatLocked (decoder_t*),input\decoder.c,"static void DecoderUpdateFormatLocked( decoder_t *p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    vlc_assert_locked( &p_owner->lock );

    es_format_Clean( &p_owner->fmt );
    es_format_Copy( &p_owner->fmt, &p_dec->fmt_out );

    /* Move p_description */
    if( p_dec->p_description != NULL )
    {
        if( p_owner->p_description != NULL )
            vlc_meta_Delete( p_owner->p_description );
        p_owner->p_description = p_dec->p_description;
        p_dec->p_description = NULL;
    }

    p_owner->b_fmt_description = true;
}",256.0,275.0,1.0,1.0,20.0,22,4,17,4,3,10,3,4,1,3,,0,7,2,1,1,void
1844,27933,aout_request_vout,1,aout_request_vout,"vout_thread_t aout_request_vout (void*,vout_thread_t*,video_format_t*,bool)",input\decoder.c,"static vout_thread_t *aout_request_vout( void *p_private,
                                         vout_thread_t *p_vout,
                                         const video_format_t *p_fmt, bool b_recyle )
{
    decoder_t *p_dec = p_private;
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    input_thread_t *p_input = p_owner->p_input;
    video_format_t fmt;

    if (p_fmt != NULL)
    {
        fmt = *p_fmt;
        p_fmt = &fmt;
        video_format_AdjustColorSpace( &fmt );
    }

    p_vout = input_resource_RequestVout( p_owner->p_resource, p_vout, p_fmt, 1,
                                         b_recyle );
    if( p_input != NULL )
        input_SendEventVout( p_input );

    return p_vout;
}",280.0,302.0,1.0,1.0,23.0,14,5,22,9,0,4,3,3,0,2,,0,3,8,4,4,vout_thread_t
1845,27993,aout_replaygain_changed,1,aout_replaygain_changed,"bool aout_replaygain_changed (audio_replay_gain_t*,audio_replay_gain_t*)",input\decoder.c,"static bool aout_replaygain_changed( const audio_replay_gain_t *a,
                                     const audio_replay_gain_t *b )
{
    for( size_t i=0; i<AUDIO_REPLAY_GAIN_MAX; i++ )
    {
        if( a->pb_gain[i] != b->pb_gain[i] ||
            a->pb_peak[i] != b->pb_peak[i] ||
            a->pb_gain[i] != b->pb_gain[i] ||
            a->pb_peak[i] != b->pb_peak[i] )
            return true;
    }
    return false;
}",304.0,316.0,1.0,1.0,13.0,25,6,21,6,1,0,3,4,0,0,,0,0,4,2,2,bool
1846,28064,aout_update_format,1,aout_update_format,int aout_update_format (decoder_t*),input\decoder.c,"static int aout_update_format( decoder_t *p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    if( p_owner->p_aout &&
       ( !AOUT_FMTS_IDENTICAL(&p_dec->fmt_out.audio, &p_owner->fmt.audio) ||
         p_dec->fmt_out.i_codec != p_dec->fmt_out.audio.i_format ||
         p_dec->fmt_out.i_profile != p_owner->fmt.i_profile ) )
    {
        audio_output_t *p_aout = p_owner->p_aout;

        /* Parameters changed, restart the aout */
        vlc_mutex_lock( &p_owner->lock );
        p_owner->p_aout = NULL;
        vlc_mutex_unlock( &p_owner->lock );
        aout_DecDelete( p_aout );

        input_resource_PutAout( p_owner->p_resource, p_aout );
    }

    /* Check if only replay gain has changed */
    if( aout_replaygain_changed( &p_dec->fmt_in.audio_replay_gain,
                                 &p_owner->fmt.audio_replay_gain ) )
    {
        p_dec->fmt_out.audio_replay_gain = p_dec->fmt_in.audio_replay_gain;
        if( p_owner->p_aout )
        {
            p_owner-...",318.0,412.0,1.0,1.0,95.0,117,13,77,13,0,38,12,23,9,15,,0,26,2,1,1,int
1847,28403,vout_update_format,1,vout_update_format,int vout_update_format (decoder_t*),input\decoder.c,"static int vout_update_format( decoder_t *p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    if( p_owner->p_vout == NULL
     || p_dec->fmt_out.video.i_width != p_owner->fmt.video.i_width
     || p_dec->fmt_out.video.i_height != p_owner->fmt.video.i_height
     || p_dec->fmt_out.video.i_visible_width != p_owner->fmt.video.i_visible_width
     || p_dec->fmt_out.video.i_visible_height != p_owner->fmt.video.i_visible_height
     || p_dec->fmt_out.video.i_x_offset != p_owner->fmt.video.i_x_offset
     || p_dec->fmt_out.video.i_y_offset != p_owner->fmt.video.i_y_offset
     || p_dec->fmt_out.i_codec != p_owner->fmt.video.i_chroma
     || (int64_t)p_dec->fmt_out.video.i_sar_num * p_owner->fmt.video.i_sar_den !=
        (int64_t)p_dec->fmt_out.video.i_sar_den * p_owner->fmt.video.i_sar_num ||
        p_dec->fmt_out.video.orientation != p_owner->fmt.video.orientation ||
        p_dec->fmt_out.video.multiview_mode != p_owner->fmt.video.multiview_mode )
    {
        vout_threa...",414.0,561.0,1.0,1.0,148.0,278,18,126,17,0,42,20,36,18,13,,0,32,2,1,1,int
1848,29122,vout_new_buffer,1,vout_new_buffer,picture_t vout_new_buffer (decoder_t*),input\decoder.c,"static picture_t *vout_new_buffer( decoder_t *p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    assert( p_owner->p_vout );

    return vout_GetPicture( p_owner->p_vout );
}",563.0,569.0,1.0,1.0,7.0,4,2,4,2,0,3,1,1,0,1,,0,2,2,1,1,picture_t
1849,29142,spu_new_buffer,1,spu_new_buffer,"subpicture_t spu_new_buffer (decoder_t*,subpicture_updater_t*)",input\decoder.c,"static subpicture_t *spu_new_buffer( decoder_t *p_dec,
                                     const subpicture_updater_t *p_updater )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    vout_thread_t *p_vout = NULL;
    subpicture_t *p_subpic;
    int i_attempts = 30;

    while( i_attempts-- )
    {
        if( p_owner->error )
            break;

        p_vout = input_resource_HoldVout( p_owner->p_resource );
        if( p_vout )
            break;

        msleep( DECODER_SPU_VOUT_WAIT_DURATION );
    }

    if( !p_vout )
    {
        msg_Warn( p_dec, ""no vout found, dropping subpicture"" );
        return NULL;
    }

    if( p_owner->p_spu_vout != p_vout )
    {
        p_owner->i_spu_channel = vout_RegisterSubpictureChannel( p_vout );
        p_owner->i_spu_order = 0;
        p_owner->p_spu_vout = p_vout;
    }

    p_subpic = subpicture_New( p_updater );
    if( p_subpic )
    {
        p_subpic->i_channel = p_owner->i_spu_channel;
        p_subpic->i_order = p_owner->i_s...",571.0,615.0,1.0,16.0,45.0,29,8,32,9,0,13,9,9,2,5,,0,11,4,2,2,subpicture_t
1850,29254,DecoderGetInputAttachments,1,DecoderGetInputAttachments,"int DecoderGetInputAttachments (decoder_t*,input_attachment_t***,int*)",input\decoder.c,"static int DecoderGetInputAttachments( decoder_t *p_dec,
                                       input_attachment_t ***ppp_attachment,
                                       int *pi_attachment )
{
    input_thread_t *p_input = p_dec->p_owner->p_input;

    if( unlikely(p_input == NULL) )
        return VLC_ENOOBJ;
    return input_Control( p_input, INPUT_GET_ATTACHMENTS,
                          ppp_attachment, pi_attachment );
}",617.0,627.0,1.0,1.0,11.0,4,3,9,7,0,1,2,2,0,1,,0,0,6,3,3,int
1851,29283,DecoderGetDisplayDate,1,DecoderGetDisplayDate,"mtime_t DecoderGetDisplayDate (decoder_t*,mtime_t)",input\decoder.c,"static mtime_t DecoderGetDisplayDate( decoder_t *p_dec, mtime_t i_ts )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    vlc_mutex_lock( &p_owner->lock );
    if( p_owner->b_waiting || p_owner->paused )
        i_ts = VLC_TS_INVALID;
    vlc_mutex_unlock( &p_owner->lock );

    if( !p_owner->p_clock || i_ts <= VLC_TS_INVALID )
        return i_ts;

    if( input_clock_ConvertTS( VLC_OBJECT(p_dec), p_owner->p_clock, NULL, &i_ts, NULL, INT64_MAX ) ) {
        msg_Err(p_dec, ""Could not get display date for timestamp %""PRId64"""", i_ts);
        return VLC_TS_INVALID;
    }

    return i_ts;
}",629.0,647.0,1.0,1.0,19.0,16,6,20,6,0,9,4,4,5,3,,0,7,4,2,2,mtime_t
1852,29347,DecoderGetDisplayRate,1,DecoderGetDisplayRate,int DecoderGetDisplayRate (decoder_t*),input\decoder.c,"static int DecoderGetDisplayRate( decoder_t *p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    if( !p_owner->p_clock )
        return INPUT_RATE_DEFAULT;
    return input_clock_GetRate( p_owner->p_clock );
}",649.0,656.0,1.0,1.0,8.0,5,3,5,3,0,3,2,2,1,1,,0,2,2,1,1,int
1853,29371,decoder_NewAudioBuffer,1,decoder_NewAudioBuffer,"block_t decoder_NewAudioBuffer (decoder_t*,int)",input\decoder.c,"block_t *decoder_NewAudioBuffer( decoder_t *dec, int samples )
{
    assert( dec->fmt_out.audio.i_frame_length > 0
         && dec->fmt_out.audio.i_bytes_per_frame  > 0 );

    size_t length = samples * dec->fmt_out.audio.i_bytes_per_frame
                            / dec->fmt_out.audio.i_frame_length;
    block_t *block = block_Alloc( length );
    if( likely(block != NULL) )
    {
        block->i_nb_samples = samples;
        block->i_pts = block->i_length = 0;
    }
    return block;
}",661.0,675.0,1.0,1.0,15.0,26,8,15,5,0,1,2,2,0,1,,0,1,4,2,2,block_t
1854,29444,decoder_NewSubpicture,1,decoder_NewSubpicture,"subpicture_t decoder_NewSubpicture (decoder_t*,subpicture_updater_t*)",input\decoder.c,"subpicture_t *decoder_NewSubpicture( decoder_t *p_decoder,
                                     const subpicture_updater_t *p_dyn )
{
    subpicture_t *p_subpicture = p_decoder->pf_spu_buffer_new( p_decoder, p_dyn );
    if( !p_subpicture )
        msg_Warn( p_decoder, ""can't get output subpicture"" );
    return p_subpicture;
}",677.0,684.0,1.0,1.0,8.0,3,3,7,3,0,0,2,2,0,0,,0,0,4,2,2,subpicture_t
1855,29468,RequestReload,1,RequestReload,void RequestReload (decoder_t*),input\decoder.c,"static void RequestReload( decoder_t * p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    /* Don't override reload if it's RELOAD_DECODER_AOUT */
    int expected = RELOAD_NO_REQUEST;
    atomic_compare_exchange_strong( &p_owner->reload, &expected, RELOAD_DECODER );
}",686.0,692.0,1.0,1.0,7.0,6,3,7,5,2,1,1,1,0,0,,0,1,2,1,1,void
1856,29491,decoder_GetInputAttachments,1,decoder_GetInputAttachments,"int decoder_GetInputAttachments (decoder_t*,input_attachment_t***,int*)",input\decoder.c,"int decoder_GetInputAttachments( decoder_t *p_dec,
                                 input_attachment_t ***ppp_attachment,
                                 int *pi_attachment )
{
    if( !p_dec->pf_get_attachments )
        return VLC_EGENERIC;

    return p_dec->pf_get_attachments( p_dec, ppp_attachment, pi_attachment );
}",696.0,704.0,1.0,1.0,9.0,3,2,6,4,0,0,2,2,0,0,,0,0,6,3,3,int
1857,29514,decoder_GetDisplayDate,1,decoder_GetDisplayDate,"mtime_t decoder_GetDisplayDate (decoder_t*,mtime_t)",input\decoder.c,"mtime_t decoder_GetDisplayDate( decoder_t *p_dec, mtime_t i_ts )
{
    if( !p_dec->pf_get_display_date )
        return VLC_TS_INVALID;

    return p_dec->pf_get_display_date( p_dec, i_ts );
}",707.0,713.0,1.0,1.0,7.0,3,2,5,3,0,0,2,2,0,0,,0,0,4,2,2,mtime_t
1858,29535,decoder_GetDisplayRate,1,decoder_GetDisplayRate,int decoder_GetDisplayRate (decoder_t*),input\decoder.c,"int decoder_GetDisplayRate( decoder_t *p_dec )
{
    if( !p_dec->pf_get_display_rate )
        return INPUT_RATE_DEFAULT;

    return p_dec->pf_get_display_rate( p_dec );
}",716.0,722.0,1.0,1.0,7.0,3,2,4,2,0,0,2,2,0,0,,0,0,2,1,1,int
1859,29554,decoder_AbortPictures,1,decoder_AbortPictures,"void decoder_AbortPictures (decoder_t*,bool)",input\decoder.c,"void decoder_AbortPictures( decoder_t *p_dec, bool b_abort )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    vlc_mutex_lock( &p_owner->lock );
    if( p_owner->p_vout != NULL )
        vout_Cancel( p_owner->p_vout, b_abort );
    vlc_mutex_unlock( &p_owner->lock );
}",724.0,732.0,1.0,1.0,9.0,9,4,8,4,0,7,2,2,1,3,,0,4,4,2,2,void
1860,29588,DecoderWaitUnblock,1,DecoderWaitUnblock,void DecoderWaitUnblock (decoder_t*),input\decoder.c,"static void DecoderWaitUnblock( decoder_t *p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    vlc_assert_locked( &p_owner->lock );

    for( ;; )
    {
        if( !p_owner->b_waiting || !p_owner->b_has_data )
            break;
        vlc_cond_wait( &p_owner->wait_request, &p_owner->lock );
    }
}",734.0,746.0,1.0,1.0,13.0,13,5,7,2,3,6,4,4,2,1,,0,5,2,1,1,void
1861,29628,DecoderTimedWait,1,DecoderTimedWait,"int DecoderTimedWait (decoder_t*,mtime_t)",input\decoder.c,"static int DecoderTimedWait( decoder_t *p_dec, mtime_t deadline )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    if (deadline - mdate() <= 0)
        return VLC_SUCCESS;

    vlc_fifo_Lock( p_owner->p_fifo );
    while( !p_owner->flushing
        && vlc_fifo_TimedWaitCond( p_owner->p_fifo, &p_owner->wait_timed,
                                   deadline ) == 0 );
    int ret = p_owner->flushing ? VLC_EGENERIC : VLC_SUCCESS;
    vlc_fifo_Unlock( p_owner->p_fifo );
    return ret;
}",750.0,764.0,1.0,1.0,15.0,16,9,15,6,2,10,3,3,5,4,,0,8,4,2,2,int
1862,29685,DecoderUpdatePreroll,1,DecoderUpdatePreroll,"void DecoderUpdatePreroll (int64_t*,block_t*)",input\decoder.c,"static inline void DecoderUpdatePreroll( int64_t *pi_preroll, const block_t *p )
{
    if( p->i_flags & BLOCK_FLAG_PREROLL )
        *pi_preroll = INT64_MAX;
    /* Check if we can use the packet for end of preroll */
    else if( (p->i_flags & BLOCK_FLAG_DISCONTINUITY) &&
             (p->i_buffer == 0 || (p->i_flags & BLOCK_FLAG_CORRUPTED)) )
        *pi_preroll = INT64_MAX;
    else if( p->i_dts > VLC_TS_INVALID )
        *pi_preroll = __MIN( *pi_preroll, p->i_dts );
    else if( p->i_pts > VLC_TS_INVALID )
        *pi_preroll = __MIN( *pi_preroll, p->i_pts );
}",766.0,778.0,1.0,1.0,13.0,4,4,4,4,0,0,2,2,0,0,,0,0,4,2,2,void
1863,29763,DecoderFixTs,1,DecoderFixTs,"void DecoderFixTs (decoder_t*,mtime_t*,mtime_t*,mtime_t*,int*,mtime_t)",input\decoder.c,"static void DecoderFixTs( decoder_t *p_dec, mtime_t *pi_ts0, mtime_t *pi_ts1,
                          mtime_t *pi_duration, int *pi_rate, mtime_t i_ts_bound )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    input_clock_t   *p_clock = p_owner->p_clock;

    vlc_assert_locked( &p_owner->lock );

    const mtime_t i_es_delay = p_owner->i_ts_delay;

    if( !p_clock )
        return;

    const bool b_ephemere = pi_ts1 && *pi_ts0 == *pi_ts1;
    int i_rate;

    if( *pi_ts0 > VLC_TS_INVALID )
    {
        *pi_ts0 += i_es_delay;
        if( pi_ts1 && *pi_ts1 > VLC_TS_INVALID )
            *pi_ts1 += i_es_delay;
        if( i_ts_bound != INT64_MAX )
            i_ts_bound += i_es_delay;
        if( input_clock_ConvertTS( VLC_OBJECT(p_dec), p_clock, &i_rate, pi_ts0, pi_ts1, i_ts_bound ) ) {
            const char *psz_name = module_get_name( p_dec->p_module, false );
            if( pi_ts1 != NULL )
                msg_Err(p_dec, ""Could not convert timestamps %""PRId64
         ...",780.0,828.0,1.0,1.0,49.0,47,14,50,16,3,5,9,12,1,2,,0,5,12,6,6,void
1864,29912,DecoderPlayCc,1,DecoderPlayCc,"void DecoderPlayCc (decoder_t*,block_t*,decoder_cc_desc_t*)",input\decoder.c,"static void DecoderPlayCc( decoder_t *p_dec, block_t *p_cc,
                           const decoder_cc_desc_t *p_desc )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    vlc_mutex_lock( &p_owner->lock );

    p_owner->cc.desc = *p_desc;

    /* Fanout data to all decoders. We do not know if es_out
       selected 608 or 708. */
    uint64_t i_bitmap = p_owner->cc.desc.i_608_channels |
                        p_owner->cc.desc.i_708_channels;

    for( int i=0; i_bitmap > 0; i_bitmap >>= 1, i++ )
    {
        decoder_t *p_ccdec = p_owner->cc.pp_decoder[i];
        if( !p_ccdec )
            continue;

        if( i_bitmap > 1 )
        {
            block_FifoPut( p_ccdec->p_owner->p_fifo, block_Duplicate(p_cc) );
        }
        else
        {
            block_FifoPut( p_ccdec->p_owner->p_fifo, p_cc );
            p_cc = NULL; /* was last dec */
        }
    }

    vlc_mutex_unlock( &p_owner->lock );

    if( p_cc ) /* can have bitmap set but no created decs */
        ...",927.0,962.0,1.0,1.0,36.0,28,9,20,7,2,5,6,7,0,3,,0,2,6,3,3,void
1865,30022,PacketizerGetCc,1,PacketizerGetCc,"void PacketizerGetCc (decoder_t*,decoder_t*)",input\decoder.c,"static void PacketizerGetCc( decoder_t *p_dec, decoder_t *p_dec_cc )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    block_t *p_cc;
    decoder_cc_desc_t desc;

    /* Do not try retreiving CC if not wanted (sout) or cannot be retreived */
    if( !p_owner->cc.b_supported )
        return;

    assert( p_dec_cc->pf_get_cc != NULL );

    p_cc = p_dec_cc->pf_get_cc( p_dec_cc, &desc );
    if( !p_cc )
        return;
    DecoderPlayCc( p_dec, p_cc, &desc );
}",964.0,980.0,1.0,1.0,17.0,12,6,13,6,0,1,3,3,0,1,,0,0,4,2,2,void
1866,30070,DecoderQueueCc,1,DecoderQueueCc,"int DecoderQueueCc (decoder_t*,block_t*,decoder_cc_desc_t*)",input\decoder.c,"static int DecoderQueueCc( decoder_t *p_videodec, block_t *p_cc,
                           const decoder_cc_desc_t *p_desc )
{
    decoder_owner_sys_t *p_owner = p_videodec->p_owner;

    if( unlikely( p_cc != NULL ) )
    {
        if( p_owner->cc.b_supported &&
           ( !p_owner->p_packetizer || !p_owner->p_packetizer->pf_get_cc ) )
            DecoderPlayCc( p_videodec, p_cc, p_desc );
        else
            block_Release( p_cc );
    }
    return 0;
}",982.0,996.0,1.0,1.0,15.0,12,7,10,5,0,3,3,4,2,1,,0,2,6,3,3,int
1867,30118,DecoderPlayVideo,1,DecoderPlayVideo,"int DecoderPlayVideo (decoder_t*,picture_t*,unsigned*)",input\decoder.c,"static int DecoderPlayVideo( decoder_t *p_dec, picture_t *p_picture,
                             unsigned *restrict pi_lost_sum )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    vout_thread_t  *p_vout = p_owner->p_vout;
    bool prerolled;

    vlc_mutex_lock( &p_owner->lock );
    if( p_owner->i_preroll_end > p_picture->date )
    {
        vlc_mutex_unlock( &p_owner->lock );
        picture_Release( p_picture );
        return -1;
    }

    prerolled = p_owner->i_preroll_end > INT64_MIN;
    p_owner->i_preroll_end = INT64_MIN;
    vlc_mutex_unlock( &p_owner->lock );

    if( unlikely(prerolled) )
    {
        msg_Dbg( p_dec, ""end of video preroll"" );

        if( p_vout )
            vout_Flush( p_vout, VLC_TS_INVALID+1 );
    }

    if( p_picture->date <= VLC_TS_INVALID )
    {
        msg_Warn( p_dec, ""non-dated video buffer received"" );
        goto discard;
    }

    /* */
    vlc_mutex_lock( &p_owner->lock );

    if( p_owner->b_waiting && !p_owner->b_first )
   ...",998.0,1094.0,1.0,27.0,97.0,73,16,73,16,1,40,13,13,7,15,,0,25,6,3,3,int
1868,30386,DecoderUpdateStatVideo,1,DecoderUpdateStatVideo,"void DecoderUpdateStatVideo (decoder_owner_sys_t*,unsigned,unsigned)",input\decoder.c,"static void DecoderUpdateStatVideo( decoder_owner_sys_t *p_owner,
                                    unsigned decoded, unsigned lost )
{
    input_thread_t *p_input = p_owner->p_input;
    unsigned displayed = 0;

    /* Update ugly stat */
    if( p_input == NULL )
        return;

    if( p_owner->p_vout != NULL )
    {
        unsigned vout_lost = 0;

        vout_GetResetStatistic( p_owner->p_vout, &displayed, &vout_lost );
        lost += vout_lost;
    }

    vlc_mutex_lock( &input_priv(p_input)->counters.counters_lock );
    stats_Update( input_priv(p_input)->counters.p_decoded_video, decoded, NULL );
    stats_Update( input_priv(p_input)->counters.p_lost_pictures, lost , NULL);
    stats_Update( input_priv(p_input)->counters.p_displayed_pictures, displayed, NULL);
    vlc_mutex_unlock( &input_priv(p_input)->counters.counters_lock );
}",1096.0,1119.0,1.0,1.0,24.0,23,7,24,7,0,14,3,3,1,11,,0,8,6,3,3,void
1869,30474,DecoderQueueVideo,1,DecoderQueueVideo,"int DecoderQueueVideo (decoder_t*,picture_t*)",input\decoder.c,"static int DecoderQueueVideo( decoder_t *p_dec, picture_t *p_pic )
{
    assert( p_pic );
    unsigned i_lost = 0;
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    int ret = DecoderPlayVideo( p_dec, p_pic, &i_lost );

    p_owner->pf_update_stat( p_owner, 1, i_lost );
    return ret;
}",1121.0,1131.0,1.0,1.0,11.0,6,3,12,5,0,1,1,1,0,1,,0,1,4,2,2,int
1870,30509,DecoderPlayAudio,1,DecoderPlayAudio,"int DecoderPlayAudio (decoder_t*,block_t*,unsigned*)",input\decoder.c,"static int DecoderPlayAudio( decoder_t *p_dec, block_t *p_audio,
                             unsigned *restrict pi_lost_sum )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    bool prerolled;

    assert( p_audio != NULL );

    vlc_mutex_lock( &p_owner->lock );
    if( p_owner->i_preroll_end > p_audio->i_pts )
    {
        vlc_mutex_unlock( &p_owner->lock );
        block_Release( p_audio );
        return -1;
    }

    prerolled = p_owner->i_preroll_end > INT64_MIN;
    p_owner->i_preroll_end = INT64_MIN;
    vlc_mutex_unlock( &p_owner->lock );

    if( unlikely(prerolled) )
    {
        msg_Dbg( p_dec, ""end of audio preroll"" );

        if( p_owner->p_aout )
            aout_DecFlush( p_owner->p_aout, false );
    }

    /* */
    if( p_audio->i_pts <= VLC_TS_INVALID ) // FIXME --VLC_TS_INVALID verify audio_output/*
    {
        msg_Warn( p_dec, ""non-dated audio buffer received"" );
        *pi_lost_sum += 1;
        block_Release( p_audio );
        return 0;
    }

 ...",1133.0,1214.0,1.0,37.0,82.0,57,16,59,16,1,26,8,10,4,12,,0,16,6,3,3,int
1871,30734,DecoderUpdateStatAudio,1,DecoderUpdateStatAudio,"void DecoderUpdateStatAudio (decoder_owner_sys_t*,unsigned,unsigned)",input\decoder.c,"static void DecoderUpdateStatAudio( decoder_owner_sys_t *p_owner,
                                    unsigned decoded, unsigned lost )
{
    input_thread_t *p_input = p_owner->p_input;
    unsigned played = 0;

    /* Update ugly stat */
    if( p_input == NULL )
        return;

    if( p_owner->p_aout != NULL )
    {
        unsigned aout_lost;

        aout_DecGetResetStats( p_owner->p_aout, &aout_lost, &played );
        lost += aout_lost;
    }

    vlc_mutex_lock( &input_priv(p_input)->counters.counters_lock);
    stats_Update( input_priv(p_input)->counters.p_lost_abuffers, lost, NULL );
    stats_Update( input_priv(p_input)->counters.p_played_abuffers, played, NULL );
    stats_Update( input_priv(p_input)->counters.p_decoded_audio, decoded, NULL );
    vlc_mutex_unlock( &input_priv(p_input)->counters.counters_lock);
}",1216.0,1239.0,1.0,1.0,24.0,22,7,23,7,0,14,3,3,1,11,,0,8,6,3,3,void
1872,30819,DecoderQueueAudio,1,DecoderQueueAudio,"int DecoderQueueAudio (decoder_t*,block_t*)",input\decoder.c,"static int DecoderQueueAudio( decoder_t *p_dec, block_t *p_aout_buf )
{
    unsigned lost = 0;
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    int ret = DecoderPlayAudio( p_dec, p_aout_buf, &lost );

    p_owner->pf_update_stat( p_owner, 1, lost );

    return ret;
}",1241.0,1251.0,1.0,1.0,11.0,6,3,11,5,0,1,1,1,0,1,,0,1,4,2,2,int
1873,30852,DecoderPlaySpu,1,DecoderPlaySpu,"void DecoderPlaySpu (decoder_t*,subpicture_t*)",input\decoder.c,"static void DecoderPlaySpu( decoder_t *p_dec, subpicture_t *p_subpic )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    vout_thread_t *p_vout = p_owner->p_spu_vout;

    /* */
    if( p_subpic->i_start <= VLC_TS_INVALID )
    {
        msg_Warn( p_dec, ""non-dated spu buffer received"" );
        subpicture_Delete( p_subpic );
        return;
    }

    /* */
    vlc_mutex_lock( &p_owner->lock );

    if( p_owner->b_waiting )
    {
        p_owner->b_has_data = true;
        vlc_cond_signal( &p_owner->wait_acknowledge );
    }

    DecoderWaitUnblock( p_dec );
    DecoderFixTs( p_dec, &p_subpic->i_start, &p_subpic->i_stop, NULL,
                  NULL, INT64_MAX );
    vlc_mutex_unlock( &p_owner->lock );

    if( p_subpic->i_start <= VLC_TS_INVALID
     || DecoderTimedWait( p_dec, p_subpic->i_start - SPU_MAX_PREPARE_TIME ) )
    {
        subpicture_Delete( p_subpic );
        return;
    }

    vout_PutSubpicture( p_vout, p_subpic );
}",1253.0,1288.0,1.0,1.0,36.0,24,6,29,9,0,15,4,4,2,9,,0,7,4,2,2,void
1874,30944,DecoderUpdateStatSpu,1,DecoderUpdateStatSpu,"void DecoderUpdateStatSpu (decoder_owner_sys_t*,unsigned,unsigned)",input\decoder.c,"static void DecoderUpdateStatSpu( decoder_owner_sys_t *p_owner,
                                  unsigned decoded, unsigned lost )
{
    (void) p_owner; (void) decoded; (void) lost;
}",1290.0,1294.0,1.0,1.0,5.0,3,1,3,3,0,0,1,1,0,0,,0,0,6,3,3,void
1875,30960,DecoderQueueSpu,1,DecoderQueueSpu,"int DecoderQueueSpu (decoder_t*,subpicture_t*)",input\decoder.c,"static int DecoderQueueSpu( decoder_t *p_dec, subpicture_t *p_spu )
{
    assert( p_spu );
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    input_thread_t *p_input = p_owner->p_input;

    if( p_input != NULL )
    {
        vlc_mutex_lock( &input_priv(p_input)->counters.counters_lock );
        stats_Update( input_priv(p_input)->counters.p_decoded_sub, 1, NULL );
        vlc_mutex_unlock( &input_priv(p_input)->counters.counters_lock );
    }

    int i_ret = -1;
    vout_thread_t *p_vout = input_resource_HoldVout( p_owner->p_resource );
    if( p_vout && p_owner->p_spu_vout == p_vout )
    {
        /* Preroll does not work very well with subtitle */
        vlc_mutex_lock( &p_owner->lock );
        if( p_spu->i_start > VLC_TS_INVALID &&
            p_spu->i_start < p_owner->i_preroll_end &&
            ( p_spu->i_stop <= VLC_TS_INVALID || p_spu->i_stop < p_owner->i_preroll_end ) )
        {
            vlc_mutex_unlock( &p_owner->lock );
            subpicture_Delete( p_spu ...",1296.0,1336.0,1.0,1.0,41.0,37,12,31,8,0,18,5,6,3,11,,0,11,4,2,2,int
1876,31096,DecoderProcess,1,DecoderProcess,"void DecoderProcess (decoder_t*,block_t*)",input\decoder.c,"static void DecoderProcess( decoder_t *p_dec, block_t *p_block )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    if( p_owner->error )
        goto error;

    /* Here, the atomic doesn't prevent to miss a reload request.
     * DecoderProcess() can still be called after the decoder module or the
     * audio output requested a reload. This will only result in a drop of an
     * input block or an output buffer. */
    enum reload reload;
    if( ( reload = atomic_exchange( &p_owner->reload, RELOAD_NO_REQUEST ) ) )
    {
        msg_Warn( p_dec, ""Reloading the decoder module%s"",
                  reload == RELOAD_DECODER_AOUT ? "" and the audio output"" : """" );

        if( ReloadDecoder( p_dec, false, &p_dec->fmt_in, reload ) != VLC_SUCCESS )
            goto error;
    }

    bool packetize = p_owner->p_packetizer != NULL;
    if( p_block )
    {
        if( p_block->i_buffer <= 0 )
            goto error;

        vlc_mutex_lock( &p_owner->lock );
        DecoderUpdatePrer...",1375.0,1472.0,1.0,41.0,98.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,void
1877,31102,DecoderDecode,1,DecoderDecode,"void DecoderDecode (decoder_t*,block_t*)",input\decoder.c,"static void DecoderDecode( decoder_t *p_dec, block_t *p_block )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    int ret = p_dec->pf_decode( p_dec, p_block );
    switch( ret )
    {
        case VLCDEC_SUCCESS:
            p_owner->pf_update_stat( p_owner, 1, 0 );
            break;
        case VLCDEC_ECRITICAL:
            p_owner->error = true;
            break;
        case VLCDEC_RELOAD:
            RequestReload( p_dec );
            if( unlikely( p_block == NULL ) )
                break;
            if( !( p_block->i_flags & BLOCK_FLAG_CORE_PRIVATE_RELOADED ) )
            {
                p_block->i_flags |= BLOCK_FLAG_CORE_PRIVATE_RELOADED;
                DecoderProcess( p_dec, p_block );
            }
            else /* We prefer loosing this block than an infinite recursion */
                block_Release( p_block );
            break;
        default:
            vlc_assert_unreachable();
    }
}",1339.0,1367.0,1.0,38.0,29.0,14,6,23,10,0,3,8,6,0,2,,0,1,4,2,2,void
1878,31403,DecoderProcessFlush,1,DecoderProcessFlush,void DecoderProcessFlush (decoder_t*),input\decoder.c,"static void DecoderProcessFlush( decoder_t *p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    decoder_t *p_packetizer = p_owner->p_packetizer;

    if( p_owner->error )
        return;

    if( p_packetizer != NULL && p_packetizer->pf_flush != NULL )
        p_packetizer->pf_flush( p_packetizer );

    if ( p_dec->pf_flush != NULL )
        p_dec->pf_flush( p_dec );

    /* flush CC sub decoders */
    if( p_owner->cc.b_supported )
    {
        for( int i=0; i<MAX_CC_DECODERS; i++ )
        {
            decoder_t *p_subdec = p_owner->cc.pp_decoder[i];
            if( p_subdec && p_subdec->pf_flush )
                p_subdec->pf_flush( p_subdec );
        }
    }

#ifdef ENABLE_SOUT
    if ( p_owner->p_sout_input != NULL )
    {
        sout_InputFlush( p_owner->p_sout_input );
    }
#endif
    if( p_dec->fmt_out.i_cat == AUDIO_ES )
    {
        if( p_owner->p_aout )
            aout_DecFlush( p_owner->p_aout, false );
    }
    else if( p_dec->fmt_out.i_cat == VIDE...",1474.0,1532.0,1.0,24.0,59.0,35,9,34,9,1,10,9,13,2,3,,0,7,2,1,1,void
1879,31596,DecoderThread,1,DecoderThread,void* DecoderThread (void*),input\decoder.c,"static void *DecoderThread( void *p_data )
{
    decoder_t *p_dec = (decoder_t *)p_data;
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    bool paused = false;

    /* The decoder's main loop */
    vlc_fifo_Lock( p_owner->p_fifo );
    vlc_fifo_CleanupPush( p_owner->p_fifo );

    for( ;; )
    {
        if( p_owner->flushing )
        {   /* Flush before/regardless of pause. We do not want to resume just
             * for the sake of flushing (glitches could otherwise happen). */
            int canc = vlc_savecancel();

            vlc_fifo_Unlock( p_owner->p_fifo );

            /* Flush the decoder (and the output) */
            DecoderProcessFlush( p_dec );

            vlc_fifo_Lock( p_owner->p_fifo );
            vlc_restorecancel( canc );

            /* Reset flushing after DecoderProcess in case input_DecoderFlush
             * is called again. This will avoid a second useless flush (but
             * harmless). */
            p_owner->flushing = false;

        ...",1539.0,1645.0,1.0,1.0,107.0,74,9,80,10,0,66,16,26,9,28,,0,42,2,1,1,void*
1880,31867,CreateDecoder,1,CreateDecoder,"decoder_t CreateDecoder (vlc_object_t*,input_thread_t*,es_format_t*,input_resource_t*,sout_instance_t*)",misc\image.c,"static decoder_t *CreateDecoder( vlc_object_t *p_this, const video_format_t *fmt )
{
    decoder_t *p_dec;

    p_dec = vlc_custom_create( p_this, sizeof( *p_dec ), ""image decoder"" );
    if( p_dec == NULL )
        return NULL;

    p_dec->p_module = NULL;
    es_format_InitFromVideo( &p_dec->fmt_in, fmt );
    es_format_Init( &p_dec->fmt_out, VIDEO_ES, 0 );
    p_dec->b_frame_drop_allowed = false;

    p_dec->pf_vout_format_update = video_update_format;
    p_dec->pf_vout_buffer_new = video_new_buffer;

    /* Find a suitable decoder module */
    p_dec->p_module = module_need( p_dec, ""video decoder"", ""$codec"", false );
    if( !p_dec->p_module )
    {
        msg_Err( p_dec, ""no suitable decoder module for fourcc `%4.4s'. ""
                 ""VLC probably does not support this image format."",
                 (char*)&p_dec->fmt_in.i_codec );

        DeleteDecoder( p_dec );
        return NULL;
    }

    return p_dec;
}",671.0,700.0,1.0,1.0,30.0,183,12,148,21,1,55,17,22,5,15,,0,45,4,2,2,decoder_t
1881,32427,DeleteDecoder,1,DeleteDecoder,void DeleteDecoder (decoder_t*),misc\image.c,"static void DeleteDecoder( decoder_t * p_dec )
{
    if( p_dec->p_module ) module_unneed( p_dec, p_dec->p_module );

    es_format_Clean( &p_dec->fmt_in );
    es_format_Clean( &p_dec->fmt_out );

    if( p_dec->p_description )
        vlc_meta_Delete( p_dec->p_description );

    vlc_object_release( p_dec );
    p_dec = NULL;
}",702.0,714.0,1.0,1.0,13.0,48,7,50,8,4,50,10,15,7,22,,0,29,2,1,1,void
1882,32611,DecoderUnsupportedCodec,1,DecoderUnsupportedCodec,"void DecoderUnsupportedCodec (decoder_t*,es_format_t*,bool)",input\decoder.c,"static void DecoderUnsupportedCodec( decoder_t *p_dec, const es_format_t *fmt, bool b_decoding )
{
    if (fmt->i_codec != VLC_CODEC_UNKNOWN && fmt->i_codec) {
        const char *desc = vlc_fourcc_GetDescription(fmt->i_cat, fmt->i_codec);
        if (!desc || !*desc)
            desc = N_(""No description for this codec"");
        msg_Err( p_dec, ""Codec `%4.4s' (%s) is not supported."", (char*)&fmt->i_codec, desc );
        vlc_dialog_display_error( p_dec, _(""Codec not supported""),
            _(""VLC could not decode the format \""%4.4s\"" (%s)""),
            (char*)&fmt->i_codec, desc );
    } else if( b_decoding ){
        msg_Err( p_dec, ""could not identify codec"" );
        vlc_dialog_display_error( p_dec, _(""Unidentified codec""),
            _(""VLC could not identify the audio or video codec"" ) );
    }
}",1888.0,1903.0,1.0,1.0,16.0,18,9,15,4,1,2,3,4,0,2,,0,1,6,3,3,void
1883,32688,decoder_New,1,decoder_New,"decoder_t decoder_New (vlc_object_t*,input_thread_t*,es_format_t*,input_clock_t*,input_resource_t*,sout_instance_t*)",input\decoder.c,"static decoder_t *decoder_New( vlc_object_t *p_parent, input_thread_t *p_input,
                               const es_format_t *fmt, input_clock_t *p_clock,
                               input_resource_t *p_resource,
                               sout_instance_t *p_sout  )
{
    decoder_t *p_dec = NULL;
    const char *psz_type = p_sout ? N_(""packetizer"") : N_(""decoder"");
    int i_priority;

    /* Create the decoder configuration structure */
    p_dec = CreateDecoder( p_parent, p_input, fmt, p_resource, p_sout );
    if( p_dec == NULL )
    {
        msg_Err( p_parent, ""could not create %s"", psz_type );
        vlc_dialog_display_error( p_parent, _(""Streaming / Transcoding failed""),
            _(""VLC could not open the %s module.""), vlc_gettext( psz_type ) );
        return NULL;
    }

    if( !p_dec->p_module )
    {
        DecoderUnsupportedCodec( p_dec, fmt, !p_sout );

        DeleteDecoder( p_dec );
        return NULL;
    }

    p_dec->p_owner->p_clock = p_clock;
  ...",1906.0,1950.0,1.0,1.0,45.0,21,8,38,13,2,7,5,5,1,7,,0,3,12,6,6,decoder_t
1884,32807,input_DecoderNew,1,input_DecoderNew,"decoder_t input_DecoderNew (input_thread_t*,es_format_t*,input_clock_t*,sout_instance_t*)",input\decoder.c,"decoder_t *input_DecoderNew( input_thread_t *p_input,
                             es_format_t *fmt, input_clock_t *p_clock,
                             sout_instance_t *p_sout  )
{
    return decoder_New( VLC_OBJECT(p_input), p_input, fmt, p_clock,
                        input_priv(p_input)->p_resource, p_sout );
}",1960.0,1966.0,1.0,1.0,7.0,1,1,6,4,3,2,1,1,0,2,,0,1,8,4,4,decoder_t
1885,32827,input_DecoderCreate,1,input_DecoderCreate,"decoder_t input_DecoderCreate (vlc_object_t*,es_format_t*,input_resource_t*)",input\decoder.c,"decoder_t *input_DecoderCreate( vlc_object_t *p_parent, const es_format_t *fmt,
                                input_resource_t *p_resource )
{
    return decoder_New( p_parent, NULL, fmt, NULL, p_resource, NULL );
}",1971.0,1975.0,1.0,1.0,5.0,0,0,6,4,0,1,1,1,0,1,,0,0,6,3,3,decoder_t
1886,32842,input_DecoderDelete,1,input_DecoderDelete,void input_DecoderDelete (decoder_t*),input\decoder.c,"void input_DecoderDelete( decoder_t *p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    vlc_cancel( p_owner->thread );

    vlc_fifo_Lock( p_owner->p_fifo );
    /* Signal DecoderTimedWait */
    p_owner->flushing = true;
    vlc_cond_signal( &p_owner->wait_timed );
    vlc_fifo_Unlock( p_owner->p_fifo );

    /* Make sure we aren't waiting/decoding anymore */
    vlc_mutex_lock( &p_owner->lock );
    p_owner->b_waiting = false;
    vlc_cond_signal( &p_owner->wait_request );

    /* If the video output is paused or slow, or if the picture pool size was
     * under-estimated (e.g. greedy video filter, buggy decoder...), the
     * the picture pool may be empty, and the decoder thread or any decoder
     * module worker threads may be stuck waiting for free picture buffers.
     *
     * This unblocks the thread, allowing the decoder module to join all its
     * worker threads (if any) and the decoder thread to terminate. */
    if( p_owner->p_vout != NULL )
        v...",1985.0,2024.0,1.0,28.0,40.0,26,6,23,6,2,22,4,5,1,10,,0,12,2,1,1,void
1887,32941,input_DecoderDecode,1,input_DecoderDecode,"void input_DecoderDecode (decoder_t*,block_t*,bool)",input\decoder.c,"void input_DecoderDecode( decoder_t *p_dec, block_t *p_block, bool b_do_pace )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    vlc_fifo_Lock( p_owner->p_fifo );
    if( !b_do_pace )
    {
        /* FIXME: ideally we would check the time amount of data
         * in the FIFO instead of its size. */
        /* 400 MiB, i.e. ~ 50mb/s for 60s */
        if( vlc_fifo_GetBytes( p_owner->p_fifo ) > 400*1024*1024 )
        {
            msg_Warn( p_dec, ""decoder/packetizer fifo full (data not ""
                      ""consumed quickly enough), resetting fifo!"" );
            block_ChainRelease( vlc_fifo_DequeueAllUnlocked( p_owner->p_fifo ) );
            p_block->i_flags |= BLOCK_FLAG_DISCONTINUITY;
        }
    }
    else
    if( !p_owner->b_waiting )
    {   /* The FIFO is not consumed when waiting, so pacing would deadlock VLC.
         * Locking is not necessary as b_waiting is only read, not written by
         * the decoder thread. */
        while( vlc_fifo_GetCount( p_ow...",2033.0,2062.0,1.0,1.0,30.0,12,5,12,5,0,10,3,4,2,5,,0,6,6,3,3,void
1888,33019,input_DecoderIsEmpty,1,input_DecoderIsEmpty,bool input_DecoderIsEmpty (decoder_t*),input\decoder.c,"bool input_DecoderIsEmpty( decoder_t * p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    assert( !p_owner->b_waiting );

    vlc_fifo_Lock( p_owner->p_fifo );
    if( !vlc_fifo_IsEmpty( p_dec->p_owner->p_fifo ) || p_owner->b_draining )
    {
        vlc_fifo_Unlock( p_owner->p_fifo );
        return false;
    }
    vlc_fifo_Unlock( p_owner->p_fifo );

    bool b_empty;

    vlc_mutex_lock( &p_owner->lock );
#ifdef ENABLE_SOUT
    if( p_owner->p_sout_input != NULL )
        b_empty = sout_InputIsEmpty( p_owner->p_sout_input );
    else
#endif
    if( p_owner->fmt.i_cat == VIDEO_ES && p_owner->p_vout != NULL )
        b_empty = vout_IsEmpty( p_owner->p_vout );
    else if( p_owner->fmt.i_cat == AUDIO_ES )
        b_empty = !p_owner->b_draining || p_owner->drained;
    else
        b_empty = true; /* TODO subtitles support */
    vlc_mutex_unlock( &p_owner->lock );

    return b_empty;
}",2064.0,2095.0,1.0,1.0,32.0,24,9,18,6,2,16,3,3,3,6,,0,11,2,1,1,bool
1889,33122,input_DecoderDrain,1,input_DecoderDrain,void input_DecoderDrain (decoder_t*),input\decoder.c,"void input_DecoderDrain( decoder_t *p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    vlc_fifo_Lock( p_owner->p_fifo );
    p_owner->b_draining = true;
    vlc_fifo_Signal( p_owner->p_fifo );
    vlc_fifo_Unlock( p_owner->p_fifo );
}",2105.0,2113.0,1.0,1.0,9.0,7,2,7,3,1,7,1,1,0,3,,0,4,2,1,1,void
1890,33150,input_DecoderFlush,1,input_DecoderFlush,void input_DecoderFlush (decoder_t*),input\decoder.c,"void input_DecoderFlush( decoder_t *p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    vlc_fifo_Lock( p_owner->p_fifo );

    /* Empty the fifo */
    block_ChainRelease( vlc_fifo_DequeueAllUnlocked( p_owner->p_fifo ) );

    /* Don't need to wait for the DecoderThread to flush. Indeed, if called a
     * second time, this function will clear the FIFO again before anything was
     * dequeued by DecoderThread and there is no need to flush a second time in
     * a row. */
    p_owner->flushing = true;

    /* Flush video/spu decoder when paused: increment frames_countdown in order
     * to display one frame/subtitle */
    if( p_owner->paused
     && ( p_owner->fmt.i_cat == VIDEO_ES || p_owner->fmt.i_cat == SPU_ES )
     && p_owner->frames_countdown == 0 )
        p_owner->frames_countdown++;

    vlc_fifo_Signal( p_owner->p_fifo );
    vlc_cond_signal( &p_owner->wait_timed );

    vlc_fifo_Unlock( p_owner->p_fifo );
}",2119.0,2145.0,1.0,1.0,27.0,24,8,16,5,1,16,2,2,4,5,,0,11,2,1,1,void
1891,33219,input_DecoderGetCcDesc,1,input_DecoderGetCcDesc,"void input_DecoderGetCcDesc (decoder_t*,decoder_cc_desc_t*)",input\decoder.c,"void input_DecoderGetCcDesc( decoder_t *p_dec, decoder_cc_desc_t *p_desc )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    vlc_mutex_lock( &p_owner->lock );
    *p_desc = p_owner->cc.desc;
    vlc_mutex_unlock( &p_owner->lock );
}",2147.0,2154.0,1.0,1.0,8.0,10,5,6,3,0,4,1,1,0,2,,0,2,4,2,2,void
1892,33249,input_DecoderHasCCChanFlag,1,input_DecoderHasCCChanFlag,"bool input_DecoderHasCCChanFlag (decoder_t*,vlc_fourcc_t,int)",input\decoder.c,"static bool input_DecoderHasCCChanFlag( decoder_t *p_dec,
                                        vlc_fourcc_t codec, int i_channel )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    int i_max_channels;
    uint64_t i_bitmap;
    if( codec == VLC_CODEC_CEA608 )
    {
        i_max_channels = 4;
        i_bitmap = p_owner->cc.desc.i_608_channels;
    }
    else if( codec == VLC_CODEC_CEA708 )
    {
        i_max_channels = 64;
        i_bitmap = p_owner->cc.desc.i_708_channels;
    }
    else return false;

    return ( i_channel >= 0 && i_channel < i_max_channels &&
             ( i_bitmap & ((uint64_t)1 << i_channel) ) );
}",2156.0,2177.0,1.0,1.0,22.0,15,10,12,7,2,0,2,2,0,0,,0,0,6,3,3,bool
1893,33320,input_DecoderSetCcState,1,input_DecoderSetCcState,"int input_DecoderSetCcState (decoder_t*,vlc_fourcc_t,int,bool)",input\decoder.c,"int input_DecoderSetCcState( decoder_t *p_dec, vlc_fourcc_t codec,
                             int i_channel, bool b_decode )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    //msg_Warn( p_dec, ""input_DecoderSetCcState: %d @%x"", b_decode, i_channel );

    if( !input_DecoderHasCCChanFlag( p_dec, codec, i_channel ) )
        return VLC_EGENERIC;

    if( b_decode )
    {
        decoder_t *p_cc;
        es_format_t fmt;

        es_format_Init( &fmt, SPU_ES, codec );
        fmt.subs.cc.i_channel = i_channel;
        fmt.subs.cc.i_reorder_depth = p_owner->cc.desc.i_reorder_depth;
        p_cc = input_DecoderNew( p_owner->p_input, &fmt,
                              p_dec->p_owner->p_clock, p_owner->p_sout );
        if( !p_cc )
        {
            msg_Err( p_dec, ""could not create decoder"" );
            vlc_dialog_display_error( p_dec,
                _(""Streaming / Transcoding failed""), ""%s"",
                _(""VLC could not open the decoder module."") );
            ret...",2179.0,2232.0,1.0,1.0,54.0,34,6,31,10,0,11,4,5,1,6,,0,7,8,4,4,int
1894,33492,input_DecoderGetCcState,1,input_DecoderGetCcState,"int input_DecoderGetCcState (decoder_t*,vlc_fourcc_t,int,bool*)",input\decoder.c,"int input_DecoderGetCcState( decoder_t *p_dec, vlc_fourcc_t codec,
                             int i_channel, bool *pb_decode )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    if( !input_DecoderHasCCChanFlag( p_dec, codec, i_channel ) )
        return VLC_EGENERIC;

    vlc_mutex_lock( &p_owner->lock );
    *pb_decode = p_owner->cc.pp_decoder[i_channel] != NULL;
    vlc_mutex_unlock( &p_owner->lock );
    return VLC_SUCCESS;
}",2234.0,2246.0,1.0,1.0,13.0,13,8,13,8,0,5,2,2,1,3,,0,3,8,4,4,int
1895,33539,input_DecoderChangePause,1,input_DecoderChangePause,"void input_DecoderChangePause (decoder_t*,bool,mtime_t)",input\decoder.c,"void input_DecoderChangePause( decoder_t *p_dec, bool b_paused, mtime_t i_date )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    /* Normally, p_owner->b_paused != b_paused here. But if a track is added
     * while the input is paused (e.g. add sub file), then b_paused is
     * (incorrectly) false. FIXME: This is a bug in the decoder owner. */
    vlc_fifo_Lock( p_owner->p_fifo );
    p_owner->paused = b_paused;
    p_owner->pause_date = i_date;
    p_owner->frames_countdown = 0;
    vlc_fifo_Signal( p_owner->p_fifo );
    vlc_fifo_Unlock( p_owner->p_fifo );
}",2248.0,2261.0,1.0,1.0,14.0,11,2,10,4,0,9,1,1,0,3,,0,6,6,3,3,void
1896,33579,input_DecoderChangeDelay,1,input_DecoderChangeDelay,"void input_DecoderChangeDelay (decoder_t*,mtime_t)",input\decoder.c,"void input_DecoderChangeDelay( decoder_t *p_dec, mtime_t i_delay )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    vlc_mutex_lock( &p_owner->lock );
    p_owner->i_ts_delay = i_delay;
    vlc_mutex_unlock( &p_owner->lock );
}",2263.0,2270.0,1.0,1.0,8.0,8,3,6,3,0,5,1,1,0,2,,0,3,4,2,2,void
1897,33606,input_DecoderStartWait,1,input_DecoderStartWait,void input_DecoderStartWait (decoder_t*),input\decoder.c,"void input_DecoderStartWait( decoder_t *p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    assert( !p_owner->b_waiting );

    vlc_mutex_lock( &p_owner->lock );
    p_owner->b_first = true;
    p_owner->b_has_data = false;
    p_owner->b_waiting = true;
    vlc_cond_signal( &p_owner->wait_request );
    vlc_mutex_unlock( &p_owner->lock );
}",2272.0,2284.0,1.0,1.0,13.0,16,4,12,4,4,10,1,1,0,3,,0,7,2,1,1,void
1898,33652,input_DecoderStopWait,1,input_DecoderStopWait,void input_DecoderStopWait (decoder_t*),input\decoder.c,"void input_DecoderStopWait( decoder_t *p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    assert( p_owner->b_waiting );

    vlc_mutex_lock( &p_owner->lock );
    p_owner->b_waiting = false;
    vlc_cond_signal( &p_owner->wait_request );
    vlc_mutex_unlock( &p_owner->lock );
}",2286.0,2296.0,1.0,1.0,11.0,11,3,8,3,0,8,1,1,0,3,,0,5,2,1,1,void
1899,33687,input_DecoderWait,1,input_DecoderWait,void input_DecoderWait (decoder_t*),input\decoder.c,"void input_DecoderWait( decoder_t *p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    assert( p_owner->b_waiting );

    vlc_mutex_lock( &p_owner->lock );
    while( !p_owner->b_has_data )
    {
        /* Don't need to lock p_owner->paused since it's only modified by the
         * owner */
        if( p_owner->paused )
            break;
        vlc_fifo_Lock( p_owner->p_fifo );
        if( p_owner->b_idle && vlc_fifo_IsEmpty( p_owner->p_fifo ) )
        {
            msg_Err( p_dec, ""buffer deadlock prevented"" );
            vlc_fifo_Unlock( p_owner->p_fifo );
            break;
        }
        vlc_fifo_Unlock( p_owner->p_fifo );
        vlc_cond_wait( &p_owner->wait_acknowledge, &p_owner->lock );
    }
    vlc_mutex_unlock( &p_owner->lock );
}",2298.0,2322.0,1.0,1.0,25.0,20,5,15,2,0,18,6,6,4,6,,0,12,2,1,1,void
1900,33759,input_DecoderFrameNext,1,input_DecoderFrameNext,"void input_DecoderFrameNext (decoder_t*,mtime_t*)",input\decoder.c,"void input_DecoderFrameNext( decoder_t *p_dec, mtime_t *pi_duration )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    assert( p_owner->paused );
    *pi_duration = 0;

    vlc_fifo_Lock( p_owner->p_fifo );
    p_owner->frames_countdown++;
    vlc_fifo_Signal( p_owner->p_fifo );
    vlc_fifo_Unlock( p_owner->p_fifo );

    vlc_mutex_lock( &p_owner->lock );
    if( p_owner->fmt.i_cat == VIDEO_ES )
    {
        if( p_owner->p_vout )
            vout_NextPicture( p_owner->p_vout, pi_duration );
    }
    vlc_mutex_unlock( &p_owner->lock );
}",2324.0,2343.0,1.0,1.0,20.0,19,7,15,4,1,16,3,4,2,6,,0,10,4,2,2,void
1901,33824,input_DecoderHasFormatChanged,1,input_DecoderHasFormatChanged,"bool input_DecoderHasFormatChanged (decoder_t*,es_format_t*,vlc_meta_t**)",input\decoder.c,"bool input_DecoderHasFormatChanged( decoder_t *p_dec, es_format_t *p_fmt, vlc_meta_t **pp_meta )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    bool b_changed;

    vlc_mutex_lock( &p_owner->lock );
    b_changed = p_owner->b_fmt_description;
    if( b_changed )
    {
        if( p_fmt != NULL )
            es_format_Copy( p_fmt, &p_owner->fmt );

        if( pp_meta )
        {
            *pp_meta = NULL;
            if( p_owner->p_description )
            {
                *pp_meta = vlc_meta_New();
                if( *pp_meta )
                    vlc_meta_Merge( *pp_meta, p_owner->p_description );
            }
        }
        p_owner->b_fmt_description = false;
    }
    vlc_mutex_unlock( &p_owner->lock );
    return b_changed;
}",2345.0,2371.0,1.0,1.0,27.0,21,5,22,7,0,12,6,13,1,5,,0,8,6,3,3,bool
1902,33900,input_DecoderGetFifoSize,1,input_DecoderGetFifoSize,size_t input_DecoderGetFifoSize (decoder_t*),input\decoder.c,"size_t input_DecoderGetFifoSize( decoder_t *p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    return block_FifoSize( p_owner->p_fifo );
}",2373.0,2378.0,1.0,1.0,6.0,3,2,3,2,2,2,1,1,0,1,,0,1,2,1,1,size_t
1903,33916,input_DecoderGetObjects,1,input_DecoderGetObjects,"void input_DecoderGetObjects (decoder_t*,vout_thread_t**,audio_output_t**)",input\decoder.c,"void input_DecoderGetObjects( decoder_t *p_dec,
                              vout_thread_t **pp_vout, audio_output_t **pp_aout )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    vlc_mutex_lock( &p_owner->lock );
    if( pp_vout )
        *pp_vout = p_owner->p_vout ? vlc_object_hold( p_owner->p_vout ) : NULL;
    if( pp_aout )
        *pp_aout = p_owner->p_aout ? vlc_object_hold( p_owner->p_aout ) : NULL;
    vlc_mutex_unlock( &p_owner->lock );
}",2380.0,2391.0,1.0,1.0,12.0,16,5,14,5,1,10,3,3,0,4,,0,8,6,3,3,void
1904,34105,demux_mapping_cmp,1,demux_mapping_cmp,"int demux_mapping_cmp (void*,void*)",input\demux.c,"static int demux_mapping_cmp( const void *k, const void *v )
{
    demux_mapping* entry = v;
    return vlc_ascii_strcasecmp( k, entry->key );
}",46.0,50.0,1.0,1.0,5.0,2,2,4,3,0,1,1,1,0,0,,0,1,4,2,2,int
1905,34121,demux_lookup,1,demux_lookup,"demux_mapping demux_lookup (char*,demux_mapping*,size_t)",input\demux.c,"static demux_mapping* demux_lookup( char const* key,
                                    demux_mapping* data, size_t size )
{
    return bsearch( key, data, size, sizeof( *data ), demux_mapping_cmp );
}",52.0,56.0,1.0,1.0,5.0,2,2,4,3,2,0,1,1,0,0,,0,0,6,3,3,demux_mapping
1906,34137,demux_NameFromMimeType,1,demux_NameFromMimeType,const char* demux_NameFromMimeType (char*),input\demux.c,"static const char *demux_NameFromMimeType(const char *mime)
{
    static demux_mapping types[] =
    {   /* Must be sorted in ascending ASCII order */
        { ""audio/aac"",           ""m4a""     },
        { ""audio/aacp"",          ""m4a""     },
        { ""audio/mpeg"",          ""mp3""     },
        //{ ""video/MP1S"",          ""es,mpgv"" }, !b_force
        { ""video/dv"",            ""rawdv""   },
        { ""video/MP2P"",          ""ps""      },
        { ""video/MP2T"",          ""ts""      },
        { ""video/nsa"",           ""nsv""     },
        { ""video/nsv"",           ""nsv""     },
    };
    demux_mapping *type = demux_lookup( mime, types, ARRAY_SIZE( types ) );
    return (type != NULL) ? type->name : ""any"";
}",58.0,74.0,1.0,1.0,17.0,14,5,8,4,1,2,1,1,0,1,,0,2,2,1,1,const char*
1907,34187,DemuxNameFromExtension,1,DemuxNameFromExtension,"const char* DemuxNameFromExtension (char*,bool)",input\demux.c,"static const char* DemuxNameFromExtension( char const* ext,
                                           bool b_preparsing )
{
    /* NOTE: Add only file without any problems here and with strong detection:
     * - no .mp3, .a52, ...
     *  - wav can't be added 'cause of a52 and dts in them as raw audio
     */
    static demux_mapping strong[] =
    { /* NOTE: must be sorted in asc order */
        { ""aiff"", ""aiff"" },
        { ""asf"",  ""asf"" },
        { ""au"",   ""au"" },
        { ""avi"",  ""avi"" },
        { ""drc"",  ""dirac"" },
        { ""dv"",   ""dv"" },
        { ""flac"", ""flac"" },
        { ""h264"", ""h264"" },
        { ""kar"", ""smf"" },
        { ""m3u"",  ""m3u"" },
        { ""m4a"",  ""mp4"" },
        { ""m4v"",  ""m4v"" },
        { ""mid"",  ""smf"" },
        { ""mka"",  ""mkv"" },
        { ""mks"",  ""mkv"" },
        { ""mkv"",  ""mkv"" },
        { ""moov"", ""mp4"" },
        { ""mov"",  ""mp4"" },
        { ""mp4"",  ""mp4"" },
        { ""nsv"",  ""nsv"" },
        { ""oga"",  ""ogg"" },
        { ""ogg"",  ""ogg"" },
      ...",76.0,139.0,1.0,1.0,64.0,51,5,18,9,1,2,1,1,0,1,,0,2,4,2,2,const char*
1908,34347,demux_New,1,demux_New,"demux_t demux_New (vlc_object_t*,char*,char*,stream_t*,es_out_t*)",input\demux.c,"demux_t *demux_New( vlc_object_t *p_obj, const char *psz_name,
                    const char *psz_location, stream_t *s, es_out_t *out )
{
    return demux_NewAdvanced( p_obj, NULL,
                              (s == NULL) ? psz_name : """",
                              (s != NULL) ? psz_name : """",
                              psz_location, s, out, false );
}",145.0,152.0,1.0,11.0,8.0,4,3,18,7,0,1,1,1,0,1,,0,0,10,5,5,demux_t
1909,34387,destroy,1,demux_priv_t.destroy,void demux_priv_t.destroy (demux_t*),input\demux.c,void (*destroy)(demux_t *);,157.0,157.0,10.0,30.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1910,34393,demux_DestroyDemux,1,demux_DestroyDemux,void demux_DestroyDemux (demux_t*),input\demux.c,"static void demux_DestroyDemux(demux_t *demux)
{
    assert(demux->s != NULL);
    vlc_stream_Delete(demux->s);
}",160.0,164.0,1.0,1.0,5.0,3,2,3,2,0,1,1,1,0,1,,0,0,2,1,1,void
1911,34408,demux_DestroyAccessDemux,1,demux_DestroyAccessDemux,void demux_DestroyAccessDemux (demux_t*),input\demux.c,"static void demux_DestroyAccessDemux(demux_t *demux)
{
    assert(demux->s == NULL);
    (void) demux;
}",166.0,170.0,1.0,1.0,5.0,3,3,3,2,0,0,1,1,0,0,,0,0,2,1,1,void
1912,34422,demux_DestroyDemuxFilter,1,demux_DestroyDemuxFilter,void demux_DestroyDemuxFilter (demux_t*),input\demux.c,"static void demux_DestroyDemuxFilter(demux_t *demux)
{
    assert(demux->p_next != NULL);
    demux_Delete(demux->p_next);
}",172.0,176.0,1.0,1.0,5.0,3,2,3,2,0,1,1,1,0,1,,0,0,2,1,1,void
1913,34437,demux_Probe,1,demux_Probe,"int demux_Probe (void*,va_list)",input\demux.c,"static int demux_Probe(void *func, va_list ap)
{
    int (*probe)(vlc_object_t *) = func;
    demux_t *demux = va_arg(ap, demux_t *);

    /* Restore input stream offset (in case previous probed demux failed to
     * to do so). */
    if (vlc_stream_Tell(demux->s) != 0 && vlc_stream_Seek(demux->s, 0))
    {
        msg_Err(demux, ""seek failure before probing"");
        return VLC_EGENERIC;
    }

    return probe(VLC_OBJECT(demux));
}",178.0,192.0,1.0,1.0,15.0,4,3,5,2,0,2,2,2,2,2,,0,2,4,2,2,int
1914,34441,probe,1,demux_Probe.probe,int demux_Probe.probe (vlc_object_t*),input\demux.c,int (*probe)(vlc_object_t *) = func;,180.0,180.0,9.0,39.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
1915,34472,demux_NewAdvanced,1,demux_NewAdvanced,"demux_t demux_NewAdvanced (vlc_object_t*,input_thread_t*,char*,char*,char*,stream_t*,es_out_t*,bool)",input\demux.c,"demux_t *demux_NewAdvanced( vlc_object_t *p_obj, input_thread_t *p_parent_input,
                            const char *psz_access, const char *psz_demux,
                            const char *psz_location,
                            stream_t *s, es_out_t *out, bool b_preparsing )
{
    demux_priv_t *priv = vlc_custom_create(p_obj, sizeof (*priv), ""demux"");
    if (unlikely(priv == NULL))
        return NULL;

    demux_t *p_demux = &priv->demux;

    if( s != NULL && (!strcasecmp( psz_demux, ""any"" ) || !psz_demux[0]) )
    {   /* Look up demux by mime-type for hard to detect formats */
        char *type = stream_MimeType( s );
        if( type != NULL )
        {
            psz_demux = demux_NameFromMimeType( type );
            free( type );
        }
    }

    p_demux->p_input = p_parent_input;
    p_demux->psz_access = strdup( psz_access );
    p_demux->psz_demux = strdup( psz_demux );
    p_demux->psz_location = strdup( psz_location );
    p_demux->psz_file = get_path( p...",199.0,284.0,1.0,1.0,86.0,86,14,89,14,4,7,13,16,0,6,,0,6,16,8,8,demux_t
1916,34776,demux_Delete,1,demux_Delete,void demux_Delete (demux_t*),input\demux.c,"void demux_Delete( demux_t *p_demux )
{
    demux_priv_t *priv = (demux_priv_t *)p_demux;

    module_unneed( p_demux, p_demux->p_module );

    priv->destroy(p_demux);
    free( p_demux->psz_file );
    free( p_demux->psz_location );
    free( p_demux->psz_demux );
    free( p_demux->psz_access );
    vlc_object_release( p_demux );
}",289.0,301.0,1.0,1.0,13.0,8,3,11,2,2,3,1,1,0,3,,0,0,2,1,1,void
1917,34815,demux_ControlInternal,1,demux_ControlInternal,"int demux_ControlInternal (demux_t*,int...)",input\demux.c,"static int demux_ControlInternal( demux_t *demux, int query, ... )
{
    int ret;
    va_list ap;

    va_start( ap, query );
    ret = demux->pf_control( demux, query, ap );
    va_end( ap );
    return ret;
}",306.0,315.0,1.0,1.0,10.0,2,2,9,4,1,0,1,1,0,0,,0,0,4,2,2,int
1918,34839,demux_vaControl,1,demux_vaControl,"int demux_vaControl (demux_t*,int,va_list)",input\demux.c,"int demux_vaControl( demux_t *demux, int query, va_list args )
{
    if( demux->s != NULL )
        switch( query )
        {
            /* Legacy fallback for missing getters in synchronous demuxers */
            case DEMUX_CAN_PAUSE:
            case DEMUX_CAN_CONTROL_PACE:
            case DEMUX_GET_PTS_DELAY:
            {
                int ret;
                va_list ap;

                va_copy( ap, args );
                ret = demux->pf_control( demux, query, args );
                if( ret != VLC_SUCCESS )
                    ret = vlc_stream_vaControl( demux->s, query, ap );
                va_end( ap );
                return ret;
            }

            /* Some demuxers need to control pause directly (e.g. adaptive),
             * but many legacy demuxers do not understand pause at all.
             * If DEMUX_CAN_PAUSE is not implemented, bypass the demuxer and
             * byte stream. If DEMUX_CAN_PAUSE is implemented and pause is
             * supported, ...",317.0,366.0,1.0,1.0,50.0,10,4,33,12,0,3,6,10,1,3,,0,2,6,3,3,int
1919,34923,demux_vaControlHelper,1,demux_vaControlHelper,"int demux_vaControlHelper (stream_t*,int64_t,int64_t,int64_t,int,int,va_list)",input\demux.c,"int demux_vaControlHelper( stream_t *s,
                            int64_t i_start, int64_t i_end,
                            int64_t i_bitrate, int i_align,
                            int i_query, va_list args )
{
    int64_t i_tell;
    double  f, *pf;
    int64_t i64, *pi64;

    if( i_end < 0 )    i_end   = stream_Size( s );
    if( i_start < 0 )  i_start = 0;
    if( i_align <= 0 ) i_align = 1;
    i_tell = vlc_stream_Tell( s );

    static_control_match(CAN_PAUSE);
    static_control_match(CAN_CONTROL_PACE);
    static_control_match(GET_PTS_DELAY);
    static_control_match(GET_META);
    static_control_match(GET_SIGNAL);
    static_control_match(SET_PAUSE_STATE);

    switch( i_query )
    {
        case DEMUX_CAN_SEEK:
        {
            bool *b = va_arg( args, bool * );

            if( (i_bitrate <= 0 && i_start >= i_end)
             || vlc_stream_Control( s, STREAM_CAN_SEEK, b ) )
                *b = false;
            break;
        }

        case DEMUX_CAN_PAUSE...",371.0,503.0,1.0,4.0,133.0,71,14,135,62,0,4,14,23,2,4,,0,3,14,7,7,int
1920,35295,demux_PacketizerNew,1,demux_PacketizerNew,"decoder_t demux_PacketizerNew (demux_t*,es_format_t*,char*)",input\demux.c,"decoder_t *demux_PacketizerNew( demux_t *p_demux, es_format_t *p_fmt, const char *psz_msg )
{
    decoder_t *p_packetizer;
    p_packetizer = vlc_custom_create( p_demux, sizeof( *p_packetizer ),
                                      ""demux packetizer"" );
    if( !p_packetizer )
    {
        es_format_Clean( p_fmt );
        return NULL;
    }
    p_fmt->b_packetized = false;

    p_packetizer->pf_decode = NULL;
    p_packetizer->pf_packetize = NULL;

    p_packetizer->fmt_in = *p_fmt;
    es_format_Init( &p_packetizer->fmt_out, p_fmt->i_cat, 0 );

    p_packetizer->p_module = module_need( p_packetizer, ""packetizer"", NULL, false );
    if( !p_packetizer->p_module )
    {
        es_format_Clean( p_fmt );
        vlc_object_release( p_packetizer );
        msg_Err( p_demux, ""cannot find packetizer for %s"", psz_msg );
        return NULL;
    }

    return p_packetizer;
}",508.0,536.0,1.0,1.0,29.0,20,6,27,6,0,6,3,3,0,6,,0,2,6,3,3,decoder_t
1921,35376,demux_PacketizerDestroy,1,demux_PacketizerDestroy,void demux_PacketizerDestroy (decoder_t*),input\demux.c,"void demux_PacketizerDestroy( decoder_t *p_packetizer )
{
    if( p_packetizer->p_module )
        module_unneed( p_packetizer, p_packetizer->p_module );
    es_format_Clean( &p_packetizer->fmt_in );
    es_format_Clean( &p_packetizer->fmt_out );
    if( p_packetizer->p_description )
        vlc_meta_Delete( p_packetizer->p_description );
    vlc_object_release( p_packetizer );
}",538.0,547.0,1.0,1.0,10.0,8,2,8,1,0,5,3,3,0,5,,0,0,2,1,1,void
1922,35412,demux_TestAndClearFlags,1,demux_TestAndClearFlags,"unsigned demux_TestAndClearFlags (demux_t*,unsigned)",input\demux.c,"unsigned demux_TestAndClearFlags( demux_t *p_demux, unsigned flags )
{
    unsigned update = flags;

    if ( demux_Control( p_demux, DEMUX_TEST_AND_CLEAR_FLAGS, &update ) == VLC_SUCCESS )
        return update;

    update = p_demux->info.i_update & flags;
    p_demux->info.i_update &= ~flags;
    return update;
}",549.0,559.0,1.0,1.0,11.0,10,7,13,5,2,0,2,2,0,0,,0,0,4,2,2,unsigned
1923,35452,demux_GetTitle,1,demux_GetTitle,int demux_GetTitle (demux_t*),input\demux.c,"int demux_GetTitle( demux_t *p_demux )
{
    int i_title;
    if ( demux_Control( p_demux, DEMUX_GET_TITLE, &i_title ) == VLC_SUCCESS )
        return i_title;
    return p_demux->info.i_title;
}",561.0,567.0,1.0,1.0,7.0,4,4,6,4,0,0,2,2,0,0,,0,0,2,1,1,int
1924,35475,demux_GetSeekpoint,1,demux_GetSeekpoint,int demux_GetSeekpoint (demux_t*),input\demux.c,"int demux_GetSeekpoint( demux_t *p_demux )
{
    int i_seekpoint;
    if ( demux_Control( p_demux, DEMUX_GET_SEEKPOINT, &i_seekpoint ) == VLC_SUCCESS  )
        return i_seekpoint;
    return p_demux->info.i_seekpoint;
}",569.0,575.0,1.0,1.0,7.0,4,4,6,4,0,0,2,2,0,0,,0,0,2,1,1,int
1925,35498,demux_FilterNew,1,demux_FilterNew,"demux_t demux_FilterNew (demux_t*,char*)",input\demux.c,"static demux_t *demux_FilterNew( demux_t *p_next, const char *p_name )
{
    demux_priv_t *priv = vlc_custom_create(p_next, sizeof (*priv), ""demux_filter"");
    if (unlikely(priv == NULL))
        return NULL;

    demux_t *p_demux = &priv->demux;

    p_demux->p_next       = p_next;
    p_demux->p_input      = NULL;
    p_demux->p_sys        = NULL;
    p_demux->psz_access   = NULL;
    p_demux->psz_demux    = NULL;
    p_demux->psz_location = NULL;
    p_demux->psz_file     = NULL;
    p_demux->out          = NULL;
    priv->destroy         = demux_DestroyDemuxFilter;
    p_demux->p_module =
        module_need( p_demux, ""demux_filter"", p_name, p_name != NULL );

    if( p_demux->p_module == NULL )
        goto error;

    return p_demux;
error:
    vlc_object_release( p_demux );
    return NULL;
}",577.0,604.0,1.0,1.0,28.0,30,7,35,5,1,4,4,3,0,3,,0,3,4,2,2,demux_t
1926,35599,demux_FilterChainNew,1,demux_FilterChainNew,"demux_t demux_FilterChainNew (demux_t*,char*)",input\demux.c,"demux_t *demux_FilterChainNew( demux_t *p_demux, const char *psz_chain )
{
    if( !psz_chain || !*psz_chain )
        return NULL;

    char *psz_parser = strdup(psz_chain);
    if(!psz_parser)
        return NULL;

    /* parse chain */
    while(psz_parser)
    {
        config_chain_t *p_cfg;
        char *psz_name;
        char *psz_rest_chain = config_ChainCreate( &psz_name, &p_cfg, psz_parser );
        free( psz_parser );
        psz_parser = psz_rest_chain;

        demux_t *filter = demux_FilterNew(p_demux, psz_name);
        if (filter != NULL)
            p_demux = filter;

        free(psz_name);
        config_ChainDestroy(p_cfg);
    }

    return p_demux;
}",606.0,633.0,1.0,1.0,28.0,13,6,25,8,1,3,5,6,0,3,,0,2,4,2,2,demux_t
1927,35665,demux_filter_enable_disable,1,demux_filter_enable_disable,"bool demux_filter_enable_disable (demux_t*,char*,bool)",input\demux.c,"static bool demux_filter_enable_disable( demux_t *p_demux_chain,
                                          const char* psz_demux, bool b_enable )
{
    demux_t *p_demux = p_demux_chain;

     if( strcmp( module_get_name( p_demux->p_module, false ), psz_demux) == 0 ||
         strcmp( module_get_name( p_demux->p_module, true ), psz_demux ) == 0 )
     {
        demux_Control( p_demux,
                       b_enable ? DEMUX_FILTER_ENABLE : DEMUX_FILTER_DISABLE );
        return true;
    }
    return false;
}",635.0,648.0,1.0,1.0,14.0,7,5,14,8,2,2,2,2,2,2,,0,2,6,3,3,bool
1928,35707,demux_FilterEnable,1,demux_FilterEnable,"bool demux_FilterEnable (demux_t*,char*)",input\demux.c,"bool demux_FilterEnable( demux_t *p_demux_chain, const char* psz_demux )
{
    return demux_filter_enable_disable( p_demux_chain, psz_demux, true );
}",650.0,653.0,1.0,1.0,4.0,0,0,3,3,0,1,1,1,0,1,,0,0,4,2,2,bool
1929,35718,demux_FilterDisable,1,demux_FilterDisable,"bool demux_FilterDisable (demux_t*,char*)",input\demux.c,"bool demux_FilterDisable( demux_t *p_demux_chain, const char* psz_demux )
{
    return demux_filter_enable_disable( p_demux_chain, psz_demux, false );
}",655.0,658.0,1.0,1.0,4.0,0,0,3,3,0,1,1,1,0,1,,0,0,4,2,2,bool
1930,35823,vlc_demux_chained_Thread,1,vlc_demux_chained_Thread,void* vlc_demux_chained_Thread (void*),input\demux_chained.c,"static void *vlc_demux_chained_Thread(void *data)
{
    vlc_demux_chained_t *dc = data;
    demux_t *demux = demux_NewAdvanced(dc->fifo, NULL, """", dc->name, """",
                                       dc->fifo, dc->out, false);
    if (demux == NULL)
    {
        vlc_stream_Delete(dc->fifo);
        return NULL;
    }

    /* Stream FIFO cannot apply DVB filters.
     * Get all programs and let the E/S output sort them out. */
    demux_Control(demux, DEMUX_SET_GROUP, -1, NULL);

    /* Main loop */
    mtime_t next_update = 0;

    do
        if (demux_TestAndClearFlags(demux, UINT_MAX) || mdate() >= next_update)
        {
            double newpos;
            int64_t newlen, newtime;

            if (demux_Control(demux, DEMUX_GET_POSITION, &newpos))
                newpos = 0.;
            if (demux_Control(demux, DEMUX_GET_LENGTH, &newlen))
                newlen = 0;
            if (demux_Control(demux, DEMUX_GET_TIME, &newtime))
                newtime = 0;

            vlc_m...",53.0,96.0,1.0,21.0,44.0,38,10,50,15,0,19,3,3,7,8,,0,15,2,1,1,void*
1931,35981,vlc_demux_chained_New,1,vlc_demux_chained_New,"vlc_demux_chained_t vlc_demux_chained_New (vlc_object_t*,char*,es_out_t*)",input\demux_chained.c,"vlc_demux_chained_t *vlc_demux_chained_New(vlc_object_t *parent,
                                           const char *name, es_out_t *out)
{
    vlc_demux_chained_t *dc = malloc(sizeof (*dc) + strlen(name) + 1);
    if (unlikely(dc == NULL))
        return NULL;

    dc->fifo = vlc_stream_fifo_New(parent);
    if (dc->fifo == NULL)
    {
        free(dc);
        return NULL;
    }

    dc->stats.position = 0.;
    dc->stats.length = 0;
    dc->stats.time = 0;
    dc->out = out;
    strcpy(dc->name, name);

    vlc_mutex_init(&dc->lock);

    if (vlc_clone(&dc->thread, vlc_demux_chained_Thread, dc,
                  VLC_THREAD_PRIORITY_INPUT))
    {
        vlc_stream_Delete(dc->fifo);
        vlc_stream_fifo_Close(dc->fifo);
        vlc_mutex_destroy(&dc->lock);
        free(dc);
        dc = NULL;
    }
    return dc;
}",98.0,130.0,1.0,1.0,33.0,31,8,30,6,0,15,4,4,3,6,,0,11,6,3,3,vlc_demux_chained_t
1932,36091,vlc_demux_chained_Send,1,vlc_demux_chained_Send,"void vlc_demux_chained_Send (vlc_demux_chained_t*,block_t*)",input\demux_chained.c,"void vlc_demux_chained_Send(vlc_demux_chained_t *dc, block_t *block)
{
    vlc_stream_fifo_Queue(dc->fifo, block);
}",132.0,135.0,1.0,1.0,4.0,1,1,2,2,0,2,1,1,0,1,,0,1,4,2,2,void
1933,36102,vlc_demux_chained_ControlVa,1,vlc_demux_chained_ControlVa,"int vlc_demux_chained_ControlVa (vlc_demux_chained_t*,int,va_list)",input\demux_chained.c,"int vlc_demux_chained_ControlVa(vlc_demux_chained_t *dc, int query, va_list ap)
{
    switch (query)
    {
        case DEMUX_GET_POSITION:
            vlc_mutex_lock(&dc->lock);
            *va_arg(ap, double *) = dc->stats.position;
            vlc_mutex_unlock(&dc->lock);
            break;
        case DEMUX_GET_LENGTH:
            vlc_mutex_lock(&dc->lock);
            *va_arg(ap, int64_t *) = dc->stats.length;
            vlc_mutex_unlock(&dc->lock);
            break;
        case DEMUX_GET_TIME:
            vlc_mutex_lock(&dc->lock);
            *va_arg(ap, int64_t *) = dc->stats.time;
            vlc_mutex_unlock(&dc->lock);
            break;
        default:
            return VLC_EGENERIC;
    }
    return VLC_SUCCESS;
}",137.0,160.0,1.0,1.0,24.0,12,2,12,7,0,12,5,2,0,6,,0,6,6,3,3,int
1934,36159,vlc_demux_chained_Delete,1,vlc_demux_chained_Delete,void vlc_demux_chained_Delete (vlc_demux_chained_t*),input\demux_chained.c,"void vlc_demux_chained_Delete(vlc_demux_chained_t *dc)
{
    vlc_stream_fifo_Close(dc->fifo);
    vlc_join(dc->thread, NULL);
    vlc_mutex_destroy(&dc->lock);
    free(dc);
}",162.0,168.0,1.0,1.0,7.0,4,2,5,2,0,6,1,1,0,3,,0,3,2,1,1,void
1935,36299,EsOutAdd,1,EsOutAdd,"es_out_id_t* EsOutAdd (es_out_t*,es_format_t*)",input\es_out.c,"static es_out_id_t *EsOutAdd( es_out_t *out, const es_format_t *fmt )
{
    return EsOutAddSlave( out, fmt, NULL );
}",1671.0,1674.0,1.0,1.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,es_out_id_t
1936,36305,EsOutSend,1,EsOutSend,"int EsOutSend (es_out_t*,es_out_id_t*,block_t*)",input\es_out.c,"static int EsOutSend( es_out_t *out, es_out_id_t *es, block_t *p_block )
{
    es_out_sys_t   *p_sys = out->p_sys;
    input_thread_t *p_input = p_sys->p_input;

    assert( p_block->p_next == NULL );

    if( libvlc_stats( p_input ) )
    {
        uint64_t i_total;

        vlc_mutex_lock( &input_priv(p_input)->counters.counters_lock );
        stats_Update( input_priv(p_input)->counters.p_demux_read,
                      p_block->i_buffer, &i_total );
        stats_Update( input_priv(p_input)->counters.p_demux_bitrate, i_total, NULL );

        /* Update number of corrupted data packats */
        if( p_block->i_flags & BLOCK_FLAG_CORRUPTED )
        {
            stats_Update( input_priv(p_input)->counters.p_demux_corrupted, 1, NULL );
        }
        /* Update number of discontinuities */
        if( p_block->i_flags & BLOCK_FLAG_DISCONTINUITY )
        {
            stats_Update( input_priv(p_input)->counters.p_demux_discontinuity, 1, NULL );
        }
        vlc_mutex_unl...",2055.0,2174.0,1.0,1.0,120.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
1937,36312,EsOutDel,1,EsOutDel,"void EsOutDel (es_out_t*,es_out_id_t*)",input\es_out.c,"static void EsOutDel( es_out_t *out, es_out_id_t *es )
{
    es_out_sys_t *p_sys = out->p_sys;
    bool b_reselect = false;
    int i;

    vlc_mutex_lock( &p_sys->lock );

    es_out_es_props_t *p_esprops = GetPropsByCat( p_sys, es->fmt.i_cat );

    /* We don't try to reselect */
    if( es->p_dec )
    {   /* FIXME: This might hold the ES output caller (i.e. the demux), and
         * the corresponding thread (typically the input thread), for a little
         * bit too long if the ES is deleted in the middle of a stream. */
        input_DecoderDrain( es->p_dec );
        while( !input_Stopped(p_sys->p_input) && !p_sys->b_buffering )
        {
            if( input_DecoderIsEmpty( es->p_dec ) &&
                ( !es->p_dec_record || input_DecoderIsEmpty( es->p_dec_record ) ))
                break;
            /* FIXME there should be a way to have auto deleted es, but there will be
             * a problem when another codec of the same type is created (mainly video) */
      ...",2179.0,2260.0,1.0,1.0,82.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
1938,36318,EsOutControl,1,EsOutControl,"int EsOutControl (es_out_t*,int,ANY)",input\es_out.c,"static int EsOutControl( es_out_t *out, int i_query, va_list args )
{
    es_out_sys_t *p_sys = out->p_sys;
    int i_ret;

    vlc_mutex_lock( &p_sys->lock );
    i_ret = EsOutControlLocked( out, i_query, args );
    vlc_mutex_unlock( &p_sys->lock );

    return i_ret;
}",2922.0,2932.0,1.0,1.0,11.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
1939,36325,EsOutDelete,1,EsOutDelete,void EsOutDelete (es_out_t*),input\es_out.c,"static void EsOutDelete( es_out_t *out )
{
    es_out_sys_t *p_sys = out->p_sys;

    assert( !p_sys->i_es && !p_sys->i_pgrm && !p_sys->p_pgrm );
    EsOutPropsCleanup( &p_sys->audio );
    EsOutPropsCleanup( &p_sys->sub );

    vlc_mutex_destroy( &p_sys->lock );

    free( p_sys );
    free( out );
}",346.0,358.0,1.0,1.0,13.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1940,36330,EsOutTerminate,1,EsOutTerminate,void EsOutTerminate (es_out_t*),input\es_out.c,"static void EsOutTerminate( es_out_t *out )
{
    es_out_sys_t *p_sys = out->p_sys;

    if( p_sys->p_sout_record )
        EsOutSetRecord( out, false );

    for( int i = 0; i < p_sys->i_es; i++ )
    {
        if( p_sys->es[i]->p_dec )
            input_DecoderDelete( p_sys->es[i]->p_dec );

        free( p_sys->es[i]->psz_language );
        free( p_sys->es[i]->psz_language_code );
        es_format_Clean( &p_sys->es[i]->fmt );

        free( p_sys->es[i] );
    }
    TAB_CLEAN( p_sys->i_es, p_sys->es );

    /* FIXME duplicate work EsOutProgramDel (but we cannot use it) add a EsOutProgramClean ? */
    for( int i = 0; i < p_sys->i_pgrm; i++ )
    {
        es_out_pgrm_t *p_pgrm = p_sys->pgrm[i];
        input_clock_Delete( p_pgrm->p_clock );
        if( p_pgrm->p_meta )
            vlc_meta_Delete( p_pgrm->p_meta );

        free( p_pgrm );
    }
    TAB_CLEAN( p_sys->i_pgrm, p_sys->pgrm );

    p_sys->p_pgrm = NULL;

    input_item_SetEpgOffline( input_priv(p_sys->p_input)->p_i...",360.0,396.0,1.0,1.0,37.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1941,36335,EsOutSelect,1,EsOutSelect,"void EsOutSelect (es_out_t*,es_out_id_t*,bool)",input\es_out.c,"static void EsOutSelect( es_out_t *out, es_out_id_t *es, bool b_force )
{
    es_out_sys_t      *p_sys = out->p_sys;
    es_out_es_props_t *p_esprops = GetPropsByCat( p_sys, es->fmt.i_cat );

    if( !p_sys->b_active ||
        ( !b_force && es->fmt.i_priority < ES_PRIORITY_SELECTABLE_MIN ) )
    {
        return;
    }

    bool b_auto_unselect = p_esprops && p_sys->i_mode == ES_OUT_MODE_AUTO &&
                           p_esprops->e_policy == ES_OUT_ES_POLICY_EXCLUSIVE &&
                           p_esprops->p_main_es && p_esprops->p_main_es != es;

    if( p_sys->i_mode == ES_OUT_MODE_ALL || b_force )
    {
        if( !EsIsSelected( es ) )
        {
            if( b_auto_unselect )
                EsUnselect( out, p_esprops->p_main_es, false );

            EsSelect( out, es );
        }
    }
    else if( p_sys->i_mode == ES_OUT_MODE_PARTIAL )
    {
        char *prgms = var_GetNonEmptyString( p_sys->p_input, ""programs"" );
        if( prgms != NULL )
        {
            ch...",1871.0,2006.0,1.0,1.0,136.0,0,0,0,0,3,0,1,1,0,0,,0,0,6,3,3,void
1942,36342,EsOutUpdateInfo,1,EsOutUpdateInfo,"void EsOutUpdateInfo (es_out_t*,es_out_id_t*,es_format_t*,vlc_meta_t*)",input\es_out.c,"static void EsOutUpdateInfo( es_out_t *out, es_out_id_t *es, const es_format_t *fmt, const vlc_meta_t *p_meta )
{
    es_out_sys_t   *p_sys = out->p_sys;
    input_thread_t *p_input = p_sys->p_input;
    const es_format_t *p_fmt_es = &es->fmt;
    lldiv_t         div;

    if( es->fmt.i_cat == fmt->i_cat )
    {
        es_format_t update = *fmt;
        update.i_id = es->i_meta_id;
        update.i_codec = es->fmt.i_codec;
        update.i_original_fourcc = es->fmt.i_original_fourcc;

        /* Update infos that could have been lost by the decoder (no need to
         * dup them since input_item_UpdateTracksInfo() will do it). */
        if (update.psz_language == NULL)
            update.psz_language = es->fmt.psz_language;
        if (update.psz_description == NULL)
            update.psz_description = es->fmt.psz_description;
        if (update.i_cat == SPU_ES)
        {
            if (update.subs.psz_encoding == NULL)
                update.subs.psz_encoding = es->fmt.subs.ps...",3068.0,3407.0,1.0,1.0,340.0,0,0,0,0,2,0,1,1,0,0,,0,0,8,4,4,void
1943,36350,EsOutSetRecord,1,EsOutSetRecord,"int EsOutSetRecord (es_out_t*,bool)",input\es_out.c,"static int EsOutSetRecord(  es_out_t *out, bool b_record )
{
    es_out_sys_t   *p_sys = out->p_sys;
    input_thread_t *p_input = p_sys->p_input;

    assert( ( b_record && !p_sys->p_sout_record ) || ( !b_record && p_sys->p_sout_record ) );

    if( b_record )
    {
        char *psz_path = var_CreateGetNonEmptyString( p_input, ""input-record-path"" );
        if( !psz_path )
        {
            if( var_CountChoices( p_input, ""video-es"" ) )
                psz_path = config_GetUserDir( VLC_VIDEOS_DIR );
            else if( var_CountChoices( p_input, ""audio-es"" ) )
                psz_path = config_GetUserDir( VLC_MUSIC_DIR );
            else
                psz_path = config_GetUserDir( VLC_DOWNLOAD_DIR );
        }

        char *psz_sout = NULL;  // TODO conf

        if( !psz_sout && psz_path )
        {
            char *psz_file = input_CreateFilename( p_input, psz_path, INPUT_RECORD_PREFIX, NULL );
            if( psz_file )
            {
                char* psz_file_esc ...",473.0,554.0,1.0,1.0,82.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
1944,36356,EsIsSelected,1,EsIsSelected,bool EsIsSelected (es_out_id_t*),input\es_out.c,"static bool EsIsSelected( es_out_id_t *es )
{
    if( es->p_master )
    {
        bool b_decode = false;
        if( es->p_master->p_dec )
        {
            int i_channel = EsOutGetClosedCaptionsChannel( &es->fmt );
            input_DecoderGetCcState( es->p_master->p_dec, es->fmt.i_codec,
                                     i_channel, &b_decode );
        }
        return b_decode;
    }
    else
    {
        return es->p_dec != NULL;
    }
}",1676.0,1693.0,1.0,1.0,18.0,0,0,0,0,6,0,1,1,0,0,,0,0,2,1,1,bool
1945,36361,EsSelect,1,EsSelect,"void EsSelect (es_out_t*,es_out_id_t*)",input\es_out.c,"static void EsSelect( es_out_t *out, es_out_id_t *es )
{
    es_out_sys_t   *p_sys = out->p_sys;
    input_thread_t *p_input = p_sys->p_input;

    if( EsIsSelected( es ) )
    {
        msg_Warn( p_input, ""ES 0x%x is already selected"", es->i_id );
        return;
    }

    if( es->p_master )
    {
        int i_channel;
        if( !es->p_master->p_dec )
            return;

        i_channel = EsOutGetClosedCaptionsChannel( &es->fmt );

        if( i_channel == -1 ||
            input_DecoderSetCcState( es->p_master->p_dec, es->fmt.i_codec,
                                     i_channel, true ) )
            return;
    }
    else
    {
        const bool b_sout = input_priv(p_input)->p_sout != NULL;
        if( es->fmt.i_cat == VIDEO_ES || es->fmt.i_cat == SPU_ES )
        {
            if( !var_GetBool( p_input, b_sout ? ""sout-video"" : ""video"" ) )
            {
                msg_Dbg( p_input, ""video is disabled, not selecting ES 0x%x"",
                         es->i_id );
   ...",1732.0,1796.0,1.0,1.0,65.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
1946,36367,EsDeleteInfo,1,EsDeleteInfo,"void EsDeleteInfo (es_out_t*,es_out_id_t*)",input\es_out.c,"static void EsDeleteInfo( es_out_t *out, es_out_id_t *es )
{
    char* psz_info_category;

    if( likely( psz_info_category = EsInfoCategoryName( es ) ) )
    {
        input_Control( out->p_sys->p_input, INPUT_DEL_INFO,
          psz_info_category, NULL );

        free( psz_info_category );
    }
}",3409.0,3420.0,1.0,1.0,12.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
1947,36373,EsUnselect,1,EsUnselect,"void EsUnselect (es_out_t*,es_out_id_t*,bool)",input\es_out.c,"static void EsUnselect( es_out_t *out, es_out_id_t *es, bool b_update )
{
    es_out_sys_t   *p_sys = out->p_sys;
    input_thread_t *p_input = p_sys->p_input;

    if( !EsIsSelected( es ) )
    {
        msg_Warn( p_input, ""ES 0x%x is already unselected"", es->i_id );
        return;
    }

    if( es->p_master )
    {
        if( es->p_master->p_dec )
        {
            int i_channel = EsOutGetClosedCaptionsChannel( &es->fmt );
            if( i_channel != -1 )
                input_DecoderSetCcState( es->p_master->p_dec, es->fmt.i_codec,
                                         i_channel, false );
        }
    }
    else
    {
        EsDeleteCCChannels( out, es );
        EsDestroyDecoder( out, es );
    }

    if( !b_update )
        return;

    /* Mark it as unselected */
    input_SendEventEsSelect( p_input, es->fmt.i_cat, -1 );
    if( EsFmtIsTeletext( &es->fmt ) )
        input_SendEventTeletextSelect( p_input, -1 );
}",1826.0,1860.0,1.0,1.0,35.0,0,0,0,0,2,0,1,1,0,0,,0,0,6,3,3,void
1948,36380,EsOutDecoderChangeDelay,1,EsOutDecoderChangeDelay,"void EsOutDecoderChangeDelay (es_out_t*,es_out_id_t*)",input\es_out.c,"static void EsOutDecoderChangeDelay( es_out_t *out, es_out_id_t *p_es )
{
    es_out_sys_t *p_sys = out->p_sys;

    mtime_t i_delay = 0;
    if( p_es->fmt.i_cat == AUDIO_ES )
        i_delay = p_sys->i_audio_delay;
    else if( p_es->fmt.i_cat == SPU_ES )
        i_delay = p_sys->i_spu_delay;
    else
        return;

    if( p_es->p_dec )
        input_DecoderChangeDelay( p_es->p_dec, i_delay );
    if( p_es->p_dec_record )
        input_DecoderChangeDelay( p_es->p_dec_record, i_delay );
}",783.0,799.0,1.0,1.0,17.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
1949,36386,EsOutDecodersChangePause,1,EsOutDecodersChangePause,"void EsOutDecodersChangePause (es_out_t*,bool,mtime_t)",input\es_out.c,"static void EsOutDecodersChangePause( es_out_t *out, bool b_paused, mtime_t i_date )
{
    es_out_sys_t *p_sys = out->p_sys;

    /* Pause decoders first */
    for( int i = 0; i < p_sys->i_es; i++ )
    {
        es_out_id_t *es = p_sys->es[i];

        if( es->p_dec )
        {
            input_DecoderChangePause( es->p_dec, b_paused, i_date );
            if( es->p_dec_record )
                input_DecoderChangePause( es->p_dec_record, b_paused, i_date );
        }
    }
}",732.0,748.0,1.0,1.0,17.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
1950,36393,EsOutProgramChangePause,1,EsOutProgramChangePause,"void EsOutProgramChangePause (es_out_t*,bool,mtime_t)",input\es_out.c,"static void EsOutProgramChangePause( es_out_t *out, bool b_paused, mtime_t i_date )
{
    es_out_sys_t *p_sys = out->p_sys;

    for( int i = 0; i < p_sys->i_pgrm; i++ )
        input_clock_ChangePause( p_sys->pgrm[i]->p_clock, b_paused, i_date );
}",775.0,781.0,1.0,1.0,7.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
1951,36400,EsOutProgramsChangeRate,1,EsOutProgramsChangeRate,void EsOutProgramsChangeRate (es_out_t*),input\es_out.c,"static void EsOutProgramsChangeRate( es_out_t *out )
{
    es_out_sys_t      *p_sys = out->p_sys;

    for( int i = 0; i < p_sys->i_pgrm; i++ )
        input_clock_ChangeRate( p_sys->pgrm[i]->p_clock, p_sys->i_rate );
}",800.0,806.0,1.0,1.0,7.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1952,36405,EsOutDecodersStopBuffering,1,EsOutDecodersStopBuffering,"void EsOutDecodersStopBuffering (es_out_t*,bool)",input\es_out.c,"static void EsOutDecodersStopBuffering( es_out_t *out, bool b_forced )
{
    es_out_sys_t *p_sys = out->p_sys;

    mtime_t i_stream_start;
    mtime_t i_system_start;
    mtime_t i_stream_duration;
    mtime_t i_system_duration;
    if (input_clock_GetState( p_sys->p_pgrm->p_clock,
                                  &i_stream_start, &i_system_start,
                                  &i_stream_duration, &i_system_duration ))
        return;

    mtime_t i_preroll_duration = 0;
    if( p_sys->i_preroll_end >= 0 )
        i_preroll_duration = __MAX( p_sys->i_preroll_end - i_stream_start, 0 );

    const mtime_t i_buffering_duration = p_sys->i_pts_delay +
                                         i_preroll_duration +
                                         p_sys->i_buffering_extra_stream - p_sys->i_buffering_extra_initial;

    if( i_stream_duration <= i_buffering_duration && !b_forced )
    {
        double f_level;
        if (i_buffering_duration == 0)
            f_level = 0;
      ...",642.0,731.0,1.0,1.0,90.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,void
1953,36411,EsOutGlobalMeta,1,EsOutGlobalMeta,"void EsOutGlobalMeta (es_out_t*,vlc_meta_t*)",input\es_out.c,"static void EsOutGlobalMeta( es_out_t *p_out, const vlc_meta_t *p_meta )
{
    es_out_sys_t    *p_sys = p_out->p_sys;
    EsOutMeta( p_out, p_meta,
               (p_sys->p_pgrm && p_sys->p_pgrm->p_meta) ? p_sys->p_pgrm->p_meta : NULL );
}",1536.0,1541.0,1.0,1.0,6.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,void
1954,36417,EsOutMeta,1,EsOutMeta,"void EsOutMeta (es_out_t*,vlc_meta_t*,vlc_meta_t*)",input\es_out.c,"static void EsOutMeta( es_out_t *p_out, const vlc_meta_t *p_meta, const vlc_meta_t *p_program_meta )
{
    es_out_sys_t    *p_sys = p_out->p_sys;
    input_thread_t  *p_input = p_sys->p_input;
    input_item_t *p_item = input_GetItem( p_input );

    vlc_mutex_lock( &p_item->lock );
    if( p_meta )
        vlc_meta_Merge( p_item->p_meta, p_meta );
    vlc_mutex_unlock( &p_item->lock );

    /* Check program meta to not override GROUP_META values */
    if( p_meta && (!p_program_meta || vlc_meta_Get( p_program_meta, vlc_meta_Title ) == NULL) &&
         vlc_meta_Get( p_meta, vlc_meta_Title ) != NULL )
        input_item_SetName( p_item, vlc_meta_Get( p_meta, vlc_meta_Title ) );

    const char *psz_arturl = NULL;
    char *psz_alloc = NULL;

    if( p_program_meta )
        psz_arturl = vlc_meta_Get( p_program_meta, vlc_meta_ArtworkURL );
    if( psz_arturl == NULL && p_meta )
        psz_arturl = vlc_meta_Get( p_meta, vlc_meta_ArtworkURL );

    if( psz_arturl == NULL ) /* restore/...",1490.0,1534.0,1.0,1.0,45.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
1955,36424,LanguageGetName,1,LanguageGetName,char* LanguageGetName (char*),input\es_out.c,"static char *LanguageGetName( const char *psz_code )
{
    const iso639_lang_t *pl;

    if( psz_code == NULL || !strcmp( psz_code, ""und"" ) )
    {
        return strdup( """" );
    }

    if( strlen( psz_code ) == 2 )
    {
        pl = GetLang_1( psz_code );
    }
    else if( strlen( psz_code ) == 3 )
    {
        pl = GetLang_2B( psz_code );
        if( !strcmp( pl->psz_iso639_1, ""??"" ) )
        {
            pl = GetLang_2T( psz_code );
        }
    }
    else
    {
        char *lang = LanguageGetCode( psz_code );
        pl = GetLang_1( lang );
        free( lang );
    }

    if( !strcmp( pl->psz_iso639_1, ""??"" ) )
    {
       return strdup( psz_code );
    }
    else
    {
        return strdup( vlc_gettext(pl->psz_eng_name) );
    }
}",2937.0,2973.0,1.0,1.0,37.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,char*
1956,36429,LanguageGetCode,1,LanguageGetCode,char* LanguageGetCode (char*),input\es_out.c,"static char *LanguageGetCode( const char *psz_lang )
{
    const iso639_lang_t *pl;

    if( psz_lang == NULL || *psz_lang == '\0' )
        return strdup(""??"");

    for( pl = p_languages; pl->psz_eng_name != NULL; pl++ )
    {
        if( !strcasecmp( pl->psz_eng_name, psz_lang ) ||
            !strcasecmp( pl->psz_iso639_1, psz_lang ) ||
            !strcasecmp( pl->psz_iso639_2T, psz_lang ) ||
            !strcasecmp( pl->psz_iso639_2B, psz_lang ) )
            return strdup( pl->psz_iso639_1 );
    }

    return strdup(""??"");
}",2976.0,2993.0,1.0,1.0,18.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,char*
1957,36434,LanguageSplit,1,LanguageSplit,char** LanguageSplit (char*),input\es_out.c,"static char **LanguageSplit( const char *psz_langs )
{
    char *psz_dup;
    char *psz_parser;
    char **ppsz = NULL;
    int i_psz = 0;

    if( psz_langs == NULL ) return NULL;

    psz_parser = psz_dup = strdup(psz_langs);

    while( psz_parser && *psz_parser )
    {
        char *psz;
        char *psz_code;

        psz = strchr(psz_parser, ',' );
        if( psz ) *psz++ = '\0';

        if( !strcmp( psz_parser, ""any"" ) )
        {
            TAB_APPEND( i_psz, ppsz, strdup(""any"") );
        }
        else if( !strcmp( psz_parser, ""none"" ) )
        {
            TAB_APPEND( i_psz, ppsz, strdup(""none"") );
        }
        else
        {
            psz_code = LanguageGetCode( psz_parser );
            if( strcmp( psz_code, ""??"" ) )
            {
                TAB_APPEND( i_psz, ppsz, psz_code );
            }
            else
            {
                free( psz_code );
            }
        }

        psz_parser = psz;
    }

    if( i_psz )
    {
        TAB_APPEND...",2995.0,3045.0,1.0,1.0,51.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,char**
1958,36439,LanguageArrayIndex,1,LanguageArrayIndex,"int LanguageArrayIndex (char**,char*)",input\es_out.c,"static int LanguageArrayIndex( char **ppsz_langs, const char *psz_lang )
{
    if( !ppsz_langs || !psz_lang )
        return -1;

    for( int i = 0; ppsz_langs[i]; i++ )
    {
        if( !strcasecmp( ppsz_langs[i], psz_lang ) ||
            ( !strcasecmp( ppsz_langs[i], ""any"" ) && strcasecmp( psz_lang, ""none"") ) )
            return i;
        if( !strcasecmp( ppsz_langs[i], ""none"" ) )
            break;
    }

    return -1;
}",3047.0,3062.0,1.0,1.0,16.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
1959,36445,EsOutProgramGetMetaName,1,EsOutProgramGetMetaName,char* EsOutProgramGetMetaName (es_out_pgrm_t*),input\es_out.c,"static char *EsOutProgramGetMetaName( es_out_pgrm_t *p_pgrm )
{
    char *psz = NULL;
    if( p_pgrm->p_meta && vlc_meta_Get( p_pgrm->p_meta, vlc_meta_Title ) )
    {
        if( asprintf( &psz, _(""%s [%s %d]""), vlc_meta_Get( p_pgrm->p_meta, vlc_meta_Title ),
                      _(""Program""), p_pgrm->i_id ) == -1 )
            return NULL;
    }
    else
    {
        if( asprintf( &psz, ""%s %d"", _(""Program""), p_pgrm->i_id ) == -1 )
            return NULL;
    }
    return psz;
}",1193.0,1208.0,1.0,1.0,16.0,0,0,0,0,4,0,1,1,0,0,,0,0,2,1,1,char*
1960,36450,EsInfoCategoryName,1,EsInfoCategoryName,char* EsInfoCategoryName (es_out_id_t*),input\es_out.c,"static char *EsInfoCategoryName( es_out_id_t* es )
{
    char *psz_category;

    if( asprintf( &psz_category, _(""Stream %d""), es->i_meta_id ) == -1 )
        return NULL;

    return psz_category;
}",1225.0,1233.0,1.0,1.0,9.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,char*
1961,36455,EsOutGetClosedCaptionsChannel,1,EsOutGetClosedCaptionsChannel,int EsOutGetClosedCaptionsChannel (es_format_t*),input\es_out.c,"static inline int EsOutGetClosedCaptionsChannel( const es_format_t *p_fmt )
{
    int i_channel;
    if( p_fmt->i_codec == VLC_CODEC_CEA608 && p_fmt->subs.cc.i_channel < 4 )
        i_channel = p_fmt->subs.cc.i_channel;
    else if( p_fmt->i_codec == VLC_CODEC_CEA708 && p_fmt->subs.cc.i_channel < 64 )
        i_channel = p_fmt->subs.cc.i_channel;
    else
        i_channel = -1;
    return i_channel;
}",215.0,225.0,1.0,1.0,11.0,11,6,6,3,0,0,2,2,0,0,,0,0,2,1,1,int
1962,36523,EsFmtIsTeletext,1,EsFmtIsTeletext,bool EsFmtIsTeletext (es_format_t*),input\es_out.c,"static inline bool EsFmtIsTeletext( const es_format_t *p_fmt )
{
    return p_fmt->i_cat == SPU_ES && p_fmt->i_codec == VLC_CODEC_TELETEXT;
}",226.0,229.0,1.0,1.0,4.0,5,3,4,3,2,0,1,1,0,0,,0,0,2,1,1,bool
1963,36540,GetPropsByCat,1,GetPropsByCat,"es_out_es_props_t GetPropsByCat (es_out_sys_t*,int)",input\es_out.c,"static es_out_es_props_t * GetPropsByCat( es_out_sys_t *p_sys, int i_cat )
{
    switch( i_cat )
    {
    case AUDIO_ES:
        return &p_sys->audio;
    case SPU_ES:
        return &p_sys->sub;
    case VIDEO_ES:
        return &p_sys->video;
    }
    return NULL;
}",234.0,246.0,1.0,1.0,13.0,6,2,8,6,1,3,2,2,0,0,,0,3,4,2,2,es_out_es_props_t
1964,36572,EsOutPropsCleanup,1,EsOutPropsCleanup,void EsOutPropsCleanup (es_out_es_props_t*),input\es_out.c,"static void EsOutPropsCleanup( es_out_es_props_t *p_props )
{
    if( p_props->ppsz_language )
    {
        for( int i = 0; p_props->ppsz_language[i]; i++ )
            free( p_props->ppsz_language[i] );
        free( p_props->ppsz_language );
    }
}",248.0,256.0,1.0,1.0,9.0,5,3,5,2,0,3,3,4,2,0,,0,3,2,1,1,void
1965,36605,EsOutPropsInit,1,EsOutPropsInit,"void EsOutPropsInit (es_out_es_props_t*,bool,input_thread_t*,es_out_policy_e,char*,char*,char*,char*)",input\es_out.c,"static void EsOutPropsInit( es_out_es_props_t *p_props,
                            bool autoselect,
                            input_thread_t *p_input,
                            enum es_out_policy_e e_default_policy,
                            const char *psz_trackidvar,
                            const char *psz_trackvar,
                            const char *psz_langvar,
                            const char *psz_debug )
{
    p_props->e_policy = e_default_policy;
    p_props->i_count = 0;
    p_props->b_autoselect = autoselect;
    p_props->i_id = (psz_trackidvar) ? var_GetInteger( p_input, psz_trackidvar ): -1;
    p_props->i_channel = (psz_trackvar) ? var_GetInteger( p_input, psz_trackvar ): -1;
    p_props->i_demux_id = -1;
    p_props->p_main_es = NULL;

    if( !input_priv(p_input)->b_preparsing && psz_langvar )
    {
        char *psz_string = var_GetString( p_input, psz_langvar );
        p_props->ppsz_language = LanguageSplit( psz_string );
        if( p_props->p...",258.0,287.0,1.0,1.0,30.0,29,7,28,10,3,12,4,7,3,2,,0,12,16,8,8,void
1966,36716,input_EsOutNew,1,input_EsOutNew,"es_out_t input_EsOutNew (input_thread_t*,int)",input\es_out.c,"es_out_t *input_EsOutNew( input_thread_t *p_input, int i_rate )
{
    es_out_t     *out = malloc( sizeof( *out ) );
    if( !out )
        return NULL;

    es_out_sys_t *p_sys = calloc( 1, sizeof( *p_sys ) );
    if( !p_sys )
    {
        free( out );
        return NULL;
    }

    out->pf_add     = EsOutAdd;
    out->pf_send    = EsOutSend;
    out->pf_del     = EsOutDel;
    out->pf_control = EsOutControl;
    out->pf_destroy = EsOutDelete;
    out->p_sys      = p_sys;

    vlc_mutex_init_recursive( &p_sys->lock );
    p_sys->p_input = p_input;

    p_sys->b_active = false;
    p_sys->i_mode   = ES_OUT_MODE_NONE;

    TAB_INIT( p_sys->i_pgrm, p_sys->pgrm );

    TAB_INIT( p_sys->i_es, p_sys->es );

    /* */
    EsOutPropsInit( &p_sys->video, true, p_input, ES_OUT_ES_POLICY_SIMULTANEOUS,
                    NULL, NULL, NULL, NULL );
    EsOutPropsInit( &p_sys->audio, true, p_input, ES_OUT_ES_POLICY_EXCLUSIVE,
                    ""audio-track-id"", ""audio-track"", ""audio-language""...",292.0,341.0,1.0,1.0,50.0,53,7,55,12,0,21,3,3,0,4,,0,17,4,2,2,es_out_t
1967,37081,EsOutGetWakeup,1,EsOutGetWakeup,mtime_t EsOutGetWakeup (es_out_t*),input\es_out.c,"static mtime_t EsOutGetWakeup( es_out_t *out )
{
    es_out_sys_t   *p_sys = out->p_sys;
    input_thread_t *p_input = p_sys->p_input;

    if( !p_sys->p_pgrm )
        return 0;

    /* We do not have a wake up date if the input cannot have its speed
     * controlled or sout is imposing its own or while buffering
     *
     * FIXME for !input_priv(p_input)->b_can_pace_control a wake-up time is still needed
     * to avoid too heavy buffering */
    if( !input_priv(p_input)->b_can_pace_control ||
        input_priv(p_input)->b_out_pace_control ||
        p_sys->b_buffering )
        return 0;

    return input_clock_GetWakeup( p_sys->p_pgrm->p_clock );
}",398.0,417.0,1.0,1.0,20.0,14,4,9,3,1,7,3,3,4,3,,0,6,2,1,1,mtime_t
1968,37134,EsOutGetFromID,1,EsOutGetFromID,"es_out_id_t EsOutGetFromID (es_out_t*,int)",input\es_out.c,"static es_out_id_t *EsOutGetFromID( es_out_t *out, int i_id )
{
    if( i_id < 0 )
    {
        /* Special HACK, -i_id is the cat of the stream */
        return es_cat - i_id;
    }

    for( int i = 0; i < out->p_sys->i_es; i++ )
    {
        if( out->p_sys->es[i]->i_id == i_id )
            return out->p_sys->es[i];
    }
    return NULL;
}",421.0,435.0,1.0,1.0,15.0,14,6,12,5,3,1,4,5,0,0,,0,1,4,2,2,es_out_id_t
1969,37188,EsOutDecodersIsEmpty,1,EsOutDecodersIsEmpty,bool EsOutDecodersIsEmpty (es_out_t*),input\es_out.c,"static bool EsOutDecodersIsEmpty( es_out_t *out )
{
    es_out_sys_t      *p_sys = out->p_sys;

    if( p_sys->b_buffering && p_sys->p_pgrm )
    {
        EsOutDecodersStopBuffering( out, true );
        if( p_sys->b_buffering )
            return true;
    }

    for( int i = 0; i < p_sys->i_es; i++ )
    {
        es_out_id_t *es = p_sys->es[i];

        if( es->p_dec && !input_DecoderIsEmpty( es->p_dec ) )
            return false;
        if( es->p_dec_record && !input_DecoderIsEmpty( es->p_dec_record ) )
            return false;
    }
    return true;
}",437.0,458.0,1.0,1.0,22.0,20,6,21,6,1,12,6,9,10,3,,0,11,2,1,1,bool
1970,37268,EsOutSetDelay,1,EsOutSetDelay,"void EsOutSetDelay (es_out_t*,int,int64_t)",input\es_out.c,"static void EsOutSetDelay( es_out_t *out, int i_cat, int64_t i_delay )
{
    es_out_sys_t *p_sys = out->p_sys;

    if( i_cat == AUDIO_ES )
        p_sys->i_audio_delay = i_delay;
    else if( i_cat == SPU_ES )
        p_sys->i_spu_delay = i_delay;

    for( int i = 0; i < p_sys->i_es; i++ )
        EsOutDecoderChangeDelay( out, p_sys->es[i] );
}",460.0,471.0,1.0,1.0,12.0,8,4,9,6,1,2,3,3,1,0,,0,2,6,3,3,void
1971,37568,EsOutChangePause,1,EsOutChangePause,"void EsOutChangePause (es_out_t*,bool,mtime_t)",input\es_out.c,"static void EsOutChangePause( es_out_t *out, bool b_paused, mtime_t i_date )
{
    es_out_sys_t *p_sys = out->p_sys;

    /* XXX the order is important */
    if( b_paused )
    {
        EsOutDecodersChangePause( out, true, i_date );
        EsOutProgramChangePause( out, true, i_date );
    }
    else
    {
        if( p_sys->i_buffering_extra_initial > 0 )
        {
            mtime_t i_stream_start;
            mtime_t i_system_start;
            mtime_t i_stream_duration;
            mtime_t i_system_duration;
            int i_ret;
            i_ret = input_clock_GetState( p_sys->p_pgrm->p_clock,
                                          &i_stream_start, &i_system_start,
                                          &i_stream_duration, &i_system_duration );
            if( !i_ret )
            {
                /* FIXME pcr != exactly what wanted */
                const mtime_t i_used = /*(i_stream_duration - input_priv(p_sys->p_input)->i_pts_delay)*/ p_sys->i_buffering_extra_sys...",555.0,594.0,1.0,1.0,40.0,6,2,13,5,1,4,2,2,0,2,,0,2,6,3,3,void
1972,37674,EsOutChangeRate,1,EsOutChangeRate,"void EsOutChangeRate (es_out_t*,int)",input\es_out.c,"static void EsOutChangeRate( es_out_t *out, int i_rate )
{
    es_out_sys_t      *p_sys = out->p_sys;

    p_sys->i_rate = i_rate;
    EsOutProgramsChangeRate( out );
}",596.0,602.0,1.0,1.0,7.0,4,2,5,3,1,2,1,1,0,1,,0,1,4,2,2,void
1973,37693,EsOutChangePosition,1,EsOutChangePosition,void EsOutChangePosition (es_out_t*),input\es_out.c,"static void EsOutChangePosition( es_out_t *out )
{
    es_out_sys_t      *p_sys = out->p_sys;

    input_SendEventCache( p_sys->p_input, 0.0 );

    for( int i = 0; i < p_sys->i_es; i++ )
    {
        es_out_id_t *p_es = p_sys->es[i];

        if( p_es->p_dec != NULL )
        {
            input_DecoderFlush( p_es->p_dec );
            if( !p_sys->b_buffering )
            {
                input_DecoderStartWait( p_es->p_dec );
                if( p_es->p_dec_record != NULL )
                    input_DecoderStartWait( p_es->p_dec_record );
            }
        }
        p_es->i_pts_level = VLC_TS_INVALID;
    }

    for( int i = 0; i < p_sys->i_pgrm; i++ ) {
        input_clock_Reset( p_sys->pgrm[i]->p_clock );
        p_sys->pgrm[i]->i_last_pcr = VLC_TS_INVALID;
    }

    p_sys->b_buffering = true;
    p_sys->i_buffering_extra_initial = 0;
    p_sys->i_buffering_extra_stream = 0;
    p_sys->i_buffering_extra_system = 0;
    p_sys->i_preroll_end = -1;
    p_sys->i_prev_stream_...",604.0,638.0,1.0,1.0,35.0,44,7,34,7,2,24,6,12,5,5,,0,19,2,1,1,void
1974,38206,EsOutIsExtraBufferingAllowed,1,EsOutIsExtraBufferingAllowed,bool EsOutIsExtraBufferingAllowed (es_out_t*),input\es_out.c,"static bool EsOutIsExtraBufferingAllowed( es_out_t *out )
{
    es_out_sys_t *p_sys = out->p_sys;

    size_t i_size = 0;
    for( int i = 0; i < p_sys->i_es; i++ )
    {
        es_out_id_t *p_es = p_sys->es[i];

        if( p_es->p_dec )
            i_size += input_DecoderGetFifoSize( p_es->p_dec );
        if( p_es->p_dec_record )
            i_size += input_DecoderGetFifoSize( p_es->p_dec_record );
    }
    //msg_Info( out, ""----- EsOutIsExtraBufferingAllowed =% 5d KiB -- "", i_size / 1024 );

    /* TODO maybe we want to be able to tune it ? */
#if defined(OPTIMIZE_MEMORY)
    const size_t i_level_high = 512*1024;  /* 0.5 MiB */
#else
    const size_t i_level_high = 10*1024*1024; /* 10 MiB */
#endif
    return i_size < i_level_high;
}",750.0,773.0,1.0,1.0,24.0,19,6,18,6,1,8,4,6,3,2,,0,6,2,1,1,bool
1975,38417,EsOutFrameNext,1,EsOutFrameNext,void EsOutFrameNext (es_out_t*),input\es_out.c,"static void EsOutFrameNext( es_out_t *out )
{
    es_out_sys_t *p_sys = out->p_sys;
    es_out_id_t *p_es_video = NULL;

    if( p_sys->b_buffering )
    {
        msg_Warn( p_sys->p_input, ""buffering, ignoring 'frame next'"" );
        return;
    }

    assert( p_sys->b_paused );

    for( int i = 0; i < p_sys->i_es; i++ )
    {
        es_out_id_t *p_es = p_sys->es[i];

        if( p_es->fmt.i_cat == VIDEO_ES && p_es->p_dec )
        {
            p_es_video = p_es;
            break;
        }
    }

    if( !p_es_video )
    {
        msg_Warn( p_sys->p_input, ""No video track selected, ignoring 'frame next'"" );
        return;
    }

    mtime_t i_duration;
    input_DecoderFrameNext( p_es_video->p_dec, &i_duration );

    msg_Dbg( out->p_sys->p_input, ""EsOutFrameNext consummed %d ms"", (int)(i_duration/1000) );

    if( i_duration <= 0 )
        i_duration = 40*1000;

    /* FIXME it is not a clean way ? */
    if( p_sys->i_buffering_extra_initial <= 0 )
    {
        mtime_t i_...",808.0,876.0,1.0,1.0,69.0,70,17,54,16,1,28,9,10,5,3,,0,27,2,1,1,void
1976,38629,EsOutGetBuffering,1,EsOutGetBuffering,mtime_t EsOutGetBuffering (es_out_t*),input\es_out.c,"static mtime_t EsOutGetBuffering( es_out_t *out )
{
    es_out_sys_t *p_sys = out->p_sys;
    mtime_t i_stream_duration, i_system_start;

    if( !p_sys->p_pgrm )
        return 0;
    else
    {
        mtime_t i_stream_start, i_system_duration;

        if( input_clock_GetState( p_sys->p_pgrm->p_clock,
                                  &i_stream_start, &i_system_start,
                                  &i_stream_duration, &i_system_duration ) )
            return 0;
    }

    mtime_t i_delay;

    if( p_sys->b_buffering && p_sys->i_buffering_extra_initial <= 0 )
    {
        i_delay = i_stream_duration;
    }
    else
    {
        mtime_t i_system_duration;

        if( p_sys->b_paused )
        {
            i_system_duration = p_sys->i_pause_date  - i_system_start;
            if( p_sys->i_buffering_extra_initial > 0 )
                i_system_duration += p_sys->i_buffering_extra_system - p_sys->i_buffering_extra_initial;
        }
        else
        {
            i_system_...",877.0,921.0,1.0,1.0,45.0,10,6,9,4,1,3,4,4,3,0,,0,3,2,1,1,mtime_t
1977,38753,EsOutESVarUpdateGeneric,1,EsOutESVarUpdateGeneric,"void EsOutESVarUpdateGeneric (es_out_t*,int,es_format_t*,char*,bool)",input\es_out.c,"static void EsOutESVarUpdateGeneric( es_out_t *out, int i_id,
                                     const es_format_t *fmt, const char *psz_language,
                                     bool b_delete )
{
    es_out_sys_t      *p_sys = out->p_sys;
    input_thread_t    *p_input = p_sys->p_input;
    vlc_value_t       val, text;

    if( b_delete )
    {
        if( EsFmtIsTeletext( fmt ) )
            input_SendEventTeletextDel( p_sys->p_input, i_id );

        input_SendEventEsDel( p_input, fmt->i_cat, i_id );
        return;
    }

    /* Get the number of ES already added */
    const char *psz_var;
    if( fmt->i_cat == AUDIO_ES )
        psz_var = ""audio-es"";
    else if( fmt->i_cat == VIDEO_ES )
        psz_var = ""video-es"";
    else
        psz_var = ""spu-es"";

    var_Change( p_input, psz_var, VLC_VAR_CHOICESCOUNT, &val, NULL );
    if( val.i_int == 0 )
    {
        vlc_value_t val2;

        /* First one, we need to add the ""Disable"" choice */
        val2.i_int = -1; text....",923.0,997.0,1.0,1.0,75.0,50,12,52,16,1,11,9,13,2,8,,0,5,10,5,5,void
1978,38988,EsOutESVarUpdate,1,EsOutESVarUpdate,"void EsOutESVarUpdate (es_out_t*,es_out_id_t*,bool)",input\es_out.c,"static void EsOutESVarUpdate( es_out_t *out, es_out_id_t *es,
                              bool b_delete )
{
    EsOutESVarUpdateGeneric( out, es->i_id, &es->fmt, es->psz_language, b_delete );
}",999.0,1003.0,1.0,1.0,5.0,4,2,5,3,2,4,1,1,0,1,,0,3,6,3,3,void
1979,39008,EsOutIsProgramVisible,1,EsOutIsProgramVisible,"bool EsOutIsProgramVisible (es_out_t*,int)",input\es_out.c,"static bool EsOutIsProgramVisible( es_out_t *out, int i_group )
{
    return out->p_sys->i_group_id == 0 || out->p_sys->i_group_id == i_group;
}",1005.0,1008.0,1.0,1.0,4.0,7,3,3,2,4,0,1,1,0,0,,0,0,4,2,2,bool
1980,39030,EsOutProgramSelect,1,EsOutProgramSelect,"void EsOutProgramSelect (es_out_t*,es_out_pgrm_t*)",input\es_out.c,"static void EsOutProgramSelect( es_out_t *out, es_out_pgrm_t *p_pgrm )
{
    es_out_sys_t      *p_sys = out->p_sys;
    input_thread_t    *p_input = p_sys->p_input;
    int               i;

    if( p_sys->p_pgrm == p_pgrm )
        return; /* Nothing to do */

    if( p_sys->p_pgrm )
    {
        es_out_pgrm_t *old = p_sys->p_pgrm;
        msg_Dbg( p_input, ""unselecting program id=%d"", old->i_id );

        for( i = 0; i < p_sys->i_es; i++ )
        {
            if( p_sys->es[i]->p_pgrm == old && EsIsSelected( p_sys->es[i] ) &&
                p_sys->i_mode != ES_OUT_MODE_ALL )
                EsUnselect( out, p_sys->es[i], true );
        }

        p_sys->audio.p_main_es = NULL;
        p_sys->video.p_main_es = NULL;
        p_sys->sub.p_main_es = NULL;
    }

    msg_Dbg( p_input, ""selecting program id=%d"", p_pgrm->i_id );

    /* Mark it selected */
    p_pgrm->b_selected = true;

    /* Switch master stream */
    p_sys->p_pgrm = p_pgrm;

    /* Update ""program"" */
    input...",1013.0,1086.0,1.0,1.0,74.0,74,10,83,16,2,51,8,12,11,20,,0,33,4,2,2,void
1981,39296,EsOutProgramAdd,1,EsOutProgramAdd,"es_out_pgrm_t EsOutProgramAdd (es_out_t*,int)",input\es_out.c,"static es_out_pgrm_t *EsOutProgramAdd( es_out_t *out, int i_group )
{
    es_out_sys_t      *p_sys = out->p_sys;
    input_thread_t    *p_input = p_sys->p_input;

    es_out_pgrm_t *p_pgrm = malloc( sizeof( es_out_pgrm_t ) );
    if( !p_pgrm )
        return NULL;

    /* Init */
    p_pgrm->i_id = i_group;
    p_pgrm->i_es = 0;
    p_pgrm->b_selected = false;
    p_pgrm->b_scrambled = false;
    p_pgrm->i_last_pcr = VLC_TS_INVALID;
    p_pgrm->p_meta = NULL;
    p_pgrm->p_clock = input_clock_New( p_sys->i_rate );
    if( !p_pgrm->p_clock )
    {
        free( p_pgrm );
        return NULL;
    }
    if( p_sys->b_paused )
        input_clock_ChangePause( p_pgrm->p_clock, p_sys->b_paused, p_sys->i_pause_date );
    input_clock_SetJitter( p_pgrm->p_clock, p_sys->i_pts_delay, p_sys->i_cr_average );

    /* Append it */
    TAB_APPEND( p_sys->i_pgrm, p_sys->pgrm, p_pgrm );

    /* Update ""program"" variable */
    if( EsOutIsProgramVisible( out, i_group ) )
        input_SendEventProgram...",1091.0,1128.0,1.0,1.0,38.0,41,7,46,9,2,29,6,6,6,6,,0,25,4,2,2,es_out_pgrm_t
1982,39439,EsOutProgramDel,1,EsOutProgramDel,"int EsOutProgramDel (es_out_t*,int)",input\es_out.c,"static int EsOutProgramDel( es_out_t *out, int i_group )
{
    es_out_sys_t      *p_sys = out->p_sys;
    input_thread_t    *p_input = p_sys->p_input;
    es_out_pgrm_t     *p_pgrm = NULL;
    int               i;

    for( i = 0; i < p_sys->i_pgrm; i++ )
    {
        if( p_sys->pgrm[i]->i_id == i_group )
        {
            p_pgrm = p_sys->pgrm[i];
            break;
        }
    }

    if( p_pgrm == NULL )
        return VLC_EGENERIC;

    if( p_pgrm->i_es )
    {
        msg_Dbg( p_input, ""can't delete program %d which still has %i ES"",
                 i_group, p_pgrm->i_es );
        return VLC_EGENERIC;
    }

    TAB_REMOVE( p_sys->i_pgrm, p_sys->pgrm, p_pgrm );

    /* If program is selected we need to unselect it */
    if( p_sys->p_pgrm == p_pgrm )
        p_sys->p_pgrm = NULL;

    input_clock_Delete( p_pgrm->p_clock );

    if( p_pgrm->p_meta )
        vlc_meta_Delete( p_pgrm->p_meta );
    free( p_pgrm );

    /* Update ""program"" variable */
    input_SendEventProgr...",1133.0,1175.0,1.0,1.0,43.0,27,5,37,9,1,16,8,8,5,3,,0,13,4,2,2,int
1983,39555,EsOutProgramFind,1,EsOutProgramFind,"es_out_pgrm_t EsOutProgramFind (es_out_t*,int)",input\es_out.c,"static es_out_pgrm_t *EsOutProgramFind( es_out_t *p_out, int i_group )
{
    es_out_sys_t *p_sys = p_out->p_sys;

    for( int i = 0; i < p_sys->i_pgrm; i++ )
    {
        if( p_sys->pgrm[i]->i_id == i_group )
            return p_sys->pgrm[i];
    }
    return EsOutProgramAdd( p_out, i_group );
}",1179.0,1189.0,1.0,1.0,11.0,11,5,12,4,4,4,3,4,2,1,,0,3,4,2,2,es_out_pgrm_t
1984,39664,EsOutProgramGetProgramName,1,EsOutProgramGetProgramName,char* EsOutProgramGetProgramName (es_out_pgrm_t*),input\es_out.c,"static char *EsOutProgramGetProgramName( es_out_pgrm_t *p_pgrm )
{
    char *psz = NULL;
    if( p_pgrm->p_meta && vlc_meta_Get( p_pgrm->p_meta, vlc_meta_Title ) )
    {
        return strdup( vlc_meta_Get( p_pgrm->p_meta, vlc_meta_Title ) );
    }
    else
    {
        if( asprintf( &psz, ""%s %d"", _(""Program""), p_pgrm->i_id ) == -1 )
            return NULL;
    }
    return psz;
}",1210.0,1223.0,1.0,1.0,14.0,5,3,8,4,1,5,2,2,3,2,,0,4,2,1,1,char*
1985,39734,EsOutProgramMeta,1,EsOutProgramMeta,"void EsOutProgramMeta (es_out_t*,int,vlc_meta_t*)",input\es_out.c,"static void EsOutProgramMeta( es_out_t *out, int i_group, const vlc_meta_t *p_meta )
{
    es_out_sys_t      *p_sys = out->p_sys;
    es_out_pgrm_t     *p_pgrm;
    input_thread_t    *p_input = p_sys->p_input;
    const char        *psz_title = NULL;
    const char        *psz_provider = NULL;
    int i;

    msg_Dbg( p_input, ""EsOutProgramMeta: number=%d"", i_group );

    /* Check against empty meta data (empty for what we handle) */
    if( !vlc_meta_Get( p_meta, vlc_meta_Title) &&
        !vlc_meta_Get( p_meta, vlc_meta_ESNowPlaying) &&
        !vlc_meta_Get( p_meta, vlc_meta_Publisher) )
    {
        return;
    }

    if( i_group < 0 )
    {
        EsOutGlobalMeta( out, p_meta );
        return;
    }

    /* Find program */
    if( !EsOutIsProgramVisible( out, i_group ) )
        return;
    p_pgrm = EsOutProgramFind( out, i_group );
    if( !p_pgrm )
        return;

    if( p_pgrm->p_meta )
    {
        const char *psz_current_title = vlc_meta_Get( p_pgrm->p_meta, vlc_met...",1235.0,1355.0,1.0,1.0,121.0,60,12,123,22,1,40,22,33,9,30,,0,27,6,3,3,void
1986,40052,EsOutProgramEpgEvent,1,EsOutProgramEpgEvent,"void EsOutProgramEpgEvent (es_out_t*,int,vlc_epg_event_t*)",input\es_out.c,"static void EsOutProgramEpgEvent( es_out_t *out, int i_group, const vlc_epg_event_t *p_event )
{
    es_out_sys_t      *p_sys = out->p_sys;
    input_thread_t    *p_input = p_sys->p_input;
    input_item_t      *p_item = input_priv(p_input)->p_item;
    es_out_pgrm_t     *p_pgrm;

    /* Find program */
    if( !EsOutIsProgramVisible( out, i_group ) )
        return;
    p_pgrm = EsOutProgramFind( out, i_group );
    if( !p_pgrm )
        return;

    input_item_SetEpgEvent( p_item, p_event );
}",1357.0,1372.0,1.0,1.0,16.0,9,3,14,7,1,5,3,3,1,4,,0,4,6,3,3,void
1987,40099,EsOutProgramEpg,1,EsOutProgramEpg,"void EsOutProgramEpg (es_out_t*,int,vlc_epg_t*)",input\es_out.c,"static void EsOutProgramEpg( es_out_t *out, int i_group, const vlc_epg_t *p_epg )
{
    es_out_sys_t      *p_sys = out->p_sys;
    input_thread_t    *p_input = p_sys->p_input;
    input_item_t      *p_item = input_priv(p_input)->p_item;
    es_out_pgrm_t     *p_pgrm;
    char *psz_cat;

    /* Find program */
    if( !EsOutIsProgramVisible( out, i_group ) )
        return;
    p_pgrm = EsOutProgramFind( out, i_group );
    if( !p_pgrm )
        return;

    /* Update info */
    psz_cat = EsOutProgramGetMetaName( p_pgrm );
    msg_Dbg( p_input, ""EsOutProgramEpg: number=%d name=%s"", i_group, psz_cat );

    /* Merge EPG */
    vlc_epg_t epg;

    epg = *p_epg;
    epg.psz_name = EsOutProgramGetProgramName( p_pgrm );

    input_item_SetEpg( p_item, &epg, p_sys->p_pgrm && (p_epg->i_source_id == p_sys->p_pgrm->i_id) );
    input_SendEventMetaEpg( p_sys->p_input );

    free( epg.psz_name );

    /* Update now playing */
    if( p_epg->b_present && p_pgrm->p_meta &&
       ( p_epg->p_cur...",1374.0,1450.0,1.0,1.0,77.0,65,12,72,16,1,30,11,16,6,16,,0,22,6,3,3,void
1988,40343,EsOutEpgTime,1,EsOutEpgTime,"void EsOutEpgTime (es_out_t*,int64_t)",input\es_out.c,"static void EsOutEpgTime( es_out_t *out, int64_t time )
{
    es_out_sys_t      *p_sys = out->p_sys;
    input_thread_t    *p_input = p_sys->p_input;
    input_item_t      *p_item = input_priv(p_input)->p_item;

    input_item_SetEpgTime( p_item, time );
}",1452.0,1459.0,1.0,1.0,8.0,6,2,8,5,1,3,1,1,0,2,,0,2,4,2,2,void
1989,40371,EsOutProgramUpdateScrambled,1,EsOutProgramUpdateScrambled,"void EsOutProgramUpdateScrambled (es_out_t*,es_out_pgrm_t*)",input\es_out.c,"static void EsOutProgramUpdateScrambled( es_out_t *p_out, es_out_pgrm_t *p_pgrm )
{
    es_out_sys_t    *p_sys = p_out->p_sys;
    input_thread_t  *p_input = p_sys->p_input;
    bool b_scrambled = false;

    for( int i = 0; i < p_sys->i_es; i++ )
    {
        if( p_sys->es[i]->p_pgrm == p_pgrm && p_sys->es[i]->b_scrambled )
        {
            b_scrambled = true;
            break;
        }
    }
    if( !p_pgrm->b_scrambled == !b_scrambled )
        return;

    p_pgrm->b_scrambled = b_scrambled;
    char *psz_cat = EsOutProgramGetMetaName( p_pgrm );

    if( b_scrambled )
        input_Control( p_input, INPUT_ADD_INFO, psz_cat, _(""Scrambled""), _(""Yes"") );
    else
        input_Control( p_input, INPUT_DEL_INFO, psz_cat, _(""Scrambled"") );
    free( psz_cat );

    input_SendEventProgramScrambled( p_input, p_pgrm->i_id, b_scrambled );
}",1461.0,1488.0,1.0,1.0,28.0,25,7,30,10,2,10,6,6,4,3,,0,8,4,2,2,void
1990,40656,EsOutAddSlave,1,EsOutAddSlave,"es_out_id_t EsOutAddSlave (es_out_t*,es_format_t*,es_out_id_t*)",input\es_out.c,"static es_out_id_t *EsOutAddSlave( es_out_t *out, const es_format_t *fmt, es_out_id_t *p_master )
{
    es_out_sys_t      *p_sys = out->p_sys;
    input_thread_t    *p_input = p_sys->p_input;

    if( fmt->i_group < 0 )
    {
        msg_Err( p_input, ""invalid group number"" );
        return NULL;
    }

    es_out_id_t   *es = malloc( sizeof( *es ) );
    es_out_pgrm_t *p_pgrm;
    int i;

    if( !es )
        return NULL;

    vlc_mutex_lock( &p_sys->lock );

    /* Search the program */
    p_pgrm = EsOutProgramFind( out, fmt->i_group );
    if( !p_pgrm )
    {
        vlc_mutex_unlock( &p_sys->lock );
        free( es );
        return NULL;
    }

    /* Increase ref count for program */
    p_pgrm->i_es++;

    /* Set up ES */
    es->p_pgrm = p_pgrm;
    es_format_Copy( &es->fmt, fmt );
    if( es->fmt.i_id < 0 )
        es->fmt.i_id = p_sys->i_id;
    if( !es->fmt.i_original_fourcc )
        es->fmt.i_original_fourcc = es->fmt.i_codec;

    es->i_id = es->fmt.i_id;
    es->...",1543.0,1666.0,1.0,1.0,124.0,217,13,131,16,1,89,18,21,12,21,,0,77,6,3,3,es_out_id_t
1991,41301,EsCreateDecoder,1,EsCreateDecoder,"void EsCreateDecoder (es_out_t*,es_out_id_t*)",input\es_out.c,"static void EsCreateDecoder( es_out_t *out, es_out_id_t *p_es )
{
    es_out_sys_t   *p_sys = out->p_sys;
    input_thread_t *p_input = p_sys->p_input;

    p_es->p_dec = input_DecoderNew( p_input, &p_es->fmt, p_es->p_pgrm->p_clock, input_priv(p_input)->p_sout );
    if( p_es->p_dec )
    {
        if( p_sys->b_buffering )
            input_DecoderStartWait( p_es->p_dec );

        if( !p_es->p_master && p_sys->p_sout_record )
        {
            p_es->p_dec_record = input_DecoderNew( p_input, &p_es->fmt, p_es->p_pgrm->p_clock, p_sys->p_sout_record );
            if( p_es->p_dec_record && p_sys->b_buffering )
                input_DecoderStartWait( p_es->p_dec_record );
        }
    }

    EsOutDecoderChangeDelay( out, p_es );
}",1694.0,1714.0,1.0,1.0,21.0,29,5,24,4,3,22,5,9,6,6,,0,19,4,2,2,void
1992,41396,EsDestroyDecoder,1,EsDestroyDecoder,"void EsDestroyDecoder (es_out_t*,es_out_id_t*)",input\es_out.c,"static void EsDestroyDecoder( es_out_t *out, es_out_id_t *p_es )
{
    VLC_UNUSED(out);

    if( !p_es->p_dec )
        return;

    input_DecoderDelete( p_es->p_dec );
    p_es->p_dec = NULL;

    if( p_es->p_dec_record )
    {
        input_DecoderDelete( p_es->p_dec_record );
        p_es->p_dec_record = NULL;
    }
}",1715.0,1730.0,1.0,1.0,16.0,9,3,9,3,3,8,3,3,2,2,,0,6,4,2,2,void
1993,41644,EsDeleteCCChannels,1,EsDeleteCCChannels,"void EsDeleteCCChannels (es_out_t*,es_out_id_t*)",input\es_out.c,"static void EsDeleteCCChannels( es_out_t *out, es_out_id_t *parent )
{
    es_out_sys_t   *p_sys = out->p_sys;
    input_thread_t *p_input = p_sys->p_input;

    if( parent->cc.type == 0 )
        return;

    const int i_spu_id = var_GetInteger( p_input, ""spu-es"");

    uint64_t i_bitmap = parent->cc.i_bitmap;
    for( int i = 0; i_bitmap > 0; i++, i_bitmap >>= 1 )
    {
        if( (i_bitmap & 1) == 0 || !parent->cc.pp_es[i] )
            continue;

        if( i_spu_id == parent->cc.pp_es[i]->i_id )
        {
            /* Force unselection of the CC */
            input_SendEventEsSelect( p_input, SPU_ES, -1 );
        }
        EsOutDel( out, parent->cc.pp_es[i] );
    }

    parent->cc.i_bitmap = 0;
    parent->cc.type = 0;
}",1798.0,1824.0,1.0,1.0,27.0,35,10,24,8,0,3,6,7,0,2,,0,1,4,2,2,void
1994,42334,EsOutCreateCCChannels,1,EsOutCreateCCChannels,"void EsOutCreateCCChannels (es_out_t*,vlc_fourcc_t,uint64_t,char*,es_out_id_t*)",input\es_out.c,"static void EsOutCreateCCChannels( es_out_t *out, vlc_fourcc_t codec, uint64_t i_bitmap,
                                   const char *psz_descfmt, es_out_id_t *parent )
{
    es_out_sys_t   *p_sys = out->p_sys;
    input_thread_t *p_input = p_sys->p_input;

    /* Only one type of captions is allowed ! */
    if( parent->cc.type && parent->cc.type != codec )
        return;

    uint64_t i_existingbitmap = parent->cc.i_bitmap;
    for( int i = 0; i_bitmap > 0; i++, i_bitmap >>= 1, i_existingbitmap >>= 1 )
    {
        es_format_t fmt;

        if( (i_bitmap & 1) == 0 || (i_existingbitmap & 1) )
            continue;

        msg_Dbg( p_input, ""Adding CC track %d for es[%d]"", 1+i, parent->i_id );

        es_format_Init( &fmt, SPU_ES, codec );
        fmt.subs.cc.i_channel = i;
        fmt.i_group = parent->fmt.i_group;
        if( asprintf( &fmt.psz_description, psz_descfmt, 1 + i ) == -1 )
            fmt.psz_description = NULL;

        es_out_id_t **pp_es = &parent->cc.pp_es[i...",2008.0,2046.0,1.0,1.0,39.0,56,15,45,14,0,8,7,9,1,4,,0,5,10,5,5,void
1995,43141,EsOutControlLocked,1,EsOutControlLocked,"int EsOutControlLocked (es_out_t*,int,va_list)",input\es_out.c,"static int EsOutControlLocked( es_out_t *out, int i_query, va_list args )
{
    es_out_sys_t *p_sys = out->p_sys;

    switch( i_query )
    {
    case ES_OUT_SET_ES_STATE:
    {
        es_out_id_t *es = va_arg( args, es_out_id_t * );
        bool b = va_arg( args, int );
        if( b && !EsIsSelected( es ) )
        {
            EsSelect( out, es );
            return EsIsSelected( es ) ? VLC_SUCCESS : VLC_EGENERIC;
        }
        else if( !b && EsIsSelected( es ) )
        {
            EsUnselect( out, es, es->p_pgrm == p_sys->p_pgrm );
            return VLC_SUCCESS;
        }
        return VLC_SUCCESS;
    }

    case ES_OUT_GET_ES_STATE:
    {
        es_out_id_t *es = va_arg( args, es_out_id_t * );
        bool *pb = va_arg( args, bool * );

        *pb = EsIsSelected( es );
        return VLC_SUCCESS;
    }

    case ES_OUT_SET_ES_CAT_POLICY:
    {
        enum es_format_category_e i_cat = va_arg( args, enum es_format_category_e );
        enum es_out_policy_e i_pol =...",2270.0,2921.0,1.0,20.0,652.0,268,22,452,114,0,129,57,123,32,58,,0,91,6,3,3,int
1996,46695,es_out_SetMode,1,es_out_SetMode,"void es_out_SetMode (es_out_t*,int)",input\es_out.h,"static inline void es_out_SetMode( es_out_t *p_out, int i_mode )
{
    int i_ret = es_out_Control( p_out, ES_OUT_SET_MODE, i_mode );
    assert( !i_ret );
}",93.0,97.0,1.0,1.0,5.0,2,2,5,4,1,0,1,1,0,0,,0,0,4,2,2,void
1997,46711,es_out_GetWakeup,1,es_out_GetWakeup,mtime_t es_out_GetWakeup (es_out_t*),input\es_out.h,"static inline mtime_t es_out_GetWakeup( es_out_t *p_out )
{
    mtime_t i_wu;
    int i_ret = es_out_Control( p_out, ES_OUT_GET_WAKE_UP, &i_wu );

    assert( !i_ret );
    return i_wu;
}",98.0,105.0,1.0,1.0,8.0,3,3,6,4,0,0,1,1,0,0,,0,0,2,1,1,mtime_t
1998,46730,es_out_GetBuffering,1,es_out_GetBuffering,bool es_out_GetBuffering (es_out_t*),input\es_out.h,"static inline bool es_out_GetBuffering( es_out_t *p_out )
{
    bool b;
    int i_ret = es_out_Control( p_out, ES_OUT_GET_BUFFERING, &b );

    assert( !i_ret );
    return b;
}",106.0,113.0,1.0,1.0,8.0,3,3,6,4,0,0,1,1,0,0,,0,0,2,1,1,bool
1999,46749,es_out_GetEmpty,1,es_out_GetEmpty,bool es_out_GetEmpty (es_out_t*),input\es_out.h,"static inline bool es_out_GetEmpty( es_out_t *p_out )
{
    bool b;
    int i_ret = es_out_Control( p_out, ES_OUT_GET_EMPTY, &b );

    assert( !i_ret );
    return b;
}",114.0,121.0,1.0,1.0,8.0,3,3,6,4,0,0,1,1,0,0,,0,0,2,1,1,bool
2000,46768,es_out_SetDelay,1,es_out_SetDelay,"void es_out_SetDelay (es_out_t*,int,mtime_t)",input\es_out.h,"static inline void es_out_SetDelay( es_out_t *p_out, int i_cat, mtime_t i_delay )
{
    int i_ret = es_out_Control( p_out, ES_OUT_SET_DELAY, i_cat, i_delay );
    assert( !i_ret );
}",122.0,126.0,1.0,1.0,5.0,2,2,6,5,2,0,1,1,0,0,,0,0,6,3,3,void
2001,46786,es_out_SetRecordState,1,es_out_SetRecordState,"int es_out_SetRecordState (es_out_t*,bool)",input\es_out.h,"static inline int es_out_SetRecordState( es_out_t *p_out, bool b_record )
{
    return es_out_Control( p_out, ES_OUT_SET_RECORD_STATE, b_record );
}",127.0,130.0,1.0,1.0,4.0,0,0,3,3,0,0,1,1,0,0,,0,0,4,2,2,int
2002,46797,es_out_SetPauseState,1,es_out_SetPauseState,"int es_out_SetPauseState (es_out_t*,bool,bool,mtime_t)",input\es_out.h,"static inline int es_out_SetPauseState( es_out_t *p_out, bool b_source_paused, bool b_paused, mtime_t i_date )
{
    return es_out_Control( p_out, ES_OUT_SET_PAUSE_STATE, b_source_paused, b_paused, i_date );
}",131.0,134.0,1.0,1.0,4.0,0,0,5,5,2,0,1,1,0,0,,0,0,8,4,4,int
2003,46812,es_out_SetRate,1,es_out_SetRate,"int es_out_SetRate (es_out_t*,int,int)",input\es_out.h,"static inline int es_out_SetRate( es_out_t *p_out, int i_source_rate, int i_rate )
{
    return es_out_Control( p_out, ES_OUT_SET_RATE, i_source_rate, i_rate );
}",135.0,138.0,1.0,1.0,4.0,0,0,4,4,1,0,1,1,0,0,,0,0,6,3,3,int
2004,46825,es_out_SetTime,1,es_out_SetTime,"int es_out_SetTime (es_out_t*,mtime_t)",input\es_out.h,"static inline int es_out_SetTime( es_out_t *p_out, mtime_t i_date )
{
    return es_out_Control( p_out, ES_OUT_SET_TIME, i_date );
}",139.0,142.0,1.0,1.0,4.0,0,0,3,3,1,0,1,1,0,0,,0,0,4,2,2,int
2005,46836,es_out_SetFrameNext,1,es_out_SetFrameNext,int es_out_SetFrameNext (es_out_t*),input\es_out.h,"static inline int es_out_SetFrameNext( es_out_t *p_out )
{
    return es_out_Control( p_out, ES_OUT_SET_FRAME_NEXT );
}",143.0,146.0,1.0,1.0,4.0,0,0,2,2,1,0,1,1,0,0,,0,0,2,1,1,int
2006,46845,es_out_SetTimes,1,es_out_SetTimes,"void es_out_SetTimes (es_out_t*,double,mtime_t,mtime_t)",input\es_out.h,"static inline void es_out_SetTimes( es_out_t *p_out, double f_position, mtime_t i_time, mtime_t i_length )
{
    int i_ret = es_out_Control( p_out, ES_OUT_SET_TIMES, f_position, i_time, i_length );
    assert( !i_ret );
}",147.0,151.0,1.0,1.0,5.0,2,2,7,6,1,0,1,1,0,0,,0,0,8,4,4,void
2007,46865,es_out_SetJitter,1,es_out_SetJitter,"void es_out_SetJitter (es_out_t*,mtime_t,mtime_t,int)",input\es_out.h,"static inline void es_out_SetJitter( es_out_t *p_out,
                                     mtime_t i_pts_delay, mtime_t i_pts_jitter, int i_cr_average )
{
    int i_ret = es_out_Control( p_out, ES_OUT_SET_JITTER,
                                i_pts_delay, i_pts_jitter, i_cr_average );
    assert( !i_ret );
}",152.0,158.0,1.0,1.0,7.0,2,2,7,6,1,0,1,1,0,0,,0,0,8,4,4,void
2008,46885,es_out_GetEsObjects,1,es_out_GetEsObjects,"int es_out_GetEsObjects (es_out_t*,int,vlc_object_t**,vout_thread_t**,audio_output_t**)",input\es_out.h,"static inline int es_out_GetEsObjects( es_out_t *p_out, int i_id,
                                       vlc_object_t **pp_decoder, vout_thread_t **pp_vout, audio_output_t **pp_aout )
{
    return es_out_Control( p_out, ES_OUT_GET_ES_OBJECTS_BY_ID, i_id, pp_decoder, pp_vout, pp_aout );
}",159.0,163.0,1.0,1.0,5.0,0,0,6,6,0,0,1,1,0,0,,0,0,10,5,5,int
2009,46902,es_out_GetGroupForced,1,es_out_GetGroupForced,int es_out_GetGroupForced (es_out_t*),input\es_out.h,"static inline int es_out_GetGroupForced( es_out_t *p_out )
{
    int i_group;
    int i_ret = es_out_Control( p_out, ES_OUT_GET_GROUP_FORCED, &i_group );
    assert( !i_ret );
    return i_group;
}",164.0,170.0,1.0,1.0,7.0,3,3,6,4,0,0,1,1,0,0,,0,0,2,1,1,int
2010,46921,es_out_Eos,1,es_out_Eos,void es_out_Eos (es_out_t*),input\es_out.h,"static inline void es_out_Eos( es_out_t *p_out )
{
    int i_ret = es_out_Control( p_out, ES_OUT_SET_EOS );
    assert( !i_ret );
}",171.0,175.0,1.0,1.0,5.0,2,2,4,3,1,0,1,1,0,0,,0,0,2,1,1,void
2011,47102,Add,1,Add,"es_out_id_t* Add (es_out_t*,es_format_t*)",input\es_out_timeshift.c,"static es_out_id_t *Add( es_out_t *p_out, const es_format_t *p_fmt )
{
    es_out_sys_t *p_sys = p_out->p_sys;
    ts_cmd_t cmd;

    es_out_id_t *p_es = malloc( sizeof( *p_es ) );
    if( !p_es )
        return NULL;

    vlc_mutex_lock( &p_sys->lock );

    TsAutoStop( p_out );

    if( CmdInitAdd( &cmd, p_es, p_fmt, p_sys->b_delayed ) )
    {
        vlc_mutex_unlock( &p_sys->lock );
        free( p_es );
        return NULL;
    }

    TAB_APPEND( p_sys->i_es, p_sys->pp_es, p_es );

    if( p_sys->b_delayed )
        TsPushCmd( p_sys->p_ts, &cmd );
    else
        CmdExecuteAdd( p_sys->p_out, &cmd );

    vlc_mutex_unlock( &p_sys->lock );

    return p_es;
}",427.0,457.0,1.0,1.0,31.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,es_out_id_t
2012,47108,Send,1,Send,"int Send (es_out_t*,es_out_id_t*,block_t*)",input\es_out_timeshift.c,"static int Send( es_out_t *p_out, es_out_id_t *p_es, block_t *p_block )
{
    es_out_sys_t *p_sys = p_out->p_sys;
    ts_cmd_t cmd;
    int i_ret = VLC_SUCCESS;

    vlc_mutex_lock( &p_sys->lock );

    TsAutoStop( p_out );

    CmdInitSend( &cmd, p_es, p_block );
    if( p_sys->b_delayed )
        TsPushCmd( p_sys->p_ts, &cmd );
    else
        i_ret = CmdExecuteSend( p_sys->p_out, &cmd) ;

    vlc_mutex_unlock( &p_sys->lock );

    return i_ret;
}",458.0,477.0,1.0,1.0,20.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
2013,47115,Del,1,Del,"void Del (es_out_t*,es_out_id_t*)",input\es_out_timeshift.c,"static void Del( es_out_t *p_out, es_out_id_t *p_es )
{
    es_out_sys_t *p_sys = p_out->p_sys;
    ts_cmd_t cmd;

    vlc_mutex_lock( &p_sys->lock );

    TsAutoStop( p_out );

    CmdInitDel( &cmd, p_es );
    if( p_sys->b_delayed )
        TsPushCmd( p_sys->p_ts, &cmd );
    else
        CmdExecuteDel( p_sys->p_out, &cmd );

    TAB_REMOVE( p_sys->i_es, p_sys->pp_es, p_es );

    vlc_mutex_unlock( &p_sys->lock );
}",478.0,496.0,1.0,1.0,19.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
2014,47121,Control,1,Control,"int Control (es_out_t*,int,ANY)",input\stream_memory.c,"static int Control( stream_t *s, int i_query, va_list args )
{
    stream_sys_t *p_sys = s->p_sys;

    uint64_t   *pi_64;

    switch( i_query )
    {
        case STREAM_GET_SIZE:
            pi_64 = va_arg( args, uint64_t * );
            *pi_64 = p_sys->i_size;
            break;

        case STREAM_CAN_SEEK:
        case STREAM_CAN_FASTSEEK:
        case STREAM_CAN_PAUSE:
        case STREAM_CAN_CONTROL_PACE:
            *va_arg( args, bool * ) = true;
            break;

        case STREAM_GET_PTS_DELAY:
            *va_arg( args, int64_t * ) = 0;
            break;

        case STREAM_GET_TITLE_INFO:
        case STREAM_GET_TITLE:
        case STREAM_GET_SEEKPOINT:
        case STREAM_GET_META:
        case STREAM_GET_CONTENT_TYPE:
        case STREAM_GET_SIGNAL:
        case STREAM_SET_TITLE:
        case STREAM_SET_SEEKPOINT:
            return VLC_EGENERIC;

        case STREAM_SET_PAUSE_STATE:
            break; /* nothing to do */

        case STREAM_SET_PRIVATE_ID_S...",85.0,134.0,1.0,1.0,50.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
2015,47128,Destroy,1,Destroy,void Destroy (es_out_t*),misc\variables.c,"static void Destroy( variable_t *p_var )
{
    p_var->ops->pf_free( &p_var->val );
    if( p_var->choices.i_count )
    {
        for( int i = 0 ; i < p_var->choices.i_count ; i++ )
        {
            p_var->ops->pf_free( &p_var->choices.p_values[i] );
            free( p_var->choices_text.p_values[i].psz_string );
        }
        free( p_var->choices.p_values );
        free( p_var->choices_text.p_values );
    }

    free( p_var->psz_name );
    free( p_var->psz_text );
    free( p_var->value_callbacks.p_entries );
    free( p_var );
}",163.0,181.0,1.0,1.0,19.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,void
2016,47133,TsStart,1,TsStart,int TsStart (es_out_t*),input\es_out_timeshift.c,"static int TsStart( es_out_t *p_out )
{
    es_out_sys_t *p_sys = p_out->p_sys;
    ts_thread_t *p_ts;

    assert( !p_sys->b_delayed );

    p_sys->p_ts = p_ts = calloc(1, sizeof(*p_ts));
    if( !p_ts )
        return VLC_EGENERIC;

    p_ts->i_tmp_size_max = p_sys->i_tmp_size_max;
    p_ts->psz_tmp_path = p_sys->psz_tmp_path;
    p_ts->p_input = p_sys->p_input;
    p_ts->p_out = p_sys->p_out;
    vlc_mutex_init( &p_ts->lock );
    vlc_cond_init( &p_ts->wait );
    p_ts->b_paused = p_sys->b_input_paused && !p_sys->b_input_paused_source;
    p_ts->i_pause_date = p_ts->b_paused ? mdate() : -1;
    p_ts->i_rate_source = p_sys->i_input_rate_source;
    p_ts->i_rate        = p_sys->i_input_rate;
    p_ts->i_rate_date = -1;
    p_ts->i_rate_delay = 0;
    p_ts->i_buffering_delay = 0;
    p_ts->i_cmd_delay = 0;
    p_ts->p_storage_r = NULL;
    p_ts->p_storage_w = NULL;

    p_sys->b_delayed = true;
    if( vlc_clone( &p_ts->thread, TsRun, p_ts, VLC_THREAD_PRIORITY_INPUT ) )
    {
      ...",780.0,820.0,1.0,1.0,41.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
2017,47138,TsAutoStop,1,TsAutoStop,void TsAutoStop (es_out_t*),input\es_out_timeshift.c,"static void TsAutoStop( es_out_t *p_out )
{
    es_out_sys_t *p_sys = p_out->p_sys;

    if( !p_sys->b_delayed || !TsIsUnused( p_sys->p_ts ) )
        return;

    msg_Warn( p_sys->p_input, ""es out timeshift: auto stop"" );
    TsStop( p_sys->p_ts );

    p_sys->b_delayed = false;
}",821.0,832.0,1.0,1.0,12.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2018,47143,TsStop,1,TsStop,void TsStop (ts_thread_t*),input\es_out_timeshift.c,"static void TsStop( ts_thread_t *p_ts )
{
    vlc_cancel( p_ts->thread );
    vlc_join( p_ts->thread, NULL );

    vlc_mutex_lock( &p_ts->lock );
    for( ;; )
    {
        ts_cmd_t cmd;

        if( TsPopCmdLocked( p_ts, &cmd, true ) )
            break;

        CmdClean( &cmd );
    }
    assert( !p_ts->p_storage_r || !p_ts->p_storage_r->p_next );
    if( p_ts->p_storage_r )
        TsStorageDelete( p_ts->p_storage_r );
    vlc_mutex_unlock( &p_ts->lock );

    TsDestroy( p_ts );
}",833.0,854.0,1.0,1.0,22.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2019,47148,TsPushCmd,1,TsPushCmd,"void TsPushCmd (ts_thread_t*,ts_cmd_t*)",input\es_out_timeshift.c,"static void TsPushCmd( ts_thread_t *p_ts, ts_cmd_t *p_cmd )
{
    vlc_mutex_lock( &p_ts->lock );

    if( !p_ts->p_storage_w || TsStorageIsFull( p_ts->p_storage_w, p_cmd ) )
    {
        ts_storage_t *p_storage = TsStorageNew( p_ts->psz_tmp_path, p_ts->i_tmp_size_max );

        if( !p_storage )
        {
            CmdClean( p_cmd );
            vlc_mutex_unlock( &p_ts->lock );
            /* TODO warn the user (but only once) */
            return;
        }

        if( !p_ts->p_storage_w )
        {
            p_ts->p_storage_r = p_ts->p_storage_w = p_storage;
        }
        else
        {
            TsStoragePack( p_ts->p_storage_w );
            p_ts->p_storage_w->p_next = p_storage;
            p_ts->p_storage_w = p_storage;
        }
    }

    /* TODO return error and warn the user (but only once) */
    TsStoragePushCmd( p_ts->p_storage_w, p_cmd, p_ts->p_storage_r == p_ts->p_storage_w );

    vlc_cond_signal( &p_ts->wait );

    vlc_mutex_unlock( &p_ts->lock );
}",855.0,889.0,1.0,1.0,35.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
2020,47154,TsPopCmdLocked,1,TsPopCmdLocked,"int TsPopCmdLocked (ts_thread_t*,ts_cmd_t*,bool)",input\es_out_timeshift.c,"static int TsPopCmdLocked( ts_thread_t *p_ts, ts_cmd_t *p_cmd, bool b_flush )
{
    vlc_assert_locked( &p_ts->lock );

    if( TsStorageIsEmpty( p_ts->p_storage_r ) )
        return VLC_EGENERIC;

    TsStoragePopCmd( p_ts->p_storage_r, p_cmd, b_flush );

    while( TsStorageIsEmpty( p_ts->p_storage_r ) )
    {
        ts_storage_t *p_next = p_ts->p_storage_r->p_next;
        if( !p_next )
            break;

        TsStorageDelete( p_ts->p_storage_r );
        p_ts->p_storage_r = p_next;
    }

    return VLC_SUCCESS;
}",890.0,910.0,1.0,1.0,21.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
2021,47161,TsHasCmd,1,TsHasCmd,bool TsHasCmd (ts_thread_t*),input\es_out_timeshift.c,"static bool TsHasCmd( ts_thread_t *p_ts )
{
    bool b_cmd;

    vlc_mutex_lock( &p_ts->lock );
    b_cmd = !TsStorageIsEmpty( p_ts->p_storage_r );
    vlc_mutex_unlock( &p_ts->lock );

    return b_cmd;
}",911.0,920.0,1.0,1.0,10.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,bool
2022,47166,TsIsUnused,1,TsIsUnused,bool TsIsUnused (ts_thread_t*),input\es_out_timeshift.c,"static bool TsIsUnused( ts_thread_t *p_ts )
{
    bool b_unused;

    vlc_mutex_lock( &p_ts->lock );
    b_unused = !p_ts->b_paused &&
               p_ts->i_rate == p_ts->i_rate_source &&
               TsStorageIsEmpty( p_ts->p_storage_r );
    vlc_mutex_unlock( &p_ts->lock );

    return b_unused;
}",921.0,932.0,1.0,1.0,12.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,bool
2023,47171,TsChangePause,1,TsChangePause,"int TsChangePause (ts_thread_t*,bool,bool,mtime_t)",input\es_out_timeshift.c,"static int TsChangePause( ts_thread_t *p_ts, bool b_source_paused, bool b_paused, mtime_t i_date )
{
    vlc_mutex_lock( &p_ts->lock );

    int i_ret;
    if( b_paused )
    {
        assert( !b_source_paused );
        i_ret = es_out_SetPauseState( p_ts->p_out, true, true, i_date );
    }
    else
    {
        i_ret = es_out_SetPauseState( p_ts->p_out, false, false, i_date );
    }

    if( !i_ret )
    {
        if( !b_paused )
        {
            assert( p_ts->i_pause_date > 0 );

            p_ts->i_cmd_delay += i_date - p_ts->i_pause_date;
        }

        p_ts->b_paused = b_paused;
        p_ts->i_pause_date = i_date;

        vlc_cond_signal( &p_ts->wait );
    }
    vlc_mutex_unlock( &p_ts->lock );
    return i_ret;
}",933.0,964.0,1.0,1.0,32.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,int
2024,47179,TsChangeRate,1,TsChangeRate,"int TsChangeRate (ts_thread_t*,int,int)",input\es_out_timeshift.c,"static int TsChangeRate( ts_thread_t *p_ts, int i_src_rate, int i_rate )
{
    int i_ret;

    vlc_mutex_lock( &p_ts->lock );
    p_ts->i_cmd_delay += p_ts->i_rate_delay;

    p_ts->i_rate_date = -1;
    p_ts->i_rate_delay = 0;
    p_ts->i_rate = i_rate;
    p_ts->i_rate_source = i_src_rate;

    i_ret = es_out_SetRate( p_ts->p_out, i_rate, i_rate );
    vlc_mutex_unlock( &p_ts->lock );

    return i_ret;
}",965.0,981.0,1.0,1.0,17.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
2025,47186,TsRun,1,TsRun,void* TsRun (void*),input\es_out_timeshift.c,"static void *TsRun( void *p_data )
{
    ts_thread_t *p_ts = p_data;
    mtime_t i_buffering_date = -1;

    for( ;; )
    {
        ts_cmd_t cmd;
        mtime_t  i_deadline;
        bool b_buffering;

        /* Pop a command to execute */
        vlc_mutex_lock( &p_ts->lock );
        mutex_cleanup_push( &p_ts->lock );

        for( ;; )
        {
            const int canc = vlc_savecancel();
            b_buffering = es_out_GetBuffering( p_ts->p_out );

            if( ( !p_ts->b_paused || b_buffering ) && !TsPopCmdLocked( p_ts, &cmd, false ) )
            {
                vlc_restorecancel( canc );
                break;
            }
            vlc_restorecancel( canc );

            vlc_cond_wait( &p_ts->wait, &p_ts->lock );
        }

        if( b_buffering && i_buffering_date < 0 )
        {
            i_buffering_date = cmd.i_date;
        }
        else if( i_buffering_date > 0 )
        {
            p_ts->i_buffering_delay += i_buffering_date - cmd.i_date; /* It is...",983.0,1100.0,1.0,1.0,118.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void*
2026,47191,TsStorageNew,1,TsStorageNew,"ts_storage_t* TsStorageNew (char*,int64_t)",input\es_out_timeshift.c,"static ts_storage_t *TsStorageNew( const char *psz_tmp_path, int64_t i_tmp_size_max )
{
    ts_storage_t *p_storage = malloc( sizeof (*p_storage) );
    if( unlikely(p_storage == NULL) )
        return NULL;

    char *psz_file;
    int fd = GetTmpFile( &psz_file, psz_tmp_path );
    if( fd == -1 )
    {
        free( p_storage );
        return NULL;
    }

    p_storage->p_filew = fdopen( fd, ""w+b"" );
    if( p_storage->p_filew == NULL )
    {
        vlc_close( fd );
        vlc_unlink( psz_file );
        goto error;
    }

    p_storage->p_filer = vlc_fopen( psz_file, ""rb"" );
    if( p_storage->p_filer == NULL )
    {
        fclose( p_storage->p_filew );
        vlc_unlink( psz_file );
        goto error;
    }

#ifndef _WIN32
    vlc_unlink( psz_file );
    free( psz_file );
#else
    p_storage->psz_file = psz_file;
#endif
    p_storage->p_next = NULL;

    /* */
    p_storage->i_file_max = i_tmp_size_max;
    p_storage->i_file_size = 0;

    /* */
    p_storage->i_cmd_w = 0;...",1105.0,1164.0,1.0,1.0,60.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ts_storage_t
2027,47197,TsStorageDelete,1,TsStorageDelete,void TsStorageDelete (ts_storage_t*),input\es_out_timeshift.c,"static void TsStorageDelete( ts_storage_t *p_storage )
{
    while( p_storage->i_cmd_r < p_storage->i_cmd_w )
    {
        ts_cmd_t cmd;

        TsStoragePopCmd( p_storage, &cmd, true );

        CmdClean( &cmd );
    }
    free( p_storage->p_cmd );

    fclose( p_storage->p_filer );
    fclose( p_storage->p_filew );
#ifdef _WIN32
    vlc_unlink( p_storage->psz_file );
    free( p_storage->psz_file );
#endif
    free( p_storage );
}",1166.0,1185.0,1.0,1.0,20.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2028,47202,TsStoragePack,1,TsStoragePack,void TsStoragePack (ts_storage_t*),input\es_out_timeshift.c,"static void TsStoragePack( ts_storage_t *p_storage )
{
    /* Try to release a bit of memory */
    if( p_storage->i_cmd_w >= p_storage->i_cmd_max )
        return;

    p_storage->i_cmd_max = __MAX( p_storage->i_cmd_w, 1 );

    ts_cmd_t *p_new = realloc( p_storage->p_cmd, p_storage->i_cmd_max * sizeof(*p_storage->p_cmd) );
    if( p_new )
        p_storage->p_cmd = p_new;
}",1187.0,1198.0,1.0,1.0,12.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2029,47207,TsStorageIsFull,1,TsStorageIsFull,"bool TsStorageIsFull (ts_storage_t*,ts_cmd_t*)",input\es_out_timeshift.c,"static bool TsStorageIsFull( ts_storage_t *p_storage, const ts_cmd_t *p_cmd )
{
    if( p_cmd && p_cmd->i_type == C_SEND && p_storage->i_cmd_w > 0 )
    {
        size_t i_size = sizeof(*p_cmd->u.send.p_block) + p_cmd->u.send.p_block->i_buffer;

        if( p_storage->i_file_size + i_size >= p_storage->i_file_max )
            return true;
    }
    return p_storage->i_cmd_w >= p_storage->i_cmd_max;
}",1199.0,1209.0,1.0,1.0,11.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,bool
2030,47213,TsStorageIsEmpty,1,TsStorageIsEmpty,bool TsStorageIsEmpty (ts_storage_t*),input\es_out_timeshift.c,"static bool TsStorageIsEmpty( ts_storage_t *p_storage )
{
    return !p_storage || p_storage->i_cmd_r >= p_storage->i_cmd_w;
}",1210.0,1213.0,1.0,1.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,bool
2031,47218,TsStoragePushCmd,1,TsStoragePushCmd,"void TsStoragePushCmd (ts_storage_t*,ts_cmd_t*,bool)",input\es_out_timeshift.c,"static void TsStoragePushCmd( ts_storage_t *p_storage, const ts_cmd_t *p_cmd, bool b_flush )
{
    ts_cmd_t cmd = *p_cmd;

    assert( !TsStorageIsFull( p_storage, p_cmd ) );

    if( cmd.i_type == C_SEND )
    {
        block_t *p_block = cmd.u.send.p_block;

        cmd.u.send.p_block = NULL;
        cmd.u.send.i_offset = ftell( p_storage->p_filew );

        if( fwrite( p_block, sizeof(*p_block), 1, p_storage->p_filew ) != 1 )
        {
            block_Release( p_block );
            return;
        }
        p_storage->i_file_size += sizeof(*p_block);
        if( p_block->i_buffer > 0 )
        {
            if( fwrite( p_block->p_buffer, p_block->i_buffer, 1, p_storage->p_filew ) != 1 )
            {
                block_Release( p_block );
                return;
            }
        }
        p_storage->i_file_size += p_block->i_buffer;
        block_Release( p_block );

        if( b_flush )
            fflush( p_storage->p_filew );
    }
    p_storage->p_cmd[p_storage->...",1214.0,1248.0,1.0,1.0,35.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
2032,47225,TsStoragePopCmd,1,TsStoragePopCmd,"void TsStoragePopCmd (ts_storage_t*,ts_cmd_t*,bool)",input\es_out_timeshift.c,"static void TsStoragePopCmd( ts_storage_t *p_storage, ts_cmd_t *p_cmd, bool b_flush )
{
    assert( !TsStorageIsEmpty( p_storage ) );

    *p_cmd = p_storage->p_cmd[p_storage->i_cmd_r++];
    if( p_cmd->i_type == C_SEND )
    {
        block_t block;

        if( !b_flush &&
            !fseek( p_storage->p_filer, p_cmd->u.send.i_offset, SEEK_SET ) &&
            fread( &block, sizeof(block), 1, p_storage->p_filer ) == 1 )
        {
            block_t *p_block = block_Alloc( block.i_buffer );
            if( p_block )
            {
                p_block->i_dts      = block.i_dts;
                p_block->i_pts      = block.i_pts;
                p_block->i_flags    = block.i_flags;
                p_block->i_length   = block.i_length;
                p_block->i_nb_samples = block.i_nb_samples;
                p_block->i_buffer = fread( p_block->p_buffer, 1, block.i_buffer, p_storage->p_filer );
            }
            p_cmd->u.send.p_block = p_block;
        }
        else
    ...",1249.0,1280.0,1.0,1.0,32.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
2033,47232,CmdClean,1,CmdClean,void CmdClean (ts_cmd_t*),input\es_out_timeshift.c,"static void CmdClean( ts_cmd_t *p_cmd )
{
    switch( p_cmd->i_type )
    {
    case C_ADD:
        CmdCleanAdd( p_cmd );
        break;
    case C_SEND:
        CmdCleanSend( p_cmd );
        break;
    case C_CONTROL:
        CmdCleanControl( p_cmd );
        break;
    case C_DEL:
        break;
    default:
        vlc_assert_unreachable();
        break;
    }
}",1285.0,1304.0,1.0,1.0,20.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
2034,47237,cmd_cleanup_routine,1,cmd_cleanup_routine,void cmd_cleanup_routine (void*),input\es_out_timeshift.c,static void cmd_cleanup_routine( void *p ) { CmdClean( p ); },278.0,278.0,1.0,61.0,1.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
2035,47244,CmdInitAdd,1,CmdInitAdd,"int CmdInitAdd (ts_cmd_t*,es_out_id_t*,es_format_t*,bool)",input\es_out_timeshift.c,"static int CmdInitAdd( ts_cmd_t *p_cmd, es_out_id_t *p_es, const es_format_t *p_fmt, bool b_copy )
{
    p_cmd->i_type = C_ADD;
    p_cmd->i_date = mdate();
    p_cmd->u.add.p_es = p_es;
    if( b_copy )
    {
        p_cmd->u.add.p_fmt = malloc( sizeof(*p_fmt) );
        if( !p_cmd->u.add.p_fmt )
            return VLC_EGENERIC;
        es_format_Copy( p_cmd->u.add.p_fmt, p_fmt );
    }
    else
    {
        p_cmd->u.add.p_fmt = (es_format_t*)p_fmt;
    }
    return VLC_SUCCESS;
}",1306.0,1323.0,1.0,1.0,18.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,int
2036,47252,CmdInitSend,1,CmdInitSend,"void CmdInitSend (ts_cmd_t*,es_out_id_t*,block_t*)",input\es_out_timeshift.c,"static void CmdInitSend( ts_cmd_t *p_cmd, es_out_id_t *p_es, block_t *p_block )
{
    p_cmd->i_type = C_SEND;
    p_cmd->i_date = mdate();
    p_cmd->u.send.p_es = p_es;
    p_cmd->u.send.p_block = p_block;
}",1334.0,1340.0,1.0,1.0,7.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
2037,47259,CmdInitDel,1,CmdInitDel,"int CmdInitDel (ts_cmd_t*,es_out_id_t*)",input\es_out_timeshift.c,"static int CmdInitDel( ts_cmd_t *p_cmd, es_out_id_t *p_es )
{
    p_cmd->i_type = C_DEL;
    p_cmd->i_date = mdate();
    p_cmd->u.del.p_es = p_es;
    return VLC_SUCCESS;
}",1361.0,1367.0,1.0,1.0,7.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
2038,47265,CmdInitControl,1,CmdInitControl,"int CmdInitControl (ts_cmd_t*,int,ANY,bool)",input\es_out_timeshift.c,"static int CmdInitControl( ts_cmd_t *p_cmd, int i_query, va_list args, bool b_copy )
{
    p_cmd->i_type = C_CONTROL;
    p_cmd->i_date = mdate();
    p_cmd->u.control.i_query = i_query;

    switch( i_query )
    {
    /* Pass-through control */
    case ES_OUT_SET_MODE:    /* arg1= int                            */
    case ES_OUT_SET_GROUP:   /* arg1= int                            */
    case ES_OUT_DEL_GROUP:   /* arg1=int i_group */
        p_cmd->u.control.u.i_int = (int)va_arg( args, int );
        break;

    case ES_OUT_SET_PCR:                /* arg1=int64_t i_pcr(microsecond!) (using default group 0)*/
    case ES_OUT_SET_NEXT_DISPLAY_TIME:  /* arg1=int64_t i_pts(microsecond) */
        p_cmd->u.control.u.i_i64 = (int64_t)va_arg( args, int64_t );
        break;

    case ES_OUT_SET_GROUP_PCR:          /* arg1= int i_group, arg2=int64_t i_pcr(microsecond!)*/
        p_cmd->u.control.u.int_i64.i_int = (int)va_arg( args, int );
        p_cmd->u.control.u.int_i64.i_i64 = (in...",1375.0,1536.0,1.0,1.0,162.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,int
2039,47273,CmdCleanAdd,1,CmdCleanAdd,void CmdCleanAdd (ts_cmd_t*),input\es_out_timeshift.c,"static void CmdCleanAdd( ts_cmd_t *p_cmd )
{
    es_format_Clean( p_cmd->u.add.p_fmt );
    free( p_cmd->u.add.p_fmt );
}",1328.0,1332.0,1.0,1.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2040,47278,CmdCleanSend,1,CmdCleanSend,void CmdCleanSend (ts_cmd_t*),input\es_out_timeshift.c,"static void CmdCleanSend( ts_cmd_t *p_cmd )
{
    if( p_cmd->u.send.p_block )
        block_Release( p_cmd->u.send.p_block );
}",1355.0,1359.0,1.0,1.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2041,47283,CmdCleanControl,1,CmdCleanControl,void CmdCleanControl (ts_cmd_t*),input\es_out_timeshift.c,"static void CmdCleanControl( ts_cmd_t *p_cmd )
{
    switch( p_cmd->u.control.i_query )
    {
    case ES_OUT_SET_GROUP_META:
    case ES_OUT_SET_META:
        if( p_cmd->u.control.u.int_meta.p_meta )
            vlc_meta_Delete( p_cmd->u.control.u.int_meta.p_meta );
        break;
    case ES_OUT_SET_GROUP_EPG:
        if( p_cmd->u.control.u.int_epg.p_epg )
            vlc_epg_Delete( p_cmd->u.control.u.int_epg.p_epg );
        break;
    case ES_OUT_SET_GROUP_EPG_EVENT:
        if( p_cmd->u.control.u.int_epg_evt.p_evt )
            vlc_epg_event_Delete( p_cmd->u.control.u.int_epg_evt.p_evt );
        break;
    case ES_OUT_SET_ES_FMT:
        if( p_cmd->u.control.u.es_fmt.p_fmt )
        {
            es_format_Clean( p_cmd->u.control.u.es_fmt.p_fmt );
            free( p_cmd->u.control.u.es_fmt.p_fmt );
        }
        break;
    }
}",1617.0,1642.0,1.0,1.0,26.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2042,47288,CmdExecuteAdd,1,CmdExecuteAdd,"void CmdExecuteAdd (es_out_t*,ts_cmd_t*)",input\es_out_timeshift.c,"static void CmdExecuteAdd( es_out_t *p_out, ts_cmd_t *p_cmd )
{
    p_cmd->u.add.p_es->p_es = es_out_Add( p_out, p_cmd->u.add.p_fmt );
}",1324.0,1327.0,1.0,1.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
2043,47294,CmdExecuteSend,1,CmdExecuteSend,"int CmdExecuteSend (es_out_t*,ts_cmd_t*)",input\es_out_timeshift.c,"static int CmdExecuteSend( es_out_t *p_out, ts_cmd_t *p_cmd )
{
    block_t *p_block = p_cmd->u.send.p_block;

    p_cmd->u.send.p_block = NULL;

    if( p_block )
    {
        if( p_cmd->u.send.p_es->p_es )
            return es_out_Send( p_out, p_cmd->u.send.p_es->p_es, p_block );
        block_Release( p_block );
    }
    return VLC_EGENERIC;
}",1341.0,1354.0,1.0,1.0,14.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
2044,47300,CmdExecuteDel,1,CmdExecuteDel,"void CmdExecuteDel (es_out_t*,ts_cmd_t*)",input\es_out_timeshift.c,"static void CmdExecuteDel( es_out_t *p_out, ts_cmd_t *p_cmd )
{
    if( p_cmd->u.del.p_es->p_es )
        es_out_Del( p_out, p_cmd->u.del.p_es->p_es );
    free( p_cmd->u.del.p_es );
}",1368.0,1373.0,1.0,1.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
2045,47306,CmdExecuteControl,1,CmdExecuteControl,"int CmdExecuteControl (es_out_t*,ts_cmd_t*)",input\es_out_timeshift.c,"static int CmdExecuteControl( es_out_t *p_out, ts_cmd_t *p_cmd )
{
    const int i_query = p_cmd->u.control.i_query;

    switch( i_query )
    {
    /* Pass-through control */
    case ES_OUT_SET_MODE:    /* arg1= int                            */
    case ES_OUT_SET_GROUP:   /* arg1= int                            */
    case ES_OUT_DEL_GROUP:   /* arg1=int i_group */
        return es_out_Control( p_out, i_query, p_cmd->u.control.u.i_int );

    case ES_OUT_SET_PCR:                /* arg1=int64_t i_pcr(microsecond!) (using default group 0)*/
    case ES_OUT_SET_NEXT_DISPLAY_TIME:  /* arg1=int64_t i_pts(microsecond) */
        return es_out_Control( p_out, i_query, p_cmd->u.control.u.i_i64 );

    case ES_OUT_SET_GROUP_PCR:          /* arg1= int i_group, arg2=int64_t i_pcr(microsecond!)*/
        return es_out_Control( p_out, i_query, p_cmd->u.control.u.int_i64.i_int,
                                               p_cmd->u.control.u.int_i64.i_i64 );

    case ES_OUT_RESET_PCR:    ...",1537.0,1616.0,1.0,1.0,80.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
2046,47312,GetTmpFile,1,GetTmpFile,"int GetTmpFile (char**,char*)",input\es_out_timeshift.c,"static int GetTmpFile( char **filename, const char *dirname )
{
    if( dirname != NULL
     && asprintf( filename, ""%s""DIR_SEP PACKAGE_NAME""-timeshift.XXXXXX"",
                  dirname ) >= 0 )
    {
        vlc_mkdir( dirname, 0700 );

        int fd = vlc_mkstemp( *filename );
        if( fd != -1 )
            return fd;

        free( *filename );
    }

    *filename = strdup( DIR_SEP""tmp""DIR_SEP PACKAGE_NAME""-timeshift.XXXXXX"" );
    if( unlikely(*filename == NULL) )
        return -1;

    int fd = vlc_mkstemp( *filename );
    if( fd != -1 )
        return fd;

    free( *filename );
    return -1;
}",1644.0,1669.0,1.0,1.0,26.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
2047,47318,input_EsOutTimeshiftNew,1,input_EsOutTimeshiftNew,"es_out_t input_EsOutTimeshiftNew (input_thread_t*,es_out_t*,int)",input\es_out_timeshift.c,"es_out_t *input_EsOutTimeshiftNew( input_thread_t *p_input, es_out_t *p_next_out, int i_rate )
{
    es_out_t *p_out = malloc( sizeof(*p_out) );
    if( !p_out )
        return NULL;

    es_out_sys_t *p_sys = malloc( sizeof(*p_sys) );
    if( !p_sys )
    {
        free( p_out );
        return NULL;
    }

    /* */
    p_out->pf_add     = Add;
    p_out->pf_send    = Send;
    p_out->pf_del     = Del;
    p_out->pf_control = Control;
    p_out->pf_destroy = Destroy;
    p_out->p_sys      = p_sys;

    /* */
    p_sys->b_input_paused = false;
    p_sys->b_input_paused_source = false;
    p_sys->p_input = p_input;
    p_sys->i_input_rate = i_rate;
    p_sys->i_input_rate_source = i_rate;

    p_sys->p_out = p_next_out;
    vlc_mutex_init_recursive( &p_sys->lock );

    p_sys->b_delayed = false;
    p_sys->p_ts = NULL;

    TAB_INIT( p_sys->i_es, p_sys->pp_es );

    /* */
    const int i_tmp_size_max = var_CreateGetInteger( p_input, ""input-timeshift-granularity"" );
    if( i_tmp_si...",302.0,402.0,1.0,1.0,101.0,55,11,48,8,0,17,5,5,1,1,,0,16,6,3,3,es_out_t
2048,47765,ControlLockedGetEmpty,1,ControlLockedGetEmpty,"int ControlLockedGetEmpty (es_out_t*,bool*)",input\es_out_timeshift.c,"static int ControlLockedGetEmpty( es_out_t *p_out, bool *pb_empty )
{
    es_out_sys_t *p_sys = p_out->p_sys;

    if( p_sys->b_delayed && TsHasCmd( p_sys->p_ts ) )
        *pb_empty = false;
    else
        *pb_empty = es_out_GetEmpty( p_sys->p_out );

    return VLC_SUCCESS;
}",498.0,508.0,1.0,1.0,11.0,7,4,7,5,1,3,2,2,3,1,,0,3,4,2,2,int
2049,47802,ControlLockedGetWakeup,1,ControlLockedGetWakeup,"int ControlLockedGetWakeup (es_out_t*,mtime_t*)",input\es_out_timeshift.c,"static int ControlLockedGetWakeup( es_out_t *p_out, mtime_t *pi_wakeup )
{
    es_out_sys_t *p_sys = p_out->p_sys;

    if( p_sys->b_delayed )
    {
        assert( !input_priv(p_sys->p_input)->b_can_pace_control );
        *pi_wakeup = 0;
    }
    else
    {
        *pi_wakeup = es_out_GetWakeup( p_sys->p_out );
    }

    return VLC_SUCCESS;
}",509.0,524.0,1.0,1.0,16.0,8,4,6,4,1,3,2,2,1,1,,0,2,4,2,2,int
2050,47842,ControlLockedGetBuffering,1,ControlLockedGetBuffering,"int ControlLockedGetBuffering (es_out_t*,bool*)",input\es_out_timeshift.c,"static int ControlLockedGetBuffering( es_out_t *p_out, bool *pb_buffering )
{
    es_out_sys_t *p_sys = p_out->p_sys;

    if( p_sys->b_delayed )
        *pb_buffering = true;
    else
        *pb_buffering = es_out_GetBuffering( p_sys->p_out );

    return VLC_SUCCESS;
}",525.0,535.0,1.0,1.0,11.0,5,3,6,5,1,1,2,2,1,0,,0,1,4,2,2,int
2051,47874,ControlLockedSetPauseState,1,ControlLockedSetPauseState,"int ControlLockedSetPauseState (es_out_t*,bool,bool,mtime_t)",input\es_out_timeshift.c,"static int ControlLockedSetPauseState( es_out_t *p_out, bool b_source_paused, bool b_paused, mtime_t i_date )
{
    es_out_sys_t *p_sys = p_out->p_sys;
    int i_ret;

    if( !p_sys->b_delayed && !b_source_paused == !b_paused )
    {
        i_ret = es_out_SetPauseState( p_sys->p_out, b_source_paused, b_paused, i_date );
    }
    else
    {
        i_ret = VLC_EGENERIC;
        if( !input_priv(p_sys->p_input)->b_can_pace_control )
        {
            if( !p_sys->b_delayed )
                TsStart( p_out );
            if( p_sys->b_delayed )
                i_ret = TsChangePause( p_sys->p_ts, b_source_paused, b_paused, i_date );
        }
        else
        {
            /* XXX we may do it BUT it would be better to finish the clock clean up+improvements
             * and so be able to advertize correctly pace control property in access
             * module */
            msg_Err( p_sys->p_input, ""EsOutTimeshift does not work with streams that have pace control"" );
        }...",536.0,570.0,1.0,1.0,35.0,15,5,16,6,1,5,3,3,1,1,,0,5,8,4,4,int
2052,47969,ControlLockedSetRate,1,ControlLockedSetRate,"int ControlLockedSetRate (es_out_t*,int,int)",input\es_out_timeshift.c,"static int ControlLockedSetRate( es_out_t *p_out, int i_src_rate, int i_rate )
{
    es_out_sys_t *p_sys = p_out->p_sys;
    int i_ret;

    if( !p_sys->b_delayed && i_src_rate == i_rate )
    {
        i_ret = es_out_SetRate( p_sys->p_out, i_src_rate, i_rate );
    }
    else
    {
        i_ret = VLC_EGENERIC;
        if( !input_priv(p_sys->p_input)->b_can_pace_control )
        {
            if( !p_sys->b_delayed )
                TsStart( p_out );
            if( p_sys->b_delayed )
                i_ret = TsChangeRate( p_sys->p_ts, i_src_rate, i_rate );
        }
        else
        {
            /* XXX we may do it BUT it would be better to finish the clock clean up+improvements
             * and so be able to advertize correctly pace control property in access
             * module */
            msg_Err( p_sys->p_input, ""EsOutTimeshift does not work with streams that have pace control"" );
        }

    }

    if( !i_ret )
    {
        p_sys->i_input_rate_source = i_src_ra...",571.0,606.0,1.0,1.0,36.0,13,5,15,5,1,5,3,3,1,1,,0,5,6,3,3,int
2053,48059,ControlLockedSetTime,1,ControlLockedSetTime,"int ControlLockedSetTime (es_out_t*,mtime_t)",input\es_out_timeshift.c,"static int ControlLockedSetTime( es_out_t *p_out, mtime_t i_date )
{
    es_out_sys_t *p_sys = p_out->p_sys;

    if( !p_sys->b_delayed )
        return es_out_SetTime( p_sys->p_out, i_date );

    /* TODO */
    msg_Err( p_sys->p_input, ""EsOutTimeshift does not yet support time change"" );
    return VLC_EGENERIC;
}",607.0,617.0,1.0,1.0,11.0,6,3,7,4,1,4,2,2,1,1,,0,3,4,2,2,int
2054,48090,ControlLockedSetFrameNext,1,ControlLockedSetFrameNext,int ControlLockedSetFrameNext (es_out_t*),input\es_out_timeshift.c,"static int ControlLockedSetFrameNext( es_out_t *p_out )
{
    es_out_sys_t *p_sys = p_out->p_sys;

    return es_out_SetFrameNext( p_sys->p_out );
}",618.0,623.0,1.0,1.0,6.0,3,2,3,2,1,2,1,1,0,1,,0,1,2,1,1,int
2055,48106,ControlLocked,1,ControlLocked,"int ControlLocked (es_out_t*,int,va_list)",input\es_out_timeshift.c,"static int ControlLocked( es_out_t *p_out, int i_query, va_list args )
{
    es_out_sys_t *p_sys = p_out->p_sys;

    switch( i_query )
    {
    /* Pass-through control */
    case ES_OUT_SET_MODE:
    case ES_OUT_SET_GROUP:
    case ES_OUT_SET_PCR:
    case ES_OUT_SET_GROUP_PCR:
    case ES_OUT_RESET_PCR:
    case ES_OUT_SET_NEXT_DISPLAY_TIME:
    case ES_OUT_SET_GROUP_META:
    case ES_OUT_SET_GROUP_EPG:
    case ES_OUT_SET_GROUP_EPG_EVENT:
    case ES_OUT_SET_EPG_TIME:
    case ES_OUT_SET_ES_SCRAMBLED_STATE:
    case ES_OUT_DEL_GROUP:
    case ES_OUT_SET_META:
    case ES_OUT_SET_ES:
    case ES_OUT_RESTART_ES:
    case ES_OUT_RESTART_ALL_ES:
    case ES_OUT_SET_ES_DEFAULT:
    case ES_OUT_SET_ES_STATE:
    case ES_OUT_SET_ES_CAT_POLICY:
    case ES_OUT_SET_ES_FMT:
    case ES_OUT_SET_TIMES:
    case ES_OUT_SET_JITTER:
    case ES_OUT_SET_EOS:
    {
        ts_cmd_t cmd;
        if( CmdInitControl( &cmd, i_query, args, p_sys->b_delayed ) )
            return VLC_EGENERIC;
      ...",625.0,754.0,1.0,1.0,130.0,26,6,106,65,0,20,7,12,6,10,,0,11,6,3,3,int
2056,48414,TsDestroy,1,TsDestroy,void TsDestroy (ts_thread_t*),input\es_out_timeshift.c,"static void TsDestroy( ts_thread_t *p_ts )
{
    vlc_cond_destroy( &p_ts->wait );
    vlc_mutex_destroy( &p_ts->lock );
    free( p_ts );
}",774.0,779.0,1.0,1.0,6.0,4,2,3,1,0,4,1,1,0,2,,0,2,2,1,1,void
2057,51536,Trigger,1,Trigger,"void Trigger (input_thread_t*,int)",input\vlm_event.c,"static void Trigger( vlm_t *p_vlm, int i_type, int64_t id, const char *psz_name )
{
    vlm_event_t event;

    event.i_type = i_type;
    event.id = id;
    event.psz_name = psz_name;
    event.input_state = 0;
    event.psz_instance_name = NULL;
    var_SetAddress( p_vlm, ""intf-event"", &event );
}",74.0,84.0,1.0,1.0,11.0,0,0,0,0,25,0,1,1,0,0,,0,0,8,4,4,void
2058,51542,VarListAdd,1,VarListAdd,"void VarListAdd (input_thread_t*,char*,int,int,char*)",input\event.c,"static void VarListAdd( input_thread_t *p_input,
                        const char *psz_variable, int i_event,
                        int i_value, const char *psz_text )
{
    vlc_value_t val;
    vlc_value_t text;

    val.i_int = i_value;
    text.psz_string = (char*)psz_text;

    var_Change( p_input, psz_variable, VLC_VAR_ADDCHOICE,
                &val, psz_text ? &text : NULL );

    Trigger( p_input, i_event );
}",304.0,318.0,1.0,1.0,15.0,0,0,0,0,3,0,1,1,0,0,,0,0,10,5,5,void
2059,51551,VarListDel,1,VarListDel,"void VarListDel (input_thread_t*,char*,int,int)",input\event.c,"static void VarListDel( input_thread_t *p_input,
                        const char *psz_variable, int i_event,
                        int i_value )
{
    vlc_value_t val;

    if( i_value >= 0 )
    {
        val.i_int = i_value;
        var_Change( p_input, psz_variable, VLC_VAR_DELCHOICE, &val, NULL );
    }
    else
    {
        var_Change( p_input, psz_variable, VLC_VAR_CLEARCHOICES, &val, NULL );
    }

    Trigger( p_input, i_event );
}",319.0,336.0,1.0,1.0,18.0,0,0,0,0,3,0,1,1,0,0,,0,0,8,4,4,void
2060,51559,VarListSelect,1,VarListSelect,"void VarListSelect (input_thread_t*,char*,int,int)",input\event.c,"static void VarListSelect( input_thread_t *p_input,
                           const char *psz_variable, int i_event,
                           int i_value )
{
    vlc_value_t val;

    val.i_int = i_value;
    var_Change( p_input, psz_variable, VLC_VAR_SETVALUE, &val, NULL );

    Trigger( p_input, i_event );
}",337.0,347.0,1.0,1.0,11.0,0,0,0,0,3,0,1,1,0,0,,0,0,8,4,4,void
2061,51567,input_SendEventDead,1,input_SendEventDead,void input_SendEventDead (input_thread_t*),input\event.c,"void input_SendEventDead( input_thread_t *p_input )
{
    Trigger( p_input, INPUT_EVENT_DEAD );
}",52.0,55.0,1.0,1.0,4.0,0,0,2,2,0,1,1,1,0,1,,0,0,2,1,1,void
2062,51575,input_SendEventPosition,1,input_SendEventPosition,"void input_SendEventPosition (input_thread_t*,double,mtime_t)",input\event.c,"void input_SendEventPosition( input_thread_t *p_input, double f_position, mtime_t i_time )
{
    vlc_value_t val;

    /* */
    val.f_float = f_position;
    var_Change( p_input, ""position"", VLC_VAR_SETVALUE, &val, NULL );

    /* */
    val.i_int = i_time;
    var_Change( p_input, ""time"", VLC_VAR_SETVALUE, &val, NULL );

    Trigger( p_input, INPUT_EVENT_POSITION );
}",57.0,70.0,1.0,1.0,14.0,6,3,14,7,1,3,1,1,0,3,,0,0,6,3,3,void
2063,51610,input_SendEventLength,1,input_SendEventLength,"void input_SendEventLength (input_thread_t*,mtime_t)",input\event.c,"void input_SendEventLength( input_thread_t *p_input, mtime_t i_length )
{
    vlc_value_t val;

    /* FIXME ugly + what about meta change event ? */
    if( var_GetInteger( p_input, ""length"" ) == i_length )
        return;

    input_item_SetDuration( input_priv(p_input)->p_item, i_length );

    val.i_int = i_length;
    var_Change( p_input, ""length"", VLC_VAR_SETVALUE, &val, NULL );

    Trigger( p_input, INPUT_EVENT_LENGTH );
}",71.0,85.0,1.0,1.0,15.0,5,5,12,6,1,4,2,2,0,4,,0,1,4,2,2,void
2064,51646,input_SendEventStatistics,1,input_SendEventStatistics,void input_SendEventStatistics (input_thread_t*),input\event.c,"void input_SendEventStatistics( input_thread_t *p_input )
{
    Trigger( p_input, INPUT_EVENT_STATISTICS );
}",86.0,89.0,1.0,1.0,4.0,0,0,2,2,1,1,1,1,0,1,,0,0,2,1,1,void
2065,51654,input_SendEventRate,1,input_SendEventRate,"void input_SendEventRate (input_thread_t*,int)",input\event.c,"void input_SendEventRate( input_thread_t *p_input, int i_rate )
{
    vlc_value_t val;

    val.f_float = (float)INPUT_RATE_DEFAULT / (float)i_rate;
    var_Change( p_input, ""rate"", VLC_VAR_SETVALUE, &val, NULL );

    Trigger( p_input, INPUT_EVENT_RATE );
}",90.0,98.0,1.0,1.0,9.0,6,5,9,7,0,2,1,1,0,2,,0,0,4,2,2,void
2066,51682,input_SendEventAudioDelay,1,input_SendEventAudioDelay,"void input_SendEventAudioDelay (input_thread_t*,mtime_t)",input\event.c,"void input_SendEventAudioDelay( input_thread_t *p_input, mtime_t i_delay )
{
    vlc_value_t val;

    val.i_int = i_delay;
    var_Change( p_input, ""audio-delay"", VLC_VAR_SETVALUE, &val, NULL );

    Trigger( p_input, INPUT_EVENT_AUDIO_DELAY );
}",99.0,107.0,1.0,1.0,9.0,3,3,8,6,0,2,1,1,0,2,,0,0,4,2,2,void
2067,51704,input_SendEventSubtitleDelay,1,input_SendEventSubtitleDelay,"void input_SendEventSubtitleDelay (input_thread_t*,mtime_t)",input\event.c,"void input_SendEventSubtitleDelay( input_thread_t *p_input, mtime_t i_delay )
{
    vlc_value_t val;

    val.i_int = i_delay;
    var_Change( p_input, ""spu-delay"", VLC_VAR_SETVALUE, &val, NULL );

    Trigger( p_input, INPUT_EVENT_SUBTITLE_DELAY );
}",109.0,117.0,1.0,1.0,9.0,3,3,8,6,0,2,1,1,0,2,,0,0,4,2,2,void
2068,51726,input_SendEventRecord,1,input_SendEventRecord,"void input_SendEventRecord (input_thread_t*,bool)",input\event.c,"void input_SendEventRecord( input_thread_t *p_input, bool b_recording )
{
    vlc_value_t val;

    val.b_bool = b_recording;
    var_Change( p_input, ""record"", VLC_VAR_SETVALUE, &val, NULL );

    Trigger( p_input, INPUT_EVENT_RECORD );
}",120.0,128.0,1.0,1.0,9.0,3,3,8,6,0,2,1,1,0,2,,0,0,4,2,2,void
2069,51748,input_SendEventTitle,1,input_SendEventTitle,"void input_SendEventTitle (input_thread_t*,int)",input\event.c,"void input_SendEventTitle( input_thread_t *p_input, int i_title )
{
    vlc_value_t val;

    val.i_int = i_title;
    var_Change( p_input, ""title"", VLC_VAR_SETVALUE, &val, NULL );

    input_ControlVarTitle( p_input, i_title );

    Trigger( p_input, INPUT_EVENT_TITLE );
}",130.0,140.0,1.0,1.0,11.0,3,3,10,6,1,3,1,1,0,3,,0,0,4,2,2,void
2070,51773,input_SendEventSeekpoint,1,input_SendEventSeekpoint,"void input_SendEventSeekpoint (input_thread_t*,int,int)",input\event.c,"void input_SendEventSeekpoint( input_thread_t *p_input, int i_title, int i_seekpoint )
{
    vlc_value_t val;

    /* ""chapter"" */
    val.i_int = i_seekpoint;
    var_Change( p_input, ""chapter"", VLC_VAR_SETVALUE, &val, NULL );

    /* ""title %2u"" */
    char psz_title[sizeof (""title "") + 3 * sizeof (int)];
    sprintf( psz_title, ""title %2u"", i_title );
    var_Change( p_input, psz_title, VLC_VAR_SETVALUE, &val, NULL );

    /* */
    Trigger( p_input, INPUT_EVENT_CHAPTER );
}",142.0,157.0,1.0,1.0,16.0,4,3,15,8,0,3,1,1,0,3,,0,0,6,3,3,void
2071,51808,input_SendEventSignal,1,input_SendEventSignal,"void input_SendEventSignal (input_thread_t*,double,double)",input\event.c,"void input_SendEventSignal( input_thread_t *p_input, double f_quality, double f_strength )
{
    vlc_value_t val;

    val.f_float = f_quality;
    var_Change( p_input, ""signal-quality"", VLC_VAR_SETVALUE, &val, NULL );

    val.f_float = f_strength;
    var_Change( p_input, ""signal-strength"", VLC_VAR_SETVALUE, &val, NULL );

    Trigger( p_input, INPUT_EVENT_SIGNAL );
}",159.0,170.0,1.0,1.0,12.0,6,3,14,7,0,3,1,1,0,3,,0,0,6,3,3,void
2072,51843,input_SendEventState,1,input_SendEventState,"void input_SendEventState (input_thread_t*,int)",input\event.c,"void input_SendEventState( input_thread_t *p_input, int i_state )
{
    vlc_value_t val;

    val.i_int = i_state;
    var_Change( p_input, ""state"", VLC_VAR_SETVALUE, &val, NULL );

    Trigger( p_input, INPUT_EVENT_STATE );
}",172.0,180.0,1.0,1.0,9.0,3,3,8,6,0,2,1,1,0,2,,0,0,4,2,2,void
2073,51865,input_SendEventCache,1,input_SendEventCache,"void input_SendEventCache (input_thread_t*,double)",input\event.c,"void input_SendEventCache( input_thread_t *p_input, double f_level )
{
    vlc_value_t val;

    val.f_float = f_level;
    var_Change( p_input, ""cache"", VLC_VAR_SETVALUE, &val, NULL );

    Trigger( p_input, INPUT_EVENT_CACHE );
}",182.0,190.0,1.0,1.0,9.0,3,3,8,6,1,2,1,1,0,2,,0,0,4,2,2,void
2074,51887,input_SendEventMeta,1,input_SendEventMeta,void input_SendEventMeta (input_thread_t*),input\event.c,"void input_SendEventMeta( input_thread_t *p_input )
{
    Trigger( p_input, INPUT_EVENT_ITEM_META );
}",192.0,195.0,1.0,1.0,4.0,0,0,2,2,3,1,1,1,0,1,,0,0,2,1,1,void
2075,51895,input_SendEventMetaInfo,1,input_SendEventMetaInfo,void input_SendEventMetaInfo (input_thread_t*),input\event.c,"void input_SendEventMetaInfo( input_thread_t *p_input )
{
    Trigger( p_input, INPUT_EVENT_ITEM_INFO );
}",197.0,200.0,1.0,1.0,4.0,0,0,2,2,3,1,1,1,0,1,,0,0,2,1,1,void
2076,51903,input_SendEventMetaEpg,1,input_SendEventMetaEpg,void input_SendEventMetaEpg (input_thread_t*),input\event.c,"void input_SendEventMetaEpg( input_thread_t *p_input )
{
    Trigger( p_input, INPUT_EVENT_ITEM_EPG );
}",202.0,205.0,1.0,1.0,4.0,0,0,2,2,1,1,1,1,0,1,,0,0,2,1,1,void
2077,51911,input_SendEventProgramAdd,1,input_SendEventProgramAdd,"void input_SendEventProgramAdd (input_thread_t*,int,char*)",input\event.c,"void input_SendEventProgramAdd( input_thread_t *p_input,
                                int i_program, const char *psz_text )
{
    VarListAdd( p_input, ""program"", INPUT_EVENT_PROGRAM, i_program, psz_text );
}",209.0,213.0,1.0,1.0,5.0,0,0,4,4,2,1,1,1,0,1,,0,0,6,3,3,void
2078,51924,input_SendEventProgramDel,1,input_SendEventProgramDel,"void input_SendEventProgramDel (input_thread_t*,int)",input\event.c,"void input_SendEventProgramDel( input_thread_t *p_input, int i_program )
{
    VarListDel( p_input, ""program"", INPUT_EVENT_PROGRAM, i_program );
}",214.0,217.0,1.0,1.0,4.0,0,0,3,3,2,1,1,1,0,1,,0,0,4,2,2,void
2079,51935,input_SendEventProgramSelect,1,input_SendEventProgramSelect,"void input_SendEventProgramSelect (input_thread_t*,int)",input\event.c,"void input_SendEventProgramSelect( input_thread_t *p_input, int i_program )
{
    VarListSelect( p_input, ""program"", INPUT_EVENT_PROGRAM, i_program );
}",218.0,221.0,1.0,1.0,4.0,0,0,3,3,2,1,1,1,0,1,,0,0,4,2,2,void
2080,51946,input_SendEventProgramScrambled,1,input_SendEventProgramScrambled,"void input_SendEventProgramScrambled (input_thread_t*,int,bool)",input\event.c,"void input_SendEventProgramScrambled( input_thread_t *p_input, int i_group, bool b_scrambled )
{
    if( var_GetInteger( p_input, ""program"" ) != i_group )
        return;

    var_SetBool( p_input, ""program-scrambled"", b_scrambled );
    Trigger( p_input, INPUT_EVENT_PROGRAM );
}",222.0,229.0,1.0,1.0,8.0,1,1,6,4,2,1,2,2,0,1,,0,0,6,3,3,void
2081,51968,GetEsVarName,1,GetEsVarName,const char* GetEsVarName (es_format_category_e),input\event.c,"static const char *GetEsVarName( enum es_format_category_e i_cat )
{
    switch( i_cat )
    {
    case VIDEO_ES:
        return ""video-es"";
    case AUDIO_ES:
        return ""audio-es"";
    case SPU_ES:
        return ""spu-es"";
    default:
        return NULL;
    }
}",231.0,244.0,1.0,1.0,14.0,0,0,5,5,3,0,2,2,0,0,,0,0,2,1,1,const char*
2082,51991,input_SendEventEsAdd,1,input_SendEventEsAdd,"void input_SendEventEsAdd (input_thread_t*,es_format_category_e,int,char*)",input\event.c,"void input_SendEventEsAdd( input_thread_t *p_input, enum es_format_category_e i_cat, int i_id, const char *psz_text )
{
    const char *psz_varname = GetEsVarName( i_cat );
    if( psz_varname )
        VarListAdd( p_input, psz_varname, INPUT_EVENT_ES, i_id, psz_text );
}",245.0,250.0,1.0,1.0,6.0,1,1,8,6,1,2,2,2,0,2,,0,1,8,4,4,void
2083,52013,input_SendEventEsDel,1,input_SendEventEsDel,"void input_SendEventEsDel (input_thread_t*,es_format_category_e,int)",input\event.c,"void input_SendEventEsDel( input_thread_t *p_input, enum es_format_category_e i_cat, int i_id )
{
    const char *psz_varname = GetEsVarName( i_cat );
    if( psz_varname )
        VarListDel( p_input, psz_varname, INPUT_EVENT_ES, i_id );
}",251.0,256.0,1.0,1.0,6.0,1,1,7,5,4,2,2,2,0,2,,0,1,6,3,3,void
2084,52033,input_SendEventEsSelect,1,input_SendEventEsSelect,"void input_SendEventEsSelect (input_thread_t*,es_format_category_e,int)",input\event.c,"void input_SendEventEsSelect( input_thread_t *p_input, enum es_format_category_e i_cat, int i_id )
{
    const char *psz_varname = GetEsVarName( i_cat );
    if( psz_varname )
        VarListSelect( p_input, psz_varname, INPUT_EVENT_ES, i_id );
}",258.0,263.0,1.0,1.0,6.0,1,1,7,5,1,2,2,2,0,2,,0,1,6,3,3,void
2085,52053,input_SendEventTeletextAdd,1,input_SendEventTeletextAdd,"void input_SendEventTeletextAdd (input_thread_t*,int,char*)",input\event.c,"void input_SendEventTeletextAdd( input_thread_t *p_input,
                                 int i_teletext, const char *psz_text )
{
    VarListAdd( p_input, ""teletext-es"", INPUT_EVENT_TELETEXT, i_teletext, psz_text );
}",265.0,269.0,1.0,1.0,5.0,0,0,4,4,1,1,1,1,0,1,,0,0,6,3,3,void
2086,52066,input_SendEventTeletextDel,1,input_SendEventTeletextDel,"void input_SendEventTeletextDel (input_thread_t*,int)",input\event.c,"void input_SendEventTeletextDel( input_thread_t *p_input, int i_teletext )
{
    VarListDel( p_input, ""teletext-es"", INPUT_EVENT_TELETEXT, i_teletext );
}",270.0,273.0,1.0,1.0,4.0,0,0,3,3,2,1,1,1,0,1,,0,0,4,2,2,void
2087,52077,input_SendEventTeletextSelect,1,input_SendEventTeletextSelect,"void input_SendEventTeletextSelect (input_thread_t*,int)",input\event.c,"void input_SendEventTeletextSelect( input_thread_t *p_input, int i_teletext )
{
    VarListSelect( p_input, ""teletext-es"", INPUT_EVENT_TELETEXT, i_teletext );
}",274.0,277.0,1.0,1.0,4.0,0,0,3,3,0,1,1,1,0,1,,0,0,4,2,2,void
2088,52088,input_SendEventVout,1,input_SendEventVout,void input_SendEventVout (input_thread_t*),input\event.c,"void input_SendEventVout( input_thread_t *p_input )
{
    Trigger( p_input, INPUT_EVENT_VOUT );
}",279.0,282.0,1.0,1.0,4.0,0,0,2,2,3,1,1,1,0,1,,0,0,2,1,1,void
2089,52096,input_SendEventAout,1,input_SendEventAout,void input_SendEventAout (input_thread_t*),input\event.c,"void input_SendEventAout( input_thread_t *p_input )
{
    Trigger( p_input, INPUT_EVENT_AOUT );
}",284.0,287.0,1.0,1.0,4.0,0,0,2,2,2,1,1,1,0,1,,0,0,2,1,1,void
2090,52104,input_SendEventBookmark,1,input_SendEventBookmark,void input_SendEventBookmark (input_thread_t*),input\event.c,"void input_SendEventBookmark( input_thread_t *p_input )
{
    Trigger( p_input, INPUT_EVENT_BOOKMARK );
}",292.0,295.0,1.0,1.0,4.0,0,0,2,2,0,1,1,1,0,1,,0,0,2,1,1,void
2091,52411,info_New,1,info_New,"info_t info_New (char*,char*)",input\info.h,"static inline info_t *info_New(const char *name, const char *value )
{
    info_t *info = malloc(sizeof(*info));
    if (!info)
        return NULL;

    info->psz_name = strdup(name);
    info->psz_value = value ? strdup(value) : NULL;
    return info;
}",29.0,38.0,1.0,1.0,10.0,9,6,11,4,1,0,2,2,0,0,,0,0,4,2,2,info_t
2092,52447,info_Delete,1,info_Delete,void info_Delete (info_t*),input\info.h,"static inline void info_Delete(info_t *i)
{
    free(i->psz_name);
    free(i->psz_value);
    free(i);
}",40.0,45.0,1.0,1.0,6.0,2,1,3,1,2,0,1,1,0,0,,0,0,2,1,1,void
2093,52462,info_category_New,1,info_category_New,info_category_t info_category_New (char*),input\info.h,"static inline info_category_t *info_category_New(const char *name)
{
    info_category_t *cat = malloc(sizeof(*cat));
    if (!cat)
        return NULL;
    cat->psz_name = strdup(name);
    cat->i_infos  = 0;
    cat->pp_infos = NULL;

    return cat;
}",47.0,57.0,1.0,1.0,11.0,10,5,10,3,2,0,2,2,0,0,,0,0,2,1,1,info_category_t
2094,52498,info_category_FindInfo,1,info_category_FindInfo,"info_t info_category_FindInfo (info_category_t*,int*,char*)",input\info.h,"static inline info_t *info_category_FindInfo(const info_category_t *cat,
                                             int *index, const char *name)
{
    for (int i = 0; i < cat->i_infos; i++) {
        if (!strcmp(cat->pp_infos[i]->psz_name, name)) {
            if (index)
                *index = i;
            return cat->pp_infos[i];
        }
    }
    return NULL;
}",59.0,70.0,1.0,1.0,12.0,11,6,12,5,4,0,4,7,0,0,,0,0,6,3,3,info_t
2095,52546,info_category_ReplaceInfo,1,info_category_ReplaceInfo,"void info_category_ReplaceInfo (info_category_t*,info_t*)",input\info.h,"static inline void info_category_ReplaceInfo(info_category_t *cat,
                                             info_t *info)
{
    int index;
    info_t *old = info_category_FindInfo(cat, &index, info->psz_name);
    if (old) {
        info_Delete(cat->pp_infos[index]);
        cat->pp_infos[index] = info;
    } else
        TAB_APPEND(cat->i_infos, cat->pp_infos, info);
}",72.0,82.0,1.0,1.0,11.0,8,4,10,4,0,2,2,2,0,2,,0,1,4,2,2,void
2096,52589,info_category_VaAddInfo,1,info_category_VaAddInfo,"info_t info_category_VaAddInfo (info_category_t*,char*,char*,va_list)",input\info.h,"static inline info_t *info_category_VaAddInfo(info_category_t *cat,
                                              const char *name,
                                              const char *format, va_list args)
{
    info_t *info = info_category_FindInfo(cat, NULL, name);
    if (!info) {
        info = info_New(name, NULL);
        if (!info)
            return NULL;
        TAB_APPEND(cat->i_infos, cat->pp_infos, info);
    } else
        free(info->psz_value);
    if (vasprintf(&info->psz_value, format, args) == -1)
        info->psz_value = NULL;
    return info;
}",84.0,99.0,1.0,1.0,16.0,12,6,19,6,2,2,4,5,0,2,,0,2,8,4,4,info_t
2097,52652,info_category_AddInfo,1,info_category_AddInfo,"info_t info_category_AddInfo (info_category_t*,char*,char*...)",input\info.h,"static inline info_t *info_category_AddInfo(info_category_t *cat,
                                            const char *name,
                                            const char *format, ...)
{
    va_list args;

    va_start(args, format);
    info_t *info = info_category_VaAddInfo(cat, name, format, args);
    va_end(args);

    return info;
}",101.0,112.0,1.0,1.0,12.0,1,1,9,5,2,1,1,1,0,1,,0,1,6,3,3,info_t
2098,52675,info_category_DeleteInfo,1,info_category_DeleteInfo,"int info_category_DeleteInfo (info_category_t*,char*)",input\info.h,"static inline int info_category_DeleteInfo(info_category_t *cat, const char *name)
{
    int index;
    if (info_category_FindInfo(cat, &index, name)) {
        info_Delete(cat->pp_infos[index]);
        TAB_ERASE(cat->i_infos, cat->pp_infos, index);
        return VLC_SUCCESS;
    }
    return VLC_EGENERIC;
}",114.0,123.0,1.0,1.0,10.0,5,3,10,5,1,2,2,2,1,2,,0,1,4,2,2,int
2099,52707,info_category_Delete,1,info_category_Delete,void info_category_Delete (info_category_t*),input\info.h,"static inline void info_category_Delete(info_category_t *cat)
{
    for (int i = 0; i < cat->i_infos; i++)
        info_Delete(cat->pp_infos[i]);
    free(cat->pp_infos);
    free(cat->psz_name);
    free(cat);
}",125.0,132.0,1.0,1.0,8.0,5,3,6,2,2,0,2,2,0,0,,0,0,2,1,1,void
2100,52794,Run,1,Run,void* Run (void*),input\input.c,"static void *Run( void *data )
{
    input_thread_private_t *priv = data;
    input_thread_t *p_input = &priv->input;

    vlc_interrupt_set(&priv->interrupt);

    if( !Init( p_input ) )
    {
        if( priv->b_can_pace_control && priv->b_out_pace_control )
        {
            /* We don't want a high input priority here or we'll
             * end-up sucking up all the CPU time */
            vlc_set_priority( priv->thread, VLC_THREAD_PRIORITY_LOW );
        }

        MainLoop( p_input, true ); /* FIXME it can be wrong (like with VLM) */

        /* Clean up */
        End( p_input );
    }

    input_SendEventDead( p_input );
    return NULL;
}",489.0,513.0,1.0,1.0,25.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void*
2101,52799,Preparse,1,Preparse,void* Preparse (void*),input\input.c,"static void *Preparse( void *data )
{
    input_thread_private_t *priv = data;
    input_thread_t *p_input = &priv->input;

    vlc_interrupt_set(&priv->interrupt);

    if( !Init( p_input ) )
    {   /* if the demux is a playlist, call Mainloop that will call
         * demux_Demux in order to fetch sub items */
        bool b_is_playlist = false;

        if ( input_item_ShouldPreparseSubItems( priv->p_item )
          && demux_Control( priv->master->p_demux, DEMUX_IS_PLAYLIST,
                            &b_is_playlist ) )
            b_is_playlist = false;
        if( b_is_playlist )
            MainLoop( p_input, false );
        End( p_input );
    }

    input_SendEventDead( p_input );
    return NULL;
}",515.0,538.0,1.0,1.0,24.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void*
2102,52804,Create,1,Create,"input_thread_t* Create (vlc_object_t*,input_item_t*,char*,ANY,input_resource_t*,vlc_renderer_item_t*)",input\input.c,"static input_thread_t *Create( vlc_object_t *p_parent, input_item_t *p_item,
                               const char *psz_header, bool b_preparsing,
                               input_resource_t *p_resource,
                               vlc_renderer_item_t *p_renderer )
{
    /* Allocate descriptor */
    input_thread_private_t *priv;

    priv = vlc_custom_create( p_parent, sizeof( *priv ), ""input"" );
    if( unlikely(priv == NULL) )
        return NULL;

    input_thread_t *p_input = &priv->input;

    char * psz_name = input_item_GetName( p_item );
    msg_Dbg( p_input, ""Creating an input for %s'%s'"",
             b_preparsing ? ""preparsing "" : """", psz_name);
    free( psz_name );

    /* Parse input options */
    input_item_ApplyOptions( VLC_OBJECT(p_input), p_item );

    p_input->obj.header = psz_header ? strdup( psz_header ) : NULL;

    /* Init Common fields */
    priv->b_preparsing = b_preparsing;
    priv->b_can_pace_control = true;
    priv->i_start = 0;
    priv-...",285.0,482.0,1.0,1.0,198.0,0,0,0,0,3,0,1,1,0,0,,0,0,12,6,6,input_thread_t
2103,52814,Init,1,Init,int Init (input_thread_t*),input\input.c,"static int Init( input_thread_t * p_input )
{
    input_thread_private_t *priv = input_priv(p_input);
    input_source_t *master;

    if( var_Type( p_input->obj.parent, ""meta-file"" ) )
    {
        msg_Dbg( p_input, ""Input is a meta file: disabling unneeded options"" );
        var_SetString( p_input, ""sout"", """" );
        var_SetBool( p_input, ""sout-all"", false );
        var_SetString( p_input, ""input-slave"", """" );
        var_SetInteger( p_input, ""input-repeat"", 0 );
        var_SetString( p_input, ""sub-file"", """" );
        var_SetBool( p_input, ""sub-autodetect-file"", false );
    }

    InitStatistics( p_input );
#ifdef ENABLE_SOUT
    if( InitSout( p_input ) )
        goto error;
#endif

    /* Create es out */
    priv->p_es_out = input_EsOutTimeshiftNew( p_input, priv->p_es_out_display,
                                              priv->i_rate );
    if( priv->p_es_out == NULL )
        goto error;

    /* */
    input_ChangeState( p_input, OPENING_S );
    input_SendEventC...",1344.0,1493.0,1.0,8.0,150.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
2104,52819,End,1,End,void End (input_thread_t*),input\input.c,"static void End( input_thread_t * p_input )
{
    input_thread_private_t *priv = input_priv(p_input);

    /* We are at the end */
    input_ChangeState( p_input, END_S );

    /* Clean control variables */
    input_ControlVarStop( p_input );

    /* Stop es out activity */
    es_out_SetMode( priv->p_es_out, ES_OUT_MODE_NONE );

    /* Delete slave */
    for( int i = 0; i < priv->i_slave; i++ )
        InputSourceDestroy( priv->slave[i] );
    free( priv->slave );

    /* Clean up master */
    InputSourceDestroy( priv->master );
    priv->i_title = 0;
    priv->title = NULL;
    priv->i_title_offset = 0;
    priv->i_seekpoint_offset = 0;

    /* Unload all modules */
    if( priv->p_es_out )
        es_out_Delete( priv->p_es_out );
    es_out_SetMode( priv->p_es_out_display, ES_OUT_MODE_END );

    if( !priv->b_preparsing )
    {
#define CL_CO( c ) \
do { \
    stats_CounterClean( priv->counters.p_##c ); \
    priv->counters.p_##c = NULL; \
} while (0)

        if( libvlc_stats(...",1498.0,1589.0,1.0,12.0,92.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
2105,52824,MainLoop,1,MainLoop,"void MainLoop (input_thread_t*,bool)",input\input.c,"static void MainLoop( input_thread_t *p_input, bool b_interactive )
{
    mtime_t i_intf_update = 0;
    mtime_t i_last_seek_mdate = 0;

    if( b_interactive && var_InheritBool( p_input, ""start-paused"" ) )
        ControlPause( p_input, mdate() );

    bool b_pause_after_eof = b_interactive &&
                           var_InheritBool( p_input, ""play-and-pause"" );
    bool b_paused_at_eof = false;

    demux_t *p_demux = input_priv(p_input)->master->p_demux;
    const bool b_can_demux = p_demux->pf_demux != NULL;

    while( !input_Stopped( p_input ) && input_priv(p_input)->i_state != ERROR_S )
    {
        mtime_t i_wakeup = -1;
        bool b_paused = input_priv(p_input)->i_state == PAUSE_S;
        /* FIXME if input_priv(p_input)->i_state == PAUSE_S the access/access_demux
         * is paused -> this may cause problem with some of them
         * The same problem can be seen when seeking while paused */
        if( b_paused )
            b_paused = !es_out_GetBuffering( input...",691.0,813.0,1.0,1.0,123.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
2106,52830,ControlPop,1,ControlPop,"int ControlPop (input_thread_t*,int*,vlc_value_t*,mtime_t,bool)",input\input.c,"static inline int ControlPop( input_thread_t *p_input,
                              int *pi_type, vlc_value_t *p_val,
                              mtime_t i_deadline, bool b_postpone_seek )
{
    input_thread_private_t *p_sys = input_priv(p_input);

    vlc_mutex_lock( &p_sys->lock_control );
    while( p_sys->i_control <= 0 ||
           ( b_postpone_seek && ControlIsSeekRequest( p_sys->control[0].i_type ) ) )
    {
        if( p_sys->is_stopped )
        {
            vlc_mutex_unlock( &p_sys->lock_control );
            return VLC_EGENERIC;
        }

        if( i_deadline >= 0 )
        {
            if( vlc_cond_timedwait( &p_sys->wait_control, &p_sys->lock_control,
                                    i_deadline ) )
            {
                vlc_mutex_unlock( &p_sys->lock_control );
                return VLC_EGENERIC;
            }
        }
        else
            vlc_cond_wait( &p_sys->wait_control, &p_sys->lock_control );
    }

    /* */
    const int i_index = Con...",1662.0,1711.0,1.0,1.0,50.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,int
2107,52839,ControlRelease,1,ControlRelease,"void ControlRelease (int,vlc_value_t)",input\input.c,"static void ControlRelease( int i_type, vlc_value_t val )
{
    switch( i_type )
    {
    case INPUT_CONTROL_ADD_SLAVE:
        if( val.p_address )
            input_item_slave_Delete( val.p_address );
        break;
    case INPUT_CONTROL_SET_VIEWPOINT:
    case INPUT_CONTROL_SET_INITIAL_VIEWPOINT:
    case INPUT_CONTROL_UPDATE_VIEWPOINT:
        free( val.p_address );
        break;
    case INPUT_CONTROL_SET_RENDERER:
        if( val.p_address )
            vlc_renderer_item_release( val.p_address );
        break;

    default:
        break;
    }
}",1738.0,1759.0,1.0,1.0,22.0,0,0,0,0,3,0,1,1,0,0,,0,0,4,2,2,void
2108,52845,ControlIsSeekRequest,1,ControlIsSeekRequest,bool ControlIsSeekRequest (int),input\input.c,"static bool ControlIsSeekRequest( int i_type )
{
    switch( i_type )
    {
    case INPUT_CONTROL_SET_POSITION:
    case INPUT_CONTROL_SET_TIME:
    case INPUT_CONTROL_SET_TITLE:
    case INPUT_CONTROL_SET_TITLE_NEXT:
    case INPUT_CONTROL_SET_TITLE_PREV:
    case INPUT_CONTROL_SET_SEEKPOINT:
    case INPUT_CONTROL_SET_SEEKPOINT_NEXT:
    case INPUT_CONTROL_SET_SEEKPOINT_PREV:
    case INPUT_CONTROL_SET_BOOKMARK:
    case INPUT_CONTROL_NAV_ACTIVATE:
    case INPUT_CONTROL_NAV_UP:
    case INPUT_CONTROL_NAV_DOWN:
    case INPUT_CONTROL_NAV_LEFT:
    case INPUT_CONTROL_NAV_RIGHT:
    case INPUT_CONTROL_NAV_POPUP:
    case INPUT_CONTROL_NAV_MENU:
        return true;
    default:
        return false;
    }
}",1712.0,1736.0,1.0,1.0,25.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,bool
2109,52857,ControlPause,1,ControlPause,"void ControlPause (input_thread_t*,ANY)",input\input.c,"static void ControlPause( input_thread_t *p_input, mtime_t i_control_date )
{
    int i_state = PAUSE_S;

    if( input_priv(p_input)->b_can_pause )
    {
        demux_t *p_demux = input_priv(p_input)->master->p_demux;

        if( demux_Control( p_demux, DEMUX_SET_PAUSE_STATE, true ) )
        {
            msg_Warn( p_input, ""cannot set pause state"" );
            return;
        }
    }

    /* */
    if( es_out_SetPauseState( input_priv(p_input)->p_es_out, input_priv(p_input)->b_can_pause,
                              true, i_control_date ) )
    {
        msg_Warn( p_input, ""cannot set pause state at es_out level"" );
        return;
    }

    /* Switch to new state */
    input_ChangeState( p_input, i_state );
}",1762.0,1787.0,1.0,1.0,26.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
2110,52863,UpdateTitleSeekpointFromDemux,1,UpdateTitleSeekpointFromDemux,int UpdateTitleSeekpointFromDemux (input_thread_t*),input\input.c,"static int UpdateTitleSeekpointFromDemux( input_thread_t *p_input )
{
    demux_t *p_demux = input_priv(p_input)->master->p_demux;

    /* TODO event-like */
    if( demux_TestAndClearFlags( p_demux, INPUT_UPDATE_TITLE ) )
        input_SendEventTitle( p_input, demux_GetTitle( p_demux ) );

    if( demux_TestAndClearFlags( p_demux, INPUT_UPDATE_SEEKPOINT ) )
        input_SendEventSeekpoint( p_input, demux_GetTitle( p_demux ),
                                  demux_GetSeekpoint( p_demux ) );

    return UpdateTitleSeekpoint( p_input,
                                 demux_GetTitle( p_demux ),
                                 demux_GetSeekpoint( p_demux ) );
}",2494.0,2509.0,1.0,1.0,16.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
2111,52868,UpdateGenericFromDemux,1,UpdateGenericFromDemux,void UpdateGenericFromDemux (input_thread_t*),input\input.c,"static void UpdateGenericFromDemux( input_thread_t *p_input )
{
    demux_t *p_demux = input_priv(p_input)->master->p_demux;

    if( demux_TestAndClearFlags( p_demux, INPUT_UPDATE_META ) )
        InputUpdateMeta( p_input, p_demux );

    {
        double quality;
        double strength;

        if( !demux_Control( p_demux, DEMUX_GET_SIGNAL, &quality, &strength ) )
            input_SendEventSignal( p_input, quality, strength );
    }
}",2511.0,2525.0,1.0,1.0,15.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
2112,52873,UpdateTitleListfromDemux,1,UpdateTitleListfromDemux,void UpdateTitleListfromDemux (input_thread_t*),input\input.c,"static void UpdateTitleListfromDemux( input_thread_t *p_input )
{
    input_thread_private_t *priv = input_priv(p_input);
    input_source_t *in = priv->master;

    vlc_mutex_lock( &priv->p_item->lock );
    /* Delete the preexisting titles */
    if( in->i_title > 0 )
    {
        for( int i = 0; i < in->i_title; i++ )
            vlc_input_title_Delete( in->title[i] );
        TAB_CLEAN( in->i_title, in->title );
        priv->i_title = 0;
        priv->title = NULL;
        in->b_title_demux = false;
    }

    /* Get the new title list */
    if( demux_Control( in->p_demux, DEMUX_GET_TITLE_INFO,
                       &in->title, &in->i_title,
                       &in->i_title_offset, &in->i_seekpoint_offset ) )
        TAB_INIT( in->i_title, in->title );
    else
        in->b_title_demux = true;

    vlc_mutex_unlock( &priv->p_item->lock );

    InitTitle( p_input );
}",2527.0,2555.0,1.0,1.0,29.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
2113,52878,MRLSections,1,MRLSections,"void MRLSections (char*,int*,int*,int*,int*)",input\input.c,"static void MRLSections( const char *p,
                         int *pi_title_start, int *pi_title_end,
                         int *pi_chapter_start, int *pi_chapter_end )
{
    *pi_title_start = *pi_title_end = *pi_chapter_start = *pi_chapter_end = -1;

    int title_start, chapter_start, title_end, chapter_end;

    if( !p )
        return;

    if( *p != '-' )
        p = MRLSeekPoint( p, &title_start, &chapter_start );
    else
        title_start = chapter_start = -1;

    if( *p == '-' )
        p = MRLSeekPoint( p + 1, &title_end, &chapter_end );
    else
        title_end = chapter_end = -1;

    if( *p ) /* syntax error */
        return;

    *pi_title_start = title_start;
    *pi_title_end = title_end;
    *pi_chapter_start = chapter_start;
    *pi_chapter_end = chapter_end;
}",3345.0,3373.0,1.0,1.0,29.0,0,0,0,0,2,0,1,1,0,0,,0,0,10,5,5,void
2114,52887,InputSourceNew,1,InputSourceNew,"input_source_t* InputSourceNew (input_thread_t*,char*,char*,bool)",input\input.c,"static input_source_t *InputSourceNew( input_thread_t *p_input,
                                       const char *psz_mrl,
                                       const char *psz_forced_demux,
                                       bool b_in_can_fail )
{
    input_thread_private_t *priv = input_priv(p_input);
    input_source_t *in = vlc_custom_create( p_input, sizeof( *in ),
                                            ""input source"" );
    if( unlikely(in == NULL) )
        return NULL;

    const char *psz_access, *psz_demux, *psz_path, *psz_anchor = NULL;

    assert( psz_mrl );
    char *psz_dup = strdup( psz_mrl );
    char *psz_demux_var = NULL;

    if( psz_dup == NULL )
    {
        vlc_object_release( in );
        return NULL;
    }

    /* Split uri */
    input_SplitMRL( &psz_access, &psz_demux, &psz_path, &psz_anchor, psz_dup );

    if( psz_demux == NULL || psz_demux[0] == '\0' )
        psz_demux = psz_demux_var = var_InheritString( in, ""demux"" );

    if( psz_forced...",2651.0,2866.0,1.0,30.0,216.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,input_source_t
2115,52895,InputSourceDestroy,1,InputSourceDestroy,void InputSourceDestroy (input_source_t*),input\input.c,"static void InputSourceDestroy( input_source_t *in )
{
    int i;

    if( in->p_demux )
        demux_Delete( in->p_demux );

    if( in->i_title > 0 )
    {
        for( i = 0; i < in->i_title; i++ )
            vlc_input_title_Delete( in->title[i] );
        TAB_CLEAN( in->i_title, in->title );
    }

    vlc_object_release( in );
}",2871.0,2886.0,1.0,1.0,16.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2116,52900,InputSourceMeta,1,InputSourceMeta,"void InputSourceMeta (input_thread_t*,input_source_t*,vlc_meta_t*)",input\input.c,"static void InputSourceMeta( input_thread_t *p_input,
                             input_source_t *p_source, vlc_meta_t *p_meta )
{
    demux_t *p_demux = p_source->p_demux;

    /* XXX Remember that checking against p_item->p_meta->i_status & ITEM_PREPARSED
     * is a bad idea */

    bool has_meta = false;

    /* Read demux meta */
    if( !demux_Control( p_demux, DEMUX_GET_META, p_meta ) )
        has_meta = true;

    bool has_unsupported;
    if( demux_Control( p_demux, DEMUX_HAS_UNSUPPORTED_META, &has_unsupported ) )
        has_unsupported = true;

    /* If the demux report unsupported meta data, or if we don't have meta data
     * try an external ""meta reader"" */
    if( has_meta && !has_unsupported )
        return;

    demux_meta_t *p_demux_meta =
        vlc_custom_create( p_source, sizeof( *p_demux_meta ), ""demux meta"" );
    if( unlikely(p_demux_meta == NULL) )
        return;
    p_demux_meta->p_item = input_priv(p_input)->p_item;

    module_t *p_id3 = module_nee...",2891.0,2939.0,1.0,1.0,49.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
2117,52907,SlaveDemux,1,SlaveDemux,void SlaveDemux (input_thread_t*),input\input.c,"static void SlaveDemux( input_thread_t *p_input )
{
    int64_t i_time;
    int i;

    if( demux_Control( input_priv(p_input)->master->p_demux, DEMUX_GET_TIME, &i_time ) )
    {
        msg_Err( p_input, ""demux doesn't like DEMUX_GET_TIME"" );
        return;
    }

    for( i = 0; i < input_priv(p_input)->i_slave; i++ )
    {
        input_source_t *in = input_priv(p_input)->slave[i];
        int i_ret;

        if( in->b_eof )
            continue;

        /* Call demux_Demux until we have read enough data */
        if( demux_Control( in->p_demux, DEMUX_SET_NEXT_DEMUX_TIME, i_time ) )
        {
            for( ;; )
            {
                int64_t i_stime;
                if( demux_Control( in->p_demux, DEMUX_GET_TIME, &i_stime ) )
                {
                    msg_Err( p_input, ""slave[%d] doesn't like ""
                             ""DEMUX_GET_TIME -> EOF"", i );
                    i_ret = 0;
                    break;
                }

                if( i_stime...",2942.0,2996.0,1.0,1.0,55.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2118,52912,SlaveSeek,1,SlaveSeek,void SlaveSeek (input_thread_t*),input\input.c,"static void SlaveSeek( input_thread_t *p_input )
{
    int64_t i_time;
    int i;

    if( demux_Control( input_priv(p_input)->master->p_demux, DEMUX_GET_TIME, &i_time ) )
    {
        msg_Err( p_input, ""demux doesn't like DEMUX_GET_TIME"" );
        return;
    }

    for( i = 0; i < input_priv(p_input)->i_slave; i++ )
    {
        input_source_t *in = input_priv(p_input)->slave[i];

        if( demux_Control( in->p_demux, DEMUX_SET_TIME, i_time, true ) )
        {
            if( !in->b_eof )
                msg_Err( p_input, ""seek failed for slave %d -> EOF"", i );
            in->b_eof = true;
        }
        else
        {
            in->b_eof = false;
        }
    }
}",2998.0,3024.0,1.0,1.0,27.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2119,52917,InputMetaUser,1,InputMetaUser,"void InputMetaUser (input_thread_t*,vlc_meta_t*)",input\input.c,"static void InputMetaUser( input_thread_t *p_input, vlc_meta_t *p_meta )
{
    static const struct { int i_meta; const char *psz_name; } p_list[] = {
        { vlc_meta_Title,       ""meta-title"" },
        { vlc_meta_Artist,      ""meta-artist"" },
        { vlc_meta_Genre,       ""meta-genre"" },
        { vlc_meta_Copyright,   ""meta-copyright"" },
        { vlc_meta_Description, ""meta-description"" },
        { vlc_meta_Date,        ""meta-date"" },
        { vlc_meta_URL,         ""meta-url"" },
        { 0, NULL }
    };

    /* Get meta information from user */
    for( int i = 0; p_list[i].psz_name; i++ )
    {
        char *psz_string = var_GetNonEmptyString( p_input, p_list[i].psz_name );
        if( !psz_string )
            continue;

        EnsureUTF8( psz_string );
        vlc_meta_Set( p_meta, p_list[i].i_meta, psz_string );
        free( psz_string );
    }
}",3029.0,3053.0,1.0,1.0,25.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
2120,52923,InputUpdateMeta,1,InputUpdateMeta,"void InputUpdateMeta (input_thread_t*,demux_t*)",input\input.c,"static void InputUpdateMeta( input_thread_t *p_input, demux_t *p_demux )
{
    vlc_meta_t *p_meta = vlc_meta_New();
    if( unlikely(p_meta == NULL) )
        return;

    demux_Control( p_demux, DEMUX_GET_META, p_meta );

    /* If metadata changed, then the attachments might have changed.
       We need to update them in case they contain album art. */
    input_attachment_t **attachment;
    int i_attachment;

    if( !demux_Control( p_demux, DEMUX_GET_ATTACHMENTS,
                        &attachment, &i_attachment ) )
    {
        vlc_mutex_lock( &input_priv(p_input)->p_item->lock );
        if( input_priv(p_input)->i_attachment > 0 )
        {
            int j = 0;
            for( int i = 0; i < input_priv(p_input)->i_attachment; i++ )
            {
                if( input_priv(p_input)->attachment_demux[i] == p_demux )
                    vlc_input_attachment_Delete( input_priv(p_input)->attachment[i] );
                else
                {
                    input_pri...",3095.0,3135.0,1.0,1.0,41.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
2121,52929,InputGetExtraFiles,1,InputGetExtraFiles,"void InputGetExtraFiles (input_thread_t*,int*,char***,char**,char*)",input\input.c,"static void InputGetExtraFiles( input_thread_t *p_input,
                                int *pi_list, char ***pppsz_list,
                                const char **ppsz_access, const char *psz_path )
{
    static const struct pattern
    {
        const char *psz_access_force;
        const char *psz_match;
        const char *psz_format;
        int i_start;
        int i_stop;
    } patterns[] = {
        /* XXX the order is important */
        { ""concat"", "".001"", ""%s.%.3d"", 2, 999 },
        { NULL, "".part1.rar"",""%s.part%.1d.rar"", 2, 9 },
        { NULL, "".part01.rar"",""%s.part%.2d.rar"", 2, 99, },
        { NULL, "".part001.rar"", ""%s.part%.3d.rar"", 2, 999 },
        { NULL, "".rar"", ""%s.r%.2d"", 0, 99 },
        { ""concat"", "".mts"", ""%s.mts%d"", 1, 999 },
    };

    TAB_INIT( *pi_list, *pppsz_list );

    if( ( **ppsz_access && strcmp( *ppsz_access, ""file"" ) ) || !psz_path )
        return;

    const size_t i_path = strlen(psz_path);

    for( size_t i = 0; i < ARRAY_SIZE( patte...",3194.0,3240.0,1.0,1.0,47.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,void
2122,52938,AppendAttachment,1,AppendAttachment,"void AppendAttachment (int*,input_attachment_t***,demux_t***,int,input_attachment_t**,demux_t*)",input\input.c,"static void AppendAttachment( int *pi_attachment, input_attachment_t ***ppp_attachment,
                              const demux_t ***ppp_attachment_demux,
                              int i_new, input_attachment_t **pp_new, const demux_t *p_demux )
{
    int i_attachment = *pi_attachment;
    int i;

    input_attachment_t **pp_att = realloc( *ppp_attachment,
                    sizeof(*pp_att) * ( i_attachment + i_new ) );
    if( likely(pp_att) )
    {
        *ppp_attachment = pp_att;
        const demux_t **pp_attdmx = realloc( *ppp_attachment_demux,
                        sizeof(*pp_attdmx) * ( i_attachment + i_new ) );
        if( likely(pp_attdmx) )
        {
            *ppp_attachment_demux = pp_attdmx;

            for( i = 0; i < i_new; i++ )
            {
                pp_att[i_attachment] = pp_new[i];
                pp_attdmx[i_attachment++] = p_demux;
            }
            /* */
            *pi_attachment = i_attachment;
            free( pp_new );
         ...",3055.0,3089.0,1.0,1.0,35.0,0,0,0,0,0,0,1,1,0,0,,0,0,12,6,6,void
2123,52948,input_SlaveSourceAdd,1,input_SlaveSourceAdd,"int input_SlaveSourceAdd (input_thread_t*,slave_type,char*,unsigned)",input\input.c,"static int input_SlaveSourceAdd( input_thread_t *p_input,
                                 enum slave_type i_type, const char *psz_uri,
                                 unsigned i_flags )
{
    vlc_value_t count;
    const char *psz_es;
    const char *psz_forced_demux;
    const bool b_can_fail = i_flags & SLAVE_ADD_CANFAIL;
    const bool b_forced = i_flags & SLAVE_ADD_FORCED;
    const bool b_set_time = i_flags & SLAVE_ADD_SET_TIME;

    switch( i_type )
    {
    case SLAVE_TYPE_SPU:
        psz_es = ""spu-es"";
        psz_forced_demux = ""subtitle"";
        break;
    case SLAVE_TYPE_AUDIO:
        psz_es = ""audio-es"";
        psz_forced_demux = NULL;
        break;
    default:
        vlc_assert_unreachable();
    }

    if( b_forced )
        var_Change( p_input, psz_es, VLC_VAR_CHOICESCOUNT, &count, NULL );

    msg_Dbg( p_input, ""loading %s slave: %s (forced: %d)"", psz_es, psz_uri,
             b_forced );

    input_source_t *p_source = InputSourceNew( p_input, psz_uri,
   ...",3375.0,3472.0,1.0,38.0,98.0,0,0,0,0,2,0,1,1,0,0,,0,0,8,4,4,int
2124,52956,input_SubtitleFile2Uri,1,input_SubtitleFile2Uri,"char* input_SubtitleFile2Uri (input_thread_t*,char*)",input\input.c,"static char *input_SubtitleFile2Uri( input_thread_t *p_input,
                                     const char *psz_subtitle )
{
    /* if we are provided a subtitle.sub file,
     * see if we don't have a subtitle.idx and use it instead */
    char *psz_idxpath = NULL;
    char *psz_extension = strrchr( psz_subtitle, '.');
    if( psz_extension && strcmp( psz_extension, "".sub"" ) == 0 )
    {
        psz_idxpath = strdup( psz_subtitle );
        if( psz_idxpath )
        {
            struct stat st;

            psz_extension = psz_extension - psz_subtitle + psz_idxpath;
            strcpy( psz_extension, "".idx"" );

            if( !vlc_stat( psz_idxpath, &st ) && S_ISREG( st.st_mode ) )
            {
                msg_Dbg( p_input, ""using %s as subtitle file instead of %s"",
                         psz_idxpath, psz_subtitle );
                psz_subtitle = psz_idxpath;
            }
        }
    }

    char *psz_uri = vlc_path2uri( psz_subtitle, NULL );
    free( psz_idxpath );...",3474.0,3503.0,1.0,1.0,30.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,char*
2125,52962,input_ChangeState,1,input_ChangeState,"void input_ChangeState (input_thread_t*,int)",input\input.c,"static void input_ChangeState( input_thread_t *p_input, int i_state )
{
    if( input_priv(p_input)->i_state == i_state )
        return;

    input_priv(p_input)->i_state = i_state;
    if( i_state == ERROR_S )
        input_item_SetErrorWhenReading( input_priv(p_input)->p_item, true );
    else if ( i_state == PLAYING_S )
        input_item_SetErrorWhenReading( input_priv(p_input)->p_item, false );
    input_SendEventState( p_input, i_state );
}",3243.0,3254.0,1.0,1.0,12.0,0,0,0,0,3,0,1,1,0,0,,0,0,4,2,2,void
2126,52968,input_Create,1,input_Create,"input_thread_t input_Create (vlc_object_t*,input_item_t*,char*,input_resource_t*,vlc_renderer_item_t*)",input\input.c,"input_thread_t *input_Create( vlc_object_t *p_parent,
                              input_item_t *p_item,
                              const char *psz_log, input_resource_t *p_resource,
                              vlc_renderer_item_t *p_renderer )
{
    return Create( p_parent, p_item, psz_log, false, p_resource, p_renderer );
}",128.0,134.0,1.0,1.0,7.0,0,0,6,6,2,1,1,1,0,1,,0,0,10,5,5,input_thread_t
2127,52985,input_Read,1,input_Read,"int input_Read (vlc_object_t*,input_item_t*)",input\input.c,"int input_Read( vlc_object_t *p_parent, input_item_t *p_item )
{
    input_thread_t *p_input = Create( p_parent, p_item, NULL, false, NULL, NULL );
    if( !p_input )
        return VLC_EGENERIC;

    if( !Init( p_input ) )
    {
        MainLoop( p_input, false );
        End( p_input );
    }

    vlc_object_release( p_input );
    return VLC_SUCCESS;
}",144.0,158.0,1.0,1.0,15.0,3,2,15,7,2,5,3,3,1,5,,0,2,4,2,2,int
2128,53021,input_CreatePreparser,1,input_CreatePreparser,"input_thread_t input_CreatePreparser (vlc_object_t*,input_item_t*)",input\input.c,"input_thread_t *input_CreatePreparser( vlc_object_t *parent,
                                       input_item_t *item )
{
    return Create( parent, item, NULL, true, NULL, NULL );
}",160.0,164.0,1.0,1.0,5.0,0,0,6,4,1,1,1,1,0,1,,0,0,4,2,2,input_thread_t
2129,53035,input_Start,1,input_Start,int input_Start (input_thread_t*),input\input.c,"int input_Start( input_thread_t *p_input )
{
    input_thread_private_t *priv = input_priv(p_input);
    void *(*func)(void *) = Run;

    if( priv->b_preparsing )
        func = Preparse;

    assert( !priv->is_running );
    /* Create thread and wait for its readiness. */
    priv->is_running = !vlc_clone( &priv->thread, func, priv,
                                   VLC_THREAD_PRIORITY_INPUT );
    if( !priv->is_running )
    {
        input_ChangeState( p_input, ERROR_S );
        msg_Err( p_input, ""cannot create input thread"" );
        return VLC_EGENERIC;
    }
    return VLC_SUCCESS;
}",173.0,192.0,1.0,1.0,20.0,12,4,17,8,3,8,3,3,2,3,,0,7,2,1,1,int
2130,53043,func,1,input_Start.func,void* input_Start.func (void*),input\input.c,void *(*func)(void *) = Run;,176.0,176.0,10.0,31.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void*
2131,53092,input_Stop,1,input_Stop,void input_Stop (input_thread_t*),input\input.c,"void input_Stop( input_thread_t *p_input )
{
    input_thread_private_t *sys = input_priv(p_input);

    vlc_mutex_lock( &sys->lock_control );
    /* Discard all pending controls */
    for( int i = 0; i < sys->i_control; i++ )
    {
        input_control_t *ctrl = &sys->control[i];
        ControlRelease( ctrl->i_type, ctrl->val );
    }
    sys->i_control = 0;
    sys->is_stopped = true;
    vlc_cond_signal( &sys->wait_control );
    vlc_mutex_unlock( &sys->lock_control );
    vlc_interrupt_kill( &sys->interrupt );
}",199.0,215.0,1.0,1.0,17.0,22,5,17,5,4,16,2,2,1,6,,0,11,2,1,1,void
2132,53162,input_Close,1,input_Close,void input_Close (input_thread_t*),input\input.c,"void input_Close( input_thread_t *p_input )
{
    if( input_priv(p_input)->is_running )
        vlc_join( input_priv(p_input)->thread, NULL );
    vlc_interrupt_deinit( &input_priv(p_input)->interrupt );
    vlc_object_release( p_input );
}",222.0,228.0,1.0,1.0,7.0,4,2,5,2,6,6,2,2,1,6,,0,3,2,1,1,void
2133,53187,input_Destructor,1,input_Destructor,void input_Destructor (vlc_object_t*),input\input.c,"static void input_Destructor( vlc_object_t *obj )
{
    input_thread_t *p_input = (input_thread_t *)obj;
    input_thread_private_t *priv = input_priv(p_input);
#ifndef NDEBUG
    char * psz_name = input_item_GetName( priv->p_item );
    msg_Dbg( p_input, ""Destroying the input for '%s'"", psz_name);
    free( psz_name );
#endif

    if( priv->p_renderer )
        vlc_renderer_item_release( priv->p_renderer );
    if( priv->p_es_out_display )
        es_out_Delete( priv->p_es_out_display );

    if( priv->p_resource )
        input_resource_Release( priv->p_resource );
    if( priv->p_resource_private )
        input_resource_Release( priv->p_resource_private );

    input_item_Release( priv->p_item );

    vlc_mutex_destroy( &priv->counters.counters_lock );

    for( int i = 0; i < priv->i_control; i++ )
    {
        input_control_t *p_ctrl = &priv->control[i];
        ControlRelease( p_ctrl->i_type, p_ctrl->val );
    }

    vlc_cond_destroy( &priv->wait_control );
    vlc_mutex_de...",233.0,265.0,1.0,1.0,33.0,30,7,29,6,0,26,6,6,5,10,,0,18,2,1,1,void
2134,53303,input_GetItem,1,input_GetItem,input_item_t input_GetItem (input_thread_t*),input\input.c,"input_item_t *input_GetItem( input_thread_t *p_input )
{
    assert( p_input != NULL );
    return input_priv(p_input)->p_item;
}",273.0,277.0,1.0,1.0,5.0,2,2,3,2,3,1,1,1,0,1,,0,0,2,1,1,input_item_t
2135,54024,input_Stopped,1,input_Stopped,bool input_Stopped (input_thread_t*),input\input.c,"bool input_Stopped( input_thread_t *input )
{
    input_thread_private_t *sys = input_priv(input);
    bool ret;

    vlc_mutex_lock( &sys->lock_control );
    ret = sys->is_stopped;
    vlc_mutex_unlock( &sys->lock_control );
    return ret;
}",540.0,549.0,1.0,1.0,10.0,7,3,7,3,0,6,1,1,0,3,,0,4,2,1,1,bool
2136,54052,MainLoopDemux,1,MainLoopDemux,"void MainLoopDemux (input_thread_t*,bool*)",input\input.c,"static void MainLoopDemux( input_thread_t *p_input, bool *pb_changed )
{
    input_thread_private_t* p_priv = input_priv(p_input);
    demux_t *p_demux = p_priv->master->p_demux;
    int i_ret = VLC_DEMUXER_SUCCESS;

    *pb_changed = false;

    if( p_priv->i_stop > 0 )
    {
        if( demux_Control( p_demux, DEMUX_GET_TIME, &p_priv->i_time ) )
            p_priv->i_time = 0;

        if( p_priv->i_stop <= p_priv->i_time )
            i_ret = VLC_DEMUXER_EOF;
    }

    if( i_ret == VLC_DEMUXER_SUCCESS )
        i_ret = demux_Demux( p_demux );

    i_ret = i_ret > 0 ? VLC_DEMUXER_SUCCESS : ( i_ret < 0 ? VLC_DEMUXER_EGENERIC : VLC_DEMUXER_EOF);

    if( i_ret == VLC_DEMUXER_SUCCESS )
    {
        if( demux_TestAndClearFlags( p_demux, INPUT_UPDATE_TITLE_LIST ) )
            UpdateTitleListfromDemux( p_input );

        if( p_priv->master->b_title_demux )
        {
            i_ret = UpdateTitleSeekpointFromDemux( p_input );
            *pb_changed = true;
        }

        Updat...",559.0,607.0,1.0,1.0,49.0,35,9,44,12,0,15,9,13,6,6,,0,12,4,2,2,void
2137,54203,MainLoopTryRepeat,1,MainLoopTryRepeat,int MainLoopTryRepeat (input_thread_t*),input\input.c,"static int MainLoopTryRepeat( input_thread_t *p_input )
{
    int i_repeat = var_GetInteger( p_input, ""input-repeat"" );
    if( i_repeat <= 0 )
        return VLC_EGENERIC;

    vlc_value_t val;

    msg_Dbg( p_input, ""repeating the same input (%d)"", i_repeat );
    if( i_repeat > 0 )
    {
        i_repeat--;
        var_SetInteger( p_input, ""input-repeat"", i_repeat );
    }

    /* Seek to start title/seekpoint */
    val.i_int = input_priv(p_input)->master->i_title_start -
        input_priv(p_input)->master->i_title_offset;
    if( val.i_int < 0 || val.i_int >= input_priv(p_input)->master->i_title )
        val.i_int = 0;
    input_ControlPush( p_input,
                       INPUT_CONTROL_SET_TITLE, &val );

    val.i_int = input_priv(p_input)->master->i_seekpoint_start -
        input_priv(p_input)->master->i_seekpoint_offset;
    if( val.i_int > 0 /* TODO: check upper boundary */ )
        input_ControlPush( p_input,
                           INPUT_CONTROL_SET_SEEKPOINT, &va...",609.0,651.0,1.0,1.0,43.0,37,11,34,8,0,10,6,6,2,10,,0,7,2,1,1,int
2138,54346,MainLoopStatistics,1,MainLoopStatistics,void MainLoopStatistics (input_thread_t*),input\input.c,"static void MainLoopStatistics( input_thread_t *p_input )
{
    double f_position = 0.0;
    mtime_t i_time = 0;
    mtime_t i_length = 0;

    /* update input status variables */
    if( demux_Control( input_priv(p_input)->master->p_demux,
                       DEMUX_GET_POSITION, &f_position ) )
        f_position = 0.0;

    if( demux_Control( input_priv(p_input)->master->p_demux,
                       DEMUX_GET_TIME, &i_time ) )
        i_time = 0;
    input_priv(p_input)->i_time = i_time;

    if( demux_Control( input_priv(p_input)->master->p_demux,
                       DEMUX_GET_LENGTH, &i_length ) )
        i_length = 0;

    es_out_SetTimes( input_priv(p_input)->p_es_out, f_position, i_time, i_length );

    /* update current bookmark */
    vlc_mutex_lock( &input_priv(p_input)->p_item->lock );
    input_priv(p_input)->bookmark.i_time_offset = i_time;
    vlc_mutex_unlock( &input_priv(p_input)->p_item->lock );

    stats_ComputeInputStats( p_input, input_priv(p_input)->p...",656.0,685.0,1.0,1.0,30.0,29,4,28,7,0,14,4,4,3,14,,0,7,2,1,1,void
2139,54779,InitStatistics,1,InitStatistics,void InitStatistics (input_thread_t*),input\input.c,"static void InitStatistics( input_thread_t *p_input )
{
    input_thread_private_t *priv = input_priv(p_input);

    if( priv->b_preparsing ) return;

    /* Prepare statistics */
#define INIT_COUNTER( c, compute ) free( priv->counters.p_##c ); \
    priv->counters.p_##c = \
 stats_CounterCreate( STATS_##compute);
    if( libvlc_stats( p_input ) )
    {
        INIT_COUNTER( read_bytes, COUNTER );
        INIT_COUNTER( read_packets, COUNTER );
        INIT_COUNTER( demux_read, COUNTER );
        INIT_COUNTER( input_bitrate, DERIVATIVE );
        INIT_COUNTER( demux_bitrate, DERIVATIVE );
        INIT_COUNTER( demux_corrupted, COUNTER );
        INIT_COUNTER( demux_discontinuity, COUNTER );
        INIT_COUNTER( played_abuffers, COUNTER );
        INIT_COUNTER( lost_abuffers, COUNTER );
        INIT_COUNTER( displayed_pictures, COUNTER );
        INIT_COUNTER( lost_pictures, COUNTER );
        INIT_COUNTER( decoded_audio, COUNTER );
        INIT_COUNTER( decoded_video, COUNTER );
   ...",815.0,845.0,1.0,8.0,31.0,81,3,52,5,0,16,3,3,1,15,,0,16,2,1,1,void
2140,55044,InitTitle,1,InitTitle,void InitTitle (input_thread_t*),input\input.c,"static void InitTitle( input_thread_t * p_input )
{
    input_thread_private_t *priv = input_priv(p_input);
    input_source_t *p_master = priv->master;

    if( priv->b_preparsing )
        return;

    vlc_mutex_lock( &priv->p_item->lock );
    /* Create global title (from master) */
    priv->i_title = p_master->i_title;
    priv->title   = p_master->title;
    priv->i_title_offset = p_master->i_title_offset;
    priv->i_seekpoint_offset = p_master->i_seekpoint_offset;
    if( priv->i_title > 0 )
    {
        /* Setup variables */
        input_ControlVarNavigation( p_input );
        input_SendEventTitle( p_input, 0 );
    }

    /* Global flag */
    priv->b_can_pace_control = p_master->b_can_pace_control;
    priv->b_can_pause        = p_master->b_can_pause;
    priv->b_can_rate_control = p_master->b_can_rate_control;
    vlc_mutex_unlock( &priv->p_item->lock );
}",898.0,924.0,1.0,1.0,27.0,33,4,24,3,0,24,3,3,2,5,,0,20,2,1,1,void
2141,55141,StartTitle,1,StartTitle,void StartTitle (input_thread_t*),input\input.c,"static void StartTitle( input_thread_t * p_input )
{
    input_thread_private_t *priv = input_priv(p_input);
    vlc_value_t val;

    /* Start title/chapter */
    val.i_int = priv->master->i_title_start - priv->master->i_title_offset;
    if( val.i_int > 0 && val.i_int < priv->master->i_title )
        input_ControlPush( p_input, INPUT_CONTROL_SET_TITLE, &val );

    val.i_int = priv->master->i_seekpoint_start -
                priv->master->i_seekpoint_offset;
    if( val.i_int > 0 /* TODO: check upper boundary */ )
        input_ControlPush( p_input, INPUT_CONTROL_SET_SEEKPOINT, &val );

    /* Start/stop/run time */
    priv->i_start = llroundf(1000000.f
                                     * var_GetFloat( p_input, ""start-time"" ));
    priv->i_stop  = llroundf(1000000.f
                                     * var_GetFloat( p_input, ""stop-time"" ));
    if( priv->i_stop <= 0 )
    {
        priv->i_stop = llroundf(1000000.f
                                     * var_GetFloat( p_in...",926.0,975.0,1.0,1.0,50.0,57,10,41,7,0,22,7,8,7,4,,0,19,2,1,1,void
2142,55328,SlaveCompare,1,SlaveCompare,"int SlaveCompare (void*,void*)",input\input.c,"static int SlaveCompare(const void *a, const void *b)
{
    const input_item_slave_t *p_slave0 = *((const input_item_slave_t **) a);
    const input_item_slave_t *p_slave1 = *((const input_item_slave_t **) b);

    if( p_slave0 == NULL || p_slave1 == NULL )
    {
        /* Put NULL (or rejected) subs at the end */
        return p_slave0 == NULL ? 1 : p_slave1 == NULL ? -1 : 0;
    }

    if( p_slave0->i_priority > p_slave1->i_priority )
        return -1;

    if( p_slave0->i_priority < p_slave1->i_priority )
        return 1;

    return 0;
}",977.0,995.0,1.0,1.0,19.0,21,10,16,5,0,0,4,4,0,0,,0,0,4,2,2,int
2143,55395,SlaveExists,1,SlaveExists,"bool SlaveExists (input_item_slave_t**,int,char*)",input\input.c,"static bool SlaveExists( input_item_slave_t **pp_slaves, int i_slaves,
                         const char *psz_uri)
{
    for( int i = 0; i < i_slaves; i++ )
    {
        if( pp_slaves[i] != NULL
         && !strcmp( pp_slaves[i]->psz_uri, psz_uri ) )
            return true;
    }
    return false;
}",997.0,1007.0,1.0,1.0,11.0,8,7,11,7,1,0,3,4,0,0,,0,0,6,3,3,bool
2144,55434,SetSubtitlesOptions,1,SetSubtitlesOptions,void SetSubtitlesOptions (input_thread_t*),input\input.c,"static void SetSubtitlesOptions( input_thread_t *p_input )
{
    /* Get fps and set it if not already set */
    const float f_fps = input_priv(p_input)->master->f_fps;
    if( f_fps > 1.f )
    {
        var_Create( p_input, ""sub-original-fps"", VLC_VAR_FLOAT );
        var_SetFloat( p_input, ""sub-original-fps"", f_fps );

        float f_requested_fps = var_CreateGetFloat( p_input, ""sub-fps"" );
        if( f_requested_fps != f_fps )
        {
            var_Create( p_input, ""sub-fps"", VLC_VAR_FLOAT|
                                            VLC_VAR_DOINHERIT );
            var_SetFloat( p_input, ""sub-fps"", f_requested_fps );
        }
    }

    const int i_delay = var_CreateGetInteger( p_input, ""sub-delay"" );
    if( i_delay != 0 )
        var_SetInteger( p_input, ""spu-delay"", (mtime_t)i_delay * 100000 );
}",1009.0,1030.0,1.0,1.0,22.0,11,7,21,6,0,3,4,5,0,3,,0,1,2,1,1,void
2145,55501,DeduceSlaveType,1,DeduceSlaveType,"enum slave_type DeduceSlaveType (input_thread_t*,char*)",input\input.c,"static enum slave_type DeduceSlaveType( input_thread_t *p_input,
                                        const char *psz_uri )
{
    vlc_url_t parsed_uri;
    if( vlc_UrlParse( &parsed_uri, psz_uri ) != VLC_SUCCESS ||
        parsed_uri.psz_path == NULL )
    {
        goto fail;
    }

    enum slave_type i_type;
    if( !input_item_slave_GetType( parsed_uri.psz_path, &i_type ) )
        goto fail;

    vlc_UrlClean( &parsed_uri );
    return i_type;

fail:
    msg_Dbg( p_input, ""Can't deduce slave type of \""%s\"" with file extension."",
             psz_uri );
    vlc_UrlClean( &parsed_uri );
    return SLAVE_TYPE_AUDIO;
}",1032.0,1054.0,1.0,1.0,23.0,10,6,13,7,1,4,5,3,2,4,,0,2,4,2,2,enum slave_type
2146,55549,GetVarSlaves,1,GetVarSlaves,"void GetVarSlaves (input_thread_t*,input_item_slave_t***,int*)",input\input.c,"static void GetVarSlaves( input_thread_t *p_input,
                          input_item_slave_t ***ppp_slaves, int *p_slaves )
{
    char *psz = var_GetNonEmptyString( p_input, ""input-slave"" );
    if( !psz )
        return;

    input_item_slave_t **pp_slaves = *ppp_slaves;
    int i_slaves = *p_slaves;

    char *psz_org = psz;
    while( psz && *psz )
    {
        while( *psz == ' ' || *psz == '#' )
            psz++;

        char *psz_delim = strchr( psz, '#' );
        if( psz_delim )
            *psz_delim++ = '\0';

        if( *psz == 0 )
            break;

        char *uri = strstr(psz, ""://"")
                                   ? strdup( psz ) : vlc_path2uri( psz, NULL );
        psz = psz_delim;
        if( uri == NULL )
            continue;

        const enum slave_type i_type = DeduceSlaveType( p_input, uri );
        input_item_slave_t *p_slave =
            input_item_slave_New( uri, i_type, SLAVE_PRIORITY_USER );
        free( uri );

        if( unlikely( p_sla...",1056.0,1098.0,1.0,1.0,43.0,31,8,45,13,1,3,11,13,0,3,,0,3,6,3,3,void
2147,55677,LoadSlaves,1,LoadSlaves,void LoadSlaves (input_thread_t*),input\input.c,"static void LoadSlaves( input_thread_t *p_input )
{
    input_item_slave_t **pp_slaves;
    int i_slaves;
    TAB_INIT( i_slaves, pp_slaves );

    /* Look for and add slaves */

    char *psz_subtitle = var_GetNonEmptyString( p_input, ""sub-file"" );
    if( psz_subtitle != NULL )
    {
        msg_Dbg( p_input, ""forced subtitle: %s"", psz_subtitle );
        char *psz_uri = input_SubtitleFile2Uri( p_input, psz_subtitle );
        free( psz_subtitle );
        psz_subtitle = NULL;
        if( psz_uri != NULL )
        {
            input_item_slave_t *p_slave =
                input_item_slave_New( psz_uri, SLAVE_TYPE_SPU,
                                      SLAVE_PRIORITY_USER );
            free( psz_uri );
            if( p_slave )
            {
                TAB_APPEND(i_slaves, pp_slaves, p_slave);
                psz_subtitle = p_slave->psz_uri;
            }
        }
    }

    if( var_GetBool( p_input, ""sub-autodetect-file"" ) )
    {
        /* Add local subtitles */
    ...",1100.0,1256.0,1.0,29.0,157.0,120,17,166,26,0,20,25,47,6,20,,0,13,2,1,1,void
2148,56184,UpdatePtsDelay,1,UpdatePtsDelay,void UpdatePtsDelay (input_thread_t*),input\input.c,"static void UpdatePtsDelay( input_thread_t *p_input )
{
    input_thread_private_t *p_sys = input_priv(p_input);

    /* Get max pts delay from input source */
    mtime_t i_pts_delay = p_sys->master->i_pts_delay;
    for( int i = 0; i < p_sys->i_slave; i++ )
        i_pts_delay = __MAX( i_pts_delay, p_sys->slave[i]->i_pts_delay );

    if( i_pts_delay < 0 )
        i_pts_delay = 0;

    /* Take care of audio/spu delay */
    const mtime_t i_audio_delay = var_GetInteger( p_input, ""audio-delay"" );
    const mtime_t i_spu_delay   = var_GetInteger( p_input, ""spu-delay"" );
    const mtime_t i_extra_delay = __MIN( i_audio_delay, i_spu_delay );
    if( i_extra_delay < 0 )
        i_pts_delay -= i_extra_delay;

    /* Update cr_average depending on the caching */
    const int i_cr_average = var_GetInteger( p_input, ""cr-average"" ) * i_pts_delay / DEFAULT_PTS_DELAY;

    /* */
    es_out_SetDelay( input_priv(p_input)->p_es_out_display, AUDIO_ES, i_audio_delay );
    es_out_SetDelay( input_p...",1258.0,1284.0,1.0,1.0,27.0,20,6,32,11,1,9,4,4,1,7,,0,6,2,1,1,void
2149,56292,InitPrograms,1,InitPrograms,void InitPrograms (input_thread_t*),input\input.c,"static void InitPrograms( input_thread_t * p_input )
{
    int i_es_out_mode;
    vlc_list_t list;

    /* Compute correct pts_delay */
    UpdatePtsDelay( p_input );

    /* Set up es_out */
    i_es_out_mode = ES_OUT_MODE_AUTO;
    if( input_priv(p_input)->p_sout && !input_priv(p_input)->p_renderer )
    {
        char *prgms;

        if( (prgms = var_GetNonEmptyString( p_input, ""programs"" )) != NULL )
        {
            char *buf;

            TAB_INIT( list.i_count, list.p_values );
            for( const char *prgm = strtok_r( prgms, "","", &buf );
                 prgm != NULL;
                 prgm = strtok_r( NULL, "","", &buf ) )
            {
                vlc_value_t val = { .i_int = atoi( prgm ) };
                TAB_APPEND(list.i_count, list.p_values, val);
            }

            if( list.i_count > 0 )
                i_es_out_mode = ES_OUT_MODE_PARTIAL;
                /* Note : we should remove the ""program"" callback. */

            free( prgms );
        }
  ...",1286.0,1342.0,1.0,1.0,57.0,25,11,32,13,0,6,6,11,2,6,,0,3,2,1,1,void
2150,57804,input_ControlPush,1,input_ControlPush,"void input_ControlPush (input_thread_t*,int,vlc_value_t*)",input\input.c,"void input_ControlPush( input_thread_t *p_input,
                        int i_type, vlc_value_t *p_val )
{
    input_thread_private_t *sys = input_priv(p_input);

    vlc_mutex_lock( &sys->lock_control );
    if( sys->is_stopped || sys->i_control >= INPUT_CONTROL_FIFO_SIZE )
    {
        if( sys->is_stopped )
            msg_Dbg( p_input, ""input control stopped, trashing type=%d"",
                     i_type );
        else
            msg_Err( p_input, ""input control fifo overflow, trashing type=%d"",
                     i_type );
        if( p_val )
            ControlRelease( i_type, *p_val );
    }
    else
    {
        input_control_t c;
        c.i_type = i_type;
        if( p_val )
            c.val = *p_val;
        else
            memset( &c.val, 0, sizeof(c.val) );

        sys->control[sys->i_control++] = c;

        vlc_cond_signal( &sys->wait_control );
    }
    vlc_mutex_unlock( &sys->lock_control );
}",1594.0,1625.0,1.0,45.0,32.0,11,6,12,4,12,9,4,6,3,4,,0,6,6,3,3,void
2151,57905,ControlGetReducedIndexLocked,1,ControlGetReducedIndexLocked,int ControlGetReducedIndexLocked (input_thread_t*),input\input.c,"static int ControlGetReducedIndexLocked( input_thread_t *p_input )
{
    const int i_lt = input_priv(p_input)->control[0].i_type;
    int i;
    for( i = 1; i < input_priv(p_input)->i_control; i++ )
    {
        const int i_ct = input_priv(p_input)->control[i].i_type;

        if( i_lt == i_ct &&
            ( i_ct == INPUT_CONTROL_SET_STATE ||
              i_ct == INPUT_CONTROL_SET_RATE ||
              i_ct == INPUT_CONTROL_SET_POSITION ||
              i_ct == INPUT_CONTROL_SET_TIME ||
              i_ct == INPUT_CONTROL_SET_PROGRAM ||
              i_ct == INPUT_CONTROL_SET_TITLE ||
              i_ct == INPUT_CONTROL_SET_SEEKPOINT ||
              i_ct == INPUT_CONTROL_SET_BOOKMARK ) )
        {
            continue;
        }
        else
        {
            /* TODO but that's not that important
                - merge SET_X with SET_X_CMD
                - ignore SET_SEEKPOINT/SET_POSITION/SET_TIME before a SET_TITLE
                - ignore SET_SEEKPOINT/SET_POSITION/SET...",1627.0,1659.0,1.0,1.0,33.0,29,9,27,12,0,3,4,4,1,3,,0,3,2,1,1,int
2152,58319,ControlUnpause,1,ControlUnpause,"void ControlUnpause (input_thread_t*,mtime_t)",input\input.c,"static void ControlUnpause( input_thread_t *p_input, mtime_t i_control_date )
{
    if( input_priv(p_input)->b_can_pause )
    {
        demux_t *p_demux = input_priv(p_input)->master->p_demux;

        if( demux_Control( p_demux, DEMUX_SET_PAUSE_STATE, false ) )
        {
            msg_Err( p_input, ""cannot resume"" );
            input_ChangeState( p_input, ERROR_S );
            return;
        }
    }

    /* Switch to play */
    input_ChangeState( p_input, PLAYING_S );
    es_out_SetPauseState( input_priv(p_input)->p_es_out, false, false, i_control_date );
}",1789.0,1806.0,1.0,1.0,18.0,5,2,15,7,0,6,3,4,1,6,,0,3,4,2,2,void
2153,58364,ViewpointApply,1,ViewpointApply,void ViewpointApply (input_thread_t*),input\input.c,"static void ViewpointApply( input_thread_t *p_input )
{
    input_thread_private_t *priv = input_priv(p_input);

    vlc_viewpoint_clip( &priv->viewpoint );

    vout_thread_t **pp_vout;
    size_t i_vout;
    input_resource_HoldVouts( priv->p_resource, &pp_vout, &i_vout );

    for( size_t i = 0; i < i_vout; ++i )
    {
        var_SetAddress( pp_vout[i], ""viewpoint"", &priv->viewpoint );
        /* This variable can only be read from callbacks */
        var_Change( pp_vout[i], ""viewpoint"", VLC_VAR_SETVALUE,
                    &(vlc_value_t) { .p_address = NULL }, NULL );
        vlc_object_release( pp_vout[i] );
    }
    free( pp_vout );

    audio_output_t *p_aout = input_resource_HoldAout( priv->p_resource );
    if( p_aout )
    {

        var_SetAddress( p_aout, ""viewpoint"", &priv->viewpoint );
        /* This variable can only be read from callbacks */
        var_Change( p_aout, ""viewpoint"", VLC_VAR_SETVALUE,
                    &(vlc_value_t) { .p_address = NULL }, NULL )...",1808.0,1838.0,1.0,1.0,31.0,25,7,32,9,1,12,3,3,0,7,,0,7,2,1,1,void
2154,58463,ControlNavDisplayVolume,1,ControlNavDisplayVolume,"void ControlNavDisplayVolume (vout_thread_t*,float)",input\input.c,"static void ControlNavDisplayVolume( vout_thread_t *p_vout, float vol )
{
    vout_FlushSubpictureChannel( p_vout, VOUT_SPU_CHANNEL_OSD );
    vout_OSDMessage( p_vout, VOUT_SPU_CHANNEL_OSD, _( ""Volume %ld%%"" ),
                     lroundf( vol * 100.f ) );
}",1843.0,1848.0,1.0,1.0,6.0,1,1,5,3,0,2,1,1,0,2,,0,0,4,2,2,void
2155,58481,ControlNavDisplayPosition,1,ControlNavDisplayPosition,"void ControlNavDisplayPosition (vout_thread_t*,input_thread_t*)",input\input.c,"static void ControlNavDisplayPosition( vout_thread_t *p_vout,
                                       input_thread_t *p_input )
{
    vout_FlushSubpictureChannel( p_vout, VOUT_SPU_CHANNEL_OSD );

    int64_t t = var_GetInteger( p_input, ""time"" ) / CLOCK_FREQ;
    int64_t l = var_GetInteger( p_input, ""length"" ) / CLOCK_FREQ;

    char psz_time[MSTRTIME_MAX_SIZE];
    secstotimestr( psz_time, t );

    if( l > 0 )
    {
        char psz_duration[MSTRTIME_MAX_SIZE];

        secstotimestr( psz_duration, l );
        vout_OSDMessage( p_vout, VOUT_SPU_CHANNEL_OSD,
                         ""%s / %s"", psz_time, psz_duration );
    }
    else if( t > 0 )
    {
        vout_OSDMessage( p_vout, VOUT_SPU_CHANNEL_OSD, ""%s"", psz_time );
    }
}",1850.0,1873.0,1.0,1.0,24.0,5,3,17,8,1,4,2,2,0,4,,0,0,4,2,2,void
2156,58537,ControlNav,1,ControlNav,"void ControlNav (input_thread_t*,int)",input\input.c,"static void ControlNav( input_thread_t *p_input, int i_type )
{
    input_thread_private_t *priv = input_priv(p_input);

    if( !demux_Control( priv->master->p_demux, i_type
                        - INPUT_CONTROL_NAV_ACTIVATE + DEMUX_NAV_ACTIVATE ) )
        return; /* The demux handled the navigation control */

    /* Handle Up/Down/Left/Right if the demux can't navigate */
    vlc_viewpoint_t vp = {};
    int vol_direction = 0;
    int seek_direction = 0;
    switch( i_type )
    {
        case INPUT_CONTROL_NAV_UP:
            vol_direction = 1;
            vp.pitch = -1.f;
            break;
        case INPUT_CONTROL_NAV_DOWN:
            vol_direction = -1;
            vp.pitch = 1.f;
            break;
        case INPUT_CONTROL_NAV_LEFT:
            seek_direction = -1;
            vp.yaw = -1.f;
            break;
        case INPUT_CONTROL_NAV_RIGHT:
            seek_direction = 1;
            vp.yaw = 1.f;
            break;
        case INPUT_CONTROL_NAV_ACTIVATE:
   ...",1875.0,1962.0,1.0,1.0,88.0,62,16,64,22,0,11,14,11,1,4,,0,8,4,2,2,void
2157,58802,ControlInsertDemuxFilter,1,ControlInsertDemuxFilter,"void ControlInsertDemuxFilter (input_thread_t*,char*)",input\input.c,"static void ControlInsertDemuxFilter( input_thread_t* p_input, const char* psz_demux_chain )
{
    input_source_t *p_inputSource = input_priv(p_input)->master;
    demux_t *p_filtered_demux = demux_FilterChainNew( p_inputSource->p_demux, psz_demux_chain );
    if ( p_filtered_demux != NULL )
        p_inputSource->p_demux = p_filtered_demux;
    else if ( psz_demux_chain != NULL )
        msg_Dbg(p_input, ""Failed to create demux filter %s"", psz_demux_chain);
}",1984.0,1992.0,1.0,1.0,9.0,7,3,9,5,0,4,2,2,0,2,,0,4,4,2,2,void
2158,60086,UpdateTitleSeekpoint,1,UpdateTitleSeekpoint,"int UpdateTitleSeekpoint (input_thread_t*,int,int)",input\input.c,"static int UpdateTitleSeekpoint( input_thread_t *p_input,
                                 int i_title, int i_seekpoint )
{
    int i_title_end = input_priv(p_input)->master->i_title_end -
                        input_priv(p_input)->master->i_title_offset;
    int i_seekpoint_end = input_priv(p_input)->master->i_seekpoint_end -
                            input_priv(p_input)->master->i_seekpoint_offset;

    if( i_title_end >= 0 && i_seekpoint_end >= 0 )
    {
        if( i_title > i_title_end ||
            ( i_title == i_title_end && i_seekpoint > i_seekpoint_end ) )
            return VLC_DEMUXER_EOF;
    }
    else if( i_seekpoint_end >= 0 )
    {
        if( i_seekpoint > i_seekpoint_end )
            return VLC_DEMUXER_EOF;
    }
    else if( i_title_end >= 0 )
    {
        if( i_title > i_title_end )
            return VLC_DEMUXER_EOF;
    }
    return VLC_DEMUXER_SUCCESS;
}",2465.0,2490.0,1.0,1.0,26.0,20,8,16,7,0,4,3,4,0,4,,0,4,6,3,3,int
2159,60376,InputStreamHandleAnchor,1,InputStreamHandleAnchor,"int InputStreamHandleAnchor (input_source_t*,stream_t**,char*)",input\input.c,"static int
InputStreamHandleAnchor( input_source_t *source, stream_t **stream,
                         char const *anchor )
{
    char const* extra;
    if( stream_extractor_AttachParsed( stream, anchor, &extra ) )
    {
        msg_Err( source, ""unable to attach stream-extractors for %s"",
            (*stream)->psz_url );

        return VLC_EGENERIC;
    }

    if( vlc_stream_directory_Attach( stream, NULL ) )
        msg_Dbg( source, ""attachment of directory-extractor failed for %s"",
            (*stream)->psz_url );

    MRLSections( extra ? extra : """",
        &source->i_title_start, &source->i_title_end,
        &source->i_seekpoint_start, &source->i_seekpoint_end );

    return VLC_SUCCESS;
}",2557.0,2579.0,1.0,1.0,23.0,14,4,17,7,1,7,3,3,2,3,,0,6,6,3,3,int
2160,60435,InputDemuxNew,1,InputDemuxNew,"demux_t InputDemuxNew (input_thread_t*,input_source_t*,char*,char*,char*,char*)",input\input.c,"static demux_t *InputDemuxNew( input_thread_t *p_input, input_source_t *p_source,
                               const char *psz_access, const char *psz_demux,
                               const char *psz_path, const char *psz_anchor )
{
    input_thread_private_t *priv = input_priv(p_input );
    demux_t *p_demux = NULL;

    /* first, try to create an access demux */
    p_demux = demux_NewAdvanced( VLC_OBJECT( p_source ), p_input,
                                 psz_access, psz_demux, psz_path,
                                 NULL, priv->p_es_out, priv->b_preparsing );
    if( p_demux )
    {
        MRLSections( psz_anchor,
            &p_source->i_title_start, &p_source->i_title_end,
            &p_source->i_seekpoint_start, &p_source->i_seekpoint_end );

        return p_demux;
    }

    /* not an access-demux: create the underlying access stream */
    char *psz_base_mrl;

    if( asprintf( &psz_base_mrl, ""%s://%s"", psz_access, psz_path ) < 0 )
        return NULL;

    ...",2581.0,2646.0,1.0,14.0,66.0,29,5,77,12,0,22,11,9,1,9,,0,20,12,6,6,demux_t
2161,62032,InputGetExtraFilesPattern,1,InputGetExtraFilesPattern,"void InputGetExtraFilesPattern (input_thread_t*,int*,char***,char*,char*,char*,int,int)",input\input.c,"static void InputGetExtraFilesPattern( input_thread_t *p_input,
                                       int *pi_list, char ***pppsz_list,
                                       const char *psz_path,
                                       const char *psz_match,
                                       const char *psz_format,
                                       int i_start, int i_stop )
{
    int i_list;
    char **ppsz_list;
    TAB_INIT( i_list, ppsz_list );

    char *psz_base = strdup( psz_path );
    if( !psz_base )
        goto exit;

    /* Remove the extension */
    char *psz_end = &psz_base[strlen(psz_base)-strlen(psz_match)];
    assert( psz_end >= psz_base);
    *psz_end = '\0';

    /* Try to list files */
    for( int i = i_start; i <= i_stop; i++ )
    {
        char *psz_probe;
        if( asprintf( &psz_probe, psz_format, psz_base, i ) < 0 )
            break;

        char *filepath = get_path( psz_probe );

        struct stat st;
        if( filepath == NULL ||
   ...",3141.0,3192.0,1.0,1.0,52.0,28,12,46,18,0,3,9,9,1,3,,0,3,16,8,8,void
2162,62367,input_SplitMRL,1,input_SplitMRL,"void input_SplitMRL (char**,char**,char**,char**,char*)",input\input.c,"void input_SplitMRL( const char **access, const char **demux,
                     const char **path, const char **anchor, char *buf )
{
    char *p;

    /* Separate <path> from <access>[/<demux>]:// */
    p = strstr( buf, ""://"" );
    if( p != NULL )
    {
        *p = '\0';
        p += 3; /* skips ""://"" */
        *path = p;

        /* Remove HTML anchor if present (not supported).
         * The hash symbol itself should be URI-encoded. */
        p = strchr( p, '#' );
        if( p != NULL )
        {
            *(p++) = '\0';
            *anchor = p;
        }
        else
            *anchor = """";
    }
    else
    {
#ifndef NDEBUG
        fprintf( stderr, ""%s(\""%s\"") probably not a valid URI!\n"", __func__,
                 buf );
#endif
        /* Note: this is a valid non const pointer to """": */
        *path = buf + strlen( buf );
    }

    /* Separate access from demux */
    p = strchr( buf, '/' );
    if( p != NULL )
    {
        *(p++) = '\0';
        if( p[0] =...",3261.0,3312.0,1.0,1.0,52.0,30,7,30,7,0,0,6,8,0,0,,0,0,10,5,5,void
2163,62487,MRLSeekPoint,1,MRLSeekPoint,"const char* MRLSeekPoint (char*,int*,int*)",input\input.c,"static const char *MRLSeekPoint( const char *str, int *title, int *chapter )
{
    char *end;
    unsigned long u;

    /* Look for the title */
    u = strtoul( str, &end, 0 );
    *title = (str == end || u > (unsigned long)INT_MAX) ? -1 : (int)u;
    str = end;

    /* Look for the chapter */
    if( *str == ':' )
    {
        str++;
        u = strtoul( str, &end, 0 );
        *chapter = (str == end || u > (unsigned long)INT_MAX) ? -1 : (int)u;
        str = end;
    }
    else
        *chapter = -1;

    return str;
}",3314.0,3336.0,1.0,1.0,23.0,27,10,25,6,0,0,2,2,0,0,,0,0,6,3,3,const char*
2164,62989,input_UpdateStatistic,1,input_UpdateStatistic,"void input_UpdateStatistic (input_thread_t*,input_statistic_t,int)",input\input.c,"void input_UpdateStatistic( input_thread_t *p_input,
                            input_statistic_t i_type, int i_delta )
{
    assert( input_priv(p_input)->i_state != INIT_S );

    vlc_mutex_lock( &input_priv(p_input)->counters.counters_lock);
    switch( i_type )
    {
#define I(c) stats_Update( input_priv(p_input)->counters.c, i_delta, NULL )
    case INPUT_STATISTIC_DECODED_VIDEO:
        I(p_decoded_video);
        break;
    case INPUT_STATISTIC_DECODED_AUDIO:
        I(p_decoded_audio);
        break;
    case INPUT_STATISTIC_DECODED_SUBTITLE:
        I(p_decoded_sub);
        break;
    case INPUT_STATISTIC_SENT_PACKET:
        I(p_sout_sent_packets);
        break;
#undef I
    case INPUT_STATISTIC_SENT_BYTE:
    {
        uint64_t bytes;

        stats_Update( input_priv(p_input)->counters.p_sout_sent_bytes, i_delta, &bytes );
        stats_Update( input_priv(p_input)->counters.p_sout_send_bitrate, bytes, NULL );
        break;
    }
    default:
        msg_Err( p_input, ...",3508.0,3543.0,1.0,8.0,36.0,21,4,30,11,0,17,8,2,0,17,,0,8,6,3,3,void
2165,63108,input_CreateFilename,1,input_CreateFilename,"char* input_CreateFilename (input_thread_t*,char*,char*,char*)",input\input.c,"char *input_CreateFilename(input_thread_t *input, const char *dir,
                           const char *filenamefmt, const char *ext)
{
    char *path;
    char *filename = str_format(input, filenamefmt);
    if (unlikely(filename == NULL))
        return NULL;

    filename_sanitize(filename);

    if (((ext != NULL)
            ? asprintf(&path, ""%s""DIR_SEP""%s.%s"", dir, filename, ext)
            : asprintf(&path, ""%s""DIR_SEP""%s"", dir, filename)) < 0)
        path = NULL;

    free(filename);
    return path;
}",3547.0,3564.0,1.0,1.0,18.0,3,2,11,5,0,1,3,3,0,1,,0,0,8,4,4,char*
2166,63152,input_item_SignalPreparseEnded,1,input_item_SignalPreparseEnded,"void input_item_SignalPreparseEnded (input_item_t*,int)",input\item.c,"void input_item_SignalPreparseEnded( input_item_t *p_i, int status )
{
    vlc_event_send( &p_i->event_manager, &(vlc_event_t) {
        .type = vlc_InputItemPreparseEnded,
        .u.input_item_preparse_ended.new_status = status } );
}",69.0,74.0,1.0,1.0,6.0,0,0,0,0,6,0,1,1,0,0,,0,0,4,2,2,void
2167,63158,input_item_SetPreparsed,1,input_item_SetPreparsed,"void input_item_SetPreparsed (input_item_t*,bool)",input\item.c,"void input_item_SetPreparsed( input_item_t *p_i, bool b_preparsed )
{
    bool b_send_event = false;

    vlc_mutex_lock( &p_i->lock );

    if( !p_i->p_meta )
        p_i->p_meta = vlc_meta_New();

    int status = vlc_meta_GetStatus(p_i->p_meta);
    int new_status;
    if( b_preparsed )
        new_status = status | ITEM_PREPARSED;
    else
        new_status = status & ~ITEM_PREPARSED;
    if( status != new_status )
    {
        vlc_meta_SetStatus(p_i->p_meta, new_status);
        b_send_event = true;
    }

    vlc_mutex_unlock( &p_i->lock );

    if( b_send_event )
    {
        vlc_event_send( &p_i->event_manager, &(vlc_event_t) {
            .type = vlc_InputItemPreparsedChanged,
            .u.input_item_preparsed_changed.new_status = new_status } );
    }
}",76.0,105.0,1.0,1.0,30.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,void
2168,63164,input_item_SetArtNotFound,1,input_item_SetArtNotFound,"void input_item_SetArtNotFound (input_item_t*,bool)",input\item.c,"void input_item_SetArtNotFound( input_item_t *p_i, bool b_not_found )
{
    vlc_mutex_lock( &p_i->lock );

    if( !p_i->p_meta )
        p_i->p_meta = vlc_meta_New();

    int status = vlc_meta_GetStatus(p_i->p_meta);

    if( b_not_found )
        status |= ITEM_ART_NOTFOUND;
    else
        status &= ~ITEM_ART_NOTFOUND;

    vlc_meta_SetStatus(p_i->p_meta, status);

    vlc_mutex_unlock( &p_i->lock );
}",107.0,124.0,1.0,1.0,18.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
2169,63170,input_item_SetArtFetched,1,input_item_SetArtFetched,"void input_item_SetArtFetched (input_item_t*,bool)",input\item.c,"void input_item_SetArtFetched( input_item_t *p_i, bool b_art_fetched )
{
    vlc_mutex_lock( &p_i->lock );

    if( !p_i->p_meta )
        p_i->p_meta = vlc_meta_New();

    int status = vlc_meta_GetStatus(p_i->p_meta);

    if( b_art_fetched )
        status |= ITEM_ART_FETCHED;
    else
        status &= ~ITEM_ART_FETCHED;

    vlc_meta_SetStatus(p_i->p_meta, status);

    vlc_mutex_unlock( &p_i->lock );
}",126.0,143.0,1.0,1.0,18.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
2170,63176,input_item_SetEpg,1,input_item_SetEpg,"void input_item_SetEpg (input_item_t*,vlc_epg_t*,ANY)",input\item.c,"void input_item_SetEpg( input_item_t *p_item, const vlc_epg_t *p_update, bool b_current_source )
{
    vlc_epg_t *p_epg = vlc_epg_Duplicate( p_update );
    if( !p_epg )
        return;

    vlc_mutex_lock( &p_item->lock );

    /* */
    vlc_epg_t **pp_epg = NULL;
    for( int i = 0; i < p_item->i_epg; i++ )
    {
        if( p_item->pp_epg[i]->i_source_id == p_update->i_source_id &&
            p_item->pp_epg[i]->i_id == p_update->i_id )
        {
            pp_epg = &p_item->pp_epg[i];
            break;
        }
    }

    /* replace with new version */
    if( pp_epg )
    {
        vlc_epg_Delete( *pp_epg );
        if( *pp_epg == p_item->p_epg_table ) /* current table can have changed */
            p_item->p_epg_table = NULL;
        *pp_epg = p_epg;
    }
    else
    {
        TAB_APPEND( p_item->i_epg, p_item->pp_epg, p_epg );
    }

    if( b_current_source && p_epg->b_present )
        p_item->p_epg_table = p_epg;

    vlc_mutex_unlock( &p_item->lock );

#ifdef EPG_DE...",919.0,994.0,1.0,1.0,76.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
2171,63183,input_item_ChangeEPGSource,1,input_item_ChangeEPGSource,"void input_item_ChangeEPGSource (input_item_t*,int)",input\item.c,"void input_item_ChangeEPGSource( input_item_t *p_item, int i_source_id )
{
    vlc_mutex_lock( &p_item->lock );
    p_item->p_epg_table = NULL;
    if( i_source_id > 0 )
    {
        /* Update pointer to current/next table in the full schedule */
        for( int i = 0; i < p_item->i_epg; i++ )
        {
            if( p_item->pp_epg[i]->i_source_id == i_source_id &&
                p_item->pp_epg[i]->b_present )
            {
                p_item->p_epg_table = p_item->pp_epg[i];
                break;
            }
        }
    }
    vlc_mutex_unlock( &p_item->lock );
}",996.0,1014.0,1.0,1.0,19.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
2172,63189,input_item_SetEpgEvent,1,input_item_SetEpgEvent,"void input_item_SetEpgEvent (input_item_t*,vlc_epg_event_t*)",input\item.c,"void input_item_SetEpgEvent( input_item_t *p_item, const vlc_epg_event_t *p_epg_evt )
{
    bool b_changed = false;
    vlc_mutex_lock( &p_item->lock );

    for( int i = 0; i < p_item->i_epg; i++ )
    {
        vlc_epg_t *p_epg = p_item->pp_epg[i];
        for( size_t j = 0; j < p_epg->i_event; j++ )
        {
            /* Same event can exist in more than one table */
            if( p_epg->pp_event[j]->i_id == p_epg_evt->i_id )
            {
                vlc_epg_event_t *p_dup = vlc_epg_event_Duplicate( p_epg_evt );
                if( p_dup )
                {
                    if( p_epg->p_current == p_epg->pp_event[j] )
                        p_epg->p_current = p_dup;
                    vlc_epg_event_Delete( p_epg->pp_event[j] );
                    p_epg->pp_event[j] = p_dup;
                    b_changed = true;
                }
                break;
            }
        }
    }
    vlc_mutex_unlock( &p_item->lock );

    if ( b_changed )
    {
        vlc_event...",867.0,900.0,1.0,1.0,34.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
2173,63195,input_item_SetEpgTime,1,input_item_SetEpgTime,"void input_item_SetEpgTime (input_item_t*,ANY)",input\item.c,"void input_item_SetEpgTime( input_item_t *p_item, int64_t i_time )
{
    vlc_mutex_lock( &p_item->lock );
    p_item->i_epg_time = i_time;
    vlc_mutex_unlock( &p_item->lock );
}",1016.0,1021.0,1.0,1.0,6.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
2174,63201,input_item_SetEpgOffline,1,input_item_SetEpgOffline,void input_item_SetEpgOffline (input_item_t*),input\item.c,"void input_item_SetEpgOffline( input_item_t *p_item )
{
    input_item_ChangeEPGSource( p_item, -1 );

#ifdef EPG_DEBUG
    vlc_mutex_lock( &p_item->lock );
    const int i_epg_info = p_item->i_epg;
    if( i_epg_info > 0 )
    {
        char *ppsz_epg_info[i_epg_info];
        for( int i = 0; i < p_item->i_epg; i++ )
        {
            const vlc_epg_t *p_epg = p_item->pp_epg[i];
            if( asprintf( &ppsz_epg_info[i], ""EPG %s"", p_epg->psz_name ? p_epg->psz_name : ""unknown"" ) < 0 )
                ppsz_epg_info[i] = NULL;
        }
        vlc_mutex_unlock( &p_item->lock );

        for( int i = 0; i < i_epg_info; i++ )
        {
            if( !ppsz_epg_info[i] )
                continue;
            input_item_DelInfo( p_item, ppsz_epg_info[i], NULL );
            free( ppsz_epg_info[i] );
        }
    }
    else
        vlc_mutex_unlock( &p_item->lock );
#endif

    vlc_event_send( &p_item->event_manager,
                    &(vlc_event_t) { .type = vlc_InputItemInfoCha...",1023.0,1055.0,1.0,1.0,33.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2175,63214,stats_NewInputStats,1,stats_NewInputStats,input_stats_t* stats_NewInputStats (input_thread_t*),input\stats.c,"input_stats_t *stats_NewInputStats( input_thread_t *p_input )
{
    (void)p_input;
    input_stats_t *p_stats = calloc( 1, sizeof(input_stats_t) );
    if( !p_stats )
        return NULL;

    vlc_mutex_init( &p_stats->lock );
    stats_ReinitInputStats( p_stats );

    return p_stats;
}",68.0,79.0,1.0,1.0,12.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,input_stats_t
2176,63219,input_resource_TerminateSout,1,input_resource_TerminateSout,void input_resource_TerminateSout (input_resource_t*),input\resource.c,"void input_resource_TerminateSout( input_resource_t *p_resource )
{
    input_resource_RequestSout( p_resource, NULL, NULL );
}",511.0,514.0,1.0,1.0,4.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,void
2177,63224,input_resource_HasVout,1,input_resource_HasVout,bool input_resource_HasVout (input_resource_t*),input\resource.c,"bool input_resource_HasVout( input_resource_t *p_resource )
{
    vlc_mutex_lock( &p_resource->lock );
    assert( !p_resource->p_input );
    const bool b_vout = p_resource->p_vout_free != NULL;
    vlc_mutex_unlock( &p_resource->lock );

    return b_vout;
}",492.0,500.0,1.0,1.0,9.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,bool
2178,63364,input_priv,1,input_priv,input_thread_private_t input_priv (input_thread_t*),input\input_internal.h,"static inline input_thread_private_t *input_priv(input_thread_t *input)
{
    return container_of(input, input_thread_private_t, input);
}",181.0,184.0,1.0,1.0,4.0,0,0,3,2,119,0,1,1,0,0,,0,0,2,1,1,input_thread_private_t
2179,63417,input_ExtractAttachmentAndCacheArt,1,input_ExtractAttachmentAndCacheArt,"void input_ExtractAttachmentAndCacheArt (input_thread_t*,char*)",input\meta.c,"void input_ExtractAttachmentAndCacheArt( input_thread_t *p_input,
                                         const char *name )
{
    input_item_t *p_item = input_priv(p_input)->p_item;

    if( input_item_IsArtFetched( p_item ) )
    {   /* XXX Weird, we should not end up with attachment:// art URL
         * unless there is a race condition */
        msg_Warn( p_input, ""art already fetched"" );
        if( likely(playlist_FindArtInCache( p_item ) == VLC_SUCCESS) )
            return;
    }

    /* */
    input_attachment_t *p_attachment = NULL;

    vlc_mutex_lock( &p_item->lock );
    for( int i_idx = 0; i_idx < input_priv(p_input)->i_attachment; i_idx++ )
    {
        input_attachment_t *a = input_priv(p_input)->attachment[i_idx];

        if( !strcmp( a->psz_name, name ) )
        {
            p_attachment = vlc_input_attachment_Duplicate( a );
            break;
        }
    }
    vlc_mutex_unlock( &p_item->lock );

    if( p_attachment == NULL )
    {
        msg_Warn( p_inp...",206.0,254.0,1.0,1.0,49.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
2180,63423,input_ControlVarInit,1,input_ControlVarInit,void input_ControlVarInit (input_thread_t*),input\var.c,"void input_ControlVarInit ( input_thread_t *p_input )
{
    vlc_value_t val, text;

    /* State */
    var_Create( p_input, ""state"", VLC_VAR_INTEGER );
    val.i_int = input_priv(p_input)->i_state;
    var_Change( p_input, ""state"", VLC_VAR_SETVALUE, &val, NULL );

    /* Rate */
    var_Create( p_input, ""rate"", VLC_VAR_FLOAT | VLC_VAR_DOINHERIT );

    var_Create( p_input, ""frame-next"", VLC_VAR_VOID );

    /* Position */
    var_Create( p_input, ""position"",  VLC_VAR_FLOAT );

    /* Time */
    var_Create( p_input, ""time"", VLC_VAR_INTEGER );
    var_Create( p_input, ""time-offset"", VLC_VAR_INTEGER );    /* relative */

    /* Bookmark */
    var_Create( p_input, ""bookmark"", VLC_VAR_INTEGER | VLC_VAR_ISCOMMAND );
    val.psz_string = _(""Bookmark"");
    var_Change( p_input, ""bookmark"", VLC_VAR_SETTEXT, &val, NULL );

    /* Program */
    var_Create( p_input, ""program"", VLC_VAR_INTEGER | VLC_VAR_DOINHERIT );
    var_Get( p_input, ""program"", &val );
    if( val.i_int <= 0 )
        va...",129.0,222.0,1.0,1.0,94.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2181,63428,input_ControlVarStop,1,input_ControlVarStop,void input_ControlVarStop (input_thread_t*),input\var.c,"void input_ControlVarStop( input_thread_t *p_input )
{
    if( !input_priv(p_input)->b_preparsing )
        InputDelCallbacks( p_input, p_input_callbacks );

    if( input_priv(p_input)->i_title > 1 )
        InputDelCallbacks( p_input, p_input_title_navigation_callbacks );

    for( int i = 0; i < input_priv(p_input)->i_title; i++ )
    {
        char name[sizeof(""title "") + 3 * sizeof (int)];

        sprintf( name, ""title %2u"", i );
        var_DelCallback( p_input, name, NavigationCallback, (void *)(intptr_t)i );
    }

    if( var_Type( p_input, ""next-chapter"" ) != 0 )
    {
        assert( var_Type( p_input, ""prev-chapter"" ) != 0 );
        var_Destroy( p_input, ""next-chapter"" );
        var_Destroy( p_input, ""prev-chapter"" );
    }
}",227.0,249.0,1.0,1.0,23.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2182,63433,input_ControlVarNavigation,1,input_ControlVarNavigation,void input_ControlVarNavigation (input_thread_t*),input\var.c,"void input_ControlVarNavigation( input_thread_t *p_input )
{
    vlc_value_t text;

    /* Create more command variables */
    if( input_priv(p_input)->i_title > 1 )
    {
        if( var_Type( p_input, ""next-title"" ) == 0 ) {
            var_Create( p_input, ""next-title"", VLC_VAR_VOID );
            text.psz_string = _(""Next title"");
            var_Change( p_input, ""next-title"", VLC_VAR_SETTEXT, &text, NULL );
            var_AddCallback( p_input, ""next-title"", TitleCallback, NULL );
        }

        if( var_Type( p_input, ""prev-title"" ) == 0 ) {
            var_Create( p_input, ""prev-title"", VLC_VAR_VOID );
            text.psz_string = _(""Previous title"");
            var_Change( p_input, ""prev-title"", VLC_VAR_SETTEXT, &text, NULL );
            var_AddCallback( p_input, ""prev-title"", TitleCallback, NULL );
        }

        if( var_Type( p_input, ""menu-title"" ) == 0 ) {
            var_Create( p_input, ""menu-title"", VLC_VAR_VOID );
            text.psz_string = _(""Menu titl...",255.0,359.0,1.0,1.0,105.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
2183,63438,input_ControlVarTitle,1,input_ControlVarTitle,"void input_ControlVarTitle (input_thread_t*,int)",input\var.c,"void input_ControlVarTitle( input_thread_t *p_input, int i_title )
{
    const input_title_t *t = input_priv(p_input)->title[i_title];
    vlc_value_t text;
    int  i;

    /* Create/Destroy command variables */
    if( t->i_seekpoint <= 1 )
    {
        var_Destroy( p_input, ""next-chapter"" );
        var_Destroy( p_input, ""prev-chapter"" );
    }
    else if( var_Type( p_input, ""next-chapter"" ) == 0 )
    {
        var_Create( p_input, ""next-chapter"", VLC_VAR_VOID );
        text.psz_string = _(""Next chapter"");
        var_Change( p_input, ""next-chapter"", VLC_VAR_SETTEXT, &text, NULL );
        var_AddCallback( p_input, ""next-chapter"", SeekpointCallback, NULL );

        var_Create( p_input, ""prev-chapter"", VLC_VAR_VOID );
        text.psz_string = _(""Previous chapter"");
        var_Change( p_input, ""prev-chapter"", VLC_VAR_SETTEXT, &text, NULL );
        var_AddCallback( p_input, ""prev-chapter"", SeekpointCallback, NULL );
    }

    /* Build chapter list */
    var_Change( p_input...",365.0,413.0,1.0,1.0,49.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
2184,63444,input_ConfigVarInit,1,input_ConfigVarInit,void input_ConfigVarInit (input_thread_t*),input\var.c,"void input_ConfigVarInit ( input_thread_t *p_input )
{
    /* Create Object Variables for private use only */

    if( !input_priv(p_input)->b_preparsing )
    {
        var_Create( p_input, ""video"", VLC_VAR_BOOL | VLC_VAR_DOINHERIT );
        var_Create( p_input, ""audio"", VLC_VAR_BOOL | VLC_VAR_DOINHERIT );
        var_Create( p_input, ""spu"", VLC_VAR_BOOL | VLC_VAR_DOINHERIT );

        var_Create( p_input, ""audio-track"", VLC_VAR_INTEGER|VLC_VAR_DOINHERIT );
        var_Create( p_input, ""sub-track"", VLC_VAR_INTEGER|VLC_VAR_DOINHERIT );

        var_Create( p_input, ""audio-language"",
                    VLC_VAR_STRING|VLC_VAR_DOINHERIT );
        var_Create( p_input, ""sub-language"",
                    VLC_VAR_STRING|VLC_VAR_DOINHERIT );
        var_Create( p_input, ""menu-language"",
                    VLC_VAR_STRING|VLC_VAR_DOINHERIT );

        var_Create( p_input, ""audio-track-id"",
                    VLC_VAR_INTEGER|VLC_VAR_DOINHERIT );
        var_Create( p_input, ""sub-track-id...",419.0,528.0,1.0,1.0,110.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2185,63449,subtitles_Detect,1,subtitles_Detect,"int subtitles_Detect (input_thread_t*,char*,char*,input_item_slave_t***,int*)",input\subtitles.c,"int subtitles_Detect( input_thread_t *p_this, char *psz_path, const char *psz_name_org,
                      input_item_slave_t ***ppp_slaves, int *p_slaves )
{
    int i_fuzzy = var_GetInteger( p_this, ""sub-autodetect-fuzzy"" );
    if ( i_fuzzy == 0 )
        return VLC_EGENERIC;
    int i_fname_len;
    input_item_slave_t **pp_slaves = *ppp_slaves;
    int i_slaves = *p_slaves;
    char *f_fname_noext = NULL, *f_fname_trim = NULL;
    char **subdirs; /* list of subdirectories to look in */

    if( !psz_name_org )
        return VLC_EGENERIC;

    char *psz_fname = vlc_uri2path( psz_name_org );
    if( !psz_fname )
        return VLC_EGENERIC;

    /* extract filename & dirname from psz_fname */
    char *f_dir = strdup( psz_fname );
    if( f_dir == 0 )
    {
        free( psz_fname );
        return VLC_ENOMEM;
    }

    const char *f_fname = strrchr( psz_fname, DIR_SEP_CHAR );
    if( !f_fname )
    {
        free( f_dir );
        free( psz_fname );
        return VLC_EGENER...",214.0,432.0,1.0,1.0,219.0,0,0,0,0,1,0,1,1,0,0,,0,0,10,5,5,int
2186,63458,subtitles_Filter,1,subtitles_Filter,int subtitles_Filter (char*),input\subtitles.c,"int subtitles_Filter( const char *psz_dir_content )
{
    const char *tmp = strrchr( psz_dir_content, '.');

    if( !tmp )
        return 0;
    tmp++;

    for( int i = 0; sub_exts[i][0]; i++ )
        if( strcasecmp( sub_exts[i], tmp ) == 0 )
            return 1;
    return 0;
}",138.0,150.0,1.0,1.0,13.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
2187,63472,vlc_audio_replay_gain_MergeFromMeta,1,vlc_audio_replay_gain_MergeFromMeta,"void vlc_audio_replay_gain_MergeFromMeta (audio_replay_gain_t*,vlc_meta_t*)",input\meta.c,"void vlc_audio_replay_gain_MergeFromMeta( audio_replay_gain_t *p_dst,
                                          const vlc_meta_t *p_meta )
{
    const char * psz_value;

    if( !p_meta )
        return;

    if( (psz_value = vlc_meta_GetExtra(p_meta, ""REPLAYGAIN_TRACK_GAIN"")) ||
        (psz_value = vlc_meta_GetExtra(p_meta, ""RG_RADIO"")) )
    {
        p_dst->pb_gain[AUDIO_REPLAY_GAIN_TRACK] = true;
        p_dst->pf_gain[AUDIO_REPLAY_GAIN_TRACK] = us_atof( psz_value );
    }

    if( (psz_value = vlc_meta_GetExtra(p_meta, ""REPLAYGAIN_TRACK_PEAK"" )) ||
             (psz_value = vlc_meta_GetExtra(p_meta, ""RG_PEAK"" )) )
    {
        p_dst->pb_peak[AUDIO_REPLAY_GAIN_TRACK] = true;
        p_dst->pf_peak[AUDIO_REPLAY_GAIN_TRACK] = us_atof( psz_value );
    }

    if( (psz_value = vlc_meta_GetExtra(p_meta, ""REPLAYGAIN_ALBUM_GAIN"" )) ||
             (psz_value = vlc_meta_GetExtra(p_meta, ""RG_AUDIOPHILE"" )) )
    {
        p_dst->pb_gain[AUDIO_REPLAY_GAIN_ALBUM] = true;
        p_dst->p...",290.0,324.0,1.0,1.0,35.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
2188,63478,input_item_node_PostAndDelete,1,input_item_node_PostAndDelete,void input_item_node_PostAndDelete (input_item_node_t*),input\item.c,"void input_item_node_PostAndDelete( input_item_node_t *p_root )
{
    vlc_event_send( &p_root->p_item->event_manager, &(vlc_event_t) {
        .type = vlc_InputItemSubItemTreeAdded,
        .u.input_item_subitem_tree_added.p_root = p_root } );

    input_item_node_Delete( p_root );
}",1302.0,1309.0,1.0,1.0,8.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
2189,63525,GuessType,1,GuessType,"int GuessType (input_item_t*,bool*)",input\item.c,"static int GuessType( const input_item_t *p_item, bool *p_net )
{
    static const struct item_type_entry tab[] =
    {   /* /!\ Alphabetical order /!\ */
        /* Short match work, not just exact match */
        { ""alsa"",   ITEM_TYPE_CARD, false },
        { ""atsc"",   ITEM_TYPE_CARD, false },
        { ""bd"",     ITEM_TYPE_DISC, false },
        { ""bluray"", ITEM_TYPE_DISC, false },
        { ""cable"",  ITEM_TYPE_CARD, false },
        { ""cdda"",   ITEM_TYPE_DISC, false },
        { ""cqam"",   ITEM_TYPE_CARD, false },
        { ""dc1394"", ITEM_TYPE_CARD, false },
        { ""dccp"",   ITEM_TYPE_STREAM, true },
        { ""deckli"", ITEM_TYPE_CARD, false }, /* decklink */
        { ""dir"",    ITEM_TYPE_DIRECTORY, false },
        { ""dshow"",  ITEM_TYPE_CARD, false },
        { ""dtv"",    ITEM_TYPE_CARD, false },
        { ""dvb"",    ITEM_TYPE_CARD, false },
        { ""dvd"",    ITEM_TYPE_DISC, false },
        { ""eyetv"",  ITEM_TYPE_CARD, false },
        { ""fd"",     ITEM_TYPE_UNKNOWN, false },
...",1154.0,1239.0,1.0,1.0,86.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
2190,63531,input_item_SetErrorWhenReading,1,input_item_SetErrorWhenReading,"void input_item_SetErrorWhenReading (input_item_t*,bool)",input\item.c,"void input_item_SetErrorWhenReading( input_item_t *p_i, bool b_error )
{
    bool b_changed;

    vlc_mutex_lock( &p_i->lock );

    b_changed = p_i->b_error_when_reading != b_error;
    p_i->b_error_when_reading = b_error;

    vlc_mutex_unlock( &p_i->lock );

    if( b_changed )
    {
        vlc_event_send( &p_i->event_manager, &(vlc_event_t) {
            .type = vlc_InputItemErrorWhenReadingChanged,
            .u.input_item_error_when_reading_changed.new_value = b_error } );
    }
}",51.0,68.0,1.0,1.0,18.0,18,6,17,8,0,3,2,2,0,3,,0,0,4,2,2,void
2191,63811,input_item_SetMeta,1,input_item_SetMeta,"void input_item_SetMeta (input_item_t*,vlc_meta_type_t,char*)",input\item.c,"void input_item_SetMeta( input_item_t *p_i, vlc_meta_type_t meta_type, const char *psz_val )
{
    vlc_mutex_lock( &p_i->lock );
    if( !p_i->p_meta )
        p_i->p_meta = vlc_meta_New();
    vlc_meta_Set( p_i->p_meta, meta_type, psz_val );
    vlc_mutex_unlock( &p_i->lock );

    /* Notify interested third parties */
    vlc_event_send( &p_i->event_manager, &(vlc_event_t) {
        .type = vlc_InputItemMetaChanged,
        .u.input_item_meta_changed.meta_type = meta_type } );
}",145.0,157.0,1.0,1.0,13.0,18,6,16,7,0,5,2,2,0,5,,0,1,6,3,3,void
2192,63868,input_item_CopyOptions,1,input_item_CopyOptions,"void input_item_CopyOptions (input_item_t*,input_item_t*)",input\item.c,"void input_item_CopyOptions( input_item_t *p_child,
                             input_item_t *p_parent )
{
    char **optv = NULL;
    uint8_t *flagv = NULL;
    int optc = 0;
    char **optv_realloc = NULL;
    uint8_t *flagv_realloc = NULL;

    vlc_mutex_lock( &p_parent->lock );

    if( p_parent->i_options > 0 )
    {
        optv = vlc_alloc( p_parent->i_options, sizeof (*optv) );
        if( likely(optv) )
            flagv = vlc_alloc( p_parent->i_options, sizeof (*flagv) );

        if( likely(flagv) )
        {
            for( int i = 0; i < p_parent->i_options; i++ )
            {
                char *psz_dup = strdup( p_parent->ppsz_options[i] );
                if( likely(psz_dup) )
                {
                    flagv[optc] = p_parent->optflagv[i];
                    optv[optc++] = psz_dup;
                }
            }
        }
    }

    vlc_mutex_unlock( &p_parent->lock );

    if( likely(optv && flagv && optc ) )
    {
        vlc_mutex_lock( &p_child-...",159.0,230.0,1.0,1.0,72.0,93,18,87,12,3,4,13,27,0,4,,0,0,4,2,2,void
2193,64146,input_item_HasErrorWhenReading,1,input_item_HasErrorWhenReading,bool input_item_HasErrorWhenReading (input_item_t*),input\item.c,"bool input_item_HasErrorWhenReading( input_item_t *p_item )
{
    vlc_mutex_lock( &p_item->lock );

    bool b_error = p_item->b_error_when_reading;

    vlc_mutex_unlock( &p_item->lock );

    return b_error;
}",232.0,241.0,1.0,1.0,10.0,6,3,5,2,1,2,1,1,0,2,,0,0,2,1,1,bool
2194,64169,input_item_MetaMatch,1,input_item_MetaMatch,"bool input_item_MetaMatch (input_item_t*,vlc_meta_type_t,char*)",input\item.c,"bool input_item_MetaMatch( input_item_t *p_i,
                           vlc_meta_type_t meta_type, const char *psz )
{
    vlc_mutex_lock( &p_i->lock );

    if( !p_i->p_meta )
    {
        vlc_mutex_unlock( &p_i->lock );
        return false;
    }
    const char *psz_meta = vlc_meta_Get( p_i->p_meta, meta_type );
    bool b_ret = psz_meta && strcasestr( psz_meta, psz );

    vlc_mutex_unlock( &p_i->lock );

    return b_ret;
}",243.0,259.0,1.0,1.0,17.0,12,5,13,6,0,4,2,2,0,4,,0,1,6,3,3,bool
2195,64217,input_item_GetMeta,1,input_item_GetMeta,"char* input_item_GetMeta (input_item_t*,vlc_meta_type_t)",input\item.c,"char *input_item_GetMeta( input_item_t *p_i, vlc_meta_type_t meta_type )
{
    vlc_mutex_lock( &p_i->lock );

    if( !p_i->p_meta )
    {
        vlc_mutex_unlock( &p_i->lock );
        return NULL;
    }

    char *psz = NULL;
    if( vlc_meta_Get( p_i->p_meta, meta_type ) )
        psz = strdup( vlc_meta_Get( p_i->p_meta, meta_type ) );

    vlc_mutex_unlock( &p_i->lock );
    return psz;
}",261.0,277.0,1.0,1.0,17.0,12,4,13,4,7,5,3,3,1,5,,0,2,4,2,2,char*
2196,64267,input_item_GetTitleFbName,1,input_item_GetTitleFbName,char* input_item_GetTitleFbName (input_item_t*),input\item.c,"char *input_item_GetTitleFbName( input_item_t *p_item )
{
    char *psz_ret;
    vlc_mutex_lock( &p_item->lock );

    if( !p_item->p_meta )
    {
        psz_ret = p_item->psz_name ? strdup( p_item->psz_name ) : NULL;
        vlc_mutex_unlock( &p_item->lock );
        return psz_ret;
    }

    const char *psz_title = vlc_meta_Get( p_item->p_meta, vlc_meta_Title );
    if( !EMPTY_STR( psz_title ) )
        psz_ret = strdup( psz_title );
    else
        psz_ret = p_item->psz_name ? strdup( p_item->psz_name ) : NULL;

    vlc_mutex_unlock( &p_item->lock );
    return psz_ret;
}",280.0,300.0,1.0,1.0,21.0,16,5,16,5,4,4,3,3,0,4,,0,1,2,1,1,char*
2197,64339,input_item_GetName,1,input_item_GetName,char* input_item_GetName (input_item_t*),input\item.c,"char *input_item_GetName( input_item_t *p_item )
{
    vlc_mutex_lock( &p_item->lock );

    char *psz_name = p_item->psz_name ? strdup( p_item->psz_name ) : NULL;

    vlc_mutex_unlock( &p_item->lock );
    return psz_name;
}",302.0,310.0,1.0,1.0,9.0,8,4,7,3,2,2,1,1,0,2,,0,0,2,1,1,char*
2198,64368,input_item_SetName,1,input_item_SetName,"void input_item_SetName (input_item_t*,char*)",input\item.c,"void input_item_SetName( input_item_t *p_item, const char *psz_name )
{
    vlc_mutex_lock( &p_item->lock );

    free( p_item->psz_name );
    p_item->psz_name = strdup( psz_name );

    vlc_mutex_unlock( &p_item->lock );
}",311.0,319.0,1.0,1.0,9.0,7,3,5,2,1,2,1,1,0,2,,0,0,4,2,2,void
2199,64394,input_item_GetURI,1,input_item_GetURI,char* input_item_GetURI (input_item_t*),input\item.c,"char *input_item_GetURI( input_item_t *p_i )
{
    vlc_mutex_lock( &p_i->lock );

    char *psz_s = p_i->psz_uri ? strdup( p_i->psz_uri ) : NULL;

    vlc_mutex_unlock( &p_i->lock );
    return psz_s;
}",321.0,329.0,1.0,1.0,9.0,8,4,7,3,4,2,1,1,0,2,,0,0,2,1,1,char*
2200,64423,input_item_SetURI,1,input_item_SetURI,"void input_item_SetURI (input_item_t*,char*)",input\item.c,"void input_item_SetURI( input_item_t *p_i, const char *psz_uri )
{
    assert( psz_uri );
#ifndef NDEBUG
    if( !strstr( psz_uri, ""://"" )
     || strchr( psz_uri, ' ' ) || strchr( psz_uri, '""' ) )
        fprintf( stderr, ""Warning: %s(\""%s\""): file path instead of URL.\n"",
                 __func__, psz_uri );
#endif
    vlc_mutex_lock( &p_i->lock );
    free( p_i->psz_uri );
    p_i->psz_uri = strdup( psz_uri );

    p_i->i_type = GuessType( p_i, &p_i->b_net );

    if( p_i->psz_name )
        ;
    else
    if( p_i->i_type == ITEM_TYPE_FILE || p_i->i_type == ITEM_TYPE_DIRECTORY )
    {
        const char *psz_filename = strrchr( p_i->psz_uri, '/' );

        if( psz_filename && *psz_filename == '/' )
            psz_filename++;
        if( psz_filename && *psz_filename )
            p_i->psz_name = strdup( psz_filename );

        /* Make the name more readable */
        if( p_i->psz_name )
        {
            vlc_uri_decode( p_i->psz_name );
            EnsureUTF8( p_i->psz_n...",331.0,397.0,1.0,1.0,67.0,15,5,16,4,2,3,3,3,0,3,,0,1,4,2,2,void
2201,64683,input_item_GetDuration,1,input_item_GetDuration,mtime_t input_item_GetDuration (input_item_t*),input\item.c,"mtime_t input_item_GetDuration( input_item_t *p_i )
{
    vlc_mutex_lock( &p_i->lock );

    mtime_t i_duration = p_i->i_duration;

    vlc_mutex_unlock( &p_i->lock );
    return i_duration;
}",399.0,407.0,1.0,1.0,9.0,6,3,5,2,5,2,1,1,0,2,,0,0,2,1,1,mtime_t
2202,64706,input_item_SetDuration,1,input_item_SetDuration,"void input_item_SetDuration (input_item_t*,mtime_t)",input\item.c,"void input_item_SetDuration( input_item_t *p_i, mtime_t i_duration )
{
    bool b_send_event = false;

    vlc_mutex_lock( &p_i->lock );
    if( p_i->i_duration != i_duration )
    {
        p_i->i_duration = i_duration;
        b_send_event = true;
    }
    vlc_mutex_unlock( &p_i->lock );

    if( b_send_event )
    {
        vlc_event_send( &p_i->event_manager, &(vlc_event_t) {
            .type = vlc_InputItemDurationChanged,
            .u.input_item_duration_changed.new_duration = i_duration } );
    }
}",409.0,427.0,1.0,1.0,19.0,19,6,20,10,1,3,3,3,0,3,,0,0,4,2,2,void
2203,64767,input_item_GetNowPlayingFb,1,input_item_GetNowPlayingFb,char* input_item_GetNowPlayingFb (input_item_t*),input\item.c,"char *input_item_GetNowPlayingFb( input_item_t *p_item )
{
    char *psz_meta = input_item_GetMeta( p_item, vlc_meta_NowPlaying );
    if( !psz_meta || strlen( psz_meta ) == 0 )
    {
        free( psz_meta );
        return input_item_GetMeta( p_item, vlc_meta_ESNowPlaying );
    }

    return psz_meta;
}",429.0,439.0,1.0,1.0,11.0,4,4,9,4,3,2,2,2,0,2,,0,1,2,1,1,char*
2204,64795,input_item_IsPreparsed,1,input_item_IsPreparsed,bool input_item_IsPreparsed (input_item_t*),input\item.c,"bool input_item_IsPreparsed( input_item_t *p_item )
{
    vlc_mutex_lock( &p_item->lock );
    bool b_preparsed = p_item->p_meta ? ( vlc_meta_GetStatus(p_item->p_meta) & ITEM_PREPARSED ) != 0 : false;
    vlc_mutex_unlock( &p_item->lock );

    return b_preparsed;
}",441.0,448.0,1.0,1.0,8.0,10,6,8,4,0,3,1,1,0,3,,0,1,2,1,1,bool
2205,64828,input_item_IsArtFetched,1,input_item_IsArtFetched,bool input_item_IsArtFetched (input_item_t*),input\item.c,"bool input_item_IsArtFetched( input_item_t *p_item )
{
    vlc_mutex_lock( &p_item->lock );
    bool b_fetched = p_item->p_meta ? ( vlc_meta_GetStatus(p_item->p_meta) & ITEM_ART_FETCHED ) != 0 : false;
    vlc_mutex_unlock( &p_item->lock );

    return b_fetched;
}",450.0,457.0,1.0,1.0,8.0,10,6,8,4,0,3,1,1,0,3,,0,1,2,1,1,bool
2206,64861,input_item_ShouldPreparseSubItems,1,input_item_ShouldPreparseSubItems,bool input_item_ShouldPreparseSubItems (input_item_t*),input\item.c,"bool input_item_ShouldPreparseSubItems( input_item_t *p_item )
{
    bool b_ret;

    vlc_mutex_lock( &p_item->lock );
    b_ret = p_item->i_preparse_depth == -1 ? true : p_item->i_preparse_depth > 0;
    vlc_mutex_unlock( &p_item->lock );

    return b_ret;
}",459.0,468.0,1.0,1.0,10.0,11,7,7,3,0,2,1,1,0,2,,0,0,2,1,1,bool
2207,64894,input_item_Hold,1,input_item_Hold,input_item_t input_item_Hold (input_item_t*),input\item.c,"input_item_t *input_item_Hold( input_item_t *p_item )
{
    input_item_owner_t *owner = item_owner(p_item);

    atomic_fetch_add( &owner->refs, 1 );
    return p_item;
}",470.0,476.0,1.0,32.0,7.0,4,4,5,2,4,0,1,1,0,0,,0,0,2,1,1,input_item_t
2208,64916,input_item_Release,1,input_item_Release,void input_item_Release (input_item_t*),input\item.c,"void input_item_Release( input_item_t *p_item )
{
    input_item_owner_t *owner = item_owner(p_item);

    if( atomic_fetch_sub(&owner->refs, 1) != 1 )
        return;

    vlc_event_manager_fini( &p_item->event_manager );

    free( p_item->psz_name );
    free( p_item->psz_uri );
    if( p_item->p_stats != NULL )
    {
        vlc_mutex_destroy( &p_item->p_stats->lock );
        free( p_item->p_stats );
    }

    if( p_item->p_meta != NULL )
        vlc_meta_Delete( p_item->p_meta );

    for( input_item_opaque_t *o = p_item->opaques, *next; o != NULL; o = next )
    {
        next = o->next;
        free( o );
    }

    for( int i = 0; i < p_item->i_options; i++ )
        free( p_item->ppsz_options[i] );
    TAB_CLEAN( p_item->i_options, p_item->ppsz_options );
    free( p_item->optflagv );

    for( int i = 0; i < p_item->i_es; i++ )
    {
        es_format_Clean( p_item->es[i] );
        free( p_item->es[i] );
    }
    TAB_CLEAN( p_item->i_es, p_item->es );

    for( int i =...",478.0,530.0,1.0,32.0,53.0,55,7,53,6,13,5,10,10,0,5,,0,0,2,1,1,void
2209,65154,input_item_AddOption,1,input_item_AddOption,"int input_item_AddOption (input_item_t*,char*,unsigned)",input\item.c,"int input_item_AddOption( input_item_t *p_input, const char *psz_option,
                          unsigned flags )
{
    int err = VLC_SUCCESS;

    if( psz_option == NULL )
        return VLC_EGENERIC;

    vlc_mutex_lock( &p_input->lock );
    if (flags & VLC_INPUT_OPTION_UNIQUE)
    {
        for (int i = 0 ; i < p_input->i_options; i++)
            if( !strcmp( p_input->ppsz_options[i], psz_option ) )
                goto out;
    }

    uint8_t *flagv = realloc (p_input->optflagv, p_input->optflagc + 1);
    if (flagv == NULL)
    {
        err = VLC_ENOMEM;
        goto out;
    }

    p_input->optflagv = flagv;

    char* psz_option_dup = strdup( psz_option );
    if( unlikely( !psz_option_dup ) )
    {
        err = VLC_ENOMEM;
        goto out;
    }

    TAB_APPEND(p_input->i_options, p_input->ppsz_options, psz_option_dup);

    flagv[p_input->optflagc++] = flags;

out:
    vlc_mutex_unlock( &p_input->lock );
    return err;
}",532.0,571.0,1.0,1.0,40.0,27,10,33,12,1,2,8,7,0,2,,0,0,6,3,3,int
2210,65270,input_item_AddOptions,1,input_item_AddOptions,"int input_item_AddOptions (input_item_t*,int,char**,unsigned)",input\item.c,"int input_item_AddOptions( input_item_t *p_item, int i_options,
                           const char *const *ppsz_options,
                           unsigned i_flags )
{
    int i_ret = VLC_SUCCESS;
    for( int i = 0; i < i_options && i_ret == VLC_SUCCESS; i++ )
        i_ret = input_item_AddOption( p_item, ppsz_options[i], i_flags );
    return i_ret;
}",573.0,581.0,1.0,1.0,9.0,5,4,8,4,2,0,2,2,0,0,,0,0,8,4,4,int
2211,65307,input_item_AddOpaque,1,input_item_AddOpaque,"int input_item_AddOpaque (input_item_t*,char*,void*)",input\item.c,"int input_item_AddOpaque(input_item_t *item, const char *name, void *value)
{
    assert(name != NULL);

    size_t namelen = strlen(name);
    input_item_opaque_t *entry = malloc(sizeof (*entry) + namelen);
    if (unlikely(entry == NULL))
        return VLC_ENOMEM;

    memcpy(entry->name, name, namelen + 1);
    entry->value = value;

    vlc_mutex_lock(&item->lock);
    entry->next = item->opaques;
    item->opaques = entry;
    vlc_mutex_unlock(&item->lock);
    return VLC_SUCCESS;
}",583.0,600.0,1.0,1.0,18.0,20,8,22,8,0,2,2,2,0,2,,0,0,6,3,3,int
2212,65377,input_item_ApplyOptions,1,input_item_ApplyOptions,"void input_item_ApplyOptions (vlc_object_t*,input_item_t*)",input\item.c,"void input_item_ApplyOptions(vlc_object_t *obj, input_item_t *item)
{
    vlc_mutex_lock(&item->lock);
    assert(item->optflagc == (unsigned)item->i_options);

    for (unsigned i = 0; i < (unsigned)item->i_options; i++)
        var_OptionParse(obj, item->ppsz_options[i],
                        !!(item->optflagv[i] & VLC_INPUT_OPTION_TRUSTED));

    for (const input_item_opaque_t *o = item->opaques; o != NULL; o = o->next)
    {
        var_Create(obj, o->name, VLC_VAR_ADDRESS);
        var_SetAddress(obj, o->name, o->value);
    }

    vlc_mutex_unlock(&item->lock);
}",602.0,618.0,1.0,1.0,17.0,18,7,17,6,1,3,3,3,0,3,,0,0,4,2,2,void
2213,65465,bsearch_strcmp_cb,1,bsearch_strcmp_cb,"int bsearch_strcmp_cb (void*,void*)",input\item.c,"static int bsearch_strcmp_cb(const void *a, const void *b)
{
    const char *const *entry = b;
    return strcasecmp(a, *entry);
}",620.0,624.0,1.0,1.0,5.0,2,2,4,3,0,0,1,1,0,0,,0,0,4,2,2,int
2214,65480,input_item_IsMaster,1,input_item_IsMaster,bool input_item_IsMaster (char*),input\item.c,"static bool input_item_IsMaster(const char *psz_filename)
{
    static const char *const ppsz_master_exts[] = { MASTER_EXTENSIONS };

    const char *psz_ext = strrchr(psz_filename, '.');
    if (psz_ext == NULL || *(++psz_ext) == '\0')
        return false;

    return bsearch(psz_ext, ppsz_master_exts, ARRAY_SIZE(ppsz_master_exts),
                   sizeof(const char *), bsearch_strcmp_cb) != NULL;
}",626.0,636.0,1.0,1.0,11.0,10,8,13,7,1,0,2,2,0,0,,0,0,2,1,1,bool
2215,65520,input_item_slave_GetType,1,input_item_slave_GetType,"bool input_item_slave_GetType (char*,slave_type*)",input\item.c,"bool input_item_slave_GetType(const char *psz_filename,
                              enum slave_type *p_slave_type)
{
    static const char *const ppsz_sub_exts[] = { SLAVE_SPU_EXTENSIONS };
    static const char *const ppsz_audio_exts[] = { SLAVE_AUDIO_EXTENSIONS };

    static struct {
        enum slave_type i_type;
        const char *const *ppsz_exts;
        size_t nmemb;
    } p_slave_list[] = {
        { SLAVE_TYPE_SPU, ppsz_sub_exts, ARRAY_SIZE(ppsz_sub_exts) },
        { SLAVE_TYPE_AUDIO, ppsz_audio_exts, ARRAY_SIZE(ppsz_audio_exts) },
    };

    const char *psz_ext = strrchr(psz_filename, '.');
    if (psz_ext == NULL || *(++psz_ext) == '\0')
        return false;

    for (unsigned int i = 0; i < sizeof(p_slave_list) / sizeof(*p_slave_list); ++i)
    {
        if (bsearch(psz_ext, p_slave_list[i].ppsz_exts, p_slave_list[i].nmemb,
                    sizeof(const char *), bsearch_strcmp_cb))
        {
            *p_slave_type = p_slave_list[i].i_type;
            retur...",638.0,667.0,1.0,1.0,30.0,29,11,32,15,3,0,4,5,0,0,,0,0,4,2,2,bool
2216,65615,input_item_slave_New,1,input_item_slave_New,"input_item_slave_t input_item_slave_New (char*,slave_type,slave_priority)",input\item.c,"input_item_slave_t *input_item_slave_New(const char *psz_uri, enum slave_type i_type,
                                       enum slave_priority i_priority)
{
    if( !psz_uri )
        return NULL;

    input_item_slave_t *p_slave = malloc( sizeof( *p_slave ) + strlen( psz_uri ) + 1 );
    if( !p_slave )
        return NULL;

    p_slave->i_type = i_type;
    p_slave->i_priority = i_priority;
    p_slave->b_forced = false;
    strcpy( p_slave->psz_uri, psz_uri );

    return p_slave;
}",669.0,685.0,1.0,1.0,17.0,14,6,16,6,5,0,3,3,0,0,,0,0,6,3,3,input_item_slave_t
2217,65668,input_item_AddSlave,1,input_item_AddSlave,"int input_item_AddSlave (input_item_t*,input_item_slave_t*)",input\item.c,"int input_item_AddSlave(input_item_t *p_item, input_item_slave_t *p_slave)
{
    if( p_item == NULL || p_slave == NULL
     || p_slave->i_priority < SLAVE_PRIORITY_MATCH_NONE )
        return VLC_EGENERIC;

    vlc_mutex_lock( &p_item->lock );

    TAB_APPEND(p_item->i_slaves, p_item->pp_slaves, p_slave);

    vlc_mutex_unlock( &p_item->lock );
    return VLC_SUCCESS;
}",687.0,699.0,1.0,1.0,13.0,12,5,13,6,2,2,2,2,0,2,,0,0,4,2,2,int
2218,65711,InputItemFindCat,1,InputItemFindCat,"info_category_t InputItemFindCat (input_item_t*,int*,char*)",input\item.c,"static info_category_t *InputItemFindCat( input_item_t *p_item,
                                          int *pi_index, const char *psz_cat )
{
    vlc_assert_locked( &p_item->lock );
    for( int i = 0; i < p_item->i_categories && psz_cat; i++ )
    {
        info_category_t *p_cat = p_item->pp_categories[i];

        if( !strcmp( p_cat->psz_name, psz_cat ) )
        {
            if( pi_index )
                *pi_index = i;
            return p_cat;
        }
    }
    return NULL;
}",701.0,717.0,1.0,1.0,17.0,13,8,15,6,5,0,4,7,0,0,,0,0,6,3,3,info_category_t
2219,65766,input_item_GetInfo,1,input_item_GetInfo,"char* input_item_GetInfo (input_item_t*,char*,char*)",input\item.c,"char *input_item_GetInfo( input_item_t *p_i,
                          const char *psz_cat,
                          const char *psz_name )
{
    vlc_mutex_lock( &p_i->lock );

    const info_category_t *p_cat = InputItemFindCat( p_i, NULL, psz_cat );
    if( p_cat )
    {
        info_t *p_info = info_category_FindInfo( p_cat, NULL, psz_name );
        if( p_info && p_info->psz_value )
        {
            char *psz_ret = strdup( p_info->psz_value );
            vlc_mutex_unlock( &p_i->lock );
            return psz_ret;
        }
    }
    vlc_mutex_unlock( &p_i->lock );
    return strdup( """" );
}",729.0,748.0,1.0,1.0,20.0,12,4,17,7,2,5,3,4,0,5,,0,2,6,3,3,char*
2220,65824,InputItemVaAddInfo,1,InputItemVaAddInfo,"int InputItemVaAddInfo (input_item_t*,char*,char*,char*,va_list)",input\item.c,"static int InputItemVaAddInfo( input_item_t *p_i,
                               const char *psz_cat,
                               const char *psz_name,
                               const char *psz_format, va_list args )
{
    vlc_assert_locked( &p_i->lock );

    info_category_t *p_cat = InputItemFindCat( p_i, NULL, psz_cat );
    if( !p_cat )
    {
        p_cat = info_category_New( psz_cat );
        if( !p_cat )
            return VLC_ENOMEM;
        TAB_APPEND(p_i->i_categories, p_i->pp_categories, p_cat);
    }
    info_t *p_info = info_category_VaAddInfo( p_cat, psz_name, psz_format, args );
    if( !p_info || !p_info->psz_value )
        return VLC_EGENERIC;
    return VLC_SUCCESS;
}",750.0,769.0,1.0,1.0,20.0,13,5,22,11,1,3,4,5,0,3,,0,3,10,5,5,int
2221,65888,input_item_AddInfo,1,input_item_AddInfo,"int input_item_AddInfo (input_item_t*,char*,char*,char*...)",input\item.c,"int input_item_AddInfo( input_item_t *p_i,
                        const char *psz_cat,
                        const char *psz_name,
                        const char *psz_format, ... )
{
    va_list args;

    vlc_mutex_lock( &p_i->lock );

    va_start( args, psz_format );
    const int i_ret = InputItemVaAddInfo( p_i, psz_cat, psz_name, psz_format, args );
    va_end( args );

    vlc_mutex_unlock( &p_i->lock );


    if( !i_ret )
        vlc_event_send( &p_i->event_manager, &(vlc_event_t) {
            .type = vlc_InputItemInfoChanged } );

    return i_ret;
}",771.0,792.0,1.0,1.0,22.0,12,6,16,8,1,4,2,2,0,4,,0,1,8,4,4,int
2222,65940,input_item_DelInfo,1,input_item_DelInfo,"int input_item_DelInfo (input_item_t*,char*,char*)",input\item.c,"int input_item_DelInfo( input_item_t *p_i,
                        const char *psz_cat,
                        const char *psz_name )
{
    vlc_mutex_lock( &p_i->lock );
    int i_cat;
    info_category_t *p_cat = InputItemFindCat( p_i, &i_cat, psz_cat );
    if( !p_cat )
    {
        vlc_mutex_unlock( &p_i->lock );
        return VLC_EGENERIC;
    }

    if( psz_name )
    {
        /* Remove a specific info */
        int i_ret = info_category_DeleteInfo( p_cat, psz_name );
        if( i_ret )
        {
            vlc_mutex_unlock( &p_i->lock );
            return VLC_EGENERIC;
        }
    }
    else
    {
        /* Remove the complete categorie */
        info_category_Delete( p_cat );
        TAB_ERASE(p_i->i_categories, p_i->pp_categories, i_cat);
    }
    vlc_mutex_unlock( &p_i->lock );

    vlc_event_send( &p_i->event_manager,
                    &(vlc_event_t) { .type = vlc_InputItemInfoChanged } );

    return VLC_SUCCESS;
}",794.0,829.0,1.0,1.0,36.0,18,6,20,10,1,7,4,5,0,7,,0,2,6,3,3,int
2223,66023,input_item_ReplaceInfos,1,input_item_ReplaceInfos,"void input_item_ReplaceInfos (input_item_t*,info_category_t*)",input\item.c,"void input_item_ReplaceInfos( input_item_t *p_item, info_category_t *p_cat )
{
    vlc_mutex_lock( &p_item->lock );
    int i_cat;
    info_category_t *p_old = InputItemFindCat( p_item, &i_cat, p_cat->psz_name );
    if( p_old )
    {
        info_category_Delete( p_old );
        p_item->pp_categories[i_cat] = p_cat;
    }
    else
        TAB_APPEND(p_item->i_categories, p_item->pp_categories, p_cat);
    vlc_mutex_unlock( &p_item->lock );

    vlc_event_send( &p_item->event_manager,
                    &(vlc_event_t) { .type = vlc_InputItemInfoChanged } );
}",830.0,846.0,1.0,1.0,17.0,16,6,14,6,1,5,2,2,0,5,,0,1,4,2,2,void
2224,66085,input_item_MergeInfos,1,input_item_MergeInfos,"void input_item_MergeInfos (input_item_t*,info_category_t*)",input\item.c,"void input_item_MergeInfos( input_item_t *p_item, info_category_t *p_cat )
{
    vlc_mutex_lock( &p_item->lock );
    info_category_t *p_old = InputItemFindCat( p_item, NULL, p_cat->psz_name );
    if( p_old )
    {
        for( int i = 0; i < p_cat->i_infos; i++ )
            info_category_ReplaceInfo( p_old, p_cat->pp_infos[i] );
        TAB_CLEAN( p_cat->i_infos, p_cat->pp_infos );
        info_category_Delete( p_cat );
    }
    else
        TAB_APPEND(p_item->i_categories, p_item->pp_categories, p_cat);
    vlc_mutex_unlock( &p_item->lock );

    vlc_event_send( &p_item->event_manager,
                    &(vlc_event_t) { .type = vlc_InputItemInfoChanged } );
}",848.0,865.0,1.0,1.0,18.0,17,6,16,7,0,5,3,4,0,5,,0,1,4,2,2,void
2225,66540,input_item_NewExt,1,input_item_NewExt,"input_item_t input_item_NewExt (char*,char*,mtime_t,int,input_item_net_type)",input\item.c,"input_item_t *
input_item_NewExt( const char *psz_uri, const char *psz_name,
                   mtime_t duration, int type, enum input_item_net_type i_net )
{
    input_item_owner_t *owner = calloc( 1, sizeof( *owner ) );
    if( unlikely(owner == NULL) )
        return NULL;

    atomic_init( &owner->refs, 1 );

    input_item_t *p_input = &owner->item;
    vlc_event_manager_t * p_em = &p_input->event_manager;

    vlc_mutex_init( &p_input->lock );

    p_input->psz_name = NULL;
    if( psz_name )
        input_item_SetName( p_input, psz_name );

    p_input->psz_uri = NULL;
    if( psz_uri )
        input_item_SetURI( p_input, psz_uri );
    else
    {
        p_input->i_type = ITEM_TYPE_UNKNOWN;
        p_input->b_net = false;
    }

    TAB_INIT( p_input->i_options, p_input->ppsz_options );
    p_input->optflagc = 0;
    p_input->optflagv = NULL;
    p_input->opaques = NULL;

    p_input->i_duration = duration;
    TAB_INIT( p_input->i_categories, p_input->pp_categories );
    T...",1057.0,1107.0,1.0,1.0,51.0,49,7,56,13,4,4,6,6,0,4,,0,0,10,5,5,input_item_t
2226,66721,input_item_Copy,1,input_item_Copy,input_item_t input_item_Copy (input_item_t*),input\item.c,"input_item_t *input_item_Copy( input_item_t *p_input )
{
    vlc_meta_t *meta = NULL;
    input_item_t *item;
    bool b_net;

    vlc_mutex_lock( &p_input->lock );

    item = input_item_NewExt( p_input->psz_uri, p_input->psz_name,
                              p_input->i_duration, p_input->i_type,
                              ITEM_NET_UNKNOWN );
    if( likely(item != NULL) && p_input->p_meta != NULL )
    {
        meta = vlc_meta_New();
        vlc_meta_Merge( meta, p_input->p_meta );
    }
    b_net = p_input->b_net;
    vlc_mutex_unlock( &p_input->lock );

    if( likely(item != NULL) )
    {   /* No need to lock; no other thread has seen this new item yet. */
        input_item_CopyOptions( item, p_input );
        item->p_meta = meta;
        item->b_net = b_net;
    }

    return item;
}",1109.0,1136.0,1.0,1.0,28.0,23,5,28,6,0,6,3,3,0,6,,0,2,2,1,1,input_item_t
2227,66808,typecmp,1,typecmp,"int typecmp (void*,void*)",input\item.c,"static int typecmp( const void *key, const void *entry )
{
    const struct item_type_entry *type = entry;
    const char *uri = key, *scheme = type->psz_scheme;

    return strncmp( uri, scheme, strlen( scheme ) );
}",1145.0,1151.0,1.0,1.0,7.0,4,2,9,5,0,1,1,1,0,0,,0,1,4,2,2,int
2228,67157,input_item_node_Create,1,input_item_node_Create,input_item_node_t input_item_node_Create (input_item_t*),input\item.c,"input_item_node_t *input_item_node_Create( input_item_t *p_input )
{
    input_item_node_t* p_node = malloc( sizeof( input_item_node_t ) );
    if( !p_node )
        return NULL;

    assert( p_input );

    p_node->p_item = p_input;
    input_item_Hold( p_input );

    p_node->i_children = 0;
    p_node->pp_children = NULL;

    return p_node;
}",1241.0,1256.0,1.0,1.0,16.0,9,4,12,4,1,1,2,2,0,1,,0,0,2,1,1,input_item_node_t
2229,67195,input_item_node_Delete,1,input_item_node_Delete,void input_item_node_Delete (input_item_node_t*),input\item.c,"void input_item_node_Delete( input_item_node_t *p_node )
{
    for( int i = 0; i < p_node->i_children; i++ )
        input_item_node_Delete( p_node->pp_children[i] );

    input_item_Release( p_node->p_item );
    free( p_node->pp_children );
    free( p_node );
}",1258.0,1266.0,1.0,1.0,9.0,5,3,6,2,1,1,2,2,0,1,,0,0,2,1,1,void
2230,67229,input_item_node_AppendItem,1,input_item_node_AppendItem,"input_item_node_t input_item_node_AppendItem (input_item_node_t*,input_item_t*)",input\item.c,"input_item_node_t *input_item_node_AppendItem( input_item_node_t *p_node, input_item_t *p_item )
{
    int i_preparse_depth;
    input_item_node_t *p_new_child = input_item_node_Create( p_item );
    if( !p_new_child ) return NULL;

    vlc_mutex_lock( &p_node->p_item->lock );
    i_preparse_depth = p_node->p_item->i_preparse_depth;
    vlc_mutex_unlock( &p_node->p_item->lock );

    vlc_mutex_lock( &p_item->lock );
    p_item->i_preparse_depth = i_preparse_depth > 0 ?
                               i_preparse_depth -1 :
                               i_preparse_depth;
    vlc_mutex_unlock( &p_item->lock );

    input_item_node_AppendNode( p_node, p_new_child );
    return p_new_child;
}",1268.0,1286.0,1.0,1.0,19.0,20,7,17,5,2,6,2,2,0,6,,0,1,4,2,2,input_item_node_t
2231,67295,input_item_node_AppendNode,1,input_item_node_AppendNode,"void input_item_node_AppendNode (input_item_node_t*,input_item_node_t*)",input\item.c,"void input_item_node_AppendNode( input_item_node_t *p_parent,
                                 input_item_node_t *p_child )
{
    assert(p_parent != NULL);
    assert(p_child != NULL);
    TAB_APPEND(p_parent->i_children, p_parent->pp_children, p_child);
}",1288.0,1294.0,1.0,1.0,7.0,4,2,7,3,1,0,1,1,0,0,,0,0,4,2,2,void
2232,67317,input_item_node_RemoveNode,1,input_item_node_RemoveNode,"void input_item_node_RemoveNode (input_item_node_t*,input_item_node_t*)",input\item.c,"void input_item_node_RemoveNode( input_item_node_t *parent,
                                 input_item_node_t *child )
{
    TAB_REMOVE(parent->i_children, parent->pp_children, child);
}",1296.0,1300.0,1.0,1.0,5.0,2,1,3,2,1,0,1,1,0,0,,0,0,4,2,2,void
2233,67363,input_item_UpdateTracksInfo,1,input_item_UpdateTracksInfo,"void input_item_UpdateTracksInfo (input_item_t*,es_format_t*)",input\item.c,"void input_item_UpdateTracksInfo(input_item_t *item, const es_format_t *fmt)
{
    int i;
    es_format_t *fmt_copy = malloc(sizeof *fmt_copy);
    if (!fmt_copy)
        return;

    es_format_Copy(fmt_copy, fmt);

    vlc_mutex_lock( &item->lock );

    for( i = 0; i < item->i_es; i++ )
    {
        if (item->es[i]->i_id != fmt->i_id)
            continue;

        /* We've found the right ES, replace it */
        es_format_Clean(item->es[i]);
        free(item->es[i]);
        item->es[i] = fmt_copy;
        vlc_mutex_unlock( &item->lock );
        return;
    }

    /* ES not found, insert it */
    TAB_APPEND(item->i_es, item->es, fmt_copy);
    vlc_mutex_unlock( &item->lock );
}",1312.0,1339.0,1.0,1.0,28.0,27,9,24,4,0,5,5,5,0,5,,0,0,4,2,2,void
2234,67455,rdh_compar_type,1,rdh_compar_type,"int rdh_compar_type (input_item_t*,input_item_t*)",input\item.c,"static int rdh_compar_type(input_item_t *p1, input_item_t *p2)
{
    if (p1->i_type != p2->i_type)
    {
        if (p1->i_type == ITEM_TYPE_DIRECTORY)
            return -1;
        if (p2->i_type == ITEM_TYPE_DIRECTORY)
            return 1;
    }
    return 0;
}",1341.0,1351.0,1.0,1.0,11.0,8,4,6,3,1,0,4,6,0,0,,0,0,4,2,2,int
2235,67491,rdh_compar_filename,1,rdh_compar_filename,"int rdh_compar_filename (void*,void*)",input\item.c,"static int rdh_compar_filename(const void *a, const void *b)
{
    input_item_node_t *const *na = a, *const *nb = b;
    input_item_t *ia = (*na)->p_item, *ib = (*nb)->p_item;

    int i_ret = rdh_compar_type(ia, ib);
    if (i_ret != 0)
        return i_ret;

    return vlc_filenamecmp(ia->psz_name, ib->psz_name);
}",1353.0,1363.0,1.0,1.0,11.0,12,4,15,7,0,2,2,2,0,2,,0,1,4,2,2,int
2236,67540,rdh_sort,1,rdh_sort,void rdh_sort (input_item_node_t*),input\item.c,"static void rdh_sort(input_item_node_t *p_node)
{
    if (p_node->i_children <= 0)
        return;

    /* Sort current node */
    qsort(p_node->pp_children, p_node->i_children,
          sizeof(input_item_node_t *), rdh_compar_filename);

    /* Sort all children */
    for (int i = 0; i < p_node->i_children; i++)
        rdh_sort(p_node->pp_children[i]);
}",1365.0,1377.0,1.0,1.0,13.0,8,5,7,3,1,0,3,3,0,0,,0,0,2,1,1,void
2237,67582,rdh_file_has_ext,1,rdh_file_has_ext,"bool rdh_file_has_ext (char*,char*)",input\item.c,"static bool rdh_file_has_ext(const char *psz_filename,
                             const char *psz_ignored_exts)
{
    if (psz_ignored_exts == NULL)
        return false;

    const char *ext = strrchr(psz_filename, '.');
    if (ext == NULL)
        return false;

    size_t extlen = strlen(++ext);

    for (const char *type = psz_ignored_exts, *end; type[0]; type = end + 1)
    {
        end = strchr(type, ',');
        if (end == NULL)
            end = type + strlen(type);

        if (type + extlen == end && !strncasecmp(ext, type, extlen))
            return true;

        if (*end == '\0')
            break;
    }

    return false;
}",1382.0,1408.0,1.0,1.0,27.0,17,8,29,9,1,0,8,10,0,0,,0,0,4,2,2,bool
2238,67670,rdh_file_is_ignored,1,rdh_file_is_ignored,"bool rdh_file_is_ignored (vlc_readdir_helper*,char*)",input\item.c,"static bool rdh_file_is_ignored(struct vlc_readdir_helper *p_rdh,
                                const char *psz_filename)
{
    return (psz_filename[0] == '\0'
         || strcmp(psz_filename, ""."") == 0
         || strcmp(psz_filename, "".."") == 0
         || (!p_rdh->b_show_hiddenfiles && psz_filename[0] == '.')
         || rdh_file_has_ext(psz_filename, p_rdh->psz_ignored_exts));
}",1410.0,1418.0,1.0,1.0,9.0,14,6,7,2,1,1,1,1,0,1,,0,0,4,2,2,bool
2239,67723,rdh_name_from_filename,1,rdh_name_from_filename,char* rdh_name_from_filename (char*),input\item.c,"static char *rdh_name_from_filename(const char *psz_filename)
{
    /* remove leading white spaces */
    while (*psz_filename != '\0' && *psz_filename == ' ')
        psz_filename++;

    char *psz_name = strdup(psz_filename);
    if (!psz_name)
        return NULL;

    /* remove extension */
    char *psz_ptr = strrchr(psz_name, '.');
    if (psz_ptr && psz_ptr != psz_name)
        *psz_ptr = '\0';

    /* remove trailing white spaces */
    int i = strlen(psz_name) - 1;
    while (psz_name[i] == ' ' && i >= 0)
        psz_name[i--] = '\0';

    /* convert to lower case */
    psz_ptr = psz_name;
    while (*psz_ptr != '\0')
    {
        *psz_ptr = tolower(*psz_ptr);
        psz_ptr++;
    }

    return psz_name;
}",1433.0,1462.0,1.0,1.0,30.0,25,10,24,5,2,0,6,6,0,0,,0,0,2,1,1,char*
2240,67810,rdh_get_slave_priority,1,rdh_get_slave_priority,"uint8_t rdh_get_slave_priority (input_item_t*,input_item_slave_t*,char*)",input\item.c,"static uint8_t rdh_get_slave_priority(input_item_t *p_item,
                                      input_item_slave_t *p_slave,
                                      const char *psz_slave_filename)
{
    uint8_t i_priority = SLAVE_PRIORITY_MATCH_NONE;
    char *psz_item_name = rdh_name_from_filename(p_item->psz_name);
    char *psz_slave_name = rdh_name_from_filename(psz_slave_filename);

    if (!psz_item_name || !psz_slave_name)
        goto done;

    size_t i_item_len = strlen(psz_item_name);
    size_t i_slave_len = strlen(psz_slave_name);

    /* The slave name len should not be twice longer than the item name len. */
    if (i_item_len > i_slave_len || i_slave_len > 2 * i_item_len)
        goto done;

    /* check if the names match exactly */
    if (!strcmp(psz_item_name, psz_slave_name))
    {
        i_priority = SLAVE_PRIORITY_MATCH_ALL;
        goto done;
    }

    /* ""cdg"" slaves have to be a full match */
    if (p_slave->i_type == SLAVE_TYPE_SPU)
    {
        char *...",1464.0,1519.0,1.0,1.0,56.0,26,11,38,15,1,2,13,10,0,2,,0,2,6,3,3,uint8_t
2241,67934,rdh_should_match_idx,1,rdh_should_match_idx,"int rdh_should_match_idx (vlc_readdir_helper*,rdh_slave*)",input\item.c,"static int rdh_should_match_idx(struct vlc_readdir_helper *p_rdh,
                                struct rdh_slave *p_rdh_sub)
{
    char *psz_ext = strrchr(p_rdh_sub->psz_filename, '.');
    if (!psz_ext)
        return false;
    psz_ext++;

    if (strcasecmp(psz_ext, ""sub"") != 0)
        return false;

    for (size_t i = 0; i < p_rdh->i_slaves; i++)
    {
        struct rdh_slave *p_rdh_slave = p_rdh->pp_slaves[i];

        if (p_rdh_slave == NULL || p_rdh_slave == p_rdh_sub)
            continue;

        /* check that priorities match */
        if (p_rdh_slave->p_slave->i_priority !=
            p_rdh_sub->p_slave->i_priority)
            continue;

        /* check that the filenames without extension match */
        if (strncasecmp(p_rdh_sub->psz_filename, p_rdh_slave->psz_filename,
                        strlen(p_rdh_sub->psz_filename) - 3 ) != 0)
            continue;

        /* check that we have an idx file */
        char *psz_ext_idx = strrchr(p_rdh_slave->psz_fil...",1521.0,1558.0,1.0,1.0,38.0,29,10,30,9,1,7,13,14,5,0,,0,7,4,2,2,int
2242,68056,rdh_attach_slaves,1,rdh_attach_slaves,"void rdh_attach_slaves (vlc_readdir_helper*,input_item_node_t*)",input\item.c,"static void rdh_attach_slaves(struct vlc_readdir_helper *p_rdh,
                              input_item_node_t *p_parent_node)
{
    if (p_rdh->i_sub_autodetect_fuzzy == 0)
        return;

    /* Try to match slaves for each items of the node */
    for (int i = 0; i < p_parent_node->i_children; i++)
    {
        input_item_node_t *p_node = p_parent_node->pp_children[i];
        input_item_t *p_item = p_node->p_item;

        enum slave_type unused;
        if (!input_item_IsMaster(p_item->psz_name)
         || input_item_slave_GetType(p_item->psz_name, &unused))
            continue; /* don't match 2 possible slaves between each others */

        for (size_t j = 0; j < p_rdh->i_slaves; j++)
        {
            struct rdh_slave *p_rdh_slave = p_rdh->pp_slaves[j];

            /* Don't try to match slaves with themselves or slaves already
             * attached with the higher priority */
            if (p_rdh_slave->p_node == p_node
             || p_rdh_slave->p_slave->i_pri...",1560.0,1628.0,1.0,1.0,69.0,55,10,54,14,1,20,18,26,8,8,,0,18,4,2,2,void
2243,68264,rdh_unflatten,1,rdh_unflatten,"int rdh_unflatten (vlc_readdir_helper*,input_item_node_t**,char*,int)",input\item.c,"static int rdh_unflatten(struct vlc_readdir_helper *p_rdh,
                         input_item_node_t **pp_node, const char *psz_path,
                         int i_net)
{
    /* Create an input input for each sub folders that is contained in the full
     * path. Update pp_node to point to the direct parent of the future item to
     * add. */

    assert(psz_path != NULL);
    const char *psz_subpaths = psz_path;

    while ((psz_subpaths = strchr(psz_subpaths, '/')))
    {
        input_item_node_t *p_subnode = NULL;

        /* Check if this sub folder item was already added */
        for (size_t i = 0; i < p_rdh->i_dirs && p_subnode == NULL; i++)
        {
            struct rdh_dir *rdh_dir = p_rdh->pp_dirs[i];
            if (!strncmp(rdh_dir->psz_path, psz_path, psz_subpaths - psz_path))
                p_subnode = rdh_dir->p_node;
        }

        /* The sub folder item doesn't exist, so create it */
        if (p_subnode == NULL)
        {
            size_t i_sub_path...",1630.0,1694.0,1.0,1.0,65.0,49,15,68,17,1,10,9,21,1,4,,0,8,8,4,4,int
2244,68464,vlc_readdir_helper_init,1,vlc_readdir_helper_init,"void vlc_readdir_helper_init (vlc_readdir_helper*,vlc_object_t*,input_item_node_t*)",input\item.c,"void vlc_readdir_helper_init(struct vlc_readdir_helper *p_rdh,
                             vlc_object_t *p_obj, input_item_node_t *p_node)
{
    /* Read options from the parent item. This allows vlc_stream_ReadDir()
     * users to specify options whitout touhing any vlc_object_t. Apply options
     * on a temporary object in order to not apply options (that can be
     * insecure) to the current object. */
    vlc_object_t *p_var_obj = vlc_object_create(p_obj, sizeof(vlc_object_t));
    if (p_var_obj != NULL)
    {
        input_item_ApplyOptions(p_var_obj, p_node->p_item);
        p_obj = p_var_obj;
    }

    p_rdh->p_node = p_node;
    p_rdh->b_show_hiddenfiles = var_InheritBool(p_obj, ""show-hiddenfiles"");
    p_rdh->psz_ignored_exts = var_InheritString(p_obj, ""ignore-filetypes"");
    bool b_autodetect = var_InheritBool(p_obj, ""sub-autodetect-file"");
    p_rdh->i_sub_autodetect_fuzzy = !b_autodetect ? 0 :
        var_InheritInteger(p_obj, ""sub-autodetect-fuzzy"");
    p_rdh->b_f...",1697.0,1723.0,1.0,1.0,27.0,23,6,29,7,0,3,3,3,0,3,,0,1,6,3,3,void
2245,68555,vlc_readdir_helper_finish,1,vlc_readdir_helper_finish,"void vlc_readdir_helper_finish (vlc_readdir_helper*,bool)",input\item.c,"void vlc_readdir_helper_finish(struct vlc_readdir_helper *p_rdh, bool b_success)
{
    if (b_success)
    {
        rdh_sort(p_rdh->p_node);
        rdh_attach_slaves(p_rdh, p_rdh->p_node);
    }
    free(p_rdh->psz_ignored_exts);

    /* Remove unmatched slaves */
    for (size_t i = 0; i < p_rdh->i_slaves; i++)
    {
        struct rdh_slave *p_rdh_slave = p_rdh->pp_slaves[i];
        if (p_rdh_slave != NULL)
        {
            input_item_slave_Delete(p_rdh_slave->p_slave);
            free(p_rdh_slave->psz_filename);
            free(p_rdh_slave);
        }
    }
    TAB_CLEAN(p_rdh->i_slaves, p_rdh->pp_slaves);

    for (size_t i = 0; i < p_rdh->i_dirs; i++)
        free(p_rdh->pp_dirs[i]);
    TAB_CLEAN(p_rdh->i_dirs, p_rdh->pp_dirs);
}",1725.0,1750.0,1.0,1.0,26.0,19,5,23,5,0,4,5,6,0,2,,0,2,4,2,2,void
2246,68647,vlc_readdir_helper_additem,1,vlc_readdir_helper_additem,"int vlc_readdir_helper_additem (vlc_readdir_helper*,char*,char*,char*,int,int)",input\item.c,"int vlc_readdir_helper_additem(struct vlc_readdir_helper *p_rdh,
                               const char *psz_uri, const char *psz_flatpath,
                               const char *psz_filename, int i_type, int i_net)
{
    enum slave_type i_slave_type;
    struct rdh_slave *p_rdh_slave = NULL;
    assert(psz_flatpath || psz_filename);

    if (!p_rdh->b_flatten)
    {
        if (psz_filename == NULL)
        {
            psz_filename = strrchr(psz_flatpath, '/');
            if (psz_filename != NULL)
                ++psz_filename;
            else
                psz_filename = psz_flatpath;
        }
    }
    else
    {
        if (psz_filename == NULL)
            psz_filename = psz_flatpath;
        psz_flatpath = NULL;
    }

    if (p_rdh->i_sub_autodetect_fuzzy != 0
     && input_item_slave_GetType(psz_filename, &i_slave_type))
    {
        p_rdh_slave = malloc(sizeof(*p_rdh_slave));
        if (!p_rdh_slave)
            return VLC_ENOMEM;

        p_rdh_slave->p_no...",1752.0,1828.0,1.0,1.0,77.0,45,12,72,15,0,15,13,19,4,8,,0,13,12,6,6,int
2247,68924,vlc_meta_TypeToLocalizedString,1,vlc_meta_TypeToLocalizedString,const char* vlc_meta_TypeToLocalizedString (vlc_meta_type_t),input\meta.c,"const char * vlc_meta_TypeToLocalizedString( vlc_meta_type_t meta_type )
{
    static const char posix_names[][18] =
    {
        [vlc_meta_Title]       = N_(""Title""),
        [vlc_meta_Artist]      = N_(""Artist""),
        [vlc_meta_Genre]       = N_(""Genre""),
        [vlc_meta_Copyright]   = N_(""Copyright""),
        [vlc_meta_Album]       = N_(""Album""),
        [vlc_meta_TrackNumber] = N_(""Track number""),
        [vlc_meta_Description] = N_(""Description""),
        [vlc_meta_Rating]      = N_(""Rating""),
        [vlc_meta_Date]        = N_(""Date""),
        [vlc_meta_Setting]     = N_(""Setting""),
        [vlc_meta_URL]         = N_(""URL""),
        [vlc_meta_Language]    = N_(""Language""),
        [vlc_meta_ESNowPlaying]= N_(""Now Playing""),
        [vlc_meta_NowPlaying]  = N_(""Now Playing""),
        [vlc_meta_Publisher]   = N_(""Publisher""),
        [vlc_meta_EncodedBy]   = N_(""Encoded by""),
        [vlc_meta_ArtworkURL]  = N_(""Artwork URL""),
        [vlc_meta_TrackID]     = N_(""Track I...",51.0,85.0,1.0,1.0,35.0,34,6,32,28,2,1,1,1,0,1,,0,0,2,1,1,const char*
2248,69078,vlc_meta_New,1,vlc_meta_New,vlc_meta_t vlc_meta_New (void),input\meta.c,"vlc_meta_t *vlc_meta_New( void )
{
    vlc_meta_t *m = (vlc_meta_t*)malloc( sizeof(*m) );
    if( !m )
        return NULL;
    memset( m->ppsz_meta, 0, sizeof(m->ppsz_meta) );
    m->i_status = 0;
    vlc_dictionary_init( &m->extra_tags, 0 );
    return m;
}",92.0,101.0,1.0,1.0,10.0,12,7,9,2,6,4,2,2,0,0,,0,4,2,1,1,vlc_meta_t
2249,69120,vlc_meta_FreeExtraKey,1,vlc_meta_FreeExtraKey,"void vlc_meta_FreeExtraKey (void*,void*)",input\meta.c,"static void vlc_meta_FreeExtraKey( void *p_data, void *p_obj )
{
    VLC_UNUSED( p_obj );
    free( p_data );
}",104.0,108.0,1.0,1.0,5.0,0,0,2,2,0,0,1,1,0,0,,0,0,4,2,2,void
2250,69130,vlc_meta_Delete,1,vlc_meta_Delete,void vlc_meta_Delete (vlc_meta_t*),input\meta.c,"void vlc_meta_Delete( vlc_meta_t *m )
{
    for( int i = 0; i < VLC_META_TYPE_COUNT ; i++ )
        free( m->ppsz_meta[i] );
    vlc_dictionary_clear( &m->extra_tags, vlc_meta_FreeExtraKey, NULL );
    free( m );
}",110.0,116.0,1.0,1.0,7.0,4,4,6,4,7,1,2,2,0,0,,0,1,2,1,1,void
2251,69161,vlc_meta_Set,1,vlc_meta_Set,"void vlc_meta_Set (vlc_meta_t*,vlc_meta_type_t,char*)",input\meta.c,"void vlc_meta_Set( vlc_meta_t *p_meta, vlc_meta_type_t meta_type, const char *psz_val )
{
    free( p_meta->ppsz_meta[meta_type] );
    assert( psz_val == NULL || IsUTF8( psz_val ) );
    p_meta->ppsz_meta[meta_type] = psz_val ? strdup( psz_val ) : NULL;
}",124.0,129.0,1.0,1.0,6.0,8,6,10,4,2,2,1,1,0,0,,0,2,6,3,3,void
2252,69192,vlc_meta_Get,1,vlc_meta_Get,"const char* vlc_meta_Get (vlc_meta_t*,vlc_meta_type_t)",input\meta.c,"const char *vlc_meta_Get( const vlc_meta_t *p_meta, vlc_meta_type_t meta_type )
{
    return p_meta->ppsz_meta[meta_type];
}",131.0,134.0,1.0,1.0,4.0,2,2,2,2,30,1,1,1,0,0,,0,1,4,2,2,const char*
2253,69204,vlc_meta_AddExtra,1,vlc_meta_AddExtra,"void vlc_meta_AddExtra (vlc_meta_t*,char*,char*)",input\meta.c,"void vlc_meta_AddExtra( vlc_meta_t *m, const char *psz_name, const char *psz_value )
{
    char *psz_oldvalue = (char *)vlc_dictionary_value_for_key( &m->extra_tags, psz_name );
    if( psz_oldvalue != kVLCDictionaryNotFound )
        vlc_dictionary_remove_value_for_key( &m->extra_tags, psz_name,
                                            vlc_meta_FreeExtraKey, NULL );
    vlc_dictionary_insert( &m->extra_tags, psz_name, strdup(psz_value) );
}",136.0,143.0,1.0,1.0,8.0,9,5,11,6,0,3,2,2,0,0,,0,3,6,3,3,void
2254,69243,vlc_meta_GetExtra,1,vlc_meta_GetExtra,"const char* vlc_meta_GetExtra (vlc_meta_t*,char*)",input\meta.c,"const char * vlc_meta_GetExtra( const vlc_meta_t *m, const char *psz_name )
{
    return (char *)vlc_dictionary_value_for_key(&m->extra_tags, psz_name);
}",145.0,148.0,1.0,1.0,4.0,3,3,2,2,1,1,1,1,0,0,,0,1,4,2,2,const char*
2255,69258,vlc_meta_GetExtraCount,1,vlc_meta_GetExtraCount,unsigned vlc_meta_GetExtraCount (vlc_meta_t*),input\meta.c,"unsigned vlc_meta_GetExtraCount( const vlc_meta_t *m )
{
    return vlc_dictionary_keys_count(&m->extra_tags);
}",150.0,153.0,1.0,1.0,4.0,2,2,1,1,0,1,1,1,0,0,,0,1,2,1,1,unsigned
2256,69269,vlc_meta_CopyExtraNames,1,vlc_meta_CopyExtraNames,char** vlc_meta_CopyExtraNames (vlc_meta_t*),input\meta.c,"char** vlc_meta_CopyExtraNames( const vlc_meta_t *m )
{
    return vlc_dictionary_all_keys(&m->extra_tags);
}",155.0,158.0,1.0,1.0,4.0,2,2,1,1,1,1,1,1,0,0,,0,1,2,1,1,char**
2257,69280,vlc_meta_GetStatus,1,vlc_meta_GetStatus,int vlc_meta_GetStatus (vlc_meta_t*),input\meta.c,"int vlc_meta_GetStatus( vlc_meta_t *m )
{
    return m->i_status;
}",163.0,166.0,1.0,1.0,4.0,1,1,1,1,2,1,1,1,0,0,,0,1,2,1,1,int
2258,69289,vlc_meta_SetStatus,1,vlc_meta_SetStatus,"void vlc_meta_SetStatus (vlc_meta_t*,int)",input\meta.c,"void vlc_meta_SetStatus( vlc_meta_t *m, int status )
{
    m->i_status = status;
}",168.0,171.0,1.0,1.0,4.0,2,2,2,2,0,1,1,1,0,0,,0,1,4,2,2,void
2259,69300,vlc_meta_Merge,1,vlc_meta_Merge,"void vlc_meta_Merge (vlc_meta_t*,vlc_meta_t*)",input\meta.c,"void vlc_meta_Merge( vlc_meta_t *dst, const vlc_meta_t *src )
{
    if( !dst || !src )
        return;

    for( int i = 0; i < VLC_META_TYPE_COUNT; i++ )
    {
        if( src->ppsz_meta[i] )
        {
            free( dst->ppsz_meta[i] );
            dst->ppsz_meta[i] = strdup( src->ppsz_meta[i] );
        }
    }

    /* XXX: If speed up are needed, it is possible */
    char **ppsz_all_keys = vlc_dictionary_all_keys( &src->extra_tags );
    for( int i = 0; ppsz_all_keys && ppsz_all_keys[i]; i++ )
    {
        /* Always try to remove the previous value */
        vlc_dictionary_remove_value_for_key( &dst->extra_tags, ppsz_all_keys[i], vlc_meta_FreeExtraKey, NULL );

        void *p_value = vlc_dictionary_value_for_key( &src->extra_tags, ppsz_all_keys[i] );
        vlc_dictionary_insert( &dst->extra_tags, ppsz_all_keys[i], strdup( (const char*)p_value ) );
        free( ppsz_all_keys[i] );
    }
    free( ppsz_all_keys );
}",177.0,203.0,1.0,1.0,27.0,32,9,34,7,3,8,5,6,1,0,,0,8,4,2,2,void
2260,69555,input_item_WriteMeta,1,input_item_WriteMeta,"int input_item_WriteMeta (vlc_object_t*,input_item_t*)",input\meta.c,"int input_item_WriteMeta( vlc_object_t *obj, input_item_t *p_item )
{
    meta_export_t *p_export =
        vlc_custom_create( obj, sizeof( *p_export ), ""meta writer"" );
    if( p_export == NULL )
        return VLC_ENOMEM;
    p_export->p_item = p_item;

    int type;
    vlc_mutex_lock( &p_item->lock );
    type = p_item->i_type;
    vlc_mutex_unlock( &p_item->lock );
    if( type != ITEM_TYPE_FILE )
        goto error;

    char *psz_uri = input_item_GetURI( p_item );
    p_export->psz_file = vlc_uri2path( psz_uri );
    if( p_export->psz_file == NULL )
        msg_Err( p_export, ""cannot write meta to remote media %s"", psz_uri );
    free( psz_uri );
    if( p_export->psz_file == NULL )
        goto error;

    module_t *p_mod = module_need( p_export, ""meta writer"", NULL, false );
    if( p_mod )
        module_unneed( p_export, p_mod );
    vlc_object_release( p_export );
    return VLC_SUCCESS;

error:
    vlc_object_release( p_export );
    return VLC_EGENERIC;
}",256.0,288.0,1.0,1.0,33.0,21,7,36,12,0,9,8,6,0,9,,0,4,4,2,2,int
2261,69794,mrl_EscapeFragmentIdentifier,1,mrl_EscapeFragmentIdentifier,"int mrl_EscapeFragmentIdentifier (char**,char*)",input\mrl_helpers.h,"static inline int
mrl_EscapeFragmentIdentifier( char** out, char const* payload )
{
    struct vlc_memstream mstream;

#define RFC3986_SUBDELIMS  ""!"" ""$"" ""&"" ""'"" ""("" "")"" \
                           ""*"" ""+"" "","" "";"" ""=""
#define RFC3986_ALPHA      ""abcdefghijklmnopqrstuvwxyz"" \
                           ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""
#define RFC3986_DIGIT      ""0123456789""
#define RFC3986_UNRESERVED RFC3986_ALPHA RFC3986_DIGIT ""-"" ""."" ""_"" ""~""
#define RFC3986_PCHAR      RFC3986_UNRESERVED RFC3986_SUBDELIMS "":"" ""@""
#define RFC3986_FRAGMENT   RFC3986_PCHAR ""/"" ""?""

    if( vlc_memstream_open( &mstream ) )
        return VLC_EGENERIC;

    for( char const* p = payload; *p; ++p )
    {
        vlc_memstream_printf( &mstream,
            ( strchr( ""!?"", *p ) == NULL &&
              strchr( RFC3986_FRAGMENT, *p ) ? ""%c"" : ""%%%02hhx""), *p );
    }

#undef RFC3986_FRAGMENT
#undef RFC3986_PCHAR
#undef RFC3986_UNRESERVEd
#undef RFC3986_DIGIT
#undef RFC3986_ALPHA
#undef RFC3986_SUBDELIMS

    if(...",57.0,93.0,1.0,22.0,37.0,14,7,15,7,1,3,4,4,2,3,,0,2,4,2,2,int
2262,69855,mrl_FragmentSplit,1,mrl_FragmentSplit,"int mrl_FragmentSplit (vlc_array_t*,char**,char*)",input\mrl_helpers.h,"static inline int
mrl_FragmentSplit( vlc_array_t* out_items,
                   char const** out_extra,
                   char const* payload )
{
    char const* extra = NULL;

    vlc_array_init( out_items );

    while( strncmp( payload, ""!/"", 2 ) == 0 )
    {
        payload += 2;

        int len = strcspn( payload, ""!?"" );
        char* decoded = strndup( payload, len );

        if( unlikely( !decoded ) || !vlc_uri_decode( decoded ) )
            goto error;

        if( vlc_array_append( out_items, decoded ) )
        {
            free( decoded );
            goto error;
        }
        payload += len;
    }

    if( *payload )
    {
        if( *payload == '!' )
            goto error;

        if( *payload == '?' && vlc_array_count( out_items ) )
            ++payload;

        extra = payload;
    }

    *out_extra = extra;
    return VLC_SUCCESS;

error:
    for( size_t i = 0; i < vlc_array_count( out_items ); ++i )
        free( vlc_array_item_at_index( out_items, i ...",114.0,160.0,1.0,1.0,47.0,21,9,32,10,0,1,11,12,1,1,,0,1,6,3,3,int
2263,70009,DestroySout,1,DestroySout,void DestroySout (input_resource_t*),input\resource.c,"static void DestroySout( input_resource_t *p_resource )
{
#ifdef ENABLE_SOUT
    if( p_resource->p_sout )
        sout_DeleteInstance( p_resource->p_sout );
#endif
    p_resource->p_sout = NULL;
}",79.0,86.0,1.0,1.0,8.0,2,2,2,2,1,1,1,1,0,0,,0,1,2,1,1,void
2264,70019,RequestSout,1,RequestSout,"sout_instance_t RequestSout (input_resource_t*,sout_instance_t*,char*)",input\resource.c,"static sout_instance_t *RequestSout( input_resource_t *p_resource,
                                     sout_instance_t *p_sout, const char *psz_sout )
{
#ifdef ENABLE_SOUT
    if( !p_sout && !psz_sout )
    {
        if( p_resource->p_sout )
        {
            msg_Dbg( p_resource->p_sout, ""destroying useless sout"" );
            DestroySout( p_resource );
        }
        return NULL;
    }

    assert( !p_sout || ( !p_resource->p_sout && !psz_sout ) );

    /* Check the validity of the sout */
    if( p_resource->p_sout &&
        strcmp( p_resource->p_sout->psz_sout, psz_sout ) )
    {
        msg_Dbg( p_resource->p_parent, ""destroying unusable sout"" );
        DestroySout( p_resource );
    }

    if( psz_sout )
    {
        if( p_resource->p_sout )
        {
            /* Reuse it */
            msg_Dbg( p_resource->p_parent, ""reusing sout"" );
            msg_Dbg( p_resource->p_parent, ""you probably want to use gather stream_out"" );
        }
        else
        {
      ...",88.0,140.0,1.0,1.0,53.0,0,0,4,4,1,0,1,1,0,0,,0,0,6,3,3,sout_instance_t
2265,70034,DestroyVout,1,DestroyVout,void DestroyVout (input_resource_t*),input\resource.c,"static void DestroyVout( input_resource_t *p_resource )
{
    assert( p_resource->i_vout == 0 );

    if( p_resource->p_vout_free )
        vout_CloseAndRelease( p_resource->p_vout_free );

    p_resource->p_vout_free = NULL;
}",143.0,151.0,1.0,1.0,9.0,6,3,5,2,1,4,2,2,1,0,,0,4,2,1,1,void
2266,70059,DisplayVoutTitle,1,DisplayVoutTitle,"void DisplayVoutTitle (input_resource_t*,vout_thread_t*)",input\resource.c,"static void DisplayVoutTitle( input_resource_t *p_resource,
                              vout_thread_t *p_vout )
{
    if( p_resource->p_input == NULL )
        return;

    /* TODO display the title only one time for the same input ? */

    input_item_t *p_item = input_GetItem( p_resource->p_input );

    char *psz_nowplaying = input_item_GetNowPlayingFb( p_item );
    if( psz_nowplaying && *psz_nowplaying )
    {
        vout_DisplayTitle( p_vout, psz_nowplaying );
    }
    else
    {
        char *psz_artist = input_item_GetArtist( p_item );
        char *psz_name = input_item_GetTitle( p_item );

        if( !psz_name || *psz_name == '\0' )
        {
            free( psz_name );
            psz_name = input_item_GetName( p_item );
        }
        if( psz_artist && *psz_artist )
        {
            char *psz_string;
            if( asprintf( &psz_string, ""%s - %s"", psz_name, psz_artist ) != -1 )
            {
                vout_DisplayTitle( p_vout, psz_string );
      ...",153.0,195.0,1.0,1.0,43.0,7,5,11,5,1,5,3,3,1,3,,0,4,4,2,2,void
2267,70158,RequestVout,1,RequestVout,"vout_thread_t RequestVout (input_resource_t*,vout_thread_t*,video_format_t*,unsigned,bool)",input\resource.c,"static vout_thread_t *RequestVout( input_resource_t *p_resource,
                                   vout_thread_t *p_vout,
                                   const video_format_t *p_fmt, unsigned dpb_size,
                                   bool b_recycle )
{
    vlc_assert_locked( &p_resource->lock );

    if( !p_vout && !p_fmt )
    {
        if( p_resource->p_vout_free )
        {
            msg_Dbg( p_resource->p_vout_free, ""destroying useless vout"" );
            vout_CloseAndRelease( p_resource->p_vout_free );
            p_resource->p_vout_free = NULL;
        }
        return NULL;
    }

    if( p_fmt )
    {
        /* */
        if( !p_vout && p_resource->p_vout_free )
        {
            msg_Dbg( p_resource->p_parent, ""trying to reuse free vout"" );
            p_vout = p_resource->p_vout_free;

            p_resource->p_vout_free = NULL;
        }
        else if( p_vout )
        {
            assert( p_vout != p_resource->p_vout_free );

            vlc_mutex_lock( ...",196.0,290.0,1.0,4.0,95.0,44,8,47,12,1,23,7,11,3,5,,0,19,10,5,5,vout_thread_t
2268,70442,HoldVout,1,HoldVout,vout_thread_t HoldVout (input_resource_t*),input\resource.c,"static vout_thread_t *HoldVout( input_resource_t *p_resource )
{
    /* TODO FIXME: p_resource->pp_vout order is NOT stable */
    vlc_mutex_lock( &p_resource->lock_hold );

    vout_thread_t *p_vout = p_resource->i_vout > 0 ? p_resource->pp_vout[0] : NULL;
    if( p_vout )
        vlc_object_hold( p_vout );

    vlc_mutex_unlock( &p_resource->lock_hold );

    return p_vout;
}",291.0,303.0,1.0,1.0,13.0,10,6,9,3,1,7,2,2,0,3,,0,4,2,1,1,vout_thread_t
2269,70479,HoldVouts,1,HoldVouts,"void HoldVouts (input_resource_t*,vout_thread_t***,size_t*)",input\resource.c,"static void HoldVouts( input_resource_t *p_resource, vout_thread_t ***ppp_vout,
                       size_t *pi_vout )
{
    vout_thread_t **pp_vout;

    *pi_vout = 0;
    *ppp_vout = NULL;

    vlc_mutex_lock( &p_resource->lock_hold );

    if( p_resource->i_vout <= 0 )
        goto exit;

    pp_vout = vlc_alloc( p_resource->i_vout, sizeof(*pp_vout) );
    if( !pp_vout )
        goto exit;

    *ppp_vout = pp_vout;
    *pi_vout = p_resource->i_vout;

    for( int i = 0; i < p_resource->i_vout; i++ )
    {
        pp_vout[i] = p_resource->pp_vout[i];
        vlc_object_hold( pp_vout[i] );
    }

exit:
    vlc_mutex_unlock( &p_resource->lock_hold );
}",305.0,333.0,1.0,1.0,29.0,28,9,23,6,1,10,6,4,2,3,,0,7,6,3,3,void
2270,70565,input_resource_GetAout,1,input_resource_GetAout,audio_output_t input_resource_GetAout (input_resource_t*),input\resource.c,"audio_output_t *input_resource_GetAout( input_resource_t *p_resource )
{
    audio_output_t *p_aout;

    vlc_mutex_lock( &p_resource->lock_hold );
    p_aout = p_resource->p_aout;

    if( p_aout == NULL || p_resource->b_aout_busy )
    {
        msg_Dbg( p_resource->p_parent, ""creating audio output"" );
        vlc_mutex_unlock( &p_resource->lock_hold );

        p_aout = aout_New( p_resource->p_parent );
        if( p_aout == NULL )
            return NULL; /* failed */

        vlc_mutex_lock( &p_resource->lock_hold );
        if( p_resource->p_aout == NULL )
            p_resource->p_aout = p_aout;
    }
    else
        msg_Dbg( p_resource->p_parent, ""reusing audio output"" );

    if( p_resource->p_aout == p_aout )
    {
        assert( !p_resource->b_aout_busy );
        p_resource->b_aout_busy = true;
    }
    vlc_mutex_unlock( &p_resource->lock_hold );
    return p_aout;
}",336.0,366.0,1.0,17.0,31.0,28,6,26,4,2,19,5,7,3,5,,0,15,2,1,1,audio_output_t
2271,70667,input_resource_PutAout,1,input_resource_PutAout,"void input_resource_PutAout (input_resource_t*,audio_output_t*)",input\resource.c,"void input_resource_PutAout( input_resource_t *p_resource,
                             audio_output_t *p_aout )
{
    assert( p_aout != NULL );

    vlc_mutex_lock( &p_resource->lock_hold );
    if( p_aout == p_resource->p_aout )
    {
        assert( p_resource->b_aout_busy );
        p_resource->b_aout_busy = false;
        msg_Dbg( p_resource->p_parent, ""keeping audio output"" );
        p_aout = NULL;
    }
    else
        msg_Dbg( p_resource->p_parent, ""destroying extra audio output"" );
    vlc_mutex_unlock( &p_resource->lock_hold );

    if( p_aout != NULL )
        aout_Destroy( p_aout );
}",368.0,387.0,1.0,1.0,20.0,13,5,15,4,5,9,3,3,1,3,,0,6,4,2,2,void
2272,70725,input_resource_HoldAout,1,input_resource_HoldAout,audio_output_t input_resource_HoldAout (input_resource_t*),input\resource.c,"audio_output_t *input_resource_HoldAout( input_resource_t *p_resource )
{
    audio_output_t *p_aout;

    vlc_mutex_lock( &p_resource->lock_hold );
    p_aout = p_resource->p_aout;
    if( p_aout != NULL )
        vlc_object_hold( p_aout );
    vlc_mutex_unlock( &p_resource->lock_hold );

    return p_aout;
}",389.0,400.0,1.0,1.0,12.0,7,4,8,3,3,6,2,2,0,3,,0,3,2,1,1,audio_output_t
2273,70755,input_resource_ResetAout,1,input_resource_ResetAout,void input_resource_ResetAout (input_resource_t*),input\resource.c,"void input_resource_ResetAout( input_resource_t *p_resource )
{
    audio_output_t *p_aout = NULL;

    vlc_mutex_lock( &p_resource->lock_hold );
    if( !p_resource->b_aout_busy )
        p_aout = p_resource->p_aout;

    p_resource->p_aout = NULL;
    p_resource->b_aout_busy = false;
    vlc_mutex_unlock( &p_resource->lock_hold );

    if( p_aout != NULL )
        aout_Destroy( p_aout );
}",402.0,416.0,1.0,1.0,15.0,14,5,14,4,1,9,3,3,1,3,,0,6,2,1,1,void
2274,70802,input_resource_New,1,input_resource_New,input_resource_t input_resource_New (vlc_object_t*),input\resource.c,"input_resource_t *input_resource_New( vlc_object_t *p_parent )
{
    input_resource_t *p_resource = calloc( 1, sizeof(*p_resource) );
    if( !p_resource )
        return NULL;

    atomic_init( &p_resource->refs, 1 );
    p_resource->p_parent = p_parent;
    vlc_mutex_init( &p_resource->lock );
    vlc_mutex_init( &p_resource->lock_hold );
    return p_resource;
}",419.0,430.0,1.0,1.0,12.0,12,6,10,3,2,6,2,2,0,2,,0,4,2,1,1,input_resource_t
2275,70844,input_resource_Release,1,input_resource_Release,void input_resource_Release (input_resource_t*),input\resource.c,"void input_resource_Release( input_resource_t *p_resource )
{
    if( atomic_fetch_sub( &p_resource->refs, 1 ) != 1 )
        return;

    DestroySout( p_resource );
    DestroyVout( p_resource );
    if( p_resource->p_aout != NULL )
        aout_Destroy( p_resource->p_aout );

    vlc_mutex_destroy( &p_resource->lock_hold );
    vlc_mutex_destroy( &p_resource->lock );
    free( p_resource );
}",432.0,445.0,1.0,1.0,14.0,10,3,9,2,4,10,3,3,2,5,,0,5,2,1,1,void
2276,70887,input_resource_Hold,1,input_resource_Hold,input_resource_t input_resource_Hold (input_resource_t*),input\resource.c,"input_resource_t *input_resource_Hold( input_resource_t *p_resource )
{
    atomic_fetch_add( &p_resource->refs, 1 );
    return p_resource;
}",447.0,451.0,1.0,1.0,5.0,2,2,2,1,0,1,1,1,0,0,,0,1,2,1,1,input_resource_t
2277,70900,input_resource_SetInput,1,input_resource_SetInput,"void input_resource_SetInput (input_resource_t*,input_thread_t*)",input\resource.c,"void input_resource_SetInput( input_resource_t *p_resource, input_thread_t *p_input )
{
    vlc_mutex_lock( &p_resource->lock );

    if( p_resource->p_input && !p_input )
        assert( p_resource->i_vout == 0 );

    /* */
    p_resource->p_input = p_input;

    vlc_mutex_unlock( &p_resource->lock );
}",453.0,464.0,1.0,1.0,12.0,11,6,7,2,0,7,2,2,1,2,,0,5,4,2,2,void
2278,70935,input_resource_RequestVout,1,input_resource_RequestVout,"vout_thread_t input_resource_RequestVout (input_resource_t*,vout_thread_t*,video_format_t*,unsigned,bool)",input\resource.c,"vout_thread_t *input_resource_RequestVout( input_resource_t *p_resource,
                                            vout_thread_t *p_vout,
                                            const video_format_t *p_fmt, unsigned dpb_size,
                                            bool b_recycle )
{
    vlc_mutex_lock( &p_resource->lock );
    vout_thread_t *p_ret = RequestVout( p_resource, p_vout, p_fmt, dpb_size, b_recycle );
    vlc_mutex_unlock( &p_resource->lock );

    return p_ret;
}",466.0,476.0,1.0,1.0,11.0,5,3,9,6,4,5,1,1,0,3,,0,3,10,5,5,vout_thread_t
2279,70965,input_resource_HoldVout,1,input_resource_HoldVout,vout_thread_t input_resource_HoldVout (input_resource_t*),input\resource.c,"vout_thread_t *input_resource_HoldVout( input_resource_t *p_resource )
{
    return HoldVout( p_resource );
}",477.0,480.0,1.0,1.0,4.0,0,0,1,1,3,1,1,1,0,1,,0,0,2,1,1,vout_thread_t
2280,70973,input_resource_HoldVouts,1,input_resource_HoldVouts,"void input_resource_HoldVouts (input_resource_t*,vout_thread_t***,size_t*)",input\resource.c,"void input_resource_HoldVouts( input_resource_t *p_resource, vout_thread_t ***ppp_vout,
                               size_t *pi_vout )
{
    HoldVouts( p_resource, ppp_vout, pi_vout );
}",482.0,486.0,1.0,1.0,5.0,0,0,3,3,3,1,1,1,0,1,,0,0,6,3,3,void
2281,70984,input_resource_TerminateVout,1,input_resource_TerminateVout,void input_resource_TerminateVout (input_resource_t*),input\resource.c,"void input_resource_TerminateVout( input_resource_t *p_resource )
{
    input_resource_RequestVout( p_resource, NULL, NULL, 0, false );
}",488.0,491.0,1.0,1.0,4.0,0,0,4,3,4,1,1,1,0,1,,0,0,2,1,1,void
2282,71025,input_resource_RequestSout,1,input_resource_RequestSout,"sout_instance_t input_resource_RequestSout (input_resource_t*,sout_instance_t*,char*)",input\resource.c,"sout_instance_t *input_resource_RequestSout( input_resource_t *p_resource, sout_instance_t *p_sout, const char *psz_sout )
{
    vlc_mutex_lock( &p_resource->lock );
    sout_instance_t *p_ret = RequestSout( p_resource, p_sout, psz_sout );
    vlc_mutex_unlock( &p_resource->lock );

    return p_ret;
}",503.0,510.0,1.0,1.0,8.0,5,3,7,4,0,5,1,1,0,3,,0,3,6,3,3,sout_instance_t
2283,71060,input_resource_Terminate,1,input_resource_Terminate,void input_resource_Terminate (input_resource_t*),input\resource.c,"void input_resource_Terminate( input_resource_t *p_resource )
{
    input_resource_TerminateSout( p_resource );
    input_resource_ResetAout( p_resource );
    input_resource_TerminateVout( p_resource );
}",516.0,521.0,1.0,1.0,6.0,0,0,3,1,1,3,1,1,0,3,,0,0,2,1,1,void
2284,71146,vlc_sd_probe_Add,1,vlc_sd_probe_Add,"int vlc_sd_probe_Add (vlc_probe_t*,char*,char*,int)",input\services_discovery.c,"int vlc_sd_probe_Add (vlc_probe_t *probe, const char *name,
                      const char *longname, int category)
{
    vlc_sd_probe_t names = { strdup(name), strdup(longname), category };

    if (unlikely (names.name == NULL || names.longname == NULL
               || vlc_probe_add (probe, &names, sizeof (names))))
    {
        free (names.name);
        free (names.longname);
        return VLC_ENOMEM;
    }
    return VLC_PROBE_CONTINUE;
}",41.0,54.0,1.0,1.0,14.0,12,7,15,8,0,4,2,2,2,0,,0,4,8,4,4,int
2285,71196,vlc_sd_GetNames,1,vlc_sd_GetNames,"char** vlc_sd_GetNames (vlc_object_t*,char***,int**)",input\services_discovery.c,"char **vlc_sd_GetNames (vlc_object_t *obj, char ***pppsz_longnames, int **pp_categories)
{
    size_t count;
    vlc_sd_probe_t *tab = vlc_probe (obj, ""services probe"", &count);

    if (count == 0)
    {
        free (tab);
        return NULL;
    }

    char **names = vlc_alloc (count + 1, sizeof(char *));
    char **longnames = vlc_alloc (count + 1, sizeof(char *));
    int *categories = vlc_alloc (count + 1, sizeof(int));

    if (unlikely (names == NULL || longnames == NULL || categories == NULL))
    {
        free(names);
        free(longnames);
        free(categories);
        free(tab);
        return NULL;
    }
    for( size_t i = 0; i < count; i++ )
    {
        names[i] = tab[i].name;
        longnames[i] = tab[i].longname;
        categories[i] = tab[i].category;
    }
    free (tab);
    names[count] = longnames[count] = NULL;
    categories[count] = 0;
    *pppsz_longnames = longnames;
    if( pp_categories ) *pp_categories = categories;
    else free( categories...",61.0,97.0,1.0,1.0,37.0,41,10,55,12,0,1,5,5,0,1,,0,1,6,3,3,char**
2286,71344,vlc_sd_Create,1,vlc_sd_Create,"services_discovery_t vlc_sd_Create (vlc_object_t*,char*,services_discovery_owner_t*)",input\services_discovery.c,"services_discovery_t *vlc_sd_Create(vlc_object_t *parent, const char *cfg,
    const struct services_discovery_owner_t *restrict owner)
{
    services_discovery_t *sd = vlc_custom_create(parent, sizeof (*sd),
                                                 ""services discovery"");
    if (unlikely(sd == NULL))
        return NULL;

    free(config_ChainCreate(&sd->psz_name, &sd->p_cfg, cfg));
    sd->description = NULL;
    sd->owner = *owner;

    sd->p_module = module_need(sd, ""services_discovery"",
                               sd->psz_name, true);
    if (sd->p_module == NULL)
    {
        msg_Err(sd, ""no suitable services discovery module"");
        vlc_sd_Destroy(sd);
        sd = NULL;
    }

    return sd;
}",106.0,128.0,1.0,31.0,23.0,19,6,25,6,1,4,3,3,0,4,,0,2,6,3,3,services_discovery_t
2287,71422,vlc_sd_Destroy,1,vlc_sd_Destroy,void vlc_sd_Destroy (services_discovery_t*),input\services_discovery.c,"void vlc_sd_Destroy(services_discovery_t *sd)
{
    if (sd->p_module != NULL)
        module_unneed(sd, sd->p_module);
    config_ChainDestroy(sd->p_cfg);
    free(sd->psz_name);
    vlc_object_release(sd);
}",130.0,137.0,1.0,1.0,8.0,5,2,7,2,2,3,2,2,0,3,,0,0,2,1,1,void
2288,71460,stats_CounterCreate,1,stats_CounterCreate,counter_t stats_CounterCreate (int),input\stats.c,"counter_t * stats_CounterCreate( int i_compute_type )
{
    counter_t *p_counter = (counter_t*) malloc( sizeof( counter_t ) ) ;

    if( !p_counter ) return NULL;
    p_counter->i_compute_type = i_compute_type;
    p_counter->i_samples = 0;
    p_counter->pp_samples = NULL;

    p_counter->last_update = 0;

    return p_counter;
}",38.0,50.0,1.0,1.0,13.0,12,5,11,4,14,4,2,2,0,0,,0,4,2,1,1,counter_t
2289,71501,stats_GetTotal,1,stats_GetTotal,int64_t stats_GetTotal (counter_t*),input\stats.c,"static inline int64_t stats_GetTotal(const counter_t *counter)
{
    if (counter == NULL || counter->i_samples == 0)
        return 0;
    return counter->pp_samples[0]->value;
}",52.0,57.0,1.0,1.0,6.0,7,4,4,2,13,2,2,2,1,0,,0,2,2,1,1,int64_t
2290,71527,stats_GetRate,1,stats_GetRate,float stats_GetRate (counter_t*),input\stats.c,"static inline float stats_GetRate(const counter_t *counter)
{
    if (counter == NULL || counter->i_samples < 2)
        return 0.;

    return (counter->pp_samples[0]->value - counter->pp_samples[1]->value)
        / (float)(counter->pp_samples[0]->date - counter->pp_samples[1]->date);
}",59.0,66.0,1.0,1.0,8.0,20,8,7,2,3,5,2,2,1,0,,0,5,2,1,1,float
2291,71609,stats_ComputeInputStats,1,stats_ComputeInputStats,"void stats_ComputeInputStats (input_thread_t*,input_stats_t*)",input\stats.c,"void stats_ComputeInputStats(input_thread_t *input, input_stats_t *st)
{
    input_thread_private_t *priv = input_priv(input);

    if (!libvlc_stats(input))
        return;

    vlc_mutex_lock(&priv->counters.counters_lock);
    vlc_mutex_lock(&st->lock);

    /* Input */
    st->i_read_packets = stats_GetTotal(priv->counters.p_read_packets);
    st->i_read_bytes = stats_GetTotal(priv->counters.p_read_bytes);
    st->f_input_bitrate = stats_GetRate(priv->counters.p_input_bitrate);
    st->i_demux_read_bytes = stats_GetTotal(priv->counters.p_demux_read);
    st->f_demux_bitrate = stats_GetRate(priv->counters.p_demux_bitrate);
    st->i_demux_corrupted = stats_GetTotal(priv->counters.p_demux_corrupted);
    st->i_demux_discontinuity = stats_GetTotal(priv->counters.p_demux_discontinuity);

    /* Decoders */
    st->i_decoded_video = stats_GetTotal(priv->counters.p_decoded_video);
    st->i_decoded_audio = stats_GetTotal(priv->counters.p_decoded_audio);

    /* Sout */
    if (priv->c...",81.0,122.0,1.0,1.0,42.0,78,5,40,3,1,21,3,3,0,21,,0,17,4,2,2,void
2292,71817,stats_ReinitInputStats,1,stats_ReinitInputStats,void stats_ReinitInputStats (input_stats_t*),input\stats.c,"void stats_ReinitInputStats( input_stats_t *p_stats )
{
    vlc_mutex_lock( &p_stats->lock );
    p_stats->i_read_packets = p_stats->i_read_bytes =
    p_stats->f_input_bitrate = p_stats->f_average_input_bitrate =
    p_stats->i_demux_read_packets = p_stats->i_demux_read_bytes =
    p_stats->f_demux_bitrate = p_stats->f_average_demux_bitrate =
    p_stats->i_demux_corrupted = p_stats->i_demux_discontinuity =
    p_stats->i_displayed_pictures = p_stats->i_lost_pictures =
    p_stats->i_played_abuffers = p_stats->i_lost_abuffers =
    p_stats->i_decoded_video = p_stats->i_decoded_audio =
    p_stats->i_sent_bytes = p_stats->i_sent_packets = p_stats->f_send_bitrate
     = 0;
    vlc_mutex_unlock( &p_stats->lock );
}",124.0,138.0,1.0,1.0,15.0,42,3,21,1,0,2,1,1,0,2,,0,0,2,1,1,void
2293,71909,stats_CounterClean,1,stats_CounterClean,void stats_CounterClean (counter_t*),input\stats.c,"void stats_CounterClean( counter_t *p_c )
{
    if( p_c )
    {
        for( int i = 0; i < p_c->i_samples; i++ )
            free( p_c->pp_samples[i] );
        TAB_CLEAN(p_c->i_samples, p_c->pp_samples);
        free( p_c );
    }
}",140.0,149.0,1.0,1.0,10.0,5,3,7,2,0,3,3,4,1,0,,0,3,2,1,1,void
2294,71945,stats_Update,1,stats_Update,"void stats_Update (counter_t*,uint64_t,uint64_t*)",input\stats.c,"void stats_Update( counter_t *p_counter, uint64_t val, uint64_t *new_val )
{
    if( !p_counter )
        return;

    switch( p_counter->i_compute_type )
    {
    case STATS_DERIVATIVE:
    {
        counter_sample_t *p_new, *p_old;
        mtime_t now = mdate();
        if( now - p_counter->last_update < CLOCK_FREQ )
            return;
        p_counter->last_update = now;
        /* Insert the new one at the beginning */
        p_new = (counter_sample_t*)malloc( sizeof( counter_sample_t ) );
        if (unlikely(p_new == NULL))
            return; /* NOTE: Losing sample here */

        p_new->value = val;
        p_new->date = p_counter->last_update;
        TAB_INSERT(p_counter->i_samples, p_counter->pp_samples, p_new, 0);

        if( p_counter->i_samples == 3 )
        {
            p_old = p_counter->pp_samples[2];
            TAB_ERASE(p_counter->i_samples, p_counter->pp_samples, 2);
            free( p_old );
        }
        break;
    }
    case STATS_COUNTER:
      ...",158.0,209.0,1.0,1.0,52.0,47,11,42,11,19,20,12,19,5,1,,0,20,6,3,3,void
2295,72152,destroy,1,stream_priv_t.destroy,void stream_priv_t.destroy (stream_t*),input\stream.c,void (*destroy)(stream_t *);,50.0,50.0,10.0,31.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
2296,72167,vlc_stream_CommonNew,1,vlc_stream_CommonNew,"stream_t vlc_stream_CommonNew (vlc_object_t*,void)",input\stream.c,"stream_t *vlc_stream_CommonNew(vlc_object_t *parent,
                               void (*destroy)(stream_t *))
{
    stream_priv_t *priv = vlc_custom_create(parent, sizeof (*priv), ""stream"");
    if (unlikely(priv == NULL))
        return NULL;

    stream_t *s = &priv->stream;

    s->p_module = NULL;
    s->psz_url = NULL;
    s->p_source = NULL;
    s->pf_read = NULL;
    s->pf_block = NULL;
    s->pf_readdir = NULL;
    s->pf_seek = NULL;
    s->pf_control = NULL;
    s->p_sys = NULL;
    s->p_input = NULL;
    assert(destroy != NULL);
    priv->destroy = destroy;
    priv->block = NULL;
    priv->peek = NULL;
    priv->offset = 0;
    priv->eof = false;

    /* UTF16 and UTF32 text file conversion */
    priv->text.conv = (vlc_iconv_t)(-1);
    priv->text.char_width = 1;
    priv->text.little_endian = false;

    return s;
}",67.0,99.0,1.0,1.0,33.0,48,9,44,6,6,6,2,2,0,1,,0,6,4,2,2,stream_t
2297,72301,stream_CommonDelete,1,stream_CommonDelete,void stream_CommonDelete (stream_t*),input\stream.c,"void stream_CommonDelete(stream_t *s)
{
    stream_priv_t *priv = (stream_priv_t *)s;

    if (priv->text.conv != (vlc_iconv_t)(-1))
        vlc_iconv_close(priv->text.conv);

    if (priv->peek != NULL)
        block_Release(priv->peek);
    if (priv->block != NULL)
        block_Release(priv->block);

    free(s->psz_url);
    vlc_object_release(s);
}",101.0,115.0,1.0,1.0,15.0,15,6,12,3,6,6,4,4,2,2,,0,4,2,1,1,void
2298,72357,vlc_stream_Delete,1,vlc_stream_Delete,void vlc_stream_Delete (stream_t*),input\stream.c,"void vlc_stream_Delete(stream_t *s)
{
    stream_priv_t *priv = (stream_priv_t *)s;

    priv->destroy(s);
    stream_CommonDelete(s);
}",120.0,126.0,1.0,1.0,7.0,3,3,5,2,10,2,1,1,0,2,,0,0,2,1,1,void
2299,72375,vlc_stream_NewURL,1,,"stream_t (vlc_object_t*,char*)",input\stream.c,"stream_t *(vlc_stream_NewURL)(vlc_object_t *p_parent, const char *psz_url)
{
    if( !psz_url )
        return NULL;

    stream_t *s = stream_AccessNew( p_parent, NULL, false, psz_url );
    if( s == NULL )
        msg_Err( p_parent, ""no suitable access module for `%s'"", psz_url );
    return s;
}",128.0,137.0,1.0,1.0,10.0,3,3,12,5,0,1,3,3,0,1,,0,1,4,2,2,stream_t
2300,72406,vlc_stream_NewMRL,1,,"stream_t (vlc_object_t*,char*)",input\stream.c,"stream_t *(vlc_stream_NewMRL)(vlc_object_t* parent, const char* mrl )
{
    stream_t* stream = vlc_stream_NewURL( parent, mrl );

    if( stream == NULL )
        return NULL;

    char const* anchor = strchr( mrl, '#' );

    if( anchor == NULL )
        return stream;

    char const* extra;
    if( stream_extractor_AttachParsed( &stream, anchor + 1, &extra ) )
    {
        msg_Err( parent, ""unable to open %s"", mrl );
        vlc_stream_Delete( stream );
        return NULL;
    }

    if( extra && *extra )
        msg_Warn( parent, ""ignoring extra fragment data: %s"", extra );

    return stream;
}",139.0,163.0,1.0,1.0,25.0,9,6,23,6,0,2,5,5,1,2,,0,1,4,2,2,stream_t
2301,72469,vlc_stream_ReadLine,1,vlc_stream_ReadLine,char* vlc_stream_ReadLine (stream_t*),input\stream.c,"char *vlc_stream_ReadLine( stream_t *s )
{
    stream_priv_t *priv = (stream_priv_t *)s;
    char *p_line = NULL;
    int i_line = 0, i_read = 0;

    /* Let's fail quickly if this is a readdir access */
    if( s->pf_read == NULL && s->pf_block == NULL )
        return NULL;

    for( ;; )
    {
        char *psz_eol;
        const uint8_t *p_data;
        int i_data;
        int64_t i_pos;

        /* Probe new data */
        i_data = vlc_stream_Peek( s, &p_data, STREAM_PROBE_LINE );
        if( i_data <= 0 ) break; /* No more data */

        /* BOM detection */
        i_pos = vlc_stream_Tell( s );
        if( i_pos == 0 && i_data >= 2 )
        {
            const char *psz_encoding = NULL;
            bool little_endian = false;

            if( unlikely(priv->text.conv != (vlc_iconv_t)-1) )
            {   /* seek back to beginning? reset */
                vlc_iconv_close( priv->text.conv );
                priv->text.conv = (vlc_iconv_t)-1;
            }
            priv->...",172.0,359.0,1.0,46.0,188.0,145,20,152,23,0,8,34,54,1,8,,0,6,2,1,1,char*
2302,73084,vlc_stream_CopyBlock,1,vlc_stream_CopyBlock,"ssize_t vlc_stream_CopyBlock (block_t**,void*,size_t)",input\stream.c,"static ssize_t vlc_stream_CopyBlock(block_t **restrict pp,
                                    void *buf, size_t len)
{
    block_t *block = *pp;

    if (block == NULL)
        return -1;

    if (len > block->i_buffer)
        len = block->i_buffer;

    if (buf != NULL)
        memcpy(buf, block->p_buffer, len);

    block->p_buffer += len;
    block->i_buffer -= len;

    if (block->i_buffer == 0)
    {
        block_Release(block);
        *pp = NULL;
    }

    return likely(len > 0) ? (ssize_t)len : -1;
}",361.0,385.0,1.0,1.0,25.0,22,11,23,5,3,0,5,5,0,0,,0,0,6,3,3,ssize_t
2303,73161,vlc_stream_ReadRaw,1,vlc_stream_ReadRaw,"ssize_t vlc_stream_ReadRaw (stream_t*,void*,size_t)",input\stream.c,"static ssize_t vlc_stream_ReadRaw(stream_t *s, void *buf, size_t len)
{
    stream_priv_t *priv = (stream_priv_t *)s;
    ssize_t ret;

    assert(len <= SSIZE_MAX);

    if (vlc_killed())
        return 0;

    if (s->pf_read != NULL)
    {
        assert(priv->block == NULL);
        if (buf == NULL)
        {
            if (unlikely(len == 0))
                return 0;

            char dummy[(len <= 256 ? len : 256)];
            ret = s->pf_read(s, dummy, sizeof (dummy));
        }
        else
            ret = s->pf_read(s, buf, len);
        return ret;
    }

    ret = vlc_stream_CopyBlock(&priv->block, buf, len);
    if (ret >= 0)
        return ret;

    if (s->pf_block != NULL)
    {
        bool eof = false;

        priv->block = s->pf_block(s, &eof);
        ret = vlc_stream_CopyBlock(&priv->block, buf, len);
        if (ret >= 0)
            return ret;
        return eof ? 0 : -1;
    }

    return 0;
}",387.0,429.0,1.0,1.0,43.0,29,11,38,10,2,7,8,12,1,3,,0,7,6,3,3,ssize_t
2304,73296,vlc_stream_ReadPartial,1,vlc_stream_ReadPartial,"ssize_t vlc_stream_ReadPartial (stream_t*,void*,size_t)",input\stream.c,"ssize_t vlc_stream_ReadPartial(stream_t *s, void *buf, size_t len)
{
    stream_priv_t *priv = (stream_priv_t *)s;
    ssize_t ret;

    ret = vlc_stream_CopyBlock(&priv->peek, buf, len);
    if (ret >= 0)
    {
        priv->offset += ret;
        assert(ret <= (ssize_t)len);
        return ret;
    }

    ret = vlc_stream_ReadRaw(s, buf, len);
    if (ret > 0)
        priv->offset += ret;
    if (ret == 0)
        priv->eof = len != 0;
    assert(ret <= (ssize_t)len);
    return ret;
}",431.0,451.0,1.0,1.0,21.0,20,10,25,5,2,6,4,4,0,2,,0,6,6,3,3,ssize_t
2305,73373,vlc_stream_Read,1,vlc_stream_Read,"ssize_t vlc_stream_Read (stream_t*,void*,size_t)",input\stream.c,"ssize_t vlc_stream_Read(stream_t *s, void *buf, size_t len)
{
    size_t copied = 0;

    while (len > 0)
    {
        ssize_t ret = vlc_stream_ReadPartial(s, buf, len);
        if (ret < 0)
            continue;
        if (ret == 0)
            break;

        if (buf != NULL)
            buf = (char *)buf + ret;
        assert(len >= (size_t)ret);
        len -= ret;
        copied += ret;
    }

    return copied;
}",453.0,473.0,1.0,1.0,21.0,13,10,20,6,5,1,7,8,0,1,,0,1,6,3,3,ssize_t
2306,73434,vlc_stream_Peek,1,vlc_stream_Peek,"ssize_t vlc_stream_Peek (stream_t*,uint8_t**,size_t)",input\stream.c,"ssize_t vlc_stream_Peek(stream_t *s, const uint8_t **restrict bufp, size_t len)
{
    stream_priv_t *priv = (stream_priv_t *)s;
    block_t *peek;

    peek = priv->peek;
    if (peek == NULL)
    {
        peek = priv->block;
        priv->peek = peek;
        priv->block = NULL;
    }

    if (peek == NULL)
    {
        peek = block_Alloc(len);
        if (unlikely(peek == NULL))
            return VLC_ENOMEM;

        peek->i_buffer = 0;
    }
    else
    if (peek->i_buffer < len)
    {
        size_t avail = peek->i_buffer;

        peek = block_TryRealloc(peek, 0, len);
        if (unlikely(peek == NULL))
            return VLC_ENOMEM;

        peek->i_buffer = avail;
    }

    priv->peek = peek;
    *bufp = peek->p_buffer;

    while (peek->i_buffer < len)
    {
        size_t avail = peek->i_buffer;
        ssize_t ret;

        ret = vlc_stream_ReadRaw(s, peek->p_buffer + avail, len - avail);
        if (ret < 0)
            continue;

        peek->i_buffer += ret;

    ...",475.0,527.0,1.0,1.0,53.0,34,9,40,9,1,7,8,10,0,2,,0,7,6,3,3,ssize_t
2307,73588,vlc_stream_ReadBlock,1,vlc_stream_ReadBlock,block_t vlc_stream_ReadBlock (stream_t*),input\stream.c,"block_t *vlc_stream_ReadBlock(stream_t *s)
{
    stream_priv_t *priv = (stream_priv_t *)s;
    block_t *block;

    if (vlc_killed())
    {
        priv->eof = true;
        return NULL;
    }

    if (priv->peek != NULL)
    {
        block = priv->peek;
        priv->peek = NULL;
    }
    else if (priv->block != NULL)
    {
        block = priv->block;
        priv->block = NULL;
    }
    else if (s->pf_block != NULL)
    {
        priv->eof = false;
        block = s->pf_block(s, &priv->eof);
    }
    else
    {
        block = block_Alloc(4096);
        if (unlikely(block == NULL))
            return NULL;

        ssize_t ret = s->pf_read(s, block->p_buffer, block->i_buffer);
        if (ret > 0)
            block->i_buffer = ret;
        else
        {
            block_Release(block);
            block = NULL;
        }

        priv->eof = !ret;
    }

    if (block != NULL)
        priv->offset += block->i_buffer;

    return block;
}",529.0,577.0,1.0,1.0,49.0,14,5,16,5,1,6,4,4,2,1,,0,6,2,1,1,block_t
2308,73736,vlc_stream_Tell,1,vlc_stream_Tell,uint64_t vlc_stream_Tell (stream_t*),input\stream.c,"uint64_t vlc_stream_Tell(const stream_t *s)
{
    const stream_priv_t *priv = (const stream_priv_t *)s;

    return priv->offset;
}",579.0,584.0,1.0,1.0,6.0,3,3,3,2,3,1,1,1,0,0,,0,1,2,1,1,uint64_t
2309,73751,vlc_stream_Eof,1,vlc_stream_Eof,bool vlc_stream_Eof (stream_t*),input\stream.c,"bool vlc_stream_Eof(const stream_t *s)
{
    const stream_priv_t *priv = (const stream_priv_t *)s;

    return priv->eof;
}",586.0,591.0,1.0,1.0,6.0,3,3,3,2,2,1,1,1,0,0,,0,1,2,1,1,bool
2310,73766,vlc_stream_Seek,1,vlc_stream_Seek,"int vlc_stream_Seek (stream_t*,uint64_t)",input\stream.c,"int vlc_stream_Seek(stream_t *s, uint64_t offset)
{
    stream_priv_t *priv = (stream_priv_t *)s;

    priv->eof = false;

    block_t *peek = priv->peek;
    if (peek != NULL)
    {
        if (offset >= priv->offset
         && offset <= (priv->offset + peek->i_buffer))
        {   /* Seeking within the peek buffer */
            size_t fwd = offset - priv->offset;

            peek->p_buffer += fwd;
            peek->i_buffer -= fwd;
            priv->offset = offset;

            if (peek->i_buffer == 0)
            {
                priv->peek = NULL;
                block_Release(peek);
            }

            return VLC_SUCCESS;
        }
    }
    else
    {
        if (priv->offset == offset)
            return VLC_SUCCESS; /* Nothing to do! */
    }

    if (s->pf_seek == NULL)
        return VLC_EGENERIC;

    int ret = s->pf_seek(s, offset);
    if (ret != VLC_SUCCESS)
        return ret;

    priv->offset = offset;

    if (peek != NULL)
    {
        priv->peek = NU...",593.0,648.0,1.0,1.0,56.0,42,12,50,10,4,12,8,11,3,0,,0,12,4,2,2,int
2311,73921,vlc_stream_vaControl,1,vlc_stream_vaControl,"int vlc_stream_vaControl (stream_t*,int,va_list)",input\stream.c,"int vlc_stream_vaControl(stream_t *s, int cmd, va_list args)
{
    stream_priv_t *priv = (stream_priv_t *)s;

    switch (cmd)
    {
        case STREAM_SET_TITLE:
        case STREAM_SET_SEEKPOINT:
        {
            int ret = s->pf_control(s, cmd, args);
            if (ret != VLC_SUCCESS)
                return ret;

            priv->offset = 0;

            if (priv->peek != NULL)
            {
                block_Release(priv->peek);
                priv->peek = NULL;
            }

            if (priv->block != NULL)
            {
                block_Release(priv->block);
                priv->block = NULL;
            }

            return VLC_SUCCESS;
        }
    }
    return s->pf_control(s, cmd, args);
}",655.0,686.0,1.0,1.0,32.0,18,4,29,9,4,7,5,8,2,0,,0,7,6,3,3,int
2312,74006,vlc_stream_Block,1,vlc_stream_Block,"block_t vlc_stream_Block (stream_t*,size_t)",input\stream.c,"block_t *vlc_stream_Block( stream_t *s, size_t size )
{
    if( unlikely(size > SSIZE_MAX) )
        return NULL;

    block_t *block = block_Alloc( size );
    if( unlikely(block == NULL) )
        return NULL;

    ssize_t val = vlc_stream_Read( s, block->p_buffer, size );
    if( val <= 0 )
    {
        block_Release( block );
        return NULL;
    }

    block->i_buffer = val;
    return block;
}",697.0,715.0,1.0,1.0,19.0,8,5,18,6,0,2,4,4,0,2,,0,2,4,2,2,block_t
2313,74058,vlc_stream_ReadDir,1,vlc_stream_ReadDir,"int vlc_stream_ReadDir (stream_t*,input_item_node_t*)",input\stream.c,"int vlc_stream_ReadDir( stream_t *s, input_item_node_t *p_node )
{
    return s->pf_readdir( s, p_node );
}",721.0,724.0,1.0,1.0,4.0,1,1,3,2,1,0,1,1,0,0,,0,0,4,2,2,int
2314,74093,stream_FilterAutoNew,1,stream_FilterAutoNew,stream_t* stream_FilterAutoNew (stream_t*),input\stream_filter.c,"stream_t *stream_FilterAutoNew( stream_t *p_source )
{
    /* Limit number of entries to avoid infinite recursion. */
    for( unsigned i = 0; i < 16; i++ )
    {
        stream_t *p_filter = vlc_stream_FilterNew( p_source, NULL );
        if( p_filter == NULL )
            break;

        msg_Dbg( p_filter, ""stream filter added to %p"", (void *)p_source );
        p_source = p_filter;
    }
    return p_source;
}",71.0,84.0,1.0,1.0,14.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,stream_t
2315,74100,stream_FilterChainNew,1,stream_FilterChainNew,"stream_t* stream_FilterChainNew (stream_t*,char*)",input\stream_filter.c,"stream_t *stream_FilterChainNew( stream_t *p_source, const char *psz_chain )
{
    /* Add user stream filter */
    char *chain = strdup( psz_chain );
    if( unlikely(chain == NULL) )
        return p_source;

    char *buf;
    for( const char *name = strtok_r( chain, "":"", &buf );
         name != NULL;
         name = strtok_r( NULL, "":"", &buf ) )
    {
        stream_t *p_filter = vlc_stream_FilterNew( p_source, name );
        if( p_filter != NULL )
            p_source = p_filter;
        else
            msg_Warn( p_source, ""cannot insert stream filter %s"", name );
    }
    free( chain );

    return p_source;
}",87.0,108.0,1.0,1.0,22.0,0,0,0,0,4,0,1,1,0,0,,0,0,4,2,2,stream_t
2316,74108,stream_extractor_AttachParsed,1,stream_extractor_AttachParsed,"int stream_extractor_AttachParsed (stream_t**,char*,char**)",input\stream_extractor.c,"int
stream_extractor_AttachParsed( stream_t** source, char const* data,
                               char const** out_extra )
{
    vlc_array_t identifiers;

    if( mrl_FragmentSplit( &identifiers, out_extra, data ) )
        return VLC_EGENERIC;

    size_t count = vlc_array_count( &identifiers );
    size_t idx = 0;

    while( idx < count )
    {
        char* id = vlc_array_item_at_index( &identifiers, idx );

        if( vlc_stream_extractor_Attach( source, id, NULL ) )
            break;

        ++idx;
    }

    for( size_t i = 0; i < count; ++i )
        free( vlc_array_item_at_index( &identifiers, i ) );
    vlc_array_clear( &identifiers );

    return idx == count ? VLC_SUCCESS : VLC_EGENERIC;
}",346.0,373.0,1.0,1.0,28.0,0,0,0,0,2,0,1,1,0,0,,0,0,6,3,3,int
2317,74151,pf_init,1,stream_extractor_private.pf_init,"int stream_extractor_private.pf_init (stream_extractor_private*,stream_t*)",input\stream_extractor.c,"int (*pf_init)( struct stream_extractor_private*, stream_t* );",61.0,61.0,9.0,65.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
2318,74157,pf_clean,1,stream_extractor_private.pf_clean,void stream_extractor_private.pf_clean (stream_extractor_private*),input\stream_extractor.c,void (*pf_clean)( struct stream_extractor_private* );,70.0,70.0,10.0,56.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
2319,74166,StreamExtractorCreateMRL,1,StreamExtractorCreateMRL,"char* StreamExtractorCreateMRL (char*,char*)",input\stream_extractor.c,"static char*
StreamExtractorCreateMRL( char const* base, char const* subentry )
{
    struct vlc_memstream buffer;
    char* escaped;

    if( mrl_EscapeFragmentIdentifier( &escaped, subentry ) )
        return NULL;

    if( vlc_memstream_open( &buffer ) )
    {
        free( escaped );
        return NULL;
    }

    vlc_memstream_puts( &buffer, base );

    if( !strstr( base, ""#"" ) )
        vlc_memstream_putc( &buffer, '#' );

    vlc_memstream_printf( &buffer, ""!/%s"", escaped );

    free( escaped );
    return vlc_memstream_close( &buffer ) ? NULL : buffer.ptr;
}",88.0,112.0,1.0,1.0,25.0,9,4,16,5,2,5,4,4,2,5,,0,2,4,2,2,char*
2320,74221,se_Release,1,se_Release,void se_Release (stream_extractor_private*),input\stream_extractor.c,"static void se_Release( struct stream_extractor_private* priv )
{
    if( priv->pf_clean )
        priv->pf_clean( priv );

    if( priv->module )
    {
        module_unneed( priv->object, priv->module );

        if( priv->source )
            vlc_stream_Delete( priv->source );
    }

    vlc_object_release( priv->object );
}",118.0,132.0,1.0,1.0,15.0,8,1,9,1,2,10,4,5,2,4,,0,6,2,1,1,void
2321,74261,se_StreamDelete,1,se_StreamDelete,void se_StreamDelete (stream_t*),input\stream_extractor.c,"static void
se_StreamDelete( stream_t* stream )
{
    se_Release( stream->p_sys );
}",140.0,144.0,1.0,1.0,5.0,1,1,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
2322,74270,se_StreamRead,1,se_StreamRead,"ssize_t se_StreamRead (stream_t*,void*,size_t)",input\stream_extractor.c,"static ssize_t
se_StreamRead( stream_t* stream, void* buf, size_t len )
{
    struct stream_extractor_private* priv = stream->p_sys;
    return priv->extractor.pf_read( &priv->extractor, buf, len );
}",146.0,151.0,1.0,1.0,6.0,6,4,6,4,0,2,1,1,0,0,,0,2,6,3,3,ssize_t
2323,74296,se_StreamBlock,1,se_StreamBlock,"block_t se_StreamBlock (stream_t*,bool*)",input\stream_extractor.c,"static block_t*
se_StreamBlock( stream_t* stream, bool* eof )
{
    struct stream_extractor_private* priv = stream->p_sys;
    return priv->extractor.pf_block( &priv->extractor, eof );
}",153.0,158.0,1.0,1.0,6.0,6,4,5,3,0,2,1,1,0,0,,0,2,4,2,2,block_t
2324,74320,se_StreamSeek,1,se_StreamSeek,"int se_StreamSeek (stream_t*,uint64_t)",input\stream_extractor.c,"static int
se_StreamSeek( stream_t* stream, uint64_t offset )
{
    struct stream_extractor_private* priv = stream->p_sys;
    return priv->extractor.pf_seek( &priv->extractor, offset );
}",160.0,165.0,1.0,1.0,6.0,6,4,5,3,0,2,1,1,0,0,,0,2,4,2,2,int
2325,74344,se_ReadDir,1,se_ReadDir,"int se_ReadDir (stream_t*,input_item_node_t*)",input\stream_extractor.c,"static int
se_ReadDir( stream_t* stream, input_item_node_t* node )
{
    struct stream_extractor_private* priv = stream->p_sys;
    return priv->directory.pf_readdir( &priv->directory, node );
}",167.0,172.0,1.0,1.0,6.0,6,4,5,3,0,2,1,1,0,0,,0,2,4,2,2,int
2326,74368,se_StreamControl,1,se_StreamControl,"int se_StreamControl (stream_t*,int,va_list)",input\stream_extractor.c,"static int
se_StreamControl( stream_t* stream, int req, va_list args )
{
    struct stream_extractor_private* priv = stream->p_sys;
    return priv->extractor.pf_control( &priv->extractor, req, args );
}",174.0,179.0,1.0,1.0,6.0,6,4,6,4,0,2,1,1,0,0,,0,2,6,3,3,int
2327,74394,se_DirControl,1,se_DirControl,"int se_DirControl (stream_t*,int,va_list)",input\stream_extractor.c,"static int
se_DirControl( stream_t* stream, int req, va_list args )
{
    (void)stream;
    (void)args;

    if( req == STREAM_IS_DIRECTORY )
        return VLC_SUCCESS;

    return VLC_EGENERIC;
}",181.0,191.0,1.0,1.0,11.0,3,2,6,6,0,0,2,2,0,0,,0,0,6,3,3,int
2328,74416,se_InitStream,1,se_InitStream,"int se_InitStream (stream_extractor_private*,stream_t*)",input\stream_extractor.c,"static int
se_InitStream( struct stream_extractor_private* priv, stream_t* s )
{
    if( priv->extractor.pf_read ) s->pf_read = se_StreamRead;
    else                          s->pf_block = se_StreamBlock;

    s->pf_seek = se_StreamSeek;
    s->pf_control = se_StreamControl;
    s->psz_url = StreamExtractorCreateMRL( priv->extractor.source->psz_url,
                                           priv->extractor.identifier );
    if( unlikely( !s->psz_url ) )
        return VLC_ENOMEM;

    return VLC_SUCCESS;
}",203.0,217.0,1.0,1.0,15.0,17,4,10,4,0,4,3,3,1,1,,0,4,4,2,2,int
2329,74479,se_CleanStream,1,se_CleanStream,void se_CleanStream (stream_extractor_private*),input\stream_extractor.c,"static void
se_CleanStream( struct stream_extractor_private* priv )
{
    free( (char*)priv->extractor.identifier );
}",219.0,223.0,1.0,1.0,5.0,3,3,1,1,0,1,1,1,0,0,,0,1,2,1,1,void
2330,74492,se_InitDirectory,1,se_InitDirectory,"int se_InitDirectory (stream_extractor_private*,stream_t*)",input\stream_extractor.c,"static int
se_InitDirectory( struct stream_extractor_private* priv, stream_t* s )
{
    stream_directory_t* directory = &priv->directory;

    s->pf_readdir = se_ReadDir;
    s->pf_control = se_DirControl;
    s->psz_url = strdup( directory->source->psz_url );

    if( unlikely( !s->psz_url ) )
        return VLC_EGENERIC;

    return VLC_SUCCESS;
}",225.0,238.0,1.0,1.0,14.0,13,4,9,5,0,1,2,2,0,0,,0,1,4,2,2,int
2331,74536,se_AttachWrapper,1,se_AttachWrapper,"int se_AttachWrapper (stream_extractor_private*,stream_t*)",input\stream_extractor.c,"static int
se_AttachWrapper( struct stream_extractor_private* priv, stream_t* source )
{
    stream_t* s = vlc_stream_CommonNew( source->obj.parent, se_StreamDelete );

    if( unlikely( !s ) )
        return VLC_ENOMEM;

    if( priv->pf_init( priv, s ) )
    {
        stream_CommonDelete( s );
        return VLC_EGENERIC;
    }

    priv->wrapper = s;
    priv->wrapper->p_input = source->p_input;
    priv->wrapper->p_sys = priv;

    priv->source = source;

    if( priv->wrapper->pf_read )
        priv->wrapper = stream_FilterChainNew( priv->wrapper, ""cache_read"" );
    else if( priv->wrapper->pf_block )
        priv->wrapper = stream_FilterChainNew( priv->wrapper, ""cache_block"" );

    return VLC_SUCCESS;
}",255.0,281.0,1.0,1.0,27.0,21,4,21,6,1,11,4,4,2,4,,0,10,4,2,2,int
2332,74633,StreamExtractorAttach,1,StreamExtractorAttach,"int StreamExtractorAttach (stream_t**,char*,char*)",input\stream_extractor.c,"static int
StreamExtractorAttach( stream_t** source, char const* identifier,
    char const* module_name )
{
    const bool extractor = identifier != NULL;
    char const* capability = extractor ? ""stream_extractor""
                                       : ""stream_directory"";

    struct stream_extractor_private* priv = vlc_custom_create(
        (*source)->obj.parent, sizeof( *priv ), capability );

    if( unlikely( !priv ) )
        return VLC_ENOMEM;

    if( extractor )
    {
        priv->object = VLC_OBJECT( &priv->extractor );

        priv->pf_init = se_InitStream;
        priv->pf_clean = se_CleanStream;

        priv->extractor.source = *source;
        priv->extractor.identifier = strdup( identifier );

        if( unlikely( !priv->extractor.identifier ) )
            goto error;
    }
    else
    {
        priv->object = VLC_OBJECT( &priv->directory );

        priv->pf_init = se_InitDirectory;
        priv->pf_clean = NULL;

        priv->directory.source = *source;
 ...",283.0,331.0,1.0,1.0,49.0,39,10,34,11,2,13,7,6,3,4,,0,12,6,3,3,int
2333,74787,vlc_stream_directory_Attach,1,vlc_stream_directory_Attach,"int vlc_stream_directory_Attach (stream_t**,char*)",input\stream_extractor.c,"int
vlc_stream_directory_Attach( stream_t** source, char const* module_name )
{
    return StreamExtractorAttach( source, NULL, module_name );
}",333.0,337.0,1.0,1.0,5.0,0,0,3,3,1,1,1,1,0,1,,0,0,4,2,2,int
2334,74798,vlc_stream_extractor_Attach,1,vlc_stream_extractor_Attach,"int vlc_stream_extractor_Attach (stream_t**,char*,char*)",input\stream_extractor.c,"int
vlc_stream_extractor_Attach( stream_t** source, char const* identifier,
                             char const* module_name )
{
    return StreamExtractorAttach( source, identifier, module_name );
}",339.0,344.0,1.0,1.0,6.0,0,0,3,3,0,1,1,1,0,1,,0,0,6,3,3,int
2335,74884,vlc_stream_extractor_CreateMRL,1,vlc_stream_extractor_CreateMRL,"char* vlc_stream_extractor_CreateMRL (stream_directory_t*,char*)",input\stream_extractor.c,"char*
vlc_stream_extractor_CreateMRL( stream_directory_t* directory,
                                char const* subentry )
{
    return StreamExtractorCreateMRL( directory->source->psz_url, subentry );
}",375.0,380.0,1.0,1.0,6.0,2,1,2,2,0,1,1,1,0,1,,0,0,4,2,2,char*
2336,74924,vlc_stream_fifo_Destroy,1,vlc_stream_fifo_Destroy,void vlc_stream_fifo_Destroy (stream_t*),input\stream_fifo.c,"static void vlc_stream_fifo_Destroy(stream_t *s)
{
    stream_sys_t *sys = s->p_sys;
    vlc_fifo_t *fifo = sys->fifo;
    block_t *block;
    bool closed;

    vlc_fifo_Lock(fifo);
    block = vlc_fifo_DequeueAllUnlocked(fifo);
    closed = sys->eof;
    sys->eof = true;
    vlc_fifo_Unlock(fifo);

    block_ChainRelease(block);

    if (closed)
    {   /* Destroy shared state if write end is already closed */
        block_FifoRelease(fifo);
        free(sys);
    }
}",42.0,62.0,1.0,1.0,21.0,9,2,16,6,0,7,2,2,0,4,,0,4,2,1,1,void
2337,74970,vlc_stream_fifo_Block,1,vlc_stream_fifo_Block,"block_t vlc_stream_fifo_Block (stream_t*,bool*)",input\stream_fifo.c,"static block_t *vlc_stream_fifo_Block(stream_t *s, bool *restrict eof)
{
    stream_sys_t *sys = s->p_sys;
    vlc_fifo_t *fifo = sys->fifo;
    block_t *block;

    vlc_fifo_Lock(fifo);
    while (vlc_fifo_IsEmpty(fifo))
    {
        if (sys->eof)
        {
            *eof = true;
            break;
        }
        vlc_fifo_Wait(fifo);
    }

    block = vlc_fifo_DequeueUnlocked(fifo);
    vlc_fifo_Unlock(fifo);
    return block;
}",64.0,84.0,1.0,1.0,21.0,8,3,14,6,0,6,4,4,1,4,,0,3,4,2,2,block_t
2338,75015,vlc_stream_fifo_Control,1,vlc_stream_fifo_Control,"int vlc_stream_fifo_Control (stream_t*,int,va_list)",input\stream_fifo.c,"static int vlc_stream_fifo_Control(stream_t *s, int query, va_list ap)
{
    (void) s;

    switch (query)
    {
        case STREAM_CAN_SEEK:
        case STREAM_CAN_FASTSEEK:
        case STREAM_CAN_PAUSE:
        case STREAM_CAN_CONTROL_PACE:
            *va_arg(ap, bool *) = false;
            break;

        case STREAM_GET_PTS_DELAY:
            *va_arg(ap, int64_t *) = DEFAULT_PTS_DELAY;
            break;

        default:
            return VLC_EGENERIC;
    }
    return VLC_SUCCESS;
}",86.0,107.0,1.0,1.0,22.0,1,1,9,9,0,0,4,2,0,0,,0,0,6,3,3,int
2339,75047,vlc_stream_fifo_New,1,vlc_stream_fifo_New,stream_t vlc_stream_fifo_New (vlc_object_t*),input\stream_fifo.c,"stream_t *vlc_stream_fifo_New(vlc_object_t *parent)
{
    stream_sys_t *sys = malloc(sizeof (*sys));
    if (unlikely(sys == NULL))
        return NULL;

    sys->fifo = block_FifoNew();
    if (unlikely(sys->fifo == NULL))
    {
        free(sys);
        return NULL;
    }

    sys->eof = false;

    stream_t *s = vlc_stream_CommonNew(parent, vlc_stream_fifo_Destroy);
    if (unlikely(s == NULL))
    {
        block_FifoRelease(sys->fifo);
        free(sys);
        return NULL;
    }

    s->pf_block = vlc_stream_fifo_Block;
    s->pf_seek = NULL;
    s->pf_control = vlc_stream_fifo_Control;
    s->p_sys = sys;
    return vlc_object_hold(s);
}",109.0,137.0,1.0,1.0,29.0,21,5,26,5,1,8,4,4,1,4,,0,6,2,1,1,stream_t
2340,75132,vlc_stream_fifo_Queue,1,vlc_stream_fifo_Queue,"int vlc_stream_fifo_Queue (stream_t*,block_t*)",input\stream_fifo.c,"int vlc_stream_fifo_Queue(stream_t *s, block_t *block)
{
    stream_sys_t *sys = s->p_sys;
    vlc_fifo_t *fifo = sys->fifo;

    vlc_fifo_Lock(fifo);
    if (likely(!sys->eof))
    {
        vlc_fifo_QueueUnlocked(fifo, block);
        block = NULL;
    }
    vlc_fifo_Unlock(fifo);

    if (unlikely(block != NULL))
    {
        block_Release(block);
        errno = EPIPE;
        return -1;
    }
    return 0;
}",139.0,159.0,1.0,1.0,21.0,10,5,16,7,2,5,3,3,1,3,,0,2,4,2,2,int
2341,75183,vlc_stream_fifo_Write,1,vlc_stream_fifo_Write,"ssize_t vlc_stream_fifo_Write (stream_t*,void*,size_t)",input\stream_fifo.c,"ssize_t vlc_stream_fifo_Write(stream_t *s, const void *buf, size_t len)
{
    block_t *block = block_Alloc(len);
    if (unlikely(block == NULL))
        return -1;

    memcpy(block->p_buffer, buf, len);
    return vlc_stream_fifo_Queue(s, block) ? -1 : (ssize_t)len;
}",161.0,169.0,1.0,1.0,9.0,7,6,10,5,0,2,2,2,0,2,,0,1,6,3,3,ssize_t
2342,75220,vlc_stream_fifo_Close,1,vlc_stream_fifo_Close,void vlc_stream_fifo_Close (stream_t*),input\stream_fifo.c,"void vlc_stream_fifo_Close(stream_t *s)
{
    stream_sys_t *sys = s->p_sys;
    vlc_fifo_t *fifo = sys->fifo;
    bool closed;

    vlc_fifo_Lock(fifo);
    closed = sys->eof;
    sys->eof = true;
    vlc_fifo_Signal(fifo);
    vlc_fifo_Unlock(fifo);

    if (closed)
    {   /* Destroy shared state if read end is already closed */
        block_FifoRelease(fifo);
        free(sys);
    }

    vlc_object_release(s);
}",171.0,190.0,1.0,1.0,20.0,8,2,15,5,2,8,2,2,0,5,,0,3,2,1,1,void
2343,75282,StreamDelete,1,StreamDelete,void StreamDelete (stream_t*),input\stream_filter.c,"static void StreamDelete( stream_t *s )
{
    module_unneed( s, s->p_module );

    if( s->p_source )
        vlc_stream_Delete( s->p_source );
}",110.0,116.0,1.0,1.0,7.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2344,75287,vlc_stream_FilterNew,1,vlc_stream_FilterNew,"stream_t vlc_stream_FilterNew (stream_t*,char*)",input\stream_filter.c,"stream_t *vlc_stream_FilterNew( stream_t *p_source,
                                const char *psz_stream_filter )
{
    stream_t *s;
    assert( p_source != NULL );

    s = vlc_stream_CommonNew( p_source->obj.parent, StreamDelete );
    if( s == NULL )
        return NULL;

    s->p_input = p_source->p_input;

    if( p_source->psz_url != NULL )
    {
        s->psz_url = strdup( p_source->psz_url );
        if( unlikely(s->psz_url == NULL) )
            goto error;
    }
    s->p_source = p_source;

    /* */
    s->p_module = module_need( s, ""stream_filter"", psz_stream_filter, true );
    if( s->p_module == NULL )
        goto error;

    return s;
error:
    stream_CommonDelete( s );
    return NULL;
}",39.0,68.0,1.0,1.0,30.0,21,5,27,6,0,3,7,6,0,3,,0,2,4,2,2,stream_t
2345,75498,vlc_stream_FilterDefaultReadDir,1,vlc_stream_FilterDefaultReadDir,"int vlc_stream_FilterDefaultReadDir (stream_t*,input_item_node_t*)",input\stream_filter.c,"int vlc_stream_FilterDefaultReadDir( stream_t *s, input_item_node_t *p_node )
{
    assert( s->p_source != NULL );
    return vlc_stream_ReadDir( s->p_source, p_node );
}",118.0,122.0,1.0,1.0,5.0,3,2,4,3,0,1,1,1,0,1,,0,0,4,2,2,int
2346,75529,Read,1,Read,"ssize_t Read (stream_t*,void*,size_t)",input\stream_memory.c,"static ssize_t Read( stream_t *s, void *p_read, size_t i_read )
{
    stream_sys_t *p_sys = s->p_sys;

    if( i_read > p_sys->i_size - p_sys->i_pos )
        i_read = p_sys->i_size - p_sys->i_pos;
    if ( p_read )
        memcpy( p_read, p_sys->p_buffer + p_sys->i_pos, i_read );
    p_sys->i_pos += i_read;
    return i_read;
}",136.0,146.0,1.0,1.0,11.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,ssize_t
2347,75536,Seek,1,Seek,"int Seek (stream_t*,ANY)",input\stream_memory.c,"static int Seek( stream_t *s, uint64_t offset )
{
    stream_sys_t *p_sys = s->p_sys;

    if( offset > p_sys->i_size )
        offset = p_sys->i_size;

    p_sys->i_pos = offset;
    return VLC_SUCCESS;
}",148.0,157.0,1.0,1.0,10.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
2348,75549,stream_MemoryPreserveDelete,1,stream_MemoryPreserveDelete,void stream_MemoryPreserveDelete (stream_t*),input\stream_memory.c,"static void stream_MemoryPreserveDelete(stream_t *s)
{
    free(s->p_sys);
}",41.0,44.0,1.0,1.0,4.0,1,1,1,1,1,0,1,1,0,0,,0,0,2,1,1,void
2349,75558,stream_MemoryDelete,1,stream_MemoryDelete,void stream_MemoryDelete (stream_t*),input\stream_memory.c,"static void stream_MemoryDelete(stream_t *s)
{
    stream_sys_t *sys = s->p_sys;

    free(sys->p_buffer);
    stream_MemoryPreserveDelete(s);
}",46.0,52.0,1.0,1.0,7.0,3,2,4,2,0,2,1,1,0,1,,0,1,2,1,1,void
2350,75575,vlc_stream_MemoryNew,1,,"stream_t (vlc_object_t*,uint8_t*,size_t,bool)",input\stream_memory.c,"stream_t *(vlc_stream_MemoryNew)(vlc_object_t *p_this, uint8_t *p_buffer,
                                 size_t i_size, bool preserve)
{
    stream_t *s = vlc_stream_CommonNew( p_this,
                                        preserve ? stream_MemoryPreserveDelete
                                                 : stream_MemoryDelete );
    stream_sys_t *p_sys;

    if( !s )
        return NULL;

    s->p_sys = p_sys = malloc( sizeof( stream_sys_t ) );
    if( !s->p_sys )
    {
        stream_CommonDelete( s );
        return NULL;
    }
    p_sys->i_pos = 0;
    p_sys->i_size = i_size;
    p_sys->p_buffer = p_buffer;

    s->pf_read    = Read;
    s->pf_seek    = Seek;
    s->pf_control = Control;

    return s;
}",54.0,80.0,1.0,1.0,27.0,21,5,23,11,0,5,3,3,0,2,,0,4,8,4,4,stream_t
2351,75843,strcpy_trim,1,strcpy_trim,"void strcpy_trim (char*,char*)",input\subtitles.c,"static void strcpy_trim( char *d, const char *s )
{
    unsigned char c;

    /* skip leading whitespace */
    while( ((c = *s) != '\0') && !isalnum(c) )
    {
        s++;
    }
    for(;;)
    {
        /* copy word */
        while( ((c = *s) != '\0') && isalnum(c) )
        {
            *d = tolower(c);
            s++; d++;
        }
        if( *s == 0 ) break;
        /* trim excess whitespace */
        while( ((c = *s) != '\0') && !isalnum(c) )
        {
            s++;
        }
        if( *s == 0 ) break;
        *d++ = ' ';
    }
    *d = 0;
}",49.0,76.0,1.0,1.0,28.0,29,7,19,3,0,0,9,11,0,0,,0,0,4,2,2,void
2352,75924,strcpy_strip_ext,1,strcpy_strip_ext,"void strcpy_strip_ext (char*,char*)",input\subtitles.c,"static void strcpy_strip_ext( char *d, const char *s )
{
    unsigned char c;

    const char *tmp = strrchr(s, '.');
    if( !tmp )
    {
        strcpy(d, s);
        return;
    }
    else
        strlcpy(d, s, tmp - s + 1 );
    while( (c = *d) != '\0' )
    {
        *d = tolower(c);
        d++;
    }
}",78.0,95.0,1.0,1.0,18.0,8,5,10,4,0,0,3,3,0,0,,0,0,4,2,2,void
2353,75970,strcpy_get_ext,1,strcpy_get_ext,"void strcpy_get_ext (char*,char*)",input\subtitles.c,"static void strcpy_get_ext( char *d, const char *s )
{
    const char *tmp = strrchr(s, '.');
    if( !tmp )
        strcpy(d, """");
    else
        strcpy( d, tmp + 1 );
}",97.0,104.0,1.0,1.0,8.0,2,2,4,3,0,0,2,2,0,0,,0,0,4,2,2,void
2354,75996,whiteonly,1,whiteonly,int whiteonly (char*),input\subtitles.c,"static int whiteonly( const char *s )
{
    unsigned char c;

    while( (c = *s) != '\0' )
    {
        if( isalnum( c ) )
            return 0;
        s++;
    }
    return 1;
}",106.0,117.0,1.0,1.0,12.0,4,4,4,2,0,0,3,4,0,0,,0,0,2,1,1,int
2355,76020,slave_strcmp,1,slave_strcmp,"int slave_strcmp (void*,void*)",input\subtitles.c,"static int slave_strcmp( const void *a, const void *b )
{
    const input_item_slave_t *p_slave0 = *((const input_item_slave_t **) a);
    const input_item_slave_t *p_slave1 = *((const input_item_slave_t **) b);

    if( p_slave0 == NULL || p_slave1 == NULL )
        return 0;

    /* We can compare these uris since they come from the file system */
#ifdef HAVE_STRCOLL
    return strcoll( p_slave0->psz_uri, p_slave1->psz_uri );
#else
    return strcmp( p_slave0->psz_uri, p_slave1->psz_uri );
#endif
}",119.0,133.0,1.0,1.0,15.0,11,6,10,5,0,0,2,2,0,0,,0,0,4,2,2,int
2356,76104,paths_to_list,1,paths_to_list,"char** paths_to_list (char*,char*)",input\subtitles.c,"static char **paths_to_list( const char *psz_dir, char *psz_path )
{
    unsigned int i, k, i_nb_subdirs;
    char **subdirs; /* list of subdirectories to look in */
    char *psz_parser = psz_path;

    if( !psz_dir || !psz_path )
        return NULL;

    for( k = 0, i_nb_subdirs = 1; psz_path[k] != '\0'; k++ )
    {
        if( psz_path[k] == ',' )
            i_nb_subdirs++;
    }

    subdirs = calloc( i_nb_subdirs + 1, sizeof(char*) );
    if( !subdirs )
        return NULL;

    for( i = 0; psz_parser && *psz_parser != '\0' ; )
    {
        char *psz_subdir = psz_parser;
        psz_parser = strchr( psz_subdir, ',' );
        if( psz_parser )
        {
            *psz_parser++ = '\0';
            while( *psz_parser == ' ' )
                psz_parser++;
        }
        if( *psz_subdir == '\0' )
            continue;

        if( asprintf( &subdirs[i++], ""%s%s"",
                  psz_subdir[0] == '.' ? psz_dir : """",
                  psz_subdir ) == -1 )
            break;...",156.0,196.0,1.0,1.0,41.0,39,15,37,10,0,0,12,16,0,0,,0,0,4,2,2,char**
2357,76832,StateCallback,1,StateCallback,"int StateCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",input\var.c,"static int StateCallback( vlc_object_t *p_this, char const *psz_cmd,
                          vlc_value_t oldval, vlc_value_t newval,
                          void *p_data )
{
    input_thread_t *p_input = (input_thread_t*)p_this;
    VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval); VLC_UNUSED(p_data);

    if( newval.i_int == PLAYING_S || newval.i_int == PAUSE_S )
    {
        input_ControlPush( p_input, INPUT_CONTROL_SET_STATE, &newval );
        return VLC_SUCCESS;
    }

    return VLC_EGENERIC;
}",556.0,570.0,1.0,1.0,15.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,int
2358,76841,RateCallback,1,RateCallback,"int RateCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",playlist\engine.c,"static int RateCallback( vlc_object_t *p_this, char const *psz_cmd,
                         vlc_value_t oldval, vlc_value_t newval, void *p )
{
    (void)psz_cmd; (void)oldval;(void)p;
    playlist_t *p_playlist = (playlist_t*)p_this;

    PL_LOCK;

    if( pl_priv(p_playlist)->p_input )
        var_SetFloat( pl_priv( p_playlist )->p_input, ""rate"", newval.f_float );

    PL_UNLOCK;
    return VLC_SUCCESS;
}",117.0,130.0,1.0,8.0,14.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,int
2359,76850,PositionCallback,1,PositionCallback,"int PositionCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",input\var.c,"static int PositionCallback( vlc_object_t *p_this, char const *psz_cmd,
                             vlc_value_t oldval, vlc_value_t newval,
                             void *p_data )
{
    input_thread_t *p_input = (input_thread_t*)p_this;

    VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval); VLC_UNUSED(p_data);

    /* Update ""length"" for better intf behaviour */
    const int64_t i_length = var_GetInteger( p_input, ""length"" );
    if( i_length > 0 && newval.f_float >= 0.f && newval.f_float <= 1.f )
    {
        vlc_value_t val;

        val.i_int = i_length * newval.f_float;
        var_Change( p_input, ""time"", VLC_VAR_SETVALUE, &val, NULL );
    }

    input_ControlPush( p_input, INPUT_CONTROL_SET_POSITION, &newval );
    return VLC_SUCCESS;
}",584.0,604.0,1.0,1.0,21.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,int
2360,76859,TimeCallback,1,TimeCallback,"int TimeCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",input\var.c,"static int TimeCallback( vlc_object_t *p_this, char const *psz_cmd,
                         vlc_value_t oldval, vlc_value_t newval, void *p_data )
{
    input_thread_t *p_input = (input_thread_t*)p_this;
    VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval); VLC_UNUSED(p_data);

    /* Update ""position"" for better intf behaviour */
    const int64_t i_length = var_GetInteger( p_input, ""length"" );
    if( i_length > 0 && newval.i_int >= 0 && newval.i_int <= i_length )
    {
        vlc_value_t val;

        val.f_float = (double)newval.i_int/(double)i_length;
        var_Change( p_input, ""position"", VLC_VAR_SETVALUE, &val, NULL );
        /*
         * Notify the intf that a new event has been occurred.
         * XXX this is a bit hackish but it's the only way to do it now.
         */
        var_SetInteger( p_input, ""intf-event"", INPUT_EVENT_POSITION );
    }

    input_ControlPush( p_input, INPUT_CONTROL_SET_TIME, &newval );
    return VLC_SUCCESS;
}",606.0,629.0,1.0,1.0,24.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,int
2361,76868,TimeOffsetCallback,1,TimeOffsetCallback,"int TimeOffsetCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",input\var.c,"static int TimeOffsetCallback( vlc_object_t *obj, char const *varname,
                               vlc_value_t prev, vlc_value_t cur, void *data )
{
    VLC_UNUSED(varname); VLC_UNUSED(prev); VLC_UNUSED(data);

    int64_t i_time = var_GetInteger( obj, ""time"" ) + cur.i_int;
    if( i_time < 0 )
        i_time = 0;
    var_SetInteger( obj, ""time"", i_time );
    return VLC_SUCCESS;
}",631.0,641.0,1.0,1.0,11.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,int
2362,76877,ProgramCallback,1,ProgramCallback,"int ProgramCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",input\var.c,"static int ProgramCallback( vlc_object_t *p_this, char const *psz_cmd,
                            vlc_value_t oldval, vlc_value_t newval,
                            void *p_data )
{
    input_thread_t *p_input = (input_thread_t*)p_this;
    VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval); VLC_UNUSED(p_data);

    input_ControlPush( p_input, INPUT_CONTROL_SET_PROGRAM, &newval );

    return VLC_SUCCESS;
}",643.0,653.0,1.0,1.0,11.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,int
2363,76886,TitleCallback,1,TitleCallback,"int TitleCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",input\var.c,"static int TitleCallback( vlc_object_t *p_this, char const *psz_cmd,
                          vlc_value_t oldval, vlc_value_t newval,
                          void *p_data )
{
    input_thread_t *p_input = (input_thread_t*)p_this;
    vlc_value_t val, count;
    VLC_UNUSED(oldval); VLC_UNUSED(p_data);

    if( !strcmp( psz_cmd, ""next-title"" ) )
    {
        input_ControlPush( p_input, INPUT_CONTROL_SET_TITLE_NEXT, NULL );

        val.i_int = var_GetInteger( p_input, ""title"" ) + 1;
        var_Change( p_input, ""title"", VLC_VAR_CHOICESCOUNT, &count, NULL );
        if( val.i_int < count.i_int )
            var_Change( p_input, ""title"", VLC_VAR_SETVALUE, &val, NULL );
    }
    else if( !strcmp( psz_cmd, ""prev-title"" ) )
    {
        input_ControlPush( p_input, INPUT_CONTROL_SET_TITLE_PREV, NULL );

        val.i_int = var_GetInteger( p_input, ""title"" ) - 1;
        if( val.i_int >= 0 )
            var_Change( p_input, ""title"", VLC_VAR_SETVALUE, &val, NULL );
    }
    else if( !s...",655.0,694.0,1.0,1.0,40.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,int
2364,76895,SeekpointCallback,1,SeekpointCallback,"int SeekpointCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",input\var.c,"static int SeekpointCallback( vlc_object_t *p_this, char const *psz_cmd,
                              vlc_value_t oldval, vlc_value_t newval,
                              void *p_data )
{
    input_thread_t *p_input = (input_thread_t*)p_this;
    vlc_value_t val, count;
    VLC_UNUSED(oldval); VLC_UNUSED(p_data);

    if( !strcmp( psz_cmd, ""next-chapter"" ) )
    {
        input_ControlPush( p_input, INPUT_CONTROL_SET_SEEKPOINT_NEXT, NULL );

        val.i_int = var_GetInteger( p_input, ""chapter"" ) + 1;
        var_Change( p_input, ""chapter"", VLC_VAR_CHOICESCOUNT, &count, NULL );
        if( val.i_int < count.i_int )
            var_Change( p_input, ""chapter"", VLC_VAR_SETVALUE, &val, NULL );
    }
    else if( !strcmp( psz_cmd, ""prev-chapter"" ) )
    {
        input_ControlPush( p_input, INPUT_CONTROL_SET_SEEKPOINT_PREV, NULL );

        val.i_int = var_GetInteger( p_input, ""chapter"" ) - 1;
        if( val.i_int >= 0 )
            var_Change( p_input, ""chapter"", VLC_VAR_SETVALUE, &...",696.0,727.0,1.0,1.0,32.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,int
2365,76904,NavigationCallback,1,NavigationCallback,"int NavigationCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",input\var.c,"static int NavigationCallback( vlc_object_t *p_this, char const *psz_cmd,
                               vlc_value_t oldval, vlc_value_t newval,
                               void *p_data )
{
    input_thread_t *p_input = (input_thread_t*)p_this;
    vlc_value_t     val;
    VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval);

    /* Issue a title change */
    val.i_int = (intptr_t)p_data;
    input_ControlPush( p_input, INPUT_CONTROL_SET_TITLE, &val );

    var_Change( p_input, ""title"", VLC_VAR_SETVALUE, &val, NULL );

    /* And a chapter change */
    input_ControlPush( p_input, INPUT_CONTROL_SET_SEEKPOINT, &newval );

    var_Change( p_input, ""chapter"", VLC_VAR_SETVALUE, &newval, NULL );

    return VLC_SUCCESS;
}",729.0,749.0,1.0,1.0,21.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,int
2366,76913,EsVideoCallback,1,EsVideoCallback,"int EsVideoCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",input\var.c,"static int EsVideoCallback( vlc_object_t *p_this, char const *psz_cmd,
                            vlc_value_t oldval, vlc_value_t newval, void *p_data )
{
    input_thread_t *p_input = (input_thread_t*)p_this;
    VLC_UNUSED( psz_cmd); VLC_UNUSED( oldval ); VLC_UNUSED( p_data );

    if( newval.i_int < 0 )
        newval.i_int = -VIDEO_ES; /* disable video es */
    else
        var_SetBool( p_input, ""video"", true );

    input_ControlPush( p_input, INPUT_CONTROL_SET_ES, &newval );

    return VLC_SUCCESS;
}",751.0,765.0,1.0,1.0,15.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,int
2367,76922,EsAudioCallback,1,EsAudioCallback,"int EsAudioCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",input\var.c,"static int EsAudioCallback( vlc_object_t *p_this, char const *psz_cmd,
                            vlc_value_t oldval, vlc_value_t newval, void *p_data )
{
    input_thread_t *p_input = (input_thread_t*)p_this;
    VLC_UNUSED( psz_cmd); VLC_UNUSED( oldval ); VLC_UNUSED( p_data );

    if( newval.i_int < 0 )
        newval.i_int = -AUDIO_ES; /* disable audio es */
    else
        var_SetBool( p_input, ""audio"", true );

    input_ControlPush( p_input, INPUT_CONTROL_SET_ES, &newval );

    return VLC_SUCCESS;
}",767.0,781.0,1.0,1.0,15.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,int
2368,76931,EsSpuCallback,1,EsSpuCallback,"int EsSpuCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",input\var.c,"static int EsSpuCallback( vlc_object_t *p_this, char const *psz_cmd,
                           vlc_value_t oldval, vlc_value_t newval, void *p_data )
{
    input_thread_t *p_input = (input_thread_t*)p_this;
    VLC_UNUSED( psz_cmd); VLC_UNUSED( oldval ); VLC_UNUSED( p_data );

    if( newval.i_int < 0 )
        newval.i_int = -SPU_ES; /* disable spu es */
    else
        var_SetBool( p_input, ""spu"", true );

    input_ControlPush( p_input, INPUT_CONTROL_SET_ES, &newval );

    return VLC_SUCCESS;
}",783.0,797.0,1.0,1.0,15.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,int
2369,76940,EsDelayCallback,1,EsDelayCallback,"int EsDelayCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",input\var.c,"static int EsDelayCallback ( vlc_object_t *p_this, char const *psz_cmd,
                             vlc_value_t oldval, vlc_value_t newval, void *p_data )
{
    input_thread_t *p_input = (input_thread_t*)p_this;
    VLC_UNUSED(oldval); VLC_UNUSED(p_data);

    if( !strcmp( psz_cmd, ""audio-delay"" ) )
    {
        input_ControlPush( p_input, INPUT_CONTROL_SET_AUDIO_DELAY, &newval );
    }
    else if( !strcmp( psz_cmd, ""spu-delay"" ) )
    {
        input_ControlPush( p_input, INPUT_CONTROL_SET_SPU_DELAY, &newval );
    }
    return VLC_SUCCESS;
}",799.0,814.0,1.0,1.0,16.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,int
2370,76949,BookmarkCallback,1,BookmarkCallback,"int BookmarkCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",input\var.c,"static int BookmarkCallback( vlc_object_t *p_this, char const *psz_cmd,
                             vlc_value_t oldval, vlc_value_t newval,
                             void *p_data )
{
    input_thread_t *p_input = (input_thread_t*)p_this;
    VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval); VLC_UNUSED(p_data);

    input_ControlPush( p_input, INPUT_CONTROL_SET_BOOKMARK, &newval );

    return VLC_SUCCESS;
}",816.0,826.0,1.0,1.0,11.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,int
2371,76958,RecordCallback,1,RecordCallback,"int RecordCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",input\var.c,"static int RecordCallback( vlc_object_t *p_this, char const *psz_cmd,
                           vlc_value_t oldval, vlc_value_t newval,
                           void *p_data )
{
    input_thread_t *p_input = (input_thread_t*)p_this;
    VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval); VLC_UNUSED(p_data);

    input_ControlPush( p_input, INPUT_CONTROL_SET_RECORD_STATE, &newval );

    return VLC_SUCCESS;
}",828.0,838.0,1.0,1.0,11.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,int
2372,76967,FrameNextCallback,1,FrameNextCallback,"int FrameNextCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",input\var.c,"static int FrameNextCallback( vlc_object_t *p_this, char const *psz_cmd,
                              vlc_value_t oldval, vlc_value_t newval,
                              void *p_data )
{
    input_thread_t *p_input = (input_thread_t*)p_this;
    VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval); VLC_UNUSED(p_data);
    VLC_UNUSED(newval);

    input_ControlPush( p_input, INPUT_CONTROL_SET_FRAME_NEXT, NULL );

    return VLC_SUCCESS;
}",840.0,851.0,1.0,1.0,12.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,int
2373,76980,InputAddCallbacks,1,InputAddCallbacks,"void InputAddCallbacks (input_thread_t*,vlc_input_callback_t*)",input\var.c,"static void InputAddCallbacks( input_thread_t *p_input,
                               const vlc_input_callback_t *p_callbacks )
{
    int i;
    for( i = 0; p_callbacks[i].psz_name != NULL; i++ )
        var_AddCallback( p_input,
                         p_callbacks[i].psz_name,
                         p_callbacks[i].callback, NULL );
}",533.0,541.0,1.0,1.0,9.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
2374,76986,InputDelCallbacks,1,InputDelCallbacks,"void InputDelCallbacks (input_thread_t*,vlc_input_callback_t*)",input\var.c,"static void InputDelCallbacks( input_thread_t *p_input,
                               const vlc_input_callback_t *p_callbacks )
{
    int i;
    for( i = 0; p_callbacks[i].psz_name != NULL; i++ )
        var_DelCallback( p_input,
                         p_callbacks[i].psz_name,
                         p_callbacks[i].callback, NULL );
}",543.0,551.0,1.0,1.0,9.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
2375,79332,Manage,1,Manage,void* Manage (void*),input\vlm.c,"static void* Manage( void* p_object )
{
    vlm_t *vlm = (vlm_t*)p_object;
    time_t lastcheck, now, nextschedule = 0;

    time(&lastcheck);

    for( ;; )
    {
        char **ppsz_scheduled_commands = NULL;
        int    i_scheduled_commands = 0;
        bool scheduled_command = false;

        vlc_mutex_lock( &vlm->lock_manage );
        mutex_cleanup_push( &vlm->lock_manage );
        while( !vlm->input_state_changed && !scheduled_command )
        {
            if( nextschedule != 0 )
                scheduled_command = vlc_cond_timedwait_daytime( &vlm->wait_manage, &vlm->lock_manage, nextschedule ) != 0;
            else
                vlc_cond_wait( &vlm->wait_manage, &vlm->lock_manage );
        }
        vlm->input_state_changed = false;
        vlc_cleanup_pop( );
        vlc_mutex_unlock( &vlm->lock_manage );

        int canc = vlc_savecancel ();
        /* destroy the inputs that wants to die, and launch the next input */
        vlc_mutex_lock( &vlm->lock );
      ...",396.0,531.0,1.0,1.0,136.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void*
2376,79337,vlm_MediaVodControl,1,vlm_MediaVodControl,"int vlm_MediaVodControl (void*,vod_media_t*,char*,int,ANY)",input\vlm.c,"static int vlm_MediaVodControl( void *p_private, vod_media_t *p_vod_media,
                                const char *psz_id, int i_query, va_list args )
{
    vlm_t *vlm = (vlm_t *)p_private;
    int i, i_ret;
    const char *psz;
    int64_t id;

    if( !p_private || !p_vod_media )
        return VLC_EGENERIC;

    vlc_mutex_lock( &vlm->lock );

    /* Find media id */
    for( i = 0, id = -1; i < vlm->i_media; i++ )
    {
        if( p_vod_media == vlm->media[i]->vod.p_media )
        {
            id = vlm->media[i]->cfg.id;
            break;
        }
    }
    if( id == -1 )
    {
        vlc_mutex_unlock( &vlm->lock );
        return VLC_EGENERIC;
    }

    switch( i_query )
    {
    case VOD_MEDIA_PLAY:
    {
        psz = (const char *)va_arg( args, const char * );
        int64_t *i_time = (int64_t *)va_arg( args, int64_t *);
        bool b_retry = false;
        if (*i_time < 0)
        {
            /* No start time requested: return the current NPT */
            i...",279.0,390.0,1.0,1.0,112.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,int
2377,79350,InputEventPreparse,1,InputEventPreparse,"int InputEventPreparse (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",input\vlm.c,"static int InputEventPreparse( vlc_object_t *p_this, char const *psz_cmd,
                               vlc_value_t oldval, vlc_value_t newval, void *p_data )
{
    VLC_UNUSED(p_this); VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval);
    preparse_data_t *p_pre = p_data;

    if( newval.i_int == INPUT_EVENT_DEAD ||
        ( p_pre->b_mux && newval.i_int == INPUT_EVENT_ITEM_META ) )
        vlc_sem_post( p_pre->p_sem );

    return VLC_SUCCESS;
}",67.0,78.0,1.0,1.0,12.0,9,6,12,9,0,3,2,2,1,1,,0,2,10,5,5,int
2378,79392,InputEvent,1,InputEvent,"int InputEvent (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",playlist\thread.c,"static int InputEvent( vlc_object_t *p_this, char const *psz_cmd,
                       vlc_value_t oldval, vlc_value_t newval, void *p_data )
{
    VLC_UNUSED(p_this); VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval);
    playlist_t *p_playlist = p_data;

    if( newval.i_int == INPUT_EVENT_DEAD )
    {
        playlist_private_t *sys = pl_priv(p_playlist);

        PL_LOCK;
        sys->request.input_dead = true;
        vlc_cond_signal( &sys->signal );
        PL_UNLOCK;
    }
    return VLC_SUCCESS;
}",94.0,110.0,1.0,34.0,17.0,37,8,38,16,0,15,6,9,2,5,,0,11,10,5,5,int
2379,79547,vlm_New,1,vlm_New,vlm_t vlm_New (vlc_object_t*),missing.c,"vlm_t *vlm_New (vlc_object_t *obj)
{
     msg_Err (obj, ""VLM not compiled-in!"");
     return NULL;
}",244.0,248.0,1.0,1.0,5.0,72,12,75,13,0,49,8,12,4,22,,0,31,2,1,1,vlm_t
2380,79804,vlm_Delete,1,vlm_Delete,void vlm_Delete (vlm_t*),missing.c,"void vlm_Delete (vlm_t *vlm)
{
    VLC_UNUSED (vlm);
    vlc_assert_unreachable ();
}",203.0,207.0,1.0,1.0,5.0,44,7,35,5,0,43,4,4,2,20,,0,23,2,1,1,void
2381,79953,vlm_ExecuteCommand,1,vlm_ExecuteCommand,"int vlm_ExecuteCommand (vlm_t*,char*,vlm_message_t**)",missing.c,"int vlm_ExecuteCommand (vlm_t *vlm, const char *cmd, vlm_message_t **pm)
{
    VLC_UNUSED (vlm);
    VLC_UNUSED (cmd);
    VLC_UNUSED (pm);
    vlc_assert_unreachable ();
}",209.0,215.0,1.0,1.0,7.0,5,3,7,4,1,5,1,1,0,3,,0,3,6,3,3,int
2382,80769,vlm_ControlMediaGetById,1,vlm_ControlMediaGetById,"vlm_media_sys_t vlm_ControlMediaGetById (vlm_t*,int64_t)",input\vlm.c,"static vlm_media_sys_t *vlm_ControlMediaGetById( vlm_t *p_vlm, int64_t id )
{
    for( int i = 0; i < p_vlm->i_media; i++ )
    {
        if( p_vlm->media[i]->cfg.id == id )
            return p_vlm->media[i];
    }
    return NULL;
}",554.0,562.0,1.0,1.0,9.0,10,6,9,4,10,3,3,4,2,0,,0,3,4,2,2,vlm_media_sys_t
2383,80810,vlm_ControlMediaGetByName,1,vlm_ControlMediaGetByName,"vlm_media_sys_t vlm_ControlMediaGetByName (vlm_t*,char*)",input\vlm.c,"static vlm_media_sys_t *vlm_ControlMediaGetByName( vlm_t *p_vlm, const char *psz_name )
{
    for( int i = 0; i < p_vlm->i_media; i++ )
    {
        if( !strcmp( p_vlm->media[i]->cfg.psz_name, psz_name ) )
            return p_vlm->media[i];
    }
    return NULL;
}",563.0,571.0,1.0,1.0,9.0,10,6,9,4,2,3,3,4,2,0,,0,3,4,2,2,vlm_media_sys_t
2384,80852,vlm_MediaDescriptionCheck,1,vlm_MediaDescriptionCheck,"int vlm_MediaDescriptionCheck (vlm_t*,vlm_media_t*)",input\vlm.c,"static int vlm_MediaDescriptionCheck( vlm_t *p_vlm, vlm_media_t *p_cfg )
{
    if( !p_cfg || !p_cfg->psz_name ||
        !strcmp( p_cfg->psz_name, ""all"" ) || !strcmp( p_cfg->psz_name, ""media"" ) || !strcmp( p_cfg->psz_name, ""schedule"" ) )
        return VLC_EGENERIC;

    for( int i = 0; i < p_vlm->i_media; i++ )
    {
        if( p_vlm->media[i]->cfg.id == p_cfg->id )
            continue;
        if( !strcmp( p_vlm->media[i]->cfg.psz_name, p_cfg->psz_name ) )
            return VLC_EGENERIC;
    }
    return VLC_SUCCESS;
}",572.0,586.0,1.0,1.0,15.0,28,8,17,5,2,3,6,7,3,0,,0,3,4,2,2,int
2385,80940,vlm_OnMediaUpdate,1,vlm_OnMediaUpdate,"int vlm_OnMediaUpdate (vlm_t*,vlm_media_sys_t*)",input\vlm.c,"static int vlm_OnMediaUpdate( vlm_t *p_vlm, vlm_media_sys_t *p_media )
{
    vlm_media_t *p_cfg = &p_media->cfg;
    /* Check if we need to create/delete a vod media */
    if( p_cfg->b_vod && p_vlm->p_vod )
    {
        if( !p_cfg->b_enabled && p_media->vod.p_media )
        {
            p_vlm->p_vod->pf_media_del( p_vlm->p_vod, p_media->vod.p_media );
            p_media->vod.p_media = NULL;
        }
        else if( p_cfg->b_enabled && !p_media->vod.p_media && p_cfg->i_input )
        {
            /* Pre-parse the input */
            input_thread_t *p_input;
            char *psz_output;
            char *psz_header;
            char *psz_dup;

            input_item_Release( p_media->vod.p_item );

            if( strstr( p_cfg->ppsz_input[0], ""://"" ) == NULL )
            {
                char *psz_uri = vlc_path2uri( p_cfg->ppsz_input[0], NULL );
                p_media->vod.p_item = input_item_New( psz_uri,
                                                      p_cfg->ps...",590.0,723.0,1.0,1.0,134.0,21,6,15,5,3,5,3,4,1,1,,0,4,4,2,2,int
2386,81431,vlm_ControlMediaChange,1,vlm_ControlMediaChange,"int vlm_ControlMediaChange (vlm_t*,vlm_media_t*)",input\vlm.c,"static int vlm_ControlMediaChange( vlm_t *p_vlm, vlm_media_t *p_cfg )
{
    vlm_media_sys_t *p_media = vlm_ControlMediaGetById( p_vlm, p_cfg->id );

    /* */
    if( !p_media || vlm_MediaDescriptionCheck( p_vlm, p_cfg ) )
        return VLC_EGENERIC;
    if( ( p_media->cfg.b_vod && !p_cfg->b_vod ) || ( !p_media->cfg.b_vod && p_cfg->b_vod ) )
        return VLC_EGENERIC;

    if( 0 )
    {
        /* TODO check what are the changes being done (stop instance if needed) */
    }

    vlm_media_Clean( &p_media->cfg );
    vlm_media_Copy( &p_media->cfg, p_cfg );

    return vlm_OnMediaUpdate( p_vlm, p_media );
}",724.0,743.0,1.0,1.0,20.0,19,7,17,4,1,7,4,4,3,3,,0,6,4,2,2,int
2387,81498,vlm_ControlMediaAdd,1,vlm_ControlMediaAdd,"int vlm_ControlMediaAdd (vlm_t*,vlm_media_t*,int64_t*)",input\vlm.c,"static int vlm_ControlMediaAdd( vlm_t *p_vlm, vlm_media_t *p_cfg, int64_t *p_id )
{
    vlm_media_sys_t *p_media;

    if( vlm_MediaDescriptionCheck( p_vlm, p_cfg ) || vlm_ControlMediaGetByName( p_vlm, p_cfg->psz_name ) )
    {
        msg_Err( p_vlm, ""invalid media description"" );
        return VLC_EGENERIC;
    }
    /* Check if we need to load the VOD server */
    if( p_cfg->b_vod && !p_vlm->p_vod )
    {
        msg_Info( p_vlm, ""VoD support will be removed from the VLM in the next major version of VLC."" );

        p_vlm->p_vod = vlc_custom_create( VLC_OBJECT(p_vlm), sizeof( vod_t ),
                                          ""vod server"" );
        p_vlm->p_vod->p_module = module_need( p_vlm->p_vod, ""vod server"", ""$vod-server"", false );
        if( !p_vlm->p_vod->p_module )
        {
            msg_Err( p_vlm, ""cannot find vod server"" );
            vlc_object_release( p_vlm->p_vod );
            p_vlm->p_vod = NULL;
            return VLC_EGENERIC;
        }

        p_vlm-...",745.0,796.0,1.0,23.0,52.0,53,10,51,10,1,26,6,7,4,7,,0,23,6,3,3,int
2388,81685,vlm_ControlMediaDel,1,vlm_ControlMediaDel,"int vlm_ControlMediaDel (vlm_t*,int64_t)",input\vlm.c,"static int vlm_ControlMediaDel( vlm_t *p_vlm, int64_t id )
{
    vlm_media_sys_t *p_media = vlm_ControlMediaGetById( p_vlm, id );

    if( !p_media )
        return VLC_EGENERIC;

    while( p_media->i_instance > 0 )
        vlm_ControlInternal( p_vlm, VLM_STOP_MEDIA_INSTANCE, id, p_media->instance[0]->psz_name );

    if( p_media->cfg.b_vod )
    {
        p_media->cfg.b_enabled = false;
        vlm_OnMediaUpdate( p_vlm, p_media );
    }

    /* */
    vlm_SendEventMediaRemoved( p_vlm, id, p_media->cfg.psz_name );

    vlm_media_Clean( &p_media->cfg );

    input_item_Release( p_media->vod.p_item );

    if( p_media->vod.p_media )
        p_vlm->p_vod->pf_media_del( p_vlm->p_vod, p_media->vod.p_media );

    TAB_REMOVE( p_vlm->i_media, p_vlm->media, p_media );
    free( p_media );

    return VLC_SUCCESS;
}",798.0,828.0,1.0,1.0,31.0,24,6,25,6,1,13,5,5,2,4,,0,10,4,2,2,int
2389,81789,vlm_ControlMediaGets,1,vlm_ControlMediaGets,"int vlm_ControlMediaGets (vlm_t*,vlm_media_t***,int*)",input\vlm.c,"static int vlm_ControlMediaGets( vlm_t *p_vlm, vlm_media_t ***ppp_dsc, int *pi_dsc )
{
    vlm_media_t **pp_dsc;
    int                     i_dsc;

    TAB_INIT( i_dsc, pp_dsc );
    for( int i = 0; i < p_vlm->i_media; i++ )
    {
        vlm_media_t *p_dsc = vlm_media_Duplicate( &p_vlm->media[i]->cfg );
        TAB_APPEND( i_dsc, pp_dsc, p_dsc );
    }

    *ppp_dsc = pp_dsc;
    *pi_dsc = i_dsc;

    return VLC_SUCCESS;
}",830.0,846.0,1.0,1.0,17.0,12,6,16,8,1,2,2,2,1,0,,0,2,6,3,3,int
2390,81841,vlm_ControlMediaClear,1,vlm_ControlMediaClear,int vlm_ControlMediaClear (vlm_t*),input\vlm.c,"static int vlm_ControlMediaClear( vlm_t *p_vlm )
{
    while( p_vlm->i_media > 0 )
        vlm_ControlMediaDel( p_vlm, p_vlm->media[0]->cfg.id );

    return VLC_SUCCESS;
}",847.0,853.0,1.0,1.0,7.0,2,2,2,2,1,1,2,2,1,0,,0,1,2,1,1,int
2391,81865,vlm_ControlMediaGet,1,vlm_ControlMediaGet,"int vlm_ControlMediaGet (vlm_t*,int64_t,vlm_media_t**)",input\vlm.c,"static int vlm_ControlMediaGet( vlm_t *p_vlm, int64_t id, vlm_media_t **pp_dsc )
{
    vlm_media_sys_t *p_media = vlm_ControlMediaGetById( p_vlm, id );
    if( !p_media )
        return VLC_EGENERIC;

    *pp_dsc = vlm_media_Duplicate( &p_media->cfg );
    return VLC_SUCCESS;
}",854.0,862.0,1.0,1.0,9.0,6,5,8,6,1,2,2,2,0,1,,0,2,6,3,3,int
2392,81894,vlm_ControlMediaGetId,1,vlm_ControlMediaGetId,"int vlm_ControlMediaGetId (vlm_t*,char*,int64_t*)",input\vlm.c,"static int vlm_ControlMediaGetId( vlm_t *p_vlm, const char *psz_name, int64_t *p_id )
{
    vlm_media_sys_t *p_media = vlm_ControlMediaGetByName( p_vlm, psz_name );
    if( !p_media )
        return VLC_EGENERIC;

    *p_id = p_media->cfg.id;
    return VLC_SUCCESS;
}",863.0,871.0,1.0,1.0,9.0,6,5,8,6,1,2,2,2,0,1,,0,2,6,3,3,int
2393,81923,vlm_ControlMediaInstanceGetByName,1,vlm_ControlMediaInstanceGetByName,"vlm_media_instance_sys_t vlm_ControlMediaInstanceGetByName (vlm_media_sys_t*,char*)",input\vlm.c,"static vlm_media_instance_sys_t *vlm_ControlMediaInstanceGetByName( vlm_media_sys_t *p_media, const char *psz_id )
{
    for( int i = 0; i < p_media->i_instance; i++ )
    {
        const char *psz = p_media->instance[i]->psz_name;
        if( ( psz == NULL && psz_id == NULL ) ||
            ( psz && psz_id && !strcmp( psz, psz_id ) ) )
            return p_media->instance[i];
    }
    return NULL;
}",873.0,883.0,1.0,1.0,11.0,16,8,17,5,5,3,3,4,1,0,,0,3,4,2,2,vlm_media_instance_sys_t
2394,81979,vlm_MediaInstanceNew,1,vlm_MediaInstanceNew,"vlm_media_instance_sys_t vlm_MediaInstanceNew (vlm_t*,char*)",input\vlm.c,"static vlm_media_instance_sys_t *vlm_MediaInstanceNew( vlm_t *p_vlm, const char *psz_name )
{
    vlm_media_instance_sys_t *p_instance = calloc( 1, sizeof(vlm_media_instance_sys_t) );
    if( !p_instance )
        return NULL;

    p_instance->psz_name = NULL;
    if( psz_name )
        p_instance->psz_name = strdup( psz_name );

    p_instance->p_item = input_item_New( NULL, NULL );

    p_instance->i_index = 0;
    p_instance->b_sout_keep = false;
    p_instance->p_parent = vlc_object_create( p_vlm, sizeof (vlc_object_t) );
    p_instance->p_input = NULL;
    p_instance->p_input_resource = input_resource_New( p_instance->p_parent );

    return p_instance;
}",884.0,903.0,1.0,1.0,20.0,21,4,23,7,1,11,3,3,0,2,,0,11,4,2,2,vlm_media_instance_sys_t
2395,82052,vlm_MediaInstanceDelete,1,vlm_MediaInstanceDelete,"void vlm_MediaInstanceDelete (vlm_t*,int64_t,vlm_media_instance_sys_t*,vlm_media_sys_t*)",input\vlm.c,"static void vlm_MediaInstanceDelete( vlm_t *p_vlm, int64_t id, vlm_media_instance_sys_t *p_instance, vlm_media_sys_t *p_media )
{
    input_thread_t *p_input = p_instance->p_input;
    if( p_input )
    {
        input_Stop( p_input );
        input_Close( p_input );

        vlm_SendEventMediaInstanceStopped( p_vlm, id, p_media->cfg.psz_name );
    }
    input_resource_Terminate( p_instance->p_input_resource );
    input_resource_Release( p_instance->p_input_resource );
    vlc_object_release( p_instance->p_parent );

    TAB_REMOVE( p_media->i_instance, p_media->instance, p_instance );
    input_item_Release( p_instance->p_item );
    free( p_instance->psz_name );
    free( p_instance );
}",904.0,922.0,1.0,1.0,19.0,11,3,17,5,2,16,2,2,0,7,,0,9,8,4,4,void
2396,82111,vlm_ControlMediaInstanceStart,1,vlm_ControlMediaInstanceStart,"int vlm_ControlMediaInstanceStart (vlm_t*,int64_t,char*,int,char*)",input\vlm.c,"static int vlm_ControlMediaInstanceStart( vlm_t *p_vlm, int64_t id, const char *psz_id, int i_input_index, const char *psz_vod_output )
{
    vlm_media_sys_t *p_media = vlm_ControlMediaGetById( p_vlm, id );
    vlm_media_instance_sys_t *p_instance;
    char *psz_log;

    if( !p_media || !p_media->cfg.b_enabled || p_media->cfg.i_input <= 0 )
        return VLC_EGENERIC;

    /* TODO support multiple input for VOD with sout-keep ? */

    if( ( p_media->cfg.b_vod && !psz_vod_output ) || ( !p_media->cfg.b_vod && psz_vod_output ) )
        return VLC_EGENERIC;

    if( i_input_index < 0 || i_input_index >= p_media->cfg.i_input )
        return VLC_EGENERIC;

    p_instance = vlm_ControlMediaInstanceGetByName( p_media, psz_id );
    if( !p_instance )
    {
        vlm_media_t *p_cfg = &p_media->cfg;

        p_instance = vlm_MediaInstanceNew( p_vlm, psz_id );
        if( !p_instance )
            return VLC_ENOMEM;

        if ( p_cfg->b_vod )
        {
            var_Create( p_instanc...",925.0,1062.0,1.0,1.0,138.0,129,19,133,28,2,67,21,39,15,23,,0,51,10,5,5,int
2397,82630,vlm_ControlMediaInstanceStop,1,vlm_ControlMediaInstanceStop,"int vlm_ControlMediaInstanceStop (vlm_t*,int64_t,char*)",input\vlm.c,"static int vlm_ControlMediaInstanceStop( vlm_t *p_vlm, int64_t id, const char *psz_id )
{
    vlm_media_sys_t *p_media = vlm_ControlMediaGetById( p_vlm, id );
    vlm_media_instance_sys_t *p_instance;

    if( !p_media )
        return VLC_EGENERIC;

    p_instance = vlm_ControlMediaInstanceGetByName( p_media, psz_id );
    if( !p_instance )
        return VLC_EGENERIC;

    vlm_MediaInstanceDelete( p_vlm, id, p_instance, p_media );

    return VLC_SUCCESS;
}",1064.0,1079.0,1.0,1.0,16.0,4,2,15,7,1,3,3,3,0,3,,0,2,6,3,3,int
2398,82668,vlm_ControlMediaInstancePause,1,vlm_ControlMediaInstancePause,"int vlm_ControlMediaInstancePause (vlm_t*,int64_t,char*)",input\vlm.c,"static int vlm_ControlMediaInstancePause( vlm_t *p_vlm, int64_t id, const char *psz_id )
{
    vlm_media_sys_t *p_media = vlm_ControlMediaGetById( p_vlm, id );
    vlm_media_instance_sys_t *p_instance;
    int i_state;

    if( !p_media )
        return VLC_EGENERIC;

    p_instance = vlm_ControlMediaInstanceGetByName( p_media, psz_id );
    if( !p_instance || !p_instance->p_input )
        return VLC_EGENERIC;

    /* Toggle pause state */
    i_state = var_GetInteger( p_instance->p_input, ""state"" );
    if( i_state == PAUSE_S && !p_media->cfg.b_vod )
        var_SetInteger( p_instance->p_input, ""state"", PLAYING_S );
    else if( i_state == PLAYING_S )
        var_SetInteger( p_instance->p_input, ""state"", PAUSE_S );
    return VLC_SUCCESS;
}",1080.0,1100.0,1.0,1.0,21.0,15,7,19,10,1,6,4,4,2,2,,0,6,6,3,3,int
2399,82745,vlm_ControlMediaInstanceGetTimePosition,1,vlm_ControlMediaInstanceGetTimePosition,"int vlm_ControlMediaInstanceGetTimePosition (vlm_t*,int64_t,char*,int64_t*,double*)",input\vlm.c,"static int vlm_ControlMediaInstanceGetTimePosition( vlm_t *p_vlm, int64_t id, const char *psz_id, int64_t *pi_time, double *pd_position )
{
    vlm_media_sys_t *p_media = vlm_ControlMediaGetById( p_vlm, id );
    vlm_media_instance_sys_t *p_instance;

    if( !p_media )
        return VLC_EGENERIC;

    p_instance = vlm_ControlMediaInstanceGetByName( p_media, psz_id );
    if( !p_instance || !p_instance->p_input )
        return VLC_EGENERIC;

    if( pi_time )
        *pi_time = var_GetInteger( p_instance->p_input, ""time"" );
    if( pd_position )
        *pd_position = var_GetFloat( p_instance->p_input, ""position"" );
    return VLC_SUCCESS;
}",1101.0,1118.0,1.0,1.0,18.0,13,5,18,9,2,5,5,5,1,2,,0,5,10,5,5,int
2400,82807,vlm_ControlMediaInstanceSetTimePosition,1,vlm_ControlMediaInstanceSetTimePosition,"int vlm_ControlMediaInstanceSetTimePosition (vlm_t*,int64_t,char*,int64_t,double)",input\vlm.c,"static int vlm_ControlMediaInstanceSetTimePosition( vlm_t *p_vlm, int64_t id, const char *psz_id, int64_t i_time, double d_position )
{
    vlm_media_sys_t *p_media = vlm_ControlMediaGetById( p_vlm, id );
    vlm_media_instance_sys_t *p_instance;

    if( !p_media )
        return VLC_EGENERIC;

    p_instance = vlm_ControlMediaInstanceGetByName( p_media, psz_id );
    if( !p_instance || !p_instance->p_input )
        return VLC_EGENERIC;

    if( i_time >= 0 )
        return var_SetInteger( p_instance->p_input, ""time"", i_time );
    else if( d_position >= 0 && d_position <= 100 )
        return var_SetFloat( p_instance->p_input, ""position"", d_position );
    return VLC_EGENERIC;
}",1119.0,1136.0,1.0,1.0,18.0,9,5,15,7,2,4,4,4,1,2,,0,4,10,5,5,int
2401,82877,vlm_ControlMediaInstanceGets,1,vlm_ControlMediaInstanceGets,"int vlm_ControlMediaInstanceGets (vlm_t*,int64_t,vlm_media_instance_t***,int*)",input\vlm.c,"static int vlm_ControlMediaInstanceGets( vlm_t *p_vlm, int64_t id, vlm_media_instance_t ***ppp_idsc, int *pi_instance )
{
    vlm_media_sys_t *p_media = vlm_ControlMediaGetById( p_vlm, id );
    vlm_media_instance_t **pp_idsc;
    int                              i_idsc;

    if( !p_media )
        return VLC_EGENERIC;

    TAB_INIT( i_idsc, pp_idsc );
    for( int i = 0; i < p_media->i_instance; i++ )
    {
        vlm_media_instance_sys_t *p_instance = p_media->instance[i];
        vlm_media_instance_t *p_idsc = vlm_media_instance_New();

        if( p_instance->psz_name )
            p_idsc->psz_name = strdup( p_instance->psz_name );
        if( p_instance->p_input )
        {
            p_idsc->i_time = var_GetInteger( p_instance->p_input, ""time"" );
            p_idsc->i_length = var_GetInteger( p_instance->p_input, ""length"" );
            p_idsc->d_position = var_GetFloat( p_instance->p_input, ""position"" );
            if( var_GetInteger( p_instance->p_input, ""state"" ) == PAUS...",1138.0,1171.0,1.0,1.0,34.0,35,8,39,15,1,11,6,10,4,1,,0,11,8,4,4,int
2402,83012,vlm_ControlMediaInstanceClear,1,vlm_ControlMediaInstanceClear,"int vlm_ControlMediaInstanceClear (vlm_t*,int64_t)",input\vlm.c,"static int vlm_ControlMediaInstanceClear( vlm_t *p_vlm, int64_t id )
{
    vlm_media_sys_t *p_media = vlm_ControlMediaGetById( p_vlm, id );

    if( !p_media )
        return VLC_EGENERIC;

    while( p_media->i_instance > 0 )
        vlm_ControlMediaInstanceStop( p_vlm, id, p_media->instance[0]->psz_name );

    return VLC_SUCCESS;
}",1173.0,1184.0,1.0,1.0,12.0,4,4,7,5,1,2,3,3,1,1,,0,2,4,2,2,int
2403,83048,vlm_ControlScheduleClear,1,vlm_ControlScheduleClear,int vlm_ControlScheduleClear (vlm_t*),input\vlm.c,"static int vlm_ControlScheduleClear( vlm_t *p_vlm )
{
    while( p_vlm->i_schedule > 0 )
        vlm_ScheduleDelete( p_vlm, p_vlm->schedule[0] );

    return VLC_SUCCESS;
}",1186.0,1192.0,1.0,1.0,7.0,2,2,2,2,1,1,2,2,1,0,,0,1,2,1,1,int
2404,83068,vlm_vaControlInternal,1,vlm_vaControlInternal,"int vlm_vaControlInternal (vlm_t*,int,va_list)",input\vlm.c,"static int vlm_vaControlInternal( vlm_t *p_vlm, int i_query, va_list args )
{
    vlm_media_t *p_dsc;
    vlm_media_t **pp_dsc;
    vlm_media_t ***ppp_dsc;
    vlm_media_instance_t ***ppp_idsc;
    const char *psz_id;
    const char *psz_vod;
    int64_t *p_id;
    int64_t id;
    int i_int;
    int *pi_int;

    int64_t *pi_i64;
    int64_t i_i64;
    double *pd_double;
    double d_double;

    switch( i_query )
    {
    /* Media control */
    case VLM_GET_MEDIAS:
        ppp_dsc = (vlm_media_t ***)va_arg( args, vlm_media_t *** );
        pi_int = (int *)va_arg( args, int * );
        return vlm_ControlMediaGets( p_vlm, ppp_dsc, pi_int );

    case VLM_CLEAR_MEDIAS:
        return vlm_ControlMediaClear( p_vlm );

    case VLM_CHANGE_MEDIA:
        p_dsc = (vlm_media_t*)va_arg( args, vlm_media_t * );
        return vlm_ControlMediaChange( p_vlm, p_dsc );

    case VLM_ADD_MEDIA:
        p_dsc = (vlm_media_t*)va_arg( args, vlm_media_t * );
        p_id = (int64_t*)va_arg( args, in...",1194.0,1313.0,1.0,1.0,120.0,29,4,120,38,2,18,3,4,0,18,,0,0,6,3,3,int
2405,83353,vlm_ControlInternal,1,vlm_ControlInternal,"int vlm_ControlInternal (vlm_t*,int...)",input\vlm.c,"int vlm_ControlInternal( vlm_t *p_vlm, int i_query, ... )
{
    va_list args;
    int     i_result;

    va_start( args, i_query );
    i_result = vlm_vaControlInternal( p_vlm, i_query, args );
    va_end( args );

    return i_result;
}",1315.0,1325.0,1.0,1.0,11.0,1,1,8,4,2,1,1,1,0,1,,0,1,4,2,2,int
2406,83374,vlm_Control,1,vlm_Control,"int vlm_Control (vlm_t*,int...)",missing.c,"int vlm_Control (vlm_t *vlm, int query, ...)
{
    VLC_UNUSED (query);
    VLC_UNUSED (vlm);
    vlc_assert_unreachable ();
}",196.0,201.0,1.0,1.0,6.0,5,3,10,4,0,5,1,1,0,3,,0,3,4,2,2,int
2407,83430,TriggerInstanceState,1,TriggerInstanceState,"void TriggerInstanceState (vlm_t*,int,int64_t,char*,char*,input_state_e)",input\vlm_event.c,"static void TriggerInstanceState( vlm_t *p_vlm, int i_type, int64_t id, const char *psz_name, const char *psz_instance_name, input_state_e input_state )
{
    vlm_event_t event;

    event.i_type = i_type;
    event.id = id;
    event.psz_name = psz_name;
    event.input_state = input_state;
    event.psz_instance_name = psz_instance_name;
    var_SetAddress( p_vlm, ""intf-event"", &event );
}",86.0,96.0,1.0,1.0,11.0,0,0,0,0,1,0,1,1,0,0,,0,0,12,6,6,void
2408,83440,vlm_SendEventMediaAdded,1,vlm_SendEventMediaAdded,"void vlm_SendEventMediaAdded (vlm_t*,int64_t,char*)",input\vlm_event.c,"void vlm_SendEventMediaAdded( vlm_t *p_vlm, int64_t id, const char *psz_name )
{
    Trigger( p_vlm, VLM_EVENT_MEDIA_ADDED, id, psz_name );
}",44.0,47.0,1.0,1.0,4.0,0,0,4,4,1,1,1,1,0,1,,0,0,6,3,3,void
2409,83452,vlm_SendEventMediaRemoved,1,vlm_SendEventMediaRemoved,"void vlm_SendEventMediaRemoved (vlm_t*,int64_t,char*)",input\vlm_event.c,"void vlm_SendEventMediaRemoved( vlm_t *p_vlm, int64_t id, const char *psz_name )
{
    Trigger( p_vlm, VLM_EVENT_MEDIA_REMOVED, id, psz_name );
}",48.0,51.0,1.0,1.0,4.0,0,0,4,4,1,1,1,1,0,1,,0,0,6,3,3,void
2410,83464,vlm_SendEventMediaChanged,1,vlm_SendEventMediaChanged,"void vlm_SendEventMediaChanged (vlm_t*,int64_t,char*)",input\vlm_event.c,"void vlm_SendEventMediaChanged( vlm_t *p_vlm, int64_t id, const char *psz_name )
{
    Trigger( p_vlm, VLM_EVENT_MEDIA_CHANGED, id, psz_name );
}",52.0,55.0,1.0,1.0,4.0,0,0,4,4,1,1,1,1,0,1,,0,0,6,3,3,void
2411,83476,vlm_SendEventMediaInstanceStarted,1,vlm_SendEventMediaInstanceStarted,"void vlm_SendEventMediaInstanceStarted (vlm_t*,int64_t,char*)",input\vlm_event.c,"void vlm_SendEventMediaInstanceStarted( vlm_t *p_vlm, int64_t id, const char *psz_name )
{
    Trigger( p_vlm, VLM_EVENT_MEDIA_INSTANCE_STARTED, id, psz_name );
}",57.0,60.0,1.0,1.0,4.0,0,0,4,4,0,1,1,1,0,1,,0,0,6,3,3,void
2412,83488,vlm_SendEventMediaInstanceStopped,1,vlm_SendEventMediaInstanceStopped,"void vlm_SendEventMediaInstanceStopped (vlm_t*,int64_t,char*)",input\vlm_event.c,"void vlm_SendEventMediaInstanceStopped( vlm_t *p_vlm, int64_t id, const char *psz_name )
{
    Trigger( p_vlm, VLM_EVENT_MEDIA_INSTANCE_STOPPED, id, psz_name );
}",61.0,64.0,1.0,1.0,4.0,0,0,4,4,2,1,1,1,0,1,,0,0,6,3,3,void
2413,83500,vlm_SendEventMediaInstanceState,1,vlm_SendEventMediaInstanceState,"void vlm_SendEventMediaInstanceState (vlm_t*,int64_t,char*,char*,input_state_e)",input\vlm_event.c,"void vlm_SendEventMediaInstanceState( vlm_t *p_vlm, int64_t id, const char *psz_name, const char *psz_instance_name, input_state_e state )
{
    TriggerInstanceState( p_vlm, VLM_EVENT_MEDIA_INSTANCE_STATE, id, psz_name, psz_instance_name, state );
}",66.0,69.0,1.0,1.0,4.0,0,0,6,6,1,1,1,1,0,1,,0,0,10,5,5,void
2414,83707,ExecuteCommand,1,ExecuteCommand,"int ExecuteCommand (vlm_t*,char*,vlm_message_t**)",input\vlm_internal.h,"int ExecuteCommand( vlm_t *, const char *, vlm_message_t ** );",119.0,119.0,5.0,61.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,int
2415,83714,vlm_ScheduleDelete,1,vlm_ScheduleDelete,"void vlm_ScheduleDelete (vlm_t*,vlm_schedule_sys_t*)",input\vlm_internal.h,"void vlm_ScheduleDelete( vlm_t *vlm, vlm_schedule_sys_t *sched );",120.0,120.0,6.0,64.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
2416,83849,get_dialog_provider,1,get_dialog_provider,"vlc_dialog_provider get_dialog_provider (vlc_object_t*,bool)",interface\dialog.c,"static inline vlc_dialog_provider *
get_dialog_provider(vlc_object_t *p_obj, bool b_check_interact)
{
    if (b_check_interact && p_obj->obj.flags & OBJECT_FLAGS_NOINTERACT)
        return NULL;

    vlc_dialog_provider *p_provider =
        libvlc_priv(p_obj->obj.libvlc)->p_dialog_provider;
    assert(p_provider != NULL);
    return p_provider;
}",122.0,132.0,1.0,1.0,11.0,9,6,9,5,9,1,2,2,0,1,,0,1,4,2,2,vlc_dialog_provider
2417,83885,dialog_id_release,1,dialog_id_release,void dialog_id_release (vlc_dialog_id*),interface\dialog.c,"static void
dialog_id_release(vlc_dialog_id *p_id)
{
    if (p_id->answer.i_type == VLC_DIALOG_LOGIN)
    {
        free(p_id->answer.u.login.psz_username);
        free(p_id->answer.u.login.psz_password);
    }
    free(p_id->psz_progress_text);
    vlc_mutex_destroy(&p_id->lock);
    vlc_cond_destroy(&p_id->wait);
    free(p_id);
}",134.0,146.0,1.0,1.0,13.0,16,4,8,2,1,8,2,2,1,2,,0,6,2,1,1,void
2418,83935,libvlc_InternalDialogInit,1,libvlc_InternalDialogInit,int libvlc_InternalDialogInit (libvlc_int_t*),interface\dialog.c,"int
libvlc_InternalDialogInit(libvlc_int_t *p_libvlc)
{
    assert(p_libvlc != NULL);
    vlc_dialog_provider *p_provider = malloc(sizeof(*p_provider));
    if (p_provider == NULL)
        return VLC_EGENERIC;

    vlc_mutex_init(&p_provider->lock);
    vlc_array_init(&p_provider->dialog_array);

    memset(&p_provider->cbs, 0, sizeof(p_provider->cbs));
    p_provider->p_cbs_data = NULL;

    p_provider->pf_ext_update = NULL;
    p_provider->p_ext_data = NULL;
    libvlc_priv(p_libvlc)->p_dialog_provider = p_provider;

    return VLC_SUCCESS;
}",148.0,167.0,1.0,1.0,20.0,21,7,20,5,1,9,2,2,0,2,,0,7,2,1,1,int
2419,84001,dialog_cancel_locked,1,dialog_cancel_locked,"void dialog_cancel_locked (vlc_dialog_provider*,vlc_dialog_id*)",interface\dialog.c,"static void
dialog_cancel_locked(vlc_dialog_provider *p_provider, vlc_dialog_id *p_id)
{
    vlc_mutex_lock(&p_id->lock);
    if (p_id->b_cancelled || p_id->b_answered)
    {
        vlc_mutex_unlock(&p_id->lock);
        return;
    }
    p_id->b_cancelled = true;
    vlc_mutex_unlock(&p_id->lock);

    p_provider->cbs.pf_cancel(p_provider->p_cbs_data, p_id);
}",169.0,182.0,1.0,1.0,14.0,14,5,10,3,3,11,2,2,2,3,,0,8,4,2,2,void
2420,84047,dialog_add_locked,1,dialog_add_locked,"vlc_dialog_id dialog_add_locked (vlc_dialog_provider*,dialog_type)",interface\dialog.c,"static vlc_dialog_id *
dialog_add_locked(vlc_dialog_provider *p_provider, enum dialog_type i_type)
{
    vlc_dialog_id *p_id = calloc(1, sizeof(*p_id));

    if (p_id == NULL)
        return NULL;

    if(vlc_array_append(&p_provider->dialog_array, p_id))
    {
        free(p_id);
        return NULL;
    }

    vlc_mutex_init(&p_id->lock);
    vlc_cond_init(&p_id->wait);

    p_id->i_type = i_type;
    p_id->i_refcount = 2; /* provider and callbacks */

    return p_id;
}",184.0,205.0,1.0,1.0,22.0,14,6,15,4,3,7,3,3,1,2,,0,5,4,2,2,vlc_dialog_id
2421,84102,dialog_remove_locked,1,dialog_remove_locked,"void dialog_remove_locked (vlc_dialog_provider*,vlc_dialog_id*)",interface\dialog.c,"static void
dialog_remove_locked(vlc_dialog_provider *p_provider, vlc_dialog_id *p_id)
{
    ssize_t i_idx = vlc_array_index_of_item(&p_provider->dialog_array, p_id);
    assert(i_idx >= 0);
    vlc_array_remove(&p_provider->dialog_array, i_idx);

    vlc_mutex_lock(&p_id->lock);
    p_id->i_refcount--;
    if (p_id->i_refcount == 0)
    {
        vlc_mutex_unlock(&p_id->lock);
        dialog_id_release(p_id);
    }
    else
        vlc_mutex_unlock(&p_id->lock);
}",207.0,223.0,1.0,1.0,17.0,14,6,11,3,2,9,2,2,1,3,,0,6,4,2,2,void
2422,84157,dialog_clear_all_locked,1,dialog_clear_all_locked,void dialog_clear_all_locked (vlc_dialog_provider*),interface\dialog.c,"static void
dialog_clear_all_locked(vlc_dialog_provider *p_provider)
{
    for (size_t i = 0; i < vlc_array_count(&p_provider->dialog_array); ++i)
    {
        vlc_dialog_id *p_id =
            vlc_array_item_at_index(&p_provider->dialog_array, i);
        dialog_cancel_locked(p_provider, p_id);
    }
}",225.0,234.0,1.0,1.0,10.0,7,4,8,3,2,3,2,2,1,1,,0,2,2,1,1,void
2423,84190,libvlc_InternalDialogClean,1,libvlc_InternalDialogClean,void libvlc_InternalDialogClean (libvlc_int_t*),interface\dialog.c,"void
libvlc_InternalDialogClean(libvlc_int_t *p_libvlc)
{
    assert(p_libvlc != NULL);
    vlc_dialog_provider *p_provider = libvlc_priv(p_libvlc)->p_dialog_provider;

    if (p_provider == NULL)
        return;
    vlc_mutex_lock(&p_provider->lock);
    dialog_clear_all_locked(p_provider);
    vlc_mutex_unlock(&p_provider->lock);

    vlc_mutex_destroy(&p_provider->lock);
    free(p_provider);
    libvlc_priv(p_libvlc)->p_dialog_provider = NULL;
}",236.0,251.0,1.0,1.0,16.0,12,5,13,3,1,9,2,2,0,6,,0,4,2,1,1,void
2424,84237,vlc_dialog_provider_set_callbacks,1,vlc_dialog_provider_set_callbacks,"void vlc_dialog_provider_set_callbacks (vlc_object_t*,vlc_dialog_cbs*,void*)",interface\dialog.c,"void
vlc_dialog_provider_set_callbacks(vlc_object_t *p_obj,
                                  const vlc_dialog_cbs *p_cbs, void *p_data)
{
    assert(p_obj != NULL);
    vlc_dialog_provider *p_provider = get_dialog_provider(p_obj, false);

    vlc_mutex_lock(&p_provider->lock);
    dialog_clear_all_locked(p_provider);

    if (p_cbs == NULL)
    {
        memset(&p_provider->cbs, 0, sizeof(p_provider->cbs));
        p_provider->p_cbs_data = NULL;
    }
    else
    {
        p_provider->cbs = *p_cbs;
        p_provider->p_cbs_data = p_data;
    }
    vlc_mutex_unlock(&p_provider->lock);
}",254.0,275.0,1.0,1.0,22.0,13,6,14,5,0,9,2,2,0,4,,0,6,6,3,3,void
2425,84299,dialog_wait_interrupted,1,dialog_wait_interrupted,void dialog_wait_interrupted (void*),interface\dialog.c,"static void
dialog_wait_interrupted(void *p_data)
{
    struct dialog_i11e_context *p_context = p_data;
    vlc_dialog_provider *p_provider = p_context->p_provider;
    vlc_dialog_id *p_id = p_context->p_id;

    vlc_mutex_lock(&p_provider->lock);
    dialog_cancel_locked(p_provider, p_id);
    vlc_mutex_unlock(&p_provider->lock);

    vlc_mutex_lock(&p_id->lock);
    vlc_cond_signal(&p_id->wait);
    vlc_mutex_unlock(&p_id->lock);
}",277.0,291.0,1.0,1.0,15.0,15,3,13,4,0,13,1,1,0,6,,0,7,2,1,1,void
2426,84348,dialog_wait,1,dialog_wait,"int dialog_wait (vlc_dialog_provider*,vlc_dialog_id*,dialog_type,dialog_answer*)",interface\dialog.c,"static int
dialog_wait(vlc_dialog_provider *p_provider, vlc_dialog_id *p_id,
            enum dialog_type i_type, struct dialog_answer *p_answer)
{
    struct dialog_i11e_context context = {
        .p_provider = p_provider,
        .p_id = p_id,
    };
    vlc_interrupt_register(dialog_wait_interrupted, &context);

    vlc_mutex_lock(&p_id->lock);
    /* Wait for the dialog to be dismissed, interrupted or answered */
    while (!p_id->b_cancelled && !p_id->b_answered)
        vlc_cond_wait(&p_id->wait, &p_id->lock);

    int i_ret;
    if (p_id->b_cancelled)
        i_ret = 0;
    else if (p_id->answer.i_type != i_type)
        i_ret = VLC_EGENERIC;
    else
    {
        i_ret = 1;
        memcpy(p_answer, &p_id->answer, sizeof(p_id->answer));
        memset(&p_id->answer, 0, sizeof(p_id->answer));
    }

    vlc_mutex_unlock(&p_id->lock);
    vlc_interrupt_unregister();

    vlc_mutex_lock(&p_provider->lock);
    dialog_remove_locked(p_provider, p_id);
    vlc_mutex_unlock(&p_pro...",293.0,327.0,1.0,1.0,35.0,20,6,17,4,2,14,3,3,3,7,,0,7,8,4,4,int
2427,84465,dialog_display_error_va,1,dialog_display_error_va,"int dialog_display_error_va (vlc_dialog_provider*,char*,char*,va_list)",interface\dialog.c,"static int
dialog_display_error_va(vlc_dialog_provider *p_provider, const char *psz_title,
                        const char *psz_fmt, va_list ap)
{
    vlc_mutex_lock(&p_provider->lock);
    if (p_provider->cbs.pf_display_error == NULL)
    {
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_EGENERIC;
    }

    char *psz_text;
    if (vasprintf(&psz_text, psz_fmt, ap) == -1)
    {
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_ENOMEM;
    }

    p_provider->cbs.pf_display_error(p_provider->p_cbs_data, psz_title, psz_text);
    free(psz_text);
    vlc_mutex_unlock(&p_provider->lock);

    return VLC_SUCCESS;
}",329.0,352.0,1.0,1.0,24.0,17,5,17,9,1,11,3,3,1,4,,0,7,8,4,4,int
2428,84532,vlc_dialog_display_error_va,1,vlc_dialog_display_error_va,"int vlc_dialog_display_error_va (vlc_object_t*,char*,char*,va_list)",interface\dialog.c,"int
vlc_dialog_display_error_va(vlc_object_t *p_obj, const char *psz_title,
                            const char *psz_fmt, va_list ap)
{
    assert(p_obj != NULL && psz_title != NULL && psz_fmt != NULL);
    int i_ret;
    vlc_dialog_provider *p_provider = get_dialog_provider(p_obj, true);

    if (p_provider != NULL)
        i_ret = dialog_display_error_va(p_provider, psz_title, psz_fmt, ap);
    else
        i_ret = VLC_EGENERIC;

    if (i_ret != VLC_SUCCESS)
    {
        msg_Err(p_obj, ""%s"", psz_title);
        msg_GenericVa(p_obj, VLC_MSG_ERR, psz_fmt, ap);
    }
    return i_ret;
}",354.0,373.0,1.0,1.0,20.0,9,3,25,10,1,2,3,3,0,2,,0,2,8,4,4,int
2429,84592,vlc_dialog_display_error,1,vlc_dialog_display_error,"int vlc_dialog_display_error (vlc_object_t*,char*,char*...)",interface\dialog.c,"int
vlc_dialog_display_error(vlc_object_t *p_obj, const char *psz_title,
                         const char *psz_fmt, ...)
{
    assert(psz_fmt != NULL);
    va_list ap;
    va_start(ap, psz_fmt);
    int i_ret = vlc_dialog_display_error_va(p_obj, psz_title, psz_fmt, ap);
    va_end(ap);
    return i_ret;
}",377.0,387.0,1.0,1.0,11.0,2,2,11,6,4,1,1,1,0,1,,0,1,6,3,3,int
2430,84619,dialog_display_login_va,1,dialog_display_login_va,"int dialog_display_login_va (vlc_dialog_provider*,vlc_dialog_id**,char*,bool,char*,char*,va_list)",interface\dialog.c,"static int
dialog_display_login_va(vlc_dialog_provider *p_provider, vlc_dialog_id **pp_id,
                        const char *psz_default_username, bool b_ask_store,
                        const char *psz_title, const char *psz_fmt, va_list ap)
{
    vlc_mutex_lock(&p_provider->lock);
    if (p_provider->cbs.pf_display_login == NULL
     || p_provider->cbs.pf_cancel == NULL)
    {
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_EGENERIC;
    }

    char *psz_text;
    if (vasprintf(&psz_text, psz_fmt, ap) == -1)
    {
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_ENOMEM;
    }

    vlc_dialog_id *p_id = dialog_add_locked(p_provider, VLC_DIALOG_LOGIN);
    if (p_id == NULL)
    {
        free(psz_text);
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_ENOMEM;
    }
    p_provider->cbs.pf_display_login(p_provider->p_cbs_data, p_id, psz_title,
                                     psz_text, psz_default_username, b_ask_store);
    free(p...",389.0,423.0,1.0,1.0,35.0,27,8,32,14,1,15,4,4,2,6,,0,10,14,7,7,int
2431,84724,vlc_dialog_wait_login_va,1,vlc_dialog_wait_login_va,"int vlc_dialog_wait_login_va (vlc_object_t*,char**,char**,bool*,char*,char*,char*,va_list)",interface\dialog.c,"int
vlc_dialog_wait_login_va(vlc_object_t *p_obj,  char **ppsz_username,
                         char **ppsz_password, bool *p_store,
                         const char *psz_default_username,
                         const char *psz_title, const char *psz_fmt, va_list ap)
{
    assert(p_obj != NULL && ppsz_username != NULL && ppsz_password != NULL
        && psz_fmt != NULL && psz_title != NULL);

    vlc_dialog_provider *p_provider = get_dialog_provider(p_obj, true);
    if (p_provider == NULL)
        return VLC_EGENERIC;

    vlc_dialog_id *p_id;
    int i_ret = dialog_display_login_va(p_provider, &p_id, psz_default_username,
                                        p_store != NULL, psz_title, psz_fmt, ap);
    if (i_ret < 0 || p_id == NULL)
        return i_ret;

    struct dialog_answer answer;
    i_ret = dialog_wait(p_provider, p_id, VLC_DIALOG_LOGIN, &answer);
    if (i_ret <= 0)
        return i_ret;

    *ppsz_username = answer.u.login.psz_username;
    *ppsz_password = a...",425.0,455.0,1.0,1.0,31.0,36,10,44,16,2,6,5,5,0,3,,0,6,16,8,8,int
2432,84848,vlc_dialog_wait_login,1,vlc_dialog_wait_login,"int vlc_dialog_wait_login (vlc_object_t*,char**,char**,bool*,char*,char*,char*...)",interface\dialog.c,"int
vlc_dialog_wait_login(vlc_object_t *p_obj,  char **ppsz_username,
                      char **ppsz_password, bool *p_store,
                      const char *psz_default_username, const char *psz_title,
                      const char *psz_fmt, ...)
{
    assert(psz_fmt != NULL);
    va_list ap;
    va_start(ap, psz_fmt);
    int i_ret = vlc_dialog_wait_login_va(p_obj, ppsz_username, ppsz_password,
                                         p_store,psz_default_username,
                                         psz_title, psz_fmt, ap);
    va_end(ap);
    return i_ret;
}",458.0,472.0,1.0,1.0,15.0,2,2,15,10,0,1,1,1,0,1,,0,1,14,7,7,int
2433,84883,dialog_display_question_va,1,dialog_display_question_va,"int dialog_display_question_va (vlc_dialog_provider*,vlc_dialog_id**,vlc_dialog_question_type,char*,char*,char*,char*,char*,va_list)",interface\dialog.c,"static int
dialog_display_question_va(vlc_dialog_provider *p_provider, vlc_dialog_id **pp_id,
                           vlc_dialog_question_type i_type,
                           const char *psz_cancel, const char *psz_action1,
                           const char *psz_action2, const char *psz_title,
                           const char *psz_fmt, va_list ap)
{
    vlc_mutex_lock(&p_provider->lock);
    if (p_provider->cbs.pf_display_question == NULL
     || p_provider->cbs.pf_cancel == NULL)
    {
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_EGENERIC;
    }

    char *psz_text;
    if (vasprintf(&psz_text, psz_fmt, ap) == -1)
    {
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_ENOMEM;
    }

    vlc_dialog_id *p_id = dialog_add_locked(p_provider, VLC_DIALOG_QUESTION);
    if (p_id == NULL)
    {
        free(psz_text);
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_ENOMEM;
    }
    p_provider->cbs.pf_display_question(p_provi...",474.0,511.0,1.0,1.0,38.0,27,8,34,16,1,15,4,4,2,6,,0,10,18,9,9,int
2434,84992,vlc_dialog_wait_question_va,1,vlc_dialog_wait_question_va,"int vlc_dialog_wait_question_va (vlc_object_t*,vlc_dialog_question_type,char*,char*,char*,char*,char*,va_list)",interface\dialog.c,"int
vlc_dialog_wait_question_va(vlc_object_t *p_obj,
                            vlc_dialog_question_type i_type,
                            const char *psz_cancel, const char *psz_action1,
                            const char *psz_action2, const char *psz_title,
                            const char *psz_fmt, va_list ap)
{
    assert(p_obj != NULL && psz_fmt != NULL && psz_title != NULL
        && psz_cancel != NULL);

    vlc_dialog_provider *p_provider = get_dialog_provider(p_obj, true);
    if (p_provider == NULL)
        return VLC_EGENERIC;

    vlc_dialog_id *p_id;
    int i_ret = dialog_display_question_va(p_provider, &p_id, i_type,
                                           psz_cancel, psz_action1,
                                           psz_action2, psz_title, psz_fmt, ap);
    if (i_ret < 0 || p_id == NULL)
        return i_ret;

    struct dialog_answer answer;
    i_ret = dialog_wait(p_provider, p_id, VLC_DIALOG_QUESTION, &answer);
    if (i_ret <= 0)
        ret...",513.0,543.0,1.0,1.0,31.0,29,9,39,16,1,6,5,5,2,3,,0,6,16,8,8,int
2435,85106,vlc_dialog_wait_question,1,vlc_dialog_wait_question,"int vlc_dialog_wait_question (vlc_object_t*,vlc_dialog_question_type,char*,char*,char*,char*,char*...)",interface\dialog.c,"int
vlc_dialog_wait_question(vlc_object_t *p_obj,
                         vlc_dialog_question_type i_type,
                         const char *psz_cancel, const char *psz_action1,
                         const char *psz_action2, const char *psz_title,
                         const char *psz_fmt, ...)
{
    assert(psz_fmt != NULL);
    va_list ap;
    va_start(ap, psz_fmt);
    int i_ret = vlc_dialog_wait_question_va(p_obj, i_type, psz_cancel,
                                            psz_action1, psz_action2, psz_title,
                                            psz_fmt, ap);
    va_end(ap);
    return i_ret;
}",546.0,561.0,1.0,1.0,16.0,2,2,15,10,0,1,1,1,0,1,,0,1,14,7,7,int
2436,85141,display_progress_va,1,display_progress_va,"int display_progress_va (vlc_dialog_provider*,vlc_dialog_id**,bool,float,char*,char*,char*,va_list)",interface\dialog.c,"static int
display_progress_va(vlc_dialog_provider *p_provider, vlc_dialog_id **pp_id,
                    bool b_indeterminate, float f_position,
                    const char *psz_cancel, const char *psz_title,
                    const char *psz_fmt, va_list ap)
{
    vlc_mutex_lock(&p_provider->lock);
    if (p_provider->cbs.pf_display_progress == NULL
     || p_provider->cbs.pf_update_progress == NULL
     || p_provider->cbs.pf_cancel == NULL)
    {
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_EGENERIC;
    }

    char *psz_text;
    if (vasprintf(&psz_text, psz_fmt, ap) == -1)
    {
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_ENOMEM;
    }

    vlc_dialog_id *p_id = dialog_add_locked(p_provider, VLC_DIALOG_PROGRESS);
    if (p_id == NULL)
    {
        free(psz_text);
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_ENOMEM;
    }
    p_id->b_progress_indeterminate = b_indeterminate;
    p_id->psz_progress_text = psz_text;
...",563.0,601.0,1.0,1.0,39.0,35,8,38,15,1,18,4,4,3,6,,0,13,16,8,8,int
2437,85264,vlc_dialog_display_progress_va,1,vlc_dialog_display_progress_va,"vlc_dialog_id vlc_dialog_display_progress_va (vlc_object_t*,bool,float,char*,char*,char*,va_list)",interface\dialog.c,"vlc_dialog_id *
vlc_dialog_display_progress_va(vlc_object_t *p_obj, bool b_indeterminate,
                               float f_position, const char *psz_cancel,
                               const char *psz_title, const char *psz_fmt,
                               va_list ap)
{
    assert(p_obj != NULL && psz_title != NULL && psz_fmt != NULL);

    vlc_dialog_provider *p_provider = get_dialog_provider(p_obj, true);
    if (p_provider == NULL)
        return NULL;
    vlc_dialog_id *p_id;
    int i_ret = display_progress_va(p_provider, &p_id, b_indeterminate,
                                    f_position, psz_cancel, psz_title, psz_fmt,
                                    ap);
    return i_ret == VLC_SUCCESS ? p_id : NULL;
}",603.0,619.0,1.0,1.0,17.0,11,6,25,13,1,2,2,2,0,2,,0,2,14,7,7,vlc_dialog_id
2438,85321,vlc_dialog_display_progress,1,vlc_dialog_display_progress,"vlc_dialog_id vlc_dialog_display_progress (vlc_object_t*,bool,float,char*,char*,char*...)",interface\dialog.c,"vlc_dialog_id *
vlc_dialog_display_progress(vlc_object_t *p_obj, bool b_indeterminate,
                            float f_position, const char *psz_cancel,
                            const char *psz_title, const char *psz_fmt, ...)
{
    assert(psz_fmt != NULL);
    va_list ap;
    va_start(ap, psz_fmt);
    vlc_dialog_id *p_id =
        vlc_dialog_display_progress_va(p_obj, b_indeterminate, f_position,
                                       psz_cancel, psz_title, psz_fmt, ap);
    va_end(ap);
    return p_id;
}",622.0,635.0,1.0,1.0,14.0,2,2,14,9,0,1,1,1,0,1,,0,1,12,6,6,vlc_dialog_id
2439,85354,dialog_update_progress,1,dialog_update_progress,"int dialog_update_progress (vlc_object_t*,vlc_dialog_id*,float,char*)",interface\dialog.c,"static int
dialog_update_progress(vlc_object_t *p_obj, vlc_dialog_id *p_id, float f_value,
                       char *psz_text)
{
    assert(p_obj != NULL && p_id != NULL);
    vlc_dialog_provider *p_provider = get_dialog_provider(p_obj, false);

    vlc_mutex_lock(&p_provider->lock);
    if (p_provider->cbs.pf_update_progress == NULL ||
        vlc_dialog_is_cancelled(p_obj, p_id))
    {
        vlc_mutex_unlock(&p_provider->lock);
        free(psz_text);
        return VLC_EGENERIC;
    }

    if (p_id->b_progress_indeterminate)
        f_value = 0.0f;

    if (psz_text != NULL)
    {
        free(p_id->psz_progress_text);
        p_id->psz_progress_text = psz_text;
    }
    p_provider->cbs.pf_update_progress(p_provider->p_cbs_data, p_id, f_value,
                                       p_id->psz_progress_text);

    vlc_mutex_unlock(&p_provider->lock);
    return VLC_SUCCESS;
}",637.0,666.0,1.0,1.0,30.0,24,8,29,9,2,15,4,4,3,5,,0,12,8,4,4,int
2440,85446,vlc_dialog_update_progress,1,vlc_dialog_update_progress,"int vlc_dialog_update_progress (vlc_object_t*,vlc_dialog_id*,float)",interface\dialog.c,"int
vlc_dialog_update_progress(vlc_object_t *p_obj, vlc_dialog_id *p_id,
                           float f_value)
{
    return dialog_update_progress(p_obj, p_id, f_value, NULL);
}",669.0,674.0,1.0,1.0,6.0,0,0,4,4,0,1,1,1,0,1,,0,0,6,3,3,int
2441,85459,vlc_dialog_update_progress_text_va,1,vlc_dialog_update_progress_text_va,"int vlc_dialog_update_progress_text_va (vlc_object_t*,vlc_dialog_id*,float,char*,va_list)",interface\dialog.c,"int
vlc_dialog_update_progress_text_va(vlc_object_t *p_obj, vlc_dialog_id *p_id,
                                   float f_value, const char *psz_fmt,
                                   va_list ap)
{
    assert(psz_fmt != NULL);

    char *psz_text;
    if (vasprintf(&psz_text, psz_fmt, ap) == -1)
        return VLC_ENOMEM;
    return dialog_update_progress(p_obj, p_id, f_value, psz_text);
}",676.0,687.0,1.0,1.0,12.0,4,4,10,8,1,1,2,2,0,1,,0,0,10,5,5,int
2442,85491,vlc_dialog_update_progress_text,1,vlc_dialog_update_progress_text,"int vlc_dialog_update_progress_text (vlc_object_t*,vlc_dialog_id*,float,char*...)",interface\dialog.c,"int
vlc_dialog_update_progress_text(vlc_object_t *p_obj, vlc_dialog_id *p_id,
                                float f_value, const char *psz_fmt, ...)
{
    assert(psz_fmt != NULL);
    va_list ap;
    va_start(ap, psz_fmt);
    int i_ret = vlc_dialog_update_progress_text_va(p_obj, p_id, f_value,
                                                   psz_fmt, ap);
    va_end(ap);
    return i_ret;
}",690.0,701.0,1.0,1.0,12.0,2,2,12,7,0,1,1,1,0,1,,0,1,8,4,4,int
2443,85520,vlc_dialog_release,1,vlc_dialog_release,"void vlc_dialog_release (vlc_object_t*,vlc_dialog_id*)",interface\dialog.c,"void
vlc_dialog_release(vlc_object_t *p_obj, vlc_dialog_id *p_id)
{
    assert(p_obj != NULL && p_id != NULL);
    vlc_dialog_provider *p_provider = get_dialog_provider(p_obj, false);

    vlc_mutex_lock(&p_provider->lock);
    dialog_cancel_locked(p_provider, p_id);
    dialog_remove_locked(p_provider, p_id);
    vlc_mutex_unlock(&p_provider->lock);
}",704.0,714.0,1.0,1.0,11.0,8,5,13,5,0,7,1,1,0,5,,0,3,4,2,2,void
2444,85556,vlc_dialog_is_cancelled,1,vlc_dialog_is_cancelled,"bool vlc_dialog_is_cancelled (vlc_object_t*,vlc_dialog_id*)",interface\dialog.c,"bool
vlc_dialog_is_cancelled(vlc_object_t *p_obj, vlc_dialog_id *p_id)
{
    (void) p_obj;
    assert(p_id != NULL);

    vlc_mutex_lock(&p_id->lock);
    bool b_cancelled = p_id->b_cancelled;
    vlc_mutex_unlock(&p_id->lock);
    return b_cancelled;
}",717.0,727.0,1.0,1.0,11.0,8,5,8,4,1,5,1,1,0,2,,0,3,4,2,2,bool
2445,85587,vlc_dialog_id_set_context,1,vlc_dialog_id_set_context,"void vlc_dialog_id_set_context (vlc_dialog_id*,void*)",interface\dialog.c,"void
vlc_dialog_id_set_context(vlc_dialog_id *p_id, void *p_context)
{
    vlc_mutex_lock(&p_id->lock);
    p_id->p_context = p_context;
    vlc_mutex_unlock(&p_id->lock);
}",729.0,735.0,1.0,1.0,7.0,6,3,4,2,0,5,1,1,0,2,,0,3,4,2,2,void
2446,85608,vlc_dialog_id_get_context,1,vlc_dialog_id_get_context,void* vlc_dialog_id_get_context (vlc_dialog_id*),interface\dialog.c,"void *
vlc_dialog_id_get_context(vlc_dialog_id *p_id)
{
    assert(p_id != NULL);
    vlc_mutex_lock(&p_id->lock);
    void *p_context = p_id->p_context;
    vlc_mutex_unlock(&p_id->lock);
    return p_context;
}",737.0,745.0,1.0,1.0,9.0,7,4,7,3,0,5,1,1,0,2,,0,3,2,1,1,void*
2447,85635,dialog_id_post,1,dialog_id_post,"int dialog_id_post (vlc_dialog_id*,dialog_answer*)",interface\dialog.c,"static int
dialog_id_post(vlc_dialog_id *p_id, struct dialog_answer *p_answer)
{
    vlc_mutex_lock(&p_id->lock);
    if (p_answer == NULL)
    {
        p_id->b_cancelled = true;
    }
    else
    {
        p_id->answer = *p_answer;
        p_id->b_answered = true;
    }
    p_id->i_refcount--;
    if (p_id->i_refcount > 0)
    {
        vlc_cond_signal(&p_id->wait);
        vlc_mutex_unlock(&p_id->lock);
    }
    else
    {
        vlc_mutex_unlock(&p_id->lock);
        dialog_id_release(p_id);
    }
    return VLC_SUCCESS;
}",747.0,772.0,1.0,1.0,26.0,13,6,10,5,4,9,3,3,1,3,,0,6,4,2,2,int
2448,85701,vlc_dialog_id_post_login,1,vlc_dialog_id_post_login,"int vlc_dialog_id_post_login (vlc_dialog_id*,char*,char*,bool)",interface\dialog.c,"int
vlc_dialog_id_post_login(vlc_dialog_id *p_id, const char *psz_username,
                         const char *psz_password, bool b_store)
{
    assert(p_id != NULL && psz_username != NULL && psz_password != NULL);

    struct dialog_answer answer = {
        .i_type = VLC_DIALOG_LOGIN,
        .u.login = {
            .b_store = b_store,
            .psz_username = strdup(psz_username),
            .psz_password = strdup(psz_password),
        },
    };
    if (answer.u.login.psz_username == NULL
     || answer.u.login.psz_password == NULL)
    {
        free(answer.u.login.psz_username);
        free(answer.u.login.psz_password);
        dialog_id_post(p_id, NULL);
        return VLC_ENOMEM;
    }

    return dialog_id_post(p_id, &answer);
}",774.0,798.0,1.0,1.0,25.0,34,8,34,11,0,6,2,2,2,2,,0,4,8,4,4,int
2449,85811,vlc_dialog_id_post_action,1,vlc_dialog_id_post_action,"int vlc_dialog_id_post_action (vlc_dialog_id*,int)",interface\dialog.c,"int
vlc_dialog_id_post_action(vlc_dialog_id *p_id, int i_action)
{
    assert(p_id != NULL);

    struct dialog_answer answer = {
        .i_type = VLC_DIALOG_QUESTION,
        .u.question = { .i_action = i_action },
    };

    return dialog_id_post(p_id, &answer);
}",800.0,811.0,1.0,1.0,12.0,11,4,13,8,0,1,1,1,0,1,,0,0,4,2,2,int
2450,85849,vlc_dialog_id_dismiss,1,vlc_dialog_id_dismiss,int vlc_dialog_id_dismiss (vlc_dialog_id*),interface\dialog.c,"int
vlc_dialog_id_dismiss(vlc_dialog_id *p_id)
{
    return dialog_id_post(p_id, NULL);
}",813.0,817.0,1.0,1.0,5.0,0,0,2,2,0,1,1,1,0,1,,0,0,2,1,1,int
2451,85858,vlc_dialog_provider_set_ext_callback,1,vlc_dialog_provider_set_ext_callback,"void vlc_dialog_provider_set_ext_callback (vlc_object_t*,vlc_dialog_ext_update_cb,void*)",interface\dialog.c,"void
vlc_dialog_provider_set_ext_callback(vlc_object_t *p_obj,
                                     vlc_dialog_ext_update_cb pf_update,
                                     void *p_data)
{
    assert(p_obj != NULL);
    vlc_dialog_provider *p_provider = get_dialog_provider(p_obj, false);

    vlc_mutex_lock(&p_provider->lock);

    p_provider->pf_ext_update = pf_update;
    p_provider->p_ext_data = p_data;

    vlc_mutex_unlock(&p_provider->lock);
}",820.0,834.0,1.0,1.0,15.0,10,4,11,6,0,7,1,1,0,3,,0,5,6,3,3,void
2452,85895,vlc_ext_dialog_update,1,vlc_ext_dialog_update,"int vlc_ext_dialog_update (vlc_object_t*,extension_dialog_t*)",interface\dialog.c,"int
vlc_ext_dialog_update(vlc_object_t *p_obj, extension_dialog_t *p_ext_dialog)
{
    assert(p_obj != NULL);
    vlc_dialog_provider *p_provider = get_dialog_provider(p_obj, false);

    vlc_mutex_lock(&p_provider->lock);
    if (p_provider->pf_ext_update == NULL)
    {
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_EGENERIC;
    }
    p_provider->pf_ext_update(p_ext_dialog, p_provider->p_ext_data);
    vlc_mutex_unlock(&p_provider->lock);
    return VLC_SUCCESS;
}",837.0,852.0,1.0,1.0,16.0,12,5,15,7,0,10,2,2,1,4,,0,7,4,2,2,int
2453,85968,AddIntfCallback,1,AddIntfCallback,"int AddIntfCallback (vlc_object_t*,char*,ANY,ANY,void*)",interface\interface.c,"static int AddIntfCallback( vlc_object_t *obj, char const *var,
                            vlc_value_t old, vlc_value_t cur, void *data )
{
    playlist_t *playlist = data;

    int ret = intf_Create( playlist, cur.psz_string );
    if( ret )
        msg_Err( obj, ""interface \""%s\"" initialization failed"",
                 cur.psz_string );

    (void) var; (void) old;
    return ret;
}",272.0,284.0,1.0,1.0,13.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,int
2454,85981,intf_Create,1,intf_Create,"int intf_Create (playlist_t*,char*)",interface\interface.c,"int intf_Create( playlist_t *playlist, const char *chain )
{
    /* Allocate structure */
    intf_thread_t *p_intf = vlc_custom_create( playlist, sizeof( *p_intf ),
                                               ""interface"" );
    if( unlikely(p_intf == NULL) )
        return VLC_ENOMEM;

    /* Variable used for interface spawning */
    vlc_value_t val, text;
    var_Create( p_intf, ""intf-add"", VLC_VAR_STRING | VLC_VAR_ISCOMMAND );
    text.psz_string = _(""Add Interface"");
    var_Change( p_intf, ""intf-add"", VLC_VAR_SETTEXT, &text, NULL );
#if !defined(_WIN32) && defined(HAVE_ISATTY)
    if( isatty( 0 ) )
#endif
    {
        val.psz_string = (char *)""rc,none"";
        text.psz_string = (char *)_(""Console"");
        var_Change( p_intf, ""intf-add"", VLC_VAR_ADDCHOICE, &val, &text );
    }
    val.psz_string = (char *)""telnet,none"";
    text.psz_string = (char *)_(""Telnet"");
    var_Change( p_intf, ""intf-add"", VLC_VAR_ADDCHOICE, &val, &text );
    val.psz_string = (char *)""http,none...",71.0,130.0,1.0,28.0,60.0,59,9,73,18,0,17,5,4,0,15,,0,4,4,2,2,int
2455,86216,intf_GetPlaylist,1,intf_GetPlaylist,playlist_t intf_GetPlaylist (libvlc_int_t*),interface\interface.c,"static playlist_t *intf_GetPlaylist(libvlc_int_t *libvlc)
{
    playlist_t *playlist;

    vlc_mutex_lock(&lock);
    playlist = libvlc_priv(libvlc)->playlist;
    if (playlist == NULL)
    {
        playlist = playlist_Create(VLC_OBJECT(libvlc));
        libvlc_priv(libvlc)->playlist = playlist;
    }
    vlc_mutex_unlock(&lock);

    return playlist;
}",137.0,151.0,1.0,1.0,15.0,8,4,11,4,2,7,2,2,0,5,,0,4,2,1,1,playlist_t
2456,86252,intf_InsertItem,1,intf_InsertItem,"int intf_InsertItem (libvlc_int_t*,char*,unsigned,char**,unsigned)",interface\interface.c,"int intf_InsertItem(libvlc_int_t *libvlc, const char *mrl, unsigned optc,
                    const char *const *optv, unsigned flags)
{
    playlist_t *playlist = intf_GetPlaylist(libvlc);
    input_item_t *item = input_item_New(mrl, NULL);

    if (unlikely(item == NULL))
        return -1;

    int ret = -1;

    if (input_item_AddOptions(item, optc, optv, flags) == VLC_SUCCESS)
    {
        playlist_Lock(playlist);
        if (playlist_NodeAddInput(playlist, item, playlist->p_playing,
                                  0) != NULL)
            ret = 0;
        playlist_Unlock(playlist);
    }
    input_item_Release(item);
    return ret;
}",163.0,184.0,1.0,1.0,22.0,10,5,22,10,1,6,4,5,2,6,,0,3,10,5,5,int
2457,86317,libvlc_InternalPlay,1,libvlc_InternalPlay,void libvlc_InternalPlay (libvlc_int_t*),interface\interface.c,"void libvlc_InternalPlay(libvlc_int_t *libvlc)
{
    playlist_t *pl;

    vlc_mutex_lock(&lock);
    pl = libvlc_priv(libvlc)->playlist;
    vlc_mutex_unlock(&lock);

    if (pl != NULL && var_GetBool(pl, ""playlist-autostart""))
        playlist_Control(pl, PLAYLIST_PLAY, false);
}",186.0,196.0,1.0,1.0,11.0,6,5,10,6,0,6,2,2,0,4,,0,3,2,1,1,void
2458,86348,libvlc_InternalAddIntf,1,libvlc_InternalAddIntf,"int libvlc_InternalAddIntf (libvlc_int_t*,char*)",interface\interface.c,"int libvlc_InternalAddIntf(libvlc_int_t *libvlc, const char *name)
{
    playlist_t *playlist = intf_GetPlaylist(libvlc);
    int ret;

    if (unlikely(playlist == NULL))
        ret = VLC_ENOMEM;
    else
    if (name != NULL)
        ret = intf_Create(playlist, name);
    else
    {   /* Default interface */
        char *intf = var_InheritString(libvlc, ""intf"");
        if (intf == NULL) /* ""intf"" has not been set */
        {
#if !defined(_WIN32) && !defined(__OS2__)
            char *pidfile = var_InheritString(libvlc, ""pidfile"");
            if (pidfile != NULL)
                free(pidfile);
            else
#endif
                msg_Info(libvlc, _(""Running vlc with the default interface. ""
                         ""Use 'cvlc' to use vlc without interface.""));
        }
        ret = intf_Create(playlist, intf);
        free(intf);
        name = ""default"";
    }
    if (ret != VLC_SUCCESS)
        msg_Err(libvlc, ""interface \""%s\"" initialization failed"", name);
    return ...",201.0,232.0,1.0,1.0,32.0,4,3,11,7,2,1,3,3,0,1,,0,1,4,2,2,int
2459,86434,intf_DestroyAll,1,intf_DestroyAll,void intf_DestroyAll (libvlc_int_t*),interface\interface.c,"void intf_DestroyAll(libvlc_int_t *libvlc)
{
    playlist_t *playlist;

    vlc_mutex_lock(&lock);
    playlist = libvlc_priv(libvlc)->playlist;
    if (playlist != NULL)
    {
        intf_thread_t *intf, **pp = &(pl_priv(playlist)->interface);

        while ((intf = *pp) != NULL)
        {
            *pp = intf->p_next;
            vlc_mutex_unlock(&lock);

            module_unneed(intf, intf->p_module);
            config_ChainDestroy(intf->p_cfg);
            var_DelCallback(intf, ""intf-add"", AddIntfCallback, playlist);
            vlc_object_release(intf);

            vlc_mutex_lock(&lock);
        }

        libvlc_priv(libvlc)->playlist = NULL;
    }
    vlc_mutex_unlock(&lock);

    if (playlist != NULL)
        playlist_Destroy(playlist);
}",239.0,268.0,1.0,38.0,30.0,21,5,29,8,1,15,4,5,0,11,,0,5,2,1,1,void
2460,86908,vlc_module_begin,1,vlc_module_begin,ANY vlc_module_begin (),libvlc-module.c,vlc_module_begin (),1488.0,1488.0,1.0,19.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2461,86913,set_category,1,set_category,ANY set_category (ANY),libvlc-module.c,set_category( CAT_AUDIO ),1490.0,1490.0,5.0,29.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2462,86919,set_subcategory,1,set_subcategory,ANY set_subcategory (ANY),libvlc-module.c,set_subcategory( SUBCAT_AUDIO_GENERAL ),1491.0,1491.0,5.0,43.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2463,86988,GetFilenames,1,GetFilenames,"void GetFilenames (libvlc_int_t*,unsigned,char[]*)",libvlc.c,"static void GetFilenames( libvlc_int_t *p_vlc, unsigned n,
                          const char *const args[] )
{
    while( n > 0 )
    {
        /* Count the input options */
        unsigned i_options = 0;

        while( args[--n][0] == ':' )
        {
            i_options++;
            if( n == 0 )
            {
                msg_Warn( p_vlc, ""options %s without item"", args[n] );
                return; /* syntax!? */
            }
        }

        char *mrl = NULL;
        if( strstr( args[n], ""://"" ) == NULL )
        {
            mrl = vlc_path2uri( args[n], NULL );
            if( !mrl )
                continue;
        }

        intf_InsertItem( p_vlc, (mrl != NULL) ? mrl : args[n], i_options,
                         ( i_options ? &args[n + 1] : NULL ),
                         VLC_INPUT_OPTION_TRUSTED );
        free( mrl );
    }
}",456.0,487.0,1.0,1.0,32.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
2464,86995,libvlc_InternalCreate,1,libvlc_InternalCreate,libvlc_int_t libvlc_InternalCreate (void),libvlc.c,"libvlc_int_t * libvlc_InternalCreate( void )
{
    libvlc_int_t *p_libvlc;
    libvlc_priv_t *priv;

    /* Allocate a libvlc instance object */
    p_libvlc = (vlc_custom_create)( NULL, sizeof (*priv), ""libvlc"" );
    if( p_libvlc == NULL )
        return NULL;

    priv = libvlc_priv (p_libvlc);
    priv->playlist = NULL;
    priv->p_vlm = NULL;

    vlc_ExitInit( &priv->exit );

    return p_libvlc;
}",83.0,100.0,1.0,1.0,18.0,11,6,14,3,0,6,2,2,0,3,,0,5,2,1,1,libvlc_int_t
2465,87038,libvlc_InternalInit,1,libvlc_InternalInit,"int libvlc_InternalInit (libvlc_int_t*,int,char[]*)",libvlc.c,"int libvlc_InternalInit( libvlc_int_t *p_libvlc, int i_argc,
                         const char *ppsz_argv[] )
{
    libvlc_priv_t *priv = libvlc_priv (p_libvlc);
    char *       psz_modules = NULL;
    char *       psz_parser = NULL;
    char *       psz_control = NULL;
    char        *psz_val;
    int          i_ret = VLC_EGENERIC;

    /* System specific initialization code */
    system_Init();

    vlc_LogPreinit(p_libvlc);

    /* Initialize the module bank and load the configuration of the
     * core module. We need to do this at this stage to be able to display
     * a short help if required by the user. (short help == core module
     * options) */
    module_InitBank ();

    /* Get command line options that affect module loading. */
    if( config_LoadCmdLine( p_libvlc, i_argc, ppsz_argv, NULL ) )
    {
        module_EndBank (false);
        return VLC_EGENERIC;
    }

    vlc_threads_setup (p_libvlc);

    /* Load the builtins and plugins into the module_bank.
    ...",110.0,376.0,1.0,8.0,267.0,45,12,143,26,0,39,23,22,7,36,,0,12,6,3,3,int
2466,87422,libvlc_InternalCleanup,1,libvlc_InternalCleanup,void libvlc_InternalCleanup (libvlc_int_t*),libvlc.c,"void libvlc_InternalCleanup( libvlc_int_t *p_libvlc )
{
    libvlc_priv_t *priv = libvlc_priv (p_libvlc);

    if (priv->parser != NULL)
        playlist_preparser_Deactivate(priv->parser);

    /* Ask the interfaces to stop and destroy them */
    msg_Dbg( p_libvlc, ""removing all interfaces"" );
    intf_DestroyAll( p_libvlc );

    libvlc_InternalDialogClean( p_libvlc );
    libvlc_InternalKeystoreClean( p_libvlc );

#ifdef ENABLE_VLM
    /* Destroy VLM if created in libvlc_InternalInit */
    if( priv->p_vlm )
    {
        vlm_Delete( priv->p_vlm );
    }
#endif

#if !defined( _WIN32 ) && !defined( __OS2__ )
    char *pidfile = var_InheritString( p_libvlc, ""pidfile"" );
    if( pidfile != NULL )
    {
        msg_Dbg( p_libvlc, ""removing PID file %s"", pidfile );
        if( unlink( pidfile ) )
            msg_Warn( p_libvlc, ""cannot remove PID file %s: %s"",
                      pidfile, vlc_strerror_c(errno) );
        free( pidfile );
    }
#endif

    if (priv->parser != NULL)
...",382.0,431.0,1.0,1.0,50.0,10,4,28,6,2,15,6,7,2,11,,0,5,2,1,1,void
2467,87505,libvlc_InternalDestroy,1,libvlc_InternalDestroy,void libvlc_InternalDestroy (libvlc_int_t*),libvlc.c,"void libvlc_InternalDestroy( libvlc_int_t *p_libvlc )
{
    libvlc_priv_t *priv = libvlc_priv( p_libvlc );

    vlc_ExitDestroy( &priv->exit );

    assert( atomic_load(&(vlc_internals(p_libvlc)->refs)) == 1 );
    vlc_object_release( p_libvlc );
}",440.0,448.0,1.0,26.0,9.0,8,6,6,2,0,4,1,1,0,3,,0,2,2,1,1,void
2468,87626,vlc_MetadataRequest,1,vlc_MetadataRequest,"int vlc_MetadataRequest (libvlc_int_t*,input_item_t*,input_item_meta_request_option_t,int,void*)",libvlc.c,"int vlc_MetadataRequest(libvlc_int_t *libvlc, input_item_t *item,
                        input_item_meta_request_option_t i_options,
                        int timeout, void *id)
{
    libvlc_priv_t *priv = libvlc_priv(libvlc);

    if (unlikely(priv->parser == NULL))
        return VLC_ENOMEM;

    if( i_options & META_REQUEST_OPTION_DO_INTERACT )
    {
        vlc_mutex_lock( &item->lock );
        item->b_preparse_interact = true;
        vlc_mutex_unlock( &item->lock );
    }
    playlist_preparser_Push( priv->parser, item, i_options, timeout, id );
    return VLC_SUCCESS;

}",489.0,507.0,1.0,1.0,19.0,11,5,17,11,0,6,3,3,1,4,,0,3,10,5,5,int
2469,87680,libvlc_MetadataRequest,1,libvlc_MetadataRequest,"int libvlc_MetadataRequest (libvlc_int_t*,input_item_t*,input_item_meta_request_option_t,int,void*)",libvlc.c,"int libvlc_MetadataRequest(libvlc_int_t *libvlc, input_item_t *item,
                           input_item_meta_request_option_t i_options,
                           int timeout, void *id)
{
    libvlc_priv_t *priv = libvlc_priv(libvlc);

    if (unlikely(priv->parser == NULL))
        return VLC_ENOMEM;

    vlc_mutex_lock( &item->lock );
    if( item->i_preparse_depth == 0 )
        item->i_preparse_depth = 1;
    if( i_options & META_REQUEST_OPTION_DO_INTERACT )
        item->b_preparse_interact = true;
    vlc_mutex_unlock( &item->lock );
    playlist_preparser_Push( priv->parser, item, i_options, timeout, id );
    return VLC_SUCCESS;
}",514.0,531.0,1.0,1.0,18.0,15,5,19,11,0,6,4,4,1,4,,0,3,10,5,5,int
2470,87746,libvlc_ArtRequest,1,libvlc_ArtRequest,"int libvlc_ArtRequest (libvlc_int_t*,input_item_t*,input_item_meta_request_option_t)",libvlc.c,"int libvlc_ArtRequest(libvlc_int_t *libvlc, input_item_t *item,
                      input_item_meta_request_option_t i_options)
{
    libvlc_priv_t *priv = libvlc_priv(libvlc);

    if (unlikely(priv->parser == NULL))
        return VLC_ENOMEM;

    playlist_preparser_fetcher_Push(priv->parser, item, i_options);
    return VLC_SUCCESS;
}",537.0,547.0,1.0,1.0,11.0,4,3,9,7,1,4,2,2,1,2,,0,3,6,3,3,int
2471,87776,libvlc_MetadataCancel,1,libvlc_MetadataCancel,"void libvlc_MetadataCancel (libvlc_int_t*,void*)",libvlc.c,"void libvlc_MetadataCancel(libvlc_int_t *libvlc, void *id)
{
    libvlc_priv_t *priv = libvlc_priv(libvlc);

    if (unlikely(priv->parser == NULL))
        return;

    playlist_preparser_Cancel(priv->parser, id);
}",555.0,563.0,1.0,1.0,9.0,4,3,6,4,1,4,2,2,1,2,,0,3,4,2,2,void
2472,87824,vlc_CPU_init,1,vlc_CPU_init,void vlc_CPU_init (void),misc\cpu.c,"void vlc_CPU_init (void)
{
    uint32_t i_capabilities = 0;

#if defined( __i386__ ) || defined( __x86_64__ )
     unsigned int i_eax, i_ebx, i_ecx, i_edx;
     bool b_amd;

    /* Needed for x86 CPU capabilities detection */
# if defined (__i386__) && defined (__PIC__)
#  define cpuid(reg) \
     asm volatile (""xchgl %%ebx,%1\n\t"" \
                   ""cpuid\n\t"" \
                   ""xchgl %%ebx,%1\n\t"" \
                   : ""=a"" (i_eax), ""=r"" (i_ebx), ""=c"" (i_ecx), ""=d"" (i_edx) \
                   : ""a"" (reg) \
                   : ""cc"");
# else
#  define cpuid(reg) \
     asm volatile (""cpuid\n\t"" \
                   : ""=a"" (i_eax), ""=b"" (i_ebx), ""=c"" (i_ecx), ""=d"" (i_edx) \
                   : ""a"" (reg) \
                   : ""cc"");
# endif
     /* Check if the OS really supports the requested instructions */
# if defined (__i386__) && !defined (__i486__) && !defined (__i586__) \
  && !defined (__i686__) && !defined (__pentium4__) \
  && !defined (__k6__) && !defined (__ath...",124.0,264.0,1.0,1.0,141.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2473,87829,vlc_CPU_dump,1,vlc_CPU_dump,void vlc_CPU_dump (vlc_object_t*),misc\cpu.c,"void vlc_CPU_dump (vlc_object_t *obj)
{
    struct vlc_memstream stream;

    vlc_memstream_open(&stream);

#if defined (__i386__) || defined (__x86_64__)
    if (vlc_CPU_MMX())
        vlc_memstream_puts(&stream, ""MMX "");
    if (vlc_CPU_MMXEXT())
        vlc_memstream_puts(&stream, ""MMXEXT "");
    if (vlc_CPU_SSE())
        vlc_memstream_puts(&stream, ""SSE "");
    if (vlc_CPU_SSE2())
        vlc_memstream_puts(&stream, ""SSE2 "");
    if (vlc_CPU_SSE3())
        vlc_memstream_puts(&stream, ""SSE3 "");
    if (vlc_CPU_SSSE3())
        vlc_memstream_puts(&stream, ""SSSE3 "");
    if (vlc_CPU_SSE4_1())
        vlc_memstream_puts(&stream, ""SSE4.1 "");
    if (vlc_CPU_SSE4_2())
        vlc_memstream_puts(&stream, ""SSE4.2 "");
    if (vlc_CPU_SSE4A())
        vlc_memstream_puts(&stream, ""SSE4A "");
    if (vlc_CPU_AVX())
        vlc_memstream_puts(&stream, ""AVX "");
    if (vlc_CPU_AVX2())
        vlc_memstream_puts(&stream, ""AVX2 "");
    if (vlc_CPU_3dNOW())
        vlc_memstream_puts(&stream, ""...",281.0,336.0,1.0,1.0,56.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
2474,87862,vlc_LogPreinit,1,vlc_LogPreinit,int vlc_LogPreinit (libvlc_int_t*),misc\messages.c,"int vlc_LogPreinit(libvlc_int_t *vlc)
{
    vlc_logger_t *logger = vlc_custom_create(vlc, sizeof (*logger), ""logger"");

    libvlc_priv(vlc)->logger = logger;

    if (unlikely(logger == NULL))
        return -1;

    vlc_rwlock_init(&logger->lock);

    if (vlc_LogEarlyOpen(logger))
    {
        logger->log = vlc_vaLogDiscard;
        return -1;
    }

    /* Announce who we are */
    msg_Dbg(vlc, ""VLC media player - %s"", VERSION_MESSAGE);
    msg_Dbg(vlc, ""%s"", COPYRIGHT_MESSAGE);
    msg_Dbg(vlc, ""revision %s"", psz_vlc_changeset);
    msg_Dbg(vlc, ""configured with %s"", CONFIGURE_LINE);
    return 0;
}",323.0,346.0,1.0,27.0,24.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
2475,87867,vlc_LogInit,1,vlc_LogInit,int vlc_LogInit (libvlc_int_t*),misc\messages.c,"int vlc_LogInit(libvlc_int_t *vlc)
{
    vlc_logger_t *logger = libvlc_priv(vlc)->logger;
    if (unlikely(logger == NULL))
        return -1;

    vlc_log_cb cb;
    void *sys, *early_sys = NULL;

    /* TODO: module configuration item */
    module_t *module = vlc_module_load(logger, ""logger"", NULL, false,
                                       vlc_logger_load, logger, &cb, &sys);
    if (module == NULL)
        cb = vlc_vaLogDiscard;

    vlc_rwlock_wrlock(&logger->lock);
    if (logger->log == vlc_vaLogEarly)
        early_sys = logger->sys;

    logger->log = cb;
    logger->sys = sys;
    assert(logger->module == NULL); /* Only one call to vlc_LogInit()! */
    logger->module = module;
    vlc_rwlock_unlock(&logger->lock);

    if (early_sys != NULL)
        vlc_LogEarlyClose(logger, early_sys);

    return 0;
}",354.0,383.0,1.0,1.0,30.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
2476,87872,vlc_LogDeinit,1,vlc_LogDeinit,void vlc_LogDeinit (libvlc_int_t*),misc\messages.c,"void vlc_LogDeinit(libvlc_int_t *vlc)
{
    vlc_logger_t *logger = libvlc_priv(vlc)->logger;

    if (unlikely(logger == NULL))
        return;

    if (logger->module != NULL)
        vlc_module_unload(vlc, logger->module, vlc_logger_unload, logger->sys);
    else
    /* Flush early log messages (corner case: no call to vlc_LogInit()) */
    if (logger->log == vlc_vaLogEarly)
    {
        logger->log = vlc_vaLogDiscard;
        vlc_LogEarlyClose(logger, logger->sys);
    }

    vlc_rwlock_destroy(&logger->lock);
    vlc_object_release(logger);
    libvlc_priv(vlc)->logger = NULL;
}",422.0,442.0,1.0,1.0,21.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
2477,87879,handler,1,vlc_exit.handler,void vlc_exit.handler (void*),libvlc.h,void (*handler) (void *);,83.0,83.0,10.0,28.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
2478,87886,vlc_ExitInit,1,vlc_ExitInit,void vlc_ExitInit (vlc_exit_t*),misc\exit.c,"void vlc_ExitInit( vlc_exit_t *exit )
{
    vlc_mutex_init( &exit->lock );
    exit->handler = NULL;
    exit->opaque = NULL;
}",30.0,35.0,1.0,1.0,6.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
2479,87891,vlc_ExitDestroy,1,vlc_ExitDestroy,void vlc_ExitDestroy (vlc_exit_t*),misc\exit.c,"void vlc_ExitDestroy( vlc_exit_t *exit )
{
    vlc_mutex_destroy( &exit->lock );
}",37.0,40.0,1.0,1.0,4.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
2480,87896,vlc_custom_create,1,vlc_custom_create,"void* vlc_custom_create (vlc_object_t*,size_t,char*)",misc\objects.c,"void *vlc_custom_create (vlc_object_t *parent, size_t length,
                         const char *typename)
{
    /* NOTE:
     * VLC objects are laid out as follow:
     * - first the LibVLC-private per-object data,
     * - then VLC_COMMON members from vlc_object_t,
     * - finally, the type-specific data (if any).
     *
     * This function initializes the LibVLC and common data,
     * and zeroes the rest.
     */
    assert (length >= sizeof (vlc_object_t));

    vlc_object_internals_t *priv = malloc (sizeof (*priv) + length);
    if (unlikely(priv == NULL))
        return NULL;
    priv->psz_name = NULL;
    priv->var_root = NULL;
    vlc_mutex_init (&priv->var_lock);
    vlc_cond_init (&priv->var_wait);
    atomic_init (&priv->refs, 1);
    priv->pf_destructor = NULL;
    priv->prev = NULL;
    priv->first = NULL;
    vlc_mutex_init (&priv->tree_lock);
    priv->resources = NULL;

    vlc_object_t *obj = (vlc_object_t *)(priv + 1);
    obj->obj.object_type = typename;
    ...",176.0,247.0,1.0,41.0,72.0,0,0,0,0,42,0,1,1,0,0,,0,0,6,3,3,void*
2481,87903,vlc_object_set_name,1,vlc_object_set_name,"int vlc_object_set_name (vlc_object_t*,char*)",misc\objects.c,"int vlc_object_set_name(vlc_object_t *obj, const char *name)
{
    vlc_object_internals_t *priv = vlc_internals(obj);
    char *newname = name ? strdup (name) : NULL;
    char *oldname;

    vlc_mutex_lock (&name_lock);
    oldname = priv->psz_name;
    priv->psz_name = newname;
    vlc_mutex_unlock (&name_lock);

    free (oldname);
    return (priv->psz_name || !name) ? VLC_SUCCESS : VLC_ENOMEM;
}",282.0,295.0,1.0,35.0,14.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
2482,87909,vlc_destructor_t,1,vlc_destructor_t,void vlc_destructor_t (vlc_object_t*),libvlc.h,typedef void (*vlc_destructor_t) (struct vlc_object_t *);,119.0,119.0,14.0,56.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2483,87914,vlc_object_set_destructor,1,vlc_object_set_destructor,"void vlc_object_set_destructor (vlc_object_t*,vlc_destructor_t)",misc\objects.c,"void vlc_object_set_destructor( vlc_object_t *p_this,
                                vlc_destructor_t pf_destructor )
{
    vlc_object_internals_t *p_priv = vlc_internals(p_this );

    p_priv->pf_destructor = pf_destructor;
}",271.0,277.0,1.0,37.0,7.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
2484,87920,vlc_objres_new,1,vlc_objres_new,"void* vlc_objres_new (size_t,void)",misc\objres.c,"void *vlc_objres_new(size_t size, void (*release)(void *))
{
    if (unlikely(add_overflow(sizeof (struct vlc_res), size, &size)))
    {
        errno = ENOMEM;
        return NULL;
    }

    struct vlc_res *res = malloc(size);
    if (unlikely(res == NULL))
        return NULL;

    res->release = release;
    return res->payload;
}",47.0,61.0,1.0,1.0,15.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,void*
2485,87926,vlc_objres_push,1,vlc_objres_push,"void vlc_objres_push (vlc_object_t*,void*)",misc\objres.c,"void vlc_objres_push(vlc_object_t *obj, void *data)
{
    struct vlc_res **restrict pp = vlc_obj_res(obj);
    struct vlc_res *res = container_of(data, struct vlc_res, payload);

    res->prev = *pp;
    *pp = res;
}",63.0,70.0,1.0,1.0,8.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,void
2486,87932,vlc_objres_clear,1,vlc_objres_clear,void vlc_objres_clear (vlc_object_t*),misc\objres.c,"void vlc_objres_clear(vlc_object_t *obj)
{
    void *data;

    while ((data = vlc_objres_pop(obj)) != NULL)
    {
        struct vlc_res *res = container_of(data, struct vlc_res, payload);

        res->release(res->payload);
        free(res);
    }
}",83.0,94.0,1.0,1.0,12.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
2487,87937,vlc_objres_remove,1,vlc_objres_remove,"void vlc_objres_remove (vlc_object_t*,void*,bool)",misc\objres.c,"void vlc_objres_remove(vlc_object_t *obj, void *data,
                       bool (*match)(void *, void *))
{
    struct vlc_res **restrict pp = vlc_obj_res(obj);

    /* With a doubly-linked list, this function could have constant complexity.
     * But that would require one more pointer per resource.
     *
     * Any given list should contain a fairly small number of resources,
     * and in most cases, the resources are destroyed implicitly by
     * vlc_objres_clear().
     */
    for (;;)
    {
        struct vlc_res *res = *pp;

        assert(res != NULL); /* invalid free? */

        if (match(res->payload, data))
        {
            *pp = res->prev;
            res->release(res->payload);
            free(res);
            return;
        }

        pp = &res->prev;
    }
}",96.0,124.0,1.0,1.0,29.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
2488,87964,libvlc_priv,1,libvlc_priv,libvlc_priv_t libvlc_priv (libvlc_int_t*),libvlc.h,"static inline libvlc_priv_t *libvlc_priv (libvlc_int_t *libvlc)
{
    return container_of(libvlc, libvlc_priv_t, public_data);
}",199.0,202.0,1.0,1.0,4.0,0,0,3,3,33,0,1,1,0,0,,0,0,2,1,1,libvlc_priv_t
2489,87997,var_OptionParse,1,var_OptionParse,"void var_OptionParse (vlc_object_t*,char*,bool)",misc\variables.c,"void var_OptionParse( vlc_object_t *p_obj, const char *psz_option,
                      bool trusted )
{
    char *psz_name, *psz_value;
    int  i_type;
    bool b_isno = false;
    vlc_value_t val;

    val.psz_string = NULL;

    /* It's too much of a hassle to remove the ':' when we parse
     * the cmd line :) */
    if( psz_option[0] == ':' )
        psz_option++;

    if( !psz_option[0] )
        return;

    psz_name = strdup( psz_option );
    if( psz_name == NULL )
        return;

    psz_value = strchr( psz_name, '=' );
    if( psz_value != NULL )
        *psz_value++ = '\0';

    i_type = config_GetType( psz_name );
    if( !i_type && !psz_value )
    {
        /* check for ""no-foo"" or ""nofoo"" */
        if( !strncmp( psz_name, ""no-"", 3 ) )
        {
            memmove( psz_name, psz_name + 3, strlen(psz_name) + 1 - 3 );
        }
        else if( !strncmp( psz_name, ""no"", 2 ) )
        {
            memmove( psz_name, psz_name + 2, strlen(psz_name) + 1 - 2 );
       ...",1031.0,1119.0,1.0,1.0,89.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
2490,88080,vlc_CPU,1,vlc_CPU,unsigned vlc_CPU (void),misc\cpu.c,"unsigned vlc_CPU (void)
{
/* On Windows and OS/2,
 * initialized from DllMain() and _DLL_InitTerm() respectively, instead */
#if !defined(_WIN32) && !defined(__OS2__)
    static pthread_once_t once = PTHREAD_ONCE_INIT;
    pthread_once (&once, vlc_CPU_init);
#endif
    return cpu_flags;
}",269.0,278.0,1.0,1.0,10.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,unsigned
2491,88396,vlc_getaddrinfo_notify,1,vlc_getaddrinfo_notify,void vlc_getaddrinfo_notify (union sigval),linux\getaddrinfo.c,"static void vlc_getaddrinfo_notify(union sigval val)
{
    vlc_sem_post(val.sival_ptr);
}",34.0,37.0,1.0,1.0,4.0,1,1,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
2492,88405,vlc_getaddrinfo_i11e,1,vlc_getaddrinfo_i11e,"int vlc_getaddrinfo_i11e (char*,unsigned,addrinfo*,addrinfo**)",posix\getaddrinfo.c,"int vlc_getaddrinfo_i11e(const char *name, unsigned port,
                         const struct addrinfo *hints,
                         struct addrinfo **res)
{
    struct vlc_gai_req req =
    {
        .name = name,
        .service = NULL,
        .hints = hints,
    };
    char portbuf[6];
    vlc_thread_t th;

    if (port != 0)
    {
        if ((size_t)snprintf(portbuf, sizeof (portbuf), ""%u"",
                             port) >= sizeof (portbuf))
            return EAI_NONAME;

        req.service = portbuf;
    }

    vlc_sem_init(&req.done, 0);

    if (vlc_clone(&th, vlc_gai_thread, &req, VLC_THREAD_PRIORITY_LOW))
    {
        vlc_sem_destroy(&req.done);
        return EAI_SYSTEM;
    }

    vlc_sem_wait_i11e(&req.done);

    vlc_cancel(th);
    vlc_join(th, NULL);
    vlc_sem_destroy(&req.done);

    *res = req.result;
    return req.error;
}",54.0,92.0,1.0,1.0,39.0,45,10,46,23,3,5,7,8,0,5,,0,0,8,4,4,int
2493,88597,sys_futex,1,sys_futex,"int sys_futex (void*,int,unsigned,timespec*,void*,int)",linux\thread.c,"static int sys_futex(void *addr, int op, unsigned val,
                     const struct timespec *to, void *addr2, int val3)
{
    return syscall(__NR_futex, addr, op, val, to, addr2, val3);
}",50.0,54.0,1.0,1.0,5.0,0,0,7,7,2,0,1,1,0,0,,0,0,12,6,6,int
2494,88616,vlc_futex_wake,1,vlc_futex_wake,"int vlc_futex_wake (void*,int)",linux\thread.c,"static int vlc_futex_wake(void *addr, int nr)
{
    return sys_futex(addr, FUTEX_WAKE_PRIVATE, nr, NULL, NULL, 0);
}",56.0,59.0,1.0,27.0,4.0,0,0,5,4,2,1,1,1,0,1,,0,0,4,2,2,int
2495,88632,vlc_futex_wait,1,vlc_futex_wait,"int vlc_futex_wait (void*,unsigned,timespec*)",linux\thread.c,"static int vlc_futex_wait(void *addr, unsigned val, const struct timespec *to)
{
    return sys_futex(addr, FUTEX_WAIT_PRIVATE, val, to, NULL, 0);
}",61.0,64.0,1.0,27.0,4.0,0,0,5,5,2,1,1,1,0,1,,0,0,6,3,3,int
2496,88649,vlc_addr_signal,1,vlc_addr_signal,void vlc_addr_signal (void*),win32\thread.c,"void vlc_addr_signal(void *addr)
{
    WakeByAddressSingle(addr);
}",447.0,450.0,1.0,1.0,4.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
2497,88657,vlc_addr_broadcast,1,vlc_addr_broadcast,void vlc_addr_broadcast (void*),win32\thread.c,"void vlc_addr_broadcast(void *addr)
{
    WakeByAddressAll(addr);
}",452.0,455.0,1.0,1.0,4.0,0,0,2,2,1,1,1,1,0,1,,0,0,2,1,1,void
2498,88665,vlc_addr_wait,1,vlc_addr_wait,"void vlc_addr_wait (void*,unsigned)",win32\thread.c,"void vlc_addr_wait(void *addr, unsigned val)
{
    WaitOnAddress(addr, &val, sizeof (val), -1);
}",429.0,432.0,1.0,1.0,4.0,0,0,3,3,0,1,1,1,0,1,,0,0,4,2,2,void
2499,88675,vlc_addr_timedwait,1,vlc_addr_timedwait,"bool vlc_addr_timedwait (void*,unsigned,mtime_t)",win32\thread.c,"bool vlc_addr_timedwait(void *addr, unsigned val, mtime_t delay)
{
    delay = (delay + 999) / 1000;

    if (delay > 0x7fffffff)
    {
        WaitOnAddress(addr, &val, sizeof (val), 0x7fffffff);
        return true; /* woke up early, claim spurious wake-up */
    }

    return WaitOnAddress(addr, &val, sizeof (val), delay);
}",434.0,445.0,1.0,1.0,12.0,11,9,12,8,0,1,1,1,0,1,,0,0,6,3,3,bool
2500,89022,keystrcmp,1,keystrcmp,"int keystrcmp (void*,void*)",misc\actions.c,"static int keystrcmp (const void *key, const void *elem)
{
    const char *sa = key, *sb = elem;
    return strcmp (sa, sb);
}",122.0,126.0,1.0,1.0,5.0,2,1,6,4,0,0,1,1,0,0,,0,0,4,2,2,int
2501,89040,utf8_cp,1,utf8_cp,"char* utf8_cp (uint_fast32_t,char*)",misc\actions.c,"static char *utf8_cp (uint_fast32_t cp, char *buf)
{
    if (cp < (1 << 7))
    {
        buf[1] = 0;
        buf[0] = cp;
    }
    else if (cp < (1 << 11))
    {
        buf[2] = 0;
        buf[1] = 0x80 | (cp & 0x3F);
        cp >>= 6;
        buf[0] = 0xC0 | cp;
    }
    else if (cp < (1 << 16))
    {
        buf[3] = 0;
        buf[2] = 0x80 | (cp & 0x3F);
        cp >>= 6;
        buf[1] = 0x80 | (cp & 0x3F);
        cp >>= 6;
        buf[0] = 0xE0 | cp;
    }
    else if (cp < (1 << 21))
    {
        buf[4] = 0;
        buf[3] = 0x80 | (cp & 0x3F);
        cp >>= 6;
        buf[2] = 0x80 | (cp & 0x3F);
        cp >>= 6;
        buf[1] = 0x80 | (cp & 0x3F);
        cp >>= 6;
        buf[0] = 0xE0 | cp;
    }
    else
        return NULL;
    return buf;
}",129.0,166.0,1.0,1.0,38.0,6,4,5,2,1,0,2,2,0,0,,0,0,4,2,2,char*
2502,89204,vlc_str2keycode,1,vlc_str2keycode,uint_fast32_t vlc_str2keycode (char*),misc\actions.c,"uint_fast32_t vlc_str2keycode (const char *name)
{
    uint_fast32_t mods = 0;
    uint32_t code;

    for (;;)
    {
        size_t len = strcspn (name, ""-+"");
        if (len == 0 || name[len] == '\0')
            break;

        if (len == 4 && !strncasecmp (name, ""Ctrl"", 4))
            mods |= KEY_MODIFIER_CTRL;
        if (len == 3 && !strncasecmp (name, ""Alt"", 3))
            mods |= KEY_MODIFIER_ALT;
        if (len == 5 && !strncasecmp (name, ""Shift"", 5))
            mods |= KEY_MODIFIER_SHIFT;
        if (len == 4 && !strncasecmp (name, ""Meta"", 4))
            mods |= KEY_MODIFIER_META;
        if (len == 7 && !strncasecmp (name, ""Command"", 7))
            mods |= KEY_MODIFIER_COMMAND;

        name += len + 1;
    }

    struct key_descriptor *d = bsearch (name, s_keys, KEYS_COUNT,
                                        sizeof (s_keys[0]), keystrcmp);
    if (d != NULL)
        code = d->i_code;
    else
    if (vlc_towc (name, &code) <= 0)
        code = KEY_UNSET;

   ...",175.0,211.0,1.0,54.0,37.0,34,12,43,13,2,5,11,16,0,0,,0,5,2,1,1,uint_fast32_t
2503,89363,nooptext,1,nooptext,char* nooptext (char*),misc\actions.c,"static char *nooptext (const char *txt)
{
    return (char *)txt;
}",213.0,216.0,1.0,1.0,4.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,char*
2504,89372,vlc_keycode2str,1,vlc_keycode2str,"char* vlc_keycode2str (uint_fast32_t,bool)",misc\actions.c,"char *vlc_keycode2str (uint_fast32_t code, bool locale)
{
    char *(*tr) (const char *) = locale ? vlc_gettext : nooptext;
    const char *name;
    char *str, buf[5];
    uintptr_t key = code & ~KEY_MODIFIER;

    for (size_t i = 0; i < KEYS_COUNT; i++)
        if (s_keys[i].i_code == key)
        {
            name = s_keys[i].psz;
            goto found;
        }

    if (utf8_cp (key, buf) == NULL)
        return NULL;
    name = buf;

found:
    if (asprintf (&str, ""%s%s%s%s%s%s"",
                  (code & KEY_MODIFIER_CTRL) ? tr(N_(""Ctrl+"")) : """",
                  (code & KEY_MODIFIER_ALT) ? tr(N_(""Alt+"")) : """",
                  (code & KEY_MODIFIER_SHIFT) ? tr(N_(""Shift+"")) : """",
                  (code & KEY_MODIFIER_META) ? tr(N_(""Meta+"")) : """",
                  (code & KEY_MODIFIER_COMMAND) ? tr(N_(""Command+"")) : """",
                  tr(name)) == -1)
        return NULL;
    return str;
}",226.0,254.0,1.0,27.0,29.0,24,11,27,14,0,3,4,4,3,1,,0,3,4,2,2,char*
2505,89376,tr,1,vlc_keycode2str.tr,char* vlc_keycode2str.tr (char*),misc\actions.c,char *(*tr) (const char *) = locale ? vlc_gettext : nooptext;,228.0,228.0,10.0,64.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,char*
2506,89848,keycmp,1,keycmp,"int keycmp (void*,void*)",misc\actions.c,"static int keycmp (const void *a, const void *b)
{
    const struct mapping *ka = a, *kb = b;

    return (ka->key < kb->key) ? -1 : (ka->key > kb->key) ? +1 : 0;
}",387.0,392.0,1.0,1.0,6.0,12,7,8,4,0,4,1,1,0,0,,0,4,4,2,2,int
2507,89893,vlc_key_to_action,1,vlc_key_to_action,"int vlc_key_to_action (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",misc\actions.c,"static int vlc_key_to_action (vlc_object_t *obj, const char *varname,
                              vlc_value_t prevkey, vlc_value_t curkey, void *d)
{
    void *const *map = d;
    const struct mapping **pent;
    uint32_t keycode = curkey.i_int;

    pent = tfind (&keycode, map, keycmp);
    if (pent == NULL)
        return VLC_SUCCESS;

    (void) varname;
    (void) prevkey;
    return var_SetInteger (obj, ""key-action"", (*pent)->action);
}",401.0,415.0,1.0,1.0,15.0,10,7,14,10,0,0,2,2,0,0,,0,0,10,5,5,int
2508,89941,add_mapping,1,add_mapping,"int add_mapping (void**,uint32_t,vlc_action_id_t)",misc\actions.c,"static int add_mapping (void **map, uint32_t keycode, vlc_action_id_t action)
{
    struct mapping *entry = malloc (sizeof (*entry));
    if (entry == NULL)
        return ENOMEM;
    entry->key = keycode;
    entry->action = action;

    struct mapping **pent = tsearch (entry, map, keycmp);
    if (unlikely(pent == NULL))
        return ENOMEM;
    if (*pent != entry)
    {
        free (entry);
        return EEXIST;
    }
    return 0;
}",420.0,437.0,1.0,1.0,18.0,12,6,19,8,3,2,4,4,0,0,,0,2,6,3,3,int
2509,89999,add_wheel_mapping,1,add_wheel_mapping,"void add_wheel_mapping (void**,uint32_t,uint32_t,int)",misc\actions.c,"static void add_wheel_mapping (void **map, uint32_t kmore, uint32_t kless,
                                 int mode)
{
    vlc_action_id_t amore = ACTIONID_NONE, aless = ACTIONID_NONE;

    switch (mode)
    {
        case 0: /* volume up/down */
            amore = ACTIONID_COMBO_VOL_FOV_UP;
            aless = ACTIONID_COMBO_VOL_FOV_DOWN;
            break;
        case 2: /* position latter/earlier */
            amore = ACTIONID_JUMP_FORWARD_EXTRASHORT;
            aless = ACTIONID_JUMP_BACKWARD_EXTRASHORT;
            break;
        case 3: /* position earlier/latter */
            amore = ACTIONID_JUMP_BACKWARD_EXTRASHORT;
            aless = ACTIONID_JUMP_FORWARD_EXTRASHORT;
            break;
    }

    if (amore != ACTIONID_NONE)
        add_mapping (map, kmore, amore);
    if (aless != ACTIONID_NONE)
        add_mapping (map, kless, aless);
}",439.0,464.0,1.0,1.0,26.0,10,2,27,11,2,2,7,4,0,2,,0,0,8,4,4,void
2510,90063,init_action,1,init_action,"void init_action (vlc_object_t*,void**,char*,vlc_action_id_t)",misc\actions.c,"static void init_action (vlc_object_t *obj, void **map,
                            const char *confname, vlc_action_id_t action)
{
    char *keys = var_InheritString (obj, confname);
    if (keys == NULL)
        return;

    for (char *buf, *key = strtok_r (keys, ""\t"", &buf);
         key != NULL;
         key = strtok_r (NULL, ""\t"", &buf))
    {
        uint32_t code = vlc_str2keycode (key);
        if (code == KEY_UNSET)
        {
            msg_Warn (obj, ""Key \""%s\"" unrecognized"", key);
            continue;
        }

        if (add_mapping (map, code, action) == EEXIST)
            msg_Warn (obj, ""Key \""%s\"" bound to multiple actions"", key);
    }
    free (keys);
}",473.0,495.0,1.0,1.0,23.0,8,4,23,11,2,2,6,7,1,2,,0,2,8,4,4,void
2511,90134,libvlc_InternalActionsInit,1,libvlc_InternalActionsInit,int libvlc_InternalActionsInit (libvlc_int_t*),misc\actions.c,"int libvlc_InternalActionsInit (libvlc_int_t *libvlc)
{
    assert(libvlc != NULL);

    vlc_object_t *obj = VLC_OBJECT(libvlc);
    vlc_actions_t *as = malloc (sizeof (*as) + (1 + ACTIONS_COUNT)
                      * sizeof (*as->ppsz_keys));

    if (unlikely(as == NULL))
        return VLC_ENOMEM;
    as->map = NULL;
    as->global_map = NULL;

    var_Create (obj, ""key-pressed"", VLC_VAR_INTEGER);
    var_Create (obj, ""global-key-pressed"", VLC_VAR_INTEGER);
    var_Create (obj, ""key-action"", VLC_VAR_INTEGER);

    /* Initialize from configuration */
    for (size_t i = 0; i < ACTIONS_COUNT; i++)
    {
#ifndef NDEBUG
        if (i > 0
         && strcmp (s_names2actions[i-1].psz, s_names2actions[i].psz) >= 0)
        {
            msg_Err (libvlc, ""key-%s and key-%s are not ordered properly"",
                     s_names2actions[i-1].psz, s_names2actions[i].psz);
            abort ();
        }
#endif
        as->ppsz_keys[i] = s_names2actions[i].psz;

        char name[12 + MAX...",500.0,550.0,1.0,52.0,51.0,73,17,73,14,1,35,4,5,4,10,,0,25,2,1,1,int
2512,90367,libvlc_InternalActionsClean,1,libvlc_InternalActionsClean,void libvlc_InternalActionsClean (libvlc_int_t*),misc\actions.c,"void libvlc_InternalActionsClean (libvlc_int_t *libvlc)
{
    assert(libvlc != NULL);

    vlc_actions_t *as = libvlc_priv(libvlc)->actions;
    if (unlikely(as == NULL))
        return;

    var_DelCallback (libvlc, ""global-key-pressed"", vlc_key_to_action,
                     &as->global_map);
    var_DelCallback (libvlc, ""key-pressed"", vlc_key_to_action, &as->map);

    tdestroy (as->global_map, free);
    tdestroy (as->map, free);
    free (as);
    libvlc_priv(libvlc)->actions = NULL;
}",555.0,571.0,1.0,1.0,17.0,12,5,17,4,1,8,2,2,0,4,,0,5,2,1,1,void
2513,90424,actcmp,1,actcmp,"int actcmp (void*,void*)",misc\actions.c,"static int actcmp(const void *key, const void *ent)
{
    const struct name2action *act = ent;
    return strcmp(key, act->psz);
}",574.0,578.0,1.0,1.0,5.0,2,2,4,3,0,1,1,1,0,0,,0,1,4,2,2,int
2514,90440,vlc_actions_get_id,1,vlc_actions_get_id,vlc_action_id_t vlc_actions_get_id (char*),misc\actions.c,"vlc_action_id_t
vlc_actions_get_id (const char *name)
{
    const struct name2action *act;

    if (strncmp (name, ""key-"", 4))
        return ACTIONID_NONE;
    name += 4;

    act = bsearch(name, s_names2actions, ACTIONS_COUNT, sizeof(*act), actcmp);
    return (act != NULL) ? act->id : ACTIONID_NONE;
}",584.0,595.0,1.0,41.0,12.0,11,9,13,5,0,4,2,2,0,0,,0,4,2,1,1,vlc_action_id_t
2515,90484,vlc_actions_get_keycodes,1,vlc_actions_get_keycodes,"size_t vlc_actions_get_keycodes (vlc_object_t*,char*,bool,uint_fast32_t**)",misc\actions.c,"size_t
vlc_actions_get_keycodes(vlc_object_t *p_obj, const char *psz_key_name,
                        bool b_global, uint_fast32_t **pp_keycodes)
{
    char varname[12 /* ""global-key-"" */ + strlen( psz_key_name )];
    sprintf( varname, ""%skey-%s"", b_global ? ""global-"" : """", psz_key_name );

    *pp_keycodes = NULL;

    char *psz_keys = var_InheritString( p_obj, varname );
    if( psz_keys == NULL )
        return 0;

    size_t i_nb_keycodes = 0;
    for( const char* psz_it = psz_keys; *psz_it; ++psz_it )
    {
        if( *psz_it == '\t' )
            ++i_nb_keycodes;
    }
    ++i_nb_keycodes;
    *pp_keycodes = vlc_alloc( i_nb_keycodes, sizeof( **pp_keycodes ) );
    if( unlikely( !*pp_keycodes ) )
    {
        free( psz_keys );
        return 0;
    }
    size_t i = 0;
    for( char *buf, *key = strtok_r( psz_keys, ""\t"", &buf );
         key != NULL;
         key = strtok_r( NULL, ""\t"", &buf ), ++i )
    {
        (*pp_keycodes)[i] = vlc_str2keycode( key );
    }
    assert(...",598.0,634.0,1.0,1.0,37.0,27,10,35,12,0,1,6,7,0,1,,0,1,8,4,4,size_t
2516,90606,vlc_actions_get_key_names,1,vlc_actions_get_key_names,const char* const* vlc_actions_get_key_names (vlc_object_t*),misc\actions.c,"const char* const*
vlc_actions_get_key_names(vlc_object_t *p_obj)
{
    vlc_actions_t *as = libvlc_priv(p_obj->obj.libvlc)->actions;
    return as->ppsz_keys;
}",637.0,642.0,1.0,1.0,6.0,5,3,3,2,0,2,1,1,0,1,,0,2,2,1,1,const char* const*
2517,90659,,1,addons_manager_private_t.finder.,DECL_ARRAY addons_manager_private_t.finder. (char*),misc\addons.c,DECL_ARRAY(char*),55.0,55.0,19.0,25.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,DECL_ARRAY
2518,90680,,1,addons_manager_private_t.installer.,DECL_ARRAY addons_manager_private_t.installer. (addon_entry_t*),misc\addons.c,DECL_ARRAY(addon_entry_t*),66.0,66.0,19.0,34.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,DECL_ARRAY
2519,90688,FinderThread,1,FinderThread,void* FinderThread (void*),misc\addons.c,"static void *FinderThread( void *p_data )
{
    addons_manager_t *p_manager = p_data;
    int i_cancel = vlc_savecancel();
    vlc_interrupt_set( p_manager->p_priv->finder.p_interrupt );

    vlc_mutex_lock( &p_manager->p_priv->finder.lock );
    while( p_manager->p_priv->finder.b_live )
    {
        char *psz_uri;

        vlc_interrupt_register( finder_thread_interrupted, p_data );
        while( p_manager->p_priv->finder.uris.i_size == 0 &&
               p_manager->p_priv->finder.b_live )
        {
            vlc_cond_wait( &p_manager->p_priv->finder.waitcond,
                           &p_manager->p_priv->finder.lock );
        }
        vlc_interrupt_unregister();
        if( !p_manager->p_priv->finder.b_live )
            break;
        psz_uri = p_manager->p_priv->finder.uris.p_elems[0];
        ARRAY_REMOVE( p_manager->p_priv->finder.uris, 0 );

        vlc_mutex_unlock( &p_manager->p_priv->finder.lock );

        addons_finder_t *p_finder =
                vlc_custom_cre...",329.0,384.0,1.0,16.0,56.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void*
2520,90693,LoadLocalStorage,1,LoadLocalStorage,void LoadLocalStorage (addons_manager_t*),misc\addons.c,"static void LoadLocalStorage( addons_manager_t *p_manager )
{
    addons_finder_t *p_finder =
        vlc_custom_create( p_manager->p_priv->p_parent, sizeof( *p_finder ), ""entries finder"" );
    p_finder->obj.flags |= OBJECT_FLAGS_NOINTERACT;

    module_t *p_module = module_need( p_finder, ""addons finder"",
                                      ""addons.store.list"", true );
    if( p_module )
    {
        ARRAY_INIT( p_finder->entries );
        p_finder->psz_uri = NULL;
        p_finder->pf_find( p_finder );
        module_unneed( p_finder, p_module );

        MergeSources( p_manager, p_finder->entries.p_elems, p_finder->entries.i_size );

        ARRAY_RESET( p_finder->entries );
    }
    vlc_object_release( p_finder );
}",298.0,318.0,1.0,8.0,21.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
2521,90698,addon_entry_New,1,addon_entry_New,addon_entry_t addon_entry_New (void),misc\addons.c,"addon_entry_t * addon_entry_New(void)
{
    addon_entry_owner_t *owner = calloc( 1, sizeof(addon_entry_owner_t) );
    if( unlikely(owner == NULL) )
        return NULL;

    atomic_init( &owner->refs, 1 );

    addon_entry_t *p_entry = &owner->entry;
    vlc_mutex_init( &p_entry->lock );
    ARRAY_INIT( p_entry->files );
    return p_entry;
}",77.0,89.0,1.0,1.0,13.0,11,5,11,4,0,1,2,2,0,1,,0,0,2,1,1,addon_entry_t
2522,90742,addon_entry_Hold,1,addon_entry_Hold,addon_entry_t addon_entry_Hold (addon_entry_t*),misc\addons.c,"addon_entry_t * addon_entry_Hold( addon_entry_t * p_entry )
{
    addon_entry_owner_t *owner = (addon_entry_owner_t *) p_entry;

    atomic_fetch_add( &owner->refs, 1 );
    return p_entry;
}",91.0,97.0,1.0,1.0,7.0,4,4,4,2,2,0,1,1,0,0,,0,0,2,1,1,addon_entry_t
2523,90761,addon_entry_Release,1,addon_entry_Release,void addon_entry_Release (addon_entry_t*),misc\addons.c,"void addon_entry_Release( addon_entry_t * p_entry )
{
    addon_entry_owner_t *owner = (addon_entry_owner_t *) p_entry;

    if( atomic_fetch_sub(&owner->refs, 1) != 1 )
        return;

    free( p_entry->psz_name );
    free( p_entry->psz_summary );
    free( p_entry->psz_description );
    free( p_entry->psz_archive_uri );
    free( p_entry->psz_author );
    free( p_entry->psz_source_uri );
    free( p_entry->psz_image_uri );
    free( p_entry->psz_image_data );
    free( p_entry->psz_source_module );
    free( p_entry->psz_version );
    free( p_entry->p_custom );

    addon_file_t *p_file;
    FOREACH_ARRAY( p_file, p_entry->files )
    free( p_file->psz_filename );
    free( p_file->psz_download_uri );
    free( p_file );
    FOREACH_END()
    ARRAY_RESET( p_entry->files );

    vlc_mutex_destroy( &p_entry->lock );
    free( owner );
}",99.0,128.0,1.0,1.0,30.0,22,5,22,3,4,1,2,2,0,1,,0,0,2,1,1,void
2524,90857,addons_manager_New,1,addons_manager_New,"addons_manager_t addons_manager_New (vlc_object_t*,addons_manager_owner*)",misc\addons.c,"addons_manager_t *addons_manager_New( vlc_object_t *p_this,
    const struct addons_manager_owner *restrict owner )
{
    addons_manager_t *p_manager = malloc( sizeof(addons_manager_t) );
    if ( !p_manager ) return NULL;

    p_manager->p_priv = malloc( sizeof(addons_manager_private_t) );
    if ( !p_manager->p_priv )
    {
        free( p_manager );
        return NULL;
    }

    p_manager->owner = *owner;
    p_manager->p_priv->p_parent = p_this;

    p_manager->p_priv->finder.p_interrupt = vlc_interrupt_create();
    p_manager->p_priv->installer.p_interrupt = vlc_interrupt_create();
    if ( !p_manager->p_priv->finder.p_interrupt ||
         !p_manager->p_priv->installer.p_interrupt )
    {
        if( p_manager->p_priv->finder.p_interrupt )
            vlc_interrupt_destroy( p_manager->p_priv->finder.p_interrupt );
        if( p_manager->p_priv->installer.p_interrupt )
            vlc_interrupt_destroy( p_manager->p_priv->installer.p_interrupt );
        free( p_manager->p_pr...",130.0,171.0,1.0,4.0,42.0,77,8,36,7,0,8,6,8,0,8,,0,2,4,2,2,addons_manager_t
2525,91068,addons_manager_Delete,1,addons_manager_Delete,void addons_manager_Delete (addons_manager_t*),misc\addons.c,"void addons_manager_Delete( addons_manager_t *p_manager )
{
    bool b_live;

    vlc_mutex_lock( &p_manager->p_priv->finder.lock );
    b_live = p_manager->p_priv->finder.b_live;
    vlc_mutex_unlock( &p_manager->p_priv->finder.lock );
    if ( b_live )
    {
        vlc_interrupt_kill( p_manager->p_priv->finder.p_interrupt );
        vlc_join( p_manager->p_priv->finder.thread, NULL );
    }

    vlc_mutex_lock( &p_manager->p_priv->installer.lock );
    b_live = p_manager->p_priv->installer.b_live;
    vlc_mutex_unlock( &p_manager->p_priv->installer.lock );
    if ( b_live )
    {
        vlc_interrupt_kill( p_manager->p_priv->installer.p_interrupt );
        vlc_join( p_manager->p_priv->installer.thread, NULL );
    }

#define FREE_QUEUE( name ) \
    FOREACH_ARRAY( addon_entry_t *p_entry, p_manager->p_priv->name.entries )\
        addon_entry_Release( p_entry );\
    FOREACH_END();\
    ARRAY_RESET( p_manager->p_priv->name.entries );\
    vlc_mutex_destroy( &p_manager->p_priv->na...",173.0,213.0,1.0,4.0,41.0,76,5,35,5,0,16,3,3,0,16,,0,0,2,1,1,void
2526,91286,addons_manager_Gather,1,addons_manager_Gather,"void addons_manager_Gather (addons_manager_t*,char*)",misc\addons.c,"void addons_manager_Gather( addons_manager_t *p_manager, const char *psz_uri )
{
    if ( !psz_uri )
        return;

    vlc_mutex_lock( &p_manager->p_priv->finder.lock );

    ARRAY_APPEND( p_manager->p_priv->finder.uris, strdup( psz_uri ) );

    if( !p_manager->p_priv->finder.b_live )
    {
        if( vlc_clone( &p_manager->p_priv->finder.thread, FinderThread, p_manager,
                       VLC_THREAD_PRIORITY_LOW ) )
        {
            msg_Err( p_manager->p_priv->p_parent,
                     ""cannot spawn entries provider thread"" );
            vlc_mutex_unlock( &p_manager->p_priv->finder.lock );
            return;
        }
        p_manager->p_priv->finder.b_live = true;
    }

    vlc_mutex_unlock( &p_manager->p_priv->finder.lock );
    vlc_cond_signal( &p_manager->p_priv->finder.waitcond );
}",215.0,239.0,1.0,1.0,25.0,34,5,15,5,0,5,4,5,1,5,,0,1,4,2,2,void
2527,91384,getHeldEntryByUUID,1,getHeldEntryByUUID,"addon_entry_t getHeldEntryByUUID (addons_manager_t*,addon_uuid_t)",misc\addons.c,"static addon_entry_t * getHeldEntryByUUID( addons_manager_t *p_manager,
                                           const addon_uuid_t uuid )
{
    addon_entry_t *p_return = NULL;
    vlc_mutex_lock( &p_manager->p_priv->finder.lock );
    FOREACH_ARRAY( addon_entry_t *p_entry, p_manager->p_priv->finder.entries )
    if ( !memcmp( p_entry->uuid, uuid, sizeof( addon_uuid_t ) ) )
    {
        p_return = p_entry;
        addon_entry_Hold( p_return );
        break;
    }
    FOREACH_END()
    vlc_mutex_unlock( &p_manager->p_priv->finder.lock );
    return p_return;
}",245.0,260.0,1.0,1.0,16.0,17,7,14,7,2,3,3,2,0,3,,0,0,4,2,2,addon_entry_t
2528,91444,MergeSources,1,MergeSources,"void MergeSources (addons_manager_t*,addon_entry_t**,int)",misc\addons.c,"static void MergeSources( addons_manager_t *p_manager,
                          addon_entry_t **pp_addons, int i_count )
{
    addon_entry_t *p_entry, *p_manager_entry;
    addon_uuid_t zerouuid;
    memset( zerouuid, 0, sizeof( addon_uuid_t ) );
    for ( int i=0; i < i_count; i++ )
    {
        p_entry = pp_addons[i];
        vlc_mutex_lock( &p_entry->lock );
        if ( memcmp( p_entry->uuid, zerouuid, sizeof( addon_uuid_t ) ) )
            p_manager_entry = getHeldEntryByUUID( p_manager, p_entry->uuid );
        else
            p_manager_entry = NULL;
        if ( !p_manager_entry )
        {
            ARRAY_APPEND( p_manager->p_priv->finder.entries, p_entry );
            p_manager->owner.addon_found( p_manager, p_entry );
        }
        else
        {
            vlc_mutex_lock( &p_manager_entry->lock );
            if ( ( p_manager_entry->psz_version && p_entry->psz_version )
                 && /* FIXME: better version comparison */
                 strcmp( p_manage...",262.0,296.0,1.0,1.0,35.0,19,8,22,8,0,3,4,6,0,3,,0,1,6,3,3,void
2529,91643,finder_thread_interrupted,1,finder_thread_interrupted,void finder_thread_interrupted (void*),misc\addons.c,"static void finder_thread_interrupted( void* p_data )
{
    addons_manager_t *p_manager = p_data;
    vlc_mutex_lock( &p_manager->p_priv->finder.lock );
    p_manager->p_priv->finder.b_live = false;
    vlc_cond_signal( &p_manager->p_priv->finder.waitcond );
    vlc_mutex_unlock( &p_manager->p_priv->finder.lock );
}",320.0,327.0,1.0,1.0,8.0,17,4,7,3,0,3,1,1,0,3,,0,0,2,1,1,void
2530,91922,addons_manager_WriteCatalog,1,addons_manager_WriteCatalog,int addons_manager_WriteCatalog (addons_manager_t*),misc\addons.c,"static int addons_manager_WriteCatalog( addons_manager_t *p_manager )
{
    int i_return = VLC_EGENERIC;

    addons_storage_t *p_storage =
        vlc_custom_create( p_manager->p_priv->p_parent, sizeof( *p_storage ), ""entries storage"" );
    p_storage->obj.flags |= OBJECT_FLAGS_NOINTERACT;

    module_t *p_module = module_need( p_storage, ""addons storage"",
                                      ""addons.store.install"", true );
    if( p_module )
    {
        vlc_mutex_lock( &p_manager->p_priv->finder.lock );
        i_return = p_storage->pf_catalog( p_storage, p_manager->p_priv->finder.entries.p_elems,
                                          p_manager->p_priv->finder.entries.i_size );
        vlc_mutex_unlock( &p_manager->p_priv->finder.lock );
        module_unneed( p_storage, p_module );
    }
    vlc_object_release( p_storage );

    return i_return;
}",386.0,407.0,1.0,8.0,22.0,29,6,23,7,1,6,2,2,0,6,,0,2,2,1,1,int
2531,92020,addons_manager_LoadCatalog,1,addons_manager_LoadCatalog,int addons_manager_LoadCatalog (addons_manager_t*),misc\addons.c,"int addons_manager_LoadCatalog( addons_manager_t *p_manager )
{
    LoadLocalStorage( p_manager );
    return VLC_SUCCESS;
}",409.0,413.0,1.0,1.0,5.0,0,0,2,2,0,1,1,1,0,1,,0,0,2,1,1,int
2532,92029,installOrRemoveAddon,1,installOrRemoveAddon,"int installOrRemoveAddon (addons_manager_t*,addon_entry_t*,bool)",misc\addons.c,"static int installOrRemoveAddon( addons_manager_t *p_manager, addon_entry_t *p_entry, bool b_install )
{
    int i_return = VLC_EGENERIC;

    addons_storage_t *p_storage =
        vlc_custom_create( p_manager->p_priv->p_parent, sizeof( *p_storage ), ""entries storage"" );
    p_storage->obj.flags |= OBJECT_FLAGS_NOINTERACT;

    module_t *p_module = module_need( p_storage, ""addons storage"",
                                      ""addons.store.install"", true );
    if( p_module )
    {
        if ( b_install )
            i_return = p_storage->pf_install( p_storage, p_entry );
        else
            i_return = p_storage->pf_remove( p_storage, p_entry );
        module_unneed( p_storage, p_module );
        msg_Dbg( p_manager->p_priv->p_parent, ""InstallAddon returns %d"", i_return );
        if ( i_return == VLC_SUCCESS )
        {
            /* Reset flags */
            vlc_mutex_lock( &p_entry->lock );
            p_entry->e_flags = ADDON_MANAGEABLE;
            vlc_mutex_unlock( &...",415.0,444.0,1.0,8.0,30.0,22,7,29,11,1,6,4,6,0,6,,0,2,6,3,3,int
2533,92135,installer_thread_interrupted,1,installer_thread_interrupted,void installer_thread_interrupted (void*),misc\addons.c,"static void installer_thread_interrupted( void* p_data )
{
    addons_manager_t *p_manager = p_data;
    vlc_mutex_lock( &p_manager->p_priv->installer.lock );
    p_manager->p_priv->installer.b_live = false;
    vlc_cond_signal( &p_manager->p_priv->installer.waitcond );
    vlc_mutex_unlock( &p_manager->p_priv->installer.lock );
}",446.0,453.0,1.0,1.0,8.0,17,4,7,3,0,3,1,1,0,3,,0,0,2,1,1,void
2534,92180,InstallerThread,1,InstallerThread,void* InstallerThread (void*),misc\addons.c,"static void *InstallerThread( void *p_data )
{
    addons_manager_t *p_manager = p_data;
    int i_cancel = vlc_savecancel();
    vlc_interrupt_set( p_manager->p_priv->installer.p_interrupt );
    int i_ret;

    vlc_mutex_lock( &p_manager->p_priv->installer.lock );
    while( p_manager->p_priv->installer.b_live )
    {
        vlc_interrupt_register( installer_thread_interrupted, p_data );
        while ( !p_manager->p_priv->installer.entries.i_size &&
                p_manager->p_priv->installer.b_live )
        {
            /* No queued addons */
            vlc_cond_wait( &p_manager->p_priv->installer.waitcond,
                           &p_manager->p_priv->installer.lock );
        }
        vlc_interrupt_unregister();
        if( !p_manager->p_priv->installer.b_live )
            break;

        addon_entry_t *p_entry = p_manager->p_priv->installer.entries.p_elems[0];
        ARRAY_REMOVE( p_manager->p_priv->installer.entries, 0 );
        addon_entry_Hold( p_entry );
       ...",455.0,525.0,1.0,1.0,71.0,75,9,46,11,0,18,6,8,0,18,,0,2,2,1,1,void*
2535,92444,InstallEntry,1,InstallEntry,"int InstallEntry (addons_manager_t*,addon_entry_t*)",misc\addons.c,"static int InstallEntry( addons_manager_t *p_manager, addon_entry_t *p_entry )
{
    if ( p_entry->e_type == ADDON_UNKNOWN ||
         p_entry->e_type == ADDON_PLUGIN ||
         p_entry->e_type == ADDON_OTHER )
        return VLC_EBADVAR;

    vlc_mutex_lock( &p_manager->p_priv->installer.lock );
    ARRAY_APPEND( p_manager->p_priv->installer.entries, p_entry );
    if( !p_manager->p_priv->installer.b_live )
    {
        if( vlc_clone( &p_manager->p_priv->installer.thread, InstallerThread, p_manager,
                       VLC_THREAD_PRIORITY_LOW ) )
        {
            msg_Err( p_manager->p_priv->p_parent,
                     ""cannot spawn addons installer thread"" );
            vlc_mutex_unlock( &p_manager->p_priv->installer.lock );
            return VLC_EGENERIC;
        }
        else
            p_manager->p_priv->installer.b_live = true;
    }
    vlc_mutex_unlock( &p_manager->p_priv->installer.lock );
    vlc_cond_signal( &p_manager->p_priv->installer.waitcond );
    re...",527.0,552.0,1.0,1.0,26.0,37,6,20,9,1,5,4,5,1,5,,0,1,4,2,2,int
2536,92562,addons_manager_Install,1,addons_manager_Install,"int addons_manager_Install (addons_manager_t*,addon_uuid_t)",misc\addons.c,"int addons_manager_Install( addons_manager_t *p_manager, const addon_uuid_t uuid )
{
    addon_entry_t *p_install_entry = getHeldEntryByUUID( p_manager, uuid );
    if ( ! p_install_entry ) return VLC_EGENERIC;
    int i_ret = InstallEntry( p_manager, p_install_entry );
    addon_entry_Release( p_install_entry );
    return i_ret;
}",554.0,561.0,1.0,1.0,8.0,3,2,10,5,1,3,2,2,0,3,,0,2,4,2,2,int
2537,92590,addons_manager_Remove,1,addons_manager_Remove,"int addons_manager_Remove (addons_manager_t*,addon_uuid_t)",misc\addons.c,"int addons_manager_Remove( addons_manager_t *p_manager, const addon_uuid_t uuid )
{
    return addons_manager_Install( p_manager, uuid );
}",563.0,566.0,1.0,1.0,4.0,0,0,2,2,0,1,1,1,0,1,,0,0,4,2,2,int
2538,92640,Thread,1,Thread,void* Thread (void*),video_output\video_output.c,"static void *Thread(void *object)
{
    vout_thread_t *vout = object;
    vout_thread_sys_t *sys = vout->p;

    mtime_t deadline = VLC_TS_INVALID;
    bool wait = false;
    for (;;) {
        vout_control_cmd_t cmd;

        if (wait)
        {
            const mtime_t max_deadline = mdate() + 100000;
            deadline = deadline <= VLC_TS_INVALID ? max_deadline : __MIN(deadline, max_deadline);
        } else {
            deadline = VLC_TS_INVALID;
        }
        while (!vout_control_Pop(&sys->control, &cmd, deadline))
            if (ThreadControl(vout, cmd))
                return NULL;

        deadline = VLC_TS_INVALID;
        wait = ThreadDisplayPicture(vout, &deadline) != VLC_SUCCESS;

        const bool picture_interlaced = sys->displayed.is_interlaced;

        vout_SetInterlacingState(vout, picture_interlaced);
        vout_ManageWrapper(vout);
    }
}",1789.0,1818.0,1.0,1.0,30.0,94,14,63,8,0,39,16,29,9,17,,0,27,2,1,1,void*
2539,92975,BackgroundWorkerCancel,1,BackgroundWorkerCancel,"void BackgroundWorkerCancel (background_worker*,void*)",misc\background_worker.c,"static void BackgroundWorkerCancel( struct background_worker* worker, void* id)
{
    vlc_mutex_lock( &worker->lock );
    for( size_t i = 0; i < vlc_array_count( &worker->tail.data ); )
    {
        struct bg_queued_item* item =
            vlc_array_item_at_index( &worker->tail.data, i );

        if( id == NULL || item->id == id )
        {
            vlc_array_remove( &worker->tail.data, i );
            worker->conf.pf_release( item->entity );
            free( item );
            continue;
        }

        ++i;
    }

    while( ( id == NULL && worker->head.active )
        || ( id != NULL && worker->head.id == id ) )
    {
        worker->head.deadline = VLC_TS_0;
        vlc_cond_signal( &worker->head.worker_wait );
        vlc_cond_signal( &worker->tail.wait );
        vlc_cond_wait( &worker->head.wait, &worker->lock );
    }
    vlc_mutex_unlock( &worker->lock );
}",154.0,182.0,1.0,1.0,29.0,48,10,31,6,2,12,5,5,1,6,,0,6,4,2,2,void
2540,93106,background_worker_New,1,background_worker_New,"struct background_worker background_worker_New (void*,background_worker_config*)",misc\background_worker.c,"struct background_worker* background_worker_New( void* owner,
    struct background_worker_config* conf )
{
    struct background_worker* worker = malloc( sizeof *worker );

    if( unlikely( !worker ) )
        return NULL;

    worker->conf = *conf;
    worker->owner = owner;
    worker->head.id = NULL;
    worker->head.active = false;
    worker->head.deadline = VLC_TS_INVALID;

    vlc_mutex_init( &worker->lock );
    vlc_cond_init( &worker->head.wait );
    vlc_cond_init( &worker->head.worker_wait );

    vlc_array_init( &worker->tail.data );
    vlc_cond_init( &worker->tail.wait );

    return worker;
}",184.0,206.0,1.0,1.0,23.0,32,7,20,6,2,7,2,2,0,4,,0,3,4,2,2,struct background_worker
2541,93193,background_worker_Push,1,background_worker_Push,"int background_worker_Push (background_worker*,void*,void*,int)",misc\background_worker.c,"int background_worker_Push( struct background_worker* worker, void* entity,
                        void* id, int timeout )
{
    struct bg_queued_item* item = malloc( sizeof( *item ) );

    if( unlikely( !item ) )
        return VLC_EGENERIC;

    item->id = id;
    item->entity = entity;
    item->timeout = timeout < 0 ? worker->conf.default_timeout : timeout;

    vlc_mutex_lock( &worker->lock );
    int i_ret = vlc_array_append( &worker->tail.data, item );
    vlc_cond_signal( &worker->tail.wait );
    if( i_ret != 0 )
    {
        free( item );
        return VLC_EGENERIC;
    }

    if( worker->head.active == false )
    {
        worker->head.probe_request = false;
        worker->head.active =
            !vlc_clone_detach( NULL, Thread, worker, VLC_THREAD_PRIORITY_LOW );
    }

    if( worker->head.active )
        worker->conf.pf_hold( item->entity );

    int ret = worker->head.active ? VLC_SUCCESS : VLC_EGENERIC;
    vlc_mutex_unlock( &worker->lock );

    return ret;
}",208.0,243.0,1.0,1.0,36.0,45,11,37,12,4,13,5,5,0,5,,0,9,8,4,4,int
2542,93333,background_worker_Cancel,1,background_worker_Cancel,"void background_worker_Cancel (background_worker*,void*)",misc\background_worker.c,"void background_worker_Cancel( struct background_worker* worker, void* id )
{
    BackgroundWorkerCancel( worker, id );
}",245.0,248.0,1.0,1.0,4.0,0,0,2,2,2,1,1,1,0,1,,0,0,4,2,2,void
2543,93342,background_worker_RequestProbe,1,background_worker_RequestProbe,void background_worker_RequestProbe (background_worker*),misc\background_worker.c,"void background_worker_RequestProbe( struct background_worker* worker )
{
    vlc_mutex_lock( &worker->lock );
    worker->head.probe_request = true;
    vlc_cond_signal( &worker->head.worker_wait );
    vlc_mutex_unlock( &worker->lock );
}",250.0,256.0,1.0,1.0,7.0,10,4,5,2,1,5,1,1,0,3,,0,2,2,1,1,void
2544,93371,background_worker_Delete,1,background_worker_Delete,void background_worker_Delete (background_worker*),misc\background_worker.c,"void background_worker_Delete( struct background_worker* worker )
{
    BackgroundWorkerCancel( worker, NULL );
    vlc_array_clear( &worker->tail.data );
    vlc_mutex_destroy( &worker->lock );
    vlc_cond_destroy( &worker->head.wait );
    vlc_cond_destroy( &worker->head.worker_wait );
    vlc_cond_destroy( &worker->tail.wait );
    free( worker );
}",258.0,267.0,1.0,1.0,10.0,14,3,8,2,7,6,1,1,0,5,,0,1,2,1,1,void
2545,93421,pf_release,1,background_worker_config.pf_release,void background_worker_config.pf_release (void*),misc\background_worker.h,void( *pf_release )( void* entity );,42.0,42.0,9.0,39.0,1.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,void
2546,93426,pf_hold,1,background_worker_config.pf_hold,void background_worker_config.pf_hold (void*),misc\background_worker.h,void( *pf_hold )( void* entity );,53.0,53.0,9.0,36.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
2547,93431,pf_start,1,background_worker_config.pf_start,"int background_worker_config.pf_start (void*,void*,void**)",misc\background_worker.h,"int( *pf_start )( void* owner, void* entity, void** out );",72.0,72.0,8.0,61.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,int
2548,93438,pf_probe,1,background_worker_config.pf_probe,"int background_worker_config.pf_probe (void*,void*)",misc\background_worker.h,"int( *pf_probe )( void* owner, void* handle );",85.0,85.0,8.0,49.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
2549,93444,pf_stop,1,background_worker_config.pf_stop,"void background_worker_config.pf_stop (void*,void*)",misc\background_worker.h,"void( *pf_stop )( void* owner, void* handle );",101.0,101.0,9.0,49.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
2550,93505,BlockNoRelease,1,BlockNoRelease,void BlockNoRelease (block_t*),misc\block.c,"static void BlockNoRelease( block_t *b )
{
    fprintf( stderr, ""block %p has no release callback! This is a bug!\n"",
             (void *) b );
    abort();
}",39.0,44.0,1.0,1.0,6.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
2551,93517,block_Check,1,block_Check,void block_Check (block_t*),misc\block.c,"static void block_Check (block_t *block)
{
    while (block != NULL)
    {
        unsigned char *start = block->p_start;
        unsigned char *end = block->p_start + block->i_size;
        unsigned char *bufstart = block->p_buffer;
        unsigned char *bufend = block->p_buffer + block->i_buffer;

        assert (block->pf_release != BlockNoRelease);
        assert (start <= end);
        assert (bufstart <= bufend);
        assert (bufstart >= start);
        assert (bufend <= end);

        block = block->p_next;
    }
}",46.0,63.0,1.0,1.0,18.0,21,6,23,6,2,0,2,2,0,0,,0,0,2,1,1,void
2552,93586,block_Invalidate,1,block_Invalidate,void block_Invalidate (block_t*),misc\block.c,"static void block_Invalidate (block_t *block)
{
    block->p_next = NULL;
    block_Check (block);
    block->pf_release = BlockNoRelease;
}",65.0,70.0,1.0,1.0,6.0,4,2,4,2,2,1,1,1,0,1,,0,0,2,1,1,void
2553,93603,block_Init,1,block_Init,"void block_Init (block_t*,void*,size_t)",misc\block.c,"void block_Init( block_t *restrict b, void *buf, size_t size )
{
    /* Fill all fields to their default */
    b->p_next = NULL;
    b->p_buffer = buf;
    b->i_buffer = size;
    b->p_start = buf;
    b->i_size = size;
    b->i_flags = 0;
    b->i_nb_samples = 0;
    b->i_pts =
    b->i_dts = VLC_TS_INVALID;
    b->i_length = 0;
#ifndef NDEBUG
    b->pf_release = BlockNoRelease;
#endif
}",76.0,92.0,1.0,1.0,17.0,22,2,17,5,2,0,1,1,0,0,,0,0,6,3,3,void
2554,93664,block_generic_Release,1,block_generic_Release,void block_generic_Release (block_t*),misc\block.c,"static void block_generic_Release (block_t *block)
{
    /* That is always true for blocks allocated with block_Alloc(). */
    assert (block->p_start == (unsigned char *)(block + 1));
    block_Invalidate (block);
    free (block);
}",94.0,100.0,1.0,1.0,7.0,4,4,4,1,0,1,1,1,0,1,,0,0,2,1,1,void
2555,93683,BlockMetaCopy,1,BlockMetaCopy,"void BlockMetaCopy (block_t*,block_t*)",misc\block.c,"static void BlockMetaCopy( block_t *restrict out, const block_t *in )
{
    out->p_next    = in->p_next;
    out->i_nb_samples = in->i_nb_samples;
    out->i_dts     = in->i_dts;
    out->i_pts     = in->i_pts;
    out->i_flags   = in->i_flags;
    out->i_length  = in->i_length;
}",102.0,110.0,1.0,1.0,9.0,18,2,12,2,2,0,1,1,0,0,,0,0,4,2,2,void
2556,93731,block_Alloc,1,block_Alloc,block_t block_Alloc (size_t),misc\block.c,"block_t *block_Alloc (size_t size)
{
    if (unlikely(size >> 27))
    {
        errno = ENOBUFS;
        return NULL;
    }

    /* 2 * BLOCK_PADDING: pre + post padding */
    const size_t alloc = sizeof (block_t) + BLOCK_ALIGN + (2 * BLOCK_PADDING)
                       + size;
    if (unlikely(alloc <= size))
        return NULL;

    block_t *b = malloc (alloc);
    if (unlikely(b == NULL))
        return NULL;

    block_Init (b, b + 1, alloc - sizeof (*b));
    static_assert ((BLOCK_PADDING % BLOCK_ALIGN) == 0,
                   ""BLOCK_PADDING must be a multiple of BLOCK_ALIGN"");
    b->p_buffer += BLOCK_PADDING + BLOCK_ALIGN - 1;
    b->p_buffer = (void *)(((uintptr_t)b->p_buffer) & ~(BLOCK_ALIGN - 1));
    b->i_buffer = size;
    b->pf_release = block_generic_Release;
    return b;
}",120.0,146.0,1.0,44.0,27.0,33,15,26,7,8,1,4,4,0,1,,0,0,2,1,1,block_t
2557,93849,block_TryRealloc,1,block_TryRealloc,"block_t block_TryRealloc (block_t*,ssize_t,size_t)",misc\block.c,"block_t *block_TryRealloc (block_t *p_block, ssize_t i_prebody, size_t i_body)
{
    block_Check( p_block );

    /* Corner case: empty block requested */
    if( i_prebody <= 0 && i_body <= (size_t)(-i_prebody) )
        i_prebody = i_body = 0;

    assert( p_block->p_start <= p_block->p_buffer );
    assert( p_block->p_start + p_block->i_size
                                    >= p_block->p_buffer + p_block->i_buffer );

    /* First, shrink payload */

    /* Pull payload start */
    if( i_prebody < 0 )
    {
        if( p_block->i_buffer >= (size_t)-i_prebody )
        {
            p_block->p_buffer -= i_prebody;
            p_block->i_buffer += i_prebody;
        }
        else /* Discard current payload entirely */
            p_block->i_buffer = 0;
        i_body += i_prebody;
        i_prebody = 0;
    }

    /* Trim payload end */
    if( p_block->i_buffer > i_body )
        p_block->i_buffer = i_body;

    size_t requested = i_prebody + i_body;

    if( p_block->i_buffe...",148.0,237.0,1.0,1.0,90.0,77,16,87,10,1,5,11,15,0,5,,0,2,6,3,3,block_t
2558,94110,block_Realloc,1,block_Realloc,"block_t block_Realloc (block_t*,ssize_t,size_t)",misc\block.c,"block_t *block_Realloc (block_t *block, ssize_t prebody, size_t body)
{
    block_t *rea = block_TryRealloc (block, prebody, body);
    if (rea == NULL)
        block_Release(block);
    return rea;
}",239.0,245.0,1.0,1.0,7.0,2,2,8,5,0,1,2,2,0,1,,0,1,6,3,3,block_t
2559,94133,block_heap_Release,1,block_heap_Release,void block_heap_Release (block_t*),misc\block.c,"static void block_heap_Release (block_t *block)
{
    block_Invalidate (block);
    free (block->p_start);
    free (block);
}",247.0,252.0,1.0,1.0,6.0,1,1,3,1,0,1,1,1,0,1,,0,0,2,1,1,void
2560,94146,block_heap_Alloc,1,block_heap_Alloc,"block_t block_heap_Alloc (void*,size_t)",misc\block.c,"block_t *block_heap_Alloc (void *addr, size_t length)
{
    block_t *block = malloc (sizeof (*block));
    if (block == NULL)
    {
        free (addr);
        return NULL;
    }

    block_Init (block, addr, length);
    block->pf_release = block_heap_Release;
    return block;
}",254.0,266.0,1.0,1.0,13.0,6,5,11,4,0,1,2,2,0,1,,0,0,4,2,2,block_t
2561,94179,block_mmap_Alloc,1,block_mmap_Alloc,"block_t block_mmap_Alloc (void*,size_t)",misc\block.c,"block_t *block_mmap_Alloc (void *addr, size_t length)
{
    (void)addr; (void)length; return NULL;
}",301.0,304.0,1.0,1.0,4.0,2,1,3,3,0,0,1,1,0,0,,0,0,4,2,2,block_t
2562,94193,block_shm_Alloc,1,block_shm_Alloc,"block_t block_shm_Alloc (void*,size_t)",misc\block.c,"block_t *block_shm_Alloc (void *addr, size_t length)
{
    (void) addr; (void) length;
    abort ();
}",339.0,343.0,1.0,1.0,5.0,2,1,2,2,0,0,1,1,0,0,,0,0,4,2,2,block_t
2563,94206,block_File,1,block_File,"block_t block_File (int,bool)",misc\block.c,"block_t *block_File(int fd, bool write)
{
    size_t length;
    struct stat st;

    /* First, get the file size */
    if (fstat (fd, &st))
        return NULL;

    /* st_size is meaningful for regular files, shared memory and typed memory.
     * It's also meaning for symlinks, but that's not possible with fstat().
     * In other cases, it's undefined, and we should really not go further. */
#ifndef S_TYPEISSHM
# define S_TYPEISSHM( buf ) (0)
#endif
    if (S_ISDIR (st.st_mode))
    {
        errno = EISDIR;
        return NULL;
    }
    if (!S_ISREG (st.st_mode) && !S_TYPEISSHM (&st))
    {
        errno = ESPIPE;
        return NULL;
    }

    /* Prevent an integer overflow in mmap() and malloc() */
    if ((uintmax_t)st.st_size >= SIZE_MAX)
    {
        errno = ENOMEM;
        return NULL;
    }
    length = (size_t)st.st_size;

#ifdef HAVE_MMAP
    if (length > 0)
    {
        int prot = PROT_READ | (write ? PROT_WRITE : 0);
        int flags = write ? MAP_PRIVATE : MAP...",368.0,433.0,1.0,34.0,66.0,27,14,41,12,1,1,9,9,0,1,,0,1,4,2,2,block_t
2564,94327,block_FilePath,1,block_FilePath,"block_t block_FilePath (char*,bool)",misc\block.c,"block_t *block_FilePath(const char *path, bool write)
{
    /* NOTE: Writeable shared mappings are not supported here. So there are no
     * needs to open the file for writing (even if the mapping is writable). */
    int fd = vlc_open (path, O_RDONLY);
    if (fd == -1)
        return NULL;

    block_t *block = block_File(fd, write);
    vlc_close (fd);
    return block;
}",435.0,446.0,1.0,1.0,12.0,4,3,10,6,0,3,2,2,0,3,,0,2,4,2,2,block_t
2565,94459,vlc_epg_event_Clean,1,vlc_epg_event_Clean,void vlc_epg_event_Clean (vlc_epg_event_t*),misc\epg.c,"static void vlc_epg_event_Clean(vlc_epg_event_t *p_event)
{
    for(int i=0; i<p_event->i_description_items; i++)
    {
        free(p_event->description_items[i].psz_key);
        free(p_event->description_items[i].psz_value);
    }
    free(p_event->description_items);
    free(p_event->psz_description);
    free(p_event->psz_short_description);
    free(p_event->psz_name);
}",35.0,46.0,1.0,1.0,12.0,13,5,11,2,1,0,2,2,0,0,,0,0,2,1,1,void
2566,94510,vlc_epg_event_Delete,1,vlc_epg_event_Delete,void vlc_epg_event_Delete (vlc_epg_event_t*),misc\epg.c,"void vlc_epg_event_Delete(vlc_epg_event_t *p_event)
{
    vlc_epg_event_Clean(p_event);
    free(p_event);
}",48.0,52.0,1.0,1.0,5.0,0,0,2,1,3,1,1,1,0,1,,0,0,2,1,1,void
2567,94519,vlc_epg_event_Init,1,vlc_epg_event_Init,"void vlc_epg_event_Init (vlc_epg_event_t*,uint16_t,int64_t,uint32_t)",misc\epg.c,"static void vlc_epg_event_Init(vlc_epg_event_t *p_event, uint16_t i_id,
                               int64_t i_start, uint32_t i_duration)
{
    memset(p_event, 0, sizeof(*p_event));
    p_event->i_start = i_start;
    p_event->i_id = i_id;
    p_event->i_duration = i_duration;
    p_event->i_description_items = 0;
    p_event->description_items = NULL;
}",54.0,63.0,1.0,1.0,10.0,12,4,11,5,1,0,1,1,0,0,,0,0,8,4,4,void
2568,94558,vlc_epg_event_New,1,vlc_epg_event_New,"vlc_epg_event_t vlc_epg_event_New (uint16_t,int64_t,uint32_t)",misc\epg.c,"vlc_epg_event_t * vlc_epg_event_New(uint16_t i_id,
                                    int64_t i_start, uint32_t i_duration)
{
    vlc_epg_event_t *p_event = (vlc_epg_event_t *) malloc(sizeof(*p_event));
    if(p_event)
        vlc_epg_event_Init(p_event, i_id, i_start, i_duration);

    return p_event;
}",65.0,73.0,1.0,1.0,9.0,4,4,8,4,1,1,2,2,0,1,,0,0,6,3,3,vlc_epg_event_t
2569,94584,vlc_epg_event_Duplicate,1,vlc_epg_event_Duplicate,vlc_epg_event_t vlc_epg_event_Duplicate (vlc_epg_event_t*),misc\epg.c,"vlc_epg_event_t * vlc_epg_event_Duplicate( const vlc_epg_event_t *p_src )
{
    vlc_epg_event_t *p_evt = vlc_epg_event_New( p_src->i_id, p_src->i_start,
                                                p_src->i_duration );
    if( likely(p_evt) )
    {
        if( p_src->psz_description )
            p_evt->psz_description = strdup( p_src->psz_description );
        if( p_src->psz_name )
            p_evt->psz_name = strdup( p_src->psz_name );
        if( p_src->psz_short_description )
            p_evt->psz_short_description = strdup( p_src->psz_short_description );
        if( p_src->i_description_items )
        {
            p_evt->description_items = malloc( sizeof(*p_evt->description_items) *
                                               p_src->i_description_items );
            if( p_evt->description_items )
            {
                for( int i=0; i<p_src->i_description_items; i++ )
                {
                    p_evt->description_items[i].psz_key =
              ...",75.0,113.0,1.0,1.0,39.0,62,11,42,3,3,1,10,22,0,1,,0,1,2,1,1,vlc_epg_event_t
2570,94764,vlc_epg_Init,1,vlc_epg_Init,"void vlc_epg_Init (vlc_epg_t*,uint32_t,uint16_t)",misc\epg.c,"static void vlc_epg_Init( vlc_epg_t *p_epg, uint32_t i_id, uint16_t i_source_id )
{
    p_epg->i_id = i_id;
    p_epg->i_source_id = i_source_id;
    p_epg->psz_name = NULL;
    p_epg->p_current = NULL;
    p_epg->b_present = false;
    TAB_INIT( p_epg->i_event, p_epg->pp_event );
}",115.0,123.0,1.0,1.0,9.0,12,2,12,5,1,0,1,1,0,0,,0,0,6,3,3,void
2571,94803,vlc_epg_Clean,1,vlc_epg_Clean,void vlc_epg_Clean (vlc_epg_t*),misc\epg.c,"static void vlc_epg_Clean( vlc_epg_t *p_epg )
{
    size_t i;
    for( i = 0; i < p_epg->i_event; i++ )
        vlc_epg_event_Delete( p_epg->pp_event[i] );
    TAB_CLEAN( p_epg->i_event, p_epg->pp_event );
    free( p_epg->psz_name );
}",125.0,132.0,1.0,1.0,8.0,6,3,6,2,1,0,2,2,0,0,,0,0,2,1,1,void
2572,94838,vlc_epg_AddEvent,1,vlc_epg_AddEvent,"bool vlc_epg_AddEvent (vlc_epg_t*,vlc_epg_event_t*)",misc\epg.c,"bool vlc_epg_AddEvent( vlc_epg_t *p_epg, vlc_epg_event_t *p_evt )
{
    ssize_t i_pos = -1;

    /* Insertions are supposed in sequential order first */
    if( p_epg->i_event )
    {
        if( p_epg->pp_event[0]->i_start > p_evt->i_start )
        {
            i_pos = 0;
        }
        else if ( p_epg->pp_event[p_epg->i_event - 1]->i_start >= p_evt->i_start )
        {
            /* Do bisect search lower start time entry */
            size_t i_lower = 0;
            size_t i_upper = p_epg->i_event - 1;

            while( i_lower < i_upper )
            {
                size_t i_split = ( i_lower + i_upper ) / 2;
                vlc_epg_event_t *p_cur = p_epg->pp_event[i_split];

                if( p_cur->i_start < p_evt->i_start )
                {
                    i_lower = i_split + 1;
                }
                else if ( p_cur->i_start >= p_evt->i_start )
                {
                    i_upper = i_split;
                }
            }
            i_...",134.0,189.0,1.0,1.0,56.0,27,7,21,4,2,1,6,10,0,1,,0,0,4,2,2,bool
2573,95026,vlc_epg_New,1,vlc_epg_New,"vlc_epg_t vlc_epg_New (uint32_t,uint16_t)",misc\epg.c,"vlc_epg_t *vlc_epg_New( uint32_t i_id, uint16_t i_source_id )
{
    vlc_epg_t *p_epg = malloc( sizeof(*p_epg) );
    if( p_epg )
        vlc_epg_Init( p_epg, i_id, i_source_id );
    return p_epg;
}",191.0,197.0,1.0,1.0,7.0,3,3,7,3,2,1,2,2,0,1,,0,0,4,2,2,vlc_epg_t
2574,95048,vlc_epg_Delete,1,vlc_epg_Delete,void vlc_epg_Delete (vlc_epg_t*),misc\epg.c,"void vlc_epg_Delete( vlc_epg_t *p_epg )
{
    vlc_epg_Clean( p_epg );
    free( p_epg );
}",199.0,203.0,1.0,1.0,5.0,0,0,2,1,3,1,1,1,0,1,,0,0,2,1,1,void
2575,95057,vlc_epg_SetCurrent,1,vlc_epg_SetCurrent,"void vlc_epg_SetCurrent (vlc_epg_t*,int64_t)",misc\epg.c,"void vlc_epg_SetCurrent( vlc_epg_t *p_epg, int64_t i_start )
{
    size_t i;
    p_epg->p_current = NULL;
    if( i_start < 0 )
        return;

    for( i = 0; i < p_epg->i_event; i++ )
    {
        if( p_epg->pp_event[i]->i_start == i_start )
        {
            p_epg->p_current = p_epg->pp_event[i];
            break;
        }
    }
}",205.0,220.0,1.0,1.0,16.0,14,5,12,4,0,0,5,5,0,0,,0,0,4,2,2,void
2576,95109,vlc_epg_Duplicate,1,vlc_epg_Duplicate,vlc_epg_t vlc_epg_Duplicate (vlc_epg_t*),misc\epg.c,"vlc_epg_t * vlc_epg_Duplicate( const vlc_epg_t *p_src )
{
    vlc_epg_t *p_epg = vlc_epg_New( p_src->i_id, p_src->i_source_id );
    if( p_epg )
    {
        p_epg->psz_name = ( p_src->psz_name ) ? strdup( p_src->psz_name ) : NULL;
        p_epg->b_present = p_src->b_present;
        for( size_t i=0; i<p_src->i_event; i++ )
        {
            vlc_epg_event_t *p_dup = vlc_epg_event_Duplicate( p_src->pp_event[i] );
            if( p_dup )
            {
                if( p_src->p_current == p_src->pp_event[i] )
                    p_epg->p_current = p_dup;
                TAB_APPEND( p_epg->i_event, p_epg->pp_event, p_dup );
            }
        }
    }
    return p_epg;
}",222.0,241.0,1.0,1.0,20.0,25,6,26,5,0,2,5,11,0,2,,0,2,2,1,1,vlc_epg_t
2577,95208,vlc_error,1,vlc_error,const char* vlc_error (int),misc\error.c,"char const * vlc_error ( int i_err )
{
    switch( i_err )
    {
        case VLC_SUCCESS:
            return ""no error"";

        case VLC_ENOMEM:
            return ""not enough memory"";
        case VLC_ETIMEOUT:
            return ""timeout"";

        case VLC_ENOMOD:
            return ""module not found"";

        case VLC_ENOOBJ:
            return ""object not found"";

        case VLC_ENOVAR:
            return ""variable not found"";
        case VLC_EBADVAR:
            return ""bad variable value"";

        case VLC_EGENERIC:
            return ""generic error"";
        default:
            return ""unknown error"";
    }
}",39.0,67.0,1.0,1.0,29.0,0,0,9,9,0,0,2,2,0,0,,0,0,2,1,1,const char*
2578,95264,BinaryLog,1,BinaryLog,int BinaryLog (uint32_t),misc\es_format.c,"static int BinaryLog( uint32_t i )
{
    int i_log = 0;

    if( i == 0 ) return -31337;

    if( i & 0xffff0000 ) i_log += 16;
    if( i & 0xff00ff00 ) i_log += 8;
    if( i & 0xf0f0f0f0 ) i_log += 4;
    if( i & 0xcccccccc ) i_log += 2;
    if( i & 0xaaaaaaaa ) i_log += 1;

    return i_log;
}",44.0,57.0,1.0,1.0,14.0,13,5,13,2,2,0,7,7,0,0,,0,0,2,1,1,int
2579,95323,MaskToShift,1,MaskToShift,"void MaskToShift (int*,int*,uint32_t)",misc\es_format.c,"static void MaskToShift( int *pi_left, int *pi_right, uint32_t i_mask )
{
    uint32_t i_low, i_high;            /* lower and higher bits of the mask */

    if( !i_mask )
    {
        *pi_left = *pi_right = 0;
        return;
    }

    /* Get bits */
    i_low = i_high = i_mask;

    i_low &= - (int32_t)i_low;          /* lower bit of the mask */
    i_high += i_low;                    /* higher bit of the mask */

    /* Transform bits into an index. Also deal with i_high overflow, which
     * is faster than changing the BinaryLog code to handle 64 bit integers. */
    i_low =  BinaryLog (i_low);
    i_high = i_high ? BinaryLog (i_high) : 32;

    /* Update pointers and return */
    *pi_left =   i_low;
    *pi_right = (8 - i_high + i_low);
}",63.0,87.0,1.0,1.0,25.0,19,9,20,5,3,2,2,2,0,2,,0,2,6,3,3,void
2580,95381,video_format_FixRgb,1,video_format_FixRgb,void video_format_FixRgb (video_format_t*),misc\es_format.c,"void video_format_FixRgb( video_format_t *p_fmt )
{
    /* FIXME find right default mask */
    if( !p_fmt->i_rmask || !p_fmt->i_gmask || !p_fmt->i_bmask )
    {
        switch( p_fmt->i_chroma )
        {
        case VLC_CODEC_RGB15:
            p_fmt->i_rmask = 0x7c00;
            p_fmt->i_gmask = 0x03e0;
            p_fmt->i_bmask = 0x001f;
            break;

        case VLC_CODEC_RGB16:
            p_fmt->i_rmask = 0xf800;
            p_fmt->i_gmask = 0x07e0;
            p_fmt->i_bmask = 0x001f;
            break;

        case VLC_CODEC_RGB24:
            p_fmt->i_rmask = 0xff0000;
            p_fmt->i_gmask = 0x00ff00;
            p_fmt->i_bmask = 0x0000ff;
            break;
        case VLC_CODEC_RGB32:
            p_fmt->i_rmask = 0x00ff0000;
            p_fmt->i_gmask = 0x0000ff00;
            p_fmt->i_bmask = 0x000000ff;
            break;

        default:
            return;
        }
    }

    MaskToShift( &p_fmt->i_lrshift, &p_fmt->i_rrshift,
                 p_fm...",90.0,131.0,1.0,1.0,42.0,48,5,29,5,6,3,7,4,0,3,,0,0,2,1,1,void
2581,95517,video_format_Setup,1,video_format_Setup,"void video_format_Setup (video_format_t*,vlc_fourcc_t,int,int,int,int,int,int)",misc\es_format.c,"void video_format_Setup( video_format_t *p_fmt, vlc_fourcc_t i_chroma,
                         int i_width, int i_height,
                         int i_visible_width, int i_visible_height,
                         int i_sar_num, int i_sar_den )
{
    p_fmt->i_chroma         = vlc_fourcc_GetCodec( VIDEO_ES, i_chroma );
    p_fmt->i_width          = i_width;
    p_fmt->i_visible_width  = i_visible_width;
    p_fmt->i_height         = i_height;
    p_fmt->i_visible_height = i_visible_height;
    p_fmt->i_x_offset       =
    p_fmt->i_y_offset       = 0;
    vlc_ureduce( &p_fmt->i_sar_num, &p_fmt->i_sar_den,
                 i_sar_num, i_sar_den, 0 );

    switch( p_fmt->i_chroma )
    {
    case VLC_CODEC_YUVA:
        p_fmt->i_bits_per_pixel = 32;
        break;
    case VLC_CODEC_YUV420A:
        p_fmt->i_bits_per_pixel = 20;
        break;
    case VLC_CODEC_YUV422A:
        p_fmt->i_bits_per_pixel = 24;
        break;
    case VLC_CODEC_I444:
    case VLC_CODEC_J444:
        p_fm...",133.0,226.0,1.0,1.0,94.0,55,3,70,43,3,2,20,2,0,2,,0,1,16,8,8,void
2582,95759,video_format_CopyCrop,1,video_format_CopyCrop,"void video_format_CopyCrop (video_format_t*,video_format_t*)",misc\es_format.c,"void video_format_CopyCrop( video_format_t *p_dst, const video_format_t *p_src )
{
    p_dst->i_x_offset       = p_src->i_x_offset;
    p_dst->i_y_offset       = p_src->i_y_offset;
    p_dst->i_visible_width  = p_src->i_visible_width;
    p_dst->i_visible_height = p_src->i_visible_height;
}",228.0,234.0,1.0,1.0,7.0,12,2,8,2,4,0,1,1,0,0,,0,0,4,2,2,void
2583,95793,video_format_ScaleCropAr,1,video_format_ScaleCropAr,"void video_format_ScaleCropAr (video_format_t*,video_format_t*)",misc\es_format.c,"void video_format_ScaleCropAr( video_format_t *p_dst, const video_format_t *p_src )
{
    p_dst->i_x_offset       = (uint64_t)p_src->i_x_offset       * p_dst->i_width  / p_src->i_width;
    p_dst->i_y_offset       = (uint64_t)p_src->i_y_offset       * p_dst->i_height / p_src->i_height;
    p_dst->i_visible_width  = (uint64_t)p_src->i_visible_width  * p_dst->i_width  / p_src->i_width;
    p_dst->i_visible_height = (uint64_t)p_src->i_visible_height * p_dst->i_height / p_src->i_height;

    p_dst->i_sar_num *= p_src->i_width;
    p_dst->i_sar_den *= p_dst->i_width;
    vlc_ureduce(&p_dst->i_sar_num, &p_dst->i_sar_den,
                p_dst->i_sar_num, p_dst->i_sar_den, 65536);

    p_dst->i_sar_num *= p_dst->i_height;
    p_dst->i_sar_den *= p_src->i_height;
    vlc_ureduce(&p_dst->i_sar_num, &p_dst->i_sar_den,
                p_dst->i_sar_num, p_dst->i_sar_den, 65536);
}",236.0,252.0,1.0,1.0,17.0,56,7,32,2,0,2,1,1,0,2,,0,0,4,2,2,void
2584,95927,transform_GetBasicOps,1,transform_GetBasicOps,"void transform_GetBasicOps (video_transform_t,unsigned*,bool*)",misc\es_format.c,"static void transform_GetBasicOps( video_transform_t transform,
                                   unsigned *restrict angle,
                                   bool *restrict hflip )
{
    *hflip = ORIENT_IS_MIRROR(transform);

    switch ( transform )
    {
        case TRANSFORM_R90:
        case TRANSFORM_TRANSPOSE:
            *angle = 90;
            break;
        case TRANSFORM_R180:
        case TRANSFORM_VFLIP:
            *angle = 180;
            break;
        case TRANSFORM_R270:
        case TRANSFORM_ANTI_TRANSPOSE:
            *angle = 270;
            break;
        case TRANSFORM_HFLIP:
        case TRANSFORM_IDENTITY:
            *angle = 0;
            break;
        default:
            vlc_assert_unreachable ();
    }
}",255.0,282.0,1.0,1.0,28.0,10,2,15,11,4,0,6,2,0,0,,0,0,6,3,3,void
2585,95980,transform_FromBasicOps,1,transform_FromBasicOps,"video_transform_t transform_FromBasicOps (unsigned,bool)",misc\es_format.c,"static video_transform_t transform_FromBasicOps( unsigned angle, bool hflip )
{
    switch ( angle )
    {
        case 90:
            return hflip ? TRANSFORM_TRANSPOSE : TRANSFORM_R90;
        case 180:
            return hflip ? TRANSFORM_VFLIP : TRANSFORM_R180;
        case 270:
            return hflip ? TRANSFORM_ANTI_TRANSPOSE : TRANSFORM_R270;
        default:
            return hflip ? TRANSFORM_HFLIP : TRANSFORM_IDENTITY;
    }
}",284.0,297.0,1.0,1.0,14.0,4,1,13,10,1,0,2,2,0,0,,0,0,4,2,2,video_transform_t
2586,96016,video_format_GetTransform,1,video_format_GetTransform,"video_transform_t video_format_GetTransform (video_orientation_t,video_orientation_t)",misc\es_format.c,"video_transform_t video_format_GetTransform( video_orientation_t src,
                                             video_orientation_t dst )
{
    unsigned angle1, angle2;
    bool hflip1, hflip2;

    transform_GetBasicOps(  (video_transform_t)src, &angle1, &hflip1 );
    transform_GetBasicOps( transform_Inverse( (video_transform_t)dst ),
                           &angle2, &hflip2 );

    int angle = (angle1 + angle2) % 360;
    bool hflip = hflip1 ^ hflip2;

    return transform_FromBasicOps(angle, hflip);
}",299.0,313.0,1.0,1.0,15.0,11,6,14,8,2,3,1,1,0,3,,0,0,4,2,2,video_transform_t
2587,96061,video_format_TransformBy,1,video_format_TransformBy,"void video_format_TransformBy (video_format_t*,video_transform_t)",misc\es_format.c,"void video_format_TransformBy( video_format_t *fmt, video_transform_t transform )
{
    /* Get destination orientation */
    unsigned angle1, angle2;
    bool hflip1, hflip2;

    transform_GetBasicOps( transform, &angle1, &hflip1 );
    transform_GetBasicOps( (video_transform_t)fmt->orientation, &angle2, &hflip2 );

    unsigned angle = (angle2 - angle1 + 360) % 360;
    bool hflip = hflip2 ^ hflip1;

    video_orientation_t dst_orient = ORIENT_NORMAL;

    if( hflip ) {

        if( angle == 0 )
            dst_orient = ORIENT_HFLIPPED;
        else if( angle == 90 )
            dst_orient = ORIENT_ANTI_TRANSPOSED;
        else if( angle == 180 )
            dst_orient = ORIENT_VFLIPPED;
        else if( angle == 270 )
            dst_orient = ORIENT_TRANSPOSED;
    }
    else {

        if( angle == 90 )
            dst_orient = ORIENT_ROTATED_90;
        else if( angle == 180 )
            dst_orient = ORIENT_ROTATED_180;
        else if( angle == 270 )
            dst_orient =...",315.0,366.0,1.0,1.0,52.0,45,12,40,12,1,2,4,5,0,2,,0,0,4,2,2,void
2588,96253,video_format_TransformTo,1,video_format_TransformTo,"void video_format_TransformTo (video_format_t*,video_orientation_t)",misc\es_format.c,"void video_format_TransformTo( video_format_t *restrict fmt,
                               video_orientation_t dst_orientation )
{
    video_transform_t transform = video_format_GetTransform(fmt->orientation,
                                                            dst_orientation);
    video_format_TransformBy(fmt, transform);
}",368.0,374.0,1.0,1.0,7.0,2,2,5,3,2,2,1,1,0,2,,0,1,4,2,2,void
2589,96270,video_format_ApplyRotation,1,video_format_ApplyRotation,"void video_format_ApplyRotation (video_format_t*,video_format_t*)",misc\es_format.c,"void video_format_ApplyRotation( video_format_t *restrict out,
                                 const video_format_t *restrict in )
{
    *out = *in;

    video_format_TransformTo(out, ORIENT_NORMAL);
}",376.0,382.0,1.0,1.0,7.0,3,2,4,3,2,1,1,1,0,1,,0,0,4,2,2,void
2590,96284,video_format_IsSimilar,1,video_format_IsSimilar,"bool video_format_IsSimilar (video_format_t*,video_format_t*)",misc\es_format.c,"bool video_format_IsSimilar( const video_format_t *f1,
                             const video_format_t *f2 )
{
    if( f1->i_chroma != f2->i_chroma )
        return false;

    if( f1->i_width != f2->i_width || f1->i_height != f2->i_height ||
        f1->i_visible_width != f2->i_visible_width ||
        f1->i_visible_height != f2->i_visible_height ||
        f1->i_x_offset != f2->i_x_offset || f1->i_y_offset != f2->i_y_offset )
        return false;
    if( (int64_t)f1->i_sar_num * f2->i_sar_den !=
        (int64_t)f2->i_sar_num * f1->i_sar_den )
        return false;

    if( f1->orientation != f2->orientation)
        return false;

    if( f1->multiview_mode!= f2->multiview_mode )
       return false;

    if( f1->i_chroma == VLC_CODEC_RGB15 ||
        f1->i_chroma == VLC_CODEC_RGB16 ||
        f1->i_chroma == VLC_CODEC_RGB24 ||
        f1->i_chroma == VLC_CODEC_RGB32 )
    {
        video_format_t v1 = *f1;
        video_format_t v2 = *f2;

        video_format_FixRgb( &v1 );
...",384.0,422.0,1.0,1.0,39.0,69,10,49,10,4,2,8,9,0,2,,0,0,4,2,2,bool
2591,96467,video_format_Print,1,video_format_Print,"void video_format_Print (vlc_object_t*,char*,video_format_t*)",misc\es_format.c,"void video_format_Print( vlc_object_t *p_this,
                         const char *psz_text, const video_format_t *fmt )
{
    msg_Dbg( p_this,
             ""%s sz %ix%i, of (%i,%i), vsz %ix%i, 4cc %4.4s, sar %i:%i, msk r0x%x g0x%x b0x%x"",
             psz_text,
             fmt->i_width, fmt->i_height, fmt->i_x_offset, fmt->i_y_offset,
             fmt->i_visible_width, fmt->i_visible_height,
             (char*)&fmt->i_chroma,
             fmt->i_sar_num, fmt->i_sar_den,
             fmt->i_rmask, fmt->i_gmask, fmt->i_bmask );
}",423.0,434.0,1.0,1.0,12.0,14,3,14,3,3,0,1,1,0,0,,0,0,6,3,3,void
2592,96517,es_format_Init,1,es_format_Init,"void es_format_Init (es_format_t*,int,vlc_fourcc_t)",misc\es_format.c,"void es_format_Init( es_format_t *fmt,
                     int i_cat, vlc_fourcc_t i_codec )
{
    memset(fmt, 0, sizeof (*fmt));
    fmt->i_cat                  = i_cat;
    fmt->i_codec                = i_codec;
    fmt->i_profile              = -1;
    fmt->i_level                = -1;
    fmt->i_id                   = -1;
    fmt->i_priority             = ES_PRIORITY_SELECTABLE_MIN;
    fmt->psz_language           = NULL;
    fmt->psz_description        = NULL;
    fmt->p_extra_languages      = NULL;

    if (fmt->i_cat == VIDEO_ES)
        video_format_Init(&fmt->video, 0);

    fmt->b_packetized           = true;
    fmt->p_extra                = NULL;
}",436.0,455.0,1.0,1.0,20.0,31,7,24,7,15,0,2,2,0,0,,0,0,6,3,3,void
2593,96601,es_format_InitFromVideo,1,es_format_InitFromVideo,"void es_format_InitFromVideo (es_format_t*,video_format_t*)",misc\es_format.c,"void es_format_InitFromVideo( es_format_t *p_es, const video_format_t *p_fmt )
{
    es_format_Init( p_es, VIDEO_ES, p_fmt->i_chroma );
    video_format_Copy( &p_es->video, p_fmt );
}",457.0,461.0,1.0,1.0,5.0,3,2,5,3,3,1,1,1,0,1,,0,0,4,2,2,void
2594,96619,es_format_Copy,1,es_format_Copy,"int es_format_Copy (es_format_t*,es_format_t*)",misc\es_format.c,"int es_format_Copy(es_format_t *restrict dst, const es_format_t *src)
{
    int ret = VLC_SUCCESS;

    *dst = *src;

    if (src->psz_language != NULL)
    {
        dst->psz_language = strdup(src->psz_language);
        if (unlikely(dst->psz_language == NULL))
            ret = VLC_ENOMEM;
    }
    if (src->psz_description != NULL)
    {
        dst->psz_description = strdup(src->psz_description);
        if (unlikely(dst->psz_description == NULL))
            ret = VLC_ENOMEM;
    }

    if (src->i_extra > 0)
    {
        assert(src->p_extra != NULL);
        dst->p_extra = malloc( src->i_extra );

        if( likely(dst->p_extra != NULL) )
            memcpy(dst->p_extra, src->p_extra, src->i_extra);
        else
        {
            dst->i_extra = 0;
            ret = VLC_ENOMEM;
        }
    }
    else
        dst->p_extra = NULL;

    if (src->i_cat == VIDEO_ES)
        ret = video_format_Copy( &dst->video, &src->video );

    if (src->i_cat == SPU_ES)
    {
        if (s...",463.0,540.0,1.0,1.0,78.0,105,11,81,9,12,1,18,36,0,1,,0,1,4,2,2,int
2595,96956,es_format_Clean,1,es_format_Clean,void es_format_Clean (es_format_t*),misc\es_format.c,"void es_format_Clean(es_format_t *fmt)
{
    free(fmt->psz_language);
    free(fmt->psz_description);
    assert(fmt->i_extra == 0 || fmt->p_extra != NULL);
    free(fmt->p_extra);

    if (fmt->i_cat == VIDEO_ES)
        video_format_Clean( &fmt->video );
    if (fmt->i_cat == SPU_ES)
    {
        free(fmt->subs.psz_encoding);

        if (fmt->subs.p_style != NULL)
            text_style_Delete(fmt->subs.p_style);
    }

    for (unsigned i = 0; i < fmt->i_extra_languages; i++)
    {
        free(fmt->p_extra_languages[i].psz_language);
        free(fmt->p_extra_languages[i].psz_description);
    }
    free(fmt->p_extra_languages);

    /* es_format_Clean can be called multiple times */
    es_format_Init(fmt, UNKNOWN_ES, 0);
}",542.0,568.0,1.0,1.0,27.0,31,9,25,6,27,2,5,6,0,2,,0,0,2,1,1,void
2596,97063,es_format_IsSimilar,1,es_format_IsSimilar,"bool es_format_IsSimilar (es_format_t*,es_format_t*)",misc\es_format.c,"bool es_format_IsSimilar( const es_format_t *p_fmt1, const es_format_t *p_fmt2 )
{
    if( p_fmt1->i_cat != p_fmt2->i_cat ||
        vlc_fourcc_GetCodec( p_fmt1->i_cat, p_fmt1->i_codec ) !=
        vlc_fourcc_GetCodec( p_fmt2->i_cat, p_fmt2->i_codec ) )
        return false;

    switch( p_fmt1->i_cat )
    {
    case AUDIO_ES:
    {
        audio_format_t a1 = p_fmt1->audio;
        audio_format_t a2 = p_fmt2->audio;

        if( a1.i_format && a2.i_format && a1.i_format != a2.i_format )
            return false;
        if( a1.channel_type != a2.channel_type ||
            a1.i_rate != a2.i_rate ||
            a1.i_channels != a2.i_channels ||
            a1.i_physical_channels != a2.i_physical_channels ||
            a1.i_chan_mode != a2.i_chan_mode )
            return false;
        if( p_fmt1->i_profile != p_fmt2->i_profile )
            return false;
        return true;
    }

    case VIDEO_ES:
    {
        video_format_t v1 = p_fmt1->video;
        video_format_t v2 = p_f...",570.0,612.0,1.0,1.0,43.0,63,8,50,11,1,5,8,13,2,5,,0,4,4,2,2,bool
2597,97274,vlc_event_manager_init,1,vlc_event_manager_init,"void vlc_event_manager_init (vlc_event_manager_t*,void*)",misc\events.c,"void vlc_event_manager_init( vlc_event_manager_t * p_em, void * p_obj )
{
    p_em->p_obj = p_obj;
    /* This is an unsafe work-around for a long-standing playlist bug.
     * Do not rely on this. */
    vlc_mutex_init_recursive( &p_em->lock );

    for( size_t i = 0; i < ARRAY_SIZE(p_em->events); i++ )
       ARRAY_INIT( p_em->events[i].listeners );
}",66.0,75.0,1.0,1.0,10.0,7,4,6,3,1,1,2,2,0,1,,0,0,4,2,2,void
2598,97312,vlc_event_manager_fini,1,vlc_event_manager_fini,void vlc_event_manager_fini (vlc_event_manager_t*),misc\events.c,"void vlc_event_manager_fini( vlc_event_manager_t * p_em )
{
    struct vlc_event_listener_t * listener;

    vlc_mutex_destroy( &p_em->lock );

    for( size_t i = 0; i < ARRAY_SIZE(p_em->events); i++ )
    {
        struct vlc_event_listeners_group_t *slot = p_em->events + i;

        FOREACH_ARRAY( listener, slot->listeners )
            free( listener );
        FOREACH_END()
        ARRAY_RESET( slot->listeners );
    }
}",80.0,95.0,1.0,1.0,16.0,10,5,11,4,1,1,2,2,0,1,,0,0,2,1,1,void
2599,97360,vlc_event_send,1,vlc_event_send,"void vlc_event_send (vlc_event_manager_t*,vlc_event_t*)",misc\events.c,"void vlc_event_send( vlc_event_manager_t * p_em,
                     vlc_event_t * p_event )
{
    vlc_event_listeners_group_t *slot = &p_em->events[p_event->type];
    vlc_event_listener_t * listener;

    /* Fill event with the sending object now */
    p_event->p_obj = p_em->p_obj;

    vlc_mutex_lock( &p_em->lock ) ;

    FOREACH_ARRAY( listener, slot->listeners )
        listener->pf_callback( p_event, listener->p_user_data );
    FOREACH_END()

    vlc_mutex_unlock( &p_em->lock );
}",100.0,116.0,1.0,1.0,17.0,15,4,12,4,7,4,1,1,0,2,,0,2,4,2,2,void
2600,97411,vlc_event_attach,1,vlc_event_attach,"int vlc_event_attach (vlc_event_manager_t*,vlc_event_type_t,vlc_event_callback_t,void*)",misc\events.c,"int vlc_event_attach( vlc_event_manager_t * p_em,
                      vlc_event_type_t event_type,
                      vlc_event_callback_t pf_callback,
                      void *p_user_data )
{
    vlc_event_listener_t * listener;
    vlc_event_listeners_group_t *slot = &p_em->events[event_type];

    listener = malloc(sizeof(vlc_event_listener_t));
    if( !listener )
        return VLC_ENOMEM;

    listener->p_user_data = p_user_data;
    listener->pf_callback = pf_callback;

    vlc_mutex_lock( &p_em->lock );
    ARRAY_APPEND( slot->listeners, listener );
    vlc_mutex_unlock( &p_em->lock );
    return VLC_SUCCESS;
}",122.0,141.0,1.0,1.0,20.0,16,6,16,9,7,4,2,2,0,2,,0,2,8,4,4,int
2601,97467,vlc_event_detach,1,vlc_event_detach,"void vlc_event_detach (vlc_event_manager_t*,vlc_event_type_t,vlc_event_callback_t,void*)",misc\events.c,"void vlc_event_detach( vlc_event_manager_t *p_em,
                       vlc_event_type_t event_type,
                       vlc_event_callback_t pf_callback,
                       void *p_user_data )
{
    vlc_event_listeners_group_t *slot = &p_em->events[event_type];
    struct vlc_event_listener_t * listener;

    vlc_mutex_lock( &p_em->lock );

    FOREACH_ARRAY( listener, slot->listeners )
        if( listener->pf_callback == pf_callback &&
            listener->p_user_data == p_user_data )
        {
            /* that's our listener */
            ARRAY_REMOVE( slot->listeners,
                          fe_idx /* This comes from the macro (and that's why
                                    I hate macro) */ );
            vlc_mutex_unlock( &p_em->lock );
            free( listener );
            return;
        }
    FOREACH_END()

    vlc_assert_unreachable();
}",147.0,172.0,1.0,1.0,26.0,15,6,14,7,7,4,2,2,2,2,,0,2,8,4,4,void
2602,97570,libvlc_SetExitHandler,1,libvlc_SetExitHandler,"void libvlc_SetExitHandler (libvlc_int_t*,void,void*)",misc\exit.c,"void libvlc_SetExitHandler( libvlc_int_t *p_libvlc, void (*handler) (void *),
                            void *opaque )
{
    vlc_exit_t *exit = &libvlc_priv( p_libvlc )->exit;

    vlc_mutex_lock( &exit->lock );
    exit->handler = handler;
    exit->opaque = opaque;
    vlc_mutex_unlock( &exit->lock );
}",46.0,55.0,1.0,1.0,10.0,11,3,8,4,0,3,1,1,0,3,,0,1,6,3,3,void
2603,97605,libvlc_Quit,1,libvlc_Quit,void libvlc_Quit (libvlc_int_t*),misc\exit.c,"void libvlc_Quit( libvlc_int_t *p_libvlc )
{
    vlc_exit_t *exit = &libvlc_priv( p_libvlc )->exit;

    msg_Dbg( p_libvlc, ""exiting"" );
    vlc_mutex_lock( &exit->lock );
    if( exit->handler != NULL )
        exit->handler( exit->opaque );
    else
        msg_Dbg( p_libvlc, ""no exit handler"" );
    vlc_mutex_unlock( &exit->lock );
}",61.0,72.0,1.0,1.0,12.0,11,4,9,3,0,4,2,2,0,4,,0,1,2,1,1,void
2604,97674,vlc_fifo_Lock,1,vlc_fifo_Lock,void vlc_fifo_Lock (vlc_fifo_t*),misc\fifo.c,"void vlc_fifo_Lock(vlc_fifo_t *fifo)
{
    vlc_mutex_lock(&fifo->lock);
}",49.0,52.0,1.0,1.0,4.0,2,2,1,1,21,1,1,1,0,1,,0,0,2,1,1,void
2605,97684,vlc_fifo_Unlock,1,vlc_fifo_Unlock,void vlc_fifo_Unlock (vlc_fifo_t*),misc\fifo.c,"void vlc_fifo_Unlock(vlc_fifo_t *fifo)
{
    vlc_mutex_unlock(&fifo->lock);
}",54.0,57.0,1.0,1.0,4.0,2,2,1,1,22,1,1,1,0,1,,0,0,2,1,1,void
2606,97694,vlc_fifo_Signal,1,vlc_fifo_Signal,void vlc_fifo_Signal (vlc_fifo_t*),misc\fifo.c,"void vlc_fifo_Signal(vlc_fifo_t *fifo)
{
    vlc_cond_signal(&fifo->wait);
}",59.0,62.0,1.0,1.0,4.0,2,2,1,1,6,1,1,1,0,1,,0,0,2,1,1,void
2607,97704,vlc_fifo_Wait,1,vlc_fifo_Wait,void vlc_fifo_Wait (vlc_fifo_t*),misc\fifo.c,"void vlc_fifo_Wait(vlc_fifo_t *fifo)
{
    vlc_fifo_WaitCond(fifo, &fifo->wait);
}",64.0,67.0,1.0,1.0,4.0,2,2,2,1,4,1,1,1,0,1,,0,0,2,1,1,void
2608,97715,vlc_fifo_WaitCond,1,vlc_fifo_WaitCond,"void vlc_fifo_WaitCond (vlc_fifo_t*,vlc_cond_t*)",misc\fifo.c,"void vlc_fifo_WaitCond(vlc_fifo_t *fifo, vlc_cond_t *condvar)
{
    vlc_cond_wait(condvar, &fifo->lock);
}",69.0,72.0,1.0,1.0,4.0,2,2,2,2,1,1,1,1,0,1,,0,0,4,2,2,void
2609,97727,vlc_fifo_TimedWaitCond,1,vlc_fifo_TimedWaitCond,"int vlc_fifo_TimedWaitCond (vlc_fifo_t*,vlc_cond_t*,mtime_t)",misc\fifo.c,"int vlc_fifo_TimedWaitCond(vlc_fifo_t *fifo, vlc_cond_t *condvar, mtime_t deadline)
{
    return vlc_cond_timedwait(condvar, &fifo->lock, deadline);
}",74.0,77.0,1.0,1.0,4.0,2,2,3,3,1,1,1,1,0,1,,0,0,6,3,3,int
2610,97742,vlc_fifo_GetCount,1,vlc_fifo_GetCount,size_t vlc_fifo_GetCount (vlc_fifo_t*),misc\fifo.c,"size_t vlc_fifo_GetCount(const vlc_fifo_t *fifo)
{
    return fifo->i_depth;
}",79.0,82.0,1.0,1.0,4.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,size_t
2611,97751,vlc_fifo_GetBytes,1,vlc_fifo_GetBytes,size_t vlc_fifo_GetBytes (vlc_fifo_t*),misc\fifo.c,"size_t vlc_fifo_GetBytes(const vlc_fifo_t *fifo)
{
    return fifo->i_size;
}",84.0,87.0,1.0,1.0,4.0,1,1,1,1,1,0,1,1,0,0,,0,0,2,1,1,size_t
2612,97760,vlc_fifo_QueueUnlocked,1,vlc_fifo_QueueUnlocked,"void vlc_fifo_QueueUnlocked (block_fifo_t*,block_t*)",misc\fifo.c,"void vlc_fifo_QueueUnlocked(block_fifo_t *fifo, block_t *block)
{
    vlc_assert_locked(&fifo->lock);
    assert(*(fifo->pp_last) == NULL);

    *(fifo->pp_last) = block;

    while (block != NULL)
    {
        fifo->pp_last = &block->p_next;
        fifo->i_depth++;
        fifo->i_size += block->i_buffer;

        block = block->p_next;
    }

    vlc_fifo_Signal(fifo);
}",89.0,106.0,1.0,4.0,18.0,23,9,16,3,3,8,2,2,0,1,,0,7,4,2,2,void
2613,97822,vlc_fifo_DequeueUnlocked,1,vlc_fifo_DequeueUnlocked,block_t vlc_fifo_DequeueUnlocked (block_fifo_t*),misc\fifo.c,"block_t *vlc_fifo_DequeueUnlocked(block_fifo_t *fifo)
{
    vlc_assert_locked(&fifo->lock);

    block_t *block = fifo->p_first;

    if (block == NULL)
        return NULL; /* Nothing to do */

    fifo->p_first = block->p_next;
    if (block->p_next == NULL)
        fifo->pp_last = &fifo->p_first;
    block->p_next = NULL;

    assert(fifo->i_depth > 0);
    fifo->i_depth--;
    assert(fifo->i_size >= block->i_buffer);
    fifo->i_size -= block->i_buffer;

    return block;
}",108.0,128.0,1.0,4.0,21.0,29,9,22,3,3,10,3,3,0,0,,0,10,2,1,1,block_t
2614,97906,vlc_fifo_DequeueAllUnlocked,1,vlc_fifo_DequeueAllUnlocked,block_t vlc_fifo_DequeueAllUnlocked (block_fifo_t*),misc\fifo.c,"block_t *vlc_fifo_DequeueAllUnlocked(block_fifo_t *fifo)
{
    vlc_assert_locked(&fifo->lock);

    block_t *block = fifo->p_first;

    fifo->p_first = NULL;
    fifo->pp_last = &fifo->p_first;
    fifo->i_depth = 0;
    fifo->i_size = 0;

    return block;
}",130.0,142.0,1.0,4.0,13.0,17,4,11,3,4,8,1,1,0,0,,0,8,2,1,1,block_t
2615,97954,block_FifoNew,1,block_FifoNew,block_fifo_t block_FifoNew (void),misc\fifo.c,"block_fifo_t *block_FifoNew( void )
{
    block_fifo_t *p_fifo = malloc( sizeof( block_fifo_t ) );
    if( !p_fifo )
        return NULL;

    vlc_mutex_init( &p_fifo->lock );
    vlc_cond_init( &p_fifo->wait );
    p_fifo->p_first = NULL;
    p_fifo->pp_last = &p_fifo->p_first;
    p_fifo->i_depth = p_fifo->i_size = 0;

    return p_fifo;
}",144.0,157.0,1.0,1.0,14.0,17,5,13,3,2,9,2,2,0,2,,0,7,2,1,1,block_fifo_t
2616,98005,block_FifoRelease,1,block_FifoRelease,void block_FifoRelease (block_fifo_t*),misc\fifo.c,"void block_FifoRelease( block_fifo_t *p_fifo )
{
    block_ChainRelease( p_fifo->p_first );
    vlc_cond_destroy( &p_fifo->wait );
    vlc_mutex_destroy( &p_fifo->lock );
    free( p_fifo );
}",159.0,165.0,1.0,1.0,7.0,5,2,4,1,4,5,1,1,0,2,,0,3,2,1,1,void
2617,98026,block_FifoEmpty,1,block_FifoEmpty,void block_FifoEmpty (block_fifo_t*),misc\fifo.c,"void block_FifoEmpty(block_fifo_t *fifo)
{
    block_t *block;

    vlc_fifo_Lock(fifo);
    block = vlc_fifo_DequeueAllUnlocked(fifo);
    vlc_fifo_Unlock(fifo);
    block_ChainRelease(block);
}",167.0,175.0,1.0,1.0,9.0,1,1,5,2,0,3,1,1,0,3,,0,1,2,1,1,void
2618,98042,block_FifoPut,1,block_FifoPut,"void block_FifoPut (block_fifo_t*,block_t*)",misc\fifo.c,"void block_FifoPut(block_fifo_t *fifo, block_t *block)
{
    vlc_fifo_Lock(fifo);
    vlc_fifo_QueueUnlocked(fifo, block);
    vlc_fifo_Unlock(fifo);
}",177.0,182.0,1.0,1.0,6.0,0,0,4,2,1,3,1,1,0,3,,0,0,4,2,2,void
2619,98055,block_FifoGet,1,block_FifoGet,block_t block_FifoGet (block_fifo_t*),misc\fifo.c,"block_t *block_FifoGet(block_fifo_t *fifo)
{
    block_t *block;

    vlc_testcancel();

    vlc_fifo_Lock(fifo);
    while (vlc_fifo_IsEmpty(fifo))
    {
        vlc_fifo_CleanupPush(fifo);
        vlc_fifo_Wait(fifo);
        vlc_cleanup_pop();
    }
    block = vlc_fifo_DequeueUnlocked(fifo);
    vlc_fifo_Unlock(fifo);

    return block;
}",184.0,201.0,1.0,1.0,18.0,1,1,8,2,0,5,2,2,0,5,,0,1,2,1,1,block_t
2620,98081,block_FifoShow,1,block_FifoShow,block_t block_FifoShow (block_fifo_t*),misc\fifo.c,"block_t *block_FifoShow( block_fifo_t *p_fifo )
{
    block_t *b;

    vlc_mutex_lock( &p_fifo->lock );
    assert(p_fifo->p_first != NULL);
    b = p_fifo->p_first;
    vlc_mutex_unlock( &p_fifo->lock );

    return b;
}",203.0,213.0,1.0,1.0,11.0,8,4,7,3,0,6,1,1,0,2,,0,4,2,1,1,block_t
2621,98110,block_FifoSize,1,block_FifoSize,size_t block_FifoSize (block_fifo_t*),misc\fifo.c,"size_t block_FifoSize (block_fifo_t *fifo)
{
    size_t size;

    vlc_mutex_lock (&fifo->lock);
    size = fifo->i_size;
    vlc_mutex_unlock (&fifo->lock);
    return size;
}",216.0,224.0,1.0,1.0,9.0,6,3,5,2,1,5,1,1,0,2,,0,3,2,1,1,size_t
2622,98133,block_FifoCount,1,block_FifoCount,size_t block_FifoCount (block_fifo_t*),misc\fifo.c,"size_t block_FifoCount (block_fifo_t *fifo)
{
    size_t depth;

    vlc_mutex_lock (&fifo->lock);
    depth = fifo->i_depth;
    vlc_mutex_unlock (&fifo->lock);
    return depth;
}",227.0,235.0,1.0,1.0,9.0,6,3,5,2,0,5,1,1,0,2,,0,3,2,1,1,size_t
2623,98177,TriggerFilterCallback,1,TriggerFilterCallback,"int TriggerFilterCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",misc\filter.c,"static int TriggerFilterCallback(vlc_object_t *p_this, char const *psz_var,
                                 vlc_value_t oldval, vlc_value_t newval,
                                 void *p_data)
{
    (void) p_this; (void) oldval;
    var_Set((filter_t *)p_data, psz_var, newval);
    return 0;
}",38.0,45.0,1.0,1.0,8.0,3,1,5,5,0,1,1,1,0,1,,0,0,10,5,5,int
2624,98200,filter_AddProxyCallbacks,1,filter_AddProxyCallbacks,"void filter_AddProxyCallbacks (vlc_object_t*,filter_t*,vlc_callback_t)",misc\filter.c,"void filter_AddProxyCallbacks( vlc_object_t *obj, filter_t *filter,
                               vlc_callback_t restart_cb )
{
    char **names = var_GetAllNames(VLC_OBJECT(filter));
    if (names == NULL)
        return;

    for (char **pname = names; *pname != NULL; pname++)
    {
        char *name = *pname;
        int var_type = var_Type(filter, name);
        if (var_Type(obj, name))
        {
            free(name);
            continue;
        }
        var_Create(obj, name,
                   var_type | VLC_VAR_DOINHERIT | VLC_VAR_ISCOMMAND);
        if ((var_type & VLC_VAR_ISCOMMAND))
            var_AddCallback(obj, name, TriggerFilterCallback, filter);
        else
            var_AddCallback(obj, name, restart_cb, obj);
        free(name);
    }
    free(names);
}",48.0,73.0,1.0,1.0,26.0,11,6,28,9,2,5,6,7,1,5,,0,3,6,3,3,void
2625,98280,filter_DelProxyCallbacks,1,filter_DelProxyCallbacks,"void filter_DelProxyCallbacks (vlc_object_t*,filter_t*,vlc_callback_t)",misc\filter.c,"void filter_DelProxyCallbacks( vlc_object_t *obj, filter_t *filter,
                               vlc_callback_t restart_cb )
{
    char **names = var_GetAllNames(VLC_OBJECT(filter));
    if (names == NULL)
        return;

    for (char **pname = names; *pname != NULL; pname++)
    {
        char *name = *pname;
        if (!(var_Type(obj, name) & VLC_VAR_ISCOMMAND))
        {
            free(name);
            continue;
        }
        int filter_var_type = var_Type(filter, name);

        if (filter_var_type & VLC_VAR_ISCOMMAND)
            var_DelCallback(obj, name, TriggerFilterCallback, filter);
        else if (filter_var_type)
            var_DelCallback(obj, name, restart_cb, obj);
        var_Destroy(obj, name);
        free(name);
    }
    free(names);
}",76.0,101.0,1.0,1.0,26.0,11,6,26,8,3,4,6,7,1,4,,0,3,6,3,3,void
2626,98361,filter_NewBlend,1,filter_NewBlend,"filter_t filter_NewBlend (vlc_object_t*,video_format_t*)",misc\filter.c,"filter_t *filter_NewBlend( vlc_object_t *p_this,
                           const video_format_t *p_dst_chroma )
{
    filter_t *p_blend = vlc_custom_create( p_this, sizeof(*p_blend), ""blend"" );
    if( !p_blend )
        return NULL;

    es_format_Init( &p_blend->fmt_in, VIDEO_ES, 0 );

    es_format_Init( &p_blend->fmt_out, VIDEO_ES, 0 );

    p_blend->fmt_out.i_codec        =
    p_blend->fmt_out.video.i_chroma = p_dst_chroma->i_chroma;
    p_blend->fmt_out.video.i_rmask  = p_dst_chroma->i_rmask;
    p_blend->fmt_out.video.i_gmask  = p_dst_chroma->i_gmask;
    p_blend->fmt_out.video.i_bmask  = p_dst_chroma->i_bmask;
    p_blend->fmt_out.video.i_rrshift= p_dst_chroma->i_rrshift;
    p_blend->fmt_out.video.i_rgshift= p_dst_chroma->i_rgshift;
    p_blend->fmt_out.video.i_rbshift= p_dst_chroma->i_rbshift;
    p_blend->fmt_out.video.i_lrshift= p_dst_chroma->i_lrshift;
    p_blend->fmt_out.video.i_lgshift= p_dst_chroma->i_lgshift;
    p_blend->fmt_out.video.i_lbshift= p_dst_chroma->i_...",105.0,133.0,1.0,1.0,29.0,63,7,33,5,1,3,2,2,0,3,,0,1,4,2,2,filter_t
2627,98519,filter_ConfigureBlend,1,filter_ConfigureBlend,"int filter_ConfigureBlend (filter_t*,int,int,video_format_t*)",misc\filter.c,"int filter_ConfigureBlend( filter_t *p_blend,
                           int i_dst_width, int i_dst_height,
                           const video_format_t *p_src )
{
    /* */
    if( p_blend->p_module &&
        p_blend->fmt_in.video.i_chroma != p_src->i_chroma )
    {
        /* The chroma is not the same, we need to reload the blend module */
        module_unneed( p_blend, p_blend->p_module );
        p_blend->p_module = NULL;
    }

    /* */

    p_blend->fmt_in.i_codec = p_src->i_chroma;
    p_blend->fmt_in.video   = *p_src;

    /* */
    p_blend->fmt_out.video.i_width          =
    p_blend->fmt_out.video.i_visible_width  = i_dst_width;
    p_blend->fmt_out.video.i_height         =
    p_blend->fmt_out.video.i_visible_height = i_dst_height;

    /* */
    if( !p_blend->p_module )
        p_blend->p_module = module_need( p_blend, ""video blending"", NULL, false );
    if( !p_blend->p_module )
        return VLC_EGENERIC;
    return VLC_SUCCESS;
}",135.0,165.0,1.0,1.0,31.0,40,7,25,8,1,2,4,4,0,2,,0,1,8,4,4,int
2628,98630,filter_Blend,1,filter_Blend,"int filter_Blend (filter_t*,picture_t*,int,int,picture_t*,int)",misc\filter.c,"int filter_Blend( filter_t *p_blend,
                  picture_t *p_dst, int i_dst_x, int i_dst_y,
                  const picture_t *p_src, int i_alpha )
{
    if( !p_blend->p_module )
        return VLC_EGENERIC;

    p_blend->pf_video_blend( p_blend, p_dst, p_src, i_dst_x, i_dst_y, i_alpha );
    return VLC_SUCCESS;
}",167.0,176.0,1.0,1.0,10.0,3,2,10,8,1,0,2,2,0,0,,0,0,12,6,6,int
2629,98660,filter_DeleteBlend,1,filter_DeleteBlend,void filter_DeleteBlend (filter_t*),misc\filter.c,"void filter_DeleteBlend( filter_t *p_blend )
{
    if( p_blend->p_module )
        module_unneed( p_blend, p_blend->p_module );

    vlc_object_release( p_blend );
}",178.0,184.0,1.0,1.0,7.0,2,1,4,1,2,2,2,2,0,2,,0,0,2,1,1,void
2630,98677,video_splitter_New,1,video_splitter_New,"video_splitter_t video_splitter_New (vlc_object_t*,char*,video_format_t*)",misc\filter.c,"video_splitter_t *video_splitter_New( vlc_object_t *p_this,
                                      const char *psz_name,
                                      const video_format_t *p_fmt )
{
    video_splitter_t *p_splitter = vlc_custom_create( p_this,
                                       sizeof(*p_splitter), ""video splitter"" );
    if( !p_splitter )
        return NULL;

    video_format_Copy( &p_splitter->fmt, p_fmt );

    /* */
    p_splitter->p_module = module_need( p_splitter, ""video splitter"", psz_name, true );
    if( ! p_splitter->p_module )
    {
        video_splitter_Delete( p_splitter );
        return NULL;
    }

    return p_splitter;
}",189.0,209.0,1.0,1.0,21.0,10,6,15,6,1,3,3,3,0,3,,0,2,6,3,3,video_splitter_t
2631,98726,video_splitter_Delete,1,video_splitter_Delete,void video_splitter_Delete (video_splitter_t*),misc\filter.c,"void video_splitter_Delete( video_splitter_t *p_splitter )
{
    if( p_splitter->p_module )
        module_unneed( p_splitter, p_splitter->p_module );

    video_format_Clean( &p_splitter->fmt );

    vlc_object_release( p_splitter );
}",211.0,219.0,1.0,1.0,9.0,4,2,5,1,2,2,2,2,0,2,,0,0,2,1,1,void
2632,98775,chained,1,chained,chained_filter_t chained (filter_t*),misc\filter_chain.c,"static inline chained_filter_t *chained(filter_t *filter)
{
    return container_of(filter, chained_filter_t, filter);
}",46.0,49.0,1.0,1.0,4.0,0,0,3,2,1,0,1,1,0,0,,0,0,2,1,1,chained_filter_t
2633,98795,FilterDeletePictures,1,FilterDeletePictures,void FilterDeletePictures (picture_t*),misc\filter_chain.c,"static void FilterDeletePictures( picture_t *picture )
{
    while( picture )
    {
        picture_t *next = picture->p_next;
        picture_Release( picture );
        picture = next;
    }
}",521.0,529.0,1.0,1.0,9.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,void
2634,98800,filter_chain_NewInner,1,filter_chain_NewInner,"filter_chain_t filter_chain_NewInner (filter_owner_t*,char*,char*,bool,filter_owner_t*,es_format_category_e)",misc\filter_chain.c,"static filter_chain_t *filter_chain_NewInner( const filter_owner_t *callbacks,
    const char *cap, const char *conv_cap, bool fmt_out_change,
    const filter_owner_t *owner, enum es_format_category_e cat )
{
    assert( callbacks != NULL && callbacks->sys != NULL );
    assert( cap != NULL );

    filter_chain_t *chain = malloc( sizeof (*chain) );
    if( unlikely(chain == NULL) )
        return NULL;

    chain->callbacks = *callbacks;
    if( owner != NULL )
        chain->owner = *owner;
    chain->first = NULL;
    chain->last = NULL;
    es_format_Init( &chain->fmt_in, cat, 0 );
    es_format_Init( &chain->fmt_out, cat, 0 );
    chain->b_allow_fmt_out_change = fmt_out_change;
    chain->filter_cap = cap;
    chain->conv_cap = conv_cap;
    return chain;
}",71.0,93.0,1.0,1.0,23.0,30,8,32,8,2,11,3,3,0,2,,0,9,12,6,6,filter_chain_t
2635,98897,filter_chain_New,1,filter_chain_New,"filter_chain_t filter_chain_New (vlc_object_t*,char*,es_format_category_e)",misc\filter_chain.c,"filter_chain_t *filter_chain_New( vlc_object_t *obj, const char *cap,
                                  enum es_format_category_e cat )
{
    filter_owner_t callbacks = {
        .sys = obj,
    };

    return filter_chain_NewInner( &callbacks, cap, NULL, false, NULL, cat );
}",99.0,107.0,1.0,1.0,9.0,4,3,9,7,2,1,1,1,0,1,,0,0,6,3,3,filter_chain_t
2636,98921,filter_chain_VideoBufferNew,1,filter_chain_VideoBufferNew,picture_t filter_chain_VideoBufferNew (filter_t*),misc\filter_chain.c,"static picture_t *filter_chain_VideoBufferNew( filter_t *filter )
{
    if( chained(filter)->next != NULL )
    {
        picture_t *pic = picture_NewFromFormat( &filter->fmt_out.video );
        if( pic == NULL )
            msg_Err( filter, ""Failed to allocate picture"" );
        return pic;
    }
    else
    {
        filter_chain_t *chain = filter->owner.sys;

        /* XXX ugly */
        filter->owner.sys = chain->owner.sys;
        picture_t *pic = chain->owner.video.buffer_new( filter );
        filter->owner.sys = chain;
        return pic;
    }
}",110.0,129.0,1.0,1.0,20.0,7,6,8,3,0,2,3,4,1,2,,0,2,2,1,1,picture_t
2637,98996,filter_chain_NewVideo,1,filter_chain_NewVideo,"filter_chain_t filter_chain_NewVideo (vlc_object_t*,bool,filter_owner_t*)",misc\filter_chain.c,"filter_chain_t *filter_chain_NewVideo( vlc_object_t *obj, bool allow_change,
                                       const filter_owner_t *restrict owner )
{
    filter_owner_t callbacks = {
        .sys = obj,
        .video = {
            .buffer_new = filter_chain_VideoBufferNew,
        },
    };

    return filter_chain_NewInner( &callbacks, ""video filter"",
                                  ""video converter"", allow_change, owner, VIDEO_ES );
}",132.0,144.0,1.0,1.0,13.0,7,3,9,8,4,1,1,1,0,1,,0,0,6,3,3,filter_chain_t
2638,99028,filter_chain_Delete,1,filter_chain_Delete,void filter_chain_Delete (filter_chain_t*),misc\filter_chain.c,"void filter_chain_Delete( filter_chain_t *p_chain )
{
    while( p_chain->first != NULL )
        filter_chain_DeleteFilter( p_chain, &p_chain->first->filter );

    es_format_Clean( &p_chain->fmt_in );
    es_format_Clean( &p_chain->fmt_out );

    free( p_chain );
}",149.0,158.0,1.0,1.0,10.0,6,3,5,2,10,5,2,2,1,2,,0,3,2,1,1,void
2639,99059,filter_chain_Reset,1,filter_chain_Reset,"void filter_chain_Reset (filter_chain_t*,es_format_t*,es_format_t*)",misc\filter_chain.c,"void filter_chain_Reset( filter_chain_t *p_chain, const es_format_t *p_fmt_in,
                         const es_format_t *p_fmt_out )
{
    while( p_chain->first != NULL )
        filter_chain_DeleteFilter( p_chain, &p_chain->first->filter );

    if( p_fmt_in )
    {
        es_format_Clean( &p_chain->fmt_in );
        es_format_Copy( &p_chain->fmt_in, p_fmt_in );
    }
    if( p_fmt_out )
    {
        es_format_Clean( &p_chain->fmt_out );
        es_format_Copy( &p_chain->fmt_out, p_fmt_out );
    }
}",162.0,178.0,1.0,1.0,17.0,10,3,10,4,6,9,4,4,1,4,,0,5,6,3,3,void
2640,99108,filter_chain_AppendInner,1,filter_chain_AppendInner,"filter_t filter_chain_AppendInner (filter_chain_t*,char*,char*,config_chain_t*,es_format_t*,es_format_t*)",misc\filter_chain.c,"static filter_t *filter_chain_AppendInner( filter_chain_t *chain,
    const char *name, const char *capability, config_chain_t *cfg,
    const es_format_t *fmt_in, const es_format_t *fmt_out )
{
    vlc_object_t *parent = chain->callbacks.sys;
    chained_filter_t *chained =
        vlc_custom_create( parent, sizeof(*chained), ""filter"" );
    if( unlikely(chained == NULL) )
        return NULL;

    filter_t *filter = &chained->filter;

    if( fmt_in == NULL )
    {
        if( chain->last != NULL )
            fmt_in = &chain->last->filter.fmt_out;
        else
            fmt_in = &chain->fmt_in;
    }

    if( fmt_out == NULL )
        fmt_out = &chain->fmt_out;

    es_format_Copy( &filter->fmt_in, fmt_in );
    es_format_Copy( &filter->fmt_out, fmt_out );
    filter->b_allow_fmt_out_change = chain->b_allow_fmt_out_change;
    filter->p_cfg = cfg;
    filter->psz_name = name;

    filter->owner = chain->callbacks;
    filter->owner.sys = chain;

    assert( capability != NULL )...",180.0,265.0,1.0,1.0,86.0,84,11,90,14,2,28,12,12,2,10,,0,20,12,6,6,filter_t
2641,99419,filter_chain_AppendFilter,1,filter_chain_AppendFilter,"filter_t filter_chain_AppendFilter (filter_chain_t*,char*,config_chain_t*,es_format_t*,es_format_t*)",misc\filter_chain.c,"filter_t *filter_chain_AppendFilter( filter_chain_t *chain,
    const char *name, config_chain_t *cfg,
    const es_format_t *fmt_in, const es_format_t *fmt_out )
{
    return filter_chain_AppendInner( chain, name, chain->filter_cap, cfg,
                                     fmt_in, fmt_out );
}",267.0,273.0,1.0,1.0,7.0,1,1,6,5,2,2,1,1,0,1,,0,1,10,5,5,filter_t
2642,99438,filter_chain_AppendConverter,1,filter_chain_AppendConverter,"int filter_chain_AppendConverter (filter_chain_t*,es_format_t*,es_format_t*)",misc\filter_chain.c,"int filter_chain_AppendConverter( filter_chain_t *chain,
    const es_format_t *fmt_in, const es_format_t *fmt_out )
{
    return filter_chain_AppendInner( chain, NULL, chain->conv_cap, NULL,
                                     fmt_in, fmt_out ) != NULL ? 0 : -1;
}",275.0,280.0,1.0,1.0,6.0,4,4,7,4,3,2,1,1,0,1,,0,1,6,3,3,int
2643,99461,filter_chain_DeleteFilter,1,filter_chain_DeleteFilter,"void filter_chain_DeleteFilter (filter_chain_t*,filter_t*)",misc\filter_chain.c,"void filter_chain_DeleteFilter( filter_chain_t *chain, filter_t *filter )
{
    vlc_object_t *obj = chain->callbacks.sys;
    chained_filter_t *chained = (chained_filter_t *)filter;

    /* Remove it from the chain */
    if( chained->prev != NULL )
        chained->prev->next = chained->next;
    else
    {
        assert( chained == chain->first );
        chain->first = chained->next;
    }

    if( chained->next != NULL )
        chained->next->prev = chained->prev;
    else
    {
        assert( chained == chain->last );
        chain->last = chained->prev;
    }

    module_unneed( filter, filter->p_module );

    msg_Dbg( obj, ""Filter %p removed from chain"", (void *)filter );
    FilterDeletePictures( chained->pending );

    free( chained->mouse );
    es_format_Clean( &filter->fmt_out );
    es_format_Clean( &filter->fmt_in );

    vlc_object_release( filter );
    /* FIXME: check fmt_in/fmt_out consitency */
}",282.0,315.0,1.0,1.0,34.0,25,6,21,5,1,14,3,3,2,5,,0,9,4,2,2,void
2644,99574,filter_chain_AppendFromString,1,filter_chain_AppendFromString,"int filter_chain_AppendFromString (filter_chain_t*,char*)",misc\filter_chain.c,"int filter_chain_AppendFromString( filter_chain_t *chain, const char *str )
{
    vlc_object_t *obj = chain->callbacks.sys;
    char *buf = NULL;
    int ret = 0;

    while( str != NULL && str[0] != '\0' )
    {
        config_chain_t *cfg;
        char *name;

        char *next = config_ChainCreate( &name, &cfg, str );

        str = next;
        free( buf );
        buf = next;

        filter_t *filter = filter_chain_AppendFilter( chain, name, cfg,
                                                      NULL, NULL );
        if( cfg )
            config_ChainDestroy( cfg );

        if( filter == NULL )
        {
            msg_Err( obj, ""Failed to append '%s' to chain"", name );
            free( name );
            goto error;
        }

        free( name );
        ret++;
    }

    free( buf );
    return ret;

error:
    while( ret > 0 ) /* Unwind */
    {
        filter_chain_DeleteFilter( chain, &chain->last->filter );
        ret--;
    }
    free( buf );
    return VLC...",318.0,362.0,1.0,1.0,45.0,22,11,40,11,2,6,6,7,0,4,,0,4,4,2,2,int
2645,99680,filter_chain_ForEach,1,filter_chain_ForEach,"int filter_chain_ForEach (filter_chain_t*,int,void*)",misc\filter_chain.c,"int filter_chain_ForEach( filter_chain_t *chain,
                          int (*cb)( filter_t *, void * ), void *opaque )
{
    for( chained_filter_t *f = chain->first; f != NULL; f = f->next )
    {
        int ret = cb( &f->filter, opaque );
        if( ret )
            return ret;
    }
    return VLC_SUCCESS;
}",364.0,374.0,1.0,1.0,11.0,6,4,10,6,10,1,3,4,0,0,,0,1,6,3,3,int
2646,99720,filter_chain_IsEmpty,1,filter_chain_IsEmpty,bool filter_chain_IsEmpty (filter_chain_t*),misc\filter_chain.c,"bool filter_chain_IsEmpty(const filter_chain_t *chain)
{
    return chain->first == NULL;
}",376.0,379.0,1.0,1.0,4.0,2,2,2,2,3,1,1,1,0,0,,0,1,2,1,1,bool
2647,99731,filter_chain_GetFmtOut,1,filter_chain_GetFmtOut,es_format_t filter_chain_GetFmtOut (filter_chain_t*),misc\filter_chain.c,"const es_format_t *filter_chain_GetFmtOut( filter_chain_t *p_chain )
{

    if( p_chain->b_allow_fmt_out_change )
        return &p_chain->fmt_out;

    if( p_chain->last != NULL )
        return &p_chain->last->filter.fmt_out;

    /* Unless filter_chain_Reset has been called we are doomed */
    return &p_chain->fmt_out;
}",381.0,392.0,1.0,1.0,12.0,11,4,6,2,1,5,3,3,2,0,,0,5,2,1,1,es_format_t
2648,99767,FilterChainVideoFilter,1,FilterChainVideoFilter,"picture_t FilterChainVideoFilter (chained_filter_t*,picture_t*)",misc\filter_chain.c,"static picture_t *FilterChainVideoFilter( chained_filter_t *f, picture_t *p_pic )
{
    for( ; f != NULL; f = f->next )
    {
        filter_t *p_filter = &f->filter;
        p_pic = p_filter->pf_video_filter( p_filter, p_pic );
        if( !p_pic )
            break;
        if( f->pending )
        {
            msg_Warn( p_filter, ""dropping pictures"" );
            FilterDeletePictures( f->pending );
        }
        f->pending = p_pic->p_next;
        p_pic->p_next = NULL;
    }
    return p_pic;
}",394.0,411.0,1.0,1.0,18.0,14,5,17,4,2,5,5,6,1,1,,0,4,4,2,2,picture_t
2649,99830,filter_chain_VideoFilter,1,filter_chain_VideoFilter,"picture_t filter_chain_VideoFilter (filter_chain_t*,picture_t*)",misc\filter_chain.c,"picture_t *filter_chain_VideoFilter( filter_chain_t *p_chain, picture_t *p_pic )
{
    if( p_pic )
    {
        p_pic = FilterChainVideoFilter( p_chain->first, p_pic );
        if( p_pic )
            return p_pic;
    }
    for( chained_filter_t *b = p_chain->last; b != NULL; b = b->prev )
    {
        p_pic = b->pending;
        if( !p_pic )
            continue;
        b->pending = p_pic->p_next;
        p_pic->p_next = NULL;

        p_pic = FilterChainVideoFilter( b->next, p_pic );
        if( p_pic )
            return p_pic;
    }
    return NULL;
}",413.0,434.0,1.0,1.0,22.0,15,4,23,4,5,4,7,9,0,2,,0,4,4,2,2,picture_t
2650,99904,filter_chain_VideoFlush,1,filter_chain_VideoFlush,void filter_chain_VideoFlush (filter_chain_t*),misc\filter_chain.c,"void filter_chain_VideoFlush( filter_chain_t *p_chain )
{
    for( chained_filter_t *f = p_chain->first; f != NULL; f = f->next )
    {
        filter_t *p_filter = &f->filter;

        FilterDeletePictures( f->pending );
        f->pending = NULL;

        filter_Flush( p_filter );
    }
}",436.0,447.0,1.0,1.0,12.0,9,4,10,4,3,2,2,2,0,1,,0,1,2,1,1,void
2651,99944,filter_chain_SubSource,1,filter_chain_SubSource,"void filter_chain_SubSource (filter_chain_t*,spu_t*,mtime_t)",misc\filter_chain.c,"void filter_chain_SubSource( filter_chain_t *p_chain, spu_t *spu,
                             mtime_t display_date )
{
    for( chained_filter_t *f = p_chain->first; f != NULL; f = f->next )
    {
        filter_t *p_filter = &f->filter;
        subpicture_t *p_subpic = p_filter->pf_sub_source( p_filter, display_date );
        if( p_subpic )
            spu_PutSubpicture( spu, p_subpic );
    }
}",449.0,459.0,1.0,1.0,11.0,8,4,13,7,1,2,3,4,0,1,,0,1,6,3,3,void
2652,99990,filter_chain_SubFilter,1,filter_chain_SubFilter,"subpicture_t filter_chain_SubFilter (filter_chain_t*,subpicture_t*)",misc\filter_chain.c,"subpicture_t *filter_chain_SubFilter( filter_chain_t *p_chain, subpicture_t *p_subpic )
{
    for( chained_filter_t *f = p_chain->first; f != NULL; f = f->next )
    {
        filter_t *p_filter = &f->filter;

        p_subpic = p_filter->pf_sub_filter( p_filter, p_subpic );

        if( !p_subpic )
            break;
    }
    return p_subpic;
}",461.0,473.0,1.0,1.0,13.0,9,5,12,5,1,1,4,4,0,0,,0,1,4,2,2,subpicture_t
2653,100035,filter_chain_MouseFilter,1,filter_chain_MouseFilter,"int filter_chain_MouseFilter (filter_chain_t*,vlc_mouse_t*,vlc_mouse_t*)",misc\filter_chain.c,"int filter_chain_MouseFilter( filter_chain_t *p_chain, vlc_mouse_t *p_dst, const vlc_mouse_t *p_src )
{
    vlc_mouse_t current = *p_src;

    for( chained_filter_t *f = p_chain->last; f != NULL; f = f->prev )
    {
        filter_t *p_filter = &f->filter;
        vlc_mouse_t *p_mouse = f->mouse;

        if( p_filter->pf_video_mouse && p_mouse )
        {
            vlc_mouse_t old = *p_mouse;
            vlc_mouse_t filtered;

            *p_mouse = current;
            if( p_filter->pf_video_mouse( p_filter, &filtered, &old, &current ) )
                return VLC_EGENERIC;
            current = filtered;
        }
    }

    *p_dst = current;
    return VLC_SUCCESS;
}",475.0,498.0,1.0,1.0,24.0,23,6,27,12,2,1,4,7,0,0,,0,1,6,3,3,int
2654,100118,filter_chain_MouseEvent,1,filter_chain_MouseEvent,"int filter_chain_MouseEvent (filter_chain_t*,vlc_mouse_t*,video_format_t*)",misc\filter_chain.c,"int filter_chain_MouseEvent( filter_chain_t *p_chain,
                             const vlc_mouse_t *p_mouse,
                             const video_format_t *p_fmt )
{
    for( chained_filter_t *f = p_chain->first; f != NULL; f = f->next )
    {
        filter_t *p_filter = &f->filter;

        if( p_filter->pf_sub_mouse )
        {
            vlc_mouse_t old = *f->mouse;
            *f->mouse = *p_mouse;
            if( p_filter->pf_sub_mouse( p_filter, &old, p_mouse, p_fmt ) )
                return VLC_EGENERIC;
        }
    }

    return VLC_SUCCESS;
}",500.0,518.0,1.0,1.0,19.0,16,5,18,9,0,1,4,7,0,0,,0,1,6,3,3,int
2655,100217,fingerprinter_Create,1,fingerprinter_Create,fingerprinter_thread_t fingerprinter_Create (vlc_object_t*),misc\fingerprinter.c,"fingerprinter_thread_t *fingerprinter_Create( vlc_object_t *p_this )
{
    fingerprinter_thread_t *p_fingerprint;

    p_fingerprint = ( fingerprinter_thread_t * )
            vlc_custom_create( p_this, sizeof( *p_fingerprint ), ""fingerprinter"" );
    if( !p_fingerprint )
    {
        msg_Err( p_this, ""unable to create fingerprinter"" );
        return NULL;
    }

    p_fingerprint->p_module = module_need( p_fingerprint, ""fingerprinter"",
                                           NULL, false );
    if( !p_fingerprint->p_module )
    {
        vlc_object_release( p_fingerprint );
        msg_Err( p_this, ""AcoustID fingerprinter not found"" );
        return NULL;
    }

    return p_fingerprint;
}",30.0,52.0,1.0,12.0,23.0,9,6,16,4,0,3,3,3,0,3,,0,2,2,1,1,fingerprinter_thread_t
2656,100271,fingerprinter_Destroy,1,fingerprinter_Destroy,void fingerprinter_Destroy (fingerprinter_thread_t*),misc\fingerprinter.c,"void fingerprinter_Destroy( fingerprinter_thread_t *p_fingerprint )
{
    module_unneed( p_fingerprint, p_fingerprint->p_module );
    vlc_object_release( p_fingerprint );
}",54.0,58.0,1.0,1.0,5.0,1,1,3,1,0,2,1,1,0,2,,0,0,2,1,1,void
2657,100300,fourcc_cmp,1,fourcc_cmp,"int fourcc_cmp (void*,void*)",misc\fourcc.c,"static int fourcc_cmp(const void *key, const void *ent)
{
    return memcmp(key, ent, 4);
}",38.0,41.0,1.0,1.0,4.0,0,0,2,2,0,0,1,1,0,0,,0,0,4,2,2,int
2658,100311,Lookup,1,Lookup,"vlc_fourcc_t Lookup (vlc_fourcc_t,char**,fourcc_mapping*,size_t,fourcc_desc*,size_t)",misc\variables.c,"static variable_t *Lookup( vlc_object_t *obj, const char *psz_name )
{
    vlc_object_internals_t *priv = vlc_internals( obj );
    variable_t **pp_var;

    vlc_mutex_lock(&priv->var_lock);
    pp_var = tfind( &psz_name, &priv->var_root, varcmp );
    return (pp_var != NULL) ? *pp_var : NULL;
}",153.0,161.0,1.0,35.0,9.0,26,7,33,9,12,0,6,9,0,0,,0,0,4,2,2,variable_t
2659,100406,LookupVideo,1,LookupVideo,"vlc_fourcc_t LookupVideo (vlc_fourcc_t,char**)",misc\fourcc.c,"static vlc_fourcc_t LookupVideo(vlc_fourcc_t fourcc, const char **restrict dsc)
{
    return Lookup(fourcc, dsc, mapping_video,
                  sizeof (mapping_video) / sizeof (mapping_video[0]),
                  desc_video, sizeof (desc_video) / sizeof (desc_video[0]));
}",73.0,78.0,1.0,1.0,6.0,6,2,8,4,2,1,1,1,0,1,,0,0,4,2,2,vlc_fourcc_t
2660,100428,LookupAudio,1,LookupAudio,"vlc_fourcc_t LookupAudio (vlc_fourcc_t,char**)",misc\fourcc.c,"static vlc_fourcc_t LookupAudio(vlc_fourcc_t fourcc, const char **restrict dsc)
{
    return Lookup(fourcc, dsc, mapping_audio,
                  sizeof (mapping_audio) / sizeof (mapping_audio[0]),
                  desc_audio, sizeof (desc_audio) / sizeof (desc_audio[0]));
}",80.0,85.0,1.0,1.0,6.0,6,2,8,4,2,1,1,1,0,1,,0,0,4,2,2,vlc_fourcc_t
2661,100450,LookupSpu,1,LookupSpu,"vlc_fourcc_t LookupSpu (vlc_fourcc_t,char**)",misc\fourcc.c,"static vlc_fourcc_t LookupSpu(vlc_fourcc_t fourcc, const char **restrict dsc)
{
    return Lookup(fourcc, dsc, mapping_spu,
                  sizeof (mapping_spu) / sizeof (mapping_spu[0]),
                  desc_spu, sizeof (desc_spu) / sizeof (desc_spu[0]));
}",87.0,92.0,1.0,1.0,6.0,6,2,8,4,2,1,1,1,0,1,,0,0,4,2,2,vlc_fourcc_t
2662,100472,LookupCat,1,LookupCat,"vlc_fourcc_t LookupCat (vlc_fourcc_t,char**,int)",misc\fourcc.c,"static vlc_fourcc_t LookupCat(vlc_fourcc_t fourcc, const char **restrict dsc,
                              int cat)
{
    switch (cat)
    {
        case VIDEO_ES:
            return LookupVideo(fourcc, dsc);
        case AUDIO_ES:
            return LookupAudio(fourcc, dsc);
        case SPU_ES:
            return LookupSpu(fourcc, dsc);
    }

    vlc_fourcc_t ret = LookupVideo(fourcc, dsc);
    if (!ret)
        ret = LookupAudio(fourcc, dsc);
    if (!ret)
        ret = LookupSpu(fourcc, dsc);
    return ret;
}",94.0,113.0,1.0,1.0,20.0,5,2,22,7,2,6,4,4,0,6,,0,3,6,3,3,vlc_fourcc_t
2663,100526,vlc_fourcc_GetCodec,1,vlc_fourcc_GetCodec,"vlc_fourcc_t vlc_fourcc_GetCodec (int,vlc_fourcc_t)",misc\fourcc.c,"vlc_fourcc_t vlc_fourcc_GetCodec(int cat, vlc_fourcc_t fourcc)
{
    vlc_fourcc_t codec = LookupCat(fourcc, NULL, cat);
    return codec ? codec : fourcc;
}",115.0,119.0,1.0,1.0,5.0,2,2,7,4,10,1,1,1,0,1,,0,1,4,2,2,vlc_fourcc_t
2664,100544,vlc_fourcc_GetCodecFromString,1,vlc_fourcc_GetCodecFromString,"vlc_fourcc_t vlc_fourcc_GetCodecFromString (int,char*)",misc\fourcc.c,"vlc_fourcc_t vlc_fourcc_GetCodecFromString( int i_cat, const char *psz_fourcc )
{
    if( !psz_fourcc || strlen(psz_fourcc) != 4 )
        return 0;
    return vlc_fourcc_GetCodec( i_cat,
                                VLC_FOURCC( psz_fourcc[0], psz_fourcc[1],
                                            psz_fourcc[2], psz_fourcc[3] ) );
}",121.0,128.0,1.0,1.0,8.0,7,4,7,2,0,1,2,2,0,1,,0,0,4,2,2,vlc_fourcc_t
2665,100577,vlc_fourcc_GetCodecAudio,1,vlc_fourcc_GetCodecAudio,"vlc_fourcc_t vlc_fourcc_GetCodecAudio (vlc_fourcc_t,int)",misc\fourcc.c,"vlc_fourcc_t vlc_fourcc_GetCodecAudio( vlc_fourcc_t i_fourcc, int i_bits )
{
    const int i_bytes = ( i_bits + 7 ) / 8;

    if( i_fourcc == VLC_FOURCC( 'a', 'f', 'l', 't' ) )
    {
        switch( i_bytes )
        {
        case 4:
            return VLC_CODEC_FL32;
        case 8:
            return VLC_CODEC_FL64;
        default:
            return 0;
        }
    }
    else if( i_fourcc == VLC_FOURCC( 'a', 'r', 'a', 'w' ) )
    {
        switch( i_bytes )
        {
        case 1:
            return VLC_CODEC_U8;
        case 2:
            return VLC_CODEC_S16L;
        case 3:
            return VLC_CODEC_S24L;
        case 4:
            return VLC_CODEC_S32L;
        default:
            return 0;
        }
    }
    else if( i_fourcc == VLC_FOURCC( 't', 'w', 'o', 's' ) )
    {
        switch( i_bytes )
        {
        case 1:
            return VLC_CODEC_S8;
        case 2:
            return VLC_CODEC_S16B;
        case 3:
            return VLC_CODEC_S24B;
        c...",130.0,198.0,1.0,1.0,69.0,4,4,6,5,1,0,3,4,0,0,,0,0,4,2,2,vlc_fourcc_t
2666,100719,vlc_fourcc_GetDescription,1,vlc_fourcc_GetDescription,"const char* vlc_fourcc_GetDescription (int,vlc_fourcc_t)",misc\fourcc.c,"const char *vlc_fourcc_GetDescription(int cat, vlc_fourcc_t fourcc)
{
    const char *ret;

    return LookupCat(fourcc, &ret, cat) ? ret : """";
}",200.0,205.0,1.0,1.0,6.0,2,2,4,3,1,1,1,1,0,1,,0,0,4,2,2,const char*
2667,101940,GetFallback,1,GetFallback,"vlc_fourcc_t GetFallback (vlc_fourcc_t,vlc_fourcc_t[]*,vlc_fourcc_t[])",misc\fourcc.c,"static const vlc_fourcc_t *GetFallback( vlc_fourcc_t i_fourcc,
                                        const vlc_fourcc_t *pp_fallback[],
                                        const vlc_fourcc_t p_list[] )
{
    for( unsigned i = 0; pp_fallback[i]; i++ )
    {
        if( pp_fallback[i][0] == i_fourcc )
            return pp_fallback[i];
    }
    return p_list;
}",597.0,607.0,1.0,1.0,11.0,6,3,9,4,2,0,3,4,0,0,,0,0,6,3,3,vlc_fourcc_t
2668,101974,vlc_fourcc_GetYUVFallback,1,vlc_fourcc_GetYUVFallback,vlc_fourcc_t vlc_fourcc_GetYUVFallback (vlc_fourcc_t),misc\fourcc.c,"const vlc_fourcc_t *vlc_fourcc_GetYUVFallback( vlc_fourcc_t i_fourcc )
{
    return GetFallback( i_fourcc, pp_YUV_fallback, p_list_YUV );
}",609.0,612.0,1.0,1.0,4.0,0,0,3,3,0,3,1,1,0,1,,0,2,2,1,1,vlc_fourcc_t
2669,101984,vlc_fourcc_GetRGBFallback,1,vlc_fourcc_GetRGBFallback,vlc_fourcc_t vlc_fourcc_GetRGBFallback (vlc_fourcc_t),misc\fourcc.c,"const vlc_fourcc_t *vlc_fourcc_GetRGBFallback( vlc_fourcc_t i_fourcc )
{
    return GetFallback( i_fourcc, pp_RGB_fallback, p_RGB32_fallback );
}",613.0,616.0,1.0,1.0,4.0,0,0,3,3,0,3,1,1,0,1,,0,2,2,1,1,vlc_fourcc_t
2670,101994,vlc_fourcc_AreUVPlanesSwapped,1,vlc_fourcc_AreUVPlanesSwapped,"bool vlc_fourcc_AreUVPlanesSwapped (vlc_fourcc_t,vlc_fourcc_t)",misc\fourcc.c,"bool vlc_fourcc_AreUVPlanesSwapped( vlc_fourcc_t a, vlc_fourcc_t b )
{
    static const vlc_fourcc_t pp_swapped[][4] = {
        { VLC_CODEC_YV12, VLC_CODEC_I420, VLC_CODEC_J420, 0 },
        { VLC_CODEC_YV9,  VLC_CODEC_I410, 0 },
        { 0 }
    };

    for( int i = 0; pp_swapped[i][0]; i++ )
    {
        if( pp_swapped[i][0] == b )
        {
            vlc_fourcc_t t = a;
            a = b;
            b = t;
        }
        if( pp_swapped[i][0] != a )
            continue;
        for( int j = 1; pp_swapped[i][j]; j++ )
        {
            if( pp_swapped[i][j] == b )
                return true;
        }
    }
    return false;
}",618.0,643.0,1.0,1.0,26.0,23,5,31,13,0,0,7,11,0,0,,0,0,4,2,2,bool
2671,102085,vlc_fourcc_IsYUV,1,vlc_fourcc_IsYUV,bool vlc_fourcc_IsYUV (vlc_fourcc_t),misc\fourcc.c,"bool vlc_fourcc_IsYUV(vlc_fourcc_t fcc)
{
    for( unsigned i = 0; p_list_YUV[i]; i++ )
    {
        if( p_list_YUV[i] == fcc )
            return true;
    }
    return false;
}",645.0,653.0,1.0,1.0,9.0,4,3,8,5,2,2,3,4,2,0,,0,2,2,1,1,bool
2672,104764,vlc_fourcc_GetChromaDescription,1,vlc_fourcc_GetChromaDescription,vlc_chroma_description_t vlc_fourcc_GetChromaDescription (vlc_fourcc_t),misc\fourcc.c,"const vlc_chroma_description_t *vlc_fourcc_GetChromaDescription( vlc_fourcc_t i_fourcc )
{
    for( unsigned i = 0; p_list_chroma_description[i].p_fourcc[0]; i++ )
    {
        const vlc_fourcc_t *p_fourcc = p_list_chroma_description[i].p_fourcc;
        for( unsigned j = 0; j < 4 && p_fourcc[j] != 0; j++ )
        {
            if( p_fourcc[j] == i_fourcc )
                return &p_list_chroma_description[i].description;
        }
    }
    return NULL;
}",781.0,793.0,1.0,1.0,13.0,17,8,16,6,2,3,4,7,1,0,,0,3,2,1,1,vlc_chroma_description_t
2673,104878,cmp_entry,1,cmp_entry,"int cmp_entry (void*,void*)",misc\fourcc_gen.c,"static int cmp_entry(const void *a, const void *b)
{
    const struct entry *ea = a, *eb = b;
    int d = memcmp(ea->alias, eb->alias, 4);
    if (d == 0)
        d = memcmp(ea->fourcc, eb->fourcc, 4);
    return d;
}",58.0,65.0,1.0,1.0,8.0,9,3,12,5,0,4,2,2,0,0,,0,4,4,2,2,int
2674,104920,process_list,1,process_list,"void process_list (char*,staticentry_t*,size_t)",misc\fourcc_gen.c,"static void process_list(const char *name, const staticentry_t *list, size_t n)
{
    struct entry *entries = malloc(sizeof (*entries) * n);
    if (entries == NULL)
        abort();

    const staticentry_t *klass = NULL;

    for (size_t i = 0; i < n; i++)
    {
        if (list[i].klass)
            klass = &list[i];

        if (klass == NULL)
        {
            fprintf(stderr, ""Error: FourCC \""%.4s\"" not mapped!\n"",
                    list[i].fourcc);
            exit(1);
        }

        memcpy(entries[i].fourcc, klass->fourcc, 4);
        memcpy(entries[i].alias, list[i].fourcc, 4);
        entries[i].desc = list[i].description;
    }

    qsort(entries, n, sizeof (*entries), cmp_entry);

    size_t dups = 0;
    for (size_t i = 1; i < n; i++)
        if (!memcmp(entries[i - 1].alias, entries[i].alias, 4)
         && memcmp(entries[i - 1].fourcc, entries[i].fourcc, 4))
        {
            fprintf(stderr, ""Error: FourCC alias \""%.4s\"" conflict: ""
                    ""\...",67.0,133.0,1.0,1.0,67.0,84,12,84,9,3,1,13,15,0,0,,0,1,6,3,3,void
2675,105262,main,1,main,int main (void),misc\fourcc_gen.c,"int main(void)
{
    puts(""/* This file is generated automatically. DO NOT EDIT! */"");
    puts(""struct fourcc_mapping {"");
    puts(""    union { unsigned char alias_str[4]; vlc_fourcc_t alias; };"");
    puts(""    union { unsigned char fourcc_str[4]; vlc_fourcc_t fourcc; };"");
    puts(""};"");
    puts(""struct fourcc_desc {"");
    puts(""    union { unsigned char alias_str[4]; vlc_fourcc_t alias; };"");
    puts(""    const char desc[52];"");
    puts(""};"");

#define p(t) \
    process_list(#t, p_list_##t, \
                 sizeof (p_list_##t) / sizeof ((p_list_##t)[0]))
    p(video);
    p(audio);
    p(spu);
    return 0;
}",135.0,154.0,1.0,4.0,20.0,12,3,9,3,0,3,1,1,0,3,,0,0,2,1,1,int
2676,108252,cookie_get_attribute_value,1,cookie_get_attribute_value,"char* cookie_get_attribute_value (char*,char*)",misc\httpcookies.c,"static char *cookie_get_attribute_value( const char *cookie, const char *attr )
{
    size_t attrlen = strlen( attr );
    const char * str = strchr( cookie, ';' );
    while( str )
    {
        /* skip ; and blank */
        str++;
        str = str + strspn( str, "" "" );

        if( !vlc_ascii_strncasecmp( str, attr, attrlen )
         && (str[attrlen] == '=') )
        {
            str += attrlen + 1;
            size_t value_length = strcspn( str, "";"" );
            return strndup( str, value_length );
        }

        str = strchr( str, ';' );
    }
    return NULL;
}",48.0,69.0,1.0,1.0,22.0,13,8,23,6,2,0,3,4,0,0,,0,0,4,2,2,char*
2677,108316,cookie_has_attribute,1,cookie_has_attribute,"bool cookie_has_attribute (char*,char*)",misc\httpcookies.c,"static bool cookie_has_attribute( const char *cookie, const char *attr )
{
    size_t attrlen = strlen(attr);
    const char * str = strchr(cookie, ';');
    while( str )
    {
        /* skip ; and blank */
        str++;
        str += strspn( str, "" "" );

        if( !vlc_ascii_strncasecmp( str, attr, attrlen )
         && (str[attrlen] == '=' || str[attrlen] == ';' || str[attrlen] == '\0') )
            return true;

        str = strchr(str, ';');
    }
    return false;
}",71.0,88.0,1.0,1.0,18.0,15,8,21,6,1,0,3,4,0,0,,0,0,4,2,2,bool
2678,108377,cookie_get_domain,1,cookie_get_domain,char* cookie_get_domain (char*),misc\httpcookies.c,"static char *cookie_get_domain( const char *cookie )
{
    char *domain = cookie_get_attribute_value( cookie, ""domain"" );
    if( domain == NULL )
        return NULL;

    if( domain[0] == '.' )
    {
        const char *real_domain = domain + strspn( domain, ""."" );
        memmove( domain, real_domain, strlen( real_domain ) + 1 );
    }
    return domain;
}",91.0,103.0,1.0,1.0,13.0,7,4,13,4,1,1,3,3,0,1,,0,1,2,1,1,char*
2679,108419,cookie_domain_matches,1,cookie_domain_matches,"bool cookie_domain_matches (http_cookie_t*,char*)",misc\httpcookies.c,"static bool cookie_domain_matches( const http_cookie_t *cookie,
                                   const char *host )
{
    // TODO: should convert domain names to punycode before comparing

    if (host == NULL)
        return false;
    if ( vlc_ascii_strcasecmp(cookie->psz_domain, host) == 0 )
        return true;
    else if ( cookie->b_host_only )
        return false;

    size_t host_len = strlen(host);
    size_t cookie_domain_len = strlen(cookie->psz_domain);
    bool is_suffix = false, has_dot_before_suffix = false;

    if( host_len > cookie_domain_len )
    {
        size_t i = host_len - cookie_domain_len;

        is_suffix = vlc_ascii_strcasecmp( &host[i], cookie->psz_domain ) == 0;
        has_dot_before_suffix = host[i-1] == '.';
    }

    bool host_is_ipv4 = strspn(host, ""0123456789."") == host_len;
    bool host_is_ipv6 = strchr(host, ':') != NULL;
    return is_suffix && has_dot_before_suffix &&
        !( host_is_ipv4 || host_is_ipv6 );
}",105.0,133.0,1.0,1.0,29.0,28,11,36,12,2,3,4,4,1,0,,0,3,4,2,2,bool
2680,108529,cookie_get_path,1,cookie_get_path,char* cookie_get_path (char*),misc\httpcookies.c,"static char *cookie_get_path(const char *cookie)
{
    return cookie_get_attribute_value(cookie, ""path"");
}",135.0,138.0,1.0,1.0,4.0,0,0,1,1,1,1,1,1,0,1,,0,0,2,1,1,char*
2681,108538,cookie_path_matches,1,cookie_path_matches,"bool cookie_path_matches (http_cookie_t*,char*)",misc\httpcookies.c,"static bool cookie_path_matches( const http_cookie_t * cookie, const char *uripath )
{
    if (uripath == NULL )
        return false;
    else if ( strcmp(cookie->psz_path, uripath) == 0 )
        return true;

    size_t path_len = strlen( uripath );
    size_t prefix_len = strlen( cookie->psz_path );
    return ( path_len > prefix_len ) &&
        ( strncmp(uripath, cookie->psz_path, prefix_len) == 0 ) &&
        ( uripath[prefix_len - 1] == '/' || uripath[prefix_len] == '/' );
}",140.0,152.0,1.0,1.0,13.0,15,8,16,6,1,2,2,2,0,0,,0,2,4,2,2,bool
2682,108603,cookie_should_be_sent,1,cookie_should_be_sent,"bool cookie_should_be_sent (http_cookie_t*,bool,char*,char*)",misc\httpcookies.c,"static bool cookie_should_be_sent(const http_cookie_t *cookie, bool secure,
                                  const char *host, const char *path)
{
    bool protocol_ok = secure || !cookie->b_secure;
    bool domain_ok = cookie_domain_matches(cookie, host);
    bool path_ok = cookie_path_matches(cookie, path);
    return protocol_ok && domain_ok && path_ok;
}",154.0,161.0,1.0,1.0,8.0,8,5,12,7,1,3,1,1,0,2,,0,3,8,4,4,bool
2683,108638,cookie_default_path,1,cookie_default_path,char* cookie_default_path (char*),misc\httpcookies.c,"static char *cookie_default_path( const char *request_path )
{
    if ( request_path == NULL || request_path[0] != '/' )
        return strdup(""/"");

    char *path;
    const char *query_start = strchr( request_path, '?' );
    if ( query_start != NULL )
        path = strndup( request_path, query_start - request_path );
    else
        path = strdup( request_path );

    if ( path == NULL )
        return NULL;

    char *last_slash = strrchr(path, '/');
    assert(last_slash != NULL);
    if ( last_slash == path )
        path[1] = '\0';
    else
        *last_slash = '\0';

    return path;
}",163.0,186.0,1.0,1.0,24.0,14,6,22,5,1,0,5,5,0,0,,0,0,2,1,1,char*
2684,108717,cookie_destroy,1,cookie_destroy,void cookie_destroy (http_cookie_t*),misc\httpcookies.c,"static void cookie_destroy(http_cookie_t *cookie)
{
    assert(cookie != NULL);
    free(cookie->psz_name);
    free(cookie->psz_value);
    free(cookie->psz_domain);
    free(cookie->psz_path);
    free(cookie);
}",188.0,196.0,1.0,1.0,9.0,5,2,7,2,4,4,1,1,0,0,,0,4,2,1,1,void
2685,108746,cookie_parse,1,cookie_parse,"http_cookie_t cookie_parse (char*,char*,char*)",misc\httpcookies.c,"static http_cookie_t *cookie_parse(const char *value,
                                   const char *host, const char *path)
{
    http_cookie_t *cookie = malloc(sizeof (*cookie));
    if (unlikely(cookie == NULL))
        return NULL;

    cookie->psz_domain = NULL;
    cookie->psz_path = NULL;

    /* Get the NAME=VALUE part of the Cookie */
    size_t value_length = strcspn(value, "";"");
    const char *p = memchr(value, '=', value_length);

    if (p != NULL)
    {
        cookie->psz_name = strndup(value, p - value);
        p++;
        cookie->psz_value = strndup(p, value_length - (p - value));
        if (unlikely(cookie->psz_value == NULL))
            goto error;
    }
    else
    {
        cookie->psz_name = strndup(value, value_length);
        cookie->psz_value = NULL;
    }

    if (unlikely(cookie->psz_name == NULL))
        goto error;

    /* Cookie name is a token; it cannot be empty. */
    if (cookie->psz_name[0] == '\0')
        goto error;

    /* Get domain */...",199.0,264.0,1.0,1.0,66.0,46,9,54,8,1,22,15,13,7,5,,0,21,6,3,3,http_cookie_t
2686,108945,vlc_http_cookies_new,1,vlc_http_cookies_new,vlc_http_cookie_jar_t vlc_http_cookies_new (void),misc\httpcookies.c,"vlc_http_cookie_jar_t * vlc_http_cookies_new(void)
{
    vlc_http_cookie_jar_t * jar = malloc( sizeof( vlc_http_cookie_jar_t ) );
    if ( unlikely(jar == NULL) )
        return NULL;

    vlc_array_init( &jar->cookies );
    vlc_mutex_init( &jar->lock );

    return jar;
}",272.0,282.0,1.0,1.0,11.0,7,5,8,3,1,3,2,2,0,1,,0,2,2,1,1,vlc_http_cookie_jar_t
2687,108976,vlc_http_cookies_destroy,1,vlc_http_cookies_destroy,void vlc_http_cookies_destroy (vlc_http_cookie_jar_t*),misc\httpcookies.c,"void vlc_http_cookies_destroy( vlc_http_cookie_jar_t * p_jar )
{
    if ( !p_jar )
        return;

    for( size_t i = 0; i < vlc_array_count( &p_jar->cookies ); i++ )
        cookie_destroy( vlc_array_item_at_index( &p_jar->cookies, i ) );

    vlc_array_clear( &p_jar->cookies );
    vlc_mutex_destroy( &p_jar->lock );

    free( p_jar );
}",284.0,296.0,1.0,1.0,13.0,9,5,7,2,1,4,3,3,1,1,,0,3,2,1,1,void
2688,109020,vlc_http_cookies_store,1,vlc_http_cookies_store,"bool vlc_http_cookies_store (vlc_http_cookie_jar_t*,char*,char*,char*)",misc\httpcookies.c,"bool vlc_http_cookies_store(vlc_http_cookie_jar_t *p_jar, const char *cookies,
                            const char *host, const char *path)
{
    assert(host != NULL);
    assert(path != NULL);

    http_cookie_t *cookie = cookie_parse(cookies, host, path);
    if (cookie == NULL)
        return false;

    /* Check if a cookie from host should be added to the cookie jar */
    // FIXME: should check if domain is one of ""public suffixes"" at
    // http://publicsuffix.org/. The purpose of this check is to
    // prevent a host from setting a ""too wide"" cookie, for example
    // ""example.com"" should not be able to set a cookie for ""com"".
    // The current implementation prevents all top-level domains.
    if (strchr(cookie->psz_domain, '.') == NULL
     || !cookie_domain_matches(cookie, host))
    {
        cookie_destroy(cookie);
        return false;
    }

    vlc_mutex_lock( &p_jar->lock );

    for( size_t i = 0; i < vlc_array_count( &p_jar->cookies ); i++ )
    {
        ht...",298.0,351.0,1.0,1.0,54.0,43,9,49,13,0,23,7,7,3,7,,0,18,8,4,4,bool
2689,109186,vlc_http_cookies_fetch,1,vlc_http_cookies_fetch,"char* vlc_http_cookies_fetch (vlc_http_cookie_jar_t*,bool,char*,char*)",misc\httpcookies.c,"char *vlc_http_cookies_fetch(vlc_http_cookie_jar_t *p_jar, bool secure,
                             const char *host, const char *path)
{
    char *psz_cookiebuf = NULL;

    vlc_mutex_lock( &p_jar->lock );

    for( size_t i = 0; i < vlc_array_count( &p_jar->cookies ); i++ )
    {
        const http_cookie_t * cookie = vlc_array_item_at_index( &p_jar->cookies, i );
        if (cookie_should_be_sent(cookie, secure, host, path))
        {
            char *psz_updated_buf = NULL;
            if ( asprintf(&psz_updated_buf, ""%s%s%s=%s"",
                          psz_cookiebuf ? psz_cookiebuf : """",
                          psz_cookiebuf ? ""; "" : """",
                          cookie->psz_name ? cookie->psz_name : """",
                          cookie->psz_value ? cookie->psz_value : """") == -1 )
            {
                // TODO: report error
                free( psz_cookiebuf );
                vlc_mutex_unlock( &p_jar->lock );
                return NULL;
            }
          ...",353.0,385.0,1.0,1.0,33.0,27,7,31,9,0,13,4,7,6,4,,0,10,8,4,4,char*
2690,109326,ImageRead,1,ImageRead,"picture_t* ImageRead (image_handler_t*,block_t*,video_format_t*,video_format_t*)",misc\image.c,"static picture_t *ImageRead( image_handler_t *p_image, block_t *p_block,
                             const video_format_t *p_fmt_in,
                             video_format_t *p_fmt_out )
{
    picture_t *p_pic = NULL;

    /* Check if we can reuse the current decoder */
    if( p_image->p_dec &&
        p_image->p_dec->fmt_in.i_codec != p_fmt_in->i_chroma )
    {
        DeleteDecoder( p_image->p_dec );
        p_image->p_dec = 0;
    }

    /* Start a decoder */
    if( !p_image->p_dec )
    {
        p_image->p_dec = CreateDecoder( p_image->p_parent, p_fmt_in );
        if( !p_image->p_dec )
        {
            block_Release(p_block);
            return NULL;
        }
        if( p_image->p_dec->fmt_out.i_cat != VIDEO_ES )
        {
            DeleteDecoder( p_image->p_dec );
            p_image->p_dec = NULL;
            block_Release(p_block);
            return NULL;
        }
        p_image->p_dec->pf_queue_video = ImageQueueVideo;
        p_image->p_dec->p_queue_ctx ...",131.0,271.0,1.0,1.0,141.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,picture_t
2691,109334,ImageReadUrl,1,ImageReadUrl,"picture_t* ImageReadUrl (image_handler_t*,char*,video_format_t*,video_format_t*)",misc\image.c,"static picture_t *ImageReadUrl( image_handler_t *p_image, const char *psz_url,
                                video_format_t *p_fmt_in,
                                video_format_t *p_fmt_out )
{
    block_t *p_block;
    picture_t *p_pic;
    stream_t *p_stream = NULL;
    uint64_t i_size;

    p_stream = vlc_stream_NewURL( p_image->p_parent, psz_url );

    if( !p_stream )
    {
        msg_Dbg( p_image->p_parent, ""could not open %s for reading"",
                 psz_url );
        return NULL;
    }

    if( vlc_stream_GetSize( p_stream, &i_size ) || i_size > SSIZE_MAX )
    {
        msg_Dbg( p_image->p_parent, ""could not read %s"", psz_url );
        goto error;
    }

    p_block = vlc_stream_Block( p_stream, i_size );
    if( p_block == NULL )
        goto error;

    if( !p_fmt_in->i_chroma )
    {
        char *psz_mime = stream_MimeType( p_stream );
        if( psz_mime != NULL )
        {
            p_fmt_in->i_chroma = image_Mime2Fourcc( psz_mime );
            free( ...",273.0,324.0,1.0,1.0,52.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,picture_t
2692,109342,ImageWrite,1,ImageWrite,"block_t* ImageWrite (image_handler_t*,picture_t*,video_format_t*,video_format_t*)",misc\image.c,"static block_t *ImageWrite( image_handler_t *p_image, picture_t *p_pic,
                            const video_format_t *p_fmt_in,
                            const video_format_t *p_fmt_out )
{
    block_t *p_block;

    /* Check if we can reuse the current encoder */
    if( p_image->p_enc &&
        ( p_image->p_enc->fmt_out.i_codec != p_fmt_out->i_chroma ||
          p_image->p_enc->fmt_out.video.i_width != p_fmt_out->i_width ||
          p_image->p_enc->fmt_out.video.i_height != p_fmt_out->i_height ) )
    {
        DeleteEncoder( p_image->p_enc );
        p_image->p_enc = 0;
    }

    /* Start an encoder */
    if( !p_image->p_enc )
    {
        p_image->p_enc = CreateEncoder( p_image->p_parent,
                                        p_fmt_in, p_fmt_out );
        if( !p_image->p_enc ) return NULL;
    }

    /* Check if we need chroma conversion or resizing */
    if( p_image->p_enc->fmt_in.video.i_chroma != p_fmt_in->i_chroma ||
        p_image->p_enc->fmt_in.video.i_wid...",354.0,448.0,1.0,1.0,95.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,block_t
2693,109350,ImageWriteUrl,1,ImageWriteUrl,"int ImageWriteUrl (image_handler_t*,picture_t*,video_format_t*,video_format_t*,char*)",misc\image.c,"static int ImageWriteUrl( image_handler_t *p_image, picture_t *p_pic,
                          const video_format_t *p_fmt_in, video_format_t *p_fmt_out,
                          const char *psz_url )
{
    block_t *p_block;
    FILE *file;

    if( !p_fmt_out->i_chroma )
    {
        /* Try to guess format from file name */
        p_fmt_out->i_chroma = image_Ext2Fourcc( psz_url );
    }

    file = vlc_fopen( psz_url, ""wb"" );
    if( !file )
    {
        msg_Err( p_image->p_parent, ""%s: %s"", psz_url, vlc_strerror_c(errno) );
        return VLC_EGENERIC;
    }

    p_block = ImageWrite( p_image, p_pic, p_fmt_in, p_fmt_out );

    int err = 0;
    if( p_block )
    {
        if( fwrite( p_block->p_buffer, p_block->i_buffer, 1, file ) != 1 )
            err = errno;
        block_Release( p_block );
    }

    if( fclose( file ) && !err )
        err = errno;

    if( err )
    {
       errno = err;
       msg_Err( p_image->p_parent, ""%s: %s"", psz_url, vlc_strerror_c(errno) );
  ...",450.0,490.0,1.0,1.0,41.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,int
2694,109359,ImageConvert,1,ImageConvert,"picture_t* ImageConvert (image_handler_t*,picture_t*,video_format_t*,video_format_t*)",misc\image.c,"static picture_t *ImageConvert( image_handler_t *p_image, picture_t *p_pic,
                                const video_format_t *p_fmt_in,
                                video_format_t *p_fmt_out )
{
    picture_t *p_pif;

    if( !p_fmt_out->i_width && !p_fmt_out->i_height &&
        p_fmt_out->i_sar_num && p_fmt_out->i_sar_den &&
        p_fmt_out->i_sar_num * p_fmt_in->i_sar_den !=
        p_fmt_out->i_sar_den * p_fmt_in->i_sar_num )
    {
        p_fmt_out->i_width =
            p_fmt_in->i_sar_num * (int64_t)p_fmt_out->i_sar_den *
            p_fmt_in->i_width / p_fmt_in->i_sar_den / p_fmt_out->i_sar_num;
        p_fmt_out->i_visible_width =
            p_fmt_in->i_sar_num * (int64_t)p_fmt_out->i_sar_den *
            p_fmt_in->i_visible_width / p_fmt_in->i_sar_den /
            p_fmt_out->i_sar_num;
    }

    if( !p_fmt_out->i_chroma ) p_fmt_out->i_chroma = p_fmt_in->i_chroma;
    if( !p_fmt_out->i_width )
        p_fmt_out->i_width = p_fmt_out->i_visible_width = p_fmt_in->...",497.0,572.0,1.0,1.0,76.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,picture_t
2695,109378,CreateEncoder,1,CreateEncoder,"encoder_t* CreateEncoder (vlc_object_t*,video_format_t*,video_format_t*)",misc\image.c,"static encoder_t *CreateEncoder( vlc_object_t *p_this, const video_format_t *fmt_in,
                                 const video_format_t *fmt_out )
{
    encoder_t *p_enc;

    p_enc = sout_EncoderCreate( p_this );
    if( p_enc == NULL )
        return NULL;

    p_enc->p_module = NULL;
    es_format_InitFromVideo( &p_enc->fmt_in, fmt_in );

    if( p_enc->fmt_in.video.i_visible_width == 0 ||
        p_enc->fmt_in.video.i_visible_height == 0 ||
        p_enc->fmt_out.video.i_visible_width == 0 ||
        p_enc->fmt_out.video.i_visible_height == 0 )
    {
        if( fmt_out->i_width > 0 && fmt_out->i_height > 0 )
        {
            p_enc->fmt_in.video.i_width = fmt_out->i_width;
            p_enc->fmt_in.video.i_height = fmt_out->i_height;

            if( fmt_out->i_visible_width > 0 &&
                fmt_out->i_visible_height > 0 )
            {
                p_enc->fmt_in.video.i_visible_width = fmt_out->i_visible_width;
                p_enc->fmt_in.video.i_visible_heig...",716.0,783.0,1.0,1.0,68.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,encoder_t
2696,109385,DeleteEncoder,1,DeleteEncoder,void DeleteEncoder (encoder_t*),misc\image.c,"static void DeleteEncoder( encoder_t * p_enc )
{
    if( p_enc->p_module ) module_unneed( p_enc, p_enc->p_module );

    es_format_Clean( &p_enc->fmt_in );
    es_format_Clean( &p_enc->fmt_out );

    vlc_object_release( p_enc );
    p_enc = NULL;
}",785.0,794.0,1.0,1.0,10.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
2697,109397,DeleteFilter,1,DeleteFilter,void DeleteFilter (filter_t*),misc\image.c,"static void DeleteFilter( filter_t * p_filter )
{
    if( p_filter->p_module ) module_unneed( p_filter, p_filter->p_module );

    es_format_Clean( &p_filter->fmt_in );
    es_format_Clean( &p_filter->fmt_out );

    vlc_object_release( p_filter );
}",830.0,838.0,1.0,1.0,9.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
2698,109402,image_Type2Fourcc,1,image_Type2Fourcc,vlc_fourcc_t image_Type2Fourcc (char*),misc\image.c,"vlc_fourcc_t image_Type2Fourcc( const char *psz_type )
{
    for( unsigned i = 0; i < ARRAY_SIZE(ext_table); i++ )
        if( !strcasecmp( ext_table[i].psz_ext, psz_type ) )
            return ext_table[i].i_codec;

    return 0;
}",608.0,615.0,1.0,1.0,8.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,vlc_fourcc_t
2699,109407,image_Ext2Fourcc,1,image_Ext2Fourcc,vlc_fourcc_t image_Ext2Fourcc (char*),misc\image.c,"vlc_fourcc_t image_Ext2Fourcc( const char *psz_name )
{
    psz_name = strrchr( psz_name, '.' );
    if( !psz_name ) return 0;
    psz_name++;

    return image_Type2Fourcc( psz_name );
}",617.0,624.0,1.0,1.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,vlc_fourcc_t
2700,109412,image_HandlerCreate,1,image_HandlerCreate,image_handler_t image_HandlerCreate (vlc_object_t*),misc\image.c,"image_handler_t *image_HandlerCreate( vlc_object_t *p_this )
{
    image_handler_t *p_image = calloc( 1, sizeof(image_handler_t) );
    if( !p_image )
        return NULL;

    p_image->p_parent = p_this;

    p_image->pf_read = ImageRead;
    p_image->pf_read_url = ImageReadUrl;
    p_image->pf_write = ImageWrite;
    p_image->pf_write_url = ImageWriteUrl;
    p_image->pf_convert = ImageConvert;

    p_image->outfifo = picture_fifo_New();

    return p_image;
}",82.0,99.0,1.0,1.0,18.0,17,4,15,6,3,1,2,2,0,1,,0,1,2,1,1,image_handler_t
2701,109467,image_HandlerDelete,1,image_HandlerDelete,void image_HandlerDelete (image_handler_t*),misc\image.c,"void image_HandlerDelete( image_handler_t *p_image )
{
    if( !p_image ) return;

    if( p_image->p_dec ) DeleteDecoder( p_image->p_dec );
    if( p_image->p_enc ) DeleteEncoder( p_image->p_enc );
    if( p_image->p_filter ) DeleteFilter( p_image->p_filter );

    picture_fifo_Delete( p_image->outfifo );

    free( p_image );
    p_image = NULL;
}",105.0,117.0,1.0,1.0,13.0,9,3,11,2,3,4,5,5,0,4,,0,0,2,1,1,void
2702,109513,ImageQueueVideo,1,ImageQueueVideo,"int ImageQueueVideo (decoder_t*,picture_t*)",misc\image.c,"static int ImageQueueVideo( decoder_t *p_dec, picture_t *p_pic )
{
    image_handler_t *p_image = p_dec->p_queue_ctx;
    picture_fifo_Push( p_image->outfifo, p_pic );
    return 0;
}",124.0,129.0,1.0,1.0,6.0,3,2,4,3,0,1,1,1,0,1,,0,0,4,2,2,int
2703,110301,BitMapFormatIsSimilar,1,BitMapFormatIsSimilar,"bool BitMapFormatIsSimilar (video_format_t*,video_format_t*)",misc\image.c,"static bool BitMapFormatIsSimilar( const video_format_t *f1,
                                   const video_format_t *f2 )
{
    if( f1->i_chroma == VLC_CODEC_RGB15 ||
        f1->i_chroma == VLC_CODEC_RGB16 ||
        f1->i_chroma == VLC_CODEC_RGB24 ||
        f1->i_chroma == VLC_CODEC_RGB32 )
    {
        video_format_t v1 = *f1;
        video_format_t v2 = *f2;

        video_format_FixRgb( &v1 );
        video_format_FixRgb( &v2 );

        if( v1.i_rmask != v2.i_rmask ||
            v1.i_gmask != v2.i_gmask ||
            v1.i_bmask != v2.i_bmask )
            return false;
    }
    return true;
}",327.0,347.0,1.0,1.0,21.0,28,8,22,10,0,2,3,4,0,2,,0,0,4,2,2,bool
2704,111392,image_Mime2Fourcc,1,image_Mime2Fourcc,vlc_fourcc_t image_Mime2Fourcc (char*),misc\image.c,"vlc_fourcc_t image_Mime2Fourcc( const char *psz_mime )
{
    for( int i = 0; mime_table[i].i_codec; i++ )
        if( !strcmp( psz_mime, mime_table[i].psz_mime ) )
            return mime_table[i].i_codec;
    return 0;
}",652.0,658.0,1.0,1.0,7.0,3,3,3,2,0,1,2,2,1,0,,0,1,2,1,1,vlc_fourcc_t
2705,111428,video_update_format,1,video_update_format,int video_update_format (decoder_t*),misc\image.c,"static int video_update_format( decoder_t *p_dec )
{
    p_dec->fmt_out.video.i_chroma = p_dec->fmt_out.i_codec;
    return 0;
}",660.0,664.0,1.0,1.0,5.0,6,3,2,1,0,0,1,1,0,0,,0,0,2,1,1,int
2706,111448,video_new_buffer,1,video_new_buffer,picture_t video_new_buffer (decoder_t*),misc\image.c,"static picture_t *video_new_buffer( decoder_t *p_dec )
{
    return picture_NewFromFormat( &p_dec->fmt_out.video );
}",666.0,669.0,1.0,1.0,4.0,3,3,1,1,0,1,1,1,0,1,,0,0,2,1,1,picture_t
2707,111966,filter_new_picture,1,filter_new_picture,picture_t filter_new_picture (filter_t*),misc\image.c,"static picture_t *filter_new_picture( filter_t *p_filter )
{
    return picture_NewFromFormat( &p_filter->fmt_out.video );
}",796.0,799.0,1.0,1.0,4.0,3,3,1,1,0,1,1,1,0,1,,0,0,2,1,1,picture_t
2708,112139,vlc_interrupt_init,1,vlc_interrupt_init,void vlc_interrupt_init (vlc_interrupt_t*),misc\interrupt.c,"void vlc_interrupt_init(vlc_interrupt_t *ctx)
{
    vlc_mutex_init(&ctx->lock);
    ctx->interrupted = false;
    atomic_init(&ctx->killed, false);
    ctx->callback = NULL;
}",51.0,57.0,1.0,1.0,7.0,8,3,7,3,2,1,1,1,0,1,,0,0,2,1,1,void
2709,112165,vlc_interrupt_create,1,vlc_interrupt_create,vlc_interrupt_t vlc_interrupt_create (void),misc\interrupt.c,"vlc_interrupt_t *vlc_interrupt_create(void)
{
    vlc_interrupt_t *ctx = malloc(sizeof (*ctx));
    if (likely(ctx != NULL))
        vlc_interrupt_init(ctx);
    return ctx;
}",59.0,65.0,1.0,1.0,7.0,4,4,6,2,2,1,2,2,0,1,,0,0,2,1,1,vlc_interrupt_t
2710,112187,vlc_interrupt_deinit,1,vlc_interrupt_deinit,void vlc_interrupt_deinit (vlc_interrupt_t*),misc\interrupt.c,"void vlc_interrupt_deinit(vlc_interrupt_t *ctx)
{
    assert(ctx->callback == NULL);
    vlc_mutex_destroy(&ctx->lock);
}",71.0,75.0,1.0,1.0,5.0,4,3,3,2,4,1,1,1,0,1,,0,0,2,1,1,void
2711,112203,vlc_interrupt_destroy,1,vlc_interrupt_destroy,void vlc_interrupt_destroy (vlc_interrupt_t*),misc\interrupt.c,"void vlc_interrupt_destroy(vlc_interrupt_t *ctx)
{
    assert(ctx != NULL);
    vlc_interrupt_deinit(ctx);
    free(ctx);
}",77.0,82.0,1.0,1.0,6.0,1,1,4,2,4,1,1,1,0,1,,0,0,2,1,1,void
2712,112216,vlc_interrupt_raise,1,vlc_interrupt_raise,void vlc_interrupt_raise (vlc_interrupt_t*),misc\interrupt.c,"void vlc_interrupt_raise(vlc_interrupt_t *ctx)
{
    assert(ctx != NULL);

    /* This function must be reentrant. But the callback typically is not
     * reentrant. The lock ensures that all calls to the callback for a given
     * context are serialized. The lock also protects against invalid memory
     * accesses to the callback pointer proper, and the interrupted flag. */
    vlc_mutex_lock(&ctx->lock);
    ctx->interrupted = true;
    if (ctx->callback != NULL)
        ctx->callback(ctx->data);
    vlc_mutex_unlock(&ctx->lock);
}",84.0,97.0,1.0,1.0,14.0,11,4,10,3,1,2,2,2,0,2,,0,0,2,1,1,void
2713,112254,vlc_interrupt_set,1,vlc_interrupt_set,vlc_interrupt_t vlc_interrupt_set (vlc_interrupt_t*),misc\interrupt.c,"vlc_interrupt_t *vlc_interrupt_set(vlc_interrupt_t *newctx)
{
    vlc_interrupt_t *oldctx = vlc_interrupt_var;

    vlc_interrupt_var = newctx;
    return oldctx;
}",99.0,105.0,1.0,1.0,7.0,2,1,5,3,2,0,1,1,0,0,,0,0,2,1,1,vlc_interrupt_t
2714,112268,vlc_interrupt_prepare,1,vlc_interrupt_prepare,"void vlc_interrupt_prepare (vlc_interrupt_t*,void,void*)",misc\interrupt.c,"static void vlc_interrupt_prepare(vlc_interrupt_t *ctx,
                                  void (*cb)(void *), void *data)
{
    assert(ctx != NULL);
    assert(ctx == vlc_interrupt_var);

    vlc_mutex_lock(&ctx->lock);
    assert(ctx->callback == NULL);
    ctx->callback = cb;
    ctx->data = data;

    if (unlikely(ctx->interrupted))
        cb(data);
    vlc_mutex_unlock(&ctx->lock);
}",114.0,128.0,1.0,1.0,15.0,13,5,14,5,5,2,2,2,0,2,,0,0,6,3,3,void
2715,112317,vlc_interrupt_finish,1,vlc_interrupt_finish,int vlc_interrupt_finish (vlc_interrupt_t*),misc\interrupt.c,"static int vlc_interrupt_finish(vlc_interrupt_t *ctx)
{
    int ret = 0;

    assert(ctx != NULL);
    assert(ctx == vlc_interrupt_var);

    /* Wait for pending callbacks to prevent access by other threads. */
    vlc_mutex_lock(&ctx->lock);
    ctx->callback = NULL;
    if (ctx->interrupted)
    {
        ret = EINTR;
        ctx->interrupted = false;
    }
    vlc_mutex_unlock(&ctx->lock);
    return ret;
}",141.0,158.0,1.0,1.0,18.0,13,5,15,6,8,2,2,2,0,2,,0,0,2,1,1,int
2716,112364,vlc_interrupt_register,1,vlc_interrupt_register,"void vlc_interrupt_register (void,void*)",misc\interrupt.c,"void vlc_interrupt_register(void (*cb)(void *), void *opaque)
{
    vlc_interrupt_t *ctx = vlc_interrupt_var;
    if (ctx != NULL)
        vlc_interrupt_prepare(ctx, cb, opaque);
}",160.0,165.0,1.0,1.0,6.0,2,2,7,5,2,1,2,2,0,1,,0,0,4,2,2,void
2717,112383,vlc_interrupt_unregister,1,vlc_interrupt_unregister,int vlc_interrupt_unregister (void),misc\interrupt.c,"int vlc_interrupt_unregister(void)
{
    vlc_interrupt_t *ctx = vlc_interrupt_var;
    return (ctx != NULL) ? vlc_interrupt_finish(ctx) : 0;
}",167.0,171.0,1.0,1.0,5.0,3,3,5,3,2,1,1,1,0,1,,0,0,2,1,1,int
2718,112400,vlc_interrupt_cleanup,1,vlc_interrupt_cleanup,void vlc_interrupt_cleanup (void*),misc\interrupt.c,"static void vlc_interrupt_cleanup(void *opaque)
{
    vlc_interrupt_finish(opaque);
}",173.0,176.0,1.0,1.0,4.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
2719,112407,vlc_interrupt_kill,1,vlc_interrupt_kill,void vlc_interrupt_kill (vlc_interrupt_t*),misc\interrupt.c,"void vlc_interrupt_kill(vlc_interrupt_t *ctx)
{
    assert(ctx != NULL);

    atomic_store(&ctx->killed, true);
    vlc_interrupt_raise(ctx);
}",178.0,184.0,1.0,1.0,7.0,3,3,5,3,4,1,1,1,0,1,,0,0,2,1,1,void
2720,112424,vlc_killed,1,vlc_killed,bool vlc_killed (void),misc\interrupt.c,"bool vlc_killed(void)
{
    vlc_interrupt_t *ctx = vlc_interrupt_var;

    return (ctx != NULL) && atomic_load(&ctx->killed);
}",186.0,191.0,1.0,1.0,6.0,5,5,5,3,14,0,1,1,0,0,,0,0,2,1,1,bool
2721,112443,vlc_interrupt_sem,1,vlc_interrupt_sem,void vlc_interrupt_sem (void*),misc\interrupt.c,"static void vlc_interrupt_sem(void *opaque)
{
    vlc_sem_post(opaque);
}",193.0,196.0,1.0,1.0,4.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
2722,112450,vlc_sem_wait_i11e,1,vlc_sem_wait_i11e,int vlc_sem_wait_i11e (vlc_sem_t*),misc\interrupt.c,"int vlc_sem_wait_i11e(vlc_sem_t *sem)
{
    vlc_interrupt_t *ctx = vlc_interrupt_var;
    if (ctx == NULL)
        return vlc_sem_wait(sem), 0;

    vlc_interrupt_prepare(ctx, vlc_interrupt_sem, sem);

    vlc_cleanup_push(vlc_interrupt_cleanup, ctx);
    vlc_sem_wait(sem);
    vlc_cleanup_pop();

    return vlc_interrupt_finish(ctx);
}",198.0,211.0,1.0,1.0,14.0,3,3,10,4,1,4,2,2,0,4,,0,0,2,1,1,int
2723,112482,vlc_mwait_i11e_wake,1,vlc_mwait_i11e_wake,void vlc_mwait_i11e_wake (void*),misc\interrupt.c,"static void vlc_mwait_i11e_wake(void *opaque)
{
    vlc_cond_signal(opaque);
}",213.0,216.0,1.0,1.0,4.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
2724,112489,vlc_mwait_i11e_cleanup,1,vlc_mwait_i11e_cleanup,void vlc_mwait_i11e_cleanup (void*),misc\interrupt.c,"static void vlc_mwait_i11e_cleanup(void *opaque)
{
    vlc_interrupt_t *ctx = opaque;
    vlc_cond_t *cond = ctx->data;

    vlc_mutex_unlock(&ctx->lock);
    vlc_interrupt_finish(ctx);
    vlc_cond_destroy(cond);
}",218.0,226.0,1.0,1.0,9.0,5,3,7,3,0,3,1,1,0,3,,0,0,2,1,1,void
2725,112513,vlc_mwait_i11e,1,vlc_mwait_i11e,int vlc_mwait_i11e (mtime_t),misc\interrupt.c,"int vlc_mwait_i11e(mtime_t deadline)
{
    vlc_interrupt_t *ctx = vlc_interrupt_var;
    if (ctx == NULL)
        return mwait(deadline), 0;

    vlc_cond_t wait;
    vlc_cond_init(&wait);

    vlc_interrupt_prepare(ctx, vlc_mwait_i11e_wake, &wait);

    vlc_mutex_lock(&ctx->lock);
    vlc_cleanup_push(vlc_mwait_i11e_cleanup, ctx);
    while (!ctx->interrupted
        && vlc_cond_timedwait(&wait, &ctx->lock, deadline) == 0);
    vlc_cleanup_pop();
    vlc_mutex_unlock(&ctx->lock);

    int ret = vlc_interrupt_finish(ctx);
    vlc_cond_destroy(&wait);
    return ret;
}",228.0,249.0,1.0,1.0,22.0,18,7,19,6,0,8,3,3,1,8,,0,2,2,1,1,int
2726,112581,vlc_interrupt_forward_wake,1,vlc_interrupt_forward_wake,void vlc_interrupt_forward_wake (void*),misc\interrupt.c,"static void vlc_interrupt_forward_wake(void *opaque)
{
    void **data = opaque;
    vlc_interrupt_t *to = data[0];
    vlc_interrupt_t *from = data[1];

    (atomic_load(&from->killed) ? vlc_interrupt_kill
                                : vlc_interrupt_raise)(to);
}",251.0,259.0,1.0,1.0,9.0,8,5,8,4,0,0,1,1,0,0,,0,0,2,1,1,void
2727,112612,vlc_interrupt_forward_start,1,vlc_interrupt_forward_start,"void vlc_interrupt_forward_start (vlc_interrupt_t*,void[2]*)",misc\interrupt.c,"void vlc_interrupt_forward_start(vlc_interrupt_t *to, void *data[2])
{
    data[0] = data[1] = NULL;

    vlc_interrupt_t *from = vlc_interrupt_var;
    if (from == NULL)
        return;

    assert(from != to);
    data[0] = to;
    data[1] = from;
    vlc_interrupt_prepare(from, vlc_interrupt_forward_wake, data);
}",261.0,273.0,1.0,1.0,13.0,11,4,15,5,0,1,2,2,0,1,,0,0,4,2,2,void
2728,112655,vlc_interrupt_forward_stop,1,vlc_interrupt_forward_stop,int vlc_interrupt_forward_stop (void[2]*),misc\interrupt.c,"int vlc_interrupt_forward_stop(void *const data[2])
{
    vlc_interrupt_t *from = data[1];
    if (from == NULL)
        return 0;

    assert(from->callback == vlc_interrupt_forward_wake);
    assert(from->data == data);
    return vlc_interrupt_finish(from);
}",275.0,284.0,1.0,1.0,10.0,7,4,8,3,0,1,2,2,0,1,,0,0,2,1,1,int
2729,112688,vlc_poll_i11e_wake,1,vlc_poll_i11e_wake,void vlc_poll_i11e_wake (void*),misc\interrupt.c,"static void vlc_poll_i11e_wake(void *opaque)
{
    uint64_t value = 1;
    int *fd = opaque;
    int canc;

    canc = vlc_savecancel();
    write(fd[1], &value, sizeof (value));
    vlc_restorecancel(canc);
}",287.0,296.0,1.0,1.0,10.0,6,4,8,4,0,2,1,1,0,2,,0,1,2,1,1,void
2730,112715,vlc_poll_i11e_cleanup,1,vlc_poll_i11e_cleanup,void vlc_poll_i11e_cleanup (void*),misc\interrupt.c,"static void vlc_poll_i11e_cleanup(void *opaque)
{
    vlc_interrupt_t *ctx = opaque;
    int *fd = ctx->data;

    vlc_interrupt_finish(ctx);
    if (fd[1] != fd[0])
        vlc_close(fd[1]);
    vlc_close(fd[0]);
}",298.0,307.0,1.0,1.0,10.0,8,4,9,3,0,3,2,2,0,3,,0,0,2,1,1,void
2731,112749,vlc_poll_i11e_inner,1,vlc_poll_i11e_inner,"int vlc_poll_i11e_inner (pollfd*,unsigned,int,vlc_interrupt_t*,pollfd*)",misc\interrupt.c,"static int vlc_poll_i11e_inner(struct pollfd *restrict fds, unsigned nfds,
                               int timeout, vlc_interrupt_t *ctx,
                               struct pollfd *restrict ufd)
{
    int fd[2];
    int ret = -1;
    int canc;

    /* TODO: cache this */
# if defined (HAVE_EVENTFD) && defined (EFD_CLOEXEC)
    canc = vlc_savecancel();
    fd[0] = eventfd(0, EFD_CLOEXEC);
    vlc_restorecancel(canc);
    if (fd[0] != -1)
        fd[1] = fd[0];
    else
# endif
    if (vlc_pipe(fd))
    {
        vlc_testcancel();
        errno = ENOMEM;
        return -1;
    }

    for (unsigned i = 0; i < nfds; i++)
    {
        ufd[i].fd = fds[i].fd;
        ufd[i].events = fds[i].events;
    }
    ufd[nfds].fd = fd[0];
    ufd[nfds].events = POLLIN;

    vlc_interrupt_prepare(ctx, vlc_poll_i11e_wake, fd);

    vlc_cleanup_push(vlc_poll_i11e_cleanup, ctx);
    ret = poll(ufd, nfds + 1, timeout);

    for (unsigned i = 0; i < nfds; i++)
        fds[i].revents = ufd[i].revent...",309.0,370.0,1.0,1.0,62.0,44,12,49,14,1,8,7,7,2,8,,0,3,10,5,5,int
2732,112921,vlc_poll_i11e,1,vlc_poll_i11e,"int vlc_poll_i11e (pollfd*,unsigned,int)",misc\interrupt.c,"int vlc_poll_i11e(struct pollfd *fds, unsigned nfds, int timeout)
{
    vlc_interrupt_t *ctx = vlc_interrupt_var;
    if (ctx == NULL)
        return poll(fds, nfds, timeout);

    int ret;

    if (likely(nfds < 255))
    {   /* Fast path with stack allocation */
        struct pollfd ufd[nfds + 1];

        ret = vlc_poll_i11e_inner(fds, nfds, timeout, ctx, ufd);
    }
    else
    {   /* Slow path but poll() is slow with large nfds anyway. */
        struct pollfd *ufd = vlc_alloc(nfds + 1, sizeof (*ufd));
        if (unlikely(ufd == NULL))
            return -1; /* ENOMEM */

        vlc_cleanup_push(free, ufd);
        ret = vlc_poll_i11e_inner(fds, nfds, timeout, ctx, ufd);
        vlc_cleanup_pop();
        free(ufd);
    }
    return ret;
}",372.0,398.0,1.0,1.0,27.0,4,3,15,8,10,1,3,3,0,1,,0,1,6,3,3,int
2733,112995,vlc_readv_i11e,1,vlc_readv_i11e,"ssize_t vlc_readv_i11e (int,iovec*,int)",misc\interrupt.c,"ssize_t vlc_readv_i11e(int fd, struct iovec *iov, int count)
{
    struct pollfd ufd;

    ufd.fd = fd;
    ufd.events = POLLIN;

    if (vlc_poll_i11e(&ufd, 1, -1) < 0)
        return -1;
    return readv(fd, iov, count);
}",417.0,427.0,1.0,1.0,11.0,8,5,8,5,1,1,2,2,1,1,,0,1,6,3,3,ssize_t
2734,113031,vlc_writev_i11e,1,vlc_writev_i11e,"ssize_t vlc_writev_i11e (int,iovec*,int)",misc\interrupt.c,"ssize_t vlc_writev_i11e(int fd, const struct iovec *iov, int count)
{
    struct pollfd ufd;

    ufd.fd = fd;
    ufd.events = POLLOUT;

    if (vlc_poll_i11e(&ufd, 1, -1) < 0)
        return -1;
    return writev(fd, iov, count);
}",436.0,446.0,1.0,1.0,11.0,8,5,8,5,1,1,2,2,1,1,,0,1,6,3,3,ssize_t
2735,113067,vlc_read_i11e,1,vlc_read_i11e,"ssize_t vlc_read_i11e (int,void*,size_t)",misc\interrupt.c,"ssize_t vlc_read_i11e(int fd, void *buf, size_t count)
{
    struct iovec iov = { .iov_base = buf, .iov_len = count };
    return vlc_readv_i11e(fd, &iov, 1);
}",452.0,456.0,1.0,1.0,5.0,5,3,7,6,0,1,1,1,0,1,,0,0,6,3,3,ssize_t
2736,113092,vlc_write_i11e,1,vlc_write_i11e,"ssize_t vlc_write_i11e (int,void*,size_t)",misc\interrupt.c,"ssize_t vlc_write_i11e(int fd, const void *buf, size_t count)
{
    struct iovec iov = { .iov_base = (void*)buf, .iov_len = count };
    return vlc_writev_i11e(fd, &iov, 1);
}",465.0,469.0,1.0,1.0,5.0,6,4,7,6,0,1,1,1,0,1,,0,0,6,3,3,ssize_t
2737,113119,vlc_recvmsg_i11e,1,vlc_recvmsg_i11e,"ssize_t vlc_recvmsg_i11e (int,msghdr*,int)",misc\interrupt.c,"ssize_t vlc_recvmsg_i11e(int fd, struct msghdr *msg, int flags)
{
    struct pollfd ufd;

    ufd.fd = fd;
    ufd.events = POLLIN;

    if (vlc_poll_i11e(&ufd, 1, -1) < 0)
        return -1;
    /* NOTE: MSG_OOB and MSG_PEEK should work fine here.
     * MSG_WAITALL is not supported at this point. */
    return recvmsg(fd, msg, flags);
}",471.0,483.0,1.0,1.0,13.0,8,5,8,5,1,1,2,2,1,1,,0,1,6,3,3,ssize_t
2738,113155,vlc_recvfrom_i11e,1,vlc_recvfrom_i11e,"ssize_t vlc_recvfrom_i11e (int,void*,size_t,int,sockaddr*,socklen_t*)",misc\interrupt.c,"ssize_t vlc_recvfrom_i11e(int fd, void *buf, size_t len, int flags,
                        struct sockaddr *addr, socklen_t *addrlen)
{
    struct iovec iov = { .iov_base = buf, .iov_len = len };
    struct msghdr msg = {
        .msg_name = addr,
        .msg_namelen = (addrlen != NULL) ? *addrlen : 0,
        .msg_iov = &iov,
        .msg_iovlen = 1,
    };

    ssize_t ret = vlc_recvmsg_i11e(fd, &msg, flags);
    if (ret >= 0 && addrlen != NULL)
        *addrlen = msg.msg_namelen;
    return ret;
}",485.0,500.0,1.0,1.0,16.0,22,9,25,16,0,1,2,2,0,1,,0,1,12,6,6,ssize_t
2739,113229,vlc_sendmsg_i11e,1,vlc_sendmsg_i11e,"ssize_t vlc_sendmsg_i11e (int,msghdr*,int)",misc\interrupt.c,"ssize_t vlc_sendmsg_i11e(int fd, const struct msghdr *msg, int flags)
{
    struct pollfd ufd;

    ufd.fd = fd;
    ufd.events = POLLOUT;

    if (vlc_poll_i11e(&ufd, 1, -1) < 0)
        return -1;
    /* NOTE: MSG_EOR, MSG_OOB and MSG_NOSIGNAL should all work fine here. */
    return sendmsg(fd, msg, flags);
}",502.0,513.0,1.0,1.0,12.0,8,5,8,5,1,1,2,2,1,1,,0,1,6,3,3,ssize_t
2740,113265,vlc_sendto_i11e,1,vlc_sendto_i11e,"ssize_t vlc_sendto_i11e (int,void*,size_t,int,sockaddr*,socklen_t)",misc\interrupt.c,"ssize_t vlc_sendto_i11e(int fd, const void *buf, size_t len, int flags,
                      const struct sockaddr *addr, socklen_t addrlen)
{
    struct iovec iov = { .iov_base = (void *)buf, .iov_len = len };
    struct msghdr msg = {
        .msg_name = (struct sockaddr *)addr,
        .msg_namelen = addrlen,
        .msg_iov = &iov,
        .msg_iovlen = 1,
    };

    return vlc_sendmsg_i11e(fd, &msg, flags);
}",515.0,527.0,1.0,1.0,13.0,14,4,16,14,0,1,1,1,0,1,,0,0,12,6,6,ssize_t
2741,113318,vlc_accept_i11e,1,vlc_accept_i11e,"int vlc_accept_i11e (int,sockaddr*,socklen_t*,bool)",misc\interrupt.c,"int vlc_accept_i11e(int fd, struct sockaddr *addr, socklen_t *addrlen,
                  bool blocking)
{
    struct pollfd ufd;

    ufd.fd = fd;
    ufd.events = POLLIN;

    if (vlc_poll_i11e(&ufd, 1, -1) < 0)
        return -1;

    return vlc_accept(fd, addr, addrlen, blocking);
}",529.0,541.0,1.0,1.0,13.0,8,5,9,6,0,2,2,2,1,2,,0,1,8,4,4,int
2742,113379,callback,1,vlc_interrupt.callback,void vlc_interrupt.callback (void*),misc\interrupt.h,void (*callback)(void *);,36.0,36.0,10.0,28.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2743,113408,keystore_create,1,keystore_create,"vlc_keystore keystore_create (vlc_object_t*,char*)",misc\keystore.c,"static vlc_keystore *
keystore_create(vlc_object_t *p_parent, const char *psz_name)
{
    vlc_keystore *p_keystore = vlc_custom_create(p_parent, sizeof (*p_keystore),
                                                 ""keystore"");
    if (unlikely(p_keystore == NULL))
        return NULL;

    p_keystore->p_module = module_need(p_keystore, ""keystore"", psz_name, true);
    if (p_keystore->p_module == NULL)
    {
        vlc_object_release(p_keystore);
        return NULL;
    }
    assert(p_keystore->pf_store);
    assert(p_keystore->pf_find);
    assert(p_keystore->pf_remove);

    return p_keystore;
}",35.0,54.0,1.0,1.0,20.0,11,5,18,5,2,3,3,3,0,3,,0,2,4,2,2,vlc_keystore
2744,113465,vlc_keystore_create,1,vlc_keystore_create,vlc_keystore vlc_keystore_create (vlc_object_t*),misc\keystore.c,"vlc_keystore *
vlc_keystore_create(vlc_object_t *p_parent)
{
    assert(p_parent);
    return keystore_create(p_parent, ""$keystore"");
}",57.0,62.0,1.0,1.0,6.0,0,0,2,1,1,1,1,1,0,1,,0,0,2,1,1,vlc_keystore
2745,113476,vlc_keystore_release,1,vlc_keystore_release,void vlc_keystore_release (vlc_keystore*),misc\keystore.c,"void
vlc_keystore_release(vlc_keystore *p_keystore)
{
    assert(p_keystore);
    module_unneed(p_keystore, p_keystore->p_module);

    vlc_object_release(p_keystore);
}",64.0,71.0,1.0,1.0,8.0,1,1,4,1,2,2,1,1,0,2,,0,0,2,1,1,void
2746,113490,vlc_keystore_store,1,vlc_keystore_store,"int vlc_keystore_store (vlc_keystore*,char[KEY_MAX]*,uint8_t*,ssize_t,char*)",misc\keystore.c,"int
vlc_keystore_store(vlc_keystore *p_keystore,
                   const char * const ppsz_values[KEY_MAX],
                   const uint8_t *p_secret, ssize_t i_secret_len,
                   const char *psz_label)
{
    assert(p_keystore && ppsz_values && p_secret && i_secret_len);

    if (!ppsz_values[KEY_PROTOCOL] || !ppsz_values[KEY_SERVER])
    {
        msg_Err(p_keystore, ""invalid store request: ""
                ""protocol and server should be valid"");
        return VLC_EGENERIC;
    }
    if (ppsz_values[KEY_PORT])
    {
        long int i_port = strtol(ppsz_values[KEY_PORT], NULL, 10);
        if (i_port == LONG_MIN || i_port == LONG_MAX)
        {
            msg_Err(p_keystore, ""invalid store request: ""
                    ""port is not valid number"");
            return VLC_EGENERIC;
        }
    }
    if (i_secret_len < 0)
        i_secret_len = strlen((const char *)p_secret) + 1;
    return p_keystore->pf_store(p_keystore, ppsz_values, p_secret, i_secret_len,
     ...",73.0,101.0,1.0,1.0,29.0,19,10,31,13,1,0,5,6,0,0,,0,0,10,5,5,int
2747,113574,vlc_keystore_find,1,vlc_keystore_find,"unsigned int vlc_keystore_find (vlc_keystore*,char[KEY_MAX]*,vlc_keystore_entry**)",misc\keystore.c,"unsigned int
vlc_keystore_find(vlc_keystore *p_keystore,
                  const char * const ppsz_values[KEY_MAX],
                  vlc_keystore_entry **pp_entries)
{
    assert(p_keystore && ppsz_values && pp_entries);
    return p_keystore->pf_find(p_keystore, ppsz_values, pp_entries);
}",103.0,110.0,1.0,1.0,8.0,3,2,7,3,1,0,1,1,0,0,,0,0,6,3,3,unsigned int
2748,113595,vlc_keystore_remove,1,vlc_keystore_remove,"unsigned int vlc_keystore_remove (vlc_keystore*,char[KEY_MAX]*)",misc\keystore.c,"unsigned int
vlc_keystore_remove(vlc_keystore *p_keystore,
                    const char *const ppsz_values[KEY_MAX])
{
    assert(p_keystore && ppsz_values);
    return p_keystore->pf_remove(p_keystore, ppsz_values);
}",112.0,118.0,1.0,1.0,7.0,2,2,5,2,0,0,1,1,0,0,,0,0,4,2,2,unsigned int
2749,113612,vlc_keystore_release_entries,1,vlc_keystore_release_entries,"void vlc_keystore_release_entries (vlc_keystore_entry*,unsigned int)",misc\keystore.c,"void
vlc_keystore_release_entries(vlc_keystore_entry *p_entries, unsigned int i_count)
{
    for (unsigned int i = 0; i < i_count; ++i)
        vlc_keystore_release_entry(&p_entries[i]);
    free(p_entries);
}",120.0,126.0,1.0,1.0,7.0,2,2,4,3,3,0,2,2,0,0,,0,0,4,2,2,void
2750,113636,libvlc_InternalKeystoreInit,1,libvlc_InternalKeystoreInit,int libvlc_InternalKeystoreInit (libvlc_int_t*),misc\keystore.c,"int
libvlc_InternalKeystoreInit(libvlc_int_t *p_libvlc)
{
    assert(p_libvlc != NULL);
    libvlc_priv_t *p_priv = libvlc_priv(p_libvlc);

    p_priv->p_memory_keystore = keystore_create(VLC_OBJECT(p_libvlc), ""memory"");
    return p_priv->p_memory_keystore != NULL ? VLC_SUCCESS : VLC_EGENERIC;
}",128.0,136.0,1.0,1.0,9.0,7,4,10,5,1,4,1,1,0,2,,0,4,2,1,1,int
2751,113667,libvlc_InternalKeystoreClean,1,libvlc_InternalKeystoreClean,void libvlc_InternalKeystoreClean (libvlc_int_t*),misc\keystore.c,"void
libvlc_InternalKeystoreClean(libvlc_int_t *p_libvlc)
{
    assert(p_libvlc != NULL);
    libvlc_priv_t *p_priv = libvlc_priv(p_libvlc);

    if (p_priv->p_memory_keystore != NULL)
    {
        vlc_keystore_release(p_priv->p_memory_keystore);
        p_priv->p_memory_keystore = NULL;
    }
}",138.0,149.0,1.0,1.0,12.0,7,3,9,3,1,5,2,2,1,2,,0,4,2,1,1,void
2752,113697,get_memory_keystore,1,get_memory_keystore,vlc_keystore get_memory_keystore (vlc_object_t*),misc\keystore.c,"static vlc_keystore *
get_memory_keystore(vlc_object_t *p_obj)
{
    return libvlc_priv(p_obj->obj.libvlc)->p_memory_keystore;
}",151.0,155.0,1.0,1.0,5.0,3,2,1,1,1,1,1,1,0,1,,0,0,2,1,1,vlc_keystore
2753,113711,find_closest_path,1,find_closest_path,"vlc_keystore_entry find_closest_path (vlc_keystore_entry*,unsigned,char*)",misc\keystore.c,"static vlc_keystore_entry *
find_closest_path(vlc_keystore_entry *p_entries, unsigned i_count,
                  const char *psz_path)
{
    vlc_keystore_entry *p_match_entry = NULL;
    size_t i_last_pathlen = 0;
    char *psz_decoded_path = vlc_uri_decode_duplicate(psz_path);
    if (psz_decoded_path == NULL)
        return NULL;

    /* Try to find the entry that has the closest path to psz_url */
    for (unsigned int i = 0; i < i_count; ++i)
    {
        vlc_keystore_entry *p_entry = &p_entries[i];
        const char *psz_entry_path = p_entry->ppsz_values[KEY_PATH];
        if (psz_entry_path == NULL)
        {
            if (p_match_entry == NULL)
                p_match_entry = p_entry;
            continue;
        }
        size_t i_entry_pathlen = strlen(psz_entry_path);

        if (strncasecmp(psz_decoded_path, psz_entry_path, i_entry_pathlen) == 0
         && i_entry_pathlen > i_last_pathlen)
        {
            i_last_pathlen = i_entry_pathlen;
            p_match_...",157.0,189.0,1.0,1.0,33.0,21,8,36,12,1,1,7,10,0,1,,0,1,6,3,3,vlc_keystore_entry
2754,113806,is_credential_valid,1,is_credential_valid,bool is_credential_valid (vlc_credential*),misc\keystore.c,"static bool
is_credential_valid(vlc_credential *p_credential)
{
    if (p_credential->psz_username && p_credential->psz_password)
        return true;
    p_credential->psz_password = NULL;
    return false;
}",191.0,198.0,1.0,1.0,8.0,5,3,6,4,3,0,2,2,0,0,,0,0,2,1,1,bool
2755,113829,is_url_valid,1,is_url_valid,bool is_url_valid (vlc_url_t*),misc\keystore.c,"static bool
is_url_valid(const vlc_url_t *p_url)
{
    return p_url && p_url->psz_protocol && p_url->psz_protocol[0]
        && p_url->psz_host && p_url->psz_host[0];
}",200.0,205.0,1.0,1.0,6.0,10,3,5,1,1,0,1,1,0,0,,0,0,2,1,1,bool
2756,113881,protocol_set_port,1,protocol_set_port,"bool protocol_set_port (vlc_url_t*,char*)",misc\keystore.c,"static bool
protocol_set_port(const vlc_url_t *p_url, char *psz_port)
{
    int i_port = -1;

    if (p_url->i_port != 0 && p_url->i_port <= UINT16_MAX)
        i_port = p_url->i_port;
    else
    {
        for (unsigned int i = 0; i < sizeof(protocol_default_ports)
                                   / sizeof(*protocol_default_ports); ++i)
        {
            if (strcasecmp(p_url->psz_protocol,
                           protocol_default_ports[i].psz_protocol) == 0)
            {
                i_port = protocol_default_ports[i].i_port;
                break;
            }
        }
    }
    if (i_port != -1)
    {
        sprintf(psz_port, ""%u"", (uint16_t) i_port);
        return true;
    }
    return false;
}",222.0,248.0,1.0,1.0,27.0,12,7,11,6,2,0,3,3,0,0,,0,0,4,2,2,bool
2757,113966,protocol_is_smb,1,protocol_is_smb,bool protocol_is_smb (vlc_url_t*),misc\keystore.c,"static bool
protocol_is_smb(const vlc_url_t *p_url)
{
    return strcasecmp(p_url->psz_protocol, ""smb"") == 0;
}",250.0,254.0,1.0,1.0,5.0,2,2,1,1,4,0,1,1,0,0,,0,0,2,1,1,bool
2758,113979,protocol_store_path,1,protocol_store_path,bool protocol_store_path (vlc_url_t*),misc\keystore.c,"static bool
protocol_store_path(const vlc_url_t *p_url)
{
    return p_url->psz_path
      && (strncasecmp(p_url->psz_protocol, ""http"", 4) == 0
      || strcasecmp(p_url->psz_protocol, ""rtsp"") == 0
      || protocol_is_smb(p_url));
}",256.0,263.0,1.0,1.0,8.0,8,4,4,1,2,1,1,1,0,1,,0,0,2,1,1,bool
2759,114008,smb_split_domain,1,smb_split_domain,void smb_split_domain (vlc_credential*),misc\keystore.c,"static void
smb_split_domain(vlc_credential *p_credential)
{
    char *psz_delim = strchr(p_credential->psz_username, ';');
    if (psz_delim)
    {
        size_t i_len = psz_delim - p_credential->psz_username;
        if (i_len > 0)
        {
            free(p_credential->psz_split_domain);
            p_credential->psz_split_domain =
                strndup(p_credential->psz_username, i_len);
            p_credential->psz_realm = p_credential->psz_split_domain;
        }
        p_credential->psz_username = psz_delim + 1;
    }
}",266.0,282.0,1.0,1.0,17.0,16,5,15,3,2,0,3,4,0,0,,0,0,2,1,1,void
2760,114064,credential_find_keystore,1,credential_find_keystore,"void credential_find_keystore (vlc_credential*,vlc_keystore*)",misc\keystore.c,"static void
credential_find_keystore(vlc_credential *p_credential, vlc_keystore *p_keystore)
{
    const vlc_url_t *p_url = p_credential->p_url;

    const char *ppsz_values[KEY_MAX] = { 0 };
    ppsz_values[KEY_PROTOCOL] = p_url->psz_protocol;
    ppsz_values[KEY_USER] = p_credential->psz_username;
    ppsz_values[KEY_SERVER] = p_url->psz_host;
    /* don't try to match with the path */
    ppsz_values[KEY_REALM] = p_credential->psz_realm;
    ppsz_values[KEY_AUTHTYPE] = p_credential->psz_authtype;
    char psz_port[21];
    if (protocol_set_port(p_url, psz_port))
        ppsz_values[KEY_PORT] = psz_port;

    vlc_keystore_entry *p_entries;
    unsigned int i_entries_count;
    i_entries_count = vlc_keystore_find(p_keystore, ppsz_values, &p_entries);

    /* Remove last entries after vlc_keystore_find call since
     * p_credential->psz_username (default username) can be a pointer to an
     * entry */
    if (p_credential->i_entries_count > 0)
    {
        vlc_keystore_release_en...",284.0,342.0,1.0,1.0,59.0,50,10,48,15,2,6,6,8,2,6,,0,4,4,2,2,void
2761,114270,vlc_credential_init,1,vlc_credential_init,"void vlc_credential_init (vlc_credential*,vlc_url_t*)",misc\keystore.c,"void
vlc_credential_init(vlc_credential *p_credential, const vlc_url_t *p_url)
{
    assert(p_credential);

    memset(p_credential, 0, sizeof(*p_credential));
    p_credential->i_get_order = GET_FROM_URL;
    p_credential->p_url = p_url;
}",344.0,352.0,1.0,1.0,9.0,6,4,7,3,0,0,1,1,0,0,,0,0,4,2,2,void
2762,114294,vlc_credential_clean,1,vlc_credential_clean,void vlc_credential_clean (vlc_credential*),misc\keystore.c,"void
vlc_credential_clean(vlc_credential *p_credential)
{
    if (p_credential->i_entries_count > 0)
        vlc_keystore_release_entries(p_credential->p_entries,
                                     p_credential->i_entries_count);
    if (p_credential->p_keystore)
        vlc_keystore_release(p_credential->p_keystore);

    free(p_credential->psz_split_domain);
    free(p_credential->psz_var_username);
    free(p_credential->psz_var_password);
    free(p_credential->psz_dialog_username);
    free(p_credential->psz_dialog_password);
}",354.0,368.0,1.0,1.0,15.0,11,2,10,1,0,2,3,3,0,2,,0,0,2,1,1,void
2763,114342,vlc_credential_get,1,vlc_credential_get,"bool vlc_credential_get (vlc_credential*,vlc_object_t*,char*,char*,char*,char*...)",misc\keystore.c,"bool
vlc_credential_get(vlc_credential *p_credential, vlc_object_t *p_parent,
                   const char *psz_option_username,
                   const char *psz_option_password,
                   const char *psz_dialog_title,
                   const char *psz_dialog_fmt, ...)
{
    assert(p_credential && p_parent);
    const vlc_url_t *p_url = p_credential->p_url;

    if (!is_url_valid(p_url))
    {
        msg_Err(p_parent, ""vlc_credential_get: invalid url"");
        return false;
    }

    p_credential->b_from_keystore = false;
    /* Don't set username to NULL, we may want to use the last one set */
    p_credential->psz_password = NULL;

    while (!is_credential_valid(p_credential))
    {
        /* First, fetch credential from URL (if any).
         * Secondly, fetch credential from VLC Options (if any).
         * Thirdly, fetch credential from keystore (if any) using user and realm
         * previously set by the caller, the URL or by VLC Options.
         * Finally...",371.0,498.0,1.0,1.0,128.0,89,10,109,20,0,12,22,44,4,12,,0,7,12,6,6,bool
2764,114675,vlc_credential_store,1,vlc_credential_store,"bool vlc_credential_store (vlc_credential*,vlc_object_t*)",misc\keystore.c,"bool
vlc_credential_store(vlc_credential *p_credential, vlc_object_t *p_parent)
{
    if (!is_credential_valid(p_credential))
        return false;
    /* Don't need to store again */
    if (p_credential->b_from_keystore)
        return p_credential->b_from_keystore;

    vlc_keystore *p_keystore;
    if (p_credential->b_store)
    {
        /* Store in permanent keystore */
        assert(p_credential->p_keystore != NULL);
        p_keystore = p_credential->p_keystore;
    }
    else
    {
        /* Store in memory keystore */
        p_keystore = get_memory_keystore(p_parent);
    }
    if (p_keystore == NULL)
        return false;

    const vlc_url_t *p_url = p_credential->p_url;

    char *psz_path = NULL;
    if (protocol_store_path(p_url)
     && (psz_path =  vlc_uri_decode_duplicate(p_url->psz_path)) != NULL)
    {
        char *p_slash;
        if (protocol_is_smb(p_url))
        {
            /* Remove all characters after the first slash (store the share but
           ...",501.0,577.0,1.0,1.0,77.0,58,14,71,20,0,6,10,12,5,6,,0,6,4,2,2,bool
2765,114916,md5_init,1,md5_init,void md5_init (void*),misc\md5.c,"static void
md5_init( void *context )
{
  MD5_CONTEXT *ctx = context;

  ctx->A = 0x67452301;
  ctx->B = 0xefcdab89;
  ctx->C = 0x98badcfe;
  ctx->D = 0x10325476;

  ctx->nblocks = 0;
  ctx->count = 0;
}",54.0,66.0,1.0,1.0,13.0,13,2,8,2,1,0,1,1,0,0,,0,0,2,1,1,void
2766,114955,transform,1,transform,"void transform (MD5_CONTEXT*,unsigned char*)",misc\md5.c,"static void
transform ( MD5_CONTEXT *ctx, const unsigned char *data )
{
  u32 correct_words[16];
  register u32 A = ctx->A;
  register u32 B = ctx->B;
  register u32 C = ctx->C;
  register u32 D = ctx->D;
  u32 *cwp = correct_words;

#ifdef WORDS_BIGENDIAN
  {
    int i;
    byte *p2, *p1;
    for(i=0, p1=data, p2=(byte*)correct_words; i < 16; i++, p2 += 4 )
      {
        p2[3] = *p1++;
	p2[2] = *p1++;
	p2[1] = *p1++;
	p2[0] = *p1++;
      }
  }
#else
  memcpy( correct_words, data, 64 );
#endif


#define OP(a, b, c, d, s, T) \
  do			         	   \
    {					   \
      a += FF (b, c, d) + (*cwp++) + T;    \
      a = rol(a, s);			   \
      a += b;				   \
    }					   \
  while (0)

  /* Before we start, one word about the strange constants.
     They are defined in RFC 1321 as

     T[i] = (int) (4294967296.0 * fabs (sin (i))), i=1..64
  */

  /* Round 1.  */
  OP (A, B, C, D,  7, 0xd76aa478);
  OP (D, A, B, C, 12, 0xe8c7b756);
  OP (C, D, A, B, 17, 0x242070db);
  OP (B, C, D, A...",82.0,211.0,1.0,2.0,130.0,849,14,948,8,3,0,1,1,0,0,,0,0,4,2,2,void
2767,117574,md5_write,1,md5_write,"void md5_write (void*,void*,size_t)",misc\md5.c,"static void
md5_write( void *context, const void *inbuf_arg , size_t inlen)
{
  const unsigned char *inbuf = inbuf_arg;
  MD5_CONTEXT *hd = context;

  if( hd->count == 64 )  /* flush the buffer */
    {
      transform( hd, hd->buf );
      hd->count = 0;
      hd->nblocks++;
    }
  if( !inbuf )
    return;

  if( hd->count )
    {
      for( ; inlen && hd->count < 64; inlen-- )
        hd->buf[hd->count++] = *inbuf++;
      md5_write( hd, NULL, 0 );
      if( !inlen )
        return;
    }

  while( inlen >= 64 )
    {
      transform( hd, inbuf );
      hd->count = 0;
      hd->nblocks++;
      inlen -= 64;
      inbuf += 64;
    }
  for( ; inlen && hd->count < 64; inlen-- )
    hd->buf[hd->count++] = *inbuf++;

}",219.0,254.0,1.0,1.0,36.0,25,10,25,6,2,2,8,10,0,2,,0,0,6,3,3,void
2768,117698,md5_final,1,md5_final,void md5_final (void*),misc\md5.c,"static void
md5_final( void *context)
{
  MD5_CONTEXT *hd = context;
  u32 t, msb, lsb;
  byte *p;

  md5_write(hd, NULL, 0); /* flush */;

  t = hd->nblocks;
  /* multiply by 64 to make a byte count */
  lsb = t << 6;
  msb = t >> 26;
  /* add the count */
  t = lsb;
  if( (lsb += hd->count) < t )
    msb++;
  /* multiply by 8 to make a bit count */
  t = lsb;
  lsb <<= 3;
  msb <<= 3;
  msb |= t >> 29;

  if( hd->count < 56 )  /* enough room */
    {
      hd->buf[hd->count++] = 0x80; /* pad */
      while( hd->count < 56 )
        hd->buf[hd->count++] = 0;  /* pad */
    }
  else  /* need one extra block */
    {
      hd->buf[hd->count++] = 0x80; /* pad character */
      while( hd->count < 64 )
        hd->buf[hd->count++] = 0;
      md5_write(hd, NULL, 0);  /* flush */;
      memset(hd->buf, 0, 56 ); /* fill next block with zeroes */
    }
  /* append the 64 bit count */
  hd->buf[56] = lsb	   ;
  hd->buf[57] = lsb >>  8;
  hd->buf[58] = lsb >> 16;
  hd->buf[59] = lsb >> 24;
 ...",264.0,325.0,1.0,2.0,62.0,80,11,58,7,1,2,4,5,0,2,,0,0,2,1,1,void
2769,117975,InitMD5,1,InitMD5,void InitMD5 (md5_s*),misc\md5.c,"void InitMD5( struct md5_s *h )
{
    md5_init( h );
}",336.0,339.0,1.0,1.0,4.0,0,0,1,1,4,1,1,1,0,1,,0,0,2,1,1,void
2770,117982,AddMD5,1,AddMD5,"void AddMD5 (md5_s*,void*,size_t)",misc\md5.c,"void AddMD5( struct md5_s *restrict h, const void *data, size_t len )
{
    md5_write( h, data, len );
}",341.0,344.0,1.0,1.0,4.0,0,0,3,3,18,1,1,1,0,1,,0,0,6,3,3,void
2771,117993,EndMD5,1,EndMD5,void EndMD5 (md5_s*),misc\md5.c,"void EndMD5( struct md5_s *h )
{
    md5_final( h );
}",346.0,349.0,1.0,1.0,4.0,0,0,1,1,4,1,1,1,0,1,,0,0,2,1,1,void
2772,118032,vlc_vaLogCallback,1,vlc_vaLogCallback,"void vlc_vaLogCallback (libvlc_int_t*,int,vlc_log_t*,char*,va_list)",misc\messages.c,"static void vlc_vaLogCallback(libvlc_int_t *vlc, int type,
                              const vlc_log_t *item, const char *format,
                              va_list ap)
{
    vlc_logger_t *logger = libvlc_priv(vlc)->logger;
    int canc;

    assert(logger != NULL);
    canc = vlc_savecancel();
    vlc_rwlock_rdlock(&logger->lock);
    logger->log(logger->sys, type, item, format, ap);
    vlc_rwlock_unlock(&logger->lock);
    vlc_restorecancel(canc);
}",55.0,68.0,1.0,1.0,14.0,10,4,14,8,2,9,1,1,0,5,,0,6,10,5,5,void
2773,118079,vlc_LogCallback,1,vlc_LogCallback,"void vlc_LogCallback (libvlc_int_t*,int,vlc_log_t*,char*...)",misc\messages.c,"static void vlc_LogCallback(libvlc_int_t *vlc, int type, const vlc_log_t *item,
                            const char *format, ...)
{
    va_list ap;

    va_start(ap, format);
    vlc_vaLogCallback(vlc, type, item, format, ap);
    va_end(ap);
}",70.0,78.0,1.0,1.0,9.0,0,0,8,5,1,1,1,1,0,1,,0,0,8,4,4,void
2774,118099,vlc_vaLog,1,vlc_vaLog,"void vlc_vaLog (vlc_object_t*,int,char*,char*,unsigned,char*,char*,va_list)",misc\messages.c,"void vlc_vaLog (vlc_object_t *obj, int type, const char *module,
                const char *file, unsigned line, const char *func,
                const char *format, va_list args)
{
    if (obj != NULL && obj->obj.flags & OBJECT_FLAGS_QUIET)
        return;

    /* Get basename from the module filename */
    char *p = strrchr(module, '/');
    if (p != NULL)
        module = p + 1;
    p = strchr(module, '.');

    size_t modlen = (p != NULL) ? (p - module) : 0;
    char modulebuf[modlen + 1];
    if (p != NULL)
    {
        memcpy(modulebuf, module, modlen);
        modulebuf[modlen] = '\0';
        module = modulebuf;
    }

    /* Fill message information fields */
    vlc_log_t msg;

    msg.i_object_id = (uintptr_t)obj;
    msg.psz_object_type = (obj != NULL) ? obj->obj.object_type : ""generic"";
    msg.psz_module = module;
    msg.psz_header = NULL;
    msg.file = file;
    msg.line = line;
    msg.func = func;
    msg.tid = vlc_thread_id();

    for (vlc_object_t *o = obj;...",89.0,141.0,1.0,1.0,53.0,45,12,54,15,1,2,6,6,0,2,,0,1,16,8,8,void
2775,118278,vlc_Log,1,vlc_Log,"void vlc_Log (vlc_object_t*,int,char*,char*,unsigned,char*,char*...)",misc\messages.c,"void vlc_Log(vlc_object_t *obj, int type, const char *module,
             const char *file, unsigned line, const char *func,
             const char *format, ... )
{
    va_list ap;

    va_start(ap, format);
    vlc_vaLog(obj, type, module, file, line, func, format, ap);
    va_end(ap);
}",154.0,163.0,1.0,1.0,10.0,0,0,11,8,0,1,1,1,0,1,,0,0,14,7,7,void
2776,118316,vlc_vaLogEarly,1,vlc_vaLogEarly,"void vlc_vaLogEarly (void*,int,vlc_log_t*,char*,va_list)",misc\messages.c,"static void vlc_vaLogEarly(void *d, int type, const vlc_log_t *item,
                           const char *format, va_list ap)
{
    vlc_logger_early_t *sys = d;

    vlc_log_early_t *log = malloc(sizeof (*log));
    if (unlikely(log == NULL))
        return;

    log->next = NULL;
    log->type = type;
    log->meta.i_object_id = item->i_object_id;
    /* NOTE: Object types MUST be static constant - no need to copy them. */
    log->meta.psz_object_type = item->psz_object_type;
    log->meta.psz_module = item->psz_module; /* Ditto. */
    log->meta.psz_header = item->psz_header ? strdup(item->psz_header) : NULL;
    log->meta.file = item->file;
    log->meta.line = item->line;
    log->meta.func = item->func;

    if (vasprintf(&log->msg, format, ap) == -1)
        log->msg = NULL;

    vlc_mutex_lock(&sys->lock);
    assert(sys->tailp != NULL);
    assert(*(sys->tailp) == NULL);
    *(sys->tailp) = log;
    sys->tailp = &log->next;
    vlc_mutex_unlock(&sys->lock);
}",223.0,252.0,1.0,1.0,30.0,61,10,41,8,0,20,3,3,1,2,,0,18,10,5,5,void
2777,118476,vlc_LogEarlyOpen,1,vlc_LogEarlyOpen,int vlc_LogEarlyOpen (vlc_logger_t*),misc\messages.c,"static int vlc_LogEarlyOpen(vlc_logger_t *logger)
{
    vlc_logger_early_t *sys = malloc(sizeof (*sys));

    if (unlikely(sys == NULL))
        return -1;

    vlc_mutex_init(&sys->lock);
    sys->head = NULL;
    sys->tailp = &sys->head;

    logger->log = vlc_vaLogEarly;
    logger->sys = sys;
    return 0;
}",254.0,268.0,1.0,1.0,15.0,17,7,12,3,0,7,2,2,0,1,,0,6,2,1,1,int
2778,118527,vlc_LogEarlyClose,1,vlc_LogEarlyClose,"void vlc_LogEarlyClose (vlc_logger_t*,void*)",misc\messages.c,"static void vlc_LogEarlyClose(vlc_logger_t *logger, void *d)
{
    libvlc_int_t *vlc = logger->obj.libvlc;
    vlc_logger_early_t *sys = d;

    /* Drain early log messages */
    for (vlc_log_early_t *log = sys->head, *next; log != NULL; log = next)
    {
        vlc_LogCallback(vlc, log->type, &log->meta, ""%s"",
                        (log->msg != NULL) ? log->msg : ""message lost"");
        free(log->msg);
        next = log->next;
        free(log);
    }

    vlc_mutex_destroy(&sys->lock);
    free(sys);
}",270.0,287.0,1.0,1.0,18.0,19,6,20,7,0,4,2,2,0,2,,0,2,4,2,2,void
2779,118599,vlc_vaLogDiscard,1,vlc_vaLogDiscard,"void vlc_vaLogDiscard (void*,int,vlc_log_t*,char*,va_list)",misc\messages.c,"static void vlc_vaLogDiscard(void *d, int type, const vlc_log_t *item,
                             const char *format, va_list ap)
{
    (void) d; (void) type; (void) item; (void) format; (void) ap;
}",289.0,293.0,1.0,1.0,5.0,5,1,5,5,0,0,1,1,0,0,,0,0,10,5,5,void
2780,118623,vlc_logger_load,1,vlc_logger_load,"int vlc_logger_load (void*,va_list)",misc\messages.c,"static int vlc_logger_load(void *func, va_list ap)
{
    vlc_log_cb (*activate)(vlc_object_t *, void **) = func;
    vlc_logger_t *logger = va_arg(ap, vlc_logger_t *);
    vlc_log_cb *cb = va_arg(ap, vlc_log_cb *);
    void **sys = va_arg(ap, void **);

    *cb = activate(VLC_OBJECT(logger), sys);
    return (*cb != NULL) ? VLC_SUCCESS : VLC_EGENERIC;
}",295.0,304.0,1.0,1.0,10.0,5,4,7,6,0,0,1,1,0,0,,0,0,4,2,2,int
2781,118627,activate,1,vlc_logger_load.activate,"vlc_log_cb vlc_logger_load.activate (vlc_object_t*,void**)",misc\messages.c,"vlc_log_cb (*activate)(vlc_object_t *, void **) = func;",297.0,297.0,16.0,58.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,vlc_log_cb
2782,118653,vlc_logger_unload,1,vlc_logger_unload,"void vlc_logger_unload (void*,va_list)",misc\messages.c,"static void vlc_logger_unload(void *func, va_list ap)
{
    void (*deactivate)(vlc_logger_t *) = func;
    void *sys = va_arg(ap, void *);

    deactivate(sys);
}",306.0,312.0,1.0,1.0,7.0,0,0,1,1,0,0,1,1,0,0,,0,0,4,2,2,void
2783,118657,deactivate,1,vlc_logger_unload.deactivate,void vlc_logger_unload.deactivate (vlc_logger_t*),misc\messages.c,void (*deactivate)(vlc_logger_t *) = func;,308.0,308.0,10.0,45.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2784,118838,vlc_LogSet,1,vlc_LogSet,"void vlc_LogSet (libvlc_int_t*,vlc_log_cb,void*)",misc\messages.c,"void vlc_LogSet(libvlc_int_t *vlc, vlc_log_cb cb, void *opaque)
{
    vlc_logger_t *logger = libvlc_priv(vlc)->logger;

    if (unlikely(logger == NULL))
        return;

    module_t *module;
    void *sys;

    if (cb == NULL)
        cb = vlc_vaLogDiscard;

    vlc_rwlock_wrlock(&logger->lock);
    sys = logger->sys;
    module = logger->module;

    logger->log = cb;
    logger->sys = opaque;
    logger->module = NULL;
    vlc_rwlock_unlock(&logger->lock);

    if (module != NULL)
        vlc_module_unload(vlc, module, vlc_logger_unload, sys);

    /* Announce who we are */
    msg_Dbg (vlc, ""VLC media player - %s"", VERSION_MESSAGE);
    msg_Dbg (vlc, ""%s"", COPYRIGHT_MESSAGE);
    msg_Dbg (vlc, ""revision %s"", psz_vlc_changeset);
    msg_Dbg (vlc, ""configured with %s"", CONFIGURE_LINE);
}",390.0,420.0,1.0,1.0,31.0,20,5,32,11,0,11,4,4,0,4,,0,8,6,3,3,void
2785,119140,vlc_mime_Ext2Mime,1,vlc_mime_Ext2Mime,const char* vlc_mime_Ext2Mime (char*),misc\mime.c,"const char *vlc_mime_Ext2Mime( const char *psz_url )
{

    char *psz_ext;

    psz_ext = strrchr( psz_url, '.' );
    if( psz_ext )
    {
        int i;

        for( i = 0; ext_mime[i].psz_ext[0] ; i++ )
        {
            if( !strcasecmp( ext_mime[i].psz_ext, psz_ext ) )
            {
                return ext_mime[i].psz_mime;
            }
        }
    }
    return ""application/octet-stream"";
}",89.0,108.0,1.0,1.0,20.0,10,4,11,4,2,3,4,7,2,0,,0,3,2,1,1,const char*
2786,119201,secstotimestr,1,secstotimestr,"char* secstotimestr (char*,int32_t)",misc\mtime.c,"char *secstotimestr( char *psz_buffer, int32_t i_seconds )
{
    if( unlikely(i_seconds < 0) )
    {
        secstotimestr( psz_buffer + 1, -i_seconds );
        *psz_buffer = '-';
        return psz_buffer;
    }

    div_t d;

    d = div( i_seconds, 60 );
    i_seconds = d.rem;
    d = div( d.quot, 60 );

    if( d.quot )
        snprintf( psz_buffer, MSTRTIME_MAX_SIZE, ""%u:%02u:%02u"",
                 d.quot, d.rem, i_seconds );
    else
        snprintf( psz_buffer, MSTRTIME_MAX_SIZE, ""%02u:%02u"",
                  d.rem, i_seconds );
    return psz_buffer;
}",51.0,73.0,1.0,1.0,23.0,13,6,18,4,2,0,3,3,0,0,,0,0,4,2,2,char*
2787,119271,date_Init,1,date_Init,"void date_Init (date_t*,uint32_t,uint32_t)",misc\mtime.c,"void date_Init( date_t *p_date, uint32_t i_divider_n, uint32_t i_divider_d )
{
    p_date->date = 0;
    p_date->i_divider_num = i_divider_n;
    p_date->i_divider_den = i_divider_d;
    p_date->i_remainder = 0;
}",87.0,93.0,1.0,1.0,7.0,8,2,6,3,0,0,1,1,0,0,,0,0,6,3,3,void
2788,119298,date_Change,1,date_Change,"void date_Change (date_t*,uint32_t,uint32_t)",misc\mtime.c,"void date_Change( date_t *p_date, uint32_t i_divider_n, uint32_t i_divider_d )
{
    /* change time scale of remainder */
    p_date->i_remainder = p_date->i_remainder * i_divider_n / p_date->i_divider_num;
    p_date->i_divider_num = i_divider_n;
    p_date->i_divider_den = i_divider_d;
}",103.0,109.0,1.0,1.0,7.0,10,4,8,3,0,0,1,1,0,0,,0,0,6,3,3,void
2789,119328,date_Set,1,date_Set,"void date_Set (date_t*,mtime_t)",misc\mtime.c,"void date_Set( date_t *p_date, mtime_t i_new_date )
{
    p_date->date = i_new_date;
    p_date->i_remainder = 0;
}",117.0,121.0,1.0,1.0,5.0,4,2,3,2,0,0,1,1,0,0,,0,0,4,2,2,void
2790,119344,date_Get,1,date_Get,mtime_t date_Get (date_t*),misc\mtime.c,"mtime_t date_Get( const date_t *p_date )
{
    return p_date->date;
}",129.0,132.0,1.0,1.0,4.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,mtime_t
2791,119353,date_Move,1,date_Move,"void date_Move (date_t*,mtime_t)",misc\mtime.c,"void date_Move( date_t *p_date, mtime_t i_difference )
{
    p_date->date += i_difference;
}",140.0,143.0,1.0,1.0,4.0,2,2,2,2,0,0,1,1,0,0,,0,0,4,2,2,void
2792,119364,date_Increment,1,date_Increment,"mtime_t date_Increment (date_t*,uint32_t)",misc\mtime.c,"mtime_t date_Increment( date_t *p_date, uint32_t i_nb_samples )
{
    assert( p_date->i_divider_num != 0 );
    mtime_t i_dividend = i_nb_samples * CLOCK_FREQ * p_date->i_divider_den;
    lldiv_t d = lldiv( i_dividend, p_date->i_divider_num );

    p_date->date += d.quot;
    p_date->i_remainder += (int)d.rem;

    if( p_date->i_remainder >= p_date->i_divider_num )
    {
        /* This is Bresenham algorithm. */
        assert( p_date->i_remainder < 2*p_date->i_divider_num);
        p_date->date += 1;
        p_date->i_remainder -= p_date->i_divider_num;
    }

    return p_date->date;
}",153.0,171.0,1.0,1.0,19.0,28,10,20,5,0,0,2,2,0,0,,0,0,4,2,2,mtime_t
2793,119445,date_Decrement,1,date_Decrement,"mtime_t date_Decrement (date_t*,uint32_t)",misc\mtime.c,"mtime_t date_Decrement( date_t *p_date, uint32_t i_nb_samples )
{
    mtime_t i_dividend = (mtime_t)i_nb_samples * CLOCK_FREQ * p_date->i_divider_den;
    p_date->date -= i_dividend / p_date->i_divider_num;
    unsigned i_rem_adjust = i_dividend % p_date->i_divider_num;

    if( p_date->i_remainder < i_rem_adjust )
    {
        /* This is Bresenham algorithm. */
        assert( p_date->i_remainder < p_date->i_divider_num);
        p_date->date -= 1;
        p_date->i_remainder += p_date->i_divider_num;
    }

    p_date->i_remainder -= i_rem_adjust;

    return p_date->date;
}",181.0,198.0,1.0,1.0,18.0,25,9,20,5,0,0,2,2,0,0,,0,0,4,2,2,mtime_t
2794,119516,NTPtime64,1,NTPtime64,uint64_t NTPtime64 (void),misc\mtime.c,"uint64_t NTPtime64(void)
{
    struct timespec ts;

    timespec_get(&ts, TIME_UTC);

    /* Convert nanoseconds to 32-bits fraction (232 picosecond units) */
    uint64_t t = (uint64_t)(ts.tv_nsec) << 32;
    t /= 1000000000;

    /* The offset to Unix epoch is 70 years (incl. 17 leap ones). There were
     * no leap seconds during that period since they had not been invented yet.
     */
    t |= ((UINT64_C(70) * 365 + 17) * 24 * 60 * 60 + ts.tv_sec) << 32;
    return t;
}",203.0,218.0,1.0,1.0,16.0,13,7,8,3,0,0,1,1,0,0,,0,0,2,1,1,uint64_t
2795,119587,PrintObject,1,PrintObject,"void PrintObject (vlc_object_t*,char*)",misc\objects.c,"static void PrintObject (vlc_object_t *obj, const char *prefix)
{
    vlc_object_internals_t *priv = vlc_internals(obj);

    int canc = vlc_savecancel ();
    printf ("" %so %p %s, %u refs, parent %p\n"", prefix, (void *)obj,
            obj->obj.object_type, atomic_load(&priv->refs),
            (void *)obj->obj.parent);
    vlc_restorecancel (canc);
}",58.0,67.0,1.0,35.0,10.0,12,6,10,4,2,2,1,1,0,2,,0,1,4,2,2,void
2796,119634,DumpStructure,1,DumpStructure,"void DumpStructure (vlc_object_t*,unsigned,char*)",misc\objects.c,"static void DumpStructure (vlc_object_t *obj, unsigned level, char *psz_foo)
{
    char back = psz_foo[level];

    psz_foo[level] = '\0';
    PrintObject (obj, psz_foo);
    psz_foo[level] = back;

    if (level / 2 >= MAX_DUMPSTRUCTURE_DEPTH)
    {
        msg_Warn (obj, ""structure tree is too deep"");
        return;
    }

    vlc_object_internals_t *priv = vlc_internals(obj);

    /* NOTE: nested locking here (due to recursive call) */
    vlc_mutex_lock (&vlc_internals(obj)->tree_lock);
    for (priv = priv->first; priv != NULL; priv = priv->next)
    {
        if (level > 0)
        {
            assert(level >= 2);
            psz_foo[level - 1] = ' ';

            if (psz_foo[level - 2] == '`')
                psz_foo[level - 2] = ' ';
        }

        psz_foo[level] = priv->next ? '|' : '`';
        psz_foo[level + 1] = '-';
        psz_foo[level + 2] = '\0';

        DumpStructure (vlc_externals(priv), level + 2, psz_foo);
    }
    vlc_mutex_unlock (&vlc_internals(obj)-...",69.0,105.0,1.0,35.0,37.0,46,13,43,7,1,3,5,8,0,3,,0,0,6,3,3,void
2797,119794,TreeCommand,1,TreeCommand,"int TreeCommand (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",misc\objects.c,"static int TreeCommand (vlc_object_t *obj, char const *cmd,
                        vlc_value_t oldval, vlc_value_t newval, void *data)
{
    (void) cmd; (void) oldval; (void) newval; (void) data;

    if (cmd[0] == 't')
    {
        char psz_foo[2 * MAX_DUMPSTRUCTURE_DEPTH + 1];

        psz_foo[0] = '|';
        DumpStructure (obj, 0, psz_foo);
    }

    return VLC_SUCCESS;
}",114.0,128.0,1.0,1.0,15.0,8,4,9,7,0,1,2,2,0,1,,0,0,10,5,5,int
2798,119834,ObjectExists,1,ObjectExists,"vlc_object_t ObjectExists (vlc_object_t*,void*)",misc\objects.c,"static vlc_object_t *ObjectExists (vlc_object_t *root, void *obj)
{
    if (root == obj)
        return vlc_object_hold (root);

    vlc_object_internals_t *priv = vlc_internals(root);
    vlc_object_t *ret = NULL;

    /* NOTE: nested locking here (due to recursive call) */
    vlc_mutex_lock (&vlc_internals(root)->tree_lock);

    for (priv = priv->first; priv != NULL && ret == NULL; priv = priv->next)
        ret = ObjectExists (vlc_externals (priv), obj);

    vlc_mutex_unlock (&vlc_internals(root)->tree_lock);
    return ret;
}",130.0,146.0,1.0,35.0,17.0,18,8,19,5,1,3,3,3,0,3,,0,0,4,2,2,vlc_object_t
2799,119923,VarsCommand,1,VarsCommand,"int VarsCommand (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",misc\objects.c,"static int VarsCommand (vlc_object_t *obj, char const *cmd,
                        vlc_value_t oldval, vlc_value_t newval, void *data)
{
    void *p;

    (void) cmd; (void) oldval; (void) data;

    if (sscanf (newval.psz_string, ""%p"", &p) == 1)
    {
        p = ObjectExists (obj, p);
        if (p == NULL)
        {
            msg_Err (obj, ""no such object: %s"", newval.psz_string);
            return VLC_ENOOBJ;
        }
        obj = p;
    }
    else
        vlc_object_hold (obj);

    PrintObject (obj, """");
    DumpVariables (obj);
    vlc_object_release (obj);

    return VLC_SUCCESS;
}",148.0,173.0,1.0,1.0,26.0,10,5,19,9,0,4,3,4,0,4,,0,1,10,5,5,int
2800,120254,vlc_object_create,1,vlc_object_create,"void* vlc_object_create (vlc_object_t*,size_t)",misc\objects.c,"void *vlc_object_create( vlc_object_t *p_this, size_t i_size )
{
    return vlc_custom_create( p_this, i_size, ""generic"" );
}",257.0,260.0,1.0,1.0,4.0,0,0,2,2,4,1,1,1,0,1,,0,0,4,2,2,void*
2801,120347,vlc_object_get_name,1,vlc_object_get_name,char* vlc_object_get_name (vlc_object_t*),misc\objects.c,"char *vlc_object_get_name(const vlc_object_t *obj)
{
    vlc_object_internals_t *priv = vlc_internals(obj);
    char *name;

    vlc_mutex_lock (&name_lock);
    name = priv->psz_name ? strdup (priv->psz_name) : NULL;
    vlc_mutex_unlock (&name_lock);

    return name;
}",298.0,308.0,1.0,35.0,11.0,9,6,10,5,0,4,1,1,0,2,,0,2,2,1,1,char*
2802,120384,vlc_object_destroy,1,vlc_object_destroy,void vlc_object_destroy (vlc_object_t*),misc\objects.c,"static void vlc_object_destroy( vlc_object_t *p_this )
{
    vlc_object_internals_t *p_priv = vlc_internals( p_this );

    assert(p_priv->resources == NULL);

    /* Call the custom ""subclass"" destructor */
    if( p_priv->pf_destructor )
        p_priv->pf_destructor( p_this );

    if (unlikely(p_this->obj.parent == NULL))
    {
        /* TODO: should be in src/libvlc.c */
        var_DelCallback (p_this, ""vars"", VarsCommand, NULL);
        var_DelCallback (p_this, ""tree"", TreeCommand, NULL);
    }

    /* Destroy the associated variables. */
    var_DestroyAll( p_this );

    vlc_mutex_destroy (&p_priv->tree_lock);
    vlc_cond_destroy( &p_priv->var_wait );
    vlc_mutex_destroy( &p_priv->var_lock );
    free( p_this->obj.header );
    free( p_priv->psz_name );
    free( p_priv );
}",315.0,341.0,1.0,37.0,27.0,19,7,21,3,2,6,3,3,0,6,,0,0,2,1,1,void
2803,120466,FindName,1,FindName,"vlc_object_t FindName (vlc_object_t*,char*)",misc\objects.c,"static vlc_object_t *FindName (vlc_object_t *obj, const char *name)
{
    vlc_object_internals_t *priv = vlc_internals(obj);

    if (priv->psz_name != NULL && !strcmp (priv->psz_name, name))
        return vlc_object_hold (obj);

    vlc_object_t *found = NULL;
    /* NOTE: nested locking here (due to recursive call) */
    vlc_mutex_lock (&vlc_internals(obj)->tree_lock);

    for (priv = priv->first; priv != NULL && found == NULL; priv = priv->next)
        found = FindName (vlc_externals(priv), name);

    /* NOTE: nested locking here (due to recursive call) */
    vlc_mutex_unlock (&vlc_internals(obj)->tree_lock);
    return found;
}",343.0,360.0,1.0,35.0,18.0,22,9,21,5,1,3,3,3,0,3,,0,0,4,2,2,vlc_object_t
2804,120564,vlc_object_find_name,1,vlc_object_find_name,"vlc_object_t vlc_object_find_name (vlc_object_t*,char*)",misc\objects.c,"vlc_object_t *vlc_object_find_name( vlc_object_t *p_this, const char *psz_name )
{
    vlc_object_t *p_found;

    /* The object name is not thread-safe, provides no warranty that the
     * object is fully initialized and still active, and that its owner can
     * deal with asynchronous and external state changes. There may be multiple
     * objects with the same name, and the function may fail even if a matching
     * object exists. DO NOT USE THIS IN NEW CODE. */
#ifndef NDEBUG
    /* This was officially deprecated on August 19 2009. For the convenience of
     * wannabe code janitors, this is the list of names that remain used
     * and unfixed since then. */
    static const char bad[][11] = { ""adjust"", ""clone"", ""colorthres"",
        ""erase"", ""extract"", ""gradient"", ""logo"", ""marq"", ""motionblur"", ""puzzle"",
        ""rotate"", ""sharpen"", ""transform"", ""v4l2"", ""wall"" };
    static const char poor[][13] = { ""invert"", ""magnify"", ""motiondetect"",
        ""psychedelic"", ""ripple"", ""wave...",378.0,406.0,1.0,1.0,29.0,12,6,19,8,0,5,2,2,0,3,,0,3,4,2,2,vlc_object_t
2805,120642,vlc_object_hold,1,vlc_object_hold,void* vlc_object_hold (vlc_object_t*),misc\objects.c,"void * vlc_object_hold( vlc_object_t *p_this )
{
    vlc_object_internals_t *internals = vlc_internals( p_this );
#ifndef NDEBUG
    unsigned refs = atomic_fetch_add (&internals->refs, 1);
    assert (refs > 0); /* Avoid obvious freed object uses */
#else
    atomic_fetch_add (&internals->refs, 1);
#endif
    return p_this;
}",412.0,422.0,1.0,40.0,11.0,7,6,7,3,10,0,1,1,0,0,,0,0,2,1,1,void*
2806,120674,vlc_object_release,1,vlc_object_release,void vlc_object_release (vlc_object_t*),misc\objects.c,"void vlc_object_release (vlc_object_t *obj)
{
    vlc_object_internals_t *priv = vlc_internals(obj);
    unsigned refs = atomic_load (&priv->refs);

    /* Fast path */
    while (refs > 1)
    {
        if (atomic_compare_exchange_weak (&priv->refs, &refs, refs - 1))
            return; /* There are still other references to the object */

        assert (refs > 0);
    }

    vlc_object_t *parent = obj->obj.parent;

    if (unlikely(parent == NULL))
    {   /* Destroying the root object */
        refs = atomic_fetch_sub (&priv->refs, 1);
        assert (refs == 1); /* nobody to race against in this case */

        assert (priv->first == NULL); /* no children can be left */

        int canc = vlc_savecancel ();
        vlc_object_destroy (obj);
        vlc_restorecancel (canc);
        return;
    }

    /* Slow path */
    vlc_object_internals_t *papriv = vlc_internals (parent);

    vlc_mutex_lock (&papriv->tree_lock);
    refs = atomic_fetch_sub (&priv->refs, 1);
    assert (...",429.0,498.0,1.0,35.0,70.0,53,9,54,9,88,8,8,11,0,8,,0,2,2,1,1,void
2807,120881,vlc_list_children,1,vlc_list_children,vlc_list_t vlc_list_children (vlc_object_t*),misc\objects.c,"vlc_list_t *vlc_list_children( vlc_object_t *obj )
{
    vlc_list_t *l = malloc (sizeof (*l));
    if (unlikely(l == NULL))
        return NULL;

    l->i_count = 0;
    l->p_values = NULL;

    vlc_object_internals_t *priv;
    unsigned count = 0;

    vlc_mutex_lock (&vlc_internals(obj)->tree_lock);
    for (priv = vlc_internals (obj)->first; priv; priv = priv->next)
         count++;

    if (count > 0)
    {
        l->p_values = vlc_alloc (count, sizeof (vlc_value_t));
        if (unlikely(l->p_values == NULL))
        {
            vlc_mutex_unlock (&vlc_internals(obj)->tree_lock);
            free (l);
            return NULL;
        }
        l->i_count = count;
    }

    unsigned i = 0;

    for (priv = vlc_internals (obj)->first; priv; priv = priv->next)
        l->p_values[i++].p_address = vlc_object_hold (vlc_externals (priv));
    vlc_mutex_unlock (&vlc_internals(obj)->tree_lock);
    return l;
}",506.0,540.0,1.0,21.0,35.0,38,9,35,7,0,3,6,7,0,3,,0,0,2,1,1,vlc_list_t
2808,121053,vlc_list_release,1,vlc_list_release,void vlc_list_release (vlc_list_t*),misc\objects.c,"void vlc_list_release( vlc_list_t *p_list )
{
    for( int i = 0; i < p_list->i_count; i++ )
        vlc_object_release( p_list->p_values[i].p_address );

    free( p_list->p_values );
    free( p_list );
}",548.0,555.0,1.0,1.0,8.0,4,3,5,2,0,0,2,2,0,0,,0,0,2,1,1,void
2809,121109,release,1,vlc_res.release,void vlc_res.release (void*),misc\objres.c,void (*release)(void *);,38.0,38.0,10.0,27.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2810,121120,vlc_obj_res,1,vlc_obj_res,struct vlc_res vlc_obj_res (vlc_object_t*),misc\objres.c,"static struct vlc_res **vlc_obj_res(vlc_object_t *obj)
{
    return &vlc_internals(obj)->resources;
}",42.0,45.0,1.0,12.0,4.0,4,4,2,1,1,0,1,1,0,0,,0,0,2,1,1,struct vlc_res
2811,121203,vlc_objres_pop,1,vlc_objres_pop,void* vlc_objres_pop (vlc_object_t*),misc\objres.c,"static void *vlc_objres_pop(vlc_object_t *obj)
{
    struct vlc_res **restrict pp = vlc_obj_res(obj);
    struct vlc_res *res = *pp;

    if (res == NULL)
        return NULL;
    *pp = res->prev;
    return res->payload;
}",72.0,81.0,1.0,1.0,10.0,8,4,10,4,0,3,2,2,0,1,,0,3,2,1,1,void*
2812,121313,dummy_release,1,dummy_release,void dummy_release (void*),misc\objres.c,"static void dummy_release(void *data)
{
    (void) data;
}",126.0,129.0,1.0,1.0,4.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
2813,121321,ptrcmp,1,ptrcmp,"bool ptrcmp (void*,void*)",misc\objres.c,"static bool ptrcmp(void *a, void *b)
{
    return a == b;
}",131.0,134.0,1.0,1.0,4.0,1,1,2,2,0,0,1,1,0,0,,0,0,4,2,2,bool
2814,121331,vlc_obj_malloc,1,vlc_obj_malloc,"void* vlc_obj_malloc (vlc_object_t*,size_t)",misc\objres.c,"void *vlc_obj_malloc(vlc_object_t *obj, size_t size)
{
    void *ptr = vlc_objres_new(size, dummy_release);
    if (likely(ptr != NULL))
        vlc_objres_push(obj, ptr);
    return ptr;
}",136.0,142.0,1.0,1.0,7.0,2,2,7,4,0,2,2,2,0,2,,0,1,4,2,2,void*
2815,121354,vlc_obj_alloc_common,1,vlc_obj_alloc_common,"void* vlc_obj_alloc_common (vlc_object_t*,size_t,size_t,bool)",misc\objres.c,"static void *vlc_obj_alloc_common(vlc_object_t *obj, size_t nmemb, size_t size,
                                  bool do_memset)
{
    size_t tabsize;
    if (mul_overflow(nmemb, size, &tabsize))
    {
        errno = ENOMEM;
        return NULL;
    }

    void *ptr = vlc_objres_new(tabsize, dummy_release);
    if (likely(ptr != NULL))
    {
        if (do_memset)
            memset(ptr, 0, tabsize);
        vlc_objres_push(obj, ptr);
    }
    return ptr;
}",144.0,162.0,1.0,1.0,19.0,4,3,16,9,1,2,4,5,0,2,,0,1,8,4,4,void*
2816,121399,vlc_obj_calloc,1,vlc_obj_calloc,"void* vlc_obj_calloc (vlc_object_t*,size_t,size_t)",misc\objres.c,"void *vlc_obj_calloc(vlc_object_t *obj, size_t nmemb, size_t size)
{
    return vlc_obj_alloc_common(obj, nmemb, size, true);
}",164.0,167.0,1.0,1.0,4.0,0,0,4,4,0,1,1,1,0,1,,0,0,6,3,3,void*
2817,121412,vlc_obj_free,1,vlc_obj_free,"void vlc_obj_free (vlc_object_t*,void*)",misc\objres.c,"void vlc_obj_free(vlc_object_t *obj, void *ptr)
{
    vlc_objres_remove(obj, ptr, ptrcmp);
}",169.0,172.0,1.0,1.0,4.0,0,0,2,2,0,1,1,1,0,1,,0,0,4,2,2,void
2818,121439,AllocatePicture,1,AllocatePicture,int AllocatePicture (picture_t*),misc\picture.c,"static int AllocatePicture( picture_t *p_pic )
{
    /* Calculate how big the new image should be */
    size_t i_bytes = 0;
    for( int i = 0; i < p_pic->i_planes; i++ )
    {
        const plane_t *p = &p_pic->p[i];

        if( p->i_pitch < 0 || p->i_lines <= 0 ||
            (size_t)p->i_pitch > (SIZE_MAX - i_bytes)/p->i_lines )
        {
            p_pic->i_planes = 0;
            return VLC_ENOMEM;
        }
        i_bytes += p->i_pitch * p->i_lines;
    }

    if( i_bytes >= PICTURE_SW_SIZE_MAX )
    {
        p_pic->i_planes = 0;
        return VLC_ENOMEM;
    }

    i_bytes = (i_bytes + 63) & ~63; /* must be a multiple of 64 */
    uint8_t *p_data = aligned_alloc( 64, i_bytes );
    if( i_bytes > 0 && p_data == NULL )
    {
        p_pic->i_planes = 0;
        return VLC_EGENERIC;
    }

    /* Fill the p_pixels field for each plane */
    p_pic->p[0].p_pixels = p_data;
    for( int i = 1; i < p_pic->i_planes; i++ )
    {
        p_pic->p[i].p_pixels = &p_pic->p[i-1].p_p...",50.0,90.0,1.0,19.0,41.0,66,21,44,10,0,0,6,7,0,0,,0,0,2,1,1,int
2819,121623,PictureDestroyContext,1,PictureDestroyContext,void PictureDestroyContext (picture_t*),misc\picture.c,"static void PictureDestroyContext( picture_t *p_picture )
{
    picture_context_t *ctx = p_picture->context;
    if (ctx != NULL)
    {
        ctx->destroy(ctx);
        p_picture->context = NULL;
    }
}",96.0,104.0,1.0,1.0,9.0,6,3,8,3,2,0,2,2,0,0,,0,0,2,1,1,void
2820,121649,picture_DestroyFromResource,1,picture_DestroyFromResource,void picture_DestroyFromResource (picture_t*),misc\picture.c,"static void picture_DestroyFromResource( picture_t *p_picture )
{
    free( p_picture->p_sys );
    free( p_picture );
}",110.0,114.0,1.0,1.0,5.0,1,1,2,1,0,0,1,1,0,0,,0,0,2,1,1,void
2821,121660,picture_Destroy,1,picture_Destroy,void picture_Destroy (picture_t*),misc\picture.c,"static void picture_Destroy( picture_t *p_picture )
{
    aligned_free( p_picture->p[0].p_pixels );
    free( p_picture );
}",120.0,124.0,1.0,1.0,5.0,3,3,2,1,0,0,1,1,0,0,,0,0,2,1,1,void
2822,121675,picture_Reset,1,picture_Reset,void picture_Reset (picture_t*),misc\picture.c,"void picture_Reset( picture_t *p_picture )
{
    /* */
    p_picture->date = VLC_TS_INVALID;
    p_picture->b_force = false;
    p_picture->b_progressive = false;
    p_picture->i_nb_fields = 2;
    p_picture->b_top_field_first = false;
    PictureDestroyContext( p_picture );
}",129.0,138.0,1.0,1.0,10.0,10,2,10,3,2,1,1,1,0,1,,0,0,2,1,1,void
2823,121707,LCM,1,LCM,"int LCM (int,int)",misc\picture.c,"static int LCM( int a, int b )
{
    return a * b / GCD( a, b );
}",143.0,146.0,1.0,1.0,4.0,2,2,4,2,3,0,1,1,0,0,,0,0,4,2,2,int
2824,121721,picture_Setup,1,picture_Setup,"int picture_Setup (picture_t*,video_format_t*)",misc\picture.c,"int picture_Setup( picture_t *p_picture, const video_format_t *restrict fmt )
{
    /* Store default values */
    p_picture->i_planes = 0;
    for( unsigned i = 0; i < VOUT_MAX_PLANES; i++ )
    {
        plane_t *p = &p_picture->p[i];
        p->p_pixels = NULL;
        p->i_pixel_pitch = 0;
    }

    p_picture->i_nb_fields = 2;

    video_format_Setup( &p_picture->format, fmt->i_chroma, fmt->i_width, fmt->i_height,
                        fmt->i_visible_width, fmt->i_visible_height,
                        fmt->i_sar_num, fmt->i_sar_den );

    const vlc_chroma_description_t *p_dsc =
        vlc_fourcc_GetChromaDescription( p_picture->format.i_chroma );
    if( !p_dsc )
        return VLC_EGENERIC;

    /* We want V (width/height) to respect:
        (V * p_dsc->p[i].w.i_num) % p_dsc->p[i].w.i_den == 0
        (V * p_dsc->p[i].w.i_num/p_dsc->p[i].w.i_den * p_dsc->i_pixel_size) % 16 == 0
       Which is respected if you have
       V % lcm( p_dsc->p[0..planes].w.i_den * 16) == 0
...",148.0,206.0,1.0,1.0,59.0,153,13,100,15,1,5,6,7,0,5,,0,4,4,2,2,int
2825,122113,picture_NewFromResource,1,picture_NewFromResource,"picture_t picture_NewFromResource (video_format_t*,picture_resource_t*)",misc\picture.c,"picture_t *picture_NewFromResource( const video_format_t *p_fmt, const picture_resource_t *p_resource )
{
    video_format_t fmt = *p_fmt;

    /* It is needed to be sure all information are filled */
    video_format_Setup( &fmt, p_fmt->i_chroma,
                              p_fmt->i_width, p_fmt->i_height,
                              p_fmt->i_visible_width, p_fmt->i_visible_height,
                              p_fmt->i_sar_num, p_fmt->i_sar_den );
    if( p_fmt->i_x_offset < p_fmt->i_width &&
        p_fmt->i_y_offset < p_fmt->i_height &&
        p_fmt->i_visible_width  > 0 && p_fmt->i_x_offset + p_fmt->i_visible_width  <= p_fmt->i_width &&
        p_fmt->i_visible_height > 0 && p_fmt->i_y_offset + p_fmt->i_visible_height <= p_fmt->i_height )
        video_format_CopyCrop( &fmt, p_fmt );

    /* */
    picture_priv_t *priv = malloc( sizeof (*priv) );
    if( unlikely(priv == NULL) )
        return NULL;

    picture_t *p_picture = &priv->picture;

    memset( p_picture, 0, siz...",211.0,273.0,1.0,1.0,63.0,87,14,65,7,3,7,7,9,1,3,,0,5,4,2,2,picture_t
2826,122376,picture_NewFromFormat,1,picture_NewFromFormat,picture_t picture_NewFromFormat (video_format_t*),misc\picture.c,"picture_t *picture_NewFromFormat( const video_format_t *p_fmt )
{
    return picture_NewFromResource( p_fmt, NULL );
}",275.0,278.0,1.0,1.0,4.0,0,0,2,2,10,1,1,1,0,1,,0,0,2,1,1,picture_t
2827,122385,picture_New,1,picture_New,"picture_t picture_New (vlc_fourcc_t,int,int,int,int)",misc\picture.c,"picture_t *picture_New( vlc_fourcc_t i_chroma, int i_width, int i_height, int i_sar_num, int i_sar_den )
{
    video_format_t fmt;

    video_format_Init( &fmt, 0 );
    video_format_Setup( &fmt, i_chroma, i_width, i_height,
                        i_width, i_height, i_sar_num, i_sar_den );

    return picture_NewFromFormat( &fmt );
}",280.0,289.0,1.0,1.0,10.0,3,1,10,6,0,2,1,1,0,2,,0,0,10,5,5,picture_t
2828,122413,picture_Hold,1,picture_Hold,picture_t picture_Hold (picture_t*),misc\picture.c,"picture_t *picture_Hold( picture_t *p_picture )
{
    assert( p_picture != NULL );

    picture_priv_t *priv = (picture_priv_t *)p_picture;
    uintptr_t refs = atomic_fetch_add( &priv->gc.refs, 1 );
    assert( refs > 0 );
    return p_picture;
}",295.0,303.0,1.0,1.0,9.0,8,7,8,4,10,1,1,1,0,0,,0,1,2,1,1,picture_t
2829,122445,picture_Release,1,picture_Release,void picture_Release (picture_t*),misc\picture.c,"void picture_Release( picture_t *p_picture )
{
    assert( p_picture != NULL );

    picture_priv_t *priv = (picture_priv_t *)p_picture;
    uintptr_t refs = atomic_fetch_sub( &priv->gc.refs, 1 );
    assert( refs != 0 );
    if( refs > 1 )
        return;

    PictureDestroyContext( p_picture );
    assert( priv->gc.destroy != NULL );
    priv->gc.destroy( p_picture );
}",305.0,318.0,1.0,1.0,14.0,14,7,13,4,27,4,2,2,0,1,,0,3,2,1,1,void
2830,122498,plane_CopyPixels,1,plane_CopyPixels,"void plane_CopyPixels (plane_t*,plane_t*)",misc\picture.c,"void plane_CopyPixels( plane_t *p_dst, const plane_t *p_src )
{
    const unsigned i_width  = __MIN( p_dst->i_visible_pitch,
                                     p_src->i_visible_pitch );
    const unsigned i_height = __MIN( p_dst->i_lines, p_src->i_lines );

    /* The 2x visible pitch check does two things:
       1) Makes field plane_t's work correctly (see the deinterlacer module)
       2) Moves less data if the pitch and visible pitch differ much.
    */
    if( p_src->i_pitch == p_dst->i_pitch  &&
        p_src->i_pitch < 2*p_src->i_visible_pitch )
    {
        /* There are margins, but with the same width : perfect ! */
        memcpy( p_dst->p_pixels, p_src->p_pixels,
                    p_src->i_pitch * i_height );
    }
    else
    {
        /* We need to proceed line by line */
        uint8_t *p_in = p_src->p_pixels;
        uint8_t *p_out = p_dst->p_pixels;

        assert( p_in );
        assert( p_out );

        for( int i_line = i_height; i_line--; )
        {
  ...",323.0,356.0,1.0,1.0,34.0,18,6,14,4,0,0,2,2,0,0,,0,0,4,2,2,void
2831,122596,picture_CopyProperties,1,picture_CopyProperties,"void picture_CopyProperties (picture_t*,picture_t*)",misc\picture.c,"void picture_CopyProperties( picture_t *p_dst, const picture_t *p_src )
{
    p_dst->date = p_src->date;
    p_dst->b_force = p_src->b_force;

    p_dst->b_progressive = p_src->b_progressive;
    p_dst->i_nb_fields = p_src->i_nb_fields;
    p_dst->b_top_field_first = p_src->b_top_field_first;
}",358.0,366.0,1.0,1.0,9.0,15,2,10,2,1,0,1,1,0,0,,0,0,4,2,2,void
2832,122637,picture_CopyPixels,1,picture_CopyPixels,"void picture_CopyPixels (picture_t*,picture_t*)",misc\picture.c,"void picture_CopyPixels( picture_t *p_dst, const picture_t *p_src )
{
    for( int i = 0; i < p_src->i_planes ; i++ )
        plane_CopyPixels( p_dst->p+i, p_src->p+i );

    assert( p_dst->context == NULL );

    if( p_src->context != NULL )
        p_dst->context = p_src->context->copy( p_src->context );
}",368.0,377.0,1.0,1.0,10.0,12,5,10,4,1,0,3,3,0,0,,0,0,4,2,2,void
2833,122693,picture_Copy,1,picture_Copy,"void picture_Copy (picture_t*,picture_t*)",misc\picture.c,"void picture_Copy( picture_t *p_dst, const picture_t *p_src )
{
    picture_CopyPixels( p_dst, p_src );
    picture_CopyProperties( p_dst, p_src );
}",379.0,383.0,1.0,1.0,5.0,0,0,4,2,2,2,1,1,0,2,,0,0,4,2,2,void
2834,122705,picture_DestroyClone,1,picture_DestroyClone,void picture_DestroyClone (picture_t*),misc\picture.c,"static void picture_DestroyClone(picture_t *clone)
{
    picture_t *picture = ((picture_priv_t *)clone)->gc.opaque;

    free(clone);
    picture_Release(picture);
}",385.0,391.0,1.0,1.0,7.0,4,4,4,2,0,1,1,1,0,1,,0,0,2,1,1,void
2835,122724,picture_Clone,1,picture_Clone,picture_t picture_Clone (picture_t*),misc\picture.c,"picture_t *picture_Clone(picture_t *picture)
{
    /* TODO: merge common code with picture_pool_ClonePicture(). */
    picture_resource_t res = {
        .p_sys = picture->p_sys,
        .pf_destroy = picture_DestroyClone,
    };

    for (int i = 0; i < picture->i_planes; i++) {
        res.p[i].p_pixels = picture->p[i].p_pixels;
        res.p[i].i_lines = picture->p[i].i_lines;
        res.p[i].i_pitch = picture->p[i].i_pitch;
    }

    picture_t *clone = picture_NewFromResource(&picture->format, &res);
    if (likely(clone != NULL)) {
        ((picture_priv_t *)clone)->gc.opaque = picture;
        picture_Hold(picture);

        if (picture->context != NULL)
            clone->context = picture->context->copy(picture->context);
    }
    return clone;
}",393.0,416.0,1.0,1.0,24.0,45,9,33,7,1,2,4,5,0,2,,0,1,2,1,1,picture_t
2836,122851,picture_Export,1,picture_Export,"int picture_Export (vlc_object_t*,block_t**,video_format_t*,picture_t*,vlc_fourcc_t,int,int)",misc\picture.c,"int picture_Export( vlc_object_t *p_obj,
                    block_t **pp_image,
                    video_format_t *p_fmt,
                    picture_t *p_picture,
                    vlc_fourcc_t i_format,
                    int i_override_width, int i_override_height )
{
    /* */
    video_format_t fmt_in = p_picture->format;
    if( fmt_in.i_sar_num <= 0 || fmt_in.i_sar_den <= 0 )
    {
        fmt_in.i_sar_num =
        fmt_in.i_sar_den = 1;
    }

    /* */
    video_format_t fmt_out;
    memset( &fmt_out, 0, sizeof(fmt_out) );
    fmt_out.i_sar_num =
    fmt_out.i_sar_den = 1;
    fmt_out.i_chroma  = i_format;

    /* compute original width/height */
    unsigned int i_width, i_height, i_original_width, i_original_height;
    if( fmt_in.i_visible_width > 0 && fmt_in.i_visible_height > 0 )
    {
        i_width = fmt_in.i_visible_width;
        i_height = fmt_in.i_visible_height;
    }
    else
    {
        i_width = fmt_in.i_width;
        i_height = fmt_in.i_height;
    ...",421.0,503.0,1.0,1.0,83.0,78,18,63,18,1,2,8,8,0,2,,0,1,14,7,7,int
2837,123151,destroy,1,picture_priv_t.gc.destroy,void picture_priv_t.gc.destroy (picture_t*),misc\picture.h,void (*destroy)(picture_t *);,30.0,30.0,14.0,36.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2838,123176,PictureFifoReset,1,PictureFifoReset,void PictureFifoReset (picture_fifo_t*),misc\picture_fifo.c,"static void PictureFifoReset(picture_fifo_t *fifo)
{
    fifo->first    = NULL;
    fifo->last_ptr = &fifo->first;
}",46.0,50.0,1.0,1.0,5.0,6,3,4,2,3,3,1,1,0,0,,0,3,2,1,1,void
2839,123194,PictureFifoPush,1,PictureFifoPush,"void PictureFifoPush (picture_fifo_t*,picture_t*)",misc\picture_fifo.c,"static void PictureFifoPush(picture_fifo_t *fifo, picture_t *picture)
{
    assert(!picture->p_next);
    *fifo->last_ptr = picture;
    fifo->last_ptr  = &picture->p_next;
}",51.0,56.0,1.0,1.0,6.0,9,5,5,2,2,2,1,1,0,0,,0,2,4,2,2,void
2840,123219,PictureFifoPop,1,PictureFifoPop,picture_t PictureFifoPop (picture_fifo_t*),misc\picture_fifo.c,"static picture_t *PictureFifoPop(picture_fifo_t *fifo)
{
    picture_t *picture = fifo->first;

    if (picture) {
        fifo->first = picture->p_next;
        if (!fifo->first)
            fifo->last_ptr = &fifo->first;
        picture->p_next = NULL;
    }
    return picture;
}",57.0,68.0,1.0,1.0,12.0,13,4,11,3,2,5,3,4,1,0,,0,5,2,1,1,picture_t
2841,123261,picture_fifo_New,1,picture_fifo_New,picture_fifo_t picture_fifo_New (void),misc\picture_fifo.c,"picture_fifo_t *picture_fifo_New(void)
{
    picture_fifo_t *fifo = malloc(sizeof(*fifo));
    if (!fifo)
        return NULL;

    vlc_mutex_init(&fifo->lock);
    PictureFifoReset(fifo);
    return fifo;
}",70.0,79.0,1.0,1.0,10.0,6,6,7,2,2,3,2,2,0,2,,0,1,2,1,1,picture_fifo_t
2842,123288,picture_fifo_Push,1,picture_fifo_Push,"void picture_fifo_Push (picture_fifo_t*,picture_t*)",misc\picture_fifo.c,"void picture_fifo_Push(picture_fifo_t *fifo, picture_t *picture)
{
    vlc_mutex_lock(&fifo->lock);
    PictureFifoPush(fifo, picture);
    vlc_mutex_unlock(&fifo->lock);
}",81.0,86.0,1.0,1.0,6.0,4,2,4,2,2,5,1,1,0,3,,0,2,4,2,2,void
2843,123307,picture_fifo_Pop,1,picture_fifo_Pop,picture_t picture_fifo_Pop (picture_fifo_t*),misc\picture_fifo.c,"picture_t *picture_fifo_Pop(picture_fifo_t *fifo)
{
    vlc_mutex_lock(&fifo->lock);
    picture_t *picture = PictureFifoPop(fifo);
    vlc_mutex_unlock(&fifo->lock);

    return picture;
}",87.0,94.0,1.0,1.0,8.0,5,3,5,2,0,5,1,1,0,3,,0,3,2,1,1,picture_t
2844,123329,picture_fifo_Peek,1,picture_fifo_Peek,picture_t picture_fifo_Peek (picture_fifo_t*),misc\picture_fifo.c,"picture_t *picture_fifo_Peek(picture_fifo_t *fifo)
{
    vlc_mutex_lock(&fifo->lock);
    picture_t *picture = fifo->first;
    if (picture)
        picture_Hold(picture);
    vlc_mutex_unlock(&fifo->lock);

    return picture;
}",95.0,104.0,1.0,1.0,10.0,6,3,7,2,1,6,2,2,0,3,,0,3,2,1,1,picture_t
2845,123357,picture_fifo_Flush,1,picture_fifo_Flush,"void picture_fifo_Flush (picture_fifo_t*,mtime_t,bool)",misc\picture_fifo.c,"void picture_fifo_Flush(picture_fifo_t *fifo, mtime_t date, bool flush_before)
{
    picture_t *picture;

    vlc_mutex_lock(&fifo->lock);

    picture = fifo->first;
    PictureFifoReset(fifo);

    picture_fifo_t tmp;
    PictureFifoReset(&tmp);

    while (picture) {
        picture_t *next = picture->p_next;

        picture->p_next = NULL;
        if (( flush_before && picture->date <= date) ||
            (!flush_before && picture->date >= date))
            PictureFifoPush(&tmp, picture);
        else
            PictureFifoPush(fifo, picture);
        picture = next;
    }
    vlc_mutex_unlock(&fifo->lock);

    while ((picture = PictureFifoPop(&tmp)) != NULL)
        picture_Release(picture);
}",105.0,132.0,1.0,1.0,28.0,24,9,24,7,2,9,4,5,1,6,,0,4,6,3,3,void
2846,123440,picture_fifo_OffsetDate,1,picture_fifo_OffsetDate,"void picture_fifo_OffsetDate (picture_fifo_t*,mtime_t)",misc\picture_fifo.c,"void picture_fifo_OffsetDate(picture_fifo_t *fifo, mtime_t delta)
{
    vlc_mutex_lock(&fifo->lock);
    for (picture_t *picture = fifo->first; picture != NULL;) {
        picture->date += delta;
        picture = picture->p_next;
    }
    vlc_mutex_unlock(&fifo->lock);
}",133.0,141.0,1.0,1.0,9.0,11,5,10,4,1,5,2,2,0,2,,0,3,4,2,2,void
2847,123478,picture_fifo_Delete,1,picture_fifo_Delete,void picture_fifo_Delete (picture_fifo_t*),misc\picture_fifo.c,"void picture_fifo_Delete(picture_fifo_t *fifo)
{
    picture_fifo_Flush(fifo, INT64_MAX, true);
    vlc_mutex_destroy(&fifo->lock);
    free(fifo);
}",142.0,147.0,1.0,1.0,6.0,2,2,5,3,3,3,1,1,0,2,,0,1,2,1,1,void
2848,123517,pic_lock,1,picture_pool_t.pic_lock,int picture_pool_t.pic_lock (picture_t*),misc\picture_pool.c,int       (*pic_lock)(picture_t *);,42.0,42.0,15.0,38.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
2849,123522,pic_unlock,1,picture_pool_t.pic_unlock,void picture_pool_t.pic_unlock (picture_t*),misc\picture_pool.c,void      (*pic_unlock)(picture_t *);,43.0,43.0,15.0,40.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2850,123539,picture_pool_Destroy,1,picture_pool_Destroy,void picture_pool_Destroy (picture_pool_t*),misc\picture_pool.c,"static void picture_pool_Destroy(picture_pool_t *pool)
{
    if (atomic_fetch_sub(&pool->refs, 1) != 1)
        return;

    vlc_cond_destroy(&pool->wait);
    vlc_mutex_destroy(&pool->lock);
    aligned_free(pool);
}",54.0,62.0,1.0,1.0,9.0,7,3,4,1,2,5,2,2,1,2,,0,3,2,1,1,void
2851,123567,picture_pool_Release,1,picture_pool_Release,void picture_pool_Release (picture_pool_t*),misc\picture_pool.c,"void picture_pool_Release(picture_pool_t *pool)
{
    for (unsigned i = 0; i < pool->picture_count; i++)
        picture_Release(pool->picture[i]);
    picture_pool_Destroy(pool);
}",64.0,69.0,1.0,1.0,6.0,3,3,4,2,0,2,2,2,1,1,,0,1,2,1,1,void
2852,123593,picture_pool_ReleasePicture,1,picture_pool_ReleasePicture,void picture_pool_ReleasePicture (picture_t*),misc\picture_pool.c,"static void picture_pool_ReleasePicture(picture_t *clone)
{
    picture_priv_t *priv = (picture_priv_t *)clone;
    uintptr_t sys = (uintptr_t)priv->gc.opaque;
    picture_pool_t *pool = (void *)(sys & ~(POOL_MAX - 1));
    unsigned offset = sys & (POOL_MAX - 1);
    picture_t *picture = pool->picture[offset];

    free(clone);

    if (pool->pic_unlock != NULL)
        pool->pic_unlock(picture);
    picture_Release(picture);

    vlc_mutex_lock(&pool->lock);
    assert(!(pool->available & (1ULL << offset)));
    pool->available |= 1ULL << offset;
    vlc_cond_signal(&pool->wait);
    vlc_mutex_unlock(&pool->lock);

    picture_pool_Destroy(pool);
}",71.0,92.0,1.0,44.0,22.0,36,14,29,9,0,12,2,2,0,5,,0,7,2,1,1,void
2853,123700,picture_pool_ClonePicture,1,picture_pool_ClonePicture,"picture_t picture_pool_ClonePicture (picture_pool_t*,unsigned)",misc\picture_pool.c,"static picture_t *picture_pool_ClonePicture(picture_pool_t *pool,
                                            unsigned offset)
{
    picture_t *picture = pool->picture[offset];
    uintptr_t sys = ((uintptr_t)pool) + offset;
    picture_resource_t res = {
        .p_sys = picture->p_sys,
        .pf_destroy = picture_pool_ReleasePicture,
    };

    for (int i = 0; i < picture->i_planes; i++) {
        res.p[i].p_pixels = picture->p[i].p_pixels;
        res.p[i].i_lines = picture->p[i].i_lines;
        res.p[i].i_pitch = picture->p[i].i_pitch;
    }

    picture_t *clone = picture_NewFromResource(&picture->format, &res);
    if (likely(clone != NULL)) {
        ((picture_priv_t *)clone)->gc.opaque = (void *)sys;
        picture_Hold(picture);
    }
    return clone;
}",94.0,116.0,1.0,1.0,23.0,45,10,34,10,2,3,3,3,0,2,,0,2,4,2,2,picture_t
2854,123826,picture_pool_NewExtended,1,picture_pool_NewExtended,picture_pool_t picture_pool_NewExtended (picture_pool_configuration_t*),misc\picture_pool.c,"picture_pool_t *picture_pool_NewExtended(const picture_pool_configuration_t *cfg)
{
    if (unlikely(cfg->picture_count > POOL_MAX))
        return NULL;

    picture_pool_t *pool;
    size_t size = sizeof (*pool) + cfg->picture_count * sizeof (picture_t *);

    size += (-size) & (POOL_MAX - 1);
    pool = aligned_alloc(POOL_MAX, size);
    if (unlikely(pool == NULL))
        return NULL;

    pool->pic_lock   = cfg->lock;
    pool->pic_unlock = cfg->unlock;
    vlc_mutex_init(&pool->lock);
    vlc_cond_init(&pool->wait);
    if (cfg->picture_count == POOL_MAX)
        pool->available = ~0ULL;
    else
        pool->available = (1ULL << cfg->picture_count) - 1;
    atomic_init(&pool->refs,  1);
    pool->picture_count = cfg->picture_count;
    memcpy(pool->picture, cfg->picture,
           cfg->picture_count * sizeof (picture_t *));
    pool->canceled = false;
    return pool;
}",118.0,145.0,1.0,38.0,28.0,50,14,39,8,1,9,4,4,0,2,,0,7,2,1,1,picture_pool_t
2855,123979,picture_pool_New,1,picture_pool_New,"picture_pool_t picture_pool_New (unsigned,picture_t**)",misc\picture_pool.c,"picture_pool_t *picture_pool_New(unsigned count, picture_t *const *tab)
{
    picture_pool_configuration_t cfg = {
        .picture_count = count,
        .picture = tab,
    };

    return picture_pool_NewExtended(&cfg);
}",147.0,155.0,1.0,1.0,9.0,5,3,6,5,2,1,1,1,0,1,,0,0,4,2,2,picture_pool_t
2856,124001,picture_pool_NewFromFormat,1,picture_pool_NewFromFormat,"picture_pool_t picture_pool_NewFromFormat (video_format_t*,unsigned)",misc\picture_pool.c,"picture_pool_t *picture_pool_NewFromFormat(const video_format_t *fmt,
                                           unsigned count)
{
    picture_t *picture[count ? count : 1];
    unsigned i;

    for (i = 0; i < count; i++) {
        picture[i] = picture_NewFromFormat(fmt);
        if (picture[i] == NULL)
            goto error;
    }

    picture_pool_t *pool = picture_pool_New(count, picture);
    if (!pool)
        goto error;

    return pool;

error:
    while (i > 0)
        picture_Release(picture[--i]);
    return NULL;
}",157.0,179.0,1.0,1.0,23.0,9,6,16,6,1,2,7,6,0,2,,0,2,4,2,2,picture_pool_t
2857,124059,picture_pool_Reserve,1,picture_pool_Reserve,"picture_pool_t picture_pool_Reserve (picture_pool_t*,unsigned)",misc\picture_pool.c,"picture_pool_t *picture_pool_Reserve(picture_pool_t *master, unsigned count)
{
    picture_t *picture[count ? count : 1];
    unsigned i;

    for (i = 0; i < count; i++) {
        picture[i] = picture_pool_Get(master);
        if (picture[i] == NULL)
            goto error;
    }

    picture_pool_t *pool = picture_pool_New(count, picture);
    if (!pool)
        goto error;

    return pool;

error:
    while (i > 0)
        picture_Release(picture[--i]);
    return NULL;
}",181.0,202.0,1.0,1.0,22.0,9,6,16,6,0,2,7,6,0,2,,0,2,4,2,2,picture_pool_t
2858,124117,fnsll,1,fnsll,"int fnsll (long long unsigned,unsigned)",misc\picture_pool.c,"static int fnsll(unsigned long long x, unsigned i)
{
    if (i >= CHAR_BIT * sizeof (x))
        return 0;
    return ffsll(x & ~((1ULL << i) - 1));
}",205.0,210.0,1.0,1.0,6.0,7,7,5,3,0,0,2,2,0,0,,0,0,4,2,2,int
2859,124143,picture_pool_Get,1,picture_pool_Get,picture_t picture_pool_Get (picture_pool_t*),misc\picture_pool.c,"picture_t *picture_pool_Get(picture_pool_t *pool)
{
    vlc_mutex_lock(&pool->lock);
    assert(pool->refs > 0);

    if (pool->canceled)
    {
        vlc_mutex_unlock(&pool->lock);
        return NULL;
    }

    for (unsigned i = ffsll(pool->available); i; i = fnsll(pool->available, i))
    {
        pool->available &= ~(1ULL << (i - 1));
        vlc_mutex_unlock(&pool->lock);

        picture_t *picture = pool->picture[i - 1];

        if (pool->pic_lock != NULL && pool->pic_lock(picture) != VLC_SUCCESS) {
            vlc_mutex_lock(&pool->lock);
            pool->available |= 1ULL << (i - 1);
            continue;
        }

        picture_t *clone = picture_pool_ClonePicture(pool, i - 1);
        if (clone != NULL) {
            assert(clone->p_next == NULL);
            atomic_fetch_add(&pool->refs, 1);
        }
        return clone;
    }

    vlc_mutex_unlock(&pool->lock);
    return NULL;
}",212.0,246.0,1.0,1.0,35.0,38,11,33,6,5,18,6,7,1,6,,0,13,2,1,1,picture_t
2860,124278,picture_pool_Wait,1,picture_pool_Wait,picture_t picture_pool_Wait (picture_pool_t*),misc\picture_pool.c,"picture_t *picture_pool_Wait(picture_pool_t *pool)
{
    unsigned i;

    vlc_mutex_lock(&pool->lock);
    assert(pool->refs > 0);

    while (pool->available == 0)
    {
        if (pool->canceled)
        {
            vlc_mutex_unlock(&pool->lock);
            return NULL;
        }
        vlc_cond_wait(&pool->wait, &pool->lock);
    }

    i = ffsll(pool->available);
    assert(i > 0);
    pool->available &= ~(1ULL << (i - 1));
    vlc_mutex_unlock(&pool->lock);

    picture_t *picture = pool->picture[i - 1];

    if (pool->pic_lock != NULL && pool->pic_lock(picture) != VLC_SUCCESS) {
        vlc_mutex_lock(&pool->lock);
        pool->available |= 1ULL << (i - 1);
        vlc_cond_signal(&pool->wait);
        vlc_mutex_unlock(&pool->lock);
        return NULL;
    }

    picture_t *clone = picture_pool_ClonePicture(pool, i - 1);
    if (clone != NULL) {
        assert(clone->p_next == NULL);
        atomic_fetch_add(&pool->refs, 1);
    }
    return clone;
}",248.0,286.0,1.0,1.0,39.0,47,11,37,6,1,24,5,6,2,8,,0,17,2,1,1,picture_t
2861,124426,picture_pool_Cancel,1,picture_pool_Cancel,"void picture_pool_Cancel (picture_pool_t*,bool)",misc\picture_pool.c,"void picture_pool_Cancel(picture_pool_t *pool, bool canceled)
{
    vlc_mutex_lock(&pool->lock);
    assert(pool->refs > 0);

    pool->canceled = canceled;
    if (canceled)
        vlc_cond_broadcast(&pool->wait);
    vlc_mutex_unlock(&pool->lock);
}",288.0,297.0,1.0,1.0,10.0,10,4,7,2,1,8,2,2,0,3,,0,5,4,2,2,void
2862,124461,picture_pool_OwnsPic,1,picture_pool_OwnsPic,"bool picture_pool_OwnsPic (picture_pool_t*,picture_t*)",misc\picture_pool.c,"bool picture_pool_OwnsPic(picture_pool_t *pool, picture_t *pic)
{
    picture_priv_t *priv = (picture_priv_t *)pic;

    while (priv->gc.destroy != picture_pool_ReleasePicture) {
        pic = priv->gc.opaque;
        priv = (picture_priv_t *)pic;
    }

    uintptr_t sys = (uintptr_t)priv->gc.opaque;
    picture_pool_t *picpool = (void *)(sys & ~(POOL_MAX - 1));
    return pool == picpool;
}",299.0,311.0,1.0,47.0,13.0,22,11,15,7,1,3,2,2,1,0,,0,3,4,2,2,bool
2863,124524,picture_pool_GetSize,1,picture_pool_GetSize,unsigned picture_pool_GetSize (picture_pool_t*),misc\picture_pool.c,"unsigned picture_pool_GetSize(const picture_pool_t *pool)
{
    return pool->picture_count;
}",313.0,316.0,1.0,1.0,4.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,unsigned
2864,124533,picture_pool_Enum,1,picture_pool_Enum,"void picture_pool_Enum (picture_pool_t*,void,void*)",misc\picture_pool.c,"void picture_pool_Enum(picture_pool_t *pool, void (*cb)(void *, picture_t *),
                       void *opaque)
{
    /* NOTE: So far, the pictures table cannot change after the pool is created
     * so there is no need to lock the pool mutex here. */
    for (unsigned i = 0; i < pool->picture_count; i++)
        cb(opaque, pool->picture[i]);
}",318.0,325.0,1.0,1.0,8.0,3,3,3,2,0,1,2,2,1,0,,0,1,6,3,3,void
2865,124575,vlc_probe,1,vlc_probe,"void* vlc_probe (vlc_object_t*,char*,size_t*)",misc\probe.c,"void *vlc_probe (vlc_object_t *obj,
                 const char *capability, size_t *restrict pcount)
{
    vlc_probe_t *probe = vlc_custom_create (obj, sizeof(*probe), ""probe"");
    if (unlikely(probe == NULL))
    {
        *pcount = 0;
        return NULL;
    }
    probe->list = NULL;
    probe->count = 0;

    module_t *mod = module_need (probe, capability, NULL, false);
    if (mod != NULL)
    {
        msg_Warn (probe, ""probing halted"");
        module_unneed (probe, mod);
    }

    void *ret = probe->list;
    *pcount = probe->count;
    vlc_object_release (probe);
    return ret;
}",31.0,54.0,1.0,25.0,24.0,17,6,27,8,2,4,3,3,0,4,,0,2,6,3,3,void*
2866,124684,init_rand48,1,init_rand48,void init_rand48 (void),misc\rand.c,"static void init_rand48 (void)
{
    if (!rand48.init)
    {
        vlc_rand_bytes (rand48.subi, sizeof (rand48.subi));
        rand48.init = true;
#if 0 // short would be more than 16-bits ?
        for (unsigned i = 0; i < 3; i++)
            subi[i] &= 0xffff;
#endif
    }
}",36.0,47.0,1.0,1.0,12.0,7,4,5,2,3,5,2,2,1,1,,0,4,2,1,1,void
2867,124708,vlc_drand48,1,vlc_drand48,double vlc_drand48 (void),misc\rand.c,"double vlc_drand48 (void)
{
    double ret;

    vlc_mutex_lock (&rand48.lock);
    init_rand48 ();
    ret = erand48 (rand48.subi);
    vlc_mutex_unlock (&rand48.lock);
    return ret;
}",58.0,67.0,1.0,1.0,10.0,6,3,5,2,0,6,1,1,0,3,,0,3,2,1,1,double
2868,124733,vlc_lrand48,1,vlc_lrand48,long vlc_lrand48 (void),misc\rand.c,"long vlc_lrand48 (void)
{
    long ret;

    vlc_mutex_lock (&rand48.lock);
    init_rand48 ();
    ret = nrand48 (rand48.subi);
    vlc_mutex_unlock (&rand48.lock);
    return ret;
}",78.0,87.0,1.0,1.0,10.0,6,3,5,2,0,6,1,1,0,3,,0,3,2,1,1,long
2869,124758,vlc_mrand48,1,vlc_mrand48,long vlc_mrand48 (void),misc\rand.c,"long vlc_mrand48 (void)
{
    long ret;

    vlc_mutex_lock (&rand48.lock);
    init_rand48 ();
    ret = jrand48 (rand48.subi);
    vlc_mutex_unlock (&rand48.lock);
    return ret;
}",98.0,107.0,1.0,1.0,10.0,6,3,5,2,0,6,1,1,0,3,,0,3,2,1,1,long
2870,124812,item_free,1,item_free,void item_free (vlc_renderer_item_t*),misc\renderer_discovery.c,"static void
item_free(vlc_renderer_item_t *p_item)
{
    free(p_item->psz_name);
    free(p_item->psz_type);
    free(p_item->psz_sout);
    free(p_item->psz_icon_uri);
    free(p_item->psz_demux_filter);
    free(p_item);
}",45.0,54.0,1.0,1.0,10.0,5,1,6,1,2,5,1,1,0,0,,0,5,2,1,1,void
2871,124839,vlc_renderer_item_new,1,vlc_renderer_item_new,"vlc_renderer_item_t vlc_renderer_item_new (char*,char*,char*,char*,char*,char*,int)",misc\renderer_discovery.c,"vlc_renderer_item_t *
vlc_renderer_item_new(const char *psz_type, const char *psz_name,
                      const char *psz_uri, const char *psz_extra_sout,
                      const char *psz_demux_filter, const char *psz_icon_uri,
                      int i_flags)
{
    assert(psz_uri != NULL);
    vlc_renderer_item_t *p_item = NULL;
    vlc_url_t url;
    vlc_UrlParse(&url, psz_uri);

    if (url.psz_protocol == NULL || url.psz_host == NULL)
        goto error;

    p_item = calloc(1, sizeof(vlc_renderer_item_t));
    if (unlikely(p_item == NULL))
        goto error;

    if ((p_item->psz_type = strdup(psz_type)) == NULL)
        goto error;

    if (psz_name != NULL)
        p_item->psz_name = strdup(psz_name);
    else if (asprintf(&p_item->psz_name, ""%s (%s)"", url.psz_protocol,
                      url.psz_host) == -1)
        p_item->psz_name = NULL;
    if (p_item->psz_name == NULL)
        goto error;

    if (asprintf(&p_item->psz_sout, ""%s{ip=%s,port=%d%s%s}"",
     ...",56.0,107.0,1.0,1.0,52.0,45,11,50,11,0,12,17,10,5,4,,0,8,14,7,7,vlc_renderer_item_t
2872,125032,vlc_renderer_item_name,1,vlc_renderer_item_name,const char* vlc_renderer_item_name (vlc_renderer_item_t*),misc\renderer_discovery.c,"const char *
vlc_renderer_item_name(const vlc_renderer_item_t *p_item)
{
    assert(p_item != NULL);

    return p_item->psz_name;
}",109.0,115.0,1.0,1.0,7.0,2,2,3,2,0,1,1,1,0,0,,0,1,2,1,1,const char*
2873,125045,vlc_renderer_item_type,1,vlc_renderer_item_type,const char* vlc_renderer_item_type (vlc_renderer_item_t*),misc\renderer_discovery.c,"const char *
vlc_renderer_item_type(const vlc_renderer_item_t *p_item)
{
    assert(p_item != NULL);

    return p_item->psz_type;
}",117.0,123.0,1.0,1.0,7.0,2,2,3,2,0,1,1,1,0,0,,0,1,2,1,1,const char*
2874,125058,vlc_renderer_item_sout,1,vlc_renderer_item_sout,const char* vlc_renderer_item_sout (vlc_renderer_item_t*),misc\renderer_discovery.c,"const char *
vlc_renderer_item_sout(const vlc_renderer_item_t *p_item)
{
    assert(p_item != NULL);

    return p_item->psz_sout;
}",125.0,131.0,1.0,1.0,7.0,2,2,3,2,0,1,1,1,0,0,,0,1,2,1,1,const char*
2875,125071,vlc_renderer_item_icon_uri,1,vlc_renderer_item_icon_uri,const char* vlc_renderer_item_icon_uri (vlc_renderer_item_t*),misc\renderer_discovery.c,"const char *
vlc_renderer_item_icon_uri(const vlc_renderer_item_t *p_item)
{
    assert(p_item != NULL);

    return p_item->psz_icon_uri;
}",133.0,139.0,1.0,1.0,7.0,2,2,3,2,0,1,1,1,0,0,,0,1,2,1,1,const char*
2876,125084,vlc_renderer_item_demux_filter,1,vlc_renderer_item_demux_filter,const char* vlc_renderer_item_demux_filter (vlc_renderer_item_t*),misc\renderer_discovery.c,"const char *
vlc_renderer_item_demux_filter(const vlc_renderer_item_t *p_item)
{
    assert(p_item != NULL);

    return p_item->psz_demux_filter;
}",141.0,147.0,1.0,1.0,7.0,2,2,3,2,0,1,1,1,0,0,,0,1,2,1,1,const char*
2877,125097,vlc_renderer_item_flags,1,vlc_renderer_item_flags,int vlc_renderer_item_flags (vlc_renderer_item_t*),misc\renderer_discovery.c,"int
vlc_renderer_item_flags(const vlc_renderer_item_t *p_item)
{
    assert(p_item != NULL);

    return p_item->i_flags;
}",149.0,155.0,1.0,1.0,7.0,2,2,3,2,0,1,1,1,0,0,,0,1,2,1,1,int
2878,125110,vlc_renderer_item_hold,1,vlc_renderer_item_hold,vlc_renderer_item_t vlc_renderer_item_hold (vlc_renderer_item_t*),misc\renderer_discovery.c,"vlc_renderer_item_t *
vlc_renderer_item_hold(vlc_renderer_item_t *p_item)
{
    assert(p_item != NULL);

    atomic_fetch_add(&p_item->refs, 1);
    return p_item;
}",157.0,164.0,1.0,1.0,8.0,3,3,4,2,3,1,1,1,0,0,,0,1,2,1,1,vlc_renderer_item_t
2879,125127,vlc_renderer_item_release,1,vlc_renderer_item_release,void vlc_renderer_item_release (vlc_renderer_item_t*),misc\renderer_discovery.c,"void
vlc_renderer_item_release(vlc_renderer_item_t *p_item)
{
    assert(p_item != NULL);

    int refs = atomic_fetch_sub(&p_item->refs, 1);
    assert(refs != 0 );
    if( refs != 1 )
        return;
    item_free(p_item);
}",166.0,176.0,1.0,1.0,11.0,6,4,7,3,4,2,2,2,0,1,,0,1,2,1,1,void
2880,125160,vlc_rd_probe_add,1,vlc_rd_probe_add,"int vlc_rd_probe_add (vlc_probe_t*,char*,char*)",misc\renderer_discovery.c,"int
vlc_rd_probe_add(vlc_probe_t *probe, const char *psz_name,
                 const char *psz_longname)
{
    struct vlc_rd_probe names = { strdup(psz_name), strdup(psz_longname) };

    if (unlikely(names.psz_name == NULL || names.psz_longname == NULL
                 || vlc_probe_add(probe, &names, sizeof(names))))
    {
        free(names.psz_name);
        free(names.psz_longname);
        return VLC_ENOMEM;
    }
    return VLC_PROBE_CONTINUE;
}",184.0,198.0,1.0,1.0,15.0,12,7,14,7,0,4,2,2,2,0,,0,4,6,3,3,int
2881,125208,vlc_rd_get_names,1,vlc_rd_get_names,"int vlc_rd_get_names (vlc_object_t*,char***,char***)",misc\renderer_discovery.c,"int
vlc_rd_get_names(vlc_object_t *p_obj, char ***pppsz_names,
                 char ***pppsz_longnames)
{
    size_t i_count;
    struct vlc_rd_probe *p_tab = vlc_probe(p_obj, ""renderer probe"", &i_count);

    if (i_count == 0)
    {
        free(p_tab);
        return VLC_EGENERIC;
    }

    char **ppsz_names = vlc_alloc(i_count + 1, sizeof(char *));
    char **ppsz_longnames = vlc_alloc(i_count + 1, sizeof(char *));

    if (unlikely(ppsz_names == NULL || ppsz_longnames == NULL))
    {
        free(ppsz_names);
        free(ppsz_longnames);
        free(p_tab);
        return VLC_EGENERIC;
    }

    for (size_t i = 0; i < i_count; i++)
    {
        ppsz_names[i] = p_tab[i].psz_name;
        ppsz_longnames[i] = p_tab[i].psz_longname;
    }
    ppsz_names[i_count] = ppsz_longnames[i_count] = NULL;
    free(p_tab);
    *pppsz_names = ppsz_names;
    *pppsz_longnames = ppsz_longnames;
    return VLC_SUCCESS;
}",201.0,235.0,1.0,1.0,35.0,30,10,42,12,0,1,4,4,0,1,,0,1,6,3,3,int
2882,125320,vlc_rd_release,1,vlc_rd_release,void vlc_rd_release (vlc_renderer_discovery_t*),misc\renderer_discovery.c,"void vlc_rd_release(vlc_renderer_discovery_t *p_rd)
{
    module_unneed(p_rd, p_rd->p_module);
    config_ChainDestroy(p_rd->p_cfg);
    free(p_rd->psz_name);
    vlc_object_release(p_rd);
}",237.0,243.0,1.0,1.0,7.0,3,1,5,1,0,3,1,1,0,3,,0,0,2,1,1,void
2883,125340,vlc_rd_new,1,vlc_rd_new,"vlc_renderer_discovery_t vlc_rd_new (vlc_object_t*,char*,vlc_renderer_discovery_owner*)",misc\renderer_discovery.c,"vlc_renderer_discovery_t *
vlc_rd_new(vlc_object_t *p_obj, const char *psz_name,
           const struct vlc_renderer_discovery_owner *restrict owner)
{
    vlc_renderer_discovery_t *p_rd;

    p_rd = vlc_custom_create(p_obj, sizeof(*p_rd), ""renderer discovery"");
    if(!p_rd)
        return NULL;
    free(config_ChainCreate(&p_rd->psz_name, &p_rd->p_cfg, psz_name));

    p_rd->owner = *owner;
    p_rd->p_module = module_need(p_rd, ""renderer_discovery"",
                                 p_rd->psz_name, true);
    if (p_rd->p_module == NULL)
    {
        msg_Err(p_rd, ""no suitable renderer discovery module for '%s'"",
            psz_name);
        free(p_rd->psz_name);
        config_ChainDestroy(p_rd->p_cfg);
        vlc_object_release(p_rd);
        p_rd = NULL;
    }

    return p_rd;
}",245.0,270.0,1.0,1.0,26.0,19,7,24,6,0,5,3,3,0,5,,0,2,6,3,3,vlc_renderer_discovery_t
2884,125438,subpicture_New,1,subpicture_New,subpicture_t subpicture_New (subpicture_updater_t*),misc\subpicture.c,"subpicture_t *subpicture_New( const subpicture_updater_t *p_upd )
{
    subpicture_t *p_subpic = calloc( 1, sizeof(*p_subpic) );
    if( !p_subpic )
        return NULL;

    p_subpic->i_order    = 0;
    p_subpic->b_absolute = true;
    p_subpic->b_fade     = false;
    p_subpic->b_subtitle = false;
    p_subpic->i_alpha    = 0xFF;
    p_subpic->p_region   = NULL;

    if( p_upd )
    {
        subpicture_private_t *p_private = malloc( sizeof(*p_private) );
        if( !p_private )
        {
            free( p_subpic );
            return NULL;
        }
        video_format_Init( &p_private->src, 0 );
        video_format_Init( &p_private->dst, 0 );

        p_subpic->updater   = *p_upd;
        p_subpic->p_private = p_private;
    }
    else
    {
        p_subpic->p_private = NULL;

        p_subpic->updater.pf_validate = NULL;
        p_subpic->updater.pf_update   = NULL;
        p_subpic->updater.pf_destroy  = NULL;
        p_subpic->updater.p_sys       = NULL;
    }
    retu...",44.0,81.0,1.0,1.0,38.0,29,6,27,6,7,2,4,5,0,0,,0,2,2,1,1,subpicture_t
2885,125565,subpicture_Delete,1,subpicture_Delete,void subpicture_Delete (subpicture_t*),misc\subpicture.c,"void subpicture_Delete( subpicture_t *p_subpic )
{
    subpicture_region_ChainDelete( p_subpic->p_region );
    p_subpic->p_region = NULL;

    if( p_subpic->updater.pf_destroy )
        p_subpic->updater.pf_destroy( p_subpic );

    if( p_subpic->p_private )
    {
        video_format_Clean( &p_subpic->p_private->src );
        video_format_Clean( &p_subpic->p_private->dst );
    }

    free( p_subpic->p_private );
    free( p_subpic );
}",83.0,99.0,1.0,1.0,17.0,15,4,11,2,10,1,3,3,0,1,,0,0,2,1,1,void
2886,125618,subpicture_NewFromPicture,1,subpicture_NewFromPicture,"subpicture_t subpicture_NewFromPicture (vlc_object_t*,picture_t*,vlc_fourcc_t)",misc\subpicture.c,"subpicture_t *subpicture_NewFromPicture( vlc_object_t *p_obj,
                                         picture_t *p_picture, vlc_fourcc_t i_chroma )
{
    /* */
    video_format_t fmt_in = p_picture->format;

    /* */
    video_format_t fmt_out;
    fmt_out = fmt_in;
    fmt_out.i_chroma = i_chroma;

    /* */
    image_handler_t *p_image = image_HandlerCreate( p_obj );
    if( !p_image )
        return NULL;

    picture_t *p_pip = image_Convert( p_image, p_picture, &fmt_in, &fmt_out );

    image_HandlerDelete( p_image );

    if( !p_pip )
        return NULL;

    subpicture_t *p_subpic = subpicture_New( NULL );
    if( !p_subpic )
    {
         picture_Release( p_pip );
         return NULL;
    }

    p_subpic->i_original_picture_width  = fmt_out.i_visible_width;
    p_subpic->i_original_picture_height = fmt_out.i_visible_height;

    fmt_out.i_sar_num =
    fmt_out.i_sar_den = 0;

    p_subpic->p_region = subpicture_region_New( &fmt_out );
    if( p_subpic->p_region )
    {
...",101.0,148.0,1.0,1.0,48.0,32,5,36,9,1,6,5,5,0,6,,0,3,6,3,3,subpicture_t
2887,125736,subpicture_Update,1,subpicture_Update,"void subpicture_Update (subpicture_t*,video_format_t*,video_format_t*,mtime_t)",misc\subpicture.c,"void subpicture_Update( subpicture_t *p_subpicture,
                        const video_format_t *p_fmt_src,
                        const video_format_t *p_fmt_dst,
                        mtime_t i_ts )
{
    subpicture_updater_t *p_upd = &p_subpicture->updater;
    subpicture_private_t *p_private = p_subpicture->p_private;

    if( !p_upd->pf_validate )
        return;
    if( !p_upd->pf_validate( p_subpicture,
                          !video_format_IsSimilar( p_fmt_src,
                                                   &p_private->src ), p_fmt_src,
                          !video_format_IsSimilar( p_fmt_dst,
                                                   &p_private->dst ), p_fmt_dst,
                          i_ts ) )
        return;

    subpicture_region_ChainDelete( p_subpicture->p_region );
    p_subpicture->p_region = NULL;

    p_upd->pf_update( p_subpicture, p_fmt_src, p_fmt_dst, i_ts );

    video_format_Clean( &p_private->src );
    video_format_Clean( &p_private...",150.0,178.0,1.0,1.0,29.0,27,4,28,7,1,9,3,3,4,3,,0,8,8,4,4,void
2888,125829,subpicture_region_private_New,1,subpicture_region_private_New,subpicture_region_private_t subpicture_region_private_New (video_format_t*),misc\subpicture.c,"subpicture_region_private_t *subpicture_region_private_New( video_format_t *p_fmt )
{
    subpicture_region_private_t *p_private = malloc( sizeof(*p_private) );

    if( !p_private )
        return NULL;

    if ( video_format_Copy( &p_private->fmt, p_fmt ) != VLC_SUCCESS )
    {
        free( p_private );
        return NULL;
    }

    p_private->p_picture = NULL;
    return p_private;
}",181.0,196.0,1.0,1.0,16.0,9,7,12,4,1,2,3,3,1,0,,0,2,2,1,1,subpicture_region_private_t
2889,125868,subpicture_region_private_Delete,1,subpicture_region_private_Delete,void subpicture_region_private_Delete (subpicture_region_private_t*),misc\subpicture.c,"void subpicture_region_private_Delete( subpicture_region_private_t *p_private )
{
    if( p_private->p_picture )
        picture_Release( p_private->p_picture );
    video_format_Clean( &p_private->fmt );
    free( p_private );
}",198.0,204.0,1.0,1.0,7.0,4,2,4,1,4,4,2,2,1,1,,0,3,2,1,1,void
2890,125889,subpicture_region_New,1,subpicture_region_New,subpicture_region_t subpicture_region_New (video_format_t*),misc\subpicture.c,"subpicture_region_t *subpicture_region_New( const video_format_t *p_fmt )
{
    subpicture_region_t *p_region = calloc( 1, sizeof(*p_region ) );
    if( !p_region )
        return NULL;

    if ( p_fmt->i_chroma == VLC_CODEC_YUVP )
    {
        video_format_Copy( &p_region->fmt, p_fmt );
        /* YUVP should have a palette */
        if( p_region->fmt.p_palette == NULL )
        {
            p_region->fmt.p_palette = calloc( 1, sizeof(*p_region->fmt.p_palette) );
            if( p_region->fmt.p_palette == NULL )
            {
                free( p_region );
                return NULL;
            }
        }
    }
    else
    {
        p_region->fmt = *p_fmt;
        p_region->fmt.p_palette = NULL;
    }

    p_region->i_alpha = 0xff;
    p_region->b_balanced_text = true;

    if( p_fmt->i_chroma == VLC_CODEC_TEXT )
        return p_region;

    p_region->p_picture = picture_NewFromFormat( p_fmt );
    if( !p_region->p_picture )
    {
        video_format_Clean( &p_region->f...",206.0,247.0,1.0,1.0,42.0,33,8,29,6,9,1,7,10,0,1,,0,1,2,1,1,subpicture_region_t
2891,126015,subpicture_region_Delete,1,subpicture_region_Delete,void subpicture_region_Delete (subpicture_region_t*),misc\subpicture.c,"void subpicture_region_Delete( subpicture_region_t *p_region )
{
    if( !p_region )
        return;

    if( p_region->p_private )
        subpicture_region_private_Delete( p_region->p_private );

    if( p_region->p_picture )
        picture_Release( p_region->p_picture );

    text_segment_ChainDelete( p_region->p_text );
    video_format_Clean( &p_region->fmt );
    free( p_region );
}",249.0,263.0,1.0,1.0,15.0,8,3,8,1,1,3,4,4,0,3,,0,0,2,1,1,void
2892,126054,subpicture_region_ChainDelete,1,subpicture_region_ChainDelete,void subpicture_region_ChainDelete (subpicture_region_t*),misc\subpicture.c,"void subpicture_region_ChainDelete( subpicture_region_t *p_head )
{
    while( p_head )
    {
        subpicture_region_t *p_next = p_head->p_next;

        subpicture_region_Delete( p_head );

        p_head = p_next;
    }
}",265.0,275.0,1.0,1.0,11.0,3,2,6,2,2,1,2,2,0,1,,0,0,2,1,1,void
2893,126073,picture_BlendSubpicture,1,picture_BlendSubpicture,"unsigned picture_BlendSubpicture (picture_t*,filter_t*,subpicture_t*)",misc\subpicture.c,"unsigned picture_BlendSubpicture(picture_t *dst,
                                 filter_t *blend, subpicture_t *src)
{
    unsigned done = 0;

    assert(src && !src->b_fade && src->b_absolute);

    for (subpicture_region_t *r = src->p_region; r != NULL; r = r->p_next) {
        assert(r->p_picture && r->i_align == 0);
        if (filter_ConfigureBlend(blend, dst->format.i_width,
                                  dst->format.i_height,  &r->fmt)
         || filter_Blend(blend, dst, r->i_x, r->i_y, r->p_picture,
                         src->i_alpha * r->i_alpha / 255))
            msg_Err(blend, ""blending %4.4s to %4.4s failed"",
                    (char *)&blend->fmt_in.video.i_chroma,
                    (char *)&blend->fmt_out.video.i_chroma );
        else
            done++;
    }
    return done;
}",279.0,299.0,1.0,1.0,21.0,37,12,25,6,2,2,3,4,2,2,,0,2,6,3,3,unsigned
2894,126191,subpicture_region_Copy,1,subpicture_region_Copy,subpicture_region_t subpicture_region_Copy (subpicture_region_t*),misc\subpicture.c,"subpicture_region_t* subpicture_region_Copy( subpicture_region_t *p_region_src )
{
    if (!p_region_src)
        return NULL;
    subpicture_region_t *p_region_dst = subpicture_region_New(&p_region_src->fmt);
    if (unlikely(!p_region_dst))
        return NULL;

    p_region_dst->i_x      = p_region_src->i_x;
    p_region_dst->i_y      = p_region_src->i_y;
    p_region_dst->i_align  = p_region_src->i_align;
    p_region_dst->i_alpha  = p_region_src->i_alpha;

    p_region_dst->p_text = text_segment_Copy( p_region_src->p_text );

    //Palette is already copied by subpicture_region_New, we just have to duplicate p_pixels
    for (int i = 0; i < p_region_src->p_picture->i_planes; i++)
        memcpy(p_region_dst->p_picture->p[i].p_pixels,
               p_region_src->p_picture->p[i].p_pixels,
               p_region_src->p_picture->p[i].i_lines * p_region_src->p_picture->p[i].i_pitch);
    return p_region_dst;
}",301.0,322.0,1.0,1.0,22.0,24,5,20,4,0,2,4,4,0,2,,0,2,2,1,1,subpicture_region_t
2895,126339,text_style_New,1,text_style_New,text_style_t text_style_New (void),misc\text_style.c,"text_style_t *text_style_New( void )
{
    return text_style_Create( STYLE_FULLY_SET );
}",34.0,37.0,1.0,1.0,4.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,text_style_t
2896,126347,text_style_Create,1,text_style_Create,text_style_t text_style_Create (int),misc\text_style.c,"text_style_t *text_style_Create( int i_defaults )
{
    text_style_t *p_style = calloc( 1, sizeof(*p_style) );
    if( !p_style )
        return NULL;

    if( i_defaults == STYLE_NO_DEFAULTS )
        return p_style;

    /* initialize to default text style (FIXME: by flag) */
    p_style->psz_fontname = NULL;
    p_style->psz_monofontname = NULL;
    p_style->i_features = STYLE_FULLY_SET;
    p_style->i_style_flags = STYLE_OUTLINE;
    p_style->f_font_relsize = STYLE_DEFAULT_REL_FONT_SIZE;
    p_style->i_font_size = STYLE_DEFAULT_FONT_SIZE;
    p_style->i_font_color = 0xffffff;
    p_style->i_font_alpha = STYLE_ALPHA_OPAQUE;
    p_style->i_outline_color = 0x000000;
    p_style->i_outline_alpha = STYLE_ALPHA_OPAQUE;
    p_style->i_shadow_color = 0x808080;
    p_style->i_shadow_alpha = STYLE_ALPHA_OPAQUE;
    p_style->i_background_color = 0x000000;
    p_style->i_background_alpha = STYLE_ALPHA_OPAQUE;
    p_style->i_karaoke_background_color = 0xffffff;
    p_style->i_karaoke_backgro...",39.0,71.0,1.0,1.0,33.0,46,7,40,10,2,0,3,3,0,0,,0,0,2,1,1,text_style_t
2897,126476,text_style_Copy,1,text_style_Copy,"text_style_t text_style_Copy (text_style_t*,text_style_t*)",misc\text_style.c,"text_style_t *text_style_Copy( text_style_t *p_dst, const text_style_t *p_src )
{
    if( !p_src )
        return p_dst;

    /* */
    *p_dst = *p_src;

    if( p_src->psz_fontname )
        p_dst->psz_fontname = strdup( p_src->psz_fontname );

    if( p_src->psz_monofontname )
        p_dst->psz_monofontname = strdup( p_src->psz_monofontname );

    return p_dst;
}",73.0,88.0,1.0,1.0,16.0,12,4,11,2,1,0,4,4,0,0,,0,0,4,2,2,text_style_t
2898,126521,text_style_Merge,1,text_style_Merge,"void text_style_Merge (text_style_t*,text_style_t*,bool)",misc\text_style.c,"void text_style_Merge( text_style_t *p_dst, const text_style_t *p_src, bool b_override )
{
    if( p_src->psz_fontname && (!p_dst->psz_fontname || b_override) )
    {
        free( p_dst->psz_fontname );
        p_dst->psz_fontname = strdup( p_src->psz_fontname );
    }

    if( p_src->psz_monofontname && (!p_dst->psz_monofontname || b_override) )
    {
        free( p_dst->psz_monofontname );
        p_dst->psz_monofontname = strdup( p_src->psz_monofontname );
    }

    if( p_src->i_features != STYLE_NO_DEFAULTS )
    {
        MERGE(i_font_color,         STYLE_HAS_FONT_COLOR);
        MERGE(i_font_alpha,         STYLE_HAS_FONT_ALPHA);
        MERGE(i_outline_color,      STYLE_HAS_OUTLINE_COLOR);
        MERGE(i_outline_alpha,      STYLE_HAS_OUTLINE_ALPHA);
        MERGE(i_shadow_color,       STYLE_HAS_SHADOW_COLOR);
        MERGE(i_shadow_alpha,       STYLE_HAS_SHADOW_ALPHA);
        MERGE(i_background_color,   STYLE_HAS_BACKGROUND_COLOR);
        MERGE(i_background_alpha,   STYL...",98.0,134.0,1.0,8.0,37.0,179,9,131,15,0,0,4,4,0,0,,0,0,6,3,3,void
2899,127003,text_style_Duplicate,1,text_style_Duplicate,text_style_t text_style_Duplicate (text_style_t*),misc\text_style.c,"text_style_t *text_style_Duplicate( const text_style_t *p_src )
{
    if( !p_src )
        return NULL;

    text_style_t *p_dst = calloc( 1, sizeof(*p_dst) );
    if( p_dst )
        text_style_Copy( p_dst, p_src );
    return p_dst;
}",139.0,148.0,1.0,1.0,10.0,4,4,8,3,3,1,3,3,0,1,,0,0,2,1,1,text_style_t
2900,127030,text_style_Delete,1,text_style_Delete,void text_style_Delete (text_style_t*),misc\text_style.c,"void text_style_Delete( text_style_t *p_style )
{
    if( p_style )
        free( p_style->psz_fontname );
    if( p_style )
        free( p_style->psz_monofontname );
    free( p_style );
}",150.0,157.0,1.0,1.0,8.0,2,1,5,1,2,0,3,3,0,0,,0,0,2,1,1,void
2901,127051,text_segment_New,1,text_segment_New,text_segment_t text_segment_New (char*),misc\text_style.c,"text_segment_t *text_segment_New( const char *psz_text )
{
    text_segment_t* segment = calloc( 1, sizeof(*segment) );
    if( !segment )
        return NULL;

    if ( psz_text )
        segment->psz_text = strdup( psz_text );

    return segment;
}",159.0,169.0,1.0,1.0,11.0,6,5,8,3,4,0,3,3,0,0,,0,0,2,1,1,text_segment_t
2902,127081,text_segment_NewInheritStyle,1,text_segment_NewInheritStyle,text_segment_t text_segment_NewInheritStyle (text_style_t*),misc\text_style.c,"text_segment_t *text_segment_NewInheritStyle( const text_style_t* p_style )
{
    if ( !p_style )
        return NULL; //FIXME: Allow this, even if it is an alias to text_segment_New( NULL ) ?
    text_segment_t* p_segment = text_segment_New( NULL );
    if ( unlikely( !p_segment ) )
        return NULL;
    p_segment->style = text_style_Duplicate( p_style );
    if ( unlikely( !p_segment->style ) )
    {
        text_segment_Delete( p_segment );
        return NULL;
    }
    return p_segment;
}",171.0,185.0,1.0,1.0,15.0,7,3,12,3,0,3,4,4,0,3,,0,2,2,1,1,text_segment_t
2903,127123,text_segment_Delete,1,text_segment_Delete,void text_segment_Delete (text_segment_t*),misc\text_style.c,"void text_segment_Delete( text_segment_t* segment )
{
    if ( segment != NULL )
    {
        free( segment->psz_text );
        text_style_Delete( segment->style );
        free( segment );
    }
}",187.0,195.0,1.0,1.0,9.0,3,2,5,2,3,1,2,2,0,1,,0,0,2,1,1,void
2904,127143,text_segment_ChainDelete,1,text_segment_ChainDelete,void text_segment_ChainDelete (text_segment_t*),misc\text_style.c,"void text_segment_ChainDelete( text_segment_t *segment )
{
    while( segment != NULL )
    {
        text_segment_t *p_next = segment->p_next;

        text_segment_Delete( segment );

        segment = p_next;
    }
}",197.0,207.0,1.0,1.0,11.0,4,3,7,3,1,1,2,2,0,1,,0,0,2,1,1,void
2905,127164,text_segment_Copy,1,text_segment_Copy,text_segment_t text_segment_Copy (text_segment_t*),misc\text_style.c,"text_segment_t *text_segment_Copy( text_segment_t *p_src )
{
    text_segment_t *p_dst = NULL, *p_dst0 = NULL;

    while( p_src ) {
        text_segment_t *p_new = text_segment_New( p_src->psz_text );

        if( unlikely( !p_new ) )
            break;

        p_new->style = text_style_Duplicate( p_src->style );

        if( p_dst == NULL )
        {
            p_dst = p_dst0 = p_new;
        }
        else
        {
            p_dst->p_next = p_new;
            p_dst = p_dst->p_next;
        }

        p_src = p_src->p_next;
    }

    return p_dst0;
}",209.0,235.0,1.0,1.0,27.0,13,4,18,5,1,2,5,6,0,2,,0,2,2,1,1,text_segment_t
2906,127230,vlc_html_color,1,vlc_html_color,"unsigned int vlc_html_color (char*,bool*)",misc\text_style.c,"unsigned int vlc_html_color( const char *psz_value, bool* ok )
{
    unsigned int color = 0;
    char* psz_end;
    bool b_ret = false;

    const char *psz_hex = (*psz_value == '#') ? psz_value + 1 : psz_value;

    if( psz_hex != psz_value ||
        (*psz_hex >= '0' && *psz_hex <= '9') ||
        (*psz_hex >= 'A' && *psz_hex <= 'F') )
    {
        uint32_t i_value = strtol( psz_hex, &psz_end, 16 );
        if( *psz_end == 0 || isspace( *psz_end ) )
        {
            switch( psz_end - psz_hex )
            {
                case 8:
                    color = (i_value << 24) | (i_value >> 8);
                    b_ret = true;
                    break;
                case 6:
                    color = i_value | 0xFF000000;
                    b_ret = true;
                    break;
                default:
                    break;
            }
        }
    }

    if( !b_ret && psz_hex == psz_value &&
        !strncmp( ""rgb"", psz_value, 3 ) )
    {
        unsigned r,g,...",237.0,297.0,1.0,1.0,61.0,74,18,66,16,0,0,14,17,0,0,,0,0,4,2,2,unsigned int
2907,127489,vlc_global_mutex,1,vlc_global_mutex,"void vlc_global_mutex (unsigned,bool)",misc\threads.c,"void vlc_global_mutex (unsigned n, bool acquire)
{
    static vlc_mutex_t locks[] = {
        VLC_STATIC_MUTEX,
        VLC_STATIC_MUTEX,
        VLC_STATIC_MUTEX,
        VLC_STATIC_MUTEX,
        VLC_STATIC_MUTEX,
#ifdef _WIN32
        VLC_STATIC_MUTEX, // For MTA holder
#endif
    };
    static_assert (VLC_MAX_MUTEX == (sizeof (locks) / sizeof (locks[0])),
                   ""Wrong number of global mutexes"");
    assert (n < (sizeof (locks) / sizeof (locks[0])));

    vlc_mutex_t *lock = locks + n;
    if (acquire)
        vlc_mutex_lock (lock);
    else
        vlc_mutex_unlock (lock);
}",32.0,53.0,1.0,1.0,22.0,14,8,17,6,0,1,2,2,0,1,,0,0,4,2,2,void
2908,127575,update_New,1,update_New,update_t update_New (vlc_object_t*),misc\update.c,"update_t *update_New( vlc_object_t *p_this )
{
    update_t *p_update;
    assert( p_this );

    p_update = (update_t *)malloc( sizeof( update_t ) );
    if( !p_update ) return NULL;

    vlc_mutex_init( &p_update->lock );

    p_update->p_libvlc = p_this->obj.libvlc;

    p_update->release.psz_url = NULL;
    p_update->release.psz_desc = NULL;

    p_update->p_download = NULL;
    p_update->p_check = NULL;

    p_update->p_pkey = NULL;
    vlc_gcrypt_init();

    return p_update;
}",104.0,126.0,1.0,1.0,23.0,22,7,19,4,0,8,2,2,0,1,,0,7,2,1,1,update_t
2909,127642,update_Delete,1,update_Delete,void update_Delete (update_t*),missing.c,"void update_Delete(update_t *u)
{
    (void) u;
    vlc_assert_unreachable();
}",260.0,264.0,1.0,1.0,5.0,18,3,16,3,0,15,3,3,2,4,,0,11,2,1,1,void
2910,127712,EmptyRelease,1,EmptyRelease,void EmptyRelease (update_t*),misc\update.c,"static void EmptyRelease( update_t *p_update )
{
    p_update->release.i_major = 0;
    p_update->release.i_minor = 0;
    p_update->release.i_revision = 0;

    FREENULL( p_update->release.psz_url );
    FREENULL( p_update->release.psz_desc );
}",166.0,174.0,1.0,1.0,9.0,13,3,5,1,0,5,1,1,0,0,,0,5,2,1,1,void
2911,127750,GetUpdateFile,1,GetUpdateFile,bool GetUpdateFile (update_t*),misc\update.c,"static bool GetUpdateFile( update_t *p_update )
{
    stream_t *p_stream = NULL;
    char *psz_version_line = NULL;
    char *psz_update_data = NULL;

    p_stream = vlc_stream_NewURL( p_update->p_libvlc, UPDATE_VLC_STATUS_URL );
    if( !p_stream )
    {
        msg_Err( p_update->p_libvlc, ""Failed to open %s for reading"",
                 UPDATE_VLC_STATUS_URL );
        goto error;
    }

    uint64_t i_read;
    if( vlc_stream_GetSize( p_stream, &i_read ) || i_read >= UINT16_MAX )
    {
        msg_Err(p_update->p_libvlc, ""Status file too large"");
        goto error;
    }

    psz_update_data = malloc( i_read + 1 ); /* terminating '\0' */
    if( !psz_update_data )
        goto error;

    if( vlc_stream_Read( p_stream, psz_update_data,
                         i_read ) != (ssize_t)i_read )
    {
        msg_Err( p_update->p_libvlc, ""Couldn't download update file %s"",
                UPDATE_VLC_STATUS_URL );
        goto error;
    }
    psz_update_data[i_read] = '\0';

    vlc...",183.0,382.0,1.0,54.0,200.0,139,16,135,20,0,53,40,26,15,9,,0,51,2,1,1,bool
2912,128349,update_CheckReal,1,update_CheckReal,void* update_CheckReal (void*),misc\update.c,"void* update_CheckReal( void *obj )
{
    update_check_thread_t *p_uct = (update_check_thread_t *)obj;
    bool b_ret;
    int canc;

    canc = vlc_savecancel ();
    vlc_mutex_lock( &p_uct->p_update->lock );

    EmptyRelease( p_uct->p_update );
    b_ret = GetUpdateFile( p_uct->p_update );
    vlc_mutex_unlock( &p_uct->p_update->lock );

    if( p_uct->pf_callback )
        (p_uct->pf_callback)( p_uct->p_data, b_ret );

    vlc_restorecancel (canc);
    return NULL;
}",416.0,434.0,1.0,1.0,19.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void*
2913,128354,update_Check,1,update_Check,"void update_Check (update_t*,void,void*)",missing.c,"void update_Check(update_t *u, void (*cb)(void *, bool), void *opaque)
{
    (void) u; (void) cb; (void) opaque;
    vlc_assert_unreachable();
}",266.0,270.0,1.0,1.0,5.0,18,6,20,7,0,9,3,3,1,2,,0,7,6,3,3,void
2914,128477,update_NeedUpgrade,1,update_NeedUpgrade,bool update_NeedUpgrade (update_t*),missing.c,"bool update_NeedUpgrade(update_t *u)
{
    (void) u;
    vlc_assert_unreachable();
}",272.0,276.0,1.0,1.0,5.0,25,10,28,11,0,4,5,7,0,0,,0,4,2,1,1,bool
2915,128563,size_str,1,size_str,char* size_str (uint64_t),misc\update.c,"static char *size_str( uint64_t l_size )
{
    char *psz_tmp = NULL;
    int i_retval = 0;
    if( l_size >> 30 )
        i_retval = asprintf( &psz_tmp, _(""%.1f GiB""), (float)l_size/(1<<30) );
    else if( l_size >> 20 )
        i_retval = asprintf( &psz_tmp, _(""%.1f MiB""), (float)l_size/(1<<20) );
    else if( l_size >> 10 )
        i_retval = asprintf( &psz_tmp, _(""%.1f KiB""), (float)l_size/(1<<10) );
    else
        i_retval = asprintf( &psz_tmp, _(""%""PRIu64"" B""), l_size );

    return i_retval == -1 ? NULL : psz_tmp;
}",477.0,491.0,1.0,1.0,15.0,5,4,6,3,0,0,1,1,0,0,,0,0,2,1,1,char*
2916,128585,update_DownloadReal,1,update_DownloadReal,void* update_DownloadReal (void*),misc\update.c,"static void* update_DownloadReal( void *obj )
{
    update_download_thread_t *p_udt = (update_download_thread_t *)obj;
    uint64_t l_size;
    uint64_t l_downloaded = 0;
    float f_progress;
    char *psz_downloaded = NULL;
    char *psz_size = NULL;
    char *psz_destfile = NULL;
    char *psz_tmpdestfile = NULL;

    FILE *p_file = NULL;
    stream_t *p_stream = NULL;
    void* p_buffer = NULL;
    int i_read;
    int canc;

    vlc_dialog_id *p_dialog_id = NULL;
    update_t *p_update = p_udt->p_update;
    char *psz_destdir = p_udt->psz_destdir;

    msg_Dbg( p_udt, ""Opening Stream '%s'"", p_update->release.psz_url );
    canc = vlc_savecancel ();

    /* Open the stream */
    p_stream = vlc_stream_NewURL( p_udt, p_update->release.psz_url );
    if( !p_stream )
    {
        msg_Err( p_udt, ""Failed to open %s for reading"", p_update->release.psz_url );
        goto end;
    }

    /* Get the stream size */
    if( vlc_stream_GetSize( p_stream, &l_size ) || l_size == 0 )
       ...",528.0,754.0,1.0,8.0,227.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void*
2917,128590,update_Download,1,update_Download,"void update_Download (update_t*,char*)",missing.c,"void update_Download(update_t *u, const char *dir)
{
    (void) u; (void) dir;
    vlc_assert_unreachable();
}",278.0,282.0,1.0,1.0,5.0,24,7,26,8,0,15,3,3,1,4,,0,12,4,2,2,void
2918,129249,update_GetRelease,1,update_GetRelease,update_release_t update_GetRelease (update_t*),missing.c,"update_release_t *update_GetRelease(update_t *u)
{
    (void) u;
    vlc_assert_unreachable();
}",284.0,288.0,1.0,1.0,5.0,2,2,1,1,0,1,1,1,0,0,,0,1,2,1,1,update_release_t
2919,129493,pf_callback,1,update_check_thread_t.pf_callback,"void update_check_thread_t.pf_callback (void*,ANY)",misc\update.h,"void (*pf_callback)( void *, bool );",150.0,150.0,10.0,39.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
2920,129509,download_key,1,download_key,"public_key_t* download_key (vlc_object_t*,uint8_t*,uint8_t*)",misc\update_crypto.c,"public_key_t *download_key( vlc_object_t *p_this,
                    const uint8_t *p_longid, const uint8_t *p_signature_issuer )
{
    char *psz_url;
    if( asprintf( &psz_url, ""http://download.videolan.org/pub/keys/%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X.asc"",
                    p_longid[0], p_longid[1], p_longid[2], p_longid[3],
                    p_longid[4], p_longid[5], p_longid[6], p_longid[7] ) == -1 )
        return NULL;

    stream_t *p_stream = vlc_stream_NewURL( p_this, psz_url );
    free( psz_url );
    if( !p_stream )
        return NULL;

    uint64_t i_size;
    if( vlc_stream_GetSize( p_stream, &i_size ) || i_size > INT_MAX )
    {
        vlc_stream_Delete( p_stream );
        return NULL;
    }

    uint8_t *p_buf = (uint8_t*)malloc( i_size );
    if( !p_buf )
    {
        vlc_stream_Delete( p_stream );
        return NULL;
    }

    int i_read = vlc_stream_Read( p_stream, p_buf, (int)i_size );
    vlc_stream_Delete( p_stream );

    if( i_read != (int)i_size )
 ...",932.0,990.0,1.0,1.0,59.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,public_key_t
2921,129516,parse_public_key,1,parse_public_key,"int parse_public_key (uint8_t*,size_t,public_key_t*,uint8_t*)",misc\update_crypto.c,"int parse_public_key( const uint8_t *p_key_data, size_t i_key_len,
                      public_key_t *p_key, const uint8_t *p_sig_issuer )
{
    const uint8_t *pos = p_key_data;
    const uint8_t *max_pos = pos + i_key_len;

    int i_status = 0;
#define PUBLIC_KEY_FOUND    0x01
#define USER_ID_FOUND       0x02
#define SIGNATURE_FOUND     0X04

    uint8_t *p_key_unarmored = NULL;

    p_key->psz_username = NULL;
    p_key->sig.specific.v4.hashed_data = NULL;
    p_key->sig.specific.v4.unhashed_data = NULL;

    if( !( *pos & 0x80 ) )
    {   /* first byte is ASCII, unarmoring */
        p_key_unarmored = (uint8_t*)malloc( i_key_len );
        if( !p_key_unarmored )
            return VLC_ENOMEM;
        int i_len = pgp_unarmor( (char*)p_key_data, i_key_len,
                                 p_key_unarmored, i_key_len );

        if( i_len == 0 )
            goto error;

        pos = p_key_unarmored;
        max_pos = pos + i_len;
    }

    while( pos < max_pos )
    {
        if(...",607.0,722.0,1.0,21.0,116.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,int
2922,129524,verify_signature,1,verify_signature,"int verify_signature (signature_packet_t*,public_key_packet_t*,uint8_t*)",misc\update_crypto.c,"int verify_signature( signature_packet_t *sign, public_key_packet_t *p_key,
                      uint8_t *p_hash )
{
    if (sign->public_key_algo == GCRY_PK_DSA)
        return verify_signature_dsa(sign, p_key, p_hash);
    else if (sign->public_key_algo == GCRY_PK_RSA)
        return verify_signature_rsa(sign, p_key, p_hash);
    else
        return VLC_EGENERIC;
}",589.0,598.0,1.0,1.0,10.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,int
2923,129531,download_signature,1,download_signature,"int download_signature (vlc_object_t*,signature_packet_t*,char*)",misc\update_crypto.c,"int download_signature( vlc_object_t *p_this, signature_packet_t *p_sig,
                        const char *psz_url )
{
    char *psz_sig = (char*) malloc( strlen( psz_url ) + 4 + 1 ); /* "".asc"" + \0 */
    if( !psz_sig )
        return VLC_ENOMEM;

    strcpy( psz_sig, psz_url );
    strcat( psz_sig, "".asc"" );

    stream_t *p_stream = vlc_stream_NewURL( p_this, psz_sig );
    free( psz_sig );

    if( !p_stream )
        return VLC_ENOMEM;

    uint64_t i_size;
    if( vlc_stream_GetSize( p_stream, &i_size ) || i_size > INT_MAX )
    {
        vlc_stream_Delete( p_stream );
        return VLC_EGENERIC;
    }

    msg_Dbg( p_this, ""Downloading signature (%""PRIu64"" bytes)"", i_size );
    uint8_t *p_buf = (uint8_t*)malloc( i_size );
    if( !p_buf )
    {
        vlc_stream_Delete( p_stream );
        return VLC_ENOMEM;
    }

    int i_read = vlc_stream_Read( p_stream, p_buf, (int)i_size );

    vlc_stream_Delete( p_stream );

    if( i_read != (int)i_size )
    {
        msg_Dbg( ...",997.0,1109.0,1.0,8.0,113.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,int
2924,129538,hash_from_text,1,hash_from_text,"uint8_t* hash_from_text (char*,signature_packet_t*)",misc\update_crypto.c,"uint8_t *hash_from_text( const char *psz_string,
        signature_packet_t *p_sig )
{
    gcry_md_hd_t hd;
    if( gcry_md_open( &hd, p_sig->digest_algo, 0 ) )
        return NULL;

    if( p_sig->type == TEXT_SIGNATURE )
    while( *psz_string )
    {
        size_t i_len = strcspn( psz_string, ""\r\n"" );

        if( i_len )
        {
            gcry_md_write( hd, psz_string, i_len );
            psz_string += i_len;
        }
        gcry_md_putc( hd, '\r' );
        gcry_md_putc( hd, '\n' );

        if( *psz_string == '\r' )
            psz_string++;
        if( *psz_string == '\n' )
            psz_string++;
    }
    else
        gcry_md_write( hd, psz_string, strlen( psz_string ) );

    return hash_finish( hd, p_sig );
}",792.0,821.0,1.0,1.0,30.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,uint8_t
2925,129544,hash_from_file,1,hash_from_file,"uint8_t* hash_from_file (char*,signature_packet_t*)",misc\update_crypto.c,"uint8_t *hash_from_file( const char *psz_file, signature_packet_t *p_sig )
{
    gcry_md_hd_t hd;
    if( gcry_md_open( &hd, p_sig->digest_algo, 0 ) )
        return NULL;

    if( hash_from_binary_file( psz_file, hd ) < 0 )
    {
        gcry_md_close( hd );
        return NULL;
    }

    return hash_finish( hd, p_sig );
}",827.0,840.0,1.0,1.0,14.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,uint8_t
2926,129550,hash_from_public_key,1,hash_from_public_key,uint8_t* hash_from_public_key (public_key_t*),misc\update_crypto.c,"uint8_t *hash_from_public_key( public_key_t *p_pkey )
{
    const uint8_t pk_algo = p_pkey->key.algo;
    size_t i_size;
    size_t i_p_len, i_g_len, i_q_len, i_y_len;
    size_t i_n_len, i_e_len;

    if( p_pkey->sig.version != 4 )
        return NULL;

    if( p_pkey->sig.type < GENERIC_KEY_SIGNATURE ||
        p_pkey->sig.type > POSITIVE_KEY_SIGNATURE )
        return NULL;

    if( p_pkey->psz_username == NULL )
        return NULL;

    gcry_error_t error = 0;
    gcry_md_hd_t hd;

    if (pk_algo == GCRY_PK_DSA) {
        i_p_len = mpi_len( p_pkey->key.sig.dsa.p );
        i_g_len = mpi_len( p_pkey->key.sig.dsa.g );
        i_q_len = mpi_len( p_pkey->key.sig.dsa.q );
        i_y_len = mpi_len( p_pkey->key.sig.dsa.y );

        i_size = 6 + 2*4 + i_p_len + i_g_len + i_q_len + i_y_len;
    } else if (pk_algo == GCRY_PK_RSA) {
        i_n_len = mpi_len( p_pkey->key.sig.rsa.n );
        i_e_len = mpi_len( p_pkey->key.sig.rsa.e );

        i_size = 6 + 2*2 + i_n_len + i_e_len;
    ...",847.0,926.0,1.0,1.0,80.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,uint8_t
2927,129578,scalar_number,1,scalar_number,"uint32_t scalar_number (uint8_t*,int)",misc\update_crypto.c,"static inline uint32_t scalar_number( const uint8_t *p, int header_len )
{
    assert( header_len == 1 || header_len == 2 || header_len == 4 );

    if( header_len == 1 )
        return( p[0] );
    else if( header_len == 2 )
        return( (p[0] << 8) + p[1] );
    else if( header_len == 4 )
        return( ((uint32_t)p[0] << 24) + (p[1] << 16) + (p[2] << 8) + p[3] );
    else
        abort();
}",57.0,69.0,1.0,1.0,13.0,7,3,5,2,4,0,2,2,0,0,,0,0,4,2,2,uint32_t
2928,129656,mpi_len,1,mpi_len,uint32_t mpi_len (uint8_t*),misc\update_crypto.c,"static uint32_t mpi_len(const uint8_t *mpi)
{
    return (scalar_number(mpi, 2) + 7) / 8;
}",73.0,76.0,1.0,1.0,4.0,2,2,1,1,10,1,1,1,0,1,,0,0,2,1,1,uint32_t
2929,129669,read_mpi,1,read_mpi,"size_t read_mpi (uint8_t*,uint8_t*,size_t,size_t)",misc\update_crypto.c,"static size_t read_mpi(uint8_t *dst, const uint8_t *buf, size_t buflen, size_t bits)
{
    if (buflen < 2)
        return 0;

    size_t n = mpi_len(buf);

    if (n * 8 > bits)
        return 0;

    n += 2;

    if (buflen < n)
        return 0;

    memcpy(dst, buf, n);
    return n;
}",78.0,95.0,1.0,1.0,18.0,6,5,12,5,6,1,4,4,0,1,,0,1,8,4,4,size_t
2930,129714,parse_public_key_packet,1,parse_public_key_packet,"int parse_public_key_packet (public_key_packet_t*,uint8_t*,size_t)",misc\update_crypto.c,"static int parse_public_key_packet( public_key_packet_t *p_key,
                                    const uint8_t *p_buf, size_t i_packet_len )
{
    if( i_packet_len < 6 )
        return VLC_EGENERIC;

    size_t i_read = 0;

    p_key->version   = *p_buf++; i_read++;
    if( p_key->version != 4 )
        return VLC_EGENERIC;

    /* XXX: warn when timestamp is > date ? */
    memcpy( p_key->timestamp, p_buf, 4 ); p_buf += 4; i_read += 4;

    p_key->algo      = *p_buf++; i_read++;
    if( p_key->algo == GCRY_PK_DSA ) {
        READ_MPI(p_key->sig.dsa.p, 3072);
        READ_MPI(p_key->sig.dsa.q, 256);
        READ_MPI(p_key->sig.dsa.g, 3072);
        READ_MPI(p_key->sig.dsa.y, 3072);
    } else if ( p_key->algo == GCRY_PK_RSA ) {
        READ_MPI(p_key->sig.rsa.n, 4096);
        READ_MPI(p_key->sig.rsa.e, 4096);
    } else
        return VLC_EGENERIC;

    if( i_read == i_packet_len )
        return VLC_SUCCESS;

    /* some extra data eh ? */

error:
    return VLC_EGENERIC;
}",108.0,142.0,1.0,8.0,35.0,64,11,65,12,0,17,5,5,2,4,,0,17,6,3,3,int
2931,130047,parse_signature_v3_packet,1,parse_signature_v3_packet,"size_t parse_signature_v3_packet (signature_packet_t*,uint8_t*,size_t)",misc\update_crypto.c,"static size_t parse_signature_v3_packet( signature_packet_t *p_sig,
                                      const uint8_t *p_buf, size_t i_sig_len )
{
    size_t i_read = 1; /* we already read the version byte */

    if( i_sig_len < 19 ) /* signature is at least 19 bytes + the 2 MPIs */
        return 0;

    p_sig->specific.v3.hashed_data_len = *p_buf++; i_read++;
    if( p_sig->specific.v3.hashed_data_len != 5 )
        return 0;

    p_sig->type = *p_buf++; i_read++;

    memcpy( p_sig->specific.v3.timestamp, p_buf, 4 );
    p_buf += 4; i_read += 4;

    memcpy( p_sig->issuer_longid, p_buf, 8 );
    p_buf += 8; i_read += 8;

    p_sig->public_key_algo = *p_buf++; i_read++;

    p_sig->digest_algo = *p_buf++; i_read++;

    p_sig->hash_verification[0] = *p_buf++; i_read++;
    p_sig->hash_verification[1] = *p_buf++; i_read++;

    assert( i_read == 19 );

    return i_read;
}",145.0,175.0,1.0,1.0,31.0,49,10,31,4,1,9,3,3,1,0,,0,9,6,3,3,size_t
2932,130174,parse_signature_v4_packet,1,parse_signature_v4_packet,"size_t parse_signature_v4_packet (signature_packet_t*,uint8_t*,size_t)",misc\update_crypto.c,"static size_t parse_signature_v4_packet( signature_packet_t *p_sig,
                                      const uint8_t *p_buf, size_t i_sig_len )
{
    size_t i_read = 1; /* we already read the version byte */

    if( i_sig_len < 10 ) /* signature is at least 10 bytes + the 2 MPIs */
        return 0;

    p_sig->type = *p_buf++; i_read++;

    p_sig->public_key_algo = *p_buf++; i_read++;
    if (p_sig->public_key_algo != GCRY_PK_DSA && p_sig->public_key_algo != GCRY_PK_RSA )
            return 0;

    p_sig->digest_algo = *p_buf++; i_read++;

    memcpy( p_sig->specific.v4.hashed_data_len, p_buf, 2 );
    p_buf += 2; i_read += 2;

    size_t i_hashed_data_len =
        scalar_number( p_sig->specific.v4.hashed_data_len, 2 );
    i_read += i_hashed_data_len;
    if( i_read + 4 > i_sig_len )
        return 0;

    p_sig->specific.v4.hashed_data = (uint8_t*) malloc( i_hashed_data_len );
    if( !p_sig->specific.v4.hashed_data )
        return 0;
    memcpy( p_sig->specific.v4.hashed_...",182.0,275.0,1.0,1.0,94.0,100,15,76,12,1,22,13,20,4,3,,0,22,6,3,3,size_t
2933,130536,parse_signature_packet,1,parse_signature_packet,"int parse_signature_packet (signature_packet_t*,uint8_t*,size_t)",misc\update_crypto.c,"static int parse_signature_packet( signature_packet_t *p_sig,
                                   const uint8_t *p_buf, size_t i_packet_len )
{
    if( !i_packet_len ) /* 1st sanity check, we need at least the version */
        return VLC_EGENERIC;

    p_sig->version = *p_buf++;

    size_t i_read;
    switch( p_sig->version )
    {
        case 3:
            i_read = parse_signature_v3_packet( p_sig, p_buf, i_packet_len );
            break;
        case 4:
            p_sig->specific.v4.hashed_data = NULL;
            p_sig->specific.v4.unhashed_data = NULL;
            i_read = parse_signature_v4_packet( p_sig, p_buf, i_packet_len );
            break;
        default:
            return VLC_EGENERIC;
    }

    if( i_read == 0 ) /* signature packet parsing has failed */
        goto error;

    if( p_sig->public_key_algo != GCRY_PK_DSA && p_sig->public_key_algo != GCRY_PK_RSA )
        goto error;

    switch( p_sig->type )
    {
        case BINARY_SIGNATURE:
        case TEX...",278.0,346.0,1.0,8.0,69.0,59,13,66,18,0,15,16,9,6,4,,0,15,6,3,3,int
2934,130826,crc_octets,1,crc_octets,"long crc_octets (uint8_t*,size_t)",misc\update_crypto.c,"static long crc_octets( uint8_t *octets, size_t len )
{
    long crc = CRC24_INIT;
    int i;
    while (len--)
    {
        crc ^= (*octets++) << 16;
        for (i = 0; i < 8; i++)
        {
            crc <<= 1;
            if (crc & 0x1000000)
                crc ^= CRC24_POLY;
        }
    }
    return crc & 0xFFFFFFL;
}",356.0,371.0,1.0,15.0,16.0,9,7,10,4,1,0,4,7,0,0,,0,0,4,2,2,long
2935,130878,pgp_unarmor,1,pgp_unarmor,"int pgp_unarmor (char*,size_t,uint8_t*,size_t)",misc\update_crypto.c,"static int pgp_unarmor( const char *p_ibuf, size_t i_ibuf_len,
                        uint8_t *p_obuf, size_t i_obuf_len )
{
    const char *p_ipos = p_ibuf;
    uint8_t *p_opos = p_obuf;
    int i_end = 0;
    int i_header_skipped = 0;

    while( !i_end && p_ipos < p_ibuf + i_ibuf_len && *p_ipos != '=' )
    {
        if( *p_ipos == '\r' || *p_ipos == '\n' )
        {
            p_ipos++;
            continue;
        }

        size_t i_line_len = strcspn( p_ipos, ""\r\n"" );
        if( i_line_len == 0 )
            continue;

        if( !i_header_skipped )
        {
            if( !strncmp( p_ipos, ""-----BEGIN PGP"", 14 ) )
                i_header_skipped = 1;

            p_ipos += i_line_len + 1;
            continue;
        }

        if( !strncmp( p_ipos, ""Version:"", 8 ) )
        {
            p_ipos += i_line_len + 1;
            continue;
        }

        if( p_ipos[i_line_len - 1] == '=' )
        {
            i_end = 1;
        }

        p_opos += vlc_b64_decode...",378.0,435.0,1.0,1.0,58.0,59,16,54,12,0,3,14,17,1,3,,0,2,8,4,4,int
2936,131070,rsa_pkcs1_encode_sig,1,rsa_pkcs1_encode_sig,"int rsa_pkcs1_encode_sig (gcry_mpi_t*,size_t,uint8_t*,int)",misc\update_crypto.c,"static int rsa_pkcs1_encode_sig(gcry_mpi_t *r_result, size_t size,
                                const uint8_t *hash, int algo)
{
    uint8_t asn[100];
    uint8_t frame[4096/8];

    size_t asnlen = sizeof(asn);
    size_t hashlen = gcry_md_get_algo_dlen(algo);

    if (gcry_md_algo_info(algo, GCRYCTL_GET_ASNOID, asn, &asnlen))
        return VLC_EGENERIC;

    if (!hashlen || hashlen + asnlen + 4 > size)
        return VLC_EGENERIC;

    frame[0] = 0;
    frame[1] = 1; /* block type */
    int pad = size - hashlen - asnlen - 3 ;
    memset (&frame[2], 0xff, pad );
    frame[2+pad] = 0;
    memcpy(&frame[3+pad], asn, asnlen);
    memcpy(&frame[3+pad+asnlen], hash, hashlen);

    if (gcry_mpi_scan(r_result, GCRYMPI_FMT_USG, frame, size, &size))
        return VLC_EGENERIC;
    return VLC_SUCCESS;
}",437.0,463.0,1.0,1.0,27.0,30,9,40,13,1,0,4,4,0,0,,0,0,8,4,4,int
2937,131181,verify_signature_rsa,1,verify_signature_rsa,"int verify_signature_rsa (signature_packet_t*,public_key_packet_t*,uint8_t*)",misc\update_crypto.c,"static int verify_signature_rsa( signature_packet_t *sign, public_key_packet_t *p_key,
                      uint8_t *p_hash )
{
    int ret = VLC_EGENERIC;
    /* the data to be verified (a hash) */
    const char *hash_sexp_s = ""(data(flags raw)(value %m))"";
    /* the public key */
    const char *key_sexp_s = ""(public-key(rsa(n %m)(e %m)))"";
    /* the signature */
    const char *sig_sexp_s = ""(sig-val(rsa(s%m)))"";

    size_t erroff;
    gcry_mpi_t n, e, s, hash;
    n = e = s = hash = NULL;
    gcry_sexp_t key_sexp, hash_sexp, sig_sexp;
    key_sexp = hash_sexp = sig_sexp = NULL;

    size_t i_e_len = mpi_len( p_key->sig.rsa.e );
    size_t i_n_len = mpi_len( p_key->sig.rsa.n );
    if( gcry_mpi_scan( &n, GCRYMPI_FMT_USG, p_key->sig.rsa.n + 2, i_n_len, NULL ) ||
        gcry_mpi_scan( &e, GCRYMPI_FMT_USG, p_key->sig.rsa.e + 2, i_e_len, NULL ) ||
        gcry_sexp_build( &key_sexp, &erroff, key_sexp_s, n, e ) )
        goto out;

    uint8_t *p_s = sign->algo_specific.rsa.s;
 ...",468.0,516.0,1.0,1.0,49.0,49,6,74,23,0,9,16,12,4,4,,0,9,6,3,3,int
2938,131395,verify_signature_dsa,1,verify_signature_dsa,"int verify_signature_dsa (signature_packet_t*,public_key_packet_t*,uint8_t*)",misc\update_crypto.c,"static int verify_signature_dsa( signature_packet_t *sign, public_key_packet_t *p_key,
                      uint8_t *p_hash )
{
    int ret = VLC_EGENERIC;

    /* the data to be verified (a hash) */
    const char *hash_sexp_s = ""(data(flags raw)(value %m))"";
    /* the public key */
    const char *key_sexp_s = ""(public-key(dsa(p %m)(q %m)(g %m)(y %m)))"";
    /* the signature */
    const char *sig_sexp_s = ""(sig-val(dsa(r %m )(s %m )))"";

    size_t erroff;
    gcry_mpi_t p, q, g, y, r, s, hash;
    p = q = g = y = r = s = hash = NULL;
    gcry_sexp_t key_sexp, hash_sexp, sig_sexp;
    key_sexp = hash_sexp = sig_sexp = NULL;

    size_t i_p_len = mpi_len( p_key->sig.dsa.p );
    size_t i_q_len = mpi_len( p_key->sig.dsa.q );
    size_t i_g_len = mpi_len( p_key->sig.dsa.g );
    size_t i_y_len = mpi_len( p_key->sig.dsa.y );
    if( gcry_mpi_scan( &p, GCRYMPI_FMT_USG, p_key->sig.dsa.p + 2, i_p_len, NULL ) ||
        gcry_mpi_scan( &q, GCRYMPI_FMT_USG, p_key->sig.dsa.q + 2, i_q_len,...",521.0,584.0,1.0,1.0,64.0,83,7,116,31,0,15,20,16,4,6,,0,15,6,3,3,int
2939,132182,hash_from_binary_file,1,hash_from_binary_file,"int hash_from_binary_file (char*,gcry_md_hd_t)",misc\update_crypto.c,"static int hash_from_binary_file( const char *psz_file, gcry_md_hd_t hd )
{
    uint8_t buffer[4096];
    size_t i_read;

    FILE *f = vlc_fopen( psz_file, ""r"" );
    if( !f )
        return -1;

    while( ( i_read = fread( buffer, 1, sizeof(buffer), f ) ) > 0 )
        gcry_md_write( hd, buffer, i_read );

    fclose( f );

    return 0;
}",726.0,741.0,1.0,1.0,16.0,6,5,8,4,0,1,3,3,0,1,,0,1,4,2,2,int
2940,132222,hash_finish,1,hash_finish,"uint8_t hash_finish (gcry_md_hd_t,signature_packet_t*)",misc\update_crypto.c,"static uint8_t *hash_finish( gcry_md_hd_t hd, signature_packet_t *p_sig )
{
    if( p_sig->version == 3 )
    {
        gcry_md_putc( hd, p_sig->type );
        gcry_md_write( hd, &p_sig->specific.v3.timestamp, 4 );
    }
    else if( p_sig->version == 4 )
    {
        gcry_md_putc( hd, p_sig->version );
        gcry_md_putc( hd, p_sig->type );
        gcry_md_putc( hd, p_sig->public_key_algo );
        gcry_md_putc( hd, p_sig->digest_algo );
        gcry_md_write( hd, p_sig->specific.v4.hashed_data_len, 2 );
        size_t i_len = scalar_number( p_sig->specific.v4.hashed_data_len, 2 );
        gcry_md_write( hd, p_sig->specific.v4.hashed_data, i_len );

        gcry_md_putc( hd, 0x04 );
        gcry_md_putc( hd, 0xFF );

        i_len += 6; /* hashed data + 6 bytes header */

        gcry_md_putc( hd, (i_len >> 24) & 0xff );
        gcry_md_putc( hd, (i_len >> 16) & 0xff );
        gcry_md_putc( hd, (i_len >> 8) & 0xff );
        gcry_md_putc( hd, (i_len) & 0xff );
    }
    else
...",745.0,786.0,1.0,1.0,42.0,13,6,19,5,0,5,3,3,1,0,,0,5,4,2,2,uint8_t
2941,133446,pf_cmp,1,variable_ops_t.pf_cmp,"int variable_ops_t.pf_cmp (ANY,ANY)",misc\variables.c,"int  (*pf_cmp) ( vlc_value_t, vlc_value_t );",59.0,59.0,10.0,47.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
2942,133452,pf_dup,1,variable_ops_t.pf_dup,void variable_ops_t.pf_dup (vlc_value_t*),misc\variables.c,void (*pf_dup) ( vlc_value_t * );,60.0,60.0,10.0,36.0,1.0,0,0,0,0,5,0,1,1,0,0,,0,0,2,1,1,void
2943,133457,pf_free,1,variable_ops_t.pf_free,void variable_ops_t.pf_free (vlc_value_t*),misc\variables.c,void (*pf_free) ( vlc_value_t * );,61.0,61.0,10.0,37.0,1.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,void
2944,133482,CmpBool,1,CmpBool,"int CmpBool (vlc_value_t,vlc_value_t)",misc\variables.c,"static int CmpBool( vlc_value_t v, vlc_value_t w )
{
    return v.b_bool ? w.b_bool ? 0 : 1 : w.b_bool ? -1 : 0;
}",106.0,109.0,1.0,1.0,4.0,7,3,3,2,0,0,1,1,0,0,,0,0,4,2,2,int
2945,133506,CmpInt,1,CmpInt,"int CmpInt (vlc_value_t,vlc_value_t)",misc\variables.c,"static int CmpInt( vlc_value_t v, vlc_value_t w )
{
    return v.i_int == w.i_int ? 0 : v.i_int > w.i_int ? 1 : -1;
}",111.0,114.0,1.0,1.0,4.0,9,5,4,2,0,0,1,1,0,0,,0,0,4,2,2,int
2946,133533,CmpString,1,CmpString,"int CmpString (vlc_value_t,vlc_value_t)",misc\variables.c,"static int CmpString( vlc_value_t v, vlc_value_t w )
{
    if( !v.psz_string )
        return !w.psz_string ? 0 : -1;
    else
        return !w.psz_string ? 1 : strcmp( v.psz_string, w.psz_string );
}",116.0,122.0,1.0,1.0,7.0,6,4,2,2,0,0,2,2,0,0,,0,0,4,2,2,int
2947,133570,CmpFloat,1,CmpFloat,"int CmpFloat (vlc_value_t,vlc_value_t)",misc\variables.c,"static int CmpFloat( vlc_value_t v, vlc_value_t w ) { return v.f_float == w.f_float ? 0 : v.f_float > w.f_float ? 1 : -1; }",123.0,123.0,1.0,123.0,1.0,9,5,4,2,0,0,1,1,0,0,,0,0,4,2,2,int
2948,133597,CmpAddress,1,CmpAddress,"int CmpAddress (vlc_value_t,vlc_value_t)",misc\variables.c,"static int CmpAddress( vlc_value_t v, vlc_value_t w ) { return v.p_address == w.p_address ? 0 : v.p_address > w.p_address ? 1 : -1; }",124.0,124.0,1.0,133.0,1.0,9,5,4,2,0,0,1,1,0,0,,0,0,4,2,2,int
2949,133624,DupDummy,1,DupDummy,void DupDummy (vlc_value_t*),misc\variables.c,static void DupDummy( vlc_value_t *p_val ) { (void)p_val; /* unused */ },126.0,126.0,1.0,72.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
2950,133632,DupString,1,DupString,void DupString (vlc_value_t*),misc\variables.c,"static void DupString( vlc_value_t *p_val )
{
    p_val->psz_string = strdup( p_val->psz_string ? p_val->psz_string :  """" );
}",127.0,130.0,1.0,1.0,4.0,5,3,3,1,0,0,1,1,0,0,,0,0,2,1,1,void
2951,133650,FreeDummy,1,FreeDummy,void FreeDummy (vlc_value_t*),misc\variables.c,static void FreeDummy( vlc_value_t *p_val ) { (void)p_val; /* unused */ },132.0,132.0,1.0,73.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
2952,133658,FreeString,1,FreeString,void FreeString (vlc_value_t*),misc\variables.c,static void FreeString( vlc_value_t *p_val ) { free( p_val->psz_string ); },133.0,133.0,1.0,75.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
2953,133717,varcmp,1,varcmp,"int varcmp (void*,void*)",misc\variables.c,"static int varcmp( const void *a, const void *b )
{
    const variable_t *va = a, *vb = b;

    /* psz_name must be first */
    assert( va == (const void *)&va->psz_name );
    return strcmp( va->psz_name, vb->psz_name );
}",144.0,151.0,1.0,1.0,8.0,8,5,8,4,0,3,1,1,0,0,,0,3,4,2,2,int
2954,133880,CheckValue,1,CheckValue,"void CheckValue (variable_t*,vlc_value_t*)",misc\variables.c,"static void CheckValue(variable_t *var, vlc_value_t *val)
{
    /* Check that our variable is within the bounds */
    switch (var->i_type & VLC_VAR_TYPE)
    {
        case VLC_VAR_INTEGER:
            if (val->i_int < var->min.i_int)
               val->i_int = var->min.i_int;
            if (val->i_int > var->max.i_int)
                val->i_int = var->max.i_int;
            if (var->step.i_int != 0 && (val->i_int % var->step.i_int))
            {
                if (val->i_int > 0)
                    val->i_int = (val->i_int + (var->step.i_int / 2))
                                 / var->step.i_int * var->step.i_int;
                else
                    val->i_int = (val->i_int - (var->step.i_int / 2))
                                 / var->step.i_int * var->step.i_int;
            }
            break;

        case VLC_VAR_FLOAT:
            if (isless(val->f_float, var->min.f_float))
                val->f_float = var->min.f_float;
            if (isgreater(val->f_floa...",189.0,220.0,1.0,1.0,32.0,67,12,34,5,4,17,11,17,8,0,,0,17,4,2,2,void
2955,134090,WaitUnused,1,WaitUnused,"void WaitUnused (vlc_object_t*,variable_t*)",misc\variables.c,"static void WaitUnused(vlc_object_t *obj, variable_t *var)
{
    vlc_object_internals_t *priv = vlc_internals(obj);

    mutex_cleanup_push(&priv->var_lock);
    while (var->b_incallback)
        vlc_cond_wait(&priv->var_wait, &priv->var_lock);
    vlc_cleanup_pop();
}",225.0,233.0,1.0,35.0,9.0,6,5,5,3,5,1,2,2,1,0,,0,1,4,2,2,void
2956,134127,TriggerCallback,1,TriggerCallback,"void TriggerCallback (vlc_object_t*,variable_t*,char*,vlc_value_t)",misc\variables.c,"static void TriggerCallback(vlc_object_t *obj, variable_t *var,
                            const char *name, vlc_value_t prev)
{
    assert(obj != NULL);

    size_t count = var->value_callbacks.i_entries;
    if (count == 0)
        return;

    callback_entry_t *entries = var->value_callbacks.p_entries;
    vlc_object_internals_t *priv = vlc_internals(obj);

    assert(!var->b_incallback);
    var->b_incallback = true;
    vlc_mutex_unlock(&priv->var_lock);

    for (size_t i = 0; i < count; i++)
        entries[i].pf_value_callback(obj, name, prev, var->val,
                                     entries[i].p_data);

    vlc_mutex_lock(&priv->var_lock);
    var->b_incallback = false;
    vlc_cond_broadcast(&priv->var_wait);
}",235.0,258.0,1.0,35.0,24.0,25,10,21,9,3,8,3,3,0,3,,0,5,8,4,4,void
2957,134231,TriggerListCallback,1,TriggerListCallback,"void TriggerListCallback (vlc_object_t*,variable_t*,char*,int,vlc_value_t*)",misc\variables.c,"static void TriggerListCallback(vlc_object_t *obj, variable_t *var,
                                const char *name, int action, vlc_value_t *val)
{
    assert(obj != NULL);

    size_t count = var->list_callbacks.i_entries;
    if (count == 0)
        return;

    callback_entry_t *entries = var->list_callbacks.p_entries;
    vlc_object_internals_t *priv = vlc_internals(obj);

    assert(!var->b_incallback);
    var->b_incallback = true;
    vlc_mutex_unlock(&priv->var_lock);

    for (size_t i = 0; i < count; i++)
        entries[i].pf_list_callback(obj, name, action, val,
                                      entries[i].p_data);

    vlc_mutex_lock(&priv->var_lock);
    var->b_incallback = false;
    vlc_cond_broadcast(&priv->var_wait);
}",260.0,283.0,1.0,35.0,24.0,25,10,21,9,3,8,3,3,0,3,,0,5,10,5,5,void
2958,134334,var_Create,1,var_Create,"int var_Create (vlc_object_t*,char*,int)",misc\variables.c,"int var_Create( vlc_object_t *p_this, const char *psz_name, int i_type )
{
    assert( p_this );

    variable_t *p_var = calloc( 1, sizeof( *p_var ) );
    if( p_var == NULL )
        return VLC_ENOMEM;

    p_var->psz_name = strdup( psz_name );
    p_var->psz_text = NULL;

    p_var->i_type = i_type & ~VLC_VAR_DOINHERIT;

    p_var->i_usage = 1;

    p_var->choices.i_count = 0;
    p_var->choices.p_values = NULL;
    p_var->choices_text.i_count = 0;
    p_var->choices_text.p_values = NULL;

    p_var->b_incallback = false;
    p_var->value_callbacks = (callback_table_t){ 0, NULL };

    /* Always initialize the variable, even if it is a list variable; this
     * will lead to errors if the variable is not initialized, but it will
     * not cause crashes in the variable handling. */
    switch( i_type & VLC_VAR_CLASS )
    {
        case VLC_VAR_BOOL:
            p_var->ops = &bool_ops;
            p_var->val.b_bool = false;
            break;
        case VLC_VAR_INTEGER:
       ...",298.0,387.0,1.0,37.0,90.0,107,14,89,30,43,40,13,6,0,4,,0,36,6,3,3,int
2959,134679,var_Destroy,1,,"void (vlc_object_t*,char*)",misc\variables.c,"void (var_Destroy)(vlc_object_t *p_this, const char *psz_name)
{
    variable_t *p_var;

    assert( p_this );

    vlc_object_internals_t *p_priv = vlc_internals( p_this );

    p_var = Lookup( p_this, psz_name );
    if( p_var == NULL )
        msg_Dbg( p_this, ""attempt to destroy nonexistent variable \""%s\"""",
                 psz_name );
    else if( --p_var->i_usage == 0 )
    {
        assert(!p_var->b_incallback);
        tdelete( p_var, &p_priv->var_root, varcmp );
    }
    else
    {
        assert(p_var->i_usage != -1u);
        p_var = NULL;
    }
    vlc_mutex_unlock( &p_priv->var_lock );

    if( p_var != NULL )
        Destroy( p_var );
}",398.0,424.0,1.0,37.0,27.0,8,7,15,5,0,3,3,3,0,3,,0,1,4,2,2,void
2960,134760,CleanupVar,1,CleanupVar,void CleanupVar (void*),misc\variables.c,"static void CleanupVar( void *var )
{
    Destroy( var );
}",426.0,429.0,1.0,1.0,4.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
2961,134767,var_DestroyAll,1,var_DestroyAll,void var_DestroyAll (vlc_object_t*),misc\variables.c,"void var_DestroyAll( vlc_object_t *obj )
{
    vlc_object_internals_t *priv = vlc_internals( obj );

    tdestroy( priv->var_root, CleanupVar );
    priv->var_root = NULL;
}",431.0,437.0,1.0,35.0,7.0,6,4,6,3,1,0,1,1,0,0,,0,0,2,1,1,void
2962,134794,var_Change,1,var_Change,"int var_Change (vlc_object_t*,char*,int,vlc_value_t*,vlc_value_t*)",misc\variables.c,"int var_Change( vlc_object_t *p_this, const char *psz_name,
                int i_action, vlc_value_t *p_val, vlc_value_t *p_val2 )
{
    int ret = VLC_SUCCESS;
    variable_t *p_var;
    vlc_value_t oldval;
    vlc_value_t newval;

    assert( p_this );

    vlc_object_internals_t *p_priv = vlc_internals( p_this );

    p_var = Lookup( p_this, psz_name );
    if( p_var == NULL )
    {
        vlc_mutex_unlock( &p_priv->var_lock );
        return VLC_ENOVAR;
    }

    switch( i_action )
    {
        case VLC_VAR_GETMIN:
            *p_val = p_var->min;
            break;
        case VLC_VAR_GETMAX:
            *p_val = p_var->max;
            break;
        case VLC_VAR_SETMINMAX:
            assert(p_var->ops->pf_free == FreeDummy);
            p_var->min = *p_val;
            p_var->max = *p_val2;
            break;
        case VLC_VAR_SETSTEP:
            assert(p_var->ops->pf_free == FreeDummy);
            p_var->step = *p_val;
            CheckValue( p_var, &p_var->val );
...",449.0,619.0,1.0,37.0,171.0,230,15,187,34,47,73,33,34,10,14,,0,60,10,5,5,int
2963,135546,var_GetAndSet,1,var_GetAndSet,"int var_GetAndSet (vlc_object_t*,char*,int,vlc_value_t*)",misc\variables.c,"int var_GetAndSet( vlc_object_t *p_this, const char *psz_name, int i_action,
                   vlc_value_t *p_val )
{
    variable_t *p_var;
    vlc_value_t oldval;

    assert( p_this );
    assert( p_val );

    vlc_object_internals_t *p_priv = vlc_internals( p_this );

    p_var = Lookup( p_this, psz_name );
    if( p_var == NULL )
    {
        vlc_mutex_unlock( &p_priv->var_lock );
        return VLC_ENOVAR;
    }

    WaitUnused( p_this, p_var );

    /* Duplicated data if needed */
    //p_var->ops->pf_dup( &val );

    /* Backup needed stuff */
    oldval = p_var->val;

    /* depending of the action requiered */
    switch( i_action )
    {
    case VLC_VAR_BOOL_TOGGLE:
        assert( ( p_var->i_type & VLC_VAR_BOOL ) == VLC_VAR_BOOL );
        p_var->val.b_bool = !p_var->val.b_bool;
        break;
    case VLC_VAR_INTEGER_ADD:
        assert( ( p_var->i_type & VLC_VAR_INTEGER ) == VLC_VAR_INTEGER );
        p_var->val.i_int += p_val->i_int;
        break;
    case VLC_VAR...",631.0,690.0,1.0,37.0,60.0,47,12,53,17,0,19,7,3,0,7,,0,13,8,4,4,int
2964,135716,var_Type,1,var_Type,"int var_Type (vlc_object_t*,char*)",misc\variables.c,"int var_Type( vlc_object_t *p_this, const char *psz_name )
{
    variable_t *p_var;
    int i_type = 0;

    assert( p_this );

    vlc_object_internals_t *p_priv = vlc_internals( p_this );

    p_var = Lookup( p_this, psz_name );
    if( p_var != NULL )
    {
        i_type = p_var->i_type;
        if( p_var->choices.i_count > 0 )
            i_type |= VLC_VAR_HASCHOICE;
    }
    vlc_mutex_unlock( &p_priv->var_lock );

    return i_type;
}",700.0,719.0,1.0,37.0,20.0,13,8,17,7,4,4,3,4,1,2,,0,3,4,2,2,int
2965,135775,var_SetChecked,1,var_SetChecked,"int var_SetChecked (vlc_object_t*,char*,int,vlc_value_t)",misc\variables.c,"int var_SetChecked( vlc_object_t *p_this, const char *psz_name,
                    int expected_type, vlc_value_t val )
{
    variable_t *p_var;
    vlc_value_t oldval;

    assert( p_this );

    vlc_object_internals_t *p_priv = vlc_internals( p_this );

    p_var = Lookup( p_this, psz_name );
    if( p_var == NULL )
    {
        vlc_mutex_unlock( &p_priv->var_lock );
        return VLC_ENOVAR;
    }

    assert( expected_type == 0 ||
            (p_var->i_type & VLC_VAR_CLASS) == expected_type );
    assert ((p_var->i_type & VLC_VAR_CLASS) != VLC_VAR_VOID);

    WaitUnused( p_this, p_var );

    /* Duplicate data if needed */
    p_var->ops->pf_dup( &val );

    /* Backup needed stuff */
    oldval = p_var->val;

    /* Check boundaries and list */
    CheckValue( p_var, &val );

    /* Set the variable */
    p_var->val = val;

    /* Deal with callbacks */
    TriggerCallback( p_this, p_var, psz_name, oldval );

    /* Free data if needed */
    p_var->ops->pf_free( &oldval );...",722.0,765.0,1.0,37.0,44.0,28,9,36,12,2,14,2,2,0,8,,0,7,8,4,4,int
2966,135881,var_Set,1,var_Set,"int var_Set (vlc_object_t*,char*,vlc_value_t)",misc\variables.c,"int var_Set( vlc_object_t *p_this, const char *psz_name, vlc_value_t val )
{
    return var_SetChecked( p_this, psz_name, 0, val );
}",775.0,778.0,1.0,1.0,4.0,0,0,3,3,4,1,1,1,0,1,,0,0,6,3,3,int
2967,135894,var_GetChecked,1,var_GetChecked,"int var_GetChecked (vlc_object_t*,char*,int,vlc_value_t*)",misc\variables.c,"int var_GetChecked( vlc_object_t *p_this, const char *psz_name,
                    int expected_type, vlc_value_t *p_val )
{
    assert( p_this );

    vlc_object_internals_t *p_priv = vlc_internals( p_this );
    variable_t *p_var;
    int err = VLC_SUCCESS;

    p_var = Lookup( p_this, psz_name );
    if( p_var != NULL )
    {
        assert( expected_type == 0 ||
                (p_var->i_type & VLC_VAR_CLASS) == expected_type );
        assert ((p_var->i_type & VLC_VAR_CLASS) != VLC_VAR_VOID);

        /* Really get the variable */
        *p_val = p_var->val;

        /* Duplicate value if needed */
        p_var->ops->pf_dup( p_val );
    }
    else
        err = VLC_ENOVAR;

    vlc_mutex_unlock( &p_priv->var_lock );
    return err;
}",781.0,808.0,1.0,37.0,28.0,21,10,24,11,2,7,2,2,0,3,,0,5,8,4,4,int
2968,135976,var_Get,1,var_Get,"int var_Get (vlc_object_t*,char*,vlc_value_t*)",misc\variables.c,"int var_Get( vlc_object_t *p_this, const char *psz_name, vlc_value_t *p_val )
{
    return var_GetChecked( p_this, psz_name, 0, p_val );
}",819.0,822.0,1.0,1.0,4.0,0,0,3,3,3,1,1,1,0,1,,0,0,6,3,3,int
2969,135993,AddCallback,1,AddCallback,"void AddCallback (vlc_object_t*,char*,callback_entry_t,vlc_callback_type_t)",misc\variables.c,"static void AddCallback( vlc_object_t *p_this, const char *psz_name,
                        callback_entry_t entry, vlc_callback_type_t i_type )
{
    variable_t *p_var;

    assert( p_this );

    vlc_object_internals_t *p_priv = vlc_internals( p_this );

    p_var = Lookup( p_this, psz_name );
    if( p_var == NULL )
    {
        vlc_mutex_unlock( &p_priv->var_lock );
        msg_Err( p_this, ""cannot add callback %p to nonexistent variable '%s'"",
                 entry.p_callback, psz_name );
        return;
    }

    WaitUnused( p_this, p_var );

    callback_table_t *p_table;
    if (i_type == vlc_value_callback)
        p_table = &p_var->value_callbacks;
    else
        p_table = &p_var->list_callbacks;
    TAB_APPEND(p_table->i_entries, p_table->p_entries, entry);

    vlc_mutex_unlock( &p_priv->var_lock );
}",830.0,858.0,1.0,37.0,29.0,16,7,23,9,2,8,3,3,0,4,,0,5,8,4,4,void
2970,136075,var_AddCallback,1,var_AddCallback,"void var_AddCallback (vlc_object_t*,char*,vlc_callback_t,void*)",misc\variables.c,"void var_AddCallback( vlc_object_t *p_this, const char *psz_name,
                      vlc_callback_t pf_callback, void *p_data )
{
    callback_entry_t entry;
    entry.pf_value_callback = pf_callback;
    entry.p_data = p_data;

    AddCallback(p_this, psz_name, entry, vlc_value_callback);
}",877.0,885.0,1.0,1.0,9.0,4,2,8,6,11,3,1,1,0,1,,0,2,8,4,4,void
2971,136099,DelCallback,1,DelCallback,"void DelCallback (vlc_object_t*,char*,callback_entry_t,vlc_callback_type_t)",misc\variables.c,"static void DelCallback( vlc_object_t *p_this, const char *psz_name,
                         callback_entry_t entry, vlc_callback_type_t i_type )
{
    int i_entry;
    variable_t *p_var;
#ifndef NDEBUG
    bool b_found_similar = false;
#endif

    assert( p_this );

    vlc_object_internals_t *p_priv = vlc_internals( p_this );

    p_var = Lookup( p_this, psz_name );
    if( p_var == NULL )
    {
        vlc_mutex_unlock( &p_priv->var_lock );
        msg_Err( p_this, ""cannot delete callback %p from nonexistent ""
                 ""variable '%s'"", entry.p_callback, psz_name );
        return;
    }

    WaitUnused( p_this, p_var );

    callback_table_t *p_table;
    if (i_type == vlc_value_callback)
        p_table = &p_var->value_callbacks;
    else
        p_table = &p_var->list_callbacks;

    for( i_entry = p_table->i_entries ; i_entry-- ; )
    {
        if( p_table->p_entries[i_entry].p_callback == entry.p_callback
            && p_table->p_entries[i_entry].p_data == entry.p_...",887.0,945.0,1.0,37.0,59.0,34,11,39,13,2,14,8,9,4,5,,0,10,8,4,4,void
2972,136259,var_DelCallback,1,var_DelCallback,"void var_DelCallback (vlc_object_t*,char*,vlc_callback_t,void*)",misc\variables.c,"void var_DelCallback( vlc_object_t *p_this, const char *psz_name,
                      vlc_callback_t pf_callback, void *p_data )
{
    callback_entry_t entry;
    entry.pf_value_callback = pf_callback;
    entry.p_data = p_data;

    DelCallback(p_this, psz_name, entry, vlc_value_callback);
}",954.0,962.0,1.0,1.0,9.0,4,2,8,6,13,3,1,1,0,1,,0,2,8,4,4,void
2973,136283,var_TriggerCallback,1,var_TriggerCallback,"void var_TriggerCallback (vlc_object_t*,char*)",misc\variables.c,"void var_TriggerCallback( vlc_object_t *p_this, const char *psz_name )
{
    vlc_object_internals_t *p_priv = vlc_internals( p_this );
    variable_t *p_var = Lookup( p_this, psz_name );
    if( p_var != NULL )
    {
        WaitUnused( p_this, p_var );

        /* Deal with callbacks. Tell we're in a callback, release the lock,
         * call stored functions, retake the lock. */
        TriggerCallback( p_this, p_var, psz_name, p_var->val );
    }
    vlc_mutex_unlock( &p_priv->var_lock );
}",971.0,984.0,1.0,37.0,14.0,8,6,15,5,1,5,2,2,0,4,,0,2,4,2,2,void
2974,136327,var_AddListCallback,1,var_AddListCallback,"void var_AddListCallback (vlc_object_t*,char*,vlc_list_callback_t,void*)",misc\variables.c,"void var_AddListCallback( vlc_object_t *p_this, const char *psz_name,
                          vlc_list_callback_t pf_callback, void *p_data )
{
    callback_entry_t entry;
    entry.pf_list_callback = pf_callback;
    entry.p_data = p_data;

    AddCallback(p_this, psz_name, entry, vlc_list_callback);
}",995.0,1003.0,1.0,1.0,9.0,4,2,8,6,0,3,1,1,0,1,,0,2,8,4,4,void
2975,136351,var_DelListCallback,1,var_DelListCallback,"void var_DelListCallback (vlc_object_t*,char*,vlc_list_callback_t,void*)",misc\variables.c,"void var_DelListCallback( vlc_object_t *p_this, const char *psz_name,
                          vlc_list_callback_t pf_callback, void *p_data )
{
    callback_entry_t entry;
    entry.pf_list_callback = pf_callback;
    entry.p_data = p_data;

    DelCallback(p_this, psz_name, entry, vlc_list_callback);
}",1011.0,1019.0,1.0,1.0,9.0,4,2,8,6,0,3,1,1,0,1,,0,2,8,4,4,void
2976,136581,var_LocationParse,1,var_LocationParse,"int var_LocationParse (vlc_object_t*,char*,char*)",misc\variables.c,"int var_LocationParse (vlc_object_t *obj, const char *mrl, const char *pref)
{
    int ret = VLC_SUCCESS;
    size_t preflen = strlen (pref) + 1;

    assert(mrl != NULL);
    while (*mrl != '\0')
    {
        mrl += strspn (mrl, "":;""); /* skip leading colon(s) */

        size_t len = strcspn (mrl, "":;"");
        char *buf = malloc (preflen + len);

        if (likely(buf != NULL))
        {
            /* NOTE: this does not support the ""no-<varname>"" bool syntax. */
            /* DO NOT use asprintf() here; it won't work! Think again. */
            snprintf (buf, preflen + len, ""%s%s"", pref, mrl);
            var_OptionParse (obj, buf, false);
            free (buf);
        }
        else
            ret = VLC_ENOMEM;
        mrl += len;
    }

    return ret;
}",1138.0,1165.0,1.0,1.0,28.0,13,5,28,10,0,1,3,4,0,1,,0,0,6,3,3,int
2977,136657,var_Inherit,1,var_Inherit,"int var_Inherit (vlc_object_t*,char*,int,vlc_value_t*)",misc\variables.c,"int var_Inherit( vlc_object_t *p_this, const char *psz_name, int i_type,
                 vlc_value_t *p_val )
{
    i_type &= VLC_VAR_CLASS;
    for( vlc_object_t *obj = p_this; obj != NULL; obj = obj->obj.parent )
    {
        if( var_GetChecked( obj, psz_name, i_type, p_val ) == VLC_SUCCESS )
            return VLC_SUCCESS;
    }

    /* else take value from config */
    switch( i_type & VLC_VAR_CLASS )
    {
        case VLC_VAR_STRING:
            p_val->psz_string = config_GetPsz( p_this, psz_name );
            if( !p_val->psz_string ) p_val->psz_string = strdup("""");
            break;
        case VLC_VAR_FLOAT:
            p_val->f_float = config_GetFloat( p_this, psz_name );
            break;
        case VLC_VAR_INTEGER:
            p_val->i_int = config_GetInt( p_this, psz_name );
            break;
        case VLC_VAR_BOOL:
            p_val->b_bool = config_GetInt( p_this, psz_name ) > 0;
            break;
        default:
            vlc_assert_unreachable();
   ...",1173.0,1205.0,1.0,1.0,33.0,17,7,35,14,1,5,9,7,1,5,,0,5,8,4,4,int
2978,136763,var_InheritURational,1,,"int (vlc_object_t*,unsigned*,unsigned*,char*)",misc\variables.c,"int (var_InheritURational)(vlc_object_t *object,
                           unsigned *num, unsigned *den,
                           const char *var)
{
    char *str = var_InheritString(object, var);
    if (str == NULL)
        goto error;

    char *sep;
    unsigned n = strtoul(str, &sep, 10);
    unsigned d;

    switch (*sep) {
        case '\0':
            /* Decimal integer */
            d = 1;
            break;

        case ':':
        case '/':
            /* Decimal fraction */
            d = strtoul(sep + 1, &sep, 10);
            if (*sep != '\0')
                goto error;
            break;

        case '.': {
            /* Decimal number */
            unsigned char c;

            d = 1;
            while ((c = *(++sep)) != '\0') {
                c -= '0';

                if (c >= 10)
                    goto error;

                n = n * 10 + c;
                d *= 10;
            }
            break;
        }

        default:
            goto error;...",1215.0,1280.0,1.0,1.0,66.0,32,12,33,12,0,0,14,11,0,0,,0,0,8,4,4,int
2979,136918,var_FreeList,1,var_FreeList,"void var_FreeList (vlc_value_t*,vlc_value_t*)",misc\variables.c,"void var_FreeList( vlc_value_t *p_val, vlc_value_t *p_val2 )
{
    switch( p_val->p_list->i_type & VLC_VAR_CLASS )
    {
        case VLC_VAR_STRING:
            for( int i = 0; i < p_val->p_list->i_count; i++ )
                free( p_val->p_list->p_values[i].psz_string );
            break;
    }

    free( p_val->p_list->p_values );
    free( p_val->p_list );

    if( p_val2 != NULL )
    {
        assert( p_val2->p_list != NULL );
        assert( p_val2->p_list->i_type == VLC_VAR_STRING );

        for( int i = 0; i < p_val2->p_list->i_count; i++ )
            free( p_val2->p_list->p_values[i].psz_string );
        free( p_val2->p_list->p_values );
        free( p_val2->p_list );
    }
}",1287.0,1310.0,1.0,1.0,24.0,23,6,19,6,0,0,6,7,0,0,,0,0,4,2,2,void
2980,137025,DumpVariable,1,DumpVariable,"void DumpVariable (void*,VISIT,int)",misc\variables.c,"static void DumpVariable(const void *data, const VISIT which, const int depth)
{
    if (which != postorder && which != leaf)
        return;
    (void) depth;

    const variable_t *var = *(const variable_t **)data;
    const char *typename = ""unknown"";

    switch (var->i_type & VLC_VAR_TYPE)
    {
        case VLC_VAR_VOID:     typename = ""void"";        break;
        case VLC_VAR_BOOL:     typename = ""bool"";        break;
        case VLC_VAR_INTEGER:  typename = ""integer"";     break;
        case VLC_VAR_STRING:   typename = ""string"";      break;
        case VLC_VAR_FLOAT:    typename = ""float"";       break;
        case VLC_VAR_COORDS:   typename = ""coordinates""; break;
        case VLC_VAR_ADDRESS:  typename = ""address"";     break;
        default:               typename = ""unknown"";     break;
    }

    printf("" *-o \""%s\"" (%s"", var->psz_name, typename);
    if (var->psz_text != NULL)
        printf("", %s"", var->psz_text);
    putchar(')');
    if (var->i_type & VLC_VAR_HA...",1312.0,1369.0,1.0,1.0,58.0,41,9,51,20,0,13,23,8,6,0,,0,13,6,3,3,void
2981,137227,DumpVariables,1,DumpVariables,void DumpVariables (vlc_object_t*),misc\variables.c,"void DumpVariables(vlc_object_t *obj)
{
    vlc_mutex_lock(&vlc_internals(obj)->var_lock);
    if (vlc_internals(obj)->var_root == NULL)
        puts("" `-o No variables"");
    else
        twalk(vlc_internals(obj)->var_root, DumpVariable);
    vlc_mutex_unlock(&vlc_internals(obj)->var_lock);
}",1371.0,1379.0,1.0,20.0,9.0,12,5,7,2,1,2,2,2,0,2,,0,0,2,1,1,void
2982,137291,TwalkGetNames,1,TwalkGetNames,"void TwalkGetNames (void*,VISIT,int)",misc\variables.c,"static void TwalkGetNames(const void *data, const VISIT which, const int depth)
{
    if (which != postorder && which != leaf)
        return;
    (void) depth;

    const variable_t *var = *(const variable_t **)data;
    DECL_ARRAY(char *) *names = twalk_ctx;
    char *dup = strdup(var->psz_name);
    if (dup != NULL)
        ARRAY_APPEND(*names, dup);
}",1383.0,1394.0,1.0,1.0,12.0,11,6,13,9,0,1,3,3,0,0,,0,1,6,3,3,void
2983,137335,var_GetAllNames,1,var_GetAllNames,char** var_GetAllNames (vlc_object_t*),misc\variables.c,"char **var_GetAllNames(vlc_object_t *obj)
{
    vlc_object_internals_t *priv = vlc_internals(obj);

    DECL_ARRAY(char *) names;
    ARRAY_INIT(names);

    twalk_ctx = &names;
    vlc_mutex_lock(&priv->var_lock);
    twalk(priv->var_root, TwalkGetNames);
    vlc_mutex_unlock(&priv->var_lock);

    if (names.i_size == 0)
        return NULL;
    ARRAY_APPEND(names, NULL);
    return names.p_elems;
}",1396.0,1412.0,1.0,35.0,17.0,13,7,14,5,2,2,2,2,0,2,,0,0,2,1,1,char**
2984,137447,xml_Create,1,xml_Create,xml_t xml_Create (vlc_object_t*),misc\xml.c,"xml_t *xml_Create( vlc_object_t *p_this )
{
    xml_t *p_xml;

    p_xml = vlc_custom_create( p_this, sizeof( *p_xml ), ""xml"" );

    p_xml->p_module = module_need( p_xml, ""xml"", NULL, false );
    if( !p_xml->p_module )
    {
        vlc_object_release( p_xml );
        msg_Err( p_this, ""XML provider not found"" );
        return NULL;
    }

    return p_xml;
}",39.0,54.0,1.0,12.0,16.0,7,5,13,4,0,3,2,2,0,3,,0,2,2,1,1,xml_t
2985,137490,xml_Delete,1,xml_Delete,void xml_Delete (xml_t*),misc\xml.c,"void xml_Delete( xml_t *p_xml )
{
    module_unneed( p_xml, p_xml->p_module );
    vlc_object_release( p_xml );
}",59.0,63.0,1.0,1.0,5.0,1,1,3,1,0,2,1,1,0,2,,0,0,2,1,1,void
2986,137502,xml_ReaderCreate,1,xml_ReaderCreate,"xml_reader_t xml_ReaderCreate (vlc_object_t*,stream_t*)",misc\xml.c,"xml_reader_t *xml_ReaderCreate(vlc_object_t *obj, stream_t *stream)
{
    xml_reader_t *reader;

    reader = vlc_custom_create(obj, sizeof(*reader), ""xml reader"");

    reader->p_stream = stream;
    reader->p_module = module_need(reader, ""xml reader"", NULL, false);
    if (unlikely(reader->p_module == NULL))
    {
        msg_Err(reader, ""XML reader not found"");
        vlc_object_release(reader);
        return NULL;
    }
    return reader;
}",73.0,88.0,1.0,13.0,16.0,9,5,16,5,0,3,2,2,0,3,,0,2,4,2,2,xml_reader_t
2987,137552,xml_ReaderDelete,1,xml_ReaderDelete,void xml_ReaderDelete (xml_reader_t*),misc\xml.c,"void xml_ReaderDelete(xml_reader_t *reader)
{
    if (reader->p_stream)
        module_stop(reader, reader->p_module);
    vlc_object_release(reader);
}",95.0,100.0,1.0,1.0,6.0,2,1,4,1,0,2,2,2,0,2,,0,0,2,1,1,void
2988,137569,xml_ReaderReset,1,xml_ReaderReset,"xml_reader_t xml_ReaderReset (xml_reader_t*,stream_t*)",misc\xml.c,"xml_reader_t *xml_ReaderReset(xml_reader_t *reader, stream_t *stream)
{
    if (reader->p_stream)
        module_stop(reader, reader->p_module);

    reader->p_stream = stream;
    if ((stream != NULL) && module_start(reader, reader->p_module))
    {
        vlc_object_release(reader);
        return NULL;
    }
    return reader;
}",115.0,127.0,1.0,1.0,13.0,7,4,12,3,0,3,3,3,1,3,,0,1,4,2,2,xml_reader_t
2989,137624,sdp_AddMedia,1,sdp_AddMedia,"void sdp_AddMedia (vlc_memstream*,char*,char*,int,unsigned,bool,unsigned,char*,unsigned,unsigned,char*)",stream_output\sdp.c,"void sdp_AddMedia(struct vlc_memstream *restrict stream,
                  const char *type, const char *proto, int dport,
                  unsigned pt, bool bw_indep, unsigned bw,
                  const char *ptname, unsigned clock, unsigned chans,
                  const char *fmtp)
{
    /* Some default values */
    if (type == NULL)
        type = ""video"";
    if (proto == NULL)
        proto = ""RTP/AVP"";
    assert (pt < 128u);

    vlc_memstream_printf(stream, ""m=%s %u %s %u\r\n"", type, dport, proto, pt);

    if (bw > 0)
        vlc_memstream_printf(stream, ""b=%s:%u\r\n"",
                             bw_indep ? ""TIAS"" : ""AS"", bw);
    vlc_memstream_printf(stream, ""b=%s:%u\r\n"", ""RR"", 0);

    /* RTP payload type map */
    if (ptname != NULL)
    {
        vlc_memstream_printf(stream, ""a=rtpmap:%u %s/%u"", pt, ptname, clock);
        if ((strcmp(type, ""audio"") == 0) && (chans != 1))
            vlc_memstream_printf(stream, ""/%u"", chans);
        vlc_memstream_puts(stream, ""...",112.0,144.0,1.0,1.0,33.0,1,1,13,12,0,0,1,1,0,0,,0,0,22,11,11,void
2990,137665,sdp_AddAttribute,1,sdp_AddAttribute,"void sdp_AddAttribute (vlc_memstream*,char*,char*...)",stream_output\sdp.c,"void sdp_AddAttribute(struct vlc_memstream *restrict stream, const char *name,
                      const char *fmt, ...)
{
    va_list ap;

    va_start(ap, fmt);
    vsdp_AddAttribute(stream, name, fmt, ap);
    va_end(ap);
}",102.0,110.0,1.0,1.0,9.0,1,1,5,4,0,0,1,1,0,0,,0,0,6,3,3,void
2991,137682,sout_AccessOutControl,1,sout_AccessOutControl,"int sout_AccessOutControl (sout_access_out_t*,int...)",stream_output\stream_output.c,"int sout_AccessOutControl (sout_access_out_t *access, int query, ...)
{
    va_list ap;
    int ret;

    va_start (ap, query);
    if (access->pf_control)
        ret = access->pf_control (access, query, ap);
    else
        ret = VLC_EGENERIC;
    va_end (ap);
    return ret;
}",329.0,341.0,1.0,1.0,13.0,0,0,2,2,0,0,1,1,0,0,,0,0,4,2,2,int
2992,137693,sout_AccessOutDelete,1,sout_AccessOutDelete,void sout_AccessOutDelete (sout_access_out_t*),stream_output\stream_output.c,"void sout_AccessOutDelete( sout_access_out_t *p_access )
{
    if( p_access->p_module )
    {
        module_unneed( p_access, p_access->p_module );
    }
    free( p_access->psz_access );

    config_ChainDestroy( p_access->p_cfg );

    free( p_access->psz_path );

    vlc_object_release( p_access );
}",284.0,297.0,1.0,1.0,14.0,0,0,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
2993,137701,sout_AccessOutNew,1,sout_AccessOutNew,"sout_access_out_t sout_AccessOutNew (vlc_object_t*,char*,char*)",stream_output\stream_output.c,"sout_access_out_t *sout_AccessOutNew( vlc_object_t *p_sout,
                                      const char *psz_access, const char *psz_name )
{
    sout_access_out_t *p_access;
    char              *psz_next;

    p_access = vlc_custom_create( p_sout, sizeof( *p_access ), ""access out"" );
    if( !p_access )
        return NULL;

    psz_next = config_ChainCreate( &p_access->psz_access, &p_access->p_cfg,
                                   psz_access );
    free( psz_next );
    p_access->psz_path   = strdup( psz_name ? psz_name : """" );
    p_access->p_sys      = NULL;
    p_access->pf_seek    = NULL;
    p_access->pf_read    = NULL;
    p_access->pf_write   = NULL;
    p_access->pf_control = NULL;
    p_access->p_module   = NULL;

    p_access->p_module   =
        module_need( p_access, ""sout access"", p_access->psz_access, true );

    if( !p_access->p_module )
    {
        free( p_access->psz_access );
        free( p_access->psz_path );
        vlc_object_release( p_access );...",247.0,280.0,1.0,1.0,34.0,0,0,4,4,0,0,1,1,0,0,,0,0,6,3,3,sout_access_out_t
2994,137717,sout_AccessOutRead,1,sout_AccessOutRead,"ssize_t sout_AccessOutRead (sout_access_out_t*,block_t*)",stream_output\stream_output.c,"ssize_t sout_AccessOutRead( sout_access_out_t *p_access, block_t *p_buffer )
{
    return( p_access->pf_read ?
            p_access->pf_read( p_access, p_buffer ) : VLC_EGENERIC );
}",312.0,316.0,1.0,1.0,5.0,0,0,2,2,0,0,1,1,0,0,,0,0,4,2,2,ssize_t
2995,137728,sout_AccessOutSeek,1,sout_AccessOutSeek,"int sout_AccessOutSeek (sout_access_out_t*,off_t)",stream_output\stream_output.c,"int sout_AccessOutSeek( sout_access_out_t *p_access, off_t i_pos )
{
    if (p_access->pf_seek == NULL)
        return VLC_EGENERIC;
    return p_access->pf_seek( p_access, i_pos );
}",302.0,307.0,1.0,1.0,6.0,0,0,2,2,0,0,1,1,0,0,,0,0,4,2,2,int
2996,137739,sout_AccessOutWrite,1,sout_AccessOutWrite,"ssize_t sout_AccessOutWrite (sout_access_out_t*,block_t*)",stream_output\stream_output.c,"ssize_t sout_AccessOutWrite( sout_access_out_t *p_access, block_t *p_buffer )
{
    return p_access->pf_write( p_access, p_buffer );
}",321.0,324.0,1.0,1.0,4.0,0,0,2,2,0,0,1,1,0,0,,0,0,4,2,2,ssize_t
2997,137750,sout_AnnounceRegisterSDP,1,sout_AnnounceRegisterSDP,"session_descriptor_t sout_AnnounceRegisterSDP (vlc_object_t*,char*,char*)",stream_output\sap.c,"session_descriptor_t *
sout_AnnounceRegisterSDP (vlc_object_t *obj, const char *sdp,
                          const char *dst)
{
    int i;
    char psz_addr[NI_MAXNUMERICHOST];
    union
    {
        struct sockaddr     a;
        struct sockaddr_in  in;
        struct sockaddr_in6 in6;
    } addr;
    socklen_t addrlen = 0;
    struct addrinfo *res;

    msg_Dbg (obj, ""adding SAP session"");

    if (vlc_getaddrinfo (dst, 0, NULL, &res) == 0)
    {
        if (res->ai_addrlen <= sizeof (addr))
            memcpy (&addr, res->ai_addr, res->ai_addrlen);
        addrlen = res->ai_addrlen;
        freeaddrinfo (res);
    }

    if (addrlen == 0 || addrlen > sizeof (addr))
    {
        msg_Err (obj, ""No/invalid address specified for SAP announce"" );
        return NULL;
    }

    /* Determine SAP multicast address automatically */
    switch (addr.a.sa_family)
    {
#if defined (HAVE_INET_PTON) || defined (_WIN32)
        case AF_INET6:
        {
            /* See RFC3513 for list ...",176.0,365.0,1.0,1.0,190.0,0,0,4,4,0,0,1,1,0,0,,0,0,6,3,3,session_descriptor_t
2998,137766,sout_AnnounceUnRegister,1,sout_AnnounceUnRegister,"void sout_AnnounceUnRegister (vlc_object_t*,session_descriptor_t*)",stream_output\sap.c,"void sout_AnnounceUnRegister (vlc_object_t *obj, session_descriptor_t *session)
{
    sap_address_t *addr, **paddr;
    session_descriptor_t **psession;

    msg_Dbg (obj, ""removing SAP session"");
    vlc_mutex_lock (&sap_mutex);
    paddr = &sap_addrs;
    for (;;)
    {
        addr = *paddr;
        assert (addr != NULL);

        psession = &addr->first;
        vlc_mutex_lock (&addr->lock);
        while (*psession != NULL)
        {
            if (*psession == session)
                goto found;
            psession = &(*psession)->next;
        }
        vlc_mutex_unlock (&addr->lock);
        paddr = &addr->next;
    }

found:
    *psession = session->next;

    if (addr->first == NULL)
        /* Last session for this address -> unlink the address */
        *paddr = addr->next;
    vlc_mutex_unlock (&sap_mutex);

    if (addr->first == NULL)
    {
        /* Last session for this address -> unlink the address */
        vlc_mutex_unlock (&addr->lock);
        AddressDest...",374.0,422.0,1.0,1.0,49.0,0,0,2,2,0,0,1,1,0,0,,0,0,4,2,2,void
2999,137777,sout_EncoderCreate,1,sout_EncoderCreate,encoder_t sout_EncoderCreate (vlc_object_t*),stream_output\stream_output.c,"encoder_t *sout_EncoderCreate( vlc_object_t *p_this )
{
    return vlc_custom_create( p_this, sizeof( encoder_t ), ""encoder"" );
}",966.0,969.0,1.0,1.0,4.0,0,0,2,2,0,0,1,1,0,0,,0,0,2,1,1,encoder_t
3000,137787,sout_MuxAddStream,1,sout_MuxAddStream,"sout_input_t sout_MuxAddStream (sout_mux_t*,es_format_t*)",stream_output\stream_output.c,"sout_input_t *sout_MuxAddStream( sout_mux_t *p_mux, const es_format_t *p_fmt )
{
    sout_input_t *p_input;

    if( !p_mux->b_add_stream_any_time && !p_mux->b_waiting_stream )
    {
        msg_Err( p_mux, ""cannot add a new stream (unsupported while muxing ""
                        ""to this format). You can try increasing sout-mux-caching value"" );
        return NULL;
    }

    msg_Dbg( p_mux, ""adding a new input"" );

    /* create a new sout input */
    p_input = malloc( sizeof( sout_input_t ) );
    if( !p_input )
        return NULL;

    // FIXME: remove either fmt or p_fmt...
    es_format_Copy( &p_input->fmt, p_fmt );
    p_input->p_fmt = &p_input->fmt;

    p_input->p_fifo = block_FifoNew();
    p_input->p_sys  = NULL;

    TAB_APPEND( p_mux->i_nb_inputs, p_mux->pp_inputs, p_input );
    if( p_mux->pf_addstream( p_mux, p_input ) < 0 )
    {
        msg_Err( p_mux, ""cannot add this stream"" );
        TAB_REMOVE( p_mux->i_nb_inputs, p_mux->pp_inputs, p_input );
        bloc...",446.0,483.0,1.0,1.0,38.0,0,0,2,2,0,0,1,1,0,0,,0,0,4,2,2,sout_input_t
3001,137798,sout_MuxDelete,1,sout_MuxDelete,void sout_MuxDelete (sout_mux_t*),stream_output\stream_output.c,"void sout_MuxDelete( sout_mux_t *p_mux )
{
    if( p_mux->p_module )
    {
        module_unneed( p_mux, p_mux->p_module );
    }
    free( p_mux->psz_mux );

    config_ChainDestroy( p_mux->p_cfg );

    vlc_object_release( p_mux );
}",430.0,441.0,1.0,1.0,12.0,0,0,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
3002,137806,sout_MuxDeleteStream,1,sout_MuxDeleteStream,"void sout_MuxDeleteStream (sout_mux_t*,sout_input_t*)",stream_output\stream_output.c,"void sout_MuxDeleteStream( sout_mux_t *p_mux, sout_input_t *p_input )
{
    int i_index;

    if( p_mux->b_waiting_stream
     && block_FifoCount( p_input->p_fifo ) > 0 )
    {
        /* We stop waiting, and call the muxer for taking care of the data
         * before we remove this es */
        p_mux->b_waiting_stream = false;
        p_mux->pf_mux( p_mux );
    }

    TAB_FIND( p_mux->i_nb_inputs, p_mux->pp_inputs, p_input, i_index );
    if( i_index >= 0 )
    {
        p_mux->pf_delstream( p_mux, p_input );

        /* remove the entry */
        TAB_REMOVE( p_mux->i_nb_inputs, p_mux->pp_inputs, p_input );

        if( p_mux->i_nb_inputs == 0 )
        {
            msg_Warn( p_mux, ""no more input streams for this mux"" );
        }

        block_FifoRelease( p_input->p_fifo );
        es_format_Clean( &p_input->fmt );
        free( p_input );
    }
}",488.0,518.0,1.0,1.0,31.0,0,0,2,2,0,0,1,1,0,0,,0,0,4,2,2,void
3003,137817,sout_MuxGetStream,1,sout_MuxGetStream,"int sout_MuxGetStream (sout_mux_t*,unsigned int,mtime_t*)",stream_output\stream_output.c,"int sout_MuxGetStream( sout_mux_t *p_mux, unsigned i_blocks, mtime_t *pi_dts )
{
    mtime_t i_dts = 0;
    int     i_stream = -1;

    assert( i_blocks > 0 );

    for( int i = 0; i < p_mux->i_nb_inputs; i++ )
    {
        sout_input_t *p_input = p_mux->pp_inputs[i];
        block_t *p_data;

        if( block_FifoCount( p_input->p_fifo ) < i_blocks )
        {
            if( (!p_mux->b_add_stream_any_time) &&
                (p_input->p_fmt->i_cat != SPU_ES ) )
            {
                return -1;
            }
            /* FIXME: SPU muxing */
            continue;
        }

        p_data = block_FifoShow( p_input->p_fifo );
        if( i_stream < 0 || p_data->i_dts < i_dts )
        {
            i_stream = i;
            i_dts    = p_data->i_dts;
        }
    }

    if( pi_dts ) *pi_dts = i_dts;

    return i_stream;
}",562.0,596.0,1.0,1.0,35.0,0,0,3,3,0,0,1,1,0,0,,0,0,6,3,3,int
3004,137831,sout_MuxNew,1,sout_MuxNew,"sout_mux_t sout_MuxNew (sout_instance_t*,char*,sout_access_out_t*)",stream_output\stream_output.c,"sout_mux_t * sout_MuxNew( sout_instance_t *p_sout, const char *psz_mux,
                          sout_access_out_t *p_access )
{
    sout_mux_t *p_mux;
    char       *psz_next;

    p_mux = vlc_custom_create( p_sout, sizeof( *p_mux ), ""mux"" );
    if( p_mux == NULL )
        return NULL;

    p_mux->p_sout = p_sout;
    psz_next = config_ChainCreate( &p_mux->psz_mux, &p_mux->p_cfg, psz_mux );
    free( psz_next );

    p_mux->p_access     = p_access;
    p_mux->pf_control   = NULL;
    p_mux->pf_addstream = NULL;
    p_mux->pf_delstream = NULL;
    p_mux->pf_mux       = NULL;
    p_mux->i_nb_inputs  = 0;
    p_mux->pp_inputs    = NULL;

    p_mux->p_sys        = NULL;
    p_mux->p_module     = NULL;

    p_mux->b_add_stream_any_time = false;
    p_mux->b_waiting_stream = true;
    p_mux->i_add_stream_start = -1;

    p_mux->p_module =
        module_need( p_mux, ""sout mux"", p_mux->psz_mux, true );

    if( p_mux->p_module == NULL )
    {
        FREENULL( p_mux->psz_mux );

      ...",346.0,425.0,1.0,1.0,80.0,0,0,3,3,0,0,1,1,0,0,,0,0,6,3,3,sout_mux_t
3005,137845,sout_MuxSendBuffer,1,sout_MuxSendBuffer,"int sout_MuxSendBuffer (sout_mux_t*,sout_input_t*,block_t*)",stream_output\stream_output.c,"int sout_MuxSendBuffer( sout_mux_t *p_mux, sout_input_t *p_input,
                         block_t *p_buffer )
{
    mtime_t i_dts = p_buffer->i_dts;
    block_FifoPut( p_input->p_fifo, p_buffer );

    if( p_mux->p_sout->i_out_pace_nocontrol )
    {
        mtime_t current_date = mdate();
        if ( current_date > i_dts )
            msg_Warn( p_mux, ""late buffer for mux input (%""PRId64"")"",
                      current_date - i_dts );
    }

    if( p_mux->b_waiting_stream )
    {
        const int64_t i_caching = var_GetInteger( p_mux->p_sout, ""sout-mux-caching"" ) * INT64_C(1000);

        if( p_mux->i_add_stream_start < 0 )
            p_mux->i_add_stream_start = i_dts;

        /* Wait until we have enough data before muxing */
        if( p_mux->i_add_stream_start < 0 ||
            i_dts < p_mux->i_add_stream_start + i_caching )
            return VLC_SUCCESS;
        p_mux->b_waiting_stream = false;
    }
    return p_mux->pf_mux( p_mux );
}",523.0,551.0,1.0,1.0,29.0,0,0,3,3,0,0,1,1,0,0,,0,0,6,3,3,int
3006,137859,sout_MuxFlush,1,sout_MuxFlush,"void sout_MuxFlush (sout_mux_t*,sout_input_t*)",stream_output\stream_output.c,"void sout_MuxFlush( sout_mux_t *p_mux, sout_input_t *p_input )
{
    VLC_UNUSED(p_mux);
    block_FifoEmpty( p_input->p_fifo );
}",553.0,557.0,1.0,1.0,5.0,0,0,2,2,0,0,1,1,0,0,,0,0,4,2,2,void
3007,137870,sout_StreamChainDelete,1,sout_StreamChainDelete,"void sout_StreamChainDelete (sout_stream_t*,sout_stream_t*)",stream_output\stream_output.c,"void sout_StreamChainDelete(sout_stream_t *p_first, sout_stream_t *p_last)
{
    while(p_first != NULL)
    {
        sout_stream_t *p_next = p_first->p_next;

        sout_StreamDelete(p_first);
        if(p_first == p_last)
           break;
        p_first = p_next;
    }
}",762.0,773.0,1.0,1.0,12.0,0,0,2,2,1,0,1,1,0,0,,0,0,4,2,2,void
3008,137881,sout_StreamChainNew,1,sout_StreamChainNew,"sout_stream_t sout_StreamChainNew (sout_instance_t*,char*,sout_stream_t*,sout_stream_t**)",stream_output\stream_output.c,"sout_stream_t *sout_StreamChainNew(sout_instance_t *p_sout, const char *psz_chain,
                                sout_stream_t *p_next, sout_stream_t **pp_last)
{
    if(!psz_chain || !*psz_chain)
    {
        if(pp_last) *pp_last = NULL;
        return p_next;
    }

    char *psz_parser = strdup(psz_chain);
    if(!psz_parser)
        return NULL;

    vlc_array_t cfg, name;
    vlc_array_init(&cfg);
    vlc_array_init(&name);

    /* parse chain */
    while(psz_parser)
    {
        config_chain_t *p_cfg;
        char *psz_name;
        char *psz_rest_chain = config_ChainCreate( &psz_name, &p_cfg, psz_parser );
        free( psz_parser );
        psz_parser = psz_rest_chain;

        vlc_array_append_or_abort(&cfg, p_cfg);
        vlc_array_append_or_abort(&name, psz_name);
    }

    size_t i = vlc_array_count(&name);
    vlc_array_t module;
    vlc_array_init(&module);
    while(i--)
    {
        p_next = sout_StreamNew( p_sout, vlc_array_item_at_index(&name, i),
         ...",829.0,903.0,1.0,1.0,75.0,0,0,4,4,1,0,1,1,0,0,,0,0,8,4,4,sout_stream_t
3009,137898,vlc_sdp_Start,1,vlc_sdp_Start,"int vlc_sdp_Start (vlc_memstream*,vlc_object_t*,char*,sockaddr*,size_t,sockaddr*,size_t)",stream_output\sdp.c,"int vlc_sdp_Start(struct vlc_memstream *restrict stream,
                  vlc_object_t *obj, const char *cfgpref,
                  const struct sockaddr *src, size_t srclen,
                  const struct sockaddr *addr, size_t addrlen)
{
    char connection[MAXSDPADDRESS];
    char *str = NULL;

    size_t cfglen = strlen(cfgpref);
    if (cfglen >= 128)
        return -1;

    char varname[cfglen + sizeof (""description"")];
    char *subvar = varname + cfglen;

    strcpy(varname, cfgpref);

    vlc_memstream_open(stream);
    vlc_memstream_puts(stream, ""v=0\r\n"");

    if (AddressToSDP(addr, addrlen, connection) == NULL)
        goto error;
    {
        const uint_fast64_t now = NTPtime64();
        char hostname[256];

        gethostname(hostname, sizeof (hostname));

        vlc_memstream_printf(stream, ""o=- %""PRIu64"" %""PRIu64"" IN IP%c %s\r\n"",
                             now, now, connection[5], hostname);
    }

    strcpy(subvar, ""name"");
    str = var_GetNonEmptyString(...",146.0,267.0,1.0,20.0,122.0,0,0,6,6,0,0,1,1,0,0,,0,0,14,7,7,int
3010,137956,vlm_MessageAdd,1,vlm_MessageAdd,"vlm_message_t vlm_MessageAdd (vlm_message_t*,vlm_message_t*)",missing.c,"vlm_message_t *vlm_MessageAdd (vlm_message_t *a, vlm_message_t *b)
{
    VLC_UNUSED (a);
    VLC_UNUSED (b);
    vlc_assert_unreachable ();
}",217.0,222.0,1.0,1.0,6.0,0,0,2,2,0,0,1,1,0,0,,0,0,4,2,2,vlm_message_t
3011,137967,vlm_MessageDelete,1,vlm_MessageDelete,void vlm_MessageDelete (vlm_message_t*),missing.c,"void vlm_MessageDelete (vlm_message_t *m)
{
    VLC_UNUSED (m);
    vlc_assert_unreachable ();
}",224.0,228.0,1.0,1.0,5.0,0,0,1,1,1,0,1,1,0,0,,0,0,2,1,1,void
3012,137975,vlm_MessageSimpleNew,1,vlm_MessageSimpleNew,vlm_message_t vlm_MessageSimpleNew (char*),missing.c,"vlm_message_t *vlm_MessageSimpleNew (const char *a)
{
    VLC_UNUSED (a);
    return NULL;
}",230.0,234.0,1.0,1.0,5.0,0,0,2,2,1,0,1,1,0,0,,0,0,2,1,1,vlm_message_t
3013,137984,vlm_MessageNew,1,vlm_MessageNew,"vlm_message_t vlm_MessageNew (char*,char*...)",missing.c,"vlm_message_t *vlm_MessageNew (const char *a, const char *fmt, ...)
{
    VLC_UNUSED (a);
    VLC_UNUSED (fmt);
    return vlm_MessageSimpleNew (a);
}",236.0,241.0,1.0,1.0,6.0,0,0,3,2,0,1,1,1,0,1,,0,0,4,2,2,vlm_message_t
3014,138007,update_New,1,,update_t (vlc_object_t*),missing.c,"update_t *(update_New)(vlc_object_t *obj)
{
    (void) obj;
    return NULL;
}",254.0,258.0,1.0,1.0,5.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,update_t
3015,138118,vlc_modcap_cmp,1,vlc_modcap_cmp,"int vlc_modcap_cmp (void*,void*)",modules\bank.c,"static int vlc_modcap_cmp(const void *a, const void *b)
{
    const vlc_modcap_t *capa = a, *capb = b;
    return strcmp(capa->name, capb->name);
}",59.0,63.0,1.0,1.0,5.0,4,2,6,4,0,0,1,1,0,0,,0,0,4,2,2,int
3016,138140,vlc_modcap_free,1,vlc_modcap_free,void vlc_modcap_free (void*),modules\bank.c,"static void vlc_modcap_free(void *data)
{
    vlc_modcap_t *cap = data;

    free(cap->modv);
    free(cap->name);
    free(cap);
}",65.0,72.0,1.0,1.0,8.0,3,2,5,2,2,0,1,1,0,0,,0,0,2,1,1,void
3017,138159,vlc_module_cmp,1,vlc_module_cmp,"int vlc_module_cmp (void*,void*)",modules\bank.c,"static int vlc_module_cmp (const void *a, const void *b)
{
    const module_t *const *ma = a, *const *mb = b;
    /* Note that qsort() uses _ascending_ order,
     * so the smallest module is the one with the biggest score. */
    return (*mb)->i_score - (*ma)->i_score;
}",74.0,80.0,1.0,1.0,7.0,7,4,6,4,0,0,1,1,0,0,,0,0,4,2,2,int
3018,138183,vlc_modcap_sort,1,vlc_modcap_sort,"void vlc_modcap_sort (void*,VISIT,int)",modules\bank.c,"static void vlc_modcap_sort(const void *node, const VISIT which,
                            const int depth)
{
    vlc_modcap_t *const *cp = node, *cap = *cp;

    if (which != postorder && which != leaf)
        return;

    qsort(cap->modv, cap->modc, sizeof (*cap->modv), vlc_module_cmp);
    (void) depth;
}",82.0,92.0,1.0,1.0,11.0,12,7,12,7,0,0,2,2,0,0,,0,0,6,3,3,void
3019,138242,vlc_module_store,1,vlc_module_store,int vlc_module_store (module_t*),modules\bank.c,"static int vlc_module_store(module_t *mod)
{
    const char *name = module_get_capability(mod);
    vlc_modcap_t *cap = malloc(sizeof (*cap));
    if (unlikely(cap == NULL))
        return -1;

    cap->name = strdup(name);
    cap->modv = NULL;
    cap->modc = 0;

    if (unlikely(cap->name == NULL))
        goto error;

    vlc_modcap_t **cp = tsearch(cap, &modules.caps_tree, vlc_modcap_cmp);
    if (unlikely(cp == NULL))
        goto error;

    if (*cp != cap)
    {
        vlc_modcap_free(cap);
        cap = *cp;
    }

    module_t **modv = realloc(cap->modv, sizeof (*modv) * (cap->modc + 1));
    if (unlikely(modv == NULL))
        return -1;

    cap->modv = modv;
    cap->modv[cap->modc] = mod;
    cap->modc++;
    return 0;
error:
    vlc_modcap_free(cap);
    return -1;
}",107.0,142.0,1.0,1.0,36.0,40,13,36,7,0,4,8,6,0,3,,0,2,2,1,1,int
3020,138373,vlc_plugin_store,1,vlc_plugin_store,void vlc_plugin_store (vlc_plugin_t*),modules\bank.c,"static void vlc_plugin_store(vlc_plugin_t *lib)
{
    /*vlc_assert_locked (&modules.lock);*/

    lib->next = vlc_plugins;
    vlc_plugins = lib;

    for (module_t *m = lib->module; m != NULL; m = m->next)
        vlc_module_store(m);
}",147.0,156.0,1.0,1.0,10.0,6,3,8,4,2,4,2,2,0,0,,0,4,2,1,1,void
3021,138404,module_InitStatic,1,module_InitStatic,vlc_plugin_t module_InitStatic (vlc_plugin_cb),modules\bank.c,"static vlc_plugin_t *module_InitStatic(vlc_plugin_cb entry)
{
    /* Initializes the statically-linked library */
    vlc_plugin_t *lib = vlc_plugin_describe (entry);
    if (unlikely(lib == NULL))
        return NULL;

#ifdef HAVE_DYNAMIC_PLUGINS
    atomic_init(&lib->loaded, true);
    lib->unloadable = false;
#endif
    return lib;
}",161.0,173.0,1.0,1.0,13.0,2,2,6,3,2,1,2,2,0,1,,0,1,2,1,1,vlc_plugin_t
3022,138426,module_InitStaticModules,1,module_InitStaticModules,void module_InitStaticModules (void),modules\bank.c,"static void module_InitStaticModules(void)
{
    if (!vlc_static_modules)
        return;

    for (unsigned i = 0; vlc_static_modules[i]; i++)
    {
        vlc_plugin_t *lib = module_InitStatic(vlc_static_modules[i]);
        if (likely(lib != NULL))
            vlc_plugin_store(lib);
    }
}",183.0,194.0,1.0,1.0,12.0,6,4,10,4,1,5,4,5,2,2,,0,4,2,1,1,void
3023,138463,module_Map,1,module_Map,"int module_Map (vlc_object_t*,vlc_plugin_t*)",modules\bank.c,"int module_Map(vlc_object_t *obj, vlc_plugin_t *plugin)
{
    (void) obj; (void) plugin;
    return 0;
}",560.0,564.0,1.0,1.0,5.0,2,1,2,2,3,0,1,1,0,0,,0,0,4,2,2,int
3024,138477,module_Unmap,1,module_Unmap,void module_Unmap (vlc_plugin_t*),modules\bank.c,"static void module_Unmap(vlc_plugin_t *plugin)
{
    (void) plugin;
}",566.0,569.0,1.0,1.0,4.0,1,1,1,1,1,0,1,1,0,0,,0,0,2,1,1,void
3025,138485,module_InitBank,1,module_InitBank,void module_InitBank (void),modules\bank.c,"void module_InitBank (void)
{
    vlc_mutex_lock (&modules.lock);

    if (modules.usage == 0)
    {
        /* Fills the module bank structure with the core module infos.
         * This is very useful as it will allow us to consider the core
         * library just as another module, and for instance the configuration
         * options of core will be available in the module bank structure just
         * as for every other module. */
        vlc_plugin_t *plugin = module_InitStatic(vlc_entry__core);
        if (likely(plugin != NULL))
            vlc_plugin_store(plugin);
        config_SortConfig ();
    }
    modules.usage++;

    /* We do retain the module bank lock until the plugins are loaded as well.
     * This is ugly, this staged loading approach is needed: LibVLC gets
     * some configuration parameters relevant to loading the plugins from
     * the core (builtin) module. The module bank becomes shared read-only data
     * once it is ready, so we need to fully seria...",578.0,604.0,1.0,1.0,27.0,8,6,8,4,1,7,3,4,1,4,,0,4,2,1,1,void
3026,138520,module_EndBank,1,module_EndBank,void module_EndBank (bool),modules\bank.c,"void module_EndBank (bool b_plugins)
{
    vlc_plugin_t *libs = NULL;
    block_t *caches = NULL;
    void *caps_tree = NULL;

    /* If plugins were _not_ loaded, then the caller still has the bank lock
     * from module_InitBank(). */
    if( b_plugins )
        vlc_mutex_lock (&modules.lock);
    /*else
        vlc_assert_locked (&modules.lock); not for static mutexes :( */

    assert (modules.usage > 0);
    if (--modules.usage == 0)
    {
        config_UnsortConfig ();
        libs = vlc_plugins;
        caches = modules.caches;
        caps_tree = modules.caps_tree;
        vlc_plugins = NULL;
        modules.caches = NULL;
        modules.caps_tree = NULL;
    }
    vlc_mutex_unlock (&modules.lock);

    tdestroy(caps_tree, vlc_modcap_free);

    while (libs != NULL)
    {
        vlc_plugin_t *lib = libs;

        libs = lib->next;
        module_Unmap(lib);
        vlc_plugin_destroy(lib);
    }

    block_ChainRelease(caches);
}",610.0,648.0,1.0,1.0,39.0,26,8,33,8,2,16,4,4,1,5,,0,11,2,1,1,void
3027,138614,module_LoadPlugins,1,module_LoadPlugins,size_t module_LoadPlugins (vlc_object_t*),modules\bank.c,"size_t module_LoadPlugins (vlc_object_t *obj)
{
    /*vlc_assert_locked (&modules.lock); not for static mutexes :( */

    if (modules.usage == 1)
    {
        module_InitStaticModules ();
#ifdef HAVE_DYNAMIC_PLUGINS
        msg_Dbg (obj, ""searching plug-in modules"");
        AllocateAllPlugins (obj);
#endif
        config_UnsortConfig ();
        config_SortConfig ();

        twalk(modules.caps_tree, vlc_modcap_sort);
    }
    vlc_mutex_unlock (&modules.lock);

    size_t count;
    module_t **list = module_list_get (&count);
    module_list_free (list);
    msg_Dbg (obj, ""plug-ins loaded: %zu modules"", count);
    return count;
}",658.0,681.0,1.0,1.0,24.0,7,4,9,4,1,9,2,2,1,6,,0,4,2,1,1,size_t
3028,138654,module_list_free,1,module_list_free,void module_list_free (module_t**),modules\bank.c,"void module_list_free (module_t **list)
{
    free (list);
}",689.0,692.0,1.0,1.0,4.0,0,0,1,1,6,0,1,1,0,0,,0,0,2,1,1,void
3029,138661,module_list_get,1,module_list_get,module_t module_list_get (size_t*),modules\bank.c,"module_t **module_list_get (size_t *n)
{
    module_t **tab = NULL;
    size_t i = 0;

    assert (n != NULL);

    for (vlc_plugin_t *lib = vlc_plugins; lib != NULL; lib = lib->next)
    {
        module_t **nt = realloc(tab, (i + lib->modules_count) * sizeof (*tab));
        if (unlikely(nt == NULL))
        {
            free (tab);
            *n = 0;
            return NULL;
        }

        tab = nt;
        for (module_t *m = lib->module; m != NULL; m = m->next)
            tab[i++] = m;
    }
    *n = i;
    return tab;
}",700.0,723.0,1.0,1.0,24.0,20,8,28,8,2,1,4,6,0,0,,0,1,2,1,1,module_t
3030,138752,module_list_cap,1,module_list_cap,"ssize_t module_list_cap (module_t***,char*)",modules\bank.c,"ssize_t module_list_cap (module_t ***restrict list, const char *name)
{
    const vlc_modcap_t **cp = tfind(&name, &modules.caps_tree, vlc_modcap_cmp);
    if (cp == NULL)
    {
        *list = NULL;
        return 0;
    }

    const vlc_modcap_t *cap = *cp;
    size_t n = cap->modc;
    module_t **tab = vlc_alloc (n, sizeof (*tab));
    *list = tab;
    if (unlikely(tab == NULL))
        return -1;

    memcpy(tab, cap->modv, sizeof (*tab) * n);
    return n;
}",733.0,751.0,1.0,1.0,19.0,22,9,23,8,2,1,3,3,0,0,,0,1,4,2,2,ssize_t
3031,138892,vlc_module_create,1,vlc_module_create,module_t vlc_module_create (vlc_plugin_t*),modules\entry.c,"module_t *vlc_module_create(vlc_plugin_t *plugin)
{
    module_t *module = malloc (sizeof (*module));
    if (module == NULL)
        return NULL;

    /* NOTE XXX: For backward compatibility with preferences UIs, the first
     * module must stay first. That defines under which module, the
     * configuration items of the plugin belong. The order of the following
     * entries is irrelevant. */
    module_t *parent = plugin->module;
    if (parent == NULL)
    {
        module->next = NULL;
        plugin->module = module;
    }
    else
    {
        module->next = parent->next;
        parent->next = module;
    }

    plugin->modules_count++;
    module->plugin = plugin;

    module->psz_shortname = NULL;
    module->psz_longname = NULL;
    module->psz_help = NULL;
    module->pp_shortcuts = NULL;
    module->i_shortcuts = 0;
    module->psz_capability = NULL;
    module->i_score = (parent != NULL) ? parent->i_score : 1;
    module->activate_name = NULL;
    module->deactivat...",41.0,78.0,1.0,1.0,38.0,40,8,40,4,1,17,3,3,0,0,,0,17,2,1,1,module_t
3032,139019,vlc_module_destroy,1,vlc_module_destroy,void vlc_module_destroy (module_t*),modules\entry.c,"void vlc_module_destroy (module_t *module)
{
    while (module != NULL)
    {
        module_t *next = module->next;

        free(module->pp_shortcuts);
        free(module);
        module = next;
    }
}",83.0,93.0,1.0,1.0,11.0,5,3,8,3,1,2,2,2,0,0,,0,2,2,1,1,void
3033,139044,vlc_plugin_create,1,vlc_plugin_create,vlc_plugin_t vlc_plugin_create (void),modules\entry.c,"vlc_plugin_t *vlc_plugin_create(void)
{
    vlc_plugin_t *plugin = malloc(sizeof (*plugin));
    if (unlikely(plugin == NULL))
        return NULL;

    plugin->modules_count = 0;
    plugin->textdomain = NULL;
    plugin->conf.items = NULL;
    plugin->conf.size = 0;
    plugin->conf.count = 0;
    plugin->conf.booleans = 0;
#ifdef HAVE_DYNAMIC_PLUGINS
    plugin->abspath = NULL;
    atomic_init(&plugin->loaded, false);
    plugin->unloadable = true;
    plugin->handle = NULL;
    plugin->abspath = NULL;
    plugin->path = NULL;
#endif
    plugin->module = NULL;

    return plugin;
}",95.0,118.0,1.0,1.0,24.0,22,6,16,2,1,7,2,2,0,0,,0,7,2,1,1,vlc_plugin_t
3034,139109,vlc_plugin_destroy,1,vlc_plugin_destroy,void vlc_plugin_destroy (vlc_plugin_t*),modules\entry.c,"void vlc_plugin_destroy(vlc_plugin_t *plugin)
{
    assert(plugin != NULL);
#ifdef HAVE_DYNAMIC_PLUGINS
    assert(!plugin->unloadable || !atomic_load(&plugin->loaded));
#endif

    if (plugin->module != NULL)
        vlc_module_destroy(plugin->module);

    config_Free(plugin->conf.items, plugin->conf.size);
#ifdef HAVE_DYNAMIC_PLUGINS
    free(plugin->abspath);
    free(plugin->path);
#endif
    free(plugin);
}",125.0,141.0,1.0,1.0,17.0,8,3,8,2,2,6,2,2,1,2,,0,4,2,1,1,void
3035,139142,vlc_config_create,1,vlc_config_create,"module_config_t vlc_config_create (vlc_plugin_t*,int)",modules\entry.c,"static module_config_t *vlc_config_create(vlc_plugin_t *plugin, int type)
{
    unsigned confsize = plugin->conf.size;
    module_config_t *tab = plugin->conf.items;

    if ((confsize & 0xf) == 0)
    {
        tab = realloc_or_free (tab, (confsize + 17) * sizeof (*tab));
        if (tab == NULL)
            return NULL;

        plugin->conf.items = tab;
    }

    memset (tab + confsize, 0, sizeof (tab[confsize]));
    tab += confsize;
    tab->owner = plugin;

    if (IsConfigIntegerType (type))
    {
        tab->max.i = INT64_MAX;
        tab->min.i = INT64_MIN;
    }
    else if( IsConfigFloatType (type))
    {
        tab->max.f = FLT_MAX;
        tab->min.f = -FLT_MAX;
    }
    tab->i_type = type;

    if (CONFIG_ITEM(type))
    {
        plugin->conf.count++;
        if (type == CONFIG_ITEM_BOOL)
            plugin->conf.booleans++;
    }
    plugin->conf.size++;

    return tab;
}",143.0,182.0,1.0,8.0,40.0,43,13,38,9,1,6,6,8,0,0,,0,6,4,2,2,module_config_t
3036,139296,vlc_plugin_desc_cb,1,vlc_plugin_desc_cb,"int vlc_plugin_desc_cb (void*,void*,int...)",modules\entry.c,"static int vlc_plugin_desc_cb(void *ctx, void *tgt, int propid, ...)
{
    vlc_plugin_t *plugin = ctx;
    module_t *module = tgt;
    module_config_t *item = tgt;
    va_list ap;
    int ret = 0;

    va_start (ap, propid);
    switch (propid)
    {
        case VLC_MODULE_CREATE:
        {
            module_t *super = plugin->module;
            module_t *submodule = vlc_module_create(plugin);
            if (unlikely(submodule == NULL))
            {
                ret = -1;
                break;
            }

            *(va_arg (ap, module_t **)) = submodule;
            if (super == NULL)
                break;

            /* Inheritance. Ugly!! */
            submodule->pp_shortcuts = xmalloc (sizeof ( *submodule->pp_shortcuts ));
            submodule->pp_shortcuts[0] = super->pp_shortcuts[0];
            submodule->i_shortcuts = 1; /* object name */

            submodule->psz_shortname = super->psz_shortname;
            submodule->psz_longname = super->psz_longname;...",190.0,460.0,1.0,42.0,271.0,130,17,150,55,0,25,43,20,0,2,,0,25,6,3,3,int
3037,139920,vlc_plugin_describe,1,vlc_plugin_describe,vlc_plugin_t vlc_plugin_describe (vlc_plugin_cb),modules\entry.c,"vlc_plugin_t *vlc_plugin_describe(vlc_plugin_cb entry)
{
    vlc_plugin_t *plugin = vlc_plugin_create();
    if (unlikely(plugin == NULL))
        return NULL;

    if (entry(vlc_plugin_desc_cb, plugin) != 0)
    {
        vlc_plugin_destroy(plugin); /* partially initialized plug-in... */
        plugin = NULL;
    }
    return plugin;
}",467.0,479.0,1.0,1.0,13.0,4,3,9,2,1,2,3,3,0,2,,0,1,2,1,1,vlc_plugin_t
3038,139954,vlc_plugin_symbol_compare,1,vlc_plugin_symbol_compare,"int vlc_plugin_symbol_compare (void*,void*)",modules\entry.c,"static int vlc_plugin_symbol_compare(const void *a, const void *b)
{
    const struct vlc_plugin_symbol *sa = a , *sb = b;

    return strcmp(sa->name, sb->name);
}",487.0,492.0,1.0,1.0,6.0,4,2,6,4,0,2,1,1,0,0,,0,2,4,2,2,int
3039,139976,vlc_plugin_gpa_cb,1,vlc_plugin_gpa_cb,"int vlc_plugin_gpa_cb (void*,void*,int...)",modules\entry.c,"static int vlc_plugin_gpa_cb(void *ctx, void *tgt, int propid, ...)
{
    void **rootp = ctx;
    const char *name;
    void *addr;

    (void) tgt;

    switch (propid)
    {
        case VLC_MODULE_CB_OPEN:
        case VLC_MODULE_CB_CLOSE:
        case VLC_CONFIG_LIST_CB:
        {
            va_list ap;

            va_start(ap, propid);
            name = va_arg(ap, const char *);
            addr = va_arg(ap, void *);
            va_end (ap);
            break;
        }
        default:
            return 0;
    }

    struct vlc_plugin_symbol *sym = malloc(sizeof (*sym));

    sym->name = name;
    sym->addr = addr;

    struct vlc_plugin_symbol **symp = tsearch(sym, rootp,
                                              vlc_plugin_symbol_compare);
    if (unlikely(symp == NULL))
    {   /* Memory error */
        free(sym);
        return -1;
    }

    if (*symp != sym)
    {   /* Duplicate symbol */
        assert((*symp)->addr == sym->addr);
        free(sym);
    }
    r...",500.0,545.0,1.0,1.0,46.0,18,8,27,13,0,3,5,4,0,0,,0,3,6,3,3,int
3040,140068,vlc_plugin_get_symbols,1,vlc_plugin_get_symbols,void* vlc_plugin_get_symbols (vlc_plugin_cb),modules\entry.c,"static void *vlc_plugin_get_symbols(vlc_plugin_cb entry)
{
    void *root = NULL;

    if (entry(vlc_plugin_gpa_cb, &root))
    {
        tdestroy(root, free);
        return NULL;
    }

    return root;
}",557.0,568.0,1.0,1.0,12.0,2,2,7,3,1,0,2,2,0,0,,0,0,2,1,1,void*
3041,140090,vlc_plugin_free_symbols,1,vlc_plugin_free_symbols,void vlc_plugin_free_symbols (void*),modules\entry.c,"static void vlc_plugin_free_symbols(void *root)
{
    tdestroy(root, free);
}",570.0,573.0,1.0,1.0,4.0,0,0,2,2,1,0,1,1,0,0,,0,0,2,1,1,void
3042,140098,vlc_plugin_get_symbol,1,vlc_plugin_get_symbol,"int vlc_plugin_get_symbol (void*,char*,void**)",modules\entry.c,"static int vlc_plugin_get_symbol(void *root, const char *name,
                                 void **restrict addrp)
{
    if (name == NULL)
    {   /* TODO: use this; do not define ""NULL"" as a name for NULL? */
        *addrp = NULL;
        return 0;
    }

    const struct vlc_plugin_symbol **symp = tfind(&name, &root,
                                                  vlc_plugin_symbol_compare);

    if (symp == NULL)
        return -1;

    *addrp = (*symp)->addr;
    return 0;
}",575.0,592.0,1.0,1.0,18.0,12,6,11,5,3,0,3,3,0,0,,0,0,6,3,3,int
3043,140142,vlc_plugin_resolve,1,vlc_plugin_resolve,"int vlc_plugin_resolve (vlc_plugin_t*,vlc_plugin_cb)",modules\entry.c,"int vlc_plugin_resolve(vlc_plugin_t *plugin, vlc_plugin_cb entry)
{
    void *syms = vlc_plugin_get_symbols(entry);
    int ret = -1;

    /* Resolve modules activate/deactivate callbacks */
    for (module_t *module = plugin->module;
         module != NULL;
         module = module->next)
    {
        if (vlc_plugin_get_symbol(syms, module->activate_name,
                                  &module->pf_activate)
         || vlc_plugin_get_symbol(syms, module->deactivate_name,
                                  &module->pf_deactivate))
            goto error;
    }

    /* Resolve configuration callbacks */
    for (size_t i = 0; i < plugin->conf.size; i++)
    {
        module_config_t *item = plugin->conf.items + i;
        void *cb;

        if (item->list_cb_name == NULL)
            continue;
        if (vlc_plugin_get_symbol(syms, item->list_cb_name, &cb))
            goto error;

        if (IsConfigIntegerType (item->i_type))
            item->list.i_cb = cb;
        else
   ...",594.0,633.0,1.0,12.0,40.0,33,11,32,10,0,8,10,11,4,5,,0,7,4,2,2,int
3044,140321,module_provides,1,module_provides,"bool module_provides (module_t*,char*)",modules\modules.c,"bool module_provides (const module_t *m, const char *cap)
{
    return !strcmp (module_get_capability (m), cap);
}",53.0,56.0,1.0,1.0,4.0,1,1,2,2,0,1,1,1,0,1,,0,0,4,2,2,bool
3045,140333,module_get_object,1,module_get_object,const char* module_get_object (module_t*),modules\modules.c,"const char *module_get_object( const module_t *m )
{
    if (unlikely(m->i_shortcuts == 0))
        return ""unnamed"";
    return m->pp_shortcuts[0];
}",64.0,69.0,1.0,1.0,6.0,4,3,2,1,8,2,2,2,1,0,,0,2,2,1,1,const char*
3046,140354,module_get_name,1,module_get_name,"const char* module_get_name (module_t*,bool)",modules\modules.c,"const char *module_get_name( const module_t *m, bool long_name )
{
    if( long_name && ( m->psz_longname != NULL) )
        return m->psz_longname;

    if (m->psz_shortname != NULL)
        return m->psz_shortname;
    return module_get_object (m);
}",78.0,86.0,1.0,1.0,9.0,7,3,8,3,5,5,3,3,2,1,,0,4,4,2,2,const char*
3047,140387,module_get_help,1,module_get_help,const char* module_get_help (module_t*),modules\modules.c,"const char *module_get_help( const module_t *m )
{
    return m->psz_help;
}",94.0,97.0,1.0,1.0,4.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,const char*
3048,140396,module_get_capability,1,module_get_capability,const char* module_get_capability (module_t*),modules\modules.c,"const char *module_get_capability (const module_t *m)
{
    return (m->psz_capability != NULL) ? m->psz_capability : ""none"";
}",105.0,108.0,1.0,1.0,4.0,4,3,3,2,2,2,1,1,0,0,,0,2,2,1,1,const char*
3049,140412,module_get_score,1,module_get_score,int module_get_score (module_t*),modules\modules.c,"int module_get_score( const module_t *m )
{
    return m->i_score;
}",116.0,119.0,1.0,1.0,4.0,1,1,1,1,1,1,1,1,0,0,,0,1,2,1,1,int
3050,140421,module_gettext,1,module_gettext,"const char* module_gettext (module_t*,char*)",modules\modules.c,"const char *module_gettext (const module_t *m, const char *str)
{
    if (unlikely(str == NULL || *str == '\0'))
        return """";
#ifdef ENABLE_NLS
    const char *domain = m->plugin->textdomain;
    return dgettext ((domain != NULL) ? domain : PACKAGE_NAME, str);
#else
    (void)m;
    return str;
#endif
}",128.0,139.0,1.0,1.0,12.0,5,4,5,3,7,0,2,2,0,0,,0,0,4,2,2,const char*
3051,140445,module_start,1,module_start,"int module_start (vlc_object_t*,module_t*)",modules\modules.c,"int module_start (vlc_object_t *obj, const module_t *m)
{
   int (*activate) (vlc_object_t *) = m->pf_activate;

   return (activate != NULL) ? activate (obj) : VLC_SUCCESS;
}",142.0,147.0,1.0,1.0,6.0,2,2,4,4,1,0,1,1,0,0,,0,0,4,2,2,int
3052,140449,activate,1,module_start.activate,int module_start.activate (vlc_object_t*),modules\modules.c,int (*activate) (vlc_object_t *) = m->pf_activate;,144.0,144.0,8.0,52.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
3053,140464,module_stop,1,module_stop,"void module_stop (vlc_object_t*,module_t*)",modules\modules.c,"void module_stop (vlc_object_t *obj, const module_t *m)
{
   void (*deactivate) (vlc_object_t *) = m->pf_deactivate;

    if (deactivate != NULL)
        deactivate (obj);
}",150.0,156.0,1.0,1.0,7.0,1,1,3,3,2,0,2,2,0,0,,0,0,4,2,2,void
3054,140468,deactivate,1,module_stop.deactivate,void module_stop.deactivate (vlc_object_t*),modules\modules.c,void (*deactivate) (vlc_object_t *) = m->pf_deactivate;,152.0,152.0,9.0,57.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
3055,140482,module_match_name,1,module_match_name,"bool module_match_name (module_t*,char*)",modules\modules.c,"static bool module_match_name (const module_t *m, const char *name)
{
     /* Plugins with zero score must be matched explicitly. */
     if (!strcasecmp (""any"", name))
         return m->i_score > 0;

     for (unsigned i = 0; i < m->i_shortcuts; i++)
          if (!strcasecmp (m->pp_shortcuts[i], name))
              return true;
     return false;
}",158.0,168.0,1.0,1.0,11.0,6,5,6,4,1,2,3,3,1,0,,0,2,4,2,2,bool
3056,140527,module_load,1,module_load,"int module_load (vlc_object_t*,module_t*,vlc_activate_t,va_list)",modules\modules.c,"static int module_load (vlc_object_t *obj, module_t *m,
                        vlc_activate_t init, va_list args)
{
    int ret = VLC_SUCCESS;

    if (module_Map(obj, m->plugin))
        return VLC_EGENERIC;

    if (m->pf_activate != NULL)
    {
        va_list ap;

        va_copy (ap, args);
        ret = init (m->pf_activate, ap);
        va_end (ap);
    }

    if (ret != VLC_SUCCESS)
        vlc_objres_clear(obj);

    return ret;
}",170.0,191.0,1.0,1.0,22.0,7,3,17,8,2,5,4,4,3,2,,0,4,8,4,4,int
3057,140577,vlc_module_load,1,vlc_module_load,"module_t vlc_module_load (vlc_object_t*,char*,char*,bool,vlc_activate_t...)",modules\modules.c,"module_t *vlc_module_load(vlc_object_t *obj, const char *capability,
                          const char *name, bool strict,
                          vlc_activate_t probe, ...)
{
    char *var = NULL;

    if (name == NULL || name[0] == '\0')
        name = ""any"";

    /* Deal with variables */
    if (name[0] == '$')
    {
        var = var_InheritString (obj, name + 1);
        name = (var != NULL) ? var : ""any"";
    }

    /* Find matching modules */
    module_t **mods;
    ssize_t total = module_list_cap (&mods, capability);

    msg_Dbg (obj, ""looking for %s module matching \""%s\"": %zd candidates"",
             capability, name, total);
    if (total <= 0)
    {
        module_list_free (mods);
        msg_Dbg (obj, ""no %s modules"", capability);
        return NULL;
    }

    module_t *module = NULL;
    const bool b_force_backup = obj->obj.force; /* FIXME: remove this */
    va_list args;

    va_start(args, probe);
    while (*name)
    {
        char buf[32];
        siz...",214.0,327.0,1.0,8.0,114.0,64,18,116,21,5,11,24,32,2,11,,0,6,10,5,5,module_t
3058,140895,vlc_module_unload,1,vlc_module_unload,"void vlc_module_unload (vlc_object_t*,module_t*,vlc_deactivate_t...)",modules\modules.c,"void vlc_module_unload(vlc_object_t *obj, module_t *module,
                       vlc_deactivate_t deinit, ...)
{
    if (module->pf_deactivate != NULL)
    {
        va_list ap;

        va_start(ap, deinit);
        deinit(module->pf_deactivate, ap);
        va_end(ap);
    }

    vlc_objres_clear(obj);
}",335.0,348.0,1.0,1.0,14.0,3,2,8,5,4,3,2,2,1,1,,0,2,6,3,3,void
3059,140922,generic_start,1,generic_start,"int generic_start (void*,va_list)",modules\modules.c,"static int generic_start(void *func, va_list ap)
{
    vlc_object_t *obj = va_arg(ap, vlc_object_t *);
    int (*activate)(vlc_object_t *) = func;

    return activate(obj);
}",351.0,357.0,1.0,1.0,7.0,0,0,1,1,0,0,1,1,0,0,,0,0,4,2,2,int
3060,140927,activate,1,generic_start.activate,int generic_start.activate (vlc_object_t*),modules\modules.c,int (*activate)(vlc_object_t *) = func;,354.0,354.0,9.0,42.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
3061,140937,generic_stop,1,generic_stop,"void generic_stop (void*,va_list)",modules\modules.c,"static void generic_stop(void *func, va_list ap)
{
    vlc_object_t *obj = va_arg(ap, vlc_object_t *);
    void (*deactivate)(vlc_object_t *) = func;

    deactivate(obj);
}",359.0,365.0,1.0,1.0,7.0,0,0,1,1,0,0,1,1,0,0,,0,0,4,2,2,void
3062,140942,deactivate,1,generic_stop.deactivate,void generic_stop.deactivate (vlc_object_t*),modules\modules.c,void (*deactivate)(vlc_object_t *) = func;,362.0,362.0,10.0,45.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
3063,140951,module_need,1,module_need,"module_t module_need (vlc_object_t*,char*,char*,bool)",modules\modules.c,"module_t *module_need(vlc_object_t *obj, const char *cap, const char *name,
                      bool strict)
{
    return vlc_module_load(obj, cap, name, strict, generic_start, obj);
}",368.0,372.0,1.0,1.0,5.0,0,0,5,4,30,1,1,1,0,1,,0,0,8,4,4,module_t
3064,140967,module_unneed,1,module_unneed,"void module_unneed (vlc_object_t*,module_t*)",modules\modules.c,"void module_unneed(vlc_object_t *obj, module_t *module)
{
    msg_Dbg(obj, ""removing module \""%s\"""", module_get_object(module));
    vlc_module_unload(obj, module, generic_stop, obj);
}",375.0,379.0,1.0,1.0,5.0,0,0,5,2,30,2,1,1,0,2,,0,0,4,2,2,void
3065,140983,module_find,1,module_find,module_t module_find (char*),modules\modules.c,"module_t *module_find (const char *name)
{
    size_t count;
    module_t **list = module_list_get (&count);

    assert (name != NULL);

    for (size_t i = 0; i < count; i++)
    {
        module_t *module = list[i];

        if (unlikely(module->i_shortcuts == 0))
            continue;
        if (!strcmp (module->pp_shortcuts[0], name))
        {
            module_list_free (list);
            return module;
        }
    }
    module_list_free (list);
    return NULL;
}",387.0,408.0,1.0,1.0,22.0,12,8,17,6,1,5,5,6,2,3,,0,3,2,1,1,module_t
3066,141044,module_exists,1,module_exists,bool module_exists (char*),modules\modules.c,"bool module_exists (const char * psz_name)
{
    return module_find (psz_name) != NULL;
}",416.0,419.0,1.0,1.0,4.0,1,1,2,2,0,1,1,1,0,1,,0,0,2,1,1,bool
3067,141054,module_config_get,1,module_config_get,"module_config_t module_config_get (module_t*,unsigned*)",modules\modules.c,"module_config_t *module_config_get( const module_t *module, unsigned *restrict psize )
{
    const vlc_plugin_t *plugin = module->plugin;

    if (plugin->module != module)
    {   /* For backward compatibility, pretend non-first modules have no
         * configuration items. */
        *psize = 0;
        return NULL;
    }

    unsigned i,j;
    size_t size = plugin->conf.size;
    module_config_t *config = vlc_alloc( size, sizeof( *config ) );

    assert( psize != NULL );
    *psize = 0;

    if( !config )
        return NULL;

    for( i = 0, j = 0; i < size; i++ )
    {
        const module_config_t *item = plugin->conf.items + i;
        if( item->b_internal /* internal option */
         || item->b_removed /* removed option */ )
            continue;

        memcpy( config + j, item, sizeof( *config ) );
        j++;
    }
    *psize = j;

    return config;
}",428.0,462.0,1.0,1.0,35.0,33,12,33,9,0,4,6,6,1,0,,0,4,4,2,2,module_config_t
3068,141162,module_config_free,1,module_config_free,void module_config_free (module_config_t*),modules\modules.c,"void module_config_free( module_config_t *config )
{
    free( config );
}",470.0,473.0,1.0,1.0,4.0,0,0,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
3069,141199,vlc_plugin_cb,1,vlc_plugin_cb,"int vlc_plugin_cb (int,void*)",modules\modules.h,"typedef int (*vlc_plugin_cb) (int (*)(void *, void *, int, ...), void *);",72.0,72.0,13.0,72.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
3070,141205,vlc_entry__core,1,vlc_entry__core,"int vlc_entry__core (int,void*)",modules\modules.h,"int vlc_entry__core (int (*)(void *, void *, int, ...), void *);",75.0,75.0,5.0,63.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
3071,141283,vlc_bindtextdomain,1,vlc_bindtextdomain,int vlc_bindtextdomain (char*),modules\textdomain.c,"int vlc_bindtextdomain (const char *domain)
{
#if defined (ENABLE_NLS)
    /* Specify where to find the locales for current domain */
    char *datadir = config_GetDataDir();
    if (unlikely(datadir == NULL))
        return -1;

# if !defined (__APPLE__) && !defined (_WIN32) && !defined(__OS2__)
    const char *fmt = ""%s/../locale"";
# else
    const char *fmt = ""%s""DIR_SEP""locale"";
# endif
    char *upath;
    int ret = asprintf(&upath, fmt, datadir);
    free (datadir);
    if (unlikely(ret == -1))
        return -1;

    char *lpath = ToLocaleDup (upath);
    if (lpath == NULL || bindtextdomain (domain, lpath) == NULL)
    {
        free (lpath);
        fprintf (stderr, ""%s: text domain not found in %s\n"", domain, upath);
        free (upath);
        return -1;
    }
    free (lpath);
    free (upath);

    /* LibVLC wants all messages in UTF-8.
     * Unfortunately, we cannot ask UTF-8 for strerror_r(), strsignal_r()
     * and other functions that are not part of our text dom...",33.0,85.0,1.0,1.0,53.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
3072,141288,module_Load,1,module_Load,"int module_Load (vlc_object_t*,char*,module_handle_t*,ANY)",win32\plugin.c,"int module_Load( vlc_object_t *p_this, const char *psz_file,
                 module_handle_t *p_handle, bool lazy )
{
    wchar_t *wfile = ToWide (psz_file);
    if (wfile == NULL)
        return -1;

    module_handle_t handle = NULL;
#if !VLC_WINSTORE_APP
    DWORD mode;
    if (SetThreadErrorMode (SEM_FAILCRITICALERRORS, &mode) != 0)
    {
        handle = LoadLibraryExW (wfile, NULL, LoadLibraryFlags );
        SetThreadErrorMode (mode, NULL);
    }
#else
    handle = LoadPackagedLibrary( wfile, 0 );
#endif
    free (wfile);

    if( handle == NULL )
    {
        char *psz_err = GetWindowsError();
        msg_Warn( p_this, ""cannot load module `%s' (%s)"", psz_file, psz_err );
        free( psz_err );
        return -1;
    }

    *p_handle = handle;
    (void) lazy;
    return 0;
}",94.0,125.0,1.0,1.0,32.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,int
3073,141296,module_Lookup,1,module_Lookup,"void* module_Lookup (module_handle_t,char*)",win32\plugin.c,"void *module_Lookup( module_handle_t handle, const char *psz_function )
{
    return (void *)GetProcAddress( handle, (char *)psz_function );
}",132.0,135.0,1.0,1.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void*
3074,141302,module_Unload,1,module_Unload,void module_Unload (module_handle_t),win32\plugin.c,"void module_Unload( module_handle_t handle )
{
    FreeLibrary( handle );
}",127.0,130.0,1.0,1.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
3075,141307,vlc_cache_load,1,vlc_cache_load,"vlc_plugin_t* vlc_cache_load (vlc_object_t*,char*,block_t**)",modules\modules.h,"vlc_plugin_t *vlc_cache_load(vlc_object_t *, const char *, block_t **);",130.0,130.0,14.0,70.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,vlc_plugin_t*
3076,141314,vlc_cache_lookup,1,vlc_cache_lookup,"vlc_plugin_t* vlc_cache_lookup (vlc_plugin_t**,char*)",modules\modules.h,"vlc_plugin_t *vlc_cache_lookup(vlc_plugin_t **, const char *relpath);",131.0,131.0,14.0,68.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,vlc_plugin_t*
3077,141320,CacheSave,1,CacheSave,"void CacheSave (vlc_object_t*,char*,vlc_plugin_t**,ANY)",modules\modules.h,"void CacheSave(vlc_object_t *, const char *, vlc_plugin_t *const *, size_t);",133.0,133.0,6.0,75.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,void
3078,141353,vlc_gettext,1,vlc_gettext,char* vlc_gettext (char*),modules\textdomain.c,"char *vlc_gettext (const char *msgid)
{
#ifdef ENABLE_NLS
    if (likely(*msgid))
        return dgettext (PACKAGE_NAME, msgid);
#endif
    return (char *)msgid;
}",90.0,97.0,1.0,1.0,8.0,1,1,1,1,10,0,1,1,0,0,,0,0,2,1,1,char*
3079,141362,vlc_ngettext,1,vlc_ngettext,"char* vlc_ngettext (char*,char*,long unsigned)",modules\textdomain.c,"char *vlc_ngettext (const char *msgid, const char *plural, unsigned long n)
{
#ifdef ENABLE_NLS
    if (likely(*msgid))
        return dngettext (PACKAGE_NAME, msgid, plural, n);
#endif
    return (char *)((n == 1) ? msgid : plural);
}",99.0,106.0,1.0,1.0,8.0,3,3,3,3,0,0,1,1,0,0,,0,0,6,3,3,char*
3080,141401,vlc_getnameinfo,1,vlc_getnameinfo,"int vlc_getnameinfo (sockaddr*,int,char*,int,int*,int)",network\getaddrinfo.c,"int vlc_getnameinfo( const struct sockaddr *sa, int salen,
                     char *host, int hostlen, int *portnum, int flags )
{
    char psz_servbuf[6], *psz_serv;
    int i_servlen, i_val;

    flags |= NI_NUMERICSERV;
    if( portnum != NULL )
    {
        psz_serv = psz_servbuf;
        i_servlen = sizeof( psz_servbuf );
    }
    else
    {
        psz_serv = NULL;
        i_servlen = 0;
    }

    i_val = getnameinfo(sa, salen, host, hostlen, psz_serv, i_servlen, flags);

    if( portnum != NULL )
        *portnum = atoi( psz_serv );

    return i_val;
}",40.0,64.0,1.0,1.0,25.0,8,4,21,12,1,1,3,3,0,1,,0,1,12,6,6,int
3081,141460,vlc_getaddrinfo,1,vlc_getaddrinfo,"int vlc_getaddrinfo (char*,unsigned,addrinfo*,addrinfo**)",network\getaddrinfo.c,"int vlc_getaddrinfo (const char *node, unsigned port,
                     const struct addrinfo *hints, struct addrinfo **res)
{
    char hostbuf[NI_MAXHOST], portbuf[6], *servname;

    /*
     * In VLC, we always use port number as integer rather than strings
     * for historical reasons (and portability).
     */
    if (port != 0)
    {
        if (port > 65535)
            return EAI_SERVICE;
        /* cannot overflow */
        snprintf (portbuf, sizeof (portbuf), ""%u"", port);
        servname = portbuf;
    }
    else
        servname = NULL;

    /*
     * VLC extensions :
     * - accept the empty string as unspecified host (i.e. NULL)
     * - ignore square brackets (for IPv6 numerals)
     */
    if (node != NULL)
    {
        if (node[0] == '[')
        {
            size_t len = strlen (node + 1);
            if ((len <= sizeof (hostbuf)) && (node[len] == ']'))
            {
                assert (len > 0);
                memcpy (hostbuf, node + 1, len - 1);
     ...",78.0,121.0,1.0,1.0,44.0,24,10,32,10,5,1,7,12,0,1,,0,0,8,4,4,int
3082,141585,AuthGetParam,1,AuthGetParam,"char* AuthGetParam (char*,char*)",network\http_auth.c,"static char *AuthGetParam( const char *psz_header, const char *psz_param )
{
    char psz_what[strlen(psz_param)+3];
    sprintf( psz_what, ""%s=\"""", psz_param );
    psz_header = strstr( psz_header, psz_what );
    if ( psz_header )
    {
        const char *psz_end;
        psz_header += strlen( psz_what );
        psz_end = strchr( psz_header, '""' );
        if ( !psz_end ) /* Invalid since we should have a closing quote */
            return strdup( psz_header );
        return strndup( psz_header, psz_end - psz_header );
    }
    else
    {
        return NULL;
    }
}",46.0,64.0,1.0,1.0,19.0,5,4,15,4,4,0,3,4,0,0,,0,0,4,2,2,char*
3083,141631,AuthGetParamNoQuotes,1,AuthGetParamNoQuotes,"char* AuthGetParamNoQuotes (char*,char*)",network\http_auth.c,"static char *AuthGetParamNoQuotes( const char *psz_header, const char *psz_param )
{
    char psz_what[strlen(psz_param)+2];
    sprintf( psz_what, ""%s="", psz_param );
    psz_header = strstr( psz_header, psz_what );
    if ( psz_header )
    {
        const char *psz_end;
        psz_header += strlen( psz_what );
        psz_end = strchr( psz_header, ',' );
        /* XXX: Do we need to filter out trailing space between the value and
         * the comma/end of line? */
        if ( !psz_end ) /* Can be valid if this is the last parameter */
            return strdup( psz_header );
        return strndup( psz_header, psz_end - psz_header );
    }
    else
    {
        return NULL;
    }
}",66.0,86.0,1.0,1.0,21.0,5,4,15,4,2,0,3,4,0,0,,0,0,4,2,2,char*
3084,141677,GenerateCnonce,1,GenerateCnonce,char* GenerateCnonce (),network\http_auth.c,"static char *GenerateCnonce()
{
    char ps_random[32];
    struct md5_s md5;

    vlc_rand_bytes( ps_random, sizeof( ps_random ) );

    InitMD5( &md5 );
    AddMD5( &md5, ps_random, sizeof( ps_random ) );
    EndMD5( &md5 );

    return psz_md5_hash( &md5 );
}",88.0,100.0,1.0,1.0,13.0,6,2,8,2,1,4,1,1,0,4,,0,0,0,0,0,char*
3085,141703,AuthDigest,1,AuthDigest,"char* AuthDigest (vlc_object_t*,vlc_http_auth_t*,char*,char*,char*,char*)",network\http_auth.c,"static char *AuthDigest( vlc_object_t *p_this, vlc_http_auth_t *p_auth,
                         const char *psz_method, const char *psz_path,
                         const char *psz_username, const char *psz_password )
{
    char *psz_HA1 = NULL;
    char *psz_HA2 = NULL;
    char *psz_ent = NULL;
    char *psz_result = NULL;
    char psz_inonce[9];
    struct md5_s md5;
    struct md5_s ent;

    if ( p_auth->psz_realm == NULL )
    {
        msg_Warn( p_this, ""Digest Authentication: ""
                  ""Mandatory 'realm' value not available"" );
        goto error;
    }

    /* H(A1) */
    if ( p_auth->psz_HA1 )
    {
        psz_HA1 = strdup( p_auth->psz_HA1 );
        if ( psz_HA1 == NULL )
            goto error;
    }
    else
    {
        InitMD5( &md5 );
        AddMD5( &md5, psz_username, strlen( psz_username ) );
        AddMD5( &md5, "":"", 1 );
        AddMD5( &md5, p_auth->psz_realm, strlen( p_auth->psz_realm ) );
        AddMD5( &md5, "":"", 1 );
        AddMD5( &md5, ...",102.0,223.0,1.0,1.0,122.0,61,8,77,12,2,23,14,12,0,23,,0,0,12,6,6,char*
3086,142104,vlc_http_auth_ParseWwwAuthenticateHeader,1,vlc_http_auth_ParseWwwAuthenticateHeader,"void vlc_http_auth_ParseWwwAuthenticateHeader (vlc_object_t*,vlc_http_auth_t*,char*)",network\http_auth.c,"void vlc_http_auth_ParseWwwAuthenticateHeader(
        vlc_object_t *p_this, vlc_http_auth_t *p_auth,
        const char *psz_header )
{
    static const char psz_basic_prefix[] = ""Basic "";
    static const char psz_digest_prefix[] = ""Digest "";

    /* FIXME: multiple auth methods can be listed (comma separated) */

    if ( strncasecmp( psz_header, psz_basic_prefix,
                      sizeof( psz_basic_prefix ) - 1 ) == 0 )
    {
        /* 2 Basic Authentication Scheme */
        msg_Dbg( p_this, ""Using Basic Authentication"" );
        psz_header += sizeof( psz_basic_prefix ) - 1;
        p_auth->psz_realm = AuthGetParam( psz_header, ""realm"" );
        if ( p_auth->psz_realm == NULL )
            msg_Warn( p_this, ""Basic Authentication: ""
                      ""Mandatory 'realm' parameter is missing"" );
    }
    else if ( strncasecmp( psz_header, psz_digest_prefix,
                           sizeof( psz_digest_prefix ) - 1 ) == 0 )
    {
        /* 3 Digest Access Authenticati...",231.0,302.0,1.0,1.0,72.0,12,6,13,6,0,1,3,4,0,1,,0,1,6,3,3,void
3087,142304,vlc_http_auth_ParseAuthenticationInfoHeader,1,vlc_http_auth_ParseAuthenticationInfoHeader,"int vlc_http_auth_ParseAuthenticationInfoHeader (vlc_object_t*,vlc_http_auth_t*,char*,char*,char*,char*,char*)",network\http_auth.c,"int vlc_http_auth_ParseAuthenticationInfoHeader(
        vlc_object_t *p_this, vlc_http_auth_t *p_auth,
        const char *psz_header, const char *psz_method, const char *psz_path,
        const char *psz_username, const char *psz_password )
{
    char *psz_nextnonce = AuthGetParam( psz_header, ""nextnonce"" );
    char *psz_qop = AuthGetParamNoQuotes( psz_header, ""qop"" );
    char *psz_rspauth = AuthGetParam( psz_header, ""rspauth"" );
    char *psz_cnonce = AuthGetParam( psz_header, ""cnonce"" );
    char *psz_nc = AuthGetParamNoQuotes( psz_header, ""nc"" );
    char *psz_digest = NULL;
    int i_err = VLC_SUCCESS;
    int i_nonce;

    if ( psz_cnonce )
    {
        if ( strcmp( psz_cnonce, p_auth->psz_cnonce ) != 0 )
        {
            msg_Err( p_this, ""HTTP Digest Access Authentication: server ""
                             ""replied with a different client nonce value."" );
            i_err = VLC_EGENERIC;
            goto error;
        }

        if ( psz_nc )
        {
        ...",309.0,386.0,1.0,1.0,78.0,28,6,62,18,0,6,11,14,0,6,,0,6,14,7,7,int
3088,142472,vlc_http_auth_FormatAuthorizationHeader,1,vlc_http_auth_FormatAuthorizationHeader,"char* vlc_http_auth_FormatAuthorizationHeader (vlc_object_t*,vlc_http_auth_t*,char*,char*,char*,char*)",network\http_auth.c,"char *vlc_http_auth_FormatAuthorizationHeader(
        vlc_object_t *p_this, vlc_http_auth_t *p_auth,
        const char *psz_method, const char *psz_path,
        const char *psz_username, const char *psz_password )
{
    char *psz_result = NULL;
    char *psz_buffer = NULL;
    char *psz_base64 = NULL;
    int i_rc;

    if ( p_auth->psz_nonce )
    {
        /* Digest Access Authentication */
        if ( p_auth->psz_algorithm &&
             strcmp( p_auth->psz_algorithm, ""MD5"" ) != 0 &&
             strcmp( p_auth->psz_algorithm, ""MD5-sess"" ) != 0 )
        {
            msg_Err( p_this, ""Digest Access Authentication: ""
                     ""Unknown algorithm '%s'"", p_auth->psz_algorithm );
            goto error;
        }

        if ( p_auth->psz_qop != NULL || p_auth->psz_cnonce == NULL )
        {
            free( p_auth->psz_cnonce );

            p_auth->psz_cnonce = GenerateCnonce();
            if ( p_auth->psz_cnonce == NULL )
                goto error;
        }

 ...",388.0,487.0,1.0,1.0,100.0,63,10,60,11,0,2,11,13,0,1,,0,2,12,6,6,char*
3089,142736,vlc_http_auth_Init,1,vlc_http_auth_Init,void vlc_http_auth_Init (vlc_http_auth_t*),network\http_auth.c,"void vlc_http_auth_Init( vlc_http_auth_t *p_auth )
{
    memset( p_auth, 0, sizeof( *p_auth ) );
}",489.0,492.0,1.0,1.0,4.0,2,2,2,1,0,0,1,1,0,0,,0,0,2,1,1,void
3090,142747,vlc_http_auth_Deinit,1,vlc_http_auth_Deinit,void vlc_http_auth_Deinit (vlc_http_auth_t*),network\http_auth.c,"void vlc_http_auth_Deinit( vlc_http_auth_t *p_auth )
{
    free( p_auth->psz_realm );
    free( p_auth->psz_domain );
    free( p_auth->psz_nonce );
    free( p_auth->psz_opaque );
    free( p_auth->psz_stale );
    free( p_auth->psz_algorithm );
    free( p_auth->psz_qop );
    free( p_auth->psz_cnonce );
    free( p_auth->psz_HA1 );
}",494.0,505.0,1.0,1.0,12.0,9,1,9,1,0,0,1,1,0,0,,0,0,2,1,1,void
3091,142833,httpd_ClientDestroy,1,httpd_ClientDestroy,void httpd_ClientDestroy (httpd_client_t*),network\httpd.c,"static void httpd_ClientDestroy(httpd_client_t *cl)
{
    vlc_tls_Close(cl->sock);
    httpd_MsgClean(&cl->answer);
    httpd_MsgClean(&cl->query);

    free(cl->p_buffer);
    free(cl);
}",1214.0,1222.0,1.0,1.0,9.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,void
3092,142838,httpd_AppendData,1,httpd_AppendData,"void httpd_AppendData (httpd_stream_t*,uint8_t*,int)",network\httpd.c,"static void httpd_AppendData(httpd_stream_t *stream, uint8_t *p_data, int i_data)
{
    int i_pos = stream->i_buffer_pos % stream->i_buffer_size;
    int i_count = i_data;
    while (i_count > 0) {
        int i_copy = __MIN(i_count, stream->i_buffer_size - i_pos);

        /* Ok, we can't go past the end of our buffer */
        memcpy(&stream->p_buffer[i_pos], p_data, i_copy);

        i_pos = (i_pos + i_copy) % stream->i_buffer_size;
        i_count -= i_copy;
        p_data  += i_copy;
    }

    stream->i_buffer_pos += i_data;
}",804.0,820.0,1.0,1.0,17.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
3093,142900,httpd_ReasonFromCode,1,httpd_ReasonFromCode,const char* httpd_ReasonFromCode (unsigned),network\httpd.c,"static const char *httpd_ReasonFromCode(unsigned i_code)
{
    typedef struct
    {
        unsigned   i_code;
        const char psz_reason[36];
    } http_status_info;

    static const http_status_info http_reason[] =
    {
        /*{ 100, ""Continue"" },
          { 101, ""Switching Protocols"" },*/
        { 200, ""OK"" },
        /*{ 201, ""Created"" },
          { 202, ""Accepted"" },
          { 203, ""Non-authoritative information"" },
          { 204, ""No content"" },
          { 205, ""Reset content"" },
          { 206, ""Partial content"" },
          { 250, ""Low on storage space"" },
          { 300, ""Multiple choices"" },*/
        { 301, ""Moved permanently"" },
        /*{ 302, ""Moved temporarily"" },
          { 303, ""See other"" },
          { 304, ""Not modified"" },
          { 305, ""Use proxy"" },
          { 307, ""Temporary redirect"" },
          { 400, ""Bad request"" },*/
        { 401, ""Unauthorized"" },
        /*{ 402, ""Payment Required"" },*/
        { 403, ""Forbidden"" },
        { ...",174.0,255.0,1.0,1.0,82.0,35,11,13,4,3,0,3,3,0,0,,0,0,2,1,1,const char*
3094,143015,httpd_HtmlError,1,httpd_HtmlError,"size_t httpd_HtmlError (char**,int,char*)",network\httpd.c,"static size_t httpd_HtmlError (char **body, int code, const char *url)
{
    const char *errname = httpd_ReasonFromCode (code);
    assert (errname);

    char *url_Encoded = vlc_xml_encode (url ? url : """");

    int res = asprintf (body,
        ""<?xml version=\""1.0\"" encoding=\""ascii\"" ?>\n""
        ""<!DOCTYPE html PUBLIC \""-//W3C//DTD XHTML 1.0 Strict//EN\""""
        "" \""http://www.w3.org/TR/xhtml10/DTD/xhtml10strict.dtd\"">\n""
        ""<html lang=\""en\"">\n""
        ""<head>\n""
        ""<title>%s</title>\n""
        ""</head>\n""
        ""<body>\n""
        ""<h1>%d %s%s%s%s</h1>\n""
        ""<hr />\n""
        ""<a href=\""http://www.videolan.org\"">VideoLAN</a>\n""
        ""</body>\n""
        ""</html>\n"", errname, code, errname,
        (url_Encoded ? "" ("" : """"), (url_Encoded ? url_Encoded : """"), (url_Encoded ? "")"" : """"));

    free (url_Encoded);

    if (res == -1) {
        *body = NULL;
        return 0;
    }

    return (size_t)res;
}",257.0,288.0,1.0,1.0,32.0,12,6,20,7,2,2,2,2,0,2,,0,2,6,3,3,size_t
3095,143087,httpd_FileCallBack,1,httpd_FileCallBack,"int httpd_FileCallBack (httpd_callback_sys_t*,httpd_client_t*,httpd_message_t*,httpd_message_t*)",network\httpd.c,"static int
httpd_FileCallBack(httpd_callback_sys_t *p_sys, httpd_client_t *cl,
                    httpd_message_t *answer, const httpd_message_t *query)
{
    httpd_file_t *file = (httpd_file_t*)p_sys;
    uint8_t **pp_body, *p_body;
    int *pi_body, i_body;

    if (!answer || !query )
        return VLC_SUCCESS;

    answer->i_proto  = HTTPD_PROTO_HTTP;
    answer->i_version= 1;
    answer->i_type   = HTTPD_MSG_ANSWER;

    answer->i_status = 200;

    httpd_MsgAdd(answer, ""Content-type"",  ""%s"", file->mime);
    httpd_MsgAdd(answer, ""Cache-Control"", ""%s"", ""no-cache"");

    if (query->i_type != HTTPD_MSG_HEAD) {
        pp_body = &answer->p_body;
        pi_body = &answer->i_body;
    } else {
        /* The file still needs to be executed. */
        p_body = NULL;
        i_body = 0;
        pp_body = &p_body;
        pi_body = &i_body;
    }

    if (query->i_type == HTTPD_MSG_POST) {
        /* msg_Warn not supported */
    }

    uint8_t *psz_args = query->psz_args;
    file...",302.0,350.0,1.0,1.0,49.0,34,8,39,15,0,9,6,6,2,5,,0,5,8,4,4,int
3096,143237,httpd_FileNew,1,httpd_FileNew,"httpd_file_t httpd_FileNew (httpd_host_t*,char*,char*,char*,char*,httpd_file_callback_t,httpd_file_sys_t*)",network\httpd.c,"httpd_file_t *httpd_FileNew(httpd_host_t *host,
                             const char *psz_url, const char *psz_mime,
                             const char *psz_user, const char *psz_password,
                             httpd_file_callback_t pf_fill,
                             httpd_file_sys_t *p_sys)
{
    const char *mime = psz_mime;
    if (mime == NULL || mime[0] == '\0')
        mime = vlc_mime_Ext2Mime(psz_url);

    size_t mimelen = strlen(mime);
    httpd_file_t *file = malloc(sizeof(*file) + mimelen);
    if (unlikely(file == NULL))
        return NULL;

    file->url = httpd_UrlNew(host, psz_url, psz_user, psz_password);
    if (!file->url) {
        free(file);
        return NULL;
    }

    file->pf_fill = pf_fill;
    file->p_sys   = p_sys;
    memcpy(file->mime, mime, mimelen + 1);

    httpd_UrlCatch(file->url, HTTPD_MSG_HEAD, httpd_FileCallBack,
                    (httpd_callback_sys_t*)file);
    httpd_UrlCatch(file->url, HTTPD_MSG_GET,  httpd_FileCallBack...",352.0,385.0,1.0,1.0,34.0,28,10,40,14,0,13,4,4,1,5,,0,10,14,7,7,httpd_file_t
3097,143355,httpd_FileDelete,1,httpd_FileDelete,httpd_file_sys_t httpd_FileDelete (httpd_file_t*),network\httpd.c,"httpd_file_sys_t *httpd_FileDelete(httpd_file_t *file)
{
    httpd_file_sys_t *p_sys = file->p_sys;

    httpd_UrlDelete(file->url);
    free(file);
    return p_sys;
}",387.0,394.0,1.0,1.0,8.0,3,2,5,2,0,3,1,1,0,1,,0,2,2,1,1,httpd_file_sys_t
3098,143378,httpd_HandlerCallBack,1,httpd_HandlerCallBack,"int httpd_HandlerCallBack (httpd_callback_sys_t*,httpd_client_t*,httpd_message_t*,httpd_message_t*)",network\httpd.c,"static int
httpd_HandlerCallBack(httpd_callback_sys_t *p_sys, httpd_client_t *cl,
                       httpd_message_t *answer, const httpd_message_t *query)
{
    httpd_handler_t *handler = (httpd_handler_t*)p_sys;
    char psz_remote_addr[NI_MAXNUMERICHOST];

    if (!answer || !query)
        return VLC_SUCCESS;

    answer->i_proto  = HTTPD_PROTO_NONE;
    answer->i_type   = HTTPD_MSG_ANSWER;

    /* We do it ourselves, thanks */
    answer->i_status = 0;

    if (!httpd_ClientIP(cl, psz_remote_addr, NULL))
        *psz_remote_addr = '\0';

    uint8_t *psz_args = query->psz_args;
    handler->pf_fill(handler->p_sys, handler, query->psz_url, psz_args,
                      query->i_type, query->p_body, query->i_body,
                      psz_remote_addr, NULL,
                      &answer->p_body, &answer->i_body);

    if (query->i_type == HTTPD_MSG_HEAD) {
        char *p = (char *)answer->p_body;

        /* Looks for end of header (i.e. one empty line) */
        while (...",408.0,476.0,1.0,1.0,69.0,86,13,73,18,0,4,10,17,1,2,,0,4,8,4,4,int
3099,143681,httpd_HandlerNew,1,httpd_HandlerNew,"httpd_handler_t httpd_HandlerNew (httpd_host_t*,char*,char*,char*,httpd_handler_callback_t,void*)",network\httpd.c,"httpd_handler_t *httpd_HandlerNew(httpd_host_t *host, const char *psz_url,
                                  const char *psz_user,
                                  const char *psz_password,
                                  httpd_handler_callback_t pf_fill,
                                  void *p_sys)
{
    httpd_handler_t *handler = malloc(sizeof(*handler));
    if (!handler)
        return NULL;

    handler->url = httpd_UrlNew(host, psz_url, psz_user, psz_password);
    if (!handler->url) {
        free(handler);
        return NULL;
    }

    handler->pf_fill = pf_fill;
    handler->p_sys   = p_sys;

    httpd_UrlCatch(handler->url, HTTPD_MSG_HEAD, httpd_HandlerCallBack,
                    (httpd_callback_sys_t*)handler);
    httpd_UrlCatch(handler->url, HTTPD_MSG_GET,  httpd_HandlerCallBack,
                    (httpd_callback_sys_t*)handler);
    httpd_UrlCatch(handler->url, HTTPD_MSG_POST, httpd_HandlerCallBack,
                    (httpd_callback_sys_t*)handler);

    r...",478.0,505.0,1.0,1.0,28.0,18,6,26,11,0,11,3,3,1,4,,0,8,12,6,6,httpd_handler_t
3100,143762,httpd_HandlerDelete,1,httpd_HandlerDelete,void* httpd_HandlerDelete (httpd_handler_t*),network\httpd.c,"void *httpd_HandlerDelete(httpd_handler_t *handler)
{
    void *p_sys = handler->p_sys;
    httpd_UrlDelete(handler->url);
    free(handler);
    return p_sys;
}",507.0,513.0,1.0,1.0,7.0,3,2,5,2,0,3,1,1,0,1,,0,2,2,1,1,void*
3101,143790,httpd_RedirectCallBack,1,httpd_RedirectCallBack,"int httpd_RedirectCallBack (httpd_callback_sys_t*,httpd_client_t*,httpd_message_t*,httpd_message_t*)",network\httpd.c,"static int httpd_RedirectCallBack(httpd_callback_sys_t *p_sys,
                                   httpd_client_t *cl, httpd_message_t *answer,
                                   const httpd_message_t *query)
{
    httpd_redirect_t *rdir = (httpd_redirect_t*)p_sys;
    char *p_body;
    (void)cl;

    if (!answer || !query)
        return VLC_SUCCESS;

    answer->i_proto  = HTTPD_PROTO_HTTP;
    answer->i_version= 1;
    answer->i_type   = HTTPD_MSG_ANSWER;
    answer->i_status = 301;

    answer->i_body = httpd_HtmlError (&p_body, 301, rdir->dst);
    answer->p_body = (unsigned char *)p_body;

    /* XXX check if it's ok or we need to set an absolute url */
    httpd_MsgAdd(answer, ""Location"",  ""%s"", rdir->dst);

    httpd_MsgAdd(answer, ""Content-Length"", ""%d"", answer->i_body);

    if (httpd_MsgGet(&cl->query, ""Connection"") != NULL)
        httpd_MsgAdd(answer, ""Connection"", ""close"");

    return VLC_SUCCESS;
}",524.0,552.0,1.0,1.0,29.0,26,7,25,10,0,8,3,3,2,5,,0,5,8,4,4,int
3102,143885,httpd_RedirectNew,1,httpd_RedirectNew,"httpd_redirect_t httpd_RedirectNew (httpd_host_t*,char*,char*)",network\httpd.c,"httpd_redirect_t *httpd_RedirectNew(httpd_host_t *host, const char *psz_url_dst,
                                     const char *psz_url_src)
{
    size_t dstlen = strlen(psz_url_dst);

    httpd_redirect_t *rdir = malloc(sizeof(*rdir) + dstlen);
    if (unlikely(rdir == NULL))
        return NULL;

    rdir->url = httpd_UrlNew(host, psz_url_src, NULL, NULL);
    if (!rdir->url) {
        free(rdir);
        return NULL;
    }
    memcpy(rdir->dst, psz_url_dst, dstlen + 1);

    /* Redirect apply for all HTTP request and RTSP DESCRIBE resquest */
    httpd_UrlCatch(rdir->url, HTTPD_MSG_HEAD, httpd_RedirectCallBack,
                    (httpd_callback_sys_t*)rdir);
    httpd_UrlCatch(rdir->url, HTTPD_MSG_GET, httpd_RedirectCallBack,
                    (httpd_callback_sys_t*)rdir);
    httpd_UrlCatch(rdir->url, HTTPD_MSG_POST, httpd_RedirectCallBack,
                    (httpd_callback_sys_t*)rdir);
    httpd_UrlCatch(rdir->url, HTTPD_MSG_DESCRIBE, httpd_RedirectCallBack,
          ...",554.0,581.0,1.0,1.0,28.0,20,8,32,10,0,12,3,3,1,5,,0,8,6,3,3,httpd_redirect_t
3103,143979,httpd_RedirectDelete,1,httpd_RedirectDelete,void httpd_RedirectDelete (httpd_redirect_t*),network\httpd.c,"void httpd_RedirectDelete(httpd_redirect_t *rdir)
{
    httpd_UrlDelete(rdir->url);
    free(rdir);
}",582.0,586.0,1.0,1.0,5.0,1,1,2,1,0,2,1,1,0,1,,0,1,2,1,1,void
3104,144004,httpd_StreamCallBack,1,httpd_StreamCallBack,"int httpd_StreamCallBack (httpd_callback_sys_t*,httpd_client_t*,httpd_message_t*,httpd_message_t*)",network\httpd.c,"static int httpd_StreamCallBack(httpd_callback_sys_t *p_sys,
                                 httpd_client_t *cl, httpd_message_t *answer,
                                 const httpd_message_t *query)
{
    httpd_stream_t *stream = (httpd_stream_t*)p_sys;

    if (!answer || !query || !cl)
        return VLC_SUCCESS;

    if (answer->i_body_offset > 0) {
        int     i_pos;

        if (answer->i_body_offset >= stream->i_buffer_pos)
            return VLC_EGENERIC;    /* wait, no data available */

        if (cl->i_keyframe_wait_to_pass >= 0) {
            if (stream->i_last_keyframe_seen_pos <= cl->i_keyframe_wait_to_pass)
                /* still waiting for the next keyframe */
                return VLC_EGENERIC;

            /* seek to the new keyframe */
            answer->i_body_offset = stream->i_last_keyframe_seen_pos;
            cl->i_keyframe_wait_to_pass = -1;
        }

        if (answer->i_body_offset + stream->i_buffer_size < stream->i_buffer_pos)
            ...",621.0,744.0,1.0,22.0,124.0,60,16,50,11,0,13,8,14,6,0,,0,13,8,4,4,int
3105,144510,httpd_StreamNew,1,httpd_StreamNew,"httpd_stream_t httpd_StreamNew (httpd_host_t*,char*,char*,char*,char*)",network\httpd.c,"httpd_stream_t *httpd_StreamNew(httpd_host_t *host,
                                 const char *psz_url, const char *psz_mime,
                                 const char *psz_user, const char *psz_password)
{
    httpd_stream_t *stream = malloc(sizeof(*stream));
    if (!stream)
        return NULL;

    stream->url = httpd_UrlNew(host, psz_url, psz_user, psz_password);
    if (!stream->url) {
        free(stream);
        return NULL;
    }

    vlc_mutex_init(&stream->lock);
    if (psz_mime == NULL || psz_mime[0] == '\0')
        psz_mime = vlc_mime_Ext2Mime(psz_url);
    stream->psz_mime = xstrdup(psz_mime);

    stream->i_header = 0;
    stream->p_header = NULL;
    stream->i_buffer_size = 5000000;    /* 5 Mo per stream */
    stream->p_buffer = xmalloc(stream->i_buffer_size);
    /* We set to 1 to make life simpler
     * (this way i_body_offset can never be 0) */
    stream->i_buffer_pos = 1;
    stream->i_buffer_last_pos = 1;
    stream->b_has_keyframes = false;
    stream...",746.0,786.0,1.0,1.0,41.0,44,10,44,11,0,24,4,4,1,6,,0,20,10,5,5,httpd_stream_t
3106,144659,httpd_StreamHeader,1,httpd_StreamHeader,"int httpd_StreamHeader (httpd_stream_t*,uint8_t*,int)",network\httpd.c,"int httpd_StreamHeader(httpd_stream_t *stream, uint8_t *p_data, int i_data)
{
    vlc_mutex_lock(&stream->lock);
    free(stream->p_header);
    stream->p_header = NULL;

    stream->i_header = i_data;
    if (i_data > 0) {
        stream->p_header = xmalloc(i_data);
        memcpy(stream->p_header, p_data, i_data);
    }
    vlc_mutex_unlock(&stream->lock);

    return VLC_SUCCESS;
}",788.0,802.0,1.0,1.0,15.0,13,4,14,5,0,9,2,2,0,2,,0,7,6,3,3,int
3107,144774,httpd_StreamSend,1,httpd_StreamSend,"int httpd_StreamSend (httpd_stream_t*,block_t*)",network\httpd.c,"int httpd_StreamSend(httpd_stream_t *stream, const block_t *p_block)
{
    if (!p_block || !p_block->p_buffer)
        return VLC_SUCCESS;

    vlc_mutex_lock(&stream->lock);

    /* save this pointer (to be used by new connection) */
    stream->i_buffer_last_pos = stream->i_buffer_pos;

    if (p_block->i_flags & BLOCK_FLAG_TYPE_I) {
        stream->b_has_keyframes = true;
        stream->i_last_keyframe_seen_pos = stream->i_buffer_pos;
    }

    httpd_AppendData(stream, p_block->p_buffer, p_block->i_buffer);

    vlc_mutex_unlock(&stream->lock);
    return VLC_SUCCESS;
}",822.0,841.0,1.0,1.0,20.0,20,6,17,5,0,10,3,3,0,3,,0,7,4,2,2,int
3108,144837,httpd_StreamDelete,1,httpd_StreamDelete,void httpd_StreamDelete (httpd_stream_t*),network\httpd.c,"void httpd_StreamDelete(httpd_stream_t *stream)
{
    httpd_UrlDelete(stream->url);
    for (size_t i = 0; i < stream->i_http_headers; i++) {
        free(stream->p_http_headers[i].name);
        free(stream->p_http_headers[i].value);
    }
    free(stream->p_http_headers);
    vlc_mutex_destroy(&stream->lock);
    free(stream->psz_mime);
    free(stream->p_header);
    free(stream->p_buffer);
    free(stream);
}",843.0,856.0,1.0,1.0,14.0,16,6,14,2,0,11,2,2,1,2,,0,9,2,1,1,void
3109,144899,httpd_HostThread,1,httpd_HostThread,void* httpd_HostThread (void*),network\httpd.c,"static void* httpd_HostThread(void *data)
{
    httpd_host_t *host = data;

    vlc_mutex_lock(&host->lock);
    while (host->i_ref > 0)
        httpdLoop(host);
    vlc_mutex_unlock(&host->lock);
    return NULL;
}",2050.0,2059.0,1.0,1.0,10.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void*
3110,144904,httpd_HostCreate,1,httpd_HostCreate,"httpd_host_t* httpd_HostCreate (vlc_object_t*,char*,char*,vlc_tls_creds_t*,unsigned)",network\httpd.c,"static httpd_host_t *httpd_HostCreate(vlc_object_t *p_this,
                                       const char *hostvar,
                                       const char *portvar,
                                       vlc_tls_creds_t *p_tls,
                                       unsigned timeout_sec)
{
    httpd_host_t *host;
    unsigned port = var_InheritInteger(p_this, portvar);

    /* to be sure to avoid multiple creation */
    vlc_mutex_lock(&httpd.mutex);

    /* verify if it already exist */
    for (int i = 0; i < httpd.i_host; i++) {
        host = httpd.host[i];

        /* cannot mix TLS and non-TLS hosts */
        if (host->port != port
         || (host->p_tls != NULL) != (p_tls != NULL))
            continue;

        /* Increase existing matching host reference count.
         * The reference count is written under both the global httpd and the
         * host lock. It is read with either or both locks held. The global
         * lock is always acquired first. */...",910.0,1002.0,1.0,27.0,93.0,0,0,0,0,3,0,1,1,0,0,,0,0,10,5,5,httpd_host_t
3111,144913,vlc_http_HostNew,1,vlc_http_HostNew,httpd_host_t vlc_http_HostNew (vlc_object_t*),network\httpd.c,"httpd_host_t *vlc_http_HostNew(vlc_object_t *p_this)
{
    return httpd_HostCreate(p_this, ""http-host"", ""http-port"", NULL, 10);
}",867.0,870.0,1.0,1.0,4.0,0,0,2,2,0,1,1,1,0,1,,0,0,2,1,1,httpd_host_t
3112,144925,vlc_https_HostNew,1,vlc_https_HostNew,httpd_host_t vlc_https_HostNew (vlc_object_t*),network\httpd.c,"httpd_host_t *vlc_https_HostNew(vlc_object_t *obj)
{
    char *cert = var_InheritString(obj, ""http-cert"");
    if (!cert) {
        msg_Err(obj, ""HTTP/TLS certificate not specified!"");
        return NULL;
    }

    char *key = var_InheritString(obj, ""http-key"");
    vlc_tls_creds_t *tls = vlc_tls_ServerCreate(obj, cert, key);

    if (!tls) {
        msg_Err(obj, ""HTTP/TLS certificate error (%s and %s)"",
                 cert, key ? key : cert);
        free(key);
        free(cert);
        return NULL;
    }
    free(key);
    free(cert);

    return httpd_HostCreate(obj, ""http-host"", ""https-port"", tls, 10);
}",872.0,894.0,1.0,1.0,23.0,6,3,24,5,0,2,3,3,0,2,,0,1,2,1,1,httpd_host_t
3113,144987,vlc_rtsp_HostNew,1,vlc_rtsp_HostNew,httpd_host_t vlc_rtsp_HostNew (vlc_object_t*),network\httpd.c,"httpd_host_t *vlc_rtsp_HostNew(vlc_object_t *p_this)
{
    unsigned timeout = var_InheritInteger(p_this, ""rtsp-timeout"");
    return httpd_HostCreate(p_this, ""rtsp-host"", ""rtsp-port"", NULL, timeout);
}",896.0,900.0,1.0,1.0,5.0,1,1,5,3,0,1,1,1,0,1,,0,0,2,1,1,httpd_host_t
3114,145290,httpd_HostDelete,1,httpd_HostDelete,void httpd_HostDelete (httpd_host_t*),network\httpd.c,"void httpd_HostDelete(httpd_host_t *host)
{
    bool delete = false;

    vlc_mutex_lock(&httpd.mutex);

    vlc_mutex_lock(&host->lock);
    host->i_ref--;
    if (host->i_ref == 0)
        delete = true;
    vlc_mutex_unlock(&host->lock);
    if (!delete) {
        /* still used */
        vlc_mutex_unlock(&httpd.mutex);
        msg_Dbg(host, ""httpd_HostDelete: host still in use"");
        return;
    }
    TAB_REMOVE(httpd.i_host, httpd.host, host);

    vlc_cancel(host->thread);
    vlc_join(host->thread, NULL);

    msg_Dbg(host, ""HTTP host removed"");

    for (int i = 0; i < host->i_url; i++)
        msg_Err(host, ""url still registered: %s"", host->url[i]->psz_url);

    for (int i = 0; i < host->i_client; i++) {
        msg_Warn(host, ""client still connected"");
        httpd_ClientDestroy(host->client[i]);
    }
    TAB_CLEAN(host->i_client, host->client);

    vlc_tls_Delete(host->p_tls);
    net_ListenClose(host->fds);
    vlc_cond_destroy(&host->wait);
    vlc_mutex_destroy...",1005.0,1044.0,1.0,1.0,40.0,37,9,36,7,0,38,5,5,3,13,,0,25,2,1,1,void
3115,145439,httpd_UrlNew,1,httpd_UrlNew,"httpd_url_t httpd_UrlNew (httpd_host_t*,char*,char*,char*)",network\httpd.c,"httpd_url_t *httpd_UrlNew(httpd_host_t *host, const char *psz_url,
                           const char *psz_user, const char *psz_password)
{
    httpd_url_t *url;

    assert(psz_url);

    vlc_mutex_lock(&host->lock);
    for (int i = 0; i < host->i_url; i++)
        if (!strcmp(psz_url, host->url[i]->psz_url)) {
            msg_Warn(host, ""cannot add '%s' (url already defined)"", psz_url);
            vlc_mutex_unlock(&host->lock);
            return NULL;
        }

    url = xmalloc(sizeof(httpd_url_t));
    url->host = host;

    vlc_mutex_init(&url->lock);
    url->psz_url = xstrdup(psz_url);
    url->psz_user = xstrdup(psz_user ? psz_user : """");
    url->psz_password = xstrdup(psz_password ? psz_password : """");
    for (int i = 0; i < HTTPD_MSG_MAX; i++) {
        url->catch[i].cb = NULL;
        url->catch[i].p_sys = NULL;
    }

    TAB_APPEND(host->i_url, host->url, url);
    vlc_cond_signal(&host->wait);
    vlc_mutex_unlock(&host->lock);

    return url;
}",1047.0,1079.0,1.0,1.0,33.0,35,8,33,9,4,15,3,3,1,4,,0,11,8,4,4,httpd_url_t
3116,145580,httpd_UrlCatch,1,httpd_UrlCatch,"int httpd_UrlCatch (httpd_url_t*,int,httpd_callback_t,httpd_callback_sys_t*)",network\httpd.c,"int httpd_UrlCatch(httpd_url_t *url, int i_msg, httpd_callback_t cb,
                    httpd_callback_sys_t *p_sys)
{
    vlc_mutex_lock(&url->lock);
    url->catch[i_msg].cb   = cb;
    url->catch[i_msg].p_sys= p_sys;
    vlc_mutex_unlock(&url->lock);

    return VLC_SUCCESS;
}",1082.0,1091.0,1.0,1.0,10.0,12,5,9,5,13,4,1,1,0,2,,0,2,8,4,4,int
3117,145618,httpd_UrlDelete,1,httpd_UrlDelete,void httpd_UrlDelete (httpd_url_t*),network\httpd.c,"void httpd_UrlDelete(httpd_url_t *url)
{
    httpd_host_t *host = url->host;

    vlc_mutex_lock(&host->lock);
    TAB_REMOVE(host->i_url, host->url, url);

    vlc_mutex_destroy(&url->lock);
    free(url->psz_url);
    free(url->psz_user);
    free(url->psz_password);

    for (int i = 0; i < host->i_client; i++) {
        httpd_client_t *client = host->client[i];

        if (client->url != url)
            continue;

        /* TODO complete it */
        msg_Warn(host, ""force closing connections"");
        TAB_REMOVE(host->i_client, host->client, client);
        httpd_ClientDestroy(client);
        i--;
    }
    free(url);
    vlc_mutex_unlock(&host->lock);
}",1094.0,1120.0,1.0,1.0,27.0,24,7,26,4,4,18,4,4,2,4,,0,14,2,1,1,void
3118,145711,httpd_MsgInit,1,httpd_MsgInit,void httpd_MsgInit (httpd_message_t*),network\httpd.c,"static void httpd_MsgInit(httpd_message_t *msg)
{
    msg->cl         = NULL;
    msg->i_type     = HTTPD_MSG_NONE;
    msg->i_proto    = HTTPD_PROTO_NONE;
    msg->i_version  = -1; /* FIXME */

    msg->i_status   = 0;

    msg->psz_url    = NULL;
    msg->psz_args   = NULL;

    msg->i_headers  = 0;
    msg->p_headers  = NULL;

    msg->i_body_offset = 0;
    msg->i_body        = 0;
    msg->p_body        = NULL;
}",1122.0,1140.0,1.0,1.0,19.0,25,3,19,4,6,0,1,1,0,0,,0,0,2,1,1,void
3119,145777,httpd_MsgClean,1,httpd_MsgClean,void httpd_MsgClean (httpd_message_t*),network\httpd.c,"static void httpd_MsgClean(httpd_message_t *msg)
{
    free(msg->psz_url);
    free(msg->psz_args);
    for (size_t i = 0; i < msg->i_headers; i++) {
        free(msg->p_headers[i].name);
        free(msg->p_headers[i].value);
    }
    free(msg->p_headers);
    free(msg->p_body);
    httpd_MsgInit(msg);
}",1142.0,1153.0,1.0,1.0,12.0,13,5,12,2,3,1,2,2,0,1,,0,0,2,1,1,void
3120,145830,httpd_MsgGet,1,httpd_MsgGet,"const char* httpd_MsgGet (httpd_message_t*,char*)",network\httpd.c,"const char *httpd_MsgGet(const httpd_message_t *msg, const char *name)
{
    for (size_t i = 0; i < msg->i_headers; i++)
        if (!strcasecmp(msg->p_headers[i].name, name))
            return msg->p_headers[i].value;
    return NULL;
}",1155.0,1161.0,1.0,1.0,7.0,3,3,4,3,9,0,2,2,0,0,,0,0,4,2,2,const char*
3121,145871,httpd_MsgAdd,1,httpd_MsgAdd,"void httpd_MsgAdd (httpd_message_t*,char*,char*...)",network\httpd.c,"void httpd_MsgAdd(httpd_message_t *msg, const char *name, const char *psz_value, ...)
{
    httpd_header *p_tmp = realloc(msg->p_headers, sizeof(httpd_header) * (msg->i_headers + 1));
    if (!p_tmp)
        return;

    msg->p_headers = p_tmp;

    httpd_header *h = &msg->p_headers[msg->i_headers];
    h->name = strdup(name);
    if (!h->name)
        return;

    h->value = NULL;

    va_list args;
    va_start(args, psz_value);
    int ret = us_vasprintf(&h->value, psz_value, args);
    va_end(args);

    if (ret == -1) {
        free(h->name);
        return;
    }

    msg->i_headers++;
}",1163.0,1189.0,1.0,1.0,27.0,28,11,25,9,19,1,4,4,0,1,,0,1,6,3,3,void
3122,145963,httpd_ClientInit,1,httpd_ClientInit,void httpd_ClientInit (httpd_client_t*),network\httpd.c,"static void httpd_ClientInit(httpd_client_t *cl)
{
    cl->i_state = HTTPD_CLIENT_RECEIVING;
    cl->i_buffer_size = HTTPD_CL_BUFSIZE;
    cl->i_buffer = 0;
    cl->p_buffer = xmalloc(cl->i_buffer_size);
    cl->i_keyframe_wait_to_pass = -1;
    cl->b_stream_mode = false;

    httpd_MsgInit(&cl->query);
    httpd_MsgInit(&cl->answer);
}",1191.0,1202.0,1.0,24.0,12.0,18,4,11,3,1,11,1,1,0,2,,0,9,2,1,1,void
3123,146014,httpd_ClientIP,1,httpd_ClientIP,"char* httpd_ClientIP (httpd_client_t*,char*,int*)",network\httpd.c,"char* httpd_ClientIP(const httpd_client_t *cl, char *ip, int *port)
{
    return net_GetPeerAddress(vlc_tls_GetFD(cl->sock), ip, port) ? NULL : ip;
}",1204.0,1207.0,1.0,1.0,4.0,2,2,5,4,1,1,1,1,0,0,,0,1,6,3,3,char*
3124,146032,httpd_ServerIP,1,httpd_ServerIP,"char* httpd_ServerIP (httpd_client_t*,char*,int*)",network\httpd.c,"char* httpd_ServerIP(const httpd_client_t *cl, char *ip, int *port)
{
    return net_GetSockAddress(vlc_tls_GetFD(cl->sock), ip, port) ? NULL : ip;
}",1209.0,1212.0,1.0,1.0,4.0,2,2,5,4,0,1,1,1,0,0,,0,1,6,3,3,char*
3125,146075,httpd_ClientNew,1,httpd_ClientNew,httpd_client_t httpd_ClientNew (vlc_tls_t*),network\httpd.c,"static httpd_client_t *httpd_ClientNew(vlc_tls_t *sock)
{
    httpd_client_t *cl = malloc(sizeof(httpd_client_t));

    if (!cl) return NULL;

    cl->i_ref   = 0;
    cl->sock    = sock;
    cl->url     = NULL;

    httpd_ClientInit(cl);
    return cl;
}",1224.0,1236.0,1.0,1.0,13.0,9,4,11,4,1,4,2,2,0,1,,0,3,2,1,1,httpd_client_t
3126,146111,httpd_NetRecv,1,httpd_NetRecv,"ssize_t httpd_NetRecv (httpd_client_t*,uint8_t*,size_t)",network\httpd.c,"static
ssize_t httpd_NetRecv (httpd_client_t *cl, uint8_t *p, size_t i_len)
{
    vlc_tls_t *sock = cl->sock;
    struct iovec iov = { .iov_base = p, .iov_len = i_len };
    return sock->readv(sock, &iov, 1);
}",1238.0,1244.0,1.0,1.0,7.0,8,4,10,7,1,1,1,1,0,0,,0,1,6,3,3,ssize_t
3127,146145,httpd_NetSend,1,httpd_NetSend,"ssize_t httpd_NetSend (httpd_client_t*,uint8_t*,size_t)",network\httpd.c,"static
ssize_t httpd_NetSend (httpd_client_t *cl, const uint8_t *p, size_t i_len)
{
    vlc_tls_t *sock = cl->sock;
    const struct iovec iov = { .iov_base = (void *)p, .iov_len = i_len };
    return sock->writev(sock, &iov, 1);
}",1246.0,1252.0,1.0,1.0,7.0,9,5,10,7,1,1,1,1,0,0,,0,1,6,3,3,ssize_t
3128,146239,httpd_ClientRecv,1,httpd_ClientRecv,int httpd_ClientRecv (httpd_client_t*),network\httpd.c,"static int httpd_ClientRecv(httpd_client_t *cl)
{
    int i_len;

    /* ignore leading whites */
    if (cl->query.i_proto == HTTPD_PROTO_NONE && cl->i_buffer == 0) {
        unsigned char c;

        i_len = httpd_NetRecv(cl, &c, 1);

        if (i_len > 0 && !strchr(""\r\n\t "", c)) {
            cl->p_buffer[0] = c;
            cl->i_buffer++;
        }
    } else if (cl->query.i_proto == HTTPD_PROTO_NONE) {
        /* enough to see if it's Interleaved RTP over RTSP or RTSP/HTTP */
        i_len = httpd_NetRecv(cl, &cl->p_buffer[cl->i_buffer],
                               7 - cl->i_buffer);
        if (i_len > 0)
            cl->i_buffer += i_len;

        /* The smallest legal request is 7 bytes (""GET /\r\n""),
         * this is the maximum we can ask at this point. */
        if (cl->i_buffer >= 7) {
            if (!memcmp(cl->p_buffer, ""HTTP/1."", 7)) {
                cl->query.i_proto = HTTPD_PROTO_HTTP;
                cl->query.i_type  = HTTPD_MSG_ANSWER;
            } el...",1277.0,1565.0,1.0,1.0,289.0,38,13,26,9,1,12,8,13,5,1,,0,12,2,1,1,int
3129,147420,httpd_ClientSend,1,httpd_ClientSend,int httpd_ClientSend (httpd_client_t*),network\httpd.c,"static int httpd_ClientSend(httpd_client_t *cl)
{
    int i_len;

    if (cl->i_buffer < 0) {
        /* We need to create the header */
        int i_size = 0;
        char *p;
        const char *psz_status = httpd_ReasonFromCode(cl->answer.i_status);

        i_size = strlen(""HTTP/1."") + 10 + 10 + strlen(psz_status) + 5;
        for (size_t i = 0; i < cl->answer.i_headers; i++)
            i_size += strlen(cl->answer.p_headers[i].name) + 2 +
                      strlen(cl->answer.p_headers[i].value) + 2;

        if (cl->i_buffer_size < i_size) {
            cl->i_buffer_size = i_size;
            free(cl->p_buffer);
            cl->p_buffer = xmalloc(i_size);
        }
        p = (char *)cl->p_buffer;

        p += sprintf(p, ""%s.%u %d %s\r\n"",
                      cl->answer.i_proto ==  HTTPD_PROTO_HTTP ? ""HTTP/1"" : ""RTSP/1"",
                      cl->answer.i_version,
                      cl->answer.i_status, psz_status);
        for (size_t i = 0; i < cl->answer.i_headers...",1567.0,1646.0,1.0,1.0,80.0,114,16,75,13,1,45,10,16,9,3,,0,44,2,1,1,int
3130,147801,httpd_ClientTlsHandshake,1,httpd_ClientTlsHandshake,"void httpd_ClientTlsHandshake (httpd_host_t*,httpd_client_t*)",network\httpd.c,"static void httpd_ClientTlsHandshake(httpd_host_t *host, httpd_client_t *cl)
{
    switch (vlc_tls_SessionHandshake(host->p_tls, cl->sock))
    {
        case -1: cl->i_state = HTTPD_CLIENT_DEAD;       break;
        case 0:  cl->i_state = HTTPD_CLIENT_RECEIVING;  break;
        case 1:  cl->i_state = HTTPD_CLIENT_TLS_HS_IN;  break;
        case 2:  cl->i_state = HTTPD_CLIENT_TLS_HS_OUT; break;
    }
}",1648.0,1657.0,1.0,1.0,10.0,11,3,10,6,1,6,6,2,2,0,,0,6,4,2,2,void
3131,147849,httpdAuthOk,1,httpdAuthOk,"bool httpdAuthOk (char*,char*,char*)",network\httpd.c,"static bool httpdAuthOk(const char *user, const char *pass, const char *b64)
{
    if (!*user && !*pass)
        return true;

    if (!b64)
        return false;

    if (strncasecmp(b64, ""BASIC"", 5))
        return false;

    b64 += 5;
    while (*b64 == ' ')
        b64++;

    char *given_user = vlc_b64_decode(b64);
    if (!given_user)
        return false;

    char *given_pass = NULL;
    given_pass = strchr (given_user, ':');
    if (!given_pass)
        goto auth_failed;

    *given_pass++ = '\0';

    if (strcmp (given_user, user))
        goto auth_failed;

    if (strcmp (given_pass, pass))
        goto auth_failed;

    free(given_user);
    return true;

auth_failed:
    free(given_user);
    return false;
}",1659.0,1697.0,1.0,1.0,39.0,17,7,27,8,1,1,12,9,0,1,,0,1,6,3,3,bool
3132,147942,httpdLoop,1,httpdLoop,void httpdLoop (httpd_host_t*),network\httpd.c,"static void httpdLoop(httpd_host_t *host)
{
    struct pollfd ufd[host->nfd + host->i_client];
    unsigned nfd;
    for (nfd = 0; nfd < host->nfd; nfd++) {
        ufd[nfd].fd = host->fds[nfd];
        ufd[nfd].events = POLLIN;
        ufd[nfd].revents = 0;
    }

    /* add all socket that should be read/write and close dead connection */
    while (host->i_url <= 0) {
        mutex_cleanup_push(&host->lock);
        vlc_cond_wait(&host->wait, &host->lock);
        vlc_cleanup_pop();
    }

    mtime_t now = mdate();
    int delay = -1;
    int canc = vlc_savecancel();
    for (int i_client = 0; i_client < host->i_client; i_client++) {
        httpd_client_t *cl = host->client[i_client];
        int val = -1;

        switch (cl->i_state) {
            case HTTPD_CLIENT_RECEIVING:
                val = httpd_ClientRecv(cl);
                break;
            case HTTPD_CLIENT_SENDING:
                val = httpd_ClientSend(cl);
                break;
            case HTTPD_CLIENT_...",1699.0,2048.0,1.0,1.0,350.0,329,22,316,49,0,133,63,136,26,46,,0,106,2,1,1,void
3133,149213,httpd_StreamSetHTTPHeaders,1,httpd_StreamSetHTTPHeaders,"int httpd_StreamSetHTTPHeaders (httpd_stream_t*,httpd_header*,size_t)",network\httpd.c,"int httpd_StreamSetHTTPHeaders(httpd_stream_t * p_stream,
                               const httpd_header *p_headers, size_t i_headers)
{
    if (!p_stream)
        return VLC_EGENERIC;

    vlc_mutex_lock(&p_stream->lock);
    if (p_stream->p_http_headers) {
        for (size_t i = 0; i < p_stream->i_http_headers; i++) {
            free(p_stream->p_http_headers[i].name);
            free(p_stream->p_http_headers[i].value);
        }
        free(p_stream->p_http_headers);
        p_stream->p_http_headers = NULL;
        p_stream->i_http_headers = 0;
    }

    if (!p_headers || !i_headers) {
        vlc_mutex_unlock(&p_stream->lock);
        return VLC_SUCCESS;
    }

    p_stream->p_http_headers = vlc_alloc(i_headers, sizeof(httpd_header));
    if (!p_stream->p_http_headers) {
        vlc_mutex_unlock(&p_stream->lock);
        return VLC_ENOMEM;
    }

    size_t j = 0;
    for (size_t i = 0; i < i_headers; i++) {
        if (unlikely(!p_headers[i].name || !p_headers[i].value))...",2061.0,2108.0,1.0,1.0,48.0,72,10,54,10,0,24,11,12,5,4,,0,20,6,3,3,int
3134,149454,rootwrap_bind,1,rootwrap_bind,"int rootwrap_bind (int,int,int,sockaddr*,size_t)",network\rootbind.c,"int rootwrap_bind (int family, int socktype, int protocol,
                   const struct sockaddr *addr, size_t alen)
{
    /* can't use libvlc */
    static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
    struct sockaddr_storage ss;
    int fd, sock = -1;

    const char *sockenv = getenv (""VLC_ROOTWRAP_SOCK"");
    if (sockenv != NULL)
        sock = atoi (sockenv);
    if (sock == -1)
    {
        errno = EACCES;
        return -1;
    }

    switch (family)
    {
        case AF_INET:
            if (alen < sizeof (struct sockaddr_in))
            {
                errno = EINVAL;
                return -1;
            }
            break;

#ifdef AF_INET6
        case AF_INET6:
            if (alen < sizeof (struct sockaddr_in6))
            {
                errno = EINVAL;
                return -1;
            }
            break;
#endif

        default:
            errno = EAFNOSUPPORT;
            return -1;
    }

    if (family != addr->sa_family)
    {
       ...",115.0,184.0,1.0,38.0,70.0,0,0,0,0,1,0,1,1,0,0,,0,0,10,5,5,int
3135,149463,net_Socket,1,net_Socket,"int net_Socket (vlc_object_t*,int,int,int)",network\io.c,"int net_Socket (vlc_object_t *p_this, int family, int socktype,
                int protocol)
{
    int fd = vlc_socket (family, socktype, protocol, true);
    if (fd == -1)
    {
        if (net_errno != EAFNOSUPPORT)
            msg_Err (p_this, ""cannot create socket: %s"",
                     vlc_strerror_c(net_errno));
        return -1;
    }

    setsockopt (fd, SOL_SOCKET, SO_REUSEADDR, &(int){ 1 }, sizeof (int));

#ifdef IPV6_V6ONLY
    /*
     * Accepts only IPv6 connections on IPv6 sockets.
     * If possible, we should open two sockets, but it is not always possible.
     */
    if (family == AF_INET6)
        setsockopt (fd, IPPROTO_IPV6, IPV6_V6ONLY, &(int){ 1 }, sizeof (int));
#endif

#if defined (_WIN32)
# ifndef IPV6_PROTECTION_LEVEL
#  warning Please update your C library headers.
#  define IPV6_PROTECTION_LEVEL 23
#  define PROTECTION_LEVEL_UNRESTRICTED 10
# endif
    if (family == AF_INET6)
        setsockopt (fd, IPPROTO_IPV6, IPV6_PROTECTION_LEVEL,
             ...",55.0,103.0,1.0,1.0,49.0,9,8,15,11,5,2,3,4,0,2,,0,1,8,4,4,int
3136,149511,net_Listen,1,net_Listen,"int* net_Listen (vlc_object_t*,char*,int,int,int)",network\io.c,"int *net_Listen (vlc_object_t *p_this, const char *psz_host,
                 int i_port, int type, int protocol)
{
    struct addrinfo hints = {
        .ai_socktype = type,
        .ai_protocol = protocol,
        .ai_flags = AI_PASSIVE | AI_NUMERICSERV | AI_IDN,
    }, *res;

    msg_Dbg (p_this, ""net: listening to %s port %d"",
             (psz_host != NULL) ? psz_host : ""*"", i_port);

    int i_val = vlc_getaddrinfo (psz_host, i_port, &hints, &res);
    if (i_val)
    {
        msg_Err (p_this, ""Cannot resolve %s port %d : %s"",
                 (psz_host != NULL) ? psz_host : """", i_port,
                 gai_strerror (i_val));
        return NULL;
    }

    int *sockv = NULL;
    unsigned sockc = 0;

    for (struct addrinfo *ptr = res; ptr != NULL; ptr = ptr->ai_next)
    {
        int fd = net_Socket (p_this, ptr->ai_family, ptr->ai_socktype,
                             ptr->ai_protocol);
        if (fd == -1)
        {
            msg_Dbg (p_this, ""socket error: %s"", vlc_s...",106.0,225.0,1.0,1.0,120.0,54,15,90,27,0,6,15,23,1,6,,0,4,10,5,5,int*
3137,149772,net_Read,1,,"ssize_t (vlc_object_t*,int,void*,size_t)",network\io.c,"ssize_t (net_Read)(vlc_object_t *restrict obj, int fd,
                   void *restrict buf, size_t len)
{
    size_t rd = 0;

    do
    {
        if (vlc_killed())
        {
            vlc_testcancel();
            errno = EINTR;
            return -1;
        }

        ssize_t val = vlc_recv_i11e(fd, buf, len, 0);
        if (val < 0)
        {
            if (errno == EINTR || errno == EAGAIN)
                continue;
#ifdef _WIN32
            else if (WSAGetLastError() == WSAEMSGSIZE) /* datagram too big */
            {
                msg_Warn(obj, ""read truncated to %zu bytes"", len);
                val = len;
            }
#endif
            else
            {
                msg_Err(obj, ""read error: %s"", vlc_strerror_c(errno));
                return rd ? (ssize_t)rd : -1;
            }
        }

        rd += val;

        if (val == 0)
            break;

        assert(len >= (size_t)val);
        len -= val;
        buf = ((char *)buf) + val;
    }
    while (len...",233.0,278.0,1.0,1.0,46.0,17,11,24,8,0,2,8,11,1,2,,0,1,8,4,4,ssize_t
3138,149864,net_Write,1,,"ssize_t (vlc_object_t*,int,void*,size_t)",network\io.c,"ssize_t (net_Write)(vlc_object_t *obj, int fd, const void *buf, size_t len)
{
    size_t written = 0;

    do
    {
        if (vlc_killed())
        {
            vlc_testcancel();
            errno = EINTR;
            return -1;
        }

        ssize_t val = vlc_send_i11e (fd, buf, len, MSG_NOSIGNAL);
        if (val == -1)
        {
            if (errno == EINTR || errno == EAGAIN)
                continue;

            msg_Err(obj, ""write error: %s"", vlc_strerror_c(errno));
            return written ? (ssize_t)written : -1;
        }

        if (val == 0)
            break;

        written += val;
        assert(len >= (size_t)val);
        len -= val;
        buf = ((const char *)buf) + val;
    }
    while (len > 0);

    return written;
}",289.0,323.0,1.0,1.0,35.0,21,11,29,10,0,3,8,11,1,3,,0,1,8,4,4,ssize_t
3139,149955,net_Gets,1,net_Gets,"char* net_Gets (vlc_object_t*,int)",network\io.c,"char *net_Gets(vlc_object_t *obj, int fd)
{
    char *buf = NULL;
    size_t size = 0, len = 0;

    for (;;)
    {
        if (len == size)
        {
            if (unlikely(size >= (1 << 16)))
            {
                errno = EMSGSIZE;
                goto error; /* put sane buffer size limit */
            }

            char *newbuf = realloc(buf, size + 1024);
            if (unlikely(newbuf == NULL))
                goto error;
            buf = newbuf;
            size += 1024;
        }
        assert(len < size);

        ssize_t val = vlc_recv_i11e(fd, buf + len, size - len, MSG_PEEK);
        if (val <= 0)
            goto error;

        char *end = memchr(buf + len, '\n', val);
        if (end != NULL)
            val = (end + 1) - (buf + len);
        if (recv(fd, buf + len, val, 0) != val)
            goto error;
        len += val;
        if (end != NULL)
            break;
    }

    assert(len > 0);
    buf[--len] = '\0';
    if (len > 0 && buf[--len] == '\r...",336.0,382.0,1.0,1.0,47.0,39,14,59,12,0,1,15,19,0,1,,0,0,4,2,2,char*
3140,150119,net_Printf,1,net_Printf,"ssize_t net_Printf (vlc_object_t*,int,char*...)",network\io.c,"ssize_t net_Printf( vlc_object_t *p_this, int fd, const char *psz_fmt, ... )
{
    int i_ret;
    va_list args;
    va_start( args, psz_fmt );
    i_ret = net_vaPrintf( p_this, fd, psz_fmt, args );
    va_end( args );

    return i_ret;
}",385.0,394.0,1.0,1.0,10.0,1,1,9,5,0,1,1,1,0,1,,0,1,6,3,3,ssize_t
3141,150142,net_vaPrintf,1,net_vaPrintf,"ssize_t net_vaPrintf (vlc_object_t*,int,char*,va_list)",network\io.c,"ssize_t net_vaPrintf( vlc_object_t *p_this, int fd,
                      const char *psz_fmt, va_list args )
{
    char    *psz;
    int      i_ret;

    int i_size = vasprintf( &psz, psz_fmt, args );
    if( i_size == -1 )
        return -1;
    i_ret = net_Write( p_this, fd, psz, i_size ) < i_size
        ? -1 : i_size;
    free( psz );

    return i_ret;
}",397.0,411.0,1.0,1.0,15.0,9,6,14,7,1,0,2,2,0,0,,0,0,8,4,4,ssize_t
3142,150225,recv_fd,1,recv_fd,int recv_fd (int),network\rootbind.c,"static int recv_fd (int p)
{
    struct msghdr hdr;
    struct iovec iov;
    struct cmsghdr *cmsg;
    int val, fd;
    char buf[CMSG_SPACE (sizeof (fd))];

    hdr.msg_name = NULL;
    hdr.msg_namelen = 0;
    hdr.msg_iov = &iov;
    hdr.msg_iovlen = 1;
    hdr.msg_control = buf;
    hdr.msg_controllen = sizeof (buf);

    iov.iov_base = &val;
    iov.iov_len = sizeof (val);

    if (recvmsg (p, &hdr, 0) != sizeof (val))
        return -1;

    for (cmsg = CMSG_FIRSTHDR (&hdr); cmsg != NULL;
         cmsg = CMSG_NXTHDR (&hdr, cmsg))
    {
        if ((cmsg->cmsg_level == SOL_SOCKET)
         && (cmsg->cmsg_type == SCM_RIGHTS)
         && (cmsg->cmsg_len >= CMSG_LEN (sizeof (fd))))
        {
            memcpy (&fd, CMSG_DATA (cmsg), sizeof (fd));
            return fd;
        }
    }

    errno = val;
    return -1;
}",75.0,110.0,1.0,13.0,36.0,49,14,36,13,0,0,4,5,0,0,,0,0,2,1,1,int
3143,150535,SocksNegotiate,1,SocksNegotiate,"int SocksNegotiate (vlc_object_t*,int,int,char*,char*)",network\tcp.c,"static int SocksNegotiate( vlc_object_t *p_obj,
                           int fd, int i_socks_version,
                           const char *psz_socks_user,
                           const char *psz_socks_passwd )
{
    uint8_t buffer[128+2*256];
    int i_len;
    bool b_auth = false;

    if( i_socks_version != 5 )
        return VLC_SUCCESS;

    /* We negotiate authentication */
    buffer[0] = i_socks_version;    /* SOCKS version */
    if( psz_socks_user != NULL && psz_socks_passwd != NULL )
    {
        buffer[1] = 2;                  /* Number of methods */
        buffer[2] = 0x00;               /* - No auth required */
        buffer[3] = 0x02;               /* - USer/Password */
        i_len = 4;
        b_auth = true;
    }
    else
    {
        buffer[1] = 1;                  /* Number of methods */
        buffer[2] = 0x00;               /* - No auth required */
        i_len = 3;
    }

    if( net_Write( p_obj, fd, buffer, i_len ) != i_len )
        return VLC_...",329.0,422.0,1.0,1.0,94.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,int
3144,150544,SocksHandshakeTCP,1,SocksHandshakeTCP,"int SocksHandshakeTCP (vlc_object_t*,int,int,char*,char*,char*,int)",network\tcp.c,"static int SocksHandshakeTCP( vlc_object_t *p_obj,
                              int fd,
                              int i_socks_version,
                              const char *psz_user, const char *psz_passwd,
                              const char *psz_host, int i_port )
{
    uint8_t buffer[128+2*256];

    if( i_socks_version != 4 && i_socks_version != 5 )
    {
        msg_Warn( p_obj, ""invalid socks protocol version %d"", i_socks_version );
        i_socks_version = 5;
    }

    if( i_socks_version == 5 &&
        SocksNegotiate( p_obj, fd, i_socks_version,
                        psz_user, psz_passwd ) )
        return VLC_EGENERIC;

    if( i_socks_version == 4 )
    {
        /* v4 only support ipv4 */
        static const struct addrinfo hints = {
            .ai_family = AF_INET,
            .ai_socktype = SOCK_STREAM,
            .ai_protocol = IPPROTO_TCP,
            .ai_flags = AI_IDN,
        };
        struct addrinfo *res;

        if (vlc_getaddrinfo_i11e(p...",429.0,530.0,1.0,1.0,102.0,0,0,0,0,1,0,1,1,0,0,,0,0,14,7,7,int
3145,150563,net_Connect,1,net_Connect,"int net_Connect (vlc_object_t*,char*,int,int,int)",network\tcp.c,"int net_Connect( vlc_object_t *p_this, const char *psz_host, int i_port,
                 int type, int proto )
{
    const char      *psz_realhost;
    char            *psz_socks;
    int             i_realport, i_handle = -1;

    psz_socks = var_InheritString( p_this, ""socks"" );
    if( psz_socks != NULL )
    {
        char *psz = strchr( psz_socks, ':' );

        if( psz )
            *psz++ = '\0';

        psz_realhost = psz_socks;
        i_realport = ( psz != NULL ) ? atoi( psz ) : 1080;

        msg_Dbg( p_this, ""net: connecting to %s port %d (SOCKS) ""
                 ""for %s port %d"", psz_realhost, i_realport,
                 psz_host, i_port );

        /* We only implement TCP with SOCKS */
        switch( type )
        {
            case 0:
                type = SOCK_STREAM;
            case SOCK_STREAM:
                break;
            default:
                msg_Err( p_this, ""Socket type not supported through SOCKS"" );
                free( psz_socks );
     ...",70.0,239.0,1.0,1.0,170.0,76,21,133,38,0,11,27,38,2,11,,0,7,10,5,5,int
3146,150959,net_AcceptSingle,1,net_AcceptSingle,"int net_AcceptSingle (vlc_object_t*,int)",network\tcp.c,"int net_AcceptSingle (vlc_object_t *obj, int lfd)
{
    int fd = vlc_accept (lfd, NULL, NULL, true);
    if (fd == -1)
    {
        if (net_errno != EAGAIN)
#if (EAGAIN != EWOULDBLOCK)
          if (net_errno != EWOULDBLOCK)
#endif
            msg_Err (obj, ""accept failed (from socket %d): %s"", lfd,
                     vlc_strerror_c(net_errno));
        return -1;
    }

    msg_Dbg (obj, ""accepted socket %d (from socket %d)"", fd, lfd);
    setsockopt (fd, SOL_SOCKET, SO_REUSEADDR, &(int){ 1 }, sizeof(int));
    return fd;
}",242.0,259.0,1.0,1.0,18.0,9,8,19,10,1,2,3,4,0,2,,0,1,4,2,2,int
3147,151011,net_Accept,1,net_Accept,"int net_Accept (vlc_object_t*,int*)",network\tcp.c,"int net_Accept (vlc_object_t *p_this, int *pi_fd)
{
    assert (pi_fd != NULL);

    unsigned n = 0;
    while (pi_fd[n] != -1)
        n++;

    struct pollfd ufd[n];
    /* Initialize file descriptor set */
    for (unsigned i = 0; i < n; i++)
    {
        ufd[i].fd = pi_fd[i];
        ufd[i].events = POLLIN;
    }

    for (;;)
    {
        while (poll (ufd, n, -1) == -1)
        {
            if (net_errno != EINTR)
            {
                msg_Err (p_this, ""poll error: %s"", vlc_strerror_c(net_errno));
                return -1;
            }
        }

        for (unsigned i = 0; i < n; i++)
        {
            if (ufd[i].revents == 0)
                continue;

            int sfd = ufd[i].fd;
            int fd = net_AcceptSingle (p_this, sfd);
            if (fd == -1)
                continue;

            /*
             * Move listening socket to the end to let the others in the
             * set a chance next time.
             */
            memmove (pi_fd + ...",274.0,321.0,1.0,1.0,48.0,39,9,43,11,0,2,11,17,0,2,,0,1,4,2,2,int
3148,151753,net_ListenClose,1,net_ListenClose,void net_ListenClose (int*),network\tcp.c,"void net_ListenClose( int *pi_fd )
{
    if( pi_fd != NULL )
    {
        int *pi;

        for( pi = pi_fd; *pi != -1; pi++ )
            net_Close( *pi );
        free( pi_fd );
    }
}",532.0,542.0,1.0,1.0,11.0,5,4,6,3,1,0,3,4,0,0,,0,0,2,1,1,void
3149,151814,tls_server_load,1,tls_server_load,"int tls_server_load (void*,va_list)",network\tls.c,"static int tls_server_load(void *func, va_list ap)
{
    int (*activate) (vlc_tls_creds_t *, const char *, const char *) = func;
    vlc_tls_creds_t *crd = va_arg (ap, vlc_tls_creds_t *);
    const char *cert = va_arg (ap, const char *);
    const char *key = va_arg (ap, const char *);

    return activate (crd, cert, key);
}",60.0,68.0,1.0,1.0,9.0,0,0,3,3,0,0,1,1,0,0,,0,0,4,2,2,int
3150,151818,activate,1,tls_server_load.activate,"int tls_server_load.activate (vlc_tls_creds_t*,char*,char*)",network\tls.c,"int (*activate) (vlc_tls_creds_t *, const char *, const char *) = func;",62.0,62.0,9.0,74.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
3151,151835,tls_client_load,1,tls_client_load,"int tls_client_load (void*,va_list)",network\tls.c,"static int tls_client_load(void *func, va_list ap)
{
    int (*activate) (vlc_tls_creds_t *) = func;
    vlc_tls_creds_t *crd = va_arg (ap, vlc_tls_creds_t *);

    return activate (crd);
}",70.0,76.0,1.0,1.0,7.0,0,0,1,1,0,0,1,1,0,0,,0,0,4,2,2,int
3152,151839,activate,1,tls_client_load.activate,int tls_client_load.activate (vlc_tls_creds_t*),network\tls.c,int (*activate) (vlc_tls_creds_t *) = func;,72.0,72.0,9.0,46.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
3153,151850,tls_unload,1,tls_unload,"void tls_unload (void*,va_list)",network\tls.c,"static void tls_unload(void *func, va_list ap)
{
    void (*deactivate) (vlc_tls_creds_t *) = func;
    vlc_tls_creds_t *crd = va_arg (ap, vlc_tls_creds_t *);

    deactivate (crd);
}",78.0,84.0,1.0,1.0,7.0,0,0,1,1,0,0,1,1,0,0,,0,0,4,2,2,void
3154,151854,deactivate,1,tls_unload.deactivate,void tls_unload.deactivate (vlc_tls_creds_t*),network\tls.c,void (*deactivate) (vlc_tls_creds_t *) = func;,80.0,80.0,10.0,49.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
3155,151864,vlc_tls_ServerCreate,1,vlc_tls_ServerCreate,"vlc_tls_creds_t vlc_tls_ServerCreate (vlc_object_t*,char*,char*)",network\tls.c,"vlc_tls_creds_t *
vlc_tls_ServerCreate (vlc_object_t *obj, const char *cert_path,
                      const char *key_path)
{
    vlc_tls_creds_t *srv = vlc_custom_create (obj, sizeof (*srv),
                                              ""tls server"");
    if (unlikely(srv == NULL))
        return NULL;

    if (key_path == NULL)
        key_path = cert_path;

    srv->module = vlc_module_load (srv, ""tls server"", NULL, false,
                                   tls_server_load, srv, cert_path, key_path);
    if (srv->module == NULL)
    {
        msg_Err (srv, ""TLS server plugin not available"");
        vlc_object_release (srv);
        return NULL;
    }

    return srv;
}",86.0,108.0,1.0,27.0,23.0,10,5,24,6,1,3,4,4,0,3,,0,2,6,3,3,vlc_tls_creds_t
3156,151929,vlc_tls_ClientCreate,1,vlc_tls_ClientCreate,vlc_tls_creds_t vlc_tls_ClientCreate (vlc_object_t*),network\tls.c,"vlc_tls_creds_t *vlc_tls_ClientCreate (vlc_object_t *obj)
{
    vlc_tls_creds_t *crd = vlc_custom_create (obj, sizeof (*crd),
                                              ""tls client"");
    if (unlikely(crd == NULL))
        return NULL;

    crd->module = vlc_module_load (crd, ""tls client"", NULL, false,
                                   tls_client_load, crd);
    if (crd->module == NULL)
    {
        msg_Err (crd, ""TLS client plugin not available"");
        vlc_object_release (crd);
        return NULL;
    }

    return crd;
}",110.0,127.0,1.0,27.0,18.0,8,5,18,4,0,3,3,3,0,3,,0,2,2,1,1,vlc_tls_creds_t
3157,151982,vlc_tls_Delete,1,vlc_tls_Delete,void vlc_tls_Delete (vlc_tls_creds_t*),network\tls.c,"void vlc_tls_Delete (vlc_tls_creds_t *crd)
{
    if (crd == NULL)
        return;

    vlc_module_unload(crd, crd->module, tls_unload, crd);
    vlc_object_release (crd);
}",129.0,136.0,1.0,1.0,8.0,2,2,6,2,1,2,2,2,0,2,,0,0,2,1,1,void
3158,152002,vlc_tls_SessionCreate,1,vlc_tls_SessionCreate,"vlc_tls_t vlc_tls_SessionCreate (vlc_tls_creds_t*,vlc_tls_t*,char*,char**)",network\tls.c,"static vlc_tls_t *vlc_tls_SessionCreate(vlc_tls_creds_t *crd,
                                        vlc_tls_t *sock,
                                        const char *host,
                                        const char *const *alpn)
{
    vlc_tls_t *session;
    int canc = vlc_savecancel();
    session = crd->open(crd, sock, host, alpn);
    vlc_restorecancel(canc);
    if (session != NULL)
        session->p = sock;
    return session;
}",141.0,153.0,1.0,1.0,13.0,6,3,13,7,2,2,2,2,0,2,,0,1,8,4,4,vlc_tls_t
3159,152039,vlc_tls_SessionDelete,1,vlc_tls_SessionDelete,void vlc_tls_SessionDelete (vlc_tls_t*),network\tls.c,"void vlc_tls_SessionDelete (vlc_tls_t *session)
{
    int canc = vlc_savecancel();
    session->close(session);
    vlc_restorecancel(canc);
}",155.0,160.0,1.0,1.0,6.0,2,2,4,2,5,2,1,1,0,2,,0,1,2,1,1,void
3160,152055,cleanup_tls,1,cleanup_tls,void cleanup_tls (void*),network\tls.c,"static void cleanup_tls(void *data)
{
    vlc_tls_t *session = data;

    vlc_tls_SessionDelete (session);
}",162.0,167.0,1.0,1.0,6.0,1,1,3,2,0,1,1,1,0,1,,0,0,2,1,1,void
3161,152066,vlc_tls_ClientSessionCreate,1,vlc_tls_ClientSessionCreate,"vlc_tls_t vlc_tls_ClientSessionCreate (vlc_tls_creds_t*,vlc_tls_t*,char*,char*,char**,char**)",network\tls.c,"vlc_tls_t *vlc_tls_ClientSessionCreate(vlc_tls_creds_t *crd, vlc_tls_t *sock,
                                       const char *host, const char *service,
                                       const char *const *alpn, char **alp)
{
    int val;

    vlc_tls_t *session = vlc_tls_SessionCreate(crd, sock, host, alpn);
    if (session == NULL)
        return NULL;

    int canc = vlc_savecancel();
    mtime_t deadline = mdate ();
    deadline += var_InheritInteger (crd, ""ipv4-timeout"") * 1000;

    struct pollfd ufd[1];
    ufd[0].fd = vlc_tls_GetFD(sock);

    vlc_cleanup_push (cleanup_tls, session);
    while ((val = crd->handshake(crd, session, host, service, alp)) != 0)
    {
        if (val < 0 || vlc_killed() )
        {
            if (val < 0)
                msg_Err(crd, ""TLS session handshake error"");
error:
            vlc_tls_SessionDelete (session);
            session = NULL;
            break;
        }

        mtime_t now = mdate ();
        if (now > deadline)
      ...",170.0,219.0,1.0,1.0,50.0,30,15,48,15,1,10,9,12,1,10,,0,7,12,6,6,vlc_tls_t
3162,152213,vlc_tls_ServerSessionCreate,1,vlc_tls_ServerSessionCreate,"vlc_tls_t vlc_tls_ServerSessionCreate (vlc_tls_creds_t*,vlc_tls_t*,char**)",network\tls.c,"vlc_tls_t *vlc_tls_ServerSessionCreate(vlc_tls_creds_t *crd,
                                       vlc_tls_t *sock,
                                       const char *const *alpn)
{
    return vlc_tls_SessionCreate(crd, sock, NULL, alpn);
}",221.0,226.0,1.0,1.0,6.0,0,0,4,4,1,1,1,1,0,1,,0,0,6,3,3,vlc_tls_t
3163,152226,vlc_tls_Read,1,vlc_tls_Read,"ssize_t vlc_tls_Read (vlc_tls_t*,void*,size_t,bool)",network\tls.c,"ssize_t vlc_tls_Read(vlc_tls_t *session, void *buf, size_t len, bool waitall)
{
    struct pollfd ufd;
    struct iovec iov;

    ufd.fd = vlc_tls_GetFD(session);
    ufd.events = POLLIN;
    iov.iov_base = buf;
    iov.iov_len = len;

    for (size_t rcvd = 0;;)
    {
        if (vlc_killed())
        {
            errno = EINTR;
            return -1;
        }

        ssize_t val = session->readv(session, &iov, 1);
        if (val > 0)
        {
            if (!waitall)
                return val;
            iov.iov_base = (char *)iov.iov_base + val;
            iov.iov_len -= val;
            rcvd += val;
        }
        if (iov.iov_len == 0 || val == 0)
            return rcvd;
        if (val == -1)
        {
            if (vlc_killed())
                return -1;
            if (errno != EINTR && errno != EAGAIN)
                return rcvd ? (ssize_t)rcvd : -1;
        }

        vlc_poll_i11e(&ufd, 1, -1);
    }
}",228.0,267.0,1.0,1.0,40.0,39,16,36,12,1,3,9,19,2,3,,0,2,8,4,4,ssize_t
3164,152362,vlc_tls_Write,1,vlc_tls_Write,"ssize_t vlc_tls_Write (vlc_tls_t*,void*,size_t)",network\tls.c,"ssize_t vlc_tls_Write(vlc_tls_t *session, const void *buf, size_t len)
{
    struct pollfd ufd;
    struct iovec iov;

    ufd.fd = vlc_tls_GetFD(session);
    ufd.events = POLLOUT;
    iov.iov_base = (void *)buf;
    iov.iov_len = len;

    for (size_t sent = 0;;)
    {
        if (vlc_killed())
        {
            errno = EINTR;
            return -1;
        }

        ssize_t val = session->writev(session, &iov, 1);
        if (val > 0)
        {
            iov.iov_base = ((char *)iov.iov_base) + val;
            iov.iov_len -= val;
            sent += val;
        }
        if (iov.iov_len == 0 || val == 0)
            return sent;
        if (val == -1)
        {
            if (vlc_killed())
                return -1;
            if (errno != EINTR && errno != EAGAIN)
                return sent ? (ssize_t)sent : -1;
        }

        vlc_poll_i11e(&ufd, 1, -1);
    }
}",269.0,306.0,1.0,1.0,38.0,39,15,34,11,0,3,8,16,2,3,,0,2,6,3,3,ssize_t
3165,152493,vlc_tls_GetLine,1,vlc_tls_GetLine,char* vlc_tls_GetLine (vlc_tls_t*),network\tls.c,"char *vlc_tls_GetLine(vlc_tls_t *session)
{
    char *line = NULL;
    size_t linelen = 0, linesize = 0;

    do
    {
        if (linelen == linesize)
        {
            linesize += 1024;

            char *newline = realloc(line, linesize);
            if (unlikely(newline == NULL))
                goto error;
            line = newline;
        }

        if (vlc_tls_Read(session, line + linelen, 1, false) <= 0)
            goto error;
    }
    while (line[linelen++] != '\n');

    if (linelen >= 2 && line[linelen - 2] == '\r')
        line[linelen - 2] = '\0';
    else
        line[linelen - 1] = '\0';
    return line;

error:
    free(line);
    return NULL;
}",308.0,339.0,1.0,1.0,32.0,21,11,28,7,0,1,8,10,1,1,,0,1,2,1,1,char*
3166,152603,vlc_tls_SocketGetFD,1,vlc_tls_SocketGetFD,int vlc_tls_SocketGetFD (vlc_tls_t*),network\tls.c,"static int vlc_tls_SocketGetFD(vlc_tls_t *tls)
{
    vlc_tls_socket_t *sock = (struct vlc_tls_socket *)tls;

    return sock->fd;
}",349.0,354.0,1.0,1.0,6.0,3,3,3,2,4,0,1,1,0,0,,0,0,2,1,1,int
3167,152618,vlc_tls_SocketRead,1,vlc_tls_SocketRead,"ssize_t vlc_tls_SocketRead (vlc_tls_t*,iovec*,unsigned)",network\tls.c,"static ssize_t vlc_tls_SocketRead(vlc_tls_t *tls, struct iovec *iov,
                                  unsigned count)
{
    struct msghdr msg =
    {
        .msg_iov = iov,
        .msg_iovlen = count,
    };

    return recvmsg(vlc_tls_SocketGetFD(tls), &msg, 0);
}",356.0,366.0,1.0,1.0,11.0,5,3,7,6,0,1,1,1,0,1,,0,0,6,3,3,ssize_t
3168,152644,vlc_tls_SocketWrite,1,vlc_tls_SocketWrite,"ssize_t vlc_tls_SocketWrite (vlc_tls_t*,iovec*,unsigned)",network\tls.c,"static ssize_t vlc_tls_SocketWrite(vlc_tls_t *tls, const struct iovec *iov,
                                   unsigned count)
{
    const struct msghdr msg =
    {
        .msg_iov = (struct iovec *)iov,
        .msg_iovlen = count,
    };

    return sendmsg(vlc_tls_SocketGetFD(tls), &msg, MSG_NOSIGNAL);
}",368.0,378.0,1.0,1.0,11.0,6,4,8,7,1,1,1,1,0,1,,0,0,6,3,3,ssize_t
3169,152672,vlc_tls_SocketShutdown,1,vlc_tls_SocketShutdown,"int vlc_tls_SocketShutdown (vlc_tls_t*,bool)",network\tls.c,"static int vlc_tls_SocketShutdown(vlc_tls_t *tls, bool duplex)
{
    return shutdown(vlc_tls_SocketGetFD(tls), duplex ? SHUT_RDWR : SHUT_WR);
}",380.0,383.0,1.0,1.0,4.0,1,1,4,4,0,1,1,1,0,1,,0,0,4,2,2,int
3170,152686,vlc_tls_SocketClose,1,vlc_tls_SocketClose,void vlc_tls_SocketClose (vlc_tls_t*),network\tls.c,"static void vlc_tls_SocketClose(vlc_tls_t *tls)
{
    net_Close(vlc_tls_SocketGetFD(tls));
    free(tls);
}",385.0,389.0,1.0,1.0,5.0,0,0,2,1,0,1,1,1,0,1,,0,0,2,1,1,void
3171,152696,vlc_tls_SocketAlloc,1,vlc_tls_SocketAlloc,"vlc_tls_t vlc_tls_SocketAlloc (int,sockaddr*,socklen_t)",network\tls.c,"static vlc_tls_t *vlc_tls_SocketAlloc(int fd,
                                      const struct sockaddr *restrict peer,
                                      socklen_t peerlen)
{
    vlc_tls_socket_t *sock = malloc(sizeof (*sock) + peerlen);
    if (unlikely(sock == NULL))
        return NULL;

    vlc_tls_t *tls = &sock->tls;

    tls->get_fd = vlc_tls_SocketGetFD;
    tls->readv = vlc_tls_SocketRead;
    tls->writev = vlc_tls_SocketWrite;
    tls->shutdown = vlc_tls_SocketShutdown;
    tls->close = vlc_tls_SocketClose;
    tls->p = NULL;

    sock->fd = fd;
    sock->peerlen = peerlen;
    if (peerlen > 0)
        memcpy(sock->peer, peer, peerlen);
    return tls;
}",391.0,413.0,1.0,1.0,23.0,26,8,24,6,3,0,3,3,0,0,,0,0,6,3,3,vlc_tls_t
3172,152780,vlc_tls_SocketOpen,1,vlc_tls_SocketOpen,vlc_tls_t vlc_tls_SocketOpen (int),network\tls.c,"vlc_tls_t *vlc_tls_SocketOpen(int fd)
{
    return vlc_tls_SocketAlloc(fd, NULL, 0);
}",415.0,418.0,1.0,1.0,4.0,0,0,2,2,1,1,1,1,0,1,,0,0,2,1,1,vlc_tls_t
3173,152790,vlc_tls_SocketPair,1,vlc_tls_SocketPair,"int vlc_tls_SocketPair (int,int,vlc_tls_t[2]*)",network\tls.c,"int vlc_tls_SocketPair(int family, int protocol, vlc_tls_t *pair[2])
{
    int fds[2];

    if (vlc_socketpair(family, SOCK_STREAM, protocol, fds, true))
        return -1;

    for (size_t i = 0; i < 2; i++)
    {
        setsockopt(fds[i], SOL_SOCKET, SO_REUSEADDR,
                   &(int){ 1 }, sizeof (int));

        pair[i] = vlc_tls_SocketAlloc(fds[i], NULL, 0);
        if (unlikely(pair[i] == NULL))
        {
            net_Close(fds[i]);
            if (i)
                vlc_tls_SessionDelete(pair[0]);
            else
                net_Close(fds[1]);
            return -1;
        }
    }
    return 0;
}",420.0,444.0,1.0,1.0,25.0,16,9,24,11,0,3,5,8,1,3,,0,2,6,3,3,int
3174,152874,vlc_tls_SocketAddrInfo,1,vlc_tls_SocketAddrInfo,vlc_tls_t vlc_tls_SocketAddrInfo (addrinfo*),network\tls.c,"static vlc_tls_t *vlc_tls_SocketAddrInfo(const struct addrinfo *restrict info)
{
    int fd = vlc_socket(info->ai_family, info->ai_socktype, info->ai_protocol,
                        true /* nonblocking */);
    if (fd == -1)
        return NULL;

    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &(int){ 1 }, sizeof (int));

    if (info->ai_socktype == SOCK_STREAM && info->ai_protocol == IPPROTO_TCP)
        setsockopt(fd, SOL_TCP, TCP_NODELAY, &(int){ 1 }, sizeof (int));

    vlc_tls_t *sk = vlc_tls_SocketAlloc(fd, info->ai_addr, info->ai_addrlen);
    if (unlikely(sk == NULL))
        net_Close(fd);
    return sk;
}",449.0,465.0,1.0,23.0,17.0,23,9,27,11,1,2,4,4,0,2,,0,2,2,1,1,vlc_tls_t
3175,152959,vlc_tls_WaitConnect,1,vlc_tls_WaitConnect,int vlc_tls_WaitConnect (vlc_tls_t*),network\tls.c,"static int vlc_tls_WaitConnect(vlc_tls_t *tls)
{
    const int fd = vlc_tls_GetFD(tls);
    struct pollfd ufd;

    ufd.fd = fd;
    ufd.events = POLLOUT;

    do
    {
        if (vlc_killed())
        {
            errno = EINTR;
            return -1;
        }
    }
    while (vlc_poll_i11e(&ufd, 1, -1) <= 0);

    int val;
    socklen_t len = sizeof (val);

    if (getsockopt(fd, SOL_SOCKET, SO_ERROR, &val, &len))
        return -1;

    if (val != 0)
    {
        errno = val;
        return -1;
    }
    return 0;
}",470.0,500.0,1.0,1.0,31.0,18,7,19,10,1,2,5,6,2,2,,0,2,2,1,1,int
3176,153031,vlc_tls_Connect,1,vlc_tls_Connect,ssize_t vlc_tls_Connect (vlc_tls_t*),network\tls.c,"static ssize_t vlc_tls_Connect(vlc_tls_t *tls)
{
    const vlc_tls_socket_t *sock = (vlc_tls_socket_t *)tls;

    if (connect(sock->fd, sock->peer, sock->peerlen) == 0)
        return 0;
#ifndef _WIN32
    if (errno != EINPROGRESS)
        return -1;
#else
    if (WSAGetLastError() != WSAEWOULDBLOCK)
        return -1;
#endif
    return vlc_tls_WaitConnect(tls);
}",505.0,519.0,1.0,1.0,15.0,8,6,8,4,1,1,3,3,0,1,,0,0,2,1,1,ssize_t
3177,153069,vlc_tls_ConnectWrite,1,vlc_tls_ConnectWrite,"ssize_t vlc_tls_ConnectWrite (vlc_tls_t*,iovec*,unsigned)",network\tls.c,"static ssize_t vlc_tls_ConnectWrite(vlc_tls_t *tls,
                                    const struct iovec *iov,unsigned count)
{
#ifdef MSG_FASTOPEN
    vlc_tls_socket_t *sock = (vlc_tls_socket_t *)tls;
    const struct msghdr msg =
    {
        .msg_name = sock->peer,
        .msg_namelen = sock->peerlen,
        .msg_iov = (struct iovec *)iov,
        .msg_iovlen = count,
    };
    ssize_t ret;

    /* Next time, write directly. Do not retry to connect. */
    tls->writev = vlc_tls_SocketWrite;

    ret = sendmsg(vlc_tls_SocketGetFD(tls), &msg, MSG_NOSIGNAL|MSG_FASTOPEN);
    if (ret >= 0)
    {   /* Fast open in progress */
        return ret;
    }

    if (errno == EINPROGRESS)
    {
        if (vlc_tls_WaitConnect(tls))
            return -1;
    }
    else
    if (errno != EOPNOTSUPP)
        return -1;
    /* Fast open not supported or disabled... fallback to normal mode */
#else
    tls->writev = vlc_tls_SocketWrite;
#endif

    if (vlc_tls_Connect(tls))
        return -...",522.0,562.0,1.0,1.0,41.0,3,3,5,3,0,2,2,2,1,2,,0,1,6,3,3,ssize_t
3178,153093,vlc_tls_SocketOpenAddrInfo,1,vlc_tls_SocketOpenAddrInfo,"vlc_tls_t vlc_tls_SocketOpenAddrInfo (addrinfo*,bool)",network\tls.c,"vlc_tls_t *vlc_tls_SocketOpenAddrInfo(const struct addrinfo *restrict info,
                                      bool defer_connect)
{
    vlc_tls_t *sock = vlc_tls_SocketAddrInfo(info);
    if (sock == NULL)
        return NULL;

    if (defer_connect)
    {   /* The socket is not connected yet.
         * The connection will be triggered on the first send. */
        sock->writev = vlc_tls_ConnectWrite;
    }
    else
    {
        if (vlc_tls_Connect(sock))
        {
            vlc_tls_SessionDelete(sock);
            sock = NULL;
        }
    }
    return sock;
}",564.0,585.0,1.0,1.0,22.0,4,3,8,4,2,1,3,3,0,1,,0,1,4,2,2,vlc_tls_t
3179,153132,vlc_tls_SocketOpenTCP,1,vlc_tls_SocketOpenTCP,"vlc_tls_t vlc_tls_SocketOpenTCP (vlc_object_t*,char*,unsigned)",network\tls.c,"vlc_tls_t *vlc_tls_SocketOpenTCP(vlc_object_t *obj, const char *name,
                                 unsigned port)
{
    struct addrinfo hints =
    {
        .ai_socktype = SOCK_STREAM,
        .ai_protocol = IPPROTO_TCP,
    }, *res;

    assert(name != NULL);
    msg_Dbg(obj, ""resolving %s ..."", name);

    int val = vlc_getaddrinfo_i11e(name, port, &hints, &res);
    if (val != 0)
    {   /* TODO: C locale for gai_strerror() */
        msg_Err(obj, ""cannot resolve %s port %u: %s"", name, port,
                gai_strerror(val));
        return NULL;
    }

    msg_Dbg(obj, ""connecting to %s port %u ..."", name, port);

    /* TODO: implement RFC6555 */
    for (const struct addrinfo *p = res; p != NULL; p = p->ai_next)
    {
        vlc_tls_t *tls = vlc_tls_SocketOpenAddrInfo(p, false);
        if (tls == NULL)
        {
            msg_Err(obj, ""connection error: %s"", vlc_strerror_c(errno));
            continue;
        }

        freeaddrinfo(res);
        return tls;
    }
...",587.0,625.0,1.0,1.0,39.0,13,5,38,15,0,3,5,5,0,3,,0,2,6,3,3,vlc_tls_t
3180,153229,vlc_tls_SocketOpenTLS,1,vlc_tls_SocketOpenTLS,"vlc_tls_t vlc_tls_SocketOpenTLS (vlc_tls_creds_t*,char*,unsigned,char*,char**,char**)",network\tls.c,"vlc_tls_t *vlc_tls_SocketOpenTLS(vlc_tls_creds_t *creds, const char *name,
                                 unsigned port, const char *service,
                                 const char *const *alpn, char **alp)
{
    struct addrinfo hints =
    {
        .ai_socktype = SOCK_STREAM,
        .ai_protocol = IPPROTO_TCP,
    }, *res;

    msg_Dbg(creds, ""resolving %s ..."", name);

    int val = vlc_getaddrinfo_i11e(name, port, &hints, &res);
    if (val != 0)
    {   /* TODO: C locale for gai_strerror() */
        msg_Err(creds, ""cannot resolve %s port %u: %s"", name, port,
                gai_strerror(val));
        return NULL;
    }

    for (const struct addrinfo *p = res; p != NULL; p = p->ai_next)
    {
        vlc_tls_t *tcp = vlc_tls_SocketOpenAddrInfo(p, true);
        if (tcp == NULL)
        {
            msg_Err(creds, ""socket error: %s"", vlc_strerror_c(errno));
            continue;
        }

        vlc_tls_t *tls = vlc_tls_ClientSessionCreate(creds, tcp, name, service,...",627.0,671.0,1.0,1.0,45.0,14,5,45,19,0,6,6,7,0,6,,0,3,12,6,6,vlc_tls_t
3181,153375,net_SetupDgramSocket,1,net_SetupDgramSocket,"int net_SetupDgramSocket (vlc_object_t*,int,addrinfo*)",network\udp.c,"static int net_SetupDgramSocket (vlc_object_t *p_obj, int fd,
                                 const struct addrinfo *ptr)
{
#if defined (SO_REUSEPORT) && !defined (__linux__)
    setsockopt (fd, SOL_SOCKET, SO_REUSEPORT, &(int){ 1 }, sizeof (int));
#endif

#if defined (_WIN32)

    /* Check windows version so we know if we need to increase receive buffers
     * for Windows 7 and earlier

     * SetSocketMediaStreamingMode is present in win 8 and later, so we set
     * receive buffer if that isn't present
     */
#if (_WIN32_WINNT < _WIN32_WINNT_WIN8)
    HINSTANCE h_Network = LoadLibrary(TEXT(""Windows.Networking.dll""));
    if( (h_Network == NULL) ||
        (GetProcAddress( h_Network, ""SetSocketMediaStreamingMode"" ) == NULL ) )
    {
        setsockopt (fd, SOL_SOCKET, SO_RCVBUF,
                         (void *)&(int){ 0x80000 }, sizeof (int));
    }
    if( h_Network )
        FreeLibrary( h_Network );
#endif

    if (net_SockAddrIsMulticast (ptr->ai_addr, ptr->ai_addrlen)
   ...",93.0,141.0,1.0,1.0,49.0,3,2,7,4,2,1,2,2,0,1,,0,0,6,3,3,int
3182,153404,net_ListenSingle,1,net_ListenSingle,"int net_ListenSingle (vlc_object_t*,char*,int,int)",network\udp.c,"static int net_ListenSingle (vlc_object_t *obj, const char *host, int port,
                             int protocol)
{
    struct addrinfo hints = {
        .ai_socktype = SOCK_DGRAM,
        .ai_protocol = protocol,
        .ai_flags = AI_PASSIVE | AI_NUMERICSERV | AI_IDN,
    }, *res;

    if (host && !*host)
        host = NULL;

    msg_Dbg (obj, ""net: opening %s datagram port %d"",
             host ? host : ""any"", port);

    int val = vlc_getaddrinfo (host, port, &hints, &res);
    if (val)
    {
        msg_Err (obj, ""Cannot resolve %s port %d : %s"", host, port,
                 gai_strerror (val));
        return -1;
    }

    val = -1;

    for (const struct addrinfo *ptr = res; ptr != NULL; ptr = ptr->ai_next)
    {
        int fd = net_Socket (obj, ptr->ai_family, ptr->ai_socktype,
                             ptr->ai_protocol);
        if (fd == -1)
        {
            msg_Dbg (obj, ""socket error: %s"", vlc_strerror_c(net_errno));
            continue;
        }

#if...",144.0,201.0,1.0,1.0,58.0,35,12,56,18,1,5,11,10,1,5,,0,4,8,4,4,int
3183,153562,net_SetMcastHopLimit,1,net_SetMcastHopLimit,"int net_SetMcastHopLimit (vlc_object_t*,int,int,int)",network\udp.c,"static int net_SetMcastHopLimit( vlc_object_t *p_this,
                                 int fd, int family, int hlim )
{
    int proto, cmd;

    /* There is some confusion in the world whether IP_MULTICAST_TTL
     * takes a byte or an int as an argument.
     * BSD seems to indicate byte so we are going with that and use
     * int as a fallback to be safe */
    switch( family )
    {
#ifdef IP_MULTICAST_TTL
        case AF_INET:
            proto = SOL_IP;
            cmd = IP_MULTICAST_TTL;
            break;
#endif

#ifdef IPV6_MULTICAST_HOPS
        case AF_INET6:
            proto = SOL_IPV6;
            cmd = IPV6_MULTICAST_HOPS;
            break;
#endif

        default:
            errno = EAFNOSUPPORT;
            msg_Warn( p_this, ""%s"", vlc_strerror_c(EAFNOSUPPORT) );
            return VLC_EGENERIC;
    }

    if( setsockopt( fd, proto, cmd, &hlim, sizeof( hlim ) ) < 0 )
    {
        /* BSD compatibility */
        unsigned char buf;

        msg_Dbg( p_this, ""cannot...",204.0,252.0,1.0,1.0,49.0,10,7,27,12,1,3,4,5,0,3,,0,0,8,4,4,int
3184,153635,net_SetMcastOut,1,net_SetMcastOut,"int net_SetMcastOut (vlc_object_t*,int,int,char*)",network\udp.c,"static int net_SetMcastOut (vlc_object_t *p_this, int fd, int family,
                            const char *iface)
{
    int scope = if_nametoindex (iface);
    if (scope == 0)
    {
        msg_Err (p_this, ""invalid multicast interface: %s"", iface);
        return -1;
    }

    switch (family)
    {
#ifdef IPV6_MULTICAST_IF
        case AF_INET6:
            if (setsockopt (fd, SOL_IPV6, IPV6_MULTICAST_IF,
                            &scope, sizeof (scope)) == 0)
                return 0;
            break;
#endif

#ifdef __linux__
        case AF_INET:
        {
            struct ip_mreqn req = { .imr_ifindex = scope };
            if (setsockopt (fd, SOL_IP, IP_MULTICAST_IF,
                            &req, sizeof (req)) == 0)
                return 0;
            break;
        }
#endif
        default:
            errno = EAFNOSUPPORT;
    }
    msg_Err (p_this, ""cannot force multicast interface %s: %s"", iface,
             vlc_strerror_c(errno));
    return -1;
}",255.0,291.0,1.0,1.0,37.0,5,3,11,6,1,1,3,3,0,1,,0,0,8,4,4,int
3185,153676,var_GetIfIndex,1,var_GetIfIndex,unsigned var_GetIfIndex (vlc_object_t*),network\udp.c,"static unsigned var_GetIfIndex (vlc_object_t *obj)
{
    char *ifname = var_InheritString (obj, ""miface"");
    if (ifname == NULL)
        return 0;

    unsigned ifindex = if_nametoindex (ifname);
    if (ifindex == 0)
        msg_Err (obj, ""invalid multicast interface: %s"", ifname);
    free (ifname);
    return ifindex;
}",294.0,305.0,1.0,1.0,12.0,4,2,11,4,0,0,3,3,0,0,,0,0,2,1,1,unsigned
3186,153712,net_SourceSubscribe,1,net_SourceSubscribe,"int net_SourceSubscribe (vlc_object_t*,int,sockaddr*,socklen_t,sockaddr*,socklen_t)",network\udp.c,"static int
net_SourceSubscribe (vlc_object_t *obj, int fd,
                     const struct sockaddr *src, socklen_t srclen,
                     const struct sockaddr *grp, socklen_t grplen)
{
/* MCAST_JOIN_SOURCE_GROUP was introduced to OS X in v10.7, but it doesn't work,
 * so ignore it to use the same code path as on 10.5 or 10.6 */
#if defined (MCAST_JOIN_SOURCE_GROUP) && !defined (__APPLE__)
    /* Family-agnostic Source-Specific Multicast join */
    int level;
    struct group_source_req gsr;

    memset (&gsr, 0, sizeof (gsr));
    gsr.gsr_interface = var_GetIfIndex (obj);

    switch (grp->sa_family)
    {
#ifdef AF_INET6
        case AF_INET6:
        {
            const struct sockaddr_in6 *g6 = (const struct sockaddr_in6 *)grp;

            level = SOL_IPV6;
            assert (grplen >= sizeof (struct sockaddr_in6));
            if (g6->sin6_scope_id != 0)
                gsr.gsr_interface = g6->sin6_scope_id;
            break;
        }
#endif
        case AF_INET:
...",312.0,392.0,1.0,1.0,81.0,7,4,14,8,1,2,3,3,0,2,,0,0,12,6,6,int
3187,153760,net_Subscribe,1,net_Subscribe,"int net_Subscribe (vlc_object_t*,int,sockaddr*,socklen_t)",network\udp.c,"int net_Subscribe (vlc_object_t *obj, int fd,
                   const struct sockaddr *grp, socklen_t grplen)
{
/* MCAST_JOIN_GROUP was introduced to OS X in v10.7, but it doesn't work,
 * so ignore it to use the same code as on 10.5 or 10.6 */
#if defined (MCAST_JOIN_GROUP) && !defined (__APPLE__)
    /* Family-agnostic Any-Source Multicast join */
    int level;
    struct group_req gr;

    memset (&gr, 0, sizeof (gr));
    gr.gr_interface = var_GetIfIndex (obj);

    switch (grp->sa_family)
    {
#ifdef AF_INET6
        case AF_INET6:
        {
            const struct sockaddr_in6 *g6 = (const struct sockaddr_in6 *)grp;

            level = SOL_IPV6;
            assert (grplen >= sizeof (struct sockaddr_in6));
            if (g6->sin6_scope_id != 0)
                gr.gr_interface = g6->sin6_scope_id;
            break;
        }
#endif
        case AF_INET:
            level = SOL_IP;
            break;
        default:
            errno = EAFNOSUPPORT;
            return -1;...",395.0,476.0,1.0,1.0,82.0,3,3,5,5,3,1,2,2,0,1,,0,0,8,4,4,int
3188,153785,net_SetDSCP,1,net_SetDSCP,"int net_SetDSCP (int,uint8_t)",network\udp.c,"static int net_SetDSCP( int fd, uint8_t dscp )
{
    struct sockaddr_storage addr;
    if( getsockname( fd, (struct sockaddr *)&addr, &(socklen_t){ sizeof (addr) }) )
        return -1;

    int level, cmd;

    switch( addr.ss_family )
    {
#ifdef IPV6_TCLASS
        case AF_INET6:
            level = SOL_IPV6;
            cmd = IPV6_TCLASS;
            break;
#endif

        case AF_INET:
            level = SOL_IP;
            cmd = IP_TOS;
            break;

        default:
#ifdef ENOPROTOOPT
            errno = ENOPROTOOPT;
#endif
            return -1;
    }

    return setsockopt( fd, level, cmd, &(int){ dscp }, sizeof (int));
}",479.0,509.0,1.0,20.0,31.0,15,7,14,9,1,0,4,3,0,0,,0,0,4,2,2,int
3189,153843,net_ConnectDgram,1,net_ConnectDgram,"int net_ConnectDgram (vlc_object_t*,char*,int,int,int)",network\udp.c,"int net_ConnectDgram( vlc_object_t *p_this, const char *psz_host, int i_port,
                      int i_hlim, int proto )
{
    struct addrinfo hints = {
        .ai_socktype = SOCK_DGRAM,
        .ai_protocol = proto,
        .ai_flags = AI_NUMERICSERV | AI_IDN,
    }, *res;
    int       i_handle = -1;
    bool      b_unreach = false;

    if( i_hlim < 0 )
        i_hlim = var_InheritInteger( p_this, ""ttl"" );

    msg_Dbg( p_this, ""net: connecting to [%s]:%d"", psz_host, i_port );

    int val = vlc_getaddrinfo (psz_host, i_port, &hints, &res);
    if (val)
    {
        msg_Err (p_this, ""cannot resolve [%s]:%d : %s"", psz_host, i_port,
                 gai_strerror (val));
        return -1;
    }

    for (struct addrinfo *ptr = res; ptr != NULL; ptr = ptr->ai_next)
    {
        char *str;
        int fd = net_Socket (p_this, ptr->ai_family, ptr->ai_socktype,
                             ptr->ai_protocol);
        if (fd == -1)
            continue;

        /* Allow broadcast ...",518.0,595.0,1.0,1.0,78.0,41,12,74,27,0,5,13,17,0,5,,0,2,10,5,5,int
3190,154058,net_OpenDgram,1,net_OpenDgram,"int net_OpenDgram (vlc_object_t*,char*,int,char*,int,int)",network\udp.c,"int net_OpenDgram( vlc_object_t *obj, const char *psz_bind, int i_bind,
                   const char *psz_server, int i_server, int protocol )
{
    if ((psz_server == NULL) || (psz_server[0] == '\0'))
        return net_ListenSingle (obj, psz_bind, i_bind, protocol);

    msg_Dbg (obj, ""net: connecting to [%s]:%d from [%s]:%d"",
             psz_server, i_server, psz_bind, i_bind);

    struct addrinfo hints = {
        .ai_socktype = SOCK_DGRAM,
        .ai_protocol = protocol,
        .ai_flags = AI_NUMERICSERV | AI_IDN,
    }, *loc, *rem;

    int val = vlc_getaddrinfo (psz_server, i_server, &hints, &rem);
    if (val)
    {
        msg_Err (obj, ""cannot resolve %s port %d : %s"", psz_server, i_server,
                 gai_strerror (val));
        return -1;
    }

    hints.ai_flags |= AI_PASSIVE;
    val = vlc_getaddrinfo (psz_bind, i_bind, &hints, &loc);
    if (val)
    {
        msg_Err (obj, ""cannot resolve %s port %d : %s"", psz_bind, i_bind,
                 gai_strerror (...",603.0,678.0,1.0,1.0,76.0,57,12,91,22,0,7,17,19,1,7,,0,5,12,6,6,int
3191,154318,net_SetCSCov,1,net_SetCSCov,"int net_SetCSCov (int,int,int)",network\udp.c,"int net_SetCSCov (int fd, int sendcov, int recvcov)
{
    int type;

    if (getsockopt (fd, SOL_SOCKET, SO_TYPE,
                    &type, &(socklen_t){ sizeof (type) }))
        return VLC_EGENERIC;

    switch (type)
    {
#ifdef UDPLITE_RECV_CSCOV
        case SOCK_DGRAM: /* UDP-Lite */
            if (sendcov == -1)
                sendcov = 0;
            else
                sendcov += 8; /* partial */
            if (setsockopt (fd, SOL_UDPLITE, UDPLITE_SEND_CSCOV, &sendcov,
                            sizeof (sendcov)))
                return VLC_EGENERIC;

            if (recvcov == -1)
                recvcov = 0;
            else
                recvcov += 8;
            if (setsockopt (fd, SOL_UDPLITE, UDPLITE_RECV_CSCOV,
                            &recvcov, sizeof (recvcov)))
                return VLC_EGENERIC;

            return VLC_SUCCESS;
#endif
#ifdef DCCP_SOCKOPT_SEND_CSCOV
        case SOCK_DCCP: /* DCCP and its ill-named socket type */
            if ((send...",688.0,745.0,1.0,1.0,58.0,5,4,10,7,0,0,3,3,0,0,,0,0,6,3,3,int
3192,154535,vlc_open,1,vlc_open,"int vlc_open (char*,int...)",win32\filesystem.c,"int vlc_open (const char *filename, int flags, ...)
{
    int mode = 0;
    va_list ap;

    flags |= O_NOINHERIT; /* O_CLOEXEC */
    /* Defaults to binary mode */
    if ((flags & O_TEXT) == 0)
        flags |= O_BINARY;

    va_start (ap, flags);
    if (flags & O_CREAT)
    {
        int unixmode = va_arg(ap, int);
        if (unixmode & 0444)
            mode |= _S_IREAD;
        if (unixmode & 0222)
            mode |= _S_IWRITE;
    }
    va_end (ap);

    /*
     * open() cannot open files with non-ANSI characters on Windows.
     * We use _wopen() instead. Same thing for mkdir() and stat().
     */
    wchar_t *wpath = widen_path (filename);
    if (wpath == NULL)
        return -1;

    int fd = _wopen (wpath, flags, mode);
    free (wpath);
    return fd;
}",72.0,104.0,1.0,1.0,33.0,8,4,20,11,4,0,3,3,0,0,,0,0,4,2,2,int
3193,154589,vlc_openat,1,vlc_openat,"int vlc_openat (int,char*,int...)",win32\filesystem.c,"int vlc_openat (int dir, const char *filename, int flags, ...)
{
    (void) dir; (void) filename; (void) flags;
    errno = ENOSYS;
    return -1;
}",106.0,111.0,1.0,1.0,6.0,2,2,2,2,0,0,1,1,0,0,,0,0,6,3,3,int
3194,154602,vlc_memfd,1,vlc_memfd,int vlc_memfd (void),win32\filesystem.c,"int vlc_memfd (void)
{
#if 0
    int fd, err;

    FILE *stream = tmpfile();
    if (stream == NULL)
        return -1;

    fd = vlc_dup(fileno(stream));
    err = errno;
    fclose(stream);
    errno = err;
    return fd;
#else /* Not currently used */
    errno = ENOSYS;
    return -1;
#endif
}",113.0,131.0,1.0,1.0,19.0,2,2,2,2,0,0,1,1,0,0,,0,0,2,1,1,int
3195,154613,vlc_close,1,vlc_close,int vlc_close (int),win32\filesystem.c,"int vlc_close (int fd)
{
    return close (fd);
}",133.0,136.0,1.0,1.0,4.0,0,0,1,1,9,0,1,1,0,0,,0,0,2,1,1,int
3196,154621,vlc_mkdir,1,vlc_mkdir,"int vlc_mkdir (char*,mode_t)",win32\filesystem.c,"int vlc_mkdir( const char *dirname, mode_t mode )
{
    wchar_t *wpath = widen_path (dirname);
    if (wpath == NULL)
        return -1;

    int ret = _wmkdir (wpath);
    free (wpath);
    (void) mode;
    return ret;
}",138.0,148.0,1.0,1.0,11.0,5,3,11,7,3,0,2,2,0,0,,0,0,4,2,2,int
3197,154654,vlc_opendir,1,vlc_opendir,DIR vlc_opendir (char*),win32\filesystem.c,"DIR *vlc_opendir (const char *dirname)
{
    wchar_t *wpath = widen_path (dirname);
    if (wpath == NULL)
        return NULL;

    vlc_DIR *p_dir = malloc (sizeof (*p_dir));
    if (unlikely(p_dir == NULL))
    {
        free(wpath);
        return NULL;
    }

#if !VLC_WINSTORE_APP
    /* Special mode to list drive letters */
    if (wpath[0] == L'\0' || (wcscmp (wpath, L""\\"") == 0))
    {
        free (wpath);
        p_dir->wdir = NULL;
        p_dir->u.drives = GetLogicalDrives ();
        p_dir->entry = NULL;
        return (void *)p_dir;
    }
#endif

    assert (wpath[0]); // wpath[1] is defined
    p_dir->u.insert_dot_dot = !wcscmp (wpath + 1, L"":\\"");

    _WDIR *wdir = _wopendir (wpath);
    free (wpath);
    if (wdir == NULL)
    {
        free (p_dir);
        return NULL;
    }
    p_dir->wdir = wdir;
    p_dir->entry = NULL;
    return (void *)p_dir;
}",167.0,205.0,1.0,1.0,39.0,4,2,11,6,2,0,2,2,0,0,,0,0,2,1,1,DIR
3198,154684,vlc_readdir,1,vlc_readdir,const char* vlc_readdir (DIR*),win32\filesystem.c,"const char *vlc_readdir (DIR *dir)
{
    vlc_DIR *p_dir = (vlc_DIR *)dir;

    free(p_dir->entry);

#if !VLC_WINSTORE_APP
    /* Drive letters mode */
    if (p_dir->wdir == NULL)
    {
        DWORD drives = p_dir->u.drives;
        if (drives == 0)
        {
            p_dir->entry = NULL;
            return NULL; /* end */
        }

        unsigned int i;
        for (i = 0; !(drives & 1); i++)
            drives >>= 1;
        p_dir->u.drives &= ~(1UL << i);
        assert (i < 26);

        if (asprintf (&p_dir->entry, ""%c:\\"", 'A' + i) == -1)
            p_dir->entry = NULL;
    }
    else
#endif
    if (p_dir->u.insert_dot_dot)
    {
        /* Adds "".."", gruik! */
        p_dir->u.insert_dot_dot = false;
        p_dir->entry = strdup ("".."");
    }
    else
    {
        struct _wdirent *ent = _wreaddir (p_dir->wdir);
        p_dir->entry = (ent != NULL) ? FromWide (ent->d_name) : NULL;
    }
    return p_dir->entry;
}",207.0,247.0,1.0,1.0,41.0,9,5,18,9,2,0,3,3,0,0,,0,0,2,1,1,const char*
3199,154750,vlc_statEx,1,vlc_statEx,"int vlc_statEx (char*,stat*,bool)",os2\filesystem.c,"static int vlc_statEx (const char *filename, struct stat *buf, bool deref)
{
    const char *local_name = ToLocaleDup (filename);
    if (unlikely(local_name == NULL))
    {
        errno = ENOENT;
        return -1;
    }

    int res = deref ? stat (local_name, buf)
                    : lstat (local_name, buf);
    free (local_name);
    return res;
}",156.0,169.0,1.0,1.0,14.0,6,4,14,8,2,0,2,2,0,0,,0,0,6,3,3,int
3200,154789,vlc_stat,1,vlc_stat,"int vlc_stat (char*,stat*)",win32\filesystem.c,"int vlc_stat (const char *filename, struct stat *buf)
{
    wchar_t *wpath = widen_path (filename);
    if (wpath == NULL)
        return -1;

    static_assert (sizeof (*buf) == sizeof (struct _stati64),
                   ""Mismatched struct stat definition."");

    int ret = _wstati64 (wpath, buf);
    free (wpath);
    return ret;
}",249.0,261.0,1.0,1.0,13.0,0,0,3,3,5,1,1,1,0,1,,0,0,4,2,2,int
3201,154800,vlc_lstat,1,vlc_lstat,"int vlc_lstat (char*,stat*)",win32\filesystem.c,"int vlc_lstat (const char *filename, struct stat *buf)
{
    return vlc_stat (filename, buf);
}",263.0,266.0,1.0,1.0,4.0,0,0,3,3,0,1,1,1,0,1,,0,0,4,2,2,int
3202,154811,vlc_unlink,1,vlc_unlink,int vlc_unlink (char*),win32\filesystem.c,"int vlc_unlink (const char *filename)
{
    wchar_t *wpath = widen_path (filename);
    if (wpath == NULL)
        return -1;

    int ret = _wunlink (wpath);
    free (wpath);
    return ret;
}",268.0,277.0,1.0,1.0,10.0,5,3,10,6,3,0,2,2,0,0,,0,0,2,1,1,int
3203,154842,vlc_rename,1,vlc_rename,"int vlc_rename (char*,char*)",win32\filesystem.c,"int vlc_rename (const char *oldpath, const char *newpath)
{
    int ret = -1;

    wchar_t *wold = widen_path (oldpath), *wnew = widen_path (newpath);
    if (wold == NULL || wnew == NULL)
        goto out;

    if (_wrename (wold, wnew) && (errno == EACCES || errno == EEXIST))
    {   /* Windows does not allow atomic file replacement */
        if (_wremove (wnew))
        {
            errno = EACCES; /* restore errno */
            goto out;
        }
        if (_wrename (wold, wnew))
            goto out;
    }
    ret = 0;
out:
    free (wnew);
    free (wold);
    return ret;
}",279.0,302.0,1.0,1.0,24.0,7,3,17,8,2,0,4,3,0,0,,0,0,4,2,2,int
3204,154890,vlc_getcwd,1,vlc_getcwd,char* vlc_getcwd (void),win32\filesystem.c,"char *vlc_getcwd (void)
{
#if VLC_WINSTORE_APP
    return NULL;
#else
    wchar_t *wdir = _wgetcwd (NULL, 0);
    if (wdir == NULL)
        return NULL;

    char *dir = FromWide (wdir);
    free (wdir);
    return dir;
#endif
}",150.0,163.0,1.0,1.0,14.0,28,11,33,11,1,0,9,11,0,0,,0,0,2,1,1,char*
3205,155005,vlc_dup,1,vlc_dup,int vlc_dup (int),win32\filesystem.c,"int vlc_dup (int oldfd)
{
    int fd = dup (oldfd);
    if (fd != -1)
        setmode (fd, O_BINARY);
    return fd;
}",304.0,310.0,1.0,1.0,7.0,3,3,7,4,0,0,2,2,0,0,,0,0,2,1,1,int
3206,155028,vlc_pipe,1,vlc_pipe,int vlc_pipe (int[2]),win32\filesystem.c,"int vlc_pipe (int fds[2])
{
#if VLC_WINSTORE_APP
    _set_errno(EPERM);
    return -1;
#else
    return _pipe (fds, 32768, O_NOINHERIT | O_BINARY);
#endif
}",312.0,320.0,1.0,1.0,9.0,5,2,12,7,1,1,2,2,1,1,,0,1,2,1,1,int
3207,155066,vlc_write,1,vlc_write,"ssize_t vlc_write (int,void*,size_t)",win32\filesystem.c,"ssize_t vlc_write(int fd, const void *buf, size_t len)
{
    return write(fd, buf, len);
}",322.0,325.0,1.0,1.0,4.0,6,4,7,6,0,1,1,1,0,1,,0,0,6,3,3,ssize_t
3208,155093,vlc_writev,1,vlc_writev,"ssize_t vlc_writev (int,iovec*,int)",win32\filesystem.c,"ssize_t vlc_writev(int fd, const struct iovec *iov, int count)
{
    vlc_assert_unreachable();
}",327.0,330.0,1.0,1.0,4.0,19,10,25,15,1,0,4,5,0,0,,0,0,6,3,3,ssize_t
3209,155166,vlc_socket_setup,1,vlc_socket_setup,"void vlc_socket_setup (int,bool)",posix\filesystem.c,"static void vlc_socket_setup(int fd, bool nonblock)
{
    vlc_cloexec(fd);

    if (nonblock)
        fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) | O_NONBLOCK);

#ifdef SO_NOSIGPIPE
    setsockopt(fd, SOL_SOCKET, SO_NOSIGPIPE, &(int){ 1 }, sizeof (int));
#endif
}",283.0,293.0,1.0,1.0,11.0,1,1,9,7,3,0,2,2,0,0,,0,0,4,2,2,void
3210,155188,vlc_socket,1,vlc_socket,"int vlc_socket (int,int,int,bool)",win32\filesystem.c,"int vlc_socket (int pf, int type, int proto, bool nonblock)
{
    int fd = socket (pf, type, proto);
    if (fd == -1)
        return -1;

    if (nonblock)
        ioctlsocket (fd, FIONBIO, &(unsigned long){ 1 });
    return fd;
}",334.0,343.0,1.0,1.0,10.0,3,3,8,5,2,1,2,2,0,1,,0,0,8,4,4,int
3211,155214,vlc_socketpair,1,vlc_socketpair,"int vlc_socketpair (int,int,int,int[2],bool)",win32\filesystem.c,"int vlc_socketpair(int pf, int type, int proto, int fds[2], bool nonblock)
{
    (void) pf; (void) type; (void) proto; (void) fds; (void) nonblock;
    errno = ENOSYS;
    return -1;
}",345.0,350.0,1.0,1.0,6.0,3,2,8,5,2,2,2,2,0,2,,0,0,10,5,5,int
3212,155245,vlc_accept,1,vlc_accept,"int vlc_accept (int,sockaddr*,socklen_t*,bool)",win32\filesystem.c,"int vlc_accept (int lfd, struct sockaddr *addr, socklen_t *alen, bool nonblock)
{
    int fd = accept (lfd, addr, alen);
    if (fd != -1 && nonblock)
        ioctlsocket (fd, FIONBIO, &(unsigned long){ 1 });
    return fd;
}",352.0,358.0,1.0,1.0,7.0,6,5,17,12,3,0,4,7,0,0,,0,0,8,4,4,int
3213,155305,getnameinfo,1,getnameinfo,"int getnameinfo (sockaddr*,socklen_t,char*,int,char*,int,int)",os2\getaddrinfo.c,"int
getnameinfo (const struct sockaddr *sa, socklen_t salen,
                 char *host, int hostlen, char *serv, int servlen, int flags)
{
    if (((size_t)salen < sizeof (struct sockaddr_in))
     || (sa->sa_family != AF_INET))
        return EAI_FAMILY;
    else if (flags & (~_NI_MASK))
        return EAI_BADFLAGS;
    else
    {
        const struct sockaddr_in *addr;

        addr = (const struct sockaddr_in *)sa;

        if (host != NULL)
        {
            /* host name resolution */
            if (!(flags & NI_NUMERICHOST))
            {
                if (flags & NI_NAMEREQD)
                    return EAI_NONAME;
            }

            /* inet_ntoa() is not thread-safe, do not use it */
            uint32_t ipv4 = ntohl (addr->sin_addr.s_addr);

            if (snprintf (host, hostlen, ""%u.%u.%u.%u"", ipv4 >> 24,
                          (ipv4 >> 16) & 0xff, (ipv4 >> 8) & 0xff,
                          ipv4 & 0xff) >= (int)hostlen)
                return EAI_OVE...",46.0,87.0,1.0,23.0,42.0,6,6,5,5,1,0,2,2,0,0,,0,0,14,7,7,int
3214,155440,gai_error_from_herrno,1,gai_error_from_herrno,int gai_error_from_herrno (void),os2\getaddrinfo.c,"static int
gai_error_from_herrno (void)
{
    switch (h_errno)
    {
        case HOST_NOT_FOUND:
            return EAI_NONAME;

        case NO_ADDRESS:
# if (NO_ADDRESS != NO_DATA)
        case NO_DATA:
# endif
            return EAI_NODATA;

        case NO_RECOVERY:
            return EAI_FAIL;

        case TRY_AGAIN:
            return EAI_AGAIN;
    }
    return EAI_SYSTEM;
}",94.0,115.0,1.0,1.0,22.0,0,0,10,10,0,0,2,2,0,0,,0,0,2,1,1,int
3215,155466,makeaddrinfo,1,makeaddrinfo,"struct addrinfo makeaddrinfo (int,int,int,sockaddr*,size_t,char*)",os2\getaddrinfo.c,"static struct addrinfo *
makeaddrinfo (int af, int type, int proto,
              const struct sockaddr *addr, size_t addrlen,
              const char *canonname)
{
    struct addrinfo *res;

    res = (struct addrinfo *)malloc (sizeof (struct addrinfo));
    if (res != NULL)
    {
        res->ai_flags = 0;
        res->ai_family = af;
        res->ai_socktype = type;
        res->ai_protocol = proto;
        res->ai_addrlen = addrlen;
        res->ai_addr = malloc (addrlen);
        res->ai_canonname = NULL;
        res->ai_next = NULL;

        if (res->ai_addr != NULL)
        {
            memcpy (res->ai_addr, addr, addrlen);

            if (canonname != NULL)
            {
                res->ai_canonname = strdup (canonname);
                if (res->ai_canonname != NULL)
                    return res; /* success ! */
            }
            else
                return res;
        }
    }
    /* failsafe */
    freeaddrinfo (res);
    return NULL;
}",120.0,156.0,1.0,1.0,37.0,28,5,33,9,1,0,5,11,0,0,,0,0,12,6,6,struct addrinfo
3216,155571,makeipv4info,1,makeipv4info,"struct addrinfo makeipv4info (int,int,u_long,u_short,char*)",os2\getaddrinfo.c,"static struct addrinfo *
makeipv4info (int type, int proto, u_long ip, u_short port, const char *name)
{
    struct sockaddr_in addr;

    memset (&addr, 0, sizeof (addr));
    addr.sin_family = AF_INET;
# ifdef HAVE_SA_LEN
    addr.sin_len = sizeof (addr);
# endif
    addr.sin_port = port;
    addr.sin_addr.s_addr = ip;

    return makeaddrinfo (AF_INET, type, proto,
                         (struct sockaddr*)&addr, sizeof (addr), name);
}",158.0,173.0,1.0,1.0,16.0,12,5,14,7,2,1,1,1,0,1,,0,0,10,5,5,struct addrinfo
3217,155616,getaddrinfo,1,getaddrinfo,"int getaddrinfo (char*,char*,addrinfo*,addrinfo**)",os2\getaddrinfo.c,"int
getaddrinfo (const char *node, const char *service,
             const struct addrinfo *hints, struct addrinfo **res)
{
    struct addrinfo *info;
    u_long ip;
    u_short port;
    int protocol = 0, flags = 0;
    const char *name = NULL;

    if (hints != NULL)
    {
        flags = hints->ai_flags;

        if (flags & ~_AI_MASK)
            return EAI_BADFLAGS;
        /* only accept AF_INET and AF_UNSPEC */
        if (hints->ai_family && (hints->ai_family != AF_INET))
            return EAI_FAMILY;

        /* protocol sanity check */
        switch (hints->ai_socktype)
        {
            case SOCK_STREAM:
                protocol = IPPROTO_TCP;
                break;

            case SOCK_DGRAM:
                protocol = IPPROTO_UDP;
                break;

#ifdef SOCK_RAW
            case SOCK_RAW:
#endif
            case 0:
                break;

            default:
                return EAI_SOCKTYPE;
        }
        if (hints->ai_protocol && protocol
      ...",184.0,305.0,1.0,21.0,122.0,56,11,89,27,2,2,19,25,0,2,,0,2,8,4,4,int
3218,156065,vlc_rand_bytes,1,vlc_rand_bytes,"void vlc_rand_bytes (void*,size_t)",win32\rand.c,"void vlc_rand_bytes (void *buf, size_t len)
{
    size_t count = len;
    uint8_t *p_buf = (uint8_t *)buf;

    /* fill buffer with pseudo-random data */
    while (count > 0)
    {
        unsigned int val;
        val = rand();
        if (count < sizeof (val))
        {
            memcpy (p_buf, &val, count);
            break;
        }

        memcpy (p_buf, &val, sizeof (val));
        count -= sizeof (val);
        p_buf += sizeof (val);
    }

#if VLC_WINSTORE_APP
    static const WCHAR *className = L""Windows.Security.Cryptography.CryptographicBuffer"";
    const UINT32 clen = wcslen(className);

    HSTRING hClassName = NULL;
    HSTRING_HEADER header;
    HRESULT hr = WindowsCreateStringReference(className, clen, &header, &hClassName);
    if (hr) {
        WindowsDeleteString(hClassName);
        return;
    }

    ICryptographicBufferStatics *cryptoStatics = NULL;
    hr = RoGetActivationFactory(hClassName, &IID_ICryptographicBufferStatics, (void**)&cryptoStatics);
    ...",39.0,109.0,1.0,1.0,71.0,10,9,7,4,2,0,2,2,0,0,,0,0,4,2,2,void
3219,156136,IPCHelperThread,1,IPCHelperThread,void IPCHelperThread (void*),os2\specific.c,"static void IPCHelperThread( void *arg )
{
    libvlc_int_t *libvlc = arg;

    ULONG  ulCmd;
    int    i_argc;
    char **ppsz_argv;
    size_t i_len;
    ULONG  cbActual;
    int    i_options;

    /* Add files to the playlist */
    playlist_t *p_playlist;

    do
    {
        DosConnectNPipe( hpipeIPC );

        /* Read command */
        DosRead( hpipeIPC, &ulCmd, sizeof( ulCmd ), &cbActual );
        if( ulCmd == IPC_CMD_QUIT )
            continue;

        /* Read a count of arguments */
        DosRead( hpipeIPC, &i_argc, sizeof( i_argc ), &cbActual );

        ppsz_argv = vlc_alloc( i_argc, sizeof( *ppsz_argv ));

        for( int i_opt = 0; i_opt < i_argc; i_opt++ )
        {
            /* Read a length of argv */
            DosRead( hpipeIPC, &i_len, sizeof( i_len ), &cbActual );

            ppsz_argv[ i_opt ] = malloc( i_len );

            /* Read argv */
            DosRead( hpipeIPC, ppsz_argv[ i_opt ], i_len, &cbActual );
        }

        p_playlist = libvlc...",47.0,122.0,1.0,21.0,76.0,52,16,65,17,0,12,9,17,1,2,,0,11,2,1,1,void
3220,156541,system_End,1,system_End,void system_End (void),win32\specific.c,"void system_End(void)
{
    /* XXX: In theory, we should not call this if WSAStartup() failed. */
    WSACleanup();
}",187.0,191.0,1.0,1.0,5.0,7,4,12,8,0,2,3,4,1,0,,0,2,2,1,1,void
3221,156634,vlc_cancel_self,1,vlc_cancel_self,void vlc_cancel_self (PVOID),os2\thread.c,"static void vlc_cancel_self (PVOID self)
{
    struct vlc_thread *th = self;

    if (likely(th != NULL))
        th->killed = true;
}",654.0,660.0,1.0,1.0,7.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
3222,156639,vlc_DosWaitEventSemEx,1,vlc_DosWaitEventSemEx,"ULONG vlc_DosWaitEventSemEx (HEV,ULONG)",os2\thread.c,"static ULONG vlc_DosWaitEventSemEx( HEV hev, ULONG ulTimeout )
{
    HMUX      hmux;
    SEMRECORD asr[ 2 ];
    ULONG     ulUser;
    int       n;
    ULONG     rc;

    struct vlc_thread *th = vlc_thread_self ();
    if( th == NULL || !th->killable )
    {
        /* Main thread - cannot be cancelled anyway
         * Alien thread - out of our control
         * Cancel disabled thread - ignore cancel
         */
        if( hev != NULLHANDLE )
            return DosWaitEventSem( hev, ulTimeout );

        return DosSleep( ulTimeout );
    }

    n = 0;
    if( hev != NULLHANDLE )
    {
        asr[ n ].hsemCur = ( HSEM )hev;
        asr[ n ].ulUser  = 0;
        n++;
    }
    asr[ n ].hsemCur = ( HSEM )th->cancel_event;
    asr[ n ].ulUser  = 0xFFFF;
    n++;

    DosCreateMuxWaitSem( NULL, &hmux, n, asr, DCMW_WAIT_ANY );
    rc = DosWaitMuxWaitSem( hmux, ulTimeout, &ulUser );
    DosCloseMuxWaitSem( hmux );
    if( rc )
        return rc;

    if( ulUser == 0xFFFF )
    {
      ...",72.0,117.0,1.0,1.0,46.0,29,11,40,13,2,4,6,7,1,2,,0,3,4,2,2,ULONG
3223,156754,vlc_WaitForSingleObject,1,vlc_WaitForSingleObject,"ULONG vlc_WaitForSingleObject (HEV,ULONG)",os2\thread.c,"static ULONG vlc_WaitForSingleObject (HEV hev, ULONG ulTimeout)
{
    return vlc_DosWaitEventSemEx( hev, ulTimeout );
}",119.0,122.0,1.0,1.0,4.0,0,0,2,2,1,1,1,1,0,1,,0,0,4,2,2,ULONG
3224,156764,vlc_Sleep,1,vlc_Sleep,ULONG vlc_Sleep (ULONG),os2\thread.c,"static ULONG vlc_Sleep (ULONG ulTimeout)
{
    ULONG rc = vlc_DosWaitEventSemEx( NULLHANDLE, ulTimeout );

    return ( rc != ERROR_TIMEOUT ) ? rc : 0;
}",124.0,129.0,1.0,1.0,6.0,3,3,6,4,0,1,1,1,0,1,,0,1,2,1,1,ULONG
3225,156785,vlc_static_cond_destroy_all,1,vlc_static_cond_destroy_all,void vlc_static_cond_destroy_all (void),os2\thread.c,"static void vlc_static_cond_destroy_all (void)
{
    vlc_static_cond_t *static_condvar;
    vlc_static_cond_t *static_condvar_next;


    for (static_condvar = static_condvar_start; static_condvar;
         static_condvar = static_condvar_next)
    {
        static_condvar_next = static_condvar->next;

        vlc_cond_destroy (&static_condvar->condvar);
        free (static_condvar);
    }
}",291.0,305.0,1.0,1.0,15.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
3226,156790,_CRT_init,1,_CRT_init,int _CRT_init (void),os2\thread.c,int _CRT_init(void);,137.0,137.0,5.0,19.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
3227,156795,_CRT_term,1,_CRT_term,void _CRT_term (void),os2\thread.c,void _CRT_term(void);,138.0,138.0,6.0,20.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
3228,157012,vlc_static_cond_init,1,vlc_static_cond_init,void vlc_static_cond_init (vlc_cond_t*),os2\thread.c,"static void vlc_static_cond_init (vlc_cond_t *p_condvar)
{
    vlc_mutex_lock (&super_mutex);

    if (p_condvar->hev == NULLHANDLE)
    {
        vlc_cond_init (p_condvar);

        vlc_static_cond_t *new_static_condvar;

        new_static_condvar = malloc (sizeof (*new_static_condvar));
        if (unlikely (!new_static_condvar))
            abort();

        memcpy (&new_static_condvar->condvar, p_condvar, sizeof (*p_condvar));
        new_static_condvar->next = static_condvar_start;
        static_condvar_start = new_static_condvar;
    }

    vlc_mutex_unlock (&super_mutex);
}",269.0,289.0,1.0,1.0,21.0,15,7,15,5,0,9,3,4,0,3,,0,6,2,1,1,void
3229,157217,vlc_cond_wait_common,1,vlc_cond_wait_common,"int vlc_cond_wait_common (vlc_cond_t*,vlc_mutex_t*,ULONG)",os2\thread.c,"static int vlc_cond_wait_common (vlc_cond_t *p_condvar, vlc_mutex_t *p_mutex,
                                 ULONG ulTimeout)
{
    ULONG ulPost;
    ULONG rc;

    assert(p_condvar->hev != NULLHANDLE);

    do
    {
        vlc_testcancel();

        __atomic_increment (&p_condvar->waiters);

        vlc_mutex_unlock (p_mutex);

        do
        {
            rc = vlc_WaitForSingleObject( p_condvar->hev, ulTimeout );
            if (rc == NO_ERROR)
                DosResetEventSem (p_condvar->hev, &ulPost);
        } while (rc == NO_ERROR &&
                 __atomic_cmpxchg32 (&p_condvar->signaled, 0, 1) == 0);

        __atomic_decrement (&p_condvar->waiters);

        DosPostEventSem (p_condvar->hevAck);

        vlc_mutex_lock (p_mutex);
    } while( rc == ERROR_INTERRUPT );

    return rc ? ETIMEDOUT : 0;
}",354.0,386.0,1.0,1.0,33.0,19,7,21,9,0,4,4,7,0,4,,0,1,6,3,3,int
3230,157412,destroy,1,vlc_threadvar.destroy,void vlc_threadvar.destroy (void*),os2\thread.c,void                (*destroy) (void *);,435.0,435.0,25.0,43.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
3231,157601,vlc_thread_cleanup,1,vlc_thread_cleanup,void vlc_thread_cleanup (vlc_thread*),os2\thread.c,"static void vlc_thread_cleanup (struct vlc_thread *th)
{
    vlc_threadvar_t key;

retry:
    /* TODO: use RW lock or something similar */
    vlc_mutex_lock (&super_mutex);
    for (key = vlc_threadvar_last; key != NULL; key = key->prev)
    {
        void *value = vlc_threadvar_get (key);
        if (value != NULL && key->destroy != NULL)
        {
            vlc_mutex_unlock (&super_mutex);
            vlc_threadvar_set (key, NULL);
            key->destroy (value);
            goto retry;
        }
    }
    vlc_mutex_unlock (&super_mutex);

    if (th->detached)
    {
        DosCloseEventSem (th->cancel_event);
        DosCloseEventSem (th->done_event );

        soclose (th->cancel_sock);

        free (th);
    }
}",506.0,535.0,1.0,1.0,30.0,15,5,22,6,1,13,5,5,1,5,,0,9,2,1,1,void
3232,157675,vlc_entry,1,vlc_entry,void vlc_entry (void*),win32\thread.c,"static
#if VLC_WINSTORE_APP
DWORD
#else // !VLC_WINSTORE_APP
unsigned
#endif // !VLC_WINSTORE_APP
__stdcall vlc_entry (void *p)
{
    struct vlc_thread *th = p;

    TlsSetValue(thread_key, th);
    th->killable = true;
    th->data = th->entry (th->data);
    TlsSetValue(thread_key, NULL);

    if (th->id == NULL) /* Detached thread */
        vlc_thread_destroy(th);
    return 0;
}",464.0,482.0,1.0,28.0,19.0,8,2,11,4,0,8,1,1,0,3,,0,6,2,1,1,unsigned
3233,158205,vlc_select,1,vlc_select,"int vlc_select (int,fd_set*,fd_set*,fd_set*,timeval*)",os2\thread.c,"static int vlc_select( int nfds, fd_set *rdset, fd_set *wrset, fd_set *exset,
                       struct timeval *timeout )
{
    struct vlc_thread *th = vlc_thread_self( );

    int rc;

    if( th )
    {
        FD_SET( th->cancel_sock, rdset );

        nfds = MAX( nfds, th->cancel_sock + 1 );
    }

    rc = select( nfds, rdset, wrset, exset, timeout );

    vlc_testcancel();

    return rc;

}",748.0,768.0,1.0,1.0,21.0,6,3,14,7,0,4,2,2,0,2,,0,3,10,5,5,int
3234,158247,vlc_poll_os2,1,vlc_poll_os2,"int vlc_poll_os2 (pollfd*,unsigned,int)",os2\thread.c,"__declspec(dllexport)
int vlc_poll_os2( struct pollfd *fds, unsigned nfds, int timeout )
{
    fd_set rdset, wrset, exset;

    int non_sockets = 0;

    struct timeval tv = { 0, 0 };

    int val = -1;

    FD_ZERO( &rdset );
    FD_ZERO( &wrset );
    FD_ZERO( &exset );
    for( unsigned i = 0; i < nfds; i++ )
    {
        int fd = fds[ i ].fd;
        struct stat stbuf;

        fds[ i ].revents = 0;

        if( fstat( fd, &stbuf ) == -1 ||
            (errno = 0, !S_ISSOCK( stbuf.st_mode )))
        {
            if( fd >= 0 )
            {
                /* If regular files, assume readiness for requested modes */
                fds[ i ].revents = ( !errno && S_ISREG( stbuf.st_mode ))
                                   ? ( fds[ i ].events &
                                       ( POLLIN | POLLOUT | POLLPRI ))
                                   : POLLNVAL;

                non_sockets++;
            }

            continue;
        }

        if( val < fd )
            val ...",774.0,867.0,1.0,1.0,94.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
3235,158666,func,1,vlc_timer.func,void vlc_timer.func (void*),os2\thread.c,void (*func) (void *);,917.0,917.0,10.0,25.0,1.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
3236,158672,vlc_timer_do,1,vlc_timer_do,void vlc_timer_do (void*),os2\thread.c,"static void vlc_timer_do (void *arg)
{
    struct vlc_timer *timer = arg;

    while (1)
    {
        ULONG count;

        DosWaitEventSem (timer->hev, SEM_INDEFINITE_WAIT);
        DosResetEventSem (timer->hev, &count);

        if (timer->quit)
            break;

        timer->func (timer->data);

        if (timer->interval)
            DosAsyncTimer (timer->interval, (HSEM)timer->hev, &timer->htimer);
    }
}",921.0,940.0,1.0,1.0,20.0,13,4,13,4,0,9,5,6,2,1,,0,8,2,1,1,void
3237,158727,vlc_timer_create,1,vlc_timer_create,"int vlc_timer_create (vlc_timer_t*,void,void*)",win32\timer.c,"int vlc_timer_create (vlc_timer_t *id, void (*func) (void *), void *data)
{
    struct vlc_timer *timer = malloc (sizeof (*timer));

    if (timer == NULL)
        return ENOMEM;
    timer->func = func;
    timer->data = data;
    timer->handle = INVALID_HANDLE_VALUE;
    *id = timer;
    return 0;
}",45.0,56.0,1.0,1.0,12.0,21,7,23,10,0,6,2,2,0,0,,0,6,6,3,3,int
3238,158798,vlc_timer_destroy,1,vlc_timer_destroy,void vlc_timer_destroy (vlc_timer_t),win32\timer.c,"void vlc_timer_destroy (vlc_timer_t timer)
{
    if (timer->handle != INVALID_HANDLE_VALUE)
        DeleteTimerQueueTimer (NULL, timer->handle, INVALID_HANDLE_VALUE);
    free (timer);
}",58.0,63.0,1.0,1.0,6.0,9,4,10,4,0,0,2,2,0,0,,0,0,2,1,1,void
3239,158835,vlc_timer_schedule,1,vlc_timer_schedule,"void vlc_timer_schedule (vlc_timer_t,bool,mtime_t,mtime_t)",win32\timer.c,"void vlc_timer_schedule (vlc_timer_t timer, bool absolute,
                         mtime_t value, mtime_t interval)
{
    if (timer->handle != INVALID_HANDLE_VALUE)
    {
        DeleteTimerQueueTimer (NULL, timer->handle, INVALID_HANDLE_VALUE);
        timer->handle = INVALID_HANDLE_VALUE;
    }
    if (value == 0)
        return; /* Disarm */

    if (absolute)
    {
        value -= mdate ();
        if (value < 0)
            value = 0;
    }
    value = (value + 999) / 1000;
    interval = (interval + 999) / 1000;

    if (!CreateTimerQueueTimer (&timer->handle, NULL, vlc_timer_do, timer,
                                value, interval, WT_EXECUTEDEFAULT))
        abort ();
}",65.0,88.0,1.0,1.0,24.0,21,9,18,5,0,1,5,5,0,1,,0,0,8,4,4,void
3240,158909,vlc_timer_getoverrun,1,vlc_timer_getoverrun,unsigned vlc_timer_getoverrun (vlc_timer_t),win32\timer.c,"unsigned vlc_timer_getoverrun (vlc_timer_t timer)
{
    (void)timer;
    return 0;
}",90.0,94.0,1.0,1.0,5.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,unsigned
3241,158956,playlist_GetAout,1,playlist_GetAout,audio_output_t playlist_GetAout (playlist_t*),playlist\aout.c,"audio_output_t *playlist_GetAout(playlist_t *pl)
{
    /* NOTE: it is assumed that the input resource exists. In practice,
     * the playlist must have been activated. This is automatic when calling
     * pl_Get(). FIXME: input resources are deleted at deactivation, this can
     * be too early. */
    playlist_private_t *sys = pl_priv(pl);
    return input_resource_HoldAout(sys->p_input_resource);
}",36.0,44.0,1.0,30.0,9.0,2,2,6,4,6,2,1,1,0,1,,0,1,2,1,1,audio_output_t
3242,158976,playlist_VolumeGet,1,playlist_VolumeGet,float playlist_VolumeGet (playlist_t*),playlist\aout.c,"float playlist_VolumeGet (playlist_t *pl)
{
    float volume = -1.f;

    audio_output_t *aout = playlist_GetAout (pl);
    if (aout != NULL)
    {
        volume = aout_VolumeGet (aout);
        vlc_object_release (aout);
    }
    return volume;
}",46.0,57.0,1.0,1.0,12.0,5,3,9,4,0,3,2,2,0,3,,0,2,2,1,1,float
3243,159004,playlist_VolumeSet,1,playlist_VolumeSet,"int playlist_VolumeSet (playlist_t*,float)",playlist\aout.c,"int playlist_VolumeSet (playlist_t *pl, float vol)
{
    int ret = -1;

    audio_output_t *aout = playlist_GetAout (pl);
    if (aout != NULL)
    {
        ret = aout_VolumeSet (aout, vol);
        vlc_object_release (aout);
    }
    return ret;
}",59.0,70.0,1.0,1.0,12.0,5,3,10,5,0,3,2,2,0,3,,0,2,4,2,2,int
3244,159034,playlist_VolumeUp,1,playlist_VolumeUp,"int playlist_VolumeUp (playlist_t*,int,float*)",playlist\aout.c,"int playlist_VolumeUp (playlist_t *pl, int value, float *volp)
{
    int ret = -1;

    audio_output_t *aout = playlist_GetAout (pl);
    if (aout != NULL)
    {
        ret = aout_VolumeUpdate (aout, value, volp);
        vlc_object_release (aout);
    }
    return ret;
}",77.0,88.0,1.0,1.0,12.0,5,3,11,6,0,3,2,2,0,3,,0,2,6,3,3,int
3245,159066,playlist_MuteGet,1,playlist_MuteGet,int playlist_MuteGet (playlist_t*),playlist\aout.c,"int playlist_MuteGet (playlist_t *pl)
{
    int mute = -1;

    audio_output_t *aout = playlist_GetAout (pl);
    if (aout != NULL)
    {
        mute = aout_MuteGet (aout);
        vlc_object_release (aout);
    }
    return mute;
}",90.0,101.0,1.0,1.0,12.0,5,3,9,4,0,3,2,2,0,3,,0,2,2,1,1,int
3246,159094,playlist_MuteSet,1,playlist_MuteSet,"int playlist_MuteSet (playlist_t*,bool)",playlist\aout.c,"int playlist_MuteSet (playlist_t *pl, bool mute)
{
    int ret = -1;

    audio_output_t *aout = playlist_GetAout (pl);
    if (aout != NULL)
    {
        ret = aout_MuteSet (aout, mute);
        vlc_object_release (aout);
    }
    return ret;
}",103.0,114.0,1.0,1.0,12.0,5,3,10,5,0,3,2,2,0,3,,0,2,4,2,2,int
3247,159124,playlist_EnableAudioFilter,1,playlist_EnableAudioFilter,"void playlist_EnableAudioFilter (playlist_t*,char*,bool)",playlist\aout.c,"void playlist_EnableAudioFilter (playlist_t *pl, const char *name, bool add)
{
    audio_output_t *aout = playlist_GetAout (pl);

    aout_ChangeFilterString (VLC_OBJECT(pl), aout ? VLC_OBJECT(aout) : NULL,
                             ""audio-filter"", name, add);
    if (aout != NULL)
        vlc_object_release (aout);
}",116.0,124.0,1.0,1.0,9.0,3,3,11,5,0,3,2,2,0,3,,0,1,6,3,3,void
3248,159179,ArtCacheCreateDir,1,ArtCacheCreateDir,void ArtCacheCreateDir (char*),playlist\art.c,"static void ArtCacheCreateDir( const char *psz_dir )
{
    char newdir[strlen( psz_dir ) + 1];
    strcpy( newdir, psz_dir );
    char * psz_newdir = newdir;
    char * psz = psz_newdir;

    while( *psz )
    {
        while( *psz && *psz != DIR_SEP_CHAR) psz++;
        if( !*psz ) break;
        *psz = 0;
        if( !EMPTY_STR( psz_newdir ) )
            vlc_mkdir( psz_newdir, 0700 );
        *psz = DIR_SEP_CHAR;
        psz++;
    }
    vlc_mkdir( psz_dir, 0700 );
}",41.0,59.0,1.0,1.0,19.0,15,6,18,5,2,2,6,8,0,2,,0,0,2,1,1,void
3249,159237,ArtCacheGetDirPath,1,ArtCacheGetDirPath,"char* ArtCacheGetDirPath (char*,char*,char*,char*)",playlist\art.c,"static char* ArtCacheGetDirPath( const char *psz_arturl, const char *psz_artist,
                                 const char *psz_album,  const char *psz_title )
{
    char *psz_dir;
    char *psz_cachedir = config_GetUserDir(VLC_CACHE_DIR);

    if( !EMPTY_STR(psz_artist) && !EMPTY_STR(psz_album) )
    {
        char *psz_album_sanitized = strdup( psz_album );
        filename_sanitize( psz_album_sanitized );
        char *psz_artist_sanitized = strdup( psz_artist );
        filename_sanitize( psz_artist_sanitized );
        if( asprintf( &psz_dir, ""%s"" DIR_SEP ""art"" DIR_SEP ""artistalbum""
                      DIR_SEP ""%s"" DIR_SEP ""%s"", psz_cachedir,
                      psz_artist_sanitized, psz_album_sanitized ) == -1 )
            psz_dir = NULL;
        free( psz_album_sanitized );
        free( psz_artist_sanitized );
    }
    else
    {
        /* If artist or album are missing, cache by art download URL.
         * If the URL is an attachment://, add the title to the cache...",61.0,104.0,1.0,1.0,44.0,7,3,16,8,1,3,3,4,0,3,,0,1,8,4,4,char*
3250,159330,ArtCachePath,1,ArtCachePath,char* ArtCachePath (input_item_t*),playlist\art.c,"static char *ArtCachePath( input_item_t *p_item )
{
    char* psz_path = NULL;
    const char *psz_artist;
    const char *psz_album;
    const char *psz_arturl;
    const char *psz_title;

    vlc_mutex_lock( &p_item->lock );

    if( !p_item->p_meta )
        p_item->p_meta = vlc_meta_New();
    if( !p_item->p_meta )
        goto end;

    psz_artist = vlc_meta_Get( p_item->p_meta, vlc_meta_Artist );
    psz_album = vlc_meta_Get( p_item->p_meta, vlc_meta_Album );
    psz_arturl = vlc_meta_Get( p_item->p_meta, vlc_meta_ArtworkURL );
    psz_title = vlc_meta_Get( p_item->p_meta, vlc_meta_Title );
    if( !psz_title )
        psz_title = p_item->psz_name;


    if( (EMPTY_STR(psz_artist) || EMPTY_STR(psz_album) ) && !psz_arturl )
        goto end;

    psz_path = ArtCacheGetDirPath( psz_arturl, psz_artist, psz_album, psz_title );

end:
    vlc_mutex_unlock( &p_item->lock );
    return psz_path;
}",106.0,137.0,1.0,1.0,32.0,26,6,31,11,2,8,7,5,0,8,,0,6,2,1,1,char*
3251,159429,ArtCacheName,1,ArtCacheName,"char* ArtCacheName (input_item_t*,char*)",playlist\art.c,"static char *ArtCacheName( input_item_t *p_item, const char *psz_type )
{
    char *psz_path = ArtCachePath( p_item );
    char *psz_ext = strdup( psz_type ? psz_type : """" );
    char *psz_filename = NULL;

    if( unlikely( !psz_path || !psz_ext ) )
        goto end;

    ArtCacheCreateDir( psz_path );
    filename_sanitize( psz_ext );

    if( asprintf( &psz_filename, ""%s"" DIR_SEP ""art%s"", psz_path, psz_ext ) < 0 )
        psz_filename = NULL;

end:
    free( psz_ext );
    free( psz_path );

    return psz_filename;
}",139.0,159.0,1.0,1.0,21.0,8,4,16,6,1,3,4,3,0,3,,0,1,4,2,2,char*
3252,159478,playlist_FindArtInCache,1,playlist_FindArtInCache,int playlist_FindArtInCache (input_item_t*),playlist\art.c,"int playlist_FindArtInCache( input_item_t *p_item )
{
    char *psz_path = ArtCachePath( p_item );

    if( !psz_path )
        return VLC_EGENERIC;

    /* Check if file exists */
    DIR *p_dir = vlc_opendir( psz_path );
    if( !p_dir )
    {
        free( psz_path );
        return VLC_EGENERIC;
    }

    bool b_found = false;
    const char *psz_filename;
    while( !b_found && (psz_filename = vlc_readdir( p_dir )) )
    {
        if( !strncmp( psz_filename, ""art"", 3 ) )
        {
            char *psz_file;
            if( asprintf( &psz_file, ""%s"" DIR_SEP ""%s"",
                          psz_path, psz_filename ) != -1 )
            {
                char *psz_uri = vlc_path2uri( psz_file, ""file"" );
                if( psz_uri )
                {
                    input_item_SetArtURL( p_item, psz_uri );
                    free( psz_uri );
                }
                free( psz_file );
            }

            b_found = true;
        }
    }

    /* */
    closedir( ...",162.0,204.0,1.0,1.0,43.0,12,4,29,11,1,4,7,13,1,4,,0,4,2,1,1,int
3253,159560,GetDirByItemUIDs,1,GetDirByItemUIDs,char* GetDirByItemUIDs (char*),playlist\art.c,"static char * GetDirByItemUIDs( char *psz_uid )
{
    char *psz_cachedir = config_GetUserDir(VLC_CACHE_DIR);
    char *psz_dir;
    if( asprintf( &psz_dir, ""%s"" DIR_SEP
                  ""by-iiuid"" DIR_SEP
                  ""%s"",
                  psz_cachedir, psz_uid ) == -1 )
    {
        psz_dir = NULL;
    }
    free( psz_cachedir );
    return psz_dir;
}",206.0,219.0,1.0,1.0,14.0,2,1,6,4,2,1,2,2,0,1,,0,1,2,1,1,char*
3254,159581,GetFileByItemUID,1,GetFileByItemUID,"char* GetFileByItemUID (char*,char*)",playlist\art.c,"static char * GetFileByItemUID( char *psz_dir, const char *psz_type )
{
    char *psz_file;
    if( asprintf( &psz_file, ""%s"" DIR_SEP ""%s"", psz_dir, psz_type ) == -1 )
    {
        psz_file = NULL;
    }
    return psz_file;
}",221.0,229.0,1.0,1.0,9.0,1,1,3,2,2,0,2,2,0,0,,0,0,4,2,2,char*
3255,159596,playlist_FindArtInCacheUsingItemUID,1,playlist_FindArtInCacheUsingItemUID,int playlist_FindArtInCacheUsingItemUID (input_item_t*),playlist\art.c,"int playlist_FindArtInCacheUsingItemUID( input_item_t *p_item )
{
    char *uid = input_item_GetInfo( p_item, ""uid"", ""md5"" );
    if ( ! *uid )
    {
        free( uid );
        return VLC_EGENERIC;
    }

    /* we have an input item uid set */
    bool b_done = false;
    char *psz_byuiddir = GetDirByItemUIDs( uid );
    char *psz_byuidfile = GetFileByItemUID( psz_byuiddir, ""arturl"" );
    free( psz_byuiddir );
    if( psz_byuidfile )
    {
        FILE *fd = vlc_fopen( psz_byuidfile, ""rb"" );
        if ( fd )
        {
            char sz_cachefile[2049];
            /* read the cache hash url */
            if ( fgets( sz_cachefile, 2048, fd ) != NULL )
            {
                input_item_SetArtURL( p_item, sz_cachefile );
                b_done = true;
            }
            fclose( fd );
        }
        free( psz_byuidfile );
    }
    free( uid );
    if ( b_done ) return VLC_SUCCESS;

    return VLC_EGENERIC;
}",231.0,265.0,1.0,1.0,35.0,9,4,29,12,1,4,6,9,0,4,,0,4,2,1,1,int
3256,159674,playlist_SaveArt,1,playlist_SaveArt,"int playlist_SaveArt (vlc_object_t*,input_item_t*,void*,size_t,char*)",playlist\art.c,"int playlist_SaveArt( vlc_object_t *obj, input_item_t *p_item,
                      const void *data, size_t length, const char *psz_type )
{
    char *psz_filename = ArtCacheName( p_item, psz_type );

    if( !psz_filename )
        return VLC_EGENERIC;

    char *psz_uri = vlc_path2uri( psz_filename, ""file"" );
    if( !psz_uri )
    {
        free( psz_filename );
        return VLC_EGENERIC;
    }

    /* Check if we already dumped it */
    struct stat s;
    if( !vlc_stat( psz_filename, &s ) )
    {
        input_item_SetArtURL( p_item, psz_uri );
        free( psz_filename );
        free( psz_uri );
        return VLC_SUCCESS;
    }

    /* Dump it otherwise */
    FILE *f = vlc_fopen( psz_filename, ""wb"" );
    if( f )
    {
        if( fwrite( data, 1, length, f ) != length )
        {
            msg_Err( obj, ""%s: %s"", psz_filename, vlc_strerror_c(errno) );
        }
        else
        {
            msg_Dbg( obj, ""album art saved to %s"", psz_filename );
            inpu...",268.0,340.0,1.0,1.0,73.0,17,7,54,15,1,11,11,14,1,11,,0,8,10,5,5,int
3257,159873,playlist_Lock,1,playlist_Lock,void playlist_Lock (playlist_t*),playlist\control.c,"void playlist_Lock( playlist_t *pl )
{
    vlc_mutex_lock( &pl_priv(pl)->lock );
}",37.0,40.0,1.0,21.0,4.0,2,2,4,3,10,1,1,1,0,1,,0,0,2,1,1,void
3258,159889,playlist_Unlock,1,playlist_Unlock,void playlist_Unlock (playlist_t*),playlist\control.c,"void playlist_Unlock( playlist_t *pl )
{
    vlc_mutex_unlock( &pl_priv(pl)->lock );
}",42.0,45.0,1.0,23.0,4.0,2,2,4,3,12,1,1,1,0,1,,0,0,2,1,1,void
3259,159905,playlist_AssertLocked,1,playlist_AssertLocked,void playlist_AssertLocked (playlist_t*),playlist\control.c,"void playlist_AssertLocked( playlist_t *pl )
{
    vlc_assert_locked( &pl_priv(pl)->lock );
}",47.0,50.0,1.0,24.0,4.0,2,2,4,3,0,0,1,1,0,0,,0,0,2,1,1,void
3260,159921,playlist_vaControl,1,playlist_vaControl,"void playlist_vaControl (playlist_t*,int,bool,va_list)",playlist\control.c,"static void playlist_vaControl( playlist_t *p_playlist, int i_query,
                                bool locked, va_list args )
{
    PL_LOCK_IF( !locked );

    if( pl_priv(p_playlist)->killed )
        ;
    else
    switch( i_query )
    {
    case PLAYLIST_STOP:
        pl_priv(p_playlist)->request.b_request = true;
        pl_priv(p_playlist)->request.p_item = NULL;
        pl_priv(p_playlist)->request.p_node = NULL;
        break;

    // Node can be null, it will keep the same. Use with care ...
    // Item null = take the first child of node
    case PLAYLIST_VIEWPLAY:
    {
        playlist_item_t *p_node = va_arg( args, playlist_item_t * );
        playlist_item_t *p_item = va_arg( args, playlist_item_t * );

        assert( locked || (p_item == NULL && p_node == NULL) );

        if ( p_node == NULL )
        {
            p_node = get_current_status_node( p_playlist );
            assert( p_node );
        }
        pl_priv(p_playlist)->request.i_skip = 0;
        pl_pr...",52.0,139.0,1.0,4.0,88.0,7,3,14,4,1,3,2,2,0,3,,0,0,8,4,4,void
3261,160413,playlist_Control,1,playlist_Control,"void playlist_Control (playlist_t*,int,int...)",playlist\control.c,"void playlist_Control( playlist_t *p_playlist, int query, int locked, ... )
{
    va_list args;

    va_start( args, locked );
    playlist_vaControl( p_playlist, query, (bool)locked, args );
    va_end( args );
}",141.0,148.0,1.0,1.0,8.0,1,1,7,4,3,1,1,1,0,1,,0,0,6,3,3,void
3262,160462,VariablesInit,1,VariablesInit,void VariablesInit (playlist_t*),playlist\engine.c,"static void VariablesInit( playlist_t *p_playlist )
{
    /* These variables control updates */
    var_Create( p_playlist, ""item-change"", VLC_VAR_ADDRESS );
    var_Create( p_playlist, ""leaf-to-parent"", VLC_VAR_INTEGER );

    var_Create( p_playlist, ""playlist-item-append"", VLC_VAR_ADDRESS );
    var_Create( p_playlist, ""playlist-item-deleted"", VLC_VAR_ADDRESS );

    var_Create( p_playlist, ""input-current"", VLC_VAR_ADDRESS );

    /* Variables to control playback */
    var_Create( p_playlist, ""playlist-autostart"", VLC_VAR_BOOL | VLC_VAR_DOINHERIT );
    var_Create( p_playlist, ""random"", VLC_VAR_BOOL | VLC_VAR_DOINHERIT );
    var_AddCallback( p_playlist, ""random"", RandomCallback, NULL );
    var_Create( p_playlist, ""repeat"", VLC_VAR_BOOL | VLC_VAR_DOINHERIT );
    var_Create( p_playlist, ""loop"", VLC_VAR_BOOL | VLC_VAR_DOINHERIT );
    var_Create( p_playlist, ""corks"", VLC_VAR_INTEGER );
    var_AddCallback( p_playlist, ""corks"", CorksCallback, NULL );

    var_Create( p_playlist, ""...",428.0,483.0,1.0,1.0,56.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
3263,160467,RandomCallback,1,RandomCallback,"int RandomCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",playlist\engine.c,"static int RandomCallback( vlc_object_t *p_this, char const *psz_cmd,
                           vlc_value_t oldval, vlc_value_t newval, void *a )
{
    (void)psz_cmd; (void)oldval; (void)newval; (void)a;
    playlist_t *p_playlist = (playlist_t*)p_this;
    bool random = newval.b_bool;

    PL_LOCK;

    if( !random ) {
        pl_priv(p_playlist)->b_reset_currently_playing = true;
        vlc_cond_signal( &pl_priv(p_playlist)->signal );
    } else {
        /* Shuffle and sync the playlist on activation of random mode.
         * This preserves the current playing item, so that the user
         * can return to it if needed. (See #4472)
         */
        playlist_private_t *p_sys = pl_priv(p_playlist);
        playlist_item_t *p_new = p_sys->status.p_item;
        ResetCurrentlyPlaying( p_playlist, NULL );
        if( p_new )
            ResyncCurrentIndex( p_playlist, p_new );
    }

    PL_UNLOCK;
    return VLC_SUCCESS;
}",46.0,72.0,1.0,8.0,27.0,13,6,21,13,0,1,2,2,0,1,,0,0,10,5,5,int
3264,160559,CorksCallback,1,CorksCallback,"int CorksCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",playlist\engine.c,"static int CorksCallback( vlc_object_t *obj, char const *var,
                          vlc_value_t old, vlc_value_t cur, void *dummy )
{
    playlist_t *pl = (playlist_t *)obj;

    msg_Dbg( obj, ""corks count: %""PRId64"" -> %""PRId64, old.i_int, cur.i_int );
    if( !old.i_int == !cur.i_int )
        return VLC_SUCCESS; /* nothing to do */

    if( !var_InheritBool( obj, ""playlist-cork"" ) )
        return VLC_SUCCESS;

    playlist_Lock(pl);

    if( cur.i_int )
    {
        bool effective = playlist_Status(pl) == PLAYLIST_RUNNING;

        msg_Dbg(obj, ""corked (%seffective)"", effective ? """" : ""in"");
        pl_priv(pl)->cork_effective = effective;
        playlist_Control(pl, PLAYLIST_PAUSE, pl_Locked);
    }
    else
    {
        bool effective = pl_priv(pl)->cork_effective;

        msg_Dbg(obj, ""uncorked (%seffective)"", effective ? """" : ""in"");

        if (effective)
            playlist_Control(pl, PLAYLIST_RESUME, pl_Locked);
    }

    playlist_Unlock(pl);
    (void) var; (v...",80.0,115.0,1.0,8.0,36.0,16,7,26,13,0,4,4,4,0,4,,0,1,10,5,5,int
3265,160723,RateOffsetCallback,1,RateOffsetCallback,"int RateOffsetCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",playlist\engine.c,"static int RateOffsetCallback( vlc_object_t *obj, char const *psz_cmd,
                               vlc_value_t oldval, vlc_value_t newval, void *p_data )
{
    playlist_t *p_playlist = (playlist_t *)obj;
    VLC_UNUSED(oldval); VLC_UNUSED(p_data); VLC_UNUSED(newval);

    static const float rates[] = {
        1.0/64, 1.0/32, 1.0/16, 1.0/8, 1.0/4, 1.0/3, 1.0/2, 2.0/3,
        1.0/1,
        3.0/2, 2.0/1, 3.0/1, 4.0/1, 8.0/1, 16.0/1, 32.0/1, 64.0/1,
    };

    PL_LOCK;
    input_thread_t *input = pl_priv( p_playlist )->p_input;
    float current_rate = var_GetFloat( input ? VLC_OBJECT( input ) : obj, ""rate"" );
    PL_UNLOCK;

    const bool faster = !strcmp( psz_cmd, ""rate-faster"" );
    float rate = current_rate * ( faster ? 1.1f : 0.9f );

    /* find closest rate (if any) in the desired direction */
    for( size_t i = 0; i < ARRAY_SIZE( rates ); ++i )
    {
        if( ( faster && rates[i] > rate ) ||
            (!faster && rates[i] >= rate && i ) )
        {
            rat...",132.0,167.0,1.0,28.0,36.0,47,15,46,16,0,0,4,4,0,0,,0,0,10,5,5,int
3266,160899,VideoSplitterCallback,1,VideoSplitterCallback,"int VideoSplitterCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",playlist\engine.c,"static int VideoSplitterCallback( vlc_object_t *p_this, char const *psz_cmd,
                                  vlc_value_t oldval, vlc_value_t newval, void *p_data )
{
    playlist_t *p_playlist = (playlist_t*)p_this;
    VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval); VLC_UNUSED(p_data); VLC_UNUSED(newval);

    PL_LOCK;

    /* Force the input to restart the video ES to force a vout recreation */
    input_thread_t *p_input = pl_priv( p_playlist )->p_input;
    if( p_input )
    {
        const double f_position = var_GetFloat( p_input, ""position"" );
        input_Control( p_input, INPUT_RESTART_ES, -VIDEO_ES );
        var_SetFloat( p_input, ""position"", f_position );
    }

    PL_UNLOCK;
    return VLC_SUCCESS;
}",169.0,188.0,1.0,30.0,20.0,6,4,22,15,0,1,2,2,0,1,,0,0,10,5,5,int
3267,160956,playlist_Create,1,playlist_Create,playlist_t playlist_Create (vlc_object_t*),playlist\engine.c,"playlist_t *playlist_Create( vlc_object_t *p_parent )
{
    playlist_t *p_playlist;
    playlist_private_t *p;

    /* Allocate structure */
    p = vlc_custom_create( p_parent, sizeof( *p ), ""playlist"" );
    if( !p )
        return NULL;

    p_playlist = &p->public_data;

    p->input_tree = NULL;
    p->id_tree = NULL;

    TAB_INIT( pl_priv(p_playlist)->i_sds, pl_priv(p_playlist)->pp_sds );

    VariablesInit( p_playlist );
    vlc_mutex_init( &p->lock );
    vlc_cond_init( &p->signal );
    p->killed = false;

    /* Initialise data structures */
    pl_priv(p_playlist)->i_last_playlist_id = 0;
    pl_priv(p_playlist)->p_input = NULL;

    ARRAY_INIT( p_playlist->items );
    ARRAY_INIT( p_playlist->current );

    p_playlist->i_current_index = 0;
    pl_priv(p_playlist)->b_reset_currently_playing = true;

    pl_priv(p_playlist)->b_tree = var_InheritBool( p_parent, ""playlist-tree"" );
    pl_priv(p_playlist)->b_preparse = var_InheritBool( p_parent, ""auto-preparse"" );

    p_pl...",197.0,303.0,1.0,14.0,107.0,97,10,133,21,1,24,10,11,1,14,,0,16,2,1,1,playlist_t
3268,161356,playlist_Destroy,1,playlist_Destroy,void playlist_Destroy (playlist_t*),playlist\engine.c,"void playlist_Destroy( playlist_t *p_playlist )
{
    playlist_private_t *p_sys = pl_priv(p_playlist);

    /* Remove all services discovery */
    playlist_ServicesDiscoveryKillAll( p_playlist );

    msg_Dbg( p_playlist, ""destroying"" );

    playlist_Deactivate( p_playlist );

    /* Release input resources */
    assert( p_sys->p_input == NULL );
    input_resource_Release( p_sys->p_input_resource );
    if( p_sys->p_renderer )
        vlc_renderer_item_release( p_sys->p_renderer );

    if( p_playlist->p_media_library != NULL )
        playlist_MLDump( p_playlist );

    PL_LOCK;
    /* Release the current node */
    set_current_status_node( p_playlist, NULL );
    /* Release the current item */
    set_current_status_item( p_playlist, NULL );

    /* Destroy arrays completely - faster than one item at a time */
    ARRAY_RESET( p_playlist->items );
    ARRAY_RESET( p_playlist->current );

    /* Remove all remaining items */
    if( p_playlist->p_media_library != NULL )
    {
...",312.0,366.0,1.0,32.0,55.0,22,7,39,8,1,19,5,5,1,13,,0,6,2,1,1,void
3269,161479,playlist_CurrentInputLocked,1,playlist_CurrentInputLocked,input_thread_t playlist_CurrentInputLocked (playlist_t*),playlist\engine.c,"input_thread_t *playlist_CurrentInputLocked( playlist_t *p_playlist )
{
    PL_ASSERT_LOCKED;

    input_thread_t *p_input = pl_priv(p_playlist)->p_input;
    if( p_input != NULL )
        vlc_object_hold( p_input );
    return p_input;
}",370.0,378.0,1.0,30.0,9.0,3,3,10,6,1,1,2,2,0,1,,0,0,2,1,1,input_thread_t
3270,161506,playlist_CurrentInput,1,playlist_CurrentInput,input_thread_t playlist_CurrentInput (playlist_t*),playlist\engine.c,"input_thread_t * playlist_CurrentInput( playlist_t * p_playlist )
{
    input_thread_t * p_input;
    PL_LOCK;
    p_input = playlist_CurrentInputLocked( p_playlist );
    PL_UNLOCK;
    return p_input;
}",383.0,390.0,1.0,1.0,8.0,1,1,5,4,0,1,1,1,0,1,,0,1,2,1,1,input_thread_t
3271,161520,get_current_status_item,1,get_current_status_item,playlist_item_t get_current_status_item (playlist_t*),playlist\engine.c,"playlist_item_t * get_current_status_item( playlist_t * p_playlist )
{
    PL_ASSERT_LOCKED;

    return pl_priv(p_playlist)->status.p_item;
}",398.0,403.0,1.0,11.0,6.0,2,2,5,4,2,0,1,1,0,0,,0,0,2,1,1,playlist_item_t
3272,161538,get_current_status_node,1,get_current_status_node,playlist_item_t get_current_status_node (playlist_t*),playlist\engine.c,"playlist_item_t * get_current_status_node( playlist_t * p_playlist )
{
    PL_ASSERT_LOCKED;

    return pl_priv(p_playlist)->status.p_node;
}",405.0,410.0,1.0,11.0,6.0,2,2,5,4,1,0,1,1,0,0,,0,0,2,1,1,playlist_item_t
3273,161556,set_current_status_item,1,set_current_status_item,"void set_current_status_item (playlist_t*,playlist_item_t*)",playlist\engine.c,"void set_current_status_item( playlist_t * p_playlist,
    playlist_item_t * p_item )
{
    PL_ASSERT_LOCKED;

    pl_priv(p_playlist)->status.p_item = p_item;
}",412.0,418.0,1.0,4.0,7.0,3,3,6,5,2,0,1,1,0,0,,0,0,4,2,2,void
3274,161576,set_current_status_node,1,set_current_status_node,"void set_current_status_node (playlist_t*,playlist_item_t*)",playlist\engine.c,"void set_current_status_node( playlist_t * p_playlist,
    playlist_item_t * p_node )
{
    PL_ASSERT_LOCKED;

    pl_priv(p_playlist)->status.p_node = p_node;
}",420.0,426.0,1.0,4.0,7.0,3,3,6,5,2,0,1,1,0,0,,0,0,4,2,2,void
3275,161784,playlist_CurrentPlayingItem,1,playlist_CurrentPlayingItem,playlist_item_t playlist_CurrentPlayingItem (playlist_t*),playlist\engine.c,"playlist_item_t * playlist_CurrentPlayingItem( playlist_t * p_playlist )
{
    PL_ASSERT_LOCKED;

    return pl_priv(p_playlist)->status.p_item;
}",485.0,490.0,1.0,11.0,6.0,2,2,5,4,0,0,1,1,0,0,,0,0,2,1,1,playlist_item_t
3276,161802,playlist_Status,1,playlist_Status,int playlist_Status (playlist_t*),playlist\engine.c,"int playlist_Status( playlist_t * p_playlist )
{
    input_thread_t *p_input = pl_priv(p_playlist)->p_input;

    PL_ASSERT_LOCKED;

    if( p_input == NULL )
        return PLAYLIST_STOPPED;
    if( var_GetInteger( p_input, ""state"" ) == PAUSE_S )
        return PLAYLIST_PAUSED;
    return PLAYLIST_RUNNING;
}",492.0,503.0,1.0,30.0,12.0,4,3,13,10,1,0,3,3,0,0,,0,0,2,1,1,int
3277,161891,pf_worker,1,fetcher_thread.pf_worker,"void fetcher_thread.pf_worker (playlist_fetcher_t*,fetcher_request*)",playlist\fetcher.c,"void (*pf_worker)( playlist_fetcher_t*, struct fetcher_request* );",61.0,61.0,10.0,69.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
3278,161905,CreateCacheKey,1,CreateCacheKey,char* CreateCacheKey (input_item_t*),playlist\fetcher.c,"static char* CreateCacheKey( input_item_t* item )
{
    vlc_mutex_lock( &item->lock );

    if( !item->p_meta )
    {
        vlc_mutex_unlock( &item->lock );
        return NULL;
    }

    char const* artist = vlc_meta_Get( item->p_meta, vlc_meta_Artist );
    char const* album = vlc_meta_Get( item->p_meta, vlc_meta_Album );
    char* key;

    /**
     * Simple concatenation of artist and album can lead to the same key
     * for entities that should not have such. Imagine { dogs, tick } and
     * { dog, stick } */
    if( !artist || !album || asprintf( &key, ""%s:%zu:%s:%zu"",
          artist, strlen( artist ), album, strlen( album ) ) < 0 )
    {
        key = NULL;
    }
    vlc_mutex_unlock( &item->lock );

    return key;
}",72.0,98.0,1.0,1.0,27.0,19,6,21,7,2,5,3,3,0,5,,0,2,2,1,1,char*
3279,161975,FreeCacheEntry,1,FreeCacheEntry,"void FreeCacheEntry (void*,void*)",playlist\fetcher.c,"static void FreeCacheEntry( void* data, void* obj )
{
    free( data );
    VLC_UNUSED( obj );
}",100.0,104.0,1.0,1.0,5.0,0,0,2,2,0,0,1,1,0,0,,0,0,4,2,2,void
3280,161985,ReadAlbumCache,1,ReadAlbumCache,"int ReadAlbumCache (playlist_fetcher_t*,input_item_t*)",playlist\fetcher.c,"static int ReadAlbumCache( playlist_fetcher_t* fetcher, input_item_t* item )
{
    char* key = CreateCacheKey( item );

    if( key == NULL )
        return VLC_EGENERIC;

    vlc_mutex_lock( &fetcher->lock );
    char const* art = vlc_dictionary_value_for_key( &fetcher->album_cache,
                                                    key );
    if( art )
        input_item_SetArtURL( item, art );
    vlc_mutex_unlock( &fetcher->lock );

    free( key );
    return art ? VLC_SUCCESS : VLC_EGENERIC;
}",106.0,122.0,1.0,1.0,17.0,10,5,17,7,2,6,3,3,0,3,,0,4,4,2,2,int
3281,162035,AddAlbumCache,1,AddAlbumCache,"void AddAlbumCache (playlist_fetcher_t*,input_item_t*,bool)",playlist\fetcher.c,"static void AddAlbumCache( playlist_fetcher_t* fetcher, input_item_t* item,
                          bool overwrite )
{
    char* art = input_item_GetArtURL( item );
    char* key = CreateCacheKey( item );

    if( key && art && strncasecmp( art, ""attachment://"", 13 ) )
    {
        vlc_mutex_lock( &fetcher->lock );
        if( overwrite || !vlc_dictionary_has_key( &fetcher->album_cache, key ) )
        {
            vlc_dictionary_insert( &fetcher->album_cache, key, art );
            art = NULL;
        }
        vlc_mutex_unlock( &fetcher->lock );
    }

    free( art );
    free( key );
}",124.0,143.0,1.0,1.0,20.0,15,6,19,6,2,7,3,4,1,3,,0,5,6,3,3,void
3282,162097,InvokeModule,1,InvokeModule,"int InvokeModule (playlist_fetcher_t*,input_item_t*,int,char*)",playlist\fetcher.c,"static int InvokeModule( playlist_fetcher_t* fetcher, input_item_t* item,
                         int scope, char const* type )
{
    meta_fetcher_t* mf = vlc_custom_create( fetcher->owner,
                                            sizeof( *mf ), type );
    if( unlikely( !mf ) )
        return VLC_ENOMEM;

    mf->e_scope = scope;
    mf->p_item = item;

    module_t* mf_module = module_need( mf, type, NULL, false );

    if( mf_module )
        module_unneed( mf, mf_module );

    vlc_object_release( mf );

    return VLC_SUCCESS;
}",145.0,164.0,1.0,25.0,20.0,11,5,22,10,2,6,3,3,0,4,,0,4,8,4,4,int
3283,162158,CheckMeta,1,CheckMeta,int CheckMeta (input_item_t*),playlist\fetcher.c,"static int CheckMeta( input_item_t* item )
{
    vlc_mutex_lock( &item->lock );
    bool error = !item->p_meta ||
                 !vlc_meta_Get( item->p_meta, vlc_meta_Title ) ||
                 !vlc_meta_Get( item->p_meta, vlc_meta_Artist ) ||
                 !vlc_meta_Get( item->p_meta, vlc_meta_Album );
    vlc_mutex_unlock( &item->lock );
    return error;
}",166.0,175.0,1.0,1.0,10.0,16,5,11,5,1,5,1,1,0,5,,0,3,2,1,1,int
3284,162203,CheckArt,1,CheckArt,int CheckArt (input_item_t*),playlist\fetcher.c,"static int CheckArt( input_item_t* item )
{
    vlc_mutex_lock( &item->lock );
    bool error = !item->p_meta ||
                 !vlc_meta_Get( item->p_meta, vlc_meta_ArtworkURL );
    vlc_mutex_unlock( &item->lock );
    return error;
}",177.0,184.0,1.0,1.0,8.0,10,5,7,3,2,3,1,1,0,3,,0,1,2,1,1,int
3285,162234,SearchArt,1,SearchArt,"int SearchArt (playlist_fetcher_t*,input_item_t*,int)",playlist\fetcher.c,"static int SearchArt( playlist_fetcher_t* fetcher, input_item_t* item, int scope)
{
    InvokeModule( fetcher, item, scope, ""art finder"" );
    return CheckArt( item );
}",186.0,190.0,1.0,1.0,5.0,0,0,4,3,1,2,1,1,0,2,,0,0,6,3,3,int
3286,162249,SearchByScope,1,SearchByScope,"int SearchByScope (playlist_fetcher_t*,fetcher_request*,int)",playlist\fetcher.c,"static int SearchByScope( playlist_fetcher_t* fetcher,
    struct fetcher_request* req, int scope )
{
    input_item_t* item = req->item;

    if( CheckMeta( item ) &&
        InvokeModule( fetcher, req->item, scope, ""meta fetcher"" ) )
    {
        return VLC_EGENERIC;
    }

    if( ! CheckArt( item )                            ||
        ! ReadAlbumCache( fetcher, item )             ||
        ! playlist_FindArtInCacheUsingItemUID( item ) ||
        ! playlist_FindArtInCache( item )             ||
        ! SearchArt( fetcher, item, scope ) )
    {
        AddAlbumCache( fetcher, req->item, false );
        if( !background_worker_Push( fetcher->downloader, req, NULL, 0 ) )
            return VLC_SUCCESS;
    }

    return VLC_EGENERIC;
}",192.0,215.0,1.0,1.0,24.0,16,5,23,8,2,13,4,5,10,9,,0,12,6,3,3,int
3287,162320,SetPreparsed,1,SetPreparsed,void SetPreparsed (fetcher_request*),playlist\fetcher.c,"static void SetPreparsed( struct fetcher_request* req )
{
    if( req->preparse_status != -1 )
    {
        input_item_SetPreparsed( req->item, true );
        input_item_SignalPreparseEnded( req->item, req->preparse_status );
    }
}",217.0,224.0,1.0,1.0,8.0,6,3,5,2,4,6,2,2,1,2,,0,4,2,1,1,void
3288,162345,Downloader,1,Downloader,"void Downloader (playlist_fetcher_t*,fetcher_request*)",playlist\fetcher.c,"static void Downloader( playlist_fetcher_t* fetcher,
    struct fetcher_request* req )
{
    ReadAlbumCache( fetcher, req->item );

    char *psz_arturl = input_item_GetArtURL( req->item );
    if( !psz_arturl )
        goto error;

    if( !strncasecmp( psz_arturl, ""file://"", 7 ) ||
        !strncasecmp( psz_arturl, ""attachment://"", 13 ) )
        goto out; /* no fetch required */

    stream_t* source = vlc_stream_NewURL( fetcher->owner, psz_arturl );

    if( !source )
        goto error;

    struct vlc_memstream output_stream;
    vlc_memstream_open( &output_stream );

    for( ;; )
    {
        char buffer[2048];

        int read = vlc_stream_Read( source, buffer, sizeof( buffer ) );
        if( read <= 0 )
            break;

        if( (int)vlc_memstream_write( &output_stream, buffer, read ) < read )
            break;
    }

    vlc_stream_Delete( source );

    if( vlc_memstream_close( &output_stream ) )
        goto error;

    if( vlc_killed() )
    {
        free( ou...",226.0,290.0,1.0,1.0,65.0,28,10,41,9,0,20,18,12,3,11,,0,13,4,2,2,void
3289,162495,SearchLocal,1,SearchLocal,"void SearchLocal (playlist_fetcher_t*,fetcher_request*)",playlist\fetcher.c,"static void SearchLocal( playlist_fetcher_t* fetcher, struct fetcher_request* req )
{
    if( SearchByScope( fetcher, req, FETCHER_SCOPE_LOCAL ) == VLC_SUCCESS )
        return; /* done */

    if( var_InheritBool( fetcher->owner, ""metadata-network-access"" ) ||
        req->options & META_REQUEST_OPTION_SCOPE_NETWORK )
    {
        if( background_worker_Push( fetcher->network, req, NULL, 0 ) )
            SetPreparsed( req );
    }
    else
    {
        input_item_SetArtNotFound( req->item, true );
        SetPreparsed( req );
    }
}",292.0,308.0,1.0,1.0,17.0,6,4,11,6,0,6,4,5,5,3,,0,5,4,2,2,void
3290,162543,SearchNetwork,1,SearchNetwork,"void SearchNetwork (playlist_fetcher_t*,fetcher_request*)",playlist\fetcher.c,"static void SearchNetwork( playlist_fetcher_t* fetcher, struct fetcher_request* req )
{
    if( SearchByScope( fetcher, req, FETCHER_SCOPE_NETWORK ) )
    {
        input_item_SetArtNotFound( req->item, true );
        SetPreparsed( req );
    }
}",310.0,317.0,1.0,1.0,8.0,1,1,6,4,0,4,2,2,1,3,,0,2,4,2,2,void
3291,162562,RequestRelease,1,RequestRelease,void RequestRelease (void*),playlist\fetcher.c,"static void RequestRelease( void* req_ )
{
    struct fetcher_request* req = req_;

    if( atomic_fetch_sub( &req->refs, 1 ) != 1 )
        return;

    input_item_Release( req->item );
    free( req );
}",319.0,328.0,1.0,1.0,10.0,5,4,5,2,1,3,2,2,1,1,,0,2,2,1,1,void
3292,162588,RequestHold,1,RequestHold,void RequestHold (void*),playlist\fetcher.c,"static void RequestHold( void* req_ )
{
    struct fetcher_request* req = req_;
    atomic_fetch_add_explicit( &req->refs, 1, memory_order_relaxed );
}",330.0,334.0,1.0,1.0,5.0,3,3,4,3,0,1,1,1,0,0,,0,1,2,1,1,void
3293,162604,FetcherThread,1,FetcherThread,void* FetcherThread (void*),playlist\fetcher.c,"static void* FetcherThread( void* handle )
{
    struct fetcher_thread* th = handle;
    vlc_interrupt_set( &th->interrupt );

    th->pf_worker( th->fetcher, th->req );

    atomic_store( &th->active, false );
    background_worker_RequestProbe( th->worker );
    return NULL;
}",336.0,346.0,1.0,1.0,11.0,9,3,10,4,0,8,1,1,0,3,,0,5,2,1,1,void*
3294,162640,StartWorker,1,StartWorker,"int StartWorker (playlist_fetcher_t*,void,background_worker*,fetcher_request*,void**)",playlist\fetcher.c,"static int StartWorker( playlist_fetcher_t* fetcher,
    void( *pf_worker )( playlist_fetcher_t*, struct fetcher_request* ),
    struct background_worker* bg, struct fetcher_request* req, void** handle )
{
    struct fetcher_thread* th = malloc( sizeof *th );

    if( unlikely( !th ) )
        return VLC_ENOMEM;

    th->req = req;
    th->worker = bg;
    th->fetcher = fetcher;
    th->pf_worker = pf_worker;

    vlc_interrupt_init( &th->interrupt );
    atomic_init( &th->active, true );

    if( !vlc_clone( &th->thread, FetcherThread, th, VLC_THREAD_PRIORITY_LOW ) )
    {
        *handle = th;
        return VLC_SUCCESS;
    }

    vlc_interrupt_deinit( &th->interrupt );
    free( th );
    return VLC_EGENERIC;
}",348.0,374.0,1.0,1.0,27.0,23,6,24,11,3,10,3,3,2,3,,0,8,10,5,5,int
3295,162720,ProbeWorker,1,ProbeWorker,"int ProbeWorker (void*,void*)",playlist\fetcher.c,"static int ProbeWorker( void* fetcher_, void* th_ )
{
    return !atomic_load( &((struct fetcher_thread*)th_)->active );
    VLC_UNUSED( fetcher_ );
}",376.0,380.0,1.0,1.0,5.0,4,4,2,2,0,0,1,1,0,0,,0,0,4,2,2,int
3296,162737,CloseWorker,1,CloseWorker,"void CloseWorker (void*,void*)",playlist\fetcher.c,"static void CloseWorker( void* fetcher_, void* th_ )
{
    struct fetcher_thread* th = th_;
    VLC_UNUSED( fetcher_ );

    vlc_interrupt_kill( &th->interrupt );
    vlc_join( th->thread, NULL );
    vlc_interrupt_deinit( &th->interrupt );
    free( th );
}",382.0,391.0,1.0,1.0,10.0,6,3,8,4,0,6,1,1,0,3,,0,3,4,2,2,void
3297,162766,StartSearchLocal,1,StartSearchLocal,"int StartSearchLocal (void*,void*,void**)",playlist\fetcher.c,"DEF_STARTER(  SearchLocal, fetcher->local )",398.0,398.0,1.0,43.0,1.0,2,2,6,5,0,2,1,1,0,1,,0,1,6,3,3,int
3298,162786,StartSearchNetwork,1,StartSearchNetwork,"int StartSearchNetwork (void*,void*,void**)",playlist\fetcher.c,"DEF_STARTER(SearchNetwork, fetcher->network )",399.0,399.0,1.0,45.0,1.0,2,2,6,5,0,2,1,1,0,1,,0,1,6,3,3,int
3299,162806,StartDownloader,1,StartDownloader,"int StartDownloader (void*,void*,void**)",playlist\fetcher.c,"DEF_STARTER(   Downloader, fetcher->downloader )",400.0,400.0,1.0,48.0,1.0,2,2,6,5,0,2,1,1,0,1,,0,1,6,3,3,int
3300,162826,WorkerInit,1,WorkerInit,"void WorkerInit (playlist_fetcher_t*,background_worker**,int)",playlist\fetcher.c,"static void WorkerInit( playlist_fetcher_t* fetcher,
    struct background_worker** worker, int( *starter )( void*, void*, void** ) )
{
    struct background_worker_config conf = {
        .default_timeout = 0,
        .pf_start = starter,
        .pf_probe = ProbeWorker,
        .pf_stop = CloseWorker,
        .pf_release = RequestRelease,
        .pf_hold = RequestHold };

    *worker = background_worker_New( fetcher, &conf );
}",402.0,414.0,1.0,1.0,13.0,11,4,11,10,3,1,1,1,0,1,,0,1,6,3,3,void
3301,162868,playlist_fetcher_New,1,playlist_fetcher_New,playlist_fetcher_t playlist_fetcher_New (vlc_object_t*),playlist\fetcher.c,"playlist_fetcher_t* playlist_fetcher_New( vlc_object_t* owner )
{
    playlist_fetcher_t* fetcher = malloc( sizeof( *fetcher ) );

    if( unlikely( !fetcher ) )
        return NULL;

    fetcher->owner = owner;

    WorkerInit( fetcher, &fetcher->local, StartSearchLocal );
    WorkerInit( fetcher, &fetcher->network, StartSearchNetwork );
    WorkerInit( fetcher, &fetcher->downloader, StartDownloader );

    if( unlikely( !fetcher->local || !fetcher->network || !fetcher->downloader ) )
    {
        if( fetcher->local )
            background_worker_Delete( fetcher->local );

        if( fetcher->network )
            background_worker_Delete( fetcher->network );

        if( fetcher->downloader )
            background_worker_Delete( fetcher->downloader );

        free( fetcher );
        return NULL;
    }

    vlc_mutex_init( &fetcher->lock );
    vlc_dictionary_init( &fetcher->album_cache, 0 );

    return fetcher;
}",416.0,448.0,1.0,1.0,33.0,30,7,26,3,1,22,6,9,6,7,,0,15,2,1,1,playlist_fetcher_t
3302,162974,playlist_fetcher_Push,1,playlist_fetcher_Push,"int playlist_fetcher_Push (playlist_fetcher_t*,input_item_t*,input_item_meta_request_option_t,int)",playlist\fetcher.c,"int playlist_fetcher_Push( playlist_fetcher_t* fetcher, input_item_t* item,
    input_item_meta_request_option_t options, int preparse_status )
{
    struct fetcher_request* req = malloc( sizeof *req );

    if( unlikely( !req ) )
        return VLC_ENOMEM;

    req->item = item;
    req->options = options;
    req->preparse_status = preparse_status;

    atomic_init( &req->refs, 1 );
    input_item_Hold( item );

    if( background_worker_Push( fetcher->local, req, NULL, 0 ) )
        SetPreparsed( req );

    RequestRelease( req );
    return VLC_SUCCESS;
}",450.0,470.0,1.0,1.0,21.0,13,6,18,8,2,9,3,3,2,4,,0,6,8,4,4,int
3303,163034,playlist_fetcher_Delete,1,playlist_fetcher_Delete,void playlist_fetcher_Delete (playlist_fetcher_t*),playlist\fetcher.c,"void playlist_fetcher_Delete( playlist_fetcher_t* fetcher )
{
    background_worker_Delete( fetcher->local );
    background_worker_Delete( fetcher->network );
    background_worker_Delete( fetcher->downloader );

    vlc_dictionary_clear( &fetcher->album_cache, FreeCacheEntry, NULL );
    vlc_mutex_destroy( &fetcher->lock );

    free( fetcher );
}",472.0,482.0,1.0,1.0,11.0,7,2,7,2,1,9,1,1,0,4,,0,5,2,1,1,void
3304,163115,playlist_Preparse,1,playlist_Preparse,"void playlist_Preparse (playlist_t*,playlist_item_t*)",playlist\item.c,"static void playlist_Preparse( playlist_t *p_playlist,
                               playlist_item_t *p_item )
{
    playlist_private_t *sys = pl_priv(p_playlist);
    input_item_t *input = p_item->p_input;

    PL_ASSERT_LOCKED;
    /* Preparse if no artist/album info, and hasn't been preparsed already
       and if user has some preparsing option (auto-preparse variable)
       enabled*/
    char *psz_artist = input_item_GetArtist( input );
    char *psz_album = input_item_GetAlbum( input );

    if( sys->b_preparse && !input_item_IsPreparsed( input )
     && (EMPTY_STR(psz_artist) || EMPTY_STR(psz_album)) )
        vlc_MetadataRequest( p_playlist->obj.libvlc, input, 0, -1, p_item );
    free( psz_artist );
    free( psz_album );
}",735.0,753.0,1.0,30.0,19.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
3305,163121,RecursiveAddIntoParent,1,RecursiveAddIntoParent,"int RecursiveAddIntoParent (playlist_t*,playlist_item_t*,input_item_node_t*,int,bool,playlist_item_t**)",playlist\item.c,"static int RecursiveAddIntoParent (
    playlist_t *p_playlist, playlist_item_t *p_parent,
    input_item_node_t *p_node, int i_pos, bool b_flat,
    playlist_item_t **pp_first_leaf )
{
    *pp_first_leaf = NULL;

    if( p_parent->i_children == -1 ) ChangeToNode( p_playlist, p_parent );

    if( i_pos == PLAYLIST_END ) i_pos = p_parent->i_children;

    for( int i = 0; i < p_node->i_children; i++ )
    {
        input_item_node_t *p_child_node = p_node->pp_children[i];

        playlist_item_t *p_new_item = NULL;
        bool b_children = p_child_node->i_children > 0;

        //Create the playlist item represented by input node, if allowed.
        if( !(b_flat && b_children) )
        {
            p_new_item = playlist_NodeAddInput( p_playlist,
                                                p_child_node->p_item,
                                                p_parent, i_pos );
            if( !p_new_item ) return i_pos;

            i_pos++;
        }
        //Recurse if any ...",776.0,824.0,1.0,1.0,49.0,0,0,0,0,1,0,1,1,0,0,,0,0,12,6,6,int
3306,163131,RecursiveInsertCopy,1,RecursiveInsertCopy,"int RecursiveInsertCopy (playlist_t*,playlist_item_t*,playlist_item_t*,int,bool)",playlist\item.c,"static int RecursiveInsertCopy (
    playlist_t *p_playlist, playlist_item_t *p_item,
    playlist_item_t *p_parent, int i_pos, bool b_flat )
{
    PL_ASSERT_LOCKED;
    assert( p_parent != NULL && p_item != NULL );

    if( p_item == p_parent ) return i_pos;

    input_item_t *p_input = p_item->p_input;

    if( p_item->i_children == -1 || !b_flat )
    {
        playlist_item_t *p_new_item = NULL;

        if( p_item->i_children == -1 )
        {
            input_item_t *p_new_input = input_item_Copy( p_input );

            if( likely(p_new_input != NULL) )
            {
                p_new_item = playlist_NodeAddInput( p_playlist, p_new_input,
                                                    p_parent, i_pos );
                input_item_Release( p_new_input );
            }
        }
        else
        {
            vlc_mutex_lock( &p_input->lock );
            p_new_item = playlist_NodeCreate( p_playlist, p_input->psz_name,
                                              ...",826.0,879.0,1.0,1.0,54.0,0,0,0,0,1,0,1,1,0,0,,0,0,10,5,5,int
3307,163140,input_item_add_subitem_tree,1,input_item_add_subitem_tree,"void input_item_add_subitem_tree (vlc_event_t*,void*)",playlist\item.c,"static void input_item_add_subitem_tree ( const vlc_event_t * p_event,
                                          void * user_data )
{
    input_item_t *p_input = p_event->p_obj;
    playlist_t *p_playlist = user_data;
    playlist_private_t *p_sys = pl_priv( p_playlist );
    input_item_node_t *p_new_root = p_event->u.input_item_subitem_tree_added.p_root;

    PL_LOCK;

    playlist_item_t *p_item =
        playlist_ItemGetByInput( p_playlist, p_input );

    assert( p_item != NULL );

    bool b_current = get_current_status_item( p_playlist ) == p_item;
    bool b_autostart = var_GetBool( p_playlist, ""playlist-autostart"" );
    bool b_stop = p_item->i_flags & PLAYLIST_SUBITEM_STOP_FLAG;
    bool b_flat = false;

    p_item->i_flags &= ~PLAYLIST_SUBITEM_STOP_FLAG;

    /* We will have to flatten the tree out if we are in ""the playlist"" node and
    the user setting demands flat playlist */

    if( !pl_priv(p_playlist)->b_tree ) {
        playlist_item_t *p_up = p_item;
        whil...",54.0,224.0,1.0,32.0,171.0,74,13,101,28,0,5,15,22,0,5,,0,3,4,2,2,void
3308,163508,input_item_changed,1,input_item_changed,"void input_item_changed (vlc_event_t*,void*)",playlist\item.c,"static void input_item_changed( const vlc_event_t * p_event,
                                void * user_data )
{
    playlist_t *p_playlist = user_data;

    var_SetAddress( p_playlist, ""item-change"", p_event->p_obj );
}",228.0,234.0,1.0,1.0,7.0,2,2,4,3,0,0,1,1,0,0,,0,0,4,2,2,void
3309,163524,playlist_ItemCmpId,1,playlist_ItemCmpId,"int playlist_ItemCmpId (void*,void*)",playlist\item.c,"static int playlist_ItemCmpId( const void *a, const void *b )
{
    const playlist_item_t *pa = a, *pb = b;

    /* ID are between 1 and INT_MAX, this cannot overflow. */
    return pa->i_id - pb->i_id;
}",236.0,242.0,1.0,1.0,7.0,5,3,6,4,0,0,1,1,0,0,,0,0,4,2,2,int
3310,163546,playlist_ItemCmpInput,1,playlist_ItemCmpInput,"int playlist_ItemCmpInput (void*,void*)",playlist\item.c,"static int playlist_ItemCmpInput( const void *a, const void *b )
{
    const playlist_item_t *pa = a, *pb = b;

    if( pa->p_input == pb->p_input )
        return 0;
    return (((uintptr_t)pa->p_input) > ((uintptr_t)pb->p_input))
        ? +1 : -1;
}",244.0,252.0,1.0,1.0,9.0,13,8,8,4,0,0,2,2,0,0,,0,0,4,2,2,int
3311,163588,playlist_ItemNewFromInput,1,playlist_ItemNewFromInput,"playlist_item_t playlist_ItemNewFromInput (playlist_t*,input_item_t*)",playlist\item.c,"playlist_item_t *playlist_ItemNewFromInput( playlist_t *p_playlist,
                                              input_item_t *p_input )
{
    playlist_private_t *p = pl_priv(p_playlist);
    playlist_item_t **pp, *p_item;

    p_item = malloc( sizeof( playlist_item_t ) );
    if( unlikely(p_item == NULL) )
        return NULL;

    assert( p_input );

    p_item->p_input = p_input;
    p_item->i_id = p->i_last_playlist_id;
    p_item->p_parent = NULL;
    p_item->i_children = (p_input->i_type == ITEM_TYPE_NODE) ? 0 : -1;
    p_item->pp_children = NULL;
    p_item->i_nb_played = 0;
    p_item->i_flags = 0;

    PL_ASSERT_LOCKED;

    do  /* Find an unused ID for the item */
    {
        if( unlikely(p_item->i_id == INT_MAX) )
            p_item->i_id = 0;

        p_item->i_id++;

        if( unlikely(p_item->i_id == p->i_last_playlist_id) )
            goto error; /* All IDs taken */

        pp = tsearch( p_item, &p->id_tree, playlist_ItemCmpId );
        if( unlikely(pp == NULL...",257.0,330.0,1.0,28.0,74.0,64,11,79,19,2,13,10,10,1,7,,0,6,4,2,2,playlist_item_t
3312,163823,playlist_ItemRelease,1,playlist_ItemRelease,"void playlist_ItemRelease (playlist_t*,playlist_item_t*)",playlist\item.c,"void playlist_ItemRelease( playlist_t *p_playlist, playlist_item_t *p_item )
{
    playlist_private_t *p = pl_priv(p_playlist);

    PL_ASSERT_LOCKED;

    vlc_event_manager_t *p_em = &p_item->p_input->event_manager;

    vlc_event_detach( p_em, vlc_InputItemSubItemTreeAdded,
                      input_item_add_subitem_tree, p_playlist );
    vlc_event_detach( p_em, vlc_InputItemMetaChanged,
                      input_item_changed, p_playlist );
    vlc_event_detach( p_em, vlc_InputItemDurationChanged,
                      input_item_changed, p_playlist );
    vlc_event_detach( p_em, vlc_InputItemNameChanged,
                      input_item_changed, p_playlist );
    vlc_event_detach( p_em, vlc_InputItemInfoChanged,
                      input_item_changed, p_playlist );
    vlc_event_detach( p_em, vlc_InputItemErrorWhenReadingChanged,
                      input_item_changed, p_playlist );

    input_item_Release( p_item->p_input );

    tdelete( p_item, &p->input_tree, playlis...",341.0,368.0,1.0,28.0,28.0,11,3,33,13,0,9,1,1,0,7,,0,2,4,2,2,void
3313,163903,playlist_ItemGetById,1,playlist_ItemGetById,"playlist_item_t playlist_ItemGetById (playlist_t*,int)",playlist\item.c,"playlist_item_t *playlist_ItemGetById( playlist_t *p_playlist , int id )
{
    playlist_private_t *p = pl_priv(p_playlist);
    playlist_item_t key, **pp;

    PL_ASSERT_LOCKED;
    key.i_id = id;
    pp = tfind( &key, &p->id_tree, playlist_ItemCmpId );
    return (pp != NULL) ? *pp : NULL;
}",388.0,397.0,1.0,28.0,10.0,10,7,15,9,0,1,1,1,0,0,,0,1,4,2,2,playlist_item_t
3314,163945,playlist_ItemGetByInput,1,playlist_ItemGetByInput,"playlist_item_t playlist_ItemGetByInput (playlist_t*,input_item_t*)",playlist\item.c,"playlist_item_t *playlist_ItemGetByInput( playlist_t * p_playlist,
                                          const input_item_t *item )
{
    playlist_private_t *p = pl_priv(p_playlist);
    playlist_item_t key, **pp;

    PL_ASSERT_LOCKED;
    key.p_input = (input_item_t *)item;
    pp = tfind( &key, &p->input_tree, playlist_ItemCmpInput );
    return (pp != NULL) ? *pp : NULL;
}",411.0,421.0,1.0,28.0,11.0,11,8,15,9,3,1,1,1,0,0,,0,1,4,2,2,playlist_item_t
3315,163989,playlist_Clear,1,playlist_Clear,"void playlist_Clear (playlist_t*,bool)",playlist\item.c,"void playlist_Clear( playlist_t * p_playlist, bool b_locked )
{
    playlist_item_t *p_root = p_playlist->p_playing;

    PL_LOCK_IF( !b_locked );

    for( int i = p_root->i_children - 1; i >= 0 ;i-- )
        playlist_NodeDelete( p_playlist, p_root->pp_children[i] );

    PL_UNLOCK_IF( !b_locked );
}",430.0,440.0,1.0,4.0,11.0,10,5,11,4,0,2,2,2,0,2,,0,0,4,2,2,void
3316,164039,playlist_Add,1,playlist_Add,"int playlist_Add (playlist_t*,char*,bool)",playlist\item.c,"int playlist_Add( playlist_t *p_playlist, const char *psz_uri, bool play_now )
{
    return playlist_AddExt( p_playlist, psz_uri, NULL, play_now,
                            0, NULL, 0, true );
}",454.0,458.0,1.0,1.0,5.0,0,0,6,5,0,1,1,1,0,1,,0,0,6,3,3,int
3317,164056,playlist_AddExt,1,playlist_AddExt,"int playlist_AddExt (playlist_t*,char*,char*,bool,int,char**,unsigned,bool)",playlist\item.c,"int playlist_AddExt( playlist_t *p_playlist, const char * psz_uri,
                     const char *psz_name, bool play_now,
                     int i_options, const char *const *ppsz_options,
                     unsigned i_option_flags,
                     bool b_playlist )
{
    input_item_t *p_input = input_item_New( psz_uri, psz_name );
    if( !p_input )
        return VLC_ENOMEM;
    input_item_AddOptions( p_input, i_options, ppsz_options, i_option_flags );
    int i_ret = playlist_AddInput( p_playlist, p_input, play_now, b_playlist );
    input_item_Release( p_input );
    return i_ret;
}",473.0,486.0,1.0,1.0,14.0,3,2,16,11,2,3,2,2,0,3,,0,1,16,8,8,int
3318,164097,playlist_AddInput,1,playlist_AddInput,"int playlist_AddInput (playlist_t*,input_item_t*,bool,bool)",playlist\item.c,"int playlist_AddInput( playlist_t* p_playlist, input_item_t *p_input,
                       bool play_now, bool b_playlist )
{
    PL_LOCK;
    playlist_item_t *item = b_playlist ? p_playlist->p_playing
                                       : p_playlist->p_media_library;

    item = playlist_NodeAddInput( p_playlist, p_input, item, PLAYLIST_END );

    if( likely(item != NULL) && play_now )
        playlist_ViewPlay( p_playlist, NULL, item );
    PL_UNLOCK;
    return (item != NULL) ? VLC_SUCCESS : VLC_ENOMEM;
}",497.0,510.0,1.0,1.0,14.0,9,5,21,11,2,1,2,2,0,1,,0,1,8,4,4,int
3319,164144,playlist_NodeAddInput,1,playlist_NodeAddInput,"playlist_item_t playlist_NodeAddInput (playlist_t*,input_item_t*,playlist_item_t*,int)",playlist\item.c,"playlist_item_t * playlist_NodeAddInput( playlist_t *p_playlist,
                                         input_item_t *p_input,
                                         playlist_item_t *p_parent, int i_pos )
{
    PL_ASSERT_LOCKED;

    assert( p_input );
    assert( p_parent && p_parent->i_children != -1 );

    playlist_item_t *p_item = playlist_ItemNewFromInput( p_playlist, p_input );
    if( unlikely(p_item == NULL) )
        return NULL;

    if( p_input->i_type != ITEM_TYPE_NODE )
        ARRAY_APPEND(p_playlist->items, p_item);

    playlist_NodeInsert( p_parent, p_item, i_pos );
    playlist_SendAddNotify( p_playlist, p_item );
    playlist_Preparse( p_playlist, p_item );

    return p_item;
}",523.0,544.0,1.0,1.0,22.0,9,6,22,8,3,4,3,3,0,4,,0,1,8,4,4,playlist_item_t
3320,164202,playlist_NodeAddCopy,1,playlist_NodeAddCopy,"int playlist_NodeAddCopy (playlist_t*,playlist_item_t*,playlist_item_t*,int)",playlist\item.c,"int playlist_NodeAddCopy( playlist_t *p_playlist, playlist_item_t *p_item,
    playlist_item_t *p_parent, int i_pos )
{
    PL_ASSERT_LOCKED;
    assert( p_parent != NULL && p_item != NULL );
    assert( p_parent->i_children > -1 );

    if( i_pos == PLAYLIST_END )
        i_pos = p_parent->i_children;

    bool b_flat = false;

    for( playlist_item_t* p_up = p_parent; p_up; p_up = p_up->p_parent )
    {
        if( p_up == p_playlist->p_playing && !pl_priv(p_playlist)->b_tree )
            b_flat = true;

        if( p_up == p_item )
            /* TODO: We don't support copying a node into itself (yet),
            because we insert items as we copy. Instead, we should copy
            all items first and then insert. */
            return i_pos;
    }

    return RecursiveInsertCopy( p_playlist, p_item, p_parent, i_pos, b_flat );
}",557.0,582.0,1.0,46.0,26.0,18,8,31,13,0,1,5,7,0,1,,0,0,8,4,4,int
3321,164288,playlist_InsertInputItemTree,1,playlist_InsertInputItemTree,"int playlist_InsertInputItemTree (playlist_t*,playlist_item_t*,input_item_node_t*,int,bool)",playlist\item.c,"int playlist_InsertInputItemTree (
    playlist_t *p_playlist, playlist_item_t *p_parent,
    input_item_node_t *p_node, int i_pos, bool b_flat )
{
    return RecursiveAddIntoParent( p_playlist, p_parent, p_node, i_pos, b_flat,
                                   &(playlist_item_t*){ NULL } );
}",597.0,603.0,1.0,1.0,7.0,3,3,6,6,2,1,1,1,0,1,,0,0,10,5,5,int
3322,164309,ItemIndex,1,ItemIndex,int ItemIndex (playlist_item_t*),playlist\item.c,"static int ItemIndex ( playlist_item_t *p_item )
{
    int idx;

    TAB_FIND( p_item->p_parent->i_children,
              p_item->p_parent->pp_children,
              p_item,
              idx );

    return idx;
}",610.0,620.0,1.0,1.0,11.0,4,1,5,2,2,0,1,1,0,0,,0,0,2,1,1,int
3323,164330,playlist_TreeMove,1,playlist_TreeMove,"int playlist_TreeMove (playlist_t*,playlist_item_t*,playlist_item_t*,int)",playlist\item.c,"int playlist_TreeMove( playlist_t * p_playlist, playlist_item_t *p_item,
                       playlist_item_t *p_node, int i_newpos )
{
    PL_ASSERT_LOCKED;

    if( p_node->i_children == -1 ) return VLC_EGENERIC;

    playlist_item_t *p_detach = p_item->p_parent;
    int i_index = ItemIndex( p_item );

    TAB_ERASE(p_detach->i_children, p_detach->pp_children, i_index);

    if( p_detach == p_node && i_index < i_newpos )
        i_newpos--;

    TAB_INSERT(p_node->i_children, p_node->pp_children, p_item, i_newpos);
    p_item->p_parent = p_node;

    pl_priv( p_playlist )->b_reset_currently_playing = true;
    vlc_cond_signal( &pl_priv( p_playlist )->signal );
    return VLC_SUCCESS;
}",633.0,654.0,1.0,4.0,22.0,20,8,31,12,0,2,3,3,0,2,,0,1,8,4,4,int
3324,164417,playlist_TreeMoveMany,1,playlist_TreeMoveMany,"int playlist_TreeMoveMany (playlist_t*,int,playlist_item_t**,playlist_item_t*,int)",playlist\item.c,"int playlist_TreeMoveMany( playlist_t *p_playlist,
                            int i_items, playlist_item_t **pp_items,
                            playlist_item_t *p_node, int i_newpos )
{
    PL_ASSERT_LOCKED;

    if ( p_node->i_children == -1 ) return VLC_EGENERIC;

    for( int i = 0; i < i_items; i++ )
    {
        playlist_item_t *p_item = pp_items[i];
        int i_index = ItemIndex( p_item );
        playlist_item_t *p_parent = p_item->p_parent;
        TAB_ERASE(p_parent->i_children, p_parent->pp_children, i_index);
        if ( p_parent == p_node && i_index < i_newpos ) i_newpos--;
    }
    for( int i = i_items - 1; i >= 0; i-- )
    {
        playlist_item_t *p_item = pp_items[i];
        TAB_INSERT(p_node->i_children, p_node->pp_children, p_item, i_newpos);
        p_item->p_parent = p_node;
    }

    pl_priv( p_playlist )->b_reset_currently_playing = true;
    vlc_cond_signal( &pl_priv( p_playlist )->signal );
    return VLC_SUCCESS;
}",668.0,694.0,1.0,4.0,27.0,29,11,43,15,0,2,5,6,0,2,,0,1,10,5,5,int
3325,164543,playlist_SendAddNotify,1,playlist_SendAddNotify,"void playlist_SendAddNotify (playlist_t*,playlist_item_t*)",playlist\item.c,"void playlist_SendAddNotify( playlist_t *p_playlist, playlist_item_t *item )
{
    playlist_private_t *p_sys = pl_priv(p_playlist);
    PL_ASSERT_LOCKED;

    p_sys->b_reset_currently_playing = true;
    vlc_cond_signal( &p_sys->signal );

    var_SetAddress( p_playlist, ""playlist-item-append"", item );
}",704.0,713.0,1.0,32.0,10.0,5,3,11,7,2,3,1,1,0,1,,0,2,4,2,2,void
3326,164574,playlist_GetNodeDuration,1,playlist_GetNodeDuration,mtime_t playlist_GetNodeDuration (playlist_item_t*),playlist\item.c,"mtime_t playlist_GetNodeDuration( playlist_item_t* node )
{
    mtime_t duration = input_item_GetDuration( node->p_input );
    if( duration == -1 )
        duration = 0;

    for( int i = 0; i < node->i_children; i++ )
        duration += playlist_GetNodeDuration( node->pp_children[i] );

    return duration;
}",718.0,728.0,1.0,1.0,11.0,8,5,8,3,0,1,3,3,0,1,,0,1,2,1,1,mtime_t
3327,164681,ChangeToNode,1,ChangeToNode,"void ChangeToNode (playlist_t*,playlist_item_t*)",playlist\item.c,"static void ChangeToNode( playlist_t *p_playlist, playlist_item_t *p_item )
{
    int i;
    if( p_item->i_children != -1 ) return;

    p_item->i_children = 0;

    input_item_t *p_input = p_item->p_input;
    vlc_mutex_lock( &p_input->lock );
    p_input->i_type = ITEM_TYPE_NODE;
    vlc_mutex_unlock( &p_input->lock );

    var_SetAddress( p_playlist, ""item-change"", p_item->p_input );

    /* Remove it from the array of available items */
    ARRAY_BSEARCH( p_playlist->items,->i_id, int, p_item->i_id, i );
    if( i != -1 )
        ARRAY_REMOVE( p_playlist->items, i );
}",756.0,774.0,1.0,1.0,19.0,17,5,13,5,0,2,3,3,0,2,,0,0,4,2,2,void
3328,165067,playlist_Export,1,playlist_Export,"int playlist_Export (playlist_t*,char*,bool,char*)",playlist\loadsave.c,"int playlist_Export( playlist_t * p_playlist, const char *psz_filename,
                     bool b_playlist, const char *psz_type )
{
    playlist_export_t *p_export =
        vlc_custom_create( p_playlist, sizeof( *p_export ), ""playlist export"" );
    if( unlikely(p_export == NULL) )
        return VLC_ENOMEM;

    msg_Dbg( p_export, ""saving %s to file %s"",
             b_playlist ? ""playlist"" : ""media library"", psz_filename );

    int ret = VLC_EGENERIC;

    /* Prepare the playlist_export_t structure */
    p_export->base_url = vlc_path2uri( psz_filename, NULL );
    p_export->p_file = vlc_fopen( psz_filename, ""wt"" );
    if( p_export->p_file == NULL )
    {
        msg_Err( p_export, ""could not create playlist file %s: %s"",
                 psz_filename, vlc_strerror_c(errno) );
        goto out;
    }

    module_t *p_module;

    /* And call the module ! All work is done now */
    playlist_Lock( p_playlist );
    p_export->p_root = b_playlist ? p_playlist->p_playing
       ...",41.0,90.0,1.0,1.0,50.0,24,8,42,13,1,9,6,6,0,9,,0,4,8,4,4,int
3329,165199,playlist_Import,1,playlist_Import,"int playlist_Import (playlist_t*,char*)",playlist\loadsave.c,"int playlist_Import( playlist_t *p_playlist, const char *psz_file )
{
    input_item_t *p_input;
    char *psz_uri = vlc_path2uri( psz_file, NULL );

    if( psz_uri == NULL )
        return VLC_EGENERIC;

    p_input = input_item_New( psz_uri, psz_file );
    free( psz_uri );

    playlist_AddInput( p_playlist, p_input, false, true );

    vlc_object_t *dummy = vlc_object_create( p_playlist, sizeof (*dummy) );
    var_Create( dummy, ""meta-file"", VLC_VAR_VOID );

    int ret = input_Read( dummy, p_input );

    vlc_object_release( dummy );
    return ret;
}",92.0,112.0,1.0,1.0,21.0,7,4,24,11,0,6,2,2,0,6,,0,3,4,2,2,int
3330,165253,input_item_subitem_tree_added,1,input_item_subitem_tree_added,"void input_item_subitem_tree_added (vlc_event_t*,void*)",playlist\loadsave.c,"static void input_item_subitem_tree_added( const vlc_event_t * p_event,
                                      void * user_data )
{
    playlist_t *p_playlist = user_data;
    input_item_node_t *p_root =
        p_event->u.input_item_subitem_tree_added.p_root;

    PL_LOCK;
    playlist_InsertInputItemTree ( p_playlist, p_playlist->p_media_library,
                                   p_root, 0, false );
    PL_UNLOCK;
}",117.0,128.0,1.0,1.0,12.0,6,3,10,7,0,1,1,1,0,1,,0,0,4,2,2,void
3331,165283,playlist_MLLoad,1,playlist_MLLoad,int playlist_MLLoad (playlist_t*),playlist\loadsave.c,"int playlist_MLLoad( playlist_t *p_playlist )
{
    char *psz_datadir = config_GetUserDir( VLC_DATA_DIR );
    if( !psz_datadir ) /* XXX: This should never happen */
    {
        msg_Err( p_playlist, ""no data directory, cannot load media library"") ;
        return VLC_EGENERIC;
    }

    char *psz_file;
    if( asprintf( &psz_file, ""%s"" DIR_SEP ""ml.xspf"", psz_datadir ) == -1 )
        psz_file = NULL;
    free( psz_datadir );
    if( psz_file == NULL )
        return VLC_ENOMEM;

    /* lousy check for media library file */
    struct stat st;
    if( vlc_stat( psz_file, &st ) )
    {
        free( psz_file );
        return VLC_EGENERIC;
    }

    char *psz_uri = vlc_path2uri( psz_file, ""file/directory"" );
    free( psz_file );
    if( psz_uri == NULL )
        return VLC_ENOMEM;

    input_item_t *p_input = input_item_New( psz_uri, _(""Media Library"") );
    free( psz_uri );
    if( p_input == NULL )
        return VLC_EGENERIC;

    vlc_event_attach( &p_input->event_manager, vl...",130.0,177.0,1.0,1.0,48.0,16,7,43,14,1,10,7,7,1,10,,0,4,2,1,1,int
3332,165397,playlist_MLDump,1,playlist_MLDump,int playlist_MLDump (playlist_t*),playlist\loadsave.c,"int playlist_MLDump( playlist_t *p_playlist )
{
    char *psz_temp;

    psz_temp = config_GetUserDir( VLC_DATA_DIR );

    if( !psz_temp ) /* XXX: This should never happen */
    {
        msg_Err( p_playlist, ""no data directory, cannot save media library"") ;
        return VLC_EGENERIC;
    }

    char psz_dirname[ strlen( psz_temp ) + sizeof( DIR_SEP ""ml.xspf"")];
    strcpy( psz_dirname, psz_temp );
    free( psz_temp );
    if( config_CreateDir( (vlc_object_t *)p_playlist, psz_dirname ) )
    {
        return VLC_EGENERIC;
    }

    strcat( psz_dirname, DIR_SEP ""ml.xspf"" );

    if ( asprintf( &psz_temp, ""%s.tmp%""PRIu32, psz_dirname, (uint32_t)getpid() ) < 1 )
        return VLC_EGENERIC;

    int i_ret = playlist_Export( p_playlist, psz_temp, false, ""export-xspf"" );
    if ( i_ret != VLC_SUCCESS )
    {
        vlc_unlink( psz_temp );
        free( psz_temp );
        return i_ret;
    }

    i_ret = vlc_rename( psz_temp, psz_dirname );
    free( psz_temp );
    if( i_ret == -...",179.0,221.0,1.0,1.0,43.0,8,6,31,9,1,6,6,6,1,6,,0,4,2,1,1,int
3333,165494,playlist_ServicesDiscoveryKillAll,1,playlist_ServicesDiscoveryKillAll,void playlist_ServicesDiscoveryKillAll (playlist_t*),playlist\services_discovery.c,"void playlist_ServicesDiscoveryKillAll(playlist_t *playlist)
{
    playlist_private_t *priv = pl_priv(playlist);

    playlist_Lock(playlist);
    while (priv->i_sds > 0)
    {
        vlc_sd_internal_t *sds = priv->pp_sds[priv->i_sds - 1];
        TAB_ERASE(priv->i_sds, priv->pp_sds, priv->i_sds - 1);

        playlist_ServicesDiscoveryInternalRemoveLocked(playlist, sds);
    }

    playlist_Unlock(playlist);
}",247.0,261.0,1.0,31.0,15.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
3334,165542,playlist_Activate,1,playlist_Activate,void playlist_Activate (playlist_t*),playlist\thread.c,"void playlist_Activate( playlist_t *p_playlist )
{
    playlist_private_t *p_sys = pl_priv(p_playlist);

    if( vlc_clone( &p_sys->thread, Thread, p_playlist,
                   VLC_THREAD_PRIORITY_LOW ) )
    {
        msg_Err( p_playlist, ""cannot spawn playlist thread"" );
        abort();
    }
}",51.0,61.0,1.0,32.0,11.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
3335,165600,playlist_NodeInsert,1,playlist_NodeInsert,"int playlist_NodeInsert (playlist_item_t*,playlist_item_t*,int)",playlist\tree.c,"int playlist_NodeInsert( playlist_item_t *p_parent, playlist_item_t *p_item,
                         int i_position )
{
    assert( p_parent && p_parent->i_children != -1 );
    if( i_position == -1 ) i_position = p_parent->i_children ;
    assert( i_position <= p_parent->i_children);

    TAB_INSERT(p_parent->i_children, p_parent->pp_children,
               p_item, i_position);
    p_item->p_parent = p_parent;

    /* Inherit special flags from parent (sd cases) */
    if( ( p_parent->i_flags & PLAYLIST_NO_INHERIT_FLAG ) == 0 )
        p_item->i_flags |= (p_parent->i_flags & PLAYLIST_RO_FLAG);

    return VLC_SUCCESS;
}",149.0,165.0,1.0,1.0,17.0,0,0,0,0,2,0,1,1,0,0,,0,0,6,3,3,int
3336,165607,playlist_NodeDeleteExplicit,1,playlist_NodeDeleteExplicit,"void playlist_NodeDeleteExplicit (playlist_t*,playlist_item_t*,int)",playlist\tree.c,"void playlist_NodeDeleteExplicit( playlist_t *p_playlist,
    playlist_item_t *p_root, int flags )
{
    PL_ASSERT_LOCKED;

    /* Delete the node */
    if( p_root->i_flags & PLAYLIST_RO_FLAG &&
        !( flags & PLAYLIST_DELETE_FORCE ) )
        return;

    /* Delete the children */
    for( int i = p_root->i_children - 1 ; i >= 0; i-- )
        playlist_NodeDeleteExplicit( p_playlist,
            p_root->pp_children[i], flags | PLAYLIST_DELETE_FORCE );

    pl_priv(p_playlist)->b_reset_currently_playing = true;

    int i;
    var_SetAddress( p_playlist, ""playlist-item-deleted"", p_root );

    if( p_root->i_children == -1 ) {
        ARRAY_BSEARCH( p_playlist->items,->i_id, int, p_root->i_id, i );
        if( i != -1 )
            ARRAY_REMOVE( p_playlist->items, i );
    }

    if( get_current_status_item( p_playlist ) == p_root )
    {
        /* a deleted item cannot be currently playing */
        set_current_status_item( p_playlist, NULL );

        if( flags & PLAYLIST_DE...",98.0,147.0,1.0,19.0,50.0,0,0,0,0,6,0,1,1,0,0,,0,0,6,3,3,void
3337,165620,ResetCurrentlyPlaying,1,ResetCurrentlyPlaying,"void ResetCurrentlyPlaying (playlist_t*,playlist_item_t*)",playlist\thread.c,"void ResetCurrentlyPlaying( playlist_t *p_playlist,
                                   playlist_item_t *p_cur )
{
    playlist_private_t *p_sys = pl_priv(p_playlist);

    PL_DEBUG( ""rebuilding array of current - root %s"",
              PLI_NAME( p_sys->status.p_node ) );
    ARRAY_RESET( p_playlist->current );
    p_playlist->i_current_index = -1;
    for( playlist_item_t *p_next = NULL; ; )
    {
        /** FIXME: this is *slow* */
        p_next = playlist_GetNextLeaf( p_playlist,
                                       p_sys->status.p_node,
                                       p_next, true, false );
        if( !p_next )
            break;

        if( p_next == p_cur )
            p_playlist->i_current_index = p_playlist->current.i_size;
        ARRAY_APPEND( p_playlist->current, p_next);
    }
    PL_DEBUG(""rebuild done - %i items, index %i"", p_playlist->current.i_size,
                                                  p_playlist->i_current_index);

    if( var_GetBool( p_pl...",146.0,185.0,1.0,32.0,40.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,void
3338,165626,ResyncCurrentIndex,1,ResyncCurrentIndex,"void ResyncCurrentIndex (playlist_t*,playlist_item_t*)",playlist\thread.c,"void ResyncCurrentIndex( playlist_t *p_playlist, playlist_item_t *p_cur )
{
    PL_ASSERT_LOCKED;

    PL_DEBUG( ""resyncing on %s"", PLI_NAME( p_cur ) );
    /* Simply resync index */
    int i;
    p_playlist->i_current_index = -1;
    for( i = 0 ; i< p_playlist->current.i_size; i++ )
    {
        if( ARRAY_VAL( p_playlist->current, i ) == p_cur )
        {
            p_playlist->i_current_index = i;
            break;
        }
    }
    PL_DEBUG( ""%s is at %i"", PLI_NAME( p_cur ), p_playlist->i_current_index );
}",120.0,137.0,1.0,4.0,18.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
3339,165632,playlist_GetNextLeaf,1,playlist_GetNextLeaf,"playlist_item_t* playlist_GetNextLeaf (playlist_t*,playlist_item_t*,playlist_item_t*,bool,bool)",playlist\tree.c,"playlist_item_t *playlist_GetNextLeaf( playlist_t *p_playlist,
                                       playlist_item_t *p_root,
                                       playlist_item_t *p_item,
                                       bool b_ena, bool b_unplayed )
{
    PL_ASSERT_LOCKED;
    playlist_item_t *p_next;

    assert( p_root && p_root->i_children != -1 );

    PL_DEBUG2( ""finding next of %s within %s"",
               PLI_NAME( p_item ), PLI_NAME( p_root ) );

    /* Now, walk the tree until we find a suitable next item */
    p_next = p_item;
    while( 1 )
    {
        bool b_ena_ok = true, b_unplayed_ok = true;
        p_next = GetNextItem( p_playlist, p_root, p_next );
        if( !p_next || p_next == p_root )
            break;
        if( p_next->i_children == -1 )
        {
            if( b_ena && p_next->i_flags & PLAYLIST_DBL_FLAG )
                b_ena_ok = false;
            if( b_unplayed && p_next->i_nb_played != 0 )
                b_unplayed_ok = false;
      ...",207.0,239.0,1.0,4.0,33.0,0,0,0,0,1,0,1,1,0,0,,0,0,10,5,5,playlist_item_t
3340,165643,pl_lock_if,1,pl_lock_if,"void pl_lock_if (playlist_t*,bool)",playlist\playlist_internal.h,"static inline void pl_lock_if( playlist_t * p_playlist, bool cond )
{
    if( cond ) PL_LOCK; else PL_ASSERT_LOCKED;
}",183.0,186.0,1.0,1.0,4.0,0,0,2,2,2,0,2,2,0,0,,0,0,4,2,2,void
3341,165656,pl_unlock_if,1,pl_unlock_if,"void pl_unlock_if (playlist_t*,bool)",playlist\playlist_internal.h,"static inline void pl_unlock_if( playlist_t * p_playlist, bool cond )
{
    if( cond ) PL_UNLOCK;
}",189.0,192.0,1.0,1.0,4.0,0,0,2,2,2,0,2,2,0,0,,0,0,4,2,2,void
3342,165717,PreparserOpenInput,1,PreparserOpenInput,"int PreparserOpenInput (void*,void*,void**)",playlist\preparser.c,"static int PreparserOpenInput( void* preparser_, void* item_, void** out )
{
    playlist_preparser_t* preparser = preparser_;

    input_thread_t* input = input_CreatePreparser( preparser->owner, item_ );
    if( !input )
    {
        input_item_SignalPreparseEnded( item_, ITEM_PREPARSE_FAILED );
        return VLC_EGENERIC;
    }

    var_AddCallback( input, ""intf-event"", InputEvent, preparser->worker );
    if( input_Start( input ) )
    {
        var_DelCallback( input, ""intf-event"", InputEvent, preparser->worker );
        input_Close( input );
        input_item_SignalPreparseEnded( item_, ITEM_PREPARSE_FAILED );
        return VLC_EGENERIC;
    }

    *out = input;
    return VLC_SUCCESS;
}",53.0,75.0,1.0,1.0,23.0,8,4,21,8,0,10,3,3,1,7,,0,5,6,3,3,int
3343,165776,PreparserProbeInput,1,PreparserProbeInput,"int PreparserProbeInput (void*,void*)",playlist\preparser.c,"static int PreparserProbeInput( void* preparser_, void* input_ )
{
    int state = input_GetState( input_ );
    return state == END_S || state == ERROR_S;
    VLC_UNUSED( preparser_ );
}",77.0,82.0,1.0,1.0,6.0,4,3,7,5,0,0,1,1,0,0,,0,0,4,2,2,int
3344,165797,PreparserCloseInput,1,PreparserCloseInput,"void PreparserCloseInput (void*,void*)",playlist\preparser.c,"static void PreparserCloseInput( void* preparser_, void* input_ )
{
    playlist_preparser_t* preparser = preparser_;
    input_thread_t* input = input_;
    input_item_t* item = input_priv(input)->p_item;

    var_DelCallback( input, ""intf-event"", InputEvent, preparser->worker );

    int status;
    switch( input_GetState( input ) )
    {
        case END_S:
            status = ITEM_PREPARSE_DONE;
            break;
        case ERROR_S:
            status = ITEM_PREPARSE_FAILED;
            break;
        default:
            status = ITEM_PREPARSE_TIMEOUT;
    }

    input_Stop( input );
    input_Close( input );

    if( preparser->fetcher )
    {
        if( !playlist_fetcher_Push( preparser->fetcher, item, 0, status ) )
            return;
    }

    input_item_SetPreparsed( item, true );
    input_item_SignalPreparseEnded( item, status );
}",84.0,116.0,1.0,1.0,33.0,11,3,27,12,0,10,6,5,3,7,,0,5,4,2,2,void
3345,165872,InputItemRelease,1,InputItemRelease,void InputItemRelease (void*),playlist\preparser.c,static void InputItemRelease( void* item ) { input_item_Release( item ); },118.0,118.0,1.0,74.0,1.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
3346,165879,InputItemHold,1,InputItemHold,void InputItemHold (void*),playlist\preparser.c,static void InputItemHold( void* item ) { input_item_Hold( item ); },119.0,119.0,1.0,68.0,1.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
3347,165886,playlist_preparser_New,1,playlist_preparser_New,playlist_preparser_t playlist_preparser_New (vlc_object_t*),playlist\preparser.c,"playlist_preparser_t* playlist_preparser_New( vlc_object_t *parent )
{
    playlist_preparser_t* preparser = malloc( sizeof *preparser );

    struct background_worker_config conf = {
        .default_timeout = var_InheritInteger( parent, ""preparse-timeout"" ),
        .pf_start = PreparserOpenInput,
        .pf_probe = PreparserProbeInput,
        .pf_stop = PreparserCloseInput,
        .pf_release = InputItemRelease,
        .pf_hold = InputItemHold };


    if( likely( preparser ) )
        preparser->worker = background_worker_New( preparser, &conf );

    if( unlikely( !preparser || !preparser->worker ) )
    {
        free( preparser );
        return NULL;
    }

    preparser->owner = parent;
    preparser->fetcher = playlist_fetcher_New( parent );
    atomic_init( &preparser->deactivated, false );

    if( unlikely( !preparser->fetcher ) )
        msg_Warn( parent, ""unable to create art fetcher"" );

    return preparser;
}",121.0,151.0,1.0,1.0,31.0,26,8,27,11,1,8,4,4,2,2,,0,8,2,1,1,playlist_preparser_t
3348,165983,playlist_preparser_Push,1,playlist_preparser_Push,"void playlist_preparser_Push (playlist_preparser_t*,input_item_t*,input_item_meta_request_option_t,int,void*)",playlist\preparser.c,"void playlist_preparser_Push( playlist_preparser_t *preparser,
    input_item_t *item, input_item_meta_request_option_t i_options,
    int timeout, void *id )
{
    if( atomic_load( &preparser->deactivated ) )
        return;

    vlc_mutex_lock( &item->lock );
    int i_type = item->i_type;
    int b_net = item->b_net;
    vlc_mutex_unlock( &item->lock );

    switch( i_type )
    {
        case ITEM_TYPE_NODE:
        case ITEM_TYPE_FILE:
        case ITEM_TYPE_DIRECTORY:
        case ITEM_TYPE_PLAYLIST:
            if( !b_net || i_options & META_REQUEST_OPTION_SCOPE_NETWORK )
                break;
        default:
            input_item_SignalPreparseEnded( item, ITEM_PREPARSE_SKIPPED );
            return;
    }

    if( background_worker_Push( preparser->worker, item, id, timeout ) )
        input_item_SignalPreparseEnded( item, ITEM_PREPARSE_FAILED );
}",153.0,180.0,1.0,1.0,28.0,14,6,23,14,2,7,6,6,3,5,,0,3,10,5,5,void
3349,166059,playlist_preparser_fetcher_Push,1,playlist_preparser_fetcher_Push,"void playlist_preparser_fetcher_Push (playlist_preparser_t*,input_item_t*,input_item_meta_request_option_t)",playlist\preparser.c,"void playlist_preparser_fetcher_Push( playlist_preparser_t *preparser,
    input_item_t *item, input_item_meta_request_option_t options )
{
    if( preparser->fetcher )
        playlist_fetcher_Push( preparser->fetcher, item, options, -1 );
}",182.0,187.0,1.0,1.0,6.0,3,2,4,3,1,3,2,2,1,1,,0,2,6,3,3,void
3350,166079,playlist_preparser_Cancel,1,playlist_preparser_Cancel,"void playlist_preparser_Cancel (playlist_preparser_t*,void*)",playlist\preparser.c,"void playlist_preparser_Cancel( playlist_preparser_t *preparser, void *id )
{
    background_worker_Cancel( preparser->worker, id );
}",189.0,192.0,1.0,1.0,4.0,1,1,2,2,1,2,1,1,0,1,,0,1,4,2,2,void
3351,166090,playlist_preparser_Deactivate,1,playlist_preparser_Deactivate,void playlist_preparser_Deactivate (playlist_preparser_t*),playlist\preparser.c,"void playlist_preparser_Deactivate( playlist_preparser_t* preparser )
{
    atomic_store( &preparser->deactivated, true );
    background_worker_Cancel( preparser->worker, NULL );
}",194.0,198.0,1.0,1.0,5.0,3,2,4,3,1,3,1,1,0,1,,0,2,2,1,1,void
3352,166106,playlist_preparser_Delete,1,playlist_preparser_Delete,void playlist_preparser_Delete (playlist_preparser_t*),playlist\preparser.c,"void playlist_preparser_Delete( playlist_preparser_t *preparser )
{
    background_worker_Delete( preparser->worker );

    if( preparser->fetcher )
        playlist_fetcher_Delete( preparser->fetcher );

    free( preparser );
}",200.0,208.0,1.0,1.0,9.0,3,1,4,1,1,5,2,2,1,2,,0,3,2,1,1,void
3353,166187,playlist_SetRenderer,1,playlist_SetRenderer,"int playlist_SetRenderer (playlist_t*,vlc_renderer_item_t*)",playlist\renderer.c,"int playlist_SetRenderer( playlist_t* p_playlist, vlc_renderer_item_t* p_item )
{
    if( p_item )
        vlc_renderer_item_hold( p_item );

    PL_LOCK;

    playlist_private_t *p_priv = pl_priv( p_playlist );
    vlc_renderer_item_t *p_prev_renderer = p_priv->p_renderer;
    p_priv->p_renderer = p_item;
    if( p_priv->p_input )
        input_Control( p_priv->p_input, INPUT_SET_RENDERER, p_item );

    PL_UNLOCK;

    if( p_prev_renderer )
        vlc_renderer_item_release( p_prev_renderer );
    return VLC_SUCCESS;
}",33.0,51.0,1.0,33.0,19.0,7,2,20,10,0,7,4,4,1,3,,0,4,4,2,2,int
3354,166256,playlist_LiveSearchClean,1,playlist_LiveSearchClean,void playlist_LiveSearchClean (playlist_item_t*),playlist\search.c,"static void playlist_LiveSearchClean( playlist_item_t *p_root )
{
    for( int i = 0; i < p_root->i_children; i++ )
    {
        playlist_item_t *p_item = p_root->pp_children[i];
        if( p_item->i_children >= 0 )
            playlist_LiveSearchClean( p_item );
        p_item->i_flags &= ~PLAYLIST_DBL_FLAG;
    }
}",45.0,54.0,1.0,1.0,10.0,10,6,10,4,0,0,3,4,0,0,,0,0,2,1,1,void
3355,166298,playlist_LiveSearchUpdateInternal,1,playlist_LiveSearchUpdateInternal,"bool playlist_LiveSearchUpdateInternal (playlist_item_t*,char*,bool)",playlist\search.c,"static bool playlist_LiveSearchUpdateInternal( playlist_item_t *p_root,
                                               const char *psz_string, bool b_recursive )
{
    int i;
    bool b_match = false;
    for( i = 0 ; i < p_root->i_children ; i ++ )
    {
        bool b_enable = false;
        playlist_item_t *p_item = p_root->pp_children[i];
        // Go recurssively if their is some children
        if( b_recursive && p_item->i_children >= 0 &&
            playlist_LiveSearchUpdateInternal( p_item, psz_string, true ) )
        {
            b_enable = true;
        }

        if( !b_enable )
        {
            vlc_mutex_lock( &p_item->p_input->lock );
            // Do we have some meta ?
            if( p_item->p_input->p_meta )
            {
                // Use Title or fall back to psz_name
                const char *psz_title = vlc_meta_Get( p_item->p_input->p_meta, vlc_meta_Title );
                if( !psz_title )
                    psz_title = p_item->p_input->psz_...",63.0,108.0,1.0,1.0,46.0,43,10,49,16,1,8,7,15,0,8,,0,6,6,3,3,bool
3356,166475,playlist_LiveSearchUpdate,1,playlist_LiveSearchUpdate,"int playlist_LiveSearchUpdate (playlist_t*,playlist_item_t*,char*,bool)",playlist\search.c,"int playlist_LiveSearchUpdate( playlist_t *p_playlist, playlist_item_t *p_root,
                               const char *psz_string, bool b_recursive )
{
    PL_ASSERT_LOCKED;
    pl_priv(p_playlist)->b_reset_currently_playing = true;
    if( *psz_string )
        playlist_LiveSearchUpdateInternal( p_root, psz_string, b_recursive );
    else
        playlist_LiveSearchClean( p_root );
    vlc_cond_signal( &pl_priv(p_playlist)->signal );
    return VLC_SUCCESS;
}",119.0,130.0,1.0,4.0,12.0,5,4,15,9,0,2,2,2,0,2,,0,0,8,4,4,int
3357,166546,playlist_sd_item_added,1,playlist_sd_item_added,"void playlist_sd_item_added (services_discovery_t*,input_item_t*,input_item_t*,char*)",playlist\services_discovery.c,"static void playlist_sd_item_added(services_discovery_t *sd,
                                   input_item_t *parent, input_item_t *p_input,
                                   const char *psz_cat)
{
    assert(parent == NULL || psz_cat == NULL);

    vlc_sd_internal_t *sds = sd->owner.sys;
    playlist_t *playlist = (playlist_t *)sd->obj.parent;
    playlist_item_t *node;
    const char *longname = (sd->description != NULL) ? sd->description : ""?"";

    msg_Dbg(sd, ""adding: %s"", p_input->psz_name ? p_input->psz_name : ""(null)"");

    playlist_Lock(playlist);
    if (sds->node == NULL)
        sds->node = playlist_NodeCreate(playlist, longname, &playlist->root,
                                        PLAYLIST_END, PLAYLIST_RO_FLAG);

    if (parent != NULL)
        node = playlist_ItemGetByInput(playlist, parent);
    else
    if (psz_cat == NULL)
        node = sds->node;
    else
    {   /* Parent is NULL (root) and category is specified.
         * This is clearly a hack. TODO: re...",42.0,76.0,1.0,1.0,35.0,26,9,34,11,0,7,3,3,1,5,,0,4,8,4,4,void
3358,166680,playlist_sd_item_removed,1,playlist_sd_item_removed,"void playlist_sd_item_removed (services_discovery_t*,input_item_t*)",playlist\services_discovery.c,"static void playlist_sd_item_removed(services_discovery_t *sd,
                                     input_item_t *p_input)
{
    vlc_sd_internal_t *sds = sd->owner.sys;
    playlist_t *playlist = (playlist_t *)sd->obj.parent;
    playlist_item_t *node, *item;

    msg_Dbg(sd, ""removing: %s"", p_input->psz_name ? p_input->psz_name : ""(null)"");

    playlist_Lock(playlist);
    item = playlist_ItemGetByInput(playlist, p_input);
    if (unlikely(item == NULL))
    {
        msg_Err(sd, ""removing item not added""); /* SD plugin bug */
        playlist_Unlock(playlist);
        return;
    }

#ifndef NDEBUG
    /* Check that the item belonged to the SD */
    for (playlist_item_t *i = item->p_parent; i != sds->node; i = i->p_parent)
        assert(i != NULL);
#endif

    node = item->p_parent;
    /* if the item was added under a category and the category node
       becomes empty, delete that node as well */
    if (node != sds->node && node->i_children == 1)
        item = node;
    play...",79.0,111.0,1.0,8.0,33.0,25,9,29,8,0,7,4,4,2,5,,0,3,4,2,2,void
3359,166791,playlist_ServicesDiscoveryAdd,1,playlist_ServicesDiscoveryAdd,"int playlist_ServicesDiscoveryAdd (playlist_t*,char*)",playlist\services_discovery.c,"int playlist_ServicesDiscoveryAdd(playlist_t *playlist, const char *chain)
{
    vlc_sd_internal_t *sds = malloc(sizeof (*sds) + strlen(chain) + 1);
    if (unlikely(sds == NULL))
        return VLC_ENOMEM;

    sds->node = NULL;

    struct services_discovery_owner_t owner = {
        sds,
        playlist_sd_item_added,
        playlist_sd_item_removed,
    };

    /* Perform the addition */
    sds->sd = vlc_sd_Create(VLC_OBJECT(playlist), chain, &owner);
    if (unlikely(sds->sd == NULL))
    {
        free(sds);
        return VLC_ENOMEM;
    }

    strcpy(sds->name, chain);

    playlist_Lock(playlist);
    /* Backward compatibility with Qt UI: create the node even if the SD
     * has not discovered any item. */
    if (sds->node == NULL && sds->sd->description != NULL)
        sds->node = playlist_NodeCreate(playlist, sds->sd->description,
                                        &playlist->root, PLAYLIST_END,
                                        PLAYLIST_RO_FLAG);

    TA...",113.0,148.0,1.0,15.0,36.0,30,10,42,11,0,12,4,4,3,4,,0,10,4,2,2,int
3360,166914,playlist_ServicesDiscoveryInternalRemoveLocked,1,playlist_ServicesDiscoveryInternalRemoveLocked,"void playlist_ServicesDiscoveryInternalRemoveLocked (playlist_t*,vlc_sd_internal_t*)",playlist\services_discovery.c,"static void playlist_ServicesDiscoveryInternalRemoveLocked(playlist_t *playlist,
                                                           vlc_sd_internal_t *sds)
{
    assert(sds->sd != NULL);

    playlist_Unlock(playlist);

    vlc_sd_Destroy(sds->sd);
    /* Remove the sd playlist node if it exists */
    playlist_Lock(playlist);

    if (sds->node != NULL)
        playlist_NodeDeleteExplicit(playlist, sds->node,
            PLAYLIST_DELETE_FORCE | PLAYLIST_DELETE_STOP_IF_CURRENT );

    free(sds);
}",150.0,166.0,1.0,12.0,17.0,7,3,10,3,1,8,2,2,1,4,,0,4,4,2,2,void
3361,166955,playlist_ServicesDiscoveryRemove,1,playlist_ServicesDiscoveryRemove,"int playlist_ServicesDiscoveryRemove (playlist_t*,char*)",playlist\services_discovery.c,"int playlist_ServicesDiscoveryRemove(playlist_t *playlist, const char *name)
{
    playlist_private_t *priv = pl_priv(playlist);
    vlc_sd_internal_t *sds = NULL;

    playlist_Lock(playlist);
    for (int i = 0; i < priv->i_sds; i++)
    {
        vlc_sd_internal_t *entry = priv->pp_sds[i];

        if (!strcmp(name, entry->name))
        {
            TAB_ERASE(priv->i_sds, priv->pp_sds, i);
            sds = entry;
            break;
        }
    }

    if (sds == NULL)
    {
        msg_Warn(playlist, ""discovery %s is not loaded"", name);
        playlist_Unlock(playlist);
        return VLC_EGENERIC;
    }

    playlist_ServicesDiscoveryInternalRemoveLocked(playlist, sds);

    playlist_Unlock(playlist);

    return VLC_SUCCESS;
}",168.0,198.0,1.0,31.0,31.0,14,6,31,11,0,9,5,5,2,4,,0,5,4,2,2,int
3362,167039,playlist_IsServicesDiscoveryLoaded,1,playlist_IsServicesDiscoveryLoaded,"bool playlist_IsServicesDiscoveryLoaded (playlist_t*,char*)",playlist\services_discovery.c,"bool playlist_IsServicesDiscoveryLoaded( playlist_t * playlist,
                                         const char *psz_name )
{
    playlist_private_t *priv = pl_priv( playlist );
    bool found = false;
    playlist_Lock(playlist);

    for( int i = 0; i < priv->i_sds; i++ )
    {
        vlc_sd_internal_t *sds = priv->pp_sds[i];

        if (!strcmp(psz_name, sds->name))
        {
            found = true;
            break;
        }
    }
    playlist_Unlock(playlist);
    return found;
}",200.0,219.0,1.0,31.0,20.0,11,5,20,10,0,5,4,4,2,2,,0,3,4,2,2,bool
3363,167099,playlist_ServicesDiscoveryControl,1,playlist_ServicesDiscoveryControl,"int playlist_ServicesDiscoveryControl (playlist_t*,char*,int...)",playlist\services_discovery.c,"int playlist_ServicesDiscoveryControl( playlist_t *playlist, const char *psz_name, int i_control, ... )
{
    playlist_private_t *priv = pl_priv( playlist );
    int i_ret = VLC_EGENERIC;
    int i;

    playlist_Lock(playlist);
    for( i = 0; i < priv->i_sds; i++ )
    {
        vlc_sd_internal_t *sds = priv->pp_sds[i];
        if (!strcmp(psz_name, sds->name))
        {
            va_list args;
            va_start( args, i_control );
            i_ret = vlc_sd_control(sds->sd, i_control, args );
            va_end( args );
            break;
        }
    }

    assert( i != priv->i_sds );
    playlist_Unlock(playlist);

    return i_ret;
}",221.0,245.0,1.0,31.0,25.0,14,6,27,11,0,7,4,4,2,2,,0,5,6,3,3,int
3364,167245,meta_strcasecmp_title,1,meta_strcasecmp_title,"int meta_strcasecmp_title (playlist_item_t*,playlist_item_t*)",playlist\sort.c,"static inline int meta_strcasecmp_title( const playlist_item_t *first,
                              const playlist_item_t *second )
{
    int i_ret;
    char *psz_first = input_item_GetTitleFbName( first->p_input );
    char *psz_second = input_item_GetTitleFbName( second->p_input );

    if( psz_first && psz_second )
        i_ret = strcasecmp( psz_first, psz_second );
    else if( !psz_first && psz_second )
        i_ret = 1;
    else if( psz_first && !psz_second )
        i_ret = -1;
    else
        i_ret = 0;
    free( psz_first );
    free( psz_second );

    return i_ret;
}",43.0,62.0,1.0,1.0,20.0,6,3,12,5,1,2,2,2,0,2,,0,2,4,2,2,int
3365,167310,meta_sort,1,meta_sort,"int meta_sort (playlist_item_t*,playlist_item_t*,vlc_meta_type_t,bool)",playlist\sort.c,"static inline int meta_sort( const playlist_item_t *first,
                             const playlist_item_t *second,
                             vlc_meta_type_t meta, bool b_integer )
{
    int i_ret;
    char *psz_first = input_item_GetMeta( first->p_input, meta );
    char *psz_second = input_item_GetMeta( second->p_input, meta );

    /* Nodes go first */
    if( first->i_children == -1 && second->i_children >= 0 )
        i_ret = 1;
    else if( first->i_children >= 0 && second->i_children == -1 )
       i_ret = -1;
    /* Both are nodes, sort by name */
    else if( first->i_children >= 0 && second->i_children >= 0 )
        i_ret = meta_strcasecmp_title( first, second );
    /* Both are items */
    else if( !psz_first && !psz_second )
        i_ret = 0;
    else if( !psz_first && psz_second )
        i_ret = 1;
    else if( psz_first && !psz_second )
        i_ret = -1;
    else
    {
        if( b_integer )
            i_ret = atoi( psz_first ) - atoi( psz_second );
     ...",72.0,106.0,1.0,1.0,35.0,11,6,12,6,8,2,2,2,0,2,,0,2,8,4,4,int
3366,167452,sortfn_t,1,sortfn_t,"int sortfn_t (void*,void*)",playlist\sort.c,"typedef int (*sortfn_t)(const void *,const void *);",117.0,117.0,13.0,50.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
3367,167462,find_sorting_fn,1,find_sorting_fn,"sortfn_t find_sorting_fn (unsigned,unsigned)",playlist\sort.c,"static inline sortfn_t find_sorting_fn( unsigned i_mode, unsigned i_type )
{
    if( i_mode>=NUM_SORT_FNS || i_type>1 )
        return 0;
    return sorting_fns[i_mode][i_type];
}",119.0,124.0,1.0,1.0,6.0,5,4,6,4,1,1,2,2,0,0,,0,1,4,2,2,sortfn_t
3368,167485,playlist_ItemArraySort,1,playlist_ItemArraySort,"void playlist_ItemArraySort (unsigned,playlist_item_t**,sortfn_t)",playlist\sort.c,"static inline
void playlist_ItemArraySort( unsigned i_items, playlist_item_t **pp_items,
                             sortfn_t p_sortfn )
{
    if( p_sortfn )
    {
        qsort( pp_items, i_items, sizeof( pp_items[0] ), p_sortfn );
    }
    else /* Randomise */
    {
        unsigned i_position;
        unsigned i_new;
        playlist_item_t *p_temp;

        for( i_position = i_items - 1; i_position > 0; i_position-- )
        {
            i_new = ((unsigned)vlc_mrand48()) % (i_position+1);
            p_temp = pp_items[i_position];
            pp_items[i_position] = pp_items[i_new];
            pp_items[i_new] = p_temp;
        }
    }
}",133.0,155.0,1.0,1.0,23.0,2,2,5,3,1,0,2,2,0,0,,0,0,6,3,3,void
3369,167547,recursiveNodeSort,1,recursiveNodeSort,"int recursiveNodeSort (playlist_t*,playlist_item_t*,sortfn_t)",playlist\sort.c,"static int recursiveNodeSort( playlist_t *p_playlist, playlist_item_t *p_node,
                              sortfn_t p_sortfn )
{
    int i;
    playlist_ItemArraySort(p_node->i_children,p_node->pp_children,p_sortfn);
    for( i = 0 ; i< p_node->i_children; i++ )
    {
        if( p_node->pp_children[i]->i_children != -1 )
        {
            recursiveNodeSort( p_playlist, p_node->pp_children[i], p_sortfn );
        }
    }
    return VLC_SUCCESS;
}",166.0,179.0,1.0,1.0,14.0,12,6,13,5,1,1,3,4,0,1,,0,0,6,3,3,int
3370,167598,playlist_RecursiveNodeSort,1,playlist_RecursiveNodeSort,"int playlist_RecursiveNodeSort (playlist_t*,playlist_item_t*,int,int)",playlist\sort.c,"int playlist_RecursiveNodeSort( playlist_t *p_playlist, playlist_item_t *p_node,
                                int i_mode, int i_type )
{
    PL_ASSERT_LOCKED;

    /* Ask the playlist to reset as we are changing the order */
    pl_priv(p_playlist)->b_reset_currently_playing = true;

    /* Do the real job recursively */
    return recursiveNodeSort(p_playlist,p_node,find_sorting_fn(i_mode,i_type));
}",192.0,202.0,1.0,4.0,11.0,2,2,10,8,0,2,1,1,0,2,,0,1,8,4,4,int
3371,167625,proto_SORT_TRACK_NUMBER,1,proto_SORT_TRACK_NUMBER,"int proto_SORT_TRACK_NUMBER (playlist_item_t*,playlist_item_t*)",playlist\sort.c,"SORTFN( SORT_TRACK_NUMBER, first, second )
{
    return meta_sort( first, second, vlc_meta_TrackNumber, true );
}",218.0,221.0,1.0,42.0,4.0,0,0,4,4,1,1,1,1,0,1,,0,0,4,2,2,int
3372,167637,proto_SORT_DISC_NUMBER,1,proto_SORT_DISC_NUMBER,"int proto_SORT_DISC_NUMBER (playlist_item_t*,playlist_item_t*)",playlist\sort.c,"SORTFN( SORT_DISC_NUMBER, first, second )
{
    int i_ret = meta_sort( first, second, vlc_meta_DiscNumber, true );
    /* Items came from the same disc: compare the track numbers */
    if( i_ret == 0 )
        i_ret = proto_SORT_TRACK_NUMBER( first, second );

    return i_ret;
}",223.0,231.0,1.0,41.0,9.0,3,2,10,5,1,2,2,2,0,2,,0,2,4,2,2,int
3373,167663,proto_SORT_ALBUM,1,proto_SORT_ALBUM,"int proto_SORT_ALBUM (playlist_item_t*,playlist_item_t*)",playlist\sort.c,"SORTFN( SORT_ALBUM, first, second )
{
    int i_ret = meta_sort( first, second, vlc_meta_Album, false );
    /* Items came from the same album: compare the disc numbers */
    if( i_ret == 0 )
        i_ret = proto_SORT_DISC_NUMBER( first, second );

    return i_ret;
}",233.0,241.0,1.0,35.0,9.0,3,2,10,5,1,2,2,2,0,2,,0,2,4,2,2,int
3374,167689,proto_SORT_DATE,1,proto_SORT_DATE,"int proto_SORT_DATE (playlist_item_t*,playlist_item_t*)",playlist\sort.c,"SORTFN( SORT_DATE, first, second )
{
    int i_ret = meta_sort( first, second, vlc_meta_Date, true );
    /* Items came from the same date: compare the albums */
    if( i_ret == 0 )
        i_ret = proto_SORT_ALBUM( first, second );

    return i_ret;
}",243.0,251.0,1.0,34.0,9.0,3,2,10,5,1,2,2,2,0,2,,0,2,4,2,2,int
3375,167715,proto_SORT_ARTIST,1,proto_SORT_ARTIST,"int proto_SORT_ARTIST (playlist_item_t*,playlist_item_t*)",playlist\sort.c,"SORTFN( SORT_ARTIST, first, second )
{
    int i_ret = meta_sort( first, second, vlc_meta_Artist, false );
    /* Items came from the same artist: compare the dates */
    if( i_ret == 0 )
        i_ret = proto_SORT_DATE( first, second );

    return i_ret;
}",253.0,261.0,1.0,36.0,9.0,3,2,10,5,0,2,2,2,0,2,,0,2,4,2,2,int
3376,167741,proto_SORT_DESCRIPTION,1,proto_SORT_DESCRIPTION,"int proto_SORT_DESCRIPTION (playlist_item_t*,playlist_item_t*)",playlist\sort.c,"SORTFN( SORT_DESCRIPTION, first, second )
{
    return meta_sort( first, second, vlc_meta_Description, false );
}",263.0,266.0,1.0,41.0,4.0,0,0,4,4,0,1,1,1,0,1,,0,0,4,2,2,int
3377,167753,proto_SORT_DURATION,1,proto_SORT_DURATION,"int proto_SORT_DURATION (playlist_item_t*,playlist_item_t*)",playlist\sort.c,"SORTFN( SORT_DURATION, first, second )
{
    mtime_t time1 = input_item_GetDuration( first->p_input );
    mtime_t time2 = input_item_GetDuration( second->p_input );
    int i_ret = time1 > time2 ? 1 :
                    ( time1 == time2 ? 0 : -1 );
    return i_ret;
}",268.0,275.0,1.0,38.0,8.0,10,6,10,5,0,2,1,1,0,2,,0,2,4,2,2,int
3378,167790,proto_SORT_GENRE,1,proto_SORT_GENRE,"int proto_SORT_GENRE (playlist_item_t*,playlist_item_t*)",playlist\sort.c,"SORTFN( SORT_GENRE, first, second )
{
    return meta_sort( first, second, vlc_meta_Genre, false );
}",277.0,280.0,1.0,35.0,4.0,0,0,4,4,0,1,1,1,0,1,,0,0,4,2,2,int
3379,167802,proto_SORT_ID,1,proto_SORT_ID,"int proto_SORT_ID (playlist_item_t*,playlist_item_t*)",playlist\sort.c,"SORTFN( SORT_ID, first, second )
{
    return first->i_id - second->i_id;
}",282.0,285.0,1.0,32.0,4.0,3,2,2,2,0,0,1,1,0,0,,0,0,4,2,2,int
3380,167816,proto_SORT_RATING,1,proto_SORT_RATING,"int proto_SORT_RATING (playlist_item_t*,playlist_item_t*)",playlist\sort.c,"SORTFN( SORT_RATING, first, second )
{
    return meta_sort( first, second, vlc_meta_Rating, true );
}",287.0,290.0,1.0,36.0,4.0,0,0,4,4,0,1,1,1,0,1,,0,0,4,2,2,int
3381,167828,proto_SORT_TITLE,1,proto_SORT_TITLE,"int proto_SORT_TITLE (playlist_item_t*,playlist_item_t*)",playlist\sort.c,"SORTFN( SORT_TITLE, first, second )
{
    return meta_strcasecmp_title( first, second );
}",292.0,295.0,1.0,35.0,4.0,0,0,2,2,0,1,1,1,0,1,,0,0,4,2,2,int
3382,167838,proto_SORT_TITLE_NODES_FIRST,1,proto_SORT_TITLE_NODES_FIRST,"int proto_SORT_TITLE_NODES_FIRST (playlist_item_t*,playlist_item_t*)",playlist\sort.c,"SORTFN( SORT_TITLE_NODES_FIRST, first, second )
{
    /* If first is a node but not second */
    if( first->i_children == -1 && second->i_children >= 0 )
        return -1;
    /* If second is a node but not first */
    else if( first->i_children >= 0 && second->i_children == -1 )
        return 1;
    /* Both are nodes or both are not nodes */
    else
        return meta_strcasecmp_title( first, second );
}",297.0,308.0,1.0,47.0,12.0,7,5,2,2,0,0,2,2,0,0,,0,0,4,2,2,int
3383,167885,proto_SORT_TITLE_NUMERIC,1,proto_SORT_TITLE_NUMERIC,"int proto_SORT_TITLE_NUMERIC (playlist_item_t*,playlist_item_t*)",playlist\sort.c,"SORTFN( SORT_TITLE_NUMERIC, first, second )
{
    int i_ret;
    char *psz_first = input_item_GetTitleFbName( first->p_input );
    char *psz_second = input_item_GetTitleFbName( second->p_input );

    if( psz_first && psz_second )
        i_ret = atoi( psz_first ) - atoi( psz_second );
    else if( !psz_first && psz_second )
        i_ret = 1;
    else if( psz_first && !psz_second )
        i_ret = -1;
    else
        i_ret = 0;

    free( psz_first );
    free( psz_second );
    return i_ret;
}",310.0,328.0,1.0,43.0,19.0,7,4,12,5,0,2,2,2,0,2,,0,2,4,2,2,int
3384,167952,proto_SORT_URI,1,proto_SORT_URI,"int proto_SORT_URI (playlist_item_t*,playlist_item_t*)",playlist\sort.c,"SORTFN( SORT_URI, first, second )
{
    int i_ret;
    char *psz_first = input_item_GetURI( first->p_input );
    char *psz_second = input_item_GetURI( second->p_input );

    if( psz_first && psz_second )
        i_ret = strcasecmp( psz_first, psz_second );
    else if( !psz_first && psz_second )
        i_ret = 1;
    else if( psz_first && !psz_second )
        i_ret = -1;
    else
        i_ret = 0;

    free( psz_first );
    free( psz_second );
    return i_ret;
}",330.0,348.0,1.0,33.0,19.0,6,3,12,5,0,2,2,2,0,2,,0,2,4,2,2,int
3385,168082,playlist_Deactivate,1,playlist_Deactivate,void playlist_Deactivate (playlist_t*),playlist\thread.c,"void playlist_Deactivate( playlist_t *p_playlist )
{
    playlist_private_t *p_sys = pl_priv(p_playlist);

    PL_LOCK;
    /* WARNING: There is a latent bug. It is assumed that only one thread will
     * be waiting for playlist deactivation at a time. So far, that works
     * as playlist_Deactivate() is only ever called while closing an
     * interface and interfaces are shut down serially by intf_DestroyAll(). */
    if( p_sys->killed )
    {
        PL_UNLOCK;
        return;
    }

    msg_Dbg( p_playlist, ""deactivating the playlist"" );
    p_sys->killed = true;
    vlc_cond_signal( &p_sys->signal );
    PL_UNLOCK;

    vlc_join( p_sys->thread, NULL );
}",68.0,89.0,1.0,32.0,22.0,7,3,15,8,1,6,2,2,1,2,,0,4,2,1,1,void
3386,168438,PlayItem,1,PlayItem,"bool PlayItem (playlist_t*,playlist_item_t*)",playlist\thread.c,"static bool PlayItem( playlist_t *p_playlist, playlist_item_t *p_item )
{
    playlist_private_t *p_sys = pl_priv(p_playlist);
    input_item_t *p_input = p_item->p_input;
    vlc_renderer_item_t *p_renderer;

    PL_ASSERT_LOCKED;

    msg_Dbg( p_playlist, ""creating new input thread"" );

    p_item->i_nb_played++;
    set_current_status_item( p_playlist, p_item );
    p_renderer = p_sys->p_renderer;
    /* Retain the renderer now to avoid it to be released by
     * playlist_SetRenderer when we exit the locked scope. If the last reference
     * was to be released, we would use a dangling pointer */
    if( p_renderer )
        vlc_renderer_item_hold( p_renderer );
    assert( p_sys->p_input == NULL );
    PL_UNLOCK;

    libvlc_MetadataCancel( p_playlist->obj.libvlc, p_item );

    input_thread_t *p_input_thread = input_Create( p_playlist, p_input, NULL,
                                                   p_sys->p_input_resource,
                                                   p...",194.0,256.0,1.0,32.0,63.0,25,8,59,15,1,14,6,7,1,10,,0,6,4,2,2,bool
3387,168588,NextItem,1,NextItem,playlist_item_t NextItem (playlist_t*),playlist\thread.c,"static playlist_item_t *NextItem( playlist_t *p_playlist )
{
    playlist_private_t *p_sys = pl_priv(p_playlist);
    playlist_item_t *p_new = NULL;
    bool requested = p_sys->request.b_request;

    /* Clear the request */
    p_sys->request.b_request = false;

    /* Handle quickly a few special cases */
    /* No items to play */
    if( p_playlist->items.i_size == 0 )
    {
        msg_Info( p_playlist, ""playlist is empty"" );
        return NULL;
    }

    /* Start the real work */
    if( requested )
    {
        p_new = p_sys->request.p_item;

        if( p_new == NULL && p_sys->request.p_node == NULL )
            return NULL; /* Stop request! */

        int i_skip = p_sys->request.i_skip;
        PL_DEBUG( ""processing request item: %s, node: %s, skip: %i"",
                        PLI_NAME( p_sys->request.p_item ),
                        PLI_NAME( p_sys->request.p_node ), i_skip );

        if( p_sys->request.p_node &&
            p_sys->request.p_node != get_current_sta...",265.0,422.0,1.0,32.0,158.0,100,13,86,11,1,8,15,40,2,6,,0,5,2,1,1,playlist_item_t
3388,169160,LoopInput,1,LoopInput,bool LoopInput (playlist_t*),playlist\thread.c,"static bool LoopInput( playlist_t *p_playlist )
{
    playlist_private_t *p_sys = pl_priv(p_playlist);
    input_thread_t *p_input = p_sys->p_input;

    assert( p_input != NULL );

    /* Wait for input to end or be stopped */
    while( !p_sys->request.input_dead )
    {
        if( p_sys->request.b_request || p_sys->killed )
        {
            PL_DEBUG( ""incoming request - stopping current input"" );
            input_Stop( p_input );
        }
        vlc_cond_wait( &p_sys->signal, &p_sys->lock );
    }

    input_item_t *item = input_GetItem(p_input);
    assert(item);
    bool ok = !input_item_HasErrorWhenReading(item);

    /* This input is dead. Remove it ! */
    PL_DEBUG( ""dead input"" );
    p_sys->p_input = NULL;
    p_sys->request.input_dead = false;
    PL_UNLOCK;

    var_SetAddress( p_playlist, ""input-current"", NULL );

    /* WARNING: Input resource manipulation and callback deletion are
     * incompatible with the playlist lock. */
    if( !var_InheritBool( p_inp...",424.0,464.0,1.0,32.0,41.0,25,7,36,11,0,13,4,5,1,7,,0,8,2,1,1,bool
3389,169275,Next,1,Next,bool Next (playlist_t*),playlist\thread.c,"static bool Next( playlist_t *p_playlist )
{
    playlist_item_t *p_item = NextItem( p_playlist );
    if( p_item == NULL )
        return false;

    msg_Dbg( p_playlist, ""starting playback of new item"" );
    ResyncCurrentIndex( p_playlist, p_item );
    return PlayItem( p_playlist, p_item );
}",466.0,475.0,1.0,1.0,10.0,2,2,10,4,0,3,2,2,0,3,,0,1,2,1,1,bool
3390,169475,GetNextUncle,1,GetNextUncle,"playlist_item_t* GetNextUncle (playlist_t*,playlist_item_t*,playlist_item_t*)",playlist\tree.c,"playlist_item_t *GetNextUncle( playlist_t *p_playlist, playlist_item_t *p_item,
                               playlist_item_t *p_root )
{
    playlist_item_t *p_parent = p_item->p_parent;
    playlist_item_t *p_grandparent;
    bool b_found = false;

    (void)p_playlist;

    if( p_parent != NULL )
    {
        p_grandparent = p_parent->p_parent;
        while( p_grandparent )
        {
            int i;
            for( i = 0 ; i< p_grandparent->i_children ; i++ )
            {
                if( p_parent == p_grandparent->pp_children[i] )
                {
                    PL_DEBUG2( ""parent %s found as child %i of grandparent %s"",
                               p_parent->p_input->psz_name, i,
                               p_grandparent->p_input->psz_name );
                    b_found = true;
                    break;
                }
            }
            if( b_found && i + 1 < p_grandparent->i_children )
            {
                    return p_grandparent->pp_...",293.0,337.0,1.0,20.0,45.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,playlist_item_t
3391,169482,GetPrevUncle,1,GetPrevUncle,"playlist_item_t* GetPrevUncle (playlist_t*,playlist_item_t*,playlist_item_t*)",playlist\tree.c,"playlist_item_t *GetPrevUncle( playlist_t *p_playlist, playlist_item_t *p_item,
                               playlist_item_t *p_root )
{
    playlist_item_t *p_parent = p_item->p_parent;
    playlist_item_t *p_grandparent;
    bool b_found = false;

    (void)p_playlist;

    if( p_parent != NULL )
    {
        p_grandparent = p_parent->p_parent;
        while( 1 )
        {
            int i;
            for( i = p_grandparent->i_children -1 ; i >= 0; i-- )
            {
                if( p_parent == p_grandparent->pp_children[i] )
                {
                    b_found = true;
                    break;
                }
            }
            if( b_found && i - 1 > 0 )
            {
                return p_grandparent->pp_children[i-1];
            }
            /* Not found at root */
            if( p_grandparent == p_root )
            {
                return NULL;
            }
            else
            {
                p_parent = p_grandparent;
         ...",339.0,380.0,1.0,1.0,42.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,playlist_item_t
3392,169489,GetNextItem,1,GetNextItem,"playlist_item_t* GetNextItem (playlist_t*,playlist_item_t*,playlist_item_t*)",playlist\tree.c,"playlist_item_t *GetNextItem( playlist_t *p_playlist,
                              playlist_item_t *p_root,
                              playlist_item_t *p_item )
{
    /* If the item is NULL, return the firt child of root */
    if( p_item == NULL )
    {
        if( p_root->i_children > 0 )
            return p_root->pp_children[0];
        else
            return NULL;
    }

    /* Node with children, get the first one */
    if( p_item->i_children > 0 )
        return p_item->pp_children[0];

    playlist_item_t* p_parent = p_item->p_parent;
    for( int i = 0 ; i < p_parent->i_children ; i++ )
    {
        if( p_parent->pp_children[i] == p_item )
        {
            // Return the next children
            if( i + 1 < p_parent->i_children )
                return p_parent->pp_children[i+1];
            // We are the least one, so try to have uncles
            else
            {
                PL_DEBUG2( ""Current item is the last of the node,""
                           ""...",249.0,291.0,1.0,16.0,43.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,playlist_item_t
3393,169496,GetPrevItem,1,GetPrevItem,"playlist_item_t* GetPrevItem (playlist_t*,playlist_item_t*,playlist_item_t*)",playlist\tree.c,"playlist_item_t *GetPrevItem( playlist_t *p_playlist,
                              playlist_item_t *p_root,
                              playlist_item_t *p_item )
{
    playlist_item_t *p_parent;
    int i;

    /* Node with children, get the last one */
    if( p_item && p_item->i_children > 0 )
        return p_item->pp_children[p_item->i_children - 1];

    /* Last child of its parent ? */
    if( p_item != NULL )
        p_parent = p_item->p_parent;
    else
    {
        msg_Err( p_playlist, ""Get the last one"" );
        abort();
    };

    for( i = p_parent->i_children -1 ; i >= 0 ;  i-- )
    {
        if( p_parent->pp_children[i] == p_item )
        {
            if( i-1 < 0 )
            {
               /* Was already the first sibling. Look for uncles */
                PL_DEBUG2( ""current item is the first of its node,""
                           ""looking for uncle from %s"",
                           p_parent->p_input->psz_name );
                if( p_parent == p_ro...",384.0,428.0,1.0,16.0,45.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,playlist_item_t
3394,169503,playlist_NodeCreate,1,playlist_NodeCreate,"playlist_item_t playlist_NodeCreate (playlist_t*,char*,playlist_item_t*,int,int)",playlist\tree.c,"playlist_item_t * playlist_NodeCreate( playlist_t *p_playlist,
                                       const char *psz_name,
                                       playlist_item_t *p_parent, int i_pos,
                                       int i_flags )
{
    input_item_t *p_new_input;
    playlist_item_t *p_item;

    PL_ASSERT_LOCKED;
    if( !psz_name ) psz_name = _(""Undefined"");

    p_new_input = input_item_NewExt( NULL, psz_name, -1, ITEM_TYPE_NODE,
                                     ITEM_NET_UNKNOWN );
    if( !p_new_input )
        return NULL;
    p_item = playlist_ItemNewFromInput( p_playlist, p_new_input );
    input_item_Release( p_new_input );

    if( p_item == NULL )  return NULL;

    playlist_NodeInsert( p_parent, p_item, i_pos );
    playlist_SendAddNotify( p_playlist, p_item );

    p_item->i_flags |= i_flags;

    return p_item;
}",58.0,84.0,1.0,1.0,27.0,8,5,25,11,4,5,4,4,0,5,,0,2,10,5,5,playlist_item_t
3395,169566,playlist_NodeDelete,1,playlist_NodeDelete,"void playlist_NodeDelete (playlist_t*,playlist_item_t*)",playlist\tree.c,"void playlist_NodeDelete( playlist_t *p_playlist, playlist_item_t *p_root )
{
    playlist_NodeDeleteExplicit( p_playlist, p_root,
        PLAYLIST_DELETE_STOP_IF_CURRENT );
}",92.0,96.0,1.0,8.0,5.0,0,0,2,2,0,1,1,1,0,1,,0,0,4,2,2,void
3396,169837,playlist_ChildSearchName,1,playlist_ChildSearchName,"playlist_item_t playlist_ChildSearchName (playlist_item_t*,char*)",playlist\tree.c,"playlist_item_t *playlist_ChildSearchName( playlist_item_t *p_node,
                                           const char *psz_search )
{
    int i;

    if( p_node->i_children < 0 )
    {
         return NULL;
    }
    for( i = 0 ; i< p_node->i_children; i++ )
    {
        if( !strcmp( p_node->pp_children[i]->p_input->psz_name, psz_search ) )
        {
            return p_node->pp_children[i];
        }
    }
    return NULL;
}",177.0,194.0,1.0,1.0,18.0,12,5,11,4,0,0,4,5,0,0,,0,0,4,2,2,playlist_item_t
3397,170464,config_GetAppDir,1,config_GetAppDir,"char* config_GetAppDir (char*,char*)",win32\dirs.c,"static char *config_GetAppDir (void)
{
#if !VLC_WINSTORE_APP
    /* if portable directory exists, use it */
    TCHAR path[MAX_PATH];
    if (GetModuleFileName (NULL, path, MAX_PATH))
    {
        TCHAR *lastDir = _tcsrchr (path, '\\');
        if (lastDir)
        {
            _tcscpy (lastDir + 1, TEXT(""portable""));
            DWORD attrib = GetFileAttributes (path);
            if (attrib != INVALID_FILE_ATTRIBUTES &&
                    (attrib & FILE_ATTRIBUTE_DIRECTORY))
                return FromT (path);
        }
    }
#endif

    char *psz_dir;
    char *psz_parent = config_GetShellDir (CSIDL_APPDATA);

    if (psz_parent == NULL
     ||  asprintf (&psz_dir, ""%s\\vlc"", psz_parent) == -1)
        psz_dir = NULL;
    free (psz_parent);
    return psz_dir;
}",225.0,252.0,1.0,1.0,28.0,14,7,22,7,0,1,4,5,0,1,,0,1,2,1,1,char*
3398,170529,config_GetTypeDir,1,config_GetTypeDir,char* config_GetTypeDir (char*),posix\dirs.c,"static char *config_GetTypeDir (const char *xdg_name)
{
    const size_t namelen = strlen (xdg_name);
    const char *home = getenv (""HOME"");
    const char *dir = getenv (""XDG_CONFIG_HOME"");
    const char *file = ""user-dirs.dirs"";

    if (home == NULL)
        return NULL;
    if (dir == NULL)
    {
        dir = home;
        file = "".config/user-dirs.dirs"";
    }

    char *path;
    if (asprintf (&path, ""%s/%s"", dir, file) == -1)
        return NULL;

    FILE *stream = fopen (path, ""rte"");
    free (path);
    path = NULL;
    if (stream != NULL)
    {
        char *linebuf = NULL;
        size_t linelen = 0;

        while (getline (&linebuf, &linelen, stream) != -1)
        {
            char *ptr = linebuf;
            ptr += strspn (ptr, "" \t""); /* Skip whites */
            if (strncmp (ptr, ""XDG_"", 4))
                continue;
            ptr += 4; /* Skip XDG_ */
            if (strncmp (ptr, xdg_name, namelen))
                continue;
            ptr += namelen; /*...",107.0,209.0,1.0,1.0,103.0,59,10,82,12,0,0,28,49,0,0,,0,0,2,1,1,char*
3399,170912,vlc_strerror_l,1,vlc_strerror_l,"const char* vlc_strerror_l (int,char*)",posix\error.c,"static const char *vlc_strerror_l(int errnum, const char *lname)
{
    int saved_errno = errno;
    locale_t loc = newlocale(LC_MESSAGES_MASK, lname, (locale_t)0);

    if (unlikely(loc == (locale_t)0))
    {
        if (errno == ENOENT) /* fallback to POSIX locale */
            loc = newlocale(LC_MESSAGES_MASK, ""C"", (locale_t)0);

        if (unlikely(loc == (locale_t)0))
        {
            assert(errno != EINVAL && errno != ENOENT);
            errno = saved_errno;
            return ""Error message unavailable"";
        }
        errno = saved_errno;
    }

    const char *buf = strerror_l(errnum, loc);

    freelocale(loc);
    return buf;
}",32.0,55.0,1.0,1.0,24.0,16,5,24,9,0,0,4,6,0,0,,0,0,4,2,2,const char*
3400,171041,vlc_cloexec,1,vlc_cloexec,void vlc_cloexec (int),posix\filesystem.c,"static inline void vlc_cloexec(int fd)
{
    fcntl(fd, F_SETFD, FD_CLOEXEC | fcntl(fd, F_GETFD));
}",53.0,56.0,1.0,1.0,4.0,1,1,5,4,1,0,1,1,0,0,,0,0,2,1,1,void
3401,171119,vlc_mkstemp,1,vlc_mkstemp,int vlc_mkstemp (char*),posix\filesystem.c,"int vlc_mkstemp (char *template)
{
#if defined (HAVE_MKOSTEMP) && defined (O_CLOEXEC)
    return mkostemp(template, O_CLOEXEC);
#else
    int fd = mkstemp(template);
    if (fd != -1)
        vlc_cloexec(fd);
    return fd;
#endif
}",100.0,110.0,1.0,1.0,11.0,3,3,5,2,0,1,2,2,0,1,,0,0,2,1,1,int
3402,171625,vlc_gai_thread,1,vlc_gai_thread,void* vlc_gai_thread (void*),posix\getaddrinfo.c,"static void *vlc_gai_thread(void *data)
{
    struct vlc_gai_req *req = data;

    req->error = EAI_SYSTEM;
    req->error = getaddrinfo(req->name, req->service, req->hints,
                             &req->result);
    vlc_sem_post(&req->done);
    return NULL;
}",43.0,52.0,1.0,1.0,10.0,12,3,11,4,0,9,1,1,0,2,,0,8,2,1,1,void*
3403,172121,vlc_rand_init,1,vlc_rand_init,void vlc_rand_init (void),posix\rand.c,"static void vlc_rand_init (void)
{
    uint8_t key[BLOCK_SIZE];

    /* Get non-predictible value as key for HMAC */
    int fd = vlc_open (""/dev/urandom"", O_RDONLY);
    if (fd == -1)
        return; /* Uho! */

    for (size_t i = 0; i < sizeof (key);)
    {
         ssize_t val = read (fd, key + i, sizeof (key) - i);
         if (val > 0)
             i += val;
    }

    /* Precompute outer and inner keys for HMAC */
    for (size_t i = 0; i < sizeof (key); i++)
    {
        okey[i] = key[i] ^ 0x5c;
        ikey[i] = key[i] ^ 0x36;
    }

    vlc_close (fd);
}",50.0,74.0,1.0,16.0,25.0,23,11,27,7,0,4,5,6,0,2,,0,3,2,1,1,void
3404,172341,system_ConfigureDbus,1,system_ConfigureDbus,"void system_ConfigureDbus (libvlc_int_t*,int,char[]*)",posix\specific.c,"static void system_ConfigureDbus(libvlc_int_t *vlc, int argc,
                                 const char *const argv[])
{
/* FIXME: could be replaced by using Unix sockets */
#ifdef HAVE_DBUS
# define MPRIS_APPEND ""/org/mpris/MediaPlayer2/TrackList/Append""
# define MPRIS_BUS_NAME ""org.mpris.MediaPlayer2.vlc""
# define MPRIS_OBJECT_PATH ""/org/mpris/MediaPlayer2""
# define MPRIS_TRACKLIST_INTERFACE ""org.mpris.MediaPlayer2.TrackList""

    dbus_threads_init_default();

    if (var_InheritBool(vlc, ""dbus""))
        libvlc_InternalAddIntf(vlc, ""dbus,none"");

    if (!var_InheritBool(vlc, ""one-instance"")
     && !(var_InheritBool(vlc, ""one-instance-when-started-from-file"")
       && var_InheritBool(vlc, ""started-from-file"")))
         return;

    for (int i = 0; i < argc; i++)
        if (argv[i][0] == ':')
        {
            msg_Err(vlc, ""item option %s incompatible with single instance"",
                    argv[i]);
            return;
        }

    char *name = var_GetString(vlc, ""...",39.0,155.0,1.0,1.0,117.0,3,1,3,3,0,0,1,1,0,0,,0,0,6,3,3,void
3405,173509,vlc_timer_thread,1,vlc_timer_thread,void* vlc_timer_thread (void*),posix\timer.c,"static void *vlc_timer_thread (void *data)
{
    struct vlc_timer *timer = data;

    vlc_mutex_lock (&timer->lock);
    mutex_cleanup_push (&timer->lock);

    for (;;)
    {
        while (timer->value == 0)
        {
            assert(timer->interval == 0);
            vlc_cond_wait (&timer->reschedule, &timer->lock);
        }

        if (timer->interval != 0)
        {
            mtime_t now = mdate();

            if (now > timer->value)
            {   /* Update overrun counter */
                unsigned misses = (now - timer->value) / timer->interval;

                timer->value += misses * timer->interval;
                assert(timer->value <= now);
                atomic_fetch_add_explicit(&timer->overruns, misses,
                                          memory_order_relaxed);
            }
        }

        mtime_t value = timer->value;

        if (vlc_cond_timedwait(&timer->reschedule, &timer->lock, value) == 0)
            continue;

        if (likely(timer-...",53.0,107.0,10.0,1.0,55.0,54,11,41,7,0,34,9,16,8,9,,0,28,2,1,1,void*
3406,173921,RunThread,1,RunThread,void* RunThread (void*),stream_output\sap.c,"static void *RunThread (void *self)
{
    sap_address_t *addr = self;

    vlc_mutex_lock (&addr->lock);
    mutex_cleanup_push (&addr->lock);

    for (;;)
    {
        session_descriptor_t *p_session;
        mtime_t deadline;

        while (addr->first == NULL)
            vlc_cond_wait (&addr->wait, &addr->lock);

        assert (addr->session_count > 0);

        deadline = mdate ();
        for (p_session = addr->first; p_session; p_session = p_session->next)
        {
            send (addr->fd, p_session->data, p_session->length, 0);
            deadline += addr->interval * CLOCK_FREQ / addr->session_count;

            if (vlc_cond_timedwait (&addr->wait, &addr->lock, deadline) == 0)
                break; /* list may have changed! */
        }
    }

    vlc_cleanup_pop ();
    vlc_assert_unreachable ();
}",135.0,165.0,10.0,1.0,31.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void*
3407,173926,AddressCreate,1,AddressCreate,"sap_address_t AddressCreate (vlc_object_t*,char*)",stream_output\sap.c,"static sap_address_t *AddressCreate (vlc_object_t *obj, const char *group)
{
    int fd = net_ConnectUDP (obj, group, IPPORT_SAP, 255);
    if (fd == -1)
        return NULL;

    sap_address_t *addr = malloc (sizeof (*addr));
    if (addr == NULL)
    {
        net_Close (fd);
        return NULL;
    }

    strlcpy (addr->group, group, sizeof (addr->group));
    addr->fd = fd;
    addr->origlen = sizeof (addr->orig);
    getsockname (fd, (struct sockaddr *)&addr->orig, &addr->origlen);

    addr->interval = var_CreateGetInteger (obj, ""sap-interval"");
    vlc_mutex_init (&addr->lock);
    vlc_cond_init (&addr->wait);
    addr->session_count = 0;
    addr->first = NULL;

    if (vlc_clone (&addr->thread, RunThread, addr, VLC_THREAD_PRIORITY_LOW))
    {
        msg_Err (obj, ""unable to spawn SAP announce thread"");
        net_Close (fd);
        free (addr);
        return NULL;
    }
    return addr;
}",84.0,116.0,1.0,41.0,33.0,33,8,37,7,0,16,4,4,2,3,,0,14,4,2,2,sap_address_t
3408,174048,AddressDestroy,1,AddressDestroy,void AddressDestroy (sap_address_t*),stream_output\sap.c,"static void AddressDestroy (sap_address_t *addr)
{
    assert (addr->first == NULL);

    vlc_cancel (addr->thread);
    vlc_join (addr->thread, NULL);
    vlc_cond_destroy (&addr->wait);
    vlc_mutex_destroy (&addr->lock);
    net_Close (addr->fd);
    free (addr);
}",118.0,128.0,1.0,1.0,11.0,9,3,9,2,0,10,1,1,0,4,,0,6,2,1,1,void
3409,174748,AddressToSDP,1,AddressToSDP,"char* AddressToSDP (sockaddr*,socklen_t,char*)",stream_output\sdp.c,"static
char *AddressToSDP (const struct sockaddr *addr, socklen_t addrlen, char *buf)
{
    if (addrlen < offsetof (struct sockaddr, sa_family)
                 + sizeof (addr->sa_family))
        return NULL;

    strcpy (buf, ""IN IP* "");

    if (vlc_getnameinfo (addr, addrlen, buf + 7, MAXSDPADDRESS - 7, NULL,
                         NI_NUMERICHOST))
        return NULL;

    switch (addr->sa_family)
    {
        case AF_INET:
        {
            if (net_SockAddrIsMulticast (addr, addrlen))
                strcat (buf, ""/255""); // obsolete in RFC4566, dummy value
            buf[5] = '4';
            break;
        }

#ifdef AF_INET6
        case AF_INET6:
        {
            char *ptr = strchr (buf, '%');
            if (ptr != NULL)
                *ptr = '\0'; // remove scope ID
            buf[5] = '6';
            break;
        }
#endif

        default:
            return NULL;
    }

    return buf;
}",41.0,80.0,1.0,49.0,40.0,5,5,16,6,0,1,6,6,1,1,,0,1,6,3,3,char*
3410,174807,IsSDPString,1,IsSDPString,bool IsSDPString (char*),stream_output\sdp.c,"static bool IsSDPString (const char *str)
{
    if (strchr (str, '\r') != NULL)
        return false;
    if (strchr (str, '\n') != NULL)
        return false;
    if (!IsUTF8 (str))
        return false;
    return true;
}",83.0,92.0,1.0,1.0,10.0,3,2,9,4,0,0,4,4,0,0,,0,0,2,1,1,bool
3411,174839,vsdp_AddAttribute,1,vsdp_AddAttribute,"void vsdp_AddAttribute (vlc_memstream*,char*,char*,va_list)",stream_output\sdp.c,"static void vsdp_AddAttribute(struct vlc_memstream *restrict stream,
                              const char *name, const char *fmt, va_list ap)
{
    vlc_memstream_printf(stream, ""a=%s:"", name);
    vlc_memstream_vprintf(stream, fmt, ap);
    vlc_memstream_puts(stream, ""\r\n"");
}",94.0,100.0,1.0,1.0,7.0,0,0,6,4,0,2,1,1,0,2,,0,0,8,4,4,void
3412,175271,sout_stream_url_to_chain,1,sout_stream_url_to_chain,"char* sout_stream_url_to_chain (ANY,char*)",stream_output\stream_output.c,"static char *sout_stream_url_to_chain( bool b_sout_display,
                                       const char *psz_url )
{
    mrl_t       mrl;
    char        *psz_chain;

    mrl_Parse( &mrl, psz_url );

    /* Check if the URLs goes to #rtp - otherwise we'll use #standard */
    static const char rtplist[] = ""dccp\0sctp\0tcp\0udplite\0"";
    for (const char *a = rtplist; *a; a += strlen (a) + 1)
        if (strcmp (a, mrl.psz_access) == 0)
            goto rtp;

    if (strcmp (mrl.psz_access, ""rtp"") == 0)
    {
        char *port;
        /* For historical reasons, rtp:// means RTP over UDP */
        strcpy (mrl.psz_access, ""udp"");
rtp:
        if (mrl.psz_name[0] == '[')
        {
            port = strstr (mrl.psz_name, ""]:"");
            if (port != NULL)
                port++;
        }
        else
            port = strchr (mrl.psz_name, ':');
        if (port != NULL)
            *port++ = '\0'; /* erase ':' */

        if (asprintf (&psz_chain,
                      ""r...",905.0,963.0,1.0,1.0,59.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,char*
3413,175282,mrl_Parse,1,mrl_Parse,"int mrl_Parse (mrl_t*,char*)",stream_output\stream_output.c,"static int mrl_Parse( mrl_t *p_mrl, const char *psz_mrl )
{
    char * psz_dup = strdup( psz_mrl );
    char * psz_parser = psz_dup;
    const char * psz_access;
    const char * psz_way;
    char * psz_name;

    /* *** first parse psz_dest */
    while( *psz_parser && *psz_parser != ':' )
    {
        if( *psz_parser == '{' )
        {
            while( *psz_parser && *psz_parser != '}' )
            {
                psz_parser++;
            }
            if( *psz_parser )
            {
                psz_parser++;
            }
        }
        else
        {
            psz_parser++;
        }
    }
#if defined( _WIN32 ) || defined( __OS2__ )
    if( psz_parser - psz_dup == 1 )
    {
        /* msg_Warn( p_sout, ""drive letter %c: found in source string"",
                          *psz_dup ) ; */
        *psz_parser = '\0';
    }
#endif

    if( !*psz_parser )
    {
        psz_access = psz_way = """";
        psz_name = psz_dup;
    }
    else
    {
        *psz_parser++ = '...",602.0,715.0,1.0,1.0,114.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
3414,175288,mrl_Clean,1,mrl_Clean,void mrl_Clean (mrl_t*),stream_output\stream_output.c,"static void mrl_Clean( mrl_t *p_mrl )
{
    FREENULL( p_mrl->psz_access );
    FREENULL( p_mrl->psz_way );
    FREENULL( p_mrl->psz_name );
}",719.0,724.0,1.0,1.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
3415,175293,sout_NewInstance,1,sout_NewInstance,"sout_instance_t sout_NewInstance (vlc_object_t*,char*)",stream_output\stream_output.c,"sout_instance_t *sout_NewInstance( vlc_object_t *p_parent, const char *psz_dest )
{
    sout_instance_t *p_sout;
    char *psz_chain;

    assert( psz_dest != NULL );

    if( psz_dest[0] == '#' )
    {
        psz_chain = strdup( &psz_dest[1] );
    }
    else
    {
        psz_chain = sout_stream_url_to_chain(
            var_InheritBool(p_parent, ""sout-display""), psz_dest );
    }
    if(!psz_chain)
        return NULL;

    /* *** Allocate descriptor *** */
    p_sout = vlc_custom_create( p_parent, sizeof( *p_sout ), ""stream output"" );
    if( p_sout == NULL )
    {
        free( psz_chain );
        return NULL;
    }

    msg_Dbg( p_sout, ""using sout chain=`%s'"", psz_chain );

    /* *** init descriptor *** */
    p_sout->psz_sout    = strdup( psz_dest );
    p_sout->i_out_pace_nocontrol = 0;

    vlc_mutex_init( &p_sout->lock );
    p_sout->p_stream = NULL;

    var_Create( p_sout, ""sout-mux-caching"", VLC_VAR_INTEGER | VLC_VAR_DOINHERIT );

    p_sout->p_stream = sout_StreamC...",81.0,134.0,1.0,1.0,54.0,26,10,40,7,0,6,5,5,0,6,,0,2,4,2,2,sout_instance_t
3416,175419,sout_DeleteInstance,1,sout_DeleteInstance,void sout_DeleteInstance (sout_instance_t*),stream_output\stream_output.c,"void sout_DeleteInstance( sout_instance_t * p_sout )
{
    /* remove the stream out chain */
    sout_StreamChainDelete( p_sout->p_stream, NULL );

    /* *** free all string *** */
    FREENULL( p_sout->psz_sout );

    vlc_mutex_destroy( &p_sout->lock );

    /* *** free structure *** */
    vlc_object_release( p_sout );
}",139.0,151.0,1.0,1.0,13.0,4,2,5,2,0,3,1,1,0,3,,0,0,2,1,1,void
3417,175440,sout_InputNew,1,sout_InputNew,"sout_packetizer_input_t sout_InputNew (sout_instance_t*,es_format_t*)",stream_output\stream_output.c,"sout_packetizer_input_t *sout_InputNew( sout_instance_t *p_sout,
                                        const es_format_t *p_fmt )
{
    sout_packetizer_input_t *p_input;

    /* *** create a packetizer input *** */
    if( !p_fmt->i_codec || !(p_input = malloc(sizeof(sout_packetizer_input_t))) )
        return NULL;

    p_input->p_sout = p_sout;

    msg_Dbg( p_sout, ""adding a new sout input for `%4.4s` (sout_input: %p)"",
             (char*) &p_fmt->i_codec, (void *)p_input );

    /* *** add it to the stream chain */
    vlc_mutex_lock( &p_sout->lock );
    p_input->id = p_sout->p_stream->pf_add( p_sout->p_stream, p_fmt );
    vlc_mutex_unlock( &p_sout->lock );

    if( p_input->id == NULL )
    {
        msg_Warn( p_sout, ""new sout input failed (sout_input: %p)"",
                 (void *)p_input );
        free( p_input );
        p_input = NULL;
    }

    return( p_input );
}",156.0,184.0,1.0,1.0,29.0,25,8,23,5,0,5,3,3,1,2,,0,3,4,2,2,sout_packetizer_input_t
3418,175523,sout_InputDelete,1,sout_InputDelete,int sout_InputDelete (sout_packetizer_input_t*),stream_output\stream_output.c,"int sout_InputDelete( sout_packetizer_input_t *p_input )
{
    sout_instance_t     *p_sout = p_input->p_sout;

    msg_Dbg( p_sout, ""removing a sout input (sout_input: %p)"",
             (void *)p_input );

    vlc_mutex_lock( &p_sout->lock );
    p_sout->p_stream->pf_del( p_sout->p_stream, p_input->id );
    vlc_mutex_unlock( &p_sout->lock );

    free( p_input );

    return( VLC_SUCCESS);
}",189.0,203.0,1.0,1.0,15.0,11,4,11,3,0,4,1,1,0,2,,0,2,2,1,1,int
3419,175566,sout_InputIsEmpty,1,sout_InputIsEmpty,bool sout_InputIsEmpty (sout_packetizer_input_t*),stream_output\stream_output.c,"bool sout_InputIsEmpty( sout_packetizer_input_t *p_input )
{
    sout_instance_t *p_sout = p_input->p_sout;
    bool b;

    vlc_mutex_lock( &p_sout->lock );
    if( sout_StreamControl( p_sout->p_stream, SOUT_STREAM_EMPTY, &b ) != VLC_SUCCESS )
        b = true;
    vlc_mutex_unlock( &p_sout->lock );
    return b;
}",205.0,215.0,1.0,1.0,11.0,10,4,11,6,0,3,2,2,0,2,,0,1,2,1,1,bool
3420,175604,sout_InputFlush,1,sout_InputFlush,void sout_InputFlush (sout_packetizer_input_t*),stream_output\stream_output.c,"void sout_InputFlush( sout_packetizer_input_t *p_input )
{
    sout_instance_t     *p_sout = p_input->p_sout;

    vlc_mutex_lock( &p_sout->lock );
    sout_StreamFlush( p_sout->p_stream, p_input->id );
    vlc_mutex_unlock( &p_sout->lock );
}",217.0,224.0,1.0,1.0,8.0,8,3,6,2,0,4,1,1,0,2,,0,2,2,1,1,void
3421,175632,sout_InputSendBuffer,1,sout_InputSendBuffer,"int sout_InputSendBuffer (sout_packetizer_input_t*,block_t*)",stream_output\stream_output.c,"int sout_InputSendBuffer( sout_packetizer_input_t *p_input,
                          block_t *p_buffer )
{
    sout_instance_t     *p_sout = p_input->p_sout;
    int                 i_ret;

    vlc_mutex_lock( &p_sout->lock );
    i_ret = p_sout->p_stream->pf_send( p_sout->p_stream,
                                       p_input->id, p_buffer );
    vlc_mutex_unlock( &p_sout->lock );

    return i_ret;
}",229.0,241.0,1.0,1.0,13.0,11,3,10,4,0,4,1,1,0,2,,0,2,4,2,2,int
3422,176724,sout_StreamDelete,1,sout_StreamDelete,void sout_StreamDelete (sout_stream_t*),stream_output\stream_output.c,"static void sout_StreamDelete( sout_stream_t *p_stream )
{
    sout_instance_t *p_sout = (sout_instance_t *)(p_stream->obj.parent);

    msg_Dbg( p_stream, ""destroying chain... (name=%s)"", p_stream->psz_name );

    p_sout->i_out_pace_nocontrol -= p_stream->pace_nocontrol;

    if( p_stream->p_module != NULL )
        module_unneed( p_stream, p_stream->p_module );

    FREENULL( p_stream->psz_name );

    config_ChainDestroy( p_stream->p_cfg );

    msg_Dbg( p_stream, ""destroying chain done"" );
    vlc_object_release( p_stream );
}",736.0,753.0,1.0,1.0,18.0,13,6,14,3,1,3,2,2,0,3,,0,0,2,1,1,void
3423,176805,sout_StreamNew,1,sout_StreamNew,"sout_stream_t sout_StreamNew (sout_instance_t*,char*,config_chain_t*,sout_stream_t*)",stream_output\stream_output.c,"static sout_stream_t *sout_StreamNew( sout_instance_t *p_sout, char *psz_name,
                               config_chain_t *p_cfg, sout_stream_t *p_next)
{
    sout_stream_t *p_stream;

    assert(psz_name);

    p_stream = vlc_custom_create( p_sout, sizeof( *p_stream ), ""stream out"" );
    if( !p_stream )
        return NULL;

    p_stream->p_sout   = p_sout;
    p_stream->psz_name = psz_name;
    p_stream->p_cfg    = p_cfg;
    p_stream->p_next   = p_next;
    p_stream->pf_flush = NULL;
    p_stream->pf_control = NULL;
    p_stream->pace_nocontrol = false;
    p_stream->p_sys = NULL;

    msg_Dbg( p_sout, ""stream=`%s'"", p_stream->psz_name );

    p_stream->p_module =
        module_need( p_stream, ""sout stream"", p_stream->psz_name, true );

    if( !p_stream->p_module )
    {
        /* those must be freed by the caller if creation failed */
        p_stream->psz_name = NULL;
        p_stream->p_cfg = NULL;

        sout_StreamDelete( p_stream );
        return NULL;
    }

    ...",779.0,816.0,1.0,1.0,38.0,33,6,38,8,0,3,3,3,0,3,,0,2,8,4,4,sout_stream_t
3424,177352,us_strtod,1,us_strtod,"double us_strtod (char*,char**)",text\charset.c,"double us_strtod( const char *str, char **end )
{
    locale_t loc = newlocale (LC_NUMERIC_MASK, ""C"", NULL);
    locale_t oldloc = uselocale (loc);
    double res = strtod (str, end);

    if (loc != (locale_t)0)
    {
        uselocale (oldloc);
        freelocale (loc);
    }
    return res;
}",50.0,62.0,1.0,1.0,13.0,5,3,12,7,1,0,2,2,0,0,,0,0,4,2,2,double
3425,177389,us_strtof,1,us_strtof,"float us_strtof (char*,char**)",text\charset.c,"float us_strtof( const char *str, char **end )
{
    locale_t loc = newlocale (LC_NUMERIC_MASK, ""C"", NULL);
    locale_t oldloc = uselocale (loc);
    float res = strtof (str, end);

    if (loc != (locale_t)0)
    {
        uselocale (oldloc);
        freelocale (loc);
    }
    return res;
}",69.0,81.0,1.0,1.0,13.0,5,3,12,7,0,0,2,2,0,0,,0,0,4,2,2,float
3426,177426,us_atof,1,us_atof,double us_atof (char*),text\charset.c,"double us_atof( const char *str )
{
    return us_strtod( str, NULL );
}",88.0,91.0,1.0,1.0,4.0,0,0,2,2,2,1,1,1,0,1,,0,0,2,1,1,double
3427,177435,us_vasprintf,1,us_vasprintf,"int us_vasprintf (char**,char*,va_list)",text\charset.c,"int us_vasprintf( char **ret, const char *format, va_list ap )
{
    locale_t loc = newlocale( LC_NUMERIC_MASK, ""C"", NULL );
    locale_t oldloc = uselocale( loc );

    int i_rc = vasprintf( ret, format, ap );

    if ( loc != (locale_t)0 )
    {
        uselocale( oldloc );
        freelocale( loc );
    }

    return i_rc;
}",98.0,112.0,1.0,1.0,15.0,5,3,13,8,2,0,2,2,0,0,,0,0,6,3,3,int
3428,177474,us_asprintf,1,us_asprintf,"int us_asprintf (char**,char*...)",text\charset.c,"int us_asprintf( char **ret, const char *format, ... )
{
    va_list ap;
    int i_rc;

    va_start( ap, format );
    i_rc = us_vasprintf( ret, format, ap );
    va_end( ap );

    return i_rc;
}",119.0,129.0,1.0,1.0,11.0,1,1,8,4,0,1,1,1,0,1,,0,1,4,2,2,int
3429,177520,vlc_fopen,1,vlc_fopen,"FILE vlc_fopen (char*,char*)",text\filesystem.c,"FILE *vlc_fopen (const char *filename, const char *mode)
{
    int rwflags = 0, oflags = 0;

    for (const char *ptr = mode; *ptr; ptr++)
    {
        switch (*ptr)
        {
            case 'r':
                rwflags = O_RDONLY;
                break;

            case 'a':
                rwflags = O_WRONLY;
                oflags |= O_CREAT | O_APPEND;
                break;

            case 'w':
                rwflags = O_WRONLY;
                oflags |= O_CREAT | O_TRUNC;
                break;

            case 'x':
                oflags |= O_EXCL;
                break;

            case '+':
                rwflags = O_RDWR;
                break;

#ifdef O_BINARY
            case 'b':
                oflags = (oflags & ~O_TEXT) | O_BINARY;
                break;

            case 't':
                oflags = (oflags & ~O_BINARY) | O_TEXT;
                break;
#endif
        }
    }

    int fd = vlc_open (filename, rwflags | oflags, 0666);
    if (fd == -1)
    ...",48.0,99.0,1.0,1.0,52.0,17,5,35,15,7,2,10,6,0,2,,0,1,4,2,2,FILE
3430,177621,dummy_select,1,dummy_select,int dummy_select (char*),text\filesystem.c,"static int dummy_select( const char *str )
{
    (void)str;
    return 1;
}",102.0,106.0,1.0,1.0,5.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,int
3431,177631,vlc_loaddir,1,vlc_loaddir,"int vlc_loaddir (DIR*,char***,int,int)",text\filesystem.c,"int vlc_loaddir( DIR *dir, char ***namelist,
                  int (*select)( const char * ),
                  int (*compar)( const char **, const char ** ) )
{
    assert (dir);

    if (select == NULL)
        select = dummy_select;

    char **tab = NULL;
    unsigned num = 0;

    rewinddir (dir);

    for (unsigned size = 0;;)
    {
        errno = 0;
        const char *entry = vlc_readdir (dir);
        if (entry == NULL)
        {
            if (errno)
                goto error;
            break;
        }

        if (!select (entry))
            continue;

        if (num >= size)
        {
            size = size ? (2 * size) : 16;
            char **newtab = realloc (tab, sizeof (*tab) * (size));

            if (unlikely(newtab == NULL))
                goto error;
            tab = newtab;
        }

        tab[num] = strdup(entry);
        if (likely(tab[num] != NULL))
            num++;
    }

    if (compar != NULL && num > 0)
        qsort (tab, num, sizeof (*...",112.0,166.0,1.0,1.0,55.0,35,16,50,12,1,1,15,19,0,1,,0,1,8,4,4,int
3432,177784,vlc_scandir,1,vlc_scandir,"int vlc_scandir (char*,char***,int,int)",text\filesystem.c,"int vlc_scandir( const char *dirname, char ***namelist,
                  int (*select)( const char * ),
                  int (*compar)( const char **, const char ** ) )
{
    DIR *dir = vlc_opendir (dirname);
    int val = -1;

    if (dir != NULL)
    {
        val = vlc_loaddir (dir, namelist, select, compar);
        closedir (dir);
    }
    return val;
}",179.0,192.0,1.0,1.0,14.0,5,3,12,7,0,2,2,2,0,2,,0,2,8,4,4,int
3433,178857,GetLang_1,1,GetLang_1,iso639_lang_t GetLang_1 (char*),text\iso_lang.c,"const iso639_lang_t * GetLang_1( const char * psz_code )
{
    const iso639_lang_t *p_lang;

    for( p_lang = p_languages; p_lang->psz_eng_name; p_lang++ )
        if( !strncasecmp( p_lang->psz_iso639_1, psz_code, 2 ) )
            return p_lang;

    return &unknown_language;
}",47.0,56.0,1.0,1.0,10.0,3,3,4,3,0,1,2,2,0,0,,0,1,2,1,1,iso639_lang_t
3434,178887,GetLang_2T,1,GetLang_2T,iso639_lang_t GetLang_2T (char*),text\iso_lang.c,"const iso639_lang_t * GetLang_2T( const char * psz_code )
{
    const iso639_lang_t *p_lang;

    for( p_lang = p_languages; p_lang->psz_eng_name; p_lang++ )
        if( !strncasecmp( p_lang->psz_iso639_2T, psz_code, 3 ) )
            return p_lang;

    return &unknown_language;
}",58.0,67.0,1.0,1.0,10.0,3,3,4,3,0,1,2,2,0,0,,0,1,2,1,1,iso639_lang_t
3435,178917,GetLang_2B,1,GetLang_2B,iso639_lang_t GetLang_2B (char*),text\iso_lang.c,"const iso639_lang_t * GetLang_2B( const char * psz_code )
{
    const iso639_lang_t *p_lang;

    for( p_lang = p_languages; p_lang->psz_eng_name; p_lang++ )
        if( !strncasecmp( p_lang->psz_iso639_2B, psz_code, 3 ) )
            return p_lang;

    return &unknown_language;
}",69.0,78.0,1.0,1.0,10.0,3,3,4,3,0,1,2,2,0,0,,0,1,2,1,1,iso639_lang_t
3436,178960,vlc_memstream_open,1,vlc_memstream_open,int vlc_memstream_open (vlc_memstream*),text\memstream.c,"int vlc_memstream_open(struct vlc_memstream *ms)
{
    ms->error = 0;
    ms->ptr = calloc(1, 1);
    if (unlikely(ms->ptr == NULL))
        ms->error = EOF;
    ms->length = 0;
    return ms->error;
}",105.0,113.0,1.0,1.0,9.0,11,3,8,3,6,0,2,2,0,0,,0,0,2,1,1,int
3437,178999,vlc_memstream_flush,1,vlc_memstream_flush,int vlc_memstream_flush (vlc_memstream*),text\memstream.c,"int vlc_memstream_flush(struct vlc_memstream *ms)
{
    return ms->error;
}",115.0,118.0,1.0,1.0,4.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,int
3438,179008,vlc_memstream_close,1,vlc_memstream_close,int vlc_memstream_close (vlc_memstream*),text\memstream.c,"int vlc_memstream_close(struct vlc_memstream *ms)
{
    if (ms->error)
        free(ms->ptr);
    return ms->error;
}",120.0,125.0,1.0,1.0,6.0,3,1,3,1,8,0,2,2,0,0,,0,0,2,1,1,int
3439,179026,vlc_memstream_write,1,vlc_memstream_write,"size_t vlc_memstream_write (vlc_memstream*,void*,size_t)",text\memstream.c,"size_t vlc_memstream_write(struct vlc_memstream *ms, const void *ptr,
                           size_t len)
{
    char *base = realloc(ms->ptr, ms->length + len + 1u);
    if (unlikely(base == NULL))
        goto error;

    memcpy(base + ms->length, ptr, len);
    ms->ptr = base;
    ms->length += len;
    base[ms->length] = '\0';
    return len;

error:
    ms->error = EOF;
    return 0;
}",127.0,143.0,1.0,1.0,17.0,17,6,19,6,5,0,3,2,0,0,,0,0,6,3,3,size_t
3440,179089,vlc_memstream_putc,1,vlc_memstream_putc,"int vlc_memstream_putc (vlc_memstream*,int)",text\memstream.c,"int vlc_memstream_putc(struct vlc_memstream *ms, int c)
{
    return (vlc_memstream_write(ms, &(unsigned char){ c }, 1u) == 1) ? c : EOF;
}",145.0,148.0,1.0,1.0,4.0,5,5,4,3,5,1,1,1,0,1,,0,0,4,2,2,int
3441,179109,vlc_memstream_puts,1,,"int (vlc_memstream*,char*)",text\memstream.c,"int (vlc_memstream_puts)(struct vlc_memstream *ms, const char *str)
{
    size_t len = strlen(str);
    return (vlc_memstream_write(ms, str, len) == len) ? 0 : EOF;
}",150.0,154.0,1.0,1.0,5.0,3,3,7,4,0,1,1,1,0,1,,0,0,4,2,2,int
3442,179130,vlc_memstream_vprintf,1,vlc_memstream_vprintf,"int vlc_memstream_vprintf (vlc_memstream*,char*,va_list)",text\memstream.c,"int vlc_memstream_vprintf(struct vlc_memstream *ms, const char *fmt,
                          va_list args)
{
    va_list ap;
    char *ptr;
    int len;

    va_copy(ap, args);
    len = vsnprintf(NULL, 0, fmt, ap);
    va_end(ap);

    if (len < 0)
        goto error;

    ptr = realloc(ms->ptr, ms->length + len + 1);
    if (ptr == NULL)
        goto error;

    vsnprintf(ptr + ms->length, len + 1, fmt, args);
    ms->ptr = ptr;
    ms->length += len;
    return len;

error:
    ms->error = EOF;
    return EOF;
}",156.0,182.0,1.0,1.0,27.0,17,6,27,8,2,0,5,3,0,0,,0,0,6,3,3,int
3443,179208,vlc_memstream_printf,1,vlc_memstream_printf,"int vlc_memstream_printf (vlc_memstream*,char*...)",text\memstream.c,"int vlc_memstream_printf(struct vlc_memstream *ms, const char *fmt, ...)
{
    va_list ap;
    int ret;

    va_start(ap, fmt);
    ret = vlc_memstream_vprintf(ms, fmt, ap);
    va_end(ap);
    return ret;
}",185.0,194.0,1.0,1.0,10.0,1,1,8,4,12,1,1,1,0,1,,0,1,4,2,2,int
3444,179653,cmp_entity,1,cmp_entity,"int cmp_entity (void*,void*)",text\strings.c,"static int cmp_entity (const void *key, const void *elem)
{
    const struct xml_entity_s *ent = elem;
    const char *name = key;

    return strncmp (name, ent->psz_entity, strlen (ent->psz_entity));
}",190.0,196.0,1.0,1.0,7.0,4,2,7,4,0,2,1,1,0,0,,0,2,4,2,2,int
3445,179677,vlc_xml_decode,1,vlc_xml_decode,void vlc_xml_decode (char*),text\strings.c,"void vlc_xml_decode( char *psz_value )
{
    char *p_pos = psz_value;

    while ( *psz_value )
    {
        if( *psz_value == '&' )
        {
            if( psz_value[1] == '#' )
            {   /* &#DDD; or &#xHHHH; Unicode code point */
                char *psz_end;
                unsigned long cp;

                if( psz_value[2] == 'x' ) /* The x must be lower-case. */
                    cp = strtoul( psz_value + 3, &psz_end, 16 );
                else
                    cp = strtoul( psz_value + 2, &psz_end, 10 );

                if( *psz_end == ';' )
                {
                    psz_value = psz_end + 1;
                    if( cp == 0 )
                        (void)0; /* skip nulls */
                    else
                    if( cp <= 0x7F )
                    {
                        *p_pos =            cp;
                    }
                    else
                    /* Unicode code point outside ASCII.
                     * &#xxx; representati...",198.0,288.0,1.0,1.0,91.0,20,8,15,4,0,0,7,20,0,0,,0,0,2,1,1,void
3446,179947,vlc_xml_encode,1,vlc_xml_encode,char* vlc_xml_encode (char*),text\strings.c,"char *vlc_xml_encode (const char *str)
{
    struct vlc_memstream stream;
    size_t n;
    uint32_t cp;

    assert(str != NULL);
    vlc_memstream_open(&stream);

    while ((n = vlc_towc (str, &cp)) != 0)
    {
        if (unlikely(n == (size_t)-1))
        {
            if (vlc_memstream_close(&stream) == 0)
                free(stream.ptr);
            errno = EILSEQ;
            return NULL;
        }

        switch (cp)
        {
            case '\""':
                vlc_memstream_puts(&stream, ""&quot;"");
                break;
            case '&':
                vlc_memstream_puts(&stream, ""&amp;"");
                break;
            case '\'':
                vlc_memstream_puts(&stream, ""&#39;"");
                break;
            case '<':
                vlc_memstream_puts(&stream, ""&lt;"");
                break;
            case '>':
                vlc_memstream_puts(&stream, ""&gt;"");
                break;
            default:
                if (cp < 32) /* C0 cod...",290.0,348.0,1.0,1.0,59.0,24,10,30,8,1,5,16,16,3,5,,0,3,2,1,1,char*
3447,180080,vlc_b64_encode_binary,1,vlc_b64_encode_binary,"char* vlc_b64_encode_binary (uint8_t*,size_t)",text\strings.c,"char *vlc_b64_encode_binary( const uint8_t *src, size_t i_src )
{
    static const char b64[] =
           ""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"";

    char *ret = malloc( ( i_src + 4 ) * 4 / 3 );
    char *dst = ret;

    if( dst == NULL )
        return NULL;

    while( i_src > 0 )
    {
        /* pops (up to) 3 bytes of input, push 4 bytes */
        uint32_t v;

        /* 1/3 -> 1/4 */
        v = ((unsigned)*src++) << 24;
        *dst++ = b64[v >> 26];
        v = v << 6;

        /* 2/3 -> 2/4 */
        if( i_src >= 2 )
            v |= *src++ << 22;
        *dst++ = b64[v >> 26];
        v = v << 6;

        /* 3/3 -> 3/4 */
        if( i_src >= 3 )
            v |= *src++ << 20; // 3/3
        *dst++ = ( i_src >= 2 ) ? b64[v >> 26] : '='; // 3/4
        v = v << 6;

        /* -> 4/4 */
        *dst++ = ( i_src >= 3 ) ? b64[v >> 26] : '='; // 4/4

        if( i_src <= 3 )
            break;
        i_src -= 3;
    }

    *dst = '\0';

    retu...",351.0,395.0,1.0,1.0,45.0,55,16,41,7,1,0,7,9,0,0,,0,0,4,2,2,char*
3448,180227,vlc_b64_encode,1,vlc_b64_encode,char* vlc_b64_encode (char*),text\strings.c,"char *vlc_b64_encode( const char *src )
{
    if( src )
        return vlc_b64_encode_binary( (const uint8_t*)src, strlen(src) );
    else
        return vlc_b64_encode_binary( (const uint8_t*)"""", 0 );
}",397.0,403.0,1.0,1.0,7.0,1,1,3,1,0,1,2,2,0,1,,0,0,2,1,1,char*
3449,180250,vlc_b64_decode_binary_to_buffer,1,vlc_b64_decode_binary_to_buffer,"size_t vlc_b64_decode_binary_to_buffer (uint8_t*,size_t,char*)",text\strings.c,"size_t vlc_b64_decode_binary_to_buffer( uint8_t *p_dst, size_t i_dst, const char *p_src )
{
    static const int b64[256] = {
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* 00-0F */
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* 10-1F */
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,62,-1,-1,-1,63,  /* 20-2F */
        52,53,54,55,56,57,58,59,60,61,-1,-1,-1,-1,-1,-1,  /* 30-3F */
        -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,  /* 40-4F */
        15,16,17,18,19,20,21,22,23,24,25,-1,-1,-1,-1,-1,  /* 50-5F */
        -1,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,  /* 60-6F */
        41,42,43,44,45,46,47,48,49,50,51,-1,-1,-1,-1,-1,  /* 70-7F */
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* 80-8F */
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* 90-9F */
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* A0-AF */
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* B0-BF */
        -1,-1,-1,-1,-1,-1,-1,-1...",406.0,459.0,1.0,1.0,54.0,238,17,33,9,4,0,8,6,0,0,,0,0,6,3,3,size_t
3450,180829,vlc_b64_decode_binary,1,vlc_b64_decode_binary,"size_t vlc_b64_decode_binary (uint8_t**,char*)",text\strings.c,"size_t vlc_b64_decode_binary( uint8_t **pp_dst, const char *psz_src )
{
    const int i_src = strlen( psz_src );
    uint8_t   *p_dst;

    *pp_dst = p_dst = malloc( i_src );
    if( !p_dst )
        return 0;
    return  vlc_b64_decode_binary_to_buffer( p_dst, i_src, psz_src );
}",460.0,469.0,1.0,1.0,10.0,5,3,9,4,0,1,2,2,0,1,,0,0,4,2,2,size_t
3451,180859,vlc_b64_decode,1,vlc_b64_decode,char* vlc_b64_decode (char*),text\strings.c,"char *vlc_b64_decode( const char *psz_src )
{
    const int i_src = strlen( psz_src );
    char *p_dst = malloc( i_src + 1 );
    size_t i_dst;
    if( !p_dst )
        return NULL;

    i_dst = vlc_b64_decode_binary_to_buffer( (uint8_t*)p_dst, i_src, psz_src );
    p_dst[i_dst] = '\0';

    return p_dst;
}",470.0,482.0,1.0,1.0,13.0,8,5,13,5,1,1,2,2,0,1,,0,1,2,1,1,char*
3452,180898,vlc_strftime,1,vlc_strftime,char* vlc_strftime (char*),text\strings.c,"char *vlc_strftime( const char *tformat )
{
    time_t curtime;
    struct tm loctime;

    if (strcmp (tformat, """") == 0)
        return strdup (""""); /* corner case w.r.t. strftime() return value */

    /* Get the current time.  */
    time( &curtime );

    /* Convert it to local time representation.  */
    localtime_r( &curtime, &loctime );
    for (size_t buflen = strlen (tformat) + 32;; buflen += 32)
    {
        char *str = malloc (buflen);
        if (str == NULL)
            return NULL;

        size_t len = strftime (str, buflen, tformat, &loctime);
        if (len > 0)
        {
            char *ret = realloc (str, len + 1);
            return ret ? ret : str; /* <- this cannot fail */
        }
        free (str);
    }
    vlc_assert_unreachable ();
}",484.0,512.0,1.0,1.0,29.0,15,7,25,8,0,0,5,7,0,0,,0,0,2,1,1,char*
3453,180978,write_duration,1,write_duration,"void write_duration (vlc_memstream*,int64_t)",text\strings.c,"static void write_duration(struct vlc_memstream *stream, int64_t duration)
{
    lldiv_t d;
    long long sec;

    duration /= CLOCK_FREQ;
    d = lldiv(duration, 60);
    sec = d.rem;
    d = lldiv(d.quot, 60);
    vlc_memstream_printf(stream, ""%02lld:%02lld:%02lld"", d.quot, d.rem, sec);
}",514.0,524.0,1.0,1.0,11.0,8,3,12,5,3,1,1,1,0,1,,0,0,4,2,2,void
3454,181016,write_meta,1,write_meta,"int write_meta (vlc_memstream*,input_item_t*,vlc_meta_type_t)",text\strings.c,"static int write_meta(struct vlc_memstream *stream, input_item_t *item,
                      vlc_meta_type_t type)
{
    if (item == NULL)
        return EOF;

    char *value = input_item_GetMeta(item, type);
    if (value == NULL)
        return EOF;

    vlc_memstream_puts(stream, value);
    free(value);
    return 0;
}",526.0,539.0,1.0,1.0,14.0,3,2,12,6,14,1,3,3,0,1,,0,1,6,3,3,int
3455,181050,vlc_strfinput,1,vlc_strfinput,"char* vlc_strfinput (input_thread_t*,char*)",text\strings.c,"char *vlc_strfinput(input_thread_t *input, const char *s)
{
    struct vlc_memstream stream[1];

    input_item_t *item = (input != NULL) ? input_GetItem(input) : NULL;

    char c;
    bool b_is_format = false;
    bool b_empty_if_na = false;

    assert(s != NULL);

    vlc_memstream_open(stream);

    while ((c = *s) != '\0')
    {
        s++;

        if (!b_is_format)
        {
            if (c == '$')
            {
                b_is_format = true;
                b_empty_if_na = false;
                continue;
            }

            vlc_memstream_putc(stream, c);
            continue;
        }

        b_is_format = false;

        switch (c)
        {
            case 'a':
                write_meta(stream, item, vlc_meta_Artist);
                break;
            case 'b':
                write_meta(stream, item, vlc_meta_Album);
                break;
            case 'c':
                write_meta(stream, item, vlc_meta_Copyright);
                break;
     ...",541.0,829.0,1.0,1.0,289.0,73,15,189,32,0,39,68,83,1,39,,0,9,4,2,2,char*
3456,181734,vlc_filenamecmp,1,vlc_filenamecmp,"int vlc_filenamecmp (char*,char*)",text\strings.c,"int vlc_filenamecmp(const char *a, const char *b)
{
    size_t i;
    char ca, cb;

    /* Attempt to guess if the sorting algorithm should be alphabetic
     * (i.e. collation) or numeric:
     * - If the first mismatching characters are not both digits,
     *   then collation is the only option.
     * - If one of the first mismatching characters is 0 and the other is also
     *   a digit, the comparands are probably left-padded numerical values.
     *   It does not matter which algorithm is used: the zero will be smaller
     *   than non-zero either way.
     * - Otherwise, the comparands are numerical values, and might not be
     *   aligned (i.e. not same order of magnitude). If so, collation would
     *   fail. So numerical comparison is performed. */
    for (i = 0; (ca = a[i]) == (cb = b[i]); i++)
        if (ca == '\0')
            return 0; /* strings are exactly identical */

    if ((unsigned)(ca - '0') > 9 || (unsigned)(cb - '0') > 9)
        return strcoll(a, b);...",831.0,864.0,1.0,15.0,34.0,22,11,25,8,1,0,4,4,0,0,,0,0,4,2,2,int
3457,181829,filename_sanitize,1,filename_sanitize,void filename_sanitize (char*),text\strings.c,"void filename_sanitize( char *str )
{
    unsigned char c;

    /* Special file names, not allowed */
    if( !strcmp( str, ""."" ) || !strcmp( str, "".."" ) )
    {
        while( *str )
            *(str++) = '_';
        return;
    }

    /* On platforms not using UTF-8, VLC cannot access non-Unicode paths.
     * Also, some file systems require Unicode file names.
     * NOTE: This may inserts '?' thus is done replacing '?' with '_'. */
    EnsureUTF8( str );

    /* Avoid leading spaces to please Windows. */
    while( (c = *str) != '\0' )
    {
        if( c != ' ' )
            break;
        *(str++) = '_';
    }

    char *start = str;

    while( (c = *str) != '\0' )
    {
        /* Non-printable characters are not a good idea */
        if( c < 32 )
            *str = '_';
        /* This is the list of characters not allowed by Microsoft.
         * We also black-list them on Unix as they may be confusing, and are
         * not supported by some file system types (notably...",877.0,924.0,1.0,1.0,48.0,25,9,19,3,5,0,11,13,0,0,,0,0,2,1,1,void
3458,181958,utf8_vfprintf,1,utf8_vfprintf,"int utf8_vfprintf (FILE*,char*,va_list)",text\unicode.c,"int utf8_vfprintf( FILE *stream, const char *fmt, va_list ap )
{
#ifndef _WIN32
    return vfprintf (stream, fmt, ap);
#else
    char *str;
    int res = vasprintf (&str, fmt, ap);
    if (unlikely(res == -1))
        return -1;

#if !VLC_WINSTORE_APP
    /* Writing to the console is a lot of fun on Microsoft Windows.
     * If you use the standard I/O functions, you must use the OEM code page,
     * which is different from the usual ANSI code page. Or maybe not, if the
     * user called ""chcp"". Anyway, we prefer Unicode. */
    int fd = _fileno (stream);
    if (likely(fd != -1) && _isatty (fd))
    {
        wchar_t *wide = ToWide (str);
        if (likely(wide != NULL))
        {
            HANDLE h = (HANDLE)((uintptr_t)_get_osfhandle (fd));
            DWORD out;
            /* XXX: It is not clear whether WriteConsole() wants the number of
             * Unicode characters or the size of the wchar_t array. */
            BOOL ok = WriteConsoleW (h, wide, wcslen (wide), &out...",52.0,96.0,1.0,1.0,45.0,0,0,3,3,1,0,1,1,0,0,,0,0,6,3,3,int
3459,181970,utf8_fprintf,1,utf8_fprintf,"int utf8_fprintf (FILE*,char*...)",text\unicode.c,"int utf8_fprintf( FILE *stream, const char *fmt, ... )
{
    va_list ap;
    int res;

    va_start( ap, fmt );
    res = utf8_vfprintf( stream, fmt, ap );
    va_end( ap );
    return res;
}",102.0,111.0,1.0,1.0,10.0,1,1,8,4,0,1,1,1,0,1,,0,1,4,2,2,int
3460,181991,vlc_towc,1,vlc_towc,"size_t vlc_towc (char*,uint32_t*)",text\unicode.c,"size_t vlc_towc (const char *str, uint32_t *restrict pwc)
{
    uint8_t *ptr = (uint8_t *)str, c;
    uint32_t cp;

    assert (str != NULL);

    c = *ptr;
    if (unlikely(c > 0xF4))
        return -1;

    int charlen = clz8 (c ^ 0xFF);
    switch (charlen)
    {
        case 0: // 7-bit ASCII character -> short cut
            *pwc = c;
            return c != '\0';

        case 1: // continuation byte -> error
            return -1;

        case 2:
            if (unlikely(c < 0xC2)) // ASCII overlong
                return -1;
            cp = (c & 0x1F) << 6;
            break;

        case 3:
            cp = (c & 0x0F) << 12;
            break;

        case 4:
            cp = (c & 0x07) << 18;
            break;

        default:
            vlc_assert_unreachable ();
    }

    /* Unrolled continuation bytes decoding */
    switch (charlen)
    {
        case 4:
            c = *++ptr;
            if (unlikely((c & 0xC0) != 0x80)) // not a continuation byte
          ...",113.0,185.0,1.0,1.0,73.0,60,15,44,7,6,0,15,18,0,0,,0,0,4,2,2,size_t
3461,182208,vlc_strcasestr,1,vlc_strcasestr,"char* vlc_strcasestr (char*,char*)",text\unicode.c,"char *vlc_strcasestr (const char *haystack, const char *needle)
{
    ssize_t s;

    do
    {
        const char *h = haystack, *n = needle;

        for (;;)
        {
            uint32_t cph, cpn;

            s = vlc_towc (n, &cpn);
            if (s == 0)
                return (char *)haystack;
            if (unlikely(s < 0))
                return NULL;
            n += s;

            s = vlc_towc (h, &cph);
            if (s <= 0 || towlower (cph) != towlower (cpn))
                break;
            h += s;
        }

        s = vlc_towc (haystack, &(uint32_t) { 0 });
        haystack += s;
    }
    while (s > 0);

    return NULL;
}",198.0,229.0,1.0,1.0,32.0,20,11,27,8,3,3,7,13,0,3,,0,3,4,2,2,char*
3462,182294,FromCharset,1,FromCharset,"char* FromCharset (char*,void*,size_t)",text\unicode.c,"char *FromCharset(const char *charset, const void *data, size_t data_size)
{
    vlc_iconv_t handle = vlc_iconv_open (""UTF-8"", charset);
    if (handle == (vlc_iconv_t)(-1))
        return NULL;

    char *out = NULL;
    for(unsigned mul = 4; mul < 8; mul++ )
    {
        size_t in_size = data_size;
        const char *in = data;
        size_t out_max = mul * data_size;
        char *tmp = out = malloc (1 + out_max);
        if (!out)
            break;

        if (vlc_iconv (handle, &in, &in_size, &tmp, &out_max) != (size_t)(-1)) {
            *tmp = '\0';
            break;
        }
        free(out);
        out = NULL;

        if (errno != E2BIG)
            break;
    }
    vlc_iconv_close(handle);
    return out;
}",237.0,265.0,1.0,1.0,29.0,24,10,32,13,0,3,9,9,1,3,,0,2,6,3,3,char*
3463,182396,ToCharset,1,ToCharset,"void* ToCharset (char*,char*,size_t*)",text\unicode.c,"void *ToCharset(const char *charset, const char *in, size_t *outsize)
{
    vlc_iconv_t hd = vlc_iconv_open (charset, ""UTF-8"");
    if (hd == (vlc_iconv_t)(-1))
        return NULL;

    const size_t inlen = strlen (in);
    void *res;

    for (unsigned mul = 4; mul < 16; mul++)
    {
        size_t outlen = mul * (inlen + 1);
        res = malloc (outlen);
        if (unlikely(res == NULL))
            break;

        const char *inp = in;
        char *outp = res;
        size_t inb = inlen;
        size_t outb = outlen - mul;

        if (vlc_iconv (hd, &inp, &inb, &outp, &outb) != (size_t)(-1))
        {
            *outsize = outlen - mul - outb;
            outb += mul;
            inb = 1; /* append nul terminator if possible */
            if (vlc_iconv (hd, &inp, &inb, &outp, &outb) != (size_t)(-1))
                break;
            if (errno == EILSEQ) /* cannot translate nul terminator!? */
                break;
        }

        free (res);
        res = NULL;
      ...",279.0,318.0,1.0,1.0,40.0,37,11,50,16,0,4,12,15,2,4,,0,3,6,3,3,void*
3464,182580,vlc_uri_decode_duplicate,1,vlc_uri_decode_duplicate,char* vlc_uri_decode_duplicate (char*),text\url.c,"char *vlc_uri_decode_duplicate (const char *str)
{
    char *buf = strdup (str);
    if (vlc_uri_decode (buf) == NULL)
    {
        free (buf);
        buf = NULL;
    }
    return buf;
}",43.0,52.0,1.0,1.0,10.0,3,2,8,3,2,1,2,2,1,1,,0,1,2,1,1,char*
3465,182603,vlc_uri_decode,1,vlc_uri_decode,char* vlc_uri_decode (char*),text\url.c,"char *vlc_uri_decode (char *str)
{
    char *in = str, *out = str;
    if (in == NULL)
        return NULL;

    char c;
    while ((c = *(in++)) != '\0')
    {
        if (c == '%')
        {
            char hex[3];

            if (!(hex[0] = *(in++)) || !(hex[1] = *(in++)))
                return NULL;
            hex[2] = '\0';
            *(out++) = strtoul (hex, NULL, 0x10);
        }
        else
            *(out++) = c;
    }
    *out = '\0';
    return str;
}",54.0,77.0,1.0,1.0,24.0,26,8,21,6,5,0,5,8,0,0,,0,0,2,1,1,char*
3466,182686,isurisafe,1,isurisafe,bool isurisafe (int),text\url.c,"static bool isurisafe (int c)
{
    /* These are the _unreserved_ URI characters (RFC3986 2.3) */
    return ((unsigned char)(c - 'a') < 26)
        || ((unsigned char)(c - 'A') < 26)
        || ((unsigned char)(c - '0') < 10)
        || (strchr (""-._~"", c) != NULL);
}",79.0,86.0,1.0,1.0,8.0,13,5,5,2,2,0,1,1,0,0,,0,0,2,1,1,bool
3467,182721,isurisubdelim,1,isurisubdelim,bool isurisubdelim (int),text\url.c,"static bool isurisubdelim(int c)
{
    return strchr(""!$&'()*+,;="", c) != NULL;
}",88.0,91.0,1.0,1.0,4.0,1,1,2,2,1,0,1,1,0,0,,0,0,2,1,1,bool
3468,182732,isurihex,1,isurihex,bool isurihex (int),text\url.c,"static bool isurihex(int c)
{   /* Same as isxdigit() but does not depend on locale and unsignedness */
    return ((unsigned char)(c - '0') < 10)
        || ((unsigned char)(c - 'A') < 6)
        || ((unsigned char)(c - 'a') < 6);
}",93.0,98.0,1.0,1.0,6.0,11,4,3,1,2,0,1,1,0,0,,0,0,2,1,1,bool
3469,182765,encode_URI_bytes,1,encode_URI_bytes,"char* encode_URI_bytes (char*,size_t*)",text\url.c,"static char *encode_URI_bytes (const char *str, size_t *restrict lenp)
{
    char *buf = malloc (3 * *lenp + 1);
    if (unlikely(buf == NULL))
        return NULL;

    char *out = buf;
    for (size_t i = 0; i < *lenp; i++)
    {
        unsigned char c = str[i];

        if (isurisafe (c))
            *(out++) = c;
        /* This is URI encoding, not HTTP forms:
         * Space is encoded as '%20', not '+'. */
        else
        {
            *(out++) = '%';
            *(out++) = urihex[c >> 4];
            *(out++) = urihex[c & 0xf];
        }
    }

    *lenp = out - buf;
    out = realloc (buf, *lenp + 1);
    return likely(out != NULL) ? out : buf;
}",102.0,128.0,1.0,1.0,27.0,22,11,26,7,2,1,4,5,1,1,,0,1,4,2,2,char*
3470,182868,vlc_uri_encode,1,vlc_uri_encode,char* vlc_uri_encode (char*),text\url.c,"char *vlc_uri_encode (const char *str)
{
    size_t len = strlen (str);
    char *ret = encode_URI_bytes (str, &len);
    if (likely(ret != NULL))
        ret[len] = '\0';
    return ret;
}",130.0,137.0,1.0,1.0,8.0,6,4,10,4,2,1,2,2,0,1,,0,1,2,1,1,char*
3471,182898,vlc_path2uri,1,vlc_path2uri,"char* vlc_path2uri (char*,char*)",text\url.c,"char *vlc_path2uri (const char *path, const char *scheme)
{
    if (path == NULL)
    {
        errno = EINVAL;
        return NULL;
    }
    if (scheme == NULL && !strcmp (path, ""-""))
        return strdup (""fd://0""); // standard input
    /* Note: VLC cannot handle URI schemes without double slash after the
     * scheme name (such as mailto: or news:). */

    char *buf;

#ifdef __OS2__
    char p[strlen (path) + 1];

    for (buf = p; *path; buf++, path++)
        *buf = (*path == '/') ? DIR_SEP_CHAR : *path;
    *buf = '\0';

    path = p;
#endif

#if defined (_WIN32) || defined (__OS2__)
    /* Drive letter */
    if (isalpha ((unsigned char)path[0]) && (path[1] == ':'))
    {
        if (asprintf (&buf, ""%s:///%c:"", scheme ? scheme : ""file"",
                      path[0]) == -1)
            buf = NULL;
        path += 2;
# warning Drive letter-relative path not implemented!
        if (path[0] != DIR_SEP_CHAR)
        {
            errno = ENOTSUP;
            return NULL;
 ...",139.0,239.0,1.0,1.0,101.0,31,13,56,14,9,2,10,14,1,2,,0,2,4,2,2,char*
3472,183065,vlc_uri2path,1,vlc_uri2path,char* vlc_uri2path (char*),text\url.c,"char *vlc_uri2path (const char *url)
{
    char *ret = NULL;
    char *end;

    char *path = strstr (url, ""://"");
    if (path == NULL)
        return NULL; /* unsupported scheme or invalid syntax */

    end = memchr (url, '/', path - url);
    size_t schemelen = ((end != NULL) ? end : path) - url;
    path += 3; /* skip ""://"" */

    /* Remove request parameters and/or HTML anchor if present */
    end = path + strcspn (path, ""?#"");
    path = strndup (path, end - path);
    if (unlikely(path == NULL))
        return NULL; /* boom! */

    /* Decode path */
    vlc_uri_decode (path);

    if (schemelen == 4 && !strncasecmp (url, ""file"", 4))
    {
#if !defined (_WIN32) && !defined (__OS2__)
        /* Leading slash => local path */
        if (*path == '/')
            return path;
        /* Local path disguised as a remote one */
        if (!strncasecmp (path, ""localhost/"", 10))
            return memmove (path, path + 9, strlen (path + 9) + 1);
#else
        /* cannot start wi...",241.0,325.0,1.0,1.0,85.0,24,10,39,6,2,1,6,8,0,1,,0,0,2,1,1,char*
3473,183241,vlc_idna_to_ascii,1,vlc_idna_to_ascii,char* vlc_idna_to_ascii (char*),text\url.c,"static char *vlc_idna_to_ascii (const char *idn)
{
#if defined (HAVE_IDN)
    char *adn;

    switch (idna_to_ascii_8z(idn, &adn, IDNA_ALLOW_UNASSIGNED))
    {
        case IDNA_SUCCESS:
            return adn;
        case IDNA_MALLOC_ERROR:
            errno = ENOMEM;
            return NULL;
        case IDNA_DLOPEN_ERROR:
            errno = ENOSYS;
            return NULL;
        default:
            errno = EINVAL;
            return NULL;
    }

#elif defined (_WIN32)
    char *ret = NULL;

    if (idn[0] == '\0')
        return strdup("""");

    wchar_t *wide = ToWide (idn);
    if (wide == NULL)
        return NULL;

    int len = IdnToAscii (IDN_ALLOW_UNASSIGNED, wide, -1, NULL, 0);
    if (len == 0)
    {
        errno = EINVAL;
        goto error;
    }

    wchar_t *buf = vlc_alloc (len, sizeof (*buf));
    if (unlikely(buf == NULL))
        goto error;
    if (!IdnToAscii (IDN_ALLOW_UNASSIGNED, wide, -1, buf, len))
    {
        free (buf);
        errno = EINVAL;
    ...",911.0,975.0,1.0,1.0,65.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,char*
3474,183246,vlc_iri2uri,1,vlc_iri2uri,char* vlc_iri2uri (char*),text\url.c,"static char *vlc_iri2uri(const char *iri)
{
    size_t a = 0, u = 0;

    for (size_t i = 0; iri[i] != '\0'; i++)
    {
        unsigned char c = iri[i];

        if (c < 128)
            a++;
        else
            u++;
    }

    if (unlikely((a + u) > (SIZE_MAX / 4)))
    {
        errno = ENOMEM;
        return NULL;
    }

    char *uri = malloc(a + 3 * u + 1), *p;
    if (unlikely(uri == NULL))
        return NULL;

    for (p = uri; *iri != '\0'; iri++)
    {
        unsigned char c = *iri;

        if (c < 128)
            *(p++) = c;
        else
        {
            *(p++) = '%';
            *(p++) = urihex[c >> 4];
            *(p++) = urihex[c & 0xf];
        }
    }

    *p = '\0';
    return uri;
}",330.0,370.0,1.0,1.0,41.0,29,11,32,11,1,0,7,9,0,0,,0,0,2,1,1,char*
3475,183383,vlc_uri_component_validate,1,vlc_uri_component_validate,"bool vlc_uri_component_validate (char*,char*)",text\url.c,"static bool vlc_uri_component_validate(const char *str, const char *extras)
{
    assert(str != NULL);

    for (size_t i = 0; str[i] != '\0'; i++)
    {
        int c = str[i];

        if (isurisafe(c) || isurisubdelim(c))
            continue;
        if (strchr(extras, c) != NULL)
            continue;
        if (c == '%' && isurihex(str[i + 1]) && isurihex(str[i + 2]))
        {
            i += 2;
            continue;
        }
        return false;
    }
    return true;
}",372.0,392.0,1.0,1.0,21.0,16,8,21,7,4,4,8,8,4,4,,0,4,4,2,2,bool
3476,183456,vlc_uri_host_validate,1,vlc_uri_host_validate,bool vlc_uri_host_validate (char*),text\url.c,"static bool vlc_uri_host_validate(const char *str)
{
    return vlc_uri_component_validate(str, "":"");
}",394.0,397.0,1.0,1.0,4.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,bool
3477,183465,vlc_uri_path_validate,1,vlc_uri_path_validate,bool vlc_uri_path_validate (char*),text\url.c,"static bool vlc_uri_path_validate(const char *str)
{
    return vlc_uri_component_validate(str, ""/@:[]"");
}",399.0,402.0,1.0,1.0,4.0,0,0,1,1,1,1,1,1,0,1,,0,0,2,1,1,bool
3478,183474,vlc_UrlParseInner,1,vlc_UrlParseInner,"int vlc_UrlParseInner (vlc_url_t*,char*)",text\url.c,"static int vlc_UrlParseInner(vlc_url_t *restrict url, const char *str)
{
    url->psz_protocol = NULL;
    url->psz_username = NULL;
    url->psz_password = NULL;
    url->psz_host = NULL;
    url->i_port = 0;
    url->psz_path = NULL;
    url->psz_option = NULL;
    url->psz_buffer = NULL;
    url->psz_pathbuffer = NULL;

    if (str == NULL)
    {
        errno = EINVAL;
        return -1;
    }

    char *buf = vlc_iri2uri(str);
    if (unlikely(buf == NULL))
        return -1;
    url->psz_buffer = buf;

    char *cur = buf, *next;
    int ret = 0;

    /* URI scheme */
    next = buf;
    while ((*next >= 'A' && *next <= 'Z') || (*next >= 'a' && *next <= 'z')
        || (*next >= '0' && *next <= '9') || memchr (""+-."", *next, 3) != NULL)
        next++;

    if (*next == ':')
    {
        *(next++) = '\0';
        url->psz_protocol = cur;
        cur = next;
    }

    /* Fragment */
    next = strchr(cur, '#');
    if (next != NULL)
    {
#if 0  /* TODO */
       *(next++) = '...",404.0,553.0,1.0,1.0,150.0,133,15,117,12,2,3,17,29,0,3,,0,1,4,2,2,int
3479,183918,vlc_UrlParse,1,vlc_UrlParse,"int vlc_UrlParse (vlc_url_t*,char*)",text\url.c,"int vlc_UrlParse(vlc_url_t *url, const char *str)
{
    int ret = vlc_UrlParseInner(url, str);

    if (url->psz_path != NULL && !vlc_uri_path_validate(url->psz_path))
    {
        url->psz_path = NULL;
        errno = EINVAL;
        ret = -1;
    }
    return ret;
}",555.0,566.0,1.0,1.0,12.0,11,6,12,6,4,2,2,2,1,2,,0,2,4,2,2,int
3480,183957,vlc_uri_fixup_inner,1,vlc_uri_fixup_inner,"char* vlc_uri_fixup_inner (char*,char*)",text\url.c,"static char *vlc_uri_fixup_inner(const char *str, const char *extras)
{
    assert(str && extras);

    bool encode_percent = false;
    for (size_t i = 0; str[i] != '\0'; i++)
        if (str[i] == '%' && !(isurihex(str[i+1]) && isurihex(str[i+2])))
        {
            encode_percent = true;
            break;
        }

    struct vlc_memstream stream;

    vlc_memstream_open(&stream);

    for (size_t i = 0; str[i] != '\0'; i++)
    {
        unsigned char c = str[i];

        if (isurisafe(c) || isurisubdelim(c) || (strchr(extras, c) != NULL)
         || (c == '%' && !encode_percent))
            vlc_memstream_putc(&stream, c);
        else
            vlc_memstream_printf(&stream, ""%%%02hhX"", c);
    }

    if (vlc_memstream_close(&stream))
        return NULL;
    return stream.ptr;
}",832.0,862.0,1.0,1.0,31.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,char*
3481,183963,vlc_UrlParseFixup,1,vlc_UrlParseFixup,"int vlc_UrlParseFixup (vlc_url_t*,char*)",text\url.c,"int vlc_UrlParseFixup(vlc_url_t *url, const char *str)
{
    int ret = vlc_UrlParseInner(url, str);

    static const char pathextras[] = ""/@:"";

    if (url->psz_path != NULL
     && !vlc_uri_component_validate(url->psz_path, pathextras))
    {
        url->psz_pathbuffer = vlc_uri_fixup_inner(url->psz_path, pathextras);
        if (url->psz_pathbuffer == NULL)
        {
            url->psz_path = NULL;
            errno = ENOMEM;
            ret = -1;
        }
        else
        {
            url->psz_path = url->psz_pathbuffer;
            assert(vlc_uri_path_validate(url->psz_path));
        }
    }
    return ret;
}",570.0,593.0,1.0,1.0,24.0,17,7,19,7,0,3,3,4,1,3,,0,3,4,2,2,int
3482,184037,vlc_UrlClean,1,vlc_UrlClean,void vlc_UrlClean (vlc_url_t*),text\url.c,"void vlc_UrlClean (vlc_url_t *restrict url)
{
    free (url->psz_host);
    free (url->psz_buffer);
    free (url->psz_pathbuffer);
}",595.0,600.0,1.0,1.0,6.0,3,1,3,1,8,0,1,1,0,0,,0,0,2,1,1,void
3483,184054,vlc_uri_merge_paths,1,vlc_uri_merge_paths,"char* vlc_uri_merge_paths (char*,char*)",text\url.c,"static char *vlc_uri_merge_paths(const char *base, const char *ref)
{
    char *str;
    int len;

    if (base == NULL)
        len = asprintf(&str, ""/%s"", ref);
    else
    {
        const char *end = strrchr(base, '/');

        if (end != NULL)
            end++;
        else
            end = base;

        len = asprintf(&str, ""%.*s%s"", (int)(end - base), base, ref);
    }

    if (unlikely(len == -1))
        str = NULL;
    return str;
}",607.0,629.0,1.0,1.0,23.0,6,4,9,5,1,0,3,3,0,0,,0,0,4,2,2,char*
3484,184119,vlc_uri_remove_dot_segments,1,vlc_uri_remove_dot_segments,char* vlc_uri_remove_dot_segments (char*),text\url.c,"static char *vlc_uri_remove_dot_segments(char *str)
{
    char *input = str, *output = str;

    while (input[0] != '\0')
    {
        assert(output <= input);

        if (strncmp(input, ""../"", 3) == 0)
        {
            input += 3;
            continue;
        }
        if (strncmp(input, ""./"", 2) == 0)
        {
            input += 2;
            continue;
        }
        if (strncmp(input, ""/./"", 3) == 0)
        {
            input += 2;
            continue;
        }
        if (strcmp(input, ""/."") == 0)
        {
            input[1] = '\0';
            continue;
        }
        if (strncmp(input, ""/../"", 4) == 0)
        {
            input += 3;
            output = memrchr(str, '/', output - str);
            if (output == NULL)
                output = str;
            continue;
        }
        if (strcmp(input, ""/.."") == 0)
        {
            input[1] = '\0';
            output = memrchr(str, '/', output - str);
            if (output == NULL)
          ...",636.0,705.0,1.0,1.0,70.0,44,9,55,5,1,0,22,28,0,0,,0,0,2,1,1,char*
3485,184312,vlc_uri_compose,1,vlc_uri_compose,char* vlc_uri_compose (vlc_url_t*),text\url.c,"char *vlc_uri_compose(const vlc_url_t *uri)
{
    struct vlc_memstream stream;
    char *enc;

    vlc_memstream_open(&stream);

    if (uri->psz_protocol != NULL)
        vlc_memstream_printf(&stream, ""%s:"", uri->psz_protocol);

    if (uri->psz_host != NULL)
    {
        vlc_memstream_write(&stream, ""//"", 2);

        if (uri->psz_username != NULL)
        {
            enc = vlc_uri_encode(uri->psz_username);
            if (enc == NULL)
                goto error;

            vlc_memstream_puts(&stream, enc);
            free(enc);

            if (uri->psz_password != NULL)
            {
                enc = vlc_uri_encode(uri->psz_password);
                if (unlikely(enc == NULL))
                    goto error;

                vlc_memstream_printf(&stream, "":%s"", enc);
                free(enc);
            }
            vlc_memstream_putc(&stream, '@');
        }

        const char *fmt;

        if (strchr(uri->psz_host, ':') != NULL)
            fmt = (uri->i_port ...",707.0,766.0,1.0,1.0,60.0,43,7,49,5,1,11,14,21,2,11,,0,4,2,1,1,char*
3486,184498,vlc_uri_resolve,1,vlc_uri_resolve,"char* vlc_uri_resolve (char*,char*)",text\url.c,"char *vlc_uri_resolve(const char *base, const char *ref)
{
    vlc_url_t base_uri, rel_uri;
    vlc_url_t tgt_uri;
    char *pathbuf = NULL, *ret = NULL;

    if (vlc_UrlParse(&rel_uri, ref))
    {
        vlc_UrlClean(&rel_uri);
        return NULL;
    }

    if (rel_uri.psz_protocol != NULL)
    {   /* Short circuit in case of absolute URI */
        vlc_UrlClean(&rel_uri);
        return strdup(ref);
    }

    vlc_UrlParse(&base_uri, base);

    /* RFC3986 section 5.2.2 */
    do
    {
        tgt_uri = rel_uri;
        tgt_uri.psz_protocol = base_uri.psz_protocol;

        if (rel_uri.psz_host != NULL)
            break;

        tgt_uri.psz_username = base_uri.psz_username;
        tgt_uri.psz_password = base_uri.psz_password;
        tgt_uri.psz_host = base_uri.psz_host;
        tgt_uri.i_port = base_uri.i_port;

        if (rel_uri.psz_path == NULL || rel_uri.psz_path[0] == '\0')
        {
            tgt_uri.psz_path = base_uri.psz_path;
            if (rel_uri.psz_option ...",768.0,830.0,1.0,1.0,63.0,56,7,54,8,0,9,14,16,1,9,,0,3,4,2,2,char*
3487,184806,vlc_uri_fixup,1,vlc_uri_fixup,char* vlc_uri_fixup (char*),text\url.c,"char *vlc_uri_fixup(const char *str)
{
    static const char extras[] = "":/?#[]@"";

    /* Rule number one is do not change a (potentially) valid URI */
    if (vlc_uri_component_validate(str, extras))
        return strdup(str);

    return vlc_uri_fixup_inner(str, extras);
}",864.0,873.0,1.0,1.0,10.0,1,1,6,2,0,2,2,2,1,2,,0,1,2,1,1,char*
3488,184867,VLC_CompileBy,1,VLC_CompileBy,const char* VLC_CompileBy (void),version.c,"DECLARE_VLC_VERSION( CompileBy, COMPILE_BY )",43.0,43.0,1.0,44.0,1.0,0,0,1,1,0,0,1,1,0,0,,0,0,2,1,1,const char*
3489,184874,VLC_CompileHost,1,VLC_CompileHost,const char* VLC_CompileHost (void),version.c,"DECLARE_VLC_VERSION( CompileHost, COMPILE_HOST )",44.0,44.0,1.0,48.0,1.0,0,0,1,1,0,0,1,1,0,0,,0,0,2,1,1,const char*
3490,184881,VLC_Compiler,1,VLC_Compiler,const char* VLC_Compiler (void),version.c,"DECLARE_VLC_VERSION( Compiler, COMPILER )",45.0,45.0,1.0,41.0,1.0,0,0,1,1,0,0,1,1,0,0,,0,0,2,1,1,const char*
3491,184903,vout_chrono_Init,1,vout_chrono_Init,"void vout_chrono_Init (vout_chrono_t*,int,mtime_t)",video_output\chrono.h,"static inline void vout_chrono_Init(vout_chrono_t *chrono, int shift, mtime_t avg_initial)
{
    chrono->shift       = shift;
    chrono->avg_initial =
    chrono->avg         = avg_initial;

    chrono->shift_var   = shift+1;
    chrono->var         = avg_initial / 2;

    chrono->start = VLC_TS_INVALID;
}",40.0,50.0,1.0,1.0,11.0,14,4,11,4,2,6,1,1,0,0,,0,6,6,3,3,void
3492,184943,vout_chrono_Clean,1,vout_chrono_Clean,void vout_chrono_Clean (vout_chrono_t*),video_output\chrono.h,"static inline void vout_chrono_Clean(vout_chrono_t *chrono)
{
    VLC_UNUSED(chrono);
}",51.0,54.0,1.0,1.0,4.0,0,0,1,1,2,0,1,1,0,0,,0,0,2,1,1,void
3493,184950,vout_chrono_Start,1,vout_chrono_Start,void vout_chrono_Start (vout_chrono_t*),video_output\chrono.h,"static inline void vout_chrono_Start(vout_chrono_t *chrono)
{
    chrono->start = mdate();
}",55.0,58.0,1.0,1.0,4.0,2,2,1,1,1,2,1,1,0,1,,0,2,2,1,1,void
3494,184960,vout_chrono_GetHigh,1,vout_chrono_GetHigh,mtime_t vout_chrono_GetHigh (vout_chrono_t*),video_output\chrono.h,"static inline mtime_t vout_chrono_GetHigh(vout_chrono_t *chrono)
{
    return chrono->avg + 2 * chrono->var;
}",59.0,62.0,1.0,1.0,4.0,4,3,2,1,2,2,1,1,0,0,,0,2,2,1,1,mtime_t
3495,184975,vout_chrono_GetLow,1,vout_chrono_GetLow,mtime_t vout_chrono_GetLow (vout_chrono_t*),video_output\chrono.h,"static inline mtime_t vout_chrono_GetLow(vout_chrono_t *chrono)
{
    return __MAX(chrono->avg - 2 * chrono->var, 0);
}",63.0,66.0,1.0,1.0,4.0,4,3,2,1,0,2,1,1,0,0,,0,2,2,1,1,mtime_t
3496,184992,vout_chrono_Stop,1,vout_chrono_Stop,void vout_chrono_Stop (vout_chrono_t*),video_output\chrono.h,"static inline void vout_chrono_Stop(vout_chrono_t *chrono)
{
    assert(chrono->start != VLC_TS_INVALID);

    /* */
    const mtime_t duration = mdate() - chrono->start;
    const mtime_t var = llabs( duration - chrono->avg );

    /* Update average only if the current point is 'valid' */
    if( duration < vout_chrono_GetHigh( chrono ) )
        chrono->avg = (((1 << chrono->shift) - 1) * chrono->avg + duration) >> chrono->shift;
    /* Always update the variance */
    chrono->var = (((1 << chrono->shift_var) - 1) * chrono->var + var) >> chrono->shift_var;

    /* For assert */
    chrono->start = VLC_TS_INVALID;
}",68.0,84.0,1.0,1.0,17.0,31,9,21,4,1,14,2,2,1,2,,0,14,2,1,1,void
3497,185073,vout_chrono_Reset,1,vout_chrono_Reset,void vout_chrono_Reset (vout_chrono_t*),video_output\chrono.h,"static inline void vout_chrono_Reset(vout_chrono_t *chrono)
{
    vout_chrono_t ch = *chrono;
    vout_chrono_Clean(chrono);
    vout_chrono_Init(chrono, ch.shift, ch.avg_initial);
}",85.0,90.0,1.0,1.0,6.0,4,3,6,2,0,4,1,1,0,2,,0,2,2,1,1,void
3498,185106,vout_control_cmd_Init,1,vout_control_cmd_Init,"void vout_control_cmd_Init (vout_control_cmd_t*,int)",video_output\control.c,"void vout_control_cmd_Init(vout_control_cmd_t *cmd, int type)
{
    memset(cmd, 0, sizeof(*cmd));
    cmd->type = type;
}",33.0,37.0,1.0,1.0,5.0,4,4,4,2,15,1,1,1,0,0,,0,1,4,2,2,void
3499,185123,vout_control_cmd_Clean,1,vout_control_cmd_Clean,void vout_control_cmd_Clean (vout_control_cmd_t*),video_output\control.c,"void vout_control_cmd_Clean(vout_control_cmd_t *cmd)
{
    switch (cmd->type) {
    case VOUT_CONTROL_SUBPICTURE:
        if (cmd->u.subpicture)
            subpicture_Delete(cmd->u.subpicture);
        break;
    case VOUT_CONTROL_OSD_TITLE:
    case VOUT_CONTROL_CHANGE_FILTERS:
    case VOUT_CONTROL_CHANGE_SUB_SOURCES:
    case VOUT_CONTROL_CHANGE_SUB_FILTERS:
        free(cmd->u.string);
        break;
    default:
        break;
    }
}",39.0,55.0,1.0,1.0,17.0,7,2,9,6,2,5,6,4,2,1,,0,4,2,1,1,void
3500,185166,vout_control_Init,1,vout_control_Init,void vout_control_Init (vout_control_t*),video_output\control.c,"void vout_control_Init(vout_control_t *ctrl)
{
    vlc_mutex_init(&ctrl->lock);
    vlc_cond_init(&ctrl->wait_request);
    vlc_cond_init(&ctrl->wait_acknowledge);

    ctrl->is_dead = false;
    ctrl->can_sleep = true;
    ctrl->is_processing = false;
    ARRAY_INIT(ctrl->cmd);
}",58.0,68.0,1.0,1.0,11.0,13,3,10,3,1,9,1,1,0,3,,0,6,2,1,1,void
3501,185205,vout_control_Clean,1,vout_control_Clean,void vout_control_Clean (vout_control_t*),video_output\control.c,"void vout_control_Clean(vout_control_t *ctrl)
{
    /* */
    for (int i = 0; i < ctrl->cmd.i_size; i++) {
        vout_control_cmd_t cmd = ARRAY_VAL(ctrl->cmd, i);
        vout_control_cmd_Clean(&cmd);
    }
    ARRAY_RESET(ctrl->cmd);

    vlc_mutex_destroy(&ctrl->lock);
    vlc_cond_destroy(&ctrl->wait_request);
    vlc_cond_destroy(&ctrl->wait_acknowledge);
}",70.0,82.0,1.0,1.0,13.0,14,5,11,3,0,7,2,2,0,4,,0,3,2,1,1,void
3502,185256,vout_control_Dead,1,vout_control_Dead,void vout_control_Dead (vout_control_t*),video_output\control.c,"void vout_control_Dead(vout_control_t *ctrl)
{
    vlc_mutex_lock(&ctrl->lock);
    ctrl->is_dead = true;
    vlc_cond_broadcast(&ctrl->wait_acknowledge);
    vlc_mutex_unlock(&ctrl->lock);

}",84.0,91.0,1.0,1.0,8.0,8,3,5,2,1,7,1,1,0,3,,0,4,2,1,1,void
3503,185281,vout_control_WaitEmpty,1,vout_control_WaitEmpty,void vout_control_WaitEmpty (vout_control_t*),video_output\control.c,"void vout_control_WaitEmpty(vout_control_t *ctrl)
{
    vlc_mutex_lock(&ctrl->lock);
    while ((ctrl->cmd.i_size > 0 || ctrl->is_processing) && !ctrl->is_dead)
        vlc_cond_wait(&ctrl->wait_acknowledge, &ctrl->lock);
    vlc_mutex_unlock(&ctrl->lock);
}",93.0,99.0,1.0,1.0,7.0,12,7,5,1,6,6,2,2,2,2,,0,4,2,1,1,void
3504,185322,vout_control_Push,1,vout_control_Push,"void vout_control_Push (vout_control_t*,vout_control_cmd_t*)",video_output\control.c,"void vout_control_Push(vout_control_t *ctrl, vout_control_cmd_t *cmd)
{
    vlc_mutex_lock(&ctrl->lock);
    if (!ctrl->is_dead) {
        ARRAY_APPEND(ctrl->cmd, *cmd);
        vlc_cond_signal(&ctrl->wait_request);
    } else {
        vout_control_cmd_Clean(cmd);
    }
    vlc_mutex_unlock(&ctrl->lock);
}",101.0,111.0,1.0,1.0,11.0,10,4,6,2,15,7,2,2,1,3,,0,4,4,2,2,void
3505,185359,vout_control_Wake,1,vout_control_Wake,void vout_control_Wake (vout_control_t*),video_output\control.c,"void vout_control_Wake(vout_control_t *ctrl)
{
    vlc_mutex_lock(&ctrl->lock);
    ctrl->can_sleep = false;
    vlc_cond_signal(&ctrl->wait_request);
    vlc_mutex_unlock(&ctrl->lock);
}",113.0,119.0,1.0,1.0,7.0,8,3,5,2,1,7,1,1,0,3,,0,4,2,1,1,void
3506,185384,vout_control_PushVoid,1,vout_control_PushVoid,"void vout_control_PushVoid (vout_control_t*,int)",video_output\control.c,"void vout_control_PushVoid(vout_control_t *ctrl, int type)
{
    vout_control_cmd_t cmd;

    vout_control_cmd_Init(&cmd, type);
    vout_control_Push(ctrl, &cmd);
}",121.0,127.0,1.0,1.0,7.0,2,1,4,3,2,2,1,1,0,2,,0,0,4,2,2,void
3507,185399,vout_control_PushBool,1,vout_control_PushBool,"void vout_control_PushBool (vout_control_t*,int,bool)",video_output\control.c,"void vout_control_PushBool(vout_control_t *ctrl, int type, bool boolean)
{
    vout_control_cmd_t cmd;

    vout_control_cmd_Init(&cmd, type);
    cmd.u.boolean = boolean;
    vout_control_Push(ctrl, &cmd);
}",128.0,135.0,1.0,1.0,8.0,5,3,6,4,4,3,1,1,0,2,,0,1,6,3,3,void
3508,185422,vout_control_PushInteger,1,vout_control_PushInteger,"void vout_control_PushInteger (vout_control_t*,int,int)",video_output\control.c,"void vout_control_PushInteger(vout_control_t *ctrl, int type, int integer)
{
    vout_control_cmd_t cmd;

    vout_control_cmd_Init(&cmd, type);
    cmd.u.integer = integer;
    vout_control_Push(ctrl, &cmd);
}",136.0,143.0,1.0,1.0,8.0,5,3,6,4,3,3,1,1,0,2,,0,1,6,3,3,void
3509,185445,vout_control_PushTime,1,vout_control_PushTime,"void vout_control_PushTime (vout_control_t*,int,mtime_t)",video_output\control.c,"void vout_control_PushTime(vout_control_t *ctrl, int type, mtime_t time)
{
    vout_control_cmd_t cmd;

    vout_control_cmd_Init(&cmd, type);
    cmd.u.time = time;
    vout_control_Push(ctrl, &cmd);
}",144.0,151.0,1.0,1.0,8.0,5,3,6,4,1,3,1,1,0,2,,0,1,6,3,3,void
3510,185468,vout_control_PushMessage,1,vout_control_PushMessage,"void vout_control_PushMessage (vout_control_t*,int,int,char*)",video_output\control.c,"void vout_control_PushMessage(vout_control_t *ctrl, int type, int channel, const char *string)
{
    vout_control_cmd_t cmd;

    vout_control_cmd_Init(&cmd, type);
    cmd.u.message.channel = channel;
    cmd.u.message.string = strdup(string);
    vout_control_Push(ctrl, &cmd);
}",152.0,160.0,1.0,1.0,9.0,10,3,8,5,0,4,1,1,0,2,,0,2,8,4,4,void
3511,185504,vout_control_PushPair,1,vout_control_PushPair,"void vout_control_PushPair (vout_control_t*,int,int,int)",video_output\control.c,"void vout_control_PushPair(vout_control_t *ctrl, int type, int a, int b)
{
    vout_control_cmd_t cmd;

    vout_control_cmd_Init(&cmd, type);
    cmd.u.pair.a = a;
    cmd.u.pair.b = b;
    vout_control_Push(ctrl, &cmd);
}",161.0,169.0,1.0,1.0,9.0,10,3,8,5,3,4,1,1,0,2,,0,2,8,4,4,void
3512,185539,vout_control_PushString,1,vout_control_PushString,"void vout_control_PushString (vout_control_t*,int,char*)",video_output\control.c,"void vout_control_PushString(vout_control_t *ctrl, int type, const char *string)
{
    vout_control_cmd_t cmd;

    vout_control_cmd_Init(&cmd, type);
    cmd.u.string = string ? strdup(string) : NULL;
    vout_control_Push(ctrl, &cmd);
}",170.0,177.0,1.0,1.0,8.0,6,4,8,5,4,3,1,1,0,2,,0,1,6,3,3,void
3513,185566,vout_control_Pop,1,vout_control_Pop,"int vout_control_Pop (vout_control_t*,vout_control_cmd_t*,mtime_t)",video_output\control.c,"int vout_control_Pop(vout_control_t *ctrl, vout_control_cmd_t *cmd,
                     mtime_t deadline)
{
    vlc_mutex_lock(&ctrl->lock);
    if (ctrl->cmd.i_size <= 0) {
        ctrl->is_processing = false;
        vlc_cond_broadcast(&ctrl->wait_acknowledge);

        /* Spurious wakeups are perfectly fine */
        if (deadline > VLC_TS_INVALID && ctrl->can_sleep)
            vlc_cond_timedwait(&ctrl->wait_request, &ctrl->lock, deadline);
    }

    bool has_cmd;
    if (ctrl->cmd.i_size > 0) {
        has_cmd = true;
        *cmd = ARRAY_VAL(ctrl->cmd, 0);
        ARRAY_REMOVE(ctrl->cmd, 0);

        ctrl->is_processing = true;
    } else {
        has_cmd = false;
        ctrl->can_sleep = true;
    }
    vlc_mutex_unlock(&ctrl->lock);

    return has_cmd ? VLC_SUCCESS : VLC_EGENERIC;
}",179.0,206.0,1.0,1.0,28.0,29,9,23,9,0,12,4,5,1,4,,0,8,6,3,3,int
3514,185883,SplitterClose,1,SplitterClose,void SplitterClose (vout_display_t*),video_output\display.c,"static void SplitterClose(vout_display_t *vd)
{
    vout_display_sys_t *sys = vd->sys;

    /* */
    video_splitter_t *splitter = sys->splitter;
    free(splitter->p_owner);
    video_splitter_Delete(splitter);

    if (sys->pool)
        picture_pool_Release(sys->pool);

    /* */
    for (int i = 0; i < sys->count; i++)
        vout_DeleteDisplay(sys->display[i], NULL);
    TAB_CLEAN(sys->count, sys->display);
    free(sys->picture);

    free(sys);
}",1409.0,1428.0,1.0,1.0,20.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
3515,185888,VideoBufferNew,1,VideoBufferNew,picture_t VideoBufferNew (filter_t*),video_output\display.c,"static picture_t *VideoBufferNew(filter_t *filter)
{
    vout_display_t *vd = filter->owner.sys;
    const video_format_t *fmt = &filter->fmt_out.video;

    assert(vd->fmt.i_chroma == fmt->i_chroma &&
           vd->fmt.i_width  == fmt->i_width  &&
           vd->fmt.i_height == fmt->i_height);

    picture_pool_t *pool = vout_display_Pool(vd, 3);
    if (!pool)
        return NULL;
    return picture_pool_Get(pool);
}",53.0,66.0,1.0,1.0,14.0,23,7,15,5,0,1,2,2,0,1,,0,0,2,1,1,picture_t
3516,185955,vout_display_New,1,vout_display_New,"vout_display_t vout_display_New (vlc_object_t*,char*,bool,video_format_t*,vout_display_cfg_t*,vout_display_owner_t*)",video_output\display.c,"static vout_display_t *vout_display_New(vlc_object_t *obj,
                                        const char *module, bool load_module,
                                        const video_format_t *fmt,
                                        const vout_display_cfg_t *cfg,
                                        vout_display_owner_t *owner)
{
    /* */
    vout_display_t *vd = vlc_custom_create(obj, sizeof(*vd), ""vout display"" );

    /* */
    video_format_Copy(&vd->source, fmt);

    /* Picture buffer does not have the concept of aspect ratio */
    video_format_Copy(&vd->fmt, fmt);
    vd->fmt.i_sar_num = 0;
    vd->fmt.i_sar_den = 0;

    vd->info.is_slow = false;
    vd->info.has_double_click = false;
    vd->info.needs_hide_mouse = false;
    vd->info.has_pictures_invalid = false;
    vd->info.subpicture_chromas = NULL;

    vd->cfg = cfg;
    vd->pool = NULL;
    vd->prepare = NULL;
    vd->display = NULL;
    vd->control = NULL;
    vd->manage = NULL;
    vd->sys = NULL;

 ...",75.0,118.0,1.0,1.0,44.0,52,9,45,9,1,3,3,4,0,3,,0,2,12,6,6,vout_display_t
3517,186112,vout_display_Delete,1,vout_display_Delete,void vout_display_Delete (vout_display_t*),video_output\display.c,"static void vout_display_Delete(vout_display_t *vd)
{
    if (vd->module)
        module_unneed(vd, vd->module);

    video_format_Clean(&vd->source);
    video_format_Clean(&vd->fmt);

    vlc_object_release(vd);
}",123.0,132.0,1.0,1.0,10.0,6,2,6,1,2,2,2,2,0,2,,0,0,2,1,1,void
3518,186139,vout_display_Control,1,vout_display_Control,"int vout_display_Control (vout_display_t*,int...)",video_output\display.c,"static int vout_display_Control(vout_display_t *vd, int query, ...)
{
    va_list args;
    int result;

    va_start(args, query);
    result = vd->control(vd, query, args);
    va_end(args);

    return result;
}",137.0,147.0,1.0,1.0,11.0,2,2,9,4,8,0,1,1,0,0,,0,0,4,2,2,int
3519,186163,vout_display_Manage,1,vout_display_Manage,void vout_display_Manage (vout_display_t*),video_output\display.c,"static void vout_display_Manage(vout_display_t *vd)
{
    if (vd->manage)
        vd->manage(vd);
}",149.0,153.0,1.0,1.0,5.0,2,1,3,1,1,0,2,2,0,0,,0,0,2,1,1,void
3520,186178,vout_display_GetDefaultDisplaySize,1,vout_display_GetDefaultDisplaySize,"void vout_display_GetDefaultDisplaySize (unsigned*,unsigned*,video_format_t*,vout_display_cfg_t*)",video_output\display.c,"void vout_display_GetDefaultDisplaySize(unsigned *width, unsigned *height,
                                        const video_format_t *source,
                                        const vout_display_cfg_t *cfg)
{
    if (cfg->display.width != 0 && cfg->display.height != 0) {
        *width  = cfg->display.width;
        *height = cfg->display.height;
    } else if (cfg->display.width != 0) {
        *width  = cfg->display.width;
        *height = (int64_t)source->i_visible_height * source->i_sar_den * cfg->display.width * cfg->display.sar.num /
            source->i_visible_width / source->i_sar_num / cfg->display.sar.den;
    } else if (cfg->display.height != 0) {
        *width  = (int64_t)source->i_visible_width * source->i_sar_num * cfg->display.height * cfg->display.sar.den /
            source->i_visible_height / source->i_sar_den / cfg->display.sar.num;
        *height = cfg->display.height;
    } else if (source->i_sar_num >= source->i_sar_den) {
        *width  = (int6...",156.0,188.0,1.0,1.0,33.0,41,8,21,5,2,0,3,3,0,0,,0,0,8,4,4,void
3521,186484,vout_display_PlacePicture,1,vout_display_PlacePicture,"void vout_display_PlacePicture (vout_display_place_t*,video_format_t*,vout_display_cfg_t*,bool)",video_output\display.c,"void vout_display_PlacePicture(vout_display_place_t *place,
                               const video_format_t *source,
                               const vout_display_cfg_t *cfg,
                               bool do_clipping)
{
    /* */
    memset(place, 0, sizeof(*place));
    if (cfg->display.width == 0 || cfg->display.height == 0)
        return;

    /* */
    unsigned display_width;
    unsigned display_height;

    video_format_t source_rot;
    video_format_ApplyRotation(&source_rot, source);
    source = &source_rot;

    if (cfg->is_display_filled) {
        display_width  = cfg->display.width;
        display_height = cfg->display.height;
    } else {
        vout_display_cfg_t cfg_tmp = *cfg;

        cfg_tmp.display.width  = 0;
        cfg_tmp.display.height = 0;
        vout_display_GetDefaultDisplaySize(&display_width, &display_height,
                                           source, &cfg_tmp);

        if (do_clipping) {
            display_width  = __MIN(dis...",191.0,273.0,1.0,1.0,83.0,102,13,61,15,2,1,13,8,0,1,,0,0,8,4,4,void
3522,186830,vout_display_SendMouseMovedDisplayCoordinates,1,vout_display_SendMouseMovedDisplayCoordinates,"void vout_display_SendMouseMovedDisplayCoordinates (vout_display_t*,video_orientation_t,int,int,vout_display_place_t*)",video_output\display.c,"void vout_display_SendMouseMovedDisplayCoordinates(vout_display_t *vd, video_orientation_t orient_display, int m_x, int m_y, vout_display_place_t *place)
{
    video_format_t source_rot = vd->source;
    video_format_TransformTo(&source_rot, orient_display);

    if (place->width > 0 && place->height > 0) {

        int x = (int)(source_rot.i_x_offset +
                            (int64_t)(m_x - place->x) * source_rot.i_visible_width / place->width);
        int y = (int)(source_rot.i_y_offset +
                            (int64_t)(m_y - place->y) * source_rot.i_visible_height/ place->height);

        video_transform_t transform = video_format_GetTransform(vd->source.orientation, orient_display);

        int store;

        switch (transform) {

            case TRANSFORM_R90:
                store = x;
                x = y;
                y = vd->source.i_visible_height - store;
                break;
            case TRANSFORM_R180:
                x = vd->source.i_visible_w...",275.0,329.0,1.0,1.0,55.0,71,11,72,17,0,2,11,4,0,2,,0,1,10,5,5,void
3523,187093,VoutDisplayCreateRender,1,VoutDisplayCreateRender,int VoutDisplayCreateRender (vout_display_t*),video_output\display.c,"static int VoutDisplayCreateRender(vout_display_t *vd)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;
    filter_owner_t owner = {
        .sys = vd,
        .video = {
            .buffer_new = VideoBufferNew,
        },
    };

    osys->filters = filter_chain_NewVideo(vd, false, &owner);
    if (unlikely(osys->filters == NULL))
        return -1;

    video_format_t v_src = vd->source;
    v_src.i_sar_num = 0;
    v_src.i_sar_den = 0;

    video_format_t v_dst = vd->fmt;
    v_dst.i_sar_num = 0;
    v_dst.i_sar_den = 0;

    video_format_t v_dst_cmp = v_dst;
    if ((v_src.i_chroma == VLC_CODEC_J420 && v_dst.i_chroma == VLC_CODEC_I420) ||
        (v_src.i_chroma == VLC_CODEC_J422 && v_dst.i_chroma == VLC_CODEC_I422) ||
        (v_src.i_chroma == VLC_CODEC_J440 && v_dst.i_chroma == VLC_CODEC_I440) ||
        (v_src.i_chroma == VLC_CODEC_J444 && v_dst.i_chroma == VLC_CODEC_I444))
        v_dst_cmp.i_chroma = v_src.i_chroma;

    const bool convert = memcmp(&v_src, &v_dst_cmp...",402.0,464.0,1.0,1.0,63.0,93,16,75,24,2,14,8,8,1,8,,0,8,2,1,1,int
3524,187355,VoutDisplayDestroyRender,1,VoutDisplayDestroyRender,void VoutDisplayDestroyRender (vout_display_t*),video_output\display.c,"static void VoutDisplayDestroyRender(vout_display_t *vd)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    if (osys->filters)
        filter_chain_Delete(osys->filters);
}",466.0,472.0,1.0,1.0,7.0,5,3,4,2,2,3,2,2,1,1,,0,2,2,1,1,void
3525,187377,VoutDisplayResetRender,1,VoutDisplayResetRender,int VoutDisplayResetRender (vout_display_t*),video_output\display.c,"static int VoutDisplayResetRender(vout_display_t *vd)
{
    VoutDisplayDestroyRender(vd);
    return VoutDisplayCreateRender(vd);
}",474.0,478.0,1.0,1.0,5.0,0,0,2,1,1,2,1,1,0,2,,0,0,2,1,1,int
3526,187387,VoutDisplayEventMouse,1,VoutDisplayEventMouse,"void VoutDisplayEventMouse (vout_display_t*,int,va_list)",video_output\display.c,"static void VoutDisplayEventMouse(vout_display_t *vd, int event, va_list args)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    vlc_mutex_lock(&osys->lock);

    /* */
    vlc_mouse_t m = osys->mouse.state;
    bool is_ignored = false;

    switch (event) {
    case VOUT_DISPLAY_EVENT_MOUSE_STATE: {
        const int x = (int)va_arg(args, int);
        const int y = (int)va_arg(args, int);
        const int button_mask = (int)va_arg(args, int);

        vlc_mouse_Init(&m);
        m.i_x = x;
        m.i_y = y;
        m.i_pressed = button_mask;
        break;
    }
    case VOUT_DISPLAY_EVENT_MOUSE_MOVED: {
        const int x = (int)va_arg(args, int);
        const int y = (int)va_arg(args, int);

        //msg_Dbg(vd, ""VoutDisplayEvent 'mouse' @%d,%d"", x, y);

        m.i_x = x;
        m.i_y = y;
        m.b_double_click = false;
        break;
    }
    case VOUT_DISPLAY_EVENT_MOUSE_PRESSED:
    case VOUT_DISPLAY_EVENT_MOUSE_RELEASED: {
        const int button = (int)...",480.0,572.0,1.0,1.0,93.0,80,12,71,18,1,10,12,10,0,6,,0,6,6,3,3,void
3527,187656,VoutDisplayEvent,1,VoutDisplayEvent,"void VoutDisplayEvent (vout_display_t*,int,va_list)",video_output\display.c,"static void VoutDisplayEvent(vout_display_t *vd, int event, va_list args)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    switch (event) {
    case VOUT_DISPLAY_EVENT_CLOSE: {
        msg_Dbg(vd, ""VoutDisplayEvent 'close'"");
        vout_SendEventClose(osys->vout);
        break;
    }
    case VOUT_DISPLAY_EVENT_KEY: {
        const int key = (int)va_arg(args, int);
        msg_Dbg(vd, ""VoutDisplayEvent 'key' 0x%2.2x"", key);
        vout_SendEventKey(osys->vout, key);
        break;
    }
    case VOUT_DISPLAY_EVENT_MOUSE_STATE:
    case VOUT_DISPLAY_EVENT_MOUSE_MOVED:
    case VOUT_DISPLAY_EVENT_MOUSE_PRESSED:
    case VOUT_DISPLAY_EVENT_MOUSE_RELEASED:
    case VOUT_DISPLAY_EVENT_MOUSE_DOUBLE_CLICK:
        VoutDisplayEventMouse(vd, event, args);
        break;

    case VOUT_DISPLAY_EVENT_VIEWPOINT_MOVED:
        vout_SendEventViewpointMoved(osys->vout,
                                     va_arg(args, const vlc_viewpoint_t *));
        break;

#if defined(_WIN32) || ...",574.0,666.0,1.0,1.0,93.0,23,4,41,18,1,17,9,2,0,7,,0,10,6,3,3,void
3528,187788,VoutDisplayNewWindow,1,VoutDisplayNewWindow,"vout_window_t VoutDisplayNewWindow (vout_display_t*,unsigned)",video_output\display.c,"static vout_window_t *VoutDisplayNewWindow(vout_display_t *vd, unsigned type)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;
    vout_window_t *window = vout_NewDisplayWindow(osys->vout, type);
    if (window != NULL)
        vout_display_window_Attach(window, vd);
    return window;
}",668.0,675.0,1.0,1.0,8.0,6,4,10,5,0,3,2,2,0,2,,0,2,4,2,2,vout_window_t
3529,187820,VoutDisplayDelWindow,1,VoutDisplayDelWindow,"void VoutDisplayDelWindow (vout_display_t*,vout_window_t*)",video_output\display.c,"static void VoutDisplayDelWindow(vout_display_t *vd, vout_window_t *window)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    if (window != NULL)
        vout_display_window_Detach(window);
    vout_DeleteDisplayWindow(osys->vout, window);
}",677.0,684.0,1.0,1.0,8.0,5,4,7,4,0,3,2,2,0,2,,0,1,4,2,2,void
3530,187846,VoutDisplayFitWindow,1,VoutDisplayFitWindow,"void VoutDisplayFitWindow (vout_display_t*,bool)",video_output\display.c,"static void VoutDisplayFitWindow(vout_display_t *vd, bool default_size)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;
    vout_display_cfg_t cfg = osys->cfg;

    if (!cfg.is_display_filled)
        return;

    cfg.display.width = 0;
    if (default_size) {
        cfg.display.height = 0;
    } else {
        cfg.zoom.num = 1;
        cfg.zoom.den = 1;
    }

    unsigned display_width;
    unsigned display_height;
    vout_display_GetDefaultDisplaySize(&display_width, &display_height,
                                       &vd->source, &cfg);
    vout_SetDisplayWindowSize(osys->vout, display_width, display_height);
}",686.0,707.0,1.0,1.0,22.0,19,5,15,6,1,4,3,3,0,2,,0,2,4,2,2,void
3531,187925,VoutDisplayCropRatio,1,VoutDisplayCropRatio,"void VoutDisplayCropRatio (int*,int*,int*,int*,video_format_t*,unsigned,unsigned)",video_output\display.c,"static void VoutDisplayCropRatio(int *left, int *top, int *right, int *bottom,
                                 const video_format_t *source,
                                 unsigned num, unsigned den)
{
    unsigned scaled_width  = (uint64_t)source->i_visible_height * num * source->i_sar_den / den / source->i_sar_num;
    unsigned scaled_height = (uint64_t)source->i_visible_width  * den * source->i_sar_num / num / source->i_sar_den;

    if (scaled_width < source->i_visible_width) {
        *left   = (source->i_visible_width - scaled_width) / 2;
        *top    = 0;
        *right  = *left + scaled_width;
        *bottom = *top  + source->i_visible_height;
    } else {
        *left   = 0;
        *top    = (source->i_visible_height - scaled_height) / 2;
        *right  = *left + source->i_visible_width;
        *bottom = *top  + scaled_height;
    }
}",709.0,727.0,1.0,1.0,19.0,36,9,24,9,1,0,2,2,0,0,,0,0,14,7,7,void
3532,188045,vout_ManageDisplay,1,vout_ManageDisplay,"bool vout_ManageDisplay (vout_display_t*,bool)",video_output\display.c,"bool vout_ManageDisplay(vout_display_t *vd, bool allow_reset_pictures)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    vout_display_Manage(vd);

    /* Handle mouse timeout */
    const mtime_t date = mdate();
    bool  hide_mouse = false;

    vlc_mutex_lock(&osys->lock);

    if (!osys->mouse.is_hidden &&
        osys->mouse.last_moved + osys->mouse.hide_timeout < date) {
        osys->mouse.is_hidden = hide_mouse = true;
    } else if (osys->mouse.ch_activity) {
        if (osys->mouse.is_hidden)
            vout_HideWindowMouse(osys->vout, false);
        osys->mouse.is_hidden = false;
    }
    osys->mouse.ch_activity = false;
    vlc_mutex_unlock(&osys->lock);

    if (hide_mouse) {
        msg_Dbg(vd, ""auto hiding mouse cursor"");
        if (vout_HideWindowMouse(osys->vout, true) != VLC_SUCCESS
         && vd->info.needs_hide_mouse)
            vout_display_Control(vd, VOUT_DISPLAY_HIDE_MOUSE);
    }

    bool reset_render = false;
    for (;;) {

        vlc_mutex...",729.0,963.0,1.0,1.0,235.0,341,15,217,31,0,97,27,55,21,20,,0,81,4,2,2,bool
3533,189032,vout_AreDisplayPicturesInvalid,1,vout_AreDisplayPicturesInvalid,bool vout_AreDisplayPicturesInvalid (vout_display_t*),video_output\display.c,"bool vout_AreDisplayPicturesInvalid(vout_display_t *vd)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    vlc_mutex_lock(&osys->lock);
    const bool reset_pictures = osys->reset_pictures;
    vlc_mutex_unlock(&osys->lock);

    return reset_pictures;
}",965.0,974.0,1.0,1.0,10.0,9,4,7,3,0,5,1,1,0,2,,0,3,2,1,1,bool
3534,189063,vout_IsDisplayFiltered,1,vout_IsDisplayFiltered,bool vout_IsDisplayFiltered (vout_display_t*),video_output\display.c,"bool vout_IsDisplayFiltered(vout_display_t *vd)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    return osys->filters == NULL || !filter_chain_IsEmpty(osys->filters);
}",976.0,981.0,1.0,1.0,6.0,8,6,5,3,2,3,1,1,0,1,,0,2,2,1,1,bool
3535,189088,vout_FilterDisplay,1,vout_FilterDisplay,"picture_t vout_FilterDisplay (vout_display_t*,picture_t*)",video_output\display.c,"picture_t *vout_FilterDisplay(vout_display_t *vd, picture_t *picture)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    if (osys->filters == NULL) {
        picture_Release(picture);
        return NULL;
    }

    return filter_chain_VideoFilter(osys->filters, picture);
}",983.0,993.0,1.0,1.0,11.0,6,4,8,4,2,4,2,2,1,2,,0,2,4,2,2,picture_t
3536,189119,vout_FilterFlush,1,vout_FilterFlush,void vout_FilterFlush (vout_display_t*),video_output\display.c,"void vout_FilterFlush(vout_display_t *vd)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    if (osys->filters != NULL)
        filter_chain_VideoFlush(osys->filters);
}",995.0,1001.0,1.0,1.0,7.0,6,4,5,3,1,3,2,2,1,1,,0,2,2,1,1,void
3537,189143,vout_UpdateDisplaySourceProperties,1,vout_UpdateDisplaySourceProperties,"void vout_UpdateDisplaySourceProperties (vout_display_t*,video_format_t*)",video_output\display.c,"void vout_UpdateDisplaySourceProperties(vout_display_t *vd, const video_format_t *source)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    if (source->i_sar_num * osys->source.i_sar_den !=
        source->i_sar_den * osys->source.i_sar_num) {

        osys->source.i_sar_num = source->i_sar_num;
        osys->source.i_sar_den = source->i_sar_den;
        vlc_ureduce(&osys->source.i_sar_num, &osys->source.i_sar_den,
                    osys->source.i_sar_num, osys->source.i_sar_den, 0);

        /* FIXME it will override any AR that the user would have forced */
        osys->ch_sar = true;
        osys->sar.num = osys->source.i_sar_num;
        osys->sar.den = osys->source.i_sar_den;
    }
    if (source->i_x_offset       != osys->source.i_x_offset ||
        source->i_y_offset       != osys->source.i_y_offset ||
        source->i_visible_width  != osys->source.i_visible_width ||
        source->i_visible_height != osys->source.i_visible_height) {

        video_format_Copy...",1003.0,1031.0,1.0,1.0,29.0,65,7,32,4,1,21,3,3,6,2,,0,19,4,2,2,void
3538,189299,vout_SetDisplayFilled,1,vout_SetDisplayFilled,"void vout_SetDisplayFilled (vout_display_t*,bool)",video_output\display.c,"void vout_SetDisplayFilled(vout_display_t *vd, bool is_filled)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    osys->is_display_filled = is_filled;
}",1033.0,1038.0,1.0,1.0,6.0,5,3,4,3,1,1,1,1,0,0,,0,1,4,2,2,void
3539,189318,vout_SetDisplayZoom,1,vout_SetDisplayZoom,"void vout_SetDisplayZoom (vout_display_t*,unsigned,unsigned)",video_output\display.c,"void vout_SetDisplayZoom(vout_display_t *vd, unsigned num, unsigned den)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    if (num != 0 && den != 0) {
        vlc_ureduce(&num, &den, num, den, 0);
    } else {
        num = 1;
        den = 1;
    }

    if (10 * num <= den) {
        num = 1;
        den = 10;
    } else if (num >= 10 * den) {
        num = 10;
        den = 1;
    }

    if (osys->is_display_filled ||
        osys->zoom.num != num || osys->zoom.den != den) {
        osys->ch_zoom = true;
        osys->zoom.num = num;
        osys->zoom.den = den;
    }
}",1040.0,1065.0,1.0,1.0,26.0,29,9,23,5,1,7,4,4,3,1,,0,6,6,3,3,void
3540,189426,vout_SetDisplayAspect,1,vout_SetDisplayAspect,"void vout_SetDisplayAspect (vout_display_t*,unsigned,unsigned)",video_output\display.c,"void vout_SetDisplayAspect(vout_display_t *vd, unsigned dar_num, unsigned dar_den)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    unsigned sar_num, sar_den;
    if (dar_num > 0 && dar_den > 0) {
        sar_num = dar_num * osys->source.i_visible_height;
        sar_den = dar_den * osys->source.i_visible_width;
        vlc_ureduce(&sar_num, &sar_den, sar_num, sar_den, 0);
    } else {
        sar_num = 0;
        sar_den = 0;
    }

    if (osys->sar.num != sar_num || osys->sar.den != sar_den) {
        osys->ch_sar = true;
        osys->sar.num = sar_num;
        osys->sar.den = sar_den;
    }
}",1067.0,1086.0,1.0,1.0,20.0,31,9,24,7,1,8,3,3,2,1,,0,7,6,3,3,void
3541,189522,vout_SetDisplayCrop,1,vout_SetDisplayCrop,"void vout_SetDisplayCrop (vout_display_t*,unsigned,unsigned,unsigned,unsigned,int,int)",video_output\display.c,"void vout_SetDisplayCrop(vout_display_t *vd,
                         unsigned crop_num, unsigned crop_den,
                         unsigned left, unsigned top, int right, int bottom)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    if (osys->crop.left  != (int)left  || osys->crop.top != (int)top ||
        osys->crop.right != right || osys->crop.bottom != bottom ||
        (crop_num != 0 && crop_den != 0 &&
         (crop_num != osys->crop.num || crop_den != osys->crop.den))) {

        osys->crop.left   = left;
        osys->crop.top    = top;
        osys->crop.right  = right;
        osys->crop.bottom = bottom;
        osys->crop.num    = crop_num;
        osys->crop.den    = crop_den;

        osys->ch_crop = true;
    }
}",1087.0,1107.0,1.0,1.0,21.0,52,7,30,9,3,1,2,2,0,0,,0,1,14,7,7,void
3542,189649,vout_SetDisplayViewpoint,1,vout_SetDisplayViewpoint,"void vout_SetDisplayViewpoint (vout_display_t*,vlc_viewpoint_t*)",video_output\display.c,"void vout_SetDisplayViewpoint(vout_display_t *vd,
                              const vlc_viewpoint_t *p_viewpoint)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    if (osys->viewpoint.yaw   != p_viewpoint->yaw ||
        osys->viewpoint.pitch != p_viewpoint->pitch ||
        osys->viewpoint.roll  != p_viewpoint->roll ||
        osys->viewpoint.fov   != p_viewpoint->fov) {
        osys->viewpoint = *p_viewpoint;

        osys->ch_viewpoint = true;
    }
}",1109.0,1122.0,1.0,1.0,14.0,27,6,14,4,1,6,2,2,4,0,,0,6,4,2,2,void
3543,189715,DisplayNew,1,DisplayNew,"vout_display_t DisplayNew (vout_thread_t*,video_format_t*,vout_display_state_t*,char*,bool,mtime_t,mtime_t,vout_display_owner_t*)",video_output\display.c,"static vout_display_t *DisplayNew(vout_thread_t *vout,
                                  const video_format_t *source,
                                  const vout_display_state_t *state,
                                  const char *module, bool is_splitter,
                                  mtime_t double_click_timeout,
                                  mtime_t hide_timeout,
                                  const vout_display_owner_t *owner_ptr)
{
    /* */
    vout_display_owner_sys_t *osys = calloc(1, sizeof(*osys));
    vout_display_cfg_t *cfg = &osys->cfg;

    *cfg = state->cfg;
    osys->sar_initial = state->sar;
    vout_display_GetDefaultDisplaySize(&cfg->display.width, &cfg->display.height,
                                       source, cfg);

    osys->vout = vout;
    osys->is_splitter = is_splitter;

    vlc_mutex_init(&osys->lock);

    vlc_mouse_Init(&osys->mouse.state);
    osys->mouse.last_moved = mdate();
    osys->mouse.double_click_timeout = double_click_timeou...",1124.0,1222.0,1.0,1.0,99.0,126,10,80,15,3,32,7,5,3,8,,0,27,16,8,8,vout_display_t
3544,190064,vout_DeleteDisplay,1,vout_DeleteDisplay,"void vout_DeleteDisplay (vout_display_t*,vout_display_state_t*)",video_output\display.c,"void vout_DeleteDisplay(vout_display_t *vd, vout_display_state_t *state)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    if (state) {
        if (!osys->is_splitter)
            state->cfg = osys->cfg;
#if defined(_WIN32) || defined(__OS2__)
        state->wm_state = osys->wm_state;
#endif
        state->sar = osys->sar_initial;
    }

    VoutDisplayDestroyRender(vd);
    if (osys->is_splitter)
        SplitterClose(vd);
    vout_display_Delete(vd);
    vlc_mutex_destroy(&osys->lock);
    free(osys);
}",1224.0,1243.0,1.0,1.0,20.0,14,5,14,3,1,9,4,5,2,4,,0,5,4,2,2,void
3545,190119,vout_NewDisplay,1,vout_NewDisplay,"vout_display_t vout_NewDisplay (vout_thread_t*,video_format_t*,vout_display_state_t*,char*,mtime_t,mtime_t)",video_output\display.c,"vout_display_t *vout_NewDisplay(vout_thread_t *vout,
                                const video_format_t *source,
                                const vout_display_state_t *state,
                                const char *module,
                                mtime_t double_click_timeout,
                                mtime_t hide_timeout)
{
    return DisplayNew(vout, source, state, module, false,
                      double_click_timeout, hide_timeout, NULL);
}",1248.0,1257.0,1.0,1.0,10.0,0,0,8,8,0,1,1,1,0,1,,0,0,12,6,6,vout_display_t
3546,190147,SplitterNewWindow,1,SplitterNewWindow,"vout_window_t SplitterNewWindow (vout_display_t*,unsigned)",video_output\display.c,"static vout_window_t *SplitterNewWindow(vout_display_t *vd, unsigned type)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;
    vout_window_t *window;
    vout_window_cfg_t cfg = {
        .type = type,
        .width = vd->cfg->display.width,
        .height = vd->cfg->display.height,
        .is_standalone = true,
    };

    window = vout_display_window_New(osys->vout, &cfg);
    if (window != NULL)
        vout_display_window_Attach(window, vd);
    return window;
}",1275.0,1290.0,1.0,1.0,16.0,19,6,19,10,0,3,2,2,0,2,,0,2,4,2,2,vout_window_t
3547,190212,SplitterDelWindow,1,SplitterDelWindow,"void SplitterDelWindow (vout_display_t*,vout_window_t*)",video_output\display.c,"static void SplitterDelWindow(vout_display_t *vd, vout_window_t *window)
{
    if (window != NULL) {
        vout_display_window_Detach(window);
        vout_display_window_Delete(window);
    }
    (void) vd;
}",1292.0,1299.0,1.0,1.0,8.0,2,2,5,3,0,2,2,2,0,2,,0,0,4,2,2,void
3548,190230,SplitterEvent,1,SplitterEvent,"void SplitterEvent (vout_display_t*,int,va_list)",video_output\display.c,"static void SplitterEvent(vout_display_t *vd, int event, va_list args)
{
    //vout_display_owner_sys_t *osys = vd->owner.sys;

    switch (event) {
#if 0
    case VOUT_DISPLAY_EVENT_MOUSE_STATE:
    case VOUT_DISPLAY_EVENT_MOUSE_MOVED:
    case VOUT_DISPLAY_EVENT_MOUSE_PRESSED:
    case VOUT_DISPLAY_EVENT_MOUSE_RELEASED:
        /* TODO */
        break;
#endif
    case VOUT_DISPLAY_EVENT_MOUSE_DOUBLE_CLICK:
    case VOUT_DISPLAY_EVENT_KEY:
    case VOUT_DISPLAY_EVENT_CLOSE:
    case VOUT_DISPLAY_EVENT_DISPLAY_SIZE:
    case VOUT_DISPLAY_EVENT_PICTURES_INVALID:
        VoutDisplayEvent(vd, event, args);
        break;

    default:
        msg_Err(vd, ""splitter event not implemented: %d"", event);
        break;
    }
}",1301.0,1326.0,1.0,1.0,26.0,0,0,11,8,0,1,4,2,0,1,,0,0,6,3,3,void
3549,190261,SplitterPool,1,SplitterPool,"picture_pool_t SplitterPool (vout_display_t*,unsigned)",video_output\display.c,"static picture_pool_t *SplitterPool(vout_display_t *vd, unsigned count)
{
    vout_display_sys_t *sys = vd->sys;
    if (!sys->pool)
        sys->pool = picture_pool_NewFromFormat(&vd->fmt, count);
    return sys->pool;
}",1328.0,1334.0,1.0,1.0,7.0,9,4,7,3,0,4,2,2,1,1,,0,4,4,2,2,picture_pool_t
3550,190293,SplitterPrepare,1,SplitterPrepare,"void SplitterPrepare (vout_display_t*,picture_t*,subpicture_t*)",video_output\display.c,"static void SplitterPrepare(vout_display_t *vd,
                            picture_t *picture,
                            subpicture_t *subpicture)
{
    vout_display_sys_t *sys = vd->sys;

    picture_Hold(picture);
    assert(!subpicture);

    if (video_splitter_Filter(sys->splitter, sys->picture, picture)) {
        for (int i = 0; i < sys->count; i++)
            sys->picture[i] = NULL;
        return;
    }

    for (int i = 0; i < sys->count; i++) {
        sys->picture[i] = vout_FilterDisplay(sys->display[i], sys->picture[i]);
        if (sys->picture[i])
            vout_display_Prepare(sys->display[i], sys->picture[i], NULL);
    }
}",1335.0,1355.0,1.0,1.0,21.0,24,5,26,6,0,12,5,7,5,2,,0,11,6,3,3,void
3551,190392,SplitterDisplay,1,SplitterDisplay,"void SplitterDisplay (vout_display_t*,picture_t*,subpicture_t*)",video_output\display.c,"static void SplitterDisplay(vout_display_t *vd,
                            picture_t *picture,
                            subpicture_t *subpicture)
{
    vout_display_sys_t *sys = vd->sys;

    assert(!subpicture);
    for (int i = 0; i < sys->count; i++) {
        if (sys->picture[i])
            vout_display_Display(sys->display[i], sys->picture[i], NULL);
    }
    picture_Release(picture);
}",1356.0,1368.0,1.0,1.0,13.0,12,5,14,6,0,5,3,4,2,1,,0,4,6,3,3,void
3552,190443,SplitterControl,1,SplitterControl,"int SplitterControl (vout_display_t*,int,va_list)",video_output\display.c,"static int SplitterControl(vout_display_t *vd, int query, va_list args)
{
    (void)vd; (void)query; (void)args;
    return VLC_EGENERIC;
}",1369.0,1373.0,1.0,1.0,5.0,3,1,4,4,0,0,1,1,0,0,,0,0,6,3,3,int
3553,190461,SplitterManage,1,SplitterManage,void SplitterManage (vout_display_t*),video_output\display.c,"static void SplitterManage(vout_display_t *vd)
{
    vout_display_sys_t *sys = vd->sys;

    for (int i = 0; i < sys->count; i++)
        vout_ManageDisplay(sys->display[i], true);
}",1374.0,1380.0,1.0,1.0,7.0,5,3,5,3,0,1,2,2,1,0,,0,1,2,1,1,void
3554,190492,SplitterPictureNew,1,SplitterPictureNew,"int SplitterPictureNew (video_splitter_t*,picture_t[]*)",video_output\display.c,"static int SplitterPictureNew(video_splitter_t *splitter, picture_t *picture[])
{
    vout_display_sys_t *wsys = splitter->p_owner->wrapper->sys;

    for (int i = 0; i < wsys->count; i++) {
        if (vout_IsDisplayFiltered(wsys->display[i])) {
            /* TODO use a pool ? */
            picture[i] = picture_NewFromFormat(&wsys->display[i]->source);
        } else {
            picture_pool_t *pool = vout_display_Pool(wsys->display[i], 3);
            picture[i] = pool ? picture_pool_Get(pool) : NULL;
        }
        if (!picture[i]) {
            for (int j = 0; j < i; j++)
                picture_Release(picture[j]);
            return VLC_EGENERIC;
        }
    }
    return VLC_SUCCESS;
}",1382.0,1401.0,1.0,1.0,20.0,19,6,18,7,0,5,5,9,3,2,,0,5,4,2,2,int
3555,190589,SplitterPictureDel,1,SplitterPictureDel,"void SplitterPictureDel (video_splitter_t*,picture_t[]*)",video_output\display.c,"static void SplitterPictureDel(video_splitter_t *splitter, picture_t *picture[])
{
    vout_display_sys_t *wsys = splitter->p_owner->wrapper->sys;

    for (int i = 0; i < wsys->count; i++)
        picture_Release(picture[i]);
}",1402.0,1408.0,1.0,1.0,7.0,7,3,5,3,0,1,2,2,1,0,,0,1,4,2,2,void
3556,190687,vout_NewSplitter,1,vout_NewSplitter,"vout_display_t vout_NewSplitter (vout_thread_t*,video_format_t*,vout_display_state_t*,char*,char*,mtime_t,mtime_t)",video_output\display.c,"vout_display_t *vout_NewSplitter(vout_thread_t *vout,
                                 const video_format_t *source,
                                 const vout_display_state_t *state,
                                 const char *module,
                                 const char *splitter_module,
                                 mtime_t double_click_timeout,
                                 mtime_t hide_timeout)
{
    video_splitter_t *splitter =
        video_splitter_New(VLC_OBJECT(vout), splitter_module, source);
    if (!splitter)
        return NULL;

    /* */
    vout_display_t *wrapper =
        DisplayNew(vout, source, state, module, true,
                    double_click_timeout, hide_timeout, NULL);
    if (!wrapper) {
        video_splitter_Delete(splitter);
        return NULL;
    }
    vout_display_sys_t *sys = malloc(sizeof(*sys));
    if (!sys)
        abort();
    sys->picture = calloc(splitter->i_output, sizeof(*sys->picture));
    if (!sys->picture )
        ab...",1430.0,1505.0,1.0,1.0,76.0,94,11,85,22,0,15,7,8,1,5,,0,13,14,7,7,vout_display_t
3557,190981,vout_SendDisplayEventMouse,1,vout_SendDisplayEventMouse,"void vout_SendDisplayEventMouse (vout_thread_t*,vlc_mouse_t*)",video_output\display.c,"void vout_SendDisplayEventMouse(vout_thread_t *vout, const vlc_mouse_t *m)
{
    vlc_mouse_t tmp1, tmp2;

    /* The check on spu is needed as long as ALLOW_DUMMY_VOUT is defined */
    if (vout->p->spu && spu_ProcessMouse( vout->p->spu, m, &vout->p->display.vd->source))
        return;

    vlc_mutex_lock( &vout->p->filter.lock );
    if (vout->p->filter.chain_static && vout->p->filter.chain_interactive) {
        if (!filter_chain_MouseFilter(vout->p->filter.chain_interactive, &tmp1, m))
            m = &tmp1;
        if (!filter_chain_MouseFilter(vout->p->filter.chain_static,      &tmp2, m))
            m = &tmp2;
    }
    vlc_mutex_unlock( &vout->p->filter.lock );

    if (vlc_mouse_HasMoved(&vout->p->mouse, m)) {
        vout_SendEventMouseMoved(vout, m->i_x, m->i_y);
    }
    if (vlc_mouse_HasButton(&vout->p->mouse, m)) {
        for (unsigned button = 0; button < MOUSE_BUTTON_MAX; button++) {
            if (vlc_mouse_HasPressed(&vout->p->mouse, m, button))
                ...",1511.0,1542.0,1.0,1.0,32.0,57,8,37,6,1,8,10,15,3,8,,0,3,4,2,2,void
3558,191195,vout_NewDisplayWindow,1,vout_NewDisplayWindow,"vout_window_t* vout_NewDisplayWindow (vout_thread_t*,unsigned)",video_output\video_output.c,"vout_window_t *vout_NewDisplayWindow(vout_thread_t *vout, unsigned type)
{
    vout_window_t *window = vout->p->window;

    assert(vout->p->splitter_name == NULL);

    if (window == NULL)
        return NULL;
    if (type != VOUT_WINDOW_TYPE_INVALID && type != window->type)
        return NULL;
    return window;
}",611.0,622.0,1.0,1.0,12.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,vout_window_t
3559,191201,vout_DeleteDisplayWindow,1,vout_DeleteDisplayWindow,"void vout_DeleteDisplayWindow (vout_thread_t*,vout_window_t*)",video_output\video_output.c,"void vout_DeleteDisplayWindow(vout_thread_t *vout, vout_window_t *window)
{
    if (window == NULL && vout->p->window != NULL) {
        vout_display_window_Delete(vout->p->window);
        vout->p->window = NULL;
    }
    assert(vout->p->window == window);
}",624.0,631.0,1.0,1.0,8.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
3560,191207,vout_SetDisplayWindowSize,1,vout_SetDisplayWindowSize,"void vout_SetDisplayWindowSize (vout_thread_t*,unsigned,unsigned)",video_output\video_output.c,"void vout_SetDisplayWindowSize(vout_thread_t *vout,
                               unsigned width, unsigned height)
{
    vout_window_t *window = vout->p->window;

    if (window != NULL)
    /* Request a resize of the window. If it fails, there is nothing to do.
     * If it succeeds, the window will emit a resize event later. */
        vout_window_SetSize(window, width, height);
    else
    if (vout->p->display.vd != NULL)
    /* Force a resize of window-less display. This is not allowed to fail,
     * although the display is allowed to ignore the size anyway. */
        /* FIXME: remove this, fix MSW and OS/2 window providers */
        vout_display_SendEventDisplaySize(vout->p->display.vd, width, height);
}",633.0,648.0,1.0,1.0,16.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
3561,191214,vout_HideWindowMouse,1,vout_HideWindowMouse,"int vout_HideWindowMouse (vout_thread_t*,ANY)",video_output\video_output.c,"int vout_HideWindowMouse(vout_thread_t *vout, bool hide)
{
    vout_window_t *window = vout->p->window;

    return window != NULL ? vout_window_HideMouse(window, hide) : VLC_EGENERIC;
}",650.0,655.0,1.0,1.0,6.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
3562,191237,vout_SendEventClose,1,vout_SendEventClose,void vout_SendEventClose (vout_thread_t*),video_output\event.h,"static inline void vout_SendEventClose(vout_thread_t *vout)
{
#warning FIXME: implement video close event
    /* FIXME: this code is disabled as it breaks the non-playlist cases */
    //playlist_Stop(pl_Get(vout));
    (void) vout;
}",40.0,46.0,1.0,1.0,7.0,1,1,1,1,2,0,1,1,0,0,,0,0,2,1,1,void
3563,191245,vout_SendEventKey,1,vout_SendEventKey,"void vout_SendEventKey (vout_thread_t*,int)",video_output\event.h,"static inline void vout_SendEventKey(vout_thread_t *vout, int key)
{
    var_SetInteger(vout->obj.libvlc, ""key-pressed"", key);
}",47.0,50.0,1.0,1.0,4.0,2,2,2,2,2,0,1,1,0,0,,0,0,4,2,2,void
3564,191259,vout_SendEventMouseMoved,1,vout_SendEventMouseMoved,"void vout_SendEventMouseMoved (vout_thread_t*,int,int)",video_output\event.h,"static inline void vout_SendEventMouseMoved(vout_thread_t *vout, int x, int y)
{
    var_SetCoords(vout, ""mouse-moved"", x, y);
}",51.0,54.0,1.0,1.0,4.0,0,0,3,3,1,0,1,1,0,0,,0,0,6,3,3,void
3565,191271,vout_SendEventViewpointMoved,1,vout_SendEventViewpointMoved,"void vout_SendEventViewpointMoved (vout_thread_t*,vlc_viewpoint_t*)",video_output\event.h,"static inline void vout_SendEventViewpointMoved(vout_thread_t *vout,
                                                const vlc_viewpoint_t *p_viewpoint)
{
    var_SetAddress(vout, ""viewpoint-moved"", (void *) p_viewpoint);
    /* This variable can only be read from callbacks */
    var_Change(vout, ""viewpoint-moved"", VLC_VAR_SETVALUE,
               &(vlc_value_t) { .p_address = NULL }, NULL);
}",55.0,62.0,1.0,1.0,8.0,5,4,7,5,0,1,1,1,0,1,,0,0,4,2,2,void
3566,191296,vout_SendEventMousePressed,1,vout_SendEventMousePressed,"void vout_SendEventMousePressed (vout_thread_t*,int)",video_output\event.h,"static inline void vout_SendEventMousePressed(vout_thread_t *vout, int button)
{
    int key = KEY_UNSET;
    var_OrInteger(vout, ""mouse-button-down"", 1 << button);

    switch (button)
    {
    case MOUSE_BUTTON_LEFT:
    {
        /* FIXME? */
        int x, y;
        var_GetCoords(vout, ""mouse-moved"", &x, &y);
        var_SetCoords(vout, ""mouse-clicked"", x, y);
        var_SetBool(vout->obj.libvlc, ""intf-popupmenu"", false);
        return;
    }
    case MOUSE_BUTTON_CENTER:
        var_ToggleBool(vout->obj.libvlc, ""intf-toggle-fscontrol"");
        return;
    case MOUSE_BUTTON_RIGHT:
#if !defined(_WIN32)
        var_SetBool(vout->obj.libvlc, ""intf-popupmenu"", true);
#endif
        return;
    case MOUSE_BUTTON_WHEEL_UP:    key = KEY_MOUSEWHEELUP;    break;
    case MOUSE_BUTTON_WHEEL_DOWN:  key = KEY_MOUSEWHEELDOWN;  break;
    case MOUSE_BUTTON_WHEEL_LEFT:  key = KEY_MOUSEWHEELLEFT;  break;
    case MOUSE_BUTTON_WHEEL_RIGHT: key = KEY_MOUSEWHEELRIGHT; break;
    }
    vout_Se...",63.0,93.0,1.0,1.0,31.0,14,5,33,19,1,1,6,2,0,1,,0,0,4,2,2,void
3567,191389,vout_SendEventMouseReleased,1,vout_SendEventMouseReleased,"void vout_SendEventMouseReleased (vout_thread_t*,int)",video_output\event.h,"static inline void vout_SendEventMouseReleased(vout_thread_t *vout, int button)
{
    var_NAndInteger(vout, ""mouse-button-down"", 1 << button);
#if defined(_WIN32)
    switch (button)
    {
    case MOUSE_BUTTON_RIGHT:
        var_SetBool(vout->obj.libvlc, ""intf-popupmenu"", true);
        return;
    }
#endif
}",94.0,105.0,1.0,1.0,12.0,1,1,2,2,0,0,1,1,0,0,,0,0,4,2,2,void
3568,191401,vout_SendEventMouseDoubleClick,1,vout_SendEventMouseDoubleClick,void vout_SendEventMouseDoubleClick (vout_thread_t*),video_output\event.h,"static inline void vout_SendEventMouseDoubleClick(vout_thread_t *vout)
{
    //vout_ControlSetFullscreen(vout, !var_GetBool(vout, ""fullscreen""));
    var_ToggleBool(vout, ""fullscreen"");
}",106.0,110.0,1.0,1.0,5.0,0,0,1,1,1,0,1,1,0,0,,0,0,2,1,1,void
3569,191409,vout_SendEventViewpointChangeable,1,vout_SendEventViewpointChangeable,"void vout_SendEventViewpointChangeable (vout_thread_t*,bool)",video_output\event.h,"static inline void vout_SendEventViewpointChangeable(vout_thread_t *vout,
                                                     bool b_can_change)
{
    var_SetBool(vout, ""viewpoint-changeable"", b_can_change);
}",111.0,115.0,1.0,1.0,5.0,0,0,2,2,1,0,1,1,0,0,,0,0,4,2,2,void
3570,191440,vlc_inhibit_Create,1,vlc_inhibit_Create,vlc_inhibit_t vlc_inhibit_Create (vlc_object_t*),video_output\inhibit.c,"vlc_inhibit_t *vlc_inhibit_Create (vlc_object_t *parent)
{
    inhibit_t *priv = vlc_custom_create (parent, sizeof (*priv), ""inhibit"" );
    if (priv == NULL)
        return NULL;

    vlc_inhibit_t *ih = &priv->ih;
    ih->p_sys = NULL;
    ih->inhibit = NULL;

    priv->module = module_need (ih, ""inhibit"", NULL, false);
    if (priv->module == NULL)
    {
        vlc_object_release (ih);
        ih = NULL;
    }
    return ih;
}",37.0,54.0,1.0,1.0,18.0,16,6,22,5,1,6,3,3,1,3,,0,5,2,1,1,vlc_inhibit_t
3571,191501,vlc_inhibit_Destroy,1,vlc_inhibit_Destroy,void vlc_inhibit_Destroy (vlc_inhibit_t*),video_output\inhibit.c,"void vlc_inhibit_Destroy (vlc_inhibit_t *ih)
{
    assert (ih != NULL);

    module_unneed (ih, ((inhibit_t *)ih)->module);
    vlc_object_release (ih);
}",56.0,62.0,1.0,1.0,7.0,3,3,5,2,1,2,1,1,0,2,,0,0,2,1,1,void
3572,191568,DeinterlaceIsModeValid,1,DeinterlaceIsModeValid,bool DeinterlaceIsModeValid (char*),video_output\interlacing.c,"static bool DeinterlaceIsModeValid(const char *mode)
{
    for (unsigned i = 0; i < ARRAY_SIZE(deinterlace_modes); i++) {
        if (!strcmp(deinterlace_modes[i], mode))
            return true;
    }
    return false;
}",56.0,63.0,1.0,1.0,8.0,4,4,8,5,2,2,3,4,2,0,,0,2,2,1,1,bool
3573,191598,DeinterlaceCallback,1,DeinterlaceCallback,"int DeinterlaceCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",video_output\interlacing.c,"static int DeinterlaceCallback(vlc_object_t *object, char const *cmd,
                               vlc_value_t oldval, vlc_value_t newval, void *data)
{
    VLC_UNUSED(cmd); VLC_UNUSED(oldval); VLC_UNUSED(newval); VLC_UNUSED(data);
    vout_thread_t *vout = (vout_thread_t *)object;

    /* */
    const int  deinterlace_state = var_GetInteger(vout, ""deinterlace"");
    char       *mode             = var_GetString(vout,  ""deinterlace-mode"");
    const bool is_needed         = var_GetBool(vout,    ""deinterlace-needed"");
    if (!mode || !DeinterlaceIsModeValid(mode))
    {
        free(mode);
        return VLC_EGENERIC;
    }

    /* */
    char *old = var_CreateGetString(vout, ""sout-deinterlace-mode"");
    var_SetString(vout, ""sout-deinterlace-mode"", mode);

    msg_Dbg(vout, ""deinterlace %d, mode %s, is_needed %d"", deinterlace_state, mode, is_needed);
    if (deinterlace_state == 0 || (deinterlace_state < 0 && !is_needed))
        vout_control_PushBool(&vout->p->control,
          ...",65.0,97.0,1.0,1.0,33.0,17,9,33,14,0,2,3,3,1,2,,0,1,10,5,5,int
3574,191705,vout_InitInterlacingSupport,1,vout_InitInterlacingSupport,"void vout_InitInterlacingSupport (vout_thread_t*,bool)",video_output\interlacing.c,"void vout_InitInterlacingSupport(vout_thread_t *vout, bool is_interlaced)
{
    vlc_value_t val, text;

    msg_Dbg(vout, ""Deinterlacing available"");

    vout->p->filter.has_deint = false;

    /* Create the configuration variables */
    /* */
    var_Create(vout, ""deinterlace"", VLC_VAR_INTEGER | VLC_VAR_DOINHERIT );
    int deinterlace_state = var_GetInteger(vout, ""deinterlace"");

    text.psz_string = _(""Deinterlace"");
    var_Change(vout, ""deinterlace"", VLC_VAR_SETTEXT, &text, NULL);

    const module_config_t *optd = config_FindConfig(""deinterlace"");
    var_Change(vout, ""deinterlace"", VLC_VAR_CLEARCHOICES, NULL, NULL);
    if (likely(optd != NULL))
        for (unsigned i = 0; i < optd->list_count; i++) {
            val.i_int = optd->list.i[i];
            text.psz_string = vlc_gettext(optd->list_text[i]);
            var_Change(vout, ""deinterlace"", VLC_VAR_ADDCHOICE, &val, &text);
        }
    var_AddCallback(vout, ""deinterlace"", DeinterlaceCallback, NULL);
    /* */
    v...",99.0,170.0,1.0,1.0,72.0,75,11,104,20,1,20,10,13,1,20,,0,6,4,2,2,void
3575,192015,vout_ReinitInterlacingSupport,1,vout_ReinitInterlacingSupport,void vout_ReinitInterlacingSupport (vout_thread_t*),video_output\interlacing.c,"void vout_ReinitInterlacingSupport(vout_thread_t *vout)
{
    vout->p->interlacing.is_interlaced = false;
    var_SetBool(vout, ""deinterlace-needed"", false);
}",172.0,176.0,1.0,1.0,5.0,4,3,4,2,1,0,1,1,0,0,,0,0,2,1,1,void
3576,192033,vout_SetInterlacingState,1,vout_SetInterlacingState,"void vout_SetInterlacingState (vout_thread_t*,bool)",video_output\interlacing.c,"void vout_SetInterlacingState(vout_thread_t *vout, bool is_interlaced)
{
     /* Wait 30s before quiting interlacing mode */
    const int interlacing_change = (!!is_interlaced)
                                 - (!!vout->p->interlacing.is_interlaced);
    if (interlacing_change == 1 ||
        (interlacing_change == -1 &&
        vout->p->interlacing.date + 30000000 < mdate()))
    {
        msg_Dbg(vout, ""Detected %s video"",
                 is_interlaced ? ""interlaced"" : ""progressive"");
        var_SetBool(vout, ""deinterlace-needed"", is_interlaced);
        vout->p->interlacing.is_interlaced = is_interlaced;
    }
    if (is_interlaced)
        vout->p->interlacing.date = mdate();
}",178.0,194.0,1.0,1.0,17.0,28,12,14,3,0,2,3,3,1,2,,0,2,4,2,2,void
3577,192157,vlc_gl_Create,1,vlc_gl_Create,"vlc_gl_t vlc_gl_Create (vout_window_t*,unsigned,char*)",video_output\opengl.c,"vlc_gl_t *vlc_gl_Create(struct vout_window_t *wnd, unsigned flags,
                        const char *name)
{
    vlc_object_t *parent = (vlc_object_t *)wnd;
    struct vlc_gl_priv_t *glpriv;
    const char *type;

    switch (flags /*& VLC_OPENGL_API_MASK*/)
    {
        case VLC_OPENGL:
            type = ""opengl"";
            break;
        case VLC_OPENGL_ES2:
            type = ""opengl es2"";
            break;
        default:
            return NULL;
    }

    glpriv = vlc_custom_create(parent, sizeof (*glpriv), ""gl"");
    if (unlikely(glpriv == NULL))
        return NULL;

    glpriv->gl.surface = wnd;
    glpriv->gl.module = module_need(&glpriv->gl, type, name, true);
    if (glpriv->gl.module == NULL)
    {
        vlc_object_release(&glpriv->gl);
        return NULL;
    }
    atomic_init(&glpriv->ref_count, 1);

    return &glpriv->gl;
}",50.0,83.0,1.0,13.0,34.0,25,8,28,10,1,10,6,4,1,3,,0,9,6,3,3,vlc_gl_t
3578,192259,vlc_gl_Hold,1,vlc_gl_Hold,void vlc_gl_Hold (vlc_gl_t*),video_output\opengl.c,"void vlc_gl_Hold(vlc_gl_t *gl)
{
    struct vlc_gl_priv_t *glpriv = (struct vlc_gl_priv_t *)gl;
    atomic_fetch_add(&glpriv->ref_count, 1);
}",85.0,89.0,1.0,1.0,5.0,4,4,3,2,0,1,1,1,0,0,,0,1,2,1,1,void
3579,192276,vlc_gl_Release,1,vlc_gl_Release,void vlc_gl_Release (vlc_gl_t*),video_output\opengl.c,"void vlc_gl_Release(vlc_gl_t *gl)
{
    struct vlc_gl_priv_t *glpriv = (struct vlc_gl_priv_t *)gl;
    if (atomic_fetch_sub(&glpriv->ref_count, 1) != 1)
        return;
    module_unneed(gl, gl->module);
    vlc_object_release(gl);
}",91.0,98.0,1.0,1.0,8.0,6,5,6,2,1,3,2,2,1,2,,0,1,2,1,1,void
3580,192310,vlc_gl_surface_ResizeNotify,1,vlc_gl_surface_ResizeNotify,"void vlc_gl_surface_ResizeNotify (vout_window_t*,unsigned,unsigned)",video_output\opengl.c,"static void vlc_gl_surface_ResizeNotify(vout_window_t *surface,
                                        unsigned width, unsigned height)
{
    vlc_gl_surface_t *sys = surface->owner.sys;

    msg_Dbg(surface, ""resized to %ux%u"", width, height);

    vlc_mutex_lock(&sys->lock);
    sys->width = width;
    sys->height = height;
    vlc_mutex_unlock(&sys->lock);
}",109.0,120.0,1.0,1.0,12.0,11,4,11,4,0,2,1,1,0,2,,0,0,6,3,3,void
3581,192350,vlc_gl_surface_Create,1,vlc_gl_surface_Create,"vlc_gl_t vlc_gl_surface_Create (vlc_object_t*,vout_window_cfg_t*,vout_window_t**)",video_output\opengl.c,"vlc_gl_t *vlc_gl_surface_Create(vlc_object_t *obj,
                                const vout_window_cfg_t *cfg,
                                struct vout_window_t **restrict wp)
{
    vlc_gl_surface_t *sys = malloc(sizeof (*sys));
    if (unlikely(sys == NULL))
        return NULL;

    sys->width = cfg->width;
    sys->height = cfg->height;
    vlc_mutex_init(&sys->lock);

    vout_window_owner_t owner = {
        .sys = sys,
        .resized = vlc_gl_surface_ResizeNotify,
    };

    vout_window_t *surface = vout_window_New(obj, ""$window"", cfg, &owner);
    if (surface == NULL)
        goto error;
    if (wp != NULL)
        *wp = surface;

    /* TODO: support ES? */
    vlc_gl_t *gl = vlc_gl_Create(surface, VLC_OPENGL, NULL);
    if (gl == NULL) {
        vout_window_Delete(surface);
        return NULL;
    }

    vlc_gl_Resize(gl, cfg->width, cfg->height);
    return gl;

error:
    vlc_mutex_destroy(&sys->lock);
    free(sys);
    return NULL;
}",122.0,159.0,1.0,1.0,38.0,28,8,39,10,0,5,6,5,0,5,,0,2,6,3,3,vlc_gl_t
3582,192463,vlc_gl_surface_CheckSize,1,vlc_gl_surface_CheckSize,"bool vlc_gl_surface_CheckSize (vlc_gl_t*,unsigned*,unsigned*)",video_output\opengl.c,"bool vlc_gl_surface_CheckSize(vlc_gl_t *gl, unsigned *restrict width,
                              unsigned *restrict height)
{
    vout_window_t *surface = gl->surface;
    vlc_gl_surface_t *sys = surface->owner.sys;
    bool ret = false;

    vlc_mutex_lock(&sys->lock);
    if (sys->width >= 0 && sys->height >= 0)
    {
        *width = sys->width;
        *height = sys->height;
        sys->width = -1;
        sys->height = -1;

        vlc_gl_Resize(gl, *width, *height);
        ret = true;
    }
    vlc_mutex_unlock(&sys->lock);
    return ret;
}",169.0,189.0,1.0,1.0,21.0,30,8,22,8,0,2,2,2,0,2,,0,0,6,3,3,bool
3583,192546,vlc_gl_surface_Destroy,1,vlc_gl_surface_Destroy,void vlc_gl_surface_Destroy (vlc_gl_t*),video_output\opengl.c,"void vlc_gl_surface_Destroy(vlc_gl_t *gl)
{
    vout_window_t *surface = gl->surface;
    vlc_gl_surface_t *sys = surface->owner.sys;

    vlc_gl_Release(gl);
    vout_window_Delete(surface);
    vlc_mutex_destroy(&sys->lock);
    free(sys);
}",191.0,200.0,1.0,1.0,10.0,7,4,8,3,0,3,1,1,0,3,,0,0,2,1,1,void
3584,192607,vout_snapshot_Init,1,vout_snapshot_Init,void vout_snapshot_Init (vout_snapshot_t*),video_output\snapshot.c,"void vout_snapshot_Init(vout_snapshot_t *snap)
{
    vlc_mutex_init(&snap->lock);
    vlc_cond_init(&snap->wait);

    snap->is_available = true;
    snap->request_count = 0;
    snap->picture = NULL;
}",45.0,53.0,1.0,1.0,9.0,10,3,7,3,1,7,1,1,0,2,,0,5,2,1,1,void
3585,192637,vout_snapshot_Clean,1,vout_snapshot_Clean,void vout_snapshot_Clean (vout_snapshot_t*),video_output\snapshot.c,"void vout_snapshot_Clean(vout_snapshot_t *snap)
{
    picture_t *picture = snap->picture;
    while (picture) {
        picture_t *next = picture->p_next;
        picture_Release(picture);
        picture = next;
    }

    vlc_cond_destroy(&snap->wait);
    vlc_mutex_destroy(&snap->lock);
}",54.0,65.0,1.0,1.0,12.0,9,3,10,3,0,6,2,2,0,3,,0,3,2,1,1,void
3586,192672,vout_snapshot_End,1,vout_snapshot_End,void vout_snapshot_End (vout_snapshot_t*),video_output\snapshot.c,"void vout_snapshot_End(vout_snapshot_t *snap)
{
    vlc_mutex_lock(&snap->lock);

    snap->is_available = false;

    vlc_cond_broadcast(&snap->wait);
    vlc_mutex_unlock(&snap->lock);
}",67.0,75.0,1.0,1.0,9.0,8,3,5,2,1,7,1,1,0,3,,0,4,2,1,1,void
3587,192697,vout_snapshot_Get,1,vout_snapshot_Get,"picture_t vout_snapshot_Get (vout_snapshot_t*,mtime_t)",video_output\snapshot.c,"picture_t *vout_snapshot_Get(vout_snapshot_t *snap, mtime_t timeout)
{
    const mtime_t deadline = mdate() + timeout;

    vlc_mutex_lock(&snap->lock);

    /* */
    snap->request_count++;

    /* */
    while (snap->is_available && !snap->picture &&
        vlc_cond_timedwait(&snap->wait, &snap->lock, deadline) == 0);

    /* */
    picture_t *picture = snap->picture;
    if (picture)
        snap->picture = picture->p_next;
    else if (snap->request_count > 0)
        snap->request_count--;

    vlc_mutex_unlock(&snap->lock);

    return picture;
}",78.0,101.0,1.0,1.0,24.0,23,8,16,4,1,13,3,3,5,4,,0,11,4,2,2,picture_t
3588,192776,vout_snapshot_IsRequested,1,vout_snapshot_IsRequested,bool vout_snapshot_IsRequested (vout_snapshot_t*),video_output\snapshot.c,"bool vout_snapshot_IsRequested(vout_snapshot_t *snap)
{
    bool has_request = false;
    if (!vlc_mutex_trylock(&snap->lock)) {
        has_request = snap->request_count > 0;
        vlc_mutex_unlock(&snap->lock);
    }
    return has_request;
}",104.0,112.0,1.0,1.0,9.0,9,5,7,3,1,5,2,2,2,2,,0,4,2,1,1,bool
3589,192807,vout_snapshot_Set,1,vout_snapshot_Set,"void vout_snapshot_Set (vout_snapshot_t*,video_format_t*,picture_t*)",video_output\snapshot.c,"void vout_snapshot_Set(vout_snapshot_t *snap,
                       const video_format_t *fmt,
                       picture_t *picture)
{
    if (!fmt)
        fmt = &picture->format;

    vlc_mutex_lock(&snap->lock);
    while (snap->request_count > 0) {
        picture_t *dup = picture_Clone(picture);
        if (!dup)
            break;

        video_format_CopyCrop( &dup->format, fmt );

        dup->p_next = snap->picture;
        snap->picture = dup;
        snap->request_count--;
    }
    vlc_cond_broadcast(&snap->wait);
    vlc_mutex_unlock(&snap->lock);
}",113.0,134.0,1.0,1.0,22.0,23,6,17,4,1,12,5,5,1,5,,0,8,6,3,3,void
3590,192878,vout_snapshot_GetDirectory,1,vout_snapshot_GetDirectory,char* vout_snapshot_GetDirectory (void),video_output\snapshot.c,"char *vout_snapshot_GetDirectory(void)
{
    return config_GetUserDir(VLC_PICTURES_DIR);
}",136.0,139.0,1.0,1.0,4.0,0,0,1,1,1,1,1,1,0,1,,0,0,2,1,1,char*
3591,192886,vout_snapshot_SaveImage,1,vout_snapshot_SaveImage,"int vout_snapshot_SaveImage (char**,int*,block_t*,vout_thread_t*,vout_snapshot_save_cfg_t*)",video_output\snapshot.c,"int vout_snapshot_SaveImage(char **name, int *sequential,
                             const block_t *image,
                             vout_thread_t *p_vout,
                             const vout_snapshot_save_cfg_t *cfg)
{
    /* */
    char *filename;
    input_thread_t *input = (input_thread_t*)p_vout->p->input;

    /* */
    char *prefix = NULL;
    if (cfg->prefix_fmt)
        prefix = str_format(input, cfg->prefix_fmt);
    if (prefix)
        filename_sanitize(prefix);
    else {
        prefix = strdup(""vlcsnap-"");
        if (prefix == NULL)
            goto error;
    }

    struct stat st;
    bool b_is_folder = false;

    if ( vlc_stat( cfg->path, &st ) == 0 )
        b_is_folder = S_ISDIR( st.st_mode );
    if ( b_is_folder ) {
        if (cfg->is_sequential) {
            for (int num = cfg->sequence; ; num++) {
                if (asprintf(&filename, ""%s"" DIR_SEP ""%s%05d.%s"",
                             cfg->path, prefix, num, cfg->format) < 0) {
             ...",141.0,232.0,1.0,1.0,92.0,29,10,49,16,1,9,18,22,5,4,,0,8,10,5,5,int
3592,193199,vout_statistic_Init,1,vout_statistic_Init,void vout_statistic_Init (vout_statistic_t*),video_output\statistic.h,"static inline void vout_statistic_Init(vout_statistic_t *stat)
{
    atomic_init(&stat->displayed, 0);
    atomic_init(&stat->lost, 0);
}",36.0,40.0,1.0,1.0,5.0,4,2,2,1,1,2,1,1,0,0,,0,2,2,1,1,void
3593,193216,vout_statistic_Clean,1,vout_statistic_Clean,void vout_statistic_Clean (vout_statistic_t*),video_output\statistic.h,"static inline void vout_statistic_Clean(vout_statistic_t *stat)
{
    (void) stat;
}",42.0,45.0,1.0,1.0,4.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
3594,193224,vout_statistic_GetReset,1,vout_statistic_GetReset,"void vout_statistic_GetReset (vout_statistic_t*,unsigned*,unsigned*)",video_output\statistic.h,"static inline void vout_statistic_GetReset(vout_statistic_t *stat,
                                           unsigned *restrict displayed,
                                           unsigned *restrict lost)
{
    *displayed = atomic_exchange(&stat->displayed, 0);
    *lost      = atomic_exchange(&stat->lost, 0);
}",47.0,53.0,1.0,1.0,7.0,8,4,4,3,1,2,1,1,0,0,,0,2,6,3,3,void
3595,193249,vout_statistic_AddDisplayed,1,vout_statistic_AddDisplayed,"void vout_statistic_AddDisplayed (vout_statistic_t*,int)",video_output\statistic.h,"static inline void vout_statistic_AddDisplayed(vout_statistic_t *stat,
                                               int displayed)
{
    atomic_fetch_add(&stat->displayed, displayed);
}",55.0,59.0,1.0,1.0,5.0,2,2,2,2,1,1,1,1,0,0,,0,1,4,2,2,void
3596,193261,vout_statistic_AddLost,1,vout_statistic_AddLost,"void vout_statistic_AddLost (vout_statistic_t*,int)",video_output\statistic.h,"static inline void vout_statistic_AddLost(vout_statistic_t *stat, int lost)
{
    atomic_fetch_add(&stat->lost, lost);
}",61.0,64.0,1.0,1.0,4.0,2,2,2,2,0,1,1,1,0,0,,0,1,4,2,2,void
3597,193303,GetDefaultArtUri,1,GetDefaultArtUri,char* GetDefaultArtUri (void),video_output\video_epg.c,"static char * GetDefaultArtUri( void )
{
    char *psz_uri = NULL;
    char *psz_path;
    char *psz_datadir = config_GetDataDir();
    if( asprintf( &psz_path, ""%s/icons/128x128/vlc.png"", psz_datadir ) >= 0 )
    {
        psz_uri = vlc_path2uri( psz_path, NULL );
        free( psz_path );
    }
    free( psz_datadir );
    return psz_uri;
}",77.0,89.0,1.0,1.0,13.0,5,3,11,4,1,2,2,2,0,2,,0,2,2,1,1,char*
3598,193337,vout_OSDBackground,1,vout_OSDBackground,"subpicture_region_t vout_OSDBackground (int,int,int,int,uint32_t)",video_output\video_epg.c,"static subpicture_region_t * vout_OSDBackground(int x, int y,
                                                int width, int height,
                                                uint32_t i_argb)
{
    /* Create a new subpicture region */
    video_palette_t palette;
    spuregion_CreateVGradientPalette( &palette, GRADIENT_COLORS, i_argb, 0xFF000000 );

    video_format_t fmt;
    video_format_Init(&fmt, VLC_CODEC_YUVP);
    fmt.i_width  = fmt.i_visible_width  = width;
    fmt.i_height = fmt.i_visible_height = height;
    fmt.i_sar_num = 1;
    fmt.i_sar_den = 1;
    fmt.p_palette = &palette;

    subpicture_region_t *region = subpicture_region_New(&fmt);
    if (!region)
        return NULL;

    region->i_align = SUBPICTURE_ALIGN_LEFT | SUBPICTURE_ALIGN_TOP;
    region->i_x = x;
    region->i_y = y;

    spuregion_CreateVGradientFill( region->p_picture->p, palette.i_entries );

    return region;
}",93.0,120.0,1.0,48.0,28.0,30,6,28,12,2,3,2,2,0,3,,0,1,10,5,5,subpicture_region_t
3599,193434,vout_OSDEpgSlider,1,vout_OSDEpgSlider,"subpicture_region_t vout_OSDEpgSlider (int,int,int,int,float)",video_output\video_epg.c,"static subpicture_region_t * vout_OSDEpgSlider(int x, int y,
                                               int width, int height,
                                               float ratio)
{
    /* Create a new subpicture region */
    video_palette_t palette = {
        .i_entries = 4,
        .palette = {
            [0] = { HEX2YUV(RGB_COLOR1), 0x20 }, /* Bar fill remain/background */
            [1] = { HEX2YUV(0x00ff00), 0xff },
            [2] = { HEX2YUV(RGB_COLOR1), 0xC0 }, /* Bar fill */
            [3] = { HEX2YUV(0xffffff), 0xff }, /* Bar outline */
        },
    };

    video_format_t fmt;
    video_format_Init(&fmt, VLC_CODEC_YUVP);
    fmt.i_width  = fmt.i_visible_width  = width;
    fmt.i_height = fmt.i_visible_height = height;
    fmt.i_sar_num = 1;
    fmt.i_sar_den = 1;
    fmt.p_palette = &palette;

    subpicture_region_t *region = subpicture_region_New(&fmt);
    if (!region)
        return NULL;

    region->i_align = SUBPICTURE_ALIGN_LEFT | SUBPICTURE_ALIGN...",122.0,189.0,1.0,20.0,68.0,226,20,81,20,1,1,7,16,0,1,,0,1,10,5,5,subpicture_region_t
3600,194004,vout_OSDSegmentSetNoWrap,1,vout_OSDSegmentSetNoWrap,void vout_OSDSegmentSetNoWrap (text_segment_t*),video_output\video_epg.c,"static void vout_OSDSegmentSetNoWrap(text_segment_t *p_segment)
{
    for( ; p_segment; p_segment = p_segment->p_next )
    {
        p_segment->style->e_wrapinfo = STYLE_WRAP_NONE;
        p_segment->style->i_features |= STYLE_HAS_WRAP_INFO;
    }
}",191.0,198.0,1.0,1.0,8.0,5,2,5,3,1,0,2,2,0,0,,0,0,2,1,1,void
3601,194032,vout_OSDSegment,1,vout_OSDSegment,"text_segment_t vout_OSDSegment (char*,int,uint32_t)",video_output\video_epg.c,"static text_segment_t * vout_OSDSegment(const char *psz_text, int size, uint32_t color)
{
    text_segment_t *p_segment = text_segment_New(psz_text);
    if(unlikely(!p_segment))
        return NULL;

    /* Set text style */
    p_segment->style = text_style_Create(STYLE_NO_DEFAULTS);
    if (unlikely(!p_segment->style))
    {
        text_segment_Delete(p_segment);
        return NULL;
    }

    p_segment->style->i_font_size  = __MAX(size ,1 );
    p_segment->style->i_font_color = color;
    p_segment->style->i_font_alpha = STYLE_ALPHA_OPAQUE;
    p_segment->style->i_outline_alpha = STYLE_ALPHA_TRANSPARENT;
    p_segment->style->i_shadow_alpha = STYLE_ALPHA_TRANSPARENT;
    p_segment->style->i_features |= STYLE_HAS_FONT_ALPHA | STYLE_HAS_FONT_COLOR |
                                    STYLE_HAS_OUTLINE_ALPHA | STYLE_HAS_SHADOW_ALPHA;

    return p_segment;
}",200.0,223.0,1.0,1.0,24.0,26,4,25,12,3,3,3,3,0,3,,0,2,6,3,3,text_segment_t
3602,194120,vout_OSDImage,1,vout_OSDImage,"subpicture_region_t vout_OSDImage (vlc_object_t*,int,int,int,int,char*)",video_output\video_epg.c,"static subpicture_region_t * vout_OSDImage( vlc_object_t *p_obj,
                                            int x, int y, int w, int h,
                                            const char *psz_uri )
{
    video_format_t fmt_out;
    video_format_Init( &fmt_out, VLC_CODEC_YUVA );
    fmt_out.i_width = fmt_out.i_visible_width = w;
    fmt_out.i_height = fmt_out.i_visible_height = h;

    subpicture_region_t *image =
            spuregion_CreateFromPicture( p_obj, &fmt_out, psz_uri );
    if( image )
    {
        image->i_x = x;
        image->i_y = y;
        image->i_align = SUBPICTURE_ALIGN_LEFT|SUBPICTURE_ALIGN_TOP;
    }
    return image;
}",225.0,243.0,1.0,1.0,19.0,18,5,21,11,1,1,2,2,0,1,,0,1,12,6,6,subpicture_region_t
3603,194183,vout_OSDRegionConstrain,1,vout_OSDRegionConstrain,"void vout_OSDRegionConstrain (subpicture_region_t*,int,int)",video_output\video_epg.c,"static void vout_OSDRegionConstrain(subpicture_region_t *p_region, int w, int h)
{
    if( p_region )
    {
        p_region->i_max_width = w;
        p_region->i_max_height = h;
    }
}",245.0,252.0,1.0,1.0,8.0,4,2,5,3,2,0,2,2,0,0,,0,0,6,3,3,void
3604,194203,vout_OSDTextRegion,1,vout_OSDTextRegion,"subpicture_region_t vout_OSDTextRegion (text_segment_t*,int,int)",video_output\video_epg.c,"static subpicture_region_t * vout_OSDTextRegion(text_segment_t *p_segment,
                                                int x, int y )
{
    video_format_t fmt;
    subpicture_region_t *region;

    if (!p_segment)
        return NULL;

    /* Create a new subpicture region */
    video_format_Init(&fmt, VLC_CODEC_TEXT);
    fmt.i_sar_num = 1;
    fmt.i_sar_den = 1;

    region = subpicture_region_New(&fmt);
    if (!region)
        return NULL;

    region->p_text   = p_segment;
    region->i_align  = SUBPICTURE_ALIGN_LEFT | SUBPICTURE_ALIGN_TOP;
    region->i_text_align = SUBPICTURE_ALIGN_LEFT | SUBPICTURE_ALIGN_TOP;
    region->i_x      = x;
    region->i_y      = y;
    region->b_balanced_text = false;

    return region;
}",254.0,280.0,1.0,1.0,27.0,23,6,25,10,2,1,3,3,0,1,,0,1,6,3,3,subpicture_region_t
3605,194279,vout_OSDEpgText,1,vout_OSDEpgText,"subpicture_region_t vout_OSDEpgText (char*,int,int,int,uint32_t)",video_output\video_epg.c,"static subpicture_region_t * vout_OSDEpgText(const char *text,
                                             int x, int y,
                                             int size, uint32_t color)
{
    return vout_OSDTextRegion(vout_OSDSegment(text, size, color), x, y);
}",282.0,287.0,1.0,1.0,6.0,0,0,5,5,2,2,1,1,0,2,,0,1,10,5,5,subpicture_region_t
3606,194296,vout_OSDPrintTime,1,vout_OSDPrintTime,char* vout_OSDPrintTime (time_t),video_output\video_epg.c,"static char * vout_OSDPrintTime(time_t t)
{
    char *psz;
    struct tm tms;
    localtime_r(&t, &tms);
    if(asprintf(&psz, ""%2.2d:%2.2d"", tms.tm_hour, tms.tm_min) < 0)
       psz = NULL;
    return psz;
}",289.0,297.0,1.0,1.0,9.0,7,4,8,4,3,0,2,2,0,0,,0,0,2,1,1,char*
3607,194327,vout_OSDEpgEvent,1,vout_OSDEpgEvent,"subpicture_region_t vout_OSDEpgEvent (vlc_epg_event_t*,int,int,int)",video_output\video_epg.c,"static subpicture_region_t * vout_OSDEpgEvent(const vlc_epg_event_t *p_evt,
                                              int x, int y, int size)
{
    text_segment_t *p_segment = NULL;
    char *psz_start = vout_OSDPrintTime(p_evt->i_start);
    char *psz_end = vout_OSDPrintTime(p_evt->i_start + p_evt->i_duration);
    char *psz_text;
    if( -1 < asprintf(&psz_text, ""%s-%s "", psz_start, psz_end))
    {
        p_segment = vout_OSDSegment(psz_text, size, RGB_COLOR1);
        if( p_segment )
            p_segment->p_next = vout_OSDSegment(p_evt->psz_name, size, 0xffffff);
        vout_OSDSegmentSetNoWrap( p_segment );
    }
    free( psz_start );
    free( psz_end );
    if(!p_segment)
        return NULL;
    return vout_OSDTextRegion(p_segment, x, y);
}",299.0,318.0,1.0,52.0,20.0,15,7,25,9,2,6,4,5,0,6,,0,4,8,4,4,subpicture_region_t
3608,194407,vout_FillRightPanel,1,vout_FillRightPanel,"void vout_FillRightPanel (subpicture_updater_sys_t*,int,int,int,int,int,int,subpicture_region_t**)",video_output\video_epg.c,"static void vout_FillRightPanel(subpicture_updater_sys_t *p_sys,
                                int x, int y,
                                int width, int height,
                                int rx, int ry,
                                subpicture_region_t **last_ptr)
{
    float f_progress = 0;
    VLC_UNUSED(ry);

    /* Display the name of the channel. */
    *last_ptr = vout_OSDEpgText(p_sys->epg->psz_name,
                                x,
                                y,
                                height * EPGOSD_TEXTSIZE_NAME,
                                0x00ffffff);
    if(*last_ptr)
        last_ptr = &(*last_ptr)->p_next;

    const vlc_epg_event_t *p_current = p_sys->epg->p_current;
    vlc_epg_event_t *p_next = NULL;
    if(!p_sys->epg->p_current && p_sys->epg->i_event)
        p_current = p_sys->epg->pp_event[0];

    for(size_t i=0; i<p_sys->epg->i_event; i++)
    {
        if( p_sys->epg->pp_event[i]->i_id != p_current->i_id )
        {
          ...",320.0,412.0,1.0,41.0,93.0,121,15,84,16,1,22,15,20,6,8,,0,20,16,8,8,void
3609,194765,vout_BuildOSDEpg,1,vout_BuildOSDEpg,"subpicture_region_t vout_BuildOSDEpg (subpicture_updater_sys_t*,int,int,int,int)",video_output\video_epg.c,"static subpicture_region_t * vout_BuildOSDEpg(subpicture_updater_sys_t *p_sys,
                                              int x, int y,
                                              int visible_width,
                                              int visible_height)
{
    subpicture_region_t *head;
    subpicture_region_t **last_ptr = &head;

    const int i_padding = visible_height * (OSDEPG_HEIGHT * OSDEPG_PADDING);

    *last_ptr = vout_OSDBackground(x + visible_width * OSDEPG_LEFT,
                                   y + visible_height * OSDEPG_TOP,
                                   visible_width  * OSDEPG_WIDTH,
                                   visible_height * OSDEPG_HEIGHT,
                                   ARGB_BGCOLOR);
    if(*last_ptr)
        last_ptr = &(*last_ptr)->p_next;

    struct
    {
        int x;
        int y;
        int w;
        int h;
        int rx;
        int ry;
    } panel = {
        x + visible_width  * OSDEPG_LEFT + i_padding,
        y + v...",414.0,498.0,1.0,44.0,85.0,109,12,74,11,1,7,5,7,1,4,,0,6,10,5,5,subpicture_region_t
3610,195077,OSDEpgValidate,1,OSDEpgValidate,"int OSDEpgValidate (subpicture_t*,bool,video_format_t*,bool,video_format_t*,mtime_t)",video_output\video_epg.c,"static int OSDEpgValidate(subpicture_t *subpic,
                          bool has_src_changed, const video_format_t *fmt_src,
                          bool has_dst_changed, const video_format_t *fmt_dst,
                          mtime_t ts)
{
    VLC_UNUSED(subpic); VLC_UNUSED(ts);
    VLC_UNUSED(fmt_src); VLC_UNUSED(has_src_changed);
    VLC_UNUSED(fmt_dst);

    if (!has_dst_changed)
        return VLC_SUCCESS;
    return VLC_EGENERIC;
}",500.0,512.0,1.0,1.0,13.0,1,1,8,8,0,0,2,2,0,0,,0,0,12,6,6,int
3611,195105,OSDEpgUpdate,1,OSDEpgUpdate,"void OSDEpgUpdate (subpicture_t*,video_format_t*,video_format_t*,mtime_t)",video_output\video_epg.c,"static void OSDEpgUpdate(subpicture_t *subpic,
                         const video_format_t *fmt_src,
                         const video_format_t *fmt_dst,
                         mtime_t ts)
{
    subpicture_updater_sys_t *sys = subpic->updater.p_sys;
    VLC_UNUSED(fmt_src); VLC_UNUSED(ts);

    video_format_t fmt = *fmt_dst;
    fmt.i_width         = fmt.i_width         * fmt.i_sar_num / fmt.i_sar_den;
    fmt.i_visible_width = fmt.i_visible_width * fmt.i_sar_num / fmt.i_sar_den;
    fmt.i_x_offset      = fmt.i_x_offset      * fmt.i_sar_num / fmt.i_sar_den;

    subpic->i_original_picture_width  = fmt.i_visible_width;
    subpic->i_original_picture_height = fmt.i_visible_height;

    subpic->p_region = vout_BuildOSDEpg(sys,
                                        fmt.i_x_offset,
                                        fmt.i_y_offset,
                                        fmt.i_visible_width,
                                        fmt.i_visible_height);
}",514.0,535.0,1.0,1.0,22.0,38,6,28,6,0,1,1,1,0,1,,0,1,8,4,4,void
3612,195207,OSDEpgDestroy,1,OSDEpgDestroy,void OSDEpgDestroy (subpicture_t*),video_output\video_epg.c,"static void OSDEpgDestroy(subpicture_t *subpic)
{
    subpicture_updater_sys_t *sys = subpic->updater.p_sys;
    if( sys->epg )
        vlc_epg_Delete(sys->epg);
    free( sys->art );
    free(sys);
}",537.0,544.0,1.0,1.0,8.0,6,3,6,2,0,4,2,2,1,1,,0,3,2,1,1,void
3613,195235,vout_OSDEpg,1,vout_OSDEpg,"int vout_OSDEpg (vout_thread_t*,input_item_t*)",video_output\video_epg.c,"int vout_OSDEpg(vout_thread_t *vout, input_item_t *input )
{
    vlc_epg_t *epg = NULL;
    int64_t epg_time;

    /* Look for the current program EPG event */
    vlc_mutex_lock(&input->lock);

    const vlc_epg_t *tmp = input->p_epg_table;
    if ( tmp )
    {
        /* Pick table designated event, or first/next one */
        const vlc_epg_event_t *p_current_event = tmp->p_current;
        epg = vlc_epg_New(tmp->i_id, tmp->i_source_id);
        if(epg)
        {
            if( p_current_event )
            {
                vlc_epg_event_t *p_event = vlc_epg_event_Duplicate(p_current_event);
                if(p_event)
                {
                    if(!vlc_epg_AddEvent(epg, p_event))
                        vlc_epg_event_Delete(p_event);
                    else
                        vlc_epg_SetCurrent(epg, p_event->i_start);
                }
            }

            /* Add next event if any */
            vlc_epg_event_t *p_next = NULL;
            for(size_t i=0;...",552.0,659.0,1.0,1.0,108.0,98,17,105,26,0,24,16,38,3,17,,0,17,4,2,2,int
3614,195621,VoutDestructor,1,VoutDestructor,void VoutDestructor (vlc_object_t*),video_output\video_output.c,"static void VoutDestructor(vlc_object_t *object)
{
    vout_thread_t *vout = (vout_thread_t *)object;

    /* Make sure the vout was stopped first */
    //assert(!vout->p_module);

    free(vout->p->splitter_name);

    /* Destroy the locks */
    vlc_mutex_destroy(&vout->p->spu_lock);
    vlc_mutex_destroy(&vout->p->filter.lock);
    vout_control_Clean(&vout->p->control);

    /* */
    vout_statistic_Clean(&vout->p->statistic);

    /* */
    vout_snapshot_Clean(&vout->p->snapshot);

    video_format_Clean(&vout->p->original);
}",284.0,305.0,1.0,1.0,22.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
3615,195626,VoutValidateFormat,1,VoutValidateFormat,"int VoutValidateFormat (video_format_t*,video_format_t*)",video_output\video_output.c,"static int VoutValidateFormat(video_format_t *dst,
                              const video_format_t *src)
{
    if (src->i_width == 0  || src->i_width  > 8192 ||
        src->i_height == 0 || src->i_height > 8192)
        return VLC_EGENERIC;
    if (src->i_sar_num <= 0 || src->i_sar_den <= 0)
        return VLC_EGENERIC;

    /* */
    video_format_Copy(dst, src);
    dst->i_chroma = vlc_fourcc_GetCodec(VIDEO_ES, src->i_chroma);
    vlc_ureduce( &dst->i_sar_num, &dst->i_sar_den,
                 src->i_sar_num,  src->i_sar_den, 50000 );
    if (dst->i_sar_num <= 0 || dst->i_sar_den <= 0) {
        dst->i_sar_num = 1;
        dst->i_sar_den = 1;
    }
    video_format_FixRgb(dst);
    return VLC_SUCCESS;
}",78.0,98.0,1.0,1.0,21.0,34,7,23,5,2,3,4,4,0,3,,0,1,4,2,2,int
3616,195729,VideoFormatCopyCropAr,1,VideoFormatCopyCropAr,"void VideoFormatCopyCropAr (video_format_t*,video_format_t*)",video_output\video_output.c,"static void VideoFormatCopyCropAr(video_format_t *dst,
                                  const video_format_t *src)
{
    video_format_CopyCrop(dst, src);
    dst->i_sar_num = src->i_sar_num;
    dst->i_sar_den = src->i_sar_den;
}",99.0,105.0,1.0,1.0,7.0,6,2,6,2,4,1,1,1,0,1,,0,0,4,2,2,void
3617,195752,VideoFormatIsCropArEqual,1,VideoFormatIsCropArEqual,"bool VideoFormatIsCropArEqual (video_format_t*,video_format_t*)",video_output\video_output.c,"static bool VideoFormatIsCropArEqual(video_format_t *dst,
                                     const video_format_t *src)
{
    return dst->i_sar_num * src->i_sar_den == dst->i_sar_den * src->i_sar_num &&
           dst->i_x_offset       == src->i_x_offset &&
           dst->i_y_offset       == src->i_y_offset &&
           dst->i_visible_width  == src->i_visible_width &&
           dst->i_visible_height == src->i_visible_height;
}",106.0,114.0,1.0,1.0,9.0,23,4,12,2,0,0,1,1,0,0,,0,0,4,2,2,bool
3618,195806,VoutCreate,1,VoutCreate,"vout_thread_t VoutCreate (vlc_object_t*,vout_configuration_t*)",video_output\video_output.c,"static vout_thread_t *VoutCreate(vlc_object_t *object,
                                 const vout_configuration_t *cfg)
{
    video_format_t original;
    if (VoutValidateFormat(&original, cfg->fmt))
        return NULL;

    /* Allocate descriptor */
    vout_thread_t *vout = vlc_custom_create(object,
                                            sizeof(*vout) + sizeof(*vout->p),
                                            ""video output"");
    if (!vout) {
        video_format_Clean(&original);
        return NULL;
    }

    /* */
    vout->p = (vout_thread_sys_t*)&vout[1];

    vout->p->original = original;
    vout->p->dpb_size = cfg->dpb_size;

    vout_control_Init(&vout->p->control);
    vout_control_PushVoid(&vout->p->control, VOUT_CONTROL_INIT);

    vout_statistic_Init(&vout->p->statistic);

    vout_snapshot_Init(&vout->p->snapshot);

    /* Initialize locks */
    vlc_mutex_init(&vout->p->filter.lock);
    vlc_mutex_init(&vout->p->spu_lock);

    /* Take care of some ""int...",116.0,218.0,1.0,1.0,103.0,109,13,84,19,1,19,10,14,2,19,,0,5,4,2,2,vout_thread_t
3619,196163,vout_Request,1,vout_Request,"vout_thread_t vout_Request (vlc_object_t*,vout_configuration_t*)",video_output\video_output.c,"vout_thread_t *vout_Request(vlc_object_t *object,
                              const vout_configuration_t *cfg)
{
    vout_thread_t *vout = cfg->vout;
    if (cfg->change_fmt && !cfg->fmt) {
        if (vout)
            vout_CloseAndRelease(vout);
        return NULL;
    }

    /* If a vout is provided, try reusing it */
    if (vout) {
        if (vout->p->input != cfg->input) {
            if (vout->p->input)
                spu_Attach(vout->p->spu, vout->p->input, false);
            vout->p->input = cfg->input;
            if (vout->p->input)
                spu_Attach(vout->p->spu, vout->p->input, true);
        }

        if (cfg->change_fmt) {
            vout_control_cmd_t cmd;
            vout_control_cmd_Init(&cmd, VOUT_CONTROL_REINIT);
            cmd.u.cfg = cfg;

            vout_control_Push(&vout->p->control, &cmd);
            vout_control_WaitEmpty(&vout->p->control);
            vout_IntfReinit(vout);
        }

        if (!vout->p->dead) {
            msg_Dbg(...",221.0,260.0,1.0,1.0,40.0,41,7,36,8,1,8,9,17,0,7,,0,1,4,2,2,vout_thread_t
3620,196310,vout_Close,1,vout_Close,void vout_Close (vout_thread_t*),video_output\video_output.c,"void vout_Close(vout_thread_t *vout)
{
    assert(vout);

    if (vout->p->input)
        spu_Attach(vout->p->spu, vout->p->input, false);

    vout_snapshot_End(&vout->p->snapshot);

    vout_control_PushVoid(&vout->p->control, VOUT_CONTROL_CLEAN);
    vlc_join(vout->p->thread, NULL);

    if (vout->p->window != NULL)
        vout_display_window_Delete(vout->p->window);

    vlc_mutex_lock(&vout->p->spu_lock);
    spu_Destroy(vout->p->spu);
    vout->p->spu = NULL;
    vlc_mutex_unlock(&vout->p->spu_lock);
}",262.0,281.0,1.0,1.0,20.0,30,4,18,4,0,8,3,3,0,8,,0,0,2,1,1,void
3621,196461,vout_Cancel,1,vout_Cancel,"void vout_Cancel (vout_thread_t*,bool)",video_output\video_output.c,"void vout_Cancel(vout_thread_t *vout, bool canceled)
{
    vout_control_PushBool(&vout->p->control, VOUT_CONTROL_CANCEL, canceled);
    vout_control_WaitEmpty(&vout->p->control);
}",308.0,312.0,1.0,1.0,5.0,6,2,4,3,3,2,1,1,0,2,,0,0,4,2,2,void
3622,196483,vout_ChangePause,1,vout_ChangePause,"void vout_ChangePause (vout_thread_t*,bool,mtime_t)",video_output\video_output.c,"void vout_ChangePause(vout_thread_t *vout, bool is_paused, mtime_t date)
{
    vout_control_cmd_t cmd;
    vout_control_cmd_Init(&cmd, VOUT_CONTROL_PAUSE);
    cmd.u.pause.is_on = is_paused;
    cmd.u.pause.date  = date;
    vout_control_Push(&vout->p->control, &cmd);

    vout_control_WaitEmpty(&vout->p->control);
}",314.0,323.0,1.0,1.0,10.0,16,4,9,5,1,5,1,1,0,3,,0,2,6,3,3,void
3623,196529,vout_GetResetStatistic,1,vout_GetResetStatistic,"void vout_GetResetStatistic (vout_thread_t*,unsigned*,unsigned*)",video_output\video_output.c,"void vout_GetResetStatistic(vout_thread_t *vout, unsigned *restrict displayed,
                            unsigned *restrict lost)
{
    vout_statistic_GetReset( &vout->p->statistic, displayed, lost );
}",325.0,329.0,1.0,1.0,5.0,3,2,3,3,1,1,1,1,0,1,,0,0,6,3,3,void
3624,196545,vout_Flush,1,vout_Flush,"void vout_Flush (vout_thread_t*,mtime_t)",video_output\video_output.c,"void vout_Flush(vout_thread_t *vout, mtime_t date)
{
    vout_control_PushTime(&vout->p->control, VOUT_CONTROL_FLUSH, date);
    vout_control_WaitEmpty(&vout->p->control);
}",331.0,335.0,1.0,1.0,5.0,6,2,4,3,2,2,1,1,0,2,,0,0,4,2,2,void
3625,196567,vout_IsEmpty,1,vout_IsEmpty,bool vout_IsEmpty (vout_thread_t*),video_output\video_output.c,"bool vout_IsEmpty(vout_thread_t *vout)
{
    picture_t *picture = picture_fifo_Peek(vout->p->decoder_fifo);
    if (picture)
        picture_Release(picture);

    return !picture;
}",337.0,344.0,1.0,1.0,8.0,4,3,5,2,1,2,2,2,0,2,,0,1,2,1,1,bool
3626,196589,vout_NextPicture,1,vout_NextPicture,"void vout_NextPicture (vout_thread_t*,mtime_t*)",video_output\video_output.c,"void vout_NextPicture(vout_thread_t *vout, mtime_t *duration)
{
    vout_control_cmd_t cmd;
    vout_control_cmd_Init(&cmd, VOUT_CONTROL_STEP);
    cmd.u.time_ptr = duration;

    vout_control_Push(&vout->p->control, &cmd);
    vout_control_WaitEmpty(&vout->p->control);
}",346.0,354.0,1.0,1.0,9.0,11,4,7,4,1,4,1,1,0,3,,0,1,4,2,2,void
3627,196623,vout_DisplayTitle,1,vout_DisplayTitle,"void vout_DisplayTitle (vout_thread_t*,char*)",video_output\video_output.c,"void vout_DisplayTitle(vout_thread_t *vout, const char *title)
{
    assert(title);
    vout_control_PushString(&vout->p->control, VOUT_CONTROL_OSD_TITLE, title);
}",356.0,360.0,1.0,1.0,5.0,3,2,4,3,1,1,1,1,0,1,,0,0,4,2,2,void
3628,196640,vout_WindowMouseEvent,1,vout_WindowMouseEvent,"void vout_WindowMouseEvent (vout_thread_t*,vout_window_mouse_event_t*)",video_output\video_output.c,"void vout_WindowMouseEvent(vout_thread_t *vout,
                           const vout_window_mouse_event_t *mouse)
{
    assert(mouse);
    vout_control_cmd_t cmd;
    vout_control_cmd_Init(&cmd, VOUT_CONTROL_WINDOW_MOUSE);
    cmd.u.window_mouse = *mouse;

    vout_control_Push(&vout->p->control, &cmd);
}",362.0,371.0,1.0,1.0,10.0,9,5,7,4,1,3,1,1,0,2,,0,1,4,2,2,void
3629,196670,vout_PutSubpicture,1,vout_PutSubpicture,"void vout_PutSubpicture (vout_thread_t*,subpicture_t*)",video_output\video_output.c,"void vout_PutSubpicture( vout_thread_t *vout, subpicture_t *subpic )
{
    vout_control_cmd_t cmd;
    vout_control_cmd_Init(&cmd, VOUT_CONTROL_SUBPICTURE);
    cmd.u.subpicture = subpic;

    vout_control_Push(&vout->p->control, &cmd);
}",373.0,380.0,1.0,1.0,8.0,8,4,6,4,5,3,1,1,0,2,,0,1,4,2,2,void
3630,196697,vout_RegisterSubpictureChannel,1,vout_RegisterSubpictureChannel,int vout_RegisterSubpictureChannel (vout_thread_t*),video_output\video_output.c,"int vout_RegisterSubpictureChannel( vout_thread_t *vout )
{
    int channel = VOUT_SPU_CHANNEL_AVAIL_FIRST;

    vlc_mutex_lock(&vout->p->spu_lock);
    if (vout->p->spu)
        channel = spu_RegisterChannel(vout->p->spu);
    vlc_mutex_unlock(&vout->p->spu_lock);

    return channel;
}",381.0,391.0,1.0,1.0,11.0,12,3,8,3,1,3,2,2,0,3,,0,1,2,1,1,int
3631,196737,vout_FlushSubpictureChannel,1,vout_FlushSubpictureChannel,"void vout_FlushSubpictureChannel (vout_thread_t*,int)",video_output\video_output.c,"void vout_FlushSubpictureChannel( vout_thread_t *vout, int channel )
{
    vout_control_PushInteger(&vout->p->control, VOUT_CONTROL_FLUSH_SUBPICTURE,
                             channel);
}",392.0,396.0,1.0,1.0,5.0,3,2,3,3,3,1,1,1,0,1,,0,0,4,2,2,void
3632,196752,vout_GetPicture,1,vout_GetPicture,picture_t vout_GetPicture (vout_thread_t*),video_output\video_output.c,"picture_t *vout_GetPicture(vout_thread_t *vout)
{
    picture_t *picture = picture_pool_Wait(vout->p->decoder_pool);
    if (likely(picture != NULL)) {
        picture_Reset(picture);
        VideoFormatCopyCropAr(&picture->format, &vout->p->original);
    }
    return picture;
}",407.0,415.0,1.0,1.0,9.0,9,4,8,3,1,3,2,2,0,3,,0,1,2,1,1,picture_t
3633,196787,vout_PutPicture,1,vout_PutPicture,"void vout_PutPicture (vout_thread_t*,picture_t*)",video_output\video_output.c,"void vout_PutPicture(vout_thread_t *vout, picture_t *picture)
{
    picture->p_next = NULL;
    if (picture_pool_OwnsPic(vout->p->decoder_pool, picture))
    {
        picture_fifo_Push(vout->p->decoder_fifo, picture);

        vout_control_Wake(&vout->p->control);
    }
    else
    {
        /* FIXME: HACK: Drop this picture because the vout changed. The old
         * picture pool need to be kept by the new vout. This requires a major
         * ""vout display"" API change. */
        picture_Release(picture);
    }
}",425.0,441.0,1.0,1.0,17.0,9,3,7,3,1,3,2,2,1,3,,0,1,4,2,2,void
3634,196825,vout_GetSnapshot,1,vout_GetSnapshot,"int vout_GetSnapshot (vout_thread_t*,block_t**,picture_t**,video_format_t*,char*,mtime_t)",video_output\video_output.c,"int vout_GetSnapshot(vout_thread_t *vout,
                     block_t **image_dst, picture_t **picture_dst,
                     video_format_t *fmt,
                     const char *type, mtime_t timeout)
{
    picture_t *picture = vout_snapshot_Get(&vout->p->snapshot, timeout);
    if (!picture) {
        msg_Err(vout, ""Failed to grab a snapshot"");
        return VLC_EGENERIC;
    }

    if (image_dst) {
        vlc_fourcc_t codec = VLC_CODEC_PNG;
        if (type && image_Type2Fourcc(type))
            codec = image_Type2Fourcc(type);

        const int override_width  = var_InheritInteger(vout, ""snapshot-width"");
        const int override_height = var_InheritInteger(vout, ""snapshot-height"");

        if (picture_Export(VLC_OBJECT(vout), image_dst, fmt,
                           picture, codec, override_width, override_height)) {
            msg_Err(vout, ""Failed to convert image for snapshot"");
            picture_Release(picture);
            return VLC_EGENERIC;
        }
 ...",444.0,475.0,1.0,1.0,32.0,12,6,31,13,1,5,6,8,2,5,,0,4,12,6,6,int
3635,196915,vout_ChangeAspectRatio,1,vout_ChangeAspectRatio,"void vout_ChangeAspectRatio (vout_thread_t*,unsigned int,unsigned int)",video_output\video_output.c,"void vout_ChangeAspectRatio( vout_thread_t *p_vout,
                             unsigned int i_num, unsigned int i_den )
{
    vout_ControlChangeSampleAspectRatio( p_vout, i_num, i_den );
}",477.0,481.0,1.0,1.0,5.0,0,0,3,3,0,1,1,1,0,1,,0,0,6,3,3,void
3636,196926,vout_ControlChangeFullscreen,1,vout_ControlChangeFullscreen,"void vout_ControlChangeFullscreen (vout_thread_t*,bool)",video_output\video_output.c,"void vout_ControlChangeFullscreen(vout_thread_t *vout, bool fullscreen)
{
    vout_control_PushBool(&vout->p->control, VOUT_CONTROL_FULLSCREEN,
                          fullscreen);
}",484.0,488.0,1.0,1.0,5.0,3,2,3,3,0,1,1,1,0,1,,0,0,4,2,2,void
3637,196941,vout_ControlChangeWindowState,1,vout_ControlChangeWindowState,"void vout_ControlChangeWindowState (vout_thread_t*,unsigned)",video_output\video_output.c,"void vout_ControlChangeWindowState(vout_thread_t *vout, unsigned st)
{
    vout_control_PushInteger(&vout->p->control, VOUT_CONTROL_WINDOW_STATE, st);
}",489.0,492.0,1.0,1.0,4.0,3,2,3,3,0,1,1,1,0,1,,0,0,4,2,2,void
3638,196956,vout_ControlChangeDisplayFilled,1,vout_ControlChangeDisplayFilled,"void vout_ControlChangeDisplayFilled (vout_thread_t*,bool)",video_output\video_output.c,"void vout_ControlChangeDisplayFilled(vout_thread_t *vout, bool is_filled)
{
    vout_control_PushBool(&vout->p->control, VOUT_CONTROL_DISPLAY_FILLED,
                          is_filled);
}",493.0,497.0,1.0,1.0,5.0,3,2,3,3,0,1,1,1,0,1,,0,0,4,2,2,void
3639,196971,vout_ControlChangeZoom,1,vout_ControlChangeZoom,"void vout_ControlChangeZoom (vout_thread_t*,int,int)",video_output\video_output.c,"void vout_ControlChangeZoom(vout_thread_t *vout, int num, int den)
{
    vout_control_PushPair(&vout->p->control, VOUT_CONTROL_ZOOM,
                          num, den);
}",498.0,502.0,1.0,1.0,5.0,3,2,4,4,0,1,1,1,0,1,,0,0,6,3,3,void
3640,196988,vout_ControlChangeSampleAspectRatio,1,vout_ControlChangeSampleAspectRatio,"void vout_ControlChangeSampleAspectRatio (vout_thread_t*,unsigned,unsigned)",video_output\video_output.c,"void vout_ControlChangeSampleAspectRatio(vout_thread_t *vout,
                                         unsigned num, unsigned den)
{
    vout_control_PushPair(&vout->p->control, VOUT_CONTROL_ASPECT_RATIO,
                          num, den);
}",503.0,508.0,1.0,1.0,6.0,3,2,4,4,1,1,1,1,0,1,,0,0,6,3,3,void
3641,197005,vout_ControlChangeCropRatio,1,vout_ControlChangeCropRatio,"void vout_ControlChangeCropRatio (vout_thread_t*,unsigned,unsigned)",video_output\video_output.c,"void vout_ControlChangeCropRatio(vout_thread_t *vout,
                                 unsigned num, unsigned den)
{
    vout_control_PushPair(&vout->p->control, VOUT_CONTROL_CROP_RATIO,
                          num, den);
}",509.0,514.0,1.0,1.0,6.0,3,2,4,4,0,1,1,1,0,1,,0,0,6,3,3,void
3642,197022,vout_ControlChangeCropWindow,1,vout_ControlChangeCropWindow,"void vout_ControlChangeCropWindow (vout_thread_t*,int,int,int,int)",video_output\video_output.c,"void vout_ControlChangeCropWindow(vout_thread_t *vout,
                                  int x, int y, int width, int height)
{
    vout_control_cmd_t cmd;
    vout_control_cmd_Init(&cmd, VOUT_CONTROL_CROP_WINDOW);
    cmd.u.window.x      = __MAX(x, 0);
    cmd.u.window.y      = __MAX(y, 0);
    cmd.u.window.width  = __MAX(width, 0);
    cmd.u.window.height = __MAX(height, 0);

    vout_control_Push(&vout->p->control, &cmd);
}",515.0,526.0,1.0,1.0,12.0,21,4,12,7,0,6,1,1,0,2,,0,4,10,5,5,void
3643,197089,vout_ControlChangeCropBorder,1,vout_ControlChangeCropBorder,"void vout_ControlChangeCropBorder (vout_thread_t*,int,int,int,int)",video_output\video_output.c,"void vout_ControlChangeCropBorder(vout_thread_t *vout,
                                  int left, int top, int right, int bottom)
{
    vout_control_cmd_t cmd;
    vout_control_cmd_Init(&cmd, VOUT_CONTROL_CROP_BORDER);
    cmd.u.border.left   = __MAX(left, 0);
    cmd.u.border.top    = __MAX(top, 0);
    cmd.u.border.right  = __MAX(right, 0);
    cmd.u.border.bottom = __MAX(bottom, 0);

    vout_control_Push(&vout->p->control, &cmd);
}",527.0,538.0,1.0,1.0,12.0,21,4,12,7,0,6,1,1,0,2,,0,4,10,5,5,void
3644,197156,vout_ControlChangeFilters,1,vout_ControlChangeFilters,"void vout_ControlChangeFilters (vout_thread_t*,char*)",video_output\video_output.c,"void vout_ControlChangeFilters(vout_thread_t *vout, const char *filters)
{
    vout_control_PushString(&vout->p->control, VOUT_CONTROL_CHANGE_FILTERS,
                            filters);
}",539.0,543.0,1.0,1.0,5.0,3,2,3,3,1,1,1,1,0,1,,0,0,4,2,2,void
3645,197171,vout_ControlChangeSubSources,1,vout_ControlChangeSubSources,"void vout_ControlChangeSubSources (vout_thread_t*,char*)",video_output\video_output.c,"void vout_ControlChangeSubSources(vout_thread_t *vout, const char *filters)
{
    vout_control_PushString(&vout->p->control, VOUT_CONTROL_CHANGE_SUB_SOURCES,
                            filters);
}",544.0,548.0,1.0,1.0,5.0,3,2,3,3,1,1,1,1,0,1,,0,0,4,2,2,void
3646,197186,vout_ControlChangeSubFilters,1,vout_ControlChangeSubFilters,"void vout_ControlChangeSubFilters (vout_thread_t*,char*)",video_output\video_output.c,"void vout_ControlChangeSubFilters(vout_thread_t *vout, const char *filters)
{
    vout_control_PushString(&vout->p->control, VOUT_CONTROL_CHANGE_SUB_FILTERS,
                            filters);
}",549.0,553.0,1.0,1.0,5.0,3,2,3,3,1,1,1,1,0,1,,0,0,4,2,2,void
3647,197201,vout_ControlChangeSubMargin,1,vout_ControlChangeSubMargin,"void vout_ControlChangeSubMargin (vout_thread_t*,int)",video_output\video_output.c,"void vout_ControlChangeSubMargin(vout_thread_t *vout, int margin)
{
    vout_control_PushInteger(&vout->p->control, VOUT_CONTROL_CHANGE_SUB_MARGIN,
                             margin);
}",554.0,558.0,1.0,1.0,5.0,3,2,3,3,0,1,1,1,0,1,,0,0,4,2,2,void
3648,197216,vout_ControlChangeViewpoint,1,vout_ControlChangeViewpoint,"void vout_ControlChangeViewpoint (vout_thread_t*,vlc_viewpoint_t*)",video_output\video_output.c,"void vout_ControlChangeViewpoint(vout_thread_t *vout,
                                 const vlc_viewpoint_t *p_viewpoint)
{
    vout_control_cmd_t cmd;
    vout_control_cmd_Init(&cmd, VOUT_CONTROL_VIEWPOINT);
    cmd.u.viewpoint = *p_viewpoint;
    vout_control_Push(&vout->p->control, &cmd);
}",560.0,567.0,1.0,1.0,8.0,9,5,6,4,0,3,1,1,0,2,,0,1,4,2,2,void
3649,197244,VoutGetDisplayCfg,1,VoutGetDisplayCfg,"void VoutGetDisplayCfg (vout_thread_t*,vout_display_cfg_t*,char*)",video_output\video_output.c,"static void VoutGetDisplayCfg(vout_thread_t *vout, vout_display_cfg_t *cfg, const char *title)
{
    /* Load configuration */
#if defined(_WIN32) || defined(__OS2__)
    cfg->is_fullscreen = var_GetBool(vout, ""fullscreen"")
                         || var_GetBool(vout, ""video-wallpaper"");
#endif
    cfg->viewpoint = vout->p->original.pose;

    cfg->display.title = title;
    const int display_width = var_GetInteger(vout, ""width"");
    const int display_height = var_GetInteger(vout, ""height"");
    cfg->display.width   = display_width > 0  ? display_width  : 0;
    cfg->display.height  = display_height > 0 ? display_height : 0;
    cfg->is_display_filled  = var_GetBool(vout, ""autoscale"");
    unsigned msar_num, msar_den;
    if (var_InheritURational(vout, &msar_num, &msar_den, ""monitor-par"") ||
        msar_num <= 0 || msar_den <= 0) {
        msar_num = 1;
        msar_den = 1;
    }
    cfg->display.sar.num = msar_num;
    cfg->display.sar.den = msar_den;
    unsigned zoom_den = 100...",570.0,609.0,1.0,1.0,40.0,64,10,51,13,1,1,4,4,0,1,,0,0,6,3,3,void
3650,197615,FilterRestartCallback,1,FilterRestartCallback,"int FilterRestartCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",video_output\video_output.c,"static int FilterRestartCallback(vlc_object_t *p_this, char const *psz_var,
                                 vlc_value_t oldval, vlc_value_t newval,
                                 void *p_data)
{
    (void) p_this; (void) psz_var; (void) oldval; (void) newval;
    vout_ControlChangeFilters((vout_thread_t *)p_data, NULL);
    return 0;
}",658.0,665.0,1.0,1.0,8.0,5,1,6,6,0,1,1,1,0,1,,0,0,10,5,5,int
3651,197643,ThreadDelFilterCallbacks,1,ThreadDelFilterCallbacks,"int ThreadDelFilterCallbacks (filter_t*,void*)",video_output\video_output.c,"static int ThreadDelFilterCallbacks(filter_t *filter, void *opaque)
{
    filter_DelProxyCallbacks((vlc_object_t *)opaque, filter,
                             FilterRestartCallback);
    return VLC_SUCCESS;
}",667.0,672.0,1.0,1.0,6.0,1,1,3,3,0,1,1,1,0,1,,0,0,4,2,2,int
3652,197657,ThreadDelAllFilterCallbacks,1,ThreadDelAllFilterCallbacks,void ThreadDelAllFilterCallbacks (vout_thread_t*),video_output\video_output.c,"static void ThreadDelAllFilterCallbacks(vout_thread_t *vout)
{
    assert(vout->p->filter.chain_interactive != NULL);
    filter_chain_ForEach(vout->p->filter.chain_interactive,
                         ThreadDelFilterCallbacks, vout);
}",674.0,679.0,1.0,1.0,6.0,7,3,4,2,4,1,1,1,0,1,,0,0,2,1,1,void
3653,197682,VoutVideoFilterInteractiveNewPicture,1,VoutVideoFilterInteractiveNewPicture,picture_t VoutVideoFilterInteractiveNewPicture (filter_t*),video_output\video_output.c,"static picture_t *VoutVideoFilterInteractiveNewPicture(filter_t *filter)
{
    vout_thread_t *vout = filter->owner.sys;

    picture_t *picture = picture_pool_Get(vout->p->private_pool);
    if (picture) {
        picture_Reset(picture);
        VideoFormatCopyCropAr(&picture->format, &filter->fmt_out.video);
    }
    return picture;
}",681.0,691.0,1.0,1.0,11.0,11,4,9,3,1,3,2,2,0,3,,0,1,2,1,1,picture_t
3654,197722,VoutVideoFilterStaticNewPicture,1,VoutVideoFilterStaticNewPicture,picture_t VoutVideoFilterStaticNewPicture (filter_t*),video_output\video_output.c,"static picture_t *VoutVideoFilterStaticNewPicture(filter_t *filter)
{
    vout_thread_t *vout = filter->owner.sys;

    vlc_assert_locked(&vout->p->filter.lock);
    if (filter_chain_IsEmpty(vout->p->filter.chain_interactive))
        return VoutVideoFilterInteractiveNewPicture(filter);

    return picture_NewFromFormat(&filter->fmt_out.video);
}",693.0,702.0,1.0,1.0,10.0,13,4,6,2,0,3,2,2,1,3,,0,1,2,1,1,picture_t
3655,197765,ThreadFilterFlush,1,ThreadFilterFlush,"void ThreadFilterFlush (vout_thread_t*,bool)",video_output\video_output.c,"static void ThreadFilterFlush(vout_thread_t *vout, bool is_locked)
{
    if (vout->p->displayed.current)
        picture_Release( vout->p->displayed.current );
    vout->p->displayed.current = NULL;

    if (vout->p->displayed.next)
        picture_Release( vout->p->displayed.next );
    vout->p->displayed.next = NULL;

    if (!is_locked)
        vlc_mutex_lock(&vout->p->filter.lock);
    filter_chain_VideoFlush(vout->p->filter.chain_static);
    filter_chain_VideoFlush(vout->p->filter.chain_interactive);
    if (!is_locked)
        vlc_mutex_unlock(&vout->p->filter.lock);
}",704.0,720.0,1.0,1.0,17.0,36,5,14,3,3,6,5,5,0,6,,0,0,4,2,2,void
3656,197869,ThreadChangeFilters,1,ThreadChangeFilters,"void ThreadChangeFilters (vout_thread_t*,video_format_t*,char*,int,bool)",video_output\video_output.c,"static void ThreadChangeFilters(vout_thread_t *vout,
                                const video_format_t *source,
                                const char *filters,
                                int deinterlace,
                                bool is_locked)
{
    ThreadFilterFlush(vout, is_locked);
    ThreadDelAllFilterCallbacks(vout);

    vlc_array_t array_static;
    vlc_array_t array_interactive;

    vlc_array_init(&array_static);
    vlc_array_init(&array_interactive);

    if ((vout->p->filter.has_deint =
         deinterlace == 1 || (deinterlace == -1 && vout->p->filter.has_deint)))
    {
        vout_filter_t *e = malloc(sizeof(*e));

        if (likely(e))
        {
            free(config_ChainCreate(&e->name, &e->cfg, ""deinterlace""));
            vlc_array_append_or_abort(&array_static, e);
        }
    }

    char *current = filters ? strdup(filters) : NULL;
    while (current) {
        config_chain_t *cfg;
        char *name;
        char *next = config_Chain...",727.0,844.0,1.0,1.0,118.0,126,14,113,20,2,28,16,27,3,17,,0,16,10,5,5,void
3657,198319,ThreadDisplayPreparePicture,1,ThreadDisplayPreparePicture,"int ThreadDisplayPreparePicture (vout_thread_t*,bool,bool)",video_output\video_output.c,"static int ThreadDisplayPreparePicture(vout_thread_t *vout, bool reuse, bool frame_by_frame)
{
    bool is_late_dropped = vout->p->is_late_dropped && !vout->p->pause.is_on && !frame_by_frame;

    vlc_mutex_lock(&vout->p->filter.lock);

    picture_t *picture = filter_chain_VideoFilter(vout->p->filter.chain_static, NULL);
    assert(!reuse || !picture);

    while (!picture) {
        picture_t *decoded;
        if (reuse && vout->p->displayed.decoded) {
            decoded = picture_Hold(vout->p->displayed.decoded);
        } else {
            decoded = picture_fifo_Pop(vout->p->decoder_fifo);
            if (decoded) {
                if (is_late_dropped && !decoded->b_force) {
                    mtime_t late_threshold;
                    if (decoded->format.i_frame_rate && decoded->format.i_frame_rate_base)
                        late_threshold = ((CLOCK_FREQ/2) * decoded->format.i_frame_rate_base) / decoded->format.i_frame_rate;
                    else
                     ...",848.0,911.0,1.0,41.0,64.0,74,7,37,10,2,7,8,10,0,7,,0,4,6,3,3,int
3658,198655,ConvertRGB32AndBlendBufferNew,1,ConvertRGB32AndBlendBufferNew,picture_t ConvertRGB32AndBlendBufferNew (filter_t*),video_output\video_output.c,"static picture_t *ConvertRGB32AndBlendBufferNew(filter_t *filter)
{
    return picture_NewFromFormat(&filter->fmt_out.video);
}",913.0,916.0,1.0,1.0,4.0,3,3,1,1,0,1,1,1,0,1,,0,0,2,1,1,picture_t
3659,198668,ConvertRGB32AndBlend,1,ConvertRGB32AndBlend,"picture_t ConvertRGB32AndBlend (vout_thread_t*,picture_t*,subpicture_t*)",video_output\video_output.c,"static picture_t *ConvertRGB32AndBlend(vout_thread_t *vout, picture_t *pic,
                                     subpicture_t *subpic)
{
    /* This function will convert the pic to RGB32 and blend the subpic to it.
     * The returned pic can't be used to display since the chroma will be
     * different than the ""vout display"" one, but it can be used for snapshots.
     * */

    assert(vout->p->spu_blend);

    filter_owner_t owner = {
        .video = {
            .buffer_new = ConvertRGB32AndBlendBufferNew,
        },
    };
    filter_chain_t *filterc = filter_chain_NewVideo(vout, false, &owner);
    if (!filterc)
        return NULL;

    es_format_t src = vout->p->spu_blend->fmt_out;
    es_format_t dst = src;
    dst.video.i_chroma = VLC_CODEC_RGB32;
    video_format_FixRgb(&dst.video);

    if (filter_chain_AppendConverter(filterc, &src, &dst) != 0)
    {
        filter_chain_Delete(filterc);
        return NULL;
    }

    picture_Hold(pic);
    pic = filter_chain_VideoF...",918.0,965.0,1.0,1.0,48.0,29,8,41,14,0,11,6,9,1,11,,0,5,6,3,3,picture_t
3660,198792,ThreadDisplayRenderPicture,1,ThreadDisplayRenderPicture,"int ThreadDisplayRenderPicture (vout_thread_t*,bool)",video_output\video_output.c,"static int ThreadDisplayRenderPicture(vout_thread_t *vout, bool is_forced)
{
    vout_thread_sys_t *sys = vout->p;
    vout_display_t *vd = vout->p->display.vd;

    picture_t *torender = picture_Hold(vout->p->displayed.current);

    vout_chrono_Start(&vout->p->render);

    vlc_mutex_lock(&vout->p->filter.lock);
    picture_t *filtered = filter_chain_VideoFilter(vout->p->filter.chain_interactive, torender);
    vlc_mutex_unlock(&vout->p->filter.lock);

    if (!filtered)
        return VLC_EGENERIC;

    if (filtered->date != vout->p->displayed.current->date)
        msg_Warn(vout, ""Unsupported timestamp modifications done by chain_interactive"");

    /*
     * Get the subpicture to be displayed
     */
    const bool do_snapshot = vout_snapshot_IsRequested(&vout->p->snapshot);
    mtime_t render_subtitle_date;
    if (vout->p->pause.is_on)
        render_subtitle_date = vout->p->pause.date;
    else
        render_subtitle_date = filtered->date > 1 ? filtered->date : mdate();
   ...",967.0,1183.0,1.0,1.0,217.0,195,13,153,26,1,32,20,33,1,32,,0,10,4,2,2,int
3661,199576,ThreadDisplayPicture,1,ThreadDisplayPicture,"int ThreadDisplayPicture (vout_thread_t*,mtime_t*)",video_output\video_output.c,"static int ThreadDisplayPicture(vout_thread_t *vout, mtime_t *deadline)
{
    bool frame_by_frame = !deadline;
    bool paused = vout->p->pause.is_on;
    bool first = !vout->p->displayed.current;

    if (first)
        if (ThreadDisplayPreparePicture(vout, true, frame_by_frame)) /* FIXME not sure it is ok */
            return VLC_EGENERIC;

    if (!paused || frame_by_frame)
        while (!vout->p->displayed.next && !ThreadDisplayPreparePicture(vout, false, frame_by_frame))
            ;

    const mtime_t date = mdate();
    const mtime_t render_delay = vout_chrono_GetHigh(&vout->p->render) + VOUT_MWAIT_TOLERANCE;

    bool drop_next_frame = frame_by_frame;
    mtime_t date_next = VLC_TS_INVALID;
    if (!paused && vout->p->displayed.next) {
        date_next = vout->p->displayed.next->date - render_delay;
        if (date_next /* + 0 FIXME */ <= date)
            drop_next_frame = true;
    }

    /* FIXME/XXX we must redisplay the last decoded picture (because
     * of poten...",1185.0,1252.0,1.0,73.0,68.0,99,15,81,19,1,6,14,19,2,6,,0,5,4,2,2,int
3662,199860,ThreadDisplaySubpicture,1,ThreadDisplaySubpicture,"void ThreadDisplaySubpicture (vout_thread_t*,subpicture_t*)",video_output\video_output.c,"static void ThreadDisplaySubpicture(vout_thread_t *vout,
                                    subpicture_t *subpicture)
{
    spu_PutSubpicture(vout->p->spu, subpicture);
}",1254.0,1258.0,1.0,1.0,5.0,2,1,2,2,1,1,1,1,0,1,,0,0,4,2,2,void
3663,199873,ThreadFlushSubpicture,1,ThreadFlushSubpicture,"void ThreadFlushSubpicture (vout_thread_t*,int)",video_output\video_output.c,"static void ThreadFlushSubpicture(vout_thread_t *vout, int channel)
{
    spu_ClearChannel(vout->p->spu, channel);
}",1260.0,1263.0,1.0,1.0,4.0,2,1,2,2,1,1,1,1,0,1,,0,0,4,2,2,void
3664,199886,ThreadDisplayOsdTitle,1,ThreadDisplayOsdTitle,"void ThreadDisplayOsdTitle (vout_thread_t*,char*)",video_output\video_output.c,"static void ThreadDisplayOsdTitle(vout_thread_t *vout, const char *string)
{
    if (!vout->p->title.show)
        return;

    vout_OSDText(vout, VOUT_SPU_CHANNEL_OSD,
                 vout->p->title.position, INT64_C(1000) * vout->p->title.timeout,
                 string);
}",1265.0,1273.0,1.0,1.0,9.0,11,4,6,3,1,1,2,2,0,1,,0,0,4,2,2,void
3665,199924,ThreadChangeSubSources,1,ThreadChangeSubSources,"void ThreadChangeSubSources (vout_thread_t*,char*)",video_output\video_output.c,"static void ThreadChangeSubSources(vout_thread_t *vout, const char *filters)
{
    spu_ChangeSources(vout->p->spu, filters);
}",1275.0,1278.0,1.0,1.0,4.0,2,1,2,2,1,1,1,1,0,1,,0,0,4,2,2,void
3666,199937,ThreadChangeSubFilters,1,ThreadChangeSubFilters,"void ThreadChangeSubFilters (vout_thread_t*,char*)",video_output\video_output.c,"static void ThreadChangeSubFilters(vout_thread_t *vout, const char *filters)
{
    spu_ChangeFilters(vout->p->spu, filters);
}",1280.0,1283.0,1.0,1.0,4.0,2,1,2,2,1,1,1,1,0,1,,0,0,4,2,2,void
3667,199950,ThreadChangeSubMargin,1,ThreadChangeSubMargin,"void ThreadChangeSubMargin (vout_thread_t*,int)",video_output\video_output.c,"static void ThreadChangeSubMargin(vout_thread_t *vout, int margin)
{
    spu_ChangeMargin(vout->p->spu, margin);
}",1285.0,1288.0,1.0,1.0,4.0,2,1,2,2,1,1,1,1,0,1,,0,0,4,2,2,void
3668,199963,ThreadChangePause,1,ThreadChangePause,"void ThreadChangePause (vout_thread_t*,bool,mtime_t)",video_output\video_output.c,"static void ThreadChangePause(vout_thread_t *vout, bool is_paused, mtime_t date)
{
    assert(!vout->p->pause.is_on || !is_paused);

    if (vout->p->pause.is_on) {
        const mtime_t duration = date - vout->p->pause.date;

        if (vout->p->step.timestamp > VLC_TS_INVALID)
            vout->p->step.timestamp += duration;
        if (vout->p->step.last > VLC_TS_INVALID)
            vout->p->step.last += duration;
        picture_fifo_OffsetDate(vout->p->decoder_fifo, duration);
        if (vout->p->displayed.decoded)
            vout->p->displayed.decoded->date += duration;
        spu_OffsetSubtitleDate(vout->p->spu, duration);

        ThreadFilterFlush(vout, false);
    } else {
        vout->p->step.timestamp = VLC_TS_INVALID;
        vout->p->step.last      = VLC_TS_INVALID;
    }
    vout->p->pause.is_on = is_paused;
    vout->p->pause.date  = date;

    vout_window_t *window = vout->p->window;
    if (window != NULL)
        vout_window_SetInhibition(window, !is_paused);
}",1290.0,1317.0,1.0,1.0,28.0,55,9,33,8,1,4,6,9,0,4,,0,0,6,3,3,void
3669,200135,ThreadFlush,1,ThreadFlush,"void ThreadFlush (vout_thread_t*,bool,mtime_t)",video_output\video_output.c,"static void ThreadFlush(vout_thread_t *vout, bool below, mtime_t date)
{
    vout->p->step.timestamp = VLC_TS_INVALID;
    vout->p->step.last      = VLC_TS_INVALID;

    ThreadFilterFlush(vout, false); /* FIXME too much */

    picture_t *last = vout->p->displayed.decoded;
    if (last) {
        if (( below && last->date <= date) ||
            (!below && last->date >= date)) {
            picture_Release(last);

            vout->p->displayed.decoded   = NULL;
            vout->p->displayed.date      = VLC_TS_INVALID;
            vout->p->displayed.timestamp = VLC_TS_INVALID;
        }
    }

    picture_fifo_Flush(vout->p->decoder_fifo, date, below);
    vout_FilterFlush(vout->p->display.vd);
}",1319.0,1340.0,1.0,1.0,22.0,37,8,26,7,2,4,3,4,0,4,,0,0,6,3,3,void
3670,200239,ThreadStep,1,ThreadStep,"void ThreadStep (vout_thread_t*,mtime_t*)",video_output\video_output.c,"static void ThreadStep(vout_thread_t *vout, mtime_t *duration)
{
    *duration = 0;

    if (vout->p->step.last <= VLC_TS_INVALID)
        vout->p->step.last = vout->p->displayed.timestamp;

    if (ThreadDisplayPicture(vout, NULL))
        return;

    vout->p->step.timestamp = vout->p->displayed.timestamp;

    if (vout->p->step.last > VLC_TS_INVALID &&
        vout->p->step.timestamp > vout->p->step.last) {
        *duration = vout->p->step.timestamp - vout->p->step.last;
        vout->p->step.last = vout->p->step.timestamp;
        /* TODO advance subpicture by the duration ... */
    }
}",1342.0,1360.0,1.0,1.0,19.0,48,8,18,4,1,1,4,4,1,1,,0,1,4,2,2,void
3671,200356,ThreadChangeFullscreen,1,ThreadChangeFullscreen,"void ThreadChangeFullscreen (vout_thread_t*,bool)",video_output\video_output.c,"static void ThreadChangeFullscreen(vout_thread_t *vout, bool fullscreen)
{
    vout_window_t *window = vout->p->window;

#if !defined(_WIN32) && !defined(__OS2__)
    if (window != NULL)
        vout_window_SetFullScreen(window, fullscreen);
#else
    bool window_fullscreen = false;
    if (window != NULL
     && vout_window_SetFullScreen(window, fullscreen) == VLC_SUCCESS)
        window_fullscreen = true;
    /* FIXME: remove this event */
    if (vout->p->display.vd != NULL)
        vout_display_SendEventFullscreen(vout->p->display.vd, fullscreen, window_fullscreen);
#endif
}",1362.0,1378.0,1.0,1.0,17.0,4,3,6,4,1,0,2,2,0,0,,0,0,4,2,2,void
3672,200378,ThreadChangeWindowState,1,ThreadChangeWindowState,"void ThreadChangeWindowState (vout_thread_t*,unsigned)",video_output\video_output.c,"static void ThreadChangeWindowState(vout_thread_t *vout, unsigned state)
{
    vout_window_t *window = vout->p->window;

    if (window != NULL)
        vout_window_SetState(window, state);
#if defined(_WIN32) || defined(__OS2__)
    else /* FIXME: remove this event */
    if (vout->p->display.vd != NULL)
        vout_display_SendWindowState(vout->p->display.vd, state);
#endif
}",1380.0,1391.0,1.0,1.0,12.0,4,3,6,4,1,0,2,2,0,0,,0,0,4,2,2,void
3673,200400,ThreadChangeWindowMouse,1,ThreadChangeWindowMouse,"void ThreadChangeWindowMouse (vout_thread_t*,vout_window_mouse_event_t*)",video_output\video_output.c,"static void ThreadChangeWindowMouse(vout_thread_t *vout,
                                    const vout_window_mouse_event_t *mouse)
{
    vout_display_t *vd = vout->p->display.vd;
    switch (mouse->type)
    {
        case VOUT_WINDOW_MOUSE_STATE:
        case VOUT_WINDOW_MOUSE_MOVED:
        {
            vout_display_place_t place;
            vout_display_PlacePicture(&place, &vd->source, vd->cfg, false);

            if (place.width <= 0 || place.height <= 0)
                return;

            const int x = vd->source.i_x_offset +
                (int64_t)(mouse->x - place.x) *
                vd->source.i_visible_width / place.width;
            const int y = vd->source.i_y_offset +
                (int64_t)(mouse->y - place.y) *
                vd->source.i_visible_height/ place.height;

            if (mouse->type == VOUT_WINDOW_MOUSE_STATE)
                vout_display_SendEventMouseState(vd, x, y, mouse->button_mask);
            else
                vout_display_SendEv...",1393.0,1434.0,1.0,1.0,42.0,45,11,38,12,1,1,10,8,0,1,,0,0,4,2,2,void
3674,200558,ThreadChangeDisplayFilled,1,ThreadChangeDisplayFilled,"void ThreadChangeDisplayFilled (vout_thread_t*,bool)",video_output\video_output.c,"static void ThreadChangeDisplayFilled(vout_thread_t *vout, bool is_filled)
{
    vout_SetDisplayFilled(vout->p->display.vd, is_filled);
}",1436.0,1439.0,1.0,1.0,4.0,3,2,2,2,1,1,1,1,0,1,,0,0,4,2,2,void
3675,200573,ThreadChangeZoom,1,ThreadChangeZoom,"void ThreadChangeZoom (vout_thread_t*,int,int)",video_output\video_output.c,"static void ThreadChangeZoom(vout_thread_t *vout, int num, int den)
{
    if (num * 10 < den) {
        num = den;
        den *= 10;
    } else if (num > den * 10) {
        num = den * 10;
    }

    vout_SetDisplayZoom(vout->p->display.vd, num, den);
}",1441.0,1451.0,1.0,1.0,11.0,7,6,8,3,1,1,2,2,0,1,,0,0,6,3,3,void
3676,200617,ThreadChangeAspectRatio,1,ThreadChangeAspectRatio,"void ThreadChangeAspectRatio (vout_thread_t*,unsigned,unsigned)",video_output\video_output.c,"static void ThreadChangeAspectRatio(vout_thread_t *vout,
                                    unsigned num, unsigned den)
{
    vout_SetDisplayAspect(vout->p->display.vd, num, den);
}",1453.0,1457.0,1.0,1.0,5.0,3,2,3,3,1,1,1,1,0,1,,0,0,6,3,3,void
3677,200634,ThreadExecuteCropWindow,1,ThreadExecuteCropWindow,"void ThreadExecuteCropWindow (vout_thread_t*,unsigned,unsigned,unsigned,unsigned)",video_output\video_output.c,"static void ThreadExecuteCropWindow(vout_thread_t *vout,
                                    unsigned x, unsigned y,
                                    unsigned width, unsigned height)
{
    vout_SetDisplayCrop(vout->p->display.vd, 0, 0,
                        x, y, width, height);
}",1460.0,1466.0,1.0,1.0,7.0,3,2,5,5,1,1,1,1,0,1,,0,0,10,5,5,void
3678,200657,ThreadExecuteCropBorder,1,ThreadExecuteCropBorder,"void ThreadExecuteCropBorder (vout_thread_t*,unsigned,unsigned,unsigned,unsigned)",video_output\video_output.c,"static void ThreadExecuteCropBorder(vout_thread_t *vout,
                                    unsigned left, unsigned top,
                                    unsigned right, unsigned bottom)
{
    msg_Dbg(vout, ""ThreadExecuteCropBorder %d.%d %dx%d"", left, top, right, bottom);
    vout_SetDisplayCrop(vout->p->display.vd, 0, 0,
                        left, top, -(int)right, -(int)bottom);
}",1467.0,1474.0,1.0,1.0,8.0,7,4,10,5,1,1,1,1,0,1,,0,0,10,5,5,void
3679,200693,ThreadExecuteCropRatio,1,ThreadExecuteCropRatio,"void ThreadExecuteCropRatio (vout_thread_t*,unsigned,unsigned)",video_output\video_output.c,"static void ThreadExecuteCropRatio(vout_thread_t *vout,
                                   unsigned num, unsigned den)
{
    vout_SetDisplayCrop(vout->p->display.vd, num, den,
                        0, 0, 0, 0);
}",1476.0,1481.0,1.0,1.0,6.0,3,2,3,3,1,1,1,1,0,1,,0,0,6,3,3,void
3680,200714,ThreadExecuteViewpoint,1,ThreadExecuteViewpoint,"void ThreadExecuteViewpoint (vout_thread_t*,vlc_viewpoint_t*)",video_output\video_output.c,"static void ThreadExecuteViewpoint(vout_thread_t *vout,
                                   const vlc_viewpoint_t *p_viewpoint)
{
    vout_SetDisplayViewpoint(vout->p->display.vd, p_viewpoint);
}",1483.0,1487.0,1.0,1.0,5.0,3,2,2,2,1,1,1,1,0,1,,0,0,4,2,2,void
3681,200729,ThreadStart,1,ThreadStart,"int ThreadStart (vout_thread_t*,vout_display_state_t*)",video_output\video_output.c,"static int ThreadStart(vout_thread_t *vout, vout_display_state_t *state)
{
    vlc_mouse_Init(&vout->p->mouse);
    vout->p->decoder_fifo = picture_fifo_New();
    vout->p->decoder_pool = NULL;
    vout->p->display_pool = NULL;
    vout->p->private_pool = NULL;

    vout->p->filter.configuration = NULL;
    video_format_Copy(&vout->p->filter.format, &vout->p->original);

    filter_owner_t owner = {
        .sys = vout,
        .video = {
            .buffer_new = VoutVideoFilterStaticNewPicture,
        },
    };
    vout->p->filter.chain_static =
        filter_chain_NewVideo( vout, true, &owner );

    owner.video.buffer_new = VoutVideoFilterInteractiveNewPicture;
    vout->p->filter.chain_interactive =
        filter_chain_NewVideo( vout, true, &owner );

    vout_display_state_t state_default;
    if (!state) {
        VoutGetDisplayCfg(vout, &state_default.cfg, vout->p->display.title);

#if defined(_WIN32) || defined(__OS2__)
        bool below = var_InheritBool(vout, ""video-w...",1489.0,1567.0,1.0,1.0,79.0,130,8,76,13,2,12,9,7,2,12,,0,5,4,2,2,int
3682,201075,ThreadStop,1,ThreadStop,"void ThreadStop (vout_thread_t*,vout_display_state_t*)",video_output\video_output.c,"static void ThreadStop(vout_thread_t *vout, vout_display_state_t *state)
{
    if (vout->p->spu_blend)
        filter_DeleteBlend(vout->p->spu_blend);

    /* Destroy translation tables */
    if (vout->p->display.vd) {
        if (vout->p->decoder_pool) {
            ThreadFlush(vout, true, INT64_MAX);
            vout_EndWrapper(vout);
        }
        vout_CloseWrapper(vout, state);
    }

    /* Destroy the video filters */
    ThreadDelAllFilterCallbacks(vout);
    filter_chain_Delete(vout->p->filter.chain_interactive);
    filter_chain_Delete(vout->p->filter.chain_static);
    video_format_Clean(&vout->p->filter.format);
    free(vout->p->filter.configuration);

    if (vout->p->decoder_fifo)
        picture_fifo_Delete(vout->p->decoder_fifo);
    assert(!vout->p->decoder_pool);
}",1569.0,1593.0,1.0,1.0,25.0,29,4,18,4,3,8,5,6,0,8,,0,0,4,2,2,void
3683,201174,ThreadInit,1,ThreadInit,void ThreadInit (vout_thread_t*),video_output\video_output.c,"static void ThreadInit(vout_thread_t *vout)
{
    vout->p->dead            = false;
    vout->p->is_late_dropped = var_InheritBool(vout, ""drop-late-frames"");
    vout->p->pause.is_on     = false;
    vout->p->pause.date      = VLC_TS_INVALID;

    vout_chrono_Init(&vout->p->render, 5, 10000); /* Arbitrary initial time */
}",1595.0,1603.0,1.0,1.0,9.0,17,4,9,3,1,1,1,1,0,1,,0,0,2,1,1,void
3684,201222,ThreadClean,1,ThreadClean,void ThreadClean (vout_thread_t*),video_output\video_output.c,"static void ThreadClean(vout_thread_t *vout)
{
    vout_chrono_Clean(&vout->p->render);
    vout->p->dead = true;
    vout_control_Dead(&vout->p->control);
}",1605.0,1610.0,1.0,1.0,6.0,9,3,4,2,4,2,1,1,0,2,,0,0,2,1,1,void
3685,201248,ThreadReinit,1,ThreadReinit,"int ThreadReinit (vout_thread_t*,vout_configuration_t*)",video_output\video_output.c,"static int ThreadReinit(vout_thread_t *vout,
                        const vout_configuration_t *cfg)
{
    video_format_t original;

    vout->p->pause.is_on = false;
    vout->p->pause.date  = VLC_TS_INVALID;

    if (VoutValidateFormat(&original, cfg->fmt)) {
        ThreadStop(vout, NULL);
        ThreadClean(vout);
        return VLC_EGENERIC;
    }

    /* We ignore ar changes at this point, they are dynamically supported.
     * #19268: don't ignore crop changes (fix vouts using the crop size of the
     * previous format). */
    vout->p->original.i_sar_num = original.i_sar_num;
    vout->p->original.i_sar_den = original.i_sar_den;
    if (video_format_IsSimilar(&original, &vout->p->original)) {
        if (cfg->dpb_size <= vout->p->dpb_size) {
            video_format_Clean(&original);
            return VLC_SUCCESS;
        }
        msg_Warn(vout, ""DPB need to be increased"");
    }

    vout_display_state_t state;
    memset(&state, 0, sizeof(state));

    ThreadStop(vout...",1612.0,1674.0,1.0,1.0,63.0,92,7,47,9,1,8,7,8,3,8,,0,3,4,2,2,int
3686,201500,ThreadCancel,1,ThreadCancel,"void ThreadCancel (vout_thread_t*,bool)",video_output\video_output.c,"static void ThreadCancel(vout_thread_t *vout, bool canceled)
{
    picture_pool_Cancel(vout->p->decoder_pool, canceled);
}",1676.0,1679.0,1.0,1.0,4.0,2,1,2,2,1,1,1,1,0,1,,0,0,4,2,2,void
3687,201513,ThreadControl,1,ThreadControl,"int ThreadControl (vout_thread_t*,vout_control_cmd_t)",video_output\video_output.c,"static int ThreadControl(vout_thread_t *vout, vout_control_cmd_t cmd)
{
    switch(cmd.type) {
    case VOUT_CONTROL_INIT:
        ThreadInit(vout);
        if (ThreadStart(vout, NULL))
        {
            ThreadClean(vout);
            return 1;
        }
        break;
    case VOUT_CONTROL_CLEAN:
        ThreadStop(vout, NULL);
        ThreadClean(vout);
        return 1;
    case VOUT_CONTROL_REINIT:
        if (ThreadReinit(vout, cmd.u.cfg))
            return 1;
        break;
    case VOUT_CONTROL_CANCEL:
        ThreadCancel(vout, cmd.u.boolean);
        break;
    case VOUT_CONTROL_SUBPICTURE:
        ThreadDisplaySubpicture(vout, cmd.u.subpicture);
        cmd.u.subpicture = NULL;
        break;
    case VOUT_CONTROL_FLUSH_SUBPICTURE:
        ThreadFlushSubpicture(vout, cmd.u.integer);
        break;
    case VOUT_CONTROL_OSD_TITLE:
        ThreadDisplayOsdTitle(vout, cmd.u.string);
        break;
    case VOUT_CONTROL_CHANGE_FILTERS:
        ThreadChangeFilters(vout, NU...",1681.0,1780.0,1.0,1.0,100.0,101,7,101,29,0,65,29,6,4,29,,0,38,4,2,2,int
3688,202021,OSDTextValidate,1,OSDTextValidate,"int OSDTextValidate (subpicture_t*,bool,video_format_t*,bool,video_format_t*,mtime_t)",video_output\video_text.c,"static int OSDTextValidate(subpicture_t *subpic,
                           bool has_src_changed, const video_format_t *fmt_src,
                           bool has_dst_changed, const video_format_t *fmt_dst,
                           mtime_t ts)
{
    VLC_UNUSED(subpic); VLC_UNUSED(ts);
    VLC_UNUSED(fmt_src); VLC_UNUSED(has_src_changed);
    VLC_UNUSED(fmt_dst);

    if( !has_dst_changed )
        return VLC_SUCCESS;
    return VLC_EGENERIC;
}",39.0,51.0,1.0,1.0,13.0,1,1,8,8,0,0,2,2,0,0,,0,0,12,6,6,int
3689,202049,OSDTextUpdate,1,OSDTextUpdate,"void OSDTextUpdate (subpicture_t*,video_format_t*,video_format_t*,mtime_t)",video_output\video_text.c,"static void OSDTextUpdate(subpicture_t *subpic,
                          const video_format_t *fmt_src,
                          const video_format_t *fmt_dst,
                          mtime_t ts)
{
    subpicture_updater_sys_t *sys = subpic->updater.p_sys;
    VLC_UNUSED(fmt_src); VLC_UNUSED(ts);

    if( fmt_dst->i_sar_num <= 0 || fmt_dst->i_sar_den <= 0 )
        return;

    subpic->b_absolute = false;
    subpic->i_original_picture_width  = fmt_dst->i_visible_width * fmt_dst->i_sar_num / fmt_dst->i_sar_den;
    subpic->i_original_picture_height = fmt_dst->i_visible_height;

    video_format_t fmt;
    video_format_Init( &fmt, VLC_CODEC_TEXT);
    fmt.i_sar_num = 1;
    fmt.i_sar_den = 1;

    subpicture_region_t *r = subpic->p_region = subpicture_region_New(&fmt);
    if (!r)
        return;

    r->p_text = text_segment_New( sys->text );

    const float margin_ratio = 0.04;
    const int   margin_h     = margin_ratio * fmt_dst->i_visible_width;
    const int   margin_v    ...",53.0,96.0,1.0,1.0,44.0,62,12,47,14,0,5,5,5,0,2,,0,5,8,4,4,void
3690,202260,OSDTextDestroy,1,OSDTextDestroy,void OSDTextDestroy (subpicture_t*),video_output\video_text.c,"static void OSDTextDestroy(subpicture_t *subpic)
{
    subpicture_updater_sys_t *sys = subpic->updater.p_sys;

    free(sys->text);
    free(sys);
}",98.0,104.0,1.0,1.0,7.0,4,3,4,2,0,1,1,1,0,0,,0,1,2,1,1,void
3691,202279,vout_OSDText,1,vout_OSDText,"void vout_OSDText (vout_thread_t*,int,int,mtime_t,char*)",video_output\video_text.c,"void vout_OSDText(vout_thread_t *vout, int channel,
                   int position, mtime_t duration, const char *text)
{
    assert( (position & ~SUBPICTURE_ALIGN_MASK) == 0);
    if (!var_InheritBool(vout, ""osd"") || duration <= 0)
        return;

    subpicture_updater_sys_t *sys = malloc(sizeof(*sys));
    if (!sys)
        return;
    sys->position = position;
    sys->text     = strdup(text);

    subpicture_updater_t updater = {
        .pf_validate = OSDTextValidate,
        .pf_update   = OSDTextUpdate,
        .pf_destroy  = OSDTextDestroy,
        .p_sys       = sys,
    };
    subpicture_t *subpic = subpicture_New(&updater);
    if (!subpic) {
        free(sys->text);
        free(sys);
        return;
    }

    subpic->i_channel  = channel;
    subpic->i_start    = mdate();
    subpic->i_stop     = subpic->i_start + duration;
    subpic->b_ephemer  = true;
    subpic->b_absolute = false;
    subpic->b_fade     = true;

    vout_PutSubpicture(vout, subpic);
}",106.0,140.0,1.0,1.0,35.0,38,13,36,15,2,6,4,4,0,3,,0,5,10,5,5,void
3692,202403,vout_OSDMessage,1,vout_OSDMessage,"void vout_OSDMessage (vout_thread_t*,int,char*...)",video_output\video_text.c,"void vout_OSDMessage(vout_thread_t *vout, int channel, const char *format, ...)
{
    va_list args;
    va_start(args, format);

    char *string;
    if (vasprintf(&string, format, args) != -1) {
        vout_OSDText(vout, channel,
                     SUBPICTURE_ALIGN_TOP|SUBPICTURE_ALIGN_RIGHT, 1000000,
                     string);
        free(string);
    }
    va_end(args);
}",142.0,155.0,1.0,1.0,14.0,4,4,12,7,5,1,2,2,0,1,,0,0,6,3,3,void
3693,202456,DrawRect,1,DrawRect,"void DrawRect (subpicture_region_t*,int,uint8_t,int,int,int,int)",video_output\video_widgets.c,"static void DrawRect(subpicture_region_t *r, int fill, uint8_t color,
                     int x1, int y1, int x2, int y2)
{
    uint8_t *p    = r->p_picture->p->p_pixels;
    int     pitch = r->p_picture->p->i_pitch;
    if( x1 > x2 || y1 > y2 )
        return;

    if (fill == STYLE_FILLED) {
        if(x1 == 0 && x2 + 1 == r->p_picture->p->i_visible_pitch) {
            memset(&p[pitch * y1], color, pitch * (y2 - y1 + 1));
        } else {
            for (int y = y1; y <= y2; y++)
                memset(&p[x1 + pitch * y], color, x2 - x1 + 1);
        }
    } else {
        DrawRect(r, STYLE_FILLED, color, x1, y1, x1, y2);
        DrawRect(r, STYLE_FILLED, color, x2, y1, x2, y2);
        DrawRect(r, STYLE_FILLED, color, x1, y1, x2, y1);
        DrawRect(r, STYLE_FILLED, color, x1, y2, x2, y2);
    }
}",63.0,84.0,1.0,16.0,22.0,25,11,19,9,7,0,4,5,0,0,,0,0,14,7,7,void
3694,202606,DrawTriangle,1,DrawTriangle,"void DrawTriangle (subpicture_region_t*,int,uint8_t,int,int,int,int)",video_output\video_widgets.c,"static void DrawTriangle(subpicture_region_t *r, int fill, uint8_t color,
                         int x1, int y1, int x2, int y2)
{
    uint8_t *p    = r->p_picture->p->p_pixels;
    int     pitch = r->p_picture->p->i_pitch;
    const int mid = y1 + (y2 - y1) / 2;
    const bool b_swap = (x1 > x2);

    for (int y = y1; y <= mid; y++) {
        const int h = y - y1;
        if (fill == STYLE_FILLED) {
            const int w = b_swap ? __MAX(x1 - h, x2) : __MIN(x1 + h, x2);
            DrawRect(r, STYLE_FILLED, color,
                     (b_swap) ? w : x1, y, (b_swap) ? x1 : w, y);
            DrawRect(r, STYLE_FILLED, color,
                     (b_swap) ? w : x1, y2 - h, (b_swap) ? x1 : w, y2 - h);
        } else {
            p[x1 +                     pitch * y       ] = color;
            p[x1 + (b_swap ? -h : h) + pitch * y       ] = color;
            p[x1 +                     pitch * (y2 - h)] = color;
            p[x1 + (b_swap ? -h : h) + pitch * (y2 - h)] = color;
    ...",90.0,113.0,1.0,20.0,24.0,29,9,49,14,0,2,3,4,0,2,,0,0,14,7,7,void
3695,202783,OSDRegion,1,OSDRegion,"subpicture_region_t OSDRegion (int,int,int,int)",video_output\video_widgets.c,"static subpicture_region_t *OSDRegion(int x, int y, int width, int height)
{
    if( width == 0 || height == 0 )
        return NULL;

    video_palette_t palette;
    SET_PALETTE_COLOR(COL_WHITE,       0xffffff, STYLE_ALPHA_OPAQUE)
    SET_PALETTE_COLOR(COL_TRANSPARENT, 0xffffff, STYLE_ALPHA_TRANSPARENT)
    SET_PALETTE_COLOR(COL_FILL,        RGB_FILL, 0xA0)
    SET_PALETTE_COLOR(COL_FILL_SHADE,  RGB_FILL, 0x25)
    palette.i_entries = 4;

    video_format_t fmt;
    video_format_Init(&fmt, VLC_CODEC_YUVP);
    fmt.i_width          =
    fmt.i_visible_width  = width;
    fmt.i_height         =
    fmt.i_visible_height = height;
    fmt.i_sar_num        = 1;
    fmt.i_sar_den        = 1;
    fmt.p_palette        = &palette;

    subpicture_region_t *r = subpicture_region_New(&fmt);
    if (!r)
        return NULL;
    r->i_x = x;
    r->i_y = y;

    return r;
}",118.0,147.0,1.0,4.0,30.0,176,15,41,16,2,1,3,3,0,1,,0,1,8,4,4,subpicture_region_t
3696,203205,OSDSlider,1,OSDSlider,"subpicture_region_t OSDSlider (int,int,video_format_t*)",video_output\video_widgets.c,"static subpicture_region_t *OSDSlider(int type, int position,
                                      const video_format_t *fmt)
{
    const int size = __MAX(fmt->i_visible_width, fmt->i_visible_height);
    const int margin = size * SLIDER_MARGIN_BASE;
    const int marginbottom = margin * 0.2;
    const int marginright = margin * 0.5;
    uint8_t i_padding = __MIN(1, size * 0.25); /* small sizes */

    int x, y;
    int width, height;
    if (type == OSD_HOR_SLIDER) {
        width  = __MAX(fmt->i_visible_width - 2 * margin, 1);
        height = __MAX(fmt->i_visible_height * 0.01,      1);
        x      = __MIN(fmt->i_x_offset + margin, fmt->i_visible_width - width);
        y      = __MAX(fmt->i_y_offset + fmt->i_visible_height - marginbottom, 0);
    } else {
        width  = __MAX(fmt->i_visible_width * 0.010,       1);
        height = __MAX(fmt->i_visible_height - 2 * margin, 1);
        x      = __MAX(fmt->i_x_offset + fmt->i_visible_width - marginright, 0);
        y      =...",154.0,201.0,1.0,30.0,48.0,52,10,62,19,1,3,5,5,0,3,,0,1,6,3,3,subpicture_region_t
3697,203473,OSDIcon,1,OSDIcon,"subpicture_region_t OSDIcon (int,video_format_t*)",video_output\video_widgets.c,"static subpicture_region_t *OSDIcon(int type, const video_format_t *fmt)
{
    const float size_ratio   = 0.05;
    const float margin_ratio = 0.07;

    const int size   = __MAX(fmt->i_visible_width, fmt->i_visible_height);
    const int width  = size * size_ratio;
    const int height = size * size_ratio;
    const int x      = fmt->i_x_offset + fmt->i_visible_width - margin_ratio * size - width;
    const int y      = fmt->i_y_offset                        + margin_ratio * size;

    if( width < 1 || height < 1 )
        return NULL;

    subpicture_region_t *r = OSDRegion(__MAX(x, 0),
                                       __MIN(y, (int)fmt->i_visible_height - height),
                                       width, height);
    if (!r)
        return NULL;

    DrawRect(r, STYLE_FILLED, COL_TRANSPARENT, 0, 0, width - 1, height - 1);

    if (type == OSD_PAUSE_ICON) {
        int bar_width = width / 3;
        DrawRect(r, STYLE_FILLED, COL_WHITE, 0, 0, bar_width - 1, height -1);
 ...",207.0,250.0,1.0,16.0,44.0,38,11,49,13,0,4,4,4,0,4,,0,1,4,2,2,subpicture_region_t
3698,203779,OSDWidgetValidate,1,OSDWidgetValidate,"int OSDWidgetValidate (subpicture_t*,bool,video_format_t*,bool,video_format_t*,mtime_t)",video_output\video_widgets.c,"static int OSDWidgetValidate(subpicture_t *subpic,
                           bool has_src_changed, const video_format_t *fmt_src,
                           bool has_dst_changed, const video_format_t *fmt_dst,
                           mtime_t ts)
{
    VLC_UNUSED(subpic); VLC_UNUSED(ts);
    VLC_UNUSED(fmt_src); VLC_UNUSED(has_src_changed);
    VLC_UNUSED(fmt_dst);

    if (!has_dst_changed)
        return VLC_SUCCESS;
    return VLC_EGENERIC;
}",257.0,269.0,1.0,1.0,13.0,1,1,8,8,0,0,2,2,0,0,,0,0,12,6,6,int
3699,203807,OSDWidgetUpdate,1,OSDWidgetUpdate,"void OSDWidgetUpdate (subpicture_t*,video_format_t*,video_format_t*,mtime_t)",video_output\video_widgets.c,"static void OSDWidgetUpdate(subpicture_t *subpic,
                          const video_format_t *fmt_src,
                          const video_format_t *fmt_dst,
                          mtime_t ts)
{
    subpicture_updater_sys_t *sys = subpic->updater.p_sys;
    VLC_UNUSED(fmt_src); VLC_UNUSED(ts);

    video_format_t fmt = *fmt_dst;
    fmt.i_width         = fmt.i_width         * fmt.i_sar_num / fmt.i_sar_den;
    fmt.i_visible_width = fmt.i_visible_width * fmt.i_sar_num / fmt.i_sar_den;
    fmt.i_x_offset      = fmt.i_x_offset      * fmt.i_sar_num / fmt.i_sar_den;
    fmt.i_sar_num       = 1;
    fmt.i_sar_den       = 1;

    subpic->i_original_picture_width  = fmt.i_visible_width;
    subpic->i_original_picture_height = fmt.i_visible_height;
    if (sys->type == OSD_HOR_SLIDER || sys->type == OSD_VERT_SLIDER)
        subpic->p_region = OSDSlider(sys->type, sys->position, &fmt);
    else
        subpic->p_region = OSDIcon(sys->type, &fmt);
}",271.0,292.0,1.0,1.0,22.0,46,9,32,8,0,5,2,2,2,1,,0,5,8,4,4,void
3700,203939,OSDWidgetDestroy,1,OSDWidgetDestroy,void OSDWidgetDestroy (subpicture_t*),video_output\video_widgets.c,"static void OSDWidgetDestroy(subpicture_t *subpic)
{
    free(subpic->updater.p_sys);
}",294.0,297.0,1.0,1.0,4.0,2,2,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
3701,203950,OSDWidget,1,OSDWidget,"void OSDWidget (vout_thread_t*,int,int,int)",video_output\video_widgets.c,"static void OSDWidget(vout_thread_t *vout, int channel, int type, int position)
{
    if (!var_InheritBool(vout, ""osd""))
        return;
    if (type == OSD_HOR_SLIDER || type == OSD_VERT_SLIDER)
        position = VLC_CLIP(position, 0, 100);

    subpicture_updater_sys_t *sys = malloc(sizeof(*sys));
    if (!sys)
        return;
    sys->type     = type;
    sys->position = position;

    subpicture_updater_t updater = {
        .pf_validate = OSDWidgetValidate,
        .pf_update   = OSDWidgetUpdate,
        .pf_destroy  = OSDWidgetDestroy,
        .p_sys       = sys,
    };
    subpicture_t *subpic = subpicture_New(&updater);
    if (!subpic) {
        free(sys);
        return;
    }

    subpic->i_channel  = channel;
    subpic->i_start    = mdate();
    subpic->i_stop     = subpic->i_start + 1200000;
    subpic->b_ephemer  = true;
    subpic->b_absolute = true;
    subpic->b_fade     = true;

    vout_PutSubpicture(vout, subpic);
}",299.0,332.0,1.0,1.0,34.0,36,10,37,14,2,5,5,5,0,3,,0,4,8,4,4,void
3702,204072,vout_OSDSlider,1,vout_OSDSlider,"void vout_OSDSlider (vout_thread_t*,int,int,short)",video_output\video_widgets.c,"void vout_OSDSlider(vout_thread_t *vout, int channel, int position, short type)
{
    OSDWidget(vout, channel, type, position);
}",334.0,337.0,1.0,1.0,4.0,0,0,4,4,0,1,1,1,0,1,,0,0,8,4,4,void
3703,204085,vout_OSDIcon,1,vout_OSDIcon,"void vout_OSDIcon (vout_thread_t*,int,short)",video_output\video_widgets.c,"void vout_OSDIcon(vout_thread_t *vout, int channel, short type )
{
    OSDWidget(vout, channel, type, 0);
}",339.0,342.0,1.0,1.0,4.0,0,0,3,3,0,1,1,1,0,1,,0,0,6,3,3,void
3704,204111,spu_OffsetSubtitleDate,1,spu_OffsetSubtitleDate,"void spu_OffsetSubtitleDate (spu_t*,mtime_t)",video_output\vout_subpictures.c,"void spu_OffsetSubtitleDate(spu_t *spu, mtime_t duration)
{
    spu_private_t *sys = spu->p;

    vlc_mutex_lock(&sys->lock);
    for (int i = 0; i < VOUT_MAX_SUBPICTURES; i++) {
        spu_heap_entry_t *entry = &sys->heap.entry[i];
        subpicture_t *current = entry->subpicture;

        if (current && current->b_subtitle) {
            if (current->i_start > 0)
                current->i_start += duration;
            if (current->i_stop > 0)
                current->i_stop  += duration;
        }
    }
    vlc_mutex_unlock(&sys->lock);
}",1622.0,1639.0,1.0,24.0,18.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
3705,204331,vout_IntfInit,1,vout_IntfInit,void vout_IntfInit (vout_thread_t*),video_output\vout_intf.c,"void vout_IntfInit( vout_thread_t *p_vout )
{
    vlc_value_t val, text;
    char *psz_buf;

    /* Create a few object variables we'll need later on */
    var_Create( p_vout, ""snapshot-num"", VLC_VAR_INTEGER );
    var_SetInteger( p_vout, ""snapshot-num"", 1 );

    var_Create( p_vout, ""width"", VLC_VAR_INTEGER | VLC_VAR_DOINHERIT );
    var_Create( p_vout, ""height"", VLC_VAR_INTEGER | VLC_VAR_DOINHERIT );
    var_Create( p_vout, ""align"", VLC_VAR_INTEGER | VLC_VAR_DOINHERIT );

    var_Create( p_vout, ""mouse-hide-timeout"",
                VLC_VAR_INTEGER | VLC_VAR_DOINHERIT );

    /* Add variables to manage scaling video */
    var_Create( p_vout, ""autoscale"", VLC_VAR_BOOL | VLC_VAR_DOINHERIT
                | VLC_VAR_ISCOMMAND );
    text.psz_string = _(""Autoscale video"");
    var_Change( p_vout, ""autoscale"", VLC_VAR_SETTEXT, &text, NULL );
    var_AddCallback( p_vout, ""autoscale"", AutoScaleCallback, NULL );

    var_Create( p_vout, ""zoom"", VLC_VAR_FLOAT | VLC_VAR_ISCOMMAND |
       ...",150.0,312.0,1.0,1.0,163.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
3706,204336,vout_IntfReinit,1,vout_IntfReinit,void vout_IntfReinit (vout_thread_t*),video_output\vout_intf.c,"void vout_IntfReinit( vout_thread_t *p_vout )
{
    var_TriggerCallback( p_vout, ""zoom"" );
    var_TriggerCallback( p_vout, ""crop"" );
    var_TriggerCallback( p_vout, ""aspect-ratio"" );

    var_TriggerCallback( p_vout, ""video-on-top"" );
    var_TriggerCallback( p_vout, ""video-wallpaper"" );

    var_TriggerCallback( p_vout, ""video-filter"" );
    var_TriggerCallback( p_vout, ""sub-source"" );
    var_TriggerCallback( p_vout, ""sub-filter"" );
    var_TriggerCallback( p_vout, ""sub-margin"" );
}",314.0,327.0,1.0,1.0,14.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
3707,204341,vout_OpenWrapper,1,vout_OpenWrapper,"int vout_OpenWrapper (vout_thread_t*,char*,vout_display_state_t*)",video_output\vout_wrapper.c,"int vout_OpenWrapper(vout_thread_t *vout,
                     const char *splitter_name, const vout_display_state_t *state)
{
    vout_thread_sys_t *sys = vout->p;
    msg_Dbg(vout, ""Opening vout display wrapper"");

    /* */
    sys->display.title = var_InheritString(vout, ""video-title"");

    /* */
    const mtime_t double_click_timeout = 300000;
    const mtime_t hide_timeout = var_CreateGetInteger(vout, ""mouse-hide-timeout"") * 1000;

    if (splitter_name) {
        sys->display.vd = vout_NewSplitter(vout, &vout->p->original, state, ""$vout"", splitter_name,
                                           double_click_timeout, hide_timeout);
    } else {
        sys->display.vd = vout_NewDisplay(vout, &vout->p->original, state, ""$vout"",
                                          double_click_timeout, hide_timeout);
    }
    if (!sys->display.vd) {
        free(sys->display.title);
        return VLC_EGENERIC;
    }

    /* */
#ifdef _WIN32
    var_Create(vout, ""video-wallpaper"", VLC_V...",50.0,85.0,1.0,1.0,36.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,int
3708,204348,vout_CloseWrapper,1,vout_CloseWrapper,"void vout_CloseWrapper (vout_thread_t*,vout_display_state_t*)",video_output\vout_wrapper.c,"void vout_CloseWrapper(vout_thread_t *vout, vout_display_state_t *state)
{
    vout_thread_sys_t *sys = vout->p;

#ifdef _WIN32
    var_DelCallback(vout, ""video-wallpaper"", Forward, NULL);
#endif
    sys->decoder_pool = NULL; /* FIXME remove */

    vout_DeleteDisplay(sys->display.vd, state);
    free(sys->display.title);
}",90.0,101.0,1.0,1.0,12.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,void
3709,204354,vout_InitWrapper,1,vout_InitWrapper,int vout_InitWrapper (vout_thread_t*),video_output\vout_wrapper.c,"int vout_InitWrapper(vout_thread_t *vout)
{
    vout_thread_sys_t *sys = vout->p;
    vout_display_t *vd = sys->display.vd;

    sys->display.use_dr = !vout_IsDisplayFiltered(vd);
    const bool allow_dr = !vd->info.has_pictures_invalid && !vd->info.is_slow && sys->display.use_dr;
    const unsigned private_picture  = 4; /* XXX 3 for filter, 1 for SPU */
    const unsigned decoder_picture  = 1 + sys->dpb_size;
    const unsigned kept_picture     = 1; /* last displayed picture */
    const unsigned reserved_picture = DISPLAY_PICTURE_COUNT +
                                      private_picture +
                                      kept_picture;
    const unsigned display_pool_size = allow_dr ? __MAX(VOUT_MAX_PICTURES,
                                                        reserved_picture + decoder_picture) : 3;
    picture_pool_t *display_pool = vout_display_Pool(vd, display_pool_size);
    if (display_pool == NULL)
        return VLC_EGENERIC;

#ifndef NDEBUG
    if ( picture_po...",119.0,173.0,1.0,38.0,55.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
3710,204359,vout_EndWrapper,1,vout_EndWrapper,void vout_EndWrapper (vout_thread_t*),video_output\vout_wrapper.c,"void vout_EndWrapper(vout_thread_t *vout)
{
    vout_thread_sys_t *sys = vout->p;

    assert(vout->p->decoder_pool && vout->p->private_pool);

    picture_pool_Release(sys->private_pool);

    if (sys->decoder_pool != sys->display_pool)
        picture_pool_Release(sys->decoder_pool);
}",178.0,188.0,1.0,1.0,11.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
3711,204364,vout_ManageWrapper,1,vout_ManageWrapper,void vout_ManageWrapper (vout_thread_t*),video_output\vout_wrapper.c,"void vout_ManageWrapper(vout_thread_t *vout)
{
    vout_thread_sys_t *sys = vout->p;
    vout_display_t *vd = sys->display.vd;

    bool reset_display_pool = vout_AreDisplayPicturesInvalid(vd);
    reset_display_pool |= vout_ManageDisplay(vd, !sys->display.use_dr || reset_display_pool);

    if (reset_display_pool) {
        sys->display.use_dr = !vout_IsDisplayFiltered(vd);
        NoDrInit(vout);
    }
}",193.0,205.0,1.0,1.0,13.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
3712,204369,spu_ProcessMouse,1,spu_ProcessMouse,"int spu_ProcessMouse (spu_t*,vlc_mouse_t*,video_format_t*)",video_output\vout_subpictures.c,"int spu_ProcessMouse(spu_t *spu,
                     const vlc_mouse_t *mouse,
                     const video_format_t *fmt)
{
    spu_private_t *sys = spu->p;

    vlc_mutex_lock(&sys->source_chain_lock);
    filter_chain_MouseEvent(sys->source_chain, mouse, fmt);
    vlc_mutex_unlock(&sys->source_chain_lock);

    return VLC_SUCCESS;
}",1423.0,1434.0,1.0,1.0,12.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,int
3713,204376,spu_Attach,1,spu_Attach,"void spu_Attach (spu_t*,vlc_object_t*,ANY)",video_output\vout_subpictures.c,"void spu_Attach(spu_t *spu, vlc_object_t *input, bool attach)
{
    if (attach) {
        UpdateSPU(spu, input);
        var_Create(input, ""highlight"", VLC_VAR_BOOL);
        var_AddCallback(input, ""highlight"", CropCallback, spu);

        vlc_mutex_lock(&spu->p->lock);
        spu->p->input = input;

        if (spu->p->text)
            FilterRelease(spu->p->text);
        spu->p->text = SpuRenderCreateAndLoadText(spu);

        vlc_mutex_unlock(&spu->p->lock);
    } else {
        vlc_mutex_lock(&spu->p->lock);
        spu->p->input = NULL;
        vlc_mutex_unlock(&spu->p->lock);

        /* Delete callbacks */
        var_DelCallback(input, ""highlight"", CropCallback, spu);
        var_Destroy(input, ""highlight"");
    }
}",1394.0,1418.0,1.0,1.0,25.0,0,0,0,0,4,0,1,1,0,0,,0,0,6,3,3,void
3714,204383,spu_ChangeMargin,1,spu_ChangeMargin,"void spu_ChangeMargin (spu_t*,int)",video_output\vout_subpictures.c,"void spu_ChangeMargin(spu_t *spu, int margin)
{
    spu_private_t *sys = spu->p;

    vlc_mutex_lock(&sys->lock);
    sys->margin = margin;
    vlc_mutex_unlock(&sys->lock);
}",1712.0,1719.0,1.0,1.0,8.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
3715,204418,CropCallback,1,CropCallback,"int CropCallback (vlc_object_t*,char*,ANY,ANY,void*)",video_output\vout_subpictures.c,"static int CropCallback(vlc_object_t *object, char const *var,
                        vlc_value_t oldval, vlc_value_t newval, void *data)
{
    VLC_UNUSED(oldval); VLC_UNUSED(newval); VLC_UNUSED(var);

    UpdateSPU((spu_t *)data, object);
    return VLC_SUCCESS;
}",1194.0,1201.0,1.0,1.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,int
3716,204427,CropBorderCallback,1,CropBorderCallback,"int CropBorderCallback (vlc_object_t*,char*,ANY,ANY,void*)",video_output\vout_intf.c,"static int CropBorderCallback(vlc_object_t *object, char const *cmd,
                              vlc_value_t oldval, vlc_value_t newval, void *data)
{
    char buf[4 * 21];

    snprintf(buf, sizeof (buf), ""%""PRIu64""+%""PRIu64""+%""PRIu64""+%""PRIu64,
             var_GetInteger(object, ""crop-left""),
             var_GetInteger(object, ""crop-top""),
             var_GetInteger(object, ""crop-right""),
             var_GetInteger(object, ""crop-bottom""));
    var_SetString(object, ""crop"", buf);

    VLC_UNUSED(cmd); VLC_UNUSED(oldval); VLC_UNUSED(data); VLC_UNUSED(newval);
    return VLC_SUCCESS;
}",468.0,482.0,1.0,1.0,15.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,int
3717,204436,AspectCallback,1,AspectCallback,"int AspectCallback (vlc_object_t*,char*,ANY,ANY,void*)",video_output\vout_intf.c,"static int AspectCallback( vlc_object_t *object, char const *cmd,
                         vlc_value_t oldval, vlc_value_t newval, void *data )
{
    vout_thread_t *vout = (vout_thread_t *)object;
    VLC_UNUSED(cmd); VLC_UNUSED(oldval); VLC_UNUSED(data);
    unsigned num, den;

    if (sscanf(newval.psz_string, ""%u:%u"", &num, &den) == 2 &&
        (num != 0) == (den != 0))
        vout_ControlChangeSampleAspectRatio(vout, num, den);
    else if (*newval.psz_string == '\0')
        vout_ControlChangeSampleAspectRatio(vout, 0, 0);
    return VLC_SUCCESS;
}",484.0,497.0,1.0,1.0,14.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,int
3718,204445,AutoScaleCallback,1,AutoScaleCallback,"int AutoScaleCallback (vlc_object_t*,char*,ANY,ANY,void*)",video_output\vout_intf.c,"static int AutoScaleCallback( vlc_object_t *obj, char const *name,
                              vlc_value_t prev, vlc_value_t cur, void *data )
{
    vout_thread_t *p_vout = (vout_thread_t *)obj;

    (void) name; (void) prev; (void) data;
    vout_ControlChangeDisplayFilled( p_vout, cur.b_bool );
    return VLC_SUCCESS;
}",499.0,507.0,1.0,1.0,9.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,int
3719,204454,ZoomCallback,1,ZoomCallback,"int ZoomCallback (vlc_object_t*,char*,ANY,ANY,void*)",video_output\vout_intf.c,"static int ZoomCallback( vlc_object_t *obj, char const *name,
                         vlc_value_t prev, vlc_value_t cur, void *data )
{
    vout_thread_t *p_vout = (vout_thread_t *)obj;

    (void) name; (void) prev; (void) data;
    vout_ControlChangeZoom( p_vout, 1000 * cur.f_float, 1000 );
    return VLC_SUCCESS;
}",509.0,517.0,1.0,1.0,9.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,int
3720,204463,AboveCallback,1,AboveCallback,"int AboveCallback (vlc_object_t*,char*,ANY,ANY,void*)",video_output\vout_intf.c,"static int AboveCallback( vlc_object_t *obj, char const *name,
                          vlc_value_t prev, vlc_value_t cur, void *data )
{
    vout_ControlChangeWindowState( (vout_thread_t *)obj,
        cur.b_bool ? VOUT_WINDOW_STATE_ABOVE : VOUT_WINDOW_STATE_NORMAL );
    (void) name; (void) prev; (void) data;
    return VLC_SUCCESS;
}",519.0,526.0,1.0,1.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,int
3721,204472,WallPaperCallback,1,WallPaperCallback,"int WallPaperCallback (vlc_object_t*,char*,ANY,ANY,void*)",video_output\vout_intf.c,"static int WallPaperCallback( vlc_object_t *obj, char const *name,
                              vlc_value_t prev, vlc_value_t cur, void *data )
{
    vout_thread_t *vout = (vout_thread_t *)obj;

    if( cur.b_bool )
    {
        vout_ControlChangeWindowState( vout, VOUT_WINDOW_STATE_BELOW );
        vout_ControlChangeFullscreen( vout, true );
    }
    else
    {
        var_TriggerCallback( obj, ""fullscreen"" );
        var_TriggerCallback( obj, ""video-on-top"" );
    }
    (void) name; (void) prev; (void) data;
    return VLC_SUCCESS;
}",528.0,545.0,1.0,1.0,18.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,int
3722,204481,FullscreenCallback,1,FullscreenCallback,"int FullscreenCallback (vlc_object_t*,char*,ANY,ANY,void*)",video_output\vout_intf.c,"static int FullscreenCallback( vlc_object_t *p_this, char const *psz_cmd,
                       vlc_value_t oldval, vlc_value_t newval, void *p_data )
{
    vout_thread_t *p_vout = (vout_thread_t *)p_this;
    (void)psz_cmd; (void)p_data;

    if( oldval.b_bool != newval.b_bool )
        vout_ControlChangeFullscreen( p_vout, newval.b_bool );
    return VLC_SUCCESS;
}",547.0,556.0,1.0,1.0,10.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,int
3723,204490,SnapshotCallback,1,SnapshotCallback,"int SnapshotCallback (vlc_object_t*,char*,ANY,ANY,void*)",video_output\vout_intf.c,"static int SnapshotCallback( vlc_object_t *p_this, char const *psz_cmd,
                       vlc_value_t oldval, vlc_value_t newval, void *p_data )
{
    vout_thread_t *p_vout = (vout_thread_t *)p_this;
    VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval);
    VLC_UNUSED(newval); VLC_UNUSED(p_data);

    VoutSaveSnapshot( p_vout );
    return VLC_SUCCESS;
}",558.0,567.0,1.0,1.0,10.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,int
3724,204499,VideoFilterCallback,1,VideoFilterCallback,"int VideoFilterCallback (vlc_object_t*,char*,ANY,ANY,void*)",video_output\vout_intf.c,"static int VideoFilterCallback( vlc_object_t *p_this, char const *psz_cmd,
                                vlc_value_t oldval, vlc_value_t newval, void *p_data)
{
    vout_thread_t *p_vout = (vout_thread_t *)p_this;
    VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval); VLC_UNUSED(p_data);

    vout_ControlChangeFilters( p_vout, newval.psz_string );
    return VLC_SUCCESS;
}",569.0,577.0,1.0,1.0,9.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,int
3725,204508,SubSourceCallback,1,SubSourceCallback,"int SubSourceCallback (vlc_object_t*,char*,ANY,ANY,void*)",video_output\vout_intf.c,"static int SubSourceCallback( vlc_object_t *p_this, char const *psz_cmd,
                              vlc_value_t oldval, vlc_value_t newval, void *p_data)
{
    vout_thread_t *p_vout = (vout_thread_t *)p_this;
    VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval); VLC_UNUSED(p_data);

    vout_ControlChangeSubSources( p_vout, newval.psz_string );
    return VLC_SUCCESS;
}",579.0,587.0,1.0,1.0,9.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,int
3726,204517,SubFilterCallback,1,SubFilterCallback,"int SubFilterCallback (vlc_object_t*,char*,ANY,ANY,void*)",video_output\vout_intf.c,"static int SubFilterCallback( vlc_object_t *p_this, char const *psz_cmd,
                              vlc_value_t oldval, vlc_value_t newval, void *p_data)
{
    vout_thread_t *p_vout = (vout_thread_t *)p_this;
    VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval); VLC_UNUSED(p_data);

    vout_ControlChangeSubFilters( p_vout, newval.psz_string );
    return VLC_SUCCESS;
}",589.0,597.0,1.0,1.0,9.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,int
3727,204526,SubMarginCallback,1,SubMarginCallback,"int SubMarginCallback (vlc_object_t*,char*,ANY,ANY,void*)",video_output\vout_intf.c,"static int SubMarginCallback( vlc_object_t *p_this, char const *psz_cmd,
                              vlc_value_t oldval, vlc_value_t newval, void *p_data)
{
    vout_thread_t *p_vout = (vout_thread_t *)p_this;
    VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval); VLC_UNUSED(p_data);

    vout_ControlChangeSubMargin( p_vout, newval.i_int );
    return VLC_SUCCESS;
}",599.0,607.0,1.0,1.0,9.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,int
3728,204665,AddCustomRatios,1,AddCustomRatios,"void AddCustomRatios (vout_thread_t*,char*,char*)",video_output\vout_intf.c,"static void AddCustomRatios( vout_thread_t *p_vout, const char *psz_var,
                             char *psz_list )
{
    assert( psz_list );

    char *psz_cur = psz_list;
    char *psz_next;
    while( psz_cur && *psz_cur )
    {
        vlc_value_t val, text;
        psz_next = strchr( psz_cur, ',' );
        if( psz_next )
        {
            *psz_next = '\0';
            psz_next++;
        }
        val.psz_string = psz_cur;
        text.psz_string = psz_cur;
        var_Change( p_vout, psz_var, VLC_VAR_ADDCHOICE, &val, &text);
        psz_cur = psz_next;
    }
}",127.0,148.0,1.0,1.0,22.0,14,6,21,8,0,1,3,4,0,1,,0,0,6,3,3,void
3729,205280,VoutSnapshotPip,1,VoutSnapshotPip,"int VoutSnapshotPip (vout_thread_t*,picture_t*)",video_output\vout_intf.c,"static int VoutSnapshotPip( vout_thread_t *p_vout, picture_t *p_pic )
{
    subpicture_t *p_subpic = subpicture_NewFromPicture( VLC_OBJECT(p_vout),
                                                        p_pic, VLC_CODEC_YUVA );
    if( !p_subpic )
        return VLC_EGENERIC;

    /* FIXME SPU_DEFAULT_CHANNEL is not good (used by the text) but
     * hardcoded 0 doesn't seem right */
    p_subpic->i_channel = 0;
    p_subpic->i_start = mdate();
    p_subpic->i_stop  = p_subpic->i_start + 4000000;
    p_subpic->b_ephemer = true;
    p_subpic->b_fade = true;

    /* Reduce the picture to 1/4^2 of the screen */
    p_subpic->i_original_picture_width  *= 4;
    p_subpic->i_original_picture_height *= 4;

    vout_PutSubpicture( p_vout, p_subpic );
    return VLC_SUCCESS;
}",336.0,357.0,1.0,1.0,22.0,18,5,19,7,1,3,2,2,0,3,,0,2,4,2,2,int
3730,205344,VoutOsdSnapshot,1,VoutOsdSnapshot,"void VoutOsdSnapshot (vout_thread_t*,picture_t*,char*)",video_output\vout_intf.c,"static void VoutOsdSnapshot( vout_thread_t *p_vout, picture_t *p_pic, const char *psz_filename )
{
    msg_Dbg( p_vout, ""snapshot taken (%s)"", psz_filename );
    vout_OSDMessage( p_vout, VOUT_SPU_CHANNEL_OSD, ""%s"", psz_filename );

    if( var_InheritBool( p_vout, ""snapshot-preview"" ) )
    {
        if( VoutSnapshotPip( p_vout, p_pic ) )
            msg_Warn( p_vout, ""Failed to display snapshot"" );
    }
}",362.0,372.0,1.0,1.0,11.0,0,0,9,4,1,2,3,4,1,2,,0,1,6,3,3,void
3731,205373,VoutSaveSnapshot,1,VoutSaveSnapshot,void VoutSaveSnapshot (vout_thread_t*),video_output\vout_intf.c,"static void VoutSaveSnapshot( vout_thread_t *p_vout )
{
    char *psz_path = var_InheritString( p_vout, ""snapshot-path"" );
    char *psz_format = var_InheritString( p_vout, ""snapshot-format"" );
    char *psz_prefix = var_InheritString( p_vout, ""snapshot-prefix"" );

    /* */
    picture_t *p_picture;
    block_t *p_image;

    /* 500ms timeout
     * XXX it will cause trouble with low fps video (< 2fps) */
    if( vout_GetSnapshot( p_vout, &p_image, &p_picture, NULL, psz_format, 500*1000 ) )
    {
        p_picture = NULL;
        p_image = NULL;
        goto exit;
    }

    if( !psz_path )
    {
        psz_path = vout_snapshot_GetDirectory();
        if( !psz_path )
        {
            msg_Err( p_vout, ""no path specified for snapshots"" );
            goto exit;
        }
    }

    vout_snapshot_save_cfg_t cfg;
    memset( &cfg, 0, sizeof(cfg) );
    cfg.is_sequential = var_InheritBool( p_vout, ""snapshot-sequential"" );
    cfg.sequence = var_GetInteger( p_vout, ""snapshot-num"" )...",377.0,437.0,1.0,1.0,61.0,30,8,52,10,0,11,11,9,3,5,,0,9,2,1,1,void
3732,206094,spuregion_CreateVGradientPalette,1,spuregion_CreateVGradientPalette,"void spuregion_CreateVGradientPalette (video_palette_t*,uint8_t,uint32_t,uint32_t)",video_output\vout_spuregion_helper.h,"static inline void
spuregion_CreateVGradientPalette( video_palette_t *p_palette, uint8_t i_splits,
                                  uint32_t argb1, uint32_t argb2 )
{
    for( uint8_t i = 0; i<i_splits; i++ )
    {
        uint32_t rgb1 = argb1 & 0x00FFFFFF;
        uint32_t rgb2 = argb2 & 0x00FFFFFF;

        uint32_t r = ((((rgb1 >> 16) * (i_splits - i)) + (rgb2 >> 16) * i)) / i_splits;
        uint32_t g = (((((rgb1 >> 8) & 0xFF) * (i_splits - i)) + ((rgb2 >> 8) & 0xFF) * i)) / i_splits;
        uint32_t b = ((((rgb1 & 0xFF) * (i_splits - i)) + (rgb2 & 0xFF) * i)) / i_splits;
        uint8_t entry[4] = { RGB2YUV( r,g,b ), argb1 >> 24 };
        memcpy( p_palette->palette[i], entry, 4 );
    }
    p_palette->i_entries = i_splits;
}",30.0,46.0,1.0,29.0,17.0,58,12,47,11,1,0,2,2,0,0,,0,0,8,4,4,void
3733,206249,spuregion_CreateVGradientFill,1,spuregion_CreateVGradientFill,"void spuregion_CreateVGradientFill (plane_t*,uint8_t)",video_output\vout_spuregion_helper.h,"static inline void
spuregion_CreateVGradientFill( plane_t *p, uint8_t i_splits )
{
    const int i_split = p->i_visible_lines / i_splits;
    const int i_left = p->i_visible_lines % i_splits + p->i_lines - p->i_visible_lines;
    for( int i = 0; i<i_splits; i++ )
    {
        memset( &p->p_pixels[p->i_pitch * (i * i_split)],
                i,
                p->i_pitch * i_split );
    }
    memset( &p->p_pixels[p->i_pitch * (i_splits - 1) * i_split],
            i_splits - 1,
            p->i_pitch * i_left );
}",48.0,62.0,1.0,1.0,15.0,30,10,25,5,1,0,2,2,0,0,,0,0,4,2,2,void
3734,206333,spuregion_CreateFromPicture,1,spuregion_CreateFromPicture,"subpicture_region_t spuregion_CreateFromPicture (vlc_object_t*,video_format_t*,char*)",video_output\vout_spuregion_helper.h,"static inline subpicture_region_t *
spuregion_CreateFromPicture( vlc_object_t *p_this, video_format_t *p_fmt,
                             const char *psz_uri )
{
    video_format_t fmt_in;
    video_format_Init( &fmt_in, 0 );

    picture_t *p_pic = NULL;
    int i_flags = p_this->obj.flags;
    p_this->obj.flags |= OBJECT_FLAGS_NOINTERACT|OBJECT_FLAGS_QUIET;
    image_handler_t *p_image = image_HandlerCreate( p_this );
    if( p_image )
    {
        p_pic = image_ReadUrl( p_image, psz_uri, &fmt_in, p_fmt );
        image_HandlerDelete( p_image );
    }
    p_this->obj.flags = i_flags;

    if(!p_pic)
        return NULL;

    subpicture_region_t *region = subpicture_region_New(p_fmt);
    if (!region)
        return NULL;

    picture_Release( region->p_picture );
    region->p_picture = p_pic;

    return region;
}",65.0,94.0,1.0,1.0,30.0,20,6,29,11,1,4,4,4,0,4,,0,2,6,3,3,subpicture_region_t
3735,206502,SpuHeapInit,1,SpuHeapInit,void SpuHeapInit (spu_heap_t*),video_output\vout_subpictures.c,"static void SpuHeapInit(spu_heap_t *heap)
{
    for (int i = 0; i < VOUT_MAX_SUBPICTURES; i++) {
        spu_heap_entry_t *e = &heap->entry[i];

        e->subpicture = NULL;
        e->reject     = false;
    }
}",104.0,112.0,1.0,24.0,9.0,11,6,10,6,1,3,2,2,0,0,,0,3,2,1,1,void
3736,206544,SpuHeapPush,1,SpuHeapPush,"int SpuHeapPush (spu_heap_t*,subpicture_t*)",video_output\vout_subpictures.c,"static int SpuHeapPush(spu_heap_t *heap, subpicture_t *subpic)
{
    for (int i = 0; i < VOUT_MAX_SUBPICTURES; i++) {
        spu_heap_entry_t *e = &heap->entry[i];

        if (e->subpicture)
            continue;

        e->subpicture = subpic;
        e->reject     = false;
        return VLC_SUCCESS;
    }
    return VLC_EGENERIC;
}",114.0,127.0,1.0,24.0,14.0,12,6,13,8,1,4,4,4,1,0,,0,4,4,2,2,int
3737,206597,SpuHeapDeleteAt,1,SpuHeapDeleteAt,"void SpuHeapDeleteAt (spu_heap_t*,int)",video_output\vout_subpictures.c,"static void SpuHeapDeleteAt(spu_heap_t *heap, int index)
{
    spu_heap_entry_t *e = &heap->entry[index];

    if (e->subpicture)
        subpicture_Delete(e->subpicture);

    e->subpicture = NULL;
}",129.0,137.0,1.0,1.0,9.0,8,4,7,4,2,5,2,2,1,1,,0,4,4,2,2,void
3738,206626,SpuHeapDeleteSubpicture,1,SpuHeapDeleteSubpicture,"int SpuHeapDeleteSubpicture (spu_heap_t*,subpicture_t*)",video_output\vout_subpictures.c,"static int SpuHeapDeleteSubpicture(spu_heap_t *heap, subpicture_t *subpic)
{
    for (int i = 0; i < VOUT_MAX_SUBPICTURES; i++) {
        spu_heap_entry_t *e = &heap->entry[i];

        if (e->subpicture != subpic)
            continue;

        SpuHeapDeleteAt(heap, i);
        return VLC_SUCCESS;
    }
    return VLC_EGENERIC;
}",139.0,151.0,1.0,24.0,13.0,9,7,12,7,1,3,4,4,1,1,,0,2,4,2,2,int
3739,206674,SpuHeapClean,1,SpuHeapClean,void SpuHeapClean (spu_heap_t*),video_output\vout_subpictures.c,"static void SpuHeapClean(spu_heap_t *heap)
{
    for (int i = 0; i < VOUT_MAX_SUBPICTURES; i++) {
        spu_heap_entry_t *e = &heap->entry[i];
        if (e->subpicture)
            subpicture_Delete(e->subpicture);
    }
}",153.0,160.0,1.0,24.0,8.0,9,6,8,4,1,4,3,4,1,1,,0,3,2,1,1,void
3740,206715,FilterRelease,1,FilterRelease,void FilterRelease (filter_t*),video_output\vout_subpictures.c,"static void FilterRelease(filter_t *filter)
{
    if (filter->p_module)
        module_unneed(filter, filter->p_module);
    vlc_object_release(filter);
}",162.0,167.0,1.0,1.0,6.0,2,1,4,1,3,2,2,2,0,2,,0,0,2,1,1,void
3741,206732,spu_new_video_buffer,1,spu_new_video_buffer,picture_t spu_new_video_buffer (filter_t*),video_output\vout_subpictures.c,"static picture_t *spu_new_video_buffer(filter_t *filter)
{
    const video_format_t *fmt = &filter->fmt_out.video;

    return picture_NewFromFormat(fmt);
}",169.0,174.0,1.0,1.0,6.0,4,4,3,2,0,1,1,1,0,1,,0,0,2,1,1,picture_t
3742,206749,spu_get_attachments,1,spu_get_attachments,"int spu_get_attachments (filter_t*,input_attachment_t***,int*)",video_output\vout_subpictures.c,"static int spu_get_attachments(filter_t *filter,
                               input_attachment_t ***attachment_ptr,
                               int *attachment_count)
{
    spu_t *spu = filter->owner.sys;

    int ret = VLC_EGENERIC;
    if (spu->p->input)
        ret = input_Control((input_thread_t*)spu->p->input,
                            INPUT_GET_ATTACHMENTS,
                            attachment_ptr, attachment_count);
    return ret;
}",176.0,188.0,1.0,1.0,13.0,10,4,11,7,0,1,2,2,0,1,,0,1,6,3,3,int
3743,206790,SpuRenderCreateAndLoadText,1,SpuRenderCreateAndLoadText,filter_t SpuRenderCreateAndLoadText (spu_t*),video_output\vout_subpictures.c,"static filter_t *SpuRenderCreateAndLoadText(spu_t *spu)
{
    filter_t *text = vlc_custom_create(spu, sizeof(*text), ""spu text"");
    if (!text)
        return NULL;

    text->owner.sys = spu;

    es_format_Init(&text->fmt_in, VIDEO_ES, 0);

    es_format_Init(&text->fmt_out, VIDEO_ES, 0);
    text->fmt_out.video.i_width          =
    text->fmt_out.video.i_visible_width  = 32;
    text->fmt_out.video.i_height         =
    text->fmt_out.video.i_visible_height = 32;

    text->pf_get_attachments = spu_get_attachments;

    text->p_module = module_need(text, ""text renderer"", ""$text-renderer"", false);

    /* Create a few variables used for enhanced text rendering */
    var_Create(text, ""spu-elapsed"",   VLC_VAR_INTEGER);
    var_Create(text, ""text-rerender"", VLC_VAR_BOOL);

    return text;
}",190.0,215.0,1.0,21.0,26.0,31,7,25,7,1,6,2,2,0,6,,0,2,2,1,1,filter_t
3744,206893,SpuRenderCreateAndLoadScale,1,SpuRenderCreateAndLoadScale,"filter_t SpuRenderCreateAndLoadScale (vlc_object_t*,vlc_fourcc_t,vlc_fourcc_t,bool)",video_output\vout_subpictures.c,"static filter_t *SpuRenderCreateAndLoadScale(vlc_object_t *object,
                                             vlc_fourcc_t src_chroma,
                                             vlc_fourcc_t dst_chroma,
                                             bool require_resize)
{
    filter_t *scale = vlc_custom_create(object, sizeof(*scale), ""scale"");
    if (!scale)
        return NULL;

    es_format_Init(&scale->fmt_in, VIDEO_ES, 0);
    scale->fmt_in.video.i_chroma = src_chroma;
    scale->fmt_in.video.i_width =
    scale->fmt_in.video.i_visible_width =
    scale->fmt_in.video.i_height =
    scale->fmt_in.video.i_visible_height = 32;

    es_format_Init(&scale->fmt_out, VIDEO_ES, 0);
    scale->fmt_out.video.i_chroma = dst_chroma;
    scale->fmt_out.video.i_width =
    scale->fmt_out.video.i_visible_width =
    scale->fmt_out.video.i_height =
    scale->fmt_out.video.i_visible_height = require_resize ? 16 : 32;

    scale->owner.video.buffer_new = spu_new_video_buffer;

    scale->p_...",217.0,245.0,1.0,22.0,29.0,55,8,29,8,2,4,2,2,0,4,,0,2,8,4,4,filter_t
3745,207042,SpuRenderText,1,SpuRenderText,"void SpuRenderText (spu_t*,bool*,subpicture_region_t*,vlc_fourcc_t*,mtime_t)",video_output\vout_subpictures.c,"static void SpuRenderText(spu_t *spu, bool *rerender_text,
                          subpicture_region_t *region,
                          const vlc_fourcc_t *chroma_list,
                          mtime_t elapsed_time)
{
    filter_t *text = spu->p->text;

    assert(region->fmt.i_chroma == VLC_CODEC_TEXT);

    if (!text || !text->p_module)
        return;

    /* Setup 3 variables which can be used to render
     * time-dependent text (and effects). The first indicates
     * the total amount of time the text will be on screen,
     * the second the amount of time it has already been on
     * screen (can be a negative value as text is laid out
     * before it is rendered) and the third is a feedback
     * variable from the renderer - if the renderer sets it
     * then this particular text is time-dependent, eg. the
     * visual progress bar inside the text in karaoke and the
     * text needs to be rendered multiple times in order for
     * the effect to work - we therefor...",247.0,284.0,1.0,1.0,38.0,14,7,18,8,1,0,3,3,0,0,,0,0,10,5,5,void
3746,207108,spu_scale_create,1,spu_scale_create,"spu_scale_t spu_scale_create (int,int)",video_output\vout_subpictures.c,"static spu_scale_t spu_scale_create(int w, int h)
{
    spu_scale_t s = { .w = w, .h = h };
    if (s.w <= 0)
        s.w = SCALE_UNIT;
    if (s.h <= 0)
        s.h = SCALE_UNIT;
    return s;
}",296.0,304.0,1.0,14.0,9.0,12,4,10,3,2,4,3,3,2,0,,0,4,4,2,2,spu_scale_t
3747,207156,spu_scale_unit,1,spu_scale_unit,spu_scale_t spu_scale_unit (void),video_output\vout_subpictures.c,"static spu_scale_t spu_scale_unit(void)
{
    return spu_scale_create(SCALE_UNIT, SCALE_UNIT);
}",305.0,308.0,1.0,28.0,4.0,0,0,0,0,2,1,1,1,0,1,,0,0,2,1,1,spu_scale_t
3748,207169,spu_scale_createq,1,spu_scale_createq,"spu_scale_t spu_scale_createq (int64_t,int64_t,int64_t,int64_t)",video_output\vout_subpictures.c,"static spu_scale_t spu_scale_createq(int64_t wn, int64_t wd, int64_t hn, int64_t hd)
{
    return spu_scale_create(wn * SCALE_UNIT / wd,
                            hn * SCALE_UNIT / hd);
}",309.0,313.0,1.0,33.0,5.0,4,2,4,4,1,1,1,1,0,1,,0,0,8,4,4,spu_scale_t
3749,207193,spu_scale_w,1,spu_scale_w,"int spu_scale_w (int,spu_scale_t)",video_output\vout_subpictures.c,"static int spu_scale_w(int v, const spu_scale_t s)
{
    return v * s.w / SCALE_UNIT;
}",314.0,317.0,1.0,21.0,4.0,3,3,2,2,9,1,1,1,0,0,,0,1,4,2,2,int
3750,207209,spu_scale_h,1,spu_scale_h,"int spu_scale_h (int,spu_scale_t)",video_output\vout_subpictures.c,"static int spu_scale_h(int v, const spu_scale_t s)
{
    return v * s.h / SCALE_UNIT;
}",318.0,321.0,1.0,21.0,4.0,3,3,2,2,9,1,1,1,0,0,,0,1,4,2,2,int
3751,207225,spu_invscale_w,1,spu_invscale_w,"int spu_invscale_w (int,spu_scale_t)",video_output\vout_subpictures.c,"static int spu_invscale_w(int v, const spu_scale_t s)
{
    return v * SCALE_UNIT / s.w;
}",322.0,325.0,1.0,15.0,4.0,3,3,2,2,2,1,1,1,0,0,,0,1,4,2,2,int
3752,207241,spu_invscale_h,1,spu_invscale_h,"int spu_invscale_h (int,spu_scale_t)",video_output\vout_subpictures.c,"static int spu_invscale_h(int v, const spu_scale_t s)
{
    return v * SCALE_UNIT / s.h;
}",326.0,329.0,1.0,15.0,4.0,3,3,2,2,3,1,1,1,0,0,,0,1,4,2,2,int
3753,207264,spu_area_create,1,spu_area_create,"spu_area_t spu_area_create (int,int,int,int,spu_scale_t)",video_output\vout_subpictures.c,"static spu_area_t spu_area_create(int x, int y, int w, int h, spu_scale_t s)
{
    spu_area_t a = { .x = x, .y = y, .width = w, .height = h, .scale = s };
    return a;
}",343.0,347.0,1.0,1.0,5.0,7,2,12,9,3,0,1,1,0,0,,0,0,10,5,5,spu_area_t
3754,207299,spu_area_scaled,1,spu_area_scaled,spu_area_t spu_area_scaled (spu_area_t),video_output\vout_subpictures.c,"static spu_area_t spu_area_scaled(spu_area_t a)
{
    if (a.scale.w == SCALE_UNIT && a.scale.h == SCALE_UNIT)
        return a;

    a.x      = spu_scale_w(a.x,      a.scale);
    a.y      = spu_scale_h(a.y,      a.scale);
    a.width  = spu_scale_w(a.width,  a.scale);
    a.height = spu_scale_h(a.height, a.scale);

    a.scale = spu_scale_unit();
    return a;
}",348.0,360.0,1.0,21.0,13.0,25,4,17,1,6,20,2,2,2,5,,0,20,2,1,1,spu_area_t
3755,207378,spu_area_unscaled,1,spu_area_unscaled,"spu_area_t spu_area_unscaled (spu_area_t,spu_scale_t)",video_output\vout_subpictures.c,"static spu_area_t spu_area_unscaled(spu_area_t a, spu_scale_t s)
{
    if (a.scale.w == s.w && a.scale.h == s.h)
        return a;

    a = spu_area_scaled(a);

    a.x      = spu_invscale_w(a.x,      s);
    a.y      = spu_invscale_h(a.y,      s);
    a.width  = spu_invscale_w(a.width,  s);
    a.height = spu_invscale_h(a.height, s);

    a.scale = s;
    return a;
}",361.0,375.0,1.0,1.0,15.0,24,4,22,2,3,18,2,2,4,5,,0,18,4,2,2,spu_area_t
3756,207454,spu_area_overlap,1,spu_area_overlap,"bool spu_area_overlap (spu_area_t,spu_area_t)",video_output\vout_subpictures.c,"static bool spu_area_overlap(spu_area_t a, spu_area_t b)
{
    a = spu_area_scaled(a);
    b = spu_area_scaled(b);

    return __MAX(a.x, b.x) < __MIN(a.x + a.width , b.x + b.width ) &&
           __MAX(a.y, b.y) < __MIN(a.y + a.height, b.y + b.height);
}",376.0,383.0,1.0,1.0,8.0,21,5,16,2,1,14,1,1,0,2,,0,14,4,2,2,bool
3757,207516,SpuAreaFixOverlap,1,SpuAreaFixOverlap,"void SpuAreaFixOverlap (spu_area_t*,spu_area_t*,int,int)",video_output\vout_subpictures.c,"static void SpuAreaFixOverlap(spu_area_t *dst,
                              const spu_area_t *sub_array, int sub_count, int align)
{
    spu_area_t a = spu_area_scaled(*dst);
    bool is_moved = false;
    bool is_ok;

    /* Check for overlap
     * XXX It is not fast O(n^2) but we should not have a lot of region */
    do {
        is_ok = true;
        for (int i = 0; i < sub_count; i++) {
            spu_area_t sub = spu_area_scaled(sub_array[i]);

            if (!spu_area_overlap(a, sub))
                continue;

            if (align & SUBPICTURE_ALIGN_TOP) {
                /* We go down */
                int i_y = sub.y + sub.height;
                a.y = i_y;
                is_moved = true;
            } else if (align & SUBPICTURE_ALIGN_BOTTOM) {
                /* We go up */
                int i_y = sub.y - a.height;
                a.y = i_y;
                is_moved = true;
            } else {
                /* TODO what to do in this case? */
                ...",388.0,428.0,1.0,1.0,41.0,22,9,30,13,1,8,8,11,1,4,,0,8,8,4,4,void
3758,207634,SpuAreaFitInside,1,SpuAreaFitInside,"void SpuAreaFitInside (spu_area_t*,spu_area_t*)",video_output\vout_subpictures.c,"static void SpuAreaFitInside(spu_area_t *area, const spu_area_t *boundary)
{
    spu_area_t a = spu_area_scaled(*area);

    const int i_error_x = (a.x + a.width) - boundary->width;
    if (i_error_x > 0)
        a.x -= i_error_x;
    if (a.x < 0)
        a.x = 0;

    const int i_error_y = (a.y + a.height) - boundary->height;
    if (i_error_y > 0)
        a.y -= i_error_y;
    if (a.y < 0)
        a.y = 0;

    *area = spu_area_unscaled(a, area->scale);
}",431.0,448.0,1.0,1.0,18.0,31,9,23,5,1,15,5,5,2,2,,0,15,4,2,2,void
3759,207726,SpuRegionPlace,1,SpuRegionPlace,"void SpuRegionPlace (int*,int*,subpicture_t*,subpicture_region_t*)",video_output\vout_subpictures.c,"static void SpuRegionPlace(int *x, int *y,
                           const subpicture_t *subpic,
                           const subpicture_region_t *region)
{
    assert(region->i_x != INT_MAX && region->i_y != INT_MAX);
    if (subpic->b_absolute) {
        *x = region->i_x;
        *y = region->i_y;
    } else {
        if (region->i_align & SUBPICTURE_ALIGN_TOP)
            *y = region->i_y;
        else if (region->i_align & SUBPICTURE_ALIGN_BOTTOM)
            *y = subpic->i_original_picture_height - region->fmt.i_visible_height - region->i_y;
        else
            *y = subpic->i_original_picture_height / 2 - region->fmt.i_visible_height / 2;

        if (region->i_align & SUBPICTURE_ALIGN_LEFT)
            *x = region->i_x;
        else if (region->i_align & SUBPICTURE_ALIGN_RIGHT)
            *x = subpic->i_original_picture_width - region->fmt.i_visible_width - region->i_x;
        else
            *x = subpic->i_original_picture_width / 2 - region->fmt.i_visible_width ...",453.0,476.0,1.0,1.0,24.0,12,5,9,5,1,0,2,2,0,0,,0,0,8,4,4,void
3760,207877,IntegerCmp,1,IntegerCmp,"int IntegerCmp (int64_t,int64_t)",video_output\vout_subpictures.c,"static int IntegerCmp(int64_t i0, int64_t i1)
{
    return i0 < i1 ? -1 : i0 > i1 ? 1 : 0;
}",482.0,485.0,1.0,1.0,4.0,5,4,4,2,4,0,1,1,0,0,,0,0,4,2,2,int
3761,207896,SubpictureCmp,1,SubpictureCmp,"int SubpictureCmp (void*,void*)",video_output\vout_subpictures.c,"static int SubpictureCmp(const void *s0, const void *s1)
{
    subpicture_t *subpic0 = *(subpicture_t**)s0;
    subpicture_t *subpic1 = *(subpicture_t**)s1;
    int r;

    r = IntegerCmp(!subpic0->b_absolute, !subpic1->b_absolute);
    if (!r)
        r = IntegerCmp(subpic0->i_start, subpic1->i_start);
    if (!r)
        r = IntegerCmp(subpic0->i_channel, subpic1->i_channel);
    if (!r)
        r = IntegerCmp(subpic0->i_order, subpic1->i_order);
    return r;
}",497.0,511.0,1.0,1.0,15.0,23,5,20,5,0,4,4,4,0,4,,0,4,4,2,2,int
3762,207969,SpuSelectSubpictures,1,SpuSelectSubpictures,"void SpuSelectSubpictures (spu_t*,unsigned int*,subpicture_t**,mtime_t,mtime_t,bool)",video_output\vout_subpictures.c,"static void SpuSelectSubpictures(spu_t *spu,
                                 unsigned int *subpicture_count,
                                 subpicture_t **subpicture_array,
                                 mtime_t render_subtitle_date,
                                 mtime_t render_osd_date,
                                 bool ignore_osd)
{
    spu_private_t *sys = spu->p;

    /* */
    *subpicture_count = 0;

    /* Create a list of channels */
    int channel[VOUT_MAX_SUBPICTURES];
    int channel_count = 0;

    for (int index = 0; index < VOUT_MAX_SUBPICTURES; index++) {
        spu_heap_entry_t *entry = &sys->heap.entry[index];
        if (!entry->subpicture || entry->reject)
            continue;
        const int i_channel = entry->subpicture->i_channel;
        int i;
        for (i = 0; i < channel_count; i++) {
            if (channel[i] == i_channel)
                break;
        }
        if (channel_count <= i)
            channel[channel_count++] = i_channel;
 ...",523.0,650.0,1.0,16.0,128.0,149,18,145,35,1,16,27,54,5,2,,0,14,12,6,6,void
3763,208459,SpuRenderRegion,1,SpuRenderRegion,"void SpuRenderRegion (spu_t*,subpicture_region_t**,spu_area_t*,subpicture_t*,subpicture_region_t*,spu_scale_t,vlc_fourcc_t*,video_format_t*,spu_area_t*,int,mtime_t)",video_output\vout_subpictures.c,"static void SpuRenderRegion(spu_t *spu,
                            subpicture_region_t **dst_ptr, spu_area_t *dst_area,
                            subpicture_t *subpic, subpicture_region_t *region,
                            const spu_scale_t scale_size,
                            const vlc_fourcc_t *chroma_list,
                            const video_format_t *fmt,
                            const spu_area_t *subtitle_area, int subtitle_area_count,
                            mtime_t render_date)
{
    spu_private_t *sys = spu->p;

    video_format_t fmt_original = region->fmt;
    bool restore_text = false;
    int x_offset;
    int y_offset;

    video_format_t region_fmt;
    picture_t *region_picture;

    /* Invalidate area by default */
    *dst_area = spu_area_create(0,0, 0,0, scale_size);
    *dst_ptr  = NULL;

    /* Render text region */
    if (region->fmt.i_chroma == VLC_CODEC_TEXT) {
        // assume rendered text is in sRGB if nothing is set
        if (region-...",657.0,1000.0,1.0,25.0,344.0,399,20,329,57,1,52,50,113,12,32,,0,42,22,11,11,void
3764,209780,SpuRenderSubpictures,1,SpuRenderSubpictures,"subpicture_t SpuRenderSubpictures (spu_t*,unsigned int,subpicture_t**,vlc_fourcc_t*,video_format_t*,video_format_t*,mtime_t,mtime_t)",video_output\vout_subpictures.c,"static subpicture_t *SpuRenderSubpictures(spu_t *spu,
                                          unsigned int i_subpicture,
                                          subpicture_t **pp_subpicture,
                                          const vlc_fourcc_t *chroma_list,
                                          const video_format_t *fmt_dst,
                                          const video_format_t *fmt_src,
                                          mtime_t render_subtitle_date,
                                          mtime_t render_osd_date)
{
    spu_private_t *sys = spu->p;

    /* Count the number of regions and subtitle regions */
    unsigned int subtitle_region_count = 0;
    unsigned int region_count          = 0;
    for (unsigned i = 0; i < i_subpicture; i++) {
        const subpicture_t *subpic = pp_subpicture[i];

        unsigned count = 0;
        for (subpicture_region_t *r = subpic->p_region; r != NULL; r = r->p_next)
            count++;

        if (subpic->b...",1005.0,1144.0,1.0,36.0,140.0,170,21,139,29,1,16,23,44,5,5,,0,14,16,8,8,subpicture_t
3765,210297,UpdateSPU,1,UpdateSPU,"void UpdateSPU (spu_t*,vlc_object_t*)",video_output\vout_subpictures.c,"static void UpdateSPU(spu_t *spu, vlc_object_t *object)
{
    spu_private_t *sys = spu->p;
    vlc_value_t val;

    vlc_mutex_lock(&sys->lock);

    sys->force_palette = false;
    sys->force_crop = false;

    if (var_Get(object, ""highlight"", &val) || !val.b_bool) {
        vlc_mutex_unlock(&sys->lock);
        return;
    }

    sys->force_crop = true;
    sys->crop.x      = var_GetInteger(object, ""x-start"");
    sys->crop.y      = var_GetInteger(object, ""y-start"");
    sys->crop.width  = var_GetInteger(object, ""x-end"") - sys->crop.x;
    sys->crop.height = var_GetInteger(object, ""y-end"") - sys->crop.y;

    if (var_Get(object, ""menu-palette"", &val) == VLC_SUCCESS) {
        memcpy(sys->palette, val.p_address, 16);
        sys->force_palette = true;
    }
    vlc_mutex_unlock(&sys->lock);

    msg_Dbg(object, ""crop: %i,%i,%i,%i, palette forced: %i"",
            sys->crop.x, sys->crop.y,
            sys->crop.width, sys->crop.height,
            sys->force_palette);
}",1156.0,1187.0,1.0,1.0,32.0,51,8,37,7,0,14,3,3,2,5,,0,11,4,2,2,void
3766,210471,sub_new_buffer,1,sub_new_buffer,subpicture_t sub_new_buffer (filter_t*),video_output\vout_subpictures.c,"static subpicture_t *sub_new_buffer(filter_t *filter)
{
    int channel = (intptr_t)filter->owner.sys;

    subpicture_t *subpicture = subpicture_New(NULL);
    if (subpicture)
        subpicture->i_channel = channel;
    return subpicture;
}",1207.0,1215.0,1.0,1.0,9.0,7,4,8,4,0,1,2,2,0,1,,0,1,2,1,1,subpicture_t
3767,210501,SubSourceInit,1,SubSourceInit,"int SubSourceInit (filter_t*,void*)",video_output\vout_subpictures.c,"static int SubSourceInit(filter_t *filter, void *data)
{
    spu_t *spu = data;
    int channel = spu_RegisterChannel(spu);

    filter->owner.sys = (void *)(intptr_t)channel;
    filter->owner.sub.buffer_new = sub_new_buffer;
    return VLC_SUCCESS;
}",1217.0,1225.0,1.0,1.0,9.0,11,4,8,5,0,1,1,1,0,1,,0,1,4,2,2,int
3768,210538,SubSourceClean,1,SubSourceClean,"int SubSourceClean (filter_t*,void*)",video_output\vout_subpictures.c,"static int SubSourceClean(filter_t *filter, void *data)
{
    spu_t *spu = data;
    int channel = (intptr_t)filter->owner.sys;

    spu_ClearChannel(spu, channel);
    return VLC_SUCCESS;
}",1227.0,1234.0,1.0,1.0,8.0,5,4,7,5,0,1,1,1,0,1,,0,0,4,2,2,int
3769,210563,RestartSubFilterCallback,1,RestartSubFilterCallback,"int RestartSubFilterCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",video_output\vout_subpictures.c,"static int RestartSubFilterCallback(vlc_object_t *obj, char const *psz_var,
                                    vlc_value_t oldval, vlc_value_t newval,
                                    void *p_data)
{ VLC_UNUSED(obj); VLC_UNUSED(psz_var); VLC_UNUSED(oldval); VLC_UNUSED(newval);
    vout_ControlChangeSubFilters((vout_thread_t *)p_data, NULL);
    return VLC_SUCCESS;
}",1240.0,1246.0,1.0,1.0,7.0,1,1,7,7,0,1,1,1,0,1,,0,0,10,5,5,int
3770,210587,SubFilterAddProxyCallbacks,1,SubFilterAddProxyCallbacks,"int SubFilterAddProxyCallbacks (filter_t*,void*)",video_output\vout_subpictures.c,"static int SubFilterAddProxyCallbacks(filter_t *filter, void *opaque)
{
    filter_AddProxyCallbacks((vlc_object_t *)opaque, filter,
                             RestartSubFilterCallback);
    return VLC_SUCCESS;
}",1248.0,1253.0,1.0,1.0,6.0,1,1,3,3,0,1,1,1,0,1,,0,0,4,2,2,int
3771,210601,SubFilterDelProxyCallbacks,1,SubFilterDelProxyCallbacks,"int SubFilterDelProxyCallbacks (filter_t*,void*)",video_output\vout_subpictures.c,"static int SubFilterDelProxyCallbacks(filter_t *filter, void *opaque)
{
    filter_DelProxyCallbacks((vlc_object_t *)opaque, filter,
                             RestartSubFilterCallback);
    return VLC_SUCCESS;
}",1255.0,1260.0,1.0,1.0,6.0,1,1,3,3,0,1,1,1,0,1,,0,0,4,2,2,int
3772,210615,RestartSubSourceCallback,1,RestartSubSourceCallback,"int RestartSubSourceCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",video_output\vout_subpictures.c,"static int RestartSubSourceCallback(vlc_object_t *obj, char const *psz_var,
                                    vlc_value_t oldval, vlc_value_t newval,
                                    void *p_data)
{ VLC_UNUSED(obj); VLC_UNUSED(psz_var); VLC_UNUSED(oldval); VLC_UNUSED(newval);
    vout_ControlChangeSubSources((vout_thread_t *)p_data, NULL);
    return VLC_SUCCESS;
}",1262.0,1268.0,1.0,1.0,7.0,1,1,7,7,0,1,1,1,0,1,,0,0,10,5,5,int
3773,210639,SubSourceAddProxyCallbacks,1,SubSourceAddProxyCallbacks,"int SubSourceAddProxyCallbacks (filter_t*,void*)",video_output\vout_subpictures.c,"static int SubSourceAddProxyCallbacks(filter_t *filter, void *opaque)
{
    filter_AddProxyCallbacks((vlc_object_t *)opaque, filter,
                             RestartSubSourceCallback);
    return VLC_SUCCESS;
}",1270.0,1275.0,1.0,1.0,6.0,1,1,3,3,0,1,1,1,0,1,,0,0,4,2,2,int
3774,210653,SubSourceDelProxyCallbacks,1,SubSourceDelProxyCallbacks,"int SubSourceDelProxyCallbacks (filter_t*,void*)",video_output\vout_subpictures.c,"static int SubSourceDelProxyCallbacks(filter_t *filter, void *opaque)
{
    filter_DelProxyCallbacks((vlc_object_t *)opaque, filter,
                             RestartSubSourceCallback);
    return VLC_SUCCESS;
}",1277.0,1282.0,1.0,1.0,6.0,1,1,3,3,0,1,1,1,0,1,,0,0,4,2,2,int
3775,210667,spu_Create,1,spu_Create,"spu_t spu_Create (vlc_object_t*,vout_thread_t*)",video_output\vout_subpictures.c,"spu_t *spu_Create(vlc_object_t *object, vout_thread_t *vout)
{
    spu_t *spu = vlc_custom_create(object,
                                   sizeof(spu_t) + sizeof(spu_private_t),
                                   ""subpicture"");
    if (!spu)
        return NULL;

    /* Initialize spu fields */
    spu_private_t *sys = spu->p = (spu_private_t*)&spu[1];

    /* Initialize private fields */
    vlc_mutex_init(&sys->lock);

    SpuHeapInit(&sys->heap);

    sys->text = NULL;
    sys->scale = NULL;
    sys->scale_yuvp = NULL;

    sys->margin = var_InheritInteger(spu, ""sub-margin"");

    /* Register the default subpicture channel */
    sys->channel = VOUT_SPU_CHANNEL_AVAIL_FIRST;

    sys->source_chain_update = NULL;
    sys->filter_chain_update = NULL;
    vlc_mutex_init(&sys->source_chain_lock);
    vlc_mutex_init(&sys->filter_chain_lock);
    sys->source_chain = filter_chain_New(spu, ""sub source"", SPU_ES);
    sys->filter_chain = filter_chain_New(spu, ""sub filter"", SPU_ES);

    /...",1294.0,1344.0,1.0,17.0,51.0,48,9,50,14,1,28,2,2,0,10,,0,24,4,2,2,spu_t
3776,210820,spu_Destroy,1,spu_Destroy,void spu_Destroy (spu_t*),video_output\vout_subpictures.c,"void spu_Destroy(spu_t *spu)
{
    spu_private_t *sys = spu->p;

    if (sys->text)
        FilterRelease(sys->text);

    if (sys->scale_yuvp)
        FilterRelease(sys->scale_yuvp);

    if (sys->scale)
        FilterRelease(sys->scale);

    filter_chain_ForEach(sys->source_chain, SubSourceClean, spu);
    if (sys->vout)
        filter_chain_ForEach(sys->source_chain,
                             SubSourceDelProxyCallbacks, sys->vout);
    filter_chain_Delete(sys->source_chain);
    free(sys->source_chain_current);
    if (sys->vout)
        filter_chain_ForEach(sys->filter_chain,
                             SubFilterDelProxyCallbacks, sys->vout);
    filter_chain_Delete(sys->filter_chain);
    free(sys->filter_chain_current);
    vlc_mutex_destroy(&sys->source_chain_lock);
    vlc_mutex_destroy(&sys->filter_chain_lock);
    free(sys->source_chain_update);
    free(sys->filter_chain_update);

    /* Destroy all remaining subpictures */
    SpuHeapClean(&sys->heap);

    vlc_mute...",1351.0,1386.0,1.0,1.0,36.0,29,3,27,2,2,36,6,6,5,13,,0,23,2,1,1,void
3777,211062,spu_PutSubpicture,1,spu_PutSubpicture,"void spu_PutSubpicture (spu_t*,subpicture_t*)",video_output\vout_subpictures.c,"void spu_PutSubpicture(spu_t *spu, subpicture_t *subpic)
{
    spu_private_t *sys = spu->p;

    /* Update sub-filter chain */
    vlc_mutex_lock(&sys->lock);
    char *chain_update = sys->filter_chain_update;
    sys->filter_chain_update = NULL;
    vlc_mutex_unlock(&sys->lock);

    bool is_left_empty = false;

    vlc_mutex_lock(&sys->filter_chain_lock);
    if (chain_update) {
        if (*chain_update) {
            if (sys->vout)
                filter_chain_ForEach(sys->filter_chain,
                                     SubFilterDelProxyCallbacks,
                                     sys->vout);
            filter_chain_Reset(sys->filter_chain, NULL, NULL);

            filter_chain_AppendFromString(spu->p->filter_chain, chain_update);
            if (sys->vout)
                filter_chain_ForEach(sys->filter_chain,
                                     SubFilterAddProxyCallbacks,
                                     sys->vout);
        }
        else
            filter_chain...",1444.0,1524.0,1.0,1.0,81.0,68,9,64,9,2,47,13,24,7,20,,0,30,4,2,2,void
3778,211312,spu_Render,1,spu_Render,"subpicture_t spu_Render (spu_t*,vlc_fourcc_t*,video_format_t*,video_format_t*,mtime_t,mtime_t,bool)",video_output\vout_subpictures.c,"subpicture_t *spu_Render(spu_t *spu,
                         const vlc_fourcc_t *chroma_list,
                         const video_format_t *fmt_dst,
                         const video_format_t *fmt_src,
                         mtime_t render_subtitle_date,
                         mtime_t render_osd_date,
                         bool ignore_osd)
{
    spu_private_t *sys = spu->p;

    /* Update sub-source chain */
    vlc_mutex_lock(&sys->lock);
    char *chain_update = sys->source_chain_update;
    sys->source_chain_update = NULL;
    vlc_mutex_unlock(&sys->lock);

    vlc_mutex_lock(&sys->source_chain_lock);
    if (chain_update) {
        filter_chain_ForEach(sys->source_chain, SubSourceClean, spu);
            if (sys->vout)
                filter_chain_ForEach(sys->source_chain,
                                     SubSourceDelProxyCallbacks,
                                     sys->vout);
        filter_chain_Reset(sys->source_chain, NULL, NULL);

        filter_chain_A...",1526.0,1620.0,1.0,35.0,95.0,54,13,84,22,1,37,7,9,2,18,,0,21,14,7,7,subpicture_t
3779,211629,spu_RegisterChannel,1,spu_RegisterChannel,int spu_RegisterChannel (spu_t*),video_output\vout_subpictures.c,"int spu_RegisterChannel(spu_t *spu)
{
    spu_private_t *sys = spu->p;

    vlc_mutex_lock(&sys->lock);
    int channel = sys->channel++;
    vlc_mutex_unlock(&sys->lock);

    return channel;
}",1641.0,1650.0,1.0,1.0,10.0,9,4,7,3,2,5,1,1,0,2,,0,3,2,1,1,int
3780,211659,spu_ClearChannel,1,spu_ClearChannel,"void spu_ClearChannel (spu_t*,int)",video_output\vout_subpictures.c,"void spu_ClearChannel(spu_t *spu, int channel)
{
    spu_private_t *sys = spu->p;

    vlc_mutex_lock(&sys->lock);

    for (int i = 0; i < VOUT_MAX_SUBPICTURES; i++) {
        spu_heap_entry_t *entry = &sys->heap.entry[i];
        subpicture_t *subpic = entry->subpicture;

        if (!subpic)
            continue;
        if (subpic->i_channel != channel && (channel != -1 || subpic->i_channel == VOUT_SPU_CHANNEL_OSD))
            continue;

        /* You cannot delete subpicture outside of SpuSelectSubpictures */
        entry->reject = true;
    }

    vlc_mutex_unlock(&sys->lock);
}",1652.0,1672.0,1.0,24.0,21.0,27,13,20,9,3,7,6,6,0,2,,0,5,4,2,2,void
3781,211745,spu_ChangeSources,1,spu_ChangeSources,"void spu_ChangeSources (spu_t*,char*)",video_output\vout_subpictures.c,"void spu_ChangeSources(spu_t *spu, const char *filters)
{
    spu_private_t *sys = spu->p;

    vlc_mutex_lock(&sys->lock);

    free(sys->source_chain_update);
    if (filters)
    {
        sys->source_chain_update = strdup(filters);
        free(sys->source_chain_current);
        sys->source_chain_current = strdup(filters);
    }
    else if (sys->source_chain_current)
        sys->source_chain_update = strdup(sys->source_chain_current);

    vlc_mutex_unlock(&sys->lock);
}",1674.0,1691.0,1.0,1.0,18.0,12,3,11,3,1,8,2,2,0,2,,0,6,4,2,2,void
3782,211805,spu_ChangeFilters,1,spu_ChangeFilters,"void spu_ChangeFilters (spu_t*,char*)",video_output\vout_subpictures.c,"void spu_ChangeFilters(spu_t *spu, const char *filters)
{
    spu_private_t *sys = spu->p;

    vlc_mutex_lock(&sys->lock);

    free(sys->filter_chain_update);
    if (filters)
    {
        sys->filter_chain_update = strdup(filters);
        free(sys->filter_chain_current);
        sys->filter_chain_current = strdup(filters);
    }
    else if (sys->filter_chain_current)
        sys->filter_chain_update = strdup(sys->filter_chain_current);

    vlc_mutex_unlock(&sys->lock);
}",1693.0,1710.0,1.0,1.0,18.0,12,3,11,3,1,8,2,2,0,2,,0,6,4,2,2,void
3783,212045,NoDrInit,1,NoDrInit,void NoDrInit (vout_thread_t*),video_output\vout_wrapper.c,"static void NoDrInit(vout_thread_t *vout)
{
    vout_thread_sys_t *sys = vout->p;

    if (sys->display.use_dr)
        sys->display_pool = vout_display_Pool(sys->display.vd, 3);
    else
        sys->display_pool = NULL;
}",109.0,117.0,1.0,1.0,9.0,8,3,5,2,0,1,2,2,0,0,,0,1,2,1,1,void
3784,212447,vout_window_start,1,vout_window_start,"int vout_window_start (void*,va_list)",video_output\window.c,"static int vout_window_start(void *func, va_list ap)
{
    int (*activate)(vout_window_t *, const vout_window_cfg_t *) = func;
    vout_window_t *wnd = va_arg(ap, vout_window_t *);
    const vout_window_cfg_t *cfg = va_arg(ap, const vout_window_cfg_t *);

    return activate(wnd, cfg);
}",45.0,52.0,1.0,1.0,8.0,0,0,2,2,0,0,1,1,0,0,,0,0,4,2,2,int
3785,212451,activate,1,vout_window_start.activate,"int vout_window_start.activate (vout_window_t*,vout_window_cfg_t*)",video_output\window.c,"int (*activate)(vout_window_t *, const vout_window_cfg_t *) = func;",47.0,47.0,9.0,70.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
3786,212467,vout_window_New,1,vout_window_New,"vout_window_t vout_window_New (vlc_object_t*,char*,vout_window_cfg_t*,vout_window_owner_t*)",video_output\window.c,"vout_window_t *vout_window_New(vlc_object_t *obj, const char *module,
                               const vout_window_cfg_t *cfg,
                               const vout_window_owner_t *owner)
{
    window_t *w = vlc_custom_create(obj, sizeof(*w), ""window"");
    vout_window_t *window = &w->wnd;

    memset(&window->handle, 0, sizeof(window->handle));
    window->info.has_double_click = false;
    window->control = NULL;
    window->sys = NULL;

    if (owner != NULL)
        window->owner = *owner;
    else
        window->owner.resized = NULL;

    w->module = vlc_module_load(window, ""vout window"", module,
                                module && *module,
                                vout_window_start, window, cfg);
    if (!w->module) {
        vlc_object_release(window);
        return NULL;
    }

    /* Hook for screensaver inhibition */
    if (var_InheritBool(obj, ""disable-screensaver"") &&
        (window->type == VOUT_WINDOW_TYPE_XID || window->type == VOUT_WINDOW_TYP...",54.0,91.0,1.0,1.0,38.0,41,11,41,12,2,10,5,6,2,4,,0,9,8,4,4,vout_window_t
3787,212614,vout_window_stop,1,vout_window_stop,"void vout_window_stop (void*,va_list)",video_output\window.c,"static void vout_window_stop(void *func, va_list ap)
{
    int (*deactivate)(vout_window_t *) = func;
    vout_window_t *wnd = va_arg(ap, vout_window_t *);

    deactivate(wnd);
}",93.0,99.0,1.0,1.0,7.0,0,0,1,1,0,0,1,1,0,0,,0,0,4,2,2,void
3788,212618,deactivate,1,vout_window_stop.deactivate,int vout_window_stop.deactivate (vout_window_t*),video_output\window.c,int (*deactivate)(vout_window_t *) = func;,95.0,95.0,9.0,45.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
3789,212628,vout_window_Delete,1,vout_window_Delete,void vout_window_Delete (vout_window_t*),video_output\window.c,"void vout_window_Delete(vout_window_t *window)
{
    if (!window)
        return;

    window_t *w = (window_t *)window;
    if (w->inhibit)
    {
        vlc_inhibit_Set (w->inhibit, VLC_INHIBIT_NONE);
        vlc_inhibit_Destroy (w->inhibit);
    }

    vlc_module_unload(window, w->module, vout_window_stop, window);
    vlc_object_release(window);
}",101.0,115.0,1.0,1.0,15.0,7,4,11,3,3,7,3,3,1,3,,0,4,2,1,1,void
3790,212667,vout_window_SetInhibition,1,vout_window_SetInhibition,"void vout_window_SetInhibition (vout_window_t*,bool)",video_output\window.c,"void vout_window_SetInhibition(vout_window_t *window, bool enabled)
{
    window_t *w = (window_t *)window;
    unsigned flags = enabled ? VLC_INHIBIT_VIDEO : VLC_INHIBIT_NONE;

    if (w->inhibit != NULL)
        vlc_inhibit_Set(w->inhibit, flags);
}",117.0,124.0,1.0,1.0,8.0,7,5,10,7,1,2,2,2,1,0,,0,2,4,2,2,void
3791,212704,vout_display_window_ResizeNotify,1,vout_display_window_ResizeNotify,"void vout_display_window_ResizeNotify (vout_window_t*,unsigned,unsigned)",video_output\window.c,"static void vout_display_window_ResizeNotify(vout_window_t *window,
                                             unsigned width, unsigned height)
{
    vout_display_window_t *state = window->owner.sys;

    msg_Dbg(window, ""resized to %ux%u"", width, height);
    vlc_mutex_lock(&state->lock);
    state->width = width;
    state->height = height;

    if (state->vd != NULL)
        vout_display_SendEventDisplaySize(state->vd, width, height);
    vlc_mutex_unlock(&state->lock);
}",141.0,154.0,1.0,1.0,14.0,14,5,16,5,0,2,2,2,0,2,,0,0,6,3,3,void
3792,212757,vout_display_window_CloseNotify,1,vout_display_window_CloseNotify,void vout_display_window_CloseNotify (vout_window_t*),video_output\window.c,"static void vout_display_window_CloseNotify(vout_window_t *window)
{
    vout_thread_t *vout = (vout_thread_t *)window->obj.parent;

    vout_SendEventClose(vout);
}",156.0,161.0,1.0,1.0,6.0,4,4,3,2,0,1,1,1,0,1,,0,0,2,1,1,void
3793,212774,vout_display_window_MouseEvent,1,vout_display_window_MouseEvent,"void vout_display_window_MouseEvent (vout_window_t*,vout_window_mouse_event_t*)",video_output\window.c,"static void vout_display_window_MouseEvent(vout_window_t *window,
                                           const vout_window_mouse_event_t *mouse)
{
    vout_thread_t *vout = (vout_thread_t *)window->obj.parent;
    vout_WindowMouseEvent(vout, mouse);
}",163.0,168.0,1.0,1.0,6.0,4,4,4,3,0,1,1,1,0,1,,0,0,4,2,2,void
3794,212793,vout_display_window_New,1,vout_display_window_New,"vout_window_t vout_display_window_New (vout_thread_t*,vout_window_cfg_t*)",video_output\window.c,"vout_window_t *vout_display_window_New(vout_thread_t *vout,
                                       const vout_window_cfg_t *cfg)
{
    vout_display_window_t *state = malloc(sizeof (*state));
    if (state == NULL)
        return NULL;

    state->vd = NULL;
    state->width = cfg->width;
    state->height = cfg->height;
    vlc_mutex_init(&state->lock);

    vout_window_owner_t owner = {
        .sys = state,
        .resized = vout_display_window_ResizeNotify,
        .closed = vout_display_window_CloseNotify,
        .mouse_event = vout_display_window_MouseEvent,
    };
    vout_window_t *window;

    window = vout_window_New((vlc_object_t *)vout, ""$window"", cfg, &owner);
    if (window == NULL) {
        vlc_mutex_destroy(&state->lock);
        free(state);
    }
    return window;
}",173.0,199.0,1.0,1.0,27.0,26,8,27,10,2,3,3,3,0,3,,0,1,4,2,2,vout_window_t
3795,212882,vout_display_window_Attach,1,vout_display_window_Attach,"void vout_display_window_Attach (vout_window_t*,vout_display_t*)",video_output\window.c,"void vout_display_window_Attach(vout_window_t *window, vout_display_t *vd)
{
    vout_display_window_t *state = window->owner.sys;

    vout_window_SetSize(window,
                        vd->cfg->display.width, vd->cfg->display.height);

    vlc_mutex_lock(&state->lock);
    state->vd = vd;

    vout_display_SendEventDisplaySize(vd, state->width, state->height);
    vlc_mutex_unlock(&state->lock);
}",205.0,217.0,1.0,1.0,13.0,17,4,12,3,2,2,1,1,0,2,,0,0,4,2,2,void
3796,212935,vout_display_window_Detach,1,vout_display_window_Detach,void vout_display_window_Detach (vout_window_t*),video_output\window.c,"void vout_display_window_Detach(vout_window_t *window)
{
    vout_display_window_t *state = window->owner.sys;

    vlc_mutex_lock(&state->lock);
    state->vd = NULL;
    vlc_mutex_unlock(&state->lock);
}",223.0,230.0,1.0,1.0,8.0,9,4,6,3,2,2,1,1,0,2,,0,0,2,1,1,void
3797,212963,vout_display_window_Delete,1,vout_display_window_Delete,void vout_display_window_Delete (vout_window_t*),video_output\window.c,"void vout_display_window_Delete(vout_window_t *window)
{
    vout_display_window_t *state = window->owner.sys;

    vout_window_Delete(window);

    assert(state->vd == NULL);
    vlc_mutex_destroy(&state->lock);
    free(state);
}",236.0,245.0,1.0,1.0,10.0,7,5,7,3,3,2,1,1,0,2,,0,0,2,1,1,void
3798,213119,config_GetShellDir,1,config_GetShellDir,char* config_GetShellDir (int),win32\dirs.c,"static char *config_GetShellDir (int csidl)
{
    wchar_t wdir[MAX_PATH];

    if (SHGetFolderPathW (NULL, csidl | CSIDL_FLAG_CREATE,
                          NULL, SHGFP_TYPE_CURRENT, wdir ) == S_OK)
        return FromWide (wdir);
    return NULL;
}",215.0,223.0,1.0,1.0,9.0,2,2,9,6,0,0,2,2,0,0,,0,0,2,1,1,char*
3799,213649,widen_path,1,widen_path,wchar_t widen_path (char*),win32\filesystem.c,"static wchar_t *widen_path (const char *path)
{
    wchar_t *wpath;

    errno = 0;
    wpath = ToWide (path);
    if (wpath == NULL)
    {
        if (errno == 0)
            errno = ENOENT;
        return NULL;
    }
    return wpath;
}",52.0,65.0,1.0,1.0,14.0,5,2,10,5,0,0,3,4,0,0,,0,0,2,1,1,wchar_t
3800,214402,vlc_win32_tmpfile,1,vlc_win32_tmpfile,FILE vlc_win32_tmpfile (void),win32\filesystem.c,"FILE *vlc_win32_tmpfile(void)
{
    TCHAR tmp_path[MAX_PATH-14];
    int i_ret = GetTempPath (MAX_PATH-14, tmp_path);
    if (i_ret == 0)
        return NULL;

    TCHAR tmp_name[MAX_PATH];
    i_ret = GetTempFileName(tmp_path, TEXT(""VLC""), 0, tmp_name);
    if (i_ret == 0)
        return NULL;

    HANDLE hFile = CreateFile(tmp_name,
            GENERIC_READ | GENERIC_WRITE | DELETE, 0, NULL, CREATE_ALWAYS,
            FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_DELETE_ON_CLOSE, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
        return NULL;

    int fd = _open_osfhandle((intptr_t)hFile, 0);
    if (fd == -1) {
        CloseHandle(hFile);
        return NULL;
    }

    FILE *stream = _fdopen(fd, ""w+b"");
    if (stream == NULL) {
        _close(fd);
        return NULL;
    }
    return stream;
}",361.0,391.0,1.0,1.0,31.0,16,6,35,15,0,0,6,6,0,0,,0,0,2,1,1,FILE
3801,214517,MtaMainLoop,1,MtaMainLoop,void* MtaMainLoop (void*),win32\mta_holder.h,"static inline void* MtaMainLoop( void* opaque )
{
    vlc_mta_holder* p_mta = (vlc_mta_holder*)opaque;
    CoInitializeEx( NULL, COINIT_MULTITHREADED );

    vlc_sem_post( &p_mta->ready_sem );

    vlc_sem_wait( &p_mta->release_sem );

    CoUninitialize();
    return NULL;
}",40.0,51.0,1.0,1.0,12.0,6,4,7,4,0,4,1,1,0,2,,0,2,2,1,1,void*
3802,214544,vlc_mta_acquire,1,vlc_mta_acquire,bool vlc_mta_acquire (vlc_object_t*),win32\mta_holder.h,"static inline bool vlc_mta_acquire( vlc_object_t *p_parent )
{
    vlc_global_lock( VLC_MTA_MUTEX );
    vlc_mta_holder* p_mta = (vlc_mta_holder*)var_CreateGetAddress( p_parent->obj.libvlc, ""mta-holder"" );
    if ( p_mta == NULL )
    {
        p_mta = (vlc_mta_holder*)malloc( sizeof( *p_mta ) );
        if ( unlikely( p_mta == NULL ) )
        {
            vlc_global_unlock( VLC_MTA_MUTEX );
            return false;
        }
        vlc_sem_init( &p_mta->ready_sem, 0 );
        vlc_sem_init( &p_mta->release_sem, 0 );
        p_mta->i_refcount = 1;
        if ( vlc_clone( &p_mta->thread, MtaMainLoop, p_mta, VLC_THREAD_PRIORITY_LOW ) )
        {
            vlc_sem_destroy( &p_mta->release_sem );
            vlc_sem_destroy( &p_mta->ready_sem );
            free( p_mta );
            p_mta = NULL;
            vlc_global_unlock( VLC_MTA_MUTEX );
            return false;
        }
        var_SetAddress( p_parent->obj.libvlc, ""mta-holder"", p_mta );
        vlc_sem_wait( &p_mta->rea...",62.0,93.0,1.0,1.0,32.0,27,8,29,7,0,13,4,6,2,6,,0,8,2,1,1,bool
3803,214655,vlc_mta_release,1,vlc_mta_release,void vlc_mta_release (vlc_object_t*),win32\mta_holder.h,"static inline void vlc_mta_release( vlc_object_t* p_parent )
{
    vlc_global_lock( VLC_MTA_MUTEX );
    vlc_mta_holder *p_mta = (vlc_mta_holder*)var_InheritAddress( p_parent->obj.libvlc, ""mta-holder"" );
    assert( p_mta != NULL );
    int i_refcount = --p_mta->i_refcount;
    if ( i_refcount == 0 )
        var_SetAddress( p_parent->obj.libvlc, ""mta-holder"", NULL );
    vlc_global_unlock( VLC_MTA_MUTEX );
    if ( i_refcount == 0 )
    {
        vlc_sem_post( &p_mta->release_sem );

        vlc_join( p_mta->thread, NULL );

        vlc_sem_destroy( &p_mta->release_sem );
        vlc_sem_destroy( &p_mta->ready_sem );
        free( p_mta );
    }
}",100.0,119.0,1.0,1.0,20.0,19,8,18,5,0,9,3,3,0,4,,0,5,2,1,1,void
3804,214844,GetWindowsError,1,GetWindowsError,char* GetWindowsError (void),win32\plugin.c,"static char *GetWindowsError( void )
{
    wchar_t wmsg[256];
    int i = 0, i_error = GetLastError();

    FormatMessageW( FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                    NULL, i_error, MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT),
                    wmsg, 256, NULL );

    /* Go to the end of the string */
    while( !wmemchr( L""\r\n\0"", wmsg[i], 3 ) )
        i++;

    snwprintf( wmsg + i, 256 - i, L"" (error %i)"", i_error );
    return FromWide( wmsg );
}",77.0,92.0,1.0,1.0,16.0,7,6,17,8,0,0,2,2,0,0,,0,0,2,1,1,char*
3805,215096,system_InitWSA,1,system_InitWSA,"int system_InitWSA (int,int)",win32\specific.c,"static int system_InitWSA(int hi, int lo)
{
    WSADATA data;

    if (WSAStartup(MAKEWORD(hi, lo), &data) == 0)
    {
        if (LOBYTE(data.wVersion) == 2 && HIBYTE(data.wVersion) == 2)
            return 0;
        /* Winsock DLL is not usable */
        WSACleanup( );
    }
    return -1;
}",44.0,56.0,1.0,1.0,13.0,8,5,5,3,0,0,3,4,0,0,,0,0,4,2,2,int
3806,215783,vlc_threadvars_cleanup,1,vlc_threadvars_cleanup,void vlc_threadvars_cleanup (void),win32\thread.c,"static void vlc_threadvars_cleanup(void)
{
    vlc_threadvar_t key;
retry:
    /* TODO: use RW lock or something similar */
    EnterCriticalSection(&super_mutex);
    for (key = vlc_threadvar_last; key != NULL; key = key->prev)
    {
        void *value = vlc_threadvar_get(key);
        if (value != NULL && key->destroy != NULL)
        {
            LeaveCriticalSection(&super_mutex);
            vlc_threadvar_set(key, NULL);
            key->destroy(value);
            goto retry;
        }
    }
    LeaveCriticalSection(&super_mutex);
}",300.0,318.0,1.0,1.0,19.0,11,5,17,5,0,6,4,4,0,2,,0,5,2,1,1,void
3807,215902,vlc_thread_destroy,1,vlc_thread_destroy,void vlc_thread_destroy (vlc_thread_t),win32\thread.c,"static void vlc_thread_destroy(vlc_thread_t th)
{
    DeleteCriticalSection(&th->wait.lock);
    free(th);
}",458.0,462.0,1.0,1.0,5.0,3,3,2,1,0,0,1,1,0,0,,0,0,2,1,1,void
3808,216526,query,1,clk.interrupt.query,BOOL clk.interrupt.query (ANY),win32\thread.c,BOOL (*query) (PULONGLONG);,718.0,718.0,14.0,34.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,BOOL
3809,216533,get,1,clk.tick.get,ULONGLONG clk.tick.get (void),win32\thread.c,ULONGLONG (*get) (void);,724.0,724.0,19.0,31.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ULONGLONG
3810,216543,,1,clk.multimedia.,MMRESULT clk.multimedia. (WINAPI*),win32\thread.c,MMRESULT (WINAPI *timeGetDevCaps),734.0,734.0,18.0,41.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,MMRESULT
3811,216559,mdate_interrupt,1,mdate_interrupt,mtime_t mdate_interrupt (void),win32\thread.c,"static mtime_t mdate_interrupt (void)
{
    ULONGLONG ts;
    BOOL ret;

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN7)
    ret = QueryUnbiasedInterruptTime (&ts);
#else
    ret = clk.interrupt.query (&ts);
#endif
    if (unlikely(!ret))
        abort ();

    /* hundreds of nanoseconds */
    static_assert ((10000000 % CLOCK_FREQ) == 0, ""Broken frequencies ratio"");
    return ts / (10000000 / CLOCK_FREQ);
}",740.0,756.0,1.0,1.0,17.0,7,6,6,3,0,0,2,2,0,0,,0,0,2,1,1,mtime_t
3812,216590,mdate_tick,1,mdate_tick,mtime_t mdate_tick (void),win32\thread.c,"static mtime_t mdate_tick (void)
{
#if (_WIN32_WINNT >= _WIN32_WINNT_VISTA)
    ULONGLONG ts = GetTickCount64 ();
#else
    ULONGLONG ts = clk.tick.get ();
#endif

    /* milliseconds */
    static_assert ((CLOCK_FREQ % 1000) == 0, ""Broken frequencies ratio"");
    return ts * (CLOCK_FREQ / 1000);
}",758.0,769.0,1.0,1.0,12.0,5,5,4,2,0,0,1,1,0,0,,0,0,2,1,1,mtime_t
3813,216612,mdate_multimedia,1,mdate_multimedia,mtime_t mdate_multimedia (void),win32\thread.c,"static mtime_t mdate_multimedia (void)
{
    DWORD ts = clk.multimedia.timeGetTime ();

    /* milliseconds */
    static_assert ((CLOCK_FREQ % 1000) == 0, ""Broken frequencies ratio"");
    return ts * (CLOCK_FREQ / 1000);
}",771.0,778.0,1.0,1.0,8.0,7,6,5,3,0,1,1,1,0,0,,0,1,2,1,1,mtime_t
3814,216639,mdate_perf,1,mdate_perf,mtime_t mdate_perf (void),win32\thread.c,"static mtime_t mdate_perf (void)
{
    /* We don't need the real date, just the value of a high precision timer */
    LARGE_INTEGER counter;
    if (!QueryPerformanceCounter (&counter))
        abort ();

    /* Convert to from (1/freq) to microsecond resolution */
    /* We need to split the division to avoid 63-bits overflow */
    lldiv_t d = lldiv (counter.QuadPart, clk.perf.freq.QuadPart);

    return (d.quot * 1000000) + ((d.rem * 1000000) / clk.perf.freq.QuadPart);
}",781.0,793.0,1.0,1.0,13.0,16,7,7,3,1,2,2,2,0,0,,0,2,2,1,1,mtime_t
3815,216686,mdate_wall,1,mdate_wall,mtime_t mdate_wall (void),win32\thread.c,"static mtime_t mdate_wall (void)
{
    FILETIME ts;
    ULARGE_INTEGER s;

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN8) && (!VLC_WINSTORE_APP || _WIN32_WINNT >= 0x0A00)
    GetSystemTimePreciseAsFileTime (&ts);
#else
    GetSystemTimeAsFileTime (&ts);
#endif
    s.LowPart = ts.dwLowDateTime;
    s.HighPart = ts.dwHighDateTime;
    /* hundreds of nanoseconds */
    static_assert ((10000000 % CLOCK_FREQ) == 0, ""Broken frequencies ratio"");
    return s.QuadPart / (10000000 / CLOCK_FREQ);
}",795.0,810.0,1.0,1.0,16.0,12,6,8,3,0,0,1,1,0,0,,0,0,2,1,1,mtime_t
3816,216725,mdate_default,1,mdate_default,mtime_t mdate_default (void),win32\thread.c,"static mtime_t mdate_default(void)
{
    vlc_threads_setup(NULL);
    return mdate_perf();
}",812.0,816.0,1.0,1.0,5.0,0,0,1,1,0,2,1,1,0,2,,0,0,2,1,1,mtime_t
3817,216734,mdate_selected,1,mdate_selected,mtime_t mdate_selected (void),win32\thread.c,static mtime_t (*mdate_selected) (void) = mdate_default;,818.0,818.0,16.0,55.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,mtime_t
3818,216749,SelectClockSource,1,SelectClockSource,BOOL SelectClockSource (void*),win32\thread.c,"static BOOL SelectClockSource(void *data)
{
    vlc_object_t *obj = data;

#if VLC_WINSTORE_APP
    const char *name = ""perf"";
#else
    const char *name = ""multimedia"";
#endif
    char *str = NULL;
    if (obj != NULL)
        str = var_InheritString(obj, ""clock-source"");
    if (str != NULL)
        name = str;
    if (!strcmp (name, ""interrupt""))
    {
        msg_Dbg (obj, ""using interrupt time as clock source"");
#if (_WIN32_WINNT < _WIN32_WINNT_WIN7)
        HANDLE h = GetModuleHandle (_T(""kernel32.dll""));
        if (unlikely(h == NULL))
            return FALSE;
        clk.interrupt.query = (void *)GetProcAddress (h,
                                                      ""QueryUnbiasedInterruptTime"");
        if (unlikely(clk.interrupt.query == NULL))
            abort ();
#endif
        mdate_selected = mdate_interrupt;
    }
    else
    if (!strcmp (name, ""tick""))
    {
        msg_Dbg (obj, ""using Windows time as clock source"");
#if (_WIN32_WINNT < _WIN32_WINNT_VISTA)
   ...",848.0,941.0,1.0,1.0,94.0,9,3,18,7,0,0,4,4,0,0,,0,0,2,1,1,BOOL
3819,216979,EnumClockSource,1,EnumClockSource,"size_t EnumClockSource (vlc_object_t*,char*,char***,char***)",win32\thread.c,"size_t EnumClockSource (vlc_object_t *obj, const char *var,
                        char ***vp, char ***np)
{
    const size_t max = 6;
    char **values = xmalloc (sizeof (*values) * max);
    char **names = xmalloc (sizeof (*names) * max);
    size_t n = 0;

#if (_WIN32_WINNT < _WIN32_WINNT_WIN7)
    DWORD version = LOWORD(GetVersion());
    version = (LOBYTE(version) << 8) | (HIBYTE(version) << 0);
#endif

    values[n] = xstrdup ("""");
    names[n] = xstrdup (_(""Auto""));
    n++;
#if (_WIN32_WINNT < _WIN32_WINNT_WIN7)
    if (version >= 0x0601)
#endif
    {
        values[n] = xstrdup (""interrupt"");
        names[n] = xstrdup (""Interrupt time"");
        n++;
    }
#if (_WIN32_WINNT < _WIN32_WINNT_VISTA)
    if (version >= 0x0600)
#endif
    {
        values[n] = xstrdup (""tick"");
        names[n] = xstrdup (""Windows time"");
        n++;
    }
#if !VLC_WINSTORE_APP
    values[n] = xstrdup (""multimedia"");
    names[n] = xstrdup (""Multimedia timers"");
    n++;
#endif
    values[n] =...",943.0,991.0,1.0,1.0,49.0,46,7,45,8,0,0,1,1,0,0,,0,0,8,4,4,size_t
3820,217192,DllMain,1,DllMain,"WINAPI DllMain (ANY,ANY,ANY)",win32\thread.c,"WINAPI DllMain (HINSTANCE hinstDll, DWORD fdwReason, LPVOID lpvReserved)
{
    (void) hinstDll;
    (void) lpvReserved;

    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
#if (_WIN32_WINNT < _WIN32_WINNT_WIN8)
            HANDLE h = GetModuleHandle(TEXT(""kernel32.dll""));
            if (unlikely(h == NULL))
                return FALSE;

            if (!LOOKUP(WaitOnAddress)
             || !LOOKUP(WakeByAddressAll) || !LOOKUP(WakeByAddressSingle))
            {
# if (_WIN32_WINNT < _WIN32_WINNT_VISTA)
                if (!LOOKUP(InitializeConditionVariable)
                 || !LOOKUP(SleepConditionVariableCS)
                 || !LOOKUP(WakeAllConditionVariable))
                {
                    InitializeConditionVariable_ = DummyConditionVariable;
                    SleepConditionVariableCS_ = SleepConditionVariableFallback;
                    WakeAllConditionVariable_ = DummyConditionVariable;
                }
# endif
                vlc_wait_addr...",1043.0,1103.0,6.0,1.0,61.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,WINAPI
3821,64,fields,4,fields,,android\specific.c,"static struct {
    struct {
        jclass clazz;
        jmethodID getExternalStoragePublicDirectory;
    } Environment;
    struct {
        jmethodID getAbsolutePath;
    } File;
    struct {
        jclass clazz;
        jmethodID getProperty;
    } System;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3822,65,fields.Environment,4,fields.Environment,,android\specific.c,"struct {
        jclass clazz;
        jmethodID getExternalStoragePublicDirectory;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3823,69,fields.File,4,fields.File,,android\specific.c,"struct {
        jmethodID getAbsolutePath;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3824,72,fields.System,4,fields.System,,android\specific.c,"struct {
        jclass clazz;
        jmethodID getProperty;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3825,1459,vlc_thread,4,vlc_thread,,android\thread.c,"struct vlc_thread
{
    pthread_t      thread;
    vlc_sem_t      finished;

    void *(*entry)(void*);
    void *data;

    struct
    {
        void *addr; /// Non-null if waiting on futex
        vlc_mutex_t lock ; /// Protects futex address
    } wait;

    atomic_bool killed;
    bool killable;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3826,1468,vlc_thread.wait,4,vlc_thread.wait,,android\thread.c,"struct
    {
        void *addr; /// Non-null if waiting on futex
        vlc_mutex_t lock ; /// Protects futex address
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3827,2114,anonymous_enum_0,4,anonymous_enum_0,,audio_output\aout_internal.h,"enum {
    AOUT_RESAMPLING_NONE=0,
    AOUT_RESAMPLING_UP,
    AOUT_RESAMPLING_DOWN
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3828,2125,aout_request_vout,4,aout_request_vout,,audio_output\aout_internal.h,"struct aout_request_vout
{
    struct vout_thread_t  *(*pf_request_vout)( void *, struct vout_thread_t *,
                                               const video_format_t *, bool );
    void *p_private;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3829,2126,vout_thread_t,4,aout_request_vout.vout_thread_t,,audio_output\aout_internal.h,struct vout_thread_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3830,2129,aout_volume,4,aout_volume,,audio_output\aout_internal.h,typedef struct aout_volume,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3831,2130,aout_volume_t,4,aout_volume_t,,audio_output\aout_internal.h,typedef struct aout_volume aout_volume_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3832,2131,aout_dev,4,aout_dev,,audio_output\aout_internal.h,typedef struct aout_dev,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3833,2132,aout_dev_t,4,aout_dev_t,,audio_output\aout_internal.h,typedef struct aout_dev aout_dev_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3834,2133,aout_owner_t,4,aout_owner_t,,audio_output\aout_internal.h,"typedef struct
{
    vlc_mutex_t lock;
    module_t *module; /**< Output plugin (or NULL if inactive) */
    aout_filters_t *filters;
    aout_volume_t *volume;

    struct
    {
        vlc_mutex_t lock;
        char *device;
        float volume;
        signed char mute;
    } req;

    struct
    {
        vlc_mutex_t lock;
        aout_dev_t *list;
        unsigned count;
    } dev;

    struct
    {
        atomic_bool update;
        vlc_mutex_t lock;
        vlc_viewpoint_t value;
    } vp;

    struct
    {
        mtime_t end; /**< Last seen PTS */
        unsigned resamp_start_drift; /**< Resampler drift absolute value */
        int resamp_type; /**< Resampler mode (FIXME: redundant / resampling) */
        bool discontinuity;
    } sync;

    int initial_stereo_mode; /**< Initial stereo mode set by options */

    audio_sample_format_t input_format;
    audio_sample_format_t mixer_format;

    aout_request_vout_t request_vout;
    aout_filters_cfg_t filters_cfg;

    at...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3835,2138,aout_owner_t.req,4,aout_owner_t.req,,audio_output\aout_internal.h,"struct
    {
        vlc_mutex_t lock;
        char *device;
        float volume;
        signed char mute;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3836,2144,aout_owner_t.dev,4,aout_owner_t.dev,,audio_output\aout_internal.h,"struct
    {
        vlc_mutex_t lock;
        aout_dev_t *list;
        unsigned count;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3837,2149,aout_owner_t.vp,4,aout_owner_t.vp,,audio_output\aout_internal.h,"struct
    {
        atomic_bool update;
        vlc_mutex_t lock;
        vlc_viewpoint_t value;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3838,2154,aout_owner_t.sync,4,aout_owner_t.sync,,audio_output\aout_internal.h,"struct
    {
        mtime_t end; /**< Last seen PTS */
        unsigned resamp_start_drift; /**< Resampler drift absolute value */
        int resamp_type; /**< Resampler mode (FIXME: redundant / resampling) */
        bool discontinuity;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3839,2169,aout_instance_t,4,aout_instance_t,,audio_output\aout_internal.h,"typedef struct
{
    audio_output_t output;
    aout_owner_t   owner;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3840,7006,aout_filters,4,aout_filters,,audio_output\filters.c,"struct aout_filters
{
    filter_t *rate_filter; /**< The filter adjusting samples count
        (either the scaletempo filter or a resampler) */
    filter_t *resampler; /**< The resampler */
    int resampling; /**< Current resampling (Hz) */

    unsigned count; /**< Number of filters */
    filter_t *tab[AOUT_MAX_FILTERS]; /**< Configured user filters
        (e.g. equalization) and their conversions */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3841,8310,aout_dev,4,aout_dev,,audio_output\output.c,"struct aout_dev
{
    aout_dev_t *next;
    char *name;
    char id[1];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3842,10893,aout_volume,4,aout_volume,,audio_output\volume.c,"struct aout_volume
{
    audio_volume_t object;
    audio_replay_gain_t replay_gain;
    vlc_atomic_float gain_factor;
    float output_factor;
    module_t *module;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3843,14611,config,4,config,,config\core.c,"static struct
{
    module_config_t **list;
    size_t count;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3844,19520,vlc_getopt_s,4,vlc_getopt_s,,config\vlc_getopt.h,"typedef struct vlc_getopt_s
{
/* For communication from `getopt' to the caller.
   When `getopt' finds an option that takes an argument,
   the argument value is returned here.  */

    char *arg;

/* Index in ARGV of the next element to be scanned.
   This is used for communication to and from the caller
   and for communication between successive calls to `getopt'.

   On entry to `getopt', zero means this is the first call; initialize.

   When `getopt' returns -1, this is the index of the first of the
   non-option elements that the caller should itself scan.

   Otherwise, `optind' communicates from one call to the next
   how much of ARGV has been scanned so far.  */

    int ind;

/* Set to an option character which was unrecognized.  */

    int opt;

/* The next char to be scanned in the option-element
   in which the last option character we returned was found.
   This allows us to pick up the scan where we left off.

   If this is zero, or a null string, it means resume t...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3845,19527,vlc_getopt_t,4,vlc_getopt_t,,config\vlc_getopt.h,"typedef struct vlc_getopt_s
{
/* For communication from `getopt' to the caller.
   When `getopt' finds an option that takes an argument,
   the argument value is returned here.  */

    char *arg;

/* Index in ARGV of the next element to be scanned.
   This is used for communication to and from the caller
   and for communication between successive calls to `getopt'.

   On entry to `getopt', zero means this is the first call; initialize.

   When `getopt' returns -1, this is the index of the first of the
   non-option elements that the caller should itself scan.

   Otherwise, `optind' communicates from one call to the next
   how much of ARGV has been scanned so far.  */

    int ind;

/* Set to an option character which was unrecognized.  */

    int opt;

/* The next char to be scanned in the option-element
   in which the last option character we returned was found.
   This allows us to pick up the scan where we left off.

   If this is zero, or a null string, it means resume t...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3846,19528,vlc_option,4,vlc_option,,config\vlc_getopt.h,"struct vlc_option
{
    const char *name;
    bool has_arg;
    int *flag;
    int val;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3847,24094,average_t,4,average_t,,input\clock.c,"typedef struct
{
    mtime_t i_value;
    int     i_residue;

    int     i_count;
    int     i_divider;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3848,24133,clock_point_t,4,clock_point_t,,input\clock.c,"typedef struct
{
    mtime_t i_stream;
    mtime_t i_system;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3849,24157,input_clock_t,4,input_clock_t,,input\clock.c,"struct input_clock_t
{
    /* */
    vlc_mutex_t lock;

    /* Last point
     * It is used to detect unexpected stream discontinuities */
    clock_point_t last;

    /* Maximal timestamp returned by input_clock_ConvertTS (in system unit) */
    mtime_t i_ts_max;

    /* Amount of extra buffering expressed in stream clock */
    mtime_t i_buffering_duration;

    /* Clock drift */
    mtime_t i_next_drift_update;
    average_t drift;

    /* Late statistics */
    struct
    {
        mtime_t  pi_value[INPUT_CLOCK_LATE_COUNT];
        unsigned i_index;
    } late;

    /* Reference point */
    clock_point_t ref;
    bool          b_has_reference;

    /* External clock drift */
    mtime_t       i_external_clock;
    bool          b_has_external_clock;

    /* Current modifiers */
    bool    b_paused;
    int     i_rate;
    mtime_t i_pts_delay;
    mtime_t i_pause_date;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3850,24164,input_clock_t.late,4,input_clock_t.late,,input\clock.c,"struct
    {
        mtime_t  pi_value[INPUT_CLOCK_LATE_COUNT];
        unsigned i_index;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3851,25719,input_clock_t,4,input_clock_t,,input\clock.h,typedef struct input_clock_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3852,25720,input_clock_t,4,input_clock_t,,input\clock.h,typedef struct input_clock_t input_clock_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3853,27537,reload,4,reload,,input\decoder.c,"enum reload
{
    RELOAD_NO_REQUEST,
    RELOAD_DECODER,     /* Reload the decoder module */
    RELOAD_DECODER_AOUT /* Stop the aout and reload the decoder module */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3854,27541,decoder_owner_sys_t,4,decoder_owner_sys_t,,input\decoder.c,"struct decoder_owner_sys_t
{
    input_thread_t  *p_input;
    input_resource_t*p_resource;
    input_clock_t   *p_clock;
    int             i_last_rate;

    vout_thread_t   *p_spu_vout;
    int              i_spu_channel;
    int64_t          i_spu_order;

    sout_instance_t         *p_sout;
    sout_packetizer_input_t *p_sout_input;

    vlc_thread_t     thread;

    void (*pf_update_stat)( decoder_owner_sys_t *, unsigned decoded, unsigned lost );

    /* Some decoders require already packetized data (ie. not truncated) */
    decoder_t *p_packetizer;
    bool b_packetizer;

    /* Current format in use by the output */
    es_format_t    fmt;

    /* */
    bool           b_fmt_description;
    vlc_meta_t     *p_description;
    atomic_int     reload;

    /* fifo */
    block_fifo_t *p_fifo;

    /* Lock for communication with decoder thread */
    vlc_mutex_t lock;
    vlc_cond_t  wait_request;
    vlc_cond_t  wait_acknowledge;
    vlc_cond_t  wait_fifo; /* TODO: merge with ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3855,27585,decoder_owner_sys_t.cc,4,decoder_owner_sys_t.cc,,input\decoder.c,"struct
    {
        bool b_supported;
        decoder_cc_desc_t desc;
        decoder_t *pp_decoder[MAX_CC_DECODERS];
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3856,34093,demux_mapping,4,demux_mapping,,input\demux.c,"typedef const struct
{
    char const key[20];
    char const name[8];

}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3857,34385,demux_priv_t,4,demux_priv_t,,input\demux.c,"typedef struct demux_priv_t
{
    demux_t demux;
    void (*destroy)(demux_t *);
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3858,34392,demux_priv_t,4,demux_priv_t,,input\demux.c,"typedef struct demux_priv_t
{
    demux_t demux;
    void (*destroy)(demux_t *);
} demux_priv_t;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3859,35807,vlc_demux_chained_t,4,vlc_demux_chained_t,,input\demux_chained.c,"struct vlc_demux_chained_t
{
    stream_t *fifo;

    vlc_thread_t thread;
    vlc_mutex_t  lock;

    struct
    {
        double  position;
        int64_t length;
        int64_t time;
    } stats;

    es_out_t *out;
    char name[];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3860,35811,vlc_demux_chained_t.stats,4,vlc_demux_chained_t.stats,,input\demux_chained.c,"struct
    {
        double  position;
        int64_t length;
        int64_t time;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3861,36225,es_out_pgrm_t,4,es_out_pgrm_t,,input\es_out.c,"typedef struct
{
    /* Program ID */
    int i_id;

    /* Number of es for this pgrm */
    int i_es;

    bool b_selected;
    bool b_scrambled;

    /* Clock for this program */
    input_clock_t *p_clock;

    mtime_t i_last_pcr;

    vlc_meta_t *p_meta;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3862,36234,es_out_id_t,4,es_out_id_t,,input\es_out.c,"struct es_out_id_t
{
    /* ES ID */
    int       i_id;
    es_out_pgrm_t *p_pgrm;

    /* */
    bool b_scrambled;

    /* Channel in the track type */
    int         i_channel;
    es_format_t fmt;
    char        *psz_language;
    char        *psz_language_code;

    decoder_t   *p_dec;
    decoder_t   *p_dec_record;

    mtime_t     i_pts_level;

    /* Fields for Video with CC */
    struct
    {
        vlc_fourcc_t type;
        uint64_t     i_bitmap;    /* channels bitmap */
        es_out_id_t  *pp_es[64]; /* a max of 64 chans for CEA708 */
    } cc;

    /* Field for CC track from a master video */
    es_out_id_t *p_master;

    /* ID for the meta data */
    int         i_meta_id;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3863,36245,es_out_id_t.cc,4,es_out_id_t.cc,,input\es_out.c,"struct
    {
        vlc_fourcc_t type;
        uint64_t     i_bitmap;    /* channels bitmap */
        es_out_id_t  *pp_es[64]; /* a max of 64 chans for CEA708 */
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3864,36258,es_out_es_props_t,4,es_out_es_props_t,,input\es_out.c,"typedef struct
{
    int         i_count;    /* es count */
    es_out_id_t *p_main_es; /* current main es */
    enum es_out_policy_e e_policy;

    /* Parameters used for es selection */
    bool        b_autoselect; /* if we want to select an es when no user prefs */
    int         i_id;       /* es id as set by es fmt.id */
    int         i_demux_id; /* same as previous, demuxer set default value */
    int         i_channel;  /* es number in creation order */
    char        **ppsz_language;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3865,36261,es_out_policy_e,4,es_out_es_props_t.es_out_policy_e,,input\es_out.c,enum es_out_policy_e,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3866,36269,es_out_sys_t,4,es_out_sys_t,,input\es_out.c,"struct es_out_sys_t
{
    input_thread_t *p_input;

    /* */
    vlc_mutex_t   lock;

    /* all programs */
    int           i_pgrm;
    es_out_pgrm_t **pgrm;
    es_out_pgrm_t *p_pgrm;  /* Master program */

    /* all es */
    int         i_id;
    int         i_es;
    es_out_id_t **es;

    /* mode gestion */
    bool  b_active;
    int         i_mode;

    es_out_es_props_t video, audio, sub;

    /* es/group to select */
    int         i_group_id;

    /* delay */
    int64_t i_audio_delay;
    int64_t i_spu_delay;

    /* Clock configuration */
    mtime_t     i_pts_delay;
    mtime_t     i_pts_jitter;
    int         i_cr_average;
    int         i_rate;

    /* */
    bool        b_paused;
    mtime_t     i_pause_date;

    /* Current preroll */
    mtime_t     i_preroll_end;

    /* Used for buffering */
    bool        b_buffering;
    mtime_t     i_buffering_extra_initial;
    mtime_t     i_buffering_extra_stream;
    mtime_t     i_buffering_extra_system;

    /* Re...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3867,46662,es_out_mode_e,4,es_out_mode_e,,input\es_out.h,"enum es_out_mode_e
{
    ES_OUT_MODE_NONE,   /* don't select anything */
    ES_OUT_MODE_ALL,    /* eg for stream output */
    ES_OUT_MODE_AUTO,   /* best audio/video or for input follow audio-track, sub-track */
    ES_OUT_MODE_PARTIAL,/* select programs given after --programs */
    ES_OUT_MODE_END     /* mark the es_out as dead */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3868,46668,es_out_query_private_e,4,es_out_query_private_e,,input\es_out.h,"enum es_out_query_private_e
{
    /* set/get mode */
    ES_OUT_SET_MODE = ES_OUT_PRIVATE_START,         /* arg1= int                            */

    /* Get date to wait before demuxing more data */
    ES_OUT_GET_WAKE_UP,                             /* arg1=mtime_t*            res=cannot fail */

    /* Wrapper for some ES command to work with id */
    ES_OUT_SET_ES_BY_ID,
    ES_OUT_RESTART_ES_BY_ID,
    ES_OUT_SET_ES_DEFAULT_BY_ID,
    ES_OUT_GET_ES_OBJECTS_BY_ID,                    /* arg1=int id, vlc_object_t **dec, vout_thread_t **, audio_output_t ** res=can fail*/

    /* Stop all selected ES and save the stopped state in a context. free the
     * context or call ES_OUT_STOP_ALL_ES */
    ES_OUT_STOP_ALL_ES,                             /* arg1=void ** */
    /* Start all ES from the context returned by ES_OUT_STOP_ALL_ES */
    ES_OUT_START_ALL_ES,                            /* arg1=void * */

    /* Get buffering state */
    ES_OUT_GET_BUFFERING,                       ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3869,46980,anonymous_enum_0,4,anonymous_enum_0,,input\es_out_timeshift.c,"enum
{
    C_ADD,
    C_SEND,
    C_DEL,
    C_CONTROL,
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3870,46985,ts_cmd_add_t,4,ts_cmd_add_t,,input\es_out_timeshift.c,"typedef struct attribute_packed
{
    es_out_id_t *p_es;
    es_format_t *p_fmt;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3871,46989,ts_cmd_del_t,4,ts_cmd_del_t,,input\es_out_timeshift.c,"typedef struct attribute_packed
{
    es_out_id_t *p_es;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3872,46992,ts_cmd_send_t,4,ts_cmd_send_t,,input\es_out_timeshift.c,"typedef struct attribute_packed
{
    es_out_id_t *p_es;
    block_t *p_block;
    int     i_offset;  /* We do not use file > INT_MAX */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3873,46997,ts_cmd_control_t,4,ts_cmd_control_t,,input\es_out_timeshift.c,"typedef struct attribute_packed
{
    int  i_query;

    union
    {
        bool b_bool;
        int  i_int;
        int64_t i_i64;
        es_out_id_t *p_es;
        struct
        {
            int     i_int;
            int64_t i_i64;
        } int_i64;
        struct
        {
            int        i_int;
            vlc_meta_t *p_meta;
        } int_meta;
        struct
        {
            int       i_int;
            vlc_epg_t *p_epg;
        } int_epg;
        struct
        {
            int       i_int;
            vlc_epg_event_t *p_evt;
        } int_epg_evt;
        struct
        {
            es_out_id_t *p_es;
            bool        b_bool;
        } es_bool;
        struct
        {
            es_out_id_t *p_es;
            es_format_t *p_fmt;
        } es_fmt;
        struct
        {
            int i_cat;
            int i_policy;
        } es_policy;
        struct
        {
            /* FIXME Really too big (double make the whole thing too big) */
      ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3874,46999,ts_cmd_control_t.u,4,ts_cmd_control_t.u,,input\es_out_timeshift.c,"union
    {
        bool b_bool;
        int  i_int;
        int64_t i_i64;
        es_out_id_t *p_es;
        struct
        {
            int     i_int;
            int64_t i_i64;
        } int_i64;
        struct
        {
            int        i_int;
            vlc_meta_t *p_meta;
        } int_meta;
        struct
        {
            int       i_int;
            vlc_epg_t *p_epg;
        } int_epg;
        struct
        {
            int       i_int;
            vlc_epg_event_t *p_evt;
        } int_epg_evt;
        struct
        {
            es_out_id_t *p_es;
            bool        b_bool;
        } es_bool;
        struct
        {
            es_out_id_t *p_es;
            es_format_t *p_fmt;
        } es_fmt;
        struct
        {
            int i_cat;
            int i_policy;
        } es_policy;
        struct
        {
            /* FIXME Really too big (double make the whole thing too big) */
            double  f_position;
            mtime_t i_time;
   ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3875,47004,ts_cmd_control_t.u.int_i64,4,ts_cmd_control_t.u.int_i64,,input\es_out_timeshift.c,"struct
        {
            int     i_int;
            int64_t i_i64;
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3876,47008,ts_cmd_control_t.u.int_meta,4,ts_cmd_control_t.u.int_meta,,input\es_out_timeshift.c,"struct
        {
            int        i_int;
            vlc_meta_t *p_meta;
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3877,47012,ts_cmd_control_t.u.int_epg,4,ts_cmd_control_t.u.int_epg,,input\es_out_timeshift.c,"struct
        {
            int       i_int;
            vlc_epg_t *p_epg;
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3878,47016,ts_cmd_control_t.u.int_epg_evt,4,ts_cmd_control_t.u.int_epg_evt,,input\es_out_timeshift.c,"struct
        {
            int       i_int;
            vlc_epg_event_t *p_evt;
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3879,47020,ts_cmd_control_t.u.es_bool,4,ts_cmd_control_t.u.es_bool,,input\es_out_timeshift.c,"struct
        {
            es_out_id_t *p_es;
            bool        b_bool;
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3880,47024,ts_cmd_control_t.u.es_fmt,4,ts_cmd_control_t.u.es_fmt,,input\es_out_timeshift.c,"struct
        {
            es_out_id_t *p_es;
            es_format_t *p_fmt;
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3881,47028,ts_cmd_control_t.u.es_policy,4,ts_cmd_control_t.u.es_policy,,input\es_out_timeshift.c,"struct
        {
            int i_cat;
            int i_policy;
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3882,47032,ts_cmd_control_t.u.times,4,ts_cmd_control_t.u.times,,input\es_out_timeshift.c,"struct
        {
            /* FIXME Really too big (double make the whole thing too big) */
            double  f_position;
            mtime_t i_time;
            mtime_t i_length;
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3883,47037,ts_cmd_control_t.u.jitter,4,ts_cmd_control_t.u.jitter,,input\es_out_timeshift.c,"struct
        {
            mtime_t i_pts_delay;
            mtime_t i_pts_jitter;
            int     i_cr_average;
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3884,47044,ts_cmd_t,4,ts_cmd_t,,input\es_out_timeshift.c,"typedef struct attribute_packed
{
    int8_t  i_type;
    mtime_t i_date;
    union
    {
        ts_cmd_add_t     add;
        ts_cmd_del_t     del;
        ts_cmd_send_t    send;
        ts_cmd_control_t control;
    } u;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3885,47047,ts_cmd_t.u,4,ts_cmd_t.u,,input\es_out_timeshift.c,"union
    {
        ts_cmd_add_t     add;
        ts_cmd_del_t     del;
        ts_cmd_send_t    send;
        ts_cmd_control_t control;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3886,47054,ts_storage_t,4,ts_storage_t,,input\es_out_timeshift.c,typedef struct ts_storage_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3887,47055,ts_storage_t,4,ts_storage_t,,input\es_out_timeshift.c,typedef struct ts_storage_t ts_storage_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3888,47056,ts_storage_t,4,ts_storage_t,,input\es_out_timeshift.c,"struct ts_storage_t
{
    ts_storage_t *p_next;

    /* */
#ifdef _WIN32
    char    *psz_file;  /* Filename */
#endif
    size_t  i_file_max; /* Max size in bytes */
    int64_t i_file_size;/* Current size in bytes */
    FILE    *p_filew;   /* FILE handle for data writing */
    FILE    *p_filer;   /* FILE handle for data reading */

    /* */
    int      i_cmd_r;
    int      i_cmd_w;
    int      i_cmd_max;
    ts_cmd_t *p_cmd;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3889,47067,ts_thread_t,4,ts_thread_t,,input\es_out_timeshift.c,"typedef struct
{
    vlc_thread_t   thread;
    input_thread_t *p_input;
    es_out_t       *p_out;
    int64_t        i_tmp_size_max;
    const char     *psz_tmp_path;

    /* Lock for all following fields */
    vlc_mutex_t    lock;
    vlc_cond_t     wait;

    /* */
    bool           b_paused;
    mtime_t        i_pause_date;

    /* */
    int            i_rate;
    int            i_rate_source;
    mtime_t        i_rate_date;
    mtime_t        i_rate_delay;

    /* */
    mtime_t        i_buffering_delay;

    /* */
    ts_storage_t   *p_storage_r;
    ts_storage_t   *p_storage_w;

    mtime_t        i_cmd_delay;

}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3890,47086,es_out_id_t,4,es_out_id_t,,input\es_out_timeshift.c,"struct es_out_id_t
{
    es_out_id_t *p_es;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3891,47088,es_out_sys_t,4,es_out_sys_t,,input\es_out_timeshift.c,"struct es_out_sys_t
{
    input_thread_t *p_input;
    es_out_t       *p_out;

    /* Configuration */
    int64_t        i_tmp_size_max;    /* Maximal temporary file size in byte */
    char           *psz_tmp_path;     /* Path for temporary files */

    /* Lock for all following fields */
    vlc_mutex_t    lock;

    /* */
    bool           b_delayed;
    ts_thread_t   *p_ts;

    /* */
    bool           b_input_paused;
    bool           b_input_paused_source;
    int            i_input_rate;
    int            i_input_rate_source;

    /* */
    int            i_es;
    es_out_id_t    **pp_es;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3892,63229,input_statistic_t,4,input_statistic_t,,input\input_interface.h,"typedef enum
{
    INPUT_STATISTIC_DECODED_VIDEO,
    INPUT_STATISTIC_DECODED_AUDIO,
    INPUT_STATISTIC_DECODED_SUBTITLE,

    /* Use them only if you do not goes through a access_out module */
    INPUT_STATISTIC_SENT_PACKET,
    INPUT_STATISTIC_SENT_BYTE,

}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3893,63264,input_source_t,4,input_source_t,,input\input_internal.h,"typedef struct
{
    VLC_COMMON_MEMBERS

    demux_t  *p_demux; /**< Demux object (most downstream) */

    /* Title infos for that input */
    bool         b_title_demux; /* Titles/Seekpoints provided by demux */
    int          i_title;
    input_title_t **title;

    int i_title_offset;
    int i_seekpoint_offset;

    int i_title_start;
    int i_title_end;
    int i_seekpoint_start;
    int i_seekpoint_end;

    /* Properties */
    bool b_can_pause;
    bool b_can_pace_control;
    bool b_can_rate_control;
    bool b_can_stream_record;
    bool b_rescale_ts;
    double f_fps;

    /* */
    int64_t i_pts_delay;

    bool       b_eof;   /* eof of demuxer */

}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3894,63265,VLC_COMMON_MEMBERS,4,VLC_COMMON_MEMBERS,,input\input_internal.h,VLC_COMMON_MEMBERS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3895,63286,input_control_t,4,input_control_t,,input\input_internal.h,"typedef struct
{
    int         i_type;
    vlc_value_t val;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3896,63290,input_thread_private_t,4,input_thread_private_t,,input\input_internal.h,"typedef struct input_thread_private_t
{
    struct input_thread_t input;

    /* Global properties */
    bool        b_preparsing;
    bool        b_can_pause;
    bool        b_can_rate_control;
    bool        b_can_pace_control;

    /* Current state */
    int         i_state;
    bool        is_running;
    bool        is_stopped;
    bool        b_recording;
    int         i_rate;

    /* Playtime configuration and state */
    int64_t     i_start;    /* :start-time,0 by default */
    int64_t     i_stop;     /* :stop-time, 0 if none */
    int64_t     i_time;     /* Current time */
    bool        b_fast_seek;/* :input-fast-seek */

    /* Output */
    bool            b_out_pace_control; /* XXX Move it ot es_sout ? */
    sout_instance_t *p_sout;            /* Idem ? */
    es_out_t        *p_es_out;
    es_out_t        *p_es_out_display;
    vlc_viewpoint_t viewpoint;
    bool            viewpoint_changed;
    vlc_renderer_item_t *p_renderer;

    /* Title infos FIXME mul...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3897,63291,input_thread_t,4,input_thread_private_t.input_thread_t,,input\input_internal.h,struct input_thread_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3898,63329,input_thread_private_t.counters,4,input_thread_private_t.counters,,input\input_internal.h,"struct {
        counter_t *p_read_packets;
        counter_t *p_read_bytes;
        counter_t *p_input_bitrate;
        counter_t *p_demux_read;
        counter_t *p_demux_bitrate;
        counter_t *p_demux_corrupted;
        counter_t *p_demux_discontinuity;
        counter_t *p_decoded_audio;
        counter_t *p_decoded_video;
        counter_t *p_decoded_sub;
        counter_t *p_sout_sent_packets;
        counter_t *p_sout_sent_bytes;
        counter_t *p_sout_send_bitrate;
        counter_t *p_played_abuffers;
        counter_t *p_lost_abuffers;
        counter_t *p_displayed_pictures;
        counter_t *p_lost_pictures;
        vlc_mutex_t counters_lock;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3899,63363,input_thread_private_t,4,input_thread_private_t,,input\input_internal.h,"typedef struct input_thread_private_t
{
    struct input_thread_t input;

    /* Global properties */
    bool        b_preparsing;
    bool        b_can_pause;
    bool        b_can_rate_control;
    bool        b_can_pace_control;

    /* Current state */
    int         i_state;
    bool        is_running;
    bool        is_stopped;
    bool        b_recording;
    int         i_rate;

    /* Playtime configuration and state */
    int64_t     i_start;    /* :start-time,0 by default */
    int64_t     i_stop;     /* :stop-time, 0 if none */
    int64_t     i_time;     /* Current time */
    bool        b_fast_seek;/* :input-fast-seek */

    /* Output */
    bool            b_out_pace_control; /* XXX Move it ot es_sout ? */
    sout_instance_t *p_sout;            /* Idem ? */
    es_out_t        *p_es_out;
    es_out_t        *p_es_out_display;
    vlc_viewpoint_t viewpoint;
    bool            viewpoint_changed;
    vlc_renderer_item_t *p_renderer;

    /* Title infos FIXME mul...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3900,63374,input_control_e,4,input_control_e,,input\input_internal.h,"enum input_control_e
{
    INPUT_CONTROL_SET_STATE,

    INPUT_CONTROL_SET_RATE,

    INPUT_CONTROL_SET_POSITION,

    INPUT_CONTROL_SET_TIME,

    INPUT_CONTROL_SET_PROGRAM,

    INPUT_CONTROL_SET_TITLE,
    INPUT_CONTROL_SET_TITLE_NEXT,
    INPUT_CONTROL_SET_TITLE_PREV,

    INPUT_CONTROL_SET_SEEKPOINT,
    INPUT_CONTROL_SET_SEEKPOINT_NEXT,
    INPUT_CONTROL_SET_SEEKPOINT_PREV,

    INPUT_CONTROL_SET_BOOKMARK,

    INPUT_CONTROL_NAV_ACTIVATE, // NOTE: INPUT_CONTROL_NAV_* values must be
    INPUT_CONTROL_NAV_UP,       // contiguous and in the same order as
    INPUT_CONTROL_NAV_DOWN,     // INPUT_NAV_* and DEMUX_NAV_*.
    INPUT_CONTROL_NAV_LEFT,
    INPUT_CONTROL_NAV_RIGHT,
    INPUT_CONTROL_NAV_POPUP,
    INPUT_CONTROL_NAV_MENU,

    INPUT_CONTROL_SET_ES,
    INPUT_CONTROL_RESTART_ES,

    INPUT_CONTROL_SET_VIEWPOINT,    // new absolute viewpoint
    INPUT_CONTROL_SET_INITIAL_VIEWPOINT, // set initial viewpoint (generally from video)
    INPUT_CONTROL_UPDATE_VIEWPOINT, // update ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3901,63514,input_item_opaque,4,input_item_opaque,,input\item.c,"struct input_item_opaque
{
    struct input_item_opaque *next;
    void *value;
    char name[1];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3902,63515,input_item_opaque,4,input_item_opaque.input_item_opaque,,input\item.c,struct input_item_opaque,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3903,66804,item_type_entry,4,item_type_entry,,input\item.c,"struct item_type_entry
{
    const char *psz_scheme;
    uint8_t    i_type;
    bool       b_net;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3904,67711,rdh_slave,4,rdh_slave,,input\item.c,"struct rdh_slave
{
    input_item_slave_t *p_slave;
    char *psz_filename;
    input_item_node_t *p_node;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3905,67715,rdh_dir,4,rdh_dir,,input\item.c,"struct rdh_dir
{
    input_item_node_t *p_node;
    char psz_path[];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3906,68885,input_item_owner,4,input_item_owner,,input\item.h,"typedef struct input_item_owner
{
    input_item_t item;
    atomic_uint refs;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3907,68888,input_item_owner_t,4,input_item_owner_t,,input\item.h,"typedef struct input_item_owner
{
    input_item_t item;
    atomic_uint refs;
} input_item_owner_t;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3908,68914,vlc_meta_t,4,vlc_meta_t,,input\meta.c,"struct vlc_meta_t
{
    char * ppsz_meta[VLC_META_TYPE_COUNT];

    vlc_dictionary_t extra_tags;

    int i_status;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3909,69997,input_resource_t,4,input_resource_t,,input\resource.c,"struct input_resource_t
{
    atomic_uint    refs;

    vlc_object_t   *p_parent;

    /* This lock is used to serialize request and protect
     * our variables */
    vlc_mutex_t    lock;

    /* */
    input_thread_t *p_input;

    sout_instance_t *p_sout;
    vout_thread_t   *p_vout_free;

    /* This lock is used to protect vout resources access (for hold)
     * It is a special case because of embed video (possible deadlock
     * between vout window request and vout holds in some(qt) interface)
     */
    vlc_mutex_t    lock_hold;

    /* You need lock+lock_hold to write to the following variables and
     * only lock or lock_hold to read them */

    vout_thread_t   **pp_vout;
    int             i_vout;

    bool            b_aout_busy;
    audio_output_t *p_aout;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3910,71141,vlc_sd_probe_t,4,vlc_sd_probe_t,,input\services_discovery.c,"typedef struct
{
    char *name;
    char *longname;
    int category;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3911,72150,stream_priv_t,4,stream_priv_t,,input\stream.c,"typedef struct stream_priv_t
{
    stream_t stream;
    void (*destroy)(stream_t *);
    block_t *block;
    block_t *peek;
    uint64_t offset;
    bool eof;

    /* UTF-16 and UTF-32 file reading */
    struct {
        vlc_iconv_t   conv;
        unsigned char char_width;
        bool          little_endian;
    } text;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3912,72161,stream_priv_t.text,4,stream_priv_t.text,,input\stream.c,"struct {
        vlc_iconv_t   conv;
        unsigned char char_width;
        bool          little_endian;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3913,72166,stream_priv_t,4,stream_priv_t,,input\stream.c,"typedef struct stream_priv_t
{
    stream_t stream;
    void (*destroy)(stream_t *);
    block_t *block;
    block_t *peek;
    uint64_t offset;
    bool eof;

    /* UTF-16 and UTF-32 file reading */
    struct {
        vlc_iconv_t   conv;
        unsigned char char_width;
        bool          little_endian;
    } text;
} stream_priv_t;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3914,74147,stream_extractor_private,4,stream_extractor_private,,input\stream_extractor.c,"struct stream_extractor_private {
    union {
        stream_extractor_t extractor;
        stream_directory_t directory;
    };

    /**
     * Callback to handle initialization
     *
     * \ref pf_init will be called after successful module probing to initialize
     * the relevant members of the underlying stream-extractor object, as well
     * as the wrapping stream.
     **/
    int (*pf_init)( struct stream_extractor_private*, stream_t* );

    /**
     * Callback to handle clean-up
     *
     * \ref pf_clean, unless NULL, will be called when the stream-extractor is to
     * be destroyed, and shall be used to clean-up resources (acquired during
     * initialization, see \ref pf_init).
     */
    void (*pf_clean)( struct stream_extractor_private* );

    stream_t* wrapper; /**< the wrapping \ref stream_t used to access the
                            underlying stream-extractor */

    stream_t* source; /**< the source stream consumed by the stream-extractor */
    modul...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3915,74148,stream_extractor_private.anonymous_composite_type_0,4,stream_extractor_private.anonymous_composite_type_0,,input\stream_extractor.c,"union {
        stream_extractor_t extractor;
        stream_directory_t directory;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3916,74921,stream_sys_t,4,stream_sys_t,,input\stream_fifo.c,"struct stream_sys_t
{
    vlc_fifo_t *fifo;
    bool eof;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3917,75525,stream_sys_t,4,stream_sys_t,,input\stream_memory.c,"struct stream_sys_t
{
    size_t    i_pos;      /* Current reading offset */
    size_t    i_size;
    uint8_t  *p_buffer;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3918,76976,vlc_input_callback_t,4,vlc_input_callback_t,,input\var.c,"typedef struct
{
    const char *psz_name;
    vlc_callback_t callback;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3919,79346,preparse_data_t,4,preparse_data_t,,input\vlm.c,"typedef struct preparse_data_t
{
    vlc_sem_t *p_sem;
    bool b_mux;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3920,79349,preparse_data_t,4,preparse_data_t,,input\vlm.c,"typedef struct preparse_data_t
{
    vlc_sem_t *p_sem;
    bool b_mux;
} preparse_data_t;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3921,83656,vlm_media_instance_sys_t,4,vlm_media_instance_sys_t,,input\vlm_internal.h,"typedef struct
{
    /* instance name */
    char *psz_name;

    /* ""playlist"" index */
    int i_index;

    bool      b_sout_keep;

    vlc_object_t *p_parent;
    input_item_t      *p_item;
    input_thread_t    *p_input;
    input_resource_t *p_input_resource;

}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3922,83665,vlm_media_sys_t,4,vlm_media_sys_t,,input\vlm_internal.h,"typedef struct
{
    vlm_media_t cfg;

    struct
    {
        input_item_t *p_item;
        vod_media_t *p_media;
    } vod;

    /* actual input instances */
    int                      i_instance;
    vlm_media_instance_sys_t **instance;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3923,83667,vlm_media_sys_t.vod,4,vlm_media_sys_t.vod,,input\vlm_internal.h,"struct
    {
        input_item_t *p_item;
        vod_media_t *p_media;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3924,83674,vlm_schedule_sys_t,4,vlm_schedule_sys_t,,input\vlm_internal.h,"typedef struct
{
    /* names ""schedule"" is reserved */
    char    *psz_name;
    bool b_enabled;
    /* list of commands to execute on date */
    int i_command;
    char **command;

    /* the date of 1st execution */
    time_t date;

    /* if != 0, repeat period in seconds */
    unsigned period;
    /* number of times you have to repeat
       i_repeat < 0 : endless repeat     */
    int i_repeat;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3925,83683,vlm_t,4,vlm_t,,input\vlm_internal.h,"struct vlm_t
{
    VLC_COMMON_MEMBERS

    vlc_mutex_t  lock;

    /* a separate mutex is needed: ""lock"" must remain locked while waiting */
    vlc_mutex_t  lock_delete;
    vlc_cond_t   wait_delete;

    vlc_thread_t thread;
    vlc_mutex_t  lock_manage;
    vlc_cond_t   wait_manage;
    unsigned     users;

    /* tell vlm thread there is work to do */
    bool         input_state_changed;
    /* */
    int64_t        i_id;

    /* Vod server (used by media) */
    vod_t          *p_vod;

    /* Media list */
    int                i_media;
    vlm_media_sys_t    **media;

    /* Schedule list */
    int            i_schedule;
    vlm_schedule_sys_t **schedule;

    unsigned i_consecutive_errors;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3926,83684,VLC_COMMON_MEMBERS,4,VLC_COMMON_MEMBERS,,input\vlm_internal.h,VLC_COMMON_MEMBERS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3927,83786,vlc_dialog_provider,4,vlc_dialog_provider,,interface\dialog.c,"struct vlc_dialog_provider
{
    vlc_mutex_t                 lock;
    vlc_array_t                 dialog_array;
    vlc_dialog_cbs              cbs;
    void *                      p_cbs_data;

    vlc_dialog_ext_update_cb    pf_ext_update;
    void *                      p_ext_data;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3928,83793,dialog_type,4,dialog_type,,interface\dialog.c,"enum dialog_type
{
    VLC_DIALOG_ERROR,
    VLC_DIALOG_LOGIN,
    VLC_DIALOG_QUESTION,
    VLC_DIALOG_PROGRESS,
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3929,83798,dialog_answer,4,dialog_answer,,interface\dialog.c,"struct dialog_answer
{
    enum dialog_type i_type;
    union
    {
        struct
        {
            char *psz_username;
            char *psz_password;
            bool b_store;
        } login;
        struct
        {
            int i_action;
        } question;
    } u;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3930,83799,dialog_type,4,dialog_answer.dialog_type,,interface\dialog.c,enum dialog_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3931,83801,dialog_answer.u,4,dialog_answer.u,,interface\dialog.c,"union
    {
        struct
        {
            char *psz_username;
            char *psz_password;
            bool b_store;
        } login;
        struct
        {
            int i_action;
        } question;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3932,83802,dialog_answer.u.login,4,dialog_answer.u.login,,interface\dialog.c,"struct
        {
            char *psz_username;
            char *psz_password;
            bool b_store;
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3933,83807,dialog_answer.u.question,4,dialog_answer.u.question,,interface\dialog.c,"struct
        {
            int i_action;
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3934,83811,dialog,4,dialog,,interface\dialog.c,"struct dialog
{
    enum dialog_type i_type;
    const char *psz_title;
    const char *psz_text;

    union
    {
        struct
        {
            const char *psz_default_username;
            bool b_ask_store;
        } login;
        struct
        {
            vlc_dialog_question_type i_type;
            const char *psz_cancel;
            const char *psz_action1;
            const char *psz_action2;
        } question;
        struct
        {
            bool b_indeterminate;
            float f_position;
            const char *psz_cancel;
        } progress;
    } u;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3935,83812,dialog_type,4,dialog.dialog_type,,interface\dialog.c,enum dialog_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3936,83816,dialog.u,4,dialog.u,,interface\dialog.c,"union
    {
        struct
        {
            const char *psz_default_username;
            bool b_ask_store;
        } login;
        struct
        {
            vlc_dialog_question_type i_type;
            const char *psz_cancel;
            const char *psz_action1;
            const char *psz_action2;
        } question;
        struct
        {
            bool b_indeterminate;
            float f_position;
            const char *psz_cancel;
        } progress;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3937,83817,dialog.u.login,4,dialog.u.login,,interface\dialog.c,"struct
        {
            const char *psz_default_username;
            bool b_ask_store;
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3938,83821,dialog.u.question,4,dialog.u.question,,interface\dialog.c,"struct
        {
            vlc_dialog_question_type i_type;
            const char *psz_cancel;
            const char *psz_action1;
            const char *psz_action2;
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3939,83827,dialog.u.progress,4,dialog.u.progress,,interface\dialog.c,"struct
        {
            bool b_indeterminate;
            float f_position;
            const char *psz_cancel;
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3940,83833,vlc_dialog_id,4,vlc_dialog_id,,interface\dialog.c,"struct vlc_dialog_id
{
    vlc_mutex_t             lock;
    vlc_cond_t              wait;
    enum dialog_type        i_type;
    void *                  p_context;
    int                     i_refcount;
    bool                    b_cancelled;
    bool                    b_answered;
    bool                    b_progress_indeterminate;
    char *                  psz_progress_text;
    struct dialog_answer    answer;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3941,83836,dialog_type,4,vlc_dialog_id.dialog_type,,interface\dialog.c,enum dialog_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3942,83844,dialog_answer,4,vlc_dialog_id.dialog_answer,,interface\dialog.c,struct dialog_answer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3943,83846,dialog_i11e_context,4,dialog_i11e_context,,interface\dialog.c,"struct dialog_i11e_context
{
    vlc_dialog_provider *   p_provider;
    vlc_dialog_id *         p_id;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3944,87810,variable_t,4,variable_t,,libvlc.h,typedef struct variable_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3945,87811,variable_t,4,variable_t,,libvlc.h,typedef struct variable_t variable_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3946,87860,vlc_logger_t,4,vlc_logger_t,,libvlc.h,typedef struct vlc_logger_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3947,87861,vlc_logger_t,4,vlc_logger_t,,libvlc.h,typedef struct vlc_logger_t vlc_logger_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3948,87877,vlc_exit,4,vlc_exit,,libvlc.h,"typedef struct vlc_exit
{
    vlc_mutex_t lock;
    void (*handler) (void *);
    void *opaque;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3949,87885,vlc_exit_t,4,vlc_exit_t,,libvlc.h,"typedef struct vlc_exit
{
    vlc_mutex_t lock;
    void (*handler) (void *);
    void *opaque;
} vlc_exit_t;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3950,87944,vlc_dialog_provider,4,vlc_dialog_provider,,libvlc.h,typedef struct vlc_dialog_provider,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3951,87945,vlc_dialog_provider,4,vlc_dialog_provider,,libvlc.h,typedef struct vlc_dialog_provider vlc_dialog_provider;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3952,87946,vlc_keystore,4,vlc_keystore,,libvlc.h,typedef struct vlc_keystore,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3953,87947,vlc_keystore,4,vlc_keystore,,libvlc.h,typedef struct vlc_keystore vlc_keystore;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3954,87948,vlc_actions_t,4,vlc_actions_t,,libvlc.h,typedef struct vlc_actions_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3955,87949,vlc_actions_t,4,vlc_actions_t,,libvlc.h,typedef struct vlc_actions_t vlc_actions_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3956,87950,libvlc_priv_t,4,libvlc_priv_t,,libvlc.h,"typedef struct libvlc_priv_t
{
    libvlc_int_t       public_data;

    /* Logging */
    bool               b_stats;     ///< Whether to collect stats

    /* Singleton objects */
    vlc_logger_t      *logger;
    vlm_t             *p_vlm;  ///< the VLM singleton (or NULL)
    vlc_dialog_provider *p_dialog_provider; ///< dialog provider
    vlc_keystore      *p_memory_keystore; ///< memory keystore
    struct playlist_t *playlist; ///< Playlist for interfaces
    struct playlist_preparser_t *parser; ///< Input item meta data handler
    vlc_actions_t *actions; ///< Hotkeys handler

    /* Exit callback */
    vlc_exit_t       exit;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3957,87957,playlist_t,4,libvlc_priv_t.playlist_t,,libvlc.h,struct playlist_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3958,87959,playlist_preparser_t,4,libvlc_priv_t.playlist_preparser_t,,libvlc.h,struct playlist_preparser_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3959,87963,libvlc_priv_t,4,libvlc_priv_t,,libvlc.h,"typedef struct libvlc_priv_t
{
    libvlc_int_t       public_data;

    /* Logging */
    bool               b_stats;     ///< Whether to collect stats

    /* Singleton objects */
    vlc_logger_t      *logger;
    vlm_t             *p_vlm;  ///< the VLM singleton (or NULL)
    vlc_dialog_provider *p_dialog_provider; ///< dialog provider
    vlc_keystore      *p_memory_keystore; ///< memory keystore
    struct playlist_t *playlist; ///< Playlist for interfaces
    struct playlist_preparser_t *parser; ///< Input item meta data handler
    vlc_actions_t *actions; ///< Hotkeys handler

    /* Exit callback */
    vlc_exit_t       exit;
} libvlc_priv_t;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3960,88004,anonymous_enum_0,4,anonymous_enum_0,,libvlc.h,"enum
{
    STATS_COUNTER,
    STATS_DERIVATIVE,
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3961,88007,counter_sample_t,4,counter_sample_t,,libvlc.h,"typedef struct counter_sample_t
{
    uint64_t value;
    mtime_t  date;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3962,88010,counter_sample_t,4,counter_sample_t,,libvlc.h,"typedef struct counter_sample_t
{
    uint64_t value;
    mtime_t  date;
} counter_sample_t;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3963,88011,counter_t,4,counter_t,,libvlc.h,"typedef struct counter_t
{
    int                 i_compute_type;
    int                 i_samples;
    counter_sample_t ** pp_samples;

    mtime_t             last_update;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3964,88016,counter_t,4,counter_t,,libvlc.h,"typedef struct counter_t
{
    int                 i_compute_type;
    int                 i_samples;
    counter_sample_t ** pp_samples;

    mtime_t             last_update;
} counter_t;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3965,88017,anonymous_enum_1,4,anonymous_enum_1,,libvlc.h,"enum
{
    STATS_INPUT_BITRATE,
    STATS_READ_BYTES,
    STATS_READ_PACKETS,
    STATS_DEMUX_READ,
    STATS_DEMUX_BITRATE,
    STATS_DEMUX_CORRUPTED,
    STATS_DEMUX_DISCONTINUITY,
    STATS_PLAYED_ABUFFERS,
    STATS_LOST_ABUFFERS,
    STATS_DECODED_AUDIO,
    STATS_DECODED_VIDEO,
    STATS_DECODED_SUB,
    STATS_CLIENT_CONNECTIONS,
    STATS_ACTIVE_CONNECTIONS,
    STATS_SOUT_SENT_PACKETS,
    STATS_SOUT_SENT_BYTES,
    STATS_SOUT_SEND_BITRATE,
    STATS_DISPLAYED_PICTURES,
    STATS_LOST_PICTURES,
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3966,88741,key_descriptor,4,key_descriptor,,misc\actions.c,"static const struct key_descriptor
{
    const char psz[20];
    uint32_t i_code;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3967,89497,name2action,4,name2action,,misc\actions.c,"static const struct name2action
{
    char psz[MAXACTION];
    vlc_action_id_t id;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3968,89845,mapping,4,mapping,,misc\actions.c,"struct mapping
{
    uint32_t     key; ///< Key code
    vlc_action_id_t action; ///< Action ID
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3969,89884,vlc_actions_t,4,vlc_actions_t,,misc\actions.c,"struct vlc_actions_t
{
    void *map; /* Key map */
    void *global_map; /* Grabbed/global key map */
    const char *ppsz_keys[];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3970,90647,addon_entry_owner,4,addon_entry_owner,,misc\addons.c,"typedef struct addon_entry_owner
{
    addon_entry_t entry;
    atomic_uint refs;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3971,90650,addon_entry_owner_t,4,addon_entry_owner_t,,misc\addons.c,"typedef struct addon_entry_owner
{
    addon_entry_t entry;
    atomic_uint refs;
} addon_entry_owner_t;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3972,90651,addons_manager_private_t,4,addons_manager_private_t,,misc\addons.c,"struct addons_manager_private_t
{
    vlc_object_t *p_parent;

    struct
    {
        vlc_thread_t thread;
        vlc_cond_t waitcond;
        bool b_live;
        vlc_mutex_t lock;
        vlc_interrupt_t *p_interrupt;
        DECL_ARRAY(char*) uris;
        DECL_ARRAY(addon_entry_t*) entries;
    } finder;

    struct
    {
        vlc_thread_t thread;
        vlc_cond_t waitcond;
        bool b_live;
        vlc_mutex_t lock;
        vlc_interrupt_t *p_interrupt;
        DECL_ARRAY(addon_entry_t*) entries;
    } installer;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3973,90653,addons_manager_private_t.finder,4,addons_manager_private_t.finder,,misc\addons.c,"struct
    {
        vlc_thread_t thread;
        vlc_cond_t waitcond;
        bool b_live;
        vlc_mutex_t lock;
        vlc_interrupt_t *p_interrupt;
        DECL_ARRAY(char*) uris;
        DECL_ARRAY(addon_entry_t*) entries;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3974,90674,addons_manager_private_t.installer,4,addons_manager_private_t.installer,,misc\addons.c,"struct
    {
        vlc_thread_t thread;
        vlc_cond_t waitcond;
        bool b_live;
        vlc_mutex_t lock;
        vlc_interrupt_t *p_interrupt;
        DECL_ARRAY(addon_entry_t*) entries;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3975,92619,bg_queued_item,4,bg_queued_item,,misc\background_worker.c,"struct bg_queued_item {
    void* id; /**< id associated with entity */
    void* entity; /**< the entity to process */
    int timeout; /**< timeout duration in microseconds */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3976,92623,background_worker,4,background_worker,,misc\background_worker.c,"struct background_worker {
    void* owner;
    struct background_worker_config conf;

    vlc_mutex_t lock; /**< acquire to inspect members that follow */
    struct {
        bool probe_request; /**< true if a probe is requested */
        vlc_cond_t wait; /**< wait for update in terms of head */
        vlc_cond_t worker_wait; /**< wait for probe request or cancelation */
        mtime_t deadline; /**< deadline of the current task */
        void* id; /**< id of the current task */
        bool active; /**< true if there is an active thread */
    } head;

    struct {
        vlc_cond_t wait; /**< wait for update in terms of tail */
        vlc_array_t data; /**< queue of pending entities to process */
    } tail;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3977,92625,background_worker_config,4,background_worker.background_worker_config,,misc\background_worker.c,struct background_worker_config,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3978,92628,background_worker.head,4,background_worker.head,,misc\background_worker.c,"struct {
        bool probe_request; /**< true if a probe is requested */
        vlc_cond_t wait; /**< wait for update in terms of head */
        vlc_cond_t worker_wait; /**< wait for probe request or cancelation */
        mtime_t deadline; /**< deadline of the current task */
        void* id; /**< id of the current task */
        bool active; /**< true if there is an active thread */
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3979,92636,background_worker.tail,4,background_worker.tail,,misc\background_worker.c,"struct {
        vlc_cond_t wait; /**< wait for update in terms of tail */
        vlc_array_t data; /**< queue of pending entities to process */
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3980,93419,background_worker_config,4,background_worker_config,,misc\background_worker.h,"struct background_worker_config {
    /**
     * Default timeout for completing a task
     *
     * If less-than 0 a task can run indefinitely without being killed, whereas
     * a positive value denotes the maximum number of milliseconds a task can
     * run before \ref pf_stop is called to kill it.
     **/
    mtime_t default_timeout;

    /**
     * Release an entity
     *
     * This callback will be called in order to decrement the ref-count of a
     * entity within the background-worker. It will happen either when \ref
     * pf_stop has finished executing, or if the entity is removed from the
     * queue (through \ref background_worker_Cancel)
     *
     * \param entity the entity to release
     **/
    void( *pf_release )( void* entity );

    /**
     * Hold a queued item
     *
     * This callback will be called in order to increment the ref-count of an
     * entity. It will happen when the entity is pushed into the queue of
     * pending tasks as part of \ref ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3981,93450,background_worker,4,background_worker,,misc\background_worker.h,struct background_worker,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3982,97270,vlc_event_listener_t,4,vlc_event_listener_t,,misc\events.c,"typedef struct vlc_event_listener_t
{
    void *               p_user_data;
    vlc_event_callback_t pf_callback;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3983,97273,vlc_event_listener_t,4,vlc_event_listener_t,,misc\events.c,"typedef struct vlc_event_listener_t
{
    void *               p_user_data;
    vlc_event_callback_t pf_callback;
} vlc_event_listener_t;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3984,97667,block_fifo_t,4,block_fifo_t,,misc\fifo.c,"struct block_fifo_t
{
    vlc_mutex_t         lock;                         /* fifo data lock */
    vlc_cond_t          wait;      /**< Wait for data */

    block_t             *p_first;
    block_t             **pp_last;
    size_t              i_depth;
    size_t              i_size;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3985,98767,chained_filter_t,4,chained_filter_t,,misc\filter_chain.c,"typedef struct chained_filter_t
{
    /* Public part of the filter structure */
    filter_t filter;
    /* Private filter chain data (shhhh!) */
    struct chained_filter_t *prev, *next;
    vlc_mouse_t *mouse;
    picture_t *pending;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3986,98769,chained_filter_t,4,chained_filter_t.chained_filter_t,,misc\filter_chain.c,struct chained_filter_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3987,98774,chained_filter_t,4,chained_filter_t,,misc\filter_chain.c,"typedef struct chained_filter_t
{
    /* Public part of the filter structure */
    filter_t filter;
    /* Private filter chain data (shhhh!) */
    struct chained_filter_t *prev, *next;
    vlc_mouse_t *mouse;
    picture_t *pending;
} chained_filter_t;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3988,98785,filter_chain_t,4,filter_chain_t,,misc\filter_chain.c,"struct filter_chain_t
{
    filter_owner_t callbacks; /**< Inner callbacks */
    filter_owner_t owner; /**< Owner (downstream) callbacks */

    chained_filter_t *first, *last; /**< List of filters */

    es_format_t fmt_in; /**< Chain input format (constant) */
    es_format_t fmt_out; /**< Chain current output format */
    bool b_allow_fmt_out_change; /**< Can the output format be changed? */
    const char *filter_cap; /**< Filter modules capability */
    const char *conv_cap; /**< Converter modules capability */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3989,102113,p_list_chroma_description,4,p_list_chroma_description,,misc\fourcc.c,"static const struct
{
    vlc_fourcc_t             p_fourcc[4];
    vlc_chroma_description_t description;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3990,104850,vlc_fourcc_t,4,vlc_fourcc_t,,misc\fourcc_gen.c,typedef uint32_t vlc_fourcc_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3991,104851,vlc_rational_t,4,vlc_rational_t,,misc\fourcc_gen.c,"typedef struct { unsigned num, den; }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3992,104855,staticentry_t,4,staticentry_t,,misc\fourcc_gen.c,"typedef struct
{
    bool klass;
    char fourcc[4];
    const char *description;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3993,104866,entry,4,entry,,misc\fourcc_gen.c,"struct entry
{
    char fourcc[4];
    char alias[4];
    const char *desc;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3994,108244,http_cookie_t,4,http_cookie_t,,misc\httpcookies.c,"typedef struct http_cookie_t
{
    char *psz_name;
    char *psz_value;
    char *psz_domain;
    char *psz_path;
    bool b_host_only;
    bool b_secure;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3995,108251,http_cookie_t,4,http_cookie_t,,misc\httpcookies.c,"typedef struct http_cookie_t
{
    char *psz_name;
    char *psz_value;
    char *psz_domain;
    char *psz_path;
    bool b_host_only;
    bool b_secure;
} http_cookie_t;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3996,108942,vlc_http_cookie_jar_t,4,vlc_http_cookie_jar_t,,misc\httpcookies.c,"struct vlc_http_cookie_jar_t
{
    vlc_array_t cookies;
    vlc_mutex_t lock;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3997,111175,ext_table,4,ext_table,,misc\image.c,"static const struct
{
    vlc_fourcc_t i_codec;
    const char psz_ext[7];

}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3998,111327,mime_table,4,mime_table,,misc\image.c,"static const struct
{
    vlc_fourcc_t i_codec;
    const char *psz_mime;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3999,113375,vlc_interrupt,4,vlc_interrupt,,misc\interrupt.h,"struct vlc_interrupt
{
    vlc_mutex_t lock;
    bool interrupted;
    atomic_bool killed;
    void (*callback)(void *);
    void *data;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4000,113856,protocol_default_ports,4,protocol_default_ports,,misc\keystore.c,"static struct
{
    const char *    psz_protocol;
    uint16_t        i_port;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4001,114912,u32,4,u32,,misc\md5.c,typedef uint32_t u32;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4002,114913,byte,4,byte,,misc\md5.c,typedef uint8_t byte;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4003,114914,md5_s,4,md5_s,,misc\md5.c,typedef struct md5_s,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4004,114915,MD5_CONTEXT,4,MD5_CONTEXT,,misc\md5.c,typedef struct md5_s MD5_CONTEXT;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4005,118025,vlc_logger_t,4,vlc_logger_t,,misc\messages.c,"struct vlc_logger_t
{
    VLC_COMMON_MEMBERS
    vlc_rwlock_t lock;
    vlc_log_cb log;
    void *sys;
    module_t *module;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4006,118026,VLC_COMMON_MEMBERS,4,VLC_COMMON_MEMBERS,,misc\messages.c,VLC_COMMON_MEMBERS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4007,118304,vlc_log_early_t,4,vlc_log_early_t,,misc\messages.c,"typedef struct vlc_log_early_t
{
    struct vlc_log_early_t *next;
    int type;
    vlc_log_t meta;
    char *msg;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4008,118305,vlc_log_early_t,4,vlc_log_early_t.vlc_log_early_t,,misc\messages.c,struct vlc_log_early_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4009,118310,vlc_log_early_t,4,vlc_log_early_t,,misc\messages.c,"typedef struct vlc_log_early_t
{
    struct vlc_log_early_t *next;
    int type;
    vlc_log_t meta;
    char *msg;
} vlc_log_early_t;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4010,118311,vlc_logger_early_t,4,vlc_logger_early_t,,misc\messages.c,"typedef struct
{
    vlc_mutex_t lock;
    vlc_log_early_t *head;
    vlc_log_early_t **tailp;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4011,119010,ext_mime,4,ext_mime,,misc\mime.c,"static const struct
{
    const char psz_ext[8];
    const char *psz_mime;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4012,121106,vlc_res,4,vlc_res,,misc\objres.c,"struct vlc_res
{
    struct vlc_res *prev;
    void (*release)(void *);
    max_align_t payload[];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4013,121107,vlc_res,4,vlc_res.vlc_res,,misc\objres.c,struct vlc_res,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4014,123147,picture_priv_t,4,picture_priv_t,,misc\picture.h,"typedef struct
{
    picture_t picture;
    struct
    {
        atomic_uintptr_t refs;
        void (*destroy)(picture_t *);
        void *opaque;
    } gc;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4015,123149,picture_priv_t.gc,4,picture_priv_t.gc,,misc\picture.h,"struct
    {
        atomic_uintptr_t refs;
        void (*destroy)(picture_t *);
        void *opaque;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4016,123172,picture_fifo_t,4,picture_fifo_t,,misc\picture_fifo.c,"struct picture_fifo_t {
    vlc_mutex_t lock;
    picture_t   *first;
    picture_t   **last_ptr;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4017,123516,picture_pool_t,4,picture_pool_t,,misc\picture_pool.c,"struct picture_pool_t {
    int       (*pic_lock)(picture_t *);
    void      (*pic_unlock)(picture_t *);
    vlc_mutex_t lock;
    vlc_cond_t  wait;

    bool               canceled;
    unsigned long long available;
    atomic_ushort      refs;
    unsigned short     picture_count;
    picture_t  *picture[];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4018,124664,rand48,4,rand48,,misc\rand.c,"static struct
{
    bool           init;
    unsigned short subi[3];
    vlc_mutex_t    lock;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4019,124804,vlc_renderer_item_t,4,vlc_renderer_item_t,,misc\renderer_discovery.c,"struct vlc_renderer_item_t
{
    char *psz_name;
    char *psz_type;
    char *psz_sout;
    char *psz_icon_uri;
    char *psz_demux_filter;
    int i_flags;
    atomic_uint refs;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4020,125157,vlc_rd_probe,4,vlc_rd_probe,,misc\renderer_discovery.c,"struct vlc_rd_probe
{
    char *psz_name;
    char *psz_longname;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4021,125435,subpicture_private_t,4,subpicture_private_t,,misc\subpicture.c,"struct subpicture_private_t
{
    video_format_t src;
    video_format_t dst;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4022,126313,subpicture_region_private_t,4,subpicture_region_private_t,,misc\subpicture.h,"struct subpicture_region_private_t {
    video_format_t fmt;
    picture_t      *p_picture;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4023,129268,anonymous_enum_0,4,anonymous_enum_0,,misc\update.h,"enum    /* Packet types */
{
    SIGNATURE_PACKET    = 0x02,
    PUBLIC_KEY_PACKET   = 0x06,
    USER_ID_PACKET      = 0x0d
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4024,129285,anonymous_enum_1,4,anonymous_enum_1,,misc\update.h,"enum    /* Signature types */
{
    BINARY_SIGNATURE        = 0x00,
    TEXT_SIGNATURE          = 0x01,

    /* Public keys signatures */
    GENERIC_KEY_SIGNATURE   = 0x10, /* No assumption of verification */
    PERSONA_KEY_SIGNATURE   = 0x11, /* No verification has been made */
    CASUAL_KEY_SIGNATURE    = 0x12, /* Some casual verification */
    POSITIVE_KEY_SIGNATURE  = 0x13  /* Substantial verification */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4025,129314,anonymous_enum_2,4,anonymous_enum_2,,misc\update.h,"enum    /* Signature subpacket types */
{
    ISSUER_SUBPACKET    = 0x10
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4026,129323,public_key_packet_t,4,public_key_packet_t,,misc\update.h,"struct public_key_packet_t
{

    uint8_t version;      /* we use only version 4 */
    uint8_t timestamp[4]; /* creation time of the key */
    uint8_t algo;         /* DSA or RSA */

    /* the multi precision integers, with their 2 bytes length header */
    union {
        struct {
            uint8_t p[2+3072/8];
            uint8_t q[2+256/8];
            uint8_t g[2+3072/8];
            uint8_t y[2+3072/8];
        } dsa ;
        struct {
            uint8_t n[2+4096/8];
            uint8_t e[2+4096/8];
        } rsa;
    } sig;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4027,129327,public_key_packet_t.sig,4,public_key_packet_t.sig,,misc\update.h,"union {
        struct {
            uint8_t p[2+3072/8];
            uint8_t q[2+256/8];
            uint8_t g[2+3072/8];
            uint8_t y[2+3072/8];
        } dsa ;
        struct {
            uint8_t n[2+4096/8];
            uint8_t e[2+4096/8];
        } rsa;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4028,129328,public_key_packet_t.sig.dsa,4,public_key_packet_t.sig.dsa,,misc\update.h,"struct {
            uint8_t p[2+3072/8];
            uint8_t q[2+256/8];
            uint8_t g[2+3072/8];
            uint8_t y[2+3072/8];
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4029,129362,public_key_packet_t.sig.rsa,4,public_key_packet_t.sig.rsa,,misc\update.h,"struct {
            uint8_t n[2+4096/8];
            uint8_t e[2+4096/8];
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4030,129389,signature_packet_t,4,signature_packet_t,,misc\update.h,"struct signature_packet_t
{
    uint8_t version; /* 3 or 4 */

    uint8_t type;
    uint8_t public_key_algo;    /* DSA or RSA */
    uint8_t digest_algo;

    uint8_t hash_verification[2];
    uint8_t issuer_longid[8];

    union   /* version specific data */
    {
        struct
        {
            uint8_t hashed_data_len[2];     /* scalar number */
            uint8_t *hashed_data;           /* hashed_data_len bytes */
            uint8_t unhashed_data_len[2];   /* scalar number */
            uint8_t *unhashed_data;         /* unhashed_data_len bytes */
        } v4;
        struct
        {
            uint8_t hashed_data_len;    /* MUST be 5 */
            uint8_t timestamp[4];       /* 4 bytes scalar number */
        } v3;
    } specific;

/* The part below is made of consecutive MPIs, their number and size being
 * public-key-algorithm dependent.
 */
    union {
        struct {
            uint8_t r[2+256/8];
            uint8_t s[2+256/8];
        } dsa;
        struct ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4031,129396,signature_packet_t.specific,4,signature_packet_t.specific,,misc\update.h,"union   /* version specific data */
    {
        struct
        {
            uint8_t hashed_data_len[2];     /* scalar number */
            uint8_t *hashed_data;           /* hashed_data_len bytes */
            uint8_t unhashed_data_len[2];   /* scalar number */
            uint8_t *unhashed_data;         /* unhashed_data_len bytes */
        } v4;
        struct
        {
            uint8_t hashed_data_len;    /* MUST be 5 */
            uint8_t timestamp[4];       /* 4 bytes scalar number */
        } v3;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4032,129397,signature_packet_t.specific.v4,4,signature_packet_t.specific.v4,,misc\update.h,"struct
        {
            uint8_t hashed_data_len[2];     /* scalar number */
            uint8_t *hashed_data;           /* hashed_data_len bytes */
            uint8_t unhashed_data_len[2];   /* scalar number */
            uint8_t *unhashed_data;         /* unhashed_data_len bytes */
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4033,129411,signature_packet_t.specific.v3,4,signature_packet_t.specific.v3,,misc\update.h,"struct
        {
            uint8_t hashed_data_len;    /* MUST be 5 */
            uint8_t timestamp[4];       /* 4 bytes scalar number */
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4034,129422,signature_packet_t.algo_specific,4,signature_packet_t.algo_specific,,misc\update.h,"union {
        struct {
            uint8_t r[2+256/8];
            uint8_t s[2+256/8];
        } dsa;
        struct {
            uint8_t s[2+4096/8];
        } rsa;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4035,129423,signature_packet_t.algo_specific.dsa,4,signature_packet_t.algo_specific.dsa,,misc\update.h,"struct {
            uint8_t r[2+256/8];
            uint8_t s[2+256/8];
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4036,129443,signature_packet_t.algo_specific.rsa,4,signature_packet_t.algo_specific.rsa,,misc\update.h,"struct {
            uint8_t s[2+4096/8];
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4037,129465,public_key_packet_t,4,public_key_packet_t,,misc\update.h,typedef struct public_key_packet_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4038,129466,public_key_packet_t,4,public_key_packet_t,,misc\update.h,typedef struct public_key_packet_t public_key_packet_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4039,129467,signature_packet_t,4,signature_packet_t,,misc\update.h,typedef struct signature_packet_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4040,129468,signature_packet_t,4,signature_packet_t,,misc\update.h,typedef struct signature_packet_t signature_packet_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4041,129469,public_key_t,4,public_key_t,,misc\update.h,"struct public_key_t
{
    uint8_t longid[8];       /* Long id */
    uint8_t *psz_username;    /* USER ID */

    public_key_packet_t key;       /* Public key packet */

    signature_packet_t sig;     /* Signature packet, by the embedded key */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4042,129480,public_key_t,4,public_key_t,,misc\update.h,typedef struct public_key_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4043,129481,public_key_t,4,public_key_t,,misc\update.h,typedef struct public_key_t public_key_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4044,129482,update_download_thread_t,4,update_download_thread_t,,misc\update.h,"typedef struct
{
    VLC_COMMON_MEMBERS

    vlc_thread_t thread;
    atomic_bool aborted;
    update_t *p_update;
    char *psz_destdir;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4045,129483,VLC_COMMON_MEMBERS,4,VLC_COMMON_MEMBERS,,misc\update.h,VLC_COMMON_MEMBERS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4046,129490,update_check_thread_t,4,update_check_thread_t,,misc\update.h,"typedef struct
{
    vlc_thread_t thread;

    update_t *p_update;
    void (*pf_callback)( void *, bool );
    void *p_data;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4047,129501,update_t,4,update_t,,misc\update.h,"struct update_t
{
    libvlc_int_t *p_libvlc;
    vlc_mutex_t lock;
    struct update_release_t release;    ///< Release (version)
    public_key_t *p_pkey;
    update_download_thread_t *p_download;
    update_check_thread_t *p_check;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4048,129504,update_release_t,4,update_t.update_release_t,,misc\update.h,struct update_release_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4049,133438,callback_entry_t,4,callback_entry_t,,misc\variables.c,"typedef struct callback_entry_t
{
    union
    {
        vlc_callback_t       pf_value_callback;
        vlc_list_callback_t  pf_list_callback;
        void *               p_callback;
    };
    void *         p_data;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4050,133439,callback_entry_t.anonymous_composite_type_0,4,callback_entry_t.anonymous_composite_type_0,,misc\variables.c,"union
    {
        vlc_callback_t       pf_value_callback;
        vlc_list_callback_t  pf_list_callback;
        void *               p_callback;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4051,133444,callback_entry_t,4,callback_entry_t,,misc\variables.c,"typedef struct callback_entry_t
{
    union
    {
        vlc_callback_t       pf_value_callback;
        vlc_list_callback_t  pf_list_callback;
        void *               p_callback;
    };
    void *         p_data;
} callback_entry_t;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4052,133445,variable_ops_t,4,variable_ops_t,,misc\variables.c,"typedef struct variable_ops_t
{
    int  (*pf_cmp) ( vlc_value_t, vlc_value_t );
    void (*pf_dup) ( vlc_value_t * );
    void (*pf_free) ( vlc_value_t * );
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4053,133462,variable_ops_t,4,variable_ops_t,,misc\variables.c,"typedef struct variable_ops_t
{
    int  (*pf_cmp) ( vlc_value_t, vlc_value_t );
    void (*pf_dup) ( vlc_value_t * );
    void (*pf_free) ( vlc_value_t * );
} variable_ops_t;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4054,133463,callback_table_t,4,callback_table_t,,misc\variables.c,"typedef struct callback_table_t
{
    int                i_entries;
    callback_entry_t * p_entries;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4055,133466,callback_table_t,4,callback_table_t,,misc\variables.c,"typedef struct callback_table_t
{
    int                i_entries;
    callback_entry_t * p_entries;
} callback_table_t;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4056,133467,variable_t,4,variable_t,,misc\variables.c,"struct variable_t
{
    char *       psz_name; /**< The variable unique name (must be first) */

    /** The variable's exported value */
    vlc_value_t  val;

    /** The variable display name, mainly for use by the interfaces */
    char *       psz_text;

    const variable_ops_t *ops;

    int          i_type;   /**< The type of the variable */
    unsigned     i_usage;  /**< Reference count */

    /** If the variable has min/max/step values */
    vlc_value_t  min, max, step;

    /** List of choices */
    vlc_list_t   choices;
    /** List of friendly names for the choices */
    vlc_list_t   choices_text;

    /** Set to TRUE if the variable is in a callback */
    bool   b_incallback;

    /** Registered value callbacks */
    callback_table_t    value_callbacks;
    /** Registered list callbacks */
    callback_table_t    list_callbacks;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4057,133667,variable_ops_t,4,variable_ops_t,,misc\variables.c,static const struct variable_ops_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4058,135989,vlc_callback_type_t,4,vlc_callback_type_t,,misc\variables.c,"typedef enum
{
    vlc_value_callback,
    vlc_list_callback
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4059,137399,vlc_res,4,vlc_res,,misc\variables.h,struct vlc_res,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4060,137400,vlc_object_internals,4,vlc_object_internals,,misc\variables.h,typedef struct vlc_object_internals,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4061,137401,vlc_object_internals_t,4,vlc_object_internals_t,,misc\variables.h,typedef struct vlc_object_internals vlc_object_internals_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4062,137402,vlc_object_internals,4,vlc_object_internals,,misc\variables.h,"struct vlc_object_internals
{
    alignas (max_align_t) /* ensure vlc_externals() is maximally aligned */
    char           *psz_name; /* given name */

    /* Object variables */
    void           *var_root;
    vlc_mutex_t     var_lock;
    vlc_cond_t      var_wait;

    /* Objects management */
    atomic_uint     refs;
    vlc_destructor_t pf_destructor;

    /* Objects tree structure */
    vlc_object_internals_t *next;  /* next sibling */
    vlc_object_internals_t *prev;  /* previous sibling */
    vlc_object_internals_t *first; /* first child */
    vlc_mutex_t tree_lock;

    /* Object resources */
    struct vlc_res *resources;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4063,137415,vlc_res,4,vlc_object_internals.vlc_res,,misc\variables.h,struct vlc_res,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4064,138113,vlc_modcap,4,vlc_modcap,,modules\bank.c,"typedef struct vlc_modcap
{
    char *name;
    module_t **modv;
    size_t modc;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4065,138117,vlc_modcap_t,4,vlc_modcap_t,,modules\bank.c,"typedef struct vlc_modcap
{
    char *name;
    module_t **modv;
    size_t modc;
} vlc_modcap_t;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4066,138225,modules,4,modules,,modules\bank.c,"static struct
{
    vlc_mutex_t lock;
    block_t *caches;
    void *caps_tree;
    unsigned usage;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4067,139951,vlc_plugin_symbol,4,vlc_plugin_symbol,,modules\entry.c,"struct vlc_plugin_symbol
{
    const char *name;
    void *addr;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4068,141176,module_handle_t,4,module_handle_t,,modules\modules.h,typedef void *module_handle_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4069,141177,vlc_plugin_t,4,vlc_plugin_t,,modules\modules.h,"typedef struct vlc_plugin_t
{
    struct vlc_plugin_t *next;
    module_t *module;
    unsigned modules_count;

    const char *textdomain; /**< gettext domain (or NULL) */

    /**
     * Variables set by the module to store its config options
     */
    struct
    {
        module_config_t *items; /**< Table of configuration parameters */
        size_t size; /**< Size of items table */
        size_t count; /**< Number of configuration items */
        size_t booleans; /**< Number of booleal config items */
    } conf;

#ifdef HAVE_DYNAMIC_PLUGINS
    atomic_bool loaded; /**< Whether the plug-in is mapped in memory */
    bool unloadable; /**< Whether the plug-in can be unloaded safely */
    module_handle_t handle; /**< Run-time linker handle (if loaded) */
    char *abspath; /**< Absolute path */

    char *path; /**< Relative path (within plug-in directory) */
    int64_t mtime; /**< Last modification time */
    uint64_t size; /**< File size */
#endif
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4070,141178,vlc_plugin_t,4,vlc_plugin_t.vlc_plugin_t,,modules\modules.h,struct vlc_plugin_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4071,141183,vlc_plugin_t.conf,4,vlc_plugin_t.conf,,modules\modules.h,"struct
    {
        module_config_t *items; /**< Table of configuration parameters */
        size_t size; /**< Size of items table */
        size_t count; /**< Number of configuration items */
        size_t booleans; /**< Number of booleal config items */
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4072,141196,vlc_plugin_t,4,vlc_plugin_t,,modules\modules.h,"typedef struct vlc_plugin_t
{
    struct vlc_plugin_t *next;
    module_t *module;
    unsigned modules_count;

    const char *textdomain; /**< gettext domain (or NULL) */

    /**
     * Variables set by the module to store its config options
     */
    struct
    {
        module_config_t *items; /**< Table of configuration parameters */
        size_t size; /**< Size of items table */
        size_t count; /**< Number of configuration items */
        size_t booleans; /**< Number of booleal config items */
    } conf;

#ifdef HAVE_DYNAMIC_PLUGINS
    atomic_bool loaded; /**< Whether the plug-in is mapped in memory */
    bool unloadable; /**< Whether the plug-in can be unloaded safely */
    module_handle_t handle; /**< Run-time linker handle (if loaded) */
    char *abspath; /**< Absolute path */

    char *path; /**< Relative path (within plug-in directory) */
    int64_t mtime; /**< Last modification time */
    uint64_t size; /**< File size */
#endif
} vlc_plugin_t;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4073,141197,vlc_plugin_t,4,vlc_plugin_t,,modules\modules.h,extern struct vlc_plugin_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4074,141211,module_t,4,module_t,,modules\modules.h,"struct module_t
{
    vlc_plugin_t *plugin; /**< Plug-in/library containing the module */
    module_t   *next;

    /** Shortcuts to the module */
    unsigned    i_shortcuts;
    const char **pp_shortcuts;

    /*
     * Variables set by the module to identify itself
     */
    const char *psz_shortname;                              /**< Module name */
    const char *psz_longname;                   /**< Module descriptive name */
    const char *psz_help;        /**< Long help string for ""special"" modules */

    const char *psz_capability;                              /**< Capability */
    int      i_score;                          /**< Score for the capability */

    /* Callbacks */
    const char *activate_name;
    const char *deactivate_name;
    void *pf_activate;
    void *pf_deactivate;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4075,142845,httpd_host_t,4,httpd_host_t,,network\httpd.c,"struct httpd_host_t
{
    VLC_COMMON_MEMBERS

    /* ref count */
    unsigned    i_ref;

    /* address/port and socket for listening at connections */
    int         *fds;
    unsigned     nfd;
    unsigned     port;

    vlc_thread_t thread;
    vlc_mutex_t lock;
    vlc_cond_t  wait;

    /* all registered url (becarefull that 2 httpd_url_t could point at the same url)
     * This will slow down the url research but make my live easier
     * All url will have their cb trigger, but only the first one can answer
     * */
    int         i_url;
    httpd_url_t **url;

    bool           b_no_timeout;
    int            i_client;
    httpd_client_t **client;
    unsigned timeout_sec;

    /* TLS data */
    vlc_tls_creds_t *p_tls;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4076,142846,VLC_COMMON_MEMBERS,4,VLC_COMMON_MEMBERS,,network\httpd.c,VLC_COMMON_MEMBERS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4077,142862,httpd_url_t,4,httpd_url_t,,network\httpd.c,"struct httpd_url_t
{
    httpd_host_t *host;

    vlc_mutex_t lock;

    char      *psz_url;
    char      *psz_user;
    char      *psz_password;

    struct
    {
        httpd_callback_t     cb;
        httpd_callback_sys_t *p_sys;
    } catch[HTTPD_MSG_MAX];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4078,142868,httpd_url_t.catch,4,httpd_url_t.catch,,network\httpd.c,"struct
    {
        httpd_callback_t     cb;
        httpd_callback_sys_t *p_sys;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4079,142878,anonymous_enum_0,4,anonymous_enum_0,,network\httpd.c,"enum
{
    HTTPD_CLIENT_RECEIVING,
    HTTPD_CLIENT_RECEIVE_DONE,

    HTTPD_CLIENT_SENDING,
    HTTPD_CLIENT_SEND_DONE,

    HTTPD_CLIENT_WAITING,

    HTTPD_CLIENT_DEAD,

    HTTPD_CLIENT_TLS_HS_IN,
    HTTPD_CLIENT_TLS_HS_OUT
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4080,142887,httpd_client_t,4,httpd_client_t,,network\httpd.c,"struct httpd_client_t
{
    httpd_url_t *url;
    vlc_tls_t   *sock;

    int     i_ref;

    bool    b_stream_mode;
    uint8_t i_state;

    mtime_t i_timeout_date;

    /* buffer for reading header */
    int     i_buffer_size;
    int     i_buffer;
    uint8_t *p_buffer;

    /*
     * If waiting for a keyframe, this is the position (in bytes) of the
     * last keyframe the stream saw before this client connected.
     * Otherwise, -1.
     */
    int64_t i_keyframe_wait_to_pass;

    /* */
    httpd_message_t query;  /* client -> httpd */
    httpd_message_t answer; /* httpd -> client */

}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4081,143076,httpd_file_t,4,httpd_file_t,,network\httpd.c,"struct httpd_file_t
{
    httpd_url_t *url;
    httpd_file_callback_t pf_fill;
    httpd_file_sys_t      *p_sys;
    char mime[1];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4082,143374,httpd_handler_t,4,httpd_handler_t,,network\httpd.c,"struct httpd_handler_t
{
    httpd_url_t *url;

    httpd_handler_callback_t pf_fill;
    void                    *p_sys;

}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4083,143781,httpd_redirect_t,4,httpd_redirect_t,,network\httpd.c,"struct httpd_redirect_t
{
    httpd_url_t *url;
    char         dst[1];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4084,143990,httpd_stream_t,4,httpd_stream_t,,network\httpd.c,"struct httpd_stream_t
{
    vlc_mutex_t lock;
    httpd_url_t *url;

    char    *psz_mime;

    /* Header to send as first packet */
    uint8_t *p_header;
    int     i_header;

    /* Some muxes, in particular the avformat mux, can mark given blocks
     * as keyframes, to ensure that the stream starts with one.
     * (This is particularly important for WebM streaming to certain
     * browsers.) Store if we've ever seen any such keyframe blocks,
     * and if so, the byte position of the start of the last one. */
    bool        b_has_keyframes;
    int64_t     i_last_keyframe_seen_pos;

    /* circular buffer */
    int         i_buffer_size;      /* buffer size, can't be reallocated smaller */
    uint8_t     *p_buffer;          /* buffer */
    int64_t     i_buffer_pos;       /* absolute position from beginning */
    int64_t     i_buffer_last_pos;  /* a new connection will start with that */

    /* custom headers */
    size_t        i_http_headers;
    httpd_header * p_ht...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4085,145005,httpd,4,httpd,,network\httpd.c,"static struct httpd
{
    vlc_mutex_t  mutex;

    httpd_host_t **host;
    int          i_host;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4086,146181,msg_type,4,msg_type,,network\httpd.c,"static const struct
{
    const char name[16];
    int  i_type;
    int  i_proto;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4087,150215,sockaddr,4,sockaddr,,network\rootbind.c,struct sockaddr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4088,152590,vlc_tls_socket,4,vlc_tls_socket,,network\tls.c,"typedef struct vlc_tls_socket
{
    struct vlc_tls tls;
    int fd;
    socklen_t peerlen;
    struct sockaddr peer[];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4089,152591,vlc_tls,4,vlc_tls_socket.vlc_tls,,network\tls.c,struct vlc_tls,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4090,152595,sockaddr,4,vlc_tls_socket.sockaddr,,network\tls.c,struct sockaddr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4091,152602,vlc_tls_socket_t,4,vlc_tls_socket_t,,network\tls.c,"typedef struct vlc_tls_socket
{
    struct vlc_tls tls;
    int fd;
    socklen_t peerlen;
    struct sockaddr peer[];
} vlc_tls_socket_t;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4092,156619,vlc_thread,4,vlc_thread,,os2\thread.c,"struct vlc_thread
{
    TID            tid;
    HEV            cancel_event;
    HEV            done_event;
    int            cancel_sock;

    bool           detached;
    bool           killable;
    bool           killed;
    vlc_cleanup_t *cleaners;

    void        *(*entry) (void *);
    void          *data;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4093,157003,vlc_static_cond_t,4,vlc_static_cond_t,,os2\thread.c,typedef struct vlc_static_cond_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4094,157004,vlc_static_cond_t,4,vlc_static_cond_t,,os2\thread.c,typedef struct vlc_static_cond_t vlc_static_cond_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4095,157005,vlc_static_cond_t,4,vlc_static_cond_t,,os2\thread.c,"struct vlc_static_cond_t
{
    vlc_cond_t condvar;
    vlc_static_cond_t *next;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4096,157410,vlc_threadvar,4,vlc_threadvar,,os2\thread.c,"struct vlc_threadvar
{
    PULONG                id;
    void                (*destroy) (void *);
    struct vlc_threadvar *prev;
    struct vlc_threadvar *next;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4097,157417,vlc_threadvar,4,vlc_threadvar.vlc_threadvar,,os2\thread.c,struct vlc_threadvar,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4098,157419,vlc_threadvar,4,vlc_threadvar.vlc_threadvar,,os2\thread.c,struct vlc_threadvar,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4099,158660,vlc_timer,4,vlc_timer,,os2\thread.c,"struct vlc_timer
{
    TID    tid;
    HEV    hev;
    HTIMER htimer;
    ULONG  interval;
    bool   quit;
    void (*func) (void *);
    void  *data;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4100,161875,playlist_fetcher_t,4,playlist_fetcher_t,,playlist\fetcher.c,"struct playlist_fetcher_t {
    struct background_worker* local;
    struct background_worker* network;
    struct background_worker* downloader;

    vlc_dictionary_t album_cache;
    vlc_object_t* owner;
    vlc_mutex_t lock;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4101,161876,background_worker,4,playlist_fetcher_t.background_worker,,playlist\fetcher.c,struct background_worker,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4102,161878,background_worker,4,playlist_fetcher_t.background_worker,,playlist\fetcher.c,struct background_worker,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4103,161880,background_worker,4,playlist_fetcher_t.background_worker,,playlist\fetcher.c,struct background_worker,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4104,161885,fetcher_request,4,fetcher_request,,playlist\fetcher.c,"struct fetcher_request {
    input_item_t* item;
    atomic_uint refs;
    int preparse_status;
    int options;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4105,161890,fetcher_thread,4,fetcher_thread,,playlist\fetcher.c,"struct fetcher_thread {
    void (*pf_worker)( playlist_fetcher_t*, struct fetcher_request* );

    struct background_worker* worker;
    struct fetcher_request* req;
    playlist_fetcher_t* fetcher;

    vlc_interrupt_t interrupt;
    vlc_thread_t thread;
    atomic_bool active;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4106,161897,background_worker,4,fetcher_thread.background_worker,,playlist\fetcher.c,struct background_worker,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4107,161899,fetcher_request,4,fetcher_thread.fetcher_request,,playlist\fetcher.c,struct fetcher_request,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4108,163072,playlist_fetcher_t,4,playlist_fetcher_t,,playlist\fetcher.h,typedef struct playlist_fetcher_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4109,163073,playlist_fetcher_t,4,playlist_fetcher_t,,playlist\fetcher.h,typedef struct playlist_fetcher_t playlist_fetcher_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4110,165492,vlc_sd_internal_t,4,vlc_sd_internal_t,,playlist\playlist_internal.h,typedef struct vlc_sd_internal_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4111,165493,vlc_sd_internal_t,4,vlc_sd_internal_t,,playlist\playlist_internal.h,typedef struct vlc_sd_internal_t vlc_sd_internal_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4112,165499,playlist_private_t,4,playlist_private_t,,playlist\playlist_internal.h,"typedef struct playlist_private_t
{
    playlist_t           public_data;
    struct intf_thread_t *interface; /**< Linked-list of interfaces */

    void *input_tree; /**< Search tree for input item
                           to playlist item mapping */
    void *id_tree; /**< Search tree for item ID to item mapping */

    vlc_sd_internal_t   **pp_sds;
    int                   i_sds;   /**< Number of service discovery modules */
    input_thread_t *      p_input;  /**< the input thread associated
                                     * with the current item */
    input_resource_t *   p_input_resource; /**< input resources */
    vlc_renderer_item_t *p_renderer;
    struct {
        /* Current status. These fields are readonly, only the playlist
         * main loop can touch it*/
        playlist_item_t *   p_item; /**< Currently playing/active item */
        playlist_item_t *   p_node; /**< Current node to play from */
    } status;

    struct {
        /* Request. Use this to...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4113,165501,intf_thread_t,4,playlist_private_t.intf_thread_t,,playlist\playlist_internal.h,struct intf_thread_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4114,165510,playlist_private_t.status,4,playlist_private_t.status,,playlist\playlist_internal.h,"struct {
        /* Current status. These fields are readonly, only the playlist
         * main loop can touch it*/
        playlist_item_t *   p_item; /**< Currently playing/active item */
        playlist_item_t *   p_node; /**< Current node to play from */
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4115,165514,playlist_private_t.request,4,playlist_private_t.request,,playlist\playlist_internal.h,"struct {
        /* Request. Use this to give orders to the playlist main loop  */
        playlist_item_t *   p_node;   /**< requested node to play from */
        playlist_item_t *   p_item;   /**< requested item to play in the node */

        int                 i_skip;   /**< Number of items to skip */

        bool          b_request;/**< Set to true by the requester
                                           The playlist sets it back to false
                                           when processing the request */
        bool input_dead; /**< Set when input has finished. */
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4116,165531,playlist_private_t,4,playlist_private_t,,playlist\playlist_internal.h,"typedef struct playlist_private_t
{
    playlist_t           public_data;
    struct intf_thread_t *interface; /**< Linked-list of interfaces */

    void *input_tree; /**< Search tree for input item
                           to playlist item mapping */
    void *id_tree; /**< Search tree for item ID to item mapping */

    vlc_sd_internal_t   **pp_sds;
    int                   i_sds;   /**< Number of service discovery modules */
    input_thread_t *      p_input;  /**< the input thread associated
                                     * with the current item */
    input_resource_t *   p_input_resource; /**< input resources */
    vlc_renderer_item_t *p_renderer;
    struct {
        /* Current status. These fields are readonly, only the playlist
         * main loop can touch it*/
        playlist_item_t *   p_item; /**< Currently playing/active item */
        playlist_item_t *   p_node; /**< Current node to play from */
    } status;

    struct {
        /* Request. Use this to...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4117,165685,playlist_preparser_t,4,playlist_preparser_t,,playlist\preparser.c,"struct playlist_preparser_t
{
    vlc_object_t* owner;
    playlist_fetcher_t* fetcher;
    struct background_worker* worker;
    atomic_bool deactivated;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4118,165688,background_worker,4,playlist_preparser_t.background_worker,,playlist\preparser.c,struct background_worker,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4119,166133,playlist_preparser_t,4,playlist_preparser_t,,playlist\preparser.h,typedef struct playlist_preparser_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4120,166134,playlist_preparser_t,4,playlist_preparser_t,,playlist\preparser.h,typedef struct playlist_preparser_t playlist_preparser_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4121,166537,vlc_sd_internal_t,4,vlc_sd_internal_t,,playlist\services_discovery.c,"struct vlc_sd_internal_t
{
    /* the playlist items for category and onelevel */
    playlist_item_t      *node;
    services_discovery_t *sd; /**< Loaded service discovery modules */
    char name[];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4122,171616,vlc_gai_req,4,vlc_gai_req,,posix\getaddrinfo.c,"struct vlc_gai_req
{
    const char *name;
    const char *service;
    const struct addrinfo *hints;
    struct addrinfo *result;
    int error;
    vlc_sem_t done;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4123,171619,addrinfo,4,vlc_gai_req.addrinfo,,posix\getaddrinfo.c,const struct addrinfo,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4124,171621,addrinfo,4,vlc_gai_req.addrinfo,,posix\getaddrinfo.c,struct addrinfo,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4125,173495,vlc_timer,4,vlc_timer,,posix\timer.c,"struct vlc_timer
{
    vlc_thread_t thread;
    vlc_cond_t   reschedule;
    vlc_mutex_t  lock;
    void       (*func) (void *);
    void        *data;
    mtime_t      value, interval;
    atomic_uint  overruns;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4126,173886,session_descriptor_t,4,session_descriptor_t,,stream_output\sap.c,"struct session_descriptor_t
{
    struct session_descriptor_t *next;
    size_t length;
    char *data;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4127,173887,session_descriptor_t,4,session_descriptor_t.session_descriptor_t,,stream_output\sap.c,struct session_descriptor_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4128,173891,sap_address_t,4,sap_address_t,,stream_output\sap.c,"typedef struct sap_address_t
{
    struct sap_address_t   *next;

    vlc_thread_t            thread;
    vlc_mutex_t             lock;
    vlc_cond_t              wait;

    char                    group[NI_MAXNUMERICHOST];
    struct sockaddr_storage orig;
    socklen_t               origlen;
    int                     fd;
    unsigned                interval;

    unsigned                session_count;
    session_descriptor_t   *first;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4129,173892,sap_address_t,4,sap_address_t.sap_address_t,,stream_output\sap.c,struct sap_address_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4130,173898,sockaddr_storage,4,sap_address_t.sockaddr_storage,,stream_output\sap.c,struct sockaddr_storage,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4131,173911,sap_address_t,4,sap_address_t,,stream_output\sap.c,"typedef struct sap_address_t
{
    struct sap_address_t   *next;

    vlc_thread_t            thread;
    vlc_mutex_t             lock;
    vlc_cond_t              wait;

    char                    group[NI_MAXNUMERICHOST];
    struct sockaddr_storage orig;
    socklen_t               origlen;
    int                     fd;
    unsigned                interval;

    unsigned                session_count;
    session_descriptor_t   *first;
} sap_address_t;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4132,175277,mrl_t,4,mrl_t,,stream_output\stream_output.c,"typedef struct
{
    char *psz_access;
    char *psz_way;
    char *psz_name;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4133,177290,sout_packetizer_input_t,4,sout_packetizer_input_t,,stream_output\stream_output.h,"struct sout_packetizer_input_t
{
    sout_instance_t     *p_sout;

    sout_stream_id_sys_t    *id;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4134,179266,xml_entity_s,4,xml_entity_s,,text\strings.c,"static const struct xml_entity_s
{
    char    psz_entity[8];
    char    psz_char[4];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4135,184895,vout_chrono_t,4,vout_chrono_t,,video_output\chrono.h,"typedef struct {
    int     shift;
    mtime_t avg;
    mtime_t avg_initial;

    int     shift_var;
    mtime_t var;

    mtime_t start;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4136,185676,anonymous_enum_0,4,anonymous_enum_0,,video_output\control.h,"enum {
    VOUT_CONTROL_INIT,
    VOUT_CONTROL_CLEAN,
    VOUT_CONTROL_REINIT,                /* cfg */
    VOUT_CONTROL_CANCEL,

#if 0
    /* */
    VOUT_CONTROL_START,
    VOUT_CONTROL_STOP,
#endif
    VOUT_CONTROL_SUBPICTURE,            /* subpicture */
    VOUT_CONTROL_FLUSH_SUBPICTURE,      /* integer */
    VOUT_CONTROL_OSD_TITLE,             /* string */
    VOUT_CONTROL_CHANGE_FILTERS,        /* string */
    VOUT_CONTROL_CHANGE_INTERLACE,      /* boolean */
    VOUT_CONTROL_CHANGE_SUB_SOURCES,    /* string */
    VOUT_CONTROL_CHANGE_SUB_FILTERS,    /* string */
    VOUT_CONTROL_CHANGE_SUB_MARGIN,     /* integer */

    VOUT_CONTROL_PAUSE,
    VOUT_CONTROL_FLUSH,                 /* time */
    VOUT_CONTROL_STEP,                  /* time_ptr */

    VOUT_CONTROL_FULLSCREEN,            /* bool */
    VOUT_CONTROL_WINDOW_STATE,          /* unsigned */
    VOUT_CONTROL_WINDOW_MOUSE,          /* window_mouse */
    VOUT_CONTROL_DISPLAY_FILLED,        /* bool */
    VOUT_CONTROL_Z...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4137,185702,vout_control_cmd_t,4,vout_control_cmd_t,,video_output\control.h,"typedef struct {
    int type;

    union {
        bool    boolean;
        mtime_t time;
        mtime_t *time_ptr;
        char    *string;
        int     integer;
        struct {
            int a;
            int b;
        } pair;
        struct {
            bool is_on;
            mtime_t date;
        } pause;
        struct {
            int channel;
            char *string;
        } message;
        struct {
            unsigned left;
            unsigned top;
            unsigned right;
            unsigned bottom;
        } border;
        struct {
            unsigned x;
            unsigned y;
            unsigned width;
            unsigned height;
        } window;
        vout_window_mouse_event_t window_mouse;
        const vout_configuration_t *cfg;
        subpicture_t *subpicture;
        vlc_viewpoint_t viewpoint;
    } u;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4138,185704,vout_control_cmd_t.u,4,vout_control_cmd_t.u,,video_output\control.h,"union {
        bool    boolean;
        mtime_t time;
        mtime_t *time_ptr;
        char    *string;
        int     integer;
        struct {
            int a;
            int b;
        } pair;
        struct {
            bool is_on;
            mtime_t date;
        } pause;
        struct {
            int channel;
            char *string;
        } message;
        struct {
            unsigned left;
            unsigned top;
            unsigned right;
            unsigned bottom;
        } border;
        struct {
            unsigned x;
            unsigned y;
            unsigned width;
            unsigned height;
        } window;
        vout_window_mouse_event_t window_mouse;
        const vout_configuration_t *cfg;
        subpicture_t *subpicture;
        vlc_viewpoint_t viewpoint;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4139,185710,vout_control_cmd_t.u.pair,4,vout_control_cmd_t.u.pair,,video_output\control.h,"struct {
            int a;
            int b;
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4140,185714,vout_control_cmd_t.u.pause,4,vout_control_cmd_t.u.pause,,video_output\control.h,"struct {
            bool is_on;
            mtime_t date;
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4141,185718,vout_control_cmd_t.u.message,4,vout_control_cmd_t.u.message,,video_output\control.h,"struct {
            int channel;
            char *string;
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4142,185722,vout_control_cmd_t.u.border,4,vout_control_cmd_t.u.border,,video_output\control.h,"struct {
            unsigned left;
            unsigned top;
            unsigned right;
            unsigned bottom;
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4143,185728,vout_control_cmd_t.u.window,4,vout_control_cmd_t.u.window,,video_output\control.h,"struct {
            unsigned x;
            unsigned y;
            unsigned width;
            unsigned height;
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4144,185751,vout_control_t,4,vout_control_t,,video_output\control.h,"typedef struct {
    vlc_mutex_t lock;
    vlc_cond_t  wait_request;
    vlc_cond_t  wait_acknowledge;

    /* */
    bool is_dead;
    bool can_sleep;
    bool is_processing;
    DECL_ARRAY(vout_control_cmd_t) cmd;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4145,187045,vout_display_owner_sys_t,4,vout_display_owner_sys_t,,video_output\display.c,"typedef struct {
    vout_thread_t   *vout;
    bool            is_splitter;  /* Is this a video splitter */

    /* */
    vout_display_cfg_t cfg;
    vlc_rational_t sar_initial;

    /* */
    bool is_display_filled;

    bool ch_zoom;
    vlc_rational_t zoom;
#if defined(_WIN32) || defined(__OS2__)
    unsigned width_saved;
    unsigned height_saved;
    bool ch_fullscreen;
    bool is_fullscreen;
    bool window_fullscreen;
    bool ch_wm_state;
    unsigned wm_state;
    unsigned wm_state_initial;
#endif
    bool ch_sar;
    vlc_rational_t sar;

    bool ch_crop;
    struct {
        int      left;
        int      top;
        int      right;
        int      bottom;
        unsigned num;
        unsigned den;
    } crop;

    bool ch_viewpoint;
    vlc_viewpoint_t viewpoint;
    vlc_viewpoint_t display_viewpoint;

    /* */
    video_format_t source;
    filter_chain_t *filters;

    /* Lock protecting the variables used by
     * VoutDisplayEvent(ie vout_display_SendEvent) *...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4146,187064,vout_display_owner_sys_t.crop,4,vout_display_owner_sys_t.crop,,video_output\display.c,"struct {
        int      left;
        int      top;
        int      right;
        int      bottom;
        unsigned num;
        unsigned den;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4147,187078,vout_display_owner_sys_t.mouse,4,vout_display_owner_sys_t.mouse,,video_output\display.c,"struct {
        vlc_mouse_t state;

        mtime_t last_pressed;
        mtime_t last_moved;
        bool    is_hidden;
        bool    ch_activity;

        /* */
        mtime_t double_click_timeout;
        mtime_t hide_timeout;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4148,190139,vout_display_sys_t,4,vout_display_sys_t,,video_output\display.c,"struct vout_display_sys_t {
    picture_pool_t   *pool;
    video_splitter_t *splitter;

    /* */
    int            count;
    picture_t      **picture;
    vout_display_t **display;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4149,190145,video_splitter_owner_t,4,video_splitter_owner_t,,video_output\display.c,"struct video_splitter_owner_t {
    vout_display_t *wrapper;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4150,191436,inhibit_t,4,inhibit_t,,video_output\inhibit.c,"typedef struct
{
    vlc_inhibit_t ih;
    module_t *module;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4151,192154,vlc_gl_priv_t,4,vlc_gl_priv_t,,video_output\opengl.c,"struct vlc_gl_priv_t
{
    vlc_gl_t gl;
    atomic_uint ref_count;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4152,192305,vlc_gl_surface,4,vlc_gl_surface,,video_output\opengl.c,"typedef struct vlc_gl_surface
{
    int width;
    int height;
    vlc_mutex_t lock;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4153,192309,vlc_gl_surface_t,4,vlc_gl_surface_t,,video_output\opengl.c,"typedef struct vlc_gl_surface
{
    int width;
    int height;
    vlc_mutex_t lock;
} vlc_gl_surface_t;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4154,193127,vout_snapshot_t,4,vout_snapshot_t,,video_output\snapshot.h,"typedef struct {
    vlc_mutex_t lock;
    vlc_cond_t  wait;

    bool        is_available;
    int         request_count;
    picture_t   *picture;

}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4155,193172,vout_snapshot_save_cfg_t,4,vout_snapshot_save_cfg_t,,video_output\snapshot.h,"typedef struct {
    bool is_sequential;
    int  sequence;
    char *path;
    char *format;
    char *prefix_fmt;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4156,193195,vout_statistic_t,4,vout_statistic_t,,video_output\statistic.h,"typedef struct {
    atomic_uint displayed;
    atomic_uint lost;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4157,193298,subpicture_updater_sys_t,4,subpicture_updater_sys_t,,video_output\video_epg.c,"struct subpicture_updater_sys_t
{
    vlc_epg_t *epg;
    int64_t    time;
    char      *art;
    vlc_object_t *obj;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4158,197865,vout_filter_t,4,vout_filter_t,,video_output\video_output.c,"typedef struct {
    char           *name;
    config_chain_t *cfg;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4159,202018,subpicture_updater_sys_t,4,subpicture_updater_sys_t,,video_output\video_text.c,"struct subpicture_updater_sys_t {
    int  position;
    char *text;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4160,203776,subpicture_updater_sys_t,4,subpicture_updater_sys_t,,video_output\video_widgets.c,"struct subpicture_updater_sys_t {
    int type;
    int position;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4161,204102,vout_window_mouse_event_t,4,vout_window_mouse_event_t,,video_output\vout_control.h,typedef struct vout_window_mouse_event_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4162,204103,vout_window_mouse_event_t,4,vout_window_mouse_event_t,,video_output\vout_control.h,typedef struct vout_window_mouse_event_t vout_window_mouse_event_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4163,204182,vout_thread_sys_t,4,vout_thread_sys_t,,video_output\vout_internal.h,"struct vout_thread_sys_t
{
    /* Splitter module if used */
    char            *splitter_name;

    /* Input thread for dvd menu interactions */
    vlc_object_t    *input;

    /* */
    video_format_t  original;   /* Original format ie coming from the decoder */
    unsigned        dpb_size;

    /* Snapshot interface */
    vout_snapshot_t snapshot;

    /* Statistics */
    vout_statistic_t statistic;

    /* Subpicture unit */
    vlc_mutex_t     spu_lock;
    spu_t           *spu;
    vlc_fourcc_t    spu_blend_chroma;
    filter_t        *spu_blend;

    /* Video output window */
    vout_window_t   *window;

    /* Thread & synchronization */
    vlc_thread_t    thread;
    bool            dead;
    vout_control_t  control;

    /* */
    struct {
        char           *title;
        vout_display_t *vd;
        bool           use_dr;
    } display;

    struct {
        mtime_t     date;
        mtime_t     timestamp;
        bool        is_interlaced;
        picture_t  ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4164,204197,vout_thread_sys_t.display,4,vout_thread_sys_t.display,,video_output\vout_internal.h,"struct {
        char           *title;
        vout_display_t *vd;
        bool           use_dr;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4165,204202,vout_thread_sys_t.displayed,4,vout_thread_sys_t.displayed,,video_output\vout_internal.h,"struct {
        mtime_t     date;
        mtime_t     timestamp;
        bool        is_interlaced;
        picture_t   *decoded;
        picture_t   *current;
        picture_t   *next;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4166,204210,vout_thread_sys_t.step,4,vout_thread_sys_t.step,,video_output\vout_internal.h,"struct {
        mtime_t     last;
        mtime_t     timestamp;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4167,204214,vout_thread_sys_t.pause,4,vout_thread_sys_t.pause,,video_output\vout_internal.h,"struct {
        bool        is_on;
        mtime_t     date;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4168,204218,vout_thread_sys_t.title,4,vout_thread_sys_t.title,,video_output\vout_internal.h,"struct {
        bool        show;
        mtime_t     timeout;
        int         position;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4169,204223,vout_thread_sys_t.interlacing,4,vout_thread_sys_t.interlacing,,video_output\vout_internal.h,"struct {
        bool        is_interlaced;
        mtime_t     date;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4170,204228,vout_thread_sys_t.filter,4,vout_thread_sys_t.filter,,video_output\vout_internal.h,"struct {
        vlc_mutex_t     lock;
        char            *configuration;
        video_format_t  format;
        struct filter_chain_t *chain_static;
        struct filter_chain_t *chain_interactive;
        bool            has_deint;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4171,204232,filter_chain_t,4,vout_thread_sys_t.filter.filter_chain_t,,video_output\vout_internal.h,struct filter_chain_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4172,204234,filter_chain_t,4,vout_thread_sys_t.filter.filter_chain_t,,video_output\vout_internal.h,struct filter_chain_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4173,204544,p_zoom_values,4,p_zoom_values,,video_output\vout_intf.c,"static const struct
{
    double f_value;
    char psz_label[13];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4174,204573,p_crop_values,4,p_crop_values,,video_output\vout_intf.c,"static const struct
{
    char psz_value[8];
    char psz_label[8];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4175,204622,p_aspect_ratio_values,4,p_aspect_ratio_values,,video_output\vout_intf.c,"static const struct
{
    char psz_value[8];
    char psz_label[8];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4176,206448,spu_heap_entry_t,4,spu_heap_entry_t,,video_output\vout_subpictures.c,"typedef struct {
    subpicture_t *subpicture;
    bool          reject;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4177,206452,spu_heap_t,4,spu_heap_t,,video_output\vout_subpictures.c,"typedef struct {
    spu_heap_entry_t entry[VOUT_MAX_SUBPICTURES];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4178,206467,spu_private_t,4,spu_private_t,,video_output\vout_subpictures.c,"struct spu_private_t {
    vlc_mutex_t  lock;            /* lock to protect all followings fields */
    vlc_object_t *input;

    spu_heap_t   heap;

    int channel;             /**< number of subpicture channels registered */
    filter_t *text;                              /**< text renderer module */
    filter_t *scale_yuvp;                     /**< scaling module for YUVP */
    filter_t *scale;                    /**< scaling module (all but YUVP) */
    bool force_crop;                     /**< force cropping of subpicture */
    struct {
        int x;
        int y;
        int width;
        int height;
    } crop;                                                  /**< cropping */

    int     margin;                    /**< force position of a subpicture */
    bool    force_palette;                /**< force palette of subpicture */
    uint8_t palette[4][4];                             /**< forced palette */

    /* Subpiture filters */
    char           *source_chain...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4179,206476,spu_private_t.crop,4,spu_private_t.crop,,video_output\vout_subpictures.c,"struct {
        int x;
        int y;
        int width;
        int height;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4180,207104,spu_scale_t,4,spu_scale_t,,video_output\vout_subpictures.c,"typedef struct {
    int w;
    int h;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4181,207257,spu_area_t,4,spu_area_t,,video_output\vout_subpictures.c,"typedef struct {
    int x;
    int y;
    int width;
    int height;

    spu_scale_t scale;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4182,212442,window_t,4,window_t,,video_output\window.c,"typedef struct
{
    vout_window_t wnd;
    module_t *module;
    vlc_inhibit_t *inhibit;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4183,212698,vout_display_window,4,vout_display_window,,video_output\window.c,"typedef struct vout_display_window
{
    vout_display_t *vd;
    unsigned width;
    unsigned height;

    vlc_mutex_t lock;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4184,212703,vout_display_window_t,4,vout_display_window_t,,video_output\window.c,"typedef struct vout_display_window
{
    vout_display_t *vd;
    unsigned width;
    unsigned height;

    vlc_mutex_t lock;
} vout_display_window_t;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4185,213280,wsaerrmsg_t,4,wsaerrmsg_t,,win32\error.c,"typedef struct
{
    int code;
    const char *msg;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4186,214511,vlc_mta_holder,4,vlc_mta_holder,,win32\mta_holder.h,"typedef struct vlc_mta_holder
{
    vlc_thread_t thread;
    int          i_refcount;
    vlc_sem_t    ready_sem;
    vlc_sem_t    release_sem;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4187,214516,vlc_mta_holder,4,vlc_mta_holder,,win32\mta_holder.h,"typedef struct vlc_mta_holder
{
    vlc_thread_t thread;
    int          i_refcount;
    vlc_sem_t    ready_sem;
    vlc_sem_t    release_sem;
} vlc_mta_holder;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4188,215154,vlc_ipc_data_t,4,vlc_ipc_data_t,,win32\specific.c,"typedef struct
{
    int argc;
    int enqueue;
    char data[];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4189,215392,vlc_thread,4,vlc_thread,,win32\thread.c,"struct vlc_thread
{
    HANDLE         id;

    bool           killable;
    atomic_bool    killed;
    vlc_cleanup_t *cleaners;

    void        *(*entry) (void *);
    void          *data;

    struct
    {
        atomic_int      *addr;
        CRITICAL_SECTION lock;
    } wait;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4190,215403,vlc_thread.wait,4,vlc_thread.wait,,win32\thread.c,"struct
    {
        atomic_int      *addr;
        CRITICAL_SECTION lock;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4191,215584,vlc_threadvar,4,vlc_threadvar,,win32\thread.c,"struct vlc_threadvar
{
    DWORD                 id;
    void                (*destroy) (void *);
    struct vlc_threadvar *prev;
    struct vlc_threadvar *next;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4192,215591,vlc_threadvar,4,vlc_threadvar.vlc_threadvar,,win32\thread.c,struct vlc_threadvar,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4193,215593,vlc_threadvar,4,vlc_threadvar.vlc_threadvar,,win32\thread.c,struct vlc_threadvar,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4194,216524,clk,4,clk,,win32\thread.c,"static union
{
#if (_WIN32_WINNT < _WIN32_WINNT_WIN7)
    struct
    {
        BOOL (*query) (PULONGLONG);
    } interrupt;
#endif
#if (_WIN32_WINNT < _WIN32_WINNT_VISTA)
    struct
    {
        ULONGLONG (*get) (void);
    } tick;
#endif
    struct
    {
        LARGE_INTEGER freq;
    } perf;
#if !VLC_WINSTORE_APP
    struct
    {
        MMRESULT (WINAPI *timeGetDevCaps)(LPTIMECAPS ptc,UINT cbtc);
        DWORD (WINAPI *timeGetTime)(void);
    } multimedia;
#endif
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4195,216525,clk.interrupt,4,clk.interrupt,,win32\thread.c,"struct
    {
        BOOL (*query) (PULONGLONG);
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4196,216532,clk.tick,4,clk.tick,,win32\thread.c,"struct
    {
        ULONGLONG (*get) (void);
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4197,216539,clk.perf,4,clk.perf,,win32\thread.c,"struct
    {
        LARGE_INTEGER freq;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4198,216542,clk.multimedia,4,clk.multimedia,,win32\thread.c,"struct
    {
        MMRESULT (WINAPI *timeGetDevCaps)(LPTIMECAPS ptc,UINT cbtc);
        DWORD (WINAPI *timeGetTime)(void);
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4199,217279,vlc_timer,4,vlc_timer,,win32\timer.c,"struct vlc_timer
{
    HANDLE handle;
    void (*func) (void *);
    void *data;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4200,100735,p_I420_fallback,2,misc\fourcc.c.p_I420_fallback,,misc\fourcc.c,ANY p_I420_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4201,100759,p_J420_fallback,2,misc\fourcc.c.p_J420_fallback,,misc\fourcc.c,ANY p_J420_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4202,100783,p_YV12_fallback,2,misc\fourcc.c.p_YV12_fallback,,misc\fourcc.c,ANY p_YV12_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4203,100807,p_NV12_fallback,2,misc\fourcc.c.p_NV12_fallback,,misc\fourcc.c,ANY p_NV12_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4204,100831,p_I420_9L_fallback,2,misc\fourcc.c.p_I420_9L_fallback,,misc\fourcc.c,ANY p_I420_9L_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4205,100857,p_I420_9B_fallback,2,misc\fourcc.c.p_I420_9B_fallback,,misc\fourcc.c,ANY p_I420_9B_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4206,100883,p_I420_10L_fallback,2,misc\fourcc.c.p_I420_10L_fallback,,misc\fourcc.c,ANY p_I420_10L_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4207,100909,p_I420_10B_fallback,2,misc\fourcc.c.p_I420_10B_fallback,,misc\fourcc.c,ANY p_I420_10B_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4208,100935,p_I420_12L_fallback,2,misc\fourcc.c.p_I420_12L_fallback,,misc\fourcc.c,ANY p_I420_12L_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4209,100961,p_I420_12B_fallback,2,misc\fourcc.c.p_I420_12B_fallback,,misc\fourcc.c,ANY p_I420_12B_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4210,100987,p_I420_16L_fallback,2,misc\fourcc.c.p_I420_16L_fallback,,misc\fourcc.c,ANY p_I420_16L_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4211,101013,p_I420_16B_fallback,2,misc\fourcc.c.p_I420_16B_fallback,,misc\fourcc.c,ANY p_I420_16B_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4212,101039,p_P010_fallback,2,misc\fourcc.c.p_P010_fallback,,misc\fourcc.c,ANY p_P010_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4213,101064,p_I422_fallback,2,misc\fourcc.c.p_I422_fallback,,misc\fourcc.c,ANY p_I422_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4214,101088,p_J422_fallback,2,misc\fourcc.c.p_J422_fallback,,misc\fourcc.c,ANY p_J422_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4215,101112,p_I422_9L_fallback,2,misc\fourcc.c.p_I422_9L_fallback,,misc\fourcc.c,ANY p_I422_9L_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4216,101138,p_I422_9B_fallback,2,misc\fourcc.c.p_I422_9B_fallback,,misc\fourcc.c,ANY p_I422_9B_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4217,101164,p_I422_10L_fallback,2,misc\fourcc.c.p_I422_10L_fallback,,misc\fourcc.c,ANY p_I422_10L_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4218,101190,p_I422_10B_fallback,2,misc\fourcc.c.p_I422_10B_fallback,,misc\fourcc.c,ANY p_I422_10B_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4219,101216,p_I422_12L_fallback,2,misc\fourcc.c.p_I422_12L_fallback,,misc\fourcc.c,ANY p_I422_12L_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4220,101242,p_I422_12B_fallback,2,misc\fourcc.c.p_I422_12B_fallback,,misc\fourcc.c,ANY p_I422_12B_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4221,101268,p_I444_fallback,2,misc\fourcc.c.p_I444_fallback,,misc\fourcc.c,ANY p_I444_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4222,101292,p_J444_fallback,2,misc\fourcc.c.p_J444_fallback,,misc\fourcc.c,ANY p_J444_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4223,101316,p_I444_9L_fallback,2,misc\fourcc.c.p_I444_9L_fallback,,misc\fourcc.c,ANY p_I444_9L_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4224,101342,p_I444_9B_fallback,2,misc\fourcc.c.p_I444_9B_fallback,,misc\fourcc.c,ANY p_I444_9B_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4225,101368,p_I444_10L_fallback,2,misc\fourcc.c.p_I444_10L_fallback,,misc\fourcc.c,ANY p_I444_10L_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4226,101394,p_I444_10B_fallback,2,misc\fourcc.c.p_I444_10B_fallback,,misc\fourcc.c,ANY p_I444_10B_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4227,101420,p_I444_12L_fallback,2,misc\fourcc.c.p_I444_12L_fallback,,misc\fourcc.c,ANY p_I444_12L_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4228,101446,p_I444_12B_fallback,2,misc\fourcc.c.p_I444_12B_fallback,,misc\fourcc.c,ANY p_I444_12B_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4229,101472,p_I444_16L_fallback,2,misc\fourcc.c.p_I444_16L_fallback,,misc\fourcc.c,ANY p_I444_16L_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4230,101498,p_I444_16B_fallback,2,misc\fourcc.c.p_I444_16B_fallback,,misc\fourcc.c,ANY p_I444_16B_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4231,101524,p_CVPX_VIDEO_NV12_fallback,2,misc\fourcc.c.p_CVPX_VIDEO_NV12_fallback,,misc\fourcc.c,ANY p_CVPX_VIDEO_NV12_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4232,101532,p_CVPX_VIDEO_UYVY_fallback,2,misc\fourcc.c.p_CVPX_VIDEO_UYVY_fallback,,misc\fourcc.c,ANY p_CVPX_VIDEO_UYVY_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4233,101539,p_CVPX_VIDEO_I420_fallback,2,misc\fourcc.c.p_CVPX_VIDEO_I420_fallback,,misc\fourcc.c,ANY p_CVPX_VIDEO_I420_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4234,101546,p_CVPX_VIDEO_BGRA_fallback,2,misc\fourcc.c.p_CVPX_VIDEO_BGRA_fallback,,misc\fourcc.c,ANY p_CVPX_VIDEO_BGRA_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4235,101553,p_CVPX_VIDEO_P010_fallback,2,misc\fourcc.c.p_CVPX_VIDEO_P010_fallback,,misc\fourcc.c,ANY p_CVPX_VIDEO_P010_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4236,101561,p_VAAPI_420_fallback,2,misc\fourcc.c.p_VAAPI_420_fallback,,misc\fourcc.c,ANY p_VAAPI_420_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4237,101568,p_VAAPI_420_10BPP_fallback,2,misc\fourcc.c.p_VAAPI_420_10BPP_fallback,,misc\fourcc.c,ANY p_VAAPI_420_10BPP_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4238,101576,p_D3D9_OPAQUE_fallback,2,misc\fourcc.c.p_D3D9_OPAQUE_fallback,,misc\fourcc.c,ANY p_D3D9_OPAQUE_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4239,101583,p_D3D9_OPAQUE_10B_fallback,2,misc\fourcc.c.p_D3D9_OPAQUE_10B_fallback,,misc\fourcc.c,ANY p_D3D9_OPAQUE_10B_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4240,101591,p_D3D11_OPAQUE_fallback,2,misc\fourcc.c.p_D3D11_OPAQUE_fallback,,misc\fourcc.c,ANY p_D3D11_OPAQUE_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4241,101598,p_D3D11_OPAQUE_10B_fallback,2,misc\fourcc.c.p_D3D11_OPAQUE_10B_fallback,,misc\fourcc.c,ANY p_D3D11_OPAQUE_10B_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4242,101606,p_I440_fallback,2,misc\fourcc.c.p_I440_fallback,,misc\fourcc.c,ANY p_I440_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4243,101637,p_YUYV_fallback,2,misc\fourcc.c.p_YUYV_fallback,,misc\fourcc.c,ANY p_YUYV_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4244,101661,p_YVYU_fallback,2,misc\fourcc.c.p_YVYU_fallback,,misc\fourcc.c,ANY p_YVYU_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4245,101685,p_UYVY_fallback,2,misc\fourcc.c.p_UYVY_fallback,,misc\fourcc.c,ANY p_UYVY_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4246,101709,p_VYUY_fallback,2,misc\fourcc.c.p_VYUY_fallback,,misc\fourcc.c,ANY p_VYUY_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4247,101733,pp_YUV_fallback,2,misc\fourcc.c.pp_YUV_fallback,,misc\fourcc.c,ANY pp_YUV_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
4248,101784,p_list_YUV,2,misc\fourcc.c.p_list_YUV,,misc\fourcc.c,ANY p_list_YUV,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
4249,101879,p_RGB32_fallback,2,misc\fourcc.c.p_RGB32_fallback,,misc\fourcc.c,ANY p_RGB32_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
4250,101889,p_RGB24_fallback,2,misc\fourcc.c.p_RGB24_fallback,,misc\fourcc.c,ANY p_RGB24_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4251,101899,p_RGB16_fallback,2,misc\fourcc.c.p_RGB16_fallback,,misc\fourcc.c,ANY p_RGB16_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4252,101909,p_RGB15_fallback,2,misc\fourcc.c.p_RGB15_fallback,,misc\fourcc.c,ANY p_RGB15_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4253,101919,p_RGB8_fallback,2,misc\fourcc.c.p_RGB8_fallback,,misc\fourcc.c,ANY p_RGB8_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4254,101929,pp_RGB_fallback,2,misc\fourcc.c.pp_RGB_fallback,,misc\fourcc.c,ANY pp_RGB_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
4255,102122,p_list_chroma_description,2,misc\fourcc.c.p_list_chroma_description,,misc\fourcc.c,static const[] p_list_chroma_description,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
4256,104854,vlc_rational_t,2,misc\fourcc_gen.c.vlc_rational_t,,misc\fourcc_gen.c,struct vlc_rational_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4257,104865,staticentry_t,2,misc\fourcc_gen.c.staticentry_t,,misc\fourcc_gen.c,struct staticentry_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4258,105328,p_list_video,2,misc\fourcc_list.h.p_list_video,,misc\fourcc_list.h,ANY p_list_video,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4259,107460,p_list_audio,2,misc\fourcc_list.h.p_list_audio,,misc\fourcc_list.h,ANY p_list_audio,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4260,108095,p_list_spu,2,misc\fourcc_list.h.p_list_spu,,misc\fourcc_list.h,ANY p_list_spu,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4261,108744,VLC_USED,2,misc\httpcookies.c.VLC_USED,,misc\httpcookies.c,VLC_MALLOC VLC_USED,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4262,111184,ext_table,2,misc\image.c.ext_table,,misc\image.c,static const[] ext_table,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4263,111330,mime_table,2,misc\image.c.mime_table,,misc\image.c,static const[] mime_table,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
4264,113859,protocol_default_ports,2,misc\keystore.c.protocol_default_ports,,misc\keystore.c,static[] protocol_default_ports,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4265,118315,vlc_logger_early_t,2,misc\messages.c.vlc_logger_early_t,,misc\messages.c,struct vlc_logger_early_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4266,119019,ext_mime,2,misc\mime.c.ext_mime,,misc\mime.c,static const[] ext_mime,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
4267,120288,name_lock,2,misc\objects.c.name_lock,,misc\objects.c,vlc_mutex_t name_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
4268,123158,picture_priv_t,2,misc\picture.h.picture_priv_t,,misc\picture.h,struct picture_priv_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4269,124674,rand48,2,misc\rand.c.rand48,,misc\rand.c,struct rand48,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
4270,129489,update_download_thread_t,2,misc\update.h.update_download_thread_t,,misc\update.h,struct update_download_thread_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4271,129500,update_check_thread_t,2,misc\update.h.update_check_thread_t,,misc\update.h,struct update_check_thread_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4272,133668,void_ops,2,misc\variables.c.void_ops,,misc\variables.c,const struct variable_ops_t void_ops,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
4273,133669,addr_ops,2,misc\variables.c.addr_ops,,misc\variables.c,const struct variable_ops_t addr_ops,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
4274,133670,bool_ops,2,misc\variables.c.bool_ops,,misc\variables.c,const struct variable_ops_t bool_ops,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
4275,133671,float_ops,2,misc\variables.c.float_ops,,misc\variables.c,const struct variable_ops_t float_ops,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
4276,133672,int_ops,2,misc\variables.c.int_ops,,misc\variables.c,const struct variable_ops_t int_ops,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
4277,133673,string_ops,2,misc\variables.c.string_ops,,misc\variables.c,const struct variable_ops_t string_ops,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
4278,133674,coords_ops,2,misc\variables.c.coords_ops,,misc\variables.c,const struct variable_ops_t coords_ops,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
4279,135992,vlc_callback_type_t,2,misc\variables.c.vlc_callback_type_t,,misc\variables.c,enum vlc_callback_type_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4280,138230,modules,2,modules\bank.c.modules,,modules\bank.c,struct modules,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
4281,138238,vlc_plugins,2,modules\bank.c.vlc_plugins,,modules\bank.c,vlc_plugin_t* vlc_plugins,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
4282,138424,vlc_static_modules,2,modules\bank.c.vlc_static_modules,,modules\bank.c,"int(*[])(int(*)(void*,void*,int),void*) vlc_static_modules",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
4283,141198,vlc_plugins,2,modules\modules.h.vlc_plugins,,modules\modules.h,struct vlc_plugin_t* vlc_plugins,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4284,145009,httpd,2,network\httpd.c.httpd,,network\httpd.c,struct httpd httpd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
4285,146191,msg_type,2,network\httpd.c.msg_type,,network\httpd.c,static const[] msg_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4286,156121,_fmode_bin,2,os2\specific.c._fmode_bin,,os2\specific.c,extern int _fmode_bin,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4287,156122,hpipeIPC,2,os2\specific.c.hpipeIPC,,os2\specific.c,HPIPE hpipeIPC,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
4288,156126,tidIPCFirst,2,os2\specific.c.tidIPCFirst,,os2\specific.c,static int tidIPCFirst,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
4289,156131,tidIPCHelper,2,os2\specific.c.tidIPCHelper,,os2\specific.c,static int tidIPCHelper,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
4290,156618,thread_key,2,os2\thread.c.thread_key,,os2\thread.c,vlc_threadvar_t thread_key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
4291,156782,super_mutex,2,os2\thread.c.super_mutex,,os2\thread.c,vlc_mutex_t super_mutex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
4292,156783,super_variable,2,os2\thread.c.super_variable,,os2\thread.c,vlc_cond_t super_variable,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4293,156784,config_lock,2,os2\thread.c.config_lock,,os2\thread.c,vlc_rwlock_t config_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4294,157008,static_condvar_start,2,os2\thread.c.static_condvar_start,,os2\thread.c,vlc_static_cond_t* static_condvar_start,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
4295,157421,vlc_threadvar_last,2,os2\thread.c.vlc_threadvar_last,,os2\thread.c,struct vlc_threadvar* vlc_threadvar_last,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
4296,165642,VLC_USED,2,playlist\playlist_internal.h.VLC_USED,,playlist\playlist_internal.h,ANY VLC_USED,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4297,167458,sorting_fns,2,playlist\sort.c.sorting_fns,,playlist\sort.c,int  sorting_fns,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
4298,168018,sorting_fns,2,playlist\sort.c.sorting_fns,,playlist\sort.c,int  sorting_fns,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4299,171791,environ,2,posix\netconf.c.environ,,posix\netconf.c,extern char** environ,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4300,172111,okey,2,posix\rand.c.okey,,posix\rand.c,static uint8_t[64] okey,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
4301,172112,ikey,2,posix\rand.c.ikey,,posix\rand.c,static uint8_t[64] ikey,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
4302,173074,rt_priorities,2,posix\thread.c.rt_priorities,,posix\thread.c,bool rt_priorities,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4303,173078,rt_offset,2,posix\thread.c.rt_offset,,posix\thread.c,static int rt_offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4304,173912,sap_addrs,2,stream_output\sap.c.sap_addrs,,stream_output\sap.c,sap_address_t* sap_addrs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4305,173916,sap_mutex,2,stream_output\sap.c.sap_mutex,,stream_output\sap.c,vlc_mutex_t sap_mutex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4306,175281,mrl_t,2,stream_output\stream_output.c.mrl_t,,stream_output\stream_output.c,struct mrl_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4307,177823,p_languages,2,text\iso-639_def.h.p_languages,,text\iso-639_def.h,ANY p_languages,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4308,178849,unknown_language,2,text\iso_lang.c.unknown_language,,text\iso_lang.c,const iso639_lang_t unknown_language,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
4309,179277,xml_entities,2,text\strings.c.xml_entities,,text\strings.c,xml_entity_s[] xml_entities,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4310,182761,urihex,2,text\url.c.urihex,,text\url.c,char[] urihex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4311,184902,vout_chrono_t,2,video_output\chrono.h.vout_chrono_t,,video_output\chrono.h,struct vout_chrono_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4312,185739,vout_control_cmd_t,2,video_output\control.h.vout_control_cmd_t,,video_output\control.h,struct vout_control_cmd_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4313,185759,vout_control_t,2,video_output\control.h.vout_control_t,,video_output\control.h,struct vout_control_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4314,187092,vout_display_owner_sys_t,2,video_output\display.c.vout_display_owner_sys_t,,video_output\display.c,struct vout_display_owner_sys_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4315,191439,inhibit_t,2,video_output\inhibit.c.inhibit_t,,video_output\inhibit.c,struct inhibit_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4316,191553,deinterlace_modes,2,video_output\interlacing.c.deinterlace_modes,,video_output\interlacing.c,char[][9] deinterlace_modes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
4317,193133,vout_snapshot_t,2,video_output\snapshot.h.vout_snapshot_t,,video_output\snapshot.h,struct vout_snapshot_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4318,193178,vout_snapshot_save_cfg_t,2,video_output\snapshot.h.vout_snapshot_save_cfg_t,,video_output\snapshot.h,struct vout_snapshot_save_cfg_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4319,193198,vout_statistic_t,2,video_output\statistic.h.vout_statistic_t,,video_output\statistic.h,struct vout_statistic_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4320,197868,vout_filter_t,2,video_output\video_output.c.vout_filter_t,,video_output\video_output.c,struct vout_filter_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4321,204553,p_zoom_values,2,video_output\vout_intf.c.p_zoom_values,,video_output\vout_intf.c,static const[] p_zoom_values,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4322,204584,p_crop_values,2,video_output\vout_intf.c.p_crop_values,,video_output\vout_intf.c,static const[] p_crop_values,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4323,204633,p_aspect_ratio_values,2,video_output\vout_intf.c.p_aspect_ratio_values,,video_output\vout_intf.c,static const[] p_aspect_ratio_values,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4324,206451,spu_heap_entry_t,2,video_output\vout_subpictures.c.spu_heap_entry_t,,video_output\vout_subpictures.c,struct spu_heap_entry_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4325,206466,spu_heap_t,2,video_output\vout_subpictures.c.spu_heap_t,,video_output\vout_subpictures.c,struct spu_heap_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4326,207107,spu_scale_t,2,video_output\vout_subpictures.c.spu_scale_t,,video_output\vout_subpictures.c,struct spu_scale_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4327,207263,spu_area_t,2,video_output\vout_subpictures.c.spu_area_t,,video_output\vout_subpictures.c,struct spu_area_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4328,212446,window_t,2,video_output\window.c.window_t,,video_output\window.c,struct window_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4329,213283,wsaerrmsg_t,2,win32\error.c.wsaerrmsg_t,,win32\error.c,struct wsaerrmsg_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4330,213284,wsaerrmsg,2,win32\error.c.wsaerrmsg,,win32\error.c,static const wsaerrmsg_t[] wsaerrmsg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4331,214843,LoadLibraryFlags,2,win32\plugin.c.LoadLibraryFlags,,win32\plugin.c,DWORD LoadLibraryFlags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4332,215092,LoadLibraryFlags,2,win32\specific.c.LoadLibraryFlags,,win32\specific.c,DWORD LoadLibraryFlags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4333,215163,vlc_ipc_data_t,2,win32\specific.c.vlc_ipc_data_t,,win32\specific.c,struct vlc_ipc_data_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4334,215389,super_mutex,2,win32\thread.c.super_mutex,,win32\thread.c,CRITICAL_SECTION super_mutex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
4335,215390,super_variable,2,win32\thread.c.super_variable,,win32\thread.c,CONDITION_VARIABLE super_variable,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4336,215391,thread_key,2,win32\thread.c.thread_key,,win32\thread.c,DWORD thread_key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4337,215595,vlc_threadvar_last,2,win32\thread.c.vlc_threadvar_last,,win32\thread.c,struct vlc_threadvar* vlc_threadvar_last,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
4338,216558,clk,2,win32\thread.c.clk,,win32\thread.c,union clk,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
4339,217129,setup_lock,2,win32\thread.c.setup_lock,,win32\thread.c,CRITICAL_SECTION setup_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4340,217190,config_lock,2,win32\thread.c.config_lock,,win32\thread.c,vlc_rwlock_t config_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4341,56,s_jvm,2,android\specific.c.s_jvm,,android\specific.c,JavaVM* s_jvm,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
4342,60,ppsz_generic_names,2,android\specific.c.ppsz_generic_names,,android\specific.c,char*[] ppsz_generic_names,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
4343,76,fields,2,android\specific.c.fields,,android\specific.c,struct fields,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
4344,2168,aout_owner_t,2,audio_output\aout_internal.h.aout_owner_t,,audio_output\aout_internal.h,struct aout_owner_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4345,2172,aout_instance_t,2,audio_output\aout_internal.h.aout_instance_t,,audio_output\aout_internal.h,struct aout_instance_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4346,8306,unset_str,2,audio_output\output.c.unset_str,,audio_output\output.c,char[1] unset_str,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
4347,13506,config_lock,2,config\configuration.h.config_lock,,config\configuration.h,vlc_rwlock_t config_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4348,13507,config_dirty,2,config\configuration.h.config_dirty,,config\configuration.h,bool config_dirty,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4349,13538,config_lock,2,config\core.c.config_lock,,config\core.c,vlc_rwlock_t config_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
4350,13542,config_dirty,2,config\core.c.config_dirty,,config\core.c,bool config_dirty,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
4351,14614,config,2,config\core.c.config,,config\core.c,struct config,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
4352,17550,vlc_usage,2,config\help.c.vlc_usage,,config\help.c,char[] vlc_usage,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4353,20211,vlc_clock_conversion_factor,2,darwin\thread.c.vlc_clock_conversion_factor,,darwin\thread.c,mach_timebase_info_data_t vlc_clock_conversion_factor,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
4354,20226,vlc_clock_once,2,darwin\thread.c.vlc_clock_once,,darwin\thread.c,pthread_once_t vlc_clock_once,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4355,21358,ISO6937toUCS4,2,extras\libc.c.ISO6937toUCS4,,extras\libc.c,ANY ISO6937toUCS4,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
4356,21618,ISO6937_2toUCS4,2,extras\libc.c.ISO6937_2toUCS4,,extras\libc.c,ANY ISO6937_2toUCS4,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
4357,21878,to_ucs4_comb,2,extras\libc.c.to_ucs4_comb,,extras\libc.c,ANY to_ucs4_comb,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
4358,24099,average_t,2,input\clock.c.average_t,,input\clock.c,struct average_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4359,24136,clock_point_t,2,input\clock.c.clock_point_t,,input\clock.c,struct clock_point_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4360,33987,VLC_USED,2,input\decoder.h.VLC_USED,,input\decoder.h,ANY VLC_USED,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4361,34104,demux_mapping,2,input\demux.c.demux_mapping,,input\demux.c,const struct demux_mapping,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4362,35775,VLC_USED,2,input\demux.h.VLC_USED,,input\demux.h,ANY VLC_USED,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4363,36233,es_out_pgrm_t,2,input\es_out.c.es_out_pgrm_t,,input\es_out.c,struct es_out_pgrm_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
4364,36268,es_out_es_props_t,2,input\es_out.c.es_out_es_props_t,,input\es_out.c,struct es_out_es_props_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4365,37131,es_cat,2,input\es_out.c.es_cat,,input\es_out.c,static es_out_id_t[] es_cat,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
4366,46988,ts_cmd_add_t,2,input\es_out_timeshift.c.ts_cmd_add_t,,input\es_out_timeshift.c,struct ts_cmd_add_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4367,46991,ts_cmd_del_t,2,input\es_out_timeshift.c.ts_cmd_del_t,,input\es_out_timeshift.c,struct ts_cmd_del_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4368,46996,ts_cmd_send_t,2,input\es_out_timeshift.c.ts_cmd_send_t,,input\es_out_timeshift.c,struct ts_cmd_send_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4369,47043,ts_cmd_control_t,2,input\es_out_timeshift.c.ts_cmd_control_t,,input\es_out_timeshift.c,struct ts_cmd_control_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4370,47053,ts_cmd_t,2,input\es_out_timeshift.c.ts_cmd_t,,input\es_out_timeshift.c,struct ts_cmd_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4371,47085,ts_thread_t,2,input\es_out_timeshift.c.ts_thread_t,,input\es_out_timeshift.c,struct ts_thread_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4372,63213,VLC_USED,2,input\input_interface.h.VLC_USED,,input\input_interface.h,ANY VLC_USED,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4373,63235,input_statistic_t,2,input\input_interface.h.input_statistic_t,,input\input_interface.h,enum input_statistic_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4374,63285,input_source_t,2,input\input_internal.h.input_source_t,,input\input_internal.h,struct input_source_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4375,63289,input_control_t,2,input\input_internal.h.input_control_t,,input\input_internal.h,struct input_control_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4376,71145,vlc_sd_probe_t,2,input\services_discovery.c.vlc_sd_probe_t,,input\services_discovery.c,struct vlc_sd_probe_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4377,74099,VLC_USED,2,input\stream.h.VLC_USED,,input\stream.h,ANY VLC_USED,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4378,74107,VLC_USED,2,input\stream.h.VLC_USED,,input\stream.h,ANY VLC_USED,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4379,75837,sub_exts,2,input\subtitles.c.sub_exts,,input\subtitles.c,char[] sub_exts,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4380,76979,vlc_input_callback_t,2,input\var.c.vlc_input_callback_t,,input\var.c,struct vlc_input_callback_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4381,76992,p_input_callbacks,2,input\var.c.p_input_callbacks,,input\var.c,static const vlc_input_callback_t[] p_input_callbacks,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4382,77047,p_input_title_navigation_callbacks,2,input\var.c.p_input_title_navigation_callbacks,,input\var.c,static const vlc_input_callback_t[] p_input_title_navigation_callbacks,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4383,79543,vlm_mutex,2,input\vlm.c.vlm_mutex,,input\vlm.c,vlc_mutex_t vlm_mutex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
4384,83664,vlm_media_instance_sys_t,2,input\vlm_internal.h.vlm_media_instance_sys_t,,input\vlm_internal.h,struct vlm_media_instance_sys_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4385,83673,vlm_media_sys_t,2,input\vlm_internal.h.vlm_media_sys_t,,input\vlm_internal.h,struct vlm_media_sys_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4386,83682,vlm_schedule_sys_t,2,input\vlm_internal.h.vlm_schedule_sys_t,,input\vlm_internal.h,struct vlm_schedule_sys_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4387,85977,lock,2,interface\interface.c.lock,,interface\interface.c,vlc_mutex_t lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
4388,86585,ppsz_snap_formats,2,libvlc-module.c.ppsz_snap_formats,,libvlc-module.c,char[] ppsz_snap_formats,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4389,86592,ppsz_roles,2,libvlc-module.c.ppsz_roles,,libvlc-module.c,char[] ppsz_roles,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4390,86605,ppsz_roles_text,2,libvlc-module.c.ppsz_roles_text,,libvlc-module.c,char[] ppsz_roles_text,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4391,86627,pi_force_dolby_values,2,libvlc-module.c.pi_force_dolby_values,,libvlc-module.c,int[] pi_force_dolby_values,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4392,86634,ppsz_force_dolby_descriptions,2,libvlc-module.c.ppsz_force_dolby_descriptions,,libvlc-module.c,char[] ppsz_force_dolby_descriptions,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4393,86644,pi_stereo_mode_values,2,libvlc-module.c.pi_stereo_mode_values,,libvlc-module.c,int[] pi_stereo_mode_values,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4394,86655,ppsz_stereo_mode_texts,2,libvlc-module.c.ppsz_stereo_mode_texts,,libvlc-module.c,char[] ppsz_stereo_mode_texts,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4395,86673,ppsz_replay_gain_mode,2,libvlc-module.c.ppsz_replay_gain_mode,,libvlc-module.c,char[] ppsz_replay_gain_mode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4396,86680,ppsz_replay_gain_mode_text,2,libvlc-module.c.ppsz_replay_gain_mode_text,,libvlc-module.c,char[] ppsz_replay_gain_mode_text,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4397,86690,pi_align_values,2,libvlc-module.c.pi_align_values,,libvlc-module.c,int[] pi_align_values,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4398,86703,ppsz_align_descriptions,2,libvlc-module.c.ppsz_align_descriptions,,libvlc-module.c,char[] ppsz_align_descriptions,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4399,86725,pi_deinterlace,2,libvlc-module.c.pi_deinterlace,,libvlc-module.c,int[] pi_deinterlace,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4400,86733,ppsz_deinterlace_text,2,libvlc-module.c.ppsz_deinterlace_text,,libvlc-module.c,char[] ppsz_deinterlace_text,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4401,86740,ppsz_deinterlace_mode,2,libvlc-module.c.ppsz_deinterlace_mode,,libvlc-module.c,char[] ppsz_deinterlace_mode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4402,86755,ppsz_deinterlace_mode_text,2,libvlc-module.c.ppsz_deinterlace_mode_text,,libvlc-module.c,char[] ppsz_deinterlace_mode_text,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4403,86778,pi_pos_values,2,libvlc-module.c.pi_pos_values,,libvlc-module.c,int[] pi_pos_values,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4404,86791,ppsz_pos_descriptions,2,libvlc-module.c.ppsz_pos_descriptions,,libvlc-module.c,char[] ppsz_pos_descriptions,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4405,86813,pi_clock_values,2,libvlc-module.c.pi_clock_values,,libvlc-module.c,int[] pi_clock_values,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4406,86821,ppsz_clock_descriptions,2,libvlc-module.c.ppsz_clock_descriptions,,libvlc-module.c,char[] ppsz_clock_descriptions,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4407,86831,pi_captions,2,libvlc-module.c.pi_captions,,libvlc-module.c,int[] pi_captions,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4408,86837,ppsz_captions,2,libvlc-module.c.ppsz_captions,,libvlc-module.c,char[] ppsz_captions,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4409,86843,pi_prefres,2,libvlc-module.c.pi_prefres,,libvlc-module.c,int[] pi_prefres,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4410,86854,ppsz_prefres,2,libvlc-module.c.ppsz_prefres,,libvlc-module.c,char[] ppsz_prefres,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4411,86870,psz_recursive_list,2,libvlc-module.c.psz_recursive_list,,libvlc-module.c,char[] psz_recursive_list,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4412,86877,psz_recursive_list_text,2,libvlc-module.c.psz_recursive_list_text,,libvlc-module.c,char[] psz_recursive_list_text,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4413,86887,mouse_wheel_values,2,libvlc-module.c.mouse_wheel_values,,libvlc-module.c,int[] mouse_wheel_values,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4414,86896,mouse_wheel_texts,2,libvlc-module.c.mouse_wheel_texts,,libvlc-module.c,char[] mouse_wheel_texts,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4415,87808,psz_vlc_changeset,2,libvlc.h.psz_vlc_changeset,,libvlc.h,char[] psz_vlc_changeset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4416,88750,s_keys,2,misc\actions.c.s_keys,,misc\actions.c,key_descriptor[] s_keys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
4417,89508,s_names2actions,2,misc\actions.c.s_names2actions,,misc\actions.c,name2action[] s_names2actions,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,17,0,1,1,0,0,,0,0,0,0,0,
4418,93451,background_worker_New,2,misc\background_worker.h.background_worker_New,,misc\background_worker.h,struct background_worker* background_worker_New,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4419,94394,cpu_flags,2,misc\cpu.c.cpu_flags,,misc\cpu.c,uint32_t cpu_flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
