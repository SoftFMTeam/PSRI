11,METHOD,android\error.c:<global>,TYPE_DECL,<global>,1,11,android\error.c,android\error.c:<global>,,false,1,39,<global>,,,1,
13,METHOD,android\error.c:<global>,TYPE_DECL,"const char* vlc_strerror(int errnum)
{
    return vlc_strerror_c(errnum);
}",1,1,android\error.c,vlc_strerror,,false,29,32,vlc_strerror,,,1,const char* vlc_strerror (int)
21,METHOD,android\error.c:<global>,TYPE_DECL,"const char* vlc_strerror_c(int errnum)
{
    static __thread char android_buf[100];
    strerror_r(errnum, android_buf, 100);
    return android_buf;
}",1,11,android\error.c,vlc_strerror_c,,false,34,39,vlc_strerror_c,,,2,const char* vlc_strerror_c (int)
54,METHOD,android\specific.c:<global>,TYPE_DECL,<global>,1,20,android\specific.c,android\specific.c:<global>,,false,1,392,<global>,,,1,
87,METHOD,android\specific.c:<global>,TYPE_DECL,"static char *
get_java_string(JNIEnv *env, jclass clazz, const char *psz_name)
{
    jfieldID id = (*env)->GetStaticFieldID(env, clazz, psz_name,
                                           ""Ljava/lang/String;"");
    if ((*env)->ExceptionCheck(env))
    {
        (*env)->ExceptionClear(env);
        return NULL;
    }

    jstring jstr = (*env)->GetStaticObjectField(env, clazz, id);

    const char *psz_str = (*env)->GetStringUTFChars(env, jstr, 0);
    if (psz_str == NULL)
        return NULL;

    char *psz_strdup = strdup(psz_str);

    (*env)->ReleaseStringUTFChars(env, jstr, psz_str);
    (*env)->DeleteLocalRef(env, jstr);

    return psz_strdup;
}",1,1,android\specific.c,get_java_string,,false,53,76,get_java_string,,,8,"char* get_java_string (JNIEnv*,jclass,char*)"
173,METHOD,android\specific.c:<global>,TYPE_DECL,"void
JNI_OnUnload(JavaVM* vm, void* reserved)
{
    (void) reserved;

    for (size_t i = 0; i < GENERIC_DIR_COUNT; ++i)
        free(ppsz_generic_names[i]);

    JNIEnv* env = NULL;
    if ((*vm)->GetEnv(vm, (void**) &env, JNI_VERSION_1_2) != JNI_OK)
        return;

    if (fields.Environment.clazz)
        (*env)->DeleteGlobalRef(env, fields.Environment.clazz);

    if (fields.System.clazz)
        (*env)->DeleteGlobalRef(env, fields.System.clazz);
}",1,27,android\specific.c,JNI_OnUnload,,false,78,95,JNI_OnUnload,,,9,"void JNI_OnUnload (JavaVM*,void*)"
259,METHOD,android\specific.c:<global>,TYPE_DECL,"jint
JNI_OnLoad(JavaVM *vm, void *reserved)
{
    s_jvm = vm;
    JNIEnv* env = NULL;

    if ((*vm)->GetEnv(vm, (void**) &env, JNI_VERSION_1_2) != JNI_OK)
        return -1;

    jclass clazz = (*env)->FindClass(env, ""android/os/Environment"");
    if ((*env)->ExceptionCheck(env))
        return -1;

    static const char *ppsz_env_names[GENERIC_DIR_COUNT] = {
        NULL,                   /* VLC_DESKTOP_DIR */
        ""DIRECTORY_DOWNLOADS"",  /* VLC_DOWNLOAD_DIR */
        NULL,                   /* VLC_TEMPLATES_DIR */
        NULL,                   /* VLC_PUBLICSHARE_DIR */
        ""DIRECTORY_DOCUMENTS"",  /* VLC_DOCUMENTS_DIR */
        ""DIRECTORY_MUSIC"",      /* VLC_MUSIC_DIR */
        ""DIRECTORY_PICTURES"",   /* VLC_PICTURES_DIR */
        ""DIRECTORY_MOVIES"",     /* VLC_VIDEOS_DIR */
    };
    for (size_t i = 0; i < GENERIC_DIR_COUNT; ++i)
    {
        if (ppsz_env_names[i] != NULL)
            ppsz_generic_names[i] = get_java_string(env, clazz,
                            ...",1,38,android\specific.c,JNI_OnLoad,,false,100,163,JNI_OnLoad,,,10,"jint JNI_OnLoad (JavaVM*,void*)"
514,METHOD,android\specific.c:<global>,TYPE_DECL,"void
system_Init(void)
{
}",1,1,android\specific.c,system_Init,,false,165,168,system_Init,,,11,void system_Init (void)
519,METHOD,android\specific.c:<global>,TYPE_DECL,"void
system_Configure(libvlc_int_t *p_libvlc, int i_argc, const char *const pp_argv[])
{
    (void)i_argc; (void)pp_argv;
    assert(s_jvm != NULL);
    var_Create(p_libvlc, ""android-jvm"", VLC_VAR_ADDRESS);
    var_SetAddress(p_libvlc, ""android-jvm"", s_jvm);
}",1,1,android\specific.c,system_Configure,,false,170,177,system_Configure,,,12,"void system_Configure (libvlc_int_t*,int,char[]*)"
544,METHOD,android\specific.c:<global>,TYPE_DECL,"static char *config_GetHomeDir(const char *psz_dir, const char *psz_default_dir)
{
    char *psz_home = getenv(""HOME"");
    if (psz_home == NULL)
        goto fallback;

    if (psz_dir == NULL)
        return strdup(psz_home);

    char *psz_fullpath;
    if (asprintf(&psz_fullpath, ""%s/%s"", psz_home, psz_dir) == -1)
        goto fallback;
    if (vlc_mkdir(psz_fullpath, 0700) == -1 && errno != EEXIST)
    {
        free(psz_fullpath);
        goto fallback;
    }
    return psz_fullpath;

fallback:
    return psz_default_dir != NULL ? strdup(psz_default_dir) : NULL;
}",1,1,android\specific.c,config_GetHomeDir,,false,179,200,config_GetHomeDir,,,13,"char* config_GetHomeDir (char*,char*)"
608,METHOD,android\specific.c:<global>,TYPE_DECL,"static JNIEnv *get_env(bool *p_detach)
{
    JNIEnv *env;
    if ((*s_jvm)->GetEnv(s_jvm, (void **)&env, JNI_VERSION_1_2) != JNI_OK)
    {
        /* attach the thread to the Java VM */
        JavaVMAttachArgs args;

        args.version = JNI_VERSION_1_2;
        args.name = ""config_GetGenericDir"";
        args.group = NULL;

        if ((*s_jvm)->AttachCurrentThread(s_jvm, &env, &args) != JNI_OK)
            return NULL;
        *p_detach = true;
    }
    else
        *p_detach = false;
    return env;
}",1,1,android\specific.c,get_env,,false,202,221,get_env,,,14,JNIEnv get_env (bool*)
673,METHOD,android\specific.c:<global>,TYPE_DECL,"static void release_env(bool b_detach)
{
    if (b_detach)
        (*s_jvm)->DetachCurrentThread(s_jvm);
}",1,1,android\specific.c,release_env,,false,223,227,release_env,,,15,void release_env (bool)
687,METHOD,android\specific.c:<global>,TYPE_DECL,"static char *config_GetGenericDir(const char *psz_name)
{
    JNIEnv *env;
    bool b_detach;
    char *psz_ret = NULL;

    env = get_env(&b_detach);
    if (env == NULL)
        return NULL;

    jstring jname= (*env)->NewStringUTF(env, psz_name);
    if ((*env)->ExceptionCheck(env))
    {
        (*env)->ExceptionClear(env);
        jname = NULL;
    }
    if (jname == NULL)
        goto error;

    jobject jfile = (*env)->CallStaticObjectMethod(env,
                        fields.Environment.clazz,
                        fields.Environment.getExternalStoragePublicDirectory,
                        jname);
    (*env)->DeleteLocalRef(env, jname);
    if (jfile == NULL)
        goto error;

    jstring jpath = (*env)->CallObjectMethod(env, jfile,
                                             fields.File.getAbsolutePath);
    (*env)->DeleteLocalRef(env, jfile);

    const char *psz_path = (*env)->GetStringUTFChars(env, jpath, 0);
    if (psz_path == NULL)
        goto error;
    psz...",1,1,android\specific.c,config_GetGenericDir,,false,229,270,config_GetGenericDir,,,16,char* config_GetGenericDir (char*)
839,METHOD,android\specific.c:<global>,TYPE_DECL,"char *config_GetUserDir (vlc_userdir_t type)
{
    switch (type)
    {
        case VLC_DATA_DIR:
            return config_GetHomeDir("".share"",
                ""/sdcard/Android/data/org.videolan.vlc"");
        case VLC_CACHE_DIR:
            return config_GetHomeDir("".cache"",
                ""/sdcard/Android/data/org.videolan.vlc/cache"");
        case VLC_HOME_DIR:
            return config_GetHomeDir(NULL, NULL);
        case VLC_CONFIG_DIR:
            return config_GetHomeDir("".config"", NULL);

        case VLC_DESKTOP_DIR:
        case VLC_DOWNLOAD_DIR:
        case VLC_TEMPLATES_DIR:
        case VLC_PUBLICSHARE_DIR:
        case VLC_DOCUMENTS_DIR:
        case VLC_MUSIC_DIR:
        case VLC_PICTURES_DIR:
        case VLC_VIDEOS_DIR:
        {
            assert(type >= VLC_DESKTOP_DIR && type <= VLC_VIDEOS_DIR);
            const char *psz_name = ppsz_generic_names[type - VLC_DESKTOP_DIR];
            if (psz_name != NULL)
                return config_GetGenericDir(psz_name...",1,1,android\specific.c,config_GetUserDir,,false,272,303,config_GetUserDir,,,17,char* config_GetUserDir (vlc_userdir_t)
914,METHOD,android\specific.c:<global>,TYPE_DECL,"char *vlc_getProxyUrl(const char *url)
{
    VLC_UNUSED(url);
    JNIEnv *env;
    bool b_detach;
    char *psz_ret = NULL;
    const char *psz_host = NULL, *psz_port = NULL;
    jstring jhost = NULL, jport = NULL;

    env = get_env(&b_detach);
    if (env == NULL)
        return NULL;

    /* Fetch ""http.proxyHost"" property */
    jstring jkey = (*env)->NewStringUTF(env, ""http.proxyHost"");
    if ((*env)->ExceptionCheck(env))
    {
        (*env)->ExceptionClear(env);
        jkey = NULL;
    }
    if (jkey == NULL)
        goto end;

    jhost = (*env)->CallStaticObjectMethod(env, fields.System.clazz,
                                           fields.System.getProperty, jkey);
    (*env)->DeleteLocalRef(env, jkey);
    if (jhost == NULL)
        goto end;

    psz_host = (*env)->GetStringUTFChars(env, jhost, 0);
    /* Ensure the property is valid */
    if (psz_host == NULL || psz_host[0] == '\0')
        goto end;

    /* Fetch ""http.proxyPort"" property (only if ""http.proxyHost...",1,1,android\specific.c,vlc_getProxyUrl,,false,315,392,vlc_getProxyUrl,,,18,char* vlc_getProxyUrl (char*)
1250,METHOD,android\thread.c:<global>,TYPE_DECL,<global>,1,1,android\thread.c,android\thread.c:<global>,,false,1,421,<global>,,,1,
1252,METHOD,android\thread.c:<global>,TYPE_DECL,"static void
vlc_thread_fatal_print (const char *action, int error,
                        const char *function, const char *file, unsigned line)
{
    char buf[1000];
    const char *msg;

    switch (strerror_r (error, buf, sizeof (buf)))
    {
        case 0:
            msg = buf;
            break;
        case ERANGE: /* should never happen */
            msg = ""unknown (too big to display)"";
            break;
        default:
            msg = ""unknown (invalid error number)"";
            break;
    }

    fprintf(stderr, ""LibVLC fatal error %s (%d) in thread %lu ""
            ""at %s:%u in %s\n Error message: %s\n"",
            action, error, vlc_thread_id (), file, line, function, msg);
    fflush (stderr);
}",1,1,android\thread.c,vlc_thread_fatal_print,,false,48,72,vlc_thread_fatal_print,,,1,"void vlc_thread_fatal_print (char*,int,char*,char*,unsigned)"
1299,METHOD,android\thread.c:<global>,TYPE_DECL,"void vlc_mutex_init( vlc_mutex_t *p_mutex )
{
    pthread_mutexattr_t attr;

    pthread_mutexattr_init (&attr);
#ifdef NDEBUG
    pthread_mutexattr_settype (&attr, PTHREAD_MUTEX_DEFAULT);
#else
    pthread_mutexattr_settype (&attr, PTHREAD_MUTEX_ERRORCHECK);
#endif
    pthread_mutex_init (p_mutex, &attr);
    pthread_mutexattr_destroy( &attr );
}",1,1,android\thread.c,vlc_mutex_init,,false,85,97,vlc_mutex_init,,,2,void vlc_mutex_init (vlc_mutex_t*)
1319,METHOD,android\thread.c:<global>,TYPE_DECL,"void vlc_mutex_init_recursive( vlc_mutex_t *p_mutex )
{
    pthread_mutexattr_t attr;

    pthread_mutexattr_init (&attr);
    pthread_mutexattr_settype (&attr, PTHREAD_MUTEX_RECURSIVE);
    pthread_mutex_init (p_mutex, &attr);
    pthread_mutexattr_destroy( &attr );
}",1,1,android\thread.c,vlc_mutex_init_recursive,,false,99,107,vlc_mutex_init_recursive,,,3,void vlc_mutex_init_recursive (vlc_mutex_t*)
1339,METHOD,android\thread.c:<global>,TYPE_DECL,"void vlc_mutex_destroy (vlc_mutex_t *p_mutex)
{
    int val = pthread_mutex_destroy( p_mutex );
    VLC_THREAD_ASSERT (""destroying mutex"");
}",1,4,android\thread.c,vlc_mutex_destroy,,false,110,114,vlc_mutex_destroy,,,4,void vlc_mutex_destroy (vlc_mutex_t*)
1368,METHOD,android\thread.c:<global>,TYPE_DECL,"void vlc_mutex_lock (vlc_mutex_t *p_mutex)
{
    int val = pthread_mutex_lock( p_mutex );
    VLC_THREAD_ASSERT (""locking mutex"");
}",1,4,android\thread.c,vlc_mutex_lock,,false,123,127,vlc_mutex_lock,,,6,void vlc_mutex_lock (vlc_mutex_t*)
1396,METHOD,android\thread.c:<global>,TYPE_DECL,"int vlc_mutex_trylock (vlc_mutex_t *p_mutex)
{
    int val = pthread_mutex_trylock( p_mutex );

    if (val != EBUSY)
        VLC_THREAD_ASSERT (""locking mutex"");
    return val;
}",1,8,android\thread.c,vlc_mutex_trylock,,false,129,136,vlc_mutex_trylock,,,7,int vlc_mutex_trylock (vlc_mutex_t*)
1431,METHOD,android\thread.c:<global>,TYPE_DECL,"void vlc_mutex_unlock (vlc_mutex_t *p_mutex)
{
    int val = pthread_mutex_unlock( p_mutex );
    VLC_THREAD_ASSERT (""unlocking mutex"");
}",1,4,android\thread.c,vlc_mutex_unlock,,false,138,142,vlc_mutex_unlock,,,8,void vlc_mutex_unlock (vlc_mutex_t*)
1462,METHOD,vlc_thread,TYPE_DECL,void *(*entry)(void*);,10,25,android\thread.c,vlc_thread.entry,,false,149,149,entry,,,3,void* vlc_thread.entry (void*)
1475,METHOD,android\thread.c:<global>,TYPE_DECL,"vlc_thread_t vlc_thread_self (void)
{
    return thread;
}",1,1,android\thread.c,vlc_thread_self,,false,164,167,vlc_thread_self,,,11,vlc_thread_t vlc_thread_self (void)
1482,METHOD,android\thread.c:<global>,TYPE_DECL,"void vlc_threads_setup (libvlc_int_t *p_libvlc)
{
    (void)p_libvlc;
}",1,1,android\thread.c,vlc_threads_setup,,false,169,172,vlc_threads_setup,,,12,void vlc_threads_setup (libvlc_int_t*)
1490,METHOD,android\thread.c:<global>,TYPE_DECL,"static void clean_detached_thread(void *data)
{
    struct vlc_thread *th = data;

    /* release thread handle */
    vlc_mutex_destroy(&th->wait.lock);
    free(th);
}",1,1,android\thread.c,clean_detached_thread,,false,175,182,clean_detached_thread,,,13,void clean_detached_thread (void*)
1508,METHOD,android\thread.c:<global>,TYPE_DECL,"static void *detached_thread(void *data)
{
    vlc_thread_t th = data;

    thread = th;

    vlc_cleanup_push(clean_detached_thread, th);
    th->entry(th->data);
    vlc_cleanup_pop();
    clean_detached_thread(th);
    return NULL;
}",1,1,android\thread.c,detached_thread,,false,184,195,detached_thread,,,14,void* detached_thread (void*)
1535,METHOD,android\thread.c:<global>,TYPE_DECL,"static void finish_joinable_thread(void *data)
{
    vlc_thread_t th = data;

    vlc_sem_post(&th->finished);
}",1,1,android\thread.c,finish_joinable_thread,,false,197,202,finish_joinable_thread,,,15,void finish_joinable_thread (void*)
1549,METHOD,android\thread.c:<global>,TYPE_DECL,"static void *joinable_thread(void *data)
{
    vlc_thread_t th = data;
    void *ret;

    vlc_cleanup_push(finish_joinable_thread, th);
    thread = th;
    ret = th->entry(th->data);
    vlc_cleanup_pop();
    vlc_sem_post(&th->finished);

    return ret;
}",1,1,android\thread.c,joinable_thread,,false,204,216,joinable_thread,,,16,void* joinable_thread (void*)
1582,METHOD,android\thread.c:<global>,TYPE_DECL,"static int vlc_clone_attr (vlc_thread_t *th, void *(*entry) (void *),
                           void *data, bool detach)
{
    vlc_thread_t thread = malloc (sizeof (*thread));
    if (unlikely(thread == NULL))
        return ENOMEM;

    int ret;

    sigset_t oldset;
    {
        sigset_t set;
        sigemptyset (&set);
        sigdelset (&set, SIGHUP);
        sigaddset (&set, SIGINT);
        sigaddset (&set, SIGQUIT);
        sigaddset (&set, SIGTERM);

        sigaddset (&set, SIGPIPE); /* We don't want this one, really! */
        pthread_sigmask (SIG_BLOCK, &set, &oldset);
    }

    if (!detach)
        vlc_sem_init(&thread->finished, 0);
    atomic_store(&thread->killed, false);
    thread->killable = true;
    thread->entry = entry;
    thread->data = data;
    thread->wait.addr = NULL;
    vlc_mutex_init(&thread->wait.lock);

    pthread_attr_t attr;
    pthread_attr_init (&attr);
    pthread_attr_setdetachstate (&attr, detach ? PTHREAD_CREATE_DETACHED
                ...",1,1,android\thread.c,vlc_clone_attr,,false,218,261,vlc_clone_attr,,,17,"int vlc_clone_attr (vlc_thread_t*,void*,void*,bool)"
1722,METHOD,android\thread.c:<global>,TYPE_DECL,"int vlc_clone (vlc_thread_t *th, void *(*entry) (void *), void *data,
               int priority)
{
    (void) priority;
    return vlc_clone_attr (th, entry, data, false);
}",1,1,android\thread.c,vlc_clone,,false,263,268,vlc_clone,,,18,"int vlc_clone (vlc_thread_t*,void*,void*,int)"
1739,METHOD,android\thread.c:<global>,TYPE_DECL,"void vlc_join (vlc_thread_t handle, void **result)
{
    vlc_sem_wait (&handle->finished);
    vlc_sem_destroy (&handle->finished);

    int val = pthread_join (handle->thread, result);
    VLC_THREAD_ASSERT (""joining thread"");
    clean_detached_thread(handle);
}",1,4,android\thread.c,vlc_join,,false,270,278,vlc_join,,,19,"void vlc_join (vlc_thread_t,void**)"
1783,METHOD,android\thread.c:<global>,TYPE_DECL,"int vlc_clone_detach (vlc_thread_t *th, void *(*entry) (void *), void *data,
                      int priority)
{
    vlc_thread_t dummy;
    if (th == NULL)
        th = &dummy;

    (void) priority;
    return vlc_clone_attr (th, entry, data, true);
}",1,1,android\thread.c,vlc_clone_detach,,false,280,289,vlc_clone_detach,,,20,"int vlc_clone_detach (vlc_thread_t*,void*,void*,int)"
1810,METHOD,android\thread.c:<global>,TYPE_DECL,"int vlc_set_priority (vlc_thread_t th, int priority)
{
    (void) th; (void) priority;
    return VLC_SUCCESS;
}",1,1,android\thread.c,vlc_set_priority,,false,291,295,vlc_set_priority,,,21,"int vlc_set_priority (vlc_thread_t,int)"
1824,METHOD,android\thread.c:<global>,TYPE_DECL,"void vlc_cancel (vlc_thread_t thread_id)
{
    atomic_int *addr;

    atomic_store(&thread_id->killed, true);

    vlc_mutex_lock(&thread_id->wait.lock);
    addr = thread_id->wait.addr;
    if (addr != NULL)
    {
        atomic_fetch_or_explicit(addr, 1, memory_order_relaxed);
        vlc_addr_broadcast(addr);
    }
    vlc_mutex_unlock(&thread_id->wait.lock);
}",1,1,android\thread.c,vlc_cancel,,false,297,311,vlc_cancel,,,22,void vlc_cancel (vlc_thread_t)
1868,METHOD,android\thread.c:<global>,TYPE_DECL,"int vlc_savecancel (void)
{
    if (!thread) /* not created by VLC, can't be cancelled */
        return true;

    int oldstate = thread->killable;
    thread->killable = false;
    return oldstate;
}",1,1,android\thread.c,vlc_savecancel,,false,313,321,vlc_savecancel,,,23,int vlc_savecancel (void)
1892,METHOD,android\thread.c:<global>,TYPE_DECL,"void vlc_restorecancel (int state)
{
    if (!thread) /* not created by VLC, can't be cancelled */
        return;

    thread->killable = state;
}",1,1,android\thread.c,vlc_restorecancel,,false,323,329,vlc_restorecancel,,,24,void vlc_restorecancel (int)
1907,METHOD,android\thread.c:<global>,TYPE_DECL,"void vlc_testcancel (void)
{
    if (!thread) /* not created by VLC, can't be cancelled */
        return;
    if (!thread->killable)
        return;
    if (!atomic_load(&thread->killed))
        return;

    pthread_exit(NULL);
}",1,1,android\thread.c,vlc_testcancel,,false,331,341,vlc_testcancel,,,25,void vlc_testcancel (void)
1935,METHOD,android\thread.c:<global>,TYPE_DECL,"void vlc_control_cancel(int cmd, ...)
{
    vlc_thread_t th = vlc_thread_self();
    va_list ap;

    if (th == NULL)
        return;

    va_start(ap, cmd);
    switch (cmd)
    {
        case VLC_CANCEL_ADDR_SET:
        {
            void *addr = va_arg(ap, void *);

            vlc_mutex_lock(&th->wait.lock);
            assert(th->wait.addr == NULL);
            th->wait.addr = addr;
            vlc_mutex_unlock(&th->wait.lock);
            break;
        }

        case VLC_CANCEL_ADDR_CLEAR:
        {
            void *addr = va_arg(ap, void *);

            vlc_mutex_lock(&th->wait.lock);
            assert(th->wait.addr == addr);
            th->wait.addr = NULL;
            (void) addr;
            vlc_mutex_unlock(&th->wait.lock);
            break;
        }

        default:
            vlc_assert_unreachable ();
    }
    va_end(ap);
}",1,1,android\thread.c,vlc_control_cancel,,false,343,381,vlc_control_cancel,,,26,void vlc_control_cancel (int...)
2032,METHOD,android\thread.c:<global>,TYPE_DECL,"int vlc_threadvar_create (vlc_threadvar_t *key, void (*destr) (void *))
{
    return pthread_key_create (key, destr);
}",1,1,android\thread.c,vlc_threadvar_create,,false,385,388,vlc_threadvar_create,,,27,"int vlc_threadvar_create (vlc_threadvar_t*,void)"
2042,METHOD,android\thread.c:<global>,TYPE_DECL,"void vlc_threadvar_delete (vlc_threadvar_t *p_tls)
{
    pthread_key_delete (*p_tls);
}",1,1,android\thread.c,vlc_threadvar_delete,,false,390,393,vlc_threadvar_delete,,,28,void vlc_threadvar_delete (vlc_threadvar_t*)
2050,METHOD,android\thread.c:<global>,TYPE_DECL,"int vlc_threadvar_set (vlc_threadvar_t key, void *value)
{
    return pthread_setspecific (key, value);
}",1,1,android\thread.c,vlc_threadvar_set,,false,395,398,vlc_threadvar_set,,,29,"int vlc_threadvar_set (vlc_threadvar_t,void*)"
2060,METHOD,android\thread.c:<global>,TYPE_DECL,"void *vlc_threadvar_get (vlc_threadvar_t key)
{
    return pthread_getspecific (key);
}",1,1,android\thread.c,vlc_threadvar_get,,false,400,403,vlc_threadvar_get,,,30,void* vlc_threadvar_get (vlc_threadvar_t)
2068,METHOD,android\thread.c:<global>,TYPE_DECL,"mtime_t mdate (void)
{
    struct timespec ts;

    if (unlikely(clock_gettime (CLOCK_MONOTONIC, &ts) != 0))
        abort ();

    return (INT64_C(1000000) * ts.tv_sec) + (ts.tv_nsec / 1000);
}",1,1,android\thread.c,mdate,,false,406,414,mdate,,,31,mtime_t mdate (void)
2097,METHOD,android\thread.c:<global>,TYPE_DECL,"unsigned vlc_GetCPUCount(void)
{
    return sysconf(_SC_NPROCESSORS_ONLN);
}",1,1,android\thread.c,vlc_GetCPUCount,,false,418,421,vlc_GetCPUCount,,,32,unsigned vlc_GetCPUCount (void)
2112,METHOD,audio_output\aout_internal.h:<global>,TYPE_DECL,<global>,1,36,audio_output\aout_internal.h,audio_output\aout_internal.h:<global>,,false,1,186,<global>,,,1,
2118,METHOD,<empty>,<empty>,<empty>,1,,audio_output\aout_internal.h,anonymous_enum_0:<clinit>,,false,33,,<clinit>,,,4,
2173,METHOD,audio_output\aout_internal.h:<global>,TYPE_DECL,"static inline aout_owner_t *aout_owner (audio_output_t *aout)
{
    return &((aout_instance_t *)aout)->owner;
}",1,1,audio_output\aout_internal.h,aout_owner,,false,105,108,aout_owner,,,11,aout_owner_t aout_owner (audio_output_t*)
2185,METHOD,audio_output\aout_internal.h:<global>,TYPE_DECL,"aout_volume_t *aout_volume_New(vlc_object_t *, const audio_replay_gain_t *);",15,75,audio_output\aout_internal.h,aout_volume_New,,false,115,115,aout_volume_New,,,12,"aout_volume_t* aout_volume_New (vlc_object_t*,audio_replay_gain_t*)"
2191,METHOD,audio_output\aout_internal.h:<global>,TYPE_DECL,"int aout_volume_SetFormat(aout_volume_t *, vlc_fourcc_t);",5,56,audio_output\aout_internal.h,aout_volume_SetFormat,,false,117,117,aout_volume_SetFormat,,,13,"int aout_volume_SetFormat (aout_volume_t*,ANY)"
2197,METHOD,audio_output\aout_internal.h:<global>,TYPE_DECL,"void aout_volume_SetVolume(aout_volume_t *, float);",6,50,audio_output\aout_internal.h,aout_volume_SetVolume,,false,118,118,aout_volume_SetVolume,,,14,"void aout_volume_SetVolume (aout_volume_t*,float)"
2203,METHOD,audio_output\aout_internal.h:<global>,TYPE_DECL,"int aout_volume_Amplify(aout_volume_t *, block_t *);",5,51,audio_output\aout_internal.h,aout_volume_Amplify,,false,119,119,aout_volume_Amplify,,,15,"int aout_volume_Amplify (aout_volume_t*,block_t*)"
2209,METHOD,audio_output\aout_internal.h:<global>,TYPE_DECL,void aout_volume_Delete(aout_volume_t *);,6,40,audio_output\aout_internal.h,aout_volume_Delete,,false,120,120,aout_volume_Delete,,,16,void aout_volume_Delete (aout_volume_t*)
2214,METHOD,audio_output\aout_internal.h:<global>,TYPE_DECL,audio_output_t *aout_New (vlc_object_t *);,16,41,audio_output\aout_internal.h,aout_New,,false,124,124,aout_New,,,17,audio_output_t* aout_New (vlc_object_t*)
2219,METHOD,audio_output\aout_internal.h:<global>,TYPE_DECL,void aout_Destroy (audio_output_t *);,6,36,audio_output\aout_internal.h,aout_Destroy,,false,126,126,aout_Destroy,,,18,void aout_Destroy (audio_output_t*)
2224,METHOD,audio_output\aout_internal.h:<global>,TYPE_DECL,"int aout_OutputNew(audio_output_t *, audio_sample_format_t *,
                   aout_filters_cfg_t *filters_cfg);",5,51,audio_output\aout_internal.h,aout_OutputNew,,false,128,129,aout_OutputNew,,,19,"int aout_OutputNew (audio_output_t*,audio_sample_format_t*,aout_filters_cfg_t*)"
2231,METHOD,audio_output\aout_internal.h:<global>,TYPE_DECL,"int aout_OutputTimeGet(audio_output_t *, mtime_t *);",5,51,audio_output\aout_internal.h,aout_OutputTimeGet,,false,130,130,aout_OutputTimeGet,,,20,"int aout_OutputTimeGet (audio_output_t*,mtime_t*)"
2237,METHOD,audio_output\aout_internal.h:<global>,TYPE_DECL,"void aout_OutputPlay(audio_output_t *, block_t *);",6,49,audio_output\aout_internal.h,aout_OutputPlay,,false,131,131,aout_OutputPlay,,,21,"void aout_OutputPlay (audio_output_t*,block_t*)"
2243,METHOD,audio_output\aout_internal.h:<global>,TYPE_DECL,"void aout_OutputPause( audio_output_t * p_aout, bool, mtime_t );",6,63,audio_output\aout_internal.h,aout_OutputPause,,false,132,132,aout_OutputPause,,,22,"void aout_OutputPause (audio_output_t*,ANY,ANY)"
2250,METHOD,audio_output\aout_internal.h:<global>,TYPE_DECL,"void aout_OutputFlush( audio_output_t * p_aout, bool );",6,54,audio_output\aout_internal.h,aout_OutputFlush,,false,133,133,aout_OutputFlush,,,23,"void aout_OutputFlush (audio_output_t*,ANY)"
2256,METHOD,audio_output\aout_internal.h:<global>,TYPE_DECL,void aout_OutputDelete( audio_output_t * p_aout );,6,49,audio_output\aout_internal.h,aout_OutputDelete,,false,134,134,aout_OutputDelete,,,24,void aout_OutputDelete (audio_output_t*)
2261,METHOD,audio_output\aout_internal.h:<global>,TYPE_DECL,void aout_OutputLock(audio_output_t *);,6,38,audio_output\aout_internal.h,aout_OutputLock,,false,135,135,aout_OutputLock,,,25,void aout_OutputLock (audio_output_t*)
2266,METHOD,audio_output\aout_internal.h:<global>,TYPE_DECL,void aout_OutputUnlock(audio_output_t *);,6,40,audio_output\aout_internal.h,aout_OutputUnlock,,false,136,136,aout_OutputUnlock,,,26,void aout_OutputUnlock (audio_output_t*)
2271,METHOD,audio_output\aout_internal.h:<global>,TYPE_DECL,"void aout_FormatsPrint(vlc_object_t *, const char *,
                       const audio_sample_format_t *,
                       const audio_sample_format_t *);",6,53,audio_output\aout_internal.h,aout_FormatsPrint,,false,140,142,aout_FormatsPrint,,,27,"void aout_FormatsPrint (vlc_object_t*,char*,audio_sample_format_t*,audio_sample_format_t*)"
2279,METHOD,audio_output\aout_internal.h:<global>,TYPE_DECL,"bool aout_ChangeFilterString( vlc_object_t *manager, vlc_object_t *aout,
                              const char *var, const char *name, bool b_add );",6,77,audio_output\aout_internal.h,aout_ChangeFilterString,,false,145,146,aout_ChangeFilterString,,,28,"bool aout_ChangeFilterString (vlc_object_t*,vlc_object_t*,char*,char*,bool)"
2288,METHOD,audio_output\aout_internal.h:<global>,TYPE_DECL,"int aout_DecNew(audio_output_t *, const audio_sample_format_t *,
                const audio_replay_gain_t *, const aout_request_vout_t *);",5,73,audio_output\aout_internal.h,aout_DecNew,,false,153,154,aout_DecNew,,,29,"int aout_DecNew (audio_output_t*,audio_sample_format_t*,audio_replay_gain_t*,aout_request_vout_t*)"
2296,METHOD,audio_output\aout_internal.h:<global>,TYPE_DECL,void aout_DecDelete(audio_output_t *);,6,37,audio_output\aout_internal.h,aout_DecDelete,,false,155,155,aout_DecDelete,,,30,void aout_DecDelete (audio_output_t*)
2301,METHOD,audio_output\aout_internal.h:<global>,TYPE_DECL,"int aout_DecPlay(audio_output_t *, block_t *, int i_input_rate);",5,63,audio_output\aout_internal.h,aout_DecPlay,,false,156,156,aout_DecPlay,,,31,"int aout_DecPlay (audio_output_t*,block_t*,int)"
2308,METHOD,audio_output\aout_internal.h:<global>,TYPE_DECL,"void aout_DecGetResetStats(audio_output_t *, unsigned *, unsigned *);",6,68,audio_output\aout_internal.h,aout_DecGetResetStats,,false,157,157,aout_DecGetResetStats,,,32,"void aout_DecGetResetStats (audio_output_t*,unsigned*,unsigned*)"
2315,METHOD,audio_output\aout_internal.h:<global>,TYPE_DECL,"void aout_DecChangePause(audio_output_t *, bool b_paused, mtime_t i_date);",6,73,audio_output\aout_internal.h,aout_DecChangePause,,false,158,158,aout_DecChangePause,,,33,"void aout_DecChangePause (audio_output_t*,bool,mtime_t)"
2322,METHOD,audio_output\aout_internal.h:<global>,TYPE_DECL,"void aout_DecFlush(audio_output_t *, bool wait);",6,47,audio_output\aout_internal.h,aout_DecFlush,,false,159,159,aout_DecFlush,,,34,"void aout_DecFlush (audio_output_t*,bool)"
2328,METHOD,audio_output\aout_internal.h:<global>,TYPE_DECL,"void aout_RequestRestart (audio_output_t *, unsigned);",6,53,audio_output\aout_internal.h,aout_RequestRestart,,false,160,160,aout_RequestRestart,,,35,"void aout_RequestRestart (audio_output_t*,unsigned)"
2334,METHOD,audio_output\aout_internal.h:<global>,TYPE_DECL,"static inline void aout_InputRequestRestart(audio_output_t *aout)
{
    aout_RequestRestart(aout, AOUT_RESTART_FILTERS);
}",1,1,audio_output\aout_internal.h,aout_InputRequestRestart,,false,162,165,aout_InputRequestRestart,,,36,void aout_InputRequestRestart (audio_output_t*)
2342,METHOD,audio_output\aout_internal.h:<global>,TYPE_DECL,"static inline void aout_SetWavePhysicalChannels(audio_sample_format_t *fmt)
{
    static const uint32_t wave_channels[] = {
        AOUT_CHAN_LEFT, AOUT_CHAN_RIGHT, AOUT_CHAN_CENTER,
        AOUT_CHAN_LFE, AOUT_CHAN_REARLEFT, AOUT_CHAN_REARRIGHT,
        AOUT_CHAN_MIDDLELEFT, AOUT_CHAN_MIDDLERIGHT, AOUT_CHAN_REARCENTER };

    fmt->i_physical_channels = 0;
    for (int i = 0; i < fmt->i_channels && i < AOUT_CHAN_MAX; ++i)
        fmt->i_physical_channels |= wave_channels[i];
    aout_FormatPrepare(fmt);
}",1,1,audio_output\aout_internal.h,aout_SetWavePhysicalChannels,,false,167,178,aout_SetWavePhysicalChannels,,,37,void aout_SetWavePhysicalChannels (audio_sample_format_t*)
2391,METHOD,audio_output\aout_internal.h:<global>,TYPE_DECL,bool aout_FiltersCanResample (aout_filters_t *filters);,6,54,audio_output\aout_internal.h,aout_FiltersCanResample,,false,181,181,aout_FiltersCanResample,,,38,bool aout_FiltersCanResample (aout_filters_t*)
2396,METHOD,audio_output\aout_internal.h:<global>,TYPE_DECL,"void aout_ChangeViewpoint(audio_output_t *aout,
                          const vlc_viewpoint_t *p_viewpoint);",6,61,audio_output\aout_internal.h,aout_ChangeViewpoint,,false,183,184,aout_ChangeViewpoint,,,39,"void aout_ChangeViewpoint (audio_output_t*,vlc_viewpoint_t*)"
2417,METHOD,audio_output\common.c:<global>,TYPE_DECL,<global>,1,22,audio_output\common.c,audio_output\common.c:<global>,,false,1,648,<global>,,,1,
2419,METHOD,audio_output\common.c:<global>,TYPE_DECL,"unsigned int aout_BitsPerSample( vlc_fourcc_t i_format )
{
    switch( vlc_fourcc_GetCodec( AUDIO_ES, i_format ) )
    {
    case VLC_CODEC_U8:
    case VLC_CODEC_S8:
    case VLC_CODEC_ALAW:
    case VLC_CODEC_MULAW:
        return 8;

    case VLC_CODEC_U16L:
    case VLC_CODEC_S16L:
    case VLC_CODEC_U16B:
    case VLC_CODEC_S16B:
        return 16;

    case VLC_CODEC_U24L:
    case VLC_CODEC_S24L:
    case VLC_CODEC_U24B:
    case VLC_CODEC_S24B:
        return 24;

    case VLC_CODEC_S24L32:
    case VLC_CODEC_S24B32:
    case VLC_CODEC_U32L:
    case VLC_CODEC_U32B:
    case VLC_CODEC_S32L:
    case VLC_CODEC_S32B:
    case VLC_CODEC_F32L:
    case VLC_CODEC_F32B:
        return 32;

    case VLC_CODEC_F64L:
    case VLC_CODEC_F64B:
        return 64;

    default:
        /* For these formats the caller has to indicate the parameters
         * by hand. */
        return 0;
    }
}",1,1,audio_output\common.c,aout_BitsPerSample,,false,42,83,aout_BitsPerSample,,,1,unsigned int aout_BitsPerSample (vlc_fourcc_t)
2486,METHOD,audio_output\common.c:<global>,TYPE_DECL,"void aout_FormatPrepare( audio_sample_format_t * p_format )
{

    unsigned i_channels = aout_FormatNbChannels( p_format );
    if( i_channels > 0 )
        p_format->i_channels = i_channels;
    p_format->i_bitspersample = aout_BitsPerSample( p_format->i_format );
    if( p_format->i_bitspersample > 0 )
    {
        p_format->i_bytes_per_frame = ( p_format->i_bitspersample / 8 )
                                    * p_format->i_channels;
        p_format->i_frame_length = 1;
    }
}",1,1,audio_output\common.c,aout_FormatPrepare,,false,88,101,aout_FormatPrepare,,,2,void aout_FormatPrepare (audio_sample_format_t*)
2539,METHOD,audio_output\common.c:<global>,TYPE_DECL,"const char * aout_FormatPrintChannels( const audio_sample_format_t * p_format )
{
    if (p_format->channel_type == AUDIO_CHANNEL_TYPE_AMBISONICS)
        return ""Ambisonics"";

    /* AUDIO_CHANNEL_TYPE_BITMAP */
    switch ( p_format->i_physical_channels )
    {
    case AOUT_CHAN_LEFT:
    case AOUT_CHAN_RIGHT:
    case AOUT_CHAN_CENTER:
        if ( (p_format->i_physical_channels & AOUT_CHAN_CENTER)
              || (p_format->i_physical_channels
                   & (AOUT_CHAN_LEFT | AOUT_CHAN_RIGHT)) )
            return ""Mono"";
        else if ( p_format->i_physical_channels & AOUT_CHAN_LEFT )
            return ""Left"";
        return ""Right"";
    case AOUT_CHAN_LEFT | AOUT_CHAN_RIGHT:
        if ( p_format->i_chan_mode & AOUT_CHANMODE_DOLBYSTEREO )
            return ""Dolby"";
        else if ( p_format->i_chan_mode & AOUT_CHANMODE_DUALMONO )
            return ""Dual-mono"";
        else if ( p_format->i_physical_channels == AOUT_CHAN_CENTER )
            return ""Stereo/Mono"";
...",1,1,audio_output\common.c,aout_FormatPrintChannels,,false,106,223,aout_FormatPrintChannels,,,3,const char* aout_FormatPrintChannels (audio_sample_format_t*)
3008,METHOD,audio_output\common.c:<global>,TYPE_DECL,"void aout_FormatPrint( vlc_object_t *obj, const char *psz_text,
                       const audio_sample_format_t *p_format )
{
    msg_Dbg( obj, ""%s '%4.4s' %d Hz %s frame=%d samples/%d bytes"", psz_text,
             (char *)&p_format->i_format, p_format->i_rate,
             aout_FormatPrintChannels( p_format ),
             p_format->i_frame_length, p_format->i_bytes_per_frame );
}",1,1,audio_output\common.c,aout_FormatPrint,,false,229,236,aout_FormatPrint,,,4,"void aout_FormatPrint (vlc_object_t*,char*,audio_sample_format_t*)"
3036,METHOD,audio_output\common.c:<global>,TYPE_DECL,"void aout_FormatsPrint( vlc_object_t *obj, const char * psz_text,
                        const audio_sample_format_t * p_format1,
                        const audio_sample_format_t * p_format2 )
{
    msg_Dbg( obj, ""%s '%4.4s'->'%4.4s' %d Hz->%d Hz %s->%s"",
             psz_text,
             (char *)&p_format1->i_format, (char *)&p_format2->i_format,
             p_format1->i_rate, p_format2->i_rate,
             aout_FormatPrintChannels( p_format1 ),
             aout_FormatPrintChannels( p_format2 ) );
}",1,1,audio_output\common.c,aout_FormatsPrint,,false,242,252,aout_FormatsPrint,,,5,"void aout_FormatsPrint (vlc_object_t*,char*,audio_sample_format_t*,audio_sample_format_t*)"
3070,METHOD,audio_output\common.c:<global>,TYPE_DECL,"unsigned aout_CheckChannelReorder( const uint32_t *chans_in,
                                   const uint32_t *chans_out,
                                   uint32_t mask, uint8_t *restrict table )
{
    static_assert(AOUT_CHAN_MAX <= (sizeof (mask) * CHAR_BIT), ""Missing bits"");

    unsigned channels = 0;

    if( chans_in == NULL )
        chans_in = pi_vlc_chan_order_wg4;
    if( chans_out == NULL )
        chans_out = pi_vlc_chan_order_wg4;

    for( unsigned i = 0; chans_in[i]; i++ )
    {
        const uint32_t chan = chans_in[i];
        if( !(mask & chan) )
            continue;

        unsigned index = 0;
        for( unsigned j = 0; chan != chans_out[j]; j++ )
            if( mask & chans_out[j] )
                index++;

        table[channels++] = index;
    }

    for( unsigned i = 0; i < channels; i++ )
        if( table[i] != i )
            return channels;
    return 0;
}",1,1,audio_output\common.c,aout_CheckChannelReorder,,false,257,288,aout_CheckChannelReorder,,,6,"unsigned aout_CheckChannelReorder (uint32_t*,uint32_t*,uint32_t,uint8_t*)"
3185,METHOD,audio_output\common.c:<global>,TYPE_DECL,"void aout_ChannelReorder( void *ptr, size_t bytes, uint8_t channels,
                          const uint8_t *restrict chans_table, vlc_fourcc_t fourcc )
{
    if( unlikely(bytes == 0) )
        return;

    assert( channels != 0 );

    /* The audio formats supported in audio output are inlined. For other
     * formats (used in demuxers and muxers), memcpy() is used to avoid
     * breaking type punning. */
#define REORDER_TYPE(type) \
do { \
    const size_t frames = (bytes / sizeof (type)) / channels; \
    type *buf = ptr; \
\
    for( size_t i = 0; i < frames; i++ ) \
    { \
        type tmp[AOUT_CHAN_MAX]; \
\
        for( size_t j = 0; j < channels; j++ ) \
            tmp[chans_table[j]] = buf[j]; \
        memcpy( buf, tmp, sizeof (type) * channels ); \
        buf += channels; \
    } \
} while(0)

    if( likely(channels <= AOUT_CHAN_MAX) )
    {
        switch( fourcc )
        {
            case VLC_CODEC_U8:   REORDER_TYPE(uint8_t); return;
            case VLC_CODEC...",1,33,audio_output\common.c,aout_ChannelReorder,,false,301,355,aout_ChannelReorder,,,7,"void aout_ChannelReorder (void*,size_t,uint8_t,uint8_t*,vlc_fourcc_t)"
3630,METHOD,audio_output\common.c:<global>,TYPE_DECL,"void aout_Interleave( void *restrict dst, const void *const *srcv,
                      unsigned samples, unsigned chans, vlc_fourcc_t fourcc )
{
#define INTERLEAVE_TYPE(type) \
do { \
    type *d = dst; \
    for( size_t i = 0; i < chans; i++ ) { \
        const type *s = srcv[i]; \
        for( size_t j = 0, k = 0; j < samples; j++, k += chans ) \
            d[k] = *(s++); \
        d++; \
    } \
} while(0)

    switch( fourcc )
    {
        case VLC_CODEC_U8:   INTERLEAVE_TYPE(uint8_t);  break;
        case VLC_CODEC_S16N: INTERLEAVE_TYPE(int16_t);  break;
        case VLC_CODEC_FL32: INTERLEAVE_TYPE(float);    break;
        case VLC_CODEC_S32N: INTERLEAVE_TYPE(int32_t);  break;
        case VLC_CODEC_FL64: INTERLEAVE_TYPE(double);   break;
        default:             vlc_assert_unreachable();
    }
#undef INTERLEAVE_TYPE
}",1,29,audio_output\common.c,aout_Interleave,,false,367,391,aout_Interleave,,,8,"void aout_Interleave (void*,void**,unsigned,unsigned,vlc_fourcc_t)"
3944,METHOD,audio_output\common.c:<global>,TYPE_DECL,"void aout_Deinterleave( void *restrict dst, const void *restrict src,
                      unsigned samples, unsigned chans, vlc_fourcc_t fourcc )
{
#define DEINTERLEAVE_TYPE(type) \
do { \
    type *d = dst; \
    const type *s = src; \
    for( size_t i = 0; i < chans; i++ ) { \
        for( size_t j = 0, k = 0; j < samples; j++, k += chans ) \
            *(d++) = s[k]; \
        s++; \
    } \
} while(0)

    switch( fourcc )
    {
        case VLC_CODEC_U8:   DEINTERLEAVE_TYPE(uint8_t);  break;
        case VLC_CODEC_S16N: DEINTERLEAVE_TYPE(int16_t);  break;
        case VLC_CODEC_FL32: DEINTERLEAVE_TYPE(float);    break;
        case VLC_CODEC_S32N: DEINTERLEAVE_TYPE(int32_t);  break;
        case VLC_CODEC_FL64: DEINTERLEAVE_TYPE(double);   break;
        default:             vlc_assert_unreachable();
    }
#undef DEINTERLEAVE_TYPE
}",1,29,audio_output\common.c,aout_Deinterleave,,false,403,427,aout_Deinterleave,,,9,"void aout_Deinterleave (void*,void*,unsigned,unsigned,vlc_fourcc_t)"
4248,METHOD,audio_output\common.c:<global>,TYPE_DECL,"static inline void ExtractChannel( uint8_t *pi_dst, int i_dst_channels,
                                   const uint8_t *pi_src, int i_src_channels,
                                   int i_sample_count,
                                   const int *pi_selection, int i_bytes )
{
    for( int i = 0; i < i_sample_count; i++ )
    {
        for( int j = 0; j < i_dst_channels; j++ )
            memcpy( &pi_dst[j * i_bytes], &pi_src[pi_selection[j] * i_bytes], i_bytes );
        pi_dst += i_dst_channels * i_bytes;
        pi_src += i_src_channels * i_bytes;
    }
}",1,1,audio_output\common.c,ExtractChannel,,false,432,444,ExtractChannel,,,10,"void ExtractChannel (uint8_t*,int,uint8_t*,int,int,int*,int)"
4308,METHOD,audio_output\common.c:<global>,TYPE_DECL,"void aout_ChannelExtract( void *p_dst, int i_dst_channels,
                          const void *p_src, int i_src_channels,
                          int i_sample_count, const int *pi_selection, int i_bits_per_sample )
{
    /* It does not work in place */
    assert( p_dst != p_src );

    /* Force the compiler to inline for the specific cases so it can optimize */
    if( i_bits_per_sample == 8 )
        ExtractChannel( p_dst, i_dst_channels, p_src, i_src_channels, i_sample_count, pi_selection, 1 );
    else  if( i_bits_per_sample == 16 )
        ExtractChannel( p_dst, i_dst_channels, p_src, i_src_channels, i_sample_count, pi_selection, 2 );
    else  if( i_bits_per_sample == 32 )
        ExtractChannel( p_dst, i_dst_channels, p_src, i_src_channels, i_sample_count, pi_selection, 4 );
    else  if( i_bits_per_sample == 64 )
        ExtractChannel( p_dst, i_dst_channels, p_src, i_src_channels, i_sample_count, pi_selection, 8 );
}",1,1,audio_output\common.c,aout_ChannelExtract,,false,446,462,aout_ChannelExtract,,,11,"void aout_ChannelExtract (void*,int,void*,int,int,int*,int)"
4381,METHOD,audio_output\common.c:<global>,TYPE_DECL,"bool aout_CheckChannelExtraction( int *pi_selection,
                                  uint32_t *pi_layout, int *pi_channels,
                                  const uint32_t pi_order_dst[AOUT_CHAN_MAX],
                                  const uint32_t *pi_order_src, int i_channels )
{
    static_assert(AOUT_CHAN_MAX <= (sizeof (*pi_order_dst) * CHAR_BIT),
                  ""Missing bits"");

    uint32_t i_layout = 0;
    int i_out = 0;
    int pi_index[AOUT_CHAN_MAX];

    /* */
    if( !pi_order_dst )
        pi_order_dst = pi_vlc_chan_order_wg4;

    /* */
    for( int i = 0; i < i_channels; i++ )
    {
        /* Ignore unknown or duplicated channels or not present in output */
        if( !pi_order_src[i] || (i_layout & pi_order_src[i]) )
            continue;

        for( int j = 0; j < AOUT_CHAN_MAX; j++ )
        {
            if( pi_order_dst[j] == pi_order_src[i] )
            {
                assert( i_out < AOUT_CHAN_MAX );
                pi_index[i_out++] = i;
      ...",1,1,audio_output\common.c,aout_CheckChannelExtraction,,false,464,521,aout_CheckChannelExtraction,,,12,"bool aout_CheckChannelExtraction (int*,uint32_t*,int*,uint32_t[AOUT_CHAN_MAX],uint32_t*,int)"
4559,METHOD,audio_output\common.c:<global>,TYPE_DECL,"static int FilterOrder( const char *psz_name )
{
    static const struct {
        const char psz_name[10];
        int        i_order;
    } filter[] = {
        { ""equalizer"",  0 },
    };
    for( unsigned i = 0; i < ARRAY_SIZE(filter); i++ )
    {
        if( !strcmp( filter[i].psz_name, psz_name ) )
            return filter[i].i_order;
    }
    return INT_MAX;
}",1,1,audio_output\common.c,FilterOrder,,false,524,538,FilterOrder,,,13,int FilterOrder (char*)
4602,METHOD,audio_output\common.c:<global>,TYPE_DECL,"bool aout_ChangeFilterString( vlc_object_t *p_obj, vlc_object_t *p_aout,
                              const char *psz_variable,
                              const char *psz_name, bool b_add )
{
    if( *psz_name == '\0' )
        return false;

    char *psz_list;
    if( p_aout )
    {
        psz_list = var_GetString( p_aout, psz_variable );
    }
    else
    {
        psz_list = var_InheritString( p_obj, psz_variable );
    }

    /* Split the string into an array of filters */
    int i_count = 1;
    for( char *p = psz_list; p && *p; p++ )
        i_count += *p == ':';
    i_count += b_add;

    const char **ppsz_filter = calloc( i_count, sizeof(*ppsz_filter) );
    if( !ppsz_filter )
    {
        free( psz_list );
        return false;
    }
    bool b_present = false;
    i_count = 0;
    for( char *p = psz_list; p && *p; )
    {
        char *psz_end = strchr(p, ':');
        if( psz_end )
            *psz_end++ = '\0';
        else
            psz_end = p + strlen(p);
 ...",1,1,audio_output\common.c,aout_ChangeFilterString,,false,543,648,aout_ChangeFilterString,,,14,"bool aout_ChangeFilterString (vlc_object_t*,vlc_object_t*,char*,char*,bool)"
4946,METHOD,audio_output\dec.c:<global>,TYPE_DECL,<global>,1,1,audio_output\dec.c,audio_output\dec.c:<global>,,false,1,479,<global>,,,1,
4948,METHOD,audio_output\dec.c:<global>,TYPE_DECL,"int aout_DecNew( audio_output_t *p_aout,
                 const audio_sample_format_t *p_format,
                 const audio_replay_gain_t *p_replay_gain,
                 const aout_request_vout_t *p_request_vout )
{
    if( p_format->i_bitspersample > 0 )
    {
        /* Sanitize audio format, input need to have a valid physical channels
         * layout or a valid number of channels. */
        int i_map_channels = aout_FormatNbChannels( p_format );
        if( ( i_map_channels == 0 && p_format->i_channels == 0 )
           || i_map_channels > AOUT_CHAN_MAX || p_format->i_channels > INPUT_CHAN_MAX )
        {
            msg_Err( p_aout, ""invalid audio channels count"" );
            return -1;
        }
    }

    if( p_format->i_rate > 384000 )
    {
        msg_Err( p_aout, ""excessive audio sample frequency (%u)"",
                 p_format->i_rate );
        return -1;
    }
    if( p_format->i_rate < 4000 )
    {
        msg_Err( p_aout, ""too low audio sample frequency (%u)...",1,20,audio_output\dec.c,aout_DecNew,,false,43,119,aout_DecNew,,,1,"int aout_DecNew (audio_output_t*,audio_sample_format_t*,audio_replay_gain_t*,aout_request_vout_t*)"
5201,METHOD,audio_output\dec.c:<global>,TYPE_DECL,"void aout_DecDelete (audio_output_t *aout)
{
    aout_owner_t *owner = aout_owner (aout);

    aout_OutputLock (aout);
    if (owner->mixer_format.i_format)
    {
        aout_FiltersDelete (aout, owner->filters);
        aout_OutputDelete (aout);
    }
    aout_volume_Delete (owner->volume);
    owner->volume = NULL;
    aout_OutputUnlock (aout);
}",1,1,audio_output\dec.c,aout_DecDelete,,false,124,137,aout_DecDelete,,,2,void aout_DecDelete (audio_output_t*)
5238,METHOD,audio_output\dec.c:<global>,TYPE_DECL,"static int aout_CheckReady (audio_output_t *aout)
{
    aout_owner_t *owner = aout_owner (aout);

    int status = AOUT_DEC_SUCCESS;
    int restart = atomic_exchange (&owner->restart, 0);
    if (unlikely(restart))
    {
        if (owner->mixer_format.i_format)
            aout_FiltersDelete (aout, owner->filters);

        if (restart & AOUT_RESTART_OUTPUT)
        {   /* Reinitializes the output */
            msg_Dbg (aout, ""restarting output..."");
            if (owner->mixer_format.i_format)
                aout_OutputDelete (aout);
            owner->mixer_format = owner->input_format;
            owner->filters_cfg = AOUT_FILTERS_CFG_INIT;
            if (aout_OutputNew (aout, &owner->mixer_format, &owner->filters_cfg))
                owner->mixer_format.i_format = 0;
            aout_volume_SetFormat (owner->volume,
                                   owner->mixer_format.i_format);

            /* Notify the decoder that the aout changed in order to try a new
             ...",1,17,audio_output\dec.c,aout_CheckReady,,false,139,191,aout_CheckReady,,,3,int aout_CheckReady (audio_output_t*)
5419,METHOD,audio_output\dec.c:<global>,TYPE_DECL,"void aout_RequestRestart (audio_output_t *aout, unsigned mode)
{
    aout_owner_t *owner = aout_owner (aout);
    atomic_fetch_or (&owner->restart, mode);
    msg_Dbg (aout, ""restart requested (%u)"", mode);
}",1,1,audio_output\dec.c,aout_RequestRestart,,false,197,202,aout_RequestRestart,,,4,"void aout_RequestRestart (audio_output_t*,unsigned)"
5440,METHOD,audio_output\dec.c:<global>,TYPE_DECL,"static void aout_StopResampling (audio_output_t *aout)
{
    aout_owner_t *owner = aout_owner (aout);

    owner->sync.resamp_type = AOUT_RESAMPLING_NONE;
    aout_FiltersAdjustResampling (owner->filters, 0);
}",1,1,audio_output\dec.c,aout_StopResampling,,false,208,214,aout_StopResampling,,,5,void aout_StopResampling (audio_output_t*)
5462,METHOD,audio_output\dec.c:<global>,TYPE_DECL,"static void aout_DecSilence (audio_output_t *aout, mtime_t length, mtime_t pts)
{
    aout_owner_t *owner = aout_owner (aout);
    const audio_sample_format_t *fmt = &owner->mixer_format;
    size_t frames = (fmt->i_rate * length) / CLOCK_FREQ;

    block_t *block = block_Alloc (frames * fmt->i_bytes_per_frame
                                  / fmt->i_frame_length);
    if (unlikely(block == NULL))
        return; /* uho! */

    msg_Dbg (aout, ""inserting %zu zeroes"", frames);
    memset (block->p_buffer, 0, block->i_buffer);
    block->i_nb_samples = frames;
    block->i_pts = pts;
    block->i_dts = pts;
    block->i_length = length;
    aout_OutputPlay (aout, block);
}",1,1,audio_output\dec.c,aout_DecSilence,,false,216,234,aout_DecSilence,,,6,"void aout_DecSilence (audio_output_t*,mtime_t,mtime_t)"
5546,METHOD,audio_output\dec.c:<global>,TYPE_DECL,"static void aout_DecSynchronize (audio_output_t *aout, mtime_t dec_pts,
                                 int input_rate)
{
    aout_owner_t *owner = aout_owner (aout);
    mtime_t drift;

    /**
     * Depending on the drift between the actual and intended playback times,
     * the audio core may ignore the drift, trigger upsampling or downsampling,
     * insert silence or even discard samples.
     * Future VLC versions may instead adjust the input rate.
     *
     * The audio output plugin is responsible for estimating its actual
     * playback time, or rather the estimated time when the next sample will
     * be played. (The actual playback time is always the current time, that is
     * to say mdate(). It is not an useful statistic.)
     *
     * Most audio output plugins can estimate the delay until playback of
     * the next sample to be written to the buffer, or equally the time until
     * all samples in the buffer will have been played. Then:
     *    pts = mdate(...",1,1,audio_output\dec.c,aout_DecSynchronize,,false,236,352,aout_DecSynchronize,,,7,"void aout_DecSynchronize (audio_output_t*,mtime_t,int)"
5805,METHOD,audio_output\dec.c:<global>,TYPE_DECL,"int aout_DecPlay (audio_output_t *aout, block_t *block, int input_rate)
{
    aout_owner_t *owner = aout_owner (aout);

    assert (input_rate >= INPUT_RATE_DEFAULT / AOUT_MAX_INPUT_RATE);
    assert (input_rate <= INPUT_RATE_DEFAULT * AOUT_MAX_INPUT_RATE);
    assert (block->i_pts >= VLC_TS_0);

    block->i_length = CLOCK_FREQ * block->i_nb_samples
                                 / owner->input_format.i_rate;

    aout_OutputLock (aout);
    int ret = aout_CheckReady (aout);
    if (unlikely(ret == AOUT_DEC_FAILED))
        goto drop; /* Pipeline is unrecoverably broken :-( */

    const mtime_t now = mdate (), advance = block->i_pts - now;
    if (advance < -AOUT_MAX_PTS_DELAY)
    {   /* Late buffer can be caused by bugs in the decoder, by scheduling
         * latency spikes (excessive load, SIGSTOP, etc.) or if buffering is
         * insufficient. We assume the PTS is wrong and play the buffer anyway:
         * Hopefully video has encountered a similar PTS problem as audio....",1,47,audio_output\dec.c,aout_DecPlay,,false,357,421,aout_DecPlay,,,8,"int aout_DecPlay (audio_output_t*,block_t*,int)"
6024,METHOD,audio_output\dec.c:<global>,TYPE_DECL,"void aout_DecGetResetStats(audio_output_t *aout, unsigned *restrict lost,
                           unsigned *restrict played)
{
    aout_owner_t *owner = aout_owner (aout);

    *lost = atomic_exchange(&owner->buffers_lost, 0);
    *played = atomic_exchange(&owner->buffers_played, 0);
}",1,1,audio_output\dec.c,aout_DecGetResetStats,,false,423,430,aout_DecGetResetStats,,,9,"void aout_DecGetResetStats (audio_output_t*,unsigned*,unsigned*)"
6054,METHOD,audio_output\dec.c:<global>,TYPE_DECL,"void aout_DecChangePause (audio_output_t *aout, bool paused, mtime_t date)
{
    aout_owner_t *owner = aout_owner (aout);

    aout_OutputLock (aout);
    if (owner->sync.end != VLC_TS_INVALID)
    {
        if (paused)
            owner->sync.end -= date;
        else
            owner->sync.end += date;
    }
    if (owner->mixer_format.i_format)
        aout_OutputPause (aout, paused, date);
    aout_OutputUnlock (aout);
}",1,1,audio_output\dec.c,aout_DecChangePause,,false,432,447,aout_DecChangePause,,,10,"void aout_DecChangePause (audio_output_t*,bool,mtime_t)"
6109,METHOD,audio_output\dec.c:<global>,TYPE_DECL,"void aout_DecFlush (audio_output_t *aout, bool wait)
{
    aout_owner_t *owner = aout_owner (aout);

    aout_OutputLock (aout);
    owner->sync.end = VLC_TS_INVALID;
    if (owner->mixer_format.i_format)
    {
        if (wait)
        {
            block_t *block = aout_FiltersDrain (owner->filters);
            if (block)
                aout_OutputPlay (aout, block);
        }
        else
            aout_FiltersFlush (owner->filters);
        aout_OutputFlush (aout, wait);
    }
    aout_OutputUnlock (aout);
}",1,1,audio_output\dec.c,aout_DecFlush,,false,449,468,aout_DecFlush,,,11,"void aout_DecFlush (audio_output_t*,bool)"
6163,METHOD,audio_output\dec.c:<global>,TYPE_DECL,"void aout_ChangeViewpoint(audio_output_t *aout,
                          const vlc_viewpoint_t *p_viewpoint)
{
    aout_owner_t *owner = aout_owner (aout);

    vlc_mutex_lock (&owner->vp.lock);
    owner->vp.value = *p_viewpoint;
    atomic_store(&owner->vp.update, true);
    vlc_mutex_unlock (&owner->vp.lock);
}",1,1,audio_output\dec.c,aout_ChangeViewpoint,,false,470,479,aout_ChangeViewpoint,,,12,"void aout_ChangeViewpoint (audio_output_t*,vlc_viewpoint_t*)"
6231,METHOD,audio_output\filters.c:<global>,TYPE_DECL,<global>,1,20,audio_output\filters.c,audio_output\filters.c:<global>,,false,1,781,<global>,,,1,
6233,METHOD,audio_output\filters.c:<global>,TYPE_DECL,"static filter_t *CreateFilter (vlc_object_t *obj, const char *type,
                               const char *name, filter_owner_sys_t *owner,
                               const audio_sample_format_t *infmt,
                               const audio_sample_format_t *outfmt,
                               config_chain_t *cfg, bool const_fmt)
{
    filter_t *filter = vlc_custom_create (obj, sizeof (*filter), type);
    if (unlikely(filter == NULL))
        return NULL;

    filter->owner.sys = owner;
    filter->p_cfg = cfg;
    filter->fmt_in.audio = *infmt;
    filter->fmt_in.i_codec = infmt->i_format;
    filter->fmt_out.audio = *outfmt;
    filter->fmt_out.i_codec = outfmt->i_format;

#ifndef NDEBUG
    /* Assure that infmt/oufmt are well prepared and that channels
     * configurations are valid*/
    if( infmt->i_physical_channels != 0 )
        assert( aout_FormatNbChannels( infmt ) == infmt->i_channels );
    if( outfmt->i_physical_channels != 0 )
        assert( aout_Form...",1,1,audio_output\filters.c,CreateFilter,,false,45,90,CreateFilter,,,1,"filter_t CreateFilter (vlc_object_t*,char*,char*,filter_owner_sys_t*,audio_sample_format_t*,audio_sample_format_t*,config_chain_t*,bool)"
6394,METHOD,audio_output\filters.c:<global>,TYPE_DECL,"static filter_t *FindConverter (vlc_object_t *obj,
                                const audio_sample_format_t *infmt,
                                const audio_sample_format_t *outfmt)
{
    return CreateFilter (obj, ""audio converter"", NULL, NULL, infmt, outfmt,
                         NULL, true);
}",1,1,audio_output\filters.c,FindConverter,,false,92,98,FindConverter,,,2,"filter_t FindConverter (vlc_object_t*,audio_sample_format_t*,audio_sample_format_t*)"
6411,METHOD,audio_output\filters.c:<global>,TYPE_DECL,"static filter_t *FindResampler (vlc_object_t *obj,
                                const audio_sample_format_t *infmt,
                                const audio_sample_format_t *outfmt)
{
    return CreateFilter (obj, ""audio resampler"", ""$audio-resampler"", NULL,
                         infmt, outfmt, NULL, true);
}",1,1,audio_output\filters.c,FindResampler,,false,100,106,FindResampler,,,3,"filter_t FindResampler (vlc_object_t*,audio_sample_format_t*,audio_sample_format_t*)"
6428,METHOD,audio_output\filters.c:<global>,TYPE_DECL,"static void aout_FiltersPipelineDestroy(filter_t *const *filters, unsigned n)
{
    for( unsigned i = 0; i < n; i++ )
    {
        filter_t *p_filter = filters[i];

        module_unneed( p_filter, p_filter->p_module );
        vlc_object_release( p_filter );
    }
}",1,1,audio_output\filters.c,aout_FiltersPipelineDestroy,,false,111,120,aout_FiltersPipelineDestroy,,,4,"void aout_FiltersPipelineDestroy (filter_t**,unsigned)"
6459,METHOD,audio_output\filters.c:<global>,TYPE_DECL,"static filter_t *TryFormat (vlc_object_t *obj, vlc_fourcc_t codec,
                            audio_sample_format_t *restrict fmt)
{
    audio_sample_format_t output = *fmt;

    assert (codec != fmt->i_format);
    output.i_format = codec;
    aout_FormatPrepare (&output);

    filter_t *filter = FindConverter (obj, fmt, &output);
    if (filter != NULL)
        *fmt = output;
    return filter;
}",1,1,audio_output\filters.c,TryFormat,,false,122,135,TryFormat,,,5,"filter_t TryFormat (vlc_object_t*,vlc_fourcc_t,audio_sample_format_t*)"
6504,METHOD,audio_output\filters.c:<global>,TYPE_DECL,"static int aout_FiltersPipelineCreate(vlc_object_t *obj, filter_t **filters,
                                      unsigned *count, unsigned max,
                                 const audio_sample_format_t *restrict infmt,
                                 const audio_sample_format_t *restrict outfmt,
                                 bool headphones)
{
    aout_FormatsPrint (obj, ""conversion:"", infmt, outfmt);
    max -= *count;
    filters += *count;

    /* There is a lot of second guessing on what the conversion plugins can
     * and cannot do. This seems hardly avoidable, the conversion problem need
     * to be reduced somehow. */
    audio_sample_format_t input = *infmt;
    unsigned n = 0;

    if (!AOUT_FMT_LINEAR(&input))
    {
        msg_Err(obj, ""Can't convert non linear input"");
        return -1;
    }

    /* Remix channels */
    if (infmt->i_physical_channels != outfmt->i_physical_channels
     || infmt->i_chan_mode != outfmt->i_chan_mode
     || infmt->channel_typ...",1,4,audio_output\filters.c,aout_FiltersPipelineCreate,,false,147,272,aout_FiltersPipelineCreate,,,6,"int aout_FiltersPipelineCreate (vlc_object_t*,filter_t**,unsigned*,unsigned,audio_sample_format_t*,audio_sample_format_t*,bool)"
6848,METHOD,audio_output\filters.c:<global>,TYPE_DECL,"static block_t *aout_FiltersPipelinePlay(filter_t *const *filters,
                                         unsigned count, block_t *block)
{
    /* TODO: use filter chain */
    for (unsigned i = 0; (i < count) && (block != NULL); i++)
    {
        filter_t *filter = filters[i];

        /* Please note that p_block->i_nb_samples & i_buffer
         * shall be set by the filter plug-in. */
        block = filter->pf_audio_filter (filter, block);
    }
    return block;
}",1,1,audio_output\filters.c,aout_FiltersPipelinePlay,,false,277,290,aout_FiltersPipelinePlay,,,7,"block_t aout_FiltersPipelinePlay (filter_t**,unsigned,block_t*)"
6887,METHOD,audio_output\filters.c:<global>,TYPE_DECL,"static block_t *aout_FiltersPipelineDrain(filter_t *const *filters,
                                          unsigned count)
{
    block_t *chain = NULL;

    for (unsigned i = 0; i < count; i++)
    {
        filter_t *filter = filters[i];

        block_t *block = filter_DrainAudio (filter);
        if (block)
        {
            /* If there is a drained block, filter it through the following
             * chain of filters  */
            if (i + 1 < count)
                block = aout_FiltersPipelinePlay (&filters[i + 1],
                                                  count - i - 1, block);
            if (block)
                block_ChainAppend (&chain, block);
        }
    }

    if (chain)
        return block_ChainGather(chain);
    else
        return NULL;
}",1,1,audio_output\filters.c,aout_FiltersPipelineDrain,,false,296,322,aout_FiltersPipelineDrain,,,8,"block_t aout_FiltersPipelineDrain (filter_t**,unsigned)"
6962,METHOD,audio_output\filters.c:<global>,TYPE_DECL,"static void aout_FiltersPipelineFlush(filter_t *const *filters,
                                      unsigned count)
{
    for (unsigned i = 0; i < count; i++)
        filter_Flush (filters[i]);
}",1,1,audio_output\filters.c,aout_FiltersPipelineFlush,,false,327,332,aout_FiltersPipelineFlush,,,9,"void aout_FiltersPipelineFlush (filter_t**,unsigned)"
6983,METHOD,audio_output\filters.c:<global>,TYPE_DECL,"static void aout_FiltersPipelineChangeViewpoint(filter_t *const *filters,
                                                unsigned count,
                                                const vlc_viewpoint_t *vp)
{
    for (unsigned i = 0; i < count; i++)
        filter_ChangeViewpoint (filters[i], vp);
}",1,1,audio_output\filters.c,aout_FiltersPipelineChangeViewpoint,,false,334,340,aout_FiltersPipelineChangeViewpoint,,,10,"void aout_FiltersPipelineChangeViewpoint (filter_t**,unsigned,vlc_viewpoint_t*)"
7012,METHOD,<empty>,<empty>,<empty>,1,,audio_output\filters.c,aout_filters:<clinit>,,false,344,,<clinit>,,,6,
7020,METHOD,audio_output\filters.c:<global>,TYPE_DECL,"static int VisualizationCallback (vlc_object_t *obj, const char *var,
                                  vlc_value_t oldval, vlc_value_t newval,
                                  void *data)
{
    const char *mode = newval.psz_string;

    if (!*mode)
        mode = ""none"";
    /* FIXME: This ugly hack enforced by visual effect-list, as is the need for
     * separate ""visual"" (external) and ""audio-visual"" (internal) variables...
     * The visual plugin should have one submodule per effect instead. */
    if (strcasecmp (mode, ""none"") && strcasecmp (mode, ""goom"")
     && strcasecmp (mode, ""projectm"") && strcasecmp (mode, ""vsxu"")
     && strcasecmp (mode, ""glspectrum""))
    {
        var_Create (obj, ""effect-list"", VLC_VAR_STRING);
        var_SetString (obj, ""effect-list"", mode);
        mode = ""visual"";
    }

    var_SetString (obj, ""audio-visual"", mode);
    aout_InputRequestRestart ((audio_output_t *)obj);
    (void) var; (void) oldval; (void) data;
    return VLC_SUCCESS;
}",1,1,audio_output\filters.c,VisualizationCallback,,false,357,381,VisualizationCallback,,,12,"int VisualizationCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
7094,METHOD,audio_output\filters.c:<global>,TYPE_DECL,"vout_thread_t *aout_filter_RequestVout (filter_t *filter, vout_thread_t *vout,
                                        const video_format_t *fmt)
{
    /* NOTE: This only works from aout_filters_t.
     * If you want to use visualization filters from another place, you will
     * need to add a new pf_aout_request_vout callback or store a pointer
     * to aout_request_vout_t inside filter_t (i.e. a level of indirection). */
    const aout_request_vout_t *req = filter->owner.sys;
    char *visual = var_InheritString (filter->obj.parent, ""audio-visual"");
    /* NOTE: Disable recycling to always close the filter vout because OpenGL
     * visualizations do not use this function to ask for a context. */
    bool recycle = false;
    free (visual);

    return req->pf_request_vout (req->p_private, vout, fmt, recycle);
}",1,1,audio_output\filters.c,aout_filter_RequestVout,,false,383,398,aout_filter_RequestVout,,,13,"vout_thread_t aout_filter_RequestVout (filter_t*,vout_thread_t*,video_format_t*)"
7136,METHOD,audio_output\filters.c:<global>,TYPE_DECL,"static int AppendFilter(vlc_object_t *obj, const char *type, const char *name,
                        aout_filters_t *restrict filters, const void *owner,
                        audio_sample_format_t *restrict infmt,
                        const audio_sample_format_t *restrict outfmt,
                        config_chain_t *cfg)
{
    const unsigned max = sizeof (filters->tab) / sizeof (filters->tab[0]);
    if (filters->count >= max)
    {
        msg_Err (obj, ""maximum of %u filters reached"", max);
        return -1;
    }

    filter_t *filter = CreateFilter (obj, type, name,
                                     (void *)owner, infmt, outfmt, cfg, false);
    if (filter == NULL)
    {
        msg_Err (obj, ""cannot add user %s \""%s\"" (skipped)"", type, name);
        return -1;
    }

    /* convert to the filter input format if necessary */
    if (aout_FiltersPipelineCreate (obj, filters->tab, &filters->count,
                                    max - 1, infmt, &filter->fmt_in....",1,1,audio_output\filters.c,AppendFilter,,false,400,436,AppendFilter,,,14,"int AppendFilter (vlc_object_t*,char*,char*,aout_filters_t*,void*,audio_sample_format_t*,audio_sample_format_t*,config_chain_t*)"
7269,METHOD,audio_output\filters.c:<global>,TYPE_DECL,"static int AppendRemapFilter(vlc_object_t *obj, aout_filters_t *restrict filters,
                             audio_sample_format_t *restrict infmt,
                             const audio_sample_format_t *restrict outfmt,
                             const int *wg4_remap)
{
    char *name;
    config_chain_t *cfg;

    /* The remap audio filter use a different order than wg4 */
    static const uint8_t wg4_to_remap[] = { 0, 2, 6, 7, 3, 5, 4, 1, 8 };
    int remap[AOUT_CHAN_MAX];
    bool needed = false;
    for (int i = 0; i < AOUT_CHAN_MAX; ++i)
    {
        if (wg4_remap[i] != i)
            needed = true;
        remap[i] = wg4_remap[i] >= 0 ? wg4_to_remap[wg4_remap[i]] : -1;
    }
    if (!needed)
        return 0;

    char *str;
    int ret = asprintf(&str, ""remap{channel-left=%d,channel-right=%d,""
                       ""channel-middleleft=%d,channel-middleright=%d,""
                       ""channel-rearleft=%d,channel-rearright=%d,""
                       ""channel-rearcen...",1,1,audio_output\filters.c,AppendRemapFilter,,false,438,482,AppendRemapFilter,,,15,"int AppendRemapFilter (vlc_object_t*,aout_filters_t*,audio_sample_format_t*,audio_sample_format_t*,int*)"
7431,METHOD,audio_output\filters.c:<global>,TYPE_DECL,"aout_filters_t *aout_FiltersNew (vlc_object_t *obj,
                                 const audio_sample_format_t *restrict infmt,
                                 const audio_sample_format_t *restrict outfmt,
                                 const aout_request_vout_t *request_vout,
                                 const aout_filters_cfg_t *cfg)
{
    aout_filters_t *filters = malloc (sizeof (*filters));
    if (unlikely(filters == NULL))
        return NULL;

    filters->rate_filter = NULL;
    filters->resampler = NULL;
    filters->resampling = 0;
    filters->count = 0;

    /* Prepare format structure */
    aout_FormatPrint (obj, ""input"", infmt);
    audio_sample_format_t input_format = *infmt;
    audio_sample_format_t output_format = *outfmt;

    /* Callbacks (before reading values and also before return statement) */
    if (request_vout != NULL)
        var_AddCallback (obj, ""visual"", VisualizationCallback, NULL);

    if (!AOUT_FMT_LINEAR(outfmt))
    {   /* Non-linear o...",1,12,audio_output\filters.c,aout_FiltersNew,,false,500,661,aout_FiltersNew,,,16,"aout_filters_t aout_FiltersNew (vlc_object_t*,audio_sample_format_t*,audio_sample_format_t*,aout_request_vout_t*,aout_filters_cfg_t*)"
7934,METHOD,audio_output\filters.c:<global>,TYPE_DECL,"void aout_FiltersDelete (vlc_object_t *obj, aout_filters_t *filters)
{
    if (filters->resampler != NULL)
        aout_FiltersPipelineDestroy (&filters->resampler, 1);
    aout_FiltersPipelineDestroy (filters->tab, filters->count);
    if (obj != NULL)
        var_DelCallback (obj, ""visual"", VisualizationCallback, NULL);
    free (filters);
}",1,1,audio_output\filters.c,aout_FiltersDelete,,false,672,680,aout_FiltersDelete,,,17,"void aout_FiltersDelete (vlc_object_t*,aout_filters_t*)"
7972,METHOD,audio_output\filters.c:<global>,TYPE_DECL,"bool aout_FiltersCanResample (aout_filters_t *filters)
{
    return (filters->resampler != NULL);
}",1,1,audio_output\filters.c,aout_FiltersCanResample,,false,682,685,aout_FiltersCanResample,,,18,bool aout_FiltersCanResample (aout_filters_t*)
7983,METHOD,audio_output\filters.c:<global>,TYPE_DECL,"bool aout_FiltersAdjustResampling (aout_filters_t *filters, int adjust)
{
    if (filters->resampler == NULL)
        return false;

    if (adjust)
        filters->resampling += adjust;
    else
        filters->resampling = 0;
    return filters->resampling != 0;
}",1,1,audio_output\filters.c,aout_FiltersAdjustResampling,,false,687,697,aout_FiltersAdjustResampling,,,19,"bool aout_FiltersAdjustResampling (aout_filters_t*,int)"
8019,METHOD,audio_output\filters.c:<global>,TYPE_DECL,"block_t *aout_FiltersPlay (aout_filters_t *filters, block_t *block, int rate)
{
    int nominal_rate = 0;

    if (rate != INPUT_RATE_DEFAULT)
    {
        filter_t *rate_filter = filters->rate_filter;

        if (rate_filter == NULL)
            goto drop; /* Without linear, non-nominal rate is impossible. */

        /* Override input rate */
        nominal_rate = rate_filter->fmt_in.audio.i_rate;
        rate_filter->fmt_in.audio.i_rate =
            (nominal_rate * INPUT_RATE_DEFAULT) / rate;
    }

    block = aout_FiltersPipelinePlay (filters->tab, filters->count, block);
    if (filters->resampler != NULL)
    {   /* NOTE: the resampler needs to run even if resampling is 0.
         * The decoder and output rates can still be different. */
        filters->resampler->fmt_in.audio.i_rate += filters->resampling;
        block = aout_FiltersPipelinePlay (&filters->resampler, 1, block);
        filters->resampler->fmt_in.audio.i_rate -= filters->resampling;
    }

    if (nomi...",1,1,audio_output\filters.c,aout_FiltersPlay,,false,699,735,aout_FiltersPlay,,,20,"block_t aout_FiltersPlay (aout_filters_t*,block_t*,int)"
8150,METHOD,audio_output\filters.c:<global>,TYPE_DECL,"block_t *aout_FiltersDrain (aout_filters_t *filters)
{
    /* Drain the filters pipeline */
    block_t *block = aout_FiltersPipelineDrain (filters->tab, filters->count);

    if (filters->resampler != NULL)
    {
        block_t *chain = NULL;

        filters->resampler->fmt_in.audio.i_rate += filters->resampling;

        if (block)
        {
            /* Resample the drained block from the filters pipeline */
            block = aout_FiltersPipelinePlay (&filters->resampler, 1, block);
            if (block)
                block_ChainAppend (&chain, block);
        }

        /* Drain the resampler filter */
        block = aout_FiltersPipelineDrain (&filters->resampler, 1);
        if (block)
            block_ChainAppend (&chain, block);

        filters->resampler->fmt_in.audio.i_rate -= filters->resampling;

        return chain ? block_ChainGather (chain) : NULL;
    }
    else
        return block;
}",1,1,audio_output\filters.c,aout_FiltersDrain,,false,737,767,aout_FiltersDrain,,,21,block_t aout_FiltersDrain (aout_filters_t*)
8246,METHOD,audio_output\filters.c:<global>,TYPE_DECL,"void aout_FiltersFlush (aout_filters_t *filters)
{
    aout_FiltersPipelineFlush (filters->tab, filters->count);

    if (filters->resampler != NULL)
        aout_FiltersPipelineFlush (&filters->resampler, 1);
}",1,1,audio_output\filters.c,aout_FiltersFlush,,false,769,775,aout_FiltersFlush,,,22,void aout_FiltersFlush (aout_filters_t*)
8271,METHOD,audio_output\filters.c:<global>,TYPE_DECL,"void aout_FiltersChangeViewpoint (aout_filters_t *filters,
                                  const vlc_viewpoint_t *vp)
{
    aout_FiltersPipelineChangeViewpoint (filters->tab, filters->count, vp);
}",1,1,audio_output\filters.c,aout_FiltersChangeViewpoint,,false,777,781,aout_FiltersChangeViewpoint,,,23,"void aout_FiltersChangeViewpoint (aout_filters_t*,vlc_viewpoint_t*)"
8304,METHOD,audio_output\output.c:<global>,TYPE_DECL,<global>,1,1,audio_output\output.c,audio_output\output.c:<global>,,false,1,900,<global>,,,1,
8314,METHOD,<empty>,<empty>,<empty>,1,,audio_output\output.c,aout_dev:<clinit>,,false,40,,<clinit>,,,4,
8320,METHOD,audio_output\output.c:<global>,TYPE_DECL,"static void aout_OutputAssertLocked (audio_output_t *aout)
{
    aout_owner_t *owner = aout_owner (aout);

    vlc_assert_locked (&owner->lock);
}",1,4,audio_output\output.c,aout_OutputAssertLocked,,false,49,54,aout_OutputAssertLocked,,,4,void aout_OutputAssertLocked (audio_output_t*)
8342,METHOD,audio_output\output.c:<global>,TYPE_DECL,static void aout_Destructor( vlc_object_t * p_this );,13,52,audio_output\output.c,aout_Destructor,,false,56,56,aout_Destructor,,,5,void aout_Destructor (vlc_object_t*)
8347,METHOD,audio_output\output.c:<global>,TYPE_DECL,"static int var_Copy (vlc_object_t *src, const char *name, vlc_value_t prev,
                     vlc_value_t value, void *data)
{
    vlc_object_t *dst = data;

    (void) src; (void) prev;
    return var_Set (dst, name, value);
}",1,1,audio_output\output.c,var_Copy,,false,58,65,var_Copy,,,6,"int var_Copy (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
8371,METHOD,audio_output\output.c:<global>,TYPE_DECL,"static int var_CopyDevice (vlc_object_t *src, const char *name,
                           vlc_value_t prev, vlc_value_t value, void *data)
{
    vlc_object_t *dst = data;

    (void) src; (void) name; (void) prev;
    return var_Set (dst, ""audio-device"", value);
}",1,1,audio_output\output.c,var_CopyDevice,,false,67,74,var_CopyDevice,,,7,"int var_CopyDevice (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
8398,METHOD,audio_output\output.c:<global>,TYPE_DECL,"static void aout_VolumeNotify (audio_output_t *aout, float volume)
{
    var_SetFloat (aout, ""volume"", volume);
}",1,1,audio_output\output.c,aout_VolumeNotify,,false,86,89,aout_VolumeNotify,,,8,"void aout_VolumeNotify (audio_output_t*,float)"
8408,METHOD,audio_output\output.c:<global>,TYPE_DECL,"static void aout_MuteNotify (audio_output_t *aout, bool mute)
{
    var_SetBool (aout, ""mute"", mute);
}",1,1,audio_output\output.c,aout_MuteNotify,,false,91,94,aout_MuteNotify,,,9,"void aout_MuteNotify (audio_output_t*,bool)"
8418,METHOD,audio_output\output.c:<global>,TYPE_DECL,"static void aout_PolicyNotify (audio_output_t *aout, bool cork)
{
    (cork ? var_IncInteger : var_DecInteger) (aout->obj.parent, ""corks"");
}",1,1,audio_output\output.c,aout_PolicyNotify,,false,96,99,aout_PolicyNotify,,,10,"void aout_PolicyNotify (audio_output_t*,bool)"
8435,METHOD,audio_output\output.c:<global>,TYPE_DECL,"static void aout_DeviceNotify (audio_output_t *aout, const char *id)
{
    var_SetString (aout, ""device"", (id != NULL) ? id : """");
}",1,1,audio_output\output.c,aout_DeviceNotify,,false,101,104,aout_DeviceNotify,,,11,"void aout_DeviceNotify (audio_output_t*,char*)"
8450,METHOD,audio_output\output.c:<global>,TYPE_DECL,"static void aout_HotplugNotify (audio_output_t *aout,
                                const char *id, const char *name)
{
    aout_owner_t *owner = aout_owner (aout);
    aout_dev_t *dev, **pp = &owner->dev.list;

    vlc_mutex_lock (&owner->dev.lock);
    while ((dev = *pp) != NULL)
    {
        if (!strcmp (id, dev->id))
            break;
        pp = &dev->next;
    }

    if (name != NULL)
    {
        if (dev == NULL) /* Added device */
        {
            dev = malloc (sizeof (*dev) + strlen (id));
            if (unlikely(dev == NULL))
                goto out;
            dev->next = NULL;
            strcpy (dev->id, id);
            *pp = dev;
            owner->dev.count++;
        }
        else /* Modified device */
            free (dev->name);
        dev->name = strdup (name);
    }
    else
    {
        if (dev != NULL) /* Removed device */
        {
            owner->dev.count--;
            *pp = dev->next;
            free (dev->name);
            free (de...",1,1,audio_output\output.c,aout_HotplugNotify,,false,106,148,aout_HotplugNotify,,,12,"void aout_HotplugNotify (audio_output_t*,char*,char*)"
8593,METHOD,audio_output\output.c:<global>,TYPE_DECL,"static void aout_RestartNotify (audio_output_t *aout, unsigned mode)
{
    aout_RequestRestart (aout, mode);
}",1,1,audio_output\output.c,aout_RestartNotify,,false,150,153,aout_RestartNotify,,,13,"void aout_RestartNotify (audio_output_t*,unsigned)"
8602,METHOD,audio_output\output.c:<global>,TYPE_DECL,"static int aout_GainNotify (audio_output_t *aout, float gain)
{
    aout_owner_t *owner = aout_owner (aout);

    aout_OutputAssertLocked (aout);
    aout_volume_SetVolume (owner->volume, gain);
    /* XXX: ideally, return -1 if format cannot be amplified */
    return 0;
}",1,1,audio_output\output.c,aout_GainNotify,,false,155,163,aout_GainNotify,,,14,"int aout_GainNotify (audio_output_t*,float)"
8622,METHOD,audio_output\output.c:<global>,TYPE_DECL,"static int FilterCallback (vlc_object_t *obj, const char *var,
                           vlc_value_t prev, vlc_value_t cur, void *data)
{
    if (strcmp(prev.psz_string, cur.psz_string))
        aout_InputRequestRestart ((audio_output_t *)obj);
    (void) var; (void) data;
    return VLC_SUCCESS;
}",1,1,audio_output\output.c,FilterCallback,,false,165,172,FilterCallback,,,15,"int FilterCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
8652,METHOD,audio_output\output.c:<global>,TYPE_DECL,"static int StereoModeCallback (vlc_object_t *obj, const char *varname,
                               vlc_value_t oldval, vlc_value_t newval, void *data)
{
    audio_output_t *aout = (audio_output_t *)obj;
    (void)varname; (void)oldval; (void)newval; (void)data;

    aout_RestartRequest (aout, AOUT_RESTART_STEREOMODE);
    return 0;
}",1,1,audio_output\output.c,StereoModeCallback,,false,174,182,StereoModeCallback,,,16,"int StereoModeCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
8684,METHOD,audio_output\output.c:<global>,TYPE_DECL,"static int ViewpointCallback (vlc_object_t *obj, const char *var,
                              vlc_value_t prev, vlc_value_t cur, void *data)
{
    if( cur.p_address != NULL )
        aout_ChangeViewpoint((audio_output_t *)obj, cur.p_address );
    (void) var; (void) data; (void) prev;
    return VLC_SUCCESS;
}",1,1,audio_output\output.c,ViewpointCallback,,false,184,191,ViewpointCallback,,,17,"int ViewpointCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
8718,METHOD,audio_output\output.c:<global>,TYPE_DECL,"audio_output_t *aout_New (vlc_object_t *parent)
{
    vlc_value_t val, text;

    audio_output_t *aout = vlc_custom_create (parent, sizeof (aout_instance_t),
                                              ""audio output"");
    if (unlikely(aout == NULL))
        return NULL;

    aout_owner_t *owner = aout_owner (aout);

    vlc_mutex_init (&owner->lock);
    vlc_mutex_init (&owner->req.lock);
    vlc_mutex_init (&owner->dev.lock);
    vlc_mutex_init (&owner->vp.lock);
    vlc_viewpoint_init (&owner->vp.value);
    atomic_init (&owner->vp.update, false);
    owner->req.device = (char *)unset_str;
    owner->req.volume = -1.f;
    owner->req.mute = -1;

    vlc_object_set_destructor (aout, aout_Destructor);

    /* Audio output module callbacks */
    var_Create (aout, ""volume"", VLC_VAR_FLOAT);
    var_AddCallback (aout, ""volume"", var_Copy, parent);
    var_Create (aout, ""mute"", VLC_VAR_BOOL | VLC_VAR_DOINHERIT);
    var_AddCallback (aout, ""mute"", var_Copy, parent);
    var_Create (aou...",1,27,audio_output\output.c,aout_New,,false,197,354,aout_New,,,18,audio_output_t aout_New (vlc_object_t*)
9376,METHOD,audio_output\output.c:<global>,TYPE_DECL,"void aout_Destroy (audio_output_t *aout)
{
    aout_owner_t *owner = aout_owner (aout);

    aout_OutputLock (aout);
    module_unneed (aout, owner->module);
    /* Protect against late call from intf.c */
    aout->volume_set = NULL;
    aout->mute_set = NULL;
    aout->device_select = NULL;
    aout_OutputUnlock (aout);

    var_DelCallback (aout, ""viewpoint"", ViewpointCallback, NULL);
    var_DelCallback (aout, ""audio-filter"", FilterCallback, NULL);
    var_DelCallback (aout, ""device"", var_CopyDevice, aout->obj.parent);
    var_DelCallback (aout, ""mute"", var_Copy, aout->obj.parent);
    var_SetFloat (aout, ""volume"", -1.f);
    var_DelCallback (aout, ""volume"", var_Copy, aout->obj.parent);
    var_DelCallback (aout, ""stereo-mode"", StereoModeCallback, NULL);
    vlc_object_release (aout);
}",1,1,audio_output\output.c,aout_Destroy,,false,359,379,aout_Destroy,,,19,void aout_Destroy (audio_output_t*)
9459,METHOD,audio_output\output.c:<global>,TYPE_DECL,"static void aout_Destructor (vlc_object_t *obj)
{
    audio_output_t *aout = (audio_output_t *)obj;
    aout_owner_t *owner = aout_owner (aout);

    vlc_mutex_destroy (&owner->dev.lock);
    for (aout_dev_t *dev = owner->dev.list, *next; dev != NULL; dev = next)
    {
        next = dev->next;
        free (dev->name);
        free (dev);
    }

    assert (owner->req.device == unset_str);
    vlc_mutex_destroy (&owner->vp.lock);
    vlc_mutex_destroy (&owner->req.lock);
    vlc_mutex_destroy (&owner->lock);
}",1,1,audio_output\output.c,aout_Destructor,,false,384,401,aout_Destructor,,,20,void aout_Destructor (vlc_object_t*)
9538,METHOD,audio_output\output.c:<global>,TYPE_DECL,"static void aout_PrepareStereoMode (audio_output_t *aout,
                                    audio_sample_format_t *restrict fmt,
                                    aout_filters_cfg_t *filters_cfg,
                                    audio_channel_type_t input_chan_type,
                                    unsigned i_nb_input_channels,
                                    int i_forced_stereo_mode)
{
    /* Fill Stereo mode choices */
    var_Change (aout, ""stereo-mode"", VLC_VAR_CLEARCHOICES, NULL, NULL);
    vlc_value_t val, txt, default_val = { .i_int = AOUT_VAR_CHAN_UNSET };
    val.i_int = 0;

    if (!AOUT_FMT_LINEAR(fmt) || i_nb_input_channels == 1)
        return;

    val.i_int = AOUT_VAR_CHAN_MONO;
    txt.psz_string = _(""Mono"");
    var_Change (aout, ""stereo-mode"", VLC_VAR_ADDCHOICE, &val, &txt);

    if (i_nb_input_channels != 2)
    {
        val.i_int = AOUT_VAR_CHAN_UNSET;
        txt.psz_string = _(""Original"");
        var_Change (aout, ""stereo-mode"", VLC_VAR_ADDCHOIC...",1,1,audio_output\output.c,aout_PrepareStereoMode,,false,403,510,aout_PrepareStereoMode,,,21,"void aout_PrepareStereoMode (audio_output_t*,audio_sample_format_t*,aout_filters_cfg_t*,audio_channel_type_t,unsigned,int)"
9902,METHOD,audio_output\output.c:<global>,TYPE_DECL,"int aout_OutputNew (audio_output_t *aout, audio_sample_format_t *restrict fmt,
                    aout_filters_cfg_t *filters_cfg)
{
    aout_OutputAssertLocked (aout);

    audio_channel_type_t input_chan_type = fmt->channel_type;
    int i_forced_stereo_mode = AOUT_VAR_CHAN_UNSET;
    unsigned i_nb_input_channels = fmt->i_channels;

    /* Ideally, the audio filters would be created before the audio output,
     * and the ideal audio format would be the output of the filters chain.
     * But that scheme would not really play well with digital pass-through. */
    if (AOUT_FMT_LINEAR(fmt))
    {
        if (fmt->channel_type == AUDIO_CHANNEL_TYPE_BITMAP
         && aout_FormatNbChannels(fmt) == 0)
        {
            /* The output channel map is unknown, use the WAVE one. */
            assert(fmt->i_channels > 0);
            aout_SetWavePhysicalChannels(fmt);
        }

        if (fmt->channel_type == AUDIO_CHANNEL_TYPE_AMBISONICS)
        {
            /* Set the maximum of...",1,1,audio_output\output.c,aout_OutputNew,,false,517,580,aout_OutputNew,,,22,"int aout_OutputNew (audio_output_t*,audio_sample_format_t*,aout_filters_cfg_t*)"
10061,METHOD,audio_output\output.c:<global>,TYPE_DECL,"void aout_OutputDelete (audio_output_t *aout)
{
    aout_OutputAssertLocked (aout);

    if (aout->stop != NULL)
        aout->stop (aout);
}",1,1,audio_output\output.c,aout_OutputDelete,,false,587,593,aout_OutputDelete,,,23,void aout_OutputDelete (audio_output_t*)
10080,METHOD,audio_output\output.c:<global>,TYPE_DECL,"int aout_OutputTimeGet (audio_output_t *aout, mtime_t *delay)
{
    aout_OutputAssertLocked (aout);

    if (aout->time_get == NULL)
        return -1;
    return aout->time_get (aout, delay);
}",1,1,audio_output\output.c,aout_OutputTimeGet,,false,595,602,aout_OutputTimeGet,,,24,"int aout_OutputTimeGet (audio_output_t*,mtime_t*)"
10105,METHOD,audio_output\output.c:<global>,TYPE_DECL,"void aout_OutputPlay (audio_output_t *aout, block_t *block)
{
    aout_OutputAssertLocked (aout);
#ifndef NDEBUG
    aout_owner_t *owner = aout_owner (aout);
    assert (owner->mixer_format.i_frame_length > 0);
    assert (block->i_buffer == 0 || block->i_buffer / block->i_nb_samples ==
            owner->mixer_format.i_bytes_per_frame /
            owner->mixer_format.i_frame_length);
#endif
    aout->play (aout, block);
}",1,1,audio_output\output.c,aout_OutputPlay,,false,609,620,aout_OutputPlay,,,25,"void aout_OutputPlay (audio_output_t*,block_t*)"
10158,METHOD,audio_output\output.c:<global>,TYPE_DECL,"static void PauseDefault (audio_output_t *aout, bool pause, mtime_t date)
{
    if (pause)
        aout_OutputFlush (aout, false);
    (void) date;
}",1,1,audio_output\output.c,PauseDefault,,false,622,627,PauseDefault,,,26,"void PauseDefault (audio_output_t*,bool,mtime_t)"
10174,METHOD,audio_output\output.c:<global>,TYPE_DECL,"void aout_OutputPause( audio_output_t *aout, bool pause, mtime_t date )
{
    aout_OutputAssertLocked (aout);
    ((aout->pause != NULL) ? aout->pause : PauseDefault) (aout, pause, date);
}",1,1,audio_output\output.c,aout_OutputPause,,false,636,640,aout_OutputPause,,,27,"void aout_OutputPause (audio_output_t*,bool,mtime_t)"
10197,METHOD,audio_output\output.c:<global>,TYPE_DECL,"void aout_OutputFlush( audio_output_t *aout, bool wait )
{
    aout_OutputAssertLocked( aout );
    aout->flush (aout, wait);
}",1,1,audio_output\output.c,aout_OutputFlush,,false,650,654,aout_OutputFlush,,,28,"void aout_OutputFlush (audio_output_t*,bool)"
10211,METHOD,audio_output\output.c:<global>,TYPE_DECL,"static int aout_OutputVolumeSet (audio_output_t *aout, float vol)
{
    aout_OutputAssertLocked (aout);
    return (aout->volume_set != NULL) ? aout->volume_set (aout, vol) : -1;
}",1,1,audio_output\output.c,aout_OutputVolumeSet,,false,656,660,aout_OutputVolumeSet,,,29,"int aout_OutputVolumeSet (audio_output_t*,float)"
10234,METHOD,audio_output\output.c:<global>,TYPE_DECL,"static int aout_OutputMuteSet (audio_output_t *aout, bool mute)
{
    aout_OutputAssertLocked (aout);
    return (aout->mute_set != NULL) ? aout->mute_set (aout, mute) : -1;
}",1,1,audio_output\output.c,aout_OutputMuteSet,,false,662,666,aout_OutputMuteSet,,,30,"int aout_OutputMuteSet (audio_output_t*,bool)"
10257,METHOD,audio_output\output.c:<global>,TYPE_DECL,"static int aout_OutputDeviceSet (audio_output_t *aout, const char *id)
{
    aout_OutputAssertLocked (aout);
    return (aout->device_select != NULL) ? aout->device_select (aout, id) : -1;
}",1,1,audio_output\output.c,aout_OutputDeviceSet,,false,668,672,aout_OutputDeviceSet,,,31,"int aout_OutputDeviceSet (audio_output_t*,char*)"
10280,METHOD,audio_output\output.c:<global>,TYPE_DECL,"void aout_OutputLock (audio_output_t *aout)
{
    aout_owner_t *owner = aout_owner (aout);

    vlc_mutex_lock (&owner->lock);
}",1,1,audio_output\output.c,aout_OutputLock,,false,674,679,aout_OutputLock,,,32,void aout_OutputLock (audio_output_t*)
10295,METHOD,audio_output\output.c:<global>,TYPE_DECL,"static int aout_OutputTryLock (audio_output_t *aout)
{
    aout_owner_t *owner = aout_owner (aout);

    return vlc_mutex_trylock (&owner->lock);
}",1,1,audio_output\output.c,aout_OutputTryLock,,false,681,686,aout_OutputTryLock,,,33,int aout_OutputTryLock (audio_output_t*)
10311,METHOD,audio_output\output.c:<global>,TYPE_DECL,"void aout_OutputUnlock (audio_output_t *aout)
{
    aout_owner_t *owner = aout_owner (aout);

    vlc_assert_locked (&owner->lock);
    vlc_mutex_lock (&owner->req.lock);

    if (owner->req.device != unset_str)
    {
        aout_OutputDeviceSet (aout, owner->req.device);
        free (owner->req.device);
        owner->req.device = (char *)unset_str;
    }

    if (owner->req.volume >= 0.f)
    {
        aout_OutputVolumeSet (aout, owner->req.volume);
        owner->req.volume = -1.f;
    }

    if (owner->req.mute >= 0)
    {
        aout_OutputMuteSet (aout, owner->req.mute);
        owner->req.mute = -1;
    }

    vlc_mutex_unlock (&owner->lock);
    /* If another thread is blocked waiting for owner->req.lock at this point,
     * this aout_OutputUnlock() call will not see and apply its change request.
     * The other thread will need to apply the change request itself, which
     * implies it is able to (try-)lock owner->lock. Therefore this thread must
     * release owner-...",1,4,audio_output\output.c,aout_OutputUnlock,,false,688,721,aout_OutputUnlock,,,34,void aout_OutputUnlock (audio_output_t*)
10431,METHOD,audio_output\output.c:<global>,TYPE_DECL,"float aout_VolumeGet (audio_output_t *aout)
{
    return var_GetFloat (aout, ""volume"");
}",1,1,audio_output\output.c,aout_VolumeGet,,false,728,731,aout_VolumeGet,,,35,float aout_VolumeGet (audio_output_t*)
10440,METHOD,audio_output\output.c:<global>,TYPE_DECL,"int aout_VolumeSet (audio_output_t *aout, float vol)
{
    aout_owner_t *owner = aout_owner (aout);

    assert (vol >= 0.f);
    vlc_mutex_lock (&owner->req.lock);
    owner->req.volume = vol;
    vlc_mutex_unlock (&owner->req.lock);

    if (aout_OutputTryLock (aout) == 0)
        aout_OutputUnlock (aout);
    return 0;
}",1,1,audio_output\output.c,aout_VolumeSet,,false,738,750,aout_VolumeSet,,,36,"int aout_VolumeSet (audio_output_t*,float)"
10486,METHOD,audio_output\output.c:<global>,TYPE_DECL,"int aout_VolumeUpdate (audio_output_t *aout, int value, float *volp)
{
    int ret = -1;
    float stepSize = var_InheritFloat (aout, ""volume-step"") / (float)AOUT_VOLUME_DEFAULT;
    float delta = value * stepSize;
    float vol = aout_VolumeGet (aout);

    if (vol >= 0.f)
    {
        vol += delta;
        if (vol < 0.f)
            vol = 0.f;
        if (vol > 2.f)
            vol = 2.f;
        vol = (roundf (vol / stepSize)) * stepSize;
        if (volp != NULL)
            *volp = vol;
        ret = aout_VolumeSet (aout, vol);
    }
    return ret;
}",1,1,audio_output\output.c,aout_VolumeUpdate,,false,757,777,aout_VolumeUpdate,,,37,"int aout_VolumeUpdate (audio_output_t*,int,float*)"
10567,METHOD,audio_output\output.c:<global>,TYPE_DECL,"int aout_MuteGet (audio_output_t *aout)
{
    return var_InheritBool (aout, ""mute"");
}",1,1,audio_output\output.c,aout_MuteGet,,false,783,786,aout_MuteGet,,,38,int aout_MuteGet (audio_output_t*)
10576,METHOD,audio_output\output.c:<global>,TYPE_DECL,"int aout_MuteSet (audio_output_t *aout, bool mute)
{
    aout_owner_t *owner = aout_owner (aout);

    vlc_mutex_lock (&owner->req.lock);
    owner->req.mute = mute;
    vlc_mutex_unlock (&owner->req.lock);

    if (aout_OutputTryLock (aout) == 0)
        aout_OutputUnlock (aout);
    return 0;
}",1,1,audio_output\output.c,aout_MuteSet,,false,792,803,aout_MuteSet,,,39,"int aout_MuteSet (audio_output_t*,bool)"
10618,METHOD,audio_output\output.c:<global>,TYPE_DECL,"char *aout_DeviceGet (audio_output_t *aout)
{
    return var_GetNonEmptyString (aout, ""device"");
}",1,1,audio_output\output.c,aout_DeviceGet,,false,810,813,aout_DeviceGet,,,40,char* aout_DeviceGet (audio_output_t*)
10627,METHOD,audio_output\output.c:<global>,TYPE_DECL,"int aout_DeviceSet (audio_output_t *aout, const char *id)
{
    aout_owner_t *owner = aout_owner (aout);

    char *dev = NULL;
    if (id != NULL)
    {
        dev = strdup (id);
        if (unlikely(dev == NULL))
            return -1;
    }

    vlc_mutex_lock (&owner->req.lock);
    if (owner->req.device != unset_str)
        free (owner->req.device);
    owner->req.device = dev;
    vlc_mutex_unlock (&owner->req.lock);

    if (aout_OutputTryLock (aout) == 0)
        aout_OutputUnlock (aout);
    return 0;
}",1,1,audio_output\output.c,aout_DeviceSet,,false,820,841,aout_DeviceSet,,,41,"int aout_DeviceSet (audio_output_t*,char*)"
10706,METHOD,audio_output\output.c:<global>,TYPE_DECL,"int aout_DevicesList (audio_output_t *aout, char ***ids, char ***names)
{
    aout_owner_t *owner = aout_owner (aout);
    char **tabid, **tabname;
    unsigned i = 0;

    vlc_mutex_lock (&owner->dev.lock);
    tabid = vlc_alloc (owner->dev.count, sizeof (*tabid));
    tabname = vlc_alloc (owner->dev.count, sizeof (*tabname));

    if (unlikely(tabid == NULL || tabname == NULL))
        goto error;

    *ids = tabid;
    *names = tabname;

    for (aout_dev_t *dev = owner->dev.list; dev != NULL; dev = dev->next)
    {
        tabid[i] = strdup(dev->id);
        if (unlikely(tabid[i] == NULL))
            goto error;

        tabname[i] = strdup(dev->name);
        if (unlikely(tabname[i] == NULL))
        {
            free(tabid[i]);
            goto error;
        }

        i++;
    }
    vlc_mutex_unlock (&owner->dev.lock);

    return i;

error:
    vlc_mutex_unlock(&owner->dev.lock);
    while (i > 0)
    {
        i--;
        free(tabname[i]);
        free(tabid[i]);
    }
...",1,1,audio_output\output.c,aout_DevicesList,,false,854,900,aout_DevicesList,,,42,"int aout_DevicesList (audio_output_t*,char***,char***)"
10891,METHOD,audio_output\volume.c:<global>,TYPE_DECL,<global>,1,29,audio_output\volume.c,audio_output\volume.c:<global>,,false,1,203,<global>,,,1,
10899,METHOD,audio_output\volume.c:<global>,TYPE_DECL,"static int ReplayGainCallback (vlc_object_t *, char const *,
                               vlc_value_t, vlc_value_t, void *);",12,64,audio_output\volume.c,ReplayGainCallback,,false,45,46,ReplayGainCallback,,,2,"int ReplayGainCallback (vlc_object_t*,char*,ANY,ANY,void*)"
10908,METHOD,audio_output\volume.c:<global>,TYPE_DECL,"aout_volume_t *aout_volume_New(vlc_object_t *parent,
                               const audio_replay_gain_t *gain)
{
    aout_volume_t *vol = vlc_custom_create(parent, sizeof (aout_volume_t),
                                           ""volume"");
    if (unlikely(vol == NULL))
        return NULL;
    vol->module = NULL;
    vol->output_factor = 1.f;

    //audio_volume_t *obj = &vol->object;

    /* Gain */
    if (gain != NULL)
        memcpy(&vol->replay_gain, gain, sizeof (vol->replay_gain));
    else
        memset(&vol->replay_gain, 0, sizeof (vol->replay_gain));

    var_AddCallback(parent, ""audio-replay-gain-mode"",
                    ReplayGainCallback, vol);
    var_TriggerCallback(parent, ""audio-replay-gain-mode"");

    return vol;
}",1,1,audio_output\volume.c,aout_volume_New,,false,52,75,aout_volume_New,,,3,"aout_volume_t aout_volume_New (vlc_object_t*,audio_replay_gain_t*)"
10977,METHOD,audio_output\volume.c:<global>,TYPE_DECL,"int aout_volume_SetFormat(aout_volume_t *vol, vlc_fourcc_t format)
{
    if (unlikely(vol == NULL))
        return -1;

    audio_volume_t *obj = &vol->object;
    if (vol->module != NULL)
    {
        if (obj->format == format)
        {
            msg_Dbg (obj, ""retaining sample format"");
            return 0;
        }
        msg_Dbg (obj, ""changing sample format"");
        module_unneed(obj, vol->module);
    }

    obj->format = format;
    vol->module = module_need(obj, ""audio volume"", NULL, false);
    if (vol->module == NULL)
        return -1;
    return 0;
}",1,1,audio_output\volume.c,aout_volume_SetFormat,,false,80,102,aout_volume_SetFormat,,,4,"int aout_volume_SetFormat (aout_volume_t*,vlc_fourcc_t)"
11052,METHOD,audio_output\volume.c:<global>,TYPE_DECL,"void aout_volume_Delete(aout_volume_t *vol)
{
    if (vol == NULL)
        return;

    audio_volume_t *obj = &vol->object;

    if (vol->module != NULL)
        module_unneed(obj, vol->module);
    var_DelCallback(obj->obj.parent, ""audio-replay-gain-mode"",
                    ReplayGainCallback, vol);
    vlc_object_release(obj);
}",1,1,audio_output\volume.c,aout_volume_Delete,,false,107,119,aout_volume_Delete,,,5,void aout_volume_Delete (aout_volume_t*)
11093,METHOD,audio_output\volume.c:<global>,TYPE_DECL,"void aout_volume_SetVolume(aout_volume_t *vol, float factor)
{
    if (unlikely(vol == NULL))
        return;

    vol->output_factor = factor;
}",1,1,audio_output\volume.c,aout_volume_SetVolume,,false,121,127,aout_volume_SetVolume,,,6,"void aout_volume_SetVolume (aout_volume_t*,float)"
11111,METHOD,audio_output\volume.c:<global>,TYPE_DECL,"int aout_volume_Amplify(aout_volume_t *vol, block_t *block)
{
    if (unlikely(vol == NULL) || vol->module == NULL)
        return -1;

    float amp = vol->output_factor
              * vlc_atomic_load_float (&vol->gain_factor);

    vol->object.amplify(&vol->object, block, amp);
    return 0;
}",1,1,audio_output\volume.c,aout_volume_Amplify,,false,132,142,aout_volume_Amplify,,,7,"int aout_volume_Amplify (aout_volume_t*,block_t*)"
11158,METHOD,audio_output\volume.c:<global>,TYPE_DECL,"static float aout_ReplayGainSelect(vlc_object_t *obj, const char *str,
                                   const audio_replay_gain_t *replay_gain)
{
    unsigned mode = AUDIO_REPLAY_GAIN_MAX;

    if (likely(str != NULL))
    {   /* Find selectrf mode */
        if (!strcmp (str, ""track""))
            mode = AUDIO_REPLAY_GAIN_TRACK;
        else
        if (!strcmp (str, ""album""))
            mode = AUDIO_REPLAY_GAIN_ALBUM;
    }

    /* */
    float multiplier;

    if (mode == AUDIO_REPLAY_GAIN_MAX)
    {
        multiplier = 1.f;
    }
    else
    {
        float gain;

        /* If the selectrf mode is not available, prefer the other one */
        if (!replay_gain->pb_gain[mode] && replay_gain->pb_gain[!mode])
            mode = !mode;

        if (replay_gain->pb_gain[mode])
            gain = replay_gain->pf_gain[mode]
                 + var_InheritFloat (obj, ""audio-replay-gain-preamp"");
        else
            gain = var_InheritFloat (obj, ""audio-replay-gain-default"");

 ...",1,1,audio_output\volume.c,aout_ReplayGainSelect,,false,145,192,aout_ReplayGainSelect,,,8,"float aout_ReplayGainSelect (vlc_object_t*,char*,audio_replay_gain_t*)"
11288,METHOD,audio_output\volume.c:<global>,TYPE_DECL,"static int ReplayGainCallback (vlc_object_t *obj, char const *var,
                               vlc_value_t oldval, vlc_value_t val, void *data)
{
    aout_volume_t *vol = data;
    float multiplier = aout_ReplayGainSelect(obj, val.psz_string,
                                             &vol->replay_gain);
    vlc_atomic_store_float (&vol->gain_factor, multiplier);
    VLC_UNUSED(var); VLC_UNUSED(oldval);
    return VLC_SUCCESS;
}",1,1,audio_output\volume.c,ReplayGainCallback,,false,194,203,ReplayGainCallback,,,9,"int ReplayGainCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
11342,METHOD,config\chain.c:<global>,TYPE_DECL,<global>,1,24,config\chain.c,config\chain.c:<global>,,false,1,497,<global>,,,1,
11344,METHOD,config\chain.c:<global>,TYPE_DECL,"static bool IsEscapeNeeded( char c )
{
    return c == '\'' || c == '""' || c == '\\';
}",1,1,config\chain.c,IsEscapeNeeded,,false,45,48,IsEscapeNeeded,,,1,bool IsEscapeNeeded (char)
11361,METHOD,config\chain.c:<global>,TYPE_DECL,"static bool IsEscape( const char *psz )
{
    if( !psz )
        return false;
    return psz[0] == '\\' && IsEscapeNeeded( psz[1] );
}",1,1,config\chain.c,IsEscape,,false,49,54,IsEscape,,,2,bool IsEscape (char*)
11383,METHOD,config\chain.c:<global>,TYPE_DECL,"static bool IsSpace( char c  )
{
    return c == ' ' || c == '\t';
}",1,1,config\chain.c,IsSpace,,false,55,58,IsSpace,,,3,bool IsSpace (char)
11396,METHOD,config\chain.c:<global>,TYPE_DECL,"static const char *ChainGetEnd( const char *psz_string )
{
    const char *p = psz_string;
    char c;

    if( !psz_string )
        return NULL;

    /* Look for a opening character */
    SKIPSPACE( p );

    for( ;; p++)
    {
        if( *p == '\0' || *p == ',' || *p == '}' )
            return p;

        if( *p == '{' || *p == '""' || *p == '\'' )
            break;
    }

    /* Set c to the closing character */
    if( *p == '{' )
        c = '}';
    else
        c = *p;
    p++;

    /* Search the closing character, handle nested {..} */
    for( ;; )
    {
        if( *p == '\0')
            return p;

        if( IsEscape( p ) )
            p += 2;
        else if( *p == c )
            return ++p;
        else if( *p == '{' && c == '}' )
            p = ChainGetEnd( p );
        else
            p++;
    }
}",1,4,config\chain.c,ChainGetEnd,,false,71,113,ChainGetEnd,,,4,const char* ChainGetEnd (char*)
11526,METHOD,config\chain.c:<global>,TYPE_DECL,"static char *ChainGetValue( const char **ppsz_string )
{
    const char *p = *ppsz_string;

    char *psz_value = NULL;
    const char *end;
    bool b_keep_brackets = (*p == '{');

    if( *p == '=' )
        p++;

    end = ChainGetEnd( p );
    if( end <= p )
    {
        psz_value = NULL;
    }
    else
    {
        /* Skip heading and trailing spaces.
         * This ain't necessary but will avoid simple
         * user mistakes. */
        SKIPSPACE( p );
    }

    if( end <= p )
    {
        psz_value = NULL;
    }
    else
    {
        if( *p == '\'' || *p == '""' || ( !b_keep_brackets && *p == '{' ) )
        {
            p++;

            if( *(end-1) != '\'' && *(end-1) == '""' )
                SKIPTRAILINGSPACE( p, end );

            if( end - 1 <= p )
                psz_value = NULL;
            else
                psz_value = strndup( p, end -1 - p );
        }
        else
        {
            SKIPTRAILINGSPACE( p, end );
            if( end <= p )
          ...",1,8,config\chain.c,ChainGetValue,,false,119,178,ChainGetValue,,,5,char* ChainGetValue (char**)
11713,METHOD,config\chain.c:<global>,TYPE_DECL,"const char *config_ChainParseOptions( config_chain_t **pp_cfg, const char *psz_opts )
{
    config_chain_t **pp_next = pp_cfg;
    bool first = true;
    do
    {
        if (!first)
            psz_opts++; /* skip previous delimiter */
        SKIPSPACE( psz_opts );

        first = false;

        /* Look for the end of the name (,={}_space_) */
        size_t len = strcspn( psz_opts, ""=,{} \t"" );
        if( len == 0 )
            continue; /* ignore empty parameter */

        /* Append the new parameter */
        config_chain_t *p_cfg = malloc( sizeof(*p_cfg) );
        if( !p_cfg )
            break;
        p_cfg->psz_name = strndup( psz_opts, len );
        psz_opts += len;
        p_cfg->psz_value = NULL;
        p_cfg->p_next = NULL;

        *pp_next = p_cfg;
        pp_next = &p_cfg->p_next;

        /* Extract the option value */
        SKIPSPACE( psz_opts );
        if( strchr( ""={"", *psz_opts ) )
        {
            p_cfg->psz_value = ChainGetValue( &psz_opts );
 ...",1,8,config\chain.c,config_ChainParseOptions,,false,181,224,config_ChainParseOptions,,,6,"const char* config_ChainParseOptions (config_chain_t**,char*)"
11851,METHOD,config\chain.c:<global>,TYPE_DECL,"char *config_ChainCreate( char **ppsz_name, config_chain_t **pp_cfg,
                          const char *psz_chain )
{
    size_t len;

    *ppsz_name = NULL;
    *pp_cfg    = NULL;

    if( !psz_chain )
        return NULL;
    SKIPSPACE( psz_chain );

    /* Look for parameter (a {...} or :...) or end of name (space or nul) */
    len = strcspn( psz_chain, ""{: \t"" );
    *ppsz_name = strndup( psz_chain, len );
    psz_chain += len;

    /* Parse the parameters */
    SKIPSPACE( psz_chain );
    if( *psz_chain == '{' )
        psz_chain = config_ChainParseOptions( pp_cfg, psz_chain );

    if( *psz_chain == ':' )
        return strdup( psz_chain + 1 );

    return NULL;
}",1,4,config\chain.c,config_ChainCreate,,false,226,252,config_ChainCreate,,,7,"char* config_ChainCreate (char**,config_chain_t**,char*)"
11927,METHOD,config\chain.c:<global>,TYPE_DECL,"void config_ChainDestroy( config_chain_t *p_cfg )
{
    while( p_cfg != NULL )
    {
        config_chain_t *p_next;

        p_next = p_cfg->p_next;

        FREENULL( p_cfg->psz_name );
        FREENULL( p_cfg->psz_value );
        free( p_cfg );

        p_cfg = p_next;
    }
}",1,1,config\chain.c,config_ChainDestroy,,false,254,268,config_ChainDestroy,,,8,void config_ChainDestroy (config_chain_t*)
11956,METHOD,config\chain.c:<global>,TYPE_DECL,"void config_ChainParse( vlc_object_t *p_this, const char *psz_prefix,
                        const char *const *ppsz_options, config_chain_t *cfg )
{
    if( psz_prefix == NULL ) psz_prefix = """";
    size_t plen = 1 + strlen( psz_prefix );

    /* First, var_Create all variables */
    for( size_t i = 0; ppsz_options[i] != NULL; i++ )
    {
        const char *optname = ppsz_options[i];
        if (optname[0] == '*')
            optname++;

        char name[plen + strlen( optname )];
        snprintf( name, sizeof (name), ""%s%s"", psz_prefix, optname );
        if( var_Create( p_this, name,
                        config_GetType( name ) | VLC_VAR_DOINHERIT ) )
            return /* VLC_xxx */;

        module_config_t* p_conf = config_FindConfig( name );
        if( p_conf )
        {
            switch( CONFIG_CLASS( p_conf->i_type ) )
            {
                case CONFIG_ITEM_INTEGER:
                    var_Change( p_this, name, VLC_VAR_SETMINMAX,
                        &(...",1,20,config\chain.c,config_ChainParse,,false,271,434,config_ChainParse,,,9,"void config_ChainParse (vlc_object_t*,char*,char**,config_chain_t*)"
12446,METHOD,config\chain.c:<global>,TYPE_DECL,"config_chain_t *config_ChainDuplicate( const config_chain_t *p_src )
{
    config_chain_t *p_dst = NULL;
    config_chain_t **pp_last = &p_dst;

    for( ; p_src != NULL; p_src = p_src->p_next )
    {
        config_chain_t *p = malloc( sizeof(*p) );
        if( !p )
            break;
        p->p_next    = NULL;
        p->psz_name  = p_src->psz_name  ? strdup( p_src->psz_name )  : NULL;
        p->psz_value = p_src->psz_value ? strdup( p_src->psz_value ) : NULL;

        *pp_last = p;
        pp_last = &p->p_next;
    }
    return p_dst;
}",1,1,config\chain.c,config_ChainDuplicate,,false,436,454,config_ChainDuplicate,,,10,config_chain_t config_ChainDuplicate (config_chain_t*)
12526,METHOD,config\chain.c:<global>,TYPE_DECL,"char *config_StringUnescape( char *psz_string )
{
    char *psz_src = psz_string;
    char *psz_dst = psz_string;
    if( !psz_src )
        return NULL;

    while( *psz_src )
    {
        if( IsEscape( psz_src ) )
            psz_src++;
        *psz_dst++ = *psz_src++;
    }
    *psz_dst = '\0';

    return psz_string;
}",1,1,config\chain.c,config_StringUnescape,,false,456,472,config_StringUnescape,,,11,char* config_StringUnescape (char*)
12568,METHOD,config\chain.c:<global>,TYPE_DECL,"char *config_StringEscape( const char *str )
{
    size_t length = 0;

    if( str == NULL )
        return NULL;

    for( const char *p = str; *p; p++ )
        length += IsEscapeNeeded( *p ) ? 2 : 1;

    char *ret = malloc( length + 1 ), *dst = ret;

    if( unlikely( !ret ) )
        return NULL;

    for( const char *p = str; *p; p++ )
    {
        if( IsEscapeNeeded( *p ) )
            *dst++ = '\\';
        *dst++ = *p;
    }
    *dst = '\0';;
    return ret;
}",1,1,config\chain.c,config_StringEscape,,false,474,497,config_StringEscape,,,12,char* config_StringEscape (char*)
12678,METHOD,config\cmdline.c:<global>,TYPE_DECL,<global>,1,24,config\cmdline.c,config\cmdline.c:<global>,,false,1,304,<global>,,,1,
12680,METHOD,config\cmdline.c:<global>,TYPE_DECL,"int config_LoadCmdLine( vlc_object_t *p_this, int i_argc,
                        const char *ppsz_argv[], int *pindex )
{
    int i_cmd, i_index, i_opts, i_shortopts, flag, i_verbose = 0;
    struct vlc_option *p_longopts;
    const char **argv_copy = NULL;
#define b_ignore_errors (pindex == NULL)

    /* Short options */
    const module_config_t *pp_shortopts[256];
    char *psz_shortopts;

    /*
     * Generate the longopts and shortopts structures used by getopt_long
     */

    i_opts = 0;
    for (const vlc_plugin_t *p = vlc_plugins; p != NULL; p = p->next)
        /* count the number of exported configuration options (to allocate
         * longopts). We also need to allocate space for two options when
         * dealing with boolean to allow for --foo and --no-foo */
        i_opts += p->conf.count + 2 * p->conf.booleans;

    p_longopts = vlc_alloc( i_opts + 1, sizeof(*p_longopts)  );
    if( p_longopts == NULL )
        return -1;

    psz_shortopts = malloc( 2 * i_opts...",1,8,config\cmdline.c,config_LoadCmdLine,,false,58,304,config_LoadCmdLine,,,1,"int config_LoadCmdLine (vlc_object_t*,int,char[]*,int*)"
13459,METHOD,config\configuration.h:<global>,TYPE_DECL,<global>,1,6,config\configuration.h,config\configuration.h:<global>,,false,1,64,<global>,,,1,
13461,METHOD,config\configuration.h:<global>,TYPE_DECL,"int  config_CreateDir( vlc_object_t *, const char * );",6,53,config\configuration.h,config_CreateDir,,false,30,30,config_CreateDir,,,1,"int config_CreateDir (vlc_object_t*,char*)"
13467,METHOD,config\configuration.h:<global>,TYPE_DECL,int  config_AutoSaveConfigFile( vlc_object_t * );,6,48,config\configuration.h,config_AutoSaveConfigFile,,false,31,31,config_AutoSaveConfigFile,,,2,int config_AutoSaveConfigFile (vlc_object_t*)
13472,METHOD,config\configuration.h:<global>,TYPE_DECL,"void config_Free (module_config_t *, size_t);",6,44,config\configuration.h,config_Free,,false,33,33,config_Free,,,3,"void config_Free (module_config_t*,ANY)"
13478,METHOD,config\configuration.h:<global>,TYPE_DECL,"int config_LoadCmdLine   ( vlc_object_t *, int, const char *[], int * );",5,71,config\configuration.h,config_LoadCmdLine,,false,35,35,config_LoadCmdLine,,,4,"int config_LoadCmdLine (vlc_object_t*,int,char[]*,int*)"
13486,METHOD,config\configuration.h:<global>,TYPE_DECL,int config_LoadConfigFile( vlc_object_t * );,5,43,config\configuration.h,config_LoadConfigFile,,false,36,36,config_LoadConfigFile,,,5,int config_LoadConfigFile (vlc_object_t*)
13491,METHOD,config\configuration.h:<global>,TYPE_DECL,bool config_PrintHelp (vlc_object_t *);,6,38,config\configuration.h,config_PrintHelp,,false,39,39,config_PrintHelp,,,6,bool config_PrintHelp (vlc_object_t*)
13496,METHOD,config\configuration.h:<global>,TYPE_DECL,int config_SortConfig (void);,5,28,config\configuration.h,config_SortConfig,,false,41,41,config_SortConfig,,,7,int config_SortConfig (void)
13501,METHOD,config\configuration.h:<global>,TYPE_DECL,void config_UnsortConfig (void);,6,31,config\configuration.h,config_UnsortConfig,,false,42,42,config_UnsortConfig,,,8,void config_UnsortConfig (void)
13508,METHOD,config\configuration.h:<global>,TYPE_DECL,bool config_IsSafe (const char *);,6,33,config\configuration.h,config_IsSafe,,false,56,56,config_IsSafe,,,11,bool config_IsSafe (char*)
13536,METHOD,config\core.c:<global>,TYPE_DECL,<global>,1,1,config\core.c,config\core.c:<global>,,false,1,587,<global>,,,1,
13546,METHOD,config\core.c:<global>,TYPE_DECL,"static inline char *strdupnull (const char *src)
{
    return src ? strdup (src) : NULL;
}",1,1,config\core.c,strdupnull,,false,44,47,strdupnull,,,5,char* strdupnull (char*)
13557,METHOD,config\core.c:<global>,TYPE_DECL,"int config_GetType(const char *psz_name)
{
    module_config_t *p_config = config_FindConfig(psz_name);

    /* sanity checks */
    if( !p_config )
    {
        return 0;
    }

    switch( CONFIG_CLASS(p_config->i_type) )
    {
        case CONFIG_ITEM_FLOAT:
            return VLC_VAR_FLOAT;
        case CONFIG_ITEM_INTEGER:
            return VLC_VAR_INTEGER;
        case CONFIG_ITEM_BOOL:
            return VLC_VAR_BOOL;
        case CONFIG_ITEM_STRING:
            return VLC_VAR_STRING;
        default:
            return 0;
    }
}",1,12,config\core.c,config_GetType,,false,54,77,config_GetType,,,6,int config_GetType (char*)
13605,METHOD,config\core.c:<global>,TYPE_DECL,"bool config_IsSafe( const char *name )
{
    module_config_t *p_config = config_FindConfig( name );
    return p_config != NULL && p_config->b_safe;
}",1,1,config\core.c,config_IsSafe,,false,79,83,config_IsSafe,,,7,bool config_IsSafe (char*)
13623,METHOD,config\core.c:<global>,TYPE_DECL,"int64_t config_GetInt( vlc_object_t *p_this, const char *psz_name )
{
    module_config_t *p_config = config_FindConfig( psz_name );

    /* sanity checks */
    if( !p_config )
    {
        msg_Err( p_this, ""option %s does not exist"", psz_name );
        return -1;
    }

    assert(IsConfigIntegerType(p_config->i_type));

    int64_t val;

    vlc_rwlock_rdlock (&config_lock);
    val = p_config->value.i;
    vlc_rwlock_unlock (&config_lock);
    return val;
}",1,11,config\core.c,config_GetInt,,false,93,112,config_GetInt,,,8,"int64_t config_GetInt (vlc_object_t*,char*)"
13674,METHOD,config\core.c:<global>,TYPE_DECL,"float config_GetFloat( vlc_object_t *p_this, const char *psz_name )
{
    module_config_t *p_config;

    p_config = config_FindConfig( psz_name );

    /* sanity checks */
    if( !p_config )
    {
        msg_Err( p_this, ""option %s does not exist"", psz_name );
        return -1;
    }

    assert(IsConfigFloatType(p_config->i_type));

    float val;

    vlc_rwlock_rdlock (&config_lock);
    val = p_config->value.f;
    vlc_rwlock_unlock (&config_lock);
    return val;
}",1,11,config\core.c,config_GetFloat,,false,121,142,config_GetFloat,,,9,"float config_GetFloat (vlc_object_t*,char*)"
13723,METHOD,config\core.c:<global>,TYPE_DECL,"char * config_GetPsz( vlc_object_t *p_this, const char *psz_name )
{
    module_config_t *p_config;

    p_config = config_FindConfig( psz_name );

    /* sanity checks */
    if( !p_config )
    {
        msg_Err( p_this, ""option %s does not exist"", psz_name );
        return NULL;
    }

    assert(IsConfigStringType (p_config->i_type));

    /* return a copy of the string */
    vlc_rwlock_rdlock (&config_lock);
    char *psz_value = strdupnull (p_config->value.psz);
    vlc_rwlock_unlock (&config_lock);

    return psz_value;
}",1,11,config\core.c,config_GetPsz,,false,156,177,config_GetPsz,,,10,"char* config_GetPsz (vlc_object_t*,char*)"
13774,METHOD,config\core.c:<global>,TYPE_DECL,"void config_PutPsz( vlc_object_t *p_this,
                      const char *psz_name, const char *psz_value )
{
    module_config_t *p_config = config_FindConfig( psz_name );


    /* sanity checks */
    if( !p_config )
    {
        msg_Warn( p_this, ""option %s does not exist"", psz_name );
        return;
    }

    assert(IsConfigStringType(p_config->i_type));

    char *str, *oldstr;
    if ((psz_value != NULL) && *psz_value)
        str = strdup (psz_value);
    else
        str = NULL;

    vlc_rwlock_wrlock (&config_lock);
    oldstr = (char *)p_config->value.psz;
    p_config->value.psz = str;
    config_dirty = true;
    vlc_rwlock_unlock (&config_lock);

    free (oldstr);
}",1,11,config\core.c,config_PutPsz,,false,187,215,config_PutPsz,,,11,"void config_PutPsz (vlc_object_t*,char*,char*)"
13854,METHOD,config\core.c:<global>,TYPE_DECL,"void config_PutInt( vlc_object_t *p_this, const char *psz_name,
                    int64_t i_value )
{
    module_config_t *p_config = config_FindConfig( psz_name );

    /* sanity checks */
    if( !p_config )
    {
        msg_Warn( p_this, ""option %s does not exist"", psz_name );
        return;
    }

    assert(IsConfigIntegerType(p_config->i_type));

    if (i_value < p_config->min.i)
        i_value = p_config->min.i;
    if (i_value > p_config->max.i)
        i_value = p_config->max.i;

    vlc_rwlock_wrlock (&config_lock);
    p_config->value.i = i_value;
    config_dirty = true;
    vlc_rwlock_unlock (&config_lock);
}",1,11,config\core.c,config_PutInt,,false,225,248,config_PutInt,,,12,"void config_PutInt (vlc_object_t*,char*,int64_t)"
13936,METHOD,config\core.c:<global>,TYPE_DECL,"void config_PutFloat( vlc_object_t *p_this,
                      const char *psz_name, float f_value )
{
    module_config_t *p_config = config_FindConfig( psz_name );

    /* sanity checks */
    if( !p_config )
    {
        msg_Warn( p_this, ""option %s does not exist"", psz_name );
        return;
    }

    assert(IsConfigFloatType(p_config->i_type));

    /* if f_min == f_max == 0, then do not use them */
    if ((p_config->min.f == 0.f) && (p_config->max.f == 0.f))
        ;
    else if (f_value < p_config->min.f)
        f_value = p_config->min.f;
    else if (f_value > p_config->max.f)
        f_value = p_config->max.f;

    vlc_rwlock_wrlock (&config_lock);
    p_config->value.f = f_value;
    config_dirty = true;
    vlc_rwlock_unlock (&config_lock);
}",1,11,config\core.c,config_PutFloat,,false,257,283,config_PutFloat,,,13,"void config_PutFloat (vlc_object_t*,char*,float)"
14037,METHOD,config\core.c:<global>,TYPE_DECL,"ssize_t config_GetIntChoices (vlc_object_t *obj, const char *name,
                             int64_t **restrict values, char ***restrict texts)
{
    *values = NULL;
    *texts = NULL;

    module_config_t *cfg = config_FindConfig(name);
    if (cfg == NULL)
    {
        msg_Warn (obj, ""option %s does not exist"", name);
        errno = ENOENT;
        return -1;
    }

    size_t count = cfg->list_count;
    if (count == 0)
    {
        if (module_Map(obj, cfg->owner))
        {
            errno = EIO;
            return -1;
        }

        if (cfg->list.i_cb == NULL)
            return 0;
        return cfg->list.i_cb(obj, name, values, texts);
    }

    int64_t *vals = vlc_alloc (count, sizeof (*vals));
    char **txts = vlc_alloc (count, sizeof (*txts));
    if (vals == NULL || txts == NULL)
    {
        errno = ENOMEM;
        goto error;
    }

    for (size_t i = 0; i < count; i++)
    {
        vals[i] = cfg->list.i[i];
        /* FIXME: use module_gettext() instea...",1,1,config\core.c,config_GetIntChoices,,false,293,352,config_GetIntChoices,,,14,"ssize_t config_GetIntChoices (vlc_object_t*,char*,int64_t**,char***)"
14238,METHOD,config\core.c:<global>,TYPE_DECL,"static ssize_t config_ListModules (const char *cap, char ***restrict values,
                                   char ***restrict texts)
{
    module_t **list;
    ssize_t n = module_list_cap (&list, cap);
    if (unlikely(n < 0))
    {
        *values = *texts = NULL;
        return n;
    }

    char **vals = xmalloc ((n + 2) * sizeof (*vals));
    char **txts = xmalloc ((n + 2) * sizeof (*txts));

    vals[0] = xstrdup (""any"");
    txts[0] = xstrdup (_(""Automatic""));

    for (ssize_t i = 0; i < n; i++)
    {
        vals[i + 1] = xstrdup (module_get_object (list[i]));
        txts[i + 1] = xstrdup (module_gettext (list[i],
                               module_get_name (list[i], true)));
    }

    vals[n + 1] = xstrdup (""none"");
    txts[n + 1] = xstrdup (_(""Disable""));

    *values = vals;
    *texts = txts;
    module_list_free (list);
    return n + 2;
}",1,1,config\core.c,config_ListModules,,false,355,386,config_ListModules,,,15,"ssize_t config_ListModules (char*,char***,char***)"
14373,METHOD,config\core.c:<global>,TYPE_DECL,"ssize_t config_GetPszChoices (vlc_object_t *obj, const char *name,
                              char ***restrict values, char ***restrict texts)
{
    *values = *texts = NULL;

    module_config_t *cfg = config_FindConfig(name);
    if (cfg == NULL)
    {
        errno = ENOENT;
        return -1;
    }

    switch (cfg->i_type)
    {
        case CONFIG_ITEM_MODULE:
            return config_ListModules (cfg->psz_type, values, texts);
        default:
            if (!IsConfigStringType (cfg->i_type))
            {
                errno = EINVAL;
                return -1;
            }
            break;
    }

    size_t count = cfg->list_count;
    if (count == 0)
    {
        if (module_Map(obj, cfg->owner))
        {
            errno = EIO;
            return -1;
        }

        if (cfg->list.psz_cb == NULL)
            return 0;
        return cfg->list.psz_cb(obj, name, values, texts);
    }

    char **vals = xmalloc (sizeof (*vals) * count);
    char **txts = xmalloc...",1,17,config\core.c,config_GetPszChoices,,false,397,450,config_GetPszChoices,,,16,"ssize_t config_GetPszChoices (vlc_object_t*,char*,char***,char***)"
14570,METHOD,config\core.c:<global>,TYPE_DECL,"static int confcmp (const void *a, const void *b)
{
    const module_config_t *const *ca = a, *const *cb = b;

    return strcmp ((*ca)->psz_name, (*cb)->psz_name);
}",1,1,config\core.c,confcmp,,false,452,457,confcmp,,,17,"int confcmp (void*,void*)"
14594,METHOD,config\core.c:<global>,TYPE_DECL,"static int confnamecmp (const void *key, const void *elem)
{
    const module_config_t *const *conf = elem;

    return strcmp (key, (*conf)->psz_name);
}",1,1,config\core.c,confnamecmp,,false,459,464,confnamecmp,,,18,"int confnamecmp (void*,void*)"
14620,METHOD,config\core.c:<global>,TYPE_DECL,"int config_SortConfig (void)
{
    vlc_plugin_t *p;
    size_t nconf = 0;

    for (p = vlc_plugins; p != NULL; p = p->next)
         nconf += p->conf.size;

    module_config_t **clist = vlc_alloc (nconf, sizeof (*clist));
    if (unlikely(clist == NULL))
        return VLC_ENOMEM;

    nconf = 0;
    for (p = vlc_plugins; p != NULL; p = p->next)
    {
        module_config_t *item, *end;

        for (item = p->conf.items, end = item + p->conf.size;
             item < end;
             item++)
        {
            if (!CONFIG_ITEM(item->i_type))
                continue; /* ignore hints */
            clist[nconf++] = item;
        }
    }

    qsort (clist, nconf, sizeof (*clist), confcmp);

    config.list = clist;
    config.count = nconf;
    return VLC_SUCCESS;
}",1,1,config\core.c,config_SortConfig,,false,475,507,config_SortConfig,,,22,int config_SortConfig (void)
14743,METHOD,config\core.c:<global>,TYPE_DECL,"void config_UnsortConfig (void)
{
    module_config_t **clist;

    clist = config.list;
    config.list = NULL;
    config.count = 0;

    free (clist);
}",1,1,config\core.c,config_UnsortConfig,,false,509,518,config_UnsortConfig,,,23,void config_UnsortConfig (void)
14766,METHOD,config\core.c:<global>,TYPE_DECL,"module_config_t *config_FindConfig(const char *name)
{
    if (unlikely(name == NULL))
        return NULL;

    module_config_t *const *p;
    p = bsearch (name, config.list, config.count, sizeof (*p), confnamecmp);
    return p ? *p : NULL;
}",1,1,config\core.c,config_FindConfig,,false,523,531,config_FindConfig,,,24,module_config_t config_FindConfig (char*)
14800,METHOD,config\core.c:<global>,TYPE_DECL,"void config_Free (module_config_t *tab, size_t confsize)
{
    for (size_t j = 0; j < confsize; j++)
    {
        module_config_t *p_item = &tab[j];

        if (IsConfigStringType (p_item->i_type))
        {
            free (p_item->value.psz);
            if (p_item->list_count)
                free (p_item->list.psz);
        }

        free (p_item->list_text);
    }

    free (tab);
}",1,12,config\core.c,config_Free,,false,538,555,config_Free,,,25,"void config_Free (module_config_t*,size_t)"
14862,METHOD,config\core.c:<global>,TYPE_DECL,"void config_ResetAll( vlc_object_t *p_this )
{
    vlc_rwlock_wrlock (&config_lock);
    for (vlc_plugin_t *p = vlc_plugins; p != NULL; p = p->next)
    {
        for (size_t i = 0; i < p->conf.size; i++ )
        {
            module_config_t *p_config = p->conf.items + i;

            if (IsConfigIntegerType (p_config->i_type))
                p_config->value.i = p_config->orig.i;
            else
            if (IsConfigFloatType (p_config->i_type))
                p_config->value.f = p_config->orig.f;
            else
            if (IsConfigStringType (p_config->i_type))
            {
                free ((char *)p_config->value.psz);
                p_config->value.psz =
                        strdupnull (p_config->orig.psz);
            }
        }
    }
    vlc_rwlock_unlock (&config_lock);

    VLC_UNUSED(p_this);
}",1,16,config\core.c,config_ResetAll,,false,561,587,config_ResetAll,,,26,void config_ResetAll (vlc_object_t*)
15041,METHOD,config\file.c:<global>,TYPE_DECL,<global>,1,24,config\file.c,config\file.c:<global>,,false,1,541,<global>,,,1,
15043,METHOD,config\file.c:<global>,TYPE_DECL,"static inline char *strdupnull (const char *src)
{
    return src ? strdup (src) : NULL;
}",1,1,config\file.c,strdupnull,,false,51,54,strdupnull,,,1,char* strdupnull (char*)
15054,METHOD,config\file.c:<global>,TYPE_DECL,"static char *config_GetConfigFile( vlc_object_t *obj )
{
    char *psz_file = var_CreateGetNonEmptyString( obj, ""config"" );
    var_Destroy( obj, ""config"" );
    if( psz_file == NULL )
    {
        char *psz_dir = config_GetUserDir( VLC_CONFIG_DIR );

        if( asprintf( &psz_file, ""%s"" DIR_SEP CONFIG_FILE, psz_dir ) == -1 )
            psz_file = NULL;
        free( psz_dir );
    }
    return psz_file;
}",1,46,config\file.c,config_GetConfigFile,,false,59,72,config_GetConfigFile,,,2,char* config_GetConfigFile (vlc_object_t*)
15088,METHOD,config\file.c:<global>,TYPE_DECL,"static FILE *config_OpenConfigFile( vlc_object_t *p_obj )
{
    char *psz_filename = config_GetConfigFile( p_obj );
    if( psz_filename == NULL )
        return NULL;

    msg_Dbg( p_obj, ""opening config file (%s)"", psz_filename );

    FILE *p_stream = vlc_fopen( psz_filename, ""rt"" );
    if( p_stream == NULL && errno != ENOENT )
    {
        msg_Err( p_obj, ""cannot open config file (%s): %s"",
                 psz_filename, vlc_strerror_c(errno) );

    }
#if !( defined(_WIN32) || defined(__APPLE__) || defined(__OS2__) )
    else if( p_stream == NULL && errno == ENOENT )
    {
        /* This is the fallback for pre XDG Base Directory
         * Specification configs */
        char *home = config_GetUserDir(VLC_HOME_DIR);
        char *psz_old;

        if( home != NULL
         && asprintf( &psz_old, ""%s/.vlc/"" CONFIG_FILE,
                      home ) != -1 )
        {
            p_stream = vlc_fopen( psz_old, ""rt"" );
            if( p_stream )
            {
                /...",1,43,config\file.c,config_OpenConfigFile,,false,74,138,config_OpenConfigFile,,,3,FILE config_OpenConfigFile (vlc_object_t*)
15212,METHOD,config\file.c:<global>,TYPE_DECL,"static int64_t vlc_strtoi (const char *str)
{
    char *end;
    long long l;

    errno = 0;
    l = strtoll (str, &end, 0);

    if (!errno)
    {
#if (LLONG_MAX > 0x7fffffffffffffffLL)
        if (l > 0x7fffffffffffffffLL
         || l < -0x8000000000000000LL)
            errno = ERANGE;
#endif
        if (*end)
            errno = EINVAL;
    }
    return l;
}",1,1,config\file.c,vlc_strtoi,,false,141,160,vlc_strtoi,,,4,int64_t vlc_strtoi (char*)
15242,METHOD,config\file.c:<global>,TYPE_DECL,"int config_LoadConfigFile( vlc_object_t *p_this )
{
    FILE *file;

    file = config_OpenConfigFile (p_this);
    if (file == NULL)
        return VLC_EGENERIC;

    /* Skip UTF-8 Byte Order Mark if present */
    char bom[3];
    if (fread (bom, 1, 3, file) != 3 || memcmp (bom, ""\xEF\xBB\xBF"", 3))
        rewind (file); /* no BOM, rewind */

    char *line = NULL;
    size_t bufsize;
    ssize_t linelen;

    /* Ensure consistent number formatting... */
    locale_t loc = newlocale (LC_NUMERIC_MASK, ""C"", NULL);
    locale_t baseloc = uselocale (loc);

    vlc_rwlock_wrlock (&config_lock);
    while ((linelen = getline (&line, &bufsize, file)) != -1)
    {
        line[linelen - 1] = '\0'; /* trim newline */

        /* Ignore comments, section and empty lines */
        if (memchr (""#["", line[0], 3) != NULL)
            continue;

        /* look for option name */
        const char *psz_option_name = line;

        char *ptr = strchr (line, '=');
        if (ptr == NULL)
      ...",1,16,config\file.c,config_LoadConfigFile,,false,169,261,config_LoadConfigFile,,,5,int config_LoadConfigFile (vlc_object_t*)
15497,METHOD,config\file.c:<global>,TYPE_DECL,"int config_CreateDir( vlc_object_t *p_this, const char *psz_dirname )
{
    if( !psz_dirname || !*psz_dirname ) return -1;

    if( vlc_mkdir( psz_dirname, 0700 ) == 0 )
        return 0;

    switch( errno )
    {
        case EEXIST:
            return 0;

        case ENOENT:
        {
            /* Let's try to create the parent directory */
            char psz_parent[strlen( psz_dirname ) + 1], *psz_end;
            strcpy( psz_parent, psz_dirname );

            psz_end = strrchr( psz_parent, DIR_SEP_CHAR );
            if( psz_end && psz_end != psz_parent )
            {
                *psz_end = '\0';
                if( config_CreateDir( p_this, psz_parent ) == 0 )
                {
                    if( !vlc_mkdir( psz_dirname, 0700 ) )
                        return 0;
                }
            }
        }
    }

    msg_Warn( p_this, ""could not create %s: %s"", psz_dirname,
              vlc_strerror_c(errno) );
    return -1;
}",1,1,config\file.c,config_CreateDir,,false,266,300,config_CreateDir,,,6,"int config_CreateDir (vlc_object_t*,char*)"
15578,METHOD,config\file.c:<global>,TYPE_DECL,"static int
config_Write (FILE *file, const char *desc, const char *type,
              bool comment, const char *name, const char *fmt, ...)
{
    va_list ap;
    int ret;

    if (desc == NULL)
        desc = ""?"";

    if (fprintf (file, ""# %s (%s)\n%s%s="", desc, vlc_gettext (type),
                 comment ? ""#"" : """", name) < 0)
        return -1;

    va_start (ap, fmt);
    ret = vfprintf (file, fmt, ap);
    va_end (ap);
    if (ret < 0)
        return -1;

    if (fputs (""\n\n"", file) == EOF)
        return -1;
    return 0;
}",1,1,config\file.c,config_Write,,false,302,325,config_Write,,,7,"int config_Write (FILE*,char*,char*,bool,char*,char*...)"
15647,METHOD,config\file.c:<global>,TYPE_DECL,"static int config_PrepareDir (vlc_object_t *obj)
{
    char *psz_configdir = config_GetUserDir (VLC_CONFIG_DIR);
    if (psz_configdir == NULL)
        return -1;

    int ret = config_CreateDir (obj, psz_configdir);
    free (psz_configdir);
    return ret;
}",1,1,config\file.c,config_PrepareDir,,false,328,337,config_PrepareDir,,,8,int config_PrepareDir (vlc_object_t*)
15675,METHOD,config\file.c:<global>,TYPE_DECL,"int config_SaveConfigFile (vlc_object_t *p_this)
{

    if( config_PrepareDir( p_this ) )
    {
        msg_Err( p_this, ""no configuration directory"" );
        return -1;
    }

    /*
     * Save module config in file
     */
    char *temporary;
    char *permanent = config_GetConfigFile (p_this);
    if (permanent == NULL)
        return -1;
    if (asprintf (&temporary, ""%s.%u"", permanent, getpid ()) == -1)
    {
        free (permanent);
        return -1;
    }
    else
    {
        struct stat st;

        /* Some users make vlcrc read-only to prevent changes.
         * The atomic replacement scheme breaks this ""feature"",
         * so we check for read-only by hand. */
        if (stat (permanent, &st) == 0 && !(st.st_mode & S_IWUSR))
        {
            msg_Err (p_this, ""configuration file is read-only"");
            goto error;
        }
    }

    /* Configuration lock must be taken before vlcrc serializer below. */
    vlc_rwlock_rdlock (&config_lock);

    /* The t...",1,16,config\file.c,config_SaveConfigFile,,false,344,523,config_SaveConfigFile,,,9,int config_SaveConfigFile (vlc_object_t*)
16096,METHOD,config\file.c:<global>,TYPE_DECL,"int config_AutoSaveConfigFile( vlc_object_t *p_this )
{
    int ret = 0;

    assert( p_this );

    vlc_rwlock_rdlock (&config_lock);
    if (config_dirty)
    {
        /* Note: this will get the read lock recursively. Ok. */
        ret = config_SaveConfigFile (p_this);
        config_dirty = (ret != 0);
    }
    vlc_rwlock_unlock (&config_lock);

    return ret;
}",1,1,config\file.c,config_AutoSaveConfigFile,,false,525,541,config_AutoSaveConfigFile,,,10,int config_AutoSaveConfigFile (vlc_object_t*)
16140,METHOD,config\getopt.c:<global>,TYPE_DECL,<global>,1,1,config\getopt.c,config\getopt.c:<global>,,false,1,479,<global>,,,1,
16142,METHOD,config\getopt.c:<global>,TYPE_DECL,"static void exchange(char **argv, vlc_getopt_t *restrict state)
{
    int bottom = state->first_nonopt;
    int middle = state->last_nonopt;
    int top = state->ind;
    char *tem;

    /* Exchange the shorter segment with the far end of the longer segment.
       That puts the shorter segment into the right place.
       It leaves the longer segment in the right place overall,
       but it consists of two parts that need to be swapped next.  */

    while (top > middle && middle > bottom)
    {
        if (top - middle > middle - bottom)
        {
            /* Bottom segment is the short one.  */
            int len = middle - bottom;
            register int i;

            /* Swap it with the top part of the top segment.  */
            for (i = 0; i < len; i++)
            {
                tem = argv[bottom + i];
                argv[bottom + i] = argv[top - (middle - bottom) + i];
                argv[top - (middle - bottom) + i] = tem;
            }
            /* Exclude...",1,1,config\getopt.c,exchange,,false,41,93,exchange,,,1,"void exchange (char**,vlc_getopt_t*)"
16305,METHOD,config\getopt.c:<global>,TYPE_DECL,"int vlc_getopt_long(int argc, char *const *argv,
                    const char *optstring,
                    const struct vlc_option *restrict longopts, int *longind,
                    vlc_getopt_t *restrict state)
{
    state->arg = NULL;

    if (state->ind == 0)
    {
        /* Initialize the internal data when the first call is made.  */
        /* Start processing options with ARGV-element 1 (since ARGV-element 0
           is the program name); the sequence of previously skipped
           non-option ARGV-elements is empty.  */
        state->first_nonopt = state->last_nonopt = state->ind = 1;
        state->nextchar = NULL;
    }

#define NONOPTION_P (argv[state->ind][0] != '-' || argv[state->ind][1] == '\0')

    if (state->nextchar == NULL || *state->nextchar == '\0')
    {
        /* Advance to the next ARGV-element.  */

        /* Give FIRST_NONOPT & LAST_NONOPT rational values if OPTIND has been
           moved back by the user (who may also have changed the argu...",1,36,config\getopt.c,vlc_getopt_long,,false,146,479,vlc_getopt_long,,,2,"int vlc_getopt_long (int,char**,char*,vlc_option*,int*,vlc_getopt_t*)"
17409,METHOD,config\help.c:<global>,TYPE_DECL,<global>,1,25,config\help.c,config\help.c:<global>,,false,1,772,<global>,,,1,
17411,METHOD,config\help.c:<global>,TYPE_DECL,"static void Help (vlc_object_t *, const char *);",13,47,config\help.c,Help,,false,58,58,Help,,,1,"void Help (vlc_object_t*,char*)"
17417,METHOD,config\help.c:<global>,TYPE_DECL,"static void Usage (vlc_object_t *, const char *);",13,48,config\help.c,Usage,,false,59,59,Usage,,,2,"void Usage (vlc_object_t*,char*)"
17423,METHOD,config\help.c:<global>,TYPE_DECL,static void Version (void);,13,26,config\help.c,Version,,false,60,60,Version,,,3,void Version (void)
17428,METHOD,config\help.c:<global>,TYPE_DECL,"static void ListModules (vlc_object_t *, bool);",13,46,config\help.c,ListModules,,false,61,61,ListModules,,,4,"void ListModules (vlc_object_t*,ANY)"
17434,METHOD,config\help.c:<global>,TYPE_DECL,"static unsigned ConsoleWidth(void)
{
#ifdef TIOCGWINSZ
    struct winsize ws;

    if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &ws) == 0)
        return ws.ws_col;
#endif
#ifdef WIOCGETD
    struct uwdata uw;

    if (ioctl(STDOUT_FILENO, WIOCGETD, &uw) == 0)
        return uw.uw_height / uw.uw_vs;
#endif
#if defined (_WIN32) && !VLC_WINSTORE_APP
    CONSOLE_SCREEN_BUFFER_INFO buf;

    if (GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &buf))
        return buf.dwSize.X;
#endif
    return 80;
}",1,1,config\help.c,ConsoleWidth,,false,66,87,ConsoleWidth,,,5,unsigned ConsoleWidth (void)
17441,METHOD,config\help.c:<global>,TYPE_DECL,"bool config_PrintHelp (vlc_object_t *obj)
{
    char *str;

    /* Check for short help option */
    if (var_InheritBool (obj, ""help""))
    {
        Help (obj, ""help"");
        return true;
    }

    /* Check for version option */
    if (var_InheritBool (obj, ""version""))
    {
        Version();
        return true;
    }

    /* Check for help on modules */
    str = var_InheritString (obj, ""module"");
    if (str != NULL)
    {
        Help (obj, str);
        free (str);
        return true;
    }

    /* Check for full help option */
    if (var_InheritBool (obj, ""full-help""))
    {
        var_Create (obj, ""advanced"", VLC_VAR_BOOL);
        var_SetBool (obj, ""advanced"", true);
        var_Create (obj, ""help-verbose"", VLC_VAR_BOOL);
        var_SetBool (obj, ""help-verbose"", true);
        Help (obj, ""full-help"");
        return true;
    }

    /* Check for long help option */
    if (var_InheritBool (obj, ""longhelp""))
    {
        Help (obj, ""longhelp"");
        return true...",1,1,config\help.c,config_PrintHelp,,false,95,154,config_PrintHelp,,,6,bool config_PrintHelp (vlc_object_t*)
17540,METHOD,config\help.c:<global>,TYPE_DECL,"static inline void print_help_on_full_help( void )
{
    putchar('\n');
    puts(_(""To get exhaustive help, use '-H'.""));
}",1,1,config\help.c,print_help_on_full_help,,false,161,165,print_help_on_full_help,,,7,void print_help_on_full_help (void)
17555,METHOD,config\help.c:<global>,TYPE_DECL,"static void Help (vlc_object_t *p_this, char const *psz_help_name)
{
    ShowConsole();

    if( psz_help_name && !strcmp( psz_help_name, ""help"" ) )
    {
        printf(_(vlc_usage), ""vlc"");
        Usage( p_this, ""=core"" );
        print_help_on_full_help();
    }
    else if( psz_help_name && !strcmp( psz_help_name, ""longhelp"" ) )
    {
        printf(_(vlc_usage), ""vlc"");
        Usage( p_this, NULL );
        print_help_on_full_help();
    }
    else if( psz_help_name && !strcmp( psz_help_name, ""full-help"" ) )
    {
        printf(_(vlc_usage), ""vlc"");
        Usage( p_this, NULL );
    }
    else if( psz_help_name )
    {
        Usage( p_this, psz_help_name );
    }

    PauseConsole();
}",1,4,config\help.c,Help,,false,201,228,Help,,,10,"void Help (vlc_object_t*,char*)"
17630,METHOD,config\help.c:<global>,TYPE_DECL,"static void print_section(const module_t *m, const module_config_t **sect,
                          bool color, bool desc)
{
    const module_config_t *item = *sect;

    if (item == NULL)
        return;
    *sect = NULL;

    printf(color ? RED""   %s:\n""GRAY : ""   %s:\n"",
           module_gettext(m, item->psz_text));
    if (desc && item->psz_longtext != NULL)
        printf(color ? MAGENTA""   %s\n""GRAY : ""   %s\n"",
               module_gettext(m, item->psz_longtext));
}",1,19,config\help.c,print_section,,false,247,261,print_section,,,11,"void print_section (module_t*,module_config_t**,bool,bool)"
17686,METHOD,config\help.c:<global>,TYPE_DECL,"static void print_desc(const char *str, unsigned margin, bool color)
{
    unsigned width = ConsoleWidth() - margin;

    if (color)
        fputs(BLUE, stdout);

    const char *word = str;
    int wordlen = 0, wordwidth = 0;
    unsigned offset = 0;
    bool newline = true;

    while (str[0])
    {
        uint32_t cp;
        size_t charlen = vlc_towc(str, &cp);
        if (unlikely(charlen == (size_t)-1))
            break;

        int charwidth = wcwidth(cp);
        if (charwidth < 0)
            charwidth = 0;

        str += charlen;

        if (iswspace(cp))
        {
            if (!newline)
            {
                putchar(' '); /* insert space */
                charwidth = 1;
            }
            fwrite(word, 1, wordlen, stdout); /* write complete word */
            word = str;
            wordlen = 0;
            wordwidth = 0;
            newline = false;
        }
        else
        {
            wordlen += charlen;
            wordwidth += charwidth...",1,14,config\help.c,print_desc,,false,263,326,print_desc,,,12,"void print_desc (char*,unsigned,bool)"
17854,METHOD,config\help.c:<global>,TYPE_DECL,"static int vlc_swidth(const char *str)
{
    for (int total = 0;;)
    {
        uint32_t cp;
        size_t charlen = vlc_towc(str, &cp);

        if (charlen == 0)
            return total;
        if (charlen == (size_t)-1)
            return -1;
        str += charlen;

        int w = wcwidth(cp);
        if (w == -1)
            return -1;
        total += w;
    }
}",1,1,config\help.c,vlc_swidth,,false,328,346,vlc_swidth,,,13,int vlc_swidth (char*)
17911,METHOD,config\help.c:<global>,TYPE_DECL,"static void print_item(const vlc_object_t *p_this, const module_t *m, const module_config_t *item,
                       const module_config_t **section, bool color, bool desc)
{
#ifndef _WIN32
# define OPTION_VALUE_SEP "" ""
#else
# define OPTION_VALUE_SEP ""=""
#endif
    const char *bra = OPTION_VALUE_SEP ""<"", *type, *ket = "">"";
    const char *prefix = NULL, *suffix = NULL;
    char *typebuf = NULL;

    switch (CONFIG_CLASS(item->i_type))
    {
        case 0: // hint class
            switch (item->i_type)
            {
                case CONFIG_HINT_CATEGORY:
                case CONFIG_HINT_USAGE:
                    printf(color ? GREEN ""\n %s\n"" GRAY : ""\n %s\n"",
                           module_gettext(m, item->psz_text));

                    if (desc && item->psz_longtext != NULL)
                        printf(color ? CYAN "" %s\n"" GRAY : "" %s\n"",
                               module_gettext(m, item->psz_longtext));
                    break;

                case CONF...",1,22,config\help.c,print_item,,false,348,544,print_item,,,14,"void print_item (vlc_object_t*,module_t*,module_config_t*,module_config_t**,bool,bool)"
18586,METHOD,config\help.c:<global>,TYPE_DECL,"static bool module_match(const module_t *m, const char *pattern, bool strict)
{
    if (pattern == NULL)
        return true;

    const char *objname = module_get_object(m);

    if (strict ? (strcmp(objname, pattern) == 0)
               : (strstr(objname, pattern) != NULL))
        return true;

    for (unsigned i = 0; i < m->i_shortcuts; i++)
    {
        const char *shortcut = m->pp_shortcuts[i];

        if (strict ? (strcmp(shortcut, pattern) == 0)
                   : (strstr(shortcut, pattern) != NULL))
            return true;
    }
    return false;
}",1,1,config\help.c,module_match,,false,546,566,module_match,,,15,"bool module_match (module_t*,char*,bool)"
18661,METHOD,config\help.c:<global>,TYPE_DECL,"static bool plugin_show(const vlc_plugin_t *plugin, bool advanced)
{
    for (size_t i = 0; i < plugin->conf.size; i++)
    {
        const module_config_t *item = plugin->conf.items + i;

        if (!CONFIG_ITEM(item->i_type))
            continue;
        if (item->b_removed)
            continue;
        if ((!advanced) && item->b_advanced)
            continue;
        return true;
    }
    return false;
}",1,1,config\help.c,plugin_show,,false,568,583,plugin_show,,,16,"bool plugin_show (vlc_plugin_t*,bool)"
18720,METHOD,config\help.c:<global>,TYPE_DECL,"static void Usage (vlc_object_t *p_this, char const *psz_search)
{
    bool b_has_advanced = false;
    bool found = false;
    unsigned i_only_advanced = 0; /* Number of modules ignored because they
                               * only have advanced options */
    bool strict = false;
    if (psz_search != NULL && psz_search[0] == '=')
    {
        strict = true;
        psz_search++;
    }

    bool color = false;
#ifndef _WIN32
    if (isatty(STDOUT_FILENO))
        color = var_InheritBool(p_this, ""color"");
#endif

    const bool desc = var_InheritBool(p_this, ""help-verbose"");
    const bool advanced = var_InheritBool(p_this, ""advanced"");

    /* Enumerate the config for each module */
    for (const vlc_plugin_t *p = vlc_plugins; p != NULL; p = p->next)
    {
        const module_t *m = p->module;
        const module_config_t *section = NULL;
        const char *objname = module_get_object(m);

        if (p->conf.count == 0)
            continue; /* Ignore modules without co...",1,29,config\help.c,Usage,,false,585,665,Usage,,,17,"void Usage (vlc_object_t*,char*)"
18968,METHOD,config\help.c:<global>,TYPE_DECL,"static void ListModules (vlc_object_t *p_this, bool b_verbose)
{
    bool color = false;

    ShowConsole();
#ifndef _WIN32
    if (isatty(STDOUT_FILENO))
        color = var_InheritBool(p_this, ""color"");
#else
    (void) p_this;
#endif

    /* List all modules */
    size_t count;
    module_t **list = module_list_get (&count);

    /* Enumerate each module */
    for (size_t j = 0; j < count; j++)
    {
        module_t *p_parser = list[j];
        const char *objname = module_get_object (p_parser);
        printf(color ? GREEN""  %-22s ""WHITE""%s\n""GRAY : ""  %-22s %s\n"",
               objname, module_gettext(p_parser, p_parser->psz_longname));

        if( b_verbose )
        {
            const char *const *pp_shortcuts = p_parser->pp_shortcuts;
            for( unsigned i = 0; i < p_parser->i_shortcuts; i++ )
                if( strcmp( pp_shortcuts[i], objname ) )
                    printf(color ? CYAN""   s %s\n""GRAY : ""   s %s\n"",
                           pp_shortcuts[i]);
...",1,4,config\help.c,ListModules,,false,673,711,ListModules,,,18,"void ListModules (vlc_object_t*,bool)"
19101,METHOD,config\help.c:<global>,TYPE_DECL,"static void Version( void )
{
    ShowConsole();
    printf(_(""VLC version %s (%s)\n""), VERSION_MESSAGE, psz_vlc_changeset);
    printf(_(""Compiled by %s on %s (%s)\n""), VLC_CompileBy(),
           VLC_CompileHost(), __DATE__"" ""__TIME__ );
    printf(_(""Compiler: %s\n""), VLC_Compiler());
    fputs(LICENSE_MSG, stdout);
    PauseConsole();
}",1,4,config\help.c,Version,,false,718,727,Version,,,19,void Version (void)
19145,METHOD,config\intf.c:<global>,TYPE_DECL,<global>,1,2,config\intf.c,config\intf.c:<global>,,false,1,179,<global>,,,1,
19147,METHOD,config\intf.c:<global>,TYPE_DECL,"void config_AddIntf( vlc_object_t *p_this, const char *psz_intf )
{
    vlc_object_t *libvlc = VLC_OBJECT(p_this->obj.libvlc);

    assert( psz_intf );

    char *psz_config, *psz_parser;
    size_t i_len = strlen( psz_intf );

    psz_config = psz_parser = config_GetPsz( libvlc, ""control"" );
    while( psz_parser )
    {
        if( !strncmp( psz_intf, psz_parser, i_len ) )
        {
            free( psz_config );
            return;
        }
        psz_parser = strchr( psz_parser, ':' );
        if( psz_parser ) psz_parser++; /* skip the ':' */
    }
    free( psz_config );

    psz_config = psz_parser = config_GetPsz( libvlc, ""extraintf"" );
    while( psz_parser )
    {
        if( !strncmp( psz_intf, psz_parser, i_len ) )
        {
            free( psz_config );
            return;
        }
        psz_parser = strchr( psz_parser, ':' );
        if( psz_parser ) psz_parser++; /* skip the ':' */
    }

    /* interface not found in the config, let's add it */
    if( psz_con...",1,1,config\intf.c,config_AddIntf,,false,34,82,config_AddIntf,,,1,"void config_AddIntf (vlc_object_t*,char*)"
19267,METHOD,config\intf.c:<global>,TYPE_DECL,"void config_RemoveIntf( vlc_object_t *p_this, const char *psz_intf )
{
    vlc_object_t *libvlc = VLC_OBJECT(p_this->obj.libvlc);

    assert( psz_intf );

    char *psz_config, *psz_parser;
    size_t i_len = strlen( psz_intf );

    psz_config = psz_parser = config_GetPsz( libvlc, ""extraintf"" );
    while( psz_parser )
    {
        if( !strncmp( psz_intf, psz_parser, i_len ) )
        {
            char *psz_newconfig;
            char *psz_end = psz_parser + i_len;
            if( *psz_end == ':' ) psz_end++;
            *psz_parser = '\0';
            if( asprintf( &psz_newconfig, ""%s%s"", psz_config, psz_end ) != -1 )
            {
                config_PutPsz( libvlc, ""extraintf"", psz_newconfig );
                free( psz_newconfig );
            }
            break;
        }
        psz_parser = strchr( psz_parser, ':' );
        if( psz_parser ) psz_parser++; /* skip the ':' */
    }
    free( psz_config );

    psz_config = psz_parser = config_GetPsz( libvlc, ""control"" )...",1,1,config\intf.c,config_RemoveIntf,,false,86,136,config_RemoveIntf,,,2,"void config_RemoveIntf (vlc_object_t*,char*)"
19423,METHOD,config\intf.c:<global>,TYPE_DECL,"bool config_ExistIntf( vlc_object_t *p_this, const char *psz_intf )
{
    vlc_object_t *libvlc = VLC_OBJECT(p_this->obj.libvlc);

    assert( psz_intf );

    char *psz_config, *psz_parser;
    size_t i_len = strlen( psz_intf );

    psz_config = psz_parser = config_GetPsz( libvlc, ""extraintf"" );
    while( psz_parser )
    {
        if( !strncmp( psz_parser, psz_intf, i_len ) )
        {
            free( psz_config );
            return true;
        }
        psz_parser = strchr( psz_parser, ':' );
        if( psz_parser ) psz_parser++; /* skip the ':' */
    }
    free( psz_config );

    psz_config = psz_parser = config_GetPsz( libvlc, ""control"" );
    while( psz_parser )
    {
        if( !strncmp( psz_parser, psz_intf, i_len ) )
        {
            free( psz_config );
            return true;
        }
        psz_parser = strchr( psz_parser, ':' );
        if( psz_parser ) psz_parser++; /* skip the ':' */
    }
    free( psz_config );

    return false;
}",1,1,config\intf.c,config_ExistIntf,,false,143,179,config_ExistIntf,,,3,"bool config_ExistIntf (vlc_object_t*,char*)"
19518,METHOD,config\vlc_getopt.h:<global>,TYPE_DECL,<global>,1,40,config\vlc_getopt.h,config\vlc_getopt.h:<global>,,false,1,103,<global>,,,1,
19533,METHOD,config\vlc_getopt.h:<global>,TYPE_DECL,"extern int vlc_getopt_long(int argc, char *const *argv, const char *shortopts,
                           const struct vlc_option *longopts, int *longind,
                           vlc_getopt_t *restrict state);",12,56,config\vlc_getopt.h,vlc_getopt_long,,false,99,101,vlc_getopt_long,,,4,"int vlc_getopt_long (int,char**,char*,vlc_option*,int*,vlc_getopt_t*)"
19560,METHOD,darwin\dirs.c:<global>,TYPE_DECL,<global>,1,24,darwin\dirs.c,darwin\dirs.c:<global>,,false,1,212,<global>,,,1,
19562,METHOD,darwin\dirs.c:<global>,TYPE_DECL,"char *config_GetLibDir (void)
{
    /* Get the full program path and name */
    /* First try to see if we are linked to the framework */
    for (unsigned i = 0; i < _dyld_image_count(); i++)
    {
        const char *psz_img_name = _dyld_get_image_name(i);
        const char *p = strstr( psz_img_name, ""VLCKit.framework/Versions/"" );

        /* Check for ""VLCKit.framework/Versions/Current/VLCKit"",
         * as well as ""VLCKit.framework/Versions/A/VLCKit"" and
         * ""VLC.framework/Versions/B/VLCKit"" */
        if (p != NULL) {
            /* Look for the next forward slash */
            p += 26; /* p_char += strlen("" VLCKit.framework/Versions/"" ) */
            p += strcspn( p, ""/"" );

            /* If the string ends with VLCKit then we've found a winner */
            if (!strcmp( p, ""/VLCKit""))
                return strdup( dirname(psz_img_name) );
        }

        /* Do we end by ""VLC""? If so we are the legacy VLC.app that doesn't
         * link to VLCKit. */
       ...",1,1,darwin\dirs.c,config_GetLibDir,,false,39,93,config_GetLibDir,,,1,char* config_GetLibDir (void)
19717,METHOD,darwin\dirs.c:<global>,TYPE_DECL,"char *config_GetDataDir (void)
{
    const char *path = getenv (""VLC_DATA_PATH"");
    if (path)
        return strdup (path);

    char *vlcpath = config_GetLibDir ();
    char *datadir;

    if (asprintf (&datadir, ""%s/share"", vlcpath) == -1)
        datadir = NULL;

    free (vlcpath);
    return datadir;
}",1,1,darwin\dirs.c,config_GetDataDir,,false,95,109,config_GetDataDir,,,2,char* config_GetDataDir (void)
19755,METHOD,darwin\dirs.c:<global>,TYPE_DECL,"static char *config_GetHomeDir (void)
{
    const char *home = getenv (""HOME"");

    if (home == NULL)
        home = ""/tmp"";

    return strdup (home);
}",1,1,darwin\dirs.c,config_GetHomeDir,,false,111,119,config_GetHomeDir,,,3,char* config_GetHomeDir (void)
19776,METHOD,darwin\dirs.c:<global>,TYPE_DECL,"static char *getAppDependentDir(vlc_userdir_t type)
{
    const char *psz_path;
    switch (type) {
        case VLC_CONFIG_DIR:
            psz_path = ""%s/Library/Preferences/%s"";
            break;
        case VLC_TEMPLATES_DIR:
        case VLC_DATA_DIR:
            psz_path = ""%s/Library/Application Support/%s"";
            break;
        case VLC_CACHE_DIR:
            psz_path = ""%s/Library/Caches/%s"";
            break;
        default:
            vlc_assert_unreachable();
            break;
    }

    // Default fallback
    const char *fallback = ""org.videolan.vlc"";
    char *name = NULL;

    CFBundleRef mainBundle = CFBundleGetMainBundle();
    if (mainBundle) {
        CFStringRef identifierAsNS = CFBundleGetIdentifier(mainBundle);
        if (identifierAsNS) {
            CFIndex len = CFStringGetLength(identifierAsNS);
            CFIndex size = CFStringGetMaximumSizeForEncoding(len, kCFStringEncodingUTF8);
            char *identifier = calloc(len + 1, sizeof(char))...",1,1,darwin\dirs.c,getAppDependentDir,,false,121,169,getAppDependentDir,,,4,char* getAppDependentDir (vlc_userdir_t)
19902,METHOD,darwin\dirs.c:<global>,TYPE_DECL,"char *config_GetUserDir (vlc_userdir_t type)
{
    const char *psz_path;
    switch (type) {
        case VLC_CONFIG_DIR:
        case VLC_TEMPLATES_DIR:
        case VLC_DATA_DIR:
        case VLC_CACHE_DIR:
            return getAppDependentDir(type);

        case VLC_DESKTOP_DIR:
            psz_path = ""%s/Desktop"";
            break;
        case VLC_DOWNLOAD_DIR:
            psz_path = ""%s/Downloads"";
            break;
        case VLC_DOCUMENTS_DIR:
            psz_path = ""%s/Documents"";
            break;
        case VLC_MUSIC_DIR:
            psz_path = ""%s/Music"";
            break;
        case VLC_PICTURES_DIR:
            psz_path = ""%s/Pictures"";
            break;
        case VLC_VIDEOS_DIR:
            psz_path = ""%s/Movies"";
            break;
        case VLC_PUBLICSHARE_DIR:
            psz_path = ""%s/Public"";
            break;
        case VLC_HOME_DIR:
        default:
            psz_path = ""%s"";
    }
    char *psz_parent = config_GetHomeDir();
    char *p...",1,1,darwin\dirs.c,config_GetUserDir,,false,171,212,config_GetUserDir,,,5,char* config_GetUserDir (vlc_userdir_t)
20003,METHOD,darwin\error.c:<global>,TYPE_DECL,<global>,1,1,darwin\error.c,darwin\error.c:<global>,,false,1,43,<global>,,,1,
20005,METHOD,darwin\error.c:<global>,TYPE_DECL,"const char *vlc_strerror_c(int errnum)
{
    /* We cannot simply use strerror() here, since it is not thread-safe. */
    if ((unsigned)errnum < (unsigned)sys_nerr)
        return sys_errlist[errnum];

    return _(""Unknown error"");
}",1,1,darwin\error.c,vlc_strerror_c,,false,31,38,vlc_strerror_c,,,1,const char* vlc_strerror_c (int)
20026,METHOD,darwin\error.c:<global>,TYPE_DECL,"const char *vlc_strerror(int errnum)
{
    return vlc_strerror_c(errnum);
}",1,1,darwin\error.c,vlc_strerror,,false,40,43,vlc_strerror,,,2,const char* vlc_strerror (int)
20051,METHOD,darwin\netconf.c:<global>,TYPE_DECL,<global>,1,1,darwin\netconf.c,darwin\netconf.c:<global>,,false,1,73,<global>,,,1,
20053,METHOD,darwin\netconf.c:<global>,TYPE_DECL,"char *vlc_getProxyUrl(const char *url)
{
    VLC_UNUSED(url);
    char *proxy_url = NULL;
    CFDictionaryRef dicRef = CFNetworkCopySystemProxySettings();
    if (NULL != dicRef) {
        const CFStringRef proxyCFstr = (const CFStringRef)CFDictionaryGetValue(
            dicRef, (const void*)kCFNetworkProxiesHTTPProxy);
        const CFNumberRef portCFnum = (const CFNumberRef)CFDictionaryGetValue(
            dicRef, (const void*)kCFNetworkProxiesHTTPPort);
        if (NULL != proxyCFstr && NULL != portCFnum) {
            int port = 0;
            if (!CFNumberGetValue(portCFnum, kCFNumberIntType, &port)) {
                CFRelease(dicRef);
                return NULL;
            }

            char host_buffer[4096];
            memset(host_buffer, 0, sizeof(host_buffer));
            if (CFStringGetCString(proxyCFstr, host_buffer, sizeof(host_buffer)
                                   - 1, kCFStringEncodingUTF8))
                asprintf(&proxy_url, ""http://%s:%d"", host_buffer...",1,1,darwin\netconf.c,vlc_getProxyUrl,,false,45,73,vlc_getProxyUrl,,,1,char* vlc_getProxyUrl (char*)
20159,METHOD,darwin\specific.c:<global>,TYPE_DECL,<global>,1,24,darwin\specific.c,darwin\specific.c:<global>,,false,1,83,<global>,,,1,
20161,METHOD,darwin\specific.c:<global>,TYPE_DECL,"void system_Init(void)
{
#ifdef ENABLE_NLS
    /* Check if $LANG is set. */
    if( NULL == getenv(""LANG"") )
    {
        /*
           Retrieve the preferred language as chosen in  System Preferences.app
           (note that CFLocaleCopyCurrent() is not used because it returns the
            preferred locale not language)
        */
        CFArrayRef all_locales, preferred_locales;
        char psz_locale[50];

        all_locales = CFLocaleCopyAvailableLocaleIdentifiers();

        preferred_locales = CFBundleCopyLocalizationsForPreferences( all_locales, NULL );

        if ( preferred_locales )
        {
            if ( CFArrayGetCount( preferred_locales ) )
            {
                CFStringRef user_language_string_ref = CFArrayGetValueAtIndex( preferred_locales, 0 );
                CFStringGetCString( user_language_string_ref, psz_locale, sizeof(psz_locale), kCFStringEncodingUTF8 );
                setenv( ""LANG"", psz_locale, 1 );
            }
            CFRelease( ...",1,1,darwin\specific.c,system_Init,,false,41,72,system_Init,,,1,void system_Init (void)
20166,METHOD,darwin\specific.c:<global>,TYPE_DECL,"void system_Configure( libvlc_int_t *p_this,
                       int i_argc, const char *const ppsz_argv[] )
{
    (void)p_this;
    (void)i_argc;
    (void)ppsz_argv;
}",1,1,darwin\specific.c,system_Configure,,false,77,83,system_Configure,,,2,"void system_Configure (libvlc_int_t*,int,char[]*)"
20209,METHOD,darwin\thread.c:<global>,TYPE_DECL,<global>,1,1,darwin\thread.c,darwin\thread.c:<global>,,false,1,583,<global>,,,1,
20212,METHOD,darwin\thread.c:<global>,TYPE_DECL,"static void vlc_clock_setup_once (void)
{
    if (unlikely(mach_timebase_info (&vlc_clock_conversion_factor) != 0))
        abort ();
}",1,1,darwin\thread.c,vlc_clock_setup_once,,false,47,51,vlc_clock_setup_once,,,2,void vlc_clock_setup_once (void)
20230,METHOD,darwin\thread.c:<global>,TYPE_DECL,"static struct timespec mtime_to_ts (mtime_t date)
{
    lldiv_t d = lldiv (date, CLOCK_FREQ);
    struct timespec ts = { d.quot, d.rem * (1000000000 / CLOCK_FREQ) };

    return ts;
}",1,1,darwin\thread.c,mtime_to_ts,,false,58,64,mtime_to_ts,,,5,struct timespec mtime_to_ts (mtime_t)
20257,METHOD,darwin\thread.c:<global>,TYPE_DECL,"void vlc_trace (const char *fn, const char *file, unsigned line)
{
     fprintf (stderr, ""at %s:%u in %s\n"", file, line, fn);
     fflush (stderr); /* needed before switch to low-level I/O */
     void *stack[20];
     int len = backtrace (stack, sizeof (stack) / sizeof (stack[0]));
     backtrace_symbols_fd (stack, len, 2);
     fsync (2);
}",1,1,darwin\thread.c,vlc_trace,,false,67,75,vlc_trace,,,6,"void vlc_trace (char*,char*,unsigned)"
20291,METHOD,darwin\thread.c:<global>,TYPE_DECL,"static void
vlc_thread_fatal (const char *action, int error,
                  const char *function, const char *file, unsigned line)
{
    int canc = vlc_savecancel ();
    fprintf (stderr, ""LibVLC fatal error %s (%d) in thread %lu "",
             action, error, vlc_thread_id ());
    vlc_trace (function, file, line);

    char buf[1000];
    const char *msg;

    switch (strerror_r (error, buf, sizeof (buf)))
    {
        case 0:
            msg = buf;
            break;
        case ERANGE: /* should never happen */
            msg = ""unknown (too big to display)"";
            break;
        default:
            msg = ""unknown (invalid error number)"";
            break;
    }
    fprintf (stderr, "" Error message: %s\n"", msg);
    fflush (stderr);

    vlc_restorecancel (canc);
    abort ();
}",1,1,darwin\thread.c,vlc_thread_fatal,,false,79,108,vlc_thread_fatal,,,7,"void vlc_thread_fatal (char*,int,char*,char*,unsigned)"
20349,METHOD,darwin\thread.c:<global>,TYPE_DECL,"void vlc_mutex_init( vlc_mutex_t *p_mutex )
{
    pthread_mutexattr_t attr;

    if (unlikely(pthread_mutexattr_init (&attr)))
        abort();
#ifdef NDEBUG
    pthread_mutexattr_settype (&attr, PTHREAD_MUTEX_DEFAULT);
#else
    pthread_mutexattr_settype (&attr, PTHREAD_MUTEX_ERRORCHECK);
#endif
    if (unlikely(pthread_mutex_init (p_mutex, &attr)))
        abort();
    pthread_mutexattr_destroy( &attr );
}",1,1,darwin\thread.c,vlc_mutex_init,,false,118,132,vlc_mutex_init,,,8,void vlc_mutex_init (vlc_mutex_t*)
20377,METHOD,darwin\thread.c:<global>,TYPE_DECL,"void vlc_mutex_init_recursive( vlc_mutex_t *p_mutex )
{
    pthread_mutexattr_t attr;

    if (unlikely(pthread_mutexattr_init (&attr)))
        abort();
    pthread_mutexattr_settype (&attr, PTHREAD_MUTEX_RECURSIVE);
    if (unlikely(pthread_mutex_init (p_mutex, &attr)))
        abort();
    pthread_mutexattr_destroy( &attr );
}",1,1,darwin\thread.c,vlc_mutex_init_recursive,,false,134,144,vlc_mutex_init_recursive,,,9,void vlc_mutex_init_recursive (vlc_mutex_t*)
20405,METHOD,darwin\thread.c:<global>,TYPE_DECL,"void vlc_mutex_destroy (vlc_mutex_t *p_mutex)
{
    int val = pthread_mutex_destroy( p_mutex );
    VLC_THREAD_ASSERT (""destroying mutex"");
}",1,4,darwin\thread.c,vlc_mutex_destroy,,false,147,151,vlc_mutex_destroy,,,10,void vlc_mutex_destroy (vlc_mutex_t*)
20428,METHOD,darwin\thread.c:<global>,TYPE_DECL,"void vlc_mutex_lock (vlc_mutex_t *p_mutex)
{
    int val = pthread_mutex_lock( p_mutex );
    VLC_THREAD_ASSERT (""locking mutex"");
}",1,4,darwin\thread.c,vlc_mutex_lock,,false,168,172,vlc_mutex_lock,,,12,void vlc_mutex_lock (vlc_mutex_t*)
20450,METHOD,darwin\thread.c:<global>,TYPE_DECL,"int vlc_mutex_trylock (vlc_mutex_t *p_mutex)
{
    int val = pthread_mutex_trylock( p_mutex );

    if (val != EBUSY)
        VLC_THREAD_ASSERT (""locking mutex"");
    return val;
}",1,8,darwin\thread.c,vlc_mutex_trylock,,false,174,181,vlc_mutex_trylock,,,13,int vlc_mutex_trylock (vlc_mutex_t*)
20479,METHOD,darwin\thread.c:<global>,TYPE_DECL,"void vlc_mutex_unlock (vlc_mutex_t *p_mutex)
{
    int val = pthread_mutex_unlock( p_mutex );
    /* FIXME: We can't check for the success of the unlock
     * here as due to a bug in Apple pthread implementation.
     * The `pthread_cond_wait` function does not behave like
     * it should According to POSIX, pthread_cond_wait is a
     * cancellation point and when a thread is cancelled while
     * in a condition wait, the mutex is re-acquired before
     * calling the first cancellation cleanup handler:
     *
     * > The effect is as if the thread were unblocked, allowed
     * > to execute up to the point of returning from the call to
     * > pthread_cond_timedwait() or pthread_cond_wait(), but at
     * > that point notices the cancellation request and instead
     * > of returning to the caller of pthread_cond_timedwait()
     * > or pthread_cond_wait(), starts the thread cancellation
     * > activities, which includes calling cancellation cleanup
     * > handlers.
     ...",1,8,darwin\thread.c,vlc_mutex_unlock,,false,183,215,vlc_mutex_unlock,,,14,void vlc_mutex_unlock (vlc_mutex_t*)
20506,METHOD,darwin\thread.c:<global>,TYPE_DECL,"void vlc_cond_init (vlc_cond_t *p_condvar)
{
    if (unlikely(pthread_cond_init (p_condvar, NULL)))
        abort ();
}",1,1,darwin\thread.c,vlc_cond_init,,false,217,221,vlc_cond_init,,,15,void vlc_cond_init (vlc_cond_t*)
20518,METHOD,darwin\thread.c:<global>,TYPE_DECL,"void vlc_cond_init_daytime (vlc_cond_t *p_condvar)
{
    if (unlikely(pthread_cond_init (p_condvar, NULL)))
        abort ();
}",1,1,darwin\thread.c,vlc_cond_init_daytime,,false,223,227,vlc_cond_init_daytime,,,16,void vlc_cond_init_daytime (vlc_cond_t*)
20530,METHOD,darwin\thread.c:<global>,TYPE_DECL,"void vlc_cond_destroy (vlc_cond_t *p_condvar)
{
    int val = pthread_cond_destroy (p_condvar);

    /* due to a faulty pthread implementation within Darwin 11 and
     * later condition variables cannot be destroyed without
     * terminating the application immediately.
     * This Darwin kernel issue is still present in version 13
     * and might not be resolved prior to Darwin 15.
     * radar://12496249
     *
     * To work-around this, we are just leaking the condition variable
     * which is acceptable due to VLC's low number of created variables
     * and its usually limited runtime.
     * Ideally, we should implement a re-useable pool.
     */
    if (val != 0) {
        #ifndef NDEBUG
        printf(""pthread_cond_destroy returned %i\n"", val);
        #endif

        if (val == EBUSY)
            return;
    }

    VLC_THREAD_ASSERT (""destroying condition"");
}",1,4,darwin\thread.c,vlc_cond_destroy,,false,229,255,vlc_cond_destroy,,,17,void vlc_cond_destroy (vlc_cond_t*)
20566,METHOD,darwin\thread.c:<global>,TYPE_DECL,"void vlc_cond_signal (vlc_cond_t *p_condvar)
{
    int val = pthread_cond_signal (p_condvar);
    VLC_THREAD_ASSERT (""signaling condition variable"");
}",1,4,darwin\thread.c,vlc_cond_signal,,false,257,261,vlc_cond_signal,,,18,void vlc_cond_signal (vlc_cond_t*)
20588,METHOD,darwin\thread.c:<global>,TYPE_DECL,"void vlc_cond_broadcast (vlc_cond_t *p_condvar)
{
    pthread_cond_broadcast (p_condvar);
}",1,1,darwin\thread.c,vlc_cond_broadcast,,false,263,266,vlc_cond_broadcast,,,19,void vlc_cond_broadcast (vlc_cond_t*)
20595,METHOD,darwin\thread.c:<global>,TYPE_DECL,"void vlc_cond_wait (vlc_cond_t *p_condvar, vlc_mutex_t *p_mutex)
{
    int val = pthread_cond_wait (p_condvar, p_mutex);
    VLC_THREAD_ASSERT (""waiting on condition"");
}",1,4,darwin\thread.c,vlc_cond_wait,,false,268,272,vlc_cond_wait,,,20,"void vlc_cond_wait (vlc_cond_t*,vlc_mutex_t*)"
20619,METHOD,darwin\thread.c:<global>,TYPE_DECL,"int vlc_cond_timedwait (vlc_cond_t *p_condvar, vlc_mutex_t *p_mutex,
                        mtime_t deadline)
{
    /* according to POSIX standards, cond_timedwait should be a cancellation point
     * Of course, Darwin does not care */
    pthread_testcancel();

    /*
     * mdate() is the monotonic clock, pthread_cond_timedwait expects
     * origin of gettimeofday(). Use timedwait_relative_np() instead.
     */
    mtime_t base = mdate();
    deadline -= base;
    if (deadline < 0)
        deadline = 0;

    struct timespec ts = mtime_to_ts(deadline);
    int val = pthread_cond_timedwait_relative_np(p_condvar, p_mutex, &ts);
    if (val != ETIMEDOUT)
        VLC_THREAD_ASSERT (""timed-waiting on condition"");
    return val;
}",1,8,darwin\thread.c,vlc_cond_timedwait,,false,274,295,vlc_cond_timedwait,,,21,"int vlc_cond_timedwait (vlc_cond_t*,vlc_mutex_t*,mtime_t)"
20674,METHOD,darwin\thread.c:<global>,TYPE_DECL,"int vlc_cond_timedwait_daytime (vlc_cond_t *p_condvar, vlc_mutex_t *p_mutex,
                                time_t deadline)
{
    /*
     * Note that both pthread_cond_timedwait_relative_np and pthread_cond_timedwait
     * convert the given timeout to a mach absolute deadline, with system startup
     * as the time origin. There is no way you can change this behaviour.
     *
     * For more details, see: https://devforums.apple.com/message/931605
     */

    pthread_testcancel();

    /*
     * FIXME: It is assumed, that in this case the system waits until the real
     * time deadline is passed, even if the real time is adjusted in between.
     * This is not fulfilled, as described above.
     */
    struct timespec ts = mtime_to_ts(deadline);
    int val = pthread_cond_timedwait(p_condvar, p_mutex, &ts);

    if (val != ETIMEDOUT)
        VLC_THREAD_ASSERT (""timed-waiting on condition"");
    return val;
}",1,8,darwin\thread.c,vlc_cond_timedwait_daytime,,false,298,322,vlc_cond_timedwait_daytime,,,22,"int vlc_cond_timedwait_daytime (vlc_cond_t*,vlc_mutex_t*,time_t)"
20714,METHOD,darwin\thread.c:<global>,TYPE_DECL,"void vlc_sem_init (vlc_sem_t *sem, unsigned value)
{
    if (unlikely(semaphore_create(mach_task_self(), sem, SYNC_POLICY_FIFO, value) != KERN_SUCCESS))
        abort ();
}",1,1,darwin\thread.c,vlc_sem_init,,false,326,330,vlc_sem_init,,,23,"void vlc_sem_init (vlc_sem_t*,unsigned)"
20731,METHOD,darwin\thread.c:<global>,TYPE_DECL,"void vlc_sem_destroy (vlc_sem_t *sem)
{
    int val;

    if (likely(semaphore_destroy(mach_task_self(), *sem) == KERN_SUCCESS))
        return;

    val = EINVAL;

    VLC_THREAD_ASSERT (""destroying semaphore"");
}",1,4,darwin\thread.c,vlc_sem_destroy,,false,332,342,vlc_sem_destroy,,,24,void vlc_sem_destroy (vlc_sem_t*)
20762,METHOD,darwin\thread.c:<global>,TYPE_DECL,"int vlc_sem_post (vlc_sem_t *sem)
{
    int val;

    if (likely(semaphore_signal(*sem) == KERN_SUCCESS))
        return 0;

    val = EINVAL;

    if (unlikely(val != EOVERFLOW))
        VLC_THREAD_ASSERT (""unlocking semaphore"");
    return val;
}",1,8,darwin\thread.c,vlc_sem_post,,false,344,356,vlc_sem_post,,,25,int vlc_sem_post (vlc_sem_t*)
20801,METHOD,darwin\thread.c:<global>,TYPE_DECL,"void vlc_sem_wait (vlc_sem_t *sem)
{
    int val;

    if (likely(semaphore_wait(*sem) == KERN_SUCCESS))
        return;

    val = EINVAL;

    VLC_THREAD_ASSERT (""locking semaphore"");
}",1,4,darwin\thread.c,vlc_sem_wait,,false,358,368,vlc_sem_wait,,,26,void vlc_sem_wait (vlc_sem_t*)
20831,METHOD,darwin\thread.c:<global>,TYPE_DECL,"void vlc_rwlock_init (vlc_rwlock_t *lock)
{
    if (unlikely(pthread_rwlock_init (lock, NULL)))
        abort ();
}",1,1,darwin\thread.c,vlc_rwlock_init,,false,370,374,vlc_rwlock_init,,,27,void vlc_rwlock_init (vlc_rwlock_t*)
20843,METHOD,darwin\thread.c:<global>,TYPE_DECL,"void vlc_rwlock_destroy (vlc_rwlock_t *lock)
{
    int val = pthread_rwlock_destroy (lock);
    VLC_THREAD_ASSERT (""destroying R/W lock"");
}",1,4,darwin\thread.c,vlc_rwlock_destroy,,false,376,380,vlc_rwlock_destroy,,,28,void vlc_rwlock_destroy (vlc_rwlock_t*)
20865,METHOD,darwin\thread.c:<global>,TYPE_DECL,"void vlc_rwlock_rdlock (vlc_rwlock_t *lock)
{
    int val = pthread_rwlock_rdlock (lock);
    VLC_THREAD_ASSERT (""acquiring R/W lock for reading"");
}",1,4,darwin\thread.c,vlc_rwlock_rdlock,,false,382,386,vlc_rwlock_rdlock,,,29,void vlc_rwlock_rdlock (vlc_rwlock_t*)
20887,METHOD,darwin\thread.c:<global>,TYPE_DECL,"void vlc_rwlock_wrlock (vlc_rwlock_t *lock)
{
    int val = pthread_rwlock_wrlock (lock);
    VLC_THREAD_ASSERT (""acquiring R/W lock for writing"");
}",1,4,darwin\thread.c,vlc_rwlock_wrlock,,false,388,392,vlc_rwlock_wrlock,,,30,void vlc_rwlock_wrlock (vlc_rwlock_t*)
20909,METHOD,darwin\thread.c:<global>,TYPE_DECL,"void vlc_rwlock_unlock (vlc_rwlock_t *lock)
{
    int val = pthread_rwlock_unlock (lock);
    VLC_THREAD_ASSERT (""releasing R/W lock"");
}",1,4,darwin\thread.c,vlc_rwlock_unlock,,false,394,398,vlc_rwlock_unlock,,,31,void vlc_rwlock_unlock (vlc_rwlock_t*)
20931,METHOD,darwin\thread.c:<global>,TYPE_DECL,"int vlc_threadvar_create (vlc_threadvar_t *key, void (*destr) (void *))
{
    return pthread_key_create (key, destr);
}",1,1,darwin\thread.c,vlc_threadvar_create,,false,400,403,vlc_threadvar_create,,,32,"int vlc_threadvar_create (vlc_threadvar_t*,void)"
20941,METHOD,darwin\thread.c:<global>,TYPE_DECL,"void vlc_threadvar_delete (vlc_threadvar_t *p_tls)
{
    pthread_key_delete (*p_tls);
}",1,1,darwin\thread.c,vlc_threadvar_delete,,false,405,408,vlc_threadvar_delete,,,33,void vlc_threadvar_delete (vlc_threadvar_t*)
20949,METHOD,darwin\thread.c:<global>,TYPE_DECL,"int vlc_threadvar_set (vlc_threadvar_t key, void *value)
{
    return pthread_setspecific (key, value);
}",1,1,darwin\thread.c,vlc_threadvar_set,,false,410,413,vlc_threadvar_set,,,34,"int vlc_threadvar_set (vlc_threadvar_t,void*)"
20959,METHOD,darwin\thread.c:<global>,TYPE_DECL,"void *vlc_threadvar_get (vlc_threadvar_t key)
{
    return pthread_getspecific (key);
}",1,1,darwin\thread.c,vlc_threadvar_get,,false,415,418,vlc_threadvar_get,,,35,void* vlc_threadvar_get (vlc_threadvar_t)
20967,METHOD,darwin\thread.c:<global>,TYPE_DECL,"void vlc_threads_setup (libvlc_int_t *p_libvlc)
{
    (void) p_libvlc;
}",1,1,darwin\thread.c,vlc_threads_setup,,false,420,423,vlc_threads_setup,,,36,void vlc_threads_setup (libvlc_int_t*)
20975,METHOD,darwin\thread.c:<global>,TYPE_DECL,"static int vlc_clone_attr (vlc_thread_t *th, pthread_attr_t *attr,
                           void *(*entry) (void *), void *data, int priority)
{
    int ret;

    sigset_t oldset;
    {
        sigset_t set;
        sigemptyset (&set);
        sigdelset (&set, SIGHUP);
        sigaddset (&set, SIGINT);
        sigaddset (&set, SIGQUIT);
        sigaddset (&set, SIGTERM);

        sigaddset (&set, SIGPIPE); /* We don't want this one, really! */
        pthread_sigmask (SIG_BLOCK, &set, &oldset);
    }

    (void) priority;

#define VLC_STACKSIZE (128 * sizeof (void *) * 1024)

#ifdef VLC_STACKSIZE
    ret = pthread_attr_setstacksize (attr, VLC_STACKSIZE);
    assert (ret == 0); /* fails iif VLC_STACKSIZE is invalid */
#endif

    ret = pthread_create (th, attr, entry, data);
    pthread_sigmask (SIG_SETMASK, &oldset, NULL);
    pthread_attr_destroy (attr);
    return ret;
}",1,43,darwin\thread.c,vlc_clone_attr,,false,425,456,vlc_clone_attr,,,37,"int vlc_clone_attr (vlc_thread_t*,pthread_attr_t*,void*,void*,int)"
21052,METHOD,darwin\thread.c:<global>,TYPE_DECL,"int vlc_clone (vlc_thread_t *th, void *(*entry) (void *), void *data,
               int priority)
{
    pthread_attr_t attr;

    pthread_attr_init (&attr);
    return vlc_clone_attr (th, &attr, entry, data, priority);
}",1,1,darwin\thread.c,vlc_clone,,false,458,465,vlc_clone,,,38,"int vlc_clone (vlc_thread_t*,void*,void*,int)"
21072,METHOD,darwin\thread.c:<global>,TYPE_DECL,"void vlc_join (vlc_thread_t handle, void **result)
{
    int val = pthread_join (handle, result);
    VLC_THREAD_ASSERT (""joining thread"");
}",1,4,darwin\thread.c,vlc_join,,false,467,471,vlc_join,,,39,"void vlc_join (vlc_thread_t,void**)"
21096,METHOD,darwin\thread.c:<global>,TYPE_DECL,"int vlc_clone_detach (vlc_thread_t *th, void *(*entry) (void *), void *data,
                      int priority)
{
    vlc_thread_t dummy;
    pthread_attr_t attr;

    if (th == NULL)
        th = &dummy;

    pthread_attr_init (&attr);
    pthread_attr_setdetachstate (&attr, PTHREAD_CREATE_DETACHED);
    return vlc_clone_attr (th, &attr, entry, data, priority);
}",1,1,darwin\thread.c,vlc_clone_detach,,false,473,485,vlc_clone_detach,,,40,"int vlc_clone_detach (vlc_thread_t*,void*,void*,int)"
21130,METHOD,darwin\thread.c:<global>,TYPE_DECL,"vlc_thread_t vlc_thread_self (void)
{
    return pthread_self ();
}",1,1,darwin\thread.c,vlc_thread_self,,false,487,490,vlc_thread_self,,,41,vlc_thread_t vlc_thread_self (void)
21137,METHOD,darwin\thread.c:<global>,TYPE_DECL,"unsigned long vlc_thread_id (void)
{
    return -1;
}",1,1,darwin\thread.c,vlc_thread_id,,false,492,495,vlc_thread_id,,,42,unsigned long vlc_thread_id (void)
21145,METHOD,darwin\thread.c:<global>,TYPE_DECL,"int vlc_set_priority (vlc_thread_t th, int priority)
{
    (void) th; (void) priority;
    return VLC_SUCCESS;
}",1,1,darwin\thread.c,vlc_set_priority,,false,497,501,vlc_set_priority,,,43,"int vlc_set_priority (vlc_thread_t,int)"
21159,METHOD,darwin\thread.c:<global>,TYPE_DECL,"void vlc_cancel (vlc_thread_t thread_id)
{
    pthread_cancel (thread_id);
}",1,1,darwin\thread.c,vlc_cancel,,false,503,506,vlc_cancel,,,44,void vlc_cancel (vlc_thread_t)
21166,METHOD,darwin\thread.c:<global>,TYPE_DECL,"int vlc_savecancel (void)
{
    int state;
    int val = pthread_setcancelstate (PTHREAD_CANCEL_DISABLE, &state);

    VLC_THREAD_ASSERT (""saving cancellation"");
    return state;
}",1,4,darwin\thread.c,vlc_savecancel,,false,508,515,vlc_savecancel,,,45,int vlc_savecancel (void)
21193,METHOD,darwin\thread.c:<global>,TYPE_DECL,"void vlc_restorecancel (int state)
{
#ifndef NDEBUG
    int oldstate, val;

    val = pthread_setcancelstate (state, &oldstate);
    VLC_THREAD_ASSERT (""restoring cancellation"");

    if (unlikely(oldstate != PTHREAD_CANCEL_DISABLE))
         vlc_thread_fatal (""restoring cancellation while not disabled"", EINVAL,
                           __func__, __FILE__, __LINE__);
#else
    pthread_setcancelstate (state, NULL);
#endif
}",1,4,darwin\thread.c,vlc_restorecancel,,false,517,531,vlc_restorecancel,,,46,void vlc_restorecancel (int)
21234,METHOD,darwin\thread.c:<global>,TYPE_DECL,"void vlc_testcancel (void)
{
    pthread_testcancel ();
}",1,1,darwin\thread.c,vlc_testcancel,,false,533,536,vlc_testcancel,,,47,void vlc_testcancel (void)
21240,METHOD,darwin\thread.c:<global>,TYPE_DECL,"void vlc_control_cancel (int cmd, ...)
{
    (void) cmd;
    vlc_assert_unreachable ();
}",1,1,darwin\thread.c,vlc_control_cancel,,false,538,542,vlc_control_cancel,,,48,void vlc_control_cancel (int...)
21249,METHOD,darwin\thread.c:<global>,TYPE_DECL,"mtime_t mdate (void)
{
    vlc_clock_setup();
    uint64_t date = mach_absolute_time();

    /* denom is uint32_t, switch to 64 bits to prevent overflow. */
    uint64_t denom = vlc_clock_conversion_factor.denom;

    /* Switch to microsecs */
    denom *= 1000LL;

    /* Split the division to prevent overflow */
    lldiv_t d = lldiv (vlc_clock_conversion_factor.numer, denom);

    return (d.quot * date) + ((d.rem * date) / denom);
}",1,4,darwin\thread.c,mdate,,false,544,559,mdate,,,49,mtime_t mdate (void)
21295,METHOD,darwin\thread.c:<global>,TYPE_DECL,"void mwait (mtime_t deadline)
{
    deadline -= mdate ();
    if (deadline > 0)
        msleep (deadline);
}",1,1,darwin\thread.c,mwait,,false,562,567,mwait,,,50,void mwait (mtime_t)
21310,METHOD,darwin\thread.c:<global>,TYPE_DECL,"void msleep (mtime_t delay)
{
    struct timespec ts = mtime_to_ts (delay);

    /* nanosleep uses mach_absolute_time and mach_wait_until internally,
       but also handles kernel errors. Thus we use just this. */
    while (nanosleep (&ts, &ts) == -1)
        assert (errno == EINTR);
}",1,1,darwin\thread.c,msleep,,false,570,578,msleep,,,51,void msleep (mtime_t)
21333,METHOD,darwin\thread.c:<global>,TYPE_DECL,"unsigned vlc_GetCPUCount(void)
{
    return sysconf(_SC_NPROCESSORS_CONF);
}",1,1,darwin\thread.c,vlc_GetCPUCount,,false,580,583,vlc_GetCPUCount,,,52,unsigned vlc_GetCPUCount (void)
21356,METHOD,extras\libc.c:<global>,TYPE_DECL,<global>,1,1,extras\libc.c,extras\libc.c:<global>,,false,1,547,<global>,,,1,
22731,METHOD,extras\libc.c:<global>,TYPE_DECL,"static size_t ISO6937toUTF8( const char **inbuf, size_t *inbytesleft,
                             unsigned char **outbuf, size_t *outbytesleft,
                             const uint16_t *ucs4_table )


{
    if( !inbuf || !(*inbuf) )
        return (size_t)(0);    /* Reset state requested */

    const char *iptr = *inbuf;
    const char *iend = iptr + *inbytesleft;
    unsigned char *optr = *outbuf;
    unsigned char *oend = optr + *outbytesleft;
    int err = 0;

    while ( iptr < iend )
    {
        unsigned char c1 = *iptr;
        uint_fast16_t ch = ucs4_table[c1];

        if( c1 >= 0xc1 && c1 <= 0xcf )
        {
            /* Composed character */
            if ( iptr + 1 >= iend )
            {
                err = EINVAL;
                break;    /* No next character */
            }

            unsigned char c2 = iptr[1];
            if ( c2 < 0x40 || c2 >= 0x80 ||
                 !(ch = to_ucs4_comb[c1 - 0xc1][c2 - 0x40]) )
            {
                err = E...",1,1,extras\libc.c,ISO6937toUTF8,,false,292,391,ISO6937toUTF8,,,7,"size_t ISO6937toUTF8 (char**,size_t*,unsigned char**,size_t*,uint16_t*)"
22999,METHOD,extras\libc.c:<global>,TYPE_DECL,"vlc_iconv_t vlc_iconv_open( const char *tocode, const char *fromcode )
{
#ifndef __linux__
    if( !strcasecmp(tocode, ""UTF-8"") && !strcasecmp(fromcode, ""ISO_6937"") )
        return (vlc_iconv_t)(-2);
    else if( !strcasecmp(tocode, ""UTF-8"") && !strcasecmp(fromcode, ""ISO_6937-2"") )
        return (vlc_iconv_t)(-3);
#endif
#if defined(HAVE_ICONV)
# if defined(__OS2__) && defined(__INNOTEK_LIBC__)
    char tocode_ucs2[] = ""UCS-2LE"";
    char fromcode_ucs2[] = ""UCS-2LE"";
    os2_iconv_t *p_os2_iconv;

    /* Workaround for UTF-16 because OS/2 supports UCS-2 only not UTF-16 */
    if( !strncmp( tocode, ""UTF-16"", 6 ))
    {
        strncpy( tocode_ucs2 + 5, tocode + 6, 2 );
        tocode = tocode_ucs2;
    }

    if( !strncmp( fromcode, ""UTF-16"", 6 ))
    {
        strncpy( fromcode_ucs2 + 5, fromcode + 6, 2 );
        fromcode = fromcode_ucs2;
    }

    p_os2_iconv = ( os2_iconv_t * )iconv_open( tocode, fromcode );

    if( p_os2_iconv != ( iconv_t )(-1))
    {
        /* Mimic a beh...",1,1,extras\libc.c,vlc_iconv_open,,false,397,445,vlc_iconv_open,,,8,"vlc_iconv_t vlc_iconv_open (char*,char*)"
23041,METHOD,extras\libc.c:<global>,TYPE_DECL,"size_t vlc_iconv( vlc_iconv_t cd, const char **inbuf, size_t *inbytesleft,
                  char **outbuf, size_t *outbytesleft )
{
    size_t ret;

#ifndef __linux__
    if ( cd == (vlc_iconv_t)(-2) || cd == (vlc_iconv_t)(-3) )
    {
        unsigned char *out = NULL;
        if (outbuf != NULL)
            out = (unsigned char *)*outbuf;

        const uint16_t *ucs4_table = ( cd == (vlc_iconv_t)(-2) ? ISO6937toUCS4 : ISO6937_2toUCS4 );

        ret = ISO6937toUTF8( inbuf, inbytesleft, &out, outbytesleft, ucs4_table );
        if (outbuf != NULL)
            *outbuf = (char *)out;
    }
    else
#endif
#if defined(HAVE_ICONV)
    {
        ICONV_CONST char *cin = NULL;
        if (inbuf != NULL)
            cin = (ICONV_CONST char *)*inbuf;

        ret = iconv( cd, &cin, inbytesleft, outbuf, outbytesleft );
        if (inbuf != NULL)
            *inbuf = cin;
    }
#else
        abort ();
#endif
    return ret;
}",1,1,extras\libc.c,vlc_iconv,,false,447,481,vlc_iconv,,,9,"size_t vlc_iconv (vlc_iconv_t,char**,size_t*,char**,size_t*)"
23115,METHOD,extras\libc.c:<global>,TYPE_DECL,"int vlc_iconv_close( vlc_iconv_t cd )
{
#ifndef __linux__
    if ( cd == (vlc_iconv_t)(-2) || cd == (vlc_iconv_t)(-3) )
        return 0;
#endif
#if defined(HAVE_ICONV)
    return iconv_close( cd );
#else
    abort ();
#endif
}",1,1,extras\libc.c,vlc_iconv_close,,false,483,494,vlc_iconv_close,,,10,int vlc_iconv_close (vlc_iconv_t)
23136,METHOD,extras\libc.c:<global>,TYPE_DECL,"bool vlc_ureduce( unsigned *pi_dst_nom, unsigned *pi_dst_den,
                        uint64_t i_nom, uint64_t i_den, uint64_t i_max )
{
    bool b_exact = 1;
    uint64_t i_gcd;

    if( i_den == 0 )
    {
        *pi_dst_nom = 0;
        *pi_dst_den = 1;
        return 1;
    }

    i_gcd = GCD( i_nom, i_den );
    i_nom /= i_gcd;
    i_den /= i_gcd;

    if( i_max == 0 ) i_max = INT64_C(0xFFFFFFFF);

    if( i_nom > i_max || i_den > i_max )
    {
        uint64_t i_a0_num = 0, i_a0_den = 1, i_a1_num = 1, i_a1_den = 0;
        b_exact = 0;

        for( ; ; )
        {
            uint64_t i_x = i_nom / i_den;
            uint64_t i_a2n = i_x * i_a1_num + i_a0_num;
            uint64_t i_a2d = i_x * i_a1_den + i_a0_den;

            if( i_a2n > i_max || i_a2d > i_max ) break;

            i_nom %= i_den;

            i_a0_num = i_a1_num; i_a0_den = i_a1_den;
            i_a1_num = i_a2n; i_a1_den = i_a2d;
            if( i_nom == 0 ) break;
            i_x = i_nom; i_nom = i_den; ...",1,1,extras\libc.c,vlc_ureduce,,false,500,547,vlc_ureduce,,,11,"bool vlc_ureduce (unsigned*,unsigned*,uint64_t,uint64_t,uint64_t)"
23319,METHOD,input\access.c:<global>,TYPE_DECL,<global>,1,20,input\access.c,input\access.c:<global>,,false,1,319,<global>,,,1,
23321,METHOD,input\access.c:<global>,TYPE_DECL,"char *get_path(const char *location)
{
    char *url, *path;

    /* Prepending ""file://"" is a bit hackish. But then again, we do not want
     * to hard-code the list of schemes that use file paths in vlc_uri2path().
     */
    if (asprintf(&url, ""file://%s"", location) == -1)
        return NULL;

    path = vlc_uri2path (url);
    free (url);
    return path;
}",1,1,input\access.c,get_path,,false,42,55,get_path,,,1,char* get_path (char*)
23348,METHOD,input\access.c:<global>,TYPE_DECL,"static void vlc_access_Destroy(stream_t *access)
{
    module_unneed(access, access->p_module);
    free(access->psz_filepath);
    free(access->psz_name);
}",1,1,input\access.c,vlc_access_Destroy,,false,57,62,vlc_access_Destroy,,,2,void vlc_access_Destroy (stream_t*)
23366,METHOD,input\access.c:<global>,TYPE_DECL,"static stream_t *access_New(vlc_object_t *parent, input_thread_t *input,
                            bool preparsing, const char *mrl)
{
    char *redirv[MAX_REDIR];
    unsigned redirc = 0;

    stream_t *access = vlc_stream_CommonNew(parent, vlc_access_Destroy);
    if (unlikely(access == NULL))
        return NULL;

    access->p_input = input;
    access->psz_name = NULL;
    access->psz_url = strdup(mrl);
    access->psz_filepath = NULL;
    access->b_preparsing = preparsing;

    if (unlikely(access->psz_url == NULL))
        goto error;

    while (redirc < MAX_REDIR)
    {
        char *url = access->psz_url;
        msg_Dbg(access, ""creating access: %s"", url);

        const char *p = strstr(url, ""://"");
        if (p == NULL)
            goto error;

        access->psz_name = strndup(url, p - url);
        if (unlikely(access->psz_name == NULL))
            goto error;

        access->psz_location = p + 3;
        access->psz_filepath = get_path(access->psz_location);
  ...",1,17,input\access.c,access_New,,false,69,144,access_New,,,3,"stream_t access_New (vlc_object_t*,input_thread_t*,bool,char*)"
23625,METHOD,input\access.c:<global>,TYPE_DECL,"stream_t *vlc_access_NewMRL(vlc_object_t *parent, const char *mrl)
{
    return access_New(parent, NULL, false, mrl);
}",1,1,input\access.c,vlc_access_NewMRL,,false,146,149,vlc_access_NewMRL,,,4,"stream_t vlc_access_NewMRL (vlc_object_t*,char*)"
23637,METHOD,input\access.c:<global>,TYPE_DECL,"int access_vaDirectoryControlHelper( stream_t *p_access, int i_query, va_list args )
{
    VLC_UNUSED( p_access );

    switch( i_query )
    {
        case STREAM_CAN_SEEK:
        case STREAM_CAN_FASTSEEK:
        case STREAM_CAN_PAUSE:
        case STREAM_CAN_CONTROL_PACE:
            *va_arg( args, bool* ) = false;
            break;
        case STREAM_GET_PTS_DELAY:
            *va_arg( args, int64_t * ) = 0;
            break;
        case STREAM_IS_DIRECTORY:
            break;
        default:
            return VLC_EGENERIC;
     }
     return VLC_SUCCESS;
}",1,1,input\access.c,access_vaDirectoryControlHelper,,false,154,175,access_vaDirectoryControlHelper,,,5,"int access_vaDirectoryControlHelper (stream_t*,int,va_list)"
23671,METHOD,input\access.c:<global>,TYPE_DECL,"static int AStreamNoReadDir(stream_t *s, input_item_node_t *p_node)
{
    (void) s; (void) p_node;
    return VLC_EGENERIC;;
}",1,1,input\access.c,AStreamNoReadDir,,false,177,181,AStreamNoReadDir,,,6,"int AStreamNoReadDir (stream_t*,input_item_node_t*)"
23685,METHOD,input\access.c:<global>,TYPE_DECL,"static block_t *AStreamReadBlock(stream_t *s, bool *restrict eof)
{
    stream_t *access = s->p_sys;
    input_thread_t *input = s->p_input;
    block_t * block;

    if (vlc_stream_Eof(access))
    {
        *eof = true;
        return NULL;
    }
    if (vlc_killed())
        return NULL;

    block = vlc_stream_ReadBlock(access);

    if (block != NULL && input != NULL)
    {
        uint64_t total;

        vlc_mutex_lock(&input_priv(input)->counters.counters_lock);
        stats_Update(input_priv(input)->counters.p_read_bytes,
                     block->i_buffer, &total);
        stats_Update(input_priv(input)->counters.p_input_bitrate, total, NULL);
        stats_Update(input_priv(input)->counters.p_read_packets, 1, NULL);
        vlc_mutex_unlock(&input_priv(input)->counters.counters_lock);
    }

    return block;
}",1,1,input\access.c,AStreamReadBlock,,false,184,213,AStreamReadBlock,,,7,"block_t AStreamReadBlock (stream_t*,bool*)"
23781,METHOD,input\access.c:<global>,TYPE_DECL,"static ssize_t AStreamReadStream(stream_t *s, void *buf, size_t len)
{
    stream_t *access = s->p_sys;
    input_thread_t *input = s->p_input;

    if (vlc_stream_Eof(access))
        return 0;
    if (vlc_killed())
        return -1;

    ssize_t val = vlc_stream_ReadPartial(access, buf, len);

    if (val > 0 && input != NULL)
    {
        uint64_t total;

        vlc_mutex_lock(&input_priv(input)->counters.counters_lock);
        stats_Update(input_priv(input)->counters.p_read_bytes, val, &total);
        stats_Update(input_priv(input)->counters.p_input_bitrate, total, NULL);
        stats_Update(input_priv(input)->counters.p_read_packets, 1, NULL);
        vlc_mutex_unlock(&input_priv(input)->counters.counters_lock);
    }

    return val;
}",1,1,input\access.c,AStreamReadStream,,false,216,240,AStreamReadStream,,,8,"ssize_t AStreamReadStream (stream_t*,void*,size_t)"
23875,METHOD,input\access.c:<global>,TYPE_DECL,"static int AStreamReadDir(stream_t *s, input_item_node_t *p_node)
{
    stream_t *access = s->p_sys;

    return access->pf_readdir(access, p_node);
}",1,1,input\access.c,AStreamReadDir,,false,243,248,AStreamReadDir,,,9,"int AStreamReadDir (stream_t*,input_item_node_t*)"
23894,METHOD,input\access.c:<global>,TYPE_DECL,"static int AStreamSeek(stream_t *s, uint64_t offset)
{
    stream_t *access = s->p_sys;

    return vlc_stream_Seek(access, offset);
}",1,1,input\access.c,AStreamSeek,,false,251,256,AStreamSeek,,,10,"int AStreamSeek (stream_t*,uint64_t)"
23910,METHOD,input\access.c:<global>,TYPE_DECL,"static int AStreamControl(stream_t *s, int cmd, va_list args)
{
    stream_t *access = s->p_sys;

    return vlc_stream_vaControl(access, cmd, args);
}",1,1,input\access.c,AStreamControl,,false,258,263,AStreamControl,,,11,"int AStreamControl (stream_t*,int,va_list)"
23928,METHOD,input\access.c:<global>,TYPE_DECL,"static void AStreamDestroy(stream_t *s)
{
    stream_t *access = s->p_sys;

    vlc_stream_Delete(access);
}",1,1,input\access.c,AStreamDestroy,,false,265,270,AStreamDestroy,,,12,void AStreamDestroy (stream_t*)
23941,METHOD,input\access.c:<global>,TYPE_DECL,"stream_t *stream_AccessNew(vlc_object_t *parent, input_thread_t *input,
                           bool preparsing, const char *url)
{
    stream_t *s = vlc_stream_CommonNew(parent, AStreamDestroy);
    if (unlikely(s == NULL))
        return NULL;

    stream_t *access = access_New(VLC_OBJECT(s), input, preparsing, url);
    if (access == NULL)
    {
        stream_CommonDelete(s);
        return NULL;
    }

    s->p_input = input;
    s->psz_url = strdup(access->psz_url);

    const char *cachename;

    if (access->pf_block != NULL)
    {
        s->pf_block = AStreamReadBlock;
        cachename = ""prefetch,cache_block"";
    }
    else
    if (access->pf_read != NULL)
    {
        s->pf_read = AStreamReadStream;
        cachename = ""prefetch,cache_read"";
    }
    else
    {
        cachename = NULL;
    }

    if (access->pf_readdir != NULL)
        s->pf_readdir = AStreamReadDir;
    else
        s->pf_readdir = AStreamNoReadDir;

    s->pf_seek    = AStreamSeek;
    s->pf_co...",1,1,input\access.c,stream_AccessNew,,false,272,319,stream_AccessNew,,,13,"stream_t stream_AccessNew (vlc_object_t*,input_thread_t*,bool,char*)"
24092,METHOD,input\clock.c:<global>,TYPE_DECL,<global>,1,23,input\clock.c,input\clock.c:<global>,,false,1,675,<global>,,,1,
24100,METHOD,input\clock.c:<global>,TYPE_DECL,"static void    AvgInit( average_t *, int i_divider );",16,52,input\clock.c,AvgInit,,false,117,117,AvgInit,,,3,"void AvgInit (average_t*,int)"
24106,METHOD,input\clock.c:<global>,TYPE_DECL,static void    AvgClean( average_t * );,16,38,input\clock.c,AvgClean,,false,118,118,AvgClean,,,4,void AvgClean (average_t*)
24111,METHOD,input\clock.c:<global>,TYPE_DECL,static void    AvgReset( average_t * );,16,38,input\clock.c,AvgReset,,false,120,120,AvgReset,,,5,void AvgReset (average_t*)
24116,METHOD,input\clock.c:<global>,TYPE_DECL,"static void    AvgUpdate( average_t *, mtime_t i_value );",16,56,input\clock.c,AvgUpdate,,false,121,121,AvgUpdate,,,6,"void AvgUpdate (average_t*,mtime_t)"
24122,METHOD,input\clock.c:<global>,TYPE_DECL,static mtime_t AvgGet( average_t * );,16,36,input\clock.c,AvgGet,,false,122,122,AvgGet,,,7,mtime_t AvgGet (average_t*)
24127,METHOD,input\clock.c:<global>,TYPE_DECL,"static void    AvgRescale( average_t *, int i_divider );",16,55,input\clock.c,AvgRescale,,false,123,123,AvgRescale,,,8,"void AvgRescale (average_t*,int)"
24137,METHOD,input\clock.c:<global>,TYPE_DECL,"static inline clock_point_t clock_point_Create( mtime_t i_stream, mtime_t i_system )
{
    clock_point_t p = { .i_stream = i_stream, .i_system = i_system };
    return p;
}",1,1,input\clock.c,clock_point_Create,,false,132,136,clock_point_Create,,,11,"clock_point_t clock_point_Create (mtime_t,mtime_t)"
24167,METHOD,<empty>,<empty>,<empty>,5,,input\clock.c,input_clock_t.late:<clinit>,,false,162,,<clinit>,,,3,
24184,METHOD,input\clock.c:<global>,TYPE_DECL,"static mtime_t ClockStreamToSystem( input_clock_t *, mtime_t i_stream );",16,71,input\clock.c,ClockStreamToSystem,,false,183,183,ClockStreamToSystem,,,13,"mtime_t ClockStreamToSystem (input_clock_t*,mtime_t)"
24190,METHOD,input\clock.c:<global>,TYPE_DECL,"static mtime_t ClockSystemToStream( input_clock_t *, mtime_t i_system );",16,71,input\clock.c,ClockSystemToStream,,false,184,184,ClockSystemToStream,,,14,"mtime_t ClockSystemToStream (input_clock_t*,mtime_t)"
24196,METHOD,input\clock.c:<global>,TYPE_DECL,static mtime_t ClockGetTsOffset( input_clock_t * );,16,50,input\clock.c,ClockGetTsOffset,,false,186,186,ClockGetTsOffset,,,15,mtime_t ClockGetTsOffset (input_clock_t*)
24201,METHOD,input\clock.c:<global>,TYPE_DECL,"input_clock_t *input_clock_New( int i_rate )
{
    input_clock_t *cl = malloc( sizeof(*cl) );
    if( !cl )
        return NULL;

    vlc_mutex_init( &cl->lock );
    cl->b_has_reference = false;
    cl->ref = clock_point_Create( VLC_TS_INVALID, VLC_TS_INVALID );
    cl->b_has_external_clock = false;

    cl->last = clock_point_Create( VLC_TS_INVALID, VLC_TS_INVALID );

    cl->i_ts_max = VLC_TS_INVALID;

    cl->i_buffering_duration = 0;

    cl->i_next_drift_update = VLC_TS_INVALID;
    AvgInit( &cl->drift, 10 );

    cl->late.i_index = 0;
    for( int i = 0; i < INPUT_CLOCK_LATE_COUNT; i++ )
        cl->late.pi_value[i] = 0;

    cl->i_rate = i_rate;
    cl->i_pts_delay = 0;
    cl->b_paused = false;
    cl->i_pause_date = VLC_TS_INVALID;

    return cl;
}",1,24,input\clock.c,input_clock_New,,false,191,221,input_clock_New,,,16,input_clock_t input_clock_New (int)
24320,METHOD,input\clock.c:<global>,TYPE_DECL,"void input_clock_Delete( input_clock_t *cl )
{
    AvgClean( &cl->drift );
    vlc_mutex_destroy( &cl->lock );
    free( cl );
}",1,1,input\clock.c,input_clock_Delete,,false,226,231,input_clock_Delete,,,17,void input_clock_Delete (input_clock_t*)
24337,METHOD,input\clock.c:<global>,TYPE_DECL,"void input_clock_Update( input_clock_t *cl, vlc_object_t *p_log,
                         bool *pb_late,
                         bool b_can_pace_control, bool b_buffering_allowed,
                         mtime_t i_ck_stream, mtime_t i_ck_system )
{
    bool b_reset_reference = false;

    assert( i_ck_stream > VLC_TS_INVALID && i_ck_system > VLC_TS_INVALID );

    vlc_mutex_lock( &cl->lock );

    if( !cl->b_has_reference )
    {
        /* */
        b_reset_reference= true;
    }
    else if( cl->last.i_stream > VLC_TS_INVALID &&
             ( (cl->last.i_stream - i_ck_stream) > CR_MAX_GAP ||
               (cl->last.i_stream - i_ck_stream) < -CR_MAX_GAP ) )
    {
        /* Stream discontinuity, for which we haven't received a
         * warning from the stream control facilities (dd-edited
         * stream ?). */
        msg_Warn( p_log, ""clock gap, unexpected stream discontinuity"" );
        cl->i_ts_max = VLC_TS_INVALID;

        /* */
        msg_Warn( p_log, ""feeding syn...",1,51,input\clock.c,input_clock_Update,,false,239,327,input_clock_Update,,,18,"void input_clock_Update (input_clock_t*,vlc_object_t*,bool*,bool,bool,mtime_t,mtime_t)"
24631,METHOD,input\clock.c:<global>,TYPE_DECL,"void input_clock_Reset( input_clock_t *cl )
{
    vlc_mutex_lock( &cl->lock );

    cl->b_has_reference = false;
    cl->ref = clock_point_Create( VLC_TS_INVALID, VLC_TS_INVALID );
    cl->b_has_external_clock = false;
    cl->i_ts_max = VLC_TS_INVALID;

    vlc_mutex_unlock( &cl->lock );
}",1,1,input\clock.c,input_clock_Reset,,false,332,342,input_clock_Reset,,,19,void input_clock_Reset (input_clock_t*)
24668,METHOD,input\clock.c:<global>,TYPE_DECL,"void input_clock_ChangeRate( input_clock_t *cl, int i_rate )
{
    vlc_mutex_lock( &cl->lock );

    if( cl->b_has_reference )
    {
        /* Move the reference point (as if we were playing at the new rate
         * from the start */
        cl->ref.i_system = cl->last.i_system - (cl->last.i_system - cl->ref.i_system) * i_rate / cl->i_rate;
    }
    cl->i_rate = i_rate;

    vlc_mutex_unlock( &cl->lock );
}",1,1,input\clock.c,input_clock_ChangeRate,,false,347,360,input_clock_ChangeRate,,,20,"void input_clock_ChangeRate (input_clock_t*,int)"
24723,METHOD,input\clock.c:<global>,TYPE_DECL,"void input_clock_ChangePause( input_clock_t *cl, bool b_paused, mtime_t i_date )
{
    vlc_mutex_lock( &cl->lock );
    assert( (!cl->b_paused) != (!b_paused) );

    if( cl->b_paused )
    {
        const mtime_t i_duration = i_date - cl->i_pause_date;

        if( cl->b_has_reference && i_duration > 0 )
        {
            cl->ref.i_system += i_duration;
            cl->last.i_system += i_duration;
        }
    }
    cl->i_pause_date = i_date;
    cl->b_paused = b_paused;

    vlc_mutex_unlock( &cl->lock );
}",1,1,input\clock.c,input_clock_ChangePause,,false,365,384,input_clock_ChangePause,,,21,"void input_clock_ChangePause (input_clock_t*,bool,mtime_t)"
24794,METHOD,input\clock.c:<global>,TYPE_DECL,"mtime_t input_clock_GetWakeup( input_clock_t *cl )
{
    mtime_t i_wakeup = 0;

    vlc_mutex_lock( &cl->lock );

    /* Synchronized, we can wait */
    if( cl->b_has_reference )
        i_wakeup = ClockStreamToSystem( cl, cl->last.i_stream + AvgGet( &cl->drift ) - cl->i_buffering_duration );

    vlc_mutex_unlock( &cl->lock );

    return i_wakeup;
}",1,1,input\clock.c,input_clock_GetWakeup,,false,389,402,input_clock_GetWakeup,,,22,mtime_t input_clock_GetWakeup (input_clock_t*)
24839,METHOD,input\clock.c:<global>,TYPE_DECL,"int input_clock_ConvertTS( vlc_object_t *p_object, input_clock_t *cl,
                           int *pi_rate, mtime_t *pi_ts0, mtime_t *pi_ts1,
                           mtime_t i_ts_bound )
{
    assert( pi_ts0 );
    vlc_mutex_lock( &cl->lock );

    if( pi_rate )
        *pi_rate = cl->i_rate;

    if( !cl->b_has_reference )
    {
        vlc_mutex_unlock( &cl->lock );
        msg_Err(p_object, ""Timestamp conversion failed for %""PRId64"": ""
                ""no reference clock"", *pi_ts0);
        *pi_ts0 = VLC_TS_INVALID;
        if( pi_ts1 )
            *pi_ts1 = VLC_TS_INVALID;
        return VLC_EGENERIC;
    }

    /* */
    const mtime_t i_ts_buffering = cl->i_buffering_duration * cl->i_rate / INPUT_RATE_DEFAULT;
    const mtime_t i_ts_delay = cl->i_pts_delay + ClockGetTsOffset( cl );

    /* */
    if( *pi_ts0 > VLC_TS_INVALID )
    {
        *pi_ts0 = ClockStreamToSystem( cl, *pi_ts0 + AvgGet( &cl->drift ) );
        if( *pi_ts0 > cl->i_ts_max )
            cl->i_ts_max = ...",1,1,input\clock.c,input_clock_ConvertTS,,false,407,462,input_clock_ConvertTS,,,23,"int input_clock_ConvertTS (vlc_object_t*,input_clock_t*,int*,mtime_t*,mtime_t*,mtime_t)"
25003,METHOD,input\clock.c:<global>,TYPE_DECL,"int input_clock_GetRate( input_clock_t *cl )
{
    int i_rate;

    vlc_mutex_lock( &cl->lock );
    i_rate = cl->i_rate;
    vlc_mutex_unlock( &cl->lock );

    return i_rate;
}",1,1,input\clock.c,input_clock_GetRate,,false,466,475,input_clock_GetRate,,,24,int input_clock_GetRate (input_clock_t*)
25026,METHOD,input\clock.c:<global>,TYPE_DECL,"int input_clock_GetState( input_clock_t *cl,
                          mtime_t *pi_stream_start, mtime_t *pi_system_start,
                          mtime_t *pi_stream_duration, mtime_t *pi_system_duration )
{
    vlc_mutex_lock( &cl->lock );

    if( !cl->b_has_reference )
    {
        vlc_mutex_unlock( &cl->lock );
        return VLC_EGENERIC;
    }

    *pi_stream_start = cl->ref.i_stream;
    *pi_system_start = cl->ref.i_system;

    *pi_stream_duration = cl->last.i_stream - cl->ref.i_stream;
    *pi_system_duration = cl->last.i_system - cl->ref.i_system;

    vlc_mutex_unlock( &cl->lock );

    return VLC_SUCCESS;
}",1,1,input\clock.c,input_clock_GetState,,false,477,498,input_clock_GetState,,,25,"int input_clock_GetState (input_clock_t*,mtime_t*,mtime_t*,mtime_t*,mtime_t*)"
25104,METHOD,input\clock.c:<global>,TYPE_DECL,"void input_clock_ChangeSystemOrigin( input_clock_t *cl, bool b_absolute, mtime_t i_system )
{
    vlc_mutex_lock( &cl->lock );

    assert( cl->b_has_reference );
    mtime_t i_offset;
    if( b_absolute )
    {
        i_offset = i_system - cl->ref.i_system - ClockGetTsOffset( cl );
    }
    else
    {
        if( !cl->b_has_external_clock )
        {
            cl->b_has_external_clock = true;
            cl->i_external_clock     = i_system;
        }
        i_offset = i_system - cl->i_external_clock;
    }

    cl->ref.i_system += i_offset;
    cl->last.i_system += i_offset;

    vlc_mutex_unlock( &cl->lock );
}",1,1,input\clock.c,input_clock_ChangeSystemOrigin,,false,500,524,input_clock_ChangeSystemOrigin,,,26,"void input_clock_ChangeSystemOrigin (input_clock_t*,bool,mtime_t)"
25180,METHOD,input\clock.c:<global>,TYPE_DECL,"void input_clock_GetSystemOrigin( input_clock_t *cl, mtime_t *pi_system, mtime_t *pi_delay )
{
    vlc_mutex_lock( &cl->lock );

    assert( cl->b_has_reference );

    *pi_system = cl->ref.i_system;
    if( pi_delay )
        *pi_delay  = cl->i_pts_delay;

    vlc_mutex_unlock( &cl->lock );
}",1,1,input\clock.c,input_clock_GetSystemOrigin,,false,526,537,input_clock_GetSystemOrigin,,,27,"void input_clock_GetSystemOrigin (input_clock_t*,mtime_t*,mtime_t*)"
25218,METHOD,input\clock.c:<global>,TYPE_DECL,"void input_clock_SetJitter( input_clock_t *cl,
                            mtime_t i_pts_delay, int i_cr_average )
{
    vlc_mutex_lock( &cl->lock );

    /* Update late observations */
    const mtime_t i_delay_delta = i_pts_delay - cl->i_pts_delay;
    mtime_t pi_late[INPUT_CLOCK_LATE_COUNT];
    for( int i = 0; i < INPUT_CLOCK_LATE_COUNT; i++ )
        pi_late[i] = __MAX( cl->late.pi_value[(cl->late.i_index + 1 + i)%INPUT_CLOCK_LATE_COUNT] - i_delay_delta, 0 );

    for( int i = 0; i < INPUT_CLOCK_LATE_COUNT; i++ )
        cl->late.pi_value[i] = 0;
    cl->late.i_index = 0;

    for( int i = 0; i < INPUT_CLOCK_LATE_COUNT; i++ )
    {
        if( pi_late[i] <= 0 )
            continue;
        cl->late.pi_value[cl->late.i_index] = pi_late[i];
        cl->late.i_index = ( cl->late.i_index + 1 ) % INPUT_CLOCK_LATE_COUNT;
    }

    /* TODO always save the value, and when rebuffering use the new one if smaller
     * TODO when increasing -> force rebuffering
     */
    if( cl->i_pts...",1,20,input\clock.c,input_clock_SetJitter,,false,540,577,input_clock_SetJitter,,,28,"void input_clock_SetJitter (input_clock_t*,mtime_t,int)"
25402,METHOD,input\clock.c:<global>,TYPE_DECL,"mtime_t input_clock_GetJitter( input_clock_t *cl )
{
    vlc_mutex_lock( &cl->lock );

#if INPUT_CLOCK_LATE_COUNT != 3
#   error ""unsupported INPUT_CLOCK_LATE_COUNT""
#endif
    /* Find the median of the last late values
     * It works pretty well at rejecting bad values
     *
     * XXX we only increase pts_delay over time, decreasing it is
     * not that easy if we want to be robust.
     */
    const mtime_t *p = cl->late.pi_value;
    mtime_t i_late_median = p[0] + p[1] + p[2] - __MIN(__MIN(p[0],p[1]),p[2]) - __MAX(__MAX(p[0],p[1]),p[2]);
    mtime_t i_pts_delay = cl->i_pts_delay ;

    vlc_mutex_unlock( &cl->lock );

    return i_pts_delay + i_late_median;
}",1,4,input\clock.c,input_clock_GetJitter,,false,579,599,input_clock_GetJitter,,,29,mtime_t input_clock_GetJitter (input_clock_t*)
25473,METHOD,input\clock.c:<global>,TYPE_DECL,"static mtime_t ClockStreamToSystem( input_clock_t *cl, mtime_t i_stream )
{
    if( !cl->b_has_reference )
        return VLC_TS_INVALID;

    return ( i_stream - cl->ref.i_stream ) * cl->i_rate / INPUT_RATE_DEFAULT +
           cl->ref.i_system;
}",1,1,input\clock.c,ClockStreamToSystem,,false,604,611,ClockStreamToSystem,,,30,"mtime_t ClockStreamToSystem (input_clock_t*,mtime_t)"
25507,METHOD,input\clock.c:<global>,TYPE_DECL,"static mtime_t ClockSystemToStream( input_clock_t *cl, mtime_t i_system )
{
    assert( cl->b_has_reference );
    return ( i_system - cl->ref.i_system ) * INPUT_RATE_DEFAULT / cl->i_rate +
            cl->ref.i_stream;
}",1,1,input\clock.c,ClockSystemToStream,,false,618,623,ClockSystemToStream,,,31,"mtime_t ClockSystemToStream (input_clock_t*,mtime_t)"
25537,METHOD,input\clock.c:<global>,TYPE_DECL,"static mtime_t ClockGetTsOffset( input_clock_t *cl )
{
    return cl->i_pts_delay * ( cl->i_rate - INPUT_RATE_DEFAULT ) / INPUT_RATE_DEFAULT;
}",1,1,input\clock.c,ClockGetTsOffset,,false,629,632,ClockGetTsOffset,,,32,mtime_t ClockGetTsOffset (input_clock_t*)
25554,METHOD,input\clock.c:<global>,TYPE_DECL,"static void AvgInit( average_t *p_avg, int i_divider )
{
    p_avg->i_divider = i_divider;
    AvgReset( p_avg );
}",1,1,input\clock.c,AvgInit,,false,637,641,AvgInit,,,33,"void AvgInit (average_t*,int)"
25567,METHOD,input\clock.c:<global>,TYPE_DECL,"static void AvgClean( average_t *p_avg )
{
    VLC_UNUSED(p_avg);
}",1,1,input\clock.c,AvgClean,,false,642,645,AvgClean,,,34,void AvgClean (average_t*)
25574,METHOD,input\clock.c:<global>,TYPE_DECL,"static void AvgReset( average_t *p_avg )
{
    p_avg->i_value = 0;
    p_avg->i_residue = 0;
    p_avg->i_count = 0;
}",1,1,input\clock.c,AvgReset,,false,646,651,AvgReset,,,35,void AvgReset (average_t*)
25594,METHOD,input\clock.c:<global>,TYPE_DECL,"static void AvgUpdate( average_t *p_avg, mtime_t i_value )
{
    const int i_f0 = __MIN( p_avg->i_divider - 1, p_avg->i_count );
    const int i_f1 = p_avg->i_divider - i_f0;

    const mtime_t i_tmp = i_f0 * p_avg->i_value + i_f1 * i_value + p_avg->i_residue;

    p_avg->i_value   = i_tmp / p_avg->i_divider;
    p_avg->i_residue = i_tmp % p_avg->i_divider;

    p_avg->i_count++;
}",1,1,input\clock.c,AvgUpdate,,false,652,663,AvgUpdate,,,36,"void AvgUpdate (average_t*,mtime_t)"
25658,METHOD,input\clock.c:<global>,TYPE_DECL,"static mtime_t AvgGet( average_t *p_avg )
{
    return p_avg->i_value;
}",1,1,input\clock.c,AvgGet,,false,664,667,AvgGet,,,37,mtime_t AvgGet (average_t*)
25667,METHOD,input\clock.c:<global>,TYPE_DECL,"static void AvgRescale( average_t *p_avg, int i_divider )
{
    const mtime_t i_tmp = p_avg->i_value * p_avg->i_divider + p_avg->i_residue;

    p_avg->i_divider = i_divider;
    p_avg->i_value   = i_tmp / p_avg->i_divider;
    p_avg->i_residue = i_tmp % p_avg->i_divider;
}",1,1,input\clock.c,AvgRescale,,false,668,675,AvgRescale,,,38,"void AvgRescale (average_t*,int)"
25717,METHOD,input\clock.h:<global>,TYPE_DECL,<global>,1,6,input\clock.h,input\clock.h:<global>,,false,1,139,<global>,,,1,
25721,METHOD,input\clock.h:<global>,TYPE_DECL,input_clock_t *input_clock_New( int i_rate );,15,44,input\clock.h,input_clock_New,,false,43,43,input_clock_New,,,3,input_clock_t* input_clock_New (int)
25726,METHOD,input\clock.h:<global>,TYPE_DECL,void           input_clock_Delete( input_clock_t * );,16,52,input\clock.h,input_clock_Delete,,false,48,48,input_clock_Delete,,,4,void input_clock_Delete (input_clock_t*)
25731,METHOD,input\clock.h:<global>,TYPE_DECL,"void    input_clock_Update( input_clock_t *, vlc_object_t *p_log,
                            bool *pb_late,
                            bool b_can_pace_control, bool b_buffering_allowed,
                            mtime_t i_clock, mtime_t i_system );",9,63,input\clock.h,input_clock_Update,,false,57,60,input_clock_Update,,,5,"void input_clock_Update (input_clock_t*,vlc_object_t*,bool*,bool,bool,mtime_t,mtime_t)"
25742,METHOD,input\clock.h:<global>,TYPE_DECL,void    input_clock_Reset( input_clock_t * );,9,44,input\clock.h,input_clock_Reset,,false,66,66,input_clock_Reset,,,6,void input_clock_Reset (input_clock_t*)
25747,METHOD,input\clock.h:<global>,TYPE_DECL,mtime_t input_clock_GetWakeup( input_clock_t * );,9,48,input\clock.h,input_clock_GetWakeup,,false,71,71,input_clock_GetWakeup,,,7,mtime_t input_clock_GetWakeup (input_clock_t*)
25752,METHOD,input\clock.h:<global>,TYPE_DECL,"void    input_clock_ChangeRate( input_clock_t *, int i_rate );",9,61,input\clock.h,input_clock_ChangeRate,,false,76,76,input_clock_ChangeRate,,,8,"void input_clock_ChangeRate (input_clock_t*,int)"
25758,METHOD,input\clock.h:<global>,TYPE_DECL,"void    input_clock_ChangePause( input_clock_t *, bool b_paused, mtime_t i_date );",9,81,input\clock.h,input_clock_ChangePause,,false,81,81,input_clock_ChangePause,,,9,"void input_clock_ChangePause (input_clock_t*,bool,mtime_t)"
25765,METHOD,input\clock.h:<global>,TYPE_DECL,"void    input_clock_GetSystemOrigin( input_clock_t *, mtime_t *pi_system, mtime_t *pi_delay );",9,93,input\clock.h,input_clock_GetSystemOrigin,,false,87,87,input_clock_GetSystemOrigin,,,10,"void input_clock_GetSystemOrigin (input_clock_t*,mtime_t*,mtime_t*)"
25772,METHOD,input\clock.h:<global>,TYPE_DECL,"void    input_clock_ChangeSystemOrigin( input_clock_t *, bool b_absolute, mtime_t i_system );",9,92,input\clock.h,input_clock_ChangeSystemOrigin,,false,95,95,input_clock_ChangeSystemOrigin,,,11,"void input_clock_ChangeSystemOrigin (input_clock_t*,bool,mtime_t)"
25779,METHOD,input\clock.h:<global>,TYPE_DECL,"int input_clock_ConvertTS( vlc_object_t *, input_clock_t *, int *pi_rate,
                           mtime_t *pi_ts0, mtime_t *pi_ts1, mtime_t i_ts_bound );",5,81,input\clock.h,input_clock_ConvertTS,,false,111,112,input_clock_ConvertTS,,,12,"int input_clock_ConvertTS (vlc_object_t*,input_clock_t*,int*,mtime_t*,mtime_t*,mtime_t)"
25789,METHOD,input\clock.h:<global>,TYPE_DECL,int input_clock_GetRate( input_clock_t * );,5,42,input\clock.h,input_clock_GetRate,,false,117,117,input_clock_GetRate,,,13,int input_clock_GetRate (input_clock_t*)
25794,METHOD,input\clock.h:<global>,TYPE_DECL,"int input_clock_GetState( input_clock_t *,
                          mtime_t *pi_stream_start, mtime_t *pi_system_start,
                          mtime_t *pi_stream_duration, mtime_t *pi_system_duration );",5,84,input\clock.h,input_clock_GetState,,false,123,125,input_clock_GetState,,,14,"int input_clock_GetState (input_clock_t*,mtime_t*,mtime_t*,mtime_t*,mtime_t*)"
25803,METHOD,input\clock.h:<global>,TYPE_DECL,"void input_clock_SetJitter( input_clock_t *,
                            mtime_t i_pts_delay, int i_cr_average );",6,67,input\clock.h,input_clock_SetJitter,,false,130,131,input_clock_SetJitter,,,15,"void input_clock_SetJitter (input_clock_t*,mtime_t,int)"
25810,METHOD,input\clock.h:<global>,TYPE_DECL,mtime_t input_clock_GetJitter( input_clock_t * );,9,48,input\clock.h,input_clock_GetJitter,,false,137,137,input_clock_GetJitter,,,16,mtime_t input_clock_GetJitter (input_clock_t*)
25840,METHOD,input\control.c:<global>,TYPE_DECL,<global>,1,1,input\control.c,input\control.c:<global>,,false,1,663,<global>,,,1,
25842,METHOD,input\control.c:<global>,TYPE_DECL,static void UpdateBookmarksOption( input_thread_t * );,13,53,input\control.c,UpdateBookmarksOption,,false,42,42,UpdateBookmarksOption,,,1,void UpdateBookmarksOption (input_thread_t*)
25847,METHOD,input\control.c:<global>,TYPE_DECL,"int input_Control( input_thread_t *p_input, int i_query, ...  )
{
    va_list args;
    int     i_result;

    va_start( args, i_query );
    i_result = input_vaControl( p_input, i_query, args );
    va_end( args );

    return i_result;
}",1,1,input\control.c,input_Control,,false,53,63,input_Control,,,2,"int input_Control (input_thread_t*,int...)"
25868,METHOD,input\control.c:<global>,TYPE_DECL,"int input_vaControl( input_thread_t *p_input, int i_query, va_list args )
{
    input_thread_private_t *priv = input_priv(p_input);
    seekpoint_t *p_bkmk, ***ppp_bkmk;
    int i_bkmk = 0;
    int *pi_bkmk;

    int i_int, *pi_int;
    bool b_bool, *pb_bool;
    double f, *pf;
    int64_t i_64, *pi_64;

    char *psz;
    vlc_value_t val;

    switch( i_query )
    {
        case INPUT_GET_POSITION:
            pf = va_arg( args, double * );
            *pf = var_GetFloat( p_input, ""position"" );
            return VLC_SUCCESS;

        case INPUT_SET_POSITION:
            f = va_arg( args, double );
            return var_SetFloat( p_input, ""position"", f );

        case INPUT_GET_LENGTH:
            pi_64 = va_arg( args, int64_t * );
            *pi_64 = var_GetInteger( p_input, ""length"" );
            return VLC_SUCCESS;

        case INPUT_GET_TIME:
            pi_64 = va_arg( args, int64_t * );
            *pi_64 = var_GetInteger( p_input, ""time"" );
            return VLC_SUCCE...",1,1,input\control.c,input_vaControl,,false,65,589,input_vaControl,,,3,"int input_vaControl (input_thread_t*,int,va_list)"
27278,METHOD,input\control.c:<global>,TYPE_DECL,"static void UpdateBookmarksOption( input_thread_t *p_input )
{
    input_thread_private_t *priv = input_priv(p_input);
    input_item_t* item = priv->p_item;
    struct vlc_memstream vstr;

    vlc_memstream_open( &vstr );
    vlc_memstream_puts( &vstr, ""bookmarks="" );

    vlc_mutex_lock( &item->lock );
    var_Change( p_input, ""bookmark"", VLC_VAR_CLEARCHOICES, 0, 0 );

    for( int i = 0; i < priv->i_bookmark; i++ )
    {
        seekpoint_t const* sp = priv->pp_bookmark[i];

        /* Add bookmark to choice-list */
        var_Change( p_input, ""bookmark"", VLC_VAR_ADDCHOICE,
                    &(vlc_value_t){ .i_int = i },
                    &(vlc_value_t){ .psz_string = sp->psz_name } );

        /* Append bookmark to option-buffer */
        /* TODO: escape inappropriate values */
        vlc_memstream_printf( &vstr, ""%s{name=%s,time=%.3f}"",
            i > 0 ? "","" : """", sp->psz_name, ( 1. * sp->i_time_offset ) / CLOCK_FREQ );
    }

    if( vlc_memstream_close( &vstr ) )
   ...",1,1,input\control.c,UpdateBookmarksOption,,false,591,663,UpdateBookmarksOption,,,4,void UpdateBookmarksOption (input_thread_t*)
27535,METHOD,input\decoder.c:<global>,TYPE_DECL,<global>,1,1,input\decoder.c,input\decoder.c:<global>,,false,1,2391,<global>,,,1,
27552,METHOD,decoder_owner_sys_t,TYPE_DECL,"void (*pf_update_stat)( decoder_owner_sys_t *, unsigned decoded, unsigned lost );",10,84,input\decoder.c,decoder_owner_sys_t.pf_update_stat,,false,83,83,pf_update_stat,,,11,"void decoder_owner_sys_t.pf_update_stat (decoder_owner_sys_t*,unsigned,unsigned)"
27589,METHOD,<empty>,<empty>,<empty>,5,,input\decoder.c,decoder_owner_sys_t.cc:<clinit>,,false,135,,<clinit>,,,4,
27599,METHOD,input\decoder.c:<global>,TYPE_DECL,"static int LoadDecoder( decoder_t *p_dec, bool b_packetizer,
                        const es_format_t *restrict p_fmt )
{
    p_dec->b_frame_drop_allowed = true;
    p_dec->i_extra_picture_buffers = 0;

    p_dec->pf_decode = NULL;
    p_dec->pf_get_cc = NULL;
    p_dec->pf_packetize = NULL;
    p_dec->pf_flush = NULL;

    es_format_Copy( &p_dec->fmt_in, p_fmt );
    es_format_Init( &p_dec->fmt_out, p_fmt->i_cat, 0 );

    /* Find a suitable decoder/packetizer module */
    if( !b_packetizer )
    {
        static const char caps[ES_CATEGORY_COUNT][16] = {
            [VIDEO_ES] = ""video decoder"",
            [AUDIO_ES] = ""audio decoder"",
            [SPU_ES] = ""spu decoder"",
        };
        p_dec->p_module = module_need( p_dec, caps[p_dec->fmt_in.i_cat],
                                       ""$codec"", false );
    }
    else
        p_dec->p_module = module_need( p_dec, ""packetizer"", ""$packetizer"", false );

    if( !p_dec->p_module )
    {
        es_format_Clean( &p_dec->fm...",1,1,input\decoder.c,LoadDecoder,,false,157,192,LoadDecoder,,,3,"int LoadDecoder (decoder_t*,bool,es_format_t*)"
27715,METHOD,input\decoder.c:<global>,TYPE_DECL,"static void UnloadDecoder( decoder_t *p_dec )
{
    if( p_dec->p_module )
    {
        module_unneed( p_dec, p_dec->p_module );
        p_dec->p_module = NULL;
    }

    if( p_dec->p_description )
    {
        vlc_meta_Delete( p_dec->p_description );
        p_dec->p_description = NULL;
    }

    es_format_Clean( &p_dec->fmt_in );
    es_format_Clean( &p_dec->fmt_out );
}",1,1,input\decoder.c,UnloadDecoder,,false,197,213,UnloadDecoder,,,4,void UnloadDecoder (decoder_t*)
27759,METHOD,input\decoder.c:<global>,TYPE_DECL,"static int ReloadDecoder( decoder_t *p_dec, bool b_packetizer,
                          const es_format_t *restrict p_fmt, enum reload reload )
{
    /* Copy p_fmt since it can be destroyed by UnloadDecoder */
    es_format_t fmt_in;
    if( es_format_Copy( &fmt_in, p_fmt ) != VLC_SUCCESS )
    {
        p_dec->p_owner->error = true;
        return VLC_EGENERIC;
    }

    /* Restart the decoder module */
    UnloadDecoder( p_dec );
    p_dec->p_owner->error = false;

    if( reload == RELOAD_DECODER_AOUT )
    {
        decoder_owner_sys_t *p_owner = p_dec->p_owner;
        assert( p_owner->fmt.i_cat == AUDIO_ES );
        audio_output_t *p_aout = p_owner->p_aout;

        vlc_mutex_lock( &p_owner->lock );
        p_owner->p_aout = NULL;
        vlc_mutex_unlock( &p_owner->lock );
        if( p_aout )
        {
            aout_DecDelete( p_aout );
            input_resource_PutAout( p_owner->p_resource, p_aout );
        }
    }

    if( LoadDecoder( p_dec, b_packetizer, &fmt_in ...",1,1,input\decoder.c,ReloadDecoder,,false,215,254,ReloadDecoder,,,5,"int ReloadDecoder (decoder_t*,bool,es_format_t*,reload)"
27868,METHOD,input\decoder.c:<global>,TYPE_DECL,"static void DecoderUpdateFormatLocked( decoder_t *p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    vlc_assert_locked( &p_owner->lock );

    es_format_Clean( &p_owner->fmt );
    es_format_Copy( &p_owner->fmt, &p_dec->fmt_out );

    /* Move p_description */
    if( p_dec->p_description != NULL )
    {
        if( p_owner->p_description != NULL )
            vlc_meta_Delete( p_owner->p_description );
        p_owner->p_description = p_dec->p_description;
        p_dec->p_description = NULL;
    }

    p_owner->b_fmt_description = true;
}",1,1,input\decoder.c,DecoderUpdateFormatLocked,,false,256,275,DecoderUpdateFormatLocked,,,6,void DecoderUpdateFormatLocked (decoder_t*)
27933,METHOD,input\decoder.c:<global>,TYPE_DECL,"static vout_thread_t *aout_request_vout( void *p_private,
                                         vout_thread_t *p_vout,
                                         const video_format_t *p_fmt, bool b_recyle )
{
    decoder_t *p_dec = p_private;
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    input_thread_t *p_input = p_owner->p_input;
    video_format_t fmt;

    if (p_fmt != NULL)
    {
        fmt = *p_fmt;
        p_fmt = &fmt;
        video_format_AdjustColorSpace( &fmt );
    }

    p_vout = input_resource_RequestVout( p_owner->p_resource, p_vout, p_fmt, 1,
                                         b_recyle );
    if( p_input != NULL )
        input_SendEventVout( p_input );

    return p_vout;
}",1,1,input\decoder.c,aout_request_vout,,false,280,302,aout_request_vout,,,7,"vout_thread_t aout_request_vout (void*,vout_thread_t*,video_format_t*,bool)"
27993,METHOD,input\decoder.c:<global>,TYPE_DECL,"static bool aout_replaygain_changed( const audio_replay_gain_t *a,
                                     const audio_replay_gain_t *b )
{
    for( size_t i=0; i<AUDIO_REPLAY_GAIN_MAX; i++ )
    {
        if( a->pb_gain[i] != b->pb_gain[i] ||
            a->pb_peak[i] != b->pb_peak[i] ||
            a->pb_gain[i] != b->pb_gain[i] ||
            a->pb_peak[i] != b->pb_peak[i] )
            return true;
    }
    return false;
}",1,1,input\decoder.c,aout_replaygain_changed,,false,304,316,aout_replaygain_changed,,,8,"bool aout_replaygain_changed (audio_replay_gain_t*,audio_replay_gain_t*)"
28064,METHOD,input\decoder.c:<global>,TYPE_DECL,"static int aout_update_format( decoder_t *p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    if( p_owner->p_aout &&
       ( !AOUT_FMTS_IDENTICAL(&p_dec->fmt_out.audio, &p_owner->fmt.audio) ||
         p_dec->fmt_out.i_codec != p_dec->fmt_out.audio.i_format ||
         p_dec->fmt_out.i_profile != p_owner->fmt.i_profile ) )
    {
        audio_output_t *p_aout = p_owner->p_aout;

        /* Parameters changed, restart the aout */
        vlc_mutex_lock( &p_owner->lock );
        p_owner->p_aout = NULL;
        vlc_mutex_unlock( &p_owner->lock );
        aout_DecDelete( p_aout );

        input_resource_PutAout( p_owner->p_resource, p_aout );
    }

    /* Check if only replay gain has changed */
    if( aout_replaygain_changed( &p_dec->fmt_in.audio_replay_gain,
                                 &p_owner->fmt.audio_replay_gain ) )
    {
        p_dec->fmt_out.audio_replay_gain = p_dec->fmt_in.audio_replay_gain;
        if( p_owner->p_aout )
        {
            p_owner-...",1,1,input\decoder.c,aout_update_format,,false,318,412,aout_update_format,,,9,int aout_update_format (decoder_t*)
28403,METHOD,input\decoder.c:<global>,TYPE_DECL,"static int vout_update_format( decoder_t *p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    if( p_owner->p_vout == NULL
     || p_dec->fmt_out.video.i_width != p_owner->fmt.video.i_width
     || p_dec->fmt_out.video.i_height != p_owner->fmt.video.i_height
     || p_dec->fmt_out.video.i_visible_width != p_owner->fmt.video.i_visible_width
     || p_dec->fmt_out.video.i_visible_height != p_owner->fmt.video.i_visible_height
     || p_dec->fmt_out.video.i_x_offset != p_owner->fmt.video.i_x_offset
     || p_dec->fmt_out.video.i_y_offset != p_owner->fmt.video.i_y_offset
     || p_dec->fmt_out.i_codec != p_owner->fmt.video.i_chroma
     || (int64_t)p_dec->fmt_out.video.i_sar_num * p_owner->fmt.video.i_sar_den !=
        (int64_t)p_dec->fmt_out.video.i_sar_den * p_owner->fmt.video.i_sar_num ||
        p_dec->fmt_out.video.orientation != p_owner->fmt.video.orientation ||
        p_dec->fmt_out.video.multiview_mode != p_owner->fmt.video.multiview_mode )
    {
        vout_threa...",1,1,input\decoder.c,vout_update_format,,false,414,561,vout_update_format,,,10,int vout_update_format (decoder_t*)
29122,METHOD,input\decoder.c:<global>,TYPE_DECL,"static picture_t *vout_new_buffer( decoder_t *p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    assert( p_owner->p_vout );

    return vout_GetPicture( p_owner->p_vout );
}",1,1,input\decoder.c,vout_new_buffer,,false,563,569,vout_new_buffer,,,11,picture_t vout_new_buffer (decoder_t*)
29142,METHOD,input\decoder.c:<global>,TYPE_DECL,"static subpicture_t *spu_new_buffer( decoder_t *p_dec,
                                     const subpicture_updater_t *p_updater )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    vout_thread_t *p_vout = NULL;
    subpicture_t *p_subpic;
    int i_attempts = 30;

    while( i_attempts-- )
    {
        if( p_owner->error )
            break;

        p_vout = input_resource_HoldVout( p_owner->p_resource );
        if( p_vout )
            break;

        msleep( DECODER_SPU_VOUT_WAIT_DURATION );
    }

    if( !p_vout )
    {
        msg_Warn( p_dec, ""no vout found, dropping subpicture"" );
        return NULL;
    }

    if( p_owner->p_spu_vout != p_vout )
    {
        p_owner->i_spu_channel = vout_RegisterSubpictureChannel( p_vout );
        p_owner->i_spu_order = 0;
        p_owner->p_spu_vout = p_vout;
    }

    p_subpic = subpicture_New( p_updater );
    if( p_subpic )
    {
        p_subpic->i_channel = p_owner->i_spu_channel;
        p_subpic->i_order = p_owner->i_s...",1,16,input\decoder.c,spu_new_buffer,,false,571,615,spu_new_buffer,,,12,"subpicture_t spu_new_buffer (decoder_t*,subpicture_updater_t*)"
29254,METHOD,input\decoder.c:<global>,TYPE_DECL,"static int DecoderGetInputAttachments( decoder_t *p_dec,
                                       input_attachment_t ***ppp_attachment,
                                       int *pi_attachment )
{
    input_thread_t *p_input = p_dec->p_owner->p_input;

    if( unlikely(p_input == NULL) )
        return VLC_ENOOBJ;
    return input_Control( p_input, INPUT_GET_ATTACHMENTS,
                          ppp_attachment, pi_attachment );
}",1,1,input\decoder.c,DecoderGetInputAttachments,,false,617,627,DecoderGetInputAttachments,,,13,"int DecoderGetInputAttachments (decoder_t*,input_attachment_t***,int*)"
29283,METHOD,input\decoder.c:<global>,TYPE_DECL,"static mtime_t DecoderGetDisplayDate( decoder_t *p_dec, mtime_t i_ts )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    vlc_mutex_lock( &p_owner->lock );
    if( p_owner->b_waiting || p_owner->paused )
        i_ts = VLC_TS_INVALID;
    vlc_mutex_unlock( &p_owner->lock );

    if( !p_owner->p_clock || i_ts <= VLC_TS_INVALID )
        return i_ts;

    if( input_clock_ConvertTS( VLC_OBJECT(p_dec), p_owner->p_clock, NULL, &i_ts, NULL, INT64_MAX ) ) {
        msg_Err(p_dec, ""Could not get display date for timestamp %""PRId64"""", i_ts);
        return VLC_TS_INVALID;
    }

    return i_ts;
}",1,1,input\decoder.c,DecoderGetDisplayDate,,false,629,647,DecoderGetDisplayDate,,,14,"mtime_t DecoderGetDisplayDate (decoder_t*,mtime_t)"
29347,METHOD,input\decoder.c:<global>,TYPE_DECL,"static int DecoderGetDisplayRate( decoder_t *p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    if( !p_owner->p_clock )
        return INPUT_RATE_DEFAULT;
    return input_clock_GetRate( p_owner->p_clock );
}",1,1,input\decoder.c,DecoderGetDisplayRate,,false,649,656,DecoderGetDisplayRate,,,15,int DecoderGetDisplayRate (decoder_t*)
29371,METHOD,input\decoder.c:<global>,TYPE_DECL,"block_t *decoder_NewAudioBuffer( decoder_t *dec, int samples )
{
    assert( dec->fmt_out.audio.i_frame_length > 0
         && dec->fmt_out.audio.i_bytes_per_frame  > 0 );

    size_t length = samples * dec->fmt_out.audio.i_bytes_per_frame
                            / dec->fmt_out.audio.i_frame_length;
    block_t *block = block_Alloc( length );
    if( likely(block != NULL) )
    {
        block->i_nb_samples = samples;
        block->i_pts = block->i_length = 0;
    }
    return block;
}",1,1,input\decoder.c,decoder_NewAudioBuffer,,false,661,675,decoder_NewAudioBuffer,,,16,"block_t decoder_NewAudioBuffer (decoder_t*,int)"
29444,METHOD,input\decoder.c:<global>,TYPE_DECL,"subpicture_t *decoder_NewSubpicture( decoder_t *p_decoder,
                                     const subpicture_updater_t *p_dyn )
{
    subpicture_t *p_subpicture = p_decoder->pf_spu_buffer_new( p_decoder, p_dyn );
    if( !p_subpicture )
        msg_Warn( p_decoder, ""can't get output subpicture"" );
    return p_subpicture;
}",1,1,input\decoder.c,decoder_NewSubpicture,,false,677,684,decoder_NewSubpicture,,,17,"subpicture_t decoder_NewSubpicture (decoder_t*,subpicture_updater_t*)"
29468,METHOD,input\decoder.c:<global>,TYPE_DECL,"static void RequestReload( decoder_t * p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    /* Don't override reload if it's RELOAD_DECODER_AOUT */
    int expected = RELOAD_NO_REQUEST;
    atomic_compare_exchange_strong( &p_owner->reload, &expected, RELOAD_DECODER );
}",1,1,input\decoder.c,RequestReload,,false,686,692,RequestReload,,,18,void RequestReload (decoder_t*)
29491,METHOD,input\decoder.c:<global>,TYPE_DECL,"int decoder_GetInputAttachments( decoder_t *p_dec,
                                 input_attachment_t ***ppp_attachment,
                                 int *pi_attachment )
{
    if( !p_dec->pf_get_attachments )
        return VLC_EGENERIC;

    return p_dec->pf_get_attachments( p_dec, ppp_attachment, pi_attachment );
}",1,1,input\decoder.c,decoder_GetInputAttachments,,false,696,704,decoder_GetInputAttachments,,,19,"int decoder_GetInputAttachments (decoder_t*,input_attachment_t***,int*)"
29514,METHOD,input\decoder.c:<global>,TYPE_DECL,"mtime_t decoder_GetDisplayDate( decoder_t *p_dec, mtime_t i_ts )
{
    if( !p_dec->pf_get_display_date )
        return VLC_TS_INVALID;

    return p_dec->pf_get_display_date( p_dec, i_ts );
}",1,1,input\decoder.c,decoder_GetDisplayDate,,false,707,713,decoder_GetDisplayDate,,,20,"mtime_t decoder_GetDisplayDate (decoder_t*,mtime_t)"
29535,METHOD,input\decoder.c:<global>,TYPE_DECL,"int decoder_GetDisplayRate( decoder_t *p_dec )
{
    if( !p_dec->pf_get_display_rate )
        return INPUT_RATE_DEFAULT;

    return p_dec->pf_get_display_rate( p_dec );
}",1,1,input\decoder.c,decoder_GetDisplayRate,,false,716,722,decoder_GetDisplayRate,,,21,int decoder_GetDisplayRate (decoder_t*)
29554,METHOD,input\decoder.c:<global>,TYPE_DECL,"void decoder_AbortPictures( decoder_t *p_dec, bool b_abort )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    vlc_mutex_lock( &p_owner->lock );
    if( p_owner->p_vout != NULL )
        vout_Cancel( p_owner->p_vout, b_abort );
    vlc_mutex_unlock( &p_owner->lock );
}",1,1,input\decoder.c,decoder_AbortPictures,,false,724,732,decoder_AbortPictures,,,22,"void decoder_AbortPictures (decoder_t*,bool)"
29588,METHOD,input\decoder.c:<global>,TYPE_DECL,"static void DecoderWaitUnblock( decoder_t *p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    vlc_assert_locked( &p_owner->lock );

    for( ;; )
    {
        if( !p_owner->b_waiting || !p_owner->b_has_data )
            break;
        vlc_cond_wait( &p_owner->wait_request, &p_owner->lock );
    }
}",1,1,input\decoder.c,DecoderWaitUnblock,,false,734,746,DecoderWaitUnblock,,,23,void DecoderWaitUnblock (decoder_t*)
29628,METHOD,input\decoder.c:<global>,TYPE_DECL,"static int DecoderTimedWait( decoder_t *p_dec, mtime_t deadline )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    if (deadline - mdate() <= 0)
        return VLC_SUCCESS;

    vlc_fifo_Lock( p_owner->p_fifo );
    while( !p_owner->flushing
        && vlc_fifo_TimedWaitCond( p_owner->p_fifo, &p_owner->wait_timed,
                                   deadline ) == 0 );
    int ret = p_owner->flushing ? VLC_EGENERIC : VLC_SUCCESS;
    vlc_fifo_Unlock( p_owner->p_fifo );
    return ret;
}",1,1,input\decoder.c,DecoderTimedWait,,false,750,764,DecoderTimedWait,,,24,"int DecoderTimedWait (decoder_t*,mtime_t)"
29685,METHOD,input\decoder.c:<global>,TYPE_DECL,"static inline void DecoderUpdatePreroll( int64_t *pi_preroll, const block_t *p )
{
    if( p->i_flags & BLOCK_FLAG_PREROLL )
        *pi_preroll = INT64_MAX;
    /* Check if we can use the packet for end of preroll */
    else if( (p->i_flags & BLOCK_FLAG_DISCONTINUITY) &&
             (p->i_buffer == 0 || (p->i_flags & BLOCK_FLAG_CORRUPTED)) )
        *pi_preroll = INT64_MAX;
    else if( p->i_dts > VLC_TS_INVALID )
        *pi_preroll = __MIN( *pi_preroll, p->i_dts );
    else if( p->i_pts > VLC_TS_INVALID )
        *pi_preroll = __MIN( *pi_preroll, p->i_pts );
}",1,1,input\decoder.c,DecoderUpdatePreroll,,false,766,778,DecoderUpdatePreroll,,,25,"void DecoderUpdatePreroll (int64_t*,block_t*)"
29763,METHOD,input\decoder.c:<global>,TYPE_DECL,"static void DecoderFixTs( decoder_t *p_dec, mtime_t *pi_ts0, mtime_t *pi_ts1,
                          mtime_t *pi_duration, int *pi_rate, mtime_t i_ts_bound )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    input_clock_t   *p_clock = p_owner->p_clock;

    vlc_assert_locked( &p_owner->lock );

    const mtime_t i_es_delay = p_owner->i_ts_delay;

    if( !p_clock )
        return;

    const bool b_ephemere = pi_ts1 && *pi_ts0 == *pi_ts1;
    int i_rate;

    if( *pi_ts0 > VLC_TS_INVALID )
    {
        *pi_ts0 += i_es_delay;
        if( pi_ts1 && *pi_ts1 > VLC_TS_INVALID )
            *pi_ts1 += i_es_delay;
        if( i_ts_bound != INT64_MAX )
            i_ts_bound += i_es_delay;
        if( input_clock_ConvertTS( VLC_OBJECT(p_dec), p_clock, &i_rate, pi_ts0, pi_ts1, i_ts_bound ) ) {
            const char *psz_name = module_get_name( p_dec->p_module, false );
            if( pi_ts1 != NULL )
                msg_Err(p_dec, ""Could not convert timestamps %""PRId64
         ...",1,1,input\decoder.c,DecoderFixTs,,false,780,828,DecoderFixTs,,,26,"void DecoderFixTs (decoder_t*,mtime_t*,mtime_t*,mtime_t*,int*,mtime_t)"
29912,METHOD,input\decoder.c:<global>,TYPE_DECL,"static void DecoderPlayCc( decoder_t *p_dec, block_t *p_cc,
                           const decoder_cc_desc_t *p_desc )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    vlc_mutex_lock( &p_owner->lock );

    p_owner->cc.desc = *p_desc;

    /* Fanout data to all decoders. We do not know if es_out
       selected 608 or 708. */
    uint64_t i_bitmap = p_owner->cc.desc.i_608_channels |
                        p_owner->cc.desc.i_708_channels;

    for( int i=0; i_bitmap > 0; i_bitmap >>= 1, i++ )
    {
        decoder_t *p_ccdec = p_owner->cc.pp_decoder[i];
        if( !p_ccdec )
            continue;

        if( i_bitmap > 1 )
        {
            block_FifoPut( p_ccdec->p_owner->p_fifo, block_Duplicate(p_cc) );
        }
        else
        {
            block_FifoPut( p_ccdec->p_owner->p_fifo, p_cc );
            p_cc = NULL; /* was last dec */
        }
    }

    vlc_mutex_unlock( &p_owner->lock );

    if( p_cc ) /* can have bitmap set but no created decs */
        ...",1,1,input\decoder.c,DecoderPlayCc,,false,927,962,DecoderPlayCc,,,27,"void DecoderPlayCc (decoder_t*,block_t*,decoder_cc_desc_t*)"
30022,METHOD,input\decoder.c:<global>,TYPE_DECL,"static void PacketizerGetCc( decoder_t *p_dec, decoder_t *p_dec_cc )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    block_t *p_cc;
    decoder_cc_desc_t desc;

    /* Do not try retreiving CC if not wanted (sout) or cannot be retreived */
    if( !p_owner->cc.b_supported )
        return;

    assert( p_dec_cc->pf_get_cc != NULL );

    p_cc = p_dec_cc->pf_get_cc( p_dec_cc, &desc );
    if( !p_cc )
        return;
    DecoderPlayCc( p_dec, p_cc, &desc );
}",1,1,input\decoder.c,PacketizerGetCc,,false,964,980,PacketizerGetCc,,,28,"void PacketizerGetCc (decoder_t*,decoder_t*)"
30070,METHOD,input\decoder.c:<global>,TYPE_DECL,"static int DecoderQueueCc( decoder_t *p_videodec, block_t *p_cc,
                           const decoder_cc_desc_t *p_desc )
{
    decoder_owner_sys_t *p_owner = p_videodec->p_owner;

    if( unlikely( p_cc != NULL ) )
    {
        if( p_owner->cc.b_supported &&
           ( !p_owner->p_packetizer || !p_owner->p_packetizer->pf_get_cc ) )
            DecoderPlayCc( p_videodec, p_cc, p_desc );
        else
            block_Release( p_cc );
    }
    return 0;
}",1,1,input\decoder.c,DecoderQueueCc,,false,982,996,DecoderQueueCc,,,29,"int DecoderQueueCc (decoder_t*,block_t*,decoder_cc_desc_t*)"
30118,METHOD,input\decoder.c:<global>,TYPE_DECL,"static int DecoderPlayVideo( decoder_t *p_dec, picture_t *p_picture,
                             unsigned *restrict pi_lost_sum )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    vout_thread_t  *p_vout = p_owner->p_vout;
    bool prerolled;

    vlc_mutex_lock( &p_owner->lock );
    if( p_owner->i_preroll_end > p_picture->date )
    {
        vlc_mutex_unlock( &p_owner->lock );
        picture_Release( p_picture );
        return -1;
    }

    prerolled = p_owner->i_preroll_end > INT64_MIN;
    p_owner->i_preroll_end = INT64_MIN;
    vlc_mutex_unlock( &p_owner->lock );

    if( unlikely(prerolled) )
    {
        msg_Dbg( p_dec, ""end of video preroll"" );

        if( p_vout )
            vout_Flush( p_vout, VLC_TS_INVALID+1 );
    }

    if( p_picture->date <= VLC_TS_INVALID )
    {
        msg_Warn( p_dec, ""non-dated video buffer received"" );
        goto discard;
    }

    /* */
    vlc_mutex_lock( &p_owner->lock );

    if( p_owner->b_waiting && !p_owner->b_first )
   ...",1,27,input\decoder.c,DecoderPlayVideo,,false,998,1094,DecoderPlayVideo,,,30,"int DecoderPlayVideo (decoder_t*,picture_t*,unsigned*)"
30386,METHOD,input\decoder.c:<global>,TYPE_DECL,"static void DecoderUpdateStatVideo( decoder_owner_sys_t *p_owner,
                                    unsigned decoded, unsigned lost )
{
    input_thread_t *p_input = p_owner->p_input;
    unsigned displayed = 0;

    /* Update ugly stat */
    if( p_input == NULL )
        return;

    if( p_owner->p_vout != NULL )
    {
        unsigned vout_lost = 0;

        vout_GetResetStatistic( p_owner->p_vout, &displayed, &vout_lost );
        lost += vout_lost;
    }

    vlc_mutex_lock( &input_priv(p_input)->counters.counters_lock );
    stats_Update( input_priv(p_input)->counters.p_decoded_video, decoded, NULL );
    stats_Update( input_priv(p_input)->counters.p_lost_pictures, lost , NULL);
    stats_Update( input_priv(p_input)->counters.p_displayed_pictures, displayed, NULL);
    vlc_mutex_unlock( &input_priv(p_input)->counters.counters_lock );
}",1,1,input\decoder.c,DecoderUpdateStatVideo,,false,1096,1119,DecoderUpdateStatVideo,,,31,"void DecoderUpdateStatVideo (decoder_owner_sys_t*,unsigned,unsigned)"
30474,METHOD,input\decoder.c:<global>,TYPE_DECL,"static int DecoderQueueVideo( decoder_t *p_dec, picture_t *p_pic )
{
    assert( p_pic );
    unsigned i_lost = 0;
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    int ret = DecoderPlayVideo( p_dec, p_pic, &i_lost );

    p_owner->pf_update_stat( p_owner, 1, i_lost );
    return ret;
}",1,1,input\decoder.c,DecoderQueueVideo,,false,1121,1131,DecoderQueueVideo,,,32,"int DecoderQueueVideo (decoder_t*,picture_t*)"
30509,METHOD,input\decoder.c:<global>,TYPE_DECL,"static int DecoderPlayAudio( decoder_t *p_dec, block_t *p_audio,
                             unsigned *restrict pi_lost_sum )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    bool prerolled;

    assert( p_audio != NULL );

    vlc_mutex_lock( &p_owner->lock );
    if( p_owner->i_preroll_end > p_audio->i_pts )
    {
        vlc_mutex_unlock( &p_owner->lock );
        block_Release( p_audio );
        return -1;
    }

    prerolled = p_owner->i_preroll_end > INT64_MIN;
    p_owner->i_preroll_end = INT64_MIN;
    vlc_mutex_unlock( &p_owner->lock );

    if( unlikely(prerolled) )
    {
        msg_Dbg( p_dec, ""end of audio preroll"" );

        if( p_owner->p_aout )
            aout_DecFlush( p_owner->p_aout, false );
    }

    /* */
    if( p_audio->i_pts <= VLC_TS_INVALID ) // FIXME --VLC_TS_INVALID verify audio_output/*
    {
        msg_Warn( p_dec, ""non-dated audio buffer received"" );
        *pi_lost_sum += 1;
        block_Release( p_audio );
        return 0;
    }

 ...",1,37,input\decoder.c,DecoderPlayAudio,,false,1133,1214,DecoderPlayAudio,,,33,"int DecoderPlayAudio (decoder_t*,block_t*,unsigned*)"
30734,METHOD,input\decoder.c:<global>,TYPE_DECL,"static void DecoderUpdateStatAudio( decoder_owner_sys_t *p_owner,
                                    unsigned decoded, unsigned lost )
{
    input_thread_t *p_input = p_owner->p_input;
    unsigned played = 0;

    /* Update ugly stat */
    if( p_input == NULL )
        return;

    if( p_owner->p_aout != NULL )
    {
        unsigned aout_lost;

        aout_DecGetResetStats( p_owner->p_aout, &aout_lost, &played );
        lost += aout_lost;
    }

    vlc_mutex_lock( &input_priv(p_input)->counters.counters_lock);
    stats_Update( input_priv(p_input)->counters.p_lost_abuffers, lost, NULL );
    stats_Update( input_priv(p_input)->counters.p_played_abuffers, played, NULL );
    stats_Update( input_priv(p_input)->counters.p_decoded_audio, decoded, NULL );
    vlc_mutex_unlock( &input_priv(p_input)->counters.counters_lock);
}",1,1,input\decoder.c,DecoderUpdateStatAudio,,false,1216,1239,DecoderUpdateStatAudio,,,34,"void DecoderUpdateStatAudio (decoder_owner_sys_t*,unsigned,unsigned)"
30819,METHOD,input\decoder.c:<global>,TYPE_DECL,"static int DecoderQueueAudio( decoder_t *p_dec, block_t *p_aout_buf )
{
    unsigned lost = 0;
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    int ret = DecoderPlayAudio( p_dec, p_aout_buf, &lost );

    p_owner->pf_update_stat( p_owner, 1, lost );

    return ret;
}",1,1,input\decoder.c,DecoderQueueAudio,,false,1241,1251,DecoderQueueAudio,,,35,"int DecoderQueueAudio (decoder_t*,block_t*)"
30852,METHOD,input\decoder.c:<global>,TYPE_DECL,"static void DecoderPlaySpu( decoder_t *p_dec, subpicture_t *p_subpic )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    vout_thread_t *p_vout = p_owner->p_spu_vout;

    /* */
    if( p_subpic->i_start <= VLC_TS_INVALID )
    {
        msg_Warn( p_dec, ""non-dated spu buffer received"" );
        subpicture_Delete( p_subpic );
        return;
    }

    /* */
    vlc_mutex_lock( &p_owner->lock );

    if( p_owner->b_waiting )
    {
        p_owner->b_has_data = true;
        vlc_cond_signal( &p_owner->wait_acknowledge );
    }

    DecoderWaitUnblock( p_dec );
    DecoderFixTs( p_dec, &p_subpic->i_start, &p_subpic->i_stop, NULL,
                  NULL, INT64_MAX );
    vlc_mutex_unlock( &p_owner->lock );

    if( p_subpic->i_start <= VLC_TS_INVALID
     || DecoderTimedWait( p_dec, p_subpic->i_start - SPU_MAX_PREPARE_TIME ) )
    {
        subpicture_Delete( p_subpic );
        return;
    }

    vout_PutSubpicture( p_vout, p_subpic );
}",1,1,input\decoder.c,DecoderPlaySpu,,false,1253,1288,DecoderPlaySpu,,,36,"void DecoderPlaySpu (decoder_t*,subpicture_t*)"
30944,METHOD,input\decoder.c:<global>,TYPE_DECL,"static void DecoderUpdateStatSpu( decoder_owner_sys_t *p_owner,
                                  unsigned decoded, unsigned lost )
{
    (void) p_owner; (void) decoded; (void) lost;
}",1,1,input\decoder.c,DecoderUpdateStatSpu,,false,1290,1294,DecoderUpdateStatSpu,,,37,"void DecoderUpdateStatSpu (decoder_owner_sys_t*,unsigned,unsigned)"
30960,METHOD,input\decoder.c:<global>,TYPE_DECL,"static int DecoderQueueSpu( decoder_t *p_dec, subpicture_t *p_spu )
{
    assert( p_spu );
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    input_thread_t *p_input = p_owner->p_input;

    if( p_input != NULL )
    {
        vlc_mutex_lock( &input_priv(p_input)->counters.counters_lock );
        stats_Update( input_priv(p_input)->counters.p_decoded_sub, 1, NULL );
        vlc_mutex_unlock( &input_priv(p_input)->counters.counters_lock );
    }

    int i_ret = -1;
    vout_thread_t *p_vout = input_resource_HoldVout( p_owner->p_resource );
    if( p_vout && p_owner->p_spu_vout == p_vout )
    {
        /* Preroll does not work very well with subtitle */
        vlc_mutex_lock( &p_owner->lock );
        if( p_spu->i_start > VLC_TS_INVALID &&
            p_spu->i_start < p_owner->i_preroll_end &&
            ( p_spu->i_stop <= VLC_TS_INVALID || p_spu->i_stop < p_owner->i_preroll_end ) )
        {
            vlc_mutex_unlock( &p_owner->lock );
            subpicture_Delete( p_spu ...",1,1,input\decoder.c,DecoderQueueSpu,,false,1296,1336,DecoderQueueSpu,,,38,"int DecoderQueueSpu (decoder_t*,subpicture_t*)"
31096,METHOD,input\decoder.c:<global>,TYPE_DECL,"static void DecoderProcess( decoder_t *p_dec, block_t *p_block );",13,64,input\decoder.c,DecoderProcess,,false,1338,1338,DecoderProcess,,,39,"void DecoderProcess (decoder_t*,block_t*)"
31102,METHOD,input\decoder.c:<global>,TYPE_DECL,"static void DecoderDecode( decoder_t *p_dec, block_t *p_block )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    int ret = p_dec->pf_decode( p_dec, p_block );
    switch( ret )
    {
        case VLCDEC_SUCCESS:
            p_owner->pf_update_stat( p_owner, 1, 0 );
            break;
        case VLCDEC_ECRITICAL:
            p_owner->error = true;
            break;
        case VLCDEC_RELOAD:
            RequestReload( p_dec );
            if( unlikely( p_block == NULL ) )
                break;
            if( !( p_block->i_flags & BLOCK_FLAG_CORE_PRIVATE_RELOADED ) )
            {
                p_block->i_flags |= BLOCK_FLAG_CORE_PRIVATE_RELOADED;
                DecoderProcess( p_dec, p_block );
            }
            else /* We prefer loosing this block than an infinite recursion */
                block_Release( p_block );
            break;
        default:
            vlc_assert_unreachable();
    }
}",1,38,input\decoder.c,DecoderDecode,,false,1339,1367,DecoderDecode,,,40,"void DecoderDecode (decoder_t*,block_t*)"
31186,METHOD,input\decoder.c:<global>,TYPE_DECL,"static void DecoderProcess( decoder_t *p_dec, block_t *p_block )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    if( p_owner->error )
        goto error;

    /* Here, the atomic doesn't prevent to miss a reload request.
     * DecoderProcess() can still be called after the decoder module or the
     * audio output requested a reload. This will only result in a drop of an
     * input block or an output buffer. */
    enum reload reload;
    if( ( reload = atomic_exchange( &p_owner->reload, RELOAD_NO_REQUEST ) ) )
    {
        msg_Warn( p_dec, ""Reloading the decoder module%s"",
                  reload == RELOAD_DECODER_AOUT ? "" and the audio output"" : """" );

        if( ReloadDecoder( p_dec, false, &p_dec->fmt_in, reload ) != VLC_SUCCESS )
            goto error;
    }

    bool packetize = p_owner->p_packetizer != NULL;
    if( p_block )
    {
        if( p_block->i_buffer <= 0 )
            goto error;

        vlc_mutex_lock( &p_owner->lock );
        DecoderUpdatePrer...",1,41,input\decoder.c,DecoderProcess,,false,1375,1472,DecoderProcess,,,41,"void DecoderProcess (decoder_t*,block_t*)"
31403,METHOD,input\decoder.c:<global>,TYPE_DECL,"static void DecoderProcessFlush( decoder_t *p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    decoder_t *p_packetizer = p_owner->p_packetizer;

    if( p_owner->error )
        return;

    if( p_packetizer != NULL && p_packetizer->pf_flush != NULL )
        p_packetizer->pf_flush( p_packetizer );

    if ( p_dec->pf_flush != NULL )
        p_dec->pf_flush( p_dec );

    /* flush CC sub decoders */
    if( p_owner->cc.b_supported )
    {
        for( int i=0; i<MAX_CC_DECODERS; i++ )
        {
            decoder_t *p_subdec = p_owner->cc.pp_decoder[i];
            if( p_subdec && p_subdec->pf_flush )
                p_subdec->pf_flush( p_subdec );
        }
    }

#ifdef ENABLE_SOUT
    if ( p_owner->p_sout_input != NULL )
    {
        sout_InputFlush( p_owner->p_sout_input );
    }
#endif
    if( p_dec->fmt_out.i_cat == AUDIO_ES )
    {
        if( p_owner->p_aout )
            aout_DecFlush( p_owner->p_aout, false );
    }
    else if( p_dec->fmt_out.i_cat == VIDE...",1,24,input\decoder.c,DecoderProcessFlush,,false,1474,1532,DecoderProcessFlush,,,42,void DecoderProcessFlush (decoder_t*)
31596,METHOD,input\decoder.c:<global>,TYPE_DECL,"static void *DecoderThread( void *p_data )
{
    decoder_t *p_dec = (decoder_t *)p_data;
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    bool paused = false;

    /* The decoder's main loop */
    vlc_fifo_Lock( p_owner->p_fifo );
    vlc_fifo_CleanupPush( p_owner->p_fifo );

    for( ;; )
    {
        if( p_owner->flushing )
        {   /* Flush before/regardless of pause. We do not want to resume just
             * for the sake of flushing (glitches could otherwise happen). */
            int canc = vlc_savecancel();

            vlc_fifo_Unlock( p_owner->p_fifo );

            /* Flush the decoder (and the output) */
            DecoderProcessFlush( p_dec );

            vlc_fifo_Lock( p_owner->p_fifo );
            vlc_restorecancel( canc );

            /* Reset flushing after DecoderProcess in case input_DecoderFlush
             * is called again. This will avoid a second useless flush (but
             * harmless). */
            p_owner->flushing = false;

        ...",1,1,input\decoder.c,DecoderThread,,false,1539,1645,DecoderThread,,,43,void* DecoderThread (void*)
31867,METHOD,input\decoder.c:<global>,TYPE_DECL,"static decoder_t * CreateDecoder( vlc_object_t *p_parent,
                                  input_thread_t *p_input,
                                  const es_format_t *fmt,
                                  input_resource_t *p_resource,
                                  sout_instance_t *p_sout )
{
    decoder_t *p_dec;
    decoder_owner_sys_t *p_owner;

    p_dec = vlc_custom_create( p_parent, sizeof( *p_dec ), ""decoder"" );
    if( p_dec == NULL )
        return NULL;

    /* Allocate our private structure for the decoder */
    p_dec->p_owner = p_owner = malloc( sizeof( decoder_owner_sys_t ) );
    if( unlikely(p_owner == NULL) )
    {
        vlc_object_release( p_dec );
        return NULL;
    }
    p_owner->i_preroll_end = INT64_MIN;
    p_owner->i_last_rate = INPUT_RATE_DEFAULT;
    p_owner->p_input = p_input;
    p_owner->p_resource = p_resource;
    p_owner->p_aout = NULL;
    p_owner->p_vout = NULL;
    p_owner->p_spu_vout = NULL;
    p_owner->i_spu_channel = 0;
    p_own...",1,29,input\decoder.c,CreateDecoder,,false,1655,1805,CreateDecoder,,,44,"decoder_t CreateDecoder (vlc_object_t*,input_thread_t*,es_format_t*,input_resource_t*,sout_instance_t*)"
32427,METHOD,input\decoder.c:<global>,TYPE_DECL,"static void DeleteDecoder( decoder_t * p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    msg_Dbg( p_dec, ""killing decoder fourcc `%4.4s'"",
             (char*)&p_dec->fmt_in.i_codec );

    const bool b_flush_spu = p_dec->fmt_out.i_cat == SPU_ES;
    UnloadDecoder( p_dec );

    /* Free all packets still in the decoder fifo. */
    block_FifoRelease( p_owner->p_fifo );

    /* Cleanup */
    if( p_owner->p_aout )
    {
        /* TODO: REVISIT gap-less audio */
        aout_DecFlush( p_owner->p_aout, false );
        aout_DecDelete( p_owner->p_aout );
        input_resource_PutAout( p_owner->p_resource, p_owner->p_aout );
        if( p_owner->p_input != NULL )
            input_SendEventAout( p_owner->p_input );
    }
    if( p_owner->p_vout )
    {
        /* Reset the cancel state that was set before joining the decoder
         * thread */
        vout_Cancel( p_owner->p_vout, false );

        input_resource_RequestVout( p_owner->p_resource, p_owner->p_vout, NULL...",1,1,input\decoder.c,DeleteDecoder,,false,1813,1885,DeleteDecoder,,,45,void DeleteDecoder (decoder_t*)
32611,METHOD,input\decoder.c:<global>,TYPE_DECL,"static void DecoderUnsupportedCodec( decoder_t *p_dec, const es_format_t *fmt, bool b_decoding )
{
    if (fmt->i_codec != VLC_CODEC_UNKNOWN && fmt->i_codec) {
        const char *desc = vlc_fourcc_GetDescription(fmt->i_cat, fmt->i_codec);
        if (!desc || !*desc)
            desc = N_(""No description for this codec"");
        msg_Err( p_dec, ""Codec `%4.4s' (%s) is not supported."", (char*)&fmt->i_codec, desc );
        vlc_dialog_display_error( p_dec, _(""Codec not supported""),
            _(""VLC could not decode the format \""%4.4s\"" (%s)""),
            (char*)&fmt->i_codec, desc );
    } else if( b_decoding ){
        msg_Err( p_dec, ""could not identify codec"" );
        vlc_dialog_display_error( p_dec, _(""Unidentified codec""),
            _(""VLC could not identify the audio or video codec"" ) );
    }
}",1,1,input\decoder.c,DecoderUnsupportedCodec,,false,1888,1903,DecoderUnsupportedCodec,,,46,"void DecoderUnsupportedCodec (decoder_t*,es_format_t*,bool)"
32688,METHOD,input\decoder.c:<global>,TYPE_DECL,"static decoder_t *decoder_New( vlc_object_t *p_parent, input_thread_t *p_input,
                               const es_format_t *fmt, input_clock_t *p_clock,
                               input_resource_t *p_resource,
                               sout_instance_t *p_sout  )
{
    decoder_t *p_dec = NULL;
    const char *psz_type = p_sout ? N_(""packetizer"") : N_(""decoder"");
    int i_priority;

    /* Create the decoder configuration structure */
    p_dec = CreateDecoder( p_parent, p_input, fmt, p_resource, p_sout );
    if( p_dec == NULL )
    {
        msg_Err( p_parent, ""could not create %s"", psz_type );
        vlc_dialog_display_error( p_parent, _(""Streaming / Transcoding failed""),
            _(""VLC could not open the %s module.""), vlc_gettext( psz_type ) );
        return NULL;
    }

    if( !p_dec->p_module )
    {
        DecoderUnsupportedCodec( p_dec, fmt, !p_sout );

        DeleteDecoder( p_dec );
        return NULL;
    }

    p_dec->p_owner->p_clock = p_clock;
  ...",1,1,input\decoder.c,decoder_New,,false,1906,1950,decoder_New,,,47,"decoder_t decoder_New (vlc_object_t*,input_thread_t*,es_format_t*,input_clock_t*,input_resource_t*,sout_instance_t*)"
32807,METHOD,input\decoder.c:<global>,TYPE_DECL,"decoder_t *input_DecoderNew( input_thread_t *p_input,
                             es_format_t *fmt, input_clock_t *p_clock,
                             sout_instance_t *p_sout  )
{
    return decoder_New( VLC_OBJECT(p_input), p_input, fmt, p_clock,
                        input_priv(p_input)->p_resource, p_sout );
}",1,1,input\decoder.c,input_DecoderNew,,false,1960,1966,input_DecoderNew,,,48,"decoder_t input_DecoderNew (input_thread_t*,es_format_t*,input_clock_t*,sout_instance_t*)"
32827,METHOD,input\decoder.c:<global>,TYPE_DECL,"decoder_t *input_DecoderCreate( vlc_object_t *p_parent, const es_format_t *fmt,
                                input_resource_t *p_resource )
{
    return decoder_New( p_parent, NULL, fmt, NULL, p_resource, NULL );
}",1,1,input\decoder.c,input_DecoderCreate,,false,1971,1975,input_DecoderCreate,,,49,"decoder_t input_DecoderCreate (vlc_object_t*,es_format_t*,input_resource_t*)"
32842,METHOD,input\decoder.c:<global>,TYPE_DECL,"void input_DecoderDelete( decoder_t *p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    vlc_cancel( p_owner->thread );

    vlc_fifo_Lock( p_owner->p_fifo );
    /* Signal DecoderTimedWait */
    p_owner->flushing = true;
    vlc_cond_signal( &p_owner->wait_timed );
    vlc_fifo_Unlock( p_owner->p_fifo );

    /* Make sure we aren't waiting/decoding anymore */
    vlc_mutex_lock( &p_owner->lock );
    p_owner->b_waiting = false;
    vlc_cond_signal( &p_owner->wait_request );

    /* If the video output is paused or slow, or if the picture pool size was
     * under-estimated (e.g. greedy video filter, buggy decoder...), the
     * the picture pool may be empty, and the decoder thread or any decoder
     * module worker threads may be stuck waiting for free picture buffers.
     *
     * This unblocks the thread, allowing the decoder module to join all its
     * worker threads (if any) and the decoder thread to terminate. */
    if( p_owner->p_vout != NULL )
        v...",1,28,input\decoder.c,input_DecoderDelete,,false,1985,2024,input_DecoderDelete,,,50,void input_DecoderDelete (decoder_t*)
32941,METHOD,input\decoder.c:<global>,TYPE_DECL,"void input_DecoderDecode( decoder_t *p_dec, block_t *p_block, bool b_do_pace )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    vlc_fifo_Lock( p_owner->p_fifo );
    if( !b_do_pace )
    {
        /* FIXME: ideally we would check the time amount of data
         * in the FIFO instead of its size. */
        /* 400 MiB, i.e. ~ 50mb/s for 60s */
        if( vlc_fifo_GetBytes( p_owner->p_fifo ) > 400*1024*1024 )
        {
            msg_Warn( p_dec, ""decoder/packetizer fifo full (data not ""
                      ""consumed quickly enough), resetting fifo!"" );
            block_ChainRelease( vlc_fifo_DequeueAllUnlocked( p_owner->p_fifo ) );
            p_block->i_flags |= BLOCK_FLAG_DISCONTINUITY;
        }
    }
    else
    if( !p_owner->b_waiting )
    {   /* The FIFO is not consumed when waiting, so pacing would deadlock VLC.
         * Locking is not necessary as b_waiting is only read, not written by
         * the decoder thread. */
        while( vlc_fifo_GetCount( p_ow...",1,1,input\decoder.c,input_DecoderDecode,,false,2033,2062,input_DecoderDecode,,,51,"void input_DecoderDecode (decoder_t*,block_t*,bool)"
33019,METHOD,input\decoder.c:<global>,TYPE_DECL,"bool input_DecoderIsEmpty( decoder_t * p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    assert( !p_owner->b_waiting );

    vlc_fifo_Lock( p_owner->p_fifo );
    if( !vlc_fifo_IsEmpty( p_dec->p_owner->p_fifo ) || p_owner->b_draining )
    {
        vlc_fifo_Unlock( p_owner->p_fifo );
        return false;
    }
    vlc_fifo_Unlock( p_owner->p_fifo );

    bool b_empty;

    vlc_mutex_lock( &p_owner->lock );
#ifdef ENABLE_SOUT
    if( p_owner->p_sout_input != NULL )
        b_empty = sout_InputIsEmpty( p_owner->p_sout_input );
    else
#endif
    if( p_owner->fmt.i_cat == VIDEO_ES && p_owner->p_vout != NULL )
        b_empty = vout_IsEmpty( p_owner->p_vout );
    else if( p_owner->fmt.i_cat == AUDIO_ES )
        b_empty = !p_owner->b_draining || p_owner->drained;
    else
        b_empty = true; /* TODO subtitles support */
    vlc_mutex_unlock( &p_owner->lock );

    return b_empty;
}",1,1,input\decoder.c,input_DecoderIsEmpty,,false,2064,2095,input_DecoderIsEmpty,,,52,bool input_DecoderIsEmpty (decoder_t*)
33122,METHOD,input\decoder.c:<global>,TYPE_DECL,"void input_DecoderDrain( decoder_t *p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    vlc_fifo_Lock( p_owner->p_fifo );
    p_owner->b_draining = true;
    vlc_fifo_Signal( p_owner->p_fifo );
    vlc_fifo_Unlock( p_owner->p_fifo );
}",1,1,input\decoder.c,input_DecoderDrain,,false,2105,2113,input_DecoderDrain,,,53,void input_DecoderDrain (decoder_t*)
33150,METHOD,input\decoder.c:<global>,TYPE_DECL,"void input_DecoderFlush( decoder_t *p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    vlc_fifo_Lock( p_owner->p_fifo );

    /* Empty the fifo */
    block_ChainRelease( vlc_fifo_DequeueAllUnlocked( p_owner->p_fifo ) );

    /* Don't need to wait for the DecoderThread to flush. Indeed, if called a
     * second time, this function will clear the FIFO again before anything was
     * dequeued by DecoderThread and there is no need to flush a second time in
     * a row. */
    p_owner->flushing = true;

    /* Flush video/spu decoder when paused: increment frames_countdown in order
     * to display one frame/subtitle */
    if( p_owner->paused
     && ( p_owner->fmt.i_cat == VIDEO_ES || p_owner->fmt.i_cat == SPU_ES )
     && p_owner->frames_countdown == 0 )
        p_owner->frames_countdown++;

    vlc_fifo_Signal( p_owner->p_fifo );
    vlc_cond_signal( &p_owner->wait_timed );

    vlc_fifo_Unlock( p_owner->p_fifo );
}",1,1,input\decoder.c,input_DecoderFlush,,false,2119,2145,input_DecoderFlush,,,54,void input_DecoderFlush (decoder_t*)
33219,METHOD,input\decoder.c:<global>,TYPE_DECL,"void input_DecoderGetCcDesc( decoder_t *p_dec, decoder_cc_desc_t *p_desc )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    vlc_mutex_lock( &p_owner->lock );
    *p_desc = p_owner->cc.desc;
    vlc_mutex_unlock( &p_owner->lock );
}",1,1,input\decoder.c,input_DecoderGetCcDesc,,false,2147,2154,input_DecoderGetCcDesc,,,55,"void input_DecoderGetCcDesc (decoder_t*,decoder_cc_desc_t*)"
33249,METHOD,input\decoder.c:<global>,TYPE_DECL,"static bool input_DecoderHasCCChanFlag( decoder_t *p_dec,
                                        vlc_fourcc_t codec, int i_channel )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    int i_max_channels;
    uint64_t i_bitmap;
    if( codec == VLC_CODEC_CEA608 )
    {
        i_max_channels = 4;
        i_bitmap = p_owner->cc.desc.i_608_channels;
    }
    else if( codec == VLC_CODEC_CEA708 )
    {
        i_max_channels = 64;
        i_bitmap = p_owner->cc.desc.i_708_channels;
    }
    else return false;

    return ( i_channel >= 0 && i_channel < i_max_channels &&
             ( i_bitmap & ((uint64_t)1 << i_channel) ) );
}",1,1,input\decoder.c,input_DecoderHasCCChanFlag,,false,2156,2177,input_DecoderHasCCChanFlag,,,56,"bool input_DecoderHasCCChanFlag (decoder_t*,vlc_fourcc_t,int)"
33320,METHOD,input\decoder.c:<global>,TYPE_DECL,"int input_DecoderSetCcState( decoder_t *p_dec, vlc_fourcc_t codec,
                             int i_channel, bool b_decode )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    //msg_Warn( p_dec, ""input_DecoderSetCcState: %d @%x"", b_decode, i_channel );

    if( !input_DecoderHasCCChanFlag( p_dec, codec, i_channel ) )
        return VLC_EGENERIC;

    if( b_decode )
    {
        decoder_t *p_cc;
        es_format_t fmt;

        es_format_Init( &fmt, SPU_ES, codec );
        fmt.subs.cc.i_channel = i_channel;
        fmt.subs.cc.i_reorder_depth = p_owner->cc.desc.i_reorder_depth;
        p_cc = input_DecoderNew( p_owner->p_input, &fmt,
                              p_dec->p_owner->p_clock, p_owner->p_sout );
        if( !p_cc )
        {
            msg_Err( p_dec, ""could not create decoder"" );
            vlc_dialog_display_error( p_dec,
                _(""Streaming / Transcoding failed""), ""%s"",
                _(""VLC could not open the decoder module."") );
            ret...",1,1,input\decoder.c,input_DecoderSetCcState,,false,2179,2232,input_DecoderSetCcState,,,57,"int input_DecoderSetCcState (decoder_t*,vlc_fourcc_t,int,bool)"
33492,METHOD,input\decoder.c:<global>,TYPE_DECL,"int input_DecoderGetCcState( decoder_t *p_dec, vlc_fourcc_t codec,
                             int i_channel, bool *pb_decode )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    if( !input_DecoderHasCCChanFlag( p_dec, codec, i_channel ) )
        return VLC_EGENERIC;

    vlc_mutex_lock( &p_owner->lock );
    *pb_decode = p_owner->cc.pp_decoder[i_channel] != NULL;
    vlc_mutex_unlock( &p_owner->lock );
    return VLC_SUCCESS;
}",1,1,input\decoder.c,input_DecoderGetCcState,,false,2234,2246,input_DecoderGetCcState,,,58,"int input_DecoderGetCcState (decoder_t*,vlc_fourcc_t,int,bool*)"
33539,METHOD,input\decoder.c:<global>,TYPE_DECL,"void input_DecoderChangePause( decoder_t *p_dec, bool b_paused, mtime_t i_date )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    /* Normally, p_owner->b_paused != b_paused here. But if a track is added
     * while the input is paused (e.g. add sub file), then b_paused is
     * (incorrectly) false. FIXME: This is a bug in the decoder owner. */
    vlc_fifo_Lock( p_owner->p_fifo );
    p_owner->paused = b_paused;
    p_owner->pause_date = i_date;
    p_owner->frames_countdown = 0;
    vlc_fifo_Signal( p_owner->p_fifo );
    vlc_fifo_Unlock( p_owner->p_fifo );
}",1,1,input\decoder.c,input_DecoderChangePause,,false,2248,2261,input_DecoderChangePause,,,59,"void input_DecoderChangePause (decoder_t*,bool,mtime_t)"
33579,METHOD,input\decoder.c:<global>,TYPE_DECL,"void input_DecoderChangeDelay( decoder_t *p_dec, mtime_t i_delay )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    vlc_mutex_lock( &p_owner->lock );
    p_owner->i_ts_delay = i_delay;
    vlc_mutex_unlock( &p_owner->lock );
}",1,1,input\decoder.c,input_DecoderChangeDelay,,false,2263,2270,input_DecoderChangeDelay,,,60,"void input_DecoderChangeDelay (decoder_t*,mtime_t)"
33606,METHOD,input\decoder.c:<global>,TYPE_DECL,"void input_DecoderStartWait( decoder_t *p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    assert( !p_owner->b_waiting );

    vlc_mutex_lock( &p_owner->lock );
    p_owner->b_first = true;
    p_owner->b_has_data = false;
    p_owner->b_waiting = true;
    vlc_cond_signal( &p_owner->wait_request );
    vlc_mutex_unlock( &p_owner->lock );
}",1,1,input\decoder.c,input_DecoderStartWait,,false,2272,2284,input_DecoderStartWait,,,61,void input_DecoderStartWait (decoder_t*)
33652,METHOD,input\decoder.c:<global>,TYPE_DECL,"void input_DecoderStopWait( decoder_t *p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    assert( p_owner->b_waiting );

    vlc_mutex_lock( &p_owner->lock );
    p_owner->b_waiting = false;
    vlc_cond_signal( &p_owner->wait_request );
    vlc_mutex_unlock( &p_owner->lock );
}",1,1,input\decoder.c,input_DecoderStopWait,,false,2286,2296,input_DecoderStopWait,,,62,void input_DecoderStopWait (decoder_t*)
33687,METHOD,input\decoder.c:<global>,TYPE_DECL,"void input_DecoderWait( decoder_t *p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    assert( p_owner->b_waiting );

    vlc_mutex_lock( &p_owner->lock );
    while( !p_owner->b_has_data )
    {
        /* Don't need to lock p_owner->paused since it's only modified by the
         * owner */
        if( p_owner->paused )
            break;
        vlc_fifo_Lock( p_owner->p_fifo );
        if( p_owner->b_idle && vlc_fifo_IsEmpty( p_owner->p_fifo ) )
        {
            msg_Err( p_dec, ""buffer deadlock prevented"" );
            vlc_fifo_Unlock( p_owner->p_fifo );
            break;
        }
        vlc_fifo_Unlock( p_owner->p_fifo );
        vlc_cond_wait( &p_owner->wait_acknowledge, &p_owner->lock );
    }
    vlc_mutex_unlock( &p_owner->lock );
}",1,1,input\decoder.c,input_DecoderWait,,false,2298,2322,input_DecoderWait,,,63,void input_DecoderWait (decoder_t*)
33759,METHOD,input\decoder.c:<global>,TYPE_DECL,"void input_DecoderFrameNext( decoder_t *p_dec, mtime_t *pi_duration )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    assert( p_owner->paused );
    *pi_duration = 0;

    vlc_fifo_Lock( p_owner->p_fifo );
    p_owner->frames_countdown++;
    vlc_fifo_Signal( p_owner->p_fifo );
    vlc_fifo_Unlock( p_owner->p_fifo );

    vlc_mutex_lock( &p_owner->lock );
    if( p_owner->fmt.i_cat == VIDEO_ES )
    {
        if( p_owner->p_vout )
            vout_NextPicture( p_owner->p_vout, pi_duration );
    }
    vlc_mutex_unlock( &p_owner->lock );
}",1,1,input\decoder.c,input_DecoderFrameNext,,false,2324,2343,input_DecoderFrameNext,,,64,"void input_DecoderFrameNext (decoder_t*,mtime_t*)"
33824,METHOD,input\decoder.c:<global>,TYPE_DECL,"bool input_DecoderHasFormatChanged( decoder_t *p_dec, es_format_t *p_fmt, vlc_meta_t **pp_meta )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    bool b_changed;

    vlc_mutex_lock( &p_owner->lock );
    b_changed = p_owner->b_fmt_description;
    if( b_changed )
    {
        if( p_fmt != NULL )
            es_format_Copy( p_fmt, &p_owner->fmt );

        if( pp_meta )
        {
            *pp_meta = NULL;
            if( p_owner->p_description )
            {
                *pp_meta = vlc_meta_New();
                if( *pp_meta )
                    vlc_meta_Merge( *pp_meta, p_owner->p_description );
            }
        }
        p_owner->b_fmt_description = false;
    }
    vlc_mutex_unlock( &p_owner->lock );
    return b_changed;
}",1,1,input\decoder.c,input_DecoderHasFormatChanged,,false,2345,2371,input_DecoderHasFormatChanged,,,65,"bool input_DecoderHasFormatChanged (decoder_t*,es_format_t*,vlc_meta_t**)"
33900,METHOD,input\decoder.c:<global>,TYPE_DECL,"size_t input_DecoderGetFifoSize( decoder_t *p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    return block_FifoSize( p_owner->p_fifo );
}",1,1,input\decoder.c,input_DecoderGetFifoSize,,false,2373,2378,input_DecoderGetFifoSize,,,66,size_t input_DecoderGetFifoSize (decoder_t*)
33916,METHOD,input\decoder.c:<global>,TYPE_DECL,"void input_DecoderGetObjects( decoder_t *p_dec,
                              vout_thread_t **pp_vout, audio_output_t **pp_aout )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    vlc_mutex_lock( &p_owner->lock );
    if( pp_vout )
        *pp_vout = p_owner->p_vout ? vlc_object_hold( p_owner->p_vout ) : NULL;
    if( pp_aout )
        *pp_aout = p_owner->p_aout ? vlc_object_hold( p_owner->p_aout ) : NULL;
    vlc_mutex_unlock( &p_owner->lock );
}",1,1,input\decoder.c,input_DecoderGetObjects,,false,2380,2391,input_DecoderGetObjects,,,67,"void input_DecoderGetObjects (decoder_t*,vout_thread_t**,audio_output_t**)"
33976,METHOD,input\decoder.h:<global>,TYPE_DECL,<global>,1,6,input\decoder.h,input\decoder.h:<global>,,false,1,110,<global>,,,1,
33978,METHOD,input\decoder.h:<global>,TYPE_DECL,"decoder_t *input_DecoderNew( input_thread_t *, es_format_t *, input_clock_t *,
                             sout_instance_t * )",11,48,input\decoder.h,input_DecoderNew,,false,31,32,input_DecoderNew,,,1,"decoder_t* input_DecoderNew (input_thread_t*,es_format_t*,input_clock_t*,sout_instance_t*)"
33988,METHOD,input\decoder.h:<global>,TYPE_DECL,"void input_DecoderChangePause( decoder_t *, bool b_paused, mtime_t i_date );",6,75,input\decoder.h,input_DecoderChangePause,,false,39,39,input_DecoderChangePause,,,4,"void input_DecoderChangePause (decoder_t*,bool,mtime_t)"
33995,METHOD,input\decoder.h:<global>,TYPE_DECL,"void input_DecoderChangeDelay( decoder_t *, mtime_t i_delay );",6,61,input\decoder.h,input_DecoderChangeDelay,,false,44,44,input_DecoderChangeDelay,,,5,"void input_DecoderChangeDelay (decoder_t*,mtime_t)"
34001,METHOD,input\decoder.h:<global>,TYPE_DECL,void input_DecoderStartWait( decoder_t * );,6,42,input\decoder.h,input_DecoderStartWait,,false,49,49,input_DecoderStartWait,,,6,void input_DecoderStartWait (decoder_t*)
34006,METHOD,input\decoder.h:<global>,TYPE_DECL,void input_DecoderWait( decoder_t * );,6,37,input\decoder.h,input_DecoderWait,,false,54,54,input_DecoderWait,,,7,void input_DecoderWait (decoder_t*)
34011,METHOD,input\decoder.h:<global>,TYPE_DECL,void input_DecoderStopWait( decoder_t * );,6,41,input\decoder.h,input_DecoderStopWait,,false,59,59,input_DecoderStopWait,,,8,void input_DecoderStopWait (decoder_t*)
34016,METHOD,input\decoder.h:<global>,TYPE_DECL,bool input_DecoderIsEmpty( decoder_t * );,6,40,input\decoder.h,input_DecoderIsEmpty,,false,64,64,input_DecoderIsEmpty,,,9,bool input_DecoderIsEmpty (decoder_t*)
34021,METHOD,input\decoder.h:<global>,TYPE_DECL,"int input_DecoderSetCcState( decoder_t *, vlc_fourcc_t, int i_channel, bool b_decode );",5,86,input\decoder.h,input_DecoderSetCcState,,false,69,69,input_DecoderSetCcState,,,10,"int input_DecoderSetCcState (decoder_t*,ANY,int,bool)"
34029,METHOD,input\decoder.h:<global>,TYPE_DECL,"int input_DecoderGetCcState( decoder_t *, vlc_fourcc_t, int i_channel, bool *pb_decode );",5,88,input\decoder.h,input_DecoderGetCcState,,false,75,75,input_DecoderGetCcState,,,11,"int input_DecoderGetCcState (decoder_t*,ANY,int,bool*)"
34037,METHOD,input\decoder.h:<global>,TYPE_DECL,"void input_DecoderGetCcDesc( decoder_t *, decoder_cc_desc_t * );",6,63,input\decoder.h,input_DecoderGetCcDesc,,false,80,80,input_DecoderGetCcDesc,,,12,"void input_DecoderGetCcDesc (decoder_t*,decoder_cc_desc_t*)"
34043,METHOD,input\decoder.h:<global>,TYPE_DECL,"void input_DecoderFrameNext( decoder_t *p_dec, mtime_t *pi_duration );",6,69,input\decoder.h,input_DecoderFrameNext,,false,86,86,input_DecoderFrameNext,,,13,"void input_DecoderFrameNext (decoder_t*,mtime_t*)"
34049,METHOD,input\decoder.h:<global>,TYPE_DECL,"bool input_DecoderHasFormatChanged( decoder_t *p_dec, es_format_t *p_fmt, vlc_meta_t **pp_meta );",6,96,input\decoder.h,input_DecoderHasFormatChanged,,false,96,96,input_DecoderHasFormatChanged,,,14,"bool input_DecoderHasFormatChanged (decoder_t*,es_format_t*,vlc_meta_t**)"
34056,METHOD,input\decoder.h:<global>,TYPE_DECL,size_t input_DecoderGetFifoSize( decoder_t *p_dec );,8,51,input\decoder.h,input_DecoderGetFifoSize,,false,101,101,input_DecoderGetFifoSize,,,15,size_t input_DecoderGetFifoSize (decoder_t*)
34061,METHOD,input\decoder.h:<global>,TYPE_DECL,"void input_DecoderGetObjects( decoder_t *, vout_thread_t **, audio_output_t ** );",6,80,input\decoder.h,input_DecoderGetObjects,,false,108,108,input_DecoderGetObjects,,,16,"void input_DecoderGetObjects (decoder_t*,vout_thread_t**,audio_output_t**)"
34091,METHOD,input\demux.c:<global>,TYPE_DECL,<global>,1,1,input\demux.c,input\demux.c:<global>,,false,1,658,<global>,,,1,
34096,METHOD,<empty>,<empty>,<empty>,1,,input\demux.c,demux_mapping:<clinit>,,false,39,,<clinit>,,,3,
34105,METHOD,input\demux.c:<global>,TYPE_DECL,"static int demux_mapping_cmp( const void *k, const void *v )
{
    demux_mapping* entry = v;
    return vlc_ascii_strcasecmp( k, entry->key );
}",1,1,input\demux.c,demux_mapping_cmp,,false,46,50,demux_mapping_cmp,,,3,"int demux_mapping_cmp (void*,void*)"
34121,METHOD,input\demux.c:<global>,TYPE_DECL,"static demux_mapping* demux_lookup( char const* key,
                                    demux_mapping* data, size_t size )
{
    return bsearch( key, data, size, sizeof( *data ), demux_mapping_cmp );
}",1,1,input\demux.c,demux_lookup,,false,52,56,demux_lookup,,,4,"demux_mapping demux_lookup (char*,demux_mapping*,size_t)"
34137,METHOD,input\demux.c:<global>,TYPE_DECL,"static const char *demux_NameFromMimeType(const char *mime)
{
    static demux_mapping types[] =
    {   /* Must be sorted in ascending ASCII order */
        { ""audio/aac"",           ""m4a""     },
        { ""audio/aacp"",          ""m4a""     },
        { ""audio/mpeg"",          ""mp3""     },
        //{ ""video/MP1S"",          ""es,mpgv"" }, !b_force
        { ""video/dv"",            ""rawdv""   },
        { ""video/MP2P"",          ""ps""      },
        { ""video/MP2T"",          ""ts""      },
        { ""video/nsa"",           ""nsv""     },
        { ""video/nsv"",           ""nsv""     },
    };
    demux_mapping *type = demux_lookup( mime, types, ARRAY_SIZE( types ) );
    return (type != NULL) ? type->name : ""any"";
}",1,1,input\demux.c,demux_NameFromMimeType,,false,58,74,demux_NameFromMimeType,,,5,const char* demux_NameFromMimeType (char*)
34187,METHOD,input\demux.c:<global>,TYPE_DECL,"static const char* DemuxNameFromExtension( char const* ext,
                                           bool b_preparsing )
{
    /* NOTE: Add only file without any problems here and with strong detection:
     * - no .mp3, .a52, ...
     *  - wav can't be added 'cause of a52 and dts in them as raw audio
     */
    static demux_mapping strong[] =
    { /* NOTE: must be sorted in asc order */
        { ""aiff"", ""aiff"" },
        { ""asf"",  ""asf"" },
        { ""au"",   ""au"" },
        { ""avi"",  ""avi"" },
        { ""drc"",  ""dirac"" },
        { ""dv"",   ""dv"" },
        { ""flac"", ""flac"" },
        { ""h264"", ""h264"" },
        { ""kar"", ""smf"" },
        { ""m3u"",  ""m3u"" },
        { ""m4a"",  ""mp4"" },
        { ""m4v"",  ""m4v"" },
        { ""mid"",  ""smf"" },
        { ""mka"",  ""mkv"" },
        { ""mks"",  ""mkv"" },
        { ""mkv"",  ""mkv"" },
        { ""moov"", ""mp4"" },
        { ""mov"",  ""mp4"" },
        { ""mp4"",  ""mp4"" },
        { ""nsv"",  ""nsv"" },
        { ""oga"",  ""ogg"" },
        { ""ogg"",  ""ogg"" },
      ...",1,1,input\demux.c,DemuxNameFromExtension,,false,76,139,DemuxNameFromExtension,,,6,"const char* DemuxNameFromExtension (char*,bool)"
34347,METHOD,input\demux.c:<global>,TYPE_DECL,"demux_t *demux_New( vlc_object_t *p_obj, const char *psz_name,
                    const char *psz_location, stream_t *s, es_out_t *out )
{
    return demux_NewAdvanced( p_obj, NULL,
                              (s == NULL) ? psz_name : """",
                              (s != NULL) ? psz_name : """",
                              psz_location, s, out, false );
}",1,11,input\demux.c,demux_New,,false,145,152,demux_New,,,7,"demux_t demux_New (vlc_object_t*,char*,char*,stream_t*,es_out_t*)"
34387,METHOD,demux_priv_t,TYPE_DECL,void (*destroy)(demux_t *);,10,30,input\demux.c,demux_priv_t.destroy,,false,157,157,destroy,,,2,void demux_priv_t.destroy (demux_t*)
34393,METHOD,input\demux.c:<global>,TYPE_DECL,"static void demux_DestroyDemux(demux_t *demux)
{
    assert(demux->s != NULL);
    vlc_stream_Delete(demux->s);
}",1,1,input\demux.c,demux_DestroyDemux,,false,160,164,demux_DestroyDemux,,,10,void demux_DestroyDemux (demux_t*)
34408,METHOD,input\demux.c:<global>,TYPE_DECL,"static void demux_DestroyAccessDemux(demux_t *demux)
{
    assert(demux->s == NULL);
    (void) demux;
}",1,1,input\demux.c,demux_DestroyAccessDemux,,false,166,170,demux_DestroyAccessDemux,,,11,void demux_DestroyAccessDemux (demux_t*)
34422,METHOD,input\demux.c:<global>,TYPE_DECL,"static void demux_DestroyDemuxFilter(demux_t *demux)
{
    assert(demux->p_next != NULL);
    demux_Delete(demux->p_next);
}",1,1,input\demux.c,demux_DestroyDemuxFilter,,false,172,176,demux_DestroyDemuxFilter,,,12,void demux_DestroyDemuxFilter (demux_t*)
34437,METHOD,input\demux.c:<global>,TYPE_DECL,"static int demux_Probe(void *func, va_list ap)
{
    int (*probe)(vlc_object_t *) = func;
    demux_t *demux = va_arg(ap, demux_t *);

    /* Restore input stream offset (in case previous probed demux failed to
     * to do so). */
    if (vlc_stream_Tell(demux->s) != 0 && vlc_stream_Seek(demux->s, 0))
    {
        msg_Err(demux, ""seek failure before probing"");
        return VLC_EGENERIC;
    }

    return probe(VLC_OBJECT(demux));
}",1,1,input\demux.c,demux_Probe,,false,178,192,demux_Probe,,,13,"int demux_Probe (void*,va_list)"
34441,METHOD,input\demux.c:<global>,TYPE_DECL,int (*probe)(vlc_object_t *) = func;,9,39,input\demux.c,demux_Probe.probe,,false,180,180,probe,,,1,int demux_Probe.probe (vlc_object_t*)
34472,METHOD,input\demux.c:<global>,TYPE_DECL,"demux_t *demux_NewAdvanced( vlc_object_t *p_obj, input_thread_t *p_parent_input,
                            const char *psz_access, const char *psz_demux,
                            const char *psz_location,
                            stream_t *s, es_out_t *out, bool b_preparsing )
{
    demux_priv_t *priv = vlc_custom_create(p_obj, sizeof (*priv), ""demux"");
    if (unlikely(priv == NULL))
        return NULL;

    demux_t *p_demux = &priv->demux;

    if( s != NULL && (!strcasecmp( psz_demux, ""any"" ) || !psz_demux[0]) )
    {   /* Look up demux by mime-type for hard to detect formats */
        char *type = stream_MimeType( s );
        if( type != NULL )
        {
            psz_demux = demux_NameFromMimeType( type );
            free( type );
        }
    }

    p_demux->p_input = p_parent_input;
    p_demux->psz_access = strdup( psz_access );
    p_demux->psz_demux = strdup( psz_demux );
    p_demux->psz_location = strdup( psz_location );
    p_demux->psz_file = get_path( p...",1,1,input\demux.c,demux_NewAdvanced,,false,199,284,demux_NewAdvanced,,,14,"demux_t demux_NewAdvanced (vlc_object_t*,input_thread_t*,char*,char*,char*,stream_t*,es_out_t*,bool)"
34776,METHOD,input\demux.c:<global>,TYPE_DECL,"void demux_Delete( demux_t *p_demux )
{
    demux_priv_t *priv = (demux_priv_t *)p_demux;

    module_unneed( p_demux, p_demux->p_module );

    priv->destroy(p_demux);
    free( p_demux->psz_file );
    free( p_demux->psz_location );
    free( p_demux->psz_demux );
    free( p_demux->psz_access );
    vlc_object_release( p_demux );
}",1,1,input\demux.c,demux_Delete,,false,289,301,demux_Delete,,,15,void demux_Delete (demux_t*)
34815,METHOD,input\demux.c:<global>,TYPE_DECL,"static int demux_ControlInternal( demux_t *demux, int query, ... )
{
    int ret;
    va_list ap;

    va_start( ap, query );
    ret = demux->pf_control( demux, query, ap );
    va_end( ap );
    return ret;
}",1,1,input\demux.c,demux_ControlInternal,,false,306,315,demux_ControlInternal,,,16,"int demux_ControlInternal (demux_t*,int...)"
34839,METHOD,input\demux.c:<global>,TYPE_DECL,"int demux_vaControl( demux_t *demux, int query, va_list args )
{
    if( demux->s != NULL )
        switch( query )
        {
            /* Legacy fallback for missing getters in synchronous demuxers */
            case DEMUX_CAN_PAUSE:
            case DEMUX_CAN_CONTROL_PACE:
            case DEMUX_GET_PTS_DELAY:
            {
                int ret;
                va_list ap;

                va_copy( ap, args );
                ret = demux->pf_control( demux, query, args );
                if( ret != VLC_SUCCESS )
                    ret = vlc_stream_vaControl( demux->s, query, ap );
                va_end( ap );
                return ret;
            }

            /* Some demuxers need to control pause directly (e.g. adaptive),
             * but many legacy demuxers do not understand pause at all.
             * If DEMUX_CAN_PAUSE is not implemented, bypass the demuxer and
             * byte stream. If DEMUX_CAN_PAUSE is implemented and pause is
             * supported, ...",1,1,input\demux.c,demux_vaControl,,false,317,366,demux_vaControl,,,17,"int demux_vaControl (demux_t*,int,va_list)"
34923,METHOD,input\demux.c:<global>,TYPE_DECL,"int demux_vaControlHelper( stream_t *s,
                            int64_t i_start, int64_t i_end,
                            int64_t i_bitrate, int i_align,
                            int i_query, va_list args )
{
    int64_t i_tell;
    double  f, *pf;
    int64_t i64, *pi64;

    if( i_end < 0 )    i_end   = stream_Size( s );
    if( i_start < 0 )  i_start = 0;
    if( i_align <= 0 ) i_align = 1;
    i_tell = vlc_stream_Tell( s );

    static_control_match(CAN_PAUSE);
    static_control_match(CAN_CONTROL_PACE);
    static_control_match(GET_PTS_DELAY);
    static_control_match(GET_META);
    static_control_match(GET_SIGNAL);
    static_control_match(SET_PAUSE_STATE);

    switch( i_query )
    {
        case DEMUX_CAN_SEEK:
        {
            bool *b = va_arg( args, bool * );

            if( (i_bitrate <= 0 && i_start >= i_end)
             || vlc_stream_Control( s, STREAM_CAN_SEEK, b ) )
                *b = false;
            break;
        }

        case DEMUX_CAN_PAUSE...",1,4,input\demux.c,demux_vaControlHelper,,false,371,503,demux_vaControlHelper,,,18,"int demux_vaControlHelper (stream_t*,int64_t,int64_t,int64_t,int,int,va_list)"
35295,METHOD,input\demux.c:<global>,TYPE_DECL,"decoder_t *demux_PacketizerNew( demux_t *p_demux, es_format_t *p_fmt, const char *psz_msg )
{
    decoder_t *p_packetizer;
    p_packetizer = vlc_custom_create( p_demux, sizeof( *p_packetizer ),
                                      ""demux packetizer"" );
    if( !p_packetizer )
    {
        es_format_Clean( p_fmt );
        return NULL;
    }
    p_fmt->b_packetized = false;

    p_packetizer->pf_decode = NULL;
    p_packetizer->pf_packetize = NULL;

    p_packetizer->fmt_in = *p_fmt;
    es_format_Init( &p_packetizer->fmt_out, p_fmt->i_cat, 0 );

    p_packetizer->p_module = module_need( p_packetizer, ""packetizer"", NULL, false );
    if( !p_packetizer->p_module )
    {
        es_format_Clean( p_fmt );
        vlc_object_release( p_packetizer );
        msg_Err( p_demux, ""cannot find packetizer for %s"", psz_msg );
        return NULL;
    }

    return p_packetizer;
}",1,1,input\demux.c,demux_PacketizerNew,,false,508,536,demux_PacketizerNew,,,19,"decoder_t demux_PacketizerNew (demux_t*,es_format_t*,char*)"
35376,METHOD,input\demux.c:<global>,TYPE_DECL,"void demux_PacketizerDestroy( decoder_t *p_packetizer )
{
    if( p_packetizer->p_module )
        module_unneed( p_packetizer, p_packetizer->p_module );
    es_format_Clean( &p_packetizer->fmt_in );
    es_format_Clean( &p_packetizer->fmt_out );
    if( p_packetizer->p_description )
        vlc_meta_Delete( p_packetizer->p_description );
    vlc_object_release( p_packetizer );
}",1,1,input\demux.c,demux_PacketizerDestroy,,false,538,547,demux_PacketizerDestroy,,,20,void demux_PacketizerDestroy (decoder_t*)
35412,METHOD,input\demux.c:<global>,TYPE_DECL,"unsigned demux_TestAndClearFlags( demux_t *p_demux, unsigned flags )
{
    unsigned update = flags;

    if ( demux_Control( p_demux, DEMUX_TEST_AND_CLEAR_FLAGS, &update ) == VLC_SUCCESS )
        return update;

    update = p_demux->info.i_update & flags;
    p_demux->info.i_update &= ~flags;
    return update;
}",1,1,input\demux.c,demux_TestAndClearFlags,,false,549,559,demux_TestAndClearFlags,,,21,"unsigned demux_TestAndClearFlags (demux_t*,unsigned)"
35452,METHOD,input\demux.c:<global>,TYPE_DECL,"int demux_GetTitle( demux_t *p_demux )
{
    int i_title;
    if ( demux_Control( p_demux, DEMUX_GET_TITLE, &i_title ) == VLC_SUCCESS )
        return i_title;
    return p_demux->info.i_title;
}",1,1,input\demux.c,demux_GetTitle,,false,561,567,demux_GetTitle,,,22,int demux_GetTitle (demux_t*)
35475,METHOD,input\demux.c:<global>,TYPE_DECL,"int demux_GetSeekpoint( demux_t *p_demux )
{
    int i_seekpoint;
    if ( demux_Control( p_demux, DEMUX_GET_SEEKPOINT, &i_seekpoint ) == VLC_SUCCESS  )
        return i_seekpoint;
    return p_demux->info.i_seekpoint;
}",1,1,input\demux.c,demux_GetSeekpoint,,false,569,575,demux_GetSeekpoint,,,23,int demux_GetSeekpoint (demux_t*)
35498,METHOD,input\demux.c:<global>,TYPE_DECL,"static demux_t *demux_FilterNew( demux_t *p_next, const char *p_name )
{
    demux_priv_t *priv = vlc_custom_create(p_next, sizeof (*priv), ""demux_filter"");
    if (unlikely(priv == NULL))
        return NULL;

    demux_t *p_demux = &priv->demux;

    p_demux->p_next       = p_next;
    p_demux->p_input      = NULL;
    p_demux->p_sys        = NULL;
    p_demux->psz_access   = NULL;
    p_demux->psz_demux    = NULL;
    p_demux->psz_location = NULL;
    p_demux->psz_file     = NULL;
    p_demux->out          = NULL;
    priv->destroy         = demux_DestroyDemuxFilter;
    p_demux->p_module =
        module_need( p_demux, ""demux_filter"", p_name, p_name != NULL );

    if( p_demux->p_module == NULL )
        goto error;

    return p_demux;
error:
    vlc_object_release( p_demux );
    return NULL;
}",1,1,input\demux.c,demux_FilterNew,,false,577,604,demux_FilterNew,,,24,"demux_t demux_FilterNew (demux_t*,char*)"
35599,METHOD,input\demux.c:<global>,TYPE_DECL,"demux_t *demux_FilterChainNew( demux_t *p_demux, const char *psz_chain )
{
    if( !psz_chain || !*psz_chain )
        return NULL;

    char *psz_parser = strdup(psz_chain);
    if(!psz_parser)
        return NULL;

    /* parse chain */
    while(psz_parser)
    {
        config_chain_t *p_cfg;
        char *psz_name;
        char *psz_rest_chain = config_ChainCreate( &psz_name, &p_cfg, psz_parser );
        free( psz_parser );
        psz_parser = psz_rest_chain;

        demux_t *filter = demux_FilterNew(p_demux, psz_name);
        if (filter != NULL)
            p_demux = filter;

        free(psz_name);
        config_ChainDestroy(p_cfg);
    }

    return p_demux;
}",1,1,input\demux.c,demux_FilterChainNew,,false,606,633,demux_FilterChainNew,,,25,"demux_t demux_FilterChainNew (demux_t*,char*)"
35665,METHOD,input\demux.c:<global>,TYPE_DECL,"static bool demux_filter_enable_disable( demux_t *p_demux_chain,
                                          const char* psz_demux, bool b_enable )
{
    demux_t *p_demux = p_demux_chain;

     if( strcmp( module_get_name( p_demux->p_module, false ), psz_demux) == 0 ||
         strcmp( module_get_name( p_demux->p_module, true ), psz_demux ) == 0 )
     {
        demux_Control( p_demux,
                       b_enable ? DEMUX_FILTER_ENABLE : DEMUX_FILTER_DISABLE );
        return true;
    }
    return false;
}",1,1,input\demux.c,demux_filter_enable_disable,,false,635,648,demux_filter_enable_disable,,,26,"bool demux_filter_enable_disable (demux_t*,char*,bool)"
35707,METHOD,input\demux.c:<global>,TYPE_DECL,"bool demux_FilterEnable( demux_t *p_demux_chain, const char* psz_demux )
{
    return demux_filter_enable_disable( p_demux_chain, psz_demux, true );
}",1,1,input\demux.c,demux_FilterEnable,,false,650,653,demux_FilterEnable,,,27,"bool demux_FilterEnable (demux_t*,char*)"
35718,METHOD,input\demux.c:<global>,TYPE_DECL,"bool demux_FilterDisable( demux_t *p_demux_chain, const char* psz_demux )
{
    return demux_filter_enable_disable( p_demux_chain, psz_demux, false );
}",1,1,input\demux.c,demux_FilterDisable,,false,655,658,demux_FilterDisable,,,28,"bool demux_FilterDisable (demux_t*,char*)"
35738,METHOD,input\demux.h:<global>,TYPE_DECL,<global>,1,1,input\demux.h,input\demux.h:<global>,,false,1,62,<global>,,,1,
35740,METHOD,input\demux.h:<global>,TYPE_DECL,"demux_t *demux_NewAdvanced( vlc_object_t *p_obj, input_thread_t *p_parent_input,
                            const char *psz_access, const char *psz_demux,
                            const char *psz_path, stream_t *s, es_out_t *out, bool );",9,84,input\demux.h,demux_NewAdvanced,,false,34,36,demux_NewAdvanced,,,1,"demux_t* demux_NewAdvanced (vlc_object_t*,input_thread_t*,char*,char*,char*,stream_t*,es_out_t*,ANY)"
35752,METHOD,input\demux.h:<global>,TYPE_DECL,"unsigned demux_TestAndClearFlags( demux_t *, unsigned );",10,55,input\demux.h,demux_TestAndClearFlags,,false,39,39,demux_TestAndClearFlags,,,2,"unsigned demux_TestAndClearFlags (demux_t*,unsigned)"
35758,METHOD,input\demux.h:<global>,TYPE_DECL,int demux_GetTitle( demux_t * );,5,31,input\demux.h,demux_GetTitle,,false,40,40,demux_GetTitle,,,3,int demux_GetTitle (demux_t*)
35763,METHOD,input\demux.h:<global>,TYPE_DECL,int demux_GetSeekpoint( demux_t * );,5,35,input\demux.h,demux_GetSeekpoint,,false,41,41,demux_GetSeekpoint,,,4,int demux_GetSeekpoint (demux_t*)
35768,METHOD,input\demux.h:<global>,TYPE_DECL,"demux_t *demux_FilterChainNew( demux_t *source, const char *list )",9,66,input\demux.h,demux_FilterChainNew,,false,57,57,demux_FilterChainNew,,,5,"demux_t* demux_FilterChainNew (demux_t*,char*)"
35776,METHOD,input\demux.h:<global>,TYPE_DECL,"bool demux_FilterEnable( demux_t *p_demux_chain, const char* psz_demux );",6,72,input\demux.h,demux_FilterEnable,,false,59,59,demux_FilterEnable,,,8,"bool demux_FilterEnable (demux_t*,char*)"
35782,METHOD,input\demux.h:<global>,TYPE_DECL,"bool demux_FilterDisable( demux_t *p_demux_chain, const char* psz_demux );",6,73,input\demux.h,demux_FilterDisable,,false,60,60,demux_FilterDisable,,,9,"bool demux_FilterDisable (demux_t*,char*)"
35805,METHOD,input\demux_chained.c:<global>,TYPE_DECL,<global>,1,23,input\demux_chained.c,input\demux_chained.c:<global>,,false,1,168,<global>,,,1,
35818,METHOD,<empty>,<empty>,<empty>,1,,input\demux_chained.c,vlc_demux_chained_t:<clinit>,,false,35,,<clinit>,,,8,
35823,METHOD,input\demux_chained.c:<global>,TYPE_DECL,"static void *vlc_demux_chained_Thread(void *data)
{
    vlc_demux_chained_t *dc = data;
    demux_t *demux = demux_NewAdvanced(dc->fifo, NULL, """", dc->name, """",
                                       dc->fifo, dc->out, false);
    if (demux == NULL)
    {
        vlc_stream_Delete(dc->fifo);
        return NULL;
    }

    /* Stream FIFO cannot apply DVB filters.
     * Get all programs and let the E/S output sort them out. */
    demux_Control(demux, DEMUX_SET_GROUP, -1, NULL);

    /* Main loop */
    mtime_t next_update = 0;

    do
        if (demux_TestAndClearFlags(demux, UINT_MAX) || mdate() >= next_update)
        {
            double newpos;
            int64_t newlen, newtime;

            if (demux_Control(demux, DEMUX_GET_POSITION, &newpos))
                newpos = 0.;
            if (demux_Control(demux, DEMUX_GET_LENGTH, &newlen))
                newlen = 0;
            if (demux_Control(demux, DEMUX_GET_TIME, &newtime))
                newtime = 0;

            vlc_m...",1,21,input\demux_chained.c,vlc_demux_chained_Thread,,false,53,96,vlc_demux_chained_Thread,,,2,void* vlc_demux_chained_Thread (void*)
35981,METHOD,input\demux_chained.c:<global>,TYPE_DECL,"vlc_demux_chained_t *vlc_demux_chained_New(vlc_object_t *parent,
                                           const char *name, es_out_t *out)
{
    vlc_demux_chained_t *dc = malloc(sizeof (*dc) + strlen(name) + 1);
    if (unlikely(dc == NULL))
        return NULL;

    dc->fifo = vlc_stream_fifo_New(parent);
    if (dc->fifo == NULL)
    {
        free(dc);
        return NULL;
    }

    dc->stats.position = 0.;
    dc->stats.length = 0;
    dc->stats.time = 0;
    dc->out = out;
    strcpy(dc->name, name);

    vlc_mutex_init(&dc->lock);

    if (vlc_clone(&dc->thread, vlc_demux_chained_Thread, dc,
                  VLC_THREAD_PRIORITY_INPUT))
    {
        vlc_stream_Delete(dc->fifo);
        vlc_stream_fifo_Close(dc->fifo);
        vlc_mutex_destroy(&dc->lock);
        free(dc);
        dc = NULL;
    }
    return dc;
}",1,1,input\demux_chained.c,vlc_demux_chained_New,,false,98,130,vlc_demux_chained_New,,,3,"vlc_demux_chained_t vlc_demux_chained_New (vlc_object_t*,char*,es_out_t*)"
36091,METHOD,input\demux_chained.c:<global>,TYPE_DECL,"void vlc_demux_chained_Send(vlc_demux_chained_t *dc, block_t *block)
{
    vlc_stream_fifo_Queue(dc->fifo, block);
}",1,1,input\demux_chained.c,vlc_demux_chained_Send,,false,132,135,vlc_demux_chained_Send,,,4,"void vlc_demux_chained_Send (vlc_demux_chained_t*,block_t*)"
36102,METHOD,input\demux_chained.c:<global>,TYPE_DECL,"int vlc_demux_chained_ControlVa(vlc_demux_chained_t *dc, int query, va_list ap)
{
    switch (query)
    {
        case DEMUX_GET_POSITION:
            vlc_mutex_lock(&dc->lock);
            *va_arg(ap, double *) = dc->stats.position;
            vlc_mutex_unlock(&dc->lock);
            break;
        case DEMUX_GET_LENGTH:
            vlc_mutex_lock(&dc->lock);
            *va_arg(ap, int64_t *) = dc->stats.length;
            vlc_mutex_unlock(&dc->lock);
            break;
        case DEMUX_GET_TIME:
            vlc_mutex_lock(&dc->lock);
            *va_arg(ap, int64_t *) = dc->stats.time;
            vlc_mutex_unlock(&dc->lock);
            break;
        default:
            return VLC_EGENERIC;
    }
    return VLC_SUCCESS;
}",1,1,input\demux_chained.c,vlc_demux_chained_ControlVa,,false,137,160,vlc_demux_chained_ControlVa,,,5,"int vlc_demux_chained_ControlVa (vlc_demux_chained_t*,int,va_list)"
36159,METHOD,input\demux_chained.c:<global>,TYPE_DECL,"void vlc_demux_chained_Delete(vlc_demux_chained_t *dc)
{
    vlc_stream_fifo_Close(dc->fifo);
    vlc_join(dc->thread, NULL);
    vlc_mutex_destroy(&dc->lock);
    free(dc);
}",1,1,input\demux_chained.c,vlc_demux_chained_Delete,,false,162,168,vlc_demux_chained_Delete,,,6,void vlc_demux_chained_Delete (vlc_demux_chained_t*)
36223,METHOD,input\es_out.c:<global>,TYPE_DECL,<global>,1,1,input\es_out.c,input\es_out.c:<global>,,false,1,3420,<global>,,,1,
36249,METHOD,<empty>,<empty>,<empty>,5,,input\es_out.c,es_out_id_t.cc:<clinit>,,false,100,,<clinit>,,,4,
36299,METHOD,input\es_out.c:<global>,TYPE_DECL,"static es_out_id_t *EsOutAdd    ( es_out_t *, const es_format_t * );",20,67,input\es_out.c,EsOutAdd,,false,184,184,EsOutAdd,,,7,"es_out_id_t* EsOutAdd (es_out_t*,es_format_t*)"
36305,METHOD,input\es_out.c:<global>,TYPE_DECL,"static int          EsOutSend   ( es_out_t *, es_out_id_t *, block_t * );",21,72,input\es_out.c,EsOutSend,,false,185,185,EsOutSend,,,8,"int EsOutSend (es_out_t*,es_out_id_t*,block_t*)"
36312,METHOD,input\es_out.c:<global>,TYPE_DECL,"static void         EsOutDel    ( es_out_t *, es_out_id_t * );",21,61,input\es_out.c,EsOutDel,,false,186,186,EsOutDel,,,9,"void EsOutDel (es_out_t*,es_out_id_t*)"
36318,METHOD,input\es_out.c:<global>,TYPE_DECL,"static int          EsOutControl( es_out_t *, int i_query, va_list );",21,68,input\es_out.c,EsOutControl,,false,187,187,EsOutControl,,,10,"int EsOutControl (es_out_t*,int,ANY)"
36325,METHOD,input\es_out.c:<global>,TYPE_DECL,static void         EsOutDelete ( es_out_t * );,21,46,input\es_out.c,EsOutDelete,,false,188,188,EsOutDelete,,,11,void EsOutDelete (es_out_t*)
36330,METHOD,input\es_out.c:<global>,TYPE_DECL,static void         EsOutTerminate( es_out_t * );,21,48,input\es_out.c,EsOutTerminate,,false,190,190,EsOutTerminate,,,12,void EsOutTerminate (es_out_t*)
36335,METHOD,input\es_out.c:<global>,TYPE_DECL,"static void         EsOutSelect( es_out_t *, es_out_id_t *es, bool b_force );",21,76,input\es_out.c,EsOutSelect,,false,191,191,EsOutSelect,,,13,"void EsOutSelect (es_out_t*,es_out_id_t*,bool)"
36342,METHOD,input\es_out.c:<global>,TYPE_DECL,"static void         EsOutUpdateInfo( es_out_t *, es_out_id_t *es, const es_format_t *, const vlc_meta_t * );",21,107,input\es_out.c,EsOutUpdateInfo,,false,192,192,EsOutUpdateInfo,,,14,"void EsOutUpdateInfo (es_out_t*,es_out_id_t*,es_format_t*,vlc_meta_t*)"
36350,METHOD,input\es_out.c:<global>,TYPE_DECL,"static int          EsOutSetRecord(  es_out_t *, bool b_record );",21,64,input\es_out.c,EsOutSetRecord,,false,193,193,EsOutSetRecord,,,15,"int EsOutSetRecord (es_out_t*,bool)"
36356,METHOD,input\es_out.c:<global>,TYPE_DECL,static bool EsIsSelected( es_out_id_t *es );,13,43,input\es_out.c,EsIsSelected,,false,195,195,EsIsSelected,,,16,bool EsIsSelected (es_out_id_t*)
36361,METHOD,input\es_out.c:<global>,TYPE_DECL,"static void EsSelect( es_out_t *out, es_out_id_t *es );",13,54,input\es_out.c,EsSelect,,false,196,196,EsSelect,,,17,"void EsSelect (es_out_t*,es_out_id_t*)"
36367,METHOD,input\es_out.c:<global>,TYPE_DECL,"static void EsDeleteInfo( es_out_t *, es_out_id_t *es );",13,55,input\es_out.c,EsDeleteInfo,,false,197,197,EsDeleteInfo,,,18,"void EsDeleteInfo (es_out_t*,es_out_id_t*)"
36373,METHOD,input\es_out.c:<global>,TYPE_DECL,"static void EsUnselect( es_out_t *out, es_out_id_t *es, bool b_update );",13,71,input\es_out.c,EsUnselect,,false,198,198,EsUnselect,,,19,"void EsUnselect (es_out_t*,es_out_id_t*,bool)"
36380,METHOD,input\es_out.c:<global>,TYPE_DECL,"static void EsOutDecoderChangeDelay( es_out_t *out, es_out_id_t *p_es );",13,71,input\es_out.c,EsOutDecoderChangeDelay,,false,199,199,EsOutDecoderChangeDelay,,,20,"void EsOutDecoderChangeDelay (es_out_t*,es_out_id_t*)"
36386,METHOD,input\es_out.c:<global>,TYPE_DECL,"static void EsOutDecodersChangePause( es_out_t *out, bool b_paused, mtime_t i_date );",13,84,input\es_out.c,EsOutDecodersChangePause,,false,200,200,EsOutDecodersChangePause,,,21,"void EsOutDecodersChangePause (es_out_t*,bool,mtime_t)"
36393,METHOD,input\es_out.c:<global>,TYPE_DECL,"static void EsOutProgramChangePause( es_out_t *out, bool b_paused, mtime_t i_date );",13,83,input\es_out.c,EsOutProgramChangePause,,false,201,201,EsOutProgramChangePause,,,22,"void EsOutProgramChangePause (es_out_t*,bool,mtime_t)"
36400,METHOD,input\es_out.c:<global>,TYPE_DECL,static void EsOutProgramsChangeRate( es_out_t *out );,13,52,input\es_out.c,EsOutProgramsChangeRate,,false,202,202,EsOutProgramsChangeRate,,,23,void EsOutProgramsChangeRate (es_out_t*)
36405,METHOD,input\es_out.c:<global>,TYPE_DECL,"static void EsOutDecodersStopBuffering( es_out_t *out, bool b_forced );",13,70,input\es_out.c,EsOutDecodersStopBuffering,,false,203,203,EsOutDecodersStopBuffering,,,24,"void EsOutDecodersStopBuffering (es_out_t*,bool)"
36411,METHOD,input\es_out.c:<global>,TYPE_DECL,"static void EsOutGlobalMeta( es_out_t *p_out, const vlc_meta_t *p_meta );",13,72,input\es_out.c,EsOutGlobalMeta,,false,204,204,EsOutGlobalMeta,,,25,"void EsOutGlobalMeta (es_out_t*,vlc_meta_t*)"
36417,METHOD,input\es_out.c:<global>,TYPE_DECL,"static void EsOutMeta( es_out_t *p_out, const vlc_meta_t *p_meta, const vlc_meta_t *p_progmeta );",13,96,input\es_out.c,EsOutMeta,,false,205,205,EsOutMeta,,,26,"void EsOutMeta (es_out_t*,vlc_meta_t*,vlc_meta_t*)"
36424,METHOD,input\es_out.c:<global>,TYPE_DECL,static char *LanguageGetName( const char *psz_code );,13,52,input\es_out.c,LanguageGetName,,false,207,207,LanguageGetName,,,27,char* LanguageGetName (char*)
36429,METHOD,input\es_out.c:<global>,TYPE_DECL,static char *LanguageGetCode( const char *psz_lang );,13,52,input\es_out.c,LanguageGetCode,,false,208,208,LanguageGetCode,,,28,char* LanguageGetCode (char*)
36434,METHOD,input\es_out.c:<global>,TYPE_DECL,static char **LanguageSplit( const char *psz_langs );,13,52,input\es_out.c,LanguageSplit,,false,209,209,LanguageSplit,,,29,char** LanguageSplit (char*)
36439,METHOD,input\es_out.c:<global>,TYPE_DECL,"static int LanguageArrayIndex( char **ppsz_langs, const char *psz_lang );",12,72,input\es_out.c,LanguageArrayIndex,,false,210,210,LanguageArrayIndex,,,30,"int LanguageArrayIndex (char**,char*)"
36445,METHOD,input\es_out.c:<global>,TYPE_DECL,static char *EsOutProgramGetMetaName( es_out_pgrm_t *p_pgrm );,13,61,input\es_out.c,EsOutProgramGetMetaName,,false,212,212,EsOutProgramGetMetaName,,,31,char* EsOutProgramGetMetaName (es_out_pgrm_t*)
36450,METHOD,input\es_out.c:<global>,TYPE_DECL,static char *EsInfoCategoryName( es_out_id_t* es );,13,50,input\es_out.c,EsInfoCategoryName,,false,213,213,EsInfoCategoryName,,,32,char* EsInfoCategoryName (es_out_id_t*)
36455,METHOD,input\es_out.c:<global>,TYPE_DECL,"static inline int EsOutGetClosedCaptionsChannel( const es_format_t *p_fmt )
{
    int i_channel;
    if( p_fmt->i_codec == VLC_CODEC_CEA608 && p_fmt->subs.cc.i_channel < 4 )
        i_channel = p_fmt->subs.cc.i_channel;
    else if( p_fmt->i_codec == VLC_CODEC_CEA708 && p_fmt->subs.cc.i_channel < 64 )
        i_channel = p_fmt->subs.cc.i_channel;
    else
        i_channel = -1;
    return i_channel;
}",1,1,input\es_out.c,EsOutGetClosedCaptionsChannel,,false,215,225,EsOutGetClosedCaptionsChannel,,,33,int EsOutGetClosedCaptionsChannel (es_format_t*)
36523,METHOD,input\es_out.c:<global>,TYPE_DECL,"static inline bool EsFmtIsTeletext( const es_format_t *p_fmt )
{
    return p_fmt->i_cat == SPU_ES && p_fmt->i_codec == VLC_CODEC_TELETEXT;
}",1,1,input\es_out.c,EsFmtIsTeletext,,false,226,229,EsFmtIsTeletext,,,34,bool EsFmtIsTeletext (es_format_t*)
36540,METHOD,input\es_out.c:<global>,TYPE_DECL,"static es_out_es_props_t * GetPropsByCat( es_out_sys_t *p_sys, int i_cat )
{
    switch( i_cat )
    {
    case AUDIO_ES:
        return &p_sys->audio;
    case SPU_ES:
        return &p_sys->sub;
    case VIDEO_ES:
        return &p_sys->video;
    }
    return NULL;
}",1,1,input\es_out.c,GetPropsByCat,,false,234,246,GetPropsByCat,,,35,"es_out_es_props_t GetPropsByCat (es_out_sys_t*,int)"
36572,METHOD,input\es_out.c:<global>,TYPE_DECL,"static void EsOutPropsCleanup( es_out_es_props_t *p_props )
{
    if( p_props->ppsz_language )
    {
        for( int i = 0; p_props->ppsz_language[i]; i++ )
            free( p_props->ppsz_language[i] );
        free( p_props->ppsz_language );
    }
}",1,1,input\es_out.c,EsOutPropsCleanup,,false,248,256,EsOutPropsCleanup,,,36,void EsOutPropsCleanup (es_out_es_props_t*)
36605,METHOD,input\es_out.c:<global>,TYPE_DECL,"static void EsOutPropsInit( es_out_es_props_t *p_props,
                            bool autoselect,
                            input_thread_t *p_input,
                            enum es_out_policy_e e_default_policy,
                            const char *psz_trackidvar,
                            const char *psz_trackvar,
                            const char *psz_langvar,
                            const char *psz_debug )
{
    p_props->e_policy = e_default_policy;
    p_props->i_count = 0;
    p_props->b_autoselect = autoselect;
    p_props->i_id = (psz_trackidvar) ? var_GetInteger( p_input, psz_trackidvar ): -1;
    p_props->i_channel = (psz_trackvar) ? var_GetInteger( p_input, psz_trackvar ): -1;
    p_props->i_demux_id = -1;
    p_props->p_main_es = NULL;

    if( !input_priv(p_input)->b_preparsing && psz_langvar )
    {
        char *psz_string = var_GetString( p_input, psz_langvar );
        p_props->ppsz_language = LanguageSplit( psz_string );
        if( p_props->p...",1,1,input\es_out.c,EsOutPropsInit,,false,258,287,EsOutPropsInit,,,37,"void EsOutPropsInit (es_out_es_props_t*,bool,input_thread_t*,es_out_policy_e,char*,char*,char*,char*)"
36716,METHOD,input\es_out.c:<global>,TYPE_DECL,"es_out_t *input_EsOutNew( input_thread_t *p_input, int i_rate )
{
    es_out_t     *out = malloc( sizeof( *out ) );
    if( !out )
        return NULL;

    es_out_sys_t *p_sys = calloc( 1, sizeof( *p_sys ) );
    if( !p_sys )
    {
        free( out );
        return NULL;
    }

    out->pf_add     = EsOutAdd;
    out->pf_send    = EsOutSend;
    out->pf_del     = EsOutDel;
    out->pf_control = EsOutControl;
    out->pf_destroy = EsOutDelete;
    out->p_sys      = p_sys;

    vlc_mutex_init_recursive( &p_sys->lock );
    p_sys->p_input = p_input;

    p_sys->b_active = false;
    p_sys->i_mode   = ES_OUT_MODE_NONE;

    TAB_INIT( p_sys->i_pgrm, p_sys->pgrm );

    TAB_INIT( p_sys->i_es, p_sys->es );

    /* */
    EsOutPropsInit( &p_sys->video, true, p_input, ES_OUT_ES_POLICY_SIMULTANEOUS,
                    NULL, NULL, NULL, NULL );
    EsOutPropsInit( &p_sys->audio, true, p_input, ES_OUT_ES_POLICY_EXCLUSIVE,
                    ""audio-track-id"", ""audio-track"", ""audio-language""...",1,1,input\es_out.c,input_EsOutNew,,false,292,341,input_EsOutNew,,,38,"es_out_t input_EsOutNew (input_thread_t*,int)"
36888,METHOD,input\es_out.c:<global>,TYPE_DECL,"static void EsOutDelete( es_out_t *out )
{
    es_out_sys_t *p_sys = out->p_sys;

    assert( !p_sys->i_es && !p_sys->i_pgrm && !p_sys->p_pgrm );
    EsOutPropsCleanup( &p_sys->audio );
    EsOutPropsCleanup( &p_sys->sub );

    vlc_mutex_destroy( &p_sys->lock );

    free( p_sys );
    free( out );
}",1,1,input\es_out.c,EsOutDelete,,false,346,358,EsOutDelete,,,39,void EsOutDelete (es_out_t*)
36933,METHOD,input\es_out.c:<global>,TYPE_DECL,"static void EsOutTerminate( es_out_t *out )
{
    es_out_sys_t *p_sys = out->p_sys;

    if( p_sys->p_sout_record )
        EsOutSetRecord( out, false );

    for( int i = 0; i < p_sys->i_es; i++ )
    {
        if( p_sys->es[i]->p_dec )
            input_DecoderDelete( p_sys->es[i]->p_dec );

        free( p_sys->es[i]->psz_language );
        free( p_sys->es[i]->psz_language_code );
        es_format_Clean( &p_sys->es[i]->fmt );

        free( p_sys->es[i] );
    }
    TAB_CLEAN( p_sys->i_es, p_sys->es );

    /* FIXME duplicate work EsOutProgramDel (but we cannot use it) add a EsOutProgramClean ? */
    for( int i = 0; i < p_sys->i_pgrm; i++ )
    {
        es_out_pgrm_t *p_pgrm = p_sys->pgrm[i];
        input_clock_Delete( p_pgrm->p_clock );
        if( p_pgrm->p_meta )
            vlc_meta_Delete( p_pgrm->p_meta );

        free( p_pgrm );
    }
    TAB_CLEAN( p_sys->i_pgrm, p_sys->pgrm );

    p_sys->p_pgrm = NULL;

    input_item_SetEpgOffline( input_priv(p_sys->p_input)->p_i...",1,1,input\es_out.c,EsOutTerminate,,false,360,396,EsOutTerminate,,,40,void EsOutTerminate (es_out_t*)
37081,METHOD,input\es_out.c:<global>,TYPE_DECL,"static mtime_t EsOutGetWakeup( es_out_t *out )
{
    es_out_sys_t   *p_sys = out->p_sys;
    input_thread_t *p_input = p_sys->p_input;

    if( !p_sys->p_pgrm )
        return 0;

    /* We do not have a wake up date if the input cannot have its speed
     * controlled or sout is imposing its own or while buffering
     *
     * FIXME for !input_priv(p_input)->b_can_pace_control a wake-up time is still needed
     * to avoid too heavy buffering */
    if( !input_priv(p_input)->b_can_pace_control ||
        input_priv(p_input)->b_out_pace_control ||
        p_sys->b_buffering )
        return 0;

    return input_clock_GetWakeup( p_sys->p_pgrm->p_clock );
}",1,1,input\es_out.c,EsOutGetWakeup,,false,398,417,EsOutGetWakeup,,,41,mtime_t EsOutGetWakeup (es_out_t*)
37134,METHOD,input\es_out.c:<global>,TYPE_DECL,"static es_out_id_t *EsOutGetFromID( es_out_t *out, int i_id )
{
    if( i_id < 0 )
    {
        /* Special HACK, -i_id is the cat of the stream */
        return es_cat - i_id;
    }

    for( int i = 0; i < out->p_sys->i_es; i++ )
    {
        if( out->p_sys->es[i]->i_id == i_id )
            return out->p_sys->es[i];
    }
    return NULL;
}",1,1,input\es_out.c,EsOutGetFromID,,false,421,435,EsOutGetFromID,,,44,"es_out_id_t EsOutGetFromID (es_out_t*,int)"
37188,METHOD,input\es_out.c:<global>,TYPE_DECL,"static bool EsOutDecodersIsEmpty( es_out_t *out )
{
    es_out_sys_t      *p_sys = out->p_sys;

    if( p_sys->b_buffering && p_sys->p_pgrm )
    {
        EsOutDecodersStopBuffering( out, true );
        if( p_sys->b_buffering )
            return true;
    }

    for( int i = 0; i < p_sys->i_es; i++ )
    {
        es_out_id_t *es = p_sys->es[i];

        if( es->p_dec && !input_DecoderIsEmpty( es->p_dec ) )
            return false;
        if( es->p_dec_record && !input_DecoderIsEmpty( es->p_dec_record ) )
            return false;
    }
    return true;
}",1,1,input\es_out.c,EsOutDecodersIsEmpty,,false,437,458,EsOutDecodersIsEmpty,,,45,bool EsOutDecodersIsEmpty (es_out_t*)
37268,METHOD,input\es_out.c:<global>,TYPE_DECL,"static void EsOutSetDelay( es_out_t *out, int i_cat, int64_t i_delay )
{
    es_out_sys_t *p_sys = out->p_sys;

    if( i_cat == AUDIO_ES )
        p_sys->i_audio_delay = i_delay;
    else if( i_cat == SPU_ES )
        p_sys->i_spu_delay = i_delay;

    for( int i = 0; i < p_sys->i_es; i++ )
        EsOutDecoderChangeDelay( out, p_sys->es[i] );
}",1,1,input\es_out.c,EsOutSetDelay,,false,460,471,EsOutSetDelay,,,46,"void EsOutSetDelay (es_out_t*,int,int64_t)"
37323,METHOD,input\es_out.c:<global>,TYPE_DECL,"static int EsOutSetRecord(  es_out_t *out, bool b_record )
{
    es_out_sys_t   *p_sys = out->p_sys;
    input_thread_t *p_input = p_sys->p_input;

    assert( ( b_record && !p_sys->p_sout_record ) || ( !b_record && p_sys->p_sout_record ) );

    if( b_record )
    {
        char *psz_path = var_CreateGetNonEmptyString( p_input, ""input-record-path"" );
        if( !psz_path )
        {
            if( var_CountChoices( p_input, ""video-es"" ) )
                psz_path = config_GetUserDir( VLC_VIDEOS_DIR );
            else if( var_CountChoices( p_input, ""audio-es"" ) )
                psz_path = config_GetUserDir( VLC_MUSIC_DIR );
            else
                psz_path = config_GetUserDir( VLC_DOWNLOAD_DIR );
        }

        char *psz_sout = NULL;  // TODO conf

        if( !psz_sout && psz_path )
        {
            char *psz_file = input_CreateFilename( p_input, psz_path, INPUT_RECORD_PREFIX, NULL );
            if( psz_file )
            {
                char* psz_file_esc ...",1,1,input\es_out.c,EsOutSetRecord,,false,473,554,EsOutSetRecord,,,47,"int EsOutSetRecord (es_out_t*,bool)"
37568,METHOD,input\es_out.c:<global>,TYPE_DECL,"static void EsOutChangePause( es_out_t *out, bool b_paused, mtime_t i_date )
{
    es_out_sys_t *p_sys = out->p_sys;

    /* XXX the order is important */
    if( b_paused )
    {
        EsOutDecodersChangePause( out, true, i_date );
        EsOutProgramChangePause( out, true, i_date );
    }
    else
    {
        if( p_sys->i_buffering_extra_initial > 0 )
        {
            mtime_t i_stream_start;
            mtime_t i_system_start;
            mtime_t i_stream_duration;
            mtime_t i_system_duration;
            int i_ret;
            i_ret = input_clock_GetState( p_sys->p_pgrm->p_clock,
                                          &i_stream_start, &i_system_start,
                                          &i_stream_duration, &i_system_duration );
            if( !i_ret )
            {
                /* FIXME pcr != exactly what wanted */
                const mtime_t i_used = /*(i_stream_duration - input_priv(p_sys->p_input)->i_pts_delay)*/ p_sys->i_buffering_extra_sys...",1,1,input\es_out.c,EsOutChangePause,,false,555,594,EsOutChangePause,,,48,"void EsOutChangePause (es_out_t*,bool,mtime_t)"
37674,METHOD,input\es_out.c:<global>,TYPE_DECL,"static void EsOutChangeRate( es_out_t *out, int i_rate )
{
    es_out_sys_t      *p_sys = out->p_sys;

    p_sys->i_rate = i_rate;
    EsOutProgramsChangeRate( out );
}",1,1,input\es_out.c,EsOutChangeRate,,false,596,602,EsOutChangeRate,,,49,"void EsOutChangeRate (es_out_t*,int)"
37693,METHOD,input\es_out.c:<global>,TYPE_DECL,"static void EsOutChangePosition( es_out_t *out )
{
    es_out_sys_t      *p_sys = out->p_sys;

    input_SendEventCache( p_sys->p_input, 0.0 );

    for( int i = 0; i < p_sys->i_es; i++ )
    {
        es_out_id_t *p_es = p_sys->es[i];

        if( p_es->p_dec != NULL )
        {
            input_DecoderFlush( p_es->p_dec );
            if( !p_sys->b_buffering )
            {
                input_DecoderStartWait( p_es->p_dec );
                if( p_es->p_dec_record != NULL )
                    input_DecoderStartWait( p_es->p_dec_record );
            }
        }
        p_es->i_pts_level = VLC_TS_INVALID;
    }

    for( int i = 0; i < p_sys->i_pgrm; i++ ) {
        input_clock_Reset( p_sys->pgrm[i]->p_clock );
        p_sys->pgrm[i]->i_last_pcr = VLC_TS_INVALID;
    }

    p_sys->b_buffering = true;
    p_sys->i_buffering_extra_initial = 0;
    p_sys->i_buffering_extra_stream = 0;
    p_sys->i_buffering_extra_system = 0;
    p_sys->i_preroll_end = -1;
    p_sys->i_prev_stream_...",1,1,input\es_out.c,EsOutChangePosition,,false,604,638,EsOutChangePosition,,,50,void EsOutChangePosition (es_out_t*)
37831,METHOD,input\es_out.c:<global>,TYPE_DECL,"static void EsOutDecodersStopBuffering( es_out_t *out, bool b_forced )
{
    es_out_sys_t *p_sys = out->p_sys;

    mtime_t i_stream_start;
    mtime_t i_system_start;
    mtime_t i_stream_duration;
    mtime_t i_system_duration;
    if (input_clock_GetState( p_sys->p_pgrm->p_clock,
                                  &i_stream_start, &i_system_start,
                                  &i_stream_duration, &i_system_duration ))
        return;

    mtime_t i_preroll_duration = 0;
    if( p_sys->i_preroll_end >= 0 )
        i_preroll_duration = __MAX( p_sys->i_preroll_end - i_stream_start, 0 );

    const mtime_t i_buffering_duration = p_sys->i_pts_delay +
                                         i_preroll_duration +
                                         p_sys->i_buffering_extra_stream - p_sys->i_buffering_extra_initial;

    if( i_stream_duration <= i_buffering_duration && !b_forced )
    {
        double f_level;
        if (i_buffering_duration == 0)
            f_level = 0;
      ...",1,1,input\es_out.c,EsOutDecodersStopBuffering,,false,642,731,EsOutDecodersStopBuffering,,,51,"void EsOutDecodersStopBuffering (es_out_t*,bool)"
38149,METHOD,input\es_out.c:<global>,TYPE_DECL,"static void EsOutDecodersChangePause( es_out_t *out, bool b_paused, mtime_t i_date )
{
    es_out_sys_t *p_sys = out->p_sys;

    /* Pause decoders first */
    for( int i = 0; i < p_sys->i_es; i++ )
    {
        es_out_id_t *es = p_sys->es[i];

        if( es->p_dec )
        {
            input_DecoderChangePause( es->p_dec, b_paused, i_date );
            if( es->p_dec_record )
                input_DecoderChangePause( es->p_dec_record, b_paused, i_date );
        }
    }
}",1,1,input\es_out.c,EsOutDecodersChangePause,,false,732,748,EsOutDecodersChangePause,,,52,"void EsOutDecodersChangePause (es_out_t*,bool,mtime_t)"
38206,METHOD,input\es_out.c:<global>,TYPE_DECL,"static bool EsOutIsExtraBufferingAllowed( es_out_t *out )
{
    es_out_sys_t *p_sys = out->p_sys;

    size_t i_size = 0;
    for( int i = 0; i < p_sys->i_es; i++ )
    {
        es_out_id_t *p_es = p_sys->es[i];

        if( p_es->p_dec )
            i_size += input_DecoderGetFifoSize( p_es->p_dec );
        if( p_es->p_dec_record )
            i_size += input_DecoderGetFifoSize( p_es->p_dec_record );
    }
    //msg_Info( out, ""----- EsOutIsExtraBufferingAllowed =% 5d KiB -- "", i_size / 1024 );

    /* TODO maybe we want to be able to tune it ? */
#if defined(OPTIMIZE_MEMORY)
    const size_t i_level_high = 512*1024;  /* 0.5 MiB */
#else
    const size_t i_level_high = 10*1024*1024; /* 10 MiB */
#endif
    return i_size < i_level_high;
}",1,1,input\es_out.c,EsOutIsExtraBufferingAllowed,,false,750,773,EsOutIsExtraBufferingAllowed,,,53,bool EsOutIsExtraBufferingAllowed (es_out_t*)
38277,METHOD,input\es_out.c:<global>,TYPE_DECL,"static void EsOutProgramChangePause( es_out_t *out, bool b_paused, mtime_t i_date )
{
    es_out_sys_t *p_sys = out->p_sys;

    for( int i = 0; i < p_sys->i_pgrm; i++ )
        input_clock_ChangePause( p_sys->pgrm[i]->p_clock, b_paused, i_date );
}",1,1,input\es_out.c,EsOutProgramChangePause,,false,775,781,EsOutProgramChangePause,,,54,"void EsOutProgramChangePause (es_out_t*,bool,mtime_t)"
38313,METHOD,input\es_out.c:<global>,TYPE_DECL,"static void EsOutDecoderChangeDelay( es_out_t *out, es_out_id_t *p_es )
{
    es_out_sys_t *p_sys = out->p_sys;

    mtime_t i_delay = 0;
    if( p_es->fmt.i_cat == AUDIO_ES )
        i_delay = p_sys->i_audio_delay;
    else if( p_es->fmt.i_cat == SPU_ES )
        i_delay = p_sys->i_spu_delay;
    else
        return;

    if( p_es->p_dec )
        input_DecoderChangeDelay( p_es->p_dec, i_delay );
    if( p_es->p_dec_record )
        input_DecoderChangeDelay( p_es->p_dec_record, i_delay );
}",1,1,input\es_out.c,EsOutDecoderChangeDelay,,false,783,799,EsOutDecoderChangeDelay,,,55,"void EsOutDecoderChangeDelay (es_out_t*,es_out_id_t*)"
38382,METHOD,input\es_out.c:<global>,TYPE_DECL,"static void EsOutProgramsChangeRate( es_out_t *out )
{
    es_out_sys_t      *p_sys = out->p_sys;

    for( int i = 0; i < p_sys->i_pgrm; i++ )
        input_clock_ChangeRate( p_sys->pgrm[i]->p_clock, p_sys->i_rate );
}",1,1,input\es_out.c,EsOutProgramsChangeRate,,false,800,806,EsOutProgramsChangeRate,,,56,void EsOutProgramsChangeRate (es_out_t*)
38417,METHOD,input\es_out.c:<global>,TYPE_DECL,"static void EsOutFrameNext( es_out_t *out )
{
    es_out_sys_t *p_sys = out->p_sys;
    es_out_id_t *p_es_video = NULL;

    if( p_sys->b_buffering )
    {
        msg_Warn( p_sys->p_input, ""buffering, ignoring 'frame next'"" );
        return;
    }

    assert( p_sys->b_paused );

    for( int i = 0; i < p_sys->i_es; i++ )
    {
        es_out_id_t *p_es = p_sys->es[i];

        if( p_es->fmt.i_cat == VIDEO_ES && p_es->p_dec )
        {
            p_es_video = p_es;
            break;
        }
    }

    if( !p_es_video )
    {
        msg_Warn( p_sys->p_input, ""No video track selected, ignoring 'frame next'"" );
        return;
    }

    mtime_t i_duration;
    input_DecoderFrameNext( p_es_video->p_dec, &i_duration );

    msg_Dbg( out->p_sys->p_input, ""EsOutFrameNext consummed %d ms"", (int)(i_duration/1000) );

    if( i_duration <= 0 )
        i_duration = 40*1000;

    /* FIXME it is not a clean way ? */
    if( p_sys->i_buffering_extra_initial <= 0 )
    {
        mtime_t i_...",1,1,input\es_out.c,EsOutFrameNext,,false,808,876,EsOutFrameNext,,,57,void EsOutFrameNext (es_out_t*)
38629,METHOD,input\es_out.c:<global>,TYPE_DECL,"static mtime_t EsOutGetBuffering( es_out_t *out )
{
    es_out_sys_t *p_sys = out->p_sys;
    mtime_t i_stream_duration, i_system_start;

    if( !p_sys->p_pgrm )
        return 0;
    else
    {
        mtime_t i_stream_start, i_system_duration;

        if( input_clock_GetState( p_sys->p_pgrm->p_clock,
                                  &i_stream_start, &i_system_start,
                                  &i_stream_duration, &i_system_duration ) )
            return 0;
    }

    mtime_t i_delay;

    if( p_sys->b_buffering && p_sys->i_buffering_extra_initial <= 0 )
    {
        i_delay = i_stream_duration;
    }
    else
    {
        mtime_t i_system_duration;

        if( p_sys->b_paused )
        {
            i_system_duration = p_sys->i_pause_date  - i_system_start;
            if( p_sys->i_buffering_extra_initial > 0 )
                i_system_duration += p_sys->i_buffering_extra_system - p_sys->i_buffering_extra_initial;
        }
        else
        {
            i_system_...",1,1,input\es_out.c,EsOutGetBuffering,,false,877,921,EsOutGetBuffering,,,58,mtime_t EsOutGetBuffering (es_out_t*)
38753,METHOD,input\es_out.c:<global>,TYPE_DECL,"static void EsOutESVarUpdateGeneric( es_out_t *out, int i_id,
                                     const es_format_t *fmt, const char *psz_language,
                                     bool b_delete )
{
    es_out_sys_t      *p_sys = out->p_sys;
    input_thread_t    *p_input = p_sys->p_input;
    vlc_value_t       val, text;

    if( b_delete )
    {
        if( EsFmtIsTeletext( fmt ) )
            input_SendEventTeletextDel( p_sys->p_input, i_id );

        input_SendEventEsDel( p_input, fmt->i_cat, i_id );
        return;
    }

    /* Get the number of ES already added */
    const char *psz_var;
    if( fmt->i_cat == AUDIO_ES )
        psz_var = ""audio-es"";
    else if( fmt->i_cat == VIDEO_ES )
        psz_var = ""video-es"";
    else
        psz_var = ""spu-es"";

    var_Change( p_input, psz_var, VLC_VAR_CHOICESCOUNT, &val, NULL );
    if( val.i_int == 0 )
    {
        vlc_value_t val2;

        /* First one, we need to add the ""Disable"" choice */
        val2.i_int = -1; text....",1,1,input\es_out.c,EsOutESVarUpdateGeneric,,false,923,997,EsOutESVarUpdateGeneric,,,59,"void EsOutESVarUpdateGeneric (es_out_t*,int,es_format_t*,char*,bool)"
38988,METHOD,input\es_out.c:<global>,TYPE_DECL,"static void EsOutESVarUpdate( es_out_t *out, es_out_id_t *es,
                              bool b_delete )
{
    EsOutESVarUpdateGeneric( out, es->i_id, &es->fmt, es->psz_language, b_delete );
}",1,1,input\es_out.c,EsOutESVarUpdate,,false,999,1003,EsOutESVarUpdate,,,60,"void EsOutESVarUpdate (es_out_t*,es_out_id_t*,bool)"
39008,METHOD,input\es_out.c:<global>,TYPE_DECL,"static bool EsOutIsProgramVisible( es_out_t *out, int i_group )
{
    return out->p_sys->i_group_id == 0 || out->p_sys->i_group_id == i_group;
}",1,1,input\es_out.c,EsOutIsProgramVisible,,false,1005,1008,EsOutIsProgramVisible,,,61,"bool EsOutIsProgramVisible (es_out_t*,int)"
39030,METHOD,input\es_out.c:<global>,TYPE_DECL,"static void EsOutProgramSelect( es_out_t *out, es_out_pgrm_t *p_pgrm )
{
    es_out_sys_t      *p_sys = out->p_sys;
    input_thread_t    *p_input = p_sys->p_input;
    int               i;

    if( p_sys->p_pgrm == p_pgrm )
        return; /* Nothing to do */

    if( p_sys->p_pgrm )
    {
        es_out_pgrm_t *old = p_sys->p_pgrm;
        msg_Dbg( p_input, ""unselecting program id=%d"", old->i_id );

        for( i = 0; i < p_sys->i_es; i++ )
        {
            if( p_sys->es[i]->p_pgrm == old && EsIsSelected( p_sys->es[i] ) &&
                p_sys->i_mode != ES_OUT_MODE_ALL )
                EsUnselect( out, p_sys->es[i], true );
        }

        p_sys->audio.p_main_es = NULL;
        p_sys->video.p_main_es = NULL;
        p_sys->sub.p_main_es = NULL;
    }

    msg_Dbg( p_input, ""selecting program id=%d"", p_pgrm->i_id );

    /* Mark it selected */
    p_pgrm->b_selected = true;

    /* Switch master stream */
    p_sys->p_pgrm = p_pgrm;

    /* Update ""program"" */
    input...",1,1,input\es_out.c,EsOutProgramSelect,,false,1013,1086,EsOutProgramSelect,,,62,"void EsOutProgramSelect (es_out_t*,es_out_pgrm_t*)"
39296,METHOD,input\es_out.c:<global>,TYPE_DECL,"static es_out_pgrm_t *EsOutProgramAdd( es_out_t *out, int i_group )
{
    es_out_sys_t      *p_sys = out->p_sys;
    input_thread_t    *p_input = p_sys->p_input;

    es_out_pgrm_t *p_pgrm = malloc( sizeof( es_out_pgrm_t ) );
    if( !p_pgrm )
        return NULL;

    /* Init */
    p_pgrm->i_id = i_group;
    p_pgrm->i_es = 0;
    p_pgrm->b_selected = false;
    p_pgrm->b_scrambled = false;
    p_pgrm->i_last_pcr = VLC_TS_INVALID;
    p_pgrm->p_meta = NULL;
    p_pgrm->p_clock = input_clock_New( p_sys->i_rate );
    if( !p_pgrm->p_clock )
    {
        free( p_pgrm );
        return NULL;
    }
    if( p_sys->b_paused )
        input_clock_ChangePause( p_pgrm->p_clock, p_sys->b_paused, p_sys->i_pause_date );
    input_clock_SetJitter( p_pgrm->p_clock, p_sys->i_pts_delay, p_sys->i_cr_average );

    /* Append it */
    TAB_APPEND( p_sys->i_pgrm, p_sys->pgrm, p_pgrm );

    /* Update ""program"" variable */
    if( EsOutIsProgramVisible( out, i_group ) )
        input_SendEventProgram...",1,1,input\es_out.c,EsOutProgramAdd,,false,1091,1128,EsOutProgramAdd,,,63,"es_out_pgrm_t EsOutProgramAdd (es_out_t*,int)"
39439,METHOD,input\es_out.c:<global>,TYPE_DECL,"static int EsOutProgramDel( es_out_t *out, int i_group )
{
    es_out_sys_t      *p_sys = out->p_sys;
    input_thread_t    *p_input = p_sys->p_input;
    es_out_pgrm_t     *p_pgrm = NULL;
    int               i;

    for( i = 0; i < p_sys->i_pgrm; i++ )
    {
        if( p_sys->pgrm[i]->i_id == i_group )
        {
            p_pgrm = p_sys->pgrm[i];
            break;
        }
    }

    if( p_pgrm == NULL )
        return VLC_EGENERIC;

    if( p_pgrm->i_es )
    {
        msg_Dbg( p_input, ""can't delete program %d which still has %i ES"",
                 i_group, p_pgrm->i_es );
        return VLC_EGENERIC;
    }

    TAB_REMOVE( p_sys->i_pgrm, p_sys->pgrm, p_pgrm );

    /* If program is selected we need to unselect it */
    if( p_sys->p_pgrm == p_pgrm )
        p_sys->p_pgrm = NULL;

    input_clock_Delete( p_pgrm->p_clock );

    if( p_pgrm->p_meta )
        vlc_meta_Delete( p_pgrm->p_meta );
    free( p_pgrm );

    /* Update ""program"" variable */
    input_SendEventProgr...",1,1,input\es_out.c,EsOutProgramDel,,false,1133,1175,EsOutProgramDel,,,64,"int EsOutProgramDel (es_out_t*,int)"
39555,METHOD,input\es_out.c:<global>,TYPE_DECL,"static es_out_pgrm_t *EsOutProgramFind( es_out_t *p_out, int i_group )
{
    es_out_sys_t *p_sys = p_out->p_sys;

    for( int i = 0; i < p_sys->i_pgrm; i++ )
    {
        if( p_sys->pgrm[i]->i_id == i_group )
            return p_sys->pgrm[i];
    }
    return EsOutProgramAdd( p_out, i_group );
}",1,1,input\es_out.c,EsOutProgramFind,,false,1179,1189,EsOutProgramFind,,,65,"es_out_pgrm_t EsOutProgramFind (es_out_t*,int)"
39602,METHOD,input\es_out.c:<global>,TYPE_DECL,"static char *EsOutProgramGetMetaName( es_out_pgrm_t *p_pgrm )
{
    char *psz = NULL;
    if( p_pgrm->p_meta && vlc_meta_Get( p_pgrm->p_meta, vlc_meta_Title ) )
    {
        if( asprintf( &psz, _(""%s [%s %d]""), vlc_meta_Get( p_pgrm->p_meta, vlc_meta_Title ),
                      _(""Program""), p_pgrm->i_id ) == -1 )
            return NULL;
    }
    else
    {
        if( asprintf( &psz, ""%s %d"", _(""Program""), p_pgrm->i_id ) == -1 )
            return NULL;
    }
    return psz;
}",1,1,input\es_out.c,EsOutProgramGetMetaName,,false,1193,1208,EsOutProgramGetMetaName,,,66,char* EsOutProgramGetMetaName (es_out_pgrm_t*)
39664,METHOD,input\es_out.c:<global>,TYPE_DECL,"static char *EsOutProgramGetProgramName( es_out_pgrm_t *p_pgrm )
{
    char *psz = NULL;
    if( p_pgrm->p_meta && vlc_meta_Get( p_pgrm->p_meta, vlc_meta_Title ) )
    {
        return strdup( vlc_meta_Get( p_pgrm->p_meta, vlc_meta_Title ) );
    }
    else
    {
        if( asprintf( &psz, ""%s %d"", _(""Program""), p_pgrm->i_id ) == -1 )
            return NULL;
    }
    return psz;
}",1,1,input\es_out.c,EsOutProgramGetProgramName,,false,1210,1223,EsOutProgramGetProgramName,,,67,char* EsOutProgramGetProgramName (es_out_pgrm_t*)
39711,METHOD,input\es_out.c:<global>,TYPE_DECL,"static char *EsInfoCategoryName( es_out_id_t* es )
{
    char *psz_category;

    if( asprintf( &psz_category, _(""Stream %d""), es->i_meta_id ) == -1 )
        return NULL;

    return psz_category;
}",1,1,input\es_out.c,EsInfoCategoryName,,false,1225,1233,EsInfoCategoryName,,,68,char* EsInfoCategoryName (es_out_id_t*)
39734,METHOD,input\es_out.c:<global>,TYPE_DECL,"static void EsOutProgramMeta( es_out_t *out, int i_group, const vlc_meta_t *p_meta )
{
    es_out_sys_t      *p_sys = out->p_sys;
    es_out_pgrm_t     *p_pgrm;
    input_thread_t    *p_input = p_sys->p_input;
    const char        *psz_title = NULL;
    const char        *psz_provider = NULL;
    int i;

    msg_Dbg( p_input, ""EsOutProgramMeta: number=%d"", i_group );

    /* Check against empty meta data (empty for what we handle) */
    if( !vlc_meta_Get( p_meta, vlc_meta_Title) &&
        !vlc_meta_Get( p_meta, vlc_meta_ESNowPlaying) &&
        !vlc_meta_Get( p_meta, vlc_meta_Publisher) )
    {
        return;
    }

    if( i_group < 0 )
    {
        EsOutGlobalMeta( out, p_meta );
        return;
    }

    /* Find program */
    if( !EsOutIsProgramVisible( out, i_group ) )
        return;
    p_pgrm = EsOutProgramFind( out, i_group );
    if( !p_pgrm )
        return;

    if( p_pgrm->p_meta )
    {
        const char *psz_current_title = vlc_meta_Get( p_pgrm->p_meta, vlc_met...",1,1,input\es_out.c,EsOutProgramMeta,,false,1235,1355,EsOutProgramMeta,,,69,"void EsOutProgramMeta (es_out_t*,int,vlc_meta_t*)"
40052,METHOD,input\es_out.c:<global>,TYPE_DECL,"static void EsOutProgramEpgEvent( es_out_t *out, int i_group, const vlc_epg_event_t *p_event )
{
    es_out_sys_t      *p_sys = out->p_sys;
    input_thread_t    *p_input = p_sys->p_input;
    input_item_t      *p_item = input_priv(p_input)->p_item;
    es_out_pgrm_t     *p_pgrm;

    /* Find program */
    if( !EsOutIsProgramVisible( out, i_group ) )
        return;
    p_pgrm = EsOutProgramFind( out, i_group );
    if( !p_pgrm )
        return;

    input_item_SetEpgEvent( p_item, p_event );
}",1,1,input\es_out.c,EsOutProgramEpgEvent,,false,1357,1372,EsOutProgramEpgEvent,,,70,"void EsOutProgramEpgEvent (es_out_t*,int,vlc_epg_event_t*)"
40099,METHOD,input\es_out.c:<global>,TYPE_DECL,"static void EsOutProgramEpg( es_out_t *out, int i_group, const vlc_epg_t *p_epg )
{
    es_out_sys_t      *p_sys = out->p_sys;
    input_thread_t    *p_input = p_sys->p_input;
    input_item_t      *p_item = input_priv(p_input)->p_item;
    es_out_pgrm_t     *p_pgrm;
    char *psz_cat;

    /* Find program */
    if( !EsOutIsProgramVisible( out, i_group ) )
        return;
    p_pgrm = EsOutProgramFind( out, i_group );
    if( !p_pgrm )
        return;

    /* Update info */
    psz_cat = EsOutProgramGetMetaName( p_pgrm );
    msg_Dbg( p_input, ""EsOutProgramEpg: number=%d name=%s"", i_group, psz_cat );

    /* Merge EPG */
    vlc_epg_t epg;

    epg = *p_epg;
    epg.psz_name = EsOutProgramGetProgramName( p_pgrm );

    input_item_SetEpg( p_item, &epg, p_sys->p_pgrm && (p_epg->i_source_id == p_sys->p_pgrm->i_id) );
    input_SendEventMetaEpg( p_sys->p_input );

    free( epg.psz_name );

    /* Update now playing */
    if( p_epg->b_present && p_pgrm->p_meta &&
       ( p_epg->p_cur...",1,1,input\es_out.c,EsOutProgramEpg,,false,1374,1450,EsOutProgramEpg,,,71,"void EsOutProgramEpg (es_out_t*,int,vlc_epg_t*)"
40343,METHOD,input\es_out.c:<global>,TYPE_DECL,"static void EsOutEpgTime( es_out_t *out, int64_t time )
{
    es_out_sys_t      *p_sys = out->p_sys;
    input_thread_t    *p_input = p_sys->p_input;
    input_item_t      *p_item = input_priv(p_input)->p_item;

    input_item_SetEpgTime( p_item, time );
}",1,1,input\es_out.c,EsOutEpgTime,,false,1452,1459,EsOutEpgTime,,,72,"void EsOutEpgTime (es_out_t*,int64_t)"
40371,METHOD,input\es_out.c:<global>,TYPE_DECL,"static void EsOutProgramUpdateScrambled( es_out_t *p_out, es_out_pgrm_t *p_pgrm )
{
    es_out_sys_t    *p_sys = p_out->p_sys;
    input_thread_t  *p_input = p_sys->p_input;
    bool b_scrambled = false;

    for( int i = 0; i < p_sys->i_es; i++ )
    {
        if( p_sys->es[i]->p_pgrm == p_pgrm && p_sys->es[i]->b_scrambled )
        {
            b_scrambled = true;
            break;
        }
    }
    if( !p_pgrm->b_scrambled == !b_scrambled )
        return;

    p_pgrm->b_scrambled = b_scrambled;
    char *psz_cat = EsOutProgramGetMetaName( p_pgrm );

    if( b_scrambled )
        input_Control( p_input, INPUT_ADD_INFO, psz_cat, _(""Scrambled""), _(""Yes"") );
    else
        input_Control( p_input, INPUT_DEL_INFO, psz_cat, _(""Scrambled"") );
    free( psz_cat );

    input_SendEventProgramScrambled( p_input, p_pgrm->i_id, b_scrambled );
}",1,1,input\es_out.c,EsOutProgramUpdateScrambled,,false,1461,1488,EsOutProgramUpdateScrambled,,,73,"void EsOutProgramUpdateScrambled (es_out_t*,es_out_pgrm_t*)"
40477,METHOD,input\es_out.c:<global>,TYPE_DECL,"static void EsOutMeta( es_out_t *p_out, const vlc_meta_t *p_meta, const vlc_meta_t *p_program_meta )
{
    es_out_sys_t    *p_sys = p_out->p_sys;
    input_thread_t  *p_input = p_sys->p_input;
    input_item_t *p_item = input_GetItem( p_input );

    vlc_mutex_lock( &p_item->lock );
    if( p_meta )
        vlc_meta_Merge( p_item->p_meta, p_meta );
    vlc_mutex_unlock( &p_item->lock );

    /* Check program meta to not override GROUP_META values */
    if( p_meta && (!p_program_meta || vlc_meta_Get( p_program_meta, vlc_meta_Title ) == NULL) &&
         vlc_meta_Get( p_meta, vlc_meta_Title ) != NULL )
        input_item_SetName( p_item, vlc_meta_Get( p_meta, vlc_meta_Title ) );

    const char *psz_arturl = NULL;
    char *psz_alloc = NULL;

    if( p_program_meta )
        psz_arturl = vlc_meta_Get( p_program_meta, vlc_meta_ArtworkURL );
    if( psz_arturl == NULL && p_meta )
        psz_arturl = vlc_meta_Get( p_meta, vlc_meta_ArtworkURL );

    if( psz_arturl == NULL ) /* restore/...",1,1,input\es_out.c,EsOutMeta,,false,1490,1534,EsOutMeta,,,74,"void EsOutMeta (es_out_t*,vlc_meta_t*,vlc_meta_t*)"
40625,METHOD,input\es_out.c:<global>,TYPE_DECL,"static void EsOutGlobalMeta( es_out_t *p_out, const vlc_meta_t *p_meta )
{
    es_out_sys_t    *p_sys = p_out->p_sys;
    EsOutMeta( p_out, p_meta,
               (p_sys->p_pgrm && p_sys->p_pgrm->p_meta) ? p_sys->p_pgrm->p_meta : NULL );
}",1,1,input\es_out.c,EsOutGlobalMeta,,false,1536,1541,EsOutGlobalMeta,,,75,"void EsOutGlobalMeta (es_out_t*,vlc_meta_t*)"
40656,METHOD,input\es_out.c:<global>,TYPE_DECL,"static es_out_id_t *EsOutAddSlave( es_out_t *out, const es_format_t *fmt, es_out_id_t *p_master )
{
    es_out_sys_t      *p_sys = out->p_sys;
    input_thread_t    *p_input = p_sys->p_input;

    if( fmt->i_group < 0 )
    {
        msg_Err( p_input, ""invalid group number"" );
        return NULL;
    }

    es_out_id_t   *es = malloc( sizeof( *es ) );
    es_out_pgrm_t *p_pgrm;
    int i;

    if( !es )
        return NULL;

    vlc_mutex_lock( &p_sys->lock );

    /* Search the program */
    p_pgrm = EsOutProgramFind( out, fmt->i_group );
    if( !p_pgrm )
    {
        vlc_mutex_unlock( &p_sys->lock );
        free( es );
        return NULL;
    }

    /* Increase ref count for program */
    p_pgrm->i_es++;

    /* Set up ES */
    es->p_pgrm = p_pgrm;
    es_format_Copy( &es->fmt, fmt );
    if( es->fmt.i_id < 0 )
        es->fmt.i_id = p_sys->i_id;
    if( !es->fmt.i_original_fourcc )
        es->fmt.i_original_fourcc = es->fmt.i_codec;

    es->i_id = es->fmt.i_id;
    es->...",1,1,input\es_out.c,EsOutAddSlave,,false,1543,1666,EsOutAddSlave,,,76,"es_out_id_t EsOutAddSlave (es_out_t*,es_format_t*,es_out_id_t*)"
41237,METHOD,input\es_out.c:<global>,TYPE_DECL,"static es_out_id_t *EsOutAdd( es_out_t *out, const es_format_t *fmt )
{
    return EsOutAddSlave( out, fmt, NULL );
}",1,1,input\es_out.c,EsOutAdd,,false,1671,1674,EsOutAdd,,,77,"es_out_id_t EsOutAdd (es_out_t*,es_format_t*)"
41248,METHOD,input\es_out.c:<global>,TYPE_DECL,"static bool EsIsSelected( es_out_id_t *es )
{
    if( es->p_master )
    {
        bool b_decode = false;
        if( es->p_master->p_dec )
        {
            int i_channel = EsOutGetClosedCaptionsChannel( &es->fmt );
            input_DecoderGetCcState( es->p_master->p_dec, es->fmt.i_codec,
                                     i_channel, &b_decode );
        }
        return b_decode;
    }
    else
    {
        return es->p_dec != NULL;
    }
}",1,1,input\es_out.c,EsIsSelected,,false,1676,1693,EsIsSelected,,,78,bool EsIsSelected (es_out_id_t*)
41301,METHOD,input\es_out.c:<global>,TYPE_DECL,"static void EsCreateDecoder( es_out_t *out, es_out_id_t *p_es )
{
    es_out_sys_t   *p_sys = out->p_sys;
    input_thread_t *p_input = p_sys->p_input;

    p_es->p_dec = input_DecoderNew( p_input, &p_es->fmt, p_es->p_pgrm->p_clock, input_priv(p_input)->p_sout );
    if( p_es->p_dec )
    {
        if( p_sys->b_buffering )
            input_DecoderStartWait( p_es->p_dec );

        if( !p_es->p_master && p_sys->p_sout_record )
        {
            p_es->p_dec_record = input_DecoderNew( p_input, &p_es->fmt, p_es->p_pgrm->p_clock, p_sys->p_sout_record );
            if( p_es->p_dec_record && p_sys->b_buffering )
                input_DecoderStartWait( p_es->p_dec_record );
        }
    }

    EsOutDecoderChangeDelay( out, p_es );
}",1,1,input\es_out.c,EsCreateDecoder,,false,1694,1714,EsCreateDecoder,,,79,"void EsCreateDecoder (es_out_t*,es_out_id_t*)"
41396,METHOD,input\es_out.c:<global>,TYPE_DECL,"static void EsDestroyDecoder( es_out_t *out, es_out_id_t *p_es )
{
    VLC_UNUSED(out);

    if( !p_es->p_dec )
        return;

    input_DecoderDelete( p_es->p_dec );
    p_es->p_dec = NULL;

    if( p_es->p_dec_record )
    {
        input_DecoderDelete( p_es->p_dec_record );
        p_es->p_dec_record = NULL;
    }
}",1,1,input\es_out.c,EsDestroyDecoder,,false,1715,1730,EsDestroyDecoder,,,80,"void EsDestroyDecoder (es_out_t*,es_out_id_t*)"
41434,METHOD,input\es_out.c:<global>,TYPE_DECL,"static void EsSelect( es_out_t *out, es_out_id_t *es )
{
    es_out_sys_t   *p_sys = out->p_sys;
    input_thread_t *p_input = p_sys->p_input;

    if( EsIsSelected( es ) )
    {
        msg_Warn( p_input, ""ES 0x%x is already selected"", es->i_id );
        return;
    }

    if( es->p_master )
    {
        int i_channel;
        if( !es->p_master->p_dec )
            return;

        i_channel = EsOutGetClosedCaptionsChannel( &es->fmt );

        if( i_channel == -1 ||
            input_DecoderSetCcState( es->p_master->p_dec, es->fmt.i_codec,
                                     i_channel, true ) )
            return;
    }
    else
    {
        const bool b_sout = input_priv(p_input)->p_sout != NULL;
        if( es->fmt.i_cat == VIDEO_ES || es->fmt.i_cat == SPU_ES )
        {
            if( !var_GetBool( p_input, b_sout ? ""sout-video"" : ""video"" ) )
            {
                msg_Dbg( p_input, ""video is disabled, not selecting ES 0x%x"",
                         es->i_id );
   ...",1,1,input\es_out.c,EsSelect,,false,1732,1796,EsSelect,,,81,"void EsSelect (es_out_t*,es_out_id_t*)"
41644,METHOD,input\es_out.c:<global>,TYPE_DECL,"static void EsDeleteCCChannels( es_out_t *out, es_out_id_t *parent )
{
    es_out_sys_t   *p_sys = out->p_sys;
    input_thread_t *p_input = p_sys->p_input;

    if( parent->cc.type == 0 )
        return;

    const int i_spu_id = var_GetInteger( p_input, ""spu-es"");

    uint64_t i_bitmap = parent->cc.i_bitmap;
    for( int i = 0; i_bitmap > 0; i++, i_bitmap >>= 1 )
    {
        if( (i_bitmap & 1) == 0 || !parent->cc.pp_es[i] )
            continue;

        if( i_spu_id == parent->cc.pp_es[i]->i_id )
        {
            /* Force unselection of the CC */
            input_SendEventEsSelect( p_input, SPU_ES, -1 );
        }
        EsOutDel( out, parent->cc.pp_es[i] );
    }

    parent->cc.i_bitmap = 0;
    parent->cc.type = 0;
}",1,1,input\es_out.c,EsDeleteCCChannels,,false,1798,1824,EsDeleteCCChannels,,,82,"void EsDeleteCCChannels (es_out_t*,es_out_id_t*)"
41760,METHOD,input\es_out.c:<global>,TYPE_DECL,"static void EsUnselect( es_out_t *out, es_out_id_t *es, bool b_update )
{
    es_out_sys_t   *p_sys = out->p_sys;
    input_thread_t *p_input = p_sys->p_input;

    if( !EsIsSelected( es ) )
    {
        msg_Warn( p_input, ""ES 0x%x is already unselected"", es->i_id );
        return;
    }

    if( es->p_master )
    {
        if( es->p_master->p_dec )
        {
            int i_channel = EsOutGetClosedCaptionsChannel( &es->fmt );
            if( i_channel != -1 )
                input_DecoderSetCcState( es->p_master->p_dec, es->fmt.i_codec,
                                         i_channel, false );
        }
    }
    else
    {
        EsDeleteCCChannels( out, es );
        EsDestroyDecoder( out, es );
    }

    if( !b_update )
        return;

    /* Mark it as unselected */
    input_SendEventEsSelect( p_input, es->fmt.i_cat, -1 );
    if( EsFmtIsTeletext( &es->fmt ) )
        input_SendEventTeletextSelect( p_input, -1 );
}",1,1,input\es_out.c,EsUnselect,,false,1826,1860,EsUnselect,,,83,"void EsUnselect (es_out_t*,es_out_id_t*,bool)"
41863,METHOD,input\es_out.c:<global>,TYPE_DECL,"static void EsOutSelect( es_out_t *out, es_out_id_t *es, bool b_force )
{
    es_out_sys_t      *p_sys = out->p_sys;
    es_out_es_props_t *p_esprops = GetPropsByCat( p_sys, es->fmt.i_cat );

    if( !p_sys->b_active ||
        ( !b_force && es->fmt.i_priority < ES_PRIORITY_SELECTABLE_MIN ) )
    {
        return;
    }

    bool b_auto_unselect = p_esprops && p_sys->i_mode == ES_OUT_MODE_AUTO &&
                           p_esprops->e_policy == ES_OUT_ES_POLICY_EXCLUSIVE &&
                           p_esprops->p_main_es && p_esprops->p_main_es != es;

    if( p_sys->i_mode == ES_OUT_MODE_ALL || b_force )
    {
        if( !EsIsSelected( es ) )
        {
            if( b_auto_unselect )
                EsUnselect( out, p_esprops->p_main_es, false );

            EsSelect( out, es );
        }
    }
    else if( p_sys->i_mode == ES_OUT_MODE_PARTIAL )
    {
        char *prgms = var_GetNonEmptyString( p_sys->p_input, ""programs"" );
        if( prgms != NULL )
        {
            ch...",1,1,input\es_out.c,EsOutSelect,,false,1871,2006,EsOutSelect,,,84,"void EsOutSelect (es_out_t*,es_out_id_t*,bool)"
42334,METHOD,input\es_out.c:<global>,TYPE_DECL,"static void EsOutCreateCCChannels( es_out_t *out, vlc_fourcc_t codec, uint64_t i_bitmap,
                                   const char *psz_descfmt, es_out_id_t *parent )
{
    es_out_sys_t   *p_sys = out->p_sys;
    input_thread_t *p_input = p_sys->p_input;

    /* Only one type of captions is allowed ! */
    if( parent->cc.type && parent->cc.type != codec )
        return;

    uint64_t i_existingbitmap = parent->cc.i_bitmap;
    for( int i = 0; i_bitmap > 0; i++, i_bitmap >>= 1, i_existingbitmap >>= 1 )
    {
        es_format_t fmt;

        if( (i_bitmap & 1) == 0 || (i_existingbitmap & 1) )
            continue;

        msg_Dbg( p_input, ""Adding CC track %d for es[%d]"", 1+i, parent->i_id );

        es_format_Init( &fmt, SPU_ES, codec );
        fmt.subs.cc.i_channel = i;
        fmt.i_group = parent->fmt.i_group;
        if( asprintf( &fmt.psz_description, psz_descfmt, 1 + i ) == -1 )
            fmt.psz_description = NULL;

        es_out_id_t **pp_es = &parent->cc.pp_es[i...",1,1,input\es_out.c,EsOutCreateCCChannels,,false,2008,2046,EsOutCreateCCChannels,,,85,"void EsOutCreateCCChannels (es_out_t*,vlc_fourcc_t,uint64_t,char*,es_out_id_t*)"
42514,METHOD,input\es_out.c:<global>,TYPE_DECL,"static int EsOutSend( es_out_t *out, es_out_id_t *es, block_t *p_block )
{
    es_out_sys_t   *p_sys = out->p_sys;
    input_thread_t *p_input = p_sys->p_input;

    assert( p_block->p_next == NULL );

    if( libvlc_stats( p_input ) )
    {
        uint64_t i_total;

        vlc_mutex_lock( &input_priv(p_input)->counters.counters_lock );
        stats_Update( input_priv(p_input)->counters.p_demux_read,
                      p_block->i_buffer, &i_total );
        stats_Update( input_priv(p_input)->counters.p_demux_bitrate, i_total, NULL );

        /* Update number of corrupted data packats */
        if( p_block->i_flags & BLOCK_FLAG_CORRUPTED )
        {
            stats_Update( input_priv(p_input)->counters.p_demux_corrupted, 1, NULL );
        }
        /* Update number of discontinuities */
        if( p_block->i_flags & BLOCK_FLAG_DISCONTINUITY )
        {
            stats_Update( input_priv(p_input)->counters.p_demux_discontinuity, 1, NULL );
        }
        vlc_mutex_unl...",1,1,input\es_out.c,EsOutSend,,false,2055,2174,EsOutSend,,,86,"int EsOutSend (es_out_t*,es_out_id_t*,block_t*)"
42878,METHOD,input\es_out.c:<global>,TYPE_DECL,"static void EsOutDel( es_out_t *out, es_out_id_t *es )
{
    es_out_sys_t *p_sys = out->p_sys;
    bool b_reselect = false;
    int i;

    vlc_mutex_lock( &p_sys->lock );

    es_out_es_props_t *p_esprops = GetPropsByCat( p_sys, es->fmt.i_cat );

    /* We don't try to reselect */
    if( es->p_dec )
    {   /* FIXME: This might hold the ES output caller (i.e. the demux), and
         * the corresponding thread (typically the input thread), for a little
         * bit too long if the ES is deleted in the middle of a stream. */
        input_DecoderDrain( es->p_dec );
        while( !input_Stopped(p_sys->p_input) && !p_sys->b_buffering )
        {
            if( input_DecoderIsEmpty( es->p_dec ) &&
                ( !es->p_dec_record || input_DecoderIsEmpty( es->p_dec_record ) ))
                break;
            /* FIXME there should be a way to have auto deleted es, but there will be
             * a problem when another codec of the same type is created (mainly video) */
      ...",1,1,input\es_out.c,EsOutDel,,false,2179,2260,EsOutDel,,,87,"void EsOutDel (es_out_t*,es_out_id_t*)"
43141,METHOD,input\es_out.c:<global>,TYPE_DECL,"static int EsOutControlLocked( es_out_t *out, int i_query, va_list args )
{
    es_out_sys_t *p_sys = out->p_sys;

    switch( i_query )
    {
    case ES_OUT_SET_ES_STATE:
    {
        es_out_id_t *es = va_arg( args, es_out_id_t * );
        bool b = va_arg( args, int );
        if( b && !EsIsSelected( es ) )
        {
            EsSelect( out, es );
            return EsIsSelected( es ) ? VLC_SUCCESS : VLC_EGENERIC;
        }
        else if( !b && EsIsSelected( es ) )
        {
            EsUnselect( out, es, es->p_pgrm == p_sys->p_pgrm );
            return VLC_SUCCESS;
        }
        return VLC_SUCCESS;
    }

    case ES_OUT_GET_ES_STATE:
    {
        es_out_id_t *es = va_arg( args, es_out_id_t * );
        bool *pb = va_arg( args, bool * );

        *pb = EsIsSelected( es );
        return VLC_SUCCESS;
    }

    case ES_OUT_SET_ES_CAT_POLICY:
    {
        enum es_format_category_e i_cat = va_arg( args, enum es_format_category_e );
        enum es_out_policy_e i_pol =...",1,20,input\es_out.c,EsOutControlLocked,,false,2270,2921,EsOutControlLocked,,,88,"int EsOutControlLocked (es_out_t*,int,va_list)"
44846,METHOD,input\es_out.c:<global>,TYPE_DECL,"static int EsOutControl( es_out_t *out, int i_query, va_list args )
{
    es_out_sys_t *p_sys = out->p_sys;
    int i_ret;

    vlc_mutex_lock( &p_sys->lock );
    i_ret = EsOutControlLocked( out, i_query, args );
    vlc_mutex_unlock( &p_sys->lock );

    return i_ret;
}",1,1,input\es_out.c,EsOutControl,,false,2922,2932,EsOutControl,,,89,"int EsOutControl (es_out_t*,int,va_list)"
44878,METHOD,input\es_out.c:<global>,TYPE_DECL,"static char *LanguageGetName( const char *psz_code )
{
    const iso639_lang_t *pl;

    if( psz_code == NULL || !strcmp( psz_code, ""und"" ) )
    {
        return strdup( """" );
    }

    if( strlen( psz_code ) == 2 )
    {
        pl = GetLang_1( psz_code );
    }
    else if( strlen( psz_code ) == 3 )
    {
        pl = GetLang_2B( psz_code );
        if( !strcmp( pl->psz_iso639_1, ""??"" ) )
        {
            pl = GetLang_2T( psz_code );
        }
    }
    else
    {
        char *lang = LanguageGetCode( psz_code );
        pl = GetLang_1( lang );
        free( lang );
    }

    if( !strcmp( pl->psz_iso639_1, ""??"" ) )
    {
       return strdup( psz_code );
    }
    else
    {
        return strdup( vlc_gettext(pl->psz_eng_name) );
    }
}",1,1,input\es_out.c,LanguageGetName,,false,2937,2973,LanguageGetName,,,90,char* LanguageGetName (char*)
44963,METHOD,input\es_out.c:<global>,TYPE_DECL,"static char *LanguageGetCode( const char *psz_lang )
{
    const iso639_lang_t *pl;

    if( psz_lang == NULL || *psz_lang == '\0' )
        return strdup(""??"");

    for( pl = p_languages; pl->psz_eng_name != NULL; pl++ )
    {
        if( !strcasecmp( pl->psz_eng_name, psz_lang ) ||
            !strcasecmp( pl->psz_iso639_1, psz_lang ) ||
            !strcasecmp( pl->psz_iso639_2T, psz_lang ) ||
            !strcasecmp( pl->psz_iso639_2B, psz_lang ) )
            return strdup( pl->psz_iso639_1 );
    }

    return strdup(""??"");
}",1,1,input\es_out.c,LanguageGetCode,,false,2976,2993,LanguageGetCode,,,91,char* LanguageGetCode (char*)
45032,METHOD,input\es_out.c:<global>,TYPE_DECL,"static char **LanguageSplit( const char *psz_langs )
{
    char *psz_dup;
    char *psz_parser;
    char **ppsz = NULL;
    int i_psz = 0;

    if( psz_langs == NULL ) return NULL;

    psz_parser = psz_dup = strdup(psz_langs);

    while( psz_parser && *psz_parser )
    {
        char *psz;
        char *psz_code;

        psz = strchr(psz_parser, ',' );
        if( psz ) *psz++ = '\0';

        if( !strcmp( psz_parser, ""any"" ) )
        {
            TAB_APPEND( i_psz, ppsz, strdup(""any"") );
        }
        else if( !strcmp( psz_parser, ""none"" ) )
        {
            TAB_APPEND( i_psz, ppsz, strdup(""none"") );
        }
        else
        {
            psz_code = LanguageGetCode( psz_parser );
            if( strcmp( psz_code, ""??"" ) )
            {
                TAB_APPEND( i_psz, ppsz, psz_code );
            }
            else
            {
                free( psz_code );
            }
        }

        psz_parser = psz;
    }

    if( i_psz )
    {
        TAB_APPEND...",1,1,input\es_out.c,LanguageSplit,,false,2995,3045,LanguageSplit,,,92,char** LanguageSplit (char*)
45138,METHOD,input\es_out.c:<global>,TYPE_DECL,"static int LanguageArrayIndex( char **ppsz_langs, const char *psz_lang )
{
    if( !ppsz_langs || !psz_lang )
        return -1;

    for( int i = 0; ppsz_langs[i]; i++ )
    {
        if( !strcasecmp( ppsz_langs[i], psz_lang ) ||
            ( !strcasecmp( ppsz_langs[i], ""any"" ) && strcasecmp( psz_lang, ""none"") ) )
            return i;
        if( !strcasecmp( ppsz_langs[i], ""none"" ) )
            break;
    }

    return -1;
}",1,1,input\es_out.c,LanguageArrayIndex,,false,3047,3062,LanguageArrayIndex,,,93,"int LanguageArrayIndex (char**,char*)"
45199,METHOD,input\es_out.c:<global>,TYPE_DECL,"static void EsOutUpdateInfo( es_out_t *out, es_out_id_t *es, const es_format_t *fmt, const vlc_meta_t *p_meta )
{
    es_out_sys_t   *p_sys = out->p_sys;
    input_thread_t *p_input = p_sys->p_input;
    const es_format_t *p_fmt_es = &es->fmt;
    lldiv_t         div;

    if( es->fmt.i_cat == fmt->i_cat )
    {
        es_format_t update = *fmt;
        update.i_id = es->i_meta_id;
        update.i_codec = es->fmt.i_codec;
        update.i_original_fourcc = es->fmt.i_original_fourcc;

        /* Update infos that could have been lost by the decoder (no need to
         * dup them since input_item_UpdateTracksInfo() will do it). */
        if (update.psz_language == NULL)
            update.psz_language = es->fmt.psz_language;
        if (update.psz_description == NULL)
            update.psz_description = es->fmt.psz_description;
        if (update.i_cat == SPU_ES)
        {
            if (update.subs.psz_encoding == NULL)
                update.subs.psz_encoding = es->fmt.subs.ps...",1,1,input\es_out.c,EsOutUpdateInfo,,false,3068,3407,EsOutUpdateInfo,,,94,"void EsOutUpdateInfo (es_out_t*,es_out_id_t*,es_format_t*,vlc_meta_t*)"
46630,METHOD,input\es_out.c:<global>,TYPE_DECL,"static void EsDeleteInfo( es_out_t *out, es_out_id_t *es )
{
    char* psz_info_category;

    if( likely( psz_info_category = EsInfoCategoryName( es ) ) )
    {
        input_Control( out->p_sys->p_input, INPUT_DEL_INFO,
          psz_info_category, NULL );

        free( psz_info_category );
    }
}",1,1,input\es_out.c,EsDeleteInfo,,false,3409,3420,EsDeleteInfo,,,95,"void EsDeleteInfo (es_out_t*,es_out_id_t*)"
46660,METHOD,input\es_out.h:<global>,TYPE_DECL,<global>,1,6,input\es_out.h,input\es_out.h:<global>,,false,1,179,<global>,,,1,
46688,METHOD,<empty>,<empty>,<empty>,1,,input\es_out.h,es_out_query_private_e:<clinit>,,false,39,,<clinit>,,,20,
46695,METHOD,input\es_out.h:<global>,TYPE_DECL,"static inline void es_out_SetMode( es_out_t *p_out, int i_mode )
{
    int i_ret = es_out_Control( p_out, ES_OUT_SET_MODE, i_mode );
    assert( !i_ret );
}",1,1,input\es_out.h,es_out_SetMode,,false,93,97,es_out_SetMode,,,3,"void es_out_SetMode (es_out_t*,int)"
46711,METHOD,input\es_out.h:<global>,TYPE_DECL,"static inline mtime_t es_out_GetWakeup( es_out_t *p_out )
{
    mtime_t i_wu;
    int i_ret = es_out_Control( p_out, ES_OUT_GET_WAKE_UP, &i_wu );

    assert( !i_ret );
    return i_wu;
}",1,1,input\es_out.h,es_out_GetWakeup,,false,98,105,es_out_GetWakeup,,,4,mtime_t es_out_GetWakeup (es_out_t*)
46730,METHOD,input\es_out.h:<global>,TYPE_DECL,"static inline bool es_out_GetBuffering( es_out_t *p_out )
{
    bool b;
    int i_ret = es_out_Control( p_out, ES_OUT_GET_BUFFERING, &b );

    assert( !i_ret );
    return b;
}",1,1,input\es_out.h,es_out_GetBuffering,,false,106,113,es_out_GetBuffering,,,5,bool es_out_GetBuffering (es_out_t*)
46749,METHOD,input\es_out.h:<global>,TYPE_DECL,"static inline bool es_out_GetEmpty( es_out_t *p_out )
{
    bool b;
    int i_ret = es_out_Control( p_out, ES_OUT_GET_EMPTY, &b );

    assert( !i_ret );
    return b;
}",1,1,input\es_out.h,es_out_GetEmpty,,false,114,121,es_out_GetEmpty,,,6,bool es_out_GetEmpty (es_out_t*)
46768,METHOD,input\es_out.h:<global>,TYPE_DECL,"static inline void es_out_SetDelay( es_out_t *p_out, int i_cat, mtime_t i_delay )
{
    int i_ret = es_out_Control( p_out, ES_OUT_SET_DELAY, i_cat, i_delay );
    assert( !i_ret );
}",1,1,input\es_out.h,es_out_SetDelay,,false,122,126,es_out_SetDelay,,,7,"void es_out_SetDelay (es_out_t*,int,mtime_t)"
46786,METHOD,input\es_out.h:<global>,TYPE_DECL,"static inline int es_out_SetRecordState( es_out_t *p_out, bool b_record )
{
    return es_out_Control( p_out, ES_OUT_SET_RECORD_STATE, b_record );
}",1,1,input\es_out.h,es_out_SetRecordState,,false,127,130,es_out_SetRecordState,,,8,"int es_out_SetRecordState (es_out_t*,bool)"
46797,METHOD,input\es_out.h:<global>,TYPE_DECL,"static inline int es_out_SetPauseState( es_out_t *p_out, bool b_source_paused, bool b_paused, mtime_t i_date )
{
    return es_out_Control( p_out, ES_OUT_SET_PAUSE_STATE, b_source_paused, b_paused, i_date );
}",1,1,input\es_out.h,es_out_SetPauseState,,false,131,134,es_out_SetPauseState,,,9,"int es_out_SetPauseState (es_out_t*,bool,bool,mtime_t)"
46812,METHOD,input\es_out.h:<global>,TYPE_DECL,"static inline int es_out_SetRate( es_out_t *p_out, int i_source_rate, int i_rate )
{
    return es_out_Control( p_out, ES_OUT_SET_RATE, i_source_rate, i_rate );
}",1,1,input\es_out.h,es_out_SetRate,,false,135,138,es_out_SetRate,,,10,"int es_out_SetRate (es_out_t*,int,int)"
46825,METHOD,input\es_out.h:<global>,TYPE_DECL,"static inline int es_out_SetTime( es_out_t *p_out, mtime_t i_date )
{
    return es_out_Control( p_out, ES_OUT_SET_TIME, i_date );
}",1,1,input\es_out.h,es_out_SetTime,,false,139,142,es_out_SetTime,,,11,"int es_out_SetTime (es_out_t*,mtime_t)"
46836,METHOD,input\es_out.h:<global>,TYPE_DECL,"static inline int es_out_SetFrameNext( es_out_t *p_out )
{
    return es_out_Control( p_out, ES_OUT_SET_FRAME_NEXT );
}",1,1,input\es_out.h,es_out_SetFrameNext,,false,143,146,es_out_SetFrameNext,,,12,int es_out_SetFrameNext (es_out_t*)
46845,METHOD,input\es_out.h:<global>,TYPE_DECL,"static inline void es_out_SetTimes( es_out_t *p_out, double f_position, mtime_t i_time, mtime_t i_length )
{
    int i_ret = es_out_Control( p_out, ES_OUT_SET_TIMES, f_position, i_time, i_length );
    assert( !i_ret );
}",1,1,input\es_out.h,es_out_SetTimes,,false,147,151,es_out_SetTimes,,,13,"void es_out_SetTimes (es_out_t*,double,mtime_t,mtime_t)"
46865,METHOD,input\es_out.h:<global>,TYPE_DECL,"static inline void es_out_SetJitter( es_out_t *p_out,
                                     mtime_t i_pts_delay, mtime_t i_pts_jitter, int i_cr_average )
{
    int i_ret = es_out_Control( p_out, ES_OUT_SET_JITTER,
                                i_pts_delay, i_pts_jitter, i_cr_average );
    assert( !i_ret );
}",1,1,input\es_out.h,es_out_SetJitter,,false,152,158,es_out_SetJitter,,,14,"void es_out_SetJitter (es_out_t*,mtime_t,mtime_t,int)"
46885,METHOD,input\es_out.h:<global>,TYPE_DECL,"static inline int es_out_GetEsObjects( es_out_t *p_out, int i_id,
                                       vlc_object_t **pp_decoder, vout_thread_t **pp_vout, audio_output_t **pp_aout )
{
    return es_out_Control( p_out, ES_OUT_GET_ES_OBJECTS_BY_ID, i_id, pp_decoder, pp_vout, pp_aout );
}",1,1,input\es_out.h,es_out_GetEsObjects,,false,159,163,es_out_GetEsObjects,,,15,"int es_out_GetEsObjects (es_out_t*,int,vlc_object_t**,vout_thread_t**,audio_output_t**)"
46902,METHOD,input\es_out.h:<global>,TYPE_DECL,"static inline int es_out_GetGroupForced( es_out_t *p_out )
{
    int i_group;
    int i_ret = es_out_Control( p_out, ES_OUT_GET_GROUP_FORCED, &i_group );
    assert( !i_ret );
    return i_group;
}",1,1,input\es_out.h,es_out_GetGroupForced,,false,164,170,es_out_GetGroupForced,,,16,int es_out_GetGroupForced (es_out_t*)
46921,METHOD,input\es_out.h:<global>,TYPE_DECL,"static inline void es_out_Eos( es_out_t *p_out )
{
    int i_ret = es_out_Control( p_out, ES_OUT_SET_EOS );
    assert( !i_ret );
}",1,1,input\es_out.h,es_out_Eos,,false,171,175,es_out_Eos,,,17,void es_out_Eos (es_out_t*)
46935,METHOD,input\es_out.h:<global>,TYPE_DECL,"es_out_t  *input_EsOutNew( input_thread_t *, int i_rate );",11,57,input\es_out.h,input_EsOutNew,,false,177,177,input_EsOutNew,,,18,"es_out_t* input_EsOutNew (input_thread_t*,int)"
46978,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,<global>,1,23,input\es_out_timeshift.c,input\es_out_timeshift.c:<global>,,false,1,1669,<global>,,,1,
47102,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static es_out_id_t *Add    ( es_out_t *, const es_format_t * );",20,62,input\es_out_timeshift.c,Add,,false,250,250,Add,,,19,"es_out_id_t* Add (es_out_t*,es_format_t*)"
47108,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static int          Send   ( es_out_t *, es_out_id_t *, block_t * );",21,67,input\es_out_timeshift.c,Send,,false,251,251,Send,,,20,"int Send (es_out_t*,es_out_id_t*,block_t*)"
47115,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static void         Del    ( es_out_t *, es_out_id_t * );",21,56,input\es_out_timeshift.c,Del,,false,252,252,Del,,,21,"void Del (es_out_t*,es_out_id_t*)"
47121,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static int          Control( es_out_t *, int i_query, va_list );",21,63,input\es_out_timeshift.c,Control,,false,253,253,Control,,,22,"int Control (es_out_t*,int,ANY)"
47128,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,static void         Destroy( es_out_t * );,21,41,input\es_out_timeshift.c,Destroy,,false,254,254,Destroy,,,23,void Destroy (es_out_t*)
47133,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,static int          TsStart( es_out_t * );,21,41,input\es_out_timeshift.c,TsStart,,false,256,256,TsStart,,,24,int TsStart (es_out_t*)
47138,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,static void         TsAutoStop( es_out_t * );,21,44,input\es_out_timeshift.c,TsAutoStop,,false,257,257,TsAutoStop,,,25,void TsAutoStop (es_out_t*)
47143,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,static void         TsStop( ts_thread_t * );,21,43,input\es_out_timeshift.c,TsStop,,false,259,259,TsStop,,,26,void TsStop (ts_thread_t*)
47148,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static void         TsPushCmd( ts_thread_t *, ts_cmd_t * );",21,58,input\es_out_timeshift.c,TsPushCmd,,false,260,260,TsPushCmd,,,27,"void TsPushCmd (ts_thread_t*,ts_cmd_t*)"
47154,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static int          TsPopCmdLocked( ts_thread_t *, ts_cmd_t *, bool b_flush );",21,77,input\es_out_timeshift.c,TsPopCmdLocked,,false,261,261,TsPopCmdLocked,,,28,"int TsPopCmdLocked (ts_thread_t*,ts_cmd_t*,bool)"
47161,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,static bool         TsHasCmd( ts_thread_t * );,21,45,input\es_out_timeshift.c,TsHasCmd,,false,262,262,TsHasCmd,,,29,bool TsHasCmd (ts_thread_t*)
47166,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,static bool         TsIsUnused( ts_thread_t * );,21,47,input\es_out_timeshift.c,TsIsUnused,,false,263,263,TsIsUnused,,,30,bool TsIsUnused (ts_thread_t*)
47171,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static int          TsChangePause( ts_thread_t *, bool b_source_paused, bool b_paused, mtime_t i_date );",21,103,input\es_out_timeshift.c,TsChangePause,,false,264,264,TsChangePause,,,31,"int TsChangePause (ts_thread_t*,bool,bool,mtime_t)"
47179,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static int          TsChangeRate( ts_thread_t *, int i_src_rate, int i_rate );",21,77,input\es_out_timeshift.c,TsChangeRate,,false,265,265,TsChangeRate,,,32,"int TsChangeRate (ts_thread_t*,int,int)"
47186,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,static void         *TsRun( void * );,21,36,input\es_out_timeshift.c,TsRun,,false,267,267,TsRun,,,33,void* TsRun (void*)
47191,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static ts_storage_t *TsStorageNew( const char *psz_path, int64_t i_tmp_size_max );",21,81,input\es_out_timeshift.c,TsStorageNew,,false,269,269,TsStorageNew,,,34,"ts_storage_t* TsStorageNew (char*,int64_t)"
47197,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,static void         TsStorageDelete( ts_storage_t * );,21,53,input\es_out_timeshift.c,TsStorageDelete,,false,270,270,TsStorageDelete,,,35,void TsStorageDelete (ts_storage_t*)
47202,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,static void         TsStoragePack( ts_storage_t *p_storage );,21,60,input\es_out_timeshift.c,TsStoragePack,,false,271,271,TsStoragePack,,,36,void TsStoragePack (ts_storage_t*)
47207,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static bool         TsStorageIsFull( ts_storage_t *, const ts_cmd_t *p_cmd );",21,76,input\es_out_timeshift.c,TsStorageIsFull,,false,272,272,TsStorageIsFull,,,37,"bool TsStorageIsFull (ts_storage_t*,ts_cmd_t*)"
47213,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,static bool         TsStorageIsEmpty( ts_storage_t * );,21,54,input\es_out_timeshift.c,TsStorageIsEmpty,,false,273,273,TsStorageIsEmpty,,,38,bool TsStorageIsEmpty (ts_storage_t*)
47218,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static void         TsStoragePushCmd( ts_storage_t *, const ts_cmd_t *p_cmd, bool b_flush );",21,91,input\es_out_timeshift.c,TsStoragePushCmd,,false,274,274,TsStoragePushCmd,,,39,"void TsStoragePushCmd (ts_storage_t*,ts_cmd_t*,bool)"
47225,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static void         TsStoragePopCmd( ts_storage_t *p_storage, ts_cmd_t *p_cmd, bool b_flush );",21,93,input\es_out_timeshift.c,TsStoragePopCmd,,false,275,275,TsStoragePopCmd,,,40,"void TsStoragePopCmd (ts_storage_t*,ts_cmd_t*,bool)"
47232,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,static void CmdClean( ts_cmd_t * );,13,34,input\es_out_timeshift.c,CmdClean,,false,277,277,CmdClean,,,41,void CmdClean (ts_cmd_t*)
47237,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,static void cmd_cleanup_routine( void *p ) { CmdClean( p ); },1,61,input\es_out_timeshift.c,cmd_cleanup_routine,,false,278,278,cmd_cleanup_routine,,,42,void cmd_cleanup_routine (void*)
47244,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static int  CmdInitAdd    ( ts_cmd_t *, es_out_id_t *, const es_format_t *, bool b_copy );",13,89,input\es_out_timeshift.c,CmdInitAdd,,false,280,280,CmdInitAdd,,,43,"int CmdInitAdd (ts_cmd_t*,es_out_id_t*,es_format_t*,bool)"
47252,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static void CmdInitSend   ( ts_cmd_t *, es_out_id_t *, block_t * );",13,66,input\es_out_timeshift.c,CmdInitSend,,false,281,281,CmdInitSend,,,44,"void CmdInitSend (ts_cmd_t*,es_out_id_t*,block_t*)"
47259,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static int  CmdInitDel    ( ts_cmd_t *, es_out_id_t * );",13,55,input\es_out_timeshift.c,CmdInitDel,,false,282,282,CmdInitDel,,,45,"int CmdInitDel (ts_cmd_t*,es_out_id_t*)"
47265,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static int  CmdInitControl( ts_cmd_t *, int i_query, va_list, bool b_copy );",13,75,input\es_out_timeshift.c,CmdInitControl,,false,283,283,CmdInitControl,,,46,"int CmdInitControl (ts_cmd_t*,int,ANY,bool)"
47273,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,static void CmdCleanAdd    ( ts_cmd_t * );,13,41,input\es_out_timeshift.c,CmdCleanAdd,,false,286,286,CmdCleanAdd,,,47,void CmdCleanAdd (ts_cmd_t*)
47278,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,static void CmdCleanSend   ( ts_cmd_t * );,13,41,input\es_out_timeshift.c,CmdCleanSend,,false,287,287,CmdCleanSend,,,48,void CmdCleanSend (ts_cmd_t*)
47283,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,static void CmdCleanControl( ts_cmd_t *p_cmd );,13,46,input\es_out_timeshift.c,CmdCleanControl,,false,288,288,CmdCleanControl,,,49,void CmdCleanControl (ts_cmd_t*)
47288,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static void CmdExecuteAdd    ( es_out_t *, ts_cmd_t * );",13,55,input\es_out_timeshift.c,CmdExecuteAdd,,false,291,291,CmdExecuteAdd,,,50,"void CmdExecuteAdd (es_out_t*,ts_cmd_t*)"
47294,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static int  CmdExecuteSend   ( es_out_t *, ts_cmd_t * );",13,55,input\es_out_timeshift.c,CmdExecuteSend,,false,292,292,CmdExecuteSend,,,51,"int CmdExecuteSend (es_out_t*,ts_cmd_t*)"
47300,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static void CmdExecuteDel    ( es_out_t *, ts_cmd_t * );",13,55,input\es_out_timeshift.c,CmdExecuteDel,,false,293,293,CmdExecuteDel,,,52,"void CmdExecuteDel (es_out_t*,ts_cmd_t*)"
47306,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static int  CmdExecuteControl( es_out_t *, ts_cmd_t * );",13,55,input\es_out_timeshift.c,CmdExecuteControl,,false,294,294,CmdExecuteControl,,,53,"int CmdExecuteControl (es_out_t*,ts_cmd_t*)"
47312,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static int GetTmpFile( char **ppsz_file, const char *psz_path );",12,63,input\es_out_timeshift.c,GetTmpFile,,false,297,297,GetTmpFile,,,54,"int GetTmpFile (char**,char*)"
47318,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"es_out_t *input_EsOutTimeshiftNew( input_thread_t *p_input, es_out_t *p_next_out, int i_rate )
{
    es_out_t *p_out = malloc( sizeof(*p_out) );
    if( !p_out )
        return NULL;

    es_out_sys_t *p_sys = malloc( sizeof(*p_sys) );
    if( !p_sys )
    {
        free( p_out );
        return NULL;
    }

    /* */
    p_out->pf_add     = Add;
    p_out->pf_send    = Send;
    p_out->pf_del     = Del;
    p_out->pf_control = Control;
    p_out->pf_destroy = Destroy;
    p_out->p_sys      = p_sys;

    /* */
    p_sys->b_input_paused = false;
    p_sys->b_input_paused_source = false;
    p_sys->p_input = p_input;
    p_sys->i_input_rate = i_rate;
    p_sys->i_input_rate_source = i_rate;

    p_sys->p_out = p_next_out;
    vlc_mutex_init_recursive( &p_sys->lock );

    p_sys->b_delayed = false;
    p_sys->p_ts = NULL;

    TAB_INIT( p_sys->i_es, p_sys->pp_es );

    /* */
    const int i_tmp_size_max = var_CreateGetInteger( p_input, ""input-timeshift-granularity"" );
    if( i_tmp_si...",1,1,input\es_out_timeshift.c,input_EsOutTimeshiftNew,,false,302,402,input_EsOutTimeshiftNew,,,55,"es_out_t input_EsOutTimeshiftNew (input_thread_t*,es_out_t*,int)"
47507,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static void Destroy( es_out_t *p_out )
{
    es_out_sys_t *p_sys = p_out->p_sys;

    if( p_sys->b_delayed )
    {
        TsStop( p_sys->p_ts );
        p_sys->b_delayed = false;
    }

    while( p_sys->i_es > 0 )
        Del( p_out, p_sys->pp_es[0] );
    TAB_CLEAN( p_sys->i_es, p_sys->pp_es  );

    free( p_sys->psz_tmp_path );
    vlc_mutex_destroy( &p_sys->lock );
    free( p_sys );
    free( p_out );
}",1,1,input\es_out_timeshift.c,Destroy,,false,407,425,Destroy,,,56,void Destroy (es_out_t*)
47565,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static es_out_id_t *Add( es_out_t *p_out, const es_format_t *p_fmt )
{
    es_out_sys_t *p_sys = p_out->p_sys;
    ts_cmd_t cmd;

    es_out_id_t *p_es = malloc( sizeof( *p_es ) );
    if( !p_es )
        return NULL;

    vlc_mutex_lock( &p_sys->lock );

    TsAutoStop( p_out );

    if( CmdInitAdd( &cmd, p_es, p_fmt, p_sys->b_delayed ) )
    {
        vlc_mutex_unlock( &p_sys->lock );
        free( p_es );
        return NULL;
    }

    TAB_APPEND( p_sys->i_es, p_sys->pp_es, p_es );

    if( p_sys->b_delayed )
        TsPushCmd( p_sys->p_ts, &cmd );
    else
        CmdExecuteAdd( p_sys->p_out, &cmd );

    vlc_mutex_unlock( &p_sys->lock );

    return p_es;
}",1,1,input\es_out_timeshift.c,Add,,false,427,457,Add,,,57,"es_out_id_t Add (es_out_t*,es_format_t*)"
47651,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static int Send( es_out_t *p_out, es_out_id_t *p_es, block_t *p_block )
{
    es_out_sys_t *p_sys = p_out->p_sys;
    ts_cmd_t cmd;
    int i_ret = VLC_SUCCESS;

    vlc_mutex_lock( &p_sys->lock );

    TsAutoStop( p_out );

    CmdInitSend( &cmd, p_es, p_block );
    if( p_sys->b_delayed )
        TsPushCmd( p_sys->p_ts, &cmd );
    else
        i_ret = CmdExecuteSend( p_sys->p_out, &cmd) ;

    vlc_mutex_unlock( &p_sys->lock );

    return i_ret;
}",1,1,input\es_out_timeshift.c,Send,,false,458,477,Send,,,58,"int Send (es_out_t*,es_out_id_t*,block_t*)"
47709,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static void Del( es_out_t *p_out, es_out_id_t *p_es )
{
    es_out_sys_t *p_sys = p_out->p_sys;
    ts_cmd_t cmd;

    vlc_mutex_lock( &p_sys->lock );

    TsAutoStop( p_out );

    CmdInitDel( &cmd, p_es );
    if( p_sys->b_delayed )
        TsPushCmd( p_sys->p_ts, &cmd );
    else
        CmdExecuteDel( p_sys->p_out, &cmd );

    TAB_REMOVE( p_sys->i_es, p_sys->pp_es, p_es );

    vlc_mutex_unlock( &p_sys->lock );
}",1,1,input\es_out_timeshift.c,Del,,false,478,496,Del,,,59,"void Del (es_out_t*,es_out_id_t*)"
47765,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static int ControlLockedGetEmpty( es_out_t *p_out, bool *pb_empty )
{
    es_out_sys_t *p_sys = p_out->p_sys;

    if( p_sys->b_delayed && TsHasCmd( p_sys->p_ts ) )
        *pb_empty = false;
    else
        *pb_empty = es_out_GetEmpty( p_sys->p_out );

    return VLC_SUCCESS;
}",1,1,input\es_out_timeshift.c,ControlLockedGetEmpty,,false,498,508,ControlLockedGetEmpty,,,60,"int ControlLockedGetEmpty (es_out_t*,bool*)"
47802,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static int ControlLockedGetWakeup( es_out_t *p_out, mtime_t *pi_wakeup )
{
    es_out_sys_t *p_sys = p_out->p_sys;

    if( p_sys->b_delayed )
    {
        assert( !input_priv(p_sys->p_input)->b_can_pace_control );
        *pi_wakeup = 0;
    }
    else
    {
        *pi_wakeup = es_out_GetWakeup( p_sys->p_out );
    }

    return VLC_SUCCESS;
}",1,1,input\es_out_timeshift.c,ControlLockedGetWakeup,,false,509,524,ControlLockedGetWakeup,,,61,"int ControlLockedGetWakeup (es_out_t*,mtime_t*)"
47842,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static int ControlLockedGetBuffering( es_out_t *p_out, bool *pb_buffering )
{
    es_out_sys_t *p_sys = p_out->p_sys;

    if( p_sys->b_delayed )
        *pb_buffering = true;
    else
        *pb_buffering = es_out_GetBuffering( p_sys->p_out );

    return VLC_SUCCESS;
}",1,1,input\es_out_timeshift.c,ControlLockedGetBuffering,,false,525,535,ControlLockedGetBuffering,,,62,"int ControlLockedGetBuffering (es_out_t*,bool*)"
47874,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static int ControlLockedSetPauseState( es_out_t *p_out, bool b_source_paused, bool b_paused, mtime_t i_date )
{
    es_out_sys_t *p_sys = p_out->p_sys;
    int i_ret;

    if( !p_sys->b_delayed && !b_source_paused == !b_paused )
    {
        i_ret = es_out_SetPauseState( p_sys->p_out, b_source_paused, b_paused, i_date );
    }
    else
    {
        i_ret = VLC_EGENERIC;
        if( !input_priv(p_sys->p_input)->b_can_pace_control )
        {
            if( !p_sys->b_delayed )
                TsStart( p_out );
            if( p_sys->b_delayed )
                i_ret = TsChangePause( p_sys->p_ts, b_source_paused, b_paused, i_date );
        }
        else
        {
            /* XXX we may do it BUT it would be better to finish the clock clean up+improvements
             * and so be able to advertize correctly pace control property in access
             * module */
            msg_Err( p_sys->p_input, ""EsOutTimeshift does not work with streams that have pace control"" );
        }...",1,1,input\es_out_timeshift.c,ControlLockedSetPauseState,,false,536,570,ControlLockedSetPauseState,,,63,"int ControlLockedSetPauseState (es_out_t*,bool,bool,mtime_t)"
47969,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static int ControlLockedSetRate( es_out_t *p_out, int i_src_rate, int i_rate )
{
    es_out_sys_t *p_sys = p_out->p_sys;
    int i_ret;

    if( !p_sys->b_delayed && i_src_rate == i_rate )
    {
        i_ret = es_out_SetRate( p_sys->p_out, i_src_rate, i_rate );
    }
    else
    {
        i_ret = VLC_EGENERIC;
        if( !input_priv(p_sys->p_input)->b_can_pace_control )
        {
            if( !p_sys->b_delayed )
                TsStart( p_out );
            if( p_sys->b_delayed )
                i_ret = TsChangeRate( p_sys->p_ts, i_src_rate, i_rate );
        }
        else
        {
            /* XXX we may do it BUT it would be better to finish the clock clean up+improvements
             * and so be able to advertize correctly pace control property in access
             * module */
            msg_Err( p_sys->p_input, ""EsOutTimeshift does not work with streams that have pace control"" );
        }

    }

    if( !i_ret )
    {
        p_sys->i_input_rate_source = i_src_ra...",1,1,input\es_out_timeshift.c,ControlLockedSetRate,,false,571,606,ControlLockedSetRate,,,64,"int ControlLockedSetRate (es_out_t*,int,int)"
48059,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static int ControlLockedSetTime( es_out_t *p_out, mtime_t i_date )
{
    es_out_sys_t *p_sys = p_out->p_sys;

    if( !p_sys->b_delayed )
        return es_out_SetTime( p_sys->p_out, i_date );

    /* TODO */
    msg_Err( p_sys->p_input, ""EsOutTimeshift does not yet support time change"" );
    return VLC_EGENERIC;
}",1,1,input\es_out_timeshift.c,ControlLockedSetTime,,false,607,617,ControlLockedSetTime,,,65,"int ControlLockedSetTime (es_out_t*,mtime_t)"
48090,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static int ControlLockedSetFrameNext( es_out_t *p_out )
{
    es_out_sys_t *p_sys = p_out->p_sys;

    return es_out_SetFrameNext( p_sys->p_out );
}",1,1,input\es_out_timeshift.c,ControlLockedSetFrameNext,,false,618,623,ControlLockedSetFrameNext,,,66,int ControlLockedSetFrameNext (es_out_t*)
48106,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static int ControlLocked( es_out_t *p_out, int i_query, va_list args )
{
    es_out_sys_t *p_sys = p_out->p_sys;

    switch( i_query )
    {
    /* Pass-through control */
    case ES_OUT_SET_MODE:
    case ES_OUT_SET_GROUP:
    case ES_OUT_SET_PCR:
    case ES_OUT_SET_GROUP_PCR:
    case ES_OUT_RESET_PCR:
    case ES_OUT_SET_NEXT_DISPLAY_TIME:
    case ES_OUT_SET_GROUP_META:
    case ES_OUT_SET_GROUP_EPG:
    case ES_OUT_SET_GROUP_EPG_EVENT:
    case ES_OUT_SET_EPG_TIME:
    case ES_OUT_SET_ES_SCRAMBLED_STATE:
    case ES_OUT_DEL_GROUP:
    case ES_OUT_SET_META:
    case ES_OUT_SET_ES:
    case ES_OUT_RESTART_ES:
    case ES_OUT_RESTART_ALL_ES:
    case ES_OUT_SET_ES_DEFAULT:
    case ES_OUT_SET_ES_STATE:
    case ES_OUT_SET_ES_CAT_POLICY:
    case ES_OUT_SET_ES_FMT:
    case ES_OUT_SET_TIMES:
    case ES_OUT_SET_JITTER:
    case ES_OUT_SET_EOS:
    {
        ts_cmd_t cmd;
        if( CmdInitControl( &cmd, i_query, args, p_sys->b_delayed ) )
            return VLC_EGENERIC;
      ...",1,1,input\es_out_timeshift.c,ControlLocked,,false,625,754,ControlLocked,,,67,"int ControlLocked (es_out_t*,int,va_list)"
48380,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static int Control( es_out_t *p_out, int i_query, va_list args )
{
    es_out_sys_t *p_sys = p_out->p_sys;
    int i_ret;

    vlc_mutex_lock( &p_sys->lock );

    TsAutoStop( p_out );

    i_ret = ControlLocked( p_out, i_query, args );

    vlc_mutex_unlock( &p_sys->lock );

    return i_ret;
}",1,1,input\es_out_timeshift.c,Control,,false,755,769,Control,,,68,"int Control (es_out_t*,int,va_list)"
48414,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static void TsDestroy( ts_thread_t *p_ts )
{
    vlc_cond_destroy( &p_ts->wait );
    vlc_mutex_destroy( &p_ts->lock );
    free( p_ts );
}",1,1,input\es_out_timeshift.c,TsDestroy,,false,774,779,TsDestroy,,,69,void TsDestroy (ts_thread_t*)
48431,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static int TsStart( es_out_t *p_out )
{
    es_out_sys_t *p_sys = p_out->p_sys;
    ts_thread_t *p_ts;

    assert( !p_sys->b_delayed );

    p_sys->p_ts = p_ts = calloc(1, sizeof(*p_ts));
    if( !p_ts )
        return VLC_EGENERIC;

    p_ts->i_tmp_size_max = p_sys->i_tmp_size_max;
    p_ts->psz_tmp_path = p_sys->psz_tmp_path;
    p_ts->p_input = p_sys->p_input;
    p_ts->p_out = p_sys->p_out;
    vlc_mutex_init( &p_ts->lock );
    vlc_cond_init( &p_ts->wait );
    p_ts->b_paused = p_sys->b_input_paused && !p_sys->b_input_paused_source;
    p_ts->i_pause_date = p_ts->b_paused ? mdate() : -1;
    p_ts->i_rate_source = p_sys->i_input_rate_source;
    p_ts->i_rate        = p_sys->i_input_rate;
    p_ts->i_rate_date = -1;
    p_ts->i_rate_delay = 0;
    p_ts->i_buffering_delay = 0;
    p_ts->i_cmd_delay = 0;
    p_ts->p_storage_r = NULL;
    p_ts->p_storage_w = NULL;

    p_sys->b_delayed = true;
    if( vlc_clone( &p_ts->thread, TsRun, p_ts, VLC_THREAD_PRIORITY_INPUT ) )
    {
      ...",1,1,input\es_out_timeshift.c,TsStart,,false,780,820,TsStart,,,70,int TsStart (es_out_t*)
48602,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static void TsAutoStop( es_out_t *p_out )
{
    es_out_sys_t *p_sys = p_out->p_sys;

    if( !p_sys->b_delayed || !TsIsUnused( p_sys->p_ts ) )
        return;

    msg_Warn( p_sys->p_input, ""es out timeshift: auto stop"" );
    TsStop( p_sys->p_ts );

    p_sys->b_delayed = false;
}",1,1,input\es_out_timeshift.c,TsAutoStop,,false,821,832,TsAutoStop,,,71,void TsAutoStop (es_out_t*)
48640,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static void TsStop( ts_thread_t *p_ts )
{
    vlc_cancel( p_ts->thread );
    vlc_join( p_ts->thread, NULL );

    vlc_mutex_lock( &p_ts->lock );
    for( ;; )
    {
        ts_cmd_t cmd;

        if( TsPopCmdLocked( p_ts, &cmd, true ) )
            break;

        CmdClean( &cmd );
    }
    assert( !p_ts->p_storage_r || !p_ts->p_storage_r->p_next );
    if( p_ts->p_storage_r )
        TsStorageDelete( p_ts->p_storage_r );
    vlc_mutex_unlock( &p_ts->lock );

    TsDestroy( p_ts );
}",1,1,input\es_out_timeshift.c,TsStop,,false,833,854,TsStop,,,72,void TsStop (ts_thread_t*)
48702,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static void TsPushCmd( ts_thread_t *p_ts, ts_cmd_t *p_cmd )
{
    vlc_mutex_lock( &p_ts->lock );

    if( !p_ts->p_storage_w || TsStorageIsFull( p_ts->p_storage_w, p_cmd ) )
    {
        ts_storage_t *p_storage = TsStorageNew( p_ts->psz_tmp_path, p_ts->i_tmp_size_max );

        if( !p_storage )
        {
            CmdClean( p_cmd );
            vlc_mutex_unlock( &p_ts->lock );
            /* TODO warn the user (but only once) */
            return;
        }

        if( !p_ts->p_storage_w )
        {
            p_ts->p_storage_r = p_ts->p_storage_w = p_storage;
        }
        else
        {
            TsStoragePack( p_ts->p_storage_w );
            p_ts->p_storage_w->p_next = p_storage;
            p_ts->p_storage_w = p_storage;
        }
    }

    /* TODO return error and warn the user (but only once) */
    TsStoragePushCmd( p_ts->p_storage_w, p_cmd, p_ts->p_storage_r == p_ts->p_storage_w );

    vlc_cond_signal( &p_ts->wait );

    vlc_mutex_unlock( &p_ts->lock );
}",1,1,input\es_out_timeshift.c,TsPushCmd,,false,855,889,TsPushCmd,,,73,"void TsPushCmd (ts_thread_t*,ts_cmd_t*)"
48802,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static int TsPopCmdLocked( ts_thread_t *p_ts, ts_cmd_t *p_cmd, bool b_flush )
{
    vlc_assert_locked( &p_ts->lock );

    if( TsStorageIsEmpty( p_ts->p_storage_r ) )
        return VLC_EGENERIC;

    TsStoragePopCmd( p_ts->p_storage_r, p_cmd, b_flush );

    while( TsStorageIsEmpty( p_ts->p_storage_r ) )
    {
        ts_storage_t *p_next = p_ts->p_storage_r->p_next;
        if( !p_next )
            break;

        TsStorageDelete( p_ts->p_storage_r );
        p_ts->p_storage_r = p_next;
    }

    return VLC_SUCCESS;
}",1,1,input\es_out_timeshift.c,TsPopCmdLocked,,false,890,910,TsPopCmdLocked,,,74,"int TsPopCmdLocked (ts_thread_t*,ts_cmd_t*,bool)"
48858,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static bool TsHasCmd( ts_thread_t *p_ts )
{
    bool b_cmd;

    vlc_mutex_lock( &p_ts->lock );
    b_cmd = !TsStorageIsEmpty( p_ts->p_storage_r );
    vlc_mutex_unlock( &p_ts->lock );

    return b_cmd;
}",1,1,input\es_out_timeshift.c,TsHasCmd,,false,911,920,TsHasCmd,,,75,bool TsHasCmd (ts_thread_t*)
48883,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static bool TsIsUnused( ts_thread_t *p_ts )
{
    bool b_unused;

    vlc_mutex_lock( &p_ts->lock );
    b_unused = !p_ts->b_paused &&
               p_ts->i_rate == p_ts->i_rate_source &&
               TsStorageIsEmpty( p_ts->p_storage_r );
    vlc_mutex_unlock( &p_ts->lock );

    return b_unused;
}",1,1,input\es_out_timeshift.c,TsIsUnused,,false,921,932,TsIsUnused,,,76,bool TsIsUnused (ts_thread_t*)
48920,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static int TsChangePause( ts_thread_t *p_ts, bool b_source_paused, bool b_paused, mtime_t i_date )
{
    vlc_mutex_lock( &p_ts->lock );

    int i_ret;
    if( b_paused )
    {
        assert( !b_source_paused );
        i_ret = es_out_SetPauseState( p_ts->p_out, true, true, i_date );
    }
    else
    {
        i_ret = es_out_SetPauseState( p_ts->p_out, false, false, i_date );
    }

    if( !i_ret )
    {
        if( !b_paused )
        {
            assert( p_ts->i_pause_date > 0 );

            p_ts->i_cmd_delay += i_date - p_ts->i_pause_date;
        }

        p_ts->b_paused = b_paused;
        p_ts->i_pause_date = i_date;

        vlc_cond_signal( &p_ts->wait );
    }
    vlc_mutex_unlock( &p_ts->lock );
    return i_ret;
}",1,1,input\es_out_timeshift.c,TsChangePause,,false,933,964,TsChangePause,,,77,"int TsChangePause (ts_thread_t*,bool,bool,mtime_t)"
49005,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static int TsChangeRate( ts_thread_t *p_ts, int i_src_rate, int i_rate )
{
    int i_ret;

    vlc_mutex_lock( &p_ts->lock );
    p_ts->i_cmd_delay += p_ts->i_rate_delay;

    p_ts->i_rate_date = -1;
    p_ts->i_rate_delay = 0;
    p_ts->i_rate = i_rate;
    p_ts->i_rate_source = i_src_rate;

    i_ret = es_out_SetRate( p_ts->p_out, i_rate, i_rate );
    vlc_mutex_unlock( &p_ts->lock );

    return i_ret;
}",1,1,input\es_out_timeshift.c,TsChangeRate,,false,965,981,TsChangeRate,,,78,"int TsChangeRate (ts_thread_t*,int,int)"
49061,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static void *TsRun( void *p_data )
{
    ts_thread_t *p_ts = p_data;
    mtime_t i_buffering_date = -1;

    for( ;; )
    {
        ts_cmd_t cmd;
        mtime_t  i_deadline;
        bool b_buffering;

        /* Pop a command to execute */
        vlc_mutex_lock( &p_ts->lock );
        mutex_cleanup_push( &p_ts->lock );

        for( ;; )
        {
            const int canc = vlc_savecancel();
            b_buffering = es_out_GetBuffering( p_ts->p_out );

            if( ( !p_ts->b_paused || b_buffering ) && !TsPopCmdLocked( p_ts, &cmd, false ) )
            {
                vlc_restorecancel( canc );
                break;
            }
            vlc_restorecancel( canc );

            vlc_cond_wait( &p_ts->wait, &p_ts->lock );
        }

        if( b_buffering && i_buffering_date < 0 )
        {
            i_buffering_date = cmd.i_date;
        }
        else if( i_buffering_date > 0 )
        {
            p_ts->i_buffering_delay += i_buffering_date - cmd.i_date; /* It is...",1,1,input\es_out_timeshift.c,TsRun,,false,983,1100,TsRun,,,79,void* TsRun (void*)
49414,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static ts_storage_t *TsStorageNew( const char *psz_tmp_path, int64_t i_tmp_size_max )
{
    ts_storage_t *p_storage = malloc( sizeof (*p_storage) );
    if( unlikely(p_storage == NULL) )
        return NULL;

    char *psz_file;
    int fd = GetTmpFile( &psz_file, psz_tmp_path );
    if( fd == -1 )
    {
        free( p_storage );
        return NULL;
    }

    p_storage->p_filew = fdopen( fd, ""w+b"" );
    if( p_storage->p_filew == NULL )
    {
        vlc_close( fd );
        vlc_unlink( psz_file );
        goto error;
    }

    p_storage->p_filer = vlc_fopen( psz_file, ""rb"" );
    if( p_storage->p_filer == NULL )
    {
        fclose( p_storage->p_filew );
        vlc_unlink( psz_file );
        goto error;
    }

#ifndef _WIN32
    vlc_unlink( psz_file );
    free( psz_file );
#else
    p_storage->psz_file = psz_file;
#endif
    p_storage->p_next = NULL;

    /* */
    p_storage->i_file_max = i_tmp_size_max;
    p_storage->i_file_size = 0;

    /* */
    p_storage->i_cmd_w = 0;...",1,1,input\es_out_timeshift.c,TsStorageNew,,false,1105,1164,TsStorageNew,,,80,"ts_storage_t TsStorageNew (char*,int64_t)"
49559,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static void TsStorageDelete( ts_storage_t *p_storage )
{
    while( p_storage->i_cmd_r < p_storage->i_cmd_w )
    {
        ts_cmd_t cmd;

        TsStoragePopCmd( p_storage, &cmd, true );

        CmdClean( &cmd );
    }
    free( p_storage->p_cmd );

    fclose( p_storage->p_filer );
    fclose( p_storage->p_filew );
#ifdef _WIN32
    vlc_unlink( p_storage->psz_file );
    free( p_storage->psz_file );
#endif
    free( p_storage );
}",1,1,input\es_out_timeshift.c,TsStorageDelete,,false,1166,1185,TsStorageDelete,,,81,void TsStorageDelete (ts_storage_t*)
49596,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static void TsStoragePack( ts_storage_t *p_storage )
{
    /* Try to release a bit of memory */
    if( p_storage->i_cmd_w >= p_storage->i_cmd_max )
        return;

    p_storage->i_cmd_max = __MAX( p_storage->i_cmd_w, 1 );

    ts_cmd_t *p_new = realloc( p_storage->p_cmd, p_storage->i_cmd_max * sizeof(*p_storage->p_cmd) );
    if( p_new )
        p_storage->p_cmd = p_new;
}",1,1,input\es_out_timeshift.c,TsStoragePack,,false,1187,1198,TsStoragePack,,,82,void TsStoragePack (ts_storage_t*)
49644,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static bool TsStorageIsFull( ts_storage_t *p_storage, const ts_cmd_t *p_cmd )
{
    if( p_cmd && p_cmd->i_type == C_SEND && p_storage->i_cmd_w > 0 )
    {
        size_t i_size = sizeof(*p_cmd->u.send.p_block) + p_cmd->u.send.p_block->i_buffer;

        if( p_storage->i_file_size + i_size >= p_storage->i_file_max )
            return true;
    }
    return p_storage->i_cmd_w >= p_storage->i_cmd_max;
}",1,1,input\es_out_timeshift.c,TsStorageIsFull,,false,1199,1209,TsStorageIsFull,,,83,"bool TsStorageIsFull (ts_storage_t*,ts_cmd_t*)"
49708,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static bool TsStorageIsEmpty( ts_storage_t *p_storage )
{
    return !p_storage || p_storage->i_cmd_r >= p_storage->i_cmd_w;
}",1,1,input\es_out_timeshift.c,TsStorageIsEmpty,,false,1210,1213,TsStorageIsEmpty,,,84,bool TsStorageIsEmpty (ts_storage_t*)
49724,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static void TsStoragePushCmd( ts_storage_t *p_storage, const ts_cmd_t *p_cmd, bool b_flush )
{
    ts_cmd_t cmd = *p_cmd;

    assert( !TsStorageIsFull( p_storage, p_cmd ) );

    if( cmd.i_type == C_SEND )
    {
        block_t *p_block = cmd.u.send.p_block;

        cmd.u.send.p_block = NULL;
        cmd.u.send.i_offset = ftell( p_storage->p_filew );

        if( fwrite( p_block, sizeof(*p_block), 1, p_storage->p_filew ) != 1 )
        {
            block_Release( p_block );
            return;
        }
        p_storage->i_file_size += sizeof(*p_block);
        if( p_block->i_buffer > 0 )
        {
            if( fwrite( p_block->p_buffer, p_block->i_buffer, 1, p_storage->p_filew ) != 1 )
            {
                block_Release( p_block );
                return;
            }
        }
        p_storage->i_file_size += p_block->i_buffer;
        block_Release( p_block );

        if( b_flush )
            fflush( p_storage->p_filew );
    }
    p_storage->p_cmd[p_storage->...",1,1,input\es_out_timeshift.c,TsStoragePushCmd,,false,1214,1248,TsStoragePushCmd,,,85,"void TsStoragePushCmd (ts_storage_t*,ts_cmd_t*,bool)"
49853,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static void TsStoragePopCmd( ts_storage_t *p_storage, ts_cmd_t *p_cmd, bool b_flush )
{
    assert( !TsStorageIsEmpty( p_storage ) );

    *p_cmd = p_storage->p_cmd[p_storage->i_cmd_r++];
    if( p_cmd->i_type == C_SEND )
    {
        block_t block;

        if( !b_flush &&
            !fseek( p_storage->p_filer, p_cmd->u.send.i_offset, SEEK_SET ) &&
            fread( &block, sizeof(block), 1, p_storage->p_filer ) == 1 )
        {
            block_t *p_block = block_Alloc( block.i_buffer );
            if( p_block )
            {
                p_block->i_dts      = block.i_dts;
                p_block->i_pts      = block.i_pts;
                p_block->i_flags    = block.i_flags;
                p_block->i_length   = block.i_length;
                p_block->i_nb_samples = block.i_nb_samples;
                p_block->i_buffer = fread( p_block->p_buffer, 1, block.i_buffer, p_storage->p_filer );
            }
            p_cmd->u.send.p_block = p_block;
        }
        else
    ...",1,1,input\es_out_timeshift.c,TsStoragePopCmd,,false,1249,1280,TsStoragePopCmd,,,86,"void TsStoragePopCmd (ts_storage_t*,ts_cmd_t*,bool)"
49994,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static void CmdClean( ts_cmd_t *p_cmd )
{
    switch( p_cmd->i_type )
    {
    case C_ADD:
        CmdCleanAdd( p_cmd );
        break;
    case C_SEND:
        CmdCleanSend( p_cmd );
        break;
    case C_CONTROL:
        CmdCleanControl( p_cmd );
        break;
    case C_DEL:
        break;
    default:
        vlc_assert_unreachable();
        break;
    }
}",1,1,input\es_out_timeshift.c,CmdClean,,false,1285,1304,CmdClean,,,87,void CmdClean (ts_cmd_t*)
50025,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static int CmdInitAdd( ts_cmd_t *p_cmd, es_out_id_t *p_es, const es_format_t *p_fmt, bool b_copy )
{
    p_cmd->i_type = C_ADD;
    p_cmd->i_date = mdate();
    p_cmd->u.add.p_es = p_es;
    if( b_copy )
    {
        p_cmd->u.add.p_fmt = malloc( sizeof(*p_fmt) );
        if( !p_cmd->u.add.p_fmt )
            return VLC_EGENERIC;
        es_format_Copy( p_cmd->u.add.p_fmt, p_fmt );
    }
    else
    {
        p_cmd->u.add.p_fmt = (es_format_t*)p_fmt;
    }
    return VLC_SUCCESS;
}",1,1,input\es_out_timeshift.c,CmdInitAdd,,false,1306,1323,CmdInitAdd,,,88,"int CmdInitAdd (ts_cmd_t*,es_out_id_t*,es_format_t*,bool)"
50103,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static void CmdExecuteAdd( es_out_t *p_out, ts_cmd_t *p_cmd )
{
    p_cmd->u.add.p_es->p_es = es_out_Add( p_out, p_cmd->u.add.p_fmt );
}",1,1,input\es_out_timeshift.c,CmdExecuteAdd,,false,1324,1327,CmdExecuteAdd,,,89,"void CmdExecuteAdd (es_out_t*,ts_cmd_t*)"
50128,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static void CmdCleanAdd( ts_cmd_t *p_cmd )
{
    es_format_Clean( p_cmd->u.add.p_fmt );
    free( p_cmd->u.add.p_fmt );
}",1,1,input\es_out_timeshift.c,CmdCleanAdd,,false,1328,1332,CmdCleanAdd,,,90,void CmdCleanAdd (ts_cmd_t*)
50149,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static void CmdInitSend( ts_cmd_t *p_cmd, es_out_id_t *p_es, block_t *p_block )
{
    p_cmd->i_type = C_SEND;
    p_cmd->i_date = mdate();
    p_cmd->u.send.p_es = p_es;
    p_cmd->u.send.p_block = p_block;
}",1,1,input\es_out_timeshift.c,CmdInitSend,,false,1334,1340,CmdInitSend,,,91,"void CmdInitSend (ts_cmd_t*,es_out_id_t*,block_t*)"
50184,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static int CmdExecuteSend( es_out_t *p_out, ts_cmd_t *p_cmd )
{
    block_t *p_block = p_cmd->u.send.p_block;

    p_cmd->u.send.p_block = NULL;

    if( p_block )
    {
        if( p_cmd->u.send.p_es->p_es )
            return es_out_Send( p_out, p_cmd->u.send.p_es->p_es, p_block );
        block_Release( p_block );
    }
    return VLC_EGENERIC;
}",1,1,input\es_out_timeshift.c,CmdExecuteSend,,false,1341,1354,CmdExecuteSend,,,92,"int CmdExecuteSend (es_out_t*,ts_cmd_t*)"
50240,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static void CmdCleanSend( ts_cmd_t *p_cmd )
{
    if( p_cmd->u.send.p_block )
        block_Release( p_cmd->u.send.p_block );
}",1,1,input\es_out_timeshift.c,CmdCleanSend,,false,1355,1359,CmdCleanSend,,,93,void CmdCleanSend (ts_cmd_t*)
50262,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static int CmdInitDel( ts_cmd_t *p_cmd, es_out_id_t *p_es )
{
    p_cmd->i_type = C_DEL;
    p_cmd->i_date = mdate();
    p_cmd->u.del.p_es = p_es;
    return VLC_SUCCESS;
}",1,1,input\es_out_timeshift.c,CmdInitDel,,false,1361,1367,CmdInitDel,,,94,"int CmdInitDel (ts_cmd_t*,es_out_id_t*)"
50289,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static void CmdExecuteDel( es_out_t *p_out, ts_cmd_t *p_cmd )
{
    if( p_cmd->u.del.p_es->p_es )
        es_out_Del( p_out, p_cmd->u.del.p_es->p_es );
    free( p_cmd->u.del.p_es );
}",1,1,input\es_out_timeshift.c,CmdExecuteDel,,false,1368,1373,CmdExecuteDel,,,95,"void CmdExecuteDel (es_out_t*,ts_cmd_t*)"
50325,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static int CmdInitControl( ts_cmd_t *p_cmd, int i_query, va_list args, bool b_copy )
{
    p_cmd->i_type = C_CONTROL;
    p_cmd->i_date = mdate();
    p_cmd->u.control.i_query = i_query;

    switch( i_query )
    {
    /* Pass-through control */
    case ES_OUT_SET_MODE:    /* arg1= int                            */
    case ES_OUT_SET_GROUP:   /* arg1= int                            */
    case ES_OUT_DEL_GROUP:   /* arg1=int i_group */
        p_cmd->u.control.u.i_int = (int)va_arg( args, int );
        break;

    case ES_OUT_SET_PCR:                /* arg1=int64_t i_pcr(microsecond!) (using default group 0)*/
    case ES_OUT_SET_NEXT_DISPLAY_TIME:  /* arg1=int64_t i_pts(microsecond) */
        p_cmd->u.control.u.i_i64 = (int64_t)va_arg( args, int64_t );
        break;

    case ES_OUT_SET_GROUP_PCR:          /* arg1= int i_group, arg2=int64_t i_pcr(microsecond!)*/
        p_cmd->u.control.u.int_i64.i_int = (int)va_arg( args, int );
        p_cmd->u.control.u.int_i64.i_i64 = (in...",1,1,input\es_out_timeshift.c,CmdInitControl,,false,1375,1536,CmdInitControl,,,96,"int CmdInitControl (ts_cmd_t*,int,va_list,bool)"
50863,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static int CmdExecuteControl( es_out_t *p_out, ts_cmd_t *p_cmd )
{
    const int i_query = p_cmd->u.control.i_query;

    switch( i_query )
    {
    /* Pass-through control */
    case ES_OUT_SET_MODE:    /* arg1= int                            */
    case ES_OUT_SET_GROUP:   /* arg1= int                            */
    case ES_OUT_DEL_GROUP:   /* arg1=int i_group */
        return es_out_Control( p_out, i_query, p_cmd->u.control.u.i_int );

    case ES_OUT_SET_PCR:                /* arg1=int64_t i_pcr(microsecond!) (using default group 0)*/
    case ES_OUT_SET_NEXT_DISPLAY_TIME:  /* arg1=int64_t i_pts(microsecond) */
        return es_out_Control( p_out, i_query, p_cmd->u.control.u.i_i64 );

    case ES_OUT_SET_GROUP_PCR:          /* arg1= int i_group, arg2=int64_t i_pcr(microsecond!)*/
        return es_out_Control( p_out, i_query, p_cmd->u.control.u.int_i64.i_int,
                                               p_cmd->u.control.u.int_i64.i_i64 );

    case ES_OUT_RESET_PCR:    ...",1,1,input\es_out_timeshift.c,CmdExecuteControl,,false,1537,1616,CmdExecuteControl,,,97,"int CmdExecuteControl (es_out_t*,ts_cmd_t*)"
51305,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static void CmdCleanControl( ts_cmd_t *p_cmd )
{
    switch( p_cmd->u.control.i_query )
    {
    case ES_OUT_SET_GROUP_META:
    case ES_OUT_SET_META:
        if( p_cmd->u.control.u.int_meta.p_meta )
            vlc_meta_Delete( p_cmd->u.control.u.int_meta.p_meta );
        break;
    case ES_OUT_SET_GROUP_EPG:
        if( p_cmd->u.control.u.int_epg.p_epg )
            vlc_epg_Delete( p_cmd->u.control.u.int_epg.p_epg );
        break;
    case ES_OUT_SET_GROUP_EPG_EVENT:
        if( p_cmd->u.control.u.int_epg_evt.p_evt )
            vlc_epg_event_Delete( p_cmd->u.control.u.int_epg_evt.p_evt );
        break;
    case ES_OUT_SET_ES_FMT:
        if( p_cmd->u.control.u.es_fmt.p_fmt )
        {
            es_format_Clean( p_cmd->u.control.u.es_fmt.p_fmt );
            free( p_cmd->u.control.u.es_fmt.p_fmt );
        }
        break;
    }
}",1,1,input\es_out_timeshift.c,CmdCleanControl,,false,1617,1642,CmdCleanControl,,,98,void CmdCleanControl (ts_cmd_t*)
51445,METHOD,input\es_out_timeshift.c:<global>,TYPE_DECL,"static int GetTmpFile( char **filename, const char *dirname )
{
    if( dirname != NULL
     && asprintf( filename, ""%s""DIR_SEP PACKAGE_NAME""-timeshift.XXXXXX"",
                  dirname ) >= 0 )
    {
        vlc_mkdir( dirname, 0700 );

        int fd = vlc_mkstemp( *filename );
        if( fd != -1 )
            return fd;

        free( *filename );
    }

    *filename = strdup( DIR_SEP""tmp""DIR_SEP PACKAGE_NAME""-timeshift.XXXXXX"" );
    if( unlikely(*filename == NULL) )
        return -1;

    int fd = vlc_mkstemp( *filename );
    if( fd != -1 )
        return fd;

    free( *filename );
    return -1;
}",1,1,input\es_out_timeshift.c,GetTmpFile,,false,1644,1669,GetTmpFile,,,99,"int GetTmpFile (char**,char*)"
51510,METHOD,input\es_out_timeshift.h:<global>,TYPE_DECL,<global>,1,6,input\es_out_timeshift.h,input\es_out_timeshift.h:<global>,,false,1,32,<global>,,,1,
51512,METHOD,input\es_out_timeshift.h:<global>,TYPE_DECL,"es_out_t *input_EsOutTimeshiftNew( input_thread_t *, es_out_t *, int i_rate );",10,77,input\es_out_timeshift.h,input_EsOutTimeshiftNew,,false,30,30,input_EsOutTimeshiftNew,,,1,"es_out_t* input_EsOutTimeshiftNew (input_thread_t*,es_out_t*,int)"
51534,METHOD,input\event.c:<global>,TYPE_DECL,<global>,1,23,input\event.c,input\event.c:<global>,,false,1,348,<global>,,,1,
51536,METHOD,input\event.c:<global>,TYPE_DECL,"static void Trigger( input_thread_t *, int i_type );",13,51,input\event.c,Trigger,,false,38,38,Trigger,,,1,"void Trigger (input_thread_t*,int)"
51542,METHOD,input\event.c:<global>,TYPE_DECL,"static void VarListAdd( input_thread_t *,
                        const char *psz_variable, int i_event,
                        int i_value, const char *psz_text );",13,59,input\event.c,VarListAdd,,false,39,41,VarListAdd,,,2,"void VarListAdd (input_thread_t*,char*,int,int,char*)"
51551,METHOD,input\event.c:<global>,TYPE_DECL,"static void VarListDel( input_thread_t *,
                        const char *psz_variable, int i_event,
                        int i_value );",13,37,input\event.c,VarListDel,,false,42,44,VarListDel,,,3,"void VarListDel (input_thread_t*,char*,int,int)"
51559,METHOD,input\event.c:<global>,TYPE_DECL,"static void VarListSelect( input_thread_t *,
                           const char *psz_variable, int i_event,
                           int i_value );",13,40,input\event.c,VarListSelect,,false,45,47,VarListSelect,,,4,"void VarListSelect (input_thread_t*,char*,int,int)"
51567,METHOD,input\event.c:<global>,TYPE_DECL,"void input_SendEventDead( input_thread_t *p_input )
{
    Trigger( p_input, INPUT_EVENT_DEAD );
}",1,1,input\event.c,input_SendEventDead,,false,52,55,input_SendEventDead,,,5,void input_SendEventDead (input_thread_t*)
51575,METHOD,input\event.c:<global>,TYPE_DECL,"void input_SendEventPosition( input_thread_t *p_input, double f_position, mtime_t i_time )
{
    vlc_value_t val;

    /* */
    val.f_float = f_position;
    var_Change( p_input, ""position"", VLC_VAR_SETVALUE, &val, NULL );

    /* */
    val.i_int = i_time;
    var_Change( p_input, ""time"", VLC_VAR_SETVALUE, &val, NULL );

    Trigger( p_input, INPUT_EVENT_POSITION );
}",1,1,input\event.c,input_SendEventPosition,,false,57,70,input_SendEventPosition,,,6,"void input_SendEventPosition (input_thread_t*,double,mtime_t)"
51610,METHOD,input\event.c:<global>,TYPE_DECL,"void input_SendEventLength( input_thread_t *p_input, mtime_t i_length )
{
    vlc_value_t val;

    /* FIXME ugly + what about meta change event ? */
    if( var_GetInteger( p_input, ""length"" ) == i_length )
        return;

    input_item_SetDuration( input_priv(p_input)->p_item, i_length );

    val.i_int = i_length;
    var_Change( p_input, ""length"", VLC_VAR_SETVALUE, &val, NULL );

    Trigger( p_input, INPUT_EVENT_LENGTH );
}",1,1,input\event.c,input_SendEventLength,,false,71,85,input_SendEventLength,,,7,"void input_SendEventLength (input_thread_t*,mtime_t)"
51646,METHOD,input\event.c:<global>,TYPE_DECL,"void input_SendEventStatistics( input_thread_t *p_input )
{
    Trigger( p_input, INPUT_EVENT_STATISTICS );
}",1,1,input\event.c,input_SendEventStatistics,,false,86,89,input_SendEventStatistics,,,8,void input_SendEventStatistics (input_thread_t*)
51654,METHOD,input\event.c:<global>,TYPE_DECL,"void input_SendEventRate( input_thread_t *p_input, int i_rate )
{
    vlc_value_t val;

    val.f_float = (float)INPUT_RATE_DEFAULT / (float)i_rate;
    var_Change( p_input, ""rate"", VLC_VAR_SETVALUE, &val, NULL );

    Trigger( p_input, INPUT_EVENT_RATE );
}",1,1,input\event.c,input_SendEventRate,,false,90,98,input_SendEventRate,,,9,"void input_SendEventRate (input_thread_t*,int)"
51682,METHOD,input\event.c:<global>,TYPE_DECL,"void input_SendEventAudioDelay( input_thread_t *p_input, mtime_t i_delay )
{
    vlc_value_t val;

    val.i_int = i_delay;
    var_Change( p_input, ""audio-delay"", VLC_VAR_SETVALUE, &val, NULL );

    Trigger( p_input, INPUT_EVENT_AUDIO_DELAY );
}",1,1,input\event.c,input_SendEventAudioDelay,,false,99,107,input_SendEventAudioDelay,,,10,"void input_SendEventAudioDelay (input_thread_t*,mtime_t)"
51704,METHOD,input\event.c:<global>,TYPE_DECL,"void input_SendEventSubtitleDelay( input_thread_t *p_input, mtime_t i_delay )
{
    vlc_value_t val;

    val.i_int = i_delay;
    var_Change( p_input, ""spu-delay"", VLC_VAR_SETVALUE, &val, NULL );

    Trigger( p_input, INPUT_EVENT_SUBTITLE_DELAY );
}",1,1,input\event.c,input_SendEventSubtitleDelay,,false,109,117,input_SendEventSubtitleDelay,,,11,"void input_SendEventSubtitleDelay (input_thread_t*,mtime_t)"
51726,METHOD,input\event.c:<global>,TYPE_DECL,"void input_SendEventRecord( input_thread_t *p_input, bool b_recording )
{
    vlc_value_t val;

    val.b_bool = b_recording;
    var_Change( p_input, ""record"", VLC_VAR_SETVALUE, &val, NULL );

    Trigger( p_input, INPUT_EVENT_RECORD );
}",1,1,input\event.c,input_SendEventRecord,,false,120,128,input_SendEventRecord,,,12,"void input_SendEventRecord (input_thread_t*,bool)"
51748,METHOD,input\event.c:<global>,TYPE_DECL,"void input_SendEventTitle( input_thread_t *p_input, int i_title )
{
    vlc_value_t val;

    val.i_int = i_title;
    var_Change( p_input, ""title"", VLC_VAR_SETVALUE, &val, NULL );

    input_ControlVarTitle( p_input, i_title );

    Trigger( p_input, INPUT_EVENT_TITLE );
}",1,1,input\event.c,input_SendEventTitle,,false,130,140,input_SendEventTitle,,,13,"void input_SendEventTitle (input_thread_t*,int)"
51773,METHOD,input\event.c:<global>,TYPE_DECL,"void input_SendEventSeekpoint( input_thread_t *p_input, int i_title, int i_seekpoint )
{
    vlc_value_t val;

    /* ""chapter"" */
    val.i_int = i_seekpoint;
    var_Change( p_input, ""chapter"", VLC_VAR_SETVALUE, &val, NULL );

    /* ""title %2u"" */
    char psz_title[sizeof (""title "") + 3 * sizeof (int)];
    sprintf( psz_title, ""title %2u"", i_title );
    var_Change( p_input, psz_title, VLC_VAR_SETVALUE, &val, NULL );

    /* */
    Trigger( p_input, INPUT_EVENT_CHAPTER );
}",1,1,input\event.c,input_SendEventSeekpoint,,false,142,157,input_SendEventSeekpoint,,,14,"void input_SendEventSeekpoint (input_thread_t*,int,int)"
51808,METHOD,input\event.c:<global>,TYPE_DECL,"void input_SendEventSignal( input_thread_t *p_input, double f_quality, double f_strength )
{
    vlc_value_t val;

    val.f_float = f_quality;
    var_Change( p_input, ""signal-quality"", VLC_VAR_SETVALUE, &val, NULL );

    val.f_float = f_strength;
    var_Change( p_input, ""signal-strength"", VLC_VAR_SETVALUE, &val, NULL );

    Trigger( p_input, INPUT_EVENT_SIGNAL );
}",1,1,input\event.c,input_SendEventSignal,,false,159,170,input_SendEventSignal,,,15,"void input_SendEventSignal (input_thread_t*,double,double)"
51843,METHOD,input\event.c:<global>,TYPE_DECL,"void input_SendEventState( input_thread_t *p_input, int i_state )
{
    vlc_value_t val;

    val.i_int = i_state;
    var_Change( p_input, ""state"", VLC_VAR_SETVALUE, &val, NULL );

    Trigger( p_input, INPUT_EVENT_STATE );
}",1,1,input\event.c,input_SendEventState,,false,172,180,input_SendEventState,,,16,"void input_SendEventState (input_thread_t*,int)"
51865,METHOD,input\event.c:<global>,TYPE_DECL,"void input_SendEventCache( input_thread_t *p_input, double f_level )
{
    vlc_value_t val;

    val.f_float = f_level;
    var_Change( p_input, ""cache"", VLC_VAR_SETVALUE, &val, NULL );

    Trigger( p_input, INPUT_EVENT_CACHE );
}",1,1,input\event.c,input_SendEventCache,,false,182,190,input_SendEventCache,,,17,"void input_SendEventCache (input_thread_t*,double)"
51887,METHOD,input\event.c:<global>,TYPE_DECL,"void input_SendEventMeta( input_thread_t *p_input )
{
    Trigger( p_input, INPUT_EVENT_ITEM_META );
}",1,1,input\event.c,input_SendEventMeta,,false,192,195,input_SendEventMeta,,,18,void input_SendEventMeta (input_thread_t*)
51895,METHOD,input\event.c:<global>,TYPE_DECL,"void input_SendEventMetaInfo( input_thread_t *p_input )
{
    Trigger( p_input, INPUT_EVENT_ITEM_INFO );
}",1,1,input\event.c,input_SendEventMetaInfo,,false,197,200,input_SendEventMetaInfo,,,19,void input_SendEventMetaInfo (input_thread_t*)
51903,METHOD,input\event.c:<global>,TYPE_DECL,"void input_SendEventMetaEpg( input_thread_t *p_input )
{
    Trigger( p_input, INPUT_EVENT_ITEM_EPG );
}",1,1,input\event.c,input_SendEventMetaEpg,,false,202,205,input_SendEventMetaEpg,,,20,void input_SendEventMetaEpg (input_thread_t*)
51911,METHOD,input\event.c:<global>,TYPE_DECL,"void input_SendEventProgramAdd( input_thread_t *p_input,
                                int i_program, const char *psz_text )
{
    VarListAdd( p_input, ""program"", INPUT_EVENT_PROGRAM, i_program, psz_text );
}",1,1,input\event.c,input_SendEventProgramAdd,,false,209,213,input_SendEventProgramAdd,,,21,"void input_SendEventProgramAdd (input_thread_t*,int,char*)"
51924,METHOD,input\event.c:<global>,TYPE_DECL,"void input_SendEventProgramDel( input_thread_t *p_input, int i_program )
{
    VarListDel( p_input, ""program"", INPUT_EVENT_PROGRAM, i_program );
}",1,1,input\event.c,input_SendEventProgramDel,,false,214,217,input_SendEventProgramDel,,,22,"void input_SendEventProgramDel (input_thread_t*,int)"
51935,METHOD,input\event.c:<global>,TYPE_DECL,"void input_SendEventProgramSelect( input_thread_t *p_input, int i_program )
{
    VarListSelect( p_input, ""program"", INPUT_EVENT_PROGRAM, i_program );
}",1,1,input\event.c,input_SendEventProgramSelect,,false,218,221,input_SendEventProgramSelect,,,23,"void input_SendEventProgramSelect (input_thread_t*,int)"
51946,METHOD,input\event.c:<global>,TYPE_DECL,"void input_SendEventProgramScrambled( input_thread_t *p_input, int i_group, bool b_scrambled )
{
    if( var_GetInteger( p_input, ""program"" ) != i_group )
        return;

    var_SetBool( p_input, ""program-scrambled"", b_scrambled );
    Trigger( p_input, INPUT_EVENT_PROGRAM );
}",1,1,input\event.c,input_SendEventProgramScrambled,,false,222,229,input_SendEventProgramScrambled,,,24,"void input_SendEventProgramScrambled (input_thread_t*,int,bool)"
51968,METHOD,input\event.c:<global>,TYPE_DECL,"static const char *GetEsVarName( enum es_format_category_e i_cat )
{
    switch( i_cat )
    {
    case VIDEO_ES:
        return ""video-es"";
    case AUDIO_ES:
        return ""audio-es"";
    case SPU_ES:
        return ""spu-es"";
    default:
        return NULL;
    }
}",1,1,input\event.c,GetEsVarName,,false,231,244,GetEsVarName,,,25,const char* GetEsVarName (es_format_category_e)
51991,METHOD,input\event.c:<global>,TYPE_DECL,"void input_SendEventEsAdd( input_thread_t *p_input, enum es_format_category_e i_cat, int i_id, const char *psz_text )
{
    const char *psz_varname = GetEsVarName( i_cat );
    if( psz_varname )
        VarListAdd( p_input, psz_varname, INPUT_EVENT_ES, i_id, psz_text );
}",1,1,input\event.c,input_SendEventEsAdd,,false,245,250,input_SendEventEsAdd,,,26,"void input_SendEventEsAdd (input_thread_t*,es_format_category_e,int,char*)"
52013,METHOD,input\event.c:<global>,TYPE_DECL,"void input_SendEventEsDel( input_thread_t *p_input, enum es_format_category_e i_cat, int i_id )
{
    const char *psz_varname = GetEsVarName( i_cat );
    if( psz_varname )
        VarListDel( p_input, psz_varname, INPUT_EVENT_ES, i_id );
}",1,1,input\event.c,input_SendEventEsDel,,false,251,256,input_SendEventEsDel,,,27,"void input_SendEventEsDel (input_thread_t*,es_format_category_e,int)"
52033,METHOD,input\event.c:<global>,TYPE_DECL,"void input_SendEventEsSelect( input_thread_t *p_input, enum es_format_category_e i_cat, int i_id )
{
    const char *psz_varname = GetEsVarName( i_cat );
    if( psz_varname )
        VarListSelect( p_input, psz_varname, INPUT_EVENT_ES, i_id );
}",1,1,input\event.c,input_SendEventEsSelect,,false,258,263,input_SendEventEsSelect,,,28,"void input_SendEventEsSelect (input_thread_t*,es_format_category_e,int)"
52053,METHOD,input\event.c:<global>,TYPE_DECL,"void input_SendEventTeletextAdd( input_thread_t *p_input,
                                 int i_teletext, const char *psz_text )
{
    VarListAdd( p_input, ""teletext-es"", INPUT_EVENT_TELETEXT, i_teletext, psz_text );
}",1,1,input\event.c,input_SendEventTeletextAdd,,false,265,269,input_SendEventTeletextAdd,,,29,"void input_SendEventTeletextAdd (input_thread_t*,int,char*)"
52066,METHOD,input\event.c:<global>,TYPE_DECL,"void input_SendEventTeletextDel( input_thread_t *p_input, int i_teletext )
{
    VarListDel( p_input, ""teletext-es"", INPUT_EVENT_TELETEXT, i_teletext );
}",1,1,input\event.c,input_SendEventTeletextDel,,false,270,273,input_SendEventTeletextDel,,,30,"void input_SendEventTeletextDel (input_thread_t*,int)"
52077,METHOD,input\event.c:<global>,TYPE_DECL,"void input_SendEventTeletextSelect( input_thread_t *p_input, int i_teletext )
{
    VarListSelect( p_input, ""teletext-es"", INPUT_EVENT_TELETEXT, i_teletext );
}",1,1,input\event.c,input_SendEventTeletextSelect,,false,274,277,input_SendEventTeletextSelect,,,31,"void input_SendEventTeletextSelect (input_thread_t*,int)"
52088,METHOD,input\event.c:<global>,TYPE_DECL,"void input_SendEventVout( input_thread_t *p_input )
{
    Trigger( p_input, INPUT_EVENT_VOUT );
}",1,1,input\event.c,input_SendEventVout,,false,279,282,input_SendEventVout,,,32,void input_SendEventVout (input_thread_t*)
52096,METHOD,input\event.c:<global>,TYPE_DECL,"void input_SendEventAout( input_thread_t *p_input )
{
    Trigger( p_input, INPUT_EVENT_AOUT );
}",1,1,input\event.c,input_SendEventAout,,false,284,287,input_SendEventAout,,,33,void input_SendEventAout (input_thread_t*)
52104,METHOD,input\event.c:<global>,TYPE_DECL,"void input_SendEventBookmark( input_thread_t *p_input )
{
    Trigger( p_input, INPUT_EVENT_BOOKMARK );
}",1,1,input\event.c,input_SendEventBookmark,,false,292,295,input_SendEventBookmark,,,34,void input_SendEventBookmark (input_thread_t*)
52112,METHOD,input\event.c:<global>,TYPE_DECL,"static void Trigger( input_thread_t *p_input, int i_type )
{
    var_SetInteger( p_input, ""intf-event"", i_type );
}",1,1,input\event.c,Trigger,,false,300,303,Trigger,,,35,"void Trigger (input_thread_t*,int)"
52122,METHOD,input\event.c:<global>,TYPE_DECL,"static void VarListAdd( input_thread_t *p_input,
                        const char *psz_variable, int i_event,
                        int i_value, const char *psz_text )
{
    vlc_value_t val;
    vlc_value_t text;

    val.i_int = i_value;
    text.psz_string = (char*)psz_text;

    var_Change( p_input, psz_variable, VLC_VAR_ADDCHOICE,
                &val, psz_text ? &text : NULL );

    Trigger( p_input, i_event );
}",1,1,input\event.c,VarListAdd,,false,304,318,VarListAdd,,,36,"void VarListAdd (input_thread_t*,char*,int,int,char*)"
52159,METHOD,input\event.c:<global>,TYPE_DECL,"static void VarListDel( input_thread_t *p_input,
                        const char *psz_variable, int i_event,
                        int i_value )
{
    vlc_value_t val;

    if( i_value >= 0 )
    {
        val.i_int = i_value;
        var_Change( p_input, psz_variable, VLC_VAR_DELCHOICE, &val, NULL );
    }
    else
    {
        var_Change( p_input, psz_variable, VLC_VAR_CLEARCHOICES, &val, NULL );
    }

    Trigger( p_input, i_event );
}",1,1,input\event.c,VarListDel,,false,319,336,VarListDel,,,37,"void VarListDel (input_thread_t*,char*,int,int)"
52197,METHOD,input\event.c:<global>,TYPE_DECL,"static void VarListSelect( input_thread_t *p_input,
                           const char *psz_variable, int i_event,
                           int i_value )
{
    vlc_value_t val;

    val.i_int = i_value;
    var_Change( p_input, psz_variable, VLC_VAR_SETVALUE, &val, NULL );

    Trigger( p_input, i_event );
}",1,1,input\event.c,VarListSelect,,false,337,347,VarListSelect,,,38,"void VarListSelect (input_thread_t*,char*,int,int)"
52226,METHOD,input\event.h:<global>,TYPE_DECL,<global>,1,6,input\event.h,input\event.h:<global>,,false,1,80,<global>,,,1,
52228,METHOD,input\event.h:<global>,TYPE_DECL,void input_SendEventDead( input_thread_t *p_input );,6,51,input\event.h,input_SendEventDead,,false,32,32,input_SendEventDead,,,1,void input_SendEventDead (input_thread_t*)
52233,METHOD,input\event.h:<global>,TYPE_DECL,"void input_SendEventPosition( input_thread_t *p_input, double f_position, mtime_t i_time );",6,90,input\event.h,input_SendEventPosition,,false,33,33,input_SendEventPosition,,,2,"void input_SendEventPosition (input_thread_t*,double,mtime_t)"
52240,METHOD,input\event.h:<global>,TYPE_DECL,"void input_SendEventLength( input_thread_t *p_input, mtime_t i_length );",6,71,input\event.h,input_SendEventLength,,false,34,34,input_SendEventLength,,,3,"void input_SendEventLength (input_thread_t*,mtime_t)"
52246,METHOD,input\event.h:<global>,TYPE_DECL,void input_SendEventStatistics( input_thread_t *p_input );,6,57,input\event.h,input_SendEventStatistics,,false,35,35,input_SendEventStatistics,,,4,void input_SendEventStatistics (input_thread_t*)
52251,METHOD,input\event.h:<global>,TYPE_DECL,"void input_SendEventRate( input_thread_t *p_input, int i_rate );",6,63,input\event.h,input_SendEventRate,,false,36,36,input_SendEventRate,,,5,"void input_SendEventRate (input_thread_t*,int)"
52257,METHOD,input\event.h:<global>,TYPE_DECL,"void input_SendEventAudioDelay( input_thread_t *p_input, mtime_t i_delay );",6,74,input\event.h,input_SendEventAudioDelay,,false,37,37,input_SendEventAudioDelay,,,6,"void input_SendEventAudioDelay (input_thread_t*,mtime_t)"
52263,METHOD,input\event.h:<global>,TYPE_DECL,"void input_SendEventSubtitleDelay( input_thread_t *p_input, mtime_t i_delay );",6,77,input\event.h,input_SendEventSubtitleDelay,,false,38,38,input_SendEventSubtitleDelay,,,7,"void input_SendEventSubtitleDelay (input_thread_t*,mtime_t)"
52269,METHOD,input\event.h:<global>,TYPE_DECL,"void input_SendEventRecord( input_thread_t *p_input, bool b_recording );",6,71,input\event.h,input_SendEventRecord,,false,39,39,input_SendEventRecord,,,8,"void input_SendEventRecord (input_thread_t*,bool)"
52275,METHOD,input\event.h:<global>,TYPE_DECL,"void input_SendEventTitle( input_thread_t *p_input, int i_title );",6,65,input\event.h,input_SendEventTitle,,false,40,40,input_SendEventTitle,,,9,"void input_SendEventTitle (input_thread_t*,int)"
52281,METHOD,input\event.h:<global>,TYPE_DECL,"void input_SendEventSeekpoint( input_thread_t *p_input, int i_title, int i_seekpoint );",6,86,input\event.h,input_SendEventSeekpoint,,false,41,41,input_SendEventSeekpoint,,,10,"void input_SendEventSeekpoint (input_thread_t*,int,int)"
52288,METHOD,input\event.h:<global>,TYPE_DECL,"void input_SendEventSignal( input_thread_t *p_input, double f_quality, double f_strength );",6,90,input\event.h,input_SendEventSignal,,false,42,42,input_SendEventSignal,,,11,"void input_SendEventSignal (input_thread_t*,double,double)"
52295,METHOD,input\event.h:<global>,TYPE_DECL,"void input_SendEventState( input_thread_t *p_input, int i_state );",6,65,input\event.h,input_SendEventState,,false,43,43,input_SendEventState,,,12,"void input_SendEventState (input_thread_t*,int)"
52301,METHOD,input\event.h:<global>,TYPE_DECL,"void input_SendEventCache( input_thread_t *p_input, double f_level );",6,68,input\event.h,input_SendEventCache,,false,44,44,input_SendEventCache,,,13,"void input_SendEventCache (input_thread_t*,double)"
52307,METHOD,input\event.h:<global>,TYPE_DECL,void input_SendEventMeta( input_thread_t *p_input );,6,51,input\event.h,input_SendEventMeta,,false,47,47,input_SendEventMeta,,,14,void input_SendEventMeta (input_thread_t*)
52312,METHOD,input\event.h:<global>,TYPE_DECL,void input_SendEventMetaInfo( input_thread_t *p_input );,6,55,input\event.h,input_SendEventMetaInfo,,false,48,48,input_SendEventMetaInfo,,,15,void input_SendEventMetaInfo (input_thread_t*)
52317,METHOD,input\event.h:<global>,TYPE_DECL,void input_SendEventMetaEpg( input_thread_t *p_input );,6,54,input\event.h,input_SendEventMetaEpg,,false,49,49,input_SendEventMetaEpg,,,16,void input_SendEventMetaEpg (input_thread_t*)
52322,METHOD,input\event.h:<global>,TYPE_DECL,"void input_SendEventProgramAdd( input_thread_t *p_input,
                                int i_program, const char *psz_text );",6,69,input\event.h,input_SendEventProgramAdd,,false,54,55,input_SendEventProgramAdd,,,17,"void input_SendEventProgramAdd (input_thread_t*,int,char*)"
52329,METHOD,input\event.h:<global>,TYPE_DECL,"void input_SendEventProgramDel( input_thread_t *p_input, int i_program );",6,72,input\event.h,input_SendEventProgramDel,,false,56,56,input_SendEventProgramDel,,,18,"void input_SendEventProgramDel (input_thread_t*,int)"
52335,METHOD,input\event.h:<global>,TYPE_DECL,"void input_SendEventProgramSelect( input_thread_t *p_input, int i_program );",6,75,input\event.h,input_SendEventProgramSelect,,false,57,57,input_SendEventProgramSelect,,,19,"void input_SendEventProgramSelect (input_thread_t*,int)"
52341,METHOD,input\event.h:<global>,TYPE_DECL,"void input_SendEventProgramScrambled( input_thread_t *p_input, int i_group, bool b_scrambled );",6,94,input\event.h,input_SendEventProgramScrambled,,false,58,58,input_SendEventProgramScrambled,,,20,"void input_SendEventProgramScrambled (input_thread_t*,int,bool)"
52348,METHOD,input\event.h:<global>,TYPE_DECL,"void input_SendEventEsDel( input_thread_t *p_input, enum es_format_category_e i_cat, int i_id );",6,95,input\event.h,input_SendEventEsDel,,false,60,60,input_SendEventEsDel,,,21,"void input_SendEventEsDel (input_thread_t*,es_format_category_e,int)"
52355,METHOD,input\event.h:<global>,TYPE_DECL,"void input_SendEventEsAdd( input_thread_t *p_input, enum es_format_category_e i_cat, int i_id, const char *psz_text );",6,117,input\event.h,input_SendEventEsAdd,,false,61,61,input_SendEventEsAdd,,,22,"void input_SendEventEsAdd (input_thread_t*,es_format_category_e,int,char*)"
52363,METHOD,input\event.h:<global>,TYPE_DECL,"void input_SendEventEsSelect( input_thread_t *p_input, enum es_format_category_e i_cat, int i_id );",6,98,input\event.h,input_SendEventEsSelect,,false,62,62,input_SendEventEsSelect,,,23,"void input_SendEventEsSelect (input_thread_t*,es_format_category_e,int)"
52370,METHOD,input\event.h:<global>,TYPE_DECL,"void input_SendEventTeletextAdd( input_thread_t *p_input,
                                 int i_teletext, const char *psz_text );",6,71,input\event.h,input_SendEventTeletextAdd,,false,64,65,input_SendEventTeletextAdd,,,24,"void input_SendEventTeletextAdd (input_thread_t*,int,char*)"
52377,METHOD,input\event.h:<global>,TYPE_DECL,"void input_SendEventTeletextDel( input_thread_t *p_input, int i_teletext );",6,74,input\event.h,input_SendEventTeletextDel,,false,66,66,input_SendEventTeletextDel,,,25,"void input_SendEventTeletextDel (input_thread_t*,int)"
52383,METHOD,input\event.h:<global>,TYPE_DECL,"void input_SendEventTeletextSelect( input_thread_t *p_input, int i_teletext );",6,77,input\event.h,input_SendEventTeletextSelect,,false,67,67,input_SendEventTeletextSelect,,,26,"void input_SendEventTeletextSelect (input_thread_t*,int)"
52389,METHOD,input\event.h:<global>,TYPE_DECL,void input_SendEventVout( input_thread_t *p_input );,6,51,input\event.h,input_SendEventVout,,false,72,72,input_SendEventVout,,,27,void input_SendEventVout (input_thread_t*)
52394,METHOD,input\event.h:<global>,TYPE_DECL,void input_SendEventAout( input_thread_t *p_input );,6,51,input\event.h,input_SendEventAout,,false,73,73,input_SendEventAout,,,28,void input_SendEventAout (input_thread_t*)
52399,METHOD,input\event.h:<global>,TYPE_DECL,void input_SendEventBookmark( input_thread_t *p_input );,6,55,input\event.h,input_SendEventBookmark,,false,78,78,input_SendEventBookmark,,,29,void input_SendEventBookmark (input_thread_t*)
52409,METHOD,input\info.h:<global>,TYPE_DECL,<global>,1,6,input\info.h,input\info.h:<global>,,false,1,134,<global>,,,1,
52411,METHOD,input\info.h:<global>,TYPE_DECL,"static inline info_t *info_New(const char *name, const char *value )
{
    info_t *info = malloc(sizeof(*info));
    if (!info)
        return NULL;

    info->psz_name = strdup(name);
    info->psz_value = value ? strdup(value) : NULL;
    return info;
}",1,1,input\info.h,info_New,,false,29,38,info_New,,,1,"info_t info_New (char*,char*)"
52447,METHOD,input\info.h:<global>,TYPE_DECL,"static inline void info_Delete(info_t *i)
{
    free(i->psz_name);
    free(i->psz_value);
    free(i);
}",1,1,input\info.h,info_Delete,,false,40,45,info_Delete,,,2,void info_Delete (info_t*)
52462,METHOD,input\info.h:<global>,TYPE_DECL,"static inline info_category_t *info_category_New(const char *name)
{
    info_category_t *cat = malloc(sizeof(*cat));
    if (!cat)
        return NULL;
    cat->psz_name = strdup(name);
    cat->i_infos  = 0;
    cat->pp_infos = NULL;

    return cat;
}",1,1,input\info.h,info_category_New,,false,47,57,info_category_New,,,3,info_category_t info_category_New (char*)
52498,METHOD,input\info.h:<global>,TYPE_DECL,"static inline info_t *info_category_FindInfo(const info_category_t *cat,
                                             int *index, const char *name)
{
    for (int i = 0; i < cat->i_infos; i++) {
        if (!strcmp(cat->pp_infos[i]->psz_name, name)) {
            if (index)
                *index = i;
            return cat->pp_infos[i];
        }
    }
    return NULL;
}",1,1,input\info.h,info_category_FindInfo,,false,59,70,info_category_FindInfo,,,4,"info_t info_category_FindInfo (info_category_t*,int*,char*)"
52546,METHOD,input\info.h:<global>,TYPE_DECL,"static inline void info_category_ReplaceInfo(info_category_t *cat,
                                             info_t *info)
{
    int index;
    info_t *old = info_category_FindInfo(cat, &index, info->psz_name);
    if (old) {
        info_Delete(cat->pp_infos[index]);
        cat->pp_infos[index] = info;
    } else
        TAB_APPEND(cat->i_infos, cat->pp_infos, info);
}",1,1,input\info.h,info_category_ReplaceInfo,,false,72,82,info_category_ReplaceInfo,,,5,"void info_category_ReplaceInfo (info_category_t*,info_t*)"
52589,METHOD,input\info.h:<global>,TYPE_DECL,"static inline info_t *info_category_VaAddInfo(info_category_t *cat,
                                              const char *name,
                                              const char *format, va_list args)
{
    info_t *info = info_category_FindInfo(cat, NULL, name);
    if (!info) {
        info = info_New(name, NULL);
        if (!info)
            return NULL;
        TAB_APPEND(cat->i_infos, cat->pp_infos, info);
    } else
        free(info->psz_value);
    if (vasprintf(&info->psz_value, format, args) == -1)
        info->psz_value = NULL;
    return info;
}",1,1,input\info.h,info_category_VaAddInfo,,false,84,99,info_category_VaAddInfo,,,6,"info_t info_category_VaAddInfo (info_category_t*,char*,char*,va_list)"
52652,METHOD,input\info.h:<global>,TYPE_DECL,"static inline info_t *info_category_AddInfo(info_category_t *cat,
                                            const char *name,
                                            const char *format, ...)
{
    va_list args;

    va_start(args, format);
    info_t *info = info_category_VaAddInfo(cat, name, format, args);
    va_end(args);

    return info;
}",1,1,input\info.h,info_category_AddInfo,,false,101,112,info_category_AddInfo,,,7,"info_t info_category_AddInfo (info_category_t*,char*,char*...)"
52675,METHOD,input\info.h:<global>,TYPE_DECL,"static inline int info_category_DeleteInfo(info_category_t *cat, const char *name)
{
    int index;
    if (info_category_FindInfo(cat, &index, name)) {
        info_Delete(cat->pp_infos[index]);
        TAB_ERASE(cat->i_infos, cat->pp_infos, index);
        return VLC_SUCCESS;
    }
    return VLC_EGENERIC;
}",1,1,input\info.h,info_category_DeleteInfo,,false,114,123,info_category_DeleteInfo,,,8,"int info_category_DeleteInfo (info_category_t*,char*)"
52707,METHOD,input\info.h:<global>,TYPE_DECL,"static inline void info_category_Delete(info_category_t *cat)
{
    for (int i = 0; i < cat->i_infos; i++)
        info_Delete(cat->pp_infos[i]);
    free(cat->pp_infos);
    free(cat->psz_name);
    free(cat);
}",1,1,input\info.h,info_category_Delete,,false,125,132,info_category_Delete,,,9,void info_category_Delete (info_category_t*)
52792,METHOD,input\input.c:<global>,TYPE_DECL,<global>,1,1,input\input.c,input\input.c:<global>,,false,1,3564,<global>,,,1,
52794,METHOD,input\input.c:<global>,TYPE_DECL,static  void *Run( void * );,14,27,input\input.c,Run,,false,62,62,Run,,,1,void* Run (void*)
52799,METHOD,input\input.c:<global>,TYPE_DECL,static  void *Preparse( void * );,14,32,input\input.c,Preparse,,false,63,63,Preparse,,,2,void* Preparse (void*)
52804,METHOD,input\input.c:<global>,TYPE_DECL,"static input_thread_t * Create  ( vlc_object_t *, input_item_t *,
                                  const char *, bool, input_resource_t *,
                                  vlc_renderer_item_t * );",23,57,input\input.c,Create,,false,65,67,Create,,,3,"input_thread_t* Create (vlc_object_t*,input_item_t*,char*,ANY,input_resource_t*,vlc_renderer_item_t*)"
52814,METHOD,input\input.c:<global>,TYPE_DECL,static  int             Init    ( input_thread_t *p_input );,25,59,input\input.c,Init,,false,68,68,Init,,,4,int Init (input_thread_t*)
52819,METHOD,input\input.c:<global>,TYPE_DECL,static void             End     ( input_thread_t *p_input );,25,59,input\input.c,End,,false,69,69,End,,,5,void End (input_thread_t*)
52824,METHOD,input\input.c:<global>,TYPE_DECL,"static void             MainLoop( input_thread_t *p_input, bool b_interactive );",25,79,input\input.c,MainLoop,,false,70,70,MainLoop,,,6,"void MainLoop (input_thread_t*,bool)"
52830,METHOD,input\input.c:<global>,TYPE_DECL,"static inline int ControlPop( input_thread_t *, int *, vlc_value_t *, mtime_t i_deadline, bool b_postpone_seek );",19,112,input\input.c,ControlPop,,false,72,72,ControlPop,,,7,"int ControlPop (input_thread_t*,int*,vlc_value_t*,mtime_t,bool)"
52839,METHOD,input\input.c:<global>,TYPE_DECL,"static void       ControlRelease( int i_type, vlc_value_t val );",19,63,input\input.c,ControlRelease,,false,73,73,ControlRelease,,,8,"void ControlRelease (int,vlc_value_t)"
52845,METHOD,input\input.c:<global>,TYPE_DECL,static bool       ControlIsSeekRequest( int i_type );,19,52,input\input.c,ControlIsSeekRequest,,false,74,74,ControlIsSeekRequest,,,9,bool ControlIsSeekRequest (int)
52850,METHOD,input\input.c:<global>,TYPE_DECL,"static bool       Control( input_thread_t *, int, vlc_value_t );",19,63,input\input.c,Control,,false,75,75,Control,,,10,"bool Control (input_thread_t*,int,ANY)"
52857,METHOD,input\input.c:<global>,TYPE_DECL,"static void       ControlPause( input_thread_t *, mtime_t );",19,59,input\input.c,ControlPause,,false,76,76,ControlPause,,,11,"void ControlPause (input_thread_t*,ANY)"
52863,METHOD,input\input.c:<global>,TYPE_DECL,static int  UpdateTitleSeekpointFromDemux( input_thread_t * );,13,61,input\input.c,UpdateTitleSeekpointFromDemux,,false,78,78,UpdateTitleSeekpointFromDemux,,,12,int UpdateTitleSeekpointFromDemux (input_thread_t*)
52868,METHOD,input\input.c:<global>,TYPE_DECL,static void UpdateGenericFromDemux( input_thread_t * );,13,54,input\input.c,UpdateGenericFromDemux,,false,79,79,UpdateGenericFromDemux,,,13,void UpdateGenericFromDemux (input_thread_t*)
52873,METHOD,input\input.c:<global>,TYPE_DECL,static void UpdateTitleListfromDemux( input_thread_t * );,13,56,input\input.c,UpdateTitleListfromDemux,,false,80,80,UpdateTitleListfromDemux,,,14,void UpdateTitleListfromDemux (input_thread_t*)
52878,METHOD,input\input.c:<global>,TYPE_DECL,"static void MRLSections( const char *, int *, int *, int *, int *);",13,66,input\input.c,MRLSections,,false,82,82,MRLSections,,,15,"void MRLSections (char*,int*,int*,int*,int*)"
52887,METHOD,input\input.c:<global>,TYPE_DECL,"static input_source_t *InputSourceNew( input_thread_t *, const char *,
                                       const char *psz_forced_demux,
                                       bool b_in_can_fail );",23,59,input\input.c,InputSourceNew,,false,84,86,InputSourceNew,,,16,"input_source_t* InputSourceNew (input_thread_t*,char*,char*,bool)"
52895,METHOD,input\input.c:<global>,TYPE_DECL,static void InputSourceDestroy( input_source_t * );,13,50,input\input.c,InputSourceDestroy,,false,87,87,InputSourceDestroy,,,17,void InputSourceDestroy (input_source_t*)
52900,METHOD,input\input.c:<global>,TYPE_DECL,"static void InputSourceMeta( input_thread_t *, input_source_t *, vlc_meta_t * );",13,79,input\input.c,InputSourceMeta,,false,88,88,InputSourceMeta,,,18,"void InputSourceMeta (input_thread_t*,input_source_t*,vlc_meta_t*)"
52907,METHOD,input\input.c:<global>,TYPE_DECL,static void SlaveDemux( input_thread_t *p_input );,13,49,input\input.c,SlaveDemux,,false,92,92,SlaveDemux,,,19,void SlaveDemux (input_thread_t*)
52912,METHOD,input\input.c:<global>,TYPE_DECL,static void SlaveSeek( input_thread_t *p_input );,13,48,input\input.c,SlaveSeek,,false,93,93,SlaveSeek,,,20,void SlaveSeek (input_thread_t*)
52917,METHOD,input\input.c:<global>,TYPE_DECL,"static void InputMetaUser( input_thread_t *p_input, vlc_meta_t *p_meta );",13,72,input\input.c,InputMetaUser,,false,95,95,InputMetaUser,,,21,"void InputMetaUser (input_thread_t*,vlc_meta_t*)"
52923,METHOD,input\input.c:<global>,TYPE_DECL,"static void InputUpdateMeta( input_thread_t *p_input, demux_t *p_demux );",13,72,input\input.c,InputUpdateMeta,,false,96,96,InputUpdateMeta,,,22,"void InputUpdateMeta (input_thread_t*,demux_t*)"
52929,METHOD,input\input.c:<global>,TYPE_DECL,"static void InputGetExtraFiles( input_thread_t *p_input,
                                int *pi_list, char ***pppsz_list,
                                const char **psz_access, const char *psz_path );",13,79,input\input.c,InputGetExtraFiles,,false,97,99,InputGetExtraFiles,,,23,"void InputGetExtraFiles (input_thread_t*,int*,char***,char**,char*)"
52938,METHOD,input\input.c:<global>,TYPE_DECL,"static void AppendAttachment( int *pi_attachment, input_attachment_t ***ppp_attachment,
                              const demux_t ***ppp_attachment_demux,
                              int i_new, input_attachment_t **pp_new, const demux_t *p_demux );",13,94,input\input.c,AppendAttachment,,false,101,103,AppendAttachment,,,24,"void AppendAttachment (int*,input_attachment_t***,demux_t***,int,input_attachment_t**,demux_t*)"
52948,METHOD,input\input.c:<global>,TYPE_DECL,"static int input_SlaveSourceAdd( input_thread_t *, enum slave_type,
                                 const char *, unsigned );",12,57,input\input.c,input_SlaveSourceAdd,,false,110,111,input_SlaveSourceAdd,,,25,"int input_SlaveSourceAdd (input_thread_t*,slave_type,char*,unsigned)"
52956,METHOD,input\input.c:<global>,TYPE_DECL,"static char *input_SubtitleFile2Uri( input_thread_t *, const char * );",13,69,input\input.c,input_SubtitleFile2Uri,,false,112,112,input_SubtitleFile2Uri,,,26,"char* input_SubtitleFile2Uri (input_thread_t*,char*)"
52962,METHOD,input\input.c:<global>,TYPE_DECL,"static void input_ChangeState( input_thread_t *p_input, int i_state );",13,69,input\input.c,input_ChangeState,,false,113,113,input_ChangeState,,,27,"void input_ChangeState (input_thread_t*,int)"
52968,METHOD,input\input.c:<global>,TYPE_DECL,"input_thread_t *input_Create( vlc_object_t *p_parent,
                              input_item_t *p_item,
                              const char *psz_log, input_resource_t *p_resource,
                              vlc_renderer_item_t *p_renderer )
{
    return Create( p_parent, p_item, psz_log, false, p_resource, p_renderer );
}",1,1,input\input.c,input_Create,,false,128,134,input_Create,,,28,"input_thread_t input_Create (vlc_object_t*,input_item_t*,char*,input_resource_t*,vlc_renderer_item_t*)"
52985,METHOD,input\input.c:<global>,TYPE_DECL,"int input_Read( vlc_object_t *p_parent, input_item_t *p_item )
{
    input_thread_t *p_input = Create( p_parent, p_item, NULL, false, NULL, NULL );
    if( !p_input )
        return VLC_EGENERIC;

    if( !Init( p_input ) )
    {
        MainLoop( p_input, false );
        End( p_input );
    }

    vlc_object_release( p_input );
    return VLC_SUCCESS;
}",1,1,input\input.c,input_Read,,false,144,158,input_Read,,,29,"int input_Read (vlc_object_t*,input_item_t*)"
53021,METHOD,input\input.c:<global>,TYPE_DECL,"input_thread_t *input_CreatePreparser( vlc_object_t *parent,
                                       input_item_t *item )
{
    return Create( parent, item, NULL, true, NULL, NULL );
}",1,1,input\input.c,input_CreatePreparser,,false,160,164,input_CreatePreparser,,,30,"input_thread_t input_CreatePreparser (vlc_object_t*,input_item_t*)"
53035,METHOD,input\input.c:<global>,TYPE_DECL,"int input_Start( input_thread_t *p_input )
{
    input_thread_private_t *priv = input_priv(p_input);
    void *(*func)(void *) = Run;

    if( priv->b_preparsing )
        func = Preparse;

    assert( !priv->is_running );
    /* Create thread and wait for its readiness. */
    priv->is_running = !vlc_clone( &priv->thread, func, priv,
                                   VLC_THREAD_PRIORITY_INPUT );
    if( !priv->is_running )
    {
        input_ChangeState( p_input, ERROR_S );
        msg_Err( p_input, ""cannot create input thread"" );
        return VLC_EGENERIC;
    }
    return VLC_SUCCESS;
}",1,1,input\input.c,input_Start,,false,173,192,input_Start,,,31,int input_Start (input_thread_t*)
53043,METHOD,input\input.c:<global>,TYPE_DECL,void *(*func)(void *) = Run;,10,31,input\input.c,input_Start.func,,false,176,176,func,,,3,void* input_Start.func (void*)
53092,METHOD,input\input.c:<global>,TYPE_DECL,"void input_Stop( input_thread_t *p_input )
{
    input_thread_private_t *sys = input_priv(p_input);

    vlc_mutex_lock( &sys->lock_control );
    /* Discard all pending controls */
    for( int i = 0; i < sys->i_control; i++ )
    {
        input_control_t *ctrl = &sys->control[i];
        ControlRelease( ctrl->i_type, ctrl->val );
    }
    sys->i_control = 0;
    sys->is_stopped = true;
    vlc_cond_signal( &sys->wait_control );
    vlc_mutex_unlock( &sys->lock_control );
    vlc_interrupt_kill( &sys->interrupt );
}",1,1,input\input.c,input_Stop,,false,199,215,input_Stop,,,32,void input_Stop (input_thread_t*)
53162,METHOD,input\input.c:<global>,TYPE_DECL,"void input_Close( input_thread_t *p_input )
{
    if( input_priv(p_input)->is_running )
        vlc_join( input_priv(p_input)->thread, NULL );
    vlc_interrupt_deinit( &input_priv(p_input)->interrupt );
    vlc_object_release( p_input );
}",1,1,input\input.c,input_Close,,false,222,228,input_Close,,,33,void input_Close (input_thread_t*)
53187,METHOD,input\input.c:<global>,TYPE_DECL,"static void input_Destructor( vlc_object_t *obj )
{
    input_thread_t *p_input = (input_thread_t *)obj;
    input_thread_private_t *priv = input_priv(p_input);
#ifndef NDEBUG
    char * psz_name = input_item_GetName( priv->p_item );
    msg_Dbg( p_input, ""Destroying the input for '%s'"", psz_name);
    free( psz_name );
#endif

    if( priv->p_renderer )
        vlc_renderer_item_release( priv->p_renderer );
    if( priv->p_es_out_display )
        es_out_Delete( priv->p_es_out_display );

    if( priv->p_resource )
        input_resource_Release( priv->p_resource );
    if( priv->p_resource_private )
        input_resource_Release( priv->p_resource_private );

    input_item_Release( priv->p_item );

    vlc_mutex_destroy( &priv->counters.counters_lock );

    for( int i = 0; i < priv->i_control; i++ )
    {
        input_control_t *p_ctrl = &priv->control[i];
        ControlRelease( p_ctrl->i_type, p_ctrl->val );
    }

    vlc_cond_destroy( &priv->wait_control );
    vlc_mutex_de...",1,1,input\input.c,input_Destructor,,false,233,265,input_Destructor,,,34,void input_Destructor (vlc_object_t*)
53303,METHOD,input\input.c:<global>,TYPE_DECL,"input_item_t *input_GetItem( input_thread_t *p_input )
{
    assert( p_input != NULL );
    return input_priv(p_input)->p_item;
}",1,1,input\input.c,input_GetItem,,false,273,277,input_GetItem,,,35,input_item_t input_GetItem (input_thread_t*)
53317,METHOD,input\input.c:<global>,TYPE_DECL,"static input_thread_t *Create( vlc_object_t *p_parent, input_item_t *p_item,
                               const char *psz_header, bool b_preparsing,
                               input_resource_t *p_resource,
                               vlc_renderer_item_t *p_renderer )
{
    /* Allocate descriptor */
    input_thread_private_t *priv;

    priv = vlc_custom_create( p_parent, sizeof( *priv ), ""input"" );
    if( unlikely(priv == NULL) )
        return NULL;

    input_thread_t *p_input = &priv->input;

    char * psz_name = input_item_GetName( p_item );
    msg_Dbg( p_input, ""Creating an input for %s'%s'"",
             b_preparsing ? ""preparsing "" : """", psz_name);
    free( psz_name );

    /* Parse input options */
    input_item_ApplyOptions( VLC_OBJECT(p_input), p_item );

    p_input->obj.header = psz_header ? strdup( psz_header ) : NULL;

    /* Init Common fields */
    priv->b_preparsing = b_preparsing;
    priv->b_can_pace_control = true;
    priv->i_start = 0;
    priv-...",1,1,input\input.c,Create,,false,285,482,Create,,,36,"input_thread_t Create (vlc_object_t*,input_item_t*,char*,bool,input_resource_t*,vlc_renderer_item_t*)"
53914,METHOD,input\input.c:<global>,TYPE_DECL,"static void *Run( void *data )
{
    input_thread_private_t *priv = data;
    input_thread_t *p_input = &priv->input;

    vlc_interrupt_set(&priv->interrupt);

    if( !Init( p_input ) )
    {
        if( priv->b_can_pace_control && priv->b_out_pace_control )
        {
            /* We don't want a high input priority here or we'll
             * end-up sucking up all the CPU time */
            vlc_set_priority( priv->thread, VLC_THREAD_PRIORITY_LOW );
        }

        MainLoop( p_input, true ); /* FIXME it can be wrong (like with VLM) */

        /* Clean up */
        End( p_input );
    }

    input_SendEventDead( p_input );
    return NULL;
}",1,1,input\input.c,Run,,false,489,513,Run,,,37,void* Run (void*)
53963,METHOD,input\input.c:<global>,TYPE_DECL,"static void *Preparse( void *data )
{
    input_thread_private_t *priv = data;
    input_thread_t *p_input = &priv->input;

    vlc_interrupt_set(&priv->interrupt);

    if( !Init( p_input ) )
    {   /* if the demux is a playlist, call Mainloop that will call
         * demux_Demux in order to fetch sub items */
        bool b_is_playlist = false;

        if ( input_item_ShouldPreparseSubItems( priv->p_item )
          && demux_Control( priv->master->p_demux, DEMUX_IS_PLAYLIST,
                            &b_is_playlist ) )
            b_is_playlist = false;
        if( b_is_playlist )
            MainLoop( p_input, false );
        End( p_input );
    }

    input_SendEventDead( p_input );
    return NULL;
}",1,1,input\input.c,Preparse,,false,515,538,Preparse,,,38,void* Preparse (void*)
54024,METHOD,input\input.c:<global>,TYPE_DECL,"bool input_Stopped( input_thread_t *input )
{
    input_thread_private_t *sys = input_priv(input);
    bool ret;

    vlc_mutex_lock( &sys->lock_control );
    ret = sys->is_stopped;
    vlc_mutex_unlock( &sys->lock_control );
    return ret;
}",1,1,input\input.c,input_Stopped,,false,540,549,input_Stopped,,,39,bool input_Stopped (input_thread_t*)
54052,METHOD,input\input.c:<global>,TYPE_DECL,"static void MainLoopDemux( input_thread_t *p_input, bool *pb_changed )
{
    input_thread_private_t* p_priv = input_priv(p_input);
    demux_t *p_demux = p_priv->master->p_demux;
    int i_ret = VLC_DEMUXER_SUCCESS;

    *pb_changed = false;

    if( p_priv->i_stop > 0 )
    {
        if( demux_Control( p_demux, DEMUX_GET_TIME, &p_priv->i_time ) )
            p_priv->i_time = 0;

        if( p_priv->i_stop <= p_priv->i_time )
            i_ret = VLC_DEMUXER_EOF;
    }

    if( i_ret == VLC_DEMUXER_SUCCESS )
        i_ret = demux_Demux( p_demux );

    i_ret = i_ret > 0 ? VLC_DEMUXER_SUCCESS : ( i_ret < 0 ? VLC_DEMUXER_EGENERIC : VLC_DEMUXER_EOF);

    if( i_ret == VLC_DEMUXER_SUCCESS )
    {
        if( demux_TestAndClearFlags( p_demux, INPUT_UPDATE_TITLE_LIST ) )
            UpdateTitleListfromDemux( p_input );

        if( p_priv->master->b_title_demux )
        {
            i_ret = UpdateTitleSeekpointFromDemux( p_input );
            *pb_changed = true;
        }

        Updat...",1,1,input\input.c,MainLoopDemux,,false,559,607,MainLoopDemux,,,40,"void MainLoopDemux (input_thread_t*,bool*)"
54203,METHOD,input\input.c:<global>,TYPE_DECL,"static int MainLoopTryRepeat( input_thread_t *p_input )
{
    int i_repeat = var_GetInteger( p_input, ""input-repeat"" );
    if( i_repeat <= 0 )
        return VLC_EGENERIC;

    vlc_value_t val;

    msg_Dbg( p_input, ""repeating the same input (%d)"", i_repeat );
    if( i_repeat > 0 )
    {
        i_repeat--;
        var_SetInteger( p_input, ""input-repeat"", i_repeat );
    }

    /* Seek to start title/seekpoint */
    val.i_int = input_priv(p_input)->master->i_title_start -
        input_priv(p_input)->master->i_title_offset;
    if( val.i_int < 0 || val.i_int >= input_priv(p_input)->master->i_title )
        val.i_int = 0;
    input_ControlPush( p_input,
                       INPUT_CONTROL_SET_TITLE, &val );

    val.i_int = input_priv(p_input)->master->i_seekpoint_start -
        input_priv(p_input)->master->i_seekpoint_offset;
    if( val.i_int > 0 /* TODO: check upper boundary */ )
        input_ControlPush( p_input,
                           INPUT_CONTROL_SET_SEEKPOINT, &va...",1,1,input\input.c,MainLoopTryRepeat,,false,609,651,MainLoopTryRepeat,,,41,int MainLoopTryRepeat (input_thread_t*)
54346,METHOD,input\input.c:<global>,TYPE_DECL,"static void MainLoopStatistics( input_thread_t *p_input )
{
    double f_position = 0.0;
    mtime_t i_time = 0;
    mtime_t i_length = 0;

    /* update input status variables */
    if( demux_Control( input_priv(p_input)->master->p_demux,
                       DEMUX_GET_POSITION, &f_position ) )
        f_position = 0.0;

    if( demux_Control( input_priv(p_input)->master->p_demux,
                       DEMUX_GET_TIME, &i_time ) )
        i_time = 0;
    input_priv(p_input)->i_time = i_time;

    if( demux_Control( input_priv(p_input)->master->p_demux,
                       DEMUX_GET_LENGTH, &i_length ) )
        i_length = 0;

    es_out_SetTimes( input_priv(p_input)->p_es_out, f_position, i_time, i_length );

    /* update current bookmark */
    vlc_mutex_lock( &input_priv(p_input)->p_item->lock );
    input_priv(p_input)->bookmark.i_time_offset = i_time;
    vlc_mutex_unlock( &input_priv(p_input)->p_item->lock );

    stats_ComputeInputStats( p_input, input_priv(p_input)->p...",1,1,input\input.c,MainLoopStatistics,,false,656,685,MainLoopStatistics,,,42,void MainLoopStatistics (input_thread_t*)
54456,METHOD,input\input.c:<global>,TYPE_DECL,"static void MainLoop( input_thread_t *p_input, bool b_interactive )
{
    mtime_t i_intf_update = 0;
    mtime_t i_last_seek_mdate = 0;

    if( b_interactive && var_InheritBool( p_input, ""start-paused"" ) )
        ControlPause( p_input, mdate() );

    bool b_pause_after_eof = b_interactive &&
                           var_InheritBool( p_input, ""play-and-pause"" );
    bool b_paused_at_eof = false;

    demux_t *p_demux = input_priv(p_input)->master->p_demux;
    const bool b_can_demux = p_demux->pf_demux != NULL;

    while( !input_Stopped( p_input ) && input_priv(p_input)->i_state != ERROR_S )
    {
        mtime_t i_wakeup = -1;
        bool b_paused = input_priv(p_input)->i_state == PAUSE_S;
        /* FIXME if input_priv(p_input)->i_state == PAUSE_S the access/access_demux
         * is paused -> this may cause problem with some of them
         * The same problem can be seen when seeking while paused */
        if( b_paused )
            b_paused = !es_out_GetBuffering( input...",1,1,input\input.c,MainLoop,,false,691,813,MainLoop,,,43,"void MainLoop (input_thread_t*,bool)"
54779,METHOD,input\input.c:<global>,TYPE_DECL,"static void InitStatistics( input_thread_t *p_input )
{
    input_thread_private_t *priv = input_priv(p_input);

    if( priv->b_preparsing ) return;

    /* Prepare statistics */
#define INIT_COUNTER( c, compute ) free( priv->counters.p_##c ); \
    priv->counters.p_##c = \
 stats_CounterCreate( STATS_##compute);
    if( libvlc_stats( p_input ) )
    {
        INIT_COUNTER( read_bytes, COUNTER );
        INIT_COUNTER( read_packets, COUNTER );
        INIT_COUNTER( demux_read, COUNTER );
        INIT_COUNTER( input_bitrate, DERIVATIVE );
        INIT_COUNTER( demux_bitrate, DERIVATIVE );
        INIT_COUNTER( demux_corrupted, COUNTER );
        INIT_COUNTER( demux_discontinuity, COUNTER );
        INIT_COUNTER( played_abuffers, COUNTER );
        INIT_COUNTER( lost_abuffers, COUNTER );
        INIT_COUNTER( displayed_pictures, COUNTER );
        INIT_COUNTER( lost_pictures, COUNTER );
        INIT_COUNTER( decoded_audio, COUNTER );
        INIT_COUNTER( decoded_video, COUNTER );
   ...",1,8,input\input.c,InitStatistics,,false,815,845,InitStatistics,,,44,void InitStatistics (input_thread_t*)
55044,METHOD,input\input.c:<global>,TYPE_DECL,"static void InitTitle( input_thread_t * p_input )
{
    input_thread_private_t *priv = input_priv(p_input);
    input_source_t *p_master = priv->master;

    if( priv->b_preparsing )
        return;

    vlc_mutex_lock( &priv->p_item->lock );
    /* Create global title (from master) */
    priv->i_title = p_master->i_title;
    priv->title   = p_master->title;
    priv->i_title_offset = p_master->i_title_offset;
    priv->i_seekpoint_offset = p_master->i_seekpoint_offset;
    if( priv->i_title > 0 )
    {
        /* Setup variables */
        input_ControlVarNavigation( p_input );
        input_SendEventTitle( p_input, 0 );
    }

    /* Global flag */
    priv->b_can_pace_control = p_master->b_can_pace_control;
    priv->b_can_pause        = p_master->b_can_pause;
    priv->b_can_rate_control = p_master->b_can_rate_control;
    vlc_mutex_unlock( &priv->p_item->lock );
}",1,1,input\input.c,InitTitle,,false,898,924,InitTitle,,,45,void InitTitle (input_thread_t*)
55141,METHOD,input\input.c:<global>,TYPE_DECL,"static void StartTitle( input_thread_t * p_input )
{
    input_thread_private_t *priv = input_priv(p_input);
    vlc_value_t val;

    /* Start title/chapter */
    val.i_int = priv->master->i_title_start - priv->master->i_title_offset;
    if( val.i_int > 0 && val.i_int < priv->master->i_title )
        input_ControlPush( p_input, INPUT_CONTROL_SET_TITLE, &val );

    val.i_int = priv->master->i_seekpoint_start -
                priv->master->i_seekpoint_offset;
    if( val.i_int > 0 /* TODO: check upper boundary */ )
        input_ControlPush( p_input, INPUT_CONTROL_SET_SEEKPOINT, &val );

    /* Start/stop/run time */
    priv->i_start = llroundf(1000000.f
                                     * var_GetFloat( p_input, ""start-time"" ));
    priv->i_stop  = llroundf(1000000.f
                                     * var_GetFloat( p_input, ""stop-time"" ));
    if( priv->i_stop <= 0 )
    {
        priv->i_stop = llroundf(1000000.f
                                     * var_GetFloat( p_in...",1,1,input\input.c,StartTitle,,false,926,975,StartTitle,,,46,void StartTitle (input_thread_t*)
55328,METHOD,input\input.c:<global>,TYPE_DECL,"static int SlaveCompare(const void *a, const void *b)
{
    const input_item_slave_t *p_slave0 = *((const input_item_slave_t **) a);
    const input_item_slave_t *p_slave1 = *((const input_item_slave_t **) b);

    if( p_slave0 == NULL || p_slave1 == NULL )
    {
        /* Put NULL (or rejected) subs at the end */
        return p_slave0 == NULL ? 1 : p_slave1 == NULL ? -1 : 0;
    }

    if( p_slave0->i_priority > p_slave1->i_priority )
        return -1;

    if( p_slave0->i_priority < p_slave1->i_priority )
        return 1;

    return 0;
}",1,1,input\input.c,SlaveCompare,,false,977,995,SlaveCompare,,,47,"int SlaveCompare (void*,void*)"
55395,METHOD,input\input.c:<global>,TYPE_DECL,"static bool SlaveExists( input_item_slave_t **pp_slaves, int i_slaves,
                         const char *psz_uri)
{
    for( int i = 0; i < i_slaves; i++ )
    {
        if( pp_slaves[i] != NULL
         && !strcmp( pp_slaves[i]->psz_uri, psz_uri ) )
            return true;
    }
    return false;
}",1,1,input\input.c,SlaveExists,,false,997,1007,SlaveExists,,,48,"bool SlaveExists (input_item_slave_t**,int,char*)"
55434,METHOD,input\input.c:<global>,TYPE_DECL,"static void SetSubtitlesOptions( input_thread_t *p_input )
{
    /* Get fps and set it if not already set */
    const float f_fps = input_priv(p_input)->master->f_fps;
    if( f_fps > 1.f )
    {
        var_Create( p_input, ""sub-original-fps"", VLC_VAR_FLOAT );
        var_SetFloat( p_input, ""sub-original-fps"", f_fps );

        float f_requested_fps = var_CreateGetFloat( p_input, ""sub-fps"" );
        if( f_requested_fps != f_fps )
        {
            var_Create( p_input, ""sub-fps"", VLC_VAR_FLOAT|
                                            VLC_VAR_DOINHERIT );
            var_SetFloat( p_input, ""sub-fps"", f_requested_fps );
        }
    }

    const int i_delay = var_CreateGetInteger( p_input, ""sub-delay"" );
    if( i_delay != 0 )
        var_SetInteger( p_input, ""spu-delay"", (mtime_t)i_delay * 100000 );
}",1,1,input\input.c,SetSubtitlesOptions,,false,1009,1030,SetSubtitlesOptions,,,49,void SetSubtitlesOptions (input_thread_t*)
55501,METHOD,input\input.c:<global>,TYPE_DECL,"static enum slave_type DeduceSlaveType( input_thread_t *p_input,
                                        const char *psz_uri )
{
    vlc_url_t parsed_uri;
    if( vlc_UrlParse( &parsed_uri, psz_uri ) != VLC_SUCCESS ||
        parsed_uri.psz_path == NULL )
    {
        goto fail;
    }

    enum slave_type i_type;
    if( !input_item_slave_GetType( parsed_uri.psz_path, &i_type ) )
        goto fail;

    vlc_UrlClean( &parsed_uri );
    return i_type;

fail:
    msg_Dbg( p_input, ""Can't deduce slave type of \""%s\"" with file extension."",
             psz_uri );
    vlc_UrlClean( &parsed_uri );
    return SLAVE_TYPE_AUDIO;
}",1,1,input\input.c,DeduceSlaveType,,false,1032,1054,DeduceSlaveType,,,50,"enum slave_type DeduceSlaveType (input_thread_t*,char*)"
55549,METHOD,input\input.c:<global>,TYPE_DECL,"static void GetVarSlaves( input_thread_t *p_input,
                          input_item_slave_t ***ppp_slaves, int *p_slaves )
{
    char *psz = var_GetNonEmptyString( p_input, ""input-slave"" );
    if( !psz )
        return;

    input_item_slave_t **pp_slaves = *ppp_slaves;
    int i_slaves = *p_slaves;

    char *psz_org = psz;
    while( psz && *psz )
    {
        while( *psz == ' ' || *psz == '#' )
            psz++;

        char *psz_delim = strchr( psz, '#' );
        if( psz_delim )
            *psz_delim++ = '\0';

        if( *psz == 0 )
            break;

        char *uri = strstr(psz, ""://"")
                                   ? strdup( psz ) : vlc_path2uri( psz, NULL );
        psz = psz_delim;
        if( uri == NULL )
            continue;

        const enum slave_type i_type = DeduceSlaveType( p_input, uri );
        input_item_slave_t *p_slave =
            input_item_slave_New( uri, i_type, SLAVE_PRIORITY_USER );
        free( uri );

        if( unlikely( p_sla...",1,1,input\input.c,GetVarSlaves,,false,1056,1098,GetVarSlaves,,,51,"void GetVarSlaves (input_thread_t*,input_item_slave_t***,int*)"
55677,METHOD,input\input.c:<global>,TYPE_DECL,"static void LoadSlaves( input_thread_t *p_input )
{
    input_item_slave_t **pp_slaves;
    int i_slaves;
    TAB_INIT( i_slaves, pp_slaves );

    /* Look for and add slaves */

    char *psz_subtitle = var_GetNonEmptyString( p_input, ""sub-file"" );
    if( psz_subtitle != NULL )
    {
        msg_Dbg( p_input, ""forced subtitle: %s"", psz_subtitle );
        char *psz_uri = input_SubtitleFile2Uri( p_input, psz_subtitle );
        free( psz_subtitle );
        psz_subtitle = NULL;
        if( psz_uri != NULL )
        {
            input_item_slave_t *p_slave =
                input_item_slave_New( psz_uri, SLAVE_TYPE_SPU,
                                      SLAVE_PRIORITY_USER );
            free( psz_uri );
            if( p_slave )
            {
                TAB_APPEND(i_slaves, pp_slaves, p_slave);
                psz_subtitle = p_slave->psz_uri;
            }
        }
    }

    if( var_GetBool( p_input, ""sub-autodetect-file"" ) )
    {
        /* Add local subtitles */
    ...",1,29,input\input.c,LoadSlaves,,false,1100,1256,LoadSlaves,,,52,void LoadSlaves (input_thread_t*)
56184,METHOD,input\input.c:<global>,TYPE_DECL,"static void UpdatePtsDelay( input_thread_t *p_input )
{
    input_thread_private_t *p_sys = input_priv(p_input);

    /* Get max pts delay from input source */
    mtime_t i_pts_delay = p_sys->master->i_pts_delay;
    for( int i = 0; i < p_sys->i_slave; i++ )
        i_pts_delay = __MAX( i_pts_delay, p_sys->slave[i]->i_pts_delay );

    if( i_pts_delay < 0 )
        i_pts_delay = 0;

    /* Take care of audio/spu delay */
    const mtime_t i_audio_delay = var_GetInteger( p_input, ""audio-delay"" );
    const mtime_t i_spu_delay   = var_GetInteger( p_input, ""spu-delay"" );
    const mtime_t i_extra_delay = __MIN( i_audio_delay, i_spu_delay );
    if( i_extra_delay < 0 )
        i_pts_delay -= i_extra_delay;

    /* Update cr_average depending on the caching */
    const int i_cr_average = var_GetInteger( p_input, ""cr-average"" ) * i_pts_delay / DEFAULT_PTS_DELAY;

    /* */
    es_out_SetDelay( input_priv(p_input)->p_es_out_display, AUDIO_ES, i_audio_delay );
    es_out_SetDelay( input_p...",1,1,input\input.c,UpdatePtsDelay,,false,1258,1284,UpdatePtsDelay,,,53,void UpdatePtsDelay (input_thread_t*)
56292,METHOD,input\input.c:<global>,TYPE_DECL,"static void InitPrograms( input_thread_t * p_input )
{
    int i_es_out_mode;
    vlc_list_t list;

    /* Compute correct pts_delay */
    UpdatePtsDelay( p_input );

    /* Set up es_out */
    i_es_out_mode = ES_OUT_MODE_AUTO;
    if( input_priv(p_input)->p_sout && !input_priv(p_input)->p_renderer )
    {
        char *prgms;

        if( (prgms = var_GetNonEmptyString( p_input, ""programs"" )) != NULL )
        {
            char *buf;

            TAB_INIT( list.i_count, list.p_values );
            for( const char *prgm = strtok_r( prgms, "","", &buf );
                 prgm != NULL;
                 prgm = strtok_r( NULL, "","", &buf ) )
            {
                vlc_value_t val = { .i_int = atoi( prgm ) };
                TAB_APPEND(list.i_count, list.p_values, val);
            }

            if( list.i_count > 0 )
                i_es_out_mode = ES_OUT_MODE_PARTIAL;
                /* Note : we should remove the ""program"" callback. */

            free( prgms );
        }
  ...",1,1,input\input.c,InitPrograms,,false,1286,1342,InitPrograms,,,54,void InitPrograms (input_thread_t*)
56458,METHOD,input\input.c:<global>,TYPE_DECL,"static int Init( input_thread_t * p_input )
{
    input_thread_private_t *priv = input_priv(p_input);
    input_source_t *master;

    if( var_Type( p_input->obj.parent, ""meta-file"" ) )
    {
        msg_Dbg( p_input, ""Input is a meta file: disabling unneeded options"" );
        var_SetString( p_input, ""sout"", """" );
        var_SetBool( p_input, ""sout-all"", false );
        var_SetString( p_input, ""input-slave"", """" );
        var_SetInteger( p_input, ""input-repeat"", 0 );
        var_SetString( p_input, ""sub-file"", """" );
        var_SetBool( p_input, ""sub-autodetect-file"", false );
    }

    InitStatistics( p_input );
#ifdef ENABLE_SOUT
    if( InitSout( p_input ) )
        goto error;
#endif

    /* Create es out */
    priv->p_es_out = input_EsOutTimeshiftNew( p_input, priv->p_es_out_display,
                                              priv->i_rate );
    if( priv->p_es_out == NULL )
        goto error;

    /* */
    input_ChangeState( p_input, OPENING_S );
    input_SendEventC...",1,8,input\input.c,Init,,false,1344,1493,Init,,,55,int Init (input_thread_t*)
57285,METHOD,input\input.c:<global>,TYPE_DECL,"static void End( input_thread_t * p_input )
{
    input_thread_private_t *priv = input_priv(p_input);

    /* We are at the end */
    input_ChangeState( p_input, END_S );

    /* Clean control variables */
    input_ControlVarStop( p_input );

    /* Stop es out activity */
    es_out_SetMode( priv->p_es_out, ES_OUT_MODE_NONE );

    /* Delete slave */
    for( int i = 0; i < priv->i_slave; i++ )
        InputSourceDestroy( priv->slave[i] );
    free( priv->slave );

    /* Clean up master */
    InputSourceDestroy( priv->master );
    priv->i_title = 0;
    priv->title = NULL;
    priv->i_title_offset = 0;
    priv->i_seekpoint_offset = 0;

    /* Unload all modules */
    if( priv->p_es_out )
        es_out_Delete( priv->p_es_out );
    es_out_SetMode( priv->p_es_out_display, ES_OUT_MODE_END );

    if( !priv->b_preparsing )
    {
#define CL_CO( c ) \
do { \
    stats_CounterClean( priv->counters.p_##c ); \
    priv->counters.p_##c = NULL; \
} while (0)

        if( libvlc_stats(...",1,12,input\input.c,End,,false,1498,1589,End,,,56,void End (input_thread_t*)
57804,METHOD,input\input.c:<global>,TYPE_DECL,"void input_ControlPush( input_thread_t *p_input,
                        int i_type, vlc_value_t *p_val )
{
    input_thread_private_t *sys = input_priv(p_input);

    vlc_mutex_lock( &sys->lock_control );
    if( sys->is_stopped || sys->i_control >= INPUT_CONTROL_FIFO_SIZE )
    {
        if( sys->is_stopped )
            msg_Dbg( p_input, ""input control stopped, trashing type=%d"",
                     i_type );
        else
            msg_Err( p_input, ""input control fifo overflow, trashing type=%d"",
                     i_type );
        if( p_val )
            ControlRelease( i_type, *p_val );
    }
    else
    {
        input_control_t c;
        c.i_type = i_type;
        if( p_val )
            c.val = *p_val;
        else
            memset( &c.val, 0, sizeof(c.val) );

        sys->control[sys->i_control++] = c;

        vlc_cond_signal( &sys->wait_control );
    }
    vlc_mutex_unlock( &sys->lock_control );
}",1,45,input\input.c,input_ControlPush,,false,1594,1625,input_ControlPush,,,57,"void input_ControlPush (input_thread_t*,int,vlc_value_t*)"
57905,METHOD,input\input.c:<global>,TYPE_DECL,"static int ControlGetReducedIndexLocked( input_thread_t *p_input )
{
    const int i_lt = input_priv(p_input)->control[0].i_type;
    int i;
    for( i = 1; i < input_priv(p_input)->i_control; i++ )
    {
        const int i_ct = input_priv(p_input)->control[i].i_type;

        if( i_lt == i_ct &&
            ( i_ct == INPUT_CONTROL_SET_STATE ||
              i_ct == INPUT_CONTROL_SET_RATE ||
              i_ct == INPUT_CONTROL_SET_POSITION ||
              i_ct == INPUT_CONTROL_SET_TIME ||
              i_ct == INPUT_CONTROL_SET_PROGRAM ||
              i_ct == INPUT_CONTROL_SET_TITLE ||
              i_ct == INPUT_CONTROL_SET_SEEKPOINT ||
              i_ct == INPUT_CONTROL_SET_BOOKMARK ) )
        {
            continue;
        }
        else
        {
            /* TODO but that's not that important
                - merge SET_X with SET_X_CMD
                - ignore SET_SEEKPOINT/SET_POSITION/SET_TIME before a SET_TITLE
                - ignore SET_SEEKPOINT/SET_POSITION/SET...",1,1,input\input.c,ControlGetReducedIndexLocked,,false,1627,1659,ControlGetReducedIndexLocked,,,58,int ControlGetReducedIndexLocked (input_thread_t*)
57992,METHOD,input\input.c:<global>,TYPE_DECL,"static inline int ControlPop( input_thread_t *p_input,
                              int *pi_type, vlc_value_t *p_val,
                              mtime_t i_deadline, bool b_postpone_seek )
{
    input_thread_private_t *p_sys = input_priv(p_input);

    vlc_mutex_lock( &p_sys->lock_control );
    while( p_sys->i_control <= 0 ||
           ( b_postpone_seek && ControlIsSeekRequest( p_sys->control[0].i_type ) ) )
    {
        if( p_sys->is_stopped )
        {
            vlc_mutex_unlock( &p_sys->lock_control );
            return VLC_EGENERIC;
        }

        if( i_deadline >= 0 )
        {
            if( vlc_cond_timedwait( &p_sys->wait_control, &p_sys->lock_control,
                                    i_deadline ) )
            {
                vlc_mutex_unlock( &p_sys->lock_control );
                return VLC_EGENERIC;
            }
        }
        else
            vlc_cond_wait( &p_sys->wait_control, &p_sys->lock_control );
    }

    /* */
    const int i_index = Con...",1,1,input\input.c,ControlPop,,false,1662,1711,ControlPop,,,59,"int ControlPop (input_thread_t*,int*,vlc_value_t*,mtime_t,bool)"
58173,METHOD,input\input.c:<global>,TYPE_DECL,"static bool ControlIsSeekRequest( int i_type )
{
    switch( i_type )
    {
    case INPUT_CONTROL_SET_POSITION:
    case INPUT_CONTROL_SET_TIME:
    case INPUT_CONTROL_SET_TITLE:
    case INPUT_CONTROL_SET_TITLE_NEXT:
    case INPUT_CONTROL_SET_TITLE_PREV:
    case INPUT_CONTROL_SET_SEEKPOINT:
    case INPUT_CONTROL_SET_SEEKPOINT_NEXT:
    case INPUT_CONTROL_SET_SEEKPOINT_PREV:
    case INPUT_CONTROL_SET_BOOKMARK:
    case INPUT_CONTROL_NAV_ACTIVATE:
    case INPUT_CONTROL_NAV_UP:
    case INPUT_CONTROL_NAV_DOWN:
    case INPUT_CONTROL_NAV_LEFT:
    case INPUT_CONTROL_NAV_RIGHT:
    case INPUT_CONTROL_NAV_POPUP:
    case INPUT_CONTROL_NAV_MENU:
        return true;
    default:
        return false;
    }
}",1,1,input\input.c,ControlIsSeekRequest,,false,1712,1736,ControlIsSeekRequest,,,60,bool ControlIsSeekRequest (int)
58218,METHOD,input\input.c:<global>,TYPE_DECL,"static void ControlRelease( int i_type, vlc_value_t val )
{
    switch( i_type )
    {
    case INPUT_CONTROL_ADD_SLAVE:
        if( val.p_address )
            input_item_slave_Delete( val.p_address );
        break;
    case INPUT_CONTROL_SET_VIEWPOINT:
    case INPUT_CONTROL_SET_INITIAL_VIEWPOINT:
    case INPUT_CONTROL_UPDATE_VIEWPOINT:
        free( val.p_address );
        break;
    case INPUT_CONTROL_SET_RENDERER:
        if( val.p_address )
            vlc_renderer_item_release( val.p_address );
        break;

    default:
        break;
    }
}",1,1,input\input.c,ControlRelease,,false,1738,1759,ControlRelease,,,61,"void ControlRelease (int,vlc_value_t)"
58264,METHOD,input\input.c:<global>,TYPE_DECL,"static void ControlPause( input_thread_t *p_input, mtime_t i_control_date )
{
    int i_state = PAUSE_S;

    if( input_priv(p_input)->b_can_pause )
    {
        demux_t *p_demux = input_priv(p_input)->master->p_demux;

        if( demux_Control( p_demux, DEMUX_SET_PAUSE_STATE, true ) )
        {
            msg_Warn( p_input, ""cannot set pause state"" );
            return;
        }
    }

    /* */
    if( es_out_SetPauseState( input_priv(p_input)->p_es_out, input_priv(p_input)->b_can_pause,
                              true, i_control_date ) )
    {
        msg_Warn( p_input, ""cannot set pause state at es_out level"" );
        return;
    }

    /* Switch to new state */
    input_ChangeState( p_input, i_state );
}",1,1,input\input.c,ControlPause,,false,1762,1787,ControlPause,,,62,"void ControlPause (input_thread_t*,mtime_t)"
58319,METHOD,input\input.c:<global>,TYPE_DECL,"static void ControlUnpause( input_thread_t *p_input, mtime_t i_control_date )
{
    if( input_priv(p_input)->b_can_pause )
    {
        demux_t *p_demux = input_priv(p_input)->master->p_demux;

        if( demux_Control( p_demux, DEMUX_SET_PAUSE_STATE, false ) )
        {
            msg_Err( p_input, ""cannot resume"" );
            input_ChangeState( p_input, ERROR_S );
            return;
        }
    }

    /* Switch to play */
    input_ChangeState( p_input, PLAYING_S );
    es_out_SetPauseState( input_priv(p_input)->p_es_out, false, false, i_control_date );
}",1,1,input\input.c,ControlUnpause,,false,1789,1806,ControlUnpause,,,63,"void ControlUnpause (input_thread_t*,mtime_t)"
58364,METHOD,input\input.c:<global>,TYPE_DECL,"static void ViewpointApply( input_thread_t *p_input )
{
    input_thread_private_t *priv = input_priv(p_input);

    vlc_viewpoint_clip( &priv->viewpoint );

    vout_thread_t **pp_vout;
    size_t i_vout;
    input_resource_HoldVouts( priv->p_resource, &pp_vout, &i_vout );

    for( size_t i = 0; i < i_vout; ++i )
    {
        var_SetAddress( pp_vout[i], ""viewpoint"", &priv->viewpoint );
        /* This variable can only be read from callbacks */
        var_Change( pp_vout[i], ""viewpoint"", VLC_VAR_SETVALUE,
                    &(vlc_value_t) { .p_address = NULL }, NULL );
        vlc_object_release( pp_vout[i] );
    }
    free( pp_vout );

    audio_output_t *p_aout = input_resource_HoldAout( priv->p_resource );
    if( p_aout )
    {

        var_SetAddress( p_aout, ""viewpoint"", &priv->viewpoint );
        /* This variable can only be read from callbacks */
        var_Change( p_aout, ""viewpoint"", VLC_VAR_SETVALUE,
                    &(vlc_value_t) { .p_address = NULL }, NULL )...",1,1,input\input.c,ViewpointApply,,false,1808,1838,ViewpointApply,,,64,void ViewpointApply (input_thread_t*)
58463,METHOD,input\input.c:<global>,TYPE_DECL,"static void ControlNavDisplayVolume( vout_thread_t *p_vout, float vol )
{
    vout_FlushSubpictureChannel( p_vout, VOUT_SPU_CHANNEL_OSD );
    vout_OSDMessage( p_vout, VOUT_SPU_CHANNEL_OSD, _( ""Volume %ld%%"" ),
                     lroundf( vol * 100.f ) );
}",1,1,input\input.c,ControlNavDisplayVolume,,false,1843,1848,ControlNavDisplayVolume,,,65,"void ControlNavDisplayVolume (vout_thread_t*,float)"
58481,METHOD,input\input.c:<global>,TYPE_DECL,"static void ControlNavDisplayPosition( vout_thread_t *p_vout,
                                       input_thread_t *p_input )
{
    vout_FlushSubpictureChannel( p_vout, VOUT_SPU_CHANNEL_OSD );

    int64_t t = var_GetInteger( p_input, ""time"" ) / CLOCK_FREQ;
    int64_t l = var_GetInteger( p_input, ""length"" ) / CLOCK_FREQ;

    char psz_time[MSTRTIME_MAX_SIZE];
    secstotimestr( psz_time, t );

    if( l > 0 )
    {
        char psz_duration[MSTRTIME_MAX_SIZE];

        secstotimestr( psz_duration, l );
        vout_OSDMessage( p_vout, VOUT_SPU_CHANNEL_OSD,
                         ""%s / %s"", psz_time, psz_duration );
    }
    else if( t > 0 )
    {
        vout_OSDMessage( p_vout, VOUT_SPU_CHANNEL_OSD, ""%s"", psz_time );
    }
}",1,1,input\input.c,ControlNavDisplayPosition,,false,1850,1873,ControlNavDisplayPosition,,,66,"void ControlNavDisplayPosition (vout_thread_t*,input_thread_t*)"
58537,METHOD,input\input.c:<global>,TYPE_DECL,"static void ControlNav( input_thread_t *p_input, int i_type )
{
    input_thread_private_t *priv = input_priv(p_input);

    if( !demux_Control( priv->master->p_demux, i_type
                        - INPUT_CONTROL_NAV_ACTIVATE + DEMUX_NAV_ACTIVATE ) )
        return; /* The demux handled the navigation control */

    /* Handle Up/Down/Left/Right if the demux can't navigate */
    vlc_viewpoint_t vp = {};
    int vol_direction = 0;
    int seek_direction = 0;
    switch( i_type )
    {
        case INPUT_CONTROL_NAV_UP:
            vol_direction = 1;
            vp.pitch = -1.f;
            break;
        case INPUT_CONTROL_NAV_DOWN:
            vol_direction = -1;
            vp.pitch = 1.f;
            break;
        case INPUT_CONTROL_NAV_LEFT:
            seek_direction = -1;
            vp.yaw = -1.f;
            break;
        case INPUT_CONTROL_NAV_RIGHT:
            seek_direction = 1;
            vp.yaw = 1.f;
            break;
        case INPUT_CONTROL_NAV_ACTIVATE:
   ...",1,1,input\input.c,ControlNav,,false,1875,1962,ControlNav,,,67,"void ControlNav (input_thread_t*,int)"
58802,METHOD,input\input.c:<global>,TYPE_DECL,"static void ControlInsertDemuxFilter( input_thread_t* p_input, const char* psz_demux_chain )
{
    input_source_t *p_inputSource = input_priv(p_input)->master;
    demux_t *p_filtered_demux = demux_FilterChainNew( p_inputSource->p_demux, psz_demux_chain );
    if ( p_filtered_demux != NULL )
        p_inputSource->p_demux = p_filtered_demux;
    else if ( psz_demux_chain != NULL )
        msg_Dbg(p_input, ""Failed to create demux filter %s"", psz_demux_chain);
}",1,1,input\input.c,ControlInsertDemuxFilter,,false,1984,1992,ControlInsertDemuxFilter,,,68,"void ControlInsertDemuxFilter (input_thread_t*,char*)"
58844,METHOD,input\input.c:<global>,TYPE_DECL,"static bool Control( input_thread_t *p_input,
                     int i_type, vlc_value_t val )
{
    const mtime_t i_control_date = mdate();
    /* FIXME b_force_update is abused, it should be carefully checked */
    bool b_force_update = false;

    if( !p_input )
        return b_force_update;

    switch( i_type )
    {
        case INPUT_CONTROL_SET_POSITION:
        {
            if( input_priv(p_input)->b_recording )
            {
                msg_Err( p_input, ""INPUT_CONTROL_SET_POSITION ignored while recording"" );
                break;
            }

            float f_pos = val.f_float;
            if( f_pos < 0.f )
                f_pos = 0.f;
            else if( f_pos > 1.f )
                f_pos = 1.f;
            /* Reset the decoders states and clock sync (before calling the demuxer */
            es_out_SetTime( input_priv(p_input)->p_es_out, -1 );
            if( demux_Control( input_priv(p_input)->master->p_demux, DEMUX_SET_POSITION,
                      ...",1,35,input\input.c,Control,,false,1994,2460,Control,,,69,"bool Control (input_thread_t*,int,vlc_value_t)"
60086,METHOD,input\input.c:<global>,TYPE_DECL,"static int UpdateTitleSeekpoint( input_thread_t *p_input,
                                 int i_title, int i_seekpoint )
{
    int i_title_end = input_priv(p_input)->master->i_title_end -
                        input_priv(p_input)->master->i_title_offset;
    int i_seekpoint_end = input_priv(p_input)->master->i_seekpoint_end -
                            input_priv(p_input)->master->i_seekpoint_offset;

    if( i_title_end >= 0 && i_seekpoint_end >= 0 )
    {
        if( i_title > i_title_end ||
            ( i_title == i_title_end && i_seekpoint > i_seekpoint_end ) )
            return VLC_DEMUXER_EOF;
    }
    else if( i_seekpoint_end >= 0 )
    {
        if( i_seekpoint > i_seekpoint_end )
            return VLC_DEMUXER_EOF;
    }
    else if( i_title_end >= 0 )
    {
        if( i_title > i_title_end )
            return VLC_DEMUXER_EOF;
    }
    return VLC_DEMUXER_SUCCESS;
}",1,1,input\input.c,UpdateTitleSeekpoint,,false,2465,2490,UpdateTitleSeekpoint,,,70,"int UpdateTitleSeekpoint (input_thread_t*,int,int)"
60179,METHOD,input\input.c:<global>,TYPE_DECL,"static int UpdateTitleSeekpointFromDemux( input_thread_t *p_input )
{
    demux_t *p_demux = input_priv(p_input)->master->p_demux;

    /* TODO event-like */
    if( demux_TestAndClearFlags( p_demux, INPUT_UPDATE_TITLE ) )
        input_SendEventTitle( p_input, demux_GetTitle( p_demux ) );

    if( demux_TestAndClearFlags( p_demux, INPUT_UPDATE_SEEKPOINT ) )
        input_SendEventSeekpoint( p_input, demux_GetTitle( p_demux ),
                                  demux_GetSeekpoint( p_demux ) );

    return UpdateTitleSeekpoint( p_input,
                                 demux_GetTitle( p_demux ),
                                 demux_GetSeekpoint( p_demux ) );
}",1,1,input\input.c,UpdateTitleSeekpointFromDemux,,false,2494,2509,UpdateTitleSeekpointFromDemux,,,71,int UpdateTitleSeekpointFromDemux (input_thread_t*)
60220,METHOD,input\input.c:<global>,TYPE_DECL,"static void UpdateGenericFromDemux( input_thread_t *p_input )
{
    demux_t *p_demux = input_priv(p_input)->master->p_demux;

    if( demux_TestAndClearFlags( p_demux, INPUT_UPDATE_META ) )
        InputUpdateMeta( p_input, p_demux );

    {
        double quality;
        double strength;

        if( !demux_Control( p_demux, DEMUX_GET_SIGNAL, &quality, &strength ) )
            input_SendEventSignal( p_input, quality, strength );
    }
}",1,1,input\input.c,UpdateGenericFromDemux,,false,2511,2525,UpdateGenericFromDemux,,,72,void UpdateGenericFromDemux (input_thread_t*)
60259,METHOD,input\input.c:<global>,TYPE_DECL,"static void UpdateTitleListfromDemux( input_thread_t *p_input )
{
    input_thread_private_t *priv = input_priv(p_input);
    input_source_t *in = priv->master;

    vlc_mutex_lock( &priv->p_item->lock );
    /* Delete the preexisting titles */
    if( in->i_title > 0 )
    {
        for( int i = 0; i < in->i_title; i++ )
            vlc_input_title_Delete( in->title[i] );
        TAB_CLEAN( in->i_title, in->title );
        priv->i_title = 0;
        priv->title = NULL;
        in->b_title_demux = false;
    }

    /* Get the new title list */
    if( demux_Control( in->p_demux, DEMUX_GET_TITLE_INFO,
                       &in->title, &in->i_title,
                       &in->i_title_offset, &in->i_seekpoint_offset ) )
        TAB_INIT( in->i_title, in->title );
    else
        in->b_title_demux = true;

    vlc_mutex_unlock( &priv->p_item->lock );

    InitTitle( p_input );
}",1,1,input\input.c,UpdateTitleListfromDemux,,false,2527,2555,UpdateTitleListfromDemux,,,73,void UpdateTitleListfromDemux (input_thread_t*)
60376,METHOD,input\input.c:<global>,TYPE_DECL,"static int
InputStreamHandleAnchor( input_source_t *source, stream_t **stream,
                         char const *anchor )
{
    char const* extra;
    if( stream_extractor_AttachParsed( stream, anchor, &extra ) )
    {
        msg_Err( source, ""unable to attach stream-extractors for %s"",
            (*stream)->psz_url );

        return VLC_EGENERIC;
    }

    if( vlc_stream_directory_Attach( stream, NULL ) )
        msg_Dbg( source, ""attachment of directory-extractor failed for %s"",
            (*stream)->psz_url );

    MRLSections( extra ? extra : """",
        &source->i_title_start, &source->i_title_end,
        &source->i_seekpoint_start, &source->i_seekpoint_end );

    return VLC_SUCCESS;
}",1,1,input\input.c,InputStreamHandleAnchor,,false,2557,2579,InputStreamHandleAnchor,,,74,"int InputStreamHandleAnchor (input_source_t*,stream_t**,char*)"
60435,METHOD,input\input.c:<global>,TYPE_DECL,"static demux_t *InputDemuxNew( input_thread_t *p_input, input_source_t *p_source,
                               const char *psz_access, const char *psz_demux,
                               const char *psz_path, const char *psz_anchor )
{
    input_thread_private_t *priv = input_priv(p_input );
    demux_t *p_demux = NULL;

    /* first, try to create an access demux */
    p_demux = demux_NewAdvanced( VLC_OBJECT( p_source ), p_input,
                                 psz_access, psz_demux, psz_path,
                                 NULL, priv->p_es_out, priv->b_preparsing );
    if( p_demux )
    {
        MRLSections( psz_anchor,
            &p_source->i_title_start, &p_source->i_title_end,
            &p_source->i_seekpoint_start, &p_source->i_seekpoint_end );

        return p_demux;
    }

    /* not an access-demux: create the underlying access stream */
    char *psz_base_mrl;

    if( asprintf( &psz_base_mrl, ""%s://%s"", psz_access, psz_path ) < 0 )
        return NULL;

    ...",1,14,input\input.c,InputDemuxNew,,false,2581,2646,InputDemuxNew,,,75,"demux_t InputDemuxNew (input_thread_t*,input_source_t*,char*,char*,char*,char*)"
60624,METHOD,input\input.c:<global>,TYPE_DECL,"static input_source_t *InputSourceNew( input_thread_t *p_input,
                                       const char *psz_mrl,
                                       const char *psz_forced_demux,
                                       bool b_in_can_fail )
{
    input_thread_private_t *priv = input_priv(p_input);
    input_source_t *in = vlc_custom_create( p_input, sizeof( *in ),
                                            ""input source"" );
    if( unlikely(in == NULL) )
        return NULL;

    const char *psz_access, *psz_demux, *psz_path, *psz_anchor = NULL;

    assert( psz_mrl );
    char *psz_dup = strdup( psz_mrl );
    char *psz_demux_var = NULL;

    if( psz_dup == NULL )
    {
        vlc_object_release( in );
        return NULL;
    }

    /* Split uri */
    input_SplitMRL( &psz_access, &psz_demux, &psz_path, &psz_anchor, psz_dup );

    if( psz_demux == NULL || psz_demux[0] == '\0' )
        psz_demux = psz_demux_var = var_InheritString( in, ""demux"" );

    if( psz_forced...",1,30,input\input.c,InputSourceNew,,false,2651,2866,InputSourceNew,,,76,"input_source_t InputSourceNew (input_thread_t*,char*,char*,bool)"
61301,METHOD,input\input.c:<global>,TYPE_DECL,"static void InputSourceDestroy( input_source_t *in )
{
    int i;

    if( in->p_demux )
        demux_Delete( in->p_demux );

    if( in->i_title > 0 )
    {
        for( i = 0; i < in->i_title; i++ )
            vlc_input_title_Delete( in->title[i] );
        TAB_CLEAN( in->i_title, in->title );
    }

    vlc_object_release( in );
}",1,1,input\input.c,InputSourceDestroy,,false,2871,2886,InputSourceDestroy,,,77,void InputSourceDestroy (input_source_t*)
61350,METHOD,input\input.c:<global>,TYPE_DECL,"static void InputSourceMeta( input_thread_t *p_input,
                             input_source_t *p_source, vlc_meta_t *p_meta )
{
    demux_t *p_demux = p_source->p_demux;

    /* XXX Remember that checking against p_item->p_meta->i_status & ITEM_PREPARSED
     * is a bad idea */

    bool has_meta = false;

    /* Read demux meta */
    if( !demux_Control( p_demux, DEMUX_GET_META, p_meta ) )
        has_meta = true;

    bool has_unsupported;
    if( demux_Control( p_demux, DEMUX_HAS_UNSUPPORTED_META, &has_unsupported ) )
        has_unsupported = true;

    /* If the demux report unsupported meta data, or if we don't have meta data
     * try an external ""meta reader"" */
    if( has_meta && !has_unsupported )
        return;

    demux_meta_t *p_demux_meta =
        vlc_custom_create( p_source, sizeof( *p_demux_meta ), ""demux meta"" );
    if( unlikely(p_demux_meta == NULL) )
        return;
    p_demux_meta->p_item = input_priv(p_input)->p_item;

    module_t *p_id3 = module_nee...",1,1,input\input.c,InputSourceMeta,,false,2891,2939,InputSourceMeta,,,78,"void InputSourceMeta (input_thread_t*,input_source_t*,vlc_meta_t*)"
61495,METHOD,input\input.c:<global>,TYPE_DECL,"static void SlaveDemux( input_thread_t *p_input )
{
    int64_t i_time;
    int i;

    if( demux_Control( input_priv(p_input)->master->p_demux, DEMUX_GET_TIME, &i_time ) )
    {
        msg_Err( p_input, ""demux doesn't like DEMUX_GET_TIME"" );
        return;
    }

    for( i = 0; i < input_priv(p_input)->i_slave; i++ )
    {
        input_source_t *in = input_priv(p_input)->slave[i];
        int i_ret;

        if( in->b_eof )
            continue;

        /* Call demux_Demux until we have read enough data */
        if( demux_Control( in->p_demux, DEMUX_SET_NEXT_DEMUX_TIME, i_time ) )
        {
            for( ;; )
            {
                int64_t i_stime;
                if( demux_Control( in->p_demux, DEMUX_GET_TIME, &i_stime ) )
                {
                    msg_Err( p_input, ""slave[%d] doesn't like ""
                             ""DEMUX_GET_TIME -> EOF"", i );
                    i_ret = 0;
                    break;
                }

                if( i_stime...",1,1,input\input.c,SlaveDemux,,false,2942,2996,SlaveDemux,,,79,void SlaveDemux (input_thread_t*)
61619,METHOD,input\input.c:<global>,TYPE_DECL,"static void SlaveSeek( input_thread_t *p_input )
{
    int64_t i_time;
    int i;

    if( demux_Control( input_priv(p_input)->master->p_demux, DEMUX_GET_TIME, &i_time ) )
    {
        msg_Err( p_input, ""demux doesn't like DEMUX_GET_TIME"" );
        return;
    }

    for( i = 0; i < input_priv(p_input)->i_slave; i++ )
    {
        input_source_t *in = input_priv(p_input)->slave[i];

        if( demux_Control( in->p_demux, DEMUX_SET_TIME, i_time, true ) )
        {
            if( !in->b_eof )
                msg_Err( p_input, ""seek failed for slave %d -> EOF"", i );
            in->b_eof = true;
        }
        else
        {
            in->b_eof = false;
        }
    }
}",1,1,input\input.c,SlaveSeek,,false,2998,3024,SlaveSeek,,,80,void SlaveSeek (input_thread_t*)
61696,METHOD,input\input.c:<global>,TYPE_DECL,"static void InputMetaUser( input_thread_t *p_input, vlc_meta_t *p_meta )
{
    static const struct { int i_meta; const char *psz_name; } p_list[] = {
        { vlc_meta_Title,       ""meta-title"" },
        { vlc_meta_Artist,      ""meta-artist"" },
        { vlc_meta_Genre,       ""meta-genre"" },
        { vlc_meta_Copyright,   ""meta-copyright"" },
        { vlc_meta_Description, ""meta-description"" },
        { vlc_meta_Date,        ""meta-date"" },
        { vlc_meta_URL,         ""meta-url"" },
        { 0, NULL }
    };

    /* Get meta information from user */
    for( int i = 0; p_list[i].psz_name; i++ )
    {
        char *psz_string = var_GetNonEmptyString( p_input, p_list[i].psz_name );
        if( !psz_string )
            continue;

        EnsureUTF8( psz_string );
        vlc_meta_Set( p_meta, p_list[i].i_meta, psz_string );
        free( psz_string );
    }
}",1,1,input\input.c,InputMetaUser,,false,3029,3053,InputMetaUser,,,81,"void InputMetaUser (input_thread_t*,vlc_meta_t*)"
61771,METHOD,input\input.c:<global>,TYPE_DECL,"static void AppendAttachment( int *pi_attachment, input_attachment_t ***ppp_attachment,
                              const demux_t ***ppp_attachment_demux,
                              int i_new, input_attachment_t **pp_new, const demux_t *p_demux )
{
    int i_attachment = *pi_attachment;
    int i;

    input_attachment_t **pp_att = realloc( *ppp_attachment,
                    sizeof(*pp_att) * ( i_attachment + i_new ) );
    if( likely(pp_att) )
    {
        *ppp_attachment = pp_att;
        const demux_t **pp_attdmx = realloc( *ppp_attachment_demux,
                        sizeof(*pp_attdmx) * ( i_attachment + i_new ) );
        if( likely(pp_attdmx) )
        {
            *ppp_attachment_demux = pp_attdmx;

            for( i = 0; i < i_new; i++ )
            {
                pp_att[i_attachment] = pp_new[i];
                pp_attdmx[i_attachment++] = p_demux;
            }
            /* */
            *pi_attachment = i_attachment;
            free( pp_new );
         ...",1,1,input\input.c,AppendAttachment,,false,3055,3089,AppendAttachment,,,82,"void AppendAttachment (int*,input_attachment_t***,demux_t***,int,input_attachment_t**,demux_t*)"
61876,METHOD,input\input.c:<global>,TYPE_DECL,"static void InputUpdateMeta( input_thread_t *p_input, demux_t *p_demux )
{
    vlc_meta_t *p_meta = vlc_meta_New();
    if( unlikely(p_meta == NULL) )
        return;

    demux_Control( p_demux, DEMUX_GET_META, p_meta );

    /* If metadata changed, then the attachments might have changed.
       We need to update them in case they contain album art. */
    input_attachment_t **attachment;
    int i_attachment;

    if( !demux_Control( p_demux, DEMUX_GET_ATTACHMENTS,
                        &attachment, &i_attachment ) )
    {
        vlc_mutex_lock( &input_priv(p_input)->p_item->lock );
        if( input_priv(p_input)->i_attachment > 0 )
        {
            int j = 0;
            for( int i = 0; i < input_priv(p_input)->i_attachment; i++ )
            {
                if( input_priv(p_input)->attachment_demux[i] == p_demux )
                    vlc_input_attachment_Delete( input_priv(p_input)->attachment[i] );
                else
                {
                    input_pri...",1,1,input\input.c,InputUpdateMeta,,false,3095,3135,InputUpdateMeta,,,83,"void InputUpdateMeta (input_thread_t*,demux_t*)"
62032,METHOD,input\input.c:<global>,TYPE_DECL,"static void InputGetExtraFilesPattern( input_thread_t *p_input,
                                       int *pi_list, char ***pppsz_list,
                                       const char *psz_path,
                                       const char *psz_match,
                                       const char *psz_format,
                                       int i_start, int i_stop )
{
    int i_list;
    char **ppsz_list;
    TAB_INIT( i_list, ppsz_list );

    char *psz_base = strdup( psz_path );
    if( !psz_base )
        goto exit;

    /* Remove the extension */
    char *psz_end = &psz_base[strlen(psz_base)-strlen(psz_match)];
    assert( psz_end >= psz_base);
    *psz_end = '\0';

    /* Try to list files */
    for( int i = i_start; i <= i_stop; i++ )
    {
        char *psz_probe;
        if( asprintf( &psz_probe, psz_format, psz_base, i ) < 0 )
            break;

        char *filepath = get_path( psz_probe );

        struct stat st;
        if( filepath == NULL ||
   ...",1,1,input\input.c,InputGetExtraFilesPattern,,false,3141,3192,InputGetExtraFilesPattern,,,84,"void InputGetExtraFilesPattern (input_thread_t*,int*,char***,char*,char*,char*,int,int)"
62166,METHOD,input\input.c:<global>,TYPE_DECL,"static void InputGetExtraFiles( input_thread_t *p_input,
                                int *pi_list, char ***pppsz_list,
                                const char **ppsz_access, const char *psz_path )
{
    static const struct pattern
    {
        const char *psz_access_force;
        const char *psz_match;
        const char *psz_format;
        int i_start;
        int i_stop;
    } patterns[] = {
        /* XXX the order is important */
        { ""concat"", "".001"", ""%s.%.3d"", 2, 999 },
        { NULL, "".part1.rar"",""%s.part%.1d.rar"", 2, 9 },
        { NULL, "".part01.rar"",""%s.part%.2d.rar"", 2, 99, },
        { NULL, "".part001.rar"", ""%s.part%.3d.rar"", 2, 999 },
        { NULL, "".rar"", ""%s.r%.2d"", 0, 99 },
        { ""concat"", "".mts"", ""%s.mts%d"", 1, 999 },
    };

    TAB_INIT( *pi_list, *pppsz_list );

    if( ( **ppsz_access && strcmp( *ppsz_access, ""file"" ) ) || !psz_path )
        return;

    const size_t i_path = strlen(psz_path);

    for( size_t i = 0; i < ARRAY_SIZE( patte...",1,1,input\input.c,InputGetExtraFiles,,false,3194,3240,InputGetExtraFiles,,,85,"void InputGetExtraFiles (input_thread_t*,int*,char***,char**,char*)"
62319,METHOD,input\input.c:<global>,TYPE_DECL,"static void input_ChangeState( input_thread_t *p_input, int i_state )
{
    if( input_priv(p_input)->i_state == i_state )
        return;

    input_priv(p_input)->i_state = i_state;
    if( i_state == ERROR_S )
        input_item_SetErrorWhenReading( input_priv(p_input)->p_item, true );
    else if ( i_state == PLAYING_S )
        input_item_SetErrorWhenReading( input_priv(p_input)->p_item, false );
    input_SendEventState( p_input, i_state );
}",1,1,input\input.c,input_ChangeState,,false,3243,3254,input_ChangeState,,,86,"void input_ChangeState (input_thread_t*,int)"
62367,METHOD,input\input.c:<global>,TYPE_DECL,"void input_SplitMRL( const char **access, const char **demux,
                     const char **path, const char **anchor, char *buf )
{
    char *p;

    /* Separate <path> from <access>[/<demux>]:// */
    p = strstr( buf, ""://"" );
    if( p != NULL )
    {
        *p = '\0';
        p += 3; /* skips ""://"" */
        *path = p;

        /* Remove HTML anchor if present (not supported).
         * The hash symbol itself should be URI-encoded. */
        p = strchr( p, '#' );
        if( p != NULL )
        {
            *(p++) = '\0';
            *anchor = p;
        }
        else
            *anchor = """";
    }
    else
    {
#ifndef NDEBUG
        fprintf( stderr, ""%s(\""%s\"") probably not a valid URI!\n"", __func__,
                 buf );
#endif
        /* Note: this is a valid non const pointer to """": */
        *path = buf + strlen( buf );
    }

    /* Separate access from demux */
    p = strchr( buf, '/' );
    if( p != NULL )
    {
        *(p++) = '\0';
        if( p[0] =...",1,1,input\input.c,input_SplitMRL,,false,3261,3312,input_SplitMRL,,,87,"void input_SplitMRL (char**,char**,char**,char**,char*)"
62487,METHOD,input\input.c:<global>,TYPE_DECL,"static const char *MRLSeekPoint( const char *str, int *title, int *chapter )
{
    char *end;
    unsigned long u;

    /* Look for the title */
    u = strtoul( str, &end, 0 );
    *title = (str == end || u > (unsigned long)INT_MAX) ? -1 : (int)u;
    str = end;

    /* Look for the chapter */
    if( *str == ':' )
    {
        str++;
        u = strtoul( str, &end, 0 );
        *chapter = (str == end || u > (unsigned long)INT_MAX) ? -1 : (int)u;
        str = end;
    }
    else
        *chapter = -1;

    return str;
}",1,1,input\input.c,MRLSeekPoint,,false,3314,3336,MRLSeekPoint,,,88,"const char* MRLSeekPoint (char*,int*,int*)"
62569,METHOD,input\input.c:<global>,TYPE_DECL,"static void MRLSections( const char *p,
                         int *pi_title_start, int *pi_title_end,
                         int *pi_chapter_start, int *pi_chapter_end )
{
    *pi_title_start = *pi_title_end = *pi_chapter_start = *pi_chapter_end = -1;

    int title_start, chapter_start, title_end, chapter_end;

    if( !p )
        return;

    if( *p != '-' )
        p = MRLSeekPoint( p, &title_start, &chapter_start );
    else
        title_start = chapter_start = -1;

    if( *p == '-' )
        p = MRLSeekPoint( p + 1, &title_end, &chapter_end );
    else
        title_end = chapter_end = -1;

    if( *p ) /* syntax error */
        return;

    *pi_title_start = title_start;
    *pi_title_end = title_end;
    *pi_chapter_start = chapter_start;
    *pi_chapter_end = chapter_end;
}",1,1,input\input.c,MRLSections,,false,3345,3373,MRLSections,,,89,"void MRLSections (char*,int*,int*,int*,int*)"
62668,METHOD,input\input.c:<global>,TYPE_DECL,"static int input_SlaveSourceAdd( input_thread_t *p_input,
                                 enum slave_type i_type, const char *psz_uri,
                                 unsigned i_flags )
{
    vlc_value_t count;
    const char *psz_es;
    const char *psz_forced_demux;
    const bool b_can_fail = i_flags & SLAVE_ADD_CANFAIL;
    const bool b_forced = i_flags & SLAVE_ADD_FORCED;
    const bool b_set_time = i_flags & SLAVE_ADD_SET_TIME;

    switch( i_type )
    {
    case SLAVE_TYPE_SPU:
        psz_es = ""spu-es"";
        psz_forced_demux = ""subtitle"";
        break;
    case SLAVE_TYPE_AUDIO:
        psz_es = ""audio-es"";
        psz_forced_demux = NULL;
        break;
    default:
        vlc_assert_unreachable();
    }

    if( b_forced )
        var_Change( p_input, psz_es, VLC_VAR_CHOICESCOUNT, &count, NULL );

    msg_Dbg( p_input, ""loading %s slave: %s (forced: %d)"", psz_es, psz_uri,
             b_forced );

    input_source_t *p_source = InputSourceNew( p_input, psz_uri,
   ...",1,38,input\input.c,input_SlaveSourceAdd,,false,3375,3472,input_SlaveSourceAdd,,,90,"int input_SlaveSourceAdd (input_thread_t*,slave_type,char*,unsigned)"
62916,METHOD,input\input.c:<global>,TYPE_DECL,"static char *input_SubtitleFile2Uri( input_thread_t *p_input,
                                     const char *psz_subtitle )
{
    /* if we are provided a subtitle.sub file,
     * see if we don't have a subtitle.idx and use it instead */
    char *psz_idxpath = NULL;
    char *psz_extension = strrchr( psz_subtitle, '.');
    if( psz_extension && strcmp( psz_extension, "".sub"" ) == 0 )
    {
        psz_idxpath = strdup( psz_subtitle );
        if( psz_idxpath )
        {
            struct stat st;

            psz_extension = psz_extension - psz_subtitle + psz_idxpath;
            strcpy( psz_extension, "".idx"" );

            if( !vlc_stat( psz_idxpath, &st ) && S_ISREG( st.st_mode ) )
            {
                msg_Dbg( p_input, ""using %s as subtitle file instead of %s"",
                         psz_idxpath, psz_subtitle );
                psz_subtitle = psz_idxpath;
            }
        }
    }

    char *psz_uri = vlc_path2uri( psz_subtitle, NULL );
    free( psz_idxpath );...",1,1,input\input.c,input_SubtitleFile2Uri,,false,3474,3503,input_SubtitleFile2Uri,,,91,"char* input_SubtitleFile2Uri (input_thread_t*,char*)"
62989,METHOD,input\input.c:<global>,TYPE_DECL,"void input_UpdateStatistic( input_thread_t *p_input,
                            input_statistic_t i_type, int i_delta )
{
    assert( input_priv(p_input)->i_state != INIT_S );

    vlc_mutex_lock( &input_priv(p_input)->counters.counters_lock);
    switch( i_type )
    {
#define I(c) stats_Update( input_priv(p_input)->counters.c, i_delta, NULL )
    case INPUT_STATISTIC_DECODED_VIDEO:
        I(p_decoded_video);
        break;
    case INPUT_STATISTIC_DECODED_AUDIO:
        I(p_decoded_audio);
        break;
    case INPUT_STATISTIC_DECODED_SUBTITLE:
        I(p_decoded_sub);
        break;
    case INPUT_STATISTIC_SENT_PACKET:
        I(p_sout_sent_packets);
        break;
#undef I
    case INPUT_STATISTIC_SENT_BYTE:
    {
        uint64_t bytes;

        stats_Update( input_priv(p_input)->counters.p_sout_sent_bytes, i_delta, &bytes );
        stats_Update( input_priv(p_input)->counters.p_sout_send_bitrate, bytes, NULL );
        break;
    }
    default:
        msg_Err( p_input, ...",1,8,input\input.c,input_UpdateStatistic,,false,3508,3543,input_UpdateStatistic,,,92,"void input_UpdateStatistic (input_thread_t*,input_statistic_t,int)"
63108,METHOD,input\input.c:<global>,TYPE_DECL,"char *input_CreateFilename(input_thread_t *input, const char *dir,
                           const char *filenamefmt, const char *ext)
{
    char *path;
    char *filename = str_format(input, filenamefmt);
    if (unlikely(filename == NULL))
        return NULL;

    filename_sanitize(filename);

    if (((ext != NULL)
            ? asprintf(&path, ""%s""DIR_SEP""%s.%s"", dir, filename, ext)
            : asprintf(&path, ""%s""DIR_SEP""%s"", dir, filename)) < 0)
        path = NULL;

    free(filename);
    return path;
}",1,1,input\input.c,input_CreateFilename,,false,3547,3564,input_CreateFilename,,,93,"char* input_CreateFilename (input_thread_t*,char*,char*,char*)"
63150,METHOD,input\input_interface.h:<global>,TYPE_DECL,<global>,1,6,input\input_interface.h,input\input_interface.h:<global>,,false,1,92,<global>,,,1,
63152,METHOD,input\input_interface.h:<global>,TYPE_DECL,"void input_item_SignalPreparseEnded( input_item_t *p_i, int new_status );",6,72,input\input_interface.h,input_item_SignalPreparseEnded,,false,33,33,input_item_SignalPreparseEnded,,,1,"void input_item_SignalPreparseEnded (input_item_t*,int)"
63158,METHOD,input\input_interface.h:<global>,TYPE_DECL,"void input_item_SetPreparsed( input_item_t *p_i, bool b_preparsed );",6,67,input\input_interface.h,input_item_SetPreparsed,,false,34,34,input_item_SetPreparsed,,,2,"void input_item_SetPreparsed (input_item_t*,bool)"
63164,METHOD,input\input_interface.h:<global>,TYPE_DECL,"void input_item_SetArtNotFound( input_item_t *p_i, bool b_not_found );",6,69,input\input_interface.h,input_item_SetArtNotFound,,false,35,35,input_item_SetArtNotFound,,,3,"void input_item_SetArtNotFound (input_item_t*,bool)"
63170,METHOD,input\input_interface.h:<global>,TYPE_DECL,"void input_item_SetArtFetched( input_item_t *p_i, bool b_art_fetched );",6,70,input\input_interface.h,input_item_SetArtFetched,,false,36,36,input_item_SetArtFetched,,,4,"void input_item_SetArtFetched (input_item_t*,bool)"
63176,METHOD,input\input_interface.h:<global>,TYPE_DECL,"void input_item_SetEpg( input_item_t *p_item, const vlc_epg_t *p_epg, bool );",6,76,input\input_interface.h,input_item_SetEpg,,false,37,37,input_item_SetEpg,,,5,"void input_item_SetEpg (input_item_t*,vlc_epg_t*,ANY)"
63183,METHOD,input\input_interface.h:<global>,TYPE_DECL,"void input_item_ChangeEPGSource( input_item_t *p_item, int i_source_id );",6,72,input\input_interface.h,input_item_ChangeEPGSource,,false,38,38,input_item_ChangeEPGSource,,,6,"void input_item_ChangeEPGSource (input_item_t*,int)"
63189,METHOD,input\input_interface.h:<global>,TYPE_DECL,"void input_item_SetEpgEvent( input_item_t *p_item, const vlc_epg_event_t *p_epg_evt );",6,85,input\input_interface.h,input_item_SetEpgEvent,,false,39,39,input_item_SetEpgEvent,,,7,"void input_item_SetEpgEvent (input_item_t*,vlc_epg_event_t*)"
63195,METHOD,input\input_interface.h:<global>,TYPE_DECL,"void input_item_SetEpgTime( input_item_t *, int64_t );",6,53,input\input_interface.h,input_item_SetEpgTime,,false,40,40,input_item_SetEpgTime,,,8,"void input_item_SetEpgTime (input_item_t*,ANY)"
63201,METHOD,input\input_interface.h:<global>,TYPE_DECL,void input_item_SetEpgOffline( input_item_t * );,6,47,input\input_interface.h,input_item_SetEpgOffline,,false,41,41,input_item_SetEpgOffline,,,9,void input_item_SetEpgOffline (input_item_t*)
63206,METHOD,input\input_interface.h:<global>,TYPE_DECL,"input_thread_t *input_CreatePreparser(vlc_object_t *obj, input_item_t *item)",16,76,input\input_interface.h,input_CreatePreparser,,false,53,53,input_CreatePreparser,,,10,"input_thread_t* input_CreatePreparser (vlc_object_t*,input_item_t*)"
63214,METHOD,input\input_interface.h:<global>,TYPE_DECL,input_stats_t *stats_NewInputStats( input_thread_t *p_input );,15,61,input\input_interface.h,stats_NewInputStats,,false,58,58,stats_NewInputStats,,,13,input_stats_t* stats_NewInputStats (input_thread_t*)
63219,METHOD,input\input_interface.h:<global>,TYPE_DECL,void input_resource_TerminateSout( input_resource_t *p_resource );,6,65,input\input_interface.h,input_resource_TerminateSout,,false,63,63,input_resource_TerminateSout,,,14,void input_resource_TerminateSout (input_resource_t*)
63224,METHOD,input\input_interface.h:<global>,TYPE_DECL,bool input_resource_HasVout( input_resource_t *p_resource );,6,59,input\input_interface.h,input_resource_HasVout,,false,70,70,input_resource_HasVout,,,15,bool input_resource_HasVout (input_resource_t*)
63236,METHOD,input\input_interface.h:<global>,TYPE_DECL,"void input_UpdateStatistic( input_thread_t *, input_statistic_t, int i_delta );",6,78,input\input_interface.h,input_UpdateStatistic,,false,90,90,input_UpdateStatistic,,,18,"void input_UpdateStatistic (input_thread_t*,input_statistic_t,int)"
63262,METHOD,input\input_internal.h:<global>,TYPE_DECL,<global>,1,20,input\input_internal.h,input\input_internal.h:<global>,,false,1,284,<global>,,,1,
63355,METHOD,<empty>,<empty>,<empty>,1,,input\input_internal.h,input_thread_private_t:<clinit>,,false,85,,<clinit>,,,47,
63364,METHOD,input\input_internal.h:<global>,TYPE_DECL,"static inline input_thread_private_t *input_priv(input_thread_t *input)
{
    return container_of(input, input_thread_private_t, input);
}",1,1,input\input_internal.h,input_priv,,false,181,184,input_priv,,,7,input_thread_private_t input_priv (input_thread_t*)
63405,METHOD,input\input_internal.h:<global>,TYPE_DECL,"void input_ControlPush( input_thread_t *, int i_type, vlc_value_t * );",6,69,input\input_internal.h,input_ControlPush,,false,243,243,input_ControlPush,,,9,"void input_ControlPush (input_thread_t*,int,vlc_value_t*)"
63412,METHOD,input\input_internal.h:<global>,TYPE_DECL,bool input_Stopped( input_thread_t * );,6,38,input\input_internal.h,input_Stopped,,false,245,245,input_Stopped,,,10,bool input_Stopped (input_thread_t*)
63417,METHOD,input\input_internal.h:<global>,TYPE_DECL,"void input_ExtractAttachmentAndCacheArt( input_thread_t *, const char *name );",6,77,input\input_internal.h,input_ExtractAttachmentAndCacheArt,,false,255,255,input_ExtractAttachmentAndCacheArt,,,11,"void input_ExtractAttachmentAndCacheArt (input_thread_t*,char*)"
63423,METHOD,input\input_internal.h:<global>,TYPE_DECL,void input_ControlVarInit ( input_thread_t * );,6,46,input\input_internal.h,input_ControlVarInit,,false,262,262,input_ControlVarInit,,,12,void input_ControlVarInit (input_thread_t*)
63428,METHOD,input\input_internal.h:<global>,TYPE_DECL,void input_ControlVarStop( input_thread_t * );,6,45,input\input_internal.h,input_ControlVarStop,,false,263,263,input_ControlVarStop,,,13,void input_ControlVarStop (input_thread_t*)
63433,METHOD,input\input_internal.h:<global>,TYPE_DECL,void input_ControlVarNavigation( input_thread_t * );,6,51,input\input_internal.h,input_ControlVarNavigation,,false,264,264,input_ControlVarNavigation,,,14,void input_ControlVarNavigation (input_thread_t*)
63438,METHOD,input\input_internal.h:<global>,TYPE_DECL,"void input_ControlVarTitle( input_thread_t *, int i_title );",6,59,input\input_internal.h,input_ControlVarTitle,,false,265,265,input_ControlVarTitle,,,15,"void input_ControlVarTitle (input_thread_t*,int)"
63444,METHOD,input\input_internal.h:<global>,TYPE_DECL,void input_ConfigVarInit ( input_thread_t * );,6,45,input\input_internal.h,input_ConfigVarInit,,false,267,267,input_ConfigVarInit,,,16,void input_ConfigVarInit (input_thread_t*)
63449,METHOD,input\input_internal.h:<global>,TYPE_DECL,"int subtitles_Detect( input_thread_t *, char *, const char *, input_item_slave_t ***, int * );",5,93,input\input_internal.h,subtitles_Detect,,false,270,270,subtitles_Detect,,,17,"int subtitles_Detect (input_thread_t*,char*,char*,input_item_slave_t***,int*)"
63458,METHOD,input\input_internal.h:<global>,TYPE_DECL,int subtitles_Filter( const char *);,5,35,input\input_internal.h,subtitles_Filter,,false,271,271,subtitles_Filter,,,18,int subtitles_Filter (char*)
63463,METHOD,input\input_internal.h:<global>,TYPE_DECL,"void input_SplitMRL( const char **, const char **, const char **,
                     const char **, char * );",6,44,input\input_internal.h,input_SplitMRL,,false,274,275,input_SplitMRL,,,19,"void input_SplitMRL (char**,char**,char**,char**,char*)"
63472,METHOD,input\input_internal.h:<global>,TYPE_DECL,"void vlc_audio_replay_gain_MergeFromMeta( audio_replay_gain_t *p_dst,
                                          const vlc_meta_t *p_meta );",6,68,input\input_internal.h,vlc_audio_replay_gain_MergeFromMeta,,false,278,279,vlc_audio_replay_gain_MergeFromMeta,,,20,"void vlc_audio_replay_gain_MergeFromMeta (audio_replay_gain_t*,vlc_meta_t*)"
63478,METHOD,input\input_internal.h:<global>,TYPE_DECL,void input_item_node_PostAndDelete( input_item_node_t *p_node );,6,63,input\input_internal.h,input_item_node_PostAndDelete,,false,282,282,input_item_node_PostAndDelete,,,21,void input_item_node_PostAndDelete (input_item_node_t*)
63512,METHOD,input\item.c:<global>,TYPE_DECL,<global>,1,1,input\item.c,input\item.c:<global>,,false,1,1828,<global>,,,1,
63519,METHOD,<empty>,<empty>,<empty>,1,,input\item.c,input_item_opaque:<clinit>,,false,42,,<clinit>,,,5,
63525,METHOD,input\item.c:<global>,TYPE_DECL,"static int GuessType( const input_item_t *p_item, bool *p_net );",12,63,input\item.c,GuessType,,false,49,49,GuessType,,,2,"int GuessType (input_item_t*,bool*)"
63531,METHOD,input\item.c:<global>,TYPE_DECL,"void input_item_SetErrorWhenReading( input_item_t *p_i, bool b_error )
{
    bool b_changed;

    vlc_mutex_lock( &p_i->lock );

    b_changed = p_i->b_error_when_reading != b_error;
    p_i->b_error_when_reading = b_error;

    vlc_mutex_unlock( &p_i->lock );

    if( b_changed )
    {
        vlc_event_send( &p_i->event_manager, &(vlc_event_t) {
            .type = vlc_InputItemErrorWhenReadingChanged,
            .u.input_item_error_when_reading_changed.new_value = b_error } );
    }
}",1,1,input\item.c,input_item_SetErrorWhenReading,,false,51,68,input_item_SetErrorWhenReading,,,3,"void input_item_SetErrorWhenReading (input_item_t*,bool)"
63586,METHOD,input\item.c:<global>,TYPE_DECL,"void input_item_SignalPreparseEnded( input_item_t *p_i, int status )
{
    vlc_event_send( &p_i->event_manager, &(vlc_event_t) {
        .type = vlc_InputItemPreparseEnded,
        .u.input_item_preparse_ended.new_status = status } );
}",1,1,input\item.c,input_item_SignalPreparseEnded,,false,69,74,input_item_SignalPreparseEnded,,,4,"void input_item_SignalPreparseEnded (input_item_t*,int)"
63615,METHOD,input\item.c:<global>,TYPE_DECL,"void input_item_SetPreparsed( input_item_t *p_i, bool b_preparsed )
{
    bool b_send_event = false;

    vlc_mutex_lock( &p_i->lock );

    if( !p_i->p_meta )
        p_i->p_meta = vlc_meta_New();

    int status = vlc_meta_GetStatus(p_i->p_meta);
    int new_status;
    if( b_preparsed )
        new_status = status | ITEM_PREPARSED;
    else
        new_status = status & ~ITEM_PREPARSED;
    if( status != new_status )
    {
        vlc_meta_SetStatus(p_i->p_meta, new_status);
        b_send_event = true;
    }

    vlc_mutex_unlock( &p_i->lock );

    if( b_send_event )
    {
        vlc_event_send( &p_i->event_manager, &(vlc_event_t) {
            .type = vlc_InputItemPreparsedChanged,
            .u.input_item_preparsed_changed.new_status = new_status } );
    }
}",1,1,input\item.c,input_item_SetPreparsed,,false,76,105,input_item_SetPreparsed,,,5,"void input_item_SetPreparsed (input_item_t*,bool)"
63709,METHOD,input\item.c:<global>,TYPE_DECL,"void input_item_SetArtNotFound( input_item_t *p_i, bool b_not_found )
{
    vlc_mutex_lock( &p_i->lock );

    if( !p_i->p_meta )
        p_i->p_meta = vlc_meta_New();

    int status = vlc_meta_GetStatus(p_i->p_meta);

    if( b_not_found )
        status |= ITEM_ART_NOTFOUND;
    else
        status &= ~ITEM_ART_NOTFOUND;

    vlc_meta_SetStatus(p_i->p_meta, status);

    vlc_mutex_unlock( &p_i->lock );
}",1,1,input\item.c,input_item_SetArtNotFound,,false,107,124,input_item_SetArtNotFound,,,6,"void input_item_SetArtNotFound (input_item_t*,bool)"
63760,METHOD,input\item.c:<global>,TYPE_DECL,"void input_item_SetArtFetched( input_item_t *p_i, bool b_art_fetched )
{
    vlc_mutex_lock( &p_i->lock );

    if( !p_i->p_meta )
        p_i->p_meta = vlc_meta_New();

    int status = vlc_meta_GetStatus(p_i->p_meta);

    if( b_art_fetched )
        status |= ITEM_ART_FETCHED;
    else
        status &= ~ITEM_ART_FETCHED;

    vlc_meta_SetStatus(p_i->p_meta, status);

    vlc_mutex_unlock( &p_i->lock );
}",1,1,input\item.c,input_item_SetArtFetched,,false,126,143,input_item_SetArtFetched,,,7,"void input_item_SetArtFetched (input_item_t*,bool)"
63811,METHOD,input\item.c:<global>,TYPE_DECL,"void input_item_SetMeta( input_item_t *p_i, vlc_meta_type_t meta_type, const char *psz_val )
{
    vlc_mutex_lock( &p_i->lock );
    if( !p_i->p_meta )
        p_i->p_meta = vlc_meta_New();
    vlc_meta_Set( p_i->p_meta, meta_type, psz_val );
    vlc_mutex_unlock( &p_i->lock );

    /* Notify interested third parties */
    vlc_event_send( &p_i->event_manager, &(vlc_event_t) {
        .type = vlc_InputItemMetaChanged,
        .u.input_item_meta_changed.meta_type = meta_type } );
}",1,1,input\item.c,input_item_SetMeta,,false,145,157,input_item_SetMeta,,,8,"void input_item_SetMeta (input_item_t*,vlc_meta_type_t,char*)"
63868,METHOD,input\item.c:<global>,TYPE_DECL,"void input_item_CopyOptions( input_item_t *p_child,
                             input_item_t *p_parent )
{
    char **optv = NULL;
    uint8_t *flagv = NULL;
    int optc = 0;
    char **optv_realloc = NULL;
    uint8_t *flagv_realloc = NULL;

    vlc_mutex_lock( &p_parent->lock );

    if( p_parent->i_options > 0 )
    {
        optv = vlc_alloc( p_parent->i_options, sizeof (*optv) );
        if( likely(optv) )
            flagv = vlc_alloc( p_parent->i_options, sizeof (*flagv) );

        if( likely(flagv) )
        {
            for( int i = 0; i < p_parent->i_options; i++ )
            {
                char *psz_dup = strdup( p_parent->ppsz_options[i] );
                if( likely(psz_dup) )
                {
                    flagv[optc] = p_parent->optflagv[i];
                    optv[optc++] = psz_dup;
                }
            }
        }
    }

    vlc_mutex_unlock( &p_parent->lock );

    if( likely(optv && flagv && optc ) )
    {
        vlc_mutex_lock( &p_child-...",1,1,input\item.c,input_item_CopyOptions,,false,159,230,input_item_CopyOptions,,,9,"void input_item_CopyOptions (input_item_t*,input_item_t*)"
64146,METHOD,input\item.c:<global>,TYPE_DECL,"bool input_item_HasErrorWhenReading( input_item_t *p_item )
{
    vlc_mutex_lock( &p_item->lock );

    bool b_error = p_item->b_error_when_reading;

    vlc_mutex_unlock( &p_item->lock );

    return b_error;
}",1,1,input\item.c,input_item_HasErrorWhenReading,,false,232,241,input_item_HasErrorWhenReading,,,10,bool input_item_HasErrorWhenReading (input_item_t*)
64169,METHOD,input\item.c:<global>,TYPE_DECL,"bool input_item_MetaMatch( input_item_t *p_i,
                           vlc_meta_type_t meta_type, const char *psz )
{
    vlc_mutex_lock( &p_i->lock );

    if( !p_i->p_meta )
    {
        vlc_mutex_unlock( &p_i->lock );
        return false;
    }
    const char *psz_meta = vlc_meta_Get( p_i->p_meta, meta_type );
    bool b_ret = psz_meta && strcasestr( psz_meta, psz );

    vlc_mutex_unlock( &p_i->lock );

    return b_ret;
}",1,1,input\item.c,input_item_MetaMatch,,false,243,259,input_item_MetaMatch,,,11,"bool input_item_MetaMatch (input_item_t*,vlc_meta_type_t,char*)"
64217,METHOD,input\item.c:<global>,TYPE_DECL,"char *input_item_GetMeta( input_item_t *p_i, vlc_meta_type_t meta_type )
{
    vlc_mutex_lock( &p_i->lock );

    if( !p_i->p_meta )
    {
        vlc_mutex_unlock( &p_i->lock );
        return NULL;
    }

    char *psz = NULL;
    if( vlc_meta_Get( p_i->p_meta, meta_type ) )
        psz = strdup( vlc_meta_Get( p_i->p_meta, meta_type ) );

    vlc_mutex_unlock( &p_i->lock );
    return psz;
}",1,1,input\item.c,input_item_GetMeta,,false,261,277,input_item_GetMeta,,,12,"char* input_item_GetMeta (input_item_t*,vlc_meta_type_t)"
64267,METHOD,input\item.c:<global>,TYPE_DECL,"char *input_item_GetTitleFbName( input_item_t *p_item )
{
    char *psz_ret;
    vlc_mutex_lock( &p_item->lock );

    if( !p_item->p_meta )
    {
        psz_ret = p_item->psz_name ? strdup( p_item->psz_name ) : NULL;
        vlc_mutex_unlock( &p_item->lock );
        return psz_ret;
    }

    const char *psz_title = vlc_meta_Get( p_item->p_meta, vlc_meta_Title );
    if( !EMPTY_STR( psz_title ) )
        psz_ret = strdup( psz_title );
    else
        psz_ret = p_item->psz_name ? strdup( p_item->psz_name ) : NULL;

    vlc_mutex_unlock( &p_item->lock );
    return psz_ret;
}",1,1,input\item.c,input_item_GetTitleFbName,,false,280,300,input_item_GetTitleFbName,,,13,char* input_item_GetTitleFbName (input_item_t*)
64339,METHOD,input\item.c:<global>,TYPE_DECL,"char *input_item_GetName( input_item_t *p_item )
{
    vlc_mutex_lock( &p_item->lock );

    char *psz_name = p_item->psz_name ? strdup( p_item->psz_name ) : NULL;

    vlc_mutex_unlock( &p_item->lock );
    return psz_name;
}",1,1,input\item.c,input_item_GetName,,false,302,310,input_item_GetName,,,14,char* input_item_GetName (input_item_t*)
64368,METHOD,input\item.c:<global>,TYPE_DECL,"void input_item_SetName( input_item_t *p_item, const char *psz_name )
{
    vlc_mutex_lock( &p_item->lock );

    free( p_item->psz_name );
    p_item->psz_name = strdup( psz_name );

    vlc_mutex_unlock( &p_item->lock );
}",1,1,input\item.c,input_item_SetName,,false,311,319,input_item_SetName,,,15,"void input_item_SetName (input_item_t*,char*)"
64394,METHOD,input\item.c:<global>,TYPE_DECL,"char *input_item_GetURI( input_item_t *p_i )
{
    vlc_mutex_lock( &p_i->lock );

    char *psz_s = p_i->psz_uri ? strdup( p_i->psz_uri ) : NULL;

    vlc_mutex_unlock( &p_i->lock );
    return psz_s;
}",1,1,input\item.c,input_item_GetURI,,false,321,329,input_item_GetURI,,,16,char* input_item_GetURI (input_item_t*)
64423,METHOD,input\item.c:<global>,TYPE_DECL,"void input_item_SetURI( input_item_t *p_i, const char *psz_uri )
{
    assert( psz_uri );
#ifndef NDEBUG
    if( !strstr( psz_uri, ""://"" )
     || strchr( psz_uri, ' ' ) || strchr( psz_uri, '""' ) )
        fprintf( stderr, ""Warning: %s(\""%s\""): file path instead of URL.\n"",
                 __func__, psz_uri );
#endif
    vlc_mutex_lock( &p_i->lock );
    free( p_i->psz_uri );
    p_i->psz_uri = strdup( psz_uri );

    p_i->i_type = GuessType( p_i, &p_i->b_net );

    if( p_i->psz_name )
        ;
    else
    if( p_i->i_type == ITEM_TYPE_FILE || p_i->i_type == ITEM_TYPE_DIRECTORY )
    {
        const char *psz_filename = strrchr( p_i->psz_uri, '/' );

        if( psz_filename && *psz_filename == '/' )
            psz_filename++;
        if( psz_filename && *psz_filename )
            p_i->psz_name = strdup( psz_filename );

        /* Make the name more readable */
        if( p_i->psz_name )
        {
            vlc_uri_decode( p_i->psz_name );
            EnsureUTF8( p_i->psz_n...",1,1,input\item.c,input_item_SetURI,,false,331,397,input_item_SetURI,,,17,"void input_item_SetURI (input_item_t*,char*)"
64683,METHOD,input\item.c:<global>,TYPE_DECL,"mtime_t input_item_GetDuration( input_item_t *p_i )
{
    vlc_mutex_lock( &p_i->lock );

    mtime_t i_duration = p_i->i_duration;

    vlc_mutex_unlock( &p_i->lock );
    return i_duration;
}",1,1,input\item.c,input_item_GetDuration,,false,399,407,input_item_GetDuration,,,18,mtime_t input_item_GetDuration (input_item_t*)
64706,METHOD,input\item.c:<global>,TYPE_DECL,"void input_item_SetDuration( input_item_t *p_i, mtime_t i_duration )
{
    bool b_send_event = false;

    vlc_mutex_lock( &p_i->lock );
    if( p_i->i_duration != i_duration )
    {
        p_i->i_duration = i_duration;
        b_send_event = true;
    }
    vlc_mutex_unlock( &p_i->lock );

    if( b_send_event )
    {
        vlc_event_send( &p_i->event_manager, &(vlc_event_t) {
            .type = vlc_InputItemDurationChanged,
            .u.input_item_duration_changed.new_duration = i_duration } );
    }
}",1,1,input\item.c,input_item_SetDuration,,false,409,427,input_item_SetDuration,,,19,"void input_item_SetDuration (input_item_t*,mtime_t)"
64767,METHOD,input\item.c:<global>,TYPE_DECL,"char *input_item_GetNowPlayingFb( input_item_t *p_item )
{
    char *psz_meta = input_item_GetMeta( p_item, vlc_meta_NowPlaying );
    if( !psz_meta || strlen( psz_meta ) == 0 )
    {
        free( psz_meta );
        return input_item_GetMeta( p_item, vlc_meta_ESNowPlaying );
    }

    return psz_meta;
}",1,1,input\item.c,input_item_GetNowPlayingFb,,false,429,439,input_item_GetNowPlayingFb,,,20,char* input_item_GetNowPlayingFb (input_item_t*)
64795,METHOD,input\item.c:<global>,TYPE_DECL,"bool input_item_IsPreparsed( input_item_t *p_item )
{
    vlc_mutex_lock( &p_item->lock );
    bool b_preparsed = p_item->p_meta ? ( vlc_meta_GetStatus(p_item->p_meta) & ITEM_PREPARSED ) != 0 : false;
    vlc_mutex_unlock( &p_item->lock );

    return b_preparsed;
}",1,1,input\item.c,input_item_IsPreparsed,,false,441,448,input_item_IsPreparsed,,,21,bool input_item_IsPreparsed (input_item_t*)
64828,METHOD,input\item.c:<global>,TYPE_DECL,"bool input_item_IsArtFetched( input_item_t *p_item )
{
    vlc_mutex_lock( &p_item->lock );
    bool b_fetched = p_item->p_meta ? ( vlc_meta_GetStatus(p_item->p_meta) & ITEM_ART_FETCHED ) != 0 : false;
    vlc_mutex_unlock( &p_item->lock );

    return b_fetched;
}",1,1,input\item.c,input_item_IsArtFetched,,false,450,457,input_item_IsArtFetched,,,22,bool input_item_IsArtFetched (input_item_t*)
64861,METHOD,input\item.c:<global>,TYPE_DECL,"bool input_item_ShouldPreparseSubItems( input_item_t *p_item )
{
    bool b_ret;

    vlc_mutex_lock( &p_item->lock );
    b_ret = p_item->i_preparse_depth == -1 ? true : p_item->i_preparse_depth > 0;
    vlc_mutex_unlock( &p_item->lock );

    return b_ret;
}",1,1,input\item.c,input_item_ShouldPreparseSubItems,,false,459,468,input_item_ShouldPreparseSubItems,,,23,bool input_item_ShouldPreparseSubItems (input_item_t*)
64894,METHOD,input\item.c:<global>,TYPE_DECL,"input_item_t *input_item_Hold( input_item_t *p_item )
{
    input_item_owner_t *owner = item_owner(p_item);

    atomic_fetch_add( &owner->refs, 1 );
    return p_item;
}",1,32,input\item.c,input_item_Hold,,false,470,476,input_item_Hold,,,24,input_item_t input_item_Hold (input_item_t*)
64916,METHOD,input\item.c:<global>,TYPE_DECL,"void input_item_Release( input_item_t *p_item )
{
    input_item_owner_t *owner = item_owner(p_item);

    if( atomic_fetch_sub(&owner->refs, 1) != 1 )
        return;

    vlc_event_manager_fini( &p_item->event_manager );

    free( p_item->psz_name );
    free( p_item->psz_uri );
    if( p_item->p_stats != NULL )
    {
        vlc_mutex_destroy( &p_item->p_stats->lock );
        free( p_item->p_stats );
    }

    if( p_item->p_meta != NULL )
        vlc_meta_Delete( p_item->p_meta );

    for( input_item_opaque_t *o = p_item->opaques, *next; o != NULL; o = next )
    {
        next = o->next;
        free( o );
    }

    for( int i = 0; i < p_item->i_options; i++ )
        free( p_item->ppsz_options[i] );
    TAB_CLEAN( p_item->i_options, p_item->ppsz_options );
    free( p_item->optflagv );

    for( int i = 0; i < p_item->i_es; i++ )
    {
        es_format_Clean( p_item->es[i] );
        free( p_item->es[i] );
    }
    TAB_CLEAN( p_item->i_es, p_item->es );

    for( int i =...",1,32,input\item.c,input_item_Release,,false,478,530,input_item_Release,,,25,void input_item_Release (input_item_t*)
65154,METHOD,input\item.c:<global>,TYPE_DECL,"int input_item_AddOption( input_item_t *p_input, const char *psz_option,
                          unsigned flags )
{
    int err = VLC_SUCCESS;

    if( psz_option == NULL )
        return VLC_EGENERIC;

    vlc_mutex_lock( &p_input->lock );
    if (flags & VLC_INPUT_OPTION_UNIQUE)
    {
        for (int i = 0 ; i < p_input->i_options; i++)
            if( !strcmp( p_input->ppsz_options[i], psz_option ) )
                goto out;
    }

    uint8_t *flagv = realloc (p_input->optflagv, p_input->optflagc + 1);
    if (flagv == NULL)
    {
        err = VLC_ENOMEM;
        goto out;
    }

    p_input->optflagv = flagv;

    char* psz_option_dup = strdup( psz_option );
    if( unlikely( !psz_option_dup ) )
    {
        err = VLC_ENOMEM;
        goto out;
    }

    TAB_APPEND(p_input->i_options, p_input->ppsz_options, psz_option_dup);

    flagv[p_input->optflagc++] = flags;

out:
    vlc_mutex_unlock( &p_input->lock );
    return err;
}",1,1,input\item.c,input_item_AddOption,,false,532,571,input_item_AddOption,,,26,"int input_item_AddOption (input_item_t*,char*,unsigned)"
65270,METHOD,input\item.c:<global>,TYPE_DECL,"int input_item_AddOptions( input_item_t *p_item, int i_options,
                           const char *const *ppsz_options,
                           unsigned i_flags )
{
    int i_ret = VLC_SUCCESS;
    for( int i = 0; i < i_options && i_ret == VLC_SUCCESS; i++ )
        i_ret = input_item_AddOption( p_item, ppsz_options[i], i_flags );
    return i_ret;
}",1,1,input\item.c,input_item_AddOptions,,false,573,581,input_item_AddOptions,,,27,"int input_item_AddOptions (input_item_t*,int,char**,unsigned)"
65307,METHOD,input\item.c:<global>,TYPE_DECL,"int input_item_AddOpaque(input_item_t *item, const char *name, void *value)
{
    assert(name != NULL);

    size_t namelen = strlen(name);
    input_item_opaque_t *entry = malloc(sizeof (*entry) + namelen);
    if (unlikely(entry == NULL))
        return VLC_ENOMEM;

    memcpy(entry->name, name, namelen + 1);
    entry->value = value;

    vlc_mutex_lock(&item->lock);
    entry->next = item->opaques;
    item->opaques = entry;
    vlc_mutex_unlock(&item->lock);
    return VLC_SUCCESS;
}",1,1,input\item.c,input_item_AddOpaque,,false,583,600,input_item_AddOpaque,,,28,"int input_item_AddOpaque (input_item_t*,char*,void*)"
65377,METHOD,input\item.c:<global>,TYPE_DECL,"void input_item_ApplyOptions(vlc_object_t *obj, input_item_t *item)
{
    vlc_mutex_lock(&item->lock);
    assert(item->optflagc == (unsigned)item->i_options);

    for (unsigned i = 0; i < (unsigned)item->i_options; i++)
        var_OptionParse(obj, item->ppsz_options[i],
                        !!(item->optflagv[i] & VLC_INPUT_OPTION_TRUSTED));

    for (const input_item_opaque_t *o = item->opaques; o != NULL; o = o->next)
    {
        var_Create(obj, o->name, VLC_VAR_ADDRESS);
        var_SetAddress(obj, o->name, o->value);
    }

    vlc_mutex_unlock(&item->lock);
}",1,1,input\item.c,input_item_ApplyOptions,,false,602,618,input_item_ApplyOptions,,,29,"void input_item_ApplyOptions (vlc_object_t*,input_item_t*)"
65465,METHOD,input\item.c:<global>,TYPE_DECL,"static int bsearch_strcmp_cb(const void *a, const void *b)
{
    const char *const *entry = b;
    return strcasecmp(a, *entry);
}",1,1,input\item.c,bsearch_strcmp_cb,,false,620,624,bsearch_strcmp_cb,,,30,"int bsearch_strcmp_cb (void*,void*)"
65480,METHOD,input\item.c:<global>,TYPE_DECL,"static bool input_item_IsMaster(const char *psz_filename)
{
    static const char *const ppsz_master_exts[] = { MASTER_EXTENSIONS };

    const char *psz_ext = strrchr(psz_filename, '.');
    if (psz_ext == NULL || *(++psz_ext) == '\0')
        return false;

    return bsearch(psz_ext, ppsz_master_exts, ARRAY_SIZE(ppsz_master_exts),
                   sizeof(const char *), bsearch_strcmp_cb) != NULL;
}",1,1,input\item.c,input_item_IsMaster,,false,626,636,input_item_IsMaster,,,31,bool input_item_IsMaster (char*)
65520,METHOD,input\item.c:<global>,TYPE_DECL,"bool input_item_slave_GetType(const char *psz_filename,
                              enum slave_type *p_slave_type)
{
    static const char *const ppsz_sub_exts[] = { SLAVE_SPU_EXTENSIONS };
    static const char *const ppsz_audio_exts[] = { SLAVE_AUDIO_EXTENSIONS };

    static struct {
        enum slave_type i_type;
        const char *const *ppsz_exts;
        size_t nmemb;
    } p_slave_list[] = {
        { SLAVE_TYPE_SPU, ppsz_sub_exts, ARRAY_SIZE(ppsz_sub_exts) },
        { SLAVE_TYPE_AUDIO, ppsz_audio_exts, ARRAY_SIZE(ppsz_audio_exts) },
    };

    const char *psz_ext = strrchr(psz_filename, '.');
    if (psz_ext == NULL || *(++psz_ext) == '\0')
        return false;

    for (unsigned int i = 0; i < sizeof(p_slave_list) / sizeof(*p_slave_list); ++i)
    {
        if (bsearch(psz_ext, p_slave_list[i].ppsz_exts, p_slave_list[i].nmemb,
                    sizeof(const char *), bsearch_strcmp_cb))
        {
            *p_slave_type = p_slave_list[i].i_type;
            retur...",1,1,input\item.c,input_item_slave_GetType,,false,638,667,input_item_slave_GetType,,,32,"bool input_item_slave_GetType (char*,slave_type*)"
65615,METHOD,input\item.c:<global>,TYPE_DECL,"input_item_slave_t *input_item_slave_New(const char *psz_uri, enum slave_type i_type,
                                       enum slave_priority i_priority)
{
    if( !psz_uri )
        return NULL;

    input_item_slave_t *p_slave = malloc( sizeof( *p_slave ) + strlen( psz_uri ) + 1 );
    if( !p_slave )
        return NULL;

    p_slave->i_type = i_type;
    p_slave->i_priority = i_priority;
    p_slave->b_forced = false;
    strcpy( p_slave->psz_uri, psz_uri );

    return p_slave;
}",1,1,input\item.c,input_item_slave_New,,false,669,685,input_item_slave_New,,,33,"input_item_slave_t input_item_slave_New (char*,slave_type,slave_priority)"
65668,METHOD,input\item.c:<global>,TYPE_DECL,"int input_item_AddSlave(input_item_t *p_item, input_item_slave_t *p_slave)
{
    if( p_item == NULL || p_slave == NULL
     || p_slave->i_priority < SLAVE_PRIORITY_MATCH_NONE )
        return VLC_EGENERIC;

    vlc_mutex_lock( &p_item->lock );

    TAB_APPEND(p_item->i_slaves, p_item->pp_slaves, p_slave);

    vlc_mutex_unlock( &p_item->lock );
    return VLC_SUCCESS;
}",1,1,input\item.c,input_item_AddSlave,,false,687,699,input_item_AddSlave,,,34,"int input_item_AddSlave (input_item_t*,input_item_slave_t*)"
65711,METHOD,input\item.c:<global>,TYPE_DECL,"static info_category_t *InputItemFindCat( input_item_t *p_item,
                                          int *pi_index, const char *psz_cat )
{
    vlc_assert_locked( &p_item->lock );
    for( int i = 0; i < p_item->i_categories && psz_cat; i++ )
    {
        info_category_t *p_cat = p_item->pp_categories[i];

        if( !strcmp( p_cat->psz_name, psz_cat ) )
        {
            if( pi_index )
                *pi_index = i;
            return p_cat;
        }
    }
    return NULL;
}",1,1,input\item.c,InputItemFindCat,,false,701,717,InputItemFindCat,,,35,"info_category_t InputItemFindCat (input_item_t*,int*,char*)"
65766,METHOD,input\item.c:<global>,TYPE_DECL,"char *input_item_GetInfo( input_item_t *p_i,
                          const char *psz_cat,
                          const char *psz_name )
{
    vlc_mutex_lock( &p_i->lock );

    const info_category_t *p_cat = InputItemFindCat( p_i, NULL, psz_cat );
    if( p_cat )
    {
        info_t *p_info = info_category_FindInfo( p_cat, NULL, psz_name );
        if( p_info && p_info->psz_value )
        {
            char *psz_ret = strdup( p_info->psz_value );
            vlc_mutex_unlock( &p_i->lock );
            return psz_ret;
        }
    }
    vlc_mutex_unlock( &p_i->lock );
    return strdup( """" );
}",1,1,input\item.c,input_item_GetInfo,,false,729,748,input_item_GetInfo,,,36,"char* input_item_GetInfo (input_item_t*,char*,char*)"
65824,METHOD,input\item.c:<global>,TYPE_DECL,"static int InputItemVaAddInfo( input_item_t *p_i,
                               const char *psz_cat,
                               const char *psz_name,
                               const char *psz_format, va_list args )
{
    vlc_assert_locked( &p_i->lock );

    info_category_t *p_cat = InputItemFindCat( p_i, NULL, psz_cat );
    if( !p_cat )
    {
        p_cat = info_category_New( psz_cat );
        if( !p_cat )
            return VLC_ENOMEM;
        TAB_APPEND(p_i->i_categories, p_i->pp_categories, p_cat);
    }
    info_t *p_info = info_category_VaAddInfo( p_cat, psz_name, psz_format, args );
    if( !p_info || !p_info->psz_value )
        return VLC_EGENERIC;
    return VLC_SUCCESS;
}",1,1,input\item.c,InputItemVaAddInfo,,false,750,769,InputItemVaAddInfo,,,37,"int InputItemVaAddInfo (input_item_t*,char*,char*,char*,va_list)"
65888,METHOD,input\item.c:<global>,TYPE_DECL,"int input_item_AddInfo( input_item_t *p_i,
                        const char *psz_cat,
                        const char *psz_name,
                        const char *psz_format, ... )
{
    va_list args;

    vlc_mutex_lock( &p_i->lock );

    va_start( args, psz_format );
    const int i_ret = InputItemVaAddInfo( p_i, psz_cat, psz_name, psz_format, args );
    va_end( args );

    vlc_mutex_unlock( &p_i->lock );


    if( !i_ret )
        vlc_event_send( &p_i->event_manager, &(vlc_event_t) {
            .type = vlc_InputItemInfoChanged } );

    return i_ret;
}",1,1,input\item.c,input_item_AddInfo,,false,771,792,input_item_AddInfo,,,38,"int input_item_AddInfo (input_item_t*,char*,char*,char*...)"
65940,METHOD,input\item.c:<global>,TYPE_DECL,"int input_item_DelInfo( input_item_t *p_i,
                        const char *psz_cat,
                        const char *psz_name )
{
    vlc_mutex_lock( &p_i->lock );
    int i_cat;
    info_category_t *p_cat = InputItemFindCat( p_i, &i_cat, psz_cat );
    if( !p_cat )
    {
        vlc_mutex_unlock( &p_i->lock );
        return VLC_EGENERIC;
    }

    if( psz_name )
    {
        /* Remove a specific info */
        int i_ret = info_category_DeleteInfo( p_cat, psz_name );
        if( i_ret )
        {
            vlc_mutex_unlock( &p_i->lock );
            return VLC_EGENERIC;
        }
    }
    else
    {
        /* Remove the complete categorie */
        info_category_Delete( p_cat );
        TAB_ERASE(p_i->i_categories, p_i->pp_categories, i_cat);
    }
    vlc_mutex_unlock( &p_i->lock );

    vlc_event_send( &p_i->event_manager,
                    &(vlc_event_t) { .type = vlc_InputItemInfoChanged } );

    return VLC_SUCCESS;
}",1,1,input\item.c,input_item_DelInfo,,false,794,829,input_item_DelInfo,,,39,"int input_item_DelInfo (input_item_t*,char*,char*)"
66023,METHOD,input\item.c:<global>,TYPE_DECL,"void input_item_ReplaceInfos( input_item_t *p_item, info_category_t *p_cat )
{
    vlc_mutex_lock( &p_item->lock );
    int i_cat;
    info_category_t *p_old = InputItemFindCat( p_item, &i_cat, p_cat->psz_name );
    if( p_old )
    {
        info_category_Delete( p_old );
        p_item->pp_categories[i_cat] = p_cat;
    }
    else
        TAB_APPEND(p_item->i_categories, p_item->pp_categories, p_cat);
    vlc_mutex_unlock( &p_item->lock );

    vlc_event_send( &p_item->event_manager,
                    &(vlc_event_t) { .type = vlc_InputItemInfoChanged } );
}",1,1,input\item.c,input_item_ReplaceInfos,,false,830,846,input_item_ReplaceInfos,,,40,"void input_item_ReplaceInfos (input_item_t*,info_category_t*)"
66085,METHOD,input\item.c:<global>,TYPE_DECL,"void input_item_MergeInfos( input_item_t *p_item, info_category_t *p_cat )
{
    vlc_mutex_lock( &p_item->lock );
    info_category_t *p_old = InputItemFindCat( p_item, NULL, p_cat->psz_name );
    if( p_old )
    {
        for( int i = 0; i < p_cat->i_infos; i++ )
            info_category_ReplaceInfo( p_old, p_cat->pp_infos[i] );
        TAB_CLEAN( p_cat->i_infos, p_cat->pp_infos );
        info_category_Delete( p_cat );
    }
    else
        TAB_APPEND(p_item->i_categories, p_item->pp_categories, p_cat);
    vlc_mutex_unlock( &p_item->lock );

    vlc_event_send( &p_item->event_manager,
                    &(vlc_event_t) { .type = vlc_InputItemInfoChanged } );
}",1,1,input\item.c,input_item_MergeInfos,,false,848,865,input_item_MergeInfos,,,41,"void input_item_MergeInfos (input_item_t*,info_category_t*)"
66165,METHOD,input\item.c:<global>,TYPE_DECL,"void input_item_SetEpgEvent( input_item_t *p_item, const vlc_epg_event_t *p_epg_evt )
{
    bool b_changed = false;
    vlc_mutex_lock( &p_item->lock );

    for( int i = 0; i < p_item->i_epg; i++ )
    {
        vlc_epg_t *p_epg = p_item->pp_epg[i];
        for( size_t j = 0; j < p_epg->i_event; j++ )
        {
            /* Same event can exist in more than one table */
            if( p_epg->pp_event[j]->i_id == p_epg_evt->i_id )
            {
                vlc_epg_event_t *p_dup = vlc_epg_event_Duplicate( p_epg_evt );
                if( p_dup )
                {
                    if( p_epg->p_current == p_epg->pp_event[j] )
                        p_epg->p_current = p_dup;
                    vlc_epg_event_Delete( p_epg->pp_event[j] );
                    p_epg->pp_event[j] = p_dup;
                    b_changed = true;
                }
                break;
            }
        }
    }
    vlc_mutex_unlock( &p_item->lock );

    if ( b_changed )
    {
        vlc_event...",1,1,input\item.c,input_item_SetEpgEvent,,false,867,900,input_item_SetEpgEvent,,,42,"void input_item_SetEpgEvent (input_item_t*,vlc_epg_event_t*)"
66291,METHOD,input\item.c:<global>,TYPE_DECL,"void input_item_SetEpg( input_item_t *p_item, const vlc_epg_t *p_update, bool b_current_source )
{
    vlc_epg_t *p_epg = vlc_epg_Duplicate( p_update );
    if( !p_epg )
        return;

    vlc_mutex_lock( &p_item->lock );

    /* */
    vlc_epg_t **pp_epg = NULL;
    for( int i = 0; i < p_item->i_epg; i++ )
    {
        if( p_item->pp_epg[i]->i_source_id == p_update->i_source_id &&
            p_item->pp_epg[i]->i_id == p_update->i_id )
        {
            pp_epg = &p_item->pp_epg[i];
            break;
        }
    }

    /* replace with new version */
    if( pp_epg )
    {
        vlc_epg_Delete( *pp_epg );
        if( *pp_epg == p_item->p_epg_table ) /* current table can have changed */
            p_item->p_epg_table = NULL;
        *pp_epg = p_epg;
    }
    else
    {
        TAB_APPEND( p_item->i_epg, p_item->pp_epg, p_epg );
    }

    if( b_current_source && p_epg->b_present )
        p_item->p_epg_table = p_epg;

    vlc_mutex_unlock( &p_item->lock );

#ifdef EPG_DE...",1,1,input\item.c,input_item_SetEpg,,false,919,994,input_item_SetEpg,,,43,"void input_item_SetEpg (input_item_t*,vlc_epg_t*,bool)"
66428,METHOD,input\item.c:<global>,TYPE_DECL,"void input_item_ChangeEPGSource( input_item_t *p_item, int i_source_id )
{
    vlc_mutex_lock( &p_item->lock );
    p_item->p_epg_table = NULL;
    if( i_source_id > 0 )
    {
        /* Update pointer to current/next table in the full schedule */
        for( int i = 0; i < p_item->i_epg; i++ )
        {
            if( p_item->pp_epg[i]->i_source_id == i_source_id &&
                p_item->pp_epg[i]->b_present )
            {
                p_item->p_epg_table = p_item->pp_epg[i];
                break;
            }
        }
    }
    vlc_mutex_unlock( &p_item->lock );
}",1,1,input\item.c,input_item_ChangeEPGSource,,false,996,1014,input_item_ChangeEPGSource,,,44,"void input_item_ChangeEPGSource (input_item_t*,int)"
66497,METHOD,input\item.c:<global>,TYPE_DECL,"void input_item_SetEpgTime( input_item_t *p_item, int64_t i_time )
{
    vlc_mutex_lock( &p_item->lock );
    p_item->i_epg_time = i_time;
    vlc_mutex_unlock( &p_item->lock );
}",1,1,input\item.c,input_item_SetEpgTime,,false,1016,1021,input_item_SetEpgTime,,,45,"void input_item_SetEpgTime (input_item_t*,int64_t)"
66518,METHOD,input\item.c:<global>,TYPE_DECL,"void input_item_SetEpgOffline( input_item_t *p_item )
{
    input_item_ChangeEPGSource( p_item, -1 );

#ifdef EPG_DEBUG
    vlc_mutex_lock( &p_item->lock );
    const int i_epg_info = p_item->i_epg;
    if( i_epg_info > 0 )
    {
        char *ppsz_epg_info[i_epg_info];
        for( int i = 0; i < p_item->i_epg; i++ )
        {
            const vlc_epg_t *p_epg = p_item->pp_epg[i];
            if( asprintf( &ppsz_epg_info[i], ""EPG %s"", p_epg->psz_name ? p_epg->psz_name : ""unknown"" ) < 0 )
                ppsz_epg_info[i] = NULL;
        }
        vlc_mutex_unlock( &p_item->lock );

        for( int i = 0; i < i_epg_info; i++ )
        {
            if( !ppsz_epg_info[i] )
                continue;
            input_item_DelInfo( p_item, ppsz_epg_info[i], NULL );
            free( ppsz_epg_info[i] );
        }
    }
    else
        vlc_mutex_unlock( &p_item->lock );
#endif

    vlc_event_send( &p_item->event_manager,
                    &(vlc_event_t) { .type = vlc_InputItemInfoCha...",1,1,input\item.c,input_item_SetEpgOffline,,false,1023,1055,input_item_SetEpgOffline,,,46,void input_item_SetEpgOffline (input_item_t*)
66540,METHOD,input\item.c:<global>,TYPE_DECL,"input_item_t *
input_item_NewExt( const char *psz_uri, const char *psz_name,
                   mtime_t duration, int type, enum input_item_net_type i_net )
{
    input_item_owner_t *owner = calloc( 1, sizeof( *owner ) );
    if( unlikely(owner == NULL) )
        return NULL;

    atomic_init( &owner->refs, 1 );

    input_item_t *p_input = &owner->item;
    vlc_event_manager_t * p_em = &p_input->event_manager;

    vlc_mutex_init( &p_input->lock );

    p_input->psz_name = NULL;
    if( psz_name )
        input_item_SetName( p_input, psz_name );

    p_input->psz_uri = NULL;
    if( psz_uri )
        input_item_SetURI( p_input, psz_uri );
    else
    {
        p_input->i_type = ITEM_TYPE_UNKNOWN;
        p_input->b_net = false;
    }

    TAB_INIT( p_input->i_options, p_input->ppsz_options );
    p_input->optflagc = 0;
    p_input->optflagv = NULL;
    p_input->opaques = NULL;

    p_input->i_duration = duration;
    TAB_INIT( p_input->i_categories, p_input->pp_categories );
    T...",1,1,input\item.c,input_item_NewExt,,false,1057,1107,input_item_NewExt,,,47,"input_item_t input_item_NewExt (char*,char*,mtime_t,int,input_item_net_type)"
66721,METHOD,input\item.c:<global>,TYPE_DECL,"input_item_t *input_item_Copy( input_item_t *p_input )
{
    vlc_meta_t *meta = NULL;
    input_item_t *item;
    bool b_net;

    vlc_mutex_lock( &p_input->lock );

    item = input_item_NewExt( p_input->psz_uri, p_input->psz_name,
                              p_input->i_duration, p_input->i_type,
                              ITEM_NET_UNKNOWN );
    if( likely(item != NULL) && p_input->p_meta != NULL )
    {
        meta = vlc_meta_New();
        vlc_meta_Merge( meta, p_input->p_meta );
    }
    b_net = p_input->b_net;
    vlc_mutex_unlock( &p_input->lock );

    if( likely(item != NULL) )
    {   /* No need to lock; no other thread has seen this new item yet. */
        input_item_CopyOptions( item, p_input );
        item->p_meta = meta;
        item->b_net = b_net;
    }

    return item;
}",1,1,input\item.c,input_item_Copy,,false,1109,1136,input_item_Copy,,,48,input_item_t input_item_Copy (input_item_t*)
66808,METHOD,input\item.c:<global>,TYPE_DECL,"static int typecmp( const void *key, const void *entry )
{
    const struct item_type_entry *type = entry;
    const char *uri = key, *scheme = type->psz_scheme;

    return strncmp( uri, scheme, strlen( scheme ) );
}",1,1,input\item.c,typecmp,,false,1145,1151,typecmp,,,50,"int typecmp (void*,void*)"
66834,METHOD,input\item.c:<global>,TYPE_DECL,"static int GuessType( const input_item_t *p_item, bool *p_net )
{
    static const struct item_type_entry tab[] =
    {   /* /!\ Alphabetical order /!\ */
        /* Short match work, not just exact match */
        { ""alsa"",   ITEM_TYPE_CARD, false },
        { ""atsc"",   ITEM_TYPE_CARD, false },
        { ""bd"",     ITEM_TYPE_DISC, false },
        { ""bluray"", ITEM_TYPE_DISC, false },
        { ""cable"",  ITEM_TYPE_CARD, false },
        { ""cdda"",   ITEM_TYPE_DISC, false },
        { ""cqam"",   ITEM_TYPE_CARD, false },
        { ""dc1394"", ITEM_TYPE_CARD, false },
        { ""dccp"",   ITEM_TYPE_STREAM, true },
        { ""deckli"", ITEM_TYPE_CARD, false }, /* decklink */
        { ""dir"",    ITEM_TYPE_DIRECTORY, false },
        { ""dshow"",  ITEM_TYPE_CARD, false },
        { ""dtv"",    ITEM_TYPE_CARD, false },
        { ""dvb"",    ITEM_TYPE_CARD, false },
        { ""dvd"",    ITEM_TYPE_DISC, false },
        { ""eyetv"",  ITEM_TYPE_CARD, false },
        { ""fd"",     ITEM_TYPE_UNKNOWN, false },
...",1,1,input\item.c,GuessType,,false,1154,1239,GuessType,,,51,"int GuessType (input_item_t*,bool*)"
67157,METHOD,input\item.c:<global>,TYPE_DECL,"input_item_node_t *input_item_node_Create( input_item_t *p_input )
{
    input_item_node_t* p_node = malloc( sizeof( input_item_node_t ) );
    if( !p_node )
        return NULL;

    assert( p_input );

    p_node->p_item = p_input;
    input_item_Hold( p_input );

    p_node->i_children = 0;
    p_node->pp_children = NULL;

    return p_node;
}",1,1,input\item.c,input_item_node_Create,,false,1241,1256,input_item_node_Create,,,52,input_item_node_t input_item_node_Create (input_item_t*)
67195,METHOD,input\item.c:<global>,TYPE_DECL,"void input_item_node_Delete( input_item_node_t *p_node )
{
    for( int i = 0; i < p_node->i_children; i++ )
        input_item_node_Delete( p_node->pp_children[i] );

    input_item_Release( p_node->p_item );
    free( p_node->pp_children );
    free( p_node );
}",1,1,input\item.c,input_item_node_Delete,,false,1258,1266,input_item_node_Delete,,,53,void input_item_node_Delete (input_item_node_t*)
67229,METHOD,input\item.c:<global>,TYPE_DECL,"input_item_node_t *input_item_node_AppendItem( input_item_node_t *p_node, input_item_t *p_item )
{
    int i_preparse_depth;
    input_item_node_t *p_new_child = input_item_node_Create( p_item );
    if( !p_new_child ) return NULL;

    vlc_mutex_lock( &p_node->p_item->lock );
    i_preparse_depth = p_node->p_item->i_preparse_depth;
    vlc_mutex_unlock( &p_node->p_item->lock );

    vlc_mutex_lock( &p_item->lock );
    p_item->i_preparse_depth = i_preparse_depth > 0 ?
                               i_preparse_depth -1 :
                               i_preparse_depth;
    vlc_mutex_unlock( &p_item->lock );

    input_item_node_AppendNode( p_node, p_new_child );
    return p_new_child;
}",1,1,input\item.c,input_item_node_AppendItem,,false,1268,1286,input_item_node_AppendItem,,,54,"input_item_node_t input_item_node_AppendItem (input_item_node_t*,input_item_t*)"
67295,METHOD,input\item.c:<global>,TYPE_DECL,"void input_item_node_AppendNode( input_item_node_t *p_parent,
                                 input_item_node_t *p_child )
{
    assert(p_parent != NULL);
    assert(p_child != NULL);
    TAB_APPEND(p_parent->i_children, p_parent->pp_children, p_child);
}",1,1,input\item.c,input_item_node_AppendNode,,false,1288,1294,input_item_node_AppendNode,,,55,"void input_item_node_AppendNode (input_item_node_t*,input_item_node_t*)"
67317,METHOD,input\item.c:<global>,TYPE_DECL,"void input_item_node_RemoveNode( input_item_node_t *parent,
                                 input_item_node_t *child )
{
    TAB_REMOVE(parent->i_children, parent->pp_children, child);
}",1,1,input\item.c,input_item_node_RemoveNode,,false,1296,1300,input_item_node_RemoveNode,,,56,"void input_item_node_RemoveNode (input_item_node_t*,input_item_node_t*)"
67331,METHOD,input\item.c:<global>,TYPE_DECL,"void input_item_node_PostAndDelete( input_item_node_t *p_root )
{
    vlc_event_send( &p_root->p_item->event_manager, &(vlc_event_t) {
        .type = vlc_InputItemSubItemTreeAdded,
        .u.input_item_subitem_tree_added.p_root = p_root } );

    input_item_node_Delete( p_root );
}",1,1,input\item.c,input_item_node_PostAndDelete,,false,1302,1309,input_item_node_PostAndDelete,,,57,void input_item_node_PostAndDelete (input_item_node_t*)
67363,METHOD,input\item.c:<global>,TYPE_DECL,"void input_item_UpdateTracksInfo(input_item_t *item, const es_format_t *fmt)
{
    int i;
    es_format_t *fmt_copy = malloc(sizeof *fmt_copy);
    if (!fmt_copy)
        return;

    es_format_Copy(fmt_copy, fmt);

    vlc_mutex_lock( &item->lock );

    for( i = 0; i < item->i_es; i++ )
    {
        if (item->es[i]->i_id != fmt->i_id)
            continue;

        /* We've found the right ES, replace it */
        es_format_Clean(item->es[i]);
        free(item->es[i]);
        item->es[i] = fmt_copy;
        vlc_mutex_unlock( &item->lock );
        return;
    }

    /* ES not found, insert it */
    TAB_APPEND(item->i_es, item->es, fmt_copy);
    vlc_mutex_unlock( &item->lock );
}",1,1,input\item.c,input_item_UpdateTracksInfo,,false,1312,1339,input_item_UpdateTracksInfo,,,58,"void input_item_UpdateTracksInfo (input_item_t*,es_format_t*)"
67455,METHOD,input\item.c:<global>,TYPE_DECL,"static int rdh_compar_type(input_item_t *p1, input_item_t *p2)
{
    if (p1->i_type != p2->i_type)
    {
        if (p1->i_type == ITEM_TYPE_DIRECTORY)
            return -1;
        if (p2->i_type == ITEM_TYPE_DIRECTORY)
            return 1;
    }
    return 0;
}",1,1,input\item.c,rdh_compar_type,,false,1341,1351,rdh_compar_type,,,59,"int rdh_compar_type (input_item_t*,input_item_t*)"
67491,METHOD,input\item.c:<global>,TYPE_DECL,"static int rdh_compar_filename(const void *a, const void *b)
{
    input_item_node_t *const *na = a, *const *nb = b;
    input_item_t *ia = (*na)->p_item, *ib = (*nb)->p_item;

    int i_ret = rdh_compar_type(ia, ib);
    if (i_ret != 0)
        return i_ret;

    return vlc_filenamecmp(ia->psz_name, ib->psz_name);
}",1,1,input\item.c,rdh_compar_filename,,false,1353,1363,rdh_compar_filename,,,60,"int rdh_compar_filename (void*,void*)"
67540,METHOD,input\item.c:<global>,TYPE_DECL,"static void rdh_sort(input_item_node_t *p_node)
{
    if (p_node->i_children <= 0)
        return;

    /* Sort current node */
    qsort(p_node->pp_children, p_node->i_children,
          sizeof(input_item_node_t *), rdh_compar_filename);

    /* Sort all children */
    for (int i = 0; i < p_node->i_children; i++)
        rdh_sort(p_node->pp_children[i]);
}",1,1,input\item.c,rdh_sort,,false,1365,1377,rdh_sort,,,61,void rdh_sort (input_item_node_t*)
67582,METHOD,input\item.c:<global>,TYPE_DECL,"static bool rdh_file_has_ext(const char *psz_filename,
                             const char *psz_ignored_exts)
{
    if (psz_ignored_exts == NULL)
        return false;

    const char *ext = strrchr(psz_filename, '.');
    if (ext == NULL)
        return false;

    size_t extlen = strlen(++ext);

    for (const char *type = psz_ignored_exts, *end; type[0]; type = end + 1)
    {
        end = strchr(type, ',');
        if (end == NULL)
            end = type + strlen(type);

        if (type + extlen == end && !strncasecmp(ext, type, extlen))
            return true;

        if (*end == '\0')
            break;
    }

    return false;
}",1,1,input\item.c,rdh_file_has_ext,,false,1382,1408,rdh_file_has_ext,,,62,"bool rdh_file_has_ext (char*,char*)"
67670,METHOD,input\item.c:<global>,TYPE_DECL,"static bool rdh_file_is_ignored(struct vlc_readdir_helper *p_rdh,
                                const char *psz_filename)
{
    return (psz_filename[0] == '\0'
         || strcmp(psz_filename, ""."") == 0
         || strcmp(psz_filename, "".."") == 0
         || (!p_rdh->b_show_hiddenfiles && psz_filename[0] == '.')
         || rdh_file_has_ext(psz_filename, p_rdh->psz_ignored_exts));
}",1,1,input\item.c,rdh_file_is_ignored,,false,1410,1418,rdh_file_is_ignored,,,63,"bool rdh_file_is_ignored (vlc_readdir_helper*,char*)"
67718,METHOD,<empty>,<empty>,<empty>,1,,input\item.c,rdh_dir:<clinit>,,false,1427,,<clinit>,,,3,
67723,METHOD,input\item.c:<global>,TYPE_DECL,"static char *rdh_name_from_filename(const char *psz_filename)
{
    /* remove leading white spaces */
    while (*psz_filename != '\0' && *psz_filename == ' ')
        psz_filename++;

    char *psz_name = strdup(psz_filename);
    if (!psz_name)
        return NULL;

    /* remove extension */
    char *psz_ptr = strrchr(psz_name, '.');
    if (psz_ptr && psz_ptr != psz_name)
        *psz_ptr = '\0';

    /* remove trailing white spaces */
    int i = strlen(psz_name) - 1;
    while (psz_name[i] == ' ' && i >= 0)
        psz_name[i--] = '\0';

    /* convert to lower case */
    psz_ptr = psz_name;
    while (*psz_ptr != '\0')
    {
        *psz_ptr = tolower(*psz_ptr);
        psz_ptr++;
    }

    return psz_name;
}",1,1,input\item.c,rdh_name_from_filename,,false,1433,1462,rdh_name_from_filename,,,66,char* rdh_name_from_filename (char*)
67810,METHOD,input\item.c:<global>,TYPE_DECL,"static uint8_t rdh_get_slave_priority(input_item_t *p_item,
                                      input_item_slave_t *p_slave,
                                      const char *psz_slave_filename)
{
    uint8_t i_priority = SLAVE_PRIORITY_MATCH_NONE;
    char *psz_item_name = rdh_name_from_filename(p_item->psz_name);
    char *psz_slave_name = rdh_name_from_filename(psz_slave_filename);

    if (!psz_item_name || !psz_slave_name)
        goto done;

    size_t i_item_len = strlen(psz_item_name);
    size_t i_slave_len = strlen(psz_slave_name);

    /* The slave name len should not be twice longer than the item name len. */
    if (i_item_len > i_slave_len || i_slave_len > 2 * i_item_len)
        goto done;

    /* check if the names match exactly */
    if (!strcmp(psz_item_name, psz_slave_name))
    {
        i_priority = SLAVE_PRIORITY_MATCH_ALL;
        goto done;
    }

    /* ""cdg"" slaves have to be a full match */
    if (p_slave->i_type == SLAVE_TYPE_SPU)
    {
        char *...",1,1,input\item.c,rdh_get_slave_priority,,false,1464,1519,rdh_get_slave_priority,,,67,"uint8_t rdh_get_slave_priority (input_item_t*,input_item_slave_t*,char*)"
67934,METHOD,input\item.c:<global>,TYPE_DECL,"static int rdh_should_match_idx(struct vlc_readdir_helper *p_rdh,
                                struct rdh_slave *p_rdh_sub)
{
    char *psz_ext = strrchr(p_rdh_sub->psz_filename, '.');
    if (!psz_ext)
        return false;
    psz_ext++;

    if (strcasecmp(psz_ext, ""sub"") != 0)
        return false;

    for (size_t i = 0; i < p_rdh->i_slaves; i++)
    {
        struct rdh_slave *p_rdh_slave = p_rdh->pp_slaves[i];

        if (p_rdh_slave == NULL || p_rdh_slave == p_rdh_sub)
            continue;

        /* check that priorities match */
        if (p_rdh_slave->p_slave->i_priority !=
            p_rdh_sub->p_slave->i_priority)
            continue;

        /* check that the filenames without extension match */
        if (strncasecmp(p_rdh_sub->psz_filename, p_rdh_slave->psz_filename,
                        strlen(p_rdh_sub->psz_filename) - 3 ) != 0)
            continue;

        /* check that we have an idx file */
        char *psz_ext_idx = strrchr(p_rdh_slave->psz_fil...",1,1,input\item.c,rdh_should_match_idx,,false,1521,1558,rdh_should_match_idx,,,68,"int rdh_should_match_idx (vlc_readdir_helper*,rdh_slave*)"
68056,METHOD,input\item.c:<global>,TYPE_DECL,"static void rdh_attach_slaves(struct vlc_readdir_helper *p_rdh,
                              input_item_node_t *p_parent_node)
{
    if (p_rdh->i_sub_autodetect_fuzzy == 0)
        return;

    /* Try to match slaves for each items of the node */
    for (int i = 0; i < p_parent_node->i_children; i++)
    {
        input_item_node_t *p_node = p_parent_node->pp_children[i];
        input_item_t *p_item = p_node->p_item;

        enum slave_type unused;
        if (!input_item_IsMaster(p_item->psz_name)
         || input_item_slave_GetType(p_item->psz_name, &unused))
            continue; /* don't match 2 possible slaves between each others */

        for (size_t j = 0; j < p_rdh->i_slaves; j++)
        {
            struct rdh_slave *p_rdh_slave = p_rdh->pp_slaves[j];

            /* Don't try to match slaves with themselves or slaves already
             * attached with the higher priority */
            if (p_rdh_slave->p_node == p_node
             || p_rdh_slave->p_slave->i_pri...",1,1,input\item.c,rdh_attach_slaves,,false,1560,1628,rdh_attach_slaves,,,69,"void rdh_attach_slaves (vlc_readdir_helper*,input_item_node_t*)"
68264,METHOD,input\item.c:<global>,TYPE_DECL,"static int rdh_unflatten(struct vlc_readdir_helper *p_rdh,
                         input_item_node_t **pp_node, const char *psz_path,
                         int i_net)
{
    /* Create an input input for each sub folders that is contained in the full
     * path. Update pp_node to point to the direct parent of the future item to
     * add. */

    assert(psz_path != NULL);
    const char *psz_subpaths = psz_path;

    while ((psz_subpaths = strchr(psz_subpaths, '/')))
    {
        input_item_node_t *p_subnode = NULL;

        /* Check if this sub folder item was already added */
        for (size_t i = 0; i < p_rdh->i_dirs && p_subnode == NULL; i++)
        {
            struct rdh_dir *rdh_dir = p_rdh->pp_dirs[i];
            if (!strncmp(rdh_dir->psz_path, psz_path, psz_subpaths - psz_path))
                p_subnode = rdh_dir->p_node;
        }

        /* The sub folder item doesn't exist, so create it */
        if (p_subnode == NULL)
        {
            size_t i_sub_path...",1,1,input\item.c,rdh_unflatten,,false,1630,1694,rdh_unflatten,,,70,"int rdh_unflatten (vlc_readdir_helper*,input_item_node_t**,char*,int)"
68464,METHOD,input\item.c:<global>,TYPE_DECL,"void vlc_readdir_helper_init(struct vlc_readdir_helper *p_rdh,
                             vlc_object_t *p_obj, input_item_node_t *p_node)
{
    /* Read options from the parent item. This allows vlc_stream_ReadDir()
     * users to specify options whitout touhing any vlc_object_t. Apply options
     * on a temporary object in order to not apply options (that can be
     * insecure) to the current object. */
    vlc_object_t *p_var_obj = vlc_object_create(p_obj, sizeof(vlc_object_t));
    if (p_var_obj != NULL)
    {
        input_item_ApplyOptions(p_var_obj, p_node->p_item);
        p_obj = p_var_obj;
    }

    p_rdh->p_node = p_node;
    p_rdh->b_show_hiddenfiles = var_InheritBool(p_obj, ""show-hiddenfiles"");
    p_rdh->psz_ignored_exts = var_InheritString(p_obj, ""ignore-filetypes"");
    bool b_autodetect = var_InheritBool(p_obj, ""sub-autodetect-file"");
    p_rdh->i_sub_autodetect_fuzzy = !b_autodetect ? 0 :
        var_InheritInteger(p_obj, ""sub-autodetect-fuzzy"");
    p_rdh->b_f...",1,1,input\item.c,vlc_readdir_helper_init,,false,1697,1723,vlc_readdir_helper_init,,,71,"void vlc_readdir_helper_init (vlc_readdir_helper*,vlc_object_t*,input_item_node_t*)"
68555,METHOD,input\item.c:<global>,TYPE_DECL,"void vlc_readdir_helper_finish(struct vlc_readdir_helper *p_rdh, bool b_success)
{
    if (b_success)
    {
        rdh_sort(p_rdh->p_node);
        rdh_attach_slaves(p_rdh, p_rdh->p_node);
    }
    free(p_rdh->psz_ignored_exts);

    /* Remove unmatched slaves */
    for (size_t i = 0; i < p_rdh->i_slaves; i++)
    {
        struct rdh_slave *p_rdh_slave = p_rdh->pp_slaves[i];
        if (p_rdh_slave != NULL)
        {
            input_item_slave_Delete(p_rdh_slave->p_slave);
            free(p_rdh_slave->psz_filename);
            free(p_rdh_slave);
        }
    }
    TAB_CLEAN(p_rdh->i_slaves, p_rdh->pp_slaves);

    for (size_t i = 0; i < p_rdh->i_dirs; i++)
        free(p_rdh->pp_dirs[i]);
    TAB_CLEAN(p_rdh->i_dirs, p_rdh->pp_dirs);
}",1,1,input\item.c,vlc_readdir_helper_finish,,false,1725,1750,vlc_readdir_helper_finish,,,72,"void vlc_readdir_helper_finish (vlc_readdir_helper*,bool)"
68647,METHOD,input\item.c:<global>,TYPE_DECL,"int vlc_readdir_helper_additem(struct vlc_readdir_helper *p_rdh,
                               const char *psz_uri, const char *psz_flatpath,
                               const char *psz_filename, int i_type, int i_net)
{
    enum slave_type i_slave_type;
    struct rdh_slave *p_rdh_slave = NULL;
    assert(psz_flatpath || psz_filename);

    if (!p_rdh->b_flatten)
    {
        if (psz_filename == NULL)
        {
            psz_filename = strrchr(psz_flatpath, '/');
            if (psz_filename != NULL)
                ++psz_filename;
            else
                psz_filename = psz_flatpath;
        }
    }
    else
    {
        if (psz_filename == NULL)
            psz_filename = psz_flatpath;
        psz_flatpath = NULL;
    }

    if (p_rdh->i_sub_autodetect_fuzzy != 0
     && input_item_slave_GetType(psz_filename, &i_slave_type))
    {
        p_rdh_slave = malloc(sizeof(*p_rdh_slave));
        if (!p_rdh_slave)
            return VLC_ENOMEM;

        p_rdh_slave->p_no...",1,1,input\item.c,vlc_readdir_helper_additem,,false,1752,1828,vlc_readdir_helper_additem,,,73,"int vlc_readdir_helper_additem (vlc_readdir_helper*,char*,char*,char*,int,int)"
68866,METHOD,input\item.h:<global>,TYPE_DECL,<global>,1,1,input\item.h,input\item.h:<global>,,false,1,42,<global>,,,1,
68868,METHOD,input\item.h:<global>,TYPE_DECL,"void input_item_SetErrorWhenReading( input_item_t *p_i, bool b_error );",6,70,input\item.h,input_item_SetErrorWhenReading,,false,30,30,input_item_SetErrorWhenReading,,,1,"void input_item_SetErrorWhenReading (input_item_t*,bool)"
68874,METHOD,input\item.h:<global>,TYPE_DECL,"void input_item_UpdateTracksInfo( input_item_t *item, const es_format_t *fmt );",6,78,input\item.h,input_item_UpdateTracksInfo,,false,31,31,input_item_UpdateTracksInfo,,,2,"void input_item_UpdateTracksInfo (input_item_t*,es_format_t*)"
68880,METHOD,input\item.h:<global>,TYPE_DECL,bool input_item_ShouldPreparseSubItems( input_item_t *p_i );,6,59,input\item.h,input_item_ShouldPreparseSubItems,,false,32,32,input_item_ShouldPreparseSubItems,,,3,bool input_item_ShouldPreparseSubItems (input_item_t*)
68912,METHOD,input\meta.c:<global>,TYPE_DECL,<global>,1,1,input\meta.c,input\meta.c:<global>,,false,1,324,<global>,,,1,
68918,METHOD,<empty>,<empty>,<empty>,1,,input\meta.c,vlc_meta_t:<clinit>,,false,41,,<clinit>,,,4,
68924,METHOD,input\meta.c:<global>,TYPE_DECL,"const char * vlc_meta_TypeToLocalizedString( vlc_meta_type_t meta_type )
{
    static const char posix_names[][18] =
    {
        [vlc_meta_Title]       = N_(""Title""),
        [vlc_meta_Artist]      = N_(""Artist""),
        [vlc_meta_Genre]       = N_(""Genre""),
        [vlc_meta_Copyright]   = N_(""Copyright""),
        [vlc_meta_Album]       = N_(""Album""),
        [vlc_meta_TrackNumber] = N_(""Track number""),
        [vlc_meta_Description] = N_(""Description""),
        [vlc_meta_Rating]      = N_(""Rating""),
        [vlc_meta_Date]        = N_(""Date""),
        [vlc_meta_Setting]     = N_(""Setting""),
        [vlc_meta_URL]         = N_(""URL""),
        [vlc_meta_Language]    = N_(""Language""),
        [vlc_meta_ESNowPlaying]= N_(""Now Playing""),
        [vlc_meta_NowPlaying]  = N_(""Now Playing""),
        [vlc_meta_Publisher]   = N_(""Publisher""),
        [vlc_meta_EncodedBy]   = N_(""Encoded by""),
        [vlc_meta_ArtworkURL]  = N_(""Artwork URL""),
        [vlc_meta_TrackID]     = N_(""Track I...",1,1,input\meta.c,vlc_meta_TypeToLocalizedString,,false,51,85,vlc_meta_TypeToLocalizedString,,,2,const char* vlc_meta_TypeToLocalizedString (vlc_meta_type_t)
69078,METHOD,input\meta.c:<global>,TYPE_DECL,"vlc_meta_t *vlc_meta_New( void )
{
    vlc_meta_t *m = (vlc_meta_t*)malloc( sizeof(*m) );
    if( !m )
        return NULL;
    memset( m->ppsz_meta, 0, sizeof(m->ppsz_meta) );
    m->i_status = 0;
    vlc_dictionary_init( &m->extra_tags, 0 );
    return m;
}",1,1,input\meta.c,vlc_meta_New,,false,92,101,vlc_meta_New,,,3,vlc_meta_t vlc_meta_New (void)
69120,METHOD,input\meta.c:<global>,TYPE_DECL,"static void vlc_meta_FreeExtraKey( void *p_data, void *p_obj )
{
    VLC_UNUSED( p_obj );
    free( p_data );
}",1,1,input\meta.c,vlc_meta_FreeExtraKey,,false,104,108,vlc_meta_FreeExtraKey,,,4,"void vlc_meta_FreeExtraKey (void*,void*)"
69130,METHOD,input\meta.c:<global>,TYPE_DECL,"void vlc_meta_Delete( vlc_meta_t *m )
{
    for( int i = 0; i < VLC_META_TYPE_COUNT ; i++ )
        free( m->ppsz_meta[i] );
    vlc_dictionary_clear( &m->extra_tags, vlc_meta_FreeExtraKey, NULL );
    free( m );
}",1,1,input\meta.c,vlc_meta_Delete,,false,110,116,vlc_meta_Delete,,,5,void vlc_meta_Delete (vlc_meta_t*)
69161,METHOD,input\meta.c:<global>,TYPE_DECL,"void vlc_meta_Set( vlc_meta_t *p_meta, vlc_meta_type_t meta_type, const char *psz_val )
{
    free( p_meta->ppsz_meta[meta_type] );
    assert( psz_val == NULL || IsUTF8( psz_val ) );
    p_meta->ppsz_meta[meta_type] = psz_val ? strdup( psz_val ) : NULL;
}",1,1,input\meta.c,vlc_meta_Set,,false,124,129,vlc_meta_Set,,,6,"void vlc_meta_Set (vlc_meta_t*,vlc_meta_type_t,char*)"
69192,METHOD,input\meta.c:<global>,TYPE_DECL,"const char *vlc_meta_Get( const vlc_meta_t *p_meta, vlc_meta_type_t meta_type )
{
    return p_meta->ppsz_meta[meta_type];
}",1,1,input\meta.c,vlc_meta_Get,,false,131,134,vlc_meta_Get,,,7,"const char* vlc_meta_Get (vlc_meta_t*,vlc_meta_type_t)"
69204,METHOD,input\meta.c:<global>,TYPE_DECL,"void vlc_meta_AddExtra( vlc_meta_t *m, const char *psz_name, const char *psz_value )
{
    char *psz_oldvalue = (char *)vlc_dictionary_value_for_key( &m->extra_tags, psz_name );
    if( psz_oldvalue != kVLCDictionaryNotFound )
        vlc_dictionary_remove_value_for_key( &m->extra_tags, psz_name,
                                            vlc_meta_FreeExtraKey, NULL );
    vlc_dictionary_insert( &m->extra_tags, psz_name, strdup(psz_value) );
}",1,1,input\meta.c,vlc_meta_AddExtra,,false,136,143,vlc_meta_AddExtra,,,8,"void vlc_meta_AddExtra (vlc_meta_t*,char*,char*)"
69243,METHOD,input\meta.c:<global>,TYPE_DECL,"const char * vlc_meta_GetExtra( const vlc_meta_t *m, const char *psz_name )
{
    return (char *)vlc_dictionary_value_for_key(&m->extra_tags, psz_name);
}",1,1,input\meta.c,vlc_meta_GetExtra,,false,145,148,vlc_meta_GetExtra,,,9,"const char* vlc_meta_GetExtra (vlc_meta_t*,char*)"
69258,METHOD,input\meta.c:<global>,TYPE_DECL,"unsigned vlc_meta_GetExtraCount( const vlc_meta_t *m )
{
    return vlc_dictionary_keys_count(&m->extra_tags);
}",1,1,input\meta.c,vlc_meta_GetExtraCount,,false,150,153,vlc_meta_GetExtraCount,,,10,unsigned vlc_meta_GetExtraCount (vlc_meta_t*)
69269,METHOD,input\meta.c:<global>,TYPE_DECL,"char** vlc_meta_CopyExtraNames( const vlc_meta_t *m )
{
    return vlc_dictionary_all_keys(&m->extra_tags);
}",1,1,input\meta.c,vlc_meta_CopyExtraNames,,false,155,158,vlc_meta_CopyExtraNames,,,11,char** vlc_meta_CopyExtraNames (vlc_meta_t*)
69280,METHOD,input\meta.c:<global>,TYPE_DECL,"int vlc_meta_GetStatus( vlc_meta_t *m )
{
    return m->i_status;
}",1,1,input\meta.c,vlc_meta_GetStatus,,false,163,166,vlc_meta_GetStatus,,,12,int vlc_meta_GetStatus (vlc_meta_t*)
69289,METHOD,input\meta.c:<global>,TYPE_DECL,"void vlc_meta_SetStatus( vlc_meta_t *m, int status )
{
    m->i_status = status;
}",1,1,input\meta.c,vlc_meta_SetStatus,,false,168,171,vlc_meta_SetStatus,,,13,"void vlc_meta_SetStatus (vlc_meta_t*,int)"
69300,METHOD,input\meta.c:<global>,TYPE_DECL,"void vlc_meta_Merge( vlc_meta_t *dst, const vlc_meta_t *src )
{
    if( !dst || !src )
        return;

    for( int i = 0; i < VLC_META_TYPE_COUNT; i++ )
    {
        if( src->ppsz_meta[i] )
        {
            free( dst->ppsz_meta[i] );
            dst->ppsz_meta[i] = strdup( src->ppsz_meta[i] );
        }
    }

    /* XXX: If speed up are needed, it is possible */
    char **ppsz_all_keys = vlc_dictionary_all_keys( &src->extra_tags );
    for( int i = 0; ppsz_all_keys && ppsz_all_keys[i]; i++ )
    {
        /* Always try to remove the previous value */
        vlc_dictionary_remove_value_for_key( &dst->extra_tags, ppsz_all_keys[i], vlc_meta_FreeExtraKey, NULL );

        void *p_value = vlc_dictionary_value_for_key( &src->extra_tags, ppsz_all_keys[i] );
        vlc_dictionary_insert( &dst->extra_tags, ppsz_all_keys[i], strdup( (const char*)p_value ) );
        free( ppsz_all_keys[i] );
    }
    free( ppsz_all_keys );
}",1,1,input\meta.c,vlc_meta_Merge,,false,177,203,vlc_meta_Merge,,,14,"void vlc_meta_Merge (vlc_meta_t*,vlc_meta_t*)"
69412,METHOD,input\meta.c:<global>,TYPE_DECL,"void input_ExtractAttachmentAndCacheArt( input_thread_t *p_input,
                                         const char *name )
{
    input_item_t *p_item = input_priv(p_input)->p_item;

    if( input_item_IsArtFetched( p_item ) )
    {   /* XXX Weird, we should not end up with attachment:// art URL
         * unless there is a race condition */
        msg_Warn( p_input, ""art already fetched"" );
        if( likely(playlist_FindArtInCache( p_item ) == VLC_SUCCESS) )
            return;
    }

    /* */
    input_attachment_t *p_attachment = NULL;

    vlc_mutex_lock( &p_item->lock );
    for( int i_idx = 0; i_idx < input_priv(p_input)->i_attachment; i_idx++ )
    {
        input_attachment_t *a = input_priv(p_input)->attachment[i_idx];

        if( !strcmp( a->psz_name, name ) )
        {
            p_attachment = vlc_input_attachment_Duplicate( a );
            break;
        }
    }
    vlc_mutex_unlock( &p_item->lock );

    if( p_attachment == NULL )
    {
        msg_Warn( p_inp...",1,1,input\meta.c,input_ExtractAttachmentAndCacheArt,,false,206,254,input_ExtractAttachmentAndCacheArt,,,15,"void input_ExtractAttachmentAndCacheArt (input_thread_t*,char*)"
69555,METHOD,input\meta.c:<global>,TYPE_DECL,"int input_item_WriteMeta( vlc_object_t *obj, input_item_t *p_item )
{
    meta_export_t *p_export =
        vlc_custom_create( obj, sizeof( *p_export ), ""meta writer"" );
    if( p_export == NULL )
        return VLC_ENOMEM;
    p_export->p_item = p_item;

    int type;
    vlc_mutex_lock( &p_item->lock );
    type = p_item->i_type;
    vlc_mutex_unlock( &p_item->lock );
    if( type != ITEM_TYPE_FILE )
        goto error;

    char *psz_uri = input_item_GetURI( p_item );
    p_export->psz_file = vlc_uri2path( psz_uri );
    if( p_export->psz_file == NULL )
        msg_Err( p_export, ""cannot write meta to remote media %s"", psz_uri );
    free( psz_uri );
    if( p_export->psz_file == NULL )
        goto error;

    module_t *p_mod = module_need( p_export, ""meta writer"", NULL, false );
    if( p_mod )
        module_unneed( p_export, p_mod );
    vlc_object_release( p_export );
    return VLC_SUCCESS;

error:
    vlc_object_release( p_export );
    return VLC_EGENERIC;
}",1,1,input\meta.c,input_item_WriteMeta,,false,256,288,input_item_WriteMeta,,,16,"int input_item_WriteMeta (vlc_object_t*,input_item_t*)"
69659,METHOD,input\meta.c:<global>,TYPE_DECL,"void vlc_audio_replay_gain_MergeFromMeta( audio_replay_gain_t *p_dst,
                                          const vlc_meta_t *p_meta )
{
    const char * psz_value;

    if( !p_meta )
        return;

    if( (psz_value = vlc_meta_GetExtra(p_meta, ""REPLAYGAIN_TRACK_GAIN"")) ||
        (psz_value = vlc_meta_GetExtra(p_meta, ""RG_RADIO"")) )
    {
        p_dst->pb_gain[AUDIO_REPLAY_GAIN_TRACK] = true;
        p_dst->pf_gain[AUDIO_REPLAY_GAIN_TRACK] = us_atof( psz_value );
    }

    if( (psz_value = vlc_meta_GetExtra(p_meta, ""REPLAYGAIN_TRACK_PEAK"" )) ||
             (psz_value = vlc_meta_GetExtra(p_meta, ""RG_PEAK"" )) )
    {
        p_dst->pb_peak[AUDIO_REPLAY_GAIN_TRACK] = true;
        p_dst->pf_peak[AUDIO_REPLAY_GAIN_TRACK] = us_atof( psz_value );
    }

    if( (psz_value = vlc_meta_GetExtra(p_meta, ""REPLAYGAIN_ALBUM_GAIN"" )) ||
             (psz_value = vlc_meta_GetExtra(p_meta, ""RG_AUDIOPHILE"" )) )
    {
        p_dst->pb_gain[AUDIO_REPLAY_GAIN_ALBUM] = true;
        p_dst->p...",1,1,input\meta.c,vlc_audio_replay_gain_MergeFromMeta,,false,290,324,vlc_audio_replay_gain_MergeFromMeta,,,17,"void vlc_audio_replay_gain_MergeFromMeta (audio_replay_gain_t*,vlc_meta_t*)"
69792,METHOD,input\mrl_helpers.h:<global>,TYPE_DECL,<global>,1,22,input\mrl_helpers.h,input\mrl_helpers.h:<global>,,false,1,166,<global>,,,1,
69794,METHOD,input\mrl_helpers.h:<global>,TYPE_DECL,"static inline int
mrl_EscapeFragmentIdentifier( char** out, char const* payload )
{
    struct vlc_memstream mstream;

#define RFC3986_SUBDELIMS  ""!"" ""$"" ""&"" ""'"" ""("" "")"" \
                           ""*"" ""+"" "","" "";"" ""=""
#define RFC3986_ALPHA      ""abcdefghijklmnopqrstuvwxyz"" \
                           ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""
#define RFC3986_DIGIT      ""0123456789""
#define RFC3986_UNRESERVED RFC3986_ALPHA RFC3986_DIGIT ""-"" ""."" ""_"" ""~""
#define RFC3986_PCHAR      RFC3986_UNRESERVED RFC3986_SUBDELIMS "":"" ""@""
#define RFC3986_FRAGMENT   RFC3986_PCHAR ""/"" ""?""

    if( vlc_memstream_open( &mstream ) )
        return VLC_EGENERIC;

    for( char const* p = payload; *p; ++p )
    {
        vlc_memstream_printf( &mstream,
            ( strchr( ""!?"", *p ) == NULL &&
              strchr( RFC3986_FRAGMENT, *p ) ? ""%c"" : ""%%%02hhx""), *p );
    }

#undef RFC3986_FRAGMENT
#undef RFC3986_PCHAR
#undef RFC3986_UNRESERVEd
#undef RFC3986_DIGIT
#undef RFC3986_ALPHA
#undef RFC3986_SUBDELIMS

    if(...",1,22,input\mrl_helpers.h,mrl_EscapeFragmentIdentifier,,false,57,93,mrl_EscapeFragmentIdentifier,,,1,"int mrl_EscapeFragmentIdentifier (char**,char*)"
69855,METHOD,input\mrl_helpers.h:<global>,TYPE_DECL,"static inline int
mrl_FragmentSplit( vlc_array_t* out_items,
                   char const** out_extra,
                   char const* payload )
{
    char const* extra = NULL;

    vlc_array_init( out_items );

    while( strncmp( payload, ""!/"", 2 ) == 0 )
    {
        payload += 2;

        int len = strcspn( payload, ""!?"" );
        char* decoded = strndup( payload, len );

        if( unlikely( !decoded ) || !vlc_uri_decode( decoded ) )
            goto error;

        if( vlc_array_append( out_items, decoded ) )
        {
            free( decoded );
            goto error;
        }
        payload += len;
    }

    if( *payload )
    {
        if( *payload == '!' )
            goto error;

        if( *payload == '?' && vlc_array_count( out_items ) )
            ++payload;

        extra = payload;
    }

    *out_extra = extra;
    return VLC_SUCCESS;

error:
    for( size_t i = 0; i < vlc_array_count( out_items ); ++i )
        free( vlc_array_item_at_index( out_items, i ...",1,1,input\mrl_helpers.h,mrl_FragmentSplit,,false,114,160,mrl_FragmentSplit,,,2,"int mrl_FragmentSplit (vlc_array_t*,char**,char*)"
69995,METHOD,input\resource.c:<global>,TYPE_DECL,<global>,1,22,input\resource.c,input\resource.c:<global>,,false,1,521,<global>,,,1,
70009,METHOD,input\resource.c:<global>,TYPE_DECL,"static void DestroySout( input_resource_t *p_resource )
{
#ifdef ENABLE_SOUT
    if( p_resource->p_sout )
        sout_DeleteInstance( p_resource->p_sout );
#endif
    p_resource->p_sout = NULL;
}",1,1,input\resource.c,DestroySout,,false,79,86,DestroySout,,,2,void DestroySout (input_resource_t*)
70019,METHOD,input\resource.c:<global>,TYPE_DECL,"static sout_instance_t *RequestSout( input_resource_t *p_resource,
                                     sout_instance_t *p_sout, const char *psz_sout )
{
#ifdef ENABLE_SOUT
    if( !p_sout && !psz_sout )
    {
        if( p_resource->p_sout )
        {
            msg_Dbg( p_resource->p_sout, ""destroying useless sout"" );
            DestroySout( p_resource );
        }
        return NULL;
    }

    assert( !p_sout || ( !p_resource->p_sout && !psz_sout ) );

    /* Check the validity of the sout */
    if( p_resource->p_sout &&
        strcmp( p_resource->p_sout->psz_sout, psz_sout ) )
    {
        msg_Dbg( p_resource->p_parent, ""destroying unusable sout"" );
        DestroySout( p_resource );
    }

    if( psz_sout )
    {
        if( p_resource->p_sout )
        {
            /* Reuse it */
            msg_Dbg( p_resource->p_parent, ""reusing sout"" );
            msg_Dbg( p_resource->p_parent, ""you probably want to use gather stream_out"" );
        }
        else
        {
      ...",1,1,input\resource.c,RequestSout,,false,88,140,RequestSout,,,3,"sout_instance_t RequestSout (input_resource_t*,sout_instance_t*,char*)"
70034,METHOD,input\resource.c:<global>,TYPE_DECL,"static void DestroyVout( input_resource_t *p_resource )
{
    assert( p_resource->i_vout == 0 );

    if( p_resource->p_vout_free )
        vout_CloseAndRelease( p_resource->p_vout_free );

    p_resource->p_vout_free = NULL;
}",1,1,input\resource.c,DestroyVout,,false,143,151,DestroyVout,,,4,void DestroyVout (input_resource_t*)
70059,METHOD,input\resource.c:<global>,TYPE_DECL,"static void DisplayVoutTitle( input_resource_t *p_resource,
                              vout_thread_t *p_vout )
{
    if( p_resource->p_input == NULL )
        return;

    /* TODO display the title only one time for the same input ? */

    input_item_t *p_item = input_GetItem( p_resource->p_input );

    char *psz_nowplaying = input_item_GetNowPlayingFb( p_item );
    if( psz_nowplaying && *psz_nowplaying )
    {
        vout_DisplayTitle( p_vout, psz_nowplaying );
    }
    else
    {
        char *psz_artist = input_item_GetArtist( p_item );
        char *psz_name = input_item_GetTitle( p_item );

        if( !psz_name || *psz_name == '\0' )
        {
            free( psz_name );
            psz_name = input_item_GetName( p_item );
        }
        if( psz_artist && *psz_artist )
        {
            char *psz_string;
            if( asprintf( &psz_string, ""%s - %s"", psz_name, psz_artist ) != -1 )
            {
                vout_DisplayTitle( p_vout, psz_string );
      ...",1,1,input\resource.c,DisplayVoutTitle,,false,153,195,DisplayVoutTitle,,,5,"void DisplayVoutTitle (input_resource_t*,vout_thread_t*)"
70158,METHOD,input\resource.c:<global>,TYPE_DECL,"static vout_thread_t *RequestVout( input_resource_t *p_resource,
                                   vout_thread_t *p_vout,
                                   const video_format_t *p_fmt, unsigned dpb_size,
                                   bool b_recycle )
{
    vlc_assert_locked( &p_resource->lock );

    if( !p_vout && !p_fmt )
    {
        if( p_resource->p_vout_free )
        {
            msg_Dbg( p_resource->p_vout_free, ""destroying useless vout"" );
            vout_CloseAndRelease( p_resource->p_vout_free );
            p_resource->p_vout_free = NULL;
        }
        return NULL;
    }

    if( p_fmt )
    {
        /* */
        if( !p_vout && p_resource->p_vout_free )
        {
            msg_Dbg( p_resource->p_parent, ""trying to reuse free vout"" );
            p_vout = p_resource->p_vout_free;

            p_resource->p_vout_free = NULL;
        }
        else if( p_vout )
        {
            assert( p_vout != p_resource->p_vout_free );

            vlc_mutex_lock( ...",1,4,input\resource.c,RequestVout,,false,196,290,RequestVout,,,6,"vout_thread_t RequestVout (input_resource_t*,vout_thread_t*,video_format_t*,unsigned,bool)"
70442,METHOD,input\resource.c:<global>,TYPE_DECL,"static vout_thread_t *HoldVout( input_resource_t *p_resource )
{
    /* TODO FIXME: p_resource->pp_vout order is NOT stable */
    vlc_mutex_lock( &p_resource->lock_hold );

    vout_thread_t *p_vout = p_resource->i_vout > 0 ? p_resource->pp_vout[0] : NULL;
    if( p_vout )
        vlc_object_hold( p_vout );

    vlc_mutex_unlock( &p_resource->lock_hold );

    return p_vout;
}",1,1,input\resource.c,HoldVout,,false,291,303,HoldVout,,,7,vout_thread_t HoldVout (input_resource_t*)
70479,METHOD,input\resource.c:<global>,TYPE_DECL,"static void HoldVouts( input_resource_t *p_resource, vout_thread_t ***ppp_vout,
                       size_t *pi_vout )
{
    vout_thread_t **pp_vout;

    *pi_vout = 0;
    *ppp_vout = NULL;

    vlc_mutex_lock( &p_resource->lock_hold );

    if( p_resource->i_vout <= 0 )
        goto exit;

    pp_vout = vlc_alloc( p_resource->i_vout, sizeof(*pp_vout) );
    if( !pp_vout )
        goto exit;

    *ppp_vout = pp_vout;
    *pi_vout = p_resource->i_vout;

    for( int i = 0; i < p_resource->i_vout; i++ )
    {
        pp_vout[i] = p_resource->pp_vout[i];
        vlc_object_hold( pp_vout[i] );
    }

exit:
    vlc_mutex_unlock( &p_resource->lock_hold );
}",1,1,input\resource.c,HoldVouts,,false,305,333,HoldVouts,,,8,"void HoldVouts (input_resource_t*,vout_thread_t***,size_t*)"
70565,METHOD,input\resource.c:<global>,TYPE_DECL,"audio_output_t *input_resource_GetAout( input_resource_t *p_resource )
{
    audio_output_t *p_aout;

    vlc_mutex_lock( &p_resource->lock_hold );
    p_aout = p_resource->p_aout;

    if( p_aout == NULL || p_resource->b_aout_busy )
    {
        msg_Dbg( p_resource->p_parent, ""creating audio output"" );
        vlc_mutex_unlock( &p_resource->lock_hold );

        p_aout = aout_New( p_resource->p_parent );
        if( p_aout == NULL )
            return NULL; /* failed */

        vlc_mutex_lock( &p_resource->lock_hold );
        if( p_resource->p_aout == NULL )
            p_resource->p_aout = p_aout;
    }
    else
        msg_Dbg( p_resource->p_parent, ""reusing audio output"" );

    if( p_resource->p_aout == p_aout )
    {
        assert( !p_resource->b_aout_busy );
        p_resource->b_aout_busy = true;
    }
    vlc_mutex_unlock( &p_resource->lock_hold );
    return p_aout;
}",1,17,input\resource.c,input_resource_GetAout,,false,336,366,input_resource_GetAout,,,9,audio_output_t input_resource_GetAout (input_resource_t*)
70667,METHOD,input\resource.c:<global>,TYPE_DECL,"void input_resource_PutAout( input_resource_t *p_resource,
                             audio_output_t *p_aout )
{
    assert( p_aout != NULL );

    vlc_mutex_lock( &p_resource->lock_hold );
    if( p_aout == p_resource->p_aout )
    {
        assert( p_resource->b_aout_busy );
        p_resource->b_aout_busy = false;
        msg_Dbg( p_resource->p_parent, ""keeping audio output"" );
        p_aout = NULL;
    }
    else
        msg_Dbg( p_resource->p_parent, ""destroying extra audio output"" );
    vlc_mutex_unlock( &p_resource->lock_hold );

    if( p_aout != NULL )
        aout_Destroy( p_aout );
}",1,1,input\resource.c,input_resource_PutAout,,false,368,387,input_resource_PutAout,,,10,"void input_resource_PutAout (input_resource_t*,audio_output_t*)"
70725,METHOD,input\resource.c:<global>,TYPE_DECL,"audio_output_t *input_resource_HoldAout( input_resource_t *p_resource )
{
    audio_output_t *p_aout;

    vlc_mutex_lock( &p_resource->lock_hold );
    p_aout = p_resource->p_aout;
    if( p_aout != NULL )
        vlc_object_hold( p_aout );
    vlc_mutex_unlock( &p_resource->lock_hold );

    return p_aout;
}",1,1,input\resource.c,input_resource_HoldAout,,false,389,400,input_resource_HoldAout,,,11,audio_output_t input_resource_HoldAout (input_resource_t*)
70755,METHOD,input\resource.c:<global>,TYPE_DECL,"void input_resource_ResetAout( input_resource_t *p_resource )
{
    audio_output_t *p_aout = NULL;

    vlc_mutex_lock( &p_resource->lock_hold );
    if( !p_resource->b_aout_busy )
        p_aout = p_resource->p_aout;

    p_resource->p_aout = NULL;
    p_resource->b_aout_busy = false;
    vlc_mutex_unlock( &p_resource->lock_hold );

    if( p_aout != NULL )
        aout_Destroy( p_aout );
}",1,1,input\resource.c,input_resource_ResetAout,,false,402,416,input_resource_ResetAout,,,12,void input_resource_ResetAout (input_resource_t*)
70802,METHOD,input\resource.c:<global>,TYPE_DECL,"input_resource_t *input_resource_New( vlc_object_t *p_parent )
{
    input_resource_t *p_resource = calloc( 1, sizeof(*p_resource) );
    if( !p_resource )
        return NULL;

    atomic_init( &p_resource->refs, 1 );
    p_resource->p_parent = p_parent;
    vlc_mutex_init( &p_resource->lock );
    vlc_mutex_init( &p_resource->lock_hold );
    return p_resource;
}",1,1,input\resource.c,input_resource_New,,false,419,430,input_resource_New,,,13,input_resource_t input_resource_New (vlc_object_t*)
70844,METHOD,input\resource.c:<global>,TYPE_DECL,"void input_resource_Release( input_resource_t *p_resource )
{
    if( atomic_fetch_sub( &p_resource->refs, 1 ) != 1 )
        return;

    DestroySout( p_resource );
    DestroyVout( p_resource );
    if( p_resource->p_aout != NULL )
        aout_Destroy( p_resource->p_aout );

    vlc_mutex_destroy( &p_resource->lock_hold );
    vlc_mutex_destroy( &p_resource->lock );
    free( p_resource );
}",1,1,input\resource.c,input_resource_Release,,false,432,445,input_resource_Release,,,14,void input_resource_Release (input_resource_t*)
70887,METHOD,input\resource.c:<global>,TYPE_DECL,"input_resource_t *input_resource_Hold( input_resource_t *p_resource )
{
    atomic_fetch_add( &p_resource->refs, 1 );
    return p_resource;
}",1,1,input\resource.c,input_resource_Hold,,false,447,451,input_resource_Hold,,,15,input_resource_t input_resource_Hold (input_resource_t*)
70900,METHOD,input\resource.c:<global>,TYPE_DECL,"void input_resource_SetInput( input_resource_t *p_resource, input_thread_t *p_input )
{
    vlc_mutex_lock( &p_resource->lock );

    if( p_resource->p_input && !p_input )
        assert( p_resource->i_vout == 0 );

    /* */
    p_resource->p_input = p_input;

    vlc_mutex_unlock( &p_resource->lock );
}",1,1,input\resource.c,input_resource_SetInput,,false,453,464,input_resource_SetInput,,,16,"void input_resource_SetInput (input_resource_t*,input_thread_t*)"
70935,METHOD,input\resource.c:<global>,TYPE_DECL,"vout_thread_t *input_resource_RequestVout( input_resource_t *p_resource,
                                            vout_thread_t *p_vout,
                                            const video_format_t *p_fmt, unsigned dpb_size,
                                            bool b_recycle )
{
    vlc_mutex_lock( &p_resource->lock );
    vout_thread_t *p_ret = RequestVout( p_resource, p_vout, p_fmt, dpb_size, b_recycle );
    vlc_mutex_unlock( &p_resource->lock );

    return p_ret;
}",1,1,input\resource.c,input_resource_RequestVout,,false,466,476,input_resource_RequestVout,,,17,"vout_thread_t input_resource_RequestVout (input_resource_t*,vout_thread_t*,video_format_t*,unsigned,bool)"
70965,METHOD,input\resource.c:<global>,TYPE_DECL,"vout_thread_t *input_resource_HoldVout( input_resource_t *p_resource )
{
    return HoldVout( p_resource );
}",1,1,input\resource.c,input_resource_HoldVout,,false,477,480,input_resource_HoldVout,,,18,vout_thread_t input_resource_HoldVout (input_resource_t*)
70973,METHOD,input\resource.c:<global>,TYPE_DECL,"void input_resource_HoldVouts( input_resource_t *p_resource, vout_thread_t ***ppp_vout,
                               size_t *pi_vout )
{
    HoldVouts( p_resource, ppp_vout, pi_vout );
}",1,1,input\resource.c,input_resource_HoldVouts,,false,482,486,input_resource_HoldVouts,,,19,"void input_resource_HoldVouts (input_resource_t*,vout_thread_t***,size_t*)"
70984,METHOD,input\resource.c:<global>,TYPE_DECL,"void input_resource_TerminateVout( input_resource_t *p_resource )
{
    input_resource_RequestVout( p_resource, NULL, NULL, 0, false );
}",1,1,input\resource.c,input_resource_TerminateVout,,false,488,491,input_resource_TerminateVout,,,20,void input_resource_TerminateVout (input_resource_t*)
70995,METHOD,input\resource.c:<global>,TYPE_DECL,"bool input_resource_HasVout( input_resource_t *p_resource )
{
    vlc_mutex_lock( &p_resource->lock );
    assert( !p_resource->p_input );
    const bool b_vout = p_resource->p_vout_free != NULL;
    vlc_mutex_unlock( &p_resource->lock );

    return b_vout;
}",1,1,input\resource.c,input_resource_HasVout,,false,492,500,input_resource_HasVout,,,21,bool input_resource_HasVout (input_resource_t*)
71025,METHOD,input\resource.c:<global>,TYPE_DECL,"sout_instance_t *input_resource_RequestSout( input_resource_t *p_resource, sout_instance_t *p_sout, const char *psz_sout )
{
    vlc_mutex_lock( &p_resource->lock );
    sout_instance_t *p_ret = RequestSout( p_resource, p_sout, psz_sout );
    vlc_mutex_unlock( &p_resource->lock );

    return p_ret;
}",1,1,input\resource.c,input_resource_RequestSout,,false,503,510,input_resource_RequestSout,,,22,"sout_instance_t input_resource_RequestSout (input_resource_t*,sout_instance_t*,char*)"
71051,METHOD,input\resource.c:<global>,TYPE_DECL,"void input_resource_TerminateSout( input_resource_t *p_resource )
{
    input_resource_RequestSout( p_resource, NULL, NULL );
}",1,1,input\resource.c,input_resource_TerminateSout,,false,511,514,input_resource_TerminateSout,,,23,void input_resource_TerminateSout (input_resource_t*)
71060,METHOD,input\resource.c:<global>,TYPE_DECL,"void input_resource_Terminate( input_resource_t *p_resource )
{
    input_resource_TerminateSout( p_resource );
    input_resource_ResetAout( p_resource );
    input_resource_TerminateVout( p_resource );
}",1,1,input\resource.c,input_resource_Terminate,,false,516,521,input_resource_Terminate,,,24,void input_resource_Terminate (input_resource_t*)
71076,METHOD,input\resource.h:<global>,TYPE_DECL,<global>,1,6,input\resource.h,input\resource.h:<global>,,false,1,69,<global>,,,1,
71078,METHOD,input\resource.h:<global>,TYPE_DECL,"void input_resource_SetInput( input_resource_t *, input_thread_t * );",6,68,input\resource.h,input_resource_SetInput,,false,32,32,input_resource_SetInput,,,1,"void input_resource_SetInput (input_resource_t*,input_thread_t*)"
71084,METHOD,input\resource.h:<global>,TYPE_DECL,"sout_instance_t *input_resource_RequestSout( input_resource_t *, sout_instance_t *, const char *psz_sout );",17,106,input\resource.h,input_resource_RequestSout,,false,37,37,input_resource_RequestSout,,,2,"sout_instance_t* input_resource_RequestSout (input_resource_t*,sout_instance_t*,char*)"
71091,METHOD,input\resource.h:<global>,TYPE_DECL,"vout_thread_t *input_resource_RequestVout( input_resource_t *, vout_thread_t *,
                                           const video_format_t *, unsigned dpb_size, bool b_recycle );",15,102,input\resource.h,input_resource_RequestVout,,false,42,43,input_resource_RequestVout,,,3,"vout_thread_t* input_resource_RequestVout (input_resource_t*,vout_thread_t*,video_format_t*,unsigned,bool)"
71100,METHOD,input\resource.h:<global>,TYPE_DECL,vout_thread_t *input_resource_HoldVout( input_resource_t * );,15,60,input\resource.h,input_resource_HoldVout,,false,50,50,input_resource_HoldVout,,,4,vout_thread_t* input_resource_HoldVout (input_resource_t*)
71105,METHOD,input\resource.h:<global>,TYPE_DECL,"void input_resource_HoldVouts( input_resource_t *, vout_thread_t ***, size_t * );",6,80,input\resource.h,input_resource_HoldVouts,,false,57,57,input_resource_HoldVouts,,,5,"void input_resource_HoldVouts (input_resource_t*,vout_thread_t***,size_t*)"
71112,METHOD,input\resource.h:<global>,TYPE_DECL,void input_resource_Terminate( input_resource_t * );,6,51,input\resource.h,input_resource_Terminate,,false,62,62,input_resource_Terminate,,,6,void input_resource_Terminate (input_resource_t*)
71117,METHOD,input\resource.h:<global>,TYPE_DECL,input_resource_t *input_resource_Hold( input_resource_t * );,18,59,input\resource.h,input_resource_Hold,,false,67,67,input_resource_Hold,,,7,input_resource_t* input_resource_Hold (input_resource_t*)
71139,METHOD,input\services_discovery.c:<global>,TYPE_DECL,<global>,1,25,input\services_discovery.c,input\services_discovery.c:<global>,,false,1,137,<global>,,,1,
71146,METHOD,input\services_discovery.c:<global>,TYPE_DECL,"int vlc_sd_probe_Add (vlc_probe_t *probe, const char *name,
                      const char *longname, int category)
{
    vlc_sd_probe_t names = { strdup(name), strdup(longname), category };

    if (unlikely (names.name == NULL || names.longname == NULL
               || vlc_probe_add (probe, &names, sizeof (names))))
    {
        free (names.name);
        free (names.longname);
        return VLC_ENOMEM;
    }
    return VLC_PROBE_CONTINUE;
}",1,1,input\services_discovery.c,vlc_sd_probe_Add,,false,41,54,vlc_sd_probe_Add,,,3,"int vlc_sd_probe_Add (vlc_probe_t*,char*,char*,int)"
71196,METHOD,input\services_discovery.c:<global>,TYPE_DECL,"char **vlc_sd_GetNames (vlc_object_t *obj, char ***pppsz_longnames, int **pp_categories)
{
    size_t count;
    vlc_sd_probe_t *tab = vlc_probe (obj, ""services probe"", &count);

    if (count == 0)
    {
        free (tab);
        return NULL;
    }

    char **names = vlc_alloc (count + 1, sizeof(char *));
    char **longnames = vlc_alloc (count + 1, sizeof(char *));
    int *categories = vlc_alloc (count + 1, sizeof(int));

    if (unlikely (names == NULL || longnames == NULL || categories == NULL))
    {
        free(names);
        free(longnames);
        free(categories);
        free(tab);
        return NULL;
    }
    for( size_t i = 0; i < count; i++ )
    {
        names[i] = tab[i].name;
        longnames[i] = tab[i].longname;
        categories[i] = tab[i].category;
    }
    free (tab);
    names[count] = longnames[count] = NULL;
    categories[count] = 0;
    *pppsz_longnames = longnames;
    if( pp_categories ) *pp_categories = categories;
    else free( categories...",1,1,input\services_discovery.c,vlc_sd_GetNames,,false,61,97,vlc_sd_GetNames,,,4,"char** vlc_sd_GetNames (vlc_object_t*,char***,int**)"
71344,METHOD,input\services_discovery.c:<global>,TYPE_DECL,"services_discovery_t *vlc_sd_Create(vlc_object_t *parent, const char *cfg,
    const struct services_discovery_owner_t *restrict owner)
{
    services_discovery_t *sd = vlc_custom_create(parent, sizeof (*sd),
                                                 ""services discovery"");
    if (unlikely(sd == NULL))
        return NULL;

    free(config_ChainCreate(&sd->psz_name, &sd->p_cfg, cfg));
    sd->description = NULL;
    sd->owner = *owner;

    sd->p_module = module_need(sd, ""services_discovery"",
                               sd->psz_name, true);
    if (sd->p_module == NULL)
    {
        msg_Err(sd, ""no suitable services discovery module"");
        vlc_sd_Destroy(sd);
        sd = NULL;
    }

    return sd;
}",1,31,input\services_discovery.c,vlc_sd_Create,,false,106,128,vlc_sd_Create,,,5,"services_discovery_t vlc_sd_Create (vlc_object_t*,char*,services_discovery_owner_t*)"
71422,METHOD,input\services_discovery.c:<global>,TYPE_DECL,"void vlc_sd_Destroy(services_discovery_t *sd)
{
    if (sd->p_module != NULL)
        module_unneed(sd, sd->p_module);
    config_ChainDestroy(sd->p_cfg);
    free(sd->psz_name);
    vlc_object_release(sd);
}",1,1,input\services_discovery.c,vlc_sd_Destroy,,false,130,137,vlc_sd_Destroy,,,6,void vlc_sd_Destroy (services_discovery_t*)
71458,METHOD,input\stats.c:<global>,TYPE_DECL,<global>,1,24,input\stats.c,input\stats.c:<global>,,false,1,209,<global>,,,1,
71460,METHOD,input\stats.c:<global>,TYPE_DECL,"counter_t * stats_CounterCreate( int i_compute_type )
{
    counter_t *p_counter = (counter_t*) malloc( sizeof( counter_t ) ) ;

    if( !p_counter ) return NULL;
    p_counter->i_compute_type = i_compute_type;
    p_counter->i_samples = 0;
    p_counter->pp_samples = NULL;

    p_counter->last_update = 0;

    return p_counter;
}",1,1,input\stats.c,stats_CounterCreate,,false,38,50,stats_CounterCreate,,,1,counter_t stats_CounterCreate (int)
71501,METHOD,input\stats.c:<global>,TYPE_DECL,"static inline int64_t stats_GetTotal(const counter_t *counter)
{
    if (counter == NULL || counter->i_samples == 0)
        return 0;
    return counter->pp_samples[0]->value;
}",1,1,input\stats.c,stats_GetTotal,,false,52,57,stats_GetTotal,,,2,int64_t stats_GetTotal (counter_t*)
71527,METHOD,input\stats.c:<global>,TYPE_DECL,"static inline float stats_GetRate(const counter_t *counter)
{
    if (counter == NULL || counter->i_samples < 2)
        return 0.;

    return (counter->pp_samples[0]->value - counter->pp_samples[1]->value)
        / (float)(counter->pp_samples[0]->date - counter->pp_samples[1]->date);
}",1,1,input\stats.c,stats_GetRate,,false,59,66,stats_GetRate,,,3,float stats_GetRate (counter_t*)
71579,METHOD,input\stats.c:<global>,TYPE_DECL,"input_stats_t *stats_NewInputStats( input_thread_t *p_input )
{
    (void)p_input;
    input_stats_t *p_stats = calloc( 1, sizeof(input_stats_t) );
    if( !p_stats )
        return NULL;

    vlc_mutex_init( &p_stats->lock );
    stats_ReinitInputStats( p_stats );

    return p_stats;
}",1,1,input\stats.c,stats_NewInputStats,,false,68,79,stats_NewInputStats,,,4,input_stats_t stats_NewInputStats (input_thread_t*)
71609,METHOD,input\stats.c:<global>,TYPE_DECL,"void stats_ComputeInputStats(input_thread_t *input, input_stats_t *st)
{
    input_thread_private_t *priv = input_priv(input);

    if (!libvlc_stats(input))
        return;

    vlc_mutex_lock(&priv->counters.counters_lock);
    vlc_mutex_lock(&st->lock);

    /* Input */
    st->i_read_packets = stats_GetTotal(priv->counters.p_read_packets);
    st->i_read_bytes = stats_GetTotal(priv->counters.p_read_bytes);
    st->f_input_bitrate = stats_GetRate(priv->counters.p_input_bitrate);
    st->i_demux_read_bytes = stats_GetTotal(priv->counters.p_demux_read);
    st->f_demux_bitrate = stats_GetRate(priv->counters.p_demux_bitrate);
    st->i_demux_corrupted = stats_GetTotal(priv->counters.p_demux_corrupted);
    st->i_demux_discontinuity = stats_GetTotal(priv->counters.p_demux_discontinuity);

    /* Decoders */
    st->i_decoded_video = stats_GetTotal(priv->counters.p_decoded_video);
    st->i_decoded_audio = stats_GetTotal(priv->counters.p_decoded_audio);

    /* Sout */
    if (priv->c...",1,1,input\stats.c,stats_ComputeInputStats,,false,81,122,stats_ComputeInputStats,,,5,"void stats_ComputeInputStats (input_thread_t*,input_stats_t*)"
71817,METHOD,input\stats.c:<global>,TYPE_DECL,"void stats_ReinitInputStats( input_stats_t *p_stats )
{
    vlc_mutex_lock( &p_stats->lock );
    p_stats->i_read_packets = p_stats->i_read_bytes =
    p_stats->f_input_bitrate = p_stats->f_average_input_bitrate =
    p_stats->i_demux_read_packets = p_stats->i_demux_read_bytes =
    p_stats->f_demux_bitrate = p_stats->f_average_demux_bitrate =
    p_stats->i_demux_corrupted = p_stats->i_demux_discontinuity =
    p_stats->i_displayed_pictures = p_stats->i_lost_pictures =
    p_stats->i_played_abuffers = p_stats->i_lost_abuffers =
    p_stats->i_decoded_video = p_stats->i_decoded_audio =
    p_stats->i_sent_bytes = p_stats->i_sent_packets = p_stats->f_send_bitrate
     = 0;
    vlc_mutex_unlock( &p_stats->lock );
}",1,1,input\stats.c,stats_ReinitInputStats,,false,124,138,stats_ReinitInputStats,,,6,void stats_ReinitInputStats (input_stats_t*)
71909,METHOD,input\stats.c:<global>,TYPE_DECL,"void stats_CounterClean( counter_t *p_c )
{
    if( p_c )
    {
        for( int i = 0; i < p_c->i_samples; i++ )
            free( p_c->pp_samples[i] );
        TAB_CLEAN(p_c->i_samples, p_c->pp_samples);
        free( p_c );
    }
}",1,1,input\stats.c,stats_CounterClean,,false,140,149,stats_CounterClean,,,7,void stats_CounterClean (counter_t*)
71945,METHOD,input\stats.c:<global>,TYPE_DECL,"void stats_Update( counter_t *p_counter, uint64_t val, uint64_t *new_val )
{
    if( !p_counter )
        return;

    switch( p_counter->i_compute_type )
    {
    case STATS_DERIVATIVE:
    {
        counter_sample_t *p_new, *p_old;
        mtime_t now = mdate();
        if( now - p_counter->last_update < CLOCK_FREQ )
            return;
        p_counter->last_update = now;
        /* Insert the new one at the beginning */
        p_new = (counter_sample_t*)malloc( sizeof( counter_sample_t ) );
        if (unlikely(p_new == NULL))
            return; /* NOTE: Losing sample here */

        p_new->value = val;
        p_new->date = p_counter->last_update;
        TAB_INSERT(p_counter->i_samples, p_counter->pp_samples, p_new, 0);

        if( p_counter->i_samples == 3 )
        {
            p_old = p_counter->pp_samples[2];
            TAB_ERASE(p_counter->i_samples, p_counter->pp_samples, 2);
            free( p_old );
        }
        break;
    }
    case STATS_COUNTER:
      ...",1,1,input\stats.c,stats_Update,,false,158,209,stats_Update,,,8,"void stats_Update (counter_t*,uint64_t,uint64_t*)"
72148,METHOD,input\stream.c:<global>,TYPE_DECL,<global>,1,20,input\stream.c,input\stream.c:<global>,,false,1,724,<global>,,,1,
72152,METHOD,stream_priv_t,TYPE_DECL,void (*destroy)(stream_t *);,10,31,input\stream.c,stream_priv_t.destroy,,false,50,50,destroy,,,2,void stream_priv_t.destroy (stream_t*)
72167,METHOD,input\stream.c:<global>,TYPE_DECL,"stream_t *vlc_stream_CommonNew(vlc_object_t *parent,
                               void (*destroy)(stream_t *))
{
    stream_priv_t *priv = vlc_custom_create(parent, sizeof (*priv), ""stream"");
    if (unlikely(priv == NULL))
        return NULL;

    stream_t *s = &priv->stream;

    s->p_module = NULL;
    s->psz_url = NULL;
    s->p_source = NULL;
    s->pf_read = NULL;
    s->pf_block = NULL;
    s->pf_readdir = NULL;
    s->pf_seek = NULL;
    s->pf_control = NULL;
    s->p_sys = NULL;
    s->p_input = NULL;
    assert(destroy != NULL);
    priv->destroy = destroy;
    priv->block = NULL;
    priv->peek = NULL;
    priv->offset = 0;
    priv->eof = false;

    /* UTF16 and UTF32 text file conversion */
    priv->text.conv = (vlc_iconv_t)(-1);
    priv->text.char_width = 1;
    priv->text.little_endian = false;

    return s;
}",1,1,input\stream.c,vlc_stream_CommonNew,,false,67,99,vlc_stream_CommonNew,,,3,"stream_t vlc_stream_CommonNew (vlc_object_t*,void)"
72301,METHOD,input\stream.c:<global>,TYPE_DECL,"void stream_CommonDelete(stream_t *s)
{
    stream_priv_t *priv = (stream_priv_t *)s;

    if (priv->text.conv != (vlc_iconv_t)(-1))
        vlc_iconv_close(priv->text.conv);

    if (priv->peek != NULL)
        block_Release(priv->peek);
    if (priv->block != NULL)
        block_Release(priv->block);

    free(s->psz_url);
    vlc_object_release(s);
}",1,1,input\stream.c,stream_CommonDelete,,false,101,115,stream_CommonDelete,,,4,void stream_CommonDelete (stream_t*)
72357,METHOD,input\stream.c:<global>,TYPE_DECL,"void vlc_stream_Delete(stream_t *s)
{
    stream_priv_t *priv = (stream_priv_t *)s;

    priv->destroy(s);
    stream_CommonDelete(s);
}",1,1,input\stream.c,vlc_stream_Delete,,false,120,126,vlc_stream_Delete,,,5,void vlc_stream_Delete (stream_t*)
72375,METHOD,input\stream.c:<global>,TYPE_DECL,"stream_t *(vlc_stream_NewURL)(vlc_object_t *p_parent, const char *psz_url)
{
    if( !psz_url )
        return NULL;

    stream_t *s = stream_AccessNew( p_parent, NULL, false, psz_url );
    if( s == NULL )
        msg_Err( p_parent, ""no suitable access module for `%s'"", psz_url );
    return s;
}",1,1,input\stream.c,,,false,128,137,vlc_stream_NewURL,,,6,"stream_t (vlc_object_t*,char*)"
72406,METHOD,input\stream.c:<global>,TYPE_DECL,"stream_t *(vlc_stream_NewMRL)(vlc_object_t* parent, const char* mrl )
{
    stream_t* stream = vlc_stream_NewURL( parent, mrl );

    if( stream == NULL )
        return NULL;

    char const* anchor = strchr( mrl, '#' );

    if( anchor == NULL )
        return stream;

    char const* extra;
    if( stream_extractor_AttachParsed( &stream, anchor + 1, &extra ) )
    {
        msg_Err( parent, ""unable to open %s"", mrl );
        vlc_stream_Delete( stream );
        return NULL;
    }

    if( extra && *extra )
        msg_Warn( parent, ""ignoring extra fragment data: %s"", extra );

    return stream;
}",1,1,input\stream.c,,,false,139,163,vlc_stream_NewMRL,,,7,"stream_t (vlc_object_t*,char*)"
72469,METHOD,input\stream.c:<global>,TYPE_DECL,"char *vlc_stream_ReadLine( stream_t *s )
{
    stream_priv_t *priv = (stream_priv_t *)s;
    char *p_line = NULL;
    int i_line = 0, i_read = 0;

    /* Let's fail quickly if this is a readdir access */
    if( s->pf_read == NULL && s->pf_block == NULL )
        return NULL;

    for( ;; )
    {
        char *psz_eol;
        const uint8_t *p_data;
        int i_data;
        int64_t i_pos;

        /* Probe new data */
        i_data = vlc_stream_Peek( s, &p_data, STREAM_PROBE_LINE );
        if( i_data <= 0 ) break; /* No more data */

        /* BOM detection */
        i_pos = vlc_stream_Tell( s );
        if( i_pos == 0 && i_data >= 2 )
        {
            const char *psz_encoding = NULL;
            bool little_endian = false;

            if( unlikely(priv->text.conv != (vlc_iconv_t)-1) )
            {   /* seek back to beginning? reset */
                vlc_iconv_close( priv->text.conv );
                priv->text.conv = (vlc_iconv_t)-1;
            }
            priv->...",1,46,input\stream.c,vlc_stream_ReadLine,,false,172,359,vlc_stream_ReadLine,,,8,char* vlc_stream_ReadLine (stream_t*)
73084,METHOD,input\stream.c:<global>,TYPE_DECL,"static ssize_t vlc_stream_CopyBlock(block_t **restrict pp,
                                    void *buf, size_t len)
{
    block_t *block = *pp;

    if (block == NULL)
        return -1;

    if (len > block->i_buffer)
        len = block->i_buffer;

    if (buf != NULL)
        memcpy(buf, block->p_buffer, len);

    block->p_buffer += len;
    block->i_buffer -= len;

    if (block->i_buffer == 0)
    {
        block_Release(block);
        *pp = NULL;
    }

    return likely(len > 0) ? (ssize_t)len : -1;
}",1,1,input\stream.c,vlc_stream_CopyBlock,,false,361,385,vlc_stream_CopyBlock,,,9,"ssize_t vlc_stream_CopyBlock (block_t**,void*,size_t)"
73161,METHOD,input\stream.c:<global>,TYPE_DECL,"static ssize_t vlc_stream_ReadRaw(stream_t *s, void *buf, size_t len)
{
    stream_priv_t *priv = (stream_priv_t *)s;
    ssize_t ret;

    assert(len <= SSIZE_MAX);

    if (vlc_killed())
        return 0;

    if (s->pf_read != NULL)
    {
        assert(priv->block == NULL);
        if (buf == NULL)
        {
            if (unlikely(len == 0))
                return 0;

            char dummy[(len <= 256 ? len : 256)];
            ret = s->pf_read(s, dummy, sizeof (dummy));
        }
        else
            ret = s->pf_read(s, buf, len);
        return ret;
    }

    ret = vlc_stream_CopyBlock(&priv->block, buf, len);
    if (ret >= 0)
        return ret;

    if (s->pf_block != NULL)
    {
        bool eof = false;

        priv->block = s->pf_block(s, &eof);
        ret = vlc_stream_CopyBlock(&priv->block, buf, len);
        if (ret >= 0)
            return ret;
        return eof ? 0 : -1;
    }

    return 0;
}",1,1,input\stream.c,vlc_stream_ReadRaw,,false,387,429,vlc_stream_ReadRaw,,,10,"ssize_t vlc_stream_ReadRaw (stream_t*,void*,size_t)"
73296,METHOD,input\stream.c:<global>,TYPE_DECL,"ssize_t vlc_stream_ReadPartial(stream_t *s, void *buf, size_t len)
{
    stream_priv_t *priv = (stream_priv_t *)s;
    ssize_t ret;

    ret = vlc_stream_CopyBlock(&priv->peek, buf, len);
    if (ret >= 0)
    {
        priv->offset += ret;
        assert(ret <= (ssize_t)len);
        return ret;
    }

    ret = vlc_stream_ReadRaw(s, buf, len);
    if (ret > 0)
        priv->offset += ret;
    if (ret == 0)
        priv->eof = len != 0;
    assert(ret <= (ssize_t)len);
    return ret;
}",1,1,input\stream.c,vlc_stream_ReadPartial,,false,431,451,vlc_stream_ReadPartial,,,11,"ssize_t vlc_stream_ReadPartial (stream_t*,void*,size_t)"
73373,METHOD,input\stream.c:<global>,TYPE_DECL,"ssize_t vlc_stream_Read(stream_t *s, void *buf, size_t len)
{
    size_t copied = 0;

    while (len > 0)
    {
        ssize_t ret = vlc_stream_ReadPartial(s, buf, len);
        if (ret < 0)
            continue;
        if (ret == 0)
            break;

        if (buf != NULL)
            buf = (char *)buf + ret;
        assert(len >= (size_t)ret);
        len -= ret;
        copied += ret;
    }

    return copied;
}",1,1,input\stream.c,vlc_stream_Read,,false,453,473,vlc_stream_Read,,,12,"ssize_t vlc_stream_Read (stream_t*,void*,size_t)"
73434,METHOD,input\stream.c:<global>,TYPE_DECL,"ssize_t vlc_stream_Peek(stream_t *s, const uint8_t **restrict bufp, size_t len)
{
    stream_priv_t *priv = (stream_priv_t *)s;
    block_t *peek;

    peek = priv->peek;
    if (peek == NULL)
    {
        peek = priv->block;
        priv->peek = peek;
        priv->block = NULL;
    }

    if (peek == NULL)
    {
        peek = block_Alloc(len);
        if (unlikely(peek == NULL))
            return VLC_ENOMEM;

        peek->i_buffer = 0;
    }
    else
    if (peek->i_buffer < len)
    {
        size_t avail = peek->i_buffer;

        peek = block_TryRealloc(peek, 0, len);
        if (unlikely(peek == NULL))
            return VLC_ENOMEM;

        peek->i_buffer = avail;
    }

    priv->peek = peek;
    *bufp = peek->p_buffer;

    while (peek->i_buffer < len)
    {
        size_t avail = peek->i_buffer;
        ssize_t ret;

        ret = vlc_stream_ReadRaw(s, peek->p_buffer + avail, len - avail);
        if (ret < 0)
            continue;

        peek->i_buffer += ret;

    ...",1,1,input\stream.c,vlc_stream_Peek,,false,475,527,vlc_stream_Peek,,,13,"ssize_t vlc_stream_Peek (stream_t*,uint8_t**,size_t)"
73588,METHOD,input\stream.c:<global>,TYPE_DECL,"block_t *vlc_stream_ReadBlock(stream_t *s)
{
    stream_priv_t *priv = (stream_priv_t *)s;
    block_t *block;

    if (vlc_killed())
    {
        priv->eof = true;
        return NULL;
    }

    if (priv->peek != NULL)
    {
        block = priv->peek;
        priv->peek = NULL;
    }
    else if (priv->block != NULL)
    {
        block = priv->block;
        priv->block = NULL;
    }
    else if (s->pf_block != NULL)
    {
        priv->eof = false;
        block = s->pf_block(s, &priv->eof);
    }
    else
    {
        block = block_Alloc(4096);
        if (unlikely(block == NULL))
            return NULL;

        ssize_t ret = s->pf_read(s, block->p_buffer, block->i_buffer);
        if (ret > 0)
            block->i_buffer = ret;
        else
        {
            block_Release(block);
            block = NULL;
        }

        priv->eof = !ret;
    }

    if (block != NULL)
        priv->offset += block->i_buffer;

    return block;
}",1,1,input\stream.c,vlc_stream_ReadBlock,,false,529,577,vlc_stream_ReadBlock,,,14,block_t vlc_stream_ReadBlock (stream_t*)
73736,METHOD,input\stream.c:<global>,TYPE_DECL,"uint64_t vlc_stream_Tell(const stream_t *s)
{
    const stream_priv_t *priv = (const stream_priv_t *)s;

    return priv->offset;
}",1,1,input\stream.c,vlc_stream_Tell,,false,579,584,vlc_stream_Tell,,,15,uint64_t vlc_stream_Tell (stream_t*)
73751,METHOD,input\stream.c:<global>,TYPE_DECL,"bool vlc_stream_Eof(const stream_t *s)
{
    const stream_priv_t *priv = (const stream_priv_t *)s;

    return priv->eof;
}",1,1,input\stream.c,vlc_stream_Eof,,false,586,591,vlc_stream_Eof,,,16,bool vlc_stream_Eof (stream_t*)
73766,METHOD,input\stream.c:<global>,TYPE_DECL,"int vlc_stream_Seek(stream_t *s, uint64_t offset)
{
    stream_priv_t *priv = (stream_priv_t *)s;

    priv->eof = false;

    block_t *peek = priv->peek;
    if (peek != NULL)
    {
        if (offset >= priv->offset
         && offset <= (priv->offset + peek->i_buffer))
        {   /* Seeking within the peek buffer */
            size_t fwd = offset - priv->offset;

            peek->p_buffer += fwd;
            peek->i_buffer -= fwd;
            priv->offset = offset;

            if (peek->i_buffer == 0)
            {
                priv->peek = NULL;
                block_Release(peek);
            }

            return VLC_SUCCESS;
        }
    }
    else
    {
        if (priv->offset == offset)
            return VLC_SUCCESS; /* Nothing to do! */
    }

    if (s->pf_seek == NULL)
        return VLC_EGENERIC;

    int ret = s->pf_seek(s, offset);
    if (ret != VLC_SUCCESS)
        return ret;

    priv->offset = offset;

    if (peek != NULL)
    {
        priv->peek = NU...",1,1,input\stream.c,vlc_stream_Seek,,false,593,648,vlc_stream_Seek,,,17,"int vlc_stream_Seek (stream_t*,uint64_t)"
73921,METHOD,input\stream.c:<global>,TYPE_DECL,"int vlc_stream_vaControl(stream_t *s, int cmd, va_list args)
{
    stream_priv_t *priv = (stream_priv_t *)s;

    switch (cmd)
    {
        case STREAM_SET_TITLE:
        case STREAM_SET_SEEKPOINT:
        {
            int ret = s->pf_control(s, cmd, args);
            if (ret != VLC_SUCCESS)
                return ret;

            priv->offset = 0;

            if (priv->peek != NULL)
            {
                block_Release(priv->peek);
                priv->peek = NULL;
            }

            if (priv->block != NULL)
            {
                block_Release(priv->block);
                priv->block = NULL;
            }

            return VLC_SUCCESS;
        }
    }
    return s->pf_control(s, cmd, args);
}",1,1,input\stream.c,vlc_stream_vaControl,,false,655,686,vlc_stream_vaControl,,,18,"int vlc_stream_vaControl (stream_t*,int,va_list)"
74006,METHOD,input\stream.c:<global>,TYPE_DECL,"block_t *vlc_stream_Block( stream_t *s, size_t size )
{
    if( unlikely(size > SSIZE_MAX) )
        return NULL;

    block_t *block = block_Alloc( size );
    if( unlikely(block == NULL) )
        return NULL;

    ssize_t val = vlc_stream_Read( s, block->p_buffer, size );
    if( val <= 0 )
    {
        block_Release( block );
        return NULL;
    }

    block->i_buffer = val;
    return block;
}",1,1,input\stream.c,vlc_stream_Block,,false,697,715,vlc_stream_Block,,,19,"block_t vlc_stream_Block (stream_t*,size_t)"
74058,METHOD,input\stream.c:<global>,TYPE_DECL,"int vlc_stream_ReadDir( stream_t *s, input_item_node_t *p_node )
{
    return s->pf_readdir( s, p_node );
}",1,1,input\stream.c,vlc_stream_ReadDir,,false,721,724,vlc_stream_ReadDir,,,20,"int vlc_stream_ReadDir (stream_t*,input_item_node_t*)"
74078,METHOD,input\stream.h:<global>,TYPE_DECL,<global>,1,6,input\stream.h,input\stream.h:<global>,,false,1,116,<global>,,,1,
74080,METHOD,input\stream.h:<global>,TYPE_DECL,void stream_CommonDelete( stream_t *s );,6,39,input\stream.h,stream_CommonDelete,,false,32,32,stream_CommonDelete,,,1,void stream_CommonDelete (stream_t*)
74085,METHOD,input\stream.h:<global>,TYPE_DECL,"stream_t *stream_AccessNew(vlc_object_t *, input_thread_t *, bool, const char *);",10,80,input\stream.h,stream_AccessNew,,false,37,37,stream_AccessNew,,,2,"stream_t* stream_AccessNew (vlc_object_t*,input_thread_t*,ANY,char*)"
74093,METHOD,input\stream.h:<global>,TYPE_DECL,stream_t *stream_FilterAutoNew( stream_t *source ),10,50,input\stream.h,stream_FilterAutoNew,,false,63,63,stream_FilterAutoNew,,,3,stream_t* stream_FilterAutoNew (stream_t*)
74100,METHOD,input\stream.h:<global>,TYPE_DECL,"stream_t *stream_FilterChainNew( stream_t *source, const char *list )",10,69,input\stream.h,stream_FilterChainNew,,false,83,83,stream_FilterChainNew,,,6,"stream_t* stream_FilterChainNew (stream_t*,char*)"
74108,METHOD,input\stream.h:<global>,TYPE_DECL,"int stream_extractor_AttachParsed( stream_t** stream, const char* psz_data,
                                   char const** out_extra );",5,59,input\stream.h,stream_extractor_AttachParsed,,false,111,112,stream_extractor_AttachParsed,,,9,"int stream_extractor_AttachParsed (stream_t**,char*,char**)"
74115,METHOD,input\stream.h:<global>,TYPE_DECL,char *get_path(const char *location);,6,36,input\stream.h,get_path,,false,114,114,get_path,,,10,char* get_path (char*)
74145,METHOD,input\stream_extractor.c:<global>,TYPE_DECL,<global>,1,1,input\stream_extractor.c,input\stream_extractor.c:<global>,,false,1,386,<global>,,,1,
74151,METHOD,stream_extractor_private,TYPE_DECL,"int (*pf_init)( struct stream_extractor_private*, stream_t* );",9,65,input\stream_extractor.c,stream_extractor_private.pf_init,,false,61,61,pf_init,,,2,"int stream_extractor_private.pf_init (stream_extractor_private*,stream_t*)"
74157,METHOD,stream_extractor_private,TYPE_DECL,void (*pf_clean)( struct stream_extractor_private* );,10,56,input\stream_extractor.c,stream_extractor_private.pf_clean,,false,70,70,pf_clean,,,3,void stream_extractor_private.pf_clean (stream_extractor_private*)
74166,METHOD,input\stream_extractor.c:<global>,TYPE_DECL,"static char*
StreamExtractorCreateMRL( char const* base, char const* subentry )
{
    struct vlc_memstream buffer;
    char* escaped;

    if( mrl_EscapeFragmentIdentifier( &escaped, subentry ) )
        return NULL;

    if( vlc_memstream_open( &buffer ) )
    {
        free( escaped );
        return NULL;
    }

    vlc_memstream_puts( &buffer, base );

    if( !strstr( base, ""#"" ) )
        vlc_memstream_putc( &buffer, '#' );

    vlc_memstream_printf( &buffer, ""!/%s"", escaped );

    free( escaped );
    return vlc_memstream_close( &buffer ) ? NULL : buffer.ptr;
}",1,1,input\stream_extractor.c,StreamExtractorCreateMRL,,false,88,112,StreamExtractorCreateMRL,,,2,"char* StreamExtractorCreateMRL (char*,char*)"
74221,METHOD,input\stream_extractor.c:<global>,TYPE_DECL,"static void se_Release( struct stream_extractor_private* priv )
{
    if( priv->pf_clean )
        priv->pf_clean( priv );

    if( priv->module )
    {
        module_unneed( priv->object, priv->module );

        if( priv->source )
            vlc_stream_Delete( priv->source );
    }

    vlc_object_release( priv->object );
}",1,1,input\stream_extractor.c,se_Release,,false,118,132,se_Release,,,3,void se_Release (stream_extractor_private*)
74261,METHOD,input\stream_extractor.c:<global>,TYPE_DECL,"static void
se_StreamDelete( stream_t* stream )
{
    se_Release( stream->p_sys );
}",1,1,input\stream_extractor.c,se_StreamDelete,,false,140,144,se_StreamDelete,,,4,void se_StreamDelete (stream_t*)
74270,METHOD,input\stream_extractor.c:<global>,TYPE_DECL,"static ssize_t
se_StreamRead( stream_t* stream, void* buf, size_t len )
{
    struct stream_extractor_private* priv = stream->p_sys;
    return priv->extractor.pf_read( &priv->extractor, buf, len );
}",1,1,input\stream_extractor.c,se_StreamRead,,false,146,151,se_StreamRead,,,5,"ssize_t se_StreamRead (stream_t*,void*,size_t)"
74296,METHOD,input\stream_extractor.c:<global>,TYPE_DECL,"static block_t*
se_StreamBlock( stream_t* stream, bool* eof )
{
    struct stream_extractor_private* priv = stream->p_sys;
    return priv->extractor.pf_block( &priv->extractor, eof );
}",1,1,input\stream_extractor.c,se_StreamBlock,,false,153,158,se_StreamBlock,,,6,"block_t se_StreamBlock (stream_t*,bool*)"
74320,METHOD,input\stream_extractor.c:<global>,TYPE_DECL,"static int
se_StreamSeek( stream_t* stream, uint64_t offset )
{
    struct stream_extractor_private* priv = stream->p_sys;
    return priv->extractor.pf_seek( &priv->extractor, offset );
}",1,1,input\stream_extractor.c,se_StreamSeek,,false,160,165,se_StreamSeek,,,7,"int se_StreamSeek (stream_t*,uint64_t)"
74344,METHOD,input\stream_extractor.c:<global>,TYPE_DECL,"static int
se_ReadDir( stream_t* stream, input_item_node_t* node )
{
    struct stream_extractor_private* priv = stream->p_sys;
    return priv->directory.pf_readdir( &priv->directory, node );
}",1,1,input\stream_extractor.c,se_ReadDir,,false,167,172,se_ReadDir,,,8,"int se_ReadDir (stream_t*,input_item_node_t*)"
74368,METHOD,input\stream_extractor.c:<global>,TYPE_DECL,"static int
se_StreamControl( stream_t* stream, int req, va_list args )
{
    struct stream_extractor_private* priv = stream->p_sys;
    return priv->extractor.pf_control( &priv->extractor, req, args );
}",1,1,input\stream_extractor.c,se_StreamControl,,false,174,179,se_StreamControl,,,9,"int se_StreamControl (stream_t*,int,va_list)"
74394,METHOD,input\stream_extractor.c:<global>,TYPE_DECL,"static int
se_DirControl( stream_t* stream, int req, va_list args )
{
    (void)stream;
    (void)args;

    if( req == STREAM_IS_DIRECTORY )
        return VLC_SUCCESS;

    return VLC_EGENERIC;
}",1,1,input\stream_extractor.c,se_DirControl,,false,181,191,se_DirControl,,,10,"int se_DirControl (stream_t*,int,va_list)"
74416,METHOD,input\stream_extractor.c:<global>,TYPE_DECL,"static int
se_InitStream( struct stream_extractor_private* priv, stream_t* s )
{
    if( priv->extractor.pf_read ) s->pf_read = se_StreamRead;
    else                          s->pf_block = se_StreamBlock;

    s->pf_seek = se_StreamSeek;
    s->pf_control = se_StreamControl;
    s->psz_url = StreamExtractorCreateMRL( priv->extractor.source->psz_url,
                                           priv->extractor.identifier );
    if( unlikely( !s->psz_url ) )
        return VLC_ENOMEM;

    return VLC_SUCCESS;
}",1,1,input\stream_extractor.c,se_InitStream,,false,203,217,se_InitStream,,,11,"int se_InitStream (stream_extractor_private*,stream_t*)"
74479,METHOD,input\stream_extractor.c:<global>,TYPE_DECL,"static void
se_CleanStream( struct stream_extractor_private* priv )
{
    free( (char*)priv->extractor.identifier );
}",1,1,input\stream_extractor.c,se_CleanStream,,false,219,223,se_CleanStream,,,12,void se_CleanStream (stream_extractor_private*)
74492,METHOD,input\stream_extractor.c:<global>,TYPE_DECL,"static int
se_InitDirectory( struct stream_extractor_private* priv, stream_t* s )
{
    stream_directory_t* directory = &priv->directory;

    s->pf_readdir = se_ReadDir;
    s->pf_control = se_DirControl;
    s->psz_url = strdup( directory->source->psz_url );

    if( unlikely( !s->psz_url ) )
        return VLC_EGENERIC;

    return VLC_SUCCESS;
}",1,1,input\stream_extractor.c,se_InitDirectory,,false,225,238,se_InitDirectory,,,13,"int se_InitDirectory (stream_extractor_private*,stream_t*)"
74536,METHOD,input\stream_extractor.c:<global>,TYPE_DECL,"static int
se_AttachWrapper( struct stream_extractor_private* priv, stream_t* source )
{
    stream_t* s = vlc_stream_CommonNew( source->obj.parent, se_StreamDelete );

    if( unlikely( !s ) )
        return VLC_ENOMEM;

    if( priv->pf_init( priv, s ) )
    {
        stream_CommonDelete( s );
        return VLC_EGENERIC;
    }

    priv->wrapper = s;
    priv->wrapper->p_input = source->p_input;
    priv->wrapper->p_sys = priv;

    priv->source = source;

    if( priv->wrapper->pf_read )
        priv->wrapper = stream_FilterChainNew( priv->wrapper, ""cache_read"" );
    else if( priv->wrapper->pf_block )
        priv->wrapper = stream_FilterChainNew( priv->wrapper, ""cache_block"" );

    return VLC_SUCCESS;
}",1,1,input\stream_extractor.c,se_AttachWrapper,,false,255,281,se_AttachWrapper,,,14,"int se_AttachWrapper (stream_extractor_private*,stream_t*)"
74633,METHOD,input\stream_extractor.c:<global>,TYPE_DECL,"static int
StreamExtractorAttach( stream_t** source, char const* identifier,
    char const* module_name )
{
    const bool extractor = identifier != NULL;
    char const* capability = extractor ? ""stream_extractor""
                                       : ""stream_directory"";

    struct stream_extractor_private* priv = vlc_custom_create(
        (*source)->obj.parent, sizeof( *priv ), capability );

    if( unlikely( !priv ) )
        return VLC_ENOMEM;

    if( extractor )
    {
        priv->object = VLC_OBJECT( &priv->extractor );

        priv->pf_init = se_InitStream;
        priv->pf_clean = se_CleanStream;

        priv->extractor.source = *source;
        priv->extractor.identifier = strdup( identifier );

        if( unlikely( !priv->extractor.identifier ) )
            goto error;
    }
    else
    {
        priv->object = VLC_OBJECT( &priv->directory );

        priv->pf_init = se_InitDirectory;
        priv->pf_clean = NULL;

        priv->directory.source = *source;
 ...",1,1,input\stream_extractor.c,StreamExtractorAttach,,false,283,331,StreamExtractorAttach,,,15,"int StreamExtractorAttach (stream_t**,char*,char*)"
74787,METHOD,input\stream_extractor.c:<global>,TYPE_DECL,"int
vlc_stream_directory_Attach( stream_t** source, char const* module_name )
{
    return StreamExtractorAttach( source, NULL, module_name );
}",1,1,input\stream_extractor.c,vlc_stream_directory_Attach,,false,333,337,vlc_stream_directory_Attach,,,16,"int vlc_stream_directory_Attach (stream_t**,char*)"
74798,METHOD,input\stream_extractor.c:<global>,TYPE_DECL,"int
vlc_stream_extractor_Attach( stream_t** source, char const* identifier,
                             char const* module_name )
{
    return StreamExtractorAttach( source, identifier, module_name );
}",1,1,input\stream_extractor.c,vlc_stream_extractor_Attach,,false,339,344,vlc_stream_extractor_Attach,,,17,"int vlc_stream_extractor_Attach (stream_t**,char*,char*)"
74810,METHOD,input\stream_extractor.c:<global>,TYPE_DECL,"int
stream_extractor_AttachParsed( stream_t** source, char const* data,
                               char const** out_extra )
{
    vlc_array_t identifiers;

    if( mrl_FragmentSplit( &identifiers, out_extra, data ) )
        return VLC_EGENERIC;

    size_t count = vlc_array_count( &identifiers );
    size_t idx = 0;

    while( idx < count )
    {
        char* id = vlc_array_item_at_index( &identifiers, idx );

        if( vlc_stream_extractor_Attach( source, id, NULL ) )
            break;

        ++idx;
    }

    for( size_t i = 0; i < count; ++i )
        free( vlc_array_item_at_index( &identifiers, i ) );
    vlc_array_clear( &identifiers );

    return idx == count ? VLC_SUCCESS : VLC_EGENERIC;
}",1,1,input\stream_extractor.c,stream_extractor_AttachParsed,,false,346,373,stream_extractor_AttachParsed,,,18,"int stream_extractor_AttachParsed (stream_t**,char*,char**)"
74884,METHOD,input\stream_extractor.c:<global>,TYPE_DECL,"char*
vlc_stream_extractor_CreateMRL( stream_directory_t* directory,
                                char const* subentry )
{
    return StreamExtractorCreateMRL( directory->source->psz_url, subentry );
}",1,1,input\stream_extractor.c,vlc_stream_extractor_CreateMRL,,false,375,380,vlc_stream_extractor_CreateMRL,,,19,"char* vlc_stream_extractor_CreateMRL (stream_directory_t*,char*)"
74919,METHOD,input\stream_fifo.c:<global>,TYPE_DECL,<global>,1,1,input\stream_fifo.c,input\stream_fifo.c:<global>,,false,1,190,<global>,,,1,
74924,METHOD,input\stream_fifo.c:<global>,TYPE_DECL,"static void vlc_stream_fifo_Destroy(stream_t *s)
{
    stream_sys_t *sys = s->p_sys;
    vlc_fifo_t *fifo = sys->fifo;
    block_t *block;
    bool closed;

    vlc_fifo_Lock(fifo);
    block = vlc_fifo_DequeueAllUnlocked(fifo);
    closed = sys->eof;
    sys->eof = true;
    vlc_fifo_Unlock(fifo);

    block_ChainRelease(block);

    if (closed)
    {   /* Destroy shared state if write end is already closed */
        block_FifoRelease(fifo);
        free(sys);
    }
}",1,1,input\stream_fifo.c,vlc_stream_fifo_Destroy,,false,42,62,vlc_stream_fifo_Destroy,,,2,void vlc_stream_fifo_Destroy (stream_t*)
74970,METHOD,input\stream_fifo.c:<global>,TYPE_DECL,"static block_t *vlc_stream_fifo_Block(stream_t *s, bool *restrict eof)
{
    stream_sys_t *sys = s->p_sys;
    vlc_fifo_t *fifo = sys->fifo;
    block_t *block;

    vlc_fifo_Lock(fifo);
    while (vlc_fifo_IsEmpty(fifo))
    {
        if (sys->eof)
        {
            *eof = true;
            break;
        }
        vlc_fifo_Wait(fifo);
    }

    block = vlc_fifo_DequeueUnlocked(fifo);
    vlc_fifo_Unlock(fifo);
    return block;
}",1,1,input\stream_fifo.c,vlc_stream_fifo_Block,,false,64,84,vlc_stream_fifo_Block,,,3,"block_t vlc_stream_fifo_Block (stream_t*,bool*)"
75015,METHOD,input\stream_fifo.c:<global>,TYPE_DECL,"static int vlc_stream_fifo_Control(stream_t *s, int query, va_list ap)
{
    (void) s;

    switch (query)
    {
        case STREAM_CAN_SEEK:
        case STREAM_CAN_FASTSEEK:
        case STREAM_CAN_PAUSE:
        case STREAM_CAN_CONTROL_PACE:
            *va_arg(ap, bool *) = false;
            break;

        case STREAM_GET_PTS_DELAY:
            *va_arg(ap, int64_t *) = DEFAULT_PTS_DELAY;
            break;

        default:
            return VLC_EGENERIC;
    }
    return VLC_SUCCESS;
}",1,1,input\stream_fifo.c,vlc_stream_fifo_Control,,false,86,107,vlc_stream_fifo_Control,,,4,"int vlc_stream_fifo_Control (stream_t*,int,va_list)"
75047,METHOD,input\stream_fifo.c:<global>,TYPE_DECL,"stream_t *vlc_stream_fifo_New(vlc_object_t *parent)
{
    stream_sys_t *sys = malloc(sizeof (*sys));
    if (unlikely(sys == NULL))
        return NULL;

    sys->fifo = block_FifoNew();
    if (unlikely(sys->fifo == NULL))
    {
        free(sys);
        return NULL;
    }

    sys->eof = false;

    stream_t *s = vlc_stream_CommonNew(parent, vlc_stream_fifo_Destroy);
    if (unlikely(s == NULL))
    {
        block_FifoRelease(sys->fifo);
        free(sys);
        return NULL;
    }

    s->pf_block = vlc_stream_fifo_Block;
    s->pf_seek = NULL;
    s->pf_control = vlc_stream_fifo_Control;
    s->p_sys = sys;
    return vlc_object_hold(s);
}",1,1,input\stream_fifo.c,vlc_stream_fifo_New,,false,109,137,vlc_stream_fifo_New,,,5,stream_t vlc_stream_fifo_New (vlc_object_t*)
75132,METHOD,input\stream_fifo.c:<global>,TYPE_DECL,"int vlc_stream_fifo_Queue(stream_t *s, block_t *block)
{
    stream_sys_t *sys = s->p_sys;
    vlc_fifo_t *fifo = sys->fifo;

    vlc_fifo_Lock(fifo);
    if (likely(!sys->eof))
    {
        vlc_fifo_QueueUnlocked(fifo, block);
        block = NULL;
    }
    vlc_fifo_Unlock(fifo);

    if (unlikely(block != NULL))
    {
        block_Release(block);
        errno = EPIPE;
        return -1;
    }
    return 0;
}",1,1,input\stream_fifo.c,vlc_stream_fifo_Queue,,false,139,159,vlc_stream_fifo_Queue,,,6,"int vlc_stream_fifo_Queue (stream_t*,block_t*)"
75183,METHOD,input\stream_fifo.c:<global>,TYPE_DECL,"ssize_t vlc_stream_fifo_Write(stream_t *s, const void *buf, size_t len)
{
    block_t *block = block_Alloc(len);
    if (unlikely(block == NULL))
        return -1;

    memcpy(block->p_buffer, buf, len);
    return vlc_stream_fifo_Queue(s, block) ? -1 : (ssize_t)len;
}",1,1,input\stream_fifo.c,vlc_stream_fifo_Write,,false,161,169,vlc_stream_fifo_Write,,,7,"ssize_t vlc_stream_fifo_Write (stream_t*,void*,size_t)"
75220,METHOD,input\stream_fifo.c:<global>,TYPE_DECL,"void vlc_stream_fifo_Close(stream_t *s)
{
    stream_sys_t *sys = s->p_sys;
    vlc_fifo_t *fifo = sys->fifo;
    bool closed;

    vlc_fifo_Lock(fifo);
    closed = sys->eof;
    sys->eof = true;
    vlc_fifo_Signal(fifo);
    vlc_fifo_Unlock(fifo);

    if (closed)
    {   /* Destroy shared state if read end is already closed */
        block_FifoRelease(fifo);
        free(sys);
    }

    vlc_object_release(s);
}",1,1,input\stream_fifo.c,vlc_stream_fifo_Close,,false,171,190,vlc_stream_fifo_Close,,,8,void vlc_stream_fifo_Close (stream_t*)
75280,METHOD,input\stream_filter.c:<global>,TYPE_DECL,<global>,1,1,input\stream_filter.c,input\stream_filter.c:<global>,,false,1,122,<global>,,,1,
75282,METHOD,input\stream_filter.c:<global>,TYPE_DECL,static void StreamDelete( stream_t * );,13,38,input\stream_filter.c,StreamDelete,,false,37,37,StreamDelete,,,1,void StreamDelete (stream_t*)
75287,METHOD,input\stream_filter.c:<global>,TYPE_DECL,"stream_t *vlc_stream_FilterNew( stream_t *p_source,
                                const char *psz_stream_filter )
{
    stream_t *s;
    assert( p_source != NULL );

    s = vlc_stream_CommonNew( p_source->obj.parent, StreamDelete );
    if( s == NULL )
        return NULL;

    s->p_input = p_source->p_input;

    if( p_source->psz_url != NULL )
    {
        s->psz_url = strdup( p_source->psz_url );
        if( unlikely(s->psz_url == NULL) )
            goto error;
    }
    s->p_source = p_source;

    /* */
    s->p_module = module_need( s, ""stream_filter"", psz_stream_filter, true );
    if( s->p_module == NULL )
        goto error;

    return s;
error:
    stream_CommonDelete( s );
    return NULL;
}",1,1,input\stream_filter.c,vlc_stream_FilterNew,,false,39,68,vlc_stream_FilterNew,,,2,"stream_t vlc_stream_FilterNew (stream_t*,char*)"
75374,METHOD,input\stream_filter.c:<global>,TYPE_DECL,"stream_t *stream_FilterAutoNew( stream_t *p_source )
{
    /* Limit number of entries to avoid infinite recursion. */
    for( unsigned i = 0; i < 16; i++ )
    {
        stream_t *p_filter = vlc_stream_FilterNew( p_source, NULL );
        if( p_filter == NULL )
            break;

        msg_Dbg( p_filter, ""stream filter added to %p"", (void *)p_source );
        p_source = p_filter;
    }
    return p_source;
}",1,1,input\stream_filter.c,stream_FilterAutoNew,,false,71,84,stream_FilterAutoNew,,,3,stream_t stream_FilterAutoNew (stream_t*)
75414,METHOD,input\stream_filter.c:<global>,TYPE_DECL,"stream_t *stream_FilterChainNew( stream_t *p_source, const char *psz_chain )
{
    /* Add user stream filter */
    char *chain = strdup( psz_chain );
    if( unlikely(chain == NULL) )
        return p_source;

    char *buf;
    for( const char *name = strtok_r( chain, "":"", &buf );
         name != NULL;
         name = strtok_r( NULL, "":"", &buf ) )
    {
        stream_t *p_filter = vlc_stream_FilterNew( p_source, name );
        if( p_filter != NULL )
            p_source = p_filter;
        else
            msg_Warn( p_source, ""cannot insert stream filter %s"", name );
    }
    free( chain );

    return p_source;
}",1,1,input\stream_filter.c,stream_FilterChainNew,,false,87,108,stream_FilterChainNew,,,4,"stream_t stream_FilterChainNew (stream_t*,char*)"
75479,METHOD,input\stream_filter.c:<global>,TYPE_DECL,"static void StreamDelete( stream_t *s )
{
    module_unneed( s, s->p_module );

    if( s->p_source )
        vlc_stream_Delete( s->p_source );
}",1,1,input\stream_filter.c,StreamDelete,,false,110,116,StreamDelete,,,5,void StreamDelete (stream_t*)
75498,METHOD,input\stream_filter.c:<global>,TYPE_DECL,"int vlc_stream_FilterDefaultReadDir( stream_t *s, input_item_node_t *p_node )
{
    assert( s->p_source != NULL );
    return vlc_stream_ReadDir( s->p_source, p_node );
}",1,1,input\stream_filter.c,vlc_stream_FilterDefaultReadDir,,false,118,122,vlc_stream_FilterDefaultReadDir,,,6,"int vlc_stream_FilterDefaultReadDir (stream_t*,input_item_node_t*)"
75523,METHOD,input\stream_memory.c:<global>,TYPE_DECL,<global>,1,1,input\stream_memory.c,input\stream_memory.c:<global>,,false,1,157,<global>,,,1,
75529,METHOD,input\stream_memory.c:<global>,TYPE_DECL,"static ssize_t Read( stream_t *, void *p_read, size_t i_read );",16,62,input\stream_memory.c,Read,,false,37,37,Read,,,2,"ssize_t Read (stream_t*,void*,size_t)"
75536,METHOD,input\stream_memory.c:<global>,TYPE_DECL,"static int Seek( stream_t *, uint64_t );",12,39,input\stream_memory.c,Seek,,false,38,38,Seek,,,3,"int Seek (stream_t*,ANY)"
75542,METHOD,input\stream_memory.c:<global>,TYPE_DECL,"static int  Control( stream_t *, int i_query, va_list );",13,55,input\stream_memory.c,Control,,false,39,39,Control,,,4,"int Control (stream_t*,int,ANY)"
75549,METHOD,input\stream_memory.c:<global>,TYPE_DECL,"static void stream_MemoryPreserveDelete(stream_t *s)
{
    free(s->p_sys);
}",1,1,input\stream_memory.c,stream_MemoryPreserveDelete,,false,41,44,stream_MemoryPreserveDelete,,,5,void stream_MemoryPreserveDelete (stream_t*)
75558,METHOD,input\stream_memory.c:<global>,TYPE_DECL,"static void stream_MemoryDelete(stream_t *s)
{
    stream_sys_t *sys = s->p_sys;

    free(sys->p_buffer);
    stream_MemoryPreserveDelete(s);
}",1,1,input\stream_memory.c,stream_MemoryDelete,,false,46,52,stream_MemoryDelete,,,6,void stream_MemoryDelete (stream_t*)
75575,METHOD,input\stream_memory.c:<global>,TYPE_DECL,"stream_t *(vlc_stream_MemoryNew)(vlc_object_t *p_this, uint8_t *p_buffer,
                                 size_t i_size, bool preserve)
{
    stream_t *s = vlc_stream_CommonNew( p_this,
                                        preserve ? stream_MemoryPreserveDelete
                                                 : stream_MemoryDelete );
    stream_sys_t *p_sys;

    if( !s )
        return NULL;

    s->p_sys = p_sys = malloc( sizeof( stream_sys_t ) );
    if( !s->p_sys )
    {
        stream_CommonDelete( s );
        return NULL;
    }
    p_sys->i_pos = 0;
    p_sys->i_size = i_size;
    p_sys->p_buffer = p_buffer;

    s->pf_read    = Read;
    s->pf_seek    = Seek;
    s->pf_control = Control;

    return s;
}",1,1,input\stream_memory.c,,,false,54,80,vlc_stream_MemoryNew,,,7,"stream_t (vlc_object_t*,uint8_t*,size_t,bool)"
75650,METHOD,input\stream_memory.c:<global>,TYPE_DECL,"static int Control( stream_t *s, int i_query, va_list args )
{
    stream_sys_t *p_sys = s->p_sys;

    uint64_t   *pi_64;

    switch( i_query )
    {
        case STREAM_GET_SIZE:
            pi_64 = va_arg( args, uint64_t * );
            *pi_64 = p_sys->i_size;
            break;

        case STREAM_CAN_SEEK:
        case STREAM_CAN_FASTSEEK:
        case STREAM_CAN_PAUSE:
        case STREAM_CAN_CONTROL_PACE:
            *va_arg( args, bool * ) = true;
            break;

        case STREAM_GET_PTS_DELAY:
            *va_arg( args, int64_t * ) = 0;
            break;

        case STREAM_GET_TITLE_INFO:
        case STREAM_GET_TITLE:
        case STREAM_GET_SEEKPOINT:
        case STREAM_GET_META:
        case STREAM_GET_CONTENT_TYPE:
        case STREAM_GET_SIGNAL:
        case STREAM_SET_TITLE:
        case STREAM_SET_SEEKPOINT:
            return VLC_EGENERIC;

        case STREAM_SET_PAUSE_STATE:
            break; /* nothing to do */

        case STREAM_SET_PRIVATE_ID_S...",1,1,input\stream_memory.c,Control,,false,85,134,Control,,,8,"int Control (stream_t*,int,va_list)"
75732,METHOD,input\stream_memory.c:<global>,TYPE_DECL,"static ssize_t Read( stream_t *s, void *p_read, size_t i_read )
{
    stream_sys_t *p_sys = s->p_sys;

    if( i_read > p_sys->i_size - p_sys->i_pos )
        i_read = p_sys->i_size - p_sys->i_pos;
    if ( p_read )
        memcpy( p_read, p_sys->p_buffer + p_sys->i_pos, i_read );
    p_sys->i_pos += i_read;
    return i_read;
}",1,1,input\stream_memory.c,Read,,false,136,146,Read,,,9,"ssize_t Read (stream_t*,void*,size_t)"
75785,METHOD,input\stream_memory.c:<global>,TYPE_DECL,"static int Seek( stream_t *s, uint64_t offset )
{
    stream_sys_t *p_sys = s->p_sys;

    if( offset > p_sys->i_size )
        offset = p_sys->i_size;

    p_sys->i_pos = offset;
    return VLC_SUCCESS;
}",1,1,input\stream_memory.c,Seek,,false,148,157,Seek,,,10,"int Seek (stream_t*,uint64_t)"
75835,METHOD,input\subtitles.c:<global>,TYPE_DECL,<global>,1,1,input\subtitles.c,input\subtitles.c:<global>,,false,1,432,<global>,,,1,
75843,METHOD,input\subtitles.c:<global>,TYPE_DECL,"static void strcpy_trim( char *d, const char *s )
{
    unsigned char c;

    /* skip leading whitespace */
    while( ((c = *s) != '\0') && !isalnum(c) )
    {
        s++;
    }
    for(;;)
    {
        /* copy word */
        while( ((c = *s) != '\0') && isalnum(c) )
        {
            *d = tolower(c);
            s++; d++;
        }
        if( *s == 0 ) break;
        /* trim excess whitespace */
        while( ((c = *s) != '\0') && !isalnum(c) )
        {
            s++;
        }
        if( *s == 0 ) break;
        *d++ = ' ';
    }
    *d = 0;
}",1,1,input\subtitles.c,strcpy_trim,,false,49,76,strcpy_trim,,,3,"void strcpy_trim (char*,char*)"
75924,METHOD,input\subtitles.c:<global>,TYPE_DECL,"static void strcpy_strip_ext( char *d, const char *s )
{
    unsigned char c;

    const char *tmp = strrchr(s, '.');
    if( !tmp )
    {
        strcpy(d, s);
        return;
    }
    else
        strlcpy(d, s, tmp - s + 1 );
    while( (c = *d) != '\0' )
    {
        *d = tolower(c);
        d++;
    }
}",1,1,input\subtitles.c,strcpy_strip_ext,,false,78,95,strcpy_strip_ext,,,4,"void strcpy_strip_ext (char*,char*)"
75970,METHOD,input\subtitles.c:<global>,TYPE_DECL,"static void strcpy_get_ext( char *d, const char *s )
{
    const char *tmp = strrchr(s, '.');
    if( !tmp )
        strcpy(d, """");
    else
        strcpy( d, tmp + 1 );
}",1,1,input\subtitles.c,strcpy_get_ext,,false,97,104,strcpy_get_ext,,,5,"void strcpy_get_ext (char*,char*)"
75996,METHOD,input\subtitles.c:<global>,TYPE_DECL,"static int whiteonly( const char *s )
{
    unsigned char c;

    while( (c = *s) != '\0' )
    {
        if( isalnum( c ) )
            return 0;
        s++;
    }
    return 1;
}",1,1,input\subtitles.c,whiteonly,,false,106,117,whiteonly,,,6,int whiteonly (char*)
76020,METHOD,input\subtitles.c:<global>,TYPE_DECL,"static int slave_strcmp( const void *a, const void *b )
{
    const input_item_slave_t *p_slave0 = *((const input_item_slave_t **) a);
    const input_item_slave_t *p_slave1 = *((const input_item_slave_t **) b);

    if( p_slave0 == NULL || p_slave1 == NULL )
        return 0;

    /* We can compare these uris since they come from the file system */
#ifdef HAVE_STRCOLL
    return strcoll( p_slave0->psz_uri, p_slave1->psz_uri );
#else
    return strcmp( p_slave0->psz_uri, p_slave1->psz_uri );
#endif
}",1,1,input\subtitles.c,slave_strcmp,,false,119,133,slave_strcmp,,,7,"int slave_strcmp (void*,void*)"
76059,METHOD,input\subtitles.c:<global>,TYPE_DECL,"int subtitles_Filter( const char *psz_dir_content )
{
    const char *tmp = strrchr( psz_dir_content, '.');

    if( !tmp )
        return 0;
    tmp++;

    for( int i = 0; sub_exts[i][0]; i++ )
        if( strcasecmp( sub_exts[i], tmp ) == 0 )
            return 1;
    return 0;
}",1,1,input\subtitles.c,subtitles_Filter,,false,138,150,subtitles_Filter,,,8,int subtitles_Filter (char*)
76104,METHOD,input\subtitles.c:<global>,TYPE_DECL,"static char **paths_to_list( const char *psz_dir, char *psz_path )
{
    unsigned int i, k, i_nb_subdirs;
    char **subdirs; /* list of subdirectories to look in */
    char *psz_parser = psz_path;

    if( !psz_dir || !psz_path )
        return NULL;

    for( k = 0, i_nb_subdirs = 1; psz_path[k] != '\0'; k++ )
    {
        if( psz_path[k] == ',' )
            i_nb_subdirs++;
    }

    subdirs = calloc( i_nb_subdirs + 1, sizeof(char*) );
    if( !subdirs )
        return NULL;

    for( i = 0; psz_parser && *psz_parser != '\0' ; )
    {
        char *psz_subdir = psz_parser;
        psz_parser = strchr( psz_subdir, ',' );
        if( psz_parser )
        {
            *psz_parser++ = '\0';
            while( *psz_parser == ' ' )
                psz_parser++;
        }
        if( *psz_subdir == '\0' )
            continue;

        if( asprintf( &subdirs[i++], ""%s%s"",
                  psz_subdir[0] == '.' ? psz_dir : """",
                  psz_subdir ) == -1 )
            break;...",1,1,input\subtitles.c,paths_to_list,,false,156,196,paths_to_list,,,9,"char** paths_to_list (char*,char*)"
76239,METHOD,input\subtitles.c:<global>,TYPE_DECL,"int subtitles_Detect( input_thread_t *p_this, char *psz_path, const char *psz_name_org,
                      input_item_slave_t ***ppp_slaves, int *p_slaves )
{
    int i_fuzzy = var_GetInteger( p_this, ""sub-autodetect-fuzzy"" );
    if ( i_fuzzy == 0 )
        return VLC_EGENERIC;
    int i_fname_len;
    input_item_slave_t **pp_slaves = *ppp_slaves;
    int i_slaves = *p_slaves;
    char *f_fname_noext = NULL, *f_fname_trim = NULL;
    char **subdirs; /* list of subdirectories to look in */

    if( !psz_name_org )
        return VLC_EGENERIC;

    char *psz_fname = vlc_uri2path( psz_name_org );
    if( !psz_fname )
        return VLC_EGENERIC;

    /* extract filename & dirname from psz_fname */
    char *f_dir = strdup( psz_fname );
    if( f_dir == 0 )
    {
        free( psz_fname );
        return VLC_ENOMEM;
    }

    const char *f_fname = strrchr( psz_fname, DIR_SEP_CHAR );
    if( !f_fname )
    {
        free( f_dir );
        free( psz_fname );
        return VLC_EGENER...",1,1,input\subtitles.c,subtitles_Detect,,false,214,432,subtitles_Detect,,,10,"int subtitles_Detect (input_thread_t*,char*,char*,input_item_slave_t***,int*)"
76830,METHOD,input\var.c:<global>,TYPE_DECL,<global>,1,1,input\var.c,input\var.c:<global>,,false,1,851,<global>,,,1,
76832,METHOD,input\var.c:<global>,TYPE_DECL,"static int StateCallback   ( vlc_object_t *p_this, char const *psz_cmd,
                             vlc_value_t oldval, vlc_value_t newval, void * );",12,77,input\var.c,StateCallback,,false,42,43,StateCallback,,,1,"int StateCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
76841,METHOD,input\var.c:<global>,TYPE_DECL,"static int RateCallback    ( vlc_object_t *p_this, char const *psz_cmd,
                             vlc_value_t oldval, vlc_value_t newval, void * );",12,77,input\var.c,RateCallback,,false,44,45,RateCallback,,,2,"int RateCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
76850,METHOD,input\var.c:<global>,TYPE_DECL,"static int PositionCallback( vlc_object_t *p_this, char const *psz_cmd,
                             vlc_value_t oldval, vlc_value_t newval, void * );",12,77,input\var.c,PositionCallback,,false,46,47,PositionCallback,,,3,"int PositionCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
76859,METHOD,input\var.c:<global>,TYPE_DECL,"static int TimeCallback    ( vlc_object_t *p_this, char const *psz_cmd,
                             vlc_value_t oldval, vlc_value_t newval, void * );",12,77,input\var.c,TimeCallback,,false,48,49,TimeCallback,,,4,"int TimeCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
76868,METHOD,input\var.c:<global>,TYPE_DECL,"static int TimeOffsetCallback( vlc_object_t *p_this, char const *psz_cmd,
                             vlc_value_t oldval, vlc_value_t newval, void * );",12,77,input\var.c,TimeOffsetCallback,,false,50,51,TimeOffsetCallback,,,5,"int TimeOffsetCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
76877,METHOD,input\var.c:<global>,TYPE_DECL,"static int ProgramCallback ( vlc_object_t *p_this, char const *psz_cmd,
                             vlc_value_t oldval, vlc_value_t newval, void * );",12,77,input\var.c,ProgramCallback,,false,52,53,ProgramCallback,,,6,"int ProgramCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
76886,METHOD,input\var.c:<global>,TYPE_DECL,"static int TitleCallback   ( vlc_object_t *p_this, char const *psz_cmd,
                             vlc_value_t oldval, vlc_value_t newval, void * );",12,77,input\var.c,TitleCallback,,false,54,55,TitleCallback,,,7,"int TitleCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
76895,METHOD,input\var.c:<global>,TYPE_DECL,"static int SeekpointCallback( vlc_object_t *p_this, char const *psz_cmd,
                             vlc_value_t oldval, vlc_value_t newval, void * );",12,77,input\var.c,SeekpointCallback,,false,56,57,SeekpointCallback,,,8,"int SeekpointCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
76904,METHOD,input\var.c:<global>,TYPE_DECL,"static int NavigationCallback( vlc_object_t *p_this, char const *psz_cmd,
                             vlc_value_t oldval, vlc_value_t newval, void * );",12,77,input\var.c,NavigationCallback,,false,58,59,NavigationCallback,,,9,"int NavigationCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
76913,METHOD,input\var.c:<global>,TYPE_DECL,"static int EsVideoCallback ( vlc_object_t *p_this, char const *psz_cmd,
                             vlc_value_t oldval, vlc_value_t newval, void * );",12,77,input\var.c,EsVideoCallback,,false,60,61,EsVideoCallback,,,10,"int EsVideoCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
76922,METHOD,input\var.c:<global>,TYPE_DECL,"static int EsAudioCallback ( vlc_object_t *p_this, char const *psz_cmd,
                             vlc_value_t oldval, vlc_value_t newval, void * );",12,77,input\var.c,EsAudioCallback,,false,62,63,EsAudioCallback,,,11,"int EsAudioCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
76931,METHOD,input\var.c:<global>,TYPE_DECL,"static int EsSpuCallback ( vlc_object_t *p_this, char const *psz_cmd,
                           vlc_value_t oldval, vlc_value_t newval, void * );",12,75,input\var.c,EsSpuCallback,,false,64,65,EsSpuCallback,,,12,"int EsSpuCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
76940,METHOD,input\var.c:<global>,TYPE_DECL,"static int EsDelayCallback ( vlc_object_t *p_this, char const *psz_cmd,
                             vlc_value_t oldval, vlc_value_t newval, void * );",12,77,input\var.c,EsDelayCallback,,false,66,67,EsDelayCallback,,,13,"int EsDelayCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
76949,METHOD,input\var.c:<global>,TYPE_DECL,"static int BookmarkCallback( vlc_object_t *p_this, char const *psz_cmd,
                             vlc_value_t oldval, vlc_value_t newval, void * );",12,77,input\var.c,BookmarkCallback,,false,69,70,BookmarkCallback,,,14,"int BookmarkCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
76958,METHOD,input\var.c:<global>,TYPE_DECL,"static int RecordCallback( vlc_object_t *p_this, char const *psz_cmd,
                           vlc_value_t oldval, vlc_value_t newval,
                           void *p_data );",12,41,input\var.c,RecordCallback,,false,72,74,RecordCallback,,,15,"int RecordCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
76967,METHOD,input\var.c:<global>,TYPE_DECL,"static int FrameNextCallback( vlc_object_t *p_this, char const *psz_cmd,
                              vlc_value_t oldval, vlc_value_t newval,
                              void *p_data );",12,44,input\var.c,FrameNextCallback,,false,75,77,FrameNextCallback,,,16,"int FrameNextCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
76980,METHOD,input\var.c:<global>,TYPE_DECL,"static void InputAddCallbacks( input_thread_t *, const vlc_input_callback_t * );",13,79,input\var.c,InputAddCallbacks,,false,85,85,InputAddCallbacks,,,19,"void InputAddCallbacks (input_thread_t*,vlc_input_callback_t*)"
76986,METHOD,input\var.c:<global>,TYPE_DECL,"static void InputDelCallbacks( input_thread_t *, const vlc_input_callback_t * );",13,79,input\var.c,InputDelCallbacks,,false,86,86,InputDelCallbacks,,,20,"void InputDelCallbacks (input_thread_t*,vlc_input_callback_t*)"
77066,METHOD,input\var.c:<global>,TYPE_DECL,"void input_ControlVarInit ( input_thread_t *p_input )
{
    vlc_value_t val, text;

    /* State */
    var_Create( p_input, ""state"", VLC_VAR_INTEGER );
    val.i_int = input_priv(p_input)->i_state;
    var_Change( p_input, ""state"", VLC_VAR_SETVALUE, &val, NULL );

    /* Rate */
    var_Create( p_input, ""rate"", VLC_VAR_FLOAT | VLC_VAR_DOINHERIT );

    var_Create( p_input, ""frame-next"", VLC_VAR_VOID );

    /* Position */
    var_Create( p_input, ""position"",  VLC_VAR_FLOAT );

    /* Time */
    var_Create( p_input, ""time"", VLC_VAR_INTEGER );
    var_Create( p_input, ""time-offset"", VLC_VAR_INTEGER );    /* relative */

    /* Bookmark */
    var_Create( p_input, ""bookmark"", VLC_VAR_INTEGER | VLC_VAR_ISCOMMAND );
    val.psz_string = _(""Bookmark"");
    var_Change( p_input, ""bookmark"", VLC_VAR_SETTEXT, &val, NULL );

    /* Program */
    var_Create( p_input, ""program"", VLC_VAR_INTEGER | VLC_VAR_DOINHERIT );
    var_Get( p_input, ""program"", &val );
    if( val.i_int <= 0 )
        va...",1,1,input\var.c,input_ControlVarInit,,false,129,222,input_ControlVarInit,,,25,void input_ControlVarInit (input_thread_t*)
77359,METHOD,input\var.c:<global>,TYPE_DECL,"void input_ControlVarStop( input_thread_t *p_input )
{
    if( !input_priv(p_input)->b_preparsing )
        InputDelCallbacks( p_input, p_input_callbacks );

    if( input_priv(p_input)->i_title > 1 )
        InputDelCallbacks( p_input, p_input_title_navigation_callbacks );

    for( int i = 0; i < input_priv(p_input)->i_title; i++ )
    {
        char name[sizeof(""title "") + 3 * sizeof (int)];

        sprintf( name, ""title %2u"", i );
        var_DelCallback( p_input, name, NavigationCallback, (void *)(intptr_t)i );
    }

    if( var_Type( p_input, ""next-chapter"" ) != 0 )
    {
        assert( var_Type( p_input, ""prev-chapter"" ) != 0 );
        var_Destroy( p_input, ""next-chapter"" );
        var_Destroy( p_input, ""prev-chapter"" );
    }
}",1,1,input\var.c,input_ControlVarStop,,false,227,249,input_ControlVarStop,,,26,void input_ControlVarStop (input_thread_t*)
77433,METHOD,input\var.c:<global>,TYPE_DECL,"void input_ControlVarNavigation( input_thread_t *p_input )
{
    vlc_value_t text;

    /* Create more command variables */
    if( input_priv(p_input)->i_title > 1 )
    {
        if( var_Type( p_input, ""next-title"" ) == 0 ) {
            var_Create( p_input, ""next-title"", VLC_VAR_VOID );
            text.psz_string = _(""Next title"");
            var_Change( p_input, ""next-title"", VLC_VAR_SETTEXT, &text, NULL );
            var_AddCallback( p_input, ""next-title"", TitleCallback, NULL );
        }

        if( var_Type( p_input, ""prev-title"" ) == 0 ) {
            var_Create( p_input, ""prev-title"", VLC_VAR_VOID );
            text.psz_string = _(""Previous title"");
            var_Change( p_input, ""prev-title"", VLC_VAR_SETTEXT, &text, NULL );
            var_AddCallback( p_input, ""prev-title"", TitleCallback, NULL );
        }

        if( var_Type( p_input, ""menu-title"" ) == 0 ) {
            var_Create( p_input, ""menu-title"", VLC_VAR_VOID );
            text.psz_string = _(""Menu titl...",1,1,input\var.c,input_ControlVarNavigation,,false,255,359,input_ControlVarNavigation,,,27,void input_ControlVarNavigation (input_thread_t*)
77840,METHOD,input\var.c:<global>,TYPE_DECL,"void input_ControlVarTitle( input_thread_t *p_input, int i_title )
{
    const input_title_t *t = input_priv(p_input)->title[i_title];
    vlc_value_t text;
    int  i;

    /* Create/Destroy command variables */
    if( t->i_seekpoint <= 1 )
    {
        var_Destroy( p_input, ""next-chapter"" );
        var_Destroy( p_input, ""prev-chapter"" );
    }
    else if( var_Type( p_input, ""next-chapter"" ) == 0 )
    {
        var_Create( p_input, ""next-chapter"", VLC_VAR_VOID );
        text.psz_string = _(""Next chapter"");
        var_Change( p_input, ""next-chapter"", VLC_VAR_SETTEXT, &text, NULL );
        var_AddCallback( p_input, ""next-chapter"", SeekpointCallback, NULL );

        var_Create( p_input, ""prev-chapter"", VLC_VAR_VOID );
        text.psz_string = _(""Previous chapter"");
        var_Change( p_input, ""prev-chapter"", VLC_VAR_SETTEXT, &text, NULL );
        var_AddCallback( p_input, ""prev-chapter"", SeekpointCallback, NULL );
    }

    /* Build chapter list */
    var_Change( p_input...",1,1,input\var.c,input_ControlVarTitle,,false,365,413,input_ControlVarTitle,,,28,"void input_ControlVarTitle (input_thread_t*,int)"
78015,METHOD,input\var.c:<global>,TYPE_DECL,"void input_ConfigVarInit ( input_thread_t *p_input )
{
    /* Create Object Variables for private use only */

    if( !input_priv(p_input)->b_preparsing )
    {
        var_Create( p_input, ""video"", VLC_VAR_BOOL | VLC_VAR_DOINHERIT );
        var_Create( p_input, ""audio"", VLC_VAR_BOOL | VLC_VAR_DOINHERIT );
        var_Create( p_input, ""spu"", VLC_VAR_BOOL | VLC_VAR_DOINHERIT );

        var_Create( p_input, ""audio-track"", VLC_VAR_INTEGER|VLC_VAR_DOINHERIT );
        var_Create( p_input, ""sub-track"", VLC_VAR_INTEGER|VLC_VAR_DOINHERIT );

        var_Create( p_input, ""audio-language"",
                    VLC_VAR_STRING|VLC_VAR_DOINHERIT );
        var_Create( p_input, ""sub-language"",
                    VLC_VAR_STRING|VLC_VAR_DOINHERIT );
        var_Create( p_input, ""menu-language"",
                    VLC_VAR_STRING|VLC_VAR_DOINHERIT );

        var_Create( p_input, ""audio-track-id"",
                    VLC_VAR_INTEGER|VLC_VAR_DOINHERIT );
        var_Create( p_input, ""sub-track-id...",1,1,input\var.c,input_ConfigVarInit,,false,419,528,input_ConfigVarInit,,,29,void input_ConfigVarInit (input_thread_t*)
78370,METHOD,input\var.c:<global>,TYPE_DECL,"static void InputAddCallbacks( input_thread_t *p_input,
                               const vlc_input_callback_t *p_callbacks )
{
    int i;
    for( i = 0; p_callbacks[i].psz_name != NULL; i++ )
        var_AddCallback( p_input,
                         p_callbacks[i].psz_name,
                         p_callbacks[i].callback, NULL );
}",1,1,input\var.c,InputAddCallbacks,,false,533,541,InputAddCallbacks,,,30,"void InputAddCallbacks (input_thread_t*,vlc_input_callback_t*)"
78404,METHOD,input\var.c:<global>,TYPE_DECL,"static void InputDelCallbacks( input_thread_t *p_input,
                               const vlc_input_callback_t *p_callbacks )
{
    int i;
    for( i = 0; p_callbacks[i].psz_name != NULL; i++ )
        var_DelCallback( p_input,
                         p_callbacks[i].psz_name,
                         p_callbacks[i].callback, NULL );
}",1,1,input\var.c,InputDelCallbacks,,false,543,551,InputDelCallbacks,,,31,"void InputDelCallbacks (input_thread_t*,vlc_input_callback_t*)"
78438,METHOD,input\var.c:<global>,TYPE_DECL,"static int StateCallback( vlc_object_t *p_this, char const *psz_cmd,
                          vlc_value_t oldval, vlc_value_t newval,
                          void *p_data )
{
    input_thread_t *p_input = (input_thread_t*)p_this;
    VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval); VLC_UNUSED(p_data);

    if( newval.i_int == PLAYING_S || newval.i_int == PAUSE_S )
    {
        input_ControlPush( p_input, INPUT_CONTROL_SET_STATE, &newval );
        return VLC_SUCCESS;
    }

    return VLC_EGENERIC;
}",1,1,input\var.c,StateCallback,,false,556,570,StateCallback,,,32,"int StateCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
78481,METHOD,input\var.c:<global>,TYPE_DECL,"static int RateCallback( vlc_object_t *p_this, char const *psz_cmd,
                         vlc_value_t oldval, vlc_value_t newval, void *p_data )
{
    input_thread_t *p_input = (input_thread_t*)p_this;
    VLC_UNUSED(oldval); VLC_UNUSED(p_data); VLC_UNUSED(psz_cmd);

    newval.i_int = INPUT_RATE_DEFAULT / newval.f_float;
    input_ControlPush( p_input, INPUT_CONTROL_SET_RATE, &newval );

    return VLC_SUCCESS;
}",1,1,input\var.c,RateCallback,,false,572,582,RateCallback,,,33,"int RateCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
78518,METHOD,input\var.c:<global>,TYPE_DECL,"static int PositionCallback( vlc_object_t *p_this, char const *psz_cmd,
                             vlc_value_t oldval, vlc_value_t newval,
                             void *p_data )
{
    input_thread_t *p_input = (input_thread_t*)p_this;

    VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval); VLC_UNUSED(p_data);

    /* Update ""length"" for better intf behaviour */
    const int64_t i_length = var_GetInteger( p_input, ""length"" );
    if( i_length > 0 && newval.f_float >= 0.f && newval.f_float <= 1.f )
    {
        vlc_value_t val;

        val.i_int = i_length * newval.f_float;
        var_Change( p_input, ""time"", VLC_VAR_SETVALUE, &val, NULL );
    }

    input_ControlPush( p_input, INPUT_CONTROL_SET_POSITION, &newval );
    return VLC_SUCCESS;
}",1,1,input\var.c,PositionCallback,,false,584,604,PositionCallback,,,34,"int PositionCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
78586,METHOD,input\var.c:<global>,TYPE_DECL,"static int TimeCallback( vlc_object_t *p_this, char const *psz_cmd,
                         vlc_value_t oldval, vlc_value_t newval, void *p_data )
{
    input_thread_t *p_input = (input_thread_t*)p_this;
    VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval); VLC_UNUSED(p_data);

    /* Update ""position"" for better intf behaviour */
    const int64_t i_length = var_GetInteger( p_input, ""length"" );
    if( i_length > 0 && newval.i_int >= 0 && newval.i_int <= i_length )
    {
        vlc_value_t val;

        val.f_float = (double)newval.i_int/(double)i_length;
        var_Change( p_input, ""position"", VLC_VAR_SETVALUE, &val, NULL );
        /*
         * Notify the intf that a new event has been occurred.
         * XXX this is a bit hackish but it's the only way to do it now.
         */
        var_SetInteger( p_input, ""intf-event"", INPUT_EVENT_POSITION );
    }

    input_ControlPush( p_input, INPUT_CONTROL_SET_TIME, &newval );
    return VLC_SUCCESS;
}",1,1,input\var.c,TimeCallback,,false,606,629,TimeCallback,,,35,"int TimeCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
78662,METHOD,input\var.c:<global>,TYPE_DECL,"static int TimeOffsetCallback( vlc_object_t *obj, char const *varname,
                               vlc_value_t prev, vlc_value_t cur, void *data )
{
    VLC_UNUSED(varname); VLC_UNUSED(prev); VLC_UNUSED(data);

    int64_t i_time = var_GetInteger( obj, ""time"" ) + cur.i_int;
    if( i_time < 0 )
        i_time = 0;
    var_SetInteger( obj, ""time"", i_time );
    return VLC_SUCCESS;
}",1,1,input\var.c,TimeOffsetCallback,,false,631,641,TimeOffsetCallback,,,36,"int TimeOffsetCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
78701,METHOD,input\var.c:<global>,TYPE_DECL,"static int ProgramCallback( vlc_object_t *p_this, char const *psz_cmd,
                            vlc_value_t oldval, vlc_value_t newval,
                            void *p_data )
{
    input_thread_t *p_input = (input_thread_t*)p_this;
    VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval); VLC_UNUSED(p_data);

    input_ControlPush( p_input, INPUT_CONTROL_SET_PROGRAM, &newval );

    return VLC_SUCCESS;
}",1,1,input\var.c,ProgramCallback,,false,643,653,ProgramCallback,,,37,"int ProgramCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
78729,METHOD,input\var.c:<global>,TYPE_DECL,"static int TitleCallback( vlc_object_t *p_this, char const *psz_cmd,
                          vlc_value_t oldval, vlc_value_t newval,
                          void *p_data )
{
    input_thread_t *p_input = (input_thread_t*)p_this;
    vlc_value_t val, count;
    VLC_UNUSED(oldval); VLC_UNUSED(p_data);

    if( !strcmp( psz_cmd, ""next-title"" ) )
    {
        input_ControlPush( p_input, INPUT_CONTROL_SET_TITLE_NEXT, NULL );

        val.i_int = var_GetInteger( p_input, ""title"" ) + 1;
        var_Change( p_input, ""title"", VLC_VAR_CHOICESCOUNT, &count, NULL );
        if( val.i_int < count.i_int )
            var_Change( p_input, ""title"", VLC_VAR_SETVALUE, &val, NULL );
    }
    else if( !strcmp( psz_cmd, ""prev-title"" ) )
    {
        input_ControlPush( p_input, INPUT_CONTROL_SET_TITLE_PREV, NULL );

        val.i_int = var_GetInteger( p_input, ""title"" ) - 1;
        if( val.i_int >= 0 )
            var_Change( p_input, ""title"", VLC_VAR_SETVALUE, &val, NULL );
    }
    else if( !s...",1,1,input\var.c,TitleCallback,,false,655,694,TitleCallback,,,38,"int TitleCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
78860,METHOD,input\var.c:<global>,TYPE_DECL,"static int SeekpointCallback( vlc_object_t *p_this, char const *psz_cmd,
                              vlc_value_t oldval, vlc_value_t newval,
                              void *p_data )
{
    input_thread_t *p_input = (input_thread_t*)p_this;
    vlc_value_t val, count;
    VLC_UNUSED(oldval); VLC_UNUSED(p_data);

    if( !strcmp( psz_cmd, ""next-chapter"" ) )
    {
        input_ControlPush( p_input, INPUT_CONTROL_SET_SEEKPOINT_NEXT, NULL );

        val.i_int = var_GetInteger( p_input, ""chapter"" ) + 1;
        var_Change( p_input, ""chapter"", VLC_VAR_CHOICESCOUNT, &count, NULL );
        if( val.i_int < count.i_int )
            var_Change( p_input, ""chapter"", VLC_VAR_SETVALUE, &val, NULL );
    }
    else if( !strcmp( psz_cmd, ""prev-chapter"" ) )
    {
        input_ControlPush( p_input, INPUT_CONTROL_SET_SEEKPOINT_PREV, NULL );

        val.i_int = var_GetInteger( p_input, ""chapter"" ) - 1;
        if( val.i_int >= 0 )
            var_Change( p_input, ""chapter"", VLC_VAR_SETVALUE, &...",1,1,input\var.c,SeekpointCallback,,false,696,727,SeekpointCallback,,,39,"int SeekpointCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
78967,METHOD,input\var.c:<global>,TYPE_DECL,"static int NavigationCallback( vlc_object_t *p_this, char const *psz_cmd,
                               vlc_value_t oldval, vlc_value_t newval,
                               void *p_data )
{
    input_thread_t *p_input = (input_thread_t*)p_this;
    vlc_value_t     val;
    VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval);

    /* Issue a title change */
    val.i_int = (intptr_t)p_data;
    input_ControlPush( p_input, INPUT_CONTROL_SET_TITLE, &val );

    var_Change( p_input, ""title"", VLC_VAR_SETVALUE, &val, NULL );

    /* And a chapter change */
    input_ControlPush( p_input, INPUT_CONTROL_SET_SEEKPOINT, &newval );

    var_Change( p_input, ""chapter"", VLC_VAR_SETVALUE, &newval, NULL );

    return VLC_SUCCESS;
}",1,1,input\var.c,NavigationCallback,,false,729,749,NavigationCallback,,,40,"int NavigationCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
79020,METHOD,input\var.c:<global>,TYPE_DECL,"static int EsVideoCallback( vlc_object_t *p_this, char const *psz_cmd,
                            vlc_value_t oldval, vlc_value_t newval, void *p_data )
{
    input_thread_t *p_input = (input_thread_t*)p_this;
    VLC_UNUSED( psz_cmd); VLC_UNUSED( oldval ); VLC_UNUSED( p_data );

    if( newval.i_int < 0 )
        newval.i_int = -VIDEO_ES; /* disable video es */
    else
        var_SetBool( p_input, ""video"", true );

    input_ControlPush( p_input, INPUT_CONTROL_SET_ES, &newval );

    return VLC_SUCCESS;
}",1,1,input\var.c,EsVideoCallback,,false,751,765,EsVideoCallback,,,41,"int EsVideoCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
79067,METHOD,input\var.c:<global>,TYPE_DECL,"static int EsAudioCallback( vlc_object_t *p_this, char const *psz_cmd,
                            vlc_value_t oldval, vlc_value_t newval, void *p_data )
{
    input_thread_t *p_input = (input_thread_t*)p_this;
    VLC_UNUSED( psz_cmd); VLC_UNUSED( oldval ); VLC_UNUSED( p_data );

    if( newval.i_int < 0 )
        newval.i_int = -AUDIO_ES; /* disable audio es */
    else
        var_SetBool( p_input, ""audio"", true );

    input_ControlPush( p_input, INPUT_CONTROL_SET_ES, &newval );

    return VLC_SUCCESS;
}",1,1,input\var.c,EsAudioCallback,,false,767,781,EsAudioCallback,,,42,"int EsAudioCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
79114,METHOD,input\var.c:<global>,TYPE_DECL,"static int EsSpuCallback( vlc_object_t *p_this, char const *psz_cmd,
                           vlc_value_t oldval, vlc_value_t newval, void *p_data )
{
    input_thread_t *p_input = (input_thread_t*)p_this;
    VLC_UNUSED( psz_cmd); VLC_UNUSED( oldval ); VLC_UNUSED( p_data );

    if( newval.i_int < 0 )
        newval.i_int = -SPU_ES; /* disable spu es */
    else
        var_SetBool( p_input, ""spu"", true );

    input_ControlPush( p_input, INPUT_CONTROL_SET_ES, &newval );

    return VLC_SUCCESS;
}",1,1,input\var.c,EsSpuCallback,,false,783,797,EsSpuCallback,,,43,"int EsSpuCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
79161,METHOD,input\var.c:<global>,TYPE_DECL,"static int EsDelayCallback ( vlc_object_t *p_this, char const *psz_cmd,
                             vlc_value_t oldval, vlc_value_t newval, void *p_data )
{
    input_thread_t *p_input = (input_thread_t*)p_this;
    VLC_UNUSED(oldval); VLC_UNUSED(p_data);

    if( !strcmp( psz_cmd, ""audio-delay"" ) )
    {
        input_ControlPush( p_input, INPUT_CONTROL_SET_AUDIO_DELAY, &newval );
    }
    else if( !strcmp( psz_cmd, ""spu-delay"" ) )
    {
        input_ControlPush( p_input, INPUT_CONTROL_SET_SPU_DELAY, &newval );
    }
    return VLC_SUCCESS;
}",1,1,input\var.c,EsDelayCallback,,false,799,814,EsDelayCallback,,,44,"int EsDelayCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
79206,METHOD,input\var.c:<global>,TYPE_DECL,"static int BookmarkCallback( vlc_object_t *p_this, char const *psz_cmd,
                             vlc_value_t oldval, vlc_value_t newval,
                             void *p_data )
{
    input_thread_t *p_input = (input_thread_t*)p_this;
    VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval); VLC_UNUSED(p_data);

    input_ControlPush( p_input, INPUT_CONTROL_SET_BOOKMARK, &newval );

    return VLC_SUCCESS;
}",1,1,input\var.c,BookmarkCallback,,false,816,826,BookmarkCallback,,,45,"int BookmarkCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
79234,METHOD,input\var.c:<global>,TYPE_DECL,"static int RecordCallback( vlc_object_t *p_this, char const *psz_cmd,
                           vlc_value_t oldval, vlc_value_t newval,
                           void *p_data )
{
    input_thread_t *p_input = (input_thread_t*)p_this;
    VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval); VLC_UNUSED(p_data);

    input_ControlPush( p_input, INPUT_CONTROL_SET_RECORD_STATE, &newval );

    return VLC_SUCCESS;
}",1,1,input\var.c,RecordCallback,,false,828,838,RecordCallback,,,46,"int RecordCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
79262,METHOD,input\var.c:<global>,TYPE_DECL,"static int FrameNextCallback( vlc_object_t *p_this, char const *psz_cmd,
                              vlc_value_t oldval, vlc_value_t newval,
                              void *p_data )
{
    input_thread_t *p_input = (input_thread_t*)p_this;
    VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval); VLC_UNUSED(p_data);
    VLC_UNUSED(newval);

    input_ControlPush( p_input, INPUT_CONTROL_SET_FRAME_NEXT, NULL );

    return VLC_SUCCESS;
}",1,1,input\var.c,FrameNextCallback,,false,840,851,FrameNextCallback,,,47,"int FrameNextCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
79330,METHOD,input\vlm.c:<global>,TYPE_DECL,<global>,1,24,input\vlm.c,input\vlm.c:<global>,,false,1,1341,<global>,,,1,
79332,METHOD,input\vlm.c:<global>,TYPE_DECL,static void* Manage( void * );,12,29,input\vlm.c,Manage,,false,58,58,Manage,,,1,void* Manage (void*)
79337,METHOD,input\vlm.c:<global>,TYPE_DECL,"static int vlm_MediaVodControl( void *, vod_media_t *, const char *, int, va_list );",12,83,input\vlm.c,vlm_MediaVodControl,,false,59,59,vlm_MediaVodControl,,,2,"int vlm_MediaVodControl (void*,vod_media_t*,char*,int,ANY)"
79350,METHOD,input\vlm.c:<global>,TYPE_DECL,"static int InputEventPreparse( vlc_object_t *p_this, char const *psz_cmd,
                               vlc_value_t oldval, vlc_value_t newval, void *p_data )
{
    VLC_UNUSED(p_this); VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval);
    preparse_data_t *p_pre = p_data;

    if( newval.i_int == INPUT_EVENT_DEAD ||
        ( p_pre->b_mux && newval.i_int == INPUT_EVENT_ITEM_META ) )
        vlc_sem_post( p_pre->p_sem );

    return VLC_SUCCESS;
}",1,1,input\vlm.c,InputEventPreparse,,false,67,78,InputEventPreparse,,,5,"int InputEventPreparse (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
79392,METHOD,input\vlm.c:<global>,TYPE_DECL,"static int InputEvent( vlc_object_t *p_this, char const *psz_cmd,
                       vlc_value_t oldval, vlc_value_t newval,
                       void *p_data )
{
    VLC_UNUSED(psz_cmd);
    VLC_UNUSED(oldval);
    input_thread_t *p_input = (input_thread_t *)p_this;
    vlm_t *p_vlm = libvlc_priv( p_input->obj.libvlc )->p_vlm;
    assert( p_vlm );
    vlm_media_sys_t *p_media = p_data;
    const char *psz_instance_name = NULL;

    if( newval.i_int == INPUT_EVENT_STATE )
    {
        for( int i = 0; i < p_media->i_instance; i++ )
        {
            if( p_media->instance[i]->p_input == p_input )
            {
                psz_instance_name = p_media->instance[i]->psz_name;
                break;
            }
        }
        int state = var_GetInteger(p_input, ""state"");
        vlm_SendEventMediaInstanceState( p_vlm, p_media->cfg.id, p_media->cfg.psz_name, psz_instance_name, state );

        vlc_mutex_lock( &p_vlm->lock_manage );

        if (state == PLAYING_S)
    ...",1,1,input\vlm.c,InputEvent,,false,80,117,InputEvent,,,6,"int InputEvent (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
79547,METHOD,input\vlm.c:<global>,TYPE_DECL,"vlm_t *vlm_New ( vlc_object_t *p_this )
{
    vlm_t *p_vlm = NULL, **pp_vlm = &(libvlc_priv (p_this->obj.libvlc)->p_vlm);
    char *psz_vlmconf;

    /* Avoid multiple creation */
    vlc_mutex_lock( &vlm_mutex );

    p_vlm = *pp_vlm;
    if( p_vlm )
    {   /* VLM already exists */
        if( likely( p_vlm->users < UINT_MAX ) )
            p_vlm->users++;
        else
            p_vlm = NULL;
        vlc_mutex_unlock( &vlm_mutex );
        return p_vlm;
    }

    msg_Dbg( p_this, ""creating VLM"" );

    p_vlm = vlc_custom_create( p_this->obj.libvlc, sizeof( *p_vlm ),
                               ""vlm daemon"" );
    if( !p_vlm )
    {
        vlc_mutex_unlock( &vlm_mutex );
        return NULL;
    }

    vlc_mutex_init( &p_vlm->lock );

    vlc_mutex_init( &p_vlm->lock_delete );
    vlc_cond_init( &p_vlm->wait_delete );

    vlc_mutex_init( &p_vlm->lock_manage );
    vlc_cond_init_daytime( &p_vlm->wait_manage );
    p_vlm->users = 1;
    p_vlm->input_state_changed = false;
   ...",1,12,input\vlm.c,vlm_New,,false,125,207,vlm_New,,,9,vlm_t vlm_New (vlc_object_t*)
79804,METHOD,input\vlm.c:<global>,TYPE_DECL,"void vlm_Delete( vlm_t *p_vlm )
{
    /* vlm_Delete() is serialized against itself, and against vlm_New().
     * This mutex protects libvlc_priv->p_vlm and p_vlm->users. */
    vlc_mutex_lock( &vlm_mutex );
    assert( p_vlm->users > 0 );
    if( --p_vlm->users == 0 )
        assert( libvlc_priv(p_vlm->obj.libvlc)->p_vlm == p_vlm );
    else
        p_vlm = NULL;

    if( p_vlm == NULL )
    {
        vlc_mutex_unlock( &vlm_mutex );
        return;
    }

    vlc_cond_signal(&p_vlm->wait_delete);

    /* Destroy and release VLM */
    vlc_mutex_lock( &p_vlm->lock );
    vlm_ControlInternal( p_vlm, VLM_CLEAR_MEDIAS );
    TAB_CLEAN( p_vlm->i_media, p_vlm->media );

    vlm_ControlInternal( p_vlm, VLM_CLEAR_SCHEDULES );
    TAB_CLEAN( p_vlm->i_schedule, p_vlm->schedule );
    vlc_mutex_unlock( &p_vlm->lock );

    vlc_cancel( p_vlm->thread );

    if( p_vlm->p_vod )
    {
        module_unneed( p_vlm->p_vod, p_vlm->p_vod->p_module );
        vlc_object_release( p_vlm->p_vod );
    }
...",1,1,input\vlm.c,vlm_Delete,,false,212,259,vlm_Delete,,,10,void vlm_Delete (vlm_t*)
79953,METHOD,input\vlm.c:<global>,TYPE_DECL,"int vlm_ExecuteCommand( vlm_t *p_vlm, const char *psz_command,
                        vlm_message_t **pp_message)
{
    int i_result;

    vlc_mutex_lock( &p_vlm->lock );
    i_result = ExecuteCommand( p_vlm, psz_command, pp_message );
    vlc_mutex_unlock( &p_vlm->lock );

    return i_result;
}",1,1,input\vlm.c,vlm_ExecuteCommand,,false,264,274,vlm_ExecuteCommand,,,11,"int vlm_ExecuteCommand (vlm_t*,char*,vlm_message_t**)"
79979,METHOD,input\vlm.c:<global>,TYPE_DECL,"static int vlm_MediaVodControl( void *p_private, vod_media_t *p_vod_media,
                                const char *psz_id, int i_query, va_list args )
{
    vlm_t *vlm = (vlm_t *)p_private;
    int i, i_ret;
    const char *psz;
    int64_t id;

    if( !p_private || !p_vod_media )
        return VLC_EGENERIC;

    vlc_mutex_lock( &vlm->lock );

    /* Find media id */
    for( i = 0, id = -1; i < vlm->i_media; i++ )
    {
        if( p_vod_media == vlm->media[i]->vod.p_media )
        {
            id = vlm->media[i]->cfg.id;
            break;
        }
    }
    if( id == -1 )
    {
        vlc_mutex_unlock( &vlm->lock );
        return VLC_EGENERIC;
    }

    switch( i_query )
    {
    case VOD_MEDIA_PLAY:
    {
        psz = (const char *)va_arg( args, const char * );
        int64_t *i_time = (int64_t *)va_arg( args, int64_t *);
        bool b_retry = false;
        if (*i_time < 0)
        {
            /* No start time requested: return the current NPT */
            i...",1,1,input\vlm.c,vlm_MediaVodControl,,false,279,390,vlm_MediaVodControl,,,12,"int vlm_MediaVodControl (void*,vod_media_t*,char*,int,va_list)"
80271,METHOD,input\vlm.c:<global>,TYPE_DECL,"static void* Manage( void* p_object )
{
    vlm_t *vlm = (vlm_t*)p_object;
    time_t lastcheck, now, nextschedule = 0;

    time(&lastcheck);

    for( ;; )
    {
        char **ppsz_scheduled_commands = NULL;
        int    i_scheduled_commands = 0;
        bool scheduled_command = false;

        vlc_mutex_lock( &vlm->lock_manage );
        mutex_cleanup_push( &vlm->lock_manage );
        while( !vlm->input_state_changed && !scheduled_command )
        {
            if( nextschedule != 0 )
                scheduled_command = vlc_cond_timedwait_daytime( &vlm->wait_manage, &vlm->lock_manage, nextschedule ) != 0;
            else
                vlc_cond_wait( &vlm->wait_manage, &vlm->lock_manage );
        }
        vlm->input_state_changed = false;
        vlc_cleanup_pop( );
        vlc_mutex_unlock( &vlm->lock_manage );

        int canc = vlc_savecancel ();
        /* destroy the inputs that wants to die, and launch the next input */
        vlc_mutex_lock( &vlm->lock );
      ...",1,1,input\vlm.c,Manage,,false,396,531,Manage,,,13,void* Manage (void*)
80769,METHOD,input\vlm.c:<global>,TYPE_DECL,"static vlm_media_sys_t *vlm_ControlMediaGetById( vlm_t *p_vlm, int64_t id )
{
    for( int i = 0; i < p_vlm->i_media; i++ )
    {
        if( p_vlm->media[i]->cfg.id == id )
            return p_vlm->media[i];
    }
    return NULL;
}",1,1,input\vlm.c,vlm_ControlMediaGetById,,false,554,562,vlm_ControlMediaGetById,,,14,"vlm_media_sys_t vlm_ControlMediaGetById (vlm_t*,int64_t)"
80810,METHOD,input\vlm.c:<global>,TYPE_DECL,"static vlm_media_sys_t *vlm_ControlMediaGetByName( vlm_t *p_vlm, const char *psz_name )
{
    for( int i = 0; i < p_vlm->i_media; i++ )
    {
        if( !strcmp( p_vlm->media[i]->cfg.psz_name, psz_name ) )
            return p_vlm->media[i];
    }
    return NULL;
}",1,1,input\vlm.c,vlm_ControlMediaGetByName,,false,563,571,vlm_ControlMediaGetByName,,,15,"vlm_media_sys_t vlm_ControlMediaGetByName (vlm_t*,char*)"
80852,METHOD,input\vlm.c:<global>,TYPE_DECL,"static int vlm_MediaDescriptionCheck( vlm_t *p_vlm, vlm_media_t *p_cfg )
{
    if( !p_cfg || !p_cfg->psz_name ||
        !strcmp( p_cfg->psz_name, ""all"" ) || !strcmp( p_cfg->psz_name, ""media"" ) || !strcmp( p_cfg->psz_name, ""schedule"" ) )
        return VLC_EGENERIC;

    for( int i = 0; i < p_vlm->i_media; i++ )
    {
        if( p_vlm->media[i]->cfg.id == p_cfg->id )
            continue;
        if( !strcmp( p_vlm->media[i]->cfg.psz_name, p_cfg->psz_name ) )
            return VLC_EGENERIC;
    }
    return VLC_SUCCESS;
}",1,1,input\vlm.c,vlm_MediaDescriptionCheck,,false,572,586,vlm_MediaDescriptionCheck,,,16,"int vlm_MediaDescriptionCheck (vlm_t*,vlm_media_t*)"
80940,METHOD,input\vlm.c:<global>,TYPE_DECL,"static int vlm_OnMediaUpdate( vlm_t *p_vlm, vlm_media_sys_t *p_media )
{
    vlm_media_t *p_cfg = &p_media->cfg;
    /* Check if we need to create/delete a vod media */
    if( p_cfg->b_vod && p_vlm->p_vod )
    {
        if( !p_cfg->b_enabled && p_media->vod.p_media )
        {
            p_vlm->p_vod->pf_media_del( p_vlm->p_vod, p_media->vod.p_media );
            p_media->vod.p_media = NULL;
        }
        else if( p_cfg->b_enabled && !p_media->vod.p_media && p_cfg->i_input )
        {
            /* Pre-parse the input */
            input_thread_t *p_input;
            char *psz_output;
            char *psz_header;
            char *psz_dup;

            input_item_Release( p_media->vod.p_item );

            if( strstr( p_cfg->ppsz_input[0], ""://"" ) == NULL )
            {
                char *psz_uri = vlc_path2uri( p_cfg->ppsz_input[0], NULL );
                p_media->vod.p_item = input_item_New( psz_uri,
                                                      p_cfg->ps...",1,1,input\vlm.c,vlm_OnMediaUpdate,,false,590,723,vlm_OnMediaUpdate,,,17,"int vlm_OnMediaUpdate (vlm_t*,vlm_media_sys_t*)"
81431,METHOD,input\vlm.c:<global>,TYPE_DECL,"static int vlm_ControlMediaChange( vlm_t *p_vlm, vlm_media_t *p_cfg )
{
    vlm_media_sys_t *p_media = vlm_ControlMediaGetById( p_vlm, p_cfg->id );

    /* */
    if( !p_media || vlm_MediaDescriptionCheck( p_vlm, p_cfg ) )
        return VLC_EGENERIC;
    if( ( p_media->cfg.b_vod && !p_cfg->b_vod ) || ( !p_media->cfg.b_vod && p_cfg->b_vod ) )
        return VLC_EGENERIC;

    if( 0 )
    {
        /* TODO check what are the changes being done (stop instance if needed) */
    }

    vlm_media_Clean( &p_media->cfg );
    vlm_media_Copy( &p_media->cfg, p_cfg );

    return vlm_OnMediaUpdate( p_vlm, p_media );
}",1,1,input\vlm.c,vlm_ControlMediaChange,,false,724,743,vlm_ControlMediaChange,,,18,"int vlm_ControlMediaChange (vlm_t*,vlm_media_t*)"
81498,METHOD,input\vlm.c:<global>,TYPE_DECL,"static int vlm_ControlMediaAdd( vlm_t *p_vlm, vlm_media_t *p_cfg, int64_t *p_id )
{
    vlm_media_sys_t *p_media;

    if( vlm_MediaDescriptionCheck( p_vlm, p_cfg ) || vlm_ControlMediaGetByName( p_vlm, p_cfg->psz_name ) )
    {
        msg_Err( p_vlm, ""invalid media description"" );
        return VLC_EGENERIC;
    }
    /* Check if we need to load the VOD server */
    if( p_cfg->b_vod && !p_vlm->p_vod )
    {
        msg_Info( p_vlm, ""VoD support will be removed from the VLM in the next major version of VLC."" );

        p_vlm->p_vod = vlc_custom_create( VLC_OBJECT(p_vlm), sizeof( vod_t ),
                                          ""vod server"" );
        p_vlm->p_vod->p_module = module_need( p_vlm->p_vod, ""vod server"", ""$vod-server"", false );
        if( !p_vlm->p_vod->p_module )
        {
            msg_Err( p_vlm, ""cannot find vod server"" );
            vlc_object_release( p_vlm->p_vod );
            p_vlm->p_vod = NULL;
            return VLC_EGENERIC;
        }

        p_vlm-...",1,23,input\vlm.c,vlm_ControlMediaAdd,,false,745,796,vlm_ControlMediaAdd,,,19,"int vlm_ControlMediaAdd (vlm_t*,vlm_media_t*,int64_t*)"
81685,METHOD,input\vlm.c:<global>,TYPE_DECL,"static int vlm_ControlMediaDel( vlm_t *p_vlm, int64_t id )
{
    vlm_media_sys_t *p_media = vlm_ControlMediaGetById( p_vlm, id );

    if( !p_media )
        return VLC_EGENERIC;

    while( p_media->i_instance > 0 )
        vlm_ControlInternal( p_vlm, VLM_STOP_MEDIA_INSTANCE, id, p_media->instance[0]->psz_name );

    if( p_media->cfg.b_vod )
    {
        p_media->cfg.b_enabled = false;
        vlm_OnMediaUpdate( p_vlm, p_media );
    }

    /* */
    vlm_SendEventMediaRemoved( p_vlm, id, p_media->cfg.psz_name );

    vlm_media_Clean( &p_media->cfg );

    input_item_Release( p_media->vod.p_item );

    if( p_media->vod.p_media )
        p_vlm->p_vod->pf_media_del( p_vlm->p_vod, p_media->vod.p_media );

    TAB_REMOVE( p_vlm->i_media, p_vlm->media, p_media );
    free( p_media );

    return VLC_SUCCESS;
}",1,1,input\vlm.c,vlm_ControlMediaDel,,false,798,828,vlm_ControlMediaDel,,,20,"int vlm_ControlMediaDel (vlm_t*,int64_t)"
81789,METHOD,input\vlm.c:<global>,TYPE_DECL,"static int vlm_ControlMediaGets( vlm_t *p_vlm, vlm_media_t ***ppp_dsc, int *pi_dsc )
{
    vlm_media_t **pp_dsc;
    int                     i_dsc;

    TAB_INIT( i_dsc, pp_dsc );
    for( int i = 0; i < p_vlm->i_media; i++ )
    {
        vlm_media_t *p_dsc = vlm_media_Duplicate( &p_vlm->media[i]->cfg );
        TAB_APPEND( i_dsc, pp_dsc, p_dsc );
    }

    *ppp_dsc = pp_dsc;
    *pi_dsc = i_dsc;

    return VLC_SUCCESS;
}",1,1,input\vlm.c,vlm_ControlMediaGets,,false,830,846,vlm_ControlMediaGets,,,21,"int vlm_ControlMediaGets (vlm_t*,vlm_media_t***,int*)"
81841,METHOD,input\vlm.c:<global>,TYPE_DECL,"static int vlm_ControlMediaClear( vlm_t *p_vlm )
{
    while( p_vlm->i_media > 0 )
        vlm_ControlMediaDel( p_vlm, p_vlm->media[0]->cfg.id );

    return VLC_SUCCESS;
}",1,1,input\vlm.c,vlm_ControlMediaClear,,false,847,853,vlm_ControlMediaClear,,,22,int vlm_ControlMediaClear (vlm_t*)
81865,METHOD,input\vlm.c:<global>,TYPE_DECL,"static int vlm_ControlMediaGet( vlm_t *p_vlm, int64_t id, vlm_media_t **pp_dsc )
{
    vlm_media_sys_t *p_media = vlm_ControlMediaGetById( p_vlm, id );
    if( !p_media )
        return VLC_EGENERIC;

    *pp_dsc = vlm_media_Duplicate( &p_media->cfg );
    return VLC_SUCCESS;
}",1,1,input\vlm.c,vlm_ControlMediaGet,,false,854,862,vlm_ControlMediaGet,,,23,"int vlm_ControlMediaGet (vlm_t*,int64_t,vlm_media_t**)"
81894,METHOD,input\vlm.c:<global>,TYPE_DECL,"static int vlm_ControlMediaGetId( vlm_t *p_vlm, const char *psz_name, int64_t *p_id )
{
    vlm_media_sys_t *p_media = vlm_ControlMediaGetByName( p_vlm, psz_name );
    if( !p_media )
        return VLC_EGENERIC;

    *p_id = p_media->cfg.id;
    return VLC_SUCCESS;
}",1,1,input\vlm.c,vlm_ControlMediaGetId,,false,863,871,vlm_ControlMediaGetId,,,24,"int vlm_ControlMediaGetId (vlm_t*,char*,int64_t*)"
81923,METHOD,input\vlm.c:<global>,TYPE_DECL,"static vlm_media_instance_sys_t *vlm_ControlMediaInstanceGetByName( vlm_media_sys_t *p_media, const char *psz_id )
{
    for( int i = 0; i < p_media->i_instance; i++ )
    {
        const char *psz = p_media->instance[i]->psz_name;
        if( ( psz == NULL && psz_id == NULL ) ||
            ( psz && psz_id && !strcmp( psz, psz_id ) ) )
            return p_media->instance[i];
    }
    return NULL;
}",1,1,input\vlm.c,vlm_ControlMediaInstanceGetByName,,false,873,883,vlm_ControlMediaInstanceGetByName,,,25,"vlm_media_instance_sys_t vlm_ControlMediaInstanceGetByName (vlm_media_sys_t*,char*)"
81979,METHOD,input\vlm.c:<global>,TYPE_DECL,"static vlm_media_instance_sys_t *vlm_MediaInstanceNew( vlm_t *p_vlm, const char *psz_name )
{
    vlm_media_instance_sys_t *p_instance = calloc( 1, sizeof(vlm_media_instance_sys_t) );
    if( !p_instance )
        return NULL;

    p_instance->psz_name = NULL;
    if( psz_name )
        p_instance->psz_name = strdup( psz_name );

    p_instance->p_item = input_item_New( NULL, NULL );

    p_instance->i_index = 0;
    p_instance->b_sout_keep = false;
    p_instance->p_parent = vlc_object_create( p_vlm, sizeof (vlc_object_t) );
    p_instance->p_input = NULL;
    p_instance->p_input_resource = input_resource_New( p_instance->p_parent );

    return p_instance;
}",1,1,input\vlm.c,vlm_MediaInstanceNew,,false,884,903,vlm_MediaInstanceNew,,,26,"vlm_media_instance_sys_t vlm_MediaInstanceNew (vlm_t*,char*)"
82052,METHOD,input\vlm.c:<global>,TYPE_DECL,"static void vlm_MediaInstanceDelete( vlm_t *p_vlm, int64_t id, vlm_media_instance_sys_t *p_instance, vlm_media_sys_t *p_media )
{
    input_thread_t *p_input = p_instance->p_input;
    if( p_input )
    {
        input_Stop( p_input );
        input_Close( p_input );

        vlm_SendEventMediaInstanceStopped( p_vlm, id, p_media->cfg.psz_name );
    }
    input_resource_Terminate( p_instance->p_input_resource );
    input_resource_Release( p_instance->p_input_resource );
    vlc_object_release( p_instance->p_parent );

    TAB_REMOVE( p_media->i_instance, p_media->instance, p_instance );
    input_item_Release( p_instance->p_item );
    free( p_instance->psz_name );
    free( p_instance );
}",1,1,input\vlm.c,vlm_MediaInstanceDelete,,false,904,922,vlm_MediaInstanceDelete,,,27,"void vlm_MediaInstanceDelete (vlm_t*,int64_t,vlm_media_instance_sys_t*,vlm_media_sys_t*)"
82111,METHOD,input\vlm.c:<global>,TYPE_DECL,"static int vlm_ControlMediaInstanceStart( vlm_t *p_vlm, int64_t id, const char *psz_id, int i_input_index, const char *psz_vod_output )
{
    vlm_media_sys_t *p_media = vlm_ControlMediaGetById( p_vlm, id );
    vlm_media_instance_sys_t *p_instance;
    char *psz_log;

    if( !p_media || !p_media->cfg.b_enabled || p_media->cfg.i_input <= 0 )
        return VLC_EGENERIC;

    /* TODO support multiple input for VOD with sout-keep ? */

    if( ( p_media->cfg.b_vod && !psz_vod_output ) || ( !p_media->cfg.b_vod && psz_vod_output ) )
        return VLC_EGENERIC;

    if( i_input_index < 0 || i_input_index >= p_media->cfg.i_input )
        return VLC_EGENERIC;

    p_instance = vlm_ControlMediaInstanceGetByName( p_media, psz_id );
    if( !p_instance )
    {
        vlm_media_t *p_cfg = &p_media->cfg;

        p_instance = vlm_MediaInstanceNew( p_vlm, psz_id );
        if( !p_instance )
            return VLC_ENOMEM;

        if ( p_cfg->b_vod )
        {
            var_Create( p_instanc...",1,1,input\vlm.c,vlm_ControlMediaInstanceStart,,false,925,1062,vlm_ControlMediaInstanceStart,,,28,"int vlm_ControlMediaInstanceStart (vlm_t*,int64_t,char*,int,char*)"
82630,METHOD,input\vlm.c:<global>,TYPE_DECL,"static int vlm_ControlMediaInstanceStop( vlm_t *p_vlm, int64_t id, const char *psz_id )
{
    vlm_media_sys_t *p_media = vlm_ControlMediaGetById( p_vlm, id );
    vlm_media_instance_sys_t *p_instance;

    if( !p_media )
        return VLC_EGENERIC;

    p_instance = vlm_ControlMediaInstanceGetByName( p_media, psz_id );
    if( !p_instance )
        return VLC_EGENERIC;

    vlm_MediaInstanceDelete( p_vlm, id, p_instance, p_media );

    return VLC_SUCCESS;
}",1,1,input\vlm.c,vlm_ControlMediaInstanceStop,,false,1064,1079,vlm_ControlMediaInstanceStop,,,29,"int vlm_ControlMediaInstanceStop (vlm_t*,int64_t,char*)"
82668,METHOD,input\vlm.c:<global>,TYPE_DECL,"static int vlm_ControlMediaInstancePause( vlm_t *p_vlm, int64_t id, const char *psz_id )
{
    vlm_media_sys_t *p_media = vlm_ControlMediaGetById( p_vlm, id );
    vlm_media_instance_sys_t *p_instance;
    int i_state;

    if( !p_media )
        return VLC_EGENERIC;

    p_instance = vlm_ControlMediaInstanceGetByName( p_media, psz_id );
    if( !p_instance || !p_instance->p_input )
        return VLC_EGENERIC;

    /* Toggle pause state */
    i_state = var_GetInteger( p_instance->p_input, ""state"" );
    if( i_state == PAUSE_S && !p_media->cfg.b_vod )
        var_SetInteger( p_instance->p_input, ""state"", PLAYING_S );
    else if( i_state == PLAYING_S )
        var_SetInteger( p_instance->p_input, ""state"", PAUSE_S );
    return VLC_SUCCESS;
}",1,1,input\vlm.c,vlm_ControlMediaInstancePause,,false,1080,1100,vlm_ControlMediaInstancePause,,,30,"int vlm_ControlMediaInstancePause (vlm_t*,int64_t,char*)"
82745,METHOD,input\vlm.c:<global>,TYPE_DECL,"static int vlm_ControlMediaInstanceGetTimePosition( vlm_t *p_vlm, int64_t id, const char *psz_id, int64_t *pi_time, double *pd_position )
{
    vlm_media_sys_t *p_media = vlm_ControlMediaGetById( p_vlm, id );
    vlm_media_instance_sys_t *p_instance;

    if( !p_media )
        return VLC_EGENERIC;

    p_instance = vlm_ControlMediaInstanceGetByName( p_media, psz_id );
    if( !p_instance || !p_instance->p_input )
        return VLC_EGENERIC;

    if( pi_time )
        *pi_time = var_GetInteger( p_instance->p_input, ""time"" );
    if( pd_position )
        *pd_position = var_GetFloat( p_instance->p_input, ""position"" );
    return VLC_SUCCESS;
}",1,1,input\vlm.c,vlm_ControlMediaInstanceGetTimePosition,,false,1101,1118,vlm_ControlMediaInstanceGetTimePosition,,,31,"int vlm_ControlMediaInstanceGetTimePosition (vlm_t*,int64_t,char*,int64_t*,double*)"
82807,METHOD,input\vlm.c:<global>,TYPE_DECL,"static int vlm_ControlMediaInstanceSetTimePosition( vlm_t *p_vlm, int64_t id, const char *psz_id, int64_t i_time, double d_position )
{
    vlm_media_sys_t *p_media = vlm_ControlMediaGetById( p_vlm, id );
    vlm_media_instance_sys_t *p_instance;

    if( !p_media )
        return VLC_EGENERIC;

    p_instance = vlm_ControlMediaInstanceGetByName( p_media, psz_id );
    if( !p_instance || !p_instance->p_input )
        return VLC_EGENERIC;

    if( i_time >= 0 )
        return var_SetInteger( p_instance->p_input, ""time"", i_time );
    else if( d_position >= 0 && d_position <= 100 )
        return var_SetFloat( p_instance->p_input, ""position"", d_position );
    return VLC_EGENERIC;
}",1,1,input\vlm.c,vlm_ControlMediaInstanceSetTimePosition,,false,1119,1136,vlm_ControlMediaInstanceSetTimePosition,,,32,"int vlm_ControlMediaInstanceSetTimePosition (vlm_t*,int64_t,char*,int64_t,double)"
82877,METHOD,input\vlm.c:<global>,TYPE_DECL,"static int vlm_ControlMediaInstanceGets( vlm_t *p_vlm, int64_t id, vlm_media_instance_t ***ppp_idsc, int *pi_instance )
{
    vlm_media_sys_t *p_media = vlm_ControlMediaGetById( p_vlm, id );
    vlm_media_instance_t **pp_idsc;
    int                              i_idsc;

    if( !p_media )
        return VLC_EGENERIC;

    TAB_INIT( i_idsc, pp_idsc );
    for( int i = 0; i < p_media->i_instance; i++ )
    {
        vlm_media_instance_sys_t *p_instance = p_media->instance[i];
        vlm_media_instance_t *p_idsc = vlm_media_instance_New();

        if( p_instance->psz_name )
            p_idsc->psz_name = strdup( p_instance->psz_name );
        if( p_instance->p_input )
        {
            p_idsc->i_time = var_GetInteger( p_instance->p_input, ""time"" );
            p_idsc->i_length = var_GetInteger( p_instance->p_input, ""length"" );
            p_idsc->d_position = var_GetFloat( p_instance->p_input, ""position"" );
            if( var_GetInteger( p_instance->p_input, ""state"" ) == PAUS...",1,1,input\vlm.c,vlm_ControlMediaInstanceGets,,false,1138,1171,vlm_ControlMediaInstanceGets,,,33,"int vlm_ControlMediaInstanceGets (vlm_t*,int64_t,vlm_media_instance_t***,int*)"
83012,METHOD,input\vlm.c:<global>,TYPE_DECL,"static int vlm_ControlMediaInstanceClear( vlm_t *p_vlm, int64_t id )
{
    vlm_media_sys_t *p_media = vlm_ControlMediaGetById( p_vlm, id );

    if( !p_media )
        return VLC_EGENERIC;

    while( p_media->i_instance > 0 )
        vlm_ControlMediaInstanceStop( p_vlm, id, p_media->instance[0]->psz_name );

    return VLC_SUCCESS;
}",1,1,input\vlm.c,vlm_ControlMediaInstanceClear,,false,1173,1184,vlm_ControlMediaInstanceClear,,,34,"int vlm_ControlMediaInstanceClear (vlm_t*,int64_t)"
83048,METHOD,input\vlm.c:<global>,TYPE_DECL,"static int vlm_ControlScheduleClear( vlm_t *p_vlm )
{
    while( p_vlm->i_schedule > 0 )
        vlm_ScheduleDelete( p_vlm, p_vlm->schedule[0] );

    return VLC_SUCCESS;
}",1,1,input\vlm.c,vlm_ControlScheduleClear,,false,1186,1192,vlm_ControlScheduleClear,,,35,int vlm_ControlScheduleClear (vlm_t*)
83068,METHOD,input\vlm.c:<global>,TYPE_DECL,"static int vlm_vaControlInternal( vlm_t *p_vlm, int i_query, va_list args )
{
    vlm_media_t *p_dsc;
    vlm_media_t **pp_dsc;
    vlm_media_t ***ppp_dsc;
    vlm_media_instance_t ***ppp_idsc;
    const char *psz_id;
    const char *psz_vod;
    int64_t *p_id;
    int64_t id;
    int i_int;
    int *pi_int;

    int64_t *pi_i64;
    int64_t i_i64;
    double *pd_double;
    double d_double;

    switch( i_query )
    {
    /* Media control */
    case VLM_GET_MEDIAS:
        ppp_dsc = (vlm_media_t ***)va_arg( args, vlm_media_t *** );
        pi_int = (int *)va_arg( args, int * );
        return vlm_ControlMediaGets( p_vlm, ppp_dsc, pi_int );

    case VLM_CLEAR_MEDIAS:
        return vlm_ControlMediaClear( p_vlm );

    case VLM_CHANGE_MEDIA:
        p_dsc = (vlm_media_t*)va_arg( args, vlm_media_t * );
        return vlm_ControlMediaChange( p_vlm, p_dsc );

    case VLM_ADD_MEDIA:
        p_dsc = (vlm_media_t*)va_arg( args, vlm_media_t * );
        p_id = (int64_t*)va_arg( args, in...",1,1,input\vlm.c,vlm_vaControlInternal,,false,1194,1313,vlm_vaControlInternal,,,36,"int vlm_vaControlInternal (vlm_t*,int,va_list)"
83353,METHOD,input\vlm.c:<global>,TYPE_DECL,"int vlm_ControlInternal( vlm_t *p_vlm, int i_query, ... )
{
    va_list args;
    int     i_result;

    va_start( args, i_query );
    i_result = vlm_vaControlInternal( p_vlm, i_query, args );
    va_end( args );

    return i_result;
}",1,1,input\vlm.c,vlm_ControlInternal,,false,1315,1325,vlm_ControlInternal,,,37,"int vlm_ControlInternal (vlm_t*,int...)"
83374,METHOD,input\vlm.c:<global>,TYPE_DECL,"int vlm_Control( vlm_t *p_vlm, int i_query, ... )
{
    va_list args;
    int     i_result;

    va_start( args, i_query );

    vlc_mutex_lock( &p_vlm->lock );
    i_result = vlm_vaControlInternal( p_vlm, i_query, args );
    vlc_mutex_unlock( &p_vlm->lock );

    va_end( args );

    return i_result;
}",1,1,input\vlm.c,vlm_Control,,false,1327,1341,vlm_Control,,,38,"int vlm_Control (vlm_t*,int...)"
83420,METHOD,input\vlm_event.c:<global>,TYPE_DECL,<global>,1,21,input\vlm_event.c,input\vlm_event.c:<global>,,false,1,96,<global>,,,1,
83422,METHOD,input\vlm_event.c:<global>,TYPE_DECL,"static void Trigger( vlm_t *, int i_type, int64_t id, const char *psz_name );",13,76,input\vlm_event.c,Trigger,,false,38,38,Trigger,,,1,"void Trigger (vlm_t*,int,int64_t,char*)"
83430,METHOD,input\vlm_event.c:<global>,TYPE_DECL,"static void TriggerInstanceState( vlm_t *, int i_type, int64_t id, const char *psz_name, const char *psz_instance_name, input_state_e input_state );",13,147,input\vlm_event.c,TriggerInstanceState,,false,39,39,TriggerInstanceState,,,2,"void TriggerInstanceState (vlm_t*,int,int64_t,char*,char*,input_state_e)"
83440,METHOD,input\vlm_event.c:<global>,TYPE_DECL,"void vlm_SendEventMediaAdded( vlm_t *p_vlm, int64_t id, const char *psz_name )
{
    Trigger( p_vlm, VLM_EVENT_MEDIA_ADDED, id, psz_name );
}",1,1,input\vlm_event.c,vlm_SendEventMediaAdded,,false,44,47,vlm_SendEventMediaAdded,,,3,"void vlm_SendEventMediaAdded (vlm_t*,int64_t,char*)"
83452,METHOD,input\vlm_event.c:<global>,TYPE_DECL,"void vlm_SendEventMediaRemoved( vlm_t *p_vlm, int64_t id, const char *psz_name )
{
    Trigger( p_vlm, VLM_EVENT_MEDIA_REMOVED, id, psz_name );
}",1,1,input\vlm_event.c,vlm_SendEventMediaRemoved,,false,48,51,vlm_SendEventMediaRemoved,,,4,"void vlm_SendEventMediaRemoved (vlm_t*,int64_t,char*)"
83464,METHOD,input\vlm_event.c:<global>,TYPE_DECL,"void vlm_SendEventMediaChanged( vlm_t *p_vlm, int64_t id, const char *psz_name )
{
    Trigger( p_vlm, VLM_EVENT_MEDIA_CHANGED, id, psz_name );
}",1,1,input\vlm_event.c,vlm_SendEventMediaChanged,,false,52,55,vlm_SendEventMediaChanged,,,5,"void vlm_SendEventMediaChanged (vlm_t*,int64_t,char*)"
83476,METHOD,input\vlm_event.c:<global>,TYPE_DECL,"void vlm_SendEventMediaInstanceStarted( vlm_t *p_vlm, int64_t id, const char *psz_name )
{
    Trigger( p_vlm, VLM_EVENT_MEDIA_INSTANCE_STARTED, id, psz_name );
}",1,1,input\vlm_event.c,vlm_SendEventMediaInstanceStarted,,false,57,60,vlm_SendEventMediaInstanceStarted,,,6,"void vlm_SendEventMediaInstanceStarted (vlm_t*,int64_t,char*)"
83488,METHOD,input\vlm_event.c:<global>,TYPE_DECL,"void vlm_SendEventMediaInstanceStopped( vlm_t *p_vlm, int64_t id, const char *psz_name )
{
    Trigger( p_vlm, VLM_EVENT_MEDIA_INSTANCE_STOPPED, id, psz_name );
}",1,1,input\vlm_event.c,vlm_SendEventMediaInstanceStopped,,false,61,64,vlm_SendEventMediaInstanceStopped,,,7,"void vlm_SendEventMediaInstanceStopped (vlm_t*,int64_t,char*)"
83500,METHOD,input\vlm_event.c:<global>,TYPE_DECL,"void vlm_SendEventMediaInstanceState( vlm_t *p_vlm, int64_t id, const char *psz_name, const char *psz_instance_name, input_state_e state )
{
    TriggerInstanceState( p_vlm, VLM_EVENT_MEDIA_INSTANCE_STATE, id, psz_name, psz_instance_name, state );
}",1,1,input\vlm_event.c,vlm_SendEventMediaInstanceState,,false,66,69,vlm_SendEventMediaInstanceState,,,8,"void vlm_SendEventMediaInstanceState (vlm_t*,int64_t,char*,char*,input_state_e)"
83516,METHOD,input\vlm_event.c:<global>,TYPE_DECL,"static void Trigger( vlm_t *p_vlm, int i_type, int64_t id, const char *psz_name )
{
    vlm_event_t event;

    event.i_type = i_type;
    event.id = id;
    event.psz_name = psz_name;
    event.input_state = 0;
    event.psz_instance_name = NULL;
    var_SetAddress( p_vlm, ""intf-event"", &event );
}",1,1,input\vlm_event.c,Trigger,,false,74,84,Trigger,,,9,"void Trigger (vlm_t*,int,int64_t,char*)"
83555,METHOD,input\vlm_event.c:<global>,TYPE_DECL,"static void TriggerInstanceState( vlm_t *p_vlm, int i_type, int64_t id, const char *psz_name, const char *psz_instance_name, input_state_e input_state )
{
    vlm_event_t event;

    event.i_type = i_type;
    event.id = id;
    event.psz_name = psz_name;
    event.input_state = input_state;
    event.psz_instance_name = psz_instance_name;
    var_SetAddress( p_vlm, ""intf-event"", &event );
}",1,1,input\vlm_event.c,TriggerInstanceState,,false,86,96,TriggerInstanceState,,,10,"void TriggerInstanceState (vlm_t*,int,int64_t,char*,char*,input_state_e)"
83601,METHOD,input\vlm_event.h:<global>,TYPE_DECL,<global>,1,6,input\vlm_event.h,input\vlm_event.h:<global>,,false,1,40,<global>,,,1,
83603,METHOD,input\vlm_event.h:<global>,TYPE_DECL,"void vlm_SendEventMediaAdded( vlm_t *, int64_t id, const char *psz_name );",6,73,input\vlm_event.h,vlm_SendEventMediaAdded,,false,32,32,vlm_SendEventMediaAdded,,,1,"void vlm_SendEventMediaAdded (vlm_t*,int64_t,char*)"
83610,METHOD,input\vlm_event.h:<global>,TYPE_DECL,"void vlm_SendEventMediaRemoved( vlm_t *, int64_t id, const char *psz_name );",6,75,input\vlm_event.h,vlm_SendEventMediaRemoved,,false,33,33,vlm_SendEventMediaRemoved,,,2,"void vlm_SendEventMediaRemoved (vlm_t*,int64_t,char*)"
83617,METHOD,input\vlm_event.h:<global>,TYPE_DECL,"void vlm_SendEventMediaChanged( vlm_t *, int64_t id, const char *psz_name );",6,75,input\vlm_event.h,vlm_SendEventMediaChanged,,false,34,34,vlm_SendEventMediaChanged,,,3,"void vlm_SendEventMediaChanged (vlm_t*,int64_t,char*)"
83624,METHOD,input\vlm_event.h:<global>,TYPE_DECL,"void vlm_SendEventMediaInstanceStarted( vlm_t *, int64_t id, const char *psz_name );",6,83,input\vlm_event.h,vlm_SendEventMediaInstanceStarted,,false,36,36,vlm_SendEventMediaInstanceStarted,,,4,"void vlm_SendEventMediaInstanceStarted (vlm_t*,int64_t,char*)"
83631,METHOD,input\vlm_event.h:<global>,TYPE_DECL,"void vlm_SendEventMediaInstanceStopped( vlm_t *, int64_t id, const char *psz_name );",6,83,input\vlm_event.h,vlm_SendEventMediaInstanceStopped,,false,37,37,vlm_SendEventMediaInstanceStopped,,,5,"void vlm_SendEventMediaInstanceStopped (vlm_t*,int64_t,char*)"
83638,METHOD,input\vlm_event.h:<global>,TYPE_DECL,"void vlm_SendEventMediaInstanceState( vlm_t *, int64_t id, const char *psz_name, const char *psz_instance_name, input_state_e state );",6,133,input\vlm_event.h,vlm_SendEventMediaInstanceState,,false,38,38,vlm_SendEventMediaInstanceState,,,6,"void vlm_SendEventMediaInstanceState (vlm_t*,int64_t,char*,char*,input_state_e)"
83654,METHOD,input\vlm_internal.h:<global>,TYPE_DECL,<global>,1,21,input\vlm_internal.h,input\vlm_internal.h:<global>,,false,1,122,<global>,,,1,
83701,METHOD,input\vlm_internal.h:<global>,TYPE_DECL,"int vlm_ControlInternal( vlm_t *p_vlm, int i_query, ... );",5,57,input\vlm_internal.h,vlm_ControlInternal,,false,118,118,vlm_ControlInternal,,,8,"int vlm_ControlInternal (vlm_t*,int...)"
83707,METHOD,input\vlm_internal.h:<global>,TYPE_DECL,"int ExecuteCommand( vlm_t *, const char *, vlm_message_t ** );",5,61,input\vlm_internal.h,ExecuteCommand,,false,119,119,ExecuteCommand,,,9,"int ExecuteCommand (vlm_t*,char*,vlm_message_t**)"
83714,METHOD,input\vlm_internal.h:<global>,TYPE_DECL,"void vlm_ScheduleDelete( vlm_t *vlm, vlm_schedule_sys_t *sched );",6,64,input\vlm_internal.h,vlm_ScheduleDelete,,false,120,120,vlm_ScheduleDelete,,,10,"void vlm_ScheduleDelete (vlm_t*,vlm_schedule_sys_t*)"
83763,METHOD,input\vlmshell.c:<global>,TYPE_DECL,<global>,1,23,input\vlmshell.c,input\vlmshell.c:<global>,,false,1,1690,<global>,,,1,
83784,METHOD,interface\dialog.c:<global>,TYPE_DECL,<global>,1,20,interface\dialog.c,interface\dialog.c:<global>,,false,1,852,<global>,,,1,
83849,METHOD,interface\dialog.c:<global>,TYPE_DECL,"static inline vlc_dialog_provider *
get_dialog_provider(vlc_object_t *p_obj, bool b_check_interact)
{
    if (b_check_interact && p_obj->obj.flags & OBJECT_FLAGS_NOINTERACT)
        return NULL;

    vlc_dialog_provider *p_provider =
        libvlc_priv(p_obj->obj.libvlc)->p_dialog_provider;
    assert(p_provider != NULL);
    return p_provider;
}",1,1,interface\dialog.c,get_dialog_provider,,false,122,132,get_dialog_provider,,,7,"vlc_dialog_provider get_dialog_provider (vlc_object_t*,bool)"
83885,METHOD,interface\dialog.c:<global>,TYPE_DECL,"static void
dialog_id_release(vlc_dialog_id *p_id)
{
    if (p_id->answer.i_type == VLC_DIALOG_LOGIN)
    {
        free(p_id->answer.u.login.psz_username);
        free(p_id->answer.u.login.psz_password);
    }
    free(p_id->psz_progress_text);
    vlc_mutex_destroy(&p_id->lock);
    vlc_cond_destroy(&p_id->wait);
    free(p_id);
}",1,1,interface\dialog.c,dialog_id_release,,false,134,146,dialog_id_release,,,8,void dialog_id_release (vlc_dialog_id*)
83935,METHOD,interface\dialog.c:<global>,TYPE_DECL,"int
libvlc_InternalDialogInit(libvlc_int_t *p_libvlc)
{
    assert(p_libvlc != NULL);
    vlc_dialog_provider *p_provider = malloc(sizeof(*p_provider));
    if (p_provider == NULL)
        return VLC_EGENERIC;

    vlc_mutex_init(&p_provider->lock);
    vlc_array_init(&p_provider->dialog_array);

    memset(&p_provider->cbs, 0, sizeof(p_provider->cbs));
    p_provider->p_cbs_data = NULL;

    p_provider->pf_ext_update = NULL;
    p_provider->p_ext_data = NULL;
    libvlc_priv(p_libvlc)->p_dialog_provider = p_provider;

    return VLC_SUCCESS;
}",1,1,interface\dialog.c,libvlc_InternalDialogInit,,false,148,167,libvlc_InternalDialogInit,,,9,int libvlc_InternalDialogInit (libvlc_int_t*)
84001,METHOD,interface\dialog.c:<global>,TYPE_DECL,"static void
dialog_cancel_locked(vlc_dialog_provider *p_provider, vlc_dialog_id *p_id)
{
    vlc_mutex_lock(&p_id->lock);
    if (p_id->b_cancelled || p_id->b_answered)
    {
        vlc_mutex_unlock(&p_id->lock);
        return;
    }
    p_id->b_cancelled = true;
    vlc_mutex_unlock(&p_id->lock);

    p_provider->cbs.pf_cancel(p_provider->p_cbs_data, p_id);
}",1,1,interface\dialog.c,dialog_cancel_locked,,false,169,182,dialog_cancel_locked,,,10,"void dialog_cancel_locked (vlc_dialog_provider*,vlc_dialog_id*)"
84047,METHOD,interface\dialog.c:<global>,TYPE_DECL,"static vlc_dialog_id *
dialog_add_locked(vlc_dialog_provider *p_provider, enum dialog_type i_type)
{
    vlc_dialog_id *p_id = calloc(1, sizeof(*p_id));

    if (p_id == NULL)
        return NULL;

    if(vlc_array_append(&p_provider->dialog_array, p_id))
    {
        free(p_id);
        return NULL;
    }

    vlc_mutex_init(&p_id->lock);
    vlc_cond_init(&p_id->wait);

    p_id->i_type = i_type;
    p_id->i_refcount = 2; /* provider and callbacks */

    return p_id;
}",1,1,interface\dialog.c,dialog_add_locked,,false,184,205,dialog_add_locked,,,11,"vlc_dialog_id dialog_add_locked (vlc_dialog_provider*,dialog_type)"
84102,METHOD,interface\dialog.c:<global>,TYPE_DECL,"static void
dialog_remove_locked(vlc_dialog_provider *p_provider, vlc_dialog_id *p_id)
{
    ssize_t i_idx = vlc_array_index_of_item(&p_provider->dialog_array, p_id);
    assert(i_idx >= 0);
    vlc_array_remove(&p_provider->dialog_array, i_idx);

    vlc_mutex_lock(&p_id->lock);
    p_id->i_refcount--;
    if (p_id->i_refcount == 0)
    {
        vlc_mutex_unlock(&p_id->lock);
        dialog_id_release(p_id);
    }
    else
        vlc_mutex_unlock(&p_id->lock);
}",1,1,interface\dialog.c,dialog_remove_locked,,false,207,223,dialog_remove_locked,,,12,"void dialog_remove_locked (vlc_dialog_provider*,vlc_dialog_id*)"
84157,METHOD,interface\dialog.c:<global>,TYPE_DECL,"static void
dialog_clear_all_locked(vlc_dialog_provider *p_provider)
{
    for (size_t i = 0; i < vlc_array_count(&p_provider->dialog_array); ++i)
    {
        vlc_dialog_id *p_id =
            vlc_array_item_at_index(&p_provider->dialog_array, i);
        dialog_cancel_locked(p_provider, p_id);
    }
}",1,1,interface\dialog.c,dialog_clear_all_locked,,false,225,234,dialog_clear_all_locked,,,13,void dialog_clear_all_locked (vlc_dialog_provider*)
84190,METHOD,interface\dialog.c:<global>,TYPE_DECL,"void
libvlc_InternalDialogClean(libvlc_int_t *p_libvlc)
{
    assert(p_libvlc != NULL);
    vlc_dialog_provider *p_provider = libvlc_priv(p_libvlc)->p_dialog_provider;

    if (p_provider == NULL)
        return;
    vlc_mutex_lock(&p_provider->lock);
    dialog_clear_all_locked(p_provider);
    vlc_mutex_unlock(&p_provider->lock);

    vlc_mutex_destroy(&p_provider->lock);
    free(p_provider);
    libvlc_priv(p_libvlc)->p_dialog_provider = NULL;
}",1,1,interface\dialog.c,libvlc_InternalDialogClean,,false,236,251,libvlc_InternalDialogClean,,,14,void libvlc_InternalDialogClean (libvlc_int_t*)
84237,METHOD,interface\dialog.c:<global>,TYPE_DECL,"void
vlc_dialog_provider_set_callbacks(vlc_object_t *p_obj,
                                  const vlc_dialog_cbs *p_cbs, void *p_data)
{
    assert(p_obj != NULL);
    vlc_dialog_provider *p_provider = get_dialog_provider(p_obj, false);

    vlc_mutex_lock(&p_provider->lock);
    dialog_clear_all_locked(p_provider);

    if (p_cbs == NULL)
    {
        memset(&p_provider->cbs, 0, sizeof(p_provider->cbs));
        p_provider->p_cbs_data = NULL;
    }
    else
    {
        p_provider->cbs = *p_cbs;
        p_provider->p_cbs_data = p_data;
    }
    vlc_mutex_unlock(&p_provider->lock);
}",1,1,interface\dialog.c,vlc_dialog_provider_set_callbacks,,false,254,275,vlc_dialog_provider_set_callbacks,,,15,"void vlc_dialog_provider_set_callbacks (vlc_object_t*,vlc_dialog_cbs*,void*)"
84299,METHOD,interface\dialog.c:<global>,TYPE_DECL,"static void
dialog_wait_interrupted(void *p_data)
{
    struct dialog_i11e_context *p_context = p_data;
    vlc_dialog_provider *p_provider = p_context->p_provider;
    vlc_dialog_id *p_id = p_context->p_id;

    vlc_mutex_lock(&p_provider->lock);
    dialog_cancel_locked(p_provider, p_id);
    vlc_mutex_unlock(&p_provider->lock);

    vlc_mutex_lock(&p_id->lock);
    vlc_cond_signal(&p_id->wait);
    vlc_mutex_unlock(&p_id->lock);
}",1,1,interface\dialog.c,dialog_wait_interrupted,,false,277,291,dialog_wait_interrupted,,,16,void dialog_wait_interrupted (void*)
84348,METHOD,interface\dialog.c:<global>,TYPE_DECL,"static int
dialog_wait(vlc_dialog_provider *p_provider, vlc_dialog_id *p_id,
            enum dialog_type i_type, struct dialog_answer *p_answer)
{
    struct dialog_i11e_context context = {
        .p_provider = p_provider,
        .p_id = p_id,
    };
    vlc_interrupt_register(dialog_wait_interrupted, &context);

    vlc_mutex_lock(&p_id->lock);
    /* Wait for the dialog to be dismissed, interrupted or answered */
    while (!p_id->b_cancelled && !p_id->b_answered)
        vlc_cond_wait(&p_id->wait, &p_id->lock);

    int i_ret;
    if (p_id->b_cancelled)
        i_ret = 0;
    else if (p_id->answer.i_type != i_type)
        i_ret = VLC_EGENERIC;
    else
    {
        i_ret = 1;
        memcpy(p_answer, &p_id->answer, sizeof(p_id->answer));
        memset(&p_id->answer, 0, sizeof(p_id->answer));
    }

    vlc_mutex_unlock(&p_id->lock);
    vlc_interrupt_unregister();

    vlc_mutex_lock(&p_provider->lock);
    dialog_remove_locked(p_provider, p_id);
    vlc_mutex_unlock(&p_pro...",1,1,interface\dialog.c,dialog_wait,,false,293,327,dialog_wait,,,17,"int dialog_wait (vlc_dialog_provider*,vlc_dialog_id*,dialog_type,dialog_answer*)"
84465,METHOD,interface\dialog.c:<global>,TYPE_DECL,"static int
dialog_display_error_va(vlc_dialog_provider *p_provider, const char *psz_title,
                        const char *psz_fmt, va_list ap)
{
    vlc_mutex_lock(&p_provider->lock);
    if (p_provider->cbs.pf_display_error == NULL)
    {
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_EGENERIC;
    }

    char *psz_text;
    if (vasprintf(&psz_text, psz_fmt, ap) == -1)
    {
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_ENOMEM;
    }

    p_provider->cbs.pf_display_error(p_provider->p_cbs_data, psz_title, psz_text);
    free(psz_text);
    vlc_mutex_unlock(&p_provider->lock);

    return VLC_SUCCESS;
}",1,1,interface\dialog.c,dialog_display_error_va,,false,329,352,dialog_display_error_va,,,18,"int dialog_display_error_va (vlc_dialog_provider*,char*,char*,va_list)"
84532,METHOD,interface\dialog.c:<global>,TYPE_DECL,"int
vlc_dialog_display_error_va(vlc_object_t *p_obj, const char *psz_title,
                            const char *psz_fmt, va_list ap)
{
    assert(p_obj != NULL && psz_title != NULL && psz_fmt != NULL);
    int i_ret;
    vlc_dialog_provider *p_provider = get_dialog_provider(p_obj, true);

    if (p_provider != NULL)
        i_ret = dialog_display_error_va(p_provider, psz_title, psz_fmt, ap);
    else
        i_ret = VLC_EGENERIC;

    if (i_ret != VLC_SUCCESS)
    {
        msg_Err(p_obj, ""%s"", psz_title);
        msg_GenericVa(p_obj, VLC_MSG_ERR, psz_fmt, ap);
    }
    return i_ret;
}",1,1,interface\dialog.c,vlc_dialog_display_error_va,,false,354,373,vlc_dialog_display_error_va,,,19,"int vlc_dialog_display_error_va (vlc_object_t*,char*,char*,va_list)"
84592,METHOD,interface\dialog.c:<global>,TYPE_DECL,"int
vlc_dialog_display_error(vlc_object_t *p_obj, const char *psz_title,
                         const char *psz_fmt, ...)
{
    assert(psz_fmt != NULL);
    va_list ap;
    va_start(ap, psz_fmt);
    int i_ret = vlc_dialog_display_error_va(p_obj, psz_title, psz_fmt, ap);
    va_end(ap);
    return i_ret;
}",1,1,interface\dialog.c,vlc_dialog_display_error,,false,377,387,vlc_dialog_display_error,,,20,"int vlc_dialog_display_error (vlc_object_t*,char*,char*...)"
84619,METHOD,interface\dialog.c:<global>,TYPE_DECL,"static int
dialog_display_login_va(vlc_dialog_provider *p_provider, vlc_dialog_id **pp_id,
                        const char *psz_default_username, bool b_ask_store,
                        const char *psz_title, const char *psz_fmt, va_list ap)
{
    vlc_mutex_lock(&p_provider->lock);
    if (p_provider->cbs.pf_display_login == NULL
     || p_provider->cbs.pf_cancel == NULL)
    {
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_EGENERIC;
    }

    char *psz_text;
    if (vasprintf(&psz_text, psz_fmt, ap) == -1)
    {
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_ENOMEM;
    }

    vlc_dialog_id *p_id = dialog_add_locked(p_provider, VLC_DIALOG_LOGIN);
    if (p_id == NULL)
    {
        free(psz_text);
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_ENOMEM;
    }
    p_provider->cbs.pf_display_login(p_provider->p_cbs_data, p_id, psz_title,
                                     psz_text, psz_default_username, b_ask_store);
    free(p...",1,1,interface\dialog.c,dialog_display_login_va,,false,389,423,dialog_display_login_va,,,21,"int dialog_display_login_va (vlc_dialog_provider*,vlc_dialog_id**,char*,bool,char*,char*,va_list)"
84724,METHOD,interface\dialog.c:<global>,TYPE_DECL,"int
vlc_dialog_wait_login_va(vlc_object_t *p_obj,  char **ppsz_username,
                         char **ppsz_password, bool *p_store,
                         const char *psz_default_username,
                         const char *psz_title, const char *psz_fmt, va_list ap)
{
    assert(p_obj != NULL && ppsz_username != NULL && ppsz_password != NULL
        && psz_fmt != NULL && psz_title != NULL);

    vlc_dialog_provider *p_provider = get_dialog_provider(p_obj, true);
    if (p_provider == NULL)
        return VLC_EGENERIC;

    vlc_dialog_id *p_id;
    int i_ret = dialog_display_login_va(p_provider, &p_id, psz_default_username,
                                        p_store != NULL, psz_title, psz_fmt, ap);
    if (i_ret < 0 || p_id == NULL)
        return i_ret;

    struct dialog_answer answer;
    i_ret = dialog_wait(p_provider, p_id, VLC_DIALOG_LOGIN, &answer);
    if (i_ret <= 0)
        return i_ret;

    *ppsz_username = answer.u.login.psz_username;
    *ppsz_password = a...",1,1,interface\dialog.c,vlc_dialog_wait_login_va,,false,425,455,vlc_dialog_wait_login_va,,,22,"int vlc_dialog_wait_login_va (vlc_object_t*,char**,char**,bool*,char*,char*,char*,va_list)"
84848,METHOD,interface\dialog.c:<global>,TYPE_DECL,"int
vlc_dialog_wait_login(vlc_object_t *p_obj,  char **ppsz_username,
                      char **ppsz_password, bool *p_store,
                      const char *psz_default_username, const char *psz_title,
                      const char *psz_fmt, ...)
{
    assert(psz_fmt != NULL);
    va_list ap;
    va_start(ap, psz_fmt);
    int i_ret = vlc_dialog_wait_login_va(p_obj, ppsz_username, ppsz_password,
                                         p_store,psz_default_username,
                                         psz_title, psz_fmt, ap);
    va_end(ap);
    return i_ret;
}",1,1,interface\dialog.c,vlc_dialog_wait_login,,false,458,472,vlc_dialog_wait_login,,,23,"int vlc_dialog_wait_login (vlc_object_t*,char**,char**,bool*,char*,char*,char*...)"
84883,METHOD,interface\dialog.c:<global>,TYPE_DECL,"static int
dialog_display_question_va(vlc_dialog_provider *p_provider, vlc_dialog_id **pp_id,
                           vlc_dialog_question_type i_type,
                           const char *psz_cancel, const char *psz_action1,
                           const char *psz_action2, const char *psz_title,
                           const char *psz_fmt, va_list ap)
{
    vlc_mutex_lock(&p_provider->lock);
    if (p_provider->cbs.pf_display_question == NULL
     || p_provider->cbs.pf_cancel == NULL)
    {
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_EGENERIC;
    }

    char *psz_text;
    if (vasprintf(&psz_text, psz_fmt, ap) == -1)
    {
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_ENOMEM;
    }

    vlc_dialog_id *p_id = dialog_add_locked(p_provider, VLC_DIALOG_QUESTION);
    if (p_id == NULL)
    {
        free(psz_text);
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_ENOMEM;
    }
    p_provider->cbs.pf_display_question(p_provi...",1,1,interface\dialog.c,dialog_display_question_va,,false,474,511,dialog_display_question_va,,,24,"int dialog_display_question_va (vlc_dialog_provider*,vlc_dialog_id**,vlc_dialog_question_type,char*,char*,char*,char*,char*,va_list)"
84992,METHOD,interface\dialog.c:<global>,TYPE_DECL,"int
vlc_dialog_wait_question_va(vlc_object_t *p_obj,
                            vlc_dialog_question_type i_type,
                            const char *psz_cancel, const char *psz_action1,
                            const char *psz_action2, const char *psz_title,
                            const char *psz_fmt, va_list ap)
{
    assert(p_obj != NULL && psz_fmt != NULL && psz_title != NULL
        && psz_cancel != NULL);

    vlc_dialog_provider *p_provider = get_dialog_provider(p_obj, true);
    if (p_provider == NULL)
        return VLC_EGENERIC;

    vlc_dialog_id *p_id;
    int i_ret = dialog_display_question_va(p_provider, &p_id, i_type,
                                           psz_cancel, psz_action1,
                                           psz_action2, psz_title, psz_fmt, ap);
    if (i_ret < 0 || p_id == NULL)
        return i_ret;

    struct dialog_answer answer;
    i_ret = dialog_wait(p_provider, p_id, VLC_DIALOG_QUESTION, &answer);
    if (i_ret <= 0)
        ret...",1,1,interface\dialog.c,vlc_dialog_wait_question_va,,false,513,543,vlc_dialog_wait_question_va,,,25,"int vlc_dialog_wait_question_va (vlc_object_t*,vlc_dialog_question_type,char*,char*,char*,char*,char*,va_list)"
85106,METHOD,interface\dialog.c:<global>,TYPE_DECL,"int
vlc_dialog_wait_question(vlc_object_t *p_obj,
                         vlc_dialog_question_type i_type,
                         const char *psz_cancel, const char *psz_action1,
                         const char *psz_action2, const char *psz_title,
                         const char *psz_fmt, ...)
{
    assert(psz_fmt != NULL);
    va_list ap;
    va_start(ap, psz_fmt);
    int i_ret = vlc_dialog_wait_question_va(p_obj, i_type, psz_cancel,
                                            psz_action1, psz_action2, psz_title,
                                            psz_fmt, ap);
    va_end(ap);
    return i_ret;
}",1,1,interface\dialog.c,vlc_dialog_wait_question,,false,546,561,vlc_dialog_wait_question,,,26,"int vlc_dialog_wait_question (vlc_object_t*,vlc_dialog_question_type,char*,char*,char*,char*,char*...)"
85141,METHOD,interface\dialog.c:<global>,TYPE_DECL,"static int
display_progress_va(vlc_dialog_provider *p_provider, vlc_dialog_id **pp_id,
                    bool b_indeterminate, float f_position,
                    const char *psz_cancel, const char *psz_title,
                    const char *psz_fmt, va_list ap)
{
    vlc_mutex_lock(&p_provider->lock);
    if (p_provider->cbs.pf_display_progress == NULL
     || p_provider->cbs.pf_update_progress == NULL
     || p_provider->cbs.pf_cancel == NULL)
    {
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_EGENERIC;
    }

    char *psz_text;
    if (vasprintf(&psz_text, psz_fmt, ap) == -1)
    {
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_ENOMEM;
    }

    vlc_dialog_id *p_id = dialog_add_locked(p_provider, VLC_DIALOG_PROGRESS);
    if (p_id == NULL)
    {
        free(psz_text);
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_ENOMEM;
    }
    p_id->b_progress_indeterminate = b_indeterminate;
    p_id->psz_progress_text = psz_text;
...",1,1,interface\dialog.c,display_progress_va,,false,563,601,display_progress_va,,,27,"int display_progress_va (vlc_dialog_provider*,vlc_dialog_id**,bool,float,char*,char*,char*,va_list)"
85264,METHOD,interface\dialog.c:<global>,TYPE_DECL,"vlc_dialog_id *
vlc_dialog_display_progress_va(vlc_object_t *p_obj, bool b_indeterminate,
                               float f_position, const char *psz_cancel,
                               const char *psz_title, const char *psz_fmt,
                               va_list ap)
{
    assert(p_obj != NULL && psz_title != NULL && psz_fmt != NULL);

    vlc_dialog_provider *p_provider = get_dialog_provider(p_obj, true);
    if (p_provider == NULL)
        return NULL;
    vlc_dialog_id *p_id;
    int i_ret = display_progress_va(p_provider, &p_id, b_indeterminate,
                                    f_position, psz_cancel, psz_title, psz_fmt,
                                    ap);
    return i_ret == VLC_SUCCESS ? p_id : NULL;
}",1,1,interface\dialog.c,vlc_dialog_display_progress_va,,false,603,619,vlc_dialog_display_progress_va,,,28,"vlc_dialog_id vlc_dialog_display_progress_va (vlc_object_t*,bool,float,char*,char*,char*,va_list)"
85321,METHOD,interface\dialog.c:<global>,TYPE_DECL,"vlc_dialog_id *
vlc_dialog_display_progress(vlc_object_t *p_obj, bool b_indeterminate,
                            float f_position, const char *psz_cancel,
                            const char *psz_title, const char *psz_fmt, ...)
{
    assert(psz_fmt != NULL);
    va_list ap;
    va_start(ap, psz_fmt);
    vlc_dialog_id *p_id =
        vlc_dialog_display_progress_va(p_obj, b_indeterminate, f_position,
                                       psz_cancel, psz_title, psz_fmt, ap);
    va_end(ap);
    return p_id;
}",1,1,interface\dialog.c,vlc_dialog_display_progress,,false,622,635,vlc_dialog_display_progress,,,29,"vlc_dialog_id vlc_dialog_display_progress (vlc_object_t*,bool,float,char*,char*,char*...)"
85354,METHOD,interface\dialog.c:<global>,TYPE_DECL,"static int
dialog_update_progress(vlc_object_t *p_obj, vlc_dialog_id *p_id, float f_value,
                       char *psz_text)
{
    assert(p_obj != NULL && p_id != NULL);
    vlc_dialog_provider *p_provider = get_dialog_provider(p_obj, false);

    vlc_mutex_lock(&p_provider->lock);
    if (p_provider->cbs.pf_update_progress == NULL ||
        vlc_dialog_is_cancelled(p_obj, p_id))
    {
        vlc_mutex_unlock(&p_provider->lock);
        free(psz_text);
        return VLC_EGENERIC;
    }

    if (p_id->b_progress_indeterminate)
        f_value = 0.0f;

    if (psz_text != NULL)
    {
        free(p_id->psz_progress_text);
        p_id->psz_progress_text = psz_text;
    }
    p_provider->cbs.pf_update_progress(p_provider->p_cbs_data, p_id, f_value,
                                       p_id->psz_progress_text);

    vlc_mutex_unlock(&p_provider->lock);
    return VLC_SUCCESS;
}",1,1,interface\dialog.c,dialog_update_progress,,false,637,666,dialog_update_progress,,,30,"int dialog_update_progress (vlc_object_t*,vlc_dialog_id*,float,char*)"
85446,METHOD,interface\dialog.c:<global>,TYPE_DECL,"int
vlc_dialog_update_progress(vlc_object_t *p_obj, vlc_dialog_id *p_id,
                           float f_value)
{
    return dialog_update_progress(p_obj, p_id, f_value, NULL);
}",1,1,interface\dialog.c,vlc_dialog_update_progress,,false,669,674,vlc_dialog_update_progress,,,31,"int vlc_dialog_update_progress (vlc_object_t*,vlc_dialog_id*,float)"
85459,METHOD,interface\dialog.c:<global>,TYPE_DECL,"int
vlc_dialog_update_progress_text_va(vlc_object_t *p_obj, vlc_dialog_id *p_id,
                                   float f_value, const char *psz_fmt,
                                   va_list ap)
{
    assert(psz_fmt != NULL);

    char *psz_text;
    if (vasprintf(&psz_text, psz_fmt, ap) == -1)
        return VLC_ENOMEM;
    return dialog_update_progress(p_obj, p_id, f_value, psz_text);
}",1,1,interface\dialog.c,vlc_dialog_update_progress_text_va,,false,676,687,vlc_dialog_update_progress_text_va,,,32,"int vlc_dialog_update_progress_text_va (vlc_object_t*,vlc_dialog_id*,float,char*,va_list)"
85491,METHOD,interface\dialog.c:<global>,TYPE_DECL,"int
vlc_dialog_update_progress_text(vlc_object_t *p_obj, vlc_dialog_id *p_id,
                                float f_value, const char *psz_fmt, ...)
{
    assert(psz_fmt != NULL);
    va_list ap;
    va_start(ap, psz_fmt);
    int i_ret = vlc_dialog_update_progress_text_va(p_obj, p_id, f_value,
                                                   psz_fmt, ap);
    va_end(ap);
    return i_ret;
}",1,1,interface\dialog.c,vlc_dialog_update_progress_text,,false,690,701,vlc_dialog_update_progress_text,,,33,"int vlc_dialog_update_progress_text (vlc_object_t*,vlc_dialog_id*,float,char*...)"
85520,METHOD,interface\dialog.c:<global>,TYPE_DECL,"void
vlc_dialog_release(vlc_object_t *p_obj, vlc_dialog_id *p_id)
{
    assert(p_obj != NULL && p_id != NULL);
    vlc_dialog_provider *p_provider = get_dialog_provider(p_obj, false);

    vlc_mutex_lock(&p_provider->lock);
    dialog_cancel_locked(p_provider, p_id);
    dialog_remove_locked(p_provider, p_id);
    vlc_mutex_unlock(&p_provider->lock);
}",1,1,interface\dialog.c,vlc_dialog_release,,false,704,714,vlc_dialog_release,,,34,"void vlc_dialog_release (vlc_object_t*,vlc_dialog_id*)"
85556,METHOD,interface\dialog.c:<global>,TYPE_DECL,"bool
vlc_dialog_is_cancelled(vlc_object_t *p_obj, vlc_dialog_id *p_id)
{
    (void) p_obj;
    assert(p_id != NULL);

    vlc_mutex_lock(&p_id->lock);
    bool b_cancelled = p_id->b_cancelled;
    vlc_mutex_unlock(&p_id->lock);
    return b_cancelled;
}",1,1,interface\dialog.c,vlc_dialog_is_cancelled,,false,717,727,vlc_dialog_is_cancelled,,,35,"bool vlc_dialog_is_cancelled (vlc_object_t*,vlc_dialog_id*)"
85587,METHOD,interface\dialog.c:<global>,TYPE_DECL,"void
vlc_dialog_id_set_context(vlc_dialog_id *p_id, void *p_context)
{
    vlc_mutex_lock(&p_id->lock);
    p_id->p_context = p_context;
    vlc_mutex_unlock(&p_id->lock);
}",1,1,interface\dialog.c,vlc_dialog_id_set_context,,false,729,735,vlc_dialog_id_set_context,,,36,"void vlc_dialog_id_set_context (vlc_dialog_id*,void*)"
85608,METHOD,interface\dialog.c:<global>,TYPE_DECL,"void *
vlc_dialog_id_get_context(vlc_dialog_id *p_id)
{
    assert(p_id != NULL);
    vlc_mutex_lock(&p_id->lock);
    void *p_context = p_id->p_context;
    vlc_mutex_unlock(&p_id->lock);
    return p_context;
}",1,1,interface\dialog.c,vlc_dialog_id_get_context,,false,737,745,vlc_dialog_id_get_context,,,37,void* vlc_dialog_id_get_context (vlc_dialog_id*)
85635,METHOD,interface\dialog.c:<global>,TYPE_DECL,"static int
dialog_id_post(vlc_dialog_id *p_id, struct dialog_answer *p_answer)
{
    vlc_mutex_lock(&p_id->lock);
    if (p_answer == NULL)
    {
        p_id->b_cancelled = true;
    }
    else
    {
        p_id->answer = *p_answer;
        p_id->b_answered = true;
    }
    p_id->i_refcount--;
    if (p_id->i_refcount > 0)
    {
        vlc_cond_signal(&p_id->wait);
        vlc_mutex_unlock(&p_id->lock);
    }
    else
    {
        vlc_mutex_unlock(&p_id->lock);
        dialog_id_release(p_id);
    }
    return VLC_SUCCESS;
}",1,1,interface\dialog.c,dialog_id_post,,false,747,772,dialog_id_post,,,38,"int dialog_id_post (vlc_dialog_id*,dialog_answer*)"
85701,METHOD,interface\dialog.c:<global>,TYPE_DECL,"int
vlc_dialog_id_post_login(vlc_dialog_id *p_id, const char *psz_username,
                         const char *psz_password, bool b_store)
{
    assert(p_id != NULL && psz_username != NULL && psz_password != NULL);

    struct dialog_answer answer = {
        .i_type = VLC_DIALOG_LOGIN,
        .u.login = {
            .b_store = b_store,
            .psz_username = strdup(psz_username),
            .psz_password = strdup(psz_password),
        },
    };
    if (answer.u.login.psz_username == NULL
     || answer.u.login.psz_password == NULL)
    {
        free(answer.u.login.psz_username);
        free(answer.u.login.psz_password);
        dialog_id_post(p_id, NULL);
        return VLC_ENOMEM;
    }

    return dialog_id_post(p_id, &answer);
}",1,1,interface\dialog.c,vlc_dialog_id_post_login,,false,774,798,vlc_dialog_id_post_login,,,39,"int vlc_dialog_id_post_login (vlc_dialog_id*,char*,char*,bool)"
85811,METHOD,interface\dialog.c:<global>,TYPE_DECL,"int
vlc_dialog_id_post_action(vlc_dialog_id *p_id, int i_action)
{
    assert(p_id != NULL);

    struct dialog_answer answer = {
        .i_type = VLC_DIALOG_QUESTION,
        .u.question = { .i_action = i_action },
    };

    return dialog_id_post(p_id, &answer);
}",1,1,interface\dialog.c,vlc_dialog_id_post_action,,false,800,811,vlc_dialog_id_post_action,,,40,"int vlc_dialog_id_post_action (vlc_dialog_id*,int)"
85849,METHOD,interface\dialog.c:<global>,TYPE_DECL,"int
vlc_dialog_id_dismiss(vlc_dialog_id *p_id)
{
    return dialog_id_post(p_id, NULL);
}",1,1,interface\dialog.c,vlc_dialog_id_dismiss,,false,813,817,vlc_dialog_id_dismiss,,,41,int vlc_dialog_id_dismiss (vlc_dialog_id*)
85858,METHOD,interface\dialog.c:<global>,TYPE_DECL,"void
vlc_dialog_provider_set_ext_callback(vlc_object_t *p_obj,
                                     vlc_dialog_ext_update_cb pf_update,
                                     void *p_data)
{
    assert(p_obj != NULL);
    vlc_dialog_provider *p_provider = get_dialog_provider(p_obj, false);

    vlc_mutex_lock(&p_provider->lock);

    p_provider->pf_ext_update = pf_update;
    p_provider->p_ext_data = p_data;

    vlc_mutex_unlock(&p_provider->lock);
}",1,1,interface\dialog.c,vlc_dialog_provider_set_ext_callback,,false,820,834,vlc_dialog_provider_set_ext_callback,,,42,"void vlc_dialog_provider_set_ext_callback (vlc_object_t*,vlc_dialog_ext_update_cb,void*)"
85895,METHOD,interface\dialog.c:<global>,TYPE_DECL,"int
vlc_ext_dialog_update(vlc_object_t *p_obj, extension_dialog_t *p_ext_dialog)
{
    assert(p_obj != NULL);
    vlc_dialog_provider *p_provider = get_dialog_provider(p_obj, false);

    vlc_mutex_lock(&p_provider->lock);
    if (p_provider->pf_ext_update == NULL)
    {
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_EGENERIC;
    }
    p_provider->pf_ext_update(p_ext_dialog, p_provider->p_ext_data);
    vlc_mutex_unlock(&p_provider->lock);
    return VLC_SUCCESS;
}",1,1,interface\dialog.c,vlc_ext_dialog_update,,false,837,852,vlc_ext_dialog_update,,,43,"int vlc_ext_dialog_update (vlc_object_t*,extension_dialog_t*)"
85966,METHOD,interface\interface.c:<global>,TYPE_DECL,<global>,1,26,interface\interface.c,interface\interface.c:<global>,,false,1,284,<global>,,,1,
85968,METHOD,interface\interface.c:<global>,TYPE_DECL,"static int AddIntfCallback( vlc_object_t *, char const *,
                            vlc_value_t , vlc_value_t , void * );",12,64,interface\interface.c,AddIntfCallback,,false,50,51,AddIntfCallback,,,1,"int AddIntfCallback (vlc_object_t*,char*,ANY,ANY,void*)"
85981,METHOD,interface\interface.c:<global>,TYPE_DECL,"int intf_Create( playlist_t *playlist, const char *chain )
{
    /* Allocate structure */
    intf_thread_t *p_intf = vlc_custom_create( playlist, sizeof( *p_intf ),
                                               ""interface"" );
    if( unlikely(p_intf == NULL) )
        return VLC_ENOMEM;

    /* Variable used for interface spawning */
    vlc_value_t val, text;
    var_Create( p_intf, ""intf-add"", VLC_VAR_STRING | VLC_VAR_ISCOMMAND );
    text.psz_string = _(""Add Interface"");
    var_Change( p_intf, ""intf-add"", VLC_VAR_SETTEXT, &text, NULL );
#if !defined(_WIN32) && defined(HAVE_ISATTY)
    if( isatty( 0 ) )
#endif
    {
        val.psz_string = (char *)""rc,none"";
        text.psz_string = (char *)_(""Console"");
        var_Change( p_intf, ""intf-add"", VLC_VAR_ADDCHOICE, &val, &text );
    }
    val.psz_string = (char *)""telnet,none"";
    text.psz_string = (char *)_(""Telnet"");
    var_Change( p_intf, ""intf-add"", VLC_VAR_ADDCHOICE, &val, &text );
    val.psz_string = (char *)""http,none...",1,28,interface\interface.c,intf_Create,,false,71,130,intf_Create,,,4,"int intf_Create (playlist_t*,char*)"
86216,METHOD,interface\interface.c:<global>,TYPE_DECL,"static playlist_t *intf_GetPlaylist(libvlc_int_t *libvlc)
{
    playlist_t *playlist;

    vlc_mutex_lock(&lock);
    playlist = libvlc_priv(libvlc)->playlist;
    if (playlist == NULL)
    {
        playlist = playlist_Create(VLC_OBJECT(libvlc));
        libvlc_priv(libvlc)->playlist = playlist;
    }
    vlc_mutex_unlock(&lock);

    return playlist;
}",1,1,interface\interface.c,intf_GetPlaylist,,false,137,151,intf_GetPlaylist,,,5,playlist_t intf_GetPlaylist (libvlc_int_t*)
86252,METHOD,interface\interface.c:<global>,TYPE_DECL,"int intf_InsertItem(libvlc_int_t *libvlc, const char *mrl, unsigned optc,
                    const char *const *optv, unsigned flags)
{
    playlist_t *playlist = intf_GetPlaylist(libvlc);
    input_item_t *item = input_item_New(mrl, NULL);

    if (unlikely(item == NULL))
        return -1;

    int ret = -1;

    if (input_item_AddOptions(item, optc, optv, flags) == VLC_SUCCESS)
    {
        playlist_Lock(playlist);
        if (playlist_NodeAddInput(playlist, item, playlist->p_playing,
                                  0) != NULL)
            ret = 0;
        playlist_Unlock(playlist);
    }
    input_item_Release(item);
    return ret;
}",1,1,interface\interface.c,intf_InsertItem,,false,163,184,intf_InsertItem,,,6,"int intf_InsertItem (libvlc_int_t*,char*,unsigned,char**,unsigned)"
86317,METHOD,interface\interface.c:<global>,TYPE_DECL,"void libvlc_InternalPlay(libvlc_int_t *libvlc)
{
    playlist_t *pl;

    vlc_mutex_lock(&lock);
    pl = libvlc_priv(libvlc)->playlist;
    vlc_mutex_unlock(&lock);

    if (pl != NULL && var_GetBool(pl, ""playlist-autostart""))
        playlist_Control(pl, PLAYLIST_PLAY, false);
}",1,1,interface\interface.c,libvlc_InternalPlay,,false,186,196,libvlc_InternalPlay,,,7,void libvlc_InternalPlay (libvlc_int_t*)
86348,METHOD,interface\interface.c:<global>,TYPE_DECL,"int libvlc_InternalAddIntf(libvlc_int_t *libvlc, const char *name)
{
    playlist_t *playlist = intf_GetPlaylist(libvlc);
    int ret;

    if (unlikely(playlist == NULL))
        ret = VLC_ENOMEM;
    else
    if (name != NULL)
        ret = intf_Create(playlist, name);
    else
    {   /* Default interface */
        char *intf = var_InheritString(libvlc, ""intf"");
        if (intf == NULL) /* ""intf"" has not been set */
        {
#if !defined(_WIN32) && !defined(__OS2__)
            char *pidfile = var_InheritString(libvlc, ""pidfile"");
            if (pidfile != NULL)
                free(pidfile);
            else
#endif
                msg_Info(libvlc, _(""Running vlc with the default interface. ""
                         ""Use 'cvlc' to use vlc without interface.""));
        }
        ret = intf_Create(playlist, intf);
        free(intf);
        name = ""default"";
    }
    if (ret != VLC_SUCCESS)
        msg_Err(libvlc, ""interface \""%s\"" initialization failed"", name);
    return ...",1,1,interface\interface.c,libvlc_InternalAddIntf,,false,201,232,libvlc_InternalAddIntf,,,8,"int libvlc_InternalAddIntf (libvlc_int_t*,char*)"
86434,METHOD,interface\interface.c:<global>,TYPE_DECL,"void intf_DestroyAll(libvlc_int_t *libvlc)
{
    playlist_t *playlist;

    vlc_mutex_lock(&lock);
    playlist = libvlc_priv(libvlc)->playlist;
    if (playlist != NULL)
    {
        intf_thread_t *intf, **pp = &(pl_priv(playlist)->interface);

        while ((intf = *pp) != NULL)
        {
            *pp = intf->p_next;
            vlc_mutex_unlock(&lock);

            module_unneed(intf, intf->p_module);
            config_ChainDestroy(intf->p_cfg);
            var_DelCallback(intf, ""intf-add"", AddIntfCallback, playlist);
            vlc_object_release(intf);

            vlc_mutex_lock(&lock);
        }

        libvlc_priv(libvlc)->playlist = NULL;
    }
    vlc_mutex_unlock(&lock);

    if (playlist != NULL)
        playlist_Destroy(playlist);
}",1,38,interface\interface.c,intf_DestroyAll,,false,239,268,intf_DestroyAll,,,9,void intf_DestroyAll (libvlc_int_t*)
86520,METHOD,interface\interface.c:<global>,TYPE_DECL,"static int AddIntfCallback( vlc_object_t *obj, char const *var,
                            vlc_value_t old, vlc_value_t cur, void *data )
{
    playlist_t *playlist = data;

    int ret = intf_Create( playlist, cur.psz_string );
    if( ret )
        msg_Err( obj, ""interface \""%s\"" initialization failed"",
                 cur.psz_string );

    (void) var; (void) old;
    return ret;
}",1,1,interface\interface.c,AddIntfCallback,,false,272,284,AddIntfCallback,,,10,"int AddIntfCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
86583,METHOD,libvlc-module.c:<global>,TYPE_DECL,<global>,1,26,libvlc-module.c,libvlc-module.c:<global>,,false,1,2828,<global>,,,1,
86908,METHOD,libvlc-module.c:<global>,TYPE_DECL,vlc_module_begin (),1,19,libvlc-module.c,vlc_module_begin,,false,1488,1488,vlc_module_begin,,,55,ANY vlc_module_begin ()
86913,METHOD,libvlc-module.c:<global>,TYPE_DECL,set_category( CAT_AUDIO ),5,29,libvlc-module.c,set_category,,false,1490,1490,set_category,,,57,ANY set_category (ANY)
86919,METHOD,libvlc-module.c:<global>,TYPE_DECL,set_subcategory( SUBCAT_AUDIO_GENERAL ),5,43,libvlc-module.c,set_subcategory,,false,1491,1491,set_subcategory,,,59,ANY set_subcategory (ANY)
86986,METHOD,libvlc.c:<global>,TYPE_DECL,<global>,1,1,libvlc.c,libvlc.c:<global>,,false,1,563,<global>,,,1,
86988,METHOD,libvlc.c:<global>,TYPE_DECL,"static void GetFilenames  ( libvlc_int_t *, unsigned, const char *const [] );",13,76,libvlc.c,GetFilenames,,false,77,77,GetFilenames,,,1,"void GetFilenames (libvlc_int_t*,unsigned,char[]*)"
86995,METHOD,libvlc.c:<global>,TYPE_DECL,"libvlc_int_t * libvlc_InternalCreate( void )
{
    libvlc_int_t *p_libvlc;
    libvlc_priv_t *priv;

    /* Allocate a libvlc instance object */
    p_libvlc = (vlc_custom_create)( NULL, sizeof (*priv), ""libvlc"" );
    if( p_libvlc == NULL )
        return NULL;

    priv = libvlc_priv (p_libvlc);
    priv->playlist = NULL;
    priv->p_vlm = NULL;

    vlc_ExitInit( &priv->exit );

    return p_libvlc;
}",1,1,libvlc.c,libvlc_InternalCreate,,false,83,100,libvlc_InternalCreate,,,2,libvlc_int_t libvlc_InternalCreate (void)
87038,METHOD,libvlc.c:<global>,TYPE_DECL,"int libvlc_InternalInit( libvlc_int_t *p_libvlc, int i_argc,
                         const char *ppsz_argv[] )
{
    libvlc_priv_t *priv = libvlc_priv (p_libvlc);
    char *       psz_modules = NULL;
    char *       psz_parser = NULL;
    char *       psz_control = NULL;
    char        *psz_val;
    int          i_ret = VLC_EGENERIC;

    /* System specific initialization code */
    system_Init();

    vlc_LogPreinit(p_libvlc);

    /* Initialize the module bank and load the configuration of the
     * core module. We need to do this at this stage to be able to display
     * a short help if required by the user. (short help == core module
     * options) */
    module_InitBank ();

    /* Get command line options that affect module loading. */
    if( config_LoadCmdLine( p_libvlc, i_argc, ppsz_argv, NULL ) )
    {
        module_EndBank (false);
        return VLC_EGENERIC;
    }

    vlc_threads_setup (p_libvlc);

    /* Load the builtins and plugins into the module_bank.
    ...",1,8,libvlc.c,libvlc_InternalInit,,false,110,376,libvlc_InternalInit,,,3,"int libvlc_InternalInit (libvlc_int_t*,int,char[]*)"
87422,METHOD,libvlc.c:<global>,TYPE_DECL,"void libvlc_InternalCleanup( libvlc_int_t *p_libvlc )
{
    libvlc_priv_t *priv = libvlc_priv (p_libvlc);

    if (priv->parser != NULL)
        playlist_preparser_Deactivate(priv->parser);

    /* Ask the interfaces to stop and destroy them */
    msg_Dbg( p_libvlc, ""removing all interfaces"" );
    intf_DestroyAll( p_libvlc );

    libvlc_InternalDialogClean( p_libvlc );
    libvlc_InternalKeystoreClean( p_libvlc );

#ifdef ENABLE_VLM
    /* Destroy VLM if created in libvlc_InternalInit */
    if( priv->p_vlm )
    {
        vlm_Delete( priv->p_vlm );
    }
#endif

#if !defined( _WIN32 ) && !defined( __OS2__ )
    char *pidfile = var_InheritString( p_libvlc, ""pidfile"" );
    if( pidfile != NULL )
    {
        msg_Dbg( p_libvlc, ""removing PID file %s"", pidfile );
        if( unlink( pidfile ) )
            msg_Warn( p_libvlc, ""cannot remove PID file %s: %s"",
                      pidfile, vlc_strerror_c(errno) );
        free( pidfile );
    }
#endif

    if (priv->parser != NULL)
...",1,1,libvlc.c,libvlc_InternalCleanup,,false,382,431,libvlc_InternalCleanup,,,4,void libvlc_InternalCleanup (libvlc_int_t*)
87505,METHOD,libvlc.c:<global>,TYPE_DECL,"void libvlc_InternalDestroy( libvlc_int_t *p_libvlc )
{
    libvlc_priv_t *priv = libvlc_priv( p_libvlc );

    vlc_ExitDestroy( &priv->exit );

    assert( atomic_load(&(vlc_internals(p_libvlc)->refs)) == 1 );
    vlc_object_release( p_libvlc );
}",1,26,libvlc.c,libvlc_InternalDestroy,,false,440,448,libvlc_InternalDestroy,,,5,void libvlc_InternalDestroy (libvlc_int_t*)
87538,METHOD,libvlc.c:<global>,TYPE_DECL,"static void GetFilenames( libvlc_int_t *p_vlc, unsigned n,
                          const char *const args[] )
{
    while( n > 0 )
    {
        /* Count the input options */
        unsigned i_options = 0;

        while( args[--n][0] == ':' )
        {
            i_options++;
            if( n == 0 )
            {
                msg_Warn( p_vlc, ""options %s without item"", args[n] );
                return; /* syntax!? */
            }
        }

        char *mrl = NULL;
        if( strstr( args[n], ""://"" ) == NULL )
        {
            mrl = vlc_path2uri( args[n], NULL );
            if( !mrl )
                continue;
        }

        intf_InsertItem( p_vlc, (mrl != NULL) ? mrl : args[n], i_options,
                         ( i_options ? &args[n + 1] : NULL ),
                         VLC_INPUT_OPTION_TRUSTED );
        free( mrl );
    }
}",1,1,libvlc.c,GetFilenames,,false,456,487,GetFilenames,,,6,"void GetFilenames (libvlc_int_t*,unsigned,char[]*)"
87626,METHOD,libvlc.c:<global>,TYPE_DECL,"int vlc_MetadataRequest(libvlc_int_t *libvlc, input_item_t *item,
                        input_item_meta_request_option_t i_options,
                        int timeout, void *id)
{
    libvlc_priv_t *priv = libvlc_priv(libvlc);

    if (unlikely(priv->parser == NULL))
        return VLC_ENOMEM;

    if( i_options & META_REQUEST_OPTION_DO_INTERACT )
    {
        vlc_mutex_lock( &item->lock );
        item->b_preparse_interact = true;
        vlc_mutex_unlock( &item->lock );
    }
    playlist_preparser_Push( priv->parser, item, i_options, timeout, id );
    return VLC_SUCCESS;

}",1,1,libvlc.c,vlc_MetadataRequest,,false,489,507,vlc_MetadataRequest,,,7,"int vlc_MetadataRequest (libvlc_int_t*,input_item_t*,input_item_meta_request_option_t,int,void*)"
87680,METHOD,libvlc.c:<global>,TYPE_DECL,"int libvlc_MetadataRequest(libvlc_int_t *libvlc, input_item_t *item,
                           input_item_meta_request_option_t i_options,
                           int timeout, void *id)
{
    libvlc_priv_t *priv = libvlc_priv(libvlc);

    if (unlikely(priv->parser == NULL))
        return VLC_ENOMEM;

    vlc_mutex_lock( &item->lock );
    if( item->i_preparse_depth == 0 )
        item->i_preparse_depth = 1;
    if( i_options & META_REQUEST_OPTION_DO_INTERACT )
        item->b_preparse_interact = true;
    vlc_mutex_unlock( &item->lock );
    playlist_preparser_Push( priv->parser, item, i_options, timeout, id );
    return VLC_SUCCESS;
}",1,1,libvlc.c,libvlc_MetadataRequest,,false,514,531,libvlc_MetadataRequest,,,8,"int libvlc_MetadataRequest (libvlc_int_t*,input_item_t*,input_item_meta_request_option_t,int,void*)"
87746,METHOD,libvlc.c:<global>,TYPE_DECL,"int libvlc_ArtRequest(libvlc_int_t *libvlc, input_item_t *item,
                      input_item_meta_request_option_t i_options)
{
    libvlc_priv_t *priv = libvlc_priv(libvlc);

    if (unlikely(priv->parser == NULL))
        return VLC_ENOMEM;

    playlist_preparser_fetcher_Push(priv->parser, item, i_options);
    return VLC_SUCCESS;
}",1,1,libvlc.c,libvlc_ArtRequest,,false,537,547,libvlc_ArtRequest,,,9,"int libvlc_ArtRequest (libvlc_int_t*,input_item_t*,input_item_meta_request_option_t)"
87776,METHOD,libvlc.c:<global>,TYPE_DECL,"void libvlc_MetadataCancel(libvlc_int_t *libvlc, void *id)
{
    libvlc_priv_t *priv = libvlc_priv(libvlc);

    if (unlikely(priv->parser == NULL))
        return;

    playlist_preparser_Cancel(priv->parser, id);
}",1,1,libvlc.c,libvlc_MetadataCancel,,false,555,563,libvlc_MetadataCancel,,,10,"void libvlc_MetadataCancel (libvlc_int_t*,void*)"
87806,METHOD,libvlc.h:<global>,TYPE_DECL,<global>,1,6,libvlc.h,libvlc.h:<global>,,false,1,273,<global>,,,1,
87812,METHOD,libvlc.h:<global>,TYPE_DECL,void system_Init      ( void );,6,30,libvlc.h,system_Init,,false,37,37,system_Init,,,5,void system_Init (void)
87817,METHOD,libvlc.h:<global>,TYPE_DECL,"void system_Configure ( libvlc_int_t *, int, const char *const [] );",6,67,libvlc.h,system_Configure,,false,38,38,system_Configure,,,6,"void system_Configure (libvlc_int_t*,int,char[]*)"
87824,METHOD,libvlc.h:<global>,TYPE_DECL,void vlc_CPU_init(void);,6,23,libvlc.h,vlc_CPU_init,,false,45,45,vlc_CPU_init,,,7,void vlc_CPU_init (void)
87829,METHOD,libvlc.h:<global>,TYPE_DECL,void vlc_CPU_dump(vlc_object_t *);,6,33,libvlc.h,vlc_CPU_dump,,false,46,46,vlc_CPU_dump,,,8,void vlc_CPU_dump (vlc_object_t*)
87834,METHOD,libvlc.h:<global>,TYPE_DECL,"int vlc_clone_detach (vlc_thread_t *, void *(*)(void *), void *, int);",5,69,libvlc.h,vlc_clone_detach,,false,53,53,vlc_clone_detach,,,9,"int vlc_clone_detach (vlc_thread_t*,void*,void*,int)"
87842,METHOD,libvlc.h:<global>,TYPE_DECL,"int vlc_set_priority( vlc_thread_t, int );",5,41,libvlc.h,vlc_set_priority,,false,55,55,vlc_set_priority,,,10,"int vlc_set_priority (ANY,int)"
87848,METHOD,libvlc.h:<global>,TYPE_DECL,void vlc_threads_setup (libvlc_int_t *);,6,39,libvlc.h,vlc_threads_setup,,false,57,57,vlc_threads_setup,,,11,void vlc_threads_setup (libvlc_int_t*)
87853,METHOD,libvlc.h:<global>,TYPE_DECL,"void vlc_trace (const char *fn, const char *file, unsigned line);",6,64,libvlc.h,vlc_trace,,false,59,59,vlc_trace,,,12,"void vlc_trace (char*,char*,unsigned)"
87862,METHOD,libvlc.h:<global>,TYPE_DECL,int vlc_LogPreinit(libvlc_int_t *);,5,34,libvlc.h,vlc_LogPreinit,,false,73,73,vlc_LogPreinit,,,15,int vlc_LogPreinit (libvlc_int_t*)
87867,METHOD,libvlc.h:<global>,TYPE_DECL,int vlc_LogInit(libvlc_int_t *);,5,31,libvlc.h,vlc_LogInit,,false,74,74,vlc_LogInit,,,16,int vlc_LogInit (libvlc_int_t*)
87872,METHOD,libvlc.h:<global>,TYPE_DECL,void vlc_LogDeinit(libvlc_int_t *);,6,34,libvlc.h,vlc_LogDeinit,,false,75,75,vlc_LogDeinit,,,17,void vlc_LogDeinit (libvlc_int_t*)
87879,METHOD,vlc_exit,TYPE_DECL,void (*handler) (void *);,10,28,libvlc.h,vlc_exit.handler,,false,83,83,handler,,,2,void vlc_exit.handler (void*)
87886,METHOD,libvlc.h:<global>,TYPE_DECL,void vlc_ExitInit( vlc_exit_t * );,6,33,libvlc.h,vlc_ExitInit,,false,87,87,vlc_ExitInit,,,20,void vlc_ExitInit (vlc_exit_t*)
87891,METHOD,libvlc.h:<global>,TYPE_DECL,void vlc_ExitDestroy( vlc_exit_t * );,6,36,libvlc.h,vlc_ExitDestroy,,false,88,88,vlc_ExitDestroy,,,21,void vlc_ExitDestroy (vlc_exit_t*)
87896,METHOD,libvlc.h:<global>,TYPE_DECL,"extern void *
vlc_custom_create (vlc_object_t *p_this, size_t i_size, const char *psz_type);",13,77,libvlc.h,vlc_custom_create,,false,107,108,vlc_custom_create,,,22,"void* vlc_custom_create (vlc_object_t*,size_t,char*)"
87903,METHOD,libvlc.h:<global>,TYPE_DECL,"extern int vlc_object_set_name(vlc_object_t *, const char *);",12,60,libvlc.h,vlc_object_set_name,,false,115,115,vlc_object_set_name,,,23,"int vlc_object_set_name (vlc_object_t*,char*)"
87909,METHOD,libvlc.h:<global>,TYPE_DECL,typedef void (*vlc_destructor_t) (struct vlc_object_t *);,14,56,libvlc.h,vlc_destructor_t,,false,119,119,vlc_destructor_t,,,24,void vlc_destructor_t (vlc_object_t*)
87914,METHOD,libvlc.h:<global>,TYPE_DECL,"void vlc_object_set_destructor (vlc_object_t *, vlc_destructor_t);",6,65,libvlc.h,vlc_object_set_destructor,,false,120,120,vlc_object_set_destructor,,,25,"void vlc_object_set_destructor (vlc_object_t*,vlc_destructor_t)"
87920,METHOD,libvlc.h:<global>,TYPE_DECL,"void *vlc_objres_new(size_t size, void (*release)(void *));",6,58,libvlc.h,vlc_objres_new,,false,132,132,vlc_objres_new,,,26,"void* vlc_objres_new (size_t,void)"
87926,METHOD,libvlc.h:<global>,TYPE_DECL,"void vlc_objres_push(vlc_object_t *obj, void *data);",6,51,libvlc.h,vlc_objres_push,,false,140,140,vlc_objres_push,,,27,"void vlc_objres_push (vlc_object_t*,void*)"
87932,METHOD,libvlc.h:<global>,TYPE_DECL,void vlc_objres_clear(vlc_object_t *obj);,6,40,libvlc.h,vlc_objres_clear,,false,150,150,vlc_objres_clear,,,28,void vlc_objres_clear (vlc_object_t*)
87937,METHOD,libvlc.h:<global>,TYPE_DECL,"void vlc_objres_remove(vlc_object_t *obj, void *data,
                       bool (*match)(void *, void *));",6,53,libvlc.h,vlc_objres_remove,,false,163,164,vlc_objres_remove,,,29,"void vlc_objres_remove (vlc_object_t*,void*,bool)"
87964,METHOD,libvlc.h:<global>,TYPE_DECL,"static inline libvlc_priv_t *libvlc_priv (libvlc_int_t *libvlc)
{
    return container_of(libvlc, libvlc_priv_t, public_data);
}",1,1,libvlc.h,libvlc_priv,,false,199,202,libvlc_priv,,,38,libvlc_priv_t libvlc_priv (libvlc_int_t*)
87974,METHOD,libvlc.h:<global>,TYPE_DECL,"int intf_InsertItem(libvlc_int_t *, const char *mrl, unsigned optc,
                    const char * const *optv, unsigned flags);",5,61,libvlc.h,intf_InsertItem,,false,204,205,intf_InsertItem,,,39,"int intf_InsertItem (libvlc_int_t*,char*,unsigned,char**,unsigned)"
87983,METHOD,libvlc.h:<global>,TYPE_DECL,void intf_DestroyAll( libvlc_int_t * );,6,38,libvlc.h,intf_DestroyAll,,false,206,206,intf_DestroyAll,,,40,void intf_DestroyAll (libvlc_int_t*)
87988,METHOD,libvlc.h:<global>,TYPE_DECL,"int vlc_MetadataRequest(libvlc_int_t *libvlc, input_item_t *item,
                        input_item_meta_request_option_t i_options,
                        int timeout, void *id);",5,46,libvlc.h,vlc_MetadataRequest,,false,210,212,vlc_MetadataRequest,,,41,"int vlc_MetadataRequest (libvlc_int_t*,input_item_t*,input_item_meta_request_option_t,int,void*)"
87997,METHOD,libvlc.h:<global>,TYPE_DECL,"void var_OptionParse (vlc_object_t *, const char *, bool trusted);",6,65,libvlc.h,var_OptionParse,,false,217,217,var_OptionParse,,,42,"void var_OptionParse (vlc_object_t*,char*,bool)"
88037,METHOD,libvlc.h:<global>,TYPE_DECL,counter_t * stats_CounterCreate (int);,11,37,libvlc.h,stats_CounterCreate,,false,266,266,stats_CounterCreate,,,49,counter_t* stats_CounterCreate (int)
88042,METHOD,libvlc.h:<global>,TYPE_DECL,"void stats_Update (counter_t *, uint64_t, uint64_t *);",6,53,libvlc.h,stats_Update,,false,267,267,stats_Update,,,50,"void stats_Update (counter_t*,ANY,uint64_t*)"
88049,METHOD,libvlc.h:<global>,TYPE_DECL,void stats_CounterClean (counter_t * );,6,38,libvlc.h,stats_CounterClean,,false,268,268,stats_CounterClean,,,51,void stats_CounterClean (counter_t*)
88054,METHOD,libvlc.h:<global>,TYPE_DECL,"void stats_ComputeInputStats(input_thread_t*, input_stats_t*);",6,61,libvlc.h,stats_ComputeInputStats,,false,270,270,stats_ComputeInputStats,,,52,"void stats_ComputeInputStats (input_thread_t*,input_stats_t*)"
88060,METHOD,libvlc.h:<global>,TYPE_DECL,void stats_ReinitInputStats(input_stats_t *);,6,44,libvlc.h,stats_ReinitInputStats,,false,271,271,stats_ReinitInputStats,,,53,void stats_ReinitInputStats (input_stats_t*)
88078,METHOD,linux\cpu.c:<global>,TYPE_DECL,<global>,1,6,linux\cpu.c,linux\cpu.c:<global>,,false,1,134,<global>,,,1,
88080,METHOD,linux\cpu.c:<global>,TYPE_DECL,"unsigned vlc_CPU (void)
{
    return 0;
}",1,1,linux\cpu.c,vlc_CPU,,false,130,133,vlc_CPU,,,1,unsigned vlc_CPU (void)
88104,METHOD,linux\dirs.c:<global>,TYPE_DECL,<global>,1,24,linux\dirs.c,linux\dirs.c:<global>,,false,1,129,<global>,,,1,
88106,METHOD,linux\dirs.c:<global>,TYPE_DECL,"char *config_GetLibDir (void)
{
    static struct
    {
        vlc_mutex_t lock;
        char path[PATH_MAX];
    } cache = {
        VLC_STATIC_MUTEX, """",
    };

    /* Reading and parsing /proc/self/maps is slow, so cache the value since
     * it's guaranteed not to change during the life-time of the process. */
    vlc_mutex_lock(&cache.lock);
    if (cache.path[0] != '\0')
    {
        char *ret = strdup(cache.path);
        vlc_mutex_unlock(&cache.lock);
        return ret;
    }
    char *path = NULL;

    /* Find the path to libvlc (i.e. ourselves) */
    FILE *maps = fopen (""/proc/self/maps"", ""rte"");
    if (maps == NULL)
        goto error;

    char *line = NULL;
    size_t linelen = 0;
    uintptr_t needle = (uintptr_t)config_GetLibDir;

    for (;;)
    {
        ssize_t len = getline (&line, &linelen, maps);
        if (len == -1)
            break;

        void *start, *end;
        if (sscanf (line, ""%p-%p"", &start, &end) < 2)
            continue;
        /* Thi...",1,1,linux\dirs.c,config_GetLibDir,,false,33,99,config_GetLibDir,,,1,char* config_GetLibDir (void)
88297,METHOD,linux\dirs.c:<global>,TYPE_DECL,"char *config_GetDataDir (void)
{
    const char *path = getenv (""VLC_DATA_PATH"");
    if (path != NULL)
        return strdup (path);

    char *libdir = config_GetLibDir ();
    if (libdir == NULL)
        return NULL; /* OOM */

    char *datadir = NULL;

    /* There are no clean ways to do this, are there?
     * Due to multilibs, we cannot simply append ../share/. */
    char *p = strstr (libdir, ""/lib/"");
    if (p != NULL)
    {
        char *p2;
        /* Deal with nested ""lib"" directories. Grmbl. */
        while ((p2 = strstr (p + 4, ""/lib/"")) != NULL)
            p = p2;
        *p = '\0';

        if (unlikely(asprintf (&datadir, ""%s/share/""PACKAGE, libdir) == -1))
            datadir = NULL;
    }
    free (libdir);
    return (datadir != NULL) ? datadir : strdup (PKGDATADIR);
}",1,1,linux\dirs.c,config_GetDataDir,,false,101,129,config_GetDataDir,,,2,char* config_GetDataDir (void)
88394,METHOD,linux\getaddrinfo.c:<global>,TYPE_DECL,<global>,1,1,linux\getaddrinfo.c,linux\getaddrinfo.c:<global>,,false,1,92,<global>,,,1,
88396,METHOD,linux\getaddrinfo.c:<global>,TYPE_DECL,"static void vlc_getaddrinfo_notify(union sigval val)
{
    vlc_sem_post(val.sival_ptr);
}",1,1,linux\getaddrinfo.c,vlc_getaddrinfo_notify,,false,34,37,vlc_getaddrinfo_notify,,,1,void vlc_getaddrinfo_notify (union sigval)
88405,METHOD,linux\getaddrinfo.c:<global>,TYPE_DECL,"int vlc_getaddrinfo_i11e(const char *name, unsigned port,
                         const struct addrinfo *hints,
                         struct addrinfo **res)
{
    struct gaicb req =
    {
        .ar_name = name,
        .ar_service = NULL,
        .ar_request = hints,
    };
    char portbuf[6];
    vlc_sem_t done;

    if (port != 0)
    {
        if ((size_t)snprintf(portbuf, sizeof (portbuf), ""%u"",
                             port) >= sizeof (portbuf))
            return EAI_NONAME;

        req.ar_service = portbuf;
    }

    struct sigevent sev =
    {
        .sigev_notify = SIGEV_THREAD,
        .sigev_value = { .sival_ptr = &done, },
        .sigev_notify_function = vlc_getaddrinfo_notify,
    };

    vlc_sem_init(&done, 0);

    int val = getaddrinfo_a(GAI_NOWAIT, &(struct gaicb *){ &req }, 1, &sev);
    if (val)
    {
        vlc_sem_destroy(&done);
        return val;
    }

    vlc_sem_wait_i11e(&done);

    if (gai_cancel(&req) == EAI_CANCELED)
        vlc_sem_wa...",1,1,linux\getaddrinfo.c,vlc_getaddrinfo_i11e,,false,39,92,vlc_getaddrinfo_i11e,,,2,"int vlc_getaddrinfo_i11e (char*,unsigned,addrinfo*,addrinfo**)"
88574,METHOD,linux\thread.c:<global>,TYPE_DECL,<global>,1,12,linux\thread.c,linux\thread.c:<global>,,false,1,87,<global>,,,1,
88576,METHOD,linux\thread.c:<global>,TYPE_DECL,"unsigned long vlc_thread_id(void)
{
     static __thread pid_t tid = 0;

     if (unlikely(tid == 0))
         tid = syscall(__NR_gettid);

     return tid;
}",1,12,linux\thread.c,vlc_thread_id,,false,40,48,vlc_thread_id,,,1,unsigned long vlc_thread_id (void)
88597,METHOD,linux\thread.c:<global>,TYPE_DECL,"static int sys_futex(void *addr, int op, unsigned val,
                     const struct timespec *to, void *addr2, int val3)
{
    return syscall(__NR_futex, addr, op, val, to, addr2, val3);
}",1,1,linux\thread.c,sys_futex,,false,50,54,sys_futex,,,2,"int sys_futex (void*,int,unsigned,timespec*,void*,int)"
88616,METHOD,linux\thread.c:<global>,TYPE_DECL,"static int vlc_futex_wake(void *addr, int nr)
{
    return sys_futex(addr, FUTEX_WAKE_PRIVATE, nr, NULL, NULL, 0);
}",1,27,linux\thread.c,vlc_futex_wake,,false,56,59,vlc_futex_wake,,,3,"int vlc_futex_wake (void*,int)"
88632,METHOD,linux\thread.c:<global>,TYPE_DECL,"static int vlc_futex_wait(void *addr, unsigned val, const struct timespec *to)
{
    return sys_futex(addr, FUTEX_WAIT_PRIVATE, val, to, NULL, 0);
}",1,27,linux\thread.c,vlc_futex_wait,,false,61,64,vlc_futex_wait,,,4,"int vlc_futex_wait (void*,unsigned,timespec*)"
88649,METHOD,linux\thread.c:<global>,TYPE_DECL,"void vlc_addr_signal(void *addr)
{
    vlc_futex_wake(addr, 1);
}",1,1,linux\thread.c,vlc_addr_signal,,false,66,69,vlc_addr_signal,,,5,void vlc_addr_signal (void*)
88657,METHOD,linux\thread.c:<global>,TYPE_DECL,"void vlc_addr_broadcast(void *addr)
{
    vlc_futex_wake(addr, INT_MAX);
}",1,1,linux\thread.c,vlc_addr_broadcast,,false,71,74,vlc_addr_broadcast,,,6,void vlc_addr_broadcast (void*)
88665,METHOD,linux\thread.c:<global>,TYPE_DECL,"void vlc_addr_wait(void *addr, unsigned val)
{
    vlc_futex_wait(addr, val, NULL);
}",1,1,linux\thread.c,vlc_addr_wait,,false,76,79,vlc_addr_wait,,,7,"void vlc_addr_wait (void*,unsigned)"
88675,METHOD,linux\thread.c:<global>,TYPE_DECL,"bool vlc_addr_timedwait(void *addr, unsigned val, mtime_t delay)
{
    lldiv_t d = lldiv(delay, CLOCK_FREQ);
    struct timespec ts = { d.quot, d.rem * (1000000000 / CLOCK_FREQ) };

    return (vlc_futex_wait(addr, val, &ts) == 0 || errno != ETIMEDOUT);
}",1,1,linux\thread.c,vlc_addr_timedwait,,false,81,87,vlc_addr_timedwait,,,8,"bool vlc_addr_timedwait (void*,unsigned,mtime_t)"
88739,METHOD,misc\actions.c:<global>,TYPE_DECL,<global>,1,25,misc\actions.c,misc\actions.c:<global>,,false,1,642,<global>,,,1,
88744,METHOD,<empty>,<empty>,<empty>,1,,misc\actions.c,key_descriptor:<clinit>,,false,46,,<clinit>,,,3,
89022,METHOD,misc\actions.c:<global>,TYPE_DECL,"static int keystrcmp (const void *key, const void *elem)
{
    const char *sa = key, *sb = elem;
    return strcmp (sa, sb);
}",1,1,misc\actions.c,keystrcmp,,false,122,126,keystrcmp,,,4,"int keystrcmp (void*,void*)"
89040,METHOD,misc\actions.c:<global>,TYPE_DECL,"static char *utf8_cp (uint_fast32_t cp, char *buf)
{
    if (cp < (1 << 7))
    {
        buf[1] = 0;
        buf[0] = cp;
    }
    else if (cp < (1 << 11))
    {
        buf[2] = 0;
        buf[1] = 0x80 | (cp & 0x3F);
        cp >>= 6;
        buf[0] = 0xC0 | cp;
    }
    else if (cp < (1 << 16))
    {
        buf[3] = 0;
        buf[2] = 0x80 | (cp & 0x3F);
        cp >>= 6;
        buf[1] = 0x80 | (cp & 0x3F);
        cp >>= 6;
        buf[0] = 0xE0 | cp;
    }
    else if (cp < (1 << 21))
    {
        buf[4] = 0;
        buf[3] = 0x80 | (cp & 0x3F);
        cp >>= 6;
        buf[2] = 0x80 | (cp & 0x3F);
        cp >>= 6;
        buf[1] = 0x80 | (cp & 0x3F);
        cp >>= 6;
        buf[0] = 0xE0 | cp;
    }
    else
        return NULL;
    return buf;
}",1,1,misc\actions.c,utf8_cp,,false,129,166,utf8_cp,,,5,"char* utf8_cp (uint_fast32_t,char*)"
89204,METHOD,misc\actions.c:<global>,TYPE_DECL,"uint_fast32_t vlc_str2keycode (const char *name)
{
    uint_fast32_t mods = 0;
    uint32_t code;

    for (;;)
    {
        size_t len = strcspn (name, ""-+"");
        if (len == 0 || name[len] == '\0')
            break;

        if (len == 4 && !strncasecmp (name, ""Ctrl"", 4))
            mods |= KEY_MODIFIER_CTRL;
        if (len == 3 && !strncasecmp (name, ""Alt"", 3))
            mods |= KEY_MODIFIER_ALT;
        if (len == 5 && !strncasecmp (name, ""Shift"", 5))
            mods |= KEY_MODIFIER_SHIFT;
        if (len == 4 && !strncasecmp (name, ""Meta"", 4))
            mods |= KEY_MODIFIER_META;
        if (len == 7 && !strncasecmp (name, ""Command"", 7))
            mods |= KEY_MODIFIER_COMMAND;

        name += len + 1;
    }

    struct key_descriptor *d = bsearch (name, s_keys, KEYS_COUNT,
                                        sizeof (s_keys[0]), keystrcmp);
    if (d != NULL)
        code = d->i_code;
    else
    if (vlc_towc (name, &code) <= 0)
        code = KEY_UNSET;

   ...",1,54,misc\actions.c,vlc_str2keycode,,false,175,211,vlc_str2keycode,,,6,uint_fast32_t vlc_str2keycode (char*)
89363,METHOD,misc\actions.c:<global>,TYPE_DECL,"static char *nooptext (const char *txt)
{
    return (char *)txt;
}",1,1,misc\actions.c,nooptext,,false,213,216,nooptext,,,7,char* nooptext (char*)
89372,METHOD,misc\actions.c:<global>,TYPE_DECL,"char *vlc_keycode2str (uint_fast32_t code, bool locale)
{
    char *(*tr) (const char *) = locale ? vlc_gettext : nooptext;
    const char *name;
    char *str, buf[5];
    uintptr_t key = code & ~KEY_MODIFIER;

    for (size_t i = 0; i < KEYS_COUNT; i++)
        if (s_keys[i].i_code == key)
        {
            name = s_keys[i].psz;
            goto found;
        }

    if (utf8_cp (key, buf) == NULL)
        return NULL;
    name = buf;

found:
    if (asprintf (&str, ""%s%s%s%s%s%s"",
                  (code & KEY_MODIFIER_CTRL) ? tr(N_(""Ctrl+"")) : """",
                  (code & KEY_MODIFIER_ALT) ? tr(N_(""Alt+"")) : """",
                  (code & KEY_MODIFIER_SHIFT) ? tr(N_(""Shift+"")) : """",
                  (code & KEY_MODIFIER_META) ? tr(N_(""Meta+"")) : """",
                  (code & KEY_MODIFIER_COMMAND) ? tr(N_(""Command+"")) : """",
                  tr(name)) == -1)
        return NULL;
    return str;
}",1,27,misc\actions.c,vlc_keycode2str,,false,226,254,vlc_keycode2str,,,8,"char* vlc_keycode2str (uint_fast32_t,bool)"
89376,METHOD,misc\actions.c:<global>,TYPE_DECL,char *(*tr) (const char *) = locale ? vlc_gettext : nooptext;,10,64,misc\actions.c,vlc_keycode2str.tr,,false,228,228,tr,,,1,char* vlc_keycode2str.tr (char*)
89500,METHOD,<empty>,<empty>,<empty>,1,,misc\actions.c,name2action:<clinit>,,false,260,,<clinit>,,,3,
89848,METHOD,misc\actions.c:<global>,TYPE_DECL,"static int keycmp (const void *a, const void *b)
{
    const struct mapping *ka = a, *kb = b;

    return (ka->key < kb->key) ? -1 : (ka->key > kb->key) ? +1 : 0;
}",1,1,misc\actions.c,keycmp,,false,387,392,keycmp,,,13,"int keycmp (void*,void*)"
89888,METHOD,<empty>,<empty>,<empty>,1,,misc\actions.c,vlc_actions_t:<clinit>,,false,394,,<clinit>,,,4,
89893,METHOD,misc\actions.c:<global>,TYPE_DECL,"static int vlc_key_to_action (vlc_object_t *obj, const char *varname,
                              vlc_value_t prevkey, vlc_value_t curkey, void *d)
{
    void *const *map = d;
    const struct mapping **pent;
    uint32_t keycode = curkey.i_int;

    pent = tfind (&keycode, map, keycmp);
    if (pent == NULL)
        return VLC_SUCCESS;

    (void) varname;
    (void) prevkey;
    return var_SetInteger (obj, ""key-action"", (*pent)->action);
}",1,1,misc\actions.c,vlc_key_to_action,,false,401,415,vlc_key_to_action,,,15,"int vlc_key_to_action (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
89941,METHOD,misc\actions.c:<global>,TYPE_DECL,"static int add_mapping (void **map, uint32_t keycode, vlc_action_id_t action)
{
    struct mapping *entry = malloc (sizeof (*entry));
    if (entry == NULL)
        return ENOMEM;
    entry->key = keycode;
    entry->action = action;

    struct mapping **pent = tsearch (entry, map, keycmp);
    if (unlikely(pent == NULL))
        return ENOMEM;
    if (*pent != entry)
    {
        free (entry);
        return EEXIST;
    }
    return 0;
}",1,1,misc\actions.c,add_mapping,,false,420,437,add_mapping,,,16,"int add_mapping (void**,uint32_t,vlc_action_id_t)"
89999,METHOD,misc\actions.c:<global>,TYPE_DECL,"static void add_wheel_mapping (void **map, uint32_t kmore, uint32_t kless,
                                 int mode)
{
    vlc_action_id_t amore = ACTIONID_NONE, aless = ACTIONID_NONE;

    switch (mode)
    {
        case 0: /* volume up/down */
            amore = ACTIONID_COMBO_VOL_FOV_UP;
            aless = ACTIONID_COMBO_VOL_FOV_DOWN;
            break;
        case 2: /* position latter/earlier */
            amore = ACTIONID_JUMP_FORWARD_EXTRASHORT;
            aless = ACTIONID_JUMP_BACKWARD_EXTRASHORT;
            break;
        case 3: /* position earlier/latter */
            amore = ACTIONID_JUMP_BACKWARD_EXTRASHORT;
            aless = ACTIONID_JUMP_FORWARD_EXTRASHORT;
            break;
    }

    if (amore != ACTIONID_NONE)
        add_mapping (map, kmore, amore);
    if (aless != ACTIONID_NONE)
        add_mapping (map, kless, aless);
}",1,1,misc\actions.c,add_wheel_mapping,,false,439,464,add_wheel_mapping,,,17,"void add_wheel_mapping (void**,uint32_t,uint32_t,int)"
90063,METHOD,misc\actions.c:<global>,TYPE_DECL,"static void init_action (vlc_object_t *obj, void **map,
                            const char *confname, vlc_action_id_t action)
{
    char *keys = var_InheritString (obj, confname);
    if (keys == NULL)
        return;

    for (char *buf, *key = strtok_r (keys, ""\t"", &buf);
         key != NULL;
         key = strtok_r (NULL, ""\t"", &buf))
    {
        uint32_t code = vlc_str2keycode (key);
        if (code == KEY_UNSET)
        {
            msg_Warn (obj, ""Key \""%s\"" unrecognized"", key);
            continue;
        }

        if (add_mapping (map, code, action) == EEXIST)
            msg_Warn (obj, ""Key \""%s\"" bound to multiple actions"", key);
    }
    free (keys);
}",1,1,misc\actions.c,init_action,,false,473,495,init_action,,,18,"void init_action (vlc_object_t*,void**,char*,vlc_action_id_t)"
90134,METHOD,misc\actions.c:<global>,TYPE_DECL,"int libvlc_InternalActionsInit (libvlc_int_t *libvlc)
{
    assert(libvlc != NULL);

    vlc_object_t *obj = VLC_OBJECT(libvlc);
    vlc_actions_t *as = malloc (sizeof (*as) + (1 + ACTIONS_COUNT)
                      * sizeof (*as->ppsz_keys));

    if (unlikely(as == NULL))
        return VLC_ENOMEM;
    as->map = NULL;
    as->global_map = NULL;

    var_Create (obj, ""key-pressed"", VLC_VAR_INTEGER);
    var_Create (obj, ""global-key-pressed"", VLC_VAR_INTEGER);
    var_Create (obj, ""key-action"", VLC_VAR_INTEGER);

    /* Initialize from configuration */
    for (size_t i = 0; i < ACTIONS_COUNT; i++)
    {
#ifndef NDEBUG
        if (i > 0
         && strcmp (s_names2actions[i-1].psz, s_names2actions[i].psz) >= 0)
        {
            msg_Err (libvlc, ""key-%s and key-%s are not ordered properly"",
                     s_names2actions[i-1].psz, s_names2actions[i].psz);
            abort ();
        }
#endif
        as->ppsz_keys[i] = s_names2actions[i].psz;

        char name[12 + MAX...",1,52,misc\actions.c,libvlc_InternalActionsInit,,false,500,550,libvlc_InternalActionsInit,,,19,int libvlc_InternalActionsInit (libvlc_int_t*)
90367,METHOD,misc\actions.c:<global>,TYPE_DECL,"void libvlc_InternalActionsClean (libvlc_int_t *libvlc)
{
    assert(libvlc != NULL);

    vlc_actions_t *as = libvlc_priv(libvlc)->actions;
    if (unlikely(as == NULL))
        return;

    var_DelCallback (libvlc, ""global-key-pressed"", vlc_key_to_action,
                     &as->global_map);
    var_DelCallback (libvlc, ""key-pressed"", vlc_key_to_action, &as->map);

    tdestroy (as->global_map, free);
    tdestroy (as->map, free);
    free (as);
    libvlc_priv(libvlc)->actions = NULL;
}",1,1,misc\actions.c,libvlc_InternalActionsClean,,false,555,571,libvlc_InternalActionsClean,,,20,void libvlc_InternalActionsClean (libvlc_int_t*)
90424,METHOD,misc\actions.c:<global>,TYPE_DECL,"static int actcmp(const void *key, const void *ent)
{
    const struct name2action *act = ent;
    return strcmp(key, act->psz);
}",1,1,misc\actions.c,actcmp,,false,574,578,actcmp,,,21,"int actcmp (void*,void*)"
90440,METHOD,misc\actions.c:<global>,TYPE_DECL,"vlc_action_id_t
vlc_actions_get_id (const char *name)
{
    const struct name2action *act;

    if (strncmp (name, ""key-"", 4))
        return ACTIONID_NONE;
    name += 4;

    act = bsearch(name, s_names2actions, ACTIONS_COUNT, sizeof(*act), actcmp);
    return (act != NULL) ? act->id : ACTIONID_NONE;
}",1,41,misc\actions.c,vlc_actions_get_id,,false,584,595,vlc_actions_get_id,,,22,vlc_action_id_t vlc_actions_get_id (char*)
90484,METHOD,misc\actions.c:<global>,TYPE_DECL,"size_t
vlc_actions_get_keycodes(vlc_object_t *p_obj, const char *psz_key_name,
                        bool b_global, uint_fast32_t **pp_keycodes)
{
    char varname[12 /* ""global-key-"" */ + strlen( psz_key_name )];
    sprintf( varname, ""%skey-%s"", b_global ? ""global-"" : """", psz_key_name );

    *pp_keycodes = NULL;

    char *psz_keys = var_InheritString( p_obj, varname );
    if( psz_keys == NULL )
        return 0;

    size_t i_nb_keycodes = 0;
    for( const char* psz_it = psz_keys; *psz_it; ++psz_it )
    {
        if( *psz_it == '\t' )
            ++i_nb_keycodes;
    }
    ++i_nb_keycodes;
    *pp_keycodes = vlc_alloc( i_nb_keycodes, sizeof( **pp_keycodes ) );
    if( unlikely( !*pp_keycodes ) )
    {
        free( psz_keys );
        return 0;
    }
    size_t i = 0;
    for( char *buf, *key = strtok_r( psz_keys, ""\t"", &buf );
         key != NULL;
         key = strtok_r( NULL, ""\t"", &buf ), ++i )
    {
        (*pp_keycodes)[i] = vlc_str2keycode( key );
    }
    assert(...",1,1,misc\actions.c,vlc_actions_get_keycodes,,false,598,634,vlc_actions_get_keycodes,,,23,"size_t vlc_actions_get_keycodes (vlc_object_t*,char*,bool,uint_fast32_t**)"
90606,METHOD,misc\actions.c:<global>,TYPE_DECL,"const char* const*
vlc_actions_get_key_names(vlc_object_t *p_obj)
{
    vlc_actions_t *as = libvlc_priv(p_obj->obj.libvlc)->actions;
    return as->ppsz_keys;
}",1,1,misc\actions.c,vlc_actions_get_key_names,,false,637,642,vlc_actions_get_key_names,,,24,const char* const* vlc_actions_get_key_names (vlc_object_t*)
90645,METHOD,misc\addons.c:<global>,TYPE_DECL,<global>,1,27,misc\addons.c,misc\addons.c:<global>,,false,1,566,<global>,,,1,
90659,METHOD,addons_manager_private_t.finder,TYPE_DECL,DECL_ARRAY(char*),19,25,misc\addons.c,addons_manager_private_t.finder.,,false,55,55,,,,6,DECL_ARRAY addons_manager_private_t.finder. (char*)
90666,METHOD,addons_manager_private_t.finder,TYPE_DECL,DECL_ARRAY(addon_entry_t*),19,34,misc\addons.c,addons_manager_private_t.finder.,,false,56,56,,,,9,DECL_ARRAY addons_manager_private_t.finder. (addon_entry_t*)
90680,METHOD,addons_manager_private_t.installer,TYPE_DECL,DECL_ARRAY(addon_entry_t*),19,34,misc\addons.c,addons_manager_private_t.installer.,,false,66,66,,,,6,DECL_ARRAY addons_manager_private_t.installer. (addon_entry_t*)
90688,METHOD,misc\addons.c:<global>,TYPE_DECL,static void *FinderThread( void * );,13,35,misc\addons.c,FinderThread,,false,70,70,FinderThread,,,4,void* FinderThread (void*)
90693,METHOD,misc\addons.c:<global>,TYPE_DECL,static void LoadLocalStorage( addons_manager_t *p_manager );,13,59,misc\addons.c,LoadLocalStorage,,false,71,71,LoadLocalStorage,,,5,void LoadLocalStorage (addons_manager_t*)
90698,METHOD,misc\addons.c:<global>,TYPE_DECL,"addon_entry_t * addon_entry_New(void)
{
    addon_entry_owner_t *owner = calloc( 1, sizeof(addon_entry_owner_t) );
    if( unlikely(owner == NULL) )
        return NULL;

    atomic_init( &owner->refs, 1 );

    addon_entry_t *p_entry = &owner->entry;
    vlc_mutex_init( &p_entry->lock );
    ARRAY_INIT( p_entry->files );
    return p_entry;
}",1,1,misc\addons.c,addon_entry_New,,false,77,89,addon_entry_New,,,6,addon_entry_t addon_entry_New (void)
90742,METHOD,misc\addons.c:<global>,TYPE_DECL,"addon_entry_t * addon_entry_Hold( addon_entry_t * p_entry )
{
    addon_entry_owner_t *owner = (addon_entry_owner_t *) p_entry;

    atomic_fetch_add( &owner->refs, 1 );
    return p_entry;
}",1,1,misc\addons.c,addon_entry_Hold,,false,91,97,addon_entry_Hold,,,7,addon_entry_t addon_entry_Hold (addon_entry_t*)
90761,METHOD,misc\addons.c:<global>,TYPE_DECL,"void addon_entry_Release( addon_entry_t * p_entry )
{
    addon_entry_owner_t *owner = (addon_entry_owner_t *) p_entry;

    if( atomic_fetch_sub(&owner->refs, 1) != 1 )
        return;

    free( p_entry->psz_name );
    free( p_entry->psz_summary );
    free( p_entry->psz_description );
    free( p_entry->psz_archive_uri );
    free( p_entry->psz_author );
    free( p_entry->psz_source_uri );
    free( p_entry->psz_image_uri );
    free( p_entry->psz_image_data );
    free( p_entry->psz_source_module );
    free( p_entry->psz_version );
    free( p_entry->p_custom );

    addon_file_t *p_file;
    FOREACH_ARRAY( p_file, p_entry->files )
    free( p_file->psz_filename );
    free( p_file->psz_download_uri );
    free( p_file );
    FOREACH_END()
    ARRAY_RESET( p_entry->files );

    vlc_mutex_destroy( &p_entry->lock );
    free( owner );
}",1,1,misc\addons.c,addon_entry_Release,,false,99,128,addon_entry_Release,,,8,void addon_entry_Release (addon_entry_t*)
90857,METHOD,misc\addons.c:<global>,TYPE_DECL,"addons_manager_t *addons_manager_New( vlc_object_t *p_this,
    const struct addons_manager_owner *restrict owner )
{
    addons_manager_t *p_manager = malloc( sizeof(addons_manager_t) );
    if ( !p_manager ) return NULL;

    p_manager->p_priv = malloc( sizeof(addons_manager_private_t) );
    if ( !p_manager->p_priv )
    {
        free( p_manager );
        return NULL;
    }

    p_manager->owner = *owner;
    p_manager->p_priv->p_parent = p_this;

    p_manager->p_priv->finder.p_interrupt = vlc_interrupt_create();
    p_manager->p_priv->installer.p_interrupt = vlc_interrupt_create();
    if ( !p_manager->p_priv->finder.p_interrupt ||
         !p_manager->p_priv->installer.p_interrupt )
    {
        if( p_manager->p_priv->finder.p_interrupt )
            vlc_interrupt_destroy( p_manager->p_priv->finder.p_interrupt );
        if( p_manager->p_priv->installer.p_interrupt )
            vlc_interrupt_destroy( p_manager->p_priv->installer.p_interrupt );
        free( p_manager->p_pr...",1,4,misc\addons.c,addons_manager_New,,false,130,171,addons_manager_New,,,9,"addons_manager_t addons_manager_New (vlc_object_t*,addons_manager_owner*)"
91068,METHOD,misc\addons.c:<global>,TYPE_DECL,"void addons_manager_Delete( addons_manager_t *p_manager )
{
    bool b_live;

    vlc_mutex_lock( &p_manager->p_priv->finder.lock );
    b_live = p_manager->p_priv->finder.b_live;
    vlc_mutex_unlock( &p_manager->p_priv->finder.lock );
    if ( b_live )
    {
        vlc_interrupt_kill( p_manager->p_priv->finder.p_interrupt );
        vlc_join( p_manager->p_priv->finder.thread, NULL );
    }

    vlc_mutex_lock( &p_manager->p_priv->installer.lock );
    b_live = p_manager->p_priv->installer.b_live;
    vlc_mutex_unlock( &p_manager->p_priv->installer.lock );
    if ( b_live )
    {
        vlc_interrupt_kill( p_manager->p_priv->installer.p_interrupt );
        vlc_join( p_manager->p_priv->installer.thread, NULL );
    }

#define FREE_QUEUE( name ) \
    FOREACH_ARRAY( addon_entry_t *p_entry, p_manager->p_priv->name.entries )\
        addon_entry_Release( p_entry );\
    FOREACH_END();\
    ARRAY_RESET( p_manager->p_priv->name.entries );\
    vlc_mutex_destroy( &p_manager->p_priv->na...",1,4,misc\addons.c,addons_manager_Delete,,false,173,213,addons_manager_Delete,,,10,void addons_manager_Delete (addons_manager_t*)
91286,METHOD,misc\addons.c:<global>,TYPE_DECL,"void addons_manager_Gather( addons_manager_t *p_manager, const char *psz_uri )
{
    if ( !psz_uri )
        return;

    vlc_mutex_lock( &p_manager->p_priv->finder.lock );

    ARRAY_APPEND( p_manager->p_priv->finder.uris, strdup( psz_uri ) );

    if( !p_manager->p_priv->finder.b_live )
    {
        if( vlc_clone( &p_manager->p_priv->finder.thread, FinderThread, p_manager,
                       VLC_THREAD_PRIORITY_LOW ) )
        {
            msg_Err( p_manager->p_priv->p_parent,
                     ""cannot spawn entries provider thread"" );
            vlc_mutex_unlock( &p_manager->p_priv->finder.lock );
            return;
        }
        p_manager->p_priv->finder.b_live = true;
    }

    vlc_mutex_unlock( &p_manager->p_priv->finder.lock );
    vlc_cond_signal( &p_manager->p_priv->finder.waitcond );
}",1,1,misc\addons.c,addons_manager_Gather,,false,215,239,addons_manager_Gather,,,11,"void addons_manager_Gather (addons_manager_t*,char*)"
91384,METHOD,misc\addons.c:<global>,TYPE_DECL,"static addon_entry_t * getHeldEntryByUUID( addons_manager_t *p_manager,
                                           const addon_uuid_t uuid )
{
    addon_entry_t *p_return = NULL;
    vlc_mutex_lock( &p_manager->p_priv->finder.lock );
    FOREACH_ARRAY( addon_entry_t *p_entry, p_manager->p_priv->finder.entries )
    if ( !memcmp( p_entry->uuid, uuid, sizeof( addon_uuid_t ) ) )
    {
        p_return = p_entry;
        addon_entry_Hold( p_return );
        break;
    }
    FOREACH_END()
    vlc_mutex_unlock( &p_manager->p_priv->finder.lock );
    return p_return;
}",1,1,misc\addons.c,getHeldEntryByUUID,,false,245,260,getHeldEntryByUUID,,,12,"addon_entry_t getHeldEntryByUUID (addons_manager_t*,addon_uuid_t)"
91444,METHOD,misc\addons.c:<global>,TYPE_DECL,"static void MergeSources( addons_manager_t *p_manager,
                          addon_entry_t **pp_addons, int i_count )
{
    addon_entry_t *p_entry, *p_manager_entry;
    addon_uuid_t zerouuid;
    memset( zerouuid, 0, sizeof( addon_uuid_t ) );
    for ( int i=0; i < i_count; i++ )
    {
        p_entry = pp_addons[i];
        vlc_mutex_lock( &p_entry->lock );
        if ( memcmp( p_entry->uuid, zerouuid, sizeof( addon_uuid_t ) ) )
            p_manager_entry = getHeldEntryByUUID( p_manager, p_entry->uuid );
        else
            p_manager_entry = NULL;
        if ( !p_manager_entry )
        {
            ARRAY_APPEND( p_manager->p_priv->finder.entries, p_entry );
            p_manager->owner.addon_found( p_manager, p_entry );
        }
        else
        {
            vlc_mutex_lock( &p_manager_entry->lock );
            if ( ( p_manager_entry->psz_version && p_entry->psz_version )
                 && /* FIXME: better version comparison */
                 strcmp( p_manage...",1,1,misc\addons.c,MergeSources,,false,262,296,MergeSources,,,13,"void MergeSources (addons_manager_t*,addon_entry_t**,int)"
91564,METHOD,misc\addons.c:<global>,TYPE_DECL,"static void LoadLocalStorage( addons_manager_t *p_manager )
{
    addons_finder_t *p_finder =
        vlc_custom_create( p_manager->p_priv->p_parent, sizeof( *p_finder ), ""entries finder"" );
    p_finder->obj.flags |= OBJECT_FLAGS_NOINTERACT;

    module_t *p_module = module_need( p_finder, ""addons finder"",
                                      ""addons.store.list"", true );
    if( p_module )
    {
        ARRAY_INIT( p_finder->entries );
        p_finder->psz_uri = NULL;
        p_finder->pf_find( p_finder );
        module_unneed( p_finder, p_module );

        MergeSources( p_manager, p_finder->entries.p_elems, p_finder->entries.i_size );

        ARRAY_RESET( p_finder->entries );
    }
    vlc_object_release( p_finder );
}",1,8,misc\addons.c,LoadLocalStorage,,false,298,318,LoadLocalStorage,,,14,void LoadLocalStorage (addons_manager_t*)
91643,METHOD,misc\addons.c:<global>,TYPE_DECL,"static void finder_thread_interrupted( void* p_data )
{
    addons_manager_t *p_manager = p_data;
    vlc_mutex_lock( &p_manager->p_priv->finder.lock );
    p_manager->p_priv->finder.b_live = false;
    vlc_cond_signal( &p_manager->p_priv->finder.waitcond );
    vlc_mutex_unlock( &p_manager->p_priv->finder.lock );
}",1,1,misc\addons.c,finder_thread_interrupted,,false,320,327,finder_thread_interrupted,,,15,void finder_thread_interrupted (void*)
91688,METHOD,misc\addons.c:<global>,TYPE_DECL,"static void *FinderThread( void *p_data )
{
    addons_manager_t *p_manager = p_data;
    int i_cancel = vlc_savecancel();
    vlc_interrupt_set( p_manager->p_priv->finder.p_interrupt );

    vlc_mutex_lock( &p_manager->p_priv->finder.lock );
    while( p_manager->p_priv->finder.b_live )
    {
        char *psz_uri;

        vlc_interrupt_register( finder_thread_interrupted, p_data );
        while( p_manager->p_priv->finder.uris.i_size == 0 &&
               p_manager->p_priv->finder.b_live )
        {
            vlc_cond_wait( &p_manager->p_priv->finder.waitcond,
                           &p_manager->p_priv->finder.lock );
        }
        vlc_interrupt_unregister();
        if( !p_manager->p_priv->finder.b_live )
            break;
        psz_uri = p_manager->p_priv->finder.uris.p_elems[0];
        ARRAY_REMOVE( p_manager->p_priv->finder.uris, 0 );

        vlc_mutex_unlock( &p_manager->p_priv->finder.lock );

        addons_finder_t *p_finder =
                vlc_custom_cre...",1,16,misc\addons.c,FinderThread,,false,329,384,FinderThread,,,16,void* FinderThread (void*)
91922,METHOD,misc\addons.c:<global>,TYPE_DECL,"static int addons_manager_WriteCatalog( addons_manager_t *p_manager )
{
    int i_return = VLC_EGENERIC;

    addons_storage_t *p_storage =
        vlc_custom_create( p_manager->p_priv->p_parent, sizeof( *p_storage ), ""entries storage"" );
    p_storage->obj.flags |= OBJECT_FLAGS_NOINTERACT;

    module_t *p_module = module_need( p_storage, ""addons storage"",
                                      ""addons.store.install"", true );
    if( p_module )
    {
        vlc_mutex_lock( &p_manager->p_priv->finder.lock );
        i_return = p_storage->pf_catalog( p_storage, p_manager->p_priv->finder.entries.p_elems,
                                          p_manager->p_priv->finder.entries.i_size );
        vlc_mutex_unlock( &p_manager->p_priv->finder.lock );
        module_unneed( p_storage, p_module );
    }
    vlc_object_release( p_storage );

    return i_return;
}",1,8,misc\addons.c,addons_manager_WriteCatalog,,false,386,407,addons_manager_WriteCatalog,,,17,int addons_manager_WriteCatalog (addons_manager_t*)
92020,METHOD,misc\addons.c:<global>,TYPE_DECL,"int addons_manager_LoadCatalog( addons_manager_t *p_manager )
{
    LoadLocalStorage( p_manager );
    return VLC_SUCCESS;
}",1,1,misc\addons.c,addons_manager_LoadCatalog,,false,409,413,addons_manager_LoadCatalog,,,18,int addons_manager_LoadCatalog (addons_manager_t*)
92029,METHOD,misc\addons.c:<global>,TYPE_DECL,"static int installOrRemoveAddon( addons_manager_t *p_manager, addon_entry_t *p_entry, bool b_install )
{
    int i_return = VLC_EGENERIC;

    addons_storage_t *p_storage =
        vlc_custom_create( p_manager->p_priv->p_parent, sizeof( *p_storage ), ""entries storage"" );
    p_storage->obj.flags |= OBJECT_FLAGS_NOINTERACT;

    module_t *p_module = module_need( p_storage, ""addons storage"",
                                      ""addons.store.install"", true );
    if( p_module )
    {
        if ( b_install )
            i_return = p_storage->pf_install( p_storage, p_entry );
        else
            i_return = p_storage->pf_remove( p_storage, p_entry );
        module_unneed( p_storage, p_module );
        msg_Dbg( p_manager->p_priv->p_parent, ""InstallAddon returns %d"", i_return );
        if ( i_return == VLC_SUCCESS )
        {
            /* Reset flags */
            vlc_mutex_lock( &p_entry->lock );
            p_entry->e_flags = ADDON_MANAGEABLE;
            vlc_mutex_unlock( &...",1,8,misc\addons.c,installOrRemoveAddon,,false,415,444,installOrRemoveAddon,,,19,"int installOrRemoveAddon (addons_manager_t*,addon_entry_t*,bool)"
92135,METHOD,misc\addons.c:<global>,TYPE_DECL,"static void installer_thread_interrupted( void* p_data )
{
    addons_manager_t *p_manager = p_data;
    vlc_mutex_lock( &p_manager->p_priv->installer.lock );
    p_manager->p_priv->installer.b_live = false;
    vlc_cond_signal( &p_manager->p_priv->installer.waitcond );
    vlc_mutex_unlock( &p_manager->p_priv->installer.lock );
}",1,1,misc\addons.c,installer_thread_interrupted,,false,446,453,installer_thread_interrupted,,,20,void installer_thread_interrupted (void*)
92180,METHOD,misc\addons.c:<global>,TYPE_DECL,"static void *InstallerThread( void *p_data )
{
    addons_manager_t *p_manager = p_data;
    int i_cancel = vlc_savecancel();
    vlc_interrupt_set( p_manager->p_priv->installer.p_interrupt );
    int i_ret;

    vlc_mutex_lock( &p_manager->p_priv->installer.lock );
    while( p_manager->p_priv->installer.b_live )
    {
        vlc_interrupt_register( installer_thread_interrupted, p_data );
        while ( !p_manager->p_priv->installer.entries.i_size &&
                p_manager->p_priv->installer.b_live )
        {
            /* No queued addons */
            vlc_cond_wait( &p_manager->p_priv->installer.waitcond,
                           &p_manager->p_priv->installer.lock );
        }
        vlc_interrupt_unregister();
        if( !p_manager->p_priv->installer.b_live )
            break;

        addon_entry_t *p_entry = p_manager->p_priv->installer.entries.p_elems[0];
        ARRAY_REMOVE( p_manager->p_priv->installer.entries, 0 );
        addon_entry_Hold( p_entry );
       ...",1,1,misc\addons.c,InstallerThread,,false,455,525,InstallerThread,,,21,void* InstallerThread (void*)
92444,METHOD,misc\addons.c:<global>,TYPE_DECL,"static int InstallEntry( addons_manager_t *p_manager, addon_entry_t *p_entry )
{
    if ( p_entry->e_type == ADDON_UNKNOWN ||
         p_entry->e_type == ADDON_PLUGIN ||
         p_entry->e_type == ADDON_OTHER )
        return VLC_EBADVAR;

    vlc_mutex_lock( &p_manager->p_priv->installer.lock );
    ARRAY_APPEND( p_manager->p_priv->installer.entries, p_entry );
    if( !p_manager->p_priv->installer.b_live )
    {
        if( vlc_clone( &p_manager->p_priv->installer.thread, InstallerThread, p_manager,
                       VLC_THREAD_PRIORITY_LOW ) )
        {
            msg_Err( p_manager->p_priv->p_parent,
                     ""cannot spawn addons installer thread"" );
            vlc_mutex_unlock( &p_manager->p_priv->installer.lock );
            return VLC_EGENERIC;
        }
        else
            p_manager->p_priv->installer.b_live = true;
    }
    vlc_mutex_unlock( &p_manager->p_priv->installer.lock );
    vlc_cond_signal( &p_manager->p_priv->installer.waitcond );
    re...",1,1,misc\addons.c,InstallEntry,,false,527,552,InstallEntry,,,22,"int InstallEntry (addons_manager_t*,addon_entry_t*)"
92562,METHOD,misc\addons.c:<global>,TYPE_DECL,"int addons_manager_Install( addons_manager_t *p_manager, const addon_uuid_t uuid )
{
    addon_entry_t *p_install_entry = getHeldEntryByUUID( p_manager, uuid );
    if ( ! p_install_entry ) return VLC_EGENERIC;
    int i_ret = InstallEntry( p_manager, p_install_entry );
    addon_entry_Release( p_install_entry );
    return i_ret;
}",1,1,misc\addons.c,addons_manager_Install,,false,554,561,addons_manager_Install,,,23,"int addons_manager_Install (addons_manager_t*,addon_uuid_t)"
92590,METHOD,misc\addons.c:<global>,TYPE_DECL,"int addons_manager_Remove( addons_manager_t *p_manager, const addon_uuid_t uuid )
{
    return addons_manager_Install( p_manager, uuid );
}",1,1,misc\addons.c,addons_manager_Remove,,false,563,566,addons_manager_Remove,,,24,"int addons_manager_Remove (addons_manager_t*,addon_uuid_t)"
92617,METHOD,misc\background_worker.c:<global>,TYPE_DECL,<global>,1,1,misc\background_worker.c,misc\background_worker.c:<global>,,false,1,267,<global>,,,1,
92640,METHOD,misc\background_worker.c:<global>,TYPE_DECL,"static void* Thread( void* data )
{
    struct background_worker* worker = data;

    for( ;; )
    {
        struct bg_queued_item* item = NULL;
        void* handle;

        vlc_mutex_lock( &worker->lock );
        for( ;; )
        {
            if( vlc_array_count( &worker->tail.data ) )
            {
                item = vlc_array_item_at_index( &worker->tail.data, 0 );
                handle = NULL;

                vlc_array_remove( &worker->tail.data, 0 );
            }

            if( worker->head.deadline == VLC_TS_0 && item == NULL )
                worker->head.active = false;
            worker->head.id = item ? item->id : NULL;
            vlc_cond_broadcast( &worker->head.wait );

            if( item )
            {
                if( item->timeout > 0 )
                    worker->head.deadline = mdate() + item->timeout * 1000;
                else
                    worker->head.deadline = INT64_MAX;
            }
            else if( worker->head.deadline !=...",1,1,misc\background_worker.c,Thread,,false,57,152,Thread,,,3,void* Thread (void*)
92975,METHOD,misc\background_worker.c:<global>,TYPE_DECL,"static void BackgroundWorkerCancel( struct background_worker* worker, void* id)
{
    vlc_mutex_lock( &worker->lock );
    for( size_t i = 0; i < vlc_array_count( &worker->tail.data ); )
    {
        struct bg_queued_item* item =
            vlc_array_item_at_index( &worker->tail.data, i );

        if( id == NULL || item->id == id )
        {
            vlc_array_remove( &worker->tail.data, i );
            worker->conf.pf_release( item->entity );
            free( item );
            continue;
        }

        ++i;
    }

    while( ( id == NULL && worker->head.active )
        || ( id != NULL && worker->head.id == id ) )
    {
        worker->head.deadline = VLC_TS_0;
        vlc_cond_signal( &worker->head.worker_wait );
        vlc_cond_signal( &worker->tail.wait );
        vlc_cond_wait( &worker->head.wait, &worker->lock );
    }
    vlc_mutex_unlock( &worker->lock );
}",1,1,misc\background_worker.c,BackgroundWorkerCancel,,false,154,182,BackgroundWorkerCancel,,,4,"void BackgroundWorkerCancel (background_worker*,void*)"
93106,METHOD,misc\background_worker.c:<global>,TYPE_DECL,"struct background_worker* background_worker_New( void* owner,
    struct background_worker_config* conf )
{
    struct background_worker* worker = malloc( sizeof *worker );

    if( unlikely( !worker ) )
        return NULL;

    worker->conf = *conf;
    worker->owner = owner;
    worker->head.id = NULL;
    worker->head.active = false;
    worker->head.deadline = VLC_TS_INVALID;

    vlc_mutex_init( &worker->lock );
    vlc_cond_init( &worker->head.wait );
    vlc_cond_init( &worker->head.worker_wait );

    vlc_array_init( &worker->tail.data );
    vlc_cond_init( &worker->tail.wait );

    return worker;
}",1,1,misc\background_worker.c,background_worker_New,,false,184,206,background_worker_New,,,5,"struct background_worker background_worker_New (void*,background_worker_config*)"
93193,METHOD,misc\background_worker.c:<global>,TYPE_DECL,"int background_worker_Push( struct background_worker* worker, void* entity,
                        void* id, int timeout )
{
    struct bg_queued_item* item = malloc( sizeof( *item ) );

    if( unlikely( !item ) )
        return VLC_EGENERIC;

    item->id = id;
    item->entity = entity;
    item->timeout = timeout < 0 ? worker->conf.default_timeout : timeout;

    vlc_mutex_lock( &worker->lock );
    int i_ret = vlc_array_append( &worker->tail.data, item );
    vlc_cond_signal( &worker->tail.wait );
    if( i_ret != 0 )
    {
        free( item );
        return VLC_EGENERIC;
    }

    if( worker->head.active == false )
    {
        worker->head.probe_request = false;
        worker->head.active =
            !vlc_clone_detach( NULL, Thread, worker, VLC_THREAD_PRIORITY_LOW );
    }

    if( worker->head.active )
        worker->conf.pf_hold( item->entity );

    int ret = worker->head.active ? VLC_SUCCESS : VLC_EGENERIC;
    vlc_mutex_unlock( &worker->lock );

    return ret;
}",1,1,misc\background_worker.c,background_worker_Push,,false,208,243,background_worker_Push,,,6,"int background_worker_Push (background_worker*,void*,void*,int)"
93333,METHOD,misc\background_worker.c:<global>,TYPE_DECL,"void background_worker_Cancel( struct background_worker* worker, void* id )
{
    BackgroundWorkerCancel( worker, id );
}",1,1,misc\background_worker.c,background_worker_Cancel,,false,245,248,background_worker_Cancel,,,7,"void background_worker_Cancel (background_worker*,void*)"
93342,METHOD,misc\background_worker.c:<global>,TYPE_DECL,"void background_worker_RequestProbe( struct background_worker* worker )
{
    vlc_mutex_lock( &worker->lock );
    worker->head.probe_request = true;
    vlc_cond_signal( &worker->head.worker_wait );
    vlc_mutex_unlock( &worker->lock );
}",1,1,misc\background_worker.c,background_worker_RequestProbe,,false,250,256,background_worker_RequestProbe,,,8,void background_worker_RequestProbe (background_worker*)
93371,METHOD,misc\background_worker.c:<global>,TYPE_DECL,"void background_worker_Delete( struct background_worker* worker )
{
    BackgroundWorkerCancel( worker, NULL );
    vlc_array_clear( &worker->tail.data );
    vlc_mutex_destroy( &worker->lock );
    vlc_cond_destroy( &worker->head.wait );
    vlc_cond_destroy( &worker->head.worker_wait );
    vlc_cond_destroy( &worker->tail.wait );
    free( worker );
}",1,1,misc\background_worker.c,background_worker_Delete,,false,258,267,background_worker_Delete,,,9,void background_worker_Delete (background_worker*)
93417,METHOD,misc\background_worker.h:<global>,TYPE_DECL,<global>,1,6,misc\background_worker.h,misc\background_worker.h:<global>,,false,1,183,<global>,,,1,
93421,METHOD,background_worker_config,TYPE_DECL,void( *pf_release )( void* entity );,9,39,misc\background_worker.h,background_worker_config.pf_release,,false,42,42,pf_release,,,2,void background_worker_config.pf_release (void*)
93426,METHOD,background_worker_config,TYPE_DECL,void( *pf_hold )( void* entity );,9,36,misc\background_worker.h,background_worker_config.pf_hold,,false,53,53,pf_hold,,,3,void background_worker_config.pf_hold (void*)
93431,METHOD,background_worker_config,TYPE_DECL,"int( *pf_start )( void* owner, void* entity, void** out );",8,61,misc\background_worker.h,background_worker_config.pf_start,,false,72,72,pf_start,,,4,"int background_worker_config.pf_start (void*,void*,void**)"
93438,METHOD,background_worker_config,TYPE_DECL,"int( *pf_probe )( void* owner, void* handle );",8,49,misc\background_worker.h,background_worker_config.pf_probe,,false,85,85,pf_probe,,,5,"int background_worker_config.pf_probe (void*,void*)"
93444,METHOD,background_worker_config,TYPE_DECL,"void( *pf_stop )( void* owner, void* handle );",9,49,misc\background_worker.h,background_worker_config.pf_stop,,false,101,101,pf_stop,,,6,"void background_worker_config.pf_stop (void*,void*)"
93452,METHOD,misc\background_worker.h:<global>,TYPE_DECL,void background_worker_RequestProbe( struct background_worker* worker );,6,71,misc\background_worker.h,background_worker_RequestProbe,,false,133,133,background_worker_RequestProbe,,,4,void background_worker_RequestProbe (background_worker*)
93457,METHOD,misc\background_worker.h:<global>,TYPE_DECL,"int background_worker_Push( struct background_worker* worker, void* entity,
    void* id, int timeout );",5,27,misc\background_worker.h,background_worker_Push,,false,151,152,background_worker_Push,,,5,"int background_worker_Push (background_worker*,void*,void*,int)"
93465,METHOD,misc\background_worker.h:<global>,TYPE_DECL,"void background_worker_Cancel( struct background_worker* worker, void* id );",6,75,misc\background_worker.h,background_worker_Cancel,,false,168,168,background_worker_Cancel,,,6,"void background_worker_Cancel (background_worker*,void*)"
93471,METHOD,misc\background_worker.h:<global>,TYPE_DECL,void background_worker_Delete( struct background_worker* worker );,6,65,misc\background_worker.h,background_worker_Delete,,false,182,182,background_worker_Delete,,,7,void background_worker_Delete (background_worker*)
93503,METHOD,misc\block.c:<global>,TYPE_DECL,<global>,1,44,misc\block.c,misc\block.c:<global>,,false,1,446,<global>,,,1,
93505,METHOD,misc\block.c:<global>,TYPE_DECL,"static void BlockNoRelease( block_t *b )
{
    fprintf( stderr, ""block %p has no release callback! This is a bug!\n"",
             (void *) b );
    abort();
}",1,1,misc\block.c,BlockNoRelease,,false,39,44,BlockNoRelease,,,1,void BlockNoRelease (block_t*)
93517,METHOD,misc\block.c:<global>,TYPE_DECL,"static void block_Check (block_t *block)
{
    while (block != NULL)
    {
        unsigned char *start = block->p_start;
        unsigned char *end = block->p_start + block->i_size;
        unsigned char *bufstart = block->p_buffer;
        unsigned char *bufend = block->p_buffer + block->i_buffer;

        assert (block->pf_release != BlockNoRelease);
        assert (start <= end);
        assert (bufstart <= bufend);
        assert (bufstart >= start);
        assert (bufend <= end);

        block = block->p_next;
    }
}",1,1,misc\block.c,block_Check,,false,46,63,block_Check,,,2,void block_Check (block_t*)
93586,METHOD,misc\block.c:<global>,TYPE_DECL,"static void block_Invalidate (block_t *block)
{
    block->p_next = NULL;
    block_Check (block);
    block->pf_release = BlockNoRelease;
}",1,1,misc\block.c,block_Invalidate,,false,65,70,block_Invalidate,,,3,void block_Invalidate (block_t*)
93603,METHOD,misc\block.c:<global>,TYPE_DECL,"void block_Init( block_t *restrict b, void *buf, size_t size )
{
    /* Fill all fields to their default */
    b->p_next = NULL;
    b->p_buffer = buf;
    b->i_buffer = size;
    b->p_start = buf;
    b->i_size = size;
    b->i_flags = 0;
    b->i_nb_samples = 0;
    b->i_pts =
    b->i_dts = VLC_TS_INVALID;
    b->i_length = 0;
#ifndef NDEBUG
    b->pf_release = BlockNoRelease;
#endif
}",1,1,misc\block.c,block_Init,,false,76,92,block_Init,,,4,"void block_Init (block_t*,void*,size_t)"
93664,METHOD,misc\block.c:<global>,TYPE_DECL,"static void block_generic_Release (block_t *block)
{
    /* That is always true for blocks allocated with block_Alloc(). */
    assert (block->p_start == (unsigned char *)(block + 1));
    block_Invalidate (block);
    free (block);
}",1,1,misc\block.c,block_generic_Release,,false,94,100,block_generic_Release,,,5,void block_generic_Release (block_t*)
93683,METHOD,misc\block.c:<global>,TYPE_DECL,"static void BlockMetaCopy( block_t *restrict out, const block_t *in )
{
    out->p_next    = in->p_next;
    out->i_nb_samples = in->i_nb_samples;
    out->i_dts     = in->i_dts;
    out->i_pts     = in->i_pts;
    out->i_flags   = in->i_flags;
    out->i_length  = in->i_length;
}",1,1,misc\block.c,BlockMetaCopy,,false,102,110,BlockMetaCopy,,,6,"void BlockMetaCopy (block_t*,block_t*)"
93731,METHOD,misc\block.c:<global>,TYPE_DECL,"block_t *block_Alloc (size_t size)
{
    if (unlikely(size >> 27))
    {
        errno = ENOBUFS;
        return NULL;
    }

    /* 2 * BLOCK_PADDING: pre + post padding */
    const size_t alloc = sizeof (block_t) + BLOCK_ALIGN + (2 * BLOCK_PADDING)
                       + size;
    if (unlikely(alloc <= size))
        return NULL;

    block_t *b = malloc (alloc);
    if (unlikely(b == NULL))
        return NULL;

    block_Init (b, b + 1, alloc - sizeof (*b));
    static_assert ((BLOCK_PADDING % BLOCK_ALIGN) == 0,
                   ""BLOCK_PADDING must be a multiple of BLOCK_ALIGN"");
    b->p_buffer += BLOCK_PADDING + BLOCK_ALIGN - 1;
    b->p_buffer = (void *)(((uintptr_t)b->p_buffer) & ~(BLOCK_ALIGN - 1));
    b->i_buffer = size;
    b->pf_release = block_generic_Release;
    return b;
}",1,44,misc\block.c,block_Alloc,,false,120,146,block_Alloc,,,7,block_t block_Alloc (size_t)
93849,METHOD,misc\block.c:<global>,TYPE_DECL,"block_t *block_TryRealloc (block_t *p_block, ssize_t i_prebody, size_t i_body)
{
    block_Check( p_block );

    /* Corner case: empty block requested */
    if( i_prebody <= 0 && i_body <= (size_t)(-i_prebody) )
        i_prebody = i_body = 0;

    assert( p_block->p_start <= p_block->p_buffer );
    assert( p_block->p_start + p_block->i_size
                                    >= p_block->p_buffer + p_block->i_buffer );

    /* First, shrink payload */

    /* Pull payload start */
    if( i_prebody < 0 )
    {
        if( p_block->i_buffer >= (size_t)-i_prebody )
        {
            p_block->p_buffer -= i_prebody;
            p_block->i_buffer += i_prebody;
        }
        else /* Discard current payload entirely */
            p_block->i_buffer = 0;
        i_body += i_prebody;
        i_prebody = 0;
    }

    /* Trim payload end */
    if( p_block->i_buffer > i_body )
        p_block->i_buffer = i_body;

    size_t requested = i_prebody + i_body;

    if( p_block->i_buffe...",1,1,misc\block.c,block_TryRealloc,,false,148,237,block_TryRealloc,,,8,"block_t block_TryRealloc (block_t*,ssize_t,size_t)"
94110,METHOD,misc\block.c:<global>,TYPE_DECL,"block_t *block_Realloc (block_t *block, ssize_t prebody, size_t body)
{
    block_t *rea = block_TryRealloc (block, prebody, body);
    if (rea == NULL)
        block_Release(block);
    return rea;
}",1,1,misc\block.c,block_Realloc,,false,239,245,block_Realloc,,,9,"block_t block_Realloc (block_t*,ssize_t,size_t)"
94133,METHOD,misc\block.c:<global>,TYPE_DECL,"static void block_heap_Release (block_t *block)
{
    block_Invalidate (block);
    free (block->p_start);
    free (block);
}",1,1,misc\block.c,block_heap_Release,,false,247,252,block_heap_Release,,,10,void block_heap_Release (block_t*)
94146,METHOD,misc\block.c:<global>,TYPE_DECL,"block_t *block_heap_Alloc (void *addr, size_t length)
{
    block_t *block = malloc (sizeof (*block));
    if (block == NULL)
    {
        free (addr);
        return NULL;
    }

    block_Init (block, addr, length);
    block->pf_release = block_heap_Release;
    return block;
}",1,1,misc\block.c,block_heap_Alloc,,false,254,266,block_heap_Alloc,,,11,"block_t block_heap_Alloc (void*,size_t)"
94179,METHOD,misc\block.c:<global>,TYPE_DECL,"block_t *block_mmap_Alloc (void *addr, size_t length)
{
    (void)addr; (void)length; return NULL;
}",1,1,misc\block.c,block_mmap_Alloc,,false,301,304,block_mmap_Alloc,,,12,"block_t block_mmap_Alloc (void*,size_t)"
94193,METHOD,misc\block.c:<global>,TYPE_DECL,"block_t *block_shm_Alloc (void *addr, size_t length)
{
    (void) addr; (void) length;
    abort ();
}",1,1,misc\block.c,block_shm_Alloc,,false,339,343,block_shm_Alloc,,,13,"block_t block_shm_Alloc (void*,size_t)"
94206,METHOD,misc\block.c:<global>,TYPE_DECL,"block_t *block_File(int fd, bool write)
{
    size_t length;
    struct stat st;

    /* First, get the file size */
    if (fstat (fd, &st))
        return NULL;

    /* st_size is meaningful for regular files, shared memory and typed memory.
     * It's also meaning for symlinks, but that's not possible with fstat().
     * In other cases, it's undefined, and we should really not go further. */
#ifndef S_TYPEISSHM
# define S_TYPEISSHM( buf ) (0)
#endif
    if (S_ISDIR (st.st_mode))
    {
        errno = EISDIR;
        return NULL;
    }
    if (!S_ISREG (st.st_mode) && !S_TYPEISSHM (&st))
    {
        errno = ESPIPE;
        return NULL;
    }

    /* Prevent an integer overflow in mmap() and malloc() */
    if ((uintmax_t)st.st_size >= SIZE_MAX)
    {
        errno = ENOMEM;
        return NULL;
    }
    length = (size_t)st.st_size;

#ifdef HAVE_MMAP
    if (length > 0)
    {
        int prot = PROT_READ | (write ? PROT_WRITE : 0);
        int flags = write ? MAP_PRIVATE : MAP...",1,34,misc\block.c,block_File,,false,368,433,block_File,,,14,"block_t block_File (int,bool)"
94327,METHOD,misc\block.c:<global>,TYPE_DECL,"block_t *block_FilePath(const char *path, bool write)
{
    /* NOTE: Writeable shared mappings are not supported here. So there are no
     * needs to open the file for writing (even if the mapping is writable). */
    int fd = vlc_open (path, O_RDONLY);
    if (fd == -1)
        return NULL;

    block_t *block = block_File(fd, write);
    vlc_close (fd);
    return block;
}",1,1,misc\block.c,block_FilePath,,false,435,446,block_FilePath,,,15,"block_t block_FilePath (char*,bool)"
94392,METHOD,misc\cpu.c:<global>,TYPE_DECL,<global>,1,27,misc\cpu.c,misc\cpu.c:<global>,,false,1,336,<global>,,,1,
94395,METHOD,misc\cpu.c:<global>,TYPE_DECL,"void vlc_CPU_init (void)
{
    uint32_t i_capabilities = 0;

#if defined( __i386__ ) || defined( __x86_64__ )
     unsigned int i_eax, i_ebx, i_ecx, i_edx;
     bool b_amd;

    /* Needed for x86 CPU capabilities detection */
# if defined (__i386__) && defined (__PIC__)
#  define cpuid(reg) \
     asm volatile (""xchgl %%ebx,%1\n\t"" \
                   ""cpuid\n\t"" \
                   ""xchgl %%ebx,%1\n\t"" \
                   : ""=a"" (i_eax), ""=r"" (i_ebx), ""=c"" (i_ecx), ""=d"" (i_edx) \
                   : ""a"" (reg) \
                   : ""cc"");
# else
#  define cpuid(reg) \
     asm volatile (""cpuid\n\t"" \
                   : ""=a"" (i_eax), ""=b"" (i_ebx), ""=c"" (i_ecx), ""=d"" (i_edx) \
                   : ""a"" (reg) \
                   : ""cc"");
# endif
     /* Check if the OS really supports the requested instructions */
# if defined (__i386__) && !defined (__i486__) && !defined (__i586__) \
  && !defined (__i686__) && !defined (__pentium4__) \
  && !defined (__k6__) && !defined (__ath...",1,1,misc\cpu.c,vlc_CPU_init,,false,124,264,vlc_CPU_init,,,2,void vlc_CPU_init (void)
94407,METHOD,misc\cpu.c:<global>,TYPE_DECL,"unsigned vlc_CPU (void)
{
/* On Windows and OS/2,
 * initialized from DllMain() and _DLL_InitTerm() respectively, instead */
#if !defined(_WIN32) && !defined(__OS2__)
    static pthread_once_t once = PTHREAD_ONCE_INIT;
    pthread_once (&once, vlc_CPU_init);
#endif
    return cpu_flags;
}",1,1,misc\cpu.c,vlc_CPU,,false,269,278,vlc_CPU,,,3,unsigned vlc_CPU (void)
94422,METHOD,misc\cpu.c:<global>,TYPE_DECL,"void vlc_CPU_dump (vlc_object_t *obj)
{
    struct vlc_memstream stream;

    vlc_memstream_open(&stream);

#if defined (__i386__) || defined (__x86_64__)
    if (vlc_CPU_MMX())
        vlc_memstream_puts(&stream, ""MMX "");
    if (vlc_CPU_MMXEXT())
        vlc_memstream_puts(&stream, ""MMXEXT "");
    if (vlc_CPU_SSE())
        vlc_memstream_puts(&stream, ""SSE "");
    if (vlc_CPU_SSE2())
        vlc_memstream_puts(&stream, ""SSE2 "");
    if (vlc_CPU_SSE3())
        vlc_memstream_puts(&stream, ""SSE3 "");
    if (vlc_CPU_SSSE3())
        vlc_memstream_puts(&stream, ""SSSE3 "");
    if (vlc_CPU_SSE4_1())
        vlc_memstream_puts(&stream, ""SSE4.1 "");
    if (vlc_CPU_SSE4_2())
        vlc_memstream_puts(&stream, ""SSE4.2 "");
    if (vlc_CPU_SSE4A())
        vlc_memstream_puts(&stream, ""SSE4A "");
    if (vlc_CPU_AVX())
        vlc_memstream_puts(&stream, ""AVX "");
    if (vlc_CPU_AVX2())
        vlc_memstream_puts(&stream, ""AVX2 "");
    if (vlc_CPU_3dNOW())
        vlc_memstream_puts(&stream, ""...",1,1,misc\cpu.c,vlc_CPU_dump,,false,281,336,vlc_CPU_dump,,,4,void vlc_CPU_dump (vlc_object_t*)
94457,METHOD,misc\epg.c:<global>,TYPE_DECL,<global>,1,1,misc\epg.c,misc\epg.c:<global>,,false,1,241,<global>,,,1,
94459,METHOD,misc\epg.c:<global>,TYPE_DECL,"static void vlc_epg_event_Clean(vlc_epg_event_t *p_event)
{
    for(int i=0; i<p_event->i_description_items; i++)
    {
        free(p_event->description_items[i].psz_key);
        free(p_event->description_items[i].psz_value);
    }
    free(p_event->description_items);
    free(p_event->psz_description);
    free(p_event->psz_short_description);
    free(p_event->psz_name);
}",1,1,misc\epg.c,vlc_epg_event_Clean,,false,35,46,vlc_epg_event_Clean,,,1,void vlc_epg_event_Clean (vlc_epg_event_t*)
94510,METHOD,misc\epg.c:<global>,TYPE_DECL,"void vlc_epg_event_Delete(vlc_epg_event_t *p_event)
{
    vlc_epg_event_Clean(p_event);
    free(p_event);
}",1,1,misc\epg.c,vlc_epg_event_Delete,,false,48,52,vlc_epg_event_Delete,,,2,void vlc_epg_event_Delete (vlc_epg_event_t*)
94519,METHOD,misc\epg.c:<global>,TYPE_DECL,"static void vlc_epg_event_Init(vlc_epg_event_t *p_event, uint16_t i_id,
                               int64_t i_start, uint32_t i_duration)
{
    memset(p_event, 0, sizeof(*p_event));
    p_event->i_start = i_start;
    p_event->i_id = i_id;
    p_event->i_duration = i_duration;
    p_event->i_description_items = 0;
    p_event->description_items = NULL;
}",1,1,misc\epg.c,vlc_epg_event_Init,,false,54,63,vlc_epg_event_Init,,,3,"void vlc_epg_event_Init (vlc_epg_event_t*,uint16_t,int64_t,uint32_t)"
94558,METHOD,misc\epg.c:<global>,TYPE_DECL,"vlc_epg_event_t * vlc_epg_event_New(uint16_t i_id,
                                    int64_t i_start, uint32_t i_duration)
{
    vlc_epg_event_t *p_event = (vlc_epg_event_t *) malloc(sizeof(*p_event));
    if(p_event)
        vlc_epg_event_Init(p_event, i_id, i_start, i_duration);

    return p_event;
}",1,1,misc\epg.c,vlc_epg_event_New,,false,65,73,vlc_epg_event_New,,,4,"vlc_epg_event_t vlc_epg_event_New (uint16_t,int64_t,uint32_t)"
94584,METHOD,misc\epg.c:<global>,TYPE_DECL,"vlc_epg_event_t * vlc_epg_event_Duplicate( const vlc_epg_event_t *p_src )
{
    vlc_epg_event_t *p_evt = vlc_epg_event_New( p_src->i_id, p_src->i_start,
                                                p_src->i_duration );
    if( likely(p_evt) )
    {
        if( p_src->psz_description )
            p_evt->psz_description = strdup( p_src->psz_description );
        if( p_src->psz_name )
            p_evt->psz_name = strdup( p_src->psz_name );
        if( p_src->psz_short_description )
            p_evt->psz_short_description = strdup( p_src->psz_short_description );
        if( p_src->i_description_items )
        {
            p_evt->description_items = malloc( sizeof(*p_evt->description_items) *
                                               p_src->i_description_items );
            if( p_evt->description_items )
            {
                for( int i=0; i<p_src->i_description_items; i++ )
                {
                    p_evt->description_items[i].psz_key =
              ...",1,1,misc\epg.c,vlc_epg_event_Duplicate,,false,75,113,vlc_epg_event_Duplicate,,,5,vlc_epg_event_t vlc_epg_event_Duplicate (vlc_epg_event_t*)
94764,METHOD,misc\epg.c:<global>,TYPE_DECL,"static void vlc_epg_Init( vlc_epg_t *p_epg, uint32_t i_id, uint16_t i_source_id )
{
    p_epg->i_id = i_id;
    p_epg->i_source_id = i_source_id;
    p_epg->psz_name = NULL;
    p_epg->p_current = NULL;
    p_epg->b_present = false;
    TAB_INIT( p_epg->i_event, p_epg->pp_event );
}",1,1,misc\epg.c,vlc_epg_Init,,false,115,123,vlc_epg_Init,,,6,"void vlc_epg_Init (vlc_epg_t*,uint32_t,uint16_t)"
94803,METHOD,misc\epg.c:<global>,TYPE_DECL,"static void vlc_epg_Clean( vlc_epg_t *p_epg )
{
    size_t i;
    for( i = 0; i < p_epg->i_event; i++ )
        vlc_epg_event_Delete( p_epg->pp_event[i] );
    TAB_CLEAN( p_epg->i_event, p_epg->pp_event );
    free( p_epg->psz_name );
}",1,1,misc\epg.c,vlc_epg_Clean,,false,125,132,vlc_epg_Clean,,,7,void vlc_epg_Clean (vlc_epg_t*)
94838,METHOD,misc\epg.c:<global>,TYPE_DECL,"bool vlc_epg_AddEvent( vlc_epg_t *p_epg, vlc_epg_event_t *p_evt )
{
    ssize_t i_pos = -1;

    /* Insertions are supposed in sequential order first */
    if( p_epg->i_event )
    {
        if( p_epg->pp_event[0]->i_start > p_evt->i_start )
        {
            i_pos = 0;
        }
        else if ( p_epg->pp_event[p_epg->i_event - 1]->i_start >= p_evt->i_start )
        {
            /* Do bisect search lower start time entry */
            size_t i_lower = 0;
            size_t i_upper = p_epg->i_event - 1;

            while( i_lower < i_upper )
            {
                size_t i_split = ( i_lower + i_upper ) / 2;
                vlc_epg_event_t *p_cur = p_epg->pp_event[i_split];

                if( p_cur->i_start < p_evt->i_start )
                {
                    i_lower = i_split + 1;
                }
                else if ( p_cur->i_start >= p_evt->i_start )
                {
                    i_upper = i_split;
                }
            }
            i_...",1,1,misc\epg.c,vlc_epg_AddEvent,,false,134,189,vlc_epg_AddEvent,,,8,"bool vlc_epg_AddEvent (vlc_epg_t*,vlc_epg_event_t*)"
95026,METHOD,misc\epg.c:<global>,TYPE_DECL,"vlc_epg_t *vlc_epg_New( uint32_t i_id, uint16_t i_source_id )
{
    vlc_epg_t *p_epg = malloc( sizeof(*p_epg) );
    if( p_epg )
        vlc_epg_Init( p_epg, i_id, i_source_id );
    return p_epg;
}",1,1,misc\epg.c,vlc_epg_New,,false,191,197,vlc_epg_New,,,9,"vlc_epg_t vlc_epg_New (uint32_t,uint16_t)"
95048,METHOD,misc\epg.c:<global>,TYPE_DECL,"void vlc_epg_Delete( vlc_epg_t *p_epg )
{
    vlc_epg_Clean( p_epg );
    free( p_epg );
}",1,1,misc\epg.c,vlc_epg_Delete,,false,199,203,vlc_epg_Delete,,,10,void vlc_epg_Delete (vlc_epg_t*)
95057,METHOD,misc\epg.c:<global>,TYPE_DECL,"void vlc_epg_SetCurrent( vlc_epg_t *p_epg, int64_t i_start )
{
    size_t i;
    p_epg->p_current = NULL;
    if( i_start < 0 )
        return;

    for( i = 0; i < p_epg->i_event; i++ )
    {
        if( p_epg->pp_event[i]->i_start == i_start )
        {
            p_epg->p_current = p_epg->pp_event[i];
            break;
        }
    }
}",1,1,misc\epg.c,vlc_epg_SetCurrent,,false,205,220,vlc_epg_SetCurrent,,,11,"void vlc_epg_SetCurrent (vlc_epg_t*,int64_t)"
95109,METHOD,misc\epg.c:<global>,TYPE_DECL,"vlc_epg_t * vlc_epg_Duplicate( const vlc_epg_t *p_src )
{
    vlc_epg_t *p_epg = vlc_epg_New( p_src->i_id, p_src->i_source_id );
    if( p_epg )
    {
        p_epg->psz_name = ( p_src->psz_name ) ? strdup( p_src->psz_name ) : NULL;
        p_epg->b_present = p_src->b_present;
        for( size_t i=0; i<p_src->i_event; i++ )
        {
            vlc_epg_event_t *p_dup = vlc_epg_event_Duplicate( p_src->pp_event[i] );
            if( p_dup )
            {
                if( p_src->p_current == p_src->pp_event[i] )
                    p_epg->p_current = p_dup;
                TAB_APPEND( p_epg->i_event, p_epg->pp_event, p_dup );
            }
        }
    }
    return p_epg;
}",1,1,misc\epg.c,vlc_epg_Duplicate,,false,222,241,vlc_epg_Duplicate,,,12,vlc_epg_t vlc_epg_Duplicate (vlc_epg_t*)
95206,METHOD,misc\error.c:<global>,TYPE_DECL,<global>,1,2,misc\error.c,misc\error.c:<global>,,false,1,67,<global>,,,1,
95208,METHOD,misc\error.c:<global>,TYPE_DECL,"char const * vlc_error ( int i_err )
{
    switch( i_err )
    {
        case VLC_SUCCESS:
            return ""no error"";

        case VLC_ENOMEM:
            return ""not enough memory"";
        case VLC_ETIMEOUT:
            return ""timeout"";

        case VLC_ENOMOD:
            return ""module not found"";

        case VLC_ENOOBJ:
            return ""object not found"";

        case VLC_ENOVAR:
            return ""variable not found"";
        case VLC_EBADVAR:
            return ""bad variable value"";

        case VLC_EGENERIC:
            return ""generic error"";
        default:
            return ""unknown error"";
    }
}",1,1,misc\error.c,vlc_error,,false,39,67,vlc_error,,,1,const char* vlc_error (int)
95262,METHOD,misc\es_format.c:<global>,TYPE_DECL,<global>,1,2,misc\es_format.c,misc\es_format.c:<global>,,false,1,612,<global>,,,1,
95264,METHOD,misc\es_format.c:<global>,TYPE_DECL,"static int BinaryLog( uint32_t i )
{
    int i_log = 0;

    if( i == 0 ) return -31337;

    if( i & 0xffff0000 ) i_log += 16;
    if( i & 0xff00ff00 ) i_log += 8;
    if( i & 0xf0f0f0f0 ) i_log += 4;
    if( i & 0xcccccccc ) i_log += 2;
    if( i & 0xaaaaaaaa ) i_log += 1;

    return i_log;
}",1,1,misc\es_format.c,BinaryLog,,false,44,57,BinaryLog,,,1,int BinaryLog (uint32_t)
95323,METHOD,misc\es_format.c:<global>,TYPE_DECL,"static void MaskToShift( int *pi_left, int *pi_right, uint32_t i_mask )
{
    uint32_t i_low, i_high;            /* lower and higher bits of the mask */

    if( !i_mask )
    {
        *pi_left = *pi_right = 0;
        return;
    }

    /* Get bits */
    i_low = i_high = i_mask;

    i_low &= - (int32_t)i_low;          /* lower bit of the mask */
    i_high += i_low;                    /* higher bit of the mask */

    /* Transform bits into an index. Also deal with i_high overflow, which
     * is faster than changing the BinaryLog code to handle 64 bit integers. */
    i_low =  BinaryLog (i_low);
    i_high = i_high ? BinaryLog (i_high) : 32;

    /* Update pointers and return */
    *pi_left =   i_low;
    *pi_right = (8 - i_high + i_low);
}",1,1,misc\es_format.c,MaskToShift,,false,63,87,MaskToShift,,,2,"void MaskToShift (int*,int*,uint32_t)"
95381,METHOD,misc\es_format.c:<global>,TYPE_DECL,"void video_format_FixRgb( video_format_t *p_fmt )
{
    /* FIXME find right default mask */
    if( !p_fmt->i_rmask || !p_fmt->i_gmask || !p_fmt->i_bmask )
    {
        switch( p_fmt->i_chroma )
        {
        case VLC_CODEC_RGB15:
            p_fmt->i_rmask = 0x7c00;
            p_fmt->i_gmask = 0x03e0;
            p_fmt->i_bmask = 0x001f;
            break;

        case VLC_CODEC_RGB16:
            p_fmt->i_rmask = 0xf800;
            p_fmt->i_gmask = 0x07e0;
            p_fmt->i_bmask = 0x001f;
            break;

        case VLC_CODEC_RGB24:
            p_fmt->i_rmask = 0xff0000;
            p_fmt->i_gmask = 0x00ff00;
            p_fmt->i_bmask = 0x0000ff;
            break;
        case VLC_CODEC_RGB32:
            p_fmt->i_rmask = 0x00ff0000;
            p_fmt->i_gmask = 0x0000ff00;
            p_fmt->i_bmask = 0x000000ff;
            break;

        default:
            return;
        }
    }

    MaskToShift( &p_fmt->i_lrshift, &p_fmt->i_rrshift,
                 p_fm...",1,1,misc\es_format.c,video_format_FixRgb,,false,90,131,video_format_FixRgb,,,3,void video_format_FixRgb (video_format_t*)
95517,METHOD,misc\es_format.c:<global>,TYPE_DECL,"void video_format_Setup( video_format_t *p_fmt, vlc_fourcc_t i_chroma,
                         int i_width, int i_height,
                         int i_visible_width, int i_visible_height,
                         int i_sar_num, int i_sar_den )
{
    p_fmt->i_chroma         = vlc_fourcc_GetCodec( VIDEO_ES, i_chroma );
    p_fmt->i_width          = i_width;
    p_fmt->i_visible_width  = i_visible_width;
    p_fmt->i_height         = i_height;
    p_fmt->i_visible_height = i_visible_height;
    p_fmt->i_x_offset       =
    p_fmt->i_y_offset       = 0;
    vlc_ureduce( &p_fmt->i_sar_num, &p_fmt->i_sar_den,
                 i_sar_num, i_sar_den, 0 );

    switch( p_fmt->i_chroma )
    {
    case VLC_CODEC_YUVA:
        p_fmt->i_bits_per_pixel = 32;
        break;
    case VLC_CODEC_YUV420A:
        p_fmt->i_bits_per_pixel = 20;
        break;
    case VLC_CODEC_YUV422A:
        p_fmt->i_bits_per_pixel = 24;
        break;
    case VLC_CODEC_I444:
    case VLC_CODEC_J444:
        p_fm...",1,1,misc\es_format.c,video_format_Setup,,false,133,226,video_format_Setup,,,4,"void video_format_Setup (video_format_t*,vlc_fourcc_t,int,int,int,int,int,int)"
95759,METHOD,misc\es_format.c:<global>,TYPE_DECL,"void video_format_CopyCrop( video_format_t *p_dst, const video_format_t *p_src )
{
    p_dst->i_x_offset       = p_src->i_x_offset;
    p_dst->i_y_offset       = p_src->i_y_offset;
    p_dst->i_visible_width  = p_src->i_visible_width;
    p_dst->i_visible_height = p_src->i_visible_height;
}",1,1,misc\es_format.c,video_format_CopyCrop,,false,228,234,video_format_CopyCrop,,,5,"void video_format_CopyCrop (video_format_t*,video_format_t*)"
95793,METHOD,misc\es_format.c:<global>,TYPE_DECL,"void video_format_ScaleCropAr( video_format_t *p_dst, const video_format_t *p_src )
{
    p_dst->i_x_offset       = (uint64_t)p_src->i_x_offset       * p_dst->i_width  / p_src->i_width;
    p_dst->i_y_offset       = (uint64_t)p_src->i_y_offset       * p_dst->i_height / p_src->i_height;
    p_dst->i_visible_width  = (uint64_t)p_src->i_visible_width  * p_dst->i_width  / p_src->i_width;
    p_dst->i_visible_height = (uint64_t)p_src->i_visible_height * p_dst->i_height / p_src->i_height;

    p_dst->i_sar_num *= p_src->i_width;
    p_dst->i_sar_den *= p_dst->i_width;
    vlc_ureduce(&p_dst->i_sar_num, &p_dst->i_sar_den,
                p_dst->i_sar_num, p_dst->i_sar_den, 65536);

    p_dst->i_sar_num *= p_dst->i_height;
    p_dst->i_sar_den *= p_src->i_height;
    vlc_ureduce(&p_dst->i_sar_num, &p_dst->i_sar_den,
                p_dst->i_sar_num, p_dst->i_sar_den, 65536);
}",1,1,misc\es_format.c,video_format_ScaleCropAr,,false,236,252,video_format_ScaleCropAr,,,6,"void video_format_ScaleCropAr (video_format_t*,video_format_t*)"
95927,METHOD,misc\es_format.c:<global>,TYPE_DECL,"static void transform_GetBasicOps( video_transform_t transform,
                                   unsigned *restrict angle,
                                   bool *restrict hflip )
{
    *hflip = ORIENT_IS_MIRROR(transform);

    switch ( transform )
    {
        case TRANSFORM_R90:
        case TRANSFORM_TRANSPOSE:
            *angle = 90;
            break;
        case TRANSFORM_R180:
        case TRANSFORM_VFLIP:
            *angle = 180;
            break;
        case TRANSFORM_R270:
        case TRANSFORM_ANTI_TRANSPOSE:
            *angle = 270;
            break;
        case TRANSFORM_HFLIP:
        case TRANSFORM_IDENTITY:
            *angle = 0;
            break;
        default:
            vlc_assert_unreachable ();
    }
}",1,1,misc\es_format.c,transform_GetBasicOps,,false,255,282,transform_GetBasicOps,,,7,"void transform_GetBasicOps (video_transform_t,unsigned*,bool*)"
95980,METHOD,misc\es_format.c:<global>,TYPE_DECL,"static video_transform_t transform_FromBasicOps( unsigned angle, bool hflip )
{
    switch ( angle )
    {
        case 90:
            return hflip ? TRANSFORM_TRANSPOSE : TRANSFORM_R90;
        case 180:
            return hflip ? TRANSFORM_VFLIP : TRANSFORM_R180;
        case 270:
            return hflip ? TRANSFORM_ANTI_TRANSPOSE : TRANSFORM_R270;
        default:
            return hflip ? TRANSFORM_HFLIP : TRANSFORM_IDENTITY;
    }
}",1,1,misc\es_format.c,transform_FromBasicOps,,false,284,297,transform_FromBasicOps,,,8,"video_transform_t transform_FromBasicOps (unsigned,bool)"
96016,METHOD,misc\es_format.c:<global>,TYPE_DECL,"video_transform_t video_format_GetTransform( video_orientation_t src,
                                             video_orientation_t dst )
{
    unsigned angle1, angle2;
    bool hflip1, hflip2;

    transform_GetBasicOps(  (video_transform_t)src, &angle1, &hflip1 );
    transform_GetBasicOps( transform_Inverse( (video_transform_t)dst ),
                           &angle2, &hflip2 );

    int angle = (angle1 + angle2) % 360;
    bool hflip = hflip1 ^ hflip2;

    return transform_FromBasicOps(angle, hflip);
}",1,1,misc\es_format.c,video_format_GetTransform,,false,299,313,video_format_GetTransform,,,9,"video_transform_t video_format_GetTransform (video_orientation_t,video_orientation_t)"
96061,METHOD,misc\es_format.c:<global>,TYPE_DECL,"void video_format_TransformBy( video_format_t *fmt, video_transform_t transform )
{
    /* Get destination orientation */
    unsigned angle1, angle2;
    bool hflip1, hflip2;

    transform_GetBasicOps( transform, &angle1, &hflip1 );
    transform_GetBasicOps( (video_transform_t)fmt->orientation, &angle2, &hflip2 );

    unsigned angle = (angle2 - angle1 + 360) % 360;
    bool hflip = hflip2 ^ hflip1;

    video_orientation_t dst_orient = ORIENT_NORMAL;

    if( hflip ) {

        if( angle == 0 )
            dst_orient = ORIENT_HFLIPPED;
        else if( angle == 90 )
            dst_orient = ORIENT_ANTI_TRANSPOSED;
        else if( angle == 180 )
            dst_orient = ORIENT_VFLIPPED;
        else if( angle == 270 )
            dst_orient = ORIENT_TRANSPOSED;
    }
    else {

        if( angle == 90 )
            dst_orient = ORIENT_ROTATED_90;
        else if( angle == 180 )
            dst_orient = ORIENT_ROTATED_180;
        else if( angle == 270 )
            dst_orient =...",1,1,misc\es_format.c,video_format_TransformBy,,false,315,366,video_format_TransformBy,,,10,"void video_format_TransformBy (video_format_t*,video_transform_t)"
96253,METHOD,misc\es_format.c:<global>,TYPE_DECL,"void video_format_TransformTo( video_format_t *restrict fmt,
                               video_orientation_t dst_orientation )
{
    video_transform_t transform = video_format_GetTransform(fmt->orientation,
                                                            dst_orientation);
    video_format_TransformBy(fmt, transform);
}",1,1,misc\es_format.c,video_format_TransformTo,,false,368,374,video_format_TransformTo,,,11,"void video_format_TransformTo (video_format_t*,video_orientation_t)"
96270,METHOD,misc\es_format.c:<global>,TYPE_DECL,"void video_format_ApplyRotation( video_format_t *restrict out,
                                 const video_format_t *restrict in )
{
    *out = *in;

    video_format_TransformTo(out, ORIENT_NORMAL);
}",1,1,misc\es_format.c,video_format_ApplyRotation,,false,376,382,video_format_ApplyRotation,,,12,"void video_format_ApplyRotation (video_format_t*,video_format_t*)"
96284,METHOD,misc\es_format.c:<global>,TYPE_DECL,"bool video_format_IsSimilar( const video_format_t *f1,
                             const video_format_t *f2 )
{
    if( f1->i_chroma != f2->i_chroma )
        return false;

    if( f1->i_width != f2->i_width || f1->i_height != f2->i_height ||
        f1->i_visible_width != f2->i_visible_width ||
        f1->i_visible_height != f2->i_visible_height ||
        f1->i_x_offset != f2->i_x_offset || f1->i_y_offset != f2->i_y_offset )
        return false;
    if( (int64_t)f1->i_sar_num * f2->i_sar_den !=
        (int64_t)f2->i_sar_num * f1->i_sar_den )
        return false;

    if( f1->orientation != f2->orientation)
        return false;

    if( f1->multiview_mode!= f2->multiview_mode )
       return false;

    if( f1->i_chroma == VLC_CODEC_RGB15 ||
        f1->i_chroma == VLC_CODEC_RGB16 ||
        f1->i_chroma == VLC_CODEC_RGB24 ||
        f1->i_chroma == VLC_CODEC_RGB32 )
    {
        video_format_t v1 = *f1;
        video_format_t v2 = *f2;

        video_format_FixRgb( &v1 );
...",1,1,misc\es_format.c,video_format_IsSimilar,,false,384,422,video_format_IsSimilar,,,13,"bool video_format_IsSimilar (video_format_t*,video_format_t*)"
96467,METHOD,misc\es_format.c:<global>,TYPE_DECL,"void video_format_Print( vlc_object_t *p_this,
                         const char *psz_text, const video_format_t *fmt )
{
    msg_Dbg( p_this,
             ""%s sz %ix%i, of (%i,%i), vsz %ix%i, 4cc %4.4s, sar %i:%i, msk r0x%x g0x%x b0x%x"",
             psz_text,
             fmt->i_width, fmt->i_height, fmt->i_x_offset, fmt->i_y_offset,
             fmt->i_visible_width, fmt->i_visible_height,
             (char*)&fmt->i_chroma,
             fmt->i_sar_num, fmt->i_sar_den,
             fmt->i_rmask, fmt->i_gmask, fmt->i_bmask );
}",1,1,misc\es_format.c,video_format_Print,,false,423,434,video_format_Print,,,14,"void video_format_Print (vlc_object_t*,char*,video_format_t*)"
96517,METHOD,misc\es_format.c:<global>,TYPE_DECL,"void es_format_Init( es_format_t *fmt,
                     int i_cat, vlc_fourcc_t i_codec )
{
    memset(fmt, 0, sizeof (*fmt));
    fmt->i_cat                  = i_cat;
    fmt->i_codec                = i_codec;
    fmt->i_profile              = -1;
    fmt->i_level                = -1;
    fmt->i_id                   = -1;
    fmt->i_priority             = ES_PRIORITY_SELECTABLE_MIN;
    fmt->psz_language           = NULL;
    fmt->psz_description        = NULL;
    fmt->p_extra_languages      = NULL;

    if (fmt->i_cat == VIDEO_ES)
        video_format_Init(&fmt->video, 0);

    fmt->b_packetized           = true;
    fmt->p_extra                = NULL;
}",1,1,misc\es_format.c,es_format_Init,,false,436,455,es_format_Init,,,15,"void es_format_Init (es_format_t*,int,vlc_fourcc_t)"
96601,METHOD,misc\es_format.c:<global>,TYPE_DECL,"void es_format_InitFromVideo( es_format_t *p_es, const video_format_t *p_fmt )
{
    es_format_Init( p_es, VIDEO_ES, p_fmt->i_chroma );
    video_format_Copy( &p_es->video, p_fmt );
}",1,1,misc\es_format.c,es_format_InitFromVideo,,false,457,461,es_format_InitFromVideo,,,16,"void es_format_InitFromVideo (es_format_t*,video_format_t*)"
96619,METHOD,misc\es_format.c:<global>,TYPE_DECL,"int es_format_Copy(es_format_t *restrict dst, const es_format_t *src)
{
    int ret = VLC_SUCCESS;

    *dst = *src;

    if (src->psz_language != NULL)
    {
        dst->psz_language = strdup(src->psz_language);
        if (unlikely(dst->psz_language == NULL))
            ret = VLC_ENOMEM;
    }
    if (src->psz_description != NULL)
    {
        dst->psz_description = strdup(src->psz_description);
        if (unlikely(dst->psz_description == NULL))
            ret = VLC_ENOMEM;
    }

    if (src->i_extra > 0)
    {
        assert(src->p_extra != NULL);
        dst->p_extra = malloc( src->i_extra );

        if( likely(dst->p_extra != NULL) )
            memcpy(dst->p_extra, src->p_extra, src->i_extra);
        else
        {
            dst->i_extra = 0;
            ret = VLC_ENOMEM;
        }
    }
    else
        dst->p_extra = NULL;

    if (src->i_cat == VIDEO_ES)
        ret = video_format_Copy( &dst->video, &src->video );

    if (src->i_cat == SPU_ES)
    {
        if (s...",1,1,misc\es_format.c,es_format_Copy,,false,463,540,es_format_Copy,,,17,"int es_format_Copy (es_format_t*,es_format_t*)"
96956,METHOD,misc\es_format.c:<global>,TYPE_DECL,"void es_format_Clean(es_format_t *fmt)
{
    free(fmt->psz_language);
    free(fmt->psz_description);
    assert(fmt->i_extra == 0 || fmt->p_extra != NULL);
    free(fmt->p_extra);

    if (fmt->i_cat == VIDEO_ES)
        video_format_Clean( &fmt->video );
    if (fmt->i_cat == SPU_ES)
    {
        free(fmt->subs.psz_encoding);

        if (fmt->subs.p_style != NULL)
            text_style_Delete(fmt->subs.p_style);
    }

    for (unsigned i = 0; i < fmt->i_extra_languages; i++)
    {
        free(fmt->p_extra_languages[i].psz_language);
        free(fmt->p_extra_languages[i].psz_description);
    }
    free(fmt->p_extra_languages);

    /* es_format_Clean can be called multiple times */
    es_format_Init(fmt, UNKNOWN_ES, 0);
}",1,1,misc\es_format.c,es_format_Clean,,false,542,568,es_format_Clean,,,18,void es_format_Clean (es_format_t*)
97063,METHOD,misc\es_format.c:<global>,TYPE_DECL,"bool es_format_IsSimilar( const es_format_t *p_fmt1, const es_format_t *p_fmt2 )
{
    if( p_fmt1->i_cat != p_fmt2->i_cat ||
        vlc_fourcc_GetCodec( p_fmt1->i_cat, p_fmt1->i_codec ) !=
        vlc_fourcc_GetCodec( p_fmt2->i_cat, p_fmt2->i_codec ) )
        return false;

    switch( p_fmt1->i_cat )
    {
    case AUDIO_ES:
    {
        audio_format_t a1 = p_fmt1->audio;
        audio_format_t a2 = p_fmt2->audio;

        if( a1.i_format && a2.i_format && a1.i_format != a2.i_format )
            return false;
        if( a1.channel_type != a2.channel_type ||
            a1.i_rate != a2.i_rate ||
            a1.i_channels != a2.i_channels ||
            a1.i_physical_channels != a2.i_physical_channels ||
            a1.i_chan_mode != a2.i_chan_mode )
            return false;
        if( p_fmt1->i_profile != p_fmt2->i_profile )
            return false;
        return true;
    }

    case VIDEO_ES:
    {
        video_format_t v1 = p_fmt1->video;
        video_format_t v2 = p_f...",1,1,misc\es_format.c,es_format_IsSimilar,,false,570,612,es_format_IsSimilar,,,19,"bool es_format_IsSimilar (es_format_t*,es_format_t*)"
97268,METHOD,misc\events.c:<global>,TYPE_DECL,<global>,1,1,misc\events.c,misc\events.c:<global>,,false,1,172,<global>,,,1,
97274,METHOD,misc\events.c:<global>,TYPE_DECL,"void vlc_event_manager_init( vlc_event_manager_t * p_em, void * p_obj )
{
    p_em->p_obj = p_obj;
    /* This is an unsafe work-around for a long-standing playlist bug.
     * Do not rely on this. */
    vlc_mutex_init_recursive( &p_em->lock );

    for( size_t i = 0; i < ARRAY_SIZE(p_em->events); i++ )
       ARRAY_INIT( p_em->events[i].listeners );
}",1,1,misc\events.c,vlc_event_manager_init,,false,66,75,vlc_event_manager_init,,,3,"void vlc_event_manager_init (vlc_event_manager_t*,void*)"
97312,METHOD,misc\events.c:<global>,TYPE_DECL,"void vlc_event_manager_fini( vlc_event_manager_t * p_em )
{
    struct vlc_event_listener_t * listener;

    vlc_mutex_destroy( &p_em->lock );

    for( size_t i = 0; i < ARRAY_SIZE(p_em->events); i++ )
    {
        struct vlc_event_listeners_group_t *slot = p_em->events + i;

        FOREACH_ARRAY( listener, slot->listeners )
            free( listener );
        FOREACH_END()
        ARRAY_RESET( slot->listeners );
    }
}",1,1,misc\events.c,vlc_event_manager_fini,,false,80,95,vlc_event_manager_fini,,,4,void vlc_event_manager_fini (vlc_event_manager_t*)
97360,METHOD,misc\events.c:<global>,TYPE_DECL,"void vlc_event_send( vlc_event_manager_t * p_em,
                     vlc_event_t * p_event )
{
    vlc_event_listeners_group_t *slot = &p_em->events[p_event->type];
    vlc_event_listener_t * listener;

    /* Fill event with the sending object now */
    p_event->p_obj = p_em->p_obj;

    vlc_mutex_lock( &p_em->lock ) ;

    FOREACH_ARRAY( listener, slot->listeners )
        listener->pf_callback( p_event, listener->p_user_data );
    FOREACH_END()

    vlc_mutex_unlock( &p_em->lock );
}",1,1,misc\events.c,vlc_event_send,,false,100,116,vlc_event_send,,,5,"void vlc_event_send (vlc_event_manager_t*,vlc_event_t*)"
97411,METHOD,misc\events.c:<global>,TYPE_DECL,"int vlc_event_attach( vlc_event_manager_t * p_em,
                      vlc_event_type_t event_type,
                      vlc_event_callback_t pf_callback,
                      void *p_user_data )
{
    vlc_event_listener_t * listener;
    vlc_event_listeners_group_t *slot = &p_em->events[event_type];

    listener = malloc(sizeof(vlc_event_listener_t));
    if( !listener )
        return VLC_ENOMEM;

    listener->p_user_data = p_user_data;
    listener->pf_callback = pf_callback;

    vlc_mutex_lock( &p_em->lock );
    ARRAY_APPEND( slot->listeners, listener );
    vlc_mutex_unlock( &p_em->lock );
    return VLC_SUCCESS;
}",1,1,misc\events.c,vlc_event_attach,,false,122,141,vlc_event_attach,,,6,"int vlc_event_attach (vlc_event_manager_t*,vlc_event_type_t,vlc_event_callback_t,void*)"
97467,METHOD,misc\events.c:<global>,TYPE_DECL,"void vlc_event_detach( vlc_event_manager_t *p_em,
                       vlc_event_type_t event_type,
                       vlc_event_callback_t pf_callback,
                       void *p_user_data )
{
    vlc_event_listeners_group_t *slot = &p_em->events[event_type];
    struct vlc_event_listener_t * listener;

    vlc_mutex_lock( &p_em->lock );

    FOREACH_ARRAY( listener, slot->listeners )
        if( listener->pf_callback == pf_callback &&
            listener->p_user_data == p_user_data )
        {
            /* that's our listener */
            ARRAY_REMOVE( slot->listeners,
                          fe_idx /* This comes from the macro (and that's why
                                    I hate macro) */ );
            vlc_mutex_unlock( &p_em->lock );
            free( listener );
            return;
        }
    FOREACH_END()

    vlc_assert_unreachable();
}",1,1,misc\events.c,vlc_event_detach,,false,147,172,vlc_event_detach,,,7,"void vlc_event_detach (vlc_event_manager_t*,vlc_event_type_t,vlc_event_callback_t,void*)"
97538,METHOD,misc\exit.c:<global>,TYPE_DECL,<global>,1,27,misc\exit.c,misc\exit.c:<global>,,false,1,72,<global>,,,1,
97540,METHOD,misc\exit.c:<global>,TYPE_DECL,"void vlc_ExitInit( vlc_exit_t *exit )
{
    vlc_mutex_init( &exit->lock );
    exit->handler = NULL;
    exit->opaque = NULL;
}",1,1,misc\exit.c,vlc_ExitInit,,false,30,35,vlc_ExitInit,,,1,void vlc_ExitInit (vlc_exit_t*)
97560,METHOD,misc\exit.c:<global>,TYPE_DECL,"void vlc_ExitDestroy( vlc_exit_t *exit )
{
    vlc_mutex_destroy( &exit->lock );
}",1,1,misc\exit.c,vlc_ExitDestroy,,false,37,40,vlc_ExitDestroy,,,2,void vlc_ExitDestroy (vlc_exit_t*)
97570,METHOD,misc\exit.c:<global>,TYPE_DECL,"void libvlc_SetExitHandler( libvlc_int_t *p_libvlc, void (*handler) (void *),
                            void *opaque )
{
    vlc_exit_t *exit = &libvlc_priv( p_libvlc )->exit;

    vlc_mutex_lock( &exit->lock );
    exit->handler = handler;
    exit->opaque = opaque;
    vlc_mutex_unlock( &exit->lock );
}",1,1,misc\exit.c,libvlc_SetExitHandler,,false,46,55,libvlc_SetExitHandler,,,3,"void libvlc_SetExitHandler (libvlc_int_t*,void,void*)"
97605,METHOD,misc\exit.c:<global>,TYPE_DECL,"void libvlc_Quit( libvlc_int_t *p_libvlc )
{
    vlc_exit_t *exit = &libvlc_priv( p_libvlc )->exit;

    msg_Dbg( p_libvlc, ""exiting"" );
    vlc_mutex_lock( &exit->lock );
    if( exit->handler != NULL )
        exit->handler( exit->opaque );
    else
        msg_Dbg( p_libvlc, ""no exit handler"" );
    vlc_mutex_unlock( &exit->lock );
}",1,1,misc\exit.c,libvlc_Quit,,false,61,72,libvlc_Quit,,,4,void libvlc_Quit (libvlc_int_t*)
97665,METHOD,misc\fifo.c:<global>,TYPE_DECL,<global>,1,23,misc\fifo.c,misc\fifo.c:<global>,,false,1,235,<global>,,,1,
97674,METHOD,misc\fifo.c:<global>,TYPE_DECL,"void vlc_fifo_Lock(vlc_fifo_t *fifo)
{
    vlc_mutex_lock(&fifo->lock);
}",1,1,misc\fifo.c,vlc_fifo_Lock,,false,49,52,vlc_fifo_Lock,,,2,void vlc_fifo_Lock (vlc_fifo_t*)
97684,METHOD,misc\fifo.c:<global>,TYPE_DECL,"void vlc_fifo_Unlock(vlc_fifo_t *fifo)
{
    vlc_mutex_unlock(&fifo->lock);
}",1,1,misc\fifo.c,vlc_fifo_Unlock,,false,54,57,vlc_fifo_Unlock,,,3,void vlc_fifo_Unlock (vlc_fifo_t*)
97694,METHOD,misc\fifo.c:<global>,TYPE_DECL,"void vlc_fifo_Signal(vlc_fifo_t *fifo)
{
    vlc_cond_signal(&fifo->wait);
}",1,1,misc\fifo.c,vlc_fifo_Signal,,false,59,62,vlc_fifo_Signal,,,4,void vlc_fifo_Signal (vlc_fifo_t*)
97704,METHOD,misc\fifo.c:<global>,TYPE_DECL,"void vlc_fifo_Wait(vlc_fifo_t *fifo)
{
    vlc_fifo_WaitCond(fifo, &fifo->wait);
}",1,1,misc\fifo.c,vlc_fifo_Wait,,false,64,67,vlc_fifo_Wait,,,5,void vlc_fifo_Wait (vlc_fifo_t*)
97715,METHOD,misc\fifo.c:<global>,TYPE_DECL,"void vlc_fifo_WaitCond(vlc_fifo_t *fifo, vlc_cond_t *condvar)
{
    vlc_cond_wait(condvar, &fifo->lock);
}",1,1,misc\fifo.c,vlc_fifo_WaitCond,,false,69,72,vlc_fifo_WaitCond,,,6,"void vlc_fifo_WaitCond (vlc_fifo_t*,vlc_cond_t*)"
97727,METHOD,misc\fifo.c:<global>,TYPE_DECL,"int vlc_fifo_TimedWaitCond(vlc_fifo_t *fifo, vlc_cond_t *condvar, mtime_t deadline)
{
    return vlc_cond_timedwait(condvar, &fifo->lock, deadline);
}",1,1,misc\fifo.c,vlc_fifo_TimedWaitCond,,false,74,77,vlc_fifo_TimedWaitCond,,,7,"int vlc_fifo_TimedWaitCond (vlc_fifo_t*,vlc_cond_t*,mtime_t)"
97742,METHOD,misc\fifo.c:<global>,TYPE_DECL,"size_t vlc_fifo_GetCount(const vlc_fifo_t *fifo)
{
    return fifo->i_depth;
}",1,1,misc\fifo.c,vlc_fifo_GetCount,,false,79,82,vlc_fifo_GetCount,,,8,size_t vlc_fifo_GetCount (vlc_fifo_t*)
97751,METHOD,misc\fifo.c:<global>,TYPE_DECL,"size_t vlc_fifo_GetBytes(const vlc_fifo_t *fifo)
{
    return fifo->i_size;
}",1,1,misc\fifo.c,vlc_fifo_GetBytes,,false,84,87,vlc_fifo_GetBytes,,,9,size_t vlc_fifo_GetBytes (vlc_fifo_t*)
97760,METHOD,misc\fifo.c:<global>,TYPE_DECL,"void vlc_fifo_QueueUnlocked(block_fifo_t *fifo, block_t *block)
{
    vlc_assert_locked(&fifo->lock);
    assert(*(fifo->pp_last) == NULL);

    *(fifo->pp_last) = block;

    while (block != NULL)
    {
        fifo->pp_last = &block->p_next;
        fifo->i_depth++;
        fifo->i_size += block->i_buffer;

        block = block->p_next;
    }

    vlc_fifo_Signal(fifo);
}",1,4,misc\fifo.c,vlc_fifo_QueueUnlocked,,false,89,106,vlc_fifo_QueueUnlocked,,,10,"void vlc_fifo_QueueUnlocked (block_fifo_t*,block_t*)"
97822,METHOD,misc\fifo.c:<global>,TYPE_DECL,"block_t *vlc_fifo_DequeueUnlocked(block_fifo_t *fifo)
{
    vlc_assert_locked(&fifo->lock);

    block_t *block = fifo->p_first;

    if (block == NULL)
        return NULL; /* Nothing to do */

    fifo->p_first = block->p_next;
    if (block->p_next == NULL)
        fifo->pp_last = &fifo->p_first;
    block->p_next = NULL;

    assert(fifo->i_depth > 0);
    fifo->i_depth--;
    assert(fifo->i_size >= block->i_buffer);
    fifo->i_size -= block->i_buffer;

    return block;
}",1,4,misc\fifo.c,vlc_fifo_DequeueUnlocked,,false,108,128,vlc_fifo_DequeueUnlocked,,,11,block_t vlc_fifo_DequeueUnlocked (block_fifo_t*)
97906,METHOD,misc\fifo.c:<global>,TYPE_DECL,"block_t *vlc_fifo_DequeueAllUnlocked(block_fifo_t *fifo)
{
    vlc_assert_locked(&fifo->lock);

    block_t *block = fifo->p_first;

    fifo->p_first = NULL;
    fifo->pp_last = &fifo->p_first;
    fifo->i_depth = 0;
    fifo->i_size = 0;

    return block;
}",1,4,misc\fifo.c,vlc_fifo_DequeueAllUnlocked,,false,130,142,vlc_fifo_DequeueAllUnlocked,,,12,block_t vlc_fifo_DequeueAllUnlocked (block_fifo_t*)
97954,METHOD,misc\fifo.c:<global>,TYPE_DECL,"block_fifo_t *block_FifoNew( void )
{
    block_fifo_t *p_fifo = malloc( sizeof( block_fifo_t ) );
    if( !p_fifo )
        return NULL;

    vlc_mutex_init( &p_fifo->lock );
    vlc_cond_init( &p_fifo->wait );
    p_fifo->p_first = NULL;
    p_fifo->pp_last = &p_fifo->p_first;
    p_fifo->i_depth = p_fifo->i_size = 0;

    return p_fifo;
}",1,1,misc\fifo.c,block_FifoNew,,false,144,157,block_FifoNew,,,13,block_fifo_t block_FifoNew (void)
98005,METHOD,misc\fifo.c:<global>,TYPE_DECL,"void block_FifoRelease( block_fifo_t *p_fifo )
{
    block_ChainRelease( p_fifo->p_first );
    vlc_cond_destroy( &p_fifo->wait );
    vlc_mutex_destroy( &p_fifo->lock );
    free( p_fifo );
}",1,1,misc\fifo.c,block_FifoRelease,,false,159,165,block_FifoRelease,,,14,void block_FifoRelease (block_fifo_t*)
98026,METHOD,misc\fifo.c:<global>,TYPE_DECL,"void block_FifoEmpty(block_fifo_t *fifo)
{
    block_t *block;

    vlc_fifo_Lock(fifo);
    block = vlc_fifo_DequeueAllUnlocked(fifo);
    vlc_fifo_Unlock(fifo);
    block_ChainRelease(block);
}",1,1,misc\fifo.c,block_FifoEmpty,,false,167,175,block_FifoEmpty,,,15,void block_FifoEmpty (block_fifo_t*)
98042,METHOD,misc\fifo.c:<global>,TYPE_DECL,"void block_FifoPut(block_fifo_t *fifo, block_t *block)
{
    vlc_fifo_Lock(fifo);
    vlc_fifo_QueueUnlocked(fifo, block);
    vlc_fifo_Unlock(fifo);
}",1,1,misc\fifo.c,block_FifoPut,,false,177,182,block_FifoPut,,,16,"void block_FifoPut (block_fifo_t*,block_t*)"
98055,METHOD,misc\fifo.c:<global>,TYPE_DECL,"block_t *block_FifoGet(block_fifo_t *fifo)
{
    block_t *block;

    vlc_testcancel();

    vlc_fifo_Lock(fifo);
    while (vlc_fifo_IsEmpty(fifo))
    {
        vlc_fifo_CleanupPush(fifo);
        vlc_fifo_Wait(fifo);
        vlc_cleanup_pop();
    }
    block = vlc_fifo_DequeueUnlocked(fifo);
    vlc_fifo_Unlock(fifo);

    return block;
}",1,1,misc\fifo.c,block_FifoGet,,false,184,201,block_FifoGet,,,17,block_t block_FifoGet (block_fifo_t*)
98081,METHOD,misc\fifo.c:<global>,TYPE_DECL,"block_t *block_FifoShow( block_fifo_t *p_fifo )
{
    block_t *b;

    vlc_mutex_lock( &p_fifo->lock );
    assert(p_fifo->p_first != NULL);
    b = p_fifo->p_first;
    vlc_mutex_unlock( &p_fifo->lock );

    return b;
}",1,1,misc\fifo.c,block_FifoShow,,false,203,213,block_FifoShow,,,18,block_t block_FifoShow (block_fifo_t*)
98110,METHOD,misc\fifo.c:<global>,TYPE_DECL,"size_t block_FifoSize (block_fifo_t *fifo)
{
    size_t size;

    vlc_mutex_lock (&fifo->lock);
    size = fifo->i_size;
    vlc_mutex_unlock (&fifo->lock);
    return size;
}",1,1,misc\fifo.c,block_FifoSize,,false,216,224,block_FifoSize,,,19,size_t block_FifoSize (block_fifo_t*)
98133,METHOD,misc\fifo.c:<global>,TYPE_DECL,"size_t block_FifoCount (block_fifo_t *fifo)
{
    size_t depth;

    vlc_mutex_lock (&fifo->lock);
    depth = fifo->i_depth;
    vlc_mutex_unlock (&fifo->lock);
    return depth;
}",1,1,misc\fifo.c,block_FifoCount,,false,227,235,block_FifoCount,,,20,size_t block_FifoCount (block_fifo_t*)
98175,METHOD,misc\filter.c:<global>,TYPE_DECL,<global>,1,25,misc\filter.c,misc\filter.c:<global>,,false,1,219,<global>,,,1,
98177,METHOD,misc\filter.c:<global>,TYPE_DECL,"static int TriggerFilterCallback(vlc_object_t *p_this, char const *psz_var,
                                 vlc_value_t oldval, vlc_value_t newval,
                                 void *p_data)
{
    (void) p_this; (void) oldval;
    var_Set((filter_t *)p_data, psz_var, newval);
    return 0;
}",1,1,misc\filter.c,TriggerFilterCallback,,false,38,45,TriggerFilterCallback,,,1,"int TriggerFilterCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
98200,METHOD,misc\filter.c:<global>,TYPE_DECL,"void filter_AddProxyCallbacks( vlc_object_t *obj, filter_t *filter,
                               vlc_callback_t restart_cb )
{
    char **names = var_GetAllNames(VLC_OBJECT(filter));
    if (names == NULL)
        return;

    for (char **pname = names; *pname != NULL; pname++)
    {
        char *name = *pname;
        int var_type = var_Type(filter, name);
        if (var_Type(obj, name))
        {
            free(name);
            continue;
        }
        var_Create(obj, name,
                   var_type | VLC_VAR_DOINHERIT | VLC_VAR_ISCOMMAND);
        if ((var_type & VLC_VAR_ISCOMMAND))
            var_AddCallback(obj, name, TriggerFilterCallback, filter);
        else
            var_AddCallback(obj, name, restart_cb, obj);
        free(name);
    }
    free(names);
}",1,1,misc\filter.c,filter_AddProxyCallbacks,,false,48,73,filter_AddProxyCallbacks,,,2,"void filter_AddProxyCallbacks (vlc_object_t*,filter_t*,vlc_callback_t)"
98280,METHOD,misc\filter.c:<global>,TYPE_DECL,"void filter_DelProxyCallbacks( vlc_object_t *obj, filter_t *filter,
                               vlc_callback_t restart_cb )
{
    char **names = var_GetAllNames(VLC_OBJECT(filter));
    if (names == NULL)
        return;

    for (char **pname = names; *pname != NULL; pname++)
    {
        char *name = *pname;
        if (!(var_Type(obj, name) & VLC_VAR_ISCOMMAND))
        {
            free(name);
            continue;
        }
        int filter_var_type = var_Type(filter, name);

        if (filter_var_type & VLC_VAR_ISCOMMAND)
            var_DelCallback(obj, name, TriggerFilterCallback, filter);
        else if (filter_var_type)
            var_DelCallback(obj, name, restart_cb, obj);
        var_Destroy(obj, name);
        free(name);
    }
    free(names);
}",1,1,misc\filter.c,filter_DelProxyCallbacks,,false,76,101,filter_DelProxyCallbacks,,,3,"void filter_DelProxyCallbacks (vlc_object_t*,filter_t*,vlc_callback_t)"
98361,METHOD,misc\filter.c:<global>,TYPE_DECL,"filter_t *filter_NewBlend( vlc_object_t *p_this,
                           const video_format_t *p_dst_chroma )
{
    filter_t *p_blend = vlc_custom_create( p_this, sizeof(*p_blend), ""blend"" );
    if( !p_blend )
        return NULL;

    es_format_Init( &p_blend->fmt_in, VIDEO_ES, 0 );

    es_format_Init( &p_blend->fmt_out, VIDEO_ES, 0 );

    p_blend->fmt_out.i_codec        =
    p_blend->fmt_out.video.i_chroma = p_dst_chroma->i_chroma;
    p_blend->fmt_out.video.i_rmask  = p_dst_chroma->i_rmask;
    p_blend->fmt_out.video.i_gmask  = p_dst_chroma->i_gmask;
    p_blend->fmt_out.video.i_bmask  = p_dst_chroma->i_bmask;
    p_blend->fmt_out.video.i_rrshift= p_dst_chroma->i_rrshift;
    p_blend->fmt_out.video.i_rgshift= p_dst_chroma->i_rgshift;
    p_blend->fmt_out.video.i_rbshift= p_dst_chroma->i_rbshift;
    p_blend->fmt_out.video.i_lrshift= p_dst_chroma->i_lrshift;
    p_blend->fmt_out.video.i_lgshift= p_dst_chroma->i_lgshift;
    p_blend->fmt_out.video.i_lbshift= p_dst_chroma->i_...",1,1,misc\filter.c,filter_NewBlend,,false,105,133,filter_NewBlend,,,4,"filter_t filter_NewBlend (vlc_object_t*,video_format_t*)"
98519,METHOD,misc\filter.c:<global>,TYPE_DECL,"int filter_ConfigureBlend( filter_t *p_blend,
                           int i_dst_width, int i_dst_height,
                           const video_format_t *p_src )
{
    /* */
    if( p_blend->p_module &&
        p_blend->fmt_in.video.i_chroma != p_src->i_chroma )
    {
        /* The chroma is not the same, we need to reload the blend module */
        module_unneed( p_blend, p_blend->p_module );
        p_blend->p_module = NULL;
    }

    /* */

    p_blend->fmt_in.i_codec = p_src->i_chroma;
    p_blend->fmt_in.video   = *p_src;

    /* */
    p_blend->fmt_out.video.i_width          =
    p_blend->fmt_out.video.i_visible_width  = i_dst_width;
    p_blend->fmt_out.video.i_height         =
    p_blend->fmt_out.video.i_visible_height = i_dst_height;

    /* */
    if( !p_blend->p_module )
        p_blend->p_module = module_need( p_blend, ""video blending"", NULL, false );
    if( !p_blend->p_module )
        return VLC_EGENERIC;
    return VLC_SUCCESS;
}",1,1,misc\filter.c,filter_ConfigureBlend,,false,135,165,filter_ConfigureBlend,,,5,"int filter_ConfigureBlend (filter_t*,int,int,video_format_t*)"
98630,METHOD,misc\filter.c:<global>,TYPE_DECL,"int filter_Blend( filter_t *p_blend,
                  picture_t *p_dst, int i_dst_x, int i_dst_y,
                  const picture_t *p_src, int i_alpha )
{
    if( !p_blend->p_module )
        return VLC_EGENERIC;

    p_blend->pf_video_blend( p_blend, p_dst, p_src, i_dst_x, i_dst_y, i_alpha );
    return VLC_SUCCESS;
}",1,1,misc\filter.c,filter_Blend,,false,167,176,filter_Blend,,,6,"int filter_Blend (filter_t*,picture_t*,int,int,picture_t*,int)"
98660,METHOD,misc\filter.c:<global>,TYPE_DECL,"void filter_DeleteBlend( filter_t *p_blend )
{
    if( p_blend->p_module )
        module_unneed( p_blend, p_blend->p_module );

    vlc_object_release( p_blend );
}",1,1,misc\filter.c,filter_DeleteBlend,,false,178,184,filter_DeleteBlend,,,7,void filter_DeleteBlend (filter_t*)
98677,METHOD,misc\filter.c:<global>,TYPE_DECL,"video_splitter_t *video_splitter_New( vlc_object_t *p_this,
                                      const char *psz_name,
                                      const video_format_t *p_fmt )
{
    video_splitter_t *p_splitter = vlc_custom_create( p_this,
                                       sizeof(*p_splitter), ""video splitter"" );
    if( !p_splitter )
        return NULL;

    video_format_Copy( &p_splitter->fmt, p_fmt );

    /* */
    p_splitter->p_module = module_need( p_splitter, ""video splitter"", psz_name, true );
    if( ! p_splitter->p_module )
    {
        video_splitter_Delete( p_splitter );
        return NULL;
    }

    return p_splitter;
}",1,1,misc\filter.c,video_splitter_New,,false,189,209,video_splitter_New,,,8,"video_splitter_t video_splitter_New (vlc_object_t*,char*,video_format_t*)"
98726,METHOD,misc\filter.c:<global>,TYPE_DECL,"void video_splitter_Delete( video_splitter_t *p_splitter )
{
    if( p_splitter->p_module )
        module_unneed( p_splitter, p_splitter->p_module );

    video_format_Clean( &p_splitter->fmt );

    vlc_object_release( p_splitter );
}",1,1,misc\filter.c,video_splitter_Delete,,false,211,219,video_splitter_Delete,,,9,void video_splitter_Delete (video_splitter_t*)
98765,METHOD,misc\filter_chain.c:<global>,TYPE_DECL,<global>,1,1,misc\filter_chain.c,misc\filter_chain.c:<global>,,false,1,529,<global>,,,1,
98775,METHOD,misc\filter_chain.c:<global>,TYPE_DECL,"static inline chained_filter_t *chained(filter_t *filter)
{
    return container_of(filter, chained_filter_t, filter);
}",1,1,misc\filter_chain.c,chained,,false,46,49,chained,,,3,chained_filter_t chained (filter_t*)
98795,METHOD,misc\filter_chain.c:<global>,TYPE_DECL,static void FilterDeletePictures( picture_t * );,13,47,misc\filter_chain.c,FilterDeletePictures,,false,69,69,FilterDeletePictures,,,5,void FilterDeletePictures (picture_t*)
98800,METHOD,misc\filter_chain.c:<global>,TYPE_DECL,"static filter_chain_t *filter_chain_NewInner( const filter_owner_t *callbacks,
    const char *cap, const char *conv_cap, bool fmt_out_change,
    const filter_owner_t *owner, enum es_format_category_e cat )
{
    assert( callbacks != NULL && callbacks->sys != NULL );
    assert( cap != NULL );

    filter_chain_t *chain = malloc( sizeof (*chain) );
    if( unlikely(chain == NULL) )
        return NULL;

    chain->callbacks = *callbacks;
    if( owner != NULL )
        chain->owner = *owner;
    chain->first = NULL;
    chain->last = NULL;
    es_format_Init( &chain->fmt_in, cat, 0 );
    es_format_Init( &chain->fmt_out, cat, 0 );
    chain->b_allow_fmt_out_change = fmt_out_change;
    chain->filter_cap = cap;
    chain->conv_cap = conv_cap;
    return chain;
}",1,1,misc\filter_chain.c,filter_chain_NewInner,,false,71,93,filter_chain_NewInner,,,6,"filter_chain_t filter_chain_NewInner (filter_owner_t*,char*,char*,bool,filter_owner_t*,es_format_category_e)"
98897,METHOD,misc\filter_chain.c:<global>,TYPE_DECL,"filter_chain_t *filter_chain_New( vlc_object_t *obj, const char *cap,
                                  enum es_format_category_e cat )
{
    filter_owner_t callbacks = {
        .sys = obj,
    };

    return filter_chain_NewInner( &callbacks, cap, NULL, false, NULL, cat );
}",1,1,misc\filter_chain.c,filter_chain_New,,false,99,107,filter_chain_New,,,7,"filter_chain_t filter_chain_New (vlc_object_t*,char*,es_format_category_e)"
98921,METHOD,misc\filter_chain.c:<global>,TYPE_DECL,"static picture_t *filter_chain_VideoBufferNew( filter_t *filter )
{
    if( chained(filter)->next != NULL )
    {
        picture_t *pic = picture_NewFromFormat( &filter->fmt_out.video );
        if( pic == NULL )
            msg_Err( filter, ""Failed to allocate picture"" );
        return pic;
    }
    else
    {
        filter_chain_t *chain = filter->owner.sys;

        /* XXX ugly */
        filter->owner.sys = chain->owner.sys;
        picture_t *pic = chain->owner.video.buffer_new( filter );
        filter->owner.sys = chain;
        return pic;
    }
}",1,1,misc\filter_chain.c,filter_chain_VideoBufferNew,,false,110,129,filter_chain_VideoBufferNew,,,8,picture_t filter_chain_VideoBufferNew (filter_t*)
98996,METHOD,misc\filter_chain.c:<global>,TYPE_DECL,"filter_chain_t *filter_chain_NewVideo( vlc_object_t *obj, bool allow_change,
                                       const filter_owner_t *restrict owner )
{
    filter_owner_t callbacks = {
        .sys = obj,
        .video = {
            .buffer_new = filter_chain_VideoBufferNew,
        },
    };

    return filter_chain_NewInner( &callbacks, ""video filter"",
                                  ""video converter"", allow_change, owner, VIDEO_ES );
}",1,1,misc\filter_chain.c,filter_chain_NewVideo,,false,132,144,filter_chain_NewVideo,,,9,"filter_chain_t filter_chain_NewVideo (vlc_object_t*,bool,filter_owner_t*)"
99028,METHOD,misc\filter_chain.c:<global>,TYPE_DECL,"void filter_chain_Delete( filter_chain_t *p_chain )
{
    while( p_chain->first != NULL )
        filter_chain_DeleteFilter( p_chain, &p_chain->first->filter );

    es_format_Clean( &p_chain->fmt_in );
    es_format_Clean( &p_chain->fmt_out );

    free( p_chain );
}",1,1,misc\filter_chain.c,filter_chain_Delete,,false,149,158,filter_chain_Delete,,,10,void filter_chain_Delete (filter_chain_t*)
99059,METHOD,misc\filter_chain.c:<global>,TYPE_DECL,"void filter_chain_Reset( filter_chain_t *p_chain, const es_format_t *p_fmt_in,
                         const es_format_t *p_fmt_out )
{
    while( p_chain->first != NULL )
        filter_chain_DeleteFilter( p_chain, &p_chain->first->filter );

    if( p_fmt_in )
    {
        es_format_Clean( &p_chain->fmt_in );
        es_format_Copy( &p_chain->fmt_in, p_fmt_in );
    }
    if( p_fmt_out )
    {
        es_format_Clean( &p_chain->fmt_out );
        es_format_Copy( &p_chain->fmt_out, p_fmt_out );
    }
}",1,1,misc\filter_chain.c,filter_chain_Reset,,false,162,178,filter_chain_Reset,,,11,"void filter_chain_Reset (filter_chain_t*,es_format_t*,es_format_t*)"
99108,METHOD,misc\filter_chain.c:<global>,TYPE_DECL,"static filter_t *filter_chain_AppendInner( filter_chain_t *chain,
    const char *name, const char *capability, config_chain_t *cfg,
    const es_format_t *fmt_in, const es_format_t *fmt_out )
{
    vlc_object_t *parent = chain->callbacks.sys;
    chained_filter_t *chained =
        vlc_custom_create( parent, sizeof(*chained), ""filter"" );
    if( unlikely(chained == NULL) )
        return NULL;

    filter_t *filter = &chained->filter;

    if( fmt_in == NULL )
    {
        if( chain->last != NULL )
            fmt_in = &chain->last->filter.fmt_out;
        else
            fmt_in = &chain->fmt_in;
    }

    if( fmt_out == NULL )
        fmt_out = &chain->fmt_out;

    es_format_Copy( &filter->fmt_in, fmt_in );
    es_format_Copy( &filter->fmt_out, fmt_out );
    filter->b_allow_fmt_out_change = chain->b_allow_fmt_out_change;
    filter->p_cfg = cfg;
    filter->psz_name = name;

    filter->owner = chain->callbacks;
    filter->owner.sys = chain;

    assert( capability != NULL )...",1,1,misc\filter_chain.c,filter_chain_AppendInner,,false,180,265,filter_chain_AppendInner,,,12,"filter_t filter_chain_AppendInner (filter_chain_t*,char*,char*,config_chain_t*,es_format_t*,es_format_t*)"
99419,METHOD,misc\filter_chain.c:<global>,TYPE_DECL,"filter_t *filter_chain_AppendFilter( filter_chain_t *chain,
    const char *name, config_chain_t *cfg,
    const es_format_t *fmt_in, const es_format_t *fmt_out )
{
    return filter_chain_AppendInner( chain, name, chain->filter_cap, cfg,
                                     fmt_in, fmt_out );
}",1,1,misc\filter_chain.c,filter_chain_AppendFilter,,false,267,273,filter_chain_AppendFilter,,,13,"filter_t filter_chain_AppendFilter (filter_chain_t*,char*,config_chain_t*,es_format_t*,es_format_t*)"
99438,METHOD,misc\filter_chain.c:<global>,TYPE_DECL,"int filter_chain_AppendConverter( filter_chain_t *chain,
    const es_format_t *fmt_in, const es_format_t *fmt_out )
{
    return filter_chain_AppendInner( chain, NULL, chain->conv_cap, NULL,
                                     fmt_in, fmt_out ) != NULL ? 0 : -1;
}",1,1,misc\filter_chain.c,filter_chain_AppendConverter,,false,275,280,filter_chain_AppendConverter,,,14,"int filter_chain_AppendConverter (filter_chain_t*,es_format_t*,es_format_t*)"
99461,METHOD,misc\filter_chain.c:<global>,TYPE_DECL,"void filter_chain_DeleteFilter( filter_chain_t *chain, filter_t *filter )
{
    vlc_object_t *obj = chain->callbacks.sys;
    chained_filter_t *chained = (chained_filter_t *)filter;

    /* Remove it from the chain */
    if( chained->prev != NULL )
        chained->prev->next = chained->next;
    else
    {
        assert( chained == chain->first );
        chain->first = chained->next;
    }

    if( chained->next != NULL )
        chained->next->prev = chained->prev;
    else
    {
        assert( chained == chain->last );
        chain->last = chained->prev;
    }

    module_unneed( filter, filter->p_module );

    msg_Dbg( obj, ""Filter %p removed from chain"", (void *)filter );
    FilterDeletePictures( chained->pending );

    free( chained->mouse );
    es_format_Clean( &filter->fmt_out );
    es_format_Clean( &filter->fmt_in );

    vlc_object_release( filter );
    /* FIXME: check fmt_in/fmt_out consitency */
}",1,1,misc\filter_chain.c,filter_chain_DeleteFilter,,false,282,315,filter_chain_DeleteFilter,,,15,"void filter_chain_DeleteFilter (filter_chain_t*,filter_t*)"
99574,METHOD,misc\filter_chain.c:<global>,TYPE_DECL,"int filter_chain_AppendFromString( filter_chain_t *chain, const char *str )
{
    vlc_object_t *obj = chain->callbacks.sys;
    char *buf = NULL;
    int ret = 0;

    while( str != NULL && str[0] != '\0' )
    {
        config_chain_t *cfg;
        char *name;

        char *next = config_ChainCreate( &name, &cfg, str );

        str = next;
        free( buf );
        buf = next;

        filter_t *filter = filter_chain_AppendFilter( chain, name, cfg,
                                                      NULL, NULL );
        if( cfg )
            config_ChainDestroy( cfg );

        if( filter == NULL )
        {
            msg_Err( obj, ""Failed to append '%s' to chain"", name );
            free( name );
            goto error;
        }

        free( name );
        ret++;
    }

    free( buf );
    return ret;

error:
    while( ret > 0 ) /* Unwind */
    {
        filter_chain_DeleteFilter( chain, &chain->last->filter );
        ret--;
    }
    free( buf );
    return VLC...",1,1,misc\filter_chain.c,filter_chain_AppendFromString,,false,318,362,filter_chain_AppendFromString,,,16,"int filter_chain_AppendFromString (filter_chain_t*,char*)"
99680,METHOD,misc\filter_chain.c:<global>,TYPE_DECL,"int filter_chain_ForEach( filter_chain_t *chain,
                          int (*cb)( filter_t *, void * ), void *opaque )
{
    for( chained_filter_t *f = chain->first; f != NULL; f = f->next )
    {
        int ret = cb( &f->filter, opaque );
        if( ret )
            return ret;
    }
    return VLC_SUCCESS;
}",1,1,misc\filter_chain.c,filter_chain_ForEach,,false,364,374,filter_chain_ForEach,,,17,"int filter_chain_ForEach (filter_chain_t*,int,void*)"
99720,METHOD,misc\filter_chain.c:<global>,TYPE_DECL,"bool filter_chain_IsEmpty(const filter_chain_t *chain)
{
    return chain->first == NULL;
}",1,1,misc\filter_chain.c,filter_chain_IsEmpty,,false,376,379,filter_chain_IsEmpty,,,18,bool filter_chain_IsEmpty (filter_chain_t*)
99731,METHOD,misc\filter_chain.c:<global>,TYPE_DECL,"const es_format_t *filter_chain_GetFmtOut( filter_chain_t *p_chain )
{

    if( p_chain->b_allow_fmt_out_change )
        return &p_chain->fmt_out;

    if( p_chain->last != NULL )
        return &p_chain->last->filter.fmt_out;

    /* Unless filter_chain_Reset has been called we are doomed */
    return &p_chain->fmt_out;
}",1,1,misc\filter_chain.c,filter_chain_GetFmtOut,,false,381,392,filter_chain_GetFmtOut,,,19,es_format_t filter_chain_GetFmtOut (filter_chain_t*)
99767,METHOD,misc\filter_chain.c:<global>,TYPE_DECL,"static picture_t *FilterChainVideoFilter( chained_filter_t *f, picture_t *p_pic )
{
    for( ; f != NULL; f = f->next )
    {
        filter_t *p_filter = &f->filter;
        p_pic = p_filter->pf_video_filter( p_filter, p_pic );
        if( !p_pic )
            break;
        if( f->pending )
        {
            msg_Warn( p_filter, ""dropping pictures"" );
            FilterDeletePictures( f->pending );
        }
        f->pending = p_pic->p_next;
        p_pic->p_next = NULL;
    }
    return p_pic;
}",1,1,misc\filter_chain.c,FilterChainVideoFilter,,false,394,411,FilterChainVideoFilter,,,20,"picture_t FilterChainVideoFilter (chained_filter_t*,picture_t*)"
99830,METHOD,misc\filter_chain.c:<global>,TYPE_DECL,"picture_t *filter_chain_VideoFilter( filter_chain_t *p_chain, picture_t *p_pic )
{
    if( p_pic )
    {
        p_pic = FilterChainVideoFilter( p_chain->first, p_pic );
        if( p_pic )
            return p_pic;
    }
    for( chained_filter_t *b = p_chain->last; b != NULL; b = b->prev )
    {
        p_pic = b->pending;
        if( !p_pic )
            continue;
        b->pending = p_pic->p_next;
        p_pic->p_next = NULL;

        p_pic = FilterChainVideoFilter( b->next, p_pic );
        if( p_pic )
            return p_pic;
    }
    return NULL;
}",1,1,misc\filter_chain.c,filter_chain_VideoFilter,,false,413,434,filter_chain_VideoFilter,,,21,"picture_t filter_chain_VideoFilter (filter_chain_t*,picture_t*)"
99904,METHOD,misc\filter_chain.c:<global>,TYPE_DECL,"void filter_chain_VideoFlush( filter_chain_t *p_chain )
{
    for( chained_filter_t *f = p_chain->first; f != NULL; f = f->next )
    {
        filter_t *p_filter = &f->filter;

        FilterDeletePictures( f->pending );
        f->pending = NULL;

        filter_Flush( p_filter );
    }
}",1,1,misc\filter_chain.c,filter_chain_VideoFlush,,false,436,447,filter_chain_VideoFlush,,,22,void filter_chain_VideoFlush (filter_chain_t*)
99944,METHOD,misc\filter_chain.c:<global>,TYPE_DECL,"void filter_chain_SubSource( filter_chain_t *p_chain, spu_t *spu,
                             mtime_t display_date )
{
    for( chained_filter_t *f = p_chain->first; f != NULL; f = f->next )
    {
        filter_t *p_filter = &f->filter;
        subpicture_t *p_subpic = p_filter->pf_sub_source( p_filter, display_date );
        if( p_subpic )
            spu_PutSubpicture( spu, p_subpic );
    }
}",1,1,misc\filter_chain.c,filter_chain_SubSource,,false,449,459,filter_chain_SubSource,,,23,"void filter_chain_SubSource (filter_chain_t*,spu_t*,mtime_t)"
99990,METHOD,misc\filter_chain.c:<global>,TYPE_DECL,"subpicture_t *filter_chain_SubFilter( filter_chain_t *p_chain, subpicture_t *p_subpic )
{
    for( chained_filter_t *f = p_chain->first; f != NULL; f = f->next )
    {
        filter_t *p_filter = &f->filter;

        p_subpic = p_filter->pf_sub_filter( p_filter, p_subpic );

        if( !p_subpic )
            break;
    }
    return p_subpic;
}",1,1,misc\filter_chain.c,filter_chain_SubFilter,,false,461,473,filter_chain_SubFilter,,,24,"subpicture_t filter_chain_SubFilter (filter_chain_t*,subpicture_t*)"
100035,METHOD,misc\filter_chain.c:<global>,TYPE_DECL,"int filter_chain_MouseFilter( filter_chain_t *p_chain, vlc_mouse_t *p_dst, const vlc_mouse_t *p_src )
{
    vlc_mouse_t current = *p_src;

    for( chained_filter_t *f = p_chain->last; f != NULL; f = f->prev )
    {
        filter_t *p_filter = &f->filter;
        vlc_mouse_t *p_mouse = f->mouse;

        if( p_filter->pf_video_mouse && p_mouse )
        {
            vlc_mouse_t old = *p_mouse;
            vlc_mouse_t filtered;

            *p_mouse = current;
            if( p_filter->pf_video_mouse( p_filter, &filtered, &old, &current ) )
                return VLC_EGENERIC;
            current = filtered;
        }
    }

    *p_dst = current;
    return VLC_SUCCESS;
}",1,1,misc\filter_chain.c,filter_chain_MouseFilter,,false,475,498,filter_chain_MouseFilter,,,25,"int filter_chain_MouseFilter (filter_chain_t*,vlc_mouse_t*,vlc_mouse_t*)"
100118,METHOD,misc\filter_chain.c:<global>,TYPE_DECL,"int filter_chain_MouseEvent( filter_chain_t *p_chain,
                             const vlc_mouse_t *p_mouse,
                             const video_format_t *p_fmt )
{
    for( chained_filter_t *f = p_chain->first; f != NULL; f = f->next )
    {
        filter_t *p_filter = &f->filter;

        if( p_filter->pf_sub_mouse )
        {
            vlc_mouse_t old = *f->mouse;
            *f->mouse = *p_mouse;
            if( p_filter->pf_sub_mouse( p_filter, &old, p_mouse, p_fmt ) )
                return VLC_EGENERIC;
        }
    }

    return VLC_SUCCESS;
}",1,1,misc\filter_chain.c,filter_chain_MouseEvent,,false,500,518,filter_chain_MouseEvent,,,26,"int filter_chain_MouseEvent (filter_chain_t*,vlc_mouse_t*,video_format_t*)"
100183,METHOD,misc\filter_chain.c:<global>,TYPE_DECL,"static void FilterDeletePictures( picture_t *picture )
{
    while( picture )
    {
        picture_t *next = picture->p_next;
        picture_Release( picture );
        picture = next;
    }
}",1,1,misc\filter_chain.c,FilterDeletePictures,,false,521,529,FilterDeletePictures,,,27,void FilterDeletePictures (picture_t*)
100215,METHOD,misc\fingerprinter.c:<global>,TYPE_DECL,<global>,1,25,misc\fingerprinter.c,misc\fingerprinter.c:<global>,,false,1,58,<global>,,,1,
100217,METHOD,misc\fingerprinter.c:<global>,TYPE_DECL,"fingerprinter_thread_t *fingerprinter_Create( vlc_object_t *p_this )
{
    fingerprinter_thread_t *p_fingerprint;

    p_fingerprint = ( fingerprinter_thread_t * )
            vlc_custom_create( p_this, sizeof( *p_fingerprint ), ""fingerprinter"" );
    if( !p_fingerprint )
    {
        msg_Err( p_this, ""unable to create fingerprinter"" );
        return NULL;
    }

    p_fingerprint->p_module = module_need( p_fingerprint, ""fingerprinter"",
                                           NULL, false );
    if( !p_fingerprint->p_module )
    {
        vlc_object_release( p_fingerprint );
        msg_Err( p_this, ""AcoustID fingerprinter not found"" );
        return NULL;
    }

    return p_fingerprint;
}",1,12,misc\fingerprinter.c,fingerprinter_Create,,false,30,52,fingerprinter_Create,,,1,fingerprinter_thread_t fingerprinter_Create (vlc_object_t*)
100271,METHOD,misc\fingerprinter.c:<global>,TYPE_DECL,"void fingerprinter_Destroy( fingerprinter_thread_t *p_fingerprint )
{
    module_unneed( p_fingerprint, p_fingerprint->p_module );
    vlc_object_release( p_fingerprint );
}",1,1,misc\fingerprinter.c,fingerprinter_Destroy,,false,54,58,fingerprinter_Destroy,,,2,void fingerprinter_Destroy (fingerprinter_thread_t*)
100298,METHOD,misc\fourcc.c:<global>,TYPE_DECL,<global>,1,52,misc\fourcc.c,misc\fourcc.c:<global>,,false,1,793,<global>,,,1,
100300,METHOD,misc\fourcc.c:<global>,TYPE_DECL,"static int fourcc_cmp(const void *key, const void *ent)
{
    return memcmp(key, ent, 4);
}",1,1,misc\fourcc.c,fourcc_cmp,,false,38,41,fourcc_cmp,,,1,"int fourcc_cmp (void*,void*)"
100311,METHOD,misc\fourcc.c:<global>,TYPE_DECL,"static vlc_fourcc_t Lookup(vlc_fourcc_t fourcc, const char **restrict dsc,
                           const struct fourcc_mapping *mapv, size_t mapc,
                           const struct fourcc_desc *dscv, size_t dscc)
{
    const struct fourcc_mapping *mapping;
    const struct fourcc_desc *desc;

    mapping = bsearch(&fourcc, mapv, mapc, sizeof (*mapv), fourcc_cmp);
    if (mapping != NULL)
    {
        if (dsc != NULL)
        {
            desc = bsearch(&fourcc, dscv, dscc, sizeof (*dscv), fourcc_cmp);
            if (desc != NULL)
            {
                *dsc = desc->desc;
                return mapping->fourcc;
            }
        }
        fourcc = mapping->fourcc;
    }

    desc = bsearch(&fourcc, dscv, dscc, sizeof (*dscv), fourcc_cmp);
    if (desc == NULL)
        return 0; /* Unknown FourCC */
    if (dsc != NULL)
        *dsc = desc->desc;
    return fourcc; /* Known FourCC (has a description) */
}",1,1,misc\fourcc.c,Lookup,,false,43,71,Lookup,,,2,"vlc_fourcc_t Lookup (vlc_fourcc_t,char**,fourcc_mapping*,size_t,fourcc_desc*,size_t)"
100406,METHOD,misc\fourcc.c:<global>,TYPE_DECL,"static vlc_fourcc_t LookupVideo(vlc_fourcc_t fourcc, const char **restrict dsc)
{
    return Lookup(fourcc, dsc, mapping_video,
                  sizeof (mapping_video) / sizeof (mapping_video[0]),
                  desc_video, sizeof (desc_video) / sizeof (desc_video[0]));
}",1,1,misc\fourcc.c,LookupVideo,,false,73,78,LookupVideo,,,3,"vlc_fourcc_t LookupVideo (vlc_fourcc_t,char**)"
100428,METHOD,misc\fourcc.c:<global>,TYPE_DECL,"static vlc_fourcc_t LookupAudio(vlc_fourcc_t fourcc, const char **restrict dsc)
{
    return Lookup(fourcc, dsc, mapping_audio,
                  sizeof (mapping_audio) / sizeof (mapping_audio[0]),
                  desc_audio, sizeof (desc_audio) / sizeof (desc_audio[0]));
}",1,1,misc\fourcc.c,LookupAudio,,false,80,85,LookupAudio,,,4,"vlc_fourcc_t LookupAudio (vlc_fourcc_t,char**)"
100450,METHOD,misc\fourcc.c:<global>,TYPE_DECL,"static vlc_fourcc_t LookupSpu(vlc_fourcc_t fourcc, const char **restrict dsc)
{
    return Lookup(fourcc, dsc, mapping_spu,
                  sizeof (mapping_spu) / sizeof (mapping_spu[0]),
                  desc_spu, sizeof (desc_spu) / sizeof (desc_spu[0]));
}",1,1,misc\fourcc.c,LookupSpu,,false,87,92,LookupSpu,,,5,"vlc_fourcc_t LookupSpu (vlc_fourcc_t,char**)"
100472,METHOD,misc\fourcc.c:<global>,TYPE_DECL,"static vlc_fourcc_t LookupCat(vlc_fourcc_t fourcc, const char **restrict dsc,
                              int cat)
{
    switch (cat)
    {
        case VIDEO_ES:
            return LookupVideo(fourcc, dsc);
        case AUDIO_ES:
            return LookupAudio(fourcc, dsc);
        case SPU_ES:
            return LookupSpu(fourcc, dsc);
    }

    vlc_fourcc_t ret = LookupVideo(fourcc, dsc);
    if (!ret)
        ret = LookupAudio(fourcc, dsc);
    if (!ret)
        ret = LookupSpu(fourcc, dsc);
    return ret;
}",1,1,misc\fourcc.c,LookupCat,,false,94,113,LookupCat,,,6,"vlc_fourcc_t LookupCat (vlc_fourcc_t,char**,int)"
100526,METHOD,misc\fourcc.c:<global>,TYPE_DECL,"vlc_fourcc_t vlc_fourcc_GetCodec(int cat, vlc_fourcc_t fourcc)
{
    vlc_fourcc_t codec = LookupCat(fourcc, NULL, cat);
    return codec ? codec : fourcc;
}",1,1,misc\fourcc.c,vlc_fourcc_GetCodec,,false,115,119,vlc_fourcc_GetCodec,,,7,"vlc_fourcc_t vlc_fourcc_GetCodec (int,vlc_fourcc_t)"
100544,METHOD,misc\fourcc.c:<global>,TYPE_DECL,"vlc_fourcc_t vlc_fourcc_GetCodecFromString( int i_cat, const char *psz_fourcc )
{
    if( !psz_fourcc || strlen(psz_fourcc) != 4 )
        return 0;
    return vlc_fourcc_GetCodec( i_cat,
                                VLC_FOURCC( psz_fourcc[0], psz_fourcc[1],
                                            psz_fourcc[2], psz_fourcc[3] ) );
}",1,1,misc\fourcc.c,vlc_fourcc_GetCodecFromString,,false,121,128,vlc_fourcc_GetCodecFromString,,,8,"vlc_fourcc_t vlc_fourcc_GetCodecFromString (int,char*)"
100577,METHOD,misc\fourcc.c:<global>,TYPE_DECL,"vlc_fourcc_t vlc_fourcc_GetCodecAudio( vlc_fourcc_t i_fourcc, int i_bits )
{
    const int i_bytes = ( i_bits + 7 ) / 8;

    if( i_fourcc == VLC_FOURCC( 'a', 'f', 'l', 't' ) )
    {
        switch( i_bytes )
        {
        case 4:
            return VLC_CODEC_FL32;
        case 8:
            return VLC_CODEC_FL64;
        default:
            return 0;
        }
    }
    else if( i_fourcc == VLC_FOURCC( 'a', 'r', 'a', 'w' ) )
    {
        switch( i_bytes )
        {
        case 1:
            return VLC_CODEC_U8;
        case 2:
            return VLC_CODEC_S16L;
        case 3:
            return VLC_CODEC_S24L;
        case 4:
            return VLC_CODEC_S32L;
        default:
            return 0;
        }
    }
    else if( i_fourcc == VLC_FOURCC( 't', 'w', 'o', 's' ) )
    {
        switch( i_bytes )
        {
        case 1:
            return VLC_CODEC_S8;
        case 2:
            return VLC_CODEC_S16B;
        case 3:
            return VLC_CODEC_S24B;
        c...",1,1,misc\fourcc.c,vlc_fourcc_GetCodecAudio,,false,130,198,vlc_fourcc_GetCodecAudio,,,9,"vlc_fourcc_t vlc_fourcc_GetCodecAudio (vlc_fourcc_t,int)"
100719,METHOD,misc\fourcc.c:<global>,TYPE_DECL,"const char *vlc_fourcc_GetDescription(int cat, vlc_fourcc_t fourcc)
{
    const char *ret;

    return LookupCat(fourcc, &ret, cat) ? ret : """";
}",1,1,misc\fourcc.c,vlc_fourcc_GetDescription,,false,200,205,vlc_fourcc_GetDescription,,,10,"const char* vlc_fourcc_GetDescription (int,vlc_fourcc_t)"
101940,METHOD,misc\fourcc.c:<global>,TYPE_DECL,"static const vlc_fourcc_t *GetFallback( vlc_fourcc_t i_fourcc,
                                        const vlc_fourcc_t *pp_fallback[],
                                        const vlc_fourcc_t p_list[] )
{
    for( unsigned i = 0; pp_fallback[i]; i++ )
    {
        if( pp_fallback[i][0] == i_fourcc )
            return pp_fallback[i];
    }
    return p_list;
}",1,1,misc\fourcc.c,GetFallback,,false,597,607,GetFallback,,,121,"vlc_fourcc_t GetFallback (vlc_fourcc_t,vlc_fourcc_t[]*,vlc_fourcc_t[])"
101974,METHOD,misc\fourcc.c:<global>,TYPE_DECL,"const vlc_fourcc_t *vlc_fourcc_GetYUVFallback( vlc_fourcc_t i_fourcc )
{
    return GetFallback( i_fourcc, pp_YUV_fallback, p_list_YUV );
}",1,1,misc\fourcc.c,vlc_fourcc_GetYUVFallback,,false,609,612,vlc_fourcc_GetYUVFallback,,,122,vlc_fourcc_t vlc_fourcc_GetYUVFallback (vlc_fourcc_t)
101984,METHOD,misc\fourcc.c:<global>,TYPE_DECL,"const vlc_fourcc_t *vlc_fourcc_GetRGBFallback( vlc_fourcc_t i_fourcc )
{
    return GetFallback( i_fourcc, pp_RGB_fallback, p_RGB32_fallback );
}",1,1,misc\fourcc.c,vlc_fourcc_GetRGBFallback,,false,613,616,vlc_fourcc_GetRGBFallback,,,123,vlc_fourcc_t vlc_fourcc_GetRGBFallback (vlc_fourcc_t)
101994,METHOD,misc\fourcc.c:<global>,TYPE_DECL,"bool vlc_fourcc_AreUVPlanesSwapped( vlc_fourcc_t a, vlc_fourcc_t b )
{
    static const vlc_fourcc_t pp_swapped[][4] = {
        { VLC_CODEC_YV12, VLC_CODEC_I420, VLC_CODEC_J420, 0 },
        { VLC_CODEC_YV9,  VLC_CODEC_I410, 0 },
        { 0 }
    };

    for( int i = 0; pp_swapped[i][0]; i++ )
    {
        if( pp_swapped[i][0] == b )
        {
            vlc_fourcc_t t = a;
            a = b;
            b = t;
        }
        if( pp_swapped[i][0] != a )
            continue;
        for( int j = 1; pp_swapped[i][j]; j++ )
        {
            if( pp_swapped[i][j] == b )
                return true;
        }
    }
    return false;
}",1,1,misc\fourcc.c,vlc_fourcc_AreUVPlanesSwapped,,false,618,643,vlc_fourcc_AreUVPlanesSwapped,,,124,"bool vlc_fourcc_AreUVPlanesSwapped (vlc_fourcc_t,vlc_fourcc_t)"
102085,METHOD,misc\fourcc.c:<global>,TYPE_DECL,"bool vlc_fourcc_IsYUV(vlc_fourcc_t fcc)
{
    for( unsigned i = 0; p_list_YUV[i]; i++ )
    {
        if( p_list_YUV[i] == fcc )
            return true;
    }
    return false;
}",1,1,misc\fourcc.c,vlc_fourcc_IsYUV,,false,645,653,vlc_fourcc_IsYUV,,,125,bool vlc_fourcc_IsYUV (vlc_fourcc_t)
102116,METHOD,<empty>,<empty>,<empty>,1,,misc\fourcc.c,p_list_chroma_description:<clinit>,,false,687,,<clinit>,,,3,
104764,METHOD,misc\fourcc.c:<global>,TYPE_DECL,"const vlc_chroma_description_t *vlc_fourcc_GetChromaDescription( vlc_fourcc_t i_fourcc )
{
    for( unsigned i = 0; p_list_chroma_description[i].p_fourcc[0]; i++ )
    {
        const vlc_fourcc_t *p_fourcc = p_list_chroma_description[i].p_fourcc;
        for( unsigned j = 0; j < 4 && p_fourcc[j] != 0; j++ )
        {
            if( p_fourcc[j] == i_fourcc )
                return &p_list_chroma_description[i].description;
        }
    }
    return NULL;
}",1,1,misc\fourcc.c,vlc_fourcc_GetChromaDescription,,false,781,793,vlc_fourcc_GetChromaDescription,,,129,vlc_chroma_description_t vlc_fourcc_GetChromaDescription (vlc_fourcc_t)
104848,METHOD,misc\fourcc_gen.c:<global>,TYPE_DECL,<global>,1,1,misc\fourcc_gen.c,misc\fourcc_gen.c:<global>,,false,1,154,<global>,,,1,
104859,METHOD,<empty>,<empty>,<empty>,1,,misc\fourcc_gen.c,staticentry_t:<clinit>,,false,42,,<clinit>,,,4,
104870,METHOD,<empty>,<empty>,<empty>,1,,misc\fourcc_gen.c,entry:<clinit>,,false,51,,<clinit>,,,4,
104878,METHOD,misc\fourcc_gen.c:<global>,TYPE_DECL,"static int cmp_entry(const void *a, const void *b)
{
    const struct entry *ea = a, *eb = b;
    int d = memcmp(ea->alias, eb->alias, 4);
    if (d == 0)
        d = memcmp(ea->fourcc, eb->fourcc, 4);
    return d;
}",1,1,misc\fourcc_gen.c,cmp_entry,,false,58,65,cmp_entry,,,7,"int cmp_entry (void*,void*)"
104920,METHOD,misc\fourcc_gen.c:<global>,TYPE_DECL,"static void process_list(const char *name, const staticentry_t *list, size_t n)
{
    struct entry *entries = malloc(sizeof (*entries) * n);
    if (entries == NULL)
        abort();

    const staticentry_t *klass = NULL;

    for (size_t i = 0; i < n; i++)
    {
        if (list[i].klass)
            klass = &list[i];

        if (klass == NULL)
        {
            fprintf(stderr, ""Error: FourCC \""%.4s\"" not mapped!\n"",
                    list[i].fourcc);
            exit(1);
        }

        memcpy(entries[i].fourcc, klass->fourcc, 4);
        memcpy(entries[i].alias, list[i].fourcc, 4);
        entries[i].desc = list[i].description;
    }

    qsort(entries, n, sizeof (*entries), cmp_entry);

    size_t dups = 0;
    for (size_t i = 1; i < n; i++)
        if (!memcmp(entries[i - 1].alias, entries[i].alias, 4)
         && memcmp(entries[i - 1].fourcc, entries[i].fourcc, 4))
        {
            fprintf(stderr, ""Error: FourCC alias \""%.4s\"" conflict: ""
                    ""\...",1,1,misc\fourcc_gen.c,process_list,,false,67,133,process_list,,,8,"void process_list (char*,staticentry_t*,size_t)"
105262,METHOD,misc\fourcc_gen.c:<global>,TYPE_DECL,"int main(void)
{
    puts(""/* This file is generated automatically. DO NOT EDIT! */"");
    puts(""struct fourcc_mapping {"");
    puts(""    union { unsigned char alias_str[4]; vlc_fourcc_t alias; };"");
    puts(""    union { unsigned char fourcc_str[4]; vlc_fourcc_t fourcc; };"");
    puts(""};"");
    puts(""struct fourcc_desc {"");
    puts(""    union { unsigned char alias_str[4]; vlc_fourcc_t alias; };"");
    puts(""    const char desc[52];"");
    puts(""};"");

#define p(t) \
    process_list(#t, p_list_##t, \
                 sizeof (p_list_##t) / sizeof ((p_list_##t)[0]))
    p(video);
    p(audio);
    p(spu);
    return 0;
}",1,4,misc\fourcc_gen.c,main,,false,135,154,main,,,9,int main (void)
105326,METHOD,misc\fourcc_list.h:<global>,TYPE_DECL,<global>,1,2,misc\fourcc_list.h,misc\fourcc_list.h:<global>,,false,1,1633,<global>,,,1,
108242,METHOD,misc\httpcookies.c:<global>,TYPE_DECL,<global>,1,1,misc\httpcookies.c,misc\httpcookies.c:<global>,,false,1,385,<global>,,,1,
108252,METHOD,misc\httpcookies.c:<global>,TYPE_DECL,"static char *cookie_get_attribute_value( const char *cookie, const char *attr )
{
    size_t attrlen = strlen( attr );
    const char * str = strchr( cookie, ';' );
    while( str )
    {
        /* skip ; and blank */
        str++;
        str = str + strspn( str, "" "" );

        if( !vlc_ascii_strncasecmp( str, attr, attrlen )
         && (str[attrlen] == '=') )
        {
            str += attrlen + 1;
            size_t value_length = strcspn( str, "";"" );
            return strndup( str, value_length );
        }

        str = strchr( str, ';' );
    }
    return NULL;
}",1,1,misc\httpcookies.c,cookie_get_attribute_value,,false,48,69,cookie_get_attribute_value,,,3,"char* cookie_get_attribute_value (char*,char*)"
108316,METHOD,misc\httpcookies.c:<global>,TYPE_DECL,"static bool cookie_has_attribute( const char *cookie, const char *attr )
{
    size_t attrlen = strlen(attr);
    const char * str = strchr(cookie, ';');
    while( str )
    {
        /* skip ; and blank */
        str++;
        str += strspn( str, "" "" );

        if( !vlc_ascii_strncasecmp( str, attr, attrlen )
         && (str[attrlen] == '=' || str[attrlen] == ';' || str[attrlen] == '\0') )
            return true;

        str = strchr(str, ';');
    }
    return false;
}",1,1,misc\httpcookies.c,cookie_has_attribute,,false,71,88,cookie_has_attribute,,,4,"bool cookie_has_attribute (char*,char*)"
108377,METHOD,misc\httpcookies.c:<global>,TYPE_DECL,"static char *cookie_get_domain( const char *cookie )
{
    char *domain = cookie_get_attribute_value( cookie, ""domain"" );
    if( domain == NULL )
        return NULL;

    if( domain[0] == '.' )
    {
        const char *real_domain = domain + strspn( domain, ""."" );
        memmove( domain, real_domain, strlen( real_domain ) + 1 );
    }
    return domain;
}",1,1,misc\httpcookies.c,cookie_get_domain,,false,91,103,cookie_get_domain,,,5,char* cookie_get_domain (char*)
108419,METHOD,misc\httpcookies.c:<global>,TYPE_DECL,"static bool cookie_domain_matches( const http_cookie_t *cookie,
                                   const char *host )
{
    // TODO: should convert domain names to punycode before comparing

    if (host == NULL)
        return false;
    if ( vlc_ascii_strcasecmp(cookie->psz_domain, host) == 0 )
        return true;
    else if ( cookie->b_host_only )
        return false;

    size_t host_len = strlen(host);
    size_t cookie_domain_len = strlen(cookie->psz_domain);
    bool is_suffix = false, has_dot_before_suffix = false;

    if( host_len > cookie_domain_len )
    {
        size_t i = host_len - cookie_domain_len;

        is_suffix = vlc_ascii_strcasecmp( &host[i], cookie->psz_domain ) == 0;
        has_dot_before_suffix = host[i-1] == '.';
    }

    bool host_is_ipv4 = strspn(host, ""0123456789."") == host_len;
    bool host_is_ipv6 = strchr(host, ':') != NULL;
    return is_suffix && has_dot_before_suffix &&
        !( host_is_ipv4 || host_is_ipv6 );
}",1,1,misc\httpcookies.c,cookie_domain_matches,,false,105,133,cookie_domain_matches,,,6,"bool cookie_domain_matches (http_cookie_t*,char*)"
108529,METHOD,misc\httpcookies.c:<global>,TYPE_DECL,"static char *cookie_get_path(const char *cookie)
{
    return cookie_get_attribute_value(cookie, ""path"");
}",1,1,misc\httpcookies.c,cookie_get_path,,false,135,138,cookie_get_path,,,7,char* cookie_get_path (char*)
108538,METHOD,misc\httpcookies.c:<global>,TYPE_DECL,"static bool cookie_path_matches( const http_cookie_t * cookie, const char *uripath )
{
    if (uripath == NULL )
        return false;
    else if ( strcmp(cookie->psz_path, uripath) == 0 )
        return true;

    size_t path_len = strlen( uripath );
    size_t prefix_len = strlen( cookie->psz_path );
    return ( path_len > prefix_len ) &&
        ( strncmp(uripath, cookie->psz_path, prefix_len) == 0 ) &&
        ( uripath[prefix_len - 1] == '/' || uripath[prefix_len] == '/' );
}",1,1,misc\httpcookies.c,cookie_path_matches,,false,140,152,cookie_path_matches,,,8,"bool cookie_path_matches (http_cookie_t*,char*)"
108603,METHOD,misc\httpcookies.c:<global>,TYPE_DECL,"static bool cookie_should_be_sent(const http_cookie_t *cookie, bool secure,
                                  const char *host, const char *path)
{
    bool protocol_ok = secure || !cookie->b_secure;
    bool domain_ok = cookie_domain_matches(cookie, host);
    bool path_ok = cookie_path_matches(cookie, path);
    return protocol_ok && domain_ok && path_ok;
}",1,1,misc\httpcookies.c,cookie_should_be_sent,,false,154,161,cookie_should_be_sent,,,9,"bool cookie_should_be_sent (http_cookie_t*,bool,char*,char*)"
108638,METHOD,misc\httpcookies.c:<global>,TYPE_DECL,"static char *cookie_default_path( const char *request_path )
{
    if ( request_path == NULL || request_path[0] != '/' )
        return strdup(""/"");

    char *path;
    const char *query_start = strchr( request_path, '?' );
    if ( query_start != NULL )
        path = strndup( request_path, query_start - request_path );
    else
        path = strdup( request_path );

    if ( path == NULL )
        return NULL;

    char *last_slash = strrchr(path, '/');
    assert(last_slash != NULL);
    if ( last_slash == path )
        path[1] = '\0';
    else
        *last_slash = '\0';

    return path;
}",1,1,misc\httpcookies.c,cookie_default_path,,false,163,186,cookie_default_path,,,10,char* cookie_default_path (char*)
108717,METHOD,misc\httpcookies.c:<global>,TYPE_DECL,"static void cookie_destroy(http_cookie_t *cookie)
{
    assert(cookie != NULL);
    free(cookie->psz_name);
    free(cookie->psz_value);
    free(cookie->psz_domain);
    free(cookie->psz_path);
    free(cookie);
}",1,1,misc\httpcookies.c,cookie_destroy,,false,188,196,cookie_destroy,,,11,void cookie_destroy (http_cookie_t*)
108746,METHOD,misc\httpcookies.c:<global>,TYPE_DECL,"static http_cookie_t *cookie_parse(const char *value,
                                   const char *host, const char *path)
{
    http_cookie_t *cookie = malloc(sizeof (*cookie));
    if (unlikely(cookie == NULL))
        return NULL;

    cookie->psz_domain = NULL;
    cookie->psz_path = NULL;

    /* Get the NAME=VALUE part of the Cookie */
    size_t value_length = strcspn(value, "";"");
    const char *p = memchr(value, '=', value_length);

    if (p != NULL)
    {
        cookie->psz_name = strndup(value, p - value);
        p++;
        cookie->psz_value = strndup(p, value_length - (p - value));
        if (unlikely(cookie->psz_value == NULL))
            goto error;
    }
    else
    {
        cookie->psz_name = strndup(value, value_length);
        cookie->psz_value = NULL;
    }

    if (unlikely(cookie->psz_name == NULL))
        goto error;

    /* Cookie name is a token; it cannot be empty. */
    if (cookie->psz_name[0] == '\0')
        goto error;

    /* Get domain */...",1,1,misc\httpcookies.c,cookie_parse,,false,199,264,cookie_parse,,,14,"http_cookie_t cookie_parse (char*,char*,char*)"
108945,METHOD,misc\httpcookies.c:<global>,TYPE_DECL,"vlc_http_cookie_jar_t * vlc_http_cookies_new(void)
{
    vlc_http_cookie_jar_t * jar = malloc( sizeof( vlc_http_cookie_jar_t ) );
    if ( unlikely(jar == NULL) )
        return NULL;

    vlc_array_init( &jar->cookies );
    vlc_mutex_init( &jar->lock );

    return jar;
}",1,1,misc\httpcookies.c,vlc_http_cookies_new,,false,272,282,vlc_http_cookies_new,,,16,vlc_http_cookie_jar_t vlc_http_cookies_new (void)
108976,METHOD,misc\httpcookies.c:<global>,TYPE_DECL,"void vlc_http_cookies_destroy( vlc_http_cookie_jar_t * p_jar )
{
    if ( !p_jar )
        return;

    for( size_t i = 0; i < vlc_array_count( &p_jar->cookies ); i++ )
        cookie_destroy( vlc_array_item_at_index( &p_jar->cookies, i ) );

    vlc_array_clear( &p_jar->cookies );
    vlc_mutex_destroy( &p_jar->lock );

    free( p_jar );
}",1,1,misc\httpcookies.c,vlc_http_cookies_destroy,,false,284,296,vlc_http_cookies_destroy,,,17,void vlc_http_cookies_destroy (vlc_http_cookie_jar_t*)
109020,METHOD,misc\httpcookies.c:<global>,TYPE_DECL,"bool vlc_http_cookies_store(vlc_http_cookie_jar_t *p_jar, const char *cookies,
                            const char *host, const char *path)
{
    assert(host != NULL);
    assert(path != NULL);

    http_cookie_t *cookie = cookie_parse(cookies, host, path);
    if (cookie == NULL)
        return false;

    /* Check if a cookie from host should be added to the cookie jar */
    // FIXME: should check if domain is one of ""public suffixes"" at
    // http://publicsuffix.org/. The purpose of this check is to
    // prevent a host from setting a ""too wide"" cookie, for example
    // ""example.com"" should not be able to set a cookie for ""com"".
    // The current implementation prevents all top-level domains.
    if (strchr(cookie->psz_domain, '.') == NULL
     || !cookie_domain_matches(cookie, host))
    {
        cookie_destroy(cookie);
        return false;
    }

    vlc_mutex_lock( &p_jar->lock );

    for( size_t i = 0; i < vlc_array_count( &p_jar->cookies ); i++ )
    {
        ht...",1,1,misc\httpcookies.c,vlc_http_cookies_store,,false,298,351,vlc_http_cookies_store,,,18,"bool vlc_http_cookies_store (vlc_http_cookie_jar_t*,char*,char*,char*)"
109186,METHOD,misc\httpcookies.c:<global>,TYPE_DECL,"char *vlc_http_cookies_fetch(vlc_http_cookie_jar_t *p_jar, bool secure,
                             const char *host, const char *path)
{
    char *psz_cookiebuf = NULL;

    vlc_mutex_lock( &p_jar->lock );

    for( size_t i = 0; i < vlc_array_count( &p_jar->cookies ); i++ )
    {
        const http_cookie_t * cookie = vlc_array_item_at_index( &p_jar->cookies, i );
        if (cookie_should_be_sent(cookie, secure, host, path))
        {
            char *psz_updated_buf = NULL;
            if ( asprintf(&psz_updated_buf, ""%s%s%s=%s"",
                          psz_cookiebuf ? psz_cookiebuf : """",
                          psz_cookiebuf ? ""; "" : """",
                          cookie->psz_name ? cookie->psz_name : """",
                          cookie->psz_value ? cookie->psz_value : """") == -1 )
            {
                // TODO: report error
                free( psz_cookiebuf );
                vlc_mutex_unlock( &p_jar->lock );
                return NULL;
            }
          ...",1,1,misc\httpcookies.c,vlc_http_cookies_fetch,,false,353,385,vlc_http_cookies_fetch,,,19,"char* vlc_http_cookies_fetch (vlc_http_cookie_jar_t*,bool,char*,char*)"
109324,METHOD,misc\image.c:<global>,TYPE_DECL,<global>,1,1,misc\image.c,misc\image.c:<global>,,false,1,838,<global>,,,1,
109326,METHOD,misc\image.c:<global>,TYPE_DECL,"static picture_t *ImageRead( image_handler_t *, block_t *,
                             const video_format_t *, video_format_t * );",18,71,misc\image.c,ImageRead,,false,52,53,ImageRead,,,1,"picture_t* ImageRead (image_handler_t*,block_t*,video_format_t*,video_format_t*)"
109334,METHOD,misc\image.c:<global>,TYPE_DECL,"static picture_t *ImageReadUrl( image_handler_t *, const char *,
                                video_format_t *, video_format_t * );",18,68,misc\image.c,ImageReadUrl,,false,54,55,ImageReadUrl,,,2,"picture_t* ImageReadUrl (image_handler_t*,char*,video_format_t*,video_format_t*)"
109342,METHOD,misc\image.c:<global>,TYPE_DECL,"static block_t *ImageWrite( image_handler_t *, picture_t *,
                            const video_format_t *, const video_format_t * );",16,76,misc\image.c,ImageWrite,,false,56,57,ImageWrite,,,3,"block_t* ImageWrite (image_handler_t*,picture_t*,video_format_t*,video_format_t*)"
109350,METHOD,misc\image.c:<global>,TYPE_DECL,"static int ImageWriteUrl( image_handler_t *, picture_t *,
                          const video_format_t *, video_format_t *, const char * );",12,82,misc\image.c,ImageWriteUrl,,false,58,59,ImageWriteUrl,,,4,"int ImageWriteUrl (image_handler_t*,picture_t*,video_format_t*,video_format_t*,char*)"
109359,METHOD,misc\image.c:<global>,TYPE_DECL,"static picture_t *ImageConvert( image_handler_t *, picture_t *,
                                const video_format_t *, video_format_t * );",18,74,misc\image.c,ImageConvert,,false,61,62,ImageConvert,,,5,"picture_t* ImageConvert (image_handler_t*,picture_t*,video_format_t*,video_format_t*)"
109367,METHOD,misc\image.c:<global>,TYPE_DECL,"static decoder_t *CreateDecoder( vlc_object_t *, const video_format_t * );",18,73,misc\image.c,CreateDecoder,,false,64,64,CreateDecoder,,,6,"decoder_t* CreateDecoder (vlc_object_t*,video_format_t*)"
109373,METHOD,misc\image.c:<global>,TYPE_DECL,static void DeleteDecoder( decoder_t * );,13,40,misc\image.c,DeleteDecoder,,false,65,65,DeleteDecoder,,,7,void DeleteDecoder (decoder_t*)
109378,METHOD,misc\image.c:<global>,TYPE_DECL,"static encoder_t *CreateEncoder( vlc_object_t *, const video_format_t *,
                                 const video_format_t * );",18,57,misc\image.c,CreateEncoder,,false,66,67,CreateEncoder,,,8,"encoder_t* CreateEncoder (vlc_object_t*,video_format_t*,video_format_t*)"
109385,METHOD,misc\image.c:<global>,TYPE_DECL,static void DeleteEncoder( encoder_t * );,13,40,misc\image.c,DeleteEncoder,,false,68,68,DeleteEncoder,,,9,void DeleteEncoder (encoder_t*)
109390,METHOD,misc\image.c:<global>,TYPE_DECL,"static filter_t *CreateFilter( vlc_object_t *, const es_format_t *,
                               const video_format_t * );",17,55,misc\image.c,CreateFilter,,false,69,70,CreateFilter,,,10,"filter_t* CreateFilter (vlc_object_t*,es_format_t*,video_format_t*)"
109397,METHOD,misc\image.c:<global>,TYPE_DECL,static void DeleteFilter( filter_t * );,13,38,misc\image.c,DeleteFilter,,false,71,71,DeleteFilter,,,11,void DeleteFilter (filter_t*)
109402,METHOD,misc\image.c:<global>,TYPE_DECL,vlc_fourcc_t image_Type2Fourcc( const char * );,14,46,misc\image.c,image_Type2Fourcc,,false,73,73,image_Type2Fourcc,,,12,vlc_fourcc_t image_Type2Fourcc (char*)
109407,METHOD,misc\image.c:<global>,TYPE_DECL,vlc_fourcc_t image_Ext2Fourcc( const char * );,14,45,misc\image.c,image_Ext2Fourcc,,false,74,74,image_Ext2Fourcc,,,13,vlc_fourcc_t image_Ext2Fourcc (char*)
109412,METHOD,misc\image.c:<global>,TYPE_DECL,"image_handler_t *image_HandlerCreate( vlc_object_t *p_this )
{
    image_handler_t *p_image = calloc( 1, sizeof(image_handler_t) );
    if( !p_image )
        return NULL;

    p_image->p_parent = p_this;

    p_image->pf_read = ImageRead;
    p_image->pf_read_url = ImageReadUrl;
    p_image->pf_write = ImageWrite;
    p_image->pf_write_url = ImageWriteUrl;
    p_image->pf_convert = ImageConvert;

    p_image->outfifo = picture_fifo_New();

    return p_image;
}",1,1,misc\image.c,image_HandlerCreate,,false,82,99,image_HandlerCreate,,,14,image_handler_t image_HandlerCreate (vlc_object_t*)
109467,METHOD,misc\image.c:<global>,TYPE_DECL,"void image_HandlerDelete( image_handler_t *p_image )
{
    if( !p_image ) return;

    if( p_image->p_dec ) DeleteDecoder( p_image->p_dec );
    if( p_image->p_enc ) DeleteEncoder( p_image->p_enc );
    if( p_image->p_filter ) DeleteFilter( p_image->p_filter );

    picture_fifo_Delete( p_image->outfifo );

    free( p_image );
    p_image = NULL;
}",1,1,misc\image.c,image_HandlerDelete,,false,105,117,image_HandlerDelete,,,15,void image_HandlerDelete (image_handler_t*)
109513,METHOD,misc\image.c:<global>,TYPE_DECL,"static int ImageQueueVideo( decoder_t *p_dec, picture_t *p_pic )
{
    image_handler_t *p_image = p_dec->p_queue_ctx;
    picture_fifo_Push( p_image->outfifo, p_pic );
    return 0;
}",1,1,misc\image.c,ImageQueueVideo,,false,124,129,ImageQueueVideo,,,16,"int ImageQueueVideo (decoder_t*,picture_t*)"
109532,METHOD,misc\image.c:<global>,TYPE_DECL,"static picture_t *ImageRead( image_handler_t *p_image, block_t *p_block,
                             const video_format_t *p_fmt_in,
                             video_format_t *p_fmt_out )
{
    picture_t *p_pic = NULL;

    /* Check if we can reuse the current decoder */
    if( p_image->p_dec &&
        p_image->p_dec->fmt_in.i_codec != p_fmt_in->i_chroma )
    {
        DeleteDecoder( p_image->p_dec );
        p_image->p_dec = 0;
    }

    /* Start a decoder */
    if( !p_image->p_dec )
    {
        p_image->p_dec = CreateDecoder( p_image->p_parent, p_fmt_in );
        if( !p_image->p_dec )
        {
            block_Release(p_block);
            return NULL;
        }
        if( p_image->p_dec->fmt_out.i_cat != VIDEO_ES )
        {
            DeleteDecoder( p_image->p_dec );
            p_image->p_dec = NULL;
            block_Release(p_block);
            return NULL;
        }
        p_image->p_dec->pf_queue_video = ImageQueueVideo;
        p_image->p_dec->p_queue_ctx ...",1,1,misc\image.c,ImageRead,,false,131,271,ImageRead,,,17,"picture_t ImageRead (image_handler_t*,block_t*,video_format_t*,video_format_t*)"
110187,METHOD,misc\image.c:<global>,TYPE_DECL,"static picture_t *ImageReadUrl( image_handler_t *p_image, const char *psz_url,
                                video_format_t *p_fmt_in,
                                video_format_t *p_fmt_out )
{
    block_t *p_block;
    picture_t *p_pic;
    stream_t *p_stream = NULL;
    uint64_t i_size;

    p_stream = vlc_stream_NewURL( p_image->p_parent, psz_url );

    if( !p_stream )
    {
        msg_Dbg( p_image->p_parent, ""could not open %s for reading"",
                 psz_url );
        return NULL;
    }

    if( vlc_stream_GetSize( p_stream, &i_size ) || i_size > SSIZE_MAX )
    {
        msg_Dbg( p_image->p_parent, ""could not read %s"", psz_url );
        goto error;
    }

    p_block = vlc_stream_Block( p_stream, i_size );
    if( p_block == NULL )
        goto error;

    if( !p_fmt_in->i_chroma )
    {
        char *psz_mime = stream_MimeType( p_stream );
        if( psz_mime != NULL )
        {
            p_fmt_in->i_chroma = image_Mime2Fourcc( psz_mime );
            free( ...",1,1,misc\image.c,ImageReadUrl,,false,273,324,ImageReadUrl,,,18,"picture_t ImageReadUrl (image_handler_t*,char*,video_format_t*,video_format_t*)"
110301,METHOD,misc\image.c:<global>,TYPE_DECL,"static bool BitMapFormatIsSimilar( const video_format_t *f1,
                                   const video_format_t *f2 )
{
    if( f1->i_chroma == VLC_CODEC_RGB15 ||
        f1->i_chroma == VLC_CODEC_RGB16 ||
        f1->i_chroma == VLC_CODEC_RGB24 ||
        f1->i_chroma == VLC_CODEC_RGB32 )
    {
        video_format_t v1 = *f1;
        video_format_t v2 = *f2;

        video_format_FixRgb( &v1 );
        video_format_FixRgb( &v2 );

        if( v1.i_rmask != v2.i_rmask ||
            v1.i_gmask != v2.i_gmask ||
            v1.i_bmask != v2.i_bmask )
            return false;
    }
    return true;
}",1,1,misc\image.c,BitMapFormatIsSimilar,,false,327,347,BitMapFormatIsSimilar,,,19,"bool BitMapFormatIsSimilar (video_format_t*,video_format_t*)"
110377,METHOD,misc\image.c:<global>,TYPE_DECL,"static block_t *ImageWrite( image_handler_t *p_image, picture_t *p_pic,
                            const video_format_t *p_fmt_in,
                            const video_format_t *p_fmt_out )
{
    block_t *p_block;

    /* Check if we can reuse the current encoder */
    if( p_image->p_enc &&
        ( p_image->p_enc->fmt_out.i_codec != p_fmt_out->i_chroma ||
          p_image->p_enc->fmt_out.video.i_width != p_fmt_out->i_width ||
          p_image->p_enc->fmt_out.video.i_height != p_fmt_out->i_height ) )
    {
        DeleteEncoder( p_image->p_enc );
        p_image->p_enc = 0;
    }

    /* Start an encoder */
    if( !p_image->p_enc )
    {
        p_image->p_enc = CreateEncoder( p_image->p_parent,
                                        p_fmt_in, p_fmt_out );
        if( !p_image->p_enc ) return NULL;
    }

    /* Check if we need chroma conversion or resizing */
    if( p_image->p_enc->fmt_in.video.i_chroma != p_fmt_in->i_chroma ||
        p_image->p_enc->fmt_in.video.i_wid...",1,1,misc\image.c,ImageWrite,,false,354,448,ImageWrite,,,20,"block_t ImageWrite (image_handler_t*,picture_t*,video_format_t*,video_format_t*)"
110746,METHOD,misc\image.c:<global>,TYPE_DECL,"static int ImageWriteUrl( image_handler_t *p_image, picture_t *p_pic,
                          const video_format_t *p_fmt_in, video_format_t *p_fmt_out,
                          const char *psz_url )
{
    block_t *p_block;
    FILE *file;

    if( !p_fmt_out->i_chroma )
    {
        /* Try to guess format from file name */
        p_fmt_out->i_chroma = image_Ext2Fourcc( psz_url );
    }

    file = vlc_fopen( psz_url, ""wb"" );
    if( !file )
    {
        msg_Err( p_image->p_parent, ""%s: %s"", psz_url, vlc_strerror_c(errno) );
        return VLC_EGENERIC;
    }

    p_block = ImageWrite( p_image, p_pic, p_fmt_in, p_fmt_out );

    int err = 0;
    if( p_block )
    {
        if( fwrite( p_block->p_buffer, p_block->i_buffer, 1, file ) != 1 )
            err = errno;
        block_Release( p_block );
    }

    if( fclose( file ) && !err )
        err = errno;

    if( err )
    {
       errno = err;
       msg_Err( p_image->p_parent, ""%s: %s"", psz_url, vlc_strerror_c(errno) );
  ...",1,1,misc\image.c,ImageWriteUrl,,false,450,490,ImageWriteUrl,,,21,"int ImageWriteUrl (image_handler_t*,picture_t*,video_format_t*,video_format_t*,char*)"
110849,METHOD,misc\image.c:<global>,TYPE_DECL,"static picture_t *ImageConvert( image_handler_t *p_image, picture_t *p_pic,
                                const video_format_t *p_fmt_in,
                                video_format_t *p_fmt_out )
{
    picture_t *p_pif;

    if( !p_fmt_out->i_width && !p_fmt_out->i_height &&
        p_fmt_out->i_sar_num && p_fmt_out->i_sar_den &&
        p_fmt_out->i_sar_num * p_fmt_in->i_sar_den !=
        p_fmt_out->i_sar_den * p_fmt_in->i_sar_num )
    {
        p_fmt_out->i_width =
            p_fmt_in->i_sar_num * (int64_t)p_fmt_out->i_sar_den *
            p_fmt_in->i_width / p_fmt_in->i_sar_den / p_fmt_out->i_sar_num;
        p_fmt_out->i_visible_width =
            p_fmt_in->i_sar_num * (int64_t)p_fmt_out->i_sar_den *
            p_fmt_in->i_visible_width / p_fmt_in->i_sar_den /
            p_fmt_out->i_sar_num;
    }

    if( !p_fmt_out->i_chroma ) p_fmt_out->i_chroma = p_fmt_in->i_chroma;
    if( !p_fmt_out->i_width )
        p_fmt_out->i_width = p_fmt_out->i_visible_width = p_fmt_in->...",1,1,misc\image.c,ImageConvert,,false,497,572,ImageConvert,,,22,"picture_t ImageConvert (image_handler_t*,picture_t*,video_format_t*,video_format_t*)"
111178,METHOD,<empty>,<empty>,<empty>,1,,misc\image.c,ext_table:<clinit>,,false,578,,<clinit>,,,3,
111271,METHOD,misc\image.c:<global>,TYPE_DECL,"vlc_fourcc_t image_Type2Fourcc( const char *psz_type )
{
    for( unsigned i = 0; i < ARRAY_SIZE(ext_table); i++ )
        if( !strcasecmp( ext_table[i].psz_ext, psz_type ) )
            return ext_table[i].i_codec;

    return 0;
}",1,1,misc\image.c,image_Type2Fourcc,,false,608,615,image_Type2Fourcc,,,26,vlc_fourcc_t image_Type2Fourcc (char*)
111306,METHOD,misc\image.c:<global>,TYPE_DECL,"vlc_fourcc_t image_Ext2Fourcc( const char *psz_name )
{
    psz_name = strrchr( psz_name, '.' );
    if( !psz_name ) return 0;
    psz_name++;

    return image_Type2Fourcc( psz_name );
}",1,1,misc\image.c,image_Ext2Fourcc,,false,617,624,image_Ext2Fourcc,,,27,vlc_fourcc_t image_Ext2Fourcc (char*)
111392,METHOD,misc\image.c:<global>,TYPE_DECL,"vlc_fourcc_t image_Mime2Fourcc( const char *psz_mime )
{
    for( int i = 0; mime_table[i].i_codec; i++ )
        if( !strcmp( psz_mime, mime_table[i].psz_mime ) )
            return mime_table[i].i_codec;
    return 0;
}",1,1,misc\image.c,image_Mime2Fourcc,,false,652,658,image_Mime2Fourcc,,,31,vlc_fourcc_t image_Mime2Fourcc (char*)
111428,METHOD,misc\image.c:<global>,TYPE_DECL,"static int video_update_format( decoder_t *p_dec )
{
    p_dec->fmt_out.video.i_chroma = p_dec->fmt_out.i_codec;
    return 0;
}",1,1,misc\image.c,video_update_format,,false,660,664,video_update_format,,,32,int video_update_format (decoder_t*)
111448,METHOD,misc\image.c:<global>,TYPE_DECL,"static picture_t *video_new_buffer( decoder_t *p_dec )
{
    return picture_NewFromFormat( &p_dec->fmt_out.video );
}",1,1,misc\image.c,video_new_buffer,,false,666,669,video_new_buffer,,,33,picture_t video_new_buffer (decoder_t*)
111461,METHOD,misc\image.c:<global>,TYPE_DECL,"static decoder_t *CreateDecoder( vlc_object_t *p_this, const video_format_t *fmt )
{
    decoder_t *p_dec;

    p_dec = vlc_custom_create( p_this, sizeof( *p_dec ), ""image decoder"" );
    if( p_dec == NULL )
        return NULL;

    p_dec->p_module = NULL;
    es_format_InitFromVideo( &p_dec->fmt_in, fmt );
    es_format_Init( &p_dec->fmt_out, VIDEO_ES, 0 );
    p_dec->b_frame_drop_allowed = false;

    p_dec->pf_vout_format_update = video_update_format;
    p_dec->pf_vout_buffer_new = video_new_buffer;

    /* Find a suitable decoder module */
    p_dec->p_module = module_need( p_dec, ""video decoder"", ""$codec"", false );
    if( !p_dec->p_module )
    {
        msg_Err( p_dec, ""no suitable decoder module for fourcc `%4.4s'. ""
                 ""VLC probably does not support this image format."",
                 (char*)&p_dec->fmt_in.i_codec );

        DeleteDecoder( p_dec );
        return NULL;
    }

    return p_dec;
}",1,1,misc\image.c,CreateDecoder,,false,671,700,CreateDecoder,,,34,"decoder_t CreateDecoder (vlc_object_t*,video_format_t*)"
111548,METHOD,misc\image.c:<global>,TYPE_DECL,"static void DeleteDecoder( decoder_t * p_dec )
{
    if( p_dec->p_module ) module_unneed( p_dec, p_dec->p_module );

    es_format_Clean( &p_dec->fmt_in );
    es_format_Clean( &p_dec->fmt_out );

    if( p_dec->p_description )
        vlc_meta_Delete( p_dec->p_description );

    vlc_object_release( p_dec );
    p_dec = NULL;
}",1,1,misc\image.c,DeleteDecoder,,false,702,714,DeleteDecoder,,,35,void DeleteDecoder (decoder_t*)
111587,METHOD,misc\image.c:<global>,TYPE_DECL,"static encoder_t *CreateEncoder( vlc_object_t *p_this, const video_format_t *fmt_in,
                                 const video_format_t *fmt_out )
{
    encoder_t *p_enc;

    p_enc = sout_EncoderCreate( p_this );
    if( p_enc == NULL )
        return NULL;

    p_enc->p_module = NULL;
    es_format_InitFromVideo( &p_enc->fmt_in, fmt_in );

    if( p_enc->fmt_in.video.i_visible_width == 0 ||
        p_enc->fmt_in.video.i_visible_height == 0 ||
        p_enc->fmt_out.video.i_visible_width == 0 ||
        p_enc->fmt_out.video.i_visible_height == 0 )
    {
        if( fmt_out->i_width > 0 && fmt_out->i_height > 0 )
        {
            p_enc->fmt_in.video.i_width = fmt_out->i_width;
            p_enc->fmt_in.video.i_height = fmt_out->i_height;

            if( fmt_out->i_visible_width > 0 &&
                fmt_out->i_visible_height > 0 )
            {
                p_enc->fmt_in.video.i_visible_width = fmt_out->i_visible_width;
                p_enc->fmt_in.video.i_visible_heig...",1,1,misc\image.c,CreateEncoder,,false,716,783,CreateEncoder,,,36,"encoder_t CreateEncoder (vlc_object_t*,video_format_t*,video_format_t*)"
111936,METHOD,misc\image.c:<global>,TYPE_DECL,"static void DeleteEncoder( encoder_t * p_enc )
{
    if( p_enc->p_module ) module_unneed( p_enc, p_enc->p_module );

    es_format_Clean( &p_enc->fmt_in );
    es_format_Clean( &p_enc->fmt_out );

    vlc_object_release( p_enc );
    p_enc = NULL;
}",1,1,misc\image.c,DeleteEncoder,,false,785,794,DeleteEncoder,,,37,void DeleteEncoder (encoder_t*)
111966,METHOD,misc\image.c:<global>,TYPE_DECL,"static picture_t *filter_new_picture( filter_t *p_filter )
{
    return picture_NewFromFormat( &p_filter->fmt_out.video );
}",1,1,misc\image.c,filter_new_picture,,false,796,799,filter_new_picture,,,38,picture_t filter_new_picture (filter_t*)
111979,METHOD,misc\image.c:<global>,TYPE_DECL,"static filter_t *CreateFilter( vlc_object_t *p_this, const es_format_t *p_fmt_in,
                               const video_format_t *p_fmt_out )
{
    filter_t *p_filter;

    p_filter = vlc_custom_create( p_this, sizeof(filter_t), ""filter"" );
    p_filter->owner.video.buffer_new = filter_new_picture;

    es_format_Copy( &p_filter->fmt_in, p_fmt_in );
    es_format_Copy( &p_filter->fmt_out, p_fmt_in );
    video_format_Copy( &p_filter->fmt_out.video, p_fmt_out );

    /* whatever the input offset, write at offset 0 in the target image */
    p_filter->fmt_out.video.i_x_offset = 0;
    p_filter->fmt_out.video.i_y_offset = 0;

    p_filter->fmt_out.i_codec = p_fmt_out->i_chroma;
    p_filter->p_module = module_need( p_filter, ""video converter"", NULL, false );

    if( !p_filter->p_module )
    {
        msg_Dbg( p_filter, ""no video converter found"" );
        DeleteFilter( p_filter );
        return NULL;
    }

    return p_filter;
}",1,1,misc\image.c,CreateFilter,,false,801,828,CreateFilter,,,39,"filter_t CreateFilter (vlc_object_t*,es_format_t*,video_format_t*)"
112074,METHOD,misc\image.c:<global>,TYPE_DECL,"static void DeleteFilter( filter_t * p_filter )
{
    if( p_filter->p_module ) module_unneed( p_filter, p_filter->p_module );

    es_format_Clean( &p_filter->fmt_in );
    es_format_Clean( &p_filter->fmt_out );

    vlc_object_release( p_filter );
}",1,1,misc\image.c,DeleteFilter,,false,830,838,DeleteFilter,,,40,void DeleteFilter (filter_t*)
112136,METHOD,misc\interrupt.c:<global>,TYPE_DECL,<global>,1,1,misc\interrupt.c,misc\interrupt.c:<global>,,false,1,687,<global>,,,1,
112139,METHOD,misc\interrupt.c:<global>,TYPE_DECL,"void vlc_interrupt_init(vlc_interrupt_t *ctx)
{
    vlc_mutex_init(&ctx->lock);
    ctx->interrupted = false;
    atomic_init(&ctx->killed, false);
    ctx->callback = NULL;
}",1,1,misc\interrupt.c,vlc_interrupt_init,,false,51,57,vlc_interrupt_init,,,2,void vlc_interrupt_init (vlc_interrupt_t*)
112165,METHOD,misc\interrupt.c:<global>,TYPE_DECL,"vlc_interrupt_t *vlc_interrupt_create(void)
{
    vlc_interrupt_t *ctx = malloc(sizeof (*ctx));
    if (likely(ctx != NULL))
        vlc_interrupt_init(ctx);
    return ctx;
}",1,1,misc\interrupt.c,vlc_interrupt_create,,false,59,65,vlc_interrupt_create,,,3,vlc_interrupt_t vlc_interrupt_create (void)
112187,METHOD,misc\interrupt.c:<global>,TYPE_DECL,"void vlc_interrupt_deinit(vlc_interrupt_t *ctx)
{
    assert(ctx->callback == NULL);
    vlc_mutex_destroy(&ctx->lock);
}",1,1,misc\interrupt.c,vlc_interrupt_deinit,,false,71,75,vlc_interrupt_deinit,,,4,void vlc_interrupt_deinit (vlc_interrupt_t*)
112203,METHOD,misc\interrupt.c:<global>,TYPE_DECL,"void vlc_interrupt_destroy(vlc_interrupt_t *ctx)
{
    assert(ctx != NULL);
    vlc_interrupt_deinit(ctx);
    free(ctx);
}",1,1,misc\interrupt.c,vlc_interrupt_destroy,,false,77,82,vlc_interrupt_destroy,,,5,void vlc_interrupt_destroy (vlc_interrupt_t*)
112216,METHOD,misc\interrupt.c:<global>,TYPE_DECL,"void vlc_interrupt_raise(vlc_interrupt_t *ctx)
{
    assert(ctx != NULL);

    /* This function must be reentrant. But the callback typically is not
     * reentrant. The lock ensures that all calls to the callback for a given
     * context are serialized. The lock also protects against invalid memory
     * accesses to the callback pointer proper, and the interrupted flag. */
    vlc_mutex_lock(&ctx->lock);
    ctx->interrupted = true;
    if (ctx->callback != NULL)
        ctx->callback(ctx->data);
    vlc_mutex_unlock(&ctx->lock);
}",1,1,misc\interrupt.c,vlc_interrupt_raise,,false,84,97,vlc_interrupt_raise,,,6,void vlc_interrupt_raise (vlc_interrupt_t*)
112254,METHOD,misc\interrupt.c:<global>,TYPE_DECL,"vlc_interrupt_t *vlc_interrupt_set(vlc_interrupt_t *newctx)
{
    vlc_interrupt_t *oldctx = vlc_interrupt_var;

    vlc_interrupt_var = newctx;
    return oldctx;
}",1,1,misc\interrupt.c,vlc_interrupt_set,,false,99,105,vlc_interrupt_set,,,7,vlc_interrupt_t vlc_interrupt_set (vlc_interrupt_t*)
112268,METHOD,misc\interrupt.c:<global>,TYPE_DECL,"static void vlc_interrupt_prepare(vlc_interrupt_t *ctx,
                                  void (*cb)(void *), void *data)
{
    assert(ctx != NULL);
    assert(ctx == vlc_interrupt_var);

    vlc_mutex_lock(&ctx->lock);
    assert(ctx->callback == NULL);
    ctx->callback = cb;
    ctx->data = data;

    if (unlikely(ctx->interrupted))
        cb(data);
    vlc_mutex_unlock(&ctx->lock);
}",1,1,misc\interrupt.c,vlc_interrupt_prepare,,false,114,128,vlc_interrupt_prepare,,,8,"void vlc_interrupt_prepare (vlc_interrupt_t*,void,void*)"
112317,METHOD,misc\interrupt.c:<global>,TYPE_DECL,"static int vlc_interrupt_finish(vlc_interrupt_t *ctx)
{
    int ret = 0;

    assert(ctx != NULL);
    assert(ctx == vlc_interrupt_var);

    /* Wait for pending callbacks to prevent access by other threads. */
    vlc_mutex_lock(&ctx->lock);
    ctx->callback = NULL;
    if (ctx->interrupted)
    {
        ret = EINTR;
        ctx->interrupted = false;
    }
    vlc_mutex_unlock(&ctx->lock);
    return ret;
}",1,1,misc\interrupt.c,vlc_interrupt_finish,,false,141,158,vlc_interrupt_finish,,,9,int vlc_interrupt_finish (vlc_interrupt_t*)
112364,METHOD,misc\interrupt.c:<global>,TYPE_DECL,"void vlc_interrupt_register(void (*cb)(void *), void *opaque)
{
    vlc_interrupt_t *ctx = vlc_interrupt_var;
    if (ctx != NULL)
        vlc_interrupt_prepare(ctx, cb, opaque);
}",1,1,misc\interrupt.c,vlc_interrupt_register,,false,160,165,vlc_interrupt_register,,,10,"void vlc_interrupt_register (void,void*)"
112383,METHOD,misc\interrupt.c:<global>,TYPE_DECL,"int vlc_interrupt_unregister(void)
{
    vlc_interrupt_t *ctx = vlc_interrupt_var;
    return (ctx != NULL) ? vlc_interrupt_finish(ctx) : 0;
}",1,1,misc\interrupt.c,vlc_interrupt_unregister,,false,167,171,vlc_interrupt_unregister,,,11,int vlc_interrupt_unregister (void)
112400,METHOD,misc\interrupt.c:<global>,TYPE_DECL,"static void vlc_interrupt_cleanup(void *opaque)
{
    vlc_interrupt_finish(opaque);
}",1,1,misc\interrupt.c,vlc_interrupt_cleanup,,false,173,176,vlc_interrupt_cleanup,,,12,void vlc_interrupt_cleanup (void*)
112407,METHOD,misc\interrupt.c:<global>,TYPE_DECL,"void vlc_interrupt_kill(vlc_interrupt_t *ctx)
{
    assert(ctx != NULL);

    atomic_store(&ctx->killed, true);
    vlc_interrupt_raise(ctx);
}",1,1,misc\interrupt.c,vlc_interrupt_kill,,false,178,184,vlc_interrupt_kill,,,13,void vlc_interrupt_kill (vlc_interrupt_t*)
112424,METHOD,misc\interrupt.c:<global>,TYPE_DECL,"bool vlc_killed(void)
{
    vlc_interrupt_t *ctx = vlc_interrupt_var;

    return (ctx != NULL) && atomic_load(&ctx->killed);
}",1,1,misc\interrupt.c,vlc_killed,,false,186,191,vlc_killed,,,14,bool vlc_killed (void)
112443,METHOD,misc\interrupt.c:<global>,TYPE_DECL,"static void vlc_interrupt_sem(void *opaque)
{
    vlc_sem_post(opaque);
}",1,1,misc\interrupt.c,vlc_interrupt_sem,,false,193,196,vlc_interrupt_sem,,,15,void vlc_interrupt_sem (void*)
112450,METHOD,misc\interrupt.c:<global>,TYPE_DECL,"int vlc_sem_wait_i11e(vlc_sem_t *sem)
{
    vlc_interrupt_t *ctx = vlc_interrupt_var;
    if (ctx == NULL)
        return vlc_sem_wait(sem), 0;

    vlc_interrupt_prepare(ctx, vlc_interrupt_sem, sem);

    vlc_cleanup_push(vlc_interrupt_cleanup, ctx);
    vlc_sem_wait(sem);
    vlc_cleanup_pop();

    return vlc_interrupt_finish(ctx);
}",1,1,misc\interrupt.c,vlc_sem_wait_i11e,,false,198,211,vlc_sem_wait_i11e,,,16,int vlc_sem_wait_i11e (vlc_sem_t*)
112482,METHOD,misc\interrupt.c:<global>,TYPE_DECL,"static void vlc_mwait_i11e_wake(void *opaque)
{
    vlc_cond_signal(opaque);
}",1,1,misc\interrupt.c,vlc_mwait_i11e_wake,,false,213,216,vlc_mwait_i11e_wake,,,17,void vlc_mwait_i11e_wake (void*)
112489,METHOD,misc\interrupt.c:<global>,TYPE_DECL,"static void vlc_mwait_i11e_cleanup(void *opaque)
{
    vlc_interrupt_t *ctx = opaque;
    vlc_cond_t *cond = ctx->data;

    vlc_mutex_unlock(&ctx->lock);
    vlc_interrupt_finish(ctx);
    vlc_cond_destroy(cond);
}",1,1,misc\interrupt.c,vlc_mwait_i11e_cleanup,,false,218,226,vlc_mwait_i11e_cleanup,,,18,void vlc_mwait_i11e_cleanup (void*)
112513,METHOD,misc\interrupt.c:<global>,TYPE_DECL,"int vlc_mwait_i11e(mtime_t deadline)
{
    vlc_interrupt_t *ctx = vlc_interrupt_var;
    if (ctx == NULL)
        return mwait(deadline), 0;

    vlc_cond_t wait;
    vlc_cond_init(&wait);

    vlc_interrupt_prepare(ctx, vlc_mwait_i11e_wake, &wait);

    vlc_mutex_lock(&ctx->lock);
    vlc_cleanup_push(vlc_mwait_i11e_cleanup, ctx);
    while (!ctx->interrupted
        && vlc_cond_timedwait(&wait, &ctx->lock, deadline) == 0);
    vlc_cleanup_pop();
    vlc_mutex_unlock(&ctx->lock);

    int ret = vlc_interrupt_finish(ctx);
    vlc_cond_destroy(&wait);
    return ret;
}",1,1,misc\interrupt.c,vlc_mwait_i11e,,false,228,249,vlc_mwait_i11e,,,19,int vlc_mwait_i11e (mtime_t)
112581,METHOD,misc\interrupt.c:<global>,TYPE_DECL,"static void vlc_interrupt_forward_wake(void *opaque)
{
    void **data = opaque;
    vlc_interrupt_t *to = data[0];
    vlc_interrupt_t *from = data[1];

    (atomic_load(&from->killed) ? vlc_interrupt_kill
                                : vlc_interrupt_raise)(to);
}",1,1,misc\interrupt.c,vlc_interrupt_forward_wake,,false,251,259,vlc_interrupt_forward_wake,,,20,void vlc_interrupt_forward_wake (void*)
112612,METHOD,misc\interrupt.c:<global>,TYPE_DECL,"void vlc_interrupt_forward_start(vlc_interrupt_t *to, void *data[2])
{
    data[0] = data[1] = NULL;

    vlc_interrupt_t *from = vlc_interrupt_var;
    if (from == NULL)
        return;

    assert(from != to);
    data[0] = to;
    data[1] = from;
    vlc_interrupt_prepare(from, vlc_interrupt_forward_wake, data);
}",1,1,misc\interrupt.c,vlc_interrupt_forward_start,,false,261,273,vlc_interrupt_forward_start,,,21,"void vlc_interrupt_forward_start (vlc_interrupt_t*,void[2]*)"
112655,METHOD,misc\interrupt.c:<global>,TYPE_DECL,"int vlc_interrupt_forward_stop(void *const data[2])
{
    vlc_interrupt_t *from = data[1];
    if (from == NULL)
        return 0;

    assert(from->callback == vlc_interrupt_forward_wake);
    assert(from->data == data);
    return vlc_interrupt_finish(from);
}",1,1,misc\interrupt.c,vlc_interrupt_forward_stop,,false,275,284,vlc_interrupt_forward_stop,,,22,int vlc_interrupt_forward_stop (void[2]*)
112688,METHOD,misc\interrupt.c:<global>,TYPE_DECL,"static void vlc_poll_i11e_wake(void *opaque)
{
    uint64_t value = 1;
    int *fd = opaque;
    int canc;

    canc = vlc_savecancel();
    write(fd[1], &value, sizeof (value));
    vlc_restorecancel(canc);
}",1,1,misc\interrupt.c,vlc_poll_i11e_wake,,false,287,296,vlc_poll_i11e_wake,,,23,void vlc_poll_i11e_wake (void*)
112715,METHOD,misc\interrupt.c:<global>,TYPE_DECL,"static void vlc_poll_i11e_cleanup(void *opaque)
{
    vlc_interrupt_t *ctx = opaque;
    int *fd = ctx->data;

    vlc_interrupt_finish(ctx);
    if (fd[1] != fd[0])
        vlc_close(fd[1]);
    vlc_close(fd[0]);
}",1,1,misc\interrupt.c,vlc_poll_i11e_cleanup,,false,298,307,vlc_poll_i11e_cleanup,,,24,void vlc_poll_i11e_cleanup (void*)
112749,METHOD,misc\interrupt.c:<global>,TYPE_DECL,"static int vlc_poll_i11e_inner(struct pollfd *restrict fds, unsigned nfds,
                               int timeout, vlc_interrupt_t *ctx,
                               struct pollfd *restrict ufd)
{
    int fd[2];
    int ret = -1;
    int canc;

    /* TODO: cache this */
# if defined (HAVE_EVENTFD) && defined (EFD_CLOEXEC)
    canc = vlc_savecancel();
    fd[0] = eventfd(0, EFD_CLOEXEC);
    vlc_restorecancel(canc);
    if (fd[0] != -1)
        fd[1] = fd[0];
    else
# endif
    if (vlc_pipe(fd))
    {
        vlc_testcancel();
        errno = ENOMEM;
        return -1;
    }

    for (unsigned i = 0; i < nfds; i++)
    {
        ufd[i].fd = fds[i].fd;
        ufd[i].events = fds[i].events;
    }
    ufd[nfds].fd = fd[0];
    ufd[nfds].events = POLLIN;

    vlc_interrupt_prepare(ctx, vlc_poll_i11e_wake, fd);

    vlc_cleanup_push(vlc_poll_i11e_cleanup, ctx);
    ret = poll(ufd, nfds + 1, timeout);

    for (unsigned i = 0; i < nfds; i++)
        fds[i].revents = ufd[i].revent...",1,1,misc\interrupt.c,vlc_poll_i11e_inner,,false,309,370,vlc_poll_i11e_inner,,,25,"int vlc_poll_i11e_inner (pollfd*,unsigned,int,vlc_interrupt_t*,pollfd*)"
112921,METHOD,misc\interrupt.c:<global>,TYPE_DECL,"int vlc_poll_i11e(struct pollfd *fds, unsigned nfds, int timeout)
{
    vlc_interrupt_t *ctx = vlc_interrupt_var;
    if (ctx == NULL)
        return poll(fds, nfds, timeout);

    int ret;

    if (likely(nfds < 255))
    {   /* Fast path with stack allocation */
        struct pollfd ufd[nfds + 1];

        ret = vlc_poll_i11e_inner(fds, nfds, timeout, ctx, ufd);
    }
    else
    {   /* Slow path but poll() is slow with large nfds anyway. */
        struct pollfd *ufd = vlc_alloc(nfds + 1, sizeof (*ufd));
        if (unlikely(ufd == NULL))
            return -1; /* ENOMEM */

        vlc_cleanup_push(free, ufd);
        ret = vlc_poll_i11e_inner(fds, nfds, timeout, ctx, ufd);
        vlc_cleanup_pop();
        free(ufd);
    }
    return ret;
}",1,1,misc\interrupt.c,vlc_poll_i11e,,false,372,398,vlc_poll_i11e,,,26,"int vlc_poll_i11e (pollfd*,unsigned,int)"
112995,METHOD,misc\interrupt.c:<global>,TYPE_DECL,"ssize_t vlc_readv_i11e(int fd, struct iovec *iov, int count)
{
    struct pollfd ufd;

    ufd.fd = fd;
    ufd.events = POLLIN;

    if (vlc_poll_i11e(&ufd, 1, -1) < 0)
        return -1;
    return readv(fd, iov, count);
}",1,1,misc\interrupt.c,vlc_readv_i11e,,false,417,427,vlc_readv_i11e,,,27,"ssize_t vlc_readv_i11e (int,iovec*,int)"
113031,METHOD,misc\interrupt.c:<global>,TYPE_DECL,"ssize_t vlc_writev_i11e(int fd, const struct iovec *iov, int count)
{
    struct pollfd ufd;

    ufd.fd = fd;
    ufd.events = POLLOUT;

    if (vlc_poll_i11e(&ufd, 1, -1) < 0)
        return -1;
    return writev(fd, iov, count);
}",1,1,misc\interrupt.c,vlc_writev_i11e,,false,436,446,vlc_writev_i11e,,,28,"ssize_t vlc_writev_i11e (int,iovec*,int)"
113067,METHOD,misc\interrupt.c:<global>,TYPE_DECL,"ssize_t vlc_read_i11e(int fd, void *buf, size_t count)
{
    struct iovec iov = { .iov_base = buf, .iov_len = count };
    return vlc_readv_i11e(fd, &iov, 1);
}",1,1,misc\interrupt.c,vlc_read_i11e,,false,452,456,vlc_read_i11e,,,29,"ssize_t vlc_read_i11e (int,void*,size_t)"
113092,METHOD,misc\interrupt.c:<global>,TYPE_DECL,"ssize_t vlc_write_i11e(int fd, const void *buf, size_t count)
{
    struct iovec iov = { .iov_base = (void*)buf, .iov_len = count };
    return vlc_writev_i11e(fd, &iov, 1);
}",1,1,misc\interrupt.c,vlc_write_i11e,,false,465,469,vlc_write_i11e,,,30,"ssize_t vlc_write_i11e (int,void*,size_t)"
113119,METHOD,misc\interrupt.c:<global>,TYPE_DECL,"ssize_t vlc_recvmsg_i11e(int fd, struct msghdr *msg, int flags)
{
    struct pollfd ufd;

    ufd.fd = fd;
    ufd.events = POLLIN;

    if (vlc_poll_i11e(&ufd, 1, -1) < 0)
        return -1;
    /* NOTE: MSG_OOB and MSG_PEEK should work fine here.
     * MSG_WAITALL is not supported at this point. */
    return recvmsg(fd, msg, flags);
}",1,1,misc\interrupt.c,vlc_recvmsg_i11e,,false,471,483,vlc_recvmsg_i11e,,,31,"ssize_t vlc_recvmsg_i11e (int,msghdr*,int)"
113155,METHOD,misc\interrupt.c:<global>,TYPE_DECL,"ssize_t vlc_recvfrom_i11e(int fd, void *buf, size_t len, int flags,
                        struct sockaddr *addr, socklen_t *addrlen)
{
    struct iovec iov = { .iov_base = buf, .iov_len = len };
    struct msghdr msg = {
        .msg_name = addr,
        .msg_namelen = (addrlen != NULL) ? *addrlen : 0,
        .msg_iov = &iov,
        .msg_iovlen = 1,
    };

    ssize_t ret = vlc_recvmsg_i11e(fd, &msg, flags);
    if (ret >= 0 && addrlen != NULL)
        *addrlen = msg.msg_namelen;
    return ret;
}",1,1,misc\interrupt.c,vlc_recvfrom_i11e,,false,485,500,vlc_recvfrom_i11e,,,32,"ssize_t vlc_recvfrom_i11e (int,void*,size_t,int,sockaddr*,socklen_t*)"
113229,METHOD,misc\interrupt.c:<global>,TYPE_DECL,"ssize_t vlc_sendmsg_i11e(int fd, const struct msghdr *msg, int flags)
{
    struct pollfd ufd;

    ufd.fd = fd;
    ufd.events = POLLOUT;

    if (vlc_poll_i11e(&ufd, 1, -1) < 0)
        return -1;
    /* NOTE: MSG_EOR, MSG_OOB and MSG_NOSIGNAL should all work fine here. */
    return sendmsg(fd, msg, flags);
}",1,1,misc\interrupt.c,vlc_sendmsg_i11e,,false,502,513,vlc_sendmsg_i11e,,,33,"ssize_t vlc_sendmsg_i11e (int,msghdr*,int)"
113265,METHOD,misc\interrupt.c:<global>,TYPE_DECL,"ssize_t vlc_sendto_i11e(int fd, const void *buf, size_t len, int flags,
                      const struct sockaddr *addr, socklen_t addrlen)
{
    struct iovec iov = { .iov_base = (void *)buf, .iov_len = len };
    struct msghdr msg = {
        .msg_name = (struct sockaddr *)addr,
        .msg_namelen = addrlen,
        .msg_iov = &iov,
        .msg_iovlen = 1,
    };

    return vlc_sendmsg_i11e(fd, &msg, flags);
}",1,1,misc\interrupt.c,vlc_sendto_i11e,,false,515,527,vlc_sendto_i11e,,,34,"ssize_t vlc_sendto_i11e (int,void*,size_t,int,sockaddr*,socklen_t)"
113318,METHOD,misc\interrupt.c:<global>,TYPE_DECL,"int vlc_accept_i11e(int fd, struct sockaddr *addr, socklen_t *addrlen,
                  bool blocking)
{
    struct pollfd ufd;

    ufd.fd = fd;
    ufd.events = POLLIN;

    if (vlc_poll_i11e(&ufd, 1, -1) < 0)
        return -1;

    return vlc_accept(fd, addr, addrlen, blocking);
}",1,1,misc\interrupt.c,vlc_accept_i11e,,false,529,541,vlc_accept_i11e,,,35,"int vlc_accept_i11e (int,sockaddr*,socklen_t*,bool)"
113363,METHOD,misc\interrupt.h:<global>,TYPE_DECL,<global>,1,6,misc\interrupt.h,misc\interrupt.h:<global>,,false,1,39,<global>,,,1,
113365,METHOD,misc\interrupt.h:<global>,TYPE_DECL,void vlc_interrupt_init(vlc_interrupt_t *);,6,42,misc\interrupt.h,vlc_interrupt_init,,false,28,28,vlc_interrupt_init,,,1,void vlc_interrupt_init (vlc_interrupt_t*)
113370,METHOD,misc\interrupt.h:<global>,TYPE_DECL,void vlc_interrupt_deinit(vlc_interrupt_t *);,6,44,misc\interrupt.h,vlc_interrupt_deinit,,false,29,29,vlc_interrupt_deinit,,,2,void vlc_interrupt_deinit (vlc_interrupt_t*)
113379,METHOD,vlc_interrupt,TYPE_DECL,void (*callback)(void *);,10,28,misc\interrupt.h,vlc_interrupt.callback,,false,36,36,callback,,,4,void vlc_interrupt.callback (void*)
113406,METHOD,misc\keystore.c:<global>,TYPE_DECL,<global>,1,1,misc\keystore.c,misc\keystore.c:<global>,,false,1,577,<global>,,,1,
113408,METHOD,misc\keystore.c:<global>,TYPE_DECL,"static vlc_keystore *
keystore_create(vlc_object_t *p_parent, const char *psz_name)
{
    vlc_keystore *p_keystore = vlc_custom_create(p_parent, sizeof (*p_keystore),
                                                 ""keystore"");
    if (unlikely(p_keystore == NULL))
        return NULL;

    p_keystore->p_module = module_need(p_keystore, ""keystore"", psz_name, true);
    if (p_keystore->p_module == NULL)
    {
        vlc_object_release(p_keystore);
        return NULL;
    }
    assert(p_keystore->pf_store);
    assert(p_keystore->pf_find);
    assert(p_keystore->pf_remove);

    return p_keystore;
}",1,1,misc\keystore.c,keystore_create,,false,35,54,keystore_create,,,1,"vlc_keystore keystore_create (vlc_object_t*,char*)"
113465,METHOD,misc\keystore.c:<global>,TYPE_DECL,"vlc_keystore *
vlc_keystore_create(vlc_object_t *p_parent)
{
    assert(p_parent);
    return keystore_create(p_parent, ""$keystore"");
}",1,1,misc\keystore.c,vlc_keystore_create,,false,57,62,vlc_keystore_create,,,2,vlc_keystore vlc_keystore_create (vlc_object_t*)
113476,METHOD,misc\keystore.c:<global>,TYPE_DECL,"void
vlc_keystore_release(vlc_keystore *p_keystore)
{
    assert(p_keystore);
    module_unneed(p_keystore, p_keystore->p_module);

    vlc_object_release(p_keystore);
}",1,1,misc\keystore.c,vlc_keystore_release,,false,64,71,vlc_keystore_release,,,3,void vlc_keystore_release (vlc_keystore*)
113490,METHOD,misc\keystore.c:<global>,TYPE_DECL,"int
vlc_keystore_store(vlc_keystore *p_keystore,
                   const char * const ppsz_values[KEY_MAX],
                   const uint8_t *p_secret, ssize_t i_secret_len,
                   const char *psz_label)
{
    assert(p_keystore && ppsz_values && p_secret && i_secret_len);

    if (!ppsz_values[KEY_PROTOCOL] || !ppsz_values[KEY_SERVER])
    {
        msg_Err(p_keystore, ""invalid store request: ""
                ""protocol and server should be valid"");
        return VLC_EGENERIC;
    }
    if (ppsz_values[KEY_PORT])
    {
        long int i_port = strtol(ppsz_values[KEY_PORT], NULL, 10);
        if (i_port == LONG_MIN || i_port == LONG_MAX)
        {
            msg_Err(p_keystore, ""invalid store request: ""
                    ""port is not valid number"");
            return VLC_EGENERIC;
        }
    }
    if (i_secret_len < 0)
        i_secret_len = strlen((const char *)p_secret) + 1;
    return p_keystore->pf_store(p_keystore, ppsz_values, p_secret, i_secret_len,
     ...",1,1,misc\keystore.c,vlc_keystore_store,,false,73,101,vlc_keystore_store,,,4,"int vlc_keystore_store (vlc_keystore*,char[KEY_MAX]*,uint8_t*,ssize_t,char*)"
113574,METHOD,misc\keystore.c:<global>,TYPE_DECL,"unsigned int
vlc_keystore_find(vlc_keystore *p_keystore,
                  const char * const ppsz_values[KEY_MAX],
                  vlc_keystore_entry **pp_entries)
{
    assert(p_keystore && ppsz_values && pp_entries);
    return p_keystore->pf_find(p_keystore, ppsz_values, pp_entries);
}",1,1,misc\keystore.c,vlc_keystore_find,,false,103,110,vlc_keystore_find,,,5,"unsigned int vlc_keystore_find (vlc_keystore*,char[KEY_MAX]*,vlc_keystore_entry**)"
113595,METHOD,misc\keystore.c:<global>,TYPE_DECL,"unsigned int
vlc_keystore_remove(vlc_keystore *p_keystore,
                    const char *const ppsz_values[KEY_MAX])
{
    assert(p_keystore && ppsz_values);
    return p_keystore->pf_remove(p_keystore, ppsz_values);
}",1,1,misc\keystore.c,vlc_keystore_remove,,false,112,118,vlc_keystore_remove,,,6,"unsigned int vlc_keystore_remove (vlc_keystore*,char[KEY_MAX]*)"
113612,METHOD,misc\keystore.c:<global>,TYPE_DECL,"void
vlc_keystore_release_entries(vlc_keystore_entry *p_entries, unsigned int i_count)
{
    for (unsigned int i = 0; i < i_count; ++i)
        vlc_keystore_release_entry(&p_entries[i]);
    free(p_entries);
}",1,1,misc\keystore.c,vlc_keystore_release_entries,,false,120,126,vlc_keystore_release_entries,,,7,"void vlc_keystore_release_entries (vlc_keystore_entry*,unsigned int)"
113636,METHOD,misc\keystore.c:<global>,TYPE_DECL,"int
libvlc_InternalKeystoreInit(libvlc_int_t *p_libvlc)
{
    assert(p_libvlc != NULL);
    libvlc_priv_t *p_priv = libvlc_priv(p_libvlc);

    p_priv->p_memory_keystore = keystore_create(VLC_OBJECT(p_libvlc), ""memory"");
    return p_priv->p_memory_keystore != NULL ? VLC_SUCCESS : VLC_EGENERIC;
}",1,1,misc\keystore.c,libvlc_InternalKeystoreInit,,false,128,136,libvlc_InternalKeystoreInit,,,8,int libvlc_InternalKeystoreInit (libvlc_int_t*)
113667,METHOD,misc\keystore.c:<global>,TYPE_DECL,"void
libvlc_InternalKeystoreClean(libvlc_int_t *p_libvlc)
{
    assert(p_libvlc != NULL);
    libvlc_priv_t *p_priv = libvlc_priv(p_libvlc);

    if (p_priv->p_memory_keystore != NULL)
    {
        vlc_keystore_release(p_priv->p_memory_keystore);
        p_priv->p_memory_keystore = NULL;
    }
}",1,1,misc\keystore.c,libvlc_InternalKeystoreClean,,false,138,149,libvlc_InternalKeystoreClean,,,9,void libvlc_InternalKeystoreClean (libvlc_int_t*)
113697,METHOD,misc\keystore.c:<global>,TYPE_DECL,"static vlc_keystore *
get_memory_keystore(vlc_object_t *p_obj)
{
    return libvlc_priv(p_obj->obj.libvlc)->p_memory_keystore;
}",1,1,misc\keystore.c,get_memory_keystore,,false,151,155,get_memory_keystore,,,10,vlc_keystore get_memory_keystore (vlc_object_t*)
113711,METHOD,misc\keystore.c:<global>,TYPE_DECL,"static vlc_keystore_entry *
find_closest_path(vlc_keystore_entry *p_entries, unsigned i_count,
                  const char *psz_path)
{
    vlc_keystore_entry *p_match_entry = NULL;
    size_t i_last_pathlen = 0;
    char *psz_decoded_path = vlc_uri_decode_duplicate(psz_path);
    if (psz_decoded_path == NULL)
        return NULL;

    /* Try to find the entry that has the closest path to psz_url */
    for (unsigned int i = 0; i < i_count; ++i)
    {
        vlc_keystore_entry *p_entry = &p_entries[i];
        const char *psz_entry_path = p_entry->ppsz_values[KEY_PATH];
        if (psz_entry_path == NULL)
        {
            if (p_match_entry == NULL)
                p_match_entry = p_entry;
            continue;
        }
        size_t i_entry_pathlen = strlen(psz_entry_path);

        if (strncasecmp(psz_decoded_path, psz_entry_path, i_entry_pathlen) == 0
         && i_entry_pathlen > i_last_pathlen)
        {
            i_last_pathlen = i_entry_pathlen;
            p_match_...",1,1,misc\keystore.c,find_closest_path,,false,157,189,find_closest_path,,,11,"vlc_keystore_entry find_closest_path (vlc_keystore_entry*,unsigned,char*)"
113806,METHOD,misc\keystore.c:<global>,TYPE_DECL,"static bool
is_credential_valid(vlc_credential *p_credential)
{
    if (p_credential->psz_username && p_credential->psz_password)
        return true;
    p_credential->psz_password = NULL;
    return false;
}",1,1,misc\keystore.c,is_credential_valid,,false,191,198,is_credential_valid,,,12,bool is_credential_valid (vlc_credential*)
113829,METHOD,misc\keystore.c:<global>,TYPE_DECL,"static bool
is_url_valid(const vlc_url_t *p_url)
{
    return p_url && p_url->psz_protocol && p_url->psz_protocol[0]
        && p_url->psz_host && p_url->psz_host[0];
}",1,1,misc\keystore.c,is_url_valid,,false,200,205,is_url_valid,,,13,bool is_url_valid (vlc_url_t*)
113881,METHOD,misc\keystore.c:<global>,TYPE_DECL,"static bool
protocol_set_port(const vlc_url_t *p_url, char *psz_port)
{
    int i_port = -1;

    if (p_url->i_port != 0 && p_url->i_port <= UINT16_MAX)
        i_port = p_url->i_port;
    else
    {
        for (unsigned int i = 0; i < sizeof(protocol_default_ports)
                                   / sizeof(*protocol_default_ports); ++i)
        {
            if (strcasecmp(p_url->psz_protocol,
                           protocol_default_ports[i].psz_protocol) == 0)
            {
                i_port = protocol_default_ports[i].i_port;
                break;
            }
        }
    }
    if (i_port != -1)
    {
        sprintf(psz_port, ""%u"", (uint16_t) i_port);
        return true;
    }
    return false;
}",1,1,misc\keystore.c,protocol_set_port,,false,222,248,protocol_set_port,,,17,"bool protocol_set_port (vlc_url_t*,char*)"
113966,METHOD,misc\keystore.c:<global>,TYPE_DECL,"static bool
protocol_is_smb(const vlc_url_t *p_url)
{
    return strcasecmp(p_url->psz_protocol, ""smb"") == 0;
}",1,1,misc\keystore.c,protocol_is_smb,,false,250,254,protocol_is_smb,,,18,bool protocol_is_smb (vlc_url_t*)
113979,METHOD,misc\keystore.c:<global>,TYPE_DECL,"static bool
protocol_store_path(const vlc_url_t *p_url)
{
    return p_url->psz_path
      && (strncasecmp(p_url->psz_protocol, ""http"", 4) == 0
      || strcasecmp(p_url->psz_protocol, ""rtsp"") == 0
      || protocol_is_smb(p_url));
}",1,1,misc\keystore.c,protocol_store_path,,false,256,263,protocol_store_path,,,19,bool protocol_store_path (vlc_url_t*)
114008,METHOD,misc\keystore.c:<global>,TYPE_DECL,"static void
smb_split_domain(vlc_credential *p_credential)
{
    char *psz_delim = strchr(p_credential->psz_username, ';');
    if (psz_delim)
    {
        size_t i_len = psz_delim - p_credential->psz_username;
        if (i_len > 0)
        {
            free(p_credential->psz_split_domain);
            p_credential->psz_split_domain =
                strndup(p_credential->psz_username, i_len);
            p_credential->psz_realm = p_credential->psz_split_domain;
        }
        p_credential->psz_username = psz_delim + 1;
    }
}",1,1,misc\keystore.c,smb_split_domain,,false,266,282,smb_split_domain,,,20,void smb_split_domain (vlc_credential*)
114064,METHOD,misc\keystore.c:<global>,TYPE_DECL,"static void
credential_find_keystore(vlc_credential *p_credential, vlc_keystore *p_keystore)
{
    const vlc_url_t *p_url = p_credential->p_url;

    const char *ppsz_values[KEY_MAX] = { 0 };
    ppsz_values[KEY_PROTOCOL] = p_url->psz_protocol;
    ppsz_values[KEY_USER] = p_credential->psz_username;
    ppsz_values[KEY_SERVER] = p_url->psz_host;
    /* don't try to match with the path */
    ppsz_values[KEY_REALM] = p_credential->psz_realm;
    ppsz_values[KEY_AUTHTYPE] = p_credential->psz_authtype;
    char psz_port[21];
    if (protocol_set_port(p_url, psz_port))
        ppsz_values[KEY_PORT] = psz_port;

    vlc_keystore_entry *p_entries;
    unsigned int i_entries_count;
    i_entries_count = vlc_keystore_find(p_keystore, ppsz_values, &p_entries);

    /* Remove last entries after vlc_keystore_find call since
     * p_credential->psz_username (default username) can be a pointer to an
     * entry */
    if (p_credential->i_entries_count > 0)
    {
        vlc_keystore_release_en...",1,1,misc\keystore.c,credential_find_keystore,,false,284,342,credential_find_keystore,,,21,"void credential_find_keystore (vlc_credential*,vlc_keystore*)"
114270,METHOD,misc\keystore.c:<global>,TYPE_DECL,"void
vlc_credential_init(vlc_credential *p_credential, const vlc_url_t *p_url)
{
    assert(p_credential);

    memset(p_credential, 0, sizeof(*p_credential));
    p_credential->i_get_order = GET_FROM_URL;
    p_credential->p_url = p_url;
}",1,1,misc\keystore.c,vlc_credential_init,,false,344,352,vlc_credential_init,,,22,"void vlc_credential_init (vlc_credential*,vlc_url_t*)"
114294,METHOD,misc\keystore.c:<global>,TYPE_DECL,"void
vlc_credential_clean(vlc_credential *p_credential)
{
    if (p_credential->i_entries_count > 0)
        vlc_keystore_release_entries(p_credential->p_entries,
                                     p_credential->i_entries_count);
    if (p_credential->p_keystore)
        vlc_keystore_release(p_credential->p_keystore);

    free(p_credential->psz_split_domain);
    free(p_credential->psz_var_username);
    free(p_credential->psz_var_password);
    free(p_credential->psz_dialog_username);
    free(p_credential->psz_dialog_password);
}",1,1,misc\keystore.c,vlc_credential_clean,,false,354,368,vlc_credential_clean,,,23,void vlc_credential_clean (vlc_credential*)
114342,METHOD,misc\keystore.c:<global>,TYPE_DECL,"bool
vlc_credential_get(vlc_credential *p_credential, vlc_object_t *p_parent,
                   const char *psz_option_username,
                   const char *psz_option_password,
                   const char *psz_dialog_title,
                   const char *psz_dialog_fmt, ...)
{
    assert(p_credential && p_parent);
    const vlc_url_t *p_url = p_credential->p_url;

    if (!is_url_valid(p_url))
    {
        msg_Err(p_parent, ""vlc_credential_get: invalid url"");
        return false;
    }

    p_credential->b_from_keystore = false;
    /* Don't set username to NULL, we may want to use the last one set */
    p_credential->psz_password = NULL;

    while (!is_credential_valid(p_credential))
    {
        /* First, fetch credential from URL (if any).
         * Secondly, fetch credential from VLC Options (if any).
         * Thirdly, fetch credential from keystore (if any) using user and realm
         * previously set by the caller, the URL or by VLC Options.
         * Finally...",1,1,misc\keystore.c,vlc_credential_get,,false,371,498,vlc_credential_get,,,24,"bool vlc_credential_get (vlc_credential*,vlc_object_t*,char*,char*,char*,char*...)"
114675,METHOD,misc\keystore.c:<global>,TYPE_DECL,"bool
vlc_credential_store(vlc_credential *p_credential, vlc_object_t *p_parent)
{
    if (!is_credential_valid(p_credential))
        return false;
    /* Don't need to store again */
    if (p_credential->b_from_keystore)
        return p_credential->b_from_keystore;

    vlc_keystore *p_keystore;
    if (p_credential->b_store)
    {
        /* Store in permanent keystore */
        assert(p_credential->p_keystore != NULL);
        p_keystore = p_credential->p_keystore;
    }
    else
    {
        /* Store in memory keystore */
        p_keystore = get_memory_keystore(p_parent);
    }
    if (p_keystore == NULL)
        return false;

    const vlc_url_t *p_url = p_credential->p_url;

    char *psz_path = NULL;
    if (protocol_store_path(p_url)
     && (psz_path =  vlc_uri_decode_duplicate(p_url->psz_path)) != NULL)
    {
        char *p_slash;
        if (protocol_is_smb(p_url))
        {
            /* Remove all characters after the first slash (store the share but
           ...",1,1,misc\keystore.c,vlc_credential_store,,false,501,577,vlc_credential_store,,,25,"bool vlc_credential_store (vlc_credential*,vlc_object_t*)"
114910,METHOD,misc\md5.c:<global>,TYPE_DECL,<global>,1,2,misc\md5.c,misc\md5.c:<global>,,false,1,349,<global>,,,1,
114916,METHOD,misc\md5.c:<global>,TYPE_DECL,"static void
md5_init( void *context )
{
  MD5_CONTEXT *ctx = context;

  ctx->A = 0x67452301;
  ctx->B = 0xefcdab89;
  ctx->C = 0x98badcfe;
  ctx->D = 0x10325476;

  ctx->nblocks = 0;
  ctx->count = 0;
}",1,1,misc\md5.c,md5_init,,false,54,66,md5_init,,,5,void md5_init (void*)
114955,METHOD,misc\md5.c:<global>,TYPE_DECL,"static void
transform ( MD5_CONTEXT *ctx, const unsigned char *data )
{
  u32 correct_words[16];
  register u32 A = ctx->A;
  register u32 B = ctx->B;
  register u32 C = ctx->C;
  register u32 D = ctx->D;
  u32 *cwp = correct_words;

#ifdef WORDS_BIGENDIAN
  {
    int i;
    byte *p2, *p1;
    for(i=0, p1=data, p2=(byte*)correct_words; i < 16; i++, p2 += 4 )
      {
        p2[3] = *p1++;
	p2[2] = *p1++;
	p2[1] = *p1++;
	p2[0] = *p1++;
      }
  }
#else
  memcpy( correct_words, data, 64 );
#endif


#define OP(a, b, c, d, s, T) \
  do			         	   \
    {					   \
      a += FF (b, c, d) + (*cwp++) + T;    \
      a = rol(a, s);			   \
      a += b;				   \
    }					   \
  while (0)

  /* Before we start, one word about the strange constants.
     They are defined in RFC 1321 as

     T[i] = (int) (4294967296.0 * fabs (sin (i))), i=1..64
  */

  /* Round 1.  */
  OP (A, B, C, D,  7, 0xd76aa478);
  OP (D, A, B, C, 12, 0xe8c7b756);
  OP (C, D, A, B, 17, 0x242070db);
  OP (B, C, D, A...",1,2,misc\md5.c,transform,,false,82,211,transform,,,6,"void transform (MD5_CONTEXT*,unsigned char*)"
117574,METHOD,misc\md5.c:<global>,TYPE_DECL,"static void
md5_write( void *context, const void *inbuf_arg , size_t inlen)
{
  const unsigned char *inbuf = inbuf_arg;
  MD5_CONTEXT *hd = context;

  if( hd->count == 64 )  /* flush the buffer */
    {
      transform( hd, hd->buf );
      hd->count = 0;
      hd->nblocks++;
    }
  if( !inbuf )
    return;

  if( hd->count )
    {
      for( ; inlen && hd->count < 64; inlen-- )
        hd->buf[hd->count++] = *inbuf++;
      md5_write( hd, NULL, 0 );
      if( !inlen )
        return;
    }

  while( inlen >= 64 )
    {
      transform( hd, inbuf );
      hd->count = 0;
      hd->nblocks++;
      inlen -= 64;
      inbuf += 64;
    }
  for( ; inlen && hd->count < 64; inlen-- )
    hd->buf[hd->count++] = *inbuf++;

}",1,1,misc\md5.c,md5_write,,false,219,254,md5_write,,,7,"void md5_write (void*,void*,size_t)"
117698,METHOD,misc\md5.c:<global>,TYPE_DECL,"static void
md5_final( void *context)
{
  MD5_CONTEXT *hd = context;
  u32 t, msb, lsb;
  byte *p;

  md5_write(hd, NULL, 0); /* flush */;

  t = hd->nblocks;
  /* multiply by 64 to make a byte count */
  lsb = t << 6;
  msb = t >> 26;
  /* add the count */
  t = lsb;
  if( (lsb += hd->count) < t )
    msb++;
  /* multiply by 8 to make a bit count */
  t = lsb;
  lsb <<= 3;
  msb <<= 3;
  msb |= t >> 29;

  if( hd->count < 56 )  /* enough room */
    {
      hd->buf[hd->count++] = 0x80; /* pad */
      while( hd->count < 56 )
        hd->buf[hd->count++] = 0;  /* pad */
    }
  else  /* need one extra block */
    {
      hd->buf[hd->count++] = 0x80; /* pad character */
      while( hd->count < 64 )
        hd->buf[hd->count++] = 0;
      md5_write(hd, NULL, 0);  /* flush */;
      memset(hd->buf, 0, 56 ); /* fill next block with zeroes */
    }
  /* append the 64 bit count */
  hd->buf[56] = lsb	   ;
  hd->buf[57] = lsb >>  8;
  hd->buf[58] = lsb >> 16;
  hd->buf[59] = lsb >> 24;
 ...",1,2,misc\md5.c,md5_final,,false,264,325,md5_final,,,8,void md5_final (void*)
117975,METHOD,misc\md5.c:<global>,TYPE_DECL,"void InitMD5( struct md5_s *h )
{
    md5_init( h );
}",1,1,misc\md5.c,InitMD5,,false,336,339,InitMD5,,,9,void InitMD5 (md5_s*)
117982,METHOD,misc\md5.c:<global>,TYPE_DECL,"void AddMD5( struct md5_s *restrict h, const void *data, size_t len )
{
    md5_write( h, data, len );
}",1,1,misc\md5.c,AddMD5,,false,341,344,AddMD5,,,10,"void AddMD5 (md5_s*,void*,size_t)"
117993,METHOD,misc\md5.c:<global>,TYPE_DECL,"void EndMD5( struct md5_s *h )
{
    md5_final( h );
}",1,1,misc\md5.c,EndMD5,,false,346,349,EndMD5,,,11,void EndMD5 (md5_s*)
118023,METHOD,misc\messages.c:<global>,TYPE_DECL,<global>,1,25,misc\messages.c,misc\messages.c:<global>,,false,1,442,<global>,,,1,
118032,METHOD,misc\messages.c:<global>,TYPE_DECL,"static void vlc_vaLogCallback(libvlc_int_t *vlc, int type,
                              const vlc_log_t *item, const char *format,
                              va_list ap)
{
    vlc_logger_t *logger = libvlc_priv(vlc)->logger;
    int canc;

    assert(logger != NULL);
    canc = vlc_savecancel();
    vlc_rwlock_rdlock(&logger->lock);
    logger->log(logger->sys, type, item, format, ap);
    vlc_rwlock_unlock(&logger->lock);
    vlc_restorecancel(canc);
}",1,1,misc\messages.c,vlc_vaLogCallback,,false,55,68,vlc_vaLogCallback,,,2,"void vlc_vaLogCallback (libvlc_int_t*,int,vlc_log_t*,char*,va_list)"
118079,METHOD,misc\messages.c:<global>,TYPE_DECL,"static void vlc_LogCallback(libvlc_int_t *vlc, int type, const vlc_log_t *item,
                            const char *format, ...)
{
    va_list ap;

    va_start(ap, format);
    vlc_vaLogCallback(vlc, type, item, format, ap);
    va_end(ap);
}",1,1,misc\messages.c,vlc_LogCallback,,false,70,78,vlc_LogCallback,,,3,"void vlc_LogCallback (libvlc_int_t*,int,vlc_log_t*,char*...)"
118099,METHOD,misc\messages.c:<global>,TYPE_DECL,"void vlc_vaLog (vlc_object_t *obj, int type, const char *module,
                const char *file, unsigned line, const char *func,
                const char *format, va_list args)
{
    if (obj != NULL && obj->obj.flags & OBJECT_FLAGS_QUIET)
        return;

    /* Get basename from the module filename */
    char *p = strrchr(module, '/');
    if (p != NULL)
        module = p + 1;
    p = strchr(module, '.');

    size_t modlen = (p != NULL) ? (p - module) : 0;
    char modulebuf[modlen + 1];
    if (p != NULL)
    {
        memcpy(modulebuf, module, modlen);
        modulebuf[modlen] = '\0';
        module = modulebuf;
    }

    /* Fill message information fields */
    vlc_log_t msg;

    msg.i_object_id = (uintptr_t)obj;
    msg.psz_object_type = (obj != NULL) ? obj->obj.object_type : ""generic"";
    msg.psz_module = module;
    msg.psz_header = NULL;
    msg.file = file;
    msg.line = line;
    msg.func = func;
    msg.tid = vlc_thread_id();

    for (vlc_object_t *o = obj;...",1,1,misc\messages.c,vlc_vaLog,,false,89,141,vlc_vaLog,,,4,"void vlc_vaLog (vlc_object_t*,int,char*,char*,unsigned,char*,char*,va_list)"
118278,METHOD,misc\messages.c:<global>,TYPE_DECL,"void vlc_Log(vlc_object_t *obj, int type, const char *module,
             const char *file, unsigned line, const char *func,
             const char *format, ... )
{
    va_list ap;

    va_start(ap, format);
    vlc_vaLog(obj, type, module, file, line, func, format, ap);
    va_end(ap);
}",1,1,misc\messages.c,vlc_Log,,false,154,163,vlc_Log,,,5,"void vlc_Log (vlc_object_t*,int,char*,char*,unsigned,char*,char*...)"
118316,METHOD,misc\messages.c:<global>,TYPE_DECL,"static void vlc_vaLogEarly(void *d, int type, const vlc_log_t *item,
                           const char *format, va_list ap)
{
    vlc_logger_early_t *sys = d;

    vlc_log_early_t *log = malloc(sizeof (*log));
    if (unlikely(log == NULL))
        return;

    log->next = NULL;
    log->type = type;
    log->meta.i_object_id = item->i_object_id;
    /* NOTE: Object types MUST be static constant - no need to copy them. */
    log->meta.psz_object_type = item->psz_object_type;
    log->meta.psz_module = item->psz_module; /* Ditto. */
    log->meta.psz_header = item->psz_header ? strdup(item->psz_header) : NULL;
    log->meta.file = item->file;
    log->meta.line = item->line;
    log->meta.func = item->func;

    if (vasprintf(&log->msg, format, ap) == -1)
        log->msg = NULL;

    vlc_mutex_lock(&sys->lock);
    assert(sys->tailp != NULL);
    assert(*(sys->tailp) == NULL);
    *(sys->tailp) = log;
    sys->tailp = &log->next;
    vlc_mutex_unlock(&sys->lock);
}",1,1,misc\messages.c,vlc_vaLogEarly,,false,223,252,vlc_vaLogEarly,,,10,"void vlc_vaLogEarly (void*,int,vlc_log_t*,char*,va_list)"
118476,METHOD,misc\messages.c:<global>,TYPE_DECL,"static int vlc_LogEarlyOpen(vlc_logger_t *logger)
{
    vlc_logger_early_t *sys = malloc(sizeof (*sys));

    if (unlikely(sys == NULL))
        return -1;

    vlc_mutex_init(&sys->lock);
    sys->head = NULL;
    sys->tailp = &sys->head;

    logger->log = vlc_vaLogEarly;
    logger->sys = sys;
    return 0;
}",1,1,misc\messages.c,vlc_LogEarlyOpen,,false,254,268,vlc_LogEarlyOpen,,,11,int vlc_LogEarlyOpen (vlc_logger_t*)
118527,METHOD,misc\messages.c:<global>,TYPE_DECL,"static void vlc_LogEarlyClose(vlc_logger_t *logger, void *d)
{
    libvlc_int_t *vlc = logger->obj.libvlc;
    vlc_logger_early_t *sys = d;

    /* Drain early log messages */
    for (vlc_log_early_t *log = sys->head, *next; log != NULL; log = next)
    {
        vlc_LogCallback(vlc, log->type, &log->meta, ""%s"",
                        (log->msg != NULL) ? log->msg : ""message lost"");
        free(log->msg);
        next = log->next;
        free(log);
    }

    vlc_mutex_destroy(&sys->lock);
    free(sys);
}",1,1,misc\messages.c,vlc_LogEarlyClose,,false,270,287,vlc_LogEarlyClose,,,12,"void vlc_LogEarlyClose (vlc_logger_t*,void*)"
118599,METHOD,misc\messages.c:<global>,TYPE_DECL,"static void vlc_vaLogDiscard(void *d, int type, const vlc_log_t *item,
                             const char *format, va_list ap)
{
    (void) d; (void) type; (void) item; (void) format; (void) ap;
}",1,1,misc\messages.c,vlc_vaLogDiscard,,false,289,293,vlc_vaLogDiscard,,,13,"void vlc_vaLogDiscard (void*,int,vlc_log_t*,char*,va_list)"
118623,METHOD,misc\messages.c:<global>,TYPE_DECL,"static int vlc_logger_load(void *func, va_list ap)
{
    vlc_log_cb (*activate)(vlc_object_t *, void **) = func;
    vlc_logger_t *logger = va_arg(ap, vlc_logger_t *);
    vlc_log_cb *cb = va_arg(ap, vlc_log_cb *);
    void **sys = va_arg(ap, void **);

    *cb = activate(VLC_OBJECT(logger), sys);
    return (*cb != NULL) ? VLC_SUCCESS : VLC_EGENERIC;
}",1,1,misc\messages.c,vlc_logger_load,,false,295,304,vlc_logger_load,,,14,"int vlc_logger_load (void*,va_list)"
118627,METHOD,misc\messages.c:<global>,TYPE_DECL,"vlc_log_cb (*activate)(vlc_object_t *, void **) = func;",16,58,misc\messages.c,vlc_logger_load.activate,,false,297,297,activate,,,1,"vlc_log_cb vlc_logger_load.activate (vlc_object_t*,void**)"
118653,METHOD,misc\messages.c:<global>,TYPE_DECL,"static void vlc_logger_unload(void *func, va_list ap)
{
    void (*deactivate)(vlc_logger_t *) = func;
    void *sys = va_arg(ap, void *);

    deactivate(sys);
}",1,1,misc\messages.c,vlc_logger_unload,,false,306,312,vlc_logger_unload,,,15,"void vlc_logger_unload (void*,va_list)"
118657,METHOD,misc\messages.c:<global>,TYPE_DECL,void (*deactivate)(vlc_logger_t *) = func;,10,45,misc\messages.c,vlc_logger_unload.deactivate,,false,308,308,deactivate,,,1,void vlc_logger_unload.deactivate (vlc_logger_t*)
118667,METHOD,misc\messages.c:<global>,TYPE_DECL,"int vlc_LogPreinit(libvlc_int_t *vlc)
{
    vlc_logger_t *logger = vlc_custom_create(vlc, sizeof (*logger), ""logger"");

    libvlc_priv(vlc)->logger = logger;

    if (unlikely(logger == NULL))
        return -1;

    vlc_rwlock_init(&logger->lock);

    if (vlc_LogEarlyOpen(logger))
    {
        logger->log = vlc_vaLogDiscard;
        return -1;
    }

    /* Announce who we are */
    msg_Dbg(vlc, ""VLC media player - %s"", VERSION_MESSAGE);
    msg_Dbg(vlc, ""%s"", COPYRIGHT_MESSAGE);
    msg_Dbg(vlc, ""revision %s"", psz_vlc_changeset);
    msg_Dbg(vlc, ""configured with %s"", CONFIGURE_LINE);
    return 0;
}",1,27,misc\messages.c,vlc_LogPreinit,,false,323,346,vlc_LogPreinit,,,16,int vlc_LogPreinit (libvlc_int_t*)
118736,METHOD,misc\messages.c:<global>,TYPE_DECL,"int vlc_LogInit(libvlc_int_t *vlc)
{
    vlc_logger_t *logger = libvlc_priv(vlc)->logger;
    if (unlikely(logger == NULL))
        return -1;

    vlc_log_cb cb;
    void *sys, *early_sys = NULL;

    /* TODO: module configuration item */
    module_t *module = vlc_module_load(logger, ""logger"", NULL, false,
                                       vlc_logger_load, logger, &cb, &sys);
    if (module == NULL)
        cb = vlc_vaLogDiscard;

    vlc_rwlock_wrlock(&logger->lock);
    if (logger->log == vlc_vaLogEarly)
        early_sys = logger->sys;

    logger->log = cb;
    logger->sys = sys;
    assert(logger->module == NULL); /* Only one call to vlc_LogInit()! */
    logger->module = module;
    vlc_rwlock_unlock(&logger->lock);

    if (early_sys != NULL)
        vlc_LogEarlyClose(logger, early_sys);

    return 0;
}",1,1,misc\messages.c,vlc_LogInit,,false,354,383,vlc_LogInit,,,17,int vlc_LogInit (libvlc_int_t*)
118838,METHOD,misc\messages.c:<global>,TYPE_DECL,"void vlc_LogSet(libvlc_int_t *vlc, vlc_log_cb cb, void *opaque)
{
    vlc_logger_t *logger = libvlc_priv(vlc)->logger;

    if (unlikely(logger == NULL))
        return;

    module_t *module;
    void *sys;

    if (cb == NULL)
        cb = vlc_vaLogDiscard;

    vlc_rwlock_wrlock(&logger->lock);
    sys = logger->sys;
    module = logger->module;

    logger->log = cb;
    logger->sys = opaque;
    logger->module = NULL;
    vlc_rwlock_unlock(&logger->lock);

    if (module != NULL)
        vlc_module_unload(vlc, module, vlc_logger_unload, sys);

    /* Announce who we are */
    msg_Dbg (vlc, ""VLC media player - %s"", VERSION_MESSAGE);
    msg_Dbg (vlc, ""%s"", COPYRIGHT_MESSAGE);
    msg_Dbg (vlc, ""revision %s"", psz_vlc_changeset);
    msg_Dbg (vlc, ""configured with %s"", CONFIGURE_LINE);
}",1,1,misc\messages.c,vlc_LogSet,,false,390,420,vlc_LogSet,,,18,"void vlc_LogSet (libvlc_int_t*,vlc_log_cb,void*)"
118930,METHOD,misc\messages.c:<global>,TYPE_DECL,"void vlc_LogDeinit(libvlc_int_t *vlc)
{
    vlc_logger_t *logger = libvlc_priv(vlc)->logger;

    if (unlikely(logger == NULL))
        return;

    if (logger->module != NULL)
        vlc_module_unload(vlc, logger->module, vlc_logger_unload, logger->sys);
    else
    /* Flush early log messages (corner case: no call to vlc_LogInit()) */
    if (logger->log == vlc_vaLogEarly)
    {
        logger->log = vlc_vaLogDiscard;
        vlc_LogEarlyClose(logger, logger->sys);
    }

    vlc_rwlock_destroy(&logger->lock);
    vlc_object_release(logger);
    libvlc_priv(vlc)->logger = NULL;
}",1,1,misc\messages.c,vlc_LogDeinit,,false,422,442,vlc_LogDeinit,,,19,void vlc_LogDeinit (libvlc_int_t*)
119008,METHOD,misc\mime.c:<global>,TYPE_DECL,<global>,1,2,misc\mime.c,misc\mime.c:<global>,,false,1,108,<global>,,,1,
119013,METHOD,<empty>,<empty>,<empty>,1,,misc\mime.c,ext_mime:<clinit>,,false,34,,<clinit>,,,3,
119140,METHOD,misc\mime.c:<global>,TYPE_DECL,"const char *vlc_mime_Ext2Mime( const char *psz_url )
{

    char *psz_ext;

    psz_ext = strrchr( psz_url, '.' );
    if( psz_ext )
    {
        int i;

        for( i = 0; ext_mime[i].psz_ext[0] ; i++ )
        {
            if( !strcasecmp( ext_mime[i].psz_ext, psz_ext ) )
            {
                return ext_mime[i].psz_mime;
            }
        }
    }
    return ""application/octet-stream"";
}",1,1,misc\mime.c,vlc_mime_Ext2Mime,,false,89,108,vlc_mime_Ext2Mime,,,4,const char* vlc_mime_Ext2Mime (char*)
119199,METHOD,misc\mtime.c:<global>,TYPE_DECL,<global>,1,1,misc\mtime.c,misc\mtime.c:<global>,,false,1,218,<global>,,,1,
119201,METHOD,misc\mtime.c:<global>,TYPE_DECL,"char *secstotimestr( char *psz_buffer, int32_t i_seconds )
{
    if( unlikely(i_seconds < 0) )
    {
        secstotimestr( psz_buffer + 1, -i_seconds );
        *psz_buffer = '-';
        return psz_buffer;
    }

    div_t d;

    d = div( i_seconds, 60 );
    i_seconds = d.rem;
    d = div( d.quot, 60 );

    if( d.quot )
        snprintf( psz_buffer, MSTRTIME_MAX_SIZE, ""%u:%02u:%02u"",
                 d.quot, d.rem, i_seconds );
    else
        snprintf( psz_buffer, MSTRTIME_MAX_SIZE, ""%02u:%02u"",
                  d.rem, i_seconds );
    return psz_buffer;
}",1,1,misc\mtime.c,secstotimestr,,false,51,73,secstotimestr,,,1,"char* secstotimestr (char*,int32_t)"
119271,METHOD,misc\mtime.c:<global>,TYPE_DECL,"void date_Init( date_t *p_date, uint32_t i_divider_n, uint32_t i_divider_d )
{
    p_date->date = 0;
    p_date->i_divider_num = i_divider_n;
    p_date->i_divider_den = i_divider_d;
    p_date->i_remainder = 0;
}",1,1,misc\mtime.c,date_Init,,false,87,93,date_Init,,,2,"void date_Init (date_t*,uint32_t,uint32_t)"
119298,METHOD,misc\mtime.c:<global>,TYPE_DECL,"void date_Change( date_t *p_date, uint32_t i_divider_n, uint32_t i_divider_d )
{
    /* change time scale of remainder */
    p_date->i_remainder = p_date->i_remainder * i_divider_n / p_date->i_divider_num;
    p_date->i_divider_num = i_divider_n;
    p_date->i_divider_den = i_divider_d;
}",1,1,misc\mtime.c,date_Change,,false,103,109,date_Change,,,3,"void date_Change (date_t*,uint32_t,uint32_t)"
119328,METHOD,misc\mtime.c:<global>,TYPE_DECL,"void date_Set( date_t *p_date, mtime_t i_new_date )
{
    p_date->date = i_new_date;
    p_date->i_remainder = 0;
}",1,1,misc\mtime.c,date_Set,,false,117,121,date_Set,,,4,"void date_Set (date_t*,mtime_t)"
119344,METHOD,misc\mtime.c:<global>,TYPE_DECL,"mtime_t date_Get( const date_t *p_date )
{
    return p_date->date;
}",1,1,misc\mtime.c,date_Get,,false,129,132,date_Get,,,5,mtime_t date_Get (date_t*)
119353,METHOD,misc\mtime.c:<global>,TYPE_DECL,"void date_Move( date_t *p_date, mtime_t i_difference )
{
    p_date->date += i_difference;
}",1,1,misc\mtime.c,date_Move,,false,140,143,date_Move,,,6,"void date_Move (date_t*,mtime_t)"
119364,METHOD,misc\mtime.c:<global>,TYPE_DECL,"mtime_t date_Increment( date_t *p_date, uint32_t i_nb_samples )
{
    assert( p_date->i_divider_num != 0 );
    mtime_t i_dividend = i_nb_samples * CLOCK_FREQ * p_date->i_divider_den;
    lldiv_t d = lldiv( i_dividend, p_date->i_divider_num );

    p_date->date += d.quot;
    p_date->i_remainder += (int)d.rem;

    if( p_date->i_remainder >= p_date->i_divider_num )
    {
        /* This is Bresenham algorithm. */
        assert( p_date->i_remainder < 2*p_date->i_divider_num);
        p_date->date += 1;
        p_date->i_remainder -= p_date->i_divider_num;
    }

    return p_date->date;
}",1,1,misc\mtime.c,date_Increment,,false,153,171,date_Increment,,,7,"mtime_t date_Increment (date_t*,uint32_t)"
119445,METHOD,misc\mtime.c:<global>,TYPE_DECL,"mtime_t date_Decrement( date_t *p_date, uint32_t i_nb_samples )
{
    mtime_t i_dividend = (mtime_t)i_nb_samples * CLOCK_FREQ * p_date->i_divider_den;
    p_date->date -= i_dividend / p_date->i_divider_num;
    unsigned i_rem_adjust = i_dividend % p_date->i_divider_num;

    if( p_date->i_remainder < i_rem_adjust )
    {
        /* This is Bresenham algorithm. */
        assert( p_date->i_remainder < p_date->i_divider_num);
        p_date->date -= 1;
        p_date->i_remainder += p_date->i_divider_num;
    }

    p_date->i_remainder -= i_rem_adjust;

    return p_date->date;
}",1,1,misc\mtime.c,date_Decrement,,false,181,198,date_Decrement,,,8,"mtime_t date_Decrement (date_t*,uint32_t)"
119516,METHOD,misc\mtime.c:<global>,TYPE_DECL,"uint64_t NTPtime64(void)
{
    struct timespec ts;

    timespec_get(&ts, TIME_UTC);

    /* Convert nanoseconds to 32-bits fraction (232 picosecond units) */
    uint64_t t = (uint64_t)(ts.tv_nsec) << 32;
    t /= 1000000000;

    /* The offset to Unix epoch is 70 years (incl. 17 leap ones). There were
     * no leap seconds during that period since they had not been invented yet.
     */
    t |= ((UINT64_C(70) * 365 + 17) * 24 * 60 * 60 + ts.tv_sec) << 32;
    return t;
}",1,1,misc\mtime.c,NTPtime64,,false,203,218,NTPtime64,,,9,uint64_t NTPtime64 (void)
119585,METHOD,misc\objects.c:<global>,TYPE_DECL,<global>,1,1,misc\objects.c,misc\objects.c:<global>,,false,1,555,<global>,,,1,
119587,METHOD,misc\objects.c:<global>,TYPE_DECL,"static void PrintObject (vlc_object_t *obj, const char *prefix)
{
    vlc_object_internals_t *priv = vlc_internals(obj);

    int canc = vlc_savecancel ();
    printf ("" %so %p %s, %u refs, parent %p\n"", prefix, (void *)obj,
            obj->obj.object_type, atomic_load(&priv->refs),
            (void *)obj->obj.parent);
    vlc_restorecancel (canc);
}",1,35,misc\objects.c,PrintObject,,false,58,67,PrintObject,,,1,"void PrintObject (vlc_object_t*,char*)"
119634,METHOD,misc\objects.c:<global>,TYPE_DECL,"static void DumpStructure (vlc_object_t *obj, unsigned level, char *psz_foo)
{
    char back = psz_foo[level];

    psz_foo[level] = '\0';
    PrintObject (obj, psz_foo);
    psz_foo[level] = back;

    if (level / 2 >= MAX_DUMPSTRUCTURE_DEPTH)
    {
        msg_Warn (obj, ""structure tree is too deep"");
        return;
    }

    vlc_object_internals_t *priv = vlc_internals(obj);

    /* NOTE: nested locking here (due to recursive call) */
    vlc_mutex_lock (&vlc_internals(obj)->tree_lock);
    for (priv = priv->first; priv != NULL; priv = priv->next)
    {
        if (level > 0)
        {
            assert(level >= 2);
            psz_foo[level - 1] = ' ';

            if (psz_foo[level - 2] == '`')
                psz_foo[level - 2] = ' ';
        }

        psz_foo[level] = priv->next ? '|' : '`';
        psz_foo[level + 1] = '-';
        psz_foo[level + 2] = '\0';

        DumpStructure (vlc_externals(priv), level + 2, psz_foo);
    }
    vlc_mutex_unlock (&vlc_internals(obj)-...",1,35,misc\objects.c,DumpStructure,,false,69,105,DumpStructure,,,2,"void DumpStructure (vlc_object_t*,unsigned,char*)"
119794,METHOD,misc\objects.c:<global>,TYPE_DECL,"static int TreeCommand (vlc_object_t *obj, char const *cmd,
                        vlc_value_t oldval, vlc_value_t newval, void *data)
{
    (void) cmd; (void) oldval; (void) newval; (void) data;

    if (cmd[0] == 't')
    {
        char psz_foo[2 * MAX_DUMPSTRUCTURE_DEPTH + 1];

        psz_foo[0] = '|';
        DumpStructure (obj, 0, psz_foo);
    }

    return VLC_SUCCESS;
}",1,1,misc\objects.c,TreeCommand,,false,114,128,TreeCommand,,,3,"int TreeCommand (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
119834,METHOD,misc\objects.c:<global>,TYPE_DECL,"static vlc_object_t *ObjectExists (vlc_object_t *root, void *obj)
{
    if (root == obj)
        return vlc_object_hold (root);

    vlc_object_internals_t *priv = vlc_internals(root);
    vlc_object_t *ret = NULL;

    /* NOTE: nested locking here (due to recursive call) */
    vlc_mutex_lock (&vlc_internals(root)->tree_lock);

    for (priv = priv->first; priv != NULL && ret == NULL; priv = priv->next)
        ret = ObjectExists (vlc_externals (priv), obj);

    vlc_mutex_unlock (&vlc_internals(root)->tree_lock);
    return ret;
}",1,35,misc\objects.c,ObjectExists,,false,130,146,ObjectExists,,,4,"vlc_object_t ObjectExists (vlc_object_t*,void*)"
119923,METHOD,misc\objects.c:<global>,TYPE_DECL,"static int VarsCommand (vlc_object_t *obj, char const *cmd,
                        vlc_value_t oldval, vlc_value_t newval, void *data)
{
    void *p;

    (void) cmd; (void) oldval; (void) data;

    if (sscanf (newval.psz_string, ""%p"", &p) == 1)
    {
        p = ObjectExists (obj, p);
        if (p == NULL)
        {
            msg_Err (obj, ""no such object: %s"", newval.psz_string);
            return VLC_ENOOBJ;
        }
        obj = p;
    }
    else
        vlc_object_hold (obj);

    PrintObject (obj, """");
    DumpVariables (obj);
    vlc_object_release (obj);

    return VLC_SUCCESS;
}",1,1,misc\objects.c,VarsCommand,,false,148,173,VarsCommand,,,5,"int VarsCommand (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
119987,METHOD,misc\objects.c:<global>,TYPE_DECL,"void *vlc_custom_create (vlc_object_t *parent, size_t length,
                         const char *typename)
{
    /* NOTE:
     * VLC objects are laid out as follow:
     * - first the LibVLC-private per-object data,
     * - then VLC_COMMON members from vlc_object_t,
     * - finally, the type-specific data (if any).
     *
     * This function initializes the LibVLC and common data,
     * and zeroes the rest.
     */
    assert (length >= sizeof (vlc_object_t));

    vlc_object_internals_t *priv = malloc (sizeof (*priv) + length);
    if (unlikely(priv == NULL))
        return NULL;
    priv->psz_name = NULL;
    priv->var_root = NULL;
    vlc_mutex_init (&priv->var_lock);
    vlc_cond_init (&priv->var_wait);
    atomic_init (&priv->refs, 1);
    priv->pf_destructor = NULL;
    priv->prev = NULL;
    priv->first = NULL;
    vlc_mutex_init (&priv->tree_lock);
    priv->resources = NULL;

    vlc_object_t *obj = (vlc_object_t *)(priv + 1);
    obj->obj.object_type = typename;
    ...",1,41,misc\objects.c,vlc_custom_create,,false,176,247,vlc_custom_create,,,6,"void* vlc_custom_create (vlc_object_t*,size_t,char*)"
120254,METHOD,misc\objects.c:<global>,TYPE_DECL,"void *vlc_object_create( vlc_object_t *p_this, size_t i_size )
{
    return vlc_custom_create( p_this, i_size, ""generic"" );
}",1,1,misc\objects.c,vlc_object_create,,false,257,260,vlc_object_create,,,7,"void* vlc_object_create (vlc_object_t*,size_t)"
120265,METHOD,misc\objects.c:<global>,TYPE_DECL,"void vlc_object_set_destructor( vlc_object_t *p_this,
                                vlc_destructor_t pf_destructor )
{
    vlc_object_internals_t *p_priv = vlc_internals(p_this );

    p_priv->pf_destructor = pf_destructor;
}",1,37,misc\objects.c,vlc_object_set_destructor,,false,271,277,vlc_object_set_destructor,,,8,"void vlc_object_set_destructor (vlc_object_t*,vlc_destructor_t)"
120292,METHOD,misc\objects.c:<global>,TYPE_DECL,"int vlc_object_set_name(vlc_object_t *obj, const char *name)
{
    vlc_object_internals_t *priv = vlc_internals(obj);
    char *newname = name ? strdup (name) : NULL;
    char *oldname;

    vlc_mutex_lock (&name_lock);
    oldname = priv->psz_name;
    priv->psz_name = newname;
    vlc_mutex_unlock (&name_lock);

    free (oldname);
    return (priv->psz_name || !name) ? VLC_SUCCESS : VLC_ENOMEM;
}",1,35,misc\objects.c,vlc_object_set_name,,false,282,295,vlc_object_set_name,,,11,"int vlc_object_set_name (vlc_object_t*,char*)"
120347,METHOD,misc\objects.c:<global>,TYPE_DECL,"char *vlc_object_get_name(const vlc_object_t *obj)
{
    vlc_object_internals_t *priv = vlc_internals(obj);
    char *name;

    vlc_mutex_lock (&name_lock);
    name = priv->psz_name ? strdup (priv->psz_name) : NULL;
    vlc_mutex_unlock (&name_lock);

    return name;
}",1,35,misc\objects.c,vlc_object_get_name,,false,298,308,vlc_object_get_name,,,12,char* vlc_object_get_name (vlc_object_t*)
120384,METHOD,misc\objects.c:<global>,TYPE_DECL,"static void vlc_object_destroy( vlc_object_t *p_this )
{
    vlc_object_internals_t *p_priv = vlc_internals( p_this );

    assert(p_priv->resources == NULL);

    /* Call the custom ""subclass"" destructor */
    if( p_priv->pf_destructor )
        p_priv->pf_destructor( p_this );

    if (unlikely(p_this->obj.parent == NULL))
    {
        /* TODO: should be in src/libvlc.c */
        var_DelCallback (p_this, ""vars"", VarsCommand, NULL);
        var_DelCallback (p_this, ""tree"", TreeCommand, NULL);
    }

    /* Destroy the associated variables. */
    var_DestroyAll( p_this );

    vlc_mutex_destroy (&p_priv->tree_lock);
    vlc_cond_destroy( &p_priv->var_wait );
    vlc_mutex_destroy( &p_priv->var_lock );
    free( p_this->obj.header );
    free( p_priv->psz_name );
    free( p_priv );
}",1,37,misc\objects.c,vlc_object_destroy,,false,315,341,vlc_object_destroy,,,13,void vlc_object_destroy (vlc_object_t*)
120466,METHOD,misc\objects.c:<global>,TYPE_DECL,"static vlc_object_t *FindName (vlc_object_t *obj, const char *name)
{
    vlc_object_internals_t *priv = vlc_internals(obj);

    if (priv->psz_name != NULL && !strcmp (priv->psz_name, name))
        return vlc_object_hold (obj);

    vlc_object_t *found = NULL;
    /* NOTE: nested locking here (due to recursive call) */
    vlc_mutex_lock (&vlc_internals(obj)->tree_lock);

    for (priv = priv->first; priv != NULL && found == NULL; priv = priv->next)
        found = FindName (vlc_externals(priv), name);

    /* NOTE: nested locking here (due to recursive call) */
    vlc_mutex_unlock (&vlc_internals(obj)->tree_lock);
    return found;
}",1,35,misc\objects.c,FindName,,false,343,360,FindName,,,14,"vlc_object_t FindName (vlc_object_t*,char*)"
120564,METHOD,misc\objects.c:<global>,TYPE_DECL,"vlc_object_t *vlc_object_find_name( vlc_object_t *p_this, const char *psz_name )
{
    vlc_object_t *p_found;

    /* The object name is not thread-safe, provides no warranty that the
     * object is fully initialized and still active, and that its owner can
     * deal with asynchronous and external state changes. There may be multiple
     * objects with the same name, and the function may fail even if a matching
     * object exists. DO NOT USE THIS IN NEW CODE. */
#ifndef NDEBUG
    /* This was officially deprecated on August 19 2009. For the convenience of
     * wannabe code janitors, this is the list of names that remain used
     * and unfixed since then. */
    static const char bad[][11] = { ""adjust"", ""clone"", ""colorthres"",
        ""erase"", ""extract"", ""gradient"", ""logo"", ""marq"", ""motionblur"", ""puzzle"",
        ""rotate"", ""sharpen"", ""transform"", ""v4l2"", ""wall"" };
    static const char poor[][13] = { ""invert"", ""magnify"", ""motiondetect"",
        ""psychedelic"", ""ripple"", ""wave...",1,1,misc\objects.c,vlc_object_find_name,,false,378,406,vlc_object_find_name,,,15,"vlc_object_t vlc_object_find_name (vlc_object_t*,char*)"
120642,METHOD,misc\objects.c:<global>,TYPE_DECL,"void * vlc_object_hold( vlc_object_t *p_this )
{
    vlc_object_internals_t *internals = vlc_internals( p_this );
#ifndef NDEBUG
    unsigned refs = atomic_fetch_add (&internals->refs, 1);
    assert (refs > 0); /* Avoid obvious freed object uses */
#else
    atomic_fetch_add (&internals->refs, 1);
#endif
    return p_this;
}",1,40,misc\objects.c,vlc_object_hold,,false,412,422,vlc_object_hold,,,16,void* vlc_object_hold (vlc_object_t*)
120674,METHOD,misc\objects.c:<global>,TYPE_DECL,"void vlc_object_release (vlc_object_t *obj)
{
    vlc_object_internals_t *priv = vlc_internals(obj);
    unsigned refs = atomic_load (&priv->refs);

    /* Fast path */
    while (refs > 1)
    {
        if (atomic_compare_exchange_weak (&priv->refs, &refs, refs - 1))
            return; /* There are still other references to the object */

        assert (refs > 0);
    }

    vlc_object_t *parent = obj->obj.parent;

    if (unlikely(parent == NULL))
    {   /* Destroying the root object */
        refs = atomic_fetch_sub (&priv->refs, 1);
        assert (refs == 1); /* nobody to race against in this case */

        assert (priv->first == NULL); /* no children can be left */

        int canc = vlc_savecancel ();
        vlc_object_destroy (obj);
        vlc_restorecancel (canc);
        return;
    }

    /* Slow path */
    vlc_object_internals_t *papriv = vlc_internals (parent);

    vlc_mutex_lock (&papriv->tree_lock);
    refs = atomic_fetch_sub (&priv->refs, 1);
    assert (...",1,35,misc\objects.c,vlc_object_release,,false,429,498,vlc_object_release,,,17,void vlc_object_release (vlc_object_t*)
120881,METHOD,misc\objects.c:<global>,TYPE_DECL,"vlc_list_t *vlc_list_children( vlc_object_t *obj )
{
    vlc_list_t *l = malloc (sizeof (*l));
    if (unlikely(l == NULL))
        return NULL;

    l->i_count = 0;
    l->p_values = NULL;

    vlc_object_internals_t *priv;
    unsigned count = 0;

    vlc_mutex_lock (&vlc_internals(obj)->tree_lock);
    for (priv = vlc_internals (obj)->first; priv; priv = priv->next)
         count++;

    if (count > 0)
    {
        l->p_values = vlc_alloc (count, sizeof (vlc_value_t));
        if (unlikely(l->p_values == NULL))
        {
            vlc_mutex_unlock (&vlc_internals(obj)->tree_lock);
            free (l);
            return NULL;
        }
        l->i_count = count;
    }

    unsigned i = 0;

    for (priv = vlc_internals (obj)->first; priv; priv = priv->next)
        l->p_values[i++].p_address = vlc_object_hold (vlc_externals (priv));
    vlc_mutex_unlock (&vlc_internals(obj)->tree_lock);
    return l;
}",1,21,misc\objects.c,vlc_list_children,,false,506,540,vlc_list_children,,,18,vlc_list_t vlc_list_children (vlc_object_t*)
121053,METHOD,misc\objects.c:<global>,TYPE_DECL,"void vlc_list_release( vlc_list_t *p_list )
{
    for( int i = 0; i < p_list->i_count; i++ )
        vlc_object_release( p_list->p_values[i].p_address );

    free( p_list->p_values );
    free( p_list );
}",1,1,misc\objects.c,vlc_list_release,,false,548,555,vlc_list_release,,,19,void vlc_list_release (vlc_list_t*)
121104,METHOD,misc\objres.c:<global>,TYPE_DECL,<global>,1,1,misc\objres.c,misc\objres.c:<global>,,false,1,172,<global>,,,1,
121109,METHOD,vlc_res,TYPE_DECL,void (*release)(void *);,10,27,misc\objres.c,vlc_res.release,,false,38,38,release,,,3,void vlc_res.release (void*)
121115,METHOD,<empty>,<empty>,<empty>,1,,misc\objres.c,vlc_res:<clinit>,,false,35,,<clinit>,,,5,
121120,METHOD,misc\objres.c:<global>,TYPE_DECL,"static struct vlc_res **vlc_obj_res(vlc_object_t *obj)
{
    return &vlc_internals(obj)->resources;
}",1,12,misc\objres.c,vlc_obj_res,,false,42,45,vlc_obj_res,,,2,struct vlc_res vlc_obj_res (vlc_object_t*)
121138,METHOD,misc\objres.c:<global>,TYPE_DECL,"void *vlc_objres_new(size_t size, void (*release)(void *))
{
    if (unlikely(add_overflow(sizeof (struct vlc_res), size, &size)))
    {
        errno = ENOMEM;
        return NULL;
    }

    struct vlc_res *res = malloc(size);
    if (unlikely(res == NULL))
        return NULL;

    res->release = release;
    return res->payload;
}",1,1,misc\objres.c,vlc_objres_new,,false,47,61,vlc_objres_new,,,3,"void* vlc_objres_new (size_t,void)"
121180,METHOD,misc\objres.c:<global>,TYPE_DECL,"void vlc_objres_push(vlc_object_t *obj, void *data)
{
    struct vlc_res **restrict pp = vlc_obj_res(obj);
    struct vlc_res *res = container_of(data, struct vlc_res, payload);

    res->prev = *pp;
    *pp = res;
}",1,1,misc\objres.c,vlc_objres_push,,false,63,70,vlc_objres_push,,,4,"void vlc_objres_push (vlc_object_t*,void*)"
121203,METHOD,misc\objres.c:<global>,TYPE_DECL,"static void *vlc_objres_pop(vlc_object_t *obj)
{
    struct vlc_res **restrict pp = vlc_obj_res(obj);
    struct vlc_res *res = *pp;

    if (res == NULL)
        return NULL;
    *pp = res->prev;
    return res->payload;
}",1,1,misc\objres.c,vlc_objres_pop,,false,72,81,vlc_objres_pop,,,5,void* vlc_objres_pop (vlc_object_t*)
121235,METHOD,misc\objres.c:<global>,TYPE_DECL,"void vlc_objres_clear(vlc_object_t *obj)
{
    void *data;

    while ((data = vlc_objres_pop(obj)) != NULL)
    {
        struct vlc_res *res = container_of(data, struct vlc_res, payload);

        res->release(res->payload);
        free(res);
    }
}",1,1,misc\objres.c,vlc_objres_clear,,false,83,94,vlc_objres_clear,,,6,void vlc_objres_clear (vlc_object_t*)
121260,METHOD,misc\objres.c:<global>,TYPE_DECL,"void vlc_objres_remove(vlc_object_t *obj, void *data,
                       bool (*match)(void *, void *))
{
    struct vlc_res **restrict pp = vlc_obj_res(obj);

    /* With a doubly-linked list, this function could have constant complexity.
     * But that would require one more pointer per resource.
     *
     * Any given list should contain a fairly small number of resources,
     * and in most cases, the resources are destroyed implicitly by
     * vlc_objres_clear().
     */
    for (;;)
    {
        struct vlc_res *res = *pp;

        assert(res != NULL); /* invalid free? */

        if (match(res->payload, data))
        {
            *pp = res->prev;
            res->release(res->payload);
            free(res);
            return;
        }

        pp = &res->prev;
    }
}",1,1,misc\objres.c,vlc_objres_remove,,false,96,124,vlc_objres_remove,,,7,"void vlc_objres_remove (vlc_object_t*,void*,bool)"
121313,METHOD,misc\objres.c:<global>,TYPE_DECL,"static void dummy_release(void *data)
{
    (void) data;
}",1,1,misc\objres.c,dummy_release,,false,126,129,dummy_release,,,8,void dummy_release (void*)
121321,METHOD,misc\objres.c:<global>,TYPE_DECL,"static bool ptrcmp(void *a, void *b)
{
    return a == b;
}",1,1,misc\objres.c,ptrcmp,,false,131,134,ptrcmp,,,9,"bool ptrcmp (void*,void*)"
121331,METHOD,misc\objres.c:<global>,TYPE_DECL,"void *vlc_obj_malloc(vlc_object_t *obj, size_t size)
{
    void *ptr = vlc_objres_new(size, dummy_release);
    if (likely(ptr != NULL))
        vlc_objres_push(obj, ptr);
    return ptr;
}",1,1,misc\objres.c,vlc_obj_malloc,,false,136,142,vlc_obj_malloc,,,10,"void* vlc_obj_malloc (vlc_object_t*,size_t)"
121354,METHOD,misc\objres.c:<global>,TYPE_DECL,"static void *vlc_obj_alloc_common(vlc_object_t *obj, size_t nmemb, size_t size,
                                  bool do_memset)
{
    size_t tabsize;
    if (mul_overflow(nmemb, size, &tabsize))
    {
        errno = ENOMEM;
        return NULL;
    }

    void *ptr = vlc_objres_new(tabsize, dummy_release);
    if (likely(ptr != NULL))
    {
        if (do_memset)
            memset(ptr, 0, tabsize);
        vlc_objres_push(obj, ptr);
    }
    return ptr;
}",1,1,misc\objres.c,vlc_obj_alloc_common,,false,144,162,vlc_obj_alloc_common,,,11,"void* vlc_obj_alloc_common (vlc_object_t*,size_t,size_t,bool)"
121399,METHOD,misc\objres.c:<global>,TYPE_DECL,"void *vlc_obj_calloc(vlc_object_t *obj, size_t nmemb, size_t size)
{
    return vlc_obj_alloc_common(obj, nmemb, size, true);
}",1,1,misc\objres.c,vlc_obj_calloc,,false,164,167,vlc_obj_calloc,,,12,"void* vlc_obj_calloc (vlc_object_t*,size_t,size_t)"
121412,METHOD,misc\objres.c:<global>,TYPE_DECL,"void vlc_obj_free(vlc_object_t *obj, void *ptr)
{
    vlc_objres_remove(obj, ptr, ptrcmp);
}",1,1,misc\objres.c,vlc_obj_free,,false,169,172,vlc_obj_free,,,13,"void vlc_obj_free (vlc_object_t*,void*)"
121437,METHOD,misc\picture.c:<global>,TYPE_DECL,<global>,1,24,misc\picture.c,misc\picture.c:<global>,,false,1,503,<global>,,,1,
121439,METHOD,misc\picture.c:<global>,TYPE_DECL,"static int AllocatePicture( picture_t *p_pic )
{
    /* Calculate how big the new image should be */
    size_t i_bytes = 0;
    for( int i = 0; i < p_pic->i_planes; i++ )
    {
        const plane_t *p = &p_pic->p[i];

        if( p->i_pitch < 0 || p->i_lines <= 0 ||
            (size_t)p->i_pitch > (SIZE_MAX - i_bytes)/p->i_lines )
        {
            p_pic->i_planes = 0;
            return VLC_ENOMEM;
        }
        i_bytes += p->i_pitch * p->i_lines;
    }

    if( i_bytes >= PICTURE_SW_SIZE_MAX )
    {
        p_pic->i_planes = 0;
        return VLC_ENOMEM;
    }

    i_bytes = (i_bytes + 63) & ~63; /* must be a multiple of 64 */
    uint8_t *p_data = aligned_alloc( 64, i_bytes );
    if( i_bytes > 0 && p_data == NULL )
    {
        p_pic->i_planes = 0;
        return VLC_EGENERIC;
    }

    /* Fill the p_pixels field for each plane */
    p_pic->p[0].p_pixels = p_data;
    for( int i = 1; i < p_pic->i_planes; i++ )
    {
        p_pic->p[i].p_pixels = &p_pic->p[i-1].p_p...",1,19,misc\picture.c,AllocatePicture,,false,50,90,AllocatePicture,,,1,int AllocatePicture (picture_t*)
121623,METHOD,misc\picture.c:<global>,TYPE_DECL,"static void PictureDestroyContext( picture_t *p_picture )
{
    picture_context_t *ctx = p_picture->context;
    if (ctx != NULL)
    {
        ctx->destroy(ctx);
        p_picture->context = NULL;
    }
}",1,1,misc\picture.c,PictureDestroyContext,,false,96,104,PictureDestroyContext,,,2,void PictureDestroyContext (picture_t*)
121649,METHOD,misc\picture.c:<global>,TYPE_DECL,"static void picture_DestroyFromResource( picture_t *p_picture )
{
    free( p_picture->p_sys );
    free( p_picture );
}",1,1,misc\picture.c,picture_DestroyFromResource,,false,110,114,picture_DestroyFromResource,,,3,void picture_DestroyFromResource (picture_t*)
121660,METHOD,misc\picture.c:<global>,TYPE_DECL,"static void picture_Destroy( picture_t *p_picture )
{
    aligned_free( p_picture->p[0].p_pixels );
    free( p_picture );
}",1,1,misc\picture.c,picture_Destroy,,false,120,124,picture_Destroy,,,4,void picture_Destroy (picture_t*)
121675,METHOD,misc\picture.c:<global>,TYPE_DECL,"void picture_Reset( picture_t *p_picture )
{
    /* */
    p_picture->date = VLC_TS_INVALID;
    p_picture->b_force = false;
    p_picture->b_progressive = false;
    p_picture->i_nb_fields = 2;
    p_picture->b_top_field_first = false;
    PictureDestroyContext( p_picture );
}",1,1,misc\picture.c,picture_Reset,,false,129,138,picture_Reset,,,5,void picture_Reset (picture_t*)
121707,METHOD,misc\picture.c:<global>,TYPE_DECL,"static int LCM( int a, int b )
{
    return a * b / GCD( a, b );
}",1,1,misc\picture.c,LCM,,false,143,146,LCM,,,6,"int LCM (int,int)"
121721,METHOD,misc\picture.c:<global>,TYPE_DECL,"int picture_Setup( picture_t *p_picture, const video_format_t *restrict fmt )
{
    /* Store default values */
    p_picture->i_planes = 0;
    for( unsigned i = 0; i < VOUT_MAX_PLANES; i++ )
    {
        plane_t *p = &p_picture->p[i];
        p->p_pixels = NULL;
        p->i_pixel_pitch = 0;
    }

    p_picture->i_nb_fields = 2;

    video_format_Setup( &p_picture->format, fmt->i_chroma, fmt->i_width, fmt->i_height,
                        fmt->i_visible_width, fmt->i_visible_height,
                        fmt->i_sar_num, fmt->i_sar_den );

    const vlc_chroma_description_t *p_dsc =
        vlc_fourcc_GetChromaDescription( p_picture->format.i_chroma );
    if( !p_dsc )
        return VLC_EGENERIC;

    /* We want V (width/height) to respect:
        (V * p_dsc->p[i].w.i_num) % p_dsc->p[i].w.i_den == 0
        (V * p_dsc->p[i].w.i_num/p_dsc->p[i].w.i_den * p_dsc->i_pixel_size) % 16 == 0
       Which is respected if you have
       V % lcm( p_dsc->p[0..planes].w.i_den * 16) == 0
...",1,1,misc\picture.c,picture_Setup,,false,148,206,picture_Setup,,,7,"int picture_Setup (picture_t*,video_format_t*)"
122113,METHOD,misc\picture.c:<global>,TYPE_DECL,"picture_t *picture_NewFromResource( const video_format_t *p_fmt, const picture_resource_t *p_resource )
{
    video_format_t fmt = *p_fmt;

    /* It is needed to be sure all information are filled */
    video_format_Setup( &fmt, p_fmt->i_chroma,
                              p_fmt->i_width, p_fmt->i_height,
                              p_fmt->i_visible_width, p_fmt->i_visible_height,
                              p_fmt->i_sar_num, p_fmt->i_sar_den );
    if( p_fmt->i_x_offset < p_fmt->i_width &&
        p_fmt->i_y_offset < p_fmt->i_height &&
        p_fmt->i_visible_width  > 0 && p_fmt->i_x_offset + p_fmt->i_visible_width  <= p_fmt->i_width &&
        p_fmt->i_visible_height > 0 && p_fmt->i_y_offset + p_fmt->i_visible_height <= p_fmt->i_height )
        video_format_CopyCrop( &fmt, p_fmt );

    /* */
    picture_priv_t *priv = malloc( sizeof (*priv) );
    if( unlikely(priv == NULL) )
        return NULL;

    picture_t *p_picture = &priv->picture;

    memset( p_picture, 0, siz...",1,1,misc\picture.c,picture_NewFromResource,,false,211,273,picture_NewFromResource,,,8,"picture_t picture_NewFromResource (video_format_t*,picture_resource_t*)"
122376,METHOD,misc\picture.c:<global>,TYPE_DECL,"picture_t *picture_NewFromFormat( const video_format_t *p_fmt )
{
    return picture_NewFromResource( p_fmt, NULL );
}",1,1,misc\picture.c,picture_NewFromFormat,,false,275,278,picture_NewFromFormat,,,9,picture_t picture_NewFromFormat (video_format_t*)
122385,METHOD,misc\picture.c:<global>,TYPE_DECL,"picture_t *picture_New( vlc_fourcc_t i_chroma, int i_width, int i_height, int i_sar_num, int i_sar_den )
{
    video_format_t fmt;

    video_format_Init( &fmt, 0 );
    video_format_Setup( &fmt, i_chroma, i_width, i_height,
                        i_width, i_height, i_sar_num, i_sar_den );

    return picture_NewFromFormat( &fmt );
}",1,1,misc\picture.c,picture_New,,false,280,289,picture_New,,,10,"picture_t picture_New (vlc_fourcc_t,int,int,int,int)"
122413,METHOD,misc\picture.c:<global>,TYPE_DECL,"picture_t *picture_Hold( picture_t *p_picture )
{
    assert( p_picture != NULL );

    picture_priv_t *priv = (picture_priv_t *)p_picture;
    uintptr_t refs = atomic_fetch_add( &priv->gc.refs, 1 );
    assert( refs > 0 );
    return p_picture;
}",1,1,misc\picture.c,picture_Hold,,false,295,303,picture_Hold,,,11,picture_t picture_Hold (picture_t*)
122445,METHOD,misc\picture.c:<global>,TYPE_DECL,"void picture_Release( picture_t *p_picture )
{
    assert( p_picture != NULL );

    picture_priv_t *priv = (picture_priv_t *)p_picture;
    uintptr_t refs = atomic_fetch_sub( &priv->gc.refs, 1 );
    assert( refs != 0 );
    if( refs > 1 )
        return;

    PictureDestroyContext( p_picture );
    assert( priv->gc.destroy != NULL );
    priv->gc.destroy( p_picture );
}",1,1,misc\picture.c,picture_Release,,false,305,318,picture_Release,,,12,void picture_Release (picture_t*)
122498,METHOD,misc\picture.c:<global>,TYPE_DECL,"void plane_CopyPixels( plane_t *p_dst, const plane_t *p_src )
{
    const unsigned i_width  = __MIN( p_dst->i_visible_pitch,
                                     p_src->i_visible_pitch );
    const unsigned i_height = __MIN( p_dst->i_lines, p_src->i_lines );

    /* The 2x visible pitch check does two things:
       1) Makes field plane_t's work correctly (see the deinterlacer module)
       2) Moves less data if the pitch and visible pitch differ much.
    */
    if( p_src->i_pitch == p_dst->i_pitch  &&
        p_src->i_pitch < 2*p_src->i_visible_pitch )
    {
        /* There are margins, but with the same width : perfect ! */
        memcpy( p_dst->p_pixels, p_src->p_pixels,
                    p_src->i_pitch * i_height );
    }
    else
    {
        /* We need to proceed line by line */
        uint8_t *p_in = p_src->p_pixels;
        uint8_t *p_out = p_dst->p_pixels;

        assert( p_in );
        assert( p_out );

        for( int i_line = i_height; i_line--; )
        {
  ...",1,1,misc\picture.c,plane_CopyPixels,,false,323,356,plane_CopyPixels,,,13,"void plane_CopyPixels (plane_t*,plane_t*)"
122596,METHOD,misc\picture.c:<global>,TYPE_DECL,"void picture_CopyProperties( picture_t *p_dst, const picture_t *p_src )
{
    p_dst->date = p_src->date;
    p_dst->b_force = p_src->b_force;

    p_dst->b_progressive = p_src->b_progressive;
    p_dst->i_nb_fields = p_src->i_nb_fields;
    p_dst->b_top_field_first = p_src->b_top_field_first;
}",1,1,misc\picture.c,picture_CopyProperties,,false,358,366,picture_CopyProperties,,,14,"void picture_CopyProperties (picture_t*,picture_t*)"
122637,METHOD,misc\picture.c:<global>,TYPE_DECL,"void picture_CopyPixels( picture_t *p_dst, const picture_t *p_src )
{
    for( int i = 0; i < p_src->i_planes ; i++ )
        plane_CopyPixels( p_dst->p+i, p_src->p+i );

    assert( p_dst->context == NULL );

    if( p_src->context != NULL )
        p_dst->context = p_src->context->copy( p_src->context );
}",1,1,misc\picture.c,picture_CopyPixels,,false,368,377,picture_CopyPixels,,,15,"void picture_CopyPixels (picture_t*,picture_t*)"
122693,METHOD,misc\picture.c:<global>,TYPE_DECL,"void picture_Copy( picture_t *p_dst, const picture_t *p_src )
{
    picture_CopyPixels( p_dst, p_src );
    picture_CopyProperties( p_dst, p_src );
}",1,1,misc\picture.c,picture_Copy,,false,379,383,picture_Copy,,,16,"void picture_Copy (picture_t*,picture_t*)"
122705,METHOD,misc\picture.c:<global>,TYPE_DECL,"static void picture_DestroyClone(picture_t *clone)
{
    picture_t *picture = ((picture_priv_t *)clone)->gc.opaque;

    free(clone);
    picture_Release(picture);
}",1,1,misc\picture.c,picture_DestroyClone,,false,385,391,picture_DestroyClone,,,17,void picture_DestroyClone (picture_t*)
122724,METHOD,misc\picture.c:<global>,TYPE_DECL,"picture_t *picture_Clone(picture_t *picture)
{
    /* TODO: merge common code with picture_pool_ClonePicture(). */
    picture_resource_t res = {
        .p_sys = picture->p_sys,
        .pf_destroy = picture_DestroyClone,
    };

    for (int i = 0; i < picture->i_planes; i++) {
        res.p[i].p_pixels = picture->p[i].p_pixels;
        res.p[i].i_lines = picture->p[i].i_lines;
        res.p[i].i_pitch = picture->p[i].i_pitch;
    }

    picture_t *clone = picture_NewFromResource(&picture->format, &res);
    if (likely(clone != NULL)) {
        ((picture_priv_t *)clone)->gc.opaque = picture;
        picture_Hold(picture);

        if (picture->context != NULL)
            clone->context = picture->context->copy(picture->context);
    }
    return clone;
}",1,1,misc\picture.c,picture_Clone,,false,393,416,picture_Clone,,,18,picture_t picture_Clone (picture_t*)
122851,METHOD,misc\picture.c:<global>,TYPE_DECL,"int picture_Export( vlc_object_t *p_obj,
                    block_t **pp_image,
                    video_format_t *p_fmt,
                    picture_t *p_picture,
                    vlc_fourcc_t i_format,
                    int i_override_width, int i_override_height )
{
    /* */
    video_format_t fmt_in = p_picture->format;
    if( fmt_in.i_sar_num <= 0 || fmt_in.i_sar_den <= 0 )
    {
        fmt_in.i_sar_num =
        fmt_in.i_sar_den = 1;
    }

    /* */
    video_format_t fmt_out;
    memset( &fmt_out, 0, sizeof(fmt_out) );
    fmt_out.i_sar_num =
    fmt_out.i_sar_den = 1;
    fmt_out.i_chroma  = i_format;

    /* compute original width/height */
    unsigned int i_width, i_height, i_original_width, i_original_height;
    if( fmt_in.i_visible_width > 0 && fmt_in.i_visible_height > 0 )
    {
        i_width = fmt_in.i_visible_width;
        i_height = fmt_in.i_visible_height;
    }
    else
    {
        i_width = fmt_in.i_width;
        i_height = fmt_in.i_height;
    ...",1,1,misc\picture.c,picture_Export,,false,421,503,picture_Export,,,19,"int picture_Export (vlc_object_t*,block_t**,video_format_t*,picture_t*,vlc_fourcc_t,int,int)"
123145,METHOD,misc\picture.h:<global>,TYPE_DECL,<global>,1,17,misc\picture.h,misc\picture.h:<global>,,false,1,33,<global>,,,1,
123151,METHOD,picture_priv_t.gc,TYPE_DECL,void (*destroy)(picture_t *);,14,36,misc\picture.h,picture_priv_t.gc.destroy,,false,30,30,destroy,,,2,void picture_priv_t.gc.destroy (picture_t*)
123170,METHOD,misc\picture_fifo.c:<global>,TYPE_DECL,<global>,1,2,misc\picture_fifo.c,misc\picture_fifo.c:<global>,,false,1,147,<global>,,,1,
123176,METHOD,misc\picture_fifo.c:<global>,TYPE_DECL,"static void PictureFifoReset(picture_fifo_t *fifo)
{
    fifo->first    = NULL;
    fifo->last_ptr = &fifo->first;
}",1,1,misc\picture_fifo.c,PictureFifoReset,,false,46,50,PictureFifoReset,,,2,void PictureFifoReset (picture_fifo_t*)
123194,METHOD,misc\picture_fifo.c:<global>,TYPE_DECL,"static void PictureFifoPush(picture_fifo_t *fifo, picture_t *picture)
{
    assert(!picture->p_next);
    *fifo->last_ptr = picture;
    fifo->last_ptr  = &picture->p_next;
}",1,1,misc\picture_fifo.c,PictureFifoPush,,false,51,56,PictureFifoPush,,,3,"void PictureFifoPush (picture_fifo_t*,picture_t*)"
123219,METHOD,misc\picture_fifo.c:<global>,TYPE_DECL,"static picture_t *PictureFifoPop(picture_fifo_t *fifo)
{
    picture_t *picture = fifo->first;

    if (picture) {
        fifo->first = picture->p_next;
        if (!fifo->first)
            fifo->last_ptr = &fifo->first;
        picture->p_next = NULL;
    }
    return picture;
}",1,1,misc\picture_fifo.c,PictureFifoPop,,false,57,68,PictureFifoPop,,,4,picture_t PictureFifoPop (picture_fifo_t*)
123261,METHOD,misc\picture_fifo.c:<global>,TYPE_DECL,"picture_fifo_t *picture_fifo_New(void)
{
    picture_fifo_t *fifo = malloc(sizeof(*fifo));
    if (!fifo)
        return NULL;

    vlc_mutex_init(&fifo->lock);
    PictureFifoReset(fifo);
    return fifo;
}",1,1,misc\picture_fifo.c,picture_fifo_New,,false,70,79,picture_fifo_New,,,5,picture_fifo_t picture_fifo_New (void)
123288,METHOD,misc\picture_fifo.c:<global>,TYPE_DECL,"void picture_fifo_Push(picture_fifo_t *fifo, picture_t *picture)
{
    vlc_mutex_lock(&fifo->lock);
    PictureFifoPush(fifo, picture);
    vlc_mutex_unlock(&fifo->lock);
}",1,1,misc\picture_fifo.c,picture_fifo_Push,,false,81,86,picture_fifo_Push,,,6,"void picture_fifo_Push (picture_fifo_t*,picture_t*)"
123307,METHOD,misc\picture_fifo.c:<global>,TYPE_DECL,"picture_t *picture_fifo_Pop(picture_fifo_t *fifo)
{
    vlc_mutex_lock(&fifo->lock);
    picture_t *picture = PictureFifoPop(fifo);
    vlc_mutex_unlock(&fifo->lock);

    return picture;
}",1,1,misc\picture_fifo.c,picture_fifo_Pop,,false,87,94,picture_fifo_Pop,,,7,picture_t picture_fifo_Pop (picture_fifo_t*)
123329,METHOD,misc\picture_fifo.c:<global>,TYPE_DECL,"picture_t *picture_fifo_Peek(picture_fifo_t *fifo)
{
    vlc_mutex_lock(&fifo->lock);
    picture_t *picture = fifo->first;
    if (picture)
        picture_Hold(picture);
    vlc_mutex_unlock(&fifo->lock);

    return picture;
}",1,1,misc\picture_fifo.c,picture_fifo_Peek,,false,95,104,picture_fifo_Peek,,,8,picture_t picture_fifo_Peek (picture_fifo_t*)
123357,METHOD,misc\picture_fifo.c:<global>,TYPE_DECL,"void picture_fifo_Flush(picture_fifo_t *fifo, mtime_t date, bool flush_before)
{
    picture_t *picture;

    vlc_mutex_lock(&fifo->lock);

    picture = fifo->first;
    PictureFifoReset(fifo);

    picture_fifo_t tmp;
    PictureFifoReset(&tmp);

    while (picture) {
        picture_t *next = picture->p_next;

        picture->p_next = NULL;
        if (( flush_before && picture->date <= date) ||
            (!flush_before && picture->date >= date))
            PictureFifoPush(&tmp, picture);
        else
            PictureFifoPush(fifo, picture);
        picture = next;
    }
    vlc_mutex_unlock(&fifo->lock);

    while ((picture = PictureFifoPop(&tmp)) != NULL)
        picture_Release(picture);
}",1,1,misc\picture_fifo.c,picture_fifo_Flush,,false,105,132,picture_fifo_Flush,,,9,"void picture_fifo_Flush (picture_fifo_t*,mtime_t,bool)"
123440,METHOD,misc\picture_fifo.c:<global>,TYPE_DECL,"void picture_fifo_OffsetDate(picture_fifo_t *fifo, mtime_t delta)
{
    vlc_mutex_lock(&fifo->lock);
    for (picture_t *picture = fifo->first; picture != NULL;) {
        picture->date += delta;
        picture = picture->p_next;
    }
    vlc_mutex_unlock(&fifo->lock);
}",1,1,misc\picture_fifo.c,picture_fifo_OffsetDate,,false,133,141,picture_fifo_OffsetDate,,,10,"void picture_fifo_OffsetDate (picture_fifo_t*,mtime_t)"
123478,METHOD,misc\picture_fifo.c:<global>,TYPE_DECL,"void picture_fifo_Delete(picture_fifo_t *fifo)
{
    picture_fifo_Flush(fifo, INT64_MAX, true);
    vlc_mutex_destroy(&fifo->lock);
    free(fifo);
}",1,1,misc\picture_fifo.c,picture_fifo_Delete,,false,142,147,picture_fifo_Delete,,,11,void picture_fifo_Delete (picture_fifo_t*)
123513,METHOD,misc\picture_pool.c:<global>,TYPE_DECL,<global>,1,24,misc\picture_pool.c,misc\picture_pool.c:<global>,,false,1,325,<global>,,,1,
123517,METHOD,picture_pool_t,TYPE_DECL,int       (*pic_lock)(picture_t *);,15,38,misc\picture_pool.c,picture_pool_t.pic_lock,,false,42,42,pic_lock,,,1,int picture_pool_t.pic_lock (picture_t*)
123522,METHOD,picture_pool_t,TYPE_DECL,void      (*pic_unlock)(picture_t *);,15,40,misc\picture_pool.c,picture_pool_t.pic_unlock,,false,43,43,pic_unlock,,,2,void picture_pool_t.pic_unlock (picture_t*)
123534,METHOD,<empty>,<empty>,<empty>,1,,misc\picture_pool.c,picture_pool_t:<clinit>,,false,41,,<clinit>,,,10,
123539,METHOD,misc\picture_pool.c:<global>,TYPE_DECL,"static void picture_pool_Destroy(picture_pool_t *pool)
{
    if (atomic_fetch_sub(&pool->refs, 1) != 1)
        return;

    vlc_cond_destroy(&pool->wait);
    vlc_mutex_destroy(&pool->lock);
    aligned_free(pool);
}",1,1,misc\picture_pool.c,picture_pool_Destroy,,false,54,62,picture_pool_Destroy,,,3,void picture_pool_Destroy (picture_pool_t*)
123567,METHOD,misc\picture_pool.c:<global>,TYPE_DECL,"void picture_pool_Release(picture_pool_t *pool)
{
    for (unsigned i = 0; i < pool->picture_count; i++)
        picture_Release(pool->picture[i]);
    picture_pool_Destroy(pool);
}",1,1,misc\picture_pool.c,picture_pool_Release,,false,64,69,picture_pool_Release,,,4,void picture_pool_Release (picture_pool_t*)
123593,METHOD,misc\picture_pool.c:<global>,TYPE_DECL,"static void picture_pool_ReleasePicture(picture_t *clone)
{
    picture_priv_t *priv = (picture_priv_t *)clone;
    uintptr_t sys = (uintptr_t)priv->gc.opaque;
    picture_pool_t *pool = (void *)(sys & ~(POOL_MAX - 1));
    unsigned offset = sys & (POOL_MAX - 1);
    picture_t *picture = pool->picture[offset];

    free(clone);

    if (pool->pic_unlock != NULL)
        pool->pic_unlock(picture);
    picture_Release(picture);

    vlc_mutex_lock(&pool->lock);
    assert(!(pool->available & (1ULL << offset)));
    pool->available |= 1ULL << offset;
    vlc_cond_signal(&pool->wait);
    vlc_mutex_unlock(&pool->lock);

    picture_pool_Destroy(pool);
}",1,44,misc\picture_pool.c,picture_pool_ReleasePicture,,false,71,92,picture_pool_ReleasePicture,,,5,void picture_pool_ReleasePicture (picture_t*)
123700,METHOD,misc\picture_pool.c:<global>,TYPE_DECL,"static picture_t *picture_pool_ClonePicture(picture_pool_t *pool,
                                            unsigned offset)
{
    picture_t *picture = pool->picture[offset];
    uintptr_t sys = ((uintptr_t)pool) + offset;
    picture_resource_t res = {
        .p_sys = picture->p_sys,
        .pf_destroy = picture_pool_ReleasePicture,
    };

    for (int i = 0; i < picture->i_planes; i++) {
        res.p[i].p_pixels = picture->p[i].p_pixels;
        res.p[i].i_lines = picture->p[i].i_lines;
        res.p[i].i_pitch = picture->p[i].i_pitch;
    }

    picture_t *clone = picture_NewFromResource(&picture->format, &res);
    if (likely(clone != NULL)) {
        ((picture_priv_t *)clone)->gc.opaque = (void *)sys;
        picture_Hold(picture);
    }
    return clone;
}",1,1,misc\picture_pool.c,picture_pool_ClonePicture,,false,94,116,picture_pool_ClonePicture,,,6,"picture_t picture_pool_ClonePicture (picture_pool_t*,unsigned)"
123826,METHOD,misc\picture_pool.c:<global>,TYPE_DECL,"picture_pool_t *picture_pool_NewExtended(const picture_pool_configuration_t *cfg)
{
    if (unlikely(cfg->picture_count > POOL_MAX))
        return NULL;

    picture_pool_t *pool;
    size_t size = sizeof (*pool) + cfg->picture_count * sizeof (picture_t *);

    size += (-size) & (POOL_MAX - 1);
    pool = aligned_alloc(POOL_MAX, size);
    if (unlikely(pool == NULL))
        return NULL;

    pool->pic_lock   = cfg->lock;
    pool->pic_unlock = cfg->unlock;
    vlc_mutex_init(&pool->lock);
    vlc_cond_init(&pool->wait);
    if (cfg->picture_count == POOL_MAX)
        pool->available = ~0ULL;
    else
        pool->available = (1ULL << cfg->picture_count) - 1;
    atomic_init(&pool->refs,  1);
    pool->picture_count = cfg->picture_count;
    memcpy(pool->picture, cfg->picture,
           cfg->picture_count * sizeof (picture_t *));
    pool->canceled = false;
    return pool;
}",1,38,misc\picture_pool.c,picture_pool_NewExtended,,false,118,145,picture_pool_NewExtended,,,7,picture_pool_t picture_pool_NewExtended (picture_pool_configuration_t*)
123979,METHOD,misc\picture_pool.c:<global>,TYPE_DECL,"picture_pool_t *picture_pool_New(unsigned count, picture_t *const *tab)
{
    picture_pool_configuration_t cfg = {
        .picture_count = count,
        .picture = tab,
    };

    return picture_pool_NewExtended(&cfg);
}",1,1,misc\picture_pool.c,picture_pool_New,,false,147,155,picture_pool_New,,,8,"picture_pool_t picture_pool_New (unsigned,picture_t**)"
124001,METHOD,misc\picture_pool.c:<global>,TYPE_DECL,"picture_pool_t *picture_pool_NewFromFormat(const video_format_t *fmt,
                                           unsigned count)
{
    picture_t *picture[count ? count : 1];
    unsigned i;

    for (i = 0; i < count; i++) {
        picture[i] = picture_NewFromFormat(fmt);
        if (picture[i] == NULL)
            goto error;
    }

    picture_pool_t *pool = picture_pool_New(count, picture);
    if (!pool)
        goto error;

    return pool;

error:
    while (i > 0)
        picture_Release(picture[--i]);
    return NULL;
}",1,1,misc\picture_pool.c,picture_pool_NewFromFormat,,false,157,179,picture_pool_NewFromFormat,,,9,"picture_pool_t picture_pool_NewFromFormat (video_format_t*,unsigned)"
124059,METHOD,misc\picture_pool.c:<global>,TYPE_DECL,"picture_pool_t *picture_pool_Reserve(picture_pool_t *master, unsigned count)
{
    picture_t *picture[count ? count : 1];
    unsigned i;

    for (i = 0; i < count; i++) {
        picture[i] = picture_pool_Get(master);
        if (picture[i] == NULL)
            goto error;
    }

    picture_pool_t *pool = picture_pool_New(count, picture);
    if (!pool)
        goto error;

    return pool;

error:
    while (i > 0)
        picture_Release(picture[--i]);
    return NULL;
}",1,1,misc\picture_pool.c,picture_pool_Reserve,,false,181,202,picture_pool_Reserve,,,10,"picture_pool_t picture_pool_Reserve (picture_pool_t*,unsigned)"
124117,METHOD,misc\picture_pool.c:<global>,TYPE_DECL,"static int fnsll(unsigned long long x, unsigned i)
{
    if (i >= CHAR_BIT * sizeof (x))
        return 0;
    return ffsll(x & ~((1ULL << i) - 1));
}",1,1,misc\picture_pool.c,fnsll,,false,205,210,fnsll,,,11,"int fnsll (long long unsigned,unsigned)"
124143,METHOD,misc\picture_pool.c:<global>,TYPE_DECL,"picture_t *picture_pool_Get(picture_pool_t *pool)
{
    vlc_mutex_lock(&pool->lock);
    assert(pool->refs > 0);

    if (pool->canceled)
    {
        vlc_mutex_unlock(&pool->lock);
        return NULL;
    }

    for (unsigned i = ffsll(pool->available); i; i = fnsll(pool->available, i))
    {
        pool->available &= ~(1ULL << (i - 1));
        vlc_mutex_unlock(&pool->lock);

        picture_t *picture = pool->picture[i - 1];

        if (pool->pic_lock != NULL && pool->pic_lock(picture) != VLC_SUCCESS) {
            vlc_mutex_lock(&pool->lock);
            pool->available |= 1ULL << (i - 1);
            continue;
        }

        picture_t *clone = picture_pool_ClonePicture(pool, i - 1);
        if (clone != NULL) {
            assert(clone->p_next == NULL);
            atomic_fetch_add(&pool->refs, 1);
        }
        return clone;
    }

    vlc_mutex_unlock(&pool->lock);
    return NULL;
}",1,1,misc\picture_pool.c,picture_pool_Get,,false,212,246,picture_pool_Get,,,12,picture_t picture_pool_Get (picture_pool_t*)
124278,METHOD,misc\picture_pool.c:<global>,TYPE_DECL,"picture_t *picture_pool_Wait(picture_pool_t *pool)
{
    unsigned i;

    vlc_mutex_lock(&pool->lock);
    assert(pool->refs > 0);

    while (pool->available == 0)
    {
        if (pool->canceled)
        {
            vlc_mutex_unlock(&pool->lock);
            return NULL;
        }
        vlc_cond_wait(&pool->wait, &pool->lock);
    }

    i = ffsll(pool->available);
    assert(i > 0);
    pool->available &= ~(1ULL << (i - 1));
    vlc_mutex_unlock(&pool->lock);

    picture_t *picture = pool->picture[i - 1];

    if (pool->pic_lock != NULL && pool->pic_lock(picture) != VLC_SUCCESS) {
        vlc_mutex_lock(&pool->lock);
        pool->available |= 1ULL << (i - 1);
        vlc_cond_signal(&pool->wait);
        vlc_mutex_unlock(&pool->lock);
        return NULL;
    }

    picture_t *clone = picture_pool_ClonePicture(pool, i - 1);
    if (clone != NULL) {
        assert(clone->p_next == NULL);
        atomic_fetch_add(&pool->refs, 1);
    }
    return clone;
}",1,1,misc\picture_pool.c,picture_pool_Wait,,false,248,286,picture_pool_Wait,,,13,picture_t picture_pool_Wait (picture_pool_t*)
124426,METHOD,misc\picture_pool.c:<global>,TYPE_DECL,"void picture_pool_Cancel(picture_pool_t *pool, bool canceled)
{
    vlc_mutex_lock(&pool->lock);
    assert(pool->refs > 0);

    pool->canceled = canceled;
    if (canceled)
        vlc_cond_broadcast(&pool->wait);
    vlc_mutex_unlock(&pool->lock);
}",1,1,misc\picture_pool.c,picture_pool_Cancel,,false,288,297,picture_pool_Cancel,,,14,"void picture_pool_Cancel (picture_pool_t*,bool)"
124461,METHOD,misc\picture_pool.c:<global>,TYPE_DECL,"bool picture_pool_OwnsPic(picture_pool_t *pool, picture_t *pic)
{
    picture_priv_t *priv = (picture_priv_t *)pic;

    while (priv->gc.destroy != picture_pool_ReleasePicture) {
        pic = priv->gc.opaque;
        priv = (picture_priv_t *)pic;
    }

    uintptr_t sys = (uintptr_t)priv->gc.opaque;
    picture_pool_t *picpool = (void *)(sys & ~(POOL_MAX - 1));
    return pool == picpool;
}",1,47,misc\picture_pool.c,picture_pool_OwnsPic,,false,299,311,picture_pool_OwnsPic,,,15,"bool picture_pool_OwnsPic (picture_pool_t*,picture_t*)"
124524,METHOD,misc\picture_pool.c:<global>,TYPE_DECL,"unsigned picture_pool_GetSize(const picture_pool_t *pool)
{
    return pool->picture_count;
}",1,1,misc\picture_pool.c,picture_pool_GetSize,,false,313,316,picture_pool_GetSize,,,16,unsigned picture_pool_GetSize (picture_pool_t*)
124533,METHOD,misc\picture_pool.c:<global>,TYPE_DECL,"void picture_pool_Enum(picture_pool_t *pool, void (*cb)(void *, picture_t *),
                       void *opaque)
{
    /* NOTE: So far, the pictures table cannot change after the pool is created
     * so there is no need to lock the pool mutex here. */
    for (unsigned i = 0; i < pool->picture_count; i++)
        cb(opaque, pool->picture[i]);
}",1,1,misc\picture_pool.c,picture_pool_Enum,,false,318,325,picture_pool_Enum,,,17,"void picture_pool_Enum (picture_pool_t*,void,void*)"
124573,METHOD,misc\probe.c:<global>,TYPE_DECL,<global>,1,25,misc\probe.c,misc\probe.c:<global>,,false,1,54,<global>,,,1,
124575,METHOD,misc\probe.c:<global>,TYPE_DECL,"void *vlc_probe (vlc_object_t *obj,
                 const char *capability, size_t *restrict pcount)
{
    vlc_probe_t *probe = vlc_custom_create (obj, sizeof(*probe), ""probe"");
    if (unlikely(probe == NULL))
    {
        *pcount = 0;
        return NULL;
    }
    probe->list = NULL;
    probe->count = 0;

    module_t *mod = module_need (probe, capability, NULL, false);
    if (mod != NULL)
    {
        msg_Warn (probe, ""probing halted"");
        module_unneed (probe, mod);
    }

    void *ret = probe->list;
    *pcount = probe->count;
    vlc_object_release (probe);
    return ret;
}",1,25,misc\probe.c,vlc_probe,,false,31,54,vlc_probe,,,1,"void* vlc_probe (vlc_object_t*,char*,size_t*)"
124662,METHOD,misc\rand.c:<global>,TYPE_DECL,<global>,1,1,misc\rand.c,misc\rand.c:<global>,,false,1,107,<global>,,,1,
124668,METHOD,<empty>,<empty>,<empty>,1,,misc\rand.c,rand48:<clinit>,,false,29,,<clinit>,,,4,
124684,METHOD,misc\rand.c:<global>,TYPE_DECL,"static void init_rand48 (void)
{
    if (!rand48.init)
    {
        vlc_rand_bytes (rand48.subi, sizeof (rand48.subi));
        rand48.init = true;
#if 0 // short would be more than 16-bits ?
        for (unsigned i = 0; i < 3; i++)
            subi[i] &= 0xffff;
#endif
    }
}",1,1,misc\rand.c,init_rand48,,false,36,47,init_rand48,,,4,void init_rand48 (void)
124708,METHOD,misc\rand.c:<global>,TYPE_DECL,"double vlc_drand48 (void)
{
    double ret;

    vlc_mutex_lock (&rand48.lock);
    init_rand48 ();
    ret = erand48 (rand48.subi);
    vlc_mutex_unlock (&rand48.lock);
    return ret;
}",1,1,misc\rand.c,vlc_drand48,,false,58,67,vlc_drand48,,,5,double vlc_drand48 (void)
124733,METHOD,misc\rand.c:<global>,TYPE_DECL,"long vlc_lrand48 (void)
{
    long ret;

    vlc_mutex_lock (&rand48.lock);
    init_rand48 ();
    ret = nrand48 (rand48.subi);
    vlc_mutex_unlock (&rand48.lock);
    return ret;
}",1,1,misc\rand.c,vlc_lrand48,,false,78,87,vlc_lrand48,,,6,long vlc_lrand48 (void)
124758,METHOD,misc\rand.c:<global>,TYPE_DECL,"long vlc_mrand48 (void)
{
    long ret;

    vlc_mutex_lock (&rand48.lock);
    init_rand48 ();
    ret = jrand48 (rand48.subi);
    vlc_mutex_unlock (&rand48.lock);
    return ret;
}",1,1,misc\rand.c,vlc_mrand48,,false,98,107,vlc_mrand48,,,7,long vlc_mrand48 (void)
124802,METHOD,misc\renderer_discovery.c:<global>,TYPE_DECL,<global>,1,1,misc\renderer_discovery.c,misc\renderer_discovery.c:<global>,,false,1,270,<global>,,,1,
124812,METHOD,misc\renderer_discovery.c:<global>,TYPE_DECL,"static void
item_free(vlc_renderer_item_t *p_item)
{
    free(p_item->psz_name);
    free(p_item->psz_type);
    free(p_item->psz_sout);
    free(p_item->psz_icon_uri);
    free(p_item->psz_demux_filter);
    free(p_item);
}",1,1,misc\renderer_discovery.c,item_free,,false,45,54,item_free,,,2,void item_free (vlc_renderer_item_t*)
124839,METHOD,misc\renderer_discovery.c:<global>,TYPE_DECL,"vlc_renderer_item_t *
vlc_renderer_item_new(const char *psz_type, const char *psz_name,
                      const char *psz_uri, const char *psz_extra_sout,
                      const char *psz_demux_filter, const char *psz_icon_uri,
                      int i_flags)
{
    assert(psz_uri != NULL);
    vlc_renderer_item_t *p_item = NULL;
    vlc_url_t url;
    vlc_UrlParse(&url, psz_uri);

    if (url.psz_protocol == NULL || url.psz_host == NULL)
        goto error;

    p_item = calloc(1, sizeof(vlc_renderer_item_t));
    if (unlikely(p_item == NULL))
        goto error;

    if ((p_item->psz_type = strdup(psz_type)) == NULL)
        goto error;

    if (psz_name != NULL)
        p_item->psz_name = strdup(psz_name);
    else if (asprintf(&p_item->psz_name, ""%s (%s)"", url.psz_protocol,
                      url.psz_host) == -1)
        p_item->psz_name = NULL;
    if (p_item->psz_name == NULL)
        goto error;

    if (asprintf(&p_item->psz_sout, ""%s{ip=%s,port=%d%s%s}"",
     ...",1,1,misc\renderer_discovery.c,vlc_renderer_item_new,,false,56,107,vlc_renderer_item_new,,,3,"vlc_renderer_item_t vlc_renderer_item_new (char*,char*,char*,char*,char*,char*,int)"
125032,METHOD,misc\renderer_discovery.c:<global>,TYPE_DECL,"const char *
vlc_renderer_item_name(const vlc_renderer_item_t *p_item)
{
    assert(p_item != NULL);

    return p_item->psz_name;
}",1,1,misc\renderer_discovery.c,vlc_renderer_item_name,,false,109,115,vlc_renderer_item_name,,,4,const char* vlc_renderer_item_name (vlc_renderer_item_t*)
125045,METHOD,misc\renderer_discovery.c:<global>,TYPE_DECL,"const char *
vlc_renderer_item_type(const vlc_renderer_item_t *p_item)
{
    assert(p_item != NULL);

    return p_item->psz_type;
}",1,1,misc\renderer_discovery.c,vlc_renderer_item_type,,false,117,123,vlc_renderer_item_type,,,5,const char* vlc_renderer_item_type (vlc_renderer_item_t*)
125058,METHOD,misc\renderer_discovery.c:<global>,TYPE_DECL,"const char *
vlc_renderer_item_sout(const vlc_renderer_item_t *p_item)
{
    assert(p_item != NULL);

    return p_item->psz_sout;
}",1,1,misc\renderer_discovery.c,vlc_renderer_item_sout,,false,125,131,vlc_renderer_item_sout,,,6,const char* vlc_renderer_item_sout (vlc_renderer_item_t*)
125071,METHOD,misc\renderer_discovery.c:<global>,TYPE_DECL,"const char *
vlc_renderer_item_icon_uri(const vlc_renderer_item_t *p_item)
{
    assert(p_item != NULL);

    return p_item->psz_icon_uri;
}",1,1,misc\renderer_discovery.c,vlc_renderer_item_icon_uri,,false,133,139,vlc_renderer_item_icon_uri,,,7,const char* vlc_renderer_item_icon_uri (vlc_renderer_item_t*)
125084,METHOD,misc\renderer_discovery.c:<global>,TYPE_DECL,"const char *
vlc_renderer_item_demux_filter(const vlc_renderer_item_t *p_item)
{
    assert(p_item != NULL);

    return p_item->psz_demux_filter;
}",1,1,misc\renderer_discovery.c,vlc_renderer_item_demux_filter,,false,141,147,vlc_renderer_item_demux_filter,,,8,const char* vlc_renderer_item_demux_filter (vlc_renderer_item_t*)
125097,METHOD,misc\renderer_discovery.c:<global>,TYPE_DECL,"int
vlc_renderer_item_flags(const vlc_renderer_item_t *p_item)
{
    assert(p_item != NULL);

    return p_item->i_flags;
}",1,1,misc\renderer_discovery.c,vlc_renderer_item_flags,,false,149,155,vlc_renderer_item_flags,,,9,int vlc_renderer_item_flags (vlc_renderer_item_t*)
125110,METHOD,misc\renderer_discovery.c:<global>,TYPE_DECL,"vlc_renderer_item_t *
vlc_renderer_item_hold(vlc_renderer_item_t *p_item)
{
    assert(p_item != NULL);

    atomic_fetch_add(&p_item->refs, 1);
    return p_item;
}",1,1,misc\renderer_discovery.c,vlc_renderer_item_hold,,false,157,164,vlc_renderer_item_hold,,,10,vlc_renderer_item_t vlc_renderer_item_hold (vlc_renderer_item_t*)
125127,METHOD,misc\renderer_discovery.c:<global>,TYPE_DECL,"void
vlc_renderer_item_release(vlc_renderer_item_t *p_item)
{
    assert(p_item != NULL);

    int refs = atomic_fetch_sub(&p_item->refs, 1);
    assert(refs != 0 );
    if( refs != 1 )
        return;
    item_free(p_item);
}",1,1,misc\renderer_discovery.c,vlc_renderer_item_release,,false,166,176,vlc_renderer_item_release,,,11,void vlc_renderer_item_release (vlc_renderer_item_t*)
125160,METHOD,misc\renderer_discovery.c:<global>,TYPE_DECL,"int
vlc_rd_probe_add(vlc_probe_t *probe, const char *psz_name,
                 const char *psz_longname)
{
    struct vlc_rd_probe names = { strdup(psz_name), strdup(psz_longname) };

    if (unlikely(names.psz_name == NULL || names.psz_longname == NULL
                 || vlc_probe_add(probe, &names, sizeof(names))))
    {
        free(names.psz_name);
        free(names.psz_longname);
        return VLC_ENOMEM;
    }
    return VLC_PROBE_CONTINUE;
}",1,1,misc\renderer_discovery.c,vlc_rd_probe_add,,false,184,198,vlc_rd_probe_add,,,13,"int vlc_rd_probe_add (vlc_probe_t*,char*,char*)"
125208,METHOD,misc\renderer_discovery.c:<global>,TYPE_DECL,"int
vlc_rd_get_names(vlc_object_t *p_obj, char ***pppsz_names,
                 char ***pppsz_longnames)
{
    size_t i_count;
    struct vlc_rd_probe *p_tab = vlc_probe(p_obj, ""renderer probe"", &i_count);

    if (i_count == 0)
    {
        free(p_tab);
        return VLC_EGENERIC;
    }

    char **ppsz_names = vlc_alloc(i_count + 1, sizeof(char *));
    char **ppsz_longnames = vlc_alloc(i_count + 1, sizeof(char *));

    if (unlikely(ppsz_names == NULL || ppsz_longnames == NULL))
    {
        free(ppsz_names);
        free(ppsz_longnames);
        free(p_tab);
        return VLC_EGENERIC;
    }

    for (size_t i = 0; i < i_count; i++)
    {
        ppsz_names[i] = p_tab[i].psz_name;
        ppsz_longnames[i] = p_tab[i].psz_longname;
    }
    ppsz_names[i_count] = ppsz_longnames[i_count] = NULL;
    free(p_tab);
    *pppsz_names = ppsz_names;
    *pppsz_longnames = ppsz_longnames;
    return VLC_SUCCESS;
}",1,1,misc\renderer_discovery.c,vlc_rd_get_names,,false,201,235,vlc_rd_get_names,,,14,"int vlc_rd_get_names (vlc_object_t*,char***,char***)"
125320,METHOD,misc\renderer_discovery.c:<global>,TYPE_DECL,"void vlc_rd_release(vlc_renderer_discovery_t *p_rd)
{
    module_unneed(p_rd, p_rd->p_module);
    config_ChainDestroy(p_rd->p_cfg);
    free(p_rd->psz_name);
    vlc_object_release(p_rd);
}",1,1,misc\renderer_discovery.c,vlc_rd_release,,false,237,243,vlc_rd_release,,,15,void vlc_rd_release (vlc_renderer_discovery_t*)
125340,METHOD,misc\renderer_discovery.c:<global>,TYPE_DECL,"vlc_renderer_discovery_t *
vlc_rd_new(vlc_object_t *p_obj, const char *psz_name,
           const struct vlc_renderer_discovery_owner *restrict owner)
{
    vlc_renderer_discovery_t *p_rd;

    p_rd = vlc_custom_create(p_obj, sizeof(*p_rd), ""renderer discovery"");
    if(!p_rd)
        return NULL;
    free(config_ChainCreate(&p_rd->psz_name, &p_rd->p_cfg, psz_name));

    p_rd->owner = *owner;
    p_rd->p_module = module_need(p_rd, ""renderer_discovery"",
                                 p_rd->psz_name, true);
    if (p_rd->p_module == NULL)
    {
        msg_Err(p_rd, ""no suitable renderer discovery module for '%s'"",
            psz_name);
        free(p_rd->psz_name);
        config_ChainDestroy(p_rd->p_cfg);
        vlc_object_release(p_rd);
        p_rd = NULL;
    }

    return p_rd;
}",1,1,misc\renderer_discovery.c,vlc_rd_new,,false,245,270,vlc_rd_new,,,16,"vlc_renderer_discovery_t vlc_rd_new (vlc_object_t*,char*,vlc_renderer_discovery_owner*)"
125433,METHOD,misc\subpicture.c:<global>,TYPE_DECL,<global>,1,28,misc\subpicture.c,misc\subpicture.c:<global>,,false,1,322,<global>,,,1,
125438,METHOD,misc\subpicture.c:<global>,TYPE_DECL,"subpicture_t *subpicture_New( const subpicture_updater_t *p_upd )
{
    subpicture_t *p_subpic = calloc( 1, sizeof(*p_subpic) );
    if( !p_subpic )
        return NULL;

    p_subpic->i_order    = 0;
    p_subpic->b_absolute = true;
    p_subpic->b_fade     = false;
    p_subpic->b_subtitle = false;
    p_subpic->i_alpha    = 0xFF;
    p_subpic->p_region   = NULL;

    if( p_upd )
    {
        subpicture_private_t *p_private = malloc( sizeof(*p_private) );
        if( !p_private )
        {
            free( p_subpic );
            return NULL;
        }
        video_format_Init( &p_private->src, 0 );
        video_format_Init( &p_private->dst, 0 );

        p_subpic->updater   = *p_upd;
        p_subpic->p_private = p_private;
    }
    else
    {
        p_subpic->p_private = NULL;

        p_subpic->updater.pf_validate = NULL;
        p_subpic->updater.pf_update   = NULL;
        p_subpic->updater.pf_destroy  = NULL;
        p_subpic->updater.p_sys       = NULL;
    }
    retu...",1,1,misc\subpicture.c,subpicture_New,,false,44,81,subpicture_New,,,2,subpicture_t subpicture_New (subpicture_updater_t*)
125565,METHOD,misc\subpicture.c:<global>,TYPE_DECL,"void subpicture_Delete( subpicture_t *p_subpic )
{
    subpicture_region_ChainDelete( p_subpic->p_region );
    p_subpic->p_region = NULL;

    if( p_subpic->updater.pf_destroy )
        p_subpic->updater.pf_destroy( p_subpic );

    if( p_subpic->p_private )
    {
        video_format_Clean( &p_subpic->p_private->src );
        video_format_Clean( &p_subpic->p_private->dst );
    }

    free( p_subpic->p_private );
    free( p_subpic );
}",1,1,misc\subpicture.c,subpicture_Delete,,false,83,99,subpicture_Delete,,,3,void subpicture_Delete (subpicture_t*)
125618,METHOD,misc\subpicture.c:<global>,TYPE_DECL,"subpicture_t *subpicture_NewFromPicture( vlc_object_t *p_obj,
                                         picture_t *p_picture, vlc_fourcc_t i_chroma )
{
    /* */
    video_format_t fmt_in = p_picture->format;

    /* */
    video_format_t fmt_out;
    fmt_out = fmt_in;
    fmt_out.i_chroma = i_chroma;

    /* */
    image_handler_t *p_image = image_HandlerCreate( p_obj );
    if( !p_image )
        return NULL;

    picture_t *p_pip = image_Convert( p_image, p_picture, &fmt_in, &fmt_out );

    image_HandlerDelete( p_image );

    if( !p_pip )
        return NULL;

    subpicture_t *p_subpic = subpicture_New( NULL );
    if( !p_subpic )
    {
         picture_Release( p_pip );
         return NULL;
    }

    p_subpic->i_original_picture_width  = fmt_out.i_visible_width;
    p_subpic->i_original_picture_height = fmt_out.i_visible_height;

    fmt_out.i_sar_num =
    fmt_out.i_sar_den = 0;

    p_subpic->p_region = subpicture_region_New( &fmt_out );
    if( p_subpic->p_region )
    {
...",1,1,misc\subpicture.c,subpicture_NewFromPicture,,false,101,148,subpicture_NewFromPicture,,,4,"subpicture_t subpicture_NewFromPicture (vlc_object_t*,picture_t*,vlc_fourcc_t)"
125736,METHOD,misc\subpicture.c:<global>,TYPE_DECL,"void subpicture_Update( subpicture_t *p_subpicture,
                        const video_format_t *p_fmt_src,
                        const video_format_t *p_fmt_dst,
                        mtime_t i_ts )
{
    subpicture_updater_t *p_upd = &p_subpicture->updater;
    subpicture_private_t *p_private = p_subpicture->p_private;

    if( !p_upd->pf_validate )
        return;
    if( !p_upd->pf_validate( p_subpicture,
                          !video_format_IsSimilar( p_fmt_src,
                                                   &p_private->src ), p_fmt_src,
                          !video_format_IsSimilar( p_fmt_dst,
                                                   &p_private->dst ), p_fmt_dst,
                          i_ts ) )
        return;

    subpicture_region_ChainDelete( p_subpicture->p_region );
    p_subpicture->p_region = NULL;

    p_upd->pf_update( p_subpicture, p_fmt_src, p_fmt_dst, i_ts );

    video_format_Clean( &p_private->src );
    video_format_Clean( &p_private...",1,1,misc\subpicture.c,subpicture_Update,,false,150,178,subpicture_Update,,,5,"void subpicture_Update (subpicture_t*,video_format_t*,video_format_t*,mtime_t)"
125829,METHOD,misc\subpicture.c:<global>,TYPE_DECL,"subpicture_region_private_t *subpicture_region_private_New( video_format_t *p_fmt )
{
    subpicture_region_private_t *p_private = malloc( sizeof(*p_private) );

    if( !p_private )
        return NULL;

    if ( video_format_Copy( &p_private->fmt, p_fmt ) != VLC_SUCCESS )
    {
        free( p_private );
        return NULL;
    }

    p_private->p_picture = NULL;
    return p_private;
}",1,1,misc\subpicture.c,subpicture_region_private_New,,false,181,196,subpicture_region_private_New,,,6,subpicture_region_private_t subpicture_region_private_New (video_format_t*)
125868,METHOD,misc\subpicture.c:<global>,TYPE_DECL,"void subpicture_region_private_Delete( subpicture_region_private_t *p_private )
{
    if( p_private->p_picture )
        picture_Release( p_private->p_picture );
    video_format_Clean( &p_private->fmt );
    free( p_private );
}",1,1,misc\subpicture.c,subpicture_region_private_Delete,,false,198,204,subpicture_region_private_Delete,,,7,void subpicture_region_private_Delete (subpicture_region_private_t*)
125889,METHOD,misc\subpicture.c:<global>,TYPE_DECL,"subpicture_region_t *subpicture_region_New( const video_format_t *p_fmt )
{
    subpicture_region_t *p_region = calloc( 1, sizeof(*p_region ) );
    if( !p_region )
        return NULL;

    if ( p_fmt->i_chroma == VLC_CODEC_YUVP )
    {
        video_format_Copy( &p_region->fmt, p_fmt );
        /* YUVP should have a palette */
        if( p_region->fmt.p_palette == NULL )
        {
            p_region->fmt.p_palette = calloc( 1, sizeof(*p_region->fmt.p_palette) );
            if( p_region->fmt.p_palette == NULL )
            {
                free( p_region );
                return NULL;
            }
        }
    }
    else
    {
        p_region->fmt = *p_fmt;
        p_region->fmt.p_palette = NULL;
    }

    p_region->i_alpha = 0xff;
    p_region->b_balanced_text = true;

    if( p_fmt->i_chroma == VLC_CODEC_TEXT )
        return p_region;

    p_region->p_picture = picture_NewFromFormat( p_fmt );
    if( !p_region->p_picture )
    {
        video_format_Clean( &p_region->f...",1,1,misc\subpicture.c,subpicture_region_New,,false,206,247,subpicture_region_New,,,8,subpicture_region_t subpicture_region_New (video_format_t*)
126015,METHOD,misc\subpicture.c:<global>,TYPE_DECL,"void subpicture_region_Delete( subpicture_region_t *p_region )
{
    if( !p_region )
        return;

    if( p_region->p_private )
        subpicture_region_private_Delete( p_region->p_private );

    if( p_region->p_picture )
        picture_Release( p_region->p_picture );

    text_segment_ChainDelete( p_region->p_text );
    video_format_Clean( &p_region->fmt );
    free( p_region );
}",1,1,misc\subpicture.c,subpicture_region_Delete,,false,249,263,subpicture_region_Delete,,,9,void subpicture_region_Delete (subpicture_region_t*)
126054,METHOD,misc\subpicture.c:<global>,TYPE_DECL,"void subpicture_region_ChainDelete( subpicture_region_t *p_head )
{
    while( p_head )
    {
        subpicture_region_t *p_next = p_head->p_next;

        subpicture_region_Delete( p_head );

        p_head = p_next;
    }
}",1,1,misc\subpicture.c,subpicture_region_ChainDelete,,false,265,275,subpicture_region_ChainDelete,,,10,void subpicture_region_ChainDelete (subpicture_region_t*)
126073,METHOD,misc\subpicture.c:<global>,TYPE_DECL,"unsigned picture_BlendSubpicture(picture_t *dst,
                                 filter_t *blend, subpicture_t *src)
{
    unsigned done = 0;

    assert(src && !src->b_fade && src->b_absolute);

    for (subpicture_region_t *r = src->p_region; r != NULL; r = r->p_next) {
        assert(r->p_picture && r->i_align == 0);
        if (filter_ConfigureBlend(blend, dst->format.i_width,
                                  dst->format.i_height,  &r->fmt)
         || filter_Blend(blend, dst, r->i_x, r->i_y, r->p_picture,
                         src->i_alpha * r->i_alpha / 255))
            msg_Err(blend, ""blending %4.4s to %4.4s failed"",
                    (char *)&blend->fmt_in.video.i_chroma,
                    (char *)&blend->fmt_out.video.i_chroma );
        else
            done++;
    }
    return done;
}",1,1,misc\subpicture.c,picture_BlendSubpicture,,false,279,299,picture_BlendSubpicture,,,11,"unsigned picture_BlendSubpicture (picture_t*,filter_t*,subpicture_t*)"
126191,METHOD,misc\subpicture.c:<global>,TYPE_DECL,"subpicture_region_t* subpicture_region_Copy( subpicture_region_t *p_region_src )
{
    if (!p_region_src)
        return NULL;
    subpicture_region_t *p_region_dst = subpicture_region_New(&p_region_src->fmt);
    if (unlikely(!p_region_dst))
        return NULL;

    p_region_dst->i_x      = p_region_src->i_x;
    p_region_dst->i_y      = p_region_src->i_y;
    p_region_dst->i_align  = p_region_src->i_align;
    p_region_dst->i_alpha  = p_region_src->i_alpha;

    p_region_dst->p_text = text_segment_Copy( p_region_src->p_text );

    //Palette is already copied by subpicture_region_New, we just have to duplicate p_pixels
    for (int i = 0; i < p_region_src->p_picture->i_planes; i++)
        memcpy(p_region_dst->p_picture->p[i].p_pixels,
               p_region_src->p_picture->p[i].p_pixels,
               p_region_src->p_picture->p[i].i_lines * p_region_src->p_picture->p[i].i_pitch);
    return p_region_dst;
}",1,1,misc\subpicture.c,subpicture_region_Copy,,false,301,322,subpicture_region_Copy,,,12,subpicture_region_t subpicture_region_Copy (subpicture_region_t*)
126311,METHOD,misc\subpicture.h:<global>,TYPE_DECL,<global>,1,70,misc\subpicture.h,misc\subpicture.h:<global>,,false,1,30,<global>,,,1,
126316,METHOD,misc\subpicture.h:<global>,TYPE_DECL,subpicture_region_private_t *subpicture_region_private_New(video_format_t *);,29,76,misc\subpicture.h,subpicture_region_private_New,,false,29,29,subpicture_region_private_New,,,2,subpicture_region_private_t* subpicture_region_private_New (video_format_t*)
126321,METHOD,misc\subpicture.h:<global>,TYPE_DECL,void subpicture_region_private_Delete(subpicture_region_private_t *);,6,68,misc\subpicture.h,subpicture_region_private_Delete,,false,30,30,subpicture_region_private_Delete,,,3,void subpicture_region_private_Delete (subpicture_region_private_t*)
126337,METHOD,misc\text_style.c:<global>,TYPE_DECL,<global>,1,8,misc\text_style.c,misc\text_style.c:<global>,,false,1,297,<global>,,,1,
126339,METHOD,misc\text_style.c:<global>,TYPE_DECL,"text_style_t *text_style_New( void )
{
    return text_style_Create( STYLE_FULLY_SET );
}",1,1,misc\text_style.c,text_style_New,,false,34,37,text_style_New,,,1,text_style_t text_style_New (void)
126347,METHOD,misc\text_style.c:<global>,TYPE_DECL,"text_style_t *text_style_Create( int i_defaults )
{
    text_style_t *p_style = calloc( 1, sizeof(*p_style) );
    if( !p_style )
        return NULL;

    if( i_defaults == STYLE_NO_DEFAULTS )
        return p_style;

    /* initialize to default text style (FIXME: by flag) */
    p_style->psz_fontname = NULL;
    p_style->psz_monofontname = NULL;
    p_style->i_features = STYLE_FULLY_SET;
    p_style->i_style_flags = STYLE_OUTLINE;
    p_style->f_font_relsize = STYLE_DEFAULT_REL_FONT_SIZE;
    p_style->i_font_size = STYLE_DEFAULT_FONT_SIZE;
    p_style->i_font_color = 0xffffff;
    p_style->i_font_alpha = STYLE_ALPHA_OPAQUE;
    p_style->i_outline_color = 0x000000;
    p_style->i_outline_alpha = STYLE_ALPHA_OPAQUE;
    p_style->i_shadow_color = 0x808080;
    p_style->i_shadow_alpha = STYLE_ALPHA_OPAQUE;
    p_style->i_background_color = 0x000000;
    p_style->i_background_alpha = STYLE_ALPHA_OPAQUE;
    p_style->i_karaoke_background_color = 0xffffff;
    p_style->i_karaoke_backgro...",1,1,misc\text_style.c,text_style_Create,,false,39,71,text_style_Create,,,2,text_style_t text_style_Create (int)
126476,METHOD,misc\text_style.c:<global>,TYPE_DECL,"text_style_t *text_style_Copy( text_style_t *p_dst, const text_style_t *p_src )
{
    if( !p_src )
        return p_dst;

    /* */
    *p_dst = *p_src;

    if( p_src->psz_fontname )
        p_dst->psz_fontname = strdup( p_src->psz_fontname );

    if( p_src->psz_monofontname )
        p_dst->psz_monofontname = strdup( p_src->psz_monofontname );

    return p_dst;
}",1,1,misc\text_style.c,text_style_Copy,,false,73,88,text_style_Copy,,,3,"text_style_t text_style_Copy (text_style_t*,text_style_t*)"
126521,METHOD,misc\text_style.c:<global>,TYPE_DECL,"void text_style_Merge( text_style_t *p_dst, const text_style_t *p_src, bool b_override )
{
    if( p_src->psz_fontname && (!p_dst->psz_fontname || b_override) )
    {
        free( p_dst->psz_fontname );
        p_dst->psz_fontname = strdup( p_src->psz_fontname );
    }

    if( p_src->psz_monofontname && (!p_dst->psz_monofontname || b_override) )
    {
        free( p_dst->psz_monofontname );
        p_dst->psz_monofontname = strdup( p_src->psz_monofontname );
    }

    if( p_src->i_features != STYLE_NO_DEFAULTS )
    {
        MERGE(i_font_color,         STYLE_HAS_FONT_COLOR);
        MERGE(i_font_alpha,         STYLE_HAS_FONT_ALPHA);
        MERGE(i_outline_color,      STYLE_HAS_OUTLINE_COLOR);
        MERGE(i_outline_alpha,      STYLE_HAS_OUTLINE_ALPHA);
        MERGE(i_shadow_color,       STYLE_HAS_SHADOW_COLOR);
        MERGE(i_shadow_alpha,       STYLE_HAS_SHADOW_ALPHA);
        MERGE(i_background_color,   STYLE_HAS_BACKGROUND_COLOR);
        MERGE(i_background_alpha,   STYL...",1,8,misc\text_style.c,text_style_Merge,,false,98,134,text_style_Merge,,,4,"void text_style_Merge (text_style_t*,text_style_t*,bool)"
127003,METHOD,misc\text_style.c:<global>,TYPE_DECL,"text_style_t *text_style_Duplicate( const text_style_t *p_src )
{
    if( !p_src )
        return NULL;

    text_style_t *p_dst = calloc( 1, sizeof(*p_dst) );
    if( p_dst )
        text_style_Copy( p_dst, p_src );
    return p_dst;
}",1,1,misc\text_style.c,text_style_Duplicate,,false,139,148,text_style_Duplicate,,,5,text_style_t text_style_Duplicate (text_style_t*)
127030,METHOD,misc\text_style.c:<global>,TYPE_DECL,"void text_style_Delete( text_style_t *p_style )
{
    if( p_style )
        free( p_style->psz_fontname );
    if( p_style )
        free( p_style->psz_monofontname );
    free( p_style );
}",1,1,misc\text_style.c,text_style_Delete,,false,150,157,text_style_Delete,,,6,void text_style_Delete (text_style_t*)
127051,METHOD,misc\text_style.c:<global>,TYPE_DECL,"text_segment_t *text_segment_New( const char *psz_text )
{
    text_segment_t* segment = calloc( 1, sizeof(*segment) );
    if( !segment )
        return NULL;

    if ( psz_text )
        segment->psz_text = strdup( psz_text );

    return segment;
}",1,1,misc\text_style.c,text_segment_New,,false,159,169,text_segment_New,,,7,text_segment_t text_segment_New (char*)
127081,METHOD,misc\text_style.c:<global>,TYPE_DECL,"text_segment_t *text_segment_NewInheritStyle( const text_style_t* p_style )
{
    if ( !p_style )
        return NULL; //FIXME: Allow this, even if it is an alias to text_segment_New( NULL ) ?
    text_segment_t* p_segment = text_segment_New( NULL );
    if ( unlikely( !p_segment ) )
        return NULL;
    p_segment->style = text_style_Duplicate( p_style );
    if ( unlikely( !p_segment->style ) )
    {
        text_segment_Delete( p_segment );
        return NULL;
    }
    return p_segment;
}",1,1,misc\text_style.c,text_segment_NewInheritStyle,,false,171,185,text_segment_NewInheritStyle,,,8,text_segment_t text_segment_NewInheritStyle (text_style_t*)
127123,METHOD,misc\text_style.c:<global>,TYPE_DECL,"void text_segment_Delete( text_segment_t* segment )
{
    if ( segment != NULL )
    {
        free( segment->psz_text );
        text_style_Delete( segment->style );
        free( segment );
    }
}",1,1,misc\text_style.c,text_segment_Delete,,false,187,195,text_segment_Delete,,,9,void text_segment_Delete (text_segment_t*)
127143,METHOD,misc\text_style.c:<global>,TYPE_DECL,"void text_segment_ChainDelete( text_segment_t *segment )
{
    while( segment != NULL )
    {
        text_segment_t *p_next = segment->p_next;

        text_segment_Delete( segment );

        segment = p_next;
    }
}",1,1,misc\text_style.c,text_segment_ChainDelete,,false,197,207,text_segment_ChainDelete,,,10,void text_segment_ChainDelete (text_segment_t*)
127164,METHOD,misc\text_style.c:<global>,TYPE_DECL,"text_segment_t *text_segment_Copy( text_segment_t *p_src )
{
    text_segment_t *p_dst = NULL, *p_dst0 = NULL;

    while( p_src ) {
        text_segment_t *p_new = text_segment_New( p_src->psz_text );

        if( unlikely( !p_new ) )
            break;

        p_new->style = text_style_Duplicate( p_src->style );

        if( p_dst == NULL )
        {
            p_dst = p_dst0 = p_new;
        }
        else
        {
            p_dst->p_next = p_new;
            p_dst = p_dst->p_next;
        }

        p_src = p_src->p_next;
    }

    return p_dst0;
}",1,1,misc\text_style.c,text_segment_Copy,,false,209,235,text_segment_Copy,,,11,text_segment_t text_segment_Copy (text_segment_t*)
127230,METHOD,misc\text_style.c:<global>,TYPE_DECL,"unsigned int vlc_html_color( const char *psz_value, bool* ok )
{
    unsigned int color = 0;
    char* psz_end;
    bool b_ret = false;

    const char *psz_hex = (*psz_value == '#') ? psz_value + 1 : psz_value;

    if( psz_hex != psz_value ||
        (*psz_hex >= '0' && *psz_hex <= '9') ||
        (*psz_hex >= 'A' && *psz_hex <= 'F') )
    {
        uint32_t i_value = strtol( psz_hex, &psz_end, 16 );
        if( *psz_end == 0 || isspace( *psz_end ) )
        {
            switch( psz_end - psz_hex )
            {
                case 8:
                    color = (i_value << 24) | (i_value >> 8);
                    b_ret = true;
                    break;
                case 6:
                    color = i_value | 0xFF000000;
                    b_ret = true;
                    break;
                default:
                    break;
            }
        }
    }

    if( !b_ret && psz_hex == psz_value &&
        !strncmp( ""rgb"", psz_value, 3 ) )
    {
        unsigned r,g,...",1,1,misc\text_style.c,vlc_html_color,,false,237,297,vlc_html_color,,,12,"unsigned int vlc_html_color (char*,bool*)"
127487,METHOD,misc\threads.c:<global>,TYPE_DECL,<global>,1,34,misc\threads.c,misc\threads.c:<global>,,false,1,352,<global>,,,1,
127489,METHOD,misc\threads.c:<global>,TYPE_DECL,"void vlc_global_mutex (unsigned n, bool acquire)
{
    static vlc_mutex_t locks[] = {
        VLC_STATIC_MUTEX,
        VLC_STATIC_MUTEX,
        VLC_STATIC_MUTEX,
        VLC_STATIC_MUTEX,
        VLC_STATIC_MUTEX,
#ifdef _WIN32
        VLC_STATIC_MUTEX, // For MTA holder
#endif
    };
    static_assert (VLC_MAX_MUTEX == (sizeof (locks) / sizeof (locks[0])),
                   ""Wrong number of global mutexes"");
    assert (n < (sizeof (locks) / sizeof (locks[0])));

    vlc_mutex_t *lock = locks + n;
    if (acquire)
        vlc_mutex_lock (lock);
    else
        vlc_mutex_unlock (lock);
}",1,1,misc\threads.c,vlc_global_mutex,,false,32,53,vlc_global_mutex,,,1,"void vlc_global_mutex (unsigned,bool)"
127573,METHOD,misc\update.c:<global>,TYPE_DECL,<global>,1,7,misc\update.c,misc\update.c:<global>,,false,1,759,<global>,,,1,
127575,METHOD,misc\update.c:<global>,TYPE_DECL,"update_t *update_New( vlc_object_t *p_this )
{
    update_t *p_update;
    assert( p_this );

    p_update = (update_t *)malloc( sizeof( update_t ) );
    if( !p_update ) return NULL;

    vlc_mutex_init( &p_update->lock );

    p_update->p_libvlc = p_this->obj.libvlc;

    p_update->release.psz_url = NULL;
    p_update->release.psz_desc = NULL;

    p_update->p_download = NULL;
    p_update->p_check = NULL;

    p_update->p_pkey = NULL;
    vlc_gcrypt_init();

    return p_update;
}",1,1,misc\update.c,update_New,,false,104,126,update_New,,,1,update_t update_New (vlc_object_t*)
127642,METHOD,misc\update.c:<global>,TYPE_DECL,"void update_Delete( update_t *p_update )
{
    assert( p_update );

    if( p_update->p_check )
    {
        vlc_join( p_update->p_check->thread, NULL );
        free( p_update->p_check );
    }

    if( p_update->p_download )
    {
        atomic_store( &p_update->p_download->aborted, true );
        vlc_join( p_update->p_download->thread, NULL );
        vlc_object_release( p_update->p_download );
    }

    vlc_mutex_destroy( &p_update->lock );

    free( p_update->release.psz_url );
    free( p_update->release.psz_desc );
    free( p_update->p_pkey );

    free( p_update );
}",1,1,misc\update.c,update_Delete,,false,134,158,update_Delete,,,2,void update_Delete (update_t*)
127712,METHOD,misc\update.c:<global>,TYPE_DECL,"static void EmptyRelease( update_t *p_update )
{
    p_update->release.i_major = 0;
    p_update->release.i_minor = 0;
    p_update->release.i_revision = 0;

    FREENULL( p_update->release.psz_url );
    FREENULL( p_update->release.psz_desc );
}",1,1,misc\update.c,EmptyRelease,,false,166,174,EmptyRelease,,,3,void EmptyRelease (update_t*)
127750,METHOD,misc\update.c:<global>,TYPE_DECL,"static bool GetUpdateFile( update_t *p_update )
{
    stream_t *p_stream = NULL;
    char *psz_version_line = NULL;
    char *psz_update_data = NULL;

    p_stream = vlc_stream_NewURL( p_update->p_libvlc, UPDATE_VLC_STATUS_URL );
    if( !p_stream )
    {
        msg_Err( p_update->p_libvlc, ""Failed to open %s for reading"",
                 UPDATE_VLC_STATUS_URL );
        goto error;
    }

    uint64_t i_read;
    if( vlc_stream_GetSize( p_stream, &i_read ) || i_read >= UINT16_MAX )
    {
        msg_Err(p_update->p_libvlc, ""Status file too large"");
        goto error;
    }

    psz_update_data = malloc( i_read + 1 ); /* terminating '\0' */
    if( !psz_update_data )
        goto error;

    if( vlc_stream_Read( p_stream, psz_update_data,
                         i_read ) != (ssize_t)i_read )
    {
        msg_Err( p_update->p_libvlc, ""Couldn't download update file %s"",
                UPDATE_VLC_STATUS_URL );
        goto error;
    }
    psz_update_data[i_read] = '\0';

    vlc...",1,54,misc\update.c,GetUpdateFile,,false,183,382,GetUpdateFile,,,4,bool GetUpdateFile (update_t*)
128349,METHOD,misc\update.c:<global>,TYPE_DECL,static void* update_CheckReal( void * );,12,39,misc\update.c,update_CheckReal,,false,384,384,update_CheckReal,,,5,void* update_CheckReal (void*)
128354,METHOD,misc\update.c:<global>,TYPE_DECL,"void update_Check( update_t *p_update, void (*pf_callback)( void*, bool ), void *p_data )
{
    assert( p_update );

    // If the object already exist, destroy it
    if( p_update->p_check )
    {
        vlc_join( p_update->p_check->thread, NULL );
        free( p_update->p_check );
    }

    update_check_thread_t *p_uct = calloc( 1, sizeof( *p_uct ) );
    if( !p_uct ) return;

    p_uct->p_update = p_update;
    p_update->p_check = p_uct;
    p_uct->pf_callback = pf_callback;
    p_uct->p_data = p_data;

    vlc_clone( &p_uct->thread, update_CheckReal, p_uct, VLC_THREAD_PRIORITY_LOW );
}",1,1,misc\update.c,update_Check,,false,394,414,update_Check,,,6,"void update_Check (update_t*,void,void*)"
128420,METHOD,misc\update.c:<global>,TYPE_DECL,"void* update_CheckReal( void *obj )
{
    update_check_thread_t *p_uct = (update_check_thread_t *)obj;
    bool b_ret;
    int canc;

    canc = vlc_savecancel ();
    vlc_mutex_lock( &p_uct->p_update->lock );

    EmptyRelease( p_uct->p_update );
    b_ret = GetUpdateFile( p_uct->p_update );
    vlc_mutex_unlock( &p_uct->p_update->lock );

    if( p_uct->pf_callback )
        (p_uct->pf_callback)( p_uct->p_data, b_ret );

    vlc_restorecancel (canc);
    return NULL;
}",1,1,misc\update.c,update_CheckReal,,false,416,434,update_CheckReal,,,7,void* update_CheckReal (void*)
128477,METHOD,misc\update.c:<global>,TYPE_DECL,"bool update_NeedUpgrade( update_t *p_update )
{
    assert( p_update );

    static const int current[4] = {
        PACKAGE_VERSION_MAJOR,
        PACKAGE_VERSION_MINOR,
        PACKAGE_VERSION_REVISION,
        PACKAGE_VERSION_EXTRA
    };
    const int latest[4] = {
        p_update->release.i_major,
        p_update->release.i_minor,
        p_update->release.i_revision,
        p_update->release.i_extra
    };

    for (unsigned i = 0; i < sizeof latest / sizeof *latest; i++) {
        /* there is a new version available */
        if (latest[i] > current[i])
            return true;

        /* current version is more recent than the latest version ?! */
        if (latest[i] < current[i])
            return false;
    }

    /* current version is not a release, it's a -git or -rc version */
    if (*PACKAGE_VERSION_DEV)
        return true;

    /* current version is latest version */
    return false;
}",1,1,misc\update.c,update_NeedUpgrade,,false,436,469,update_NeedUpgrade,,,8,bool update_NeedUpgrade (update_t*)
128563,METHOD,misc\update.c:<global>,TYPE_DECL,"static char *size_str( uint64_t l_size )
{
    char *psz_tmp = NULL;
    int i_retval = 0;
    if( l_size >> 30 )
        i_retval = asprintf( &psz_tmp, _(""%.1f GiB""), (float)l_size/(1<<30) );
    else if( l_size >> 20 )
        i_retval = asprintf( &psz_tmp, _(""%.1f MiB""), (float)l_size/(1<<20) );
    else if( l_size >> 10 )
        i_retval = asprintf( &psz_tmp, _(""%.1f KiB""), (float)l_size/(1<<10) );
    else
        i_retval = asprintf( &psz_tmp, _(""%""PRIu64"" B""), l_size );

    return i_retval == -1 ? NULL : psz_tmp;
}",1,1,misc\update.c,size_str,,false,477,491,size_str,,,9,char* size_str (uint64_t)
128585,METHOD,misc\update.c:<global>,TYPE_DECL,static void* update_DownloadReal( void * );,12,42,misc\update.c,update_DownloadReal,,false,493,493,update_DownloadReal,,,10,void* update_DownloadReal (void*)
128590,METHOD,misc\update.c:<global>,TYPE_DECL,"void update_Download( update_t *p_update, const char *psz_destdir )
{
    assert( p_update );

    // If the object already exist, destroy it
    if( p_update->p_download )
    {
        atomic_store( &p_update->p_download->aborted, true );
        vlc_join( p_update->p_download->thread, NULL );
        vlc_object_release( p_update->p_download );
    }

    update_download_thread_t *p_udt =
        vlc_custom_create( p_update->p_libvlc, sizeof( *p_udt ),
                           ""update download"" );
    if( !p_udt )
        return;

    p_udt->p_update = p_update;
    p_update->p_download = p_udt;
    p_udt->psz_destdir = psz_destdir ? strdup( psz_destdir ) : NULL;

    atomic_store(&p_udt->aborted, false);
    vlc_clone( &p_udt->thread, update_DownloadReal, p_udt, VLC_THREAD_PRIORITY_LOW );
}",1,8,misc\update.c,update_Download,,false,502,526,update_Download,,,11,"void update_Download (update_t*,char*)"
128677,METHOD,misc\update.c:<global>,TYPE_DECL,"static void* update_DownloadReal( void *obj )
{
    update_download_thread_t *p_udt = (update_download_thread_t *)obj;
    uint64_t l_size;
    uint64_t l_downloaded = 0;
    float f_progress;
    char *psz_downloaded = NULL;
    char *psz_size = NULL;
    char *psz_destfile = NULL;
    char *psz_tmpdestfile = NULL;

    FILE *p_file = NULL;
    stream_t *p_stream = NULL;
    void* p_buffer = NULL;
    int i_read;
    int canc;

    vlc_dialog_id *p_dialog_id = NULL;
    update_t *p_update = p_udt->p_update;
    char *psz_destdir = p_udt->psz_destdir;

    msg_Dbg( p_udt, ""Opening Stream '%s'"", p_update->release.psz_url );
    canc = vlc_savecancel ();

    /* Open the stream */
    p_stream = vlc_stream_NewURL( p_udt, p_update->release.psz_url );
    if( !p_stream )
    {
        msg_Err( p_udt, ""Failed to open %s for reading"", p_update->release.psz_url );
        goto end;
    }

    /* Get the stream size */
    if( vlc_stream_GetSize( p_stream, &l_size ) || l_size == 0 )
       ...",1,8,misc\update.c,update_DownloadReal,,false,528,754,update_DownloadReal,,,12,void* update_DownloadReal (void*)
129249,METHOD,misc\update.c:<global>,TYPE_DECL,"update_release_t *update_GetRelease( update_t *p_update )
{
    return &p_update->release;
}",1,1,misc\update.c,update_GetRelease,,false,756,759,update_GetRelease,,,13,update_release_t update_GetRelease (update_t*)
129266,METHOD,misc\update.h:<global>,TYPE_DECL,<global>,1,45,misc\update.h,misc\update.h:<global>,,false,1,219,<global>,,,1,
129272,METHOD,<empty>,<empty>,<empty>,1,,misc\update.h,anonymous_enum_0:<clinit>,,false,26,,<clinit>,,,4,
129292,METHOD,<empty>,<empty>,<empty>,1,,misc\update.h,anonymous_enum_1:<clinit>,,false,33,,<clinit>,,,7,
129316,METHOD,<empty>,<empty>,<empty>,1,,misc\update.h,anonymous_enum_2:<clinit>,,false,45,,<clinit>,,,2,
129333,METHOD,<empty>,<empty>,<empty>,9,,misc\update.h,public_key_packet_t.sig.dsa:<clinit>,,false,59,,<clinit>,,,5,
129365,METHOD,<empty>,<empty>,<empty>,9,,misc\update.h,public_key_packet_t.sig.rsa:<clinit>,,false,65,,<clinit>,,,3,
129383,METHOD,<empty>,<empty>,<empty>,1,,misc\update.h,public_key_packet_t:<clinit>,,false,50,,<clinit>,,,6,
129402,METHOD,<empty>,<empty>,<empty>,9,,misc\update.h,signature_packet_t.specific.v4:<clinit>,,false,86,,<clinit>,,,5,
129414,METHOD,<empty>,<empty>,<empty>,9,,misc\update.h,signature_packet_t.specific.v3:<clinit>,,false,93,,<clinit>,,,3,
129426,METHOD,<empty>,<empty>,<empty>,9,,misc\update.h,signature_packet_t.algo_specific.dsa:<clinit>,,false,104,,<clinit>,,,3,
129445,METHOD,<empty>,<empty>,<empty>,9,,misc\update.h,signature_packet_t.algo_specific.rsa:<clinit>,,false,108,,<clinit>,,,2,
129457,METHOD,<empty>,<empty>,<empty>,1,,misc\update.h,signature_packet_t:<clinit>,,false,73,,<clinit>,,,11,
129474,METHOD,<empty>,<empty>,<empty>,1,,misc\update.h,public_key_t:<clinit>,,false,117,,<clinit>,,,5,
129493,METHOD,update_check_thread_t,TYPE_DECL,"void (*pf_callback)( void *, bool );",10,39,misc\update.h,update_check_thread_t.pf_callback,,false,150,150,pf_callback,,,3,"void update_check_thread_t.pf_callback (void*,ANY)"
129509,METHOD,misc\update.h:<global>,TYPE_DECL,"public_key_t *
download_key(
        vlc_object_t *p_this, const uint8_t *p_longid,
        const uint8_t *p_signature_issuer );",14,43,misc\update.h,download_key,,false,170,173,download_key,,,18,"public_key_t* download_key (vlc_object_t*,uint8_t*,uint8_t*)"
129516,METHOD,misc\update.h:<global>,TYPE_DECL,"int
parse_public_key(
        const uint8_t *p_key_data, size_t i_key_len, public_key_t *p_key,
        const uint8_t *p_sig_issuer );",1,37,misc\update.h,parse_public_key,,false,182,184,parse_public_key,,,19,"int parse_public_key (uint8_t*,size_t,public_key_t*,uint8_t*)"
129524,METHOD,misc\update.h:<global>,TYPE_DECL,"int
verify_signature(signature_packet_t *sign, public_key_packet_t *p_key,
        uint8_t *p_hash );",1,25,misc\update.h,verify_signature,,false,190,191,verify_signature,,,20,"int verify_signature (signature_packet_t*,public_key_packet_t*,uint8_t*)"
129531,METHOD,misc\update.h:<global>,TYPE_DECL,"int
download_signature(
        vlc_object_t *p_this, signature_packet_t *p_sig, const char *psz_url );",1,78,misc\update.h,download_signature,,false,198,199,download_signature,,,21,"int download_signature (vlc_object_t*,signature_packet_t*,char*)"
129538,METHOD,misc\update.h:<global>,TYPE_DECL,"uint8_t *
hash_from_text(
        const char *psz_text, signature_packet_t *p_sig );",9,57,misc\update.h,hash_from_text,,false,204,206,hash_from_text,,,22,"uint8_t* hash_from_text (char*,signature_packet_t*)"
129544,METHOD,misc\update.h:<global>,TYPE_DECL,"uint8_t *
hash_from_file(
        const char *psz_file, signature_packet_t *p_sig );",9,57,misc\update.h,hash_from_file,,false,211,213,hash_from_file,,,23,"uint8_t* hash_from_file (char*,signature_packet_t*)"
129550,METHOD,misc\update.h:<global>,TYPE_DECL,"uint8_t *
hash_from_public_key( public_key_t *p_pkey );",9,44,misc\update.h,hash_from_public_key,,false,218,219,hash_from_public_key,,,24,uint8_t* hash_from_public_key (public_key_t*)
129576,METHOD,misc\update_crypto.c:<global>,TYPE_DECL,<global>,1,1,misc\update_crypto.c,misc\update_crypto.c:<global>,,false,1,1109,<global>,,,1,
129578,METHOD,misc\update_crypto.c:<global>,TYPE_DECL,"static inline uint32_t scalar_number( const uint8_t *p, int header_len )
{
    assert( header_len == 1 || header_len == 2 || header_len == 4 );

    if( header_len == 1 )
        return( p[0] );
    else if( header_len == 2 )
        return( (p[0] << 8) + p[1] );
    else if( header_len == 4 )
        return( ((uint32_t)p[0] << 24) + (p[1] << 16) + (p[2] << 8) + p[3] );
    else
        abort();
}",1,1,misc\update_crypto.c,scalar_number,,false,57,69,scalar_number,,,1,"uint32_t scalar_number (uint8_t*,int)"
129656,METHOD,misc\update_crypto.c:<global>,TYPE_DECL,"static uint32_t mpi_len(const uint8_t *mpi)
{
    return (scalar_number(mpi, 2) + 7) / 8;
}",1,1,misc\update_crypto.c,mpi_len,,false,73,76,mpi_len,,,2,uint32_t mpi_len (uint8_t*)
129669,METHOD,misc\update_crypto.c:<global>,TYPE_DECL,"static size_t read_mpi(uint8_t *dst, const uint8_t *buf, size_t buflen, size_t bits)
{
    if (buflen < 2)
        return 0;

    size_t n = mpi_len(buf);

    if (n * 8 > bits)
        return 0;

    n += 2;

    if (buflen < n)
        return 0;

    memcpy(dst, buf, n);
    return n;
}",1,1,misc\update_crypto.c,read_mpi,,false,78,95,read_mpi,,,3,"size_t read_mpi (uint8_t*,uint8_t*,size_t,size_t)"
129714,METHOD,misc\update_crypto.c:<global>,TYPE_DECL,"static int parse_public_key_packet( public_key_packet_t *p_key,
                                    const uint8_t *p_buf, size_t i_packet_len )
{
    if( i_packet_len < 6 )
        return VLC_EGENERIC;

    size_t i_read = 0;

    p_key->version   = *p_buf++; i_read++;
    if( p_key->version != 4 )
        return VLC_EGENERIC;

    /* XXX: warn when timestamp is > date ? */
    memcpy( p_key->timestamp, p_buf, 4 ); p_buf += 4; i_read += 4;

    p_key->algo      = *p_buf++; i_read++;
    if( p_key->algo == GCRY_PK_DSA ) {
        READ_MPI(p_key->sig.dsa.p, 3072);
        READ_MPI(p_key->sig.dsa.q, 256);
        READ_MPI(p_key->sig.dsa.g, 3072);
        READ_MPI(p_key->sig.dsa.y, 3072);
    } else if ( p_key->algo == GCRY_PK_RSA ) {
        READ_MPI(p_key->sig.rsa.n, 4096);
        READ_MPI(p_key->sig.rsa.e, 4096);
    } else
        return VLC_EGENERIC;

    if( i_read == i_packet_len )
        return VLC_SUCCESS;

    /* some extra data eh ? */

error:
    return VLC_EGENERIC;
}",1,8,misc\update_crypto.c,parse_public_key_packet,,false,108,142,parse_public_key_packet,,,4,"int parse_public_key_packet (public_key_packet_t*,uint8_t*,size_t)"
130047,METHOD,misc\update_crypto.c:<global>,TYPE_DECL,"static size_t parse_signature_v3_packet( signature_packet_t *p_sig,
                                      const uint8_t *p_buf, size_t i_sig_len )
{
    size_t i_read = 1; /* we already read the version byte */

    if( i_sig_len < 19 ) /* signature is at least 19 bytes + the 2 MPIs */
        return 0;

    p_sig->specific.v3.hashed_data_len = *p_buf++; i_read++;
    if( p_sig->specific.v3.hashed_data_len != 5 )
        return 0;

    p_sig->type = *p_buf++; i_read++;

    memcpy( p_sig->specific.v3.timestamp, p_buf, 4 );
    p_buf += 4; i_read += 4;

    memcpy( p_sig->issuer_longid, p_buf, 8 );
    p_buf += 8; i_read += 8;

    p_sig->public_key_algo = *p_buf++; i_read++;

    p_sig->digest_algo = *p_buf++; i_read++;

    p_sig->hash_verification[0] = *p_buf++; i_read++;
    p_sig->hash_verification[1] = *p_buf++; i_read++;

    assert( i_read == 19 );

    return i_read;
}",1,1,misc\update_crypto.c,parse_signature_v3_packet,,false,145,175,parse_signature_v3_packet,,,5,"size_t parse_signature_v3_packet (signature_packet_t*,uint8_t*,size_t)"
130174,METHOD,misc\update_crypto.c:<global>,TYPE_DECL,"static size_t parse_signature_v4_packet( signature_packet_t *p_sig,
                                      const uint8_t *p_buf, size_t i_sig_len )
{
    size_t i_read = 1; /* we already read the version byte */

    if( i_sig_len < 10 ) /* signature is at least 10 bytes + the 2 MPIs */
        return 0;

    p_sig->type = *p_buf++; i_read++;

    p_sig->public_key_algo = *p_buf++; i_read++;
    if (p_sig->public_key_algo != GCRY_PK_DSA && p_sig->public_key_algo != GCRY_PK_RSA )
            return 0;

    p_sig->digest_algo = *p_buf++; i_read++;

    memcpy( p_sig->specific.v4.hashed_data_len, p_buf, 2 );
    p_buf += 2; i_read += 2;

    size_t i_hashed_data_len =
        scalar_number( p_sig->specific.v4.hashed_data_len, 2 );
    i_read += i_hashed_data_len;
    if( i_read + 4 > i_sig_len )
        return 0;

    p_sig->specific.v4.hashed_data = (uint8_t*) malloc( i_hashed_data_len );
    if( !p_sig->specific.v4.hashed_data )
        return 0;
    memcpy( p_sig->specific.v4.hashed_...",1,1,misc\update_crypto.c,parse_signature_v4_packet,,false,182,275,parse_signature_v4_packet,,,6,"size_t parse_signature_v4_packet (signature_packet_t*,uint8_t*,size_t)"
130536,METHOD,misc\update_crypto.c:<global>,TYPE_DECL,"static int parse_signature_packet( signature_packet_t *p_sig,
                                   const uint8_t *p_buf, size_t i_packet_len )
{
    if( !i_packet_len ) /* 1st sanity check, we need at least the version */
        return VLC_EGENERIC;

    p_sig->version = *p_buf++;

    size_t i_read;
    switch( p_sig->version )
    {
        case 3:
            i_read = parse_signature_v3_packet( p_sig, p_buf, i_packet_len );
            break;
        case 4:
            p_sig->specific.v4.hashed_data = NULL;
            p_sig->specific.v4.unhashed_data = NULL;
            i_read = parse_signature_v4_packet( p_sig, p_buf, i_packet_len );
            break;
        default:
            return VLC_EGENERIC;
    }

    if( i_read == 0 ) /* signature packet parsing has failed */
        goto error;

    if( p_sig->public_key_algo != GCRY_PK_DSA && p_sig->public_key_algo != GCRY_PK_RSA )
        goto error;

    switch( p_sig->type )
    {
        case BINARY_SIGNATURE:
        case TEX...",1,8,misc\update_crypto.c,parse_signature_packet,,false,278,346,parse_signature_packet,,,7,"int parse_signature_packet (signature_packet_t*,uint8_t*,size_t)"
130826,METHOD,misc\update_crypto.c:<global>,TYPE_DECL,"static long crc_octets( uint8_t *octets, size_t len )
{
    long crc = CRC24_INIT;
    int i;
    while (len--)
    {
        crc ^= (*octets++) << 16;
        for (i = 0; i < 8; i++)
        {
            crc <<= 1;
            if (crc & 0x1000000)
                crc ^= CRC24_POLY;
        }
    }
    return crc & 0xFFFFFFL;
}",1,15,misc\update_crypto.c,crc_octets,,false,356,371,crc_octets,,,8,"long crc_octets (uint8_t*,size_t)"
130878,METHOD,misc\update_crypto.c:<global>,TYPE_DECL,"static int pgp_unarmor( const char *p_ibuf, size_t i_ibuf_len,
                        uint8_t *p_obuf, size_t i_obuf_len )
{
    const char *p_ipos = p_ibuf;
    uint8_t *p_opos = p_obuf;
    int i_end = 0;
    int i_header_skipped = 0;

    while( !i_end && p_ipos < p_ibuf + i_ibuf_len && *p_ipos != '=' )
    {
        if( *p_ipos == '\r' || *p_ipos == '\n' )
        {
            p_ipos++;
            continue;
        }

        size_t i_line_len = strcspn( p_ipos, ""\r\n"" );
        if( i_line_len == 0 )
            continue;

        if( !i_header_skipped )
        {
            if( !strncmp( p_ipos, ""-----BEGIN PGP"", 14 ) )
                i_header_skipped = 1;

            p_ipos += i_line_len + 1;
            continue;
        }

        if( !strncmp( p_ipos, ""Version:"", 8 ) )
        {
            p_ipos += i_line_len + 1;
            continue;
        }

        if( p_ipos[i_line_len - 1] == '=' )
        {
            i_end = 1;
        }

        p_opos += vlc_b64_decode...",1,1,misc\update_crypto.c,pgp_unarmor,,false,378,435,pgp_unarmor,,,9,"int pgp_unarmor (char*,size_t,uint8_t*,size_t)"
131070,METHOD,misc\update_crypto.c:<global>,TYPE_DECL,"static int rsa_pkcs1_encode_sig(gcry_mpi_t *r_result, size_t size,
                                const uint8_t *hash, int algo)
{
    uint8_t asn[100];
    uint8_t frame[4096/8];

    size_t asnlen = sizeof(asn);
    size_t hashlen = gcry_md_get_algo_dlen(algo);

    if (gcry_md_algo_info(algo, GCRYCTL_GET_ASNOID, asn, &asnlen))
        return VLC_EGENERIC;

    if (!hashlen || hashlen + asnlen + 4 > size)
        return VLC_EGENERIC;

    frame[0] = 0;
    frame[1] = 1; /* block type */
    int pad = size - hashlen - asnlen - 3 ;
    memset (&frame[2], 0xff, pad );
    frame[2+pad] = 0;
    memcpy(&frame[3+pad], asn, asnlen);
    memcpy(&frame[3+pad+asnlen], hash, hashlen);

    if (gcry_mpi_scan(r_result, GCRYMPI_FMT_USG, frame, size, &size))
        return VLC_EGENERIC;
    return VLC_SUCCESS;
}",1,1,misc\update_crypto.c,rsa_pkcs1_encode_sig,,false,437,463,rsa_pkcs1_encode_sig,,,10,"int rsa_pkcs1_encode_sig (gcry_mpi_t*,size_t,uint8_t*,int)"
131181,METHOD,misc\update_crypto.c:<global>,TYPE_DECL,"static int verify_signature_rsa( signature_packet_t *sign, public_key_packet_t *p_key,
                      uint8_t *p_hash )
{
    int ret = VLC_EGENERIC;
    /* the data to be verified (a hash) */
    const char *hash_sexp_s = ""(data(flags raw)(value %m))"";
    /* the public key */
    const char *key_sexp_s = ""(public-key(rsa(n %m)(e %m)))"";
    /* the signature */
    const char *sig_sexp_s = ""(sig-val(rsa(s%m)))"";

    size_t erroff;
    gcry_mpi_t n, e, s, hash;
    n = e = s = hash = NULL;
    gcry_sexp_t key_sexp, hash_sexp, sig_sexp;
    key_sexp = hash_sexp = sig_sexp = NULL;

    size_t i_e_len = mpi_len( p_key->sig.rsa.e );
    size_t i_n_len = mpi_len( p_key->sig.rsa.n );
    if( gcry_mpi_scan( &n, GCRYMPI_FMT_USG, p_key->sig.rsa.n + 2, i_n_len, NULL ) ||
        gcry_mpi_scan( &e, GCRYMPI_FMT_USG, p_key->sig.rsa.e + 2, i_e_len, NULL ) ||
        gcry_sexp_build( &key_sexp, &erroff, key_sexp_s, n, e ) )
        goto out;

    uint8_t *p_s = sign->algo_specific.rsa.s;
 ...",1,1,misc\update_crypto.c,verify_signature_rsa,,false,468,516,verify_signature_rsa,,,11,"int verify_signature_rsa (signature_packet_t*,public_key_packet_t*,uint8_t*)"
131395,METHOD,misc\update_crypto.c:<global>,TYPE_DECL,"static int verify_signature_dsa( signature_packet_t *sign, public_key_packet_t *p_key,
                      uint8_t *p_hash )
{
    int ret = VLC_EGENERIC;

    /* the data to be verified (a hash) */
    const char *hash_sexp_s = ""(data(flags raw)(value %m))"";
    /* the public key */
    const char *key_sexp_s = ""(public-key(dsa(p %m)(q %m)(g %m)(y %m)))"";
    /* the signature */
    const char *sig_sexp_s = ""(sig-val(dsa(r %m )(s %m )))"";

    size_t erroff;
    gcry_mpi_t p, q, g, y, r, s, hash;
    p = q = g = y = r = s = hash = NULL;
    gcry_sexp_t key_sexp, hash_sexp, sig_sexp;
    key_sexp = hash_sexp = sig_sexp = NULL;

    size_t i_p_len = mpi_len( p_key->sig.dsa.p );
    size_t i_q_len = mpi_len( p_key->sig.dsa.q );
    size_t i_g_len = mpi_len( p_key->sig.dsa.g );
    size_t i_y_len = mpi_len( p_key->sig.dsa.y );
    if( gcry_mpi_scan( &p, GCRYMPI_FMT_USG, p_key->sig.dsa.p + 2, i_p_len, NULL ) ||
        gcry_mpi_scan( &q, GCRYMPI_FMT_USG, p_key->sig.dsa.q + 2, i_q_len,...",1,1,misc\update_crypto.c,verify_signature_dsa,,false,521,584,verify_signature_dsa,,,12,"int verify_signature_dsa (signature_packet_t*,public_key_packet_t*,uint8_t*)"
131729,METHOD,misc\update_crypto.c:<global>,TYPE_DECL,"int verify_signature( signature_packet_t *sign, public_key_packet_t *p_key,
                      uint8_t *p_hash )
{
    if (sign->public_key_algo == GCRY_PK_DSA)
        return verify_signature_dsa(sign, p_key, p_hash);
    else if (sign->public_key_algo == GCRY_PK_RSA)
        return verify_signature_rsa(sign, p_key, p_hash);
    else
        return VLC_EGENERIC;
}",1,1,misc\update_crypto.c,verify_signature,,false,589,598,verify_signature,,,13,"int verify_signature (signature_packet_t*,public_key_packet_t*,uint8_t*)"
131766,METHOD,misc\update_crypto.c:<global>,TYPE_DECL,"int parse_public_key( const uint8_t *p_key_data, size_t i_key_len,
                      public_key_t *p_key, const uint8_t *p_sig_issuer )
{
    const uint8_t *pos = p_key_data;
    const uint8_t *max_pos = pos + i_key_len;

    int i_status = 0;
#define PUBLIC_KEY_FOUND    0x01
#define USER_ID_FOUND       0x02
#define SIGNATURE_FOUND     0X04

    uint8_t *p_key_unarmored = NULL;

    p_key->psz_username = NULL;
    p_key->sig.specific.v4.hashed_data = NULL;
    p_key->sig.specific.v4.unhashed_data = NULL;

    if( !( *pos & 0x80 ) )
    {   /* first byte is ASCII, unarmoring */
        p_key_unarmored = (uint8_t*)malloc( i_key_len );
        if( !p_key_unarmored )
            return VLC_ENOMEM;
        int i_len = pgp_unarmor( (char*)p_key_data, i_key_len,
                                 p_key_unarmored, i_key_len );

        if( i_len == 0 )
            goto error;

        pos = p_key_unarmored;
        max_pos = pos + i_len;
    }

    while( pos < max_pos )
    {
        if(...",1,21,misc\update_crypto.c,parse_public_key,,false,607,722,parse_public_key,,,14,"int parse_public_key (uint8_t*,size_t,public_key_t*,uint8_t*)"
132182,METHOD,misc\update_crypto.c:<global>,TYPE_DECL,"static int hash_from_binary_file( const char *psz_file, gcry_md_hd_t hd )
{
    uint8_t buffer[4096];
    size_t i_read;

    FILE *f = vlc_fopen( psz_file, ""r"" );
    if( !f )
        return -1;

    while( ( i_read = fread( buffer, 1, sizeof(buffer), f ) ) > 0 )
        gcry_md_write( hd, buffer, i_read );

    fclose( f );

    return 0;
}",1,1,misc\update_crypto.c,hash_from_binary_file,,false,726,741,hash_from_binary_file,,,15,"int hash_from_binary_file (char*,gcry_md_hd_t)"
132222,METHOD,misc\update_crypto.c:<global>,TYPE_DECL,"static uint8_t *hash_finish( gcry_md_hd_t hd, signature_packet_t *p_sig )
{
    if( p_sig->version == 3 )
    {
        gcry_md_putc( hd, p_sig->type );
        gcry_md_write( hd, &p_sig->specific.v3.timestamp, 4 );
    }
    else if( p_sig->version == 4 )
    {
        gcry_md_putc( hd, p_sig->version );
        gcry_md_putc( hd, p_sig->type );
        gcry_md_putc( hd, p_sig->public_key_algo );
        gcry_md_putc( hd, p_sig->digest_algo );
        gcry_md_write( hd, p_sig->specific.v4.hashed_data_len, 2 );
        size_t i_len = scalar_number( p_sig->specific.v4.hashed_data_len, 2 );
        gcry_md_write( hd, p_sig->specific.v4.hashed_data, i_len );

        gcry_md_putc( hd, 0x04 );
        gcry_md_putc( hd, 0xFF );

        i_len += 6; /* hashed data + 6 bytes header */

        gcry_md_putc( hd, (i_len >> 24) & 0xff );
        gcry_md_putc( hd, (i_len >> 16) & 0xff );
        gcry_md_putc( hd, (i_len >> 8) & 0xff );
        gcry_md_putc( hd, (i_len) & 0xff );
    }
    else
...",1,1,misc\update_crypto.c,hash_finish,,false,745,786,hash_finish,,,16,"uint8_t hash_finish (gcry_md_hd_t,signature_packet_t*)"
132386,METHOD,misc\update_crypto.c:<global>,TYPE_DECL,"uint8_t *hash_from_text( const char *psz_string,
        signature_packet_t *p_sig )
{
    gcry_md_hd_t hd;
    if( gcry_md_open( &hd, p_sig->digest_algo, 0 ) )
        return NULL;

    if( p_sig->type == TEXT_SIGNATURE )
    while( *psz_string )
    {
        size_t i_len = strcspn( psz_string, ""\r\n"" );

        if( i_len )
        {
            gcry_md_write( hd, psz_string, i_len );
            psz_string += i_len;
        }
        gcry_md_putc( hd, '\r' );
        gcry_md_putc( hd, '\n' );

        if( *psz_string == '\r' )
            psz_string++;
        if( *psz_string == '\n' )
            psz_string++;
    }
    else
        gcry_md_write( hd, psz_string, strlen( psz_string ) );

    return hash_finish( hd, p_sig );
}",1,1,misc\update_crypto.c,hash_from_text,,false,792,821,hash_from_text,,,17,"uint8_t hash_from_text (char*,signature_packet_t*)"
132464,METHOD,misc\update_crypto.c:<global>,TYPE_DECL,"uint8_t *hash_from_file( const char *psz_file, signature_packet_t *p_sig )
{
    gcry_md_hd_t hd;
    if( gcry_md_open( &hd, p_sig->digest_algo, 0 ) )
        return NULL;

    if( hash_from_binary_file( psz_file, hd ) < 0 )
    {
        gcry_md_close( hd );
        return NULL;
    }

    return hash_finish( hd, p_sig );
}",1,1,misc\update_crypto.c,hash_from_file,,false,827,840,hash_from_file,,,18,"uint8_t hash_from_file (char*,signature_packet_t*)"
132497,METHOD,misc\update_crypto.c:<global>,TYPE_DECL,"uint8_t *hash_from_public_key( public_key_t *p_pkey )
{
    const uint8_t pk_algo = p_pkey->key.algo;
    size_t i_size;
    size_t i_p_len, i_g_len, i_q_len, i_y_len;
    size_t i_n_len, i_e_len;

    if( p_pkey->sig.version != 4 )
        return NULL;

    if( p_pkey->sig.type < GENERIC_KEY_SIGNATURE ||
        p_pkey->sig.type > POSITIVE_KEY_SIGNATURE )
        return NULL;

    if( p_pkey->psz_username == NULL )
        return NULL;

    gcry_error_t error = 0;
    gcry_md_hd_t hd;

    if (pk_algo == GCRY_PK_DSA) {
        i_p_len = mpi_len( p_pkey->key.sig.dsa.p );
        i_g_len = mpi_len( p_pkey->key.sig.dsa.g );
        i_q_len = mpi_len( p_pkey->key.sig.dsa.q );
        i_y_len = mpi_len( p_pkey->key.sig.dsa.y );

        i_size = 6 + 2*4 + i_p_len + i_g_len + i_q_len + i_y_len;
    } else if (pk_algo == GCRY_PK_RSA) {
        i_n_len = mpi_len( p_pkey->key.sig.rsa.n );
        i_e_len = mpi_len( p_pkey->key.sig.rsa.e );

        i_size = 6 + 2*2 + i_n_len + i_e_len;
    ...",1,1,misc\update_crypto.c,hash_from_public_key,,false,847,926,hash_from_public_key,,,19,uint8_t hash_from_public_key (public_key_t*)
132929,METHOD,misc\update_crypto.c:<global>,TYPE_DECL,"public_key_t *download_key( vlc_object_t *p_this,
                    const uint8_t *p_longid, const uint8_t *p_signature_issuer )
{
    char *psz_url;
    if( asprintf( &psz_url, ""http://download.videolan.org/pub/keys/%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X.asc"",
                    p_longid[0], p_longid[1], p_longid[2], p_longid[3],
                    p_longid[4], p_longid[5], p_longid[6], p_longid[7] ) == -1 )
        return NULL;

    stream_t *p_stream = vlc_stream_NewURL( p_this, psz_url );
    free( psz_url );
    if( !p_stream )
        return NULL;

    uint64_t i_size;
    if( vlc_stream_GetSize( p_stream, &i_size ) || i_size > INT_MAX )
    {
        vlc_stream_Delete( p_stream );
        return NULL;
    }

    uint8_t *p_buf = (uint8_t*)malloc( i_size );
    if( !p_buf )
    {
        vlc_stream_Delete( p_stream );
        return NULL;
    }

    int i_read = vlc_stream_Read( p_stream, p_buf, (int)i_size );
    vlc_stream_Delete( p_stream );

    if( i_read != (int)i_size )
 ...",1,1,misc\update_crypto.c,download_key,,false,932,990,download_key,,,20,"public_key_t download_key (vlc_object_t*,uint8_t*,uint8_t*)"
133087,METHOD,misc\update_crypto.c:<global>,TYPE_DECL,"int download_signature( vlc_object_t *p_this, signature_packet_t *p_sig,
                        const char *psz_url )
{
    char *psz_sig = (char*) malloc( strlen( psz_url ) + 4 + 1 ); /* "".asc"" + \0 */
    if( !psz_sig )
        return VLC_ENOMEM;

    strcpy( psz_sig, psz_url );
    strcat( psz_sig, "".asc"" );

    stream_t *p_stream = vlc_stream_NewURL( p_this, psz_sig );
    free( psz_sig );

    if( !p_stream )
        return VLC_ENOMEM;

    uint64_t i_size;
    if( vlc_stream_GetSize( p_stream, &i_size ) || i_size > INT_MAX )
    {
        vlc_stream_Delete( p_stream );
        return VLC_EGENERIC;
    }

    msg_Dbg( p_this, ""Downloading signature (%""PRIu64"" bytes)"", i_size );
    uint8_t *p_buf = (uint8_t*)malloc( i_size );
    if( !p_buf )
    {
        vlc_stream_Delete( p_stream );
        return VLC_ENOMEM;
    }

    int i_read = vlc_stream_Read( p_stream, p_buf, (int)i_size );

    vlc_stream_Delete( p_stream );

    if( i_read != (int)i_size )
    {
        msg_Dbg( ...",1,8,misc\update_crypto.c,download_signature,,false,997,1109,download_signature,,,21,"int download_signature (vlc_object_t*,signature_packet_t*,char*)"
133436,METHOD,misc\variables.c:<global>,TYPE_DECL,<global>,1,25,misc\variables.c,misc\variables.c:<global>,,false,1,1412,<global>,,,1,
133446,METHOD,variable_ops_t,TYPE_DECL,"int  (*pf_cmp) ( vlc_value_t, vlc_value_t );",10,47,misc\variables.c,variable_ops_t.pf_cmp,,false,59,59,pf_cmp,,,1,"int variable_ops_t.pf_cmp (ANY,ANY)"
133452,METHOD,variable_ops_t,TYPE_DECL,void (*pf_dup) ( vlc_value_t * );,10,36,misc\variables.c,variable_ops_t.pf_dup,,false,60,60,pf_dup,,,2,void variable_ops_t.pf_dup (vlc_value_t*)
133457,METHOD,variable_ops_t,TYPE_DECL,void (*pf_free) ( vlc_value_t * );,10,37,misc\variables.c,variable_ops_t.pf_free,,false,61,61,pf_free,,,3,void variable_ops_t.pf_free (vlc_value_t*)
133482,METHOD,misc\variables.c:<global>,TYPE_DECL,"static int CmpBool( vlc_value_t v, vlc_value_t w )
{
    return v.b_bool ? w.b_bool ? 0 : 1 : w.b_bool ? -1 : 0;
}",1,1,misc\variables.c,CmpBool,,false,106,109,CmpBool,,,8,"int CmpBool (vlc_value_t,vlc_value_t)"
133506,METHOD,misc\variables.c:<global>,TYPE_DECL,"static int CmpInt( vlc_value_t v, vlc_value_t w )
{
    return v.i_int == w.i_int ? 0 : v.i_int > w.i_int ? 1 : -1;
}",1,1,misc\variables.c,CmpInt,,false,111,114,CmpInt,,,9,"int CmpInt (vlc_value_t,vlc_value_t)"
133533,METHOD,misc\variables.c:<global>,TYPE_DECL,"static int CmpString( vlc_value_t v, vlc_value_t w )
{
    if( !v.psz_string )
        return !w.psz_string ? 0 : -1;
    else
        return !w.psz_string ? 1 : strcmp( v.psz_string, w.psz_string );
}",1,1,misc\variables.c,CmpString,,false,116,122,CmpString,,,10,"int CmpString (vlc_value_t,vlc_value_t)"
133570,METHOD,misc\variables.c:<global>,TYPE_DECL,"static int CmpFloat( vlc_value_t v, vlc_value_t w ) { return v.f_float == w.f_float ? 0 : v.f_float > w.f_float ? 1 : -1; }",1,123,misc\variables.c,CmpFloat,,false,123,123,CmpFloat,,,11,"int CmpFloat (vlc_value_t,vlc_value_t)"
133597,METHOD,misc\variables.c:<global>,TYPE_DECL,"static int CmpAddress( vlc_value_t v, vlc_value_t w ) { return v.p_address == w.p_address ? 0 : v.p_address > w.p_address ? 1 : -1; }",1,133,misc\variables.c,CmpAddress,,false,124,124,CmpAddress,,,12,"int CmpAddress (vlc_value_t,vlc_value_t)"
133624,METHOD,misc\variables.c:<global>,TYPE_DECL,static void DupDummy( vlc_value_t *p_val ) { (void)p_val; /* unused */ },1,72,misc\variables.c,DupDummy,,false,126,126,DupDummy,,,13,void DupDummy (vlc_value_t*)
133632,METHOD,misc\variables.c:<global>,TYPE_DECL,"static void DupString( vlc_value_t *p_val )
{
    p_val->psz_string = strdup( p_val->psz_string ? p_val->psz_string :  """" );
}",1,1,misc\variables.c,DupString,,false,127,130,DupString,,,14,void DupString (vlc_value_t*)
133650,METHOD,misc\variables.c:<global>,TYPE_DECL,static void FreeDummy( vlc_value_t *p_val ) { (void)p_val; /* unused */ },1,73,misc\variables.c,FreeDummy,,false,132,132,FreeDummy,,,15,void FreeDummy (vlc_value_t*)
133658,METHOD,misc\variables.c:<global>,TYPE_DECL,static void FreeString( vlc_value_t *p_val ) { free( p_val->psz_string ); },1,75,misc\variables.c,FreeString,,false,133,133,FreeString,,,16,void FreeString (vlc_value_t*)
133717,METHOD,misc\variables.c:<global>,TYPE_DECL,"static int varcmp( const void *a, const void *b )
{
    const variable_t *va = a, *vb = b;

    /* psz_name must be first */
    assert( va == (const void *)&va->psz_name );
    return strcmp( va->psz_name, vb->psz_name );
}",1,1,misc\variables.c,varcmp,,false,144,151,varcmp,,,32,"int varcmp (void*,void*)"
133748,METHOD,misc\variables.c:<global>,TYPE_DECL,"static variable_t *Lookup( vlc_object_t *obj, const char *psz_name )
{
    vlc_object_internals_t *priv = vlc_internals( obj );
    variable_t **pp_var;

    vlc_mutex_lock(&priv->var_lock);
    pp_var = tfind( &psz_name, &priv->var_root, varcmp );
    return (pp_var != NULL) ? *pp_var : NULL;
}",1,35,misc\variables.c,Lookup,,false,153,161,Lookup,,,33,"variable_t Lookup (vlc_object_t*,char*)"
133790,METHOD,misc\variables.c:<global>,TYPE_DECL,"static void Destroy( variable_t *p_var )
{
    p_var->ops->pf_free( &p_var->val );
    if( p_var->choices.i_count )
    {
        for( int i = 0 ; i < p_var->choices.i_count ; i++ )
        {
            p_var->ops->pf_free( &p_var->choices.p_values[i] );
            free( p_var->choices_text.p_values[i].psz_string );
        }
        free( p_var->choices.p_values );
        free( p_var->choices_text.p_values );
    }

    free( p_var->psz_name );
    free( p_var->psz_text );
    free( p_var->value_callbacks.p_entries );
    free( p_var );
}",1,1,misc\variables.c,Destroy,,false,163,181,Destroy,,,34,void Destroy (variable_t*)
133880,METHOD,misc\variables.c:<global>,TYPE_DECL,"static void CheckValue(variable_t *var, vlc_value_t *val)
{
    /* Check that our variable is within the bounds */
    switch (var->i_type & VLC_VAR_TYPE)
    {
        case VLC_VAR_INTEGER:
            if (val->i_int < var->min.i_int)
               val->i_int = var->min.i_int;
            if (val->i_int > var->max.i_int)
                val->i_int = var->max.i_int;
            if (var->step.i_int != 0 && (val->i_int % var->step.i_int))
            {
                if (val->i_int > 0)
                    val->i_int = (val->i_int + (var->step.i_int / 2))
                                 / var->step.i_int * var->step.i_int;
                else
                    val->i_int = (val->i_int - (var->step.i_int / 2))
                                 / var->step.i_int * var->step.i_int;
            }
            break;

        case VLC_VAR_FLOAT:
            if (isless(val->f_float, var->min.f_float))
                val->f_float = var->min.f_float;
            if (isgreater(val->f_floa...",1,1,misc\variables.c,CheckValue,,false,189,220,CheckValue,,,35,"void CheckValue (variable_t*,vlc_value_t*)"
134090,METHOD,misc\variables.c:<global>,TYPE_DECL,"static void WaitUnused(vlc_object_t *obj, variable_t *var)
{
    vlc_object_internals_t *priv = vlc_internals(obj);

    mutex_cleanup_push(&priv->var_lock);
    while (var->b_incallback)
        vlc_cond_wait(&priv->var_wait, &priv->var_lock);
    vlc_cleanup_pop();
}",1,35,misc\variables.c,WaitUnused,,false,225,233,WaitUnused,,,36,"void WaitUnused (vlc_object_t*,variable_t*)"
134127,METHOD,misc\variables.c:<global>,TYPE_DECL,"static void TriggerCallback(vlc_object_t *obj, variable_t *var,
                            const char *name, vlc_value_t prev)
{
    assert(obj != NULL);

    size_t count = var->value_callbacks.i_entries;
    if (count == 0)
        return;

    callback_entry_t *entries = var->value_callbacks.p_entries;
    vlc_object_internals_t *priv = vlc_internals(obj);

    assert(!var->b_incallback);
    var->b_incallback = true;
    vlc_mutex_unlock(&priv->var_lock);

    for (size_t i = 0; i < count; i++)
        entries[i].pf_value_callback(obj, name, prev, var->val,
                                     entries[i].p_data);

    vlc_mutex_lock(&priv->var_lock);
    var->b_incallback = false;
    vlc_cond_broadcast(&priv->var_wait);
}",1,35,misc\variables.c,TriggerCallback,,false,235,258,TriggerCallback,,,37,"void TriggerCallback (vlc_object_t*,variable_t*,char*,vlc_value_t)"
134231,METHOD,misc\variables.c:<global>,TYPE_DECL,"static void TriggerListCallback(vlc_object_t *obj, variable_t *var,
                                const char *name, int action, vlc_value_t *val)
{
    assert(obj != NULL);

    size_t count = var->list_callbacks.i_entries;
    if (count == 0)
        return;

    callback_entry_t *entries = var->list_callbacks.p_entries;
    vlc_object_internals_t *priv = vlc_internals(obj);

    assert(!var->b_incallback);
    var->b_incallback = true;
    vlc_mutex_unlock(&priv->var_lock);

    for (size_t i = 0; i < count; i++)
        entries[i].pf_list_callback(obj, name, action, val,
                                      entries[i].p_data);

    vlc_mutex_lock(&priv->var_lock);
    var->b_incallback = false;
    vlc_cond_broadcast(&priv->var_wait);
}",1,35,misc\variables.c,TriggerListCallback,,false,260,283,TriggerListCallback,,,38,"void TriggerListCallback (vlc_object_t*,variable_t*,char*,int,vlc_value_t*)"
134334,METHOD,misc\variables.c:<global>,TYPE_DECL,"int var_Create( vlc_object_t *p_this, const char *psz_name, int i_type )
{
    assert( p_this );

    variable_t *p_var = calloc( 1, sizeof( *p_var ) );
    if( p_var == NULL )
        return VLC_ENOMEM;

    p_var->psz_name = strdup( psz_name );
    p_var->psz_text = NULL;

    p_var->i_type = i_type & ~VLC_VAR_DOINHERIT;

    p_var->i_usage = 1;

    p_var->choices.i_count = 0;
    p_var->choices.p_values = NULL;
    p_var->choices_text.i_count = 0;
    p_var->choices_text.p_values = NULL;

    p_var->b_incallback = false;
    p_var->value_callbacks = (callback_table_t){ 0, NULL };

    /* Always initialize the variable, even if it is a list variable; this
     * will lead to errors if the variable is not initialized, but it will
     * not cause crashes in the variable handling. */
    switch( i_type & VLC_VAR_CLASS )
    {
        case VLC_VAR_BOOL:
            p_var->ops = &bool_ops;
            p_var->val.b_bool = false;
            break;
        case VLC_VAR_INTEGER:
       ...",1,37,misc\variables.c,var_Create,,false,298,387,var_Create,,,39,"int var_Create (vlc_object_t*,char*,int)"
134679,METHOD,misc\variables.c:<global>,TYPE_DECL,"void (var_Destroy)(vlc_object_t *p_this, const char *psz_name)
{
    variable_t *p_var;

    assert( p_this );

    vlc_object_internals_t *p_priv = vlc_internals( p_this );

    p_var = Lookup( p_this, psz_name );
    if( p_var == NULL )
        msg_Dbg( p_this, ""attempt to destroy nonexistent variable \""%s\"""",
                 psz_name );
    else if( --p_var->i_usage == 0 )
    {
        assert(!p_var->b_incallback);
        tdelete( p_var, &p_priv->var_root, varcmp );
    }
    else
    {
        assert(p_var->i_usage != -1u);
        p_var = NULL;
    }
    vlc_mutex_unlock( &p_priv->var_lock );

    if( p_var != NULL )
        Destroy( p_var );
}",1,37,misc\variables.c,,,false,398,424,var_Destroy,,,40,"void (vlc_object_t*,char*)"
134760,METHOD,misc\variables.c:<global>,TYPE_DECL,"static void CleanupVar( void *var )
{
    Destroy( var );
}",1,1,misc\variables.c,CleanupVar,,false,426,429,CleanupVar,,,41,void CleanupVar (void*)
134767,METHOD,misc\variables.c:<global>,TYPE_DECL,"void var_DestroyAll( vlc_object_t *obj )
{
    vlc_object_internals_t *priv = vlc_internals( obj );

    tdestroy( priv->var_root, CleanupVar );
    priv->var_root = NULL;
}",1,35,misc\variables.c,var_DestroyAll,,false,431,437,var_DestroyAll,,,42,void var_DestroyAll (vlc_object_t*)
134794,METHOD,misc\variables.c:<global>,TYPE_DECL,"int var_Change( vlc_object_t *p_this, const char *psz_name,
                int i_action, vlc_value_t *p_val, vlc_value_t *p_val2 )
{
    int ret = VLC_SUCCESS;
    variable_t *p_var;
    vlc_value_t oldval;
    vlc_value_t newval;

    assert( p_this );

    vlc_object_internals_t *p_priv = vlc_internals( p_this );

    p_var = Lookup( p_this, psz_name );
    if( p_var == NULL )
    {
        vlc_mutex_unlock( &p_priv->var_lock );
        return VLC_ENOVAR;
    }

    switch( i_action )
    {
        case VLC_VAR_GETMIN:
            *p_val = p_var->min;
            break;
        case VLC_VAR_GETMAX:
            *p_val = p_var->max;
            break;
        case VLC_VAR_SETMINMAX:
            assert(p_var->ops->pf_free == FreeDummy);
            p_var->min = *p_val;
            p_var->max = *p_val2;
            break;
        case VLC_VAR_SETSTEP:
            assert(p_var->ops->pf_free == FreeDummy);
            p_var->step = *p_val;
            CheckValue( p_var, &p_var->val );
...",1,37,misc\variables.c,var_Change,,false,449,619,var_Change,,,43,"int var_Change (vlc_object_t*,char*,int,vlc_value_t*,vlc_value_t*)"
135546,METHOD,misc\variables.c:<global>,TYPE_DECL,"int var_GetAndSet( vlc_object_t *p_this, const char *psz_name, int i_action,
                   vlc_value_t *p_val )
{
    variable_t *p_var;
    vlc_value_t oldval;

    assert( p_this );
    assert( p_val );

    vlc_object_internals_t *p_priv = vlc_internals( p_this );

    p_var = Lookup( p_this, psz_name );
    if( p_var == NULL )
    {
        vlc_mutex_unlock( &p_priv->var_lock );
        return VLC_ENOVAR;
    }

    WaitUnused( p_this, p_var );

    /* Duplicated data if needed */
    //p_var->ops->pf_dup( &val );

    /* Backup needed stuff */
    oldval = p_var->val;

    /* depending of the action requiered */
    switch( i_action )
    {
    case VLC_VAR_BOOL_TOGGLE:
        assert( ( p_var->i_type & VLC_VAR_BOOL ) == VLC_VAR_BOOL );
        p_var->val.b_bool = !p_var->val.b_bool;
        break;
    case VLC_VAR_INTEGER_ADD:
        assert( ( p_var->i_type & VLC_VAR_INTEGER ) == VLC_VAR_INTEGER );
        p_var->val.i_int += p_val->i_int;
        break;
    case VLC_VAR...",1,37,misc\variables.c,var_GetAndSet,,false,631,690,var_GetAndSet,,,44,"int var_GetAndSet (vlc_object_t*,char*,int,vlc_value_t*)"
135716,METHOD,misc\variables.c:<global>,TYPE_DECL,"int var_Type( vlc_object_t *p_this, const char *psz_name )
{
    variable_t *p_var;
    int i_type = 0;

    assert( p_this );

    vlc_object_internals_t *p_priv = vlc_internals( p_this );

    p_var = Lookup( p_this, psz_name );
    if( p_var != NULL )
    {
        i_type = p_var->i_type;
        if( p_var->choices.i_count > 0 )
            i_type |= VLC_VAR_HASCHOICE;
    }
    vlc_mutex_unlock( &p_priv->var_lock );

    return i_type;
}",1,37,misc\variables.c,var_Type,,false,700,719,var_Type,,,45,"int var_Type (vlc_object_t*,char*)"
135775,METHOD,misc\variables.c:<global>,TYPE_DECL,"int var_SetChecked( vlc_object_t *p_this, const char *psz_name,
                    int expected_type, vlc_value_t val )
{
    variable_t *p_var;
    vlc_value_t oldval;

    assert( p_this );

    vlc_object_internals_t *p_priv = vlc_internals( p_this );

    p_var = Lookup( p_this, psz_name );
    if( p_var == NULL )
    {
        vlc_mutex_unlock( &p_priv->var_lock );
        return VLC_ENOVAR;
    }

    assert( expected_type == 0 ||
            (p_var->i_type & VLC_VAR_CLASS) == expected_type );
    assert ((p_var->i_type & VLC_VAR_CLASS) != VLC_VAR_VOID);

    WaitUnused( p_this, p_var );

    /* Duplicate data if needed */
    p_var->ops->pf_dup( &val );

    /* Backup needed stuff */
    oldval = p_var->val;

    /* Check boundaries and list */
    CheckValue( p_var, &val );

    /* Set the variable */
    p_var->val = val;

    /* Deal with callbacks */
    TriggerCallback( p_this, p_var, psz_name, oldval );

    /* Free data if needed */
    p_var->ops->pf_free( &oldval );...",1,37,misc\variables.c,var_SetChecked,,false,722,765,var_SetChecked,,,46,"int var_SetChecked (vlc_object_t*,char*,int,vlc_value_t)"
135881,METHOD,misc\variables.c:<global>,TYPE_DECL,"int var_Set( vlc_object_t *p_this, const char *psz_name, vlc_value_t val )
{
    return var_SetChecked( p_this, psz_name, 0, val );
}",1,1,misc\variables.c,var_Set,,false,775,778,var_Set,,,47,"int var_Set (vlc_object_t*,char*,vlc_value_t)"
135894,METHOD,misc\variables.c:<global>,TYPE_DECL,"int var_GetChecked( vlc_object_t *p_this, const char *psz_name,
                    int expected_type, vlc_value_t *p_val )
{
    assert( p_this );

    vlc_object_internals_t *p_priv = vlc_internals( p_this );
    variable_t *p_var;
    int err = VLC_SUCCESS;

    p_var = Lookup( p_this, psz_name );
    if( p_var != NULL )
    {
        assert( expected_type == 0 ||
                (p_var->i_type & VLC_VAR_CLASS) == expected_type );
        assert ((p_var->i_type & VLC_VAR_CLASS) != VLC_VAR_VOID);

        /* Really get the variable */
        *p_val = p_var->val;

        /* Duplicate value if needed */
        p_var->ops->pf_dup( p_val );
    }
    else
        err = VLC_ENOVAR;

    vlc_mutex_unlock( &p_priv->var_lock );
    return err;
}",1,37,misc\variables.c,var_GetChecked,,false,781,808,var_GetChecked,,,48,"int var_GetChecked (vlc_object_t*,char*,int,vlc_value_t*)"
135976,METHOD,misc\variables.c:<global>,TYPE_DECL,"int var_Get( vlc_object_t *p_this, const char *psz_name, vlc_value_t *p_val )
{
    return var_GetChecked( p_this, psz_name, 0, p_val );
}",1,1,misc\variables.c,var_Get,,false,819,822,var_Get,,,49,"int var_Get (vlc_object_t*,char*,vlc_value_t*)"
135993,METHOD,misc\variables.c:<global>,TYPE_DECL,"static void AddCallback( vlc_object_t *p_this, const char *psz_name,
                        callback_entry_t entry, vlc_callback_type_t i_type )
{
    variable_t *p_var;

    assert( p_this );

    vlc_object_internals_t *p_priv = vlc_internals( p_this );

    p_var = Lookup( p_this, psz_name );
    if( p_var == NULL )
    {
        vlc_mutex_unlock( &p_priv->var_lock );
        msg_Err( p_this, ""cannot add callback %p to nonexistent variable '%s'"",
                 entry.p_callback, psz_name );
        return;
    }

    WaitUnused( p_this, p_var );

    callback_table_t *p_table;
    if (i_type == vlc_value_callback)
        p_table = &p_var->value_callbacks;
    else
        p_table = &p_var->list_callbacks;
    TAB_APPEND(p_table->i_entries, p_table->p_entries, entry);

    vlc_mutex_unlock( &p_priv->var_lock );
}",1,37,misc\variables.c,AddCallback,,false,830,858,AddCallback,,,52,"void AddCallback (vlc_object_t*,char*,callback_entry_t,vlc_callback_type_t)"
136075,METHOD,misc\variables.c:<global>,TYPE_DECL,"void var_AddCallback( vlc_object_t *p_this, const char *psz_name,
                      vlc_callback_t pf_callback, void *p_data )
{
    callback_entry_t entry;
    entry.pf_value_callback = pf_callback;
    entry.p_data = p_data;

    AddCallback(p_this, psz_name, entry, vlc_value_callback);
}",1,1,misc\variables.c,var_AddCallback,,false,877,885,var_AddCallback,,,53,"void var_AddCallback (vlc_object_t*,char*,vlc_callback_t,void*)"
136099,METHOD,misc\variables.c:<global>,TYPE_DECL,"static void DelCallback( vlc_object_t *p_this, const char *psz_name,
                         callback_entry_t entry, vlc_callback_type_t i_type )
{
    int i_entry;
    variable_t *p_var;
#ifndef NDEBUG
    bool b_found_similar = false;
#endif

    assert( p_this );

    vlc_object_internals_t *p_priv = vlc_internals( p_this );

    p_var = Lookup( p_this, psz_name );
    if( p_var == NULL )
    {
        vlc_mutex_unlock( &p_priv->var_lock );
        msg_Err( p_this, ""cannot delete callback %p from nonexistent ""
                 ""variable '%s'"", entry.p_callback, psz_name );
        return;
    }

    WaitUnused( p_this, p_var );

    callback_table_t *p_table;
    if (i_type == vlc_value_callback)
        p_table = &p_var->value_callbacks;
    else
        p_table = &p_var->list_callbacks;

    for( i_entry = p_table->i_entries ; i_entry-- ; )
    {
        if( p_table->p_entries[i_entry].p_callback == entry.p_callback
            && p_table->p_entries[i_entry].p_data == entry.p_...",1,37,misc\variables.c,DelCallback,,false,887,945,DelCallback,,,54,"void DelCallback (vlc_object_t*,char*,callback_entry_t,vlc_callback_type_t)"
136259,METHOD,misc\variables.c:<global>,TYPE_DECL,"void var_DelCallback( vlc_object_t *p_this, const char *psz_name,
                      vlc_callback_t pf_callback, void *p_data )
{
    callback_entry_t entry;
    entry.pf_value_callback = pf_callback;
    entry.p_data = p_data;

    DelCallback(p_this, psz_name, entry, vlc_value_callback);
}",1,1,misc\variables.c,var_DelCallback,,false,954,962,var_DelCallback,,,55,"void var_DelCallback (vlc_object_t*,char*,vlc_callback_t,void*)"
136283,METHOD,misc\variables.c:<global>,TYPE_DECL,"void var_TriggerCallback( vlc_object_t *p_this, const char *psz_name )
{
    vlc_object_internals_t *p_priv = vlc_internals( p_this );
    variable_t *p_var = Lookup( p_this, psz_name );
    if( p_var != NULL )
    {
        WaitUnused( p_this, p_var );

        /* Deal with callbacks. Tell we're in a callback, release the lock,
         * call stored functions, retake the lock. */
        TriggerCallback( p_this, p_var, psz_name, p_var->val );
    }
    vlc_mutex_unlock( &p_priv->var_lock );
}",1,37,misc\variables.c,var_TriggerCallback,,false,971,984,var_TriggerCallback,,,56,"void var_TriggerCallback (vlc_object_t*,char*)"
136327,METHOD,misc\variables.c:<global>,TYPE_DECL,"void var_AddListCallback( vlc_object_t *p_this, const char *psz_name,
                          vlc_list_callback_t pf_callback, void *p_data )
{
    callback_entry_t entry;
    entry.pf_list_callback = pf_callback;
    entry.p_data = p_data;

    AddCallback(p_this, psz_name, entry, vlc_list_callback);
}",1,1,misc\variables.c,var_AddListCallback,,false,995,1003,var_AddListCallback,,,57,"void var_AddListCallback (vlc_object_t*,char*,vlc_list_callback_t,void*)"
136351,METHOD,misc\variables.c:<global>,TYPE_DECL,"void var_DelListCallback( vlc_object_t *p_this, const char *psz_name,
                          vlc_list_callback_t pf_callback, void *p_data )
{
    callback_entry_t entry;
    entry.pf_list_callback = pf_callback;
    entry.p_data = p_data;

    DelCallback(p_this, psz_name, entry, vlc_list_callback);
}",1,1,misc\variables.c,var_DelListCallback,,false,1011,1019,var_DelListCallback,,,58,"void var_DelListCallback (vlc_object_t*,char*,vlc_list_callback_t,void*)"
136375,METHOD,misc\variables.c:<global>,TYPE_DECL,"void var_OptionParse( vlc_object_t *p_obj, const char *psz_option,
                      bool trusted )
{
    char *psz_name, *psz_value;
    int  i_type;
    bool b_isno = false;
    vlc_value_t val;

    val.psz_string = NULL;

    /* It's too much of a hassle to remove the ':' when we parse
     * the cmd line :) */
    if( psz_option[0] == ':' )
        psz_option++;

    if( !psz_option[0] )
        return;

    psz_name = strdup( psz_option );
    if( psz_name == NULL )
        return;

    psz_value = strchr( psz_name, '=' );
    if( psz_value != NULL )
        *psz_value++ = '\0';

    i_type = config_GetType( psz_name );
    if( !i_type && !psz_value )
    {
        /* check for ""no-foo"" or ""nofoo"" */
        if( !strncmp( psz_name, ""no-"", 3 ) )
        {
            memmove( psz_name, psz_name + 3, strlen(psz_name) + 1 - 3 );
        }
        else if( !strncmp( psz_name, ""no"", 2 ) )
        {
            memmove( psz_name, psz_name + 2, strlen(psz_name) + 1 - 2 );
       ...",1,1,misc\variables.c,var_OptionParse,,false,1031,1119,var_OptionParse,,,59,"void var_OptionParse (vlc_object_t*,char*,bool)"
136581,METHOD,misc\variables.c:<global>,TYPE_DECL,"int var_LocationParse (vlc_object_t *obj, const char *mrl, const char *pref)
{
    int ret = VLC_SUCCESS;
    size_t preflen = strlen (pref) + 1;

    assert(mrl != NULL);
    while (*mrl != '\0')
    {
        mrl += strspn (mrl, "":;""); /* skip leading colon(s) */

        size_t len = strcspn (mrl, "":;"");
        char *buf = malloc (preflen + len);

        if (likely(buf != NULL))
        {
            /* NOTE: this does not support the ""no-<varname>"" bool syntax. */
            /* DO NOT use asprintf() here; it won't work! Think again. */
            snprintf (buf, preflen + len, ""%s%s"", pref, mrl);
            var_OptionParse (obj, buf, false);
            free (buf);
        }
        else
            ret = VLC_ENOMEM;
        mrl += len;
    }

    return ret;
}",1,1,misc\variables.c,var_LocationParse,,false,1138,1165,var_LocationParse,,,60,"int var_LocationParse (vlc_object_t*,char*,char*)"
136657,METHOD,misc\variables.c:<global>,TYPE_DECL,"int var_Inherit( vlc_object_t *p_this, const char *psz_name, int i_type,
                 vlc_value_t *p_val )
{
    i_type &= VLC_VAR_CLASS;
    for( vlc_object_t *obj = p_this; obj != NULL; obj = obj->obj.parent )
    {
        if( var_GetChecked( obj, psz_name, i_type, p_val ) == VLC_SUCCESS )
            return VLC_SUCCESS;
    }

    /* else take value from config */
    switch( i_type & VLC_VAR_CLASS )
    {
        case VLC_VAR_STRING:
            p_val->psz_string = config_GetPsz( p_this, psz_name );
            if( !p_val->psz_string ) p_val->psz_string = strdup("""");
            break;
        case VLC_VAR_FLOAT:
            p_val->f_float = config_GetFloat( p_this, psz_name );
            break;
        case VLC_VAR_INTEGER:
            p_val->i_int = config_GetInt( p_this, psz_name );
            break;
        case VLC_VAR_BOOL:
            p_val->b_bool = config_GetInt( p_this, psz_name ) > 0;
            break;
        default:
            vlc_assert_unreachable();
   ...",1,1,misc\variables.c,var_Inherit,,false,1173,1205,var_Inherit,,,61,"int var_Inherit (vlc_object_t*,char*,int,vlc_value_t*)"
136763,METHOD,misc\variables.c:<global>,TYPE_DECL,"int (var_InheritURational)(vlc_object_t *object,
                           unsigned *num, unsigned *den,
                           const char *var)
{
    char *str = var_InheritString(object, var);
    if (str == NULL)
        goto error;

    char *sep;
    unsigned n = strtoul(str, &sep, 10);
    unsigned d;

    switch (*sep) {
        case '\0':
            /* Decimal integer */
            d = 1;
            break;

        case ':':
        case '/':
            /* Decimal fraction */
            d = strtoul(sep + 1, &sep, 10);
            if (*sep != '\0')
                goto error;
            break;

        case '.': {
            /* Decimal number */
            unsigned char c;

            d = 1;
            while ((c = *(++sep)) != '\0') {
                c -= '0';

                if (c >= 10)
                    goto error;

                n = n * 10 + c;
                d *= 10;
            }
            break;
        }

        default:
            goto error;...",1,1,misc\variables.c,,,false,1215,1280,var_InheritURational,,,62,"int (vlc_object_t*,unsigned*,unsigned*,char*)"
136918,METHOD,misc\variables.c:<global>,TYPE_DECL,"void var_FreeList( vlc_value_t *p_val, vlc_value_t *p_val2 )
{
    switch( p_val->p_list->i_type & VLC_VAR_CLASS )
    {
        case VLC_VAR_STRING:
            for( int i = 0; i < p_val->p_list->i_count; i++ )
                free( p_val->p_list->p_values[i].psz_string );
            break;
    }

    free( p_val->p_list->p_values );
    free( p_val->p_list );

    if( p_val2 != NULL )
    {
        assert( p_val2->p_list != NULL );
        assert( p_val2->p_list->i_type == VLC_VAR_STRING );

        for( int i = 0; i < p_val2->p_list->i_count; i++ )
            free( p_val2->p_list->p_values[i].psz_string );
        free( p_val2->p_list->p_values );
        free( p_val2->p_list );
    }
}",1,1,misc\variables.c,var_FreeList,,false,1287,1310,var_FreeList,,,63,"void var_FreeList (vlc_value_t*,vlc_value_t*)"
137025,METHOD,misc\variables.c:<global>,TYPE_DECL,"static void DumpVariable(const void *data, const VISIT which, const int depth)
{
    if (which != postorder && which != leaf)
        return;
    (void) depth;

    const variable_t *var = *(const variable_t **)data;
    const char *typename = ""unknown"";

    switch (var->i_type & VLC_VAR_TYPE)
    {
        case VLC_VAR_VOID:     typename = ""void"";        break;
        case VLC_VAR_BOOL:     typename = ""bool"";        break;
        case VLC_VAR_INTEGER:  typename = ""integer"";     break;
        case VLC_VAR_STRING:   typename = ""string"";      break;
        case VLC_VAR_FLOAT:    typename = ""float"";       break;
        case VLC_VAR_COORDS:   typename = ""coordinates""; break;
        case VLC_VAR_ADDRESS:  typename = ""address"";     break;
        default:               typename = ""unknown"";     break;
    }

    printf("" *-o \""%s\"" (%s"", var->psz_name, typename);
    if (var->psz_text != NULL)
        printf("", %s"", var->psz_text);
    putchar(')');
    if (var->i_type & VLC_VAR_HA...",1,1,misc\variables.c,DumpVariable,,false,1312,1369,DumpVariable,,,64,"void DumpVariable (void*,VISIT,int)"
137227,METHOD,misc\variables.c:<global>,TYPE_DECL,"void DumpVariables(vlc_object_t *obj)
{
    vlc_mutex_lock(&vlc_internals(obj)->var_lock);
    if (vlc_internals(obj)->var_root == NULL)
        puts("" `-o No variables"");
    else
        twalk(vlc_internals(obj)->var_root, DumpVariable);
    vlc_mutex_unlock(&vlc_internals(obj)->var_lock);
}",1,20,misc\variables.c,DumpVariables,,false,1371,1379,DumpVariables,,,65,void DumpVariables (vlc_object_t*)
137291,METHOD,misc\variables.c:<global>,TYPE_DECL,"static void TwalkGetNames(const void *data, const VISIT which, const int depth)
{
    if (which != postorder && which != leaf)
        return;
    (void) depth;

    const variable_t *var = *(const variable_t **)data;
    DECL_ARRAY(char *) *names = twalk_ctx;
    char *dup = strdup(var->psz_name);
    if (dup != NULL)
        ARRAY_APPEND(*names, dup);
}",1,1,misc\variables.c,TwalkGetNames,,false,1383,1394,TwalkGetNames,,,67,"void TwalkGetNames (void*,VISIT,int)"
137335,METHOD,misc\variables.c:<global>,TYPE_DECL,"char **var_GetAllNames(vlc_object_t *obj)
{
    vlc_object_internals_t *priv = vlc_internals(obj);

    DECL_ARRAY(char *) names;
    ARRAY_INIT(names);

    twalk_ctx = &names;
    vlc_mutex_lock(&priv->var_lock);
    twalk(priv->var_root, TwalkGetNames);
    vlc_mutex_unlock(&priv->var_lock);

    if (names.i_size == 0)
        return NULL;
    ARRAY_APPEND(names, NULL);
    return names.p_elems;
}",1,35,misc\variables.c,var_GetAllNames,,false,1396,1412,var_GetAllNames,,,68,char** var_GetAllNames (vlc_object_t*)
137397,METHOD,misc\variables.h:<global>,TYPE_DECL,<global>,1,6,misc\variables.h,misc\variables.h:<global>,,false,1,78,<global>,,,1,
137417,METHOD,misc\variables.h:<global>,TYPE_DECL,void DumpVariables(vlc_object_t *obj);,6,37,misc\variables.h,DumpVariables,,false,63,63,DumpVariables,,,5,void DumpVariables (vlc_object_t*)
137422,METHOD,misc\variables.h:<global>,TYPE_DECL,extern void var_DestroyAll( vlc_object_t * );,13,44,misc\variables.h,var_DestroyAll,,false,65,65,var_DestroyAll,,,6,void var_DestroyAll (vlc_object_t*)
137427,METHOD,misc\variables.h:<global>,TYPE_DECL,char **var_GetAllNames(vlc_object_t *);,6,38,misc\variables.h,var_GetAllNames,,false,76,76,var_GetAllNames,,,7,char** var_GetAllNames (vlc_object_t*)
137445,METHOD,misc\xml.c:<global>,TYPE_DECL,<global>,1,25,misc\xml.c,misc\xml.c:<global>,,false,1,127,<global>,,,1,
137447,METHOD,misc\xml.c:<global>,TYPE_DECL,"xml_t *xml_Create( vlc_object_t *p_this )
{
    xml_t *p_xml;

    p_xml = vlc_custom_create( p_this, sizeof( *p_xml ), ""xml"" );

    p_xml->p_module = module_need( p_xml, ""xml"", NULL, false );
    if( !p_xml->p_module )
    {
        vlc_object_release( p_xml );
        msg_Err( p_this, ""XML provider not found"" );
        return NULL;
    }

    return p_xml;
}",1,12,misc\xml.c,xml_Create,,false,39,54,xml_Create,,,1,xml_t xml_Create (vlc_object_t*)
137490,METHOD,misc\xml.c:<global>,TYPE_DECL,"void xml_Delete( xml_t *p_xml )
{
    module_unneed( p_xml, p_xml->p_module );
    vlc_object_release( p_xml );
}",1,1,misc\xml.c,xml_Delete,,false,59,63,xml_Delete,,,2,void xml_Delete (xml_t*)
137502,METHOD,misc\xml.c:<global>,TYPE_DECL,"xml_reader_t *xml_ReaderCreate(vlc_object_t *obj, stream_t *stream)
{
    xml_reader_t *reader;

    reader = vlc_custom_create(obj, sizeof(*reader), ""xml reader"");

    reader->p_stream = stream;
    reader->p_module = module_need(reader, ""xml reader"", NULL, false);
    if (unlikely(reader->p_module == NULL))
    {
        msg_Err(reader, ""XML reader not found"");
        vlc_object_release(reader);
        return NULL;
    }
    return reader;
}",1,13,misc\xml.c,xml_ReaderCreate,,false,73,88,xml_ReaderCreate,,,3,"xml_reader_t xml_ReaderCreate (vlc_object_t*,stream_t*)"
137552,METHOD,misc\xml.c:<global>,TYPE_DECL,"void xml_ReaderDelete(xml_reader_t *reader)
{
    if (reader->p_stream)
        module_stop(reader, reader->p_module);
    vlc_object_release(reader);
}",1,1,misc\xml.c,xml_ReaderDelete,,false,95,100,xml_ReaderDelete,,,4,void xml_ReaderDelete (xml_reader_t*)
137569,METHOD,misc\xml.c:<global>,TYPE_DECL,"xml_reader_t *xml_ReaderReset(xml_reader_t *reader, stream_t *stream)
{
    if (reader->p_stream)
        module_stop(reader, reader->p_module);

    reader->p_stream = stream;
    if ((stream != NULL) && module_start(reader, reader->p_module))
    {
        vlc_object_release(reader);
        return NULL;
    }
    return reader;
}",1,1,misc\xml.c,xml_ReaderReset,,false,115,127,xml_ReaderReset,,,5,"xml_reader_t xml_ReaderReset (xml_reader_t*,stream_t*)"
137622,METHOD,missing.c:<global>,TYPE_DECL,<global>,1,26,missing.c,missing.c:<global>,,false,1,289,<global>,,,1,
137624,METHOD,missing.c:<global>,TYPE_DECL,"void sdp_AddMedia (struct vlc_memstream *sdp, const char *type, const char *protocol,
                    int dport, unsigned pt, bool bw_indep, unsigned bw,
                    const char *ptname, unsigned clockrate, unsigned channels,
                    const char *fmtp)
{
    VLC_UNUSED (sdp); VLC_UNUSED (type); VLC_UNUSED (protocol);
    VLC_UNUSED (dport); VLC_UNUSED (pt); VLC_UNUSED (bw_indep);
    VLC_UNUSED (bw); VLC_UNUSED (ptname); VLC_UNUSED (clockrate);
    VLC_UNUSED (channels); VLC_UNUSED (fmtp);
    assert (sdp == NULL);
}",1,1,missing.c,sdp_AddMedia,,false,44,54,sdp_AddMedia,,,1,"void sdp_AddMedia (vlc_memstream*,char*,char*,int,unsigned,bool,unsigned,char*,unsigned,unsigned,char*)"
137665,METHOD,missing.c:<global>,TYPE_DECL,"void sdp_AddAttribute (struct vlc_memstream *sdp, const char *name, const char *fmt, ...)
{
    VLC_UNUSED (sdp); VLC_UNUSED (name); VLC_UNUSED (fmt);
    assert (sdp == NULL);
}",1,1,missing.c,sdp_AddAttribute,,false,56,60,sdp_AddAttribute,,,2,"void sdp_AddAttribute (vlc_memstream*,char*,char*...)"
137682,METHOD,missing.c:<global>,TYPE_DECL,"int sout_AccessOutControl (sout_access_out_t *out, int query, ...)
{
    VLC_UNUSED (out); VLC_UNUSED (query);
    vlc_assert_unreachable ();
}",1,1,missing.c,sout_AccessOutControl,,false,62,66,sout_AccessOutControl,,,3,"int sout_AccessOutControl (sout_access_out_t*,int...)"
137693,METHOD,missing.c:<global>,TYPE_DECL,"void sout_AccessOutDelete (sout_access_out_t *out)
{
    VLC_UNUSED (out);
    vlc_assert_unreachable ();
}",1,1,missing.c,sout_AccessOutDelete,,false,68,72,sout_AccessOutDelete,,,4,void sout_AccessOutDelete (sout_access_out_t*)
137701,METHOD,missing.c:<global>,TYPE_DECL,"sout_access_out_t *sout_AccessOutNew (vlc_object_t *obj,
                                      const char *access, const char *name)
{
    VLC_UNUSED (access); VLC_UNUSED (name);
    msg_Err (obj, ""Output support not compiled-in!"");
    return NULL;
}",1,1,missing.c,sout_AccessOutNew,,false,75,81,sout_AccessOutNew,,,5,"sout_access_out_t sout_AccessOutNew (vlc_object_t*,char*,char*)"
137717,METHOD,missing.c:<global>,TYPE_DECL,"ssize_t sout_AccessOutRead (sout_access_out_t *out, block_t *block)
{
    VLC_UNUSED (out); VLC_UNUSED (block);
    vlc_assert_unreachable ();
}",1,1,missing.c,sout_AccessOutRead,,false,83,87,sout_AccessOutRead,,,6,"ssize_t sout_AccessOutRead (sout_access_out_t*,block_t*)"
137728,METHOD,missing.c:<global>,TYPE_DECL,"int sout_AccessOutSeek (sout_access_out_t *out, off_t offset)
{
    VLC_UNUSED (out); VLC_UNUSED (offset);
    vlc_assert_unreachable ();
}",1,1,missing.c,sout_AccessOutSeek,,false,89,93,sout_AccessOutSeek,,,7,"int sout_AccessOutSeek (sout_access_out_t*,off_t)"
137739,METHOD,missing.c:<global>,TYPE_DECL,"ssize_t sout_AccessOutWrite (sout_access_out_t *out, block_t *block)
{
    VLC_UNUSED (out); VLC_UNUSED (block);
    vlc_assert_unreachable ();
}",1,1,missing.c,sout_AccessOutWrite,,false,95,99,sout_AccessOutWrite,,,8,"ssize_t sout_AccessOutWrite (sout_access_out_t*,block_t*)"
137750,METHOD,missing.c:<global>,TYPE_DECL,"session_descriptor_t *sout_AnnounceRegisterSDP (vlc_object_t *obj,
                                                const char *sdp,
                                                const char *dst)
{
    VLC_UNUSED (sdp); VLC_UNUSED (dst);
    msg_Err (obj, ""SDP export not compiled-in!"");
    return NULL;
}",1,1,missing.c,sout_AnnounceRegisterSDP,,false,102,109,sout_AnnounceRegisterSDP,,,9,"session_descriptor_t sout_AnnounceRegisterSDP (vlc_object_t*,char*,char*)"
137766,METHOD,missing.c:<global>,TYPE_DECL,"void sout_AnnounceUnRegister (vlc_object_t *obj, session_descriptor_t *d)
{
    VLC_UNUSED (obj); VLC_UNUSED (d);
    vlc_assert_unreachable ();
}",1,1,missing.c,sout_AnnounceUnRegister,,false,112,116,sout_AnnounceUnRegister,,,10,"void sout_AnnounceUnRegister (vlc_object_t*,session_descriptor_t*)"
137777,METHOD,missing.c:<global>,TYPE_DECL,"encoder_t *sout_EncoderCreate( vlc_object_t *p_this )
{
    msg_Err (p_this, ""Encoding support not compiled-in!"");
    return NULL;
}",1,1,missing.c,sout_EncoderCreate,,false,119,123,sout_EncoderCreate,,,11,encoder_t sout_EncoderCreate (vlc_object_t*)
137787,METHOD,missing.c:<global>,TYPE_DECL,"sout_input_t *sout_MuxAddStream( sout_mux_t *mux, const es_format_t *fmt )
{
    VLC_UNUSED (mux); VLC_UNUSED (fmt);
    vlc_assert_unreachable ();
}",1,1,missing.c,sout_MuxAddStream,,false,125,129,sout_MuxAddStream,,,12,"sout_input_t sout_MuxAddStream (sout_mux_t*,es_format_t*)"
137798,METHOD,missing.c:<global>,TYPE_DECL,"void sout_MuxDelete (sout_mux_t *mux)
{
    VLC_UNUSED (mux);
    vlc_assert_unreachable ();
}",1,1,missing.c,sout_MuxDelete,,false,131,135,sout_MuxDelete,,,13,void sout_MuxDelete (sout_mux_t*)
137806,METHOD,missing.c:<global>,TYPE_DECL,"void sout_MuxDeleteStream (sout_mux_t *mux, sout_input_t *input)
{
    VLC_UNUSED (mux); VLC_UNUSED (input);
    vlc_assert_unreachable ();
}",1,1,missing.c,sout_MuxDeleteStream,,false,137,141,sout_MuxDeleteStream,,,14,"void sout_MuxDeleteStream (sout_mux_t*,sout_input_t*)"
137817,METHOD,missing.c:<global>,TYPE_DECL,"int sout_MuxGetStream (sout_mux_t *p_mux, unsigned int i_blocks, mtime_t *pi_dts)
{
    VLC_UNUSED (p_mux); VLC_UNUSED (i_blocks); VLC_UNUSED (pi_dts);
    vlc_assert_unreachable ();
}",1,1,missing.c,sout_MuxGetStream,,false,143,147,sout_MuxGetStream,,,15,"int sout_MuxGetStream (sout_mux_t*,unsigned int,mtime_t*)"
137831,METHOD,missing.c:<global>,TYPE_DECL,"sout_mux_t *sout_MuxNew (sout_instance_t *instance, const char *mux,
                         sout_access_out_t *out)
{
    VLC_UNUSED (instance); VLC_UNUSED (mux); VLC_UNUSED (out);
    vlc_assert_unreachable ();
}",1,1,missing.c,sout_MuxNew,,false,149,154,sout_MuxNew,,,16,"sout_mux_t sout_MuxNew (sout_instance_t*,char*,sout_access_out_t*)"
137845,METHOD,missing.c:<global>,TYPE_DECL,"int sout_MuxSendBuffer (sout_mux_t *mux, sout_input_t *input, block_t *block)
{
    VLC_UNUSED (mux); VLC_UNUSED (input); VLC_UNUSED (block);
    vlc_assert_unreachable ();
}",1,1,missing.c,sout_MuxSendBuffer,,false,156,160,sout_MuxSendBuffer,,,17,"int sout_MuxSendBuffer (sout_mux_t*,sout_input_t*,block_t*)"
137859,METHOD,missing.c:<global>,TYPE_DECL,"void sout_MuxFlush( sout_mux_t *mux, sout_input_t *input )
{
    VLC_UNUSED (mux); VLC_UNUSED (input);
    vlc_assert_unreachable ();
}",1,1,missing.c,sout_MuxFlush,,false,162,166,sout_MuxFlush,,,18,"void sout_MuxFlush (sout_mux_t*,sout_input_t*)"
137870,METHOD,missing.c:<global>,TYPE_DECL,"void sout_StreamChainDelete (sout_stream_t *p_first, sout_stream_t *p_last)
{
    VLC_UNUSED (p_first); VLC_UNUSED (p_last);
    vlc_assert_unreachable ();
}",1,1,missing.c,sout_StreamChainDelete,,false,168,172,sout_StreamChainDelete,,,19,"void sout_StreamChainDelete (sout_stream_t*,sout_stream_t*)"
137881,METHOD,missing.c:<global>,TYPE_DECL,"sout_stream_t *sout_StreamChainNew (sout_instance_t *p_sout, const char *psz_chain,
                                    sout_stream_t *p_next,
                                    sout_stream_t **pp_last)
{
    VLC_UNUSED (p_sout); VLC_UNUSED (psz_chain); VLC_UNUSED (p_next);
    VLC_UNUSED (pp_last);
    vlc_assert_unreachable ();
}",1,1,missing.c,sout_StreamChainNew,,false,174,181,sout_StreamChainNew,,,20,"sout_stream_t sout_StreamChainNew (sout_instance_t*,char*,sout_stream_t*,sout_stream_t**)"
137898,METHOD,missing.c:<global>,TYPE_DECL,"int vlc_sdp_Start (struct vlc_memstream *sdp, vlc_object_t *obj, const char *cfg,
                     const struct sockaddr *src, size_t srclen,
                     const struct sockaddr *addr, size_t addrlen)
{
    VLC_UNUSED (obj); VLC_UNUSED (cfg); VLC_UNUSED (src); VLC_UNUSED (srclen);
    VLC_UNUSED (addr); VLC_UNUSED (addrlen);
    return 0;
}",1,1,missing.c,vlc_sdp_Start,,false,183,190,vlc_sdp_Start,,,21,"int vlc_sdp_Start (vlc_memstream*,vlc_object_t*,char*,sockaddr*,size_t,sockaddr*,size_t)"
137923,METHOD,missing.c:<global>,TYPE_DECL,"int vlm_Control (vlm_t *vlm, int query, ...)
{
    VLC_UNUSED (query);
    VLC_UNUSED (vlm);
    vlc_assert_unreachable ();
}",1,1,missing.c,vlm_Control,,false,196,201,vlm_Control,,,22,"int vlm_Control (vlm_t*,int...)"
137934,METHOD,missing.c:<global>,TYPE_DECL,"void vlm_Delete (vlm_t *vlm)
{
    VLC_UNUSED (vlm);
    vlc_assert_unreachable ();
}",1,1,missing.c,vlm_Delete,,false,203,207,vlm_Delete,,,23,void vlm_Delete (vlm_t*)
137942,METHOD,missing.c:<global>,TYPE_DECL,"int vlm_ExecuteCommand (vlm_t *vlm, const char *cmd, vlm_message_t **pm)
{
    VLC_UNUSED (vlm);
    VLC_UNUSED (cmd);
    VLC_UNUSED (pm);
    vlc_assert_unreachable ();
}",1,1,missing.c,vlm_ExecuteCommand,,false,209,215,vlm_ExecuteCommand,,,24,"int vlm_ExecuteCommand (vlm_t*,char*,vlm_message_t**)"
137956,METHOD,missing.c:<global>,TYPE_DECL,"vlm_message_t *vlm_MessageAdd (vlm_message_t *a, vlm_message_t *b)
{
    VLC_UNUSED (a);
    VLC_UNUSED (b);
    vlc_assert_unreachable ();
}",1,1,missing.c,vlm_MessageAdd,,false,217,222,vlm_MessageAdd,,,25,"vlm_message_t vlm_MessageAdd (vlm_message_t*,vlm_message_t*)"
137967,METHOD,missing.c:<global>,TYPE_DECL,"void vlm_MessageDelete (vlm_message_t *m)
{
    VLC_UNUSED (m);
    vlc_assert_unreachable ();
}",1,1,missing.c,vlm_MessageDelete,,false,224,228,vlm_MessageDelete,,,26,void vlm_MessageDelete (vlm_message_t*)
137975,METHOD,missing.c:<global>,TYPE_DECL,"vlm_message_t *vlm_MessageSimpleNew (const char *a)
{
    VLC_UNUSED (a);
    return NULL;
}",1,1,missing.c,vlm_MessageSimpleNew,,false,230,234,vlm_MessageSimpleNew,,,27,vlm_message_t vlm_MessageSimpleNew (char*)
137984,METHOD,missing.c:<global>,TYPE_DECL,"vlm_message_t *vlm_MessageNew (const char *a, const char *fmt, ...)
{
    VLC_UNUSED (a);
    VLC_UNUSED (fmt);
    return vlm_MessageSimpleNew (a);
}",1,1,missing.c,vlm_MessageNew,,false,236,241,vlm_MessageNew,,,28,"vlm_message_t vlm_MessageNew (char*,char*...)"
137997,METHOD,missing.c:<global>,TYPE_DECL,"vlm_t *vlm_New (vlc_object_t *obj)
{
     msg_Err (obj, ""VLM not compiled-in!"");
     return NULL;
}",1,1,missing.c,vlm_New,,false,244,248,vlm_New,,,29,vlm_t vlm_New (vlc_object_t*)
138007,METHOD,missing.c:<global>,TYPE_DECL,"update_t *(update_New)(vlc_object_t *obj)
{
    (void) obj;
    return NULL;
}",1,1,missing.c,,,false,254,258,update_New,,,30,update_t (vlc_object_t*)
138017,METHOD,missing.c:<global>,TYPE_DECL,"void update_Delete(update_t *u)
{
    (void) u;
    vlc_assert_unreachable();
}",1,1,missing.c,update_Delete,,false,260,264,update_Delete,,,31,void update_Delete (update_t*)
138026,METHOD,missing.c:<global>,TYPE_DECL,"void update_Check(update_t *u, void (*cb)(void *, bool), void *opaque)
{
    (void) u; (void) cb; (void) opaque;
    vlc_assert_unreachable();
}",1,1,missing.c,update_Check,,false,266,270,update_Check,,,32,"void update_Check (update_t*,void,void*)"
138043,METHOD,missing.c:<global>,TYPE_DECL,"bool update_NeedUpgrade(update_t *u)
{
    (void) u;
    vlc_assert_unreachable();
}",1,1,missing.c,update_NeedUpgrade,,false,272,276,update_NeedUpgrade,,,33,bool update_NeedUpgrade (update_t*)
138052,METHOD,missing.c:<global>,TYPE_DECL,"void update_Download(update_t *u, const char *dir)
{
    (void) u; (void) dir;
    vlc_assert_unreachable();
}",1,1,missing.c,update_Download,,false,278,282,update_Download,,,34,"void update_Download (update_t*,char*)"
138065,METHOD,missing.c:<global>,TYPE_DECL,"update_release_t *update_GetRelease(update_t *u)
{
    (void) u;
    vlc_assert_unreachable();
}",1,1,missing.c,update_GetRelease,,false,284,288,update_GetRelease,,,35,update_release_t update_GetRelease (update_t*)
138111,METHOD,modules\bank.c:<global>,TYPE_DECL,<global>,1,23,modules\bank.c,modules\bank.c:<global>,,false,1,751,<global>,,,1,
138118,METHOD,modules\bank.c:<global>,TYPE_DECL,"static int vlc_modcap_cmp(const void *a, const void *b)
{
    const vlc_modcap_t *capa = a, *capb = b;
    return strcmp(capa->name, capb->name);
}",1,1,modules\bank.c,vlc_modcap_cmp,,false,59,63,vlc_modcap_cmp,,,3,"int vlc_modcap_cmp (void*,void*)"
138140,METHOD,modules\bank.c:<global>,TYPE_DECL,"static void vlc_modcap_free(void *data)
{
    vlc_modcap_t *cap = data;

    free(cap->modv);
    free(cap->name);
    free(cap);
}",1,1,modules\bank.c,vlc_modcap_free,,false,65,72,vlc_modcap_free,,,4,void vlc_modcap_free (void*)
138159,METHOD,modules\bank.c:<global>,TYPE_DECL,"static int vlc_module_cmp (const void *a, const void *b)
{
    const module_t *const *ma = a, *const *mb = b;
    /* Note that qsort() uses _ascending_ order,
     * so the smallest module is the one with the biggest score. */
    return (*mb)->i_score - (*ma)->i_score;
}",1,1,modules\bank.c,vlc_module_cmp,,false,74,80,vlc_module_cmp,,,5,"int vlc_module_cmp (void*,void*)"
138183,METHOD,modules\bank.c:<global>,TYPE_DECL,"static void vlc_modcap_sort(const void *node, const VISIT which,
                            const int depth)
{
    vlc_modcap_t *const *cp = node, *cap = *cp;

    if (which != postorder && which != leaf)
        return;

    qsort(cap->modv, cap->modc, sizeof (*cap->modv), vlc_module_cmp);
    (void) depth;
}",1,1,modules\bank.c,vlc_modcap_sort,,false,82,92,vlc_modcap_sort,,,6,"void vlc_modcap_sort (void*,VISIT,int)"
138242,METHOD,modules\bank.c:<global>,TYPE_DECL,"static int vlc_module_store(module_t *mod)
{
    const char *name = module_get_capability(mod);
    vlc_modcap_t *cap = malloc(sizeof (*cap));
    if (unlikely(cap == NULL))
        return -1;

    cap->name = strdup(name);
    cap->modv = NULL;
    cap->modc = 0;

    if (unlikely(cap->name == NULL))
        goto error;

    vlc_modcap_t **cp = tsearch(cap, &modules.caps_tree, vlc_modcap_cmp);
    if (unlikely(cp == NULL))
        goto error;

    if (*cp != cap)
    {
        vlc_modcap_free(cap);
        cap = *cp;
    }

    module_t **modv = realloc(cap->modv, sizeof (*modv) * (cap->modc + 1));
    if (unlikely(modv == NULL))
        return -1;

    cap->modv = modv;
    cap->modv[cap->modc] = mod;
    cap->modc++;
    return 0;
error:
    vlc_modcap_free(cap);
    return -1;
}",1,1,modules\bank.c,vlc_module_store,,false,107,142,vlc_module_store,,,12,int vlc_module_store (module_t*)
138373,METHOD,modules\bank.c:<global>,TYPE_DECL,"static void vlc_plugin_store(vlc_plugin_t *lib)
{
    /*vlc_assert_locked (&modules.lock);*/

    lib->next = vlc_plugins;
    vlc_plugins = lib;

    for (module_t *m = lib->module; m != NULL; m = m->next)
        vlc_module_store(m);
}",1,1,modules\bank.c,vlc_plugin_store,,false,147,156,vlc_plugin_store,,,13,void vlc_plugin_store (vlc_plugin_t*)
138404,METHOD,modules\bank.c:<global>,TYPE_DECL,"static vlc_plugin_t *module_InitStatic(vlc_plugin_cb entry)
{
    /* Initializes the statically-linked library */
    vlc_plugin_t *lib = vlc_plugin_describe (entry);
    if (unlikely(lib == NULL))
        return NULL;

#ifdef HAVE_DYNAMIC_PLUGINS
    atomic_init(&lib->loaded, true);
    lib->unloadable = false;
#endif
    return lib;
}",1,1,modules\bank.c,module_InitStatic,,false,161,173,module_InitStatic,,,14,vlc_plugin_t module_InitStatic (vlc_plugin_cb)
138426,METHOD,modules\bank.c:<global>,TYPE_DECL,"static void module_InitStaticModules(void)
{
    if (!vlc_static_modules)
        return;

    for (unsigned i = 0; vlc_static_modules[i]; i++)
    {
        vlc_plugin_t *lib = module_InitStatic(vlc_static_modules[i]);
        if (likely(lib != NULL))
            vlc_plugin_store(lib);
    }
}",1,1,modules\bank.c,module_InitStaticModules,,false,183,194,module_InitStaticModules,,,17,void module_InitStaticModules (void)
138463,METHOD,modules\bank.c:<global>,TYPE_DECL,"int module_Map(vlc_object_t *obj, vlc_plugin_t *plugin)
{
    (void) obj; (void) plugin;
    return 0;
}",1,1,modules\bank.c,module_Map,,false,560,564,module_Map,,,18,"int module_Map (vlc_object_t*,vlc_plugin_t*)"
138477,METHOD,modules\bank.c:<global>,TYPE_DECL,"static void module_Unmap(vlc_plugin_t *plugin)
{
    (void) plugin;
}",1,1,modules\bank.c,module_Unmap,,false,566,569,module_Unmap,,,19,void module_Unmap (vlc_plugin_t*)
138485,METHOD,modules\bank.c:<global>,TYPE_DECL,"void module_InitBank (void)
{
    vlc_mutex_lock (&modules.lock);

    if (modules.usage == 0)
    {
        /* Fills the module bank structure with the core module infos.
         * This is very useful as it will allow us to consider the core
         * library just as another module, and for instance the configuration
         * options of core will be available in the module bank structure just
         * as for every other module. */
        vlc_plugin_t *plugin = module_InitStatic(vlc_entry__core);
        if (likely(plugin != NULL))
            vlc_plugin_store(plugin);
        config_SortConfig ();
    }
    modules.usage++;

    /* We do retain the module bank lock until the plugins are loaded as well.
     * This is ugly, this staged loading approach is needed: LibVLC gets
     * some configuration parameters relevant to loading the plugins from
     * the core (builtin) module. The module bank becomes shared read-only data
     * once it is ready, so we need to fully seria...",1,1,modules\bank.c,module_InitBank,,false,578,604,module_InitBank,,,20,void module_InitBank (void)
138520,METHOD,modules\bank.c:<global>,TYPE_DECL,"void module_EndBank (bool b_plugins)
{
    vlc_plugin_t *libs = NULL;
    block_t *caches = NULL;
    void *caps_tree = NULL;

    /* If plugins were _not_ loaded, then the caller still has the bank lock
     * from module_InitBank(). */
    if( b_plugins )
        vlc_mutex_lock (&modules.lock);
    /*else
        vlc_assert_locked (&modules.lock); not for static mutexes :( */

    assert (modules.usage > 0);
    if (--modules.usage == 0)
    {
        config_UnsortConfig ();
        libs = vlc_plugins;
        caches = modules.caches;
        caps_tree = modules.caps_tree;
        vlc_plugins = NULL;
        modules.caches = NULL;
        modules.caps_tree = NULL;
    }
    vlc_mutex_unlock (&modules.lock);

    tdestroy(caps_tree, vlc_modcap_free);

    while (libs != NULL)
    {
        vlc_plugin_t *lib = libs;

        libs = lib->next;
        module_Unmap(lib);
        vlc_plugin_destroy(lib);
    }

    block_ChainRelease(caches);
}",1,1,modules\bank.c,module_EndBank,,false,610,648,module_EndBank,,,21,void module_EndBank (bool)
138614,METHOD,modules\bank.c:<global>,TYPE_DECL,"size_t module_LoadPlugins (vlc_object_t *obj)
{
    /*vlc_assert_locked (&modules.lock); not for static mutexes :( */

    if (modules.usage == 1)
    {
        module_InitStaticModules ();
#ifdef HAVE_DYNAMIC_PLUGINS
        msg_Dbg (obj, ""searching plug-in modules"");
        AllocateAllPlugins (obj);
#endif
        config_UnsortConfig ();
        config_SortConfig ();

        twalk(modules.caps_tree, vlc_modcap_sort);
    }
    vlc_mutex_unlock (&modules.lock);

    size_t count;
    module_t **list = module_list_get (&count);
    module_list_free (list);
    msg_Dbg (obj, ""plug-ins loaded: %zu modules"", count);
    return count;
}",1,1,modules\bank.c,module_LoadPlugins,,false,658,681,module_LoadPlugins,,,22,size_t module_LoadPlugins (vlc_object_t*)
138654,METHOD,modules\bank.c:<global>,TYPE_DECL,"void module_list_free (module_t **list)
{
    free (list);
}",1,1,modules\bank.c,module_list_free,,false,689,692,module_list_free,,,23,void module_list_free (module_t**)
138661,METHOD,modules\bank.c:<global>,TYPE_DECL,"module_t **module_list_get (size_t *n)
{
    module_t **tab = NULL;
    size_t i = 0;

    assert (n != NULL);

    for (vlc_plugin_t *lib = vlc_plugins; lib != NULL; lib = lib->next)
    {
        module_t **nt = realloc(tab, (i + lib->modules_count) * sizeof (*tab));
        if (unlikely(nt == NULL))
        {
            free (tab);
            *n = 0;
            return NULL;
        }

        tab = nt;
        for (module_t *m = lib->module; m != NULL; m = m->next)
            tab[i++] = m;
    }
    *n = i;
    return tab;
}",1,1,modules\bank.c,module_list_get,,false,700,723,module_list_get,,,24,module_t module_list_get (size_t*)
138752,METHOD,modules\bank.c:<global>,TYPE_DECL,"ssize_t module_list_cap (module_t ***restrict list, const char *name)
{
    const vlc_modcap_t **cp = tfind(&name, &modules.caps_tree, vlc_modcap_cmp);
    if (cp == NULL)
    {
        *list = NULL;
        return 0;
    }

    const vlc_modcap_t *cap = *cp;
    size_t n = cap->modc;
    module_t **tab = vlc_alloc (n, sizeof (*tab));
    *list = tab;
    if (unlikely(tab == NULL))
        return -1;

    memcpy(tab, cap->modv, sizeof (*tab) * n);
    return n;
}",1,1,modules\bank.c,module_list_cap,,false,733,751,module_list_cap,,,25,"ssize_t module_list_cap (module_t***,char*)"
138861,METHOD,modules\cache.c:<global>,TYPE_DECL,<global>,1,23,modules\cache.c,modules\cache.c:<global>,,false,1,721,<global>,,,1,
138890,METHOD,modules\entry.c:<global>,TYPE_DECL,<global>,1,1,modules\entry.c,modules\entry.c:<global>,,false,1,633,<global>,,,1,
138892,METHOD,modules\entry.c:<global>,TYPE_DECL,"module_t *vlc_module_create(vlc_plugin_t *plugin)
{
    module_t *module = malloc (sizeof (*module));
    if (module == NULL)
        return NULL;

    /* NOTE XXX: For backward compatibility with preferences UIs, the first
     * module must stay first. That defines under which module, the
     * configuration items of the plugin belong. The order of the following
     * entries is irrelevant. */
    module_t *parent = plugin->module;
    if (parent == NULL)
    {
        module->next = NULL;
        plugin->module = module;
    }
    else
    {
        module->next = parent->next;
        parent->next = module;
    }

    plugin->modules_count++;
    module->plugin = plugin;

    module->psz_shortname = NULL;
    module->psz_longname = NULL;
    module->psz_help = NULL;
    module->pp_shortcuts = NULL;
    module->i_shortcuts = 0;
    module->psz_capability = NULL;
    module->i_score = (parent != NULL) ? parent->i_score : 1;
    module->activate_name = NULL;
    module->deactivat...",1,1,modules\entry.c,vlc_module_create,,false,41,78,vlc_module_create,,,1,module_t vlc_module_create (vlc_plugin_t*)
139019,METHOD,modules\entry.c:<global>,TYPE_DECL,"void vlc_module_destroy (module_t *module)
{
    while (module != NULL)
    {
        module_t *next = module->next;

        free(module->pp_shortcuts);
        free(module);
        module = next;
    }
}",1,1,modules\entry.c,vlc_module_destroy,,false,83,93,vlc_module_destroy,,,2,void vlc_module_destroy (module_t*)
139044,METHOD,modules\entry.c:<global>,TYPE_DECL,"vlc_plugin_t *vlc_plugin_create(void)
{
    vlc_plugin_t *plugin = malloc(sizeof (*plugin));
    if (unlikely(plugin == NULL))
        return NULL;

    plugin->modules_count = 0;
    plugin->textdomain = NULL;
    plugin->conf.items = NULL;
    plugin->conf.size = 0;
    plugin->conf.count = 0;
    plugin->conf.booleans = 0;
#ifdef HAVE_DYNAMIC_PLUGINS
    plugin->abspath = NULL;
    atomic_init(&plugin->loaded, false);
    plugin->unloadable = true;
    plugin->handle = NULL;
    plugin->abspath = NULL;
    plugin->path = NULL;
#endif
    plugin->module = NULL;

    return plugin;
}",1,1,modules\entry.c,vlc_plugin_create,,false,95,118,vlc_plugin_create,,,3,vlc_plugin_t vlc_plugin_create (void)
139109,METHOD,modules\entry.c:<global>,TYPE_DECL,"void vlc_plugin_destroy(vlc_plugin_t *plugin)
{
    assert(plugin != NULL);
#ifdef HAVE_DYNAMIC_PLUGINS
    assert(!plugin->unloadable || !atomic_load(&plugin->loaded));
#endif

    if (plugin->module != NULL)
        vlc_module_destroy(plugin->module);

    config_Free(plugin->conf.items, plugin->conf.size);
#ifdef HAVE_DYNAMIC_PLUGINS
    free(plugin->abspath);
    free(plugin->path);
#endif
    free(plugin);
}",1,1,modules\entry.c,vlc_plugin_destroy,,false,125,141,vlc_plugin_destroy,,,4,void vlc_plugin_destroy (vlc_plugin_t*)
139142,METHOD,modules\entry.c:<global>,TYPE_DECL,"static module_config_t *vlc_config_create(vlc_plugin_t *plugin, int type)
{
    unsigned confsize = plugin->conf.size;
    module_config_t *tab = plugin->conf.items;

    if ((confsize & 0xf) == 0)
    {
        tab = realloc_or_free (tab, (confsize + 17) * sizeof (*tab));
        if (tab == NULL)
            return NULL;

        plugin->conf.items = tab;
    }

    memset (tab + confsize, 0, sizeof (tab[confsize]));
    tab += confsize;
    tab->owner = plugin;

    if (IsConfigIntegerType (type))
    {
        tab->max.i = INT64_MAX;
        tab->min.i = INT64_MIN;
    }
    else if( IsConfigFloatType (type))
    {
        tab->max.f = FLT_MAX;
        tab->min.f = -FLT_MAX;
    }
    tab->i_type = type;

    if (CONFIG_ITEM(type))
    {
        plugin->conf.count++;
        if (type == CONFIG_ITEM_BOOL)
            plugin->conf.booleans++;
    }
    plugin->conf.size++;

    return tab;
}",1,8,modules\entry.c,vlc_config_create,,false,143,182,vlc_config_create,,,5,"module_config_t vlc_config_create (vlc_plugin_t*,int)"
139296,METHOD,modules\entry.c:<global>,TYPE_DECL,"static int vlc_plugin_desc_cb(void *ctx, void *tgt, int propid, ...)
{
    vlc_plugin_t *plugin = ctx;
    module_t *module = tgt;
    module_config_t *item = tgt;
    va_list ap;
    int ret = 0;

    va_start (ap, propid);
    switch (propid)
    {
        case VLC_MODULE_CREATE:
        {
            module_t *super = plugin->module;
            module_t *submodule = vlc_module_create(plugin);
            if (unlikely(submodule == NULL))
            {
                ret = -1;
                break;
            }

            *(va_arg (ap, module_t **)) = submodule;
            if (super == NULL)
                break;

            /* Inheritance. Ugly!! */
            submodule->pp_shortcuts = xmalloc (sizeof ( *submodule->pp_shortcuts ));
            submodule->pp_shortcuts[0] = super->pp_shortcuts[0];
            submodule->i_shortcuts = 1; /* object name */

            submodule->psz_shortname = super->psz_shortname;
            submodule->psz_longname = super->psz_longname;...",1,42,modules\entry.c,vlc_plugin_desc_cb,,false,190,460,vlc_plugin_desc_cb,,,6,"int vlc_plugin_desc_cb (void*,void*,int...)"
139920,METHOD,modules\entry.c:<global>,TYPE_DECL,"vlc_plugin_t *vlc_plugin_describe(vlc_plugin_cb entry)
{
    vlc_plugin_t *plugin = vlc_plugin_create();
    if (unlikely(plugin == NULL))
        return NULL;

    if (entry(vlc_plugin_desc_cb, plugin) != 0)
    {
        vlc_plugin_destroy(plugin); /* partially initialized plug-in... */
        plugin = NULL;
    }
    return plugin;
}",1,1,modules\entry.c,vlc_plugin_describe,,false,467,479,vlc_plugin_describe,,,7,vlc_plugin_t vlc_plugin_describe (vlc_plugin_cb)
139954,METHOD,modules\entry.c:<global>,TYPE_DECL,"static int vlc_plugin_symbol_compare(const void *a, const void *b)
{
    const struct vlc_plugin_symbol *sa = a , *sb = b;

    return strcmp(sa->name, sb->name);
}",1,1,modules\entry.c,vlc_plugin_symbol_compare,,false,487,492,vlc_plugin_symbol_compare,,,9,"int vlc_plugin_symbol_compare (void*,void*)"
139976,METHOD,modules\entry.c:<global>,TYPE_DECL,"static int vlc_plugin_gpa_cb(void *ctx, void *tgt, int propid, ...)
{
    void **rootp = ctx;
    const char *name;
    void *addr;

    (void) tgt;

    switch (propid)
    {
        case VLC_MODULE_CB_OPEN:
        case VLC_MODULE_CB_CLOSE:
        case VLC_CONFIG_LIST_CB:
        {
            va_list ap;

            va_start(ap, propid);
            name = va_arg(ap, const char *);
            addr = va_arg(ap, void *);
            va_end (ap);
            break;
        }
        default:
            return 0;
    }

    struct vlc_plugin_symbol *sym = malloc(sizeof (*sym));

    sym->name = name;
    sym->addr = addr;

    struct vlc_plugin_symbol **symp = tsearch(sym, rootp,
                                              vlc_plugin_symbol_compare);
    if (unlikely(symp == NULL))
    {   /* Memory error */
        free(sym);
        return -1;
    }

    if (*symp != sym)
    {   /* Duplicate symbol */
        assert((*symp)->addr == sym->addr);
        free(sym);
    }
    r...",1,1,modules\entry.c,vlc_plugin_gpa_cb,,false,500,545,vlc_plugin_gpa_cb,,,10,"int vlc_plugin_gpa_cb (void*,void*,int...)"
140068,METHOD,modules\entry.c:<global>,TYPE_DECL,"static void *vlc_plugin_get_symbols(vlc_plugin_cb entry)
{
    void *root = NULL;

    if (entry(vlc_plugin_gpa_cb, &root))
    {
        tdestroy(root, free);
        return NULL;
    }

    return root;
}",1,1,modules\entry.c,vlc_plugin_get_symbols,,false,557,568,vlc_plugin_get_symbols,,,11,void* vlc_plugin_get_symbols (vlc_plugin_cb)
140090,METHOD,modules\entry.c:<global>,TYPE_DECL,"static void vlc_plugin_free_symbols(void *root)
{
    tdestroy(root, free);
}",1,1,modules\entry.c,vlc_plugin_free_symbols,,false,570,573,vlc_plugin_free_symbols,,,12,void vlc_plugin_free_symbols (void*)
140098,METHOD,modules\entry.c:<global>,TYPE_DECL,"static int vlc_plugin_get_symbol(void *root, const char *name,
                                 void **restrict addrp)
{
    if (name == NULL)
    {   /* TODO: use this; do not define ""NULL"" as a name for NULL? */
        *addrp = NULL;
        return 0;
    }

    const struct vlc_plugin_symbol **symp = tfind(&name, &root,
                                                  vlc_plugin_symbol_compare);

    if (symp == NULL)
        return -1;

    *addrp = (*symp)->addr;
    return 0;
}",1,1,modules\entry.c,vlc_plugin_get_symbol,,false,575,592,vlc_plugin_get_symbol,,,13,"int vlc_plugin_get_symbol (void*,char*,void**)"
140142,METHOD,modules\entry.c:<global>,TYPE_DECL,"int vlc_plugin_resolve(vlc_plugin_t *plugin, vlc_plugin_cb entry)
{
    void *syms = vlc_plugin_get_symbols(entry);
    int ret = -1;

    /* Resolve modules activate/deactivate callbacks */
    for (module_t *module = plugin->module;
         module != NULL;
         module = module->next)
    {
        if (vlc_plugin_get_symbol(syms, module->activate_name,
                                  &module->pf_activate)
         || vlc_plugin_get_symbol(syms, module->deactivate_name,
                                  &module->pf_deactivate))
            goto error;
    }

    /* Resolve configuration callbacks */
    for (size_t i = 0; i < plugin->conf.size; i++)
    {
        module_config_t *item = plugin->conf.items + i;
        void *cb;

        if (item->list_cb_name == NULL)
            continue;
        if (vlc_plugin_get_symbol(syms, item->list_cb_name, &cb))
            goto error;

        if (IsConfigIntegerType (item->i_type))
            item->list.i_cb = cb;
        else
   ...",1,12,modules\entry.c,vlc_plugin_resolve,,false,594,633,vlc_plugin_resolve,,,14,"int vlc_plugin_resolve (vlc_plugin_t*,vlc_plugin_cb)"
140319,METHOD,modules\modules.c:<global>,TYPE_DECL,<global>,1,25,modules\modules.c,modules\modules.c:<global>,,false,1,473,<global>,,,1,
140321,METHOD,modules\modules.c:<global>,TYPE_DECL,"bool module_provides (const module_t *m, const char *cap)
{
    return !strcmp (module_get_capability (m), cap);
}",1,1,modules\modules.c,module_provides,,false,53,56,module_provides,,,1,"bool module_provides (module_t*,char*)"
140333,METHOD,modules\modules.c:<global>,TYPE_DECL,"const char *module_get_object( const module_t *m )
{
    if (unlikely(m->i_shortcuts == 0))
        return ""unnamed"";
    return m->pp_shortcuts[0];
}",1,1,modules\modules.c,module_get_object,,false,64,69,module_get_object,,,2,const char* module_get_object (module_t*)
140354,METHOD,modules\modules.c:<global>,TYPE_DECL,"const char *module_get_name( const module_t *m, bool long_name )
{
    if( long_name && ( m->psz_longname != NULL) )
        return m->psz_longname;

    if (m->psz_shortname != NULL)
        return m->psz_shortname;
    return module_get_object (m);
}",1,1,modules\modules.c,module_get_name,,false,78,86,module_get_name,,,3,"const char* module_get_name (module_t*,bool)"
140387,METHOD,modules\modules.c:<global>,TYPE_DECL,"const char *module_get_help( const module_t *m )
{
    return m->psz_help;
}",1,1,modules\modules.c,module_get_help,,false,94,97,module_get_help,,,4,const char* module_get_help (module_t*)
140396,METHOD,modules\modules.c:<global>,TYPE_DECL,"const char *module_get_capability (const module_t *m)
{
    return (m->psz_capability != NULL) ? m->psz_capability : ""none"";
}",1,1,modules\modules.c,module_get_capability,,false,105,108,module_get_capability,,,5,const char* module_get_capability (module_t*)
140412,METHOD,modules\modules.c:<global>,TYPE_DECL,"int module_get_score( const module_t *m )
{
    return m->i_score;
}",1,1,modules\modules.c,module_get_score,,false,116,119,module_get_score,,,6,int module_get_score (module_t*)
140421,METHOD,modules\modules.c:<global>,TYPE_DECL,"const char *module_gettext (const module_t *m, const char *str)
{
    if (unlikely(str == NULL || *str == '\0'))
        return """";
#ifdef ENABLE_NLS
    const char *domain = m->plugin->textdomain;
    return dgettext ((domain != NULL) ? domain : PACKAGE_NAME, str);
#else
    (void)m;
    return str;
#endif
}",1,1,modules\modules.c,module_gettext,,false,128,139,module_gettext,,,7,"const char* module_gettext (module_t*,char*)"
140445,METHOD,modules\modules.c:<global>,TYPE_DECL,"int module_start (vlc_object_t *obj, const module_t *m)
{
   int (*activate) (vlc_object_t *) = m->pf_activate;

   return (activate != NULL) ? activate (obj) : VLC_SUCCESS;
}",1,1,modules\modules.c,module_start,,false,142,147,module_start,,,8,"int module_start (vlc_object_t*,module_t*)"
140449,METHOD,modules\modules.c:<global>,TYPE_DECL,int (*activate) (vlc_object_t *) = m->pf_activate;,8,52,modules\modules.c,module_start.activate,,false,144,144,activate,,,1,int module_start.activate (vlc_object_t*)
140464,METHOD,modules\modules.c:<global>,TYPE_DECL,"void module_stop (vlc_object_t *obj, const module_t *m)
{
   void (*deactivate) (vlc_object_t *) = m->pf_deactivate;

    if (deactivate != NULL)
        deactivate (obj);
}",1,1,modules\modules.c,module_stop,,false,150,156,module_stop,,,9,"void module_stop (vlc_object_t*,module_t*)"
140468,METHOD,modules\modules.c:<global>,TYPE_DECL,void (*deactivate) (vlc_object_t *) = m->pf_deactivate;,9,57,modules\modules.c,module_stop.deactivate,,false,152,152,deactivate,,,1,void module_stop.deactivate (vlc_object_t*)
140482,METHOD,modules\modules.c:<global>,TYPE_DECL,"static bool module_match_name (const module_t *m, const char *name)
{
     /* Plugins with zero score must be matched explicitly. */
     if (!strcasecmp (""any"", name))
         return m->i_score > 0;

     for (unsigned i = 0; i < m->i_shortcuts; i++)
          if (!strcasecmp (m->pp_shortcuts[i], name))
              return true;
     return false;
}",1,1,modules\modules.c,module_match_name,,false,158,168,module_match_name,,,10,"bool module_match_name (module_t*,char*)"
140527,METHOD,modules\modules.c:<global>,TYPE_DECL,"static int module_load (vlc_object_t *obj, module_t *m,
                        vlc_activate_t init, va_list args)
{
    int ret = VLC_SUCCESS;

    if (module_Map(obj, m->plugin))
        return VLC_EGENERIC;

    if (m->pf_activate != NULL)
    {
        va_list ap;

        va_copy (ap, args);
        ret = init (m->pf_activate, ap);
        va_end (ap);
    }

    if (ret != VLC_SUCCESS)
        vlc_objres_clear(obj);

    return ret;
}",1,1,modules\modules.c,module_load,,false,170,191,module_load,,,11,"int module_load (vlc_object_t*,module_t*,vlc_activate_t,va_list)"
140577,METHOD,modules\modules.c:<global>,TYPE_DECL,"module_t *vlc_module_load(vlc_object_t *obj, const char *capability,
                          const char *name, bool strict,
                          vlc_activate_t probe, ...)
{
    char *var = NULL;

    if (name == NULL || name[0] == '\0')
        name = ""any"";

    /* Deal with variables */
    if (name[0] == '$')
    {
        var = var_InheritString (obj, name + 1);
        name = (var != NULL) ? var : ""any"";
    }

    /* Find matching modules */
    module_t **mods;
    ssize_t total = module_list_cap (&mods, capability);

    msg_Dbg (obj, ""looking for %s module matching \""%s\"": %zd candidates"",
             capability, name, total);
    if (total <= 0)
    {
        module_list_free (mods);
        msg_Dbg (obj, ""no %s modules"", capability);
        return NULL;
    }

    module_t *module = NULL;
    const bool b_force_backup = obj->obj.force; /* FIXME: remove this */
    va_list args;

    va_start(args, probe);
    while (*name)
    {
        char buf[32];
        siz...",1,8,modules\modules.c,vlc_module_load,,false,214,327,vlc_module_load,,,12,"module_t vlc_module_load (vlc_object_t*,char*,char*,bool,vlc_activate_t...)"
140895,METHOD,modules\modules.c:<global>,TYPE_DECL,"void vlc_module_unload(vlc_object_t *obj, module_t *module,
                       vlc_deactivate_t deinit, ...)
{
    if (module->pf_deactivate != NULL)
    {
        va_list ap;

        va_start(ap, deinit);
        deinit(module->pf_deactivate, ap);
        va_end(ap);
    }

    vlc_objres_clear(obj);
}",1,1,modules\modules.c,vlc_module_unload,,false,335,348,vlc_module_unload,,,13,"void vlc_module_unload (vlc_object_t*,module_t*,vlc_deactivate_t...)"
140922,METHOD,modules\modules.c:<global>,TYPE_DECL,"static int generic_start(void *func, va_list ap)
{
    vlc_object_t *obj = va_arg(ap, vlc_object_t *);
    int (*activate)(vlc_object_t *) = func;

    return activate(obj);
}",1,1,modules\modules.c,generic_start,,false,351,357,generic_start,,,14,"int generic_start (void*,va_list)"
140927,METHOD,modules\modules.c:<global>,TYPE_DECL,int (*activate)(vlc_object_t *) = func;,9,42,modules\modules.c,generic_start.activate,,false,354,354,activate,,,2,int generic_start.activate (vlc_object_t*)
140937,METHOD,modules\modules.c:<global>,TYPE_DECL,"static void generic_stop(void *func, va_list ap)
{
    vlc_object_t *obj = va_arg(ap, vlc_object_t *);
    void (*deactivate)(vlc_object_t *) = func;

    deactivate(obj);
}",1,1,modules\modules.c,generic_stop,,false,359,365,generic_stop,,,15,"void generic_stop (void*,va_list)"
140942,METHOD,modules\modules.c:<global>,TYPE_DECL,void (*deactivate)(vlc_object_t *) = func;,10,45,modules\modules.c,generic_stop.deactivate,,false,362,362,deactivate,,,2,void generic_stop.deactivate (vlc_object_t*)
140951,METHOD,modules\modules.c:<global>,TYPE_DECL,"module_t *module_need(vlc_object_t *obj, const char *cap, const char *name,
                      bool strict)
{
    return vlc_module_load(obj, cap, name, strict, generic_start, obj);
}",1,1,modules\modules.c,module_need,,false,368,372,module_need,,,16,"module_t module_need (vlc_object_t*,char*,char*,bool)"
140967,METHOD,modules\modules.c:<global>,TYPE_DECL,"void module_unneed(vlc_object_t *obj, module_t *module)
{
    msg_Dbg(obj, ""removing module \""%s\"""", module_get_object(module));
    vlc_module_unload(obj, module, generic_stop, obj);
}",1,1,modules\modules.c,module_unneed,,false,375,379,module_unneed,,,17,"void module_unneed (vlc_object_t*,module_t*)"
140983,METHOD,modules\modules.c:<global>,TYPE_DECL,"module_t *module_find (const char *name)
{
    size_t count;
    module_t **list = module_list_get (&count);

    assert (name != NULL);

    for (size_t i = 0; i < count; i++)
    {
        module_t *module = list[i];

        if (unlikely(module->i_shortcuts == 0))
            continue;
        if (!strcmp (module->pp_shortcuts[0], name))
        {
            module_list_free (list);
            return module;
        }
    }
    module_list_free (list);
    return NULL;
}",1,1,modules\modules.c,module_find,,false,387,408,module_find,,,18,module_t module_find (char*)
141044,METHOD,modules\modules.c:<global>,TYPE_DECL,"bool module_exists (const char * psz_name)
{
    return module_find (psz_name) != NULL;
}",1,1,modules\modules.c,module_exists,,false,416,419,module_exists,,,19,bool module_exists (char*)
141054,METHOD,modules\modules.c:<global>,TYPE_DECL,"module_config_t *module_config_get( const module_t *module, unsigned *restrict psize )
{
    const vlc_plugin_t *plugin = module->plugin;

    if (plugin->module != module)
    {   /* For backward compatibility, pretend non-first modules have no
         * configuration items. */
        *psize = 0;
        return NULL;
    }

    unsigned i,j;
    size_t size = plugin->conf.size;
    module_config_t *config = vlc_alloc( size, sizeof( *config ) );

    assert( psize != NULL );
    *psize = 0;

    if( !config )
        return NULL;

    for( i = 0, j = 0; i < size; i++ )
    {
        const module_config_t *item = plugin->conf.items + i;
        if( item->b_internal /* internal option */
         || item->b_removed /* removed option */ )
            continue;

        memcpy( config + j, item, sizeof( *config ) );
        j++;
    }
    *psize = j;

    return config;
}",1,1,modules\modules.c,module_config_get,,false,428,462,module_config_get,,,20,"module_config_t module_config_get (module_t*,unsigned*)"
141162,METHOD,modules\modules.c:<global>,TYPE_DECL,"void module_config_free( module_config_t *config )
{
    free( config );
}",1,1,modules\modules.c,module_config_free,,false,470,473,module_config_free,,,21,void module_config_free (module_config_t*)
141174,METHOD,modules\modules.h:<global>,TYPE_DECL,<global>,1,30,modules\modules.h,modules\modules.h:<global>,,false,1,135,<global>,,,1,
141199,METHOD,modules\modules.h:<global>,TYPE_DECL,"typedef int (*vlc_plugin_cb) (int (*)(void *, void *, int, ...), void *);",13,72,modules\modules.h,vlc_plugin_cb,,false,72,72,vlc_plugin_cb,,,6,"int vlc_plugin_cb (int,void*)"
141205,METHOD,modules\modules.h:<global>,TYPE_DECL,"int vlc_entry__core (int (*)(void *, void *, int, ...), void *);",5,63,modules\modules.h,vlc_entry__core,,false,75,75,vlc_entry__core,,,7,"int vlc_entry__core (int,void*)"
141225,METHOD,modules\modules.h:<global>,TYPE_DECL,vlc_plugin_t *vlc_plugin_create(void);,14,37,modules\modules.h,vlc_plugin_create,,false,106,106,vlc_plugin_create,,,9,vlc_plugin_t* vlc_plugin_create (void)
141230,METHOD,modules\modules.h:<global>,TYPE_DECL,void vlc_plugin_destroy(vlc_plugin_t *);,6,39,modules\modules.h,vlc_plugin_destroy,,false,107,107,vlc_plugin_destroy,,,10,void vlc_plugin_destroy (vlc_plugin_t*)
141235,METHOD,modules\modules.h:<global>,TYPE_DECL,module_t *vlc_module_create(vlc_plugin_t *);,10,43,modules\modules.h,vlc_module_create,,false,108,108,vlc_module_create,,,11,module_t* vlc_module_create (vlc_plugin_t*)
141240,METHOD,modules\modules.h:<global>,TYPE_DECL,void vlc_module_destroy (module_t *);,6,36,modules\modules.h,vlc_module_destroy,,false,109,109,vlc_module_destroy,,,12,void vlc_module_destroy (module_t*)
141245,METHOD,modules\modules.h:<global>,TYPE_DECL,vlc_plugin_t *vlc_plugin_describe(vlc_plugin_cb);,14,48,modules\modules.h,vlc_plugin_describe,,false,111,111,vlc_plugin_describe,,,13,vlc_plugin_t* vlc_plugin_describe (vlc_plugin_cb)
141250,METHOD,modules\modules.h:<global>,TYPE_DECL,"int vlc_plugin_resolve(vlc_plugin_t *, vlc_plugin_cb);",5,53,modules\modules.h,vlc_plugin_resolve,,false,112,112,vlc_plugin_resolve,,,14,"int vlc_plugin_resolve (vlc_plugin_t*,vlc_plugin_cb)"
141256,METHOD,modules\modules.h:<global>,TYPE_DECL,void module_InitBank (void);,6,27,modules\modules.h,module_InitBank,,false,114,114,module_InitBank,,,15,void module_InitBank (void)
141261,METHOD,modules\modules.h:<global>,TYPE_DECL,size_t module_LoadPlugins( vlc_object_t * );,8,43,modules\modules.h,module_LoadPlugins,,false,115,115,module_LoadPlugins,,,16,size_t module_LoadPlugins (vlc_object_t*)
141266,METHOD,modules\modules.h:<global>,TYPE_DECL,void module_EndBank (bool);,6,26,modules\modules.h,module_EndBank,,false,117,117,module_EndBank,,,17,void module_EndBank (ANY)
141271,METHOD,modules\modules.h:<global>,TYPE_DECL,"int module_Map(vlc_object_t *, vlc_plugin_t *);",5,46,modules\modules.h,module_Map,,false,118,118,module_Map,,,18,"int module_Map (vlc_object_t*,vlc_plugin_t*)"
141277,METHOD,modules\modules.h:<global>,TYPE_DECL,"ssize_t module_list_cap (module_t ***, const char *);",9,52,modules\modules.h,module_list_cap,,false,120,120,module_list_cap,,,19,"ssize_t module_list_cap (module_t***,char*)"
141283,METHOD,modules\modules.h:<global>,TYPE_DECL,int vlc_bindtextdomain (const char *);,5,37,modules\modules.h,vlc_bindtextdomain,,false,122,122,vlc_bindtextdomain,,,20,int vlc_bindtextdomain (char*)
141288,METHOD,modules\modules.h:<global>,TYPE_DECL,"int module_Load (vlc_object_t *, const char *, module_handle_t *, bool);",5,71,modules\modules.h,module_Load,,false,125,125,module_Load,,,21,"int module_Load (vlc_object_t*,char*,module_handle_t*,ANY)"
141296,METHOD,modules\modules.h:<global>,TYPE_DECL,"void *module_Lookup (module_handle_t, const char *);",6,51,modules\modules.h,module_Lookup,,false,126,126,module_Lookup,,,22,"void* module_Lookup (module_handle_t,char*)"
141302,METHOD,modules\modules.h:<global>,TYPE_DECL,void module_Unload (module_handle_t);,6,36,modules\modules.h,module_Unload,,false,127,127,module_Unload,,,23,void module_Unload (module_handle_t)
141307,METHOD,modules\modules.h:<global>,TYPE_DECL,"vlc_plugin_t *vlc_cache_load(vlc_object_t *, const char *, block_t **);",14,70,modules\modules.h,vlc_cache_load,,false,130,130,vlc_cache_load,,,24,"vlc_plugin_t* vlc_cache_load (vlc_object_t*,char*,block_t**)"
141314,METHOD,modules\modules.h:<global>,TYPE_DECL,"vlc_plugin_t *vlc_cache_lookup(vlc_plugin_t **, const char *relpath);",14,68,modules\modules.h,vlc_cache_lookup,,false,131,131,vlc_cache_lookup,,,25,"vlc_plugin_t* vlc_cache_lookup (vlc_plugin_t**,char*)"
141320,METHOD,modules\modules.h:<global>,TYPE_DECL,"void CacheSave(vlc_object_t *, const char *, vlc_plugin_t *const *, size_t);",6,75,modules\modules.h,CacheSave,,false,133,133,CacheSave,,,26,"void CacheSave (vlc_object_t*,char*,vlc_plugin_t**,ANY)"
141341,METHOD,modules\textdomain.c:<global>,TYPE_DECL,<global>,1,24,modules\textdomain.c,modules\textdomain.c:<global>,,false,1,106,<global>,,,1,
141343,METHOD,modules\textdomain.c:<global>,TYPE_DECL,"int vlc_bindtextdomain (const char *domain)
{
#if defined (ENABLE_NLS)
    /* Specify where to find the locales for current domain */
    char *datadir = config_GetDataDir();
    if (unlikely(datadir == NULL))
        return -1;

# if !defined (__APPLE__) && !defined (_WIN32) && !defined(__OS2__)
    const char *fmt = ""%s/../locale"";
# else
    const char *fmt = ""%s""DIR_SEP""locale"";
# endif
    char *upath;
    int ret = asprintf(&upath, fmt, datadir);
    free (datadir);
    if (unlikely(ret == -1))
        return -1;

    char *lpath = ToLocaleDup (upath);
    if (lpath == NULL || bindtextdomain (domain, lpath) == NULL)
    {
        free (lpath);
        fprintf (stderr, ""%s: text domain not found in %s\n"", domain, upath);
        free (upath);
        return -1;
    }
    free (lpath);
    free (upath);

    /* LibVLC wants all messages in UTF-8.
     * Unfortunately, we cannot ask UTF-8 for strerror_r(), strsignal_r()
     * and other functions that are not part of our text dom...",1,1,modules\textdomain.c,vlc_bindtextdomain,,false,33,85,vlc_bindtextdomain,,,1,int vlc_bindtextdomain (char*)
141353,METHOD,modules\textdomain.c:<global>,TYPE_DECL,"char *vlc_gettext (const char *msgid)
{
#ifdef ENABLE_NLS
    if (likely(*msgid))
        return dgettext (PACKAGE_NAME, msgid);
#endif
    return (char *)msgid;
}",1,1,modules\textdomain.c,vlc_gettext,,false,90,97,vlc_gettext,,,2,char* vlc_gettext (char*)
141362,METHOD,modules\textdomain.c:<global>,TYPE_DECL,"char *vlc_ngettext (const char *msgid, const char *plural, unsigned long n)
{
#ifdef ENABLE_NLS
    if (likely(*msgid))
        return dngettext (PACKAGE_NAME, msgid, plural, n);
#endif
    return (char *)((n == 1) ? msgid : plural);
}",1,1,modules\textdomain.c,vlc_ngettext,,false,99,106,vlc_ngettext,,,3,"char* vlc_ngettext (char*,char*,long unsigned)"
141399,METHOD,network\getaddrinfo.c:<global>,TYPE_DECL,<global>,1,6,network\getaddrinfo.c,network\getaddrinfo.c:<global>,,false,1,132,<global>,,,1,
141401,METHOD,network\getaddrinfo.c:<global>,TYPE_DECL,"int vlc_getnameinfo( const struct sockaddr *sa, int salen,
                     char *host, int hostlen, int *portnum, int flags )
{
    char psz_servbuf[6], *psz_serv;
    int i_servlen, i_val;

    flags |= NI_NUMERICSERV;
    if( portnum != NULL )
    {
        psz_serv = psz_servbuf;
        i_servlen = sizeof( psz_servbuf );
    }
    else
    {
        psz_serv = NULL;
        i_servlen = 0;
    }

    i_val = getnameinfo(sa, salen, host, hostlen, psz_serv, i_servlen, flags);

    if( portnum != NULL )
        *portnum = atoi( psz_serv );

    return i_val;
}",1,1,network\getaddrinfo.c,vlc_getnameinfo,,false,40,64,vlc_getnameinfo,,,1,"int vlc_getnameinfo (sockaddr*,int,char*,int,int*,int)"
141460,METHOD,network\getaddrinfo.c:<global>,TYPE_DECL,"int vlc_getaddrinfo (const char *node, unsigned port,
                     const struct addrinfo *hints, struct addrinfo **res)
{
    char hostbuf[NI_MAXHOST], portbuf[6], *servname;

    /*
     * In VLC, we always use port number as integer rather than strings
     * for historical reasons (and portability).
     */
    if (port != 0)
    {
        if (port > 65535)
            return EAI_SERVICE;
        /* cannot overflow */
        snprintf (portbuf, sizeof (portbuf), ""%u"", port);
        servname = portbuf;
    }
    else
        servname = NULL;

    /*
     * VLC extensions :
     * - accept the empty string as unspecified host (i.e. NULL)
     * - ignore square brackets (for IPv6 numerals)
     */
    if (node != NULL)
    {
        if (node[0] == '[')
        {
            size_t len = strlen (node + 1);
            if ((len <= sizeof (hostbuf)) && (node[len] == ']'))
            {
                assert (len > 0);
                memcpy (hostbuf, node + 1, len - 1);
     ...",1,1,network\getaddrinfo.c,vlc_getaddrinfo,,false,78,121,vlc_getaddrinfo,,,2,"int vlc_getaddrinfo (char*,unsigned,addrinfo*,addrinfo**)"
141583,METHOD,network\http_auth.c:<global>,TYPE_DECL,<global>,1,1,network\http_auth.c,network\http_auth.c:<global>,,false,1,505,<global>,,,1,
141585,METHOD,network\http_auth.c:<global>,TYPE_DECL,"static char *AuthGetParam( const char *psz_header, const char *psz_param )
{
    char psz_what[strlen(psz_param)+3];
    sprintf( psz_what, ""%s=\"""", psz_param );
    psz_header = strstr( psz_header, psz_what );
    if ( psz_header )
    {
        const char *psz_end;
        psz_header += strlen( psz_what );
        psz_end = strchr( psz_header, '""' );
        if ( !psz_end ) /* Invalid since we should have a closing quote */
            return strdup( psz_header );
        return strndup( psz_header, psz_end - psz_header );
    }
    else
    {
        return NULL;
    }
}",1,1,network\http_auth.c,AuthGetParam,,false,46,64,AuthGetParam,,,1,"char* AuthGetParam (char*,char*)"
141631,METHOD,network\http_auth.c:<global>,TYPE_DECL,"static char *AuthGetParamNoQuotes( const char *psz_header, const char *psz_param )
{
    char psz_what[strlen(psz_param)+2];
    sprintf( psz_what, ""%s="", psz_param );
    psz_header = strstr( psz_header, psz_what );
    if ( psz_header )
    {
        const char *psz_end;
        psz_header += strlen( psz_what );
        psz_end = strchr( psz_header, ',' );
        /* XXX: Do we need to filter out trailing space between the value and
         * the comma/end of line? */
        if ( !psz_end ) /* Can be valid if this is the last parameter */
            return strdup( psz_header );
        return strndup( psz_header, psz_end - psz_header );
    }
    else
    {
        return NULL;
    }
}",1,1,network\http_auth.c,AuthGetParamNoQuotes,,false,66,86,AuthGetParamNoQuotes,,,2,"char* AuthGetParamNoQuotes (char*,char*)"
141677,METHOD,network\http_auth.c:<global>,TYPE_DECL,"static char *GenerateCnonce()
{
    char ps_random[32];
    struct md5_s md5;

    vlc_rand_bytes( ps_random, sizeof( ps_random ) );

    InitMD5( &md5 );
    AddMD5( &md5, ps_random, sizeof( ps_random ) );
    EndMD5( &md5 );

    return psz_md5_hash( &md5 );
}",1,1,network\http_auth.c,GenerateCnonce,,false,88,100,GenerateCnonce,,,3,char* GenerateCnonce ()
141703,METHOD,network\http_auth.c:<global>,TYPE_DECL,"static char *AuthDigest( vlc_object_t *p_this, vlc_http_auth_t *p_auth,
                         const char *psz_method, const char *psz_path,
                         const char *psz_username, const char *psz_password )
{
    char *psz_HA1 = NULL;
    char *psz_HA2 = NULL;
    char *psz_ent = NULL;
    char *psz_result = NULL;
    char psz_inonce[9];
    struct md5_s md5;
    struct md5_s ent;

    if ( p_auth->psz_realm == NULL )
    {
        msg_Warn( p_this, ""Digest Authentication: ""
                  ""Mandatory 'realm' value not available"" );
        goto error;
    }

    /* H(A1) */
    if ( p_auth->psz_HA1 )
    {
        psz_HA1 = strdup( p_auth->psz_HA1 );
        if ( psz_HA1 == NULL )
            goto error;
    }
    else
    {
        InitMD5( &md5 );
        AddMD5( &md5, psz_username, strlen( psz_username ) );
        AddMD5( &md5, "":"", 1 );
        AddMD5( &md5, p_auth->psz_realm, strlen( p_auth->psz_realm ) );
        AddMD5( &md5, "":"", 1 );
        AddMD5( &md5, ...",1,1,network\http_auth.c,AuthDigest,,false,102,223,AuthDigest,,,4,"char* AuthDigest (vlc_object_t*,vlc_http_auth_t*,char*,char*,char*,char*)"
142104,METHOD,network\http_auth.c:<global>,TYPE_DECL,"void vlc_http_auth_ParseWwwAuthenticateHeader(
        vlc_object_t *p_this, vlc_http_auth_t *p_auth,
        const char *psz_header )
{
    static const char psz_basic_prefix[] = ""Basic "";
    static const char psz_digest_prefix[] = ""Digest "";

    /* FIXME: multiple auth methods can be listed (comma separated) */

    if ( strncasecmp( psz_header, psz_basic_prefix,
                      sizeof( psz_basic_prefix ) - 1 ) == 0 )
    {
        /* 2 Basic Authentication Scheme */
        msg_Dbg( p_this, ""Using Basic Authentication"" );
        psz_header += sizeof( psz_basic_prefix ) - 1;
        p_auth->psz_realm = AuthGetParam( psz_header, ""realm"" );
        if ( p_auth->psz_realm == NULL )
            msg_Warn( p_this, ""Basic Authentication: ""
                      ""Mandatory 'realm' parameter is missing"" );
    }
    else if ( strncasecmp( psz_header, psz_digest_prefix,
                           sizeof( psz_digest_prefix ) - 1 ) == 0 )
    {
        /* 3 Digest Access Authenticati...",1,1,network\http_auth.c,vlc_http_auth_ParseWwwAuthenticateHeader,,false,231,302,vlc_http_auth_ParseWwwAuthenticateHeader,,,5,"void vlc_http_auth_ParseWwwAuthenticateHeader (vlc_object_t*,vlc_http_auth_t*,char*)"
142304,METHOD,network\http_auth.c:<global>,TYPE_DECL,"int vlc_http_auth_ParseAuthenticationInfoHeader(
        vlc_object_t *p_this, vlc_http_auth_t *p_auth,
        const char *psz_header, const char *psz_method, const char *psz_path,
        const char *psz_username, const char *psz_password )
{
    char *psz_nextnonce = AuthGetParam( psz_header, ""nextnonce"" );
    char *psz_qop = AuthGetParamNoQuotes( psz_header, ""qop"" );
    char *psz_rspauth = AuthGetParam( psz_header, ""rspauth"" );
    char *psz_cnonce = AuthGetParam( psz_header, ""cnonce"" );
    char *psz_nc = AuthGetParamNoQuotes( psz_header, ""nc"" );
    char *psz_digest = NULL;
    int i_err = VLC_SUCCESS;
    int i_nonce;

    if ( psz_cnonce )
    {
        if ( strcmp( psz_cnonce, p_auth->psz_cnonce ) != 0 )
        {
            msg_Err( p_this, ""HTTP Digest Access Authentication: server ""
                             ""replied with a different client nonce value."" );
            i_err = VLC_EGENERIC;
            goto error;
        }

        if ( psz_nc )
        {
        ...",1,1,network\http_auth.c,vlc_http_auth_ParseAuthenticationInfoHeader,,false,309,386,vlc_http_auth_ParseAuthenticationInfoHeader,,,6,"int vlc_http_auth_ParseAuthenticationInfoHeader (vlc_object_t*,vlc_http_auth_t*,char*,char*,char*,char*,char*)"
142472,METHOD,network\http_auth.c:<global>,TYPE_DECL,"char *vlc_http_auth_FormatAuthorizationHeader(
        vlc_object_t *p_this, vlc_http_auth_t *p_auth,
        const char *psz_method, const char *psz_path,
        const char *psz_username, const char *psz_password )
{
    char *psz_result = NULL;
    char *psz_buffer = NULL;
    char *psz_base64 = NULL;
    int i_rc;

    if ( p_auth->psz_nonce )
    {
        /* Digest Access Authentication */
        if ( p_auth->psz_algorithm &&
             strcmp( p_auth->psz_algorithm, ""MD5"" ) != 0 &&
             strcmp( p_auth->psz_algorithm, ""MD5-sess"" ) != 0 )
        {
            msg_Err( p_this, ""Digest Access Authentication: ""
                     ""Unknown algorithm '%s'"", p_auth->psz_algorithm );
            goto error;
        }

        if ( p_auth->psz_qop != NULL || p_auth->psz_cnonce == NULL )
        {
            free( p_auth->psz_cnonce );

            p_auth->psz_cnonce = GenerateCnonce();
            if ( p_auth->psz_cnonce == NULL )
                goto error;
        }

 ...",1,1,network\http_auth.c,vlc_http_auth_FormatAuthorizationHeader,,false,388,487,vlc_http_auth_FormatAuthorizationHeader,,,7,"char* vlc_http_auth_FormatAuthorizationHeader (vlc_object_t*,vlc_http_auth_t*,char*,char*,char*,char*)"
142736,METHOD,network\http_auth.c:<global>,TYPE_DECL,"void vlc_http_auth_Init( vlc_http_auth_t *p_auth )
{
    memset( p_auth, 0, sizeof( *p_auth ) );
}",1,1,network\http_auth.c,vlc_http_auth_Init,,false,489,492,vlc_http_auth_Init,,,8,void vlc_http_auth_Init (vlc_http_auth_t*)
142747,METHOD,network\http_auth.c:<global>,TYPE_DECL,"void vlc_http_auth_Deinit( vlc_http_auth_t *p_auth )
{
    free( p_auth->psz_realm );
    free( p_auth->psz_domain );
    free( p_auth->psz_nonce );
    free( p_auth->psz_opaque );
    free( p_auth->psz_stale );
    free( p_auth->psz_algorithm );
    free( p_auth->psz_qop );
    free( p_auth->psz_cnonce );
    free( p_auth->psz_HA1 );
}",1,1,network\http_auth.c,vlc_http_auth_Deinit,,false,494,505,vlc_http_auth_Deinit,,,9,void vlc_http_auth_Deinit (vlc_http_auth_t*)
142831,METHOD,network\httpd.c:<global>,TYPE_DECL,<global>,1,23,network\httpd.c,network\httpd.c:<global>,,false,1,2108,<global>,,,1,
142833,METHOD,network\httpd.c:<global>,TYPE_DECL,static void httpd_ClientDestroy(httpd_client_t *cl);,13,51,network\httpd.c,httpd_ClientDestroy,,false,69,69,httpd_ClientDestroy,,,1,void httpd_ClientDestroy (httpd_client_t*)
142838,METHOD,network\httpd.c:<global>,TYPE_DECL,"static void httpd_AppendData(httpd_stream_t *stream, uint8_t *p_data, int i_data);",13,81,network\httpd.c,httpd_AppendData,,false,70,70,httpd_AppendData,,,2,"void httpd_AppendData (httpd_stream_t*,uint8_t*,int)"
142872,METHOD,<empty>,<empty>,<empty>,1,,network\httpd.c,httpd_url_t:<clinit>,,false,106,,<clinit>,,,8,
142900,METHOD,network\httpd.c:<global>,TYPE_DECL,"static const char *httpd_ReasonFromCode(unsigned i_code)
{
    typedef struct
    {
        unsigned   i_code;
        const char psz_reason[36];
    } http_status_info;

    static const http_status_info http_reason[] =
    {
        /*{ 100, ""Continue"" },
          { 101, ""Switching Protocols"" },*/
        { 200, ""OK"" },
        /*{ 201, ""Created"" },
          { 202, ""Accepted"" },
          { 203, ""Non-authoritative information"" },
          { 204, ""No content"" },
          { 205, ""Reset content"" },
          { 206, ""Partial content"" },
          { 250, ""Low on storage space"" },
          { 300, ""Multiple choices"" },*/
        { 301, ""Moved permanently"" },
        /*{ 302, ""Moved temporarily"" },
          { 303, ""See other"" },
          { 304, ""Not modified"" },
          { 305, ""Use proxy"" },
          { 307, ""Temporary redirect"" },
          { 400, ""Bad request"" },*/
        { 401, ""Unauthorized"" },
        /*{ 402, ""Payment Required"" },*/
        { 403, ""Forbidden"" },
        { ...",1,1,network\httpd.c,httpd_ReasonFromCode,,false,174,255,httpd_ReasonFromCode,,,7,const char* httpd_ReasonFromCode (unsigned)
143015,METHOD,network\httpd.c:<global>,TYPE_DECL,"static size_t httpd_HtmlError (char **body, int code, const char *url)
{
    const char *errname = httpd_ReasonFromCode (code);
    assert (errname);

    char *url_Encoded = vlc_xml_encode (url ? url : """");

    int res = asprintf (body,
        ""<?xml version=\""1.0\"" encoding=\""ascii\"" ?>\n""
        ""<!DOCTYPE html PUBLIC \""-//W3C//DTD XHTML 1.0 Strict//EN\""""
        "" \""http://www.w3.org/TR/xhtml10/DTD/xhtml10strict.dtd\"">\n""
        ""<html lang=\""en\"">\n""
        ""<head>\n""
        ""<title>%s</title>\n""
        ""</head>\n""
        ""<body>\n""
        ""<h1>%d %s%s%s%s</h1>\n""
        ""<hr />\n""
        ""<a href=\""http://www.videolan.org\"">VideoLAN</a>\n""
        ""</body>\n""
        ""</html>\n"", errname, code, errname,
        (url_Encoded ? "" ("" : """"), (url_Encoded ? url_Encoded : """"), (url_Encoded ? "")"" : """"));

    free (url_Encoded);

    if (res == -1) {
        *body = NULL;
        return 0;
    }

    return (size_t)res;
}",1,1,network\httpd.c,httpd_HtmlError,,false,257,288,httpd_HtmlError,,,8,"size_t httpd_HtmlError (char**,int,char*)"
143081,METHOD,<empty>,<empty>,<empty>,1,,network\httpd.c,httpd_file_t:<clinit>,,false,294,,<clinit>,,,5,
143087,METHOD,network\httpd.c:<global>,TYPE_DECL,"static int
httpd_FileCallBack(httpd_callback_sys_t *p_sys, httpd_client_t *cl,
                    httpd_message_t *answer, const httpd_message_t *query)
{
    httpd_file_t *file = (httpd_file_t*)p_sys;
    uint8_t **pp_body, *p_body;
    int *pi_body, i_body;

    if (!answer || !query )
        return VLC_SUCCESS;

    answer->i_proto  = HTTPD_PROTO_HTTP;
    answer->i_version= 1;
    answer->i_type   = HTTPD_MSG_ANSWER;

    answer->i_status = 200;

    httpd_MsgAdd(answer, ""Content-type"",  ""%s"", file->mime);
    httpd_MsgAdd(answer, ""Cache-Control"", ""%s"", ""no-cache"");

    if (query->i_type != HTTPD_MSG_HEAD) {
        pp_body = &answer->p_body;
        pi_body = &answer->i_body;
    } else {
        /* The file still needs to be executed. */
        p_body = NULL;
        i_body = 0;
        pp_body = &p_body;
        pi_body = &i_body;
    }

    if (query->i_type == HTTPD_MSG_POST) {
        /* msg_Warn not supported */
    }

    uint8_t *psz_args = query->psz_args;
    file...",1,1,network\httpd.c,httpd_FileCallBack,,false,302,350,httpd_FileCallBack,,,10,"int httpd_FileCallBack (httpd_callback_sys_t*,httpd_client_t*,httpd_message_t*,httpd_message_t*)"
143237,METHOD,network\httpd.c:<global>,TYPE_DECL,"httpd_file_t *httpd_FileNew(httpd_host_t *host,
                             const char *psz_url, const char *psz_mime,
                             const char *psz_user, const char *psz_password,
                             httpd_file_callback_t pf_fill,
                             httpd_file_sys_t *p_sys)
{
    const char *mime = psz_mime;
    if (mime == NULL || mime[0] == '\0')
        mime = vlc_mime_Ext2Mime(psz_url);

    size_t mimelen = strlen(mime);
    httpd_file_t *file = malloc(sizeof(*file) + mimelen);
    if (unlikely(file == NULL))
        return NULL;

    file->url = httpd_UrlNew(host, psz_url, psz_user, psz_password);
    if (!file->url) {
        free(file);
        return NULL;
    }

    file->pf_fill = pf_fill;
    file->p_sys   = p_sys;
    memcpy(file->mime, mime, mimelen + 1);

    httpd_UrlCatch(file->url, HTTPD_MSG_HEAD, httpd_FileCallBack,
                    (httpd_callback_sys_t*)file);
    httpd_UrlCatch(file->url, HTTPD_MSG_GET,  httpd_FileCallBack...",1,1,network\httpd.c,httpd_FileNew,,false,352,385,httpd_FileNew,,,11,"httpd_file_t httpd_FileNew (httpd_host_t*,char*,char*,char*,char*,httpd_file_callback_t,httpd_file_sys_t*)"
143355,METHOD,network\httpd.c:<global>,TYPE_DECL,"httpd_file_sys_t *httpd_FileDelete(httpd_file_t *file)
{
    httpd_file_sys_t *p_sys = file->p_sys;

    httpd_UrlDelete(file->url);
    free(file);
    return p_sys;
}",1,1,network\httpd.c,httpd_FileDelete,,false,387,394,httpd_FileDelete,,,12,httpd_file_sys_t httpd_FileDelete (httpd_file_t*)
143378,METHOD,network\httpd.c:<global>,TYPE_DECL,"static int
httpd_HandlerCallBack(httpd_callback_sys_t *p_sys, httpd_client_t *cl,
                       httpd_message_t *answer, const httpd_message_t *query)
{
    httpd_handler_t *handler = (httpd_handler_t*)p_sys;
    char psz_remote_addr[NI_MAXNUMERICHOST];

    if (!answer || !query)
        return VLC_SUCCESS;

    answer->i_proto  = HTTPD_PROTO_NONE;
    answer->i_type   = HTTPD_MSG_ANSWER;

    /* We do it ourselves, thanks */
    answer->i_status = 0;

    if (!httpd_ClientIP(cl, psz_remote_addr, NULL))
        *psz_remote_addr = '\0';

    uint8_t *psz_args = query->psz_args;
    handler->pf_fill(handler->p_sys, handler, query->psz_url, psz_args,
                      query->i_type, query->p_body, query->i_body,
                      psz_remote_addr, NULL,
                      &answer->p_body, &answer->i_body);

    if (query->i_type == HTTPD_MSG_HEAD) {
        char *p = (char *)answer->p_body;

        /* Looks for end of header (i.e. one empty line) */
        while (...",1,1,network\httpd.c,httpd_HandlerCallBack,,false,408,476,httpd_HandlerCallBack,,,14,"int httpd_HandlerCallBack (httpd_callback_sys_t*,httpd_client_t*,httpd_message_t*,httpd_message_t*)"
143681,METHOD,network\httpd.c:<global>,TYPE_DECL,"httpd_handler_t *httpd_HandlerNew(httpd_host_t *host, const char *psz_url,
                                  const char *psz_user,
                                  const char *psz_password,
                                  httpd_handler_callback_t pf_fill,
                                  void *p_sys)
{
    httpd_handler_t *handler = malloc(sizeof(*handler));
    if (!handler)
        return NULL;

    handler->url = httpd_UrlNew(host, psz_url, psz_user, psz_password);
    if (!handler->url) {
        free(handler);
        return NULL;
    }

    handler->pf_fill = pf_fill;
    handler->p_sys   = p_sys;

    httpd_UrlCatch(handler->url, HTTPD_MSG_HEAD, httpd_HandlerCallBack,
                    (httpd_callback_sys_t*)handler);
    httpd_UrlCatch(handler->url, HTTPD_MSG_GET,  httpd_HandlerCallBack,
                    (httpd_callback_sys_t*)handler);
    httpd_UrlCatch(handler->url, HTTPD_MSG_POST, httpd_HandlerCallBack,
                    (httpd_callback_sys_t*)handler);

    r...",1,1,network\httpd.c,httpd_HandlerNew,,false,478,505,httpd_HandlerNew,,,15,"httpd_handler_t httpd_HandlerNew (httpd_host_t*,char*,char*,char*,httpd_handler_callback_t,void*)"
143762,METHOD,network\httpd.c:<global>,TYPE_DECL,"void *httpd_HandlerDelete(httpd_handler_t *handler)
{
    void *p_sys = handler->p_sys;
    httpd_UrlDelete(handler->url);
    free(handler);
    return p_sys;
}",1,1,network\httpd.c,httpd_HandlerDelete,,false,507,513,httpd_HandlerDelete,,,16,void* httpd_HandlerDelete (httpd_handler_t*)
143784,METHOD,<empty>,<empty>,<empty>,1,,network\httpd.c,httpd_redirect_t:<clinit>,,false,518,,<clinit>,,,3,
143790,METHOD,network\httpd.c:<global>,TYPE_DECL,"static int httpd_RedirectCallBack(httpd_callback_sys_t *p_sys,
                                   httpd_client_t *cl, httpd_message_t *answer,
                                   const httpd_message_t *query)
{
    httpd_redirect_t *rdir = (httpd_redirect_t*)p_sys;
    char *p_body;
    (void)cl;

    if (!answer || !query)
        return VLC_SUCCESS;

    answer->i_proto  = HTTPD_PROTO_HTTP;
    answer->i_version= 1;
    answer->i_type   = HTTPD_MSG_ANSWER;
    answer->i_status = 301;

    answer->i_body = httpd_HtmlError (&p_body, 301, rdir->dst);
    answer->p_body = (unsigned char *)p_body;

    /* XXX check if it's ok or we need to set an absolute url */
    httpd_MsgAdd(answer, ""Location"",  ""%s"", rdir->dst);

    httpd_MsgAdd(answer, ""Content-Length"", ""%d"", answer->i_body);

    if (httpd_MsgGet(&cl->query, ""Connection"") != NULL)
        httpd_MsgAdd(answer, ""Connection"", ""close"");

    return VLC_SUCCESS;
}",1,1,network\httpd.c,httpd_RedirectCallBack,,false,524,552,httpd_RedirectCallBack,,,18,"int httpd_RedirectCallBack (httpd_callback_sys_t*,httpd_client_t*,httpd_message_t*,httpd_message_t*)"
143885,METHOD,network\httpd.c:<global>,TYPE_DECL,"httpd_redirect_t *httpd_RedirectNew(httpd_host_t *host, const char *psz_url_dst,
                                     const char *psz_url_src)
{
    size_t dstlen = strlen(psz_url_dst);

    httpd_redirect_t *rdir = malloc(sizeof(*rdir) + dstlen);
    if (unlikely(rdir == NULL))
        return NULL;

    rdir->url = httpd_UrlNew(host, psz_url_src, NULL, NULL);
    if (!rdir->url) {
        free(rdir);
        return NULL;
    }
    memcpy(rdir->dst, psz_url_dst, dstlen + 1);

    /* Redirect apply for all HTTP request and RTSP DESCRIBE resquest */
    httpd_UrlCatch(rdir->url, HTTPD_MSG_HEAD, httpd_RedirectCallBack,
                    (httpd_callback_sys_t*)rdir);
    httpd_UrlCatch(rdir->url, HTTPD_MSG_GET, httpd_RedirectCallBack,
                    (httpd_callback_sys_t*)rdir);
    httpd_UrlCatch(rdir->url, HTTPD_MSG_POST, httpd_RedirectCallBack,
                    (httpd_callback_sys_t*)rdir);
    httpd_UrlCatch(rdir->url, HTTPD_MSG_DESCRIBE, httpd_RedirectCallBack,
          ...",1,1,network\httpd.c,httpd_RedirectNew,,false,554,581,httpd_RedirectNew,,,19,"httpd_redirect_t httpd_RedirectNew (httpd_host_t*,char*,char*)"
143979,METHOD,network\httpd.c:<global>,TYPE_DECL,"void httpd_RedirectDelete(httpd_redirect_t *rdir)
{
    httpd_UrlDelete(rdir->url);
    free(rdir);
}",1,1,network\httpd.c,httpd_RedirectDelete,,false,582,586,httpd_RedirectDelete,,,20,void httpd_RedirectDelete (httpd_redirect_t*)
144004,METHOD,network\httpd.c:<global>,TYPE_DECL,"static int httpd_StreamCallBack(httpd_callback_sys_t *p_sys,
                                 httpd_client_t *cl, httpd_message_t *answer,
                                 const httpd_message_t *query)
{
    httpd_stream_t *stream = (httpd_stream_t*)p_sys;

    if (!answer || !query || !cl)
        return VLC_SUCCESS;

    if (answer->i_body_offset > 0) {
        int     i_pos;

        if (answer->i_body_offset >= stream->i_buffer_pos)
            return VLC_EGENERIC;    /* wait, no data available */

        if (cl->i_keyframe_wait_to_pass >= 0) {
            if (stream->i_last_keyframe_seen_pos <= cl->i_keyframe_wait_to_pass)
                /* still waiting for the next keyframe */
                return VLC_EGENERIC;

            /* seek to the new keyframe */
            answer->i_body_offset = stream->i_last_keyframe_seen_pos;
            cl->i_keyframe_wait_to_pass = -1;
        }

        if (answer->i_body_offset + stream->i_buffer_size < stream->i_buffer_pos)
            ...",1,22,network\httpd.c,httpd_StreamCallBack,,false,621,744,httpd_StreamCallBack,,,22,"int httpd_StreamCallBack (httpd_callback_sys_t*,httpd_client_t*,httpd_message_t*,httpd_message_t*)"
144510,METHOD,network\httpd.c:<global>,TYPE_DECL,"httpd_stream_t *httpd_StreamNew(httpd_host_t *host,
                                 const char *psz_url, const char *psz_mime,
                                 const char *psz_user, const char *psz_password)
{
    httpd_stream_t *stream = malloc(sizeof(*stream));
    if (!stream)
        return NULL;

    stream->url = httpd_UrlNew(host, psz_url, psz_user, psz_password);
    if (!stream->url) {
        free(stream);
        return NULL;
    }

    vlc_mutex_init(&stream->lock);
    if (psz_mime == NULL || psz_mime[0] == '\0')
        psz_mime = vlc_mime_Ext2Mime(psz_url);
    stream->psz_mime = xstrdup(psz_mime);

    stream->i_header = 0;
    stream->p_header = NULL;
    stream->i_buffer_size = 5000000;    /* 5 Mo per stream */
    stream->p_buffer = xmalloc(stream->i_buffer_size);
    /* We set to 1 to make life simpler
     * (this way i_body_offset can never be 0) */
    stream->i_buffer_pos = 1;
    stream->i_buffer_last_pos = 1;
    stream->b_has_keyframes = false;
    stream...",1,1,network\httpd.c,httpd_StreamNew,,false,746,786,httpd_StreamNew,,,23,"httpd_stream_t httpd_StreamNew (httpd_host_t*,char*,char*,char*,char*)"
144659,METHOD,network\httpd.c:<global>,TYPE_DECL,"int httpd_StreamHeader(httpd_stream_t *stream, uint8_t *p_data, int i_data)
{
    vlc_mutex_lock(&stream->lock);
    free(stream->p_header);
    stream->p_header = NULL;

    stream->i_header = i_data;
    if (i_data > 0) {
        stream->p_header = xmalloc(i_data);
        memcpy(stream->p_header, p_data, i_data);
    }
    vlc_mutex_unlock(&stream->lock);

    return VLC_SUCCESS;
}",1,1,network\httpd.c,httpd_StreamHeader,,false,788,802,httpd_StreamHeader,,,24,"int httpd_StreamHeader (httpd_stream_t*,uint8_t*,int)"
144709,METHOD,network\httpd.c:<global>,TYPE_DECL,"static void httpd_AppendData(httpd_stream_t *stream, uint8_t *p_data, int i_data)
{
    int i_pos = stream->i_buffer_pos % stream->i_buffer_size;
    int i_count = i_data;
    while (i_count > 0) {
        int i_copy = __MIN(i_count, stream->i_buffer_size - i_pos);

        /* Ok, we can't go past the end of our buffer */
        memcpy(&stream->p_buffer[i_pos], p_data, i_copy);

        i_pos = (i_pos + i_copy) % stream->i_buffer_size;
        i_count -= i_copy;
        p_data  += i_copy;
    }

    stream->i_buffer_pos += i_data;
}",1,1,network\httpd.c,httpd_AppendData,,false,804,820,httpd_AppendData,,,25,"void httpd_AppendData (httpd_stream_t*,uint8_t*,int)"
144774,METHOD,network\httpd.c:<global>,TYPE_DECL,"int httpd_StreamSend(httpd_stream_t *stream, const block_t *p_block)
{
    if (!p_block || !p_block->p_buffer)
        return VLC_SUCCESS;

    vlc_mutex_lock(&stream->lock);

    /* save this pointer (to be used by new connection) */
    stream->i_buffer_last_pos = stream->i_buffer_pos;

    if (p_block->i_flags & BLOCK_FLAG_TYPE_I) {
        stream->b_has_keyframes = true;
        stream->i_last_keyframe_seen_pos = stream->i_buffer_pos;
    }

    httpd_AppendData(stream, p_block->p_buffer, p_block->i_buffer);

    vlc_mutex_unlock(&stream->lock);
    return VLC_SUCCESS;
}",1,1,network\httpd.c,httpd_StreamSend,,false,822,841,httpd_StreamSend,,,26,"int httpd_StreamSend (httpd_stream_t*,block_t*)"
144837,METHOD,network\httpd.c:<global>,TYPE_DECL,"void httpd_StreamDelete(httpd_stream_t *stream)
{
    httpd_UrlDelete(stream->url);
    for (size_t i = 0; i < stream->i_http_headers; i++) {
        free(stream->p_http_headers[i].name);
        free(stream->p_http_headers[i].value);
    }
    free(stream->p_http_headers);
    vlc_mutex_destroy(&stream->lock);
    free(stream->psz_mime);
    free(stream->p_header);
    free(stream->p_buffer);
    free(stream);
}",1,1,network\httpd.c,httpd_StreamDelete,,false,843,856,httpd_StreamDelete,,,27,void httpd_StreamDelete (httpd_stream_t*)
144899,METHOD,network\httpd.c:<global>,TYPE_DECL,static void* httpd_HostThread(void *);,12,37,network\httpd.c,httpd_HostThread,,false,861,861,httpd_HostThread,,,28,void* httpd_HostThread (void*)
144904,METHOD,network\httpd.c:<global>,TYPE_DECL,"static httpd_host_t *httpd_HostCreate(vlc_object_t *, const char *,
                                      const char *, vlc_tls_creds_t *,
                                      unsigned);",21,47,network\httpd.c,httpd_HostCreate,,false,862,864,httpd_HostCreate,,,29,"httpd_host_t* httpd_HostCreate (vlc_object_t*,char*,char*,vlc_tls_creds_t*,unsigned)"
144913,METHOD,network\httpd.c:<global>,TYPE_DECL,"httpd_host_t *vlc_http_HostNew(vlc_object_t *p_this)
{
    return httpd_HostCreate(p_this, ""http-host"", ""http-port"", NULL, 10);
}",1,1,network\httpd.c,vlc_http_HostNew,,false,867,870,vlc_http_HostNew,,,30,httpd_host_t vlc_http_HostNew (vlc_object_t*)
144925,METHOD,network\httpd.c:<global>,TYPE_DECL,"httpd_host_t *vlc_https_HostNew(vlc_object_t *obj)
{
    char *cert = var_InheritString(obj, ""http-cert"");
    if (!cert) {
        msg_Err(obj, ""HTTP/TLS certificate not specified!"");
        return NULL;
    }

    char *key = var_InheritString(obj, ""http-key"");
    vlc_tls_creds_t *tls = vlc_tls_ServerCreate(obj, cert, key);

    if (!tls) {
        msg_Err(obj, ""HTTP/TLS certificate error (%s and %s)"",
                 cert, key ? key : cert);
        free(key);
        free(cert);
        return NULL;
    }
    free(key);
    free(cert);

    return httpd_HostCreate(obj, ""http-host"", ""https-port"", tls, 10);
}",1,1,network\httpd.c,vlc_https_HostNew,,false,872,894,vlc_https_HostNew,,,31,httpd_host_t vlc_https_HostNew (vlc_object_t*)
144987,METHOD,network\httpd.c:<global>,TYPE_DECL,"httpd_host_t *vlc_rtsp_HostNew(vlc_object_t *p_this)
{
    unsigned timeout = var_InheritInteger(p_this, ""rtsp-timeout"");
    return httpd_HostCreate(p_this, ""rtsp-host"", ""rtsp-port"", NULL, timeout);
}",1,1,network\httpd.c,vlc_rtsp_HostNew,,false,896,900,vlc_rtsp_HostNew,,,32,httpd_host_t vlc_rtsp_HostNew (vlc_object_t*)
145016,METHOD,network\httpd.c:<global>,TYPE_DECL,"static httpd_host_t *httpd_HostCreate(vlc_object_t *p_this,
                                       const char *hostvar,
                                       const char *portvar,
                                       vlc_tls_creds_t *p_tls,
                                       unsigned timeout_sec)
{
    httpd_host_t *host;
    unsigned port = var_InheritInteger(p_this, portvar);

    /* to be sure to avoid multiple creation */
    vlc_mutex_lock(&httpd.mutex);

    /* verify if it already exist */
    for (int i = 0; i < httpd.i_host; i++) {
        host = httpd.host[i];

        /* cannot mix TLS and non-TLS hosts */
        if (host->port != port
         || (host->p_tls != NULL) != (p_tls != NULL))
            continue;

        /* Increase existing matching host reference count.
         * The reference count is written under both the global httpd and the
         * host lock. It is read with either or both locks held. The global
         * lock is always acquired first. */...",1,27,network\httpd.c,httpd_HostCreate,,false,910,1002,httpd_HostCreate,,,36,"httpd_host_t httpd_HostCreate (vlc_object_t*,char*,char*,vlc_tls_creds_t*,unsigned)"
145290,METHOD,network\httpd.c:<global>,TYPE_DECL,"void httpd_HostDelete(httpd_host_t *host)
{
    bool delete = false;

    vlc_mutex_lock(&httpd.mutex);

    vlc_mutex_lock(&host->lock);
    host->i_ref--;
    if (host->i_ref == 0)
        delete = true;
    vlc_mutex_unlock(&host->lock);
    if (!delete) {
        /* still used */
        vlc_mutex_unlock(&httpd.mutex);
        msg_Dbg(host, ""httpd_HostDelete: host still in use"");
        return;
    }
    TAB_REMOVE(httpd.i_host, httpd.host, host);

    vlc_cancel(host->thread);
    vlc_join(host->thread, NULL);

    msg_Dbg(host, ""HTTP host removed"");

    for (int i = 0; i < host->i_url; i++)
        msg_Err(host, ""url still registered: %s"", host->url[i]->psz_url);

    for (int i = 0; i < host->i_client; i++) {
        msg_Warn(host, ""client still connected"");
        httpd_ClientDestroy(host->client[i]);
    }
    TAB_CLEAN(host->i_client, host->client);

    vlc_tls_Delete(host->p_tls);
    net_ListenClose(host->fds);
    vlc_cond_destroy(&host->wait);
    vlc_mutex_destroy...",1,1,network\httpd.c,httpd_HostDelete,,false,1005,1044,httpd_HostDelete,,,37,void httpd_HostDelete (httpd_host_t*)
145439,METHOD,network\httpd.c:<global>,TYPE_DECL,"httpd_url_t *httpd_UrlNew(httpd_host_t *host, const char *psz_url,
                           const char *psz_user, const char *psz_password)
{
    httpd_url_t *url;

    assert(psz_url);

    vlc_mutex_lock(&host->lock);
    for (int i = 0; i < host->i_url; i++)
        if (!strcmp(psz_url, host->url[i]->psz_url)) {
            msg_Warn(host, ""cannot add '%s' (url already defined)"", psz_url);
            vlc_mutex_unlock(&host->lock);
            return NULL;
        }

    url = xmalloc(sizeof(httpd_url_t));
    url->host = host;

    vlc_mutex_init(&url->lock);
    url->psz_url = xstrdup(psz_url);
    url->psz_user = xstrdup(psz_user ? psz_user : """");
    url->psz_password = xstrdup(psz_password ? psz_password : """");
    for (int i = 0; i < HTTPD_MSG_MAX; i++) {
        url->catch[i].cb = NULL;
        url->catch[i].p_sys = NULL;
    }

    TAB_APPEND(host->i_url, host->url, url);
    vlc_cond_signal(&host->wait);
    vlc_mutex_unlock(&host->lock);

    return url;
}",1,1,network\httpd.c,httpd_UrlNew,,false,1047,1079,httpd_UrlNew,,,38,"httpd_url_t httpd_UrlNew (httpd_host_t*,char*,char*,char*)"
145580,METHOD,network\httpd.c:<global>,TYPE_DECL,"int httpd_UrlCatch(httpd_url_t *url, int i_msg, httpd_callback_t cb,
                    httpd_callback_sys_t *p_sys)
{
    vlc_mutex_lock(&url->lock);
    url->catch[i_msg].cb   = cb;
    url->catch[i_msg].p_sys= p_sys;
    vlc_mutex_unlock(&url->lock);

    return VLC_SUCCESS;
}",1,1,network\httpd.c,httpd_UrlCatch,,false,1082,1091,httpd_UrlCatch,,,39,"int httpd_UrlCatch (httpd_url_t*,int,httpd_callback_t,httpd_callback_sys_t*)"
145618,METHOD,network\httpd.c:<global>,TYPE_DECL,"void httpd_UrlDelete(httpd_url_t *url)
{
    httpd_host_t *host = url->host;

    vlc_mutex_lock(&host->lock);
    TAB_REMOVE(host->i_url, host->url, url);

    vlc_mutex_destroy(&url->lock);
    free(url->psz_url);
    free(url->psz_user);
    free(url->psz_password);

    for (int i = 0; i < host->i_client; i++) {
        httpd_client_t *client = host->client[i];

        if (client->url != url)
            continue;

        /* TODO complete it */
        msg_Warn(host, ""force closing connections"");
        TAB_REMOVE(host->i_client, host->client, client);
        httpd_ClientDestroy(client);
        i--;
    }
    free(url);
    vlc_mutex_unlock(&host->lock);
}",1,1,network\httpd.c,httpd_UrlDelete,,false,1094,1120,httpd_UrlDelete,,,40,void httpd_UrlDelete (httpd_url_t*)
145711,METHOD,network\httpd.c:<global>,TYPE_DECL,"static void httpd_MsgInit(httpd_message_t *msg)
{
    msg->cl         = NULL;
    msg->i_type     = HTTPD_MSG_NONE;
    msg->i_proto    = HTTPD_PROTO_NONE;
    msg->i_version  = -1; /* FIXME */

    msg->i_status   = 0;

    msg->psz_url    = NULL;
    msg->psz_args   = NULL;

    msg->i_headers  = 0;
    msg->p_headers  = NULL;

    msg->i_body_offset = 0;
    msg->i_body        = 0;
    msg->p_body        = NULL;
}",1,1,network\httpd.c,httpd_MsgInit,,false,1122,1140,httpd_MsgInit,,,41,void httpd_MsgInit (httpd_message_t*)
145777,METHOD,network\httpd.c:<global>,TYPE_DECL,"static void httpd_MsgClean(httpd_message_t *msg)
{
    free(msg->psz_url);
    free(msg->psz_args);
    for (size_t i = 0; i < msg->i_headers; i++) {
        free(msg->p_headers[i].name);
        free(msg->p_headers[i].value);
    }
    free(msg->p_headers);
    free(msg->p_body);
    httpd_MsgInit(msg);
}",1,1,network\httpd.c,httpd_MsgClean,,false,1142,1153,httpd_MsgClean,,,42,void httpd_MsgClean (httpd_message_t*)
145830,METHOD,network\httpd.c:<global>,TYPE_DECL,"const char *httpd_MsgGet(const httpd_message_t *msg, const char *name)
{
    for (size_t i = 0; i < msg->i_headers; i++)
        if (!strcasecmp(msg->p_headers[i].name, name))
            return msg->p_headers[i].value;
    return NULL;
}",1,1,network\httpd.c,httpd_MsgGet,,false,1155,1161,httpd_MsgGet,,,43,"const char* httpd_MsgGet (httpd_message_t*,char*)"
145871,METHOD,network\httpd.c:<global>,TYPE_DECL,"void httpd_MsgAdd(httpd_message_t *msg, const char *name, const char *psz_value, ...)
{
    httpd_header *p_tmp = realloc(msg->p_headers, sizeof(httpd_header) * (msg->i_headers + 1));
    if (!p_tmp)
        return;

    msg->p_headers = p_tmp;

    httpd_header *h = &msg->p_headers[msg->i_headers];
    h->name = strdup(name);
    if (!h->name)
        return;

    h->value = NULL;

    va_list args;
    va_start(args, psz_value);
    int ret = us_vasprintf(&h->value, psz_value, args);
    va_end(args);

    if (ret == -1) {
        free(h->name);
        return;
    }

    msg->i_headers++;
}",1,1,network\httpd.c,httpd_MsgAdd,,false,1163,1189,httpd_MsgAdd,,,44,"void httpd_MsgAdd (httpd_message_t*,char*,char*...)"
145963,METHOD,network\httpd.c:<global>,TYPE_DECL,"static void httpd_ClientInit(httpd_client_t *cl)
{
    cl->i_state = HTTPD_CLIENT_RECEIVING;
    cl->i_buffer_size = HTTPD_CL_BUFSIZE;
    cl->i_buffer = 0;
    cl->p_buffer = xmalloc(cl->i_buffer_size);
    cl->i_keyframe_wait_to_pass = -1;
    cl->b_stream_mode = false;

    httpd_MsgInit(&cl->query);
    httpd_MsgInit(&cl->answer);
}",1,24,network\httpd.c,httpd_ClientInit,,false,1191,1202,httpd_ClientInit,,,45,void httpd_ClientInit (httpd_client_t*)
146014,METHOD,network\httpd.c:<global>,TYPE_DECL,"char* httpd_ClientIP(const httpd_client_t *cl, char *ip, int *port)
{
    return net_GetPeerAddress(vlc_tls_GetFD(cl->sock), ip, port) ? NULL : ip;
}",1,1,network\httpd.c,httpd_ClientIP,,false,1204,1207,httpd_ClientIP,,,46,"char* httpd_ClientIP (httpd_client_t*,char*,int*)"
146032,METHOD,network\httpd.c:<global>,TYPE_DECL,"char* httpd_ServerIP(const httpd_client_t *cl, char *ip, int *port)
{
    return net_GetSockAddress(vlc_tls_GetFD(cl->sock), ip, port) ? NULL : ip;
}",1,1,network\httpd.c,httpd_ServerIP,,false,1209,1212,httpd_ServerIP,,,47,"char* httpd_ServerIP (httpd_client_t*,char*,int*)"
146050,METHOD,network\httpd.c:<global>,TYPE_DECL,"static void httpd_ClientDestroy(httpd_client_t *cl)
{
    vlc_tls_Close(cl->sock);
    httpd_MsgClean(&cl->answer);
    httpd_MsgClean(&cl->query);

    free(cl->p_buffer);
    free(cl);
}",1,1,network\httpd.c,httpd_ClientDestroy,,false,1214,1222,httpd_ClientDestroy,,,48,void httpd_ClientDestroy (httpd_client_t*)
146075,METHOD,network\httpd.c:<global>,TYPE_DECL,"static httpd_client_t *httpd_ClientNew(vlc_tls_t *sock)
{
    httpd_client_t *cl = malloc(sizeof(httpd_client_t));

    if (!cl) return NULL;

    cl->i_ref   = 0;
    cl->sock    = sock;
    cl->url     = NULL;

    httpd_ClientInit(cl);
    return cl;
}",1,1,network\httpd.c,httpd_ClientNew,,false,1224,1236,httpd_ClientNew,,,49,httpd_client_t httpd_ClientNew (vlc_tls_t*)
146111,METHOD,network\httpd.c:<global>,TYPE_DECL,"static
ssize_t httpd_NetRecv (httpd_client_t *cl, uint8_t *p, size_t i_len)
{
    vlc_tls_t *sock = cl->sock;
    struct iovec iov = { .iov_base = p, .iov_len = i_len };
    return sock->readv(sock, &iov, 1);
}",1,1,network\httpd.c,httpd_NetRecv,,false,1238,1244,httpd_NetRecv,,,50,"ssize_t httpd_NetRecv (httpd_client_t*,uint8_t*,size_t)"
146145,METHOD,network\httpd.c:<global>,TYPE_DECL,"static
ssize_t httpd_NetSend (httpd_client_t *cl, const uint8_t *p, size_t i_len)
{
    vlc_tls_t *sock = cl->sock;
    const struct iovec iov = { .iov_base = (void *)p, .iov_len = i_len };
    return sock->writev(sock, &iov, 1);
}",1,1,network\httpd.c,httpd_NetSend,,false,1246,1252,httpd_NetSend,,,51,"ssize_t httpd_NetSend (httpd_client_t*,uint8_t*,size_t)"
146185,METHOD,<empty>,<empty>,<empty>,1,,network\httpd.c,msg_type:<clinit>,,false,1255,,<clinit>,,,4,
146239,METHOD,network\httpd.c:<global>,TYPE_DECL,"static int httpd_ClientRecv(httpd_client_t *cl)
{
    int i_len;

    /* ignore leading whites */
    if (cl->query.i_proto == HTTPD_PROTO_NONE && cl->i_buffer == 0) {
        unsigned char c;

        i_len = httpd_NetRecv(cl, &c, 1);

        if (i_len > 0 && !strchr(""\r\n\t "", c)) {
            cl->p_buffer[0] = c;
            cl->i_buffer++;
        }
    } else if (cl->query.i_proto == HTTPD_PROTO_NONE) {
        /* enough to see if it's Interleaved RTP over RTSP or RTSP/HTTP */
        i_len = httpd_NetRecv(cl, &cl->p_buffer[cl->i_buffer],
                               7 - cl->i_buffer);
        if (i_len > 0)
            cl->i_buffer += i_len;

        /* The smallest legal request is 7 bytes (""GET /\r\n""),
         * this is the maximum we can ask at this point. */
        if (cl->i_buffer >= 7) {
            if (!memcmp(cl->p_buffer, ""HTTP/1."", 7)) {
                cl->query.i_proto = HTTPD_PROTO_HTTP;
                cl->query.i_type  = HTTPD_MSG_ANSWER;
            } el...",1,1,network\httpd.c,httpd_ClientRecv,,false,1277,1565,httpd_ClientRecv,,,55,int httpd_ClientRecv (httpd_client_t*)
147420,METHOD,network\httpd.c:<global>,TYPE_DECL,"static int httpd_ClientSend(httpd_client_t *cl)
{
    int i_len;

    if (cl->i_buffer < 0) {
        /* We need to create the header */
        int i_size = 0;
        char *p;
        const char *psz_status = httpd_ReasonFromCode(cl->answer.i_status);

        i_size = strlen(""HTTP/1."") + 10 + 10 + strlen(psz_status) + 5;
        for (size_t i = 0; i < cl->answer.i_headers; i++)
            i_size += strlen(cl->answer.p_headers[i].name) + 2 +
                      strlen(cl->answer.p_headers[i].value) + 2;

        if (cl->i_buffer_size < i_size) {
            cl->i_buffer_size = i_size;
            free(cl->p_buffer);
            cl->p_buffer = xmalloc(i_size);
        }
        p = (char *)cl->p_buffer;

        p += sprintf(p, ""%s.%u %d %s\r\n"",
                      cl->answer.i_proto ==  HTTPD_PROTO_HTTP ? ""HTTP/1"" : ""RTSP/1"",
                      cl->answer.i_version,
                      cl->answer.i_status, psz_status);
        for (size_t i = 0; i < cl->answer.i_headers...",1,1,network\httpd.c,httpd_ClientSend,,false,1567,1646,httpd_ClientSend,,,56,int httpd_ClientSend (httpd_client_t*)
147801,METHOD,network\httpd.c:<global>,TYPE_DECL,"static void httpd_ClientTlsHandshake(httpd_host_t *host, httpd_client_t *cl)
{
    switch (vlc_tls_SessionHandshake(host->p_tls, cl->sock))
    {
        case -1: cl->i_state = HTTPD_CLIENT_DEAD;       break;
        case 0:  cl->i_state = HTTPD_CLIENT_RECEIVING;  break;
        case 1:  cl->i_state = HTTPD_CLIENT_TLS_HS_IN;  break;
        case 2:  cl->i_state = HTTPD_CLIENT_TLS_HS_OUT; break;
    }
}",1,1,network\httpd.c,httpd_ClientTlsHandshake,,false,1648,1657,httpd_ClientTlsHandshake,,,57,"void httpd_ClientTlsHandshake (httpd_host_t*,httpd_client_t*)"
147849,METHOD,network\httpd.c:<global>,TYPE_DECL,"static bool httpdAuthOk(const char *user, const char *pass, const char *b64)
{
    if (!*user && !*pass)
        return true;

    if (!b64)
        return false;

    if (strncasecmp(b64, ""BASIC"", 5))
        return false;

    b64 += 5;
    while (*b64 == ' ')
        b64++;

    char *given_user = vlc_b64_decode(b64);
    if (!given_user)
        return false;

    char *given_pass = NULL;
    given_pass = strchr (given_user, ':');
    if (!given_pass)
        goto auth_failed;

    *given_pass++ = '\0';

    if (strcmp (given_user, user))
        goto auth_failed;

    if (strcmp (given_pass, pass))
        goto auth_failed;

    free(given_user);
    return true;

auth_failed:
    free(given_user);
    return false;
}",1,1,network\httpd.c,httpdAuthOk,,false,1659,1697,httpdAuthOk,,,58,"bool httpdAuthOk (char*,char*,char*)"
147942,METHOD,network\httpd.c:<global>,TYPE_DECL,"static void httpdLoop(httpd_host_t *host)
{
    struct pollfd ufd[host->nfd + host->i_client];
    unsigned nfd;
    for (nfd = 0; nfd < host->nfd; nfd++) {
        ufd[nfd].fd = host->fds[nfd];
        ufd[nfd].events = POLLIN;
        ufd[nfd].revents = 0;
    }

    /* add all socket that should be read/write and close dead connection */
    while (host->i_url <= 0) {
        mutex_cleanup_push(&host->lock);
        vlc_cond_wait(&host->wait, &host->lock);
        vlc_cleanup_pop();
    }

    mtime_t now = mdate();
    int delay = -1;
    int canc = vlc_savecancel();
    for (int i_client = 0; i_client < host->i_client; i_client++) {
        httpd_client_t *cl = host->client[i_client];
        int val = -1;

        switch (cl->i_state) {
            case HTTPD_CLIENT_RECEIVING:
                val = httpd_ClientRecv(cl);
                break;
            case HTTPD_CLIENT_SENDING:
                val = httpd_ClientSend(cl);
                break;
            case HTTPD_CLIENT_...",1,1,network\httpd.c,httpdLoop,,false,1699,2048,httpdLoop,,,59,void httpdLoop (httpd_host_t*)
149184,METHOD,network\httpd.c:<global>,TYPE_DECL,"static void* httpd_HostThread(void *data)
{
    httpd_host_t *host = data;

    vlc_mutex_lock(&host->lock);
    while (host->i_ref > 0)
        httpdLoop(host);
    vlc_mutex_unlock(&host->lock);
    return NULL;
}",1,1,network\httpd.c,httpd_HostThread,,false,2050,2059,httpd_HostThread,,,60,void* httpd_HostThread (void*)
149213,METHOD,network\httpd.c:<global>,TYPE_DECL,"int httpd_StreamSetHTTPHeaders(httpd_stream_t * p_stream,
                               const httpd_header *p_headers, size_t i_headers)
{
    if (!p_stream)
        return VLC_EGENERIC;

    vlc_mutex_lock(&p_stream->lock);
    if (p_stream->p_http_headers) {
        for (size_t i = 0; i < p_stream->i_http_headers; i++) {
            free(p_stream->p_http_headers[i].name);
            free(p_stream->p_http_headers[i].value);
        }
        free(p_stream->p_http_headers);
        p_stream->p_http_headers = NULL;
        p_stream->i_http_headers = 0;
    }

    if (!p_headers || !i_headers) {
        vlc_mutex_unlock(&p_stream->lock);
        return VLC_SUCCESS;
    }

    p_stream->p_http_headers = vlc_alloc(i_headers, sizeof(httpd_header));
    if (!p_stream->p_http_headers) {
        vlc_mutex_unlock(&p_stream->lock);
        return VLC_ENOMEM;
    }

    size_t j = 0;
    for (size_t i = 0; i < i_headers; i++) {
        if (unlikely(!p_headers[i].name || !p_headers[i].value))...",1,1,network\httpd.c,httpd_StreamSetHTTPHeaders,,false,2061,2108,httpd_StreamSetHTTPHeaders,,,61,"int httpd_StreamSetHTTPHeaders (httpd_stream_t*,httpd_header*,size_t)"
149452,METHOD,network\io.c:<global>,TYPE_DECL,<global>,1,1,network\io.c,network\io.c:<global>,,false,1,411,<global>,,,1,
149454,METHOD,network\io.c:<global>,TYPE_DECL,"extern int rootwrap_bind (int family, int socktype, int protocol,
                          const struct sockaddr *addr, size_t alen);",12,67,network\io.c,rootwrap_bind,,false,52,53,rootwrap_bind,,,1,"int rootwrap_bind (int,int,int,sockaddr*,size_t)"
149463,METHOD,network\io.c:<global>,TYPE_DECL,"int net_Socket (vlc_object_t *p_this, int family, int socktype,
                int protocol)
{
    int fd = vlc_socket (family, socktype, protocol, true);
    if (fd == -1)
    {
        if (net_errno != EAFNOSUPPORT)
            msg_Err (p_this, ""cannot create socket: %s"",
                     vlc_strerror_c(net_errno));
        return -1;
    }

    setsockopt (fd, SOL_SOCKET, SO_REUSEADDR, &(int){ 1 }, sizeof (int));

#ifdef IPV6_V6ONLY
    /*
     * Accepts only IPv6 connections on IPv6 sockets.
     * If possible, we should open two sockets, but it is not always possible.
     */
    if (family == AF_INET6)
        setsockopt (fd, IPPROTO_IPV6, IPV6_V6ONLY, &(int){ 1 }, sizeof (int));
#endif

#if defined (_WIN32)
# ifndef IPV6_PROTECTION_LEVEL
#  warning Please update your C library headers.
#  define IPV6_PROTECTION_LEVEL 23
#  define PROTECTION_LEVEL_UNRESTRICTED 10
# endif
    if (family == AF_INET6)
        setsockopt (fd, IPPROTO_IPV6, IPV6_PROTECTION_LEVEL,
             ...",1,1,network\io.c,net_Socket,,false,55,103,net_Socket,,,2,"int net_Socket (vlc_object_t*,int,int,int)"
149511,METHOD,network\io.c:<global>,TYPE_DECL,"int *net_Listen (vlc_object_t *p_this, const char *psz_host,
                 int i_port, int type, int protocol)
{
    struct addrinfo hints = {
        .ai_socktype = type,
        .ai_protocol = protocol,
        .ai_flags = AI_PASSIVE | AI_NUMERICSERV | AI_IDN,
    }, *res;

    msg_Dbg (p_this, ""net: listening to %s port %d"",
             (psz_host != NULL) ? psz_host : ""*"", i_port);

    int i_val = vlc_getaddrinfo (psz_host, i_port, &hints, &res);
    if (i_val)
    {
        msg_Err (p_this, ""Cannot resolve %s port %d : %s"",
                 (psz_host != NULL) ? psz_host : """", i_port,
                 gai_strerror (i_val));
        return NULL;
    }

    int *sockv = NULL;
    unsigned sockc = 0;

    for (struct addrinfo *ptr = res; ptr != NULL; ptr = ptr->ai_next)
    {
        int fd = net_Socket (p_this, ptr->ai_family, ptr->ai_socktype,
                             ptr->ai_protocol);
        if (fd == -1)
        {
            msg_Dbg (p_this, ""socket error: %s"", vlc_s...",1,1,network\io.c,net_Listen,,false,106,225,net_Listen,,,3,"int* net_Listen (vlc_object_t*,char*,int,int,int)"
149772,METHOD,network\io.c:<global>,TYPE_DECL,"ssize_t (net_Read)(vlc_object_t *restrict obj, int fd,
                   void *restrict buf, size_t len)
{
    size_t rd = 0;

    do
    {
        if (vlc_killed())
        {
            vlc_testcancel();
            errno = EINTR;
            return -1;
        }

        ssize_t val = vlc_recv_i11e(fd, buf, len, 0);
        if (val < 0)
        {
            if (errno == EINTR || errno == EAGAIN)
                continue;
#ifdef _WIN32
            else if (WSAGetLastError() == WSAEMSGSIZE) /* datagram too big */
            {
                msg_Warn(obj, ""read truncated to %zu bytes"", len);
                val = len;
            }
#endif
            else
            {
                msg_Err(obj, ""read error: %s"", vlc_strerror_c(errno));
                return rd ? (ssize_t)rd : -1;
            }
        }

        rd += val;

        if (val == 0)
            break;

        assert(len >= (size_t)val);
        len -= val;
        buf = ((char *)buf) + val;
    }
    while (len...",1,1,network\io.c,,,false,233,278,net_Read,,,4,"ssize_t (vlc_object_t*,int,void*,size_t)"
149864,METHOD,network\io.c:<global>,TYPE_DECL,"ssize_t (net_Write)(vlc_object_t *obj, int fd, const void *buf, size_t len)
{
    size_t written = 0;

    do
    {
        if (vlc_killed())
        {
            vlc_testcancel();
            errno = EINTR;
            return -1;
        }

        ssize_t val = vlc_send_i11e (fd, buf, len, MSG_NOSIGNAL);
        if (val == -1)
        {
            if (errno == EINTR || errno == EAGAIN)
                continue;

            msg_Err(obj, ""write error: %s"", vlc_strerror_c(errno));
            return written ? (ssize_t)written : -1;
        }

        if (val == 0)
            break;

        written += val;
        assert(len >= (size_t)val);
        len -= val;
        buf = ((const char *)buf) + val;
    }
    while (len > 0);

    return written;
}",1,1,network\io.c,,,false,289,323,net_Write,,,5,"ssize_t (vlc_object_t*,int,void*,size_t)"
149955,METHOD,network\io.c:<global>,TYPE_DECL,"char *net_Gets(vlc_object_t *obj, int fd)
{
    char *buf = NULL;
    size_t size = 0, len = 0;

    for (;;)
    {
        if (len == size)
        {
            if (unlikely(size >= (1 << 16)))
            {
                errno = EMSGSIZE;
                goto error; /* put sane buffer size limit */
            }

            char *newbuf = realloc(buf, size + 1024);
            if (unlikely(newbuf == NULL))
                goto error;
            buf = newbuf;
            size += 1024;
        }
        assert(len < size);

        ssize_t val = vlc_recv_i11e(fd, buf + len, size - len, MSG_PEEK);
        if (val <= 0)
            goto error;

        char *end = memchr(buf + len, '\n', val);
        if (end != NULL)
            val = (end + 1) - (buf + len);
        if (recv(fd, buf + len, val, 0) != val)
            goto error;
        len += val;
        if (end != NULL)
            break;
    }

    assert(len > 0);
    buf[--len] = '\0';
    if (len > 0 && buf[--len] == '\r...",1,1,network\io.c,net_Gets,,false,336,382,net_Gets,,,6,"char* net_Gets (vlc_object_t*,int)"
150119,METHOD,network\io.c:<global>,TYPE_DECL,"ssize_t net_Printf( vlc_object_t *p_this, int fd, const char *psz_fmt, ... )
{
    int i_ret;
    va_list args;
    va_start( args, psz_fmt );
    i_ret = net_vaPrintf( p_this, fd, psz_fmt, args );
    va_end( args );

    return i_ret;
}",1,1,network\io.c,net_Printf,,false,385,394,net_Printf,,,7,"ssize_t net_Printf (vlc_object_t*,int,char*...)"
150142,METHOD,network\io.c:<global>,TYPE_DECL,"ssize_t net_vaPrintf( vlc_object_t *p_this, int fd,
                      const char *psz_fmt, va_list args )
{
    char    *psz;
    int      i_ret;

    int i_size = vasprintf( &psz, psz_fmt, args );
    if( i_size == -1 )
        return -1;
    i_ret = net_Write( p_this, fd, psz, i_size ) < i_size
        ? -1 : i_size;
    free( psz );

    return i_ret;
}",1,1,network\io.c,net_vaPrintf,,false,397,411,net_vaPrintf,,,8,"ssize_t net_vaPrintf (vlc_object_t*,int,char*,va_list)"
150213,METHOD,network\rootbind.c:<global>,TYPE_DECL,<global>,1,13,network\rootbind.c,network\rootbind.c:<global>,,false,1,199,<global>,,,1,
150216,METHOD,network\rootbind.c:<global>,TYPE_DECL,"int rootwrap_bind (int, int, int, const struct sockaddr *, size_t);",5,66,network\rootbind.c,rootwrap_bind,,false,33,33,rootwrap_bind,,,2,"int rootwrap_bind (int,int,int,sockaddr*,ANY)"
150225,METHOD,network\rootbind.c:<global>,TYPE_DECL,"static int recv_fd (int p)
{
    struct msghdr hdr;
    struct iovec iov;
    struct cmsghdr *cmsg;
    int val, fd;
    char buf[CMSG_SPACE (sizeof (fd))];

    hdr.msg_name = NULL;
    hdr.msg_namelen = 0;
    hdr.msg_iov = &iov;
    hdr.msg_iovlen = 1;
    hdr.msg_control = buf;
    hdr.msg_controllen = sizeof (buf);

    iov.iov_base = &val;
    iov.iov_len = sizeof (val);

    if (recvmsg (p, &hdr, 0) != sizeof (val))
        return -1;

    for (cmsg = CMSG_FIRSTHDR (&hdr); cmsg != NULL;
         cmsg = CMSG_NXTHDR (&hdr, cmsg))
    {
        if ((cmsg->cmsg_level == SOL_SOCKET)
         && (cmsg->cmsg_type == SCM_RIGHTS)
         && (cmsg->cmsg_len >= CMSG_LEN (sizeof (fd))))
        {
            memcpy (&fd, CMSG_DATA (cmsg), sizeof (fd));
            return fd;
        }
    }

    errno = val;
    return -1;
}",1,13,network\rootbind.c,recv_fd,,false,75,110,recv_fd,,,3,int recv_fd (int)
150361,METHOD,network\rootbind.c:<global>,TYPE_DECL,"int rootwrap_bind (int family, int socktype, int protocol,
                   const struct sockaddr *addr, size_t alen)
{
    /* can't use libvlc */
    static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
    struct sockaddr_storage ss;
    int fd, sock = -1;

    const char *sockenv = getenv (""VLC_ROOTWRAP_SOCK"");
    if (sockenv != NULL)
        sock = atoi (sockenv);
    if (sock == -1)
    {
        errno = EACCES;
        return -1;
    }

    switch (family)
    {
        case AF_INET:
            if (alen < sizeof (struct sockaddr_in))
            {
                errno = EINVAL;
                return -1;
            }
            break;

#ifdef AF_INET6
        case AF_INET6:
            if (alen < sizeof (struct sockaddr_in6))
            {
                errno = EINVAL;
                return -1;
            }
            break;
#endif

        default:
            errno = EAFNOSUPPORT;
            return -1;
    }

    if (family != addr->sa_family)
    {
       ...",1,38,network\rootbind.c,rootwrap_bind,,false,115,184,rootwrap_bind,,,4,"int rootwrap_bind (int,int,int,sockaddr*,size_t)"
150533,METHOD,network\tcp.c:<global>,TYPE_DECL,<global>,1,1,network\tcp.c,network\tcp.c:<global>,,false,1,542,<global>,,,1,
150535,METHOD,network\tcp.c:<global>,TYPE_DECL,"static int SocksNegotiate( vlc_object_t *, int fd, int i_socks_version,
                           const char *psz_user, const char *psz_passwd );",12,73,network\tcp.c,SocksNegotiate,,false,54,55,SocksNegotiate,,,1,"int SocksNegotiate (vlc_object_t*,int,int,char*,char*)"
150544,METHOD,network\tcp.c:<global>,TYPE_DECL,"static int SocksHandshakeTCP( vlc_object_t *,
                              int fd, int i_socks_version,
                              const char *psz_user, const char *psz_passwd,
                              const char *psz_host, int i_port );",12,64,network\tcp.c,SocksHandshakeTCP,,false,56,59,SocksHandshakeTCP,,,2,"int SocksHandshakeTCP (vlc_object_t*,int,int,char*,char*,char*,int)"
150555,METHOD,network\tcp.c:<global>,TYPE_DECL,"extern int net_Socket( vlc_object_t *p_this, int i_family, int i_socktype,
                       int i_protocol );",12,39,network\tcp.c,net_Socket,,false,60,61,net_Socket,,,3,"int net_Socket (vlc_object_t*,int,int,int)"
150563,METHOD,network\tcp.c:<global>,TYPE_DECL,"int net_Connect( vlc_object_t *p_this, const char *psz_host, int i_port,
                 int type, int proto )
{
    const char      *psz_realhost;
    char            *psz_socks;
    int             i_realport, i_handle = -1;

    psz_socks = var_InheritString( p_this, ""socks"" );
    if( psz_socks != NULL )
    {
        char *psz = strchr( psz_socks, ':' );

        if( psz )
            *psz++ = '\0';

        psz_realhost = psz_socks;
        i_realport = ( psz != NULL ) ? atoi( psz ) : 1080;

        msg_Dbg( p_this, ""net: connecting to %s port %d (SOCKS) ""
                 ""for %s port %d"", psz_realhost, i_realport,
                 psz_host, i_port );

        /* We only implement TCP with SOCKS */
        switch( type )
        {
            case 0:
                type = SOCK_STREAM;
            case SOCK_STREAM:
                break;
            default:
                msg_Err( p_this, ""Socket type not supported through SOCKS"" );
                free( psz_socks );
     ...",1,1,network\tcp.c,net_Connect,,false,70,239,net_Connect,,,4,"int net_Connect (vlc_object_t*,char*,int,int,int)"
150959,METHOD,network\tcp.c:<global>,TYPE_DECL,"int net_AcceptSingle (vlc_object_t *obj, int lfd)
{
    int fd = vlc_accept (lfd, NULL, NULL, true);
    if (fd == -1)
    {
        if (net_errno != EAGAIN)
#if (EAGAIN != EWOULDBLOCK)
          if (net_errno != EWOULDBLOCK)
#endif
            msg_Err (obj, ""accept failed (from socket %d): %s"", lfd,
                     vlc_strerror_c(net_errno));
        return -1;
    }

    msg_Dbg (obj, ""accepted socket %d (from socket %d)"", fd, lfd);
    setsockopt (fd, SOL_SOCKET, SO_REUSEADDR, &(int){ 1 }, sizeof(int));
    return fd;
}",1,1,network\tcp.c,net_AcceptSingle,,false,242,259,net_AcceptSingle,,,5,"int net_AcceptSingle (vlc_object_t*,int)"
151011,METHOD,network\tcp.c:<global>,TYPE_DECL,"int net_Accept (vlc_object_t *p_this, int *pi_fd)
{
    assert (pi_fd != NULL);

    unsigned n = 0;
    while (pi_fd[n] != -1)
        n++;

    struct pollfd ufd[n];
    /* Initialize file descriptor set */
    for (unsigned i = 0; i < n; i++)
    {
        ufd[i].fd = pi_fd[i];
        ufd[i].events = POLLIN;
    }

    for (;;)
    {
        while (poll (ufd, n, -1) == -1)
        {
            if (net_errno != EINTR)
            {
                msg_Err (p_this, ""poll error: %s"", vlc_strerror_c(net_errno));
                return -1;
            }
        }

        for (unsigned i = 0; i < n; i++)
        {
            if (ufd[i].revents == 0)
                continue;

            int sfd = ufd[i].fd;
            int fd = net_AcceptSingle (p_this, sfd);
            if (fd == -1)
                continue;

            /*
             * Move listening socket to the end to let the others in the
             * set a chance next time.
             */
            memmove (pi_fd + ...",1,1,network\tcp.c,net_Accept,,false,274,321,net_Accept,,,6,"int net_Accept (vlc_object_t*,int*)"
151158,METHOD,network\tcp.c:<global>,TYPE_DECL,"static int SocksNegotiate( vlc_object_t *p_obj,
                           int fd, int i_socks_version,
                           const char *psz_socks_user,
                           const char *psz_socks_passwd )
{
    uint8_t buffer[128+2*256];
    int i_len;
    bool b_auth = false;

    if( i_socks_version != 5 )
        return VLC_SUCCESS;

    /* We negotiate authentication */
    buffer[0] = i_socks_version;    /* SOCKS version */
    if( psz_socks_user != NULL && psz_socks_passwd != NULL )
    {
        buffer[1] = 2;                  /* Number of methods */
        buffer[2] = 0x00;               /* - No auth required */
        buffer[3] = 0x02;               /* - USer/Password */
        i_len = 4;
        b_auth = true;
    }
    else
    {
        buffer[1] = 1;                  /* Number of methods */
        buffer[2] = 0x00;               /* - No auth required */
        i_len = 3;
    }

    if( net_Write( p_obj, fd, buffer, i_len ) != i_len )
        return VLC_...",1,1,network\tcp.c,SocksNegotiate,,false,329,422,SocksNegotiate,,,7,"int SocksNegotiate (vlc_object_t*,int,int,char*,char*)"
151426,METHOD,network\tcp.c:<global>,TYPE_DECL,"static int SocksHandshakeTCP( vlc_object_t *p_obj,
                              int fd,
                              int i_socks_version,
                              const char *psz_user, const char *psz_passwd,
                              const char *psz_host, int i_port )
{
    uint8_t buffer[128+2*256];

    if( i_socks_version != 4 && i_socks_version != 5 )
    {
        msg_Warn( p_obj, ""invalid socks protocol version %d"", i_socks_version );
        i_socks_version = 5;
    }

    if( i_socks_version == 5 &&
        SocksNegotiate( p_obj, fd, i_socks_version,
                        psz_user, psz_passwd ) )
        return VLC_EGENERIC;

    if( i_socks_version == 4 )
    {
        /* v4 only support ipv4 */
        static const struct addrinfo hints = {
            .ai_family = AF_INET,
            .ai_socktype = SOCK_STREAM,
            .ai_protocol = IPPROTO_TCP,
            .ai_flags = AI_IDN,
        };
        struct addrinfo *res;

        if (vlc_getaddrinfo_i11e(p...",1,1,network\tcp.c,SocksHandshakeTCP,,false,429,530,SocksHandshakeTCP,,,8,"int SocksHandshakeTCP (vlc_object_t*,int,int,char*,char*,char*,int)"
151753,METHOD,network\tcp.c:<global>,TYPE_DECL,"void net_ListenClose( int *pi_fd )
{
    if( pi_fd != NULL )
    {
        int *pi;

        for( pi = pi_fd; *pi != -1; pi++ )
            net_Close( *pi );
        free( pi_fd );
    }
}",1,1,network\tcp.c,net_ListenClose,,false,532,542,net_ListenClose,,,9,void net_ListenClose (int*)
151812,METHOD,network\tls.c:<global>,TYPE_DECL,<global>,1,24,network\tls.c,network\tls.c:<global>,,false,1,671,<global>,,,1,
151814,METHOD,network\tls.c:<global>,TYPE_DECL,"static int tls_server_load(void *func, va_list ap)
{
    int (*activate) (vlc_tls_creds_t *, const char *, const char *) = func;
    vlc_tls_creds_t *crd = va_arg (ap, vlc_tls_creds_t *);
    const char *cert = va_arg (ap, const char *);
    const char *key = va_arg (ap, const char *);

    return activate (crd, cert, key);
}",1,1,network\tls.c,tls_server_load,,false,60,68,tls_server_load,,,1,"int tls_server_load (void*,va_list)"
151818,METHOD,network\tls.c:<global>,TYPE_DECL,"int (*activate) (vlc_tls_creds_t *, const char *, const char *) = func;",9,74,network\tls.c,tls_server_load.activate,,false,62,62,activate,,,1,"int tls_server_load.activate (vlc_tls_creds_t*,char*,char*)"
151835,METHOD,network\tls.c:<global>,TYPE_DECL,"static int tls_client_load(void *func, va_list ap)
{
    int (*activate) (vlc_tls_creds_t *) = func;
    vlc_tls_creds_t *crd = va_arg (ap, vlc_tls_creds_t *);

    return activate (crd);
}",1,1,network\tls.c,tls_client_load,,false,70,76,tls_client_load,,,2,"int tls_client_load (void*,va_list)"
151839,METHOD,network\tls.c:<global>,TYPE_DECL,int (*activate) (vlc_tls_creds_t *) = func;,9,46,network\tls.c,tls_client_load.activate,,false,72,72,activate,,,1,int tls_client_load.activate (vlc_tls_creds_t*)
151850,METHOD,network\tls.c:<global>,TYPE_DECL,"static void tls_unload(void *func, va_list ap)
{
    void (*deactivate) (vlc_tls_creds_t *) = func;
    vlc_tls_creds_t *crd = va_arg (ap, vlc_tls_creds_t *);

    deactivate (crd);
}",1,1,network\tls.c,tls_unload,,false,78,84,tls_unload,,,3,"void tls_unload (void*,va_list)"
151854,METHOD,network\tls.c:<global>,TYPE_DECL,void (*deactivate) (vlc_tls_creds_t *) = func;,10,49,network\tls.c,tls_unload.deactivate,,false,80,80,deactivate,,,1,void tls_unload.deactivate (vlc_tls_creds_t*)
151864,METHOD,network\tls.c:<global>,TYPE_DECL,"vlc_tls_creds_t *
vlc_tls_ServerCreate (vlc_object_t *obj, const char *cert_path,
                      const char *key_path)
{
    vlc_tls_creds_t *srv = vlc_custom_create (obj, sizeof (*srv),
                                              ""tls server"");
    if (unlikely(srv == NULL))
        return NULL;

    if (key_path == NULL)
        key_path = cert_path;

    srv->module = vlc_module_load (srv, ""tls server"", NULL, false,
                                   tls_server_load, srv, cert_path, key_path);
    if (srv->module == NULL)
    {
        msg_Err (srv, ""TLS server plugin not available"");
        vlc_object_release (srv);
        return NULL;
    }

    return srv;
}",1,27,network\tls.c,vlc_tls_ServerCreate,,false,86,108,vlc_tls_ServerCreate,,,4,"vlc_tls_creds_t vlc_tls_ServerCreate (vlc_object_t*,char*,char*)"
151929,METHOD,network\tls.c:<global>,TYPE_DECL,"vlc_tls_creds_t *vlc_tls_ClientCreate (vlc_object_t *obj)
{
    vlc_tls_creds_t *crd = vlc_custom_create (obj, sizeof (*crd),
                                              ""tls client"");
    if (unlikely(crd == NULL))
        return NULL;

    crd->module = vlc_module_load (crd, ""tls client"", NULL, false,
                                   tls_client_load, crd);
    if (crd->module == NULL)
    {
        msg_Err (crd, ""TLS client plugin not available"");
        vlc_object_release (crd);
        return NULL;
    }

    return crd;
}",1,27,network\tls.c,vlc_tls_ClientCreate,,false,110,127,vlc_tls_ClientCreate,,,5,vlc_tls_creds_t vlc_tls_ClientCreate (vlc_object_t*)
151982,METHOD,network\tls.c:<global>,TYPE_DECL,"void vlc_tls_Delete (vlc_tls_creds_t *crd)
{
    if (crd == NULL)
        return;

    vlc_module_unload(crd, crd->module, tls_unload, crd);
    vlc_object_release (crd);
}",1,1,network\tls.c,vlc_tls_Delete,,false,129,136,vlc_tls_Delete,,,6,void vlc_tls_Delete (vlc_tls_creds_t*)
152002,METHOD,network\tls.c:<global>,TYPE_DECL,"static vlc_tls_t *vlc_tls_SessionCreate(vlc_tls_creds_t *crd,
                                        vlc_tls_t *sock,
                                        const char *host,
                                        const char *const *alpn)
{
    vlc_tls_t *session;
    int canc = vlc_savecancel();
    session = crd->open(crd, sock, host, alpn);
    vlc_restorecancel(canc);
    if (session != NULL)
        session->p = sock;
    return session;
}",1,1,network\tls.c,vlc_tls_SessionCreate,,false,141,153,vlc_tls_SessionCreate,,,7,"vlc_tls_t vlc_tls_SessionCreate (vlc_tls_creds_t*,vlc_tls_t*,char*,char**)"
152039,METHOD,network\tls.c:<global>,TYPE_DECL,"void vlc_tls_SessionDelete (vlc_tls_t *session)
{
    int canc = vlc_savecancel();
    session->close(session);
    vlc_restorecancel(canc);
}",1,1,network\tls.c,vlc_tls_SessionDelete,,false,155,160,vlc_tls_SessionDelete,,,8,void vlc_tls_SessionDelete (vlc_tls_t*)
152055,METHOD,network\tls.c:<global>,TYPE_DECL,"static void cleanup_tls(void *data)
{
    vlc_tls_t *session = data;

    vlc_tls_SessionDelete (session);
}",1,1,network\tls.c,cleanup_tls,,false,162,167,cleanup_tls,,,9,void cleanup_tls (void*)
152066,METHOD,network\tls.c:<global>,TYPE_DECL,"vlc_tls_t *vlc_tls_ClientSessionCreate(vlc_tls_creds_t *crd, vlc_tls_t *sock,
                                       const char *host, const char *service,
                                       const char *const *alpn, char **alp)
{
    int val;

    vlc_tls_t *session = vlc_tls_SessionCreate(crd, sock, host, alpn);
    if (session == NULL)
        return NULL;

    int canc = vlc_savecancel();
    mtime_t deadline = mdate ();
    deadline += var_InheritInteger (crd, ""ipv4-timeout"") * 1000;

    struct pollfd ufd[1];
    ufd[0].fd = vlc_tls_GetFD(sock);

    vlc_cleanup_push (cleanup_tls, session);
    while ((val = crd->handshake(crd, session, host, service, alp)) != 0)
    {
        if (val < 0 || vlc_killed() )
        {
            if (val < 0)
                msg_Err(crd, ""TLS session handshake error"");
error:
            vlc_tls_SessionDelete (session);
            session = NULL;
            break;
        }

        mtime_t now = mdate ();
        if (now > deadline)
      ...",1,1,network\tls.c,vlc_tls_ClientSessionCreate,,false,170,219,vlc_tls_ClientSessionCreate,,,10,"vlc_tls_t vlc_tls_ClientSessionCreate (vlc_tls_creds_t*,vlc_tls_t*,char*,char*,char**,char**)"
152213,METHOD,network\tls.c:<global>,TYPE_DECL,"vlc_tls_t *vlc_tls_ServerSessionCreate(vlc_tls_creds_t *crd,
                                       vlc_tls_t *sock,
                                       const char *const *alpn)
{
    return vlc_tls_SessionCreate(crd, sock, NULL, alpn);
}",1,1,network\tls.c,vlc_tls_ServerSessionCreate,,false,221,226,vlc_tls_ServerSessionCreate,,,11,"vlc_tls_t vlc_tls_ServerSessionCreate (vlc_tls_creds_t*,vlc_tls_t*,char**)"
152226,METHOD,network\tls.c:<global>,TYPE_DECL,"ssize_t vlc_tls_Read(vlc_tls_t *session, void *buf, size_t len, bool waitall)
{
    struct pollfd ufd;
    struct iovec iov;

    ufd.fd = vlc_tls_GetFD(session);
    ufd.events = POLLIN;
    iov.iov_base = buf;
    iov.iov_len = len;

    for (size_t rcvd = 0;;)
    {
        if (vlc_killed())
        {
            errno = EINTR;
            return -1;
        }

        ssize_t val = session->readv(session, &iov, 1);
        if (val > 0)
        {
            if (!waitall)
                return val;
            iov.iov_base = (char *)iov.iov_base + val;
            iov.iov_len -= val;
            rcvd += val;
        }
        if (iov.iov_len == 0 || val == 0)
            return rcvd;
        if (val == -1)
        {
            if (vlc_killed())
                return -1;
            if (errno != EINTR && errno != EAGAIN)
                return rcvd ? (ssize_t)rcvd : -1;
        }

        vlc_poll_i11e(&ufd, 1, -1);
    }
}",1,1,network\tls.c,vlc_tls_Read,,false,228,267,vlc_tls_Read,,,12,"ssize_t vlc_tls_Read (vlc_tls_t*,void*,size_t,bool)"
152362,METHOD,network\tls.c:<global>,TYPE_DECL,"ssize_t vlc_tls_Write(vlc_tls_t *session, const void *buf, size_t len)
{
    struct pollfd ufd;
    struct iovec iov;

    ufd.fd = vlc_tls_GetFD(session);
    ufd.events = POLLOUT;
    iov.iov_base = (void *)buf;
    iov.iov_len = len;

    for (size_t sent = 0;;)
    {
        if (vlc_killed())
        {
            errno = EINTR;
            return -1;
        }

        ssize_t val = session->writev(session, &iov, 1);
        if (val > 0)
        {
            iov.iov_base = ((char *)iov.iov_base) + val;
            iov.iov_len -= val;
            sent += val;
        }
        if (iov.iov_len == 0 || val == 0)
            return sent;
        if (val == -1)
        {
            if (vlc_killed())
                return -1;
            if (errno != EINTR && errno != EAGAIN)
                return sent ? (ssize_t)sent : -1;
        }

        vlc_poll_i11e(&ufd, 1, -1);
    }
}",1,1,network\tls.c,vlc_tls_Write,,false,269,306,vlc_tls_Write,,,13,"ssize_t vlc_tls_Write (vlc_tls_t*,void*,size_t)"
152493,METHOD,network\tls.c:<global>,TYPE_DECL,"char *vlc_tls_GetLine(vlc_tls_t *session)
{
    char *line = NULL;
    size_t linelen = 0, linesize = 0;

    do
    {
        if (linelen == linesize)
        {
            linesize += 1024;

            char *newline = realloc(line, linesize);
            if (unlikely(newline == NULL))
                goto error;
            line = newline;
        }

        if (vlc_tls_Read(session, line + linelen, 1, false) <= 0)
            goto error;
    }
    while (line[linelen++] != '\n');

    if (linelen >= 2 && line[linelen - 2] == '\r')
        line[linelen - 2] = '\0';
    else
        line[linelen - 1] = '\0';
    return line;

error:
    free(line);
    return NULL;
}",1,1,network\tls.c,vlc_tls_GetLine,,false,308,339,vlc_tls_GetLine,,,14,char* vlc_tls_GetLine (vlc_tls_t*)
152597,METHOD,<empty>,<empty>,<empty>,1,,network\tls.c,vlc_tls_socket:<clinit>,,false,341,,<clinit>,,,7,
152603,METHOD,network\tls.c:<global>,TYPE_DECL,"static int vlc_tls_SocketGetFD(vlc_tls_t *tls)
{
    vlc_tls_socket_t *sock = (struct vlc_tls_socket *)tls;

    return sock->fd;
}",1,1,network\tls.c,vlc_tls_SocketGetFD,,false,349,354,vlc_tls_SocketGetFD,,,17,int vlc_tls_SocketGetFD (vlc_tls_t*)
152618,METHOD,network\tls.c:<global>,TYPE_DECL,"static ssize_t vlc_tls_SocketRead(vlc_tls_t *tls, struct iovec *iov,
                                  unsigned count)
{
    struct msghdr msg =
    {
        .msg_iov = iov,
        .msg_iovlen = count,
    };

    return recvmsg(vlc_tls_SocketGetFD(tls), &msg, 0);
}",1,1,network\tls.c,vlc_tls_SocketRead,,false,356,366,vlc_tls_SocketRead,,,18,"ssize_t vlc_tls_SocketRead (vlc_tls_t*,iovec*,unsigned)"
152644,METHOD,network\tls.c:<global>,TYPE_DECL,"static ssize_t vlc_tls_SocketWrite(vlc_tls_t *tls, const struct iovec *iov,
                                   unsigned count)
{
    const struct msghdr msg =
    {
        .msg_iov = (struct iovec *)iov,
        .msg_iovlen = count,
    };

    return sendmsg(vlc_tls_SocketGetFD(tls), &msg, MSG_NOSIGNAL);
}",1,1,network\tls.c,vlc_tls_SocketWrite,,false,368,378,vlc_tls_SocketWrite,,,19,"ssize_t vlc_tls_SocketWrite (vlc_tls_t*,iovec*,unsigned)"
152672,METHOD,network\tls.c:<global>,TYPE_DECL,"static int vlc_tls_SocketShutdown(vlc_tls_t *tls, bool duplex)
{
    return shutdown(vlc_tls_SocketGetFD(tls), duplex ? SHUT_RDWR : SHUT_WR);
}",1,1,network\tls.c,vlc_tls_SocketShutdown,,false,380,383,vlc_tls_SocketShutdown,,,20,"int vlc_tls_SocketShutdown (vlc_tls_t*,bool)"
152686,METHOD,network\tls.c:<global>,TYPE_DECL,"static void vlc_tls_SocketClose(vlc_tls_t *tls)
{
    net_Close(vlc_tls_SocketGetFD(tls));
    free(tls);
}",1,1,network\tls.c,vlc_tls_SocketClose,,false,385,389,vlc_tls_SocketClose,,,21,void vlc_tls_SocketClose (vlc_tls_t*)
152696,METHOD,network\tls.c:<global>,TYPE_DECL,"static vlc_tls_t *vlc_tls_SocketAlloc(int fd,
                                      const struct sockaddr *restrict peer,
                                      socklen_t peerlen)
{
    vlc_tls_socket_t *sock = malloc(sizeof (*sock) + peerlen);
    if (unlikely(sock == NULL))
        return NULL;

    vlc_tls_t *tls = &sock->tls;

    tls->get_fd = vlc_tls_SocketGetFD;
    tls->readv = vlc_tls_SocketRead;
    tls->writev = vlc_tls_SocketWrite;
    tls->shutdown = vlc_tls_SocketShutdown;
    tls->close = vlc_tls_SocketClose;
    tls->p = NULL;

    sock->fd = fd;
    sock->peerlen = peerlen;
    if (peerlen > 0)
        memcpy(sock->peer, peer, peerlen);
    return tls;
}",1,1,network\tls.c,vlc_tls_SocketAlloc,,false,391,413,vlc_tls_SocketAlloc,,,22,"vlc_tls_t vlc_tls_SocketAlloc (int,sockaddr*,socklen_t)"
152780,METHOD,network\tls.c:<global>,TYPE_DECL,"vlc_tls_t *vlc_tls_SocketOpen(int fd)
{
    return vlc_tls_SocketAlloc(fd, NULL, 0);
}",1,1,network\tls.c,vlc_tls_SocketOpen,,false,415,418,vlc_tls_SocketOpen,,,23,vlc_tls_t vlc_tls_SocketOpen (int)
152790,METHOD,network\tls.c:<global>,TYPE_DECL,"int vlc_tls_SocketPair(int family, int protocol, vlc_tls_t *pair[2])
{
    int fds[2];

    if (vlc_socketpair(family, SOCK_STREAM, protocol, fds, true))
        return -1;

    for (size_t i = 0; i < 2; i++)
    {
        setsockopt(fds[i], SOL_SOCKET, SO_REUSEADDR,
                   &(int){ 1 }, sizeof (int));

        pair[i] = vlc_tls_SocketAlloc(fds[i], NULL, 0);
        if (unlikely(pair[i] == NULL))
        {
            net_Close(fds[i]);
            if (i)
                vlc_tls_SessionDelete(pair[0]);
            else
                net_Close(fds[1]);
            return -1;
        }
    }
    return 0;
}",1,1,network\tls.c,vlc_tls_SocketPair,,false,420,444,vlc_tls_SocketPair,,,24,"int vlc_tls_SocketPair (int,int,vlc_tls_t[2]*)"
152874,METHOD,network\tls.c:<global>,TYPE_DECL,"static vlc_tls_t *vlc_tls_SocketAddrInfo(const struct addrinfo *restrict info)
{
    int fd = vlc_socket(info->ai_family, info->ai_socktype, info->ai_protocol,
                        true /* nonblocking */);
    if (fd == -1)
        return NULL;

    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &(int){ 1 }, sizeof (int));

    if (info->ai_socktype == SOCK_STREAM && info->ai_protocol == IPPROTO_TCP)
        setsockopt(fd, SOL_TCP, TCP_NODELAY, &(int){ 1 }, sizeof (int));

    vlc_tls_t *sk = vlc_tls_SocketAlloc(fd, info->ai_addr, info->ai_addrlen);
    if (unlikely(sk == NULL))
        net_Close(fd);
    return sk;
}",1,23,network\tls.c,vlc_tls_SocketAddrInfo,,false,449,465,vlc_tls_SocketAddrInfo,,,25,vlc_tls_t vlc_tls_SocketAddrInfo (addrinfo*)
152959,METHOD,network\tls.c:<global>,TYPE_DECL,"static int vlc_tls_WaitConnect(vlc_tls_t *tls)
{
    const int fd = vlc_tls_GetFD(tls);
    struct pollfd ufd;

    ufd.fd = fd;
    ufd.events = POLLOUT;

    do
    {
        if (vlc_killed())
        {
            errno = EINTR;
            return -1;
        }
    }
    while (vlc_poll_i11e(&ufd, 1, -1) <= 0);

    int val;
    socklen_t len = sizeof (val);

    if (getsockopt(fd, SOL_SOCKET, SO_ERROR, &val, &len))
        return -1;

    if (val != 0)
    {
        errno = val;
        return -1;
    }
    return 0;
}",1,1,network\tls.c,vlc_tls_WaitConnect,,false,470,500,vlc_tls_WaitConnect,,,26,int vlc_tls_WaitConnect (vlc_tls_t*)
153031,METHOD,network\tls.c:<global>,TYPE_DECL,"static ssize_t vlc_tls_Connect(vlc_tls_t *tls)
{
    const vlc_tls_socket_t *sock = (vlc_tls_socket_t *)tls;

    if (connect(sock->fd, sock->peer, sock->peerlen) == 0)
        return 0;
#ifndef _WIN32
    if (errno != EINPROGRESS)
        return -1;
#else
    if (WSAGetLastError() != WSAEWOULDBLOCK)
        return -1;
#endif
    return vlc_tls_WaitConnect(tls);
}",1,1,network\tls.c,vlc_tls_Connect,,false,505,519,vlc_tls_Connect,,,27,ssize_t vlc_tls_Connect (vlc_tls_t*)
153069,METHOD,network\tls.c:<global>,TYPE_DECL,"static ssize_t vlc_tls_ConnectWrite(vlc_tls_t *tls,
                                    const struct iovec *iov,unsigned count)
{
#ifdef MSG_FASTOPEN
    vlc_tls_socket_t *sock = (vlc_tls_socket_t *)tls;
    const struct msghdr msg =
    {
        .msg_name = sock->peer,
        .msg_namelen = sock->peerlen,
        .msg_iov = (struct iovec *)iov,
        .msg_iovlen = count,
    };
    ssize_t ret;

    /* Next time, write directly. Do not retry to connect. */
    tls->writev = vlc_tls_SocketWrite;

    ret = sendmsg(vlc_tls_SocketGetFD(tls), &msg, MSG_NOSIGNAL|MSG_FASTOPEN);
    if (ret >= 0)
    {   /* Fast open in progress */
        return ret;
    }

    if (errno == EINPROGRESS)
    {
        if (vlc_tls_WaitConnect(tls))
            return -1;
    }
    else
    if (errno != EOPNOTSUPP)
        return -1;
    /* Fast open not supported or disabled... fallback to normal mode */
#else
    tls->writev = vlc_tls_SocketWrite;
#endif

    if (vlc_tls_Connect(tls))
        return -...",1,1,network\tls.c,vlc_tls_ConnectWrite,,false,522,562,vlc_tls_ConnectWrite,,,28,"ssize_t vlc_tls_ConnectWrite (vlc_tls_t*,iovec*,unsigned)"
153093,METHOD,network\tls.c:<global>,TYPE_DECL,"vlc_tls_t *vlc_tls_SocketOpenAddrInfo(const struct addrinfo *restrict info,
                                      bool defer_connect)
{
    vlc_tls_t *sock = vlc_tls_SocketAddrInfo(info);
    if (sock == NULL)
        return NULL;

    if (defer_connect)
    {   /* The socket is not connected yet.
         * The connection will be triggered on the first send. */
        sock->writev = vlc_tls_ConnectWrite;
    }
    else
    {
        if (vlc_tls_Connect(sock))
        {
            vlc_tls_SessionDelete(sock);
            sock = NULL;
        }
    }
    return sock;
}",1,1,network\tls.c,vlc_tls_SocketOpenAddrInfo,,false,564,585,vlc_tls_SocketOpenAddrInfo,,,29,"vlc_tls_t vlc_tls_SocketOpenAddrInfo (addrinfo*,bool)"
153132,METHOD,network\tls.c:<global>,TYPE_DECL,"vlc_tls_t *vlc_tls_SocketOpenTCP(vlc_object_t *obj, const char *name,
                                 unsigned port)
{
    struct addrinfo hints =
    {
        .ai_socktype = SOCK_STREAM,
        .ai_protocol = IPPROTO_TCP,
    }, *res;

    assert(name != NULL);
    msg_Dbg(obj, ""resolving %s ..."", name);

    int val = vlc_getaddrinfo_i11e(name, port, &hints, &res);
    if (val != 0)
    {   /* TODO: C locale for gai_strerror() */
        msg_Err(obj, ""cannot resolve %s port %u: %s"", name, port,
                gai_strerror(val));
        return NULL;
    }

    msg_Dbg(obj, ""connecting to %s port %u ..."", name, port);

    /* TODO: implement RFC6555 */
    for (const struct addrinfo *p = res; p != NULL; p = p->ai_next)
    {
        vlc_tls_t *tls = vlc_tls_SocketOpenAddrInfo(p, false);
        if (tls == NULL)
        {
            msg_Err(obj, ""connection error: %s"", vlc_strerror_c(errno));
            continue;
        }

        freeaddrinfo(res);
        return tls;
    }
...",1,1,network\tls.c,vlc_tls_SocketOpenTCP,,false,587,625,vlc_tls_SocketOpenTCP,,,30,"vlc_tls_t vlc_tls_SocketOpenTCP (vlc_object_t*,char*,unsigned)"
153229,METHOD,network\tls.c:<global>,TYPE_DECL,"vlc_tls_t *vlc_tls_SocketOpenTLS(vlc_tls_creds_t *creds, const char *name,
                                 unsigned port, const char *service,
                                 const char *const *alpn, char **alp)
{
    struct addrinfo hints =
    {
        .ai_socktype = SOCK_STREAM,
        .ai_protocol = IPPROTO_TCP,
    }, *res;

    msg_Dbg(creds, ""resolving %s ..."", name);

    int val = vlc_getaddrinfo_i11e(name, port, &hints, &res);
    if (val != 0)
    {   /* TODO: C locale for gai_strerror() */
        msg_Err(creds, ""cannot resolve %s port %u: %s"", name, port,
                gai_strerror(val));
        return NULL;
    }

    for (const struct addrinfo *p = res; p != NULL; p = p->ai_next)
    {
        vlc_tls_t *tcp = vlc_tls_SocketOpenAddrInfo(p, true);
        if (tcp == NULL)
        {
            msg_Err(creds, ""socket error: %s"", vlc_strerror_c(errno));
            continue;
        }

        vlc_tls_t *tls = vlc_tls_ClientSessionCreate(creds, tcp, name, service,...",1,1,network\tls.c,vlc_tls_SocketOpenTLS,,false,627,671,vlc_tls_SocketOpenTLS,,,31,"vlc_tls_t vlc_tls_SocketOpenTLS (vlc_tls_creds_t*,char*,unsigned,char*,char**,char**)"
153365,METHOD,network\udp.c:<global>,TYPE_DECL,<global>,1,20,network\udp.c,network\udp.c:<global>,,false,1,745,<global>,,,1,
153367,METHOD,network\udp.c:<global>,TYPE_DECL,"extern int net_Socket( vlc_object_t *p_this, int i_family, int i_socktype,
                       int i_protocol );",12,39,network\udp.c,net_Socket,,false,89,90,net_Socket,,,1,"int net_Socket (vlc_object_t*,int,int,int)"
153375,METHOD,network\udp.c:<global>,TYPE_DECL,"static int net_SetupDgramSocket (vlc_object_t *p_obj, int fd,
                                 const struct addrinfo *ptr)
{
#if defined (SO_REUSEPORT) && !defined (__linux__)
    setsockopt (fd, SOL_SOCKET, SO_REUSEPORT, &(int){ 1 }, sizeof (int));
#endif

#if defined (_WIN32)

    /* Check windows version so we know if we need to increase receive buffers
     * for Windows 7 and earlier

     * SetSocketMediaStreamingMode is present in win 8 and later, so we set
     * receive buffer if that isn't present
     */
#if (_WIN32_WINNT < _WIN32_WINNT_WIN8)
    HINSTANCE h_Network = LoadLibrary(TEXT(""Windows.Networking.dll""));
    if( (h_Network == NULL) ||
        (GetProcAddress( h_Network, ""SetSocketMediaStreamingMode"" ) == NULL ) )
    {
        setsockopt (fd, SOL_SOCKET, SO_RCVBUF,
                         (void *)&(int){ 0x80000 }, sizeof (int));
    }
    if( h_Network )
        FreeLibrary( h_Network );
#endif

    if (net_SockAddrIsMulticast (ptr->ai_addr, ptr->ai_addrlen)
   ...",1,1,network\udp.c,net_SetupDgramSocket,,false,93,141,net_SetupDgramSocket,,,2,"int net_SetupDgramSocket (vlc_object_t*,int,addrinfo*)"
153404,METHOD,network\udp.c:<global>,TYPE_DECL,"static int net_ListenSingle (vlc_object_t *obj, const char *host, int port,
                             int protocol)
{
    struct addrinfo hints = {
        .ai_socktype = SOCK_DGRAM,
        .ai_protocol = protocol,
        .ai_flags = AI_PASSIVE | AI_NUMERICSERV | AI_IDN,
    }, *res;

    if (host && !*host)
        host = NULL;

    msg_Dbg (obj, ""net: opening %s datagram port %d"",
             host ? host : ""any"", port);

    int val = vlc_getaddrinfo (host, port, &hints, &res);
    if (val)
    {
        msg_Err (obj, ""Cannot resolve %s port %d : %s"", host, port,
                 gai_strerror (val));
        return -1;
    }

    val = -1;

    for (const struct addrinfo *ptr = res; ptr != NULL; ptr = ptr->ai_next)
    {
        int fd = net_Socket (obj, ptr->ai_family, ptr->ai_socktype,
                             ptr->ai_protocol);
        if (fd == -1)
        {
            msg_Dbg (obj, ""socket error: %s"", vlc_strerror_c(net_errno));
            continue;
        }

#if...",1,1,network\udp.c,net_ListenSingle,,false,144,201,net_ListenSingle,,,3,"int net_ListenSingle (vlc_object_t*,char*,int,int)"
153562,METHOD,network\udp.c:<global>,TYPE_DECL,"static int net_SetMcastHopLimit( vlc_object_t *p_this,
                                 int fd, int family, int hlim )
{
    int proto, cmd;

    /* There is some confusion in the world whether IP_MULTICAST_TTL
     * takes a byte or an int as an argument.
     * BSD seems to indicate byte so we are going with that and use
     * int as a fallback to be safe */
    switch( family )
    {
#ifdef IP_MULTICAST_TTL
        case AF_INET:
            proto = SOL_IP;
            cmd = IP_MULTICAST_TTL;
            break;
#endif

#ifdef IPV6_MULTICAST_HOPS
        case AF_INET6:
            proto = SOL_IPV6;
            cmd = IPV6_MULTICAST_HOPS;
            break;
#endif

        default:
            errno = EAFNOSUPPORT;
            msg_Warn( p_this, ""%s"", vlc_strerror_c(EAFNOSUPPORT) );
            return VLC_EGENERIC;
    }

    if( setsockopt( fd, proto, cmd, &hlim, sizeof( hlim ) ) < 0 )
    {
        /* BSD compatibility */
        unsigned char buf;

        msg_Dbg( p_this, ""cannot...",1,1,network\udp.c,net_SetMcastHopLimit,,false,204,252,net_SetMcastHopLimit,,,4,"int net_SetMcastHopLimit (vlc_object_t*,int,int,int)"
153635,METHOD,network\udp.c:<global>,TYPE_DECL,"static int net_SetMcastOut (vlc_object_t *p_this, int fd, int family,
                            const char *iface)
{
    int scope = if_nametoindex (iface);
    if (scope == 0)
    {
        msg_Err (p_this, ""invalid multicast interface: %s"", iface);
        return -1;
    }

    switch (family)
    {
#ifdef IPV6_MULTICAST_IF
        case AF_INET6:
            if (setsockopt (fd, SOL_IPV6, IPV6_MULTICAST_IF,
                            &scope, sizeof (scope)) == 0)
                return 0;
            break;
#endif

#ifdef __linux__
        case AF_INET:
        {
            struct ip_mreqn req = { .imr_ifindex = scope };
            if (setsockopt (fd, SOL_IP, IP_MULTICAST_IF,
                            &req, sizeof (req)) == 0)
                return 0;
            break;
        }
#endif
        default:
            errno = EAFNOSUPPORT;
    }
    msg_Err (p_this, ""cannot force multicast interface %s: %s"", iface,
             vlc_strerror_c(errno));
    return -1;
}",1,1,network\udp.c,net_SetMcastOut,,false,255,291,net_SetMcastOut,,,5,"int net_SetMcastOut (vlc_object_t*,int,int,char*)"
153676,METHOD,network\udp.c:<global>,TYPE_DECL,"static unsigned var_GetIfIndex (vlc_object_t *obj)
{
    char *ifname = var_InheritString (obj, ""miface"");
    if (ifname == NULL)
        return 0;

    unsigned ifindex = if_nametoindex (ifname);
    if (ifindex == 0)
        msg_Err (obj, ""invalid multicast interface: %s"", ifname);
    free (ifname);
    return ifindex;
}",1,1,network\udp.c,var_GetIfIndex,,false,294,305,var_GetIfIndex,,,6,unsigned var_GetIfIndex (vlc_object_t*)
153712,METHOD,network\udp.c:<global>,TYPE_DECL,"static int
net_SourceSubscribe (vlc_object_t *obj, int fd,
                     const struct sockaddr *src, socklen_t srclen,
                     const struct sockaddr *grp, socklen_t grplen)
{
/* MCAST_JOIN_SOURCE_GROUP was introduced to OS X in v10.7, but it doesn't work,
 * so ignore it to use the same code path as on 10.5 or 10.6 */
#if defined (MCAST_JOIN_SOURCE_GROUP) && !defined (__APPLE__)
    /* Family-agnostic Source-Specific Multicast join */
    int level;
    struct group_source_req gsr;

    memset (&gsr, 0, sizeof (gsr));
    gsr.gsr_interface = var_GetIfIndex (obj);

    switch (grp->sa_family)
    {
#ifdef AF_INET6
        case AF_INET6:
        {
            const struct sockaddr_in6 *g6 = (const struct sockaddr_in6 *)grp;

            level = SOL_IPV6;
            assert (grplen >= sizeof (struct sockaddr_in6));
            if (g6->sin6_scope_id != 0)
                gsr.gsr_interface = g6->sin6_scope_id;
            break;
        }
#endif
        case AF_INET:
...",1,1,network\udp.c,net_SourceSubscribe,,false,312,392,net_SourceSubscribe,,,7,"int net_SourceSubscribe (vlc_object_t*,int,sockaddr*,socklen_t,sockaddr*,socklen_t)"
153760,METHOD,network\udp.c:<global>,TYPE_DECL,"int net_Subscribe (vlc_object_t *obj, int fd,
                   const struct sockaddr *grp, socklen_t grplen)
{
/* MCAST_JOIN_GROUP was introduced to OS X in v10.7, but it doesn't work,
 * so ignore it to use the same code as on 10.5 or 10.6 */
#if defined (MCAST_JOIN_GROUP) && !defined (__APPLE__)
    /* Family-agnostic Any-Source Multicast join */
    int level;
    struct group_req gr;

    memset (&gr, 0, sizeof (gr));
    gr.gr_interface = var_GetIfIndex (obj);

    switch (grp->sa_family)
    {
#ifdef AF_INET6
        case AF_INET6:
        {
            const struct sockaddr_in6 *g6 = (const struct sockaddr_in6 *)grp;

            level = SOL_IPV6;
            assert (grplen >= sizeof (struct sockaddr_in6));
            if (g6->sin6_scope_id != 0)
                gr.gr_interface = g6->sin6_scope_id;
            break;
        }
#endif
        case AF_INET:
            level = SOL_IP;
            break;
        default:
            errno = EAFNOSUPPORT;
            return -1;...",1,1,network\udp.c,net_Subscribe,,false,395,476,net_Subscribe,,,8,"int net_Subscribe (vlc_object_t*,int,sockaddr*,socklen_t)"
153785,METHOD,network\udp.c:<global>,TYPE_DECL,"static int net_SetDSCP( int fd, uint8_t dscp )
{
    struct sockaddr_storage addr;
    if( getsockname( fd, (struct sockaddr *)&addr, &(socklen_t){ sizeof (addr) }) )
        return -1;

    int level, cmd;

    switch( addr.ss_family )
    {
#ifdef IPV6_TCLASS
        case AF_INET6:
            level = SOL_IPV6;
            cmd = IPV6_TCLASS;
            break;
#endif

        case AF_INET:
            level = SOL_IP;
            cmd = IP_TOS;
            break;

        default:
#ifdef ENOPROTOOPT
            errno = ENOPROTOOPT;
#endif
            return -1;
    }

    return setsockopt( fd, level, cmd, &(int){ dscp }, sizeof (int));
}",1,20,network\udp.c,net_SetDSCP,,false,479,509,net_SetDSCP,,,9,"int net_SetDSCP (int,uint8_t)"
153843,METHOD,network\udp.c:<global>,TYPE_DECL,"int net_ConnectDgram( vlc_object_t *p_this, const char *psz_host, int i_port,
                      int i_hlim, int proto )
{
    struct addrinfo hints = {
        .ai_socktype = SOCK_DGRAM,
        .ai_protocol = proto,
        .ai_flags = AI_NUMERICSERV | AI_IDN,
    }, *res;
    int       i_handle = -1;
    bool      b_unreach = false;

    if( i_hlim < 0 )
        i_hlim = var_InheritInteger( p_this, ""ttl"" );

    msg_Dbg( p_this, ""net: connecting to [%s]:%d"", psz_host, i_port );

    int val = vlc_getaddrinfo (psz_host, i_port, &hints, &res);
    if (val)
    {
        msg_Err (p_this, ""cannot resolve [%s]:%d : %s"", psz_host, i_port,
                 gai_strerror (val));
        return -1;
    }

    for (struct addrinfo *ptr = res; ptr != NULL; ptr = ptr->ai_next)
    {
        char *str;
        int fd = net_Socket (p_this, ptr->ai_family, ptr->ai_socktype,
                             ptr->ai_protocol);
        if (fd == -1)
            continue;

        /* Allow broadcast ...",1,1,network\udp.c,net_ConnectDgram,,false,518,595,net_ConnectDgram,,,10,"int net_ConnectDgram (vlc_object_t*,char*,int,int,int)"
154058,METHOD,network\udp.c:<global>,TYPE_DECL,"int net_OpenDgram( vlc_object_t *obj, const char *psz_bind, int i_bind,
                   const char *psz_server, int i_server, int protocol )
{
    if ((psz_server == NULL) || (psz_server[0] == '\0'))
        return net_ListenSingle (obj, psz_bind, i_bind, protocol);

    msg_Dbg (obj, ""net: connecting to [%s]:%d from [%s]:%d"",
             psz_server, i_server, psz_bind, i_bind);

    struct addrinfo hints = {
        .ai_socktype = SOCK_DGRAM,
        .ai_protocol = protocol,
        .ai_flags = AI_NUMERICSERV | AI_IDN,
    }, *loc, *rem;

    int val = vlc_getaddrinfo (psz_server, i_server, &hints, &rem);
    if (val)
    {
        msg_Err (obj, ""cannot resolve %s port %d : %s"", psz_server, i_server,
                 gai_strerror (val));
        return -1;
    }

    hints.ai_flags |= AI_PASSIVE;
    val = vlc_getaddrinfo (psz_bind, i_bind, &hints, &loc);
    if (val)
    {
        msg_Err (obj, ""cannot resolve %s port %d : %s"", psz_bind, i_bind,
                 gai_strerror (...",1,1,network\udp.c,net_OpenDgram,,false,603,678,net_OpenDgram,,,11,"int net_OpenDgram (vlc_object_t*,char*,int,char*,int,int)"
154318,METHOD,network\udp.c:<global>,TYPE_DECL,"int net_SetCSCov (int fd, int sendcov, int recvcov)
{
    int type;

    if (getsockopt (fd, SOL_SOCKET, SO_TYPE,
                    &type, &(socklen_t){ sizeof (type) }))
        return VLC_EGENERIC;

    switch (type)
    {
#ifdef UDPLITE_RECV_CSCOV
        case SOCK_DGRAM: /* UDP-Lite */
            if (sendcov == -1)
                sendcov = 0;
            else
                sendcov += 8; /* partial */
            if (setsockopt (fd, SOL_UDPLITE, UDPLITE_SEND_CSCOV, &sendcov,
                            sizeof (sendcov)))
                return VLC_EGENERIC;

            if (recvcov == -1)
                recvcov = 0;
            else
                recvcov += 8;
            if (setsockopt (fd, SOL_UDPLITE, UDPLITE_RECV_CSCOV,
                            &recvcov, sizeof (recvcov)))
                return VLC_EGENERIC;

            return VLC_SUCCESS;
#endif
#ifdef DCCP_SOCKOPT_SEND_CSCOV
        case SOCK_DCCP: /* DCCP and its ill-named socket type */
            if ((send...",1,1,network\udp.c,net_SetCSCov,,false,688,745,net_SetCSCov,,,12,"int net_SetCSCov (int,int,int)"
154364,METHOD,os2\dirs.c:<global>,TYPE_DECL,<global>,1,1,os2\dirs.c,os2\dirs.c:<global>,,false,1,95,<global>,,,1,
154366,METHOD,os2\dirs.c:<global>,TYPE_DECL,"char *config_GetLibDir (void)
{
    HMODULE hmod;
    CHAR    psz_path[CCHMAXPATH + 4];

    DosQueryModFromEIP( &hmod, NULL, 0, NULL, NULL, ( ULONG )system_Init );
    DosQueryModuleName( hmod, sizeof( psz_path ), psz_path );

    /* remove the DLL name */
    char *slash = strrchr( psz_path, '\\');
    if( slash == NULL )
        abort();
    strcpy(slash + 1, PACKAGE);
    return FromLocaleDup(psz_path);
}",1,1,os2\dirs.c,config_GetLibDir,,false,33,47,config_GetLibDir,,,1,char* config_GetLibDir (void)
154408,METHOD,os2\dirs.c:<global>,TYPE_DECL,"char *config_GetDataDir (void)
{
    const char *path = getenv (""VLC_DATA_PATH"");
    if (path)
        return strdup (path);

    char *datadir = config_GetLibDir();
    if (datadir)
        /* replace last lib\vlc with share */
        strcpy ( datadir + strlen (datadir) - 7, ""share"");
    return datadir;
}",1,1,os2\dirs.c,config_GetDataDir,,false,54,65,config_GetDataDir,,,2,char* config_GetDataDir (void)
154441,METHOD,os2\dirs.c:<global>,TYPE_DECL,"static char *config_GetHomeDir (void)
{
    const char *home = getenv (""HOME"");
    if (home != NULL)
        return FromLocaleDup (home);

    return config_GetLibDir();
}",1,1,os2\dirs.c,config_GetHomeDir,,false,67,74,config_GetHomeDir,,,3,char* config_GetHomeDir (void)
154461,METHOD,os2\dirs.c:<global>,TYPE_DECL,"char *config_GetUserDir (vlc_userdir_t type)
{
    switch (type)
    {
        case VLC_HOME_DIR:
        case VLC_CONFIG_DIR:
        case VLC_DATA_DIR:
        case VLC_CACHE_DIR:
        case VLC_DESKTOP_DIR:
        case VLC_DOWNLOAD_DIR:
        case VLC_TEMPLATES_DIR:
        case VLC_PUBLICSHARE_DIR:
        case VLC_DOCUMENTS_DIR:
        case VLC_MUSIC_DIR:
        case VLC_PICTURES_DIR:
        case VLC_VIDEOS_DIR:
            break;
    }
    return config_GetHomeDir ();
}",1,1,os2\dirs.c,config_GetUserDir,,false,76,95,config_GetUserDir,,,4,char* config_GetUserDir (vlc_userdir_t)
154533,METHOD,os2\filesystem.c:<global>,TYPE_DECL,<global>,1,25,os2\filesystem.c,os2\filesystem.c:<global>,,false,1,350,<global>,,,1,
154535,METHOD,os2\filesystem.c:<global>,TYPE_DECL,"int vlc_open (const char *filename, int flags, ...)
{
    unsigned int mode = 0;
    va_list ap;

    va_start (ap, flags);
    if (flags & O_CREAT)
        mode = va_arg (ap, unsigned int);
    va_end (ap);

    const char *local_name = ToLocaleDup (filename);

    if (local_name == NULL)
    {
        errno = ENOENT;
        return -1;
    }

    int fd = open (local_name, flags, mode);
    if (fd != -1)
        fcntl (fd, F_SETFD, FD_CLOEXEC);

    free (local_name);
    return fd;
}",1,1,os2\filesystem.c,vlc_open,,false,50,74,vlc_open,,,1,"int vlc_open (char*,int...)"
154589,METHOD,os2\filesystem.c:<global>,TYPE_DECL,"int vlc_openat (int dir, const char *filename, int flags, ...)
{
    errno = ENOSYS;

    return -1;
}",1,1,os2\filesystem.c,vlc_openat,,false,76,81,vlc_openat,,,2,"int vlc_openat (int,char*,int...)"
154602,METHOD,os2\filesystem.c:<global>,TYPE_DECL,"int vlc_memfd (void)
{
    errno = ENOSYS;
    return -1;
}",1,1,os2\filesystem.c,vlc_memfd,,false,83,87,vlc_memfd,,,3,int vlc_memfd (void)
154613,METHOD,os2\filesystem.c:<global>,TYPE_DECL,"int vlc_close (int fd)
{
    return close (fd);
}",1,1,os2\filesystem.c,vlc_close,,false,89,92,vlc_close,,,4,int vlc_close (int)
154621,METHOD,os2\filesystem.c:<global>,TYPE_DECL,"int vlc_mkdir (const char *dirname, mode_t mode)
{
    char *locname = ToLocaleDup (dirname);
    if (unlikely(locname == NULL))
    {
        errno = ENOENT;
        return -1;
    }

    int res = mkdir (locname, mode);
    free (locname);
    return res;
}",1,1,os2\filesystem.c,vlc_mkdir,,false,94,106,vlc_mkdir,,,5,"int vlc_mkdir (char*,mode_t)"
154654,METHOD,os2\filesystem.c:<global>,TYPE_DECL,"DIR *vlc_opendir (const char *dirname)
{
    const char *locname = ToLocaleDup (dirname);
    if (unlikely(locname == NULL))
    {
        errno = ENOENT;
        return NULL;
    }

    DIR *dir = opendir (locname);

    free (locname);

    return dir;
}",1,1,os2\filesystem.c,vlc_opendir,,false,108,122,vlc_opendir,,,6,DIR vlc_opendir (char*)
154684,METHOD,os2\filesystem.c:<global>,TYPE_DECL,"const char *vlc_readdir(DIR *dir)
{
    /* Beware that readdir_r() assumes <buf> is large enough to hold the result
     * dirent including the file name. A buffer overflow could occur otherwise.
     * In particular, pathconf() and _POSIX_NAME_MAX cannot be used here. */
    struct dirent *ent;
    char *path = NULL;

    /* In the implementation of Innotek LIBC, aka kLIBC on OS/2,
     * fpathconf (_PC_NAME_MAX) is broken, and errno is set to EBADF.
     * Moreover, d_name is not the last member of struct dirent.
     * So just allocate as many as the size of struct dirent. */
#if 1
    long len = sizeof (struct dirent);
#else
    long len = fpathconf (dirfd (dir), _PC_NAME_MAX);
    len += offsetof (struct dirent, d_name) + 1;
#endif

    struct dirent *buf = malloc (len);
    if (unlikely(buf == NULL))
        return NULL;

    int val = readdir_r (dir, buf, &ent);
    if (val != 0)
        errno = val;
    else if (ent != NULL)
        path = FromCharset ("""", ent->d_name, strle...",1,1,os2\filesystem.c,vlc_readdir,,false,124,154,vlc_readdir,,,7,const char* vlc_readdir (DIR*)
154750,METHOD,os2\filesystem.c:<global>,TYPE_DECL,"static int vlc_statEx (const char *filename, struct stat *buf, bool deref)
{
    const char *local_name = ToLocaleDup (filename);
    if (unlikely(local_name == NULL))
    {
        errno = ENOENT;
        return -1;
    }

    int res = deref ? stat (local_name, buf)
                    : lstat (local_name, buf);
    free (local_name);
    return res;
}",1,1,os2\filesystem.c,vlc_statEx,,false,156,169,vlc_statEx,,,8,"int vlc_statEx (char*,stat*,bool)"
154789,METHOD,os2\filesystem.c:<global>,TYPE_DECL,"int vlc_stat (const char *filename, struct stat *buf)
{
    return vlc_statEx (filename, buf, true);
}",1,1,os2\filesystem.c,vlc_stat,,false,171,174,vlc_stat,,,9,"int vlc_stat (char*,stat*)"
154800,METHOD,os2\filesystem.c:<global>,TYPE_DECL,"int vlc_lstat (const char *filename, struct stat *buf)
{
    return vlc_statEx (filename, buf, false);
}",1,1,os2\filesystem.c,vlc_lstat,,false,176,179,vlc_lstat,,,10,"int vlc_lstat (char*,stat*)"
154811,METHOD,os2\filesystem.c:<global>,TYPE_DECL,"int vlc_unlink (const char *filename)
{
    const char *local_name = ToLocaleDup (filename);
    if (unlikely(local_name == NULL))
    {
        errno = ENOENT;
        return -1;
    }

    int ret = unlink (local_name);
    free (local_name);
    return ret;
}",1,1,os2\filesystem.c,vlc_unlink,,false,181,193,vlc_unlink,,,11,int vlc_unlink (char*)
154842,METHOD,os2\filesystem.c:<global>,TYPE_DECL,"int vlc_rename (const char *oldpath, const char *newpath)
{
    const char *lo = ToLocaleDup (oldpath);
    if (lo == NULL)
        goto error;

    const char *ln = ToLocaleDup (newpath);
    if (ln == NULL)
    {
        free (lo);
error:
        errno = ENOENT;
        return -1;
    }

    int ret = rename (lo, ln);
    free (lo);
    free (ln);
    return ret;
}",1,1,os2\filesystem.c,vlc_rename,,false,195,214,vlc_rename,,,12,"int vlc_rename (char*,char*)"
154890,METHOD,os2\filesystem.c:<global>,TYPE_DECL,"char *vlc_getcwd (void)
{
    /* Try $PWD */
    const char *pwd = getenv (""PWD"");
    if (pwd != NULL)
    {
        struct stat s1, s2;
        /* Make sure $PWD is correct */
        if (stat (pwd, &s1) == 0 && stat (""."", &s2) == 0
         && s1.st_dev == s2.st_dev && s1.st_ino == s2.st_ino)
            return ToLocaleDup (pwd);
    }

    /* Otherwise iterate getcwd() until the buffer is big enough */
    long path_max = pathconf (""."", _PC_PATH_MAX);
    size_t size = (path_max == -1 || path_max > 4096) ? 4096 : path_max;

    for (;; size *= 2)
    {
        char *buf = malloc (size);
        if (unlikely(buf == NULL))
            break;

        if (getcwd (buf, size) != NULL)
        {
            char *ret = ToLocaleDup (buf);
            free (buf);
            return ret; /* success */
        }
        free (buf);

        if (errno != ERANGE)
            break;
    }
    return NULL;
}",1,1,os2\filesystem.c,vlc_getcwd,,false,216,251,vlc_getcwd,,,13,char* vlc_getcwd (void)
155005,METHOD,os2\filesystem.c:<global>,TYPE_DECL,"int vlc_dup (int oldfd)
{
    int newfd;

    newfd = dup (oldfd);
    if (likely(newfd != -1))
        fcntl (newfd, F_SETFD, FD_CLOEXEC);

    return newfd;
}",1,1,os2\filesystem.c,vlc_dup,,false,253,262,vlc_dup,,,14,int vlc_dup (int)
155028,METHOD,os2\filesystem.c:<global>,TYPE_DECL,"int vlc_pipe (int fds[2])
{
    if (vlc_socketpair (AF_LOCAL, SOCK_STREAM, 0, fds, false))
        return -1;

    shutdown (fds[0], SHUT_WR);
    shutdown (fds[1], SHUT_RD);

    setmode (fds[0], O_BINARY);
    setmode (fds[1], O_BINARY);

    return 0;
}",1,1,os2\filesystem.c,vlc_pipe,,false,264,276,vlc_pipe,,,15,int vlc_pipe (int[2])
155066,METHOD,os2\filesystem.c:<global>,TYPE_DECL,"ssize_t vlc_write(int fd, const void *buf, size_t len)
{
    struct iovec iov = { .iov_base = (void *)buf, .iov_len = len };

    return vlc_writev(fd, &iov, 1);
}",1,1,os2\filesystem.c,vlc_write,,false,278,283,vlc_write,,,16,"ssize_t vlc_write (int,void*,size_t)"
155093,METHOD,os2\filesystem.c:<global>,TYPE_DECL,"ssize_t vlc_writev(int fd, const struct iovec *iov, int count)
{
    sigset_t set, oset;

    sigemptyset(&set);
    sigaddset(&set, SIGPIPE);
    pthread_sigmask(SIG_BLOCK, &set, &oset);

    ssize_t val = writev(fd, iov, count);
    if (val < 0 && errno == EPIPE)
    {
        siginfo_t info;
        struct timespec ts = { 0, 0 };

        while (sigtimedwait(&set, &info, &ts) >= 0 || errno != EAGAIN);
    }

    if (!sigismember(&oset, SIGPIPE)) /* Restore the signal mask if changed */
        pthread_sigmask(SIG_SETMASK, &oset, NULL);

    return val;
}",1,1,os2\filesystem.c,vlc_writev,,false,285,306,vlc_writev,,,17,"ssize_t vlc_writev (int,iovec*,int)"
155166,METHOD,os2\filesystem.c:<global>,TYPE_DECL,"static void vlc_socket_setup(int fd, bool nonblock)
{
    fcntl(fd, F_SETFD, FD_CLOEXEC);

    if (nonblock)
        fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) | O_NONBLOCK);
}",1,1,os2\filesystem.c,vlc_socket_setup,,false,308,314,vlc_socket_setup,,,18,"void vlc_socket_setup (int,bool)"
155188,METHOD,os2\filesystem.c:<global>,TYPE_DECL,"int vlc_socket (int pf, int type, int proto, bool nonblock)
{
    int fd = socket(pf, type, proto);
    if (fd != -1)
        vlc_socket_setup(fd, nonblock);
    return fd;
}",1,1,os2\filesystem.c,vlc_socket,,false,316,322,vlc_socket,,,19,"int vlc_socket (int,int,int,bool)"
155214,METHOD,os2\filesystem.c:<global>,TYPE_DECL,"int vlc_socketpair(int pf, int type, int proto, int fds[2], bool nonblock)
{
    if (socketpair(pf, type, proto, fds))
        return -1;

    vlc_socket_setup(fds[0], nonblock);
    vlc_socket_setup(fds[1], nonblock);
    return 0;
}",1,1,os2\filesystem.c,vlc_socketpair,,false,324,332,vlc_socketpair,,,20,"int vlc_socketpair (int,int,int,int[2],bool)"
155245,METHOD,os2\filesystem.c:<global>,TYPE_DECL,"int vlc_accept (int lfd, struct sockaddr *addr, socklen_t *alen, bool nonblock)
{
    do
    {
        int fd = accept (lfd, addr, alen);
        if (fd != -1)
        {
            fcntl (fd, F_SETFD, FD_CLOEXEC);
            if (nonblock)
                fcntl (fd, F_SETFL, fcntl (fd, F_GETFL, 0) | O_NONBLOCK);
            return fd;
        }
    }
    while (errno == EINTR);

    return -1;
}",1,1,os2\filesystem.c,vlc_accept,,false,334,350,vlc_accept,,,21,"int vlc_accept (int,sockaddr*,socklen_t*,bool)"
155303,METHOD,os2\getaddrinfo.c:<global>,TYPE_DECL,<global>,1,23,os2\getaddrinfo.c,os2\getaddrinfo.c:<global>,,false,1,305,<global>,,,1,
155305,METHOD,os2\getaddrinfo.c:<global>,TYPE_DECL,"int
getnameinfo (const struct sockaddr *sa, socklen_t salen,
                 char *host, int hostlen, char *serv, int servlen, int flags)
{
    if (((size_t)salen < sizeof (struct sockaddr_in))
     || (sa->sa_family != AF_INET))
        return EAI_FAMILY;
    else if (flags & (~_NI_MASK))
        return EAI_BADFLAGS;
    else
    {
        const struct sockaddr_in *addr;

        addr = (const struct sockaddr_in *)sa;

        if (host != NULL)
        {
            /* host name resolution */
            if (!(flags & NI_NUMERICHOST))
            {
                if (flags & NI_NAMEREQD)
                    return EAI_NONAME;
            }

            /* inet_ntoa() is not thread-safe, do not use it */
            uint32_t ipv4 = ntohl (addr->sin_addr.s_addr);

            if (snprintf (host, hostlen, ""%u.%u.%u.%u"", ipv4 >> 24,
                          (ipv4 >> 16) & 0xff, (ipv4 >> 8) & 0xff,
                          ipv4 & 0xff) >= (int)hostlen)
                return EAI_OVE...",1,23,os2\getaddrinfo.c,getnameinfo,,false,46,87,getnameinfo,,,1,"int getnameinfo (sockaddr*,socklen_t,char*,int,char*,int,int)"
155440,METHOD,os2\getaddrinfo.c:<global>,TYPE_DECL,"static int
gai_error_from_herrno (void)
{
    switch (h_errno)
    {
        case HOST_NOT_FOUND:
            return EAI_NONAME;

        case NO_ADDRESS:
# if (NO_ADDRESS != NO_DATA)
        case NO_DATA:
# endif
            return EAI_NODATA;

        case NO_RECOVERY:
            return EAI_FAIL;

        case TRY_AGAIN:
            return EAI_AGAIN;
    }
    return EAI_SYSTEM;
}",1,1,os2\getaddrinfo.c,gai_error_from_herrno,,false,94,115,gai_error_from_herrno,,,2,int gai_error_from_herrno (void)
155466,METHOD,os2\getaddrinfo.c:<global>,TYPE_DECL,"static struct addrinfo *
makeaddrinfo (int af, int type, int proto,
              const struct sockaddr *addr, size_t addrlen,
              const char *canonname)
{
    struct addrinfo *res;

    res = (struct addrinfo *)malloc (sizeof (struct addrinfo));
    if (res != NULL)
    {
        res->ai_flags = 0;
        res->ai_family = af;
        res->ai_socktype = type;
        res->ai_protocol = proto;
        res->ai_addrlen = addrlen;
        res->ai_addr = malloc (addrlen);
        res->ai_canonname = NULL;
        res->ai_next = NULL;

        if (res->ai_addr != NULL)
        {
            memcpy (res->ai_addr, addr, addrlen);

            if (canonname != NULL)
            {
                res->ai_canonname = strdup (canonname);
                if (res->ai_canonname != NULL)
                    return res; /* success ! */
            }
            else
                return res;
        }
    }
    /* failsafe */
    freeaddrinfo (res);
    return NULL;
}",1,1,os2\getaddrinfo.c,makeaddrinfo,,false,120,156,makeaddrinfo,,,3,"struct addrinfo makeaddrinfo (int,int,int,sockaddr*,size_t,char*)"
155571,METHOD,os2\getaddrinfo.c:<global>,TYPE_DECL,"static struct addrinfo *
makeipv4info (int type, int proto, u_long ip, u_short port, const char *name)
{
    struct sockaddr_in addr;

    memset (&addr, 0, sizeof (addr));
    addr.sin_family = AF_INET;
# ifdef HAVE_SA_LEN
    addr.sin_len = sizeof (addr);
# endif
    addr.sin_port = port;
    addr.sin_addr.s_addr = ip;

    return makeaddrinfo (AF_INET, type, proto,
                         (struct sockaddr*)&addr, sizeof (addr), name);
}",1,1,os2\getaddrinfo.c,makeipv4info,,false,158,173,makeipv4info,,,4,"struct addrinfo makeipv4info (int,int,u_long,u_short,char*)"
155616,METHOD,os2\getaddrinfo.c:<global>,TYPE_DECL,"int
getaddrinfo (const char *node, const char *service,
             const struct addrinfo *hints, struct addrinfo **res)
{
    struct addrinfo *info;
    u_long ip;
    u_short port;
    int protocol = 0, flags = 0;
    const char *name = NULL;

    if (hints != NULL)
    {
        flags = hints->ai_flags;

        if (flags & ~_AI_MASK)
            return EAI_BADFLAGS;
        /* only accept AF_INET and AF_UNSPEC */
        if (hints->ai_family && (hints->ai_family != AF_INET))
            return EAI_FAMILY;

        /* protocol sanity check */
        switch (hints->ai_socktype)
        {
            case SOCK_STREAM:
                protocol = IPPROTO_TCP;
                break;

            case SOCK_DGRAM:
                protocol = IPPROTO_UDP;
                break;

#ifdef SOCK_RAW
            case SOCK_RAW:
#endif
            case 0:
                break;

            default:
                return EAI_SOCKTYPE;
        }
        if (hints->ai_protocol && protocol
      ...",1,21,os2\getaddrinfo.c,getaddrinfo,,false,184,305,getaddrinfo,,,5,"int getaddrinfo (char*,char*,addrinfo*,addrinfo**)"
155947,METHOD,os2\netconf.c:<global>,TYPE_DECL,<global>,1,1,os2\netconf.c,os2\netconf.c:<global>,,false,1,38,<global>,,,1,
155949,METHOD,os2\netconf.c:<global>,TYPE_DECL,"char *vlc_getProxyUrl(const char *url)
{
    VLC_UNUSED(url);

    return NULL;
}",1,1,os2\netconf.c,vlc_getProxyUrl,,false,33,38,vlc_getProxyUrl,,,1,char* vlc_getProxyUrl (char*)
155975,METHOD,os2\plugin.c:<global>,TYPE_DECL,<global>,1,25,os2\plugin.c,os2\plugin.c:<global>,,false,1,99,<global>,,,1,
155977,METHOD,os2\plugin.c:<global>,TYPE_DECL,"int module_Load( vlc_object_t *p_this, const char *psz_file,
                 module_handle_t *p_handle, bool lazy )
{
    const int flags = lazy ? RTLD_LAZY : RTLD_NOW;
    char *path = ToLocaleDup( psz_file );

    module_handle_t handle = dlopen( path, flags );
    if( handle == NULL )
    {
        msg_Warn( p_this, ""cannot load module `%s' (%s)"", path, dlerror() );
        free( path );
        return -1;
    }
    free( path );
    *p_handle = handle;
    return 0;
}",1,1,os2\plugin.c,module_Load,,false,50,66,module_Load,,,1,"int module_Load (vlc_object_t*,char*,module_handle_t*,bool)"
156026,METHOD,os2\plugin.c:<global>,TYPE_DECL,"void module_Unload( module_handle_t handle )
{
    dlclose( handle );
}",1,1,os2\plugin.c,module_Unload,,false,77,80,module_Unload,,,2,void module_Unload (module_handle_t)
156033,METHOD,os2\plugin.c:<global>,TYPE_DECL,"void *module_Lookup( module_handle_t handle, const char *psz_function )
{
    char buf[strlen(psz_function) + 2];
    buf[0] = '_';
    strcpy(buf + 1, psz_function);
    return dlsym( handle, buf );
}",1,1,os2\plugin.c,module_Lookup,,false,93,99,module_Lookup,,,3,"void* module_Lookup (module_handle_t,char*)"
156063,METHOD,os2\rand.c:<global>,TYPE_DECL,<global>,1,1,os2\rand.c,os2\rand.c:<global>,,false,1,40,<global>,,,1,
156065,METHOD,os2\rand.c:<global>,TYPE_DECL,"void vlc_rand_bytes (void *buf, size_t len)
{
    QWORD qwTime;
    uint8_t *p_buf = (uint8_t *)buf;

    while (len > 0)
    {
        DosTmrQueryTime( &qwTime );

        *p_buf++ = ( uint8_t )( qwTime.ulLo * rand());
        len--;
    }
}",1,1,os2\rand.c,vlc_rand_bytes,,false,28,40,vlc_rand_bytes,,,1,"void vlc_rand_bytes (void*,size_t)"
156119,METHOD,os2\specific.c:<global>,TYPE_DECL,<global>,1,24,os2\specific.c,os2\specific.c:<global>,,false,1,287,<global>,,,1,
156136,METHOD,os2\specific.c:<global>,TYPE_DECL,"static void IPCHelperThread( void *arg )
{
    libvlc_int_t *libvlc = arg;

    ULONG  ulCmd;
    int    i_argc;
    char **ppsz_argv;
    size_t i_len;
    ULONG  cbActual;
    int    i_options;

    /* Add files to the playlist */
    playlist_t *p_playlist;

    do
    {
        DosConnectNPipe( hpipeIPC );

        /* Read command */
        DosRead( hpipeIPC, &ulCmd, sizeof( ulCmd ), &cbActual );
        if( ulCmd == IPC_CMD_QUIT )
            continue;

        /* Read a count of arguments */
        DosRead( hpipeIPC, &i_argc, sizeof( i_argc ), &cbActual );

        ppsz_argv = vlc_alloc( i_argc, sizeof( *ppsz_argv ));

        for( int i_opt = 0; i_opt < i_argc; i_opt++ )
        {
            /* Read a length of argv */
            DosRead( hpipeIPC, &i_len, sizeof( i_len ), &cbActual );

            ppsz_argv[ i_opt ] = malloc( i_len );

            /* Read argv */
            DosRead( hpipeIPC, ppsz_argv[ i_opt ], i_len, &cbActual );
        }

        p_playlist = libvlc...",1,21,os2\specific.c,IPCHelperThread,,false,47,122,IPCHelperThread,,,8,void IPCHelperThread (void*)
156327,METHOD,os2\specific.c:<global>,TYPE_DECL,"void system_Init( void )
{
    /* Set the default file-translation mode */
    _fmode_bin = 1;
    setmode( fileno( stdin ), O_BINARY ); /* Needed for pipes */
}",1,1,os2\specific.c,system_Init,,false,124,129,system_Init,,,9,void system_Init (void)
156339,METHOD,os2\specific.c:<global>,TYPE_DECL,"void system_Configure( libvlc_int_t *p_this, int i_argc, const char *const ppsz_argv[] )
{
    if( var_InheritBool( p_this, ""high-priority"" ) )
    {
        if( !DosSetPriority( PRTYS_PROCESS, PRTYC_REGULAR, PRTYD_MAXIMUM, 0 ) )
        {
            msg_Dbg( p_this, ""raised process priority"" );
        }
        else
        {
            msg_Dbg( p_this, ""could not raise process priority"" );
        }
    }

    if( var_InheritBool( p_this, ""one-instance"" )
        || ( var_InheritBool( p_this, ""one-instance-when-started-from-file"" )
             && var_InheritBool( p_this, ""started-from-file"" ) ) )
    {
        HPIPE hpipe;
        ULONG ulAction;
        ULONG rc;

        msg_Info( p_this, ""one instance mode ENABLED"");

        /* Use a named pipe to check if another instance is already running */
        for(;;)
        {
            rc = DosOpen( VLC_IPC_PIPE, &hpipe, &ulAction, 0, 0,
                          OPEN_ACTION_OPEN_IF_EXISTS,
                          OPEN_ACCES...",1,26,os2\specific.c,system_Configure,,false,131,250,system_Configure,,,10,"void system_Configure (libvlc_int_t*,int,char[]*)"
156541,METHOD,os2\specific.c:<global>,TYPE_DECL,"void system_End(void)
{
    if( tidIPCFirst == _gettid())
    {
        HPIPE hpipe;
        ULONG ulAction;
        ULONG cbActual;
        ULONG rc;

        do
        {
            rc = DosOpen( VLC_IPC_PIPE, &hpipe, &ulAction, 0, 0,
                          OPEN_ACTION_OPEN_IF_EXISTS,
                          OPEN_ACCESS_READWRITE | OPEN_SHARE_DENYREADWRITE |
                          OPEN_FLAGS_FAIL_ON_ERROR,
                          NULL );

            if( rc == ERROR_PIPE_BUSY )
                DosWaitNPipe( VLC_IPC_PIPE, -1 );
            else if( rc )
                DosSleep( 1 );
        } while( rc );

        /* Ask for IPCHelper to quit */
        ULONG ulCmd = IPC_CMD_QUIT;
        DosWrite( hpipe, &ulCmd, sizeof( ulCmd ), &cbActual );

        DosClose( hpipe );

        TID tid = tidIPCHelper;
        DosWaitThread( &tid, DCWW_WAIT );
    }
}",1,26,os2\specific.c,system_End,,false,255,287,system_End,,,11,void system_End (void)
156616,METHOD,os2\thread.c:<global>,TYPE_DECL,<global>,1,1,os2\thread.c,os2\thread.c:<global>,,false,1,1013,<global>,,,1,
156628,METHOD,vlc_thread,TYPE_DECL,void        *(*entry) (void *);,17,34,os2\thread.c,vlc_thread.entry,,false,66,66,entry,,,9,void* vlc_thread.entry (void*)
156634,METHOD,os2\thread.c:<global>,TYPE_DECL,static void vlc_cancel_self (PVOID dummy);,13,41,os2\thread.c,vlc_cancel_self,,false,70,70,vlc_cancel_self,,,3,void vlc_cancel_self (PVOID)
156639,METHOD,os2\thread.c:<global>,TYPE_DECL,"static ULONG vlc_DosWaitEventSemEx( HEV hev, ULONG ulTimeout )
{
    HMUX      hmux;
    SEMRECORD asr[ 2 ];
    ULONG     ulUser;
    int       n;
    ULONG     rc;

    struct vlc_thread *th = vlc_thread_self ();
    if( th == NULL || !th->killable )
    {
        /* Main thread - cannot be cancelled anyway
         * Alien thread - out of our control
         * Cancel disabled thread - ignore cancel
         */
        if( hev != NULLHANDLE )
            return DosWaitEventSem( hev, ulTimeout );

        return DosSleep( ulTimeout );
    }

    n = 0;
    if( hev != NULLHANDLE )
    {
        asr[ n ].hsemCur = ( HSEM )hev;
        asr[ n ].ulUser  = 0;
        n++;
    }
    asr[ n ].hsemCur = ( HSEM )th->cancel_event;
    asr[ n ].ulUser  = 0xFFFF;
    n++;

    DosCreateMuxWaitSem( NULL, &hmux, n, asr, DCMW_WAIT_ANY );
    rc = DosWaitMuxWaitSem( hmux, ulTimeout, &ulUser );
    DosCloseMuxWaitSem( hmux );
    if( rc )
        return rc;

    if( ulUser == 0xFFFF )
    {
      ...",1,1,os2\thread.c,vlc_DosWaitEventSemEx,,false,72,117,vlc_DosWaitEventSemEx,,,4,"ULONG vlc_DosWaitEventSemEx (HEV,ULONG)"
156754,METHOD,os2\thread.c:<global>,TYPE_DECL,"static ULONG vlc_WaitForSingleObject (HEV hev, ULONG ulTimeout)
{
    return vlc_DosWaitEventSemEx( hev, ulTimeout );
}",1,1,os2\thread.c,vlc_WaitForSingleObject,,false,119,122,vlc_WaitForSingleObject,,,5,"ULONG vlc_WaitForSingleObject (HEV,ULONG)"
156764,METHOD,os2\thread.c:<global>,TYPE_DECL,"static ULONG vlc_Sleep (ULONG ulTimeout)
{
    ULONG rc = vlc_DosWaitEventSemEx( NULLHANDLE, ulTimeout );

    return ( rc != ERROR_TIMEOUT ) ? rc : 0;
}",1,1,os2\thread.c,vlc_Sleep,,false,124,129,vlc_Sleep,,,6,ULONG vlc_Sleep (ULONG)
156785,METHOD,os2\thread.c:<global>,TYPE_DECL,static void vlc_static_cond_destroy_all(void);,13,45,os2\thread.c,vlc_static_cond_destroy_all,,false,135,135,vlc_static_cond_destroy_all,,,10,void vlc_static_cond_destroy_all (void)
156790,METHOD,os2\thread.c:<global>,TYPE_DECL,int _CRT_init(void);,5,19,os2\thread.c,_CRT_init,,false,137,137,_CRT_init,,,11,int _CRT_init (void)
156795,METHOD,os2\thread.c:<global>,TYPE_DECL,void _CRT_term(void);,6,20,os2\thread.c,_CRT_term,,false,138,138,_CRT_term,,,12,void _CRT_term (void)
156802,METHOD,os2\thread.c:<global>,TYPE_DECL,"void vlc_mutex_init( vlc_mutex_t *p_mutex )
{
    /* This creates a recursive mutex. This is OK as fast mutexes have
     * no defined behavior in case of recursive locking. */
    DosCreateMutexSem( NULL, &p_mutex->hmtx, 0, FALSE );
    p_mutex->dynamic = true;
}",1,1,os2\thread.c,vlc_mutex_init,,false,176,182,vlc_mutex_init,,,15,void vlc_mutex_init (vlc_mutex_t*)
156820,METHOD,os2\thread.c:<global>,TYPE_DECL,"void vlc_mutex_init_recursive( vlc_mutex_t *p_mutex )
{
    DosCreateMutexSem( NULL, &p_mutex->hmtx, 0, FALSE );
    p_mutex->dynamic = true;
}",1,1,os2\thread.c,vlc_mutex_init_recursive,,false,184,188,vlc_mutex_init_recursive,,,16,void vlc_mutex_init_recursive (vlc_mutex_t*)
156838,METHOD,os2\thread.c:<global>,TYPE_DECL,"void vlc_mutex_destroy (vlc_mutex_t *p_mutex)
{
    assert (p_mutex->dynamic);
    DosCloseMutexSem( p_mutex->hmtx );
}",1,1,os2\thread.c,vlc_mutex_destroy,,false,191,195,vlc_mutex_destroy,,,17,void vlc_mutex_destroy (vlc_mutex_t*)
156851,METHOD,os2\thread.c:<global>,TYPE_DECL,"void vlc_mutex_lock (vlc_mutex_t *p_mutex)
{
    if (!p_mutex->dynamic)
    {   /* static mutexes */
        int canc = vlc_savecancel ();
        assert (p_mutex != &super_mutex); /* this one cannot be static */

        vlc_mutex_lock (&super_mutex);
        while (p_mutex->locked)
        {
            p_mutex->contention++;
            vlc_cond_wait (&super_variable, &super_mutex);
            p_mutex->contention--;
        }
        p_mutex->locked = true;
        vlc_mutex_unlock (&super_mutex);
        vlc_restorecancel (canc);
        return;
    }

    DosRequestMutexSem(p_mutex->hmtx, SEM_INDEFINITE_WAIT);
}",1,1,os2\thread.c,vlc_mutex_lock,,false,197,218,vlc_mutex_lock,,,18,void vlc_mutex_lock (vlc_mutex_t*)
156908,METHOD,os2\thread.c:<global>,TYPE_DECL,"int vlc_mutex_trylock (vlc_mutex_t *p_mutex)
{
    if (!p_mutex->dynamic)
    {   /* static mutexes */
        int ret = EBUSY;

        assert (p_mutex != &super_mutex); /* this one cannot be static */
        vlc_mutex_lock (&super_mutex);
        if (!p_mutex->locked)
        {
            p_mutex->locked = true;
            ret = 0;
        }
        vlc_mutex_unlock (&super_mutex);
        return ret;
    }

    return DosRequestMutexSem( p_mutex->hmtx, 0 ) ? EBUSY : 0;
}",1,1,os2\thread.c,vlc_mutex_trylock,,false,220,238,vlc_mutex_trylock,,,19,int vlc_mutex_trylock (vlc_mutex_t*)
156959,METHOD,os2\thread.c:<global>,TYPE_DECL,"void vlc_mutex_unlock (vlc_mutex_t *p_mutex)
{
    if (!p_mutex->dynamic)
    {   /* static mutexes */
        assert (p_mutex != &super_mutex); /* this one cannot be static */

        vlc_mutex_lock (&super_mutex);
        assert (p_mutex->locked);
        p_mutex->locked = false;
        if (p_mutex->contention)
            vlc_cond_broadcast (&super_variable);
        vlc_mutex_unlock (&super_mutex);
        return;
    }

    DosReleaseMutexSem( p_mutex->hmtx );
}",1,1,os2\thread.c,vlc_mutex_unlock,,false,240,256,vlc_mutex_unlock,,,20,void vlc_mutex_unlock (vlc_mutex_t*)
157012,METHOD,os2\thread.c:<global>,TYPE_DECL,"static void vlc_static_cond_init (vlc_cond_t *p_condvar)
{
    vlc_mutex_lock (&super_mutex);

    if (p_condvar->hev == NULLHANDLE)
    {
        vlc_cond_init (p_condvar);

        vlc_static_cond_t *new_static_condvar;

        new_static_condvar = malloc (sizeof (*new_static_condvar));
        if (unlikely (!new_static_condvar))
            abort();

        memcpy (&new_static_condvar->condvar, p_condvar, sizeof (*p_condvar));
        new_static_condvar->next = static_condvar_start;
        static_condvar_start = new_static_condvar;
    }

    vlc_mutex_unlock (&super_mutex);
}",1,1,os2\thread.c,vlc_static_cond_init,,false,269,289,vlc_static_cond_init,,,26,void vlc_static_cond_init (vlc_cond_t*)
157062,METHOD,os2\thread.c:<global>,TYPE_DECL,"static void vlc_static_cond_destroy_all (void)
{
    vlc_static_cond_t *static_condvar;
    vlc_static_cond_t *static_condvar_next;


    for (static_condvar = static_condvar_start; static_condvar;
         static_condvar = static_condvar_next)
    {
        static_condvar_next = static_condvar->next;

        vlc_cond_destroy (&static_condvar->condvar);
        free (static_condvar);
    }
}",1,1,os2\thread.c,vlc_static_cond_destroy_all,,false,291,305,vlc_static_cond_destroy_all,,,27,void vlc_static_cond_destroy_all (void)
157091,METHOD,os2\thread.c:<global>,TYPE_DECL,"void vlc_cond_init (vlc_cond_t *p_condvar)
{
    if (DosCreateEventSem (NULL, &p_condvar->hev, 0, FALSE) ||
        DosCreateEventSem (NULL, &p_condvar->hevAck, 0, FALSE))
        abort();

    p_condvar->waiters = 0;
    p_condvar->signaled = 0;
}",1,1,os2\thread.c,vlc_cond_init,,false,307,315,vlc_cond_init,,,28,void vlc_cond_init (vlc_cond_t*)
157126,METHOD,os2\thread.c:<global>,TYPE_DECL,"void vlc_cond_init_daytime (vlc_cond_t *p_condvar)
{
    vlc_cond_init (p_condvar);
}",1,1,os2\thread.c,vlc_cond_init_daytime,,false,317,320,vlc_cond_init_daytime,,,29,void vlc_cond_init_daytime (vlc_cond_t*)
157133,METHOD,os2\thread.c:<global>,TYPE_DECL,"void vlc_cond_destroy (vlc_cond_t *p_condvar)
{
    DosCloseEventSem( p_condvar->hev );
    DosCloseEventSem( p_condvar->hevAck );
}",1,1,os2\thread.c,vlc_cond_destroy,,false,322,326,vlc_cond_destroy,,,30,void vlc_cond_destroy (vlc_cond_t*)
157146,METHOD,os2\thread.c:<global>,TYPE_DECL,"void vlc_cond_signal (vlc_cond_t *p_condvar)
{
    if (p_condvar->hev == NULLHANDLE)
        vlc_static_cond_init (p_condvar);

    if (!__atomic_cmpxchg32 (&p_condvar->waiters, 0, 0))
    {
        ULONG ulPost;

        __atomic_xchg (&p_condvar->signaled, 1);
        DosPostEventSem (p_condvar->hev);

        DosWaitEventSem (p_condvar->hevAck, SEM_INDEFINITE_WAIT);
        DosResetEventSem (p_condvar->hevAck, &ulPost);
    }
}",1,1,os2\thread.c,vlc_cond_signal,,false,328,343,vlc_cond_signal,,,31,void vlc_cond_signal (vlc_cond_t*)
157192,METHOD,os2\thread.c:<global>,TYPE_DECL,"void vlc_cond_broadcast (vlc_cond_t *p_condvar)
{
    if (p_condvar->hev == NULLHANDLE)
        vlc_static_cond_init (p_condvar);

    while (!__atomic_cmpxchg32 (&p_condvar->waiters, 0, 0))
        vlc_cond_signal (p_condvar);
}",1,1,os2\thread.c,vlc_cond_broadcast,,false,345,352,vlc_cond_broadcast,,,32,void vlc_cond_broadcast (vlc_cond_t*)
157217,METHOD,os2\thread.c:<global>,TYPE_DECL,"static int vlc_cond_wait_common (vlc_cond_t *p_condvar, vlc_mutex_t *p_mutex,
                                 ULONG ulTimeout)
{
    ULONG ulPost;
    ULONG rc;

    assert(p_condvar->hev != NULLHANDLE);

    do
    {
        vlc_testcancel();

        __atomic_increment (&p_condvar->waiters);

        vlc_mutex_unlock (p_mutex);

        do
        {
            rc = vlc_WaitForSingleObject( p_condvar->hev, ulTimeout );
            if (rc == NO_ERROR)
                DosResetEventSem (p_condvar->hev, &ulPost);
        } while (rc == NO_ERROR &&
                 __atomic_cmpxchg32 (&p_condvar->signaled, 0, 1) == 0);

        __atomic_decrement (&p_condvar->waiters);

        DosPostEventSem (p_condvar->hevAck);

        vlc_mutex_lock (p_mutex);
    } while( rc == ERROR_INTERRUPT );

    return rc ? ETIMEDOUT : 0;
}",1,1,os2\thread.c,vlc_cond_wait_common,,false,354,386,vlc_cond_wait_common,,,33,"int vlc_cond_wait_common (vlc_cond_t*,vlc_mutex_t*,ULONG)"
157294,METHOD,os2\thread.c:<global>,TYPE_DECL,"void vlc_cond_wait (vlc_cond_t *p_condvar, vlc_mutex_t *p_mutex)
{
    if (p_condvar->hev == NULLHANDLE)
        vlc_static_cond_init (p_condvar);

    vlc_cond_wait_common (p_condvar, p_mutex, SEM_INDEFINITE_WAIT);
}",1,1,os2\thread.c,vlc_cond_wait,,false,388,394,vlc_cond_wait,,,34,"void vlc_cond_wait (vlc_cond_t*,vlc_mutex_t*)"
157313,METHOD,os2\thread.c:<global>,TYPE_DECL,"int vlc_cond_timedwait (vlc_cond_t *p_condvar, vlc_mutex_t *p_mutex,
                        mtime_t deadline)
{
    ULONG ulTimeout;

    mtime_t total = mdate();
    total = (deadline - total) / 1000;
    if( total < 0 )
        total = 0;

    ulTimeout = ( total > 0x7fffffff ) ? 0x7fffffff : total;

    return vlc_cond_wait_common (p_condvar, p_mutex, ulTimeout);
}",1,1,os2\thread.c,vlc_cond_timedwait,,false,396,409,vlc_cond_timedwait,,,35,"int vlc_cond_timedwait (vlc_cond_t*,vlc_mutex_t*,mtime_t)"
157353,METHOD,os2\thread.c:<global>,TYPE_DECL,"int vlc_cond_timedwait_daytime (vlc_cond_t *p_condvar, vlc_mutex_t *p_mutex,
                                time_t deadline)
{
    ULONG ulTimeout;
    mtime_t total;
    struct timeval tv;

    gettimeofday (&tv, NULL);

    total = CLOCK_FREQ * tv.tv_sec +
            CLOCK_FREQ * tv.tv_usec / 1000000L;
    total = (deadline - total) / 1000;
    if( total < 0 )
        total = 0;

    ulTimeout = ( total > 0x7fffffff ) ? 0x7fffffff : total;

    return vlc_cond_wait_common (p_condvar, p_mutex, ulTimeout);
}",1,1,os2\thread.c,vlc_cond_timedwait_daytime,,false,411,429,vlc_cond_timedwait_daytime,,,36,"int vlc_cond_timedwait_daytime (vlc_cond_t*,vlc_mutex_t*,time_t)"
157412,METHOD,vlc_threadvar,TYPE_DECL,void                (*destroy) (void *);,25,43,os2\thread.c,vlc_threadvar.destroy,,false,435,435,destroy,,,2,void vlc_threadvar.destroy (void*)
157425,METHOD,os2\thread.c:<global>,TYPE_DECL,"int vlc_threadvar_create (vlc_threadvar_t *p_tls, void (*destr) (void *))
{
    ULONG rc;

    struct vlc_threadvar *var = malloc (sizeof (*var));
    if (unlikely(var == NULL))
        return errno;

    rc = DosAllocThreadLocalMemory( 1, &var->id );
    if( rc )
    {
        free (var);
        return EAGAIN;
    }

    var->destroy = destr;
    var->next = NULL;
    *p_tls = var;

    vlc_mutex_lock (&super_mutex);
    var->prev = vlc_threadvar_last;
    if (var->prev)
        var->prev->next = var;

    vlc_threadvar_last = var;
    vlc_mutex_unlock (&super_mutex);
    return 0;
}",1,1,os2\thread.c,vlc_threadvar_create,,false,440,467,vlc_threadvar_create,,,40,"int vlc_threadvar_create (vlc_threadvar_t*,void)"
157504,METHOD,os2\thread.c:<global>,TYPE_DECL,"void vlc_threadvar_delete (vlc_threadvar_t *p_tls)
{
    struct vlc_threadvar *var = *p_tls;

    vlc_mutex_lock (&super_mutex);
    if (var->prev != NULL)
        var->prev->next = var->next;

    if (var->next != NULL)
        var->next->prev = var->prev;
    else
        vlc_threadvar_last = var->prev;

    vlc_mutex_unlock (&super_mutex);

    DosFreeThreadLocalMemory( var->id );
    free (var);
}",1,1,os2\thread.c,vlc_threadvar_delete,,false,469,486,vlc_threadvar_delete,,,41,void vlc_threadvar_delete (vlc_threadvar_t*)
157565,METHOD,os2\thread.c:<global>,TYPE_DECL,"int vlc_threadvar_set (vlc_threadvar_t key, void *value)
{
    *key->id = ( ULONG )value;
    return 0;
}",1,1,os2\thread.c,vlc_threadvar_set,,false,488,492,vlc_threadvar_set,,,42,"int vlc_threadvar_set (vlc_threadvar_t,void*)"
157581,METHOD,os2\thread.c:<global>,TYPE_DECL,"void *vlc_threadvar_get (vlc_threadvar_t key)
{
    return ( void * )*key->id;
}",1,1,os2\thread.c,vlc_threadvar_get,,false,494,497,vlc_threadvar_get,,,43,void* vlc_threadvar_get (vlc_threadvar_t)
157593,METHOD,os2\thread.c:<global>,TYPE_DECL,"void vlc_threads_setup (libvlc_int_t *p_libvlc)
{
    (void) p_libvlc;
}",1,1,os2\thread.c,vlc_threads_setup,,false,501,504,vlc_threads_setup,,,44,void vlc_threads_setup (libvlc_int_t*)
157601,METHOD,os2\thread.c:<global>,TYPE_DECL,"static void vlc_thread_cleanup (struct vlc_thread *th)
{
    vlc_threadvar_t key;

retry:
    /* TODO: use RW lock or something similar */
    vlc_mutex_lock (&super_mutex);
    for (key = vlc_threadvar_last; key != NULL; key = key->prev)
    {
        void *value = vlc_threadvar_get (key);
        if (value != NULL && key->destroy != NULL)
        {
            vlc_mutex_unlock (&super_mutex);
            vlc_threadvar_set (key, NULL);
            key->destroy (value);
            goto retry;
        }
    }
    vlc_mutex_unlock (&super_mutex);

    if (th->detached)
    {
        DosCloseEventSem (th->cancel_event);
        DosCloseEventSem (th->done_event );

        soclose (th->cancel_sock);

        free (th);
    }
}",1,1,os2\thread.c,vlc_thread_cleanup,,false,506,535,vlc_thread_cleanup,,,45,void vlc_thread_cleanup (vlc_thread*)
157675,METHOD,os2\thread.c:<global>,TYPE_DECL,"static void vlc_entry( void *p )
{
    struct vlc_thread *th = p;

    vlc_threadvar_set (thread_key, th);
    th->killable = true;
    th->data = th->entry (th->data);
    DosPostEventSem( th->done_event );
    vlc_thread_cleanup (th);
}",1,1,os2\thread.c,vlc_entry,,false,537,546,vlc_entry,,,46,void vlc_entry (void*)
157709,METHOD,os2\thread.c:<global>,TYPE_DECL,"static int vlc_clone_attr (vlc_thread_t *p_handle, bool detached,
                           void *(*entry) (void *), void *data, int priority)
{
    struct vlc_thread *th = malloc (sizeof (*th));
    if (unlikely(th == NULL))
        return ENOMEM;
    th->entry = entry;
    th->data = data;
    th->detached = detached;
    th->killable = false; /* not until vlc_entry() ! */
    th->killed = false;
    th->cleaners = NULL;

    if( DosCreateEventSem (NULL, &th->cancel_event, 0, FALSE))
        goto error;
    if( DosCreateEventSem (NULL, &th->done_event, 0, FALSE))
        goto error;

    th->cancel_sock = socket (AF_LOCAL, SOCK_STREAM, 0);
    if( th->cancel_sock < 0 )
        goto error;

    th->tid = _beginthread (vlc_entry, NULL, 1024 * 1024, th);
    if((int)th->tid == -1)
        goto error;

    if (p_handle != NULL)
        *p_handle = th;

    if (priority)
        DosSetPriority(PRTYS_THREAD,
                       HIBYTE(priority),
                       LOBYTE(priorit...",1,1,os2\thread.c,vlc_clone_attr,,false,548,592,vlc_clone_attr,,,47,"int vlc_clone_attr (vlc_thread_t*,bool,void*,void*,int)"
157863,METHOD,os2\thread.c:<global>,TYPE_DECL,"int vlc_clone (vlc_thread_t *p_handle, void *(*entry) (void *),
                void *data, int priority)
{
    return vlc_clone_attr (p_handle, false, entry, data, priority);
}",1,1,os2\thread.c,vlc_clone,,false,594,598,vlc_clone,,,48,"int vlc_clone (vlc_thread_t*,void*,void*,int)"
157878,METHOD,os2\thread.c:<global>,TYPE_DECL,"void vlc_join (vlc_thread_t th, void **result)
{
    ULONG rc;

    do
    {
        vlc_testcancel();
        rc = vlc_WaitForSingleObject( th->done_event, SEM_INDEFINITE_WAIT );
    } while( rc == ERROR_INTERRUPT );

    if (result != NULL)
        *result = th->data;

    DosCloseEventSem( th->cancel_event );
    DosCloseEventSem( th->done_event );

    soclose( th->cancel_sock );

    free( th );
}",1,1,os2\thread.c,vlc_join,,false,600,619,vlc_join,,,49,"void vlc_join (vlc_thread_t,void**)"
157923,METHOD,os2\thread.c:<global>,TYPE_DECL,"int vlc_clone_detach (vlc_thread_t *p_handle, void *(*entry) (void *),
                      void *data, int priority)
{
    vlc_thread_t th;
    if (p_handle == NULL)
        p_handle = &th;

    return vlc_clone_attr (p_handle, true, entry, data, priority);
}",1,1,os2\thread.c,vlc_clone_detach,,false,621,629,vlc_clone_detach,,,50,"int vlc_clone_detach (vlc_thread_t*,void*,void*,int)"
157948,METHOD,os2\thread.c:<global>,TYPE_DECL,"int vlc_set_priority (vlc_thread_t th, int priority)
{
    if (DosSetPriority(PRTYS_THREAD,
                       HIBYTE(priority),
                       LOBYTE(priority),
                       th->tid))
        return VLC_EGENERIC;
    return VLC_SUCCESS;
}",1,1,os2\thread.c,vlc_set_priority,,false,631,639,vlc_set_priority,,,51,"int vlc_set_priority (vlc_thread_t,int)"
157969,METHOD,os2\thread.c:<global>,TYPE_DECL,"vlc_thread_t vlc_thread_self (void)
{
    return vlc_threadvar_get (thread_key);
}",1,1,os2\thread.c,vlc_thread_self,,false,641,644,vlc_thread_self,,,52,vlc_thread_t vlc_thread_self (void)
157977,METHOD,os2\thread.c:<global>,TYPE_DECL,"unsigned long vlc_thread_id (void)
{
    return _gettid();
}",1,1,os2\thread.c,vlc_thread_id,,false,646,649,vlc_thread_id,,,53,unsigned long vlc_thread_id (void)
157984,METHOD,os2\thread.c:<global>,TYPE_DECL,"static void vlc_cancel_self (PVOID self)
{
    struct vlc_thread *th = self;

    if (likely(th != NULL))
        th->killed = true;
}",1,1,os2\thread.c,vlc_cancel_self,,false,654,660,vlc_cancel_self,,,54,void vlc_cancel_self (PVOID)
158004,METHOD,os2\thread.c:<global>,TYPE_DECL,"void vlc_cancel (vlc_thread_t thread_id)
{
    DosPostEventSem( thread_id->cancel_event );
    so_cancel( thread_id->cancel_sock );
}",1,1,os2\thread.c,vlc_cancel,,false,662,666,vlc_cancel,,,55,void vlc_cancel (vlc_thread_t)
158017,METHOD,os2\thread.c:<global>,TYPE_DECL,"int vlc_savecancel (void)
{
    int state;

    struct vlc_thread *th = vlc_thread_self ();
    if (th == NULL)
        return false; /* Main thread - cannot be cancelled anyway */

    state = th->killable;
    th->killable = false;
    return state;
}",1,1,os2\thread.c,vlc_savecancel,,false,668,679,vlc_savecancel,,,56,int vlc_savecancel (void)
158046,METHOD,os2\thread.c:<global>,TYPE_DECL,"void vlc_restorecancel (int state)
{
    struct vlc_thread *th = vlc_thread_self ();
    assert (state == false || state == true);

    if (th == NULL)
        return; /* Main thread - cannot be cancelled anyway */

    assert (!th->killable);
    th->killable = state != 0;
}",1,1,os2\thread.c,vlc_restorecancel,,false,681,691,vlc_restorecancel,,,57,void vlc_restorecancel (int)
158081,METHOD,os2\thread.c:<global>,TYPE_DECL,"void vlc_testcancel (void)
{
    struct vlc_thread *th = vlc_thread_self ();
    if (th == NULL)
        return; /* Main thread - cannot be cancelled anyway */

    /* This check is needed for the case that vlc_cancel() is followed by
     * vlc_testcancel() without any cancellation point */
    if( DosWaitEventSem( th->cancel_event, 0 ) == NO_ERROR )
        vlc_cancel_self( th );

    if (th->killable && th->killed)
    {
        for (vlc_cleanup_t *p = th->cleaners; p != NULL; p = p->next)
             p->proc (p->data);

        DosPostEventSem( th->done_event );
        th->data = NULL; /* TODO: special value? */
        vlc_thread_cleanup (th);
        _endthread();
    }
}",1,1,os2\thread.c,vlc_testcancel,,false,693,714,vlc_testcancel,,,58,void vlc_testcancel (void)
158151,METHOD,os2\thread.c:<global>,TYPE_DECL,"void vlc_control_cancel (int cmd, ...)
{
    /* NOTE: This function only modifies thread-specific data, so there is no
     * need to lock anything. */
    va_list ap;

    struct vlc_thread *th = vlc_thread_self ();
    if (th == NULL)
        return; /* Main thread - cannot be cancelled anyway */

    va_start (ap, cmd);
    switch (cmd)
    {
        case VLC_CLEANUP_PUSH:
        {
            /* cleaner is a pointer to the caller stack, no need to allocate
             * and copy anything. As a nice side effect, this cannot fail. */
            vlc_cleanup_t *cleaner = va_arg (ap, vlc_cleanup_t *);
            cleaner->next = th->cleaners;
            th->cleaners = cleaner;
            break;
        }

        case VLC_CLEANUP_POP:
        {
            th->cleaners = th->cleaners->next;
            break;
        }
    }
    va_end (ap);
}",1,1,os2\thread.c,vlc_control_cancel,,false,716,746,vlc_control_cancel,,,59,void vlc_control_cancel (int...)
158205,METHOD,os2\thread.c:<global>,TYPE_DECL,"static int vlc_select( int nfds, fd_set *rdset, fd_set *wrset, fd_set *exset,
                       struct timeval *timeout )
{
    struct vlc_thread *th = vlc_thread_self( );

    int rc;

    if( th )
    {
        FD_SET( th->cancel_sock, rdset );

        nfds = MAX( nfds, th->cancel_sock + 1 );
    }

    rc = select( nfds, rdset, wrset, exset, timeout );

    vlc_testcancel();

    return rc;

}",1,1,os2\thread.c,vlc_select,,false,748,768,vlc_select,,,60,"int vlc_select (int,fd_set*,fd_set*,fd_set*,timeval*)"
158247,METHOD,os2\thread.c:<global>,TYPE_DECL,"__declspec(dllexport)
int vlc_poll_os2( struct pollfd *fds, unsigned nfds, int timeout );",5,66,os2\thread.c,vlc_poll_os2,,false,772,772,vlc_poll_os2,,,61,"int vlc_poll_os2 (pollfd*,unsigned,int)"
158254,METHOD,os2\thread.c:<global>,TYPE_DECL,"__declspec(dllexport)
int vlc_poll_os2( struct pollfd *fds, unsigned nfds, int timeout )
{
    fd_set rdset, wrset, exset;

    int non_sockets = 0;

    struct timeval tv = { 0, 0 };

    int val = -1;

    FD_ZERO( &rdset );
    FD_ZERO( &wrset );
    FD_ZERO( &exset );
    for( unsigned i = 0; i < nfds; i++ )
    {
        int fd = fds[ i ].fd;
        struct stat stbuf;

        fds[ i ].revents = 0;

        if( fstat( fd, &stbuf ) == -1 ||
            (errno = 0, !S_ISSOCK( stbuf.st_mode )))
        {
            if( fd >= 0 )
            {
                /* If regular files, assume readiness for requested modes */
                fds[ i ].revents = ( !errno && S_ISREG( stbuf.st_mode ))
                                   ? ( fds[ i ].events &
                                       ( POLLIN | POLLOUT | POLLPRI ))
                                   : POLLNVAL;

                non_sockets++;
            }

            continue;
        }

        if( val < fd )
            val ...",1,1,os2\thread.c,vlc_poll_os2,,false,774,867,vlc_poll_os2,,,62,"int vlc_poll_os2 (pollfd*,unsigned,int)"
158576,METHOD,os2\thread.c:<global>,TYPE_DECL,"mtime_t mdate (void)
{
    /* We don't need the real date, just the value of a high precision timer */
    QWORD counter;
    ULONG freq;
    if (DosTmrQueryTime(&counter) || DosTmrQueryFreq(&freq))
        abort();

    /* Convert to from (1/freq) to microsecond resolution */
    /* We need to split the division to avoid 63-bits overflow */
    lldiv_t d = lldiv (Q2LL(counter), freq);

    return (d.quot * 1000000) + ((d.rem * 1000000) / freq);
}",1,23,os2\thread.c,mdate,,false,872,885,mdate,,,63,mtime_t mdate (void)
158620,METHOD,os2\thread.c:<global>,TYPE_DECL,"void mwait (mtime_t deadline)
{
    mtime_t delay;

    vlc_testcancel();
    while ((delay = (deadline - mdate())) > 0)
    {
        delay /= 1000;
        if (unlikely(delay > 0x7fffffff))
            delay = 0x7fffffff;
        vlc_Sleep (delay);
        vlc_testcancel();
    }
}",1,1,os2\thread.c,mwait,,false,888,901,mwait,,,64,void mwait (mtime_t)
158651,METHOD,os2\thread.c:<global>,TYPE_DECL,"void msleep (mtime_t delay)
{
    mwait (mdate () + delay);
}",1,1,os2\thread.c,msleep,,false,904,907,msleep,,,65,void msleep (mtime_t)
158666,METHOD,vlc_timer,TYPE_DECL,void (*func) (void *);,10,25,os2\thread.c,vlc_timer.func,,false,917,917,func,,,6,void vlc_timer.func (void*)
158672,METHOD,os2\thread.c:<global>,TYPE_DECL,"static void vlc_timer_do (void *arg)
{
    struct vlc_timer *timer = arg;

    while (1)
    {
        ULONG count;

        DosWaitEventSem (timer->hev, SEM_INDEFINITE_WAIT);
        DosResetEventSem (timer->hev, &count);

        if (timer->quit)
            break;

        timer->func (timer->data);

        if (timer->interval)
            DosAsyncTimer (timer->interval, (HSEM)timer->hev, &timer->htimer);
    }
}",1,1,os2\thread.c,vlc_timer_do,,false,921,940,vlc_timer_do,,,67,void vlc_timer_do (void*)
158727,METHOD,os2\thread.c:<global>,TYPE_DECL,"int vlc_timer_create (vlc_timer_t *id, void (*func) (void *), void *data)
{
    struct vlc_timer *timer = malloc (sizeof (*timer));

    if (timer == NULL)
        return ENOMEM;

    timer->func = func;
    timer->data = data;

    DosCreateEventSem (NULL, &timer->hev, DC_SEM_SHARED, FALSE);
    timer->htimer = NULLHANDLE;
    timer->interval = 0;
    timer->quit = false;
    timer->tid  = _beginthread (vlc_timer_do, NULL, 1024 * 1024, timer);

    *id = timer;
    return 0;
}",1,1,os2\thread.c,vlc_timer_create,,false,942,960,vlc_timer_create,,,68,"int vlc_timer_create (vlc_timer_t*,void,void*)"
158798,METHOD,os2\thread.c:<global>,TYPE_DECL,"void vlc_timer_destroy (vlc_timer_t timer)
{
    if (timer->htimer != NULLHANDLE)
        DosStopTimer (timer->htimer);

    timer->quit = true;
    DosPostEventSem (timer->hev);
    DosWaitThread (&timer->tid, DCWW_WAIT);
    DosCloseEventSem (timer->hev);

    free (timer);
}",1,1,os2\thread.c,vlc_timer_destroy,,false,962,973,vlc_timer_destroy,,,69,void vlc_timer_destroy (vlc_timer_t)
158835,METHOD,os2\thread.c:<global>,TYPE_DECL,"void vlc_timer_schedule (vlc_timer_t timer, bool absolute,
                         mtime_t value, mtime_t interval)
{
    if (timer->htimer != NULLHANDLE)
    {
        DosStopTimer (timer->htimer);
        timer->htimer = NULLHANDLE;
        timer->interval = 0;
    }

    if (value == 0)
        return; /* Disarm */

    if (absolute)
        value -= mdate ();
    value = (value + 999) / 1000;
    interval = (interval + 999) / 1000;

    timer->interval = interval;
    if (DosAsyncTimer (value, (HSEM)timer->hev, &timer->htimer))
        abort ();
}",1,1,os2\thread.c,vlc_timer_schedule,,false,975,996,vlc_timer_schedule,,,70,"void vlc_timer_schedule (vlc_timer_t,bool,mtime_t,mtime_t)"
158909,METHOD,os2\thread.c:<global>,TYPE_DECL,"unsigned vlc_timer_getoverrun (vlc_timer_t timer)
{
    (void)timer;
    return 0;
}",1,1,os2\thread.c,vlc_timer_getoverrun,,false,998,1002,vlc_timer_getoverrun,,,71,unsigned vlc_timer_getoverrun (vlc_timer_t)
158919,METHOD,os2\thread.c:<global>,TYPE_DECL,"unsigned vlc_GetCPUCount (void)
{
    ULONG numprocs = 1;

    DosQuerySysInfo(QSV_NUMPROCESSORS, QSV_NUMPROCESSORS,
                    &numprocs, sizeof(numprocs));

    return numprocs;
}",1,1,os2\thread.c,vlc_GetCPUCount,,false,1005,1013,vlc_GetCPUCount,,,72,unsigned vlc_GetCPUCount (void)
158954,METHOD,playlist\aout.c:<global>,TYPE_DECL,<global>,1,1,playlist\aout.c,playlist\aout.c:<global>,,false,1,124,<global>,,,1,
158956,METHOD,playlist\aout.c:<global>,TYPE_DECL,"audio_output_t *playlist_GetAout(playlist_t *pl)
{
    /* NOTE: it is assumed that the input resource exists. In practice,
     * the playlist must have been activated. This is automatic when calling
     * pl_Get(). FIXME: input resources are deleted at deactivation, this can
     * be too early. */
    playlist_private_t *sys = pl_priv(pl);
    return input_resource_HoldAout(sys->p_input_resource);
}",1,30,playlist\aout.c,playlist_GetAout,,false,36,44,playlist_GetAout,,,1,audio_output_t playlist_GetAout (playlist_t*)
158976,METHOD,playlist\aout.c:<global>,TYPE_DECL,"float playlist_VolumeGet (playlist_t *pl)
{
    float volume = -1.f;

    audio_output_t *aout = playlist_GetAout (pl);
    if (aout != NULL)
    {
        volume = aout_VolumeGet (aout);
        vlc_object_release (aout);
    }
    return volume;
}",1,1,playlist\aout.c,playlist_VolumeGet,,false,46,57,playlist_VolumeGet,,,2,float playlist_VolumeGet (playlist_t*)
159004,METHOD,playlist\aout.c:<global>,TYPE_DECL,"int playlist_VolumeSet (playlist_t *pl, float vol)
{
    int ret = -1;

    audio_output_t *aout = playlist_GetAout (pl);
    if (aout != NULL)
    {
        ret = aout_VolumeSet (aout, vol);
        vlc_object_release (aout);
    }
    return ret;
}",1,1,playlist\aout.c,playlist_VolumeSet,,false,59,70,playlist_VolumeSet,,,3,"int playlist_VolumeSet (playlist_t*,float)"
159034,METHOD,playlist\aout.c:<global>,TYPE_DECL,"int playlist_VolumeUp (playlist_t *pl, int value, float *volp)
{
    int ret = -1;

    audio_output_t *aout = playlist_GetAout (pl);
    if (aout != NULL)
    {
        ret = aout_VolumeUpdate (aout, value, volp);
        vlc_object_release (aout);
    }
    return ret;
}",1,1,playlist\aout.c,playlist_VolumeUp,,false,77,88,playlist_VolumeUp,,,4,"int playlist_VolumeUp (playlist_t*,int,float*)"
159066,METHOD,playlist\aout.c:<global>,TYPE_DECL,"int playlist_MuteGet (playlist_t *pl)
{
    int mute = -1;

    audio_output_t *aout = playlist_GetAout (pl);
    if (aout != NULL)
    {
        mute = aout_MuteGet (aout);
        vlc_object_release (aout);
    }
    return mute;
}",1,1,playlist\aout.c,playlist_MuteGet,,false,90,101,playlist_MuteGet,,,5,int playlist_MuteGet (playlist_t*)
159094,METHOD,playlist\aout.c:<global>,TYPE_DECL,"int playlist_MuteSet (playlist_t *pl, bool mute)
{
    int ret = -1;

    audio_output_t *aout = playlist_GetAout (pl);
    if (aout != NULL)
    {
        ret = aout_MuteSet (aout, mute);
        vlc_object_release (aout);
    }
    return ret;
}",1,1,playlist\aout.c,playlist_MuteSet,,false,103,114,playlist_MuteSet,,,6,"int playlist_MuteSet (playlist_t*,bool)"
159124,METHOD,playlist\aout.c:<global>,TYPE_DECL,"void playlist_EnableAudioFilter (playlist_t *pl, const char *name, bool add)
{
    audio_output_t *aout = playlist_GetAout (pl);

    aout_ChangeFilterString (VLC_OBJECT(pl), aout ? VLC_OBJECT(aout) : NULL,
                             ""audio-filter"", name, add);
    if (aout != NULL)
        vlc_object_release (aout);
}",1,1,playlist\aout.c,playlist_EnableAudioFilter,,false,116,124,playlist_EnableAudioFilter,,,7,"void playlist_EnableAudioFilter (playlist_t*,char*,bool)"
159177,METHOD,playlist\art.c:<global>,TYPE_DECL,<global>,1,1,playlist\art.c,playlist\art.c:<global>,,false,1,340,<global>,,,1,
159179,METHOD,playlist\art.c:<global>,TYPE_DECL,"static void ArtCacheCreateDir( const char *psz_dir )
{
    char newdir[strlen( psz_dir ) + 1];
    strcpy( newdir, psz_dir );
    char * psz_newdir = newdir;
    char * psz = psz_newdir;

    while( *psz )
    {
        while( *psz && *psz != DIR_SEP_CHAR) psz++;
        if( !*psz ) break;
        *psz = 0;
        if( !EMPTY_STR( psz_newdir ) )
            vlc_mkdir( psz_newdir, 0700 );
        *psz = DIR_SEP_CHAR;
        psz++;
    }
    vlc_mkdir( psz_dir, 0700 );
}",1,1,playlist\art.c,ArtCacheCreateDir,,false,41,59,ArtCacheCreateDir,,,1,void ArtCacheCreateDir (char*)
159237,METHOD,playlist\art.c:<global>,TYPE_DECL,"static char* ArtCacheGetDirPath( const char *psz_arturl, const char *psz_artist,
                                 const char *psz_album,  const char *psz_title )
{
    char *psz_dir;
    char *psz_cachedir = config_GetUserDir(VLC_CACHE_DIR);

    if( !EMPTY_STR(psz_artist) && !EMPTY_STR(psz_album) )
    {
        char *psz_album_sanitized = strdup( psz_album );
        filename_sanitize( psz_album_sanitized );
        char *psz_artist_sanitized = strdup( psz_artist );
        filename_sanitize( psz_artist_sanitized );
        if( asprintf( &psz_dir, ""%s"" DIR_SEP ""art"" DIR_SEP ""artistalbum""
                      DIR_SEP ""%s"" DIR_SEP ""%s"", psz_cachedir,
                      psz_artist_sanitized, psz_album_sanitized ) == -1 )
            psz_dir = NULL;
        free( psz_album_sanitized );
        free( psz_artist_sanitized );
    }
    else
    {
        /* If artist or album are missing, cache by art download URL.
         * If the URL is an attachment://, add the title to the cache...",1,1,playlist\art.c,ArtCacheGetDirPath,,false,61,104,ArtCacheGetDirPath,,,2,"char* ArtCacheGetDirPath (char*,char*,char*,char*)"
159330,METHOD,playlist\art.c:<global>,TYPE_DECL,"static char *ArtCachePath( input_item_t *p_item )
{
    char* psz_path = NULL;
    const char *psz_artist;
    const char *psz_album;
    const char *psz_arturl;
    const char *psz_title;

    vlc_mutex_lock( &p_item->lock );

    if( !p_item->p_meta )
        p_item->p_meta = vlc_meta_New();
    if( !p_item->p_meta )
        goto end;

    psz_artist = vlc_meta_Get( p_item->p_meta, vlc_meta_Artist );
    psz_album = vlc_meta_Get( p_item->p_meta, vlc_meta_Album );
    psz_arturl = vlc_meta_Get( p_item->p_meta, vlc_meta_ArtworkURL );
    psz_title = vlc_meta_Get( p_item->p_meta, vlc_meta_Title );
    if( !psz_title )
        psz_title = p_item->psz_name;


    if( (EMPTY_STR(psz_artist) || EMPTY_STR(psz_album) ) && !psz_arturl )
        goto end;

    psz_path = ArtCacheGetDirPath( psz_arturl, psz_artist, psz_album, psz_title );

end:
    vlc_mutex_unlock( &p_item->lock );
    return psz_path;
}",1,1,playlist\art.c,ArtCachePath,,false,106,137,ArtCachePath,,,3,char* ArtCachePath (input_item_t*)
159429,METHOD,playlist\art.c:<global>,TYPE_DECL,"static char *ArtCacheName( input_item_t *p_item, const char *psz_type )
{
    char *psz_path = ArtCachePath( p_item );
    char *psz_ext = strdup( psz_type ? psz_type : """" );
    char *psz_filename = NULL;

    if( unlikely( !psz_path || !psz_ext ) )
        goto end;

    ArtCacheCreateDir( psz_path );
    filename_sanitize( psz_ext );

    if( asprintf( &psz_filename, ""%s"" DIR_SEP ""art%s"", psz_path, psz_ext ) < 0 )
        psz_filename = NULL;

end:
    free( psz_ext );
    free( psz_path );

    return psz_filename;
}",1,1,playlist\art.c,ArtCacheName,,false,139,159,ArtCacheName,,,4,"char* ArtCacheName (input_item_t*,char*)"
159478,METHOD,playlist\art.c:<global>,TYPE_DECL,"int playlist_FindArtInCache( input_item_t *p_item )
{
    char *psz_path = ArtCachePath( p_item );

    if( !psz_path )
        return VLC_EGENERIC;

    /* Check if file exists */
    DIR *p_dir = vlc_opendir( psz_path );
    if( !p_dir )
    {
        free( psz_path );
        return VLC_EGENERIC;
    }

    bool b_found = false;
    const char *psz_filename;
    while( !b_found && (psz_filename = vlc_readdir( p_dir )) )
    {
        if( !strncmp( psz_filename, ""art"", 3 ) )
        {
            char *psz_file;
            if( asprintf( &psz_file, ""%s"" DIR_SEP ""%s"",
                          psz_path, psz_filename ) != -1 )
            {
                char *psz_uri = vlc_path2uri( psz_file, ""file"" );
                if( psz_uri )
                {
                    input_item_SetArtURL( p_item, psz_uri );
                    free( psz_uri );
                }
                free( psz_file );
            }

            b_found = true;
        }
    }

    /* */
    closedir( ...",1,1,playlist\art.c,playlist_FindArtInCache,,false,162,204,playlist_FindArtInCache,,,5,int playlist_FindArtInCache (input_item_t*)
159560,METHOD,playlist\art.c:<global>,TYPE_DECL,"static char * GetDirByItemUIDs( char *psz_uid )
{
    char *psz_cachedir = config_GetUserDir(VLC_CACHE_DIR);
    char *psz_dir;
    if( asprintf( &psz_dir, ""%s"" DIR_SEP
                  ""by-iiuid"" DIR_SEP
                  ""%s"",
                  psz_cachedir, psz_uid ) == -1 )
    {
        psz_dir = NULL;
    }
    free( psz_cachedir );
    return psz_dir;
}",1,1,playlist\art.c,GetDirByItemUIDs,,false,206,219,GetDirByItemUIDs,,,6,char* GetDirByItemUIDs (char*)
159581,METHOD,playlist\art.c:<global>,TYPE_DECL,"static char * GetFileByItemUID( char *psz_dir, const char *psz_type )
{
    char *psz_file;
    if( asprintf( &psz_file, ""%s"" DIR_SEP ""%s"", psz_dir, psz_type ) == -1 )
    {
        psz_file = NULL;
    }
    return psz_file;
}",1,1,playlist\art.c,GetFileByItemUID,,false,221,229,GetFileByItemUID,,,7,"char* GetFileByItemUID (char*,char*)"
159596,METHOD,playlist\art.c:<global>,TYPE_DECL,"int playlist_FindArtInCacheUsingItemUID( input_item_t *p_item )
{
    char *uid = input_item_GetInfo( p_item, ""uid"", ""md5"" );
    if ( ! *uid )
    {
        free( uid );
        return VLC_EGENERIC;
    }

    /* we have an input item uid set */
    bool b_done = false;
    char *psz_byuiddir = GetDirByItemUIDs( uid );
    char *psz_byuidfile = GetFileByItemUID( psz_byuiddir, ""arturl"" );
    free( psz_byuiddir );
    if( psz_byuidfile )
    {
        FILE *fd = vlc_fopen( psz_byuidfile, ""rb"" );
        if ( fd )
        {
            char sz_cachefile[2049];
            /* read the cache hash url */
            if ( fgets( sz_cachefile, 2048, fd ) != NULL )
            {
                input_item_SetArtURL( p_item, sz_cachefile );
                b_done = true;
            }
            fclose( fd );
        }
        free( psz_byuidfile );
    }
    free( uid );
    if ( b_done ) return VLC_SUCCESS;

    return VLC_EGENERIC;
}",1,1,playlist\art.c,playlist_FindArtInCacheUsingItemUID,,false,231,265,playlist_FindArtInCacheUsingItemUID,,,8,int playlist_FindArtInCacheUsingItemUID (input_item_t*)
159674,METHOD,playlist\art.c:<global>,TYPE_DECL,"int playlist_SaveArt( vlc_object_t *obj, input_item_t *p_item,
                      const void *data, size_t length, const char *psz_type )
{
    char *psz_filename = ArtCacheName( p_item, psz_type );

    if( !psz_filename )
        return VLC_EGENERIC;

    char *psz_uri = vlc_path2uri( psz_filename, ""file"" );
    if( !psz_uri )
    {
        free( psz_filename );
        return VLC_EGENERIC;
    }

    /* Check if we already dumped it */
    struct stat s;
    if( !vlc_stat( psz_filename, &s ) )
    {
        input_item_SetArtURL( p_item, psz_uri );
        free( psz_filename );
        free( psz_uri );
        return VLC_SUCCESS;
    }

    /* Dump it otherwise */
    FILE *f = vlc_fopen( psz_filename, ""wb"" );
    if( f )
    {
        if( fwrite( data, 1, length, f ) != length )
        {
            msg_Err( obj, ""%s: %s"", psz_filename, vlc_strerror_c(errno) );
        }
        else
        {
            msg_Dbg( obj, ""album art saved to %s"", psz_filename );
            inpu...",1,1,playlist\art.c,playlist_SaveArt,,false,268,340,playlist_SaveArt,,,9,"int playlist_SaveArt (vlc_object_t*,input_item_t*,void*,size_t,char*)"
159837,METHOD,playlist\art.h:<global>,TYPE_DECL,<global>,1,7,playlist\art.h,playlist\art.h:<global>,,false,1,34,<global>,,,1,
159839,METHOD,playlist\art.h:<global>,TYPE_DECL,int playlist_FindArtInCache( input_item_t * );,5,45,playlist\art.h,playlist_FindArtInCache,,false,28,28,playlist_FindArtInCache,,,1,int playlist_FindArtInCache (input_item_t*)
159844,METHOD,playlist\art.h:<global>,TYPE_DECL,int playlist_FindArtInCacheUsingItemUID( input_item_t * );,5,57,playlist\art.h,playlist_FindArtInCacheUsingItemUID,,false,29,29,playlist_FindArtInCacheUsingItemUID,,,2,int playlist_FindArtInCacheUsingItemUID (input_item_t*)
159849,METHOD,playlist\art.h:<global>,TYPE_DECL,"int playlist_SaveArt( vlc_object_t *, input_item_t *,
                      const void *, size_t, const char *psz_type );",5,66,playlist\art.h,playlist_SaveArt,,false,31,32,playlist_SaveArt,,,3,"int playlist_SaveArt (vlc_object_t*,input_item_t*,void*,ANY,char*)"
159871,METHOD,playlist\control.c:<global>,TYPE_DECL,<global>,1,26,playlist\control.c,playlist\control.c:<global>,,false,1,148,<global>,,,1,
159873,METHOD,playlist\control.c:<global>,TYPE_DECL,"void playlist_Lock( playlist_t *pl )
{
    vlc_mutex_lock( &pl_priv(pl)->lock );
}",1,21,playlist\control.c,playlist_Lock,,false,37,40,playlist_Lock,,,1,void playlist_Lock (playlist_t*)
159889,METHOD,playlist\control.c:<global>,TYPE_DECL,"void playlist_Unlock( playlist_t *pl )
{
    vlc_mutex_unlock( &pl_priv(pl)->lock );
}",1,23,playlist\control.c,playlist_Unlock,,false,42,45,playlist_Unlock,,,2,void playlist_Unlock (playlist_t*)
159905,METHOD,playlist\control.c:<global>,TYPE_DECL,"void playlist_AssertLocked( playlist_t *pl )
{
    vlc_assert_locked( &pl_priv(pl)->lock );
}",1,24,playlist\control.c,playlist_AssertLocked,,false,47,50,playlist_AssertLocked,,,3,void playlist_AssertLocked (playlist_t*)
159921,METHOD,playlist\control.c:<global>,TYPE_DECL,"static void playlist_vaControl( playlist_t *p_playlist, int i_query,
                                bool locked, va_list args )
{
    PL_LOCK_IF( !locked );

    if( pl_priv(p_playlist)->killed )
        ;
    else
    switch( i_query )
    {
    case PLAYLIST_STOP:
        pl_priv(p_playlist)->request.b_request = true;
        pl_priv(p_playlist)->request.p_item = NULL;
        pl_priv(p_playlist)->request.p_node = NULL;
        break;

    // Node can be null, it will keep the same. Use with care ...
    // Item null = take the first child of node
    case PLAYLIST_VIEWPLAY:
    {
        playlist_item_t *p_node = va_arg( args, playlist_item_t * );
        playlist_item_t *p_item = va_arg( args, playlist_item_t * );

        assert( locked || (p_item == NULL && p_node == NULL) );

        if ( p_node == NULL )
        {
            p_node = get_current_status_node( p_playlist );
            assert( p_node );
        }
        pl_priv(p_playlist)->request.i_skip = 0;
        pl_pr...",1,4,playlist\control.c,playlist_vaControl,,false,52,139,playlist_vaControl,,,4,"void playlist_vaControl (playlist_t*,int,bool,va_list)"
160413,METHOD,playlist\control.c:<global>,TYPE_DECL,"void playlist_Control( playlist_t *p_playlist, int query, int locked, ... )
{
    va_list args;

    va_start( args, locked );
    playlist_vaControl( p_playlist, query, (bool)locked, args );
    va_end( args );
}",1,1,playlist\control.c,playlist_Control,,false,141,148,playlist_Control,,,5,"void playlist_Control (playlist_t*,int,int...)"
160460,METHOD,playlist\engine.c:<global>,TYPE_DECL,<global>,1,36,playlist\engine.c,playlist\engine.c:<global>,,false,1,503,<global>,,,1,
160462,METHOD,playlist\engine.c:<global>,TYPE_DECL,static void VariablesInit( playlist_t *p_playlist );,13,51,playlist\engine.c,VariablesInit,,false,44,44,VariablesInit,,,1,void VariablesInit (playlist_t*)
160467,METHOD,playlist\engine.c:<global>,TYPE_DECL,"static int RandomCallback( vlc_object_t *p_this, char const *psz_cmd,
                           vlc_value_t oldval, vlc_value_t newval, void *a )
{
    (void)psz_cmd; (void)oldval; (void)newval; (void)a;
    playlist_t *p_playlist = (playlist_t*)p_this;
    bool random = newval.b_bool;

    PL_LOCK;

    if( !random ) {
        pl_priv(p_playlist)->b_reset_currently_playing = true;
        vlc_cond_signal( &pl_priv(p_playlist)->signal );
    } else {
        /* Shuffle and sync the playlist on activation of random mode.
         * This preserves the current playing item, so that the user
         * can return to it if needed. (See #4472)
         */
        playlist_private_t *p_sys = pl_priv(p_playlist);
        playlist_item_t *p_new = p_sys->status.p_item;
        ResetCurrentlyPlaying( p_playlist, NULL );
        if( p_new )
            ResyncCurrentIndex( p_playlist, p_new );
    }

    PL_UNLOCK;
    return VLC_SUCCESS;
}",1,8,playlist\engine.c,RandomCallback,,false,46,72,RandomCallback,,,2,"int RandomCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
160559,METHOD,playlist\engine.c:<global>,TYPE_DECL,"static int CorksCallback( vlc_object_t *obj, char const *var,
                          vlc_value_t old, vlc_value_t cur, void *dummy )
{
    playlist_t *pl = (playlist_t *)obj;

    msg_Dbg( obj, ""corks count: %""PRId64"" -> %""PRId64, old.i_int, cur.i_int );
    if( !old.i_int == !cur.i_int )
        return VLC_SUCCESS; /* nothing to do */

    if( !var_InheritBool( obj, ""playlist-cork"" ) )
        return VLC_SUCCESS;

    playlist_Lock(pl);

    if( cur.i_int )
    {
        bool effective = playlist_Status(pl) == PLAYLIST_RUNNING;

        msg_Dbg(obj, ""corked (%seffective)"", effective ? """" : ""in"");
        pl_priv(pl)->cork_effective = effective;
        playlist_Control(pl, PLAYLIST_PAUSE, pl_Locked);
    }
    else
    {
        bool effective = pl_priv(pl)->cork_effective;

        msg_Dbg(obj, ""uncorked (%seffective)"", effective ? """" : ""in"");

        if (effective)
            playlist_Control(pl, PLAYLIST_RESUME, pl_Locked);
    }

    playlist_Unlock(pl);
    (void) var; (v...",1,8,playlist\engine.c,CorksCallback,,false,80,115,CorksCallback,,,3,"int CorksCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
160670,METHOD,playlist\engine.c:<global>,TYPE_DECL,"static int RateCallback( vlc_object_t *p_this, char const *psz_cmd,
                         vlc_value_t oldval, vlc_value_t newval, void *p )
{
    (void)psz_cmd; (void)oldval;(void)p;
    playlist_t *p_playlist = (playlist_t*)p_this;

    PL_LOCK;

    if( pl_priv(p_playlist)->p_input )
        var_SetFloat( pl_priv( p_playlist )->p_input, ""rate"", newval.f_float );

    PL_UNLOCK;
    return VLC_SUCCESS;
}",1,8,playlist\engine.c,RateCallback,,false,117,130,RateCallback,,,4,"int RateCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
160723,METHOD,playlist\engine.c:<global>,TYPE_DECL,"static int RateOffsetCallback( vlc_object_t *obj, char const *psz_cmd,
                               vlc_value_t oldval, vlc_value_t newval, void *p_data )
{
    playlist_t *p_playlist = (playlist_t *)obj;
    VLC_UNUSED(oldval); VLC_UNUSED(p_data); VLC_UNUSED(newval);

    static const float rates[] = {
        1.0/64, 1.0/32, 1.0/16, 1.0/8, 1.0/4, 1.0/3, 1.0/2, 2.0/3,
        1.0/1,
        3.0/2, 2.0/1, 3.0/1, 4.0/1, 8.0/1, 16.0/1, 32.0/1, 64.0/1,
    };

    PL_LOCK;
    input_thread_t *input = pl_priv( p_playlist )->p_input;
    float current_rate = var_GetFloat( input ? VLC_OBJECT( input ) : obj, ""rate"" );
    PL_UNLOCK;

    const bool faster = !strcmp( psz_cmd, ""rate-faster"" );
    float rate = current_rate * ( faster ? 1.1f : 0.9f );

    /* find closest rate (if any) in the desired direction */
    for( size_t i = 0; i < ARRAY_SIZE( rates ); ++i )
    {
        if( ( faster && rates[i] > rate ) ||
            (!faster && rates[i] >= rate && i ) )
        {
            rat...",1,28,playlist\engine.c,RateOffsetCallback,,false,132,167,RateOffsetCallback,,,5,"int RateOffsetCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
160899,METHOD,playlist\engine.c:<global>,TYPE_DECL,"static int VideoSplitterCallback( vlc_object_t *p_this, char const *psz_cmd,
                                  vlc_value_t oldval, vlc_value_t newval, void *p_data )
{
    playlist_t *p_playlist = (playlist_t*)p_this;
    VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval); VLC_UNUSED(p_data); VLC_UNUSED(newval);

    PL_LOCK;

    /* Force the input to restart the video ES to force a vout recreation */
    input_thread_t *p_input = pl_priv( p_playlist )->p_input;
    if( p_input )
    {
        const double f_position = var_GetFloat( p_input, ""position"" );
        input_Control( p_input, INPUT_RESTART_ES, -VIDEO_ES );
        var_SetFloat( p_input, ""position"", f_position );
    }

    PL_UNLOCK;
    return VLC_SUCCESS;
}",1,30,playlist\engine.c,VideoSplitterCallback,,false,169,188,VideoSplitterCallback,,,6,"int VideoSplitterCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
160956,METHOD,playlist\engine.c:<global>,TYPE_DECL,"playlist_t *playlist_Create( vlc_object_t *p_parent )
{
    playlist_t *p_playlist;
    playlist_private_t *p;

    /* Allocate structure */
    p = vlc_custom_create( p_parent, sizeof( *p ), ""playlist"" );
    if( !p )
        return NULL;

    p_playlist = &p->public_data;

    p->input_tree = NULL;
    p->id_tree = NULL;

    TAB_INIT( pl_priv(p_playlist)->i_sds, pl_priv(p_playlist)->pp_sds );

    VariablesInit( p_playlist );
    vlc_mutex_init( &p->lock );
    vlc_cond_init( &p->signal );
    p->killed = false;

    /* Initialise data structures */
    pl_priv(p_playlist)->i_last_playlist_id = 0;
    pl_priv(p_playlist)->p_input = NULL;

    ARRAY_INIT( p_playlist->items );
    ARRAY_INIT( p_playlist->current );

    p_playlist->i_current_index = 0;
    pl_priv(p_playlist)->b_reset_currently_playing = true;

    pl_priv(p_playlist)->b_tree = var_InheritBool( p_parent, ""playlist-tree"" );
    pl_priv(p_playlist)->b_preparse = var_InheritBool( p_parent, ""auto-preparse"" );

    p_pl...",1,14,playlist\engine.c,playlist_Create,,false,197,303,playlist_Create,,,7,playlist_t playlist_Create (vlc_object_t*)
161356,METHOD,playlist\engine.c:<global>,TYPE_DECL,"void playlist_Destroy( playlist_t *p_playlist )
{
    playlist_private_t *p_sys = pl_priv(p_playlist);

    /* Remove all services discovery */
    playlist_ServicesDiscoveryKillAll( p_playlist );

    msg_Dbg( p_playlist, ""destroying"" );

    playlist_Deactivate( p_playlist );

    /* Release input resources */
    assert( p_sys->p_input == NULL );
    input_resource_Release( p_sys->p_input_resource );
    if( p_sys->p_renderer )
        vlc_renderer_item_release( p_sys->p_renderer );

    if( p_playlist->p_media_library != NULL )
        playlist_MLDump( p_playlist );

    PL_LOCK;
    /* Release the current node */
    set_current_status_node( p_playlist, NULL );
    /* Release the current item */
    set_current_status_item( p_playlist, NULL );

    /* Destroy arrays completely - faster than one item at a time */
    ARRAY_RESET( p_playlist->items );
    ARRAY_RESET( p_playlist->current );

    /* Remove all remaining items */
    if( p_playlist->p_media_library != NULL )
    {
...",1,32,playlist\engine.c,playlist_Destroy,,false,312,366,playlist_Destroy,,,8,void playlist_Destroy (playlist_t*)
161479,METHOD,playlist\engine.c:<global>,TYPE_DECL,"input_thread_t *playlist_CurrentInputLocked( playlist_t *p_playlist )
{
    PL_ASSERT_LOCKED;

    input_thread_t *p_input = pl_priv(p_playlist)->p_input;
    if( p_input != NULL )
        vlc_object_hold( p_input );
    return p_input;
}",1,30,playlist\engine.c,playlist_CurrentInputLocked,,false,370,378,playlist_CurrentInputLocked,,,9,input_thread_t playlist_CurrentInputLocked (playlist_t*)
161506,METHOD,playlist\engine.c:<global>,TYPE_DECL,"input_thread_t * playlist_CurrentInput( playlist_t * p_playlist )
{
    input_thread_t * p_input;
    PL_LOCK;
    p_input = playlist_CurrentInputLocked( p_playlist );
    PL_UNLOCK;
    return p_input;
}",1,1,playlist\engine.c,playlist_CurrentInput,,false,383,390,playlist_CurrentInput,,,10,input_thread_t playlist_CurrentInput (playlist_t*)
161520,METHOD,playlist\engine.c:<global>,TYPE_DECL,"playlist_item_t * get_current_status_item( playlist_t * p_playlist )
{
    PL_ASSERT_LOCKED;

    return pl_priv(p_playlist)->status.p_item;
}",1,11,playlist\engine.c,get_current_status_item,,false,398,403,get_current_status_item,,,11,playlist_item_t get_current_status_item (playlist_t*)
161538,METHOD,playlist\engine.c:<global>,TYPE_DECL,"playlist_item_t * get_current_status_node( playlist_t * p_playlist )
{
    PL_ASSERT_LOCKED;

    return pl_priv(p_playlist)->status.p_node;
}",1,11,playlist\engine.c,get_current_status_node,,false,405,410,get_current_status_node,,,12,playlist_item_t get_current_status_node (playlist_t*)
161556,METHOD,playlist\engine.c:<global>,TYPE_DECL,"void set_current_status_item( playlist_t * p_playlist,
    playlist_item_t * p_item )
{
    PL_ASSERT_LOCKED;

    pl_priv(p_playlist)->status.p_item = p_item;
}",1,4,playlist\engine.c,set_current_status_item,,false,412,418,set_current_status_item,,,13,"void set_current_status_item (playlist_t*,playlist_item_t*)"
161576,METHOD,playlist\engine.c:<global>,TYPE_DECL,"void set_current_status_node( playlist_t * p_playlist,
    playlist_item_t * p_node )
{
    PL_ASSERT_LOCKED;

    pl_priv(p_playlist)->status.p_node = p_node;
}",1,4,playlist\engine.c,set_current_status_node,,false,420,426,set_current_status_node,,,14,"void set_current_status_node (playlist_t*,playlist_item_t*)"
161596,METHOD,playlist\engine.c:<global>,TYPE_DECL,"static void VariablesInit( playlist_t *p_playlist )
{
    /* These variables control updates */
    var_Create( p_playlist, ""item-change"", VLC_VAR_ADDRESS );
    var_Create( p_playlist, ""leaf-to-parent"", VLC_VAR_INTEGER );

    var_Create( p_playlist, ""playlist-item-append"", VLC_VAR_ADDRESS );
    var_Create( p_playlist, ""playlist-item-deleted"", VLC_VAR_ADDRESS );

    var_Create( p_playlist, ""input-current"", VLC_VAR_ADDRESS );

    /* Variables to control playback */
    var_Create( p_playlist, ""playlist-autostart"", VLC_VAR_BOOL | VLC_VAR_DOINHERIT );
    var_Create( p_playlist, ""random"", VLC_VAR_BOOL | VLC_VAR_DOINHERIT );
    var_AddCallback( p_playlist, ""random"", RandomCallback, NULL );
    var_Create( p_playlist, ""repeat"", VLC_VAR_BOOL | VLC_VAR_DOINHERIT );
    var_Create( p_playlist, ""loop"", VLC_VAR_BOOL | VLC_VAR_DOINHERIT );
    var_Create( p_playlist, ""corks"", VLC_VAR_INTEGER );
    var_AddCallback( p_playlist, ""corks"", CorksCallback, NULL );

    var_Create( p_playlist, ""...",1,1,playlist\engine.c,VariablesInit,,false,428,483,VariablesInit,,,15,void VariablesInit (playlist_t*)
161784,METHOD,playlist\engine.c:<global>,TYPE_DECL,"playlist_item_t * playlist_CurrentPlayingItem( playlist_t * p_playlist )
{
    PL_ASSERT_LOCKED;

    return pl_priv(p_playlist)->status.p_item;
}",1,11,playlist\engine.c,playlist_CurrentPlayingItem,,false,485,490,playlist_CurrentPlayingItem,,,16,playlist_item_t playlist_CurrentPlayingItem (playlist_t*)
161802,METHOD,playlist\engine.c:<global>,TYPE_DECL,"int playlist_Status( playlist_t * p_playlist )
{
    input_thread_t *p_input = pl_priv(p_playlist)->p_input;

    PL_ASSERT_LOCKED;

    if( p_input == NULL )
        return PLAYLIST_STOPPED;
    if( var_GetInteger( p_input, ""state"" ) == PAUSE_S )
        return PLAYLIST_PAUSED;
    return PLAYLIST_RUNNING;
}",1,30,playlist\engine.c,playlist_Status,,false,492,503,playlist_Status,,,17,int playlist_Status (playlist_t*)
161873,METHOD,playlist\fetcher.c:<global>,TYPE_DECL,<global>,1,1,playlist\fetcher.c,playlist\fetcher.c:<global>,,false,1,482,<global>,,,1,
161891,METHOD,fetcher_thread,TYPE_DECL,"void (*pf_worker)( playlist_fetcher_t*, struct fetcher_request* );",10,69,playlist\fetcher.c,fetcher_thread.pf_worker,,false,61,61,pf_worker,,,1,"void fetcher_thread.pf_worker (playlist_fetcher_t*,fetcher_request*)"
161905,METHOD,playlist\fetcher.c:<global>,TYPE_DECL,"static char* CreateCacheKey( input_item_t* item )
{
    vlc_mutex_lock( &item->lock );

    if( !item->p_meta )
    {
        vlc_mutex_unlock( &item->lock );
        return NULL;
    }

    char const* artist = vlc_meta_Get( item->p_meta, vlc_meta_Artist );
    char const* album = vlc_meta_Get( item->p_meta, vlc_meta_Album );
    char* key;

    /**
     * Simple concatenation of artist and album can lead to the same key
     * for entities that should not have such. Imagine { dogs, tick } and
     * { dog, stick } */
    if( !artist || !album || asprintf( &key, ""%s:%zu:%s:%zu"",
          artist, strlen( artist ), album, strlen( album ) ) < 0 )
    {
        key = NULL;
    }
    vlc_mutex_unlock( &item->lock );

    return key;
}",1,1,playlist\fetcher.c,CreateCacheKey,,false,72,98,CreateCacheKey,,,4,char* CreateCacheKey (input_item_t*)
161975,METHOD,playlist\fetcher.c:<global>,TYPE_DECL,"static void FreeCacheEntry( void* data, void* obj )
{
    free( data );
    VLC_UNUSED( obj );
}",1,1,playlist\fetcher.c,FreeCacheEntry,,false,100,104,FreeCacheEntry,,,5,"void FreeCacheEntry (void*,void*)"
161985,METHOD,playlist\fetcher.c:<global>,TYPE_DECL,"static int ReadAlbumCache( playlist_fetcher_t* fetcher, input_item_t* item )
{
    char* key = CreateCacheKey( item );

    if( key == NULL )
        return VLC_EGENERIC;

    vlc_mutex_lock( &fetcher->lock );
    char const* art = vlc_dictionary_value_for_key( &fetcher->album_cache,
                                                    key );
    if( art )
        input_item_SetArtURL( item, art );
    vlc_mutex_unlock( &fetcher->lock );

    free( key );
    return art ? VLC_SUCCESS : VLC_EGENERIC;
}",1,1,playlist\fetcher.c,ReadAlbumCache,,false,106,122,ReadAlbumCache,,,6,"int ReadAlbumCache (playlist_fetcher_t*,input_item_t*)"
162035,METHOD,playlist\fetcher.c:<global>,TYPE_DECL,"static void AddAlbumCache( playlist_fetcher_t* fetcher, input_item_t* item,
                          bool overwrite )
{
    char* art = input_item_GetArtURL( item );
    char* key = CreateCacheKey( item );

    if( key && art && strncasecmp( art, ""attachment://"", 13 ) )
    {
        vlc_mutex_lock( &fetcher->lock );
        if( overwrite || !vlc_dictionary_has_key( &fetcher->album_cache, key ) )
        {
            vlc_dictionary_insert( &fetcher->album_cache, key, art );
            art = NULL;
        }
        vlc_mutex_unlock( &fetcher->lock );
    }

    free( art );
    free( key );
}",1,1,playlist\fetcher.c,AddAlbumCache,,false,124,143,AddAlbumCache,,,7,"void AddAlbumCache (playlist_fetcher_t*,input_item_t*,bool)"
162097,METHOD,playlist\fetcher.c:<global>,TYPE_DECL,"static int InvokeModule( playlist_fetcher_t* fetcher, input_item_t* item,
                         int scope, char const* type )
{
    meta_fetcher_t* mf = vlc_custom_create( fetcher->owner,
                                            sizeof( *mf ), type );
    if( unlikely( !mf ) )
        return VLC_ENOMEM;

    mf->e_scope = scope;
    mf->p_item = item;

    module_t* mf_module = module_need( mf, type, NULL, false );

    if( mf_module )
        module_unneed( mf, mf_module );

    vlc_object_release( mf );

    return VLC_SUCCESS;
}",1,25,playlist\fetcher.c,InvokeModule,,false,145,164,InvokeModule,,,8,"int InvokeModule (playlist_fetcher_t*,input_item_t*,int,char*)"
162158,METHOD,playlist\fetcher.c:<global>,TYPE_DECL,"static int CheckMeta( input_item_t* item )
{
    vlc_mutex_lock( &item->lock );
    bool error = !item->p_meta ||
                 !vlc_meta_Get( item->p_meta, vlc_meta_Title ) ||
                 !vlc_meta_Get( item->p_meta, vlc_meta_Artist ) ||
                 !vlc_meta_Get( item->p_meta, vlc_meta_Album );
    vlc_mutex_unlock( &item->lock );
    return error;
}",1,1,playlist\fetcher.c,CheckMeta,,false,166,175,CheckMeta,,,9,int CheckMeta (input_item_t*)
162203,METHOD,playlist\fetcher.c:<global>,TYPE_DECL,"static int CheckArt( input_item_t* item )
{
    vlc_mutex_lock( &item->lock );
    bool error = !item->p_meta ||
                 !vlc_meta_Get( item->p_meta, vlc_meta_ArtworkURL );
    vlc_mutex_unlock( &item->lock );
    return error;
}",1,1,playlist\fetcher.c,CheckArt,,false,177,184,CheckArt,,,10,int CheckArt (input_item_t*)
162234,METHOD,playlist\fetcher.c:<global>,TYPE_DECL,"static int SearchArt( playlist_fetcher_t* fetcher, input_item_t* item, int scope)
{
    InvokeModule( fetcher, item, scope, ""art finder"" );
    return CheckArt( item );
}",1,1,playlist\fetcher.c,SearchArt,,false,186,190,SearchArt,,,11,"int SearchArt (playlist_fetcher_t*,input_item_t*,int)"
162249,METHOD,playlist\fetcher.c:<global>,TYPE_DECL,"static int SearchByScope( playlist_fetcher_t* fetcher,
    struct fetcher_request* req, int scope )
{
    input_item_t* item = req->item;

    if( CheckMeta( item ) &&
        InvokeModule( fetcher, req->item, scope, ""meta fetcher"" ) )
    {
        return VLC_EGENERIC;
    }

    if( ! CheckArt( item )                            ||
        ! ReadAlbumCache( fetcher, item )             ||
        ! playlist_FindArtInCacheUsingItemUID( item ) ||
        ! playlist_FindArtInCache( item )             ||
        ! SearchArt( fetcher, item, scope ) )
    {
        AddAlbumCache( fetcher, req->item, false );
        if( !background_worker_Push( fetcher->downloader, req, NULL, 0 ) )
            return VLC_SUCCESS;
    }

    return VLC_EGENERIC;
}",1,1,playlist\fetcher.c,SearchByScope,,false,192,215,SearchByScope,,,12,"int SearchByScope (playlist_fetcher_t*,fetcher_request*,int)"
162320,METHOD,playlist\fetcher.c:<global>,TYPE_DECL,"static void SetPreparsed( struct fetcher_request* req )
{
    if( req->preparse_status != -1 )
    {
        input_item_SetPreparsed( req->item, true );
        input_item_SignalPreparseEnded( req->item, req->preparse_status );
    }
}",1,1,playlist\fetcher.c,SetPreparsed,,false,217,224,SetPreparsed,,,13,void SetPreparsed (fetcher_request*)
162345,METHOD,playlist\fetcher.c:<global>,TYPE_DECL,"static void Downloader( playlist_fetcher_t* fetcher,
    struct fetcher_request* req )
{
    ReadAlbumCache( fetcher, req->item );

    char *psz_arturl = input_item_GetArtURL( req->item );
    if( !psz_arturl )
        goto error;

    if( !strncasecmp( psz_arturl, ""file://"", 7 ) ||
        !strncasecmp( psz_arturl, ""attachment://"", 13 ) )
        goto out; /* no fetch required */

    stream_t* source = vlc_stream_NewURL( fetcher->owner, psz_arturl );

    if( !source )
        goto error;

    struct vlc_memstream output_stream;
    vlc_memstream_open( &output_stream );

    for( ;; )
    {
        char buffer[2048];

        int read = vlc_stream_Read( source, buffer, sizeof( buffer ) );
        if( read <= 0 )
            break;

        if( (int)vlc_memstream_write( &output_stream, buffer, read ) < read )
            break;
    }

    vlc_stream_Delete( source );

    if( vlc_memstream_close( &output_stream ) )
        goto error;

    if( vlc_killed() )
    {
        free( ou...",1,1,playlist\fetcher.c,Downloader,,false,226,290,Downloader,,,14,"void Downloader (playlist_fetcher_t*,fetcher_request*)"
162495,METHOD,playlist\fetcher.c:<global>,TYPE_DECL,"static void SearchLocal( playlist_fetcher_t* fetcher, struct fetcher_request* req )
{
    if( SearchByScope( fetcher, req, FETCHER_SCOPE_LOCAL ) == VLC_SUCCESS )
        return; /* done */

    if( var_InheritBool( fetcher->owner, ""metadata-network-access"" ) ||
        req->options & META_REQUEST_OPTION_SCOPE_NETWORK )
    {
        if( background_worker_Push( fetcher->network, req, NULL, 0 ) )
            SetPreparsed( req );
    }
    else
    {
        input_item_SetArtNotFound( req->item, true );
        SetPreparsed( req );
    }
}",1,1,playlist\fetcher.c,SearchLocal,,false,292,308,SearchLocal,,,15,"void SearchLocal (playlist_fetcher_t*,fetcher_request*)"
162543,METHOD,playlist\fetcher.c:<global>,TYPE_DECL,"static void SearchNetwork( playlist_fetcher_t* fetcher, struct fetcher_request* req )
{
    if( SearchByScope( fetcher, req, FETCHER_SCOPE_NETWORK ) )
    {
        input_item_SetArtNotFound( req->item, true );
        SetPreparsed( req );
    }
}",1,1,playlist\fetcher.c,SearchNetwork,,false,310,317,SearchNetwork,,,16,"void SearchNetwork (playlist_fetcher_t*,fetcher_request*)"
162562,METHOD,playlist\fetcher.c:<global>,TYPE_DECL,"static void RequestRelease( void* req_ )
{
    struct fetcher_request* req = req_;

    if( atomic_fetch_sub( &req->refs, 1 ) != 1 )
        return;

    input_item_Release( req->item );
    free( req );
}",1,1,playlist\fetcher.c,RequestRelease,,false,319,328,RequestRelease,,,17,void RequestRelease (void*)
162588,METHOD,playlist\fetcher.c:<global>,TYPE_DECL,"static void RequestHold( void* req_ )
{
    struct fetcher_request* req = req_;
    atomic_fetch_add_explicit( &req->refs, 1, memory_order_relaxed );
}",1,1,playlist\fetcher.c,RequestHold,,false,330,334,RequestHold,,,18,void RequestHold (void*)
162604,METHOD,playlist\fetcher.c:<global>,TYPE_DECL,"static void* FetcherThread( void* handle )
{
    struct fetcher_thread* th = handle;
    vlc_interrupt_set( &th->interrupt );

    th->pf_worker( th->fetcher, th->req );

    atomic_store( &th->active, false );
    background_worker_RequestProbe( th->worker );
    return NULL;
}",1,1,playlist\fetcher.c,FetcherThread,,false,336,346,FetcherThread,,,19,void* FetcherThread (void*)
162640,METHOD,playlist\fetcher.c:<global>,TYPE_DECL,"static int StartWorker( playlist_fetcher_t* fetcher,
    void( *pf_worker )( playlist_fetcher_t*, struct fetcher_request* ),
    struct background_worker* bg, struct fetcher_request* req, void** handle )
{
    struct fetcher_thread* th = malloc( sizeof *th );

    if( unlikely( !th ) )
        return VLC_ENOMEM;

    th->req = req;
    th->worker = bg;
    th->fetcher = fetcher;
    th->pf_worker = pf_worker;

    vlc_interrupt_init( &th->interrupt );
    atomic_init( &th->active, true );

    if( !vlc_clone( &th->thread, FetcherThread, th, VLC_THREAD_PRIORITY_LOW ) )
    {
        *handle = th;
        return VLC_SUCCESS;
    }

    vlc_interrupt_deinit( &th->interrupt );
    free( th );
    return VLC_EGENERIC;
}",1,1,playlist\fetcher.c,StartWorker,,false,348,374,StartWorker,,,20,"int StartWorker (playlist_fetcher_t*,void,background_worker*,fetcher_request*,void**)"
162720,METHOD,playlist\fetcher.c:<global>,TYPE_DECL,"static int ProbeWorker( void* fetcher_, void* th_ )
{
    return !atomic_load( &((struct fetcher_thread*)th_)->active );
    VLC_UNUSED( fetcher_ );
}",1,1,playlist\fetcher.c,ProbeWorker,,false,376,380,ProbeWorker,,,21,"int ProbeWorker (void*,void*)"
162737,METHOD,playlist\fetcher.c:<global>,TYPE_DECL,"static void CloseWorker( void* fetcher_, void* th_ )
{
    struct fetcher_thread* th = th_;
    VLC_UNUSED( fetcher_ );

    vlc_interrupt_kill( &th->interrupt );
    vlc_join( th->thread, NULL );
    vlc_interrupt_deinit( &th->interrupt );
    free( th );
}",1,1,playlist\fetcher.c,CloseWorker,,false,382,391,CloseWorker,,,22,"void CloseWorker (void*,void*)"
162766,METHOD,playlist\fetcher.c:<global>,TYPE_DECL,"DEF_STARTER(  SearchLocal, fetcher->local )",1,43,playlist\fetcher.c,StartSearchLocal,,false,398,398,StartSearchLocal,,,23,"int StartSearchLocal (void*,void*,void**)"
162786,METHOD,playlist\fetcher.c:<global>,TYPE_DECL,"DEF_STARTER(SearchNetwork, fetcher->network )",1,45,playlist\fetcher.c,StartSearchNetwork,,false,399,399,StartSearchNetwork,,,24,"int StartSearchNetwork (void*,void*,void**)"
162806,METHOD,playlist\fetcher.c:<global>,TYPE_DECL,"DEF_STARTER(   Downloader, fetcher->downloader )",1,48,playlist\fetcher.c,StartDownloader,,false,400,400,StartDownloader,,,25,"int StartDownloader (void*,void*,void**)"
162826,METHOD,playlist\fetcher.c:<global>,TYPE_DECL,"static void WorkerInit( playlist_fetcher_t* fetcher,
    struct background_worker** worker, int( *starter )( void*, void*, void** ) )
{
    struct background_worker_config conf = {
        .default_timeout = 0,
        .pf_start = starter,
        .pf_probe = ProbeWorker,
        .pf_stop = CloseWorker,
        .pf_release = RequestRelease,
        .pf_hold = RequestHold };

    *worker = background_worker_New( fetcher, &conf );
}",1,1,playlist\fetcher.c,WorkerInit,,false,402,414,WorkerInit,,,26,"void WorkerInit (playlist_fetcher_t*,background_worker**,int)"
162868,METHOD,playlist\fetcher.c:<global>,TYPE_DECL,"playlist_fetcher_t* playlist_fetcher_New( vlc_object_t* owner )
{
    playlist_fetcher_t* fetcher = malloc( sizeof( *fetcher ) );

    if( unlikely( !fetcher ) )
        return NULL;

    fetcher->owner = owner;

    WorkerInit( fetcher, &fetcher->local, StartSearchLocal );
    WorkerInit( fetcher, &fetcher->network, StartSearchNetwork );
    WorkerInit( fetcher, &fetcher->downloader, StartDownloader );

    if( unlikely( !fetcher->local || !fetcher->network || !fetcher->downloader ) )
    {
        if( fetcher->local )
            background_worker_Delete( fetcher->local );

        if( fetcher->network )
            background_worker_Delete( fetcher->network );

        if( fetcher->downloader )
            background_worker_Delete( fetcher->downloader );

        free( fetcher );
        return NULL;
    }

    vlc_mutex_init( &fetcher->lock );
    vlc_dictionary_init( &fetcher->album_cache, 0 );

    return fetcher;
}",1,1,playlist\fetcher.c,playlist_fetcher_New,,false,416,448,playlist_fetcher_New,,,27,playlist_fetcher_t playlist_fetcher_New (vlc_object_t*)
162974,METHOD,playlist\fetcher.c:<global>,TYPE_DECL,"int playlist_fetcher_Push( playlist_fetcher_t* fetcher, input_item_t* item,
    input_item_meta_request_option_t options, int preparse_status )
{
    struct fetcher_request* req = malloc( sizeof *req );

    if( unlikely( !req ) )
        return VLC_ENOMEM;

    req->item = item;
    req->options = options;
    req->preparse_status = preparse_status;

    atomic_init( &req->refs, 1 );
    input_item_Hold( item );

    if( background_worker_Push( fetcher->local, req, NULL, 0 ) )
        SetPreparsed( req );

    RequestRelease( req );
    return VLC_SUCCESS;
}",1,1,playlist\fetcher.c,playlist_fetcher_Push,,false,450,470,playlist_fetcher_Push,,,28,"int playlist_fetcher_Push (playlist_fetcher_t*,input_item_t*,input_item_meta_request_option_t,int)"
163034,METHOD,playlist\fetcher.c:<global>,TYPE_DECL,"void playlist_fetcher_Delete( playlist_fetcher_t* fetcher )
{
    background_worker_Delete( fetcher->local );
    background_worker_Delete( fetcher->network );
    background_worker_Delete( fetcher->downloader );

    vlc_dictionary_clear( &fetcher->album_cache, FreeCacheEntry, NULL );
    vlc_mutex_destroy( &fetcher->lock );

    free( fetcher );
}",1,1,playlist\fetcher.c,playlist_fetcher_Delete,,false,472,482,playlist_fetcher_Delete,,,29,void playlist_fetcher_Delete (playlist_fetcher_t*)
163070,METHOD,playlist\fetcher.h:<global>,TYPE_DECL,<global>,1,7,playlist\fetcher.h,playlist\fetcher.h:<global>,,false,1,59,<global>,,,1,
163074,METHOD,playlist\fetcher.h:<global>,TYPE_DECL,playlist_fetcher_t *playlist_fetcher_New( vlc_object_t * );,20,58,playlist\fetcher.h,playlist_fetcher_New,,false,41,41,playlist_fetcher_New,,,3,playlist_fetcher_t* playlist_fetcher_New (vlc_object_t*)
163079,METHOD,playlist\fetcher.h:<global>,TYPE_DECL,"int playlist_fetcher_Push( playlist_fetcher_t *, input_item_t *,
                           input_item_meta_request_option_t, int );",5,66,playlist\fetcher.h,playlist_fetcher_Push,,false,49,50,playlist_fetcher_Push,,,4,"int playlist_fetcher_Push (playlist_fetcher_t*,input_item_t*,ANY,int)"
163087,METHOD,playlist\fetcher.h:<global>,TYPE_DECL,void playlist_fetcher_Delete( playlist_fetcher_t * );,6,52,playlist\fetcher.h,playlist_fetcher_Delete,,false,57,57,playlist_fetcher_Delete,,,5,void playlist_fetcher_Delete (playlist_fetcher_t*)
163113,METHOD,playlist\item.c:<global>,TYPE_DECL,<global>,1,22,playlist\item.c,playlist\item.c:<global>,,false,1,879,<global>,,,1,
163115,METHOD,playlist\item.c:<global>,TYPE_DECL,"static void playlist_Preparse( playlist_t *, playlist_item_t * );",13,64,playlist\item.c,playlist_Preparse,,false,40,40,playlist_Preparse,,,1,"void playlist_Preparse (playlist_t*,playlist_item_t*)"
163121,METHOD,playlist\item.c:<global>,TYPE_DECL,"static int RecursiveAddIntoParent (
                playlist_t *p_playlist, playlist_item_t *p_parent,
                input_item_node_t *p_node, int i_pos, bool b_flat,
                playlist_item_t **pp_first_leaf );",12,49,playlist\item.c,RecursiveAddIntoParent,,false,42,45,RecursiveAddIntoParent,,,2,"int RecursiveAddIntoParent (playlist_t*,playlist_item_t*,input_item_node_t*,int,bool,playlist_item_t**)"
163131,METHOD,playlist\item.c:<global>,TYPE_DECL,"static int RecursiveInsertCopy (
                playlist_t *p_playlist, playlist_item_t *p_item,
                playlist_item_t *p_parent, int i_pos, bool b_flat );",12,67,playlist\item.c,RecursiveInsertCopy,,false,46,48,RecursiveInsertCopy,,,3,"int RecursiveInsertCopy (playlist_t*,playlist_item_t*,playlist_item_t*,int,bool)"
163140,METHOD,playlist\item.c:<global>,TYPE_DECL,"static void input_item_add_subitem_tree ( const vlc_event_t * p_event,
                                          void * user_data )
{
    input_item_t *p_input = p_event->p_obj;
    playlist_t *p_playlist = user_data;
    playlist_private_t *p_sys = pl_priv( p_playlist );
    input_item_node_t *p_new_root = p_event->u.input_item_subitem_tree_added.p_root;

    PL_LOCK;

    playlist_item_t *p_item =
        playlist_ItemGetByInput( p_playlist, p_input );

    assert( p_item != NULL );

    bool b_current = get_current_status_item( p_playlist ) == p_item;
    bool b_autostart = var_GetBool( p_playlist, ""playlist-autostart"" );
    bool b_stop = p_item->i_flags & PLAYLIST_SUBITEM_STOP_FLAG;
    bool b_flat = false;

    p_item->i_flags &= ~PLAYLIST_SUBITEM_STOP_FLAG;

    /* We will have to flatten the tree out if we are in ""the playlist"" node and
    the user setting demands flat playlist */

    if( !pl_priv(p_playlist)->b_tree ) {
        playlist_item_t *p_up = p_item;
        whil...",1,32,playlist\item.c,input_item_add_subitem_tree,,false,54,224,input_item_add_subitem_tree,,,4,"void input_item_add_subitem_tree (vlc_event_t*,void*)"
163508,METHOD,playlist\item.c:<global>,TYPE_DECL,"static void input_item_changed( const vlc_event_t * p_event,
                                void * user_data )
{
    playlist_t *p_playlist = user_data;

    var_SetAddress( p_playlist, ""item-change"", p_event->p_obj );
}",1,1,playlist\item.c,input_item_changed,,false,228,234,input_item_changed,,,5,"void input_item_changed (vlc_event_t*,void*)"
163524,METHOD,playlist\item.c:<global>,TYPE_DECL,"static int playlist_ItemCmpId( const void *a, const void *b )
{
    const playlist_item_t *pa = a, *pb = b;

    /* ID are between 1 and INT_MAX, this cannot overflow. */
    return pa->i_id - pb->i_id;
}",1,1,playlist\item.c,playlist_ItemCmpId,,false,236,242,playlist_ItemCmpId,,,6,"int playlist_ItemCmpId (void*,void*)"
163546,METHOD,playlist\item.c:<global>,TYPE_DECL,"static int playlist_ItemCmpInput( const void *a, const void *b )
{
    const playlist_item_t *pa = a, *pb = b;

    if( pa->p_input == pb->p_input )
        return 0;
    return (((uintptr_t)pa->p_input) > ((uintptr_t)pb->p_input))
        ? +1 : -1;
}",1,1,playlist\item.c,playlist_ItemCmpInput,,false,244,252,playlist_ItemCmpInput,,,7,"int playlist_ItemCmpInput (void*,void*)"
163588,METHOD,playlist\item.c:<global>,TYPE_DECL,"playlist_item_t *playlist_ItemNewFromInput( playlist_t *p_playlist,
                                              input_item_t *p_input )
{
    playlist_private_t *p = pl_priv(p_playlist);
    playlist_item_t **pp, *p_item;

    p_item = malloc( sizeof( playlist_item_t ) );
    if( unlikely(p_item == NULL) )
        return NULL;

    assert( p_input );

    p_item->p_input = p_input;
    p_item->i_id = p->i_last_playlist_id;
    p_item->p_parent = NULL;
    p_item->i_children = (p_input->i_type == ITEM_TYPE_NODE) ? 0 : -1;
    p_item->pp_children = NULL;
    p_item->i_nb_played = 0;
    p_item->i_flags = 0;

    PL_ASSERT_LOCKED;

    do  /* Find an unused ID for the item */
    {
        if( unlikely(p_item->i_id == INT_MAX) )
            p_item->i_id = 0;

        p_item->i_id++;

        if( unlikely(p_item->i_id == p->i_last_playlist_id) )
            goto error; /* All IDs taken */

        pp = tsearch( p_item, &p->id_tree, playlist_ItemCmpId );
        if( unlikely(pp == NULL...",1,28,playlist\item.c,playlist_ItemNewFromInput,,false,257,330,playlist_ItemNewFromInput,,,8,"playlist_item_t playlist_ItemNewFromInput (playlist_t*,input_item_t*)"
163823,METHOD,playlist\item.c:<global>,TYPE_DECL,"void playlist_ItemRelease( playlist_t *p_playlist, playlist_item_t *p_item )
{
    playlist_private_t *p = pl_priv(p_playlist);

    PL_ASSERT_LOCKED;

    vlc_event_manager_t *p_em = &p_item->p_input->event_manager;

    vlc_event_detach( p_em, vlc_InputItemSubItemTreeAdded,
                      input_item_add_subitem_tree, p_playlist );
    vlc_event_detach( p_em, vlc_InputItemMetaChanged,
                      input_item_changed, p_playlist );
    vlc_event_detach( p_em, vlc_InputItemDurationChanged,
                      input_item_changed, p_playlist );
    vlc_event_detach( p_em, vlc_InputItemNameChanged,
                      input_item_changed, p_playlist );
    vlc_event_detach( p_em, vlc_InputItemInfoChanged,
                      input_item_changed, p_playlist );
    vlc_event_detach( p_em, vlc_InputItemErrorWhenReadingChanged,
                      input_item_changed, p_playlist );

    input_item_Release( p_item->p_input );

    tdelete( p_item, &p->input_tree, playlis...",1,28,playlist\item.c,playlist_ItemRelease,,false,341,368,playlist_ItemRelease,,,9,"void playlist_ItemRelease (playlist_t*,playlist_item_t*)"
163903,METHOD,playlist\item.c:<global>,TYPE_DECL,"playlist_item_t *playlist_ItemGetById( playlist_t *p_playlist , int id )
{
    playlist_private_t *p = pl_priv(p_playlist);
    playlist_item_t key, **pp;

    PL_ASSERT_LOCKED;
    key.i_id = id;
    pp = tfind( &key, &p->id_tree, playlist_ItemCmpId );
    return (pp != NULL) ? *pp : NULL;
}",1,28,playlist\item.c,playlist_ItemGetById,,false,388,397,playlist_ItemGetById,,,10,"playlist_item_t playlist_ItemGetById (playlist_t*,int)"
163945,METHOD,playlist\item.c:<global>,TYPE_DECL,"playlist_item_t *playlist_ItemGetByInput( playlist_t * p_playlist,
                                          const input_item_t *item )
{
    playlist_private_t *p = pl_priv(p_playlist);
    playlist_item_t key, **pp;

    PL_ASSERT_LOCKED;
    key.p_input = (input_item_t *)item;
    pp = tfind( &key, &p->input_tree, playlist_ItemCmpInput );
    return (pp != NULL) ? *pp : NULL;
}",1,28,playlist\item.c,playlist_ItemGetByInput,,false,411,421,playlist_ItemGetByInput,,,11,"playlist_item_t playlist_ItemGetByInput (playlist_t*,input_item_t*)"
163989,METHOD,playlist\item.c:<global>,TYPE_DECL,"void playlist_Clear( playlist_t * p_playlist, bool b_locked )
{
    playlist_item_t *p_root = p_playlist->p_playing;

    PL_LOCK_IF( !b_locked );

    for( int i = p_root->i_children - 1; i >= 0 ;i-- )
        playlist_NodeDelete( p_playlist, p_root->pp_children[i] );

    PL_UNLOCK_IF( !b_locked );
}",1,4,playlist\item.c,playlist_Clear,,false,430,440,playlist_Clear,,,12,"void playlist_Clear (playlist_t*,bool)"
164039,METHOD,playlist\item.c:<global>,TYPE_DECL,"int playlist_Add( playlist_t *p_playlist, const char *psz_uri, bool play_now )
{
    return playlist_AddExt( p_playlist, psz_uri, NULL, play_now,
                            0, NULL, 0, true );
}",1,1,playlist\item.c,playlist_Add,,false,454,458,playlist_Add,,,13,"int playlist_Add (playlist_t*,char*,bool)"
164056,METHOD,playlist\item.c:<global>,TYPE_DECL,"int playlist_AddExt( playlist_t *p_playlist, const char * psz_uri,
                     const char *psz_name, bool play_now,
                     int i_options, const char *const *ppsz_options,
                     unsigned i_option_flags,
                     bool b_playlist )
{
    input_item_t *p_input = input_item_New( psz_uri, psz_name );
    if( !p_input )
        return VLC_ENOMEM;
    input_item_AddOptions( p_input, i_options, ppsz_options, i_option_flags );
    int i_ret = playlist_AddInput( p_playlist, p_input, play_now, b_playlist );
    input_item_Release( p_input );
    return i_ret;
}",1,1,playlist\item.c,playlist_AddExt,,false,473,486,playlist_AddExt,,,14,"int playlist_AddExt (playlist_t*,char*,char*,bool,int,char**,unsigned,bool)"
164097,METHOD,playlist\item.c:<global>,TYPE_DECL,"int playlist_AddInput( playlist_t* p_playlist, input_item_t *p_input,
                       bool play_now, bool b_playlist )
{
    PL_LOCK;
    playlist_item_t *item = b_playlist ? p_playlist->p_playing
                                       : p_playlist->p_media_library;

    item = playlist_NodeAddInput( p_playlist, p_input, item, PLAYLIST_END );

    if( likely(item != NULL) && play_now )
        playlist_ViewPlay( p_playlist, NULL, item );
    PL_UNLOCK;
    return (item != NULL) ? VLC_SUCCESS : VLC_ENOMEM;
}",1,1,playlist\item.c,playlist_AddInput,,false,497,510,playlist_AddInput,,,15,"int playlist_AddInput (playlist_t*,input_item_t*,bool,bool)"
164144,METHOD,playlist\item.c:<global>,TYPE_DECL,"playlist_item_t * playlist_NodeAddInput( playlist_t *p_playlist,
                                         input_item_t *p_input,
                                         playlist_item_t *p_parent, int i_pos )
{
    PL_ASSERT_LOCKED;

    assert( p_input );
    assert( p_parent && p_parent->i_children != -1 );

    playlist_item_t *p_item = playlist_ItemNewFromInput( p_playlist, p_input );
    if( unlikely(p_item == NULL) )
        return NULL;

    if( p_input->i_type != ITEM_TYPE_NODE )
        ARRAY_APPEND(p_playlist->items, p_item);

    playlist_NodeInsert( p_parent, p_item, i_pos );
    playlist_SendAddNotify( p_playlist, p_item );
    playlist_Preparse( p_playlist, p_item );

    return p_item;
}",1,1,playlist\item.c,playlist_NodeAddInput,,false,523,544,playlist_NodeAddInput,,,16,"playlist_item_t playlist_NodeAddInput (playlist_t*,input_item_t*,playlist_item_t*,int)"
164202,METHOD,playlist\item.c:<global>,TYPE_DECL,"int playlist_NodeAddCopy( playlist_t *p_playlist, playlist_item_t *p_item,
    playlist_item_t *p_parent, int i_pos )
{
    PL_ASSERT_LOCKED;
    assert( p_parent != NULL && p_item != NULL );
    assert( p_parent->i_children > -1 );

    if( i_pos == PLAYLIST_END )
        i_pos = p_parent->i_children;

    bool b_flat = false;

    for( playlist_item_t* p_up = p_parent; p_up; p_up = p_up->p_parent )
    {
        if( p_up == p_playlist->p_playing && !pl_priv(p_playlist)->b_tree )
            b_flat = true;

        if( p_up == p_item )
            /* TODO: We don't support copying a node into itself (yet),
            because we insert items as we copy. Instead, we should copy
            all items first and then insert. */
            return i_pos;
    }

    return RecursiveInsertCopy( p_playlist, p_item, p_parent, i_pos, b_flat );
}",1,46,playlist\item.c,playlist_NodeAddCopy,,false,557,582,playlist_NodeAddCopy,,,17,"int playlist_NodeAddCopy (playlist_t*,playlist_item_t*,playlist_item_t*,int)"
164288,METHOD,playlist\item.c:<global>,TYPE_DECL,"int playlist_InsertInputItemTree (
    playlist_t *p_playlist, playlist_item_t *p_parent,
    input_item_node_t *p_node, int i_pos, bool b_flat )
{
    return RecursiveAddIntoParent( p_playlist, p_parent, p_node, i_pos, b_flat,
                                   &(playlist_item_t*){ NULL } );
}",1,1,playlist\item.c,playlist_InsertInputItemTree,,false,597,603,playlist_InsertInputItemTree,,,18,"int playlist_InsertInputItemTree (playlist_t*,playlist_item_t*,input_item_node_t*,int,bool)"
164309,METHOD,playlist\item.c:<global>,TYPE_DECL,"static int ItemIndex ( playlist_item_t *p_item )
{
    int idx;

    TAB_FIND( p_item->p_parent->i_children,
              p_item->p_parent->pp_children,
              p_item,
              idx );

    return idx;
}",1,1,playlist\item.c,ItemIndex,,false,610,620,ItemIndex,,,19,int ItemIndex (playlist_item_t*)
164330,METHOD,playlist\item.c:<global>,TYPE_DECL,"int playlist_TreeMove( playlist_t * p_playlist, playlist_item_t *p_item,
                       playlist_item_t *p_node, int i_newpos )
{
    PL_ASSERT_LOCKED;

    if( p_node->i_children == -1 ) return VLC_EGENERIC;

    playlist_item_t *p_detach = p_item->p_parent;
    int i_index = ItemIndex( p_item );

    TAB_ERASE(p_detach->i_children, p_detach->pp_children, i_index);

    if( p_detach == p_node && i_index < i_newpos )
        i_newpos--;

    TAB_INSERT(p_node->i_children, p_node->pp_children, p_item, i_newpos);
    p_item->p_parent = p_node;

    pl_priv( p_playlist )->b_reset_currently_playing = true;
    vlc_cond_signal( &pl_priv( p_playlist )->signal );
    return VLC_SUCCESS;
}",1,4,playlist\item.c,playlist_TreeMove,,false,633,654,playlist_TreeMove,,,20,"int playlist_TreeMove (playlist_t*,playlist_item_t*,playlist_item_t*,int)"
164417,METHOD,playlist\item.c:<global>,TYPE_DECL,"int playlist_TreeMoveMany( playlist_t *p_playlist,
                            int i_items, playlist_item_t **pp_items,
                            playlist_item_t *p_node, int i_newpos )
{
    PL_ASSERT_LOCKED;

    if ( p_node->i_children == -1 ) return VLC_EGENERIC;

    for( int i = 0; i < i_items; i++ )
    {
        playlist_item_t *p_item = pp_items[i];
        int i_index = ItemIndex( p_item );
        playlist_item_t *p_parent = p_item->p_parent;
        TAB_ERASE(p_parent->i_children, p_parent->pp_children, i_index);
        if ( p_parent == p_node && i_index < i_newpos ) i_newpos--;
    }
    for( int i = i_items - 1; i >= 0; i-- )
    {
        playlist_item_t *p_item = pp_items[i];
        TAB_INSERT(p_node->i_children, p_node->pp_children, p_item, i_newpos);
        p_item->p_parent = p_node;
    }

    pl_priv( p_playlist )->b_reset_currently_playing = true;
    vlc_cond_signal( &pl_priv( p_playlist )->signal );
    return VLC_SUCCESS;
}",1,4,playlist\item.c,playlist_TreeMoveMany,,false,668,694,playlist_TreeMoveMany,,,21,"int playlist_TreeMoveMany (playlist_t*,int,playlist_item_t**,playlist_item_t*,int)"
164543,METHOD,playlist\item.c:<global>,TYPE_DECL,"void playlist_SendAddNotify( playlist_t *p_playlist, playlist_item_t *item )
{
    playlist_private_t *p_sys = pl_priv(p_playlist);
    PL_ASSERT_LOCKED;

    p_sys->b_reset_currently_playing = true;
    vlc_cond_signal( &p_sys->signal );

    var_SetAddress( p_playlist, ""playlist-item-append"", item );
}",1,32,playlist\item.c,playlist_SendAddNotify,,false,704,713,playlist_SendAddNotify,,,22,"void playlist_SendAddNotify (playlist_t*,playlist_item_t*)"
164574,METHOD,playlist\item.c:<global>,TYPE_DECL,"mtime_t playlist_GetNodeDuration( playlist_item_t* node )
{
    mtime_t duration = input_item_GetDuration( node->p_input );
    if( duration == -1 )
        duration = 0;

    for( int i = 0; i < node->i_children; i++ )
        duration += playlist_GetNodeDuration( node->pp_children[i] );

    return duration;
}",1,1,playlist\item.c,playlist_GetNodeDuration,,false,718,728,playlist_GetNodeDuration,,,23,mtime_t playlist_GetNodeDuration (playlist_item_t*)
164618,METHOD,playlist\item.c:<global>,TYPE_DECL,"static void playlist_Preparse( playlist_t *p_playlist,
                               playlist_item_t *p_item )
{
    playlist_private_t *sys = pl_priv(p_playlist);
    input_item_t *input = p_item->p_input;

    PL_ASSERT_LOCKED;
    /* Preparse if no artist/album info, and hasn't been preparsed already
       and if user has some preparsing option (auto-preparse variable)
       enabled*/
    char *psz_artist = input_item_GetArtist( input );
    char *psz_album = input_item_GetAlbum( input );

    if( sys->b_preparse && !input_item_IsPreparsed( input )
     && (EMPTY_STR(psz_artist) || EMPTY_STR(psz_album)) )
        vlc_MetadataRequest( p_playlist->obj.libvlc, input, 0, -1, p_item );
    free( psz_artist );
    free( psz_album );
}",1,30,playlist\item.c,playlist_Preparse,,false,735,753,playlist_Preparse,,,24,"void playlist_Preparse (playlist_t*,playlist_item_t*)"
164681,METHOD,playlist\item.c:<global>,TYPE_DECL,"static void ChangeToNode( playlist_t *p_playlist, playlist_item_t *p_item )
{
    int i;
    if( p_item->i_children != -1 ) return;

    p_item->i_children = 0;

    input_item_t *p_input = p_item->p_input;
    vlc_mutex_lock( &p_input->lock );
    p_input->i_type = ITEM_TYPE_NODE;
    vlc_mutex_unlock( &p_input->lock );

    var_SetAddress( p_playlist, ""item-change"", p_item->p_input );

    /* Remove it from the array of available items */
    ARRAY_BSEARCH( p_playlist->items,->i_id, int, p_item->i_id, i );
    if( i != -1 )
        ARRAY_REMOVE( p_playlist->items, i );
}",1,1,playlist\item.c,ChangeToNode,,false,756,774,ChangeToNode,,,25,"void ChangeToNode (playlist_t*,playlist_item_t*)"
164741,METHOD,playlist\item.c:<global>,TYPE_DECL,"static int RecursiveAddIntoParent (
    playlist_t *p_playlist, playlist_item_t *p_parent,
    input_item_node_t *p_node, int i_pos, bool b_flat,
    playlist_item_t **pp_first_leaf )
{
    *pp_first_leaf = NULL;

    if( p_parent->i_children == -1 ) ChangeToNode( p_playlist, p_parent );

    if( i_pos == PLAYLIST_END ) i_pos = p_parent->i_children;

    for( int i = 0; i < p_node->i_children; i++ )
    {
        input_item_node_t *p_child_node = p_node->pp_children[i];

        playlist_item_t *p_new_item = NULL;
        bool b_children = p_child_node->i_children > 0;

        //Create the playlist item represented by input node, if allowed.
        if( !(b_flat && b_children) )
        {
            p_new_item = playlist_NodeAddInput( p_playlist,
                                                p_child_node->p_item,
                                                p_parent, i_pos );
            if( !p_new_item ) return i_pos;

            i_pos++;
        }
        //Recurse if any ...",1,1,playlist\item.c,RecursiveAddIntoParent,,false,776,824,RecursiveAddIntoParent,,,26,"int RecursiveAddIntoParent (playlist_t*,playlist_item_t*,input_item_node_t*,int,bool,playlist_item_t**)"
164874,METHOD,playlist\item.c:<global>,TYPE_DECL,"static int RecursiveInsertCopy (
    playlist_t *p_playlist, playlist_item_t *p_item,
    playlist_item_t *p_parent, int i_pos, bool b_flat )
{
    PL_ASSERT_LOCKED;
    assert( p_parent != NULL && p_item != NULL );

    if( p_item == p_parent ) return i_pos;

    input_item_t *p_input = p_item->p_input;

    if( p_item->i_children == -1 || !b_flat )
    {
        playlist_item_t *p_new_item = NULL;

        if( p_item->i_children == -1 )
        {
            input_item_t *p_new_input = input_item_Copy( p_input );

            if( likely(p_new_input != NULL) )
            {
                p_new_item = playlist_NodeAddInput( p_playlist, p_new_input,
                                                    p_parent, i_pos );
                input_item_Release( p_new_input );
            }
        }
        else
        {
            vlc_mutex_lock( &p_input->lock );
            p_new_item = playlist_NodeCreate( p_playlist, p_input->psz_name,
                                              ...",1,1,playlist\item.c,RecursiveInsertCopy,,false,826,879,RecursiveInsertCopy,,,27,"int RecursiveInsertCopy (playlist_t*,playlist_item_t*,playlist_item_t*,int,bool)"
165065,METHOD,playlist\loadsave.c:<global>,TYPE_DECL,<global>,1,24,playlist\loadsave.c,playlist\loadsave.c:<global>,,false,1,221,<global>,,,1,
165067,METHOD,playlist\loadsave.c:<global>,TYPE_DECL,"int playlist_Export( playlist_t * p_playlist, const char *psz_filename,
                     bool b_playlist, const char *psz_type )
{
    playlist_export_t *p_export =
        vlc_custom_create( p_playlist, sizeof( *p_export ), ""playlist export"" );
    if( unlikely(p_export == NULL) )
        return VLC_ENOMEM;

    msg_Dbg( p_export, ""saving %s to file %s"",
             b_playlist ? ""playlist"" : ""media library"", psz_filename );

    int ret = VLC_EGENERIC;

    /* Prepare the playlist_export_t structure */
    p_export->base_url = vlc_path2uri( psz_filename, NULL );
    p_export->p_file = vlc_fopen( psz_filename, ""wt"" );
    if( p_export->p_file == NULL )
    {
        msg_Err( p_export, ""could not create playlist file %s: %s"",
                 psz_filename, vlc_strerror_c(errno) );
        goto out;
    }

    module_t *p_module;

    /* And call the module ! All work is done now */
    playlist_Lock( p_playlist );
    p_export->p_root = b_playlist ? p_playlist->p_playing
       ...",1,1,playlist\loadsave.c,playlist_Export,,false,41,90,playlist_Export,,,1,"int playlist_Export (playlist_t*,char*,bool,char*)"
165199,METHOD,playlist\loadsave.c:<global>,TYPE_DECL,"int playlist_Import( playlist_t *p_playlist, const char *psz_file )
{
    input_item_t *p_input;
    char *psz_uri = vlc_path2uri( psz_file, NULL );

    if( psz_uri == NULL )
        return VLC_EGENERIC;

    p_input = input_item_New( psz_uri, psz_file );
    free( psz_uri );

    playlist_AddInput( p_playlist, p_input, false, true );

    vlc_object_t *dummy = vlc_object_create( p_playlist, sizeof (*dummy) );
    var_Create( dummy, ""meta-file"", VLC_VAR_VOID );

    int ret = input_Read( dummy, p_input );

    vlc_object_release( dummy );
    return ret;
}",1,1,playlist\loadsave.c,playlist_Import,,false,92,112,playlist_Import,,,2,"int playlist_Import (playlist_t*,char*)"
165253,METHOD,playlist\loadsave.c:<global>,TYPE_DECL,"static void input_item_subitem_tree_added( const vlc_event_t * p_event,
                                      void * user_data )
{
    playlist_t *p_playlist = user_data;
    input_item_node_t *p_root =
        p_event->u.input_item_subitem_tree_added.p_root;

    PL_LOCK;
    playlist_InsertInputItemTree ( p_playlist, p_playlist->p_media_library,
                                   p_root, 0, false );
    PL_UNLOCK;
}",1,1,playlist\loadsave.c,input_item_subitem_tree_added,,false,117,128,input_item_subitem_tree_added,,,3,"void input_item_subitem_tree_added (vlc_event_t*,void*)"
165283,METHOD,playlist\loadsave.c:<global>,TYPE_DECL,"int playlist_MLLoad( playlist_t *p_playlist )
{
    char *psz_datadir = config_GetUserDir( VLC_DATA_DIR );
    if( !psz_datadir ) /* XXX: This should never happen */
    {
        msg_Err( p_playlist, ""no data directory, cannot load media library"") ;
        return VLC_EGENERIC;
    }

    char *psz_file;
    if( asprintf( &psz_file, ""%s"" DIR_SEP ""ml.xspf"", psz_datadir ) == -1 )
        psz_file = NULL;
    free( psz_datadir );
    if( psz_file == NULL )
        return VLC_ENOMEM;

    /* lousy check for media library file */
    struct stat st;
    if( vlc_stat( psz_file, &st ) )
    {
        free( psz_file );
        return VLC_EGENERIC;
    }

    char *psz_uri = vlc_path2uri( psz_file, ""file/directory"" );
    free( psz_file );
    if( psz_uri == NULL )
        return VLC_ENOMEM;

    input_item_t *p_input = input_item_New( psz_uri, _(""Media Library"") );
    free( psz_uri );
    if( p_input == NULL )
        return VLC_EGENERIC;

    vlc_event_attach( &p_input->event_manager, vl...",1,1,playlist\loadsave.c,playlist_MLLoad,,false,130,177,playlist_MLLoad,,,4,int playlist_MLLoad (playlist_t*)
165397,METHOD,playlist\loadsave.c:<global>,TYPE_DECL,"int playlist_MLDump( playlist_t *p_playlist )
{
    char *psz_temp;

    psz_temp = config_GetUserDir( VLC_DATA_DIR );

    if( !psz_temp ) /* XXX: This should never happen */
    {
        msg_Err( p_playlist, ""no data directory, cannot save media library"") ;
        return VLC_EGENERIC;
    }

    char psz_dirname[ strlen( psz_temp ) + sizeof( DIR_SEP ""ml.xspf"")];
    strcpy( psz_dirname, psz_temp );
    free( psz_temp );
    if( config_CreateDir( (vlc_object_t *)p_playlist, psz_dirname ) )
    {
        return VLC_EGENERIC;
    }

    strcat( psz_dirname, DIR_SEP ""ml.xspf"" );

    if ( asprintf( &psz_temp, ""%s.tmp%""PRIu32, psz_dirname, (uint32_t)getpid() ) < 1 )
        return VLC_EGENERIC;

    int i_ret = playlist_Export( p_playlist, psz_temp, false, ""export-xspf"" );
    if ( i_ret != VLC_SUCCESS )
    {
        vlc_unlink( psz_temp );
        free( psz_temp );
        return i_ret;
    }

    i_ret = vlc_rename( psz_temp, psz_dirname );
    free( psz_temp );
    if( i_ret == -...",1,1,playlist\loadsave.c,playlist_MLDump,,false,179,221,playlist_MLDump,,,5,int playlist_MLDump (playlist_t*)
165490,METHOD,playlist\playlist_internal.h:<global>,TYPE_DECL,<global>,1,1,playlist\playlist_internal.h,playlist\playlist_internal.h:<global>,,false,1,195,<global>,,,1,
165494,METHOD,playlist\playlist_internal.h:<global>,TYPE_DECL,void playlist_ServicesDiscoveryKillAll( playlist_t *p_playlist );,6,64,playlist\playlist_internal.h,playlist_ServicesDiscoveryKillAll,,false,45,45,playlist_ServicesDiscoveryKillAll,,,3,void playlist_ServicesDiscoveryKillAll (playlist_t*)
165532,METHOD,playlist\playlist_internal.h:<global>,TYPE_DECL,playlist_t *playlist_Create( vlc_object_t * );,12,45,playlist\playlist_internal.h,playlist_Create,,false,103,103,playlist_Create,,,6,playlist_t* playlist_Create (vlc_object_t*)
165537,METHOD,playlist\playlist_internal.h:<global>,TYPE_DECL,void playlist_Destroy( playlist_t * );,6,37,playlist\playlist_internal.h,playlist_Destroy,,false,104,104,playlist_Destroy,,,7,void playlist_Destroy (playlist_t*)
165542,METHOD,playlist\playlist_internal.h:<global>,TYPE_DECL,void playlist_Activate( playlist_t * );,6,38,playlist\playlist_internal.h,playlist_Activate,,false,105,105,playlist_Activate,,,8,void playlist_Activate (playlist_t*)
165547,METHOD,playlist\playlist_internal.h:<global>,TYPE_DECL,"playlist_item_t *playlist_ItemNewFromInput( playlist_t *p_playlist,
                                            input_item_t *p_input );",17,67,playlist\playlist_internal.h,playlist_ItemNewFromInput,,false,108,109,playlist_ItemNewFromInput,,,9,"playlist_item_t* playlist_ItemNewFromInput (playlist_t*,input_item_t*)"
165553,METHOD,playlist\playlist_internal.h:<global>,TYPE_DECL,playlist_item_t * get_current_status_item( playlist_t * p_playlist);,17,67,playlist\playlist_internal.h,get_current_status_item,,false,112,112,get_current_status_item,,,10,playlist_item_t* get_current_status_item (playlist_t*)
165558,METHOD,playlist\playlist_internal.h:<global>,TYPE_DECL,playlist_item_t * get_current_status_node( playlist_t * p_playlist );,17,68,playlist\playlist_internal.h,get_current_status_node,,false,113,113,get_current_status_node,,,11,playlist_item_t* get_current_status_node (playlist_t*)
165563,METHOD,playlist\playlist_internal.h:<global>,TYPE_DECL,"void set_current_status_item( playlist_t *, playlist_item_t * );",6,63,playlist\playlist_internal.h,set_current_status_item,,false,114,114,set_current_status_item,,,12,"void set_current_status_item (playlist_t*,playlist_item_t*)"
165569,METHOD,playlist\playlist_internal.h:<global>,TYPE_DECL,"void set_current_status_node( playlist_t *, playlist_item_t * );",6,63,playlist\playlist_internal.h,set_current_status_node,,false,115,115,set_current_status_node,,,13,"void set_current_status_node (playlist_t*,playlist_item_t*)"
165575,METHOD,playlist\playlist_internal.h:<global>,TYPE_DECL,int playlist_MLLoad( playlist_t *p_playlist );,5,45,playlist\playlist_internal.h,playlist_MLLoad,,false,118,118,playlist_MLLoad,,,14,int playlist_MLLoad (playlist_t*)
165580,METHOD,playlist\playlist_internal.h:<global>,TYPE_DECL,int playlist_MLDump( playlist_t *p_playlist );,5,45,playlist\playlist_internal.h,playlist_MLDump,,false,119,119,playlist_MLDump,,,15,int playlist_MLDump (playlist_t*)
165585,METHOD,playlist\playlist_internal.h:<global>,TYPE_DECL,"void playlist_SendAddNotify( playlist_t *p_playlist, playlist_item_t *item );",6,76,playlist\playlist_internal.h,playlist_SendAddNotify,,false,125,125,playlist_SendAddNotify,,,16,"void playlist_SendAddNotify (playlist_t*,playlist_item_t*)"
165591,METHOD,playlist\playlist_internal.h:<global>,TYPE_DECL,"int playlist_InsertInputItemTree ( playlist_t *,
        playlist_item_t *, input_item_node_t *, int, bool );",5,59,playlist\playlist_internal.h,playlist_InsertInputItemTree,,false,127,128,playlist_InsertInputItemTree,,,17,"int playlist_InsertInputItemTree (playlist_t*,playlist_item_t*,input_item_node_t*,int,ANY)"
165600,METHOD,playlist\playlist_internal.h:<global>,TYPE_DECL,"int playlist_NodeInsert(playlist_item_t*, playlist_item_t *, int);",5,65,playlist\playlist_internal.h,playlist_NodeInsert,,false,131,131,playlist_NodeInsert,,,18,"int playlist_NodeInsert (playlist_item_t*,playlist_item_t*,int)"
165607,METHOD,playlist\playlist_internal.h:<global>,TYPE_DECL,"void playlist_NodeDeleteExplicit(playlist_t*, playlist_item_t*,
    int flags);",6,14,playlist\playlist_internal.h,playlist_NodeDeleteExplicit,,false,154,155,playlist_NodeDeleteExplicit,,,19,"void playlist_NodeDeleteExplicit (playlist_t*,playlist_item_t*,int)"
165614,METHOD,playlist\playlist_internal.h:<global>,TYPE_DECL,"void playlist_ItemRelease( playlist_t *, playlist_item_t * );",6,60,playlist\playlist_internal.h,playlist_ItemRelease,,false,157,157,playlist_ItemRelease,,,20,"void playlist_ItemRelease (playlist_t*,playlist_item_t*)"
165620,METHOD,playlist\playlist_internal.h:<global>,TYPE_DECL,"void ResetCurrentlyPlaying( playlist_t *p_playlist, playlist_item_t *p_cur );",6,76,playlist\playlist_internal.h,ResetCurrentlyPlaying,,false,159,159,ResetCurrentlyPlaying,,,21,"void ResetCurrentlyPlaying (playlist_t*,playlist_item_t*)"
165626,METHOD,playlist\playlist_internal.h:<global>,TYPE_DECL,"void ResyncCurrentIndex( playlist_t *p_playlist, playlist_item_t *p_cur );",6,73,playlist\playlist_internal.h,ResyncCurrentIndex,,false,160,160,ResyncCurrentIndex,,,22,"void ResyncCurrentIndex (playlist_t*,playlist_item_t*)"
165632,METHOD,playlist\playlist_internal.h:<global>,TYPE_DECL,"playlist_item_t * playlist_GetNextLeaf( playlist_t *, playlist_item_t *p_root,
    playlist_item_t *p_item, bool b_ena, bool b_unplayed )",17,58,playlist\playlist_internal.h,playlist_GetNextLeaf,,false,162,163,playlist_GetNextLeaf,,,23,"playlist_item_t* playlist_GetNextLeaf (playlist_t*,playlist_item_t*,playlist_item_t*,bool,bool)"
165643,METHOD,playlist\playlist_internal.h:<global>,TYPE_DECL,"static inline void pl_lock_if( playlist_t * p_playlist, bool cond )
{
    if( cond ) PL_LOCK; else PL_ASSERT_LOCKED;
}",1,1,playlist\playlist_internal.h,pl_lock_if,,false,183,186,pl_lock_if,,,26,"void pl_lock_if (playlist_t*,bool)"
165656,METHOD,playlist\playlist_internal.h:<global>,TYPE_DECL,"static inline void pl_unlock_if( playlist_t * p_playlist, bool cond )
{
    if( cond ) PL_UNLOCK;
}",1,1,playlist\playlist_internal.h,pl_unlock_if,,false,189,192,pl_unlock_if,,,27,"void pl_unlock_if (playlist_t*,bool)"
165683,METHOD,playlist\preparser.c:<global>,TYPE_DECL,<global>,1,1,playlist\preparser.c,playlist\preparser.c:<global>,,false,1,208,<global>,,,1,
165691,METHOD,playlist\preparser.c:<global>,TYPE_DECL,"static int InputEvent( vlc_object_t* obj, const char* varname,
    vlc_value_t old, vlc_value_t cur, void* worker )
{
    VLC_UNUSED( obj ); VLC_UNUSED( varname ); VLC_UNUSED( old );

    if( cur.i_int == INPUT_EVENT_DEAD )
        background_worker_RequestProbe( worker );

    return VLC_SUCCESS;
}",1,1,playlist\preparser.c,InputEvent,,false,42,51,InputEvent,,,2,"int InputEvent (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
165717,METHOD,playlist\preparser.c:<global>,TYPE_DECL,"static int PreparserOpenInput( void* preparser_, void* item_, void** out )
{
    playlist_preparser_t* preparser = preparser_;

    input_thread_t* input = input_CreatePreparser( preparser->owner, item_ );
    if( !input )
    {
        input_item_SignalPreparseEnded( item_, ITEM_PREPARSE_FAILED );
        return VLC_EGENERIC;
    }

    var_AddCallback( input, ""intf-event"", InputEvent, preparser->worker );
    if( input_Start( input ) )
    {
        var_DelCallback( input, ""intf-event"", InputEvent, preparser->worker );
        input_Close( input );
        input_item_SignalPreparseEnded( item_, ITEM_PREPARSE_FAILED );
        return VLC_EGENERIC;
    }

    *out = input;
    return VLC_SUCCESS;
}",1,1,playlist\preparser.c,PreparserOpenInput,,false,53,75,PreparserOpenInput,,,3,"int PreparserOpenInput (void*,void*,void**)"
165776,METHOD,playlist\preparser.c:<global>,TYPE_DECL,"static int PreparserProbeInput( void* preparser_, void* input_ )
{
    int state = input_GetState( input_ );
    return state == END_S || state == ERROR_S;
    VLC_UNUSED( preparser_ );
}",1,1,playlist\preparser.c,PreparserProbeInput,,false,77,82,PreparserProbeInput,,,4,"int PreparserProbeInput (void*,void*)"
165797,METHOD,playlist\preparser.c:<global>,TYPE_DECL,"static void PreparserCloseInput( void* preparser_, void* input_ )
{
    playlist_preparser_t* preparser = preparser_;
    input_thread_t* input = input_;
    input_item_t* item = input_priv(input)->p_item;

    var_DelCallback( input, ""intf-event"", InputEvent, preparser->worker );

    int status;
    switch( input_GetState( input ) )
    {
        case END_S:
            status = ITEM_PREPARSE_DONE;
            break;
        case ERROR_S:
            status = ITEM_PREPARSE_FAILED;
            break;
        default:
            status = ITEM_PREPARSE_TIMEOUT;
    }

    input_Stop( input );
    input_Close( input );

    if( preparser->fetcher )
    {
        if( !playlist_fetcher_Push( preparser->fetcher, item, 0, status ) )
            return;
    }

    input_item_SetPreparsed( item, true );
    input_item_SignalPreparseEnded( item, status );
}",1,1,playlist\preparser.c,PreparserCloseInput,,false,84,116,PreparserCloseInput,,,5,"void PreparserCloseInput (void*,void*)"
165872,METHOD,playlist\preparser.c:<global>,TYPE_DECL,static void InputItemRelease( void* item ) { input_item_Release( item ); },1,74,playlist\preparser.c,InputItemRelease,,false,118,118,InputItemRelease,,,6,void InputItemRelease (void*)
165879,METHOD,playlist\preparser.c:<global>,TYPE_DECL,static void InputItemHold( void* item ) { input_item_Hold( item ); },1,68,playlist\preparser.c,InputItemHold,,false,119,119,InputItemHold,,,7,void InputItemHold (void*)
165886,METHOD,playlist\preparser.c:<global>,TYPE_DECL,"playlist_preparser_t* playlist_preparser_New( vlc_object_t *parent )
{
    playlist_preparser_t* preparser = malloc( sizeof *preparser );

    struct background_worker_config conf = {
        .default_timeout = var_InheritInteger( parent, ""preparse-timeout"" ),
        .pf_start = PreparserOpenInput,
        .pf_probe = PreparserProbeInput,
        .pf_stop = PreparserCloseInput,
        .pf_release = InputItemRelease,
        .pf_hold = InputItemHold };


    if( likely( preparser ) )
        preparser->worker = background_worker_New( preparser, &conf );

    if( unlikely( !preparser || !preparser->worker ) )
    {
        free( preparser );
        return NULL;
    }

    preparser->owner = parent;
    preparser->fetcher = playlist_fetcher_New( parent );
    atomic_init( &preparser->deactivated, false );

    if( unlikely( !preparser->fetcher ) )
        msg_Warn( parent, ""unable to create art fetcher"" );

    return preparser;
}",1,1,playlist\preparser.c,playlist_preparser_New,,false,121,151,playlist_preparser_New,,,8,playlist_preparser_t playlist_preparser_New (vlc_object_t*)
165983,METHOD,playlist\preparser.c:<global>,TYPE_DECL,"void playlist_preparser_Push( playlist_preparser_t *preparser,
    input_item_t *item, input_item_meta_request_option_t i_options,
    int timeout, void *id )
{
    if( atomic_load( &preparser->deactivated ) )
        return;

    vlc_mutex_lock( &item->lock );
    int i_type = item->i_type;
    int b_net = item->b_net;
    vlc_mutex_unlock( &item->lock );

    switch( i_type )
    {
        case ITEM_TYPE_NODE:
        case ITEM_TYPE_FILE:
        case ITEM_TYPE_DIRECTORY:
        case ITEM_TYPE_PLAYLIST:
            if( !b_net || i_options & META_REQUEST_OPTION_SCOPE_NETWORK )
                break;
        default:
            input_item_SignalPreparseEnded( item, ITEM_PREPARSE_SKIPPED );
            return;
    }

    if( background_worker_Push( preparser->worker, item, id, timeout ) )
        input_item_SignalPreparseEnded( item, ITEM_PREPARSE_FAILED );
}",1,1,playlist\preparser.c,playlist_preparser_Push,,false,153,180,playlist_preparser_Push,,,9,"void playlist_preparser_Push (playlist_preparser_t*,input_item_t*,input_item_meta_request_option_t,int,void*)"
166059,METHOD,playlist\preparser.c:<global>,TYPE_DECL,"void playlist_preparser_fetcher_Push( playlist_preparser_t *preparser,
    input_item_t *item, input_item_meta_request_option_t options )
{
    if( preparser->fetcher )
        playlist_fetcher_Push( preparser->fetcher, item, options, -1 );
}",1,1,playlist\preparser.c,playlist_preparser_fetcher_Push,,false,182,187,playlist_preparser_fetcher_Push,,,10,"void playlist_preparser_fetcher_Push (playlist_preparser_t*,input_item_t*,input_item_meta_request_option_t)"
166079,METHOD,playlist\preparser.c:<global>,TYPE_DECL,"void playlist_preparser_Cancel( playlist_preparser_t *preparser, void *id )
{
    background_worker_Cancel( preparser->worker, id );
}",1,1,playlist\preparser.c,playlist_preparser_Cancel,,false,189,192,playlist_preparser_Cancel,,,11,"void playlist_preparser_Cancel (playlist_preparser_t*,void*)"
166090,METHOD,playlist\preparser.c:<global>,TYPE_DECL,"void playlist_preparser_Deactivate( playlist_preparser_t* preparser )
{
    atomic_store( &preparser->deactivated, true );
    background_worker_Cancel( preparser->worker, NULL );
}",1,1,playlist\preparser.c,playlist_preparser_Deactivate,,false,194,198,playlist_preparser_Deactivate,,,12,void playlist_preparser_Deactivate (playlist_preparser_t*)
166106,METHOD,playlist\preparser.c:<global>,TYPE_DECL,"void playlist_preparser_Delete( playlist_preparser_t *preparser )
{
    background_worker_Delete( preparser->worker );

    if( preparser->fetcher )
        playlist_fetcher_Delete( preparser->fetcher );

    free( preparser );
}",1,1,playlist\preparser.c,playlist_preparser_Delete,,false,200,208,playlist_preparser_Delete,,,13,void playlist_preparser_Delete (playlist_preparser_t*)
166131,METHOD,playlist\preparser.h:<global>,TYPE_DECL,<global>,1,7,playlist\preparser.h,playlist\preparser.h:<global>,,false,1,86,<global>,,,1,
166135,METHOD,playlist\preparser.h:<global>,TYPE_DECL,playlist_preparser_t *playlist_preparser_New( vlc_object_t * );,22,62,playlist\preparser.h,playlist_preparser_New,,false,41,41,playlist_preparser_New,,,3,playlist_preparser_t* playlist_preparser_New (vlc_object_t*)
166140,METHOD,playlist\preparser.h:<global>,TYPE_DECL,"void playlist_preparser_Push( playlist_preparser_t *, input_item_t *,
                              input_item_meta_request_option_t,
                              int timeout, void *id );",6,53,playlist\preparser.h,playlist_preparser_Push,,false,57,59,playlist_preparser_Push,,,4,"void playlist_preparser_Push (playlist_preparser_t*,input_item_t*,ANY,int,void*)"
166149,METHOD,playlist\preparser.h:<global>,TYPE_DECL,"void playlist_preparser_fetcher_Push( playlist_preparser_t *, input_item_t *,
                                      input_item_meta_request_option_t );",6,72,playlist\preparser.h,playlist_preparser_fetcher_Push,,false,61,62,playlist_preparser_fetcher_Push,,,5,"void playlist_preparser_fetcher_Push (playlist_preparser_t*,input_item_t*,ANY)"
166156,METHOD,playlist\preparser.h:<global>,TYPE_DECL,"void playlist_preparser_Cancel( playlist_preparser_t *, void *id );",6,66,playlist\preparser.h,playlist_preparser_Cancel,,false,69,69,playlist_preparser_Cancel,,,6,"void playlist_preparser_Cancel (playlist_preparser_t*,void*)"
166162,METHOD,playlist\preparser.h:<global>,TYPE_DECL,void playlist_preparser_Delete( playlist_preparser_t * );,6,56,playlist\preparser.h,playlist_preparser_Delete,,false,76,76,playlist_preparser_Delete,,,7,void playlist_preparser_Delete (playlist_preparser_t*)
166167,METHOD,playlist\preparser.h:<global>,TYPE_DECL,void playlist_preparser_Deactivate( playlist_preparser_t * );,6,60,playlist\preparser.h,playlist_preparser_Deactivate,,false,84,84,playlist_preparser_Deactivate,,,8,void playlist_preparser_Deactivate (playlist_preparser_t*)
166185,METHOD,playlist\renderer.c:<global>,TYPE_DECL,<global>,1,1,playlist\renderer.c,playlist\renderer.c:<global>,,false,1,51,<global>,,,1,
166187,METHOD,playlist\renderer.c:<global>,TYPE_DECL,"int playlist_SetRenderer( playlist_t* p_playlist, vlc_renderer_item_t* p_item )
{
    if( p_item )
        vlc_renderer_item_hold( p_item );

    PL_LOCK;

    playlist_private_t *p_priv = pl_priv( p_playlist );
    vlc_renderer_item_t *p_prev_renderer = p_priv->p_renderer;
    p_priv->p_renderer = p_item;
    if( p_priv->p_input )
        input_Control( p_priv->p_input, INPUT_SET_RENDERER, p_item );

    PL_UNLOCK;

    if( p_prev_renderer )
        vlc_renderer_item_release( p_prev_renderer );
    return VLC_SUCCESS;
}",1,33,playlist\renderer.c,playlist_SetRenderer,,false,33,51,playlist_SetRenderer,,,1,"int playlist_SetRenderer (playlist_t*,vlc_renderer_item_t*)"
166254,METHOD,playlist\search.c:<global>,TYPE_DECL,<global>,1,25,playlist\search.c,playlist\search.c:<global>,,false,1,130,<global>,,,1,
166256,METHOD,playlist\search.c:<global>,TYPE_DECL,"static void playlist_LiveSearchClean( playlist_item_t *p_root )
{
    for( int i = 0; i < p_root->i_children; i++ )
    {
        playlist_item_t *p_item = p_root->pp_children[i];
        if( p_item->i_children >= 0 )
            playlist_LiveSearchClean( p_item );
        p_item->i_flags &= ~PLAYLIST_DBL_FLAG;
    }
}",1,1,playlist\search.c,playlist_LiveSearchClean,,false,45,54,playlist_LiveSearchClean,,,1,void playlist_LiveSearchClean (playlist_item_t*)
166298,METHOD,playlist\search.c:<global>,TYPE_DECL,"static bool playlist_LiveSearchUpdateInternal( playlist_item_t *p_root,
                                               const char *psz_string, bool b_recursive )
{
    int i;
    bool b_match = false;
    for( i = 0 ; i < p_root->i_children ; i ++ )
    {
        bool b_enable = false;
        playlist_item_t *p_item = p_root->pp_children[i];
        // Go recurssively if their is some children
        if( b_recursive && p_item->i_children >= 0 &&
            playlist_LiveSearchUpdateInternal( p_item, psz_string, true ) )
        {
            b_enable = true;
        }

        if( !b_enable )
        {
            vlc_mutex_lock( &p_item->p_input->lock );
            // Do we have some meta ?
            if( p_item->p_input->p_meta )
            {
                // Use Title or fall back to psz_name
                const char *psz_title = vlc_meta_Get( p_item->p_input->p_meta, vlc_meta_Title );
                if( !psz_title )
                    psz_title = p_item->p_input->psz_...",1,1,playlist\search.c,playlist_LiveSearchUpdateInternal,,false,63,108,playlist_LiveSearchUpdateInternal,,,2,"bool playlist_LiveSearchUpdateInternal (playlist_item_t*,char*,bool)"
166475,METHOD,playlist\search.c:<global>,TYPE_DECL,"int playlist_LiveSearchUpdate( playlist_t *p_playlist, playlist_item_t *p_root,
                               const char *psz_string, bool b_recursive )
{
    PL_ASSERT_LOCKED;
    pl_priv(p_playlist)->b_reset_currently_playing = true;
    if( *psz_string )
        playlist_LiveSearchUpdateInternal( p_root, psz_string, b_recursive );
    else
        playlist_LiveSearchClean( p_root );
    vlc_cond_signal( &pl_priv(p_playlist)->signal );
    return VLC_SUCCESS;
}",1,4,playlist\search.c,playlist_LiveSearchUpdate,,false,119,130,playlist_LiveSearchUpdate,,,3,"int playlist_LiveSearchUpdate (playlist_t*,playlist_item_t*,char*,bool)"
166535,METHOD,playlist\services_discovery.c:<global>,TYPE_DECL,<global>,1,36,playlist\services_discovery.c,playlist\services_discovery.c:<global>,,false,1,261,<global>,,,1,
166541,METHOD,<empty>,<empty>,<empty>,1,,playlist\services_discovery.c,vlc_sd_internal_t:<clinit>,,false,33,,<clinit>,,,4,
166546,METHOD,playlist\services_discovery.c:<global>,TYPE_DECL,"static void playlist_sd_item_added(services_discovery_t *sd,
                                   input_item_t *parent, input_item_t *p_input,
                                   const char *psz_cat)
{
    assert(parent == NULL || psz_cat == NULL);

    vlc_sd_internal_t *sds = sd->owner.sys;
    playlist_t *playlist = (playlist_t *)sd->obj.parent;
    playlist_item_t *node;
    const char *longname = (sd->description != NULL) ? sd->description : ""?"";

    msg_Dbg(sd, ""adding: %s"", p_input->psz_name ? p_input->psz_name : ""(null)"");

    playlist_Lock(playlist);
    if (sds->node == NULL)
        sds->node = playlist_NodeCreate(playlist, longname, &playlist->root,
                                        PLAYLIST_END, PLAYLIST_RO_FLAG);

    if (parent != NULL)
        node = playlist_ItemGetByInput(playlist, parent);
    else
    if (psz_cat == NULL)
        node = sds->node;
    else
    {   /* Parent is NULL (root) and category is specified.
         * This is clearly a hack. TODO: re...",1,1,playlist\services_discovery.c,playlist_sd_item_added,,false,42,76,playlist_sd_item_added,,,2,"void playlist_sd_item_added (services_discovery_t*,input_item_t*,input_item_t*,char*)"
166680,METHOD,playlist\services_discovery.c:<global>,TYPE_DECL,"static void playlist_sd_item_removed(services_discovery_t *sd,
                                     input_item_t *p_input)
{
    vlc_sd_internal_t *sds = sd->owner.sys;
    playlist_t *playlist = (playlist_t *)sd->obj.parent;
    playlist_item_t *node, *item;

    msg_Dbg(sd, ""removing: %s"", p_input->psz_name ? p_input->psz_name : ""(null)"");

    playlist_Lock(playlist);
    item = playlist_ItemGetByInput(playlist, p_input);
    if (unlikely(item == NULL))
    {
        msg_Err(sd, ""removing item not added""); /* SD plugin bug */
        playlist_Unlock(playlist);
        return;
    }

#ifndef NDEBUG
    /* Check that the item belonged to the SD */
    for (playlist_item_t *i = item->p_parent; i != sds->node; i = i->p_parent)
        assert(i != NULL);
#endif

    node = item->p_parent;
    /* if the item was added under a category and the category node
       becomes empty, delete that node as well */
    if (node != sds->node && node->i_children == 1)
        item = node;
    play...",1,8,playlist\services_discovery.c,playlist_sd_item_removed,,false,79,111,playlist_sd_item_removed,,,3,"void playlist_sd_item_removed (services_discovery_t*,input_item_t*)"
166791,METHOD,playlist\services_discovery.c:<global>,TYPE_DECL,"int playlist_ServicesDiscoveryAdd(playlist_t *playlist, const char *chain)
{
    vlc_sd_internal_t *sds = malloc(sizeof (*sds) + strlen(chain) + 1);
    if (unlikely(sds == NULL))
        return VLC_ENOMEM;

    sds->node = NULL;

    struct services_discovery_owner_t owner = {
        sds,
        playlist_sd_item_added,
        playlist_sd_item_removed,
    };

    /* Perform the addition */
    sds->sd = vlc_sd_Create(VLC_OBJECT(playlist), chain, &owner);
    if (unlikely(sds->sd == NULL))
    {
        free(sds);
        return VLC_ENOMEM;
    }

    strcpy(sds->name, chain);

    playlist_Lock(playlist);
    /* Backward compatibility with Qt UI: create the node even if the SD
     * has not discovered any item. */
    if (sds->node == NULL && sds->sd->description != NULL)
        sds->node = playlist_NodeCreate(playlist, sds->sd->description,
                                        &playlist->root, PLAYLIST_END,
                                        PLAYLIST_RO_FLAG);

    TA...",1,15,playlist\services_discovery.c,playlist_ServicesDiscoveryAdd,,false,113,148,playlist_ServicesDiscoveryAdd,,,4,"int playlist_ServicesDiscoveryAdd (playlist_t*,char*)"
166914,METHOD,playlist\services_discovery.c:<global>,TYPE_DECL,"static void playlist_ServicesDiscoveryInternalRemoveLocked(playlist_t *playlist,
                                                           vlc_sd_internal_t *sds)
{
    assert(sds->sd != NULL);

    playlist_Unlock(playlist);

    vlc_sd_Destroy(sds->sd);
    /* Remove the sd playlist node if it exists */
    playlist_Lock(playlist);

    if (sds->node != NULL)
        playlist_NodeDeleteExplicit(playlist, sds->node,
            PLAYLIST_DELETE_FORCE | PLAYLIST_DELETE_STOP_IF_CURRENT );

    free(sds);
}",1,12,playlist\services_discovery.c,playlist_ServicesDiscoveryInternalRemoveLocked,,false,150,166,playlist_ServicesDiscoveryInternalRemoveLocked,,,5,"void playlist_ServicesDiscoveryInternalRemoveLocked (playlist_t*,vlc_sd_internal_t*)"
166955,METHOD,playlist\services_discovery.c:<global>,TYPE_DECL,"int playlist_ServicesDiscoveryRemove(playlist_t *playlist, const char *name)
{
    playlist_private_t *priv = pl_priv(playlist);
    vlc_sd_internal_t *sds = NULL;

    playlist_Lock(playlist);
    for (int i = 0; i < priv->i_sds; i++)
    {
        vlc_sd_internal_t *entry = priv->pp_sds[i];

        if (!strcmp(name, entry->name))
        {
            TAB_ERASE(priv->i_sds, priv->pp_sds, i);
            sds = entry;
            break;
        }
    }

    if (sds == NULL)
    {
        msg_Warn(playlist, ""discovery %s is not loaded"", name);
        playlist_Unlock(playlist);
        return VLC_EGENERIC;
    }

    playlist_ServicesDiscoveryInternalRemoveLocked(playlist, sds);

    playlist_Unlock(playlist);

    return VLC_SUCCESS;
}",1,31,playlist\services_discovery.c,playlist_ServicesDiscoveryRemove,,false,168,198,playlist_ServicesDiscoveryRemove,,,6,"int playlist_ServicesDiscoveryRemove (playlist_t*,char*)"
167039,METHOD,playlist\services_discovery.c:<global>,TYPE_DECL,"bool playlist_IsServicesDiscoveryLoaded( playlist_t * playlist,
                                         const char *psz_name )
{
    playlist_private_t *priv = pl_priv( playlist );
    bool found = false;
    playlist_Lock(playlist);

    for( int i = 0; i < priv->i_sds; i++ )
    {
        vlc_sd_internal_t *sds = priv->pp_sds[i];

        if (!strcmp(psz_name, sds->name))
        {
            found = true;
            break;
        }
    }
    playlist_Unlock(playlist);
    return found;
}",1,31,playlist\services_discovery.c,playlist_IsServicesDiscoveryLoaded,,false,200,219,playlist_IsServicesDiscoveryLoaded,,,7,"bool playlist_IsServicesDiscoveryLoaded (playlist_t*,char*)"
167099,METHOD,playlist\services_discovery.c:<global>,TYPE_DECL,"int playlist_ServicesDiscoveryControl( playlist_t *playlist, const char *psz_name, int i_control, ... )
{
    playlist_private_t *priv = pl_priv( playlist );
    int i_ret = VLC_EGENERIC;
    int i;

    playlist_Lock(playlist);
    for( i = 0; i < priv->i_sds; i++ )
    {
        vlc_sd_internal_t *sds = priv->pp_sds[i];
        if (!strcmp(psz_name, sds->name))
        {
            va_list args;
            va_start( args, i_control );
            i_ret = vlc_sd_control(sds->sd, i_control, args );
            va_end( args );
            break;
        }
    }

    assert( i != priv->i_sds );
    playlist_Unlock(playlist);

    return i_ret;
}",1,31,playlist\services_discovery.c,playlist_ServicesDiscoveryControl,,false,221,245,playlist_ServicesDiscoveryControl,,,8,"int playlist_ServicesDiscoveryControl (playlist_t*,char*,int...)"
167177,METHOD,playlist\services_discovery.c:<global>,TYPE_DECL,"void playlist_ServicesDiscoveryKillAll(playlist_t *playlist)
{
    playlist_private_t *priv = pl_priv(playlist);

    playlist_Lock(playlist);
    while (priv->i_sds > 0)
    {
        vlc_sd_internal_t *sds = priv->pp_sds[priv->i_sds - 1];
        TAB_ERASE(priv->i_sds, priv->pp_sds, priv->i_sds - 1);

        playlist_ServicesDiscoveryInternalRemoveLocked(playlist, sds);
    }

    playlist_Unlock(playlist);
}",1,31,playlist\services_discovery.c,playlist_ServicesDiscoveryKillAll,,false,247,261,playlist_ServicesDiscoveryKillAll,,,9,void playlist_ServicesDiscoveryKillAll (playlist_t*)
167243,METHOD,playlist\sort.c:<global>,TYPE_DECL,<global>,1,26,playlist\sort.c,playlist\sort.c:<global>,,false,1,377,<global>,,,1,
167245,METHOD,playlist\sort.c:<global>,TYPE_DECL,"static inline int meta_strcasecmp_title( const playlist_item_t *first,
                              const playlist_item_t *second )
{
    int i_ret;
    char *psz_first = input_item_GetTitleFbName( first->p_input );
    char *psz_second = input_item_GetTitleFbName( second->p_input );

    if( psz_first && psz_second )
        i_ret = strcasecmp( psz_first, psz_second );
    else if( !psz_first && psz_second )
        i_ret = 1;
    else if( psz_first && !psz_second )
        i_ret = -1;
    else
        i_ret = 0;
    free( psz_first );
    free( psz_second );

    return i_ret;
}",1,1,playlist\sort.c,meta_strcasecmp_title,,false,43,62,meta_strcasecmp_title,,,1,"int meta_strcasecmp_title (playlist_item_t*,playlist_item_t*)"
167310,METHOD,playlist\sort.c:<global>,TYPE_DECL,"static inline int meta_sort( const playlist_item_t *first,
                             const playlist_item_t *second,
                             vlc_meta_type_t meta, bool b_integer )
{
    int i_ret;
    char *psz_first = input_item_GetMeta( first->p_input, meta );
    char *psz_second = input_item_GetMeta( second->p_input, meta );

    /* Nodes go first */
    if( first->i_children == -1 && second->i_children >= 0 )
        i_ret = 1;
    else if( first->i_children >= 0 && second->i_children == -1 )
       i_ret = -1;
    /* Both are nodes, sort by name */
    else if( first->i_children >= 0 && second->i_children >= 0 )
        i_ret = meta_strcasecmp_title( first, second );
    /* Both are items */
    else if( !psz_first && !psz_second )
        i_ret = 0;
    else if( !psz_first && psz_second )
        i_ret = 1;
    else if( psz_first && !psz_second )
        i_ret = -1;
    else
    {
        if( b_integer )
            i_ret = atoi( psz_first ) - atoi( psz_second );
     ...",1,1,playlist\sort.c,meta_sort,,false,72,106,meta_sort,,,2,"int meta_sort (playlist_item_t*,playlist_item_t*,vlc_meta_type_t,bool)"
167452,METHOD,playlist\sort.c:<global>,TYPE_DECL,"typedef int (*sortfn_t)(const void *,const void *);",13,50,playlist\sort.c,sortfn_t,,false,117,117,sortfn_t,,,3,"int sortfn_t (void*,void*)"
167462,METHOD,playlist\sort.c:<global>,TYPE_DECL,"static inline sortfn_t find_sorting_fn( unsigned i_mode, unsigned i_type )
{
    if( i_mode>=NUM_SORT_FNS || i_type>1 )
        return 0;
    return sorting_fns[i_mode][i_type];
}",1,1,playlist\sort.c,find_sorting_fn,,false,119,124,find_sorting_fn,,,6,"sortfn_t find_sorting_fn (unsigned,unsigned)"
167485,METHOD,playlist\sort.c:<global>,TYPE_DECL,"static inline
void playlist_ItemArraySort( unsigned i_items, playlist_item_t **pp_items,
                             sortfn_t p_sortfn )
{
    if( p_sortfn )
    {
        qsort( pp_items, i_items, sizeof( pp_items[0] ), p_sortfn );
    }
    else /* Randomise */
    {
        unsigned i_position;
        unsigned i_new;
        playlist_item_t *p_temp;

        for( i_position = i_items - 1; i_position > 0; i_position-- )
        {
            i_new = ((unsigned)vlc_mrand48()) % (i_position+1);
            p_temp = pp_items[i_position];
            pp_items[i_position] = pp_items[i_new];
            pp_items[i_new] = p_temp;
        }
    }
}",1,1,playlist\sort.c,playlist_ItemArraySort,,false,133,155,playlist_ItemArraySort,,,7,"void playlist_ItemArraySort (unsigned,playlist_item_t**,sortfn_t)"
167547,METHOD,playlist\sort.c:<global>,TYPE_DECL,"static int recursiveNodeSort( playlist_t *p_playlist, playlist_item_t *p_node,
                              sortfn_t p_sortfn )
{
    int i;
    playlist_ItemArraySort(p_node->i_children,p_node->pp_children,p_sortfn);
    for( i = 0 ; i< p_node->i_children; i++ )
    {
        if( p_node->pp_children[i]->i_children != -1 )
        {
            recursiveNodeSort( p_playlist, p_node->pp_children[i], p_sortfn );
        }
    }
    return VLC_SUCCESS;
}",1,1,playlist\sort.c,recursiveNodeSort,,false,166,179,recursiveNodeSort,,,8,"int recursiveNodeSort (playlist_t*,playlist_item_t*,sortfn_t)"
167598,METHOD,playlist\sort.c:<global>,TYPE_DECL,"int playlist_RecursiveNodeSort( playlist_t *p_playlist, playlist_item_t *p_node,
                                int i_mode, int i_type )
{
    PL_ASSERT_LOCKED;

    /* Ask the playlist to reset as we are changing the order */
    pl_priv(p_playlist)->b_reset_currently_playing = true;

    /* Do the real job recursively */
    return recursiveNodeSort(p_playlist,p_node,find_sorting_fn(i_mode,i_type));
}",1,4,playlist\sort.c,playlist_RecursiveNodeSort,,false,192,202,playlist_RecursiveNodeSort,,,9,"int playlist_RecursiveNodeSort (playlist_t*,playlist_item_t*,int,int)"
167625,METHOD,playlist\sort.c:<global>,TYPE_DECL,"SORTFN( SORT_TRACK_NUMBER, first, second )
{
    return meta_sort( first, second, vlc_meta_TrackNumber, true );
}",1,42,playlist\sort.c,proto_SORT_TRACK_NUMBER,,false,218,221,proto_SORT_TRACK_NUMBER,,,10,"int proto_SORT_TRACK_NUMBER (playlist_item_t*,playlist_item_t*)"
167637,METHOD,playlist\sort.c:<global>,TYPE_DECL,"SORTFN( SORT_DISC_NUMBER, first, second )
{
    int i_ret = meta_sort( first, second, vlc_meta_DiscNumber, true );
    /* Items came from the same disc: compare the track numbers */
    if( i_ret == 0 )
        i_ret = proto_SORT_TRACK_NUMBER( first, second );

    return i_ret;
}",1,41,playlist\sort.c,proto_SORT_DISC_NUMBER,,false,223,231,proto_SORT_DISC_NUMBER,,,11,"int proto_SORT_DISC_NUMBER (playlist_item_t*,playlist_item_t*)"
167663,METHOD,playlist\sort.c:<global>,TYPE_DECL,"SORTFN( SORT_ALBUM, first, second )
{
    int i_ret = meta_sort( first, second, vlc_meta_Album, false );
    /* Items came from the same album: compare the disc numbers */
    if( i_ret == 0 )
        i_ret = proto_SORT_DISC_NUMBER( first, second );

    return i_ret;
}",1,35,playlist\sort.c,proto_SORT_ALBUM,,false,233,241,proto_SORT_ALBUM,,,12,"int proto_SORT_ALBUM (playlist_item_t*,playlist_item_t*)"
167689,METHOD,playlist\sort.c:<global>,TYPE_DECL,"SORTFN( SORT_DATE, first, second )
{
    int i_ret = meta_sort( first, second, vlc_meta_Date, true );
    /* Items came from the same date: compare the albums */
    if( i_ret == 0 )
        i_ret = proto_SORT_ALBUM( first, second );

    return i_ret;
}",1,34,playlist\sort.c,proto_SORT_DATE,,false,243,251,proto_SORT_DATE,,,13,"int proto_SORT_DATE (playlist_item_t*,playlist_item_t*)"
167715,METHOD,playlist\sort.c:<global>,TYPE_DECL,"SORTFN( SORT_ARTIST, first, second )
{
    int i_ret = meta_sort( first, second, vlc_meta_Artist, false );
    /* Items came from the same artist: compare the dates */
    if( i_ret == 0 )
        i_ret = proto_SORT_DATE( first, second );

    return i_ret;
}",1,36,playlist\sort.c,proto_SORT_ARTIST,,false,253,261,proto_SORT_ARTIST,,,14,"int proto_SORT_ARTIST (playlist_item_t*,playlist_item_t*)"
167741,METHOD,playlist\sort.c:<global>,TYPE_DECL,"SORTFN( SORT_DESCRIPTION, first, second )
{
    return meta_sort( first, second, vlc_meta_Description, false );
}",1,41,playlist\sort.c,proto_SORT_DESCRIPTION,,false,263,266,proto_SORT_DESCRIPTION,,,15,"int proto_SORT_DESCRIPTION (playlist_item_t*,playlist_item_t*)"
167753,METHOD,playlist\sort.c:<global>,TYPE_DECL,"SORTFN( SORT_DURATION, first, second )
{
    mtime_t time1 = input_item_GetDuration( first->p_input );
    mtime_t time2 = input_item_GetDuration( second->p_input );
    int i_ret = time1 > time2 ? 1 :
                    ( time1 == time2 ? 0 : -1 );
    return i_ret;
}",1,38,playlist\sort.c,proto_SORT_DURATION,,false,268,275,proto_SORT_DURATION,,,16,"int proto_SORT_DURATION (playlist_item_t*,playlist_item_t*)"
167790,METHOD,playlist\sort.c:<global>,TYPE_DECL,"SORTFN( SORT_GENRE, first, second )
{
    return meta_sort( first, second, vlc_meta_Genre, false );
}",1,35,playlist\sort.c,proto_SORT_GENRE,,false,277,280,proto_SORT_GENRE,,,17,"int proto_SORT_GENRE (playlist_item_t*,playlist_item_t*)"
167802,METHOD,playlist\sort.c:<global>,TYPE_DECL,"SORTFN( SORT_ID, first, second )
{
    return first->i_id - second->i_id;
}",1,32,playlist\sort.c,proto_SORT_ID,,false,282,285,proto_SORT_ID,,,18,"int proto_SORT_ID (playlist_item_t*,playlist_item_t*)"
167816,METHOD,playlist\sort.c:<global>,TYPE_DECL,"SORTFN( SORT_RATING, first, second )
{
    return meta_sort( first, second, vlc_meta_Rating, true );
}",1,36,playlist\sort.c,proto_SORT_RATING,,false,287,290,proto_SORT_RATING,,,19,"int proto_SORT_RATING (playlist_item_t*,playlist_item_t*)"
167828,METHOD,playlist\sort.c:<global>,TYPE_DECL,"SORTFN( SORT_TITLE, first, second )
{
    return meta_strcasecmp_title( first, second );
}",1,35,playlist\sort.c,proto_SORT_TITLE,,false,292,295,proto_SORT_TITLE,,,20,"int proto_SORT_TITLE (playlist_item_t*,playlist_item_t*)"
167838,METHOD,playlist\sort.c:<global>,TYPE_DECL,"SORTFN( SORT_TITLE_NODES_FIRST, first, second )
{
    /* If first is a node but not second */
    if( first->i_children == -1 && second->i_children >= 0 )
        return -1;
    /* If second is a node but not first */
    else if( first->i_children >= 0 && second->i_children == -1 )
        return 1;
    /* Both are nodes or both are not nodes */
    else
        return meta_strcasecmp_title( first, second );
}",1,47,playlist\sort.c,proto_SORT_TITLE_NODES_FIRST,,false,297,308,proto_SORT_TITLE_NODES_FIRST,,,21,"int proto_SORT_TITLE_NODES_FIRST (playlist_item_t*,playlist_item_t*)"
167885,METHOD,playlist\sort.c:<global>,TYPE_DECL,"SORTFN( SORT_TITLE_NUMERIC, first, second )
{
    int i_ret;
    char *psz_first = input_item_GetTitleFbName( first->p_input );
    char *psz_second = input_item_GetTitleFbName( second->p_input );

    if( psz_first && psz_second )
        i_ret = atoi( psz_first ) - atoi( psz_second );
    else if( !psz_first && psz_second )
        i_ret = 1;
    else if( psz_first && !psz_second )
        i_ret = -1;
    else
        i_ret = 0;

    free( psz_first );
    free( psz_second );
    return i_ret;
}",1,43,playlist\sort.c,proto_SORT_TITLE_NUMERIC,,false,310,328,proto_SORT_TITLE_NUMERIC,,,22,"int proto_SORT_TITLE_NUMERIC (playlist_item_t*,playlist_item_t*)"
167952,METHOD,playlist\sort.c:<global>,TYPE_DECL,"SORTFN( SORT_URI, first, second )
{
    int i_ret;
    char *psz_first = input_item_GetURI( first->p_input );
    char *psz_second = input_item_GetURI( second->p_input );

    if( psz_first && psz_second )
        i_ret = strcasecmp( psz_first, psz_second );
    else if( !psz_first && psz_second )
        i_ret = 1;
    else if( psz_first && !psz_second )
        i_ret = -1;
    else
        i_ret = 0;

    free( psz_first );
    free( psz_second );
    return i_ret;
}",1,33,playlist\sort.c,proto_SORT_URI,,false,330,348,proto_SORT_URI,,,23,"int proto_SORT_URI (playlist_item_t*,playlist_item_t*)"
168046,METHOD,playlist\thread.c:<global>,TYPE_DECL,<global>,1,36,playlist\thread.c,playlist\thread.c:<global>,,false,1,537,<global>,,,1,
168048,METHOD,playlist\thread.c:<global>,TYPE_DECL,static void *Thread   ( void * );,13,32,playlist\thread.c,Thread,,false,42,42,Thread,,,1,void* Thread (void*)
168053,METHOD,playlist\thread.c:<global>,TYPE_DECL,"void playlist_Activate( playlist_t *p_playlist )
{
    playlist_private_t *p_sys = pl_priv(p_playlist);

    if( vlc_clone( &p_sys->thread, Thread, p_playlist,
                   VLC_THREAD_PRIORITY_LOW ) )
    {
        msg_Err( p_playlist, ""cannot spawn playlist thread"" );
        abort();
    }
}",1,32,playlist\thread.c,playlist_Activate,,false,51,61,playlist_Activate,,,2,void playlist_Activate (playlist_t*)
168082,METHOD,playlist\thread.c:<global>,TYPE_DECL,"void playlist_Deactivate( playlist_t *p_playlist )
{
    playlist_private_t *p_sys = pl_priv(p_playlist);

    PL_LOCK;
    /* WARNING: There is a latent bug. It is assumed that only one thread will
     * be waiting for playlist deactivation at a time. So far, that works
     * as playlist_Deactivate() is only ever called while closing an
     * interface and interfaces are shut down serially by intf_DestroyAll(). */
    if( p_sys->killed )
    {
        PL_UNLOCK;
        return;
    }

    msg_Dbg( p_playlist, ""deactivating the playlist"" );
    p_sys->killed = true;
    vlc_cond_signal( &p_sys->signal );
    PL_UNLOCK;

    vlc_join( p_sys->thread, NULL );
}",1,32,playlist\thread.c,playlist_Deactivate,,false,68,89,playlist_Deactivate,,,3,void playlist_Deactivate (playlist_t*)
168124,METHOD,playlist\thread.c:<global>,TYPE_DECL,"static int InputEvent( vlc_object_t *p_this, char const *psz_cmd,
                       vlc_value_t oldval, vlc_value_t newval, void *p_data )
{
    VLC_UNUSED(p_this); VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval);
    playlist_t *p_playlist = p_data;

    if( newval.i_int == INPUT_EVENT_DEAD )
    {
        playlist_private_t *sys = pl_priv(p_playlist);

        PL_LOCK;
        sys->request.input_dead = true;
        vlc_cond_signal( &sys->signal );
        PL_UNLOCK;
    }
    return VLC_SUCCESS;
}",1,34,playlist\thread.c,InputEvent,,false,94,110,InputEvent,,,4,"int InputEvent (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
168176,METHOD,playlist\thread.c:<global>,TYPE_DECL,"void ResyncCurrentIndex( playlist_t *p_playlist, playlist_item_t *p_cur )
{
    PL_ASSERT_LOCKED;

    PL_DEBUG( ""resyncing on %s"", PLI_NAME( p_cur ) );
    /* Simply resync index */
    int i;
    p_playlist->i_current_index = -1;
    for( i = 0 ; i< p_playlist->current.i_size; i++ )
    {
        if( ARRAY_VAL( p_playlist->current, i ) == p_cur )
        {
            p_playlist->i_current_index = i;
            break;
        }
    }
    PL_DEBUG( ""%s is at %i"", PLI_NAME( p_cur ), p_playlist->i_current_index );
}",1,4,playlist\thread.c,ResyncCurrentIndex,,false,120,137,ResyncCurrentIndex,,,5,"void ResyncCurrentIndex (playlist_t*,playlist_item_t*)"
168257,METHOD,playlist\thread.c:<global>,TYPE_DECL,"void ResetCurrentlyPlaying( playlist_t *p_playlist,
                                   playlist_item_t *p_cur )
{
    playlist_private_t *p_sys = pl_priv(p_playlist);

    PL_DEBUG( ""rebuilding array of current - root %s"",
              PLI_NAME( p_sys->status.p_node ) );
    ARRAY_RESET( p_playlist->current );
    p_playlist->i_current_index = -1;
    for( playlist_item_t *p_next = NULL; ; )
    {
        /** FIXME: this is *slow* */
        p_next = playlist_GetNextLeaf( p_playlist,
                                       p_sys->status.p_node,
                                       p_next, true, false );
        if( !p_next )
            break;

        if( p_next == p_cur )
            p_playlist->i_current_index = p_playlist->current.i_size;
        ARRAY_APPEND( p_playlist->current, p_next);
    }
    PL_DEBUG(""rebuild done - %i items, index %i"", p_playlist->current.i_size,
                                                  p_playlist->i_current_index);

    if( var_GetBool( p_pl...",1,32,playlist\thread.c,ResetCurrentlyPlaying,,false,146,185,ResetCurrentlyPlaying,,,6,"void ResetCurrentlyPlaying (playlist_t*,playlist_item_t*)"
168438,METHOD,playlist\thread.c:<global>,TYPE_DECL,"static bool PlayItem( playlist_t *p_playlist, playlist_item_t *p_item )
{
    playlist_private_t *p_sys = pl_priv(p_playlist);
    input_item_t *p_input = p_item->p_input;
    vlc_renderer_item_t *p_renderer;

    PL_ASSERT_LOCKED;

    msg_Dbg( p_playlist, ""creating new input thread"" );

    p_item->i_nb_played++;
    set_current_status_item( p_playlist, p_item );
    p_renderer = p_sys->p_renderer;
    /* Retain the renderer now to avoid it to be released by
     * playlist_SetRenderer when we exit the locked scope. If the last reference
     * was to be released, we would use a dangling pointer */
    if( p_renderer )
        vlc_renderer_item_hold( p_renderer );
    assert( p_sys->p_input == NULL );
    PL_UNLOCK;

    libvlc_MetadataCancel( p_playlist->obj.libvlc, p_item );

    input_thread_t *p_input_thread = input_Create( p_playlist, p_input, NULL,
                                                   p_sys->p_input_resource,
                                                   p...",1,32,playlist\thread.c,PlayItem,,false,194,256,PlayItem,,,7,"bool PlayItem (playlist_t*,playlist_item_t*)"
168588,METHOD,playlist\thread.c:<global>,TYPE_DECL,"static playlist_item_t *NextItem( playlist_t *p_playlist )
{
    playlist_private_t *p_sys = pl_priv(p_playlist);
    playlist_item_t *p_new = NULL;
    bool requested = p_sys->request.b_request;

    /* Clear the request */
    p_sys->request.b_request = false;

    /* Handle quickly a few special cases */
    /* No items to play */
    if( p_playlist->items.i_size == 0 )
    {
        msg_Info( p_playlist, ""playlist is empty"" );
        return NULL;
    }

    /* Start the real work */
    if( requested )
    {
        p_new = p_sys->request.p_item;

        if( p_new == NULL && p_sys->request.p_node == NULL )
            return NULL; /* Stop request! */

        int i_skip = p_sys->request.i_skip;
        PL_DEBUG( ""processing request item: %s, node: %s, skip: %i"",
                        PLI_NAME( p_sys->request.p_item ),
                        PLI_NAME( p_sys->request.p_node ), i_skip );

        if( p_sys->request.p_node &&
            p_sys->request.p_node != get_current_sta...",1,32,playlist\thread.c,NextItem,,false,265,422,NextItem,,,8,playlist_item_t NextItem (playlist_t*)
169160,METHOD,playlist\thread.c:<global>,TYPE_DECL,"static bool LoopInput( playlist_t *p_playlist )
{
    playlist_private_t *p_sys = pl_priv(p_playlist);
    input_thread_t *p_input = p_sys->p_input;

    assert( p_input != NULL );

    /* Wait for input to end or be stopped */
    while( !p_sys->request.input_dead )
    {
        if( p_sys->request.b_request || p_sys->killed )
        {
            PL_DEBUG( ""incoming request - stopping current input"" );
            input_Stop( p_input );
        }
        vlc_cond_wait( &p_sys->signal, &p_sys->lock );
    }

    input_item_t *item = input_GetItem(p_input);
    assert(item);
    bool ok = !input_item_HasErrorWhenReading(item);

    /* This input is dead. Remove it ! */
    PL_DEBUG( ""dead input"" );
    p_sys->p_input = NULL;
    p_sys->request.input_dead = false;
    PL_UNLOCK;

    var_SetAddress( p_playlist, ""input-current"", NULL );

    /* WARNING: Input resource manipulation and callback deletion are
     * incompatible with the playlist lock. */
    if( !var_InheritBool( p_inp...",1,32,playlist\thread.c,LoopInput,,false,424,464,LoopInput,,,9,bool LoopInput (playlist_t*)
169275,METHOD,playlist\thread.c:<global>,TYPE_DECL,"static bool Next( playlist_t *p_playlist )
{
    playlist_item_t *p_item = NextItem( p_playlist );
    if( p_item == NULL )
        return false;

    msg_Dbg( p_playlist, ""starting playback of new item"" );
    ResyncCurrentIndex( p_playlist, p_item );
    return PlayItem( p_playlist, p_item );
}",1,1,playlist\thread.c,Next,,false,466,475,Next,,,10,bool Next (playlist_t*)
169302,METHOD,playlist\thread.c:<global>,TYPE_DECL,"static void *Thread ( void *data )
{
    playlist_t *p_playlist = data;
    playlist_private_t *p_sys = pl_priv(p_playlist);
    bool played = false;

    PL_LOCK;
    while( !p_sys->killed )
    {
        /* Playlist in stopped state */
        assert(p_sys->p_input == NULL);

        if( !p_sys->request.b_request )
        {
            vlc_cond_wait( &p_sys->signal, &p_sys->lock );
            continue;
        }

        /* Playlist in running state */
        while( !p_sys->killed && Next( p_playlist ) )
        {
            bool ok = LoopInput( p_playlist );
            if (ok)
                p_sys->i_consecutive_errors = 0;
            else
            {
                if (p_sys->i_consecutive_errors < 6)
                    p_sys->i_consecutive_errors++;

                int slowdown = 1 << (p_sys->i_consecutive_errors - 1);
                /* 100ms, 200ms, 400ms, 800ms, 1.6s, 3.2s */
                mtime_t deadline = mdate() + slowdown * 100000L; /* usecs */
           ...",1,32,playlist\thread.c,Thread,,false,480,537,Thread,,,11,void* Thread (void*)
169473,METHOD,playlist\tree.c:<global>,TYPE_DECL,<global>,1,26,playlist\tree.c,playlist\tree.c:<global>,,false,1,428,<global>,,,1,
169475,METHOD,playlist\tree.c:<global>,TYPE_DECL,"playlist_item_t *GetNextUncle( playlist_t *p_playlist, playlist_item_t *p_item,
                               playlist_item_t *p_root );",17,56,playlist\tree.c,GetNextUncle,,false,35,36,GetNextUncle,,,1,"playlist_item_t* GetNextUncle (playlist_t*,playlist_item_t*,playlist_item_t*)"
169482,METHOD,playlist\tree.c:<global>,TYPE_DECL,"playlist_item_t *GetPrevUncle( playlist_t *p_playlist, playlist_item_t *p_item,
                               playlist_item_t *p_root );",17,56,playlist\tree.c,GetPrevUncle,,false,37,38,GetPrevUncle,,,2,"playlist_item_t* GetPrevUncle (playlist_t*,playlist_item_t*,playlist_item_t*)"
169489,METHOD,playlist\tree.c:<global>,TYPE_DECL,"playlist_item_t *GetNextItem( playlist_t *p_playlist,
                              playlist_item_t *p_root,
                              playlist_item_t *p_item );",17,55,playlist\tree.c,GetNextItem,,false,40,42,GetNextItem,,,3,"playlist_item_t* GetNextItem (playlist_t*,playlist_item_t*,playlist_item_t*)"
169496,METHOD,playlist\tree.c:<global>,TYPE_DECL,"playlist_item_t *GetPrevItem( playlist_t *p_playlist,
                              playlist_item_t *p_item,
                              playlist_item_t *p_root );",17,55,playlist\tree.c,GetPrevItem,,false,43,45,GetPrevItem,,,4,"playlist_item_t* GetPrevItem (playlist_t*,playlist_item_t*,playlist_item_t*)"
169503,METHOD,playlist\tree.c:<global>,TYPE_DECL,"playlist_item_t * playlist_NodeCreate( playlist_t *p_playlist,
                                       const char *psz_name,
                                       playlist_item_t *p_parent, int i_pos,
                                       int i_flags )
{
    input_item_t *p_new_input;
    playlist_item_t *p_item;

    PL_ASSERT_LOCKED;
    if( !psz_name ) psz_name = _(""Undefined"");

    p_new_input = input_item_NewExt( NULL, psz_name, -1, ITEM_TYPE_NODE,
                                     ITEM_NET_UNKNOWN );
    if( !p_new_input )
        return NULL;
    p_item = playlist_ItemNewFromInput( p_playlist, p_new_input );
    input_item_Release( p_new_input );

    if( p_item == NULL )  return NULL;

    playlist_NodeInsert( p_parent, p_item, i_pos );
    playlist_SendAddNotify( p_playlist, p_item );

    p_item->i_flags |= i_flags;

    return p_item;
}",1,1,playlist\tree.c,playlist_NodeCreate,,false,58,84,playlist_NodeCreate,,,5,"playlist_item_t playlist_NodeCreate (playlist_t*,char*,playlist_item_t*,int,int)"
169566,METHOD,playlist\tree.c:<global>,TYPE_DECL,"void playlist_NodeDelete( playlist_t *p_playlist, playlist_item_t *p_root )
{
    playlist_NodeDeleteExplicit( p_playlist, p_root,
        PLAYLIST_DELETE_STOP_IF_CURRENT );
}",1,8,playlist\tree.c,playlist_NodeDelete,,false,92,96,playlist_NodeDelete,,,6,"void playlist_NodeDelete (playlist_t*,playlist_item_t*)"
169578,METHOD,playlist\tree.c:<global>,TYPE_DECL,"void playlist_NodeDeleteExplicit( playlist_t *p_playlist,
    playlist_item_t *p_root, int flags )
{
    PL_ASSERT_LOCKED;

    /* Delete the node */
    if( p_root->i_flags & PLAYLIST_RO_FLAG &&
        !( flags & PLAYLIST_DELETE_FORCE ) )
        return;

    /* Delete the children */
    for( int i = p_root->i_children - 1 ; i >= 0; i-- )
        playlist_NodeDeleteExplicit( p_playlist,
            p_root->pp_children[i], flags | PLAYLIST_DELETE_FORCE );

    pl_priv(p_playlist)->b_reset_currently_playing = true;

    int i;
    var_SetAddress( p_playlist, ""playlist-item-deleted"", p_root );

    if( p_root->i_children == -1 ) {
        ARRAY_BSEARCH( p_playlist->items,->i_id, int, p_root->i_id, i );
        if( i != -1 )
            ARRAY_REMOVE( p_playlist->items, i );
    }

    if( get_current_status_item( p_playlist ) == p_root )
    {
        /* a deleted item cannot be currently playing */
        set_current_status_item( p_playlist, NULL );

        if( flags & PLAYLIST_DE...",1,19,playlist\tree.c,playlist_NodeDeleteExplicit,,false,98,147,playlist_NodeDeleteExplicit,,,7,"void playlist_NodeDeleteExplicit (playlist_t*,playlist_item_t*,int)"
169770,METHOD,playlist\tree.c:<global>,TYPE_DECL,"int playlist_NodeInsert( playlist_item_t *p_parent, playlist_item_t *p_item,
                         int i_position )
{
    assert( p_parent && p_parent->i_children != -1 );
    if( i_position == -1 ) i_position = p_parent->i_children ;
    assert( i_position <= p_parent->i_children);

    TAB_INSERT(p_parent->i_children, p_parent->pp_children,
               p_item, i_position);
    p_item->p_parent = p_parent;

    /* Inherit special flags from parent (sd cases) */
    if( ( p_parent->i_flags & PLAYLIST_NO_INHERIT_FLAG ) == 0 )
        p_item->i_flags |= (p_parent->i_flags & PLAYLIST_RO_FLAG);

    return VLC_SUCCESS;
}",1,1,playlist\tree.c,playlist_NodeInsert,,false,149,165,playlist_NodeInsert,,,8,"int playlist_NodeInsert (playlist_item_t*,playlist_item_t*,int)"
169837,METHOD,playlist\tree.c:<global>,TYPE_DECL,"playlist_item_t *playlist_ChildSearchName( playlist_item_t *p_node,
                                           const char *psz_search )
{
    int i;

    if( p_node->i_children < 0 )
    {
         return NULL;
    }
    for( i = 0 ; i< p_node->i_children; i++ )
    {
        if( !strcmp( p_node->pp_children[i]->p_input->psz_name, psz_search ) )
        {
            return p_node->pp_children[i];
        }
    }
    return NULL;
}",1,1,playlist\tree.c,playlist_ChildSearchName,,false,177,194,playlist_ChildSearchName,,,9,"playlist_item_t playlist_ChildSearchName (playlist_item_t*,char*)"
169888,METHOD,playlist\tree.c:<global>,TYPE_DECL,"playlist_item_t *playlist_GetNextLeaf( playlist_t *p_playlist,
                                       playlist_item_t *p_root,
                                       playlist_item_t *p_item,
                                       bool b_ena, bool b_unplayed )
{
    PL_ASSERT_LOCKED;
    playlist_item_t *p_next;

    assert( p_root && p_root->i_children != -1 );

    PL_DEBUG2( ""finding next of %s within %s"",
               PLI_NAME( p_item ), PLI_NAME( p_root ) );

    /* Now, walk the tree until we find a suitable next item */
    p_next = p_item;
    while( 1 )
    {
        bool b_ena_ok = true, b_unplayed_ok = true;
        p_next = GetNextItem( p_playlist, p_root, p_next );
        if( !p_next || p_next == p_root )
            break;
        if( p_next->i_children == -1 )
        {
            if( b_ena && p_next->i_flags & PLAYLIST_DBL_FLAG )
                b_ena_ok = false;
            if( b_unplayed && p_next->i_nb_played != 0 )
                b_unplayed_ok = false;
      ...",1,4,playlist\tree.c,playlist_GetNextLeaf,,false,207,239,playlist_GetNextLeaf,,,10,"playlist_item_t playlist_GetNextLeaf (playlist_t*,playlist_item_t*,playlist_item_t*,bool,bool)"
169984,METHOD,playlist\tree.c:<global>,TYPE_DECL,"playlist_item_t *GetNextItem( playlist_t *p_playlist,
                              playlist_item_t *p_root,
                              playlist_item_t *p_item )
{
    /* If the item is NULL, return the firt child of root */
    if( p_item == NULL )
    {
        if( p_root->i_children > 0 )
            return p_root->pp_children[0];
        else
            return NULL;
    }

    /* Node with children, get the first one */
    if( p_item->i_children > 0 )
        return p_item->pp_children[0];

    playlist_item_t* p_parent = p_item->p_parent;
    for( int i = 0 ; i < p_parent->i_children ; i++ )
    {
        if( p_parent->pp_children[i] == p_item )
        {
            // Return the next children
            if( i + 1 < p_parent->i_children )
                return p_parent->pp_children[i+1];
            // We are the least one, so try to have uncles
            else
            {
                PL_DEBUG2( ""Current item is the last of the node,""
                           ""...",1,16,playlist\tree.c,GetNextItem,,false,249,291,GetNextItem,,,11,"playlist_item_t GetNextItem (playlist_t*,playlist_item_t*,playlist_item_t*)"
170094,METHOD,playlist\tree.c:<global>,TYPE_DECL,"playlist_item_t *GetNextUncle( playlist_t *p_playlist, playlist_item_t *p_item,
                               playlist_item_t *p_root )
{
    playlist_item_t *p_parent = p_item->p_parent;
    playlist_item_t *p_grandparent;
    bool b_found = false;

    (void)p_playlist;

    if( p_parent != NULL )
    {
        p_grandparent = p_parent->p_parent;
        while( p_grandparent )
        {
            int i;
            for( i = 0 ; i< p_grandparent->i_children ; i++ )
            {
                if( p_parent == p_grandparent->pp_children[i] )
                {
                    PL_DEBUG2( ""parent %s found as child %i of grandparent %s"",
                               p_parent->p_input->psz_name, i,
                               p_grandparent->p_input->psz_name );
                    b_found = true;
                    break;
                }
            }
            if( b_found && i + 1 < p_grandparent->i_children )
            {
                    return p_grandparent->pp_...",1,20,playlist\tree.c,GetNextUncle,,false,293,337,GetNextUncle,,,12,"playlist_item_t GetNextUncle (playlist_t*,playlist_item_t*,playlist_item_t*)"
170195,METHOD,playlist\tree.c:<global>,TYPE_DECL,"playlist_item_t *GetPrevUncle( playlist_t *p_playlist, playlist_item_t *p_item,
                               playlist_item_t *p_root )
{
    playlist_item_t *p_parent = p_item->p_parent;
    playlist_item_t *p_grandparent;
    bool b_found = false;

    (void)p_playlist;

    if( p_parent != NULL )
    {
        p_grandparent = p_parent->p_parent;
        while( 1 )
        {
            int i;
            for( i = p_grandparent->i_children -1 ; i >= 0; i-- )
            {
                if( p_parent == p_grandparent->pp_children[i] )
                {
                    b_found = true;
                    break;
                }
            }
            if( b_found && i - 1 > 0 )
            {
                return p_grandparent->pp_children[i-1];
            }
            /* Not found at root */
            if( p_grandparent == p_root )
            {
                return NULL;
            }
            else
            {
                p_parent = p_grandparent;
         ...",1,1,playlist\tree.c,GetPrevUncle,,false,339,380,GetPrevUncle,,,13,"playlist_item_t GetPrevUncle (playlist_t*,playlist_item_t*,playlist_item_t*)"
170294,METHOD,playlist\tree.c:<global>,TYPE_DECL,"playlist_item_t *GetPrevItem( playlist_t *p_playlist,
                              playlist_item_t *p_root,
                              playlist_item_t *p_item )
{
    playlist_item_t *p_parent;
    int i;

    /* Node with children, get the last one */
    if( p_item && p_item->i_children > 0 )
        return p_item->pp_children[p_item->i_children - 1];

    /* Last child of its parent ? */
    if( p_item != NULL )
        p_parent = p_item->p_parent;
    else
    {
        msg_Err( p_playlist, ""Get the last one"" );
        abort();
    };

    for( i = p_parent->i_children -1 ; i >= 0 ;  i-- )
    {
        if( p_parent->pp_children[i] == p_item )
        {
            if( i-1 < 0 )
            {
               /* Was already the first sibling. Look for uncles */
                PL_DEBUG2( ""current item is the first of its node,""
                           ""looking for uncle from %s"",
                           p_parent->p_input->psz_name );
                if( p_parent == p_ro...",1,16,playlist\tree.c,GetPrevItem,,false,384,428,GetPrevItem,,,14,"playlist_item_t GetPrevItem (playlist_t*,playlist_item_t*,playlist_item_t*)"
170416,METHOD,posix\dirs.c:<global>,TYPE_DECL,<global>,1,1,posix\dirs.c,posix\dirs.c:<global>,,false,1,243,<global>,,,1,
170418,METHOD,posix\dirs.c:<global>,TYPE_DECL,"char *config_GetDataDir (void)
{
    const char *path = getenv (""VLC_DATA_PATH"");
    return strdup ((path != NULL) ? path : PKGDATADIR);
}",1,1,posix\dirs.c,config_GetDataDir,,false,44,48,config_GetDataDir,,,1,char* config_GetDataDir (void)
170436,METHOD,posix\dirs.c:<global>,TYPE_DECL,"char *config_GetLibDir (void)
{
    return strdup (PKGLIBDIR);
}",1,1,posix\dirs.c,config_GetLibDir,,false,55,58,config_GetLibDir,,,2,char* config_GetLibDir (void)
170444,METHOD,posix\dirs.c:<global>,TYPE_DECL,"static char *config_GetHomeDir (void)
{
    /* 1/ Try $HOME  */
    const char *home = getenv (""HOME"");
    if (home != NULL)
        return strdup (home);
#if defined(HAVE_GETPWUID_R)
    /* 2/ Try /etc/passwd */
    long max = sysconf (_SC_GETPW_R_SIZE_MAX);
    if (max != -1)
    {
        char buf[max];
        struct passwd pwbuf, *pw;

        if (getpwuid_r (getuid (), &pwbuf, buf, sizeof (buf), &pw) == 0
          && pw != NULL)
            return strdup (pw->pw_dir);
    }
#endif
    return NULL;
}",1,1,posix\dirs.c,config_GetHomeDir,,false,61,81,config_GetHomeDir,,,3,char* config_GetHomeDir (void)
170464,METHOD,posix\dirs.c:<global>,TYPE_DECL,"static char *config_GetAppDir (const char *xdg_name, const char *xdg_default)
{
    char *psz_dir;
    char var[sizeof (""XDG__HOME"") + strlen (xdg_name)];

    /* XDG Base Directory Specification - Version 0.6 */
    snprintf (var, sizeof (var), ""XDG_%s_HOME"", xdg_name);

    const char *home = getenv (var);
    if (home != NULL)
    {
        if (asprintf (&psz_dir, ""%s/vlc"", home) == -1)
            psz_dir = NULL;
        return psz_dir;
    }

    char *psz_home = config_GetHomeDir ();
    if( psz_home == NULL
     || asprintf( &psz_dir, ""%s/%s/vlc"", psz_home, xdg_default ) == -1 )
        psz_dir = NULL;
    free (psz_home);
    return psz_dir;
}",1,1,posix\dirs.c,config_GetAppDir,,false,83,105,config_GetAppDir,,,4,"char* config_GetAppDir (char*,char*)"
170529,METHOD,posix\dirs.c:<global>,TYPE_DECL,"static char *config_GetTypeDir (const char *xdg_name)
{
    const size_t namelen = strlen (xdg_name);
    const char *home = getenv (""HOME"");
    const char *dir = getenv (""XDG_CONFIG_HOME"");
    const char *file = ""user-dirs.dirs"";

    if (home == NULL)
        return NULL;
    if (dir == NULL)
    {
        dir = home;
        file = "".config/user-dirs.dirs"";
    }

    char *path;
    if (asprintf (&path, ""%s/%s"", dir, file) == -1)
        return NULL;

    FILE *stream = fopen (path, ""rte"");
    free (path);
    path = NULL;
    if (stream != NULL)
    {
        char *linebuf = NULL;
        size_t linelen = 0;

        while (getline (&linebuf, &linelen, stream) != -1)
        {
            char *ptr = linebuf;
            ptr += strspn (ptr, "" \t""); /* Skip whites */
            if (strncmp (ptr, ""XDG_"", 4))
                continue;
            ptr += 4; /* Skip XDG_ */
            if (strncmp (ptr, xdg_name, namelen))
                continue;
            ptr += namelen; /*...",1,1,posix\dirs.c,config_GetTypeDir,,false,107,209,config_GetTypeDir,,,5,char* config_GetTypeDir (char*)
170824,METHOD,posix\dirs.c:<global>,TYPE_DECL,"char *config_GetUserDir (vlc_userdir_t type)
{
    switch (type)
    {
        case VLC_HOME_DIR:
            break;
        case VLC_CONFIG_DIR:
            return config_GetAppDir (""CONFIG"", "".config"");
        case VLC_DATA_DIR:
            return config_GetAppDir (""DATA"", "".local/share"");
        case VLC_CACHE_DIR:
            return config_GetAppDir (""CACHE"", "".cache"");

        case VLC_DESKTOP_DIR:
            return config_GetTypeDir (""DESKTOP"");
        case VLC_DOWNLOAD_DIR:
            return config_GetTypeDir (""DOWNLOAD"");
        case VLC_TEMPLATES_DIR:
            return config_GetTypeDir (""TEMPLATES"");
        case VLC_PUBLICSHARE_DIR:
            return config_GetTypeDir (""PUBLICSHARE"");
        case VLC_DOCUMENTS_DIR:
            return config_GetTypeDir (""DOCUMENTS"");
        case VLC_MUSIC_DIR:
            return config_GetTypeDir (""MUSIC"");
        case VLC_PICTURES_DIR:
            return config_GetTypeDir (""PICTURES"");
        case VLC_VIDEOS_DIR:
            ...",1,1,posix\dirs.c,config_GetUserDir,,false,212,243,config_GetUserDir,,,6,char* config_GetUserDir (vlc_userdir_t)
170910,METHOD,posix\error.c:<global>,TYPE_DECL,<global>,1,1,posix\error.c,posix\error.c:<global>,,false,1,78,<global>,,,1,
170912,METHOD,posix\error.c:<global>,TYPE_DECL,"static const char *vlc_strerror_l(int errnum, const char *lname)
{
    int saved_errno = errno;
    locale_t loc = newlocale(LC_MESSAGES_MASK, lname, (locale_t)0);

    if (unlikely(loc == (locale_t)0))
    {
        if (errno == ENOENT) /* fallback to POSIX locale */
            loc = newlocale(LC_MESSAGES_MASK, ""C"", (locale_t)0);

        if (unlikely(loc == (locale_t)0))
        {
            assert(errno != EINVAL && errno != ENOENT);
            errno = saved_errno;
            return ""Error message unavailable"";
        }
        errno = saved_errno;
    }

    const char *buf = strerror_l(errnum, loc);

    freelocale(loc);
    return buf;
}",1,1,posix\error.c,vlc_strerror_l,,false,32,55,vlc_strerror_l,,,1,"const char* vlc_strerror_l (int,char*)"
170986,METHOD,posix\error.c:<global>,TYPE_DECL,"const char *vlc_strerror(int errnum)
{
    /* We cannot simply use strerror() here, since it is not thread-safe. */
    return vlc_strerror_l(errnum, """");
}",1,1,posix\error.c,vlc_strerror,,false,63,67,vlc_strerror,,,2,const char* vlc_strerror (int)
170995,METHOD,posix\error.c:<global>,TYPE_DECL,"const char *vlc_strerror_c(int errnum)
{
    return vlc_strerror_l(errnum, ""C"");
}",1,1,posix\error.c,vlc_strerror_c,,false,75,78,vlc_strerror_c,,,3,const char* vlc_strerror_c (int)
171039,METHOD,posix\filesystem.c:<global>,TYPE_DECL,<global>,1,25,posix\filesystem.c,posix\filesystem.c:<global>,,false,1,360,<global>,,,1,
171041,METHOD,posix\filesystem.c:<global>,TYPE_DECL,"static inline void vlc_cloexec(int fd)
{
    fcntl(fd, F_SETFD, FD_CLOEXEC | fcntl(fd, F_GETFD));
}",1,1,posix\filesystem.c,vlc_cloexec,,false,53,56,vlc_cloexec,,,1,void vlc_cloexec (int)
171054,METHOD,posix\filesystem.c:<global>,TYPE_DECL,"int vlc_open (const char *filename, int flags, ...)
{
    unsigned int mode = 0;
    va_list ap;

    va_start (ap, flags);
    if (flags & (O_CREAT|O_TMPFILE))
        mode = va_arg (ap, unsigned int);
    va_end (ap);

#ifdef O_CLOEXEC
    return open(filename, flags | O_CLOEXEC, mode);
#else
    int fd = open(filename, flags, mode);
    if (fd != -1)
        vlc_cloexec(fd);
    return -1;
#endif
}",1,25,posix\filesystem.c,vlc_open,,false,59,77,vlc_open,,,2,"int vlc_open (char*,int...)"
171089,METHOD,posix\filesystem.c:<global>,TYPE_DECL,"int vlc_openat (int dir, const char *filename, int flags, ...)
{
    unsigned int mode = 0;
    va_list ap;

    va_start (ap, flags);
    if (flags & (O_CREAT|O_TMPFILE))
        mode = va_arg (ap, unsigned int);
    va_end (ap);

#ifdef HAVE_OPENAT
    return openat(dir, filename, flags | O_CLOEXEC, mode);
#else
    VLC_UNUSED (dir);
    VLC_UNUSED (filename);
    VLC_UNUSED (mode);
    errno = ENOSYS;
    return -1;
#endif
}",1,25,posix\filesystem.c,vlc_openat,,false,79,98,vlc_openat,,,3,"int vlc_openat (int,char*,int...)"
171119,METHOD,posix\filesystem.c:<global>,TYPE_DECL,"int vlc_mkstemp (char *template)
{
#if defined (HAVE_MKOSTEMP) && defined (O_CLOEXEC)
    return mkostemp(template, O_CLOEXEC);
#else
    int fd = mkstemp(template);
    if (fd != -1)
        vlc_cloexec(fd);
    return fd;
#endif
}",1,1,posix\filesystem.c,vlc_mkstemp,,false,100,110,vlc_mkstemp,,,4,int vlc_mkstemp (char*)
171139,METHOD,posix\filesystem.c:<global>,TYPE_DECL,"int vlc_memfd (void)
{
    int fd;
#if O_TMPFILE
    fd = vlc_open (""/tmp"", O_RDWR|O_TMPFILE, S_IRUSR|S_IWUSR);
    if (fd != -1)
        return fd;
    /* ENOENT means either /tmp is missing (!) or the kernel does not support
     * O_TMPFILE. EISDIR means /tmp exists but the kernel does not support
     * O_TMPFILE. EOPNOTSUPP means the kernel supports O_TMPFILE but the /tmp
     * filesystem does not. Do not fallback on other errors. */
    if (errno != ENOENT && errno != EISDIR && errno != EOPNOTSUPP)
        return -1;
#endif

    char bufpath[] = ""/tmp/""PACKAGE_NAME""XXXXXX"";

    fd = vlc_mkstemp (bufpath);
    if (fd != -1)
        unlink (bufpath);
    return fd;
}",1,4,posix\filesystem.c,vlc_memfd,,false,112,133,vlc_memfd,,,5,int vlc_memfd (void)
171167,METHOD,posix\filesystem.c:<global>,TYPE_DECL,"int vlc_close (int fd)
{
    int ret;
#ifdef POSIX_CLOSE_RESTART
    ret = posix_close(fd, 0);
#else
    ret = close(fd);
    /* POSIX.2008 (and earlier) does not specify if the file descriptor is
     * closed on failure. Assume it is as on Linux and most other common OSes.
     * Also emulate the correct error code as per newer POSIX versions. */
    if (unlikely(ret != 0) && unlikely(errno == EINTR))
        errno = EINPROGRESS;
#endif
    assert(ret == 0 || errno != EBADF); /* something is corrupt? */
    return ret;
}",1,1,posix\filesystem.c,vlc_close,,false,135,150,vlc_close,,,6,int vlc_close (int)
171201,METHOD,posix\filesystem.c:<global>,TYPE_DECL,"int vlc_mkdir (const char *dirname, mode_t mode)
{
    return mkdir (dirname, mode);
}",1,1,posix\filesystem.c,vlc_mkdir,,false,152,155,vlc_mkdir,,,7,"int vlc_mkdir (char*,mode_t)"
171211,METHOD,posix\filesystem.c:<global>,TYPE_DECL,"DIR *vlc_opendir (const char *dirname)
{
    return opendir (dirname);
}",1,1,posix\filesystem.c,vlc_opendir,,false,157,160,vlc_opendir,,,8,DIR vlc_opendir (char*)
171219,METHOD,posix\filesystem.c:<global>,TYPE_DECL,"const char *vlc_readdir(DIR *dir)
{
    struct dirent *ent = readdir (dir);
    return (ent != NULL) ? ent->d_name : NULL;
}",1,1,posix\filesystem.c,vlc_readdir,,false,162,166,vlc_readdir,,,9,const char* vlc_readdir (DIR*)
171238,METHOD,posix\filesystem.c:<global>,TYPE_DECL,"int vlc_stat (const char *filename, struct stat *buf)
{
    return stat (filename, buf);
}",1,1,posix\filesystem.c,vlc_stat,,false,168,171,vlc_stat,,,10,"int vlc_stat (char*,stat*)"
171248,METHOD,posix\filesystem.c:<global>,TYPE_DECL,"int vlc_lstat (const char *filename, struct stat *buf)
{
    return lstat (filename, buf);
}",1,11,posix\filesystem.c,vlc_lstat,,false,173,176,vlc_lstat,,,11,"int vlc_lstat (char*,stat*)"
171262,METHOD,posix\filesystem.c:<global>,TYPE_DECL,"int vlc_unlink (const char *filename)
{
    return unlink (filename);
}",1,1,posix\filesystem.c,vlc_unlink,,false,178,181,vlc_unlink,,,12,int vlc_unlink (char*)
171270,METHOD,posix\filesystem.c:<global>,TYPE_DECL,"int vlc_rename (const char *oldpath, const char *newpath)
{
    return rename (oldpath, newpath);
}",1,1,posix\filesystem.c,vlc_rename,,false,183,186,vlc_rename,,,13,"int vlc_rename (char*,char*)"
171280,METHOD,posix\filesystem.c:<global>,TYPE_DECL,"char *vlc_getcwd (void)
{
    long path_max = pathconf (""."", _PC_PATH_MAX);
    size_t size = (path_max == -1 || path_max > 4096) ? 4096 : path_max;

    for (;; size *= 2)
    {
        char *buf = malloc (size);
        if (unlikely(buf == NULL))
            break;

        if (getcwd (buf, size) != NULL)
            return buf;
        free (buf);

        if (errno != ERANGE)
            break;
    }
    return NULL;
}",1,1,posix\filesystem.c,vlc_getcwd,,false,188,207,vlc_getcwd,,,14,char* vlc_getcwd (void)
171342,METHOD,posix\filesystem.c:<global>,TYPE_DECL,"int vlc_dup (int oldfd)
{
#ifdef F_DUPFD_CLOEXEC
    return fcntl (oldfd, F_DUPFD_CLOEXEC, 0);
#else
    int newfd = dup (oldfd);
    if (newfd != -1)
        vlc_cloexec(oldfd);
    return newfd;
#endif
}",1,1,posix\filesystem.c,vlc_dup,,false,209,219,vlc_dup,,,15,int vlc_dup (int)
171362,METHOD,posix\filesystem.c:<global>,TYPE_DECL,"int vlc_pipe (int fds[2])
{
#ifdef HAVE_PIPE2
    return pipe2(fds, O_CLOEXEC);
#else
    int ret = pipe(fds);
    if (ret == 0)
    {
        vlc_cloexec(fds[0]);
        vlc_cloexec(fds[1]);
    }
    return ret;
#endif
}",1,1,posix\filesystem.c,vlc_pipe,,false,221,234,vlc_pipe,,,16,int vlc_pipe (int[2])
171387,METHOD,posix\filesystem.c:<global>,TYPE_DECL,"ssize_t vlc_write(int fd, const void *buf, size_t len)
{
    struct iovec iov = { .iov_base = (void *)buf, .iov_len = len };

    return vlc_writev(fd, &iov, 1);
}",1,1,posix\filesystem.c,vlc_write,,false,236,241,vlc_write,,,17,"ssize_t vlc_write (int,void*,size_t)"
171414,METHOD,posix\filesystem.c:<global>,TYPE_DECL,"ssize_t vlc_writev(int fd, const struct iovec *iov, int count)
{
    sigset_t set, oset;

    sigemptyset(&set);
    sigaddset(&set, SIGPIPE);
    pthread_sigmask(SIG_BLOCK, &set, &oset);

    ssize_t val = writev(fd, iov, count);
    if (val < 0 && errno == EPIPE)
    {
#if (_POSIX_REALTIME_SIGNALS > 0)
        siginfo_t info;
        struct timespec ts = { 0, 0 };

        while (sigtimedwait(&set, &info, &ts) >= 0 || errno != EAGAIN);
#else
        for (;;)
        {
            sigset_t s;
            int num;

            sigpending(&s);
            if (!sigismember(&s, SIGPIPE))
                break;

            sigwait(&set, &num);
            assert(num == SIGPIPE);
        }
#endif
    }

    if (!sigismember(&oset, SIGPIPE)) /* Restore the signal mask if changed */
        pthread_sigmask(SIG_SETMASK, &oset, NULL);
    return val;
}",1,1,posix\filesystem.c,vlc_writev,,false,243,278,vlc_writev,,,18,"ssize_t vlc_writev (int,iovec*,int)"
171491,METHOD,posix\filesystem.c:<global>,TYPE_DECL,"static void vlc_socket_setup(int fd, bool nonblock)
{
    vlc_cloexec(fd);

    if (nonblock)
        fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) | O_NONBLOCK);

#ifdef SO_NOSIGPIPE
    setsockopt(fd, SOL_SOCKET, SO_NOSIGPIPE, &(int){ 1 }, sizeof (int));
#endif
}",1,1,posix\filesystem.c,vlc_socket_setup,,false,283,293,vlc_socket_setup,,,19,"void vlc_socket_setup (int,bool)"
171511,METHOD,posix\filesystem.c:<global>,TYPE_DECL,"int vlc_socket (int pf, int type, int proto, bool nonblock)
{
#ifdef SOCK_CLOEXEC
    if (nonblock)
        type |= SOCK_NONBLOCK;

    int fd = socket(pf, type | SOCK_CLOEXEC, proto);
# ifdef SO_NOSIGPIPE
    if (fd != -1)
        setsockopt(fd, SOL_SOCKET, SO_NOSIGPIPE, &(int){ 1 }, sizeof (int));
# endif
#else
    int fd = socket (pf, type, proto);
    if (fd != -1)
        vlc_socket_setup(fd, nonblock);
#endif
    return fd;
}",1,1,posix\filesystem.c,vlc_socket,,false,296,313,vlc_socket,,,20,"int vlc_socket (int,int,int,bool)"
171537,METHOD,posix\filesystem.c:<global>,TYPE_DECL,"int vlc_socketpair(int pf, int type, int proto, int fds[2], bool nonblock)
{
#ifdef SOCK_CLOEXEC
    if (nonblock)
        type |= SOCK_NONBLOCK;

    int ret = socketpair(pf, type | SOCK_CLOEXEC, proto, fds);
# ifdef SO_NOSIGPIPE
    if (ret == 0)
    {
        const int val = 1;

        setsockopt(fds[0], SOL_SOCKET, SO_NOSIGPIPE, &val, sizeof (val));
        setsockopt(fds[1], SOL_SOCKET, SO_NOSIGPIPE, &val, sizeof (val));
    }
# endif
#else
    int ret = socketpair(pf, type, proto, fds);
    if (ret == 0)
    {
        vlc_socket_setup(fds[0], nonblock);
        vlc_socket_setup(fds[1], nonblock);
    }
#endif
    return ret;
}",1,1,posix\filesystem.c,vlc_socketpair,,false,315,340,vlc_socketpair,,,21,"int vlc_socketpair (int,int,int,int[2],bool)"
171571,METHOD,posix\filesystem.c:<global>,TYPE_DECL,"int vlc_accept (int lfd, struct sockaddr *addr, socklen_t *alen, bool nonblock)
{
#ifdef HAVE_ACCEPT4
    int flags = SOCK_CLOEXEC;
    if (nonblock)
        flags |= SOCK_NONBLOCK;

    int fd = accept4(lfd, addr, alen, flags);
# ifdef SO_NOSIGPIPE
    if (fd != -1)
        setsockopt(fd, SOL_SOCKET, SO_NOSIGPIPE, &(int){ 1 }, sizeof (int));
# endif
#else
    int fd = accept(lfd, addr, alen);
    if (fd != -1)
        vlc_socket_setup(fd, nonblock);
#endif
    return fd;
}",1,1,posix\filesystem.c,vlc_accept,,false,342,360,vlc_accept,,,22,"int vlc_accept (int,sockaddr*,socklen_t*,bool)"
171614,METHOD,posix\getaddrinfo.c:<global>,TYPE_DECL,<global>,1,1,posix\getaddrinfo.c,posix\getaddrinfo.c:<global>,,false,1,92,<global>,,,1,
171625,METHOD,posix\getaddrinfo.c:<global>,TYPE_DECL,"static void *vlc_gai_thread(void *data)
{
    struct vlc_gai_req *req = data;

    req->error = EAI_SYSTEM;
    req->error = getaddrinfo(req->name, req->service, req->hints,
                             &req->result);
    vlc_sem_post(&req->done);
    return NULL;
}",1,1,posix\getaddrinfo.c,vlc_gai_thread,,false,43,52,vlc_gai_thread,,,2,void* vlc_gai_thread (void*)
171664,METHOD,posix\getaddrinfo.c:<global>,TYPE_DECL,"int vlc_getaddrinfo_i11e(const char *name, unsigned port,
                         const struct addrinfo *hints,
                         struct addrinfo **res)
{
    struct vlc_gai_req req =
    {
        .name = name,
        .service = NULL,
        .hints = hints,
    };
    char portbuf[6];
    vlc_thread_t th;

    if (port != 0)
    {
        if ((size_t)snprintf(portbuf, sizeof (portbuf), ""%u"",
                             port) >= sizeof (portbuf))
            return EAI_NONAME;

        req.service = portbuf;
    }

    vlc_sem_init(&req.done, 0);

    if (vlc_clone(&th, vlc_gai_thread, &req, VLC_THREAD_PRIORITY_LOW))
    {
        vlc_sem_destroy(&req.done);
        return EAI_SYSTEM;
    }

    vlc_sem_wait_i11e(&req.done);

    vlc_cancel(th);
    vlc_join(th, NULL);
    vlc_sem_destroy(&req.done);

    *res = req.result;
    return req.error;
}",1,1,posix\getaddrinfo.c,vlc_getaddrinfo_i11e,,false,54,92,vlc_getaddrinfo_i11e,,,3,"int vlc_getaddrinfo_i11e (char*,unsigned,addrinfo*,addrinfo**)"
171789,METHOD,posix\netconf.c:<global>,TYPE_DECL,<global>,1,1,posix\netconf.c,posix\netconf.c:<global>,,false,1,123,<global>,,,1,
171792,METHOD,posix\netconf.c:<global>,TYPE_DECL,"char *vlc_getProxyUrl(const char *url)
{
    /* libproxy helper */
    pid_t pid;
    posix_spawn_file_actions_t actions;
    posix_spawnattr_t attr;
    char *argv[3] = { (char *)""proxy"", (char *)url, NULL };
    int fd[2];

    if (vlc_pipe(fd))
        return NULL;

    if (posix_spawn_file_actions_init(&actions))
        return NULL;
    if (posix_spawn_file_actions_addopen(&actions, STDIN_FILENO, ""/dev/null"",
                                         O_RDONLY, 0644) ||
        posix_spawn_file_actions_adddup2(&actions, fd[1], STDOUT_FILENO))
    {
        posix_spawn_file_actions_destroy(&actions);
        return NULL;
    }

    posix_spawnattr_init(&attr);
    {
        sigset_t set;

        sigemptyset(&set);
        posix_spawnattr_setsigmask(&attr, &set);
        sigaddset (&set, SIGPIPE);
        posix_spawnattr_setsigdefault(&attr, &set);
        posix_spawnattr_setflags(&attr, POSIX_SPAWN_SETSIGDEF
                                      | POSIX_SPAWN_SETSIGMASK);
    }

...",1,1,posix\netconf.c,vlc_getProxyUrl,,false,46,123,vlc_getProxyUrl,,,2,char* vlc_getProxyUrl (char*)
172026,METHOD,posix\plugin.c:<global>,TYPE_DECL,<global>,1,24,posix\plugin.c,posix\plugin.c:<global>,,false,1,106,<global>,,,1,
172028,METHOD,posix\plugin.c:<global>,TYPE_DECL,"int module_Load (vlc_object_t *p_this, const char *path,
                 module_handle_t *p_handle, bool lazy)
{
#if defined (RTLD_NOW)
    const int flags = lazy ? RTLD_LAZY : RTLD_NOW;
#elif defined (DL_LAZY)
    const int flags = DL_LAZY;
#else
    const int flags = 0;
#endif

    module_handle_t handle = dlopen (path, flags);
    if( handle == NULL )
    {
        msg_Warn( p_this, ""cannot load module `%s' (%s)"", path, dlerror() );
        return -1;
    }
    *p_handle = handle;
    return 0;
}",1,1,posix\plugin.c,module_Load,,false,49,68,module_Load,,,1,"int module_Load (vlc_object_t*,char*,module_handle_t*,bool)"
172065,METHOD,posix\plugin.c:<global>,TYPE_DECL,"void module_Unload( module_handle_t handle )
{
#if !defined(__SANITIZE_ADDRESS__)
#ifdef HAVE_VALGRIND_VALGRIND_H
    if( RUNNING_ON_VALGRIND > 0 )
        return; /* do not dlclose() so that we get proper stack traces */
#endif
    dlclose( handle );
#else
    (void) handle;
#endif
}",1,1,posix\plugin.c,module_Unload,,false,79,90,module_Unload,,,2,void module_Unload (module_handle_t)
172072,METHOD,posix\plugin.c:<global>,TYPE_DECL,"void *module_Lookup( module_handle_t handle, const char *psz_function )
{
    return dlsym( handle, psz_function );
}",1,1,posix\plugin.c,module_Lookup,,false,103,106,module_Lookup,,,3,"void* module_Lookup (module_handle_t,char*)"
172109,METHOD,posix\rand.c:<global>,TYPE_DECL,<global>,1,20,posix\rand.c,posix\rand.c:<global>,,false,1,117,<global>,,,1,
172121,METHOD,posix\rand.c:<global>,TYPE_DECL,"static void vlc_rand_init (void)
{
    uint8_t key[BLOCK_SIZE];

    /* Get non-predictible value as key for HMAC */
    int fd = vlc_open (""/dev/urandom"", O_RDONLY);
    if (fd == -1)
        return; /* Uho! */

    for (size_t i = 0; i < sizeof (key);)
    {
         ssize_t val = read (fd, key + i, sizeof (key) - i);
         if (val > 0)
             i += val;
    }

    /* Precompute outer and inner keys for HMAC */
    for (size_t i = 0; i < sizeof (key); i++)
    {
        okey[i] = key[i] ^ 0x5c;
        ikey[i] = key[i] ^ 0x36;
    }

    vlc_close (fd);
}",1,16,posix\rand.c,vlc_rand_init,,false,50,74,vlc_rand_init,,,5,void vlc_rand_init (void)
172204,METHOD,posix\rand.c:<global>,TYPE_DECL,"void vlc_rand_bytes (void *buf, size_t len)
{
    static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
    static uint64_t counter = 0;

    uint64_t stamp = NTPtime64 ();

    while (len > 0)
    {
        uint64_t val;
        struct md5_s mdi, mdo;

        InitMD5 (&mdi);
        InitMD5 (&mdo);

        pthread_mutex_lock (&lock);
        if (counter == 0)
            vlc_rand_init ();
        val = counter++;

        AddMD5 (&mdi, ikey, sizeof (ikey));
        AddMD5 (&mdo, okey, sizeof (okey));
        pthread_mutex_unlock (&lock);

        AddMD5 (&mdi, &stamp, sizeof (stamp));
        AddMD5 (&mdi, &val, sizeof (val));
        EndMD5 (&mdi);
        AddMD5 (&mdo, mdi.buf, 16);
        EndMD5 (&mdo);

        if (len < 16)
        {
            memcpy (buf, mdo.buf, len);
            break;
        }

        memcpy (buf, mdo.buf, 16);
        len -= 16;
        buf = ((uint8_t *)buf) + 16;
    }
}",1,1,posix\rand.c,vlc_rand_bytes,,false,77,117,vlc_rand_bytes,,,6,"void vlc_rand_bytes (void*,size_t)"
172334,METHOD,posix\specific.c:<global>,TYPE_DECL,<global>,1,24,posix\specific.c,posix\specific.c:<global>,,false,1,161,<global>,,,1,
172336,METHOD,posix\specific.c:<global>,TYPE_DECL,"void system_Init (void)
{
}",1,1,posix\specific.c,system_Init,,false,35,37,system_Init,,,1,void system_Init (void)
172341,METHOD,posix\specific.c:<global>,TYPE_DECL,"static void system_ConfigureDbus(libvlc_int_t *vlc, int argc,
                                 const char *const argv[])
{
/* FIXME: could be replaced by using Unix sockets */
#ifdef HAVE_DBUS
# define MPRIS_APPEND ""/org/mpris/MediaPlayer2/TrackList/Append""
# define MPRIS_BUS_NAME ""org.mpris.MediaPlayer2.vlc""
# define MPRIS_OBJECT_PATH ""/org/mpris/MediaPlayer2""
# define MPRIS_TRACKLIST_INTERFACE ""org.mpris.MediaPlayer2.TrackList""

    dbus_threads_init_default();

    if (var_InheritBool(vlc, ""dbus""))
        libvlc_InternalAddIntf(vlc, ""dbus,none"");

    if (!var_InheritBool(vlc, ""one-instance"")
     && !(var_InheritBool(vlc, ""one-instance-when-started-from-file"")
       && var_InheritBool(vlc, ""started-from-file"")))
         return;

    for (int i = 0; i < argc; i++)
        if (argv[i][0] == ':')
        {
            msg_Err(vlc, ""item option %s incompatible with single instance"",
                    argv[i]);
            return;
        }

    char *name = var_GetString(vlc, ""...",1,1,posix\specific.c,system_ConfigureDbus,,false,39,155,system_ConfigureDbus,,,2,"void system_ConfigureDbus (libvlc_int_t*,int,char[]*)"
172357,METHOD,posix\specific.c:<global>,TYPE_DECL,"void system_Configure(libvlc_int_t *libvlc,
                      int argc, const char *const argv[])
{
    system_ConfigureDbus(libvlc, argc, argv);
}",1,1,posix\specific.c,system_Configure,,false,157,161,system_Configure,,,3,"void system_Configure (libvlc_int_t*,int,char[]*)"
172407,METHOD,posix\thread.c:<global>,TYPE_DECL,<global>,1,1,posix\thread.c,posix\thread.c:<global>,,false,1,723,<global>,,,1,
172409,METHOD,posix\thread.c:<global>,TYPE_DECL,"static struct timespec mtime_to_ts (mtime_t date)
{
    lldiv_t d = lldiv (date, CLOCK_FREQ);
    struct timespec ts = { d.quot, d.rem * (1000000000 / CLOCK_FREQ) };

    return ts;
}",1,1,posix\thread.c,mtime_to_ts,,false,110,116,mtime_to_ts,,,1,struct timespec mtime_to_ts (mtime_t)
172436,METHOD,posix\thread.c:<global>,TYPE_DECL,"void vlc_trace (const char *fn, const char *file, unsigned line)
{
     fprintf (stderr, ""at %s:%u in %s\n"", file, line, fn);
     fflush (stderr); /* needed before switch to low-level I/O */
#ifdef HAVE_BACKTRACE
     void *stack[20];
     int len = backtrace (stack, sizeof (stack) / sizeof (stack[0]));
     backtrace_symbols_fd (stack, len, 2);
#endif
     fsync (2);
}",1,1,posix\thread.c,vlc_trace,,false,121,131,vlc_trace,,,2,"void vlc_trace (char*,char*,unsigned)"
172453,METHOD,posix\thread.c:<global>,TYPE_DECL,"static void
vlc_thread_fatal (const char *action, int error,
                  const char *function, const char *file, unsigned line)
{
    int canc = vlc_savecancel ();
    fprintf (stderr, ""LibVLC fatal error %s (%d) in thread %lu "",
             action, error, vlc_thread_id ());
    vlc_trace (function, file, line);
    perror (""Thread error"");
    fflush (stderr);

    vlc_restorecancel (canc);
    abort ();
}",1,1,posix\thread.c,vlc_thread_fatal,,false,137,150,vlc_thread_fatal,,,3,"void vlc_thread_fatal (char*,int,char*,char*,unsigned)"
172483,METHOD,posix\thread.c:<global>,TYPE_DECL,"void vlc_mutex_init( vlc_mutex_t *p_mutex )
{
    pthread_mutexattr_t attr;

    if (unlikely(pthread_mutexattr_init (&attr)))
        abort();
#ifdef NDEBUG
    pthread_mutexattr_settype (&attr, PTHREAD_MUTEX_DEFAULT);
#else
    pthread_mutexattr_settype (&attr, PTHREAD_MUTEX_ERRORCHECK);
#endif
    if (unlikely(pthread_mutex_init (p_mutex, &attr)))
        abort();
    pthread_mutexattr_destroy( &attr );
}",1,1,posix\thread.c,vlc_mutex_init,,false,159,173,vlc_mutex_init,,,4,void vlc_mutex_init (vlc_mutex_t*)
172511,METHOD,posix\thread.c:<global>,TYPE_DECL,"void vlc_mutex_init_recursive( vlc_mutex_t *p_mutex )
{
    pthread_mutexattr_t attr;

    if (unlikely(pthread_mutexattr_init (&attr)))
        abort();
    pthread_mutexattr_settype (&attr, PTHREAD_MUTEX_RECURSIVE);
    if (unlikely(pthread_mutex_init (p_mutex, &attr)))
        abort();
    pthread_mutexattr_destroy( &attr );
}",1,1,posix\thread.c,vlc_mutex_init_recursive,,false,175,185,vlc_mutex_init_recursive,,,5,void vlc_mutex_init_recursive (vlc_mutex_t*)
172539,METHOD,posix\thread.c:<global>,TYPE_DECL,"void vlc_mutex_destroy (vlc_mutex_t *p_mutex)
{
    int val = pthread_mutex_destroy( p_mutex );
    VLC_THREAD_ASSERT (""destroying mutex"");
}",1,4,posix\thread.c,vlc_mutex_destroy,,false,187,191,vlc_mutex_destroy,,,6,void vlc_mutex_destroy (vlc_mutex_t*)
172562,METHOD,posix\thread.c:<global>,TYPE_DECL,"void vlc_mutex_lock (vlc_mutex_t *p_mutex)
{
    int val = pthread_mutex_lock( p_mutex );
    VLC_THREAD_ASSERT (""locking mutex"");
}",1,4,posix\thread.c,vlc_mutex_lock,,false,211,215,vlc_mutex_lock,,,8,void vlc_mutex_lock (vlc_mutex_t*)
172584,METHOD,posix\thread.c:<global>,TYPE_DECL,"int vlc_mutex_trylock (vlc_mutex_t *p_mutex)
{
    int val = pthread_mutex_trylock( p_mutex );

    if (val != EBUSY)
        VLC_THREAD_ASSERT (""locking mutex"");
    return val;
}",1,8,posix\thread.c,vlc_mutex_trylock,,false,217,224,vlc_mutex_trylock,,,9,int vlc_mutex_trylock (vlc_mutex_t*)
172613,METHOD,posix\thread.c:<global>,TYPE_DECL,"void vlc_mutex_unlock (vlc_mutex_t *p_mutex)
{
    int val = pthread_mutex_unlock( p_mutex );
    VLC_THREAD_ASSERT (""unlocking mutex"");
}",1,4,posix\thread.c,vlc_mutex_unlock,,false,226,230,vlc_mutex_unlock,,,10,void vlc_mutex_unlock (vlc_mutex_t*)
172635,METHOD,posix\thread.c:<global>,TYPE_DECL,"void vlc_cond_init (vlc_cond_t *p_condvar)
{
    pthread_condattr_t attr;

    if (unlikely(pthread_condattr_init (&attr)))
        abort ();
#if (_POSIX_CLOCK_SELECTION > 0)
    vlc_clock_setup ();
    pthread_condattr_setclock (&attr, vlc_clock_id);
#endif
    if (unlikely(pthread_cond_init (p_condvar, &attr)))
        abort ();
    pthread_condattr_destroy (&attr);
}",1,5,posix\thread.c,vlc_cond_init,,false,232,245,vlc_cond_init,,,11,void vlc_cond_init (vlc_cond_t*)
172659,METHOD,posix\thread.c:<global>,TYPE_DECL,"void vlc_cond_init_daytime (vlc_cond_t *p_condvar)
{
    if (unlikely(pthread_cond_init (p_condvar, NULL)))
        abort ();
}",1,1,posix\thread.c,vlc_cond_init_daytime,,false,247,251,vlc_cond_init_daytime,,,12,void vlc_cond_init_daytime (vlc_cond_t*)
172671,METHOD,posix\thread.c:<global>,TYPE_DECL,"void vlc_cond_destroy (vlc_cond_t *p_condvar)
{
    int val = pthread_cond_destroy( p_condvar );
    VLC_THREAD_ASSERT (""destroying condition"");
}",1,4,posix\thread.c,vlc_cond_destroy,,false,253,257,vlc_cond_destroy,,,13,void vlc_cond_destroy (vlc_cond_t*)
172693,METHOD,posix\thread.c:<global>,TYPE_DECL,"void vlc_cond_signal (vlc_cond_t *p_condvar)
{
    int val = pthread_cond_signal( p_condvar );
    VLC_THREAD_ASSERT (""signaling condition variable"");
}",1,4,posix\thread.c,vlc_cond_signal,,false,259,263,vlc_cond_signal,,,14,void vlc_cond_signal (vlc_cond_t*)
172715,METHOD,posix\thread.c:<global>,TYPE_DECL,"void vlc_cond_broadcast (vlc_cond_t *p_condvar)
{
    pthread_cond_broadcast (p_condvar);
}",1,1,posix\thread.c,vlc_cond_broadcast,,false,265,268,vlc_cond_broadcast,,,15,void vlc_cond_broadcast (vlc_cond_t*)
172722,METHOD,posix\thread.c:<global>,TYPE_DECL,"void vlc_cond_wait (vlc_cond_t *p_condvar, vlc_mutex_t *p_mutex)
{
    int val = pthread_cond_wait( p_condvar, p_mutex );
    VLC_THREAD_ASSERT (""waiting on condition"");
}",1,4,posix\thread.c,vlc_cond_wait,,false,270,274,vlc_cond_wait,,,16,"void vlc_cond_wait (vlc_cond_t*,vlc_mutex_t*)"
172746,METHOD,posix\thread.c:<global>,TYPE_DECL,"int vlc_cond_timedwait (vlc_cond_t *p_condvar, vlc_mutex_t *p_mutex,
                        mtime_t deadline)
{
    struct timespec ts = mtime_to_ts (deadline);
    int val = pthread_cond_timedwait (p_condvar, p_mutex, &ts);
    if (val != ETIMEDOUT)
        VLC_THREAD_ASSERT (""timed-waiting on condition"");
    return val;
}",1,8,posix\thread.c,vlc_cond_timedwait,,false,276,284,vlc_cond_timedwait,,,17,"int vlc_cond_timedwait (vlc_cond_t*,vlc_mutex_t*,mtime_t)"
172785,METHOD,posix\thread.c:<global>,TYPE_DECL,"int vlc_cond_timedwait_daytime (vlc_cond_t *p_condvar, vlc_mutex_t *p_mutex,
                                time_t deadline)
{
    struct timespec ts = { deadline, 0 };
    int val = pthread_cond_timedwait (p_condvar, p_mutex, &ts);
    if (val != ETIMEDOUT)
        VLC_THREAD_ASSERT (""timed-waiting on condition"");
    return val;
}",1,8,posix\thread.c,vlc_cond_timedwait_daytime,,false,286,294,vlc_cond_timedwait_daytime,,,18,"int vlc_cond_timedwait_daytime (vlc_cond_t*,vlc_mutex_t*,time_t)"
172825,METHOD,posix\thread.c:<global>,TYPE_DECL,"void vlc_sem_init (vlc_sem_t *sem, unsigned value)
{
    if (unlikely(sem_init (sem, 0, value)))
        abort ();
}",1,1,posix\thread.c,vlc_sem_init,,false,296,300,vlc_sem_init,,,19,"void vlc_sem_init (vlc_sem_t*,unsigned)"
172839,METHOD,posix\thread.c:<global>,TYPE_DECL,"void vlc_sem_destroy (vlc_sem_t *sem)
{
    int val;

    if (likely(sem_destroy (sem) == 0))
        return;

    val = errno;

    VLC_THREAD_ASSERT (""destroying semaphore"");
}",1,4,posix\thread.c,vlc_sem_destroy,,false,302,312,vlc_sem_destroy,,,20,void vlc_sem_destroy (vlc_sem_t*)
172868,METHOD,posix\thread.c:<global>,TYPE_DECL,"int vlc_sem_post (vlc_sem_t *sem)
{
    int val;

    if (likely(sem_post (sem) == 0))
        return 0;

    val = errno;

    if (unlikely(val != EOVERFLOW))
        VLC_THREAD_ASSERT (""unlocking semaphore"");
    return val;
}",1,8,posix\thread.c,vlc_sem_post,,false,314,326,vlc_sem_post,,,21,int vlc_sem_post (vlc_sem_t*)
172906,METHOD,posix\thread.c:<global>,TYPE_DECL,"void vlc_sem_wait (vlc_sem_t *sem)
{
    int val;

    do
        if (likely(sem_wait (sem) == 0))
            return;
    while ((val = errno) == EINTR);

    VLC_THREAD_ASSERT (""locking semaphore"");
}",1,4,posix\thread.c,vlc_sem_wait,,false,328,338,vlc_sem_wait,,,22,void vlc_sem_wait (vlc_sem_t*)
172938,METHOD,posix\thread.c:<global>,TYPE_DECL,"void vlc_rwlock_init (vlc_rwlock_t *lock)
{
    if (unlikely(pthread_rwlock_init (lock, NULL)))
        abort ();
}",1,1,posix\thread.c,vlc_rwlock_init,,false,340,344,vlc_rwlock_init,,,23,void vlc_rwlock_init (vlc_rwlock_t*)
172950,METHOD,posix\thread.c:<global>,TYPE_DECL,"void vlc_rwlock_destroy (vlc_rwlock_t *lock)
{
    int val = pthread_rwlock_destroy (lock);
    VLC_THREAD_ASSERT (""destroying R/W lock"");
}",1,4,posix\thread.c,vlc_rwlock_destroy,,false,346,350,vlc_rwlock_destroy,,,24,void vlc_rwlock_destroy (vlc_rwlock_t*)
172972,METHOD,posix\thread.c:<global>,TYPE_DECL,"void vlc_rwlock_rdlock (vlc_rwlock_t *lock)
{
    int val = pthread_rwlock_rdlock (lock);
    VLC_THREAD_ASSERT (""acquiring R/W lock for reading"");
}",1,4,posix\thread.c,vlc_rwlock_rdlock,,false,352,356,vlc_rwlock_rdlock,,,25,void vlc_rwlock_rdlock (vlc_rwlock_t*)
172994,METHOD,posix\thread.c:<global>,TYPE_DECL,"void vlc_rwlock_wrlock (vlc_rwlock_t *lock)
{
    int val = pthread_rwlock_wrlock (lock);
    VLC_THREAD_ASSERT (""acquiring R/W lock for writing"");
}",1,4,posix\thread.c,vlc_rwlock_wrlock,,false,358,362,vlc_rwlock_wrlock,,,26,void vlc_rwlock_wrlock (vlc_rwlock_t*)
173016,METHOD,posix\thread.c:<global>,TYPE_DECL,"void vlc_rwlock_unlock (vlc_rwlock_t *lock)
{
    int val = pthread_rwlock_unlock (lock);
    VLC_THREAD_ASSERT (""releasing R/W lock"");
}",1,4,posix\thread.c,vlc_rwlock_unlock,,false,364,368,vlc_rwlock_unlock,,,27,void vlc_rwlock_unlock (vlc_rwlock_t*)
173038,METHOD,posix\thread.c:<global>,TYPE_DECL,"int vlc_threadvar_create (vlc_threadvar_t *key, void (*destr) (void *))
{
    return pthread_key_create (key, destr);
}",1,1,posix\thread.c,vlc_threadvar_create,,false,370,373,vlc_threadvar_create,,,28,"int vlc_threadvar_create (vlc_threadvar_t*,void)"
173048,METHOD,posix\thread.c:<global>,TYPE_DECL,"void vlc_threadvar_delete (vlc_threadvar_t *p_tls)
{
    pthread_key_delete (*p_tls);
}",1,1,posix\thread.c,vlc_threadvar_delete,,false,375,378,vlc_threadvar_delete,,,29,void vlc_threadvar_delete (vlc_threadvar_t*)
173056,METHOD,posix\thread.c:<global>,TYPE_DECL,"int vlc_threadvar_set (vlc_threadvar_t key, void *value)
{
    return pthread_setspecific (key, value);
}",1,1,posix\thread.c,vlc_threadvar_set,,false,380,383,vlc_threadvar_set,,,30,"int vlc_threadvar_set (vlc_threadvar_t,void*)"
173066,METHOD,posix\thread.c:<global>,TYPE_DECL,"void *vlc_threadvar_get (vlc_threadvar_t key)
{
    return pthread_getspecific (key);
}",1,1,posix\thread.c,vlc_threadvar_get,,false,385,388,vlc_threadvar_get,,,31,void* vlc_threadvar_get (vlc_threadvar_t)
173079,METHOD,posix\thread.c:<global>,TYPE_DECL,"void vlc_threads_setup (libvlc_int_t *p_libvlc)
{
    static vlc_mutex_t lock = VLC_STATIC_MUTEX;
    static bool initialized = false;

    vlc_mutex_lock (&lock);
    /* Initializes real-time priorities before any thread is created,
     * just once per process. */
    if (!initialized)
    {
        if (var_InheritBool (p_libvlc, ""rt-priority""))
        {
            rt_offset = var_InheritInteger (p_libvlc, ""rt-offset"");
            rt_priorities = true;
        }
        initialized = true;
    }
    vlc_mutex_unlock (&lock);
}",1,1,posix\thread.c,vlc_threads_setup,,false,393,411,vlc_threads_setup,,,35,void vlc_threads_setup (libvlc_int_t*)
173118,METHOD,posix\thread.c:<global>,TYPE_DECL,"static int vlc_clone_attr (vlc_thread_t *th, pthread_attr_t *attr,
                           void *(*entry) (void *), void *data, int priority)
{
    int ret;

    /* Block the signals that signals interface plugin handles.
     * If the LibVLC caller wants to handle some signals by itself, it should
     * block these before whenever invoking LibVLC. And it must obviously not
     * start the VLC signals interface plugin.
     *
     * LibVLC will normally ignore any interruption caused by an asynchronous
     * signal during a system call. But there may well be some buggy cases
     * where it fails to handle EINTR (bug reports welcome). Some underlying
     * libraries might also not handle EINTR properly.
     */
    sigset_t oldset;
    {
        sigset_t set;
        sigemptyset (&set);
        sigdelset (&set, SIGHUP);
        sigaddset (&set, SIGINT);
        sigaddset (&set, SIGQUIT);
        sigaddset (&set, SIGTERM);

        sigaddset (&set, SIGPIPE); /* We don't want t...",1,43,posix\thread.c,vlc_clone_attr,,false,414,486,vlc_clone_attr,,,36,"int vlc_clone_attr (vlc_thread_t*,pthread_attr_t*,void*,void*,int)"
173198,METHOD,posix\thread.c:<global>,TYPE_DECL,"int vlc_clone (vlc_thread_t *th, void *(*entry) (void *), void *data,
               int priority)
{
    pthread_attr_t attr;

    pthread_attr_init (&attr);
    return vlc_clone_attr (th, &attr, entry, data, priority);
}",1,1,posix\thread.c,vlc_clone,,false,488,495,vlc_clone,,,37,"int vlc_clone (vlc_thread_t*,void*,void*,int)"
173218,METHOD,posix\thread.c:<global>,TYPE_DECL,"void vlc_join(vlc_thread_t th, void **result)
{
    int val = pthread_join(th.handle, result);
    VLC_THREAD_ASSERT (""joining thread"");
}",1,4,posix\thread.c,vlc_join,,false,497,501,vlc_join,,,38,"void vlc_join (vlc_thread_t,void**)"
173244,METHOD,posix\thread.c:<global>,TYPE_DECL,"int vlc_clone_detach (vlc_thread_t *th, void *(*entry) (void *), void *data,
                      int priority)
{
    vlc_thread_t dummy;
    pthread_attr_t attr;

    if (th == NULL)
        th = &dummy;

    pthread_attr_init (&attr);
    pthread_attr_setdetachstate (&attr, PTHREAD_CREATE_DETACHED);
    return vlc_clone_attr (th, &attr, entry, data, priority);
}",1,1,posix\thread.c,vlc_clone_detach,,false,533,545,vlc_clone_detach,,,39,"int vlc_clone_detach (vlc_thread_t*,void*,void*,int)"
173278,METHOD,posix\thread.c:<global>,TYPE_DECL,"vlc_thread_t vlc_thread_self (void)
{
    vlc_thread_t thread = { pthread_self() };
    return thread;
}",1,1,posix\thread.c,vlc_thread_self,,false,547,551,vlc_thread_self,,,40,vlc_thread_t vlc_thread_self (void)
173290,METHOD,posix\thread.c:<global>,TYPE_DECL,"unsigned long vlc_thread_id (void)
{
     return -1;
}",1,1,posix\thread.c,vlc_thread_id,,false,554,557,vlc_thread_id,,,41,unsigned long vlc_thread_id (void)
173298,METHOD,posix\thread.c:<global>,TYPE_DECL,"int vlc_set_priority (vlc_thread_t th, int priority)
{
#if defined (_POSIX_PRIORITY_SCHEDULING) && (_POSIX_PRIORITY_SCHEDULING >= 0) \
 && defined (_POSIX_THREAD_PRIORITY_SCHEDULING) \
 && (_POSIX_THREAD_PRIORITY_SCHEDULING >= 0)
    if (rt_priorities)
    {
        struct sched_param sp = { .sched_priority = priority + rt_offset, };
        int policy;

        if (sp.sched_priority <= 0)
            sp.sched_priority += sched_get_priority_max (policy = SCHED_OTHER);
        else
            sp.sched_priority += sched_get_priority_min (policy = SCHED_RR);

        if (pthread_setschedparam(th.handle, policy, &sp))
            return VLC_EGENERIC;
    }
#else
    (void) th; (void) priority;
#endif
    return VLC_SUCCESS;
}",1,1,posix\thread.c,vlc_set_priority,,false,560,582,vlc_set_priority,,,42,"int vlc_set_priority (vlc_thread_t,int)"
173312,METHOD,posix\thread.c:<global>,TYPE_DECL,"void vlc_cancel(vlc_thread_t th)
{
    pthread_cancel(th.handle);
}",1,1,posix\thread.c,vlc_cancel,,false,584,587,vlc_cancel,,,43,void vlc_cancel (vlc_thread_t)
173321,METHOD,posix\thread.c:<global>,TYPE_DECL,"int vlc_savecancel (void)
{
    int state;
    int val = pthread_setcancelstate (PTHREAD_CANCEL_DISABLE, &state);

    VLC_THREAD_ASSERT (""saving cancellation"");
    return state;
}",1,4,posix\thread.c,vlc_savecancel,,false,589,596,vlc_savecancel,,,44,int vlc_savecancel (void)
173348,METHOD,posix\thread.c:<global>,TYPE_DECL,"void vlc_restorecancel (int state)
{
#ifndef NDEBUG
    int oldstate, val;

    val = pthread_setcancelstate (state, &oldstate);
    /* This should fail if an invalid value for given for state */
    VLC_THREAD_ASSERT (""restoring cancellation"");

    if (unlikely(oldstate != PTHREAD_CANCEL_DISABLE))
         vlc_thread_fatal (""restoring cancellation while not disabled"", EINVAL,
                           __func__, __FILE__, __LINE__);
#else
    pthread_setcancelstate (state, NULL);
#endif
}",1,4,posix\thread.c,vlc_restorecancel,,false,598,613,vlc_restorecancel,,,45,void vlc_restorecancel (int)
173389,METHOD,posix\thread.c:<global>,TYPE_DECL,"void vlc_testcancel (void)
{
    pthread_testcancel ();
}",1,1,posix\thread.c,vlc_testcancel,,false,615,618,vlc_testcancel,,,46,void vlc_testcancel (void)
173395,METHOD,posix\thread.c:<global>,TYPE_DECL,"void vlc_control_cancel (int cmd, ...)
{
    (void) cmd;
    vlc_assert_unreachable ();
}",1,1,posix\thread.c,vlc_control_cancel,,false,620,624,vlc_control_cancel,,,47,void vlc_control_cancel (int...)
173404,METHOD,posix\thread.c:<global>,TYPE_DECL,"mtime_t mdate (void)
{
#if (_POSIX_TIMERS > 0)
    struct timespec ts;

    vlc_clock_setup ();
    if (unlikely(clock_gettime (vlc_clock_id, &ts) != 0))
        abort ();

    return (INT64_C(1000000) * ts.tv_sec) + (ts.tv_nsec / 1000);

#else
    struct timeval tv;

    if (unlikely(gettimeofday (&tv, NULL) != 0))
        abort ();
    return (INT64_C(1000000) * tv.tv_sec) + tv.tv_usec;

#endif
}",1,5,posix\thread.c,mdate,,false,626,645,mdate,,,48,mtime_t mdate (void)
173431,METHOD,posix\thread.c:<global>,TYPE_DECL,"void mwait (mtime_t deadline)
{
#if (_POSIX_CLOCK_SELECTION > 0)
    vlc_clock_setup ();
    /* If the deadline is already elapsed, or within the clock precision,
     * do not even bother the system timer. */
    deadline -= vlc_clock_prec;

    struct timespec ts = mtime_to_ts (deadline);

    while (clock_nanosleep (vlc_clock_id, TIMER_ABSTIME, &ts, NULL) == EINTR);

#else
    deadline -= mdate ();
    if (deadline > 0)
        msleep (deadline);

#endif
}",1,5,posix\thread.c,mwait,,false,648,666,mwait,,,49,void mwait (mtime_t)
173446,METHOD,posix\thread.c:<global>,TYPE_DECL,"void msleep (mtime_t delay)
{
    struct timespec ts = mtime_to_ts (delay);

#if (_POSIX_CLOCK_SELECTION > 0)
    vlc_clock_setup ();
    while (clock_nanosleep (vlc_clock_id, 0, &ts, &ts) == EINTR);

#else
    while (nanosleep (&ts, &ts) == -1)
        assert (errno == EINTR);

#endif
}",1,5,posix\thread.c,msleep,,false,669,682,msleep,,,50,void msleep (mtime_t)
173469,METHOD,posix\thread.c:<global>,TYPE_DECL,"unsigned vlc_GetCPUCount(void)
{
#if defined(HAVE_SCHED_GETAFFINITY)
    cpu_set_t cpu;

    CPU_ZERO(&cpu);
    if (sched_getaffinity (0, sizeof (cpu), &cpu) < 0)
        return 1;

    return CPU_COUNT (&cpu);

#elif defined(__SunOS)
    unsigned count = 0;
    int type;
    u_int numcpus;
    processor_info_t cpuinfo;

    processorid_t *cpulist = vlc_alloc (sysconf(_SC_NPROCESSORS_MAX), sizeof (*cpulist));
    if (unlikely(cpulist == NULL))
        return 1;

    if (pset_info(PS_MYID, &type, &numcpus, cpulist) == 0)
    {
        for (u_int i = 0; i < numcpus; i++)
            if (processor_info (cpulist[i], &cpuinfo) == 0)
                count += (cpuinfo.pi_state == P_ONLINE);
    }
    else
        count = sysconf (_SC_NPROCESSORS_ONLN);
    free (cpulist);
    return count ? count : 1;
#elif defined(_SC_NPROCESSORS_ONLN)
    return sysconf(_SC_NPROCESSORS_ONLN);
#elif defined(_SC_NPROCESSORS_CONF)
    return sysconf(_SC_NPROCESSORS_CONF);
#else
#   warning ""vlc_GetCPUCount...",1,1,posix\thread.c,vlc_GetCPUCount,,false,684,723,vlc_GetCPUCount,,,51,unsigned vlc_GetCPUCount (void)
173493,METHOD,posix\timer.c:<global>,TYPE_DECL,<global>,1,1,posix\timer.c,posix\timer.c:<global>,,false,1,166,<global>,,,1,
173499,METHOD,vlc_timer,TYPE_DECL,void       (*func) (void *);,16,31,posix\timer.c,vlc_timer.func,,false,47,47,func,,,4,void vlc_timer.func (void*)
173509,METHOD,posix\timer.c:<global>,TYPE_DECL,"static void *vlc_timer_thread (void *data)
{
    struct vlc_timer *timer = data;

    vlc_mutex_lock (&timer->lock);
    mutex_cleanup_push (&timer->lock);

    for (;;)
    {
        while (timer->value == 0)
        {
            assert(timer->interval == 0);
            vlc_cond_wait (&timer->reschedule, &timer->lock);
        }

        if (timer->interval != 0)
        {
            mtime_t now = mdate();

            if (now > timer->value)
            {   /* Update overrun counter */
                unsigned misses = (now - timer->value) / timer->interval;

                timer->value += misses * timer->interval;
                assert(timer->value <= now);
                atomic_fetch_add_explicit(&timer->overruns, misses,
                                          memory_order_relaxed);
            }
        }

        mtime_t value = timer->value;

        if (vlc_cond_timedwait(&timer->reschedule, &timer->lock, value) == 0)
            continue;

        if (likely(timer-...",10,1,posix\timer.c,vlc_timer_thread,,false,53,107,vlc_timer_thread,,,3,void* vlc_timer_thread (void*)
173678,METHOD,posix\timer.c:<global>,TYPE_DECL,"int vlc_timer_create (vlc_timer_t *id, void (*func) (void *), void *data)
{
    struct vlc_timer *timer = malloc (sizeof (*timer));

    if (unlikely(timer == NULL))
        return ENOMEM;
    vlc_mutex_init (&timer->lock);
    vlc_cond_init (&timer->reschedule);
    assert (func);
    timer->func = func;
    timer->data = data;
    timer->value = 0;
    timer->interval = 0;
    atomic_init(&timer->overruns, 0);

    if (vlc_clone (&timer->thread, vlc_timer_thread, timer,
                   VLC_THREAD_PRIORITY_INPUT))
    {
        vlc_cond_destroy (&timer->reschedule);
        vlc_mutex_destroy (&timer->lock);
        free (timer);
        return ENOMEM;
    }

    *id = timer;
    return 0;
}",1,1,posix\timer.c,vlc_timer_create,,false,109,135,vlc_timer_create,,,4,"int vlc_timer_create (vlc_timer_t*,void,void*)"
173768,METHOD,posix\timer.c:<global>,TYPE_DECL,"void vlc_timer_destroy (vlc_timer_t timer)
{
    vlc_cancel (timer->thread);
    vlc_join (timer->thread, NULL);
    vlc_cond_destroy (&timer->reschedule);
    vlc_mutex_destroy (&timer->lock);
    free (timer);
}",1,1,posix\timer.c,vlc_timer_destroy,,false,137,144,vlc_timer_destroy,,,5,void vlc_timer_destroy (vlc_timer_t)
173794,METHOD,posix\timer.c:<global>,TYPE_DECL,"void vlc_timer_schedule (vlc_timer_t timer, bool absolute,
                         mtime_t value, mtime_t interval)
{
    if (value == 0)
        interval = 0;
    else
    if (!absolute)
        value += mdate();

    vlc_mutex_lock (&timer->lock);
    timer->value = value;
    timer->interval = interval;
    vlc_cond_signal (&timer->reschedule);
    vlc_mutex_unlock (&timer->lock);
}",1,1,posix\timer.c,vlc_timer_schedule,,false,146,160,vlc_timer_schedule,,,6,"void vlc_timer_schedule (vlc_timer_t,bool,mtime_t,mtime_t)"
173844,METHOD,posix\timer.c:<global>,TYPE_DECL,"unsigned vlc_timer_getoverrun (vlc_timer_t timer)
{
    return atomic_exchange_explicit (&timer->overruns, 0,
                                     memory_order_relaxed);
}",1,1,posix\timer.c,vlc_timer_getoverrun,,false,162,166,vlc_timer_getoverrun,,,7,unsigned vlc_timer_getoverrun (vlc_timer_t)
173884,METHOD,stream_output\sap.c:<global>,TYPE_DECL,<global>,1,1,stream_output\sap.c,stream_output\sap.c:<global>,,false,1,422,<global>,,,1,
173905,METHOD,<empty>,<empty>,<empty>,1,,stream_output\sap.c,sap_address_t:<clinit>,,false,57,,<clinit>,,,14,
173921,METHOD,stream_output\sap.c:<global>,TYPE_DECL,static void *RunThread (void *);,22,40,stream_output\sap.c,RunThread,,false,82,82,RunThread,,,9,void* RunThread (void*)
173926,METHOD,stream_output\sap.c:<global>,TYPE_DECL,"static sap_address_t *AddressCreate (vlc_object_t *obj, const char *group)
{
    int fd = net_ConnectUDP (obj, group, IPPORT_SAP, 255);
    if (fd == -1)
        return NULL;

    sap_address_t *addr = malloc (sizeof (*addr));
    if (addr == NULL)
    {
        net_Close (fd);
        return NULL;
    }

    strlcpy (addr->group, group, sizeof (addr->group));
    addr->fd = fd;
    addr->origlen = sizeof (addr->orig);
    getsockname (fd, (struct sockaddr *)&addr->orig, &addr->origlen);

    addr->interval = var_CreateGetInteger (obj, ""sap-interval"");
    vlc_mutex_init (&addr->lock);
    vlc_cond_init (&addr->wait);
    addr->session_count = 0;
    addr->first = NULL;

    if (vlc_clone (&addr->thread, RunThread, addr, VLC_THREAD_PRIORITY_LOW))
    {
        msg_Err (obj, ""unable to spawn SAP announce thread"");
        net_Close (fd);
        free (addr);
        return NULL;
    }
    return addr;
}",1,41,stream_output\sap.c,AddressCreate,,false,84,116,AddressCreate,,,10,"sap_address_t AddressCreate (vlc_object_t*,char*)"
174048,METHOD,stream_output\sap.c:<global>,TYPE_DECL,"static void AddressDestroy (sap_address_t *addr)
{
    assert (addr->first == NULL);

    vlc_cancel (addr->thread);
    vlc_join (addr->thread, NULL);
    vlc_cond_destroy (&addr->wait);
    vlc_mutex_destroy (&addr->lock);
    net_Close (addr->fd);
    free (addr);
}",1,1,stream_output\sap.c,AddressDestroy,,false,118,128,AddressDestroy,,,11,void AddressDestroy (sap_address_t*)
174085,METHOD,stream_output\sap.c:<global>,TYPE_DECL,"static void *RunThread (void *self)
{
    sap_address_t *addr = self;

    vlc_mutex_lock (&addr->lock);
    mutex_cleanup_push (&addr->lock);

    for (;;)
    {
        session_descriptor_t *p_session;
        mtime_t deadline;

        while (addr->first == NULL)
            vlc_cond_wait (&addr->wait, &addr->lock);

        assert (addr->session_count > 0);

        deadline = mdate ();
        for (p_session = addr->first; p_session; p_session = p_session->next)
        {
            send (addr->fd, p_session->data, p_session->length, 0);
            deadline += addr->interval * CLOCK_FREQ / addr->session_count;

            if (vlc_cond_timedwait (&addr->wait, &addr->lock, deadline) == 0)
                break; /* list may have changed! */
        }
    }

    vlc_cleanup_pop ();
    vlc_assert_unreachable ();
}",10,1,stream_output\sap.c,RunThread,,false,135,165,RunThread,,,13,void* RunThread (void*)
174186,METHOD,stream_output\sap.c:<global>,TYPE_DECL,"session_descriptor_t *
sout_AnnounceRegisterSDP (vlc_object_t *obj, const char *sdp,
                          const char *dst)
{
    int i;
    char psz_addr[NI_MAXNUMERICHOST];
    union
    {
        struct sockaddr     a;
        struct sockaddr_in  in;
        struct sockaddr_in6 in6;
    } addr;
    socklen_t addrlen = 0;
    struct addrinfo *res;

    msg_Dbg (obj, ""adding SAP session"");

    if (vlc_getaddrinfo (dst, 0, NULL, &res) == 0)
    {
        if (res->ai_addrlen <= sizeof (addr))
            memcpy (&addr, res->ai_addr, res->ai_addrlen);
        addrlen = res->ai_addrlen;
        freeaddrinfo (res);
    }

    if (addrlen == 0 || addrlen > sizeof (addr))
    {
        msg_Err (obj, ""No/invalid address specified for SAP announce"" );
        return NULL;
    }

    /* Determine SAP multicast address automatically */
    switch (addr.a.sa_family)
    {
#if defined (HAVE_INET_PTON) || defined (_WIN32)
        case AF_INET6:
        {
            /* See RFC3513 for list ...",1,1,stream_output\sap.c,sout_AnnounceRegisterSDP,,false,176,365,sout_AnnounceRegisterSDP,,,14,"session_descriptor_t sout_AnnounceRegisterSDP (vlc_object_t*,char*,char*)"
174590,METHOD,stream_output\sap.c:<global>,TYPE_DECL,"void sout_AnnounceUnRegister (vlc_object_t *obj, session_descriptor_t *session)
{
    sap_address_t *addr, **paddr;
    session_descriptor_t **psession;

    msg_Dbg (obj, ""removing SAP session"");
    vlc_mutex_lock (&sap_mutex);
    paddr = &sap_addrs;
    for (;;)
    {
        addr = *paddr;
        assert (addr != NULL);

        psession = &addr->first;
        vlc_mutex_lock (&addr->lock);
        while (*psession != NULL)
        {
            if (*psession == session)
                goto found;
            psession = &(*psession)->next;
        }
        vlc_mutex_unlock (&addr->lock);
        paddr = &addr->next;
    }

found:
    *psession = session->next;

    if (addr->first == NULL)
        /* Last session for this address -> unlink the address */
        *paddr = addr->next;
    vlc_mutex_unlock (&sap_mutex);

    if (addr->first == NULL)
    {
        /* Last session for this address -> unlink the address */
        vlc_mutex_unlock (&addr->lock);
        AddressDest...",1,1,stream_output\sap.c,sout_AnnounceUnRegister,,false,374,422,sout_AnnounceUnRegister,,,15,"void sout_AnnounceUnRegister (vlc_object_t*,session_descriptor_t*)"
174746,METHOD,stream_output\sdp.c:<global>,TYPE_DECL,<global>,1,1,stream_output\sdp.c,stream_output\sdp.c:<global>,,false,1,267,<global>,,,1,
174748,METHOD,stream_output\sdp.c:<global>,TYPE_DECL,"static
char *AddressToSDP (const struct sockaddr *addr, socklen_t addrlen, char *buf)
{
    if (addrlen < offsetof (struct sockaddr, sa_family)
                 + sizeof (addr->sa_family))
        return NULL;

    strcpy (buf, ""IN IP* "");

    if (vlc_getnameinfo (addr, addrlen, buf + 7, MAXSDPADDRESS - 7, NULL,
                         NI_NUMERICHOST))
        return NULL;

    switch (addr->sa_family)
    {
        case AF_INET:
        {
            if (net_SockAddrIsMulticast (addr, addrlen))
                strcat (buf, ""/255""); // obsolete in RFC4566, dummy value
            buf[5] = '4';
            break;
        }

#ifdef AF_INET6
        case AF_INET6:
        {
            char *ptr = strchr (buf, '%');
            if (ptr != NULL)
                *ptr = '\0'; // remove scope ID
            buf[5] = '6';
            break;
        }
#endif

        default:
            return NULL;
    }

    return buf;
}",1,49,stream_output\sdp.c,AddressToSDP,,false,41,80,AddressToSDP,,,1,"char* AddressToSDP (sockaddr*,socklen_t,char*)"
174807,METHOD,stream_output\sdp.c:<global>,TYPE_DECL,"static bool IsSDPString (const char *str)
{
    if (strchr (str, '\r') != NULL)
        return false;
    if (strchr (str, '\n') != NULL)
        return false;
    if (!IsUTF8 (str))
        return false;
    return true;
}",1,1,stream_output\sdp.c,IsSDPString,,false,83,92,IsSDPString,,,2,bool IsSDPString (char*)
174839,METHOD,stream_output\sdp.c:<global>,TYPE_DECL,"static void vsdp_AddAttribute(struct vlc_memstream *restrict stream,
                              const char *name, const char *fmt, va_list ap)
{
    vlc_memstream_printf(stream, ""a=%s:"", name);
    vlc_memstream_vprintf(stream, fmt, ap);
    vlc_memstream_puts(stream, ""\r\n"");
}",1,1,stream_output\sdp.c,vsdp_AddAttribute,,false,94,100,vsdp_AddAttribute,,,3,"void vsdp_AddAttribute (vlc_memstream*,char*,char*,va_list)"
174858,METHOD,stream_output\sdp.c:<global>,TYPE_DECL,"void sdp_AddAttribute(struct vlc_memstream *restrict stream, const char *name,
                      const char *fmt, ...)
{
    va_list ap;

    va_start(ap, fmt);
    vsdp_AddAttribute(stream, name, fmt, ap);
    va_end(ap);
}",1,1,stream_output\sdp.c,sdp_AddAttribute,,false,102,110,sdp_AddAttribute,,,4,"void sdp_AddAttribute (vlc_memstream*,char*,char*...)"
174876,METHOD,stream_output\sdp.c:<global>,TYPE_DECL,"void sdp_AddMedia(struct vlc_memstream *restrict stream,
                  const char *type, const char *proto, int dport,
                  unsigned pt, bool bw_indep, unsigned bw,
                  const char *ptname, unsigned clock, unsigned chans,
                  const char *fmtp)
{
    /* Some default values */
    if (type == NULL)
        type = ""video"";
    if (proto == NULL)
        proto = ""RTP/AVP"";
    assert (pt < 128u);

    vlc_memstream_printf(stream, ""m=%s %u %s %u\r\n"", type, dport, proto, pt);

    if (bw > 0)
        vlc_memstream_printf(stream, ""b=%s:%u\r\n"",
                             bw_indep ? ""TIAS"" : ""AS"", bw);
    vlc_memstream_printf(stream, ""b=%s:%u\r\n"", ""RR"", 0);

    /* RTP payload type map */
    if (ptname != NULL)
    {
        vlc_memstream_printf(stream, ""a=rtpmap:%u %s/%u"", pt, ptname, clock);
        if ((strcmp(type, ""audio"") == 0) && (chans != 1))
            vlc_memstream_printf(stream, ""/%u"", chans);
        vlc_memstream_puts(stream, ""...",1,1,stream_output\sdp.c,sdp_AddMedia,,false,112,144,sdp_AddMedia,,,5,"void sdp_AddMedia (vlc_memstream*,char*,char*,int,unsigned,bool,unsigned,char*,unsigned,unsigned,char*)"
174975,METHOD,stream_output\sdp.c:<global>,TYPE_DECL,"int vlc_sdp_Start(struct vlc_memstream *restrict stream,
                  vlc_object_t *obj, const char *cfgpref,
                  const struct sockaddr *src, size_t srclen,
                  const struct sockaddr *addr, size_t addrlen)
{
    char connection[MAXSDPADDRESS];
    char *str = NULL;

    size_t cfglen = strlen(cfgpref);
    if (cfglen >= 128)
        return -1;

    char varname[cfglen + sizeof (""description"")];
    char *subvar = varname + cfglen;

    strcpy(varname, cfgpref);

    vlc_memstream_open(stream);
    vlc_memstream_puts(stream, ""v=0\r\n"");

    if (AddressToSDP(addr, addrlen, connection) == NULL)
        goto error;
    {
        const uint_fast64_t now = NTPtime64();
        char hostname[256];

        gethostname(hostname, sizeof (hostname));

        vlc_memstream_printf(stream, ""o=- %""PRIu64"" %""PRIu64"" IN IP%c %s\r\n"",
                             now, now, connection[5], hostname);
    }

    strcpy(subvar, ""name"");
    str = var_GetNonEmptyString(...",1,20,stream_output\sdp.c,vlc_sdp_Start,,false,146,267,vlc_sdp_Start,,,6,"int vlc_sdp_Start (vlc_memstream*,vlc_object_t*,char*,sockaddr*,size_t,sockaddr*,size_t)"
175269,METHOD,stream_output\stream_output.c:<global>,TYPE_DECL,<global>,1,1,stream_output\stream_output.c,stream_output\stream_output.c:<global>,,false,1,969,<global>,,,1,
175271,METHOD,stream_output\stream_output.c:<global>,TYPE_DECL,"static char *sout_stream_url_to_chain( bool, const char * );",13,59,stream_output\stream_output.c,sout_stream_url_to_chain,,false,57,57,sout_stream_url_to_chain,,,1,"char* sout_stream_url_to_chain (ANY,char*)"
175282,METHOD,stream_output\stream_output.c:<global>,TYPE_DECL,"static int  mrl_Parse( mrl_t *p_mrl, const char *psz_mrl );",13,58,stream_output\stream_output.c,mrl_Parse,,false,72,72,mrl_Parse,,,4,"int mrl_Parse (mrl_t*,char*)"
175288,METHOD,stream_output\stream_output.c:<global>,TYPE_DECL,static void mrl_Clean( mrl_t *p_mrl );,13,37,stream_output\stream_output.c,mrl_Clean,,false,74,74,mrl_Clean,,,5,void mrl_Clean (mrl_t*)
175293,METHOD,stream_output\stream_output.c:<global>,TYPE_DECL,"sout_instance_t *sout_NewInstance( vlc_object_t *p_parent, const char *psz_dest )
{
    sout_instance_t *p_sout;
    char *psz_chain;

    assert( psz_dest != NULL );

    if( psz_dest[0] == '#' )
    {
        psz_chain = strdup( &psz_dest[1] );
    }
    else
    {
        psz_chain = sout_stream_url_to_chain(
            var_InheritBool(p_parent, ""sout-display""), psz_dest );
    }
    if(!psz_chain)
        return NULL;

    /* *** Allocate descriptor *** */
    p_sout = vlc_custom_create( p_parent, sizeof( *p_sout ), ""stream output"" );
    if( p_sout == NULL )
    {
        free( psz_chain );
        return NULL;
    }

    msg_Dbg( p_sout, ""using sout chain=`%s'"", psz_chain );

    /* *** init descriptor *** */
    p_sout->psz_sout    = strdup( psz_dest );
    p_sout->i_out_pace_nocontrol = 0;

    vlc_mutex_init( &p_sout->lock );
    p_sout->p_stream = NULL;

    var_Create( p_sout, ""sout-mux-caching"", VLC_VAR_INTEGER | VLC_VAR_DOINHERIT );

    p_sout->p_stream = sout_StreamC...",1,1,stream_output\stream_output.c,sout_NewInstance,,false,81,134,sout_NewInstance,,,6,"sout_instance_t sout_NewInstance (vlc_object_t*,char*)"
175419,METHOD,stream_output\stream_output.c:<global>,TYPE_DECL,"void sout_DeleteInstance( sout_instance_t * p_sout )
{
    /* remove the stream out chain */
    sout_StreamChainDelete( p_sout->p_stream, NULL );

    /* *** free all string *** */
    FREENULL( p_sout->psz_sout );

    vlc_mutex_destroy( &p_sout->lock );

    /* *** free structure *** */
    vlc_object_release( p_sout );
}",1,1,stream_output\stream_output.c,sout_DeleteInstance,,false,139,151,sout_DeleteInstance,,,7,void sout_DeleteInstance (sout_instance_t*)
175440,METHOD,stream_output\stream_output.c:<global>,TYPE_DECL,"sout_packetizer_input_t *sout_InputNew( sout_instance_t *p_sout,
                                        const es_format_t *p_fmt )
{
    sout_packetizer_input_t *p_input;

    /* *** create a packetizer input *** */
    if( !p_fmt->i_codec || !(p_input = malloc(sizeof(sout_packetizer_input_t))) )
        return NULL;

    p_input->p_sout = p_sout;

    msg_Dbg( p_sout, ""adding a new sout input for `%4.4s` (sout_input: %p)"",
             (char*) &p_fmt->i_codec, (void *)p_input );

    /* *** add it to the stream chain */
    vlc_mutex_lock( &p_sout->lock );
    p_input->id = p_sout->p_stream->pf_add( p_sout->p_stream, p_fmt );
    vlc_mutex_unlock( &p_sout->lock );

    if( p_input->id == NULL )
    {
        msg_Warn( p_sout, ""new sout input failed (sout_input: %p)"",
                 (void *)p_input );
        free( p_input );
        p_input = NULL;
    }

    return( p_input );
}",1,1,stream_output\stream_output.c,sout_InputNew,,false,156,184,sout_InputNew,,,8,"sout_packetizer_input_t sout_InputNew (sout_instance_t*,es_format_t*)"
175523,METHOD,stream_output\stream_output.c:<global>,TYPE_DECL,"int sout_InputDelete( sout_packetizer_input_t *p_input )
{
    sout_instance_t     *p_sout = p_input->p_sout;

    msg_Dbg( p_sout, ""removing a sout input (sout_input: %p)"",
             (void *)p_input );

    vlc_mutex_lock( &p_sout->lock );
    p_sout->p_stream->pf_del( p_sout->p_stream, p_input->id );
    vlc_mutex_unlock( &p_sout->lock );

    free( p_input );

    return( VLC_SUCCESS);
}",1,1,stream_output\stream_output.c,sout_InputDelete,,false,189,203,sout_InputDelete,,,9,int sout_InputDelete (sout_packetizer_input_t*)
175566,METHOD,stream_output\stream_output.c:<global>,TYPE_DECL,"bool sout_InputIsEmpty( sout_packetizer_input_t *p_input )
{
    sout_instance_t *p_sout = p_input->p_sout;
    bool b;

    vlc_mutex_lock( &p_sout->lock );
    if( sout_StreamControl( p_sout->p_stream, SOUT_STREAM_EMPTY, &b ) != VLC_SUCCESS )
        b = true;
    vlc_mutex_unlock( &p_sout->lock );
    return b;
}",1,1,stream_output\stream_output.c,sout_InputIsEmpty,,false,205,215,sout_InputIsEmpty,,,10,bool sout_InputIsEmpty (sout_packetizer_input_t*)
175604,METHOD,stream_output\stream_output.c:<global>,TYPE_DECL,"void sout_InputFlush( sout_packetizer_input_t *p_input )
{
    sout_instance_t     *p_sout = p_input->p_sout;

    vlc_mutex_lock( &p_sout->lock );
    sout_StreamFlush( p_sout->p_stream, p_input->id );
    vlc_mutex_unlock( &p_sout->lock );
}",1,1,stream_output\stream_output.c,sout_InputFlush,,false,217,224,sout_InputFlush,,,11,void sout_InputFlush (sout_packetizer_input_t*)
175632,METHOD,stream_output\stream_output.c:<global>,TYPE_DECL,"int sout_InputSendBuffer( sout_packetizer_input_t *p_input,
                          block_t *p_buffer )
{
    sout_instance_t     *p_sout = p_input->p_sout;
    int                 i_ret;

    vlc_mutex_lock( &p_sout->lock );
    i_ret = p_sout->p_stream->pf_send( p_sout->p_stream,
                                       p_input->id, p_buffer );
    vlc_mutex_unlock( &p_sout->lock );

    return i_ret;
}",1,1,stream_output\stream_output.c,sout_InputSendBuffer,,false,229,241,sout_InputSendBuffer,,,12,"int sout_InputSendBuffer (sout_packetizer_input_t*,block_t*)"
175672,METHOD,stream_output\stream_output.c:<global>,TYPE_DECL,"sout_access_out_t *sout_AccessOutNew( vlc_object_t *p_sout,
                                      const char *psz_access, const char *psz_name )
{
    sout_access_out_t *p_access;
    char              *psz_next;

    p_access = vlc_custom_create( p_sout, sizeof( *p_access ), ""access out"" );
    if( !p_access )
        return NULL;

    psz_next = config_ChainCreate( &p_access->psz_access, &p_access->p_cfg,
                                   psz_access );
    free( psz_next );
    p_access->psz_path   = strdup( psz_name ? psz_name : """" );
    p_access->p_sys      = NULL;
    p_access->pf_seek    = NULL;
    p_access->pf_read    = NULL;
    p_access->pf_write   = NULL;
    p_access->pf_control = NULL;
    p_access->p_module   = NULL;

    p_access->p_module   =
        module_need( p_access, ""sout access"", p_access->psz_access, true );

    if( !p_access->p_module )
    {
        free( p_access->psz_access );
        free( p_access->psz_path );
        vlc_object_release( p_access );...",1,1,stream_output\stream_output.c,sout_AccessOutNew,,false,247,280,sout_AccessOutNew,,,13,"sout_access_out_t sout_AccessOutNew (vlc_object_t*,char*,char*)"
175779,METHOD,stream_output\stream_output.c:<global>,TYPE_DECL,"void sout_AccessOutDelete( sout_access_out_t *p_access )
{
    if( p_access->p_module )
    {
        module_unneed( p_access, p_access->p_module );
    }
    free( p_access->psz_access );

    config_ChainDestroy( p_access->p_cfg );

    free( p_access->psz_path );

    vlc_object_release( p_access );
}",1,1,stream_output\stream_output.c,sout_AccessOutDelete,,false,284,297,sout_AccessOutDelete,,,14,void sout_AccessOutDelete (sout_access_out_t*)
175808,METHOD,stream_output\stream_output.c:<global>,TYPE_DECL,"int sout_AccessOutSeek( sout_access_out_t *p_access, off_t i_pos )
{
    if (p_access->pf_seek == NULL)
        return VLC_EGENERIC;
    return p_access->pf_seek( p_access, i_pos );
}",1,1,stream_output\stream_output.c,sout_AccessOutSeek,,false,302,307,sout_AccessOutSeek,,,15,"int sout_AccessOutSeek (sout_access_out_t*,off_t)"
175830,METHOD,stream_output\stream_output.c:<global>,TYPE_DECL,"ssize_t sout_AccessOutRead( sout_access_out_t *p_access, block_t *p_buffer )
{
    return( p_access->pf_read ?
            p_access->pf_read( p_access, p_buffer ) : VLC_EGENERIC );
}",1,1,stream_output\stream_output.c,sout_AccessOutRead,,false,312,316,sout_AccessOutRead,,,16,"ssize_t sout_AccessOutRead (sout_access_out_t*,block_t*)"
175848,METHOD,stream_output\stream_output.c:<global>,TYPE_DECL,"ssize_t sout_AccessOutWrite( sout_access_out_t *p_access, block_t *p_buffer )
{
    return p_access->pf_write( p_access, p_buffer );
}",1,1,stream_output\stream_output.c,sout_AccessOutWrite,,false,321,324,sout_AccessOutWrite,,,17,"ssize_t sout_AccessOutWrite (sout_access_out_t*,block_t*)"
175861,METHOD,stream_output\stream_output.c:<global>,TYPE_DECL,"int sout_AccessOutControl (sout_access_out_t *access, int query, ...)
{
    va_list ap;
    int ret;

    va_start (ap, query);
    if (access->pf_control)
        ret = access->pf_control (access, query, ap);
    else
        ret = VLC_EGENERIC;
    va_end (ap);
    return ret;
}",1,1,stream_output\stream_output.c,sout_AccessOutControl,,false,329,341,sout_AccessOutControl,,,18,"int sout_AccessOutControl (sout_access_out_t*,int...)"
175895,METHOD,stream_output\stream_output.c:<global>,TYPE_DECL,"sout_mux_t * sout_MuxNew( sout_instance_t *p_sout, const char *psz_mux,
                          sout_access_out_t *p_access )
{
    sout_mux_t *p_mux;
    char       *psz_next;

    p_mux = vlc_custom_create( p_sout, sizeof( *p_mux ), ""mux"" );
    if( p_mux == NULL )
        return NULL;

    p_mux->p_sout = p_sout;
    psz_next = config_ChainCreate( &p_mux->psz_mux, &p_mux->p_cfg, psz_mux );
    free( psz_next );

    p_mux->p_access     = p_access;
    p_mux->pf_control   = NULL;
    p_mux->pf_addstream = NULL;
    p_mux->pf_delstream = NULL;
    p_mux->pf_mux       = NULL;
    p_mux->i_nb_inputs  = 0;
    p_mux->pp_inputs    = NULL;

    p_mux->p_sys        = NULL;
    p_mux->p_module     = NULL;

    p_mux->b_add_stream_any_time = false;
    p_mux->b_waiting_stream = true;
    p_mux->i_add_stream_start = -1;

    p_mux->p_module =
        module_need( p_mux, ""sout mux"", p_mux->psz_mux, true );

    if( p_mux->p_module == NULL )
    {
        FREENULL( p_mux->psz_mux );

      ...",1,1,stream_output\stream_output.c,sout_MuxNew,,false,346,425,sout_MuxNew,,,19,"sout_mux_t sout_MuxNew (sout_instance_t*,char*,sout_access_out_t*)"
176094,METHOD,stream_output\stream_output.c:<global>,TYPE_DECL,"void sout_MuxDelete( sout_mux_t *p_mux )
{
    if( p_mux->p_module )
    {
        module_unneed( p_mux, p_mux->p_module );
    }
    free( p_mux->psz_mux );

    config_ChainDestroy( p_mux->p_cfg );

    vlc_object_release( p_mux );
}",1,1,stream_output\stream_output.c,sout_MuxDelete,,false,430,441,sout_MuxDelete,,,20,void sout_MuxDelete (sout_mux_t*)
176119,METHOD,stream_output\stream_output.c:<global>,TYPE_DECL,"sout_input_t *sout_MuxAddStream( sout_mux_t *p_mux, const es_format_t *p_fmt )
{
    sout_input_t *p_input;

    if( !p_mux->b_add_stream_any_time && !p_mux->b_waiting_stream )
    {
        msg_Err( p_mux, ""cannot add a new stream (unsupported while muxing ""
                        ""to this format). You can try increasing sout-mux-caching value"" );
        return NULL;
    }

    msg_Dbg( p_mux, ""adding a new input"" );

    /* create a new sout input */
    p_input = malloc( sizeof( sout_input_t ) );
    if( !p_input )
        return NULL;

    // FIXME: remove either fmt or p_fmt...
    es_format_Copy( &p_input->fmt, p_fmt );
    p_input->p_fmt = &p_input->fmt;

    p_input->p_fifo = block_FifoNew();
    p_input->p_sys  = NULL;

    TAB_APPEND( p_mux->i_nb_inputs, p_mux->pp_inputs, p_input );
    if( p_mux->pf_addstream( p_mux, p_input ) < 0 )
    {
        msg_Err( p_mux, ""cannot add this stream"" );
        TAB_REMOVE( p_mux->i_nb_inputs, p_mux->pp_inputs, p_input );
        bloc...",1,1,stream_output\stream_output.c,sout_MuxAddStream,,false,446,483,sout_MuxAddStream,,,21,"sout_input_t sout_MuxAddStream (sout_mux_t*,es_format_t*)"
176224,METHOD,stream_output\stream_output.c:<global>,TYPE_DECL,"void sout_MuxDeleteStream( sout_mux_t *p_mux, sout_input_t *p_input )
{
    int i_index;

    if( p_mux->b_waiting_stream
     && block_FifoCount( p_input->p_fifo ) > 0 )
    {
        /* We stop waiting, and call the muxer for taking care of the data
         * before we remove this es */
        p_mux->b_waiting_stream = false;
        p_mux->pf_mux( p_mux );
    }

    TAB_FIND( p_mux->i_nb_inputs, p_mux->pp_inputs, p_input, i_index );
    if( i_index >= 0 )
    {
        p_mux->pf_delstream( p_mux, p_input );

        /* remove the entry */
        TAB_REMOVE( p_mux->i_nb_inputs, p_mux->pp_inputs, p_input );

        if( p_mux->i_nb_inputs == 0 )
        {
            msg_Warn( p_mux, ""no more input streams for this mux"" );
        }

        block_FifoRelease( p_input->p_fifo );
        es_format_Clean( &p_input->fmt );
        free( p_input );
    }
}",1,1,stream_output\stream_output.c,sout_MuxDeleteStream,,false,488,518,sout_MuxDeleteStream,,,22,"void sout_MuxDeleteStream (sout_mux_t*,sout_input_t*)"
176302,METHOD,stream_output\stream_output.c:<global>,TYPE_DECL,"int sout_MuxSendBuffer( sout_mux_t *p_mux, sout_input_t *p_input,
                         block_t *p_buffer )
{
    mtime_t i_dts = p_buffer->i_dts;
    block_FifoPut( p_input->p_fifo, p_buffer );

    if( p_mux->p_sout->i_out_pace_nocontrol )
    {
        mtime_t current_date = mdate();
        if ( current_date > i_dts )
            msg_Warn( p_mux, ""late buffer for mux input (%""PRId64"")"",
                      current_date - i_dts );
    }

    if( p_mux->b_waiting_stream )
    {
        const int64_t i_caching = var_GetInteger( p_mux->p_sout, ""sout-mux-caching"" ) * INT64_C(1000);

        if( p_mux->i_add_stream_start < 0 )
            p_mux->i_add_stream_start = i_dts;

        /* Wait until we have enough data before muxing */
        if( p_mux->i_add_stream_start < 0 ||
            i_dts < p_mux->i_add_stream_start + i_caching )
            return VLC_SUCCESS;
        p_mux->b_waiting_stream = false;
    }
    return p_mux->pf_mux( p_mux );
}",1,1,stream_output\stream_output.c,sout_MuxSendBuffer,,false,523,551,sout_MuxSendBuffer,,,23,"int sout_MuxSendBuffer (sout_mux_t*,sout_input_t*,block_t*)"
176388,METHOD,stream_output\stream_output.c:<global>,TYPE_DECL,"void sout_MuxFlush( sout_mux_t *p_mux, sout_input_t *p_input )
{
    VLC_UNUSED(p_mux);
    block_FifoEmpty( p_input->p_fifo );
}",1,1,stream_output\stream_output.c,sout_MuxFlush,,false,553,557,sout_MuxFlush,,,24,"void sout_MuxFlush (sout_mux_t*,sout_input_t*)"
176400,METHOD,stream_output\stream_output.c:<global>,TYPE_DECL,"int sout_MuxGetStream( sout_mux_t *p_mux, unsigned i_blocks, mtime_t *pi_dts )
{
    mtime_t i_dts = 0;
    int     i_stream = -1;

    assert( i_blocks > 0 );

    for( int i = 0; i < p_mux->i_nb_inputs; i++ )
    {
        sout_input_t *p_input = p_mux->pp_inputs[i];
        block_t *p_data;

        if( block_FifoCount( p_input->p_fifo ) < i_blocks )
        {
            if( (!p_mux->b_add_stream_any_time) &&
                (p_input->p_fmt->i_cat != SPU_ES ) )
            {
                return -1;
            }
            /* FIXME: SPU muxing */
            continue;
        }

        p_data = block_FifoShow( p_input->p_fifo );
        if( i_stream < 0 || p_data->i_dts < i_dts )
        {
            i_stream = i;
            i_dts    = p_data->i_dts;
        }
    }

    if( pi_dts ) *pi_dts = i_dts;

    return i_stream;
}",1,1,stream_output\stream_output.c,sout_MuxGetStream,,false,562,596,sout_MuxGetStream,,,25,"int sout_MuxGetStream (sout_mux_t*,unsigned,mtime_t*)"
176503,METHOD,stream_output\stream_output.c:<global>,TYPE_DECL,"static int mrl_Parse( mrl_t *p_mrl, const char *psz_mrl )
{
    char * psz_dup = strdup( psz_mrl );
    char * psz_parser = psz_dup;
    const char * psz_access;
    const char * psz_way;
    char * psz_name;

    /* *** first parse psz_dest */
    while( *psz_parser && *psz_parser != ':' )
    {
        if( *psz_parser == '{' )
        {
            while( *psz_parser && *psz_parser != '}' )
            {
                psz_parser++;
            }
            if( *psz_parser )
            {
                psz_parser++;
            }
        }
        else
        {
            psz_parser++;
        }
    }
#if defined( _WIN32 ) || defined( __OS2__ )
    if( psz_parser - psz_dup == 1 )
    {
        /* msg_Warn( p_sout, ""drive letter %c: found in source string"",
                          *psz_dup ) ; */
        *psz_parser = '\0';
    }
#endif

    if( !*psz_parser )
    {
        psz_access = psz_way = """";
        psz_name = psz_dup;
    }
    else
    {
        *psz_parser++ = '...",1,1,stream_output\stream_output.c,mrl_Parse,,false,602,715,mrl_Parse,,,26,"int mrl_Parse (mrl_t*,char*)"
176707,METHOD,stream_output\stream_output.c:<global>,TYPE_DECL,"static void mrl_Clean( mrl_t *p_mrl )
{
    FREENULL( p_mrl->psz_access );
    FREENULL( p_mrl->psz_way );
    FREENULL( p_mrl->psz_name );
}",1,1,stream_output\stream_output.c,mrl_Clean,,false,719,724,mrl_Clean,,,27,void mrl_Clean (mrl_t*)
176724,METHOD,stream_output\stream_output.c:<global>,TYPE_DECL,"static void sout_StreamDelete( sout_stream_t *p_stream )
{
    sout_instance_t *p_sout = (sout_instance_t *)(p_stream->obj.parent);

    msg_Dbg( p_stream, ""destroying chain... (name=%s)"", p_stream->psz_name );

    p_sout->i_out_pace_nocontrol -= p_stream->pace_nocontrol;

    if( p_stream->p_module != NULL )
        module_unneed( p_stream, p_stream->p_module );

    FREENULL( p_stream->psz_name );

    config_ChainDestroy( p_stream->p_cfg );

    msg_Dbg( p_stream, ""destroying chain done"" );
    vlc_object_release( p_stream );
}",1,1,stream_output\stream_output.c,sout_StreamDelete,,false,736,753,sout_StreamDelete,,,28,void sout_StreamDelete (sout_stream_t*)
176777,METHOD,stream_output\stream_output.c:<global>,TYPE_DECL,"void sout_StreamChainDelete(sout_stream_t *p_first, sout_stream_t *p_last)
{
    while(p_first != NULL)
    {
        sout_stream_t *p_next = p_first->p_next;

        sout_StreamDelete(p_first);
        if(p_first == p_last)
           break;
        p_first = p_next;
    }
}",1,1,stream_output\stream_output.c,sout_StreamChainDelete,,false,762,773,sout_StreamChainDelete,,,29,"void sout_StreamChainDelete (sout_stream_t*,sout_stream_t*)"
176805,METHOD,stream_output\stream_output.c:<global>,TYPE_DECL,"static sout_stream_t *sout_StreamNew( sout_instance_t *p_sout, char *psz_name,
                               config_chain_t *p_cfg, sout_stream_t *p_next)
{
    sout_stream_t *p_stream;

    assert(psz_name);

    p_stream = vlc_custom_create( p_sout, sizeof( *p_stream ), ""stream out"" );
    if( !p_stream )
        return NULL;

    p_stream->p_sout   = p_sout;
    p_stream->psz_name = psz_name;
    p_stream->p_cfg    = p_cfg;
    p_stream->p_next   = p_next;
    p_stream->pf_flush = NULL;
    p_stream->pf_control = NULL;
    p_stream->pace_nocontrol = false;
    p_stream->p_sys = NULL;

    msg_Dbg( p_sout, ""stream=`%s'"", p_stream->psz_name );

    p_stream->p_module =
        module_need( p_stream, ""sout stream"", p_stream->psz_name, true );

    if( !p_stream->p_module )
    {
        /* those must be freed by the caller if creation failed */
        p_stream->psz_name = NULL;
        p_stream->p_cfg = NULL;

        sout_StreamDelete( p_stream );
        return NULL;
    }

    ...",1,1,stream_output\stream_output.c,sout_StreamNew,,false,779,816,sout_StreamNew,,,30,"sout_stream_t sout_StreamNew (sout_instance_t*,char*,config_chain_t*,sout_stream_t*)"
176916,METHOD,stream_output\stream_output.c:<global>,TYPE_DECL,"sout_stream_t *sout_StreamChainNew(sout_instance_t *p_sout, const char *psz_chain,
                                sout_stream_t *p_next, sout_stream_t **pp_last)
{
    if(!psz_chain || !*psz_chain)
    {
        if(pp_last) *pp_last = NULL;
        return p_next;
    }

    char *psz_parser = strdup(psz_chain);
    if(!psz_parser)
        return NULL;

    vlc_array_t cfg, name;
    vlc_array_init(&cfg);
    vlc_array_init(&name);

    /* parse chain */
    while(psz_parser)
    {
        config_chain_t *p_cfg;
        char *psz_name;
        char *psz_rest_chain = config_ChainCreate( &psz_name, &p_cfg, psz_parser );
        free( psz_parser );
        psz_parser = psz_rest_chain;

        vlc_array_append_or_abort(&cfg, p_cfg);
        vlc_array_append_or_abort(&name, psz_name);
    }

    size_t i = vlc_array_count(&name);
    vlc_array_t module;
    vlc_array_init(&module);
    while(i--)
    {
        p_next = sout_StreamNew( p_sout, vlc_array_item_at_index(&name, i),
         ...",1,1,stream_output\stream_output.c,sout_StreamChainNew,,false,829,903,sout_StreamChainNew,,,31,"sout_stream_t sout_StreamChainNew (sout_instance_t*,char*,sout_stream_t*,sout_stream_t**)"
177091,METHOD,stream_output\stream_output.c:<global>,TYPE_DECL,"static char *sout_stream_url_to_chain( bool b_sout_display,
                                       const char *psz_url )
{
    mrl_t       mrl;
    char        *psz_chain;

    mrl_Parse( &mrl, psz_url );

    /* Check if the URLs goes to #rtp - otherwise we'll use #standard */
    static const char rtplist[] = ""dccp\0sctp\0tcp\0udplite\0"";
    for (const char *a = rtplist; *a; a += strlen (a) + 1)
        if (strcmp (a, mrl.psz_access) == 0)
            goto rtp;

    if (strcmp (mrl.psz_access, ""rtp"") == 0)
    {
        char *port;
        /* For historical reasons, rtp:// means RTP over UDP */
        strcpy (mrl.psz_access, ""udp"");
rtp:
        if (mrl.psz_name[0] == '[')
        {
            port = strstr (mrl.psz_name, ""]:"");
            if (port != NULL)
                port++;
        }
        else
            port = strchr (mrl.psz_name, ':');
        if (port != NULL)
            *port++ = '\0'; /* erase ':' */

        if (asprintf (&psz_chain,
                      ""r...",1,1,stream_output\stream_output.c,sout_stream_url_to_chain,,false,905,963,sout_stream_url_to_chain,,,32,"char* sout_stream_url_to_chain (bool,char*)"
177270,METHOD,stream_output\stream_output.c:<global>,TYPE_DECL,"encoder_t *sout_EncoderCreate( vlc_object_t *p_this )
{
    return vlc_custom_create( p_this, sizeof( encoder_t ), ""encoder"" );
}",1,1,stream_output\stream_output.c,sout_EncoderCreate,,false,966,969,sout_EncoderCreate,,,33,encoder_t sout_EncoderCreate (vlc_object_t*)
177288,METHOD,stream_output\stream_output.h:<global>,TYPE_DECL,<global>,1,6,stream_output\stream_output.h,stream_output\stream_output.h:<global>,,false,1,53,<global>,,,1,
177293,METHOD,stream_output\stream_output.h:<global>,TYPE_DECL,"sout_instance_t *sout_NewInstance( vlc_object_t *, const char * );",17,65,stream_output\stream_output.h,sout_NewInstance,,false,43,43,sout_NewInstance,,,2,"sout_instance_t* sout_NewInstance (vlc_object_t*,char*)"
177299,METHOD,stream_output\stream_output.h:<global>,TYPE_DECL,void sout_DeleteInstance( sout_instance_t * );,6,45,stream_output\stream_output.h,sout_DeleteInstance,,false,45,45,sout_DeleteInstance,,,3,void sout_DeleteInstance (sout_instance_t*)
177304,METHOD,stream_output\stream_output.h:<global>,TYPE_DECL,"sout_packetizer_input_t *sout_InputNew( sout_instance_t *, const es_format_t * );",25,80,stream_output\stream_output.h,sout_InputNew,,false,47,47,sout_InputNew,,,4,"sout_packetizer_input_t* sout_InputNew (sout_instance_t*,es_format_t*)"
177310,METHOD,stream_output\stream_output.h:<global>,TYPE_DECL,int sout_InputDelete( sout_packetizer_input_t * );,5,49,stream_output\stream_output.h,sout_InputDelete,,false,48,48,sout_InputDelete,,,5,int sout_InputDelete (sout_packetizer_input_t*)
177315,METHOD,stream_output\stream_output.h:<global>,TYPE_DECL,"int sout_InputSendBuffer( sout_packetizer_input_t *, block_t* );",5,63,stream_output\stream_output.h,sout_InputSendBuffer,,false,49,49,sout_InputSendBuffer,,,6,"int sout_InputSendBuffer (sout_packetizer_input_t*,block_t*)"
177321,METHOD,stream_output\stream_output.h:<global>,TYPE_DECL,bool sout_InputIsEmpty(sout_packetizer_input_t *);,6,49,stream_output\stream_output.h,sout_InputIsEmpty,,false,50,50,sout_InputIsEmpty,,,7,bool sout_InputIsEmpty (sout_packetizer_input_t*)
177326,METHOD,stream_output\stream_output.h:<global>,TYPE_DECL,void sout_InputFlush( sout_packetizer_input_t * );,6,49,stream_output\stream_output.h,sout_InputFlush,,false,51,51,sout_InputFlush,,,8,void sout_InputFlush (sout_packetizer_input_t*)
177350,METHOD,text\charset.c:<global>,TYPE_DECL,<global>,1,1,text\charset.c,text\charset.c:<global>,,false,1,129,<global>,,,1,
177352,METHOD,text\charset.c:<global>,TYPE_DECL,"double us_strtod( const char *str, char **end )
{
    locale_t loc = newlocale (LC_NUMERIC_MASK, ""C"", NULL);
    locale_t oldloc = uselocale (loc);
    double res = strtod (str, end);

    if (loc != (locale_t)0)
    {
        uselocale (oldloc);
        freelocale (loc);
    }
    return res;
}",1,1,text\charset.c,us_strtod,,false,50,62,us_strtod,,,1,"double us_strtod (char*,char**)"
177389,METHOD,text\charset.c:<global>,TYPE_DECL,"float us_strtof( const char *str, char **end )
{
    locale_t loc = newlocale (LC_NUMERIC_MASK, ""C"", NULL);
    locale_t oldloc = uselocale (loc);
    float res = strtof (str, end);

    if (loc != (locale_t)0)
    {
        uselocale (oldloc);
        freelocale (loc);
    }
    return res;
}",1,1,text\charset.c,us_strtof,,false,69,81,us_strtof,,,2,"float us_strtof (char*,char**)"
177426,METHOD,text\charset.c:<global>,TYPE_DECL,"double us_atof( const char *str )
{
    return us_strtod( str, NULL );
}",1,1,text\charset.c,us_atof,,false,88,91,us_atof,,,3,double us_atof (char*)
177435,METHOD,text\charset.c:<global>,TYPE_DECL,"int us_vasprintf( char **ret, const char *format, va_list ap )
{
    locale_t loc = newlocale( LC_NUMERIC_MASK, ""C"", NULL );
    locale_t oldloc = uselocale( loc );

    int i_rc = vasprintf( ret, format, ap );

    if ( loc != (locale_t)0 )
    {
        uselocale( oldloc );
        freelocale( loc );
    }

    return i_rc;
}",1,1,text\charset.c,us_vasprintf,,false,98,112,us_vasprintf,,,4,"int us_vasprintf (char**,char*,va_list)"
177474,METHOD,text\charset.c:<global>,TYPE_DECL,"int us_asprintf( char **ret, const char *format, ... )
{
    va_list ap;
    int i_rc;

    va_start( ap, format );
    i_rc = us_vasprintf( ret, format, ap );
    va_end( ap );

    return i_rc;
}",1,1,text\charset.c,us_asprintf,,false,119,129,us_asprintf,,,5,"int us_asprintf (char**,char*...)"
177518,METHOD,text\filesystem.c:<global>,TYPE_DECL,<global>,1,6,text\filesystem.c,text\filesystem.c:<global>,,false,1,236,<global>,,,1,
177520,METHOD,text\filesystem.c:<global>,TYPE_DECL,"FILE *vlc_fopen (const char *filename, const char *mode)
{
    int rwflags = 0, oflags = 0;

    for (const char *ptr = mode; *ptr; ptr++)
    {
        switch (*ptr)
        {
            case 'r':
                rwflags = O_RDONLY;
                break;

            case 'a':
                rwflags = O_WRONLY;
                oflags |= O_CREAT | O_APPEND;
                break;

            case 'w':
                rwflags = O_WRONLY;
                oflags |= O_CREAT | O_TRUNC;
                break;

            case 'x':
                oflags |= O_EXCL;
                break;

            case '+':
                rwflags = O_RDWR;
                break;

#ifdef O_BINARY
            case 'b':
                oflags = (oflags & ~O_TEXT) | O_BINARY;
                break;

            case 't':
                oflags = (oflags & ~O_BINARY) | O_TEXT;
                break;
#endif
        }
    }

    int fd = vlc_open (filename, rwflags | oflags, 0666);
    if (fd == -1)
    ...",1,1,text\filesystem.c,vlc_fopen,,false,48,99,vlc_fopen,,,1,"FILE vlc_fopen (char*,char*)"
177621,METHOD,text\filesystem.c:<global>,TYPE_DECL,"static int dummy_select( const char *str )
{
    (void)str;
    return 1;
}",1,1,text\filesystem.c,dummy_select,,false,102,106,dummy_select,,,2,int dummy_select (char*)
177631,METHOD,text\filesystem.c:<global>,TYPE_DECL,"int vlc_loaddir( DIR *dir, char ***namelist,
                  int (*select)( const char * ),
                  int (*compar)( const char **, const char ** ) )
{
    assert (dir);

    if (select == NULL)
        select = dummy_select;

    char **tab = NULL;
    unsigned num = 0;

    rewinddir (dir);

    for (unsigned size = 0;;)
    {
        errno = 0;
        const char *entry = vlc_readdir (dir);
        if (entry == NULL)
        {
            if (errno)
                goto error;
            break;
        }

        if (!select (entry))
            continue;

        if (num >= size)
        {
            size = size ? (2 * size) : 16;
            char **newtab = realloc (tab, sizeof (*tab) * (size));

            if (unlikely(newtab == NULL))
                goto error;
            tab = newtab;
        }

        tab[num] = strdup(entry);
        if (likely(tab[num] != NULL))
            num++;
    }

    if (compar != NULL && num > 0)
        qsort (tab, num, sizeof (*...",1,1,text\filesystem.c,vlc_loaddir,,false,112,166,vlc_loaddir,,,3,"int vlc_loaddir (DIR*,char***,int,int)"
177784,METHOD,text\filesystem.c:<global>,TYPE_DECL,"int vlc_scandir( const char *dirname, char ***namelist,
                  int (*select)( const char * ),
                  int (*compar)( const char **, const char ** ) )
{
    DIR *dir = vlc_opendir (dirname);
    int val = -1;

    if (dir != NULL)
    {
        val = vlc_loaddir (dir, namelist, select, compar);
        closedir (dir);
    }
    return val;
}",1,1,text\filesystem.c,vlc_scandir,,false,179,192,vlc_scandir,,,4,"int vlc_scandir (char*,char***,int,int)"
177821,METHOD,text\iso-639_def.h:<global>,TYPE_DECL,<global>,1,3,text\iso-639_def.h,text\iso-639_def.h:<global>,,false,1,209,<global>,,,1,
178847,METHOD,text\iso_lang.c:<global>,TYPE_DECL,<global>,1,80,text\iso_lang.c,text\iso_lang.c:<global>,,false,1,78,<global>,,,1,
178857,METHOD,text\iso_lang.c:<global>,TYPE_DECL,"const iso639_lang_t * GetLang_1( const char * psz_code )
{
    const iso639_lang_t *p_lang;

    for( p_lang = p_languages; p_lang->psz_eng_name; p_lang++ )
        if( !strncasecmp( p_lang->psz_iso639_1, psz_code, 2 ) )
            return p_lang;

    return &unknown_language;
}",1,1,text\iso_lang.c,GetLang_1,,false,47,56,GetLang_1,,,3,iso639_lang_t GetLang_1 (char*)
178887,METHOD,text\iso_lang.c:<global>,TYPE_DECL,"const iso639_lang_t * GetLang_2T( const char * psz_code )
{
    const iso639_lang_t *p_lang;

    for( p_lang = p_languages; p_lang->psz_eng_name; p_lang++ )
        if( !strncasecmp( p_lang->psz_iso639_2T, psz_code, 3 ) )
            return p_lang;

    return &unknown_language;
}",1,1,text\iso_lang.c,GetLang_2T,,false,58,67,GetLang_2T,,,4,iso639_lang_t GetLang_2T (char*)
178917,METHOD,text\iso_lang.c:<global>,TYPE_DECL,"const iso639_lang_t * GetLang_2B( const char * psz_code )
{
    const iso639_lang_t *p_lang;

    for( p_lang = p_languages; p_lang->psz_eng_name; p_lang++ )
        if( !strncasecmp( p_lang->psz_iso639_2B, psz_code, 3 ) )
            return p_lang;

    return &unknown_language;
}",1,1,text\iso_lang.c,GetLang_2B,,false,69,78,GetLang_2B,,,5,iso639_lang_t GetLang_2B (char*)
178958,METHOD,text\memstream.c:<global>,TYPE_DECL,<global>,1,1,text\memstream.c,text\memstream.c:<global>,,false,1,194,<global>,,,1,
178960,METHOD,text\memstream.c:<global>,TYPE_DECL,"int vlc_memstream_open(struct vlc_memstream *ms)
{
    ms->error = 0;
    ms->ptr = calloc(1, 1);
    if (unlikely(ms->ptr == NULL))
        ms->error = EOF;
    ms->length = 0;
    return ms->error;
}",1,1,text\memstream.c,vlc_memstream_open,,false,105,113,vlc_memstream_open,,,1,int vlc_memstream_open (vlc_memstream*)
178999,METHOD,text\memstream.c:<global>,TYPE_DECL,"int vlc_memstream_flush(struct vlc_memstream *ms)
{
    return ms->error;
}",1,1,text\memstream.c,vlc_memstream_flush,,false,115,118,vlc_memstream_flush,,,2,int vlc_memstream_flush (vlc_memstream*)
179008,METHOD,text\memstream.c:<global>,TYPE_DECL,"int vlc_memstream_close(struct vlc_memstream *ms)
{
    if (ms->error)
        free(ms->ptr);
    return ms->error;
}",1,1,text\memstream.c,vlc_memstream_close,,false,120,125,vlc_memstream_close,,,3,int vlc_memstream_close (vlc_memstream*)
179026,METHOD,text\memstream.c:<global>,TYPE_DECL,"size_t vlc_memstream_write(struct vlc_memstream *ms, const void *ptr,
                           size_t len)
{
    char *base = realloc(ms->ptr, ms->length + len + 1u);
    if (unlikely(base == NULL))
        goto error;

    memcpy(base + ms->length, ptr, len);
    ms->ptr = base;
    ms->length += len;
    base[ms->length] = '\0';
    return len;

error:
    ms->error = EOF;
    return 0;
}",1,1,text\memstream.c,vlc_memstream_write,,false,127,143,vlc_memstream_write,,,4,"size_t vlc_memstream_write (vlc_memstream*,void*,size_t)"
179089,METHOD,text\memstream.c:<global>,TYPE_DECL,"int vlc_memstream_putc(struct vlc_memstream *ms, int c)
{
    return (vlc_memstream_write(ms, &(unsigned char){ c }, 1u) == 1) ? c : EOF;
}",1,1,text\memstream.c,vlc_memstream_putc,,false,145,148,vlc_memstream_putc,,,5,"int vlc_memstream_putc (vlc_memstream*,int)"
179109,METHOD,text\memstream.c:<global>,TYPE_DECL,"int (vlc_memstream_puts)(struct vlc_memstream *ms, const char *str)
{
    size_t len = strlen(str);
    return (vlc_memstream_write(ms, str, len) == len) ? 0 : EOF;
}",1,1,text\memstream.c,,,false,150,154,vlc_memstream_puts,,,6,"int (vlc_memstream*,char*)"
179130,METHOD,text\memstream.c:<global>,TYPE_DECL,"int vlc_memstream_vprintf(struct vlc_memstream *ms, const char *fmt,
                          va_list args)
{
    va_list ap;
    char *ptr;
    int len;

    va_copy(ap, args);
    len = vsnprintf(NULL, 0, fmt, ap);
    va_end(ap);

    if (len < 0)
        goto error;

    ptr = realloc(ms->ptr, ms->length + len + 1);
    if (ptr == NULL)
        goto error;

    vsnprintf(ptr + ms->length, len + 1, fmt, args);
    ms->ptr = ptr;
    ms->length += len;
    return len;

error:
    ms->error = EOF;
    return EOF;
}",1,1,text\memstream.c,vlc_memstream_vprintf,,false,156,182,vlc_memstream_vprintf,,,7,"int vlc_memstream_vprintf (vlc_memstream*,char*,va_list)"
179208,METHOD,text\memstream.c:<global>,TYPE_DECL,"int vlc_memstream_printf(struct vlc_memstream *ms, const char *fmt, ...)
{
    va_list ap;
    int ret;

    va_start(ap, fmt);
    ret = vlc_memstream_vprintf(ms, fmt, ap);
    va_end(ap);
    return ret;
}",1,1,text\memstream.c,vlc_memstream_printf,,false,185,194,vlc_memstream_printf,,,8,"int vlc_memstream_printf (vlc_memstream*,char*...)"
179264,METHOD,text\strings.c:<global>,TYPE_DECL,<global>,1,15,text\strings.c,text\strings.c:<global>,,false,1,924,<global>,,,1,
179269,METHOD,<empty>,<empty>,<empty>,1,,text\strings.c,xml_entity_s:<clinit>,,false,58,,<clinit>,,,3,
179653,METHOD,text\strings.c:<global>,TYPE_DECL,"static int cmp_entity (const void *key, const void *elem)
{
    const struct xml_entity_s *ent = elem;
    const char *name = key;

    return strncmp (name, ent->psz_entity, strlen (ent->psz_entity));
}",1,1,text\strings.c,cmp_entity,,false,190,196,cmp_entity,,,4,"int cmp_entity (void*,void*)"
179677,METHOD,text\strings.c:<global>,TYPE_DECL,"void vlc_xml_decode( char *psz_value )
{
    char *p_pos = psz_value;

    while ( *psz_value )
    {
        if( *psz_value == '&' )
        {
            if( psz_value[1] == '#' )
            {   /* &#DDD; or &#xHHHH; Unicode code point */
                char *psz_end;
                unsigned long cp;

                if( psz_value[2] == 'x' ) /* The x must be lower-case. */
                    cp = strtoul( psz_value + 3, &psz_end, 16 );
                else
                    cp = strtoul( psz_value + 2, &psz_end, 10 );

                if( *psz_end == ';' )
                {
                    psz_value = psz_end + 1;
                    if( cp == 0 )
                        (void)0; /* skip nulls */
                    else
                    if( cp <= 0x7F )
                    {
                        *p_pos =            cp;
                    }
                    else
                    /* Unicode code point outside ASCII.
                     * &#xxx; representati...",1,1,text\strings.c,vlc_xml_decode,,false,198,288,vlc_xml_decode,,,5,void vlc_xml_decode (char*)
179947,METHOD,text\strings.c:<global>,TYPE_DECL,"char *vlc_xml_encode (const char *str)
{
    struct vlc_memstream stream;
    size_t n;
    uint32_t cp;

    assert(str != NULL);
    vlc_memstream_open(&stream);

    while ((n = vlc_towc (str, &cp)) != 0)
    {
        if (unlikely(n == (size_t)-1))
        {
            if (vlc_memstream_close(&stream) == 0)
                free(stream.ptr);
            errno = EILSEQ;
            return NULL;
        }

        switch (cp)
        {
            case '\""':
                vlc_memstream_puts(&stream, ""&quot;"");
                break;
            case '&':
                vlc_memstream_puts(&stream, ""&amp;"");
                break;
            case '\'':
                vlc_memstream_puts(&stream, ""&#39;"");
                break;
            case '<':
                vlc_memstream_puts(&stream, ""&lt;"");
                break;
            case '>':
                vlc_memstream_puts(&stream, ""&gt;"");
                break;
            default:
                if (cp < 32) /* C0 cod...",1,1,text\strings.c,vlc_xml_encode,,false,290,348,vlc_xml_encode,,,6,char* vlc_xml_encode (char*)
180080,METHOD,text\strings.c:<global>,TYPE_DECL,"char *vlc_b64_encode_binary( const uint8_t *src, size_t i_src )
{
    static const char b64[] =
           ""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"";

    char *ret = malloc( ( i_src + 4 ) * 4 / 3 );
    char *dst = ret;

    if( dst == NULL )
        return NULL;

    while( i_src > 0 )
    {
        /* pops (up to) 3 bytes of input, push 4 bytes */
        uint32_t v;

        /* 1/3 -> 1/4 */
        v = ((unsigned)*src++) << 24;
        *dst++ = b64[v >> 26];
        v = v << 6;

        /* 2/3 -> 2/4 */
        if( i_src >= 2 )
            v |= *src++ << 22;
        *dst++ = b64[v >> 26];
        v = v << 6;

        /* 3/3 -> 3/4 */
        if( i_src >= 3 )
            v |= *src++ << 20; // 3/3
        *dst++ = ( i_src >= 2 ) ? b64[v >> 26] : '='; // 3/4
        v = v << 6;

        /* -> 4/4 */
        *dst++ = ( i_src >= 3 ) ? b64[v >> 26] : '='; // 4/4

        if( i_src <= 3 )
            break;
        i_src -= 3;
    }

    *dst = '\0';

    retu...",1,1,text\strings.c,vlc_b64_encode_binary,,false,351,395,vlc_b64_encode_binary,,,7,"char* vlc_b64_encode_binary (uint8_t*,size_t)"
180227,METHOD,text\strings.c:<global>,TYPE_DECL,"char *vlc_b64_encode( const char *src )
{
    if( src )
        return vlc_b64_encode_binary( (const uint8_t*)src, strlen(src) );
    else
        return vlc_b64_encode_binary( (const uint8_t*)"""", 0 );
}",1,1,text\strings.c,vlc_b64_encode,,false,397,403,vlc_b64_encode,,,8,char* vlc_b64_encode (char*)
180250,METHOD,text\strings.c:<global>,TYPE_DECL,"size_t vlc_b64_decode_binary_to_buffer( uint8_t *p_dst, size_t i_dst, const char *p_src )
{
    static const int b64[256] = {
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* 00-0F */
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* 10-1F */
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,62,-1,-1,-1,63,  /* 20-2F */
        52,53,54,55,56,57,58,59,60,61,-1,-1,-1,-1,-1,-1,  /* 30-3F */
        -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,  /* 40-4F */
        15,16,17,18,19,20,21,22,23,24,25,-1,-1,-1,-1,-1,  /* 50-5F */
        -1,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,  /* 60-6F */
        41,42,43,44,45,46,47,48,49,50,51,-1,-1,-1,-1,-1,  /* 70-7F */
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* 80-8F */
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* 90-9F */
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* A0-AF */
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* B0-BF */
        -1,-1,-1,-1,-1,-1,-1,-1...",1,1,text\strings.c,vlc_b64_decode_binary_to_buffer,,false,406,459,vlc_b64_decode_binary_to_buffer,,,9,"size_t vlc_b64_decode_binary_to_buffer (uint8_t*,size_t,char*)"
180829,METHOD,text\strings.c:<global>,TYPE_DECL,"size_t vlc_b64_decode_binary( uint8_t **pp_dst, const char *psz_src )
{
    const int i_src = strlen( psz_src );
    uint8_t   *p_dst;

    *pp_dst = p_dst = malloc( i_src );
    if( !p_dst )
        return 0;
    return  vlc_b64_decode_binary_to_buffer( p_dst, i_src, psz_src );
}",1,1,text\strings.c,vlc_b64_decode_binary,,false,460,469,vlc_b64_decode_binary,,,10,"size_t vlc_b64_decode_binary (uint8_t**,char*)"
180859,METHOD,text\strings.c:<global>,TYPE_DECL,"char *vlc_b64_decode( const char *psz_src )
{
    const int i_src = strlen( psz_src );
    char *p_dst = malloc( i_src + 1 );
    size_t i_dst;
    if( !p_dst )
        return NULL;

    i_dst = vlc_b64_decode_binary_to_buffer( (uint8_t*)p_dst, i_src, psz_src );
    p_dst[i_dst] = '\0';

    return p_dst;
}",1,1,text\strings.c,vlc_b64_decode,,false,470,482,vlc_b64_decode,,,11,char* vlc_b64_decode (char*)
180898,METHOD,text\strings.c:<global>,TYPE_DECL,"char *vlc_strftime( const char *tformat )
{
    time_t curtime;
    struct tm loctime;

    if (strcmp (tformat, """") == 0)
        return strdup (""""); /* corner case w.r.t. strftime() return value */

    /* Get the current time.  */
    time( &curtime );

    /* Convert it to local time representation.  */
    localtime_r( &curtime, &loctime );
    for (size_t buflen = strlen (tformat) + 32;; buflen += 32)
    {
        char *str = malloc (buflen);
        if (str == NULL)
            return NULL;

        size_t len = strftime (str, buflen, tformat, &loctime);
        if (len > 0)
        {
            char *ret = realloc (str, len + 1);
            return ret ? ret : str; /* <- this cannot fail */
        }
        free (str);
    }
    vlc_assert_unreachable ();
}",1,1,text\strings.c,vlc_strftime,,false,484,512,vlc_strftime,,,12,char* vlc_strftime (char*)
180978,METHOD,text\strings.c:<global>,TYPE_DECL,"static void write_duration(struct vlc_memstream *stream, int64_t duration)
{
    lldiv_t d;
    long long sec;

    duration /= CLOCK_FREQ;
    d = lldiv(duration, 60);
    sec = d.rem;
    d = lldiv(d.quot, 60);
    vlc_memstream_printf(stream, ""%02lld:%02lld:%02lld"", d.quot, d.rem, sec);
}",1,1,text\strings.c,write_duration,,false,514,524,write_duration,,,13,"void write_duration (vlc_memstream*,int64_t)"
181016,METHOD,text\strings.c:<global>,TYPE_DECL,"static int write_meta(struct vlc_memstream *stream, input_item_t *item,
                      vlc_meta_type_t type)
{
    if (item == NULL)
        return EOF;

    char *value = input_item_GetMeta(item, type);
    if (value == NULL)
        return EOF;

    vlc_memstream_puts(stream, value);
    free(value);
    return 0;
}",1,1,text\strings.c,write_meta,,false,526,539,write_meta,,,14,"int write_meta (vlc_memstream*,input_item_t*,vlc_meta_type_t)"
181050,METHOD,text\strings.c:<global>,TYPE_DECL,"char *vlc_strfinput(input_thread_t *input, const char *s)
{
    struct vlc_memstream stream[1];

    input_item_t *item = (input != NULL) ? input_GetItem(input) : NULL;

    char c;
    bool b_is_format = false;
    bool b_empty_if_na = false;

    assert(s != NULL);

    vlc_memstream_open(stream);

    while ((c = *s) != '\0')
    {
        s++;

        if (!b_is_format)
        {
            if (c == '$')
            {
                b_is_format = true;
                b_empty_if_na = false;
                continue;
            }

            vlc_memstream_putc(stream, c);
            continue;
        }

        b_is_format = false;

        switch (c)
        {
            case 'a':
                write_meta(stream, item, vlc_meta_Artist);
                break;
            case 'b':
                write_meta(stream, item, vlc_meta_Album);
                break;
            case 'c':
                write_meta(stream, item, vlc_meta_Copyright);
                break;
     ...",1,1,text\strings.c,vlc_strfinput,,false,541,829,vlc_strfinput,,,15,"char* vlc_strfinput (input_thread_t*,char*)"
181734,METHOD,text\strings.c:<global>,TYPE_DECL,"int vlc_filenamecmp(const char *a, const char *b)
{
    size_t i;
    char ca, cb;

    /* Attempt to guess if the sorting algorithm should be alphabetic
     * (i.e. collation) or numeric:
     * - If the first mismatching characters are not both digits,
     *   then collation is the only option.
     * - If one of the first mismatching characters is 0 and the other is also
     *   a digit, the comparands are probably left-padded numerical values.
     *   It does not matter which algorithm is used: the zero will be smaller
     *   than non-zero either way.
     * - Otherwise, the comparands are numerical values, and might not be
     *   aligned (i.e. not same order of magnitude). If so, collation would
     *   fail. So numerical comparison is performed. */
    for (i = 0; (ca = a[i]) == (cb = b[i]); i++)
        if (ca == '\0')
            return 0; /* strings are exactly identical */

    if ((unsigned)(ca - '0') > 9 || (unsigned)(cb - '0') > 9)
        return strcoll(a, b);...",1,15,text\strings.c,vlc_filenamecmp,,false,831,864,vlc_filenamecmp,,,16,"int vlc_filenamecmp (char*,char*)"
181829,METHOD,text\strings.c:<global>,TYPE_DECL,"void filename_sanitize( char *str )
{
    unsigned char c;

    /* Special file names, not allowed */
    if( !strcmp( str, ""."" ) || !strcmp( str, "".."" ) )
    {
        while( *str )
            *(str++) = '_';
        return;
    }

    /* On platforms not using UTF-8, VLC cannot access non-Unicode paths.
     * Also, some file systems require Unicode file names.
     * NOTE: This may inserts '?' thus is done replacing '?' with '_'. */
    EnsureUTF8( str );

    /* Avoid leading spaces to please Windows. */
    while( (c = *str) != '\0' )
    {
        if( c != ' ' )
            break;
        *(str++) = '_';
    }

    char *start = str;

    while( (c = *str) != '\0' )
    {
        /* Non-printable characters are not a good idea */
        if( c < 32 )
            *str = '_';
        /* This is the list of characters not allowed by Microsoft.
         * We also black-list them on Unix as they may be confusing, and are
         * not supported by some file system types (notably...",1,1,text\strings.c,filename_sanitize,,false,877,924,filename_sanitize,,,17,void filename_sanitize (char*)
181956,METHOD,text\unicode.c:<global>,TYPE_DECL,<global>,1,1,text\unicode.c,text\unicode.c:<global>,,false,1,318,<global>,,,1,
181958,METHOD,text\unicode.c:<global>,TYPE_DECL,"int utf8_vfprintf( FILE *stream, const char *fmt, va_list ap )
{
#ifndef _WIN32
    return vfprintf (stream, fmt, ap);
#else
    char *str;
    int res = vasprintf (&str, fmt, ap);
    if (unlikely(res == -1))
        return -1;

#if !VLC_WINSTORE_APP
    /* Writing to the console is a lot of fun on Microsoft Windows.
     * If you use the standard I/O functions, you must use the OEM code page,
     * which is different from the usual ANSI code page. Or maybe not, if the
     * user called ""chcp"". Anyway, we prefer Unicode. */
    int fd = _fileno (stream);
    if (likely(fd != -1) && _isatty (fd))
    {
        wchar_t *wide = ToWide (str);
        if (likely(wide != NULL))
        {
            HANDLE h = (HANDLE)((uintptr_t)_get_osfhandle (fd));
            DWORD out;
            /* XXX: It is not clear whether WriteConsole() wants the number of
             * Unicode characters or the size of the wchar_t array. */
            BOOL ok = WriteConsoleW (h, wide, wcslen (wide), &out...",1,1,text\unicode.c,utf8_vfprintf,,false,52,96,utf8_vfprintf,,,1,"int utf8_vfprintf (FILE*,char*,va_list)"
181970,METHOD,text\unicode.c:<global>,TYPE_DECL,"int utf8_fprintf( FILE *stream, const char *fmt, ... )
{
    va_list ap;
    int res;

    va_start( ap, fmt );
    res = utf8_vfprintf( stream, fmt, ap );
    va_end( ap );
    return res;
}",1,1,text\unicode.c,utf8_fprintf,,false,102,111,utf8_fprintf,,,2,"int utf8_fprintf (FILE*,char*...)"
181991,METHOD,text\unicode.c:<global>,TYPE_DECL,"size_t vlc_towc (const char *str, uint32_t *restrict pwc)
{
    uint8_t *ptr = (uint8_t *)str, c;
    uint32_t cp;

    assert (str != NULL);

    c = *ptr;
    if (unlikely(c > 0xF4))
        return -1;

    int charlen = clz8 (c ^ 0xFF);
    switch (charlen)
    {
        case 0: // 7-bit ASCII character -> short cut
            *pwc = c;
            return c != '\0';

        case 1: // continuation byte -> error
            return -1;

        case 2:
            if (unlikely(c < 0xC2)) // ASCII overlong
                return -1;
            cp = (c & 0x1F) << 6;
            break;

        case 3:
            cp = (c & 0x0F) << 12;
            break;

        case 4:
            cp = (c & 0x07) << 18;
            break;

        default:
            vlc_assert_unreachable ();
    }

    /* Unrolled continuation bytes decoding */
    switch (charlen)
    {
        case 4:
            c = *++ptr;
            if (unlikely((c & 0xC0) != 0x80)) // not a continuation byte
          ...",1,1,text\unicode.c,vlc_towc,,false,113,185,vlc_towc,,,3,"size_t vlc_towc (char*,uint32_t*)"
182208,METHOD,text\unicode.c:<global>,TYPE_DECL,"char *vlc_strcasestr (const char *haystack, const char *needle)
{
    ssize_t s;

    do
    {
        const char *h = haystack, *n = needle;

        for (;;)
        {
            uint32_t cph, cpn;

            s = vlc_towc (n, &cpn);
            if (s == 0)
                return (char *)haystack;
            if (unlikely(s < 0))
                return NULL;
            n += s;

            s = vlc_towc (h, &cph);
            if (s <= 0 || towlower (cph) != towlower (cpn))
                break;
            h += s;
        }

        s = vlc_towc (haystack, &(uint32_t) { 0 });
        haystack += s;
    }
    while (s > 0);

    return NULL;
}",1,1,text\unicode.c,vlc_strcasestr,,false,198,229,vlc_strcasestr,,,4,"char* vlc_strcasestr (char*,char*)"
182294,METHOD,text\unicode.c:<global>,TYPE_DECL,"char *FromCharset(const char *charset, const void *data, size_t data_size)
{
    vlc_iconv_t handle = vlc_iconv_open (""UTF-8"", charset);
    if (handle == (vlc_iconv_t)(-1))
        return NULL;

    char *out = NULL;
    for(unsigned mul = 4; mul < 8; mul++ )
    {
        size_t in_size = data_size;
        const char *in = data;
        size_t out_max = mul * data_size;
        char *tmp = out = malloc (1 + out_max);
        if (!out)
            break;

        if (vlc_iconv (handle, &in, &in_size, &tmp, &out_max) != (size_t)(-1)) {
            *tmp = '\0';
            break;
        }
        free(out);
        out = NULL;

        if (errno != E2BIG)
            break;
    }
    vlc_iconv_close(handle);
    return out;
}",1,1,text\unicode.c,FromCharset,,false,237,265,FromCharset,,,5,"char* FromCharset (char*,void*,size_t)"
182396,METHOD,text\unicode.c:<global>,TYPE_DECL,"void *ToCharset(const char *charset, const char *in, size_t *outsize)
{
    vlc_iconv_t hd = vlc_iconv_open (charset, ""UTF-8"");
    if (hd == (vlc_iconv_t)(-1))
        return NULL;

    const size_t inlen = strlen (in);
    void *res;

    for (unsigned mul = 4; mul < 16; mul++)
    {
        size_t outlen = mul * (inlen + 1);
        res = malloc (outlen);
        if (unlikely(res == NULL))
            break;

        const char *inp = in;
        char *outp = res;
        size_t inb = inlen;
        size_t outb = outlen - mul;

        if (vlc_iconv (hd, &inp, &inb, &outp, &outb) != (size_t)(-1))
        {
            *outsize = outlen - mul - outb;
            outb += mul;
            inb = 1; /* append nul terminator if possible */
            if (vlc_iconv (hd, &inp, &inb, &outp, &outb) != (size_t)(-1))
                break;
            if (errno == EILSEQ) /* cannot translate nul terminator!? */
                break;
        }

        free (res);
        res = NULL;
      ...",1,1,text\unicode.c,ToCharset,,false,279,318,ToCharset,,,6,"void* ToCharset (char*,char*,size_t*)"
182578,METHOD,text\url.c:<global>,TYPE_DECL,<global>,1,1,text\url.c,text\url.c:<global>,,false,1,975,<global>,,,1,
182580,METHOD,text\url.c:<global>,TYPE_DECL,"char *vlc_uri_decode_duplicate (const char *str)
{
    char *buf = strdup (str);
    if (vlc_uri_decode (buf) == NULL)
    {
        free (buf);
        buf = NULL;
    }
    return buf;
}",1,1,text\url.c,vlc_uri_decode_duplicate,,false,43,52,vlc_uri_decode_duplicate,,,1,char* vlc_uri_decode_duplicate (char*)
182603,METHOD,text\url.c:<global>,TYPE_DECL,"char *vlc_uri_decode (char *str)
{
    char *in = str, *out = str;
    if (in == NULL)
        return NULL;

    char c;
    while ((c = *(in++)) != '\0')
    {
        if (c == '%')
        {
            char hex[3];

            if (!(hex[0] = *(in++)) || !(hex[1] = *(in++)))
                return NULL;
            hex[2] = '\0';
            *(out++) = strtoul (hex, NULL, 0x10);
        }
        else
            *(out++) = c;
    }
    *out = '\0';
    return str;
}",1,1,text\url.c,vlc_uri_decode,,false,54,77,vlc_uri_decode,,,2,char* vlc_uri_decode (char*)
182686,METHOD,text\url.c:<global>,TYPE_DECL,"static bool isurisafe (int c)
{
    /* These are the _unreserved_ URI characters (RFC3986 2.3) */
    return ((unsigned char)(c - 'a') < 26)
        || ((unsigned char)(c - 'A') < 26)
        || ((unsigned char)(c - '0') < 10)
        || (strchr (""-._~"", c) != NULL);
}",1,1,text\url.c,isurisafe,,false,79,86,isurisafe,,,3,bool isurisafe (int)
182721,METHOD,text\url.c:<global>,TYPE_DECL,"static bool isurisubdelim(int c)
{
    return strchr(""!$&'()*+,;="", c) != NULL;
}",1,1,text\url.c,isurisubdelim,,false,88,91,isurisubdelim,,,4,bool isurisubdelim (int)
182732,METHOD,text\url.c:<global>,TYPE_DECL,"static bool isurihex(int c)
{   /* Same as isxdigit() but does not depend on locale and unsignedness */
    return ((unsigned char)(c - '0') < 10)
        || ((unsigned char)(c - 'A') < 6)
        || ((unsigned char)(c - 'a') < 6);
}",1,1,text\url.c,isurihex,,false,93,98,isurihex,,,5,bool isurihex (int)
182765,METHOD,text\url.c:<global>,TYPE_DECL,"static char *encode_URI_bytes (const char *str, size_t *restrict lenp)
{
    char *buf = malloc (3 * *lenp + 1);
    if (unlikely(buf == NULL))
        return NULL;

    char *out = buf;
    for (size_t i = 0; i < *lenp; i++)
    {
        unsigned char c = str[i];

        if (isurisafe (c))
            *(out++) = c;
        /* This is URI encoding, not HTTP forms:
         * Space is encoded as '%20', not '+'. */
        else
        {
            *(out++) = '%';
            *(out++) = urihex[c >> 4];
            *(out++) = urihex[c & 0xf];
        }
    }

    *lenp = out - buf;
    out = realloc (buf, *lenp + 1);
    return likely(out != NULL) ? out : buf;
}",1,1,text\url.c,encode_URI_bytes,,false,102,128,encode_URI_bytes,,,8,"char* encode_URI_bytes (char*,size_t*)"
182868,METHOD,text\url.c:<global>,TYPE_DECL,"char *vlc_uri_encode (const char *str)
{
    size_t len = strlen (str);
    char *ret = encode_URI_bytes (str, &len);
    if (likely(ret != NULL))
        ret[len] = '\0';
    return ret;
}",1,1,text\url.c,vlc_uri_encode,,false,130,137,vlc_uri_encode,,,9,char* vlc_uri_encode (char*)
182898,METHOD,text\url.c:<global>,TYPE_DECL,"char *vlc_path2uri (const char *path, const char *scheme)
{
    if (path == NULL)
    {
        errno = EINVAL;
        return NULL;
    }
    if (scheme == NULL && !strcmp (path, ""-""))
        return strdup (""fd://0""); // standard input
    /* Note: VLC cannot handle URI schemes without double slash after the
     * scheme name (such as mailto: or news:). */

    char *buf;

#ifdef __OS2__
    char p[strlen (path) + 1];

    for (buf = p; *path; buf++, path++)
        *buf = (*path == '/') ? DIR_SEP_CHAR : *path;
    *buf = '\0';

    path = p;
#endif

#if defined (_WIN32) || defined (__OS2__)
    /* Drive letter */
    if (isalpha ((unsigned char)path[0]) && (path[1] == ':'))
    {
        if (asprintf (&buf, ""%s:///%c:"", scheme ? scheme : ""file"",
                      path[0]) == -1)
            buf = NULL;
        path += 2;
# warning Drive letter-relative path not implemented!
        if (path[0] != DIR_SEP_CHAR)
        {
            errno = ENOTSUP;
            return NULL;
 ...",1,1,text\url.c,vlc_path2uri,,false,139,239,vlc_path2uri,,,10,"char* vlc_path2uri (char*,char*)"
183065,METHOD,text\url.c:<global>,TYPE_DECL,"char *vlc_uri2path (const char *url)
{
    char *ret = NULL;
    char *end;

    char *path = strstr (url, ""://"");
    if (path == NULL)
        return NULL; /* unsupported scheme or invalid syntax */

    end = memchr (url, '/', path - url);
    size_t schemelen = ((end != NULL) ? end : path) - url;
    path += 3; /* skip ""://"" */

    /* Remove request parameters and/or HTML anchor if present */
    end = path + strcspn (path, ""?#"");
    path = strndup (path, end - path);
    if (unlikely(path == NULL))
        return NULL; /* boom! */

    /* Decode path */
    vlc_uri_decode (path);

    if (schemelen == 4 && !strncasecmp (url, ""file"", 4))
    {
#if !defined (_WIN32) && !defined (__OS2__)
        /* Leading slash => local path */
        if (*path == '/')
            return path;
        /* Local path disguised as a remote one */
        if (!strncasecmp (path, ""localhost/"", 10))
            return memmove (path, path + 9, strlen (path + 9) + 1);
#else
        /* cannot start wi...",1,1,text\url.c,vlc_uri2path,,false,241,325,vlc_uri2path,,,11,char* vlc_uri2path (char*)
183241,METHOD,text\url.c:<global>,TYPE_DECL,static char *vlc_idna_to_ascii (const char *);,13,45,text\url.c,vlc_idna_to_ascii,,false,327,327,vlc_idna_to_ascii,,,12,char* vlc_idna_to_ascii (char*)
183246,METHOD,text\url.c:<global>,TYPE_DECL,"static char *vlc_iri2uri(const char *iri)
{
    size_t a = 0, u = 0;

    for (size_t i = 0; iri[i] != '\0'; i++)
    {
        unsigned char c = iri[i];

        if (c < 128)
            a++;
        else
            u++;
    }

    if (unlikely((a + u) > (SIZE_MAX / 4)))
    {
        errno = ENOMEM;
        return NULL;
    }

    char *uri = malloc(a + 3 * u + 1), *p;
    if (unlikely(uri == NULL))
        return NULL;

    for (p = uri; *iri != '\0'; iri++)
    {
        unsigned char c = *iri;

        if (c < 128)
            *(p++) = c;
        else
        {
            *(p++) = '%';
            *(p++) = urihex[c >> 4];
            *(p++) = urihex[c & 0xf];
        }
    }

    *p = '\0';
    return uri;
}",1,1,text\url.c,vlc_iri2uri,,false,330,370,vlc_iri2uri,,,13,char* vlc_iri2uri (char*)
183383,METHOD,text\url.c:<global>,TYPE_DECL,"static bool vlc_uri_component_validate(const char *str, const char *extras)
{
    assert(str != NULL);

    for (size_t i = 0; str[i] != '\0'; i++)
    {
        int c = str[i];

        if (isurisafe(c) || isurisubdelim(c))
            continue;
        if (strchr(extras, c) != NULL)
            continue;
        if (c == '%' && isurihex(str[i + 1]) && isurihex(str[i + 2]))
        {
            i += 2;
            continue;
        }
        return false;
    }
    return true;
}",1,1,text\url.c,vlc_uri_component_validate,,false,372,392,vlc_uri_component_validate,,,14,"bool vlc_uri_component_validate (char*,char*)"
183456,METHOD,text\url.c:<global>,TYPE_DECL,"static bool vlc_uri_host_validate(const char *str)
{
    return vlc_uri_component_validate(str, "":"");
}",1,1,text\url.c,vlc_uri_host_validate,,false,394,397,vlc_uri_host_validate,,,15,bool vlc_uri_host_validate (char*)
183465,METHOD,text\url.c:<global>,TYPE_DECL,"static bool vlc_uri_path_validate(const char *str)
{
    return vlc_uri_component_validate(str, ""/@:[]"");
}",1,1,text\url.c,vlc_uri_path_validate,,false,399,402,vlc_uri_path_validate,,,16,bool vlc_uri_path_validate (char*)
183474,METHOD,text\url.c:<global>,TYPE_DECL,"static int vlc_UrlParseInner(vlc_url_t *restrict url, const char *str)
{
    url->psz_protocol = NULL;
    url->psz_username = NULL;
    url->psz_password = NULL;
    url->psz_host = NULL;
    url->i_port = 0;
    url->psz_path = NULL;
    url->psz_option = NULL;
    url->psz_buffer = NULL;
    url->psz_pathbuffer = NULL;

    if (str == NULL)
    {
        errno = EINVAL;
        return -1;
    }

    char *buf = vlc_iri2uri(str);
    if (unlikely(buf == NULL))
        return -1;
    url->psz_buffer = buf;

    char *cur = buf, *next;
    int ret = 0;

    /* URI scheme */
    next = buf;
    while ((*next >= 'A' && *next <= 'Z') || (*next >= 'a' && *next <= 'z')
        || (*next >= '0' && *next <= '9') || memchr (""+-."", *next, 3) != NULL)
        next++;

    if (*next == ':')
    {
        *(next++) = '\0';
        url->psz_protocol = cur;
        cur = next;
    }

    /* Fragment */
    next = strchr(cur, '#');
    if (next != NULL)
    {
#if 0  /* TODO */
       *(next++) = '...",1,1,text\url.c,vlc_UrlParseInner,,false,404,553,vlc_UrlParseInner,,,17,"int vlc_UrlParseInner (vlc_url_t*,char*)"
183918,METHOD,text\url.c:<global>,TYPE_DECL,"int vlc_UrlParse(vlc_url_t *url, const char *str)
{
    int ret = vlc_UrlParseInner(url, str);

    if (url->psz_path != NULL && !vlc_uri_path_validate(url->psz_path))
    {
        url->psz_path = NULL;
        errno = EINVAL;
        ret = -1;
    }
    return ret;
}",1,1,text\url.c,vlc_UrlParse,,false,555,566,vlc_UrlParse,,,18,"int vlc_UrlParse (vlc_url_t*,char*)"
183957,METHOD,text\url.c:<global>,TYPE_DECL,"static char *vlc_uri_fixup_inner(const char *str, const char *extras);",13,69,text\url.c,vlc_uri_fixup_inner,,false,568,568,vlc_uri_fixup_inner,,,19,"char* vlc_uri_fixup_inner (char*,char*)"
183963,METHOD,text\url.c:<global>,TYPE_DECL,"int vlc_UrlParseFixup(vlc_url_t *url, const char *str)
{
    int ret = vlc_UrlParseInner(url, str);

    static const char pathextras[] = ""/@:"";

    if (url->psz_path != NULL
     && !vlc_uri_component_validate(url->psz_path, pathextras))
    {
        url->psz_pathbuffer = vlc_uri_fixup_inner(url->psz_path, pathextras);
        if (url->psz_pathbuffer == NULL)
        {
            url->psz_path = NULL;
            errno = ENOMEM;
            ret = -1;
        }
        else
        {
            url->psz_path = url->psz_pathbuffer;
            assert(vlc_uri_path_validate(url->psz_path));
        }
    }
    return ret;
}",1,1,text\url.c,vlc_UrlParseFixup,,false,570,593,vlc_UrlParseFixup,,,20,"int vlc_UrlParseFixup (vlc_url_t*,char*)"
184037,METHOD,text\url.c:<global>,TYPE_DECL,"void vlc_UrlClean (vlc_url_t *restrict url)
{
    free (url->psz_host);
    free (url->psz_buffer);
    free (url->psz_pathbuffer);
}",1,1,text\url.c,vlc_UrlClean,,false,595,600,vlc_UrlClean,,,21,void vlc_UrlClean (vlc_url_t*)
184054,METHOD,text\url.c:<global>,TYPE_DECL,"static char *vlc_uri_merge_paths(const char *base, const char *ref)
{
    char *str;
    int len;

    if (base == NULL)
        len = asprintf(&str, ""/%s"", ref);
    else
    {
        const char *end = strrchr(base, '/');

        if (end != NULL)
            end++;
        else
            end = base;

        len = asprintf(&str, ""%.*s%s"", (int)(end - base), base, ref);
    }

    if (unlikely(len == -1))
        str = NULL;
    return str;
}",1,1,text\url.c,vlc_uri_merge_paths,,false,607,629,vlc_uri_merge_paths,,,22,"char* vlc_uri_merge_paths (char*,char*)"
184119,METHOD,text\url.c:<global>,TYPE_DECL,"static char *vlc_uri_remove_dot_segments(char *str)
{
    char *input = str, *output = str;

    while (input[0] != '\0')
    {
        assert(output <= input);

        if (strncmp(input, ""../"", 3) == 0)
        {
            input += 3;
            continue;
        }
        if (strncmp(input, ""./"", 2) == 0)
        {
            input += 2;
            continue;
        }
        if (strncmp(input, ""/./"", 3) == 0)
        {
            input += 2;
            continue;
        }
        if (strcmp(input, ""/."") == 0)
        {
            input[1] = '\0';
            continue;
        }
        if (strncmp(input, ""/../"", 4) == 0)
        {
            input += 3;
            output = memrchr(str, '/', output - str);
            if (output == NULL)
                output = str;
            continue;
        }
        if (strcmp(input, ""/.."") == 0)
        {
            input[1] = '\0';
            output = memrchr(str, '/', output - str);
            if (output == NULL)
          ...",1,1,text\url.c,vlc_uri_remove_dot_segments,,false,636,705,vlc_uri_remove_dot_segments,,,23,char* vlc_uri_remove_dot_segments (char*)
184312,METHOD,text\url.c:<global>,TYPE_DECL,"char *vlc_uri_compose(const vlc_url_t *uri)
{
    struct vlc_memstream stream;
    char *enc;

    vlc_memstream_open(&stream);

    if (uri->psz_protocol != NULL)
        vlc_memstream_printf(&stream, ""%s:"", uri->psz_protocol);

    if (uri->psz_host != NULL)
    {
        vlc_memstream_write(&stream, ""//"", 2);

        if (uri->psz_username != NULL)
        {
            enc = vlc_uri_encode(uri->psz_username);
            if (enc == NULL)
                goto error;

            vlc_memstream_puts(&stream, enc);
            free(enc);

            if (uri->psz_password != NULL)
            {
                enc = vlc_uri_encode(uri->psz_password);
                if (unlikely(enc == NULL))
                    goto error;

                vlc_memstream_printf(&stream, "":%s"", enc);
                free(enc);
            }
            vlc_memstream_putc(&stream, '@');
        }

        const char *fmt;

        if (strchr(uri->psz_host, ':') != NULL)
            fmt = (uri->i_port ...",1,1,text\url.c,vlc_uri_compose,,false,707,766,vlc_uri_compose,,,24,char* vlc_uri_compose (vlc_url_t*)
184498,METHOD,text\url.c:<global>,TYPE_DECL,"char *vlc_uri_resolve(const char *base, const char *ref)
{
    vlc_url_t base_uri, rel_uri;
    vlc_url_t tgt_uri;
    char *pathbuf = NULL, *ret = NULL;

    if (vlc_UrlParse(&rel_uri, ref))
    {
        vlc_UrlClean(&rel_uri);
        return NULL;
    }

    if (rel_uri.psz_protocol != NULL)
    {   /* Short circuit in case of absolute URI */
        vlc_UrlClean(&rel_uri);
        return strdup(ref);
    }

    vlc_UrlParse(&base_uri, base);

    /* RFC3986 section 5.2.2 */
    do
    {
        tgt_uri = rel_uri;
        tgt_uri.psz_protocol = base_uri.psz_protocol;

        if (rel_uri.psz_host != NULL)
            break;

        tgt_uri.psz_username = base_uri.psz_username;
        tgt_uri.psz_password = base_uri.psz_password;
        tgt_uri.psz_host = base_uri.psz_host;
        tgt_uri.i_port = base_uri.i_port;

        if (rel_uri.psz_path == NULL || rel_uri.psz_path[0] == '\0')
        {
            tgt_uri.psz_path = base_uri.psz_path;
            if (rel_uri.psz_option ...",1,1,text\url.c,vlc_uri_resolve,,false,768,830,vlc_uri_resolve,,,25,"char* vlc_uri_resolve (char*,char*)"
184687,METHOD,text\url.c:<global>,TYPE_DECL,"static char *vlc_uri_fixup_inner(const char *str, const char *extras)
{
    assert(str && extras);

    bool encode_percent = false;
    for (size_t i = 0; str[i] != '\0'; i++)
        if (str[i] == '%' && !(isurihex(str[i+1]) && isurihex(str[i+2])))
        {
            encode_percent = true;
            break;
        }

    struct vlc_memstream stream;

    vlc_memstream_open(&stream);

    for (size_t i = 0; str[i] != '\0'; i++)
    {
        unsigned char c = str[i];

        if (isurisafe(c) || isurisubdelim(c) || (strchr(extras, c) != NULL)
         || (c == '%' && !encode_percent))
            vlc_memstream_putc(&stream, c);
        else
            vlc_memstream_printf(&stream, ""%%%02hhX"", c);
    }

    if (vlc_memstream_close(&stream))
        return NULL;
    return stream.ptr;
}",1,1,text\url.c,vlc_uri_fixup_inner,,false,832,862,vlc_uri_fixup_inner,,,26,"char* vlc_uri_fixup_inner (char*,char*)"
184806,METHOD,text\url.c:<global>,TYPE_DECL,"char *vlc_uri_fixup(const char *str)
{
    static const char extras[] = "":/?#[]@"";

    /* Rule number one is do not change a (potentially) valid URI */
    if (vlc_uri_component_validate(str, extras))
        return strdup(str);

    return vlc_uri_fixup_inner(str, extras);
}",1,1,text\url.c,vlc_uri_fixup,,false,864,873,vlc_uri_fixup,,,27,char* vlc_uri_fixup (char*)
184827,METHOD,text\url.c:<global>,TYPE_DECL,"static char *vlc_idna_to_ascii (const char *idn)
{
#if defined (HAVE_IDN)
    char *adn;

    switch (idna_to_ascii_8z(idn, &adn, IDNA_ALLOW_UNASSIGNED))
    {
        case IDNA_SUCCESS:
            return adn;
        case IDNA_MALLOC_ERROR:
            errno = ENOMEM;
            return NULL;
        case IDNA_DLOPEN_ERROR:
            errno = ENOSYS;
            return NULL;
        default:
            errno = EINVAL;
            return NULL;
    }

#elif defined (_WIN32)
    char *ret = NULL;

    if (idn[0] == '\0')
        return strdup("""");

    wchar_t *wide = ToWide (idn);
    if (wide == NULL)
        return NULL;

    int len = IdnToAscii (IDN_ALLOW_UNASSIGNED, wide, -1, NULL, 0);
    if (len == 0)
    {
        errno = EINVAL;
        goto error;
    }

    wchar_t *buf = vlc_alloc (len, sizeof (*buf));
    if (unlikely(buf == NULL))
        goto error;
    if (!IdnToAscii (IDN_ALLOW_UNASSIGNED, wide, -1, buf, len))
    {
        free (buf);
        errno = EINVAL;
    ...",1,1,text\url.c,vlc_idna_to_ascii,,false,911,975,vlc_idna_to_ascii,,,28,char* vlc_idna_to_ascii (char*)
184865,METHOD,version.c:<global>,TYPE_DECL,<global>,1,1,version.c,version.c:<global>,,false,1,45,<global>,,,1,
184867,METHOD,version.c:<global>,TYPE_DECL,"DECLARE_VLC_VERSION( CompileBy, COMPILE_BY )",1,44,version.c,VLC_CompileBy,,false,43,43,VLC_CompileBy,,,1,const char* VLC_CompileBy (void)
184874,METHOD,version.c:<global>,TYPE_DECL,"DECLARE_VLC_VERSION( CompileHost, COMPILE_HOST )",1,48,version.c,VLC_CompileHost,,false,44,44,VLC_CompileHost,,,2,const char* VLC_CompileHost (void)
184881,METHOD,version.c:<global>,TYPE_DECL,"DECLARE_VLC_VERSION( Compiler, COMPILER )",1,41,version.c,VLC_Compiler,,false,45,45,VLC_Compiler,,,3,const char* VLC_Compiler (void)
184893,METHOD,video_output\chrono.h:<global>,TYPE_DECL,<global>,1,6,video_output\chrono.h,video_output\chrono.h:<global>,,false,1,92,<global>,,,1,
184903,METHOD,video_output\chrono.h:<global>,TYPE_DECL,"static inline void vout_chrono_Init(vout_chrono_t *chrono, int shift, mtime_t avg_initial)
{
    chrono->shift       = shift;
    chrono->avg_initial =
    chrono->avg         = avg_initial;

    chrono->shift_var   = shift+1;
    chrono->var         = avg_initial / 2;

    chrono->start = VLC_TS_INVALID;
}",1,1,video_output\chrono.h,vout_chrono_Init,,false,40,50,vout_chrono_Init,,,3,"void vout_chrono_Init (vout_chrono_t*,int,mtime_t)"
184943,METHOD,video_output\chrono.h:<global>,TYPE_DECL,"static inline void vout_chrono_Clean(vout_chrono_t *chrono)
{
    VLC_UNUSED(chrono);
}",1,1,video_output\chrono.h,vout_chrono_Clean,,false,51,54,vout_chrono_Clean,,,4,void vout_chrono_Clean (vout_chrono_t*)
184950,METHOD,video_output\chrono.h:<global>,TYPE_DECL,"static inline void vout_chrono_Start(vout_chrono_t *chrono)
{
    chrono->start = mdate();
}",1,1,video_output\chrono.h,vout_chrono_Start,,false,55,58,vout_chrono_Start,,,5,void vout_chrono_Start (vout_chrono_t*)
184960,METHOD,video_output\chrono.h:<global>,TYPE_DECL,"static inline mtime_t vout_chrono_GetHigh(vout_chrono_t *chrono)
{
    return chrono->avg + 2 * chrono->var;
}",1,1,video_output\chrono.h,vout_chrono_GetHigh,,false,59,62,vout_chrono_GetHigh,,,6,mtime_t vout_chrono_GetHigh (vout_chrono_t*)
184975,METHOD,video_output\chrono.h:<global>,TYPE_DECL,"static inline mtime_t vout_chrono_GetLow(vout_chrono_t *chrono)
{
    return __MAX(chrono->avg - 2 * chrono->var, 0);
}",1,1,video_output\chrono.h,vout_chrono_GetLow,,false,63,66,vout_chrono_GetLow,,,7,mtime_t vout_chrono_GetLow (vout_chrono_t*)
184992,METHOD,video_output\chrono.h:<global>,TYPE_DECL,"static inline void vout_chrono_Stop(vout_chrono_t *chrono)
{
    assert(chrono->start != VLC_TS_INVALID);

    /* */
    const mtime_t duration = mdate() - chrono->start;
    const mtime_t var = llabs( duration - chrono->avg );

    /* Update average only if the current point is 'valid' */
    if( duration < vout_chrono_GetHigh( chrono ) )
        chrono->avg = (((1 << chrono->shift) - 1) * chrono->avg + duration) >> chrono->shift;
    /* Always update the variance */
    chrono->var = (((1 << chrono->shift_var) - 1) * chrono->var + var) >> chrono->shift_var;

    /* For assert */
    chrono->start = VLC_TS_INVALID;
}",1,1,video_output\chrono.h,vout_chrono_Stop,,false,68,84,vout_chrono_Stop,,,8,void vout_chrono_Stop (vout_chrono_t*)
185073,METHOD,video_output\chrono.h:<global>,TYPE_DECL,"static inline void vout_chrono_Reset(vout_chrono_t *chrono)
{
    vout_chrono_t ch = *chrono;
    vout_chrono_Clean(chrono);
    vout_chrono_Init(chrono, ch.shift, ch.avg_initial);
}",1,1,video_output\chrono.h,vout_chrono_Reset,,false,85,90,vout_chrono_Reset,,,9,void vout_chrono_Reset (vout_chrono_t*)
185104,METHOD,video_output\control.c:<global>,TYPE_DECL,<global>,1,22,video_output\control.c,video_output\control.c:<global>,,false,1,206,<global>,,,1,
185106,METHOD,video_output\control.c:<global>,TYPE_DECL,"void vout_control_cmd_Init(vout_control_cmd_t *cmd, int type)
{
    memset(cmd, 0, sizeof(*cmd));
    cmd->type = type;
}",1,1,video_output\control.c,vout_control_cmd_Init,,false,33,37,vout_control_cmd_Init,,,1,"void vout_control_cmd_Init (vout_control_cmd_t*,int)"
185123,METHOD,video_output\control.c:<global>,TYPE_DECL,"void vout_control_cmd_Clean(vout_control_cmd_t *cmd)
{
    switch (cmd->type) {
    case VOUT_CONTROL_SUBPICTURE:
        if (cmd->u.subpicture)
            subpicture_Delete(cmd->u.subpicture);
        break;
    case VOUT_CONTROL_OSD_TITLE:
    case VOUT_CONTROL_CHANGE_FILTERS:
    case VOUT_CONTROL_CHANGE_SUB_SOURCES:
    case VOUT_CONTROL_CHANGE_SUB_FILTERS:
        free(cmd->u.string);
        break;
    default:
        break;
    }
}",1,1,video_output\control.c,vout_control_cmd_Clean,,false,39,55,vout_control_cmd_Clean,,,2,void vout_control_cmd_Clean (vout_control_cmd_t*)
185166,METHOD,video_output\control.c:<global>,TYPE_DECL,"void vout_control_Init(vout_control_t *ctrl)
{
    vlc_mutex_init(&ctrl->lock);
    vlc_cond_init(&ctrl->wait_request);
    vlc_cond_init(&ctrl->wait_acknowledge);

    ctrl->is_dead = false;
    ctrl->can_sleep = true;
    ctrl->is_processing = false;
    ARRAY_INIT(ctrl->cmd);
}",1,1,video_output\control.c,vout_control_Init,,false,58,68,vout_control_Init,,,3,void vout_control_Init (vout_control_t*)
185205,METHOD,video_output\control.c:<global>,TYPE_DECL,"void vout_control_Clean(vout_control_t *ctrl)
{
    /* */
    for (int i = 0; i < ctrl->cmd.i_size; i++) {
        vout_control_cmd_t cmd = ARRAY_VAL(ctrl->cmd, i);
        vout_control_cmd_Clean(&cmd);
    }
    ARRAY_RESET(ctrl->cmd);

    vlc_mutex_destroy(&ctrl->lock);
    vlc_cond_destroy(&ctrl->wait_request);
    vlc_cond_destroy(&ctrl->wait_acknowledge);
}",1,1,video_output\control.c,vout_control_Clean,,false,70,82,vout_control_Clean,,,4,void vout_control_Clean (vout_control_t*)
185256,METHOD,video_output\control.c:<global>,TYPE_DECL,"void vout_control_Dead(vout_control_t *ctrl)
{
    vlc_mutex_lock(&ctrl->lock);
    ctrl->is_dead = true;
    vlc_cond_broadcast(&ctrl->wait_acknowledge);
    vlc_mutex_unlock(&ctrl->lock);

}",1,1,video_output\control.c,vout_control_Dead,,false,84,91,vout_control_Dead,,,5,void vout_control_Dead (vout_control_t*)
185281,METHOD,video_output\control.c:<global>,TYPE_DECL,"void vout_control_WaitEmpty(vout_control_t *ctrl)
{
    vlc_mutex_lock(&ctrl->lock);
    while ((ctrl->cmd.i_size > 0 || ctrl->is_processing) && !ctrl->is_dead)
        vlc_cond_wait(&ctrl->wait_acknowledge, &ctrl->lock);
    vlc_mutex_unlock(&ctrl->lock);
}",1,1,video_output\control.c,vout_control_WaitEmpty,,false,93,99,vout_control_WaitEmpty,,,6,void vout_control_WaitEmpty (vout_control_t*)
185322,METHOD,video_output\control.c:<global>,TYPE_DECL,"void vout_control_Push(vout_control_t *ctrl, vout_control_cmd_t *cmd)
{
    vlc_mutex_lock(&ctrl->lock);
    if (!ctrl->is_dead) {
        ARRAY_APPEND(ctrl->cmd, *cmd);
        vlc_cond_signal(&ctrl->wait_request);
    } else {
        vout_control_cmd_Clean(cmd);
    }
    vlc_mutex_unlock(&ctrl->lock);
}",1,1,video_output\control.c,vout_control_Push,,false,101,111,vout_control_Push,,,7,"void vout_control_Push (vout_control_t*,vout_control_cmd_t*)"
185359,METHOD,video_output\control.c:<global>,TYPE_DECL,"void vout_control_Wake(vout_control_t *ctrl)
{
    vlc_mutex_lock(&ctrl->lock);
    ctrl->can_sleep = false;
    vlc_cond_signal(&ctrl->wait_request);
    vlc_mutex_unlock(&ctrl->lock);
}",1,1,video_output\control.c,vout_control_Wake,,false,113,119,vout_control_Wake,,,8,void vout_control_Wake (vout_control_t*)
185384,METHOD,video_output\control.c:<global>,TYPE_DECL,"void vout_control_PushVoid(vout_control_t *ctrl, int type)
{
    vout_control_cmd_t cmd;

    vout_control_cmd_Init(&cmd, type);
    vout_control_Push(ctrl, &cmd);
}",1,1,video_output\control.c,vout_control_PushVoid,,false,121,127,vout_control_PushVoid,,,9,"void vout_control_PushVoid (vout_control_t*,int)"
185399,METHOD,video_output\control.c:<global>,TYPE_DECL,"void vout_control_PushBool(vout_control_t *ctrl, int type, bool boolean)
{
    vout_control_cmd_t cmd;

    vout_control_cmd_Init(&cmd, type);
    cmd.u.boolean = boolean;
    vout_control_Push(ctrl, &cmd);
}",1,1,video_output\control.c,vout_control_PushBool,,false,128,135,vout_control_PushBool,,,10,"void vout_control_PushBool (vout_control_t*,int,bool)"
185422,METHOD,video_output\control.c:<global>,TYPE_DECL,"void vout_control_PushInteger(vout_control_t *ctrl, int type, int integer)
{
    vout_control_cmd_t cmd;

    vout_control_cmd_Init(&cmd, type);
    cmd.u.integer = integer;
    vout_control_Push(ctrl, &cmd);
}",1,1,video_output\control.c,vout_control_PushInteger,,false,136,143,vout_control_PushInteger,,,11,"void vout_control_PushInteger (vout_control_t*,int,int)"
185445,METHOD,video_output\control.c:<global>,TYPE_DECL,"void vout_control_PushTime(vout_control_t *ctrl, int type, mtime_t time)
{
    vout_control_cmd_t cmd;

    vout_control_cmd_Init(&cmd, type);
    cmd.u.time = time;
    vout_control_Push(ctrl, &cmd);
}",1,1,video_output\control.c,vout_control_PushTime,,false,144,151,vout_control_PushTime,,,12,"void vout_control_PushTime (vout_control_t*,int,mtime_t)"
185468,METHOD,video_output\control.c:<global>,TYPE_DECL,"void vout_control_PushMessage(vout_control_t *ctrl, int type, int channel, const char *string)
{
    vout_control_cmd_t cmd;

    vout_control_cmd_Init(&cmd, type);
    cmd.u.message.channel = channel;
    cmd.u.message.string = strdup(string);
    vout_control_Push(ctrl, &cmd);
}",1,1,video_output\control.c,vout_control_PushMessage,,false,152,160,vout_control_PushMessage,,,13,"void vout_control_PushMessage (vout_control_t*,int,int,char*)"
185504,METHOD,video_output\control.c:<global>,TYPE_DECL,"void vout_control_PushPair(vout_control_t *ctrl, int type, int a, int b)
{
    vout_control_cmd_t cmd;

    vout_control_cmd_Init(&cmd, type);
    cmd.u.pair.a = a;
    cmd.u.pair.b = b;
    vout_control_Push(ctrl, &cmd);
}",1,1,video_output\control.c,vout_control_PushPair,,false,161,169,vout_control_PushPair,,,14,"void vout_control_PushPair (vout_control_t*,int,int,int)"
185539,METHOD,video_output\control.c:<global>,TYPE_DECL,"void vout_control_PushString(vout_control_t *ctrl, int type, const char *string)
{
    vout_control_cmd_t cmd;

    vout_control_cmd_Init(&cmd, type);
    cmd.u.string = string ? strdup(string) : NULL;
    vout_control_Push(ctrl, &cmd);
}",1,1,video_output\control.c,vout_control_PushString,,false,170,177,vout_control_PushString,,,15,"void vout_control_PushString (vout_control_t*,int,char*)"
185566,METHOD,video_output\control.c:<global>,TYPE_DECL,"int vout_control_Pop(vout_control_t *ctrl, vout_control_cmd_t *cmd,
                     mtime_t deadline)
{
    vlc_mutex_lock(&ctrl->lock);
    if (ctrl->cmd.i_size <= 0) {
        ctrl->is_processing = false;
        vlc_cond_broadcast(&ctrl->wait_acknowledge);

        /* Spurious wakeups are perfectly fine */
        if (deadline > VLC_TS_INVALID && ctrl->can_sleep)
            vlc_cond_timedwait(&ctrl->wait_request, &ctrl->lock, deadline);
    }

    bool has_cmd;
    if (ctrl->cmd.i_size > 0) {
        has_cmd = true;
        *cmd = ARRAY_VAL(ctrl->cmd, 0);
        ARRAY_REMOVE(ctrl->cmd, 0);

        ctrl->is_processing = true;
    } else {
        has_cmd = false;
        ctrl->can_sleep = true;
    }
    vlc_mutex_unlock(&ctrl->lock);

    return has_cmd ? VLC_SUCCESS : VLC_EGENERIC;
}",1,1,video_output\control.c,vout_control_Pop,,false,179,206,vout_control_Pop,,,16,"int vout_control_Pop (vout_control_t*,vout_control_cmd_t*,mtime_t)"
185674,METHOD,video_output\control.h:<global>,TYPE_DECL,<global>,1,6,video_output\control.h,video_output\control.h:<global>,,false,1,144,<global>,,,1,
185740,METHOD,video_output\control.h:<global>,TYPE_DECL,"void vout_control_cmd_Init(vout_control_cmd_t *, int type);",6,58,video_output\control.h,vout_control_cmd_Init,,false,108,108,vout_control_cmd_Init,,,4,"void vout_control_cmd_Init (vout_control_cmd_t*,int)"
185746,METHOD,video_output\control.h:<global>,TYPE_DECL,void vout_control_cmd_Clean(vout_control_cmd_t *);,6,49,video_output\control.h,vout_control_cmd_Clean,,false,109,109,vout_control_cmd_Clean,,,5,void vout_control_cmd_Clean (vout_control_cmd_t*)
185760,METHOD,video_output\control.h:<global>,TYPE_DECL,void vout_control_Init(vout_control_t *);,6,40,video_output\control.h,vout_control_Init,,false,124,124,vout_control_Init,,,8,void vout_control_Init (vout_control_t*)
185765,METHOD,video_output\control.h:<global>,TYPE_DECL,void vout_control_Clean(vout_control_t *);,6,41,video_output\control.h,vout_control_Clean,,false,125,125,vout_control_Clean,,,9,void vout_control_Clean (vout_control_t*)
185770,METHOD,video_output\control.h:<global>,TYPE_DECL,void vout_control_WaitEmpty(vout_control_t *);,6,45,video_output\control.h,vout_control_WaitEmpty,,false,128,128,vout_control_WaitEmpty,,,10,void vout_control_WaitEmpty (vout_control_t*)
185775,METHOD,video_output\control.h:<global>,TYPE_DECL,"void vout_control_Push(vout_control_t *, vout_control_cmd_t *);",6,62,video_output\control.h,vout_control_Push,,false,130,130,vout_control_Push,,,11,"void vout_control_Push (vout_control_t*,vout_control_cmd_t*)"
185781,METHOD,video_output\control.h:<global>,TYPE_DECL,"void vout_control_PushVoid(vout_control_t *, int type);",6,54,video_output\control.h,vout_control_PushVoid,,false,131,131,vout_control_PushVoid,,,12,"void vout_control_PushVoid (vout_control_t*,int)"
185787,METHOD,video_output\control.h:<global>,TYPE_DECL,"void vout_control_PushBool(vout_control_t *, int type, bool boolean);",6,68,video_output\control.h,vout_control_PushBool,,false,132,132,vout_control_PushBool,,,13,"void vout_control_PushBool (vout_control_t*,int,bool)"
185794,METHOD,video_output\control.h:<global>,TYPE_DECL,"void vout_control_PushInteger(vout_control_t *, int type, int integer);",6,70,video_output\control.h,vout_control_PushInteger,,false,133,133,vout_control_PushInteger,,,14,"void vout_control_PushInteger (vout_control_t*,int,int)"
185801,METHOD,video_output\control.h:<global>,TYPE_DECL,"void vout_control_PushTime(vout_control_t *, int type, mtime_t time);",6,68,video_output\control.h,vout_control_PushTime,,false,134,134,vout_control_PushTime,,,15,"void vout_control_PushTime (vout_control_t*,int,mtime_t)"
185808,METHOD,video_output\control.h:<global>,TYPE_DECL,"void vout_control_PushMessage(vout_control_t *, int type, int channel, const char *string);",6,90,video_output\control.h,vout_control_PushMessage,,false,135,135,vout_control_PushMessage,,,16,"void vout_control_PushMessage (vout_control_t*,int,int,char*)"
185816,METHOD,video_output\control.h:<global>,TYPE_DECL,"void vout_control_PushPair(vout_control_t *, int type, int a, int b);",6,68,video_output\control.h,vout_control_PushPair,,false,136,136,vout_control_PushPair,,,17,"void vout_control_PushPair (vout_control_t*,int,int,int)"
185824,METHOD,video_output\control.h:<global>,TYPE_DECL,"void vout_control_PushString(vout_control_t *, int type, const char *string);",6,76,video_output\control.h,vout_control_PushString,,false,137,137,vout_control_PushString,,,18,"void vout_control_PushString (vout_control_t*,int,char*)"
185831,METHOD,video_output\control.h:<global>,TYPE_DECL,void vout_control_Wake(vout_control_t *);,6,40,video_output\control.h,vout_control_Wake,,false,138,138,vout_control_Wake,,,19,void vout_control_Wake (vout_control_t*)
185836,METHOD,video_output\control.h:<global>,TYPE_DECL,"int vout_control_Pop(vout_control_t *, vout_control_cmd_t *, mtime_t deadline);",5,78,video_output\control.h,vout_control_Pop,,false,141,141,vout_control_Pop,,,20,"int vout_control_Pop (vout_control_t*,vout_control_cmd_t*,mtime_t)"
185843,METHOD,video_output\control.h:<global>,TYPE_DECL,void vout_control_Dead(vout_control_t *);,6,40,video_output\control.h,vout_control_Dead,,false,142,142,vout_control_Dead,,,21,void vout_control_Dead (vout_control_t*)
185881,METHOD,video_output\display.c:<global>,TYPE_DECL,<global>,1,1,video_output\display.c,video_output\display.c:<global>,,false,1,1542,<global>,,,1,
185883,METHOD,video_output\display.c:<global>,TYPE_DECL,static void SplitterClose(vout_display_t *vd);,13,45,video_output\display.c,SplitterClose,,false,48,48,SplitterClose,,,1,void SplitterClose (vout_display_t*)
185888,METHOD,video_output\display.c:<global>,TYPE_DECL,"static picture_t *VideoBufferNew(filter_t *filter)
{
    vout_display_t *vd = filter->owner.sys;
    const video_format_t *fmt = &filter->fmt_out.video;

    assert(vd->fmt.i_chroma == fmt->i_chroma &&
           vd->fmt.i_width  == fmt->i_width  &&
           vd->fmt.i_height == fmt->i_height);

    picture_pool_t *pool = vout_display_Pool(vd, 3);
    if (!pool)
        return NULL;
    return picture_pool_Get(pool);
}",1,1,video_output\display.c,VideoBufferNew,,false,53,66,VideoBufferNew,,,2,picture_t VideoBufferNew (filter_t*)
185955,METHOD,video_output\display.c:<global>,TYPE_DECL,"static vout_display_t *vout_display_New(vlc_object_t *obj,
                                        const char *module, bool load_module,
                                        const video_format_t *fmt,
                                        const vout_display_cfg_t *cfg,
                                        vout_display_owner_t *owner)
{
    /* */
    vout_display_t *vd = vlc_custom_create(obj, sizeof(*vd), ""vout display"" );

    /* */
    video_format_Copy(&vd->source, fmt);

    /* Picture buffer does not have the concept of aspect ratio */
    video_format_Copy(&vd->fmt, fmt);
    vd->fmt.i_sar_num = 0;
    vd->fmt.i_sar_den = 0;

    vd->info.is_slow = false;
    vd->info.has_double_click = false;
    vd->info.needs_hide_mouse = false;
    vd->info.has_pictures_invalid = false;
    vd->info.subpicture_chromas = NULL;

    vd->cfg = cfg;
    vd->pool = NULL;
    vd->prepare = NULL;
    vd->display = NULL;
    vd->control = NULL;
    vd->manage = NULL;
    vd->sys = NULL;

 ...",1,1,video_output\display.c,vout_display_New,,false,75,118,vout_display_New,,,3,"vout_display_t vout_display_New (vlc_object_t*,char*,bool,video_format_t*,vout_display_cfg_t*,vout_display_owner_t*)"
186112,METHOD,video_output\display.c:<global>,TYPE_DECL,"static void vout_display_Delete(vout_display_t *vd)
{
    if (vd->module)
        module_unneed(vd, vd->module);

    video_format_Clean(&vd->source);
    video_format_Clean(&vd->fmt);

    vlc_object_release(vd);
}",1,1,video_output\display.c,vout_display_Delete,,false,123,132,vout_display_Delete,,,4,void vout_display_Delete (vout_display_t*)
186139,METHOD,video_output\display.c:<global>,TYPE_DECL,"static int vout_display_Control(vout_display_t *vd, int query, ...)
{
    va_list args;
    int result;

    va_start(args, query);
    result = vd->control(vd, query, args);
    va_end(args);

    return result;
}",1,1,video_output\display.c,vout_display_Control,,false,137,147,vout_display_Control,,,5,"int vout_display_Control (vout_display_t*,int...)"
186163,METHOD,video_output\display.c:<global>,TYPE_DECL,"static void vout_display_Manage(vout_display_t *vd)
{
    if (vd->manage)
        vd->manage(vd);
}",1,1,video_output\display.c,vout_display_Manage,,false,149,153,vout_display_Manage,,,6,void vout_display_Manage (vout_display_t*)
186178,METHOD,video_output\display.c:<global>,TYPE_DECL,"void vout_display_GetDefaultDisplaySize(unsigned *width, unsigned *height,
                                        const video_format_t *source,
                                        const vout_display_cfg_t *cfg)
{
    if (cfg->display.width != 0 && cfg->display.height != 0) {
        *width  = cfg->display.width;
        *height = cfg->display.height;
    } else if (cfg->display.width != 0) {
        *width  = cfg->display.width;
        *height = (int64_t)source->i_visible_height * source->i_sar_den * cfg->display.width * cfg->display.sar.num /
            source->i_visible_width / source->i_sar_num / cfg->display.sar.den;
    } else if (cfg->display.height != 0) {
        *width  = (int64_t)source->i_visible_width * source->i_sar_num * cfg->display.height * cfg->display.sar.den /
            source->i_visible_height / source->i_sar_den / cfg->display.sar.num;
        *height = cfg->display.height;
    } else if (source->i_sar_num >= source->i_sar_den) {
        *width  = (int6...",1,1,video_output\display.c,vout_display_GetDefaultDisplaySize,,false,156,188,vout_display_GetDefaultDisplaySize,,,7,"void vout_display_GetDefaultDisplaySize (unsigned*,unsigned*,video_format_t*,vout_display_cfg_t*)"
186484,METHOD,video_output\display.c:<global>,TYPE_DECL,"void vout_display_PlacePicture(vout_display_place_t *place,
                               const video_format_t *source,
                               const vout_display_cfg_t *cfg,
                               bool do_clipping)
{
    /* */
    memset(place, 0, sizeof(*place));
    if (cfg->display.width == 0 || cfg->display.height == 0)
        return;

    /* */
    unsigned display_width;
    unsigned display_height;

    video_format_t source_rot;
    video_format_ApplyRotation(&source_rot, source);
    source = &source_rot;

    if (cfg->is_display_filled) {
        display_width  = cfg->display.width;
        display_height = cfg->display.height;
    } else {
        vout_display_cfg_t cfg_tmp = *cfg;

        cfg_tmp.display.width  = 0;
        cfg_tmp.display.height = 0;
        vout_display_GetDefaultDisplaySize(&display_width, &display_height,
                                           source, &cfg_tmp);

        if (do_clipping) {
            display_width  = __MIN(dis...",1,1,video_output\display.c,vout_display_PlacePicture,,false,191,273,vout_display_PlacePicture,,,8,"void vout_display_PlacePicture (vout_display_place_t*,video_format_t*,vout_display_cfg_t*,bool)"
186830,METHOD,video_output\display.c:<global>,TYPE_DECL,"void vout_display_SendMouseMovedDisplayCoordinates(vout_display_t *vd, video_orientation_t orient_display, int m_x, int m_y, vout_display_place_t *place)
{
    video_format_t source_rot = vd->source;
    video_format_TransformTo(&source_rot, orient_display);

    if (place->width > 0 && place->height > 0) {

        int x = (int)(source_rot.i_x_offset +
                            (int64_t)(m_x - place->x) * source_rot.i_visible_width / place->width);
        int y = (int)(source_rot.i_y_offset +
                            (int64_t)(m_y - place->y) * source_rot.i_visible_height/ place->height);

        video_transform_t transform = video_format_GetTransform(vd->source.orientation, orient_display);

        int store;

        switch (transform) {

            case TRANSFORM_R90:
                store = x;
                x = y;
                y = vd->source.i_visible_height - store;
                break;
            case TRANSFORM_R180:
                x = vd->source.i_visible_w...",1,1,video_output\display.c,vout_display_SendMouseMovedDisplayCoordinates,,false,275,329,vout_display_SendMouseMovedDisplayCoordinates,,,9,"void vout_display_SendMouseMovedDisplayCoordinates (vout_display_t*,video_orientation_t,int,int,vout_display_place_t*)"
187093,METHOD,video_output\display.c:<global>,TYPE_DECL,"static int VoutDisplayCreateRender(vout_display_t *vd)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;
    filter_owner_t owner = {
        .sys = vd,
        .video = {
            .buffer_new = VideoBufferNew,
        },
    };

    osys->filters = filter_chain_NewVideo(vd, false, &owner);
    if (unlikely(osys->filters == NULL))
        return -1;

    video_format_t v_src = vd->source;
    v_src.i_sar_num = 0;
    v_src.i_sar_den = 0;

    video_format_t v_dst = vd->fmt;
    v_dst.i_sar_num = 0;
    v_dst.i_sar_den = 0;

    video_format_t v_dst_cmp = v_dst;
    if ((v_src.i_chroma == VLC_CODEC_J420 && v_dst.i_chroma == VLC_CODEC_I420) ||
        (v_src.i_chroma == VLC_CODEC_J422 && v_dst.i_chroma == VLC_CODEC_I422) ||
        (v_src.i_chroma == VLC_CODEC_J440 && v_dst.i_chroma == VLC_CODEC_I440) ||
        (v_src.i_chroma == VLC_CODEC_J444 && v_dst.i_chroma == VLC_CODEC_I444))
        v_dst_cmp.i_chroma = v_src.i_chroma;

    const bool convert = memcmp(&v_src, &v_dst_cmp...",1,1,video_output\display.c,VoutDisplayCreateRender,,false,402,464,VoutDisplayCreateRender,,,12,int VoutDisplayCreateRender (vout_display_t*)
187355,METHOD,video_output\display.c:<global>,TYPE_DECL,"static void VoutDisplayDestroyRender(vout_display_t *vd)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    if (osys->filters)
        filter_chain_Delete(osys->filters);
}",1,1,video_output\display.c,VoutDisplayDestroyRender,,false,466,472,VoutDisplayDestroyRender,,,13,void VoutDisplayDestroyRender (vout_display_t*)
187377,METHOD,video_output\display.c:<global>,TYPE_DECL,"static int VoutDisplayResetRender(vout_display_t *vd)
{
    VoutDisplayDestroyRender(vd);
    return VoutDisplayCreateRender(vd);
}",1,1,video_output\display.c,VoutDisplayResetRender,,false,474,478,VoutDisplayResetRender,,,14,int VoutDisplayResetRender (vout_display_t*)
187387,METHOD,video_output\display.c:<global>,TYPE_DECL,"static void VoutDisplayEventMouse(vout_display_t *vd, int event, va_list args)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    vlc_mutex_lock(&osys->lock);

    /* */
    vlc_mouse_t m = osys->mouse.state;
    bool is_ignored = false;

    switch (event) {
    case VOUT_DISPLAY_EVENT_MOUSE_STATE: {
        const int x = (int)va_arg(args, int);
        const int y = (int)va_arg(args, int);
        const int button_mask = (int)va_arg(args, int);

        vlc_mouse_Init(&m);
        m.i_x = x;
        m.i_y = y;
        m.i_pressed = button_mask;
        break;
    }
    case VOUT_DISPLAY_EVENT_MOUSE_MOVED: {
        const int x = (int)va_arg(args, int);
        const int y = (int)va_arg(args, int);

        //msg_Dbg(vd, ""VoutDisplayEvent 'mouse' @%d,%d"", x, y);

        m.i_x = x;
        m.i_y = y;
        m.b_double_click = false;
        break;
    }
    case VOUT_DISPLAY_EVENT_MOUSE_PRESSED:
    case VOUT_DISPLAY_EVENT_MOUSE_RELEASED: {
        const int button = (int)...",1,1,video_output\display.c,VoutDisplayEventMouse,,false,480,572,VoutDisplayEventMouse,,,15,"void VoutDisplayEventMouse (vout_display_t*,int,va_list)"
187656,METHOD,video_output\display.c:<global>,TYPE_DECL,"static void VoutDisplayEvent(vout_display_t *vd, int event, va_list args)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    switch (event) {
    case VOUT_DISPLAY_EVENT_CLOSE: {
        msg_Dbg(vd, ""VoutDisplayEvent 'close'"");
        vout_SendEventClose(osys->vout);
        break;
    }
    case VOUT_DISPLAY_EVENT_KEY: {
        const int key = (int)va_arg(args, int);
        msg_Dbg(vd, ""VoutDisplayEvent 'key' 0x%2.2x"", key);
        vout_SendEventKey(osys->vout, key);
        break;
    }
    case VOUT_DISPLAY_EVENT_MOUSE_STATE:
    case VOUT_DISPLAY_EVENT_MOUSE_MOVED:
    case VOUT_DISPLAY_EVENT_MOUSE_PRESSED:
    case VOUT_DISPLAY_EVENT_MOUSE_RELEASED:
    case VOUT_DISPLAY_EVENT_MOUSE_DOUBLE_CLICK:
        VoutDisplayEventMouse(vd, event, args);
        break;

    case VOUT_DISPLAY_EVENT_VIEWPOINT_MOVED:
        vout_SendEventViewpointMoved(osys->vout,
                                     va_arg(args, const vlc_viewpoint_t *));
        break;

#if defined(_WIN32) || ...",1,1,video_output\display.c,VoutDisplayEvent,,false,574,666,VoutDisplayEvent,,,16,"void VoutDisplayEvent (vout_display_t*,int,va_list)"
187788,METHOD,video_output\display.c:<global>,TYPE_DECL,"static vout_window_t *VoutDisplayNewWindow(vout_display_t *vd, unsigned type)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;
    vout_window_t *window = vout_NewDisplayWindow(osys->vout, type);
    if (window != NULL)
        vout_display_window_Attach(window, vd);
    return window;
}",1,1,video_output\display.c,VoutDisplayNewWindow,,false,668,675,VoutDisplayNewWindow,,,17,"vout_window_t VoutDisplayNewWindow (vout_display_t*,unsigned)"
187820,METHOD,video_output\display.c:<global>,TYPE_DECL,"static void VoutDisplayDelWindow(vout_display_t *vd, vout_window_t *window)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    if (window != NULL)
        vout_display_window_Detach(window);
    vout_DeleteDisplayWindow(osys->vout, window);
}",1,1,video_output\display.c,VoutDisplayDelWindow,,false,677,684,VoutDisplayDelWindow,,,18,"void VoutDisplayDelWindow (vout_display_t*,vout_window_t*)"
187846,METHOD,video_output\display.c:<global>,TYPE_DECL,"static void VoutDisplayFitWindow(vout_display_t *vd, bool default_size)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;
    vout_display_cfg_t cfg = osys->cfg;

    if (!cfg.is_display_filled)
        return;

    cfg.display.width = 0;
    if (default_size) {
        cfg.display.height = 0;
    } else {
        cfg.zoom.num = 1;
        cfg.zoom.den = 1;
    }

    unsigned display_width;
    unsigned display_height;
    vout_display_GetDefaultDisplaySize(&display_width, &display_height,
                                       &vd->source, &cfg);
    vout_SetDisplayWindowSize(osys->vout, display_width, display_height);
}",1,1,video_output\display.c,VoutDisplayFitWindow,,false,686,707,VoutDisplayFitWindow,,,19,"void VoutDisplayFitWindow (vout_display_t*,bool)"
187925,METHOD,video_output\display.c:<global>,TYPE_DECL,"static void VoutDisplayCropRatio(int *left, int *top, int *right, int *bottom,
                                 const video_format_t *source,
                                 unsigned num, unsigned den)
{
    unsigned scaled_width  = (uint64_t)source->i_visible_height * num * source->i_sar_den / den / source->i_sar_num;
    unsigned scaled_height = (uint64_t)source->i_visible_width  * den * source->i_sar_num / num / source->i_sar_den;

    if (scaled_width < source->i_visible_width) {
        *left   = (source->i_visible_width - scaled_width) / 2;
        *top    = 0;
        *right  = *left + scaled_width;
        *bottom = *top  + source->i_visible_height;
    } else {
        *left   = 0;
        *top    = (source->i_visible_height - scaled_height) / 2;
        *right  = *left + source->i_visible_width;
        *bottom = *top  + scaled_height;
    }
}",1,1,video_output\display.c,VoutDisplayCropRatio,,false,709,727,VoutDisplayCropRatio,,,20,"void VoutDisplayCropRatio (int*,int*,int*,int*,video_format_t*,unsigned,unsigned)"
188045,METHOD,video_output\display.c:<global>,TYPE_DECL,"bool vout_ManageDisplay(vout_display_t *vd, bool allow_reset_pictures)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    vout_display_Manage(vd);

    /* Handle mouse timeout */
    const mtime_t date = mdate();
    bool  hide_mouse = false;

    vlc_mutex_lock(&osys->lock);

    if (!osys->mouse.is_hidden &&
        osys->mouse.last_moved + osys->mouse.hide_timeout < date) {
        osys->mouse.is_hidden = hide_mouse = true;
    } else if (osys->mouse.ch_activity) {
        if (osys->mouse.is_hidden)
            vout_HideWindowMouse(osys->vout, false);
        osys->mouse.is_hidden = false;
    }
    osys->mouse.ch_activity = false;
    vlc_mutex_unlock(&osys->lock);

    if (hide_mouse) {
        msg_Dbg(vd, ""auto hiding mouse cursor"");
        if (vout_HideWindowMouse(osys->vout, true) != VLC_SUCCESS
         && vd->info.needs_hide_mouse)
            vout_display_Control(vd, VOUT_DISPLAY_HIDE_MOUSE);
    }

    bool reset_render = false;
    for (;;) {

        vlc_mutex...",1,1,video_output\display.c,vout_ManageDisplay,,false,729,963,vout_ManageDisplay,,,21,"bool vout_ManageDisplay (vout_display_t*,bool)"
189032,METHOD,video_output\display.c:<global>,TYPE_DECL,"bool vout_AreDisplayPicturesInvalid(vout_display_t *vd)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    vlc_mutex_lock(&osys->lock);
    const bool reset_pictures = osys->reset_pictures;
    vlc_mutex_unlock(&osys->lock);

    return reset_pictures;
}",1,1,video_output\display.c,vout_AreDisplayPicturesInvalid,,false,965,974,vout_AreDisplayPicturesInvalid,,,22,bool vout_AreDisplayPicturesInvalid (vout_display_t*)
189063,METHOD,video_output\display.c:<global>,TYPE_DECL,"bool vout_IsDisplayFiltered(vout_display_t *vd)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    return osys->filters == NULL || !filter_chain_IsEmpty(osys->filters);
}",1,1,video_output\display.c,vout_IsDisplayFiltered,,false,976,981,vout_IsDisplayFiltered,,,23,bool vout_IsDisplayFiltered (vout_display_t*)
189088,METHOD,video_output\display.c:<global>,TYPE_DECL,"picture_t *vout_FilterDisplay(vout_display_t *vd, picture_t *picture)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    if (osys->filters == NULL) {
        picture_Release(picture);
        return NULL;
    }

    return filter_chain_VideoFilter(osys->filters, picture);
}",1,1,video_output\display.c,vout_FilterDisplay,,false,983,993,vout_FilterDisplay,,,24,"picture_t vout_FilterDisplay (vout_display_t*,picture_t*)"
189119,METHOD,video_output\display.c:<global>,TYPE_DECL,"void vout_FilterFlush(vout_display_t *vd)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    if (osys->filters != NULL)
        filter_chain_VideoFlush(osys->filters);
}",1,1,video_output\display.c,vout_FilterFlush,,false,995,1001,vout_FilterFlush,,,25,void vout_FilterFlush (vout_display_t*)
189143,METHOD,video_output\display.c:<global>,TYPE_DECL,"void vout_UpdateDisplaySourceProperties(vout_display_t *vd, const video_format_t *source)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    if (source->i_sar_num * osys->source.i_sar_den !=
        source->i_sar_den * osys->source.i_sar_num) {

        osys->source.i_sar_num = source->i_sar_num;
        osys->source.i_sar_den = source->i_sar_den;
        vlc_ureduce(&osys->source.i_sar_num, &osys->source.i_sar_den,
                    osys->source.i_sar_num, osys->source.i_sar_den, 0);

        /* FIXME it will override any AR that the user would have forced */
        osys->ch_sar = true;
        osys->sar.num = osys->source.i_sar_num;
        osys->sar.den = osys->source.i_sar_den;
    }
    if (source->i_x_offset       != osys->source.i_x_offset ||
        source->i_y_offset       != osys->source.i_y_offset ||
        source->i_visible_width  != osys->source.i_visible_width ||
        source->i_visible_height != osys->source.i_visible_height) {

        video_format_Copy...",1,1,video_output\display.c,vout_UpdateDisplaySourceProperties,,false,1003,1031,vout_UpdateDisplaySourceProperties,,,26,"void vout_UpdateDisplaySourceProperties (vout_display_t*,video_format_t*)"
189299,METHOD,video_output\display.c:<global>,TYPE_DECL,"void vout_SetDisplayFilled(vout_display_t *vd, bool is_filled)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    osys->is_display_filled = is_filled;
}",1,1,video_output\display.c,vout_SetDisplayFilled,,false,1033,1038,vout_SetDisplayFilled,,,27,"void vout_SetDisplayFilled (vout_display_t*,bool)"
189318,METHOD,video_output\display.c:<global>,TYPE_DECL,"void vout_SetDisplayZoom(vout_display_t *vd, unsigned num, unsigned den)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    if (num != 0 && den != 0) {
        vlc_ureduce(&num, &den, num, den, 0);
    } else {
        num = 1;
        den = 1;
    }

    if (10 * num <= den) {
        num = 1;
        den = 10;
    } else if (num >= 10 * den) {
        num = 10;
        den = 1;
    }

    if (osys->is_display_filled ||
        osys->zoom.num != num || osys->zoom.den != den) {
        osys->ch_zoom = true;
        osys->zoom.num = num;
        osys->zoom.den = den;
    }
}",1,1,video_output\display.c,vout_SetDisplayZoom,,false,1040,1065,vout_SetDisplayZoom,,,28,"void vout_SetDisplayZoom (vout_display_t*,unsigned,unsigned)"
189426,METHOD,video_output\display.c:<global>,TYPE_DECL,"void vout_SetDisplayAspect(vout_display_t *vd, unsigned dar_num, unsigned dar_den)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    unsigned sar_num, sar_den;
    if (dar_num > 0 && dar_den > 0) {
        sar_num = dar_num * osys->source.i_visible_height;
        sar_den = dar_den * osys->source.i_visible_width;
        vlc_ureduce(&sar_num, &sar_den, sar_num, sar_den, 0);
    } else {
        sar_num = 0;
        sar_den = 0;
    }

    if (osys->sar.num != sar_num || osys->sar.den != sar_den) {
        osys->ch_sar = true;
        osys->sar.num = sar_num;
        osys->sar.den = sar_den;
    }
}",1,1,video_output\display.c,vout_SetDisplayAspect,,false,1067,1086,vout_SetDisplayAspect,,,29,"void vout_SetDisplayAspect (vout_display_t*,unsigned,unsigned)"
189522,METHOD,video_output\display.c:<global>,TYPE_DECL,"void vout_SetDisplayCrop(vout_display_t *vd,
                         unsigned crop_num, unsigned crop_den,
                         unsigned left, unsigned top, int right, int bottom)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    if (osys->crop.left  != (int)left  || osys->crop.top != (int)top ||
        osys->crop.right != right || osys->crop.bottom != bottom ||
        (crop_num != 0 && crop_den != 0 &&
         (crop_num != osys->crop.num || crop_den != osys->crop.den))) {

        osys->crop.left   = left;
        osys->crop.top    = top;
        osys->crop.right  = right;
        osys->crop.bottom = bottom;
        osys->crop.num    = crop_num;
        osys->crop.den    = crop_den;

        osys->ch_crop = true;
    }
}",1,1,video_output\display.c,vout_SetDisplayCrop,,false,1087,1107,vout_SetDisplayCrop,,,30,"void vout_SetDisplayCrop (vout_display_t*,unsigned,unsigned,unsigned,unsigned,int,int)"
189649,METHOD,video_output\display.c:<global>,TYPE_DECL,"void vout_SetDisplayViewpoint(vout_display_t *vd,
                              const vlc_viewpoint_t *p_viewpoint)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    if (osys->viewpoint.yaw   != p_viewpoint->yaw ||
        osys->viewpoint.pitch != p_viewpoint->pitch ||
        osys->viewpoint.roll  != p_viewpoint->roll ||
        osys->viewpoint.fov   != p_viewpoint->fov) {
        osys->viewpoint = *p_viewpoint;

        osys->ch_viewpoint = true;
    }
}",1,1,video_output\display.c,vout_SetDisplayViewpoint,,false,1109,1122,vout_SetDisplayViewpoint,,,31,"void vout_SetDisplayViewpoint (vout_display_t*,vlc_viewpoint_t*)"
189715,METHOD,video_output\display.c:<global>,TYPE_DECL,"static vout_display_t *DisplayNew(vout_thread_t *vout,
                                  const video_format_t *source,
                                  const vout_display_state_t *state,
                                  const char *module, bool is_splitter,
                                  mtime_t double_click_timeout,
                                  mtime_t hide_timeout,
                                  const vout_display_owner_t *owner_ptr)
{
    /* */
    vout_display_owner_sys_t *osys = calloc(1, sizeof(*osys));
    vout_display_cfg_t *cfg = &osys->cfg;

    *cfg = state->cfg;
    osys->sar_initial = state->sar;
    vout_display_GetDefaultDisplaySize(&cfg->display.width, &cfg->display.height,
                                       source, cfg);

    osys->vout = vout;
    osys->is_splitter = is_splitter;

    vlc_mutex_init(&osys->lock);

    vlc_mouse_Init(&osys->mouse.state);
    osys->mouse.last_moved = mdate();
    osys->mouse.double_click_timeout = double_click_timeou...",1,1,video_output\display.c,DisplayNew,,false,1124,1222,DisplayNew,,,32,"vout_display_t DisplayNew (vout_thread_t*,video_format_t*,vout_display_state_t*,char*,bool,mtime_t,mtime_t,vout_display_owner_t*)"
190064,METHOD,video_output\display.c:<global>,TYPE_DECL,"void vout_DeleteDisplay(vout_display_t *vd, vout_display_state_t *state)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    if (state) {
        if (!osys->is_splitter)
            state->cfg = osys->cfg;
#if defined(_WIN32) || defined(__OS2__)
        state->wm_state = osys->wm_state;
#endif
        state->sar = osys->sar_initial;
    }

    VoutDisplayDestroyRender(vd);
    if (osys->is_splitter)
        SplitterClose(vd);
    vout_display_Delete(vd);
    vlc_mutex_destroy(&osys->lock);
    free(osys);
}",1,1,video_output\display.c,vout_DeleteDisplay,,false,1224,1243,vout_DeleteDisplay,,,33,"void vout_DeleteDisplay (vout_display_t*,vout_display_state_t*)"
190119,METHOD,video_output\display.c:<global>,TYPE_DECL,"vout_display_t *vout_NewDisplay(vout_thread_t *vout,
                                const video_format_t *source,
                                const vout_display_state_t *state,
                                const char *module,
                                mtime_t double_click_timeout,
                                mtime_t hide_timeout)
{
    return DisplayNew(vout, source, state, module, false,
                      double_click_timeout, hide_timeout, NULL);
}",1,1,video_output\display.c,vout_NewDisplay,,false,1248,1257,vout_NewDisplay,,,34,"vout_display_t vout_NewDisplay (vout_thread_t*,video_format_t*,vout_display_state_t*,char*,mtime_t,mtime_t)"
190147,METHOD,video_output\display.c:<global>,TYPE_DECL,"static vout_window_t *SplitterNewWindow(vout_display_t *vd, unsigned type)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;
    vout_window_t *window;
    vout_window_cfg_t cfg = {
        .type = type,
        .width = vd->cfg->display.width,
        .height = vd->cfg->display.height,
        .is_standalone = true,
    };

    window = vout_display_window_New(osys->vout, &cfg);
    if (window != NULL)
        vout_display_window_Attach(window, vd);
    return window;
}",1,1,video_output\display.c,SplitterNewWindow,,false,1275,1290,SplitterNewWindow,,,37,"vout_window_t SplitterNewWindow (vout_display_t*,unsigned)"
190212,METHOD,video_output\display.c:<global>,TYPE_DECL,"static void SplitterDelWindow(vout_display_t *vd, vout_window_t *window)
{
    if (window != NULL) {
        vout_display_window_Detach(window);
        vout_display_window_Delete(window);
    }
    (void) vd;
}",1,1,video_output\display.c,SplitterDelWindow,,false,1292,1299,SplitterDelWindow,,,38,"void SplitterDelWindow (vout_display_t*,vout_window_t*)"
190230,METHOD,video_output\display.c:<global>,TYPE_DECL,"static void SplitterEvent(vout_display_t *vd, int event, va_list args)
{
    //vout_display_owner_sys_t *osys = vd->owner.sys;

    switch (event) {
#if 0
    case VOUT_DISPLAY_EVENT_MOUSE_STATE:
    case VOUT_DISPLAY_EVENT_MOUSE_MOVED:
    case VOUT_DISPLAY_EVENT_MOUSE_PRESSED:
    case VOUT_DISPLAY_EVENT_MOUSE_RELEASED:
        /* TODO */
        break;
#endif
    case VOUT_DISPLAY_EVENT_MOUSE_DOUBLE_CLICK:
    case VOUT_DISPLAY_EVENT_KEY:
    case VOUT_DISPLAY_EVENT_CLOSE:
    case VOUT_DISPLAY_EVENT_DISPLAY_SIZE:
    case VOUT_DISPLAY_EVENT_PICTURES_INVALID:
        VoutDisplayEvent(vd, event, args);
        break;

    default:
        msg_Err(vd, ""splitter event not implemented: %d"", event);
        break;
    }
}",1,1,video_output\display.c,SplitterEvent,,false,1301,1326,SplitterEvent,,,39,"void SplitterEvent (vout_display_t*,int,va_list)"
190261,METHOD,video_output\display.c:<global>,TYPE_DECL,"static picture_pool_t *SplitterPool(vout_display_t *vd, unsigned count)
{
    vout_display_sys_t *sys = vd->sys;
    if (!sys->pool)
        sys->pool = picture_pool_NewFromFormat(&vd->fmt, count);
    return sys->pool;
}",1,1,video_output\display.c,SplitterPool,,false,1328,1334,SplitterPool,,,40,"picture_pool_t SplitterPool (vout_display_t*,unsigned)"
190293,METHOD,video_output\display.c:<global>,TYPE_DECL,"static void SplitterPrepare(vout_display_t *vd,
                            picture_t *picture,
                            subpicture_t *subpicture)
{
    vout_display_sys_t *sys = vd->sys;

    picture_Hold(picture);
    assert(!subpicture);

    if (video_splitter_Filter(sys->splitter, sys->picture, picture)) {
        for (int i = 0; i < sys->count; i++)
            sys->picture[i] = NULL;
        return;
    }

    for (int i = 0; i < sys->count; i++) {
        sys->picture[i] = vout_FilterDisplay(sys->display[i], sys->picture[i]);
        if (sys->picture[i])
            vout_display_Prepare(sys->display[i], sys->picture[i], NULL);
    }
}",1,1,video_output\display.c,SplitterPrepare,,false,1335,1355,SplitterPrepare,,,41,"void SplitterPrepare (vout_display_t*,picture_t*,subpicture_t*)"
190392,METHOD,video_output\display.c:<global>,TYPE_DECL,"static void SplitterDisplay(vout_display_t *vd,
                            picture_t *picture,
                            subpicture_t *subpicture)
{
    vout_display_sys_t *sys = vd->sys;

    assert(!subpicture);
    for (int i = 0; i < sys->count; i++) {
        if (sys->picture[i])
            vout_display_Display(sys->display[i], sys->picture[i], NULL);
    }
    picture_Release(picture);
}",1,1,video_output\display.c,SplitterDisplay,,false,1356,1368,SplitterDisplay,,,42,"void SplitterDisplay (vout_display_t*,picture_t*,subpicture_t*)"
190443,METHOD,video_output\display.c:<global>,TYPE_DECL,"static int SplitterControl(vout_display_t *vd, int query, va_list args)
{
    (void)vd; (void)query; (void)args;
    return VLC_EGENERIC;
}",1,1,video_output\display.c,SplitterControl,,false,1369,1373,SplitterControl,,,43,"int SplitterControl (vout_display_t*,int,va_list)"
190461,METHOD,video_output\display.c:<global>,TYPE_DECL,"static void SplitterManage(vout_display_t *vd)
{
    vout_display_sys_t *sys = vd->sys;

    for (int i = 0; i < sys->count; i++)
        vout_ManageDisplay(sys->display[i], true);
}",1,1,video_output\display.c,SplitterManage,,false,1374,1380,SplitterManage,,,44,void SplitterManage (vout_display_t*)
190492,METHOD,video_output\display.c:<global>,TYPE_DECL,"static int SplitterPictureNew(video_splitter_t *splitter, picture_t *picture[])
{
    vout_display_sys_t *wsys = splitter->p_owner->wrapper->sys;

    for (int i = 0; i < wsys->count; i++) {
        if (vout_IsDisplayFiltered(wsys->display[i])) {
            /* TODO use a pool ? */
            picture[i] = picture_NewFromFormat(&wsys->display[i]->source);
        } else {
            picture_pool_t *pool = vout_display_Pool(wsys->display[i], 3);
            picture[i] = pool ? picture_pool_Get(pool) : NULL;
        }
        if (!picture[i]) {
            for (int j = 0; j < i; j++)
                picture_Release(picture[j]);
            return VLC_EGENERIC;
        }
    }
    return VLC_SUCCESS;
}",1,1,video_output\display.c,SplitterPictureNew,,false,1382,1401,SplitterPictureNew,,,45,"int SplitterPictureNew (video_splitter_t*,picture_t[]*)"
190589,METHOD,video_output\display.c:<global>,TYPE_DECL,"static void SplitterPictureDel(video_splitter_t *splitter, picture_t *picture[])
{
    vout_display_sys_t *wsys = splitter->p_owner->wrapper->sys;

    for (int i = 0; i < wsys->count; i++)
        picture_Release(picture[i]);
}",1,1,video_output\display.c,SplitterPictureDel,,false,1402,1408,SplitterPictureDel,,,46,"void SplitterPictureDel (video_splitter_t*,picture_t[]*)"
190622,METHOD,video_output\display.c:<global>,TYPE_DECL,"static void SplitterClose(vout_display_t *vd)
{
    vout_display_sys_t *sys = vd->sys;

    /* */
    video_splitter_t *splitter = sys->splitter;
    free(splitter->p_owner);
    video_splitter_Delete(splitter);

    if (sys->pool)
        picture_pool_Release(sys->pool);

    /* */
    for (int i = 0; i < sys->count; i++)
        vout_DeleteDisplay(sys->display[i], NULL);
    TAB_CLEAN(sys->count, sys->display);
    free(sys->picture);

    free(sys);
}",1,1,video_output\display.c,SplitterClose,,false,1409,1428,SplitterClose,,,47,void SplitterClose (vout_display_t*)
190687,METHOD,video_output\display.c:<global>,TYPE_DECL,"vout_display_t *vout_NewSplitter(vout_thread_t *vout,
                                 const video_format_t *source,
                                 const vout_display_state_t *state,
                                 const char *module,
                                 const char *splitter_module,
                                 mtime_t double_click_timeout,
                                 mtime_t hide_timeout)
{
    video_splitter_t *splitter =
        video_splitter_New(VLC_OBJECT(vout), splitter_module, source);
    if (!splitter)
        return NULL;

    /* */
    vout_display_t *wrapper =
        DisplayNew(vout, source, state, module, true,
                    double_click_timeout, hide_timeout, NULL);
    if (!wrapper) {
        video_splitter_Delete(splitter);
        return NULL;
    }
    vout_display_sys_t *sys = malloc(sizeof(*sys));
    if (!sys)
        abort();
    sys->picture = calloc(splitter->i_output, sizeof(*sys->picture));
    if (!sys->picture )
        ab...",1,1,video_output\display.c,vout_NewSplitter,,false,1430,1505,vout_NewSplitter,,,48,"vout_display_t vout_NewSplitter (vout_thread_t*,video_format_t*,vout_display_state_t*,char*,char*,mtime_t,mtime_t)"
190981,METHOD,video_output\display.c:<global>,TYPE_DECL,"void vout_SendDisplayEventMouse(vout_thread_t *vout, const vlc_mouse_t *m)
{
    vlc_mouse_t tmp1, tmp2;

    /* The check on spu is needed as long as ALLOW_DUMMY_VOUT is defined */
    if (vout->p->spu && spu_ProcessMouse( vout->p->spu, m, &vout->p->display.vd->source))
        return;

    vlc_mutex_lock( &vout->p->filter.lock );
    if (vout->p->filter.chain_static && vout->p->filter.chain_interactive) {
        if (!filter_chain_MouseFilter(vout->p->filter.chain_interactive, &tmp1, m))
            m = &tmp1;
        if (!filter_chain_MouseFilter(vout->p->filter.chain_static,      &tmp2, m))
            m = &tmp2;
    }
    vlc_mutex_unlock( &vout->p->filter.lock );

    if (vlc_mouse_HasMoved(&vout->p->mouse, m)) {
        vout_SendEventMouseMoved(vout, m->i_x, m->i_y);
    }
    if (vlc_mouse_HasButton(&vout->p->mouse, m)) {
        for (unsigned button = 0; button < MOUSE_BUTTON_MAX; button++) {
            if (vlc_mouse_HasPressed(&vout->p->mouse, m, button))
                ...",1,1,video_output\display.c,vout_SendDisplayEventMouse,,false,1511,1542,vout_SendDisplayEventMouse,,,49,"void vout_SendDisplayEventMouse (vout_thread_t*,vlc_mouse_t*)"
191176,METHOD,video_output\display.h:<global>,TYPE_DECL,<global>,1,84,video_output\display.h,video_output\display.h:<global>,,false,1,42,<global>,,,1,
191178,METHOD,video_output\display.h:<global>,TYPE_DECL,"vout_display_t *vout_NewSplitter(vout_thread_t *vout,
                                 const video_format_t *source,
                                 const vout_display_state_t *state,
                                 const char *module,
                                 const char *splitter_module,
                                 mtime_t double_click_timeout,
                                 mtime_t hide_timeout);",16,54,video_output\display.h,vout_NewSplitter,,false,26,32,vout_NewSplitter,,,1,"vout_display_t* vout_NewSplitter (vout_thread_t*,video_format_t*,vout_display_state_t*,char*,char*,mtime_t,mtime_t)"
191189,METHOD,video_output\display.h:<global>,TYPE_DECL,"void vout_SendDisplayEventMouse(vout_thread_t *, const vlc_mouse_t *);",6,69,video_output\display.h,vout_SendDisplayEventMouse,,false,35,35,vout_SendDisplayEventMouse,,,2,"void vout_SendDisplayEventMouse (vout_thread_t*,vlc_mouse_t*)"
191195,METHOD,video_output\display.h:<global>,TYPE_DECL,"vout_window_t *vout_NewDisplayWindow(vout_thread_t *, unsigned type);",15,68,video_output\display.h,vout_NewDisplayWindow,,false,37,37,vout_NewDisplayWindow,,,3,"vout_window_t* vout_NewDisplayWindow (vout_thread_t*,unsigned)"
191201,METHOD,video_output\display.h:<global>,TYPE_DECL,"void vout_DeleteDisplayWindow(vout_thread_t *, vout_window_t *);",6,63,video_output\display.h,vout_DeleteDisplayWindow,,false,38,38,vout_DeleteDisplayWindow,,,4,"void vout_DeleteDisplayWindow (vout_thread_t*,vout_window_t*)"
191207,METHOD,video_output\display.h:<global>,TYPE_DECL,"void vout_SetDisplayWindowSize(vout_thread_t *, unsigned, unsigned);",6,67,video_output\display.h,vout_SetDisplayWindowSize,,false,39,39,vout_SetDisplayWindowSize,,,5,"void vout_SetDisplayWindowSize (vout_thread_t*,unsigned,unsigned)"
191214,METHOD,video_output\display.h:<global>,TYPE_DECL,"int  vout_HideWindowMouse(vout_thread_t *, bool);",6,48,video_output\display.h,vout_HideWindowMouse,,false,40,40,vout_HideWindowMouse,,,6,"int vout_HideWindowMouse (vout_thread_t*,ANY)"
191220,METHOD,video_output\display.h:<global>,TYPE_DECL,"void vout_UpdateDisplaySourceProperties(vout_display_t *vd, const video_format_t *);",6,83,video_output\display.h,vout_UpdateDisplaySourceProperties,,false,42,42,vout_UpdateDisplaySourceProperties,,,7,"void vout_UpdateDisplaySourceProperties (vout_display_t*,video_format_t*)"
191235,METHOD,video_output\event.h:<global>,TYPE_DECL,<global>,1,1,video_output\event.h,video_output\event.h:<global>,,false,1,169,<global>,,,1,
191237,METHOD,video_output\event.h:<global>,TYPE_DECL,"static inline void vout_SendEventClose(vout_thread_t *vout)
{
#warning FIXME: implement video close event
    /* FIXME: this code is disabled as it breaks the non-playlist cases */
    //playlist_Stop(pl_Get(vout));
    (void) vout;
}",1,1,video_output\event.h,vout_SendEventClose,,false,40,46,vout_SendEventClose,,,1,void vout_SendEventClose (vout_thread_t*)
191245,METHOD,video_output\event.h:<global>,TYPE_DECL,"static inline void vout_SendEventKey(vout_thread_t *vout, int key)
{
    var_SetInteger(vout->obj.libvlc, ""key-pressed"", key);
}",1,1,video_output\event.h,vout_SendEventKey,,false,47,50,vout_SendEventKey,,,2,"void vout_SendEventKey (vout_thread_t*,int)"
191259,METHOD,video_output\event.h:<global>,TYPE_DECL,"static inline void vout_SendEventMouseMoved(vout_thread_t *vout, int x, int y)
{
    var_SetCoords(vout, ""mouse-moved"", x, y);
}",1,1,video_output\event.h,vout_SendEventMouseMoved,,false,51,54,vout_SendEventMouseMoved,,,3,"void vout_SendEventMouseMoved (vout_thread_t*,int,int)"
191271,METHOD,video_output\event.h:<global>,TYPE_DECL,"static inline void vout_SendEventViewpointMoved(vout_thread_t *vout,
                                                const vlc_viewpoint_t *p_viewpoint)
{
    var_SetAddress(vout, ""viewpoint-moved"", (void *) p_viewpoint);
    /* This variable can only be read from callbacks */
    var_Change(vout, ""viewpoint-moved"", VLC_VAR_SETVALUE,
               &(vlc_value_t) { .p_address = NULL }, NULL);
}",1,1,video_output\event.h,vout_SendEventViewpointMoved,,false,55,62,vout_SendEventViewpointMoved,,,4,"void vout_SendEventViewpointMoved (vout_thread_t*,vlc_viewpoint_t*)"
191296,METHOD,video_output\event.h:<global>,TYPE_DECL,"static inline void vout_SendEventMousePressed(vout_thread_t *vout, int button)
{
    int key = KEY_UNSET;
    var_OrInteger(vout, ""mouse-button-down"", 1 << button);

    switch (button)
    {
    case MOUSE_BUTTON_LEFT:
    {
        /* FIXME? */
        int x, y;
        var_GetCoords(vout, ""mouse-moved"", &x, &y);
        var_SetCoords(vout, ""mouse-clicked"", x, y);
        var_SetBool(vout->obj.libvlc, ""intf-popupmenu"", false);
        return;
    }
    case MOUSE_BUTTON_CENTER:
        var_ToggleBool(vout->obj.libvlc, ""intf-toggle-fscontrol"");
        return;
    case MOUSE_BUTTON_RIGHT:
#if !defined(_WIN32)
        var_SetBool(vout->obj.libvlc, ""intf-popupmenu"", true);
#endif
        return;
    case MOUSE_BUTTON_WHEEL_UP:    key = KEY_MOUSEWHEELUP;    break;
    case MOUSE_BUTTON_WHEEL_DOWN:  key = KEY_MOUSEWHEELDOWN;  break;
    case MOUSE_BUTTON_WHEEL_LEFT:  key = KEY_MOUSEWHEELLEFT;  break;
    case MOUSE_BUTTON_WHEEL_RIGHT: key = KEY_MOUSEWHEELRIGHT; break;
    }
    vout_Se...",1,1,video_output\event.h,vout_SendEventMousePressed,,false,63,93,vout_SendEventMousePressed,,,5,"void vout_SendEventMousePressed (vout_thread_t*,int)"
191389,METHOD,video_output\event.h:<global>,TYPE_DECL,"static inline void vout_SendEventMouseReleased(vout_thread_t *vout, int button)
{
    var_NAndInteger(vout, ""mouse-button-down"", 1 << button);
#if defined(_WIN32)
    switch (button)
    {
    case MOUSE_BUTTON_RIGHT:
        var_SetBool(vout->obj.libvlc, ""intf-popupmenu"", true);
        return;
    }
#endif
}",1,1,video_output\event.h,vout_SendEventMouseReleased,,false,94,105,vout_SendEventMouseReleased,,,6,"void vout_SendEventMouseReleased (vout_thread_t*,int)"
191401,METHOD,video_output\event.h:<global>,TYPE_DECL,"static inline void vout_SendEventMouseDoubleClick(vout_thread_t *vout)
{
    //vout_ControlSetFullscreen(vout, !var_GetBool(vout, ""fullscreen""));
    var_ToggleBool(vout, ""fullscreen"");
}",1,1,video_output\event.h,vout_SendEventMouseDoubleClick,,false,106,110,vout_SendEventMouseDoubleClick,,,7,void vout_SendEventMouseDoubleClick (vout_thread_t*)
191409,METHOD,video_output\event.h:<global>,TYPE_DECL,"static inline void vout_SendEventViewpointChangeable(vout_thread_t *vout,
                                                     bool b_can_change)
{
    var_SetBool(vout, ""viewpoint-changeable"", b_can_change);
}",1,1,video_output\event.h,vout_SendEventViewpointChangeable,,false,111,115,vout_SendEventViewpointChangeable,,,8,"void vout_SendEventViewpointChangeable (vout_thread_t*,bool)"
191434,METHOD,video_output\inhibit.c:<global>,TYPE_DECL,<global>,1,25,video_output\inhibit.c,video_output\inhibit.c:<global>,,false,1,62,<global>,,,1,
191440,METHOD,video_output\inhibit.c:<global>,TYPE_DECL,"vlc_inhibit_t *vlc_inhibit_Create (vlc_object_t *parent)
{
    inhibit_t *priv = vlc_custom_create (parent, sizeof (*priv), ""inhibit"" );
    if (priv == NULL)
        return NULL;

    vlc_inhibit_t *ih = &priv->ih;
    ih->p_sys = NULL;
    ih->inhibit = NULL;

    priv->module = module_need (ih, ""inhibit"", NULL, false);
    if (priv->module == NULL)
    {
        vlc_object_release (ih);
        ih = NULL;
    }
    return ih;
}",1,1,video_output\inhibit.c,vlc_inhibit_Create,,false,37,54,vlc_inhibit_Create,,,3,vlc_inhibit_t vlc_inhibit_Create (vlc_object_t*)
191501,METHOD,video_output\inhibit.c:<global>,TYPE_DECL,"void vlc_inhibit_Destroy (vlc_inhibit_t *ih)
{
    assert (ih != NULL);

    module_unneed (ih, ((inhibit_t *)ih)->module);
    vlc_object_release (ih);
}",1,1,video_output\inhibit.c,vlc_inhibit_Destroy,,false,56,62,vlc_inhibit_Destroy,,,4,void vlc_inhibit_Destroy (vlc_inhibit_t*)
191524,METHOD,video_output\inhibit.h:<global>,TYPE_DECL,<global>,1,6,video_output\inhibit.h,video_output\inhibit.h:<global>,,false,1,28,<global>,,,1,
191526,METHOD,video_output\inhibit.h:<global>,TYPE_DECL,vlc_inhibit_t *vlc_inhibit_Create (vlc_object_t *);,15,50,video_output\inhibit.h,vlc_inhibit_Create,,false,26,26,vlc_inhibit_Create,,,1,vlc_inhibit_t* vlc_inhibit_Create (vlc_object_t*)
191531,METHOD,video_output\inhibit.h:<global>,TYPE_DECL,void vlc_inhibit_Destroy (vlc_inhibit_t *);,6,42,video_output\inhibit.h,vlc_inhibit_Destroy,,false,27,27,vlc_inhibit_Destroy,,,2,void vlc_inhibit_Destroy (vlc_inhibit_t*)
191551,METHOD,video_output\interlacing.c:<global>,TYPE_DECL,<global>,1,1,video_output\interlacing.c,video_output\interlacing.c:<global>,,false,1,194,<global>,,,1,
191568,METHOD,video_output\interlacing.c:<global>,TYPE_DECL,"static bool DeinterlaceIsModeValid(const char *mode)
{
    for (unsigned i = 0; i < ARRAY_SIZE(deinterlace_modes); i++) {
        if (!strcmp(deinterlace_modes[i], mode))
            return true;
    }
    return false;
}",1,1,video_output\interlacing.c,DeinterlaceIsModeValid,,false,56,63,DeinterlaceIsModeValid,,,3,bool DeinterlaceIsModeValid (char*)
191598,METHOD,video_output\interlacing.c:<global>,TYPE_DECL,"static int DeinterlaceCallback(vlc_object_t *object, char const *cmd,
                               vlc_value_t oldval, vlc_value_t newval, void *data)
{
    VLC_UNUSED(cmd); VLC_UNUSED(oldval); VLC_UNUSED(newval); VLC_UNUSED(data);
    vout_thread_t *vout = (vout_thread_t *)object;

    /* */
    const int  deinterlace_state = var_GetInteger(vout, ""deinterlace"");
    char       *mode             = var_GetString(vout,  ""deinterlace-mode"");
    const bool is_needed         = var_GetBool(vout,    ""deinterlace-needed"");
    if (!mode || !DeinterlaceIsModeValid(mode))
    {
        free(mode);
        return VLC_EGENERIC;
    }

    /* */
    char *old = var_CreateGetString(vout, ""sout-deinterlace-mode"");
    var_SetString(vout, ""sout-deinterlace-mode"", mode);

    msg_Dbg(vout, ""deinterlace %d, mode %s, is_needed %d"", deinterlace_state, mode, is_needed);
    if (deinterlace_state == 0 || (deinterlace_state < 0 && !is_needed))
        vout_control_PushBool(&vout->p->control,
          ...",1,1,video_output\interlacing.c,DeinterlaceCallback,,false,65,97,DeinterlaceCallback,,,4,"int DeinterlaceCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
191705,METHOD,video_output\interlacing.c:<global>,TYPE_DECL,"void vout_InitInterlacingSupport(vout_thread_t *vout, bool is_interlaced)
{
    vlc_value_t val, text;

    msg_Dbg(vout, ""Deinterlacing available"");

    vout->p->filter.has_deint = false;

    /* Create the configuration variables */
    /* */
    var_Create(vout, ""deinterlace"", VLC_VAR_INTEGER | VLC_VAR_DOINHERIT );
    int deinterlace_state = var_GetInteger(vout, ""deinterlace"");

    text.psz_string = _(""Deinterlace"");
    var_Change(vout, ""deinterlace"", VLC_VAR_SETTEXT, &text, NULL);

    const module_config_t *optd = config_FindConfig(""deinterlace"");
    var_Change(vout, ""deinterlace"", VLC_VAR_CLEARCHOICES, NULL, NULL);
    if (likely(optd != NULL))
        for (unsigned i = 0; i < optd->list_count; i++) {
            val.i_int = optd->list.i[i];
            text.psz_string = vlc_gettext(optd->list_text[i]);
            var_Change(vout, ""deinterlace"", VLC_VAR_ADDCHOICE, &val, &text);
        }
    var_AddCallback(vout, ""deinterlace"", DeinterlaceCallback, NULL);
    /* */
    v...",1,1,video_output\interlacing.c,vout_InitInterlacingSupport,,false,99,170,vout_InitInterlacingSupport,,,5,"void vout_InitInterlacingSupport (vout_thread_t*,bool)"
192015,METHOD,video_output\interlacing.c:<global>,TYPE_DECL,"void vout_ReinitInterlacingSupport(vout_thread_t *vout)
{
    vout->p->interlacing.is_interlaced = false;
    var_SetBool(vout, ""deinterlace-needed"", false);
}",1,1,video_output\interlacing.c,vout_ReinitInterlacingSupport,,false,172,176,vout_ReinitInterlacingSupport,,,6,void vout_ReinitInterlacingSupport (vout_thread_t*)
192033,METHOD,video_output\interlacing.c:<global>,TYPE_DECL,"void vout_SetInterlacingState(vout_thread_t *vout, bool is_interlaced)
{
     /* Wait 30s before quiting interlacing mode */
    const int interlacing_change = (!!is_interlaced)
                                 - (!!vout->p->interlacing.is_interlaced);
    if (interlacing_change == 1 ||
        (interlacing_change == -1 &&
        vout->p->interlacing.date + 30000000 < mdate()))
    {
        msg_Dbg(vout, ""Detected %s video"",
                 is_interlaced ? ""interlaced"" : ""progressive"");
        var_SetBool(vout, ""deinterlace-needed"", is_interlaced);
        vout->p->interlacing.is_interlaced = is_interlaced;
    }
    if (is_interlaced)
        vout->p->interlacing.date = mdate();
}",1,1,video_output\interlacing.c,vout_SetInterlacingState,,false,178,194,vout_SetInterlacingState,,,7,"void vout_SetInterlacingState (vout_thread_t*,bool)"
192112,METHOD,video_output\interlacing.h:<global>,TYPE_DECL,<global>,1,6,video_output\interlacing.h,video_output\interlacing.h:<global>,,false,1,31,<global>,,,1,
192114,METHOD,video_output\interlacing.h:<global>,TYPE_DECL,"void vout_InitInterlacingSupport(vout_thread_t *, bool is_interlaced);",6,69,video_output\interlacing.h,vout_InitInterlacingSupport,,false,27,27,vout_InitInterlacingSupport,,,1,"void vout_InitInterlacingSupport (vout_thread_t*,bool)"
192120,METHOD,video_output\interlacing.h:<global>,TYPE_DECL,void vout_ReinitInterlacingSupport(vout_thread_t *);,6,51,video_output\interlacing.h,vout_ReinitInterlacingSupport,,false,28,28,vout_ReinitInterlacingSupport,,,2,void vout_ReinitInterlacingSupport (vout_thread_t*)
192125,METHOD,video_output\interlacing.h:<global>,TYPE_DECL,"void vout_SetInterlacingState(vout_thread_t *, bool is_interlaced);",6,66,video_output\interlacing.h,vout_SetInterlacingState,,false,29,29,vout_SetInterlacingState,,,3,"void vout_SetInterlacingState (vout_thread_t*,bool)"
192152,METHOD,video_output\opengl.c:<global>,TYPE_DECL,<global>,1,24,video_output\opengl.c,video_output\opengl.c:<global>,,false,1,200,<global>,,,1,
192157,METHOD,video_output\opengl.c:<global>,TYPE_DECL,"vlc_gl_t *vlc_gl_Create(struct vout_window_t *wnd, unsigned flags,
                        const char *name)
{
    vlc_object_t *parent = (vlc_object_t *)wnd;
    struct vlc_gl_priv_t *glpriv;
    const char *type;

    switch (flags /*& VLC_OPENGL_API_MASK*/)
    {
        case VLC_OPENGL:
            type = ""opengl"";
            break;
        case VLC_OPENGL_ES2:
            type = ""opengl es2"";
            break;
        default:
            return NULL;
    }

    glpriv = vlc_custom_create(parent, sizeof (*glpriv), ""gl"");
    if (unlikely(glpriv == NULL))
        return NULL;

    glpriv->gl.surface = wnd;
    glpriv->gl.module = module_need(&glpriv->gl, type, name, true);
    if (glpriv->gl.module == NULL)
    {
        vlc_object_release(&glpriv->gl);
        return NULL;
    }
    atomic_init(&glpriv->ref_count, 1);

    return &glpriv->gl;
}",1,13,video_output\opengl.c,vlc_gl_Create,,false,50,83,vlc_gl_Create,,,2,"vlc_gl_t vlc_gl_Create (vout_window_t*,unsigned,char*)"
192259,METHOD,video_output\opengl.c:<global>,TYPE_DECL,"void vlc_gl_Hold(vlc_gl_t *gl)
{
    struct vlc_gl_priv_t *glpriv = (struct vlc_gl_priv_t *)gl;
    atomic_fetch_add(&glpriv->ref_count, 1);
}",1,1,video_output\opengl.c,vlc_gl_Hold,,false,85,89,vlc_gl_Hold,,,3,void vlc_gl_Hold (vlc_gl_t*)
192276,METHOD,video_output\opengl.c:<global>,TYPE_DECL,"void vlc_gl_Release(vlc_gl_t *gl)
{
    struct vlc_gl_priv_t *glpriv = (struct vlc_gl_priv_t *)gl;
    if (atomic_fetch_sub(&glpriv->ref_count, 1) != 1)
        return;
    module_unneed(gl, gl->module);
    vlc_object_release(gl);
}",1,1,video_output\opengl.c,vlc_gl_Release,,false,91,98,vlc_gl_Release,,,4,void vlc_gl_Release (vlc_gl_t*)
192310,METHOD,video_output\opengl.c:<global>,TYPE_DECL,"static void vlc_gl_surface_ResizeNotify(vout_window_t *surface,
                                        unsigned width, unsigned height)
{
    vlc_gl_surface_t *sys = surface->owner.sys;

    msg_Dbg(surface, ""resized to %ux%u"", width, height);

    vlc_mutex_lock(&sys->lock);
    sys->width = width;
    sys->height = height;
    vlc_mutex_unlock(&sys->lock);
}",1,1,video_output\opengl.c,vlc_gl_surface_ResizeNotify,,false,109,120,vlc_gl_surface_ResizeNotify,,,7,"void vlc_gl_surface_ResizeNotify (vout_window_t*,unsigned,unsigned)"
192350,METHOD,video_output\opengl.c:<global>,TYPE_DECL,"vlc_gl_t *vlc_gl_surface_Create(vlc_object_t *obj,
                                const vout_window_cfg_t *cfg,
                                struct vout_window_t **restrict wp)
{
    vlc_gl_surface_t *sys = malloc(sizeof (*sys));
    if (unlikely(sys == NULL))
        return NULL;

    sys->width = cfg->width;
    sys->height = cfg->height;
    vlc_mutex_init(&sys->lock);

    vout_window_owner_t owner = {
        .sys = sys,
        .resized = vlc_gl_surface_ResizeNotify,
    };

    vout_window_t *surface = vout_window_New(obj, ""$window"", cfg, &owner);
    if (surface == NULL)
        goto error;
    if (wp != NULL)
        *wp = surface;

    /* TODO: support ES? */
    vlc_gl_t *gl = vlc_gl_Create(surface, VLC_OPENGL, NULL);
    if (gl == NULL) {
        vout_window_Delete(surface);
        return NULL;
    }

    vlc_gl_Resize(gl, cfg->width, cfg->height);
    return gl;

error:
    vlc_mutex_destroy(&sys->lock);
    free(sys);
    return NULL;
}",1,1,video_output\opengl.c,vlc_gl_surface_Create,,false,122,159,vlc_gl_surface_Create,,,8,"vlc_gl_t vlc_gl_surface_Create (vlc_object_t*,vout_window_cfg_t*,vout_window_t**)"
192463,METHOD,video_output\opengl.c:<global>,TYPE_DECL,"bool vlc_gl_surface_CheckSize(vlc_gl_t *gl, unsigned *restrict width,
                              unsigned *restrict height)
{
    vout_window_t *surface = gl->surface;
    vlc_gl_surface_t *sys = surface->owner.sys;
    bool ret = false;

    vlc_mutex_lock(&sys->lock);
    if (sys->width >= 0 && sys->height >= 0)
    {
        *width = sys->width;
        *height = sys->height;
        sys->width = -1;
        sys->height = -1;

        vlc_gl_Resize(gl, *width, *height);
        ret = true;
    }
    vlc_mutex_unlock(&sys->lock);
    return ret;
}",1,1,video_output\opengl.c,vlc_gl_surface_CheckSize,,false,169,189,vlc_gl_surface_CheckSize,,,9,"bool vlc_gl_surface_CheckSize (vlc_gl_t*,unsigned*,unsigned*)"
192546,METHOD,video_output\opengl.c:<global>,TYPE_DECL,"void vlc_gl_surface_Destroy(vlc_gl_t *gl)
{
    vout_window_t *surface = gl->surface;
    vlc_gl_surface_t *sys = surface->owner.sys;

    vlc_gl_Release(gl);
    vout_window_Delete(surface);
    vlc_mutex_destroy(&sys->lock);
    free(sys);
}",1,1,video_output\opengl.c,vlc_gl_surface_Destroy,,false,191,200,vlc_gl_surface_Destroy,,,10,void vlc_gl_surface_Destroy (vlc_gl_t*)
192605,METHOD,video_output\snapshot.c:<global>,TYPE_DECL,<global>,1,1,video_output\snapshot.c,video_output\snapshot.c:<global>,,false,1,232,<global>,,,1,
192607,METHOD,video_output\snapshot.c:<global>,TYPE_DECL,"void vout_snapshot_Init(vout_snapshot_t *snap)
{
    vlc_mutex_init(&snap->lock);
    vlc_cond_init(&snap->wait);

    snap->is_available = true;
    snap->request_count = 0;
    snap->picture = NULL;
}",1,1,video_output\snapshot.c,vout_snapshot_Init,,false,45,53,vout_snapshot_Init,,,1,void vout_snapshot_Init (vout_snapshot_t*)
192637,METHOD,video_output\snapshot.c:<global>,TYPE_DECL,"void vout_snapshot_Clean(vout_snapshot_t *snap)
{
    picture_t *picture = snap->picture;
    while (picture) {
        picture_t *next = picture->p_next;
        picture_Release(picture);
        picture = next;
    }

    vlc_cond_destroy(&snap->wait);
    vlc_mutex_destroy(&snap->lock);
}",1,1,video_output\snapshot.c,vout_snapshot_Clean,,false,54,65,vout_snapshot_Clean,,,2,void vout_snapshot_Clean (vout_snapshot_t*)
192672,METHOD,video_output\snapshot.c:<global>,TYPE_DECL,"void vout_snapshot_End(vout_snapshot_t *snap)
{
    vlc_mutex_lock(&snap->lock);

    snap->is_available = false;

    vlc_cond_broadcast(&snap->wait);
    vlc_mutex_unlock(&snap->lock);
}",1,1,video_output\snapshot.c,vout_snapshot_End,,false,67,75,vout_snapshot_End,,,3,void vout_snapshot_End (vout_snapshot_t*)
192697,METHOD,video_output\snapshot.c:<global>,TYPE_DECL,"picture_t *vout_snapshot_Get(vout_snapshot_t *snap, mtime_t timeout)
{
    const mtime_t deadline = mdate() + timeout;

    vlc_mutex_lock(&snap->lock);

    /* */
    snap->request_count++;

    /* */
    while (snap->is_available && !snap->picture &&
        vlc_cond_timedwait(&snap->wait, &snap->lock, deadline) == 0);

    /* */
    picture_t *picture = snap->picture;
    if (picture)
        snap->picture = picture->p_next;
    else if (snap->request_count > 0)
        snap->request_count--;

    vlc_mutex_unlock(&snap->lock);

    return picture;
}",1,1,video_output\snapshot.c,vout_snapshot_Get,,false,78,101,vout_snapshot_Get,,,4,"picture_t vout_snapshot_Get (vout_snapshot_t*,mtime_t)"
192776,METHOD,video_output\snapshot.c:<global>,TYPE_DECL,"bool vout_snapshot_IsRequested(vout_snapshot_t *snap)
{
    bool has_request = false;
    if (!vlc_mutex_trylock(&snap->lock)) {
        has_request = snap->request_count > 0;
        vlc_mutex_unlock(&snap->lock);
    }
    return has_request;
}",1,1,video_output\snapshot.c,vout_snapshot_IsRequested,,false,104,112,vout_snapshot_IsRequested,,,5,bool vout_snapshot_IsRequested (vout_snapshot_t*)
192807,METHOD,video_output\snapshot.c:<global>,TYPE_DECL,"void vout_snapshot_Set(vout_snapshot_t *snap,
                       const video_format_t *fmt,
                       picture_t *picture)
{
    if (!fmt)
        fmt = &picture->format;

    vlc_mutex_lock(&snap->lock);
    while (snap->request_count > 0) {
        picture_t *dup = picture_Clone(picture);
        if (!dup)
            break;

        video_format_CopyCrop( &dup->format, fmt );

        dup->p_next = snap->picture;
        snap->picture = dup;
        snap->request_count--;
    }
    vlc_cond_broadcast(&snap->wait);
    vlc_mutex_unlock(&snap->lock);
}",1,1,video_output\snapshot.c,vout_snapshot_Set,,false,113,134,vout_snapshot_Set,,,6,"void vout_snapshot_Set (vout_snapshot_t*,video_format_t*,picture_t*)"
192878,METHOD,video_output\snapshot.c:<global>,TYPE_DECL,"char *vout_snapshot_GetDirectory(void)
{
    return config_GetUserDir(VLC_PICTURES_DIR);
}",1,1,video_output\snapshot.c,vout_snapshot_GetDirectory,,false,136,139,vout_snapshot_GetDirectory,,,7,char* vout_snapshot_GetDirectory (void)
192886,METHOD,video_output\snapshot.c:<global>,TYPE_DECL,"int vout_snapshot_SaveImage(char **name, int *sequential,
                             const block_t *image,
                             vout_thread_t *p_vout,
                             const vout_snapshot_save_cfg_t *cfg)
{
    /* */
    char *filename;
    input_thread_t *input = (input_thread_t*)p_vout->p->input;

    /* */
    char *prefix = NULL;
    if (cfg->prefix_fmt)
        prefix = str_format(input, cfg->prefix_fmt);
    if (prefix)
        filename_sanitize(prefix);
    else {
        prefix = strdup(""vlcsnap-"");
        if (prefix == NULL)
            goto error;
    }

    struct stat st;
    bool b_is_folder = false;

    if ( vlc_stat( cfg->path, &st ) == 0 )
        b_is_folder = S_ISDIR( st.st_mode );
    if ( b_is_folder ) {
        if (cfg->is_sequential) {
            for (int num = cfg->sequence; ; num++) {
                if (asprintf(&filename, ""%s"" DIR_SEP ""%s%05d.%s"",
                             cfg->path, prefix, num, cfg->format) < 0) {
             ...",1,1,video_output\snapshot.c,vout_snapshot_SaveImage,,false,141,232,vout_snapshot_SaveImage,,,8,"int vout_snapshot_SaveImage (char**,int*,block_t*,vout_thread_t*,vout_snapshot_save_cfg_t*)"
193125,METHOD,video_output\snapshot.h:<global>,TYPE_DECL,<global>,1,6,video_output\snapshot.h,video_output\snapshot.h:<global>,,false,1,83,<global>,,,1,
193134,METHOD,video_output\snapshot.h:<global>,TYPE_DECL,void vout_snapshot_Init(vout_snapshot_t *);,6,42,video_output\snapshot.h,vout_snapshot_Init,,false,40,40,vout_snapshot_Init,,,3,void vout_snapshot_Init (vout_snapshot_t*)
193139,METHOD,video_output\snapshot.h:<global>,TYPE_DECL,void vout_snapshot_Clean(vout_snapshot_t *);,6,43,video_output\snapshot.h,vout_snapshot_Clean,,false,41,41,vout_snapshot_Clean,,,4,void vout_snapshot_Clean (vout_snapshot_t*)
193144,METHOD,video_output\snapshot.h:<global>,TYPE_DECL,void vout_snapshot_End(vout_snapshot_t *);,6,41,video_output\snapshot.h,vout_snapshot_End,,false,43,43,vout_snapshot_End,,,5,void vout_snapshot_End (vout_snapshot_t*)
193149,METHOD,video_output\snapshot.h:<global>,TYPE_DECL,"picture_t *vout_snapshot_Get(vout_snapshot_t *, mtime_t timeout);",11,64,video_output\snapshot.h,vout_snapshot_Get,,false,46,46,vout_snapshot_Get,,,6,"picture_t* vout_snapshot_Get (vout_snapshot_t*,mtime_t)"
193155,METHOD,video_output\snapshot.h:<global>,TYPE_DECL,bool vout_snapshot_IsRequested(vout_snapshot_t *);,6,49,video_output\snapshot.h,vout_snapshot_IsRequested,,false,51,51,vout_snapshot_IsRequested,,,7,bool vout_snapshot_IsRequested (vout_snapshot_t*)
193160,METHOD,video_output\snapshot.h:<global>,TYPE_DECL,"void vout_snapshot_Set(vout_snapshot_t *, const video_format_t *, picture_t *);",6,78,video_output\snapshot.h,vout_snapshot_Set,,false,60,60,vout_snapshot_Set,,,8,"void vout_snapshot_Set (vout_snapshot_t*,video_format_t*,picture_t*)"
193167,METHOD,video_output\snapshot.h:<global>,TYPE_DECL,char *vout_snapshot_GetDirectory(void);,6,38,video_output\snapshot.h,vout_snapshot_GetDirectory,,false,65,65,vout_snapshot_GetDirectory,,,9,char* vout_snapshot_GetDirectory (void)
193179,METHOD,video_output\snapshot.h:<global>,TYPE_DECL,"int vout_snapshot_SaveImage(char **name, int *sequential,
                            const block_t *image,
                            vout_thread_t *p_vout,
                            const vout_snapshot_save_cfg_t *cfg);",5,64,video_output\snapshot.h,vout_snapshot_SaveImage,,false,78,81,vout_snapshot_SaveImage,,,12,"int vout_snapshot_SaveImage (char**,int*,block_t*,vout_thread_t*,vout_snapshot_save_cfg_t*)"
193193,METHOD,video_output\statistic.h:<global>,TYPE_DECL,<global>,1,6,video_output\statistic.h,video_output\statistic.h:<global>,,false,1,66,<global>,,,1,
193199,METHOD,video_output\statistic.h:<global>,TYPE_DECL,"static inline void vout_statistic_Init(vout_statistic_t *stat)
{
    atomic_init(&stat->displayed, 0);
    atomic_init(&stat->lost, 0);
}",1,1,video_output\statistic.h,vout_statistic_Init,,false,36,40,vout_statistic_Init,,,3,void vout_statistic_Init (vout_statistic_t*)
193216,METHOD,video_output\statistic.h:<global>,TYPE_DECL,"static inline void vout_statistic_Clean(vout_statistic_t *stat)
{
    (void) stat;
}",1,1,video_output\statistic.h,vout_statistic_Clean,,false,42,45,vout_statistic_Clean,,,4,void vout_statistic_Clean (vout_statistic_t*)
193224,METHOD,video_output\statistic.h:<global>,TYPE_DECL,"static inline void vout_statistic_GetReset(vout_statistic_t *stat,
                                           unsigned *restrict displayed,
                                           unsigned *restrict lost)
{
    *displayed = atomic_exchange(&stat->displayed, 0);
    *lost      = atomic_exchange(&stat->lost, 0);
}",1,1,video_output\statistic.h,vout_statistic_GetReset,,false,47,53,vout_statistic_GetReset,,,5,"void vout_statistic_GetReset (vout_statistic_t*,unsigned*,unsigned*)"
193249,METHOD,video_output\statistic.h:<global>,TYPE_DECL,"static inline void vout_statistic_AddDisplayed(vout_statistic_t *stat,
                                               int displayed)
{
    atomic_fetch_add(&stat->displayed, displayed);
}",1,1,video_output\statistic.h,vout_statistic_AddDisplayed,,false,55,59,vout_statistic_AddDisplayed,,,6,"void vout_statistic_AddDisplayed (vout_statistic_t*,int)"
193261,METHOD,video_output\statistic.h:<global>,TYPE_DECL,"static inline void vout_statistic_AddLost(vout_statistic_t *stat, int lost)
{
    atomic_fetch_add(&stat->lost, lost);
}",1,1,video_output\statistic.h,vout_statistic_AddLost,,false,61,64,vout_statistic_AddLost,,,7,"void vout_statistic_AddLost (vout_statistic_t*,int)"
193296,METHOD,video_output\video_epg.c:<global>,TYPE_DECL,<global>,1,21,video_output\video_epg.c,video_output\video_epg.c:<global>,,false,1,659,<global>,,,1,
193303,METHOD,video_output\video_epg.c:<global>,TYPE_DECL,"static char * GetDefaultArtUri( void )
{
    char *psz_uri = NULL;
    char *psz_path;
    char *psz_datadir = config_GetDataDir();
    if( asprintf( &psz_path, ""%s/icons/128x128/vlc.png"", psz_datadir ) >= 0 )
    {
        psz_uri = vlc_path2uri( psz_path, NULL );
        free( psz_path );
    }
    free( psz_datadir );
    return psz_uri;
}",1,1,video_output\video_epg.c,GetDefaultArtUri,,false,77,89,GetDefaultArtUri,,,2,char* GetDefaultArtUri (void)
193337,METHOD,video_output\video_epg.c:<global>,TYPE_DECL,"static subpicture_region_t * vout_OSDBackground(int x, int y,
                                                int width, int height,
                                                uint32_t i_argb)
{
    /* Create a new subpicture region */
    video_palette_t palette;
    spuregion_CreateVGradientPalette( &palette, GRADIENT_COLORS, i_argb, 0xFF000000 );

    video_format_t fmt;
    video_format_Init(&fmt, VLC_CODEC_YUVP);
    fmt.i_width  = fmt.i_visible_width  = width;
    fmt.i_height = fmt.i_visible_height = height;
    fmt.i_sar_num = 1;
    fmt.i_sar_den = 1;
    fmt.p_palette = &palette;

    subpicture_region_t *region = subpicture_region_New(&fmt);
    if (!region)
        return NULL;

    region->i_align = SUBPICTURE_ALIGN_LEFT | SUBPICTURE_ALIGN_TOP;
    region->i_x = x;
    region->i_y = y;

    spuregion_CreateVGradientFill( region->p_picture->p, palette.i_entries );

    return region;
}",1,48,video_output\video_epg.c,vout_OSDBackground,,false,93,120,vout_OSDBackground,,,3,"subpicture_region_t vout_OSDBackground (int,int,int,int,uint32_t)"
193434,METHOD,video_output\video_epg.c:<global>,TYPE_DECL,"static subpicture_region_t * vout_OSDEpgSlider(int x, int y,
                                               int width, int height,
                                               float ratio)
{
    /* Create a new subpicture region */
    video_palette_t palette = {
        .i_entries = 4,
        .palette = {
            [0] = { HEX2YUV(RGB_COLOR1), 0x20 }, /* Bar fill remain/background */
            [1] = { HEX2YUV(0x00ff00), 0xff },
            [2] = { HEX2YUV(RGB_COLOR1), 0xC0 }, /* Bar fill */
            [3] = { HEX2YUV(0xffffff), 0xff }, /* Bar outline */
        },
    };

    video_format_t fmt;
    video_format_Init(&fmt, VLC_CODEC_YUVP);
    fmt.i_width  = fmt.i_visible_width  = width;
    fmt.i_height = fmt.i_visible_height = height;
    fmt.i_sar_num = 1;
    fmt.i_sar_den = 1;
    fmt.p_palette = &palette;

    subpicture_region_t *region = subpicture_region_New(&fmt);
    if (!region)
        return NULL;

    region->i_align = SUBPICTURE_ALIGN_LEFT | SUBPICTURE_ALIGN...",1,20,video_output\video_epg.c,vout_OSDEpgSlider,,false,122,189,vout_OSDEpgSlider,,,4,"subpicture_region_t vout_OSDEpgSlider (int,int,int,int,float)"
194004,METHOD,video_output\video_epg.c:<global>,TYPE_DECL,"static void vout_OSDSegmentSetNoWrap(text_segment_t *p_segment)
{
    for( ; p_segment; p_segment = p_segment->p_next )
    {
        p_segment->style->e_wrapinfo = STYLE_WRAP_NONE;
        p_segment->style->i_features |= STYLE_HAS_WRAP_INFO;
    }
}",1,1,video_output\video_epg.c,vout_OSDSegmentSetNoWrap,,false,191,198,vout_OSDSegmentSetNoWrap,,,5,void vout_OSDSegmentSetNoWrap (text_segment_t*)
194032,METHOD,video_output\video_epg.c:<global>,TYPE_DECL,"static text_segment_t * vout_OSDSegment(const char *psz_text, int size, uint32_t color)
{
    text_segment_t *p_segment = text_segment_New(psz_text);
    if(unlikely(!p_segment))
        return NULL;

    /* Set text style */
    p_segment->style = text_style_Create(STYLE_NO_DEFAULTS);
    if (unlikely(!p_segment->style))
    {
        text_segment_Delete(p_segment);
        return NULL;
    }

    p_segment->style->i_font_size  = __MAX(size ,1 );
    p_segment->style->i_font_color = color;
    p_segment->style->i_font_alpha = STYLE_ALPHA_OPAQUE;
    p_segment->style->i_outline_alpha = STYLE_ALPHA_TRANSPARENT;
    p_segment->style->i_shadow_alpha = STYLE_ALPHA_TRANSPARENT;
    p_segment->style->i_features |= STYLE_HAS_FONT_ALPHA | STYLE_HAS_FONT_COLOR |
                                    STYLE_HAS_OUTLINE_ALPHA | STYLE_HAS_SHADOW_ALPHA;

    return p_segment;
}",1,1,video_output\video_epg.c,vout_OSDSegment,,false,200,223,vout_OSDSegment,,,6,"text_segment_t vout_OSDSegment (char*,int,uint32_t)"
194120,METHOD,video_output\video_epg.c:<global>,TYPE_DECL,"static subpicture_region_t * vout_OSDImage( vlc_object_t *p_obj,
                                            int x, int y, int w, int h,
                                            const char *psz_uri )
{
    video_format_t fmt_out;
    video_format_Init( &fmt_out, VLC_CODEC_YUVA );
    fmt_out.i_width = fmt_out.i_visible_width = w;
    fmt_out.i_height = fmt_out.i_visible_height = h;

    subpicture_region_t *image =
            spuregion_CreateFromPicture( p_obj, &fmt_out, psz_uri );
    if( image )
    {
        image->i_x = x;
        image->i_y = y;
        image->i_align = SUBPICTURE_ALIGN_LEFT|SUBPICTURE_ALIGN_TOP;
    }
    return image;
}",1,1,video_output\video_epg.c,vout_OSDImage,,false,225,243,vout_OSDImage,,,7,"subpicture_region_t vout_OSDImage (vlc_object_t*,int,int,int,int,char*)"
194183,METHOD,video_output\video_epg.c:<global>,TYPE_DECL,"static void vout_OSDRegionConstrain(subpicture_region_t *p_region, int w, int h)
{
    if( p_region )
    {
        p_region->i_max_width = w;
        p_region->i_max_height = h;
    }
}",1,1,video_output\video_epg.c,vout_OSDRegionConstrain,,false,245,252,vout_OSDRegionConstrain,,,8,"void vout_OSDRegionConstrain (subpicture_region_t*,int,int)"
194203,METHOD,video_output\video_epg.c:<global>,TYPE_DECL,"static subpicture_region_t * vout_OSDTextRegion(text_segment_t *p_segment,
                                                int x, int y )
{
    video_format_t fmt;
    subpicture_region_t *region;

    if (!p_segment)
        return NULL;

    /* Create a new subpicture region */
    video_format_Init(&fmt, VLC_CODEC_TEXT);
    fmt.i_sar_num = 1;
    fmt.i_sar_den = 1;

    region = subpicture_region_New(&fmt);
    if (!region)
        return NULL;

    region->p_text   = p_segment;
    region->i_align  = SUBPICTURE_ALIGN_LEFT | SUBPICTURE_ALIGN_TOP;
    region->i_text_align = SUBPICTURE_ALIGN_LEFT | SUBPICTURE_ALIGN_TOP;
    region->i_x      = x;
    region->i_y      = y;
    region->b_balanced_text = false;

    return region;
}",1,1,video_output\video_epg.c,vout_OSDTextRegion,,false,254,280,vout_OSDTextRegion,,,9,"subpicture_region_t vout_OSDTextRegion (text_segment_t*,int,int)"
194279,METHOD,video_output\video_epg.c:<global>,TYPE_DECL,"static subpicture_region_t * vout_OSDEpgText(const char *text,
                                             int x, int y,
                                             int size, uint32_t color)
{
    return vout_OSDTextRegion(vout_OSDSegment(text, size, color), x, y);
}",1,1,video_output\video_epg.c,vout_OSDEpgText,,false,282,287,vout_OSDEpgText,,,10,"subpicture_region_t vout_OSDEpgText (char*,int,int,int,uint32_t)"
194296,METHOD,video_output\video_epg.c:<global>,TYPE_DECL,"static char * vout_OSDPrintTime(time_t t)
{
    char *psz;
    struct tm tms;
    localtime_r(&t, &tms);
    if(asprintf(&psz, ""%2.2d:%2.2d"", tms.tm_hour, tms.tm_min) < 0)
       psz = NULL;
    return psz;
}",1,1,video_output\video_epg.c,vout_OSDPrintTime,,false,289,297,vout_OSDPrintTime,,,11,char* vout_OSDPrintTime (time_t)
194327,METHOD,video_output\video_epg.c:<global>,TYPE_DECL,"static subpicture_region_t * vout_OSDEpgEvent(const vlc_epg_event_t *p_evt,
                                              int x, int y, int size)
{
    text_segment_t *p_segment = NULL;
    char *psz_start = vout_OSDPrintTime(p_evt->i_start);
    char *psz_end = vout_OSDPrintTime(p_evt->i_start + p_evt->i_duration);
    char *psz_text;
    if( -1 < asprintf(&psz_text, ""%s-%s "", psz_start, psz_end))
    {
        p_segment = vout_OSDSegment(psz_text, size, RGB_COLOR1);
        if( p_segment )
            p_segment->p_next = vout_OSDSegment(p_evt->psz_name, size, 0xffffff);
        vout_OSDSegmentSetNoWrap( p_segment );
    }
    free( psz_start );
    free( psz_end );
    if(!p_segment)
        return NULL;
    return vout_OSDTextRegion(p_segment, x, y);
}",1,52,video_output\video_epg.c,vout_OSDEpgEvent,,false,299,318,vout_OSDEpgEvent,,,12,"subpicture_region_t vout_OSDEpgEvent (vlc_epg_event_t*,int,int,int)"
194407,METHOD,video_output\video_epg.c:<global>,TYPE_DECL,"static void vout_FillRightPanel(subpicture_updater_sys_t *p_sys,
                                int x, int y,
                                int width, int height,
                                int rx, int ry,
                                subpicture_region_t **last_ptr)
{
    float f_progress = 0;
    VLC_UNUSED(ry);

    /* Display the name of the channel. */
    *last_ptr = vout_OSDEpgText(p_sys->epg->psz_name,
                                x,
                                y,
                                height * EPGOSD_TEXTSIZE_NAME,
                                0x00ffffff);
    if(*last_ptr)
        last_ptr = &(*last_ptr)->p_next;

    const vlc_epg_event_t *p_current = p_sys->epg->p_current;
    vlc_epg_event_t *p_next = NULL;
    if(!p_sys->epg->p_current && p_sys->epg->i_event)
        p_current = p_sys->epg->pp_event[0];

    for(size_t i=0; i<p_sys->epg->i_event; i++)
    {
        if( p_sys->epg->pp_event[i]->i_id != p_current->i_id )
        {
          ...",1,41,video_output\video_epg.c,vout_FillRightPanel,,false,320,412,vout_FillRightPanel,,,13,"void vout_FillRightPanel (subpicture_updater_sys_t*,int,int,int,int,int,int,subpicture_region_t**)"
194765,METHOD,video_output\video_epg.c:<global>,TYPE_DECL,"static subpicture_region_t * vout_BuildOSDEpg(subpicture_updater_sys_t *p_sys,
                                              int x, int y,
                                              int visible_width,
                                              int visible_height)
{
    subpicture_region_t *head;
    subpicture_region_t **last_ptr = &head;

    const int i_padding = visible_height * (OSDEPG_HEIGHT * OSDEPG_PADDING);

    *last_ptr = vout_OSDBackground(x + visible_width * OSDEPG_LEFT,
                                   y + visible_height * OSDEPG_TOP,
                                   visible_width  * OSDEPG_WIDTH,
                                   visible_height * OSDEPG_HEIGHT,
                                   ARGB_BGCOLOR);
    if(*last_ptr)
        last_ptr = &(*last_ptr)->p_next;

    struct
    {
        int x;
        int y;
        int w;
        int h;
        int rx;
        int ry;
    } panel = {
        x + visible_width  * OSDEPG_LEFT + i_padding,
        y + v...",1,44,video_output\video_epg.c,vout_BuildOSDEpg,,false,414,498,vout_BuildOSDEpg,,,14,"subpicture_region_t vout_BuildOSDEpg (subpicture_updater_sys_t*,int,int,int,int)"
195077,METHOD,video_output\video_epg.c:<global>,TYPE_DECL,"static int OSDEpgValidate(subpicture_t *subpic,
                          bool has_src_changed, const video_format_t *fmt_src,
                          bool has_dst_changed, const video_format_t *fmt_dst,
                          mtime_t ts)
{
    VLC_UNUSED(subpic); VLC_UNUSED(ts);
    VLC_UNUSED(fmt_src); VLC_UNUSED(has_src_changed);
    VLC_UNUSED(fmt_dst);

    if (!has_dst_changed)
        return VLC_SUCCESS;
    return VLC_EGENERIC;
}",1,1,video_output\video_epg.c,OSDEpgValidate,,false,500,512,OSDEpgValidate,,,15,"int OSDEpgValidate (subpicture_t*,bool,video_format_t*,bool,video_format_t*,mtime_t)"
195105,METHOD,video_output\video_epg.c:<global>,TYPE_DECL,"static void OSDEpgUpdate(subpicture_t *subpic,
                         const video_format_t *fmt_src,
                         const video_format_t *fmt_dst,
                         mtime_t ts)
{
    subpicture_updater_sys_t *sys = subpic->updater.p_sys;
    VLC_UNUSED(fmt_src); VLC_UNUSED(ts);

    video_format_t fmt = *fmt_dst;
    fmt.i_width         = fmt.i_width         * fmt.i_sar_num / fmt.i_sar_den;
    fmt.i_visible_width = fmt.i_visible_width * fmt.i_sar_num / fmt.i_sar_den;
    fmt.i_x_offset      = fmt.i_x_offset      * fmt.i_sar_num / fmt.i_sar_den;

    subpic->i_original_picture_width  = fmt.i_visible_width;
    subpic->i_original_picture_height = fmt.i_visible_height;

    subpic->p_region = vout_BuildOSDEpg(sys,
                                        fmt.i_x_offset,
                                        fmt.i_y_offset,
                                        fmt.i_visible_width,
                                        fmt.i_visible_height);
}",1,1,video_output\video_epg.c,OSDEpgUpdate,,false,514,535,OSDEpgUpdate,,,16,"void OSDEpgUpdate (subpicture_t*,video_format_t*,video_format_t*,mtime_t)"
195207,METHOD,video_output\video_epg.c:<global>,TYPE_DECL,"static void OSDEpgDestroy(subpicture_t *subpic)
{
    subpicture_updater_sys_t *sys = subpic->updater.p_sys;
    if( sys->epg )
        vlc_epg_Delete(sys->epg);
    free( sys->art );
    free(sys);
}",1,1,video_output\video_epg.c,OSDEpgDestroy,,false,537,544,OSDEpgDestroy,,,17,void OSDEpgDestroy (subpicture_t*)
195235,METHOD,video_output\video_epg.c:<global>,TYPE_DECL,"int vout_OSDEpg(vout_thread_t *vout, input_item_t *input )
{
    vlc_epg_t *epg = NULL;
    int64_t epg_time;

    /* Look for the current program EPG event */
    vlc_mutex_lock(&input->lock);

    const vlc_epg_t *tmp = input->p_epg_table;
    if ( tmp )
    {
        /* Pick table designated event, or first/next one */
        const vlc_epg_event_t *p_current_event = tmp->p_current;
        epg = vlc_epg_New(tmp->i_id, tmp->i_source_id);
        if(epg)
        {
            if( p_current_event )
            {
                vlc_epg_event_t *p_event = vlc_epg_event_Duplicate(p_current_event);
                if(p_event)
                {
                    if(!vlc_epg_AddEvent(epg, p_event))
                        vlc_epg_event_Delete(p_event);
                    else
                        vlc_epg_SetCurrent(epg, p_event->i_start);
                }
            }

            /* Add next event if any */
            vlc_epg_event_t *p_next = NULL;
            for(size_t i=0;...",1,1,video_output\video_epg.c,vout_OSDEpg,,false,552,659,vout_OSDEpg,,,18,"int vout_OSDEpg (vout_thread_t*,input_item_t*)"
195614,METHOD,video_output\video_output.c:<global>,TYPE_DECL,<global>,1,20,video_output\video_output.c,video_output\video_output.c:<global>,,false,1,1818,<global>,,,1,
195616,METHOD,video_output\video_output.c:<global>,TYPE_DECL,static void *Thread(void *);,13,27,video_output\video_output.c,Thread,,false,61,61,Thread,,,1,void* Thread (void*)
195621,METHOD,video_output\video_output.c:<global>,TYPE_DECL,static void VoutDestructor(vlc_object_t *);,13,42,video_output\video_output.c,VoutDestructor,,false,62,62,VoutDestructor,,,2,void VoutDestructor (vlc_object_t*)
195626,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"static int VoutValidateFormat(video_format_t *dst,
                              const video_format_t *src)
{
    if (src->i_width == 0  || src->i_width  > 8192 ||
        src->i_height == 0 || src->i_height > 8192)
        return VLC_EGENERIC;
    if (src->i_sar_num <= 0 || src->i_sar_den <= 0)
        return VLC_EGENERIC;

    /* */
    video_format_Copy(dst, src);
    dst->i_chroma = vlc_fourcc_GetCodec(VIDEO_ES, src->i_chroma);
    vlc_ureduce( &dst->i_sar_num, &dst->i_sar_den,
                 src->i_sar_num,  src->i_sar_den, 50000 );
    if (dst->i_sar_num <= 0 || dst->i_sar_den <= 0) {
        dst->i_sar_num = 1;
        dst->i_sar_den = 1;
    }
    video_format_FixRgb(dst);
    return VLC_SUCCESS;
}",1,1,video_output\video_output.c,VoutValidateFormat,,false,78,98,VoutValidateFormat,,,3,"int VoutValidateFormat (video_format_t*,video_format_t*)"
195729,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"static void VideoFormatCopyCropAr(video_format_t *dst,
                                  const video_format_t *src)
{
    video_format_CopyCrop(dst, src);
    dst->i_sar_num = src->i_sar_num;
    dst->i_sar_den = src->i_sar_den;
}",1,1,video_output\video_output.c,VideoFormatCopyCropAr,,false,99,105,VideoFormatCopyCropAr,,,4,"void VideoFormatCopyCropAr (video_format_t*,video_format_t*)"
195752,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"static bool VideoFormatIsCropArEqual(video_format_t *dst,
                                     const video_format_t *src)
{
    return dst->i_sar_num * src->i_sar_den == dst->i_sar_den * src->i_sar_num &&
           dst->i_x_offset       == src->i_x_offset &&
           dst->i_y_offset       == src->i_y_offset &&
           dst->i_visible_width  == src->i_visible_width &&
           dst->i_visible_height == src->i_visible_height;
}",1,1,video_output\video_output.c,VideoFormatIsCropArEqual,,false,106,114,VideoFormatIsCropArEqual,,,5,"bool VideoFormatIsCropArEqual (video_format_t*,video_format_t*)"
195806,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"static vout_thread_t *VoutCreate(vlc_object_t *object,
                                 const vout_configuration_t *cfg)
{
    video_format_t original;
    if (VoutValidateFormat(&original, cfg->fmt))
        return NULL;

    /* Allocate descriptor */
    vout_thread_t *vout = vlc_custom_create(object,
                                            sizeof(*vout) + sizeof(*vout->p),
                                            ""video output"");
    if (!vout) {
        video_format_Clean(&original);
        return NULL;
    }

    /* */
    vout->p = (vout_thread_sys_t*)&vout[1];

    vout->p->original = original;
    vout->p->dpb_size = cfg->dpb_size;

    vout_control_Init(&vout->p->control);
    vout_control_PushVoid(&vout->p->control, VOUT_CONTROL_INIT);

    vout_statistic_Init(&vout->p->statistic);

    vout_snapshot_Init(&vout->p->snapshot);

    /* Initialize locks */
    vlc_mutex_init(&vout->p->filter.lock);
    vlc_mutex_init(&vout->p->spu_lock);

    /* Take care of some ""int...",1,1,video_output\video_output.c,VoutCreate,,false,116,218,VoutCreate,,,6,"vout_thread_t VoutCreate (vlc_object_t*,vout_configuration_t*)"
196163,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"vout_thread_t *vout_Request(vlc_object_t *object,
                              const vout_configuration_t *cfg)
{
    vout_thread_t *vout = cfg->vout;
    if (cfg->change_fmt && !cfg->fmt) {
        if (vout)
            vout_CloseAndRelease(vout);
        return NULL;
    }

    /* If a vout is provided, try reusing it */
    if (vout) {
        if (vout->p->input != cfg->input) {
            if (vout->p->input)
                spu_Attach(vout->p->spu, vout->p->input, false);
            vout->p->input = cfg->input;
            if (vout->p->input)
                spu_Attach(vout->p->spu, vout->p->input, true);
        }

        if (cfg->change_fmt) {
            vout_control_cmd_t cmd;
            vout_control_cmd_Init(&cmd, VOUT_CONTROL_REINIT);
            cmd.u.cfg = cfg;

            vout_control_Push(&vout->p->control, &cmd);
            vout_control_WaitEmpty(&vout->p->control);
            vout_IntfReinit(vout);
        }

        if (!vout->p->dead) {
            msg_Dbg(...",1,1,video_output\video_output.c,vout_Request,,false,221,260,vout_Request,,,7,"vout_thread_t vout_Request (vlc_object_t*,vout_configuration_t*)"
196310,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"void vout_Close(vout_thread_t *vout)
{
    assert(vout);

    if (vout->p->input)
        spu_Attach(vout->p->spu, vout->p->input, false);

    vout_snapshot_End(&vout->p->snapshot);

    vout_control_PushVoid(&vout->p->control, VOUT_CONTROL_CLEAN);
    vlc_join(vout->p->thread, NULL);

    if (vout->p->window != NULL)
        vout_display_window_Delete(vout->p->window);

    vlc_mutex_lock(&vout->p->spu_lock);
    spu_Destroy(vout->p->spu);
    vout->p->spu = NULL;
    vlc_mutex_unlock(&vout->p->spu_lock);
}",1,1,video_output\video_output.c,vout_Close,,false,262,281,vout_Close,,,8,void vout_Close (vout_thread_t*)
196400,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"static void VoutDestructor(vlc_object_t *object)
{
    vout_thread_t *vout = (vout_thread_t *)object;

    /* Make sure the vout was stopped first */
    //assert(!vout->p_module);

    free(vout->p->splitter_name);

    /* Destroy the locks */
    vlc_mutex_destroy(&vout->p->spu_lock);
    vlc_mutex_destroy(&vout->p->filter.lock);
    vout_control_Clean(&vout->p->control);

    /* */
    vout_statistic_Clean(&vout->p->statistic);

    /* */
    vout_snapshot_Clean(&vout->p->snapshot);

    video_format_Clean(&vout->p->original);
}",1,1,video_output\video_output.c,VoutDestructor,,false,284,305,VoutDestructor,,,9,void VoutDestructor (vlc_object_t*)
196461,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"void vout_Cancel(vout_thread_t *vout, bool canceled)
{
    vout_control_PushBool(&vout->p->control, VOUT_CONTROL_CANCEL, canceled);
    vout_control_WaitEmpty(&vout->p->control);
}",1,1,video_output\video_output.c,vout_Cancel,,false,308,312,vout_Cancel,,,10,"void vout_Cancel (vout_thread_t*,bool)"
196483,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"void vout_ChangePause(vout_thread_t *vout, bool is_paused, mtime_t date)
{
    vout_control_cmd_t cmd;
    vout_control_cmd_Init(&cmd, VOUT_CONTROL_PAUSE);
    cmd.u.pause.is_on = is_paused;
    cmd.u.pause.date  = date;
    vout_control_Push(&vout->p->control, &cmd);

    vout_control_WaitEmpty(&vout->p->control);
}",1,1,video_output\video_output.c,vout_ChangePause,,false,314,323,vout_ChangePause,,,11,"void vout_ChangePause (vout_thread_t*,bool,mtime_t)"
196529,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"void vout_GetResetStatistic(vout_thread_t *vout, unsigned *restrict displayed,
                            unsigned *restrict lost)
{
    vout_statistic_GetReset( &vout->p->statistic, displayed, lost );
}",1,1,video_output\video_output.c,vout_GetResetStatistic,,false,325,329,vout_GetResetStatistic,,,12,"void vout_GetResetStatistic (vout_thread_t*,unsigned*,unsigned*)"
196545,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"void vout_Flush(vout_thread_t *vout, mtime_t date)
{
    vout_control_PushTime(&vout->p->control, VOUT_CONTROL_FLUSH, date);
    vout_control_WaitEmpty(&vout->p->control);
}",1,1,video_output\video_output.c,vout_Flush,,false,331,335,vout_Flush,,,13,"void vout_Flush (vout_thread_t*,mtime_t)"
196567,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"bool vout_IsEmpty(vout_thread_t *vout)
{
    picture_t *picture = picture_fifo_Peek(vout->p->decoder_fifo);
    if (picture)
        picture_Release(picture);

    return !picture;
}",1,1,video_output\video_output.c,vout_IsEmpty,,false,337,344,vout_IsEmpty,,,14,bool vout_IsEmpty (vout_thread_t*)
196589,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"void vout_NextPicture(vout_thread_t *vout, mtime_t *duration)
{
    vout_control_cmd_t cmd;
    vout_control_cmd_Init(&cmd, VOUT_CONTROL_STEP);
    cmd.u.time_ptr = duration;

    vout_control_Push(&vout->p->control, &cmd);
    vout_control_WaitEmpty(&vout->p->control);
}",1,1,video_output\video_output.c,vout_NextPicture,,false,346,354,vout_NextPicture,,,15,"void vout_NextPicture (vout_thread_t*,mtime_t*)"
196623,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"void vout_DisplayTitle(vout_thread_t *vout, const char *title)
{
    assert(title);
    vout_control_PushString(&vout->p->control, VOUT_CONTROL_OSD_TITLE, title);
}",1,1,video_output\video_output.c,vout_DisplayTitle,,false,356,360,vout_DisplayTitle,,,16,"void vout_DisplayTitle (vout_thread_t*,char*)"
196640,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"void vout_WindowMouseEvent(vout_thread_t *vout,
                           const vout_window_mouse_event_t *mouse)
{
    assert(mouse);
    vout_control_cmd_t cmd;
    vout_control_cmd_Init(&cmd, VOUT_CONTROL_WINDOW_MOUSE);
    cmd.u.window_mouse = *mouse;

    vout_control_Push(&vout->p->control, &cmd);
}",1,1,video_output\video_output.c,vout_WindowMouseEvent,,false,362,371,vout_WindowMouseEvent,,,17,"void vout_WindowMouseEvent (vout_thread_t*,vout_window_mouse_event_t*)"
196670,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"void vout_PutSubpicture( vout_thread_t *vout, subpicture_t *subpic )
{
    vout_control_cmd_t cmd;
    vout_control_cmd_Init(&cmd, VOUT_CONTROL_SUBPICTURE);
    cmd.u.subpicture = subpic;

    vout_control_Push(&vout->p->control, &cmd);
}",1,1,video_output\video_output.c,vout_PutSubpicture,,false,373,380,vout_PutSubpicture,,,18,"void vout_PutSubpicture (vout_thread_t*,subpicture_t*)"
196697,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"int vout_RegisterSubpictureChannel( vout_thread_t *vout )
{
    int channel = VOUT_SPU_CHANNEL_AVAIL_FIRST;

    vlc_mutex_lock(&vout->p->spu_lock);
    if (vout->p->spu)
        channel = spu_RegisterChannel(vout->p->spu);
    vlc_mutex_unlock(&vout->p->spu_lock);

    return channel;
}",1,1,video_output\video_output.c,vout_RegisterSubpictureChannel,,false,381,391,vout_RegisterSubpictureChannel,,,19,int vout_RegisterSubpictureChannel (vout_thread_t*)
196737,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"void vout_FlushSubpictureChannel( vout_thread_t *vout, int channel )
{
    vout_control_PushInteger(&vout->p->control, VOUT_CONTROL_FLUSH_SUBPICTURE,
                             channel);
}",1,1,video_output\video_output.c,vout_FlushSubpictureChannel,,false,392,396,vout_FlushSubpictureChannel,,,20,"void vout_FlushSubpictureChannel (vout_thread_t*,int)"
196752,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"picture_t *vout_GetPicture(vout_thread_t *vout)
{
    picture_t *picture = picture_pool_Wait(vout->p->decoder_pool);
    if (likely(picture != NULL)) {
        picture_Reset(picture);
        VideoFormatCopyCropAr(&picture->format, &vout->p->original);
    }
    return picture;
}",1,1,video_output\video_output.c,vout_GetPicture,,false,407,415,vout_GetPicture,,,21,picture_t vout_GetPicture (vout_thread_t*)
196787,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"void vout_PutPicture(vout_thread_t *vout, picture_t *picture)
{
    picture->p_next = NULL;
    if (picture_pool_OwnsPic(vout->p->decoder_pool, picture))
    {
        picture_fifo_Push(vout->p->decoder_fifo, picture);

        vout_control_Wake(&vout->p->control);
    }
    else
    {
        /* FIXME: HACK: Drop this picture because the vout changed. The old
         * picture pool need to be kept by the new vout. This requires a major
         * ""vout display"" API change. */
        picture_Release(picture);
    }
}",1,1,video_output\video_output.c,vout_PutPicture,,false,425,441,vout_PutPicture,,,22,"void vout_PutPicture (vout_thread_t*,picture_t*)"
196825,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"int vout_GetSnapshot(vout_thread_t *vout,
                     block_t **image_dst, picture_t **picture_dst,
                     video_format_t *fmt,
                     const char *type, mtime_t timeout)
{
    picture_t *picture = vout_snapshot_Get(&vout->p->snapshot, timeout);
    if (!picture) {
        msg_Err(vout, ""Failed to grab a snapshot"");
        return VLC_EGENERIC;
    }

    if (image_dst) {
        vlc_fourcc_t codec = VLC_CODEC_PNG;
        if (type && image_Type2Fourcc(type))
            codec = image_Type2Fourcc(type);

        const int override_width  = var_InheritInteger(vout, ""snapshot-width"");
        const int override_height = var_InheritInteger(vout, ""snapshot-height"");

        if (picture_Export(VLC_OBJECT(vout), image_dst, fmt,
                           picture, codec, override_width, override_height)) {
            msg_Err(vout, ""Failed to convert image for snapshot"");
            picture_Release(picture);
            return VLC_EGENERIC;
        }
 ...",1,1,video_output\video_output.c,vout_GetSnapshot,,false,444,475,vout_GetSnapshot,,,23,"int vout_GetSnapshot (vout_thread_t*,block_t**,picture_t**,video_format_t*,char*,mtime_t)"
196915,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"void vout_ChangeAspectRatio( vout_thread_t *p_vout,
                             unsigned int i_num, unsigned int i_den )
{
    vout_ControlChangeSampleAspectRatio( p_vout, i_num, i_den );
}",1,1,video_output\video_output.c,vout_ChangeAspectRatio,,false,477,481,vout_ChangeAspectRatio,,,24,"void vout_ChangeAspectRatio (vout_thread_t*,unsigned int,unsigned int)"
196926,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"void vout_ControlChangeFullscreen(vout_thread_t *vout, bool fullscreen)
{
    vout_control_PushBool(&vout->p->control, VOUT_CONTROL_FULLSCREEN,
                          fullscreen);
}",1,1,video_output\video_output.c,vout_ControlChangeFullscreen,,false,484,488,vout_ControlChangeFullscreen,,,25,"void vout_ControlChangeFullscreen (vout_thread_t*,bool)"
196941,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"void vout_ControlChangeWindowState(vout_thread_t *vout, unsigned st)
{
    vout_control_PushInteger(&vout->p->control, VOUT_CONTROL_WINDOW_STATE, st);
}",1,1,video_output\video_output.c,vout_ControlChangeWindowState,,false,489,492,vout_ControlChangeWindowState,,,26,"void vout_ControlChangeWindowState (vout_thread_t*,unsigned)"
196956,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"void vout_ControlChangeDisplayFilled(vout_thread_t *vout, bool is_filled)
{
    vout_control_PushBool(&vout->p->control, VOUT_CONTROL_DISPLAY_FILLED,
                          is_filled);
}",1,1,video_output\video_output.c,vout_ControlChangeDisplayFilled,,false,493,497,vout_ControlChangeDisplayFilled,,,27,"void vout_ControlChangeDisplayFilled (vout_thread_t*,bool)"
196971,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"void vout_ControlChangeZoom(vout_thread_t *vout, int num, int den)
{
    vout_control_PushPair(&vout->p->control, VOUT_CONTROL_ZOOM,
                          num, den);
}",1,1,video_output\video_output.c,vout_ControlChangeZoom,,false,498,502,vout_ControlChangeZoom,,,28,"void vout_ControlChangeZoom (vout_thread_t*,int,int)"
196988,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"void vout_ControlChangeSampleAspectRatio(vout_thread_t *vout,
                                         unsigned num, unsigned den)
{
    vout_control_PushPair(&vout->p->control, VOUT_CONTROL_ASPECT_RATIO,
                          num, den);
}",1,1,video_output\video_output.c,vout_ControlChangeSampleAspectRatio,,false,503,508,vout_ControlChangeSampleAspectRatio,,,29,"void vout_ControlChangeSampleAspectRatio (vout_thread_t*,unsigned,unsigned)"
197005,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"void vout_ControlChangeCropRatio(vout_thread_t *vout,
                                 unsigned num, unsigned den)
{
    vout_control_PushPair(&vout->p->control, VOUT_CONTROL_CROP_RATIO,
                          num, den);
}",1,1,video_output\video_output.c,vout_ControlChangeCropRatio,,false,509,514,vout_ControlChangeCropRatio,,,30,"void vout_ControlChangeCropRatio (vout_thread_t*,unsigned,unsigned)"
197022,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"void vout_ControlChangeCropWindow(vout_thread_t *vout,
                                  int x, int y, int width, int height)
{
    vout_control_cmd_t cmd;
    vout_control_cmd_Init(&cmd, VOUT_CONTROL_CROP_WINDOW);
    cmd.u.window.x      = __MAX(x, 0);
    cmd.u.window.y      = __MAX(y, 0);
    cmd.u.window.width  = __MAX(width, 0);
    cmd.u.window.height = __MAX(height, 0);

    vout_control_Push(&vout->p->control, &cmd);
}",1,1,video_output\video_output.c,vout_ControlChangeCropWindow,,false,515,526,vout_ControlChangeCropWindow,,,31,"void vout_ControlChangeCropWindow (vout_thread_t*,int,int,int,int)"
197089,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"void vout_ControlChangeCropBorder(vout_thread_t *vout,
                                  int left, int top, int right, int bottom)
{
    vout_control_cmd_t cmd;
    vout_control_cmd_Init(&cmd, VOUT_CONTROL_CROP_BORDER);
    cmd.u.border.left   = __MAX(left, 0);
    cmd.u.border.top    = __MAX(top, 0);
    cmd.u.border.right  = __MAX(right, 0);
    cmd.u.border.bottom = __MAX(bottom, 0);

    vout_control_Push(&vout->p->control, &cmd);
}",1,1,video_output\video_output.c,vout_ControlChangeCropBorder,,false,527,538,vout_ControlChangeCropBorder,,,32,"void vout_ControlChangeCropBorder (vout_thread_t*,int,int,int,int)"
197156,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"void vout_ControlChangeFilters(vout_thread_t *vout, const char *filters)
{
    vout_control_PushString(&vout->p->control, VOUT_CONTROL_CHANGE_FILTERS,
                            filters);
}",1,1,video_output\video_output.c,vout_ControlChangeFilters,,false,539,543,vout_ControlChangeFilters,,,33,"void vout_ControlChangeFilters (vout_thread_t*,char*)"
197171,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"void vout_ControlChangeSubSources(vout_thread_t *vout, const char *filters)
{
    vout_control_PushString(&vout->p->control, VOUT_CONTROL_CHANGE_SUB_SOURCES,
                            filters);
}",1,1,video_output\video_output.c,vout_ControlChangeSubSources,,false,544,548,vout_ControlChangeSubSources,,,34,"void vout_ControlChangeSubSources (vout_thread_t*,char*)"
197186,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"void vout_ControlChangeSubFilters(vout_thread_t *vout, const char *filters)
{
    vout_control_PushString(&vout->p->control, VOUT_CONTROL_CHANGE_SUB_FILTERS,
                            filters);
}",1,1,video_output\video_output.c,vout_ControlChangeSubFilters,,false,549,553,vout_ControlChangeSubFilters,,,35,"void vout_ControlChangeSubFilters (vout_thread_t*,char*)"
197201,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"void vout_ControlChangeSubMargin(vout_thread_t *vout, int margin)
{
    vout_control_PushInteger(&vout->p->control, VOUT_CONTROL_CHANGE_SUB_MARGIN,
                             margin);
}",1,1,video_output\video_output.c,vout_ControlChangeSubMargin,,false,554,558,vout_ControlChangeSubMargin,,,36,"void vout_ControlChangeSubMargin (vout_thread_t*,int)"
197216,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"void vout_ControlChangeViewpoint(vout_thread_t *vout,
                                 const vlc_viewpoint_t *p_viewpoint)
{
    vout_control_cmd_t cmd;
    vout_control_cmd_Init(&cmd, VOUT_CONTROL_VIEWPOINT);
    cmd.u.viewpoint = *p_viewpoint;
    vout_control_Push(&vout->p->control, &cmd);
}",1,1,video_output\video_output.c,vout_ControlChangeViewpoint,,false,560,567,vout_ControlChangeViewpoint,,,37,"void vout_ControlChangeViewpoint (vout_thread_t*,vlc_viewpoint_t*)"
197244,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"static void VoutGetDisplayCfg(vout_thread_t *vout, vout_display_cfg_t *cfg, const char *title)
{
    /* Load configuration */
#if defined(_WIN32) || defined(__OS2__)
    cfg->is_fullscreen = var_GetBool(vout, ""fullscreen"")
                         || var_GetBool(vout, ""video-wallpaper"");
#endif
    cfg->viewpoint = vout->p->original.pose;

    cfg->display.title = title;
    const int display_width = var_GetInteger(vout, ""width"");
    const int display_height = var_GetInteger(vout, ""height"");
    cfg->display.width   = display_width > 0  ? display_width  : 0;
    cfg->display.height  = display_height > 0 ? display_height : 0;
    cfg->is_display_filled  = var_GetBool(vout, ""autoscale"");
    unsigned msar_num, msar_den;
    if (var_InheritURational(vout, &msar_num, &msar_den, ""monitor-par"") ||
        msar_num <= 0 || msar_den <= 0) {
        msar_num = 1;
        msar_den = 1;
    }
    cfg->display.sar.num = msar_num;
    cfg->display.sar.den = msar_den;
    unsigned zoom_den = 100...",1,1,video_output\video_output.c,VoutGetDisplayCfg,,false,570,609,VoutGetDisplayCfg,,,38,"void VoutGetDisplayCfg (vout_thread_t*,vout_display_cfg_t*,char*)"
197461,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"vout_window_t *vout_NewDisplayWindow(vout_thread_t *vout, unsigned type)
{
    vout_window_t *window = vout->p->window;

    assert(vout->p->splitter_name == NULL);

    if (window == NULL)
        return NULL;
    if (type != VOUT_WINDOW_TYPE_INVALID && type != window->type)
        return NULL;
    return window;
}",1,1,video_output\video_output.c,vout_NewDisplayWindow,,false,611,622,vout_NewDisplayWindow,,,39,"vout_window_t vout_NewDisplayWindow (vout_thread_t*,unsigned)"
197505,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"void vout_DeleteDisplayWindow(vout_thread_t *vout, vout_window_t *window)
{
    if (window == NULL && vout->p->window != NULL) {
        vout_display_window_Delete(vout->p->window);
        vout->p->window = NULL;
    }
    assert(vout->p->window == window);
}",1,1,video_output\video_output.c,vout_DeleteDisplayWindow,,false,624,631,vout_DeleteDisplayWindow,,,40,"void vout_DeleteDisplayWindow (vout_thread_t*,vout_window_t*)"
197545,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"void vout_SetDisplayWindowSize(vout_thread_t *vout,
                               unsigned width, unsigned height)
{
    vout_window_t *window = vout->p->window;

    if (window != NULL)
    /* Request a resize of the window. If it fails, there is nothing to do.
     * If it succeeds, the window will emit a resize event later. */
        vout_window_SetSize(window, width, height);
    else
    if (vout->p->display.vd != NULL)
    /* Force a resize of window-less display. This is not allowed to fail,
     * although the display is allowed to ignore the size anyway. */
        /* FIXME: remove this, fix MSW and OS/2 window providers */
        vout_display_SendEventDisplaySize(vout->p->display.vd, width, height);
}",1,1,video_output\video_output.c,vout_SetDisplayWindowSize,,false,633,648,vout_SetDisplayWindowSize,,,41,"void vout_SetDisplayWindowSize (vout_thread_t*,unsigned,unsigned)"
197592,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"int vout_HideWindowMouse(vout_thread_t *vout, bool hide)
{
    vout_window_t *window = vout->p->window;

    return window != NULL ? vout_window_HideMouse(window, hide) : VLC_EGENERIC;
}",1,1,video_output\video_output.c,vout_HideWindowMouse,,false,650,655,vout_HideWindowMouse,,,42,"int vout_HideWindowMouse (vout_thread_t*,bool)"
197615,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"static int FilterRestartCallback(vlc_object_t *p_this, char const *psz_var,
                                 vlc_value_t oldval, vlc_value_t newval,
                                 void *p_data)
{
    (void) p_this; (void) psz_var; (void) oldval; (void) newval;
    vout_ControlChangeFilters((vout_thread_t *)p_data, NULL);
    return 0;
}",1,1,video_output\video_output.c,FilterRestartCallback,,false,658,665,FilterRestartCallback,,,43,"int FilterRestartCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
197643,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"static int ThreadDelFilterCallbacks(filter_t *filter, void *opaque)
{
    filter_DelProxyCallbacks((vlc_object_t *)opaque, filter,
                             FilterRestartCallback);
    return VLC_SUCCESS;
}",1,1,video_output\video_output.c,ThreadDelFilterCallbacks,,false,667,672,ThreadDelFilterCallbacks,,,44,"int ThreadDelFilterCallbacks (filter_t*,void*)"
197657,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"static void ThreadDelAllFilterCallbacks(vout_thread_t *vout)
{
    assert(vout->p->filter.chain_interactive != NULL);
    filter_chain_ForEach(vout->p->filter.chain_interactive,
                         ThreadDelFilterCallbacks, vout);
}",1,1,video_output\video_output.c,ThreadDelAllFilterCallbacks,,false,674,679,ThreadDelAllFilterCallbacks,,,45,void ThreadDelAllFilterCallbacks (vout_thread_t*)
197682,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"static picture_t *VoutVideoFilterInteractiveNewPicture(filter_t *filter)
{
    vout_thread_t *vout = filter->owner.sys;

    picture_t *picture = picture_pool_Get(vout->p->private_pool);
    if (picture) {
        picture_Reset(picture);
        VideoFormatCopyCropAr(&picture->format, &filter->fmt_out.video);
    }
    return picture;
}",1,1,video_output\video_output.c,VoutVideoFilterInteractiveNewPicture,,false,681,691,VoutVideoFilterInteractiveNewPicture,,,46,picture_t VoutVideoFilterInteractiveNewPicture (filter_t*)
197722,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"static picture_t *VoutVideoFilterStaticNewPicture(filter_t *filter)
{
    vout_thread_t *vout = filter->owner.sys;

    vlc_assert_locked(&vout->p->filter.lock);
    if (filter_chain_IsEmpty(vout->p->filter.chain_interactive))
        return VoutVideoFilterInteractiveNewPicture(filter);

    return picture_NewFromFormat(&filter->fmt_out.video);
}",1,1,video_output\video_output.c,VoutVideoFilterStaticNewPicture,,false,693,702,VoutVideoFilterStaticNewPicture,,,47,picture_t VoutVideoFilterStaticNewPicture (filter_t*)
197765,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"static void ThreadFilterFlush(vout_thread_t *vout, bool is_locked)
{
    if (vout->p->displayed.current)
        picture_Release( vout->p->displayed.current );
    vout->p->displayed.current = NULL;

    if (vout->p->displayed.next)
        picture_Release( vout->p->displayed.next );
    vout->p->displayed.next = NULL;

    if (!is_locked)
        vlc_mutex_lock(&vout->p->filter.lock);
    filter_chain_VideoFlush(vout->p->filter.chain_static);
    filter_chain_VideoFlush(vout->p->filter.chain_interactive);
    if (!is_locked)
        vlc_mutex_unlock(&vout->p->filter.lock);
}",1,1,video_output\video_output.c,ThreadFilterFlush,,false,704,720,ThreadFilterFlush,,,48,"void ThreadFilterFlush (vout_thread_t*,bool)"
197869,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"static void ThreadChangeFilters(vout_thread_t *vout,
                                const video_format_t *source,
                                const char *filters,
                                int deinterlace,
                                bool is_locked)
{
    ThreadFilterFlush(vout, is_locked);
    ThreadDelAllFilterCallbacks(vout);

    vlc_array_t array_static;
    vlc_array_t array_interactive;

    vlc_array_init(&array_static);
    vlc_array_init(&array_interactive);

    if ((vout->p->filter.has_deint =
         deinterlace == 1 || (deinterlace == -1 && vout->p->filter.has_deint)))
    {
        vout_filter_t *e = malloc(sizeof(*e));

        if (likely(e))
        {
            free(config_ChainCreate(&e->name, &e->cfg, ""deinterlace""));
            vlc_array_append_or_abort(&array_static, e);
        }
    }

    char *current = filters ? strdup(filters) : NULL;
    while (current) {
        config_chain_t *cfg;
        char *name;
        char *next = config_Chain...",1,1,video_output\video_output.c,ThreadChangeFilters,,false,727,844,ThreadChangeFilters,,,51,"void ThreadChangeFilters (vout_thread_t*,video_format_t*,char*,int,bool)"
198319,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"static int ThreadDisplayPreparePicture(vout_thread_t *vout, bool reuse, bool frame_by_frame)
{
    bool is_late_dropped = vout->p->is_late_dropped && !vout->p->pause.is_on && !frame_by_frame;

    vlc_mutex_lock(&vout->p->filter.lock);

    picture_t *picture = filter_chain_VideoFilter(vout->p->filter.chain_static, NULL);
    assert(!reuse || !picture);

    while (!picture) {
        picture_t *decoded;
        if (reuse && vout->p->displayed.decoded) {
            decoded = picture_Hold(vout->p->displayed.decoded);
        } else {
            decoded = picture_fifo_Pop(vout->p->decoder_fifo);
            if (decoded) {
                if (is_late_dropped && !decoded->b_force) {
                    mtime_t late_threshold;
                    if (decoded->format.i_frame_rate && decoded->format.i_frame_rate_base)
                        late_threshold = ((CLOCK_FREQ/2) * decoded->format.i_frame_rate_base) / decoded->format.i_frame_rate;
                    else
                     ...",1,41,video_output\video_output.c,ThreadDisplayPreparePicture,,false,848,911,ThreadDisplayPreparePicture,,,52,"int ThreadDisplayPreparePicture (vout_thread_t*,bool,bool)"
198655,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"static picture_t *ConvertRGB32AndBlendBufferNew(filter_t *filter)
{
    return picture_NewFromFormat(&filter->fmt_out.video);
}",1,1,video_output\video_output.c,ConvertRGB32AndBlendBufferNew,,false,913,916,ConvertRGB32AndBlendBufferNew,,,53,picture_t ConvertRGB32AndBlendBufferNew (filter_t*)
198668,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"static picture_t *ConvertRGB32AndBlend(vout_thread_t *vout, picture_t *pic,
                                     subpicture_t *subpic)
{
    /* This function will convert the pic to RGB32 and blend the subpic to it.
     * The returned pic can't be used to display since the chroma will be
     * different than the ""vout display"" one, but it can be used for snapshots.
     * */

    assert(vout->p->spu_blend);

    filter_owner_t owner = {
        .video = {
            .buffer_new = ConvertRGB32AndBlendBufferNew,
        },
    };
    filter_chain_t *filterc = filter_chain_NewVideo(vout, false, &owner);
    if (!filterc)
        return NULL;

    es_format_t src = vout->p->spu_blend->fmt_out;
    es_format_t dst = src;
    dst.video.i_chroma = VLC_CODEC_RGB32;
    video_format_FixRgb(&dst.video);

    if (filter_chain_AppendConverter(filterc, &src, &dst) != 0)
    {
        filter_chain_Delete(filterc);
        return NULL;
    }

    picture_Hold(pic);
    pic = filter_chain_VideoF...",1,1,video_output\video_output.c,ConvertRGB32AndBlend,,false,918,965,ConvertRGB32AndBlend,,,54,"picture_t ConvertRGB32AndBlend (vout_thread_t*,picture_t*,subpicture_t*)"
198792,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"static int ThreadDisplayRenderPicture(vout_thread_t *vout, bool is_forced)
{
    vout_thread_sys_t *sys = vout->p;
    vout_display_t *vd = vout->p->display.vd;

    picture_t *torender = picture_Hold(vout->p->displayed.current);

    vout_chrono_Start(&vout->p->render);

    vlc_mutex_lock(&vout->p->filter.lock);
    picture_t *filtered = filter_chain_VideoFilter(vout->p->filter.chain_interactive, torender);
    vlc_mutex_unlock(&vout->p->filter.lock);

    if (!filtered)
        return VLC_EGENERIC;

    if (filtered->date != vout->p->displayed.current->date)
        msg_Warn(vout, ""Unsupported timestamp modifications done by chain_interactive"");

    /*
     * Get the subpicture to be displayed
     */
    const bool do_snapshot = vout_snapshot_IsRequested(&vout->p->snapshot);
    mtime_t render_subtitle_date;
    if (vout->p->pause.is_on)
        render_subtitle_date = vout->p->pause.date;
    else
        render_subtitle_date = filtered->date > 1 ? filtered->date : mdate();
   ...",1,1,video_output\video_output.c,ThreadDisplayRenderPicture,,false,967,1183,ThreadDisplayRenderPicture,,,55,"int ThreadDisplayRenderPicture (vout_thread_t*,bool)"
199576,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"static int ThreadDisplayPicture(vout_thread_t *vout, mtime_t *deadline)
{
    bool frame_by_frame = !deadline;
    bool paused = vout->p->pause.is_on;
    bool first = !vout->p->displayed.current;

    if (first)
        if (ThreadDisplayPreparePicture(vout, true, frame_by_frame)) /* FIXME not sure it is ok */
            return VLC_EGENERIC;

    if (!paused || frame_by_frame)
        while (!vout->p->displayed.next && !ThreadDisplayPreparePicture(vout, false, frame_by_frame))
            ;

    const mtime_t date = mdate();
    const mtime_t render_delay = vout_chrono_GetHigh(&vout->p->render) + VOUT_MWAIT_TOLERANCE;

    bool drop_next_frame = frame_by_frame;
    mtime_t date_next = VLC_TS_INVALID;
    if (!paused && vout->p->displayed.next) {
        date_next = vout->p->displayed.next->date - render_delay;
        if (date_next /* + 0 FIXME */ <= date)
            drop_next_frame = true;
    }

    /* FIXME/XXX we must redisplay the last decoded picture (because
     * of poten...",1,73,video_output\video_output.c,ThreadDisplayPicture,,false,1185,1252,ThreadDisplayPicture,,,56,"int ThreadDisplayPicture (vout_thread_t*,mtime_t*)"
199860,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"static void ThreadDisplaySubpicture(vout_thread_t *vout,
                                    subpicture_t *subpicture)
{
    spu_PutSubpicture(vout->p->spu, subpicture);
}",1,1,video_output\video_output.c,ThreadDisplaySubpicture,,false,1254,1258,ThreadDisplaySubpicture,,,57,"void ThreadDisplaySubpicture (vout_thread_t*,subpicture_t*)"
199873,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"static void ThreadFlushSubpicture(vout_thread_t *vout, int channel)
{
    spu_ClearChannel(vout->p->spu, channel);
}",1,1,video_output\video_output.c,ThreadFlushSubpicture,,false,1260,1263,ThreadFlushSubpicture,,,58,"void ThreadFlushSubpicture (vout_thread_t*,int)"
199886,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"static void ThreadDisplayOsdTitle(vout_thread_t *vout, const char *string)
{
    if (!vout->p->title.show)
        return;

    vout_OSDText(vout, VOUT_SPU_CHANNEL_OSD,
                 vout->p->title.position, INT64_C(1000) * vout->p->title.timeout,
                 string);
}",1,1,video_output\video_output.c,ThreadDisplayOsdTitle,,false,1265,1273,ThreadDisplayOsdTitle,,,59,"void ThreadDisplayOsdTitle (vout_thread_t*,char*)"
199924,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"static void ThreadChangeSubSources(vout_thread_t *vout, const char *filters)
{
    spu_ChangeSources(vout->p->spu, filters);
}",1,1,video_output\video_output.c,ThreadChangeSubSources,,false,1275,1278,ThreadChangeSubSources,,,60,"void ThreadChangeSubSources (vout_thread_t*,char*)"
199937,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"static void ThreadChangeSubFilters(vout_thread_t *vout, const char *filters)
{
    spu_ChangeFilters(vout->p->spu, filters);
}",1,1,video_output\video_output.c,ThreadChangeSubFilters,,false,1280,1283,ThreadChangeSubFilters,,,61,"void ThreadChangeSubFilters (vout_thread_t*,char*)"
199950,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"static void ThreadChangeSubMargin(vout_thread_t *vout, int margin)
{
    spu_ChangeMargin(vout->p->spu, margin);
}",1,1,video_output\video_output.c,ThreadChangeSubMargin,,false,1285,1288,ThreadChangeSubMargin,,,62,"void ThreadChangeSubMargin (vout_thread_t*,int)"
199963,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"static void ThreadChangePause(vout_thread_t *vout, bool is_paused, mtime_t date)
{
    assert(!vout->p->pause.is_on || !is_paused);

    if (vout->p->pause.is_on) {
        const mtime_t duration = date - vout->p->pause.date;

        if (vout->p->step.timestamp > VLC_TS_INVALID)
            vout->p->step.timestamp += duration;
        if (vout->p->step.last > VLC_TS_INVALID)
            vout->p->step.last += duration;
        picture_fifo_OffsetDate(vout->p->decoder_fifo, duration);
        if (vout->p->displayed.decoded)
            vout->p->displayed.decoded->date += duration;
        spu_OffsetSubtitleDate(vout->p->spu, duration);

        ThreadFilterFlush(vout, false);
    } else {
        vout->p->step.timestamp = VLC_TS_INVALID;
        vout->p->step.last      = VLC_TS_INVALID;
    }
    vout->p->pause.is_on = is_paused;
    vout->p->pause.date  = date;

    vout_window_t *window = vout->p->window;
    if (window != NULL)
        vout_window_SetInhibition(window, !is_paused);
}",1,1,video_output\video_output.c,ThreadChangePause,,false,1290,1317,ThreadChangePause,,,63,"void ThreadChangePause (vout_thread_t*,bool,mtime_t)"
200135,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"static void ThreadFlush(vout_thread_t *vout, bool below, mtime_t date)
{
    vout->p->step.timestamp = VLC_TS_INVALID;
    vout->p->step.last      = VLC_TS_INVALID;

    ThreadFilterFlush(vout, false); /* FIXME too much */

    picture_t *last = vout->p->displayed.decoded;
    if (last) {
        if (( below && last->date <= date) ||
            (!below && last->date >= date)) {
            picture_Release(last);

            vout->p->displayed.decoded   = NULL;
            vout->p->displayed.date      = VLC_TS_INVALID;
            vout->p->displayed.timestamp = VLC_TS_INVALID;
        }
    }

    picture_fifo_Flush(vout->p->decoder_fifo, date, below);
    vout_FilterFlush(vout->p->display.vd);
}",1,1,video_output\video_output.c,ThreadFlush,,false,1319,1340,ThreadFlush,,,64,"void ThreadFlush (vout_thread_t*,bool,mtime_t)"
200239,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"static void ThreadStep(vout_thread_t *vout, mtime_t *duration)
{
    *duration = 0;

    if (vout->p->step.last <= VLC_TS_INVALID)
        vout->p->step.last = vout->p->displayed.timestamp;

    if (ThreadDisplayPicture(vout, NULL))
        return;

    vout->p->step.timestamp = vout->p->displayed.timestamp;

    if (vout->p->step.last > VLC_TS_INVALID &&
        vout->p->step.timestamp > vout->p->step.last) {
        *duration = vout->p->step.timestamp - vout->p->step.last;
        vout->p->step.last = vout->p->step.timestamp;
        /* TODO advance subpicture by the duration ... */
    }
}",1,1,video_output\video_output.c,ThreadStep,,false,1342,1360,ThreadStep,,,65,"void ThreadStep (vout_thread_t*,mtime_t*)"
200356,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"static void ThreadChangeFullscreen(vout_thread_t *vout, bool fullscreen)
{
    vout_window_t *window = vout->p->window;

#if !defined(_WIN32) && !defined(__OS2__)
    if (window != NULL)
        vout_window_SetFullScreen(window, fullscreen);
#else
    bool window_fullscreen = false;
    if (window != NULL
     && vout_window_SetFullScreen(window, fullscreen) == VLC_SUCCESS)
        window_fullscreen = true;
    /* FIXME: remove this event */
    if (vout->p->display.vd != NULL)
        vout_display_SendEventFullscreen(vout->p->display.vd, fullscreen, window_fullscreen);
#endif
}",1,1,video_output\video_output.c,ThreadChangeFullscreen,,false,1362,1378,ThreadChangeFullscreen,,,66,"void ThreadChangeFullscreen (vout_thread_t*,bool)"
200378,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"static void ThreadChangeWindowState(vout_thread_t *vout, unsigned state)
{
    vout_window_t *window = vout->p->window;

    if (window != NULL)
        vout_window_SetState(window, state);
#if defined(_WIN32) || defined(__OS2__)
    else /* FIXME: remove this event */
    if (vout->p->display.vd != NULL)
        vout_display_SendWindowState(vout->p->display.vd, state);
#endif
}",1,1,video_output\video_output.c,ThreadChangeWindowState,,false,1380,1391,ThreadChangeWindowState,,,67,"void ThreadChangeWindowState (vout_thread_t*,unsigned)"
200400,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"static void ThreadChangeWindowMouse(vout_thread_t *vout,
                                    const vout_window_mouse_event_t *mouse)
{
    vout_display_t *vd = vout->p->display.vd;
    switch (mouse->type)
    {
        case VOUT_WINDOW_MOUSE_STATE:
        case VOUT_WINDOW_MOUSE_MOVED:
        {
            vout_display_place_t place;
            vout_display_PlacePicture(&place, &vd->source, vd->cfg, false);

            if (place.width <= 0 || place.height <= 0)
                return;

            const int x = vd->source.i_x_offset +
                (int64_t)(mouse->x - place.x) *
                vd->source.i_visible_width / place.width;
            const int y = vd->source.i_y_offset +
                (int64_t)(mouse->y - place.y) *
                vd->source.i_visible_height/ place.height;

            if (mouse->type == VOUT_WINDOW_MOUSE_STATE)
                vout_display_SendEventMouseState(vd, x, y, mouse->button_mask);
            else
                vout_display_SendEv...",1,1,video_output\video_output.c,ThreadChangeWindowMouse,,false,1393,1434,ThreadChangeWindowMouse,,,68,"void ThreadChangeWindowMouse (vout_thread_t*,vout_window_mouse_event_t*)"
200558,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"static void ThreadChangeDisplayFilled(vout_thread_t *vout, bool is_filled)
{
    vout_SetDisplayFilled(vout->p->display.vd, is_filled);
}",1,1,video_output\video_output.c,ThreadChangeDisplayFilled,,false,1436,1439,ThreadChangeDisplayFilled,,,69,"void ThreadChangeDisplayFilled (vout_thread_t*,bool)"
200573,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"static void ThreadChangeZoom(vout_thread_t *vout, int num, int den)
{
    if (num * 10 < den) {
        num = den;
        den *= 10;
    } else if (num > den * 10) {
        num = den * 10;
    }

    vout_SetDisplayZoom(vout->p->display.vd, num, den);
}",1,1,video_output\video_output.c,ThreadChangeZoom,,false,1441,1451,ThreadChangeZoom,,,70,"void ThreadChangeZoom (vout_thread_t*,int,int)"
200617,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"static void ThreadChangeAspectRatio(vout_thread_t *vout,
                                    unsigned num, unsigned den)
{
    vout_SetDisplayAspect(vout->p->display.vd, num, den);
}",1,1,video_output\video_output.c,ThreadChangeAspectRatio,,false,1453,1457,ThreadChangeAspectRatio,,,71,"void ThreadChangeAspectRatio (vout_thread_t*,unsigned,unsigned)"
200634,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"static void ThreadExecuteCropWindow(vout_thread_t *vout,
                                    unsigned x, unsigned y,
                                    unsigned width, unsigned height)
{
    vout_SetDisplayCrop(vout->p->display.vd, 0, 0,
                        x, y, width, height);
}",1,1,video_output\video_output.c,ThreadExecuteCropWindow,,false,1460,1466,ThreadExecuteCropWindow,,,72,"void ThreadExecuteCropWindow (vout_thread_t*,unsigned,unsigned,unsigned,unsigned)"
200657,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"static void ThreadExecuteCropBorder(vout_thread_t *vout,
                                    unsigned left, unsigned top,
                                    unsigned right, unsigned bottom)
{
    msg_Dbg(vout, ""ThreadExecuteCropBorder %d.%d %dx%d"", left, top, right, bottom);
    vout_SetDisplayCrop(vout->p->display.vd, 0, 0,
                        left, top, -(int)right, -(int)bottom);
}",1,1,video_output\video_output.c,ThreadExecuteCropBorder,,false,1467,1474,ThreadExecuteCropBorder,,,73,"void ThreadExecuteCropBorder (vout_thread_t*,unsigned,unsigned,unsigned,unsigned)"
200693,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"static void ThreadExecuteCropRatio(vout_thread_t *vout,
                                   unsigned num, unsigned den)
{
    vout_SetDisplayCrop(vout->p->display.vd, num, den,
                        0, 0, 0, 0);
}",1,1,video_output\video_output.c,ThreadExecuteCropRatio,,false,1476,1481,ThreadExecuteCropRatio,,,74,"void ThreadExecuteCropRatio (vout_thread_t*,unsigned,unsigned)"
200714,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"static void ThreadExecuteViewpoint(vout_thread_t *vout,
                                   const vlc_viewpoint_t *p_viewpoint)
{
    vout_SetDisplayViewpoint(vout->p->display.vd, p_viewpoint);
}",1,1,video_output\video_output.c,ThreadExecuteViewpoint,,false,1483,1487,ThreadExecuteViewpoint,,,75,"void ThreadExecuteViewpoint (vout_thread_t*,vlc_viewpoint_t*)"
200729,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"static int ThreadStart(vout_thread_t *vout, vout_display_state_t *state)
{
    vlc_mouse_Init(&vout->p->mouse);
    vout->p->decoder_fifo = picture_fifo_New();
    vout->p->decoder_pool = NULL;
    vout->p->display_pool = NULL;
    vout->p->private_pool = NULL;

    vout->p->filter.configuration = NULL;
    video_format_Copy(&vout->p->filter.format, &vout->p->original);

    filter_owner_t owner = {
        .sys = vout,
        .video = {
            .buffer_new = VoutVideoFilterStaticNewPicture,
        },
    };
    vout->p->filter.chain_static =
        filter_chain_NewVideo( vout, true, &owner );

    owner.video.buffer_new = VoutVideoFilterInteractiveNewPicture;
    vout->p->filter.chain_interactive =
        filter_chain_NewVideo( vout, true, &owner );

    vout_display_state_t state_default;
    if (!state) {
        VoutGetDisplayCfg(vout, &state_default.cfg, vout->p->display.title);

#if defined(_WIN32) || defined(__OS2__)
        bool below = var_InheritBool(vout, ""video-w...",1,1,video_output\video_output.c,ThreadStart,,false,1489,1567,ThreadStart,,,76,"int ThreadStart (vout_thread_t*,vout_display_state_t*)"
201075,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"static void ThreadStop(vout_thread_t *vout, vout_display_state_t *state)
{
    if (vout->p->spu_blend)
        filter_DeleteBlend(vout->p->spu_blend);

    /* Destroy translation tables */
    if (vout->p->display.vd) {
        if (vout->p->decoder_pool) {
            ThreadFlush(vout, true, INT64_MAX);
            vout_EndWrapper(vout);
        }
        vout_CloseWrapper(vout, state);
    }

    /* Destroy the video filters */
    ThreadDelAllFilterCallbacks(vout);
    filter_chain_Delete(vout->p->filter.chain_interactive);
    filter_chain_Delete(vout->p->filter.chain_static);
    video_format_Clean(&vout->p->filter.format);
    free(vout->p->filter.configuration);

    if (vout->p->decoder_fifo)
        picture_fifo_Delete(vout->p->decoder_fifo);
    assert(!vout->p->decoder_pool);
}",1,1,video_output\video_output.c,ThreadStop,,false,1569,1593,ThreadStop,,,77,"void ThreadStop (vout_thread_t*,vout_display_state_t*)"
201174,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"static void ThreadInit(vout_thread_t *vout)
{
    vout->p->dead            = false;
    vout->p->is_late_dropped = var_InheritBool(vout, ""drop-late-frames"");
    vout->p->pause.is_on     = false;
    vout->p->pause.date      = VLC_TS_INVALID;

    vout_chrono_Init(&vout->p->render, 5, 10000); /* Arbitrary initial time */
}",1,1,video_output\video_output.c,ThreadInit,,false,1595,1603,ThreadInit,,,78,void ThreadInit (vout_thread_t*)
201222,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"static void ThreadClean(vout_thread_t *vout)
{
    vout_chrono_Clean(&vout->p->render);
    vout->p->dead = true;
    vout_control_Dead(&vout->p->control);
}",1,1,video_output\video_output.c,ThreadClean,,false,1605,1610,ThreadClean,,,79,void ThreadClean (vout_thread_t*)
201248,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"static int ThreadReinit(vout_thread_t *vout,
                        const vout_configuration_t *cfg)
{
    video_format_t original;

    vout->p->pause.is_on = false;
    vout->p->pause.date  = VLC_TS_INVALID;

    if (VoutValidateFormat(&original, cfg->fmt)) {
        ThreadStop(vout, NULL);
        ThreadClean(vout);
        return VLC_EGENERIC;
    }

    /* We ignore ar changes at this point, they are dynamically supported.
     * #19268: don't ignore crop changes (fix vouts using the crop size of the
     * previous format). */
    vout->p->original.i_sar_num = original.i_sar_num;
    vout->p->original.i_sar_den = original.i_sar_den;
    if (video_format_IsSimilar(&original, &vout->p->original)) {
        if (cfg->dpb_size <= vout->p->dpb_size) {
            video_format_Clean(&original);
            return VLC_SUCCESS;
        }
        msg_Warn(vout, ""DPB need to be increased"");
    }

    vout_display_state_t state;
    memset(&state, 0, sizeof(state));

    ThreadStop(vout...",1,1,video_output\video_output.c,ThreadReinit,,false,1612,1674,ThreadReinit,,,80,"int ThreadReinit (vout_thread_t*,vout_configuration_t*)"
201500,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"static void ThreadCancel(vout_thread_t *vout, bool canceled)
{
    picture_pool_Cancel(vout->p->decoder_pool, canceled);
}",1,1,video_output\video_output.c,ThreadCancel,,false,1676,1679,ThreadCancel,,,81,"void ThreadCancel (vout_thread_t*,bool)"
201513,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"static int ThreadControl(vout_thread_t *vout, vout_control_cmd_t cmd)
{
    switch(cmd.type) {
    case VOUT_CONTROL_INIT:
        ThreadInit(vout);
        if (ThreadStart(vout, NULL))
        {
            ThreadClean(vout);
            return 1;
        }
        break;
    case VOUT_CONTROL_CLEAN:
        ThreadStop(vout, NULL);
        ThreadClean(vout);
        return 1;
    case VOUT_CONTROL_REINIT:
        if (ThreadReinit(vout, cmd.u.cfg))
            return 1;
        break;
    case VOUT_CONTROL_CANCEL:
        ThreadCancel(vout, cmd.u.boolean);
        break;
    case VOUT_CONTROL_SUBPICTURE:
        ThreadDisplaySubpicture(vout, cmd.u.subpicture);
        cmd.u.subpicture = NULL;
        break;
    case VOUT_CONTROL_FLUSH_SUBPICTURE:
        ThreadFlushSubpicture(vout, cmd.u.integer);
        break;
    case VOUT_CONTROL_OSD_TITLE:
        ThreadDisplayOsdTitle(vout, cmd.u.string);
        break;
    case VOUT_CONTROL_CHANGE_FILTERS:
        ThreadChangeFilters(vout, NU...",1,1,video_output\video_output.c,ThreadControl,,false,1681,1780,ThreadControl,,,82,"int ThreadControl (vout_thread_t*,vout_control_cmd_t)"
201911,METHOD,video_output\video_output.c:<global>,TYPE_DECL,"static void *Thread(void *object)
{
    vout_thread_t *vout = object;
    vout_thread_sys_t *sys = vout->p;

    mtime_t deadline = VLC_TS_INVALID;
    bool wait = false;
    for (;;) {
        vout_control_cmd_t cmd;

        if (wait)
        {
            const mtime_t max_deadline = mdate() + 100000;
            deadline = deadline <= VLC_TS_INVALID ? max_deadline : __MIN(deadline, max_deadline);
        } else {
            deadline = VLC_TS_INVALID;
        }
        while (!vout_control_Pop(&sys->control, &cmd, deadline))
            if (ThreadControl(vout, cmd))
                return NULL;

        deadline = VLC_TS_INVALID;
        wait = ThreadDisplayPicture(vout, &deadline) != VLC_SUCCESS;

        const bool picture_interlaced = sys->displayed.is_interlaced;

        vout_SetInterlacingState(vout, picture_interlaced);
        vout_ManageWrapper(vout);
    }
}",1,1,video_output\video_output.c,Thread,,false,1789,1818,Thread,,,83,void* Thread (void*)
202016,METHOD,video_output\video_text.c:<global>,TYPE_DECL,<global>,1,2,video_output\video_text.c,video_output\video_text.c:<global>,,false,1,155,<global>,,,1,
202021,METHOD,video_output\video_text.c:<global>,TYPE_DECL,"static int OSDTextValidate(subpicture_t *subpic,
                           bool has_src_changed, const video_format_t *fmt_src,
                           bool has_dst_changed, const video_format_t *fmt_dst,
                           mtime_t ts)
{
    VLC_UNUSED(subpic); VLC_UNUSED(ts);
    VLC_UNUSED(fmt_src); VLC_UNUSED(has_src_changed);
    VLC_UNUSED(fmt_dst);

    if( !has_dst_changed )
        return VLC_SUCCESS;
    return VLC_EGENERIC;
}",1,1,video_output\video_text.c,OSDTextValidate,,false,39,51,OSDTextValidate,,,2,"int OSDTextValidate (subpicture_t*,bool,video_format_t*,bool,video_format_t*,mtime_t)"
202049,METHOD,video_output\video_text.c:<global>,TYPE_DECL,"static void OSDTextUpdate(subpicture_t *subpic,
                          const video_format_t *fmt_src,
                          const video_format_t *fmt_dst,
                          mtime_t ts)
{
    subpicture_updater_sys_t *sys = subpic->updater.p_sys;
    VLC_UNUSED(fmt_src); VLC_UNUSED(ts);

    if( fmt_dst->i_sar_num <= 0 || fmt_dst->i_sar_den <= 0 )
        return;

    subpic->b_absolute = false;
    subpic->i_original_picture_width  = fmt_dst->i_visible_width * fmt_dst->i_sar_num / fmt_dst->i_sar_den;
    subpic->i_original_picture_height = fmt_dst->i_visible_height;

    video_format_t fmt;
    video_format_Init( &fmt, VLC_CODEC_TEXT);
    fmt.i_sar_num = 1;
    fmt.i_sar_den = 1;

    subpicture_region_t *r = subpic->p_region = subpicture_region_New(&fmt);
    if (!r)
        return;

    r->p_text = text_segment_New( sys->text );

    const float margin_ratio = 0.04;
    const int   margin_h     = margin_ratio * fmt_dst->i_visible_width;
    const int   margin_v    ...",1,1,video_output\video_text.c,OSDTextUpdate,,false,53,96,OSDTextUpdate,,,3,"void OSDTextUpdate (subpicture_t*,video_format_t*,video_format_t*,mtime_t)"
202260,METHOD,video_output\video_text.c:<global>,TYPE_DECL,"static void OSDTextDestroy(subpicture_t *subpic)
{
    subpicture_updater_sys_t *sys = subpic->updater.p_sys;

    free(sys->text);
    free(sys);
}",1,1,video_output\video_text.c,OSDTextDestroy,,false,98,104,OSDTextDestroy,,,4,void OSDTextDestroy (subpicture_t*)
202279,METHOD,video_output\video_text.c:<global>,TYPE_DECL,"void vout_OSDText(vout_thread_t *vout, int channel,
                   int position, mtime_t duration, const char *text)
{
    assert( (position & ~SUBPICTURE_ALIGN_MASK) == 0);
    if (!var_InheritBool(vout, ""osd"") || duration <= 0)
        return;

    subpicture_updater_sys_t *sys = malloc(sizeof(*sys));
    if (!sys)
        return;
    sys->position = position;
    sys->text     = strdup(text);

    subpicture_updater_t updater = {
        .pf_validate = OSDTextValidate,
        .pf_update   = OSDTextUpdate,
        .pf_destroy  = OSDTextDestroy,
        .p_sys       = sys,
    };
    subpicture_t *subpic = subpicture_New(&updater);
    if (!subpic) {
        free(sys->text);
        free(sys);
        return;
    }

    subpic->i_channel  = channel;
    subpic->i_start    = mdate();
    subpic->i_stop     = subpic->i_start + duration;
    subpic->b_ephemer  = true;
    subpic->b_absolute = false;
    subpic->b_fade     = true;

    vout_PutSubpicture(vout, subpic);
}",1,1,video_output\video_text.c,vout_OSDText,,false,106,140,vout_OSDText,,,5,"void vout_OSDText (vout_thread_t*,int,int,mtime_t,char*)"
202403,METHOD,video_output\video_text.c:<global>,TYPE_DECL,"void vout_OSDMessage(vout_thread_t *vout, int channel, const char *format, ...)
{
    va_list args;
    va_start(args, format);

    char *string;
    if (vasprintf(&string, format, args) != -1) {
        vout_OSDText(vout, channel,
                     SUBPICTURE_ALIGN_TOP|SUBPICTURE_ALIGN_RIGHT, 1000000,
                     string);
        free(string);
    }
    va_end(args);
}",1,1,video_output\video_text.c,vout_OSDMessage,,false,142,155,vout_OSDMessage,,,6,"void vout_OSDMessage (vout_thread_t*,int,char*...)"
202454,METHOD,video_output\video_widgets.c:<global>,TYPE_DECL,<global>,1,1,video_output\video_widgets.c,video_output\video_widgets.c:<global>,,false,1,342,<global>,,,1,
202456,METHOD,video_output\video_widgets.c:<global>,TYPE_DECL,"static void DrawRect(subpicture_region_t *r, int fill, uint8_t color,
                     int x1, int y1, int x2, int y2)
{
    uint8_t *p    = r->p_picture->p->p_pixels;
    int     pitch = r->p_picture->p->i_pitch;
    if( x1 > x2 || y1 > y2 )
        return;

    if (fill == STYLE_FILLED) {
        if(x1 == 0 && x2 + 1 == r->p_picture->p->i_visible_pitch) {
            memset(&p[pitch * y1], color, pitch * (y2 - y1 + 1));
        } else {
            for (int y = y1; y <= y2; y++)
                memset(&p[x1 + pitch * y], color, x2 - x1 + 1);
        }
    } else {
        DrawRect(r, STYLE_FILLED, color, x1, y1, x1, y2);
        DrawRect(r, STYLE_FILLED, color, x2, y1, x2, y2);
        DrawRect(r, STYLE_FILLED, color, x1, y1, x2, y1);
        DrawRect(r, STYLE_FILLED, color, x1, y2, x2, y2);
    }
}",1,16,video_output\video_widgets.c,DrawRect,,false,63,84,DrawRect,,,1,"void DrawRect (subpicture_region_t*,int,uint8_t,int,int,int,int)"
202606,METHOD,video_output\video_widgets.c:<global>,TYPE_DECL,"static void DrawTriangle(subpicture_region_t *r, int fill, uint8_t color,
                         int x1, int y1, int x2, int y2)
{
    uint8_t *p    = r->p_picture->p->p_pixels;
    int     pitch = r->p_picture->p->i_pitch;
    const int mid = y1 + (y2 - y1) / 2;
    const bool b_swap = (x1 > x2);

    for (int y = y1; y <= mid; y++) {
        const int h = y - y1;
        if (fill == STYLE_FILLED) {
            const int w = b_swap ? __MAX(x1 - h, x2) : __MIN(x1 + h, x2);
            DrawRect(r, STYLE_FILLED, color,
                     (b_swap) ? w : x1, y, (b_swap) ? x1 : w, y);
            DrawRect(r, STYLE_FILLED, color,
                     (b_swap) ? w : x1, y2 - h, (b_swap) ? x1 : w, y2 - h);
        } else {
            p[x1 +                     pitch * y       ] = color;
            p[x1 + (b_swap ? -h : h) + pitch * y       ] = color;
            p[x1 +                     pitch * (y2 - h)] = color;
            p[x1 + (b_swap ? -h : h) + pitch * (y2 - h)] = color;
    ...",1,20,video_output\video_widgets.c,DrawTriangle,,false,90,113,DrawTriangle,,,2,"void DrawTriangle (subpicture_region_t*,int,uint8_t,int,int,int,int)"
202783,METHOD,video_output\video_widgets.c:<global>,TYPE_DECL,"static subpicture_region_t *OSDRegion(int x, int y, int width, int height)
{
    if( width == 0 || height == 0 )
        return NULL;

    video_palette_t palette;
    SET_PALETTE_COLOR(COL_WHITE,       0xffffff, STYLE_ALPHA_OPAQUE)
    SET_PALETTE_COLOR(COL_TRANSPARENT, 0xffffff, STYLE_ALPHA_TRANSPARENT)
    SET_PALETTE_COLOR(COL_FILL,        RGB_FILL, 0xA0)
    SET_PALETTE_COLOR(COL_FILL_SHADE,  RGB_FILL, 0x25)
    palette.i_entries = 4;

    video_format_t fmt;
    video_format_Init(&fmt, VLC_CODEC_YUVP);
    fmt.i_width          =
    fmt.i_visible_width  = width;
    fmt.i_height         =
    fmt.i_visible_height = height;
    fmt.i_sar_num        = 1;
    fmt.i_sar_den        = 1;
    fmt.p_palette        = &palette;

    subpicture_region_t *r = subpicture_region_New(&fmt);
    if (!r)
        return NULL;
    r->i_x = x;
    r->i_y = y;

    return r;
}",1,4,video_output\video_widgets.c,OSDRegion,,false,118,147,OSDRegion,,,3,"subpicture_region_t OSDRegion (int,int,int,int)"
203205,METHOD,video_output\video_widgets.c:<global>,TYPE_DECL,"static subpicture_region_t *OSDSlider(int type, int position,
                                      const video_format_t *fmt)
{
    const int size = __MAX(fmt->i_visible_width, fmt->i_visible_height);
    const int margin = size * SLIDER_MARGIN_BASE;
    const int marginbottom = margin * 0.2;
    const int marginright = margin * 0.5;
    uint8_t i_padding = __MIN(1, size * 0.25); /* small sizes */

    int x, y;
    int width, height;
    if (type == OSD_HOR_SLIDER) {
        width  = __MAX(fmt->i_visible_width - 2 * margin, 1);
        height = __MAX(fmt->i_visible_height * 0.01,      1);
        x      = __MIN(fmt->i_x_offset + margin, fmt->i_visible_width - width);
        y      = __MAX(fmt->i_y_offset + fmt->i_visible_height - marginbottom, 0);
    } else {
        width  = __MAX(fmt->i_visible_width * 0.010,       1);
        height = __MAX(fmt->i_visible_height - 2 * margin, 1);
        x      = __MAX(fmt->i_x_offset + fmt->i_visible_width - marginright, 0);
        y      =...",1,30,video_output\video_widgets.c,OSDSlider,,false,154,201,OSDSlider,,,4,"subpicture_region_t OSDSlider (int,int,video_format_t*)"
203473,METHOD,video_output\video_widgets.c:<global>,TYPE_DECL,"static subpicture_region_t *OSDIcon(int type, const video_format_t *fmt)
{
    const float size_ratio   = 0.05;
    const float margin_ratio = 0.07;

    const int size   = __MAX(fmt->i_visible_width, fmt->i_visible_height);
    const int width  = size * size_ratio;
    const int height = size * size_ratio;
    const int x      = fmt->i_x_offset + fmt->i_visible_width - margin_ratio * size - width;
    const int y      = fmt->i_y_offset                        + margin_ratio * size;

    if( width < 1 || height < 1 )
        return NULL;

    subpicture_region_t *r = OSDRegion(__MAX(x, 0),
                                       __MIN(y, (int)fmt->i_visible_height - height),
                                       width, height);
    if (!r)
        return NULL;

    DrawRect(r, STYLE_FILLED, COL_TRANSPARENT, 0, 0, width - 1, height - 1);

    if (type == OSD_PAUSE_ICON) {
        int bar_width = width / 3;
        DrawRect(r, STYLE_FILLED, COL_WHITE, 0, 0, bar_width - 1, height -1);
 ...",1,16,video_output\video_widgets.c,OSDIcon,,false,207,250,OSDIcon,,,5,"subpicture_region_t OSDIcon (int,video_format_t*)"
203779,METHOD,video_output\video_widgets.c:<global>,TYPE_DECL,"static int OSDWidgetValidate(subpicture_t *subpic,
                           bool has_src_changed, const video_format_t *fmt_src,
                           bool has_dst_changed, const video_format_t *fmt_dst,
                           mtime_t ts)
{
    VLC_UNUSED(subpic); VLC_UNUSED(ts);
    VLC_UNUSED(fmt_src); VLC_UNUSED(has_src_changed);
    VLC_UNUSED(fmt_dst);

    if (!has_dst_changed)
        return VLC_SUCCESS;
    return VLC_EGENERIC;
}",1,1,video_output\video_widgets.c,OSDWidgetValidate,,false,257,269,OSDWidgetValidate,,,7,"int OSDWidgetValidate (subpicture_t*,bool,video_format_t*,bool,video_format_t*,mtime_t)"
203807,METHOD,video_output\video_widgets.c:<global>,TYPE_DECL,"static void OSDWidgetUpdate(subpicture_t *subpic,
                          const video_format_t *fmt_src,
                          const video_format_t *fmt_dst,
                          mtime_t ts)
{
    subpicture_updater_sys_t *sys = subpic->updater.p_sys;
    VLC_UNUSED(fmt_src); VLC_UNUSED(ts);

    video_format_t fmt = *fmt_dst;
    fmt.i_width         = fmt.i_width         * fmt.i_sar_num / fmt.i_sar_den;
    fmt.i_visible_width = fmt.i_visible_width * fmt.i_sar_num / fmt.i_sar_den;
    fmt.i_x_offset      = fmt.i_x_offset      * fmt.i_sar_num / fmt.i_sar_den;
    fmt.i_sar_num       = 1;
    fmt.i_sar_den       = 1;

    subpic->i_original_picture_width  = fmt.i_visible_width;
    subpic->i_original_picture_height = fmt.i_visible_height;
    if (sys->type == OSD_HOR_SLIDER || sys->type == OSD_VERT_SLIDER)
        subpic->p_region = OSDSlider(sys->type, sys->position, &fmt);
    else
        subpic->p_region = OSDIcon(sys->type, &fmt);
}",1,1,video_output\video_widgets.c,OSDWidgetUpdate,,false,271,292,OSDWidgetUpdate,,,8,"void OSDWidgetUpdate (subpicture_t*,video_format_t*,video_format_t*,mtime_t)"
203939,METHOD,video_output\video_widgets.c:<global>,TYPE_DECL,"static void OSDWidgetDestroy(subpicture_t *subpic)
{
    free(subpic->updater.p_sys);
}",1,1,video_output\video_widgets.c,OSDWidgetDestroy,,false,294,297,OSDWidgetDestroy,,,9,void OSDWidgetDestroy (subpicture_t*)
203950,METHOD,video_output\video_widgets.c:<global>,TYPE_DECL,"static void OSDWidget(vout_thread_t *vout, int channel, int type, int position)
{
    if (!var_InheritBool(vout, ""osd""))
        return;
    if (type == OSD_HOR_SLIDER || type == OSD_VERT_SLIDER)
        position = VLC_CLIP(position, 0, 100);

    subpicture_updater_sys_t *sys = malloc(sizeof(*sys));
    if (!sys)
        return;
    sys->type     = type;
    sys->position = position;

    subpicture_updater_t updater = {
        .pf_validate = OSDWidgetValidate,
        .pf_update   = OSDWidgetUpdate,
        .pf_destroy  = OSDWidgetDestroy,
        .p_sys       = sys,
    };
    subpicture_t *subpic = subpicture_New(&updater);
    if (!subpic) {
        free(sys);
        return;
    }

    subpic->i_channel  = channel;
    subpic->i_start    = mdate();
    subpic->i_stop     = subpic->i_start + 1200000;
    subpic->b_ephemer  = true;
    subpic->b_absolute = true;
    subpic->b_fade     = true;

    vout_PutSubpicture(vout, subpic);
}",1,1,video_output\video_widgets.c,OSDWidget,,false,299,332,OSDWidget,,,10,"void OSDWidget (vout_thread_t*,int,int,int)"
204072,METHOD,video_output\video_widgets.c:<global>,TYPE_DECL,"void vout_OSDSlider(vout_thread_t *vout, int channel, int position, short type)
{
    OSDWidget(vout, channel, type, position);
}",1,1,video_output\video_widgets.c,vout_OSDSlider,,false,334,337,vout_OSDSlider,,,11,"void vout_OSDSlider (vout_thread_t*,int,int,short)"
204085,METHOD,video_output\video_widgets.c:<global>,TYPE_DECL,"void vout_OSDIcon(vout_thread_t *vout, int channel, short type )
{
    OSDWidget(vout, channel, type, 0);
}",1,1,video_output\video_widgets.c,vout_OSDIcon,,false,339,342,vout_OSDIcon,,,12,"void vout_OSDIcon (vout_thread_t*,int,short)"
204100,METHOD,video_output\vout_control.h:<global>,TYPE_DECL,<global>,1,6,video_output\vout_control.h,video_output\vout_control.h:<global>,,false,1,77,<global>,,,1,
204104,METHOD,video_output\vout_control.h:<global>,TYPE_DECL,"void vout_ChangePause( vout_thread_t *, bool b_paused, mtime_t i_date );",6,71,video_output\vout_control.h,vout_ChangePause,,false,34,34,vout_ChangePause,,,3,"void vout_ChangePause (vout_thread_t*,bool,mtime_t)"
204111,METHOD,video_output\vout_control.h:<global>,TYPE_DECL,"void spu_OffsetSubtitleDate( spu_t *p_spu, mtime_t i_duration );",6,63,video_output\vout_control.h,spu_OffsetSubtitleDate,,false,39,39,spu_OffsetSubtitleDate,,,4,"void spu_OffsetSubtitleDate (spu_t*,mtime_t)"
204117,METHOD,video_output\vout_control.h:<global>,TYPE_DECL,"void vout_GetResetStatistic( vout_thread_t *p_vout, unsigned *pi_displayed,
                             unsigned *pi_lost );",6,48,video_output\vout_control.h,vout_GetResetStatistic,,false,44,45,vout_GetResetStatistic,,,5,"void vout_GetResetStatistic (vout_thread_t*,unsigned*,unsigned*)"
204124,METHOD,video_output\vout_control.h:<global>,TYPE_DECL,"void vout_Flush( vout_thread_t *p_vout, mtime_t i_date );",6,56,video_output\vout_control.h,vout_Flush,,false,51,51,vout_Flush,,,6,"void vout_Flush (vout_thread_t*,mtime_t)"
204130,METHOD,video_output\vout_control.h:<global>,TYPE_DECL,"void vout_Cancel( vout_thread_t *p_vout, bool b_canceled );",6,58,video_output\vout_control.h,vout_Cancel,,false,57,57,vout_Cancel,,,7,"void vout_Cancel (vout_thread_t*,bool)"
204136,METHOD,video_output\vout_control.h:<global>,TYPE_DECL,"void vout_NextPicture( vout_thread_t *p_vout, mtime_t *pi_duration );",6,68,video_output\vout_control.h,vout_NextPicture,,false,62,62,vout_NextPicture,,,8,"void vout_NextPicture (vout_thread_t*,mtime_t*)"
204142,METHOD,video_output\vout_control.h:<global>,TYPE_DECL,"void vout_DisplayTitle( vout_thread_t *p_vout, const char *psz_title );",6,70,video_output\vout_control.h,vout_DisplayTitle,,false,67,67,vout_DisplayTitle,,,9,"void vout_DisplayTitle (vout_thread_t*,char*)"
204148,METHOD,video_output\vout_control.h:<global>,TYPE_DECL,"void vout_WindowMouseEvent( vout_thread_t *p_vout,
                            const vout_window_mouse_event_t *mouse );",6,68,video_output\vout_control.h,vout_WindowMouseEvent,,false,69,70,vout_WindowMouseEvent,,,10,"void vout_WindowMouseEvent (vout_thread_t*,vout_window_mouse_event_t*)"
204154,METHOD,video_output\vout_control.h:<global>,TYPE_DECL,bool vout_IsEmpty( vout_thread_t *p_vout );,6,42,video_output\vout_control.h,vout_IsEmpty,,false,75,75,vout_IsEmpty,,,11,bool vout_IsEmpty (vout_thread_t*)
204180,METHOD,video_output\vout_internal.h:<global>,TYPE_DECL,<global>,1,30,video_output\vout_internal.h,video_output\vout_internal.h:<global>,,false,1,172,<global>,,,1,
204244,METHOD,video_output\vout_internal.h:<global>,TYPE_DECL,"void vout_ControlChangeFullscreen(vout_thread_t *, bool fullscreen);",6,67,video_output\vout_internal.h,vout_ControlChangeFullscreen,,false,142,142,vout_ControlChangeFullscreen,,,2,"void vout_ControlChangeFullscreen (vout_thread_t*,bool)"
204250,METHOD,video_output\vout_internal.h:<global>,TYPE_DECL,"void vout_ControlChangeWindowState(vout_thread_t *, unsigned state);",6,67,video_output\vout_internal.h,vout_ControlChangeWindowState,,false,143,143,vout_ControlChangeWindowState,,,3,"void vout_ControlChangeWindowState (vout_thread_t*,unsigned)"
204256,METHOD,video_output\vout_internal.h:<global>,TYPE_DECL,"void vout_ControlChangeDisplayFilled(vout_thread_t *, bool is_filled);",6,69,video_output\vout_internal.h,vout_ControlChangeDisplayFilled,,false,144,144,vout_ControlChangeDisplayFilled,,,4,"void vout_ControlChangeDisplayFilled (vout_thread_t*,bool)"
204262,METHOD,video_output\vout_internal.h:<global>,TYPE_DECL,"void vout_ControlChangeZoom(vout_thread_t *, int num, int den);",6,62,video_output\vout_internal.h,vout_ControlChangeZoom,,false,145,145,vout_ControlChangeZoom,,,5,"void vout_ControlChangeZoom (vout_thread_t*,int,int)"
204269,METHOD,video_output\vout_internal.h:<global>,TYPE_DECL,"void vout_ControlChangeSampleAspectRatio(vout_thread_t *, unsigned num, unsigned den);",6,85,video_output\vout_internal.h,vout_ControlChangeSampleAspectRatio,,false,146,146,vout_ControlChangeSampleAspectRatio,,,6,"void vout_ControlChangeSampleAspectRatio (vout_thread_t*,unsigned,unsigned)"
204276,METHOD,video_output\vout_internal.h:<global>,TYPE_DECL,"void vout_ControlChangeCropRatio(vout_thread_t *, unsigned num, unsigned den);",6,77,video_output\vout_internal.h,vout_ControlChangeCropRatio,,false,147,147,vout_ControlChangeCropRatio,,,7,"void vout_ControlChangeCropRatio (vout_thread_t*,unsigned,unsigned)"
204283,METHOD,video_output\vout_internal.h:<global>,TYPE_DECL,"void vout_ControlChangeCropWindow(vout_thread_t *, int x, int y, int width, int height);",6,87,video_output\vout_internal.h,vout_ControlChangeCropWindow,,false,148,148,vout_ControlChangeCropWindow,,,8,"void vout_ControlChangeCropWindow (vout_thread_t*,int,int,int,int)"
204292,METHOD,video_output\vout_internal.h:<global>,TYPE_DECL,"void vout_ControlChangeCropBorder(vout_thread_t *, int left, int top, int right, int bottom);",6,92,video_output\vout_internal.h,vout_ControlChangeCropBorder,,false,149,149,vout_ControlChangeCropBorder,,,9,"void vout_ControlChangeCropBorder (vout_thread_t*,int,int,int,int)"
204301,METHOD,video_output\vout_internal.h:<global>,TYPE_DECL,"void vout_ControlChangeFilters(vout_thread_t *, const char *);",6,61,video_output\vout_internal.h,vout_ControlChangeFilters,,false,150,150,vout_ControlChangeFilters,,,10,"void vout_ControlChangeFilters (vout_thread_t*,char*)"
204307,METHOD,video_output\vout_internal.h:<global>,TYPE_DECL,"void vout_ControlChangeSubSources(vout_thread_t *, const char *);",6,64,video_output\vout_internal.h,vout_ControlChangeSubSources,,false,151,151,vout_ControlChangeSubSources,,,11,"void vout_ControlChangeSubSources (vout_thread_t*,char*)"
204313,METHOD,video_output\vout_internal.h:<global>,TYPE_DECL,"void vout_ControlChangeSubFilters(vout_thread_t *, const char *);",6,64,video_output\vout_internal.h,vout_ControlChangeSubFilters,,false,152,152,vout_ControlChangeSubFilters,,,12,"void vout_ControlChangeSubFilters (vout_thread_t*,char*)"
204319,METHOD,video_output\vout_internal.h:<global>,TYPE_DECL,"void vout_ControlChangeSubMargin(vout_thread_t *, int);",6,54,video_output\vout_internal.h,vout_ControlChangeSubMargin,,false,153,153,vout_ControlChangeSubMargin,,,13,"void vout_ControlChangeSubMargin (vout_thread_t*,int)"
204325,METHOD,video_output\vout_internal.h:<global>,TYPE_DECL,"void vout_ControlChangeViewpoint( vout_thread_t *, const vlc_viewpoint_t *);",6,75,video_output\vout_internal.h,vout_ControlChangeViewpoint,,false,154,154,vout_ControlChangeViewpoint,,,14,"void vout_ControlChangeViewpoint (vout_thread_t*,vlc_viewpoint_t*)"
204331,METHOD,video_output\vout_internal.h:<global>,TYPE_DECL,void vout_IntfInit( vout_thread_t * );,6,37,video_output\vout_internal.h,vout_IntfInit,,false,157,157,vout_IntfInit,,,15,void vout_IntfInit (vout_thread_t*)
204336,METHOD,video_output\vout_internal.h:<global>,TYPE_DECL,void vout_IntfReinit( vout_thread_t * );,6,39,video_output\vout_internal.h,vout_IntfReinit,,false,158,158,vout_IntfReinit,,,16,void vout_IntfReinit (vout_thread_t*)
204341,METHOD,video_output\vout_internal.h:<global>,TYPE_DECL,"int  vout_OpenWrapper (vout_thread_t *, const char *, const vout_display_state_t *);",6,83,video_output\vout_internal.h,vout_OpenWrapper,,false,161,161,vout_OpenWrapper,,,17,"int vout_OpenWrapper (vout_thread_t*,char*,vout_display_state_t*)"
204348,METHOD,video_output\vout_internal.h:<global>,TYPE_DECL,"void vout_CloseWrapper(vout_thread_t *, vout_display_state_t *);",6,63,video_output\vout_internal.h,vout_CloseWrapper,,false,162,162,vout_CloseWrapper,,,18,"void vout_CloseWrapper (vout_thread_t*,vout_display_state_t*)"
204354,METHOD,video_output\vout_internal.h:<global>,TYPE_DECL,int  vout_InitWrapper(vout_thread_t *);,6,38,video_output\vout_internal.h,vout_InitWrapper,,false,163,163,vout_InitWrapper,,,19,int vout_InitWrapper (vout_thread_t*)
204359,METHOD,video_output\vout_internal.h:<global>,TYPE_DECL,void vout_EndWrapper(vout_thread_t *);,6,37,video_output\vout_internal.h,vout_EndWrapper,,false,164,164,vout_EndWrapper,,,20,void vout_EndWrapper (vout_thread_t*)
204364,METHOD,video_output\vout_internal.h:<global>,TYPE_DECL,void vout_ManageWrapper(vout_thread_t *);,6,40,video_output\vout_internal.h,vout_ManageWrapper,,false,165,165,vout_ManageWrapper,,,21,void vout_ManageWrapper (vout_thread_t*)
204369,METHOD,video_output\vout_internal.h:<global>,TYPE_DECL,"int spu_ProcessMouse(spu_t *, const vlc_mouse_t *, const video_format_t *);",5,74,video_output\vout_internal.h,spu_ProcessMouse,,false,168,168,spu_ProcessMouse,,,22,"int spu_ProcessMouse (spu_t*,vlc_mouse_t*,video_format_t*)"
204376,METHOD,video_output\vout_internal.h:<global>,TYPE_DECL,"void spu_Attach( spu_t *, vlc_object_t *input, bool );",6,53,video_output\vout_internal.h,spu_Attach,,false,169,169,spu_Attach,,,23,"void spu_Attach (spu_t*,vlc_object_t*,ANY)"
204383,METHOD,video_output\vout_internal.h:<global>,TYPE_DECL,"void spu_ChangeMargin(spu_t *, int);",6,35,video_output\vout_internal.h,spu_ChangeMargin,,false,170,170,spu_ChangeMargin,,,24,"void spu_ChangeMargin (spu_t*,int)"
204416,METHOD,video_output\vout_intf.c:<global>,TYPE_DECL,<global>,1,25,video_output\vout_intf.c,video_output\vout_intf.c:<global>,,false,1,618,<global>,,,1,
204418,METHOD,video_output\vout_intf.c:<global>,TYPE_DECL,"static int CropCallback( vlc_object_t *, char const *,
                         vlc_value_t, vlc_value_t, void * );",12,59,video_output\vout_intf.c,CropCallback,,false,50,51,CropCallback,,,1,"int CropCallback (vlc_object_t*,char*,ANY,ANY,void*)"
204427,METHOD,video_output\vout_intf.c:<global>,TYPE_DECL,"static int CropBorderCallback( vlc_object_t *, char const *,
                               vlc_value_t, vlc_value_t, void * );",12,65,video_output\vout_intf.c,CropBorderCallback,,false,52,53,CropBorderCallback,,,2,"int CropBorderCallback (vlc_object_t*,char*,ANY,ANY,void*)"
204436,METHOD,video_output\vout_intf.c:<global>,TYPE_DECL,"static int AspectCallback( vlc_object_t *, char const *,
                           vlc_value_t, vlc_value_t, void * );",12,61,video_output\vout_intf.c,AspectCallback,,false,54,55,AspectCallback,,,3,"int AspectCallback (vlc_object_t*,char*,ANY,ANY,void*)"
204445,METHOD,video_output\vout_intf.c:<global>,TYPE_DECL,"static int AutoScaleCallback( vlc_object_t *, char const *,
                              vlc_value_t, vlc_value_t, void * );",12,64,video_output\vout_intf.c,AutoScaleCallback,,false,56,57,AutoScaleCallback,,,4,"int AutoScaleCallback (vlc_object_t*,char*,ANY,ANY,void*)"
204454,METHOD,video_output\vout_intf.c:<global>,TYPE_DECL,"static int ZoomCallback( vlc_object_t *, char const *,
                         vlc_value_t, vlc_value_t, void * );",12,59,video_output\vout_intf.c,ZoomCallback,,false,58,59,ZoomCallback,,,5,"int ZoomCallback (vlc_object_t*,char*,ANY,ANY,void*)"
204463,METHOD,video_output\vout_intf.c:<global>,TYPE_DECL,"static int AboveCallback( vlc_object_t *, char const *,
                          vlc_value_t, vlc_value_t, void * );",12,60,video_output\vout_intf.c,AboveCallback,,false,60,61,AboveCallback,,,6,"int AboveCallback (vlc_object_t*,char*,ANY,ANY,void*)"
204472,METHOD,video_output\vout_intf.c:<global>,TYPE_DECL,"static int WallPaperCallback( vlc_object_t *, char const *,
                              vlc_value_t, vlc_value_t, void * );",12,64,video_output\vout_intf.c,WallPaperCallback,,false,62,63,WallPaperCallback,,,7,"int WallPaperCallback (vlc_object_t*,char*,ANY,ANY,void*)"
204481,METHOD,video_output\vout_intf.c:<global>,TYPE_DECL,"static int FullscreenCallback( vlc_object_t *, char const *,
                               vlc_value_t, vlc_value_t, void * );",12,65,video_output\vout_intf.c,FullscreenCallback,,false,64,65,FullscreenCallback,,,8,"int FullscreenCallback (vlc_object_t*,char*,ANY,ANY,void*)"
204490,METHOD,video_output\vout_intf.c:<global>,TYPE_DECL,"static int SnapshotCallback( vlc_object_t *, char const *,
                             vlc_value_t, vlc_value_t, void * );",12,63,video_output\vout_intf.c,SnapshotCallback,,false,66,67,SnapshotCallback,,,9,"int SnapshotCallback (vlc_object_t*,char*,ANY,ANY,void*)"
204499,METHOD,video_output\vout_intf.c:<global>,TYPE_DECL,"static int VideoFilterCallback( vlc_object_t *, char const *,
                                vlc_value_t, vlc_value_t, void * );",12,66,video_output\vout_intf.c,VideoFilterCallback,,false,68,69,VideoFilterCallback,,,10,"int VideoFilterCallback (vlc_object_t*,char*,ANY,ANY,void*)"
204508,METHOD,video_output\vout_intf.c:<global>,TYPE_DECL,"static int SubSourceCallback( vlc_object_t *, char const *,
                              vlc_value_t, vlc_value_t, void * );",12,64,video_output\vout_intf.c,SubSourceCallback,,false,70,71,SubSourceCallback,,,11,"int SubSourceCallback (vlc_object_t*,char*,ANY,ANY,void*)"
204517,METHOD,video_output\vout_intf.c:<global>,TYPE_DECL,"static int SubFilterCallback( vlc_object_t *, char const *,
                              vlc_value_t, vlc_value_t, void * );",12,64,video_output\vout_intf.c,SubFilterCallback,,false,72,73,SubFilterCallback,,,12,"int SubFilterCallback (vlc_object_t*,char*,ANY,ANY,void*)"
204526,METHOD,video_output\vout_intf.c:<global>,TYPE_DECL,"static int SubMarginCallback( vlc_object_t *, char const *,
                              vlc_value_t, vlc_value_t, void * );",12,64,video_output\vout_intf.c,SubMarginCallback,,false,74,75,SubMarginCallback,,,13,"int SubMarginCallback (vlc_object_t*,char*,ANY,ANY,void*)"
204535,METHOD,video_output\vout_intf.c:<global>,TYPE_DECL,"static int ViewpointCallback( vlc_object_t *, char const *,
                              vlc_value_t, vlc_value_t, void * );",12,64,video_output\vout_intf.c,ViewpointCallback,,false,76,77,ViewpointCallback,,,14,"int ViewpointCallback (vlc_object_t*,char*,ANY,ANY,void*)"
204547,METHOD,<empty>,<empty>,<empty>,1,,video_output\vout_intf.c,p_zoom_values:<clinit>,,false,82,,<clinit>,,,3,
204576,METHOD,<empty>,<empty>,<empty>,1,,video_output\vout_intf.c,p_crop_values:<clinit>,,false,93,,<clinit>,,,3,
204625,METHOD,<empty>,<empty>,<empty>,1,,video_output\vout_intf.c,p_aspect_ratio_values:<clinit>,,false,111,,<clinit>,,,3,
204665,METHOD,video_output\vout_intf.c:<global>,TYPE_DECL,"static void AddCustomRatios( vout_thread_t *p_vout, const char *psz_var,
                             char *psz_list )
{
    assert( psz_list );

    char *psz_cur = psz_list;
    char *psz_next;
    while( psz_cur && *psz_cur )
    {
        vlc_value_t val, text;
        psz_next = strchr( psz_cur, ',' );
        if( psz_next )
        {
            *psz_next = '\0';
            psz_next++;
        }
        val.psz_string = psz_cur;
        text.psz_string = psz_cur;
        var_Change( p_vout, psz_var, VLC_VAR_ADDCHOICE, &val, &text);
        psz_cur = psz_next;
    }
}",1,1,video_output\vout_intf.c,AddCustomRatios,,false,127,148,AddCustomRatios,,,24,"void AddCustomRatios (vout_thread_t*,char*,char*)"
204722,METHOD,video_output\vout_intf.c:<global>,TYPE_DECL,"void vout_IntfInit( vout_thread_t *p_vout )
{
    vlc_value_t val, text;
    char *psz_buf;

    /* Create a few object variables we'll need later on */
    var_Create( p_vout, ""snapshot-num"", VLC_VAR_INTEGER );
    var_SetInteger( p_vout, ""snapshot-num"", 1 );

    var_Create( p_vout, ""width"", VLC_VAR_INTEGER | VLC_VAR_DOINHERIT );
    var_Create( p_vout, ""height"", VLC_VAR_INTEGER | VLC_VAR_DOINHERIT );
    var_Create( p_vout, ""align"", VLC_VAR_INTEGER | VLC_VAR_DOINHERIT );

    var_Create( p_vout, ""mouse-hide-timeout"",
                VLC_VAR_INTEGER | VLC_VAR_DOINHERIT );

    /* Add variables to manage scaling video */
    var_Create( p_vout, ""autoscale"", VLC_VAR_BOOL | VLC_VAR_DOINHERIT
                | VLC_VAR_ISCOMMAND );
    text.psz_string = _(""Autoscale video"");
    var_Change( p_vout, ""autoscale"", VLC_VAR_SETTEXT, &text, NULL );
    var_AddCallback( p_vout, ""autoscale"", AutoScaleCallback, NULL );

    var_Create( p_vout, ""zoom"", VLC_VAR_FLOAT | VLC_VAR_ISCOMMAND |
       ...",1,1,video_output\vout_intf.c,vout_IntfInit,,false,150,312,vout_IntfInit,,,25,void vout_IntfInit (vout_thread_t*)
205248,METHOD,video_output\vout_intf.c:<global>,TYPE_DECL,"void vout_IntfReinit( vout_thread_t *p_vout )
{
    var_TriggerCallback( p_vout, ""zoom"" );
    var_TriggerCallback( p_vout, ""crop"" );
    var_TriggerCallback( p_vout, ""aspect-ratio"" );

    var_TriggerCallback( p_vout, ""video-on-top"" );
    var_TriggerCallback( p_vout, ""video-wallpaper"" );

    var_TriggerCallback( p_vout, ""video-filter"" );
    var_TriggerCallback( p_vout, ""sub-source"" );
    var_TriggerCallback( p_vout, ""sub-filter"" );
    var_TriggerCallback( p_vout, ""sub-margin"" );
}",1,1,video_output\vout_intf.c,vout_IntfReinit,,false,314,327,vout_IntfReinit,,,26,void vout_IntfReinit (vout_thread_t*)
205280,METHOD,video_output\vout_intf.c:<global>,TYPE_DECL,"static int VoutSnapshotPip( vout_thread_t *p_vout, picture_t *p_pic )
{
    subpicture_t *p_subpic = subpicture_NewFromPicture( VLC_OBJECT(p_vout),
                                                        p_pic, VLC_CODEC_YUVA );
    if( !p_subpic )
        return VLC_EGENERIC;

    /* FIXME SPU_DEFAULT_CHANNEL is not good (used by the text) but
     * hardcoded 0 doesn't seem right */
    p_subpic->i_channel = 0;
    p_subpic->i_start = mdate();
    p_subpic->i_stop  = p_subpic->i_start + 4000000;
    p_subpic->b_ephemer = true;
    p_subpic->b_fade = true;

    /* Reduce the picture to 1/4^2 of the screen */
    p_subpic->i_original_picture_width  *= 4;
    p_subpic->i_original_picture_height *= 4;

    vout_PutSubpicture( p_vout, p_subpic );
    return VLC_SUCCESS;
}",1,1,video_output\vout_intf.c,VoutSnapshotPip,,false,336,357,VoutSnapshotPip,,,27,"int VoutSnapshotPip (vout_thread_t*,picture_t*)"
205344,METHOD,video_output\vout_intf.c:<global>,TYPE_DECL,"static void VoutOsdSnapshot( vout_thread_t *p_vout, picture_t *p_pic, const char *psz_filename )
{
    msg_Dbg( p_vout, ""snapshot taken (%s)"", psz_filename );
    vout_OSDMessage( p_vout, VOUT_SPU_CHANNEL_OSD, ""%s"", psz_filename );

    if( var_InheritBool( p_vout, ""snapshot-preview"" ) )
    {
        if( VoutSnapshotPip( p_vout, p_pic ) )
            msg_Warn( p_vout, ""Failed to display snapshot"" );
    }
}",1,1,video_output\vout_intf.c,VoutOsdSnapshot,,false,362,372,VoutOsdSnapshot,,,28,"void VoutOsdSnapshot (vout_thread_t*,picture_t*,char*)"
205373,METHOD,video_output\vout_intf.c:<global>,TYPE_DECL,"static void VoutSaveSnapshot( vout_thread_t *p_vout )
{
    char *psz_path = var_InheritString( p_vout, ""snapshot-path"" );
    char *psz_format = var_InheritString( p_vout, ""snapshot-format"" );
    char *psz_prefix = var_InheritString( p_vout, ""snapshot-prefix"" );

    /* */
    picture_t *p_picture;
    block_t *p_image;

    /* 500ms timeout
     * XXX it will cause trouble with low fps video (< 2fps) */
    if( vout_GetSnapshot( p_vout, &p_image, &p_picture, NULL, psz_format, 500*1000 ) )
    {
        p_picture = NULL;
        p_image = NULL;
        goto exit;
    }

    if( !psz_path )
    {
        psz_path = vout_snapshot_GetDirectory();
        if( !psz_path )
        {
            msg_Err( p_vout, ""no path specified for snapshots"" );
            goto exit;
        }
    }

    vout_snapshot_save_cfg_t cfg;
    memset( &cfg, 0, sizeof(cfg) );
    cfg.is_sequential = var_InheritBool( p_vout, ""snapshot-sequential"" );
    cfg.sequence = var_GetInteger( p_vout, ""snapshot-num"" )...",1,1,video_output\vout_intf.c,VoutSaveSnapshot,,false,377,437,VoutSaveSnapshot,,,29,void VoutSaveSnapshot (vout_thread_t*)
205525,METHOD,video_output\vout_intf.c:<global>,TYPE_DECL,"static int CropCallback( vlc_object_t *object, char const *cmd,
                         vlc_value_t oldval, vlc_value_t newval, void *data )
{
    vout_thread_t *vout = (vout_thread_t *)object;
    VLC_UNUSED(cmd); VLC_UNUSED(oldval); VLC_UNUSED(data);
    unsigned num, den;
    unsigned y, x;
    unsigned width, height;
    unsigned left, top, right, bottom;

    if (sscanf(newval.psz_string, ""%u:%u"", &num, &den) == 2) {
        vout_ControlChangeCropRatio(vout, num, den);
    } else if (sscanf(newval.psz_string, ""%ux%u+%u+%u"",
                      &width, &height, &x, &y) == 4) {
        vout_ControlChangeCropWindow(vout, x, y, width, height);
    } else if (sscanf(newval.psz_string, ""%u+%u+%u+%u"",
                    &left, &top, &right, &bottom) == 4) {
        vout_ControlChangeCropBorder(vout, left, top, right, bottom);
    } else if (*newval.psz_string == '\0') {
        vout_ControlChangeCropRatio(vout, 0, 0);
    } else {
        msg_Err(object, ""Unknown crop format (%s)""...",1,1,video_output\vout_intf.c,CropCallback,,false,442,466,CropCallback,,,30,"int CropCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
205647,METHOD,video_output\vout_intf.c:<global>,TYPE_DECL,"static int CropBorderCallback(vlc_object_t *object, char const *cmd,
                              vlc_value_t oldval, vlc_value_t newval, void *data)
{
    char buf[4 * 21];

    snprintf(buf, sizeof (buf), ""%""PRIu64""+%""PRIu64""+%""PRIu64""+%""PRIu64,
             var_GetInteger(object, ""crop-left""),
             var_GetInteger(object, ""crop-top""),
             var_GetInteger(object, ""crop-right""),
             var_GetInteger(object, ""crop-bottom""));
    var_SetString(object, ""crop"", buf);

    VLC_UNUSED(cmd); VLC_UNUSED(oldval); VLC_UNUSED(data); VLC_UNUSED(newval);
    return VLC_SUCCESS;
}",1,1,video_output\vout_intf.c,CropBorderCallback,,false,468,482,CropBorderCallback,,,31,"int CropBorderCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
205672,METHOD,video_output\vout_intf.c:<global>,TYPE_DECL,"static int AspectCallback( vlc_object_t *object, char const *cmd,
                         vlc_value_t oldval, vlc_value_t newval, void *data )
{
    vout_thread_t *vout = (vout_thread_t *)object;
    VLC_UNUSED(cmd); VLC_UNUSED(oldval); VLC_UNUSED(data);
    unsigned num, den;

    if (sscanf(newval.psz_string, ""%u:%u"", &num, &den) == 2 &&
        (num != 0) == (den != 0))
        vout_ControlChangeSampleAspectRatio(vout, num, den);
    else if (*newval.psz_string == '\0')
        vout_ControlChangeSampleAspectRatio(vout, 0, 0);
    return VLC_SUCCESS;
}",1,1,video_output\vout_intf.c,AspectCallback,,false,484,497,AspectCallback,,,32,"int AspectCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
205736,METHOD,video_output\vout_intf.c:<global>,TYPE_DECL,"static int AutoScaleCallback( vlc_object_t *obj, char const *name,
                              vlc_value_t prev, vlc_value_t cur, void *data )
{
    vout_thread_t *p_vout = (vout_thread_t *)obj;

    (void) name; (void) prev; (void) data;
    vout_ControlChangeDisplayFilled( p_vout, cur.b_bool );
    return VLC_SUCCESS;
}",1,1,video_output\vout_intf.c,AutoScaleCallback,,false,499,507,AutoScaleCallback,,,33,"int AutoScaleCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
205767,METHOD,video_output\vout_intf.c:<global>,TYPE_DECL,"static int ZoomCallback( vlc_object_t *obj, char const *name,
                         vlc_value_t prev, vlc_value_t cur, void *data )
{
    vout_thread_t *p_vout = (vout_thread_t *)obj;

    (void) name; (void) prev; (void) data;
    vout_ControlChangeZoom( p_vout, 1000 * cur.f_float, 1000 );
    return VLC_SUCCESS;
}",1,1,video_output\vout_intf.c,ZoomCallback,,false,509,517,ZoomCallback,,,34,"int ZoomCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
205801,METHOD,video_output\vout_intf.c:<global>,TYPE_DECL,"static int AboveCallback( vlc_object_t *obj, char const *name,
                          vlc_value_t prev, vlc_value_t cur, void *data )
{
    vout_ControlChangeWindowState( (vout_thread_t *)obj,
        cur.b_bool ? VOUT_WINDOW_STATE_ABOVE : VOUT_WINDOW_STATE_NORMAL );
    (void) name; (void) prev; (void) data;
    return VLC_SUCCESS;
}",1,1,video_output\vout_intf.c,AboveCallback,,false,519,526,AboveCallback,,,35,"int AboveCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
205831,METHOD,video_output\vout_intf.c:<global>,TYPE_DECL,"static int WallPaperCallback( vlc_object_t *obj, char const *name,
                              vlc_value_t prev, vlc_value_t cur, void *data )
{
    vout_thread_t *vout = (vout_thread_t *)obj;

    if( cur.b_bool )
    {
        vout_ControlChangeWindowState( vout, VOUT_WINDOW_STATE_BELOW );
        vout_ControlChangeFullscreen( vout, true );
    }
    else
    {
        var_TriggerCallback( obj, ""fullscreen"" );
        var_TriggerCallback( obj, ""video-on-top"" );
    }
    (void) name; (void) prev; (void) data;
    return VLC_SUCCESS;
}",1,1,video_output\vout_intf.c,WallPaperCallback,,false,528,545,WallPaperCallback,,,36,"int WallPaperCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
205876,METHOD,video_output\vout_intf.c:<global>,TYPE_DECL,"static int FullscreenCallback( vlc_object_t *p_this, char const *psz_cmd,
                       vlc_value_t oldval, vlc_value_t newval, void *p_data )
{
    vout_thread_t *p_vout = (vout_thread_t *)p_this;
    (void)psz_cmd; (void)p_data;

    if( oldval.b_bool != newval.b_bool )
        vout_ControlChangeFullscreen( p_vout, newval.b_bool );
    return VLC_SUCCESS;
}",1,1,video_output\vout_intf.c,FullscreenCallback,,false,547,556,FullscreenCallback,,,37,"int FullscreenCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
205913,METHOD,video_output\vout_intf.c:<global>,TYPE_DECL,"static int SnapshotCallback( vlc_object_t *p_this, char const *psz_cmd,
                       vlc_value_t oldval, vlc_value_t newval, void *p_data )
{
    vout_thread_t *p_vout = (vout_thread_t *)p_this;
    VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval);
    VLC_UNUSED(newval); VLC_UNUSED(p_data);

    VoutSaveSnapshot( p_vout );
    return VLC_SUCCESS;
}",1,1,video_output\vout_intf.c,SnapshotCallback,,false,558,567,SnapshotCallback,,,38,"int SnapshotCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
205940,METHOD,video_output\vout_intf.c:<global>,TYPE_DECL,"static int VideoFilterCallback( vlc_object_t *p_this, char const *psz_cmd,
                                vlc_value_t oldval, vlc_value_t newval, void *p_data)
{
    vout_thread_t *p_vout = (vout_thread_t *)p_this;
    VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval); VLC_UNUSED(p_data);

    vout_ControlChangeFilters( p_vout, newval.psz_string );
    return VLC_SUCCESS;
}",1,1,video_output\vout_intf.c,VideoFilterCallback,,false,569,577,VideoFilterCallback,,,39,"int VideoFilterCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
205968,METHOD,video_output\vout_intf.c:<global>,TYPE_DECL,"static int SubSourceCallback( vlc_object_t *p_this, char const *psz_cmd,
                              vlc_value_t oldval, vlc_value_t newval, void *p_data)
{
    vout_thread_t *p_vout = (vout_thread_t *)p_this;
    VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval); VLC_UNUSED(p_data);

    vout_ControlChangeSubSources( p_vout, newval.psz_string );
    return VLC_SUCCESS;
}",1,1,video_output\vout_intf.c,SubSourceCallback,,false,579,587,SubSourceCallback,,,40,"int SubSourceCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
205996,METHOD,video_output\vout_intf.c:<global>,TYPE_DECL,"static int SubFilterCallback( vlc_object_t *p_this, char const *psz_cmd,
                              vlc_value_t oldval, vlc_value_t newval, void *p_data)
{
    vout_thread_t *p_vout = (vout_thread_t *)p_this;
    VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval); VLC_UNUSED(p_data);

    vout_ControlChangeSubFilters( p_vout, newval.psz_string );
    return VLC_SUCCESS;
}",1,1,video_output\vout_intf.c,SubFilterCallback,,false,589,597,SubFilterCallback,,,41,"int SubFilterCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
206024,METHOD,video_output\vout_intf.c:<global>,TYPE_DECL,"static int SubMarginCallback( vlc_object_t *p_this, char const *psz_cmd,
                              vlc_value_t oldval, vlc_value_t newval, void *p_data)
{
    vout_thread_t *p_vout = (vout_thread_t *)p_this;
    VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval); VLC_UNUSED(p_data);

    vout_ControlChangeSubMargin( p_vout, newval.i_int );
    return VLC_SUCCESS;
}",1,1,video_output\vout_intf.c,SubMarginCallback,,false,599,607,SubMarginCallback,,,42,"int SubMarginCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
206052,METHOD,video_output\vout_intf.c:<global>,TYPE_DECL,"static int ViewpointCallback( vlc_object_t *p_this, char const *psz_cmd,
                              vlc_value_t oldval, vlc_value_t newval, void *p_data)
{
    vout_thread_t *p_vout = (vout_thread_t *)p_this;
    VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval); VLC_UNUSED(p_data);

    if( newval.p_address != NULL )
        vout_ControlChangeViewpoint( p_vout, newval.p_address );
    return VLC_SUCCESS;
}",1,1,video_output\vout_intf.c,ViewpointCallback,,false,609,618,ViewpointCallback,,,43,"int ViewpointCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
206092,METHOD,video_output\vout_spuregion_helper.h:<global>,TYPE_DECL,<global>,1,29,video_output\vout_spuregion_helper.h,video_output\vout_spuregion_helper.h:<global>,,false,1,94,<global>,,,1,
206094,METHOD,video_output\vout_spuregion_helper.h:<global>,TYPE_DECL,"static inline void
spuregion_CreateVGradientPalette( video_palette_t *p_palette, uint8_t i_splits,
                                  uint32_t argb1, uint32_t argb2 )
{
    for( uint8_t i = 0; i<i_splits; i++ )
    {
        uint32_t rgb1 = argb1 & 0x00FFFFFF;
        uint32_t rgb2 = argb2 & 0x00FFFFFF;

        uint32_t r = ((((rgb1 >> 16) * (i_splits - i)) + (rgb2 >> 16) * i)) / i_splits;
        uint32_t g = (((((rgb1 >> 8) & 0xFF) * (i_splits - i)) + ((rgb2 >> 8) & 0xFF) * i)) / i_splits;
        uint32_t b = ((((rgb1 & 0xFF) * (i_splits - i)) + (rgb2 & 0xFF) * i)) / i_splits;
        uint8_t entry[4] = { RGB2YUV( r,g,b ), argb1 >> 24 };
        memcpy( p_palette->palette[i], entry, 4 );
    }
    p_palette->i_entries = i_splits;
}",1,29,video_output\vout_spuregion_helper.h,spuregion_CreateVGradientPalette,,false,30,46,spuregion_CreateVGradientPalette,,,1,"void spuregion_CreateVGradientPalette (video_palette_t*,uint8_t,uint32_t,uint32_t)"
206249,METHOD,video_output\vout_spuregion_helper.h:<global>,TYPE_DECL,"static inline void
spuregion_CreateVGradientFill( plane_t *p, uint8_t i_splits )
{
    const int i_split = p->i_visible_lines / i_splits;
    const int i_left = p->i_visible_lines % i_splits + p->i_lines - p->i_visible_lines;
    for( int i = 0; i<i_splits; i++ )
    {
        memset( &p->p_pixels[p->i_pitch * (i * i_split)],
                i,
                p->i_pitch * i_split );
    }
    memset( &p->p_pixels[p->i_pitch * (i_splits - 1) * i_split],
            i_splits - 1,
            p->i_pitch * i_left );
}",1,1,video_output\vout_spuregion_helper.h,spuregion_CreateVGradientFill,,false,48,62,spuregion_CreateVGradientFill,,,2,"void spuregion_CreateVGradientFill (plane_t*,uint8_t)"
206333,METHOD,video_output\vout_spuregion_helper.h:<global>,TYPE_DECL,"static inline subpicture_region_t *
spuregion_CreateFromPicture( vlc_object_t *p_this, video_format_t *p_fmt,
                             const char *psz_uri )
{
    video_format_t fmt_in;
    video_format_Init( &fmt_in, 0 );

    picture_t *p_pic = NULL;
    int i_flags = p_this->obj.flags;
    p_this->obj.flags |= OBJECT_FLAGS_NOINTERACT|OBJECT_FLAGS_QUIET;
    image_handler_t *p_image = image_HandlerCreate( p_this );
    if( p_image )
    {
        p_pic = image_ReadUrl( p_image, psz_uri, &fmt_in, p_fmt );
        image_HandlerDelete( p_image );
    }
    p_this->obj.flags = i_flags;

    if(!p_pic)
        return NULL;

    subpicture_region_t *region = subpicture_region_New(p_fmt);
    if (!region)
        return NULL;

    picture_Release( region->p_picture );
    region->p_picture = p_pic;

    return region;
}",1,1,video_output\vout_spuregion_helper.h,spuregion_CreateFromPicture,,false,65,94,spuregion_CreateFromPicture,,,3,"subpicture_region_t spuregion_CreateFromPicture (vlc_object_t*,video_format_t*,char*)"
206446,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,<global>,1,1,video_output\vout_subpictures.c,video_output\vout_subpictures.c:<global>,,false,1,1719,<global>,,,1,
206454,METHOD,<empty>,<empty>,<empty>,1,,video_output\vout_subpictures.c,spu_heap_t:<clinit>,,false,60,,<clinit>,,,2,
206495,METHOD,<empty>,<empty>,<empty>,1,,video_output\vout_subpictures.c,spu_private_t:<clinit>,,false,64,,<clinit>,,,24,
206502,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"static void SpuHeapInit(spu_heap_t *heap)
{
    for (int i = 0; i < VOUT_MAX_SUBPICTURES; i++) {
        spu_heap_entry_t *e = &heap->entry[i];

        e->subpicture = NULL;
        e->reject     = false;
    }
}",1,24,video_output\vout_subpictures.c,SpuHeapInit,,false,104,112,SpuHeapInit,,,6,void SpuHeapInit (spu_heap_t*)
206544,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"static int SpuHeapPush(spu_heap_t *heap, subpicture_t *subpic)
{
    for (int i = 0; i < VOUT_MAX_SUBPICTURES; i++) {
        spu_heap_entry_t *e = &heap->entry[i];

        if (e->subpicture)
            continue;

        e->subpicture = subpic;
        e->reject     = false;
        return VLC_SUCCESS;
    }
    return VLC_EGENERIC;
}",1,24,video_output\vout_subpictures.c,SpuHeapPush,,false,114,127,SpuHeapPush,,,7,"int SpuHeapPush (spu_heap_t*,subpicture_t*)"
206597,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"static void SpuHeapDeleteAt(spu_heap_t *heap, int index)
{
    spu_heap_entry_t *e = &heap->entry[index];

    if (e->subpicture)
        subpicture_Delete(e->subpicture);

    e->subpicture = NULL;
}",1,1,video_output\vout_subpictures.c,SpuHeapDeleteAt,,false,129,137,SpuHeapDeleteAt,,,8,"void SpuHeapDeleteAt (spu_heap_t*,int)"
206626,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"static int SpuHeapDeleteSubpicture(spu_heap_t *heap, subpicture_t *subpic)
{
    for (int i = 0; i < VOUT_MAX_SUBPICTURES; i++) {
        spu_heap_entry_t *e = &heap->entry[i];

        if (e->subpicture != subpic)
            continue;

        SpuHeapDeleteAt(heap, i);
        return VLC_SUCCESS;
    }
    return VLC_EGENERIC;
}",1,24,video_output\vout_subpictures.c,SpuHeapDeleteSubpicture,,false,139,151,SpuHeapDeleteSubpicture,,,9,"int SpuHeapDeleteSubpicture (spu_heap_t*,subpicture_t*)"
206674,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"static void SpuHeapClean(spu_heap_t *heap)
{
    for (int i = 0; i < VOUT_MAX_SUBPICTURES; i++) {
        spu_heap_entry_t *e = &heap->entry[i];
        if (e->subpicture)
            subpicture_Delete(e->subpicture);
    }
}",1,24,video_output\vout_subpictures.c,SpuHeapClean,,false,153,160,SpuHeapClean,,,10,void SpuHeapClean (spu_heap_t*)
206715,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"static void FilterRelease(filter_t *filter)
{
    if (filter->p_module)
        module_unneed(filter, filter->p_module);
    vlc_object_release(filter);
}",1,1,video_output\vout_subpictures.c,FilterRelease,,false,162,167,FilterRelease,,,11,void FilterRelease (filter_t*)
206732,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"static picture_t *spu_new_video_buffer(filter_t *filter)
{
    const video_format_t *fmt = &filter->fmt_out.video;

    return picture_NewFromFormat(fmt);
}",1,1,video_output\vout_subpictures.c,spu_new_video_buffer,,false,169,174,spu_new_video_buffer,,,12,picture_t spu_new_video_buffer (filter_t*)
206749,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"static int spu_get_attachments(filter_t *filter,
                               input_attachment_t ***attachment_ptr,
                               int *attachment_count)
{
    spu_t *spu = filter->owner.sys;

    int ret = VLC_EGENERIC;
    if (spu->p->input)
        ret = input_Control((input_thread_t*)spu->p->input,
                            INPUT_GET_ATTACHMENTS,
                            attachment_ptr, attachment_count);
    return ret;
}",1,1,video_output\vout_subpictures.c,spu_get_attachments,,false,176,188,spu_get_attachments,,,13,"int spu_get_attachments (filter_t*,input_attachment_t***,int*)"
206790,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"static filter_t *SpuRenderCreateAndLoadText(spu_t *spu)
{
    filter_t *text = vlc_custom_create(spu, sizeof(*text), ""spu text"");
    if (!text)
        return NULL;

    text->owner.sys = spu;

    es_format_Init(&text->fmt_in, VIDEO_ES, 0);

    es_format_Init(&text->fmt_out, VIDEO_ES, 0);
    text->fmt_out.video.i_width          =
    text->fmt_out.video.i_visible_width  = 32;
    text->fmt_out.video.i_height         =
    text->fmt_out.video.i_visible_height = 32;

    text->pf_get_attachments = spu_get_attachments;

    text->p_module = module_need(text, ""text renderer"", ""$text-renderer"", false);

    /* Create a few variables used for enhanced text rendering */
    var_Create(text, ""spu-elapsed"",   VLC_VAR_INTEGER);
    var_Create(text, ""text-rerender"", VLC_VAR_BOOL);

    return text;
}",1,21,video_output\vout_subpictures.c,SpuRenderCreateAndLoadText,,false,190,215,SpuRenderCreateAndLoadText,,,14,filter_t SpuRenderCreateAndLoadText (spu_t*)
206893,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"static filter_t *SpuRenderCreateAndLoadScale(vlc_object_t *object,
                                             vlc_fourcc_t src_chroma,
                                             vlc_fourcc_t dst_chroma,
                                             bool require_resize)
{
    filter_t *scale = vlc_custom_create(object, sizeof(*scale), ""scale"");
    if (!scale)
        return NULL;

    es_format_Init(&scale->fmt_in, VIDEO_ES, 0);
    scale->fmt_in.video.i_chroma = src_chroma;
    scale->fmt_in.video.i_width =
    scale->fmt_in.video.i_visible_width =
    scale->fmt_in.video.i_height =
    scale->fmt_in.video.i_visible_height = 32;

    es_format_Init(&scale->fmt_out, VIDEO_ES, 0);
    scale->fmt_out.video.i_chroma = dst_chroma;
    scale->fmt_out.video.i_width =
    scale->fmt_out.video.i_visible_width =
    scale->fmt_out.video.i_height =
    scale->fmt_out.video.i_visible_height = require_resize ? 16 : 32;

    scale->owner.video.buffer_new = spu_new_video_buffer;

    scale->p_...",1,22,video_output\vout_subpictures.c,SpuRenderCreateAndLoadScale,,false,217,245,SpuRenderCreateAndLoadScale,,,15,"filter_t SpuRenderCreateAndLoadScale (vlc_object_t*,vlc_fourcc_t,vlc_fourcc_t,bool)"
207042,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"static void SpuRenderText(spu_t *spu, bool *rerender_text,
                          subpicture_region_t *region,
                          const vlc_fourcc_t *chroma_list,
                          mtime_t elapsed_time)
{
    filter_t *text = spu->p->text;

    assert(region->fmt.i_chroma == VLC_CODEC_TEXT);

    if (!text || !text->p_module)
        return;

    /* Setup 3 variables which can be used to render
     * time-dependent text (and effects). The first indicates
     * the total amount of time the text will be on screen,
     * the second the amount of time it has already been on
     * screen (can be a negative value as text is laid out
     * before it is rendered) and the third is a feedback
     * variable from the renderer - if the renderer sets it
     * then this particular text is time-dependent, eg. the
     * visual progress bar inside the text in karaoke and the
     * text needs to be rendered multiple times in order for
     * the effect to work - we therefor...",1,1,video_output\vout_subpictures.c,SpuRenderText,,false,247,284,SpuRenderText,,,16,"void SpuRenderText (spu_t*,bool*,subpicture_region_t*,vlc_fourcc_t*,mtime_t)"
207108,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"static spu_scale_t spu_scale_create(int w, int h)
{
    spu_scale_t s = { .w = w, .h = h };
    if (s.w <= 0)
        s.w = SCALE_UNIT;
    if (s.h <= 0)
        s.h = SCALE_UNIT;
    return s;
}",1,14,video_output\vout_subpictures.c,spu_scale_create,,false,296,304,spu_scale_create,,,19,"spu_scale_t spu_scale_create (int,int)"
207156,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"static spu_scale_t spu_scale_unit(void)
{
    return spu_scale_create(SCALE_UNIT, SCALE_UNIT);
}",1,28,video_output\vout_subpictures.c,spu_scale_unit,,false,305,308,spu_scale_unit,,,20,spu_scale_t spu_scale_unit (void)
207169,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"static spu_scale_t spu_scale_createq(int64_t wn, int64_t wd, int64_t hn, int64_t hd)
{
    return spu_scale_create(wn * SCALE_UNIT / wd,
                            hn * SCALE_UNIT / hd);
}",1,33,video_output\vout_subpictures.c,spu_scale_createq,,false,309,313,spu_scale_createq,,,21,"spu_scale_t spu_scale_createq (int64_t,int64_t,int64_t,int64_t)"
207193,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"static int spu_scale_w(int v, const spu_scale_t s)
{
    return v * s.w / SCALE_UNIT;
}",1,21,video_output\vout_subpictures.c,spu_scale_w,,false,314,317,spu_scale_w,,,22,"int spu_scale_w (int,spu_scale_t)"
207209,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"static int spu_scale_h(int v, const spu_scale_t s)
{
    return v * s.h / SCALE_UNIT;
}",1,21,video_output\vout_subpictures.c,spu_scale_h,,false,318,321,spu_scale_h,,,23,"int spu_scale_h (int,spu_scale_t)"
207225,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"static int spu_invscale_w(int v, const spu_scale_t s)
{
    return v * SCALE_UNIT / s.w;
}",1,15,video_output\vout_subpictures.c,spu_invscale_w,,false,322,325,spu_invscale_w,,,24,"int spu_invscale_w (int,spu_scale_t)"
207241,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"static int spu_invscale_h(int v, const spu_scale_t s)
{
    return v * SCALE_UNIT / s.h;
}",1,15,video_output\vout_subpictures.c,spu_invscale_h,,false,326,329,spu_invscale_h,,,25,"int spu_invscale_h (int,spu_scale_t)"
207264,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"static spu_area_t spu_area_create(int x, int y, int w, int h, spu_scale_t s)
{
    spu_area_t a = { .x = x, .y = y, .width = w, .height = h, .scale = s };
    return a;
}",1,1,video_output\vout_subpictures.c,spu_area_create,,false,343,347,spu_area_create,,,28,"spu_area_t spu_area_create (int,int,int,int,spu_scale_t)"
207299,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"static spu_area_t spu_area_scaled(spu_area_t a)
{
    if (a.scale.w == SCALE_UNIT && a.scale.h == SCALE_UNIT)
        return a;

    a.x      = spu_scale_w(a.x,      a.scale);
    a.y      = spu_scale_h(a.y,      a.scale);
    a.width  = spu_scale_w(a.width,  a.scale);
    a.height = spu_scale_h(a.height, a.scale);

    a.scale = spu_scale_unit();
    return a;
}",1,21,video_output\vout_subpictures.c,spu_area_scaled,,false,348,360,spu_area_scaled,,,29,spu_area_t spu_area_scaled (spu_area_t)
207378,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"static spu_area_t spu_area_unscaled(spu_area_t a, spu_scale_t s)
{
    if (a.scale.w == s.w && a.scale.h == s.h)
        return a;

    a = spu_area_scaled(a);

    a.x      = spu_invscale_w(a.x,      s);
    a.y      = spu_invscale_h(a.y,      s);
    a.width  = spu_invscale_w(a.width,  s);
    a.height = spu_invscale_h(a.height, s);

    a.scale = s;
    return a;
}",1,1,video_output\vout_subpictures.c,spu_area_unscaled,,false,361,375,spu_area_unscaled,,,30,"spu_area_t spu_area_unscaled (spu_area_t,spu_scale_t)"
207454,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"static bool spu_area_overlap(spu_area_t a, spu_area_t b)
{
    a = spu_area_scaled(a);
    b = spu_area_scaled(b);

    return __MAX(a.x, b.x) < __MIN(a.x + a.width , b.x + b.width ) &&
           __MAX(a.y, b.y) < __MIN(a.y + a.height, b.y + b.height);
}",1,1,video_output\vout_subpictures.c,spu_area_overlap,,false,376,383,spu_area_overlap,,,31,"bool spu_area_overlap (spu_area_t,spu_area_t)"
207516,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"static void SpuAreaFixOverlap(spu_area_t *dst,
                              const spu_area_t *sub_array, int sub_count, int align)
{
    spu_area_t a = spu_area_scaled(*dst);
    bool is_moved = false;
    bool is_ok;

    /* Check for overlap
     * XXX It is not fast O(n^2) but we should not have a lot of region */
    do {
        is_ok = true;
        for (int i = 0; i < sub_count; i++) {
            spu_area_t sub = spu_area_scaled(sub_array[i]);

            if (!spu_area_overlap(a, sub))
                continue;

            if (align & SUBPICTURE_ALIGN_TOP) {
                /* We go down */
                int i_y = sub.y + sub.height;
                a.y = i_y;
                is_moved = true;
            } else if (align & SUBPICTURE_ALIGN_BOTTOM) {
                /* We go up */
                int i_y = sub.y - a.height;
                a.y = i_y;
                is_moved = true;
            } else {
                /* TODO what to do in this case? */
                ...",1,1,video_output\vout_subpictures.c,SpuAreaFixOverlap,,false,388,428,SpuAreaFixOverlap,,,32,"void SpuAreaFixOverlap (spu_area_t*,spu_area_t*,int,int)"
207634,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"static void SpuAreaFitInside(spu_area_t *area, const spu_area_t *boundary)
{
    spu_area_t a = spu_area_scaled(*area);

    const int i_error_x = (a.x + a.width) - boundary->width;
    if (i_error_x > 0)
        a.x -= i_error_x;
    if (a.x < 0)
        a.x = 0;

    const int i_error_y = (a.y + a.height) - boundary->height;
    if (i_error_y > 0)
        a.y -= i_error_y;
    if (a.y < 0)
        a.y = 0;

    *area = spu_area_unscaled(a, area->scale);
}",1,1,video_output\vout_subpictures.c,SpuAreaFitInside,,false,431,448,SpuAreaFitInside,,,33,"void SpuAreaFitInside (spu_area_t*,spu_area_t*)"
207726,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"static void SpuRegionPlace(int *x, int *y,
                           const subpicture_t *subpic,
                           const subpicture_region_t *region)
{
    assert(region->i_x != INT_MAX && region->i_y != INT_MAX);
    if (subpic->b_absolute) {
        *x = region->i_x;
        *y = region->i_y;
    } else {
        if (region->i_align & SUBPICTURE_ALIGN_TOP)
            *y = region->i_y;
        else if (region->i_align & SUBPICTURE_ALIGN_BOTTOM)
            *y = subpic->i_original_picture_height - region->fmt.i_visible_height - region->i_y;
        else
            *y = subpic->i_original_picture_height / 2 - region->fmt.i_visible_height / 2;

        if (region->i_align & SUBPICTURE_ALIGN_LEFT)
            *x = region->i_x;
        else if (region->i_align & SUBPICTURE_ALIGN_RIGHT)
            *x = subpic->i_original_picture_width - region->fmt.i_visible_width - region->i_x;
        else
            *x = subpic->i_original_picture_width / 2 - region->fmt.i_visible_width ...",1,1,video_output\vout_subpictures.c,SpuRegionPlace,,false,453,476,SpuRegionPlace,,,34,"void SpuRegionPlace (int*,int*,subpicture_t*,subpicture_region_t*)"
207877,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"static int IntegerCmp(int64_t i0, int64_t i1)
{
    return i0 < i1 ? -1 : i0 > i1 ? 1 : 0;
}",1,1,video_output\vout_subpictures.c,IntegerCmp,,false,482,485,IntegerCmp,,,35,"int IntegerCmp (int64_t,int64_t)"
207896,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"static int SubpictureCmp(const void *s0, const void *s1)
{
    subpicture_t *subpic0 = *(subpicture_t**)s0;
    subpicture_t *subpic1 = *(subpicture_t**)s1;
    int r;

    r = IntegerCmp(!subpic0->b_absolute, !subpic1->b_absolute);
    if (!r)
        r = IntegerCmp(subpic0->i_start, subpic1->i_start);
    if (!r)
        r = IntegerCmp(subpic0->i_channel, subpic1->i_channel);
    if (!r)
        r = IntegerCmp(subpic0->i_order, subpic1->i_order);
    return r;
}",1,1,video_output\vout_subpictures.c,SubpictureCmp,,false,497,511,SubpictureCmp,,,36,"int SubpictureCmp (void*,void*)"
207969,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"static void SpuSelectSubpictures(spu_t *spu,
                                 unsigned int *subpicture_count,
                                 subpicture_t **subpicture_array,
                                 mtime_t render_subtitle_date,
                                 mtime_t render_osd_date,
                                 bool ignore_osd)
{
    spu_private_t *sys = spu->p;

    /* */
    *subpicture_count = 0;

    /* Create a list of channels */
    int channel[VOUT_MAX_SUBPICTURES];
    int channel_count = 0;

    for (int index = 0; index < VOUT_MAX_SUBPICTURES; index++) {
        spu_heap_entry_t *entry = &sys->heap.entry[index];
        if (!entry->subpicture || entry->reject)
            continue;
        const int i_channel = entry->subpicture->i_channel;
        int i;
        for (i = 0; i < channel_count; i++) {
            if (channel[i] == i_channel)
                break;
        }
        if (channel_count <= i)
            channel[channel_count++] = i_channel;
 ...",1,16,video_output\vout_subpictures.c,SpuSelectSubpictures,,false,523,650,SpuSelectSubpictures,,,37,"void SpuSelectSubpictures (spu_t*,unsigned int*,subpicture_t**,mtime_t,mtime_t,bool)"
208459,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"static void SpuRenderRegion(spu_t *spu,
                            subpicture_region_t **dst_ptr, spu_area_t *dst_area,
                            subpicture_t *subpic, subpicture_region_t *region,
                            const spu_scale_t scale_size,
                            const vlc_fourcc_t *chroma_list,
                            const video_format_t *fmt,
                            const spu_area_t *subtitle_area, int subtitle_area_count,
                            mtime_t render_date)
{
    spu_private_t *sys = spu->p;

    video_format_t fmt_original = region->fmt;
    bool restore_text = false;
    int x_offset;
    int y_offset;

    video_format_t region_fmt;
    picture_t *region_picture;

    /* Invalidate area by default */
    *dst_area = spu_area_create(0,0, 0,0, scale_size);
    *dst_ptr  = NULL;

    /* Render text region */
    if (region->fmt.i_chroma == VLC_CODEC_TEXT) {
        // assume rendered text is in sRGB if nothing is set
        if (region-...",1,25,video_output\vout_subpictures.c,SpuRenderRegion,,false,657,1000,SpuRenderRegion,,,38,"void SpuRenderRegion (spu_t*,subpicture_region_t**,spu_area_t*,subpicture_t*,subpicture_region_t*,spu_scale_t,vlc_fourcc_t*,video_format_t*,spu_area_t*,int,mtime_t)"
209780,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"static subpicture_t *SpuRenderSubpictures(spu_t *spu,
                                          unsigned int i_subpicture,
                                          subpicture_t **pp_subpicture,
                                          const vlc_fourcc_t *chroma_list,
                                          const video_format_t *fmt_dst,
                                          const video_format_t *fmt_src,
                                          mtime_t render_subtitle_date,
                                          mtime_t render_osd_date)
{
    spu_private_t *sys = spu->p;

    /* Count the number of regions and subtitle regions */
    unsigned int subtitle_region_count = 0;
    unsigned int region_count          = 0;
    for (unsigned i = 0; i < i_subpicture; i++) {
        const subpicture_t *subpic = pp_subpicture[i];

        unsigned count = 0;
        for (subpicture_region_t *r = subpic->p_region; r != NULL; r = r->p_next)
            count++;

        if (subpic->b...",1,36,video_output\vout_subpictures.c,SpuRenderSubpictures,,false,1005,1144,SpuRenderSubpictures,,,39,"subpicture_t SpuRenderSubpictures (spu_t*,unsigned int,subpicture_t**,vlc_fourcc_t*,video_format_t*,video_format_t*,mtime_t,mtime_t)"
210297,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"static void UpdateSPU(spu_t *spu, vlc_object_t *object)
{
    spu_private_t *sys = spu->p;
    vlc_value_t val;

    vlc_mutex_lock(&sys->lock);

    sys->force_palette = false;
    sys->force_crop = false;

    if (var_Get(object, ""highlight"", &val) || !val.b_bool) {
        vlc_mutex_unlock(&sys->lock);
        return;
    }

    sys->force_crop = true;
    sys->crop.x      = var_GetInteger(object, ""x-start"");
    sys->crop.y      = var_GetInteger(object, ""y-start"");
    sys->crop.width  = var_GetInteger(object, ""x-end"") - sys->crop.x;
    sys->crop.height = var_GetInteger(object, ""y-end"") - sys->crop.y;

    if (var_Get(object, ""menu-palette"", &val) == VLC_SUCCESS) {
        memcpy(sys->palette, val.p_address, 16);
        sys->force_palette = true;
    }
    vlc_mutex_unlock(&sys->lock);

    msg_Dbg(object, ""crop: %i,%i,%i,%i, palette forced: %i"",
            sys->crop.x, sys->crop.y,
            sys->crop.width, sys->crop.height,
            sys->force_palette);
}",1,1,video_output\vout_subpictures.c,UpdateSPU,,false,1156,1187,UpdateSPU,,,40,"void UpdateSPU (spu_t*,vlc_object_t*)"
210449,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"static int CropCallback(vlc_object_t *object, char const *var,
                        vlc_value_t oldval, vlc_value_t newval, void *data)
{
    VLC_UNUSED(oldval); VLC_UNUSED(newval); VLC_UNUSED(var);

    UpdateSPU((spu_t *)data, object);
    return VLC_SUCCESS;
}",1,1,video_output\vout_subpictures.c,CropCallback,,false,1194,1201,CropCallback,,,41,"int CropCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
210471,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"static subpicture_t *sub_new_buffer(filter_t *filter)
{
    int channel = (intptr_t)filter->owner.sys;

    subpicture_t *subpicture = subpicture_New(NULL);
    if (subpicture)
        subpicture->i_channel = channel;
    return subpicture;
}",1,1,video_output\vout_subpictures.c,sub_new_buffer,,false,1207,1215,sub_new_buffer,,,42,subpicture_t sub_new_buffer (filter_t*)
210501,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"static int SubSourceInit(filter_t *filter, void *data)
{
    spu_t *spu = data;
    int channel = spu_RegisterChannel(spu);

    filter->owner.sys = (void *)(intptr_t)channel;
    filter->owner.sub.buffer_new = sub_new_buffer;
    return VLC_SUCCESS;
}",1,1,video_output\vout_subpictures.c,SubSourceInit,,false,1217,1225,SubSourceInit,,,43,"int SubSourceInit (filter_t*,void*)"
210538,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"static int SubSourceClean(filter_t *filter, void *data)
{
    spu_t *spu = data;
    int channel = (intptr_t)filter->owner.sys;

    spu_ClearChannel(spu, channel);
    return VLC_SUCCESS;
}",1,1,video_output\vout_subpictures.c,SubSourceClean,,false,1227,1234,SubSourceClean,,,44,"int SubSourceClean (filter_t*,void*)"
210563,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"static int RestartSubFilterCallback(vlc_object_t *obj, char const *psz_var,
                                    vlc_value_t oldval, vlc_value_t newval,
                                    void *p_data)
{ VLC_UNUSED(obj); VLC_UNUSED(psz_var); VLC_UNUSED(oldval); VLC_UNUSED(newval);
    vout_ControlChangeSubFilters((vout_thread_t *)p_data, NULL);
    return VLC_SUCCESS;
}",1,1,video_output\vout_subpictures.c,RestartSubFilterCallback,,false,1240,1246,RestartSubFilterCallback,,,45,"int RestartSubFilterCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
210587,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"static int SubFilterAddProxyCallbacks(filter_t *filter, void *opaque)
{
    filter_AddProxyCallbacks((vlc_object_t *)opaque, filter,
                             RestartSubFilterCallback);
    return VLC_SUCCESS;
}",1,1,video_output\vout_subpictures.c,SubFilterAddProxyCallbacks,,false,1248,1253,SubFilterAddProxyCallbacks,,,46,"int SubFilterAddProxyCallbacks (filter_t*,void*)"
210601,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"static int SubFilterDelProxyCallbacks(filter_t *filter, void *opaque)
{
    filter_DelProxyCallbacks((vlc_object_t *)opaque, filter,
                             RestartSubFilterCallback);
    return VLC_SUCCESS;
}",1,1,video_output\vout_subpictures.c,SubFilterDelProxyCallbacks,,false,1255,1260,SubFilterDelProxyCallbacks,,,47,"int SubFilterDelProxyCallbacks (filter_t*,void*)"
210615,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"static int RestartSubSourceCallback(vlc_object_t *obj, char const *psz_var,
                                    vlc_value_t oldval, vlc_value_t newval,
                                    void *p_data)
{ VLC_UNUSED(obj); VLC_UNUSED(psz_var); VLC_UNUSED(oldval); VLC_UNUSED(newval);
    vout_ControlChangeSubSources((vout_thread_t *)p_data, NULL);
    return VLC_SUCCESS;
}",1,1,video_output\vout_subpictures.c,RestartSubSourceCallback,,false,1262,1268,RestartSubSourceCallback,,,48,"int RestartSubSourceCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)"
210639,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"static int SubSourceAddProxyCallbacks(filter_t *filter, void *opaque)
{
    filter_AddProxyCallbacks((vlc_object_t *)opaque, filter,
                             RestartSubSourceCallback);
    return VLC_SUCCESS;
}",1,1,video_output\vout_subpictures.c,SubSourceAddProxyCallbacks,,false,1270,1275,SubSourceAddProxyCallbacks,,,49,"int SubSourceAddProxyCallbacks (filter_t*,void*)"
210653,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"static int SubSourceDelProxyCallbacks(filter_t *filter, void *opaque)
{
    filter_DelProxyCallbacks((vlc_object_t *)opaque, filter,
                             RestartSubSourceCallback);
    return VLC_SUCCESS;
}",1,1,video_output\vout_subpictures.c,SubSourceDelProxyCallbacks,,false,1277,1282,SubSourceDelProxyCallbacks,,,50,"int SubSourceDelProxyCallbacks (filter_t*,void*)"
210667,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"spu_t *spu_Create(vlc_object_t *object, vout_thread_t *vout)
{
    spu_t *spu = vlc_custom_create(object,
                                   sizeof(spu_t) + sizeof(spu_private_t),
                                   ""subpicture"");
    if (!spu)
        return NULL;

    /* Initialize spu fields */
    spu_private_t *sys = spu->p = (spu_private_t*)&spu[1];

    /* Initialize private fields */
    vlc_mutex_init(&sys->lock);

    SpuHeapInit(&sys->heap);

    sys->text = NULL;
    sys->scale = NULL;
    sys->scale_yuvp = NULL;

    sys->margin = var_InheritInteger(spu, ""sub-margin"");

    /* Register the default subpicture channel */
    sys->channel = VOUT_SPU_CHANNEL_AVAIL_FIRST;

    sys->source_chain_update = NULL;
    sys->filter_chain_update = NULL;
    vlc_mutex_init(&sys->source_chain_lock);
    vlc_mutex_init(&sys->filter_chain_lock);
    sys->source_chain = filter_chain_New(spu, ""sub source"", SPU_ES);
    sys->filter_chain = filter_chain_New(spu, ""sub filter"", SPU_ES);

    /...",1,17,video_output\vout_subpictures.c,spu_Create,,false,1294,1344,spu_Create,,,51,"spu_t spu_Create (vlc_object_t*,vout_thread_t*)"
210820,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"void spu_Destroy(spu_t *spu)
{
    spu_private_t *sys = spu->p;

    if (sys->text)
        FilterRelease(sys->text);

    if (sys->scale_yuvp)
        FilterRelease(sys->scale_yuvp);

    if (sys->scale)
        FilterRelease(sys->scale);

    filter_chain_ForEach(sys->source_chain, SubSourceClean, spu);
    if (sys->vout)
        filter_chain_ForEach(sys->source_chain,
                             SubSourceDelProxyCallbacks, sys->vout);
    filter_chain_Delete(sys->source_chain);
    free(sys->source_chain_current);
    if (sys->vout)
        filter_chain_ForEach(sys->filter_chain,
                             SubFilterDelProxyCallbacks, sys->vout);
    filter_chain_Delete(sys->filter_chain);
    free(sys->filter_chain_current);
    vlc_mutex_destroy(&sys->source_chain_lock);
    vlc_mutex_destroy(&sys->filter_chain_lock);
    free(sys->source_chain_update);
    free(sys->filter_chain_update);

    /* Destroy all remaining subpictures */
    SpuHeapClean(&sys->heap);

    vlc_mute...",1,1,video_output\vout_subpictures.c,spu_Destroy,,false,1351,1386,spu_Destroy,,,52,void spu_Destroy (spu_t*)
210936,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"void spu_Attach(spu_t *spu, vlc_object_t *input, bool attach)
{
    if (attach) {
        UpdateSPU(spu, input);
        var_Create(input, ""highlight"", VLC_VAR_BOOL);
        var_AddCallback(input, ""highlight"", CropCallback, spu);

        vlc_mutex_lock(&spu->p->lock);
        spu->p->input = input;

        if (spu->p->text)
            FilterRelease(spu->p->text);
        spu->p->text = SpuRenderCreateAndLoadText(spu);

        vlc_mutex_unlock(&spu->p->lock);
    } else {
        vlc_mutex_lock(&spu->p->lock);
        spu->p->input = NULL;
        vlc_mutex_unlock(&spu->p->lock);

        /* Delete callbacks */
        var_DelCallback(input, ""highlight"", CropCallback, spu);
        var_Destroy(input, ""highlight"");
    }
}",1,1,video_output\vout_subpictures.c,spu_Attach,,false,1394,1418,spu_Attach,,,53,"void spu_Attach (spu_t*,vlc_object_t*,bool)"
211031,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"int spu_ProcessMouse(spu_t *spu,
                     const vlc_mouse_t *mouse,
                     const video_format_t *fmt)
{
    spu_private_t *sys = spu->p;

    vlc_mutex_lock(&sys->source_chain_lock);
    filter_chain_MouseEvent(sys->source_chain, mouse, fmt);
    vlc_mutex_unlock(&sys->source_chain_lock);

    return VLC_SUCCESS;
}",1,1,video_output\vout_subpictures.c,spu_ProcessMouse,,false,1423,1434,spu_ProcessMouse,,,54,"int spu_ProcessMouse (spu_t*,vlc_mouse_t*,video_format_t*)"
211062,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"void spu_PutSubpicture(spu_t *spu, subpicture_t *subpic)
{
    spu_private_t *sys = spu->p;

    /* Update sub-filter chain */
    vlc_mutex_lock(&sys->lock);
    char *chain_update = sys->filter_chain_update;
    sys->filter_chain_update = NULL;
    vlc_mutex_unlock(&sys->lock);

    bool is_left_empty = false;

    vlc_mutex_lock(&sys->filter_chain_lock);
    if (chain_update) {
        if (*chain_update) {
            if (sys->vout)
                filter_chain_ForEach(sys->filter_chain,
                                     SubFilterDelProxyCallbacks,
                                     sys->vout);
            filter_chain_Reset(sys->filter_chain, NULL, NULL);

            filter_chain_AppendFromString(spu->p->filter_chain, chain_update);
            if (sys->vout)
                filter_chain_ForEach(sys->filter_chain,
                                     SubFilterAddProxyCallbacks,
                                     sys->vout);
        }
        else
            filter_chain...",1,1,video_output\vout_subpictures.c,spu_PutSubpicture,,false,1444,1524,spu_PutSubpicture,,,55,"void spu_PutSubpicture (spu_t*,subpicture_t*)"
211312,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"subpicture_t *spu_Render(spu_t *spu,
                         const vlc_fourcc_t *chroma_list,
                         const video_format_t *fmt_dst,
                         const video_format_t *fmt_src,
                         mtime_t render_subtitle_date,
                         mtime_t render_osd_date,
                         bool ignore_osd)
{
    spu_private_t *sys = spu->p;

    /* Update sub-source chain */
    vlc_mutex_lock(&sys->lock);
    char *chain_update = sys->source_chain_update;
    sys->source_chain_update = NULL;
    vlc_mutex_unlock(&sys->lock);

    vlc_mutex_lock(&sys->source_chain_lock);
    if (chain_update) {
        filter_chain_ForEach(sys->source_chain, SubSourceClean, spu);
            if (sys->vout)
                filter_chain_ForEach(sys->source_chain,
                                     SubSourceDelProxyCallbacks,
                                     sys->vout);
        filter_chain_Reset(sys->source_chain, NULL, NULL);

        filter_chain_A...",1,35,video_output\vout_subpictures.c,spu_Render,,false,1526,1620,spu_Render,,,56,"subpicture_t spu_Render (spu_t*,vlc_fourcc_t*,video_format_t*,video_format_t*,mtime_t,mtime_t,bool)"
211541,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"void spu_OffsetSubtitleDate(spu_t *spu, mtime_t duration)
{
    spu_private_t *sys = spu->p;

    vlc_mutex_lock(&sys->lock);
    for (int i = 0; i < VOUT_MAX_SUBPICTURES; i++) {
        spu_heap_entry_t *entry = &sys->heap.entry[i];
        subpicture_t *current = entry->subpicture;

        if (current && current->b_subtitle) {
            if (current->i_start > 0)
                current->i_start += duration;
            if (current->i_stop > 0)
                current->i_stop  += duration;
        }
    }
    vlc_mutex_unlock(&sys->lock);
}",1,24,video_output\vout_subpictures.c,spu_OffsetSubtitleDate,,false,1622,1639,spu_OffsetSubtitleDate,,,57,"void spu_OffsetSubtitleDate (spu_t*,mtime_t)"
211629,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"int spu_RegisterChannel(spu_t *spu)
{
    spu_private_t *sys = spu->p;

    vlc_mutex_lock(&sys->lock);
    int channel = sys->channel++;
    vlc_mutex_unlock(&sys->lock);

    return channel;
}",1,1,video_output\vout_subpictures.c,spu_RegisterChannel,,false,1641,1650,spu_RegisterChannel,,,58,int spu_RegisterChannel (spu_t*)
211659,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"void spu_ClearChannel(spu_t *spu, int channel)
{
    spu_private_t *sys = spu->p;

    vlc_mutex_lock(&sys->lock);

    for (int i = 0; i < VOUT_MAX_SUBPICTURES; i++) {
        spu_heap_entry_t *entry = &sys->heap.entry[i];
        subpicture_t *subpic = entry->subpicture;

        if (!subpic)
            continue;
        if (subpic->i_channel != channel && (channel != -1 || subpic->i_channel == VOUT_SPU_CHANNEL_OSD))
            continue;

        /* You cannot delete subpicture outside of SpuSelectSubpictures */
        entry->reject = true;
    }

    vlc_mutex_unlock(&sys->lock);
}",1,24,video_output\vout_subpictures.c,spu_ClearChannel,,false,1652,1672,spu_ClearChannel,,,59,"void spu_ClearChannel (spu_t*,int)"
211745,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"void spu_ChangeSources(spu_t *spu, const char *filters)
{
    spu_private_t *sys = spu->p;

    vlc_mutex_lock(&sys->lock);

    free(sys->source_chain_update);
    if (filters)
    {
        sys->source_chain_update = strdup(filters);
        free(sys->source_chain_current);
        sys->source_chain_current = strdup(filters);
    }
    else if (sys->source_chain_current)
        sys->source_chain_update = strdup(sys->source_chain_current);

    vlc_mutex_unlock(&sys->lock);
}",1,1,video_output\vout_subpictures.c,spu_ChangeSources,,false,1674,1691,spu_ChangeSources,,,60,"void spu_ChangeSources (spu_t*,char*)"
211805,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"void spu_ChangeFilters(spu_t *spu, const char *filters)
{
    spu_private_t *sys = spu->p;

    vlc_mutex_lock(&sys->lock);

    free(sys->filter_chain_update);
    if (filters)
    {
        sys->filter_chain_update = strdup(filters);
        free(sys->filter_chain_current);
        sys->filter_chain_current = strdup(filters);
    }
    else if (sys->filter_chain_current)
        sys->filter_chain_update = strdup(sys->filter_chain_current);

    vlc_mutex_unlock(&sys->lock);
}",1,1,video_output\vout_subpictures.c,spu_ChangeFilters,,false,1693,1710,spu_ChangeFilters,,,61,"void spu_ChangeFilters (spu_t*,char*)"
211865,METHOD,video_output\vout_subpictures.c:<global>,TYPE_DECL,"void spu_ChangeMargin(spu_t *spu, int margin)
{
    spu_private_t *sys = spu->p;

    vlc_mutex_lock(&sys->lock);
    sys->margin = margin;
    vlc_mutex_unlock(&sys->lock);
}",1,1,video_output\vout_subpictures.c,spu_ChangeMargin,,false,1712,1719,spu_ChangeMargin,,,62,"void spu_ChangeMargin (spu_t*,int)"
211911,METHOD,video_output\vout_wrapper.c:<global>,TYPE_DECL,<global>,1,20,video_output\vout_wrapper.c,video_output\vout_wrapper.c:<global>,,false,1,217,<global>,,,1,
211913,METHOD,video_output\vout_wrapper.c:<global>,TYPE_DECL,"int vout_OpenWrapper(vout_thread_t *vout,
                     const char *splitter_name, const vout_display_state_t *state)
{
    vout_thread_sys_t *sys = vout->p;
    msg_Dbg(vout, ""Opening vout display wrapper"");

    /* */
    sys->display.title = var_InheritString(vout, ""video-title"");

    /* */
    const mtime_t double_click_timeout = 300000;
    const mtime_t hide_timeout = var_CreateGetInteger(vout, ""mouse-hide-timeout"") * 1000;

    if (splitter_name) {
        sys->display.vd = vout_NewSplitter(vout, &vout->p->original, state, ""$vout"", splitter_name,
                                           double_click_timeout, hide_timeout);
    } else {
        sys->display.vd = vout_NewDisplay(vout, &vout->p->original, state, ""$vout"",
                                          double_click_timeout, hide_timeout);
    }
    if (!sys->display.vd) {
        free(sys->display.title);
        return VLC_EGENERIC;
    }

    /* */
#ifdef _WIN32
    var_Create(vout, ""video-wallpaper"", VLC_V...",1,1,video_output\vout_wrapper.c,vout_OpenWrapper,,false,50,85,vout_OpenWrapper,,,1,"int vout_OpenWrapper (vout_thread_t*,char*,vout_display_state_t*)"
212015,METHOD,video_output\vout_wrapper.c:<global>,TYPE_DECL,"void vout_CloseWrapper(vout_thread_t *vout, vout_display_state_t *state)
{
    vout_thread_sys_t *sys = vout->p;

#ifdef _WIN32
    var_DelCallback(vout, ""video-wallpaper"", Forward, NULL);
#endif
    sys->decoder_pool = NULL; /* FIXME remove */

    vout_DeleteDisplay(sys->display.vd, state);
    free(sys->display.title);
}",1,1,video_output\vout_wrapper.c,vout_CloseWrapper,,false,90,101,vout_CloseWrapper,,,2,"void vout_CloseWrapper (vout_thread_t*,vout_display_state_t*)"
212045,METHOD,video_output\vout_wrapper.c:<global>,TYPE_DECL,"static void NoDrInit(vout_thread_t *vout)
{
    vout_thread_sys_t *sys = vout->p;

    if (sys->display.use_dr)
        sys->display_pool = vout_display_Pool(sys->display.vd, 3);
    else
        sys->display_pool = NULL;
}",1,1,video_output\vout_wrapper.c,NoDrInit,,false,109,117,NoDrInit,,,3,void NoDrInit (vout_thread_t*)
212081,METHOD,video_output\vout_wrapper.c:<global>,TYPE_DECL,"int vout_InitWrapper(vout_thread_t *vout)
{
    vout_thread_sys_t *sys = vout->p;
    vout_display_t *vd = sys->display.vd;

    sys->display.use_dr = !vout_IsDisplayFiltered(vd);
    const bool allow_dr = !vd->info.has_pictures_invalid && !vd->info.is_slow && sys->display.use_dr;
    const unsigned private_picture  = 4; /* XXX 3 for filter, 1 for SPU */
    const unsigned decoder_picture  = 1 + sys->dpb_size;
    const unsigned kept_picture     = 1; /* last displayed picture */
    const unsigned reserved_picture = DISPLAY_PICTURE_COUNT +
                                      private_picture +
                                      kept_picture;
    const unsigned display_pool_size = allow_dr ? __MAX(VOUT_MAX_PICTURES,
                                                        reserved_picture + decoder_picture) : 3;
    picture_pool_t *display_pool = vout_display_Pool(vd, display_pool_size);
    if (display_pool == NULL)
        return VLC_EGENERIC;

#ifndef NDEBUG
    if ( picture_po...",1,38,video_output\vout_wrapper.c,vout_InitWrapper,,false,119,173,vout_InitWrapper,,,4,int vout_InitWrapper (vout_thread_t*)
212325,METHOD,video_output\vout_wrapper.c:<global>,TYPE_DECL,"void vout_EndWrapper(vout_thread_t *vout)
{
    vout_thread_sys_t *sys = vout->p;

    assert(vout->p->decoder_pool && vout->p->private_pool);

    picture_pool_Release(sys->private_pool);

    if (sys->decoder_pool != sys->display_pool)
        picture_pool_Release(sys->decoder_pool);
}",1,1,video_output\vout_wrapper.c,vout_EndWrapper,,false,178,188,vout_EndWrapper,,,5,void vout_EndWrapper (vout_thread_t*)
212365,METHOD,video_output\vout_wrapper.c:<global>,TYPE_DECL,"void vout_ManageWrapper(vout_thread_t *vout)
{
    vout_thread_sys_t *sys = vout->p;
    vout_display_t *vd = sys->display.vd;

    bool reset_display_pool = vout_AreDisplayPicturesInvalid(vd);
    reset_display_pool |= vout_ManageDisplay(vd, !sys->display.use_dr || reset_display_pool);

    if (reset_display_pool) {
        sys->display.use_dr = !vout_IsDisplayFiltered(vd);
        NoDrInit(vout);
    }
}",1,1,video_output\vout_wrapper.c,vout_ManageWrapper,,false,193,205,vout_ManageWrapper,,,6,void vout_ManageWrapper (vout_thread_t*)
212440,METHOD,video_output\window.c:<global>,TYPE_DECL,<global>,1,25,video_output\window.c,video_output\window.c:<global>,,false,1,245,<global>,,,1,
212447,METHOD,video_output\window.c:<global>,TYPE_DECL,"static int vout_window_start(void *func, va_list ap)
{
    int (*activate)(vout_window_t *, const vout_window_cfg_t *) = func;
    vout_window_t *wnd = va_arg(ap, vout_window_t *);
    const vout_window_cfg_t *cfg = va_arg(ap, const vout_window_cfg_t *);

    return activate(wnd, cfg);
}",1,1,video_output\window.c,vout_window_start,,false,45,52,vout_window_start,,,3,"int vout_window_start (void*,va_list)"
212451,METHOD,video_output\window.c:<global>,TYPE_DECL,"int (*activate)(vout_window_t *, const vout_window_cfg_t *) = func;",9,70,video_output\window.c,vout_window_start.activate,,false,47,47,activate,,,1,"int vout_window_start.activate (vout_window_t*,vout_window_cfg_t*)"
212467,METHOD,video_output\window.c:<global>,TYPE_DECL,"vout_window_t *vout_window_New(vlc_object_t *obj, const char *module,
                               const vout_window_cfg_t *cfg,
                               const vout_window_owner_t *owner)
{
    window_t *w = vlc_custom_create(obj, sizeof(*w), ""window"");
    vout_window_t *window = &w->wnd;

    memset(&window->handle, 0, sizeof(window->handle));
    window->info.has_double_click = false;
    window->control = NULL;
    window->sys = NULL;

    if (owner != NULL)
        window->owner = *owner;
    else
        window->owner.resized = NULL;

    w->module = vlc_module_load(window, ""vout window"", module,
                                module && *module,
                                vout_window_start, window, cfg);
    if (!w->module) {
        vlc_object_release(window);
        return NULL;
    }

    /* Hook for screensaver inhibition */
    if (var_InheritBool(obj, ""disable-screensaver"") &&
        (window->type == VOUT_WINDOW_TYPE_XID || window->type == VOUT_WINDOW_TYP...",1,1,video_output\window.c,vout_window_New,,false,54,91,vout_window_New,,,4,"vout_window_t vout_window_New (vlc_object_t*,char*,vout_window_cfg_t*,vout_window_owner_t*)"
212614,METHOD,video_output\window.c:<global>,TYPE_DECL,"static void vout_window_stop(void *func, va_list ap)
{
    int (*deactivate)(vout_window_t *) = func;
    vout_window_t *wnd = va_arg(ap, vout_window_t *);

    deactivate(wnd);
}",1,1,video_output\window.c,vout_window_stop,,false,93,99,vout_window_stop,,,5,"void vout_window_stop (void*,va_list)"
212618,METHOD,video_output\window.c:<global>,TYPE_DECL,int (*deactivate)(vout_window_t *) = func;,9,45,video_output\window.c,vout_window_stop.deactivate,,false,95,95,deactivate,,,1,int vout_window_stop.deactivate (vout_window_t*)
212628,METHOD,video_output\window.c:<global>,TYPE_DECL,"void vout_window_Delete(vout_window_t *window)
{
    if (!window)
        return;

    window_t *w = (window_t *)window;
    if (w->inhibit)
    {
        vlc_inhibit_Set (w->inhibit, VLC_INHIBIT_NONE);
        vlc_inhibit_Destroy (w->inhibit);
    }

    vlc_module_unload(window, w->module, vout_window_stop, window);
    vlc_object_release(window);
}",1,1,video_output\window.c,vout_window_Delete,,false,101,115,vout_window_Delete,,,6,void vout_window_Delete (vout_window_t*)
212667,METHOD,video_output\window.c:<global>,TYPE_DECL,"void vout_window_SetInhibition(vout_window_t *window, bool enabled)
{
    window_t *w = (window_t *)window;
    unsigned flags = enabled ? VLC_INHIBIT_VIDEO : VLC_INHIBIT_NONE;

    if (w->inhibit != NULL)
        vlc_inhibit_Set(w->inhibit, flags);
}",1,1,video_output\window.c,vout_window_SetInhibition,,false,117,124,vout_window_SetInhibition,,,7,"void vout_window_SetInhibition (vout_window_t*,bool)"
212704,METHOD,video_output\window.c:<global>,TYPE_DECL,"static void vout_display_window_ResizeNotify(vout_window_t *window,
                                             unsigned width, unsigned height)
{
    vout_display_window_t *state = window->owner.sys;

    msg_Dbg(window, ""resized to %ux%u"", width, height);
    vlc_mutex_lock(&state->lock);
    state->width = width;
    state->height = height;

    if (state->vd != NULL)
        vout_display_SendEventDisplaySize(state->vd, width, height);
    vlc_mutex_unlock(&state->lock);
}",1,1,video_output\window.c,vout_display_window_ResizeNotify,,false,141,154,vout_display_window_ResizeNotify,,,10,"void vout_display_window_ResizeNotify (vout_window_t*,unsigned,unsigned)"
212757,METHOD,video_output\window.c:<global>,TYPE_DECL,"static void vout_display_window_CloseNotify(vout_window_t *window)
{
    vout_thread_t *vout = (vout_thread_t *)window->obj.parent;

    vout_SendEventClose(vout);
}",1,1,video_output\window.c,vout_display_window_CloseNotify,,false,156,161,vout_display_window_CloseNotify,,,11,void vout_display_window_CloseNotify (vout_window_t*)
212774,METHOD,video_output\window.c:<global>,TYPE_DECL,"static void vout_display_window_MouseEvent(vout_window_t *window,
                                           const vout_window_mouse_event_t *mouse)
{
    vout_thread_t *vout = (vout_thread_t *)window->obj.parent;
    vout_WindowMouseEvent(vout, mouse);
}",1,1,video_output\window.c,vout_display_window_MouseEvent,,false,163,168,vout_display_window_MouseEvent,,,12,"void vout_display_window_MouseEvent (vout_window_t*,vout_window_mouse_event_t*)"
212793,METHOD,video_output\window.c:<global>,TYPE_DECL,"vout_window_t *vout_display_window_New(vout_thread_t *vout,
                                       const vout_window_cfg_t *cfg)
{
    vout_display_window_t *state = malloc(sizeof (*state));
    if (state == NULL)
        return NULL;

    state->vd = NULL;
    state->width = cfg->width;
    state->height = cfg->height;
    vlc_mutex_init(&state->lock);

    vout_window_owner_t owner = {
        .sys = state,
        .resized = vout_display_window_ResizeNotify,
        .closed = vout_display_window_CloseNotify,
        .mouse_event = vout_display_window_MouseEvent,
    };
    vout_window_t *window;

    window = vout_window_New((vlc_object_t *)vout, ""$window"", cfg, &owner);
    if (window == NULL) {
        vlc_mutex_destroy(&state->lock);
        free(state);
    }
    return window;
}",1,1,video_output\window.c,vout_display_window_New,,false,173,199,vout_display_window_New,,,13,"vout_window_t vout_display_window_New (vout_thread_t*,vout_window_cfg_t*)"
212882,METHOD,video_output\window.c:<global>,TYPE_DECL,"void vout_display_window_Attach(vout_window_t *window, vout_display_t *vd)
{
    vout_display_window_t *state = window->owner.sys;

    vout_window_SetSize(window,
                        vd->cfg->display.width, vd->cfg->display.height);

    vlc_mutex_lock(&state->lock);
    state->vd = vd;

    vout_display_SendEventDisplaySize(vd, state->width, state->height);
    vlc_mutex_unlock(&state->lock);
}",1,1,video_output\window.c,vout_display_window_Attach,,false,205,217,vout_display_window_Attach,,,14,"void vout_display_window_Attach (vout_window_t*,vout_display_t*)"
212935,METHOD,video_output\window.c:<global>,TYPE_DECL,"void vout_display_window_Detach(vout_window_t *window)
{
    vout_display_window_t *state = window->owner.sys;

    vlc_mutex_lock(&state->lock);
    state->vd = NULL;
    vlc_mutex_unlock(&state->lock);
}",1,1,video_output\window.c,vout_display_window_Detach,,false,223,230,vout_display_window_Detach,,,15,void vout_display_window_Detach (vout_window_t*)
212963,METHOD,video_output\window.c:<global>,TYPE_DECL,"void vout_display_window_Delete(vout_window_t *window)
{
    vout_display_window_t *state = window->owner.sys;

    vout_window_Delete(window);

    assert(state->vd == NULL);
    vlc_mutex_destroy(&state->lock);
    free(state);
}",1,1,video_output\window.c,vout_display_window_Delete,,false,236,245,vout_display_window_Delete,,,16,void vout_display_window_Delete (vout_window_t*)
212994,METHOD,video_output\window.h:<global>,TYPE_DECL,<global>,1,49,video_output\window.h,video_output\window.h:<global>,,false,1,25,<global>,,,1,
212996,METHOD,video_output\window.h:<global>,TYPE_DECL,"vout_window_t *vout_display_window_New(vout_thread_t *,
                                       const vout_window_cfg_t *);",15,65,video_output\window.h,vout_display_window_New,,false,21,22,vout_display_window_New,,,1,"vout_window_t* vout_display_window_New (vout_thread_t*,vout_window_cfg_t*)"
213002,METHOD,video_output\window.h:<global>,TYPE_DECL,"void vout_display_window_Attach(vout_window_t *, vout_display_t *);",6,66,video_output\window.h,vout_display_window_Attach,,false,23,23,vout_display_window_Attach,,,2,"void vout_display_window_Attach (vout_window_t*,vout_display_t*)"
213008,METHOD,video_output\window.h:<global>,TYPE_DECL,void vout_display_window_Detach(vout_window_t *);,6,48,video_output\window.h,vout_display_window_Detach,,false,24,24,vout_display_window_Detach,,,3,void vout_display_window_Detach (vout_window_t*)
213013,METHOD,video_output\window.h:<global>,TYPE_DECL,void vout_display_window_Delete(vout_window_t *);,6,48,video_output\window.h,vout_display_window_Delete,,false,25,25,vout_display_window_Delete,,,4,void vout_display_window_Delete (vout_window_t*)
213049,METHOD,win32\dirs.c:<global>,TYPE_DECL,<global>,1,1,win32\dirs.c,win32\dirs.c:<global>,,false,1,285,<global>,,,1,
213051,METHOD,win32\dirs.c:<global>,TYPE_DECL,"char *config_GetLibDir (void)
{
#if VLC_WINSTORE_APP
    return NULL;
#else
    /* Get our full path */
    MEMORY_BASIC_INFORMATION mbi;
    if (!VirtualQuery (config_GetLibDir, &mbi, sizeof(mbi)))
        goto error;

    wchar_t wpath[MAX_PATH];
    if (!GetModuleFileName ((HMODULE) mbi.AllocationBase, wpath, MAX_PATH))
        goto error;

    wchar_t *file = wcsrchr (wpath, L'\\');
    if (file == NULL)
        goto error;
    *file = L'\0';

    return FromWide (wpath);
error:
    abort ();
#endif
}",1,1,win32\dirs.c,config_GetLibDir,,false,184,207,config_GetLibDir,,,1,char* config_GetLibDir (void)
213101,METHOD,win32\dirs.c:<global>,TYPE_DECL,"char *config_GetDataDir (void)
{
    const char *path = getenv (""VLC_DATA_PATH"");
    return (path != NULL) ? strdup (path) : config_GetLibDir ();
}",1,1,win32\dirs.c,config_GetDataDir,,false,209,213,config_GetDataDir,,,2,char* config_GetDataDir (void)
213119,METHOD,win32\dirs.c:<global>,TYPE_DECL,"static char *config_GetShellDir (int csidl)
{
    wchar_t wdir[MAX_PATH];

    if (SHGetFolderPathW (NULL, csidl | CSIDL_FLAG_CREATE,
                          NULL, SHGFP_TYPE_CURRENT, wdir ) == S_OK)
        return FromWide (wdir);
    return NULL;
}",1,1,win32\dirs.c,config_GetShellDir,,false,215,223,config_GetShellDir,,,3,char* config_GetShellDir (int)
213142,METHOD,win32\dirs.c:<global>,TYPE_DECL,"static char *config_GetAppDir (void)
{
#if !VLC_WINSTORE_APP
    /* if portable directory exists, use it */
    TCHAR path[MAX_PATH];
    if (GetModuleFileName (NULL, path, MAX_PATH))
    {
        TCHAR *lastDir = _tcsrchr (path, '\\');
        if (lastDir)
        {
            _tcscpy (lastDir + 1, TEXT(""portable""));
            DWORD attrib = GetFileAttributes (path);
            if (attrib != INVALID_FILE_ATTRIBUTES &&
                    (attrib & FILE_ATTRIBUTE_DIRECTORY))
                return FromT (path);
        }
    }
#endif

    char *psz_dir;
    char *psz_parent = config_GetShellDir (CSIDL_APPDATA);

    if (psz_parent == NULL
     ||  asprintf (&psz_dir, ""%s\\vlc"", psz_parent) == -1)
        psz_dir = NULL;
    free (psz_parent);
    return psz_dir;
}",1,1,win32\dirs.c,config_GetAppDir,,false,225,252,config_GetAppDir,,,4,char* config_GetAppDir (void)
213213,METHOD,win32\dirs.c:<global>,TYPE_DECL,"char *config_GetUserDir (vlc_userdir_t type)
{
    switch (type)
    {
        case VLC_HOME_DIR:
            return config_GetShellDir (CSIDL_PERSONAL);
        case VLC_CONFIG_DIR:
        case VLC_DATA_DIR:
            return config_GetAppDir ();
        case VLC_CACHE_DIR:
#if !VLC_WINSTORE_APP
            return config_GetAppDir ();
#else
            return config_GetShellDir (CSIDL_LOCAL_APPDATA);
#endif

        case VLC_DESKTOP_DIR:
        case VLC_DOWNLOAD_DIR:
        case VLC_TEMPLATES_DIR:
        case VLC_PUBLICSHARE_DIR:
        case VLC_DOCUMENTS_DIR:
            return config_GetUserDir(VLC_HOME_DIR);
        case VLC_MUSIC_DIR:
            return config_GetShellDir (CSIDL_MYMUSIC);
        case VLC_PICTURES_DIR:
            return config_GetShellDir (CSIDL_MYPICTURES);
        case VLC_VIDEOS_DIR:
            return config_GetShellDir (CSIDL_MYVIDEO);
    }
    vlc_assert_unreachable ();
}",1,1,win32\dirs.c,config_GetUserDir,,false,255,285,config_GetUserDir,,,5,char* config_GetUserDir (vlc_userdir_t)
213278,METHOD,win32\error.c:<global>,TYPE_DECL,<global>,1,6,win32\error.c,win32\error.c:<global>,,false,1,153,<global>,,,1,
213560,METHOD,win32\error.c:<global>,TYPE_DECL,"const char *vlc_strerror_c(int errnum)
{
    /* C run-time errors */
    if ((unsigned)errnum < (unsigned)_sys_nerr)
        return _sys_errlist[errnum];

    /* Windows socket errors */
    for (const wsaerrmsg_t *e = wsaerrmsg; e->msg != NULL; e++)
        if (e->code == errnum)
            return e->msg;

    return ""Unknown error"";
}",1,1,win32\error.c,vlc_strerror_c,,false,136,148,vlc_strerror_c,,,5,const char* vlc_strerror_c (int)
213604,METHOD,win32\error.c:<global>,TYPE_DECL,"const char *vlc_strerror(int errnum)
{
    return /*vlc_gettext*/(vlc_strerror_c(errnum));
}",1,1,win32\error.c,vlc_strerror,,false,150,153,vlc_strerror,,,6,const char* vlc_strerror (int)
213647,METHOD,win32\filesystem.c:<global>,TYPE_DECL,<global>,1,20,win32\filesystem.c,win32\filesystem.c:<global>,,false,1,397,<global>,,,1,
213649,METHOD,win32\filesystem.c:<global>,TYPE_DECL,"static wchar_t *widen_path (const char *path)
{
    wchar_t *wpath;

    errno = 0;
    wpath = ToWide (path);
    if (wpath == NULL)
    {
        if (errno == 0)
            errno = ENOENT;
        return NULL;
    }
    return wpath;
}",1,1,win32\filesystem.c,widen_path,,false,52,65,widen_path,,,1,wchar_t widen_path (char*)
213679,METHOD,win32\filesystem.c:<global>,TYPE_DECL,"int vlc_open (const char *filename, int flags, ...)
{
    int mode = 0;
    va_list ap;

    flags |= O_NOINHERIT; /* O_CLOEXEC */
    /* Defaults to binary mode */
    if ((flags & O_TEXT) == 0)
        flags |= O_BINARY;

    va_start (ap, flags);
    if (flags & O_CREAT)
    {
        int unixmode = va_arg(ap, int);
        if (unixmode & 0444)
            mode |= _S_IREAD;
        if (unixmode & 0222)
            mode |= _S_IWRITE;
    }
    va_end (ap);

    /*
     * open() cannot open files with non-ANSI characters on Windows.
     * We use _wopen() instead. Same thing for mkdir() and stat().
     */
    wchar_t *wpath = widen_path (filename);
    if (wpath == NULL)
        return -1;

    int fd = _wopen (wpath, flags, mode);
    free (wpath);
    return fd;
}",1,1,win32\filesystem.c,vlc_open,,false,72,104,vlc_open,,,2,"int vlc_open (char*,int...)"
213754,METHOD,win32\filesystem.c:<global>,TYPE_DECL,"int vlc_openat (int dir, const char *filename, int flags, ...)
{
    (void) dir; (void) filename; (void) flags;
    errno = ENOSYS;
    return -1;
}",1,1,win32\filesystem.c,vlc_openat,,false,106,111,vlc_openat,,,3,"int vlc_openat (int,char*,int...)"
213776,METHOD,win32\filesystem.c:<global>,TYPE_DECL,"int vlc_memfd (void)
{
#if 0
    int fd, err;

    FILE *stream = tmpfile();
    if (stream == NULL)
        return -1;

    fd = vlc_dup(fileno(stream));
    err = errno;
    fclose(stream);
    errno = err;
    return fd;
#else /* Not currently used */
    errno = ENOSYS;
    return -1;
#endif
}",1,1,win32\filesystem.c,vlc_memfd,,false,113,131,vlc_memfd,,,4,int vlc_memfd (void)
213787,METHOD,win32\filesystem.c:<global>,TYPE_DECL,"int vlc_close (int fd)
{
    return close (fd);
}",1,1,win32\filesystem.c,vlc_close,,false,133,136,vlc_close,,,5,int vlc_close (int)
213795,METHOD,win32\filesystem.c:<global>,TYPE_DECL,"int vlc_mkdir( const char *dirname, mode_t mode )
{
    wchar_t *wpath = widen_path (dirname);
    if (wpath == NULL)
        return -1;

    int ret = _wmkdir (wpath);
    free (wpath);
    (void) mode;
    return ret;
}",1,1,win32\filesystem.c,vlc_mkdir,,false,138,148,vlc_mkdir,,,6,"int vlc_mkdir (char*,mode_t)"
213826,METHOD,win32\filesystem.c:<global>,TYPE_DECL,"char *vlc_getcwd (void)
{
#if VLC_WINSTORE_APP
    return NULL;
#else
    wchar_t *wdir = _wgetcwd (NULL, 0);
    if (wdir == NULL)
        return NULL;

    char *dir = FromWide (wdir);
    free (wdir);
    return dir;
#endif
}",1,1,win32\filesystem.c,vlc_getcwd,,false,150,163,vlc_getcwd,,,7,char* vlc_getcwd (void)
213853,METHOD,win32\filesystem.c:<global>,TYPE_DECL,"DIR *vlc_opendir (const char *dirname)
{
    wchar_t *wpath = widen_path (dirname);
    if (wpath == NULL)
        return NULL;

    vlc_DIR *p_dir = malloc (sizeof (*p_dir));
    if (unlikely(p_dir == NULL))
    {
        free(wpath);
        return NULL;
    }

#if !VLC_WINSTORE_APP
    /* Special mode to list drive letters */
    if (wpath[0] == L'\0' || (wcscmp (wpath, L""\\"") == 0))
    {
        free (wpath);
        p_dir->wdir = NULL;
        p_dir->u.drives = GetLogicalDrives ();
        p_dir->entry = NULL;
        return (void *)p_dir;
    }
#endif

    assert (wpath[0]); // wpath[1] is defined
    p_dir->u.insert_dot_dot = !wcscmp (wpath + 1, L"":\\"");

    _WDIR *wdir = _wopendir (wpath);
    free (wpath);
    if (wdir == NULL)
    {
        free (p_dir);
        return NULL;
    }
    p_dir->wdir = wdir;
    p_dir->entry = NULL;
    return (void *)p_dir;
}",1,1,win32\filesystem.c,vlc_opendir,,false,167,205,vlc_opendir,,,8,DIR vlc_opendir (char*)
213969,METHOD,win32\filesystem.c:<global>,TYPE_DECL,"const char *vlc_readdir (DIR *dir)
{
    vlc_DIR *p_dir = (vlc_DIR *)dir;

    free(p_dir->entry);

#if !VLC_WINSTORE_APP
    /* Drive letters mode */
    if (p_dir->wdir == NULL)
    {
        DWORD drives = p_dir->u.drives;
        if (drives == 0)
        {
            p_dir->entry = NULL;
            return NULL; /* end */
        }

        unsigned int i;
        for (i = 0; !(drives & 1); i++)
            drives >>= 1;
        p_dir->u.drives &= ~(1UL << i);
        assert (i < 26);

        if (asprintf (&p_dir->entry, ""%c:\\"", 'A' + i) == -1)
            p_dir->entry = NULL;
    }
    else
#endif
    if (p_dir->u.insert_dot_dot)
    {
        /* Adds "".."", gruik! */
        p_dir->u.insert_dot_dot = false;
        p_dir->entry = strdup ("".."");
    }
    else
    {
        struct _wdirent *ent = _wreaddir (p_dir->wdir);
        p_dir->entry = (ent != NULL) ? FromWide (ent->d_name) : NULL;
    }
    return p_dir->entry;
}",1,1,win32\filesystem.c,vlc_readdir,,false,207,247,vlc_readdir,,,9,const char* vlc_readdir (DIR*)
214107,METHOD,win32\filesystem.c:<global>,TYPE_DECL,"int vlc_stat (const char *filename, struct stat *buf)
{
    wchar_t *wpath = widen_path (filename);
    if (wpath == NULL)
        return -1;

    static_assert (sizeof (*buf) == sizeof (struct _stati64),
                   ""Mismatched struct stat definition."");

    int ret = _wstati64 (wpath, buf);
    free (wpath);
    return ret;
}",1,1,win32\filesystem.c,vlc_stat,,false,249,261,vlc_stat,,,10,"int vlc_stat (char*,stat*)"
214144,METHOD,win32\filesystem.c:<global>,TYPE_DECL,"int vlc_lstat (const char *filename, struct stat *buf)
{
    return vlc_stat (filename, buf);
}",1,1,win32\filesystem.c,vlc_lstat,,false,263,266,vlc_lstat,,,11,"int vlc_lstat (char*,stat*)"
214154,METHOD,win32\filesystem.c:<global>,TYPE_DECL,"int vlc_unlink (const char *filename)
{
    wchar_t *wpath = widen_path (filename);
    if (wpath == NULL)
        return -1;

    int ret = _wunlink (wpath);
    free (wpath);
    return ret;
}",1,1,win32\filesystem.c,vlc_unlink,,false,268,277,vlc_unlink,,,12,int vlc_unlink (char*)
214181,METHOD,win32\filesystem.c:<global>,TYPE_DECL,"int vlc_rename (const char *oldpath, const char *newpath)
{
    int ret = -1;

    wchar_t *wold = widen_path (oldpath), *wnew = widen_path (newpath);
    if (wold == NULL || wnew == NULL)
        goto out;

    if (_wrename (wold, wnew) && (errno == EACCES || errno == EEXIST))
    {   /* Windows does not allow atomic file replacement */
        if (_wremove (wnew))
        {
            errno = EACCES; /* restore errno */
            goto out;
        }
        if (_wrename (wold, wnew))
            goto out;
    }
    ret = 0;
out:
    free (wnew);
    free (wold);
    return ret;
}",1,1,win32\filesystem.c,vlc_rename,,false,279,302,vlc_rename,,,13,"int vlc_rename (char*,char*)"
214249,METHOD,win32\filesystem.c:<global>,TYPE_DECL,"int vlc_dup (int oldfd)
{
    int fd = dup (oldfd);
    if (fd != -1)
        setmode (fd, O_BINARY);
    return fd;
}",1,1,win32\filesystem.c,vlc_dup,,false,304,310,vlc_dup,,,14,int vlc_dup (int)
214270,METHOD,win32\filesystem.c:<global>,TYPE_DECL,"int vlc_pipe (int fds[2])
{
#if VLC_WINSTORE_APP
    _set_errno(EPERM);
    return -1;
#else
    return _pipe (fds, 32768, O_NOINHERIT | O_BINARY);
#endif
}",1,1,win32\filesystem.c,vlc_pipe,,false,312,320,vlc_pipe,,,15,int vlc_pipe (int[2])
214282,METHOD,win32\filesystem.c:<global>,TYPE_DECL,"ssize_t vlc_write(int fd, const void *buf, size_t len)
{
    return write(fd, buf, len);
}",1,1,win32\filesystem.c,vlc_write,,false,322,325,vlc_write,,,16,"ssize_t vlc_write (int,void*,size_t)"
214294,METHOD,win32\filesystem.c:<global>,TYPE_DECL,"ssize_t vlc_writev(int fd, const struct iovec *iov, int count)
{
    vlc_assert_unreachable();
}",1,1,win32\filesystem.c,vlc_writev,,false,327,330,vlc_writev,,,17,"ssize_t vlc_writev (int,iovec*,int)"
214302,METHOD,win32\filesystem.c:<global>,TYPE_DECL,"int vlc_socket (int pf, int type, int proto, bool nonblock)
{
    int fd = socket (pf, type, proto);
    if (fd == -1)
        return -1;

    if (nonblock)
        ioctlsocket (fd, FIONBIO, &(unsigned long){ 1 });
    return fd;
}",1,1,win32\filesystem.c,vlc_socket,,false,334,343,vlc_socket,,,18,"int vlc_socket (int,int,int,bool)"
214339,METHOD,win32\filesystem.c:<global>,TYPE_DECL,"int vlc_socketpair(int pf, int type, int proto, int fds[2], bool nonblock)
{
    (void) pf; (void) type; (void) proto; (void) fds; (void) nonblock;
    errno = ENOSYS;
    return -1;
}",1,1,win32\filesystem.c,vlc_socketpair,,false,345,350,vlc_socketpair,,,19,"int vlc_socketpair (int,int,int,int[2],bool)"
214369,METHOD,win32\filesystem.c:<global>,TYPE_DECL,"int vlc_accept (int lfd, struct sockaddr *addr, socklen_t *alen, bool nonblock)
{
    int fd = accept (lfd, addr, alen);
    if (fd != -1 && nonblock)
        ioctlsocket (fd, FIONBIO, &(unsigned long){ 1 });
    return fd;
}",1,1,win32\filesystem.c,vlc_accept,,false,352,358,vlc_accept,,,20,"int vlc_accept (int,sockaddr*,socklen_t*,bool)"
214402,METHOD,win32\filesystem.c:<global>,TYPE_DECL,"FILE *vlc_win32_tmpfile(void)
{
    TCHAR tmp_path[MAX_PATH-14];
    int i_ret = GetTempPath (MAX_PATH-14, tmp_path);
    if (i_ret == 0)
        return NULL;

    TCHAR tmp_name[MAX_PATH];
    i_ret = GetTempFileName(tmp_path, TEXT(""VLC""), 0, tmp_name);
    if (i_ret == 0)
        return NULL;

    HANDLE hFile = CreateFile(tmp_name,
            GENERIC_READ | GENERIC_WRITE | DELETE, 0, NULL, CREATE_ALWAYS,
            FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_DELETE_ON_CLOSE, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
        return NULL;

    int fd = _open_osfhandle((intptr_t)hFile, 0);
    if (fd == -1) {
        CloseHandle(hFile);
        return NULL;
    }

    FILE *stream = _fdopen(fd, ""w+b"");
    if (stream == NULL) {
        _close(fd);
        return NULL;
    }
    return stream;
}",1,1,win32\filesystem.c,vlc_win32_tmpfile,,false,361,391,vlc_win32_tmpfile,,,21,FILE vlc_win32_tmpfile (void)
214509,METHOD,win32\mta_holder.h:<global>,TYPE_DECL,<global>,1,6,win32\mta_holder.h,win32\mta_holder.h:<global>,,false,1,121,<global>,,,1,
214517,METHOD,win32\mta_holder.h:<global>,TYPE_DECL,"static inline void* MtaMainLoop( void* opaque )
{
    vlc_mta_holder* p_mta = (vlc_mta_holder*)opaque;
    CoInitializeEx( NULL, COINIT_MULTITHREADED );

    vlc_sem_post( &p_mta->ready_sem );

    vlc_sem_wait( &p_mta->release_sem );

    CoUninitialize();
    return NULL;
}",1,1,win32\mta_holder.h,MtaMainLoop,,false,40,51,MtaMainLoop,,,3,void* MtaMainLoop (void*)
214544,METHOD,win32\mta_holder.h:<global>,TYPE_DECL,"static inline bool vlc_mta_acquire( vlc_object_t *p_parent )
{
    vlc_global_lock( VLC_MTA_MUTEX );
    vlc_mta_holder* p_mta = (vlc_mta_holder*)var_CreateGetAddress( p_parent->obj.libvlc, ""mta-holder"" );
    if ( p_mta == NULL )
    {
        p_mta = (vlc_mta_holder*)malloc( sizeof( *p_mta ) );
        if ( unlikely( p_mta == NULL ) )
        {
            vlc_global_unlock( VLC_MTA_MUTEX );
            return false;
        }
        vlc_sem_init( &p_mta->ready_sem, 0 );
        vlc_sem_init( &p_mta->release_sem, 0 );
        p_mta->i_refcount = 1;
        if ( vlc_clone( &p_mta->thread, MtaMainLoop, p_mta, VLC_THREAD_PRIORITY_LOW ) )
        {
            vlc_sem_destroy( &p_mta->release_sem );
            vlc_sem_destroy( &p_mta->ready_sem );
            free( p_mta );
            p_mta = NULL;
            vlc_global_unlock( VLC_MTA_MUTEX );
            return false;
        }
        var_SetAddress( p_parent->obj.libvlc, ""mta-holder"", p_mta );
        vlc_sem_wait( &p_mta->rea...",1,1,win32\mta_holder.h,vlc_mta_acquire,,false,62,93,vlc_mta_acquire,,,4,bool vlc_mta_acquire (vlc_object_t*)
214655,METHOD,win32\mta_holder.h:<global>,TYPE_DECL,"static inline void vlc_mta_release( vlc_object_t* p_parent )
{
    vlc_global_lock( VLC_MTA_MUTEX );
    vlc_mta_holder *p_mta = (vlc_mta_holder*)var_InheritAddress( p_parent->obj.libvlc, ""mta-holder"" );
    assert( p_mta != NULL );
    int i_refcount = --p_mta->i_refcount;
    if ( i_refcount == 0 )
        var_SetAddress( p_parent->obj.libvlc, ""mta-holder"", NULL );
    vlc_global_unlock( VLC_MTA_MUTEX );
    if ( i_refcount == 0 )
    {
        vlc_sem_post( &p_mta->release_sem );

        vlc_join( p_mta->thread, NULL );

        vlc_sem_destroy( &p_mta->release_sem );
        vlc_sem_destroy( &p_mta->ready_sem );
        free( p_mta );
    }
}",1,1,win32\mta_holder.h,vlc_mta_release,,false,100,119,vlc_mta_release,,,5,void vlc_mta_release (vlc_object_t*)
214742,METHOD,win32\netconf.c:<global>,TYPE_DECL,<global>,1,1,win32\netconf.c,win32\netconf.c:<global>,,false,1,110,<global>,,,1,
214744,METHOD,win32\netconf.c:<global>,TYPE_DECL,"char *vlc_getProxyUrl(const char *psz_url)
{
    VLC_UNUSED(psz_url);

    char *proxy = config_GetPsz( (vlc_object_t *)(NULL), ""http-proxy"" );
    if (proxy == NULL)
        return NULL;

    char *proxy_pwd = config_GetPsz( (vlc_object_t *)(NULL), ""http-proxy-pwd"" );
    if (proxy_pwd == NULL)
        return proxy;

    vlc_url_t url;
    if (vlc_UrlParse(&url, proxy) < 0) {
        vlc_UrlClean(&url);
        free (proxy);
        free (proxy_pwd);
        return NULL;
    }

    if (url.psz_password == NULL )
        url.psz_password = proxy_pwd;

    char *proxy_url = vlc_uri_compose (&url);
    vlc_UrlClean (&url);

    free (proxy_pwd);
    free (proxy);

#if 0
    /* Try to get the proxy server address from Windows internet settings. */
    HKEY h_key;

    /* Open the key */
    if( RegOpenKeyEx( HKEY_CURRENT_USER, ""Software\\Microsoft""
                      ""\\Windows\\CurrentVersion\\Internet Settings"",
                      0, KEY_READ, &h_key ) == ERROR_SUCCESS )
      ...",1,1,win32\netconf.c,vlc_getProxyUrl,,false,32,110,vlc_getProxyUrl,,,1,char* vlc_getProxyUrl (char*)
214841,METHOD,win32\plugin.c:<global>,TYPE_DECL,<global>,1,25,win32\plugin.c,win32\plugin.c:<global>,,false,1,135,<global>,,,1,
214844,METHOD,win32\plugin.c:<global>,TYPE_DECL,"static char *GetWindowsError( void )
{
    wchar_t wmsg[256];
    int i = 0, i_error = GetLastError();

    FormatMessageW( FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                    NULL, i_error, MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT),
                    wmsg, 256, NULL );

    /* Go to the end of the string */
    while( !wmemchr( L""\r\n\0"", wmsg[i], 3 ) )
        i++;

    snwprintf( wmsg + i, 256 - i, L"" (error %i)"", i_error );
    return FromWide( wmsg );
}",1,1,win32\plugin.c,GetWindowsError,,false,77,92,GetWindowsError,,,2,char* GetWindowsError (void)
214892,METHOD,win32\plugin.c:<global>,TYPE_DECL,"int module_Load( vlc_object_t *p_this, const char *psz_file,
                 module_handle_t *p_handle, bool lazy )
{
    wchar_t *wfile = ToWide (psz_file);
    if (wfile == NULL)
        return -1;

    module_handle_t handle = NULL;
#if !VLC_WINSTORE_APP
    DWORD mode;
    if (SetThreadErrorMode (SEM_FAILCRITICALERRORS, &mode) != 0)
    {
        handle = LoadLibraryExW (wfile, NULL, LoadLibraryFlags );
        SetThreadErrorMode (mode, NULL);
    }
#else
    handle = LoadPackagedLibrary( wfile, 0 );
#endif
    free (wfile);

    if( handle == NULL )
    {
        char *psz_err = GetWindowsError();
        msg_Warn( p_this, ""cannot load module `%s' (%s)"", psz_file, psz_err );
        free( psz_err );
        return -1;
    }

    *p_handle = handle;
    (void) lazy;
    return 0;
}",1,1,win32\plugin.c,module_Load,,false,94,125,module_Load,,,3,"int module_Load (vlc_object_t*,char*,module_handle_t*,bool)"
214965,METHOD,win32\plugin.c:<global>,TYPE_DECL,"void module_Unload( module_handle_t handle )
{
    FreeLibrary( handle );
}",1,1,win32\plugin.c,module_Unload,,false,127,130,module_Unload,,,4,void module_Unload (module_handle_t)
214972,METHOD,win32\plugin.c:<global>,TYPE_DECL,"void *module_Lookup( module_handle_t handle, const char *psz_function )
{
    return (void *)GetProcAddress( handle, (char *)psz_function );
}",1,1,win32\plugin.c,module_Lookup,,false,132,135,module_Lookup,,,5,"void* module_Lookup (module_handle_t,char*)"
215003,METHOD,win32\rand.c:<global>,TYPE_DECL,<global>,1,1,win32\rand.c,win32\rand.c:<global>,,false,1,109,<global>,,,1,
215005,METHOD,win32\rand.c:<global>,TYPE_DECL,"void vlc_rand_bytes (void *buf, size_t len)
{
    size_t count = len;
    uint8_t *p_buf = (uint8_t *)buf;

    /* fill buffer with pseudo-random data */
    while (count > 0)
    {
        unsigned int val;
        val = rand();
        if (count < sizeof (val))
        {
            memcpy (p_buf, &val, count);
            break;
        }

        memcpy (p_buf, &val, sizeof (val));
        count -= sizeof (val);
        p_buf += sizeof (val);
    }

#if VLC_WINSTORE_APP
    static const WCHAR *className = L""Windows.Security.Cryptography.CryptographicBuffer"";
    const UINT32 clen = wcslen(className);

    HSTRING hClassName = NULL;
    HSTRING_HEADER header;
    HRESULT hr = WindowsCreateStringReference(className, clen, &header, &hClassName);
    if (hr) {
        WindowsDeleteString(hClassName);
        return;
    }

    ICryptographicBufferStatics *cryptoStatics = NULL;
    hr = RoGetActivationFactory(hClassName, &IID_ICryptographicBufferStatics, (void**)&cryptoStatics);
    ...",1,1,win32\rand.c,vlc_rand_bytes,,false,39,109,vlc_rand_bytes,,,1,"void vlc_rand_bytes (void*,size_t)"
215090,METHOD,win32\specific.c:<global>,TYPE_DECL,<global>,1,24,win32\specific.c,win32\specific.c:<global>,,false,1,191,<global>,,,1,
215096,METHOD,win32\specific.c:<global>,TYPE_DECL,"static int system_InitWSA(int hi, int lo)
{
    WSADATA data;

    if (WSAStartup(MAKEWORD(hi, lo), &data) == 0)
    {
        if (LOBYTE(data.wVersion) == 2 && HIBYTE(data.wVersion) == 2)
            return 0;
        /* Winsock DLL is not usable */
        WSACleanup( );
    }
    return -1;
}",1,1,win32\specific.c,system_InitWSA,,false,44,56,system_InitWSA,,,3,"int system_InitWSA (int,int)"
215134,METHOD,win32\specific.c:<global>,TYPE_DECL,"void system_Init(void)
{
    if (system_InitWSA(2, 2) && system_InitWSA(1, 1))
        fputs(""Error: cannot initialize Winsocks\n"", stderr);

#if !VLC_WINSTORE_APP
# if (_WIN32_WINNT < _WIN32_WINNT_WIN8)
    if (GetProcAddress(GetModuleHandle(TEXT(""kernel32.dll"")),
                                       ""SetDefaultDllDirectories"") != NULL)
# endif /* FIXME: not reentrant */
        LoadLibraryFlags = LOAD_LIBRARY_SEARCH_SYSTEM32;
#endif
}",1,1,win32\specific.c,system_Init,,false,61,73,system_Init,,,4,void system_Init (void)
215158,METHOD,<empty>,<empty>,<empty>,1,,win32\specific.c,vlc_ipc_data_t:<clinit>,,false,80,,<clinit>,,,4,
215164,METHOD,win32\specific.c:<global>,TYPE_DECL,"void system_Configure( libvlc_int_t *p_this, int i_argc, const char *const ppsz_argv[] )
{
#if !VLC_WINSTORE_APP
    if( var_InheritBool( p_this, ""one-instance"" )
     || ( var_InheritBool( p_this, ""one-instance-when-started-from-file"" )
       && var_InheritBool( p_this, ""started-from-file"" ) ) )
    {
        HANDLE hmutex;

        msg_Info( p_this, ""one instance mode ENABLED"");

        /* Use a named mutex to check if another instance is already running */
        if( !( hmutex = CreateMutex( 0, TRUE, L""VLC ipc "" TEXT(VERSION) ) ) )
        {
            /* Failed for some reason. Just ignore the option and go on as
             * normal. */
            msg_Err( p_this, ""one instance mode DISABLED ""
                     ""(mutex couldn't be created)"" );
            return;
        }

        if( GetLastError() != ERROR_ALREADY_EXISTS )
        {
            libvlc_InternalAddIntf( p_this, ""win_msg,none"" );
            /* Initialization done.
             * Release the mutex to u...",1,1,win32\specific.c,system_Configure,,false,87,182,system_Configure,,,7,"void system_Configure (libvlc_int_t*,int,char[]*)"
215356,METHOD,win32\specific.c:<global>,TYPE_DECL,"void system_End(void)
{
    /* XXX: In theory, we should not call this if WSAStartup() failed. */
    WSACleanup();
}",1,1,win32\specific.c,system_End,,false,187,191,system_End,,,8,void system_End (void)
215387,METHOD,win32\thread.c:<global>,TYPE_DECL,<global>,1,1,win32\thread.c,win32\thread.c:<global>,,false,1,1103,<global>,,,1,
215397,METHOD,vlc_thread,TYPE_DECL,void        *(*entry) (void *);,17,34,win32\thread.c,vlc_thread.entry,,false,62,62,entry,,,5,void* vlc_thread.entry (void*)
215407,METHOD,win32\thread.c:<global>,TYPE_DECL,"void vlc_mutex_init( vlc_mutex_t *p_mutex )
{
    /* This creates a recursive mutex. This is OK as fast mutexes have
     * no defined behavior in case of recursive locking. */
    InitializeCriticalSection (&p_mutex->mutex);
    p_mutex->dynamic = true;
}",1,1,win32\thread.c,vlc_mutex_init,,false,100,106,vlc_mutex_init,,,5,void vlc_mutex_init (vlc_mutex_t*)
215422,METHOD,win32\thread.c:<global>,TYPE_DECL,"void vlc_mutex_init_recursive( vlc_mutex_t *p_mutex )
{
    InitializeCriticalSection( &p_mutex->mutex );
    p_mutex->dynamic = true;
}",1,1,win32\thread.c,vlc_mutex_init_recursive,,false,108,112,vlc_mutex_init_recursive,,,6,void vlc_mutex_init_recursive (vlc_mutex_t*)
215437,METHOD,win32\thread.c:<global>,TYPE_DECL,"void vlc_mutex_destroy (vlc_mutex_t *p_mutex)
{
    assert (p_mutex->dynamic);
    DeleteCriticalSection (&p_mutex->mutex);
}",1,1,win32\thread.c,vlc_mutex_destroy,,false,115,119,vlc_mutex_destroy,,,7,void vlc_mutex_destroy (vlc_mutex_t*)
215451,METHOD,win32\thread.c:<global>,TYPE_DECL,"void vlc_mutex_lock (vlc_mutex_t *p_mutex)
{
    if (!p_mutex->dynamic)
    {   /* static mutexes */
        EnterCriticalSection(&super_mutex);
        while (p_mutex->locked)
        {
            p_mutex->contention++;
            SleepConditionVariableCS(&super_variable, &super_mutex, INFINITE);
            p_mutex->contention--;
        }
        p_mutex->locked = true;
        LeaveCriticalSection(&super_mutex);
        return;
    }

    EnterCriticalSection (&p_mutex->mutex);
}",1,1,win32\thread.c,vlc_mutex_lock,,false,121,138,vlc_mutex_lock,,,8,void vlc_mutex_lock (vlc_mutex_t*)
215498,METHOD,win32\thread.c:<global>,TYPE_DECL,"int vlc_mutex_trylock (vlc_mutex_t *p_mutex)
{
    if (!p_mutex->dynamic)
    {   /* static mutexes */
        int ret = EBUSY;

        EnterCriticalSection(&super_mutex);
        if (!p_mutex->locked)
        {
            p_mutex->locked = true;
            ret = 0;
        }
        LeaveCriticalSection(&super_mutex);
        return ret;
    }

    return TryEnterCriticalSection (&p_mutex->mutex) ? 0 : EBUSY;
}",1,1,win32\thread.c,vlc_mutex_trylock,,false,140,157,vlc_mutex_trylock,,,9,int vlc_mutex_trylock (vlc_mutex_t*)
215544,METHOD,win32\thread.c:<global>,TYPE_DECL,"void vlc_mutex_unlock (vlc_mutex_t *p_mutex)
{
    if (!p_mutex->dynamic)
    {   /* static mutexes */
        EnterCriticalSection(&super_mutex);
        assert (p_mutex->locked);
        p_mutex->locked = false;
        if (p_mutex->contention)
            WakeAllConditionVariable(&super_variable);
        LeaveCriticalSection(&super_mutex);
        return;
    }

    LeaveCriticalSection (&p_mutex->mutex);
}",1,1,win32\thread.c,vlc_mutex_unlock,,false,159,173,vlc_mutex_unlock,,,10,void vlc_mutex_unlock (vlc_mutex_t*)
215586,METHOD,vlc_threadvar,TYPE_DECL,void                (*destroy) (void *);,25,43,win32\thread.c,vlc_threadvar.destroy,,false,230,230,destroy,,,2,void vlc_threadvar.destroy (void*)
215599,METHOD,win32\thread.c:<global>,TYPE_DECL,"int vlc_threadvar_create (vlc_threadvar_t *p_tls, void (*destr) (void *))
{
    struct vlc_threadvar *var = malloc (sizeof (*var));
    if (unlikely(var == NULL))
        return errno;

    var->id = TlsAlloc();
    if (var->id == TLS_OUT_OF_INDEXES)
    {
        free (var);
        return EAGAIN;
    }
    var->destroy = destr;
    var->next = NULL;
    *p_tls = var;

    EnterCriticalSection(&super_mutex);
    var->prev = vlc_threadvar_last;
    if (var->prev)
        var->prev->next = var;

    vlc_threadvar_last = var;
    LeaveCriticalSection(&super_mutex);
    return 0;
}",1,1,win32\thread.c,vlc_threadvar_create,,false,235,259,vlc_threadvar_create,,,14,"int vlc_threadvar_create (vlc_threadvar_t*,void)"
215678,METHOD,win32\thread.c:<global>,TYPE_DECL,"void vlc_threadvar_delete (vlc_threadvar_t *p_tls)
{
    struct vlc_threadvar *var = *p_tls;

    EnterCriticalSection(&super_mutex);
    if (var->prev != NULL)
        var->prev->next = var->next;

    if (var->next != NULL)
        var->next->prev = var->prev;
    else
        vlc_threadvar_last = var->prev;

    LeaveCriticalSection(&super_mutex);

    TlsFree (var->id);
    free (var);
}",1,1,win32\thread.c,vlc_threadvar_delete,,false,261,278,vlc_threadvar_delete,,,15,void vlc_threadvar_delete (vlc_threadvar_t*)
215739,METHOD,win32\thread.c:<global>,TYPE_DECL,"int vlc_threadvar_set (vlc_threadvar_t key, void *value)
{
    int saved = GetLastError ();

    if (!TlsSetValue(key->id, value))
        return ENOMEM;

    SetLastError(saved);
    return 0;
}",1,1,win32\thread.c,vlc_threadvar_set,,false,280,289,vlc_threadvar_set,,,16,"int vlc_threadvar_set (vlc_threadvar_t,void*)"
215763,METHOD,win32\thread.c:<global>,TYPE_DECL,"void *vlc_threadvar_get (vlc_threadvar_t key)
{
    int saved = GetLastError ();
    void *value = TlsGetValue (key->id);

    SetLastError(saved);
    return value;
}",1,1,win32\thread.c,vlc_threadvar_get,,false,291,298,vlc_threadvar_get,,,17,void* vlc_threadvar_get (vlc_threadvar_t)
215783,METHOD,win32\thread.c:<global>,TYPE_DECL,"static void vlc_threadvars_cleanup(void)
{
    vlc_threadvar_t key;
retry:
    /* TODO: use RW lock or something similar */
    EnterCriticalSection(&super_mutex);
    for (key = vlc_threadvar_last; key != NULL; key = key->prev)
    {
        void *value = vlc_threadvar_get(key);
        if (value != NULL && key->destroy != NULL)
        {
            LeaveCriticalSection(&super_mutex);
            vlc_threadvar_set(key, NULL);
            key->destroy(value);
            goto retry;
        }
    }
    LeaveCriticalSection(&super_mutex);
}",1,1,win32\thread.c,vlc_threadvars_cleanup,,false,300,318,vlc_threadvars_cleanup,,,18,void vlc_threadvars_cleanup (void)
215838,METHOD,win32\thread.c:<global>,TYPE_DECL,"void vlc_addr_wait(void *addr, unsigned val)
{
    WaitOnAddress(addr, &val, sizeof (val), -1);
}",1,1,win32\thread.c,vlc_addr_wait,,false,429,432,vlc_addr_wait,,,19,"void vlc_addr_wait (void*,unsigned)"
215852,METHOD,win32\thread.c:<global>,TYPE_DECL,"bool vlc_addr_timedwait(void *addr, unsigned val, mtime_t delay)
{
    delay = (delay + 999) / 1000;

    if (delay > 0x7fffffff)
    {
        WaitOnAddress(addr, &val, sizeof (val), 0x7fffffff);
        return true; /* woke up early, claim spurious wake-up */
    }

    return WaitOnAddress(addr, &val, sizeof (val), delay);
}",1,1,win32\thread.c,vlc_addr_timedwait,,false,434,445,vlc_addr_timedwait,,,20,"bool vlc_addr_timedwait (void*,unsigned,mtime_t)"
215888,METHOD,win32\thread.c:<global>,TYPE_DECL,"void vlc_addr_signal(void *addr)
{
    WakeByAddressSingle(addr);
}",1,1,win32\thread.c,vlc_addr_signal,,false,447,450,vlc_addr_signal,,,21,void vlc_addr_signal (void*)
215895,METHOD,win32\thread.c:<global>,TYPE_DECL,"void vlc_addr_broadcast(void *addr)
{
    WakeByAddressAll(addr);
}",1,1,win32\thread.c,vlc_addr_broadcast,,false,452,455,vlc_addr_broadcast,,,22,void vlc_addr_broadcast (void*)
215902,METHOD,win32\thread.c:<global>,TYPE_DECL,"static void vlc_thread_destroy(vlc_thread_t th)
{
    DeleteCriticalSection(&th->wait.lock);
    free(th);
}",1,1,win32\thread.c,vlc_thread_destroy,,false,458,462,vlc_thread_destroy,,,23,void vlc_thread_destroy (vlc_thread_t)
215916,METHOD,win32\thread.c:<global>,TYPE_DECL,"static
#if VLC_WINSTORE_APP
DWORD
#else // !VLC_WINSTORE_APP
unsigned
#endif // !VLC_WINSTORE_APP
__stdcall vlc_entry (void *p)
{
    struct vlc_thread *th = p;

    TlsSetValue(thread_key, th);
    th->killable = true;
    th->data = th->entry (th->data);
    TlsSetValue(thread_key, NULL);

    if (th->id == NULL) /* Detached thread */
        vlc_thread_destroy(th);
    return 0;
}",1,28,win32\thread.c,vlc_entry,,false,464,482,vlc_entry,,,24,unsigned vlc_entry (void*)
215958,METHOD,win32\thread.c:<global>,TYPE_DECL,"static int vlc_clone_attr (vlc_thread_t *p_handle, bool detached,
                           void *(*entry) (void *), void *data, int priority)
{
    struct vlc_thread *th = malloc (sizeof (*th));
    if (unlikely(th == NULL))
        return ENOMEM;
    th->entry = entry;
    th->data = data;
    th->killable = false; /* not until vlc_entry() ! */
    atomic_init(&th->killed, false);
    th->cleaners = NULL;
    th->wait.addr = NULL;
    InitializeCriticalSection(&th->wait.lock);

    HANDLE h;
#if VLC_WINSTORE_APP
    h = CreateThread(NULL, 0, vlc_entry, th, 0, NULL);
#else // !VLC_WINSTORE_APP
    /* When using the MSVCRT C library you have to use the _beginthreadex
     * function instead of CreateThread, otherwise you'll end up with
     * memory leaks and the signal functions not working (see Microsoft
     * Knowledge Base, article 104641) */
    h = (HANDLE)(uintptr_t) _beginthreadex (NULL, 0, vlc_entry, th, 0, NULL);
#endif // !VLC_WINSTORE_APP
    if (h == 0)
    {
        ...",1,1,win32\thread.c,vlc_clone_attr,,false,484,530,vlc_clone_attr,,,25,"int vlc_clone_attr (vlc_thread_t*,bool,void*,void*,int)"
216085,METHOD,win32\thread.c:<global>,TYPE_DECL,"int vlc_clone (vlc_thread_t *p_handle, void *(*entry) (void *),
                void *data, int priority)
{
    return vlc_clone_attr (p_handle, false, entry, data, priority);
}",1,1,win32\thread.c,vlc_clone,,false,532,536,vlc_clone,,,26,"int vlc_clone (vlc_thread_t*,void*,void*,int)"
216100,METHOD,win32\thread.c:<global>,TYPE_DECL,"void vlc_join (vlc_thread_t th, void **result)
{
    DWORD ret;

    do
    {
        vlc_testcancel ();
        ret = WaitForSingleObjectEx(th->id, INFINITE, TRUE);
        assert(ret != WAIT_ABANDONED_0);
    }
    while (ret == WAIT_IO_COMPLETION || ret == WAIT_FAILED);

    if (result != NULL)
        *result = th->data;
    CloseHandle (th->id);
    vlc_thread_destroy(th);
}",1,1,win32\thread.c,vlc_join,,false,538,554,vlc_join,,,27,"void vlc_join (vlc_thread_t,void**)"
216146,METHOD,win32\thread.c:<global>,TYPE_DECL,"int vlc_clone_detach (vlc_thread_t *p_handle, void *(*entry) (void *),
                      void *data, int priority)
{
    vlc_thread_t th;
    if (p_handle == NULL)
        p_handle = &th;

    return vlc_clone_attr (p_handle, true, entry, data, priority);
}",1,1,win32\thread.c,vlc_clone_detach,,false,556,564,vlc_clone_detach,,,28,"int vlc_clone_detach (vlc_thread_t*,void*,void*,int)"
216171,METHOD,win32\thread.c:<global>,TYPE_DECL,"vlc_thread_t vlc_thread_self (void)
{
    return TlsGetValue(thread_key);
}",1,1,win32\thread.c,vlc_thread_self,,false,566,569,vlc_thread_self,,,29,vlc_thread_t vlc_thread_self (void)
216179,METHOD,win32\thread.c:<global>,TYPE_DECL,"unsigned long vlc_thread_id (void)
{
    return GetCurrentThreadId ();
}",1,1,win32\thread.c,vlc_thread_id,,false,571,574,vlc_thread_id,,,30,unsigned long vlc_thread_id (void)
216186,METHOD,win32\thread.c:<global>,TYPE_DECL,"int vlc_set_priority (vlc_thread_t th, int priority)
{
    if (!SetThreadPriority (th->id, priority))
        return VLC_EGENERIC;
    return VLC_SUCCESS;
}",1,1,win32\thread.c,vlc_set_priority,,false,576,581,vlc_set_priority,,,31,"int vlc_set_priority (vlc_thread_t,int)"
216205,METHOD,win32\thread.c:<global>,TYPE_DECL,"void vlc_cancel (vlc_thread_t th)
{
    atomic_store_explicit(&th->killed, true, memory_order_relaxed);

    EnterCriticalSection(&th->wait.lock);
    if (th->wait.addr != NULL)
    {
        atomic_fetch_or_explicit(th->wait.addr, 1, memory_order_relaxed);
        vlc_addr_broadcast(th->wait.addr);
    }
    LeaveCriticalSection(&th->wait.lock);

#if IS_INTERRUPTIBLE
    QueueUserAPC (vlc_cancel_self, th->id, (uintptr_t)th);
#endif
}",1,4,win32\thread.c,vlc_cancel,,false,593,608,vlc_cancel,,,33,void vlc_cancel (vlc_thread_t)
216262,METHOD,win32\thread.c:<global>,TYPE_DECL,"int vlc_savecancel (void)
{
    struct vlc_thread *th = vlc_thread_self();
    if (th == NULL)
        return false; /* Main thread - cannot be cancelled anyway */

    int state = th->killable;
    th->killable = false;
    return state;
}",1,1,win32\thread.c,vlc_savecancel,,false,610,619,vlc_savecancel,,,34,int vlc_savecancel (void)
216291,METHOD,win32\thread.c:<global>,TYPE_DECL,"void vlc_restorecancel (int state)
{
    struct vlc_thread *th = vlc_thread_self();
    assert (state == false || state == true);

    if (th == NULL)
        return; /* Main thread - cannot be cancelled anyway */

    assert (!th->killable);
    th->killable = state != 0;
}",1,1,win32\thread.c,vlc_restorecancel,,false,621,631,vlc_restorecancel,,,35,void vlc_restorecancel (int)
216326,METHOD,win32\thread.c:<global>,TYPE_DECL,"void vlc_testcancel (void)
{
    struct vlc_thread *th = vlc_thread_self();
    if (th == NULL)
        return; /* Main thread - cannot be cancelled anyway */
    if (!th->killable)
        return;
    if (!atomic_load_explicit(&th->killed, memory_order_relaxed))
        return;

    th->killable = true; /* Do not re-enter cancellation cleanup */

    for (vlc_cleanup_t *p = th->cleaners; p != NULL; p = p->next)
        p->proc (p->data);

    th->data = NULL; /* TODO: special value? */
    if (th->id == NULL) /* Detached thread */
        vlc_thread_destroy(th);
#if VLC_WINSTORE_APP
    ExitThread(0);
#else // !VLC_WINSTORE_APP
    _endthreadex(0);
#endif // !VLC_WINSTORE_APP
}",1,1,win32\thread.c,vlc_testcancel,,false,633,656,vlc_testcancel,,,36,void vlc_testcancel (void)
216402,METHOD,win32\thread.c:<global>,TYPE_DECL,"void vlc_control_cancel (int cmd, ...)
{
    /* NOTE: This function only modifies thread-specific data, so there is no
     * need to lock anything. */
    va_list ap;

    struct vlc_thread *th = vlc_thread_self();
    if (th == NULL)
        return; /* Main thread - cannot be cancelled anyway */

    va_start (ap, cmd);
    switch (cmd)
    {
        case VLC_CLEANUP_PUSH:
        {
            /* cleaner is a pointer to the caller stack, no need to allocate
             * and copy anything. As a nice side effect, this cannot fail. */
            vlc_cleanup_t *cleaner = va_arg (ap, vlc_cleanup_t *);
            cleaner->next = th->cleaners;
            th->cleaners = cleaner;
            break;
        }

        case VLC_CLEANUP_POP:
        {
            th->cleaners = th->cleaners->next;
            break;
        }

        case VLC_CANCEL_ADDR_SET:
        {
            void *addr = va_arg(ap, void *);

            EnterCriticalSection(&th->wait.lock);
            assert(th-...",1,1,win32\thread.c,vlc_control_cancel,,false,658,710,vlc_control_cancel,,,37,void vlc_control_cancel (int...)
216526,METHOD,clk.interrupt,TYPE_DECL,BOOL (*query) (PULONGLONG);,14,34,win32\thread.c,clk.interrupt.query,,false,718,718,query,,,1,BOOL clk.interrupt.query (ANY)
216533,METHOD,clk.tick,TYPE_DECL,ULONGLONG (*get) (void);,19,31,win32\thread.c,clk.tick.get,,false,724,724,get,,,1,ULONGLONG clk.tick.get (void)
216543,METHOD,clk.multimedia,TYPE_DECL,MMRESULT (WINAPI *timeGetDevCaps),18,41,win32\thread.c,clk.multimedia.,,false,734,734,,,,1,MMRESULT clk.multimedia. (WINAPI*)
216550,METHOD,clk.multimedia,TYPE_DECL,DWORD (WINAPI *timeGetTime),15,35,win32\thread.c,clk.multimedia.,,false,735,735,,,,4,DWORD clk.multimedia. (WINAPI*)
216559,METHOD,win32\thread.c:<global>,TYPE_DECL,"static mtime_t mdate_interrupt (void)
{
    ULONGLONG ts;
    BOOL ret;

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN7)
    ret = QueryUnbiasedInterruptTime (&ts);
#else
    ret = clk.interrupt.query (&ts);
#endif
    if (unlikely(!ret))
        abort ();

    /* hundreds of nanoseconds */
    static_assert ((10000000 % CLOCK_FREQ) == 0, ""Broken frequencies ratio"");
    return ts / (10000000 / CLOCK_FREQ);
}",1,1,win32\thread.c,mdate_interrupt,,false,740,756,mdate_interrupt,,,40,mtime_t mdate_interrupt (void)
216590,METHOD,win32\thread.c:<global>,TYPE_DECL,"static mtime_t mdate_tick (void)
{
#if (_WIN32_WINNT >= _WIN32_WINNT_VISTA)
    ULONGLONG ts = GetTickCount64 ();
#else
    ULONGLONG ts = clk.tick.get ();
#endif

    /* milliseconds */
    static_assert ((CLOCK_FREQ % 1000) == 0, ""Broken frequencies ratio"");
    return ts * (CLOCK_FREQ / 1000);
}",1,1,win32\thread.c,mdate_tick,,false,758,769,mdate_tick,,,41,mtime_t mdate_tick (void)
216612,METHOD,win32\thread.c:<global>,TYPE_DECL,"static mtime_t mdate_multimedia (void)
{
    DWORD ts = clk.multimedia.timeGetTime ();

    /* milliseconds */
    static_assert ((CLOCK_FREQ % 1000) == 0, ""Broken frequencies ratio"");
    return ts * (CLOCK_FREQ / 1000);
}",1,1,win32\thread.c,mdate_multimedia,,false,771,778,mdate_multimedia,,,42,mtime_t mdate_multimedia (void)
216639,METHOD,win32\thread.c:<global>,TYPE_DECL,"static mtime_t mdate_perf (void)
{
    /* We don't need the real date, just the value of a high precision timer */
    LARGE_INTEGER counter;
    if (!QueryPerformanceCounter (&counter))
        abort ();

    /* Convert to from (1/freq) to microsecond resolution */
    /* We need to split the division to avoid 63-bits overflow */
    lldiv_t d = lldiv (counter.QuadPart, clk.perf.freq.QuadPart);

    return (d.quot * 1000000) + ((d.rem * 1000000) / clk.perf.freq.QuadPart);
}",1,1,win32\thread.c,mdate_perf,,false,781,793,mdate_perf,,,43,mtime_t mdate_perf (void)
216686,METHOD,win32\thread.c:<global>,TYPE_DECL,"static mtime_t mdate_wall (void)
{
    FILETIME ts;
    ULARGE_INTEGER s;

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN8) && (!VLC_WINSTORE_APP || _WIN32_WINNT >= 0x0A00)
    GetSystemTimePreciseAsFileTime (&ts);
#else
    GetSystemTimeAsFileTime (&ts);
#endif
    s.LowPart = ts.dwLowDateTime;
    s.HighPart = ts.dwHighDateTime;
    /* hundreds of nanoseconds */
    static_assert ((10000000 % CLOCK_FREQ) == 0, ""Broken frequencies ratio"");
    return s.QuadPart / (10000000 / CLOCK_FREQ);
}",1,1,win32\thread.c,mdate_wall,,false,795,810,mdate_wall,,,44,mtime_t mdate_wall (void)
216725,METHOD,win32\thread.c:<global>,TYPE_DECL,"static mtime_t mdate_default(void)
{
    vlc_threads_setup(NULL);
    return mdate_perf();
}",1,1,win32\thread.c,mdate_default,,false,812,816,mdate_default,,,45,mtime_t mdate_default (void)
216734,METHOD,win32\thread.c:<global>,TYPE_DECL,static mtime_t (*mdate_selected) (void) = mdate_default;,16,55,win32\thread.c,mdate_selected,,false,818,818,mdate_selected,,,46,mtime_t mdate_selected (void)
216742,METHOD,win32\thread.c:<global>,TYPE_DECL,"mtime_t mdate (void)
{
    return mdate_selected ();
}",1,1,win32\thread.c,mdate,,false,820,823,mdate,,,48,mtime_t mdate (void)
216749,METHOD,win32\thread.c:<global>,TYPE_DECL,"static BOOL SelectClockSource(void *data)
{
    vlc_object_t *obj = data;

#if VLC_WINSTORE_APP
    const char *name = ""perf"";
#else
    const char *name = ""multimedia"";
#endif
    char *str = NULL;
    if (obj != NULL)
        str = var_InheritString(obj, ""clock-source"");
    if (str != NULL)
        name = str;
    if (!strcmp (name, ""interrupt""))
    {
        msg_Dbg (obj, ""using interrupt time as clock source"");
#if (_WIN32_WINNT < _WIN32_WINNT_WIN7)
        HANDLE h = GetModuleHandle (_T(""kernel32.dll""));
        if (unlikely(h == NULL))
            return FALSE;
        clk.interrupt.query = (void *)GetProcAddress (h,
                                                      ""QueryUnbiasedInterruptTime"");
        if (unlikely(clk.interrupt.query == NULL))
            abort ();
#endif
        mdate_selected = mdate_interrupt;
    }
    else
    if (!strcmp (name, ""tick""))
    {
        msg_Dbg (obj, ""using Windows time as clock source"");
#if (_WIN32_WINNT < _WIN32_WINNT_VISTA)
   ...",1,1,win32\thread.c,SelectClockSource,,false,848,941,SelectClockSource,,,49,BOOL SelectClockSource (void*)
216979,METHOD,win32\thread.c:<global>,TYPE_DECL,"size_t EnumClockSource (vlc_object_t *obj, const char *var,
                        char ***vp, char ***np)
{
    const size_t max = 6;
    char **values = xmalloc (sizeof (*values) * max);
    char **names = xmalloc (sizeof (*names) * max);
    size_t n = 0;

#if (_WIN32_WINNT < _WIN32_WINNT_WIN7)
    DWORD version = LOWORD(GetVersion());
    version = (LOBYTE(version) << 8) | (HIBYTE(version) << 0);
#endif

    values[n] = xstrdup ("""");
    names[n] = xstrdup (_(""Auto""));
    n++;
#if (_WIN32_WINNT < _WIN32_WINNT_WIN7)
    if (version >= 0x0601)
#endif
    {
        values[n] = xstrdup (""interrupt"");
        names[n] = xstrdup (""Interrupt time"");
        n++;
    }
#if (_WIN32_WINNT < _WIN32_WINNT_VISTA)
    if (version >= 0x0600)
#endif
    {
        values[n] = xstrdup (""tick"");
        names[n] = xstrdup (""Windows time"");
        n++;
    }
#if !VLC_WINSTORE_APP
    values[n] = xstrdup (""multimedia"");
    names[n] = xstrdup (""Multimedia timers"");
    n++;
#endif
    values[n] =...",1,1,win32\thread.c,EnumClockSource,,false,943,991,EnumClockSource,,,50,"size_t EnumClockSource (vlc_object_t*,char*,char***,char***)"
217116,METHOD,win32\thread.c:<global>,TYPE_DECL,"unsigned vlc_GetCPUCount (void)
{
    SYSTEM_INFO systemInfo;

    GetNativeSystemInfo(&systemInfo);

    return systemInfo.dwNumberOfProcessors;
}",1,1,win32\thread.c,vlc_GetCPUCount,,false,995,1002,vlc_GetCPUCount,,,51,unsigned vlc_GetCPUCount (void)
217130,METHOD,win32\thread.c:<global>,TYPE_DECL,"void vlc_threads_setup(libvlc_int_t *vlc)
{
    EnterCriticalSection(&setup_lock);
    if (mdate_selected != mdate_default)
    {
        LeaveCriticalSection(&setup_lock);
        return;
    }

    if (!SelectClockSource((vlc != NULL) ? VLC_OBJECT(vlc) : NULL))
        abort();
    assert(mdate_selected != mdate_default);

#if !VLC_WINSTORE_APP
    /* Raise default priority of the current process */
#ifndef ABOVE_NORMAL_PRIORITY_CLASS
#   define ABOVE_NORMAL_PRIORITY_CLASS 0x00008000
#endif
    if (var_InheritBool(vlc, ""high-priority""))
    {
        if (SetPriorityClass(GetCurrentProcess(), ABOVE_NORMAL_PRIORITY_CLASS)
         || SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS))
            msg_Dbg(vlc, ""raised process priority"");
        else
            msg_Dbg(vlc, ""could not raise process priority"");
    }
#endif
    LeaveCriticalSection(&setup_lock);
}",1,50,win32\thread.c,vlc_threads_setup,,false,1008,1036,vlc_threads_setup,,,53,void vlc_threads_setup (libvlc_int_t*)
217192,METHOD,win32\thread.c:<global>,TYPE_DECL,"WINAPI DllMain (HINSTANCE, DWORD, LPVOID);",13,46,win32\thread.c,DllMain,,false,1041,1041,DllMain,,,56,"WINAPI DllMain (ANY,ANY,ANY)"
217200,METHOD,win32\thread.c:<global>,TYPE_DECL,"WINAPI DllMain (HINSTANCE hinstDll, DWORD fdwReason, LPVOID lpvReserved)
{
    (void) hinstDll;
    (void) lpvReserved;

    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
#if (_WIN32_WINNT < _WIN32_WINNT_WIN8)
            HANDLE h = GetModuleHandle(TEXT(""kernel32.dll""));
            if (unlikely(h == NULL))
                return FALSE;

            if (!LOOKUP(WaitOnAddress)
             || !LOOKUP(WakeByAddressAll) || !LOOKUP(WakeByAddressSingle))
            {
# if (_WIN32_WINNT < _WIN32_WINNT_VISTA)
                if (!LOOKUP(InitializeConditionVariable)
                 || !LOOKUP(SleepConditionVariableCS)
                 || !LOOKUP(WakeAllConditionVariable))
                {
                    InitializeConditionVariable_ = DummyConditionVariable;
                    SleepConditionVariableCS_ = SleepConditionVariableFallback;
                    WakeAllConditionVariable_ = DummyConditionVariable;
                }
# endif
                vlc_wait_addr...",6,1,win32\thread.c,DllMain,,false,1043,1103,DllMain,,,58,"WINAPI DllMain (HINSTANCE,DWORD,LPVOID)"
217277,METHOD,win32\timer.c:<global>,TYPE_DECL,<global>,1,1,win32\timer.c,win32\timer.c:<global>,,false,1,94,<global>,,,1,
217281,METHOD,vlc_timer,TYPE_DECL,void (*func) (void *);,10,25,win32\timer.c,vlc_timer.func,,false,33,33,func,,,2,void vlc_timer.func (void*)
217288,METHOD,win32\timer.c:<global>,TYPE_DECL,"int vlc_timer_create (vlc_timer_t *id, void (*func) (void *), void *data)
{
    struct vlc_timer *timer = malloc (sizeof (*timer));

    if (timer == NULL)
        return ENOMEM;
    timer->func = func;
    timer->data = data;
    timer->handle = INVALID_HANDLE_VALUE;
    *id = timer;
    return 0;
}",1,1,win32\timer.c,vlc_timer_create,,false,45,56,vlc_timer_create,,,3,"int vlc_timer_create (vlc_timer_t*,void,void*)"
217330,METHOD,win32\timer.c:<global>,TYPE_DECL,"void vlc_timer_destroy (vlc_timer_t timer)
{
    if (timer->handle != INVALID_HANDLE_VALUE)
        DeleteTimerQueueTimer (NULL, timer->handle, INVALID_HANDLE_VALUE);
    free (timer);
}",1,1,win32\timer.c,vlc_timer_destroy,,false,58,63,vlc_timer_destroy,,,4,void vlc_timer_destroy (vlc_timer_t)
217350,METHOD,win32\timer.c:<global>,TYPE_DECL,"void vlc_timer_schedule (vlc_timer_t timer, bool absolute,
                         mtime_t value, mtime_t interval)
{
    if (timer->handle != INVALID_HANDLE_VALUE)
    {
        DeleteTimerQueueTimer (NULL, timer->handle, INVALID_HANDLE_VALUE);
        timer->handle = INVALID_HANDLE_VALUE;
    }
    if (value == 0)
        return; /* Disarm */

    if (absolute)
    {
        value -= mdate ();
        if (value < 0)
            value = 0;
    }
    value = (value + 999) / 1000;
    interval = (interval + 999) / 1000;

    if (!CreateTimerQueueTimer (&timer->handle, NULL, vlc_timer_do, timer,
                                value, interval, WT_EXECUTEDEFAULT))
        abort ();
}",1,1,win32\timer.c,vlc_timer_schedule,,false,65,88,vlc_timer_schedule,,,5,"void vlc_timer_schedule (vlc_timer_t,bool,mtime_t,mtime_t)"
217425,METHOD,win32\timer.c:<global>,TYPE_DECL,"unsigned vlc_timer_getoverrun (vlc_timer_t timer)
{
    (void)timer;
    return 0;
}",1,1,win32\timer.c,vlc_timer_getoverrun,,false,90,94,vlc_timer_getoverrun,,,6,unsigned vlc_timer_getoverrun (vlc_timer_t)
217444,METHOD,win32\winsock.c:<global>,TYPE_DECL,<global>,1,6,win32\winsock.c,win32\winsock.c:<global>,,false,1,89,<global>,,,1,
219559,METHOD,<includes>:<global>,NAMESPACE_BLOCK,<global>,,,<includes>,<includes>:<global>,,false,1,,<global>,,,1,
219785,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strerror_r,,true,,,strerror_r,,,0,
219791,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.assignment,,true,,,<operator>.assignment,,,0,
219796,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.arrayInitializer,,true,,,<operator>.arrayInitializer,,,0,
219799,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetStaticFieldID,,true,,,GetStaticFieldID,,,0,
219807,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.indirectFieldAccess,,true,,,<operator>.indirectFieldAccess,,,0,
219812,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.indirection,,true,,,<operator>.indirection,,,0,
219816,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ExceptionCheck,,true,,,ExceptionCheck,,,0,
219821,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ExceptionClear,,true,,,ExceptionClear,,,0,
219826,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetStaticObjectField,,true,,,GetStaticObjectField,,,0,
219833,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetStringUTFChars,,true,,,GetStringUTFChars,,,0,
219840,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.equals,,true,,,<operator>.equals,,,0,
219845,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strdup,,true,,,strdup,,,0,
219849,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReleaseStringUTFChars,,true,,,ReleaseStringUTFChars,,,0,
219856,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DeleteLocalRef,,true,,,DeleteLocalRef,,,0,
219862,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.cast,,true,,,<operator>.cast,,,0,
219867,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.lessThan,,true,,,<operator>.lessThan,,,0,
219872,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,android\specific.c,android\specific.c:37:37:GENERIC_DIR_COUNT:0,,true,37,37,GENERIC_DIR_COUNT,,,0,
219875,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.addition,,true,,,<operator>.addition,,,0,
219880,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.subtraction,,true,,,<operator>.subtraction,,,0,
219885,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.preIncrement,,true,,,<operator>.preIncrement,,,0,
219889,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,free,,true,,,free,,,0,
219893,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.indirectIndexAccess,,true,,,<operator>.indirectIndexAccess,,,0,
219898,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.notEquals,,true,,,<operator>.notEquals,,,0,
219903,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetEnv,,true,,,GetEnv,,,0,
219910,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.addressOf,,true,,,<operator>.addressOf,,,0,
219914,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.fieldAccess,,true,,,<operator>.fieldAccess,,,0,
219919,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DeleteGlobalRef,,true,,,DeleteGlobalRef,,,0,
219925,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.minus,,true,,,<operator>.minus,,,0,
219929,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FindClass,,true,,,FindClass,,,0,
219935,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NewGlobalRef,,true,,,NewGlobalRef,,,0,
219941,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetStaticMethodID,,true,,,GetStaticMethodID,,,0,
219949,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetMethodID,,true,,,GetMethodID,,,0,
219957,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,assert,,true,,,assert,,,0,
219961,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,var_SetAddress,,true,,,var_SetAddress,,,0,
219967,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getenv,,true,,,getenv,,,0,
219971,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,asprintf,,true,,,asprintf,,,0,
219977,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.logicalAnd,,true,,,<operator>.logicalAnd,,,0,
219982,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.conditional,,true,,,<operator>.conditional,,,0,
219988,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AttachCurrentThread,,true,,,AttachCurrentThread,,,0,
219995,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DetachCurrentThread,,true,,,DetachCurrentThread,,,0,
220000,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NewStringUTF,,true,,,NewStringUTF,,,0,
220006,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CallStaticObjectMethod,,true,,,CallStaticObjectMethod,,,0,
220014,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CallObjectMethod,,true,,,CallObjectMethod,,,0,
220021,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.greaterEqualsThan,,true,,,<operator>.greaterEqualsThan,,,0,
220026,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.lessEqualsThan,,true,,,<operator>.lessEqualsThan,,,0,
220031,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,VLC_UNUSED,,true,,,VLC_UNUSED,,,0,
220035,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.logicalOr,,true,,,<operator>.logicalOr,,,0,
220040,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.sizeOf,,true,,,<operator>.sizeOf,,,0,
220044,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fprintf,,true,,,fprintf,,,0,
220052,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fflush,,true,,,fflush,,,0,
220056,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_mutexattr_init,,true,,,pthread_mutexattr_init,,,0,
220060,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_mutexattr_settype,,true,,,pthread_mutexattr_settype,,,0,
220065,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_mutex_init,,true,,,pthread_mutex_init,,,0,
220070,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_mutexattr_destroy,,true,,,pthread_mutexattr_destroy,,,0,
220074,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_mutex_destroy,,true,,,pthread_mutex_destroy,,,0,
220078,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,android\thread.c,android\thread.c:74:79:VLC_THREAD_ASSERT:1,,true,74,79,VLC_THREAD_ASSERT,,,0,
220081,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,unlikely,,true,,,unlikely,,,0,
220085,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.logicalNot,,true,,,<operator>.logicalNot,,,0,
220089,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_mutex_lock,,true,,,pthread_mutex_lock,,,0,
220093,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_mutex_trylock,,true,,,pthread_mutex_trylock,,,0,
220097,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_mutex_unlock,,true,,,pthread_mutex_unlock,,,0,
220101,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_cleanup_push,,true,,,vlc_cleanup_push,,,0,
220106,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,entry,,true,,,entry,,,0,
220111,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_cleanup_pop,,true,,,vlc_cleanup_pop,,,0,
220114,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,malloc,,true,,,malloc,,,0,
220118,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sigemptyset,,true,,,sigemptyset,,,0,
220122,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sigdelset,,true,,,sigdelset,,,0,
220127,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sigaddset,,true,,,sigaddset,,,0,
220132,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_sigmask,,true,,,pthread_sigmask,,,0,
220138,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,atomic_store,,true,,,atomic_store,,,0,
220143,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_attr_init,,true,,,pthread_attr_init,,,0,
220147,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_attr_setdetachstate,,true,,,pthread_attr_setdetachstate,,,0,
220152,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_create,,true,,,pthread_create,,,0,
220159,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_attr_destroy,,true,,,pthread_attr_destroy,,,0,
220163,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_join,,true,,,pthread_join,,,0,
220168,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,atomic_fetch_or_explicit,,true,,,atomic_fetch_or_explicit,,,0,
220174,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,atomic_load,,true,,,atomic_load,,,0,
220178,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_exit,,true,,,pthread_exit,,,0,
220182,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,va_start,,true,,,va_start,,,0,
220187,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_assert_unreachable,,true,,,vlc_assert_unreachable,,,0,
220190,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,va_end,,true,,,va_end,,,0,
220194,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_key_create,,true,,,pthread_key_create,,,0,
220199,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_key_delete,,true,,,pthread_key_delete,,,0,
220203,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_setspecific,,true,,,pthread_setspecific,,,0,
220208,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_getspecific,,true,,,pthread_getspecific,,,0,
220212,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,clock_gettime,,true,,,clock_gettime,,,0,
220217,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,abort,,true,,,abort,,,0,
220220,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.multiplication,,true,,,<operator>.multiplication,,,0,
220225,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,INT64_C,,true,,,INT64_C,,,0,
220229,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.division,,true,,,<operator>.division,,,0,
220234,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sysconf,,true,,,sysconf,,,0,
220238,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operators>.assignmentOr,,true,,,<operators>.assignmentOr,,,0,
220243,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,aout_FormatNbChannels,,true,,,aout_FormatNbChannels,,,0,
220247,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.greaterThan,,true,,,<operator>.greaterThan,,,0,
220252,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.and,,true,,,<operator>.and,,,0,
220257,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.or,,true,,,<operator>.or,,,0,
220262,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,msg_Dbg,,true,,,msg_Dbg,,,0,
220267,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,static_assert,,true,,,static_assert,,,0,
220272,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.postIncrement,,true,,,<operator>.postIncrement,,,0,
220276,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,likely,,true,,,likely,,,0,
220280,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,audio_output\common.c,audio_output\common.c:312:326:REORDER_TYPE:1,,true,312,326,REORDER_TYPE,,,0,
220284,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,memcpy,,true,,,memcpy,,,0,
220290,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.assignmentPlus,,true,,,<operator>.assignmentPlus,,,0,
220295,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,audio_output\common.c,audio_output\common.c:370:379:INTERLEAVE_TYPE:1,,true,370,379,INTERLEAVE_TYPE,,,0,
220298,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.expressionList,,true,,,<operator>.expressionList,,,0,
220303,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,audio_output\common.c,audio_output\common.c:406:415:DEINTERLEAVE_TYPE:1,,true,406,415,DEINTERLEAVE_TYPE,,,0,
220306,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ARRAY_SIZE,,true,,,ARRAY_SIZE,,,0,
220310,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strcmp,,true,,,strcmp,,,0,
220315,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,var_GetString,,true,,,var_GetString,,,0,
220320,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,var_InheritString,,true,,,var_InheritString,,,0,
220325,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,calloc,,true,,,calloc,,,0,
220330,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strchr,,true,,,strchr,,,0,
220335,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strlen,,true,,,strlen,,,0,
220339,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,memmove,,true,,,memmove,,,0,
220345,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strcat,,true,,,strcat,,,0,
220350,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,var_SetString,,true,,,var_SetString,,,0,
220356,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,msg_Err,,true,,,msg_Err,,,0,
220362,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,audio_output\aout_internal.h,audio_output\aout_internal.h:116:116:aout_volume_New:2,,true,116,116,aout_volume_New,,,0,
220367,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,VLC_OBJECT,,true,,,VLC_OBJECT,,,0,
220371,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,atomic_init,,true,,,atomic_init,,,0,
220376,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,audio_output\aout_internal.h,audio_output\aout_internal.h:149:149:AOUT_DEC_SUCCESS:0,,true,149,149,AOUT_DEC_SUCCESS,,,0,
220379,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,atomic_exchange,,true,,,atomic_exchange,,,0,
220384,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,audio_output\aout_internal.h,audio_output\aout_internal.h:150:150:AOUT_DEC_CHANGED:0,,true,150,150,AOUT_DEC_CHANGED,,,0,
220387,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,audio_output\aout_internal.h,audio_output\aout_internal.h:151:151:AOUT_DEC_FAILED:0,,true,151,151,AOUT_DEC_FAILED,,,0,
220390,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,atomic_fetch_or,,true,,,atomic_fetch_or,,,0,
220395,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,memset,,true,,,memset,,,0,
220401,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.plus,,true,,,<operator>.plus,,,0,
220405,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,llabs,,true,,,llabs,,,0,
220409,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.assignmentMultiplication,,true,,,<operator>.assignmentMultiplication,,,0,
220414,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,audio_output\aout_internal.h,audio_output\aout_internal.h:31:31:AOUT_MAX_INPUT_RATE:0,,true,31,31,AOUT_MAX_INPUT_RATE,,,0,
220417,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,atomic_fetch_add,,true,,,atomic_fetch_add,,,0,
220422,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,block_Release,,true,,,block_Release,,,0,
220426,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.assignmentMinus,,true,,,<operator>.assignmentMinus,,,0,
220431,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AOUT_FMTS_IDENTICAL,,true,,,AOUT_FMTS_IDENTICAL,,,0,
220436,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,audio_output\aout_internal.h,audio_output\aout_internal.h:143:144:aout_FormatsPrint:4,,true,143,144,aout_FormatsPrint,,,0,
220443,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AOUT_FMT_LINEAR,,true,,,AOUT_FMT_LINEAR,,,0,
220447,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_,,true,,,_,,,0,
220451,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pf_audio_filter,,true,,,pf_audio_filter,,,0,
220457,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,filter_DrainAudio,,true,,,filter_DrainAudio,,,0,
220461,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,block_ChainAppend,,true,,,block_ChainAppend,,,0,
220466,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,block_ChainGather,,true,,,block_ChainGather,,,0,
220470,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,filter_Flush,,true,,,filter_Flush,,,0,
220474,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,filter_ChangeViewpoint,,true,,,filter_ChangeViewpoint,,,0,
220479,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,audio_output\filters.c,audio_output\filters.c:342:342:AOUT_MAX_FILTERS:0,,true,342,342,AOUT_MAX_FILTERS,,,0,
220482,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strcasecmp,,true,,,strcasecmp,,,0,
220487,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pf_request_vout,,true,,,pf_request_vout,,,0,
220495,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,msg_Warn,,true,,,msg_Warn,,,0,
220502,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,msg_Info,,true,,,msg_Info,,,0,
220507,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,var_InheritBool,,true,,,var_InheritBool,,,0,
220512,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strsep,,true,,,strsep,,,0,
220517,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,libvlc.h,libvlc.h:65:65:vlc_assert_locked:1,,true,65,65,vlc_assert_locked,,,0,
220521,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,var_SetFloat,,true,,,var_SetFloat,,,0,
220527,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,var_SetBool,,true,,,var_SetBool,,,0,
220533,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,cork ? var_IncInteger : var_DecInteger,,true,,,cork ? var_IncInteger : var_DecInteger,,,0,
220539,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strcpy,,true,,,strcpy,,,0,
220544,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.postDecrement,,true,,,<operator>.postDecrement,,,0,
220548,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,aout_RestartRequest,,true,,,aout_RestartRequest,,,0,
220553,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,libvlc.h,libvlc.h:109:110:vlc_custom_create:3,,true,109,110,vlc_custom_create,,,0,
220558,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_viewpoint_init,,true,,,vlc_viewpoint_init,,,0,
220562,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,libvlc.h,libvlc.h:121:122:vlc_object_set_destructor:2,,true,121,122,vlc_object_set_destructor,,,0,
220567,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,var_GetNonEmptyString,,true,,,var_GetNonEmptyString,,,0,
220572,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,var_GetInteger,,true,,,var_GetInteger,,,0,
220577,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,start,,true,,,start,,,0,
220583,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,stop,,true,,,stop,,,0,
220588,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,time_get,,true,,,time_get,,,0,
220594,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,play,,true,,,play,,,0,
220600,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,(aout->pause != NULL) ? aout->pause : PauseDefault,,true,,,(aout->pause != NULL) ? aout->pause : PauseDefault,,,0,
220607,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,flush,,true,,,flush,,,0,
220613,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,volume_set,,true,,,volume_set,,,0,
220619,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,mute_set,,true,,,mute_set,,,0,
220625,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,device_select,,true,,,device_select,,,0,
220631,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,var_GetFloat,,true,,,var_GetFloat,,,0,
220636,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,var_InheritFloat,,true,,,var_InheritFloat,,,0,
220641,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,roundf,,true,,,roundf,,,0,
220645,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_alloc,,true,,,vlc_alloc,,,0,
220650,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_atomic_load_float,,true,,,vlc_atomic_load_float,,,0,
220654,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,amplify,,true,,,amplify,,,0,
220661,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,powf,,true,,,powf,,,0,
220666,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fminf,,true,,,fminf,,,0,
220671,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_atomic_store_float,,true,,,vlc_atomic_store_float,,,0,
220676,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,config\chain.c,config\chain.c:60:60:SKIPSPACE:1,,true,60,60,SKIPSPACE,,,0,
220680,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strspn,,true,,,strspn,,,0,
220685,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,config\chain.c,config\chain.c:61:62:SKIPTRAILINGSPACE:2,,true,61,62,SKIPTRAILINGSPACE,,,0,
220690,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strndup,,true,,,strndup,,,0,
220695,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strcspn,,true,,,strcspn,,,0,
220700,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,memchr,,true,,,memchr,,,0,
220706,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FREENULL,,true,,,FREENULL,,,0,
220710,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,snprintf,,true,,,snprintf,,,0,
220717,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,config\configuration.h,config\configuration.h:44:44:CONFIG_CLASS:1,,true,44,44,CONFIG_CLASS,,,0,
220721,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.not,,true,,,<operator>.not,,,0,
220725,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strncmp,,true,,,strncmp,,,0,
220731,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strtoll,,true,,,strtoll,,,0,
220737,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,config\cmdline.c,config\cmdline.c:64:64:b_ignore_errors:0,,true,64,64,b_ignore_errors,,,0,
220740,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CONFIG_ITEM,,true,,,CONFIG_ITEM,,,0,
220744,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,var_SetInteger,,true,,,var_SetInteger,,,0,
220750,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fputs,,true,,,fputs,,,0,
220755,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,config\configuration.h,config\configuration.h:48:49:IsConfigIntegerType:1,,true,48,49,IsConfigIntegerType,,,0,
220759,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,config\configuration.h,config\configuration.h:50:51:IsConfigFloatType:1,,true,50,51,IsConfigFloatType,,,0,
220763,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,config\configuration.h,config\configuration.h:46:47:IsConfigStringType:1,,true,46,47,IsConfigStringType,,,0,
220767,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,i_cb,,true,,,i_cb,,,0,
220775,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.preDecrement,,true,,,<operator>.preDecrement,,,0,
220779,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,xmalloc,,true,,,xmalloc,,,0,
220783,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,xstrdup,,true,,,xstrdup,,,0,
220787,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,psz_cb,,true,,,psz_cb,,,0,
220795,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,qsort,,true,,,qsort,,,0,
220802,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,bsearch,,true,,,bsearch,,,0,
220810,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,var_CreateGetNonEmptyString,,true,,,var_CreateGetNonEmptyString,,,0,
220815,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,var_Destroy,,true,,,var_Destroy,,,0,
220820,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fclose,,true,,,fclose,,,0,
220824,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,unlink,,true,,,unlink,,,0,
220828,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fread,,true,,,fread,,,0,
220835,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,memcmp,,true,,,memcmp,,,0,
220841,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,rewind,,true,,,rewind,,,0,
220845,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,newlocale,,true,,,newlocale,,,0,
220851,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uselocale,,true,,,uselocale,,,0,
220855,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getline,,true,,,getline,,,0,
220861,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,atof,,true,,,atof,,,0,
220865,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ferror,,true,,,ferror,,,0,
220869,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,clearerr,,true,,,clearerr,,,0,
220873,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,freelocale,,true,,,freelocale,,,0,
220877,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strrchr,,true,,,strrchr,,,0,
220882,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vfprintf,,true,,,vfprintf,,,0,
220888,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getpid,,true,,,getpid,,,0,
220891,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,stat,,true,,,stat,,,0,
220896,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fdopen,,true,,,fdopen,,,0,
220901,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,N_,,true,,,N_,,,0,
220905,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fdatasync,,true,,,fdatasync,,,0,
220909,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,config\getopt.c,config\getopt.c:163:163:NONOPTION_P:0,,true,163,163,NONOPTION_P,,,0,
220912,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,putchar,,true,,,putchar,,,0,
220916,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,puts,,true,,,puts,,,0,
220920,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,config\help.c,config\help.c:54:54:ShowConsole:0,,true,54,54,ShowConsole,,,0,
220923,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,printf,,true,,,printf,,,0,
220928,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,config\help.c,config\help.c:55:55:PauseConsole:0,,true,55,55,PauseConsole,,,0,
220931,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,config\help.c,config\help.c:236:236:RED:0,,true,236,236,RED,,,0,
220934,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,config\help.c,config\help.c:240:240:MAGENTA:0,,true,240,240,MAGENTA,,,0,
220937,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,config\help.c,config\help.c:239:239:BLUE:0,,true,239,239,BLUE,,,0,
220940,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,wcwidth,,true,,,wcwidth,,,0,
220944,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,iswspace,,true,,,iswspace,,,0,
220948,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fwrite,,true,,,fwrite,,,0,
220955,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,config\help.c,config\help.c:352:352:OPTION_VALUE_SEP:0,,true,352,352,OPTION_VALUE_SEP,,,0,
220958,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,config\help.c,config\help.c:237:237:GREEN:0,,true,237,237,GREEN,,,0,
220961,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,config\help.c,config\help.c:241:241:CYAN:0,,true,241,241,CYAN,,,0,
220964,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sprintf,,true,,,sprintf,,,0,
220969,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,config\help.c,config\help.c:242:242:WHITE:0,,true,242,242,WHITE,,,0,
220972,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,config\help.c,config\help.c:245:245:PADDING_SPACES:0,,true,245,245,PADDING_SPACES,,,0,
220975,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,config\help.c,config\help.c:244:244:LINE_START:0,,true,244,244,LINE_START,,,0,
220978,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strstr,,true,,,strstr,,,0,
220983,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,isatty,,true,,,isatty,,,0,
220987,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,config\help.c,config\help.c:-1:-1:__DATE__:0,,true,-1,-1,__DATE__,,,0,
220990,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_dyld_image_count,,true,,,_dyld_image_count,,,0,
220993,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_dyld_get_image_name,,true,,,_dyld_get_image_name,,,0,
220997,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,dirname,,true,,,dirname,,,0,
221001,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,dladdr,,true,,,dladdr,,,0,
221006,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CFBundleGetMainBundle,,true,,,CFBundleGetMainBundle,,,0,
221009,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CFBundleGetIdentifier,,true,,,CFBundleGetIdentifier,,,0,
221013,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CFStringGetLength,,true,,,CFStringGetLength,,,0,
221017,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CFStringGetMaximumSizeForEncoding,,true,,,CFStringGetMaximumSizeForEncoding,,,0,
221022,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CFStringGetCString,,true,,,CFStringGetCString,,,0,
221029,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CFNetworkCopySystemProxySettings,,true,,,CFNetworkCopySystemProxySettings,,,0,
221032,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CFDictionaryGetValue,,true,,,CFDictionaryGetValue,,,0,
221037,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CFNumberGetValue,,true,,,CFNumberGetValue,,,0,
221043,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CFRelease,,true,,,CFRelease,,,0,
221047,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,mach_timebase_info,,true,,,mach_timebase_info,,,0,
221051,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lldiv,,true,,,lldiv,,,0,
221056,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,backtrace,,true,,,backtrace,,,0,
221061,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,backtrace_symbols_fd,,true,,,backtrace_symbols_fd,,,0,
221067,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fsync,,true,,,fsync,,,0,
221071,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,darwin\thread.c,darwin\thread.c:110:112:VLC_THREAD_ASSERT:1,,true,110,112,VLC_THREAD_ASSERT,,,0,
221074,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_cond_init,,true,,,pthread_cond_init,,,0,
221079,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_cond_destroy,,true,,,pthread_cond_destroy,,,0,
221083,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_cond_signal,,true,,,pthread_cond_signal,,,0,
221087,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_cond_broadcast,,true,,,pthread_cond_broadcast,,,0,
221091,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_cond_wait,,true,,,pthread_cond_wait,,,0,
221096,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_testcancel,,true,,,pthread_testcancel,,,0,
221099,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_cond_timedwait_relative_np,,true,,,pthread_cond_timedwait_relative_np,,,0,
221105,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_cond_timedwait,,true,,,pthread_cond_timedwait,,,0,
221111,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,semaphore_create,,true,,,semaphore_create,,,0,
221118,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,mach_task_self,,true,,,mach_task_self,,,0,
221121,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,semaphore_destroy,,true,,,semaphore_destroy,,,0,
221126,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,semaphore_signal,,true,,,semaphore_signal,,,0,
221130,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,semaphore_wait,,true,,,semaphore_wait,,,0,
221134,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_rwlock_init,,true,,,pthread_rwlock_init,,,0,
221139,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_rwlock_destroy,,true,,,pthread_rwlock_destroy,,,0,
221143,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_rwlock_rdlock,,true,,,pthread_rwlock_rdlock,,,0,
221147,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_rwlock_wrlock,,true,,,pthread_rwlock_wrlock,,,0,
221151,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_rwlock_unlock,,true,,,pthread_rwlock_unlock,,,0,
221155,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_attr_setstacksize,,true,,,pthread_attr_setstacksize,,,0,
221160,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,darwin\thread.c,darwin\thread.c:445:445:VLC_STACKSIZE:0,,true,445,445,VLC_STACKSIZE,,,0,
221163,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_self,,true,,,pthread_self,,,0,
221166,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_cancel,,true,,,pthread_cancel,,,0,
221170,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_setcancelstate,,true,,,pthread_setcancelstate,,,0,
221175,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,darwin\thread.c,darwin\thread.c:-1:-1:__FILE__:0,,true,-1,-1,__FILE__,,,0,
221178,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,darwin\thread.c,darwin\thread.c:-1:-1:__LINE__:0,,true,-1,-1,__LINE__,,,0,
221181,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,darwin\thread.c,darwin\thread.c:55:56:vlc_clock_setup:0,,true,55,56,vlc_clock_setup,,,0,
221184,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_once,,true,,,pthread_once,,,0,
221189,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,mach_absolute_time,,true,,,mach_absolute_time,,,0,
221192,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nanosleep,,true,,,nanosleep,,,0,
221197,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,size_t,,true,,,size_t,,,0,
221201,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.arithmeticShiftRight,,true,,,<operator>.arithmeticShiftRight,,,0,
221206,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operators>.assignmentArithmeticShiftRight,,true,,,<operators>.assignmentArithmeticShiftRight,,,0,
221211,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_iconv_t,,true,,,vlc_iconv_t,,,0,
221215,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GCD,,true,,,GCD,,,0,
221220,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.assignmentDivision,,true,,,<operator>.assignmentDivision,,,0,
221225,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operators>.assignmentModulo,,true,,,<operators>.assignmentModulo,,,0,
221230,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,input\access.c,input\access.c:64:64:MAX_REDIR:0,,true,64,64,MAX_REDIR,,,0,
221233,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pf_readdir,,true,,,pf_readdir,,,0,
221239,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,input\clock.c,input\clock.c:139:139:INPUT_CLOCK_LATE_COUNT:0,,true,139,139,INPUT_CLOCK_LATE_COUNT,,,0,
221242,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,input\clock.c,input\clock.c:83:83:CR_MAX_GAP:0,,true,83,83,CR_MAX_GAP,,,0,
221245,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,__MAX,,true,,,__MAX,,,0,
221250,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,input\clock.c,input\clock.c:87:87:CR_MEAN_PTS_GAP:0,,true,87,87,CR_MEAN_PTS_GAP,,,0,
221253,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,input\clock.c,input\clock.c:92:92:CR_BUFFERING_RATE:0,,true,92,92,CR_BUFFERING_RATE,,,0,
221256,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,input\clock.c,input\clock.c:100:100:CR_BUFFERING_TARGET:0,,true,100,100,CR_BUFFERING_TARGET,,,0,
221259,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.modulo,,true,,,<operator>.modulo,,,0,
221264,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,__MIN,,true,,,__MIN,,,0,
221269,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,va_arg,,true,,,va_arg,,,0,
221274,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vasprintf,,true,,,vasprintf,,,0,
221280,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_seekpoint_Duplicate,,true,,,vlc_seekpoint_Duplicate,,,0,
221284,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TAB_APPEND,,true,,,TAB_APPEND,,,0,
221290,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_seekpoint_Delete,,true,,,vlc_seekpoint_Delete,,,0,
221294,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TAB_REMOVE,,true,,,TAB_REMOVE,,,0,
221300,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TAB_CLEAN,,true,,,TAB_CLEAN,,,0,
221305,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_input_title_Duplicate,,true,,,vlc_input_title_Duplicate,,,0,
221309,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,input_GetVout,,true,,,input_GetVout,,,0,
221313,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_input_attachment_Duplicate,,true,,,vlc_input_attachment_Duplicate,,,0,
221317,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,var_GetBool,,true,,,var_GetBool,,,0,
221322,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,es_out_Control,,true,,,es_out_Control,,,0,
221328,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,es_out_ControlGetPcrSystem,,true,,,es_out_ControlGetPcrSystem,,,0,
221334,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,es_out_ControlModifyPcrSystem,,true,,,es_out_ControlModifyPcrSystem,,,0,
221340,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_memstream_puts,,true,,,vlc_memstream_puts,,,0,
221345,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,input\decoder.c,input\decoder.c:134:134:MAX_CC_DECODERS:0,,true,134,134,MAX_CC_DECODERS,,,0,
221348,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_assert_locked,,true,,,vlc_assert_locked,,,0,
221352,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,video_format_AdjustColorSpace,,true,,,video_format_AdjustColorSpace,,,0,
221356,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,var_InheritInteger,,true,,,var_InheritInteger,,,0,
221361,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operators>.assignmentAnd,,true,,,<operators>.assignmentAnd,,,0,
221366,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,var_CreateGetBool,,true,,,var_CreateGetBool,,,0,
221371,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,input\decoder.c,input\decoder.c:151:151:DECODER_SPU_VOUT_WAIT_DURATION:0,,true,151,151,DECODER_SPU_VOUT_WAIT_DURATION,,,0,
221374,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pf_spu_buffer_new,,true,,,pf_spu_buffer_new,,,0,
221380,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,atomic_compare_exchange_strong,,true,,,atomic_compare_exchange_strong,,,0,
221386,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pf_get_attachments,,true,,,pf_get_attachments,,,0,
221393,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pf_get_display_date,,true,,,pf_get_display_date,,,0,
221399,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pf_get_display_rate,,true,,,pf_get_display_rate,,,0,
221404,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,block_Duplicate,,true,,,block_Duplicate,,,0,
221408,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pf_get_cc,,true,,,pf_get_cc,,,0,
221414,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,input\decoder.c,input\decoder.c:148:148:DECODER_BOGUS_VIDEO_DELAY:0,,true,148,148,DECODER_BOGUS_VIDEO_DELAY,,,0,
221417,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,mtime_t,,true,,,mtime_t,,,0,
221421,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pf_update_stat,,true,,,pf_update_stat,,,0,
221428,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pf_decode,,true,,,pf_decode,,,0,
221434,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,input\decoder.c,input\decoder.c:152:152:BLOCK_FLAG_CORE_PRIVATE_RELOADED:0,,true,152,152,BLOCK_FLAG_CORE_PRIVATE_RELOADED,,,0,
221437,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.shiftLeft,,true,,,<operator>.shiftLeft,,,0,
221442,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pf_packetize,,true,,,pf_packetize,,,0,
221448,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,block_ChainRelease,,true,,,block_ChainRelease,,,0,
221452,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pf_flush,,true,,,pf_flush,,,0,
221457,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_fifo_CleanupPush,,true,,,vlc_fifo_CleanupPush,,,0,
221461,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_fifo_IsEmpty,,true,,,vlc_fifo_IsEmpty,,,0,
221465,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_ascii_strcasecmp,,true,,,vlc_ascii_strcasecmp,,,0,
221470,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,input\demux.h,input\demux.h:37:37:demux_NewAdvanced:8,,true,37,37,demux_NewAdvanced,,,0,
221481,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,probe,,true,,,probe,,,0,
221485,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,stream_MimeType,,true,,,stream_MimeType,,,0,
221489,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pf_control,,true,,,pf_control,,,0,
221496,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,va_copy,,true,,,va_copy,,,0,
221501,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,stream_Size,,true,,,stream_Size,,,0,
221505,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,input\demux.c,input\demux.c:303:304:static_control_match:1,,true,303,304,static_control_match,,,0,
221508,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_stream_Control,,true,,,vlc_stream_Control,,,0,
221514,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,demux_Control,,true,,,demux_Control,,,0,
221521,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,demux_Demux,,true,,,demux_Demux,,,0,
221525,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TAB_INIT,,true,,,TAB_INIT,,,0,
221530,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,var_CountChoices,,true,,,var_CountChoices,,,0,
221535,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,input_item_SetESNowPlaying,,true,,,input_item_SetESNowPlaying,,,0,
221540,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,input_item_SetPublisher,,true,,,input_item_SetPublisher,,,0,
221545,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,input_item_SetTitle,,true,,,input_item_SetTitle,,,0,
221550,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_meta_SetNowPlaying,,true,,,vlc_meta_SetNowPlaying,,,0,
221555,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,input_item_GetArtURL,,true,,,input_item_GetArtURL,,,0,
221559,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,input_item_SetArtURL,,true,,,input_item_SetArtURL,,,0,
221564,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strtok_r,,true,,,strtok_r,,,0,
221570,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,atoi,,true,,,atoi,,,0,
221574,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,libvlc_stats,,true,,,libvlc_stats,,,0,
221578,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,input\es_out.c,input\es_out.c:2362:2362:IGNORE_ES:0,,true,2362,2362,IGNORE_ES,,,0,
221581,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,input\input_internal.h,input\input_internal.h:248:248:INPUT_PTS_DELAY_MAX:0,,true,248,248,INPUT_PTS_DELAY_MAX,,,0,
221584,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,VLC_FOURCC,,true,,,VLC_FOURCC,,,0,
221591,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_pgettext,,true,,,vlc_pgettext,,,0,
221596,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,var_CreateGetInteger,,true,,,var_CreateGetInteger,,,0,
221601,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,es_out_vaControl,,true,,,es_out_vaControl,,,0,
221607,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,mutex_cleanup_push,,true,,,mutex_cleanup_push,,,0,
221611,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,realloc,,true,,,realloc,,,0,
221616,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ftell,,true,,,ftell,,,0,
221620,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fseek,,true,,,fseek,,,0,
221626,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,es_out_Add,,true,,,es_out_Add,,,0,
221631,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,es_out_Send,,true,,,es_out_Send,,,0,
221637,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,es_out_Del,,true,,,es_out_Del,,,0,
221642,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TAB_ERASE,,true,,,TAB_ERASE,,,0,
221648,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,es_out_Delete,,true,,,es_out_Delete,,,0,
221652,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,var_InheritAddress,,true,,,var_InheritAddress,,,0,
221657,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_seekpoint_New,,true,,,vlc_seekpoint_New,,,0,
221660,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,input_item_SetNowPlaying,,true,,,input_item_SetNowPlaying,,,0,
221665,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,input\input.c,input\input.c:822:824:INIT_COUNTER:2,,true,822,824,INIT_COUNTER,,,0,
221668,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,llroundf,,true,,,llroundf,,,0,
221672,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,var_CreateGetFloat,,true,,,var_CreateGetFloat,,,0,
221677,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,input_item_slave_Delete,,true,,,input_item_slave_Delete,,,0,
221681,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,input\input.c,input\input.c:107:107:SLAVE_ADD_CANFAIL:0,,true,107,107,SLAVE_ADD_CANFAIL,,,0,
221684,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,input\input.c,input\input.c:105:105:SLAVE_ADD_NOFLAG:0,,true,105,105,SLAVE_ADD_NOFLAG,,,0,
221687,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,input\input.c,input\input.c:106:106:SLAVE_ADD_FORCED:0,,true,106,106,SLAVE_ADD_FORCED,,,0,
221690,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_input_attachment_New,,true,,,vlc_input_attachment_New,,,0,
221698,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_input_attachment_Delete,,true,,,vlc_input_attachment_Delete,,,0,
221702,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,es_out_ControlSetMeta,,true,,,es_out_ControlSetMeta,,,0,
221707,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,input\input.c,input\input.c:1461:1463:EXIT_COUNTER:1,,true,1461,1463,EXIT_COUNTER,,,0,
221710,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,input\input.c,input\input.c:1530:1534:CL_CO:1,,true,1530,1534,CL_CO,,,0,
221713,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,input\input_internal.h,input\input_internal.h:41:41:INPUT_CONTROL_FIFO_SIZE:0,,true,41,41,INPUT_CONTROL_FIFO_SIZE,,,0,
221716,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_viewpoint_clip,,true,,,vlc_viewpoint_clip,,,0,
221720,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lroundf,,true,,,lroundf,,,0,
221724,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,VLC_CLIP,,true,,,VLC_CLIP,,,0,
221730,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,input\input.c,input\input.c:108:108:SLAVE_ADD_SET_TIME:0,,true,108,108,SLAVE_ADD_SET_TIME,,,0,
221733,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_input_title_Delete,,true,,,vlc_input_title_Delete,,,0,
221737,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EnsureUTF8,,true,,,EnsureUTF8,,,0,
221741,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,S_ISREG,,true,,,S_ISREG,,,0,
221745,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strtoul,,true,,,strtoul,,,0,
221751,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,input\input.c,input\input.c:3516:3516:I:1,,true,3516,3516,I,,,0,
221754,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,str_format,,true,,,str_format,,,0,
221759,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,container_of,,true,,,container_of,,,0,
221765,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strcasestr,,true,,,strcasestr,,,0,
221770,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EMPTY_STR,,true,,,EMPTY_STR,,,0,
221774,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,input\item.h,input\item.h:40:40:item_owner:1,,true,40,40,item_owner,,,0,
221778,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,atomic_fetch_sub,,true,,,atomic_fetch_sub,,,0,
221783,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strncasecmp,,true,,,strncasecmp,,,0,
221789,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tolower,,true,,,tolower,,,0,
221793,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strncpy,,true,,,strncpy,,,0,
221799,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_dictionary_init,,true,,,vlc_dictionary_init,,,0,
221804,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_dictionary_clear,,true,,,vlc_dictionary_clear,,,0,
221810,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsUTF8,,true,,,IsUTF8,,,0,
221814,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_dictionary_value_for_key,,true,,,vlc_dictionary_value_for_key,,,0,
221819,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_dictionary_remove_value_for_key,,true,,,vlc_dictionary_remove_value_for_key,,,0,
221826,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_dictionary_insert,,true,,,vlc_dictionary_insert,,,0,
221832,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_dictionary_keys_count,,true,,,vlc_dictionary_keys_count,,,0,
221836,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_dictionary_all_keys,,true,,,vlc_dictionary_all_keys,,,0,
221840,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,input\mrl_helpers.h,input\mrl_helpers.h:69:69:RFC3986_FRAGMENT:0,,true,69,69,RFC3986_FRAGMENT,,,0,
221843,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_array_init,,true,,,vlc_array_init,,,0,
221847,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_array_append,,true,,,vlc_array_append,,,0,
221852,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_array_count,,true,,,vlc_array_count,,,0,
221856,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_array_item_at_index,,true,,,vlc_array_item_at_index,,,0,
221861,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_array_clear,,true,,,vlc_array_clear,,,0,
221865,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vout_CloseAndRelease,,true,,,vout_CloseAndRelease,,,0,
221869,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,input_item_GetArtist,,true,,,input_item_GetArtist,,,0,
221873,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,input_item_GetTitle,,true,,,input_item_GetTitle,,,0,
221877,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,audio_output\aout_internal.h,audio_output\aout_internal.h:125:125:aout_New:1,,true,125,125,aout_New,,,0,
221881,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_probe_add,,true,,,vlc_probe_add,,,0,
221887,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TAB_INSERT,,true,,,TAB_INSERT,,,0,
221894,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_stream_NewURL,,true,,,vlc_stream_NewURL,,,0,
221899,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,input\stream.c,input\stream.c:170:170:STREAM_PROBE_LINE:0,,true,170,170,STREAM_PROBE_LINE,,,0,
221902,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,U16_AT,,true,,,U16_AT,,,0,
221906,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,realloc_or_free,,true,,,realloc_or_free,,,0,
221911,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,input\stream.c,input\stream.c:171:171:STREAM_LINE_MAX:0,,true,171,171,STREAM_LINE_MAX,,,0,
221914,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pf_read,,true,,,pf_read,,,0,
221920,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pf_block,,true,,,pf_block,,,0,
221926,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pf_seek,,true,,,pf_seek,,,0,
221932,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,isalnum,,true,,,isalnum,,,0,
221936,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strlcpy,,true,,,strlcpy,,,0,
221942,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,closedir,,true,,,closedir,,,0,
221946,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,var_CreateGetString,,true,,,var_CreateGetString,,,0,
221951,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,time,,true,,,time,,,0,
221955,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pf_media_del,,true,,,pf_media_del,,,0,
221961,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,input_item_New,,true,,,input_item_New,,,0,
221966,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pf_media_new,,true,,,pf_media_new,,,0,
221973,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlm_media_Clean,,true,,,vlm_media_Clean,,,0,
221977,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlm_media_Copy,,true,,,vlm_media_Copy,,,0,
221982,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlm_media_Duplicate,,true,,,vlm_media_Duplicate,,,0,
221986,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlm_media_instance_New,,true,,,vlm_media_instance_New,,,0,
221989,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pf_cancel,,true,,,pf_cancel,,,0,
221995,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_array_index_of_item,,true,,,vlc_array_index_of_item,,,0,
222000,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_array_remove,,true,,,vlc_array_remove,,,0,
222005,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pf_display_error,,true,,,pf_display_error,,,0,
222012,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,msg_GenericVa,,true,,,msg_GenericVa,,,0,
222019,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pf_display_login,,true,,,pf_display_login,,,0,
222029,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pf_display_question,,true,,,pf_display_question,,,0,
222041,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pf_display_progress,,true,,,pf_display_progress,,,0,
222052,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pf_update_progress,,true,,,pf_update_progress,,,0,
222060,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_dialog_provider.pf_ext_update,,true,,,pf_ext_update,,,0,
222066,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,playlist\playlist_internal.h,playlist\playlist_internal.h:96:96:pl_priv:1,,true,96,96,pl_priv,,,0,
222070,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,config\configuration.h,config\configuration.h:37:37:config_LoadCmdLine:4,,true,37,37,config_LoadCmdLine,,,0,
222077,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,modules\modules.h,modules\modules.h:116:116:module_LoadPlugins:1,,true,116,116,module_LoadPlugins,,,0,
222081,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,config\configuration.h,config\configuration.h:38:38:config_LoadConfigFile:1,,true,38,38,config_LoadConfigFile,,,0,
222085,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,exit,,true,,,exit,,,0,
222089,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\variables.h,misc\variables.h:60:60:vlc_internals:1,,true,60,60,vlc_internals,,,0,
222093,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fopen,,true,,,fopen,,,0,
222098,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sscanf,,true,,,sscanf,,,0,
222105,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getaddrinfo_a,,true,,,getaddrinfo_a,,,0,
222112,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gai_cancel,,true,,,gai_cancel,,,0,
222116,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gai_suspend,,true,,,gai_suspend,,,0,
222122,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gai_error,,true,,,gai_error,,,0,
222126,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,syscall,,true,,,syscall,,,0,
222136,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,linux\thread.c,linux\thread.c:34:34:FUTEX_WAKE_PRIVATE:0,,true,34,34,FUTEX_WAKE_PRIVATE,,,0,
222139,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,linux\thread.c,linux\thread.c:35:35:FUTEX_WAIT_PRIVATE:0,,true,35,35,FUTEX_WAIT_PRIVATE,,,0,
222142,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\actions.c,misc\actions.c:120:120:KEYS_COUNT:0,,true,120,120,KEYS_COUNT,,,0,
222145,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tr,,true,,,tr,,,0,
222149,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\actions.c,misc\actions.c:259:259:MAXACTION:0,,true,259,259,MAXACTION,,,0,
222152,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tfind,,true,,,tfind,,,0,
222158,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tsearch,,true,,,tsearch,,,0,
222164,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\actions.c,misc\actions.c:379:379:ACTIONS_COUNT:0,,true,379,379,ACTIONS_COUNT,,,0,
222167,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tdestroy,,true,,,tdestroy,,,0,
222172,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ARRAY_INIT,,true,,,ARRAY_INIT,,,0,
222176,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FOREACH_ARRAY,,true,,,FOREACH_ARRAY,,,0,
222181,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FOREACH_END,,true,,,FOREACH_END,,,0,
222184,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ARRAY_RESET,,true,,,ARRAY_RESET,,,0,
222188,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\addons.c,misc\addons.c:160:164:INIT_QUEUE:1,,true,160,164,INIT_QUEUE,,,0,
222191,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\addons.c,misc\addons.c:195:202:FREE_QUEUE:1,,true,195,202,FREE_QUEUE,,,0,
222194,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ARRAY_APPEND,,true,,,ARRAY_APPEND,,,0,
222199,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,addon_found,,true,,,addon_found,,,0,
222205,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pf_find,,true,,,pf_find,,,0,
222212,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ARRAY_REMOVE,,true,,,ARRAY_REMOVE,,,0,
222217,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,discovery_ended,,true,,,discovery_ended,,,0,
222222,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pf_catalog,,true,,,pf_catalog,,,0,
222229,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pf_install,,true,,,pf_install,,,0,
222235,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pf_remove,,true,,,pf_remove,,,0,
222241,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,addon_changed,,true,,,addon_changed,,,0,
222247,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\block.c,misc\block.c:115:115:BLOCK_ALIGN:0,,true,115,115,BLOCK_ALIGN,,,0,
222250,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\block.c,misc\block.c:118:118:BLOCK_PADDING:0,,true,118,118,BLOCK_PADDING,,,0,
222253,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fstat,,true,,,fstat,,,0,
222258,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,S_ISDIR,,true,,,S_ISDIR,,,0,
222262,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\block.c,misc\block.c:381:381:S_TYPEISSHM:1,,true,381,381,S_TYPEISSHM,,,0,
222265,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,block_cleanup_push,,true,,,block_cleanup_push,,,0,
222269,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pread,,true,,,pread,,,0,
222276,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ORIENT_IS_MIRROR,,true,,,ORIENT_IS_MIRROR,,,0,
222280,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,transform_Inverse,,true,,,transform_Inverse,,,0,
222284,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.xor,,true,,,<operator>.xor,,,0,
222289,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ORIENT_IS_SWAP,,true,,,ORIENT_IS_SWAP,,,0,
222293,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,video_format_Init,,true,,,video_format_Init,,,0,
222298,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,video_format_Copy,,true,,,video_format_Copy,,,0,
222303,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,video_format_Clean,,true,,,video_format_Clean,,,0,
222307,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_event_listener_t.pf_callback,,true,,,pf_callback,,,0,
222313,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pf_video_blend,,true,,,pf_video_blend,,,0,
222323,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,buffer_new,,true,,,buffer_new,,,0,
222328,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_mouse_Init,,true,,,vlc_mouse_Init,,,0,
222332,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,cb,,true,,,cb,,,0,
222340,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pf_video_filter,,true,,,pf_video_filter,,,0,
222346,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pf_sub_source,,true,,,pf_sub_source,,,0,
222352,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pf_sub_filter,,true,,,pf_sub_filter,,,0,
222358,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pf_video_mouse,,true,,,pf_video_mouse,,,0,
222366,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pf_sub_mouse,,true,,,pf_sub_mouse,,,0,
222374,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\fourcc.c,misc\fourcc.c:253:256:VLC_CODEC_FALLBACK_420:0,,true,253,256,VLC_CODEC_FALLBACK_420,,,0,
222377,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\fourcc.c,misc\fourcc.c:271:272:VLC_CODEC_FALLBACK_420_16:0,,true,271,272,VLC_CODEC_FALLBACK_420_16,,,0,
222380,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\fourcc.c,misc\fourcc.c:303:306:VLC_CODEC_FALLBACK_422:0,,true,303,306,VLC_CODEC_FALLBACK_422,,,0,
222383,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\fourcc.c,misc\fourcc.c:315:316:VLC_CODEC_FALLBACK_422_16:0,,true,315,316,VLC_CODEC_FALLBACK_422_16,,,0,
222386,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\fourcc.c,misc\fourcc.c:337:340:VLC_CODEC_FALLBACK_444:0,,true,337,340,VLC_CODEC_FALLBACK_444,,,0,
222389,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\fourcc.c,misc\fourcc.c:349:350:VLC_CODEC_FALLBACK_444_16:0,,true,349,350,VLC_CODEC_FALLBACK_444_16,,,0,
222392,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\fourcc.c,misc\fourcc.c:212:213:VLC_CODEC_YUV_PLANAR_420:0,,true,212,213,VLC_CODEC_YUV_PLANAR_420,,,0,
222395,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\fourcc.c,misc\fourcc.c:224:225:VLC_CODEC_YUV_PLANAR_422:0,,true,224,225,VLC_CODEC_YUV_PLANAR_422,,,0,
222398,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\fourcc.c,misc\fourcc.c:236:237:VLC_CODEC_YUV_PLANAR_444:0,,true,236,237,VLC_CODEC_YUV_PLANAR_444,,,0,
222401,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\fourcc.c,misc\fourcc.c:249:251:VLC_CODEC_YUV_PACKED:0,,true,249,251,VLC_CODEC_YUV_PACKED,,,0,
222404,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\fourcc.c,misc\fourcc.c:209:210:VLC_CODEC_YUV_PLANAR_410:0,,true,209,210,VLC_CODEC_YUV_PLANAR_410,,,0,
222407,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\fourcc.c,misc\fourcc.c:428:431:VLC_CODEC_FALLBACK_PACKED:0,,true,428,431,VLC_CODEC_FALLBACK_PACKED,,,0,
222410,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\fourcc.c,misc\fourcc.c:215:216:VLC_CODEC_YUV_SEMIPLANAR_420:0,,true,215,216,VLC_CODEC_YUV_SEMIPLANAR_420,,,0,
222413,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\fourcc.c,misc\fourcc.c:227:228:VLC_CODEC_YUV_SEMIPLANAR_422:0,,true,227,228,VLC_CODEC_YUV_SEMIPLANAR_422,,,0,
222416,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\fourcc.c,misc\fourcc.c:233:234:VLC_CODEC_YUV_PLANAR_440:0,,true,233,234,VLC_CODEC_YUV_PLANAR_440,,,0,
222419,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\fourcc.c,misc\fourcc.c:239:240:VLC_CODEC_YUV_PLANAR_444_ALPHA:0,,true,239,240,VLC_CODEC_YUV_PLANAR_444_ALPHA,,,0,
222422,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\fourcc.c,misc\fourcc.c:242:243:VLC_CODEC_YUV_SEMIPLANAR_444:0,,true,242,243,VLC_CODEC_YUV_SEMIPLANAR_444,,,0,
222425,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\fourcc.c,misc\fourcc.c:218:219:VLC_CODEC_YUV_PLANAR_420_16:0,,true,218,219,VLC_CODEC_YUV_PLANAR_420_16,,,0,
222428,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\fourcc.c,misc\fourcc.c:221:222:VLC_CODEC_YUV_SEMIPLANAR_420_16:0,,true,221,222,VLC_CODEC_YUV_SEMIPLANAR_420_16,,,0,
222431,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\fourcc.c,misc\fourcc.c:230:231:VLC_CODEC_YUV_PLANAR_422_16:0,,true,230,231,VLC_CODEC_YUV_PLANAR_422_16,,,0,
222434,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\fourcc.c,misc\fourcc.c:245:247:VLC_CODEC_YUV_PLANAR_444_16:0,,true,245,247,VLC_CODEC_YUV_PLANAR_444_16,,,0,
222437,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\fourcc_gen.c,misc\fourcc_gen.c:147:149:p:1,,true,147,149,p,,,0,
222440,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,B,,true,,,B,,,0,
222445,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,A,,true,,,A,,,0,
222449,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,E,,true,,,E,,,0,
222454,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_ascii_strncasecmp,,true,,,vlc_ascii_strncasecmp,,,0,
222460,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_stream_GetSize,,true,,,vlc_stream_GetSize,,,0,
222465,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pf_encode_video,,true,,,pf_encode_video,,,0,
222471,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,filter_NewPicture,,true,,,filter_NewPicture,,,0,
222475,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,callback,,true,,,callback,,,0,
222480,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"atomic_load(&from->killed) ? vlc_interrupt_kill
                                : vlc_interrupt_raise",,true,,,"atomic_load(&from->killed) ? vlc_interrupt_kill
                                : vlc_interrupt_raise",,,0,
222485,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,write,,true,,,write,,,0,
222491,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,poll,,true,,,poll,,,0,
222497,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,read,,true,,,read,,,0,
222503,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,readv,,true,,,readv,,,0,
222510,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,writev,,true,,,writev,,,0,
222516,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,recvmsg,,true,,,recvmsg,,,0,
222522,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sendmsg,,true,,,sendmsg,,,0,
222528,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strtol,,true,,,strtol,,,0,
222534,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pf_store,,true,,,pf_store,,,0,
222543,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_keystore_release_entry,,true,,,vlc_keystore_release_entry,,,0,
222547,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\md5.c,misc\md5.c:109:116:OP:6,,true,109,116,OP,,,0,
222556,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\md5.c,misc\md5.c:143:150:OP:8,,true,143,150,OP,,,0,
222566,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operators>.assignmentShiftLeft,,true,,,<operators>.assignmentShiftLeft,,,0,
222571,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\md5.c,misc\md5.c:317:317:X:1,,true,317,317,X,,,0,
222574,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_logger_t.log,,true,,,log,,,0,
222583,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,activate,,true,,,activate,,,0,
222588,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,deactivate,,true,,,deactivate,,,0,
222592,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,div,,true,,,div,,,0,
222597,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,timespec_get,,true,,,timespec_get,,,0,
222602,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uint64_t,,true,,,uint64_t,,,0,
222606,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,UINT64_C,,true,,,UINT64_C,,,0,
222610,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\variables.h,misc\variables.h:61:61:vlc_externals:1,,true,61,61,vlc_externals,,,0,
222614,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_object_internals.pf_destructor,,true,,,pf_destructor,,,0,
222619,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,atomic_compare_exchange_weak,,true,,,atomic_compare_exchange_weak,,,0,
222625,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,add_overflow,,true,,,add_overflow,,,0,
222631,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,release,,true,,,release,,,0,
222636,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,match,,true,,,match,,,0,
222641,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,mul_overflow,,true,,,mul_overflow,,,0,
222647,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\picture.c,misc\picture.c:41:41:PICTURE_SW_SIZE_MAX:0,,true,41,41,PICTURE_SW_SIZE_MAX,,,0,
222650,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,aligned_alloc,,true,,,aligned_alloc,,,0,
222655,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,destroy,,true,,,destroy,,,0,
222660,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,aligned_free,,true,,,aligned_free,,,0,
222664,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,anonymous_type_0.destroy,,true,,,destroy,,,0,
222669,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,copy,,true,,,copy,,,0,
222674,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,image_Write,,true,,,image_Write,,,0,
222681,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\picture_pool.c,misc\picture_pool.c:37:37:POOL_MAX:0,,true,37,37,POOL_MAX,,,0,
222684,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pic_unlock,,true,,,pic_unlock,,,0,
222689,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ffsll,,true,,,ffsll,,,0,
222693,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pic_lock,,true,,,pic_lock,,,0,
222698,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,erand48,,true,,,erand48,,,0,
222702,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nrand48,,true,,,nrand48,,,0,
222706,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,jrand48,,true,,,jrand48,,,0,
222710,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pf_destroy,,true,,,pf_destroy,,,0,
222715,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,image_Convert,,true,,,image_Convert,,,0,
222722,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pf_validate,,true,,,pf_validate,,,0,
222732,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pf_update,,true,,,pf_update,,,0,
222740,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\text_style.c,misc\text_style.c:90:92:MERGE:2,,true,90,92,MERGE,,,0,
222744,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\text_style.c,misc\text_style.c:94:96:MERGE_SIZE:1,,true,94,96,MERGE_SIZE,,,0,
222747,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,isspace,,true,,,isspace,,,0,
222751,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_gcrypt_init,,true,,,vlc_gcrypt_init,,,0,
222754,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\update.c,misc\update.c:84:84:UPDATE_VLC_STATUS_URL:0,,true,84,84,UPDATE_VLC_STATUS_URL,,,0,
222757,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,p_uct->pf_callback,,true,,,p_uct->pf_callback,,,0,
222763,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\update.c,misc\update.c:89:91:dialog_FatalWait:4,,true,89,91,dialog_FatalWait,,,0,
222768,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\update_crypto.c,misc\update_crypto.c:97:102:READ_MPI:2,,true,97,102,READ_MPI,,,0,
222773,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,U32_AT,,true,,,U32_AT,,,0,
222777,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\update_crypto.c,misc\update_crypto.c:353:353:CRC24_INIT:0,,true,353,353,CRC24_INIT,,,0,
222780,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operators>.assignmentXor,,true,,,<operators>.assignmentXor,,,0,
222785,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\update_crypto.c,misc\update_crypto.c:354:354:CRC24_POLY:0,,true,354,354,CRC24_POLY,,,0,
222788,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gcry_md_get_algo_dlen,,true,,,gcry_md_get_algo_dlen,,,0,
222792,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gcry_md_algo_info,,true,,,gcry_md_algo_info,,,0,
222799,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gcry_mpi_scan,,true,,,gcry_mpi_scan,,,0,
222807,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gcry_sexp_build,,true,,,gcry_sexp_build,,,0,
222814,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gcry_pk_verify,,true,,,gcry_pk_verify,,,0,
222820,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gcry_mpi_release,,true,,,gcry_mpi_release,,,0,
222824,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gcry_sexp_release,,true,,,gcry_sexp_release,,,0,
222828,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\update_crypto.c,misc\update_crypto.c:53:53:packet_type:1,,true,53,53,packet_type,,,0,
222832,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\update_crypto.c,misc\update_crypto.c:54:54:packet_header_len:1,,true,54,54,packet_header_len,,,0,
222836,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\update_crypto.c,misc\update_crypto.c:614:614:PUBLIC_KEY_FOUND:0,,true,614,614,PUBLIC_KEY_FOUND,,,0,
222839,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\update_crypto.c,misc\update_crypto.c:616:616:SIGNATURE_FOUND:0,,true,616,616,SIGNATURE_FOUND,,,0,
222842,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,misc\update_crypto.c,misc\update_crypto.c:615:615:USER_ID_FOUND:0,,true,615,615,USER_ID_FOUND,,,0,
222845,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gcry_md_write,,true,,,gcry_md_write,,,0,
222851,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gcry_md_putc,,true,,,gcry_md_putc,,,0,
222856,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gcry_md_final,,true,,,gcry_md_final,,,0,
222860,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gcry_md_read,,true,,,gcry_md_read,,,0,
222865,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gcry_md_close,,true,,,gcry_md_close,,,0,
222869,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gcry_md_open,,true,,,gcry_md_open,,,0,
222875,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,isless,,true,,,isless,,,0,
222880,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,isgreater,,true,,,isgreater,,,0,
222885,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,callback_entry_t.pf_value_callback,,true,,,pf_value_callback,,,0,
222894,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,callback_entry_t.pf_list_callback,,true,,,pf_list_callback,,,0,
222903,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tdelete,,true,,,tdelete,,,0,
222909,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,twalk,,true,,,twalk,,,0,
222914,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,modules\modules.h,modules\modules.h:69:69:MODULE_SHORTCUT_MAX:0,,true,69,69,MODULE_SHORTCUT_MAX,,,0,
222917,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,init,,true,,,init,,,0,
222922,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,libvlc.h,libvlc.h:116:116:vlc_object_set_name:2,,true,116,116,vlc_object_set_name,,,0,
222927,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,deinit,,true,,,deinit,,,0,
222932,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,psz_md5_hash,,true,,,psz_md5_hash,,,0,
222936,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pf_fill,,true,,,pf_fill,,,0,
222951,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,xrealloc,,true,,,xrealloc,,,0,
222956,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,network\httpd.c,network\httpd.c:66:66:HTTPD_CL_BUFSIZE:0,,true,66,66,HTTPD_CL_BUFSIZE,,,0,
222959,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,net_ListenTCP,,true,,,net_ListenTCP,,,0,
222965,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,net_GetPeerAddress,,true,,,net_GetPeerAddress,,,0,
222971,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_tls_GetFD,,true,,,vlc_tls_GetFD,,,0,
222975,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,net_GetSockAddress,,true,,,net_GetSockAddress,,,0,
222981,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_tls_Close,,true,,,vlc_tls_Close,,,0,
222985,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,atol,,true,,,atol,,,0,
222989,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_tls_SessionHandshake,,true,,,vlc_tls_SessionHandshake,,,0,
222994,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,setsockopt,,true,,,setsockopt,,,0,
223002,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gai_strerror,,true,,,gai_strerror,,,0,
223006,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,bind,,true,,,bind,,,0,
223012,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,net_Close,,true,,,net_Close,,,0,
223016,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,net_SockAddrIsMulticast,,true,,,net_SockAddrIsMulticast,,,0,
223021,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,listen,,true,,,listen,,,0,
223026,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,freeaddrinfo,,true,,,freeaddrinfo,,,0,
223030,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_recv_i11e,,true,,,vlc_recv_i11e,,,0,
223037,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_send_i11e,,true,,,vlc_send_i11e,,,0,
223044,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,recv,,true,,,recv,,,0,
223051,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,net_Write,,true,,,net_Write,,,0,
223058,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CMSG_FIRSTHDR,,true,,,CMSG_FIRSTHDR,,,0,
223062,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CMSG_NXTHDR,,true,,,CMSG_NXTHDR,,,0,
223067,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,network\rootbind.c,network\rootbind.c:58:58:CMSG_LEN:1,,true,58,58,CMSG_LEN,,,0,
223070,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CMSG_DATA,,true,,,CMSG_DATA,,,0,
223074,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,send,,true,,,send,,,0,
223081,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,network\rootbind.c,network\rootbind.c:64:64:MSG_NOSIGNAL:0,,true,64,64,MSG_NOSIGNAL,,,0,
223084,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,connect,,true,,,connect,,,0,
223090,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getsockopt,,true,,,getsockopt,,,0,
223098,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,net_Read,,true,,,net_Read,,,0,
223105,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetWBE,,true,,,SetWBE,,,0,
223110,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,open,,true,,,open,,,0,
223116,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,close,,true,,,close,,,0,
223120,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,handshake,,true,,,handshake,,,0,
223129,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,shutdown,,true,,,shutdown,,,0,
223134,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,network\tls.c,network\tls.c:48:48:SOL_TCP:0,,true,48,48,SOL_TCP,,,0,
223137,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,if_nametoindex,,true,,,if_nametoindex,,,0,
223141,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getsockname,,true,,,getsockname,,,0,
223147,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,network\udp.c,network\udp.c:60:60:SOL_IP:0,,true,60,60,SOL_IP,,,0,
223150,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DosQueryModFromEIP,,true,,,DosQueryModFromEIP,,,0,
223159,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DosQueryModuleName,,true,,,DosQueryModuleName,,,0,
223165,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FromLocaleDup,,true,,,FromLocaleDup,,,0,
223169,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ToLocaleDup,,true,,,ToLocaleDup,,,0,
223173,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fcntl,,true,,,fcntl,,,0,
223179,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,mkdir,,true,,,mkdir,,,0,
223184,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,opendir,,true,,,opendir,,,0,
223188,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,readdir_r,,true,,,readdir_r,,,0,
223194,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lstat,,true,,,lstat,,,0,
223199,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,rename,,true,,,rename,,,0,
223204,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pathconf,,true,,,pathconf,,,0,
223209,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getcwd,,true,,,getcwd,,,0,
223214,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,dup,,true,,,dup,,,0,
223218,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,setmode,,true,,,setmode,,,0,
223223,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sigtimedwait,,true,,,sigtimedwait,,,0,
223229,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sigismember,,true,,,sigismember,,,0,
223234,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,socket,,true,,,socket,,,0,
223240,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,socketpair,,true,,,socketpair,,,0,
223247,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,accept,,true,,,accept,,,0,
223253,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,os2\getaddrinfo.c,os2\getaddrinfo.c:35:36:_NI_MASK:0,,true,35,36,_NI_MASK,,,0,
223256,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ntohl,,true,,,ntohl,,,0,
223260,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ntohs,,true,,,ntohs,,,0,
223264,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,os2\getaddrinfo.c,os2\getaddrinfo.c:89:89:_AI_MASK:0,,true,89,89,_AI_MASK,,,0,
223267,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,htonl,,true,,,htonl,,,0,
223271,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,inet_addr,,true,,,inet_addr,,,0,
223275,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gethostbyname,,true,,,gethostbyname,,,0,
223279,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,htons,,true,,,htons,,,0,
223283,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,dlopen,,true,,,dlopen,,,0,
223288,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,dlerror,,true,,,dlerror,,,0,
223291,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,dlclose,,true,,,dlclose,,,0,
223295,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,dlsym,,true,,,dlsym,,,0,
223300,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DosTmrQueryTime,,true,,,DosTmrQueryTime,,,0,
223304,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uint8_t,,true,,,uint8_t,,,0,
223308,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,rand,,true,,,rand,,,0,
223311,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DosConnectNPipe,,true,,,DosConnectNPipe,,,0,
223315,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DosRead,,true,,,DosRead,,,0,
223322,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,os2\specific.c,os2\specific.c:38:38:IPC_CMD_ENQUEUE:0,,true,38,38,IPC_CMD_ENQUEUE,,,0,
223325,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DosDisConnectNPipe,,true,,,DosDisConnectNPipe,,,0,
223329,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,os2\specific.c,os2\specific.c:39:39:IPC_CMD_QUIT:0,,true,39,39,IPC_CMD_QUIT,,,0,
223332,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DosClose,,true,,,DosClose,,,0,
223336,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fileno,,true,,,fileno,,,0,
223340,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DosSetPriority,,true,,,DosSetPriority,,,0,
223347,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_gettid,,true,,,_gettid,,,0,
223350,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_beginthread,,true,,,_beginthread,,,0,
223357,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,os2\specific.c,os2\specific.c:37:37:IPC_CMD_GO:0,,true,37,37,IPC_CMD_GO,,,0,
223360,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DosWrite,,true,,,DosWrite,,,0,
223367,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DosWaitThread,,true,,,DosWaitThread,,,0,
223372,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DosWaitEventSem,,true,,,DosWaitEventSem,,,0,
223377,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DosSleep,,true,,,DosSleep,,,0,
223381,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DosCreateMuxWaitSem,,true,,,DosCreateMuxWaitSem,,,0,
223389,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DosWaitMuxWaitSem,,true,,,DosWaitMuxWaitSem,,,0,
223395,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DosCloseMuxWaitSem,,true,,,DosCloseMuxWaitSem,,,0,
223399,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DosCreateMutexSem,,true,,,DosCreateMutexSem,,,0,
223406,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DosCloseMutexSem,,true,,,DosCloseMutexSem,,,0,
223410,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DosRequestMutexSem,,true,,,DosRequestMutexSem,,,0,
223415,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DosReleaseMutexSem,,true,,,DosReleaseMutexSem,,,0,
223419,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DosCreateEventSem,,true,,,DosCreateEventSem,,,0,
223426,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DosCloseEventSem,,true,,,DosCloseEventSem,,,0,
223430,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,__atomic_cmpxchg32,,true,,,__atomic_cmpxchg32,,,0,
223436,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,__atomic_xchg,,true,,,__atomic_xchg,,,0,
223441,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DosPostEventSem,,true,,,DosPostEventSem,,,0,
223445,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DosResetEventSem,,true,,,DosResetEventSem,,,0,
223450,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,__atomic_increment,,true,,,__atomic_increment,,,0,
223454,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,__atomic_decrement,,true,,,__atomic_decrement,,,0,
223458,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gettimeofday,,true,,,gettimeofday,,,0,
223463,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DosAllocThreadLocalMemory,,true,,,DosAllocThreadLocalMemory,,,0,
223468,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DosFreeThreadLocalMemory,,true,,,DosFreeThreadLocalMemory,,,0,
223472,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,soclose,,true,,,soclose,,,0,
223476,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HIBYTE,,true,,,HIBYTE,,,0,
223480,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LOBYTE,,true,,,LOBYTE,,,0,
223484,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,so_cancel,,true,,,so_cancel,,,0,
223488,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,proc,,true,,,proc,,,0,
223493,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_endthread,,true,,,_endthread,,,0,
223496,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FD_SET,,true,,,FD_SET,,,0,
223501,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MAX,,true,,,MAX,,,0,
223506,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,select,,true,,,select,,,0,
223510,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FD_ZERO,,true,,,FD_ZERO,,,0,
223514,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.bracketedPrimary,,true,,,<operator>.bracketedPrimary,,,0,
223518,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,S_ISSOCK,,true,,,S_ISSOCK,,,0,
223522,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FD_ISSET,,true,,,FD_ISSET,,,0,
223527,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DosTmrQueryFreq,,true,,,DosTmrQueryFreq,,,0,
223531,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,os2\thread.c,os2\thread.c:869:869:Q2LL:1,,true,869,869,Q2LL,,,0,
223535,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DosAsyncTimer,,true,,,DosAsyncTimer,,,0,
223541,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DosStopTimer,,true,,,DosStopTimer,,,0,
223545,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DosQuerySysInfo,,true,,,DosQuerySysInfo,,,0,
223552,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fgets,,true,,,fgets,,,0,
223558,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,playlist\playlist_internal.h,playlist\playlist_internal.h:182:182:PL_LOCK_IF:1,,true,182,182,PL_LOCK_IF,,,0,
223562,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,playlist\playlist_internal.h,playlist\playlist_internal.h:188:188:PL_UNLOCK_IF:1,,true,188,188,PL_UNLOCK_IF,,,0,
223566,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,playlist\playlist_internal.h,playlist\playlist_internal.h:138:138:PLAYLIST_DELETE_FORCE:0,,true,138,138,PLAYLIST_DELETE_FORCE,,,0,
223569,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,var_GetAddress,,true,,,var_GetAddress,,,0,
223574,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_dictionary_has_key,,true,,,vlc_dictionary_has_key,,,0,
223579,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,atomic_fetch_add_explicit,,true,,,atomic_fetch_add_explicit,,,0,
223585,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,playlist_ViewPlay,,true,,,playlist_ViewPlay,,,0,
223591,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ARRAY_VAL,,true,,,ARRAY_VAL,,,0,
223596,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TAB_FIND,,true,,,TAB_FIND,,,0,
223603,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,input_item_GetAlbum,,true,,,input_item_GetAlbum,,,0,
223607,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,input_GetState,,true,,,input_GetState,,,0,
223611,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,playlist\playlist_internal.h,playlist\playlist_internal.h:139:139:PLAYLIST_DELETE_STOP_IF_CURRENT:0,,true,139,139,PLAYLIST_DELETE_STOP_IF_CURRENT,,,0,
223614,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_sd_control,,true,,,vlc_sd_control,,,0,
223620,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,playlist\playlist_internal.h,playlist\playlist_internal.h:169:169:PL_DEBUG:1,,true,169,169,PL_DEBUG,,,0,
223623,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,playlist\playlist_internal.h,playlist\playlist_internal.h:173:173:PL_DEBUG2:2,,true,173,173,PL_DEBUG2,,,0,
223626,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strerror_l,,true,,,strerror_l,,,0,
223631,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,mkstemp,,true,,,mkstemp,,,0,
223635,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,readdir,,true,,,readdir,,,0,
223639,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,posix\filesystem.c,posix\filesystem.c:41:41:lstat:2,,true,41,41,lstat,,,0,
223644,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pipe,,true,,,pipe,,,0,
223648,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sigpending,,true,,,sigpending,,,0,
223652,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sigwait,,true,,,sigwait,,,0,
223657,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,posix_spawn_file_actions_init,,true,,,posix_spawn_file_actions_init,,,0,
223661,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,posix_spawn_file_actions_addopen,,true,,,posix_spawn_file_actions_addopen,,,0,
223669,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,posix_spawn_file_actions_adddup2,,true,,,posix_spawn_file_actions_adddup2,,,0,
223675,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,posix_spawn_file_actions_destroy,,true,,,posix_spawn_file_actions_destroy,,,0,
223679,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,posix_spawnattr_init,,true,,,posix_spawnattr_init,,,0,
223683,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,posix_spawnattr_setsigmask,,true,,,posix_spawnattr_setsigmask,,,0,
223688,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,posix_spawnattr_setsigdefault,,true,,,posix_spawnattr_setsigdefault,,,0,
223693,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,posix_spawnattr_setflags,,true,,,posix_spawnattr_setflags,,,0,
223698,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,posix_spawnp,,true,,,posix_spawnp,,,0,
223707,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,posix_spawnattr_destroy,,true,,,posix_spawnattr_destroy,,,0,
223711,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,waitpid,,true,,,waitpid,,,0,
223717,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,posix\rand.c,posix\rand.c:46:46:BLOCK_SIZE:0,,true,46,46,BLOCK_SIZE,,,0,
223720,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,perror,,true,,,perror,,,0,
223724,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,posix\thread.c,posix\thread.c:152:154:VLC_THREAD_ASSERT:1,,true,152,154,VLC_THREAD_ASSERT,,,0,
223727,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_condattr_init,,true,,,pthread_condattr_init,,,0,
223731,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_condattr_destroy,,true,,,pthread_condattr_destroy,,,0,
223735,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sem_init,,true,,,sem_init,,,0,
223741,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sem_destroy,,true,,,sem_destroy,,,0,
223745,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sem_post,,true,,,sem_post,,,0,
223749,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sem_wait,,true,,,sem_wait,,,0,
223753,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,posix\thread.c,posix\thread.c:475:475:VLC_STACKSIZE:0,,true,475,475,VLC_STACKSIZE,,,0,
223756,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,posix\thread.c,posix\thread.c:-1:-1:__FILE__:0,,true,-1,-1,__FILE__,,,0,
223759,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,posix\thread.c,posix\thread.c:-1:-1:__LINE__:0,,true,-1,-1,__LINE__,,,0,
223762,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,atomic_exchange_explicit,,true,,,atomic_exchange_explicit,,,0,
223768,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,net_ConnectUDP,,true,,,net_ConnectUDP,,,0,
223775,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,stream_output\sap.c,stream_output\sap.c:45:45:IPPORT_SAP:0,,true,45,45,IPPORT_SAP,,,0,
223778,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,stream_output\sdp.c,stream_output\sdp.c:39:39:MAXSDPADDRESS:0,,true,39,39,MAXSDPADDRESS,,,0,
223781,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gethostname,,true,,,gethostname,,,0,
223786,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pf_add,,true,,,pf_add,,,0,
223792,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pf_del,,true,,,pf_del,,,0,
223798,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sout_StreamControl,,true,,,sout_StreamControl,,,0,
223804,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sout_StreamFlush,,true,,,sout_StreamFlush,,,0,
223809,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pf_send,,true,,,pf_send,,,0,
223816,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pf_write,,true,,,pf_write,,,0,
223822,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sout_MuxControl,,true,,,sout_MuxControl,,,0,
223828,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pf_addstream,,true,,,pf_addstream,,,0,
223834,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pf_mux,,true,,,pf_mux,,,0,
223839,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pf_delstream,,true,,,pf_delstream,,,0,
223845,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_array_append_or_abort,,true,,,vlc_array_append_or_abort,,,0,
223850,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strtod,,true,,,strtod,,,0,
223855,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strtof,,true,,,strtof,,,0,
223860,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,rewinddir,,true,,,rewinddir,,,0,
223864,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vsnprintf,,true,,,vsnprintf,,,0,
223871,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,localtime_r,,true,,,localtime_r,,,0,
223876,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strftime,,true,,,strftime,,,0,
223883,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,input_GetAout,,true,,,input_GetAout,,,0,
223887,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,text\strings.c,text\strings.c:43:43:strcoll:0,,true,43,43,strcoll,,,0,
223890,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strtoull,,true,,,strtoull,,,0,
223896,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,clz8,,true,,,clz8,,,0,
223900,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,towlower,,true,,,towlower,,,0,
223904,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,memrchr,,true,,,memrchr,,,0,
223910,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vout_display_Pool,,true,,,vout_display_Pool,,,0,
223915,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,control,,true,,,control,,,0,
223922,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,manage,,true,,,manage,,,0,
223927,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,int64_t,,true,,,int64_t,,,0,
223931,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vout_display_SendEventMouseMoved,,true,,,vout_display_SendEventMouseMoved,,,0,
223937,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_mouse_HasPressed,,true,,,vlc_mouse_HasPressed,,,0,
223943,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,video_splitter_Filter,,true,,,video_splitter_Filter,,,0,
223949,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vout_display_Prepare,,true,,,vout_display_Prepare,,,0,
223955,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vout_display_Display,,true,,,vout_display_Display,,,0,
223961,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_mouse_HasMoved,,true,,,vlc_mouse_HasMoved,,,0,
223966,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_mouse_HasButton,,true,,,vlc_mouse_HasButton,,,0,
223971,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_mouse_HasReleased,,true,,,vlc_mouse_HasReleased,,,0,
223977,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,var_SetCoords,,true,,,var_SetCoords,,,0,
223984,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,var_OrInteger,,true,,,var_OrInteger,,,0,
223990,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,var_GetCoords,,true,,,var_GetCoords,,,0,
223997,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,var_ToggleBool,,true,,,var_ToggleBool,,,0,
224002,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,var_NAndInteger,,true,,,var_NAndInteger,,,0,
224008,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_gl_Resize,,true,,,vlc_gl_Resize,,,0,
224014,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gmtime_r,,true,,,gmtime_r,,,0,
224019,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,video_output\video_epg.c,video_output\video_epg.c:91:91:GRADIENT_COLORS:0,,true,91,91,GRADIENT_COLORS,,,0,
224022,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,video_output\vout_spuregion_helper.h,video_output\vout_spuregion_helper.h:27:28:HEX2YUV:1,,true,27,28,HEX2YUV,,,0,
224026,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,video_output\video_epg.c,video_output\video_epg.c:63:63:RGB_COLOR1:0,,true,63,63,RGB_COLOR1,,,0,
224029,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,video_output\video_epg.c,video_output\video_epg.c:59:59:EPGOSD_TEXTSIZE_NAME:0,,true,59,59,EPGOSD_TEXTSIZE_NAME,,,0,
224032,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,video_output\video_epg.c,video_output\video_epg.c:57:57:OSDEPG_ROW:1,,true,57,57,OSDEPG_ROW,,,0,
224036,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,video_output\video_epg.c,video_output\video_epg.c:60:60:EPGOSD_TEXTSIZE_PROG:0,,true,60,60,EPGOSD_TEXTSIZE_PROG,,,0,
224039,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,video_output\video_epg.c,video_output\video_epg.c:56:56:OSDEPG_ROWS:1,,true,56,56,OSDEPG_ROWS,,,0,
224043,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,video_output\video_epg.c,video_output\video_epg.c:61:61:EPGOSD_TEXTSIZE_NTWK:0,,true,61,61,EPGOSD_TEXTSIZE_NTWK,,,0,
224046,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,video_output\video_epg.c,video_output\video_epg.c:44:44:OSDEPG_HEIGHT:0,,true,44,44,OSDEPG_HEIGHT,,,0,
224049,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,video_output\video_epg.c,video_output\video_epg.c:42:42:OSDEPG_PADDING:0,,true,42,42,OSDEPG_PADDING,,,0,
224052,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,video_output\video_epg.c,video_output\video_epg.c:45:45:OSDEPG_LEFT:0,,true,45,45,OSDEPG_LEFT,,,0,
224055,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,video_output\video_epg.c,video_output\video_epg.c:46:46:OSDEPG_TOP:0,,true,46,46,OSDEPG_TOP,,,0,
224058,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,video_output\video_epg.c,video_output\video_epg.c:43:43:OSDEPG_WIDTH:0,,true,43,43,OSDEPG_WIDTH,,,0,
224061,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,video_output\video_epg.c,video_output\video_epg.c:64:64:ARGB_BGCOLOR:0,,true,64,64,ARGB_BGCOLOR,,,0,
224064,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,video_output\video_epg.c,video_output\video_epg.c:51:51:OSDEPG_LOGO_SIZE:0,,true,51,51,OSDEPG_LOGO_SIZE,,,0,
224067,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vout_window_SetState,,true,,,vout_window_SetState,,,0,
224072,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,var_InheritURational,,true,,,var_InheritURational,,,0,
224079,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vout_window_SetSize,,true,,,vout_window_SetSize,,,0,
224085,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vout_display_SendEventDisplaySize,,true,,,vout_display_SendEventDisplaySize,,,0,
224091,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vout_window_HideMouse,,true,,,vout_window_HideMouse,,,0,
224096,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,video_output\video_output.c,video_output\video_output.c:72:72:VOUT_DISPLAY_LATE_THRESHOLD:0,,true,72,72,VOUT_DISPLAY_LATE_THRESHOLD,,,0,
224099,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,video_output\video_output.c,video_output\video_output.c:75:75:VOUT_MWAIT_TOLERANCE:0,,true,75,75,VOUT_MWAIT_TOLERANCE,,,0,
224102,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,video_output\video_output.c,video_output\video_output.c:67:67:VOUT_REDISPLAY_DELAY:0,,true,67,67,VOUT_REDISPLAY_DELAY,,,0,
224105,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vout_window_SetFullScreen,,true,,,vout_window_SetFullScreen,,,0,
224110,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vout_display_SendEventMouseState,,true,,,vout_display_SendEventMouseState,,,0,
224117,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vout_display_SendEventMousePressed,,true,,,vout_display_SendEventMousePressed,,,0,
224122,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vout_display_SendEventMouseReleased,,true,,,vout_display_SendEventMouseReleased,,,0,
224127,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vout_display_SendEventMouseDoubleClick,,true,,,vout_display_SendEventMouseDoubleClick,,,0,
224131,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,video_output\video_widgets.c,video_output\video_widgets.c:42:42:STYLE_FILLED:0,,true,42,42,STYLE_FILLED,,,0,
224134,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,video_output\video_widgets.c,video_output\video_widgets.c:53:57:SET_PALETTE_COLOR:3,,true,53,57,SET_PALETTE_COLOR,,,0,
224138,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,video_output\video_widgets.c,video_output\video_widgets.c:153:153:SLIDER_MARGIN_BASE:0,,true,153,153,SLIDER_MARGIN_BASE,,,0,
224141,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,video_output\video_widgets.c,video_output\video_widgets.c:51:51:COL_FILL_SHADE:0,,true,51,51,COL_FILL_SHADE,,,0,
224144,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,video_output\video_widgets.c,video_output\video_widgets.c:50:50:COL_FILL:0,,true,50,50,COL_FILL,,,0,
224147,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,video_output\video_widgets.c,video_output\video_widgets.c:48:48:COL_TRANSPARENT:0,,true,48,48,COL_TRANSPARENT,,,0,
224150,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,video_output\video_widgets.c,video_output\video_widgets.c:49:49:COL_WHITE:0,,true,49,49,COL_WHITE,,,0,
224153,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,video_output\vout_spuregion_helper.h,video_output\vout_spuregion_helper.h:22:25:RGB2YUV:3,,true,22,25,RGB2YUV,,,0,
224159,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,image_ReadUrl,,true,,,image_ReadUrl,,,0,
224166,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,video_output\vout_subpictures.c,video_output\vout_subpictures.c:52:52:VOUT_MAX_SUBPICTURES:0,,true,52,52,VOUT_MAX_SUBPICTURES,,,0,
224169,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pf_render,,true,,,pf_render,,,0,
224177,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,video_output\vout_subpictures.c,video_output\vout_subpictures.c:290:290:SCALE_UNIT:0,,true,290,290,SCALE_UNIT,,,0,
224180,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,video_output\vout_wrapper.c,video_output\vout_wrapper.c:107:107:DISPLAY_PICTURE_COUNT:0,,true,107,107,DISPLAY_PICTURE_COUNT,,,0,
224183,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,video_output\vout_internal.h,video_output\vout_internal.h:44:44:VOUT_MAX_PICTURES:0,,true,44,44,VOUT_MAX_PICTURES,,,0,
224186,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_inhibit_Set,,true,,,vlc_inhibit_Set,,,0,
224191,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,VirtualQuery,,true,,,VirtualQuery,,,0,
224197,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetModuleFileName,,true,,,GetModuleFileName,,,0,
224203,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,wcsrchr,,true,,,wcsrchr,,,0,
224208,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FromWide,,true,,,FromWide,,,0,
224212,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SHGetFolderPathW,,true,,,SHGetFolderPathW,,,0,
224220,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_tcsrchr,,true,,,_tcsrchr,,,0,
224225,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_tcscpy,,true,,,_tcscpy,,,0,
224230,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TEXT,,true,,,TEXT,,,0,
224234,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetFileAttributes,,true,,,GetFileAttributes,,,0,
224238,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FromT,,true,,,FromT,,,0,
224242,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,win32\error.c,win32\error.c:32:32:WSA_QOS_EUNKNOWNPSOBJ:0,,true,32,32,WSA_QOS_EUNKNOWNPSOBJ,,,0,
224245,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ToWide,,true,,,ToWide,,,0,
224249,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_wopen,,true,,,_wopen,,,0,
224255,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_wmkdir,,true,,,_wmkdir,,,0,
224259,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_wgetcwd,,true,,,_wgetcwd,,,0,
224264,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,wcscmp,,true,,,wcscmp,,,0,
224269,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetLogicalDrives,,true,,,GetLogicalDrives,,,0,
224272,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_wopendir,,true,,,_wopendir,,,0,
224276,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_wreaddir,,true,,,_wreaddir,,,0,
224280,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_wstati64,,true,,,_wstati64,,,0,
224285,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_wunlink,,true,,,_wunlink,,,0,
224289,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_wrename,,true,,,_wrename,,,0,
224294,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_wremove,,true,,,_wremove,,,0,
224298,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_pipe,,true,,,_pipe,,,0,
224304,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ioctlsocket,,true,,,ioctlsocket,,,0,
224310,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetTempPath,,true,,,GetTempPath,,,0,
224315,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetTempFileName,,true,,,GetTempFileName,,,0,
224322,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CreateFile,,true,,,CreateFile,,,0,
224332,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_open_osfhandle,,true,,,_open_osfhandle,,,0,
224337,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CloseHandle,,true,,,CloseHandle,,,0,
224341,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_fdopen,,true,,,_fdopen,,,0,
224346,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_close,,true,,,_close,,,0,
224350,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CoInitializeEx,,true,,,CoInitializeEx,,,0,
224355,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CoUninitialize,,true,,,CoUninitialize,,,0,
224358,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_global_lock,,true,,,vlc_global_lock,,,0,
224362,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,var_CreateGetAddress,,true,,,var_CreateGetAddress,,,0,
224367,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vlc_global_unlock,,true,,,vlc_global_unlock,,,0,
224371,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetLastError,,true,,,GetLastError,,,0,
224374,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FormatMessageW,,true,,,FormatMessageW,,,0,
224384,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MAKELANGID,,true,,,MAKELANGID,,,0,
224389,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,wmemchr,,true,,,wmemchr,,,0,
224395,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,snwprintf,,true,,,snwprintf,,,0,
224402,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetThreadErrorMode,,true,,,SetThreadErrorMode,,,0,
224407,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LoadLibraryExW,,true,,,LoadLibraryExW,,,0,
224413,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FreeLibrary,,true,,,FreeLibrary,,,0,
224417,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetProcAddress,,true,,,GetProcAddress,,,0,
224422,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CryptAcquireContext,,true,,,CryptAcquireContext,,,0,
224430,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CryptGenRandom,,true,,,CryptGenRandom,,,0,
224436,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CryptReleaseContext,,true,,,CryptReleaseContext,,,0,
224441,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WSAStartup,,true,,,WSAStartup,,,0,
224446,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MAKEWORD,,true,,,MAKEWORD,,,0,
224451,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WSACleanup,,true,,,WSACleanup,,,0,
224454,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReleaseMutex,,true,,,ReleaseMutex,,,0,
224458,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WaitForSingleObject,,true,,,WaitForSingleObject,,,0,
224463,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SendMessage,,true,,,SendMessage,,,0,
224470,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InitializeCriticalSection,,true,,,InitializeCriticalSection,,,0,
224474,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DeleteCriticalSection,,true,,,DeleteCriticalSection,,,0,
224478,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EnterCriticalSection,,true,,,EnterCriticalSection,,,0,
224482,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SleepConditionVariableCS,,true,,,SleepConditionVariableCS,,,0,
224488,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LeaveCriticalSection,,true,,,LeaveCriticalSection,,,0,
224492,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TryEnterCriticalSection,,true,,,TryEnterCriticalSection,,,0,
224496,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WakeAllConditionVariable,,true,,,WakeAllConditionVariable,,,0,
224500,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TlsAlloc,,true,,,TlsAlloc,,,0,
224503,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TlsFree,,true,,,TlsFree,,,0,
224507,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TlsSetValue,,true,,,TlsSetValue,,,0,
224512,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetLastError,,true,,,SetLastError,,,0,
224516,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TlsGetValue,,true,,,TlsGetValue,,,0,
224520,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WaitOnAddress,,true,,,WaitOnAddress,,,0,
224527,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WakeByAddressSingle,,true,,,WakeByAddressSingle,,,0,
224531,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WakeByAddressAll,,true,,,WakeByAddressAll,,,0,
224535,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_beginthreadex,,true,,,_beginthreadex,,,0,
224544,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetThreadPriority,,true,,,SetThreadPriority,,,0,
224549,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WaitForSingleObjectEx,,true,,,WaitForSingleObjectEx,,,0,
224555,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetCurrentThreadId,,true,,,GetCurrentThreadId,,,0,
224558,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,atomic_store_explicit,,true,,,atomic_store_explicit,,,0,
224564,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,QueueUserAPC,,true,,,QueueUserAPC,,,0,
224570,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,atomic_load_explicit,,true,,,atomic_load_explicit,,,0,
224575,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_endthreadex,,true,,,_endthreadex,,,0,
224579,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,QueryUnbiasedInterruptTime,,true,,,QueryUnbiasedInterruptTime,,,0,
224583,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetTickCount64,,true,,,GetTickCount64,,,0,
224586,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,anonymous_type_0.timeGetTime,,true,,,timeGetTime,,,0,
224590,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,QueryPerformanceCounter,,true,,,QueryPerformanceCounter,,,0,
224594,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetSystemTimePreciseAsFileTime,,true,,,GetSystemTimePreciseAsFileTime,,,0,
224598,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MMRESULT (WINAPI * timeBeginPeriod),,true,,,MMRESULT (WINAPI * timeBeginPeriod),,,0,
224603,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MMRESULT,,true,,,MMRESULT,,,0,
224607,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LoadLibrary,,true,,,LoadLibrary,,,0,
224611,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,anonymous_type_2.timeGetDevCaps,,true,,,timeGetDevCaps,,,0,
224617,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,timeBeginPeriod,,true,,,timeBeginPeriod,,,0,
224621,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,QueryPerformanceFrequency,,true,,,QueryPerformanceFrequency,,,0,
224625,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetNativeSystemInfo,,true,,,GetNativeSystemInfo,,,0,
224629,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetPriorityClass,,true,,,SetPriorityClass,,,0,
224634,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetCurrentProcess,,true,,,GetCurrentProcess,,,0,
224637,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,win32\thread.c,win32\thread.c:1024:1024:ABOVE_NORMAL_PRIORITY_CLASS:0,,true,1024,1024,ABOVE_NORMAL_PRIORITY_CLASS,,,0,
224640,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InitializeConditionVariable,,true,,,InitializeConditionVariable,,,0,
224644,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DeleteTimerQueueTimer,,true,,,DeleteTimerQueueTimer,,,0,
224650,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CreateTimerQueueTimer,,true,,,CreateTimerQueueTimer,,,0,
